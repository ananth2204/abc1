{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011640000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 3233230, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 58, "INMDSNAM": "CBT.V500.FILE282.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 3233230, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 3233230, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE282.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x006\\r'", "DS1TRBAL": "b'-\\xd2'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\xf2\\x00\\x0e\\x01\\xf6\\x00\\x08\\x007'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$CALL": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x14\\x00\\x14\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n&LABEL  $CALL  &NAME\n         LCLC  &LNAME\n         AIF   ('&LABEL' EQ '').SKIP01\n&LABEL   DS    0H\n.SKIP01  ANOP\n         AIF   ('&NAME' EQ '').MNOTE01\n         AIF   ('&NAME'(1,1) EQ '(').SKIP02\n&LNAME   SETC  'V&NAME'            ENTRY NAME OF ROUTINE\n&LNAME   SETC  '&LNAME'(1,8)       ASSEMBLER SPECIFICATIONS\n         LA    15,&LNAME-SCRICVT   GET ENTRY OFFSET OF ROUTINE\n         BAL   6,SCVTENT           BRANCH TO ENTRY SEQUENCE\n         MEXIT\n.SKIP02  AIF   ('&NAME' EQ '(R15)').SKIP03\n         LR    15,&NAME            GET ENTRY OFFSET OF ROUTINE\n.SKIP03  ANOP\n         BAL   6,SCVTENTR          BRANCH TO REG ENTRY SEQUENCE\n         MEXIT\n.MNOTE01 MNOTE 8,'$CALL  --  MISSING ROUTINE NAME TO CALL'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$CC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x14\\x00\\x14\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n&LABEL  $CC    &COND\n         AIF   ('&LABEL' EQ '').SKIP01\n&LABEL   DS    0H\n.SKIP01  AIF   ('&COND' NE 'OMIT').SKIP02\n         TM    *+1,X'01'           SET COND CODE 1\n         MEXIT\n.SKIP02  AIF   ('&COND' NE 'POS').SKIP03\n         CLI   *,X'94'             SET COND CODE 2\n         MEXIT\n.SKIP03  AIF   ('&COND' NE 'NEG').SKIP04\n         CLI   *,X'96'             SET COND CODE 4\n         MEXIT\n.SKIP04  AIF   ('&COND' NE 'DNO').SKIP05\n         CLI   *,X'95'             SET COND CODE 8\n         MEXIT\n.SKIP05  MNOTE 8,'$COND  --  INVALID PARM ''&COND''.'\n         BCR   0,0\n         BCR   0,0\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$COPYWRT": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x1d\\x00\\x1d\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "CBT249"}, "text": "         SPACE\n***********************************************************************\n*                                                                     *\n*        THIS VERSION OF SCRIPT COMES FROM THE UNIVERSITY             *\n*        OF WATERLOO.  IT IS A LOCALLY MODIFIED VERSION OF            *\n*        THE PROGRAMME \"NSCRIPT\", WHICH IS AVAILABLE FROM             *\n*        THE \"SHARE\" PROGRAMME LIBRARY.                               *\n*                                                                     *\n*        THIS PRODUCT IS FREE OF CHARGE FOR A DISTRIBUTION FEE        *\n*        WITH NO WARRANTY, EXPRESSED OR IMPLIED ON OUR PART.          *\n*        IT MAY BE FREELY SUBDISTRIBUTED AT YOUR DISCRETION.          *\n*                                                                     *\n*        HOWEVER, WE ASK THAT A DESCRIPTION OF ANY MODIFICATIONS      *\n*        OR EXTENSIONS TO THE SOURCE BE REPORTED TO US AND            *\n*        THAT THOSE SOURCE MODS BE MADE AVAILABLE, IF                 *\n*        POSSIBLE, SO THAT OTHER USERS OF THIS PRODUCT                *\n*        MAY BENEFIT.                                                 *\n*                                                                     *\n*        QUESTIONS AND MODS SHOULD BE SENT TO:                        *\n*                                                                     *\n*              MRS. SANDRA WARD                                       *\n*              COMPUTING CENTRE                                       *\n*              UNIVERSITY OF WATERLOO                                 *\n*              WATERLOO, ONTARIO                                      *\n*              CANADA                                                 *\n*                  N2L 3G1                                            *\n*                                                                     *\n***********************************************************************\n         SPACE\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$ENTER": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00 \\x00 \\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n&LABEL  $ENTER ,\n         GBLB  &USPUSH\n         GBLC  &SCRSECT,&TRPSECT\n         LCLC  &CLABEL,&LLABEL,&LLABEL7\n&LLABEL  SETC  '&LABEL'\n         AIF   ('&LLABEL' NE '').SKIP01\n         MNOTE 8,'$ENTER -- MISSING LABEL'\n&LLABEL  SETC  '$ENT&SYSNDX'\n.SKIP01  ANOP\n         DS    0D                  WHERE WE ARE NOW\nSCRIPT&SCRSECT CSECT ,\n&CLABEL  SETC  '&LLABEL'\n         AIF   ('&SCRSECT' NE '&TRPSECT').SKIP02\n&CLABEL  SETC  '$&TRPSECT&SYSNDX'\n         AGO   .SKIP03\n.SKIP02  ANOP\n&LLABEL7 SETC  '&LLABEL'(1,7)\n         ORG   A&SCRSECT.SCRIP+V&LLABEL7-V&SCRSECT.SCRIP\n.SKIP03  ANOP\n         DC    A(&CLABEL)          ROUTINE ENTRY ADDRESS\n         ORG   ,\n&CLABEL  CSECT ,\n         AIF   (NOT &USPUSH).SKIP04\n         POP   USING               RESTORE GLOBAL USING STATUS\n.SKIP04  ANOP\n         PUSH  USING               SAVE GLOBAL USING STATUS\n&USPUSH  SETB  (1)\n         DC    CL4'SCRW'           PREFIX IDENTIFIER\n         DC    CL8'&LLABEL'        FOR DUMP READERS\n         USING &CLABEL,BASE2       AND TELL THE ASSEMBLER\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$EXIT": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x1c\\x00\\x1c\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n&LABEL  $EXIT  &KEEP=,&RC=\n         LCLA  &I\n&I       SETA  N'&KEEP\n         AIF   ('&LABEL' EQ '').SKIP01\n&LABEL   DS    0H\n.SKIP01  AIF   (&I LE 0).SKIP04\n         AIF   ('&KEEP(&I)' EQ 'R15').SKIP02\n         ST    &KEEP(&I),4*&KEEP(&I).(,BASESAVE)  SAVE KEEP REGISTER\n         AGO   .SKIP03\n.SKIP02  ANOP\n         MNOTE 1,'$EXIT  --  R15 USED AS KEEP'\n.SKIP03  ANOP\n&I       SETA  &I-1\n         AGO   .SKIP01\n.SKIP04  AIF   ('&RC' NE '').SKIP05\n         MNOTE 1,'$EXIT  --  MISSING RETURN CODE'\n         AGO   .SKIP07\n.SKIP05  AIF   ('&RC'(1,1) EQ '(').SKIP06\n         LA    R15,&RC             RETURN CODE\n         AGO   .SKIP07\n.SKIP06  ANOP\n         AIF   ('&RC' EQ '(R15)').SKIP07\n         LR    R15,&RC             RETURN CODE\n.SKIP07  ANOP\n         LM    0,14,0(BASESAVE)    RESTORE CALLER'S REGISTERS\n         BR    6                   RETURN TO CALLER\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$FOTERM": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x005\\x005\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n        $FOTERM &HORIZ=,&VERT=,&SUP=,&SUB=,                            *\n               &TAB=,&VMI=,&HMI=,&NLF=\n         LCLA      &I\nFOT&SYSNDX DC  (TDEVLEN/4)F'0'      INITIAL SETTING TO ZERO\n         AIF   ('&HORIZ' EQ '').SKIP01\n         ORG   FOT&SYSNDX+TDEVRESH-TDEVBEG\n         DC    A(&HORIZ)           HORIZONTAL RESOLUTION\n.SKIP01  AIF   ('&VERT' EQ '').SKIP02\n         ORG   FOT&SYSNDX+TDEVRESV-TDEVBEG\n         DC    A(&VERT)            VERTICAL RESOLUTION\n.SKIP02  AIF   ('&SUP' EQ '').SKIP03\n         ORG   FOT&SYSNDX+TDEVSUP-TDEVBEG\n         DC    AL1(FOT&SYSNDX.A-*-2)\n         DC    AL1&SUP             SUPERSCRIPT\nFOT&SYSNDX.A EQU *\n.SKIP03  AIF   ('&SUB' EQ '').SKIP04\n         ORG   FOT&SYSNDX+TDEVSUB-TDEVBEG\n         DC    AL1(FOT&SYSNDX.B-*-2)\n         DC    AL1&SUB             SUBSCRIPT\nFOT&SYSNDX.B EQU *\n.SKIP04  AIF   ('&TAB' EQ '').SKIP05\n         ORG   FOT&SYSNDX+TDEVTAB-TDEVBEG\n         DC    AL1(FOT&SYSNDX.C-*-2)\n         DC    AL1&TAB             TAB TO COLUMN\nFOT&SYSNDX.C EQU *\n.SKIP05  AIF   ('&VMI' EQ '').SKIP06\n         ORG   FOT&SYSNDX+TDEVVMI-TDEVBEG\n         DC    AL1(FOT&SYSNDX.D-*-2)\n         DC    AL1&VMI             VERTICAL MOVEMENT\nFOT&SYSNDX.D EQU *\n.SKIP06  AIF   ('&HMI' EQ '').SKIP07\n         ORG   FOT&SYSNDX+TDEVHMI-TDEVBEG\n         DC    AL1(FOT&SYSNDX.E-*-2)\n         DC    AL1&HMI             HORIZONTAL MOVEMENT\nFOT&SYSNDX.E EQU *\n.SKIP07  AIF   ('&NLF' EQ '').SKIP08\n         ORG   FOT&SYSNDX+TDEVNLF-TDEVBEG\n         DC    AL1(FOT&SYSNDX.F-*-2)\n         DC    AL1&NLF             NEGATIVE LINE FEED\nFOT&SYSNDX.F EQU *\n.SKIP08  ANOP\n&I       SETA  1\n.SKIP09  AIF   (&I GT N'&SYSLIST).SKIP11\n         AIF   ('&SYSLIST(&I)' EQ '').SKIP10\n         ORG   FOT&SYSNDX+TDEVAESC-TDEVBEG+&SYSLIST(&I,1)\n         DC    AL1(&SYSLIST(&I,2)-1)    LENGTH-1 OF ESCAPE STRING\n.SKIP10  ANOP\n&I       SETA  &I+1\n         AGO   .SKIP09\n.SKIP11  ANOP\n         ORG   ,\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$HEAD": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x02\\x80\\x02\\x80\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 640, "newlines": 640, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n        $HEAD  &STRING,           STRING IS EXPANDED                   *\n               &BLOCK=YES,        STRING IS TO BE BLOCKED              *\n               &TITLE=            (A,'B') -GEN TITLE STATEMENT WITH    *\n                                  NAME FIELD A, AND TITLE 'B'\n.*\n.*  THIS MACRO COPIED & ALTERED FROM 'MIM#3' WRITTEN BY C. J. GOELZ\n.*\n         LCLB  &HEADB\n         LCLC  &HEADC(497)\n         LCLA  &I\n         LCLA  &J\n         LCLA  &K\n         LCLA  &L\n         LCLA  &M\n         LCLA  &N\n         LCLC  &F(64)\n         LCLC  &STR(64)\n         LCLC  &B\n         LCLC  &W\n.*\n.*\n         AIF   (&HEADB).PROC\n&HEADB   SETB  (1)\n&HEADC(1)    SETC  ' '\n&HEADC(2)    SETC  '        '\n&HEADC(3)    SETC  '        '\n&HEADC(4)    SETC  '        '\n&HEADC(5)    SETC  '        '\n&HEADC(6)    SETC  '        '\n&HEADC(7)    SETC  '        '\n&HEADC(8)    SETC  '        '\n&HEADC(9)    SETC  '        '\n&HEADC(10)   SETC  'A'\n&HEADC(11)   SETC  '    A   '\n&HEADC(12)   SETC  '   AAA  '\n&HEADC(13)   SETC  '  AA AA '\n&HEADC(14)   SETC  ' AA   AA'\n&HEADC(15)   SETC  ' AA   AA'\n&HEADC(16)   SETC  ' AAAAAAA'\n&HEADC(17)   SETC  ' AA   AA'\n&HEADC(18)   SETC  ' AA   AA'\n&HEADC(19)   SETC  'B'\n&HEADC(20)   SETC  ' BBBBBB '\n&HEADC(21)   SETC  ' BB   BB'\n&HEADC(22)   SETC  ' BB   BB'\n&HEADC(23)   SETC  ' BBBBBB '\n&HEADC(24)   SETC  ' BB   BB'\n&HEADC(25)   SETC  ' BB   BB'\n&HEADC(26)   SETC  ' BB   BB'\n&HEADC(27)   SETC  ' BBBBBB '\n&HEADC(28)   SETC  'C'\n&HEADC(29)   SETC  '  CCCCC '\n&HEADC(30)   SETC  ' CC   CC'\n&HEADC(31)   SETC  ' CC   CC'\n&HEADC(32)   SETC  ' CC     '\n&HEADC(33)   SETC  ' CC     '\n&HEADC(34)   SETC  ' CC   CC'\n&HEADC(35)   SETC  ' CC   CC'\n&HEADC(36)   SETC  '  CCCCC '\n&HEADC(37)   SETC  'D'\n&HEADC(38)   SETC  ' DDDDDD '\n&HEADC(39)   SETC  ' DD   DD'\n&HEADC(40)   SETC  ' DD   DD'\n&HEADC(41)   SETC  ' DD   DD'\n&HEADC(42)   SETC  ' DD   DD'\n&HEADC(43)   SETC  ' DD   DD'\n&HEADC(44)   SETC  ' DD   DD'\n&HEADC(45)   SETC  ' DDDDDD '\n&HEADC(46)   SETC  'E'\n&HEADC(47)   SETC  ' EEEEEE '\n&HEADC(48)   SETC  ' EE     '\n&HEADC(49)   SETC  ' EE     '\n&HEADC(50)   SETC  ' EEEE   '\n&HEADC(51)   SETC  ' EE     '\n&HEADC(52)   SETC  ' EE     '\n&HEADC(53)   SETC  ' EE     '\n&HEADC(54)   SETC  ' EEEEEEE'\n&HEADC(55)   SETC  'F'\n&HEADC(56)   SETC  ' FFFFFFF'\n&HEADC(57)   SETC  ' FF     '\n&HEADC(58)   SETC  ' FF     '\n&HEADC(59)   SETC  ' FFFFF  '\n&HEADC(60)   SETC  ' FF     '\n&HEADC(61)   SETC  ' FF     '\n&HEADC(62)   SETC  ' FF     '\n&HEADC(63)   SETC  ' FF     '\n&HEADC(64)   SETC  'G'\n&HEADC(65)   SETC  '  GGGGG '\n&HEADC(66)   SETC  ' GG   GG'\n&HEADC(67)   SETC  ' GG   GG'\n&HEADC(68)   SETC  ' GG     '\n&HEADC(69)   SETC  ' GG  GGG'\n&HEADC(70)   SETC  ' GG   GG'\n&HEADC(71)   SETC  ' GG   GG'\n&HEADC(72)   SETC  '  GGGGG '\n&HEADC(73)   SETC  'H'\n&HEADC(74)   SETC  ' HH   HH'\n&HEADC(75)   SETC  ' HH   HH'\n&HEADC(76)   SETC  ' HH   HH'\n&HEADC(77)   SETC  ' HHHHHHH'\n&HEADC(78)   SETC  ' HH   HH'\n&HEADC(79)   SETC  ' HH   HH'\n&HEADC(80)   SETC  ' HH   HH'\n&HEADC(81)   SETC  ' HH   HH'\n&HEADC(82)   SETC  'I'\n&HEADC(83)   SETC  '  IIII  '\n&HEADC(84)   SETC  '   II   '\n&HEADC(85)   SETC  '   II   '\n&HEADC(86)   SETC  '   II   '\n&HEADC(87)   SETC  '   II   '\n&HEADC(88)   SETC  '   II   '\n&HEADC(89)   SETC  '   II   '\n&HEADC(90)   SETC  '  IIII  '\n&HEADC(91)   SETC  'J'\n&HEADC(92)   SETC  '      JJ'\n&HEADC(93)   SETC  '      JJ'\n&HEADC(94)   SETC  '      JJ'\n&HEADC(95)   SETC  '      JJ'\n&HEADC(96)   SETC  '      JJ'\n&HEADC(97)   SETC  ' JJ   JJ'\n&HEADC(98)   SETC  ' JJ   JJ'\n&HEADC(99)   SETC  '  JJJJJ '\n&HEADC(100)  SETC  'K'\n&HEADC(101)  SETC  ' KK   KK'\n&HEADC(102)  SETC  ' KK  KK '\n&HEADC(103)  SETC  ' KK KK  '\n&HEADC(104)  SETC  ' KKKK   '\n&HEADC(105)  SETC  ' KKKK   '\n&HEADC(106)  SETC  ' KK KK  '\n&HEADC(107)  SETC  ' KK  KK '\n&HEADC(108)  SETC  ' KK   KK'\n&HEADC(109)  SETC  'L'\n&HEADC(110)  SETC  ' LL     '\n&HEADC(111)  SETC  ' LL     '\n&HEADC(112)  SETC  ' LL     '\n&HEADC(113)  SETC  ' LL     '\n&HEADC(114)  SETC  ' LL     '\n&HEADC(115)  SETC  ' LL     '\n&HEADC(116)  SETC  ' LL     '\n&HEADC(117)  SETC  ' LLLLLLL'\n&HEADC(118)  SETC  'M'\n&HEADC(119)  SETC  ' M     M'\n&HEADC(120)  SETC  ' MM   MM'\n&HEADC(121)  SETC  ' MMM MMM'\n&HEADC(122)  SETC  ' MMMMMMM'\n&HEADC(123)  SETC  ' MM M MM'\n&HEADC(124)  SETC  ' MM   MM'\n&HEADC(125)  SETC  ' MM   MM'\n&HEADC(126)  SETC  ' MM   MM'\n&HEADC(127)  SETC  'N'\n&HEADC(128)  SETC  ' NN   NN'\n&HEADC(129)  SETC  ' NNN  NN'\n&HEADC(130)  SETC  ' NNN  NN'\n&HEADC(131)  SETC  ' NNNN NN'\n&HEADC(132)  SETC  ' NN NNNN'\n&HEADC(133)  SETC  ' NN  NNN'\n&HEADC(134)  SETC  ' NN  NNN'\n&HEADC(135)  SETC  ' NN   NN'\n&HEADC(136)  SETC  'O'\n&HEADC(137)  SETC  '  OOOOO '\n&HEADC(138)  SETC  ' OO   OO'\n&HEADC(139)  SETC  ' OO   OO'\n&HEADC(140)  SETC  ' OO   OO'\n&HEADC(141)  SETC  ' OO   OO'\n&HEADC(142)  SETC  ' OO   OO'\n&HEADC(143)  SETC  ' OO   OO'\n&HEADC(144)  SETC  '  OOOOO '\n&HEADC(145)  SETC  'P'\n&HEADC(146)  SETC  ' PPPPPP '\n&HEADC(147)  SETC  ' PP   PP'\n&HEADC(148)  SETC  ' PP   PP'\n&HEADC(149)  SETC  ' PP   PP'\n&HEADC(150)  SETC  ' PPPPPP '\n&HEADC(151)  SETC  ' PP     '\n&HEADC(152)  SETC  ' PP     '\n&HEADC(153)  SETC  ' PP     '\n&HEADC(154)  SETC  'Q'\n&HEADC(155)  SETC  '  QQQQQ '\n&HEADC(156)  SETC  ' QQ   QQ'\n&HEADC(157)  SETC  ' QQ   QQ'\n&HEADC(158)  SETC  ' QQ   QQ'\n&HEADC(159)  SETC  ' QQ Q QQ'\n&HEADC(160)  SETC  ' QQ  QQQ'\n&HEADC(161)  SETC  ' QQ   QQ'\n&HEADC(162)  SETC  '  QQQQQQ'\n&HEADC(163)  SETC  'R'\n&HEADC(164)  SETC  ' RRRRRR '\n&HEADC(165)  SETC  ' RR   RR'\n&HEADC(166)  SETC  ' RR   RR'\n&HEADC(167)  SETC  ' RR   RR'\n&HEADC(168)  SETC  ' RRRRRR '\n&HEADC(169)  SETC  ' RR RR  '\n&HEADC(170)  SETC  ' RR  RR '\n&HEADC(171)  SETC  ' RR   RR'\n&HEADC(172)  SETC  'S'\n&HEADC(173)  SETC  '  SSSSS '\n&HEADC(174)  SETC  ' SS   SS'\n&HEADC(175)  SETC  ' SS     '\n&HEADC(176)  SETC  '  SSSSS '\n&HEADC(177)  SETC  '      SS'\n&HEADC(178)  SETC  ' SS   SS'\n&HEADC(179)  SETC  ' SS   SS'\n&HEADC(180)  SETC  '  SSSSS '\n&HEADC(181)  SETC  'T'\n&HEADC(182)  SETC  'TTTTTTTT'\n&HEADC(183)  SETC  '   TT   '\n&HEADC(184)  SETC  '   TT   '\n&HEADC(185)  SETC  '   TT   '\n&HEADC(186)  SETC  '   TT   '\n&HEADC(187)  SETC  '   TT   '\n&HEADC(188)  SETC  '   TT   '\n&HEADC(189)  SETC  '   TT   '\n&HEADC(190)  SETC  'U'\n&HEADC(191)  SETC  ' UU   UU'\n&HEADC(192)  SETC  ' UU   UU'\n&HEADC(193)  SETC  ' UU   UU'\n&HEADC(194)  SETC  ' UU   UU'\n&HEADC(195)  SETC  ' UU   UU'\n&HEADC(196)  SETC  ' UU   UU'\n&HEADC(197)  SETC  ' UU   UU'\n&HEADC(198)  SETC  '  UUUUU '\n&HEADC(199)  SETC  'V'\n&HEADC(200)  SETC  ' VV   VV'\n&HEADC(201)  SETC  ' VV   VV'\n&HEADC(202)  SETC  ' VV   VV'\n&HEADC(203)  SETC  ' VV   VV'\n&HEADC(204)  SETC  ' VV   VV'\n&HEADC(205)  SETC  '  VV VV '\n&HEADC(206)  SETC  '   VVV  '\n&HEADC(207)  SETC  '    V   '\n&HEADC(208)  SETC  'W'\n&HEADC(209)  SETC  ' WW   WW'\n&HEADC(210)  SETC  ' WW   WW'\n&HEADC(211)  SETC  ' WW   WW'\n&HEADC(212)  SETC  ' WW   WW'\n&HEADC(213)  SETC  ' WW W WW'\n&HEADC(214)  SETC  ' WWWWWWW'\n&HEADC(215)  SETC  ' WWW WWW'\n&HEADC(216)  SETC  '  W   W '\n&HEADC(217)  SETC  'X'\n&HEADC(218)  SETC  ' XX   XX'\n&HEADC(219)  SETC  ' XX   XX'\n&HEADC(220)  SETC  '  XX XX '\n&HEADC(221)  SETC  '   XXX  '\n&HEADC(222)  SETC  '   XXX  '\n&HEADC(223)  SETC  '  XX XX '\n&HEADC(224)  SETC  ' XX   XX'\n&HEADC(225)  SETC  ' XX   XX'\n&HEADC(226)  SETC  'Y'\n&HEADC(227)  SETC  ' YY   YY'\n&HEADC(228)  SETC  ' YY   YY'\n&HEADC(229)  SETC  ' YY   YY'\n&HEADC(230)  SETC  '  YY YY '\n&HEADC(231)  SETC  '   YYY  '\n&HEADC(232)  SETC  '   YY   '\n&HEADC(233)  SETC  '   YY   '\n&HEADC(234)  SETC  '   YY   '\n&HEADC(235)  SETC  'Z'\n&HEADC(236)  SETC  ' ZZZZZZZ'\n&HEADC(237)  SETC  '      ZZ'\n&HEADC(238)  SETC  '     ZZ '\n&HEADC(239)  SETC  '    ZZ  '\n&HEADC(240)  SETC  '   ZZ   '\n&HEADC(241)  SETC  '  ZZ    '\n&HEADC(242)  SETC  ' ZZ     '\n&HEADC(243)  SETC  ' ZZZZZZZ'\n&HEADC(244)  SETC  '1'\n&HEADC(245)  SETC  '    1   '\n&HEADC(246)  SETC  '   11   '\n&HEADC(247)  SETC  '    1   '\n&HEADC(248)  SETC  '    1   '\n&HEADC(249)  SETC  '    1   '\n&HEADC(250)  SETC  '    1   '\n&HEADC(251)  SETC  '    1   '\n&HEADC(252)  SETC  '   111  '\n&HEADC(253)  SETC  '2'\n&HEADC(254)  SETC  '   222  '\n&HEADC(255)  SETC  '  2   2 '\n&HEADC(256)  SETC  '      2 '\n&HEADC(257)  SETC  '      2 '\n&HEADC(258)  SETC  '   222  '\n&HEADC(259)  SETC  '  2     '\n&HEADC(260)  SETC  '  2     '\n&HEADC(261)  SETC  '  22222 '\n&HEADC(262)  SETC  '3'\n&HEADC(263)  SETC  '   333  '\n&HEADC(264)  SETC  '  3   3 '\n&HEADC(265)  SETC  '      3 '\n&HEADC(266)  SETC  '    33  '\n&HEADC(267)  SETC  '      3 '\n&HEADC(268)  SETC  '  3   3 '\n&HEADC(269)  SETC  '  3   3 '\n&HEADC(270)  SETC  '   333  '\n&HEADC(271)  SETC  '4'\n&HEADC(272)  SETC  '     4  '\n&HEADC(273)  SETC  '    44  '\n&HEADC(274)  SETC  '   4 4  '\n&HEADC(275)  SETC  '  4  4  '\n&HEADC(276)  SETC  ' 444444 '\n&HEADC(277)  SETC  '     4  '\n&HEADC(278)  SETC  '     4  '\n&HEADC(279)  SETC  '     4  '\n&HEADC(280)  SETC  '5'\n&HEADC(281)  SETC  '  55555 '\n&HEADC(282)  SETC  '  5     '\n&HEADC(283)  SETC  '  5     '\n&HEADC(284)  SETC  '  5555  '\n&HEADC(285)  SETC  '      5 '\n&HEADC(286)  SETC  '  5   5 '\n&HEADC(287)  SETC  '  5   5 '\n&HEADC(288)  SETC  '   555  '\n&HEADC(289)  SETC  '6'\n&HEADC(290)  SETC  '   666  '\n&HEADC(291)  SETC  '  6   6 '\n&HEADC(292)  SETC  '  6     '\n&HEADC(293)  SETC  '  6666  '\n&HEADC(294)  SETC  '  6   6 '\n&HEADC(295)  SETC  '  6   6 '\n&HEADC(296)  SETC  '  6   6 '\n&HEADC(297)  SETC  '   666  '\n&HEADC(298)  SETC  '7'\n&HEADC(299)  SETC  '  77777 '\n&HEADC(300)  SETC  '      7 '\n&HEADC(301)  SETC  '      7 '\n&HEADC(302)  SETC  '     7  '\n&HEADC(303)  SETC  '    7   '\n&HEADC(304)  SETC  '   7    '\n&HEADC(305)  SETC  '   7    '\n&HEADC(306)  SETC  '   7    '\n&HEADC(307)  SETC  '8'\n&HEADC(308)  SETC  '   888  '\n&HEADC(309)  SETC  '  8   8 '\n&HEADC(310)  SETC  '  8   8 '\n&HEADC(311)  SETC  '   888  '\n&HEADC(312)  SETC  '  8   8 '\n&HEADC(313)  SETC  '  8   8 '\n&HEADC(314)  SETC  '  8   8 '\n&HEADC(315)  SETC  '   888  '\n&HEADC(316)  SETC  '9'\n&HEADC(317)  SETC  '   999  '\n&HEADC(318)  SETC  '  9   9 '\n&HEADC(319)  SETC  '  9   9 '\n&HEADC(320)  SETC  '  9   9 '\n&HEADC(321)  SETC  '   9999 '\n&HEADC(322)  SETC  '      9 '\n&HEADC(323)  SETC  '  9   9 '\n&HEADC(324)  SETC  '   999  '\n&HEADC(325)  SETC  '0'\n&HEADC(326)  SETC  '   000  '\n&HEADC(327)  SETC  '  0   0 '\n&HEADC(328)  SETC  '  0   0 '\n&HEADC(329)  SETC  '  0   0 '\n&HEADC(330)  SETC  '  0   0 '\n&HEADC(331)  SETC  '  0   0 '\n&HEADC(332)  SETC  '  0   0 '\n&HEADC(333)  SETC  '   000  '\n&HEADC(334)  SETC  '$'\n&HEADC(335)  SETC  '    $   '\n&HEADC(336)  SETC  '  $$$$$ '\n&HEADC(337)  SETC  ' $$ $ $$'\n&HEADC(338)  SETC  ' $$ $   '\n&HEADC(339)  SETC  '  $$$$$ '\n&HEADC(340)  SETC  '    $ $$'\n&HEADC(341)  SETC  ' $$ $ $$'\n&HEADC(342)  SETC  '  $$$$$ '\n&HEADC(343)  SETC  '#'\n&HEADC(344)  SETC  '  ## ## '\n&HEADC(345)  SETC  '  ## ## '\n&HEADC(346)  SETC  ' #######'\n&HEADC(347)  SETC  '  ## ## '\n&HEADC(348)  SETC  '  ## ## '\n&HEADC(349)  SETC  ' #######'\n&HEADC(350)  SETC  '  ## ## '\n&HEADC(351)  SETC  '  ## ## '\n&HEADC(352)  SETC  '@'\n&HEADC(353)  SETC  '  @@@@@ '\n&HEADC(354)  SETC  ' @     @'\n&HEADC(355)  SETC  ' @  @@ @'\n&HEADC(356)  SETC  ' @ @ @ @'\n&HEADC(357)  SETC  '  @  @ @'\n&HEADC(358)  SETC  ' @   @ @'\n&HEADC(359)  SETC  ' @   @ @'\n&HEADC(360)  SETC  '  @@@ @ '\n&HEADC(361)  SETC  ','\n&HEADC(362)  SETC  '        '\n&HEADC(363)  SETC  '        '\n&HEADC(364)  SETC  '        '\n&HEADC(365)  SETC  '        '\n&HEADC(366)  SETC  '   ,,   '\n&HEADC(367)  SETC  '   ,,   '\n&HEADC(368)  SETC  '    ,   '\n&HEADC(369)  SETC  '   ,    '\n&HEADC(370)  SETC  '.'\n&HEADC(371)  SETC  '        '\n&HEADC(372)  SETC  '        '\n&HEADC(373)  SETC  '        '\n&HEADC(374)  SETC  '        '\n&HEADC(375)  SETC  '        '\n&HEADC(376)  SETC  '   ..   '\n&HEADC(377)  SETC  '   ..   '\n&HEADC(378)  SETC  '        '\n&HEADC(379)  SETC  '('\n&HEADC(380)  SETC  '    (   '\n&HEADC(381)  SETC  '   (    '\n&HEADC(382)  SETC  '  (     '\n&HEADC(383)  SETC  '  (     '\n&HEADC(384)  SETC  '  (     '\n&HEADC(385)  SETC  '  (     '\n&HEADC(386)  SETC  '   (    '\n&HEADC(387)  SETC  '    (   '\n&HEADC(388)  SETC  ')'\n&HEADC(389)  SETC  '   )    '\n&HEADC(390)  SETC  '    )   '\n&HEADC(391)  SETC  '     )  '\n&HEADC(392)  SETC  '     )  '\n&HEADC(393)  SETC  '     )  '\n&HEADC(394)  SETC  '     )  '\n&HEADC(395)  SETC  '    )   '\n&HEADC(396)  SETC  '   )    '\n&HEADC(397)  SETC  '+'\n&HEADC(398)  SETC  '        '\n&HEADC(399)  SETC  '    +   '\n&HEADC(400)  SETC  '    +   '\n&HEADC(401)  SETC  '    +   '\n&HEADC(402)  SETC  ' +++++++'\n&HEADC(403)  SETC  '    +   '\n&HEADC(404)  SETC  '    +   '\n&HEADC(405)  SETC  '    +   '\n&HEADC(406)  SETC  '/'\n&HEADC(407)  SETC  '       /'\n&HEADC(408)  SETC  '      / '\n&HEADC(409)  SETC  '     /  '\n&HEADC(410)  SETC  '    /   '\n&HEADC(411)  SETC  '   /    '\n&HEADC(412)  SETC  '  /     '\n&HEADC(413)  SETC  ' /      '\n&HEADC(414)  SETC  '/       '\n&HEADC(415)  SETC  '\"'\n&HEADC(416)  SETC  '   \"\"   '\n&HEADC(417)  SETC  '   \"\"   '\n&HEADC(418)  SETC  '    \"   '\n&HEADC(419)  SETC  '   \"    '\n&HEADC(420)  SETC  '        '\n&HEADC(421)  SETC  '        '\n&HEADC(422)  SETC  '        '\n&HEADC(423)  SETC  '        '\n&HEADC(424)  SETC  '-'\n&HEADC(425)  SETC  '        '\n&HEADC(426)  SETC  '        '\n&HEADC(427)  SETC  '        '\n&HEADC(428)  SETC  '        '\n&HEADC(429)  SETC  ' -------'\n&HEADC(430)  SETC  '        '\n&HEADC(431)  SETC  '        '\n&HEADC(432)  SETC  '        '\n&HEADC(433)  SETC  '*'\n&HEADC(434)  SETC  '        '\n&HEADC(435)  SETC  '  *   * '\n&HEADC(436)  SETC  '   * *  '\n&HEADC(437)  SETC  ' *******'\n&HEADC(438)  SETC  '   * *  '\n&HEADC(439)  SETC  '  *   * '\n&HEADC(440)  SETC  '        '\n&HEADC(441)  SETC  '        '\n&HEADC(442)  SETC  'END'           MARKS END OF THE CHARACTER LIST\n.PROC    ANOP  ,\n.*\n.*\n         AIF   (K'&TITLE LE 0).NTITL\n.*\n         AIF   ('&TITLE' NE 'EJECT').NEJEC\n         EJECT\n         AGO   .NTITL\n.*\n.NEJEC   ANOP\n&TITLE(1) TITLE &TITLE(2)\n.*\n.*\n.NTITL   ANOP\n.*\n.*\n&K       SETA  K'&STRING\n         AIF   ((&K EQ 0) OR (&K GT 64)).DONE\n.*\n.*\n         AIF   ('&BLOCK' EQ 'NO').NBLK1\n MNOTE   '**************************************************************\n               **********'\n&B       SETC  '*'\n.NBLK1   ANOP  ,\n.*\n.*\n.*\n&M       SETA  1\n.COPY2   ANOP  ,\n&STR(&M) SETC  '&STRING'(&M,1)\n&M       SETA  &M+1\n         AIF   (&M LE &K).COPY2\n.*\n&J       SETA  0\n&M       SETA  0\n.*\n.*\n.EDIT    AIF   (&M EQ &K).AGIN\n&M       SETA  &M+1\n&I       SETA  &M\n         AIF   ('&STR(&M)' NE '''').EDIT\n.*\n         AIF   (&J GT 0).QTCK\n.*\n&J       SETA  1\n         AGO   .COMP\n.*\n.*\n.QTCK    AIF   ('&STR(&M+1)' NE '''').COMP\n.*\n&STR(&M) SETC  '\"'\n&J       SETA  0\n&M       SETA  &M+1\n&I       SETA  &M\n.*\n.*\n.COMP    ANOP\n&STR(&I) SETC  '&STR(&I+1)'\n&I       SETA  &I+1\n         AIF   (&I LT &K).COMP\n.*\n&STR(&K) SETC  ' '\n&K       SETA  &K-1\n&M       SETA  &M-1\n         AGO   .EDIT\n.*\n.*\n.AGIN    ANOP\n&I       SETA  1\n&L       SETA  &K-&N\n         AIF   (&L LE 0).ENDOFF\n.*\n         AIF   (&L LE 8).CK4\n.*\n&L       SETA  8\n.*\n.*\n.CK4     ANOP\n&J       SETA  (8-&L)/2*8\n.*\n.*\n.FILT    AIF   (&I GT &J).SETL\n.*\n&F(&I)   SETC  '        '\n&F(&I+1) SETC  '        '\n&F(&I+2) SETC  '        '\n&F(&I+3) SETC  '        '\n&F(&I+4) SETC  '        '\n&F(&I+5) SETC  '        '\n&F(&I+6) SETC  '        '\n&F(&I+7) SETC  '        '\n&I       SETA  &I+8\n         AGO   .FILT\n.*\n.*\n.SETL    ANOP\n&L       SETA  &L+&N\n.*\n.*\n.LOOP    AIF   (&N EQ &L).FINI\n.*\n&N       SETA  &N+1\n&J       SETA  1\n&W       SETC  '&STR(&N)'\n.*\n.*\n.MTCH    AIF   ('&W' EQ '&HEADC(&J)').GO\n.*\n&J       SETA  &J+9\n         AIF   ('&HEADC(&J)' NE 'END').MTCH\n&J       SETA  &J-9\n.*\n.*\n.GO      ANOP\n.*\n&F(&I)   SETC  '&HEADC(&J+1)'\n&F(&I+1) SETC  '&HEADC(&J+2)'\n&F(&I+2) SETC  '&HEADC(&J+3)'\n&F(&I+3) SETC  '&HEADC(&J+4)'\n&F(&I+4) SETC  '&HEADC(&J+5)'\n&F(&I+5) SETC  '&HEADC(&J+6)'\n&F(&I+6) SETC  '&HEADC(&J+7)'\n&F(&I+7) SETC  '&HEADC(&J+8)'\n&I       SETA  &I+8\n         AGO   .LOOP\n.*\n.*\n.FINI    AIF   (&I GT 64).DOIT\n.*\n&F(&I)   SETC  '        '\n&F(&I+1) SETC  '        '\n&F(&I+2) SETC  '        '\n&F(&I+3) SETC  '        '\n&F(&I+4) SETC  '        '\n&F(&I+5) SETC  '        '\n&F(&I+6) SETC  '        '\n&F(&I+7) SETC  '        '\n&I       SETA  &I+8\n         AGO   .FINI\n.*\n.*\n.DOIT    AIF   ('&BLOCK' EQ 'NO').SPACE\n MNOTE   '*                                                            *\n                        *'\n MNOTE   '*                                                            *\n                        *'\n         AGO   .DOIT2\n.SPACE   ANOP   ,\n         SPACE 2\n.DOIT2   ANOP  ,\n MNOTE   '&B  &F(1)&F(9)&F(17)&F(25)&F(33)&F(41)&F(49)&F(57)   &B'\n MNOTE   '&B  &F(2)&F(10)&F(18)&F(26)&F(34)&F(42)&F(50)&F(58)   &B'\n MNOTE   '&B  &F(3)&F(11)&F(19)&F(27)&F(35)&F(43)&F(51)&F(59)   &B'\n MNOTE   '&B  &F(4)&F(12)&F(20)&F(28)&F(36)&F(44)&F(52)&F(60)   &B'\n MNOTE   '&B  &F(5)&F(13)&F(21)&F(29)&F(37)&F(45)&F(53)&F(61)   &B'\n MNOTE   '&B  &F(6)&F(14)&F(22)&F(30)&F(38)&F(46)&F(54)&F(62)   &B'\n MNOTE   '&B  &F(7)&F(15)&F(23)&F(31)&F(39)&F(47)&F(55)&F(63)   &B'\n MNOTE   '&B  &F(8)&F(16)&F(24)&F(32)&F(40)&F(48)&F(56)&F(64)   &B'\n         AGO   .AGIN\n.*\n.*\n.ENDOFF  AIF   ('&BLOCK' EQ 'NO').DONE\n MNOTE   '*                                                            *\n                        *'\n MNOTE   '*                                                            *\n                        *'\n MNOTE   '**************************************************************\n               **********'\n.*\n.*\n.DONE    ANOP\n         SPACE 3\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$IFANY": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00+\\x00+\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 43, "newlines": 43, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n&LABEL  $IFANY     &BYTE,&FLAG,&BRANCH\n.*       BUILT TO HANDLE TEN SWITCHES, BUT RESTRICTED TO THREE\n         LCLA      &I,&J,&K,&C(10)\n         LCLC      &R,&TC,&A(150)\n         AIF       ('&LABEL' EQ '').SKIP01\n&LABEL   DS        0H\n.SKIP01  AIF       ('&BYTE' EQ '').MNOTE01\n&I       SETA      N'&FLAG\n         AIF       (&I LT 1 OR &I GT 3).MNOTE02\n.SKIP02  ANOP\n&TC      SETC      T'&FLAG(&I)\n&J       SETA      0\n         AIF       ('&TC' LT '0').SKIP03\n&J       SETA      &TC\n.SKIP03  ANOP\n&K       SETA  &J*15+&C(&J+1)+1\n         AIF   (&C(&J+1) EQ 0).SKIP04\n&A(&K)   SETC  '+'\n&C(&J+1) SETA  &C(&J+1)+1\n&K       SETA  &K+1\n.SKIP04  ANOP\n&A(&K)   SETC  '&FLAG(&I)'\n&C(&J+1) SETA  &C(&J+1)+1\n&I       SETA      &I-1\n         AIF       (&I GT 0).SKIP02\n&I       SETA      9\n.SKIP05  ANOP\n&K       SETA  &I*15+1\n         AIF   ('&A(&K)' EQ '').SKIP06\n         TM    &BYTE.+&I,&A(&K).&A(&K+1).&A(&K+2).&A(&K+3).&A(&K+4)\n         AIF   ('&BRANCH'(1,2) EQ '*N').SKIP06\n         AIF   ('&BRANCH'(1,1) NE '(').SKIP05A\n&R       SETC  'R'\n.SKIP05A BNZ&R &BRANCH\n.SKIP06  ANOP\n&I       SETA      &I-1\n         AIF       (&I GE 0).SKIP05\n         MEXIT\n.MNOTE01 MNOTE     4,'$IFANY  --  MISSING FIRST PARAMETER'\n         MEXIT\n.MNOTE02 MNOTE     4,'$IFANY  --  INVALID SECOND PARAMETER'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$IFNONE": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00+\\x00+\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 43, "newlines": 43, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n&LABEL  $IFNONE    &BYTE,&FLAG,&BRANCH,&OP=BZ\n.*       BUILT TO HANDLE TEN SWITCHES, BUT RESTRICTED TO THREE\n         LCLA      &I,&J,&K,&C(10)\n         LCLC      &R,&TC,&A(150)\n         AIF       ('&LABEL' EQ '').SKIP01\n&LABEL   DS        0H\n.SKIP01  AIF       ('&BYTE' EQ '').MNOTE01\n&I       SETA      N'&FLAG\n         AIF       (&I LT 1 OR &I GT 3).MNOTE02\n.SKIP02  ANOP\n&TC      SETC      T'&FLAG(&I)\n&J       SETA      0\n         AIF       ('&TC' LT '0').SKIP03\n&J       SETA      &TC\n.SKIP03  ANOP\n&K       SETA  &J*15+&C(&J+1)+1\n         AIF   (&C(&J+1) EQ 0).SKIP04\n&A(&K)   SETC  '+'\n&C(&J+1) SETA  &C(&J+1)+1\n&K       SETA  &K+1\n.SKIP04  ANOP\n&A(&K)   SETC  '&FLAG(&I)'\n&C(&J+1) SETA  &C(&J+1)+1\n&I       SETA      &I-1\n         AIF       (&I GT 0).SKIP02\n&I       SETA      9\n.SKIP05  ANOP\n&K       SETA  &I*15+1\n         AIF   ('&A(&K)' EQ '').SKIP06\n         TM    &BYTE.+&I,&A(&K).&A(&K+1).&A(&K+2).&A(&K+3).&A(&K+4)\n         AIF   ('&BRANCH'(1,2) EQ '*N').SKIP06\n         AIF   ('&BRANCH'(1,1) NE '(').SKIP05A\n&R       SETC  'R'\n.SKIP05A &OP&R &BRANCH\n.SKIP06  ANOP\n&I       SETA      &I-1\n         AIF       (&I GE 0).SKIP05\n         MEXIT\n.MNOTE01 MNOTE     4,'$IFNONE  --  MISSING FIRST PARAMETER'\n         MEXIT\n.MNOTE02 MNOTE     4,'$IFNONE  --  INVALID SECOND PARAMETER'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$IFOFF": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00+\\x00+\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 43, "newlines": 43, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n&LABEL  $IFOFF     &BYTE,&FLAG,&BRANCH,&OP=BNO\n.*       BUILT TO HANDLE TEN SWITCHES, BUT RESTRICTED TO THREE\n         LCLA      &I,&J,&K,&C(10)\n         LCLC      &R,&TC,&A(150)\n         AIF       ('&LABEL' EQ '').SKIP01\n&LABEL   DS        0H\n.SKIP01  AIF       ('&BYTE' EQ '').MNOTE01\n&I       SETA      N'&FLAG\n         AIF       (&I LT 1 OR &I GT 3).MNOTE02\n.SKIP02  ANOP\n&TC      SETC      T'&FLAG(&I)\n&J       SETA      0\n         AIF       ('&TC' LT '0').SKIP03\n&J       SETA      &TC\n.SKIP03  ANOP\n&K       SETA  &J*15+&C(&J+1)+1\n         AIF   (&C(&J+1) EQ 0).SKIP04\n&A(&K)   SETC  '+'\n&C(&J+1) SETA  &C(&J+1)+1\n&K       SETA  &K+1\n.SKIP04  ANOP\n&A(&K)   SETC  '&FLAG(&I)'\n&C(&J+1) SETA  &C(&J+1)+1\n&I       SETA      &I-1\n         AIF       (&I GT 0).SKIP02\n&I       SETA      9\n.SKIP05  ANOP\n&K       SETA  &I*15+1\n         AIF   ('&A(&K)' EQ '').SKIP06\n         TM    &BYTE.+&I,&A(&K).&A(&K+1).&A(&K+2).&A(&K+3).&A(&K+4)\n         AIF   ('&BRANCH'(1,2) EQ '*N').SKIP06\n         AIF   ('&BRANCH'(1,1) NE '(').SKIP05A\n&R       SETC  'R'\n.SKIP05A &OP&R &BRANCH\n.SKIP06  ANOP\n&I       SETA      &I-1\n         AIF       (&I GE 0).SKIP05\n         MEXIT\n.MNOTE01 MNOTE     4,'$IFOFF  --  MISSING FIRST PARAMETER'\n         MEXIT\n.MNOTE02 MNOTE     4,'$IFOFF  --  INVALID SECOND PARAMETER'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$IFON": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00+\\x00+\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 43, "newlines": 43, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n&LABEL  $IFON      &BYTE,&FLAG,&BRANCH\n.*       BUILT TO HANDLE TEN SWITCHES, BUT RESTRICTED TO THREE\n         LCLA      &I,&J,&K,&C(10)\n         LCLC      &R,&TC,&A(150)\n         AIF       ('&LABEL' EQ '').SKIP01\n&LABEL   DS        0H\n.SKIP01  AIF       ('&BYTE' EQ '').MNOTE01\n&I       SETA      N'&FLAG\n         AIF       (&I LT 1 OR &I GT 3).MNOTE02\n.SKIP02  ANOP\n&TC      SETC      T'&FLAG(&I)\n&J       SETA      0\n         AIF       ('&TC' LT '0').SKIP03\n&J       SETA      &TC\n.SKIP03  ANOP\n&K       SETA  &J*15+&C(&J+1)+1\n         AIF   (&C(&J+1) EQ 0).SKIP04\n&A(&K)   SETC  '+'\n&C(&J+1) SETA  &C(&J+1)+1\n&K       SETA  &K+1\n.SKIP04  ANOP\n&A(&K)   SETC  '&FLAG(&I)'\n&C(&J+1) SETA  &C(&J+1)+1\n&I       SETA      &I-1\n         AIF       (&I GT 0).SKIP02\n&I       SETA      9\n.SKIP05  ANOP\n&K       SETA  &I*15+1\n         AIF   ('&A(&K)' EQ '').SKIP06\n         TM    &BYTE.+&I,&A(&K).&A(&K+1).&A(&K+2).&A(&K+3).&A(&K+4)\n         AIF   ('&BRANCH'(1,2) EQ '*N').SKIP06\n         AIF   ('&BRANCH'(1,1) NE '(').SKIP05A\n&R       SETC  'R'\n.SKIP05A BO&R  &BRANCH\n.SKIP06  ANOP\n&I       SETA      &I-1\n         AIF       (&I GE 0).SKIP05\n         MEXIT\n.MNOTE01 MNOTE     4,'$IFON  --  MISSING FIRST PARAMETER'\n         MEXIT\n.MNOTE02 MNOTE     4,'$IFON  --  INVALID SECOND PARAMETER'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$LINECTL": {"ttr": 783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n&LABEL  $LINECTL &WHAT,&WHO\n         AIF   ('&LABEL' EQ '').SKIP01\n&LABEL   DS    0H\n.SKIP01  AIF   ('&WHAT' EQ '' OR '&WHO' EQ '').MNOTE01\n         AIF   ('&WHAT'(1,1) NE '(').SKIP02\n         STC   &WHAT,PRNTRCC       INSERT ASA CARRIAGE CONTROL\n         AGO   .SKIP03\n.SKIP02  MVI   PRNTRCC,&WHAT       INSERT ASA CARRIAGE CONTROL\n.SKIP03  LA    R0,BLNKLINE         POINT TO BLANK LINE\n        $CALL  &WHO                GO TO OUTPUT ROUTINE\n         MEXIT\n.MNOTE01 MNOTE 4,'$LINECTL -- MISSING ARGUMENT(S)'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$LOGERR": {"ttr": 785, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n&LABEL  $LOGERR    &CODE\n         AIF   ('&LABEL' EQ '').SKIP01\n&LABEL   DS    0H\n.SKIP01  ANOP\n         AIF   ('&CODE' EQ '').MNOTE01\n         MVI   EFLAG998,ERRTERM    TERMINAL ERROR\n         MVI   RETCODE,X'&CODE'/256     HALF OF ERROR CODE\n         MVI   RETCODE+1,X'&CODE'-X'&CODE'/256*256  SECOND HALF\n         EX    R0,*                0C3 TAKES US TO SPIE\n         MEXIT\n.MNOTE01 MNOTE 8,'$LOGERR -- MISSING ERROR CODE.'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MSGSECT": {"ttr": 787, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x87\\x00\\x87\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 135, "newlines": 135, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n&LABEL  $MSGSECT &A,&B,&DOC=NOGEN,&TYPE=\n         LCLA  &N,&I\n         LCLC  &C\n&N       SETA  61\n         AIF   ('&TYPE' EQ 'FLAG').FLAG01\n         AIF   ('&TYPE' EQ 'MSG').MSG01\n         AIF   ('&A' NE '' AND '&B' NE '').TEXT01\n         MNOTE 8,'$MSGSECT -- INVALID ARGUMENTS.'\n         MEXIT\n.FLAG01  ANOP\nERRFLGS  DC    XL(&N+3)'00'        ERROR FLAGS\n&I       SETA  0\n.FLAG02  ANOP\n&C       SETC  '&I'\n         AIF   (&I GE 100).FLAG04\n         AIF   (&I GE 10).FLAG03\n&C       SETC  '0&C'\n.FLAG03  ANOP\n&C       SETC  '0&C'\n.FLAG04  ANOP\nEFLAG&C  EQU   ERRFLGS+&I\n&I       SETA  &I+1\n         AIF   (&I LE &N).FLAG02\nEFLAG998 EQU   ERRFLGS+&N+1\nEFLAG999 EQU   ERRFLGS+&N+2\n         MEXIT\n.*\n.*\n.MSG01   ANOP\n         PUSH  PRINT\n         PRINT &DOC\n***********************************************************************\n*                                                                     *\n*              ERROR MESSAGES                                         *\n*                                                                     *\n***********************************************************************\n         SPACE\n&LABEL   DS    0H\n         SPACE\n*        THE START OF MESSAGE AREA CONTAINS A TABLE OF TWO BYTE\n*        OFFSETS, CORRESPONDING TO BYTE OFFSETS IN 'ERRFLGS'.\n*\n*        THESE OFFSETS POINT TO A BYTE CONTAINING LENGTH-1\n*        OF MESSAGE TEXT THAT FOLLOWS IMMEDIATELY.\n         SPACE\n&I       SETA 0\n.MSG02   ANOP\n&C       SETC  '&I'\n         AIF   (&I GE 100).MSG04\n         AIF   (&I GE 10).MSG03\n&C       SETC  '0&C'\n.MSG03   ANOP\n&C       SETC  '0&C'\n.MSG04   ANOP\n         DC    AL2(ERR&C.M-&LABEL)      ERROR OFFSET\n&I       SETA  &I+1\n         AIF   (&I LE &N).MSG02\n         DC    AL2(ERR998M-&LABEL)      OFFSET OF LOGIC ERROR\n         DC    AL2(ERR999M-&LABEL)      OFFSET OF SPIE ERROR\n.*\n        $MSGSECT 000,'UNUSED'\n        $MSGSECT 001,'UNRECOGNIZABLE CODES IN PARM FIELD'\n        $MSGSECT 002,'OUTPUT FILE (SYSPRINT) CANNOT BE OPENED'\n        $MSGSECT 003,'OMITTED CONTROL WORD PARAMETER'\n        $MSGSECT 004,'UNDEFINED CONTROL WORD'\n        $MSGSECT 005,'ILLEGAL CONTROL WORD PARAMETER VALUE'\n        $MSGSECT 006,'OMITTED CONTROL WORD TERMINATION'\n        $MSGSECT 007,'TOO MANY REFERENCE NAMES'\n        $MSGSECT 008,'REFERENCE NAME OR ARGUMENT TOO LONG'\n        $MSGSECT 009,'LOOP IN REFERENCE NAME SUBSTITUTION'\n        $MSGSECT 010,'OUTPUT LINE HAS ZERO WIDTH'\n        $MSGSECT 011,'SAVE/RESTORE STATUS STACK ERROR'\n        $MSGSECT 012,'ILLEGAL PLACEMENT OF CONTROL WORD'\n        $MSGSECT 013,'CONTROL WORD PARAMETER TOO BIG'\n        $MSGSECT 014,'CONTROL WORD PARAMETER TOO SMALL'\n        $MSGSECT 015,'MISMATCHED DELIMITER ON STRING'\n        $MSGSECT 016,'HANGING INDENT INVALID'\n        $MSGSECT 017,'MACRO/REMOTE NAME UNDEFINED'\n        $MSGSECT 018,'INSUFFICIENT STORAGE FOR MACRO/REMOTE'\n        $MSGSECT 019,'TOO MANY RECORDS IN ONE MACRO/REMOTE'\n        $MSGSECT 020,'EXCESSIVE NUMBER OF LINE ELEMENTS'\n        $MSGSECT 021,'BACKSPACE BEFORE COLUMN ONE'\n        $MSGSECT 022,'.IF NESTING TOO DEEP'\n        $MSGSECT 023,'.TH OR .EL NOT AFTER .IF'\n        $MSGSECT 024,'WORKING STORAGE EXHAUSTED'\n        $MSGSECT 025,'DUPLICATE LABEL'\n        $MSGSECT 026,'FORWARD .GO TARGET NOT FOUND'\n        $MSGSECT 027,'BACKWARD .GO TARGET NOT FOUND'\n        $MSGSECT 028,'INCORRECT PLACEMENT OF .DO OR .EN'\n        $MSGSECT 029,'POSITIONAL PARAMETER ASSUMED'\n        $MSGSECT 030,'HYPHEN DELETE WORD NOT FOUND'\n        $MSGSECT 031,'INVALID WORD TO HYPHENATE'\n        $MSGSECT 032,'TOO MANY HYPHEN BREAK POINTS'\n        $MSGSECT 033,'HYPHEN WORD TOO LONG'\n        $MSGSECT 034,'TOO MANY QUEUED LINES FOR '\n        $MSGSECT 035,'CONTROL WORD PARAMETER SHOULD BE NUMERIC'\n        $MSGSECT 036,'UNUSED'\n        $MSGSECT 037,'HEADNOTE TOO LONG FOR PAGE'\n        $MSGSECT 038,'INVALID SUBSCRIPT'\n        $MSGSECT 039,'INVALID SUBSTRING'\n        $MSGSECT 040,'INVALID CONDITION OPERATOR IN .IF'\n        $MSGSECT 041,'.HM + .HS GREATER THAN .TM'\n        $MSGSECT 042,'.FM + .FS GREATER THAN .BM'\n        $MSGSECT 043,'ILLEGAL CONTROL WORD WITHIN KEEP OR FOOTNOTE'\n        $MSGSECT 044,'GENERATED INPUT LINE TOO LONG'\n        $MSGSECT 045,'.TM + .BM TOO BIG FOR .PL'\n        $MSGSECT 046,'UNUSED'\n        $MSGSECT 047,'UNUSED'\n        $MSGSECT 048,'UNUSED'\n        $MSGSECT 049,'UNUSED'\n        $MSGSECT 050,'.ER '\n        $MSGSECT 051,'FILE NOT FOUND'\n        $MSGSECT 052,'FILE NOT PARTITIONED, MEMBER NAME IGNORED'\n        $MSGSECT 053,'BUFFER STORAGE UNAVAILABLE, FILE SKIPPED'\n        $MSGSECT 054,'RECORD FORMAT NOT SUPPORTED, FILE SKIPPED'\n        $MSGSECT 055,'INVALID INPUT RECORD, FILE SKIPPED'\n        $MSGSECT 056,'I/O ERROR'\n        $MSGSECT 057,'SCRIPT -- SYSTERM FAILED TO OPEN'\n        $MSGSECT 058,'UNABLE TO OPEN WORK FILE'\n        $MSGSECT 059,'UNUSED'\n        $MSGSECT 060,'UNUSED'\n        $MSGSECT 061,'UNUSED'\n        $MSGSECT 998,'A LOGIC ERROR HAS BEEN DETECTED'\n        $MSGSECT 999,'A PROGRAM CHECK HAS OCCURRED'\n         POP   PRINT\n         MEXIT\n.*\n.*\n.TEXT01  ANOP\n&C       SETC  '&A'.'*  '\n&I       SETA  K'&B+K'&C-2\n         SPACE\nERR&A.M  DC    AL1(&I),C'&C',C&B,C'.'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MVC": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\t\\x00\\t\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n&LABEL  $MVC   &A1,&A2\n         LCLC  &LEN\n         AIF   ('&A1' EQ '' OR '&A2' EQ '').MNOTE1\n&LEN     SETC  'L'''\n&LABEL   MVC   &A1.(&LEN&A2),&A2   MOVE DATA\n         MEXIT\n.MNOTE1  MNOTE 8,'$MVC      OMITTED PARAMETER'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$NSCDAT": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x03\\xe8\\x03\\xe8\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 1000, "newlines": 1000, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n        $NSCDAT &DSECT=NO,&DOC=NOGEN\n         PUSH  PRINT\n         PRINT &DOC\n         AIF   ('&DSECT' EQ 'NO').SKP01\nNSCDAT   DSECT\n         AGO   .SKP02\n.SKP01   ANOP\nNSCDAT   CSECT ,                   START OF COMMON DATA AREA\n.SKP02   ANOP\n         PUSH  USING               SAVE REGISTER STATUS\n         DROP  ,                   RELEASE ALL REGISTERS\n         USING NSCDAT,R13          COMMON WORK AREA\n         SPACE\n***********************************************************************\n*                                                                     *\n*              SAVE AREA AND CONSTANTS                                *\n*                                                                     *\n***********************************************************************\n         SPACE\nSAVEAREA DC    18F'0'              OS SAVE AREA\nPATCH    DC    20S(*)              PATCH AREA\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              SCRIPT CVT COMMON ROUTINE AREA                         *\n*                                                                     *\n***********************************************************************\n         SPACE\nSCVTENT  A     R15,VSCRICVT        POINT TO ENTRY ADDRESS\n         L     R15,0(,R15)         GET ROUTINE ENTRY ADDRESS\nSCVTENTR DS    0H\n        $SAVE  ,                   SAVE CALLER'S REGISTERS\n         LR    BASE2,R15           TRANSFER ENTRY ADDRESS\nSCVTENY  B     SCVTDSLN(,BASE2)    ENTRY SEQUENCE COMPLETE\n*        ABOVE BRANCH NOPPED IF FULLSTAT\n         L     BASE2,SCVTCCNT-SCVTDSCT(,R15) ROUTINE CALL COUNT\n         LA    BASE2,1(,BASE2)               PLUS ONE\n         ST    BASE2,SCVTCCNT-SCVTDSCT(,R15) UPDATE CALL COUNT\n         LR    BASE2,R15           TRANSFER ENTRY ADDRESS\nSCVTENZ  B     SCVTDSLN(,BASE2)    ENTRY SEQUENCE COMPLETE\n*        ZAP ABOVE BRANCH TO NOP IN DESPERATION\n         OI    SCVTENZ+1,X'F0'     CLOSE THE PRINT GATE\n         MVC   SCVTENN,SCVTCSCT-SCVTDSCT(BASE2)  ENTER ROUTINE NAME\n         LA    R0,SCVTENM          POINT TO SHORT DISPLAY RECORD\n        $CALL  PUTTERM             DISPLAY THE RESULT\n         NI    SCVTENZ+1,X'0F'     REOPEN THE PRINT GATE\n         LM    R0,R15,0(BASESAVE)  REGISTERS AS THEY WERE AT ENTRY\n         LR    BASE2,R15           TRANSFER BASE REG\n         B     SCVTDSLN(,BASE2)    ENTRY SEQUENCE COMPLETE\n         SPACE\nSCVTENM  DC    0H'0',AL2(5+L'SCVTENN,0),C' '\nSCVTENN  DC    CL8'********'\n         EJECT\n***********************************************************************\n*                                                                     *\n*              CONSTANTS                                              *\n*                                                                     *\n***********************************************************************\n         SPACE\nFM8      DC    F'-8'               MINUS EIGHT\nFM4      DC    F'-4'               MINUS FOUR\nF0       DC    F'0'                FULLWORD ZERO\nH0       EQU   F0+2                HALFWORD ZERO\nF1       DC    F'1'                FULLWORD ONE\nH1       EQU   F1+2                HALFWORD ONE\nF2       DC    F'2'                FULLWORD TWO\nH2       EQU   F2+2                HALFWORD TWO\nF3       DC    F'3'                FULLWORD THREE\nH3       EQU   F3+2                HALFWORD THREE\nF4       DC    F'4'                FULLWORD FOUR\nH4       EQU   F4+2                HALFWORD FOUR\nF5       DC    F'5'                FULLWORD FIVE\nH5       EQU   F5+2                HALFWORD FIVE\nF6       DC    F'6'                FULLWORD SIX\nH6       EQU   F6+2                HALFWORD SIX\nF7       DC    F'7'                FULLWORD SEVEN\nH7       EQU   F7+2                HALFWORD SEVEN\nF8       DC    F'8'                FULLWORD EIGHT\nH8       EQU   F8+2                HALFWORD EIGHT\nF9       DC    F'9'                FULLWORD NINE\nH9       EQU   F9+2                HALFWORD NINE\nF10      DC    F'10'               FULLWORD TEN\nH10      EQU   F10+2               HALFWORD TEN\nF11      DC    F'11'               FULLWORD ELEVEN\nH11      EQU   F11+2               HALFWORD ELEVEN\nF12      DC    F'12'               FULLWORD TWELVE\nH12      EQU   F12+2               HALFWORD TWELVE\nF15      DC    F'15'               FULLWORD FIFTEEN\nH15      EQU   F15+2               HALFWORD FIFTEEN\nF30      DC    F'30'               FULLWORD THIRTY\nH30      EQU   F30+2               HALFWORD THIRTY\nH60      DC    H'60'               HALFWORD SIXTY\nH132     DC    H'132'              HALFWORD ONE-THIRTY-TWO\nF255     DC    F'255'              FULLWORD TWO FIFTY-FIVE\nF256     DC    F'256'              FULLWORD TWO FIFTY-SIX\nF4096    DC    F'4096'             FULLWORD FOUR K\nF32767   DC    F'32767'            FULLWORD 32K-1\nH32767   EQU   F32767+2            LARGEST POSITIVE HALFWORD\nFM32768  DC    F'-32768'           FULLWORD -32K\nHM32768  EQU   FM32768+2           LARGEST NEGATIVE HALFWORD\nF16MEG   DC    A(X'1000000')       SIXTEEN MEGABYTES\n         DC    F'0'                    UNUSED\n         DC    F'0'                    UNUSED\n         DC    F'0'                    UNUSED\n         SPACE\n         DC    0D'0'               FOR BLANKS ALIGNMENT\nBLANKS   DC    CL240' '            BLANKS FOR ALL PURPOSES\n         EJECT\n***********************************************************************\n*                                                                     *\n*              SCRIPTW CONSTANT AREA                                  *\n*                                                                     *\n***********************************************************************\n         SPACE\nADBASE   DC    V(SCRIPTW)          SCRIPT FIRST BASE\nVMAIN    DC    V(MAIN)             SCRIPT MAIN LOOPING POINT\nVSCRICVT DC    V(SCRICVT)          SCRIPT COMMUNICATION VECTOR TABLE\nVSCRLAST DC    A(*-*)              HIGHEST ROUTINE ADDRESS\nVTRUEEND DC    V(TRUEEND)          SCRIPT FINAL EOF ROUTINE\nWRETDC   EQU   4                   DON'T COUNT ENCOUNTERED RETCODE\nWRETNR   EQU   8                   ANOTHER RECORD NOW PRESENT RETCODE\nWRETQT   EQU   12                  FINAL RECORD RETCODE\nWRETQQ   EQU   16                  IMMEDIATE FINAL RECORD RETCODE\nWRETSU   EQU   20                  SUBSTITUTE ANOTHER RECORD RETCODE\nWRETLI   EQU   24                  REPROCESS LITERALLY\nWRETPA   EQU   28                  FINAL PAGE RETCODE\n         SPACE\n         DC    A(*-*)\n         DC    A(*-*)\n         DC    A(*-*)\n         EJECT\n***********************************************************************\n*                                                                     *\n*              DEFAULT PARM VALUES FOR KEYWORDS                       *\n*                                                                     *\n***********************************************************************\n         SPACE\nTAB3DEF  EQU   0                   THE DEFAULT VALUE\nTAB3MIN  EQU   4                   THE MINIMUM VALUE\nTAB3MAX  EQU   8                   THE MAXIMUM VALUE\n         SPACE\nDEFAULTS DC    0F'0'\nDEFLL    DC    A(60,10,144)        LINE LENGTH\nDEFPL    DC    A(66,10,176)        PAGE LENGTH\nDEFTM    DC    A(6,0,33)           TOP MARGIN\nDEFBM    DC    A(6,0,33)           BOTTOM MARGIN\nDEFHDMG  DC    A(1,0,33)           HEADING MARGIN\nDEFFTMG  DC    A(1,0,33)           FOOTING MARGIN\nDEFPAGS  DC    A(1,1,32767)        PAGE NUMBER TO START PRINTING\nDEFPAGL  DC    A(32767,1,32767)    PAGE NUMBER TO QUIT PRINTING\nDEFADJ   DC    A(0,0,50)           ADJUST COUNT\nDEFNUM   DC    A(1,0,100)          NUMBER COLUMN OFFSET\nDEFFFCH  DC    A(1,1,9)            SKIP TO CHANNEL FOR PAGE ALIGN\nDEFFFTO  DC    A(3,1,175)          PAGE LINE NUMBER OF SKIP TO CHANNEL\nDEFFNSIZ DC    A(200,1,32767)      MAX BUFFERED FOOTNOTE LINES\nDEFRMSIZ DC    A(200,1,32767)      MAX RECORDS PER REMOTE\nDEFHSFS  DC    A(9,2,HSFSCT)       HEADING/FOOTING SPACE OVERLAP\nDEFRNLEN DC    A(150,4,240)        SET REFERENCE MAX CHAR LENGTH\nDEFLNUM  DC    A(0,0,125)          LINE NUMBER COLUMN OFFSET\nDEFSEQC  DC    A(240,0,240)        INPUT SEQUENCE NUMBER COLUMN\nDEFPASOF DC    A(1,1,10)           NUMBER OF PASSES\nDEFDARK  DC    A(1,1,10)           OFFLINE DARK OPTION\nDEFTRSH  DC    A(5,0,32767)        HYPHENATION THRESHOLD\nDEFMNPT  DC    A(3,0,32767)        HYPHENATION START MINIMUM\nDEFENDPT DC    A(3,0,32767)        HYPHENATION END MINIMUM\nDEFCONT  DC    A(0,0,32767)        ERROR CONTINUE\nDEFTABL  DC    A(0,0,1)            LEFT TAB ADJUST VALUE\nDEFHYSUP DC    A(3,0,32767)        HYPHENATION LINE SUPPRESS\nDEFCPI   DC    A(10,4,18)          CHARACTERS PER INCH\nDEFLPI   DC    A(6,2,15)           OUTPUT LINES PER INCH\n         DC    A(*-*,*-*,*-*)          UNUSED\n         DC    A(*-*,*-*,*-*)          UNUSED\n         DC    A(*-*,*-*,*-*)          UNUSED\n         EJECT\n***********************************************************************\n*                                                                     *\n*              ADCONS                                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nIOCBPRT  DC    A(*-*)              SYSPRINT IOCB POINTER\nIOCBTERM DC    A(*-*)              SYSTERM IOCB POINTER\n         SPACE\nINDEXS   DC    V(CTLTAB),A(SPCTLL),V(CTLTABN)     CONTROL WORD POINTERS\nSPCTLI   EQU   0,2                 INITIAL CONTROL WORD\nSPCTLW   EQU   2,2                 WORKING CONTROL WORD\nSPCTLO   EQU   4,2                 BRANCH OFFSET\nSPCTLC   EQU   6,2                 STATISTICS COUNT\nSPCTLL   EQU   8,8                 LENGTH OF ONE ENTRY\n         SPACE\nTRANAD   DC    A(*-*)              WORKING I/O TRANSLATE TABLE ADDR\nTRANADI  DC    A(TRANTABI)         INPUT TRANSLATE TABLE\nTRANADO  DC    A(TRANTABO)         OUTPUT TRANSLATE TABLE\nPASSNO   DC    F'0'                CURRENT PASS NUMBER\nNUMTBLAD DC    A(NUMTBL)           NUMERIC TRANSLATE TABLE ADDRESS\nCWTABAD  DC    A(CWTABLE)          CONTROL WORD SEPARATOR TABLE\nESTABAD  DC    A(*-*,ESTABLE)      WORKING/ACTUAL INPUT ESCAPE TABLE\nCSTABAD  DC    A(CSTABLE)          ADDR .CS STATUS AND CURRENT TABLES\nHEXTABAD DC    A(HEXTABLE)         FOR HEX TO CHARACTER CONVERSION\nTRINITAD DC    A(TRINIT)           IDENTITY TRANSLATE TABLE ADDRESS\nRCAREAAD DC    A(*-*)              REV CODE WORK AREA ADDRESS\nTBANCHR  DC    A(*-*)              POINTER TO USER TAB CHAIN\n         SPACE\nSTAKMAX  EQU   9                   MAXIMUM LEVELS OF SAVE/RESTORE\nSTAKANCH DC    A(*-*)              SAVE/RESTORE STACK ANCHOR\nSTAKCTR  DC    F'0'                SAVE/RESTORE STACK COUNTER\n         SPACE\nDUMPAD   DC    A(DUMPAREA)         MINI DUMP DATA AREA\nLKTOP    DC    F'0'                TOP CHARACTER LINK ELEMENT\nLKSTAR   DC    F'0'                LINK CHARACTER START\nLKSIZE   DC    F'0'                LINK AREA SIZE\nLKMULT   DC    F'0'                LINK SAVE WORD\nLKANCH   DC    A(*-*)              LINK CHARACTER BLOCK ANCHOR\nLKASIZE  DC    A(*-*)              NUMBER OF LINKED CHAR BLOCKS\n         SPACE\nWRKPLIST DC    A(*-*)              ADDRESS OF NEW STRING\n         DC    A(*-*)              LENGTH OF NEW STRING\nWRKFLN   DC    A(*-*)              FIRST LINK ADDRESS\nWRKLLN   DC    A(*-*)              LAST LINK ADDRESS\n         DC    A(*-*)              PRIMARY LINE LENGTH\n         SPACE\nWRKNX    DC    A(*-*)\nWRKL     DC    F'0'                BOOLEAN NON-BLANK FOUND IND (0 OR 1)\n         SPACE\nWRKBRK   DC    A(*-*)              HYPHEN BREAK POINT\nWRKSW    DC    X'00'               SWITCHS\nWRKUHY   EQU   X'80'                    USER HYPHEN SWITCH\nWRKBLNK  EQU   X'40'                    NO BLANKS FOUND SWITCH\n         SPACE\nESCFLAG  DC    X'00'               ESCAPE CHAR FLAG\nESCSW    EQU   X'80'                    ESCAPE CHAR SWITCH\n         SPACE\nLBANCH   DC    A(0)                LOCAL FILE LABEL ANCHOR\nLBGOTO   DC    CL8' '              GOTO TARGET\nLBWRK    DC    CL8' '              GOTO WORK AREA\n         SPACE\nBUFF3AD  DC    A(BUFF3)            TEMPORARY READ BUFFER\nHIDBANCH DC    A(*-*)              HIDDEN BUFFER ANCHOR\nPEANCH   DC    A(*-*)              PERFORM LINE BUFFERS ANCHOR\nOIANCH   DC    A(0)                INPUT OVERLAY ANCHOR\nOOANCH   DC    A(0)                OUTPUT OVERLAY ANCHOR\nBXPTR    DC    A(*-*)              POINTER TO BOX BUILDING AREA\n         SPACE\nDHMAXTC  EQU   10                  MAX NUMBER OF TABLES OF CONTENTS\nDHNUMTC  DC    A(*-*)              CURRENT TABLE OF CONTENTS NUMBER\nDHANCH   DC    (DHMAXTC)A(*-*)     TABLES OF CONTENTS ANCHORS\nTCANCH   DC    (DHMAXTC)A(*-*)     TABLE OF CONTENTS BUFFER ANCHOR\nTCPAGE   DC    A(*-*)              PAGE NUMBER AFTER .TC\nTCDHSAVE DC    XL6'00'             .TC DEFINE HEAD SAVE\n         SPACE\nSAVEINIT DC    A(*-*)              INITIAL STACK SAVE WORK AREA\n         SPACE\n*        POSSIBLE RETURN CODES FROM THE 'GETYESNO' ROUTINE            *\n*        TO BE FOUND IN 'YNRESULT'.                                   *\n         SPACE\nYNPOS    EQU   1                   IF AFFIRMATIVE\nYNNEG    EQU   2                   IF NEGATIVE\nYNMBE    EQU   3                   IF YES AND NO\nYNDEL    EQU   4                   IF DELETE\nYNOFN    EQU   5                   IF SUPER NEGATIVE\nYNSET    EQU   6                   IF SET\nYNARA    EQU   7                   IF ARABIC\nYNROM    EQU   8                   IF ROMAN\nYNINC    EQU   9                   IF INCLUDE\nYNIGN    EQU   10                  IF IGNORE\nYNODD    EQU   11                  IF ODD\nYNEVN    EQU   12                  IF EVEN\nYNTRON   EQU   13                  IF TRACEON\nYNTROFF  EQU   14                  IF TRACEOFF\nYNUSER   EQU   15                  IF USER\nYNADD    EQU   16                  IF ADD\nYNCNG    EQU   17                  IF CHANGE\nYNDUMP   EQU   18                  IF DUMP\nYNPUR    EQU   19                  IF PURGE\nYNLEFT   EQU   20                  IF LEFT\nYNRGHT   EQU   21                  IF RIGHT\nYNCNTR   EQU   22                  IF CENTRE OR CENTER\nYNISDE   EQU   23                  IF INSIDE\nYNOSDE   EQU   24                  IF OUTSIDE\nYNLOWER  EQU   25                  IF LOWER\nYNASTK   EQU   26                  IF CHARACTER ASTERISK\nYNTEST   EQU   27                  IF TEST\nYNPREF   EQU   28                  IF PREFIX\nYNSUFX   EQU   29                  IF SUFFIX\nYNSUP    EQU   30                  IF SUPPRESS\nYNTRSH   EQU   31                  IF THRESH\nYNMNPT   EQU   32                  IF MINPT\nYNENDPT  EQU   33                  IF ENDPT\nYNHALF   EQU   34                  IF HALF\nYNAND    EQU   35                  IF LOGICAL AND\nYNOR     EQU   36                  IF LOGICAL OR\nYNABS    EQU   37                  IF ABSOLUTE\nYNCND    EQU   38                  IF CONDITIONAL\nYNFRAC   EQU   39                  IF FRACTIONAL\nYNNORM   EQU   40                  IF NORMAL\nYNDHSTRT EQU   41                  DEFINE HEAD START LIMIT\nYNSKBF   EQU   41                  IF SKBF\nYNSPAF   EQU   42                  IF SPAF\nYNTCIN   EQU   43                  IF TCINDENT\nYNTCOF   EQU   44                  IF TCOFFSET\nYNTO     EQU   45                  IF TONLY\nYNTC     EQU   46                  IF TC\nYNTSP    EQU   47                  IF TSPACE\nYNUS     EQU   48                  IF US\nYNUP     EQU   49                  IF UPPER\nYNOJ     EQU   50                  IF OJUST\nYNPA     EQU   51                  IF PAGE\nYNBREAK  EQU   52                  IF BREAK\nYNNOTO   EQU   53                  IF NOTONLY\nYNNOTC   EQU   54                  IF NOTC\nYNNOTSP  EQU   55                  IF NOTSPACE\nYNNOUS   EQU   56                  IF NOUS\nYNNOUP   EQU   57                  IF NOUPPER\nYNNOOJ   EQU   58                  IF NOOJUST\nYNNOPA   EQU   59                  IF NOPAGE\nYNNOBRK  EQU   60                  IF NOBREAK\nYNDHEND  EQU   YNNOBRK             DEFINE HEAD END LIMIT\nYNHJ     EQU   61                  IF HEX JOIN\nYNNOHJ   EQU   62                  IF NO HEX JOIN\n*\nYNOMIT   EQU   X'FE'               IF OMITTED\nYNDNO    EQU   X'FF'               IF DON'T KNOW\n         SPACE\nYNRESULT DC    X'00'               PASS BACK GETYESNO RESULT\n         SPACE\nBOMIT    EQU   1                   COND CODE 1 IF ARGUMENT OMITTED\nBPOS     EQU   2                   COND CODE 2 IF ARGUMENT AFFIRMATIVE\nBNEG     EQU   4                   COND CODE 4 IF ARGUMENT NEGATIVE\nBDNO     EQU   8                   COND CODE 8 IF ARGUMENT UNDEFINED\n         SPACE\nERRTEXT  DC    A(*-*)              EXTRA ERROR TEXT LENGTH/POINTER\nERRSTART DC    A(*-*)              ERROR START COLUMN\nARGSTART DC    A(*-*)              FIRST CHARACTER TO SCAN\nARGSTOP  DC    A(*-*)              LAST CHARACTER TO SCAN\nARGSRSTA DC    A(0)                SAVE FIRST CHARACTER TO SCAN\nARGSRSTP DC    A(0)                SAVE LAST CHARACTER TO SCAN\nARGTSTAR DC    A(0)                SAVE FIRST CHARACTER TO SCAN\nARGTSTOP DC    A(0)                SAVE LAST CHARACTER TO SCAN\nOPENPARN DC    A(0)                -> OPEN PARENTHESIS IN ARG\nCLOSPARN DC    A(0)                -> CLOSE PARENTHESIS IN ARG\nARGCOUNT DC    F'0'                LAST COUNT OF ARGS IN .AP/.IM/.SI\nQSTRING  DC    A(0)                QUOTED STRING SWITCH\nOUTSEQ   DC    F'0'                LEGAL OUTPUT SEQUENCE NUMBER\n         EJECT\n        $MSGSECT TYPE=FLAG         GENERATE ERROR FLAGS\n         SPACE\nERRCLR   EQU   X'00'                    NO ERROR\nERRINFO  EQU   X'01'                    INFORMATION MESSAGE\nERRWARN  EQU   X'04'                    WARNING MESSAGE\nERRSET   EQU   X'08'                    ERROR MESSAGE\nERRSVERE EQU   X'0C'                    SEVERE ERROR MESSAGE\nERRTERM  EQU   X'10'                    ERROR AND NOCONTINUE\n         EJECT\n*                                                                     *\n*  PARAMETER BLOCKS PASSED TO THE INPUT COORDINATOR ROUTINE           *\n*                                                                     *\n         SPACE\nPRIMBLOK DS    0D                  REFERS TO PRIMARY INPUT FILE\nPRIMNAME DC    CL8'SYSIN'          FILE NAME\nPRIMMEMB DC    CL8'        '       NO MEMBER NAME\nPRIMMIN  DC    A(1)                BEGINNING LINE NUMBER\nPRIMMAX  DC    A(X'1000000')       ENDING LINE NUMBER\nPRIMFLAG DC    XL4'00'             FLAG BYTES\nPRIMARGC DC    F'0'                ARGUMENT COUNT\nPRIMGOTO DC    CL8' '              GOTO TARGET\n         SPACE 2\nCONSBLOK DS    0D                  REFERS TO CONSOLE\nCONSNAME DC    CL8'SYSCONS'        FILE NAME\nCONSMEMB DC    CL8'        '       NO MEMBER NAME\nCONSMIN  DC    A(1)                FIRST ITEM NUMBER\nCONSMAX  DC    A(*-*)              LAST LINE NUMBER\nCONSFLAG DC    XL4'00'             FLAG BYTES\nCONSARGC DC    F'0'                ARGUMENT COUNT\nCONSGOTO DC    CL8' '              GOTO TARGET\n         SPACE 2\nAPIMBLOK DS    0D                  BLOCK USED BY APPEND/IMBED/SIGNAL\nAPIMNAME DC    CL8'********'       DDNAME TO BE READ\nAPIMMEMB DC    CL8'        '       MEMBER NAME (IF ANY) TO BE READ\nAPIMMIN  DC    A(*-*)              FIRST ITEM NUMBER\nAPIMMAX  DC    A(*-*)              MAXIMUM LINE NUMBER\nAPIMFLAG DC    XL4'00'             FILLED IN FLAGS\nAPIMARGC DC    F'0'                ARGUMENT COUNT\nAPIMGOTO DC    CL8' '              GOTO TARGET\n         SPACE\nCOMREPAD DC    A(*-*)              -> LIST OF DDNAME REPLACEMENTS\nCOMPARM3 DC    A(*-*)              THIRD USER PARM POINTER\nCURFILE  DC    A(0,0)              PTRS TO CURRENT FILBLOCK AND DDBLOCK\nCOMAREA  DC    0F'0'               START OF RECORD DESCRIPTOR DATA\nCOMFILNM DC    CL8' '              NAME OF CURRENT INPUT FILE\nCOMMEMNM DC    CL8' '              NAME OF CURRENT INPUT MEMBER\nCOMFILNO DC    CL8' '              ZONED DECIMAL LINE NUMBER\nCOMFILIT DC    A(0)                NUMBER OF LAST RECORD READ\nCOMLEN   EQU   *-COMAREA           LENGTH OF RECORD DESCRIPTOR DATA\n         SPACE\nCOMAGO   DS    XL(COMLEN)          SOURCE OF FORWARD GOTO\n         EJECT\n*                                                                     *\n*                                       PARAMETER LISTS               *\n*                                                                     *\n         SPACE 2\nFMTOLD1  DS    0D                  ORIGIN OF FIRST FORMAT DATA AREA\nLINKPARM DS    0F\nOUTPARM  DC    A(BUFF1M1)          LOC. OF STRING\nNOCHARS  DC    F'0'                LENGTH OF STRING\nOLDFIRST DC    A(*-*)              LOC. OF FIRST LINK ELEMENT\nOLDLAST  DC    A(*-*)              LOC. OF LAST LINK ELEMENT\nOLDCOUNT DC    F'0'                NUMBER OF LINK BLOCKS\nIWSPC    DC    F'0'                INTER-WORD SPACES\n         SPACE\nPARMPUT  DS    0F\nPTCHLOC  DC    A(BUFF2M1)          LOC. OF STRING\nPTCHLNG  DC    F'0'                LENGTH OF STRING\nPTELFIR  DC    A(*-*)              LOC. OF FIRST LINK ELEMENT\nPTELLST  DC    A(*-*)              LOC. OF LAST LINK ELEMENT\nPTELLNG  DC    F'0'                LENGTH OF PRIMARY LINE\nEFMTOLD1 EQU   *-FMTOLD1           LENGTH OF LINK DESCRIPTORS\n         SPACE\nSWCTL    DC    0F'0'               START OF SWITCH CONTROL AREA\nCLLZ     DC    A(*-*)              COLUMN LENGTH PARAMETER\nTBANCHA  DC    A(TBANCHR)          ADDR OF TAB ANCHOR FIELD\nRMARGIN  DC    H'0'                RIGHT MARGIN\nOFUNCNT  DC    H'0'                OFFSET/UNDENT MARGIN COUNT\nINDENTR  DC    H'0'                RIGHT INDENT FROM LINE LENGTH\n         SPACE\nJUVAL    DC    AL1(*-*)            JUSTIFY OPTION\nJUVNEG   EQU   0                        NO JUSTIFY\nJUVHALF  EQU   4                        HALF JUSTIFY LEFT AND RIGHT\nJUVPOS   EQU   8                        JUSTIFY LEFT AND RIGHT\nJUVLEFT  EQU   12                       LEFT JUSTIFY\nJUVRGHT  EQU   16                       RIGHT JUSTIFY\nJUVCNTR  EQU   20                       CENTRE JUSTIFY\nJUVISDE  EQU   24                       INSIDE JUSTIFY\nJUVOSDE  EQU   28                       OUTSIDE JUSTIFY\nFOVAL    DC    AL1(*-*)            FORMAT OPTION  ***RESERVED***\n         DC    F'0'                    UNUSED\n         DC    F'0'                    UNUSED\n         SPACE\n*                                                                     *\n*                                       SWITCHS                       *\n*                                                                     *\nSWITCHS  DC    XL10'00'            ALL THE SWITCHES\n         SPACE\n         ORG   SWITCHS+6           END OF SAVED/RESTORED SWITCHS\nLFMTOLD1 EQU   *-FMTOLD1           LENGTH OF FIRST FORMAT AREA\nSWCTLZ   EQU   *-SWCTL             END OF SWITCH CONTROL AREA\n         ORG   ,                   END OF GLOBAL SWITCHS\n         EJECT\n***********************************************************************\n*                                                                     *\n*                                       PAGE CONTROL                  *\n*                                                                     *\n***********************************************************************\n         SPACE\nFMTOLD2  DS    0F                  ORIGIN OF SECOND FORMAT DATA AREA\nLLZ      DC    A(*-*)              LINE LENGTH PARAMETER\nINDL     DC    H'0'                INDENTATION FACTOR\nOFFL     DC    H'0'                OFFSET VALUE\nOFFLI    DC    H'0'                OFFSET INCREMENT\nUNDL     DC    H'0'                UNDENT FACTOR\nCECNT    DC    H'0'                CENTER VALUE\nLICNT    DC    H'0'                LITERAL VALUE\nDSCNT    DC    H'1'                LINE SPACING FACTOR\nOVLINCNT DC    H'0'                OVERLAY COUNT LEFT\nURCNT    DC    H'0'                USER REFERENCE VALUE\nADJCNT   DC    H'0'                ADJUST COUNT\nADJCEVN  DC    H'0'                EVEN PAGE ADJUST COUNT\nADJCODD  DC    H'0'                ODD PAGE ADJUST COUNT\nPICNT    DC    H'0'                PARAGRAPH INDENT VALUE\nHICNT    DC    H'0'                HANGING INDENT VALUE\nPLZ      DC    H'0'                PAGE LENGTH\nTOPMRG   DC    H'0'                TOP MARGIN\nBMMRG    DC    H'0'                BOTTOM MARGIN\nHDMRG    DC    H'1'                HEADING MARGIN\nFTMRG    DC    H'1'                FOOTING MARGIN\nHSCNT    DC    H'0'                HEADING SPACE COUNT\nFSCNT    DC    H'0'                FOOTING SPACE COUNT\nFTCNT    DC    H'0'                FOOTING TITLE COUNT\nDARKVAL  DC    H'0'                DARK OUTPUT VALUE\nHYTHRESH DC    H'0'                HYPHENATION THRESHOLD\nHYMINPT  DC    H'0'                HYPHENATION START MINIMUM\nHYENDPT  DC    H'0'                HYPHENATION END MINIMUM\nHYSUPCNT DC    H'0'                HYPHENATION LINE SUPPRESS\nHYSUPWRK DC    H'0'                HYPHENATION LINE SUPPRESS LEFT\nCDCOUNT  DC    F'0'                COUNT OF MULTI-COLUMN DEFINITION\nCDMAXC   EQU   9                   MAX MULTI-COLUMN SUPPORT\nCDVALC   DC    XL(CDMAXC)'00'      MULTI-COLUMN OFFSETS\nCDINIT1  EQU   0                        DEFAULT FIRST VALUE\nCDINIT2  EQU   46                       DEFAULT SECOND VALUE\nCDINIT3  EQU   92                       DEFAULT THIRD VALUE\nLFMTOLD2 EQU   *-FMTOLD2           LENGTH OF SECOND AREA\n         SPACE\nPACNTI   DC    A(*-*)              INTEGER PART OF PAGE NUMBER\nPACNTD   DC    A(*-*)              DECIMAL PART OF PAGE NUMBER\nPACNTII  DC    A(1)                INITIAL INTEGER PART OF PAGE NUMBER\nPACNTDI  DC    A(-1)               INITIAL DECIMAL PART OF PAGE NUMBER\nPNPREF   DC    0CL9' ',X'00',CL8'*'     LENGTH/PAGE NUMBER PREFIX\nPNSUFX   DC    0CL9' ',X'00',CL8'*'     LENGTH/PAGE NUMBER SUFFIX\n         SPACE\nERCONT   DC    F'0'                ERROR CONTINUE COUNT\nRETCODE  DC    H'0'                RETURN CODE TO CALLER\nSYRET    DC    H'0'                LAST .SY RETURN CODE\nPLCT     DC    H'0'                PAGE LENGTH COUNTER\nFNSEP    DC    H'0'                FOOTNOTE DEPTH INCL SEPARATOR\n         SPACE\nWRKBUFFA DC    A(WRKBUFF)          HEADING/FOOTING BUFFER ADDRESS\nADJBUFFA DC    A(*-*)              EVEN/ODD ADJUST WORK BUFFER\n         SPACE\nEBCDPAGE DC    CL32'1'             EBCDIC PAGE NUMBER FOR SYSPPAGE\nDECPAGE  DC    CL8'00000000',CL8'********' NUMERIC/ROMAN PAGE NUMBER\nHDTEMPAD DC    A(BUFF3+4)          TEMP HEADING BUFFER ADDRESS\nHPBKCNT  DC    2H'0'               HEADING BUFFER BACKSPACE COUNT\n         SPACE\nTRIPLSP  EQU   C'-'                SKIP 3 LINES BEFORE PRINTING\nDOUBLSP  EQU   C'0'                SKIP 2 LINES BEFORE PRINTING\nSINGLSP  EQU   X'40'               SKIP 1 LINE BEFORE PRINTING\nSUPRSPAC EQU   C'+'                SUPPRESS SPACE BEFORE PRINTING\nSPACTABL DC    AL1(SUPRSPAC,SINGLSP,DOUBLSP,TRIPLSP)  ASA CARRIAGE TAB\n         SPACE\nLINEFC   EQU   30                  MAX NUMBER OF LINEFEEDS AT ONCE\nLINEFE   EQU   10                  NUMBER OF LINE FEEDS TO EJECT PAGE\nLINEF    DC    (LINEFC)X'1725'     LINE FEED OPERATION\n         SPACE\nCPRTBYP  EQU   X'24'               SUPPRESS CONSOLE PRINTING\nCPRTRES  EQU   X'14'               RESTORE  CONSOLE PRINTING\nCBACKSP  EQU   X'16'               BACKSPACE CHARACTER\nCESCAPE  EQU   X'27'               ESCAPE CHARACTER\n         SPACE\nFLOFFCH  DC    F'0'                BUFFERED SPACE CHANNEL SKIP\nFLOFFSP  DC    F'0'                BUFFERED OFFLINE SPACES\nFLBLNK   DC    0F'0',AL2(BLNKRDWL,0)\nFLBLNKCC DC    X'CC',C' '          BLANK FLUSH CC AND DATA\n         SPACE\nBLNKRDWL EQU   6                   LENGTH IN RDW FOR BLANK LINE\nBLNKLINE DC    0F'0',AL2(BLNKRDWL,0)    FOR SKIPPING SPACES\nPRNTRCC  DC    C' '\nBLNKDATA DC    CL132' '\n         EJECT\n***********************************************************************\n*                                                                     *\n*                                       BUFFER STORAGE                *\n*                                                                     *\n***********************************************************************\n         SPACE\n         DS    0F\nBUFF1LGZ DC    H'5',H'0'\nBUFF1LG  EQU   BUFF1LGZ+1\nBUFF1M1  DC    C' '\nBUFF1    DC    CL240' ',CL16' '    OUTPUT BUFFER\n         SPACE\n         DS    0F\nBUFF2LGZ DC    H'5',H'0'\nBUFF2LG  EQU   BUFF2LGZ+1\nBUFF2M1  EQU   *-1                 (MUST PRECEED BUFF2)\nBUFF2    DC    CL240' ',CL16' '    INPUT BUFFER\n         SPACE\nB2LG     EQU   L'BUFF2\n         EJECT\n***********************************************************************\n*                                                                     *\n*              HEADING AND FOOTING BUFFERS                            *\n*                                                                     *\n***********************************************************************\n         SPACE\nADEVHEAD DC    A(EVNHEAD)          ADDR EVEN HEADINGS/FOOTINGS\nADODHEAD DC    A(ODDHEAD)          ADDR ODD HEADINGS/FOOTINGS\nAFTHEAD  DC    A(FTHEAD)           ADDR FOOTNOTE TITLES\nHSFSCT   EQU   19                  MAX HEADING/FOOTING WRAP AROUND CNT\nHSFSWRK  DC    H'0'                WORKING HS/FS REMAINDER\n         SPACE\nPSYMBOL  DC    AL1(*-*),C'%',C'&&' WORKING/DEFAULT/ALTERNATE PAGE SYMBL\n         SPACE\nOCCNT    DC    H'0'                OVERLAY CHAR TEXT LINES COUNT\nOCCHAR   DC    AL1(*-*),C' '       OVERLAY CHARACTER OPERAND\nOCEXCEP  DC    XL21'00'            EXCEPTION CHARACTER ARRAY\nOCLEN    EQU   *-OCCNT             LENGTH OF OVERLAY CHAR AREA\n         SPACE\nUDFLAG   DC    X'00'               UNDERSCORE INCLUDE/IGNORE FLAG\nUDINCCHR DC    C' '                UNDERSCORE INCLUDE ESCAPE\nUDIGNCHR DC    C' '                UNDERSCORE IGNORE ESCAPE\nUDTABAD  DC    A(UDTABLE)          UNDERSCORE TABLE ADDRESS\nUPTABAD  DC    A(UPTABLE)          UPPERCASE TABLE ADDRESS\n         SPACE\nIFSTAKCT EQU   10                  MAX .IF NESTING COUNT\nIFSTAKSP EQU   2                   BYTE COUNT FOR ONE .IF LEVEL\nIFSTAK   DC    XL(IFSTAKCT*IFSTAKSP)'00',XL(IFSTAKSP)'00'  IF STACK\n         SPACE\nPERIND   DC    AL1(*-*),C'.'       CONTROL WORD INDICATOR CHARACTER\nBREAKCHR DC    AL1(*-*),CL1''''    WORKING/DEFAULT HEADER BREAK CHAR\nPERNBIND DC    AL1(*-*),C' '       NOBREAK CONTROL WORD INDICATOR\nBSIND    DC    AL1(*-*),C' '       USER BACKSPACE/HEXJOIN CHARACTER\nTBIND    DC    AL1(*-*),X'05'      USER ADDITIONAL TAB CHARACTER\n         SPACE\n*                                                                     *\n*        INCORE FORMATTING SAVE AREAS                                 *\n*                                                                     *\n         SPACE\nICORANCH DC    A(*-*)              INCORE FORMAT ANCHOR POINTER\nICORFLG  DC    X'00'               TYPE OF INCORE OPERATION\nICORNONE EQU   0                        INCORE FORMAT NOT IN PROGRESS\nICORCC   EQU   4                        .CC BEGIN/END SEQUENCE\nICORCP   EQU   8                        .CP BEGIN/END SEQUENCE\nICORFB   EQU   12                       .FB BEGIN/END SEQUENCE\nICORFK   EQU   16                       .FK BEGIN/END SEQUENCE\nICORFN   EQU   20                       .FN BEGIN/END SEQUENCE\nICORHN   EQU   24                       .HN BEGIN/END SEQUENCE\nICORHNE  EQU   28                       .HN EVEN BEGIN/END SEQUENCE\nICORHNO  EQU   32                       .HN ODD BEGIN/END SEQUENCE\n         SPACE\nICOLFLG  DC    X'00'               TYPE OF MULTI-COLUMN OPERATION\nICOLNONE EQU   0                        MULTI-COLUMN NOT IN PROGRESS\nICOLMC   EQU   4                        MULTI-COLUMN IN PROGRESS\nICOLSC   EQU   8                        SUPPRESSED MULTI-COLUMN\nICOLTC   EQU   12                       TITLE SUPPRESSED MULTI-COLUMN\nCLLZSAVE DC    F'0'                SAVE FOR REAL CLLZ\nSCCOUNT  DC    F'0'                SINGLE COLUMN NEST COUNT\nCDCURR   DC    F'0'                CURRENT MULTI-COLUMN IN PROGRESS\nCDPLCT   DC    H'0'                SAVE LINES REMAINING FIR COLUMN\n         SPACE\nCCAREA   DC    0F'0'               .CC FORMAT AREA\nCCQCNT   DC    F'0'                     NUMBER QUEUED .CC LINES\nCCQCNTF  DC    F'0'                     NUMBER IN FIRST BLOCK\nCCQANCH  DC    A(0)                     .CC CELL ANCHOR\nCCQFLGS  DC    XL4'00'                  .CC FLAGS\nCCQSAVE  DC    A(*-*)                   .CC SAVE CURRENT DATA POINTER\nCPAREA   DC    0F'0'               .CP FORMAT AREA\nCPQCNT   DC    F'0'                     NUMBER QUEUED .CP LINES\nCPQCNTF  DC    F'0'                     NUMBER IN FIRST BLOCK\nCPQANCH  DC    A(0)                     .CP CELL ANCHOR\nCPQFLGS  DC    XL4'00'                  .CP FLAGS\nCPQSAVE  DC    A(*-*)                   .CP SAVE CURRENT DATA POINTER\nFBAREA   DC    0F'0'               .FB FORMAT AREA\nFBQCNT   DC    F'0'                     NUMBER QUEUED .FB LINES\nFBQCNTF  DC    F'0'                     NUMBER IN FIRST BLOCK\nFBQANCH  DC    A(0)                     .FB CELL ANCHOR\nFBQFLGS  DC    XL4'00'                  .FB FLAGS\nFBQSAVE  DC    A(*-*)                   .FB SAVE CURRENT DATA POINTER\nFKAREA   DC    0F'0'               .FK FORMAT AREA\nFKQCNT   DC    F'0'                     NUMBER QUEUED .FK LINES\nFKQCNTF  DC    F'0'                     NUMBER IN FIRST BLOCK\nFKQANCH  DC    A(0)                     .FK CELL ANCHOR\nFKQFLGS  DC    XL4'00'                  .FK FLAGS\nFKQSAVE  DC    A(*-*)                   .FK SAVE CURRENT DATA POINTER\nFNAREA   DC    0F'0'               .FN FORMAT AREA\nFNQCNT   DC    F'0'                     NUMBER QUEUED FOOTNOTE LINES\nFNQCNTF  DC    F'0'                     NUMBER IN FIRST BLOCK\nFNQANCH  DC    A(0)                     FOOTNOTE CELL ANCHOR\nFNQFLGS  DC    XL4'00'                  .FN FLAGS\nFNQSAVE  DC    A(*-*)                   .FN SAVE CURRENT DATA POINTER\nHNAREA   DC    0F'0'               .HN FORMAT AREA\nHNQCNT   DC    F'0'                     NUMBER QUEUED HEADNOTE LINES\nHNQCNTF  DC    F'0'                     NUMBER IN FIRST BLOCK\nHNQANCH  DC    A(0)                     HEADNOTE CELL ANCHOR\nHNQFLGS  DC    XL4'00'                  HEADNOTE FLAGS\nHNQSAVE  DC    A(*-*)                   .HN SAVE CURRENT DATA POINTER\nHNEAREA  DC    0F'0'               .HN EVEN FORMAT AREA\nHNEQCNT  DC    F'0'                     NUMBER QUEUED HEADNOTE LINES\nHNEQCNTF DC    F'0'                     NUMBER IN FIRST BLOCK\nHNEQANCH DC    A(0)                     HEADNOTE CELL ANCHOR\nHNEQFLGS DC    XL4'00'                  HEADNOTE FLAGS\nHNEQSAVE DC    A(*-*)                   .HN SAVE CURRENT DATA POINTER\nHNOAREA  DC    0F'0'               .HN ODD FORMAT AREA\nHNOQCNT  DC    F'0'                     NUMBER QUEUED HEADNOTE LINES\nHNOQCNTF DC    F'0'                     NUMBER IN FIRST BLOCK\nHNOQANCH DC    A(0)                     HEADNOTE CELL ANCHOR\nHNOQFLGS DC    XL4'00'                  HEADNOTE FLAGS\nHNOQSAVE DC    A(*-*)                   .HN SAVE CURRENT DATA POINTER\n         SPACE\nSCAREA   DC    0F'0'               SINGLE COLUMN FORMAT AREA\nSCQCNT   DC    F'0'                     NUMBER QUEUED SC LINES\nSCQCNTF  DC    F'0'                     NUMBER IN FIRST BLOCK\nSCQANCH  DC    A(0)                     SINGLE COLUMN ANCHOR\nSCQFLGS  DC    XL4'00'                  SINGLE COLUMN FLAGS\nSCQSAVE  DC    A(*-*)                   SINGLE COLUMN SAVE CURRENT DATA\nMCAREA   DC    0F'0'               MULTI-COLUMN FORMAT AREA\nMCQCNT   DC    F'0'                     NUMBER QUEUED MC LINES\nMCQCNTF  DC    F'0'                     NUMBER IN FIRST BLOCK\nMCQANCH  DC    A(0)                     MULTI-COLUMN ANCHOR\nMCQFLGS  DC    XL4'00'                  MULTI-COLUMN FLAGS\nMCQSAVE  DC    A(*-*)                   MULTI-COLUMN SAVE CURRENT DATA\nMCQLEN   EQU   *-MCAREA            LENGTH OF ONE AREA\n         DC    (CDMAXC-1)XL(MCQLEN)'00' ROOM FOR THE OTHERS\nMCFNQAD  DC    A(*-*)              MULTI-COLUMN LINE POINTER\nMCALEN   DC    AL2(MCQLEN)         LENGTH OF ONE AREA\n         SPACE\nHDPTRSAV DS    CL(LFMTOLD1)        SAVE AREA FOR HEADING ROUTINE\n         SPACE\nHYLEVEL  DC    A(*-*)              CURRENT HYPHENATION LEVEL\nHYNONE   EQU   1                   NO HYPHENATION\nHYUSER   EQU   2                   USER HYPHENATION\nHYAUTO   EQU   3                   AUTOMATIC HYPHENATION\nHYUCHAR  EQU   X'30'               INTERNAL USER TRAILING HYPHEN CHAR\nHYACHAR  EQU   C'-'                EXTERNAL HYPHEN CHARACTER\nHYEXCNT  DC    F'0'                HYPHENATION EXCEPTION WORD COUNT\nHYTESTAR DC    0CL65' ',X'00',CL64' '   HYPHENATION TEST AREA\n         SPACE\nPUMAX    EQU   9                   MAXIMUM PUT FILE NUMBER\nPUIOCBPT DC    A(PUIOCBAD)         POINTER TO WORK FILE IOCB ADDRS\nPUDDNAME DC    CL8'SYSUSR**'       PUT WORK FILE BASIC DDNAME\n         SPACE\nIXVCNT   EQU   9                   MAX CONCURRENT INDEXES\nIXANCHV  DC    (IXVCNT)A(*-*)      PTRS FIRST LEVEL ONE INDEX BLOCK\nIXPTRS   DC    0A(0)               START OF INDEX PARSED PARMS\nIXPTR1   DC    A(*-*)                   FIRST LENGTH-1/ADDRESS\nIXPTR2   DC    A(*-*)                   SECOND LENGTH-1/ADDRESS\nIXPTR3   DC    A(*-*)                   THIRD LENGTH-1/ADDRESS\nIXPTRE   DC    A(0)                     END OF PARM LEVELS\nIXPARM   DC    A(*-*)                   REFERENCE LENGTH-1/ADDRESS\nIXPTRL   EQU   *-IXPTRS            LENGTH OF IX PARSED PARMS\n         SPACE\nRGLISTAD DC    A(RGLIST)           ADDRESS REGION MANAGER PARM LIST\n         SPACE\nPRGUSED  DC    A(0)                REGION MANAGER GOTTEN CORE\nPRGHIGH  DC    A(0)                HIGH WATER MARK FOR GOTTEN CORE\n         EJECT\n*                                                                     *\n*                                       RANDOM STORAGE                *\n*                                                                     *\n         SPACE\nWTOCOUNT DC    F'0'                WRITE TO OPERATOR RECORD COUNT\nPAGECNT  DC    F'0'                REAL PAGE EJECT COUNT\nSKSP     DC    0F'0'               CONDITIONAL SKIP/SPACE AREA\nSKSPFLG  DC    X'00'               SKIP SPACE FLAGS\nSKSPABS  EQU   X'80'                    ABSOLUTE SKIP/SPACE\nSKSPCND  EQU   X'40'                    CONDITIONAL SKIP/SPACE\nSKSPSK   EQU   X'20'                    A SKIP, NOT A SPACE\nSKSPFLG2 DC    X'00'               SKIP/SPACE TO ACCOMPANY CONDITIONAL\nSKSPCCNT DC    H'0'                CONDITIONAL SKIP/SPACE COUNT\nPLSTSV   DC    A(*-*)              INVOCATION PARM LIST ADDRESS\nDECM     DC    D'0'                CONVERSION AREA\nNUMSIGN  DC    C' '                GET NUMBER SIGN AREA\n         SPACE\nURSV     DC    16A(0)              .UR REGISTER SAVE AREA\nURCURPTR DC    A(*-*)              .UR CURRENT TARGET POINTER\nURENDPTR DC    A(*-*)              .UR CURRENT TARGET END POINTER\nURBBACK  DC    F'0'                .UR URBUMP BACKUP COUNT\nURMAXCNT DC    AL2(*-*,100)        .AP/.UR ITERATION COUNTER\nUREDPAT  DC    X'4020202020202120' EDMK PATTERN - AT LEAST \"0\"\nUREDPTN  DC    XL10'40202020202020202120'    LONG DECIMAL EDIT PATTERN\nUREDWRK  DC    CL10'*'             DECIMAL WORK AREA\nURFLAG   DC    X'00'               .UR LOCAL SWITCHES\nURLQUT   EQU   X'80'                    L'&VARIABLE FLAG\nURTQUT   EQU   X'40'                    T'&VARIABLE FLAG\n         SPACE\n*                                                                     *\n*        REMOTE SEQUENCE SAVE AREAS --                                *\n*                                                                     *\n         SPACE\nRMNAMLEN DC    XL(L'APIMNAME)'00'  FLAGGED IF REMOTE NAME OF LENGTH\nRMNAMDEF EQU   X'FF'               REMOTE NAME DEFINED OF THIS LENGTH\n         SPACE\nRMQANCH  DC    A(*-*)              REMOTE DESCRIPTOR QUEUE ANCHOR\nRMCNT    DC    F'0'                REMOTE CALL COUNT\nRMCW     DC    C'**'               CONTROL WORD STRING\nRMFLAG   DC    XL4'00'             REMOTE WORK FLAG\n         ORG   *-2                 BACKUP FOR CHARACTERS\nRMCWIND  DC    C' '                MACRO/REMOTE CONTROL WORD IND\nRMDELIM  DC    C' '                .DM STRING DELIMITER\n         SPACE\nRMTRIG   DC    H'0'                TRIGGER FOR REMOTE SEQUENCE\nRMNEST   DC    H'0'                NESTED LEVEL OF REMOTE SEQUENCES\nRMNMNEST DC    H'0'                NEST LEVEL OF AUTOMATIC REMOTES\nFILNEST  DC    H'0'                TOTAL NESTED LEVEL OF FILES\n         SPACE\nSFNCNT   DC    H'0'                SYSTEM FOOTNOTE COUNT\nRMIMSAV  DC    16F'0'              REGISTERS OF REMOTE IMBEDDER\n         EJECT\n***********************************************************************\n*                                                                     *\n*              .SR SYMBOL TABLE                                       *\n*                                                                     *\n***********************************************************************\n         SPACE\nASRWORK  DC    A(*-*)              CURRENT SYMBOL DICTIONARY PTR\nASRGBL   DC    A(SRGBL)            GLOBAL SYMBOL DICTIONARY\nASRLCL   DC    A(SRLCL)            LOCAL SYMBOL DICTIONARY\nASRCNT   EQU   9                   KEEP COUNT LAST VARIABLE PTR\n         SPACE\nRNTBCNT  DC    F'0'                COUNT OF USER VARIABLE SYMBOLS\nRNTBSCNT DC    F'0'                COUNT OF SUBSCRIPTED VARIABLES\nRNTBSRCH DC    F'0'                TOTAL SEARCH COUNT FOR VARIABLES\nRNTBFAIL DC    F'0'                LOOKASIDE FAILURE COUNT\n         SPACE\nSRNTBLN  DC    A(*-*)              SINGLE ENTRY LENGTH FOR BXLE\nSRNTBCUR DC    A(*-*)              ADDR OF LAST SYSTEM ENTRY (SYSNULL)\nSRNTBBEG DC    V(SYSREFS)          ADDR OF START SYSTEM SYMBOLS\n         SPACE\nSRNM     DC    CL10' '             WORKING REFERENCE NAME\nSRNMSUB  DC    AL2(*-*,0)          SUBSCRIPT VALUE AND DEFAULT\nSRNMFR   DC    AL2(*-*,1)          FROM SUBLIST VALUE AND DEFAULT\nSRNMTO   DC    AL2(*-*,255)        TO SUBLIST VALUE AND DEFAULT\nSRNMFLG  DC    X'00'               REFERENCE NAME FLAG BYTE\nSRNMALL  EQU   X'80'                    ALL SUBSCRIPT FLAG\nSRNMALLP EQU   X'40'                    ALL BUT POSITIVE\nSRNMALLN EQU   X'20'                    ALL BUT NEGATIVE\n*        EQU   X'10'                    UNUSED\nSRNMTSYM EQU   X'08'                    ERROR IN REFERENCE SYMBOL\nSRNMTSUB EQU   X'04'                    ERROR IN REFERENCE SUBSCRIPT\nSRNMTFR  EQU   X'02'                    ERROR IN REF SUBLIST FROM\nSRNMTTO  EQU   X'01'                    ERROR IN REF SUBLIST TO\n         SPACE\n***********************************************************************\n*                                                                     *\n*              END OF DIRECTLY ADDRESSABLE PORTION                    *\n*                                                                     *\n***********************************************************************\n         SPACE\nSCRDATWK DC    0D'0'               START OF TEMPORARY WORK AREAS\n         SPACE\nTTYPE    DC    X'00'               OUTPUT DEFINITION\nTONLINE  EQU   X'80'                    ON IF OUTPUT ONLINE\nTFILE    EQU   X'40'                    ON IF OUTPUT TO A FILE\nTSCREEN  EQU   X'20'                    ON IF OUTPUT TO A CRT SCREEN\n         SPACE\nTDEVICE  DC    X'00'               DEVICE QUALIFIER\nT2741    EQU   VFO2741-VFO2741          2741 COMPATIBLE\nTX1620   EQU   VFO1620-VFO2741          XEROX 1620 TERMINAL\nTXASM3   EQU   VFOASM3-VFO2741          A.S. MULTIWRITER III\nTQUME    EQU   VFOQUME-VFO2741          QUME TERMINAL\nTXASIS   EQU   VFOASIS-VFO2741          ASIS OUTPUT TERMINAL\nTMYTE    EQU   VFOMYTE-VFO2741          INSTALLATION DEFINED TERMINAL\nTDEVWID  DC    H'0'                CHARACTER WIDTH\nVDEVICEA DC    A(*-*)              TERMINAL DESCRIPTOR POINTER\nTDEVATEA DC    A(TDEVATE)          ASCII TO EBCDIC TRANSLATE TABLE\nBSHJ     DC    AL1(*-*),AL1(YNHJ)  HEX JOIN ATTRIBUTE OF USER BACKSPACE\n         SPACE 2\n         ORG   SCRDATWK+X'100'     LEAVE A HOLE FOR TEMPORARIES\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              BUFFER AND WORK AREAS                                  *\n*                                                                     *\n***********************************************************************\n         SPACE\nBUFF3    DC    H'0',H'0',CL240' ',CL16' '  DUMMY TERM READS HERE\nWRKBUFF  DC    CL240' ',CL16' '    HEADING/FOOTING BUFFER\n         EJECT\n***********************************************************************\n*                                                                     *\n*              TRANSLATE TABLE FOR .TR AND TRANSLATE PARM             *\n*                                                                     *\n***********************************************************************\n         SPACE\n         DC    0D'0'               TO ALIGN TRANSLATE TABLES\nTRANTABO DC    256AL1(*-TRANTABO)  OUTPUT TRANSLATE TABLE\n         SPACE\nTRANTABI DC    256AL1(*-TRANTABI)  INPUT TRANSLATE TABLE\n         SPACE\nESTABLE  DC    XL256'00'           INPUT ESCAPE CHAR TABLE\n         SPACE\nCWTABLE  DC    XL256'00'           CONTROL WORD SEPARATOR TABLE\n         ORG   CWTABLE+C';'        DEFAULT VALUE\n         DC    C';'                DEFAULT SEPARATOR\n         ORG\n         SPACE\nNUMTBL   DC    256X'FF'            NUMERIC TRANSLATE AND TEST TABLE\n         ORG   NUMTBL+C'0'\n         DC    10X'00'\n         ORG   ,\n         SPACE\nHEXTABLE DC    256X'FF'            HEX TO CHARACTER CONVERSION AID\n         ORG   HEXTABLE+C'A'-C' '  LOWER ALPHA\n         DC    AL1(10,11,12,13,14,15)\n         ORG   HEXTABLE+C'A'       UPPER ALPHA\n         DC    AL1(10,11,12,13,14,15)\n         ORG   HEXTABLE+C'0'       NUMERICS\n         DC    AL1(0,1,2,3,4,5,6,7,8,9)\n         ORG   ,\n         SPACE\nTRINIT   DC    256AL1(*-TRINIT)    IDENTITY TRANSLATE TABLE\n         SPACE\nUDON     EQU   X'01'               IF CHAR TO BE UNDERSCORED\nUDOFF    EQU   X'00'               IF CHAR NOT TO BE UNDERSCORED\nUDTABLE  DC    XL256'00'           UNDERSCORE TABLE\n         SPACE\nUPTABLE  DC    256AL1(*-UPTABLE)   UPPER CASE TRANSLATE TABLE\n         ORG   UPTABLE+C'A'-C' '   LOWER CASE 'A'\n         DC    C'ABCDEFGHI'        LOWER TO UPPER\n         ORG   UPTABLE+C'J'-C' '   LOWER CASE 'J'\n         DC    C'JKLMNOPQR'        LOWER TO UPPER\n         ORG   UPTABLE+C'S'-C' '   LOWER CASE 'S'\n         DC    C'STUVWXYZ'         LOWER TO UPPER\n         ORG   ,\n         SPACE\nTDEVATE  DC    X'00010203372D2E2F1605250B0C0D0E0F'\n         DC    X'101112133C3D322618193F27221D351F'\n         DC    C' !\"#$%&&''()*+,-./'\n         DC    C'0123456789:;<=>?'\n         DC    C'@ABCDEFGHIJKLMNO'\n         DC    C'PQRSTUVWXYZ',X'ADE0BD4A6D'\n         DC    X'79',C'abcdefghijklmno'\n         DC    C'pqrstuvwxyz',X'C04FD05F07'\n         DC    128X'00'\n         SPACE\nCSTABLE  DC    2XL100'00'          .CS INCLUDE STATUS, 00 ON, FF OFF\n*                                  .CS CURRENTLY ON STATUS\n         SPACE\nPUIOCBAD DC    (PUMAX+1)A(*-*)     PUT FILE IOCB ADDRESSES\n         SPACE\nEVNHEAD  DC    (HSFSCT)A(0)        EVEN PAGE HEADING/FOOTING POINTERS\nODDHEAD  DC    (HSFSCT)A(0)        ODD PAGE HEADING/FOOTING POINTERS\nFTHEAD   DC    (HSFSCT)A(0)        FOOTNOTE TITLE POINTERS\n         SPACE\nSRGBL    DC    0A(*-*)             GLOBAL SYMBOL DICTIONARY\nSGBLANCH DC    A(*-*)              GBL VARIABLE SYMBOL ANCHOR\nSGBLLAST DC    (ASRCNT)A(*-*)      LAST GBL SUCCESSES\n         SPACE\nSRLCL    DC    0A(*-*)             LOCAL SYMBOL DICTIONARY\nSLCLANCH DC    A(*-*)              LCL VARIABLE SYMBOL ANCHOR\nSLCLLAST DC    (ASRCNT)A(*-*)      LAST LCL SUCCESSES\n         SPACE\nRGLIST   DC    0F'0'               REGION MANAGER PARM LIST\nPCELLLEN DC    A(*-*)              CELL LENGTH FOR GETCELL/FREECELL\nPCELLPTR DC    A(*-*)              CELL ADDR FOR GETCELL/FREECELL\nPRGFLAG  DC    XL4'00'             CALL TYPE\nPRGINIT  EQU   X'00'                    INITIAL CALL\nPRGFINIS EQU   X'FF'                    TERMINATION CALL\nPMAXEXTS DC    AL1(63)             MAX 4K BLOCKS ALLOCATED -1\nPMINEXTS DC    AL1(1)              MIN 4K BLOCKS ALLOCATED -1\nPSPNUMBR DC    AL1(0)              SUB-POOL NUMBER\n         DC    AL1(0)                   *RESERVED*\nPMNCSIZE DC    A(0)                MIN CELL SIZE\nRGWORKAR DC    XL(X'90')'00'       REGION MANAGER WORK AREA\nPRGLEN   EQU   *-RGLIST            LENGTH OF REGION MANAGER PARM LIST\n         SPACE\nDUMPAREA DC    0D'0'               START OF DUMP DATA\nDUMPPSW  DC    XL8'0'              DUMP PSW\nDUMPREG  DC    16F'0'              DUMP REGISTERS\nDUMPFROM DC    A(0)                DUMP FROM ADDRESS\nDUMPTO   DC    A(0)                DUMP TO ADDRESS\nDUMPLEN  EQU   *-DUMPAREA          LENGTH OF DUMP AREA\n         SPACE 2\n         POP   USING\n         POP   PRINT\n         MEND\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$OFF": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00(\\x00(\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n&LABEL  $OFF       &BYTE,&FLAG\n.*       BUILT TO HANDLE TEN SWITCHES, BUT RESTRICTED TO SIX\n         LCLA      &I,&J,&K,&C(10)\n         LCLC      &TC,&A(150)\n         AIF       ('&LABEL' EQ '').SKIP01\n&LABEL   DS        0H\n.SKIP01  AIF       ('&BYTE' EQ '').MNOTE01\n&I       SETA      N'&FLAG\n         AIF       (&I LT 1 OR &I GT 6).MNOTE02\n.SKIP02  ANOP\n&TC      SETC      T'&FLAG(&I)\n&J       SETA      0\n         AIF       ('&TC' LT '0').SKIP03\n&J       SETA      &TC\n.SKIP03  ANOP\n&K       SETA  &J*15+&C(&J+1)+1\n         AIF   (&C(&J+1) EQ 0).SKIP04\n&A(&K)   SETC  '-'\n&C(&J+1) SETA  &C(&J+1)+1\n&K       SETA  &K+1\n.SKIP04  ANOP\n&A(&K)   SETC  '&FLAG(&I)'\n&C(&J+1) SETA  &C(&J+1)+1\n&I       SETA      &I-1\n         AIF       (&I GT 0).SKIP02\n&I       SETA      9\n.SKIP05  ANOP\n&K       SETA  &I*15+1\n         AIF   ('&A(&K)' EQ '').SKIP06\n         NI    &BYTE.+&I,255-&A(&K).&A(&K+1).&A(&K+2).&A(&K+3).&A(&K+4)*\n               .&A(&K+5).&A(&K+6).&A(&K+7).&A(&K+8).&A(&K+9).&A(&K+10)\n.SKIP06  ANOP\n&I       SETA      &I-1\n         AIF       (&I GE 0).SKIP05\n         MEXIT\n.MNOTE01 MNOTE     4,'$OFF  --  MISSING FIRST PARAMETER'\n         MEXIT\n.MNOTE02 MNOTE     4,'$OFF  --  INVALID SECOND PARAMETER'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$ON": {"ttr": 1292, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00(\\x00(\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n&LABEL  $ON        &BYTE,&FLAG\n.*       BUILT TO HANDLE TEN SWITCHES, BUT RESTRICTED TO SIX\n         LCLA      &I,&J,&K,&C(10)\n         LCLC      &TC,&A(150)\n         AIF       ('&LABEL' EQ '').SKIP01\n&LABEL   DS        0H\n.SKIP01  AIF       ('&BYTE' EQ '').MNOTE01\n&I       SETA      N'&FLAG\n         AIF       (&I LT 1 OR &I GT 6).MNOTE02\n.SKIP02  ANOP\n&TC      SETC      T'&FLAG(&I)\n&J       SETA      0\n         AIF       ('&TC' LT '0').SKIP03\n&J       SETA      &TC\n.SKIP03  ANOP\n&K       SETA  &J*15+&C(&J+1)+1\n         AIF   (&C(&J+1) EQ 0).SKIP04\n&A(&K)   SETC  '+'\n&C(&J+1) SETA  &C(&J+1)+1\n&K       SETA  &K+1\n.SKIP04  ANOP\n&A(&K)   SETC  '&FLAG(&I)'\n&C(&J+1) SETA  &C(&J+1)+1\n&I       SETA      &I-1\n         AIF       (&I GT 0).SKIP02\n&I       SETA      9\n.SKIP05  ANOP\n&K       SETA  &I*15+1\n         AIF   ('&A(&K)' EQ '').SKIP06\n         OI    &BYTE.+&I,&A(&K).&A(&K+1).&A(&K+2).&A(&K+3).&A(&K+4).&A(*\n               &K+5).&A(&K+6).&A(&K+7).&A(&K+8).&A(&K+9).&A(&K+10)\n.SKIP06  ANOP\n&I       SETA      &I-1\n         AIF       (&I GE 0).SKIP05\n         MEXIT\n.MNOTE01 MNOTE     4,'$ON  --  MISSING FIRST PARAMETER'\n         MEXIT\n.MNOTE02 MNOTE     4,'$ON  --  INVALID SECOND PARAMETER'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$RESTOR": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x13\\x00\\x13\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n&LABEL  $RESTOR &KEEP=\n         LCLA  &I\n         LCLC  &LAST\n&LAST    SETC  '15'\n&I       SETA  N'&KEEP\n         AIF   ('&LABEL' EQ '').SKIP01\n&LABEL   DS    0H\n.SKIP01  AIF   (&I LE 0).SKIP04\n         AIF   ('&KEEP(&I)' EQ 'R15').SKIP02\n         ST    &KEEP(&I),4*&KEEP(&I).(,BASESAVE)  SAVE KEEP REGISTER\n         AGO   .SKIP03\n.SKIP02  ANOP\n&LAST    SETC  '14'\n.SKIP03  ANOP\n&I       SETA  &I-1\n         AGO   .SKIP01\n.SKIP04  LM    0,&LAST,0(BASESAVE) RESTORE CALLER'S REGISTERS\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$SAVE": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x05\\x00\\x05\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n&LABEL  $SAVE  ,\n&LABEL   STM   0,15,SAVELEN(BASESAVE)   SAVE ALL REGISTERS\n         LA    BASESAVE,SAVELEN(,BASESAVE)   NEXT SAVE AREA ON STACK\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$SCRCVT": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x01\\xf4\\x01\\xf4\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 500, "newlines": 500, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n        $SCRCVT  &DSECT=NO,&DOC=NOGEN\n         PUSH  PRINT\n         PRINT &DOC\n         AIF   ('&DSECT' EQ 'NO').SKIP01\nSCRICVT  DSECT ,                   START OF COMMUNICATION AREA\n         AGO   .SKIP02\n.SKIP01  ANOP\nSCRICVT  CSECT ,                   START OF COMMUNICATION AREA\n.SKIP02  ANOP\n         SPACE\n***********************************************************************\n*                                                                     *\n*              SCRIPTCW CONSTANT AREA                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nVFSTATS  DC    0A(*-*)             FULLSTAT START ADDR\n         SPACE\nVCWSCRIP DC    A(*-*)              SCRIPT CONTROL WORD ROUTINE\nVAB      DC    A(*-*)              ABEND ROUTINE\nVAD      DC    A(*-*)              ADJUST ROUTINE\nVAP      DC    A(*-*)              APPEND ROUTINE\nVAPI     DC    A(*-*)              APPEND FILENAME SCANNER\nVAPS     DC    A(*-*)              APPEND ARG SCANNER\nVAR      DC    A(*-*)              ARABIC ROUTINE\nVBM      DC    A(*-*)              BOTTOM MARGIN ROUTINE\nVBR      DC    A(*-*)              BREAK ROUTINE\nVBS      DC    A(*-*)              BACKSPACE ROUTINE\nVBX      DC    A(*-*)              BOX BUILD DEFINITION\nVBXCLR   DC    A(*-*)              CLEAR CURRENT BOX DEFINITION\nVCE      DC    A(*-*)              CENTER ROUTINE\nVCELARA  DC    A(*-*)              CENTER/LEFT/RIGHT SCANNER\nVCM      DC    A(*-*)              COMMENT ROUTINE\nVCO      DC    A(*-*)              CONCATENATE ROUTINE\nVCR      DC    A(*-*)              CONTROL WORD REPLACEMENT ROUTINE\nVCS      DC    A(*-*)              CONDITIONAL SECTION ROUTINE\nVCW      DC    A(*-*)              CONTROL WORD SEPARATOR ROUTINE\nVDA      DC    A(*-*)              DARK OUTPUT\nVDC      DC    A(*-*)              DON'T COUNT ROUTINE\nVDO      DC    A(*-*)              DO GROUP START\nVDS      DC    A(*-*)              DOUBLE SPACE ROUTINE\nVEF      DC    A(*-*)              END OF FILE ROUTINE\nVEL      DC    A(*-*)              ELSE ROUTINE\nVEM      DC    A(*-*)              EMPTY PAGE ROUTINE\nVEN      DC    A(*-*)              END DO GROUP\nVOB      DC    A(*-*)              ODD BOTTOM TITLE ROUTINE\nVER      DC    A(*-*)              ERROR MESSAGE CONTROL\nVFD      DC    A(*-*)              ODD PAGE FOOTING ROUTINE\nVBT      DC    A(*-*)              BOTTOM TITLE ROUTINE\nVFE      DC    A(*-*)              FOOTING ROUTINE\nVFM      DC    A(*-*)              FOOTING MARGINE ROUTINE\nVFO      DC    A(*-*)              FORMAT ROUTINE\nVFS      DC    A(*-*)              FOOTING SPACE ROUTINE\nVEB      DC    A(*-*)              EVEN BOTTOM TITLE ROUTINE\nVFV      DC    A(*-*)              EVEN PAGE FOOTING ROUTINE\nVOT      DC    A(*-*)              ODD TOP TITLE ROUTINE\nVGO      DC    A(*-*)              GOTO ROUTINE\nVHD      DC    A(*-*)              ODD PAGE HEADING ROUTINE\nVTT      DC    A(*-*)              TOP TITLE ROUTINE\nVHE      DC    A(*-*)              HEADING ROUTINE\nVHI      DC    A(*-*)              HANGING INDENT ROUTINE\nVHM      DC    A(*-*)              HEADING MARGIN ROUTINE\nVHS      DC    A(*-*)              HEADING SPACE ROUTINE\nVET      DC    A(*-*)              EVEN TOP TITLE ROUTINE\nVHV      DC    A(*-*)              EVEN PAGE HEADING ROUTINE\nVHW      DC    A(*-*)              HYPHENATE WORD\nVIF      DC    A(*-*)              IF ROUTINE\nVIL      DC    A(*-*)              INDENT LINE\nVIM      DC    A(*-*)              IMBED ROUTINE\nVIN      DC    A(*-*)              INDENT ROUTINE\nVJU      DC    A(*-*)              JUSTIFY ROUTINE\nVLA      DC    A(*-*)              LEFT ADJUST ROUTINE\nVLB      DC    A(*-*)              LABEL ROUTINE\nVLBCLR   DC    A(*-*)              CLEAR LABEL BLOCKS\nVLE      DC    A(*-*)              LEADING SPACE ROUTINE\nVLI      DC    A(*-*)              LITERAL ROUTINE\nVLL      DC    A(*-*)              LINE LENGTH ROUTINE\nVLN      DC    A(*-*)              ABSOLUTE LINE\nVLS      DC    A(*-*)              LINE SPACING ROUTINE\nVNC      DC    A(*-*)              NO CONCATENATE ROUTINE\nVNF      DC    A(*-*)              NO FORMAT ROUTINE\nVNJ      DC    A(*-*)              NO JUSTIFY ROUTINE\nVNL      DC    A(*-*)              NULL COMMAND\nVOC      DC    A(*-*)              OVERLAY CHARACTER ROUTINE\nVOF      DC    A(*-*)              OFFSET ROUTINE\nVOJ      DC    A(*-*)              OUT JUSTIFY\nVOO      DC    A(*-*)              OVERLAY OUTPUT ROUTINE\nVOVPROC  DC    A(*-*)              OVERLAY ELEMENT OPERAND\nVOV      DC    A(*-*)              OVERLAY INPUT ROUTINE\nVPA      DC    A(*-*)              PAGE EJECT ROUTINE\nVPD      DC    A(*-*)              ODD PAGE EJECT\nVPE      DC    A(*-*)              PERFORM ROUTINE\nVPI      DC    A(*-*)              PARAGRAPH INDENT ROUTINE\nVPL      DC    A(*-*)              PAGE LENGTH CONTROL\nVPN      DC    A(*-*)              PAGE NUMBER CONTROL\nVPP      DC    A(*-*)              PARAGRAPH START\nVPR      DC    A(*-*)              PRINT ROUTINE\nVPS      DC    A(*-*)              PAGE SYMBOL CONTROL\nVPU      DC    A(*-*)              PUT WORK FILE\nVPV      DC    A(*-*)              EVEN PAGE EJECT CONTROL\nVQQ      DC    A(*-*)              QUIT QUICKLY\nVQT      DC    A(*-*)              QUIT CONTROL\nVRA      DC    A(*-*)              RIGHT ADJUST CONTROL\nVRC      DC    A(*-*)              REVISION CODE CONTROL\nVRCOFF   DC    A(*-*)              REMOVE ONE REVISION CODE\nVRCAGET  DC    A(*-*)              GET REV CODE AREA\nVRCAINIT DC    A(*-*)              INITIALIZE REV CODE AREA\nVRCAFREE DC    A(*-*)              FREE REV CODE AREA\nVRD      DC    A(*-*)              READ TERMINAL CONTROL\nVRE      DC    A(*-*)              RESTORE CONTROL\nVSTAKFRE DC    A(*-*)              FREE SAVE/RESTORE STACK\nVRO      DC    A(*-*)              ROMAN NUMBERING CONTROL\nVRV      DC    A(*-*)              READ VARIABLE\nVSA      DC    A(*-*)              SAVE CONTROL\nVSE      DC    A(*-*)              SET REFERENCE CONTROL\nVSITST   DC    A(*-*)              SIGNAL SCANNER\nVSIS     DC    A(*-*)              SIGNAL ROUTINE\nVSI      DC    A(*-*)              SIGNAL CONTROL\nVSK      DC    A(*-*)              SKIP\nVSP      DC    A(*-*)              SPACE CONTROL\nVSPEX    DC    A(*-*)              SPACE EXECUTION CONTROL\nVSR      DC    A(*-*)              SET REFERENCE CONTROL\nVSS      DC    A(*-*)              SINGLE SPACE CONTROL\nVSU      DC    A(*-*)              SUBSTITUTE SYMBOL CONTROL\nVSY      DC    A(*-*)              SYSTEM\nVTB      DC    A(*-*)              TAB CONTROL\nVTBFREBL DC    A(*-*)              FREE USER TAB CHAIN\nVTBCOPY  DC    A(*-*)              DUPLICATE USER TAB CHAIN\nVTE      DC    A(*-*)              READ TERMINAL CONTROL\nVTH      DC    A(*-*)              THEN CONTROL\nVTI      DC    A(*-*)              TRANSLATE ON INPUT CONTROL\nVTM      DC    A(*-*)              TOP MARGIN CONTROL\nVTR      DC    A(*-*)              TRANSLATE ON OUTPUT CONTROL\nVTRSCN   DC    A(*-*)              SCAN TRANSLATE OPERANDS\nVTRHEX   DC    A(*-*)              CHAR TO HEX CONVERSION\nVTRRESET DC    A(*-*)              RESET TRANSLATE TABLE\nVUC      DC    A(*-*)              UNDERSCORE AND CAPITALIZE\nVUD      DC    A(*-*)              UNDERSCORE DEFINITION\nVUDRESET DC    A(*-*)              INITIALIZE UNDERSCORE DEFINITION\nVUL      DC    A(*-*)              UNDERLINE ALPHANUMERICS\nVUN      DC    A(*-*)              UNDENT CONTROL\nVUP      DC    A(*-*)              UPPERCASE\nVUR      DC    A(*-*)              USE REFERENCE CONTROL\nVUS      DC    A(*-*)              UNDERSCORE\nVUSOP    DC    A(*-*)              PERFORM UNDERSCORE OPERATION\nVUSARG   DC    A(*-*)              ISOLATE UNDERSCORE ARG LINE\nVWD      DC    A(*-*)              WIDOW CONTROL\n         DC    A(*-*)\n         DC    A(*-*)\n         DC    A(*-*)\nVLCWSCRI EQU   *-VCWSCRIP          LENGTH OF SCRIPTCW ADCONS\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              SCRIPTMC CONSTANT AREA                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nVMCSCRIP DC    A(*-*)              SCRIPT MULTI-COL ROUTINES\nVBC      DC    A(*-*)              BALANCE COLUMNS ROUTINE\nVCB      DC    A(*-*)              COLUMN BEGIN ROUTINE\nVCC      DC    A(*-*)              CONDITIONAL COLUMN BEGIN ROUTINE\nVCD      DC    A(*-*)              COLUMN DEFINITION ROUTINE\nVCL      DC    A(*-*)              COLUMN LENGTH ROUTINE\nVCOLBAL  DC    A(*-*)              COLUMN BALANCE ROUTINE\nVCOLNEW  DC    A(*-*)              NEW OUTPUT COLUMN ROUTINE\nVCOLPAGE DC    A(*-*)              COLUMN EJECT\nVCOLPRT  DC    A(*-*)              COLUMN PRINT ROUTINE\nVCOLSAVE DC    A(*-*)              COLUMN SAVE ROUTINE\nVCP      DC    A(*-*)              CONDITIONAL PAGE ROUTINE\nVCPENDS  DC    A(*-*)              BLOCK END SET ROUTINE\nVCPFKNXT DC    A(*-*)              COUNT NEXT INCORE DATA BLOCK\nVCPFKPRT DC    A(*-*)              PRINT INCORE DATA BLOCK\nVDH      DC    A(*-*)              DEFINE HEAD LEVEL ROUTINE\nVDHCLR   DC    A(*-*)              DEFINE HEAD LEVEL INITIALIZE\nVDM      DC    A(*-*)              DEFINE MACRO\nVEZ      DC    A(*-*)              EASY SCRIPT\nVFB      DC    A(*-*)              FLOATING BLOCK\nVFK      DC    A(*-*)              FLOATING KEEP\nVFN      DC    A(*-*)              FOOTNOTE ROUTINE\nVFNPRT   DC    A(*-*)              PRINT FOOTNOTE\nVFNSAVE  DC    A(*-*)              SAVE INCORE OUTPUT LINE\nVHIDBADD DC    A(*-*)              ADD HIDDEN READ BUFFER LINE\nVHIDBDEL DC    A(*-*)              REMOVE HIDDEN READ BUFFER LINE\nVHIDBPUR DC    A(*-*)              REMOVE ALL HIDDEN READ BUFFER LINES\nVHIDTCAD DC    A(*-*)              SAVE INCORE TABLE OF CONTENTS LINE\nVHIDTCCN DC    A(*-*)              TABLE OF CONTENTS CHAIN\nVHIDTCOR DC    A(*-*)              SAVE FLOATING CONTENTS CHAIN\nVHL      DC    A(*-*)              HEAD LEVEL\nVHN      DC    A(*-*)              HEADNOTE ROUTINE\nVHNCLR   DC    A(*-*)              HEADNOTE CANCEL ROUTINE\nVHNPRT   DC    A(*-*)              HEADNOTE PRINT ROUTINE\nVIX      DC    A(*-*)              INDEX CONTROL\nVIXCLR   DC    A(*-*)              INDEX CLEAR ROUTINE\nVIXDRM   DC    A(*-*)              INDEX DUMP REMOTE READ ROUTINE\nVIXDUMP  DC    A(*-*)              INDEX DUMP INITIALIZE ROUTINE\nVIXPROC  DC    A(*-*)              INDEX PROCESS ROUTINE\nVMC      DC    A(*-*)              MULTIPLE COLUMN ROUTINE\nVMS      DC    A(*-*)              MACRO SUBSTITUTE\nVPT      DC    A(*-*)              PUT TABLE OF CONTENTS\nVRM      DC    A(*-*)              REMOTE DEFINITION CONTROL\nVRMCLR   DC    A(*-*)              CLEAR ALL REMOTES\nVRMCOND  DC    A(*-*)              CONDITIONAL REMOTE SIGNAL\nVRMDEL   DC    A(*-*)              DELETE ONE MACRO/REMOTE\nVRMFIND  DC    A(*-*)              FIND REMOTE INSERTION POINT\nVRMIMBED DC    A(*-*)              IMBED A REMOTE FILE\nVRMNEXT  DC    A(*-*)              LOCATE NEXT AUTOMATIC REMOTE\nVRMREAD  DC    A(*-*)              BUILD REMOTE LINES\nVSC      DC    A(*-*)              SINGLE COLUMN ROUTINE\nVTC      DC    A(*-*)              TABLE OF CONTENTS\n         DC    A(*-*)\n         DC    A(*-*)\n         DC    A(*-*)\nVLMCSCRI EQU   *-VMCSCRIP         LENGTH OF SCRIPTMC ADCONS\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              SCRIPTOU CONSTANT AREA                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nVOUSCRIP DC    A(*-*)              SCRIPT SUBROUTINE ROUTINE\nVSPACER  DC    A(*-*)              SPACE DOWN ROUTINE\nVSPACEIM DC    A(*-*)              SPACE ONLINE IMMEDIATE\nVPRINTNB DC    A(*-*)              NOBREAK AUTOBREAK CHECK\nVPRINT   DC    A(*-*)\nVPAGE    DC    A(*-*)\nVPAGETOP DC    A(*-*)\nVHEADSAV DC    A(*-*)\nVHEADCLR DC    A(*-*)              INITIALIZE TITLES\nVGETCELL DC    A(*-*)\nVFREECEL DC    A(*-*)\nVIOPRINT DC    A(*-*)\nVIOADJ   DC    A(*-*)\nVOOPRT   DC    A(*-*)              OVERLAY OUTPUT PROCESSOR\nVOVREMOV DC    A(*-*)\nVOVCLR   DC    A(*-*)              REMOVE ALL OVERLAY ELEMENTS\nVSCRIPUT DC    A(*-*)\nVFLUSHSP DC    A(*-*)              FLUSH OFFLINE SPACES\nVSYMCLR  DC    A(*-*)              DELETE DICTIONARY SYMBOLS\nVSYMSR   DC    A(*-*)              SET SYMBOL SEARCH ROUTINE\nVSYMUR   DC    A(*-*)              USE SYMBOL SEARCH ROUTINE\nVSYMUSL  DC    A(*-*)              SYMBOL SEARCH ROUTINE\nVTERMREA DC    A(*-*)\nVREAD    DC    A(*-*)\nVGETYESN DC    A(*-*)\nVGETQST  DC    A(*-*)\nVQUITS   DC    A(*-*)              TERMINATION ROUTINE\nVGETSYM  DC    A(*-*)\nVARGINIT DC    A(*-*)\nVGETNUM  DC    A(*-*)\nVGETARG  DC    A(*-*)\nVDUMPIT  DC    A(*-*)\nVHEADPRT DC    A(*-*)\nVOUSTAT  DC    A(*-*)\nVERROUT  DC    A(*-*)\nVODDEVN  DC    A(*-*)              EVEN OR ODD PAGE DETERMINATION\nVPNUMFMT DC    A(*-*)              FORMAT CURRENT PAGE NUMBER\nVPRTERM  DC    A(*-*)              WRITE RECORD TO ERROR FILE\nVBXHORIZ DC    A(*-*)              HORIZONTAL BOX LINE GENERATOR\nVBXVERT  DC    A(*-*)              VERTICAL BOX LINE GENERATOR\nVPUTPRT  DC    A(*-*)              SYSPRINT OUTPUT ROUTINE\nVPUTTERM DC    A(*-*)              SYSTERM OUTPUT ROUTINE\nVPUWORK  DC    A(*-*)              PUT I/O WORK ROUTINE\nVPAGEREA DC    A(*-*)              PHYSICAL PAGE EJECT\nVVTRAPS  DC    A(*-*)              CALLER'S ROUTINE TRAPS\nVPRLIN   DC    A(*-*)              ENTER LINENUM OR LEGAL OPTION\nVPRNUM   DC    A(*-*)              ENTER NUM OPTION DATA\nVPRRCADD DC    A(*-*)              ADD REVISION CODE TO OUTPUT\nVPRSKSPC DC    A(*-*)              FLUSH CONDITIONAL SPACE/SKIP\nVPRTARG  DC    A(*-*)              GET PRINT TARGET WITHIN OUTPUT LINE\nVMAINOC  DC    A(*-*)              OVERLAY CHARACTER ROUTINE\nVRGNMGR  DC    A(*-*)              SCRIPT USER REGION MANAGER\nVPUTCONS DC    A(*-*)              PUT TO ONLINE CONSOLE\n         DC    A(*-*)\n         DC    A(*-*)\n         DC    A(*-*)\nVLOUSCRI EQU   *-VOUSCRIP          LENGTH OF SCRIPTOU ADCONS\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              SCRIPTFO CONSTANT AREA                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nVFOSCRIP DC    A(*-*)              SCRIPT CHARACTER FORMAT ROUTINES\nVMERGE   DC    A(*-*)              MERGE NEW INPUT LINE\nVADJUST  DC    A(*-*)              JUSTIFY OUTPUT LINE\nVCENTER  DC    A(*-*)              CENTRE OUTPUT LINE\nVRIGHTAD DC    A(*-*)              RIGHT JUSTIFY OUTPUT LINE\nVTABIT   DC    A(*-*)              EXPAND USER'S TABS\nVTABITA  DC    A(*-*)              CHARACTER ALIGN TAB\nVTABITC  DC    A(*-*)              CENTER ALIGN TAB\nVTABITL  DC    A(*-*)              LEFT ALIGN TAB\nVTABITR  DC    A(*-*)              RIGHT ALIGN TAB\nVTABPCC  DC    A(*-*)              PHRASE CHARACTER COUNT\nVTABFILL DC    A(*-*)              TAB CHARACTER STRING FILL\nVFOADD   DC    A(*-*)              ADD MORE CHARACTER BLOCKS\nVLKINIT  DC    A(*-*)              INITIALIZE CHARACTER BLOCKS\nVLKGESC  DC    A(*-*)              ADD ESCAPE SEQUENCE TO OUTPUT\nVLKGETP  DC    A(*-*)              UNSTRING CHARACTERS FOR PRINTER\nVLKGETT  DC    A(*-*)              UNSTRING CHARACTERS FOR TERMINAL\nVLKPUT   DC    A(*-*)              ADD NEW CHARACTERS\nVLKADD   DC    A(*-*)              ADD NEW CHARACTER BLOCK\nVLKCHAIN DC    A(*-*)              CHAIN NEW CHARACTER BLOCK\nVFOHYPH  DC    A(*-*)              AUTOMATIC HYPHENATION\nVTABCHK  DC    A(*-*)              TAB/CHAR CHECK\nVPUNCADJ DC    A(*-*)              JUSTIFY AFTER PUNCTUATION\n         DC    A(*-*)\n         DC    A(*-*)\n         DC    A(*-*)\nVFO2741  DC    A(*-*)              2741 ESCAPE CONTROL\nVFO1620  DC    A(*-*)              XEROX 1620 ESCAPE CONTROL\nVFOASM3  DC    A(*-*)              AHEARN/SOPER MULTIWRITER III\nVFOQUME  DC    A(*-*)              QUME\nVFOASIS  DC    A(*-*)              SPECIAL CHARACTERS HANDLED 'ASIS'\nVFOMYTE  DC    A(*-*)              INSTALLATION DEPENDENT TERMINAL\n         DC    A(*-*)\nVLFOSCRI EQU   *-VFOSCRIP          LENGTH OF SCRIPTFO ADCONS\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              SCRIPTHY CONSTANT AREA                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nVHYSCRIP DC    A(*-*)              SCRIPT HYPHENATION ROUTINES\nVHY      DC    A(*-*)              HYPHENATION SET\nVHYPHEN  DC    A(*-*)              HYPHENATION ROUTINE\nVHYSCN   DC    A(*-*)              EXCEPTION WORD SCAN ROUTINE\nVDCOMPOZ DC    A(*-*)              DECOMPOSE AND PACK WORD\nVSUFFIX  DC    A(*-*)              SUFFIX ANALYSIS\nVEXCEPT  DC    A(*-*)              EXCEPTION WORD ANALYSIS\nVHALGO   DC    A(*-*)              PROBABILITY ALGORITHM\n         DC    A(*-*)\n         DC    A(*-*)\n         DC    A(*-*)\nVLHYSCRI EQU   *-VHYSCRIP          LENGTH OF SCRIPTHY ADCONS\n         SPACE\nVHZSCRIP DC    A(*-*)              SCRIPT HYPHENATION DICTIONARY\n         DC    A(*-*)\n         DC    A(*-*)\n         DC    A(*-*)\nVLHZSCRI EQU   *-VHZSCRIP          LENGTH OF SCRIPTHZ ADCONS\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              SCRIPTPM CONSTANT AREA                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nVPMSCRIP DC    A(*-*)              SCRIPT PARM SCAN/INITIALIZE ROUTINE\nVPARMSCA DC    A(*-*)              PARM SCAN ROUTINE\n         DC    A(*-*)\n         DC    A(*-*)\nVLPMSCRI EQU   *-VPMSCRIP          LENGTH OF SCRIPTPM ADCONS\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              SCRIPTRD CONSTANT AREA                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nVRDSCRIP DC    A(*-*)              SCRIPT READER ROUTINE\nVRDFILE  DC    A(*-*)              OPEN AN INPUT FILE\nVRDLINE  DC    A(*-*)              READ AN INPUT RECORD\nVRDFINDF DC    A(*-*)\nVRDSCANF DC    A(*-*)\nVRDPURGE DC    A(*-*)\nVRDPURON DC    A(*-*)\nVRDPUSH  DC    A(*-*)\nVRDPOP   DC    A(*-*)\nVRDERROR DC    A(*-*)\nVRDCLOSE DC    A(*-*)\nVRDGBUFF DC    A(*-*)\nVRDFBUFF DC    A(*-*)\nVRDREWIN DC    A(*-*)              REWIND INPUT FILE\nVRDRECD  DC    A(*-*)              DEBLOCK RECORD FROM INPUT FILE\nVRDDDREP DC    A(*-*)              FILENAME REPLACEMENT\nVRDEJCT  DC    A(*-*)              ONLINE PAGE EJECT\nVRDJIGG  DC    A(*-*)              ONLINE TYPEBALL JIGGLE\n         DC    A(*-*)\n         DC    A(*-*)\n         DC    A(*-*)\nVLRDSCRI EQU   *-VRDSCRIP          LENGTH OF SCRIPTRD ADCONS\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              SCRIPTSY CONSTANT AREA                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nVSYSCRIP DC    A(*-*)              SCRIPT SYSTEM DEPENDENT ROUTINES\nVSYSINT  DC    A(*-*)              SYSTEM INTERFACE ROUTINE\nVSYFMAIN DC    A(*-*)              SYSTEM FREEMAIN\nVSYGMAIN DC    A(*-*)              SYSTEM GETMAIN\nVSYTIME  DC    A(*-*)              TIME OF DAY ROUTINE\nVSYABEND DC    A(*-*)              USER ABEND ROUTINE\nVSYSPIE  DC    A(*-*)              SPECIFY PROGRAM INTERRUPT EXIT\nVSYWTO   DC    A(*-*)              WRITE TO OPERATOR\nVSYPUTOP DC    A(*-*)              QSAM OPEN FOR PUT\nVSYPUT   DC    A(*-*)              QSAM PUT\nVSYPUTCL DC    A(*-*)              QSAM CLOSE AFTER PUT\nVSYTEST  DC    A(*-*)              FILE DEFINED TEST\nVSYCONSW DC    A(*-*)              WRITE TO ONLINE TERMINAL USER\n         DC    A(*-*)\n         DC    A(*-*)\n         DC    A(*-*)\nVLSYSCRI EQU   *-VSYSCRIP\n         SPACE\nVFSTATE  EQU   *-L'VFSTATS         FULLSTAT END ADDRESS\n         SPACE 2\n         POP   PRINT\n         MEND\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$SETON": {"ttr": 1550, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00(\\x00(\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n&LABEL  $SETON     &BYTE,&FLAG\n.*       BUILT TO HANDLE TEN SWITCHES, BUT RESTRICTED TO SIX\n         LCLA      &I,&J,&K,&C(10)\n         LCLC      &TC,&A(150)\n         AIF       ('&LABEL' EQ '').SKIP01\n&LABEL   DS        0H\n.SKIP01  AIF       ('&BYTE' EQ '').MNOTE01\n&I       SETA      N'&FLAG\n         AIF       (&I LT 1 OR &I GT 6).MNOTE02\n.SKIP02  ANOP\n&TC      SETC      T'&FLAG(&I)\n&J       SETA      0\n         AIF       ('&TC' LT '0').SKIP03\n&J       SETA      &TC\n.SKIP03  ANOP\n&K       SETA  &J*15+&C(&J+1)+1\n         AIF   (&C(&J+1) EQ 0).SKIP04\n&A(&K)   SETC  '+'\n&C(&J+1) SETA  &C(&J+1)+1\n&K       SETA  &K+1\n.SKIP04  ANOP\n&A(&K)   SETC  '&FLAG(&I)'\n&C(&J+1) SETA  &C(&J+1)+1\n&I       SETA      &I-1\n         AIF       (&I GT 0).SKIP02\n&I       SETA      9\n.SKIP05  ANOP\n&K       SETA  &I*15+1\n         AIF   ('&A(&K)' EQ '').SKIP06\n         MVI   &BYTE.+&I,&A(&K).&A(&K+1).&A(&K+2).&A(&K+3).&A(&K+4).&A(*\n               &K+5).&A(&K+6).&A(&K+7).&A(&K+8).&A(&K+9).&A(&K+10)\n.SKIP06  ANOP\n&I       SETA      &I-1\n         AIF       (&I GE 0).SKIP05\n         MEXIT\n.MNOTE01 MNOTE     4,'$SETON  --  MISSING FIRST PARAMETER'\n         MEXIT\n.MNOTE02 MNOTE     4,'$SETON  --  INVALID SECOND PARAMETER'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$SPCTL": {"ttr": 1552, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\t\\x00\\t\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n        $SPCTL &OP,&AD,&FREQ=1\n         GBLA  &G,&GFR(255)\n         GBLC  &GOP(255),&GAD(255)\n&G       SETA  &G+1\n&GOP(&G) SETC  '&OP'\n&GAD(&G) SETC  '&AD'\n&GFR(&G) SETA  &FREQ\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$SPCTLGN": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00(\\x00(\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n        $SPCTLGN   &DOC=NOGEN\n         GBLA  &G,&GFR(255)\n         GBLC  &GOP(255),&GAD(255)\n         LCLA  &I,&J,&W\n         LCLC  &WC\n         ACTR  25000\n         PUSH  PRINT\n         PRINT &DOC\n         MNOTE *,'$SPCTLGN -- NUMBER OF CONTROL WORDS IS &G..'\n.*                 BUBBLE SORT OP AND AD BY FREQUENCY\n.LOOP1   ANOP\n&I       SETA  &I+1\n&J       SETA  &I\n.LOOP2   ANOP\n&J       SETA  &J+1\n         AIF   (&GFR(&I) GE &GFR(&J)).LOOP3\n&W       SETA  &GFR(&I)\n&GFR(&I) SETA  &GFR(&J)\n&GFR(&J) SETA  &W\n&WC      SETC  '&GOP(&I)'\n&GOP(&I) SETC  '&GOP(&J)'\n&GOP(&J) SETC  '&WC'\n&WC      SETC  '&GAD(&I)'\n&GAD(&I) SETC  '&GAD(&J)'\n&GAD(&J) SETC  '&WC'\n.LOOP3   AIF   (&J LT &G).LOOP2\n         AIF   (&I LT &G-1).LOOP1\n.*                 OUTPUT THE RESULTS\n&I       SETA  0\n.OUTLP1  ANOP\n&I       SETA  &I+1\n         AIF   (&I NE &G).OUTLP2\nCTLTABN  EQU   *\n         ENTRY CTLTABN             END OF SCRIPT CONTROL WORD TABLE\n.OUTLP2  ANOP\n&GOP(&I).#### DC CL2'&GOP(&I)',CL2'&GOP(&I)',AL2(V&GAD(&I).-SCRICVT,0)\n         AIF   (&I LT &G).OUTLP1\n         POP PRINT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$SPCTLTB": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x9a\\x00\\x9a\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 154, "newlines": 154, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              SCRIPT NATIVE CONTROL WORDS                            *\n*                                                                     *\n***********************************************************************\n         SPACE\nCTLTAB   CSECT ,                   SCRIPT CONTROL WORD TABLE\n        $SPCTL AB,AB,FREQ=0        ABEND\n        $SPCTL AD,AD               ADJUST\n        $SPCTL AP,AP               APPEND\n        $SPCTL AR,AR               ARABIC PAGE NUMBERS\n        $SPCTL BC,BC               BALANCE COLUMNS\n        $SPCTL BM,BM,FREQ=3        BOTTOM MARGIN\n        $SPCTL BR,BR,FREQ=5        BREAK\n        $SPCTL BS,BS               BACKSPACE\n        $SPCTL BT,BT,FREQ=5        BOTTOM TITLE -- (.FE)\n        $SPCTL BX,BX               BOX\n        $SPCTL CB,CB               COLUMN BEGIN\n        $SPCTL CC,CC               CONDITIONAL COLUMN\n        $SPCTL CD,CD               COLUMN DEFINITION\n        $SPCTL CE,CE,FREQ=7        CENTER\n        $SPCTL CL,CL               COLUMN LENGTH\n        $SPCTL CM,CM,FREQ=5        COMMENT\n        $SPCTL CO,CO               CONCATENATE\n        $SPCTL CP,CP,FREQ=3        CONDITIONAL PAGE EJECT\n        $SPCTL CR,CR               CONTROL WORD REPLACEMENT\n        $SPCTL CS,CS               CONDITIONAL SECTION\n        $SPCTL CW,CW               CONTROL WORD SEPARATOR\n        $SPCTL DA,DA               DARK OUTPUT\n        $SPCTL DC,DC               DON'T COUNT\n        $SPCTL DH,DH               DEFINE HEAD LEVEL\n        $SPCTL DM,DM               DEFINE MACRO\n        $SPCTL DO,DO               DO GROUP\n        $SPCTL DS,DS               DOUBLE SPACE\n        $SPCTL EB,EB               EVEN BOTTOM TITLE -- (.FV)\n        $SPCTL EF,EF               END OF FILE\n        $SPCTL EL,EL,FREQ=3        ELSE\n        $SPCTL EM,EM               EMPTY PAGE CONTROL\n        $SPCTL EN,EN               END DO GROUP\n        $SPCTL EP,PV               EVEN PAGE EJECT -- (.PV)\n        $SPCTL ER,ER               ERROR MESSAGE\n        $SPCTL ET,ET               EVEN TOP TITLE -- (.HV)\n        $SPCTL EZ,EZ               EASY SCRIPT\n        $SPCTL FB,FB               FLOATING BLOCK\n        $SPCTL FD,FD               ODD PAGE FOOTING\n        $SPCTL FE,FE               FOOTING\n        $SPCTL FI,FO               FORMAT -- (.FO)\n        $SPCTL FK,FK               FLOATING KEEP\n        $SPCTL FM,FM,FREQ=3        FOOTING MARGIN\n        $SPCTL FN,FN,FREQ=3        FOOTNOTE CONTROL\n        $SPCTL FO,FO,FREQ=7        FORMAT\n        $SPCTL FS,FS               FOOTING SPACING\n        $SPCTL FT,FE               FOOTING TITLE -- (.FE)\n        $SPCTL FV,FV               EVEN PAGE FOOTING\n        $SPCTL GO,GO,FREQ=3        GOTO\n        $SPCTL HD,HD               ODD PAGE HEADING\n        $SPCTL HE,HE               HEADING\n        $SPCTL HI,HI               HANGING INDENT\n        $SPCTL HL,HL               HEAD LEVEL\n        $SPCTL HM,HM,FREQ=5        HEADING MARGIN\n        $SPCTL HN,HN               HEADNOTE\n        $SPCTL HS,HS               HEADING SPACING\n        $SPCTL HV,HV               EVEN PAGE HEADING\n        $SPCTL HW,HW               HYPHENATE WORD\n        $SPCTL HY,HY               HYPHENATION\n        $SPCTL H0,HL               HEAD LEVEL ZERO\n        $SPCTL H1,HL               HEAD LEVEL ONE\n        $SPCTL H2,HL               HEAD LEVEL TWO\n        $SPCTL H3,HL               HEAD LEVEL THREE\n        $SPCTL H4,HL               HEAD LEVEL FOUR\n        $SPCTL H5,HL               HEAD LEVEL FIVE\n        $SPCTL H6,HL               HEAD LEVEL SIX\n        $SPCTL H7,HL               HEAD LEVEL SEVEN\n        $SPCTL H8,HL               HEAD LEVEL EIGHT\n        $SPCTL H9,HL               HEAD LEVEL NINE\n        $SPCTL IF,IF,FREQ=3        IF\n        $SPCTL IL,IL               INDENT LINE\n        $SPCTL IM,IM,FREQ=5        IMBED\n        $SPCTL IN,IN,FREQ=7        INDENT\n        $SPCTL IX,IX,FREQ=0        INDEX\n        $SPCTL JU,JU               JUSTIFICATION MODE\n        $SPCTL LA,LA               LEFT ADJUST\n        $SPCTL LB,LB,FREQ=3        LABEL\n        $SPCTL LE,LE               LEADING BLANK LINES\n        $SPCTL LI,LI               LITERAL\n        $SPCTL LL,LL               LINE LENGTH\n        $SPCTL LN,LN               IMMEDIATE LINE\n        $SPCTL LS,LS               LINE SPACING\n        $SPCTL MC,MC               MULTIPLE COLUMN\n        $SPCTL MS,MS               MACRO SUBSTITUTE\n        $SPCTL NC,NC               NO CONCATENATE\n        $SPCTL NF,NF,FREQ=7        NO FORMAT\n        $SPCTL NJ,NJ               NO JUSTIFICATION\n        $SPCTL NL,NL               NULL\n        $SPCTL OB,OB               ODD BOTTOM TITLE -- (.FD)\n        $SPCTL OC,OC,FREQ=3        OVERLAY CHARACTER\n        $SPCTL OF,OF,FREQ=5        OFFSET\n        $SPCTL OJ,OJ               OUT JUSTIFY\n        $SPCTL OO,OO               OVERLAY OUTPUT\n        $SPCTL OP,PD               ODD PAGE EJECT -- (.PD)\n        $SPCTL OT,OT               ODD TOP TITLE -- (.HD)\n        $SPCTL OV,OV               OVERLAY INPUT\n        $SPCTL PA,PA,FREQ=7        PAGE EJECT\n        $SPCTL PD,PD               FORCE ODD PAGE\n        $SPCTL PE,PE               PERFORM\n        $SPCTL PI,PI               PARAGRAPH INDENT\n        $SPCTL PL,PL               PAGE LENGTH\n        $SPCTL PN,PN               PAGE NUMBER\n        $SPCTL PP,PP               PARAGRAPH START\n        $SPCTL PR,PR               PRINT ONLINE\n        $SPCTL PS,PS               PAGE SYMBOL\n        $SPCTL PT,PT               PUT TABLE OF CONTENTS\n        $SPCTL PU,PU               PUT WORK FILE\n        $SPCTL PV,PV               FORCE EVEN PAGE\n        $SPCTL QQ,QQ,FREQ=0        QUIT QUICKLY\n        $SPCTL QT,QT,FREQ=0        QUIT\n        $SPCTL QU,QT,FREQ=0        ALSO QUIT\n        $SPCTL RA,RA               RIGHT ADJUST\n        $SPCTL RC,RC               REVISION CODE\n        $SPCTL RD,RD               TERMINAL READ\n        $SPCTL RE,RE               RESTORE STATUS\n        $SPCTL RI,RA               RIGHT ADJUST -- (.RA)\n        $SPCTL RM,RM               REMOTE\n        $SPCTL RO,RO               ROMAN PAGE NUMBERS\n        $SPCTL RV,RV               READ VARIABLE\n        $SPCTL SA,SA               SAVE STATUS\n        $SPCTL SC,SC               SINGLE COLUMN\n        $SPCTL SE,SE,FREQ=5        SET REFERENCE\n        $SPCTL SI,SI               SIGNAL REMOTE\n        $SPCTL SK,SK               SKIP\n        $SPCTL SP,SP,FREQ=9        SPACE LINES\n        $SPCTL SR,SR,FREQ=5        SET REFERENCE\n        $SPCTL SS,SS               SINGLE SPACE\n        $SPCTL SU,SU               SUBSTITUTE SYMBOL\n        $SPCTL SY,SY,FREQ=0        SYSTEM\n        $SPCTL TB,TB               TAB SET\n        $SPCTL TC,TC               TABLE OF CONTENTS\n        $SPCTL TE,TE               TERMINAL READ\n        $SPCTL TI,TI               TRANSLATE ON INPUT\n        $SPCTL TH,TH,FREQ=3        THEN\n        $SPCTL TM,TM               TOP MARGIN\n        $SPCTL TR,TR               TRANSLATE\n        $SPCTL TT,TT,FREQ=5        TOP TITLE -- (.HE)\n        $SPCTL TY,PR               TYPE ON TERMINAL -- (.PR)\n        $SPCTL UC,UC               UNDERSCORE\n        $SPCTL UD,UD               UNDERSCORE DEFINITION\n        $SPCTL UL,UL               UNDERLINE ALPHANUMERICS\n        $SPCTL UN,UN,FREQ=5        UNDENT\n        $SPCTL UP,UP               UPPERCASE\n        $SPCTL UR,UR,FREQ=5        USE REFERENCE\n        $SPCTL US,US               UNDERSCORE\n        $SPCTL WD,WD               WIDOW\n         SPACE\n        $SPCTLGN DOC=GEN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$SYSREF": {"ttr": 1799, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x1d\\x00\\x1d\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n        $SYSREF &LABEL,&TYPE=CHAR,&LENGTH=*-*,&VALUE=,                 *\n               &BRANCH=,&LAST=*+RNLN\n         LCLC  &ITYPE,&OLAB\n.*       TO GENERATE ENTRIES FOR SYSTEM REFERENCE NAMES IN RND FORMAT\n&ITYPE   SETC  '00'                FOR NUMERIC\n         AIF   ('&TYPE'(1,1) EQ 'N').SKIP00\n&ITYPE   SETC  '80'                FOR CHARACTER\n         AIF   ('&TYPE'(1,1) EQ 'C').SKIP00\n&ITYPE   SETC  '40'                FOR POINTER\n.SKIP00  ANOP\n&OLAB    SETC  '&LABEL'\n         AIF   ('&LABEL'(1,3) NE 'SYS').SKIP01\n&OLAB    SETC  '@'.'&LABEL'(4,7)\n.SKIP01  ANOP\n&OLAB    DC    A(&LAST),CL10'&LABEL.',XL2'00',AL4(0),X'&ITYPE.',AL1(&LE*\n               NGTH)\n         AIF   ('&BRANCH' NE '').SKIP03\n         AIF   ('&VALUE'(1,1) NE '''').SKIP02\n         DC    CL10&VALUE\n         AGO   .SKIP04\n.SKIP02  ANOP\n         DC    2X'00',AL4(&VALUE),4X'00'\n         AGO   .SKIP04\n.SKIP03  ANOP\n         B     &BRANCH\n         DC    6X'00'\n.SKIP04  ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$VERSION": {"ttr": 1801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x009\\x009\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 57, "newlines": 57, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n&SECT   $VERSION &BASE=R15,&NAME=\n         LCLC  &LNAME\n         GBLC  &SCRSECT,&TRPSECT\n&TRPSECT SETC  'TR'                TRAP ROUTINE CSECT\n         AIF   ('&SECT' EQ '').MNOTE01\n&LNAME   SETC  '&NAME'\n         AIF   ('&LNAME' NE '').SKIP01\n&LNAME   SETC  '&SECT'\n.SKIP01  ANOP\n&SECT    CSECT ,\n         USING NSCDAT,R13          DATA AREA BASE\n         USING SAVESCR,BASESAVE    REGISTER STACK AREA BASE\n&SCRSECT SETC  '&SECT'(7,2)\n         AIF   ('&SCRSECT' EQ '&TRPSECT').SKIP20\n         USING &SECT,&BASE         ENTRY ADDRESS\n         B     VERSEND-*(,&BASE)   BRANCH AROUND IDENT\n         DC    AL1(L'VERSN)        LENGTH OF IDENT\nVERSN    DC    C'UOW &LNAME - VERSION(3.2) &SYSDATE.'\nVERSEND  DS    0H\n        $HEAD  '&LNAME'\n         AIF   ('&SECT' NE '&LNAME').SKIP10\n         AIF   ('&SCRSECT' EQ '').MNOTE02\n         STM   14,12,12(13)        SAVE CALLER'S REGISTERS\n         LA    1,VL&SCRSECT.SCRI   ADCON LENGTH\n         LA    2,V&SCRSECT.SCRIP-SCRICVT     TARGET OFFSET\n         A     2,VSCRICVT          PLUS CVT BASE\n         LA    3,A&SCRSECT.SCRIP   FROM ADDRESS\nVERSEND1 DS    0H\n         S     1,F256              DECREMENT LENGTH\n         BM    VERSEND2            BRANCH IF LAST\n         MVC   0(256,2),0(3)       MOVE A CHUNK\n         BZ    VERSEND3            BRANCH IF DONE\n         LA    2,256(,2)           INCREMENT TARGET\n         LA    3,256(,3)           INCREMENT FROM\n         B     VERSEND1            TRY AGAIN\nVERSEND2 DS    0H\n         A     1,F255              RESTORE LENGTH -1\n         EX    1,VERSENDM          MOVE THE REMAINDER\nVERSEND3 DS    0H\n         LM    14,12,12(13)        RESTORE CALLER'S REGS\n         BR    14                  RETURN TO CALLER\nVERSENDM MVC   0(*-*,2),0(3)       MOVE REMAINDER OF DATA\nA&SCRSECT.SCRIP DC (VL&SCRSECT.SCRI/4)A(*-*) ROUTINE ADDRESS CONSTANTS\n         ORG   A&SCRSECT.SCRIP+V&SCRSECT.SCRIP-V&SCRSECT.SCRIP\n         DC    A(&SECT)            MAIN ROUTINE ENTRY ADDR\n         ORG   ,                   END OF AREA\n.SKIP10  ANOP  ,\n         DROP  &BASE\n         MEXIT\n.SKIP20  ANOP\n        $HEAD  '&LNAME'\n         MEXIT\n.MNOTE01 MNOTE 8,'$VERSION -- MISSING SECTION LABEL.'\n         MEXIT\n.MNOTE02 MNOTE 8,'$VERSION -- SECTION LABEL ''&SECT'' TOO SHORT.'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$WITCHS": {"ttr": 1803, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00_\\x00_\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 95, "newlines": 95, "modlines": 0, "user": "CBT249"}, "text": "         SPACE\nFF       EQU   X'FF'\n*        EQU   X'80',,C'0'             UNUSED                         *\nNFSWS    EQU   X'40',,C'0'         NO FILL\nSTSWS    EQU   X'20',,C'0'         STOP MODE\n*        EQU   X'10',,C'0'             UNUSED  WAS OFSWS\nNOSWS    EQU   X'08',,C'0'         NOWAIT MODE\nBCSWS    EQU   X'04',,C'0'         BALANCE COLUMNS IF ON\nTHSWS    EQU   X'02',,C'0'         HYPHENATE IN TABULATION MODE\n*        EQU   X'01',,C'0'             UNUSED                         *\n         SPACE\nJUADSWS  EQU   X'80',,C'1'         JUSTIFY CURRENT LINE WITH ADJUST\n*        EQU   X'40',,C'1'             UNUSED                         *\nCESWS    EQU   X'20',,C'1'         ON IF .CE, OFF IF .LA OR .RA\nRASWS    EQU   X'10',,C'1'         ON IF .RA, OFF IF .LA\nNCSWS    EQU   X'08',,C'1'         IGNORE CONTROL WORDS\nPINCRNO  EQU   X'04',,C'1'         DON'T INCREMENT PAGE NUMBER\n*        EQU   X'02',,C'1'             UNUSED                         *\nPAGOFF   EQU   X'01',,C'1'         PAGE NUMBERING IS OFF\n         SPACE\nLISWS    EQU   X'80',,C'2'         LITERAL 'ON' SWITCH\n*        EQU   X'40',,C'2'             UNUSED                         *\nMASWS    EQU   X'20',,C'2'         MARK NEW LINES OPTION SPECIFIED\n*        EQU   X'10',,C'2'             UNUSED                         *\nHDPSWS   EQU   X'08',,C'2'         WITHIN HEADING/FOOTING PRINT\n*        EQU   X'04',,C'2'             UNUSED                         *\n*        EQU   X'02',,C'2'             UNUSED                         *\n*        EQU   X'01',,C'2'             UNUSED                         *\n         SPACE\n*        EQU   X'80',,C'3'             UNUSED                         *\n*        EQU   X'40',,C'3'             UNUSED                         *\n*        EQU   X'20',,C'3'             UNUSED                         *\n*        EQU   X'10',,C'3'             UNUSED                         *\n*        EQU   X'08',,C'3'             UNUSED                         *\nFNOEMPTY EQU   X'04',,C'3'         DON'T PRINT ENTIRELY BLANK PAGES\nFNOEMBMP EQU   X'02',,C'3'         DON'T BUMP PAGE NUM FOR BLANK PAGES\n*        EQU   X'01',,C'3'             UNUSED                         *\n         SPACE\nFOVLY    EQU   X'80',,C'4'         NEXT PRINTER LINE IS OVERLAID\nFRMSV    EQU   X'40',,C'4'         CURRENT REMOTE IS SAVED\nOOSWS    EQU   X'20',,C'4'         OUTPUT OVERLAY DISABLED\nUCSWS    EQU   X'10',,C'4'         .UR COMMA SWITCH\nFLDSP    EQU   X'08',,C'4'         ALLOW SPACES TO START PAGE\n*        EQU   X'04',,C'4'             UNUSED                         *\nFUPCASE  EQU   X'02',,C'4'         UPPER CASE PAGE NUMBERING\nFROMAN   EQU   X'01',,C'4'         ROMAN NUMERAL PAGE NUMBERING\n         SPACE\nURSWS    EQU   X'80',,C'5'         SUBSTITUTION DONE UNDER .UR\nFNOCASE  EQU   X'40',,C'5'         DON'T CONVERT CASE IN \"GETARG\"\n*        EQU   X'20',,C'5'             UNUSED                         *\n*        EQU   X'10',,C'5'             UNUSED                         *\nFCHARIF  EQU   X'08',,C'5'         IF: CHARACTER COMPARISON\nWDSWS    EQU   X'04',,C'5'         ON IF WIDOW PROCESSING\nSRSWS    EQU   X'02',,C'5'         NUMERIC EVALUATION UNDER .SR\nUTSWS    EQU   X'01',,C'5'         .UR TRACE SWITCH\n         SPACE\n*        SWITCHS FROM THIS POINT ARE GLOBAL                           *\n*        THAT IS, THEY NEED NOT BE SAVED AND RESTORED                 *\n*        WHEN REMOTES ARE TRIGGERED OR BY .SA/.RE.                    *\n         SPACE\n*        EQU   X'80',,C'6'             UNUSED                         *\nFRMKP    EQU   X'40',,C'6'         KEEP ENVIRONMENT THRU REMOTE\nDTTSWS   EQU   X'20',,C'6'         DEFAULT TITLE BEING SET\nPROFSW   EQU   X'10',,C'6'         ON IF PROFILE SPECIFIED\nFNOCT    EQU   X'08',,C'6'         NEXT LINE IS \"DON'T COUNT\"\nMSSWS    EQU   X'04',,C'6'         MACRO SUBSTITUTION SWITCH\n*        EQU   X'02',,C'6'             UNUSED                         *\n*        EQU   X'01',,C'6'             UNUSED                         *\n         SPACE\nTRSWS    EQU   X'80',,C'7'         TRANSLATE MODE\nTROSWS   EQU   X'40',,C'7'         TRANSLATE PARM OPTION SPECIFIED\nNUSWS    EQU   X'20',,C'7'         NUMBER OUTPUT LINES\nDBSWS    EQU   X'10',,C'7'         ON IF DEBUG (NOSPIE) SPECIFIED\nTRSUP    EQU   X'08',,C'7'         SUPPRESS OUTPUT TRANSLATE\nCSSWS    EQU   X'04',,C'7'         COND SECTION, SKIP TILL OFF\nOUSWS    EQU   X'02',,C'7'         OFF IF LINENUM/ON IF LEGALNUM\nHYSUPSW  EQU   X'01',,C'7'         SUPPRESS HYPHENATION FOR ONE LINE\n         SPACE\nNUPSWS   EQU   X'80',,C'8'         NO UPPERCASE REF NAME CONVERSION\nQUSWS    EQU   X'40',,C'8'         QUIET PROMPT SWITCH FOR ONLINE\nCMSWS    EQU   X'20',,C'8'         SCRIPT IS UNDER CMS\nTSOWS    EQU   X'10',,C'8'         SCRIPT IS UNDER TSO\n*        EQU   X'08',,C'8'             UNUSED  WAS CRTSWS\n*        EQU   X'04',,C'8'             UNUSED  WAS MEMOSWS\nGBLSWS   EQU   X'02',,C'8'         IF ALL REF NAMES TO BE GLOBAL\nSTATSWS  EQU   X'01',,C'8'         STATISTICS SWITCH\n         SPACE\nNPSWS    EQU   X'80',,C'9'         NO PRINT MODE IF ON\nFLNESWS  EQU   X'40',,C'9'         ON IF FIRST OUTPUT LINE AFTER BREAK\nFEMPTY   EQU   X'20',,C'9'         PAGE EMPTY SO FAR\nFFIRST   EQU   X'10',,C'9'         THIS IS THE FIRST PRINTED PAGE\nAFIRST   EQU   X'08',,C'9'         THIS IS THE REAL FIRST PAGE\nHITSWS   EQU   X'04',,C'9'         ON IF 'LOAD;HIT' MESSAGE DISPLAYED\nHIDBSWS  EQU   X'02',,C'9'         ON IF HIDDEN BUFFER DATA PRESENT\nTCSWS    EQU   X'01',,C'9'         TABLE OF CONTENTS IN PROGRESS\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#AB": {"ttr": 1806, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00+\\x00+\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 43, "newlines": 43, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .AB (ABEND) --- CONTROL                                *\n*                                                                     *\n***********************************************************************\n         SPACE\nAB      $ENTER ,\n        $IFOFF SWITCHS,DBSWS,AB06  IGNORE IF 'DEBUG' NOT SPECIFIED\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BOMIT+BPOS,AB04     BRANCH IF NULL OR AFFIRMATIVE\n         BC    BNEG,AB06           IGNORE IF NEGATIVE\n         CLI   YNRESULT,YNTRON     A 'TRACEON' CONDITION .Q\n         BNE   AB01                BRANCH IF NOT\n         TM    TRACEPTR,X'80'      IS SUPRTRAC OUT THERE .Q\n         BO    AB06                BRANCH IF NOT\n         L     R15,TRACEPTR        GET TRACE ENTRY ADDRESS\n         LA    R14,AB06            RETURN ADDRESS\n         BR    R15                 GO TO TRACE\nAB01     DS    0H\n         CLI   YNRESULT,YNTROFF    A 'TRACEOFF' CONDITION .Q\n         BNE   AB02                BRANCH IF NOT\n         TM    0,6                 TRACEOFF\n         B     AB06                AND GO TO EXIT\nAB02     DS    0H\n         ST    COUNT,ARGSTART      RESET POINTER FOR RESCAN\n        $CALL  GETNUM              GET NUMERIC ARGUMENT\n         BC    BDNO+BNEG,AB03      ERROR IF INVALID OR NEGATIVE\n         LR    R1,COUNT            TRANSFER THE RESULT\n         B     AB05                GO TO ABEND\nAB03     DS    0H\n         MVI   EFLAG005,ERRSET     SET THE ERROR\n         B     AB06                AND GO TO RETURN\nAB04     DS    0H\n         LA    R1,1                ABEND 1 BY DEFAULT\nAB05     DS    0H\n        $CALL  SYABEND             CALL ABEND ROUTINE\n         B     AB06                IN CASE HE SHOULD RETURN\n         SPACE\n         DC    A(AB06)             TRACE (R14) IN LINE\nTRACEPTR DC    X'80',AL3(0)        FILLED IN BY TRACE\n         ENTRY TRACEPTR            FOR SUPRTRAC'S INFORMATION\nAB06     DS    0H\n        $EXIT  RC=0                CONTINUE PROCESSING\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#AD": {"ttr": 1808, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x001\\x001\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 49, "newlines": 49, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .AD (ADJUST) --- CONTROL                               *\n*                                                                     *\n***********************************************************************\n         SPACE\nAD      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n        $CALL  GETYESNO            GET AND TEST FIRST ARG\n         LA    X1,ADJCNT           NORMAL TARGET ADDRESS\n         BC    BOMIT,AD01          BRANCH IF OMITTED\n         LA    X1,ADJCEVN          EVEN TARGET\n         CLI   YNRESULT,YNEVN      IS ARG 'EVEN' .Q\n         BE    AD00                BRANCH IF YES\n         LA    X1,ADJCODD          ODD TARGET\n         CLI   YNRESULT,YNODD      IS ARG 'ODD' .Q\n         BE    AD00                BRANCH IF YES\n         ST    COUNT,ARGSTART      RESCAN FOR A NUMERIC\n         LA    X1,ADJCNT           RESET NORMAL TARGET\n         SPACE\nAD00     DS    0H\n        $CALL  GETNUM              GET ARGUMENT\n         BC    BDNO,AD03           ERROR IF INVALID\n         BC    BOMIT,AD01          BRANCH IF OMITTED\n         CLI   NUMSIGN,C' '        WAS OPERAND SIGNED .Q\n         BE    AD02                BRANCH IF YES\n         AH    COUNT,0(X1)         MAKE RELATIVE CHANGE\n         B     AD02                GO CHECK AND ENTER\nAD01     DS    0H\n         L     COUNT,DEFADJ+TAB3DEF  GET DEFAULT ADJUST VALUE\nAD02     DS    0H\n         C     COUNT,DEFADJ+TAB3MIN  TOO SMALL .Q\n         BL    AD05                BRANCH IF YES\n         C     COUNT,DEFADJ+TAB3MAX  TOO BIG .Q\n         BH    AD04                BRANCH IF YES\n         STH   COUNT,0(X1)         SET NEW ADJUST VALUE\n         B     AD06                AND GO TO TERMINATE\n         SPACE\nAD03     DS    0H\n         MVI   EFLAG005,ERRSET     SET INVALID OPERAND\n         B     AD06                AND GO TO TERMINATE\nAD04     DS    0H\n         MVI   EFLAG013,ERRSET     OPERAND TOO LARGE\n         B     AD06                AND GO TO TERMINATE\nAD05     DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         SPACE\nAD06     DS    0H\n        $EXIT  RC=0                RETURN TO CONTROLLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#ADJUST": {"ttr": 1810, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\xb3\\x00\\xb3\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 179, "newlines": 179, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*                             ADJUST                                  *\n*                                                                     *\n*              ADJUST THE LINE TO THE RIGHT MARGIN.                   *\n*                                                                     *\n*        REGISTER USAGE:                                              *\n*                                                                     *\n*        M     MULTIPLIER                                             *\n*        P     CHARACTER BLOCK POINTER                                *\n*        W     1/2 SPACE = NUMBER OF INTER-WORD SPACES                *\n*        R     FRACTIONAL LEFTOVER                                    *\n*        C     STANDARD NUMBER OF ADDITIONAL SPACES NEEDED            *\n*        Q     (ACCUMULATED FRACT)-(1/2 SPACE)                        *\n*        A     ADJUSTMENT AMOUNT REMAINING                            *\n*                                                                     *\n*        METHOD:                                                      *\n*                                                                     *\n*              STANDARD ADJUSTMENT = (FOLL-FONOCHAR)/FOIWSPC          *\n*              FRACTION = REM(FOLL-FONOCHAR,FPIWSPC)                  *\n*                                                                     *\n*        WHEN FRACTIONS ACCUMULATE TO MORE THAN 1/2 SPACE, AN EXTRA   *\n*        BLANK IS ADDED, AND A WHOLE SPACE SUBTRACTED FROM THE        *\n*        ACCUMULATED FRACTION.                                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nADJUST  $ENTER ,\n         USING FOPMLIST,R1\n         USING LINKELEM,P\n         CLC   FOPCOUNT,F0         IS LINE NULL .Q\n         BE    ADJRET              YES, DO NOTHING\n         L     A,FOLL              CURRENT LINE LENGTH\n         AH    A,FOINDR            PLUS RIGHT INDENT VALUE\n         S     A,FONOCHAR          CALCULATE ADJUSTMENT VALUE\n         BNP   ADJRET              IF ADJUSTMENT = 0, DO NOTHING\n         SR    R15,R15             ZERO WORK REGISTER\n         IC    R15,FOJUVAL         GET JUSTIFY OPTION VALUE\n         B     *+4(R15)            INDEXED BRANCH\n         SPACE\n         B     ADJRET              NO JUSTIFY\n         B     ADJHALF             HALF JUSTIFY RIGHT AND LEFT\n         B     ADJPOS              JUSTIFY RIGHT AND LEFT\n         B     ADJLEFT             LEFT JUSTIFY\n         B     ADJRGHT             RIGHT JUSTIFY\n         B     ADJCNTR             CENTRE JUSTIFY\n         B     ADJISDE             INSIDE JUSTIFY\n         B     ADJOSDE             OUTSIDE JUSTIFY\n         SPACE\nADJHALF  DS    0H\n         LA    A,1(,A)             BUMP NUMBER OF BLANKS BY ONE\n         SRL   A,1                 AND DIVIDE BY TWO FOR HALF\n         SPACE\nADJPOS   DS    0H\n         L     W,FOIWSPC           GET INTER-WORD SPACES (FROM MERGE)\n         LTR   W,W                 IS IT NULL .Q\n         BNP   ADJRET              YES, DO NOTHING\n        $IFOFF FOSWTCH,NFSWS,ADJ01 BRANCH IF CONCAT MODE\n         LA    W,1(,W)             BUMP BY DUMMY ONE\nADJ01    DS    0H\n         L     R,VDEVICEA          TERMINAL DESCRIPTOR BLOCK\n         LTR   R,R                 DOES IT EXIST .Q\n         BZ    ADJ02               BRANCH IF NOT\n         USING TDEVICEA,R          AREA LOOKS LIKE SO\n         CLI   TDEVHMI,X'00'       HORIZONTAL MOTION DEFINED .Q\n         DROP  R\n         BE    ADJ02               BRANCH IF NOT\n         LA    C,0(W,W)            TWICE INTERWORD SPACE COUNT\n         CR    C,A                 COMPARE WITH DESIRED ADJUSTMENT\n         BL    ADJ02               BRANCH IF WOULD NOT BE WORTHWHILE\n         B     ADJ20               SETUP FOR TERMINAL TYPE\n         SPACE\nADJ02    DS    0H\n        $CALL  PUNCADJ             ADJUST ANY PUNCTUATION FIRST\n         BC    BOMIT,ADJRET        BRANCH IF NOTHING LEFT\n         LR    R,A                 TOTAL ADJUSTMENT TO MAKE\n         SRDA  R,32                CALCULATE STANDARD ADJUSTMENT\n         DR    R,W                 AND FRACTIONAL LEFTOVER\n         LR    C,Q                 GET STANDARD ADJUSTMENT\n         SLA   R,1                 MULTIPLY FRACTION * 2\n         LCR   Q,W                 -1/2 SPACE\n         L     P,FOPLAST           GET POINTER TO LAST LINK BLOCK\n         SR    M,M                 ZERO MULTIPLIER REGISTER HANDLER\n         B     ADJ04               SKIP FORWARD\n         SPACE\nADJ03    DS    0H\n         L     P,LINKBACK          FIND NEXT NON-BLANK\nADJ04    DS    0H\n         LTR   P,P                 AT THE BEGINNING .Q\n         BZ    ADJRET              BRANCH IF YES\n         CLI   LINKCHAR,C' '       ..\n         BE    ADJ03               ..\n         SPACE\nADJ05    DS    0H\n         L     P,LINKBACK          FIND NEXT BLANK\n         LTR   P,P                 AT THE BEGINNING .Q\n         BZ    ADJRET              BRANCH IF YES\n         CLI   LINKCHAR,C' '       ..\n         BNE   ADJ05               ..\n         IC    M,LINKMULT          GET MULTIPLIER\n         AR    M,C                 ADD STANDARD ADJUSTMENT AMOUNT\n         SR    A,C                 ..\n         AR    Q,R                 DO WE NEED EXTRA BLANK\n         BL    ADJ06               NO\n         SR    Q,W                 SUBTRACT WHOLE BLANK\n         SR    Q,W                 ..\n         LA    M,1(,M)             ADD EXTRA BLANK TO MULTIPLIER\n         BCTR  A,0                 ..\nADJ06    DS    0H\n         STC   M,LINKMULT          STORE THE MULTIPLIER\n         LTR   A,A                 HAVE ALL ADJUSTMENTS BEEN MADE .Q\n         BP    ADJ03               NO, KEEP FILLING BLANKS\n         B     ADJRET              AND GO TO RETURN\n         SPACE\nADJ20    DS    0H\n         MH    A,TDEVWID           TOTAL ADJUSTMENT (IN RESOLUTION)\n         LR    R,A                 TOTAL ADJUSTMENT TO MAKE\n         SRDA  R,32                CALCULATE STANDARD ADJUSTMENT\n         DR    R,W                 AND FRACTIONAL LEFTOVER\n         LR    C,Q                 GET STANDARD ADJUSTMENT\n         SLA   R,1                 MULTIPLY FRACTION * 2\n         LCR   Q,W                 -1/2 SPACE\n         L     P,FOPLAST           GET POINTER TO LAST LINK BLOCK\n         B     ADJ22               SKIP FORWARD\n         SPACE\nADJ21    DS    0H\n         L     P,LINKBACK          FIND NEXT NON-BLANK\nADJ22    DS    0H\n         LTR   P,P                 AT THE BEGINNING .Q\n         BZ    ADJ25               BRANCH IF YES\n         CLI   LINKCHAR,C' '       IS IT A BLANK .Q\n         BE    ADJ21               BRANCH BACK IF YES\nADJ23    DS    0H\n         L     P,LINKBACK          FIND NEXT BLANK\n         LTR   P,P                 AT THE BEGINNING .Q\n         BZ    ADJ25               BRANCH IF YES\n         CLI   LINKCHAR,C' '       IS THIS A BLANK .Q\n         BNE   ADJ23               BRANCH IF NOT\n         LH    M,LINKWID           GET CHARACTER WIDTH\n         AR    M,C                 ADD STANDARD ADJUSTMENT AMOUNT\n         SR    A,C                 DECREMENT AMOUNT LEFT TO DO\n         AR    Q,R                 DO WE NEED AN EXTRA PART .Q\n         BL    ADJ24               BRANCH IF NOT\n         SR    Q,W                 SUBTRACT A HALF\n         SR    Q,W                 AND AGAIN FOR A WHOLE BLANK\n         LA    M,1(,M)             ADD EXTRA PART TO WIDTH\n         BCTR  A,0                 DECREMENT AMOUNT LEFT\nADJ24    DS    0H\n         STH   M,LINKWID           STORE CHARACTER WIDTH\n         LTR   A,A                 HAVE ALL ADJUSTMENTS BEEN MADE .Q\n         BP    ADJ21               NO, KEEP FILLING BLANKS\nADJ25    DS    0H\n         B     ADJRET              AND GO TO RETURN\n         SPACE\nADJLEFT  DS    0H\n         B     ADJRET              AND GO TO RETURN\n         SPACE\nADJRGHT  DS    0H\n        $CALL  RIGHTADJ            RIGHT ADJUST THIS LINE\n         B     ADJRET              AND GO TO RETURN\n         SPACE\nADJCNTR  DS    0H\n        $CALL  CENTER              CENTRE THIS LINE\n         B     ADJRET              AND GO TO RETURN\n         SPACE\nADJISDE  DS    0H\n        $CALL  ODDEVN              ODD OR EVEN PAGE .Q\n         BC    BNEG,ADJLEFT        BRANCH IF ODD PAGE\n         B     ADJRGHT             ELSE EVEN PAGE\n         SPACE\nADJOSDE  DS    0H\n        $CALL  ODDEVN              ODD OR EVEN PAGE .Q\n         BC    BPOS,ADJLEFT        BRANCH IF EVEN\n         B     ADJRGHT             ELSE ODD\n         SPACE\nADJRET   DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\n         DROP  P,R1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#AP": {"ttr": 2052, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x01t\\x01t\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 372, "newlines": 372, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .APPEND (.AP) --- CONTROL                              *\n*                                                                     *\n***********************************************************************\n         SPACE\nAP      $ENTER ,\n         XC    APIMFLAG,APIMFLAG   CLEAR FILE FLAGS\n        $ON    APIMFLAG,IO$AP      SET APPEND FLAG (CLOSE CURR. FILE)\n        $CALL  API                 CHECK FILENAME\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\nAPI     $ENTER ,\n         MVC   APIMNAME,BLANKS     BLANK OUT NEW FILENAME\n         MVC   APIMMEMB,BLANKS     AND BLANK OUT MEMBER NAME\n         L     X1,ARGSTART         REMEMBER STARTING POINT\n        $CALL  GETNUM              GET A NUMERIC\n         BC    BOMIT,APIE003       ERROR IF OMITTED\n         BC    BDNO,API01          BRANCH IF NOT NUMERIC\n         LTR   COUNT,COUNT         FILE NUMBER TOO SMALL .Q\n         BNP   APIE014             ERROR IF YES\n         LA    R0,PUMAX            MAX PUT WORK FILE NUMBER\n         CR    COUNT,R0            FILE NUMBER TOO BIG .Q\n         BH    APIE013             ERROR IF YES\n         LR    R1,COUNT            ENTER FILE NUMBER\n         SR    R0,R0               NO DATA PTR MEANS CLOSE\n        $CALL  PUWORK              CLOSE FILE IF OPEN\n         CVD   COUNT,SAVED0        FILE NUMBER TO DECIMAL\n         OI    SAVED0+7,X'0F'      FIX THE SIGN\n         MVC   APIMNAME,PUDDNAME   ENTER BASIC DDNAME\n         UNPK  APIMNAME+6(2),SAVED0+6(2)  ENTER FILE NUMBER\n         B     API03               AND CONTINUE\n         SPACE\nAPI01    DS    0H\n         ST    X1,ARGSTART         RESCAN FROM HERE\n        $CALL  GETARG              GET FILE NAME\n         LM    X1,X2,OPENPARN      GET POINTERS TO PARENTHESES\n         LTR   X1,X1               WAS THERE AN OPEN PARENTHESIS\n         BNZ   API02               BRANCH IF YES\n         LA    X1,1(TEMP,COUNT)    PRETEND THERE IS ONE\n         LR    X2,X1               AT THE END OF THE FILE NAME\n         SPACE\nAPI02    DS    0H\n         MVC   APIMNAME,BLANKS     BLANK OUT NEW FILE NAME\n         MVC   APIMMEMB,BLANKS     SAME FOR MEMBER NAME\n         SPACE\n         LA    R1,7                MAXIMUM LENGTH(NAME), SS-TYPE\n         LR    TEMP,X1             POINT TO OPEN PARENTHESIS\n         SR    TEMP,COUNT          GET LENGTH(FILE NAME)\n         BNP   APIE005             BRANCH IF NOTHING\n         SPACE\n         BCTR  TEMP,0              GET SS-TYPE LENGTH\n         CLR   TEMP,R1             IF MORE THAN 7, TRUNCATE NAME\n         BNH   *+6\n         LR    TEMP,R1             TRUNCATE THE NAME\n         SPACE\n         EX    TEMP,APMVC          MOVE FILE NAME TO CONTROL BLOCK\n         SPACE\n         SR    X2,X1               COMPUTE LENGTH(MEMBER NAME)+1\n         S     X2,F2               SS-TYPE LENGTH OF MEMBER NAME\n         BM    API03               IF NOT THERE, IGNORE  THE FACT\n         SPACE\n         CLR   X2,R1               IF NAME HAS MORE THAN 8 CHARACTERS\n         BNH   *+6                 THEN TRUNCATE IT\n         LR    X2,R1               TO 8 CHARACTERS\n         SPACE\n         EX    X2,APMVCB           MOVE MEMBER NAME TO BLOCK\n         SPACE\nAPI03    DS    0H\n        $CALL  APS                 GET ANY ARGS AND RANGE\n         BC    BNEG,API04          BRANCH IF ARGUMENT ERRORS\n         LA    R1,APIMBLOK         TO APPEND OR IMBED NEW FILE\n        $CALL  RDFILE              CALL THE INPUT COORDINATOR\n         SPACE\nAPI04    DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\nAPIE003  DS    0H\n         MVI   EFLAG003,ERRSET     OMITTED FILENAME\n         B     API04               AND GO TO RETURN\nAPIE005  DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     API04               AND GO TO RETURN\nAPIE013  DS    0H\n         MVI   EFLAG013,ERRSET     FILE NUMBER TOO LARGE\n         B     API04               AND GO TO RETURN\nAPIE014  DS    0H\n         MVI   EFLAG014,ERRSET     FILE NUMBER TOO SMALL\n         B     API04               AND GO TO RETURN\n         SPACE\nAPMVC    MVC   APIMNAME(*-*),0(COUNT) EXECUTED INSTRUCTION\nAPMVCB   MVC   APIMMEMB(*-*),1(X1) EXECUTED INSTRUCTION\n         EJECT\n***********************************************************************\n*                                                                     *\n*              SCAN ARGUMENTS AND RANGE                               *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON EXIT  --  CC = BPOS   IF SUCCESSFUL\n*                     CC = BNEG   IF UNSUCCESSFUL\n         SPACE\nAPS     $ENTER ,\n         MVC   APIMMIN,F1          DEFAULT MINIMUM RECORD NUMBER\n         MVC   APIMMAX,F16MEG      DEFAULT MAXIMUM RECORD NUMBER\n         MVC   APIMGOTO,BLANKS     CLEAR GOTO TARGET\n         SPACE\n         L     X2,ARGSTART         REMEMBER ARGUMENT START ADDR\n         LA    X2,1(,X2)           PASS OVER BLANK DELIM\n         SR    R0,R0               ZERO A WORK REGISTER\n         ST    R0,APIMARGC         ZERO ARGUMENT COUNT\n        $IFON  SWITCHS,GBLSWS,APS01     BRANCH IF REF NAMES ALL GLOBAL\n         MVC   ASRWORK,ASRLCL      SET TO LOCAL DICTIONARY\n         B     APS02               AND CONTINUE\nAPS01    DS    0H\n         MVC   ASRWORK,ASRGBL      SET TO GLOBAL DICTIONARY\n         OI    APIMARGC,X'80'      SET HIGH BIT MEANING UNUSED\n         SPACE\nAPS02    DS    0H\n         L     X3,ARGSTART         NEXT ARGUMENT START ADDR\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION FOR ARGS\n        $CALL  GETQST              GET AN ARGUMENT\n         BC    BOMIT,APS09         BRANCH IF NONE LEFT\n         CLC   PERIND(1),0(COUNT)  RECORD NUMBER DELIMITER .Q\n         BNE   APS03               BRANCH IF NOT\n         CLI   1(COUNT),C' '       AND THAT ALONE .Q\n         BNE   APS03               BRANCH IF NOT\n         LA    COUNT,1(,COUNT)     BUMP OVER CONTROL WORD IND\n         ST    COUNT,ARGSTART      SCAN FROM THERE NEXT TIME\n         NI    APIMARGC,X'FF'-X'80'     RESET UNDEFINED FLAG\n         B     APS09               QUIT ARGS\nAPS03    DS    0H\n         L     R1,DEFRNLEN+TAB3DEF MAX LENGTH OF CHAR ARGUMENT\n         A     R1,QSTRING          PLUS ANY QUOTE DELIMITERS\n         CR    TEMP,R1             COMPARE WITH ACTUAL\n         BL    APS04               BRANCH IF OK\n         MVI   EFLAG008,ERRSET     SET THE ERROR\n         B     APS27               AND TAKE ERROR EXIT\n         SPACE\nAPS04    DS    0H\n         OC    QSTRING,QSTRING     ANY QUOTES .Q\n         BNZ   APS08               BRANCH IF YES\n         LR    X1,COUNT            POINT TO FIRST CHAR\nAPS05    DS    0H\n         LA    X1,1(,X1)           POINT TO NEXT CHAR\n         C     X1,ARGSTART         PAST THE END .Q\n         BNL   APS08               BRANCH IF YES\n         CLI   0(X1),C'='          POSSIBLE KEYWORD .Q\n         BNE   APS05               BRANCH IF NOT\n         NI    APIMARGC,X'FF'-X'80'     RESET UNDEFINED FLAG\n         L     R1,ERRSTART         REMEMBER ERROR POINTER\n        $SAVE  ,                   SAVE ALL REGISTERS\n         LR    R1,COUNT            POINT TO SCAN START\n         LA    X1,1(,X1)           POINT PAST EQUAL SIGN\n         MVC   ARGTSTAR(8),ARGSTART     SAVE CURRENT SCAN POINTERS\n         CLI   0(X1),C' '          EQUAL FOLLOWED BY BLANK .Q\n         BNE   APS06               BRANCH IF NOT\n         LR    COUNT,X1            SET SCAN END POINTER\n         B     APS07               AND GO FORWARD\nAPS06    DS    0H\n         ST    X1,ARGSTART         SCAN OPERAND FROM HERE\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION PLEASE\n        $CALL  GETQST              GET OPERAND\n         LA    COUNT,1(COUNT,TEMP) END OF SCANNED ARGUMENT\nAPS07    DS    0H\n         ST    COUNT,ARGSTOP       SAVE END RESULT\n         ST    R1,ARGSTART         SAVE START ADDRESS\n         SPACE\n         L     R1,ASRWORK          RETAIN DICTIONARY POINTER\n         MVC   ASRWORK,ASRGBL      KEYWORDS SHALL REMAIN GLOBAL\n        $CALL  SR                  TRY TO EVALUATE ASSIGNMENT\n         ST    R1,ASRWORK          RESTORE DICTIONARY POINTER\n         SPACE\n        $RESTOR ,                  RESTORE SAVED REGS\n         MVC   ARGSTOP(4),ARGTSTAR+4    RESTORE SCAN END POINTER\n         OC    ERRFLGS,ERRFLGS     ANY ERRORS ENCOUNTERED .Q\n         BZ    APS02               NO, GET NEXT POSITIONAL\n         ST    R1,ERRSTART         RESTORE ERROR POINTER\n         MVC   ARGSTART(8),ARGTSTAR     RESTORE SCAN POINTERS\n         XC    ERRFLGS,ERRFLGS     CLEAR ALL EVIDENCE OF PROBLEM\n         MVI   EFLAG029,ERRWARN    THIS IS A WARNING\n        $CALL  ERROUT              AND PRINT THE MESSAGE\n         SPACE\nAPS08    DS    0H\n         L     R1,APIMARGC         CURRENT ARGUMENT COUNT\n         LA    R1,1(,R1)           CLEAR UNDEF FLAG, BUMP BY ONE\n         ST    R1,APIMARGC         RESET WITH NEW VALUE\n         CVD   R1,SAVED0           CONVERT ARG NUMBER TO DECIMAL\n         MVC   ARGTSTAR(8),ARGSTART  SAVE CURRENT POINTERS\n         L     R1,BUFF3AD          POINT TO TEMPORARY BUFFER\n         LA    R1,4(,R1)           SKIP RDW AREA\n         ST    R1,ARGSTART         START ADDRESS\n         MVC   0(B2LG,R1),BLANKS   CLEAR WORKING BUFFER\n         MVC   0(8,R1),UREDPAT     INSERT EDIT PATTERN\n         ED    0(8,R1),SAVED0+4    UNPACK TO CHARACTER\n         LA    R1,9(,R1)           ARGUMENT FIELD GOES HERE\n         EX    TEMP,APMVCARG       MOVE ARGUMENT\n         LA    R1,1(TEMP,R1)       END OF ARGUMENT\n         ST    R1,ARGSTOP          ENDING ADDRESS\n         L     X1,ERRSTART         REMEMBER ERROR ADDRESS\n        $CALL  SR                  DUMMY UP CALL TO PROCESS RESULT\n         MVC   ARGSTART(8),ARGTSTAR     RESET SCANNING ADDRESSES\n         OC    ERRFLGS,ERRFLGS     ANY ERRORS FOUND\n         BZ    APS02               NO, CONTINUE WITH NEXT ARG\n         ST    X1,ERRSTART         RESET ERROR POINT\n         CLI   EFLAG015,ERRCLR     WAS IT MISMATCHED DELIMITER .Q\n         BE    APS27               NO, QUIT WITH ERROR\n         MVI   EFLAG015,ERRWARN    WARNING MESSAGE HERE\n        $CALL  ERROUT              DISPLAY RESULT\n         B     APS02               AND CONTINUE WITH NEXT ARG\n         SPACE\nAPS09    DS    0H\n         L     R1,APIMARGC         GET COUNT OF ARGUMENTS\n         LTR   R1,R1               ZERO ARGUMENTS PRESENT .Q\n         BM    APS12               YES, DON'T SET '&0'\n         L     R1,APIMARGC         GET COUNT OF ARGUMENTS WITHOUT TEXT\n         CVD   R1,SAVED0           CONVERT NUMBER TO DECIMAL\n         MVC   ARGTSTAR(8),ARGSTART  SAVE CURRENT PTRS\n         L     R1,BUFF3AD          POINT TO WORKING BUFFER\n         LA    R1,4(,R1)           SKIP RDW AREA\n         ST    R1,ARGSTART         START ADDRESS\n         MVC   0(B2LG,R1),BLANKS   CLEAR WORKING BUFFER\n         MVI   0(R1),C'0'          PARAMETER NUMBER ZERO\n         MVC   2(8,R1),UREDPAT     EDIT PATTERN\n         ED    2(8,R1),SAVED0+4    EDIT IN NUMBER OF ARGUMENTS\n         LA    R1,10(,R1)          THIS IS THE END\n         ST    R1,ARGSTOP          SET ENDING ADDRESS\n        $CALL  SR                  DUMMY UP CALL TO PROCESS RESULT\n         SPACE\n        $IFOFF SWITCHS,GBLSWS,APS11     BRANCH IF NOT GLOBAL REF NAMES\n         L     X1,ARGCOUNT         COUNT OF ARGS LAST TIME\nAPS10    DS    0H\n         C     X1,APIMARGC         ALL DONE CLEARING .Q\n         BNH   APS11               BRANCH OUT IF YES\n         L     R1,BUFF3AD          POINT TO WORKING AREA\n         LA    R1,4(,R1)           SKIP RDW AREA\n         ST    R1,ARGSTART         STARTING ADDRESS\n         MVC   0(B2LG,R1),BLANKS   CLEAR WORKING AREA\n         CVD   X1,SAVED0           CONVERT ARG NUMBER TO DECIMAL\n         MVC   0(8,R1),UREDPAT     INSERT EDIT PATTERN\n         ED    0(8,R1),SAVED0+4    UNPACK NUMBER TO CHARACTER\n         LA    R1,9(,R1)           NULL ARGUMENT GOES HERE\n         MVI   0(R1),C''''         INITIAL QUOTE\n         MVI   1(R1),C''''         AND ENDING QUOTE FOR A NULL\n         LA    R1,2(,R1)           END OF STRING\n         ST    R1,ARGSTOP          ENDING ADDRESS\n        $CALL  SR                  DUMMY UP CALL TO PROCESS RESULT\n         S     X1,F1               LESS ONE FOR ARG NUMBER\n         B     APS10               DO AS REQUIRED\n         SPACE\nAPS11    DS    0H\n         L     R1,APIMARGC         CURRENT ARGUMENT COUNT\n         ST    R1,ARGCOUNT         SAVE COUNT FOR NEXT TIME\n         MVC   ARGSTART(8),ARGTSTAR  RESTORE CURRENT POINTERS\n         SPACE\nAPS12    DS    0H\n        $CALL  GETNUM              GET START RECORD NUMBER\n         BC    BOMIT,APS20         BRANCH IF NONE ARE LEFT\n         BC    15-BDNO,APS15       BRANCH IF VALID NUMERIC\n         ST    COUNT,ARGSTART      RESCAN FOR IDENTIFIER\n        $CALL  GETARG              GET ARGUMENT STRING\n         LTR   TEMP,TEMP           LENGTH-1 ZERO .Q\n         BNZ   APS13               BRANCH IF NOT\n         CLI   0(COUNT),C'*'       '*' MEANS FROM THE START .Q\n         BE    APS17               BRANCH IF YES\nAPS13    DS    0H\n         LA    R0,L'LBNAME-1       MAX-1 LENGTH ALLOWED\n         CR    TEMP,R0             TOO LONG .Q\n         BNH   APS14               BRANCH IF NOT\n         MVI   EFLAG005,ERRSET     ELSE INVALID OPERAND\n         B     APS27               AND TAKE ERROR EXIT\nAPS14    DS    0H\n         EX    TEMP,APMVCGO        SET IMPLIED GOTO ARGUMENT\n         MVC   COMAGO,COMAREA      REMEMBER SOURCE OF IMPLIED GOTO\n         B     APS20               AND TAKE SUCCESSFUL RETURN\n         SPACE\nAPS15    DS    0H\n         LTR   COUNT,COUNT         ZERO OR NEGATIVE .Q\n         BP    APS16               BRANCH IF NOT\n         MVI   EFLAG014,ERRSET     SET THE ERROR\n         B     APS27               AND TAKE THE ERROR EXIT\nAPS16    DS    0H\n         ST    COUNT,APIMMIN       AND STORE IN PARM BLOCK\n         SPACE\nAPS17    DS    0H\n        $CALL  GETARG              LOCATE SECOND ARGUMENT\n         BC    BOMIT,APS20         IF NOT SUPPLIED, READ WHOLE FILE\n         SPACE\n         CLI   0(COUNT),C'*'       DID HE SAY '*' MEANING ALL\n         BE    APS20               IF SO, DEFAULT OK\n         ST    COUNT,ARGSTART      ELSE PICK UP NUMBER\n        $CALL  GETNUM\n         BC    15-BDNO-BNEG,APS18  BRANCH IF NOT INVALID OR NEGATIVE\n         MVI   EFLAG005,ERRSET     SET THE ERROR\n         B     APS27               AND TAKE THE ERROR EXIT\nAPS18    DS    0H\n         C     COUNT,APIMMIN       MAKE SURE PARAMETERS MAKE SENSE\n         BNL   APS19               BRANCH IF OK\n         MVI   EFLAG005,ERRSET     SET THE ERROR\n         B     APS27               AND TAKE THE ERROR EXIT\nAPS19    DS    0H\n         ST    COUNT,APIMMAX       STORE IN PARM BLOCK\n         SPACE\nAPS20    DS    0H\n         MVC   ARGTSTAR(8),ARGSTART     SAVE CURRENT ARG POINTERS\n         L     R1,BUFF3AD          POINT TO WORK AREA\n         LA    R1,4(,R1)           SKIP RDW AREA\n         ST    R1,ARGSTART         STARTING ADDR\n         MVC   0(B2LG,R1),BLANKS   CLEAR WORKING AREA\n         MVI   0(R1),C'*'          NAME OF TOTAL PARM VARIABLE\n         MVI   1(R1),C'='          NORMAL ASSIGNMENT CHAR\n         LA    R1,2(,R1)           NEXT STOP\n         LR    COUNT,X3            END+1 OF ARGS\n         SR    COUNT,X2            LENGTH OF TOTAL ARG\n         BNP   APS21               BRANCH IF NOTHING\n         BCTR  COUNT,0             LENGTH-1\n         MVI   0(R1),C'A'          DUMMY CHARACTER\n         S     COUNT,F1            LENGTH-1 OF REMAINDER\n         BM    APS22               BRANCH IF BUT ONE LONG\n         EX    COUNT,APMVCAAA      EXTEND ARGUMENT\n         LA    R1,2(COUNT,R1)      END POINTER\n         B     APS22               GO TO ENTER\nAPS21    DS    0H\n         MVI   0(R1),C''''         LEADING QUOTE\n         MVI   1(R1),C''''         ENDING QUOTE FOR NULL\n         LA    R1,2(,R1)           NEXT STOP\nAPS22    DS    0H\n         ST    R1,ARGSTOP          END OF STRING\n        $CALL  SR                  ENTER DUMMY STRING\n         MVC   ARGSTART(8),ARGTSTAR     RESET SCAN PTRS\n         OC    ERRFLGS,ERRFLGS     ANY ERRORS .Q\n         BZ    APS23               BRANCH IF NONE\n         ST    X2,ERRSTART         SET ERROR POINT\n         B     APS27               AND QUIT WITH ERROR\n         SPACE\nAPS23    DS    0H\n         L     R1,ASRWORK          CURRENT DICTIONARY\n        $CALL  SYMUSL              LOCATE LAST ENTRY\n         BC    BPOS,APS24          BRANCH IF SUCCESSFUL\n         MVI   EFLAG008,ERRSET     SET ERROR (SHOULD NOT HAPPEN)\n         B     APS27               AND TAKE ERROR EXIT\nAPS24    DS    0H\n         USING RND,COUNT           TELL THE ASSEMBLER\n         SR    R1,R1               CLEAR LENGTH REG\n         IC    R1,RNCLEN           LENGTH WE CREATED\n         S     R1,F1               LENGTH-1\n         BM    APS26               IF NULL, WE'RE DONE\n         LA    TEMP,RNCVAL         SHORT STRING TARGET\n         CLI   RNCLEN,L'RNCVAL     IS IT SHORT STRING .Q\n         BNH   APS25               BRANCH IF YES\n         L     TEMP,RNCPTR         POINT TO LONG STRING\nAPS25    DS    0H\n         EX    R1,APMVCBBB         ENTER ACTUAL ARGUMENT STRING\n         DROP  COUNT\n         SPACE\nAPS26    DS    0H\n        $CC    POS                 SET SUCCESSFUL RETURN\n         B     APS28               AND GO TO RETURN\n         SPACE\nAPS27    DS    0H\n         L     R1,ASRLCL           POINT TO LOCAL DICTIONARY\n        $CALL  SYMCLR              DELETE ANY ARGUMENT ENTRIES\n        $CC    NEG                 SET UNSUCCESSFUL RETURN\n         SPACE\nAPS28    DS    0H\n         MVC   ASRWORK,F0          RESET WORK DICTIONARY PTR\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nAPMVCGO  MVC   APIMGOTO(*-*),0(COUNT)   INITIAL GOTO OPERAND\nAPMVCARG MVC   0(*-*,R1),0(COUNT)  EXECUTED MOVE ARGUMENT\nAPMVCAAA MVC   1(*-*,R1),0(R1)     EXTEND DUMMY ARGUMENT\nAPMVCBBB MVC   0(*-*,TEMP),0(X2)   ENTER ACTUAL ARGUMENT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#AR": {"ttr": 2059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x17\\x00\\x17\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .AR (ARABIC NUMBERING) --- CONTROL                     *\n*                                                                     *\n***********************************************************************\n         SPACE\nAR      $ENTER ,\n        $OFF   SWITCHS,FROMAN      CLEAR ROMAN NUMERAL FLAG\n        $OFF   SWITCHS,FUPCASE     ASSUME LOWER CASE ARABIC\n        $CALL  GETYESNO            GET AND TEST ANY ARGUMENT\n         BC    BOMIT,AR02          BRANCH IF ARG OMITTED\n         CLI   YNRESULT,YNLOWER    'LOWER' CASE SPECIFIED .Q\n         BE    AR02                BRANCH IF YES\n         CLI   YNRESULT,YNNOUP     'NOUPPER' SAME AS LOWER .Q\n         BE    AR02                BRANCH IF YES\n         CLI   YNRESULT,YNUP       'UPPER' CASE SPECIFIED .Q\n         BE    AR01                BRANCH IF YES\n         MVI   EFLAG005,ERRSET     ELSE AN INVALID OPERAND\n         B     AR02                AND GO TO RETURN\nAR01     DS    0H\n        $ON    SWITCHS,FUPCASE     SET UPPER CASE ARABIC (WHAT'S THAT)\nAR02     DS    0H\n        $EXIT  RC=0                CONTINUE WITH NEXT LINE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#ARGINIT": {"ttr": 2061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\"\\x00\"\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        INTERNAL FUNCTION 'ARGINIT' --- INITIALIZE OPERAND SCAN      *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON EXIT --- (COUNT=ADDRESS)                                  *\n*                    (TEMP=LENGTH-1)                                  *\n         SPACE\nARGINIT $ENTER ,                   SKIP PAST CONTROL WORD\n         LH    R1,BUFF2LG-1        GET LENGTH OF CONTROL LINE\n         LA    R1,BUFF2-1(R1)      ADDRESS OF LAST CHARACTER\n         LA    R0,1                INCREMENT FOR BXLE\n         LA    COUNT,BUFF2         ADDRESS OF FIRST CHARACTER\n         LR    TEMP,COUNT          WORKING POINTER FOR SCAN\n         SPACE\nINIT01   DS    0H\n         CLI   0(TEMP),C' '        LOCATE BLANK AFTER CONTROL WORD\n         BE    INIT02              IF FOUND, SKIP AHEAD\n         BXLE  TEMP,R0,INIT01      NOT YET, KEEP TRYING\n         SPACE\nINIT02   DS    0H\n        $OFF   SWITCHS,FNOCASE     OPERANDS TO UPPERCASE BY DEFAULT\n         ST    R1,ARGSTOP          STORE SCAN STOP ADDRESS\n         ST    TEMP,ARGSTART       STORE ARGUMENT START ADDRESS\n         SR    R0,R0               ZERO WORK REGISTER\n         ST    R0,OPENPARN         CLEAR OPEN PARENTHESIS POINTER\n         ST    R0,CLOSPARN         CLEAR CLOSE PARENTHESIS POINTER\n         ST    R0,ERRSTART         ZERO ERROR ADDRESS\n         ST    R0,ERRTEXT          CLEAR EXTRA ERROR MESSAGE TEXT PTR\n         SR    TEMP,COUNT          LENGTH OF RESULT\n         BCTR  TEMP,0              LENGTH-1 OF RESULT\n        $RESTOR KEEP=(COUNT,TEMP)  RESTORE CALLER'S REGISTERS\n         BR    RETURN              RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#BC": {"ttr": 2063, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .BC (BALANCE COLUMN) --- CONTROL                       *\n*                                                                     *\n***********************************************************************\n         SPACE\nBC      $ENTER ,\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BPOS+BOMIT,BC01     BRANCH IF AFFIRMATIVE OR OMITTED\n         BC    BNEG,BC02           BRANCH IF NEGATIVE\n         B     BCE005              OTHERWISE INVALID\n         SPACE\nBC01     DS    0H\n        $ON    SWITCHS,BCSWS       BALANCE COLUMNS 'ON'\n         B     BC03                GO TO RETURN\n         SPACE\nBC02     DS    0H\n        $OFF   SWITCHS,BCSWS       BALANCE COLUMNS 'OFF'\n         B     BC03                GO TO RETURN\n         SPACE\nBC03     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nBCE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     BC03                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#BM": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00<\\x00<\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 60, "newlines": 60, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .BM (BOTTOM MARGIN) --- CONTROL                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nBM      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n        $CALL  GETNUM              GET NUMBER\n         BC    15-BDNO,BM01        BRANCH IF OK\n         MVI   EFLAG005,ERRSET     SET ERROR FLAG\n         B     BM09                AND GO TO RETURN\nBM01     DS    0H\n         BC    BOMIT,BM02          SET DEFAULT IF OMITTED\n         CLI   NUMSIGN,C' '        IS ARGUMENT SIGNED .Q\n         BE    BM03                BRANCH IF NOT\n         AH    COUNT,BMMRG         ALTER CURRENT BOTTOM MARGIN\n         B     BM03                GO CHECK AND ENTER\nBM02     DS    0H\n         L     COUNT,DEFBM+TAB3DEF SET DEFAULT BOTTOM MARGIN\nBM03     DS    0H\n         LTR   COUNT,COUNT         CHECK VALUE FOR NEGATIVE\n         BNM   BM04                BRANCH IF NOT NEGATIVE\n         MVI   EFLAG014,ERRSET     SET THE ERROR\n         B     BM09                AND GO TO RETURN\nBM04     DS    0H\n         LH    TEMP,FTMRG          FOOTING MARGIN\n         AH    TEMP,FSCNT          FOOTING SPACING\n         CR    COUNT,TEMP          COMPARE VALUES\n         BNL   BM05                BRANCH IF NOT LOW\n         MVI   EFLAG042,ERRSET     SET THE ERROR\n         B     BM09                AND GO TO RETURN\nBM05     DS    0H\n         LH    TEMP,PLZ            GET CURRENT PAGE LENGTH\n         SH    TEMP,TOPMRG         LESS TOP MARGIN\n         CR    COUNT,TEMP          TOO BIG .Q\n         BL    BM06                BRANCH IF NOT TOO BIG\n         MVI   EFLAG045,ERRSET     SET THE ERROR\n         B     BM09                AND GO TO RETURN\nBM06     DS    0H\n         CH    COUNT,PLCT          STILL ENOUGH LINES LEFT ON PAGE .Q\n         BNH   BM07                BRANCH IF YES\n        $CALL  PAGE                TERMINATE THIS PAGE\n         B     BM06                AND TRY AGAIN\n         SPACE\nBM07     DS    0H\n         OC    FNSEP,FNSEP         ANY FOOTNOTE LINES FOR THIS PAGE .Q\n         BZ    BM08                BRANCH IF NONE\n         SPACE\n         LH    TEMP,FNSEP          FOOTNOTE LINES QUEUED\n         AR    TEMP,COUNT          PLUS NEW BOTTOM MARGIN\n         CH    TEMP,PLCT           STILL ENOUGH LINES ON PAGE .Q\n         BNH   BM08                BRANCH IF YES\n        $CALL  PAGE                TERMINATE THIS PAGE\n         B     BM06                AND TRY AGAIN\nBM08     DS    0H\n         STH   COUNT,BMMRG         SET NEW BOTTOM MARGIN\n         SPACE\nBM09     DS    0H\n        $EXIT  RC=0                BACK TO MAIN LINE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#BR": {"ttr": 2307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x10\\x00\\x10\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .BR (BREAK) --- CONTROL                                *\n*                                                                     *\n***********************************************************************\n         SPACE\nBR      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n         SPACE\n        $CALL  USARG               ISOLATE ARGUMENT LINE\n         LA    R15,WRETNR          ASSUME LINE OPERAND PRESENT\n         BC    BPOS,BR01           BRANCH IF LINE OPERAND PRESENT\n         SR    R15,R15             SET RETURN CODE TO IGNORE\n         SPACE\nBR01     DS    0H\n        $EXIT  RC=(R15)            RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#BS": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00*\\x00*\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .BS (BACKSPACE) --- CONTROL                            *\n*                                                                     *\n***********************************************************************\n         SPACE\nBS      $ENTER ,\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION PLEASE\n        $CALL  GETARG              GET AN ARGUMENT\n         BC    BOMIT,BS05          RESET DEFAULT IF OMITTED\n        $CALL  TRHEX               SCAN RESULT FOR CHARACTER\n         BC    BDNO,BS01           BRANCH IF INVALID\n         STC   R1,BSIND            SET USER BACKSPACE CHAR\n         B     BS02                AND CONTINUE\n         SPACE\nBS01     DS    0H\n         ST    COUNT,ARGSTART      RESCAN FOR OPERAND\nBS02     DS    0H\n        $CALL  GETYESNO            SCAN SECOND OPERAND\n         BC    BOMIT,BS06          BRANCH IF DONE\n         CLI   YNRESULT,YNHJ       IS IT 'HJOIN' .Q\n         BE    BS03                BRANCH IF YES\n         CLI   YNRESULT,YNNOHJ     IS IT 'NOHJOIN' .Q\n         BE    BS04                BRANCH IF YES\n         B     BSE005              ELSE INVALID OPERAND\nBS03     DS    0H\n         MVI   BSHJ,YNHJ           HEX JOIN OPTION IN EFFECT\n         B     BS06                GO TO RETURN\nBS04     DS    0H\n         MVI   BSHJ,YNNOHJ         NO HEX JOIN OPTION IN EFFECT\n         B     BS06                GO TO RETURN\n         SPACE\nBS05     DS    0H\n         MVC   BSIND(1),BSIND+1    RESET TO INITIAL VALUE\n         MVC   BSHJ(1),BSHJ+1      RESET HEX JOIN ATTRIBUTE\n         SPACE\nBS06     DS    0H\n        $EXIT  RC=0                AND CONTINUE\n         SPACE\nBSE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     BS06                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#BX": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\xc9\\x00\\xc9\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 201, "newlines": 201, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .BX (BOX) --- CONTROL                                  *\n*                                                                     *\n***********************************************************************\n         SPACE\nBX      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n        $CALL  PRSKSPC             FLUSH ANY COND SKIP/SPACE\n        $CALL  GETYESNO            GET AND TEST FIRST ARGUMENT\n         BC    BOMIT,BX01          IF NO ARGS, REPEAT LAST SET\n         BC    BNEG,BX03           BRANCH IF 'OFF'\n         CLI   YNRESULT,YNDEL      WAS ARG 'DELETE' .Q\n         BE    BX06                BRANCH IF YES\n         B     BX07                TRY AGAIN FOR NUMERICS\n         SPACE\nBX01     DS    0H\n         L     X1,BXPTR            GET BOX DATA POINTER\n         LTR   X1,X1               ANY PRESENT .Q\n         BZ    BX25                NO, GO TO RETURN\n         USING BXAREA,X1           AREA LOOKS LIKE THIS\n         LH    COUNT,BXBLKLN       LENGTH OF HORIZONTAL LINE\n         LR    X2,COUNT            RETAIN LENGTH FOR LATER\n         BCTR  X2,0                BUT AS AN OFFSET\nBX02     DS    0H\n         S     COUNT,F1            DECREMENT LENGTH BY ONE\n         BM    BX20                BRANCH TO PUT IF ALL DONE\n         LA    R1,BXDATA(COUNT)    POINT TO CHAR\n         TM    0(R1),BXDOWN        DOWN CHAR ON .Q\n         BZ    BX02                BRANCH IF NOT\n         OI    0(R1),BXUP          TURN ON UP CHAR ALSO\n         B     BX02                AND CONTINUE\n         DROP  X1\n         SPACE\nBX03     DS    0H\n         L     X1,BXPTR            GET BOX DATA POINTER\n         LTR   X1,X1               ANY PRESENT .Q\n         BZ    BX25                NO, GO TO RETURN\n         USING BXAREA,X1           AREA LOOKS LIKE THIS\n         LH    COUNT,BXBLKLN       LENGTH OF HORIZONTAL LINE\nBX04     DS    0H\n         S     COUNT,F1            DECREMENT LENGTH BY ONE\n         BM    BX05                BRANCH TO PUT IF ALL DONE\n         LA    R1,BXDATA(COUNT)    POINT TO CHAR\n         TM    0(R1),BXDOWN        DOWN CHAR ON .Q\n         BZ    BX04                BRANCH IF NOT\n         OI    0(R1),BXUP          TURN ON UP CHAR\n         NI    0(R1),FF-BXDOWN     TURN OFF DOWN CHAR\n         B     BX04                AND CONTINUE\nBX05     DS    0H\n        $CALL  BXHORIZ             STACK HORIZONTAL RESULT\nBX06     DS    0H\n        $CALL  BXCLR               REMOVE CURRENT BOX DEFINITION\n         B     BX25                GO TO RETURN\n         SPACE\nBX07     DS    0H\n         SR    X2,X2               FORMER COLUMN OFFSET\n         BCTR  X2,0                MINUS ONE FOR NEVER USED\n         ST    COUNT,ARGSTART      RESCAN FOR NUMERIC\nBX08     DS    0H\n        $CALL  GETNUM              GET NUMERIC ARGUMENT\n         BC    BOMIT,BX17          BRANCH IF DONE\n         BC    BDNO,BXE005         ERROR IF INVALID\n         CLI   NUMSIGN,C' '        ARG UNSIGNED .Q\n         BE    BX09                BRANCH IF YES\n         LA    COUNT,1(COUNT,X2)   MAKE RELATIVE CHANGE\nBX09     DS    0H\n         LA    X3,1(,X2)           LAST OPERAND VALUE\n         CR    COUNT,X3            BIGGER THAN LAST .Q\n         BNP   BXE014              ERROR IF TOO SMALL\n         L     X1,BXPTR            DATA AREA POINTER\n         LTR   X1,X1               AREA PRESENT .Q\n         BNZ   BX10                BRANCH IF YES\n         LA    R1,BXLEN            LENGTH REQUIRED\n        $CALL  GETCELL             GET THE AREA\n         BC    BNEG,BXE024         ERROR IF NO SPACE\n         LR    X1,TEMP             TRANSFER POINTER\n         ST    X1,BXPTR            AND SAVE FOR LATER\n         USING BXAREA,X1           AREA LOOKS LIKE THIS\n         XC    BXAREA(BXLEN),BXAREA     CLEAR ENTIRE AREA\nBX10     DS    0H\n         LR    X3,COUNT            TRANSFER COLUMN\n         BCTR  X3,0                CHANGE TO OFFSET\n         LR    TEMP,X2             RETAIN STARTING OFFSET\nBX11     DS    0H\n         LA    X2,1(,X2)           NEXT OFFSET\n         CR    X2,X3               DONE .Q\n         BNL   BX14                BRANCH IF YES\n         LA    R1,BXDATA(X2)       POINT TO NEXT CHAR\n         TM    0(R1),BXDOWN        DOWNWARD POINTER ON .Q\n         BNO   BX12                BRANCH IF NOT\n         OI    0(R1),BXRIGHT       POINT TO RIGHT\n         NI    0(R1),FF-BXDOWN     NO FURTHER DOWNWARD MOVEMENT\nBX12     DS    0H\n         LTR   TEMP,TEMP           FIRST TIME THROUGH .Q\n         BM    BX13                BRANCH IF YES\n         OI    0(R1),BXLEFT+BXRIGHT     ENTER A DASH\n         B     BX11                AND CONTINUE\nBX13     DS    0H\n         TM    0(R1),BXUP          CHARACTER POINTS UP .Q\n         BZ    BX11                NO LINE FILL IF NOT\n         SR    TEMP,TEMP           RESUME DRAGGING DASHES\n         B     BX11                AND CONTINUE\nBX14     DS    0H\n         LA    R1,BXDATA(X3)       POINT TO THIS COLUMN\n         OI    0(R1),BXDOWN+BXRIGHT     ADD DOWN AND RIGHT\n         LTR   X3,X3               FIRST COLUMN .Q\n         BZ    BX16                BRANCH IF YES\n         BCTR  R1,0                BACKUP ONE\n         CLI   0(R1),BXBLANK       IS FORMER CHAR NULL .Q\n         BNE   BX15                BRANCH IF NOT\n         NI    1(R1),FF-BXLEFT     KILL LEFT CHAR\n         B     BX16                AND CONTINUE\nBX15     DS    0H\n         OI    1(R1),BXLEFT        POINT TO THE LEFT\nBX16     DS    0H\n         LR    X2,X3               REMEMBER LAST OFFSET\n         LA    X3,1(,X3)           FROM OFFSET TO COLUMN\n         CH    X3,BXBLKLN          HAS LINE GROWN .Q\n         BNH   BX08                BRANCH IF NOT\n         STH   X3,BXBLKLN          SET LONGER LENGTH\n         B     BX08                GET NEXT ARGUMENT\n         SPACE\nBX17     DS    0H\n         LA    R1,BXDATA(X2)       LAST CHAR ENTERED\n         CLI   1(R1),BXBLANK       NEXT CHAR NULL .Q\n         BNE   BX18                BRANCH IF NOT\n         NI    0(R1),FF-BXRIGHT    CLEAR RIGHT POINTER\nBX18     DS    0H\n         LA    TEMP,1(,X2)         NEXT OFFSET VALUE\nBX19     DS    0H\n         CH    TEMP,BXBLKLN        OFF THE END OF LINE .Q\n         BNL   BX20                BRANCH IF YES\n         LA    R1,BXDATA(TEMP)     POINT TO NEXT CHAR\n         NI    0(R1),FF-BXDOWN     CLEAR ANY DOWNWARD POINTER\n         OI    0(R1),BXLEFT        ENTER LEFT POINTER\n         BCTR  R1,0                BACKUP ONE\n         OI    0(R1),BXRIGHT       AND POINT TOWARDS SAME\n         LA    TEMP,1(,TEMP)       NEXT CHARACTER OFFSET\n         B     BX19                LOOK TO END OF LINE\n         DROP  X1\n         SPACE\nBX20     DS    0H\n        $CALL  BXHORIZ             STACK HORIZONTAL RESULT\n         L     X1,BXPTR            RESTORE DATA POINTER\n         LTR   X1,X1               ANY AREA PRESENT .Q\n         BZ    BX25                BRANCH IF NOT\n         USING BXAREA,X1           AND TELL THE ASSEMBLER\n         LH    COUNT,BXBLKLN       LENGTH OF HORIZONTAL LINE\nBX21     DS    0H\n         S     COUNT,F1            DECREMENT LENGTH BY ONE\n         BM    BX23                BRANCH IF ALL DONE\n         LA    R1,BXDATA(COUNT)    POINT TO CHAR\n         NI    0(R1),FF-BXUP       CLEAR UP POINTER\n         TM    0(R1),BXDOWN        DOES CHAR GO DOWN .Q\n         BZ    BX22                BRANCH IF NOT\n         OI    0(R1),BXUP          THEN NEXT LINE IT GOES UP\nBX22     DS    0H\n         CR    COUNT,X2            PASSED LAST DOWN .Q\n         BNH   BX21                BRANCH IF NOT\n         MVI   0(R1),BXBLANK       CLEAR CHAR\n         STH   COUNT,BXBLKLN       SET STRING LENGTH\n         LTR   COUNT,COUNT         FIRST COLUMN .Q\n         BNP   BX21                BRANCH IF YES\n         BCTR  R1,0                BACKUP ONE COLUMN\n         NI    0(R1),FF-BXRIGHT    DO NOT POINT TO THIS\n         B     BX21                CONTINUE\nBX23     DS    0H\n         SR    COUNT,COUNT         START AGAIN FROM THE BEGINNING\nBX24     DS    0H\n         LA    R1,BXDATA(COUNT)    POINT TO CHAR\n         TM    0(R1),BXDOWN        IS IT A DOWN .Q\n         BO    BX25                YES, BRANCH OUT\n         MVI   0(R1),BXBLANK       ELSE CLEAR CHAR\n         NI    1(R1),FF-BXLEFT     AND NEXT CHAR THAT POINTS TO IT\n         LA    COUNT,1(,COUNT)     NEXT CHAR\n         CH    COUNT,BXBLKLN       ALL FINISHED STRING .Q\n         BL    BX24                BRANCH BACK IF NOT\n         SPACE\nBX25     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nBXE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     BX25                AND GO TO RETURN\nBXE014   DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     BX25                AND GO TO RETURN\nBXE024   DS    0H\n         MVI   EFLAG024,ERRSET     NO SPACE FOR WORK AREA\n         B     BX25                AND GO TO RETURN\n         SPACE\nBXCLR   $ENTER ,\n         L     R0,BXPTR            CURRENT BOX DEFINITION POINTER\n         LTR   R0,R0               ANY PRESENT .Q\n         BZ    BXCLR01             BRANCH IF NOT\n         XC    BXPTR,BXPTR         CLEAR POINTER\n         LA    R1,BXLEN            HOW MUCH TO FREE\n        $CALL  FREECELL            FREE THE WORK AREA\nBXCLR01  DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#BXHORIZ": {"ttr": 2315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x80\\x00\\x80\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 128, "newlines": 128, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              'BXHORIZ' INTERNAL ROUTINE --- PROCESS TOPS AND BOTTOMS*\n*                                                                     *\n***********************************************************************\n         SPACE\nBXHORIZ $ENTER ,\n         CLI   ICORFLG,ICORNONE    NOT FORMATTING INTO CORE .Q\n         BNE   BXH05               BRANCH IF TRUE\nBXH01    DS    0H\n        $IFON  SWITCHS,FEMPTY,BXH02     BRANCH IF PAGE EMPTY\n         LH    TEMP,PLCT           LINES LEFT ON PAGE\n         BCTR  TEMP,0              DECREMENT BY ONE\n         LH    R1,BMMRG            BOTTOM MARGIN\n         AH    R1,FNSEP            PLUS FOOTNOTE MARGIN\n         CR    TEMP,R1             BELOW BOTTOM MARGIN .Q\n         BNL   BXH03               BRANCH IF NOT\n        $CALL  PAGE                YES, FORCE PAGE EJECT\nBXH02    DS    0H\n        $CALL  PAGETOP             GET NEXT PAGE STARTED\n         B     BXH01               AND TRY AGAIN\nBXH03    DS    0H\n         CLC   PLCT,RMTRIG         REMOTE SET FOR HERE .Q\n         BNE   BXH04               BRANCH IF NOT\n         LH    R1,RMTRIG           REMOTE NUMBER TO IMBED\n        $CALL  RMIMBED             AND TRIGGER SAME FIRST\n         B     BXH01               NOW START AGAIN\n         SPACE\nBXH04    DS    0H\n         STH   TEMP,PLCT           SET NEW LINES REMAINING\nBXH05    DS    0H\n         L     X3,WRKBUFFA         WORKING BUFFER ADDRESS\n         MVC   0(L'WRKBUFF,X3),BLANKS   CLEAR BUFFER\n         LA    X3,1(,X3)           AND POINT TO TARGET\n         SPACE\n         L     X1,BXPTR            DEFINING HORIZ BITS\n         USING BXAREA,X1           AREA LOOKS LIKE THIS\n         LH    COUNT,BXBLKLN       GET LENGTH OF DATA\n         LA    X1,BXDATA           POINT TO DATA\n         DROP  X1\n         LA    X2,BXTRM            ASSUME ONLINE OUTPUT\n        $IFON  TTYPE,TONLINE,BXH06 BRANCH IF TRUE\n        $IFON  SWITCHS,TROSWS,BXH06     BRANCH IF UPPER TRANSLATE\n         LA    X2,BXPRT            'TIS OFFLINE OUTPUT\nBXH06    DS    0H\n         S     COUNT,F1            DECREMENT LENGTH LEFT\n         BM    BXH10               BRANCH OUT IF DONE\n         IC    R1,0(,X1)           GET CHAR BITS\n         N     R1,F15              PURIFY RESULT\n         AR    R1,R1               DOUBLE IT\n         LA    R1,0(R1,X2)         POINT TO CHAR EQUIVALENT\n         MVC   0(1,X3),0(R1)       ENTER CHAR\n        $IFOFF SWITCHS,TRSWS,BXH07 BRANCH IF NO TRANSLATE\n         L     TEMP,TRANADO        OUTPUT TRANS TABLE ADDRESS\n         TR    0(1,X3),0(TEMP)     CONVERT SINGLE CHAR\nBXH07    DS    0H\n         CLI   1(R1),C' '          SECOND CHAR BLANK .Q\n         BE    BXH09               BRANCH IF YES\n         MVI   1(X3),X'16'         ENTER BACKSPACE\n         MVC   2(1,X3),1(R1)       ENTER SECOND CHAR\n        $IFOFF SWITCHS,TRSWS,BXH08 BRANCH IF NO TRANSLATE\n         TR    2(1,X3),0(TEMP)     CONVERT SECOND CHAR\nBXH08    DS    0H\n         LA    X3,2(,X3)           BUMP OUTPUT POINTER\nBXH09    DS    0H\n         LA    X1,1(,X1)           BUMP INPUT POINTER\n         LA    X3,1(,X3)           BUMP OUTPUT POINTER\n         B     BXH06               DO IT AGAIN\nBXH10    DS    0H\n         L     R1,WRKBUFFA         STARTED HERE\n         SR    X3,R1               LENGTH OF RESULT\n         L     X1,BXPTR            RETAIN BOX ANCHOR\n         XC    BXPTR,BXPTR         CLEAR FOR PRINT REQUEST\n         MVC   HDPTRSAV,FMTOLD1    SAVE LINK PTRS/LOCAL SWITCHES\n        $OFF   SWITCHS,JUADSWS     SOME DON'T COUNT\n         ST    X3,NOCHARS          SETUP AND CALL LINKPUT\n         L     R0,WRKBUFFA         RECORD POINTER\n         ST    R0,OUTPARM          IN COMMON AREA\n         XC    OLDFIRST(PARMPUT-OLDFIRST),OLDFIRST   NO OLD DATA\n         LA    R1,OUTPARM          COMMON DATA AREA\n        $CALL  LKPUT               BUILD CHARACTER BLOCKS\n         L     COUNT,NOCHARS       CURRENT CHAR COUNT\n         BCTR  COUNT,0             LESS ONE\n         ST    COUNT,NOCHARS       UPDATE\n        $ON    SWITCHS,HDPSWS      PRINT HORIZONTAL BOX LINE\n        $CALL  PRINT               PRINT THE LINKS\n        $OFF   SWITCHS,HDPSWS      CLEAR HEADING SWITCH\n        $MVC   FMTOLD1,HDPTRSAV    RESTORE LINK PTRS/LOCAL SWITCHES\n         ST    X1,BXPTR            RESTORE BOX ANCHOR\n        $CALL  RMNEXT              SET UP FOR NEXT REMOTE\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nBXTRM    DS    0CL32               ONLINE TERMINAL BOX CHARACTERS\n         DC    C'  '                    0 - BLANK\n         DC    C'- '                    1 - RIGHT DASH\n         DC    C'- '                    2 - LEFT DASH\n         DC    C'- '                    3 - DASH\n         DC    C'| '                    4 - DOWN BAR\n         DC    C'+ '                    5 - DOWN AND RIGHT CORNER\n         DC    C'+ '                    6 - DOWN AND LEFT CORNER\n         DC    C'+ '                    7 - DOWN AND ACROSS INTERSECT\n         DC    C'| '                    8 - UP BAR\n         DC    C'+ '                    9 - UP AND RIGHT CORNER\n         DC    C'+ '                   10 - UP AND LEFT CORNER\n         DC    C'+ '                   11 - UP AND ACROSS INTERSECT\n         DC    C'| '                   12 - BAR\n         DC    C'+ '                   13 - DOWN AND RIGHT INTERSECT\n         DC    C'+ '                   14 - DOWN AND LEFT INTERSECT\n         DC    C'+ '                   15 - INTERSECTION\n         SPACE\nBXPRT    DS    0CL32               OFFLINE PRINTER CHARACTERS\n         DC    X'4040'                  0 - BLANK\n         DC    X'BF40'                  1 - RIGHT DASH\n         DC    X'BF40'                  2 - LEFT DASH\n         DC    X'BF40'                  3 - DASH\n         DC    X'4F40'                  4 - DOWN BAR\n         DC    X'AC40'                  5 - DOWN AND RIGHT CORNER\n         DC    X'BC40'                  6 - DOWN AND LEFT CORNER\n         DC    X'BFBC'                  7 - DOWN AND ACROSS INTERSECT\n         DC    X'4F40'                  8 - UP BAR\n         DC    X'AB40'                  9 - UP AND RIGHT CORNER\n         DC    X'BB40'                 10 - UP AND LEFT CORNER\n         DC    X'BFAB'                 11 - UP AND ACROSS INTERSECT\n         DC    X'4F40'                 12 - BAR\n         DC    X'4FAB'                 13 - DOWN AND RIGHT INTERSECTION\n         DC    X'4FBB'                 14 - DOWN AND LEFT INTERSECTION\n         DC    X'4FBF'                 15 - INTERSECTION\n*                                           ALSO X'8F40' BUT FOR ALA\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#BXVERT": {"ttr": 2318, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00F\\x00F\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 70, "newlines": 70, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              'BXVERT' INTERNAL ROUTINE --- PROCESS SIDES OF BOXES   *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY --  (R0) -> RDW OF OUTPUT LINE\n         SPACE\nBXVERT  $ENTER ,\n         L     X1,BXPTR            BOX DATA ANCHOR\n         LTR   X1,X1               ANYTHING THERE .Q\n         BZ    BXV07               BRANCH IF NOT\n         SPACE\n         USING BXAREA,X1           AREA LOOKS LIKE THIS\n         LH    COUNT,BXBLKLN       LENGTH OF OVERLAY\n         LTR   COUNT,COUNT         ANY DATA .Q\n         BNP   BXV07               BRANCH IF NOT\n         LR    X3,R0               OUTPUT BUFFER ADDR\n        $IFON  TTYPE,TONLINE,BXV01 BRANCH IF ONLINE\n         CLI   4(X3),SUPRSPAC      PRINTER OVERLAY LINE .Q\n         BE    BXV07               YES, GO TO RETURN\n         LA    X3,1(,X3)           BUMP ONE FOR CARRIAGE CONTROL\nBXV01    DS    0H\n         LA    X3,4(,X3)           BUMP OVER RDW\n         AH    X3,ADJCNT           PLUS ADJUST VALUE\n         LA    X2,BXDATA           OVERLAY STRING CONTROL\n         DROP  X1\n         SPACE\nBXV02    DS    0H\n         S     COUNT,F1            DECREMENT LENGTH LEFT BY ONE\n         BM    BXV06               BRANCH IF DONE\n         TM    0(X2),BXDOWN        A BAR IN THIS COLUMN .Q\n         BNO   BXV03               BRANCH IF NOT\n         CLI   0(X3),C' '          IS FORMATTED LINE BLANK .Q\n         BNE   BXV03               BRANCH IF NOT\n         MVI   0(X3),C'|'          'OR' BAR FOR VERT LINES\n        $IFOFF SWITCHS,TRSWS,BXV03 BRANCH IF NO TRANSLATE\n        $IFON  SWITCHS,TRSUP,BXV03 BRANCH IF TRANSLATE SUPPRESSED\n         L     R1,TRANADO          ADDR OF OUTPUT TRANS TABLE\n         TR    0(1,X3),0(R1)       CONVERT SINGLE CHAR\nBXV03    DS    0H\n         LA    X3,1(,X3)           NEXT OUTPUT CHAR\n         LA    X2,1(,X2)           NEXT OVERLAY CHAR\n        $IFOFF TTYPE,TONLINE,BXV02 BRANCH IF NOT ONLINE\nBXV04    DS    0H\n         CLI   0(X3),CBACKSP       BACKSPACE IN ONLINE OUTPUT .Q\n         BE    BXV05               BRANCH IF YES\n         CLI   0(X3),CESCAPE       ESCAPE IN ONLINE OUTPUT .Q\n         BNE   BXV02               BRANCH IF NOT\n         L     TEMP,VDEVICEA       TERMINAL DESCRIPTOR BLOCK\n         LTR   TEMP,TEMP           DOES IT EXIST .Q\n         BZ    BXV05               BRANCH IF NOT\n         LA    TEMP,TDEVAESC-TDEVICEA(,TEMP) LENGTH-1 AFTER ESC TABLE\n         SR    R0,R0               CLEAR WORK REG\n         IC    R0,1(,X3)           FUNCTION CHARACTER\n         AR    TEMP,R0             POINT TO LENGTH-1\n         IC    R0,0(,TEMP)         LENGTH-1 AFTER ESCAPE\n         AR    X3,R0               BUMP BY LENGTH-1\nBXV05    DS    0H\n         LA    X3,2(,X3)           SKIP BKSP AND NEXT CHAR\n         B     BXV04               TRY AGAIN\n         SPACE\nBXV06    DS    0H\n         LR    R1,R0               RDW POINTER\n         SR    X3,R0               LENGTH OF OVERLAYED OUTPUT\n         CH    X3,0(,R1)           NEW LENGTH LONGER .Q\n         BNH   BXV07               BRANCH IF NOT\n         STH   X3,0(,R1)           SET NEW RDW LENGTH\nBXV07    DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#CB": {"ttr": 2320, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x11\\x00\\x11\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .CB (COLUMN BEGIN) --- CONTROL                         *\n*                                                                     *\n***********************************************************************\n         SPACE\nCB      $ENTER ,\n         CLI   ICORFLG,ICORNONE    IN 'NO KEEP' .Q\n         BNE   CBE043              ERROR IF NOT\n        $CALL  PRINTNB             PRINT CURRENT LINE\n        $CALL  COLPAGE             DO REQUIRED COLUMN EJECT\nCB01     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nCBE043   DS    0H\n         MVI   EFLAG043,ERRSET     INVALID CONTROL WORD IN KEEP\n         B     CB01                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#CC": {"ttr": 2561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00w\\x00w\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 119, "newlines": 119, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .CC (CONDITIONAL COLUMN BEGIN) --- CONTROL             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nCC      $ENTER ,\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BOMIT,CC14          IF ARG OMITTED, IGNORE\n         BC    BPOS,CC02           BRANCH IF A BEGINNING\n         BC    BNEG,CC03           BRANCH IF AN ENDING\n         ST    COUNT,ARGSTART      RESET START OF SCAN\n        $CALL  GETNUM              GET NUMERIC ARGUMENT\n         BC    BDNO,CCE005         ERROR IF INVALID\n         CLI   ICORFLG,ICORNONE    ARE WE SAVING INTO CORE NOW .Q\n         BNE   CC14                IF YES, IGNORE THIS REQUEST\n         LTR   COUNT,COUNT         ZERO OR MINUS SPACE .Q\n         BNP   CC14                IF SO, NO COLUMN EJECT\n         LH    TEMP,PLCT           GET COUNT OF NUMBER LEFT\n         SR    TEMP,COUNT          LESS NUMBER REQUIRED\n         BM    CC01                MINUS FORCE AN EJECT\n         LH    R1,BMMRG            BOTTOM MARGIN\n         AH    R1,FNSEP            PLUS FOOTNOTE MARGIN\n         CR    TEMP,R1             BELOW BOTTOM MARGIN .Q\n         BNL   CC14                BRANCH IF NOT\nCC01     DS    0H\n        $CALL  COLPAGE             YES, CAUSE COLUMN EJECT\n         B     CC14                GO TO DONE\n         SPACE\nCC02     DS    0H\n         CLI   ICORFLG,ICORNONE    CURRENTLY FORMATTING INTO CORE .Q\n         BNE   CCE043              ERROR IF YES\n         LA    R1,ICORSLEN         NEED THIS MUCH SPACE\n        $CALL  GETCELL             GET THE SPACE\n         BC    BNEG,CCE024         BRANCH IF FAILURE\n         USING ICORSAVE,TEMP       SAVE AREA LOOKS LIKE THIS\n         ST    TEMP,CCQSAVE        SAVE AREA POINTER\n         MVC   ICORSKSP,SKSP       SAVE CONDITIONAL SKIP/SPACE\n         XC    SKSP,SKSP           CLEAR CURRENT SKIP/SPACE\n         DROP  TEMP\n         SPACE\n         MVI   ICORFLG,ICORCC      SET CONDITIONAL COLUMN KEEP\n         LA    TEMP,CCAREA         CONDITIONAL COLUMN KEEP CONTROL\n         ST    TEMP,ICORANCH       SAVE THIS FOR LATER\n         B     CC14                GO TO DONE\n         SPACE\nCC03     DS    0H\n         CLI   ICORFLG,ICORCC      ENDING A CONDITIONAL COLUMN .Q\n         BNE   CCE043              ERROR IF NOT\n        $CALL  GETNUM              GET OPTIONAL SECOND ARG FOR 'END'\n         BC    15-BDNO,CC04        OK IF NOT INVALID\n         MVI   EFLAG005,ERRSET     SET ERROR FLAG\n         SR    COUNT,COUNT         AND USE ZERO ADJUSTMENT\n         B     CC05                CONTINUE\nCC04     DS    0H\n         BC    15-BOMIT,CC05       BRANCH IF NOT OMITTED\n         SR    COUNT,COUNT         USER ZERO ADJUSTMENT\nCC05     DS    0H\n         LA    R1,CCAREA           CONDITIONAL COLUMN AREA DESCRIPTOR\n        $CALL  CPENDS              TERMINATE THE BLOCK\n         SPACE\n         L     TEMP,CCQSAVE        RESTORE SAVED AREA POINTER\n         XC    CCQSAVE,CCQSAVE     CLEAR SAVED POINTER\n         USING ICORSAVE,TEMP       AREA LOOKS LIKE THIS\n        $MVC   SKSP,ICORSKSP       RESTORE CONDITIONAL SKIP/SPACE\n         LA    R0,ICORSAVE         POINTER TO AREA\n         LA    R1,ICORSLEN         LENGTH OF SAVE AREA\n        $CALL  FREECELL            RELEASE WORK AREA\n         DROP  TEMP\n         SPACE\n         MVI   ICORFLG,ICORNONE    RESET SAVING COND COLUMN FLAG\n         XC    ICORANCH,ICORANCH   CLEAR COND COLUMN CONTROL\n         SPACE\n        $IFON  SWITCHS,FEMPTY,CC13 BRANCH IF PAGE NOW EMPTY\n         LH    TEMP,PLCT           COUNT OF LINES LEFT\n         S     TEMP,CCQCNT         LESS QUEUED COND KEEP COUNT\n         SH    TEMP,SKSPCCNT       LESS CONDITIONAL SPACE COUNT\n         SR    TEMP,COUNT          ADJUST FURTHER WITH USER'S REQUEST\n         CLC   OLDCOUNT,F0         ALL DATA FORMATTED AND PRINTED .Q\n         BE    CC09                BRANCH IF YES\n         S     TEMP,F1             TAKE THAT LINE INTO ACCOUNT\nCC09     DS    0H\n         LTR   TEMP,TEMP           TEST FOR NONE LEFT\n         BM    CC10                MINUS, FORCE AN EJECT\n         LH    R1,BMMRG            BOTTOM MARGIN\n         AH    R1,FNSEP            PLUS FOOTNOTE MARGIN\n         CR    TEMP,R1             BELOW BOTTOM MARGIN .Q\n         BNL   CC12                IF NOT, DON'T FORCE AN EJECT\n         SPACE\nCC10     DS    0H\n         L     R1,CDCURR           CURRENT OUTPUT COLUMN\n         C     R1,CDCOUNT          IS IT THE LAST .Q\n         BL    CC11                BRANCH IF NOT\n        $CALL  PAGEREAL            TERMINATE THIS PAGE FOR REAL\n         B     CC12                AND CONTINUE\nCC11     DS    0H\n        $ON    SWITCHS,OOSWS       NO OVERLAY PLEASE\n        $CALL  COLPAGE             FIRST FORCE LAST COLUMN\n        $OFF   SWITCHS,OOSWS       REENABLE OVERLAY\nCC12     DS    0H\n        $IFON  SWITCHS,FEMPTY,CC13 BRANCH IF PAGE NOW EMPTY\n         LA    R1,CCAREA           QUEUED LINE DESCRIPTOR\n        $CALL  CPFKPRT             DUMP OUT ALL THAT'S SAVED\n         B     CC14                BRANCH TO RETURN\nCC13     DS    0H\n        $CALL  PAGETOP             PRINT HEADER AND SAVED LINES\n         SPACE\nCC14     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nCCE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     CC14                BRANCH TO RETURN\nCCE024   DS    0H\n         MVI   EFLAG024,ERRSET     NO STORAGE FOR SAVE\n         B     CC14                BRANCH TO RETURN\nCCE043   DS    0H\n         MVI   EFLAG043,ERRSET     INVALID CONTROL WORD IN KEEP\n         B     CC14                BRANCH TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#CD": {"ttr": 2564, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00d\\x00d\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 100, "newlines": 100, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .CD (COLUMN DEFINITION) --- CONTROL                    *\n*                                                                     *\n***********************************************************************\n         SPACE\nCD      $ENTER ,\n         CLI   ICORFLG,ICORNONE    IN 'NO KEEP' .Q\n         BNE   CDE043              ERROR IF NOT\n        $CALL  PRINTNB             CLEAR PRINT LINE\n         L     COUNT,CLLZSAVE      COLUMN LENGTH VALUE\n         LTR   COUNT,COUNT         HAS IT BEEN SET .Q\n         BZ    CD01                BRANCH IF NOT\n         ST    COUNT,CLLZ          SET COLUMN LENGTH\n         SPACE\nCD01     DS    0H\n         CLI   ICOLFLG,ICOLNONE    IN NO COLUMN MODE .Q\n         BE    CD01A               BRANCH IF YES\n         CLI   ICOLFLG,ICOLSC      IN SINGLE COLUMN MODE .Q\n         BNE   CD02                BRANCH IF NOT\n         MVI   ICOLFLG,ICOLMC      BACK TO MULTI-COLUMN\n         SR    COUNT,COUNT         ZERO WORK REG\n         ST    COUNT,SCCOUNT       ZERO SINGLE COLUMN NEST\nCD01A    DS    0H\n         MVC   CDPLCT,PLCT         SAVE LINES REMAINING IN COLUMN\n         SPACE\nCD02     DS    0H\n         CLI   ICOLFLG,ICOLMC      IN MULTI-COLUMN MODE .Q\n         BNE   CD03                BRANCH IF NOT\n        $CALL  COLPRT              PRINT COLUMNS TO THIS POINT\n         SPACE\nCD03     DS    0H\n        $CALL  GETNUM              GET NUMBER OF COLUMNS\n         BC    BOMIT,CD07          BRANCH IF NONE\n         BC    BDNO,CDE005         BRANCH IF INVALID\n         CLI   NUMSIGN,C' '        WAS IT UNSIGNED .Q\n         BE    CD04                BRANCH IF YES\n         A     COUNT,CDCOUNT       ADJUST FORMER VALUE\nCD04     DS    0H\n         LTR   COUNT,COUNT         TOO SMALL .Q\n         BNP   CDE014              ERROR IF YES\n         LA    R0,CDMAXC           MAXIMUM ALLOWED\n         CR    COUNT,R0            TOO BIG .Q\n         BH    CDE013              ERROR IF YES\n         ST    COUNT,CDCOUNT       SET NEW VALUE\n         SR    X1,X1               KEEP LAST OPERAND VALUE\n         SR    X2,X2               OPERAND COUNTER\n         LA    X3,CDVALC           TARGET OFFSET RESULTS\n         SPACE\nCD05     DS    0H\n        $CALL  GETNUM              GET OPERAND\n         BC    BOMIT,CD07          BRANCH IF DONE\n         BC    BDNO,CDE005         BRANCH IF INVALID\n         LA    X2,1(,X2)           BUMP OPERAND NUMBER\n         LA    R0,CDMAXC           MAXIMUM ALLOWED\n         CR    X2,R0               TOO BIG .Q\n         BH    CDE013              ERROR IF YES\n         CLI   NUMSIGN,C' '        UNSIGNED OPERAND .Q\n         BE    CD06                BRANCH IF YES\n         AR    COUNT,X1            RELATIVE TO LAST\nCD06     DS    0H\n         LTR   COUNT,COUNT         TOO SMALL .Q\n         BM    CDE014              ERROR IF YES\n         C     COUNT,DEFLL+TAB3MAX TOO BIG .Q\n         BH    CDE013              ERROR IF YES\n         STC   COUNT,0(,X3)        ENTER RESULT\n         LA    X3,1(,X3)           NEXT COLUMN TARGET\n         LR    X1,COUNT            FORMER VALUE\n         B     CD05                DO IT AGAIN\n         SPACE\nCD07     DS    0H\n         LA    COUNT,1             TEST ONLY ONE COLUMN\n         C     COUNT,CDCOUNT       ONLY ONE COLUMN .Q\n         BNE   CD08                BRANCH IF NOT\n         CLI   CDVALC,X'00'        STARTING AT THE BEGINNING .Q\n         BNE   CD08                BRANCH IF NOT\n         MVI   ICOLFLG,ICOLNONE    NORMAL AGAIN\n         B     CD09                GO TO RETURN\n         SPACE\nCD08     DS    0H\n         MVI   ICOLFLG,ICOLMC      MULTI-COLUMN OUTPUT\n         LA    COUNT,1             FIRST COLUMN\n         ST    COUNT,CDCURR        PROCESS FIRST COLUMN FIRST\n         MVC   CDPLCT,PLCT         SAVE LINES REMAINING FOR COLUMN\n         SPACE\nCD09     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nCDE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     CD09                GO TO RETURN\nCDE013   DS    0H\n         MVI   EFLAG013,ERRSET     TOO BIG OR TOO MANY\n         B     CD09                GO TO RETURN\nCDE014   DS    0H\n         MVI   EFLAG014,ERRSET     TOO SMALL\n         B     CD09                GO TO RETURN\nCDE043   DS    0H\n         MVI   EFLAG043,ERRSET     INVALID CONTROL WORD IN KEEP\n         B     CD09                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#CE": {"ttr": 2567, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00-\\x00-\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .CE (CENTER) --- CONTROL                               *\n*                                                                     *\n***********************************************************************\n         SPACE\nCE      $ENTER ,\n        $ON    SWITCHS,CESWS       SET CENTERING SWITCH\n        $CALL  CELARA              SCAN AND SET ARGUMENT\n        $EXIT  RC=(R15)            AND RETURN TO CALLER\n         SPACE\nCELARA  $ENTER ,\n        $CALL  PRINTNB             CLEAR OUT PRINT LINE\n         L     X1,ARGSTART         RETAIN ARG LINE POINTER\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BOMIT,CE01          BRANCH IF NULL, ASSUME ONE\n         BC    BPOS,CE02           AFFIRMATIVE IS FOREVER\n         BC    BNEG,CE03           NEGATIVE FINISHES IT\n         ST    COUNT,ARGSTART      RESET START OF SCAN\n        $CALL  GETNUM              IT IS PROBABLY NUMERIC\n         BC    BPOS,CE04           POSSIBLY VALID IF POSITIVE OR ZERO\n         ST    X1,ARGSTART         ELSE MUST BE A 'LINE' ARGUMENT\n         B     CE04                JOIN 'LINE' TEST\n         SPACE\nCE01     DS    0H\n         LA    COUNT,1             ONE LINE BY DEFAULT\n         B     CE04                ENTER VALUE FOR CE/LA/RA\nCE02     DS    0H\n         LH    COUNT,H32767        LARGE POSITIVE NUMBER\n         B     CE04                ENTER VALUE FOR CE/LA/RA\nCE03     DS    0H\n         SR    COUNT,COUNT         ZERO VALUE\nCE04     DS    0H\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION PLEASE\n         LR    R1,COUNT            RETAIN LINE COUNT\n        $CALL  GETARG              ANY FURTHER TEXT .Q\n         LA    R15,0               ASSUME ONLY SINGLE VALID ARG\n         BC    BOMIT,CE05          NONE, SINGLE VALID ARG ONLY\n         ST    X1,ARGSTART         ORIGINAL ARG STARTS HERE\n        $CALL  USARG               MOVE ARG LINE INTO BUFFER\n         LA    R15,WRETNR          PROCESS RESULTING LINE\n         LA    R1,1                COUNT OF LINE TO PROCESS\nCE05     DS    0H\n         STH   R1,CECNT            ENTER CE/LA/RA VALUE\n        $EXIT  RC=(R15)            AND GET NEXT LINE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#CENTER": {"ttr": 2569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x19\\x00\\x19\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*                             CENTER                                  *\n*                                                                     *\n*              CENTER A LINE ON THE PAGE                              *\n*                                                                     *\n***********************************************************************\n         SPACE\nCENTER  $ENTER ,\n         USING FOPMLIST,R1\n         USING LINKELEM,P\n         L     C,FOLL              CURRENT LINE LENGTH\n         AH    C,FOINDR            PLUS RIGHT INDENT VALUE\n         S     C,FONOCHAR          LESS LENGTH OF CHARS IN LINE\n         SRA   C,1                 DIVIDE BY TWO\n         BNP   CERET               IF LINE OVERFLOWS, DON'T CENTER\n         SR    M,M                 ZERO OUT MULTIPLIER HOLDING REGISTER\n         L     P,FOPFIRST          GET POINTER TO FIRST LINK BLOCK\n         IC    M,LINKMULT          GET OLD MULTIPLIER\n         AR    M,C                 ADD ADJUSTMENT\n         STC   M,LINKMULT          STORE MULTIPLIER\nCERET    DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\n         DROP  P,R1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#CL": {"ttr": 2571, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x000\\x000\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .CL (COLUMN LENGTH) --- CONTROL                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nCL      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n        $CALL  GETNUM              GET NUMBER OPERAND\n         BC    BDNO,CLE005         ERROR IF INVALID\n         BC    BOMIT,CL01          BRANCH IF OMITTED\n         CLI   NUMSIGN,C' '        WAS OPERAND UNSIGNED .Q\n         BE    CL02                BRANCH IF YES\n         A     COUNT,CLLZ          MAKE RELATIVE CHANGE\n         B     CL02                GO CHECK AND ENTER\n         SPACE\nCL01     DS    0H\n         SR    COUNT,COUNT         ZERO DEFAULT VALUE\nCL02     DS    0H\n         LTR   COUNT,COUNT         REST FOR ZERO\n         BZ    CL03                SPECIAL CASE IF YES\n         CH    COUNT,PICNT         TEST GREATER THAN PARAGRAPH INDENT\n         BNH   CLE014              ERROR IF NOT\n         C     COUNT,DEFLL+TAB3MIN LESS THAN MINIMUM .Q\n         BL    CLE014              ERROR IF YES\n         C     COUNT,DEFLL+TAB3MAX BEYOND MAX LENGTH .Q\n         BH    CLE013              ERROR IF YES\n         ST    COUNT,CLLZ          SET COLUMN LENGTH\n         ST    COUNT,CLLZSAVE      AND SET IT TWICE\n         B     CL04                GO TO RETURN\n         SPACE\nCL03     DS    0H\n         ST    COUNT,CLLZSAVE      ZERO SAVED VALUE\n         L     COUNT,LLZ           GET CURRENT LINE LENGTH\n         ST    COUNT,CLLZ          SET AS COLUMN LENGTH\n         SPACE\nCL04     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nCLE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     CL04                GO TO RETURN\nCLE013   DS    0H\n         MVI   EFLAG013,ERRSET     OPERAND TOO BIG\n         B     CL04                GO TO RETURN\nCLE014   DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     CL04                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#CM": {"ttr": 2573, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .CM (COMMENT) --- CONTROL                              *\n*                                                                     *\n***********************************************************************\n         SPACE\nCM      $ENTER ,\n         SPACE\n*        SOME DAY THIS COMMAND MAY DO GREAT THINGS\n         SPACE\n        $EXIT  RC=0                AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#CO": {"ttr": 2575, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x13\\x00\\x13\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .CO (CONCATENATE) --- CONTROL                          *\n*                                                                     *\n***********************************************************************\n         SPACE\nCO      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BNEG,CO02           BRANCH IF NEGATIVE\nCO01     DS    0H\n        $OFF   SWITCHS,NFSWS       CONCATENATE SWITCH\n         B     CO03                AND GO TO RETURN\n         SPACE\nCO02     DS    0H\n        $ON    SWITCHS,NFSWS       NO CONCATENATE\n         SPACE\nCO03     DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#COLBAL": {"ttr": 2577, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\xf6\\x00\\xf6\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 246, "newlines": 246, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              COLBAL --- COLUMN BALANCE ROUTINE                      *\n*                                                                     *\n***********************************************************************\n         SPACE\nCOLBAL  $ENTER ,\n        $IFOFF SWITCHS,BCSWS,COLB30     QUIT IF NO BALANCE IN EFFECT\n         SPACE 2\n*--STRUCTURE OF LINKED TEXT LINES IN MULTIPLE COLUMNS\n*\n*  POINTER\n*     |\n*     |     **********************************\n*     '---> * + *  COLUMN DESCRIPTOR RECORD  *\n*           **|*******************************\n*             |\n*     .-------'\n*     |\n*     |     ************************\n*     '---> * + *  LINE 1 OF TEXT  *\n*           **|*********************\n*             |\n*     .-------'\n*     |\n*     |     ************************\n*     '---> * + *  LINE 2 OF TEXT  *\n*           **|*********************\n*             |\n*     .-------'\n*     |\n*     |     ************************\n*     '---> * + *  LINE 3 OF TEXT  *\n*           **|*********************\n*             |\n*     .-------'\n*     .\n*     .\n*     .     ************************\n*     '---> * 0 *  LAST TEXT LINE  *\n*           ************************\n         EJECT\n***********************************************************************\n*                                                                     *\n*  'BC' IS ON -- SEE IF WE HAVE ANYTHING WE CAN BALANCE               *\n*                                                                     *\n***********************************************************************\n         SPACE\n         SR    R1,R1               CLEAR WORKING COLUMN NUMBER\n         LA    X3,1(,R1)           BALANCE FROM COLUMN ONE, NORMALLY\n         SR    COUNT,COUNT         CLEAR LINE COUNT\nCOLB01   DS    0H\n         LA    R1,1(,R1)           NEXT COLUMN\n         C     R1,CDCOUNT          OVER THE TOP .Q\n         BH    COLB04              DONE IF YES\n         SPACE\n         LR    X1,R1               COLUMN TO EXAMINE\n         BCTR  X1,0                COLUMN LESS ONE\n         MH    X1,MCALEN           DESCRIPTOR OFFSET\n         LA    X1,MCAREA(X1)       POINT TO DESCRIPTOR\n         USING CPFKFN,X1           TELL THE ASSEMBLER\n         A     COUNT,CPFKFNC       ADD COLUMN LINE COUNT\n         BZ    COLB02              IF TOTAL ZERO, START WITH NEXT\n        $IFOFF CPFKFNG,COLLOCK,COLB01   BRANCH IF COLUMN NOT LOCKED\n         SR    COUNT,COUNT         ELSE, START OVER AGAIN\nCOLB02   DS    0H\n         LA    X3,1(,R1)           BALANCE FROM NEXT COLUMN\n         B     COLB01              TRY NEXT COLUMN\n         SPACE\nCOLB04   DS    0H\n         LTR   COUNT,COUNT         ANY LINES TO BALANCE .Q\n         BZ    COLB30              NO, QUIT\n         C     X3,CDCOUNT          ANY COLUMNS TO BALANCE .Q\n         BNL   COLB30              NO, QUIT\n         EJECT\n***********************************************************************\n*                                                                     *\n*  THERE IS STUFF WE CAN TRY TO BALANCE -- MAKE IT ALL ONE COLUMN     *\n*                                                                     *\n***********************************************************************\n         SPACE\n         XC    SCAREA(CPFKFNL),SCAREA   CLEAR TEMP SEQUENTIAL TARGET\n         ST    COUNT,SCQCNT        SET EXPECTED LINE COUNT\n         SR    COUNT,COUNT         CLEAR WORKING LINE COUNT\n         LR    R1,X3               START COLUMN NUMBER\n         LA    TEMP,SCQANCH+FNQFCHN-FNQELEM  CHAIN ADDRESS POINTER\n         USING FNQELEM,TEMP        TELL THE ASSEMBLER\nCOLB11   DS    0H\n         LR    X1,R1               COLUMN NUMBER\n         BCTR  X1,0                COLUMN NUMBER MINUS ONE\n         MH    X1,MCALEN           COLUMN DESCRIPTOR OFFSET\n         LA    X1,MCAREA(X1)       COLUMN DESCRIPTOR ADDR\n         MVC   FNQFCHN,CPFKFNA     ENTER COLUMN DATA\n         XC    CPFKFN(CPFKFNL),CPFKFN   CLEAR COLUMN DESCRIPTOR\n         B     COLB13              NOW GO TO END OF SEQUENTIAL\n         SPACE\nCOLB12   DS    0H\n         L     TEMP,FNQFCHN        NEXT LINE ELEMENT\n        $IFON  FNQFLAG,FNQOVLY,COLB13   BRANCH IF OVERLAY LINE\n         LA    COUNT,1(,COUNT)     BUMP RECORD COUNT\nCOLB13   DS    0H\n         OC    FNQFCHN,FNQFCHN     AT THE END .Q\n         BNZ   COLB12              BRANCH IF NOT\n         SPACE\n         LA    R1,1(,R1)           NEXT COLUMN NUMBER\n         C     R1,CDCOUNT          DONE THE LAST COLUMN .Q\n         BNH   COLB11              BRANCH IF NOT\n         SPACE\n         C     COUNT,SCQCNT        TOTALS TALLY .Q\n         BNE   ABCOLB01            LET'S TAKE A LOOK IF NOT\n         SPACE\n***********************************************************************\n*                                                                     *\n*  CALCULATE NUMBER OF LINES DESIRED PER COLUMN                       *\n*                                                                     *\n***********************************************************************\n         SPACE\n         L     TEMP,CDCOUNT        COLUMN COUNT\n         SR    TEMP,X3             LESS BALANCE COLUMN START NUMBER\n         A     TEMP,F1             NUMBER OF COLUMNS TO BALANCE\n         L     R0,SCQCNT           NUMBER OF LINES TO BALANCE\n         SRDL  R0,32               PREPARE FOR DIVIDE\n         DR    R0,TEMP             LINES BY COLUMNS\n         LTR   R0,R0               REMAINDER ZERO .Q\n         BZ    COLB21              BRANCH IF YES\n         LA    R1,1(,R1)           BUMP LINES PER COLUMN\n         EJECT\n***********************************************************************\n*                                                                     *\n*  CONSTRUCT A COLUMN                                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\n*\n*--MAKE TEMP POINT TO COLUMN DESCRIPTOR RECORD\n*\nCOLB21   DS    0H\n         LR    X1,X3               COLUMN NUMBER\n         BCTR  X1,0                COLUMN NUMBER MINUS ONE\n         MH    X1,MCALEN           COLUMN DESCRIPTOR OFFSET\n         LA    X1,MCAREA(X1)       COLUMN DESCRIPTOR ADDRESS\n         MVC   CPFKFNA,SCQANCH     REMAINDER OF LINES IN COLUMN\n         SR    COUNT,COUNT         ZERO COLUMN LINE COUNT\n         LA    TEMP,CPFKFNA+FNQFCHN-FNQELEM  START OF LIST\n*\n*--THROW AWAY SKIPS AT THE TOP OF A COLUMN\n*\nCOLB21P5 DS    0H\n         OC    FNQFCHN,FNQFCHN     IS THERE A FIRST LINE .Q\n         BZ    COLB25              IF NOT, GET OUT\n         L     X2,FNQFCHN          IS THIS FIRST LINE A\n         TM    FNQFLAG-FNQELEM(X2),FNQSSET   'SKIP AT EOB' .Q\n         BO    COLB22P3            BRANCH IF IT IS\n         TM    FNQSKSP-FNQELEM(X2),SKSPSK  IS IT A SKIP .Q\n         BZ    COLB22P3            BRANCH IF NOT\n*\n*--FIRST LINE IS A SKIP, SO FREE IT AND DELETE IT\n*\n        $SAVE  ,                   SAVE R0 AND R1\n         LR    R0,X2               ADDRESS\n         LA    R1,FNQOVHD\n         AH    R1,FNQRDW-FNQELEM(X2)  LENGTH\n         L     X2,0(X2)            POINT TO THE SECOND LINE\n         ST    X2,FNQFCHN          SAVE POINTER TO SECOND LINE\n        $CALL  FREECELL            GOODBYE, FIRST LINE\n        $RESTOR  ,                 RESTORE R0 AND R1\n         B     COLB21P5            TEST FOR ANOTHER SKIP\n         EJECT\n*\n*--PICK UP THE DESIRED NUMBER OF LINES\n*\nCOLB22   DS    0H\n         OC    FNQFCHN,FNQFCHN     IS THERE A NEXT LINE .Q\n         BZ    COLB25              IF NOT, GET OUT\n         L     X2,FNQFCHN          IS NEXT LINE AN OVERLAY .Q\nCOLB22P3 DS    0H\n         TM    FNQFLAG-FNQELEM(X2),FNQOVLY\n         BO    COLB22P9            BRANCH IF YES\n         LA    COUNT,1(,COUNT)     BUMP LINE COUNT\n         CR    COUNT,R1            ALL LINES GOT .Q\n         BL    COLB22P9            BRANCH IF NOT\n*\n         CLI   FNQCORSW-FNQELEM(X2),ICORNONE   ARE WE IN A BLOCK .Q\n         BE    COLB23              BRANCH IF NOT\n         TM    FNQFLAG-FNQELEM(X2),FNQEOB   AT LAST LINE OF BLOCK .Q\n         BO    COLB23       BRANCH IF YES -- NOW HAVE FULL COLUMN\n*\nCOLB22P9 DS    0H\n         L     TEMP,FNQFCHN        ACCEPT THIS NEXT LINE\n         B     COLB22              AND TRY AGAIN\n*\n*--GET DOWN TO THE LAST LINE OF THIS COLUMN (PLUS ITS OVERLAYS)\n*\n*--FIRST, HAVE TO SEE IF WE GOT HERE FROM THE END OF A BLOCK\n*\nCOLB23   DS    0H\n         L     TEMP,FNQFCHN        POINT AT LAST LINE\n         TM    FNQFLAG,FNQEOB      IS THIS LINE END OF BLOCK .Q\n         BZ    COLB24P1            BRANCH IF NOT\n         OC    FNQFCHN,FNQFCHN     IS THERE ONE AFTER IT .Q\n         BZ    COLB25              IF NOT, GET OUT\n*\n*--WAS THE BLOCK TERMINATED WITHOUT A BREAK .Q\n*\n         TM    FNQFLAG,FNQNOBRK\n         BZ    COLB25              BRANCH IF TERMINATED BY A BREAK\n*\n*--GRAB THE NEXT LINE IF IT IS NOT IN A BLOCK\n*\nCOLB23P2 DS    0H\n         L     X2,FNQFCHN          POINT TO NEXT LINE\n         CLI   FNQFLAG-FNQELEM(X2),ICORNONE   IN A BLOCK .Q\n         BNE   COLB25              BRANCH IF YES\n         LA    COUNT,1(,COUNT)     TAKE THIS LINE\n*\nCOLB24   DS    0H\n         L     TEMP,FNQFCHN        POINT AT LAST LINE\nCOLB24P1 DS    0H\n         OC    FNQFCHN,FNQFCHN     IS THERE ONE AFTER IT .Q\n         BZ    COLB25              IF NOT, GET OUT\n         L     X2,FNQFCHN          IS LINE AFTER LAST AN OVERLAY .Q\n         TM    FNQFLAG-FNQELEM(X2),FNQOVLY\n         BO    COLB24              BRANCH IF YES\n         EJECT\n***********************************************************************\n*                                                                     *\n*  SAVE THIS COLUMN, PREPARE TO CONSTRUCT NEXT                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nCOLB25   DS    0H\n         ST    COUNT,CPFKFNC       SET COLUMN LINE COUNT\n         MVC   SCQANCH,FNQFCHN     REST OF LINES\n         XC    FNQFCHN,FNQFCHN     MARK COLUMN END\n         SPACE\n         LA    X3,1(,X3)           NEXT COLUMN NUMBER\n         C     X3,CDCOUNT          DONE .Q\n         BNH   COLB21              BRANCH IF NOT\n         XC    SCAREA(CPFKFNL),SCAREA   CLEAR TEMP DESCRIPTOR\n         SPACE\nCOLB30   DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         DROP  TEMP,X1\n         SPACE\nABCOLB01 DS    0H\n        $LOGERR 1017               COLUMN LINE COUNTS DON'T MATCH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#COLNEW": {"ttr": 2820, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00E\\x00E\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 69, "newlines": 69, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              COLNEW --- NEW OUTPUT COLUMN ROUTINE                   *\n*                                                                     *\n***********************************************************************\n         SPACE\nCOLNEW  $ENTER ,\nCOLN01   DS    0H\n         OC    FNQCNT,FNQCNT       ANY FOOTNOTES QUEUED .Q\n         BZ    COLN03              BRANCH IF NONE\n         LH    R1,BMMRG            BOTTOM MARGIN\n         AH    R1,FNSEP            PLUS FOOTNOTE MARGIN\n         CH    R1,RMTRIG           REMOTE BEFORE BOTTOM MARGIN .Q\n         BNL   COLN02              IF NOT, SKIP\n         LH    COUNT,PLCT          YES, SPACE DOWN TO IT\n         SH    COUNT,RMTRIG        AMOUNT TO SPACE\n        $CALL  SPACER              DO IT NOW\n         SPACE\n         L     COUNT,PAGECNT       SAVE REAL PAGE EJECT COUNT\n         LH    R1,RMTRIG           REMOTE TO IMBED\n         LH    R1,RMTRIG           REMOTE TO IMBED\n        $CALL  RMIMBED             IMBED A REMOTE SEQUENCE\n         C     COUNT,PAGECNT       DID A PAGE EJECT OCCUR .Q\n         BE    COLN01              IF NOT, TRY AGAIN\n         B     COLN05              OTHERWISE QUIT\n         SPACE\nCOLN02   DS    0H\n         LH    COUNT,PLCT          LINES LEFT ON BOTTOM OF COLUMN\n         SH    COUNT,BMMRG         LESS BOTTOM MARGIN\n         SH    COUNT,FNSEP         LESS FOOTNOTE MARGIN\n        $CALL  SPACER              GENERATE LINES UP TO FOOTNOTES\n        $CALL  FNPRT               FLUSH FOOTNOTES\n         L     R1,CDCURR           CURRENT COLUMN BEING PROCESSED\n         BCTR  R1,0                DECREMENT COLUMN BY ONE\n         MH    R1,MCALEN           LENGTH OF ONE COLUMN DESCRIPTOR\n         LA    R1,MCAREA(R1)       POINT TO COLUMN ANCHOR\n         USING CPFKFN,R1           AREA LOOKS LIKE THIS\n        $ON    CPFKFNG,COLLOCK     MARK COLUMN LOCKED\n         DROP  R1\n         SPACE\nCOLN03   DS    0H\n         L     COUNT,CDCURR        CURRENT COLUMN BEING PROCESSED\n         C     COUNT,CDCOUNT       PROCESSING LAST COLUMN .Q\n         BE    COLN04              BRANCH IF YES\n         A     COUNT,F1            BUMP CURRENT COLUMN BY ONE\n         B     COLN06              GO TO COMMON EXIT\n         SPACE\nCOLN04   DS    0H\n         LH    X1,FNSEP            RETAIN FOOTNOTE MARGIN\n         XC    FNSEP,FNSEP         CLEAR FOOTNOTE MARGIN\n        $CALL  COLPRT              FLUSH WHAT WE HAVE SO FAR\n         STH   X1,FNSEP            RESTORE FOOTNOTE MARGIN\n         SPACE\n        $IFON  SWITCHS,FEMPTY,COLN05    BRANCH IF NEXT PAGE EMPTY\n         MVI   ICOLFLG,ICOLSC      DISABLE MULTIPLE COLUMNS\n         MVC   CLLZ,LLZ            RESTORE FULL LINE LENGTH\n        $CALL  PAGE                NOW TERMINATE THIS PAGE\n         MVI   ICOLFLG,ICOLMC      MULTIPLE COLUMN AGAIN\n         MVC   CDPLCT,PLCT         SAVE LINES REMAINING IN COLUMN\n         L     COUNT,CLLZSAVE      GET COLUMN LENGTH\n         LTR   COUNT,COUNT         HAS IT BEEN DEFINED .Q\n         BZ    COLN05              BRANCH IF NOT\n         ST    COUNT,CLLZ          RESTORE COLUMN LENGTH\nCOLN05   DS    0H\n         LA    COUNT,1             START WITH COLUMN ONE AGAIN\nCOLN06   DS    0H\n         ST    COUNT,CDCURR        SET CURRENT OUTPUT COLUMN\n         MVC   PLCT,CDPLCT         RESET LINES REMAINING\n        $EXIT  RC=0                RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#COLPAGE": {"ttr": 2822, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00 \\x00 \\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              COLPAGE --- COLUMN EJECT ROUTINE                       *\n*                                                                     *\n***********************************************************************\n         SPACE\nCOLPAGE $ENTER ,\n         CLI   ICORFLG,ICORNONE    'NO KEEP' IN PROGRESS\n         BNE   COLGE043            ERROR IF NOT\n         CLI   ICOLFLG,ICOLMC      MULTI-COLUMN MODE .Q\n         BE    COLG01              BRANCH IF YES\n        $CALL  PAGE                TREAT AS PAGE EJECT\n         B     COLG03              GO TO RETURN\n         SPACE\nCOLG01   DS    0H\n         L     R1,CDCURR           CURRENT COLUMN BEING PROCESSED\n         C     R1,CDCOUNT          PROCESSING LAST COLUMN .Q\n         BE    COLG02              BRANCH IF YES\n         BCTR  R1,0                DECREMENT COLUMN BY ONE\n         MH    R1,MCALEN           LENGTH OF ONE COLUMN DESCRIPTOR\n         LA    R1,MCAREA(R1)       POINT TO COLUMN ANCHOR\n         USING CPFKFN,R1           AREA LOOKS LIKE THIS\n        $ON    CPFKFNG,COLLOCK     MARK COLUMN LOCKED\n         DROP  R1\nCOLG02   DS    0H\n        $CALL  COLNEW              NEW COLUMN REQUIRED\nCOLG03   DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nCOLGE043 DS    0H\n         MVI   EFLAG043,ERRSET     INVALID ROUTINE IN KEEP\n         B     COLG03              GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#COLPRT": {"ttr": 2824, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\xd5\\x00\\xd5\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 213, "newlines": 213, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              COLPRT --- COLUMN PRINT ROUTINE                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nCOLPRT  $ENTER ,\n         CLI   ICOLFLG,ICOLMC      IN MULTI-COLUMN MODE .Q\n         BNE   ABCOLT01            WHY ARE WE HERE IF NOT .Q\n         SPACE\n         OC    SKSP,SKSP           ANY CONDITIONAL SKIP/SPACE .Q\n         BZ    COLT02              BRANCH IF NONE\n         LA    R1,ICORSLEN         LENGTH OF DATA SAVE\n        $CALL  GETCELL             GET DATA SAVE AREA\n         BC    BNEG,COLT01         BRANCH IF FAILURE\n         USING ICORSAVE,TEMP       TELL THE ASSEMBLER\n         ST    TEMP,SCQSAVE        RETAIN AREA ADDRESS\n         MVC   ICORSKSP,SKSP       RETAIN OUTSTANDING COND SKIP/SPACE\n         DROP  TEMP\n         B     COLT02              AND CONTINUE\nCOLT01   DS    0H\n         MVI   EFLAG024,ERRSET     INSUFFICIENT STORAGE\n         SPACE\nCOLT02   DS    0H\n         XC    SKSP,SKSP           DELETE OUTSTANDING SKIP/SPACE\n        $CALL  COLBAL              BALANCE COLUMNS IF REQUIRED\n         SPACE\nCOLT03   DS    0H\n        $OFF   SWITCHS,FOVLY       DON'T GET OVERLAY LINES\nCOLT04   DS    0H\n         L     X3,BUFF3AD          POINT TO WORK BUFFER\n         XC    0(4,X3),0(X3)       CLEAR RDW\n         MVC   4(B2LG,X3),BLANKS   CLEAR DATA\n        $OFF   SWITCHS,FNOCASE     SEARCH FOR NOTHING LEFT\n         SPACE\n         SR    X1,X1               CLEAR COLUMN COUNT\nCOLT05   DS    0H\n         LA    X1,1(,X1)           NEXT COLUMN\n         LA    R0,CDMAXC           MAX COLUMN COUNT\n         CR    X1,R0               OFF THE END .Q\n         BH    COLT20              BRANCH IF YES\n         LR    R1,X1               COLUMN NUMBER\n         BCTR  R1,0                COLUMN LESS ONE\n         MH    R1,MCALEN           COLUMN DESCRIPTOR OFFSET\n         LA    R1,MCAREA(R1)       COLUMN DESCRIPTOR\n         USING CPFKFN,R1           AREA LOOKS LIKE THIS\n         L     TEMP,CPFKFNA        FIRST LINE HERE\n         LTR   TEMP,TEMP           ANYTHING THERE .Q\n         BZ    COLT05              NO, GO BACK\n        $ON    SWITCHS,FNOCASE     INDICATE SOMETHING LEFT\n         SPACE\n        $IFOFF SWITCHS,FOVLY,COLT06     BRANCH IF FIRST LINE ONLY\n         USING FNQELEM,TEMP        LINE IS HERE\n        $IFOFF FNQFLAG,FNQOVLY,COLT05   BRANCH IF NOT OVERLAY LINE\n         B     COLT07              GET IT\nCOLT06   DS    0H\n         L     R0,CPFKFNC          LINE REMAINING COUNT\n         S     R0,F1               LESS ONE\n         ST    R0,CPFKFNC          UPDATE REMAINING COUNT\n         BP    COLT07              BRANCH IF MORE TO COME\n         BM    ABCOLT01            SHOULD NEVER GO NEGATIVE\n         XC    CPFKFNG,CPFKFNG     CLEAR FLAGS WHEN NO LINES LEFT\nCOLT07   DS    0H\n         MVC   CPFKFNA,FNQFCHN     UNLINK THE FIRST\n         DROP  R1\n         SPACE\n         LR    R1,X1               COLUMN NUMBER\n         BCTR  R1,0                COLUMN LESS ONE\n         IC    R1,CDVALC(R1)       COLUMN OFFSET\n         STH   R1,SAVEH0           RETAIN COLUMN TARGET\n         LA    R1,1(,R1)           CHANGE TO COLUMN NUMBER\n         L     R0,BUFF3AD          POINT TO OUTPUT TARGET\n        $CALL  PRTARG              LOCATE TARGET ADDRESS\n         SPACE\n        $IFON  TTYPE,TONLINE,COLT09     BRANCH IF ONLINE\n         L     X3,BUFF3AD          POINT TO TARGET\n         MVC   4(1,X3),FNQTEXT     ENTER CARRIAGE CONTROL\n         LR    X3,R1               POINT TO TARGET AREA\n         LH    R0,FNQRDW           LENGTH OF RECORD\n         S     R0,F5               LESS RDW LENGTH/CC\n         LA    R1,FNQTEXT+1        COLUMN TEXT HERE IF OFFLINE\n         B     COLT11              AND CONTINUE\n         SPACE\nCOLT09   DS    0H\n         LR    X3,R1               ADDRESS OF TARGET\n         L     R1,BUFF3AD          POINT TO TARGET\n         LH    R1,0(,R1)           CURRENT LENGTH\n         LTR   R1,R1               FIRST TIME .Q\n         BZ    COLT10              BRANCH IF YES\n         LH    COUNT,FNQRDW        LENGTH OF DATA (INCL RDW)\n         S     COUNT,F5            LENGTH-1 OF DATA\n         BM    COLT10              BRANCH IF NOTHING\n         EX    COUNT,COLTBCLC      IS DATA ALL BLANK .Q\n         BE    COLT10              BRANCH IF YES\n         SPACE\n         MVI   SAVEX0,TDEVTAB-TDEVICEA  HORIZONTAL TAB FUNCTION\n         A     R1,BUFF3AD          LAST CHARACTER USED\n         LA    R1,1(,R1)           FIRST FREE COLUMN\n         ST    R1,SAVEF0           WHERE TO PUT RESULT\n         LA    R1,SAVED0           POINT TO PARM AREA\n        $CALL  LKGESC              ADD ESCAPE SEQUENCE\n         BC    BNEG,COLT10         BRANCH IF TAB NOT DEFINED\n         LR    X3,R1               RESUME OUTPUT HERE\n         B     COLT10              AND CONTINUE\nCOLTBCLC CLC   FNQTEXT(*-*),BLANKS IS ONLINE COLUMN DATA ALL BLANKS .Q\n         SPACE\nCOLT10   DS    0H\n         LH    R0,FNQRDW           LENGTH OF RECORD\n         S     R0,F4               LESS RDW LENGTH\n         LA    R1,FNQTEXT          COLUMN TEXT HERE IF ONLINE\nCOLT11   DS    0H\n         S     R0,F1               DECREMENT REMAINING LENGTH\n         BM    COLT13              BRANCH IF NOTHING LEFT\n         CLI   0(R1),C' '          BLANK 'FROM' CHARACTER .Q\n         BE    COLT12              BRANCH IF YES\n         MVC   0(1,X3),0(R1)       ENTER COLUMN CHARACTER\nCOLT12   DS    0H\n         LA    X3,1(,X3)           BUMP 'TO' POINTER\n         LA    R1,1(,R1)           BUMP 'FROM' POINTER\n         B     COLT11              AND TRY AGAIN\nCOLT13   DS    0H\n         LR    R1,X3               ADDED STRING ENDED HERE\n         L     X3,BUFF3AD          STARTED HERE\n         SR    R1,X3               LENGTH OF RESULT\n         CH    R1,0(,X3)           COMPARE WITH CURRENT LENGTH\n         BNH   COLT14              BRANCH IF NO GREATER\n         STH   R1,0(,X3)           SET NEW LENGTH OF TARGET\n         SPACE\nCOLT14   DS    0H\n         LH    R1,FNQRDW           LENGTH OF DATA AND RDW\n         LA    R1,FNQOVHD(,R1)     PLUS PREFIX OVERHEAD\n         LA    R0,FNQELEM          WHERE IT'S AT\n        $CALL  FREECELL            FREE THIS ENTRY\n         B     COLT05              GO TO NEXT COLUMN\n         DROP  TEMP\n         SPACE\nCOLT20   DS    0H\n        $IFOFF SWITCHS,FNOCASE,COLT30   BRANCH IF NOTHING LEFT\n         L     X3,BUFF3AD          POINT TO WORK BUFFER\n         LH    R1,0(,X3)           LENGTH OF DATA PLUS RDW\n         LTR   R1,R1               TEST LENGTH FOR NULL\n         BZ    COLT21              BRANCH IF NOTHING\n         L     TEMP,ICORANCH       SAVE INCORE ANCHOR\n         LA    R1,SCAREA           SINGLE COLUMN AREA\n         ST    R1,ICORANCH         PUT IT ON THIS CHAIN\n         LR    R0,X3               POINT TO DATA\n        $ON    SWITCHS,OOSWS       NO OVERLAY AGAIN\n        $ON    SWITCHS,TRSUP       SUPPRESS OUTPUT TRANSLATE\n        $CALL  FNSAVE              SAVE LINE ON CHAIN\n        $OFF   SWITCHS,OOSWS       RESET OUTPUT OVERLAY\n         ST    TEMP,ICORANCH       RESET ANY OTHER ANCHOR\n         B     COLT22              CHECK FOR DONE\n         SPACE\nCOLT21   DS    0H\n        $IFON  SWITCHS,FOVLY,COLT03     BRANCH IF ONLY OVERLAYS\nCOLT22   DS    0H\n        $ON    SWITCHS,FOVLY       ONLY OVERLAYS NOW\n         B     COLT04              NEXT LAYER NOW\n         SPACE\nCOLT30   DS    0H\n         L     TEMP,SCQSAVE        SAVED AREA POINTER\n         LTR   TEMP,TEMP           DOES IT EXIST .Q\n         BZ    COLT34              BRANCH IF NOT\n         USING ICORSAVE,TEMP       SAVE AREA LOOKS LIKE THIS\n         L     X1,SCQANCH          SINGLE COLUMN ANCHOR\n         LTR   X1,X1               ANY DATA AT ALL .Q\n         BZ    COLT33              BRANCH IF NOEN\n         USING FNQELEM,X1          CHAIN LOOKS LIKE THIS\nCOLT31   DS    0H\n         OC    FNQFCHN,FNQFCHN     LAST ENTRY IN CHAIN .Q\n         BZ    COLT32              BRANCH IF YES\n         L     X1,FNQFCHN          FORWARD POINTER\n         B     COLT31              AND SEARCH AGAIN\nCOLT32   DS    0H\n        $ON    FNQFLAG,FNQSSET     CONDITIONAL SKIP/SPACE SET\n         MVC   FNQSKSP,ICORSKSP    RESTORE COND SKIP/SPACE DATA\nCOLT33   DS    0H\n         XC    SCQSAVE,SCQSAVE     SINGLE COLUMN SAVE POINTER\n         LA    R0,ICORSAVE         POINT TO SAVE AREA\n         LA    R1,ICORSLEN         LENGTH OF DATA\n        $CALL  FREECELL            RELEASE WORK AREA\n         DROP  X1,TEMP\n         SPACE\nCOLT34   DS    0H\n        $OFF   SWITCHS,FOVLY       RESET OVERLAY SWITCH\n         XC    RMTRIG,RMTRIG       DISABLE AUTO REMOTES\n         MVC   PLCT,CDPLCT         AS YOU WERE AT START\n         MVI   ICOLFLG,ICOLSC      DISABLE MULTI-COLS\n         MVC   CLLZ,LLZ            RESTORE FULL LINE LENGTH\n         LA    R1,SCAREA           POINT TO NEW SINGLE COLUMN DESCRIPT\n        $CALL  CPFKPRT             PRINT COLUMNS\n         BC    15-BOMIT,ABCOLT01   BETTER BE FINISHED\n         LH    COUNT,PLCT          LINES LEFT ON PAGE\n         LH    R1,BMMRG            BOTTOM MARGIN\n         AH    R1,FNSEP            PLUS FOOTNOTE MARGIN\n         CR    COUNT,R1            COMPARE WITH BOTTOM MARGIN\n         BH    COLT35              BRANCH IF NOT FULL\n        $CALL  PAGE                TERMINATE THIS PAGE\n         SPACE\nCOLT35   DS    0H\n         MVI   ICOLFLG,ICOLMC      MULTI-COLUMN AGAIN\n         L     COUNT,CLLZSAVE      GET COLUMN LENGTH\n         LTR   COUNT,COUNT         HAS IT BEEN DEFINED .Q\n         BZ    COLT36              BRANCH IF NOT\n         ST    COUNT,CLLZ          RESTORE COLUMN LENGTH\nCOLT36   DS    0H\n         LA    COUNT,1             FIRST COLUMN\n         ST    COUNT,CDCURR        PROCESS FIRST COLUMN FIRST\n         MVC   CDPLCT,PLCT         SAVE LINES REMAINING IN COLUMN\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nABCOLT01 DS    0H\n        $LOGERR 1015               COLUMN PRINT PROBLEMS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#COLSAVE": {"ttr": 2829, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              COLSAVE --- COLUMN SAVE ROUTINE                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nCOLSAVE $ENTER ,\n         CLI   ICOLFLG,ICOLMC      IN MULTI-COLUMN MODE .Q\n         BNE   ABCOLS01            BRANCH IF NOT\n         SPACE\n         L     R1,CDCURR           CURRENT OUTPUT COLUMN\n         S     R1,F1               LESS ONE\n         BM    ABCOLS01            BRANCH IF TOO SMALL\n         MH    R1,MCALEN           COLUMN BLOCK OFFSET\n         LA    R1,MCAREA(R1)       POINT TO COLUMN BLOCK\n         L     X3,ICORANCH         SAVE INCORE ANCHOR\n         ST    R1,ICORANCH         SET COLUMN ANCHOR\n        $ON    SWITCHS,OOSWS       DISABLE OUTPUT OVERLAY\n        $ON    SWITCHS,TRSUP       SUPPRESS OUTPUT TRANSLATE\n        $CALL  FNSAVE              SAVE COLUMN LINE\n         ST    X3,ICORANCH         RESET INCORE ANCHOR\n        $OFF   SWITCHS,OOSWS       ENABLE OUTPUT OVERLAY\n         SPACE\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nABCOLS01 DS    0H\n        $LOGERR 1016               COLUMN PRINT PROBLEMS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#CP": {"ttr": 2831, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x9b\\x00\\x9b\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 155, "newlines": 155, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .CP (CONDITIONAL PAGE EJECT) --- CONTROL               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nCP      $ENTER ,\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BOMIT,CP08          IF ARG OMITTED, IGNORE\n         BC    BPOS,CP02           BRANCH IF A BEGINNING\n         BC    BNEG,CP03           BRANCH IF AN ENDING\n         ST    COUNT,ARGSTART      RESET START OF SCAN\n        $CALL  GETNUM              GET NUMERIC ARGUMENT\n         BC    BDNO,CPE005         ERROR IF INVALID\n         CLI   ICORFLG,ICORNONE    ARE WE SAVING INTO CORE NOW .Q\n         BNE   CP08                IF YES, IGNORE THIS REQUEST\n         LTR   COUNT,COUNT         ZERO OR MINUS SPACE .Q\n         BNP   CP08                IF SO, NO PAGE EJECT\n         LH    TEMP,PLCT           GET COUNT OF NUMBER LEFT\n         SR    TEMP,COUNT          LESS NUMBER REQUIRED\n         BM    CP01                MINUS FORCE AN EJECT\n         LH    R1,BMMRG            BOTTOM MARGIN\n         AH    R1,FNSEP            PLUS FOOTNOTE MARGIN\n         CR    TEMP,R1             BELOW BOTTOM MARGIN .Q\n         BNL   CP08                BRANCH IF NOT\nCP01     DS    0H\n        $CALL  PAGEREAL            YES, FORCE PAGE EJECT\n         B     CP08                GO TO DONE\n         SPACE\nCP02     DS    0H\n         CLI   ICORFLG,ICORNONE    ARE WE SAVING INTO CORE NOW .Q\n         BNE   CPE012              IF YES, ERROR\n         LA    R1,ICORSLEN         NEED THIS MUCH SPACE\n        $CALL  GETCELL             GET THE SPACE\n         BC    BNEG,CPE024         BRANCH IF FAILURE\n         USING ICORSAVE,TEMP       SAVE AREA LOOKS LIKE THIS\n         ST    TEMP,CPQSAVE        SAVE AREA POINTER\n         MVC   ICORSKSP,SKSP       SAVE CONDITIONAL SKIP/SPACE\n         XC    SKSP,SKSP           CLEAR CURRENT SKIP/SPACE\n         DROP  TEMP\n         SPACE\n         MVI   ICORFLG,ICORCP      SET CONDITIONAL KEEP\n         LA    TEMP,CPAREA         CONDITIONAL KEEP CONTROL\n         ST    TEMP,ICORANCH       SAVE THIS FOR LATER\n         B     CP08                GO TO DONE\n         SPACE\nCP03     DS    0H\n         CLI   ICORFLG,ICORCP      CURRENTLY WITHIN COND KEEP .Q\n         BNE   CPE012              ERROR IF NOT\n        $CALL  GETNUM              GET OPTIONAL SECOND ARG FOR 'END'\n         BC    15-BDNO,CP03A       OK IF NOT INVALID\n         MVI   EFLAG005,ERRSET     SET ERROR FLAG\n         SR    COUNT,COUNT         AND USE ZERO ADJUSTMENT\n         B     CP03B               CONTINUE\nCP03A    DS    0H\n         BC    15-BOMIT,CP03B      BRANCH IF NOT OMITTED\n         SR    COUNT,COUNT         USER ZERO ADJUSTMENT\nCP03B    DS    0H\n         LA    R1,CPAREA           CONDITIONAL PAGE AREA DESCRIPTOR\n        $CALL  CPENDS              TERMINATE THE BLOCK\n         SPACE\n         L     TEMP,CPQSAVE        RESTORE SAVED AREA POINTER\n         XC    CPQSAVE,CPQSAVE     CLEAR POINTER\n         USING ICORSAVE,TEMP       AREA LOOKS LIKE THIS\n        $MVC   SKSP,ICORSKSP       RESTORE CONDITIONAL SKIP/SPACE\n         LA    R0,ICORSAVE         POINT TO AREA\n         LA    R1,ICORSLEN         LENGTH OF SAVE AREA\n        $CALL  FREECELL            RELEASE WORK AREA\n         DROP  TEMP\n         SPACE\n         MVI   ICORFLG,ICORNONE    RESET SAVING CONDITIONAL PAGE FLAG\n         XC    ICORANCH,ICORANCH   CLEAR COND PAGE CONTROL\n         SPACE\n        $IFON  SWITCHS,FEMPTY,CP07 BRANCH IF PAGE NOW EMPTY\n         LH    TEMP,PLCT           COUNT OF LINES LEFT\n         S     TEMP,CPQCNT         LESS QUEUED COND KEEP COUNT\n         SH    TEMP,SKSPCCNT       LESS CONDITIONAL SPACE COUNT\n         SR    TEMP,COUNT          ADJUST FURTHER WITH USER'S REQUEST\n         OC    OLDCOUNT,OLDCOUNT   ALL DATA FORMATTED AND PRINTED .Q\n         BZ    CP04                BRANCH IF YES\n         S     TEMP,F1             TAKE THAT LINE INTO ACCOUNT\nCP04     DS    0H\n         LTR   TEMP,TEMP           TEST FOR NONE LEFT\n         BM    CP05                MINUS, FORCE AN EJECT\n         LH    R1,BMMRG            BOTTOM MARGIN\n         AH    R1,FNSEP            PLUS FOOTNOTE MARGIN\n         CR    TEMP,R1             BELOW BOTTOM MARGIN .Q\n         BNL   CP06                IF NOT, DON'T FORCE AN EJECT\n         SPACE\nCP05     DS    0H\n         XC    SKSP,SKSP           CLEAR CONDITIONAL SPACES\n        $ON    SWITCHS,OOSWS       NO OVERLAY PLEASE\n        $CALL  PAGE                FIRST FORCE LAST PAGE\n        $OFF   SWITCHS,OOSWS       REENABLE OVERLAY\nCP06     DS    0H\n        $IFON  SWITCHS,FEMPTY,CP07 BRANCH IF PAGE NOW EMPTY\n         LA    R1,CPAREA           QUEUED LINE DESCRIPTOR\n        $CALL  CPFKPRT             DUMP OUT ALL THAT'S SAVED\n         B     CP08                BRANCH TO RETURN\nCP07     DS    0H\n         XC    SKSP,SKSP           CLEAR CONDITIONAL SPACES\n        $CALL  PAGETOP             PRINT HEADER AND SAVED LINES\n         SPACE\nCP08     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nCPE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     CP08                BRANCH TO RETURN\nCPE012   DS    0H\n         MVI   EFLAG012,ERRSET     ILLEGAL CONTROL WORD\n         B     CP08                BRANCH TO RETURN\nCPE024   DS    0H\n         MVI   EFLAG024,ERRSET     NO STORAGE FOR SAVE\n         B     CP08                BRANCH TO RETURN\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              CPENDS --- TERMINATE INCORE TEXT BLOCK                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n*        ON ENTRY  --  (R1)    POINTER TO AREA DESCRIPTOR\n*                      (COUNT) EXTRA USER SPACE REQUEST\n         SPACE\nCPENDS  $ENTER ,\n         USING CPFKFN,R1           AREA DESCRIPTOR\n         L     X1,CPFKFNA          FIRST LINE ANCHOR\n         LTR   X1,X1               ANY DATA AT ALL .Q\n         BZ    CPENDS04            BRANCH IF NONE\n         USING FNQELEM,X1          CHAIN LOOKS LIKE THIS\nCPENDS01 DS    0H\n         OC    FNQFCHN,FNQFCHN     LAST ENTRY IN CHAIN .Q\n         BZ    CPENDS02            BRANCH IF YES\n         L     X1,FNQFCHN          FORWARD POINTER\n         B     CPENDS01            SEARCH AGAIN\n         SPACE\nCPENDS02 DS    0H\n        $ON    FNQFLAG,FNQEOB      SET LAST RECORD FLAG\n         STH   COUNT,FNQNUMOP      EXTRA USER REQUEST\n         OC    SKSPCCNT,SKSPCCNT   ANY SKIP/SPACE OUTSTANDING .Q\n         BZ    CPENDS03            BRANCH IF NONE\n        $ON    FNQFLAG,FNQSSET     SKIP/SPACE OUTSTANDING\n        $MVC   FNQSKSP+SKSPFLG2-SKSP,SKSPFLG2     SAVE THE FLAG\n        $MVC   FNQSKSP+SKSPCCNT-SKSP,SKSPCCNT     AND THE COUNT\n         XC    SKSP,SKSP           CLEAR CONDITIONAL SPACE/SKIP\n         SPACE\nCPENDS03 DS    0H\n         OC    OLDCOUNT,OLDCOUNT   ALL DATA FORMATTED AND PRINTED .Q\n         BZ    CPENDS04            BRANCH IF YES\n        $ON    FNQFLAG,FNQNOBRK    INDICATE PARTIAL LINE LEFT\n         SPACE\nCPENDS04 DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         DROP  X1,R1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#CPFKNXT": {"ttr": 3076, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00-\\x00-\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL ROUTINE 'CPFKNXT' --- LENGTH OF NEXT BLOCK    *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R1) -> CPFKFN BLOCK\n*        ON EXIT   --  CC = BOMIT IF CHAIN EMPTY\n*                      CC = BPOS  IF CHAIN NOT EMPTY\n*                      CPFKFNF    LENGTH OF NEXT BLOCK\n*                      (COUNT)    ADJUSTED LENGTH OF NEXT BLOCK\n*                      (TEMP)     PTR TO LAST RECORD IN BLOCK\n         SPACE\nCPFKNXT $ENTER ,\n         LR    X1,R1               INPUT PARM POINTER\n         USING CPFKFN,X1           AND TELL THE ASSEMBLER\n         XC    CPFKFNF,CPFKFNF     CLEAR RETURN LENGTH\n         SR    COUNT,COUNT         INITIALIZE USER ADJUSTED LENGTH\n         L     TEMP,CPFKFNA        ADDRESS OF FIRST QUEUED LINE\n         LTR   TEMP,TEMP           ANY PRESENT .Q\n         BNZ   CFNXT01             YES, CONTINUE\n        $CC    OMIT                SET COND CODE\n         B     CFNXT04             AND GO TO RETURN\n         SPACE\nCFNXT01  DS    0H\n         USING FNQELEM,TEMP        QUEUED RECORD POINTER\n        $IFON  FNQFLAG,FNQOVLY,CFNXT02  BRANCH IF OVERLAY LINE\n        $IFON  FNQFLAG,FNQTC,CFNXT02    BRANCH IF TC LINE\n         A     COUNT,F1            BUMP BLOCK LINE COUNT\nCFNXT02  DS    0H\n        $IFON  FNQFLAG,FNQEOB,CFNXT03   BRANCH OUT IF END OF BLOCK\n         OC    FNQFCHN,FNQFCHN     ANY NEXT IN LINE .Q\n         BZ    CFNXT03             BRANCH IF NOT\n         L     TEMP,FNQFCHN        FORWARD LINE LINK\n         B     CFNXT01             GO CHECK AGAIN\nCFNXT03  DS    0H\n         ST    COUNT,CPFKFNF       SAVE FIRST BLOCK LENGTH\n         AH    COUNT,FNQNUMOP      ADD USER QUALIFICATION\n        $CC    POS                 SET COND CODE\n         SPACE\nCFNXT04  DS    0H\n        $RESTOR KEEP=(COUNT,TEMP)  RESTORE CALLER'S REGISTERS\n         BR    RETURN              AND RETURN TO CALLER\n         SPACE\n         DROP  TEMP,X1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#CPFKPRT": {"ttr": 3078, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\xa5\\x00\\xa5\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 165, "newlines": 165, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL ROUTINE 'CPFKPRT' --- PRINT QUEUED LINES      *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY --  (R1) -> CPFKFN BLOCK\n*\n*        ON EXIT  --  CC=BOMIT   IF NOTHING LEFT TO DO\n*                     CC=BPOS    IF BLOCK DONE\n*                     CC=BNEG    IF FIRST BLOCK NOT DONE\n         SPACE\nCPFKPRT $ENTER ,\n         LR    X1,R1               INPUT PARAMETER\n         USING CPFKFN,X1           AND TELL THE ASSEMBLER\n         L     X2,CPFKFNA          FIRST QUEUED LINE\n         LTR   X2,X2               ANYTHING THERE .Q\n         BZ    CFPRT02             BRANCH IF NOTHING\n         USING FNQELEM,X2          LINE LOOKS SO\n        $IFON  FNQFLAG,FNQSSET,CFPRT01  IF BUT ONE LINE, ALLOW IT\n        $IFOFF FNQSKSP,SKSPCND,CFPRT01  BRANCH IF NOT CONDITIONAL\n         XC    SKSP,SKSP           KILL ANY OUTSTANDING SPACE\n         DROP  X2\nCFPRT01  DS    0H\n        $CALL  PRSKSPC             PUT CONDITIONAL SPACE FIRST\n         SPACE\nCFPRT02  DS    0H\n         XC    RMTRIG,RMTRIG       DISABLE REMOTE TRIGGERS WITHIN\n        $ON    CPFKFNG,CPFKSKIP    LEADING SKIP SWITCH\n         SR    X3,X3               KEEP NO FIRST POINTER\n        $IFOFF CPFKFNG,CPFKKEEP,CFPRT03 BRANCH IF DON'T KEEP\n         L     X3,CPFKFNA          ADDR FIRST QUEUED LINE\n         SPACE\nCFPRT03  DS    0H\n         L     X2,CPFKFNA          ADDR OF NEXT QUEUED LINE\n         LTR   X2,X2               ANYTHING THERE .Q\n         BZ    CFPRT14             BRANCH IF NOT\n         USING FNQELEM,X2          AND TELL THE ASSEMBLER\n        $IFOFF FNQFLAG,FNQTC,CFPRT04    BRANCH IF NOT TC ENTRY\n         LA    R1,FNQTEXT          POINT TO USER DATA\n         LNR   R1,R1               ENTER 'FIFO'\n         LH    TEMP,FNQRDW         LENGTH OF RDW AND DATA\n         S     TEMP,F5             LENGTH-1 OF DATA\n         BM    ABCFP03             BRANCH IF NOTHING\n         L     R0,DHNUMTC          CURRENT TABLE OF CONTENTS NUMBER\n         LH    COUNT,FNQNUMTC      FORMER TC NUMBER WHEN DEFINED\n         ST    COUNT,DHNUMTC       SET FOR ADD\n        $CALL  HIDTCAD             ENTER FOR TABLE OF CONTENTS\n         ST    R0,DHNUMTC          RESTORE TABLE OF CONTENTS NUMBER\n         MVC   CPFKFNA,FNQFCHN     POINT TO NEXT BUFFERED LINE\n         B     CFPRT10             AND CONTINUE\n         SPACE\nCFPRT04  DS    0H\n        $IFOFF CPFKFNG,CPFKSKIP,CFPRT05 BRANCH IF NOT FIRST SKIP\n         LH    COUNT,PLZ           PAGE LENGTH\n         SH    COUNT,PLCT          LESS LINES LEFT\n         CH    COUNT,TOPMRG        AT TOP OF PAGE .Q\n         BH    CFPRT05             BRANCH IF NOT\n         CLI   ICOLFLG,ICOLMC      IN MULTI-COLUMN MODE .Q\n         BE    CFPRT05             BRANCH IF YES\n        $IFON  FNQFLAG,FNQSSET,CFPRT05  BRANCH IF SKIP/SPACE SAVED\n        $IFON  FNQSKSP,SKSPSK,CFPRT09   BRANCH IF A SKIP\n         SPACE\nCFPRT05  DS    0H\n        $OFF   CPFKFNG,CPFKSKIP    NO LONGER THE FIRST SKIP\n        $IFON  FNQFLAG,FNQOVLY,CFPRT06  BRANCH IF OVERLAY LINE\n         LH    COUNT,PLCT          ACCOUNT FOR LINE WE'RE ABOUT\n         BCTR  COUNT,0             TO PRINT\n         LH    R1,BMMRG            BOTTOM MARGIN\n         AH    R1,FNSEP            PLUS FOOTNOTE MARGIN\n         CR    COUNT,R1            BELOW BOTTOM MARGIN .Q\n         BL    CFPRT16             IF YES, DONE THIS PAGE\n         STH   COUNT,PLCT          NO, SAVE UPDATED COUNT LEFT\n         SPACE\nCFPRT06  DS    0H\n         LH    R1,FNQRDW           LOAD LENGTH RDW/TEXT\n         S     R1,F4               LESS LENGTH OF RDW\n         BM    ABCFP01             BAD TROUBLE IF NEGATIVE\n         CLI   ICOLFLG,ICOLMC      DESTINED FOR MULTI-COLUMN .Q\n         BNE   CFPRT07             BRANCH IF NOT\n         LA    R0,FNQELEM          ADDRESS OF RECORD\n         ST    R0,MCFNQAD          SAVE AWAY FOR LATER\nCFPRT07  DS    0H\n         LA    R0,FNQRDW           POINT TO OUTPUT RECORD\n        $ON    SWITCHS,OOSWS       DISABLE OUTPUT OVERLAY\n        $IFOFF FNQFLAG,FNQOVLY,CFPRT08  BRANCH IF NOT OVERLAY LINE\n        $ON    SWITCHS,FOVLY       INDICATE OVERLAY\nCFPRT08  DS    0H\n        $CALL  IOPRINT             CAUSE LINE TO BE OUTPUT\n        $OFF   SWITCHS,OOSWS       RE-ENABLE OUTPUT OVERLAY\n        $OFF   SWITCHS,FOVLY       TURN OFF PRINTER OVERLAY\n         SPACE\nCFPRT09  DS    0H\n        $IFON  FNQFLAG,FNQOVLY,CFPRT10  BRANCH IF OVERLAY LINE\n         LTR   X3,X3               KEEP DATA FOR LATER .Q\n         BNZ   CFPRT10             BRANCH IF YES\n         L     COUNT,CPFKFNC       CURRENT NUMBER OF BUFFERED LINES\n         S     COUNT,F1            DECREMENT BY ONE\n         BM    ABCFP02             GONE WRONG IF NEGATIVE\n         ST    COUNT,CPFKFNC       UPDATE QUEUED LINE COUNT\nCFPRT10  DS    0H\n         SR    COUNT,COUNT         ASSUME NOT EOB RECORD\n        $IFOFF FNQFLAG,FNQEOB,CFPRT11   BRANCH IF CORRECT\n         LH    COUNT,FNQNUMOP      GET USER QUALIFICATION\n         LA    COUNT,1(,COUNT)     USER QUALIFICATION PLUS ONE\nCFPRT11  DS    0H\n        $IFOFF FNQFLAG,FNQSSET,CFPRT12  BRANCH IF NO SKIP/SPACE\n         XC    SKSP,SKSP           CLEAR SPACE/SKIP\n         MVC   SKSPFLG2,FNQSKSP+SKSPFLG2-SKSP     RESTORE TYPE\n         MVC   SKSPCCNT,FNQSKSP+SKSPCCNT-SKSP     RESTORE COUNT\nCFPRT12  DS    0H\n         MVC   CPFKFNA,FNQFCHN     POINT TO NEXT BUFFERED LINE\n         LTR   X3,X3               DO WE KEEP THE DATA LINES .Q\n         BNZ   CFPRT13             BRANCH IF YES\n         LH    R1,FNQRDW           LENGTH OF DATA AND RDW\n         LA    R1,FNQOVHD(,R1)     PLUS PREFIX OVERHEAD\n         LA    R0,FNQELEM          POINT TO AREA\n        $CALL  FREECELL            FREE THIS ENTRY\n         SPACE\nCFPRT13  DS    0H\n         S     COUNT,F1            USER QUALIFICATION RESTORED\n         BM    CFPRT03             IF MINUS, NOT EOB\n         LA    R1,CPFKFN           POINT TO ANCHOR BLOCK\n        $CALL  CPFKNXT             LOOK INTO NEXT BLOCK\n         BC    BOMIT,CFPRT14       RETURN IF THERE IS NO MORE\n        $IFON  FNQFLAG,FNQONE,CFPRT15   BRANCH IF ONE TIME PRINT\n         SPACE\n         LH    TEMP,PLCT           COUNT OF LINES LEFT ON PAGE\n         SR    TEMP,COUNT          LESS LENGTH+USER QUALIFICATION\n         BM    CFPRT16             BRANCH IF WON'T FIT\n         LH    R1,BMMRG            BOTTOM MARGIN\n         AH    R1,FNSEP            PLUS FOOTNOTE MARGIN\n         CR    TEMP,R1             BELOW BOTTOM MARGIN .Q\n         BL    CFPRT16             BRANCH IF WON'T FIT\n         B     CFPRT03             AND CONTINUE PRINTING\n         DROP  X2\n         SPACE\nCFPRT14  DS    0H\n         LA    TEMP,*+4            POINT TO FINAL RESULT\n        $CC    OMIT                NOTHING LEFT TO DO\n         B     CFPRT17             TAKE COMMON EXIT\nCFPRT15  DS    0H\n         LA    TEMP,*+4            POINT TO FINAL RESULT\n        $CC    POS                 IF BLOCK IS DONE\n         B     CFPRT17             TAKE COMMON EXIT\nCFPRT16  DS    0H\n         LA    TEMP,*+4            POINT TO FINAL RESULT\n        $CC    NEG                 IF FIRST BLOCK NOT DONE\n         B     CFPRT17             TAKE COMMON EXIT\n         SPACE\nCFPRT17  DS    0H\n         LTR   X3,X3               KEEP DATA FOR LATER .Q\n         BZ    CFPRT18             BRANCH IF NOT\n         ST    X3,CPFKFNA          RESTORE FIRST QUEUED LINE ADDR\n         DROP  X1\n         SPACE\nCFPRT18  DS    0H\n        $CALL  RMNEXT              REENABLE AUTO REMOTE IF PRESENT\n         EX    R0,0(,TEMP)         SET RETURN COND CODE\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nABCFP01  DS    0H                  NULL LINE SAVED FOR PRINT\nABCFP02  DS    0H                  NEGATIVE LINES LEFT IN KEEP\nABCFP03  DS    0H                  NULL TABLE OF CONTENTS RECORD\n        $LOGERR 1007               ERROR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#CR": {"ttr": 3082, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x001\\x001\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 49, "newlines": 49, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .CR (CONTROL WORD REPLACEMENT) --- CONTROL             *\n*                                                                     *\n***********************************************************************\n         SPACE\nCR      $ENTER ,\n        $CALL  GETARG              GET FIRST ARGUMENT\n         BC    BPOS,CR02           BRANCH IF ARG ONE PRESENT\n         LM    X1,X3,INDEXS        SET INDEXS FOR TABLE\nCR01     DS    0H\n         MVC   SPCTLW(2,X1),SPCTLI(X1)  WORKING EQUAL INITIAL\n         BXLE  X1,X2,CR01          RESET TILL DONE\n         B     CR10                AND RETURN\n         SPACE\nCR02     DS    0H\n         LM    X1,X3,INDEXS        SET INDEXS FOR LOOKUP\nCR03     DS    0H\n         CLC   SPCTLI(2,X1),0(COUNT)  IS THIS IT .Q\n         BE    CR04                BRANCH IF YES\n         BXLE  X1,X2,CR03          CHECK TILL DONE\n         MVI   EFLAG005,ERRSET     ERROR IF NOT FOUND\n         B     CR10                AND GO TO RETURN\n         SPACE\nCR04     DS    0H\n        $CALL  GETARG              GET SECOND ARGUMENT\n         LR    TEMP,X1             RESTORE POINTER TO FIRST IN TABLE\n         BC    BPOS,CR07           BRANCH IF ARG TWO PRESENT\n         LM    X1,X3,INDEXS        SET INDEXS FOR LOOKUP\nCR05     DS    0H\n         CLC   SPCTLW(2,X1),SPCTLI(TEMP)  WORKING VALUE EQUAL .Q\n         BNE   CR06                BRANCH IF NOT\n         MVC   SPCTLW(2,X1),SPCTLI(X1)  RESTORE TO ORIGINAL\nCR06     DS    0H\n         BXLE  X1,X2,CR05          CHECK THEM ALL\n         MVC   SPCTLW(2,TEMP),SPCTLI(TEMP)  RESTORE ARG1 ENTRY\n         B     CR10                AND RETURN\n         SPACE\nCR07     DS    0H\n         LM    X1,X3,INDEXS        SET INDEXS FOR LOOKUP\nCR08     DS    0H\n         CLC   SPCTLW(2,X1),0(COUNT)  WORKING VALUES EQUAL .Q\n         BNE   CR09                BRANCH IF NOT\n         MVC   SPCTLW(2,X1),BLANKS    REMOVE THAT WORKING ENTRY\nCR09     DS    0H\n         BXLE  X1,X2,CR08          GO TILL DONE\n         MVC   SPCTLW(2,TEMP),0(COUNT)  REDEFINE WORKING VALUE\nCR10     DS    0H\n        $EXIT  RC=0                AND RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#CS": {"ttr": 3084, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00]\\x00]\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 93, "newlines": 93, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .CS (CONDITIONAL SECTION) --- CONTROL                  *\n*                                                                     *\n***********************************************************************\n         SPACE\nCS      $ENTER ,\n        $CALL  GETYESNO            GET AND TEST FIRST ARGUMENT\n         BC    BOMIT,CSE003        ERROR IF OMITTED\n         BC    BPOS,CS01           BRANCH IF POSITIVE\n         BC    BNEG,CS02           BRANCH IF NEGATIVE\n         ST    COUNT,ARGSTART      RESCAN FOR NUMERIC\n        $CALL  GETNUM              GET FIRST NUMERIC ARGUMENT\n         BC    BDNO,CSE005         ERROR IF INVALID\n         LTR   COUNT,COUNT         ARGUMENT TOO SMALL .Q\n         BNP   CSE014              ERROR IF YES\n         LA    R1,L'CSTABLE        MAX VALUE +1\n         CR    COUNT,R1            TOO BIG .Q\n         BNL   CSE013              ERROR IF YES\n         L     X1,CSTABAD          .CS TABLE ADDRESS\n         AR    X1,COUNT            NTH INCLUDE ENTRY\n         B     CS03                GO TO CHECK\n         SPACE\nCS01     DS    0H\n         SR    COUNT,COUNT         DUMMY .CS 0 IGNORE/ON\n         L     X1,CSTABAD          .CS TABLE ADDRESS FOR ZERO\n         B     CS03                GO TO CHECK\nCS02     DS    0H\n         LNR   COUNT,COUNT         DUMMY .CS 0 INCLUDE/OFF\n         L     X1,CSTABAD          .CS TABLE ADDRESS FOR ZERO\n         SPACE\nCS03     DS    0H\n        $IFOFF SWITCHS,CSSWS,CS04  BRANCH IF NOT SKIPPING A SECTION\n         CLI   L'CSTABLE(X1),X'FF' THIS SECTION BEING IGNORED .Q\n         BNE   CS11                NO, GO AND RETURN\n         SPACE\nCS04     DS    0H\n         LTR   COUNT,COUNT         A .CS N COMMAND .Q\n         BP    CS06                BRANCH IF YES\n         BM    CS05                BRANCH IF .CS INCLUDE/OFF\n         SPACE\n         MVI   0(X1),X'FF'         SET TO IGNORE ZEROTH ENTRY\n         B     CS08                PROCESS 'ON'\n         SPACE\nCS05     DS    0H\n         MVI   0(X1),X'00'         SET TO INCLUDE ZEROTH ENTRY\n         B     CS09                PROCESS 'OFF'\n         SPACE\nCS06     DS    0H\n        $CALL  GETYESNO            TEST FOR 'ON' OR 'OFF'\n         BC    BOMIT,CSE003        ERROR IF OMITTED\n         BC    BPOS,CS08           BRANCH IF 'ON'\n         BC    BNEG,CS09           BRANCH IF 'OFF'\n         CLI   YNRESULT,YNIGN      WAS OPERAND 'IGNORE' .Q\n         BE    CS07                BRANCH IF YES\n         CLI   YNRESULT,YNINC      WAS OPERAND 'INCLUDE' .Q\n         BNE   CSE005              ERROR IF NOT\n         SPACE\n         MVI   0(X1),X'00'         SET TO INCLUDE NTH ENTRY\n         B     CS11                GO AND RETURN\n         SPACE\nCS07     DS    0H\n         MVI   0(X1),X'FF'         SET TO IGNORE NTH ENTRY\n         B     CS11                GO AND RETURN\n         SPACE\nCS08     DS    0H\n         MVC   L'CSTABLE(1,X1),0(X1)  CURRENT VAL IS INCLUDE VAL\n         B    CS10                 SET CS SWITCH APPROPRIATELY\n         SPACE\nCS09     DS    0H\n         MVI   L'CSTABLE(X1),X'00' RESET NTH CURRENTLY ON SWITCH\n         SPACE\nCS10     DS    0H\n        $OFF   SWITCHS,CSSWS       RESET GLOBAL CS SWITCH\n         L     X1,CSTABAD          RESET TABLE ADDRESS\n         OC    L'CSTABLE(L'CSTABLE,X1),L'CSTABLE(X1)  ALL TO INCLUDE .Q\n         BZ    CS11                RETURN NOW IF YES\n        $ON    SWITCHS,CSSWS       ONE CODE SET TO IGNORE\nCS11     DS    0H\n        $EXIT  RC=0                RETURN TO NEXT LINE\n         SPACE\nCSE003   DS    0H\n         MVI   EFLAG003,ERRSET     ARG OMITTED\n         B     CS11                AND GO TO RETURN\nCSE005   DS    0H\n         MVI   EFLAG005,ERRSET     SET ERROR FLAG\n         B     CS11                AND GO TO RETURN\nCSE013   DS    0H\n         MVI   EFLAG013,ERRSET     ARG TOO BIG FLAG\n         B     CS11                AND GO TO RETURN\nCSE014   DS    0H\n         MVI   EFLAG014,ERRSET     ARG TOO SMALL FLAG\n         B     CS11                AND GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#CW": {"ttr": 3087, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x18\\x00\\x18\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .CONTROL WORD SEPARATOR (.CW) --- CONTROL              *\n*                                                                     *\n***********************************************************************\n         SPACE\nCW      $ENTER ,\n         L     TEMP,CWTABAD        POINT TO CONTROL WORD SEPARATOR TAB\n         XC    0(256,TEMP),0(TEMP) ZERO THE LOT\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION\n        $CALL  GETARG              OBTAIN FIRST SOURCE CHAR\n         BC    BOMIT,CW01          BRANCH IF NO ARGUMENT\n         LTR   TEMP,TEMP           LENGTH-1 OF ARG IS ZERO .Q\n         BNZ   CWE005              ERROR IF NOT\n         L     TEMP,CWTABAD        POINT TO CONTROL WORD SEPARATOR TAB\n         SR    R1,R1               ZERO WORK REGISTER\n         IC    R1,0(,COUNT)        GET ARGUMENT CHAR\n         STC   R1,0(R1,TEMP)       INSERT INTO CORRECT SPOT IN TABLE\nCW01     DS    0H\n        $EXIT  RC=0                AND CONTINUE\n         SPACE\nCWE005   DS    0H\n         MVI   EFLAG005,ERRSET     BAD CHARACTER OPERAND\n         B     CW01                GO AND RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DA": {"ttr": 3089, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00-\\x00-\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .DA (DARK OUTPUT) --- CONTROL                          *\n*                                                                     *\n***********************************************************************\n         SPACE\nDA      $ENTER ,\n        $CALL  GETYESNO            GET AND TEST OPERAND\n         BC    BOMIT,DA03          BRANCH IF OMITTED\n         BC    BPOS,DA01           BRANCH IF AFFIRMATIVE\n         BC    BNEG,DA02           BRANCH IF NEGATIVE\n         ST    COUNT,ARGSTART      RESCAN FROM HERE FOR NUMERIC\n        $CALL  GETNUM              GET NUMBER\n         BC    BDNO,DAE005         ERROR IF INVALID\n         CLI   NUMSIGN,C' '        WAS OPERAND SIGNED .Q\n         BE    DA04                BRANCH IF NOT\n         AH    COUNT,DARKVAL       MAKE RELATIVE CHANGE\n         B     DA04                GO CHECK AND ENTER\nDA01     DS    0H\n         LA    COUNT,2             AFFIRMATIVE MEANS TWICE\n         B     DA04                GO TEST AND ENTER\nDA02     DS    0H\n         LA    COUNT,1             NEGATIVE MEANS BUT ONCE\n         B     DA04                GO TEST AND ENTER\nDA03     DS    0H\n         L     COUNT,DEFDARK+TAB3DEF    GET DEFAULT DARK VALUE\nDA04     DS    0H\n         C     COUNT,DEFDARK+TAB3MIN    LESS THAN MINIMUM .Q\n         BL    DAE014              ERROR IF YES\n         C     COUNT,DEFDARK+TAB3MAX    GREATER THAN MAXIMUM .Q\n         BH    DAE013              YES, ERROR\n         STH   COUNT,DARKVAL       SET DARK OUTPUT VALUE\n         SPACE\nDA05     DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\nDAE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     DA05                GO TO TERMINATE\nDAE013   DS    0H\n         MVI   EFLAG013,ERRSET     OPERAND TOO BIG\n         B     DA05                GO TO TERMINATE\nDAE014   DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     DA05                GO TO TERMINATE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DC": {"ttr": 3091, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .DC (DON'T COUNT) --- CONTROL                          *\n*                                                                     *\n***********************************************************************\n         SPACE\nDC      $ENTER ,\n        $CALL  PRINTNB             ISSUE BREAK\n        $ON    SWITCHS,FNOCT       SET \"DON'T COUNT\" FLAG\n         LA    R15,WRETDC          DON'T COUNT RETURN CODE\n        $EXIT  RC=(R15)            SKIP FLAG CLEAR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#DCOMPOZ": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00:\\x00:\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 58, "newlines": 58, "modlines": 0, "user": "CBT249"}, "text": "DCOMPOZ $ENTER ,\n         SPACE\n*        ON ENTRY --  NUMCHR      IS LENGTH OF INPUT WORD\n*                     HYWKWORD    IS INPUT STRING\n*\n*        ON EXIT  --  HYDCWORD    FIRST TO 13TH DECOMPOSED WORD\n*                     HYWKWORD    2ND TO 13TH DECOMPOSED/PACKED WORD\n*                     (R1)        FIRST CHARACTER OF WORD\n         SPACE\n         MVI   HYDCWORD,L'HYALPHA  INTERNAL BLANK TO TARGET\n         MVC   HYDCWORD+1(L'HYDCWORD-1),HYDCWORD  ALL OF IT\n         LH    COUNT,NUMCHR        GET LENGTH-1 OF INPUT STRING\n         EX    COUNT,HYDCMVC       MOVE WORD TO DECOMP AREA\n         LA    X2,1                SET INCREMENT\n         LA    X1,HYDCWORD         SET INDEX TO START OF DECOMP AREA\nHYDC01   DS    0H\n         C     COUNT,F12           TEST LENGTH OF WORD\n         BNH   HYDC04              EXIT IF UNDER 12 CHARS\n         ST    COUNT,HYLENWRD      SAVE PRESENT LENGTH\n         LA    X3,0(COUNT,X1)      ADDR OF LAST CHARACTER\n         LR    COUNT,X1            ADDR OF LAST DECOMP CHAR STORED\n         AR    X1,X2               BUMP TO NEXT TEST CHAR\n         IC    R1,HYDCWORD         FIRST CHAR OF WORD\nHYDC02   DS    0H\n         EX    R1,HYDCCLI          COMPARE CHAR+1 TO CHAR\n         IC    R1,0(,X1)           GET NEXT CHAR\n         BNH   HYDC03              BRANCH IF CHAR+1 NOT HIGHER FREQ\n         AR    COUNT,X2            BUMP ADDR OF LAST DECOMP CHAR\n         STC   R1,0(,COUNT)        KEEP CHAR+1 IN DECOMP WORD\nHYDC03   DS    0H\n         BXLE  X1,X2,HYDC02        BUMP TO NEXT CHAR\n         LA    X1,HYDCWORD         START OF DECOMP AREA\n         SR    COUNT,X1            GET NUM CHAR IN DECOMP WORD\n         C     COUNT,HYLENWRD      ANY CHARACTERS DELETED .Q\n         BE    HYDC04              GO TRUNCATE WORD IF NOT\n         B     HYDC01              GO TRY AGAIN\n         SPACE\nHYDC04   DS    0H\n         LA    COUNT,L'HYWORD*8/5  MAX CHAR STORED\n         LA    X1,HYDCWORD+1       RESULTING WORD\n         SR    R0,R0               INITIALIZE TARGET\n         LR    R1,R0               BOTH HALVES\n         SR    TEMP,TEMP           CLEAR CHARACTER WORK REGISTER\nHYDC05   DS    0H\n         IC    TEMP,0(,X1)         CHARACTER\n         SLDL  R0,5                MAKE ROOM\n         OR    R1,TEMP             ADD NEXT CHARACTER\n         LA    X1,1(,X1)           NEXT CHARACTER\n         BCT   COUNT,HYDC05        DO ALL CHARACTERS\n         STM   R0,R1,DECM          ALIGN RESULT\n         MVC   HYWKWORD(8),DECM    RETURN RESULT TO CALLER\n         SPACE\n         SR    R1,R1               ZERO RETURN REGISTER\n         IC    R1,HYDCWORD         INTERNAL FIRST CHARACTER\n        $EXIT  KEEP=(R1),RC=0      RESTORE AND RETURN TO CALLER\n         SPACE\nHYDCCLI  CLI   0(X1),*-*           COMPARE CHAR TO CHAR+1\nHYDCMVC  MVC   HYDCWORD(*-*),HYWKWORD   EXECUTED MOVE INPUT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DDBLOCK": {"ttr": 3331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00'\\x00'\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "CBT249"}, "text": "*                                                                     *\n*  ONE DDBLOCK IS ALLOCATED FOR EACH CURRENTLY OPEN DCB               *\n*  (IE. ESSENTIALLY FOR EACH DD STATEMENT WHICH IS CURRENTLY          *\n*  IN USE AS DEFINING AN INPUT FILE.)                                 *\n*                                                                     *\n*  SEVERAL DDBLOCKS CAN BE SIMULTANEOUSLY OPEN                        *\n*  FOR THE SAME DD STATEMENT ONLY IF THE DD STATEMENT                 *\n*  REFERS TO A SEQUENTIAL DATA SET, AND HAS NOT HAS THE               *\n*  NOCLOSE OPTION SELECTED                                            *\n*                                                                     *\n*  (NOTE THAT A DD STATEMENT WHICH REFERS TO A PARTICULAR MEMBER      *\n*  OF A PARTITIONED DATA SET IS TREATED AS REFERRING TO A             *\n*  SEQUENTIAL DATA SET.....AND THAT DSORG=PS IS FORCED IN THE DCB)    *\n*                                                                     *\n         SPACE 2\nDDBLOCK  DSECT\nDDNEXT   DS    A                   POINTER TO NEXT DDBLOCK (OR 0)\nDDPREV   DS    A                   POINTER TO PREVIOUS DDBLOCK (OR 0)\nDDDDNAM  DS    CL8                 ACTUAL DDNAME BLOCK OPENED ON\nDDLDDNAM DS    CL8                 LOGICAL DDNAME (BEFORE SUBSTITUTION)\nDDUSECT  DS    H                   USAGE COUNT (NUMBER OF FILES BEING\n*                                       READ FROM THIS DCB)\nDDFLAG   DS    X                   FIRST FLAG BYTE\n         SPACE\nDD$NOCLO EQU   X'80'               THIS DDBLOCK IS NEVER TO BE CLOSED\nDD$RM    EQU   X'40'               THIS DDBLOCK REPRESENTS A REMOTE\nDD$EOF   EQU   X'40'               EOF OR READ ERROR ENCOUNTERED\nDD$REISS EQU   X'20'               REISSUE READ DUE TO CONCATENATION\nDD$RECFM EQU   X'10'               DATA SET NOT V, F OR SQUISHED FORMAT\n         SPACE\nDDFLAG2  DS    X                   SECOND FLAG BYTE\n         SPACE\n         PUSH  PRINT\n         PRINT NOGEN\nDDDCB    DCB   DDNAME=ANYNAME,DEVD=DA,MACRF=RP,DSORG=PS,               X\n               EODAD=*-*,SYNAD=*-*,EXLST=*-*\n         POP   PRINT\n         SPACE\nDDBLKLN  EQU   (((*-DDBLOCK)+7)/8)*8\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DEUDATA": {"ttr": 3333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x9c\\x00\\x9c\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 156, "newlines": 156, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        LOCAL DATA AND CONSTANT AREA FOR SCRIPTHY                    *\n*                                                                     *\n***********************************************************************\n         SPACE\nSCRIPTHY CSECT ,\n         SPACE\nHYALPHA  DC    C'ETAONRISHDLFCMUGYPWBVKXJQZ',C' '  INTERNAL CHAR ORDER\nHYANCH   DC    (L'HYALPHA)A(0)     HYPHEN EXCEPTION WORD ANCHORS\nHYPRATAD DC    A(HYPRATAB)         ADDR PRATT FREQUENCY TABLE\nHYPLAST  DC    F'0'                LAST HYPHEN POSITION\nHYLENWRD DC    F'0'                LENGTH OF WORD WORK\nHYMAXSYL DC    F'14'               MAXIMUM SYLLABLE LENGTH\nHYMAXWRD DC    F'35'               MAXIMUM INPUT WORD LENGTH\n         SPACE\nHYDCWORD DC    CL40' '             WORD DECOMPOSITION AREA\nHYPRWORD DC    AL2(L'HYWKWORD+5,0),C'*'      RDW/CC TO DUMP WORDS\nHYWKWORD DC    CL40' '             STRIPPED HYPHEN WORD WORK\nHYPIND   DC    XL9'00'             HYPHEN BREAK POINTS WORK AREA\nHYALPHSW DC    X'00'               WORD SCANNING SWITCH\n         SPACE\n         DC    0D'0'               FOR ALIGNMENT OF TABLE\nHYPRATAB DC    0XL256'00'          PRATT FREQUENCY TABLE OF LETTERS\n         DC    64X'21'                  INVALID LETTER CODES\n         DC    X'20'                    BLANK\n         DC    31X'21'                  INVALID LETTER CODES\n         DC    X'1C'                    HYPHEN\n         DC    27X'21'                  INVALID LETTER CODES\n         DC    X'21'                    FORMER HYPHEN-T\n         DC    4X'21'                   INVALID LETTER CODES\n         DC    X'02130C09000B0F0806'    A,B,C,D,E,F,G,H,I  LOWER CASE\n         DC    7X'21'                   INVALID LETTER CODES\n         DC    X'17150A0D0403111805'    J,K,L,M,N,O,P,Q,R  LOWER CASE\n         DC    8X'21'                   INVALID LETTER CODES\n         DC    X'07010E1412161019'      S,T,U,V,W,X,Y,Z    LOWER CASE\n         DC    23X'21'                  INVALID LETTER CODES\n         DC    X'02130C09000B0F0806'    A,B,C,D,E,F,G,H,I\n         DC    7X'21'                   INVALID LETTER CODES\n         DC    X'17150A0D0403111805'    J,K,L,M,N,O,P,Q,R\n         DC    8X'21'                   INVALID LETTER CODES\n         DC    X'07010E1412161019'      S,T,U,V,W,X,Y,Z\n         DC    22X'21'                  INVALID LETTER CODES\n         EJECT\n***********************************************************************\n*                                                                     *\n*              REGISTER DEFINITIONS                                   *\n*                                                                     *\n***********************************************************************\n         SPACE\nREGWK0   EQU   0\nREG1     EQU   1\nREG2     EQU   2\nWORDREG  EQU   3\nREGNCR   EQU   4     USED TO INCREMENT REGIX1 TO THE LIMIT IN REGLMT\nREGLMT   EQU   5                       SEE REGNCR\nREGIX1   EQU   6                       SEE REGNCR\nREGWK3   EQU   7\nREGWK2   EQU   8\nREGWK1   EQU   9\nREGRET   EQU   14                      CONTAINS SUBROUTINE RETURN ADDR\nREGLNK   EQU   15    CONTAINS SUBROUTINE ADDR - POSS BASE REGISTER\n*\n*\nGSTATUS  DS    CL63\nASFXTAB  DC    A(SFXTAB)\nASFXTBLS DC    A(SFXTBLS)\nAYNMTRX  DC    A(YNMTRX)           YES/NO MATRIX TABLES\n         SPACE\nBINZERO  DC    F'0'\nBIN4     DC    F'4'\nBIN10    DC    F'10'\nBIN14    DC    F'14'\nBIN26    DC    F'26'\n         SPACE\nBINHEX   DC    X'000102030405060708090A0B0C0D0EF0'  CHAR TO HEX CONV\n         SPACE\nSAVEODD  DS    F\nPREVDCM  DS    H         LENGTH OF WORD AFTER PREVIOUS DECOMPOSITION\nPREVROOT DS    H\nNUMFIT   DS    H\nHYFCOM   DC    CL40' '\nASTATUS  DC    CL40' '\nNUMCHR   DS    H\nFIRSTVOW DS    H\nLASTVOW  DS    H\nINDBYTE  DS    CL1\nPOSSFLD  EQU   INDBYTE\nYESFLD   EQU   INDBYTE\nSFXSYL   DS    CL8\n         DC    X'FF'\nLSTCHR   DS    CL1\nLSTCHROF DC    H'0'                LAST CHAR OFFSET FOR LAST FIT\nATEOW    DC    F'0'\nBGWDSG   DC    F'0'\nHFLDAD   DC    F'0'                  ADDRESS OF HYPFIELD INC. LTF IND.\nMRGCNT   DC    H'0'\nSCNDSW   DC    X'00'\nHYFSW    DC    X'00'\nVOWTBL   DC    X'0102010102020102'      01 = VOWEL\n*                 E T A O N R I S       02 = CONSONANT\n         DC    X'0202020202020102'      03 = Y INDIC.\n*                 H D L F C M U G       00 = NON-ALPHA\n         DC    X'0302020202020202'\n*                 Y P W B V K X J\n         DC    X'0202000000000000'\n*                 Q Z*NON-ALPHA**\n*\n         SPACE 3\n*****                                                             *****\n*              SCAN LEFT FROM L-T-F FOR YES POINT BEFORE POSSIBLE     *\n*****                                                             *****\nSCNLFT   TM    NUMFIT+1,X'FF'\n         BZ    RTRNLFT\n         LH    REG1,NUMFIT\n         LA    REG1,ASTATUS(REG1)   * REQUIRING SUFFIX ANALYSIS\n         LA    REGWK1,ASTATUS      PLUS REG.FOR TEST OF BEGIN.OF WORD\nSCNLFT1  TM    0(REG1),X'30'       TEST STATUS\n         BO    FNDOUT              IF YES POINT EXIT\n         BM    RTRNLFT             IF POSS. POINT GO TO SUFFIX ANALYSIS\nBYPOSS   CR    REG1,REGWK1         HAS BEGINNING OF WORD BEEN REACHED\n         BNH   FNDOUT               IF YES GO TO FOUND ROUTINE\n         BCT   REG1,SCNLFT1        ELSE DECREMENT TO NEXT POINT TO LEFT\n         B     SCNLFT1              AND CONTINUE TESTING\nFNDOUT   DS    0H\n        $CC    POS                 INDICATE FOUND\n         B     SCNRET              GO TO RETURN\nRTRNLFT  DS    0H\n        $CC    NEG                 SET FOR SUFFIX ANALYSIS\nSCNRET   DS    0H\n         BR    REGRET              RETURN TO CALLER\n         SPACE\n*****          REVERSE NEGATE - SET POINTS RIGHT TO LEFT\n*              TO NO TILL VOWEL ENCOUNTERED\nNEGREV   LA    REGWK3,ASTATUS(REGWK3)   GENERATE ADDR FOR STATUS BYTE\nREVTST   TM    0(REGWK3),X'01'          TEST CHAR FOR VOWEL\n         BZ    STNREV                   AND BRANCH IF NOT\nEXIT     LA    REG1,ASTATUS             TERMINATE FORWORD OR REVERSE\n         SR    REGWK3,REG1               SCAN AND SET REGWK3 FOR REL.\n        $CC    POS                 SET RETURN COND CODE\n         BR    REGRET                    ADDRESS\nSTNREV   BCT   REGWK3,SET               ON NEGREV - SET TO PRECEEDING\n        $CC    NEG                 SET RETURN COND CODE\n         BR    REGRET\nSET      TM    0(REGWK3),X'B0'     TEST FOR YES POINT SET BY SUFFIX\n         BO    REVTST                   & BYPASS IF YES\n         NI    0(REGWK3),X'CF'          ELSE SET TO NO\n         B     REVTST                     THEN RETURN FOR TEST\n*****          FORWARD NEGATE - SET POINTS LEFT TO RIGHT\n*              TO NO TILL VOWEL ENCOUNTERED\nNEGFWD   LA    REGWK3,ASTATUS+1(REGWK3) GENERATE ADDRESS FOR STATUS\nFWDTST   TM    0(REGWK3),X'01'           BYTE & TEST FOR VOWEL\n         BO    EXIT                     BRANCH IF YES\n         NI    0(REGWK3),X'CF'           ELSE SET TO NO\n         LA    REGWK3,1(REGWK3)          & INCREMENT TO NEXT CHAR.\n         B     FWDTST\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DEUH01": {"ttr": 3337, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00*\\x00*\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "CBT249"}, "text": "*                             ********\n* *            SOURCE BOOK *** DEUH01 *** USER ENTRY TO H/360\n*                             ********\n         SPACE 3\n*        ON ENTRY  --  (R1) -> ONE BYTE LAST FIT LENGTH FOLLOWED\n*                              BY UP TO 64 EBCDIC CHARACTERS.\n*        ON EXIT   --  (R15) < 0  IF ERROR\n*                            > 0  PTR TO GSTATUS TABLE\n         SPACE\nHYPHEN  $ENTER ,                   MAIN AUTO HYPHENATION ENTRY POINT\n*        WAS   DEUHYA01\n         SPACE\n* USING REGISTER 1 AS PARAMETER LIST POINTER  ESTABLISH ADDRESSES\n* OF USERS WORD AND NO-HYPHEN REJECT  ROUTINE\n         SPACE\n         L     BASE,VSCRICVT       COMMUNICATION VECTOR TABLE\n         L     BASE,VHYSCRIP-SCRICVT(,BASE)  LOCAL DATA BASE\n         SPACE\n         ST    REG1,HFLDAD         HFLDAD  USER WORD (L-T-F BYTE)\n         L     REG3,HYPRATAD       INTERNAL CHARACTER TRANS TABLE\n         TR    1(64,REG1),0(REG3)  TRANSLATE INPUT TO INTERNAL\n         LA    REG3,1(,REG1)       REG3  ADDRESS OF 1ST CHAR IN WORD\n         LA    REG1,GSTATUS         GET ADDRESS OF HYPHEN INFORMATION\n         SPACE\n* EXECUTE SEARCH FOR TERMINAL CHARACTER , REJECT CHAR. & COUNT OF HYPFL\n         TRT   0(64,REG3),ITESTBL  ITESTBL EQUATED TO GSTATUS\n         BC    8,HREJ\n         TM    0(REG1),X'21'      TEST FOR VALID EOW TERMINATION\n         BO    HREJ                BRANCH IF REJECT CHARACTER\n         CLI   0(REG1),X'20'       TEST FOR VALID EOW CHARACTER\n         BNE   HREJ                 & BRANCH IF NOT\n* DEVELOP COUNT OF CHARACTERS IN HYPFIELD AT EOW\nHYPINP2  LR    REG5,REG1           ADDRESS OF EOW\n         SR    REG5,REG3            MINUS START OF HYPFIELD\n         STH   REG5,HYFLDCCT       SAVE CHARACTER COUNT\n         XC    ASTATUS,ASTATUS     CLEAR ASTATUS\n         XC    GSTATUS,GSTATUS     AND CLEAR GSTATUS\n         EX    REG5,SGSTS          THEN MOVE VALID CHARS.TO GSTATUS\n         EX    REG5,TGSTS           FOR TRANSLATE TO VOWEL,CONSON.ETC\n         B     NASCN               GO TO NON ALPHA SCAN\n* AT THIS STAGE GSTATUS SHOULD REFLECT THE CHARACTERISTICS OF HYPFIELD\n* RELATING TO 1-NON-ALPHA,2-VOWEL,3-CONSONANT,4-'Y'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DEUH02": {"ttr": 3339, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00N\\x00N\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 78, "newlines": 78, "modlines": 0, "user": "CBT249"}, "text": "*                             ********\n* *            SOURCE BOOK *** DEUH02 *** RETURN ROUTINES          1-1\n*                             ********\n         SPACE 3\n*****                                                             *****\n*                         REJECTED WORD ROUTINE                       *\n*****                                                             *****\nHREJ     MVI   GSTATUS,X'00'       CLEAR ALL HYPHEN INDICATORS\n         MVC   GSTATUS+1(L'GSTATUS-1),GSTATUS\n         LA    REGLNK,GSTATUS      THIS IS WHERE NO DATA LIES\n         LNR   REGLNK,REGLNK       INDICATE ROUTINE GONE WRONG\n         B     HYPRETRN            AND GO TO FINAL RETURN\n         SPACE\n*****                                                             *****\n*                            SUCCESSFUL WORD ROUTINE                  *\n*****                                                             *****\nHYPEXIT  DS    0H\n         LA    REGLNK,GSTATUS      SUCCESSFUL RETURN DATA HERE\nHYPRETRN DS    0H\n        $EXIT  RC=(R15)            AND RETURN TO OUR CALLER\n         SPACE\n*****                                                             *****\n*                         LAST TO FIT & ALL POINTS RETURN             *\n*****                                                             *****\nLTFRETR  L     REGWK2,ALTF         INIT.SCAN AT L-T-F CHAR\n         B     RTNSCN\nHRETRN   L     REGWK2,AEOW         INIT.SCAN AT END OF WORD\nRTNSCN   S     REGWK2,HFLDAD       GENERATE RELATIVE ADDRESS\n         LA    REGWK1,GSTATUS      GET ADDRESS OF GSTATUS\n         LA    REG1,1                AND\n         SR    REGWK1,REG1               BACK UP ONE POSITION\n         AR    REGWK1,REGWK2        COMBINE REL.& ACTUAL FOR SCAN START\nRTNSCN1  TM    0(REGWK1),X'30'     TEST FOR YES HYPHEN IN STATUS AREA\n         BO    HITHYP               & BRANCH WHEN HYPHEN FOUND\n         BCT   REGWK1,*+4          SCAN TO LEFT FOR HYPHEN\n         BCT   REGWK2,RTNSCN1       DECREMENT COUNT FOR CHARACTER\n         B     HREJ                 REJECT IF NO YES POINTS FOUND\nHITHYP   LA    REG1,0\n         C     REG1,ALTF           TEST FOR L-T-F REQ'D.\n         BE    HRETRN1              IF NOT BRANCH\n         MVC   RESTORE+1(1),0(REGWK1)   SAVE YES HYPHEN INDICATION\nRTNSCN2  MVI   GSTATUS,X'00'                  CLEAR ALL INDICATORS\n         MVC   GSTATUS+1(L'GSTATUS-1),GSTATUS  *\nRESTORE  OI    0(REGWK1),X'30'          RESTORE YES HYPHEN INDICATOR\nHRETRN1  B     HYPEXIT              GO TO FINAL EXIT\nNOPOS    TM    SCNDSW,X'80'   TEST FOR YES FIELDS & IF YES GO TO FOUND\n         BO    FOUND               ELSE FALL THRU TO NOHYP\nNOHYP    L     REG3,ATEOW               TEST FOR TYPE OF EOW\n         LTR   REG3,REG3                 & IF NOT TEOW\n         BZ    HRETRN                   GOTO RETURN\n         LA    REGWK3,0            ELSE INIT. HYFCOM POINTER\n         LA    REGWK0,30           *RESET TO LIMIT OF WORD SEGMENT\n         L     REG4,HFLDAD         *RESET COUNT OF CHARS.REMAINING\n         LA    REG4,64(REG4)       *\n         S     REG4,ATEOW          *\n         L     REG3,ATEOW          RESET TO GET NEXT WORD SEGMENT\n         STH   REGWK3,SCNDSW       RESET NON-ALPHA & ALPHA SCAN SWTCHS\n         ST    REGWK3,ATEOW             RESET TEOW ADDRESS\n         STH   REGWK3,MRGCNT\n         B     NULL                 SWITCHES & RETURN\nFOUND    DS    0H\n         L     REGWK1,BGWDSG      START MERGE OF CHAR.STATUS BYTES FROM\n         LA    REGWK2,ASTATUS  ASTATUS BACK TO GSTATUS\n         LH    REGWK3,MRGCNT  SET FOR CONTROL OF MERGE LOOP\nMRGA2G   TM    0(REGWK1),X'03' TEST GSTATUS FOR ALPHA / NON-ALPHA\n         BZ    IGSTAT           IF NOT ALPHA MOVE TO NEXT STATUS BYTE\n         MVC   0(1,REGWK1),0(REGWK2) MOVE STATUS BYTE FROM ASTATUS\n         LA    REGWK2,1(REGWK2)       TO GSTATUS & ACCESS NEXT ASTATUS\n         BCT   REGWK3,IGSTAT           BYTE  & DECREMENT CHAR.COUNT\n*                                  FALL THROUGH AT END OF TRANSFER\n         L     REGWK2,HFLDAD        & TEST FOR L-T-F MODE\n         TM    0(REGWK2),X'FF'\n         BM    LTFRETR             IF L-T-F MODE GO TO L-T-F RETURN\n         LH    REGWK2,LSTCHROF     GET LENGTH OF INPUT\n         B     NOHYP               ELSE TO NOHYP FOR EOW TEST\nIGSTAT   LA    REGWK1,1(REGWK1)    BUMP TO NEXT GSTATUS BYTE\n         B     MRGA2G               & CONTINUE MERGE OF ASTATUS TO\n*                                      GSTATUS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DEUH03": {"ttr": 3342, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00n\\x00n\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 110, "newlines": 110, "modlines": 0, "user": "CBT249"}, "text": "*                             ********\n* *            SOURCE BOOK *** DEUH03 *** NON-ALPHA ANALYSIS       1-1\n*                             ********\n         SPACE 3\n*\n* NON-ALPHA SCAN BEGINS BY SEARCHING HYPFIELD FOR VARIOUS CHARACTERS\n* AND BRANCHING TO PROPER SUBROUTINES\nNASCN    L     REG3,HFLDAD        ESTABLISH REG3 AS POINTER TO HYPFIELD\n         LA    REG1,0              ZERO IN REG1 TO CLEAR SWITCHES\n         ST    REG1,ATEOW             TEMP. EOW ADDRESS\n         STH   REG1,SCNDSW  &HYFSW   NON-ALPHA & ALPHA SCAN INDICATORS\n         IC    REG1,0(REG3)        GET VALUE IN LTF BYTE\n         LTR   REG1,REG1           TEST FOR L-T-F OR ALL POINTS\n         BZ    NOLTF               BRANCH IF  ALL POINTS\n         AR    REG1,REG3            ADD TO ADDRESS OF USERS WORD AREA\nNOLTF    ST    REG1,ALTF           STORE ZERO AS ADDRESS OF L-T-F CHAR\n*                            OR SAVE ACTUAL ADDRESS OF L-T-F CHAR.\n         LA    REG3,1(REG3)\n         LA    REGWK2,0            INITIALIZE GSTATUS POINTER\n         STH   REGWK2,NUMFIT       CLEAR ASCAN CONTROL COUNTERS\n         STH   REGWK2,NUMCHR       *\n         STH   REGWK2,LSTCHROF     SET LENGTH-1 OF INPUT\n         LA    REGWK0,30           INITIALIZE TO LIMIT OF WORD SEGMENT\n         LA    REGWK3,0\n         LA    REG4,64           INITIALIZE FOR FULL SEARCH OF HYPFIELD\nNXTCHR   LA    REG2,0              CLEAR REG2\n         EX    REG4,NASC          DO TRT FOR INDIVIDUAL CHARACTER TEST\n         CH    REG2,=H'8'           INVALID CHARACTER CONFIGURATION\n         BH    HREJ                  REJECT THE WORD\n         C     REG3,ALTF           TEST FOR LAST TO FIT CHAR.\n         BE    MKLTF                & IF YES MARK L-T-F\nRENAS    SLL   REG2,24             ISOLATE TABLE FUNCTION\n         SRL   REG2,22             AND MULT.BY 4 FOR PROPER BRANCH EXIT\n         B     NAEXT(REG2)        EXECUTE LINKAGE TO PROPER EXIT\nNAEXT    B     HREJ               ** DUMMY BRANCH FOR IMPOSSIBLE CHAR.\n         B     ALPH               *  THIS SERIES OF BRANCHES\n         B     NUMB               *   CONSTITUTES THE LINKAGE TO\n         B     CMMA               *** EACH SPECIALIZED ROUTINE\n         B     HYPN               *   CONNECTED WITH THE NON-ALPHA\n         B     SHFT               *   SCAN (IE. ALPHA,COMMA,ETC.)\n         B     APOS               *\n         B     EOWC\n         B     NULL\nMKLTF    STH   REGWK3,NUMFIT       SAVE NUMBER OF CHAR. TO FIT\n         B     RENAS               RESUME NON ALPHA SCAN\nREJWDSG  NI    HYFSW,B'11111100'   CLEAR ALPHA + NUMBER\nREJWDSG1 LA    REG3,1(REG3)        GET NEXT PRIMARY CHARACTER\n         LA    REGWK2,1(REGWK2)     AND NEXT STATUS BYTE\n         CLI   0(REG3),X'1C'       IS CHAR A TEXT HYPHEN\n         BE    HYPN                IF YES GO TO HYPN TO END SEGMENT\n         CLI   0(REG3),X'20'       IS CHAR AN EOW\n         BE    EOWC                YES GO TO E-O-W CHAR. ROUTINE\n         B     REJWDSG1            IF NO GET NEXT PRIMARY CHARACTER\n*\n* TEMPORARY END OF WORD PROCESSOR\n*\nTEOW     L     REG1,HFLDAD\n         CLI   0(REG1),X'00'       TEST L-T-F REQD.\n         BNE   TLTFMK              IF YES GO TEST L-T-F MARKED\n         ST    REG3,ATEOW          SAVE ADDR OF TEOW CHAR.\n         TM    HYFSW,X'02'              TEST FOR ALPHA CHAR. IN WORD\n         BO    STRCNTS              & CONTINUE ALPHA PROCESSING IF YES\nBYSGMT   NI    HYFSW,X'00'         ELSE SET UP TO BYPASS WORD SEGMENT\n         LA    REGWK3,0            *\n         B     NULL                *RETURN FOR NEXT CHARACTER\nTLTFMK   LH    REG1,NUMFIT         IF L-T-F REQ'D.\n         LTR   REG1,REG1           *  TEST FOR L-T-F MARKED\n         BH    EOWC+4                & TREAT CHAR. AS FINAL EOW IF YES\n         B     BYSGMT              ELSE BYPASS WORD SEGMENT\n         EJECT\n* THIS ROUTINE TESTSCND IS DESIGNED TO INTERROGATE A CHARACTER OR\n*  SERIES OF CHARACTERS IN CONTIGUOUS BYTES TO DETERMINE SIGNIFICANT\n*  CHARACTERISTICS OF THE CHARACTER(S) AND RELAY THAT INFORMATION TO\n*  THE CALLING ROUTINE IN THE FORM OF CERTAIN SWITCH SETTINGS.\n* THE ROUTINE ASSUMES THAT REGISTER 3 CONTAINS THE ADDRESS OF A PRIMARY\n*  CHARACTER (CHAR. PRECEEDING CHAR.(S) OF INTEREST AND THAT THE CODES\n*  USED TO REPRESENT THE CHARACTERS ARE THE PRATT CODES USED THROUGHOUT\n*  THE HYPHENATION 360 PROGRAM.\nTESTSCND LA    WREG,1(REG3)        INITIALIZE FOR SECONDARY SCAN\nLOOP     CLI   0(WREG),X'19'       TEST SECONDARY FOR ALPHA/NON-ALPHA\n         BH    NASCR               BRANCH FOR NON-ALPHA SECONDARY CHAR.\n         OI    SCNDSW,X'02'        TURN ON SECONDARY ALPHA INDICATOR\n         BR    REGRET               AND RETURN TO PRIMARY ROUTINE\nNASCR    CLI   0(WREG),X'1A'       TEST SECONDARY CHAR. FOR NUMERIC\n         BH    NNSCR                BRANCH FOR NON-NUMERIC SECONDARY\n         OI    SCNDSW,X'01'        TURN ON SECONDARY NUMERIC INDICATOR\n         BR    REGRET               AND RETURN TO PRIMARY ROUTINE\nNNSCR    CLI   0(WREG),X'1D'       TEST SECONDARY CHAR FOR SHIFT CODE\n         BE    BYSCND               AND BYPASS TO NEXT CHARACTER\n         CLI   0(WREG),X'1F'       TEST SECONDARY CHAR. FOR NULL\n         BNE   CLRSC                AND BRANCH TO CLEAR SCNDSW IF NOT\n* THE FOLLOWING PERMITS THE BYPASSING OF SHIFT & NULL SECONDARIES\nBYSCND   LA    WREG,1(WREG)        BUMP WORK INDEX TO NEXT HYPFIELD\n         B     LOOP                 CHAR. & CONTINUE SECONDARY SCAN\nCLRSC    NI    SCNDSW,X'FC'        CLEAR SECONDARY ALPHA/NUMERIC IND.\n         BR    REGRET               AND RETURN TO PRIMARY ROUTINE\nALTF     DC    F'0'                ADDR.OF ACTUAL L-T-F CHARACTER\nAEOW     DC    F'0'\nLSIG     DC    F'0'\nRJCTAD   DC    F'0'                  ADDRESS OF REJECT RETURN\nHYFLDCCT DC    H'0'                  COUNT OF HYPFIELD NUM.OF CHARS.\nSGSTS    MVC   GSTATUS(0),0(REG3)\nTGSTS    TR    GSTATUS(0),VOWTBL     TRANS.TO SET INDICATORS\nNASC     TRT   0(0,REG3),NASCTBL     FOR NON-ALPHA SCAN SEARCH\nITESTBL  DC    32X'00'\n         DC    X'2021'\nNASCTBL  DC    26X'01'             ** NON-ALPHA TABLE FOR LINKAGE ALPHA\n         DC    X'02'                * TO ANALYSIS ROUTINES        NUMBR\n         DC    X'030405060807'    **SPECIAL FROM COMMA TO EOW\n         LTORG\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DEUH04": {"ttr": 3345, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "CBT249"}, "text": "*                             ********\n* *            SOURCE BOOK *** DEUH04 *** ALPHA CHARACTER PROCESSOR\n*                             ********                             1-1\n         SPACE 3\n*****  NON ALPHA SCAN CHARACTER PROCESSING ROUTINES\nALPH     TM    HYFSW,X'01'         TEST FOR PRIOR NUMBERS\n         BO    REJWDSG             REJECT MIXED ALPHA-NUMERIC\n         LA    REG1,GSTATUS(REGWK2) DEVELOP ACTUAL STATUS BYTE ADDRESS\n         TM    HYFSW,X'06'         TEST FOR FIRST SIGNIF.ALPHA CHAR.\n         BO    BYFST                & BRANCH IF THIS IS NOT 1ST\n         ST    REG1,BGWDSG         SAVE ADDR. OF BEGINNING OF WORD\nBYFST    BAL   REGRET,TESTSCND\n         TM    SCNDSW,X'02'        TEST FOR ALPHA SECONDARY CHARACTER\n         BZ    BYPOS                IF NOT-BYPASS SETTING POSS.INDIC.\n         OI    0(REG1),X'10'       ELSE SET STATUS TO REFLECT POS.HYFN\nBYPOS    OI    HYFSW,X'06'         INDICATE SIGNIF.ALPHA CHARACTER\n         ST    REG1,LSIG           SAVE ADDR. OF LAST SIGNIF CHAR.\n         LA    REGWK1,ASTATUS(REGWK3)\n         MVC   0(1,REGWK1),0(REG1)      MOVE GSTATUS BYTE TO ASTATUS\n         LA    REGWK1,HYFCOM(REGWK3)\n         MVC   0(1,REGWK1),0(REG3)      MOVE CHARACTER TO HYFCOM\n         LA    REGWK3,1(REGWK3)    INCREMENT HYFCOM/ASTATUS POINTER\n         BCT   REGWK0,NULL         IF WORD SEGMENT UNDER LIMIT, GO GET\n         B     HREJ                 NEXT CHAR. ELSE, REJECT THE WORD\n* END OF ROUTINE ALPH FIR NON-ALPHA PROCESSING OF CHARS.\n         SPACE 6\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DEUH05": {"ttr": 3347, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\t\\x00\\t\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "CBT249"}, "text": "*                             ********\n* *            SOURCE BOOK *** DEUH05 *** NUMBER CHARACTER\n*                             ********\n         SPACE 3\nNUMB     TM    HYFSW,B'00000010'   ANY ALPHA CHARS PREVIOUSLY\n         BO    REJWDSG             IF YES GO TO REJWDSG\n         OI    HYFSW,B'00000101'   ELSE RECORD CHAR AS SIGNIF+NUMBER\n         B     NULL\n         SPACE 6\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DEUH06": {"ttr": 3349, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x11\\x00\\x11\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "CBT249"}, "text": "*                             ********\n* *            SOURCE BOOK *** DEUH06 ***  COMMA PROCESSOR\n*                             ********\n         SPACE 3\nCMMA     TM    HYFSW,B'00000010'   ANY PREV ALPHA CHARS\n         BO    EOWC                IF YES GO TO END OF WORD ROUTINE\n         TM    HYFSW,B'00000001'   ANY PREV NUMERIC CHARS\n         BO    TST2ND              IF PREVIOUS NUMERIC CHARS. CHECK\nTSTSIG   TM    HYFSW,B'00000100'   IF NO TEST SIGNIF\n         BO    HREJ\n         OI    HYFSW,X'04'         IF NO TURN ON SIGNIF. INDICATOR\n         B     NULL                GET NEXT CHAR FROM USERS WK AREA\nTST2ND   BAL   REGRET,TESTSCND\n         TM    SCNDSW,B'00000001'  IS SEC CHAR NUMBER\n         BZ    EOWC                IF NOT GO TO END OF WORD\n         B     YESG                ELSE MARK COMMA AS YES HYPHEN\n         SPACE 6\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DEUH07": {"ttr": 3585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT249"}, "text": "*                             ********\n* *            SOURCE BOOK *** DEUH07 ***  HYPHEN INPUT PROCESSOR\n*                             ********\n         SPACE 3\nHYPN     TM    HYFSW,B'00000100'   ANY SIGNIF CHARS PREVIOUSLY\n         BO    YESG                IF YES\nSIGON    OI    HYFSW,B'00000100'   ELSE-RECORD CHAR AS SIGNIF\n         B     NULL\nYESG     LA    REG1,GSTATUS(REGWK2)\n         OI    0(REG1),X'38'       IF YES INDICATE YES & TEXT HYPHEN\n         B     TEOW                IF NO-\n         SPACE 6\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DEUH08": {"ttr": 3587, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "CBT249"}, "text": "*                             ********\n* *            SOURCE BOOK *** DEUH08 *** SHIFT CHARACTER ROUTINE\n*                             ********\n         SPACE 3\nSHFT     TM    HYFSW,B'00000010'   ANY PREVIOUS ALPHA CHARS\n         BZ    NULL\n         BAL   REGRET,TESTSCND\n         TM    SCNDSW,B'00000010'  IS SECONDARY CHAR ALPHA\n         BZ    NULL\n         LA    REG1,GSTATUS(REGWK2)\n         AH    REG1,MINONE\n         OI    0(REG1),X'20'       SET PREVIOUS ALPHA CHAR TO YES\n         B     TEOW\n         SPACE 6\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DEUH09": {"ttr": 3589, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x13\\x00\\x13\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "CBT249"}, "text": "*                             ********\n* *            SOURCE BOOK *** DEUH09 ***  APOSTROPHE ROUTINE\n*                             ********\n         SPACE 3\nAPOS     TM    HYFSW,X'02'         TEST FOR ANY ALPHA CHARS.PROCESSED\n         BZ    NULL                 & BRANCH IF NOT\n         BAL   REGRET,TESTSCND\n         TM    SCNDSW,X'02'        TEST FOR ALPHA SECONDARY\n         BZ    TEOW                 IF NOT TERMINATE WORD SEGMENT\n         LA    REG1,GSTATUS(REGWK2)\nAPLOOP   LA    REG1,1(REG1)        * SEARCH FOLLOWING CHARS.FOR VOWEL\n         TM    0(REG1),X'03'       * BEFORE NON-ALPHA CHAR.\n         BZ    TEOW                IF NON-ALPHA - END WORD SEGMENT\n         TM    0(REG1),X'02'       TEST FOR VOWEL/CONSONANT\n         BO    APLOOP              * IF CONSONANT - CONTINUE SEARCH\n         LA    REG1,GSTATUS(REGWK2)  IF VOWEL\n         OI    0(REG1),X'30'       * MARK APOST. AS YES HYPHEN POINT\n         B     TEOW                 & TERMINATE WORD SEGMENT\n         SPACE 6\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DEUH10": {"ttr": 3591, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x14\\x00\\x14\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "CBT249"}, "text": "*                             ********\n* *            SOURCE BOOK *** DEUH10 *** END OF WORD PROCESSOR\n*                             ********\n         SPACE 3\nEOWC     BCT   REG3,*+4\n         L     REGWK1,HFLDAD\n         ST    REG3,AEOW           SAVE ADDR. OF END OF WORD\n         TM    0(REGWK1),X'FF'     TEST FOR L-T-F MODE\n         BZ    ALLPTS               IF NOT GO FOR ALL POINTS\n         TM    HYFSW,X'02'         TEST FOR ALPHA CHARS. IN WORD\n         BZ    LTFRETR             BRANCH IF NO ALPHA CHARS. IN SEGMENT\nSTRCNTS  STH   REGWK3,MRGCNT       SAVE TRUE CHAR.COUNT FOR MERGE BACK\n         STH   REGWK2,LSTCHROF     AND FOR LAST FIT CHECK\n         BCT   REGWK3,STRCNTS1     *DECREMENT BY 1 TO GET PROPER VALUE\nSTRCNTS1 STH   REGWK3,NUMCHR       *FOR INDEXING & SAVE AS NUMCHR\n         B     ASCAN\nALLPTS   TM    HYFSW,X'02'         ANY ALPHA CHARS.\n         BO    STRCNTS               YES - BRANCH\n         B     NOHYP                 ELSE UNHYPHENABLE\n         SPACE 6\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DEUH11": {"ttr": 3593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\t\\x00\\t\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "CBT249"}, "text": "*                             ********\n* *            SOURCE BOOK *** DEUH11 *** NULL CHARACTER PROCESSOR\n*                             ********\n         SPACE 3\nNULL     LA    REG3,1(REG3)       INCREMENT REG3 FOR NEXT CHAR.\n         LA    REGWK2,1(REGWK2)    INCREMENT GSTATUS POINTER\n         BCT   REG4,NXTCHR        DECREMENT CHAR.COUNT AND RETURN\n         B     HREJ                ERROR ESCAPE WHEN NO CHARS. LEFT\n         SPACE 6\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DEUH12": {"ttr": 3595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x006\\x006\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "CBT249"}, "text": "*                             ********\n* *            SOURCE BOOK *** DEUH12 ***  ALPHA SCAN ROUTINE\n*                             ********\n         SPACE 3\n*\n*        ***** INITIAL ALPHA SCAN  RESOLVE 'Y' & ISOLATE WORDS WITH\n*        *****  LESS THAN 4 CHARS OR LASS THAN 2 VOWELS\n*\nASCAN    OI    HYFSW,X'08'         SET EOW SWITCH ON TO INITIALIZE\n         LA    REGWK3,0\n         LH    REG4,MRGCNT         ESTABLISH CHARACTER COUNT\n         LA    REG3,ASTATUS\nFRSTSIG  LA    REG1,0(REGWK3,REG3) START AS BEGINNING OF ASTATUS FIELD\n         EX    REG4,IASCN          LOOK FOR 1ST SIGNIF CHARACTER\n         BC    8,NOHYP             NO VOWELS IN WORD\n         STC   REG2,SIGCHR         SAVE INDICATOR FOR CHARACTER TYPE\n         TM    SIGCHR,X'02'             TEST CHAR FOR Y\n         BZ    SCEND                    IF NOT BYPASS 1ST Y PROCESSING\n         LA    REG2,ASTATUS             SEE IF CHAR.IS 1ST IN WORD\n         CR    REG2,REG1\n         BE    FRSTY                    IF NOT 1ST CHAR IN WORD\n         NI    0(REG1),X'FD'            SET STATUS TO VOWEL\n         B     SCEND                    & EXIT\nFRSTY    TM    1(REG1),X'01'            IF 1ST CHAR IN WORD TEST FOLLOW\n         BZ    SETFYVL                  CHAR & BRANCH IF IT IS CONSON.\n         NI    0(REG1),X'FE'            ELSE SET STATUS OF Y TO CONSON\n         B     SCEND                    & EXEI\nSETFYVL  NI    0(REG1),X'FD'            SET STATUS OF Y TO VOWEL\nSCEND    LA    REGWK3,1(REG1)\n         SR    REGWK3,REG3         SUBT START ADDR FOR COUNT\n         SR    REG4,REGWK3         AND DECREMENT NUMBER OF CHARS\n         BC    12,EOW              IF ZERO OR MINUS - END OF WORD\n         LA    REG3,1(REG1)\n         LR    REG1,REG3\n         EX    REG4,IASCN          TRT FOR OTHER VOWELS OR 'Y'\n         BC    8,EOW               AT END OF WORD BRANCH\n         STC   REG2,SIGCHR         SAVE SIGNIF CHAR\n         TM    SIGCHR,X'02'        TEST FOR ' Y' CHARACTER\n         BO    YCHAR                BRANCH YES\nEOWOFF   NI    HYFSW,X'F7'         TURN OFF E-O-W SWITCH\n         B     SCEND\nYCHAR    LR    REGWK1,REG1         GET ADDR OF ' Y ' FOR WORK\n         BCT   REGWK1,*+4               BACK UP TO PRECEEDING CHAR.\n         TM    0(REGWK1),X'01'      & TEST FOR VOWEL\n         BZ    SETYVL              IF NOT VOWEL THEN SET Y TO VOWEL\n         NI    0(REG1),X'FE'        ELSE SET Y TO CONSONANT\n         B     SCEND               AND RETURN FOR CONTINUATUIN OF SERCH\nSETYVL   NI    0(REG1),X'FD'       SET Y TO VOWEL\n         B     EOWOFF\nEOW      TM    HYFSW,X'08'         TEST FOR MORE THAN ONE VOWEL IN\n         BO    NOHYP                WORD & IF NOT GO OT NO-HYPHEN EXIT\n         LH    REGWK1,NUMCHR       COMPARE NUMBER OF CHARACTERS IN\n         CH    REGWK1,=H'4'         WORD & IF LESS THAN 4 CHARS\n         BL    NOHYP                    REJECT WORD SEGMENT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DEUH13": {"ttr": 3597, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00M\\x00M\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 77, "newlines": 77, "modlines": 0, "user": "CBT249"}, "text": "*                             ********\n* *            SOURCE BOOK *** DEUH13 ***  YES/NO SCAN\n*                             ********\n         SPACE 3\n*\n*              ALPHA YES / NO SCAN       **********\n*\nAYNSCAN  LA    REGWK3,0            INITIALIZE FOR YES/NO SCAN\n         LR    REGWK1,REGWK3       PRIME DIGRAPH WORK AREA\n         OI    YNWORK+2,X'40'\n         BAL   REGRET,GTDGRF       * REGWK1 POINTS TO 1ST CHAR.OF DIGRF\nNXTPNT   LA    REGWK1,1(REGWK1)    * REGWK3 POINTS TO ASTATUS POINT OF\n         BAL   REGRET,GTDGRF\nTSTHXX   TM    YNWORK+2,X'0C'       TEST  HXX FOR CURRENT WORD POINT\n         BAL   REGRET,SET2YN\nTSTXHX   TM    YNWORK+1,X'30'       TEST  XHX FOR CURRENT WORD POINT\n         BAL   REGRET,SET2YN\nTSTPNO   TM    YNWORK+1,X'20'       TEST  XHX POSSIBLE NO CONDITION\n         BZ    TSTXXH\n         LA    REG1,ASTATUS(REGWK3)\n         OI   0(REG1),X'20'\nTSTXXH   TM    YNWORK,X'C0'\n         BAL   REGRET,SET2YN\nTSTEND   CH    REGWK3,NUMCHR\n         BNE   NEXT                IF NOT END OF WORD GET NEXT POINT\n         B     WRDPRP              GO TO WORD PREP AT END OF YES / NO\nNEXT     LA    REGWK3,1(REGWK3)    INCREMENT TO NEXT POINT IN WORD\n         B     NXTPNT\n* THIS ROUTINE IS DESIGNED TO RETRIEVE THE YES/NO MATRIX DIGRAPH WHICH\n*  CORRESPONDS TO THE INTERSECT POINT OF TWO LETTERS IN A WORD\n*  REGWK1 = GEN.REG. 9 POINTS TO RELATIVE LOCATION OF 1ST LETTER OF\n*   PAIR IN HYFCOM    ROUTINE DESTROYS VALUE IN GEN.REG. 8 (REGWK2)\n*\nGTDGRF   L     REGWK2,YNWORK           * CLEAR  -XX BYTE OF WORK AREA\n         SRL   REGWK2,8                * AND FORCE ZEROES\n         SLL   REGWK2,16               *   TO HIGH ORDER BYTE OF 1ST\n         CH    REGWK1,NUMCHR       TEST FOR  E-O-W\n         ST    REGWK2,YNWORK           *  TEMP WORK AREA\n         BNL   FRCEPOS              AND BRANCH IF YES\n         LA    REGWK2,HYFCOM(REGWK1)   ADDRESS OF 1ST CHAR.IN REGWK2\n         BAL   REG1,GTBYTE              GET 1ST CHAR.\n         MH    REGWK2,=H'26'            MULT. BY '26'\n         STH   REGWK2,TEMP13+2          & SAVE IN 2ND TEMP AREA(MAX650)\n         LA    REGWK2,HYFCOM+1(REGWK1) ADDRESS OF 2ND CHAR.IN REGWK2\n         BAL   REG1,GTBYTE              GET 2ND CHAR.\n         AH    REGWK2,TEMP13+2          ADD 1ST CHAR(X26) FOR ADDR.OF\n         A     REGWK2,AYNMTRX           DIGRAPH TO REGWK2\n         MVC   YNWORK+2,0(REGWK2)  NEW DIGRAPH TO LOW BYTE OF WORK AREA\n         BR    REGRET                  AND RETURN\nFRCEPOS  MVI   YNWORK+2,X'04'      FORCE N-N-P ON LAST CHAR.OF WORD\n         BR    REGRET               AND RETURN\nGTBYTE   MVC   TEMP13+1(1),0(REGWK2)    GET 1 BYTE FROM LOC'N SPECIFIED\n         LH    REGWK2,TEMP13        AFTER CLEARING REGWK2\n         BR    REG1                AND RETURN\n         DS    0F\nYNWORK   DS    2X         DIGRAPH WORK AREA 3-BYTES USED -THUS A 1 BYTE\nTEMP13   DS    2H          OVERLAY TO 1ST TEMP WORK AREA\nSET2YN   LA    REG1,ASTATUS(REGWK3)\n         BO    SET2Y\n         BM    YNOUT                IF MIXED LEAVE POSS.\n         TM     0(REG1),X'30'\n         BO    SET2PN               SET TO POSS-NO (VARIABLE)\n         NI    0(REG1),X'CF'\n         B     YNOUT                & EXIT\nSET2Y    TM    0(REG1),X'10'\n         BZ    SET2PN\n         OI    0(REG1),X'30'\n         B     YNOUT\nSET2PN   NI    0(REG1),X'CF'\n         OI    0(REG1),X'20'\nYNOUT    BR    REGRET\nIASCN    TRT   0(0,REG1),ASCTBL\nASCTBL   DC    X'00010003'         * HITS FOR POSS.INDICATORS OFF\n         DC    12X'00'             *\n         DC    X'00010003'         * HITS FOR POSS.INDICATORS ON\nSIGCHR   DC    X'0'\n         LTORG\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DEUH14": {"ttr": 3600, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x02\\xeb\\x02\\xeb\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 747, "newlines": 747, "modlines": 0, "user": "CBT249"}, "text": "*                             ********\n* *            SOURCE BOOK *** DEUH14 ***  YES/NO MATRIX\n*                             ********\n         SPACE 3\n*\n* THIS MATRIX DEFINES THE YES,NO,AND POSSIBLE OCCURANCE OF HYPHENS\n* WITH RELATION TO LETTER PAIRS (DIGRAPHS).WITH RESPECT TO THE LOCATION\n* OF THE HYPHEN EACH ENTRY IS DIVIDED INTO 2 BIT INDICATORS WHICH\n* REFLECT THE YES,NO,POSS.& VARIABLE CONDITIONS AS 11,00,01,10\n* RESPECTIVELY.THE POSITION OF THE HYPHEN OCCURANCE WITH RESPECT TO THE\n* DIGRAPH IS AS FOLLOWS  XX-  BITS 0 & 1\n*                        X-X  BITS 2 & 3\n*                        -XX  BITS 4 & 5\n*                             BITS 6 & 7 NOT CURRENTLY USED\n* THE TABLE IS IN ORDER BY PRATT FREQUENCY WITH 2ND LETTER FREQUENCY\n* A SUBSET OF 1ST LETTER FREQUENCY (IE.  EE,ET,EA.....ETC.TO ZZ)\n* ALSO INCLUDED IS THE YES/NO SCAN WORK AREA\n*\nYNMTRX   CSECT ,\n         SPACE 2\n********       E* DIGRAPHS\n         DC    X'44'         EQUALS P-N-P    FOR    DIGRAPH  EE\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  ET\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  EA\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  EO\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  EN\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  ER\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  EI\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  ES\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  EH\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  ED\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  EL\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  EF\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  EC\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  EM\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  EU\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  EG\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  EY\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  EP\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  EW\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  EB\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  EV\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  EK\n         DC    X'C0'         EQUALS Y-N-N    FOR    DIGRAPH  EX\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  EJ\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  EQ\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  EZ\n         SPACE 2\n********       T* DIGRAPHS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  TE\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  TT\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  TA\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  TO\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  TN\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  TR\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  TI\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  TS\n         DC    X'44'         EQUALS P-N-P    FOR    DIGRAPH  TH\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  TD\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  TL\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  TF\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  TC\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  TM\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  TU\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  TG\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  TY\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  TP\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  TW\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  TB\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  TV\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  TK\n         DC    X'C0'         EQUALS Y-N-N    FOR    DIGRAPH  TX\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  TJ\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  TQ\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  TZ\n         SPACE 2\n********       A* DIGRAPHS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  AE\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  AT\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  AA\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  AO\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  AN\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  AR\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  AI\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  AS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  AH\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  AD\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  AL\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  AF\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  AC\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  AM\n         DC    X'44'         EQUALS P-N-P    FOR    DIGRAPH  AU\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  AG\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  AY\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  AP\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  AW\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  AB\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  AV\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  AK\n         DC    X'C4'         EQUALS Y-N-P    FOR    DIGRAPH  AX\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  AJ\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  AQ\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  AZ\n         SPACE 2\n********       O* DIGRAPHS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  OE\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  OT\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  OA\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  OO\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  ON\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  OR\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  OI\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  OS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  OH\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  OD\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  OL\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  OF\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  OC\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  OM\n         DC    X'44'         EQUALS P-N-P    FOR    DIGRAPH  OU\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  OG\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  OY\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  OP\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  OW\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  OB\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  OV\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  OK\n         DC    X'C4'         EQUALS Y-N-P    FOR    DIGRAPH  OX\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  OJ\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  OQ\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  OZ\n         SPACE 2\n********       N* DIGRAPHS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  NE\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  NT\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  NA\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  NO\n         DC    X'70'         EQUALS P-Y-N    FOR    DIGRAPH  NN\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  NR\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  NI\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  NS\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  NH\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  ND\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  NL\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  NF\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  NC\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  NM\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  NU\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  NG\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  NY\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  NP\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  NW\n         DC    X'70'         EQUALS P-Y-N    FOR    DIGRAPH  NB\n         DC    X'70'         EQUALS P-Y-N    FOR    DIGRAPH  NV\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  NK\n         DC    X'C0'         EQUALS Y-N-N    FOR    DIGRAPH  NX\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  NJ\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  NQ\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  NZ\n         SPACE 2\n********       R* DIGRAPHS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  RE\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  RT\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  RA\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  RO\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  RN\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  RR\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  RI\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  RS\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  RH\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  RD\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  RL\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  RF\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  RC\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  RM\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  RU\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  RG\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  RY\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  RP\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  RW\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  RB\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  RV\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  RK\n         DC    X'C0'         EQUALS Y-N-N    FOR    DIGRAPH  RX\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  RJ\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  RQ\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  RZ\n         SPACE 2\n********       I* DIGRAPHS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  IE\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  IT\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  IA\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  IO\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  IN\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  IR\n         DC    X'74'         EQUALS P-Y-P    FOR    DIGRAPH  II\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  IS\n         DC    X'74'         EQUALS P-Y-P    FOR    DIGRAPH  IH\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  ID\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  IL\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  IF\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  IC\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  IM\n         DC    X'74'         EQUALS P-Y-P    FOR    DIGRAPH  IU\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  IG\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  IY\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  IP\n         DC    X'34'         EQUALS N-Y-P    FOR    DIGRAPH  IW\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  IB\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  IV\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  IK\n         DC    X'C0'         EQUALS Y-N-N    FOR    DIGRAPH  IX\n         DC    X'34'         EQUALS N-Y-P    FOR    DIGRAPH  IJ\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  IQ\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  IZ\n         SPACE 2\n********       S* DIGRAPHS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  SE\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  ST\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  SA\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  SO\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  SN\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  SR\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  SI\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  SS\n         DC    X'44'         EQUALS P-N-P    FOR    DIGRAPH  SH\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  SD\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  SL\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  SF\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  SC\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  SM\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  SU\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  SG\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  SY\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  SP\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  SW\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  SB\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  SV\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  SK\n         DC    X'C0'         EQUALS Y-N-N    FOR    DIGRAPH  SX\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  SJ\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  SQ\n         DC    X'40'         EQUALS P-N-N    FOR    DIGRAPH  SZ\n         SPACE 2\n********       H* DIGRAPHS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  HE\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  HT\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  HA\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  HO\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  HN\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  HR\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  HI\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  HS\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  HH\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  HD\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  HL\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  HF\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  HC\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  HM\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  HU\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  HG\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  HY\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  HP\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  HW\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  HB\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  HV\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  HK\n         DC    X'C0'         EQUALS Y-N-N    FOR    DIGRAPH  HX\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  HJ\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  HQ\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  HZ\n         SPACE 2\n********       D* DIGRAPHS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  DE\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  DT\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  DA\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  DO\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  DN\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  DR\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  DI\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  DS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  DH\n         DC    X'70'         EQUALS P-Y-N    FOR    DIGRAPH  DD\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  DL\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  DF\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  DC\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  DM\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  DU\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  DG\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  DY\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  DP\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  DW\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  DB\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  DV\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  DK\n         DC    X'C0'         EQUALS Y-N-N    FOR    DIGRAPH  DX\n         DC    X'70'         EQUALS P-Y-N    FOR    DIGRAPH  DJ\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  DQ\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  DZ\n         SPACE 2\n********       L* DIGRAPHS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  LE\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  LT\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  LA\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  LO\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  LN\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  LR\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  LI\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  LS\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  LH\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  LD\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  LL\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  LF\n         DC    X'70'         EQUALS P-Y-N    FOR    DIGRAPH  LC\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  LM\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  LU\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  LG\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  LY\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  LP\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  LW\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  LB\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  LV\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  LK\n         DC    X'C0'         EQUALS Y-N-N    FOR    DIGRAPH  LX\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  LJ\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  LQ\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  LZ\n         SPACE 2\n********       F* DIGRAPHS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  FE\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  FT\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  FA\n         DC    X'44'         EQUALS P-N-P    FOR    DIGRAPH  FO\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  FN\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  FR\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  FI\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  FS\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  FH\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  FD\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  FL\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  FF\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  FC\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  FM\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  FU\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  FG\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  FY\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  FP\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  FW\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  FB\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  FV\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  FK\n         DC    X'C0'         EQUALS Y-N-N    FOR    DIGRAPH  FX\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  FJ\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  FQ\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  FZ\n         SPACE 2\n********       C* DIGRAPHS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  CE\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  CT\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  CA\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  CO\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  CN\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH CR\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  CI\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  CS\n         DC    X'44'         EQUALS P-N-P    FOR    DIGRAPH  CH\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  CD\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  CL\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  CF\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  CC\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  CM\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  CU\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  CG\n         DC    X'44'         EQUALS P-N-P    FOR    DIGRAPH  CY\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  CP\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  CW\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  CB\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  CV\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  CK\n         DC    X'C0'         EQUALS Y-N-N    FOR    DIGRAPH  CX\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  CJ\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  CQ\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  CZ\n         SPACE 2\n********       M* DIGRAPHS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  ME\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  MT\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  MA\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  MO\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  MN\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  MR\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  MI\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  MS\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  MH\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  MD\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  ML\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  MF\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  MC\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  MM\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  MU\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  MG\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  MY\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  MP\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  MW\n         DC    X'70'         EQUALS P-Y-N    FOR    DIGRAPH  MB\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  MV\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  MK\n         DC    X'C0'         EQUALS Y-N-N    FOR    DIGRAPH  MX\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  MJ\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  MQ\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  MZ\n         SPACE 2\n********       U* DIGRAPHS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  UE\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  UT\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  UA\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  UO\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  UN\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  UR\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  UI\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  US\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  UH\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  UD\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  UL\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  UF\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  UC\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  UM\n         DC    X'34'         EQUALS N-Y-P    FOR    DIGRAPH  UU\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  UG\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  UY\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  UP\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  UW\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  UB\n         DC    X'34'         EQUALS N-Y-P    FOR    DIGRAPH  UV\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  UK\n         DC    X'C0'         EQUALS Y-N-N    FOR    DIGRAPH  UX\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  UJ\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  UQ\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  UZ\n         SPACE 2\n********       G* DIGRAPHS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  GE\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  GT\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  GA\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  GO\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  GN\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  GR\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  GI\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  GS\n         DC    X'44'         EQUALS P-N-P    FOR    DIGRAPH  GH\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  GD\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  GL\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  GF\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  GC\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  GM\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  GU\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  GG\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  GY\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  GP\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  GW\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  GB\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  GV\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  GK\n         DC    X'C0'         EQUALS Y-N-N    FOR    DIGRAPH  GX\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  GJ\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  GQ\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  GZ\n         SPACE 2\n********       Y* DIGRAPHS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  YE\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  YT\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  YA\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  YO\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  YN\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  YR\n         DC    X'34'         EQUALS N-Y-P    FOR    DIGRAPH  YI\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  YS\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  YH\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  YD\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  YL\n         DC    X'70'         EQUALS P-Y-N    FOR    DIGRAPH  YF\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  YC\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  YM\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  YU\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  YG\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  YY\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  YP\n         DC    X'34'         EQUALS N-Y-P    FOR    DIGRAPH  YW\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  YB\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  YV\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  YK\n         DC    X'C4'         EQUALS Y-N-P    FOR    DIGRAPH  YX\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  YJ\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  YQ\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  YZ\n         SPACE 2\n********       P* DIGRAPHS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  PE\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  PT\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  PA\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  PO\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  PN\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  PR\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  PI\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  PS\n         DC    X'44'         EQUALS P-N-P    FOR    DIGRAPH  PH\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  PD\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  PL\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  PF\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  PC\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  PM\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  PU\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  PG\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  PY\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  PP\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  PW\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  PB\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  PV\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  PK\n         DC    X'C0'         EQUALS Y-N-N    FOR    DIGRAPH  PX\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  PJ\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  PQ\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  PZ\n         SPACE 2\n********       W* DIGRAPHS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  WE\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  WT\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  WA\n         DC    X'44'         EQUALS P-N-P    FOR    DIGRAPH  WO\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  WN\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  WR\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  WI\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  WS\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  WH\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  WD\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  WL\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  WF\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  WC\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  WM\n         DC    X'04'         EQUALS N-N-P    FOR    DIGRAPH  WU\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  WG\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  WY\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  WP\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  WW\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  WB\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  WV\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  WK\n         DC    X'D0'         EQUALS Y-P-N    FOR    DIGRAPH  WX\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  WJ\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  WQ\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  WZ\n         SPACE 2\n********       B* DIGRAPHS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  BE\n         DC    X'70'         EQUALS P-Y-N    FOR    DIGRAPH  BT\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  BA\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  BO\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  BN\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  BR\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  BI\n         DC    X'70'         EQUALS P-Y-N    FOR    DIGRAPH  BS\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  BH\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  BD\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  BL\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  BF\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  BC\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  BM\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  BU\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  BG\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  BY\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  BP\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  BW\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  BB\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  BV\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  BK\n         DC    X'C0'         EQUALS Y-N-N    FOR    DIGRAPH  BX\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  BJ\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  BQ\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  BZ\n         SPACE 2\n********       V* DIGRAPHS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  VE\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  VT\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  VA\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  VO\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  VN\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  VR\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  VI\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  VS\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  VH\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  VD\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  VL\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  VF\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  VC\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  VM\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  VU\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  VG\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  VY\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  VP\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  VW\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  VB\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  VV\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  VK\n         DC    X'C0'         EQUALS Y-N-N    FOR    DIGRAPH  VX\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  VJ\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  VQ\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  VZ\n         SPACE 2\n********       K* DIGRAPHS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  KE\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  KT\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  KA\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  KO\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  KN\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  KR\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  KI\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  KS\n         DC    X'74'         EQUALS P-Y-P    FOR    DIGRAPH  KH\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  KD\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  KL\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  KF\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  KC\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  KM\n         DC    X'44'         EQUALS P-N-P    FOR    DIGRAPH  KU\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  KG\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  KY\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  KP\n         DC    X'14'         EQUALS N-P-P    FOR    DIGRAPH  KW\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  KB\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  KV\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  KK\n         DC    X'C0'         EQUALS Y-N-N    FOR    DIGRAPH  KX\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  KJ\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  KQ\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  KZ\n         SPACE 2\n********       X* DIGRAPHS\n         DC    X'70'         EQUALS P-Y-N    FOR    DIGRAPH  XE\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  XT\n         DC    X'70'         EQUALS P-Y-N    FOR    DIGRAPH  XA\n         DC    X'70'         EQUALS P-Y-N    FOR    DIGRAPH  XO\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  XN\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  XR\n         DC    X'70'         EQUALS P-Y-N    FOR    DIGRAPH  XI\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  XS\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  XH\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  XD\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  XL\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  XF\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  XC\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  XM\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  XU\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  XG\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  XY\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  XP\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  XW\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  XB\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  XV\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  XK\n         DC    X'54'         EQUALS Y-Y-N    FOR    DIGRAPH  XX\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  XJ\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  XQ\n         DC    X'54'         EQUALS N-Y-N    FOR    DIGRAPH  XZ\n         SPACE 2\n********       J* DIGRAPHS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  JE\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  JT\n         DC    X'44'         EQUALS P-N-P    FOR    DIGRAPH  JA\n         DC    X'44'         EQUALS P-N-P    FOR    DIGRAPH  JO\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  JN\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  JR\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  JI\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  JS\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  JH\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  JD\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  JL\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  JF\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  JC\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  JM\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  JU\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  JG\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  JY\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  JP\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  JW\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  JB\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  JV\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  JK\n         DC    X'C0'         EQUALS Y-N-N    FOR    DIGRAPH  JX\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  JJ\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  JQ\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  JZ\n         SPACE 2\n********       Q* DIGRAPHS\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  QE\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  QT\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  QA\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  QO\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  QN\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  QR\n         DC    X'4C'         EQUALS P-N-Y    FOR    DIGRAPH  QI\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  QS\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  QH\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  QD\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  QL\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  QF\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  QC\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  QM\n         DC    X'04'         EQUALS N-N-P    FOR    DIGRAPH  QU\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  QG\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  QY\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  QP\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  QW\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  QB\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  QV\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  QK\n         DC    X'C0'         EQUALS Y-N-N    FOR    DIGRAPH  QX\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  QJ\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  QQ\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  QZ\n         SPACE 2\n********       Z* DIGRAPHS\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  ZE\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  ZT\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  ZA\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  ZO\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  ZN\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  ZR\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  ZI\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  ZS\n         DC    X'0C'         EQUALS N-N-Y    FOR    DIGRAPH  ZH\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  ZD\n         DC    X'F0'         EQUALS N-P-Y    FOR    DIGRAPH  ZL\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  ZF\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  ZC\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  ZM\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  ZU\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  ZG\n         DC    X'54'         EQUALS P-P-P    FOR    DIGRAPH  ZY\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  ZP\n         DC    X'10'         EQUALS N-P-N    FOR    DIGRAPH  ZW\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  ZB\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  ZV\n         DC    X'30'         EQUALS N-Y-N    FOR    DIGRAPH  ZK\n         DC    X'C0'         EQUALS Y-N-N    FOR    DIGRAPH  ZX\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  ZJ\n         DC    X'00'         EQUALS N-N-N    FOR    DIGRAPH  ZQ\n         DC    X'50'         EQUALS P-P-N    FOR    DIGRAPH  ZZ\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DEUH15": {"ttr": 3849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00m\\x00m\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 109, "newlines": 109, "modlines": 0, "user": "CBT249"}, "text": "*                             ********\n* *            SOURCE BOOK *** DEUH15 ***  WORD PREPARATION ROUTINES\n*                             ********\n         SPACE 3\n*\n*              WORD PREP & HYPHENFIELD SCAN   ************\n*        ***** WORD PREPARATION  FOR SUFFIX ANALYSIS OR EXIT FROM\n*        *****  HYPHENATION\n*\nWRDPRP   LH    REGWK3,MINONE       MINUS ONE TO BEGIN WORD SCAN\n         BAL   14,NEGFWD            DO NEGATE FORWARD SCAN\n         BC    BNEG,HREJ           BRANCH IF WORD REJECTED\n         STH   REGWK3,FIRSTVOW     SAVE ADDRESS OF FIRST VOWEL\n         LH    REGWK3,NUMCHR       INITIALIZE FOR REVERSE SCAN\n         BAL   14,NEGREV            DO NEGATE REVERSE SCAN\n         BC    BNEG,HREJ           BRANCH IF WORD REJECTED\n         STH   REGWK3,LASTVOW      SAVE ADDRESS OF LAST VOWEL\n         CLC   FIRSTVOW(2),LASTVOW\n         BE    NOHYP\nWORDSCN  NI    SCNDSW,X'3F'        CLEAR YES & POSS.INDICATORS  H-FIELD\n         MVC   HFLDST,FIRSTVOW     GET ADDR.OF FIRST VOWEL\nNXTFLD   LH    REGWK1,HFLDST\n         CH    REGWK1,LASTVOW       IS THIS VOWEL = LAST VOWEL\n         BE    LSTVWL               BRANCH IF YES\n         LA    REGWK3,ASTATUS(REGWK1)\nHFLDSCN  NI    SCNDSW,X'C7'        TURN OFF YES POSS & CONSONANT INDIC.\n         XC    POSADR,POSADR       SET POSS.ADDRESS TO ZERO\n         B     TSTATS\nNXTATS   LA    REGWK1,1(REGWK1)    GET NEXT STATUS POINT\n         LA    REGWK3,ASTATUS(REGWK1)\n         TM    0(REGWK3),X'01'     TEST FOR VOWEL AS NEXT CHAR\n         BO    ENDHFLD              & BRANCH IF YES\nTSTATS   TM    0(REGWK3),X'02'     TEST CHAR FOR CONSONANT\n         BZ    BYCON                IF NOT BYPASS 1 INST.\n         OI    SCNDSW,X'08'        INDICATE CONSONANT FOR HYPH/FIELD\nBYCON    TM    0(REGWK3),X'10'     *TEST STATUS OF THIS POINT\n         BZ    NXTATS             * STATUS NO OR VARIABLE\n         TM    0(REGWK3),X'30'    *\n         BM    TSTPOS             * STATUS POSSIBLE\n         LR    REGWK3,REGWK1            * STATUS YES\n         STH   REGWK3,POSADR\n         B     NGREV                    TERMINATE FIELD SCAN ON 1ST YES\nPTOY     LH    REGWK3,MINONE\n         AH    REGWK3,POSADR\n         STH   REGWK3,POSADR\n         LA    REGWK2,ASTATUS(REGWK3)   * POINT IN FIELD & GENERAT FULL\n         OI    0(REGWK2),X'30'          * ADDR. THEN SET POINT TO YES\nNGREV    BAL   REGRET,NEGREV            SET ALL OTHER POINTS IN FIELD\n         BC    BNEG,HREJ           BRANCH IF WORD REJECTED\n         LH    REGWK3,POSADR            *TO NO\n         BAL   REGRET,NEGFWD            *\n         BC    BNEG,HREJ           BRANCH IF WORD REJECTED\n         OI    SCNDSW,X'20'             INDICATE A YES FIELD FOUND\n         LR    REGWK1,REGWK3\n         B     SVOWAD\nTSTPOS   LH    REGWK3,POSADR       TEST POSSIBLE STATUS\n         LTR   REGWK3,REGWK3\n         BM    NXTATS              IF NEGATIVE MORE THAN ONE POSS.POINT\n         BZ    FSTPOS              IF ZERO - FIRST POSS.POINT\n         OI    POSADR,X'80'        ELSE INDICATE NEG.ADDRESS FOR MORE\n         B     NXTATS              * THAN ONE POSS.POINT IN FIELD\nFSTPOS   LA    REGWK1,1(REGWK1)\n         STH   REGWK1,POSADR\n         B     NXTATS+4\n         B     NXTATS\nENDHFLD  LA    REGWK3,0\n         CH    REGWK3,POSADR\n         BE    SVOWAD\n         TM    SCNDSW,X'08'        TEST FOR CONSONANT\n         BZ    SETNO                & SET HFLDST VOWEL NO IF NOT\n         TM    POSADR,X'80'\n         BZ    PTOY\n         OI    SCNDSW,X'10'        INDICATE POSSIBLE FIELD\nSVOWAD   STH   REGWK1,HFLDST       RECORD ADDR.OF FIELD TERM.VOWEL\n         TM    SCNDSW,X'30'        TEST FOR YES OR POSS.POINTS IN FIELD\n         BZ    NXTFLD               IF NONE RETURN FOR NEXT FIELD\n         BM    INDPOS              BRANCH IF POSS FIELD\n         OI    SCNDSW,X'80'        INDICATE ONE YES FIELD\n         B     NXTFLD\nINDPOS   OI    SCNDSW,X'40'        INDICATE ONE POSS FIELD\n         B     NXTFLD\nSETNO    LH    REGWK3,HFLDST           *THIS ROUTINE INSURES THAT\n         LA    REGWK3,ASTATUS(REGWK3)  * CHARACTER SEQUENCES WHICH DO\n         NI    0(REGWK3),X'CF'         * NOT CONSTITUTE HYPHEN FIELDS\n         OI    0(REGWK3),X'20'     SET STATUS VARIABLE\n         OI    SCNDSW,X'40'         & INDICATE UNRESOLVED WORD\n         B     SVOWAD                  * WILL NOT REFLECT POSS.POINTS\nLSTVWL   DS    0H\n        $CALL  EXCEPT              LOOKUP THE WORD IN EXCEPTION DICT\n         BC    BPOS,FOUND          BRANCH IF WORD FOUND\n         SPACE\n*  FOLLOW RETURN FROM EXCEPTION WORD SEARCH WITH TEST OF HIT IN\n*  DICTIONARY AND SUBSEQUENT ISOLATION OF YES POINTS AND LINKAGE\n*  TO FOUND ROUTINE\n         BAL   REGRET,SCNLFT\n         BC    BPOS,FOUND          BRANCH IF FOUND BREAK\n         TM    SCNDSW,X'40'        TEST FOR UNRESOLVED POSS.POIMTS\n         BZ    FOUND                & IF NONE GO TO SUFFIX ANALYSIS\n        $CALL  SUFFIX              SUFFIX SCAN ROUTINE\n         BC    BPOS,FOUND          BRANCH IF WORD FOUND\n         B     HREJ                ELSE REJECT IT\nMINONE   DC    H'-1'\nHFLDST   DC    H'0'\nPOSADR   DC    H'0'\n         LTORG\nWREG     EQU   6\nREG3     EQU   3\nREG4     EQU   4\nREG5     EQU   5\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DEUH16": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\xbe\\x00\\xbe\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 190, "newlines": 190, "modlines": 0, "user": "CBT249"}, "text": "*                             ********\n* *            SOURCE BOOK *** DEUH16 *** SUFFIX ANALYSIS          1-1\n*                             ********\n         SPACE 3\nSUFFIX  $ENTER ,\n*        WAS   DEUHYB01\n         SPACE\n***********************************************************************\n*                                                                     *\n*    THE SUFFIX ANALYSIS MODULE CONSISTS OF THREE ROUTINES, THE SUFFIX*\n*  INIALIZATION ROUTINE (SFXIZ), THE SUFFIX SEARCH ROUTINE (SFXSRCH), *\n*  AND THE SUFFIX PROCESSOR ROUTINE (SFXPROC).                        *\n*                                                                     *\n*    THE FUNCTION OF SFXIZ IS TO GET THE STARTING ADDRESS FOR SFXSRCH.*\n*  IT DOES THIS BY USING THE BINARY VALUE OF THE LAST LETTER OF THE   *\n*  WORD AS AN INDEX POINTER TO A TABLE OF SUFFIX ENTRY LETTER-GROUP   *\n*  ADDRESS VALUES.                                                    *\n*                                                                     *\n*    SFXSRCH IS THE ROUTINE THAT SEARCHES THROUGH THE TABLE OF SUFFIX *\n*  ENTRIES. IT GETS THE LENGTH OF THE SUFFIX FROM THE TABLE ENTRY AND *\n*  USES THIS VALUE AS THE LENGTH FOR THE COMPARE INSTRUCTION AND TO   *\n*  GET THE ADDRESS OF THE FIRST LETTER OF A POSSIBLE SUFFIX IN THE    *\n*  WORD. IF IT GETS A HIT ON THE COMPARE IT BRANCHES TO SFXPROC, IF   *\n*  NOT, IT STEPS TO THE NEXT TABLE ENTRY ANDS LOOPS THROUGH SFXSRCH   *\n*  UNTIL IT GETS A HIT OR REACHES THE END OF THE TABLE FOR THAT       *\n*  LETTER-GROUP.                                                      *\n*                                                                     *\n*    SFXPROC, BY EXAMINING THE INDICATOR BYTES OF THE SUFFIX TABLE EN-*\n*  TRY, DETERMINES  1- THE PLACEMENT OF ANY HYPHENS AND SETS THEM IN  *\n*  THE STATUS AREA, 2- WHAT, IF ANY, SEGMENT OF THE SUFFIX IS TO BE   *\n*  STRIPPED FROM THE WORD, 3- WHETHER OR NOT ANOTHER SUFFIX SEARCH IS *\n*  TO BE INITIATED FOR THE STRIPPED VERSION OF THE WORD.              *\n*                                                                     *\n*    A BRIEF DESCRIPTION OF THE STRUCTURE OF THE SUFFIX TABLE ENTRIES *\n*  CAN BE FOUND AT THE BEGINNING OF THE SUFFIX TABLE SOURCE BOOK.     *\n*                                                                     *\n***********************************************************************\nRGLAST   EQU   2         FOR LAST CHAR OF WORD\nRGWDSZ   EQU   3         FOR SIZE OF WORD LESS 1\nRGHYF    EQU   4         CHARACTER POINTER IN HYFCOM FOR THE COMPARE\nRGSTAT   EQU   5         POINTER IN STATUS AREA\nRGNTRY   EQU   6         POINTER TO TABLE ENTRY\nRGLEN    EQU   7         FOR LENGTH OF THE SUFFIX (COMPARE LENGTH)\nRGWK3    EQU   7         MISC. WORK REGISTER NO. 3\nRGWK2    EQU   8         MISC. WORK REGISTER NO. 2\nRGWK1    EQU   9         MISC. WORK REGISTER NO. 1\n*\nE        EQU   X'00'     MASK FOR TEST INSTRUCTION\nI        EQU   X'06'     MASK FOR TEST INSTRUCTION\nS        EQU   X'07'     MASK FOR TEST INSTRUCTION\nY        EQU   X'10'     MASK FOR TEST INSTRUCTION\nSFXYES   EQU   X'B0'     SUFFIX HYPHEN INDICATION\n*\n***SUFFIX INITIALIZATION ROUTINE***************************************\n         LH    RGWDSZ,NUMCHR       GET SIZE OF WORD.\n         STH   RGWDSZ,PREVROOT     SAVE FOR ROOT WORD SIZE.\nSFXIZ    LA    RGLAST,0            CLEAR THE REGISTER\n         IC    RGLAST,HYFCOM(RGWDSZ) GET LAST CHAR OF WORD\n         STC   RGLAST,LSTCHR       AND SAVE IT.\n         LR    RGWK1,RGLAST        PUT LAST CHAR IN A WORK REGISTER AND\n         SLL   RGWK1,1             DOUBLE THE VALUE.\n         MVI   GATE+1,X'00'        INITIALIZE BRANCH TO HALGO.\n         L     RGNTRY,ASFXTBLS     GET ADDR. OF SUFFIX TABLE.\n         L     RGWK2,ASFXTAB       GET ADDR. OF LETTER-GROUP DIS-\n*                                  PLACEMENT TABLE.\n         STC   RGWK1,*+7           PUT DISPLACEMENT IN NEXT INSTRUCTION\n         TM    0(RGWK2),X'80'      IF NO SUFFIX TABLE FOR THIS LETTER,\n         BO    RDHLGO                GO TO HALGO.\n         AH    RGNTRY,0(RGWK1,RGWK2) TO GET ACTUAL ADDR. OF FIRST\n*                                    SUFFIX TABLE ENTRY FOR A\n*                                    PARTICULAR LETTER-GROUP.\n***SUFFIX SEARCH ROUTINE***********************************************\nSFXSRCH  LA    RGLEN,0             CLEAR REGISTER\n         IC    RGLEN,0(RGNTRY)     GET FIRST BYTE OF TABLE ENTRY.\n         SRL   RGLEN,4             FOR ZONE PORTION OF BYTE.\n         LR    RGHYF,RGWDSZ        TO DEVELOP AN INDEX FACTOR,CALCULATE\n         SR    RGHYF,RGLEN         SIZE OF WORD MINUS SUFFIX LENGTH\n         BNH   TSTLSX              BRANCH IF ENTRY IS LARGER THAN WORD.\n         LA    RGHYF,HYFCOM-1(RGHYF)    ADDRESS OF 1ST CHAR OF SUFFIX\n*                                       IN THE WORD.\n         EX    RGLEN,CMPSFX        COMPARE SUFFIX ENTRY TO END OF WORD.\n         BE    SFXPROC             IT'S A HIT - GO PROCESS THIS ENTRY.\n         B     TSTLSX              NO HIT,GO SEE IF THIS IS LAST ENTRY.\n         SPACE 2\nCMPSFX   CLC   1(0,RGNTRY),0(RGHYF)     THIS IS THE ACTUAL COMPARE.\n         SPACE 3\nTSTLSX   TM    0(RGNTRY),X'0F'     IS THIS THE LAST SUFFIX ENTRY\n         BZ    TSTERM              BRANCH IF NO MORE\n         MVN   *+9(1),0(RGNTRY)    PLUG ENTRY SIZE INTO NEXT INSTRUCTN\n         LA    RGNTRY,0(RGNTRY)    TO GET TO NEXT ENTRY.\n         B     SFXSRCH             LOOP THRU SEARCH ROUTINE AGAIN.\n         SPACE 6\n***SUFFIX PROCESSOR ROUTINE********************************************\nSFXPROC  LA    RGNTRY,2(RGLEN,RGNTRY) GET ADDR OF 1ST INDICATOR BYTE.\n         MVN   *+9(1),0(RGNTRY)    PLUG INDICATOR VALUE INTO NEXT INSTR\n         LA    RGWK1,0             TO GET NO. OF LETTERS IN SEGMENT\n         LR    RGWK2,RGWDSZ        LOAD THE WORD SIZE AND\n         SR    RGWK2,RGWK1         SUBTRACT SIZE OF SEGMENT FOR POINT\n         LR    RGWK1,RGWK2         IN STATUS AREA.\n         SH    RGWK2,FIRSTVOW      IS POINT TO THE RIGHT OF FIRST VOWEL\n         BM    SFXIT               GET OUT IF NOT\n         SPACE\n         TM    0(RGNTRY),X'20'     SHOULD SEARCH BE CONTINUED FOR\n*                                   STRIPPED WORD\n         BZ    *+8                 BRANCH AROUND NEXT INSTRUCTION IF NO\n         MVI   GATE+1,X'F0'        TO PREVENT BRANCH TO HALGO\nTSTHYF   TM    0(RGNTRY),X'10'     IS HYPHEN INDICATOR ON\n         LA    RGSTAT,ASTATUS(RGWK1)  GET ADDR OF POINT IN STATUS AREA\n         BO    *+8                 BRANCH AROUND NEXT 2 INSTRCTNS IF ON\n         SPACE\n         OI    0(RGSTAT),SFXYES    AND PUT A HYPHEN THERE.\n         SPACE\n         TM    0(RGNTRY),X'40'     IS STRIP INDICATOR ON\n         BO    *+14                BRANCH AROUND,IF NO\n         SPACE\n         STH   RGWDSZ,PREVROOT     SAVE PRESENT WORD SIZE\n         LR    RGWDSZ,RGWK1        GET NEW WORD SIZE AND\n         STH   RGWK1,NUMCHR        SAVE IT.\n         BAL   REGRET,SFXSETNO     SET STRIPPED SEGMENT TO NO\n         TM    0(RGNTRY),X'80'     ANY MORE INDICATOR BYTES\n         BO    SFXIT               BRANCH IF NO MORE\n         LA    RGNTRY,1(RGNTRY)    STEP TO NEXT INDICATOR BYTE AND\n         B     SFXPROC+4           LOOP THRU AGAIN.\n         SPACE 2\nTSTERM   CLI   LSTCHR,I            IS LAST LETTER AN I\n         BNE   TSTE                BRANCH IF NOT I\n         SPACE\n         MVI   LSTCHR,Y            CHANGE I TO Y\n         IC    RGLAST,LSTCHR\n         STC   RGLAST,HYFCOM(RGWDSZ)\n         B     SFXIZ               GO BACK TO SEARCH WITH NEW WORD\n         SPACE 3\nTSTE     CLI   LSTCHR,E            IS LAST LETTER AN E\n         BE    STRP1               BRANCH IF YES\n         SPACE\n         CLI   LSTCHR,S            IS LAST LETTER AN S\n         BNE   RDHLGO              BRANCH IF NO\n         SPACE\nSTRP1    LA    RGWK1,1\n         MVI   GATE+1,X'F0'        TO CONTINUE SEARCH\n         SR    RGWDSZ,RGWK1        REDUCE WORD SIZE BY ONE\n         STH   RGWDSZ,NUMCHR       SAVE NEW SIZE\n         LA    RGSTAT,ASTATUS(RGWDSZ) GET ADDR OF POINT IN STATUS AREA\n         TM    0(RGSTAT),X'B0'     TEST FOR SUFFIX YES\n         BO    SFXIT               BRANCH IF IT IS\n         MVZ   0(1,RGSTAT),BINZERO IF NOT, MAKE IT A NO POINT\n         B     SFXIT\n         SPACE 3\nSFXSETNO LH    RGWK2,PREVROOT      FOR LIMIT OF SCAN\n         SR    RGWK2,RGWDSZ        CALCULATE NO. OF POSITIONS\n         LA    RGWK2,1(RGWK2)\nNXTPT    LA    RGSTAT,1(RGSTAT)    MOVE RIGHT TO NEXT POINT\n         TM    0(RGSTAT),X'B0'     TEST IT\n         BO    *+10                BRANCH AROUND IF SUFFIX YES POINT\n         MVZ   0(1,RGSTAT),BINZERO IF POSSIBLE, MAKE IT NO\n         BCT   RGWK2,NXTPT         TEST FOR END OF SCAN\n         BR    REGRET              SCAN COMPLETE - GET OUT\n         SPACE 3\nSFXIT    LR    RGWK3,RGWDSZ        SET UP FOR NEGREV ROUTINE.\n         BAL   REGRET,NEGREV       GO THERE TO FIND NEW LAST VOWEL\n         BC    BNEG,FOUNDRTA       BRANCH IF WORD REJECTED\n         STH   RGWK3,LASTVOW       AND SAVE IT.\n         LA    REG1,1\n         CR    REG1,RGWDSZ         DO NOT GO TO EXCEPT,\n         BNL   CLCF2L               IF LESS THAN 2 LETTERS REMAIN\n        $CALL  EXCEPT              LOOKUP WORD IN EXCEPTION DICT\n         BC    BPOS,FOUNDRT        BRANCH IF FOUND\n         BAL   REGRET,SCNLFT       TO TEST FOR POSS LAST-TO-FIT EXIT.\n         BC    BPOS,FOUNDRT        BRANCH IF BREAK FOUND\nCLCF2L   CLC   FIRSTVOW,LASTVOW    IF ONLY ONE VOWEL,\n         BE    FOUNDRT             GET OUT.\n*        L     REG1,=V(DEUTSD01)   TO GO TO HYPTEST,\n*        LTR   REG1,REG1           IF RUNNING IN TEST MODE.\n*        BZ    *+6                 IF NOT IN TEST MODE, BYPASS IT.\n*        BALR  REGRET,REG1\n         LA    RGLEN,2\n         CR    RGLEN,RGWDSZ        IF NEW WORD LESS THAN 2 LETTERS\n         BH    FOUNDRT             GO TO FOUND\nGATE     BC    0,SFXIZ             IF BRANCH ACTIVE, CONTINUE SEARCH\n*                                  IF NOT, GO TO HALGO\n         SPACE 3\nRDHLGO   DS    0H\n        $CALL  HALGO               GO DO PROBABILITY ROUTINE\nFOUNDRT  DS    0H\n        $CC    POS                 INDICATE FOUND\n         B     FOUNDFIN            GO TO FINAL RETURN\nFOUNDRTA DS    0H\n        $CC    NEG                 INDICATE REJECT\nFOUNDFIN DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DEUH17": {"ttr": 4101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x02a\\x02a\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 609, "newlines": 609, "modlines": 0, "user": "CBT249"}, "text": "*                             ********\n* *            SOURCE BOOK *** DEUH17 *** SUFFIX TABLES\n*                             ********\n         SPACE 3\nSFXTBLS  CSECT\n*        WAS   DEUHYC01\n         SPACE\n*\n*\n*     SUFFIX ENTRIES ARE VARIABLE LENGTH RECORDS CONTAINING 5 OR 6\n*  FIELDS.  THE NOTATION S1, S2, .. SN, IS USED TO DENOTE THE INDIVID-\n*  UAL CHARACTERS IN THE SUFFIX WHERE S1 IS THE RIGHT-MOST CHARACTER IN\n*  THE SUFFIX, AND SN IS THE LEFT-MOST CHARACTER IN THE SUFFIX.  THUS,\n*  IN THE CASE OF -ING, S1=G, S2=N,S3=SN=I.  IN THE CASE OF MULTI-\n*  SYLLABLE SUFFIXES SUCH AS -WOM-AN, THE SYLLABLE NUMBERING SEQUENCE\n*  IS ALSO RIGHT TO LEFT -- THUS --  -AN IS THE FIRST SYLLABLE AND -WOM\n*  IS THE SECOND.\n*     EACH SUFFIX ENTRY CONTAINS CHARACTERS SN THROUGH S2 OF THE SUFFIX\n*  S1 BEING IMPLIED IN THE POSITION OF THE ENTRY IN THE SUFFIX TABLES.\n*  A TYPICAL SUFFIX ENTRY HAS THE FOLLOWING FIELDS, COUNTING LEFT TO\n*  RIGHT--\n*        1- ONE HALF-BYTE (ZONE) CONTAINING THE NUMBER OF LETTERS IN\n*  THE SUFFIX MINUS 2.\n*        2-  ONE HALF-BYTE (DIGIT) CONTAINING THE NUMBER OF BYTES IS\n*  THE TABLE ENTRY.  THE LAST ENTRY IN THE LETTER-GROUP IS SET TO ZERO.\n*        3- SN MINUS 1 BYTES CONTAINING THE SUFFIX CHARACTERS (FREQUEN-\n*  CY CODED) SN THROUGH S2.\n*        4-  (PRESENT ONLY IN MULTI-SYLLABLE SUFFIXES)  N MINUS 1\n*  BYTES (WHERE N= THE NUMBER OF SYLLABLES IN THE SUFFIX).  THE FIRST\n*  BYTE CONTAINS THE NUMBER OF LETTERS (LESS THAN 16) IN THE FIRST\n*  SYLLABLE, THE SECOND BYTE CONTAINS THE NUMBER OF LETTERS IN THE\n*  SECOND SYLLABLE, ETC.  THE COUNT IS EXPRESSED BINARILY AND ONLY THE\n*  DIGIT PORTION OF THE BYTE IS USED.\n*        5- ONE HALF-BYTE (ZONE) CONTAINING INDICATORS USED BY 'HYPHEN'\n*  THE FORMAT OF THE INDICATORS IS--\n*     BIT 0 = LAST SYLLABLE LETTER COUNT BYTE IF ON.\n*     BIT 1 =  NO STRIPPING IF ON\n*     BIT 2 = CONTINUE SUFFIX SEARCH AFTER DELETING THIS SUFFIX IF ON.\n*     BIT 3 = 'SYLLABLE' DOES NOT YIELD A HYPHEN POINT IF ON -- LETTERS\n*  ARE ONLY STRIPPED FROM THE WORD.\n*        6- ONE HALF-BYTE (DIGIT) CONTAINS THE NUMBER OF LETTERS IN THE\n*  LAST SYLLABLE OF THE SUFFIX.\n*\n*\n*\n*\n*\n         ENTRY SFXTAB\n*\n*\n*  LEGEND FOR FIRST COLUMN OF COMMENTS IN SFXTAB\n*\n*\n*                             STRIP  CONTINUE  SET YES\n*                             CHARS   SEARCH    POINT\n*\n*                        -      Y       Y         Y\n*\n*                        +      Y       N         Y\n*\n*                        /      Y       Y         N\n*\n*                        *      Y       N         N\n*\n*                        #      N       N         N\n*\n*                        $      N       Y         Y\n*\nSFXTAB   EQU   *\n         DC    Y(ESFX-SFXTBLS)     OFFSET FOR LETTER E\n         DC    Y(TSFX-SFXTBLS)     OFFSET FOR LETTER T\n         DC    Y(ASFX-SFXTBLS)     OFFSET FOR LETTER A\n         DC    Y(OSFX-SFXTBLS)     OFFSET FOR LETTER O\n         DC    Y(NSFX-SFXTBLS)     OFFSET FOR LETTER N\n         DC    Y(RSFX-SFXTBLS)     OFFSET FOR LETTER R\n         DC    Y(ISFX-SFXTBLS)     OFFSET FOR LETTER I\n         DC    Y(SSFX-SFXTBLS)     OFFSET FOR LETTER S\n         DC    Y(HSFX-SFXTBLS)     OFFSET FOR LETTER H\n         DC    Y(DSFX-SFXTBLS)     OFFSET FOR LETTER D\n         DC    Y(LSFX-SFXTBLS)     OFFSET FOR LETTER L\n         DC    Y(FSFX-SFXTBLS)     OFFSET FOR LETTER F\n         DC    Y(CSFX-SFXTBLS)     OFFSET FOR LETTER C\n         DC    Y(MSFX-SFXTBLS)     OFFSET FOR LETTER M\n         DC    Y(USFX-SFXTBLS)     OFFSET FOR LETTER U\n         DC    Y(GSFX-SFXTBLS)     OFFSET FOR LETTER G\n         DC    Y(YSFX-SFXTBLS)     OFFSET FOR LETTER Y\n         DC    Y(PSFX-SFXTBLS)     OFFSET FOR LETTER P\n         DC    Y(WSFX-SFXTBLS)     OFFSET FOR LETTER W\n         DC    X'8000'             OFFSET FOR LETTER B\n         DC    Y(VSFX-SFXTBLS)     OFFSET FOR LETTER V\n         DC    Y(KSFX-SFXTBLS)     OFFSET FOR LETTER K\n         DC    Y(XSFX-SFXTBLS)     OFFSET FOR LETTER X\n         DC    X'8000'             OFFSET FOR LETTER J\n         DC    X'8000'             OFFSET FOR LETTER Q\n         DC    Y(ZSFX-SFXTBLS)     OFFSET FOR LETTER Z\nASFX     EQU   *\n         DC    X'0319A2'                              -ZA        ZA\n         DC    X'370715021002A3'                  -SKA-YA     SKAYA\n         DC    X'0310A2'                              -YA        YA\n         DC    X'030ED0'                                #        UA\n         DC    X'0301A2'                              -TA        TA\n         DC    X'0307A2'                              -SA        SA\n         DC    X'140105A3'                           -TRA       TRA\n         DC    X'15000501A2'                        -ER-A       ERA\n         DC    X'140905A3'                           -DRA       DRA\n         DC    X'141305A3'                           -BRA       BRA\n         DC    X'0311A2'                              -PA        PA\n         DC    X'0303D0'                                #        OA\n         DC    X'0304A2'                              -NA        NA\n         DC    X'030DA2'                              -MA        MA\n         DC    X'14110AA3'                           -PLA       PLA\n         DC    X'030AA2'                              -LA        LA\n         DC    X'0315A2'                              -KA        KA\n         DC    X'040601A2'                          - I-A        IA\n         DC    X'0308A3'                             - HA        HA\n         DC    X'030FA2'                              -GA        GA\n         DC    X'0309A2'                              -DA        DA\n         DC    X'030CA2'                              -CA        CA\n         DC    X'0013A2'                              -BA        BA\nCSFX     EQU   *\n         DC    X'14090EA3'                           -DUC       DUC\n         DC    X'36180E0004A5'                     -QUENC     QUENC  E\n         DC    X'250E0004A3'                         -ENC      UENC  E\n         DC    X'360007000483'                       +ENC     ESENC  E\n         DC    X'3600050004A3'                       -ENC     ERENC  E\n         DC    X'25060004A3'                         -ENC      IENC  E\n         DC    X'140004A4'                          - ENC       ENC  E\n         DC    X'2507020484'                        +SANC      SANC  E\n         DC    X'3600050204A3'                       -ANC     ERANC  E\n         DC    X'3602050204A3'                       -ANC     ARANC  E\n         DC    X'25040204A4'                        -NANC      NANC  E\n         DC    X'25060204A3'                         -ANC      IANC  E\n         DC    X'370A10010602A3'                  -LYT-IC     LYTIC\n         DC    X'25070106A3'                         -TIC      STIC\n         DC    X'25110106A3'                         -TIC      PTIC\n         DC    X'25030106A2'                          -IC      OTIC\n         DC    X'3602040106A3'                       -TIC     ANTIC\n         DC    X'25040106A3'                         -TIC      NTIC\n         DC    X'25000106A2'                          -IC      ETIC\n         DC    X'250C0106A3'                         -TIC      CTIC\n         DC    X'25020106A2'                          -IC      ATIC\n         DC    X'25031106A2'                          -IC      OPIC\n         DC    X'25080406A3'                         -NIC      HNIC\n         DC    X'140406A2'                            -IC       NIC\n         DC    X'140D06A2'                            -IC       MIC\n         DC    X'250A0A06A3'                         -LIC      LLIC\n         DC    X'140A06A2'                            -IC       LIC\n         DC    X'140806A2'                            -IC       HIC\n         DC    X'140F06A2'                            -IC       GIC\n         DC    X'140B06A2'                            -IC       FIC\n         DC    X'140906A2'                            -IC       DIC\n         DC    X'141306A3'                           -BIC       BIC\n         DC    X'140206A2'                            -IC       AIC\n         DC    X'25110A02A4'                        -PLAC      PLAC  E\n         DC    X'140602A2'                            -AC       IAC\n         DC    X'0002A3'                             - AC        AC\nDSFX     EQU   *\n         DC    X'14010EA3'                           -TUD       TUD\n         DC    X'140305A4'                          - ORD       ORD\n         DC    X'25100205A4'                        -YARD      YARD\n         DC    X'25120205A4'                        -WARD      WARD\n         DC    X'360F0E0205A5'                     -GUARD     GUARD\n         DC    X'25010205A4'                        -TARD      TARD\n         DC    X'25030205A5'                       - OARD      OARD\n         DC    X'25040205A4'                        -NARD      NARD\n         DC    X'370A06020503A2'                  -LI-ARD     LIARD\n         DC    X'25060205A4'                        -IARD      IARD\n         DC    X'360C080205A3'                       -ARD     CHARD\n         DC    X'250F0205A4'                        -GARD      GARD\n         DC    X'25130205A4'                        -BARD      BARD\n         DC    X'25120303A4'                        -WOOD      WOOD\n         DC    X'25080303A4'                        -HOOD      HOOD\n         DC    X'470F05030E04A6'                  -GROUND    GROUND\n         DC    X'25030E04A5'                       - OUND      OUND\n         DC    X'250D0304A4'                        -MOND      MOND\n         DC    X'140604A4'                          - IND       IND\n         DC    X'25010004A4'                        -TEND      TEND\n         DC    X'3607010204A5'                     -STAND     STAND\n         DC    X'140204A4'                          - AND       AND\n         DC    X'14030AA4'                          - OLD       OLD\n         DC    X'360B06000AA5'                     -FIELD     FIELD\n         DC    X'141206A3'                           -WID       WID  E\n         DC    X'141406A3'                           -VID       VID\n         DC    X'140106A3'                           -TID       TID  E\n         DC    X'140706A3'                           -SID       SID  E\n         DC    X'140C06A3'                           -CID       CID\n         DC    X'250D0206A4'                        -MAID      MAID\n         DC    X'25010100A3'                         -TED      TTED\n         DC    X'140100A2'                            -ED       TED\n         DC    X'140000D0'                              #       EED\n         DC    X'360009090083'                       +DED     EDDED\n         DC    X'25090900A3'                         -DED      DDED\n         DC    X'360000090082'                        +ED     EEDED\n         DC    X'2600090002A3'                    - ED-ED      EDED\n         DC    X'140900A2'                            -ED       DED\n         DC    X'0300B1'                               /D        ED\n         DC    X'140302A4'                          - OAD       OAD\n         DC    X'3607010002A5'                     -STEAD     STEAD\n         DC    X'100002A4'                          - EAD       EAD\nESFX     EQU   *\n         DC    X'360707061484'                      +SIVE     SSIVE UOW\n         DC    X'25040007A4'                        -NESE      NESE\n         DC    X'14010583'                           +TRE       TRE\n         DC    X'3612080005A5'                     -WHERE     WHERE\n         DC    X'140905A3'                           -DRE       DRE\n         DC    X'140C05A3'                           -CRE       CRE\n         DC    X'141305A3'                           -BRE       BRE\n         DC    X'25100304A3'                         -ONE      YONE\n         DC    X'2500040484'                        +ENNE      ENNE\n         DC    X'14190AA3'                           -ZLE       ZLE\n         DC    X'14010AA3'                           -TLE       TLE\n         DC    X'14070AA3'                           -SLE       SLE\n         DC    X'14110AA3'                           -PLE       PLE\n         DC    X'3614060A0AA5'                     -VILLE     VILLE\n         DC    X'250C150AA2'                          -LE      CKLE\n         DC    X'14150AA3'                           -KLE       KLE\n         DC    X'2508060AA5'                       - HILE      HILE\n         DC    X'140F0AA3'                           -GLE       GLE\n         DC    X'140B0AA3'                           -FLE       FLE\n         DC    X'14090AA3'                           -DLE       DLE\n         DC    X'140C0AA3'                           -CLE       CLE\n         DC    X'48030102130A03A2'                -TA-BLE    OTABLE\n         DC    X'48060102130A03A2'                -TA-BLE    ITABLE\n         DC    X'371102130A03A2'                  -PA-BLE     PABLE\n         DC    X'360B02130AA3'                       -BLE     FABLE\n         DC    X'370C02130A03A2'                  -CA-BLE     CABLE\n         DC    X'2602130A03A1'                     -A-BLE      ABLE\n         DC    X'14130AA3'                           -BLE       BLE\n         DC    X'14020AA4'                          - ALE       ALE\n         DC    X'360506020FA5'                     -RIAGE     RIAGE\n         DC    X'2512060BA4'                        -WIFE      WIFE\n         DC    X'250F0500A4'                        -GREE      GREE\n         DC    X'250B0500A4'                        -FREE      FREE\n         DC    X'0300D0'                                #        EE\n         DC    X'100009A4'                          - EDE       EDE\nFSFX     EQU   *\n         DC    X'25090305A4'                        -DORF      DORF\n         DC    X'3611050303A5'                     -PROOF     PROOF\n         DC    X'030AA4'                            -  LF        LF\n         DC    X'200A060084'                        +LIEF      LIEF\nGSFX     EQU   *\n         DC    X'25030E05A5'                       - OURG      OURG\n         DC    X'0305A4'                            -  RG        RG\n         DC    X'0303A3'                             - OG        OG\n         DC    X'250A0304A4'                        -LONG      LONG\n         DC    X'3601010604A4'                      -TING     TTING\n         DC    X'3605050604A4'                      -RING     RRING\n         DC    X'3611110604A4'                      -PING     PPING\n         DC    X'3604040604A4'                      -NING     NNING\n         DC    X'360D0D0604A4'                      -MING     MMING\n         DC    X'36190A0604A5'                     -ZLING     ZLING\n         DC    X'36010A0604A5'                     -TLING     TLING\n         DC    X'36070A060484'                      +LING     SLING\n         DC    X'36050A0604A4'                      -LING     RLING\n         DC    X'36110A0604A5'                     -PLING     PLING\n         DC    X'4704150A0604A5'                   -KLING    NKLING\n         DC    X'36150A0604A4'                      -LING     KLING\n         DC    X'360F0A0604A5'                     -GLING     GLING\n         DC    X'360B0A0604A5'                     -FLING     FLING\n         DC    X'36090A0604A5'                     -DLING     DLING\n         DC    X'360C0A0604A5'                     -CLING     CLING\n         DC    X'36130A0604A5'                     -BLING     BLING\n         DC    X'471001080604A5'                   -THING    YTHING\n         DC    X'58000001080604A3'                   -ING   EETHING\n         DC    X'470001080604A5'                   -THING    ETHING\n         DC    X'360F0F0604A4'                      -GING     GGING\n         DC    X'3609090604A4'                      -DING     DDING\n         DC    X'3613130604A4'                      -BING     BBING\n         DC    X'140604A3'                           -ING       ING\n         DC    X'25000502A2'                          -AG      ERAG  E\n         DC    X'140002A2'                            -AG       EAG\n         DC    X'141502A2'                            -AG       KAG  E\n         DC    X'100902A2'                            -AG       DAG  E\nHSFX     EQU   *\n         DC    X'25030E01A5'                       - OUTH      OUTH\n         DC    X'140501A5'                         -  RTH       RTH\n         DC    X'140401B2'                            /TH       NTH\n         DC    X'25060001A3'                         -ETH      IETH\n         DC    X'250E0607A5'                       - UISH      UISH\n         DC    X'3605040607A4'                      -NISH     RNISH\n         DC    X'36110A0607A5'                     -PLISH     PLISH\n         DC    X'25130607A4'                        -BISH      BISH\n         DC    X'140607A3'                           -ISH       ISH\n         DC    X'360F050211A5'                     -GRAPH     GRAPH\n         DC    X'59130305030E0F04A3'            -BOR-OUGH   BOROUGH\n         DC    X'030FA5'                           -   GH        GH\n         DC    X'14060CA4'                          - ICH       ICH\n         DC    X'2513020CA4'                        -BACH      BACH\n         DC    X'14060202A2'                       - I-AH       IAH\n         DC    X'0002A3'                             - AH        AH\nISFX     EQU   *\n         DC    X'0308A3'                             - HI        HI\n         DC    X'100009A1'                             -I       EDI\nKSFX     EQU   *\n         DC    X'0305A4'                            -  RK        RK\n         DC    X'2512020AA4'                        -WALK      WALK\n         DC    X'140A06A3'                           -LIK       LIK  E\n         DC    X'2513020CA4'                        -BACK      BACK\n         DC    X'140002D0'                              #       EAK\n         DC    X'0002A3'                             - AK        AK\nLSFX     EQU   *\n         DC    X'140B0EA3'                           -FUL       FUL\n         DC    X'360708000AA5'                     -SHELL     SHELL\n         DC    X'360701020AA5'                     -STALL     STALL\n         DC    X'030AA4'                            -  LL        LL\n         DC    X'141400A2'                            -EL       VEL\n         DC    X'140E00A2'                            -EL       UEL\n         DC    X'141500A2'                            -EL       KEL\n         DC    X'140200A2'                            -EL       AEL\n         DC    X'25180E0294'                        *QUAL      QUAL\n         DC    X'140E0282'                            +AL       UAL\n         DC    X'370004010203A3'                 - EN-TAL     ENTAL\n         DC    X'140102A3'                           -TAL       TAL\n         DC    X'250E0502A2'                          -AL      URAL\n         DC    X'25000502A2'                          -AL      ERAL\n         DC    X'370F0304020381'                   +O-NAL     GONAL\n         DC    X'25030402A2'                          -AL      ONAL\n         DC    X'140402A3'                           -NAL       NAL\n         DC    X'25010602A4'                        -TIAL      TIAL\n         DC    X'25070602A4'                        -SIAL      SIAL\n         DC    X'250C0602A4'                        -CIAL      CIAL\n         DC    X'140602A2'                            -AL       IAL\n         DC    X'140F02A3'                           -GAL       GAL\n         DC    X'260500020282'                     +RE-AL      REAL\n         DC    X'26060C0212E1'                      $C/AL      ICAL\n         DC    X'101302A3'                           -BAL       BAL\nMSFX     EQU   *\n         DC    X'370305060E02A2'                   -RI-UM     ORIUM\n         DC    X'14060EA2'                            -UM       IUM\n         DC    X'14000E82'                            +UM       EUM\n         DC    X'030EA3'                             - UM        UM  E\n         DC    X'3606140607A3'                       -ISM     IVISM\n         DC    X'25010607A4'                        -TISM      TISM\n         DC    X'3603040607A3'                       -ISM     ONISM\n         DC    X'36060D0607A4'                      -MISM     IMISM\n         DC    X'36020A0607A3'                       -ISM     ALISM\n         DC    X'3607010305A5'                     -STORM     STORM\n         DC    X'0305A4'                            -  RM        RM\n         DC    X'140703A3'                           -SOM       SOM  E\n         DC    X'25050303A4'                        -ROOM      ROOM\n         DC    X'140903A3'                           -DOM       DOM\n         DC    X'140C03A3'                           -COM       COM  E\n         DC    X'140106A3'                           -TIM       TIM  E\n         DC    X'250F0502A4'                        -GRAM      GRAM\n         DC    X'140A02A4'                          - LAM       LAM  E\n         DC    X'100802A3'                           -HAM       HAM\nNSFX     EQU   *\n         DC    X'140312A4'                          - OWN       OWN\n         DC    X'3601080005A3'                       -ERN     THERN\n         DC    X'3607010005A3'                       -ERN     STERN\n         DC    X'0305A4'                            -  RN        RN\n         DC    X'25070103A4'                        -STON      STON  E\n         DC    X'140103A3'                           -TON       TON\n         DC    X'140703A3'                           -SON       SON\n         DC    X'3607110303A5'                     -SPOON     SPOON\n         DC    X'140303A4'                          - OON       OON\n         DC    X'5A0619020106030411E1'          $Z/A-TION   IZATION\n         DC    X'5A0A06020106030401A1'          -I-A-TION   LIATION\n         DC    X'2601060313E1'                     $T/ION      TION\n         DC    X'360707060384'                      +SION     SSION\n         DC    X'25070603A4'                        -SION      SION\n         DC    X'25040603A3'                         -ION      NION\n         DC    X'250F0603A4'                        -GION      GION\n         DC    X'140803A4'                          - HON       HON  E\n         DC    X'140C03A3'                           -CON       CON\n         DC    X'140506A3'                           -RIN       RIN\n         DC    X'141106A3'                           -PIN       PIN\n         DC    X'140406A3'                           -NIN       NIN\n         DC    X'140D06A3'                           -MIN       MIN\n         DC    X'250C0A06A4'                        -CLIN      CLIN  E\n         DC    X'140A06A3'                           -LIN       LIN\n         DC    X'141506A3'                           -KIN       KIN\n         DC    X'3607010006A5'                     -STEIN     STEIN\n         DC    X'25010206A4'                        -TAIN      TAIN\n         DC    X'030FA4'                            -  GN        GN  E\n         DC    X'360F080100A2'                        -EN     GHTEN\n         DC    X'3712030D0002A3'                  -WOM-EN     WOMEN\n         DC    X'140D00A3'                           -MEN       MEN\n         DC    X'25031500A3'                         -KEN      OKEN\n         DC    X'141500A2'                            -EN       KEN\n         DC    X'25010000A4'                        -TEEN      TEEN\n         DC    X'25070000A4'                        -SEEN      SEEN\n         DC    X'14070283'                           +SAN       SAN\n         DC    X'3712030D0202A3'                  -WOM-AN     WOMAN\n         DC    X'140D02A3'                           -MAN       MAN\n         DC    X'25010602A4'                        -TIAN      TIAN\n         DC    X'25070602A4'                        -SIAN      SIAN\n         DC    X'2500060283'                         +IAN      EIAN\n         DC    X'250C0602A4'                        -CIAN      CIAN\n         DC    X'140602B1'                             /N       IAN\n         DC    X'10000282'                            +AN       EAN\nOSFX     EQU   *\n         DC    X'0319A2'                              -ZO        ZO\n         DC    X'0307A2'                              -SO        SO\n         DC    X'140105A3'                           -TRO       TRO\n         DC    X'141105A3'                           -PRO       PRO\n         DC    X'2613030501A3'                     -BOR-O      BORO\n         DC    X'140905A3'                           -DRO       DRO\n         DC    X'140C05A3'                           -CRO       CRO\n         DC    X'0305A2'                              -RO        RO\n         DC    X'0303A3'                             - OO        OO\n         DC    X'2606020401A2'                      -AN-O      IANO\n         DC    X'0306A1'                               -O        IO\n         DC    X'0011A2'                              -PO        PO\nPSFX     EQU   *\n         DC    X'14030ED0'                              #       OUP\n         DC    X'030EA2'                              -UP        UP\n         DC    X'25070C03A4'                        -SCOP      SCOP  E\n         DC    X'20070806A4'                        -SHIP      SHIP\nRSFX     EQU   *\n         DC    X'2502070EA3'                          -UR      ASUR  E\n         DC    X'370B060F0E02A3'                  -FIG-UR     FIGUR  E\n         DC    X'030EA3'                             - UR        UR\n         DC    X'15070312E1'                        $S/OR       SOR\n         DC    X'25070103A4'                        -STOR      STOR  E\n         DC    X'15010312E1'                        $T/OR       TOR\n         DC    X'260506030282'                     +RI-OR      RIOR\n         DC    X'140803A4'                          - HOR       HOR  E\n         DC    X'0303A3'                             - OR        OR\n         DC    X'140806A4'                          - HIR       HIR  E\n         DC    X'25061900A2'                          -ER      IZER\n         DC    X'370C03140002A3'                  -COV-ER     COVER\n         DC    X'25031400A4'                        -OVER      OVER\n         DC    X'360E07010083'                       +TER     USTER\n         DC    X'3603070100A2'                        -ER     OSTER\n         DC    X'360607010083'                       +TER     ISTER\n         DC    X'360007010083'                       +TER     ESTER\n         DC    X'480D0207010003A3'               -MAS-TER    MASTER\n         DC    X'3602070100A2'                        -ER     ASTER\n         DC    X'25070100A4'                        -STER      STER\n         DC    X'3602050100A3'                       -TER     ARTER\n         DC    X'25050100A2'                          -ER      RTER\n         DC    X'370D0001000381'                   +E-TER     METER\n         DC    X'371202010003A2'                  -WA-TER     WATER\n         DC    X'140500A2'                            -ER       RER\n         DC    X'25031100A2'                          -ER      OPER\n         DC    X'371102110003A2'                  -PA-PER     PAPER\n         DC    X'25120400A2'                          -ER      WNER\n         DC    X'2507040083'                         +NER      SNER\n         DC    X'25030400A2'                          -ER      ONER\n         DC    X'25050D00A2'                          -ER      RMER\n         DC    X'25090A00A4'                        -DLER      DLER\n         DC    X'25130A00A4'                        -BLER      BLER\n         DC    X'141500A2'                            -ER       KER\n         DC    X'140600A2'                            -ER       IER\n         DC    X'3604010800A4'                      -THER     NTHER\n         DC    X'480B0201080004A2'               -FA-THER    FATHER\n         DC    X'25010800A2'                          -ER      THER\n         DC    X'25070800A2'                          -ER      SHER\n         DC    X'5A0F05021108000402B1'         /G-RA-PHER   GRAPHER\n         DC    X'3607110800A5'                     -SPHER     SPHER\n         DC    X'25110800A4'                        -PHER      PHER\n         DC    X'250C0800A2'                          -ER      CHER\n         DC    X'25090F00A2'                          -ER      DGER\n         DC    X'140000A4'                          - EER       EER\n         DC    X'25050900A2'                          -ER      RDER\n         DC    X'47030E040900A2'                      -ER    OUNDER\n         DC    X'250A0900A2'                          -ER      LDER\n         DC    X'370706090002A3'                  -SID-ER     SIDER\n         DC    X'36090E0C00A2'                        -ER     DUCER\n         DC    X'25040C00A2'                          -ER      NCER\n         DC    X'140002D0'                              #       EAR\n         DC    X'0002A3'                             - AR        AR\nSSFX     EQU   *\n         DC    X'250E030E83'                         +OUS      UOUS\n         DC    X'360005030EA3'                       -OUS     EROUS\n         DC    X'360106030EA5'                     -TIOUS     TIOUS\n         DC    X'360F06030EA5'                     -GIOUS     GIOUS\n         DC    X'360C06030EA5'                     -CIOUS     CIOUS\n         DC    X'2506030E83'                         +OUS      IOUS\n         DC    X'360F00030EA5'                     -GEOUS     GEOUS\n         DC    X'360C00030EA5'                     -CEOUS     CEOUS\n         DC    X'2500030E83'                         +OUS      EOUS\n         DC    X'14030EA4'                          - OUS       OUS\n         DC    X'030ED0'                                #        US\n         DC    X'25040007A4'                        -NESS      NESS\n         DC    X'250A0007A4'                        -LESS      LESS\n         DC    X'0307D0'                                #        SS\n         DC    X'140303A4'                          - OOS       OOS\n         DC    X'0303A3'                             - OS        OS  E\n         DC    X'141206A3'                           -WIS       WIS  E\n         DC    X'3711030A060381'                   +O-LIS     POLIS\n         DC    X'0306D0'                                #        IS\n         DC    X'141600A2'                            -ES       XES\n         DC    X'140700A2'                            -ES       SES\n         DC    X'25070800A2'                          -ES      SHES\n         DC    X'250C0800A2'                          -ES      CHES\n         DC    X'140C00A2'                            -ES       CES\n         DC    X'100F00A2'                            -ES       GES\nTSFX     EQU   *\n         DC    X'370213030E04A1'                  -A-BOUT     ABOUT\n         DC    X'14030EA3'                           -OUT       OUT\n         DC    X'140307A4'                          - OST       OST\n         DC    X'470603040607A3'                     -IST    IONIST\n         DC    X'3606040607A3'                       -IST     INIST\n         DC    X'36020A0607A3'                       -IST     ALIST\n         DC    X'480A030F060704A1'                -O-GIST    LOGIST\n         DC    X'3608010007A3'                       -EST     HTEST\n         DC    X'25060007A3'                         -EST      IEST\n         DC    X'360F0F0007A4'                      -GEST     GGEST\n         DC    X'360F080007A3'                       -EST     GHEST UOW\n         DC    X'250F0007A3'                         -EST      GEST\n         DC    X'3609090007A4'                      -DEST     DDEST\n         DC    X'25090007A3'                         -EST      DEST\n         DC    X'250C0207A4'                        -CAST      CAST\n         DC    X'0305A4'                            -  RT        RT\n         DC    X'140603A2'                            -OT       IOT\n         DC    X'360B050304A5'                     -FRONT     FRONT\n         DC    X'140604A5'                         -  INT       INT\n         DC    X'250D0004A4'                        -MENT      MENT\n         DC    X'360C060004A5'                     -CIENT     CIENT\n         DC    X'25060204A3'                         -ANT      IANT\n         DC    X'471205060F08A6'                  -WRIGHT    WRIGHT\n         DC    X'471305060F08A6'                  -BRIGHT    BRIGHT\n         DC    X'471200060F08A6'                  -WEIGHT    WEIGHT\n         DC    X'25060F08A5'                       - IGHT      IGHT\n         DC    X'360708060BA5'                     -SHIFT     SHIFT\n         DC    X'14020BA5'                         -  AFT       AFT\n         DC    X'25090F0082'                          +ET      DGET\n         DC    X'26010E0202A2'                     -TU-AT      TUAT\n         DC    X'25180E02A4'                        -QUAT      QUAT\n         DC    X'150E0202A1'                        -U-AT       UAT\n         DC    X'25010502A4'                        -TRAT      TRAT\n         DC    X'3601030502A2'                        -AT     TORAT\n         DC    X'250F0502A4'                        -GRAT      GRAT\n         DC    X'25000502A2'                          -AT      ERAT\n         DC    X'140302A4'                          - OAT       OAT\n         DC    X'3606030402A2'                        -AT     IONAT\n         DC    X'25000402A2'                          -AT      ENAT\n         DC    X'140602A2'                            -AT       IAT\n         DC    X'140002D0'                              #       EAT\n         DC    X'0002A3'                             - AT        AT\nUSFX     EQU   *\n         DC    X'0318A4'                            -  QU        QU  E\n         DC    X'48030401060401A3'                 -T1N-U    ONT1NU  E\n         DC    X'14030FA4'                          - OGU       OGU  E\n         DC    X'000FA5'                           -   GU        GU  E\nVSFX     EQU   *\n         DC    X'0305A4'                            -  RV        RV  E\n         DC    X'030AA4'                            -  LV        LV\n         DC    X'15010612E1'                        $T/IV       TIV  E\n         DC    X'15070612E1'                        $S/IV       SIV  E\n         DC    X'100600A4'                          - IEV       IEV\nWSFX     EQU   *\n         DC    X'20140600A4'                        -VIEW      VIEW\nXSFX     EQU   *\n         DC    X'101303A3'                           -BOX       BOX\nYSFX     EQU   *\n         DC    X'2500070182'                          +TY      ESTY\n         DC    X'140701A1'                             -Y       STY\n         DC    X'37180E06010282'                   +UI-TY     QUITY\n         DC    X'2601060102A2'                     -TI-TY      TITY\n         DC    X'37030706010281'                    +I-TY     OSITY\n         DC    X'2607060102A2'                     -SI-TY      SITY\n         DC    X'370604060102A1'                    -I-TY     INITY\n         DC    X'370004060102A1'                    -I-TY     ENITY\n         DC    X'370204060102A1'                    -I-TY     ANITY\n         DC    X'25040601A2'                       -NI-TY      NITY\n         DC    X'6B0B0213060A0601020183'        +BIL-I-TY  FABILITY\n         DC    X'6C0C0213060A0601020103A2'   -CA-BIL-I-TY  CABILITY\n         DC    X'6C110213060A0601020103A2'   -PA-BIL-I-TY  PABILITY\n         DC    X'5B0213060A0601020103A1'      -A-BIL-I-TY   ABILITY\n         DC    X'4913060A06010201A3'            -BIL-I-TY    BILITY\n         DC    X'15060102A1'                        -I-TY       ITY\n         DC    X'140801A1'                             -Y       HTY\n         DC    X'26130E0501A3'                     -BUR-Y      BURY\n         DC    X'2601030502A2'                     -TO-RY      TORY\n         DC    X'140005A1'                             -Y       ERY\n         DC    X'37180E020501A4'                  -QUAR-Y     QUARY\n         DC    X'260E02050182'                      +AR-Y      UARY\n         DC    X'5A0D00040102050202A3'         -MEN-TA-RY   MENTARY\n         DC    X'48060304020501A2'                  -AR-Y    IONARY\n         DC    X'2606020501A2'                      -AR-Y      IARY\n         DC    X'2604030D02A1'                      -O-MY      NOMY\n         DC    X'14110AA3'                           -PLY       PLY\n         DC    X'250F0F0AA3'                         -GLY      GGLY\n         DC    X'371102130A03A2'                  -PA-BLY     PABLY\n         DC    X'360B02130AA3'                       -BLY     FABLY\n         DC    X'370C02130A03A2'                  -CA-BLY     CABLY\n         DC    X'2502130AA4'                        -ABLY      ABLY\n         DC    X'14130AA3'                           -BLY       BLY\n         DC    X'030AA2'                              -LY        LY\n         DC    X'14191582'                            +KY       ZKY\n         DC    X'250E0715A1'                           -Y      USKY\n         DC    X'140715A3'                           -SKY       SKY\n         DC    X'0315A1'                               -Y        KY\n         DC    X'490F050211080302B1'              -RA-PHY    GRAPHY\n         DC    X'140C08A1'                             -Y       CHY\n         DC    X'260A030F02A1'                      -O-GY      LOGY\n         DC    X'030BA2'                              -FY        FY\n         DC    X'140400A3'                           -NEY       NEY\n         DC    X'140A00A3'                           -LEY       LEY\n         DC    X'250C1500A2'                          -EY      CKEY\n         DC    X'14150083'                           -KEY       KEY\n         DC    X'25030309A1'                           -Y      OODY\n         DC    X'2613030901A3'                     -BOD-Y      BODY\n         DC    X'2500000981'                           +Y      EEDY\n         DC    X'0313A2'                              -BY        BY\n         DC    X'2602120203A1'                     -A-WAY      AWAY\n         DC    X'141202A3'                           -WAY       WAY\n         DC    X'100902A3'                           -DAY       DAY\nZSFX     EQU   *\n         DC    X'140106A3'                           -TIZ       TIZ  E\n         DC    X'25020506A2'                          -IZ      ARIZ  E\n         DC    X'25020406A2'                          -IZ      ANIZ  E\n         DC    X'25020A06A2'                          -IZ      ALIZ  E\n         DC    X'370205090602A3'                  -ARD-IZ     ARDIZ  E\n         DC    X'25060A06A3'                         -LIZ      ILIZ  E\n         DC    X'20060C0612E1'                      $C/IZ      ICIZ  E\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DEUH18": {"ttr": 4357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x004\\x004\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "CBT249"}, "text": "*                             ********\n* *            SOURCE BOOK *** DEUH18 *** EXCEPTION WORD ANALYSIS\n*                             ********\n         SPACE\nEXCEPT  $ENTER ,\n*        WAS   DEUHYD01\n         SPACE\n         MVC   HYWKWORD,HYFCOM     ENTER STRING TO PROCESS\n        $CALL  DCOMPOZ             GO TO DCOMPOSE ROUTINE\n         CLI   HYDCWORD+1,X'1A'    IF DCOMWD IS ALL 1A'S -\n         BE    XNOHIT                GET OUT OF EXCEPT\n         SPACE\n         LR    REGWK1,REG1         INTERNAL FIRST CHARACTER\n         SLL   REGWK1,2            TIMES FOUR\n         L     REGWK1,HYANCH(REGWK1)    LETTER ANCHOR\n         USING HYDSECT,REGWK1      AND TELL THE ASSEMBLER\nEXCEP01  DS    0H\n         LTR   REGWK1,REGWK1       AT THE END OF LETTER CHAIN .Q\n         BZ    XNOHIT              YES, WORD NOT FOUND\n         CLC   HYWORD,HYWKWORD     COULD IT BE THIS WORD .Q\n         BE    HITXIT              BRANCH IF YES\n         L     REGWK1,HYCHN        NEXT WORD POINTER\n         B     EXCEP01             AND CONTINUE SEARCHING\n         SPACE\nHITXIT   XC    HYFCOM,HYFCOM        CLEAR AREA\n         LH    REG1,NUMCHR         GET THE WORD SIZE\n         EX    REG1,CLRASTAT       RESET ASTATUS BYTES TO NO\n         UNPK  HYFCOM(9),HYBRK(5)  GET ZWORD INDICATOR BYTES\n         TR    HYFCOM(8),BINHEX-240   TRANSLATE TO BINARY VALUES\n         LA    REGWK3,HYFCOM       INITIALIZE INDICATOR BYTE POINTER\n         LA    REGIX1,0            SET INDEX TO ZERO\n         LA    REG1,ASTATUS-1      INITIALIZE POINTER TO ASTATUS.\nNXTIND   CLI   0(REGWK3),X'F0'     IS THIS THE LAST INDICATOR BYTE\n         BE    FNDXIT              IF YES-PREPARE TO EXIT\n         IC    REGIX1,0(REGWK3)    GET NEXT INDICATOR BYTE\n         AR    REG1,REGIX1            AND ADD IT TO ASTATUS POINTER.\n         OI    0(REG1),YESXCPT     SET POINT IN ASTATUS TO YES.\n         LA    REGWK3,1(REGWK3)    BUMP POINTER TO NEXT INDICATOR\n         B     NXTIND              LOOP BACK TO COMPARE NEXT BYTE\nFNDXIT  $CC    POS                 SET SUCCESSFUL SEARCH\n         B     EXCEPRET            GO TO FINAL RETURNE\n         SPACE\nCLRASTAT XC    ASTATUS-1(0),ASTATUS-1\n         SPACE\nXNOHIT   DS    0H\n        $CC    NEG                 NO HIT CODE\n         SPACE\nEXCEPRET DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\n         DROP  REGWK1\nYESXCPT  EQU   X'70'               BREAK YES FLAG\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DEUH24": {"ttr": 4359, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x01\\x01\\x01\\x01\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 257, "newlines": 257, "modlines": 0, "user": "CBT249"}, "text": "*                       ********\n* *      SOURCE BOOK *** DEUH24 *** PROBABILITY ALGORITHM (HALGO)\n*                       ********\n         SPACE 3\nHALGO   $ENTER ,\n*        WAS   DEUHYH01\n         SPACE\n*\n*\n*\n*                            HALGO\n*\n*\n*             ANY TIME THE -HYPHEN-MODULE FAILS TO FIND ALL THE\n*        DIVISION POINTS OF A WORD EITHER BY SUFFIX ANALYSIS OR\n*        EXCEPTION WORDS, THE - HALGO - PHASE IS EXECUTED.\n*\n*              THE PURPOSE OF THIS PHASE IS TO GENERATE THE\n*        PROBABILITY FOR HYPHEN POINTS AT ALL REMAINING POINTS IN THE\n*        WORD, AND TO SELECT THE HIGHEST VALUES BETWEEN NON-\n*        CONTIGUOUS VOWELS AS HYPHEN POINTS. IN THE CASE OF CONTIGUOUS\n*        VOWELS, THE POINT IS SELECTED IF THE VALUE IS GREATER THAN\n*        A MINIMUM.\n*\n*              ALL PROBABILITIES ARE FOUND BY UTILIZING SIX TABLES\n*        LOCATED IN CORE MEMORY. THEIR FUNCTIONS ARE SUMMARIZED BELOW-\n*\n*        TABLE      SIZE           GIVES PROBABILITY OF\n*        *****     *****           ********************\n*\n*        BXHTB      1X26           A HYPHEN POINT AFTER THE BEGINNING\n*                                  CHARACTER IN A WORD.\n*        EHXTB      1X26           A HYPHEN POINT BEFORE THE TERMINAL\n*                                  CHARACTER IN A WORD.\n*        BXXHTB    26X26           A HYPHEN POINT OCCURRING AFTER THE\n*                                  FIRST TWO CHARACTERS IN A WORD.\n*        HXXTB     26X26           A HYPHEN POINT OCCURRING BEFORE ANY\n*                                  TWO CHARACTERS INTERNALLY IN A WORD.\n*        XHXTB     26X26           A HYPHEN POINT OCCURRING BETWEEN ANY\n*                                  TWO CHARACTERS INTERNALLY IN A WORD.\n*        XXHTB     26X26           A HYPHEN POINT OCCURRING AFTER ANY\n*                                  TWO CHARACTERS INTERNALLY IN A WORD.\n*\n*              NOTE THAT ALL OF THESE TABLES ARE ARRANGED ACCORDING TO\n*        THE HYPHENATION FREQUENCY CODING, AND ARE ADDRESSED IN A\n*        MANNER SUCH THAT THE FIRST LETTER OF THE TWO-CHARACTER SET\n*        CORRESPONDS TO THE Y-AXIS, AND THE SECOND TO THE X-AXIS. THIS\n*        SCHEME PERMITS THE USE OF SIMPLE RELATIVE ADDRESSING\n*        TECHNIQUES IN ACCESSING THE TABLES.\n*\n*              THE TABLES CONSIST OF ONE-BYTE BINARY NUMBERS.\n*\n*              - HALGO- BEGINS BY GENERATING THE RELATIVE TABLE\n*        ADDRESSES FOR ALL TWO-CHARACTER COMBINATIONS IN THE WORD.\n*        SINCE THE PROBABILITY TABLES ARE ARRANGED IN FREQUENCY-CODING\n*        ORDER, THIS CAN BE ACCOMPLISHED BY MULTIPLYING THE LEFTMOST\n*        CHARACTER BY 26 AND ADDING THE RIGHTMOST CHARACTER.\n*\n*              ANALYSIS THEN PROCEEDS BY MOVING ACROSS THE WORD FROM\n*        LEFT TO RIGHT, GENERATING THE ACTUAL PROBABILITY VALUE\n*        ADDRESSES BY ADDING THE RELATIVE ADDRESS TO THE APPROPRIATE\n*        SET OF BASE TABLE ADDRESSES AND COMPUTING THE RESULTING\n*        PROBABILITIES.\n*              AFTER ALL THE PROBABILITIES ARE GENERATED, THE - SELHYP-\n*       ROUTINE SELECTS AND MARKS A POINT IN EACH HYPHEN FIELD WHICH\n*       HAS THE HIGHEST PROBABILITY VALUE WITHIN THE HYPHEN FILED. AN\n*       EXIT IS THEN MADE TO -HYPHEN-.\n*\n*\n*\n*\n*\n*  REGAB USUALLY CONTAINS A VALUE OF 26*C1+C2, WHERE C1 AND C2 ARE A\n*        PAIR OF CONSECUTIVE LETTERS IN A WORD.  IT IS USED TO POINT\n*        TO THE PROBABILITY FOR A HYPHEN AFTER A PAIR OF CHARACTERS\n*        (XX-).  IT IS INITIALLY SET TO POINT TO A SPECIAL TABLE FOR\n*        HYPHENS AFTER THE FIRST LETTER IN A WORD (WHEN C1 = 0).\n*\n*  REGBC WILL CONTAIN THE VALUE OF 26*C2+C3 WHERE C2 AND C3 ARE THE\n*        PAIR OF LETTERS FOLLOWING C1.  IT IS USED TO POINT TO THE\n*        PROBABILITY FOR A HYPHEN BETWEEN A PAIR OF CHARACTERS (X-X).\n*\n*  REGCD WILL USUALLY CONTAIN THE VALUE OF 26*C3+C4 WHERE C3 AND C4 ARE\n*        THE PAIR OF LETTERS FOLLOWING C2.  IT IS USED TO POINT TO THE\n*        PROBABILITY FOR A HYPHEN PRECEEDING A PAIR OF LETTERS (-XX).\n*        IT IS ULTIMATELY SET TO POINT TO A SPECIAL TABLE FOR HYPHENS\n*        PRECEEDING THE LAST LETTER IN A WORD (C4=0).\n*\n*  REGCHR CONTAINS THE NEXT LETTER IN THE WORD (C5).\n*\n*   AFTER COMPUTING A HYPHEN POINT VALUE, THE FOLLOWING STEPS ARE\n*        EXECUTED FOR THE FOUR REGISTERS ABOVE\n*              1.  LOAD REGBC INTO REGAB\n*              2.  LOAD REGCD INTO REGBC\n*              3.  LOAD REGCHR INTO REGCD\n*              4.  LOAD NEXT CHARACTER INTO REGCHR\n*              5.  LOAD REGCD*26+REGCHR INTO REGCD\n*\n*\n*  RCCHTB USUALLY CONTAINS THE ADDRESS OF THE TABLE OF PROBABILITIES\n*        FOR HYPHENS AFTER LETTER PAIRS(XX-).  INITIALLY CONTAINS THE\n*        ADDRESS OF A SPECIAL TABLE OF PROBABILITIES FOR HYPHENS AFTER\n*        THE FIRST LETTER OF THE WORD.  IT IS USED IN CONJUNCTION WITH\n*        REGAB.\n*\n*  RCHCTB CONTAINS THE ADDRESS OF THE TABLE OF PROBABILITIES FORHYPHENS\n*        BETWEEN LETTER-PAIRS(X-X).  IT IS USED IN CONJUNCTION WITH\n*        REGBC.\n*\n*  RHCCTB  USUALLY CONTAINS THE ADDRESS OF THE TABLE OF PROBABILITIES\n*        FOR HYPHENS BEFORE LETTER-PAIRS (-XX).  FINALLY CONTAINS THE\n*        ADDRESS OF A SPECIAL TABLE OF PROBABILITIES OF HYPHENS BEFORE\n*        THE LAST LETTER IN THE ROOT WORD.  IT IS USED IN CONJUNCTION\n*        WITH REGCD.\n*\n*  REGPRO  IS USED TO DEVELOP THE PRODUCT OF THE THREE PROBABILITIES.\n*\n*  REGIX1  IS THE INDEX TO THE NEXT LETTER IN THE WORD TO BE PROCESSED.\n*        IT ALSO CONTROLS THE ADDRESSES LOADED INTO RCCHTB AND RHCCTB.\n*        THE HYPHEN POINT BEING PROCESSED IS AT REGIX1-2.\n*\n*\n*\n*\n*\nREGPRO   EQU   1\nRCCHTB   EQU   2\nREGBST   EQU   2\nRCHCTB   EQU   3\nREGIX2   EQU   3\nREGBC    EQU   4\nREGCD    EQU   5\nREGSYL   EQU   7\nRHCCTB   EQU   7\nREGAB    EQU   8\nREGCHR   EQU   9\nYES      EQU   X'30'\nYESHLGO  EQU   X'F0'\n*\n*\n         EJECT\n*\n*\n         LA    RCCHTB,BXHTB        LOAD TABLE ADDRESSES\n         LA    RCHCTB,XHXTB\n         LA    RHCCTB,HXXTB\n*\n         SR    REGBC,REGBC         CLEAR THE REGISTER\n         IC    REGBC,HYFCOM        GET THE FIRST CHARACTER\n         LR    REGCD,REGBC\n         MH    REGCD,BIN26+2       MLTPLY BY 26 FOR Y AXIS\n         SR    REGCHR,REGCHR       CLEAR CHARACTER REGISTER\n         IC    REGCHR,HYFCOM+1     GET 2ND CHARACTER\n         AR    REGCD,REGCHR        ADD ITS VALUE FOR X AXIS\n         LA    REGIX1,2            INITIALIZE INDEX REGISTER\n         SR    REGWK0,REGWK0       CLEAR THE WORK REGISTER\n         ST    REGWK0,PROBS\n         MVC   PROBS+4(L'PROBS*28),PROBS    CLEAR PROB. SAVE AREA\nNXTPRB   LR    REGAB,REGBC         TO GET AT NEXT DIGRAPH\n         LR    REGBC,REGCD         SLIDE THE REGISTERS\n         LR    REGCD,REGCHR\n         EX    REGIX1,CMPLMT\n         BL    CKSTAT                   BYPASS BUILDING OF LAST DIGRAPH\n         IC    REGCHR,HYFCOM(REGIX1)\n         MH    REGCD,BIN26+2       TO GET Y AXIS\n         AR    REGCD,REGCHR        TO GET X AXIS\nCKSTAT   LA    REGPRO,ASTATUS-2(REGIX1) GET ADDRESS OF POINT IN STATUS\n         TM    0(REGPRO),YES            IS IT POSSIBLE\n         BM    GTPRBS                   BRANCH IF IT IS.\n         LNR   REGPRO,REGPRO            IF NOT - SET PROB. VALUE TO NEG\n         B     STPRBS                   AND GO STORE IT.\n*\n*\n* THIS ROUTINE CALCULATES THE PRODUCT OF THE PROBABILITIES OF THE THREE\n* DIGRAPHS ABOUT A HYPHEN POINT.\n*\nGTPRBS   SR    REGPRO,REGPRO       CLEAR PROBABILITY REGISTER\n         IC    REGWK0,0(REGCD,RHCCTB) GET PROBABILITY OF -XX\n         STH   REGWK0,SAVEODD+2    SAVE FOR MULTIPLICATION\n         IC    REGWK0,0(REGBC,RCHCTB) GET PROBABILITY OF X-X\n         STH   REGWK0,SAVEODD      SAVE FOR MULTIPLICATION\n         IC    REGPRO,0(REGAB,RCCHTB) GET PROBABILITY OF XX-\n         MH    REGPRO,SAVEODD      TO GET PRODUCT OF  A X B\n         MH    REGPRO,SAVEODD+2    TO GET PRODUCT OF  (AXB) X C\nSTPRBS   SLL   REGIX1,2 BECAUSE PROBABILITY SAVE AREAS ARE FULL WORDS\n         ST    REGPRO,PROBS-8(REGIX1) SAVE THE PROBABILITY\n         SRL   REGIX1,2            RESTORE TO ORIGINAL INDEX VALUE\n         EX    REGIX1,CMPLMT       IF ALL PROBS ARE STORED,\n         BL    SELHYP         GO TO ROUTINE TO SELECT THE BEST POINTS\n         LA    REGIX1,1(0,REGIX1)  INCREMENT THE INDEX REGISTER\n         C     REGIX1,BIN4 DID WE PASS THE BEGINNING OF THE WORD\n         BL    BXHDUN              NOT QUITE - ONE MORE TO GO\n         BE    BXXHDN              NOW WE DID\n         EX    REGIX1,CMPLMT       DID WE REACH THE END OF THE WORD\n         BNL   NXTPRB              NO, MORE TO GO\n         LA    RHCCTB,EHXTB\n         B     NXTPRB\nBXHDUN   LA    RCCHTB,BXXHTB\n         B     NXTPRB\nBXXHDN   LA    RCCHTB,XXHTB\n         B     NXTPRB\n*\nCMPLMT   CLI   NUMCHR+1,X'00'\n*\n*\n*  THE FOLLOWING SUBROUTINE SELECTS THE BEST HYPHEN POINT BETWEEN\n*  VOWELS.  CONTIGUOUS VOWELS ARE TREATED UNIQUELY.\n*\nSELHYP   CLC   FIRSTVOW,NUMCHR     ANY VOWELS BEFORE LAST LETTER\n         BNL   HEXIT               IF NO,EXIT HALGO\n         LA    REGWK2,255\n         STH   REGWK2,BSTPNT       INITIALIZE BSTPNT & LSTBST\n         LA    REGNCR,1\n         LH    REGIX1,FIRSTVOW     SET POINTERS TO FIRST VOWEL\n         LH    REGLMT,LASTVOW      PROCESS ONLY AS FAR AS LAST VOWEL\n         LR    REGIX2,REGIX1\n         SLL   REGIX2,2            MLTPLY BY 4,PROBS ARE FULL WORDS\nCPRPROB1 L     REGBST,PROBS(REGIX2)\n         LTR   REGBST,REGBST       IS PROBABILITY NEGATIVE\n         BM    SCNPRB              BR IF YES\n         STC   REGIX1,BSTPNT       SAVE PROBABILITY AS BEST SO FAR\nSCNPRB   LA    REG1,ASTATUS(REGIX1) GET NEXT CHARACTER\n         TM    1(REG1),X'01'       IS IT A VOWEL\n         BZ    CPRPROB             BRANCH IF NOT\n         TM    0(REG1),X'01'       IS PREVIOUS CHAR A VOWEL\n         BZ    SETHYP              BRANCH IF NO\n         L     REG1,MINPRB\n         C     REG1,PROBS(REGIX2)  IS PROBABILITY ABOVE MINIMUM\n         BH    SETHY1              BR IF NO\nSETHYP   IC    REGWK2,BSTPNT       GET ADDRESS OF BEST POINT\n         LA    REG1,ASTATUS(REGWK2)\n         CLC   BSTPNT,LSTBST       SAME AS PREVIOUS BEST POINT\n         BE    SETHY1              BRANCH IF YES\n         TM    0(REG1),YES         IS POINT A -NO- IN STATUS\n         BZ    SETHY1              BRANCH IF IT'S A NO  IN STATUS\n         OI    0(REG1),YESHLGO     IF NOT,SET IT TO YES STATUS\n         STC   REGWK2,LSTBST       STORE POINT AS PREV. BEST POINT\nSETHY1   LNR   REGBST,REGBST       SET BEST SO FAR TO NEGATIVE\nCPRPROB  BXH   REGIX1,REGNCR,HEXIT BRANCH IF ALL CHARACTERS SCANNED\n         LA    REGIX2,4(0,REGIX2)  GET NEXT PROBABILITY\n         C     REGBST,PROBS(REGIX2)     IS IT HIGHER THAN BEST SO FAR\n         BNL   SCNPRB\n         B     CPRPROB1\n*\n* HALGO EXITS AFTER RECORDING --ALL-- HYPHEN POINTS IN ROOT WORD.\n*\nHEXIT    DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\nPROBS    DS    29F\nMINPRB   DC    F'125000'\n*\n*\n         DS    0H\nBSTPNT   DS    CL1                 MUST BE HALF-WORD BOUNDARY\nLSTBST   DS    CL1\n         LTORG\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DEUH25": {"ttr": 4364, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00v\\x00v\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 118, "newlines": 118, "modlines": 0, "user": "CBT249"}, "text": "*                       ********\n* *      SOURCE BOOK *** DEUH25 *** PROBABILITY TABLES\n*                       ********\n         SPACE 3\n*\n*\n*                E T A O N R I S H D L F C M U G Y P W B V K X J Q Z\nBXHTB   DC    X'0A00140A00000A000000000000000F000A000000000000000000'\n*                E T A O N R I S H D L F C M U G Y P W B V K X J Q Z\nEHXTB   DC    X'0100140A00000A000000000000000A000A000000000000000000'\n*                E T A O N R I S H D L F C M U G Y P W B V K X J Q Z\nBXXHTB  DC    X'0A230F1E32281419000A2D23283241281937321428235F0A0F37' E\n        DC    X'0500232300001900000000000000280005000000000000000000' T\n        DC    X'2814001E3C2814320A32284628284B14322D1E1E323C5F0F2328' A\n        DC    X'281E0A002823142D002332321E2800283C23373714325F000019' O\n        DC    X'05001E1E0000280000000000000023000F000000000000000000' N\n        DC    X'2300231900001400000000000000230005000000000000000000' R\n        DC    X'231414055F320019001E321E0A5F00280032002314145F001E23' I\n        DC    X'05001E140000140000000000000014000A000000000000000000' S\n        DC    X'1900190F00001900000000000000190023000000000000000000' H\n        DC    X'1E00191900003200000000000000280014000000000000000000' D\n        DC    X'0F001E14000014000000000000002D000F000000000000000000' L\n        DC    X'0500140F00001400000000000000190000000000000000000000' F\n        DC    X'0A0019140000140000000000000037000F000000000000000000' C\n        DC    X'0F001E0A00001E000000000000002D000F000000000000000000' M\n        DC    X'0A19141928281E0F0F1E1E371E1E002D0A19003200195F00003C' U\n        DC    X'0A00140F00000F0000000000000019000A000000000000000000' G\n        DC    X'141914230A280032000A32000F3737320028001E003241000014' Y\n        DC    X'0F001E2300002D00000000000000140028000000000000000000' P\n        DC    X'0000050000000500000000000000000014000000000000000000' W\n        DC    X'1E001919000023000000000000001E0014000000000000000000' B\n        DC    X'050023140000280000000000000014000A000000000000000000' V\n        DC    X'0500321E000028000000000000001E000A000000000000000000' K\n        DC    X'2D0023230000320000000000000000003C000000000000000000' X\n        DC    X'0A000F0F00000500000000000000190000000000000000000000' J\n        DC    X'0000000000000000000000000000000000000000000000000000' Q\n        DC    X'05003C3200001E0000000000000032003C000000000000000000' Z\n*                E T A O N R I S H D L F C M U G Y P W B V K X J Q Z\nHXXTB   DC    X'0A190A0A14320A1400140A05050F050F0F05050F050500000505' E\n        DC    X'1E003C50002D32000A0001000000410055000000000000000000' T\n        DC    X'0A14000F140F050A140A19050A14051E050A052805050505000F' A\n        DC    X'0A0F05000F0A0F0F051414050F0A141E0514050505050500230F' O\n        DC    X'2800323700002D00000000000000140041000000000000000000' N\n        DC    X'0F00191900001E001E0000000000140028000000000000000000' R\n        DC    X'14280F0A190505231914141E2D19140F000A2D14050F000A142D' I\n        DC    X'190A233C01004100050005000A012300190F0500010A00000100' S\n        DC    X'0500050500000500000000000000050000000000000000000000' H\n        DC    X'1E0041410032280014000100000037002D000000000000000000' D\n        DC    X'190032280000280000000000000028003C000000000000000000' L\n        DC    X'2300192300143700000023000000320000000000000000000000' F\n        DC    X'2D003719002341001E0032000000320050000000000000000000' C\n        DC    X'2300323700002D00000000000000280041000000000000000000' M\n        DC    X'0A05191E0F0F0A0500051E05050F320505050005050000000000' U\n        DC    X'1E00322D002337000A0032000000280050000000000000000000' G\n        DC    X'0A0F190A14050A192D0500000A142D230005192300000F00000A' Y\n        DC    X'23001E28000F23003200320000001E001E000000000000000000' P\n        DC    X'05002319000505000500000000004B0000000000000000000000' W\n        DC    X'3200282D002D4600140028000000230050000000000000000000' B\n        DC    X'19002D2D00282800000000000000370023000000000000000000' V\n        DC    X'0F00281E0514140037001900000028000F001900000000000000' K\n        DC    X'0000000000000000000000000000000000000000000000000000' X\n        DC    X'2800191900000F000000000000001E0000000000000000000000' J\n        DC    X'0000000000005F000000000000002D0000000000000000000000' Q\n        DC    X'0A004B41000023005F005F00000028001E000000000000000000' Z\n*                E T A O N R I S H D L F C M U G Y P W B V K X J Q Z\nXHXTB   DC    X'0023142D1405140A5A0A1E3C28140F37051E1E4B2D1E005A5519' E\n        DC    X'145A0F055F0A192D005F1E5F055F0A5F055F285F325F00005F23' T\n        DC    X'0F3205280F0F140F2D230A0A280F00190A280F41281900553237' A\n        DC    X'14281E0A141E0F1E5532231E37140032052D051E3714005F5546' O\n        DC    X'143C140F5F5F23555F465F5F325F1914144B5F5F5F2D005F5F50' N\n        DC    X'0F28140F46501E4632324B554B46054B28505F5A462D005F5050' R\n        DC    X'14323C1414195F0A5F1E1E4128145F235F235F41142D005F2D0F' I\n        DC    X'0A2314050F5F0F32005F145F280F055F0A19055F0114005F1400' S\n        DC    X'14230A0A4B0A19555F5F285F5A4B0500145F325F5F5F00005A00' H\n        DC    X'0F320F055F0F1E46375F145F5F5F1405195F3C5F5F5F005F5F5F' D\n        DC    X'0A460A194B5F23555F2D5A4B5F4B0A550F4B5F5F4632005F325F' L\n        DC    X'141905005F050F325F5F0550015F055F0F5F0000000000000000' F\n        DC    X'0555050F5F0F1919005F0F005F5F1900005F005F000500005F5F' C\n        DC    X'143C14195F5F2D555F465F5F325F1414144B5F5F5F4B005F5F55' M\n        DC    X'0F3C2D410F23140A4128320F28145F192D4B5F2D5F19005F5F14' U\n        DC    X'0F0F0F194B14284B005F0A5F004B195A0A5F5F5F005F0000005F' G\n        DC    X'4123414B23375F1E5A50235F4B23373200285F464132005F5F19' Y\n        DC    X'0A550A0F46051E3C005F05375F460A5F145A5F5F5F5F00000000' P\n        DC    X'235505001E050A410541145FFF1E005F55325F5F010101010101' W\n        DC    X'0A5F050F5F050A5F465F235F5F5F0F000A5F5F5A5F5F005F0000' B\n        DC    X'0F0114145F3C1E0000000100015F05003C0000005F000000005F' V\n        DC    X'375F19191E1932415F5F4B5F011E005F4B324B5F005A00000000' K\n        DC    X'5F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5F465F5F5F5F5F5F5F5F5F' X\n        DC    X'05000000000005000001000000000500005F0000000100000000' J\n        DC    X'0000000000000000000000000000000000000000000000000000' Q\n        DC    X'195F0F0A01002D00004101000000285F2D00015F5F5F0000005A' Z\n*                E T A O N R I S H D L F C M U G Y P W B V K X J Q Z\nXXHTB   DC    X'0A23051E323C05190A0A2D232D3241281937321432325F0A0F32' E\n        DC    X'05052323000019012D000000000028000500000000005F000001' T\n        DC    X'28140F23323C0A190A32284B2832372D322D231E323C5F0F2328' A\n        DC    X'281E0F142828142D052332321E2805283C23373728325F00052D' O\n        DC    X'14051E1E01002805000F00000A002D1E0F14000501325F000005' N\n        DC    X'1E2D23230A002D0A0014140F050A230A050A000514285F000000' R\n        DC    X'0514140523320519051E321E0A230532003200231E1E5F001E23' I\n        DC    X'0F231E280000230528000000000019000F05000000145F000001' S\n        DC    X'192319230500280F00000500000519002300000000005F000000' H\n        DC    X'1E00191900003C0505050000000028011400000000005F050000' D\n        DC    X'0F0F1E280F0028050023050A050F2D050F1400000A2D5F000000' L\n        DC    X'0A41140F00002D320000000F000019000000000000005F000000' F\n        DC    X'0A051914000023000A000000000037000F00000000505F000000' C\n        DC    X'14051E1E00002805000F00000A0037050F14000500325F000005' M\n        DC    X'0A1919192D281E190F1E1E371E1E002D0F190032001E5F000041' U\n        DC    X'0F00231E0100230A0F00000000001E000F00000000005F000000' G\n        DC    X'1419142337280037000A28010F37370F0028001E00325F000019' Y\n        DC    X'0F051E2300002D0514000000000019002800000000005F000000' P\n        DC    X'05000A0537000A23001E4600003700000A320000004B5F000055' W\n        DC    X'0F051919000023050000000000001E001400000000005F000000' B\n        DC    X'0A00232300002D0000000000000014000000000000005F000000' V\n        DC    X'05003223000028000500000000001E000A00000000005F000000' K\n        DC    X'2D0023230000320000000000000000003C00000000005F000000' X\n        DC    X'0A00190F0000050000000000000032000000000000005F000000' J\n        DC    X'000000000000320000000000000000000000000000005F000000' Q\n        DC    X'05003C370000230000000000000032002300000000005F000005' Z\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DH": {"ttr": 4611, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x86\\x00\\x86\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 134, "newlines": 134, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .DH (DEFINE HEADER) --- CONTROL                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nDH      $ENTER ,\n        $CALL  GETYESNO            CHECK FOR SET OPERAND\n         BC    BOMIT,DHE003        BRANCH IF NO ARGUMENTS AT ALL\n         CLI   YNRESULT,YNSET      WAS SET SPECIFIED .Q\n         BNE   DH03                BRANCH IF NO\n        $CALL  GETNUM              GET SET OPERAND\n         BC    BOMIT,DHE003        ERROR IF OMITTED\n         BC    BDNO,DHE035         ERROR IF NOT NUMERIC\n         CLI   NUMSIGN,C' '        WAS OPERAND UNSIGNED .Q\n         BE    DH01                BRANCH IF YES\n         A     COUNT,DHNUMTC       MAKE RELATIVE CHANGE\nDH01     DS    0H\n         LTR   COUNT,COUNT         IS OPERAND BIG ENOUGH .Q\n         BM    DHE014              ERROR IF TOO SMALL\n         LA    X3,DHMAXTC          GET MAX # OF TABLE OF CONTENTS\n         CR    X3,COUNT            CHECK VALUE AGAINST MAX\n         BNH   DHE013              BRANCH IF TOO HIGH\n         ST    COUNT,DHNUMTC       SET TABLE OF CONTENTS NUMBER\n         SLL   COUNT,2             MULTIPLY TABLE NUMBER BY 4\n         L     TEMP,DHANCH(COUNT)  OBTAIN ANCHOR POINTER\n         LTR   TEMP,TEMP           HAS ADDRESS BEEN ASSIGNED .Q\n         BNZ   DH02                BRANCH IF YES\n        $CALL  DHCLR               INITIALIZE TABLE AND SET ADDRESS\nDH02     DS    0H\n        $CALL  GETNUM              GET HEAD LEVEL NUMBER\n         BC    BOMIT,DHDONE        BRANCH IF THAT'S ALL\n         B     DH04                ELSE CONTINUE WITH CHECKS\n         SPACE\nDH03     DS    0H\n         ST    COUNT,ARGSTART      RESET STARTING SCAN PTR\n        $CALL  GETNUM              GET HEAD LEVEL NUMBER\nDH04     DS    0H\n         BC    BOMIT,DHE003        ISSUE ERROR IF OMITTED\n         BC    BDNO,DHE035         ISSUE ERROR IF NOT NUMERIC\n         BC    BNEG,DHE014         ISSUE ERROR IF NEGATIVE\n         LA    X3,DHMAX            GET MAXIMUM HEAD LEVEL NUMBER\n         CR    X3,COUNT            COMPARE WITH VALUE SPECIFIED\n         BNH   DHE013              BRANCH IF GREATER OR EQUAL\n         LR    R0,COUNT            SAVE HEAD LEVEL NUMBER\nDHSCAN   DS    0H\n        $CALL  GETYESNO            SCAN NEXT ARGUMENT\n         BC    BOMIT,DHDONE        RETURN IF NONE\n         CLI   YNRESULT,YNDHSTRT   ARGUMENT BELOW BOTTOM RANGE .Q\n         BL    DHE005              BRANCH IF YES\n         CLI   YNRESULT,YNDHEND    ARGUMENT ABOVE TOP LIMIT .Q\n         BH    DHE005              BRANCH IF YES\n         L     X1,DHNUMTC          GET TABLE OF CONTENTS LEVEL\n         SLL   X1,2                TIMES 4\n         L     X3,DHANCH(X1)       GET CORRECT CONTENTS ANCHOR\n         SR    R15,R15             ZERO REGISTER\n         IC    R15,YNRESULT        GET RESULT CODE\n         LA    TEMP,YNDHSTRT       GET BASE CODE\n         SR    R15,TEMP            NORMALIZE RESULT CODE\n         SLL   R15,2               MULTIPLY BY 4\n         STH   R0,DECM             ALIGN HEAD LEVEL NUMBER\n         LA    TEMP,DHDLEN         LENGTH OF ONE DH AREA\n         MH    TEMP,DECM           TIMES HEAD LEVEL NUMBER\n         AR    X3,TEMP             PLUS BASE ADDRESS\n         USING DHDSECT,X3          SET UP FOR ADDRESSABILITY\n         EX    R0,DHSET(R15)       PERFORM APPROPRIATE ACTION\n         B     DHSCAN              RESUME SCANNING\nDHDONE   DS    0H\n        $EXIT  RC=0                RETURN\n         SPACE\nDHSET    DS    0H\n         B     DHGETNUM            OBTAIN NUMERIC ARGUMENT\n         B     DHGETNUM            OBTAIN NUMERIC ARGUMENT\n         B     DHGETNUM            OBTAIN NUMERIC ARGUMENT\n         B     DHGETNUM            OBTAIN NUMERIC ARGUMENT\n        $ON    DHFLAGS,DHTO        SET TABLE OF CONTENTS ENTRY ONLY\n        $ON    DHFLAGS,DHTC        SET TABLE OF CONTENTS ENTRY WANTED\n        $ON    DHFLAGS,DHTS        SET SPACE BEFORE TABLE OF CONTENTS\n        $ON    DHFLAGS,DHUS        UNDERSCORE THE HEAD LEVEL\n        $ON    DHFLAGS,DHUP        PUT THE HEAD LEVEL IN UPPERCASE\n        $ON    DHFLAGS,DHOJ        OUTJUSTIFY THE HEAD LEVEL\n        $ON    DHFLAGS,DHPA        ISSUE PAGE EJECT BEFORE HEAD LEVEL\n        $ON    DHFLAGS,DHBR        DO A BREAK AFTER THE HEAD\n        $OFF   DHFLAGS,DHTO        NO TABLE OF CONTENTS ENTRY ONLY OFF\n        $OFF   DHFLAGS,DHTC        NO TABLE OF CONTENTS ENTRY WANTED\n        $OFF   DHFLAGS,DHTS        NO SPACE BEFORE TABLE OF CONTENTS\n        $OFF   DHFLAGS,DHUS        DO NOT UNDERSCORE THE HEAD LEVEL\n        $OFF   DHFLAGS,DHUP        NO HEAD LEVEL IN UPPERCASE\n        $OFF   DHFLAGS,DHOJ        DONT OUTJUSTIFY THE HEAD LEVEL\n        $OFF   DHFLAGS,DHPA        NO PAGE EJECT BEFORE HEAD LEVEL\n        $OFF   DHFLAGS,DHBR        NO BREAK AFTER THE HEAD\n         SPACE\nDHGETNUM DS    0H\n         LR    X2,R15              SAVE INDEX REGISTER\n        $CALL  GETNUM              SCAN FOR NUMERIC ARGUMENT\n         BC    BOMIT,DHE003        ERROR IF OMITTED\n         BC    BDNO,DHE005         ERROR IF NOT NUMERIC\n         EX    R0,DHNUM(X2)        EXTRACT ADDRESS\n         SR    X2,X2               CLEAR WORK REGISTER\n         IC    X2,0(,X1)           OBTAIN VALUE FROM TABLE\n         CLI   NUMSIGN,C' '        WAS NO SIGN GIVEN .Q\n         BNE   DHNOSIGN            BRANCH IF NOT\n         SR    X2,X2               ADD ZERO TO VALUE SPECIFIED\nDHNOSIGN DS    0H                  RELATIVE NUMERIC ARGUMENT\n         AR    X2,COUNT            ADD VALUE SPECIFIED\n         LTR   X2,X2               VERIFY TOTAL ZERO OR POSITIVE\n         BM    DHE014              BRANCH IF NOT\n         C     X2,F255             IS TOTAL LESS THAN 255 .Q\n         BH    DHE013              ERROR IF NO\n         STC   X2,0(,X1)           SAVE BACK IN TABLE\n         B     DHSCAN              RESUME SCANNING\n         SPACE\nDHNUM    DS    0H\n         LA    X1,DHSKBF           POINT TO SKBF ENTRY\n         LA    X1,DHSPAF           POINT TO SPAF ENTRY\n         LA    X1,DHTCIN           POINT TO TCON ENTRY\n         LA    X1,DHTCOF           POINT TO TCOF ENTRY\n         DROP  X3\n         SPACE\nDHE013   DS    0H\n         MVI   EFLAG013,ERRSET     NUMERIC ARGUMENT TOO LARGE\n         B     DHDONE              GO TO RETURN\nDHE003   DS    0H\n         MVI   EFLAG003,ERRSET     ARGUMENT OMITTED\n         B     DHDONE              GO TO RETURN\nDHE005   DS    0H\n         MVI   EFLAG005,ERRSET     ILLEGAL PARAMETER VALUE\n         B     DHDONE              GO TO RETURN\nDHE014   DS    0H\n         MVI   EFLAG014,ERRSET     NUMERIC ARGUMENT TOO SMALL\n         B     DHDONE              GO TO RETURN\nDHE035   DS    0H\n         MVI   EFLAG035,ERRSET     ARGUMENT MUST BE NUMERIC\n         B     DHDONE              GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DHCLR": {"ttr": 4614, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00/\\x00/\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              DHCLR (DEFINE HEADER INITIALIZATION)                   *\n*                                                                     *\n***********************************************************************\n         SPACE\nDHCLR   $ENTER ,\n         L     X1,DHNUMTC          GET TABLE OF CONTENTS NUMBER\n         SLL   X1,2                TIMES 4\n         L     TEMP,DHANCH(X1)     OBTAIN CORRRECT ANCHOR POINTER\n         LTR   TEMP,TEMP           HAS AREA BEEN ASSIGNED .Q\n         BNZ   DHCDONE             BRANCH IF YES\n         LA    R1,DHMAX*DHDLEN     LENGTH OF HEAD LEVEL TABLE\n        $CALL  GETCELL             OBTAIN CORE\n         BC    BNEG,DHC010         BRANCH IF NOT AVAILABLE\n         USING DHDSECT,TEMP        INFORM ASSEMBLER\n         MVC   DHDSECT(DHDLEN*DHMAX),DHDEFALT  SET DEFAULTS\n         ST    TEMP,DHANCH(X1)     SAVE ADDRESS OF TABLE\nDHCDONE  DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         DROP  TEMP\n         SPACE\nDHC010   DS    0H\n         MVI   EFLAG024,ERRSET     WORKING STORAGE EXHAUSTED\n         B     DHCDONE             ALL DONE\n         SPACE\nDHDEFALT DS    0H\nDHLEV0   DC    AL1(0,0,0,1)        SKBF,SPBF,TCIN,TCOF\n         DC    AL1(DHTO+DHTC,0)\nDHLEV1   DC    AL1(0,5,0,1)\n         DC    AL1(DHTC+DHTS+DHUS+DHUP+DHOJ+DHPA+DHBR,0)\nDHLEV2   DC    AL1(3,2,0,1)\n         DC    AL1(DHTC+DHUS+DHUP+DHBR,0)\nDHLEV3   DC    AL1(3,2,2,1)\n         DC    AL1(DHTC+DHUP+DHBR,0)\nDHLEV4   DC    AL1(3,2,4,1)\n         DC    AL1(DHUS+DHBR,0)\nDHLEV5   DC    AL1(1,0,6,1)\n         DC    AL1(DHUS+DHUP,0)\nDHLEV6   DC    AL1(1,0,8,1)\n         DC    AL1(DHUS,0)\nDHLEV7   DC    AL1(0,0,0,0)\n         DC    AL1(0,0)\nDHLEV8   DC    AL1(0,0,0,0)\n         DC    AL1(0,0)\nDHLEV9   DC    AL1(0,0,0,0)\n         DC    AL1(0,0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DM": {"ttr": 4616, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x85\\x00\\x85\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 133, "newlines": 133, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .DM (DEFINE MACRO) --- CONTROL                         *\n*                                                                     *\n***********************************************************************\n         SPACE\nDM      $ENTER ,\n        $CALL  GETNUM              TEST FOR NUMERIC FIRST OPERAND\n         BC    BOMIT,DME003        ERROR IF OMITTED\n         BC    BDNO,DM01           BRANCH IF ERROR, TRY AGAIN\n         LTR   COUNT,COUNT         TEST RESULT\n         BNP   DME014              BRANCH IF TOO SMALL\n         C     COUNT,F32767        TEST AGAIN\n         BH    DME013              ERROR IF TOO BIG\n         B     DM05                VALID NUMERIC OPERAND\n         SPACE\nDM01     DS    0H\n         ST     COUNT,ARGSTART     RESCAN FOR STRING OPERAND\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION PLEASE\n        $CALL  GETARG              GET ARGUMENT NAME\n         LTR   TEMP,TEMP           LENGTH-1 A ZERO .Q\n         BNZ   DM02                BRANCH IF NOT\n         CLI   0(COUNT),C'*'       DEFAULT FIRST OPERAND .Q\n         BE    DM04                BRANCH IF YES\nDM02     DS    0H\n         LA    R0,L'APIMNAME-1     MAX LENGTH-1 ALLOWED\n         CR    TEMP,R0             CHECK WITH MAX\n         BNH   DM03                BRANCH IF OK\n         LR    TEMP,R0             MAX WILL DO\nDM03     DS    0H\n         MVC   APIMNAME,BLANKS     BLANK MACRO TARGET NAME\n         EX    TEMP,DMNAMVC        MOVE IN MACRO NAME\n         OC    APIMNAME,BLANKS     CONVERT TO UPPER CASE\n         B     DM06                AND CONTINUE\nDMNAMVC  MVC   APIMNAME(*-*),0(COUNT)   ENTER MACRO NAME\n         SPACE\nDM04     DS    0H\n         LH    COUNT,TOPMRG        DEFAULT FIRST ARG, FIRST TEXT LINE\n         LA    COUNT,1(,COUNT)     BUMP TOP MARGIN BY ONE\nDM05     DS    0H\n         XC    APIMNAME,APIMNAME   ZERO NAME TARGET\n         ST    COUNT,APIMNAME+4    ADD LINE NUMBER\n         SPACE\nDM06     DS    0H\n         XC    RMFLAG,RMFLAG       ZERO SCANNING FLAG\n        $ON    RMFLAG,(RMQDM,RMQKEEP)   THIS IS A 'NOSAVE MACRO'\n         MVI   RMDELIM,C' '        DELIMITING CHAR A BLANK\n         MVC   RMCWIND,BUFF2       MACRO CONTROL WORD IND\n         MVC   RMCNT,F32767        HIGHEST CALL COUNT\n        $CALL  GETYESNO            GET AND TEST SECOND ARG\n         BC    BPOS,DM08           BRANCH IF POSITIVE TO ACCUMULATE\n         BC    BNEG,DM07           BRANCH IF NEGATIVE TO DELETE\n         BC    BOMIT,DME003        BRANCH IF NOTHING\n         CLI   YNRESULT,YNDEL      'DELETE' OPERAND .Q\n         BE    DM07                BRANCH IF YES\n         ST    COUNT,ARGSTART      RESET OPERAND START\n         MVC   RMDELIM,0(COUNT)    SET DELIMITING CHAR\n         B     DM08                AND CONTINUE\n         SPACE\nDM07     DS    0H\n        $CALL  RMDEL               DELETE ONE ENTRY\n         BC    BNEG,DME017         ERROR IF NOT FOUND\n         B     DM31                GO TO RETURN\n         SPACE\nDM08     DS    0H\n        $CALL  RMFIND              FIND QUEUE ENTRY POINT\n         LA    R1,RMQLEN           QUEUE ELEMENT LEN\n        $CALL  GETCELL             GET AN AREA\n         BC    BNEG,DME018         BRANCH IF FAILED\n         LR    X3,TEMP             USE THIS AREA\n         USING RMQD,X3             AREA GOT\n         XC    RMQD(RMQLEN),RMQD   CLEAR THE AREA\n         MVC   RMQCHN,RMQCHN-RMQD(X1)   NEXT PTR\n         ST    X3,RMQCHN-RMQD(,X1) LAST POINTER\n         MVC   RMQFLAG,RMFLAG      FLAG ATTRIBUTES\n         MVC   RMQCNT,RMCNT        AND CALL COUNT\n         MVC   RMQNAME,APIMNAME    REMOTE IDENT\n         SPACE\n         CLI   RMQDELIM,C' '       BLANK STRING DELIMITER .Q\n         BE    DM30                BRANCH IF YES\n         LA    R1,DMEND            POINT TO MACRO TERMINATOR\n         LA    TEMP,L'DMEND-1      LENGTH-1\n        $CALL  HIDBADD             QUEUE IT 'LIFO'\n         L     X2,ARGSTOP          END OF ARG\nDM20     DS    0H\n         LR    X1,X2               SCAN PTR FROM HERE\n         C     X1,ARGSTART         WHERE IT ALL STARTED\n         BL    DM30                BRANCH IF ALL DONE\nDM21     DS    0H\n         CLC   0(1,X1),RMDELIM     DELIMITER CHAR .Q\n         BE    DM22                BRANCH IF YES\n         BCT   X1,DM21             BACKUP ONE AND BRANCH\nDM22     DS    0H\n         LR    TEMP,X2             END PTR\n         SR    TEMP,X1             LENGTH INCL DELIMITERS\n         S     TEMP,F1             LENGTH-1 BETWEEN\n         BM    DM23                BRANCH IF NOTHING\n         LA    R1,1(,X1)           START OF STRING\n        $CALL  HIDBADD             QUEUE IT 'LIFO'\nDM23     DS    0H\n         LR    X2,X1               LAST DELIMITER\n         BCT   X2,DM20             BACKUP ONE AND BRANCH\n         SPACE\nDM30     DS    0H\n         LA    R0,RMQD             POINT TO ANCHOR\n        $CALL  RMREAD              GET MACRO LINES\n         ST    R1,RMQFSIZ          ENTER COUNT OF RECORDS\n         DROP  X3\n         SPACE\nDM31     DS    0H\n        $CALL  RMNEXT              SET UP FOR NEXT MACRO\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nDMEND    DC    C'.DM END'          END OF MACRO DEFINITION\n         SPACE\nDME003   DS    0H\n         MVI   EFLAG003,ERRSET     OMITTED OPERAND\n         B     DM31                GO TO RETURN\nDME005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     DM31                GO TO RETURN\nDME013   DS    0H\n         MVI   EFLAG013,ERRSET     OPERAND TOO BIG\n         B     DM31                GO TO RETURN\nDME014   DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     DM31                GO TO RETURN\nDME017   DS    0H\n         MVI   EFLAG017,ERRSET     MACRO NOT FOUND\n         B     DM31                GO TO RETURN\nDME018   DS    0H\n         MVI   EFLAG018,ERRSET     INSUFFICIENT STORAGE FOR MACRO\n         B     DM31                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DO": {"ttr": 4619, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .DO (DO GROUP) --- CONTROL                             *\n*                                                                     *\n***********************************************************************\n         SPACE\nDO      $ENTER ,\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BNEG,DO01           BRANCH IF 'END'\n         BC    BDNO,DOE005         BRANCH IF INVALID\n        $IFNONE IFSTAK,(IFTHEN,IFELSE),DOE028  ERROR IF NOT OBJECT\n        $IFON  IFSTAK,(IFDO),DOE028     ERROR IF NESTED DO\n        $ON    IFSTAK,IFDO         START OF DO GROUP\n         B     DO02                GO TO RETURN\n         SPACE\nDO01     DS    0H\n        $CALL  EN                  '.DO END' SAME AS '.EN'\nDO02     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nDOE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID .DO OPERAND\n         B     DO02                GO TO RETURN\nDOE028   DS    0H\n         MVI   EFLAG028,ERRSET     .DO NOT OBJECT OF .TH OR .EL\n         B     DO02                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DS": {"ttr": 4621, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\n\\x00\\n\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .DS (DOUBLE SPACE) --- CONTROL                         *\n*                                                                     *\n***********************************************************************\n         SPACE\nDS      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n         MVC   DSCNT,H1            SET LINE SPACING FACTOR\n        $EXIT  RC=0                GO TO NEXT RECORD\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DSECTS": {"ttr": 4623, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x01\\xc8\\x01\\xc8\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 456, "newlines": 456, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              DSECT AND SWITCH DEFINITIONS                           *\n*                                                                     *\n***********************************************************************\n         SPACE\n         COPY  $WITCHS             INCLUDE SWITCH DEFINITIONS\n         SPACE\nLINKELEM DSECT ,                   LINKED CHARACTER BLOCK\nLINKFOR  DS    A                   FORWARD POINTER\nLINKDOWN DS    A                   DOWNWARD POINTER\nLINKMULT DS    X                   MULTIPLIER\nLINKCHAR DS    C                   CHARACTER\nLINKESC  DS    0CL6                ESCAPE AFTER CHARACTER\nLINKWID  DS    H                   CHARACTER WIDTH\nLINKBACK DS    A                   BACKWARD POINTER\nLINKBSIZ EQU   *-LINKELEM\n         SPACE\nLOLDELEM DSECT ,                   OLD LINKED CHARACTER BLOCK\nLOLDFOR  DS    A                   FORWARD POINTER\nLOLDDOWN DS    A                   DOWNWARD POINTER\nLOLDMULT DS    X                   MULTIPLIER\nLOLDCHAR DS    C                   CHARACTER\nLOLDESC  DS    0CL6                ESCAPE AFTER CHARACTER\nLOLDWID  DS    H                   CHARACTER WIDTH\nLOLDBACK DS    A                   BACKWARD POINTER\nLOLDBSIZ EQU   *-LOLDELEM\n         SPACE\nLNEWELEM DSECT ,                   NEW LINKED CHARACTER BLOCK\nLNEWFOR  DS    A                   FORWARD POINTER\nLNEWDOWN DS    A                   DOWNWARD POINTER\nLNEWMULT DS    X                   MULTIPLIER\nLNEWCHAR DS    C                   CHARACTER\nLNEWESC  DS    0CL6                ESCAPE AFTER CHARACTER\nLNEWWID  DS    H                   CHARACTER WIDTH\nLNEWBACK DS    A                   BACKWARD POINTER\nLNEWBSIZ EQU   *-LNEWELEM\n         SPACE\nLARAELEM DSECT ,                   LINKED CHAR BLOCK HEADER\nLARAFOR  DS    A                   FORWARD POINTER\n         ORG   LARAELEM+LINKBSIZ   SAME AS OTHERS\nLARABSIZ EQU   *-LARAELEM\n         SPACE\nCPFKFN   DSECT ,                   BUFFERED LINE CONTROL\nCPFKFNC  DS    F                   COUNT OF BUFFERED LINES\nCPFKFNF  DS    F                   NUMBER IN FIRST BLOCK\nCPFKFNA  DS    A                   BUFFERED LINE CELL ANCHOR\nCPFKFNG  DS    XL4                 FLAGS\nCOLLOCK  EQU   X'80'                    COLUMN LOCKED FOR BALANCE\nCPFKKEEP EQU   X'40'                    DON'T DELETE DATA AFTER PRINT\nCPFKSKIP EQU   X'20'                    LEADING SKIP SWITCH\nCPFKFNS  DS    A                   SAVED DATA POINTER DURING SAVE\nCPFKFNL  EQU   *-CPFKFN\n         SPACE\nDHDSECT  DSECT ,                   DEFINE HEAD LEVEL AREA\nDHSKBF   DS    AL1                 SPACES BEFORE HEAD LEVEL\nDHSPAF   DS    AL1                 SPACES AFTER HEAD LEVEL\nDHTCIN   DS    AL1                 INDENTATION VALUE\nDHTCOF   DS    AL1                 OFFSET VALUE\n         SPACE\nDHFLAGS  DS    XL2                 DEFINE HEAD FLAGS\nDHTO     EQU   X'80',,C'0'              TABLE OF CONTENTS ENTRY ONLY\nDHTC     EQU   X'40',,C'0'              TABLE OF CONTENTS ENTRY WANTED\nDHTS     EQU   X'20',,C'0'              SPACE BEFORE TABLE\nDHUS     EQU   X'10',,C'0'              UNDERSCORE THE HEAD LEVEL\nDHUP     EQU   X'08',,C'0'              HEAD LEVEL IN UPPERCASE\nDHOJ     EQU   X'04',,C'0'              OUTJUSTIFY THE HEAD LEVEL\nDHPA     EQU   X'02',,C'0'              PAGE EJECT BEFORE HEAD LEVEL\nDHBR     EQU   X'01',,C'0'              BREAK AFTER HEAD LEVEL\n*        EQU   X'80',,C'1'                  UNUSED\n*        EQU   X'40',,C'1'                  UNUSED\n*        EQU   X'20',,C'1'                  UNUSED\n*        EQU   X'10',,C'1'                  UNUSED\n*        EQU   X'08',,C'1'                  UNUSED\n*        EQU   X'04',,C'1'                  UNUSED\n*        EQU   X'02',,C'1'                  UNUSED\n*        EQU   X'01',,C'1'                  UNUSED\nDHDLEN   EQU   *-DHDSECT           LENGTH OF AREA\n         SPACE\nDHMAX    EQU   10                  MAXIMUM NUMBER OF HEAD LEVELS\n         SPACE\nOODSECT  DSECT ,                   OVERLAY CONTROL BLOCK\nOOQFCHN  DS    A                   OVERLAY BLOCK FORWARD CHAIN\nOOQCNT   DS    F                   COUNT TO APPLY THIS BLOCK\nOOQRDW   DS    2H                  RDW OF BLOCK\nOOQDATA  DS    0CL255              DATA\nOOQLEN   EQU   *-OODSECT           LENGTH OF PREFIX\n         SPACE\nFNQELEM  DSECT ,                   STORAGE QUEUED PRINT LINE\nFNQFCHN  DS    A                   ADDRESS OF NEXT QUEUED LINE\nFNQFLAG  DS    X                   RECORD FLAGS\nFNQEOB   EQU   X'80'                    SET IF LAST RECORD OF BLOCK\nFNQONE   EQU   X'40'                    SET IF ONE BLOCK PRINT ONLY\nFNQOVLY  EQU   X'20'                    SET IF OVERLAY LINE\nFNQTC    EQU   X'10'                    SET IF TABLE OF CONTENTS LINE\nFNQSSET  EQU   X'08'                    SET IF SKIP/SPACE SET\nFNQNOBRK EQU   X'04'                    SET IF FNQEOB AND NOBREAK\nFNQCORSW DS    X                   TYPE OF PRINT LINE ELEMENT\nFNQSKSP  DS    XL4                 CONDITIONAL SPACE/SKIP DATA\nFNQNUMOP DS    H                   EXTRA USER SPACE REQUIREMENT\nFNQNUMTC DS    H                   TC NUMBER WHEN TC ENTRY STACKED\nFNQRDW   DS    H                   LENGTH OF TEXT\n         DS    H                   RDW DUMMY\nFNQTEXT  DS    0CL240              QUEUED LINE TEXT\nFNQOVHD  EQU   FNQRDW-FNQELEM      PREFIX OVERHEAD LENGTH\nFNQLN    EQU   *-FNQELEM           LENGTH OF QUEUED BUFFER PREFACE\n         SPACE\nSRAREA   DSECT ,                   SYMBOL DICTIONARY\nSRANCH   DS    A                   VARIABLE SYMBOL ANCHOR\nSRLAST   DS    (ASRCNT)A           LAST SUCCESS PTRS\nSRALEN   EQU   *-SRAREA            LENGTH OF SYMBOL DICT AREA\n         SPACE\nRND      DSECT ,                   REFERENCE SYMBOL\nRNSCHN   DS    A                   POINTER TO NEXT REFERENCE SYMBOL\nRNSYM    DS    CL10                SYMBOL NAME\nRNSUBS   DS    XL2                 SYMBOL SUBSCRIPT\nRNSLINK  DS    A                   PTR TO NEXT ARRAY INDEX\nRNFLAG   DS    X                   FLAGS --\nRNCHAR   EQU   X'80'                    CHARACTER DATA\nRNPTR    EQU   X'40'                    POINTER DATA\nRNCLEN   DS    X                   LENGTH OF CHARACTER DATA\nRNCVAL   DS    CL10                CHARACTER REFERENCE NAME VALUE\n         ORG   RNCVAL\nRNCPTR   DS    A                   CHAR REFERENCE NAME POINTER\n         ORG   RNCVAL\nRNDVAL   DS    F                   NUMERIC REFERENCE NAME VALUE\n         ORG   ,\nRNLN     EQU   *-RND               ENTRY LENGTH\n         SPACE\nRMQD     DSECT ,                   REMOTE DESCRIPTOR QUEUE ELEMENT\nRMQCHN   DS    A                   CHAIN TO NEXT QUEUE ENTRY\nRMQNAME  DS    CL8                 REMOTE IDENTIFIER\nRMQAD    DS    A                   ADDR OF FIRST QUEUED LINE\nRMQCNT   DS    F                   NUMBER OF TIMES TO CALL\nRMQFSIZ  DS    F                   SIZE OF FORMATTED REMOTE\nRMQUSE   DS    F                   REMOTE USE COUNT\nRMQPAGE  DS    F                   LAST AUTO CALL PAGE\nRMQEXIT  DS    A                   READ EXIT ADDRESS\nRMQFLAG  DS    XL4                 FLAGS --\nRMQKEEP  EQU   X'80',,C'0'              KEEP ENVIROMNENT UNCHANGED\nRMQDEL   EQU   X'40',,C'0'              DELETE THIS REMOTE\nRMQDM    EQU   X'20',,C'0'              ON IF A DEFINE MACRO (.DM)\n         ORG   *-2                 BACKUP FOR CHARACTERS\nRMQCWIND DS    C                   MACRO/REMOTE CONTROL WORD IND\nRMQDELIM DS    C                   .DM STRING DELIMITER\nRMQLEN   EQU   *-RMQD              LENGTH OF ONE ENTRY\n         SPACE\nRMQR     DSECT ,                   REMOTE DATA LINE\nRMQRCHN  DS    A                   NEXT RECORD\nRMQRLEN  DS    H                   LENGTH OF DATA\nRMQRDATA DS    0CL255              DATA LINE\nRMQRLN   EQU   *-RMQR              LENGTH OF PREFIX\n         SPACE\nHIDB     DSECT ,                   HIDDEN READ BUFFER\nHIDBCHN  DS    A                   NEXT BUFFER POINTER\nHIDBBLKL DS    H                   LENGTH OF THIS BLOCK\nHIDBLEN  DS    H                   LENGTH OF DATA\nHIDBDATA DS    0CL255              DATA ITEM\nHIDBLN   EQU   *-HIDB              LENGTH OF PREFIX\n         SPACE\nBXAREA   DSECT ,                   BOX BUILDING INFORMATION\nBXBLKLN  DS    H                   LENGTH USED IN BXDATA\nBXDATA   DS    CL240               BOX DRAWING DATA\nBXUP     EQU   X'08'                    LINE GOES UP\nBXDOWN   EQU   X'04'                    LINE GOES DOWN\nBXLEFT   EQU   X'02'                    LINE GOES LEFT\nBXRIGHT  EQU   X'01'                    LINE GOES RIGHT\nBXBLANK  EQU   X'00'                    NO LINE PRESENT\nBXLEN    EQU   *-BXAREA            LENGTH OF AREA\n         SPACE\nSTAKSAVE DSECT ,                   STATUS SAVE/RESTORE MAPPING\nSTAKCHN  DS    A                   FORWARD STACK POINTER\nSTAKTLD1 DS    CL(SWCTLZ)          SWITCHES\nSTAKTLD2 DS    CL(LFMTOLD2)        PAGE DESCRIPTORS\nSTAKICOL DS    CL(L'ICOLFLG)       MULTIPLE COLUMN FORMAT\nSTAKOC   DS    CL(OCLEN)           OVERLAY CHARACTER SAVE\nSTAKTRNO DS    CL256               OUTPUT TRANSLATE TABLE\nSTAKTRNI DS    CL256               INPUT TRANSLATE TABLE\nSTAKTABI DS    CL(L'TBIND)         USER TAB CHARACTER\nSTAKTABA DS    A                   USER'S TAB TABLE ADDRESS\nSTAKESTA DS    A                   INPUT ESCAPE CHAR/ADDRESS\nSTAKSEND DS    0D\nSTAKSIZE EQU   *-STAKSAVE          LENGTH OF ONE AREA\n         SPACE\nICORSAVE DSECT ,                   SAVE AREA WHEN FORMATTING INCORE\nICOROLD1 DS    CL(LFMTOLD1)        SWITCH SAVE AREA\nICOROLD2 DS    CL(LFMTOLD2)        PAGE DESCRIPTORS\nICORBX   DS    CL(L'BXPTR)         BOX BUILD POINTER\nICOROO   DS    CL(L'OOANCH)        OUTPUT OVERLAY POINTER\nICORSKSP DS    CL(L'SKSP)          CONDITIONAL SKIP INFORMATION\nICORSLEN EQU   *-ICORSAVE          LENGTH OF AREA\n         SPACE\nRCAREA   DSECT ,                   REVISION CODE WORK AREA\nRCASTKOF DC    H'0'                CURRENT RCASTACK OFFSET\nRCANFCNT DC    H'0'                ON/OFF COUNT LEFT\nRCACURR  DC    H'0'                CURRENT REVISION CODE NUMBER\nRCACHAR  DC    CL8' '              CURRENT REVISION CODE CHARACTERS\nRCASTALL DC    CL8' '              STALLED REVISION CODE CHARACTERS\nRCADJCNT EQU   2                   MIN REQUIRED LEFT ADJUST MARGIN\nRCAMAX   EQU   100                 MAX REVISION CODE NUMBER +1\nRCATABLE DC    (RCAMAX)CL8' '      REVISION CODE CHARACTERS\nRCASTACK DC    (RCAMAX)H'0'        REVISION CODE STACK\nRCASTKCR DC    (RCAMAX)CL8' '      REVISION CODE CHARACTER STACK\nRCALEN   EQU   *-RCAREA            LENGTH OF REVISION CODE AREA\n         SPACE\nRMSAVE   DSECT ,                   REMOTE SAVE EXTENSION\nRMSREG   DS    16F                      REGISTER SAVE AREA\nRMSOLD1  DS    CL(LFMTOLD1)             SWITCH SAVE AREA\nRMSOLD2  DS    CL(LFMTOLD2)             PAGE DESCRIPTORS\nRMSICOL  DS    CL(L'ICOLFLG)            MULTIPLE COLUMN FORMAT\nRMSARGS  DS    CL8                      BUFF2 POINTERS\nRMSOC    DS    CL(OCLEN)                OVERLAY CHARACTER SAVE\nRMSTABI  DS    CL(L'TBIND)              USER TAB CHARACTER\nRMSTABA  DS    A                        USER'S TAB TABLE ADDRESS\nRMSBUFF2 DS    CL244                    BUFF2\nRMSBUFF1 DS    CL245                    BUFF1\nRMSEND   DS    0D                  THE REMOTE SAVE END\nRMSLEN   EQU   *-RMSAVE                 LENGTH OF ABOVE\n         SPACE\nSAVESCR  DSECT ,                   SCRIPT SAVE STACK\n         DS    16A                      REGISTER SAVE AREA\nSAVED0   DS    D                        DOUBLE WORD EXTENSION\nSAVED1   DS    D                        SAME AS ABOVE\nSAVEF0   DS    F                        FULL WORD EXTENSION\nSAVEF1   DS    F                        SAME AS ABOVE\nSAVEH0   DS    H                        HALF WORD EXTENSION\nSAVEH1   DS    H                        SAME AS ABOVE\nSAVEX0   DS    X                        BYTE EXTENSION\nSAVEX1   DS    X                        SAME AS ABOVE\nSAVEX2   DS    X                        SAME AS ABOVE\nSAVEX3   DS    X                        SAME AS ABOVE\n         DS    0D                  END OF SCRIPT SAVE STACK\nSAVELEN  EQU   *-SAVESCR           LENGTH OF ONE SCRIPT SAVE STACK\nSAVEVLS  EQU   20                  NUMBER OF STACKED SAVE LEVELS\n         SPACE\nSCVTDSCT DSECT ,                   ENTRY SEQUENCE MAPPING\nSCVTCCNT DS    F                   ROUTINE CALL COUNT\nSCVTCSCT DS    CL8                 CSECT NAME\nSCVTDSLN EQU   *-SCVTDSCT          LENGTH OF ENTRY SEQUENCE\n         SPACE\nTBAREA   DSECT ,                   TAB BUFFER\nTBCHN    DS    A                   FORWARD PTR TO NEXT BUFFER\nTBVALUE  DS    H                   TAB COLUMN\nTBTYPE   DS    X                   TYPE OF TAB\nTBLEFT   EQU   0                        LEFT JUSTIFIED\nTBRIGHT  EQU   4                        RIGHT JUSTIFIED\nTBCENTRE EQU   8                        CENTRE\nTBOK     EQU   12                       ALIGN ON A CHARACTER\nTBCHAR   DS    C                   TAB ALIGNMENT CHARACTER\nTBLEN    DS    H                   LENGTH OF USER FILL\nTBFILL   DS    0CL255              USER FILL STRING\nTBLKSZE  EQU   *-TBAREA            LENGTH OF TAB BLOCK\n         SPACE\nTDEVICEA DSECT ,                   TERMINAL DESCRIPTOR AREA\nTDEVCCNT DS    F                   PREFIX CALL COUNT\nTDEVCSCT DS    CL8                 PREFIX CSECT NAME\nTDEVBEG  DS    0F                  START OF DEVICE INFO\nTDEVRESH DS    F                   HORIZONTAL RESOLUTION\nTDEVRESV DS    F                   VERTICAL RESOLUTION\nTDEVSUP  DS    AL1,CL7             SUPERSCRIPT SHIFT\nTDEVSUB  DS    AL1,CL7             SUBSCRIPT SHIFT\nTDEVTAB  DS    AL1,CL7             TAB TO COLUMN\nTDEVVMI  DS    AL1,CL7             VERTICAL MOTION INDEX\nTDEVHMI  DS    AL1,CL7             HORIZONTAL MOTION INDEX\nTDEVNLF  DS    AL1,CL7             NEGATIVE LINE FEED\nTDEVAESC DS    256AL1              NUMBER OF CHARS AFTER ESCAPE -1\nTDEVLEN  EQU   *-TDEVBEG           LENGTH OF AREA\n         SPACE\n*  THIS IS THE PARAMETER BLOCK PASSED TO READFILE TO REQUEST          *\n*  THAT A NEW FILE BE TACKED ONTO THE INPUT STACK                     *\n         SPACE\nIOBLOK   DSECT ,\nIONAME   DS    CL8                 NAME OF THE FILE\nIOMEMB   DS    CL8                 MEMBER NAME OR BLANK\nIOMIN    DS    A                   NUMBER OF FIRST RECORD TO BE READ\nIOMAX    DS    A                   NUMBER OF LAST RECORD TO BE READ\nIOFLAG   DS    XL4                 FLAG BYTES ---\n         SPACE\nIO$NULL  EQU   X'80',,C'0'         NULL RECORD IS AN EOF\nIO$SUPR  EQU   X'40',,C'0'         SUPPRESS TERM PRINT BEFORE READ\nIO$JIGG  EQU   X'20',,C'0'         JIGGLE TYPE BALL BEFORE READ\nIO$NOCLO EQU   X'10',,C'0'         NEVER CLOSE THIS FILE\nIO$UEOF  EQU   X'08',,C'0'         USER EOF REQUESTED\nIO$FIND  EQU   X'04',,C'0'         ISSUE POINT AND FIND BEFORE READ\nIO$BUFF  EQU   X'02',,C'0'         FILE BUFFER SUCCESSFULLY ALLOCATED\nIO$NONM  EQU   X'01',,C'0'         FILE IS NOT LINE NUMBERED\n         SPACE\nIO$EJCT  EQU   X'80',,C'1'         PAGE TO BE SPACED (STOP OPTION)\n*        EQU   X'40',,C'1'             UNUSED\n*        EQU   X'20',,C'1'             UNUSED\n*        EQU   X'10',,C'1'             UNUSED\n*        EQU   X'08',,C'1'             UNUSED\n*        EQU   X'04',,C'1'             UNUSED\nIO$CMS   EQU   X'02',,C'1'         FILE IS CMS TERMINAL FILE\nIO$TSO   EQU   X'01',,C'1'         FILE IS TSO TERMINAL FILE\n         SPACE\nIO$AP    EQU   X'80',,C'2'         APPEND (.AP) FLAG\nIO$IM    EQU   X'40',,C'2'         IMBED (.IM) FLAG\nIO$RM    EQU   X'20',,C'2'         REMOTE (.RM) FLAG\nIO$AURM  EQU   X'10',,C'2'         AUTOMATIC TRIGGERED REMOTE\nIO$INRM  EQU   X'08',,C'2'         INTERNAL READ EXIT REMOTE\nIO$SYRM  EQU   X'04',,C'2'         AUTOMATIC TRIGGERED SYSTEM REMOTE\n*        EQU   X'02',,C'2'             UNUSED\n*        EQU   X'01',,C'2'             UNUSED\n         SPACE\n*        EQU   X'80',,C'3'             UNUSED\n*        EQU   X'40',,C'3'             UNUSED\n*        EQU   X'20',,C'3'             UNUSED\n*        EQU   X'10',,C'3'             UNUSED\n*        EQU   X'08',,C'3'             UNUSED\n*        EQU   X'04',,C'3'             UNUSED\n*        EQU   X'02',,C'3'             UNUSED\n*        EQU   X'01',,C'3'             UNUSED\n         SPACE\nIOARGC   DS    F                   ARGUMENT COUNT\nIOGOTO   DS    CL8                 GOTO LABEL\n         DS    0D                  END OF IOBLOK\nIOBLOKLN EQU   *-IOBLOK            LENGTH OF IO BLOCK\n         SPACE\n*                                                                     *\n*  ONE FILBLOCK IS ALLOCATED FOR EACH FILE CURRENTLY ON THE INPUT     *\n*  STACK.  NOTE THAT SEVERAL FILBLOCKS CAN POINT                      *\n*  TO THE SAME DDBLOCK, EG., IF SEVERAL MEMBERS OF THE SAME           *\n*  PDS ARE BEING READ SIMULTANEOUSLY.                                 *\n         SPACE\nFILBLOCK DSECT ,\nFILPREV  DS    A                   POINTER TO PREVIOUS FILBLOCK\nFILDDADR DS    A                   POINTER TO ASSOCIATED DDBLOCK\nFILDDNAM DS    CL8                 LOGICAL DDNAME OF FILE\nFILMEMNM DS    CL8                 MEMBER NAME(IF ANY) USED BY FILE\nFILNUMBR DS    CL8                 DECIMAL ITEM NUMBER\nFILTTRK  DS    F                   TTRK OF START OF MEMBER  (PO)\nFILNOTE  DS    F                   TTR OF LAST BLOCK READ (PS/PO)\nFILRMQAD DS    A                   ADDR OF REMOTE QUEUE DESCRIPTOR\nFILRMEXT DS    A                   REMOTE READ EXIT ADDRESS\nFILH1AD  DS    A                   -> NEXT LEVEL 1 INDEX\nFILH2AD  DS    A                   -> NEXT LEVEL 2 INDEX\nFILH3AD  DS    A                   -> NEXT LEVEL 3 INDEX\nFILIXALF DS    0C                  LAST FIRST CHAR PROCESSED\nFILIXAD  DS    A                   -> NEXT ENTRY BLOCK\nFILBUFAD DS    A                   ADDRESS OF THE FILE BUFFER\nFILBUFLN DS    A                   LENGTH OF THE FILE BUFFER\nFILNEXRC DS    A                   ADDRESS OF THE RDW OF NEXT RECORD\nFILENDBL DS    A                   -> BYTE PAST END OF CURRENT BLOCK\nFILLANCH DS    A                   LABEL BLOCK ANCHOR\nFILITEM  DS    A                   NUMBER OF LAST RECORD READ\nFILMIN   DS    A                   FIRST RECORD WHICH IS TO BE READ\nFILMAX   DS    A                   LAST RECORD TO BE READ\nFILRMFLG DS    XL4                 REMOTE FLAGS\nFILFLAG  DS    XL4                 FLAG BYTES\n         SPACE\nFIL$NULL EQU   X'80',,C'0'         NULL RECORD IS AN EOF\nFIL$SUPR EQU   X'40',,C'0'         BEFORE READ, SUPPRESS TERMINAL PRINT\nFIL$JIGG EQU   X'20',,C'0'         BEFORE READ, JIGGLE TYPE BALL\nFIL$NOCL EQU   X'10',,C'0'         NEVER CLOSE THIS FILE\nFIL$UEOF EQU   X'08',,C'0'         USER EOF REQUESTED\nFIL$FIND EQU   X'04',,C'0'         ISSUE FIND AND POINT BEFORE READ\nFIL$BUFF EQU   X'02',,C'0'         FILE BUFFER SUCCESSFULLY ALLOCATED\nFIL$NONM EQU   X'01',,C'0'         FILE IS NOT LINE NUMBERED\n         SPACE\nFIL$EJCT EQU   X'80',,C'1'         BEFORE READ, EJECT PAGE\n*        EQU   X'40',,C'1'             UNUSED\n*        EQU   X'20',,C'1'             UNUSED\n*        EQU   X'10',,C'1'             UNUSED\n*        EQU   X'08',,C'1'             UNUSED\nFIL$END  EQU   X'04',,C'1'         FIRST EOD OF FILE FOR REMOTES\nFIL$CMS  EQU   X'02',,C'1'         FILE IS CMS TERMINAL\nFIL$TSO  EQU   X'01',,C'1'         FILE IS TSO TERMINAL\n         SPACE\nFIL$AP   EQU   X'80',,C'2'         APPEND (.AP) FLAG\nFIL$IM   EQU   X'40',,C'2'         IMBED (.IM) FLAG\nFIL$RM   EQU   X'20',,C'2'         REMOTE (.RM) FLAG\nFIL$AURM EQU   X'10',,C'2'         AUTOMATIC REMOTE (.RM) FLAG\nFIL$INRM EQU   X'08',,C'2'         INTERNAL READ EXIT REMOTE\nFIL$SYRM EQU   X'04',,C'2'         AUTOMATIC TRIGGERED SYSTEM REMOTE\n*        EQU   X'02',,C'2'             UNUSED\n*        EQU   X'01',,C'2'             UNUSED\n         SPACE\n*        EQU   X'80',,C'3'             UNUSED\n*        EQU   X'40',,C'3'             UNUSED\n*        EQU   X'20',,C'3'             UNUSED\n*        EQU   X'10',,C'3'             UNUSED\n*        EQU   X'08',,C'3'             UNUSED\n*        EQU   X'04',,C'3'             UNUSED\n*        EQU   X'02',,C'3'             UNUSED\n*        EQU   X'01',,C'3'             UNUSED\n         SPACE\nFILHIDB  DS    A                   ADDRESS OF HIDDEN BUFFER CHAIN\nFILPEANC DS    A                   PERFORM STACK ANCHOR POINTER\nFILSRAR  DS    XL(SRALEN)          SAVE LOCAL SYMBOL DICT AREA\nFILIFSTK DS    XL(L'IFSTAK)        .IF STACK SAVE\nFILBLKLN EQU   *-FILBLOCK          LENGTH OF FILBLOCK\n         SPACE\nHYDSECT  DSECT ,                   HYPHENATION EXCEPTION WORD BLOCK\nHYCHN    DS    A                   FORWARD CHAIN POINTER\nHYBRK    DS    XL4                 BREAK OFFSET POINTS\nHYWORD   DS    CL8                 EXCEPTION WORD - 5 BITS PER CHAR\nHYLEN    EQU   *-HYDSECT           LENGTH OF BLOCK\n         SPACE\nLBDSECT  DSECT ,                   LABEL BLOCK DEFINITION\nLBCHN    DS    A                   FORWARD POINTER\nLBNAME   DS    CL8                 LABEL OPERAND\nLBFILIT  DS    A                   LABEL RECORD NUMBER\nLBLEN    EQU   *-LBDSECT           LENGTH OF BLOCK\n         SPACE\n*        DEFINITION OF FLAGS FOR THE .IF STACK                        *\nIFLAST   EQU   X'80',,C'0'         .IF WAS LAST LINE\nIFTHEN   EQU   X'40',,C'0'         PROCESSING OBJECT OF THEN\nIFELSE   EQU   X'20',,C'0'         PROCESSING OBJECT OF ELSE\nIFDO     EQU   X'10',,C'0'         PROCESSING OBJECT OF DO GROUP\n*        EQU   X'08',,C'0'             UNUSED\n*        EQU   X'04',,C'0'             UNUSED\nIFTRUE   EQU   X'02',,C'0'         LAST .IF WAS TRUE\nIFFALSE  EQU   X'01',,C'0'         LAST .IF WAS FALSE\n         SPACE\nIFCWTE   EQU   X'80',,C'1'         .TH OR .EL CONTROL WORD\nIFCWUR   EQU   X'40',,C'1'         .UR/.DO/.EN CONTROL WORD\nIFCWIF   EQU   X'20',,C'1'         .IF CONTROL WORD\n*        EQU   X'10',,C'1'             UNUSED\n*        EQU   X'08',,C'1'             UNUSED\n*        EQU   X'04',,C'1'             UNUSED\n*        EQU   X'02',,C'1'             UNUSED\n*        EQU   X'01',,C'1'             UNUSED\n         SPACE\nIXHBLK   DSECT ,                   INDEX HEADER BLOCK\nIXHBNEXT DS    A                   NEXT HEADER BLK AT SAME LEVEL\nIXHBLOWR DS    A                   FIRST HEADER BLK AT LOWER LEVEL\nIXHBENTA DS    A                   FIRST ENTRY BLK FOR THIS HEADER\nIXHBTXTL DS    AL1                 LENGTH-1 OF TEST STRING\nIXHBTXTU DS    0C                  UPPER CASE VERSION OF HEADER TEXT\n*                                       FOLLOWED BY LOWER CASE VERSION\nIXHBLKL  EQU   *-IXHBLK            LENGTH OF PREFIX PORTION\n         SPACE\nIXEBLK   DSECT ,                   INDEX ENTRY BLOCK\nIXEBNEXT DS    A                   NEXT ENTRY BLOCK FOR SAME HEADER\nIXEBTXTL DS    AL1                 LENGTH OF TEXT IN THIS BLOCK\nIXEBTXT  DS    0C                  INDEX ENTRIES TEXT\nIXEBLKL  EQU   64                  LENGTH OF EACH ENTRY BLOCK\nIXEBTXTA EQU   IXEBLKL-(IXEBTXT-IXEBLK)  SPACE AVAIL FOR TEXT\n         SPACE\n         SYSDSECT ,                SYSTEM INDEPENDENT DSECTS\n         SPACE\n*                                  DCB OFFSETS\nDCBDEVT  EQU   X'11'               DCB DEVICE TYPE\nDCBBUFNO EQU   X'14'               DCB BUFFER NUMBER\nDCBDSORG EQU   X'1A'               DCB DATA SET ORGANIZATION\nDCBRECFM EQU   X'24'               DCB RECORD FORMAT\nDCBDDNAM EQU   X'28'               DCB DDNAME\nDCBIFLGS EQU   X'2C'               DCBIFLG AFTER OPEN\nDCBOFLGS EQU   X'30'               DCB OPEN FLAGS\nDCBGET   EQU   X'30'               DCB GET/PUT ADDRESS\nDCBMACR  EQU   X'32'               MACRO INSTRUCTION REF BEFORE OPEN\nDCBBLKSI EQU   X'3E'               DCB BLOCK SIZE\nDCBLRECL EQU   X'52'               DCB RECORD LENGTH\n         SPACE 2\n         COPY  #REGS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DUMPIT": {"ttr": 4871, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x99\\x00\\x99\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 153, "newlines": 153, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        INTERNAL ROUTINE 'DUMPIT' -- FORMAT MINI DUMP                *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER:    LA    R1,ADDR OF DUMP AREA\n*                    $CALL  DUMPIT\n         SPACE\nDUMPIT  $ENTER ,\n         LR    X1,R1               AREA TO FORMAT FROM\n         USING DUMPAREA,X1         AND TELL THE ASSEMBLER\n         OC    DUMPPSW,DUMPPSW     ANY DATA PRESENT .Q\n         BZ    DUMP04              BRANCH BACK IF NOT\n         SPACE\n         BAL   RETURN,DUMPCLR      CLEAR PRINT BUFFER\n         LA    TEMP,ADBASE         POINT TO ENTRY ADDRESS FOR SCRIPT\n         BAL   RETURN,DUMPFMT      HEX FORMAT PLEASE\n         L     R1,ADBASE           MAIN SCRIPT ENTRY POINT\n         SR    COUNT,COUNT         ZERO LENGTH REGISTER\n         IC    COUNT,4(,R1)        LENGTH OF VERSION IDENT\n         BCTR  COUNT,0             LENGTH-1 FOR MOVE\n         EX    COUNT,DUMPMVC       MOVE IDENTIFICATION TO LINE\n         MVI   0(X3),C'0'          DOUBLE SPACED PLEASE\n         LA    X3,3(COUNT,X3)      POINT AFTER IDENTIFICATION\n         MVI   0(X3),C'='          ADD AN EQUAL SIGN\n         MVC   2(6,X3),DUMPWRK+2   ADD ENTRY ADDRESS\n         BAL   RETURN,DUMPPRT      AND PRINT THE RESULT\n         SPACE\n         MVC   0(L'DMES01,X3),DMES01  FIRST MESSAGE\n         LA    X3,1+L'DMES01(,X3)  BUMP MESSAGE POINTER\n         LA    TEMP,DUMPPSW        FIRST HALF OF PSW\n         BAL   RETURN,DUMPFMT      TO EXTERNAL FORMAT\n         MVC   0(4,X3),DUMPWRK+4   ABEND CODE\n         CLI   0(X3),C'0'          0XXX ABEND .Q\n         BNE   DUMP01              BRANCH IF NOT\n         MVI   0(X3),C' '          CLEAR THE LEADING ZERO\n         CLI   1(X3),C'0'          0XX ABEND CODE .Q\n         BNE   DUMP01              BRANCH IF NOT\n         CLI   2(X3),C'0'          X0X ABEND CODE .Q\n         BNE   DUMP01              BRANCH IF NOT\n         MVI   2(X3),C'C'          XCX ABEND NOW\nDUMP01   DS    0H\n         BAL   RETURN,DUMPPRT      PRINT THE RESULT\n         SPACE\n         OC    DUMPPSW+4(4),DUMPPSW+4  ANY ADDRESS\n         BZ    DUMP04              BRANCH BACK IF NOT\n         MVC   0(L'DMES02,X3),DMES02  SECOND MESSAGE\n         LA    X3,2+L'DMES02(,X3)  BUMP MESSAGE POINTER\n         MVC   0(8,X3),DUMPWRK     FIRST HALF PSW\n         LA    TEMP,DUMPPSW+4      POINT SECOND HALF\n         BAL   RETURN,DUMPFMT      FORMAT SECOND HALF\n         MVC   9(8,X3),DUMPWRK     SECOND HALF PSW\n         BAL   RETURN,DUMPPRT      PRINT THE RESULT\n         SPACE\n         MVC   0(L'DMES03,X3),DMES03  THIRD MESSAGE\n         BAL   RETURN,DUMPPRT      PRINT THE RESULT\n         SPACE\n         OC    DUMPREG(16*4),DUMPREG  ANY REGISTERS SAVED .Q\n         BZ    DUMP04              BRANCH BACK IF NOT\n         SR    COUNT,COUNT         START AT THE BEGINNING\nDUMP02   DS    0H\n         LR    TEMP,COUNT          REGISTER NUMBER\n         BAL   RETURN,DUMPDEC      CONVERT TO DECIMAL\n         MVC   2(2,X3),DUMPWRK+10  REGISTER NUMBER\n         SLL   TEMP,2              REGISTER TIMES FOUR\n         LA    TEMP,DUMPREG(TEMP)  POINTER TO SAVED REG\n         BAL   RETURN,DUMPFMT      HEX FORMAT\n         MVC   5(8,X3),DUMPWRK     ADD THAT TO MESSAGE\n         L     TEMP,0(,TEMP)       REGISTER VALUE\n         BAL   RETURN,DUMPDEC      MAKE THAT PRINTABLE\n         MVC   13(12,X3),DUMPWRK   ADD THAT TOO\n         LR    TEMP,COUNT          REGISTER NUMBER\n         SLL   TEMP,2              REGISTER TIMES FOUR\n         L     TEMP,DUMPREG(TEMP)  REGISTER CONTENTS\n         LA    TEMP,0(,TEMP)       CLEAR HIGH BYTE\n         C     TEMP,ADBASE         BEFORE SCRIPT START .Q\n         BL    DUMP03              BRANCH IF YES\n         C     TEMP,VSCRLAST       AFTER THE END .Q\n         BH    DUMP03              BRANCH IF YES\n         BAL   RETURN,DUMPFMT      HEX FORMAT OF FIRST WORD\n         MVC   27(8,X3),DUMPWRK    FIRST WORD\n         LA    TEMP,4(,TEMP)       POINT TO SECOND WORD\n         BAL   RETURN,DUMPFMT      HEX FORMAT OF SECOND WORD\n         MVC   36(8,X3),DUMPWRK    SECOND WORD\n         LA    TEMP,4(,TEMP)       POINT TO THIRD WORD\n         BAL   RETURN,DUMPFMT      HEX FORMAT OF THIRD WORD\n         MVC   45(8,X3),DUMPWRK    THIRD WORD\n         SPACE\nDUMP03   DS    0H\n         BAL   RETURN,DUMPPRT      PRINT THE RESULT\n         LA    COUNT,1(,COUNT)     BUMP REGISTER COUNTER\n         C     COUNT,F15           AT THE END .Q\n         BNH   DUMP02              BRANCH BACK IF NOT YET\nDUMP04   DS    0H\n        $EXIT  RC=0                AND RETURN\n         DROP  X1\n         SPACE\nDUMPFMT  DS    0H\n         UNPK  DUMPWRK(9),0(5,TEMP)  UNPACK HEX VALUE\n         TR    DUMPWRK(8),DUMPTR   AND MAKE IT PRINTABLE\n         BR    RETURN              RETURN TO CALLER\n         SPACE\nDUMPDEC  DS    0H\n         LA    R0,C' '             ASSUME PLUS\n         LTR   TEMP,TEMP           IS IT POSITIVE .Q\n         BNM   DUMPDEC1            BRANCH IF YES\n         LA    R0,C'-'             MINUS SIGN AT START\n         LPR   TEMP,TEMP           POSITIVE VALUE\nDUMPDEC1 DS    0H\n         CVD   TEMP,DECM           CONVERT TO DECIMAL\n         OI    DECM+7,X'0F'        FIX THE SIGN\n         MVC   DUMPWRK,DUMPMSK     ENTER EDIT MASK\n         LA    R1,DUMPWRK+11       IN CASE NO SIG SET\n         EDMK  DUMPWRK,DECM+2      ENTER THE DATA\n         BCTR  R1,0                PULL BACK ONE\n         STC   R0,0(,R1)           AND SET THE SIGN\n         BR    RETURN              AND RETURN TO CALLER\n         SPACE\nDUMPPRT  DS    0H\n        $SAVE  ,                   SAVE CALLER'S REGISTERS\n         L     X3,BUFF3AD          PRINT BUFFER\n         LA    R1,84(,X3)          LAST POSSIBLE PRINT POSN\nDUMPPRT1 DS    0H\n         CLI   0(R1),C' '          TRAILING BLANK\n         BNE   DUMPPRT2            BRANCH IF NOT\n         BCT   R1,DUMPPRT1         DECREMENT AND TRY AGAIN\nDUMPPRT2 DS    0H\n         SR    R1,X3               LENGTH-1\n         BNP   DUMPPRT3            BRANCH IF NOTHING\n         LA    R1,1(,R1)           LENGTH INC RDW\n         STH   R1,0(,X3)           SET RDW LENGTH\n         LR    R0,X3               POINT TO RDW AND DATA\n        $CALL  PUTTERM             OUTPUT THE RESULT\nDUMPPRT3 DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         B     DUMPCLR             RETURN VIA RECORD CLEAR\n         SPACE\nDUMPCLR  DS    0H\n         L     X3,BUFF3AD          PRINT BUFFER\n         XC    0(4,X3),0(X3)       CLEAR THE RDW\n         LA    X3,4(,X3)           POINT TO DATA\n         MVC   0(B2LG,X3),BLANKS   CLEAR DATA PORTION\n         BR    RETURN              AND RETURN TO CALLER\n         SPACE\nDUMPMVC  MVC   1(*-*,X3),5(R1)     EXECUTED MOVE VERSION IDENT\nDMES01   DC    C'0PROGRAM INTERRUPT'\nDMES02   DC    C' PROGRAM STATUS WORD'\nDMES03   DC    C'0REG      HEX     DECIMAL  CONTENTS'\nDUMPTR   EQU   *-240\n         DC    C'0123456789ABCDEF' MAKE HEX PRINTABLE\nDUMPMSK  DC    XL12'402020202020202020202120'  DECIMAL MASK\nDUMPWRK  DC    CL12'************'  FORMATTING WORK AREA\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#EF": {"ttr": 4875, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x13\\x00\\x13\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .EF (END OF FILE) --- CONTROL                          *\n*                                                                     *\n***********************************************************************\n         SPACE\nEF      $ENTER ,\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BNEG,EF02           BRANCH IF NEGATIVE\n         BC    15-BDNO,EF01        BRANCH IF NOT INVALID\n         MVI   EFLAG005,ERRSET     SET ERROR FLAG\n         B     EF02                AND GO TO RETURN\nEF01     DS    0H\n         SR    R1,R1               ZERO WORK REGISTER\n         BCTR  R1,0                MINUS ONE AS PARM\n        $CALL  RDFILE              CLOSE CURRENT INPUT FILE\n         SPACE\nEF02     DS    0H\n        $EXIT  RC=0                AND GO GET NEXT RECORD\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#EL": {"ttr": 4877, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x18\\x00\\x18\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .EL (ELSE) --- CONTROL                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nEL      $ENTER ,\n        $OFF   IFSTAK,IFLAST       .IF IS NO LONGER LAST\n        $IFNONE IFSTAK,(IFTRUE,IFFALSE),EL01    T OR F MUST BE SET\n        $IFANY IFSTAK,(IFTHEN,IFELSE),EL01      NOT OBJECT OF .TH/.EL\n        $IFON  IFSTAK,IFDO,EL01    NOT WITHIN A DO GROUP\n        $ON    IFSTAK,IFELSE       THIS IS AN ELSE\n        $CALL  USARG               MOVE OVER ARGUMENT LINE\n         BC    BOMIT,EL02          BRANCH IF NO OPERAND\n         LA    R15,WRETNR          RETURN CODE TO PROCESS THE RESULT\n         B     EL03                AND GO TO RETURN\n         SPACE\nEL01     DS    0H\n         MVI   EFLAG023,ERRSET     INVALID ELSE FLAG\nEL02     DS    0H\n         SR    R15,R15             SET RETURN CODE TO IGNORE\n         SPACE\nEL03     DS    0H\n        $EXIT  RC=(R15)            RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#EM": {"ttr": 4879, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x1d\\x00\\x1d\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .EM (EMPTY PAGE) --- CONTROL                           *\n*                                                                     *\n***********************************************************************\n         SPACE\nEM      $ENTER ,\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BOMIT+BPOS,EM01     BRANCH IF NULL OR AFFIRMATIVE\n         BC    BNEG,EM02           BRANCH IF NEGATIVE\n         CLI   YNRESULT,YNOFN      IS ARGUMENT DOUBLE NEGATIVE .Q\n         BE    EM03                BRANCH IF YES\n         MVI   EFLAG005,ERRSET     NEITHER IS THE CASE\n         B     EM04                AND GO TO RETURN\n         SPACE\nEM01     DS    0H\n        $OFF   SWITCHS,(FNOEMPTY,FNOEMBMP)  ALLOW EMPTY PAGES\n         B     EM04                GO TO RETURN\n         SPACE\nEM02     DS    0H\n        $ON    SWITCHS,FNOEMPTY    DON'T ALLOW EMPTY PAGES\n        $OFF   SWITCHS,FNOEMBMP    BUT INCREMENT PAGE NUMBER\n         B     EM04                GO TO RETURN\n         SPACE\nEM03     DS    0H\n        $ON    SWITCHS,(FNOEMPTY,FNOEMBMP)  NO EMPTY PGS, NO BUMP\n         SPACE\nEM04     DS    0H\n        $EXIT  RC=0                RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#EN": {"ttr": 4881, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x18\\x00\\x18\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .EN (END DO GROUP) --- CONTROL                         *\n*                                                                     *\n***********************************************************************\n         SPACE\nEN      $ENTER ,\nEN01     DS    0H\n        $IFOFF IFSTAK,IFDO,EN02    BRANCH IF NOT WITHIN DO GROUP\n        $OFF   IFSTAK,IFDO         SET END OF DO GROUP\n         B     EN03                GO TO RETURN\n         SPACE\nEN02     DS    0H\n        $IFANY IFSTAK,(IFTHEN,IFELSE),ENE028  ERROR IF IN .THEN/.ELSE\n        $IFNONE IFSTAK,(IFTRUE,IFFALSE),ENE028  ERROR IF NOT TRUE/FALSE\n         MVC   IFSTAK,IFSTAK+IFSTAKSP   POP THE .IF STACK\n         B     EN01                AND TRY AGAIN\n         SPACE\nEN03     DS    0H\n        $EXIT  RC=0                GO TO RETURN\n         SPACE\nENE028   DS    0H\n         MVI   EFLAG028,ERRSET     .EN DOESN'T MATCH .DO\n         B     EN03                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#ER": {"ttr": 5121, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x003\\x003\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .ER (ERROR MESSAGE) --- CONTROL                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nER      $ENTER ,\n         L     X1,ARGSTART         MESSAGE MAY FOLLOW IMMEDIATELY\n        $CALL  GETNUM              GET ERROR RETURN CODE\n         BC    BOMIT,ER04          DO NOTHING, IF NOTHING THERE\n         BC    BDNO,ER02           BRANCH IF NOT NUMERIC\n         LTR   X2,COUNT            TEST RESULT\n         BM    ERE014              ERROR IF NEGATIVE\n         CH    X2,RETCODE          HIGHER THAN LAST .Q\n         BNH   ER01                BRANCH IF NOT\n         STH   X2,RETCODE          SET NEW RETURN CODE\nER01     DS    0H\n         L     X1,ARGSTART         MESSAGE FOLLOWS\n         LA    R0,ERRTERM          TERMINAL ERROR CODE\n         CR    X2,R0               WORSE THAN TERMINAL .Q\n         BNH   ER03                PROCESS AS IS IF NOT\n         LR    X2,R0               ELSE TERMINAL IS BAD ENOUGH\n         B     ER03                GO PROCESS MESSAGE\n         SPACE\nER02     DS    0H\n         ST    COUNT,ARGSTART      RESCAN FOR IDENTIFIER\n         LA    X2,ERRINFO          THIS IS AN INFORMATION MESSAGE\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION PLEASE\n        $CALL  GETARG              GET ARGUMENT STRING\n         LTR   TEMP,TEMP           LENGTH-1 ZERO .Q\n         BNZ   ER03                BRANCH IF NOT\n         CLI   0(COUNT),C'*'       '*' MEANS NO RETURN CODE\n         BNE   ER03                BRANCH IF NOT\n         L     X1,ARGSTART         MESSAGE FOLLOWS\n         SPACE\nER03     DS    0H\n         L     COUNT,ARGSTOP       ADDR OF END OF RECORD\n         SR    COUNT,X1            COMPUTE LENGTH OF LINE TO PRINT\n         BNP   ER04                EXIT IF NOTHING TO PRINT\n         LA    X1,1(,X1)           BUMP START OVER BLANK DELIM\n         ST    X1,ERRTEXT          POINT TO MESSAGE STRING\n         STC   COUNT,ERRTEXT       SET LENGTH OF STRING\n         STC   X2,EFLAG050         SET ERROR SEVERITY\n        $CALL  ERROUT              PRINT THE RESULT\n         SPACE\nER04     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nERE014   DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND VALUE TOO SMALL\n         B     ER04                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#ERROUT": {"ttr": 5123, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\xc9\\x00\\xc9\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 201, "newlines": 201, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL ROUTINE 'ERROUT' -- FORMAT ERROR MESSAGES     *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON EXIT:  R15 = 0      IF ABLE TO CONTINUE PROCESSING\n*                  $CALL QUITS  IF UNABLE TO CONTINUE PROCESSING\n         SPACE\nERROUT  $ENTER ,\n         LA    X3,0                ASSUME NO ERRORS\n         SPACE\nERRO01   DS    0H\n         L     R1,UPTABAD          ONLY X'00' AT THE START\n         TRT   ERRFLGS,0(R1)       FIND FIRST ERROR FLAG, IF ANY\n         BZ    ERRO12              BRANCH OUT IF NONE\n         LR    X1,R1               POINT TO ERROR FLAG\n         SR    X3,X3               CLEAR FOR SEVERITY\n         IC    X3,0(,X1)           GET ERROR SEVERITY\n         LA    R0,ERRTERM          TERMINAL ERROR LEVEL\n         CR    X3,R0               COMPARE ACTUAL WITH TERMINAL\n         BL    ERRO02              BRANCH IF NOT TERMINAL\n         LR    X3,R0               SET CODE TO TERMINAL\n         STC   X3,0(,X1)           MAKE SURE A VALID CODE\n         MVC   PASSNO,DEFPASOF+TAB3DEF  PREVENT FURTHER PASSES\n         XC    ERCONT,ERCONT       ZERO ERROR CONTINUE COUNT\n         SPACE\nERRO02   DS    0H\n         CLI   0(X1),ERRWARN       IS THIS LESS THAN A WARNING .Q\n         BL    ERRO03A             BRANCH AROUND IF YES\n         CH    X3,RETCODE          HIGHER RETURN CODE .Q\n         BNH   ERRO03              BRANCH IF NOT\n         STH   X3,RETCODE          SET NEW RETURN CODE\n         SPACE\nERRO03   DS    0H\n         L     R0,ERCONT           USER ERROR CONTINUE COUNT\n         S     R0,F1               LESS ONE\n         BM    ERRO04              BRANCH IF ALL THROUGH\n         ST    R0,ERCONT           UPDATE ERROR CONTINUE COUNT\nERRO03A  DS    0H\n         LA    X3,0                AND WE MAY CONTINUE\n         B     ERRO05              CONTINUE\nERRO04   DS    0H\n         LA    X3,4                SET UNABLE TO CONTINUE RETURN CODE\n         MVC   PASSNO,DEFPASOF+TAB3DEF  PREVENT FURTHER PASSES\n         SPACE\nERRO05   DS    0H\n         LA    COUNT,ERRFLGS       START OF ERROR FLAGS\n         SR    COUNT,X1            LESS CURRENT FLAG POINTER\n         LPR   COUNT,COUNT         MAKE IT POSITIVE\n         SLL   COUNT,1             DOUBLE SAME\n         LA    R1,ERROMSG          MESSAGE TABLE BASE\n         AH    R1,0(COUNT,R1)      POINT TO ERROR DATA\n         L     COUNT,BUFF3AD       POINT TO WORK AREA\n         XC    0(4,COUNT),0(COUNT) CLEAR RDW\n         MVC   4(B2LG,COUNT),BLANKS     CLEAR ALL WORK BUFFER\n         MVC   4(L'ERRSTPR,COUNT),ERRSTPR    MOVE ERROR PREFIX\n         SR    TEMP,TEMP           PREPARE WORK REGISTER\n         IC    TEMP,0(,R1)         GET LENGTH-1 OF MESSAGE\n         EX    TEMP,ERRSTMVC       ADD MESSAGE TEXT\n         LA    TEMP,5+L'ERRSTPR(,TEMP)  TOTAL LENGTH INCL RDW\n         STH   TEMP,0(,COUNT)      SET LENGTH\n         SPACE\n         SR    X2,X2               ZERO LENGTH REGISTER\n         IC    X2,ERRTEXT          LENGTH OF ANY ADDITIONAL TEXT\n         S     X2,F1               LENGTH-1\n         BM    ERRO05A             BRANCH IF NONE\n         LA    R1,1(TEMP,X2)       TOTAL NEW MESSAGE LENGTH\n         STH   R1,0(,COUNT)        SET NEW MESSAGE LENGTH\n         LA    TEMP,0(COUNT,TEMP)  EXTRA TEXT TARGET\n         BCTR  TEMP,0              BACKUP POINTER TO REMOVE '.'\n         L     R1,ERRTEXT          EXTRA TEXT ADDRESS\n         EX    X2,ERREXMVC         ADD EXTRA TEXT\n         XC    ERRTEXT,ERRTEXT     CLEAR EXTRA TEXT POINTER\n         SPACE\nERRO05A  DS    0H\n         SR    R1,R1               CLEAR FOR SEVERITY\n         IC    R1,0(,X1)           SEVERITY CODE\n         SRL   R1,2                OFFSET IN SUFFIX CHARACTERS\n         IC    R1,ERRSTSU(R1)      SUFFIX CHARACTER\n         STC   R1,7+L'ERRSTPR(,COUNT)   SET ERROR SUFFIX TYPE\n         MVI   0(X1),ERRCLR        CLEAR ERROR FLAG\n         LR    R0,COUNT            POINT TO CONSTRUCTED MESSAGE\n        $CALL  PRTERM              PRINT FIRST LINE OF ERROR\n         XC    0(4,COUNT),0(COUNT) CLEAR RDW\n         MVC   4(B2LG,COUNT),BLANKS     CLEAR ALL OF WORKING BUFFER\n         MVC   4(L'ERROUM,COUNT),ERROUM ENTER FIRST ERROR MESSAGE\n         SPACE\n         CLC   COMFILNM,BLANKS     NO FILENAME HERE .Q\n         BE    ERRO09              YES, FORGET SECOND LINE\n         MVC   28(8,COUNT),COMFILNO     COPY LINE NUMBER\n         LA    R1,4+L'ERROUM(,COUNT)    END OF STRING\n         MVC   0(8,R1),COMFILNM    COPY FILE NAME\n         BAL   RETURN,ERRSKBL      SKIP BLANKS\n         SPACE\n         CLI   COMMEMNM,C' '       ANY MEMBER NAME .Q\n         BE    ERRO06              BRANCH IF NONE\n         MVI   0(R1),C'('          LEFT PAREN\n         MVC   1(8,R1),COMMEMNM    ADD MEMBER NAME\n         BAL   RETURN,ERRSKBL      SKIP BLANKS\n         MVI   0(R1),C')'          RIGHT PAREN\n         LA    R1,1(,R1)           SKIP PAREN\n         SPACE\nERRO06   DS    0H\n         MVI   0(R1),C':'          MORE ON NEXT LINE\n         LA    R1,1(,R1)           POINT TO END OF STRING\n         SR    R1,COUNT            LENGTH OF STRING INCL RDW\n         STH   R1,0(,COUNT)        SET LENGTH\n         LR    R0,COUNT            ADDRESS OF RECORD\n        $CALL  PRTERM              PRINT SECOND LINE\n         L     X1,CURFILE          CURRENT FILE CONTROL BLOCK\n         LTR   X1,X1               CURRENT FILE STILL ON RDR STACK .Q\n         BZ    ERRO09              NO, AFTER EOF PROCESSED\n         USING FILBLOCK,X1         AND TELL THE ASSEMBLER\nERRO07   DS    0H\n         L     X1,FILPREV          PREVIOUS FILE IN INPUT STACK\n         LTR   X1,X1               ANY PREVIOUS FILE .Q\n         BZ    ERRO09              BRANCH IF NOTHING\n         XC    0(4,COUNT),0(COUNT) CLEAR WORK RDW\n         MVC   4(B2LG,COUNT),BLANKS     CLEAR ALL OF WORKING BUFFER\n         MVC   4(L'ERROUF,COUNT),ERROUF ENTER FROM MESSAGE\n         MVC   28(8,COUNT),FILNUMBR     COPY FILE LINE NUMBER\n         LA    R1,4+L'ERROUF(,COUNT)    END OF STRING\n         MVC   0(8,R1),FILDDNAM    COPY LOGICAL FILE NAME\n         BAL   RETURN,ERRSKBL      SKIP BLANKS\n         CLI   FILMEMNM,C' '       ANY MEMBER NAME .Q\n         BE    ERRO08              BRANCH IF NONE\n         MVI   0(R1),C'('          LEFT PAREN\n         MVC   1(8,R1),FILMEMNM    ADD MEMBER NAME\n         BAL   RETURN,ERRSKBL      SKIP TO BLANK\n         MVI   0(R1),C')'          RIGHT PAREN\n         LA    R1,1(,R1)           SKIP PAREN\nERRO08   DS    0H\n         MVI   0(R1),C':'          MORE ON NEXT LINE\n         LA    R1,1(,R1)           POINT TO END OF STRING\n         SR    R1,COUNT            SET MESSAGE LENGTH\n         STH   R1,0(,COUNT)        SET LENGTH IN RDW\n         LR    R0,COUNT            ADDRESS OF MESSAGE\n        $CALL  PRTERM              PRINT RESULTING MESSAGE\n         B     ERRO07              AND TRY AGAIN\n         DROP  X1\n         SPACE\nERRO09   DS    0H\n         LH    TEMP,BUFF2LGZ       GET LENGTH OF CURRENT INPUT\n         LTR   TEMP,TEMP           ANYTHING THERE .Q\n         BNP   ERRO10              BRANCH IF NOT\n         EX    TEMP,ERROUMVC       MOVE RECORD TO TARGET\n         LA    TEMP,5(,TEMP)       PLUS CARRIAGE CONTROL AND RDW\n         STH   TEMP,0(,COUNT)      SET RECORD LENGTH\n         LR    R0,COUNT            ADDRESS OF RECORD\n        $CALL  PRTERM              PUT OUT RECORD IN ERROR\n         SPACE\n         MVC   4(B2LG,COUNT),BLANKS     CLEAR ALL OF WORK BUFFER AGAIN\n         LA    R1,BUFF2            RECORD IN ERROR\n         L     TEMP,ERRSTART       POSSIBLE ERROR LOCATION\n         SR    TEMP,R1             LOWER THAN START .Q\n         BM    ERRO10              YES, THEN OUT OF RANGE\n         LA    TEMP,6(,TEMP)       PLUS CC, RDW AND ASTERISK\n         CH    TEMP,0(,COUNT)      HIGHER THAN END .Q\n         BH    ERRO10              YES, THEN OUT OR RANGE AGAIN\n         STH   TEMP,0(,COUNT)      LENGTH OF THIS MESSAGE\n         AR    TEMP,COUNT          ERROR LOCATION\n         BCTR  TEMP,0              LESS ONE\n         MVI   0(TEMP),C'*'        ENTER ERROR INDICATOR\n         LR    R0,COUNT            ADDRESS OF RECORD\n        $CALL  PRTERM              PUT OUT ERROR INDICATOR\n         SPACE\nERRO10   DS    0H\n         L     R1,DUMPAD           DUMP AREA ADDRESS\n         USING DUMPAREA,R1         AND TELL THE ASSEMBLER\n         OC    DUMPPSW,DUMPPSW     ANYTHING THERE .Q\n         BZ    ERRO11              BRANCH IF NOT\n        $CALL  DUMPIT              GO TO FORMAT A DUMP\n         DROP  R1\nERRO11   DS    0H\n         B     ERRO01              CHECK FOR MULTIPLE ERRORS\n         SPACE\nERRO12   DS    0H\n         LTR   X3,X3               CAN WE NOW CONTINUE .Q\n         BZ    ERRO13              BRANCH IF YES\n         LA    R1,WRETQQ           IMMEDIATE TERMINATION CODE\n        $CALL  QUITS               CALL TERMINATION ROUTINE\nERRO13   DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nERRSKBL  DS    0H\n         LA    R1,1(,R1)           POINT TO NEXT CHAR\n         CLI   0(R1),C' '          IS IT A BLANK .Q\n         BNE   ERRSKBL             LOOP BACK IF NOT\n         BR    RETURN              RETURN TO CALLER\n         SPACE\nERRSTMVC MVC   4+L'ERRSTPR(*-*,COUNT),1(R1)  ADD MSG TEXT\nERREXMVC MVC   0(*-*,TEMP),0(R1)   ADD EXTRA TEXT TO MESSAGE\nERROUMVC MVC   5(*-*,COUNT),BUFF2  EXECUTED MOVE ERROR RECORD\n         SPACE\nERRSTPR  DC    C'0SCRW'            CC/ERROR MESSAGE PREFIX\nERRSTSU  DC    C'IWEST?'           ERROR MESSAGE SUFFIX CHARACTERS\nERROUM   DC    C' ERROR OCCURRED AT LINE ******** OF FILE '\nERROUF   DC    C'       CALLED FROM LINE ******** OF FILE '\n         SPACE 2\nERROMSG $MSGSECT TYPE=MSG,DOC=GEN  GENERATE ERROR MESSAGE TEXT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#EZ": {"ttr": 5127, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x16\\x00\\x16\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .EZ (EASY SCRIPT) --- CONTROL                          *\n*                                                                     *\n***********************************************************************\n         SPACE\nEZ      $ENTER ,\n         XC    APIMFLAG,APIMFLAG   CLEAR FILE FLAGS\n        $ON    APIMFLAG,IO$IM      TURN IMBED FLAG ON\n         MVC   APIMNAME,EZNAME     EASY SCRIPT FILENAME\n         MVC   APIMMEMB,BLANKS     AND BLANK OUT MEMBER NAME\n         SPACE\n        $CALL  APS                 SCAN OPERANDS\n         BC    BNEG,EZ01           BRANCH IF ARGUMENT ERRORS\n         SPACE\n         LA    R1,APIMBLOK         POINT TO FILE DESCRIPTOR\n        $CALL  RDFILE              INSERT CALL TO EASY SUPPORT\n         SPACE\nEZ01     DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\nEZNAME   DC    CL8'SYSEZ'          EASY SCRIPT FILENAME\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#FB": {"ttr": 5129, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x98\\x00\\x98\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 152, "newlines": 152, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .FB (FLOATING BLOCK) --- CONTROL                       *\n*                                                                     *\n***********************************************************************\n         SPACE\nFB      $ENTER ,\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BPOS,FBBEG          BRANCH IF START\n         BC    BNEG,FBEND          BRANCH IF END\n         BC    BOMIT,FBE003        BRANCH IF ARG OMITTED\n         CLI   YNRESULT,YNDUMP     WAS ARGUMENT 'DUMP' .Q\n         BE    FBDUMP              BRANCH IF YES\n         B     FBE005              BRANCH IF ARG INVALID\n         SPACE\nFBBEG    DS    0H\n         CLI   ICORFLG,ICORNONE    ARE WE FORMATTING INTO CORE .Q\n         BNE   FBE012              ERROR IF YES\n         LA    R1,ICORSLEN         NEED THIS MUCH SPACE\n        $CALL  GETCELL             GET THE SPACE\n         BC    BNEG,FBE024         BRANCH IF FAILURE\n         USING ICORSAVE,TEMP       SAVE AREA LOOKS LIKE THIS\n         ST    TEMP,FBQSAVE        SAVE AREA POINTER\n         MVC   ICOROLD1,FMTOLD1    SAVE CURRENT SWITCHES\n         MVC   ICOROLD2,FMTOLD2    SAVE PAGE DESCRIPTORS\n         MVC   ICORBX,BXPTR        SAVE BOX BUILD POINTER\n         XC    BXPTR,BXPTR         CLEAR CURRENT BOX IN PROGRESS\n         MVC   ICOROO,OOANCH       SAVE OUTPUT OVERLAY ANCHOR\n         XC    OOANCH,OOANCH       CLEAR CURRENT OUTPUT OVERLAYS\n         MVC   ICORSKSP,SKSP       SAVE CONDITIONAL SKIP/SPACE\n         XC    SKSP,SKSP           CLEAR CURRENT SKIP/SPACE\n         DROP  TEMP\n         SPACE\n         XC    OLDCOUNT,OLDCOUNT   WIPE OUT PREVIOUS LINE\n         MVI   ICORFLG,ICORFB      NOW SAVING FLOATING BLOCK\n         LA    TEMP,FBAREA         FLOATING BLOCK CONTROL\n         ST    TEMP,ICORANCH       SAVE THIS FOR LATER\n         LH    TEMP,INDL           RESET INDENT\n         AH    TEMP,OFFLI          ..\n         STH   TEMP,INDL           ..\n         STH   TEMP,RMARGIN        SET RIGHT MARGIN\n         SR    TEMP,TEMP           ZERO WORK REGISTER\n         STH   TEMP,INDENTR        ZERO RIGHT INDENT VALUE\n         STH   TEMP,PICNT          ZERO PARAGRAPH INDENT\n         STH   TEMP,HICNT          ZERO HANGING INDENT\n         STH   TEMP,UNDL           ZERO UNDENT VALUE\n         STH   TEMP,OFFLI          ZERO OFFSET VALUE\n         STH   TEMP,CECNT          ZERO CENTER VALUE\n         STH   TEMP,LICNT          ZERO LITERAL VALUE\n         B     FBDONE              START SAVING THE FLOATING BLOCK\n         SPACE\nFBEND    DS    0H\n         CLI   ICORFLG,ICORFB      NOW SAVING A .FB SEQUENCE INCORE .Q\n         BNE   FBE012              ERROR IF NOT\n        $CALL  PRINT               CLEAR LAST .FB LINE FROM BUFFER\n         SPACE\n        $CALL  GETNUM              GET ANY EXTRA USER REQUEST\n         BC    15-BDNO,FBEND01     BRANCH IF NOT INVALID\n         MVI   EFLAG005,ERRSET     SET INVALID OPERAND\n         SR    COUNT,COUNT         AND USER ZERO EXTRA VALUE\n         B     FBEND02             AND CONTINUE\nFBEND01  DS    0H\n         BC    15-BOMIT,FBEND02    BRANCH IF NOT OMITTED\n         SR    COUNT,COUNT         SET USER EXTRA VALUE ZERO\nFBEND02  DS    0H\n         LA    R1,FBAREA           FLOATING BLOCK DESCRIPTOR AREA\n        $CALL  CPENDS              TERMINATE THE BLOCK\n         SPACE\n         L     X1,FBQANCH          FLOATING BLOCK ANCHOR\n         LTR   X1,X1               ANY DATA AT ALL .Q\n         BZ    FBEND05             BRANCH IF NONE\n         USING FNQELEM,X1          TELL THE ASSEMBLER WHERE WE ARE\nFBEND03  DS    0H\n         OC    FNQFCHN,FNQFCHN     LAST ENTRY .Q\n         BZ    FBEND04             BRANCH IF YES\n         L     X1,FNQFCHN          NEXT ENTRY POINTER\n         B     FBEND03             SEARCH FORWARD\nFBEND04  DS    0H\n        $ON    FNQFLAG,FNQONE      PRINT BUT ONE AT A TIME\n         DROP  X1\n         SPACE\nFBEND05  DS    0H\n         L     TEMP,FBQSAVE        RESTORE SAVED AREA POINTER\n         XC    FBQSAVE,FBQSAVE     CLEAR POINTER\n         USING ICORSAVE,TEMP       AREA LOOKS LIKE THIS\n        $CALL  BXCLR               DELETE ANY BOX IN PROGRESS\n         LA    R1,OOANCH           OUTPUT OVERLAY ANCHOR\n        $CALL  OVCLR               DELETE ANY IN PROGRESS\n        $MVC   FMTOLD1,ICOROLD1    RESTORE CURRENT SWITCHES\n        $MVC   FMTOLD2,ICOROLD2    RESTORE PAGE DESCRIPTORS\n        $MVC   BXPTR,ICORBX        RESTORE BOX IN PROGRESS\n        $MVC   OOANCH,ICOROO       RESTORE OUTPUT OVERLAY IN PROGRESS\n        $MVC   SKSP,ICORSKSP       RESTORE CONDITIONAL SKIP/SPACE\n         LA    R0,ICORSAVE         POINT TO AREA\n         LA    R1,ICORSLEN         LENGTH OF SAVE AREA\n        $CALL  FREECELL            RELEASE WORK AREA\n         DROP  TEMP\n         SPACE\n         MVI   ICORFLG,ICORNONE    RESET SAVING INCORE SWITCH\n         XC    ICORANCH,ICORANCH   CLEAR FLOATING BLOCK CONTROL\n         SPACE\n         LA    R1,FBAREA           POINT TO FB ANCHOR DATA\n        $CALL  CPFKNXT             GET COUNT OF FIRST BLOCK\n         B     FBDONE              ALL THROUGH\n         SPACE\nFBDUMP   DS    0H\n         CLI   ICORFLG,ICORNONE    CURRENTLY FORMATTING INCORE .Q\n         BNE   FBE012              ERROR IF YES\n        $CALL  GETNUM              GET CALL COUNT\n         BC    BDNO,FBE005         ERROR IF INVALID\n         BC    BNEG,FBE014         ERROR IF TOO SMALL\n         BC    BPOS,FBDUMP01       BRANCH IF VALID\n         L     COUNT,F32767        ELSE DO A LARGE NUMBER\nFBDUMP01 DS    0H\n         S     COUNT,F1            DECREMENT CALL COUNT\n         BM    FBDUMP04            BRANCH IF DONE\nFBDUMP02 DS    0H\n         L     X1,FBQANCH          FLOATING BLOCK ANCHOR\n         LTR   X1,X1               ANY DATA AT ALL .Q\n         BZ    FBDUMP04            QUIT IF NONE\n        $IFOFF SWITCHS,FEMPTY,FBDUMP03  BRANCH IF PAGE NOT EMPTY\n        $CALL  PAGETOP             PRINT PAGE HEADINGS FIRST\nFBDUMP03 DS    0H\n         LA    R1,FBAREA           .FB CONTROL DESCRIPTOR\n        $CALL  CPFKPRT             PRINT ALL DATA NOW\n         BC    BOMIT,FBDUMP04      BRANCH IF LAST BLOCK DONE\n         BC    BPOS,FBDUMP01       BRANCH IF FIRST BLOCK DONE\n        $CALL  PAGE                TERMINATE THIS PAGE\n         B     FBDUMP02            AND CONTINUE WITH CURRENT BLOCK\nFBDUMP04 DS    0H\n         LA    R1,FBAREA           .FB CONTROL DESCRIPTOR\n        $CALL  CPFKNXT             SET UP NEXT BLOCK LENGTH\n         B     FBDONE              AND GO TO RETURN\n         SPACE\nFBE003   DS    0H\n         MVI   EFLAG003,ERRSET     OMITTED CONTROL WORD\n         B     FBDONE              GO TO TERMINATE\nFBE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID CONTROL WORD\n         B     FBDONE              GO TO TERMINATE\nFBE012   DS    0H\n         MVI   EFLAG012,ERRSET     ILLEGAL CONTROL WORD\n         B     FBDONE              GO TO TERMINATE\nFBE014   DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     FBDONE              GO TO TERMINATE\nFBE024   DS    0H\n         MVI   EFLAG024,ERRSET     NO STORAGE FOR SAVE DATA\n         B     FBDONE              GO TO TERMINATE\n         SPACE\nFBDONE   DS    0H\n        $EXIT  RC=0                DONE WITH FLOATING BLOCK\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#FD": {"ttr": 5133, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x12\\x00\\x12\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .FD (ODD PAGE FOOTING) --- CONTROL                     *\n*              .OB (ODD BOTTOM TITLE) --- CONTROL                     *\n*                                                                     *\n***********************************************************************\n         SPACE\nOB      $ENTER ,\n        $ON    SWITCHS,FNOCASE     UPPER CASE FLAG FOR ALTERNATE FORMAT\n        $CALL  FD                  LET HIM DO THE WORK\n        $EXIT  RC=0                AND RETURN TO MAIN STREAM\n         SPACE\nFD      $ENTER ,\n         L     X1,ADODHEAD         PUT ITEMS IN ODD AREA\n         LNR   X1,X1               PUT ITEMS IN FOOT AREA\n        $CALL  HEADSAVE            ..\n        $OFF   SWITCHS,FNOCASE     RESET FORMAT FLAG\n        $EXIT  RC=0                NEXT INPUT LINE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#FE": {"ttr": 5135, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x19\\x00\\x19\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .FE (EVEN AND ODD PAGE FOOTING) --- CONTROL            *\n*              .BT (BOTTOM TITLE) --- CONTROL                         *\n*                                                                     *\n***********************************************************************\n         SPACE\nBT      $ENTER ,\n        $ON    SWITCHS,FNOCASE     UPPER CASE FLAG FOR ALTERNATE FORMAT\n        $CALL  FE                  LET HIM DO THE WORK\n        $EXIT  RC=0                AND RETURN TO MAIN STREAM\n         SPACE\nFE      $ENTER ,\n         L     COUNT,ARGSTART      REMEMBER ARGUMENT START ADDR\n         L     X1,ADEVHEAD         PUT OPERAND IN EVEN AREA\n         LNR   X1,X1               IN FOOTING AREA ALSO\n        $CALL  HEADSAVE            SCAN OPERAND\n         BC    BDNO,FE01           BRANCH IF ERROR\n         ST    COUNT,ARGSTART      DO IT AGAIN FOR ODD\n         L     X1,ADODHEAD         PUT OPERAND IN ODD AREA\n         LNR   X1,X1               IN FOOTING AREA ALSO\n        $CALL  HEADSAVE            SCAN OPERAND SECOND TIME\nFE01     DS    0H\n        $OFF   SWITCHS,FNOCASE     RESET FORMAT FLAG\n        $EXIT  RC=0                NEXT INPUT LINE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#FK": {"ttr": 5137, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\xab\\x00\\xab\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 171, "newlines": 171, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .FK (FLOATING KEEP) --- CONTROL                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nFK      $ENTER ,\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BPOS,FKBEG          BRANCH IF START\n         BC    BNEG,FKEND          BRANCH IF END\n         CLI   YNRESULT,YNDUMP     WAS ARGUMENT 'DUMP' .Q\n         BE    FKDUMP              YES, BRANCH TO PRINT\n         BC    BOMIT,FKE003        BRANCH IF ARG OMITTED\n         B     FKE005              BRANCH IF ARG INVALID\n         SPACE\nFKBEG    DS    0H\n         CLI   ICORFLG,ICORNONE    ARE WE FORMATTING INTO CORE .Q\n         BNE   FKE012              ERROR IF YES\n         LA    R1,ICORSLEN         NEED THIS MUCH SPACE\n        $CALL  GETCELL             GET THE SPACE\n         BC    BNEG,FKE024         BRANCH IF FAILURE\n         USING ICORSAVE,TEMP       SAVE AREA LOOKS LIKE THIS\n         ST    TEMP,FKQSAVE        SAVE AREA POINTER\n         MVC   ICOROLD1,FMTOLD1    SAVE CURRENT SWITCHES\n         MVC   ICOROLD2,FMTOLD2    SAVE PAGE DESCRIPTORS\n         MVC   ICORBX,BXPTR        SAVE BOX BUILD POINTER\n         XC    BXPTR,BXPTR         CLEAR CURRENT BOX IN PROGRESS\n         MVC   ICOROO,OOANCH       SAVE OUTPUT OVERLAY ANCHOR\n         XC    OOANCH,OOANCH       CLEAR CURRENT OUTPUT OVERLAYS\n         MVC   ICORSKSP,SKSP       SAVE CONDITIONAL SKIP/SPACE\n         XC    SKSP,SKSP           CLEAR CURRENT SKIP/SPACE\n         DROP  TEMP\n         SPACE\n         XC    OLDCOUNT,OLDCOUNT   WIPE OUT PREVIOUS LINE\n         MVI   ICORFLG,ICORFK      NOW SAVING FLOATING KEEP\n         LA    TEMP,FKAREA         FLOATING KEEP CONTROL\n         ST    TEMP,ICORANCH       SAVE THIS FOR LATER\n         LH    TEMP,INDL           RESET INDENT\n         AH    TEMP,OFFLI          ..\n         STH   TEMP,INDL           ..\n         STH   TEMP,RMARGIN        SET RIGHT MARGIN\n         SR    TEMP,TEMP           ZERO WORK REGISTER\n         STH   TEMP,INDENTR        ZERO RIGHT INDENT VALUE\n         STH   TEMP,PICNT          ZERO PARAGRAPH INDENT\n         STH   TEMP,HICNT          ZERO HANGING INDENT\n         STH   TEMP,UNDL           ZERO UNDENT VALUE\n         STH   TEMP,OFFLI          ZERO OFFSET VALUE\n         STH   TEMP,CECNT          ZERO CENTER VALUE\n         STH   TEMP,LICNT          ZERO LITERAL VALUE\n         B     FKDONE              START SAVING THE FLOATING KEEP\n         SPACE\nFKEND    DS    0H\n         CLI   ICORFLG,ICORFK      NOW SAVING A .FK SEQUENCE INCORE .Q\n         BNE   FKE012              ERROR IF NOT\n        $CALL  PRINT               CLEAR LAST .FK LINE FROM BUFFER\n         SPACE\n        $CALL  GETNUM              GET ANY EXTRA USER REQUEST\n         BC    15-BDNO,FKEND01     BRANCH IF NOT INVALID\n         MVI   EFLAG005,ERRSET     SET INVALID OPERAND\n         SR    COUNT,COUNT         AND USER ZERO EXTRA VALUE\n         B     FKEND02             AND CONTINUE\nFKEND01  DS    0H\n         BC    15-BOMIT,FKEND02    BRANCH IF NOT OMITTED\n         SR    COUNT,COUNT         SET USER EXTRA VALUE ZERO\nFKEND02  DS    0H\n         LA    R1,FKAREA           FLOATING KEEP DESCRIPTOR AREA\n        $CALL  CPENDS              TERMINATE THE BLOCK\n         SPACE\n         L     TEMP,FKQSAVE        RESTORE SAVED AREA POINTER\n         XC    FKQSAVE,FKQSAVE     CLEAR POINTER\n         USING ICORSAVE,TEMP       AREA LOOKS LIKE THIS\n        $CALL  BXCLR               DELETE ANY BOX IN PROGRESS\n         LA    R1,OOANCH           OUTPUT OVERLAY ANCHOR\n        $CALL  OVCLR               DELETE ANY IN PROGRESS\n        $MVC   FMTOLD1,ICOROLD1    RESTORE CURRENT SWITCHES\n        $MVC   FMTOLD2,ICOROLD2    RESTORE PAGE DESCRIPTORS\n        $MVC   BXPTR,ICORBX        RESTORE BOX IN PROGRESS\n        $MVC   OOANCH,ICOROO       RESTORE OUTPUT OVERLAY IN PROGRESS\n        $MVC   SKSP,ICORSKSP       RESTORE CONDITIONAL SKIP/SPACE\n         LA    R0,ICORSAVE         POINT TO AREA\n         LA    R1,ICORSLEN         LENGTH OF SAVE AREA\n        $CALL  FREECELL            RELEASE WORK AREA\n         DROP  TEMP\n         SPACE\n         MVI   ICORFLG,ICORNONE    RESET SAVING FLOAT SWITCH\n         XC    ICORANCH,ICORANCH   CLEAR FLOATING KEEP CONTROL\n         SPACE\n        $IFON  SWITCHS,FEMPTY,FKEND06   BRANCH IF PAGE NOW EMPTY\n         LH    TEMP,PLCT           COUNT OF LINES LEFT\n         S     TEMP,FKQCNT         LESS QUEUED LINE COUNT\n         SH    TEMP,SKSPCCNT       LESS ANY CONDITIONAL SPACES\n         SR    TEMP,COUNT          LESS USER'S EXTRA REQUEST\n         BM    FKEND07             BRANCH IF WON'T FIT\n         LH    R1,BMMRG            BOTTOM MARGIN\n         AH    R1,FNSEP            PLUS FOOTNOTE MARGIN\n         CR    TEMP,R1             BELOW BOTTOM MARGIN .Q\n         BL    FKEND07             WON'T FIT IF YES\n         LA    R1,FKAREA           .FK CONTROL DESCRIPTOR\n        $CALL  CPFKPRT             DUMP ALL DATA NOW\n         B     FKEND07             GO TO RETURN\nFKEND06  DS    0H\n         XC    SKSP,SKSP           CLEAR CONDITIONAL SPACES\n        $CALL  PAGETOP             PRINT HEADER AND SAVED LINES\nFKEND07  DS    0H\n         B     FKDONE              ALL THROUGH\n         SPACE\nFKDUMP   DS    0H\n         CLI   ICORFLG,ICORNONE    CURRENTLY FORMATTING INCORE .Q\n         BNE   FKE012              ERROR IF YES\n         SPACE\n        $CALL  GETNUM              GET BLOCK COUNT\n         LR    X3,COUNT            RETAIN BLOCK COUNT\n         BC    BDNO,FKE005         ERROR IF INVALID\n         BC    BNEG,FKE014         ERROR IF TOO SMALL\n         BC    BPOS,FKDUMP01       BRANCH IF VALID\n         L     X3,F32767           ELSE DO LARGE NUMBER OF BLOCKS\nFKDUMP01 DS    0H\n         LTR   X3,X3               ANYTHING TO DO .Q\n         BNP   FKDUMP05            BRANCH IF NOT\n         LA    R1,FKAREA           FLOATING KEEP DESCRIPTOR\n        $CALL  CPFKNXT             ANY DATA TO PRINT .Q\n         BC    BOMIT,FKDUMP05      BRANCH IF NOT\n        $CALL  PRINT               CAUSE A BREAK BEFORE 'DUMP'\n         SPACE\nFKDUMP02 DS    0H\n         S     X3,F1               DECREMENT BLOCK COUNT\n         BM    FKDUMP05            BRANCH IF DONE\n         LA    R1,FKAREA           POINT TO FK DESCRIPTOR\n        $CALL  CPFKNXT             GET NEXT BLOCK\n         BC    BOMIT,FKDUMP05      BRANCH IF EMPTY\n         USING FNQELEM,TEMP        LAST RECORD POINTER\n        $ON    FNQFLAG,FNQONE      PRINT ONLY ONE BLOCK\n         DROP  TEMP\n        $IFON  SWITCHS,FEMPTY,FKDUMP03  BRANCH IF PAGE EMPTY\n         LH    TEMP,PLCT           LINES LEFT ON THIS PAGE\n         S     TEMP,FKQCNTF        LESS LENGTH OF FIRST BLOCK\n         BM    FKDUMP04            BRANCH IF WON'T FIT\n         LH    R1,BMMRG            BOTTOM MARGIN\n         AH    R1,FNSEP            PLUS FOOTNOTE SEPARATOR\n         CR    TEMP,R1             BELOW BOTTOM MARGIN .Q\n         BL    FKDUMP04            WON'T FIT IF YES\n         LA    R1,FKAREA           .FK CONTROL DESCRIPTOR\n        $CALL  CPFKPRT             DUMP FIRST BLOCK NOW\n         B     FKDUMP02            AND TRY AGAIN\nFKDUMP03 DS    0H\n        $CALL  PAGETOP             PRINT HEADER AND SAVED BLOCK\n         B     FKDUMP02            AND TRY AGAIN\nFKDUMP04 DS    0H\n        $CALL  PAGE                TERMINATE THIS PAGE\n         B     FKDUMP03            AND PRINT ON THE NEXT\nFKDUMP05 DS    0H\n         B     FKDONE              ALL THROUGH\n         SPACE\nFKE003   DS    0H\n         MVI   EFLAG003,ERRSET     OMITTED CONTROL WORD\n         B     FKDONE              GO TO TERMINATE\nFKE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID CONTROL WORD\n         B     FKDONE              GO TO TERMINATE\nFKE012   DS    0H\n         MVI   EFLAG012,ERRSET     ILLEGAL CONTROL WORD\n         B     FKDONE              GO TO TERMINATE\nFKE014   DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     FKDONE              GO TO TERMINATE\nFKE024   DS    0H\n         MVI   EFLAG024,ERRSET     NO STORAGE FOR BLOCK\n         B     FKDONE              GO TO TERMINATE\n         SPACE\nFKDONE   DS    0H\n        $EXIT  RC=0                DONE WITH FLOATING KEEP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#FLUSHSP": {"ttr": 5380, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x003\\x003\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTION 'FLUSHSP' --- FLUSH BUFFERED SPACES  *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY   FLOFFSP  IS COUNT OF SPACES TO LEAVE\n*                   R0 = 0   DO ALL SPACES\n*                   R0 \u00ac 0   DO ONLY TRIPLE SPACES\n*                   FLOFFCH  CHANNEL SKIP VALUE\n         SPACE\nFLUSHSP $ENTER ,\n         LR    X1,R0               RETAIN PARM VALUE\n         L     TEMP,FLOFFCH        INITIAL CHANNEL SKIP\n         LTR   TEMP,TEMP           ANY PRESENT .Q\n         BZ    FLSP01              BRANCH IF NONE\n         STC   TEMP,FLBLNKCC       INSERT CARRIAGE CONTROL SKIP\n         OI    FLBLNKCC,C'0'       CHANGE TO CHARACTER\n         LA    R0,FLBLNK           POINT TO BLANK LINE\n        $CALL  PUTPRT              PRINT THE CHANNEL SKIP\n         XC    FLOFFCH,FLOFFCH     CLEAR CHANNEL SKIP\n         L     COUNT,FLOFFSP       CURRENT SPACES TO LEAVE\n         AH    COUNT,PLZ           PLUS LINE LENGTH\n         S     COUNT,DEFFFTO+TAB3DEF     LESS POSITION ON PAGE\n         ST    COUNT,FLOFFSP       UPDATE SPACES TO LEAVE\n         SPACE\nFLSP01   DS    0H\n         L     COUNT,FLOFFSP       GET SPACES TO LEAVE\n         LTR   COUNT,COUNT         ANY LINES TO DO .Q\n         BNP   FLSP05              BRANCH IF NONE AT ALL\n         SPACE\nFLSP02   DS    0H\n         LA    TEMP,3              MAXIMUM PRINTER SPACE\n         CR    COUNT,TEMP          LESS THAN THAT TO DO .Q\n         BNL   FLSP03              BRANCH IF NOT\n         LTR   X1,X1               DO ALL SPACES .Q\n         BNZ   FLSP04              BRANCH IF NOT\n         LR    TEMP,COUNT          SET FEWER SPACES\nFLSP03   DS    0H\n         SR    COUNT,TEMP          LESS NUMBER WE DO NOW\n         IC    TEMP,SPACTABL(TEMP) GET ASA CARRIAGE CONTROL\n         STC   TEMP,FLBLNKCC       INSERT CARRIAGE CONTROL\n         LA    R0,FLBLNK           POINT TO BLANK LINE\n        $CALL  PUTPRT              PRINT THE BLANK LINE\n         LTR   COUNT,COUNT         MORE LINES LEFT .Q\n         BP    FLSP02              BRANCH BACK IF YES\nFLSP04   DS    0H\n         ST    COUNT,FLOFFSP       UPDATE SPACES LEFT OUTSTANDING\n         SPACE\nFLSP05   DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#FM": {"ttr": 5382, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00'\\x00'\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .FM (FOOTING MARGIN) --- CONTROL                       *\n*                                                                     *\n***********************************************************************\n         SPACE\nFM      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n        $CALL  GETNUM              GET NUMBER\n         BC    BDNO,FM03           ERROR IF INVALID\n         BC    BOMIT,FM01          ENTER DEFAULT IF OMITTED\n         CLI   NUMSIGN,C' '        WAS ARGUMENT SIGNED .Q\n         BE    FM02                BRANCH IF NOT\n         AH    COUNT,FTMRG         ALTER EXISTING FOOTING\n         B     FM02                GO CHECK AND ENTER\nFM01     DS    0H\n         L     COUNT,DEFFTMG+TAB3DEF  DEFAULT FOOTING MARGIN VALUE\nFM02     DS    0H\n         LTR   COUNT,COUNT         IS FOOTING MARGIN NEGATIVE\n         BM    FM04                ERROR IF YES\n         LH    TEMP,BMMRG          BOTTOM MARGIN VALUE\n         SH    TEMP,FSCNT          LESS FOOTING SPACING\n         CR    COUNT,TEMP          COMPARE VALUES\n         BH    FM05                ERROR IF BIGGER\n         STH   COUNT,FTMRG         SET FOOTING MARGIN\n         B     FM06                AND GO TO RETURN\n         SPACE\nFM03     DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     FM06                AND GO TO RETURN\nFM04     DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     FM06                AND GO TO RETURN\nFM05     DS    0H\n         MVI   EFLAG042,ERRSET     OPERAND TOO BIG\n         B     FM06                AND GO TO RETURN\n         SPACE\nFM06     DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#FN": {"ttr": 5384, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x94\\x00\\x94\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 148, "newlines": 148, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .FN (FOOTNOTE) --- CONTROL                             *\n*                                                                     *\n***********************************************************************\n         SPACE\nFN      $ENTER ,\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BPOS,FNBEGIN        BRANCH IF START\n         BC    BNEG,FNEND          BRANCH IF END\n         BC    BOMIT,FNE003        ERROR IF ARG IS OMITTED\n         CLI   YNRESULT,YNSET      TEST DASH SET FUNCTION\n         BNE   FNE005              NO, UNDEFINED OPERAND\n         L     X1,ARGSTART         REMEMBER ARGUMENT START\n        $CALL  GETNUM              GET NEXT ARGUMENT\n         BC    BOMIT,FNE003        ERROR IF OMITTED\n         BC    15-BDNO,FNSET01     BRANCH IF NUMERIC FOUND\n         LA    COUNT,1             ONE FOR DEFAULT\nFNSET01  DS    0H\n         LTR   COUNT,COUNT         TOO SMALL .Q\n         BNP   FNE014              ERROR IF YES\n         L     R0,DEFHSFS+TAB3DEF  MAX ALLOWED\n         CR    COUNT,R0            TOO BIG .Q\n         BH    FNE013              ERROR IF YES\n         LR    X2,COUNT            REMEMBER FIRST NUMERIC ARG\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION PLEASE\n        $CALL  GETARG              ANYTHING LEFT .Q\n         BC    BOMIT,FNSET02       BRANCH IF NOT\n         ST    X1,ARGSTART         ELSE RESCAN FOR TITLE INTO\n        $ON    SWITCHS,FNOCASE     TITLE FORMAT PLEASE\n         L     X1,AFTHEAD          FOOTNOTE TITLE BUFFER ADDR\n        $CALL  HEADSAVE            ENTER DATA IN BUFFER\n        $OFF   SWITCHS,FNOCASE     RESET FORMAT FLAG\n         B     FNDONE              GO TO EXIT\n         SPACE\nFNSET02  DS    0H\n         STH   X2,FTCNT            SET FOOTNOTE TITLE COUNT\n         B     FNDONE              GO TO EXIT\n         SPACE\nFNBEGIN  DS    0H\n         CLI   ICORFLG,ICORNONE    ARE WE FORMATTING INTO CORE .Q\n         BNE   FNE012              ERROR IF YES\n         LH    R1,BMMRG            BOTTOM MARGIN\n         AH    R1,FNSEP            PLUS FOOTNOTE MARGIN\n         CH    R1,PLCT             PAGE ALREADY FULL .Q\n         BNH   FNBEG01             BRANCH IF NOT\n        $CALL  PAGE                FULL. CAUSE PAGE EJECT\nFNBEG01  DS    0H\n         LA    R1,ICORSLEN         NEED THIS MUCH SPACE\n        $CALL  GETCELL             GET SPACE\n         BC    BNEG,FNE024         BRANCH IF FAILURE\n         USING ICORSAVE,TEMP       SAVE AREA LOOKS LIKE THIS\n         ST    TEMP,FNQSAVE        SAVE AREA POINTER\n         MVC   ICOROLD1,FMTOLD1    SAVE CURRENT SWITCHES\n         MVC   ICOROLD2,FMTOLD2    SAVE PAGE DESCRIPTORS\n         MVC   ICORBX,BXPTR        SAVE BOX BUILD POINTER\n         XC    BXPTR,BXPTR         CLEAR CURRENT BOX IN PROGRESS\n         MVC   ICOROO,OOANCH       SAVE OUTPUT OVERLAY ANCHOR\n         XC    OOANCH,OOANCH       CLEAR CURRENT OUTPUT OVERLAYS\n         MVC   ICORSKSP,SKSP       SAVE CONDITIONAL SKIP/SPACE\n         XC    SKSP,SKSP           CLEAR CURRENT SKIP/SPACE\n         DROP  TEMP\n         SPACE\n         XC    OLDCOUNT,OLDCOUNT   WIPE OUT PREVIOUS LINE\n         MVI   ICORFLG,ICORFN      WE'RE SAVING FOOTNOTES\n         LA    TEMP,FNAREA         FOOTNOTE DESCRIPTOR AREA\n         ST    TEMP,ICORANCH       SAVE IT FOR LATER USE\n         LH    TEMP,INDL           RESET INDENT\n         AH    TEMP,OFFLI          ..\n         STH   TEMP,INDL           ..\n         STH   TEMP,RMARGIN        SET RIGHT MARGIN\n         SR    TEMP,TEMP           ZERO WORK REGISTER\n         STH   TEMP,INDENTR        ZERO RIGHT INDENT VALUE\n         STH   TEMP,PICNT          ZERO PARAGRAPH INDENT\n         STH   TEMP,HICNT          ZERO HANGING INDENT\n         STH   TEMP,UNDL           ZERO UNDENT VALUE\n         STH   TEMP,OFFLI          ZERO OFFSET VALUE\n         STH   TEMP,CECNT          ZERO CENTER VALUE\n         STH   TEMP,LICNT          ZERO LITERAL VALUE\n         STH   TEMP,DSCNT          ZERO LINE SPACING VALUE\n         MVC   HYSUPWRK,HYSUPCNT   REFRESH HYPHENATION SUPPRESSION\n         LH    TEMP,SFNCNT         GET CURRENT FOOTNOTE COUNT\n         LA    TEMP,1(,TEMP)       BUMP BY ONE\n         STH   TEMP,SFNCNT         UPDATE CURRENT FOOTNOTE COUNT\n         B     FNDONE              START SAVING THE FOOTNOTE\n         SPACE\nFNEND    DS    0H\n         CLI   ICORFLG,ICORFN      NOW SAVING A .FN SEQUENCE INCORE .Q\n         BNE   FNE012              ERROR IF NOT\n        $CALL  PRINT               CLEAR LAST FOOTNOTE LINE FROM BUFFER\n         SPACE\n         L     TEMP,FNQSAVE        RESTORE SAVED AREA POINTER\n         XC    FNQSAVE,FNQSAVE     CLEAR POINTER\n         USING ICORSAVE,TEMP       AREA LOOKS LIKE THIS\n        $CALL  BXCLR               DELETE ANY BOX IN PROGRESS\n         LA    R1,OOANCH           OUTPUT OVERLAY ANCHOR\n        $CALL  OVCLR               DELETE ANY IN PROGRESS\n        $MVC   FMTOLD1,ICOROLD1    RESTORE CURRENT SWITCHS\n        $MVC   FMTOLD2,ICOROLD2    RESTORE PAGE DESCRIPTORS\n        $MVC   BXPTR,ICORBX        RESTORE BOX IN PROGRESS\n        $MVC   OOANCH,ICOROO       RESTORE OUTPUT OVERLAY IN PROGRESS\n        $MVC   SKSP,ICORSKSP       RESTORE CONDITIONAL SKIP/SPACE\n         LA    R0,ICORSAVE         POINT TO AREA\n         LA    R1,ICORSLEN         LENGTH OF SAVE AREA\n        $CALL  FREECELL            RELEASE WORK AREA\n         DROP  TEMP\n         SPACE\n         MVI   ICORFLG,ICORNONE    NO LONGER SAVING FOOTNOTES\n         XC    ICORANCH,ICORANCH   CLEAR LINE CONTROL BLOCK ADDR\n         SPACE\n         LH    COUNT,PLCT          DETERMINE LENGTH OF REST OF PAGE\n         SH    COUNT,BMMRG         LESS BOTTOM MARGIN\n         CLC   OLDCOUNT,F0         HAS LAST TEXT LINE PRINTED .Q\n         BE    FNEND02             IF YES, LENGTH IS RIGHT\n         BCTR  COUNT,0             NO. ALLOW FOR WAITING TEXT LINE\nFNEND02  DS    0H\n         CH    COUNT,FTCNT         NEED AT LEAST FOOT TITLE +1\n         BNH   FNDONE              IF NOT AVAILABLE, QUIT\n         L     TEMP,FNQCNT         GET NUMBER OF QUEUED LINES\n         AH    TEMP,FTCNT          PLUS FOOTNOTE SEPARATOR DEPTH\n         CR    TEMP,COUNT          USE SMALLER OF THESE TWO\n         BL    FNEND03             ..\n         LR    TEMP,COUNT          ..\nFNEND03  DS    0H\n         STH   TEMP,FNSEP          SET FOOTNOTE MARGIN\n         B     FNDONE              AND GO TO RETURN\n         SPACE\nFNE003   DS    0H\n         MVI   EFLAG003,ERRSET     OMITTED OPERAND\n         B     FNDONE              GO TO COMMON EXIT\nFNE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID ARGUMENT\n         B     FNDONE              GO TO COMMON EXIT\nFNE012   DS    0H\n         MVI   EFLAG012,ERRSET     BAD PLACEMENT\n         B     FNDONE              GO TO COMMON EXIT\nFNE013   DS    0H\n         MVI   EFLAG013,ERRSET     TOO SMALL\n         B     FNDONE              GO TO COMMON EXIT\nFNE014   DS    0H\n         MVI   EFLAG014,ERRSET     TOO BIG\n         B     FNDONE              GO TO COMMON EXIT\nFNE024   DS    0H\n         MVI   EFLAG024,ERRSET     NO SPACE FOR SAVING CURRENT STATUS\n         B     FNDONE              GO TO COMMON EXIT\n         SPACE\nFNDONE   DS    0H\n        $EXIT  RC=0                DONE WITH FOOTNOTE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#FNPRT": {"ttr": 5388, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00w\\x00w\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 119, "newlines": 119, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        INTERNAL ROUTINE 'FNPRT' --- PRINT QUEUED FOOTNOTES.         *\n*                                                                     *\n***********************************************************************\n         SPACE\nFNPRT   $ENTER ,\n         LH    COUNT,PLCT          LINES LEFT ON THIS PAGE\n         SH    COUNT,BMMRG         LESS BOTTOM MARGIN\n         OC    FNSEP,FNSEP         ANY FOOTNOTES HERE .Q\n         BZ    FNP08               BRANCH IF NOT\n         CH    COUNT,FTCNT         FOOTNOTE TITLE DEPTH\n         BNH   FNP08               BRANCH IF NOT FOOTNOTE TITLE +1\n         SPACE\n         L     X1,AFTHEAD          ADDR OF FOOTNOTE TITLES\n         LH    COUNT,FTCNT         FOOTNOTE TITLE DEPTH\nFNP01    DS    0H\n         S     COUNT,F1            LESS ONE\n         BM    FNP03               BRANCH OUT IF DONE\n         L     X3,LLZ              RETAIN LINE LENGTH\n         CLI   ICOLFLG,ICOLMC      IN MULTI-COLUMN MODE .Q\n         BNE   FNP02               BRANCH IF NOT\n         MVC   LLZ,CLLZ            SET COLUMN LENGTH FOR SEPARATOR\nFNP02    DS    0H\n        $CALL  HEADPRT             PRINT ONE FOOTNOTE TITLE LINE\n         ST    X3,LLZ              RESTORE LINE LENGTH\n         LA    X1,L'FTHEAD(,X1)    NEXT FOOTNOTE TITLE BUFFER\n         B     FNP01               LOOP TILL COMPLETE\n         SPACE\nFNP03    DS    0H\n         L     X2,FNQANCH          ADDRESS OF NEXT QUEUED LINE\n         LTR   X2,X2               ANY SAVED LINE THERE .Q\n         BNZ   FNP04               BRANCH IF YES\n         OC    FNQCNT,FNQCNT       ANY LINES SUPPOSED TO BE QUEUED .Q\n         BZ    FNRET               NO, TIME TO RETURN\n         B     ABFNP03             ELSE QUIT NOW\n         SPACE\nFNP04    DS    0H\n         USING FNQELEM,X2          AND TELL THE ASSEMBLER\n        $IFOFF FNQFLAG,FNQTC,FNP05 BRANCH IF NOT TC ENTRY\n         LA    R1,FNQTEXT          POINT TO DATA\n         LNR   R1,R1               'FIFO' ENTRY\n         LH    TEMP,FNQRDW         LENGTH INCLUDING RDW\n         S     TEMP,F5             LENGTH-1 OF DATA\n         BM    ABFNP04             TROUBLE IF NEGATIVE\n         L     X3,DHNUMTC          CURRENT TABLE OF CONTENTS NUMBER\n         LH    COUNT,FNQNUMTC      TC NUMBER WHEN LINE DEFINED\n         ST    COUNT,DHNUMTC       SET FORMER FOR SAVE\n        $CALL  HIDTCAD             ENTER IN CONTENTS CHAIN\n         ST    X3,DHNUMTC          RESTORE TABLE OF CONTENTS NUMBER\n         B     FNP07               FREE THIS ENTRY\n         SPACE\nFNP05    DS    0H\n        $ON    SWITCHS,FOVLY       ASSUME AN OVERLAID LINE\n        $IFON  FNQFLAG,FNQOVLY,FNP06    BRANCH IF OVERLAY LINE\n         SPACE\n        $OFF   SWITCHS,FOVLY       NOT AN OVERLAID LINE\n         LH    COUNT,PLCT          ACCOUNT FOR LINE WE'RE ABOUT\n         BCTR  COUNT,0             TO PRINT\n         CH    COUNT,BMMRG         DOES IT PUT US BELOW MARGIN .Q\n         BL    FNRET               IF YES, DONE FOR THIS PAGE\n         STH   COUNT,PLCT          NO, SAVE UPDATED COUNT\n         SPACE\nFNP06    DS    0H\n         MVC   FNQANCH,FNQFCHN     POINT TO NEXT ONE\n         LH    R1,FNQRDW           LOAD LENGTH RDW/TEXT\n         S     R1,F4               LESS LENGTH OF RDW\n         BM    ABFNP01             BAD TROUBLE IF NEGATIVE\n         SPACE\n         LA    R0,FNQRDW           POINT TO OUTPUT RECORD\n        $ON    SWITCHS,OOSWS       DISABLE OUTPUT OVERLAY\n        $CALL  IOPRINT             CAUSE LINE TO BE OUTPUT\n        $OFF   SWITCHS,OOSWS       REENABLE OUTPUT OVERLAY\n         SPACE\n        $OFF   SWITCHS,FOVLY       RESET OVERLAY SWITCH\n        $IFON  FNQFLAG,FNQOVLY,FNP07    BRANCH IF OVERLAY LINE\n         L     COUNT,FNQCNT        CURRENT NUMBER OF FOOTNOTE LINES\n         S     COUNT,F1            DECREMENT BY ONE\n         BM    ABFNP02             GONE WRONG IF NEGATIVE\n         ST    COUNT,FNQCNT        UPDATE QUEUED FOOTNOTE LINES\nFNP07    DS    0H\n         LH    R1,FNQRDW           LENGTH OF DATA AND RDW\n         LA    R1,FNQOVHD(,R1)     PLUS PREFIX OVERHEAD\n         LA    R0,FNQELEM          POINTER TO AREA\n        $CALL  FREECELL            FREE THIS ENTRY\n         B     FNP03               CONTINUE PRINTING\n         SPACE\nFNP08    DS    0H\n        $CALL  SPACER              SPACE DOWN TO BOTTOM MARGIN\n         SPACE\nFNRET    DS    0H\n         L     COUNT,FNQCNT        GET REMAINING NUMBER OF FOOTNOTES\n         LTR   COUNT,COUNT         IS IT ZERO YET .Q\n         BNP   FNRET2              IF YES, NO MORE QUEUED\n         AH    COUNT,FTCNT         ACCOUNT FOR NEXT PAGE'S BREAK LINES\nFNRET2   DS    0H\n         AH    COUNT,BMMRG         STORE CORRECT BOTTOM MARGIN FOR\n         LH    R1,PLZ              CURRENT PAGE LENGTH\n         SH    R1,TOPMRG           LESS TOP MARGIN\n         AH    R1,BMMRG            PLUS BOTTOM MARGIN\n         AH    R1,FTCNT            PLUS NEXT PAGE BREAK LINES\n         LA    R1,3(,R1)           ROUNDING PLUS ONE LINE\n         SRA   R1,1                DIVIDED BY TWO\n         CR    COUNT,R1            TOO MUCH STACKED .Q\n         BNH   FNRET3              BRANCH IF NOT\n         LR    COUNT,R1            TAKE WHAT WE CAN HANDLE NEXT PAGE\nFNRET3   DS    0H\n         SH    COUNT,BMMRG         LESS BOTTOM MARGIN\n         STH   COUNT,FNSEP         NEXT PAGE\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              RETURN TO CALLER\n         SPACE\n         DROP  X2\n         SPACE\nABFNP01  DS    0H                  NULL FOOTNOTE SAVED FOR PRINT\nABFNP02  DS    0H                  NEGATIVE NUMBER OF FOOTNOTES\nABFNP03  DS    0H                  MISSING FOOTNOTE LINES\nABFNP04  DS    0H\n        $LOGERR 1003\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#FNSAVE": {"ttr": 5391, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x8b\\x00\\x8b\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 139, "newlines": 139, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        INTERNAL ROUTINE 'FNSAVE' --- QUEUE FORMATTED FOOTNOTE LINE  *\n*        FOR PRINTING AT END OF PAGE                                  *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY - R0       -> RDW OF BUFFER TO BE OUTPUT\n*                 - RETURN   -> RETURN ADDRESS\n         SPACE\nFNSAVE  $ENTER ,\n         L     X1,ICORANCH         ADDRESS OF LINE CONTROL\n         LTR   X1,X1               IS IT VALID .Q\n         BNP   ABFNS03             ERROR IF NOT\n        $IFON  SWITCHS,OOSWS,FNS02 BRANCH IF DISABLED\n         L     R1,OOANCH           OUTPUT OVERLAY ANCHOR\n         LTR   R1,R1               ANYTHING PRESENT .Q\n         BZ    FNS01               BRANCH IF NOTHING\n        $CALL  OOPRT               PROCESS OUTPUT OVERLAY\nFNS01    DS    0H\n         L     R1,BXPTR            BOX BUILDING POINTER\n         LTR   R1,R1               ANYTHING TO PRINT\n         BZ    FNS02               BRANCH IF NOT\n        $CALL  BXVERT              INCORPORATE VERTICAL SIDES OF BOX\n         SPACE\nFNS02    DS    0H\n         USING CPFKFN,X1           ELSE TELL THE ASSEMBLER\n         L     R1,CPFKFNC          CURRENT BUFFERED LINE COUNT\n         C     R1,DEFFNSIZ+TAB3DEF COMPARE WITH MAX ALLOWED\n         BNL   FNS05               FORGET IT IF TOO MANY\n         LR    X2,R0               ADDR OF RECORD TO SAVE\n         SR    R1,R1               ZERO WORK REGISTER\n         IC    R1,1(,X2)           LENGTH OF RECORD WITH RDW\n         L     TEMP,DEFLNUM+TAB3DEF  GET LINENUMBER COLUMN\n         LTR   TEMP,TEMP           IS IT PRESENT .Q\n         BZ    FNS04               BRANCH IF NOT\n         LA    TEMP,4+4(,TEMP)     PLUS LENGTH OF RDW AND EDIT PATTERN\n        $IFON  TTYPE,TONLINE,FNS03 BRANCH IF ONLINE\n         LA    TEMP,1(,TEMP)       PLUS LENGTH OF CARRIAGE CONT\nFNS03    DS    0H\n         CR    TEMP,R1             ALREADY LONG ENOUGH .Q\n         BNH   FNS04               BRANCH IF YES\n         LR    R1,TEMP             NEW LENGTH\n         STC   R1,1(,X2)           CHANGE THE RDW\nFNS04    DS    0H\n         LA    R1,FNQOVHD(,R1)     PLUS PREFIX OVERHEAD\n        $CALL  GETCELL             GET A QUEUE BUFFER\n         BC    BPOS,FNS06          BRANCH IF SUCCESS\n         MVI   EFLAG024,ERRSET     NO STORAGE FOR NEW LINE\n        $CALL  ERROUT              PRINT MESSAGE BEFORE CONTINUING\nFNS05    DS    0H\n         SR    R1,R1               CLEAR INDEX REGISTER\n         IC    R1,ICORFLG          GET TYPE OF OPERATION\n         LA    R1,FNSERTXT(R1)     POINT TO COMMAND\n         ST    R1,ERRTEXT          SET EXTRA TEXT ADDRESS\n         MVI   ERRTEXT,L'FNSERTXT  SET EXTRA TEXT LENGTH\n         MVI   EFLAG034,ERRSET     SET ERROR MESSAGE\n         B     FNS13               AND GO TO RETURN\n         SPACE\nFNSERTXT DC    C'.XX.'             DON'T KNOW\n         DC    C'.CC.'             CONDITIONAL COLUMN\n         DC    C'.CP.'             CONDITIONAL PAGE\n         DC    C'.FB.'             FLOATING BLOCK\n         DC    C'.FK.'             FLOATING KEEP\n         DC    C'.FN.'             FOOTNOTE\n         DC    C'.HN.'             HEADNOTE\n         DC    C'.HN.'             HEADNOTE EVEN\n         DC    C'.HN.'             HEADNOTE ODD\n         DC    C'.XX.'             DON'T KNOW\n         SPACE\nFNS06    DS    0H\n         LA    X2,CPFKFNA-FNQFCHN+FNQELEM    PRIME USED LOOP\n         USING FNQELEM,X2          FOR LAST ELEMENT SEARCH\n         SPACE\nFNS07    DS    0H\n         L     R1,FNQFCHN          CHAIN TO NEXT USED CELL\n         LA    R1,0(,R1)           CLEAR HIGH BYTE\n         LTR   R1,R1               AT THE END .Q\n         BZ    FNS08               IF YES, WE'RE DONE LOOKING\n         LR    X2,R1               NO, CHAIN TO NEXT\n         B     FNS07               AND TRY AGAIN\n         SPACE\nFNS08    DS    0H\n         ST    TEMP,FNQFCHN        LINK NEW ONE IN AT END\n         DROP  X2\n         USING FNQELEM,TEMP        PASSED BACK FROM GETCELL\n         XC    FNQELEM(FNQLN),FNQELEM   CLEAR PREFIX INFORMATION\n         LR    X2,R0               ADDR OF RECORD TO BE SAVED\n         SR    R1,R1               ZERO WORK REG\n         IC    R1,1(,X2)           GET LENGTH OF RECORD\n         STH   R1,FNQRDW           SAVE LENGTH OF RECORD\n         S     R1,F5               LESS RDW AND SS TYPE LENGTH\n         BM    ABFNS04             TROUBLE IF NEGATIVE\n         EX    R1,FNSMVC           COPY TO QUEUE BUFFER\n         SPACE\n        $IFOFF SWITCHS,TRSWS,FNS10 BRANCH IF NO TRANSLATE\n        $IFON  SWITCHS,TRSUP,FNS10 BRANCH IF SUPPRESSED TRANSLATE\n         LA    X2,FNQTEXT          OUTPUT LINE TO TRANSLATE\n        $IFON  TTYPE,TONLINE,FNS09 BRANCH IF ONLINE\n         LA    X2,FNQTEXT+1        POINT OVER CARRIAGE CONTROL\n         S     R1,F1               LESS CARRIAGE CONTROL LENGTH\n         BM    ABFNS04             ERROR IF NO DATA TO SAVE\nFNS09    DS    0H\n         L     COUNT,TRANADO       POINT TO OUTPUT TRANSLATE TABLE\n         EX    R1,FNSTR            TRANSLATE FOOTNOTE LINE\n         SPACE\nFNS10    DS    0H\n        $OFF   SWITCHS,TRSUP       RESET TRANSLATE SUPPRESS\n         MVC   FNQCORSW,ICORFLG    RETAIN TYPE OF RECORD\n        $MVC   FNQSKSP,SKSPFLG     RETAIN TYPE IF SKIP/SPACE\n         L     R1,MCFNQAD          GET ORIGINAL INCORE POINTER\n         LTR   R1,R1               DOES IT EXIST .Q\n         BZ    FNS11               BRANCH IF NOT\n         MVC   FNQELEM+4(FNQOVHD-4),4(R1)    RETAIN ORIGINAL DESCRIPT\n         XC    MCFNQAD,MCFNQAD     CLEAR POINTER\n         SPACE\nFNS11    DS    0H\n        $IFON  SWITCHS,FOVLY,FNS12 DON'T UPDATE COUNT IF OVERLAY\n         L     R1,CPFKFNC          CURRENT BUFFERED LINE COUNT\n         LA    R1,1(,R1)           BUMP BY ONE\n         ST    R1,CPFKFNC          UPDATE BUFFERED LINE COUNT\n         B     FNS13               AND GO TO RETURN\nFNS12    DS    0H\n        $ON    FNQFLAG,FNQOVLY     SET THIS AS AN OVERLAY LINE\n         SPACE\nFNS13    DS    0H\n         MVC   BLNKDATA,BLANKS     BLANK DUMMY BLANK LINE FOR SPACING\n         LA    R0,BLNKRDWL         THIS IS ITS LENGTH\n         STH   R0,BLNKLINE         SET LENGTH OF BLANK LINE\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              BACK TO CALLER\n         SPACE\nFNSMVC   MVC   FNQTEXT(*-*),4(X2)  COPIES FORMATTED FOOTNOTE LINE\nFNSTR    TR    0(*-*,X2),0(COUNT)  TRANSLATES FORMATTED FOOTNOTE LINE\n         DROP  TEMP,X1\n         SPACE\nABFNS03  DS    0H                  WHY ARE WE HERE .Q\nABFNS04  DS    0H                  SAVING NULL FOOTNOTE RECORD\n        $LOGERR 1002\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#FO": {"ttr": 5635, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00;\\x00;\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 59, "newlines": 59, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .FO (FORMAT) --- CONTROL                               *\n*              .FI (FILL) --- CONTROL                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nFO      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BPOS+BOMIT,FO01     BRANCH IF OMITTED OR POSITIVE\n         BC    BNEG,FO02           BRANCH IF NEGATIVE\n         CLI   YNRESULT,YNHALF     'HALF JUSTIFY' FORMAT .Q\n         BE    FO00                BRANCH IF YES\n         CLI   YNRESULT,YNLEFT     'LEFT' FORMAT .Q\n         BE    FO03                BRANCH IF YES\n         CLI   YNRESULT,YNRGHT     'RIGHT' FORMAT .Q\n         BE    FO04                BRANCH IF YES\n         CLI   YNRESULT,YNCNTR     'CENTRE' FORMAT .Q\n         BE    FO05                BRANCH IF YES\n         CLI   YNRESULT,YNISDE     'INSIDE' FORMAT .Q\n         BE    FO06                BRANCH IF YES\n         CLI   YNRESULT,YNOSDE     'OUTSIDE' FORMAT .Q\n         BE    FO07                BRANCH IF YES\n         MVI   EFLAG005,ERRSET     ELSE INVALID ARGUMENT\n         B     FO10                GO TO FINAL EXIT\n         SPACE\nFO00     DS    0H\n         MVI   JUVAL,JUVHALF       HALF JUSTIFY LEFT AND RIGHT\n         B     FO08                GO TO COMMON EXIT\nFO01     DS    0H\n         MVI   JUVAL,JUVPOS        JUSTIFY LEFT AND RIGHT\n         B     FO08                GO TO COMMON EXIT\nFO02     DS    0H\n         MVI   JUVAL,JUVNEG        NO JUSTIFICATION\n        $ON    SWITCHS,NFSWS       AND NO CONCATENATION\n         B     FO09                GO TO EXIT\nFO03     DS    0H\n         MVI   JUVAL,JUVLEFT       LEFT JUSTIFY\n         B     FO08                GO TO COMMON EXIT\nFO04     DS    0H\n         MVI   JUVAL,JUVRGHT       RIGHT JUSTIFY\n         B     FO08                GO TO COMMON EXIT\nFO05     DS    0H\n         MVI   JUVAL,JUVCNTR       CENTRE JUSTIFY\n         B     FO08                GO TO COMMON EXIT\nFO06     DS    0H\n         MVI   JUVAL,JUVISDE       INSIDE JUSTIFY\n         B     FO08                GO TO COMMON EXIT\nFO07     DS    0H\n         MVI   JUVAL,JUVOSDE       OUTSIDE JUSTIFY\n         B     FO08                GO TO COMMON EXIT\n         SPACE\nFO08     DS    0H\n        $OFF   SWITCHS,NFSWS       TURN OFF 'NO CONCATENATE'\nFO09     DS    0H\n         MVC   CECNT,F0            CLEAR CE/LA/RA COUNT\nFO10     DS    0H\n        $EXIT  RC=0                AND CONTINUE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#FOADD": {"ttr": 5637, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x12\\x00\\x12\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*                             FOADD                                   *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  LA    R0,(H'LEN',C'DATA')\n*                     $CALL  FOADD\n         SPACE\nFOADD   $ENTER ,\n         LR    R1,R0               POINTER TO STRING TO ADD\n         LH    R0,0(,R1)           LENGTH OF STRING TO ADD\n         ST    R0,WRKPLIST+4       SET THE LENGTH\n         LA    R0,2(,R1)           POINT TO CHARACTERS TO ADD\n         ST    R0,WRKPLIST         SET THE ADDRESS\n         LA    R1,WRKPLIST         POINT TO PARAMETER LIST\n        $CALL  LKPUT               ROUTINE TO INSERT STRING\n        $EXIT  RC=0                AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#FOASM3": {"ttr": 5639, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x10\\x00\\x10\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              FOASM3  ---  AHEARN AND SOPER MULTIWRITER III          *\n*                                                                     *\n***********************************************************************\n         SPACE\nFOASM3  $ENTER ,\n         SPACE\n        $FOTERM HORIZ=120,VERT=48,                                     *\n               SUP=(0,C'D'),SUB=(0,C'U'),NLF=(0,X'25'),                *\n               VMI=(8,X'35'),HMI=(8,X'1F'),TAB=(8,X'05'),              *\n               (X'35',2),(X'1F',2),(X'05',2)\n         SPACE\n*********\n*        WARNING  --  THIS TABLE IS PROBABLY NOT COMPLETE\n*********\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#FOHYPH": {"ttr": 5641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00~\\x00~\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 126, "newlines": 126, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              FOHYPH  ---  AUTO HYPHENATE A WORD                     *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON EXIT  --  (R15) SET TO 'HYUSER' AND BREAK POINT SET\n*                     OR\n*                     (R15) SET TO 'HYNONE'\n         SPACE\nFOHYPH  $ENTER ,\n         USING LINKELEM,P          CALLER PROVIDED\n        $IFON  SWITCHS,HYSUPSW,FOHY14   BRANCH IF HYPHENATION SUPPRESS\n         LH    R0,HYSUPWRK         NUMBERED HYPHENATION SUPPRESS\n         S     R0,F1               LESS ONE\n         STH   R0,HYSUPWRK         UPDATE WITH REMAINDER\n         BM    FOHY14              BRANCH IF MUST SUPPRESS\n         CLI   ICORFLG,ICORNONE    FORMATTING INTO CORE .Q\n         BNE   FOHY01              BRANCH IF YES\n         LH    R0,PLCT             LINES LEFT ON PAGE\n         S     R0,F1               LESS ONE\n         LH    R1,BMMRG            BOTTOM MARGIN\n         AH    R1,FNSEP            PLUS FOOTNOTE MARGIN\n         CR    R0,R1               COMPARE WITH BOTTOM MARGIN\n         BNH   FOHY14              SUPPRESS LAST LINE OF PAGE\n         SPACE\nFOHY01   DS    0H\n         SR    B,B                 ZERO FILL COUNT\nFOHY02   DS    0H\n         CLI   LINKCHAR,C' '       CHARACTER A BLANK .Q\n         BE    FOHY03              YES, GO GET WORD END\n         IC    M,LINKMULT          LENGTH OF CHAR\n         AR    B,M                 BUMP BACK AMOUNT\n         L     P,LINKBACK          BACKUP TO PREV CHARACTER\n         B     FOHY02              CONTINUE START SEARCH\nFOHY03   DS    0H\n         L     P,LINKFOR           FIRST CHAR OF WORD\n         CLI   LINKCHAR,C'('       WORD START WITH LEFT PAREN .Q\n         BE    FOHY04              BRANCH IF YES\n         CLI   LINKCHAR,C'\"'       WORD START WITH DOUBLE QUOTE .Q\n         BNE   FOHY05              BRANCH IF NOT\nFOHY04   DS    0H\n         L     P,LINKFOR           SKIP SPECIAL FIRST CHAR\n         BCTR  B,0                 DECREMENT SPACE AVAILABLE ON LINE\nFOHY05   DS    0H\n         CH    B,HYTHRESH          ENOUGH SPACES FOR THRESHOLD .Q\n         BL    FOHY14              BRANCH IF NOT\n         LA    POLD,0(,P)          REMEMBER WORD START\n         MVC   HYTESTAR,BLANKS     BLANK WORD AREA\n         LA    PNEW,HYTESTAR+1     START HERE\n         LA    R0,HYTESTAR+L'HYTESTAR   LAST POSSIBLE ENTRY\n         SR    C,C                 ZERO LENGTH OF WORD\nFOHY06   DS    0H\n         LTR   P,P                 AT THE END .Q\n         BZ    FOHY08              BRANCH OUT IF YES\n         CLI   LINKCHAR,C'-'       USER HYPHEN .Q\n         BE    FOHY07              YES, LET THAT THROUGH\n         CLI   LINKCHAR,C'A'-C' '  LESS THAN LOWER 'A' .Q\n         BL    FOHY08              IF YES, END OF WORD\n         CLI   LINKCHAR,C'Z'       MORE THAN UPPER 'Z' .Q\n         BH    FOHY08              IF YES, END OF WORD\nFOHY07   DS    0H\n         CLI   LINKMULT,X'01'      ONLY ONE CHAR .Q\n         BNE   FOHY14              NO, CANNOT HYPHENATE WORD\n         LA    C,1(,C)             BUMP LENGTH OF WORD\n         MVC   0(1,PNEW),LINKCHAR  ENTER WORD\n         LA    PNEW,1(,PNEW)       NEXT CHAR\n         CR    PNEW,R0             STILL OK .Q\n         BNL   FOHY14              NO, CANNOT HYPHENATE WORD\n         L     P,LINKFOR           NEXT CHARACTER PTR\n         B     FOHY06              CONTINUE END SEARCH\nFOHY08   DS    0H\n         LR    R0,C                LENGTH OF WORD\n         SH    R0,HYENDPT          LESS HYPHEN END POINT\n         S     B,F2                LESS BLANK BEFORE AND HYPHEN AFTER\n         CR    B,R0                COMPARE THE TWO\n         BNH   FOHY09              BRANCH IF SPACE LIMITS\n         LR    B,R0                ENDPT LIMITS\nFOHY09   DS    0H\n         LTR   B,B                 TEST THE RESULT\n         BNP   FOHY14              BRANCH IF NOTHING CAN BE DONE\n         STC   B,HYTESTAR          LAST TO FIT POINT\n         C     C,F5                WORD LENGTH FIVE OR MORE .Q\n         BL    FOHY14              IF NOT, DON'T EVEN TRY\n         LH    R1,HYMINPT          START MINIMUM\n         AH    R1,HYENDPT          PLUS END MINIMUM\n         CR    C,R1                WORD LONGER THAN MINIMUMS .Q\n         BL    FOHY14              BRANCH OUT IF NOT\n         LA    R1,HYTESTAR         POINT TO INPUT WORK AREA\n        $CALL  HYPHEN              DO HYPHENATION\n         LTR   R15,R15             SUCCESSFUL REQUEST .Q\n         BNP   FOHY14              BRANCH IF ERROR\n         LA    P,0(,POLD)          FIRST LETTER OF WORD PTR\n         LH    R0,HYMINPT          MINIMUM CHARS ON THIS LINE\n         B     FOHY11              SKIP OVER MINPT CHARACTERS\nFOHY10   DS    0H\n         L     P,LINKFOR           FIRST CHAR MAY NOT BE ORPHANED\n         LA    R15,1(,R15)         SECOND STATUS INDICATOR BYTE\n         S     B,F1                LESS FIRST CHAR LENGTH\n         BNP   FOHY14              BRANCH IF NONE LEFT\nFOHY11   DS    0H\n         S     R0,F1               ONE LESS CHAR LEFT\n         BP    FOHY10              CONTINUE IF WE MUST\n         SH    C,HYENDPT           LESS END MINIMUM\n         BNP   FOHY14              BRANCH IF NOTHING LEFT\n         CR    B,C                 DON'T ORPHAN LAST 'ENDPT' CHARS\n         BNH   FOHY12              BRANCH IF OK\n         LR    B,C                 ELSE TAKE THE MIN\nFOHY12   DS    0H\n         TM    0(R15),X'30'        DOES HYPHEN FOLLOW LETTER .Q\n         BO    FOHY13              BRANCH IF YES\n         LA    R15,1(,R15)         NEXT STATUS RETURN BYTE\n         L     P,LINKFOR           NEXT CHARACTER\n         BCT   B,FOHY12            AND TRY AGAIN\n         B     FOHY14              FAILURE\nFOHY13   DS    0H\n         ST    P,WRKBRK            SET BREAK POINTER FOR WORD\n         LA    R15,HYUSER          LET USER HYPHENATION TAKE OVER\n         B     FOHY15              GO TO RETURN\nFOHY14   DS    0H\n         MVC   HYSUPWRK,HYSUPCNT   RESET NUMBERED HYPHENATION SUPPRESS\n         LA    R15,HYNONE          LET NO HYPHENATION TAKE OVER\nFOHY15   DS    0H\n        $EXIT  RC=(R15)            AND RETURN TO CALLER\n         SPACE\n         DROP  P\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#FOMYTE": {"ttr": 5644, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x000\\x000\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              FOMYTE  ---  INSTALLATION DEPENDENT TERMINAL           *\n*                                                                     *\n***********************************************************************\n         SPACE\nFOMYTE  $ENTER ,\n         SPACE\n        $FOTERM ,\n***********************************************************************\n*                                                                     *\n*        THERE IS NO LACK OF VARIETY IN THE FLAVOURS OF DIABLO        *\n*        TYPE TERMINALS ON THE MARKET TODAY.  BUT WHAT THERE IS,      *\n*        IS A LACK OF STANDARDS.  THE ESCAPE FUNCTIONS VARY AND       *\n*        THE LENGTH OF ESCAPE FUNCTIONS VARY FROM TERMINAL TO         *\n*        TERMINAL.  THIS TABLE MAY BE DEFINED BY AN INSTALLATION      *\n*        TO ACCOMODATE THEIR TERMINAL TYPE.  THE USE OF THIS TABLE    *\n*        IS INVOKED BY THE 'MYTERM' OPTION DEFINED IN ROUTINE         *\n*        'SCRIPTPM'.                                                  *\n*                                                                     *\n*        THE '$FOTERM' MACRO IS SUPPOSED TO MAKE IT EASY TO DEFINE    *\n*        THE CHARACTERISTICS OF YOUR TERMINAL, BUT JUST IN CASE --    *\n*                                                                     *\n*        HORIZ= SPECIFIES THE NUMBER OF HORIZONTAL UNITS IN           *\n*                  ONE INCH.                                          *\n*        VERT=  SPECIFIES THE NUMBER OF VERTICAL UNITS IN             *\n*                  ONE INCH.                                          *\n*        SUP=   TAKES A 'TYPE' AND STRING FOR SUPERSCRIPTS            *\n*               'TYPE' MAY BE  0  FOR NOTHING AFTER THE STRING        *\n*                              4  FOR A ONE BYTE ASCII COUNT AFTER    *\n*                                 THE STRING                          *\n*                              8  FOR A ONE BYTE ASCII COUNT+1        *\n*                                  AFTER THE STRING                   *\n*        SUB=   TAKES A 'TYPE' AND STRING FOR SUBSCRIPTS              *\n*        NLF=   TAKES A 'TYPE' AND STRING FOR NEGATIVE LINE FEED      *\n*        VMI=   TAKES A 'TYPE' AND STRING FOR VERTICAL MOTION         *\n*               INDEX                                                 *\n*        HMI=   TAKES A 'TYPE' AND STRING FOR HORIZONTAL MOTION       *\n*               INDEX                                                 *\n*        TAB=   TAKES A 'TYPE' AND STRING FOR ABSOLUTE HORIZONTAL     *\n*              TABBING                                                *\n*        ALL FUNCTIONS FOLLOWING 'ESCAPE' (X'27') DEFAULT TO ONE      *\n*        CHARACTER IN LENGTH.  THOSE WITH LENGTH GREATER THAN ONE     *\n*        MUST BE SPECIFIED IN PAIRS AS POSITIONAL PARAMETERS          *\n*        THE FIRST OF THE PAIR BEING THE CHARACTER AND THE SECOND     *\n*        BEING THE LENGTH.                                            *\n*                                                                     *\n***********************************************************************\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#FOQUME": {"ttr": 5646, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\t\\x00\\t\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              FOQUME  ---  QUME TERMINAL CONTROL FOR ESCAPE CHARS    *\n*                                                                     *\n***********************************************************************\n         SPACE\nFOQUME  $ENTER ,\n         SPACE\n        $FOTERM ,                  *** N/A DEC/77 ***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#FO1620": {"ttr": 5648, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x11\\x00\\x11\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              FO1620  ---  XEROX 1620 CONTROL FOR ESCAPE CHARS       *\n*                                                                     *\n***********************************************************************\n         SPACE\n         PUSH  PRINT\n         PRINT GEN\n         SPACE\nFO1620  $ENTER ,\n         SPACE\n        $FOTERM HORIZ=120,VERT=48,                                     *\n               SUP=(0,C'D'),SUB=(0,C'U'),NLF=(0,X'25'),                *\n               VMI=(8,X'35'),HMI=(8,X'1F'),TAB=(8,X'05'),              *\n               (X'35',2),(X'1F',2),(X'05',2)\n         SPACE\n         POP   PRINT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#FO2741": {"ttr": 5650, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\t\\x00\\t\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              FO2741  ---  TERMINAL CONTROL FOR ESCAPE CHARS         *\n*                                                                     *\n***********************************************************************\n         SPACE\nFO2741  $ENTER ,\n         SPACE\n        $FOTERM ,                  2741 DOES NOTHING\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#FREECEL": {"ttr": 5652, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x006\\x006\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL ROUTINE 'FREECELL' -- FREE A QUEUE BUFFER     *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY -  R0     ADDRESS TO BE FREED\n*                 -  R1     LENGTH TO BE FREED\n*                 -  RETURN RETURN ADDRESS\n*                 -  IF R0 = R1 = 0  TERMINATION CALL\n*        ON EXIT  -  RETURN IF SUCCESS\n*                 -  ABEND  IF FAILURE\n         SPACE\nFREECELL $ENTER ,\n         L     X1,RGLISTAD         PARM AREA ADDRESS\n         USING RGLIST,X1           AND TELL THE ASSEMBLER\n         LTR   R0,R0               IS ADDR ZERO .Q\n         BNZ   FREC01              NO, NOT TERMINATION\n         LTR   R1,R1               IS LENGTH ZERO .Q\n         BNZ   FREC01              NO, AGAIN NOT TERMINATION\n         CLI   PRGFLAG,PRGINIT     ANY MANAGED REGIONS .Q\n         BE    FREC02              BRANCH IF NONE\n         MVI   PRGFLAG,PRGFINIS    SET TERMINATION FLAG\n         LA    R1,RGLIST           POINT TO PARM LIST\n        $CALL  RGNMGR              GO TERMINATE REGION MANAGER\n         BC    15-BPOS,ABFCELL     TERMINATE IF ERROR\n         B     FREC02              RETURN TO CALLER\n         SPACE\nFREC01   DS    0H\n         ST    R0,PCELLPTR         POINT TO ENTRY\n         ST    R1,PCELLLEN         AND SET ITS LENGTH\n         S     R1,F2               LENGTH-1 OF REMAINDER TO FREE\n         BNP   ABFCELL             ERROR IF TOO SMALL\n         LR    COUNT,R0            POINT TO AREA TO FREE\n         MVI   0(COUNT),X'7F'      DIRTY REGION TO FREE\n         EX    R1,FRECMVC          ALL OF IT\n         LA    R1,RGLIST           POINT TO PARM LIST\n        $CALL  RGNMGR              RELEASE THE CELL\n         BC    15-BPOS,ABFCELL     TERMINATE IF ERROR\n         SPACE\n         L     R1,PRGUSED          FORMER SPACE FROM REGION MANAGER\n         S     R1,PCELLLEN         LESS AREA JUST FREED\n         BM    ABFCELL             ERROR IF NEGATIVE\n         ST    R1,PRGUSED          SET CURRENT SPACE USED\n         DROP  X1\n         SPACE\nFREC02   DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGS\n         BR    RETURN              AND RETURN TO CALLER\n         SPACE\nFRECMVC  MVC   1(*-*,COUNT),0(COUNT)    DIRTY REST OF FREE REGION\n         SPACE\nABFCELL  DS    0H\n        $LOGERR 1005               FREECELL ERROR RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#FS": {"ttr": 5654, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00,\\x00,\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .FS (FOOTING SPACING) --- CONTROL                      *\n*                                                                     *\n***********************************************************************\n         SPACE\nFS      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n        $CALL  GETNUM              GET NUMBER\n         BC    BDNO,FS03           ERROR IF INVALID\n         BC    BOMIT,FS01          ENTER DEFAULT IF OMITTED\n         CLI   NUMSIGN,C' '        WAS ARGUMENT SIGNED .Q\n         BE    FS02                BRANCH IF NOT\n         AH    COUNT,FSCNT         ALTER EXISTING FOOTING\n         B     FS02                GO CHECK AND ENTER\nFS01     DS    0H\n         LA    COUNT,1             DEFAULT FOOTING SPACING VALUE\nFS02     DS    0H\n         LTR   COUNT,COUNT         IS FOOTING SPACING NEGATIVE\n         BM    FS05                ERROR IF YES\n         LH    TEMP,BMMRG          BOTTOM MARGIN VALUE\n         SH    TEMP,FTMRG          LESS FOOTING MARGIN\n         CR    COUNT,TEMP          COMPARE VALUES\n         BH    FS06                ERROR IF BIGGER\n         C     COUNT,DEFHSFS+TAB3DEF    BIGGER THAN TT/BT OVERLAP .Q\n         BH    FS04                ERROR IF YES\n         STH   COUNT,FSCNT         SET FOOTING SPACING\n         B     FS07                GO TO COMMON EXIT\n         SPACE\nFS03     DS    0H\n         MVI   EFLAG005,ERRSET     INVALID ARGUMENT\n         B     FS07                AND GO BACK\nFS04     DS    0H\n         MVI   EFLAG013,ERRSET     ARG TOO BIG\n         B     FS07                AND GO BACK\nFS05     DS    0H\n         MVI   EFLAG014,ERRSET     ARG TOO SMALL\n         B     FS07                AND GO BACK\nFS06     DS    0H\n         MVI   EFLAG042,ERRSET     ARG TOO BIG\n         B     FS07                AND GO BACK\n         SPACE\nFS07     DS    0H\n        $EXIT  RC=0                DONE WITH .FS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#FV": {"ttr": 5656, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x12\\x00\\x12\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .FV (EVEN PAGE FOOTING) --- CONTROL                    *\n*              .EB (EVEN BOTTOM TITLE) --- CONTROL                    *\n*                                                                     *\n***********************************************************************\n         SPACE\nEB      $ENTER ,\n        $ON    SWITCHS,FNOCASE     UPPER CASE FLAG FOR ALTERNATE FORMAT\n        $CALL  FV                  LET HIM DO THE WORK\n        $EXIT  RC=0                AND RETURN TO MAIN STREAM\n         SPACE\nFV      $ENTER ,\n         L     X1,ADEVHEAD         PUT DATA IN EVEN AREA\n         LNR   X1,X1               PUT DATA IN FOOT AREA\n        $CALL  HEADSAVE            ..\n        $OFF   SWITCHS,FNOCASE     RESET FORMAT FLAG\n        $EXIT  RC=0                NEXT INPUT LINE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#GETARG": {"ttr": 5889, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00<\\x00<\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 60, "newlines": 60, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        INTERNAL FUNCTION 'GETARG' --- SCAN OPERAND FIELD            *\n*                                                                     *\n***********************************************************************\n         SPACE\n*                                                                     *\n*        CC=BOMIT IF ARG IS OMITTED           (COUNT=1)               *\n*        CC=BPOS  IF ARG IS PRESENT           (COUNT=ADDRESS)         *\n*                                             (TEMP=LENGTH-1)         *\n*                                                                     *\n         SPACE\nGETARG  $ENTER ,\n         LA    R0,1                BXLE INCREMENT\n         L     R1,ARGSTOP          BXLE COMPARAND\n         L     COUNT,ARGSTART      WHERE TO START SCAN\n         CLR   COUNT,R1            ALREADY AT END OF STRING .Q\n         BH    GET02               IF YES, QUIT\n         SPACE\nGET01    DS    0H\n         CLI   0(COUNT),C' '       SKIP LEADING BLANKS\n         BNE   GET03               ..\n         BXLE  COUNT,R0,GET01      ..\nGET02    DS    0H\n        $OFF   SWITCHS,FNOCASE     RESET CASE CONVERSION IF REQUIRED\n         LA    COUNT,1             OMITTED ARG DUMMY ADDR\n        $CC    OMIT                SET CONDITION CODE\n         B     GET07               GO TO RETURN\n         SPACE\nGET03    DS    0H\n         LR    TEMP,COUNT          NOW LOOK FOR ARGUMENT END\nGET04    DS    0H\n         CLI   0(TEMP),C' '        ..\n         BE    GET05               ..\n         SPACE\n         CLI   0(TEMP),C'('        IS THIS AN OPEN PARENTHESIS\n         BNE   *+8                 SKIP INSTRUCTION, IF NOT\n         ST    TEMP,OPENPARN       SAVE POINTER TO IT\n         SPACE\n         CLI   0(TEMP),C')'        IS THIS A CLOSE PARENTHESIS\n         BNE   *+8                 SKIP INSTRUCTION IF NOT\n         ST    TEMP,CLOSPARN       ELSE SAVE POINTER\n         SPACE\n         BXLE  TEMP,R0,GET04       ..\nGET05    DS    0H\n         ST    TEMP,ARGSTART       ADDRESS OF START FOR NEXT CALL\n         SR    TEMP,COUNT          TRUE LENGTH OF ARGUMENT\n         BCTR  TEMP,0              SS-TYPE COUNT OF ARG\n         SPACE\n        $IFON  SWITCHS,FNOCASE,GET06    BRANCH IF NO UPPER CASE\n         EX    TEMP,GETARG0        CONVERT ARG TO UPPER CASE\nGET06    DS    0H\n        $OFF   SWITCHS,FNOCASE     RESET CASE CONVERSION\n        $CC    POS                 SET CC BPOS FOR ARG PRESENT\nGET07    DS    0H\n         ST    COUNT,ERRSTART      IN CASE OF ERROR\n        $RESTOR KEEP=(COUNT,TEMP)  RESTORE CALLER'S REGISTERS\n         BR    RETURN              RETURN TO CALLER\n         SPACE\nGETARG0  OC    0(*-*,COUNT),BLANKS CONVERTS TO UPPER CASE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#GETCELL": {"ttr": 5891, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x006\\x006\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL ROUTINE 'GETCELL' --- GET QUEUE BUFFER        *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY - R1      LENGTH TO BE GOT                          *\n*                 - RETURN  RETURN ADDRESS                            *\n*        ON EXIT  - TEMP    POINTER TO GOT AREA                       *\n*                 - CC=BPOS IF SUCCESSFUL                             *\n*                 - CC=BNEG IF FAILED                                 *\n         SPACE\nGETCELL $ENTER ,\n         L     X1,RGLISTAD         REGION MANAGER PARM ADDRESS\n         USING RGLIST,X1           TELL THE ASSEMBLER\n         LR    COUNT,R1            REMEMBER LENGTH REQUIRED\n         CLI   PRGFLAG,PRGINIT     INITIAL CALL DONE .Q\n         BNE   GETC02              BRANCH IF YES\n         LA    R1,RGLIST           POINT TO PARM LIST\n        $CALL  RGNMGR              INITIALIZE REGIONS\n         BC    BPOS,GETC02         BRANCH IF SUCCESS\nGETC01   DS    0H\n         SR    TEMP,TEMP           ZERO RETURN ADDRESS\n        $CC    NEG                 SET CONDITION CODE\n         B     GETC04              AND BRANCH TO RETURN\n         SPACE\nGETC02   DS    0H\n         ST    COUNT,PCELLLEN      SET GET LENGTH\n         XC    PCELLPTR,PCELLPTR   THIS IS A GET\n         LA    R1,RGLIST           PARM LIST\n        $CALL  RGNMGR              TRY FOR AN ALLOTMENT\n         BC    15-BPOS,GETC01      BRANCH IF FAILED\n         L     TEMP,PCELLPTR       SET AREA POINTER\n         LA    TEMP,0(,TEMP)       CLEAR REGION EXTENT NUMBER\n         L     COUNT,PCELLLEN      GET USER'S LENGTH\n         S     COUNT,F2            LENGTH-1 OF REMAINDER FOR MVC\n         MVI   0(TEMP),X'7D'       DIRTY REGION GOTTEN\n         EX    COUNT,GETCMVC       ALL OF IT\n         SPACE\n         L     R1,PRGUSED          FORMER SPACE FROM REGION\n         A     R1,PCELLLEN         PLUS AREA JUST GOT\n         ST    R1,PRGUSED          SET CURRENT SPACE USED\n         DROP  X1\n         C     R1,PRGHIGH          NEW HIGH WATER MARK .Q\n         BNH   GETC03              BRANCH IF NOT\n         ST    R1,PRGHIGH          SET NEW HIGH WATER MARK\nGETC03   DS    0H\n        $CC    POS                 SET CONDITION CODE\n         SPACE\nGETC04   DS    0H\n        $RESTOR KEEP=(TEMP)        RESTORE CALLER'S REGISTERS\n         BR    RETURN              AND RETURN TO CALLER\n         SPACE\nGETCMVC  MVC   1(*-*,TEMP),0(TEMP) DIRTY ALL OF GOTTEN REGION\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#GETNUM": {"ttr": 5893, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x03\\x16\\x03\\x16\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 790, "newlines": 790, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTION 'GETNUM'                             *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER:   $CALL  GETNUM\n*                  SRSWS ON TO IGNORE BLANKS\n*                  SRSWS OFF TO RETURN ON FIRST BLANK\n*\n*        CC=BOMIT IF ARG IS OMITTED           (COUNT=1)\n*        CC=BPOS  IF ARG IS POSITIVE OR ZERO  (COUNT=NUMBER)\n*                                             (TEMP=LENGTH-1)\n*        CC=BNEG  IF ARG IS NEGATIVE          (COUNT=NUMBER)\n*                                             (TEMP=LENGTH-1)\n*        CC=BDNO  IF ARG IS NOT NUMERIC       (COUNT=START ADDR)\n*                                             (TEMP=ERROR#)\n         SPACE\n*\n*  INITIALIZE\n*\nGETNUM  $ENTER ,\n         XC    TERMSWK(TERMSLEN),TERMSWK     ZERO TERMS WORK AREA\n         MVC   TERMSWIT,SWITCHS    SAVE CALLER'S SWITCHS\n        $OFF   SWITCHS,SRSWS       FORGET CALLED BY .SR\n         L     X2,ARGSTART         START OF SCAN AREA\n         L     R1,ARGSTOP          END OF THE LINE\n         LA    R0,1                BXLE INCREMENT\n         CLR   X2,R1               ALREADY AT THE END .Q\n         BH    GEXPDN              BRANCH IF YES\nGEXPLP   DS    0H\n         CLI   0(X2),C' '          SKIP LEADING BLANKS\n         BNE   GEXPDN              BRANCH IF DONE\n         BXLE  X2,R0,GEXPLP        GO TILL EXAUSTED\nGEXPDN   DS    0H\n         ST    X2,FTXPPT           SAVE FIRST BYTE POINTER\n         ST    X2,ERRSTART         IN CASE OF ERROR\n         BAL   RETURN,GEXPSW       CONVERT TO INTERNAL FORMAT\n         LA    COUNT,1             FOR OMITTED EXPRESSION\n         BC    BOMIT,SETRET        RETURN NOW IF NO ARGUMENT\n         MVI   NUMSIGN,C' '        CLEAR UNARY OPERATOR\n         CLI   0(X2),IPLUS         UNARY PLUS .Q\n         BE    GEXPUN              BRANCH IF YES\n         CLI   0(X2),IMINUS        UNARY MINUS .Q\n         BNE   GEXPSET             BRANCH IF NOT\nGEXPUN   DS    0H\n         MVC   NUMSIGN,0(X2)       MOVE INTERNAL SIGN\n         LA    X3,TRSLTB           POINT TO TRANSLATE TABLE\n         TR    NUMSIGN,0(X3)       CONVERT TO EXTERNAL FORMAT\nGEXPSET  DS    0H\n         LA    COUNT,NTRMS         GET ADDRESS OF NTRMS\n         LA    X1,TERMS            GET ADDRESS OF TERMS\n         LA    R15,OPRNS           GET ADDRESS OF OPRNS\n         LA    TEMP,RLIST          GET ADDRESS OF RLIST\n*\n*  SCAN OF THE EXPRESSION FOR TERMS OR OPERATORS\n*\nLOOK     DS    0H\n         C     X2,ARGSTOP          AT END OF STRING TO SCAN .Q\n         BH    BLCOM01             BRANCH IF YES\n         MVC   WRKCHAR,0(X2)       MOVE IN NEXT CHAR\n         LA    X3,TRSLTB           POINT TO TRANSLATE TABLE\n         TR    WRKCHAR,0(X3)       TRANSLATE TO EXTERNAL\n         CLC   WRKCHAR,PSYMBOL     WORKING PAGE SYMBOL .Q\n         BE    LOOK01              BRANCH IF YES\n         CLC   WRKCHAR,PSYMBOL+1   DEFAULT PAGE SYMBOL .Q\n         BE    LOOK01              BRANCH IF YES\n         CLC   WRKCHAR,PSYMBOL+2   ALTERNATE PAGE SYMBOL .Q\n         BNE   LOOK02              BRANCH IF NOT\nLOOK01   DS    0H\n         L     X3,PACNTI           GET INTEGER PAGE NUMBER\n         ST    X3,0(,X1)           VALUE TO TERMS LIST\n         LA    R0,1                MAX LENGTH OF PAGE SYM\n         LR    R1,R0               AND ACTUAL LENGTH OF PAGE SYM\n         AR    X2,R1               BUMP COLUMN POINTER\n         B     ABSD                VERIFY AND CHECK\n         SPACE\nLOOK02   DS    0H\n         CLI   0(X2),IALPHA        IS CHAR ALPHANUMERIC .Q\n         BH    NOTAM               BRANCH IF NOT\n         ST    X2,ERRSTART         SAVE POINTER TO FIRST BYTE OF TERM\n         CLI   0(X2),IA            IS CHAR A NUMBER .Q\n         BL    DEC\n         CLI   1(X2),IQUOTE        IS NEXT CHAR A QUOTE .Q\n         BE    NEXTQ\n         B     ERR9                ILLEGAL CHARACTER\n*\n*  DECIMAL SELF-DEFINING VALUE IN THE EXPRESSION\n*\nDEC      DS    0H\n         LA    R0,3                DECIMAL TYPE INDICATOR\n         BAL   RETURN,SDVCF        TO SELF-DEFINING VALUE ROUTINE\n         LA    R0,8                MAX NUMBER OF HEX DIGITS\n         ST    X3,0(,X1)           VALUE TO TERMS LIST\n         LA    R0,10               MAX NO OF DIGITS\n         B     ABSD                GO AND CHECK RESULT\n*\n*  1ST CHARACTER IS ALPHABETIC AND 2ND IS A QUOTE\n*\nNEXTQ    DS    0H\n         CLI   0(X2),IB            BINARY SELF-DEFINING VALUE .Q\n         BE    BINRY\n         CLI   0(X2),IC            CHARACTER SELF-DEFINING VALUE .Q\n         BE    CHARS\n         CLI   0(X2),IX            HEXADECIMAL SELF-DEFINING VALUE .Q\n         BE    HEX\n         B     ERR9                ILLEGAL CHARACTER\n*\n*  BINARY SELF-DEFINING VALUE IN THE EXPRESSION\n*\nBINRY    DS    0H\n         LA    X2,2(,X2)           POINT TO FIRST CHARACTER\n         LA    R0,1                BINARY TYPE INDICATOR\n         BAL   RETURN,SDVCF        TO SELF-DEFINING VALUE ROUTINE\n         LA    R0,32               MAX NUM OF BITS\n         B     LM\n*\n*  CHARACTER SELF-DEFINING VALUE IN THE EXPRESSION\n*\nCHARS    DS    0H\n         LA    X2,2(,X2)           POINT TO FIRST CHARACTER\n         LA    R0,8                CHARACTER TYPE INDICATOR\n         BAL   RETURN,SDVCF        TO SELF-DEFINING VALUE ROUTINE\n         LA    R0,4                MAX NO OF CHARACTERS\n         ST    X3,0(,X1)           VALUE TO TERMS LIST\n         LA    X3,TRSLTB           POINTER TO TRANSLATE TABLE\n         TR    0(4,X1),0(X3)       TRANSLATE TO EXTERNAL VALUE\n         B     CKQ\n*\n*  HEXADECIMAL SELF-DEFINING VALUE IN THE EXPRESSION\n*\nHEX      DS    0H\n         LA    X2,2(,X2)           POINT TO FIRST CHARACTER\n         LA    R0,4                HEXADECIMAL TYPE INDICATOR\n         BAL   RETURN,SDVCF        TO SELF-DEFINING VALUE ROUTINE\n         LA    R0,8                MAX NO OF HEX DIGITS\nLM       DS    0H\n         ST    X3,0(,X1)           VALUE TO TERMS LIST\nCKQ      DS    0H\n         CLI   0(X2),IQUOTE        IS ENDING CHAR A QUOTE .Q\n         BNE   ERR9\n         LA    X2,1(,X2)           POINT TO CHARACTER AFTER QUOTE\n         LTR   R1,R1               IS CNTR ZERO\n         BZ    ERR9\nABSD     DS    0H\n         CLR   R1,R0               IS ACTUAL LENGTH GT MAXIMUM .Q\n         BH    ERR0\n         CLI   COND,CONDA          IS COND UNCHANGED .Q\n         BH    ABSCK\n         B     COMPT4              THIS IS ABSOLUTE TERM\nABSCK    DS    0H\n         CLI   COND,CONDE          TWO TERMS IN A ROW .Q\n         BNL   ERR10               ERROR IF YES\nCOMPT4   DS    0H\n         MVI   COND,CONDE          SET ABSOLUTE TERM\nCOMPT    DS    0H\n         LA    R0,TERMS            START OF TERMS LIST\n         LR    R1,X1               THIS IS WHERE WE'RE AT\n         SR    R1,R0               THIS IS THE DIFFERENCE\n         CH    R1,CTTERMC          TOO MANY TERMS .Q\n         BH    ERR2                BRANCH IF YES\n         MVI   0(COUNT),X'02'      2 TO NTRMS LIST\n         LA    COUNT,1(,COUNT)     BUMP NTRMS COUNT BY ONE\n         LA    X1,4(,X1)           BUMP BY FOUR (FOR TERMS)\n         LA    TEMP,2(,TEMP)       BUMP RLIST POINTER BY TWO\n         B     LOOK\n*\n*  1ST CHARACTER IS NOT ALPHANUMERIC\n*\nNOTAM    DS    0H\n         CLI   0(X2),ICOMMA        IS CHARACTER AN OPERATOR .Q\n         BL    LTCOM               BRANCH IF YES\n         CLI   0(X2),ILPARN        IS CHARACTER LEFT PAREN .Q\n         BE    LPAR                BRANCH IF YES\n         CLI   0(X2),IRPARN        IS CHARACTER RIGHT PAREN .Q\n         BE    RPAR                BRANCH IF YES\n         CLI   0(X2),IBLANK        IS CHARACTER BLANK .Q\n         BE    BLCOM               BRANCH IF YES\n         B     ERR9                ALL ELSE IS ILLEGAL FIRST CHAR\n*\n*  RIGHT PARENTHESIS IN THE EXPRESSION\n*\nRPAR     DS    0H\n         CLI   COND,CONDE          DOES RIGHT PAREN FOLLOW TERM .Q\n         BL    ERR12               ERROR IF NOT\n         MVI   COND,CONDE          SET RIGHT PAREN COND\n         CLI   PCNTR,0             IS PCNTR =0\n         BH    NOEND               NO, CONTINUE SCANNING\n         B     ERR9                YES, UNBALANCED PAREN\n*\n*  1ST CHARACTER IS EITHER +,-,*, OR /.\n*\nLTCOM    DS    0H\n         CLI   0(X2),IASTER        IS CHARACTER AN ASTERISK .Q\n         BE    STAR\n         BH    SLASH\n*\n*  + OR - IN THE EXPRESSION\n*\nPLMIN    DS    0H\n         CLI   COND,CONDE          WAS LAST ENTRY A TERM .Q\n         BNL   PLMIN3              BRANCH IF YES\n         CLI   COND,CONDA          1ST OPERATOR/TERM .Q\n         BE    COMPT4              ENTER ZERO OPERAND IF YES\n         MVI   COND,CONDC          UNARY OPERATOR\nPLMIN2   DS    0H\n         LA    R0,IALPHA-2         BUMP OPERATOR BY TWO\n         B     SET1                AND ENTER SAME\nPLMIN3   DS    0H\n         MVI   COND,CONDB          BINARY + OR -\nSET      DS    0H\n         LA    R0,IALPHA\nSET1     DS    0H\n         IC    R1,0(,X2)\n         SR    R1,R0\n         STC   R1,NEWOP            HIERARCHY CODE TO NEWOP\n*\n*  MAIN LOOP TO PERFORM ARITHMETIC\n*\nLOOP     DS    0H\n         LA    R1,OPRNS            POINT TO FIRST OPERATOR ENTRY\n         CR    R15,R1              ARE THERE PREVIOUS OPERATORS .Q\n         BH    ONZ\n         CLI   ENDOE,0             IS ENDOE=0\n         BH    FINIS\nPUT      DS    0H\n         MVC   0(1,R15),NEWOP      NEWOP TO OPRNS LIST\nBUMPY    DS    0H\n         LA    R15,1(,R15)         BUMP R15 BY 1 (FOR OPRNS)\nBUMPR    DS    0H\n         LA    X2,1(,X2)           BUMP BY ONE FOR NON-ALFNUM\n         B     LOOK\nONZ      DS    0H\n         BCTR  R15,0               POINT R15 TO PREVIOUS OPERATOR\n         CLC   0(1,R15),NEWOP      IS NEW HIERARCHY LT-EQ PREVIOUS\n         BNL   LE\n         CLI   NEWOP,OPSLASH       TEST NEW OP /\n         BNE   STEPUP              NO\n         CLI   0(R15),OPSTAR       TEST PREV OP *\n         BE    WORK                YES, DO * FIRST\nSTEPUP   DS    0H\n         LA    R15,1(,R15)         ADD 1 BACK TO R15\n         B     PUT\nLE       DS    0H\n         CLI   NEWOP,OPUMINUS      IS THIS UNARY - .Q\n         BE    STEPUP              JUST ENTER IT IF YES\n         CLI   NEWOP,OPUPLUS       IS THIS UNARY + .Q\n         BE    STEPUP              JUST ENTER IF YES\n         CLI   0(R15),OPEND        IS OLD HIERARCHY ZERO .Q\n         BH    WORK\n         IC    R1,PCNTR            SUBTRACT 1 FROM PCNTR\n         BCTR  R1,0\n         STC   R1,PCNTR\n         B     BUMPR\n*\n*  LEFT PARENTHESIS IN THE EXPRESSION\n*\nLPAR     DS    0H\n         CLI   COND,CONDE          WAS A TERM LAST ENTRY .Q\n         BNL   LPEND               POSSIBLE END OF EXP IF YES\n         MVI   COND,CONDB          SET LEFT PAREN COND\n         SR    R1,R1               ZERO WORK REGISTER\n         IC    R1,PCNTR            GET CURRENT LEVEL OF PARENS\n         CH    R1,CTPARENC         ARE THERE TOO MANY LEFT PARENS\n         BH    ERR1                ERROR IF TOO MANY\n         LA    R1,1(,R1)           INCREMENT LEVEL OF PARENS\n         STC   R1,PCNTR\n         MVI   0(R15),0            ZERO TO OPRNS LIST\n         B     BUMPY\n*\n*  ASTERISK IN THE EXPRESSION\n*\nSTAR     DS    0H\n         CLI   COND,CONDE          DOES A TERM PRECEDE .Q\n         BL    ERR12               ERROR IF NOT\n*\n*  ASTERISK IS MULTIPLICATION OPERATOR\n*\nFORD1    DS    0H\n         MVI   COND,CONDD          SET MULT/DIV COND\n         B     PLMIN2              GO ADJUST OPERATION\n*\n*  SLASH IN THE EXPRESSION\n*\nSLASH    DS    0H\n         CLI   COND,CONDE          DOES A TERM PRECEDE .Q\n         BL    ERR12               ERROR IF NOT\n         B     FORD1               ENTER THE SLASH\n*\n*  BLANK IN THE EXPRESSION\n*\nBLCOM    DS    0H\n        $IFOFF TERMSWIT,SRSWS,BLCOM01   BRANCH IF BLANKS SIGNIFICANT\n         LA    X2,1(,X2)           POINT TO NEXT CHARACTER\n         B     LOOK                AND TRY AGAIN\nBLCOM01  DS    0H\n         CLI   COND,CONDE          TERM PRECEDE BLANK .Q\n         BL    ERR17               ERROR IF NOT\n*\n*  LEFT PARENTHESIS END CONDITION\n*\nLPEND    DS    0H\n         CLI   PCNTR,0             IS PCNTR =0\n         BH    ERR17\nENDNG    DS    0H\n         MVI   ENDOE,15            SET ENDOE NON-ZERO\nNOEND    DS    0H\n         MVI   NEWOP,OPEND         SET NEWOP ZERO\n         B     LOOP\n*\n*  PERFORM ARITHMETIC WORK\n*\nWORK     DS    0H\n         ST    TEMP,NCOMP          STORE RLIST POINTER IN NCOMP\n         LA    R0,8                POINT TO FIRST OF THE TWO\n         SR    X1,R0               TERMS ENTRIES\n         LA    R0,2                POINT TO FIRST OF THE TWO\n         SR    COUNT,R0            NTRMS ENTRIES\n         IC    R0,1(,COUNT)        2ND NTRMS  ENTRY TO R0\n         SR    TEMP,R0             SUBTRACT 2ND NTERMS ENTRY\n         SR    R1,R1               ZERO A WORK REGISTER\n         IC    R1,0(,R15)          GET OPERATOR FUNCTION\n         AR    R1,R1               DOUBLE IT\n         LH    R1,OPBRANCH(R1)     GET INDEX BRANCH VALUE\n         B     GETNUM(R1)          THE APPROPRIATE ROUTINE\nOPBRANCH DC    H'1'                ZERO ERROR\n         DC    AL2(OPPLS-GETNUM)   BINARY PLUS\n         DC    AL2(OPMINS-GETNUM)  BINARY MINUS\n         DC    AL2(OPUPLS-GETNUM)  UNARY PLUS\n         DC    AL2(OPUMINS-GETNUM) UNARY MINUS\n         DC    AL2(MULDV-GETNUM)   MULTIPLICATION\n         DC    AL2(MULDV-GETNUM)   DIVISION\n*\n*  OPERATOR IS SUBTRACTION.  COMPLEMENT 2ND VALUE AND CHANGE THE\n*  RELOCATION SIGN BYTE OF THE TERMS IN THE 2ND VALUE.\n*\nOPUMINS  DS    0H\n         CLI   0(TEMP),OPPLUS      IS SIGN BYTE + .Q\n         BL    NOCHGU              BRANCH IF ABSOLUTE\n         BE    PLCHGU              BRANCH IF SIGN +\n         MVI   0(TEMP),OPPLUS      CHANGE - SIGN TO +\n         B     NOCHGU              AND CONTINUE\nPLCHGU   DS    0H\n         MVI   0(TEMP),OPMINUS     CHANGE + SIGN TO -\nNOCHGU   DS    0H\n         L     R1,4(,X1)           GET CURRENT VALUE\n         LCR   R1,R1               COMPLEMENT 2ND TERMS LIST ENTRY\nOPUSET   DS    0H\n         LA    X1,4(,X1)           BUMP OPND POINTER\n         L     TEMP,NCOMP          RESTORE RLIST POINTER\n         LA    COUNT,1(,COUNT)     UNARY HAS BUT ONE TERM\n         B     STORE               AND CONTINUE\nOPUPLS   DS    0H\n         L     R1,4(,X1)           GET CURRENT VALUE\n         B     OPUSET              AND REENTER IT\n*\nOPMINS   DS    0H\n         L     R1,4(,X1)           GET 2ND TERMS LIST ENTRY\n         LCR   R1,R1               COMPLEMENT 2ND TERMS LIST ENTRY\n         ST    R1,4(,X1)\nCHG      DS    0H\n         CLI   0(TEMP),OPPLUS      TEST SIGN BYTE IN 2ND RLIST\n         BL    NOCHG               BRANCH IF ABS. VALUE\n         BE    PLCHG               BRANCH IF SIGN +\n         MVI   0(TEMP),OPPLUS      CHANGE SIGN TO +\n         B     NOCHG\nPLCHG    DS    0H\n         MVI   0(TEMP),OPMINUS     CHANGE SIGN TO -\nNOCHG    DS    0H\n         LA    TEMP,2(,TEMP)       POINT TO NEXT RLIST ENTRY\n         CL    TEMP,NCOMP\n         BL    CHG                 BRANCH BACK IF MORE ENTRIES\n         SR    TEMP,R0             SUBTRACT 2ND NTERMS ENTRY\n*\n*  OPERATION IS ADDITION OR SUBTRACTION.  SCRATCH ENTRIES IN THE\n*  RELOCATION LIST WHERE POSSIBLE.\n*\nOPPLS    DS    0H\n         IC    R0,0(,COUNT)        FIRST NTRMS ENTRY TO R0\n         LR    R1,TEMP             POINT R1 TO 2ND NTRMS LIST\n         SR    TEMP,R0             POINT TO 1ST NTERMS LIST\n         LR    X3,R1               SAVE R1\nBCOMP    DS    0H\n         CLI   0(TEMP),OPPLUS      IS FIRST SIGN + .Q\n         BL    NSCR                BRANCH IF ABS. VALUE (CODE =0)\n         BH    F2MIN               BRANCH IF FIRST SIGN -\n         CLI   0(R1),OPMINUS       IS SECOND SIGN -\n         BL    NSCR                BRANCH IF SIGN NOT -\nOPP      DS    0H\n         MVI   0(TEMP),X'00'       ZERO TO FIRST SIGN\n         MVI   0(R1),0             ZERO TO SECOND SIGN\n         B     NSCR\nF2MIN    DS    0H\n         CLI   0(R1),OPPLUS        IS SECOND SIGN +\n         BE    OPP\nNSCR     DS    0H\n         LA    R1,2(,R1)           POINT R1 TO NEXT IN 2ND RLIST\n         CL    R1,NCOMP\n         BL    BCOMP               BRANCH BACK IF MORE IN 2ND LIST\n         LA    TEMP,2(,TEMP)       POINT TO NEXT IN 1ST LIST\n         LR    R1,X3               START OF 2ND LIST BACK TO R1\n         CLR   R1,TEMP\n         BH    BCOMP               BRANCH BACK IF MORE IN 1ST LIST\n         L     TEMP,NCOMP          RESTORE RLIST POINTER\n         LCR   R1,R1               COMPLEMENT R1\n         AR    R1,TEMP             2ND NTRMS ENTRY TO R1\n         IC    R0,0(,COUNT)        1ST NTRMS ENTRY TO R0\n         AR    R1,R0               ADD THE 2 NTRMS ENTRIES\n         STC   R1,0(,COUNT)        SUM TO POSITION OF THE 1ST\n*\n*  PERFORM ADDITION\n*\n         L     R1,0(,X1)           1ST TERMS LIST ENTRY TO R1\n         A     R1,4(,X1)           ADD 2ND ENTRY\n         BO    ERR13               -DUMMY-APPROP. OVERFLOW ROUTINE TO S\nSTORE    DS    0H\n         ST    R1,0(,X1)           RESULT TO 1ST TERMS LIST ENTRY\n         LA    X1,4(,X1)           BUMP BY FOUR (FOR TERMS LIST)\n         LA    COUNT,1(,COUNT)     BUMP NTRMS COUNT BY ONE\n         B     LOOP\n*\n*  OPERATOR IS MULTIPLICATION OR DIVISION.\n*\nMULDV    DS    0H\n         SR    R1,R1               CLEAR R1\n         IC    R1,0(,COUNT)        1ST NTERMS ENTRY TO R1\n         AR    R0,R1               ADD THE 2 NTRMS ENTRIES\n         STC   R0,0(,COUNT)        SUM TO 1ST ENTRY LOCATION\n         SR    TEMP,R1             SUBTRACT 1ST NTRMS ENTRY\n         LA    R0,2                2 TO R0\n         L     R1,NCOMP\n         SR    R1,R0               C(NCOMP)-2 TO R1\nMORE     DS    0H\n         CLI   0(TEMP),X'00'\n         BH    *+4                 JUST FOR NOW\n         BXLE  TEMP,R0,MORE\n         SR    R1,R1               ZERO R1\n         C     R1,4(,X1)\n         BE    STORE               BRANCH IF 2ND TERMS ENTRY =0\n         L     R0,0(,X1)           1ST TERMS ENTRY TO R0\n         SRDA  R0,32               PROPAGATE SIGN BIT\n         CLI   0(R15),OPSTAR       IS OPERATOR * OR /\n         BH    DIV                 BRANCH IF /\n*\n*  PERFORM MULTIPLICATION\n*\n         M     R0,4(,X1)           MULTIPLY BY 2ND TERMS ENTRY\n         LTR   R1,R1\n         BNL   CHK0                BRANCH IF LOW-ORDER NON-NEG\n         LCR   R0,R0               COMPLEMENT HIGH-ORDER\n         BCTR  R0,0                SUBTRACT 1 FROM THE COMPLEMENT\nCHK0     DS    0H\n         LTR   R0,R0\n         BC    7,ERR13             ERROR  IF HIGH-ORDER NOW NOT=0\n         B     STORE\n*\n*  PERFORM DIVISION\n*\nDIV      DS    0H\n         D     R0,4(,X1)           DIVIDE 1ST BY 2ND TERMS ENTRY\n         B     STORE\n*\n*  END OF EXPRESSION FOUND\n*\nFINIS    DS    0H\n         LR    TEMP,X2             TRANSFER SCANNING ADDRESS\n         ST    TEMP,ARGSTART       SCAN NEXT TIME FROM HERE\n         S     TEMP,FTXPPT         LESS STARTING ADDRESS\n         BCTR  TEMP,0              LENGTH-1 OF SCANNED STRING\n         BAL   RETURN,GEXPSW       CONVERT TO EXTERNAL FORMAT\n         L     COUNT,TERMS         RESTORE FINAL RESULT\n         LTR   COUNT,COUNT         TEST RESULTING VALUE OF EXPRESSION\n         BNZ   FINIS01             BRANCH NOT ZERO\n        $CC    POS                 ZERO IS POSITIVE\nFINIS01  DS    0H\n         B     SETRET              RETURN TO CALLER\n         EJECT\n*\n*  ERROR FOUND\n*\n* TABLE OF ERROR CODES USED IN GETNUM\nSELFDEF  EQU   4                   SELF-DEF. VALUE TOO LARGE\nARITHER  EQU   8                   ARITHMETIC ERROR-OVERFLOW\nILORDER  EQU   12                  TWO TERMS NOT SEPARATE\nILLCHAR  EQU   16                  ILLEGAL CHARACTER\nMNYERR   EQU   20                  EXP. CONTAINS MORE THAN CTTERMC TRMS\nOPERR    EQU   24                  TWO OPERATORS ILLEGALLY COUPLED\nPARERR   EQU   28                  TOO MANY LEVELS OF PARENS\nENDERR   EQU   32                  EXP. END PREMATURE-UNPAIRED PAREN\n         SPACE\n*\n*  ERROR IS SELF-DEFINING VALUE TOO LARGE\n*\nERR0     DS    0H\n         LA    COUNT,SELFDEF       SELF-DEF. VALUE TOO LARGE\n         B     FATLER              BRANCH TO ERROR EXIT\n*\n*  TOO MANY LEVELS OF PARENTHESES\n*\nERR1     DS    0H\n         LA    COUNT,PARERR        TOO MANY LEVELS OF PARENS\n         B     FATLER\n*\n*  TOO MANY TERMS IN EXPRESSION\n*\nERR2     DS    0H\n         LA    COUNT,MNYERR        TOO MANY TERMS IN EXPRESSION\n         B     FATLER              GO TO ERROR EXIT\n*\n*  ERROR IS ARITHMETIC\n*\nERR13    DS    0H\n         LA    COUNT,ARITHER       ARITHMETIC ERROR\n         B     FATLER              BRANCH TO ERROR EXIT\n*\n*ERROR IS ILLEGAL CHARACTER\n*\nERR9     DS    0H\n         LA    COUNT,ILLCHAR       ILLEGAL CHARACTER\n         B     FATLER              BRANCH TO ERROR EXIT\n*\n* ERROR IS TWO CONSECUTIVE OPERATORS\n*\nERR12    DS    0H\n         LA    COUNT,OPERR         ILLEGAL ORDER OF OPERATORS\n         B     FATLER              BRANCH TO ERROR EXIT\n*\n*ERROR IS ILLEGAL END OF EXPRESSION OR UNPAIRED PARENS\n*\nERR17    DS    0H\n         LA    COUNT,ENDERR        EXPRESSION END PREMATURE\n         B     FATLER              BRANCH TO ERROR EXIT\n*\n* ERROR IS TWO CONSECUTIVE TERMS\n*\nERR10    DS    0H\n         LA    COUNT,ILORDER       ILLEGAL ORDER OF TERMS\n         B     FATLER              BRANCH TO ERROR EXIT\n*\nFATLER   DS    0H\n         ST    X2,ARGSTART         WE GOT THIS FAR IN STRING\n         BAL   RETURN,GEXPSW       CONVERT TO EXTERNAL FORMAT\n         LR    TEMP,COUNT          SET ERROR NUMBER\n         L     COUNT,FTXPPT        RESET SCAN START ADDR\n        $CC    DNO                 SET ERROR RETURN CODE\nSETRET   DS    0H\n        $RESTOR KEEP=(TEMP,COUNT)  RESTORE CALLER'S REGS\n         BR    RETURN              RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*              GEXPSW --- INTERNAL TEXT TO EXTERNAL AND VICE-VERSA    *\n*                                                                     *\n***********************************************************************\n         SPACE\nGEXPSW   DS    0H\n        $SAVE  ,                   SAVE CALLER'S REGISTERS\n         L     R1,ARGSTOP          EXPRESSION END\n         S     R1,FTXPPT           LESS EXPRESSION START\n         BM    GEXPSW01            BRANCH IF EMPTY\n         L     X2,FTXPPT           EXPRESSION START\n         LA    X3,TRSLTB           POINTER TO TRANSLATE TABLE\n         EX    R1,GEXPTR           REVERSE CODES\n        $CC    POS                 SUCCESS\n         B     GEXPSW02            GO TO RETURN\nGEXPTR   TR    0(*-*,X2),0(X3)     TRANSLATE INPUT STRING\nGEXPSW01 DS    0H\n        $CC    OMIT                NO ARGUMENT\nGEXPSW02 DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGS\n         BR    RETURN              RETURN TO CALLER\n         SPACE\n***********************************************************************\n* CONVERT SELF-DEFINING VALUES - FENDALL                              *\n* ENTER WITH REGISTER X2 POINTING TO 1ST CHARACTER OF CONSTANT.       *\n* LOAD REGISTER X1 WITH CONSTANT TYPE INDICATOR -                     *\n*        1 = BINARY                                                   *\n*        3 = DECIMAL                                                  *\n*        4 = HEX                                                      *\n*        8 = CHARACTER                                                *\n* BRANCH WITH RETURN REGISTER RETURN.                                 *\n* RETURNS WITH CONVERTED VALUE IN REGISTER X3, RIGHT JUSTIFIED,       *\n* SIGNIFICANT CHARACTER COUNT IN REGISTER R1, X2 AT FIRST             *\n* NON-CONSTANT CHARACTER.                                             *\n* LEADING BITS MAY BE LOST IF VALUE TOO LARGE.                        *\n***********************************************************************\n         SPACE\nSDVCF    DS    0H\n        $SAVE  ,                   SAVE CALLER'S REGISTERS\n         LR    X1,R0               CONVERT TYPE\n         STC   X1,SDV08+1          STORE SHIFT\n         SR    X3,X3               CLEAR RETURN VALUE\n         LR    R0,X3               CLEAR R0\n         LR    R1,X3               CLEAR COUNT\n         CLI   SDV08+1,8           TEST FOR C-CONSTANT\n         BNE   SDV01               NO\n         L     X3,SDV09            YES, LOAD EXTERNAL ZEROS\nSDV01    DS    0H\n         LA    R15,SDV08-1(X1)     TEST CHAR RANGE\n         C     X2,ARGSTOP          AT END OF STRING TO SCAN .Q\n         BH    SDV07               RETURN IF YES\n         CLC   0(1,X2),0(R15)\n         BH    SDV07               EXIT ON TOO HIGH\n         IC    R0,0(,X2)\n         LR    R15,X3              SAVE CUMULATIVE VALUE\n         CLI   SDV08+1,8           TEST FOR C-CONSTANT\n         BNE   SDV04               NO, TO SHIFT\n         CLI   0(X2),IQUOTE        TEST '\n         BNE   SDV04               NO\n         CLI   1(X2),IQUOTE        TEST ''\n         BE    SDV03               YES, TO SKIP\n         B     SDV07               NO, EXIT\nSDV03    DS    0H\n         LA    X2,1(,X2)           SKIP ' OR +\nSDV04    DS    0H\n         CLI   SDV08+1,3           TEST FOR DECIMAL CONSTANT\n         BNE   SDV05               BRANCH IF NOT\n         SLA   X3,0(X1)            OLD VALUE TIMES EIGHT\n         BO    SDVOFLO             ERROR IF OVERFLOW\n         AR    R15,R15             TWICE OLD VALUE\n         BO    SDVOFLO             BRANCH IF OVERFLOW\n         AR    X3,R15              TEN TIMES OLD VALUE\n         BO    SDVOFLO             BRANCH IF OVERFLOW\n         AR    X3,R0               PLUS NEXT DIGIT\n         BNO   SDV06               BRANCH IF NO OVERFLOW\nSDVOFLO  DS    0H\n         LA    R1,10               TOO MANY DECIMAL DIGITS\n         B     SDV06               AND CONTINUE\nSDV05    DS    0H\n         SLL   X3,0(X1)            SHIFT OLD VALUE\n         ALR   X3,R0               ADD CHAR TO VALUE\nSDV06    DS    0H\n         LA    R1,1(,R1)           STEP COUNT\n         LA    X2,1(,X2)           STEP COLUMN POINTER\n         B     SDV01               TO NEXT CHAR\nSDV07    DS    0H\n        $RESTOR KEEP=(R1,X2,X3)    RESTORE CALLER'S REGISTERS\n         BR    RETURN              RETURN TO CALLER\n         SPACE 2\nSDV08    DC    X'0100090F000000FF' LIMITS\nTERMSWIT DC    XL10'00'            WORK WITH SWITCHS\nSDV09    DC    0F'0',C'0000'       EBCDIC ZEROES\nCTTERMC  DC    0H'0',AL2(24*4)     4*(MAX-1) NUMBER OF TERMS\nCTPARENC DC    0H'0',AL2(10)       MAX-1 NUMBER OF PARENS\nFTXPPT   DS    F                   SAV AREA FOR PTR TO 1ST BYTE\nWRKCHAR  DC    C' '                EXTERNAL FORMAT WORK CHARACTER\n         SPACE 2\nTERMSWK  DS    0D                  TERMS WORK AREA START\nTERMS    DS    25F                 LIST OF VALUES\nRLIST    DS    25H                 RELOCATABILITY LIST\nPCNTR    DS    C                   COUNTER OF LEVEL OF '('\nNTRMS    DS    25C                 NUMBER OF TERMS PER TERMS ENTRY\nOPRNS    DS    40C                 LIST OF OPERATIONS\nCOND     DS    C                   VALIDITY INDICATOR\nENDOE    DS    C                   END EXPRESSION FLAG\nNEWOP    DS    C                   LATEST OPERATION FOUND\nTERMSLEN EQU   *-TERMS             LENGTH OF TERMS WORK AREA\n         SPACE\nNCOMP    DC    F'0'                SAVE RLIST POINTER\n         SPACE 2\n*                                       *******************************\n*                                       * TRANSLATE TABLE             *\n*                                       *******************************\n*        THE TRANSLATE TABLE PERMITS TRANSLATION FROM EXTERNAL CODE TO\n*        INTERNAL CODE AND VICE VERSA. THE POSITION CORRESPONDING TO\n*        THE EXTERNAL CODE FOR A SYMBOL CONTAINS ITS INTERNAL CODE,\n*        AND THE POSITION CORRESPONDING TO ITS INTERNAL CODE CONTAINS\n*        ITS EXTERNAL CODE.\n*        EXAMPLE- THE EXTERNAL CODE FOR 'A' IS HEX C1 (DECIMAL 193),\n*        AND THE INTERNAL CODE IS HEX 0A (DECIMAL 10). THE 193-D TABLE\n*        ENTRY IS HEX 0A, AND THE 10-TH TABLE ENTRY IS HEX C1\n*        TABLE STARTS WITH THE 0-TH ENTRY\n*\n         DC    0D'0'               ALIGN TRANSLATE TABLE\nTRSLTB   DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    X'C7C8C9D1D2D3D4D5D6D7D8D9E2E3E4E5'\n         DC    X'E6E7E8E95B7B7C4E605C616B7E504B4D'\n         DC    X'5D7D40333435363738393A3B3C3D3E3F'\n         DC    X'324142434445464748494A2E4C2F274F'\n         DC    X'2D5152535455565758595A2429305E5F'\n         DC    X'282A62636465666768696A2B6C6D6E6F'\n         DC    X'707172737475767778797A2526312C7F'\n         DC    X'808182838485868788898A8B8C8D8E8F'\n         DC    X'909192939495969798999A9B9C9D9E9F'\n         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'\n         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    X'C00A0B0C0D0E0F101112CACBCCCDCECF'\n         DC    X'D0131415161718191A1BDADBDCDDDEDF'\n         DC    X'E0E11C1D1E1F20212223EAEBECEDEEEF'\n         DC    X'00010203040506070809FAFBFCFDFEFF'\n         EJECT\n******** INTERNAL CHARACTER CODES *************************************\nIZERO    EQU   X'00'               NUMBERS\nI1       EQU   X'01'\nI2       EQU   X'02'\nI3       EQU   X'03'\nI4       EQU   X'04'\nI5       EQU   X'05'\nI6       EQU   X'06'\nI7       EQU   X'07'\nI8       EQU   X'08'\nI9       EQU   X'09'\nIA       EQU   X'0A'               LETTERS\nIB       EQU   X'0B'\nIC       EQU   X'0C'\nID       EQU   X'0D'\nIE       EQU   X'0E'\nIF       EQU   X'0F'\nIG       EQU   X'10'\nIH       EQU   X'11'\nII       EQU   X'12'\nIJ       EQU   X'13'\nIK       EQU   X'14'\nIL       EQU   X'15'\nIM       EQU   X'16'\nIN       EQU   X'17'\nIO       EQU   X'18'\nIP       EQU   X'19'\nIQ       EQU   X'1A'\nIR       EQU   X'1B'\nIS       EQU   X'1C'\nIT       EQU   X'1D'\nIU       EQU   X'1E'\nIV       EQU   X'1F'\nIW       EQU   X'20'\nIX       EQU   X'21'\nIY       EQU   X'22'\nIZ       EQU   X'23'\nIDOLLR   EQU   X'24'               EXTRA LETTERS\nIPOUND   EQU   X'25'\nIAT      EQU   X'26'\nIPLUS    EQU   X'27'               SPECIAL CHARACTERS\nIMINUS   EQU   X'28'\nIMULT    EQU   X'29'\nIASTER   EQU   X'29'\nIDIVID   EQU   X'2A'\nICOMMA   EQU   X'2B'\nIEQUAL   EQU   X'2C'\nIAMPSD   EQU   X'2D'\nIPRIOD   EQU   X'2E'\nILPARN   EQU   X'2F'\nIRPARN   EQU   X'30'\nIQUOTE   EQU   X'31'\nIBLANK   EQU   X'32'\nIALPHA   EQU   IAT                 LAST ALPHA CHARACTER\n******** END INTERNAL CHARACTER CODES *********************************\n         EJECT\n***********************************************************************\n*         *PREVIOUS*                                                  *\n*  CHAR   *  COND  *     ACTION                                       *\n***********************************************************************\n* START   *   --   * SET COND = 0                                     *\n***********************************************************************\n*  (      *0/1/2/3 * SET COND = 1                                     *\n*         *4       * IF PCNTR GT CTTERMC, LOG 'PARERR'                *\n***********************************************************************\n*  )      *0/1/2/3 * LOG 'OPERR'                                      *\n*         *4       * SET COND = 4, IF PCNTR=0 END EXPRESSION          *\n***********************************************************************\n*  +-     *0       * SET INITIAL ZERO TERM                            *\n*         *1/2/3   * SET COND = 2                                     *\n*         *4       * SET COND = 1                                     *\n***********************************************************************\n*  *      *0/1/2/3 * LOG 'OPERR'                                      *\n*         *4       * SET COND = 3                                     *\n***********************************************************************\n*  /      *0/1/2/3 * LOG 'OPERR'                                      *\n*         *4       * SET COND =3                                      *\n***********************************************************************\n*ABSOLUTE *0/1/2/3 * SET COND = 4                                     *\n*TERM     *4       * LOG 'OPERR'                                      *\n***********************************************************************\n* OR BLANK*0/1/2/3 * LOG 'ENDERR'                                     *\n*         *4       * IF PCNTR GT 0, LOG 'ENDERR'                      *\n***********************************************************************\n         SPACE\nCONDA    EQU   0                   INITIAL COND SETTING\nCONDB    EQU   1                   LEFT PAREN, BINARY + OR -\nCONDC    EQU   2                   UNARY + OR -\nCONDD    EQU   3                   ASTERISK OR SLASH\nCONDE    EQU   4                   ABSOLUTE TERM OR RIGHT PAREN\n*\n*        HEIRARCHY CODES FOR OPRNS\nOPEND    EQU   0                   BLANK OR COMMA\nOPPLUS   EQU   1                   BINARY PLUS\nOPMINUS  EQU   2                   BINARY MINUS\nOPUPLUS  EQU   3                   UNARY PLUS\nOPUMINUS EQU   4                   UNARY MINUS\nOPSTAR   EQU   5                   MULTIPLICATION\nOPSLASH  EQU   6                   DIVISION\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#GETQST": {"ttr": 6151, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00V\\x00V\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 86, "newlines": 86, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTION 'GETQST' --- GET QUOTED STRING       *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER:   $CALL  GETQST                                    *\n*                                                                     *\n*        CC=BOMIT  IF ARG IS OMITTED   (COUNT=1)                      *\n*        CC=BDNO   IF MISMATCHED QUOTE (COUNT=ADDRESS)                *\n*                                      (TEMP=LENGTH-1)                *\n*        CC=BPOS   IF STRING OR        (COUNT=ADDRESS)                *\n*                  QUOTED STRING       (TEMP=LENGTH-1)                *\n*                                                                     *\n*        QSTRING = F'0'                UNQUOTED STRING                *\n*                = F'1'                MISMATCHED QUOTED STRING       *\n*                = F'2'                QUOTED STRING                  *\n         SPACE\nGETQST  $ENTER ,\n         LA    R0,0                DELIMITER COUNT\n         ST    R0,QSTRING          ASSUME UNDELIMITED STRING\n        $CALL  GETARG              GET START OR ALL OF STRING\n         BC    BOMIT,GETQST05      BRANCH IF OMITTED OPERAND\n         SPACE\n         LR    X1,COUNT            POINT TO OPERAND\n         CLI   0(X1),C' '          TOO SMALL FOR DELIMITER .Q\n         BNH   GETQST04            BRANCH IF YES\n         CLI   0(X1),C'A'-C' '-1   TOO BIG FOR DELIMITER .Q\n         BNL   GETQST04            BRANCH IF YES\n         TRT   0(1,X1),GETQSTTB    IS IT A POSSIBLE DELIMITER .Q\n         BZ    GETQST04            BRANCH IF NOT\n         SPACE\n         LR    R1,X1               START OF DELIMITED STRING\nGETQST01 DS    0H\n         LA    R1,1(,R1)           BUMP DOWN OPERAND STRING\n         C     R1,ARGSTOP          PASSED THE END .Q\n         BH    GETQST03            MISMATCHED DELIM IF YES\n         CLC   0(1,R1),0(X1)       ENDING DELIMITER .Q\n         BNE   GETQST01            CONTINUE SEARCH IF NOT\n         C     R1,ARGSTOP          AT THE END .Q\n         BNL   GETQST02            GOT ARGUMENT IF YES\n         CLI   1(R1),C' '          DELIMITER FOLLOWED BY BLANK .Q\n         BNE   GETQST01            NO, KEEP SCANNING\nGETQST02 DS    0H\n         LA    R0,2                DELIMITER COUNT\n         ST    R0,QSTRING          SET DELIMITER COUNT\n         LR    TEMP,R1             LAST CHARACTER\n         SR    TEMP,X1             LESS FIRST GIVES LENGTH-1\n         LA    R1,1(,R1)           NEXT CHAR TO SCAN\n         ST    R1,ARGSTART         ADDR OF START FOR NEXT CALL\n         B     GETQST04            SUCCESSFUL RETURN\n         SPACE\nGETQST03 DS    0H\n         LA    R0,1                DELIMITER COUNT\n         ST    R0,QSTRING          SET DELIMITER COUNT\n         LR    COUNT,X1            POINT TO RESULT\n        $CC    DNO                 INDICATE ERROR CONDITION\n         B     GETQST05            AND GO TO RETURN\n         SPACE\nGETQST04 DS    0H\n         LR    COUNT,X1            POINT TO RESULT\n        $CC    POS                 SET FOR SUCCESS\n         SPACE\nGETQST05 DS    0H\n        $RESTOR KEEP=(COUNT,TEMP)  RESTORE CALLER'S REGISTERS\n         BR    RETURN              RETURN TO CALLER\n         SPACE\n         ORG   *-C' '\nGETQSTTB DS    0CL256              DELIMITER TABLE\n         ORG   GETQSTTB+C' '\n         DC    64X'00'                  INITIAL SETTING\n         ORG   GETQSTTB+C''''\n         DC    C''''                    SINGLE QUOTE\n         ORG   GETQSTTB+C'\"'\n         DC    C'\"'                     DOUBLE QUOTE\n         ORG   GETQSTTB+C'/'\n         DC    C'/'                     SLASH\n         ORG   GETQSTTB+C'|'\n         DC    C'|'                     OR BAR\n         ORG   GETQSTTB+C'!'\n         DC    C'!'                     EXCLAMATION MARK\n         ORG   GETQSTTB+C'\u00ac'\n         DC    C'\u00ac'                     NOT SIGN\n         ORG   GETQSTTB+C'\u00a2'\n         DC    C'\u00a2'                     CENT SIGN\n         ORG   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#GETSYM": {"ttr": 6154, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x01*\\x01*\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 298, "newlines": 298, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTION 'GETSYM'                             *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER:   $CALL  GETSYM                                    *\n*                                                                     *\n*        CC=BOMIT IF ARG IS OMITTED    (COUNT=1)                      *\n*        CC=BPOS  IF ARG IS FOUND      (COUNT=ADDR)                   *\n*                    (UNSUBSCRIPTED)   (TEMP=LENGTH-1)                *\n*        CC=BNEG  IF ARG IS FOUND      (COUNT=ADDR)                   *\n*                    (SUBSCRIPTED)     (TEMP=LENGTH-1)                *\n*        CC=BDNO  IF INVALID SUBSCRIPT (COUNT=ADDR)                   *\n*                 SUBSTRING OR SYMBOL TOO LONG                        *\n         SPACE\nGETSYM  $ENTER ,\n         MVC   SRNM,BLANKS         CLEAR NAME BUFFER\n         MVC   SRNMSUB,SRNMSUB+L'SRNMSUB     SET DEFAULT SUBSCRIPT\n         MVC   SRNMFR,SRNMFR+L'SRNMFR        SET DEFAULT 'FROM' SUBSTR\n         MVC   SRNMTO,SRNMTO+L'SRNMTO        SET DEFAULT 'TO' SUBSTR\n         MVI   SRNMFLG,X'00'       CLEAR ALL SUBSCRIPT VALUE\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION PLEASE\n        $CALL  GETARG              GET A STRING\n         BC    BOMIT,GTSYM20       BRANCH IF NO OPERAND\n         LR    R1,COUNT            START OF SCANNED OPERAND\n         LA    RETURN,GTSYM04      END OF STRING EXIT\n         CLI   0(R1),C'*'          THE BIG STRING .Q\n         BNE   GTSYM01             BRANCH IF NOT\n         LA    R1,1(,R1)           NEXT CHAR IS THE LAST\n         BR    RETURN              TAKE DELIMITER EXIT\n         SPACE\nGTSYM01  DS    0H\n         CLI   0(R1),C'A'-X'40'    OK FOR SURE .Q\n         BNL   GTSYM03             BRANCH IF YES\n        $IFON  SWITCHS,NUPSWS,GTSYM02   BRANCH IF NO CONVERSION\n         CLI   0(R1),C'$'          A DOLLAR SIGN .Q\n         BE    GTSYM03\n         CLI   0(R1),C'#'          A HASH SIGN .Q\n         BE    GTSYM03\n         CLI   0(R1),C'@'          AN AT SIGN .Q\n         BE    GTSYM03\n         CLI   0(R1),C'_'          AN UNDERSCORE .Q\n         BE    GTSYM03\n         BR    RETURN              ELSE A REF NAME DELIMITER\nGTSYM02  DS    0H\n         CLI   0(R1),C' '          A BLANK DELIM .Q\n         BER   RETURN\n         CLI   0(R1),C'='          AN EQUAL DELIM .Q\n         BER   RETURN\n         CLI   0(R1),C'+'          A PLUS DELIM .Q\n         BER   RETURN\n         CLI   0(R1),C'-'          A MINUS DELIM .Q\n         BER   RETURN\n         CLI   0(R1),C'*'          A STAR DELIM .Q\n         BER   RETURN\n         CLI   0(R1),C'/'          A SLASH DELIM .Q\n         BER   RETURN\n         CLI   0(R1),C'.'          A DOT DELIM .Q\n         BER   RETURN\n         CLI   0(R1),C''''         A QUOTE DELIM .Q\n         BER   RETURN\n         CLI   0(R1),C'&&'         AN AMPERSAND DELIM .Q\n         BER   RETURN\n         CLI   0(R1),C')'          A RIGHT PAREN DELIM .Q\n         BER   RETURN\n         CLI   0(R1),C'('          A LEFT PAREN DELIM .Q\n         BER   RETURN\nGTSYM03  DS    0H\n         LA    R1,1(,R1)           NEXT CHAR POINTER\n         B     GTSYM01             SCAN IT NEXT\n         SPACE\nGTSYM04  DS    0H\n         ST    R1,ARGSTART         SET START FOR NEXT ITEM\n         LR    TEMP,R1             END PLUS ONE OF RESULT\n         SR    TEMP,COUNT          LESS INITIAL CHARACTER\n         S     TEMP,F1             LENGTH-1 OF RESULT\n         BM    GTSYM20             NULL IF 1ST CHAR IS SPECIAL\n         LA    R0,L'RNSYM-1        MAX LENGTH-1 OF REFERENCE SYMBOL\n         CR    TEMP,R0             COMPARE WITH ACTUAL\n         BNH   GTSYM05             BRANCH IF OK\n         MVI   SRNMFLG,SRNMTSYM    SET SYMBOL ERROR FLAG\n         B     GTSYM19             AND SET CC AND RETURN\nGTSYM05  DS    0H\n         EX    TEMP,GETSYMVC       MOVE IN SEARCH NAME\n        $IFON  SWITCHS,NUPSWS,GTSYM06   BRANCH IF NO UPPER CASE\n         OC    SRNM,BLANKS         UPPER CASE REFERENCE NAMES\nGTSYM06  DS    0H\n         CLI   0(R1),C'('          SUBSCRIPTED ITEM .Q\n         BE    GTSYM07             BRANCH IF YES\n        $CC    POS                 SET CC BPOS FOR SUCCESS\n         B     GTSYM21             AND GO TO RETURN\n         SPACE\nGTSYM07  DS    0H\n         LA    R1,1(,R1)           BUMP OVER LEFT PAREN\n         CLI   0(R1),C')'          NULL SUBSCRIPT .Q\n         BE    GTSYM11             BRANCH IF YES\n         CLC   =C'*)',0(R1)        ALL SUBSCRIPT .Q\n         BE    GTSYM10             BRANCH IF YES\n         CLC   =C'*+)',0(R1)       ALL PLUS SUBSCRIPT .Q\n         BE    GTSYM08             BRANCH IF YES\n         CLC   =C'*-)',0(R1)       ALL MINUS SUBSCRIPT .Q\n         BNE   GTSYM12             BRANCH OUT IF NOT\n         OI    SRNMFLG,SRNMALLN    SET NEGATIVE SWITCH\n         B     GTSYM09             GO BUMP PTRS\nGTSYM08  DS    0H\n         OI    SRNMFLG,SRNMALLP    SET POSITIVE SWITCH\nGTSYM09  DS    0H\n         LA    R1,1(,R1)           BUMP POINTER ONE\n         LA    TEMP,1(,TEMP)       AND LENGTH-1 BY ONE\nGTSYM10  DS    0H\n         LA    R1,1(,R1)           BUMP POINTER BY ONE\n         LA    TEMP,1(,TEMP)       AND LENGTH-1 BY ONE\nGTSYM11  DS    0H\n         LA    R1,1(,R1)           BUMP OVER ')'\n         LA    TEMP,2(,TEMP)       BUMP TO LENGTH-1 OF STRING\n         ST    R1,ARGSTART         SET START FOR NEXT TIME\n         OI    SRNMFLG,SRNMALL     SET ALL FLAG\n        $CC    NEG                 SET CC BNEG\n         B     GTSYM21             AND RETURN\n         SPACE\nGTSYM12  DS    0H\n         BAL   RETURN,GTSYMSS      GET SUBSCRIPT AND/OR SUBSTRING\n         CLI   SRNMFLG,X'00'       ANY ERRORS .Q\n         BNE   GTSYM19             BRANCH IF YES\n         L     TEMP,ARGSTART       CONTINUE SCAN FROM HERE\n         SR    TEMP,COUNT          LESS START POSITION\n         BCTR  TEMP,0              GIVES LENGTH-1 OF RESULT\n        $CC    NEG                 SET CC TO BNEG FOR SUBSCRIPT\n         B     GTSYM21             GO TO RETURN\n         SPACE\nGTSYM19  DS    0H\n        $CC    DNO                 RETURN ERROR COND CODE\n         B     GTSYM21             BRANCH TO RETURN\n         SPACE\nGTSYM20  DS    0H\n        $CC    OMIT                SET CC BOMIT FOR DON'T KNOW\nGTSYM21  DS    0H\n        $RESTOR KEEP=(COUNT,TEMP)  RESTORE CALLER'S REGS\n         BR    RETURN              RETURN TO CALLER\n         SPACE\nGETSYMVC MVC   SRNM(*-*),0(COUNT)  COPIES SEARCH ARGUMENT\n         SPACE\n         LTORG\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              GTSYMSS  ---  SCAN SUBSCRIPT AND/OR SUBSTRING          *\n*                                                                     *\n***********************************************************************\n         SPACE\nGTSYMSS  DS    0H\n        $SAVE  ,                   SAVE CALLER'S REGISTERS\n         BAL   RETURN,GTSYMNUM     GET FIRST NUMBER\n         BC    BOMIT+BDNO,GTSSE01  BRANCH IF INVALID\n         B     *+4(R15)            BRANCH ON DELIMITER\n         B     GTSSE01                  ERROR IF UNKNOWN\n         B     GTSS01                   BRANCH TO SUBSCRIPT IF COMMA\n         B     GTSS03                   BRANCH TO SUBSTRING IF COLON\n         B     GTSS03                   BRANCH TO SUBSTRING IF OR BAR\n         B     GTSS01                   BRANCH TO SUBSCRIPT IF ')'\n         SPACE\nGTSS01   DS    0H\n         LPR   COUNT,COUNT         POSITIVE SUBSCRIPT VALUE\n         C     COUNT,F32767        TOO BIG .Q\n         BH    GTSSE01             BRANCH IF YES\n         STH   COUNT,SRNMSUB       ENTER SUBSCRIPT VALUE\n         B     *+4(R15)            BRANCH ON DELIMITER\n         DC    AL4(0)                   QUIT IF UNKNOWN\n         B     GTSS02                   BRANCH IF COMMA\n         DC    AL4(0)                   QUIT IF COLON\n         DC    AL4(0)                   QUIT IF OR BAR\n         B     GTSS99                   END OF RIGHT PAREN\n         SPACE\nGTSS02   DS    0H\n         BAL   RETURN,GTSYMNUM     GET SECOND NUMBER\n         BC    BOMIT+BDNO,GTSSE02  BRANCH IF INVALID\n         B     *+4(R15)            BRANCH ON DELIMITER\n         B     GTSSE02                  ERROR IF UNKNOWN\n         B     GTSSE02                  ERROR IF COMMA AGAIN\n         B     GTSS03                   COLON, SET FIRST SUBSTR\n         B     GTSS03                   OR BAR, SET FIRST SUBSTR\n         B     GTSSE02                  RIGHT PAREN, BAD SYNTAX\n         SPACE\nGTSS03   DS    0H\n         CH    COUNT,SRNMFR+L'SRNMFR    FIRST SUBSTR TOO SMALL .Q\n         BL    GTSSE02             ERROR IF YES\n         CH    COUNT,SRNMTO+L'SRNMTO    FIRST SUBSTR TOO BIG .Q\n         BH    GTSSE02             ERROR IF YES\n         STH   COUNT,SRNMFR        SET FIRST SUBSTRING\n         B     *+4(R15)            BRANCH ON DELIMITER\n         DC    AL4(0)                   QUIT IF UNKNOWN\n         DC    AL4(0)                   QUIT IF COMMA\n         B     GTSS05                   COLON, GET SECOND SUBSTR\n         B     GTSS04                   OR BAR, GET SECOND SUBSTR LEN\n         DC    AL4(0)                   QUIT IF RIGHT PAREN\n         SPACE\nGTSS04   DS    0H\n         BAL   RETURN,GTSYMNUM     GET SECOND SUBSTRING LENGTH\n         LH    R1,SRNMFR           THE FROM VALUE\n         LA    COUNT,0(R1,COUNT)   ADD LENGTH GIVING TO VALUE\n         BCTR  COUNT,0             LESS ONE\n         B     GTSS06              CONTINUE CHECK\n         SPACE\nGTSS05   DS    0H\n         BAL   RETURN,GTSYMNUM     GET SECOND SUBSTRING VALUE\nGTSS06   DS    0H\n         BC    BDNO,GTSSE03        BRANCH IF INVALID\n         B     *+4(R15)            BRANCH ON DELIMITER\n         B     GTSSE03                  BRANCH IF OTHER\n         B     GTSSE03                  BRANCH IF COMMA\n         B     GTSSE03                  BRANCH IF COLON AGAIN\n         B     GTSSE03                  BRANCH IF OR BAR AGAIN\n         B     GTSS07                   BRANCH IF RIGHT PAREN\n         SPACE\nGTSS07   DS    0H\n         BC    BOMIT,GTSS99        BRANCH IF SECOND SUBSTR NULL\n         CH    COUNT,SRNMFR+L'SRNMFR    SECOND SUBSTR TOO SMALL .Q\n         BL    GTSSE03             ERROR IF YES\n         CH    COUNT,SRNMTO+L'SRNMTO    SECOND SUBSTR TOO BIG .Q\n         BH    GTSSE03             ERROR IF YES\n         STH   COUNT,SRNMTO        SET SUBSTRING TWO VALUE\n         B     GTSS99              AND GO TO TERMINATE\n         SPACE\nGTSSE01  DS    0H\n         OI    SRNMFLG,SRNMTSUB    SUBSCRIPT ERROR\n         B     GTSS99              AND GO TO TERMINATE\nGTSSE02  DS    0H\n         OI    SRNMFLG,SRNMTFR     FROM SUBSTRING ERROR\n         B     GTSS99              AND GO TO TERMINATE\nGTSSE03  DS    0H\n         OI    SRNMFLG,SRNMTTO     TO SUBSTRING ERROR\n         B     GTSS99              AND GO TO TERMINATE\n         SPACE\nGTSS99   DS    0H\n         L     R1,ARGSTART         ADDRESS OF LAST DELIMITER\n         LA    R1,1(,R1)           PLUS ONE\n         ST    R1,ARGSTART         CONTINUE SCAN FROM THERE\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              AND RETURN TO CALLER\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              GETSYMNUM  ---  SCAN EXPRESSION AND DELIMITER          *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY -- ARGSTART -> VERIFIED DELIMITER\n*                    ARGSTOP  -> END OF STRING\n*\n*        ON EXIT  -- ARGSTART -> NEXT DELIMITER\n*                    R15 = 0  IF OTHER DELIMITER\n*                    R15 = 4  IF COMMA DELIMITER\n*                    R15 = 8  IF COLON DELIMITER\n*                    R15 =12  IF OR BAR DELIMITER\n*                    R15 =16  IF RIGHT PAREN DELIMITER\n*\n*                    CC = BOMIT  IF NOTHING   (COUNT) = 1\n*                    CC = BPOS   IF +VE OR 0  (COUNT) = NUMBER\n*                                             (TEMP)  = LEN-1\n*                    CC = BNEG   IF -VE       (COUNT) = NUMBER\n*                                             (TEMP)  = LEN-1\n*                    CC = BDNO   IF ERROR     (COUNT) = START ADDR\n*                                             (TEMP)  = ERROR NUMBER\n         SPACE\nGTSYMNUM DS    0H\n        $SAVE  ,                   SAVE CALLER'S REGISTERS\n         L     X1,ARGSTART         CURRENT DELIMITER POINTER\n         LA    X1,1(,X1)           START FROM HERE\n         ST    X1,ARGSTART         AND SET SAME\n         LA    X3,0                SET OTHER DELIMITER\n        $CALL  GETNUM              TAKE FIRST FLING FOR DELIM\n         BC    15-BDNO,GTSN02      THIS MUST FAIL\n         L     X2,ARGSTART         THIS IS WHERE WE DIED\n         LA    X3,16               CODE FOR RIGHT PAREN\n         CLI   0(X2),C')'          WAS IT RIGHT PAREN .Q\n         BE    GTSN01              BRANCH IF YES\n         LA    X3,12               CODE FOR OR BAR\n         CLI   0(X2),C'|'          WAS IT OR BAR .Q\n         BE    GTSN01              BRANCH IF YES\n         LA    X3,8                CODE FOR COLON\n         CLI   0(X2),C':'          WAS IT COLON .Q\n         BE    GTSN01              BRANCH IF YES\n         LA    X3,4                CODE FOR COMMA\n         CLI   0(X2),C','          WAS IT COMMA .Q\n         BE    GTSN01              BRANCH IF YES\n         LA    X3,0                ELSE IT'S OTHER\nGTSN01   DS    0H\n         LM    R0,R1,ARGSTART      RETAIN SCAN POINTERS\n         ST    X1,ARGSTART         RESCAN FROM ORIG START\n         BCTR  X2,0                BACKUP END POINTER BEFORE DELIM\n         ST    X2,ARGSTOP          AND SET TO TERMINATE SCAN\n        $CALL  GETNUM              GET RESULT\n         STM   R0,R1,ARGSTART      RESET NEXT SCAN POINTERS\nGTSN02   DS    0H\n         LR    R15,X3              RETURN DELIMITER VALUE\n        $RESTOR KEEP=(COUNT,TEMP,R15)   RESTORE MOST REGS\n         BR    RETURN              AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#GETYESN": {"ttr": 6404, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x9d\\x00\\x9d\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 157, "newlines": 157, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        INTERNAL FUNCTION 'GETYESNO'                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER:   $CALL  GETYESNO                                  *\n*                                                                     *\n*        ON EXIT:       (COUNT) POINTS TO ARGUMENT SCANNED            *\n*                       (TEMP) LENGTH-1 OF ARGUMENT                   *\n*                       YNRESULT   YNCODE OF ENTRY FOUND              *\n*        CC=BOMIT  IF ARG IS OMITTED\n*        CC=BPOS   IF ARG IS AFFIRMATIVE\n*        CC=BNEG   IF ARG IS NEGATIVE\n*        CC=BDNO   IF ARG IS UNDEFINED BY ABOVE (SEE YNRESULT)\n         SPACE\nGETYESNO $ENTER ,\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION PLEASE\n        $CALL  GETARG              GET CONTROL OPERAND\n         BC    BOMIT,GTYN09        BRANCH IF NO OPERAND\n         XC    SAVED0,SAVED0       CLEAR WORK AREA\n         LA    R1,L'GYNTAB-1       MAX LENGTH-1 OF RESULT\n         LR    X1,TEMP             SAVE REAL LENGTH IN X1\n         CR    TEMP,R1             OPERAND TOO LONG .Q\n         BH    GTYN01              YES, SEARCH DOOMED TO FAIL\n         EX    TEMP,GTYNMVC        MOVE OPERAND TO WORK AREA\n         OC    SAVED0,BLANKS       AND CONVERT OPERAND TO UPPER CASE\nGTYN01   DS    0H\n         LA    R1,GYNTAB           POINT TO THE POSSIBILITIES\n         SR    R0,R0               ZERO LENGTH CHECK REGISTER\nGTYN02   DS    0H\n         CLI   L'GYNTAB(R1),YNDNO  AT THE END WITH DON'T KNOW .Q\n         BE    GTYN05              YES, THEN OPERAND NOT FOUND\n         IC    R0,L'GYNTAB+1(,R1)  GET MINIMUM LENGTH-1\n         CR    TEMP,R0             COMPARE ACTUAL LENGTH-1\n         BL    GTYN03              BRANCH IF TOO SHORT\n         EX    TEMP,GTYNCLC        COMPARE THIS ENTRY\n         BE    GTYN04              BRANCH IF FOUND\nGTYN03   DS    0H\n         LA    R1,L'GYNTAB+2(,R1)  POINT TO NEXT ENTRY\n         B     GTYN02              AND TRY AGAIN\nGTYN04   DS    0H\n         CLI   L'GYNTAB(R1),YNPOS  AN AFFIRMATIVE ENTRY .Q\n         BE    GTYN07              BRANCH IF YES\n         CLI   L'GYNTAB(R1),YNNEG  A NEGATIVE ENTRY .Q\n         BE    GTYN08              BRANCH IF YES\n         B     GTYN06              PROCEDE WITH 'NOT KNOWN'\n         SPACE\nGTYN05   DS    0H\n         CLC   SAVED0(2),GYNTABNO  FIRST 2 CHARACTERS = 'NO' .Q\n         BNE   GTYN06              BRANCH IF NO\n         MVC   SAVED0+1(6),SAVED0+2     SHIFT LAST 6 CHARS LEFT\n         MVI   SAVED0+7,C' '       SET LAST CHAR TO BLANK\n         BCTR  TEMP,0              DECREMENT LENGTH BY ONE\n         B     GTYN01              RETRY LIST SEARCH\n         SPACE\nGTYN06   DS    0H                  ARGUMENT NOT KNOWN\n        $CC    DNO                 SET CC BDNO FOR DON'T KNOW\n         B     GTYN10              AND GO BACK\nGTYN07   DS    0H\n        $CC    POS                 SET CC BPOS FOR POSITIVE\n         B     GTYN10              AND GO BACK\nGTYN08   DS    0H\n        $CC    NEG                 SET CC BNEG FOR NEGATIVE\n         B     GTYN10              AND GO BACK\nGTYN09   DS    0H\n         L     COUNT,ARGSTART      RETURN POINTING WHERE YOU WERE\n         SR    X1,X1               ZERO LENGTH REGISTER\n         BCTR  X1,0                MINUS ONE\n         LA    R1,GYNOMIT          OPERAND WAS OMITTED\n        $CC    OMIT                SET CC BOMIT FOR NULL\nGTYN10   DS    0H\n         MVC   YNRESULT,L'GYNTAB(R1)    PASS BACK RESULT CODE\n         LR    TEMP,X1             RESTORE LENGTH IN TEMP\n        $RESTOR KEEP=(COUNT,TEMP)  RESTORE CALLER'S REGS\n         BR    RETURN              AND GO BACK\n         SPACE\nGTYNCLC  CLC   SAVED0(*-*),0(R1)   EXECUTED OPERAND COMPARE\nGTYNMVC  MVC   SAVED0(*-*),0(COUNT)     MOVE OPERAND TO WORK AREA\n         SPACE\nGYNTAB   DC    CL8'YES     ',AL1(YNPOS),X'00'\nGYNTABNO DC    CL8'NO      ',AL1(YNNEG),X'00'\n         DC    CL8'ON      ',AL1(YNPOS),X'01'\n         DC    CL8'OFF     ',AL1(YNNEG),X'01'\n         DC    CL8'BEGIN   ',AL1(YNPOS),X'00'\n         DC    CL8'END     ',AL1(YNNEG),X'00'\n         DC    CL8'SAVE    ',AL1(YNPOS),X'01'\n         DC    CL8'NSAVE   ',AL1(YNNEG),X'02'\n         DC    CL8'STOP    ',AL1(YNNEG),X'01'\n         DC    CL8'QUIT    ',AL1(YNNEG),X'01'\n         DC    CL8'ON/OFF  ',AL1(YNMBE),X'03'\n         DC    CL8'YES/NO  ',AL1(YNMBE),X'04'\n         DC    CL8'DELETE  ',AL1(YNDEL),X'00'\n         DC    CL8'OFFNO   ',AL1(YNOFN),X'03'\n         DC    CL8'SET     ',AL1(YNSET),X'01'\n         DC    CL8'ARABIC  ',AL1(YNARA),X'01'\n         DC    CL8'ROMAN   ',AL1(YNROM),X'01'\n         DC    CL8'INCLUDE ',AL1(YNINC),X'01'\n         DC    CL8'IGNORE  ',AL1(YNIGN),X'01'\n         DC    CL8'ODD     ',AL1(YNODD),X'01'\n         DC    CL8'EVEN    ',AL1(YNEVN),X'01'\n         DC    CL8'TRACEON ',AL1(YNTRON),X'06'\n         DC    CL8'TRACEOFF',AL1(YNTROFF),X'07'\n         DC    CL8'USER    ',AL1(YNUSER),X'02'\n         DC    CL8'ADD     ',AL1(YNADD),X'01'\n         DC    CL8'CHANGE  ',AL1(YNCNG),X'01'\n         DC    CL8'DUMP    ',AL1(YNDUMP),X'01'\n         DC    CL8'PURGE   ',AL1(YNPUR),X'01'\n         DC    CL8'CANCEL  ',AL1(YNPUR),X'02'\n         DC    CL8'LEFT    ',AL1(YNLEFT),X'00'\n         DC    CL8'RIGHT   ',AL1(YNRGHT),X'00'\n         DC    CL8'CENTRE  ',AL1(YNCNTR),X'01'\n         DC    CL8'CENTER  ',AL1(YNCNTR),X'01'\n         DC    CL8'INSIDE  ',AL1(YNISDE),X'02'\n         DC    CL8'OUTSIDE ',AL1(YNOSDE),X'02'\n         DC    CL8'LOWER   ',AL1(YNLOWER),X'02'\n         DC    CL8'TEST    ',AL1(YNTEST),X'03'\n         DC    CL8'PREFIX  ',AL1(YNPREF),X'02'\n         DC    CL8'SUFFIX  ',AL1(YNSUFX),X'02'\n         DC    CL8'SUPPRESS',AL1(YNSUP),X'02'\n         DC    CL8'THRESH  ',AL1(YNTRSH),X'05'\n         DC    CL8'MINPT   ',AL1(YNMNPT),X'04'\n         DC    CL8'ENDPT   ',AL1(YNENDPT),X'04'\n         DC    CL8'HALF    ',AL1(YNHALF),X'01'\n         DC    CL8'AND     ',AL1(YNAND),X'02'\n         DC    CL8'&&      ',AL1(YNAND),X'00'\n         DC    CL8'OR      ',AL1(YNOR),X'01'\n         DC    CL8'|       ',AL1(YNOR),X'00'\n         DC    CL8'*       ',AL1(YNASTK),X'00'\n         DC    CL8'ABS     ',AL1(YNABS),X'00'\n         DC    CL8'COND    ',AL1(YNCND),X'00'\n         DC    CL8'FRAC    ',AL1(YNFRAC),X'03'\n         DC    CL8'HJOIN   ',AL1(YNHJ),X'01'\n         DC    CL8'NHJOIN  ',AL1(YNNOHJ),X'02'\n         DC    CL8'NORMAL  ',AL1(YNNORM),X'03'\n         DC    CL8'SKBF    ',AL1(YNSKBF),X'01'\n         DC    CL8'SPAF    ',AL1(YNSPAF),X'01'\n         DC    CL8'TCINDENT',AL1(YNTCIN),X'02'\n         DC    CL8'TCOFFSET',AL1(YNTCOF),X'02'\n         DC    CL8'TONLY   ',AL1(YNTO),X'01'\n         DC    CL8'NTONLY  ',AL1(YNNOTO),X'02'\n         DC    CL8'TC      ',AL1(YNTC),X'01'\n         DC    CL8'NTC     ',AL1(YNNOTC),X'02'\n         DC    CL8'TSPACE  ',AL1(YNTSP),X'01'\n         DC    CL8'NTSPACE ',AL1(YNNOTSP),X'02'\n         DC    CL8'US      ',AL1(YNUS),X'01'\n         DC    CL8'NUS     ',AL1(YNNOUS),X'02'\n         DC    CL8'UPPER   ',AL1(YNUP),X'01'\n         DC    CL8'NUPPER  ',AL1(YNNOUP),X'02'\n         DC    CL8'OJUST   ',AL1(YNOJ),X'01'\n         DC    CL8'NOJUST  ',AL1(YNNOOJ),X'02'\n         DC    CL8'PAGE    ',AL1(YNPA),X'01'\n         DC    CL8'NPAGE   ',AL1(YNNOPA),X'02'\n         DC    CL8'BREAK   ',AL1(YNBREAK),X'01'\n         DC    CL8'NBREAK  ',AL1(YNNOBRK),X'02'\nGYNOMIT  DC    CL8'        ',AL1(YNOMIT),X'07'\n         DC    CL8'        ',AL1(YNDNO),X'07'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#GO": {"ttr": 6408, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00g\\x00g\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 103, "newlines": 103, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .GO GOTO --- CONTROL                                   *\n*                                                                     *\n***********************************************************************\n         SPACE\nGO      $ENTER ,\n         MVC   LBWRK,BLANKS        CLEAR OPERAND\n         MVC   COMAGO,BLANKS       CLEAR CURRENT RECORD IDENTIFICATION\n        $CALL  GETNUM              GET NUMERIC OPERAND\n         BC    BOMIT,GOE01         BRANCH IF OMITTED\n         BC    BDNO,GO02           BRANCH IF INVALID\n         CLI   NUMSIGN,C' '        UNARY SIGNED OPERAND .Q\n         BE    GO01                BRANCH IF NOT\n         A     COUNT,COMFILIT      ADJUST GO STMT NUMBER ACCORDINGLY\nGO01     DS    0H\n         LTR   COUNT,COUNT         TOO SMALL .Q\n         BNP   GOE04               BRANCH IF YES\n         C     COUNT,F32767        TOO BIG .Q\n         BH    GOE03               BRANCH IF YES\n         XC    LBWRK,LBWRK         CLEAR TARGET\n         ST    COUNT,LBWRK+4       SET OPERAND\n         C     COUNT,COMFILIT      FORWARD BRANCH .Q\n         BNH   GO05                BRANCH TO GOTO APPEND\n         B     GO08                GO TO RETURN\n         SPACE\nGO02     DS    0H\n         ST    COUNT,ARGSTART      RESCAN FOR IDENTIFIER\n        $CALL  GETARG              GET IDENTIFIER\n         LA    R0,L'LBNAME-1       MAX-1 LENGTH ALLOWED\n         CR    TEMP,R0             TOO LONG .Q\n         BH    GOE02               YES, INVALID LABEL\n         EX    TEMP,GOMVCI         ENTER THE IDENTIFIER\n         SPACE\n         LA    X1,LBANCH-LBCHN+LBDSECT  GET LABEL ANCHOR POINTER\nGO03     DS    0H\n         USING LBDSECT,X1          TELL THE ASSEMBLER\n         L     X1,LBCHN            NEXT LABEL IN CHAIN\n         LTR   X1,X1               AT THE END .Q\n         BZ    GO08                BRANCH OUT IF YES\n         CLC   LBWRK,LBNAME        FOUND IT .Q\n         BH    GO08                BRANCH OUT IF HIGH\n         BE    GO04                CHECK MORE IF EQUAL\n         B     GO03                AND TRY AGAIN\nGO04     DS    0H\n         CLC   LBFILIT,COMFILIT    FORWARD BRANCH .Q\n         BH    GO08                BRANCH IF YES\n         SPACE\nGO05     DS    0H\n         L     X2,LBANCH           SAVE LABEL ANCHOR\n         XC    LBANCH,LBANCH       CLEAR SAME FOR APPEND\n         XC    APIMFLAG,APIMFLAG   CLEAR FILE FLAGS\n        $ON    APIMFLAG,IO$AP      SET APPEND FLAG\n         MVC   APIMNAME,COMFILNM   SET FILE NAME\n         MVC   APIMMEMB,COMMEMNM   AND MEMBER NAME\n         CLC   LBWRK(4),F0         GOTO RECORD NUMBER .Q\n         BE    GO06                BRANCH IF YES\n         MVC   APIMMIN,LBFILIT     SET RECORD NUMBER OF IDENTIFIER\n         MVC   APIMGOTO,LBWRK      SET GOTO TARGET\n         B     GO07                AND CONTINUE\nGO06     DS    0H\n         MVC   APIMMIN,LBWRK+4     SET ABSOLUTE RECORD NUMBER\n         MVC   APIMGOTO,BLANKS     NO LABEL TO GOTO\n         XC    IFSTAK,IFSTAK       CLEAR IF STACK\nGO07     DS    0H\n         MVC   APIMMAX,F16MEG      DEFAULT MAX RECORD NUMBER\n         LA    R1,APIMBLOK         NECESSARY INFORMATION\n        $CALL  RDREWIND            REWIND CURRENT INPUT FILE\n         ST    X2,LBANCH           RESTORE LABEL ANCHOR\n         LTR   R15,R15             SUCCESSFUL .Q\n         BNZ   GOE05               BRANCH IF NOT\n         B     GO08                GO TO EXIT\n         DROP  X1\n         SPACE\nGO08     DS    0H\n         MVC   LBGOTO,LBWRK        ENTER GOTO OPERAND\n         CLC   LBGOTO,BLANKS       TARGET SPECIFIED .Q\n         BE    GO09                BRANCH IF NOT\n         XC    IFSTAK,IFSTAK       CLEAR ENTIRE .IF STACK\n         MVC   COMAGO,COMAREA      SOURCE OF .GO COMMAND\nGO09     DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\nGOMVCI   MVC   LBWRK(*-*),0(COUNT) MOVE OPERAND LABEL\n         SPACE\nGOE01    DS    0H\n         MVI   EFLAG003,ERRSET     OMITTED GOTO OPERAND\n         B     GOE99               GO TO CLEAR\nGOE02    DS    0H\n         MVI   EFLAG005,ERRSET     OPERAND TOO LONG\n         B     GOE99               GO TO CLEAR\nGOE03    DS    0H\n         MVI   EFLAG013,ERRSET     OPERAND TOO BIG\n         B     GOE99               GO TO CLEAR\nGOE04    DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     GOE99               GO TO CLEAR\nGOE05    DS    0H\n         MVI   EFLAG027,ERRSET     REWIND OF FILE FAILED\n         B     GOE99               GO TO CLEAR\nGOE99    DS    0H\n         MVC   LBWRK,BLANKS        CLEAR GOTO OPERAND\n         B     GO08                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#HD": {"ttr": 6411, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x11\\x00\\x11\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .HD (ODD PAGE HEADING) --- CONTROL                     *\n*              .OT (ODD TOP TITLE) --- CONTROL                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nOT      $ENTER ,\n        $ON    SWITCHS,FNOCASE     UPPER CASE FLAG FOR ALTERNATE FORMAT\n        $CALL  HD                  LET HIM DO THE WORK\n        $EXIT  RC=0                NEXT INPUT LINE\n         SPACE\nHD      $ENTER ,\n         L     X1,ADODHEAD         PUT DATA IN ODD HEAD AREA\n        $CALL  HEADSAVE            ..\n        $OFF   SWITCHS,FNOCASE     RESET FORMAT FLAG\n        $EXIT  RC=0                NEXT INPUT LINE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#HE": {"ttr": 6413, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x17\\x00\\x17\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .HE (HEADER) --- CONTROL                               *\n*              .TT (TOP TITLE) --- CONTROL                            *\n*                                                                     *\n***********************************************************************\n         SPACE\nTT      $ENTER ,\n        $ON    SWITCHS,FNOCASE     UPPER CASE FLAG FOR ALTERNATE FORMAT\n        $CALL  HE                  LET HIM DO THE WORK\n        $EXIT  RC=0                NEXT INPUT LINE\n         SPACE\nHE      $ENTER ,\n         L     COUNT,ARGSTART      REMEMBER ARGUMENT START ADDR\n         L     X1,ADEVHEAD         PUT OPERAND IN EVEN AREA\n        $CALL  HEADSAVE            SCAN OPERAND\n         BC    BDNO,HE01           BRANCH IF ERROR\n         ST    COUNT,ARGSTART      DO IT AGAIN FOR ODD\n         L     X1,ADODHEAD         PUT OPERAND IN ODD AREA\n        $CALL  HEADSAVE            SCAN OPERAND SECOND TIME\nHE01     DS    0H\n        $OFF   SWITCHS,FNOCASE     RESET FORMAT FLAG\n        $EXIT  RC=0                NEXT INPUT LINE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#HEADCLR": {"ttr": 6415, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00U\\x00U\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 85, "newlines": 85, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        INTERNAL FUNCTION 'HEADCLR'  --- INITIALIZE HEADING/FOOTING  *\n*                                                                     *\n***********************************************************************\n         SPACE\nHEADCLR $ENTER ,\n         L     TEMP,ADEVHEAD       CLEAR EVEN TITLES\n         BAL   RETURN,HDCLR        DO THEM ALL\n         L     TEMP,ADODHEAD       CLEAR ODD TITLES\n         BAL   RETURN,HDCLR        DO THEM ALL\n         L     TEMP,AFTHEAD        CLEAR FOOTNOTE SEPARATOR\n         BAL   RETURN,HDCLR        DO THEM ALL TOO\n         SPACE\n        $ON    SWITCHS,FNOCASE     SWITCH FOR HEADSAVE\n         MVC   PSYMBOL(1),PSYMBOL+1     WORKING PAGE SYMBOL CHARACTER\n         L     X3,WRKBUFFA         POINT TO TITLE BUFFER\n         MVC   0(L'WRKBUFF,X3),BLANKS   CLEAR TEMP BUFFER\n         MVC   0(L'HDCTT,X3),HDCTT ENTER DEFAULT TOP TITLE OPERAND\n         ST    X3,ARGSTART         ENTER START ADDRESS\n         LA    R1,L'HDCTT(,X3)     ARGUMENT ENDS HERE\n         ST    R1,ARGSTOP          ENTER STOP ADDRESS\n         L     X1,ADEVHEAD         ENTER EVEN HEAD ADDRESS\n        $ON    SWITCHS,DTTSWS      DEFAULT TOP TITLE BEING SET\n        $CALL  HEADSAVE            SCAN ARGUMENT\n         ST    X3,ARGSTART         REENTER START ADDRESS\n         L     X1,ADODHEAD         ENTER ODD HEAD ADDRESS\n        $ON    SWITCHS,DTTSWS      DEFAULT TOP TITLE BEING SET\n        $CALL  HEADSAVE            SCAN ARGUMENT\n         SPACE\n         LA    R1,1                DEFAULT HS/FS VALUE\n         STH   R1,HSCNT            SET HEADING SPACE\n         STH   R1,FSCNT            SET FOOTING SPACE\n         LA    R1,3                INITIAL FOOTNOTE TITLE DEPTH\n         STH   R1,FTCNT            FOOTNOTE TITLE COUNT\n         SPACE\n         MVC   0(L'WRKBUFF,X3),BLANKS   CLEAR TEMP BUFFER\n         MVC   0(L'FNCTT1,X3),FNCTT1    ENTER START OF FOOTNOTE TITLE\n         L     R1,DEFLL+TAB3DEF    LINE LENGTH\n         SR    R0,R0               PREPARE FOR DIVIDE\n         D     R0,F3               THIRD OF LINE LENGTH\n         MVC   L'FNCTT1(1,X3),FNDASH    SET DIVIDING CHARACTER\n         BCTR  R1,0                LENGTH-1\n         EX    R1,HDCFNMV          ENTER THE REST\n         LA    R1,L'FNCTT1+1(R1,X3)     STRING END ADDRESS\n         MVC   0(L'FNCTT2,R1),FNCTT2    ENTER STRING TERMINATOR\n         LA    R1,L'FNCTT2(,R1)         NEW STRING END\n         ST    R1,ARGSTOP          ENTER END ADDRESS\n         ST    X3,ARGSTART         ENTER START ADDRESS\n         L     X1,AFTHEAD          FOOTNOTE TITLE AREA\n        $CALL  HEADSAVE            ENTER FOOTNOTE SEPARATOR LINE\n         SPACE\n        $OFF   SWITCHS,FNOCASE     RESET HEADSAVE SWITCH\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nHDCFNMV  MVC   L'FNCTT1+1(*-*,X3),L'FNCTT1(X3)  MOVE DASH ACROSS\n         SPACE\nHDCTT    DC        C'///PAGE %/'   DEFAULT TOP TITLE\nFNCTT1   DC        C'2 //'         START OF FOOTNOTE SEPARATOR\nFNCTT2   DC        C'//'           AND TERMINATOR\nFNDASH   DC        C'-'            FOOTNOTE SEPARATOR CHARACTER\n         SPACE\nHDCLR   $SAVE  ,                   SAVE CALLER'S REGISTERS\n         LA    COUNT,HSFSCT        ELEMENT COUNT IN VECTOR\nHDC01    DS    0H\n         L     X1,0(,TEMP)         GET NEXT TITLE\n         LTR   X1,X1               ANY TITLE PRESENT .Q\n         BZ    HDC03               BRANCH IF NONE\n         SR    R1,R1               INITIALIZE TOTAL LENGTH\n         LA    X2,3                TITLE IN THREE PARTS\nHDC02    DS    0H\n         SR    X3,X3               ZERO LENGTH ARG\n         IC    X3,1(R1,X1)         SEGMENT LENGTH\n         LA    R1,2(X3,R1)         NEW TOTAL LENGTH\n         BCT   X2,HDC02            DO ALL SEGMENTS\n         LR    R0,X1               POINT TO STRING\n         LA    R1,246                  *TEMP*    LENGTH OF STRING\n        $CALL  FREECELL            RELEASE THE AREA\nHDC03    DS    0H\n         SR    X1,X1               ZERO WORK POINTER\n         ST    X1,0(,TEMP)         CLEAR POINTER\n         LA    TEMP,L'EVNHEAD(,TEMP)    POINT TO NEXT\n         BCT   COUNT,HDC01         DO ALL ELEMENTS\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#HEADPRT": {"ttr": 6418, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x80\\x00\\x80\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 128, "newlines": 128, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        INTERNAL FUNCTION 'HEADPRT' --- PRINT HEADING OR FOOTING     *\n*        INFORMATION                                                  *\n*              ON ENTRY -- (X1) -> THREE HEADING/FOOTING POINTER      *\n*                       -- (RETURN) -> RETURN ADDRESS                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nHEADPRT $ENTER ,\n         LH    COUNT,PLCT          ACCOUNT FOR HEADER LINE\n         BCTR  COUNT,0             ..\n         STH   COUNT,PLCT          ..\n         SPACE\n         L     X3,WRKBUFFA         HEADING/FOOTING WORK BUFFER ADDR\n         MVC   0(L'WRKBUFF,X3),BLANKS   CLEAR BUFFER\n         LA    COUNT,2             LEAD BLANK AND DATA FOR EMPTY HEADER\n         LA    X2,3                SET FOR THREE HEADERS\n         SR    R0,R0               ZERO WORK REGISTER\n         STH   R0,HPBKCNT          ZERO GLOBAL BACKSPACE COUNT\n         L     X1,0(,X1)           POINT TO HEADING DATA\n         LTR   X1,X1               EMPTY .Q\n         BZ    HP11                BRANCH IF YES\n         BNM   HP01                BRANCH IF NOT DEFAULT TITLE\n        $IFON  SWITCHS,AFIRST,HP11 BRANCH IF REAL FIRST PAGE\n        $IFON  SWITCHS,PAGOFF,HP11 BRANCH IF EXTERNAL NUMBERING OFF\nHP01     DS    0H\n         LA    X1,0(,X1)           CLEAR HIGH BYTE\n         SPACE\nHP02     DS    0H\n         L     R1,HDTEMPAD         INITIALIZE TEMPORARY BUFFER PTR\n         SR    X3,X3               INITIALIZE LENGTH REGISTER\n         IC    X3,1(,X1)           GET LENGTH OF SEGMENT\n         LTR   X3,X3               EMPTY STRING .Q\n         BZ    HP10                IF SO, DON'T PLAY WITH IT\n         LA    TEMP,2(,X1)         ADDRESS OF FIRST TEXT CHAR\n         SR    R0,R0               ZERO WORK REGISTER\n         STH   R0,HPBKCNT+2        ZERO LOCAL BACKSPACE COUNT\n         SPACE\nHP03     DS    0H\n         CLC   0(1,TEMP),PSYMBOL   PAGE NUMBER ESCAPE .Q\n         BE    HP05                IF YES, SKIP\n         MVC   0(1,R1),0(TEMP)     NO, COPY TEXT TO BUFFER\n         LA    R1,1(,R1)           NEXT BUFFER CHARACTER\n         CLI   0(TEMP),X'16'       BACKSPACE IN HEADING .Q\n         BNE   HP04                BRANCH IF NOT\n         LH    R0,HPBKCNT          CURRENT GLOBAL BACKSPACE COUNT\n         A     R0,F2               BUMP BY TWO CHARACTERS\n         STH   R0,HPBKCNT          UPDATE GLOBAL BACKSPACE COUNT\n         LH    R0,HPBKCNT+2        CURRENT LOCAL BACKSPACE COUNT\n         A     R0,F2               BUMP BY TWO CHARACTERS\n         STH   R0,HPBKCNT+2        UPDATE LOCAL BACKSPACE COUNT\n         SPACE\nHP04     DS    0H\n         LA    TEMP,1(,TEMP)       NEXT TEXT CHARACTER\n         BCT   X3,HP03             LOOP THROUGH TEXT\n         B     HP06                DONE. GO PUT IN PRINT BUFFER\n         SPACE\nHP05     DS    0H\n        $IFON  SWITCHS,PAGOFF,HP04 DROP CHAR IF NO EXTERNAL PAGE NUMB\n        $CALL  PNUMFMT             FORMAT CURRENT PAGE NUMBER\n         EX    COUNT,HPMVCPG       INSERT PAGE NUMBER\n         LA    R1,1(COUNT,R1)      BUMP BUFFER POINTER\n         B     HP04                CONTINUE COPY\n         SPACE\nHP06     DS    0H\n         L     TEMP,HDTEMPAD       REINITIALIZE TEMPORARY BUFFER PTR\n         SR    R1,TEMP             LENGTH OF TEXT\n         LR    X3,X2               DO SPECIALIZED MOVING\n         SLL   X3,2                ..\n         B     *(X3)               ..\n         B     HP08                1 => RIGHT ADJUST\n         B     HP07                2 => CENTER\n         SR    R0,R0               3 => LEFT ADJUST\n         B     HP09                ENTER DATA WITH ZERO OFFSET\n         SPACE\nHP07     DS    0H\n         L     R0,LLZ              GET LINE LENGTH\n         SR    R0,R1               COMPUTE REMAINDER OVER ITEM\n         AH    R0,HPBKCNT+2        PLUS LOCAL BACKSPACE COUNT\n         SRA   R0,1                ONE HALF IS SHIFT AMOUNT\n         AH    R0,HPBKCNT          PLUS GLOBAL BACKSPACE COUNT\n         SH    R0,HPBKCNT+2        LESS LOCAL BACKSPACE COUNT\n         B     HP09                ENTER THE DATA\n         SPACE\nHP08     DS    0H\n         L     R0,LLZ              GET LINE LENGTH\n         SR    R0,R1               TEXT OFFSET\n         AH    R0,HPBKCNT          PLUS GLOBAL BACKSPACE COUNT\n         SPACE\nHP09     DS    0H\n         L     X3,WRKBUFFA         HEADING/FOOTING WORK BUFFER ADDR\n         LA    X3,1(,X3)           LEAVE A LEADING BLANK\n         AR    X3,R0               COMPUTE WITH OFFSET\n         S     R1,F1               SS-TYPE COUNT\n         BM    HP10                BRANCH IF NOTHING LEFT\n         EX    R1,HPMVC            COPY TEXT IN\n         LR    COUNT,R0            SAVE FOR LINKPUT\n         LA    COUNT,2(COUNT,R1)   OFFSET+LEN-1+2=TLEN+1\n         SPACE\nHP10     DS    0H\n         SR    X3,X3               INITIALIZE LENGTH REGISTER\n         IC    X3,1(,X1)           GET LENGTH OF SEGMENT\n         LA    X1,2(X3,X1)         UPDATE DATA TABLE ADDRESS\n         BCT   X2,HP02             DO ALL THREE SEGMENTS\n         SPACE\nHP11     DS    0H\n         MVC   HDPTRSAV,FMTOLD1    SAVE LINK PTRS/LOCAL SWITCHES\n        $OFF   SWITCHS,JUADSWS     DISABLE JUSTIFICATION\n        $ON    SWITCHS,OOSWS       DISABLE OUTPUT OVERLAY\n         ST    COUNT,NOCHARS       SETUP AND CALL LINKPUT\n         L     R0,WRKBUFFA         RECORD POINTER\n         ST    R0,OUTPARM          IN COMMON AREA\n         XC    OLDFIRST(PARMPUT-OLDFIRST),OLDFIRST  NO OLD DATA\n         LA    R1,OUTPARM          COMMON DATA AREA\n        $CALL  LKPUT               BUILD CHARACTER BLOCKS\n         L     COUNT,NOCHARS       CURRENT CHAR COUNT\n         BCTR  COUNT,0             LESS ONE\n         ST    COUNT,NOCHARS       UPDATE\n        $ON    SWITCHS,HDPSWS      PRINT HEADING/FOOTING ENTRY\n        $CALL  PRINT               PRINT THE LINKS\n        $OFF   SWITCHS,HDPSWS      ALL THROUGH\n        $MVC   FMTOLD1,HDPTRSAV    RESTORE LINK PTRS/LOCAL SWITCHES\n        $RESTOR ,                  RESTORE CALLER'S REGS\n         BR    RETURN              AND BACK TO CALLER\n         SPACE\nHPMVCPG  MVC   0(*-*,R1),EBCDPAGE  INSERTS PAGE NUMBER\nHPMVC    MVC   0(*-*,X3),0(TEMP)   COPIES ONE SEGMENT OF HEADING DATA\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#HEADSAV": {"ttr": 6659, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x89\\x00\\x89\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 137, "newlines": 137, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTION 'HEADSAVE' --- SAVE                  *\n*              HEADING OR FOOTING INFORMATION                         *\n*                   ON ENTRY -- (X1>0) -> HEADING TARGET AREA         *\n*                               (X1<0) -> FOOTING TARGET AREA         *\n*                            -- FNOCASE OFF IF QUOTES SEPARATE        *\n*                                       ON IF FIRST CHAR SEPARATE     *\n*                            -- DTTSWS  ON IF DEFAULT TITLE BEING SET *\n*                                       OFF IF USER TITLE BEING SET   *\n*                   ON EXIT  -- CC = BPOS IF OK                       *\n*                               CC = BDNO IF ERROR                    *\n*                            -- DTTSWS  SWITCH IS ALWAYS RESET        *\n*                                                                     *\n***********************************************************************\n         SPACE\nHEADSAVE $ENTER ,\n         L     R1,ARGSTART         RETAIN ARGUMENT START ADDR\n        $CALL  GETNUM              GET AND TEXT 1ST ARGUMENT\n         BC    BOMIT+BDNO,HDS02    BRANCH IF INVALID OR OMITTED\n         LTR   COUNT,COUNT         TOO SMALL .Q\n         BP    HDS01               BRANCH IF NOT\n         MVI   EFLAG014,ERRSET     SET TOO SMALL ERROR\n         B     HDS15               AND TAKE ERROR EXIT\nHDS01    DS    0H\n         L     R0,DEFHSFS+TAB3DEF  MAXIMUM VALUE\n         CR    COUNT,R0            TOO BIG .Q\n         BNH   HDS03               BRANCH IF NOT\n         MVI   EFLAG013,ERRSET     SET TOO BIG ERROR\n         B     HDS15               AND TAKE ERROR EXIT\nHDS02    DS    0H\n         ST    R1,ARGSTART         RESCAN FROM BEGINNING\n         LA    COUNT,1             ONE IS DEFAULT VALUE\nHDS03    DS    0H\n         LA    R1,L'EVNHEAD        LENGTH OF ONE TABLE ENTRY\n         BCTR  COUNT,0             DECREMENT FIRST OPND BY ONE\n         LTR   X1,X1               HEADINGS .Q\n         BP    HDS04               BRANCH IF YES\n         L     R0,DEFHSFS+TAB3DEF  MAX WRAP VALUE\n         BCTR  R0,0                MAX WRAP VALUE -1\n         SR    COUNT,R0            NEGATIVE INVERSE\n         LPR   COUNT,COUNT         FOOTING VALUE\n         LPR   X1,X1               REAL STARTING ADDR FOR FOOTINGS\nHDS04    DS    0H\n         MR    R0,COUNT            RESULTING TARGET OFFSET\n         STH   R1,HSFSWRK          PASS THIS BACK\n         AR    X1,R1               RESULTING TARGET ADDR\n         SPACE\n         L     TEMP,0(,X1)         BUFFER WORK ADDRESS\n         LA    TEMP,0(,TEMP)       CLEAR DEFAULT FLAG, IF ANY\n         LTR   TEMP,TEMP           IS AREA DEFINED .Q\n         BNZ   HDS05               BRANCH IF YES\n         LA    R1,246              NEED THIS MUCH SPACE\n        $CALL  GETCELL             GET A WORK BUFFER\n         BC    BPOS,HDS05          BRANCH IF SUCCESSFUL\n         MVI   EFLAG024,ERRSET     NO SPACE AVAILABLE\n         B     HDS15               AND TAKE ERROR EXIT\n         SPACE\nHDS05    DS    0H\n         ST    TEMP,0(,X1)         SET BUFFER WORK ADDRESS\n        $IFOFF SWITCHS,DTTSWS,HDS06     BRANCH IF NOT DEFAULT TITLE\n         OI    0(X1),X'80'         TOP BIT FOR DEFAULTS\n        $OFF   SWITCHS,DTTSWS      RESET DEFAULT COMMUNICATION BIT\nHDS06    DS    0H\n         LR    X1,TEMP             POINT TO WORK BUFFER\n         L     TEMP,ARGSTART       ARGUMENT START ADDRESS\nHDS07    DS    0H\n         CLI   0(TEMP),C' '        LEADING BLANK .Q\n         BNE   HDS08               BRANCH OUT IF NOT\n         LA    TEMP,1(,TEMP)       BUMP ARGUMENT POINTER\n         C     TEMP,ARGSTOP        END OF THE LINE .Q\n         BNH   HDS07               BRANCH IF NOT\nHDS08    DS    0H\n         MVC   BREAKCHR,BREAKCHR+1 DEFAULT BREAK CHARACTER\n        $IFOFF SWITCHS,FNOCASE,HDS09    UPPERCASE IMPLIES .HE FORMAT\n         MVC   BREAKCHR,0(TEMP)    FIRST CHAR IS BREAK CHAR\n         SPACE\nHDS09    DS    0H\n         XC    0(246,X1),0(X1)     RESET LENGTHS AND DATA TO ZERO\n         SPACE\n         L     X3,ARGSTOP          GET BUFFER COUNT\n         LA    X3,1(,X3)           END OF BUFFER ADDRESS +1\n         SR    X3,TEMP             LENGTH OF HEADER TEXT\n         BNP   HDS14               IF NOT, NO HEADERS\n         SPACE\n         CLC   0(1,TEMP),BREAKCHR  ARE WE GETTING 3 ITEMS .Q\n         BE    HDS10               IF YES, SKIP AHEAD\n         SPACE\n         LR    R1,X3               LENGTH OF FIRST AND ONLY SEGMENT\n         BAL   RETURN,HDSSAV       ENTER TEXT SEGMENT\n         B     HDS14               AND RETURN TO CALLER\n         SPACE\nHDS10    DS    0H\n         LA    X2,3                COUNT OF STRINGS TO RETRIEVE\n         SPACE\nHDS11    DS    0H\n         LA    TEMP,1(,TEMP)       SKIP STARTING BREAK CHARACTER\n         LR    COUNT,TEMP          PRIME THE LOOP\n         SPACE\nHDS12    DS    0H\n         LTR   X3,X3               IS COUNT DOWN TO ZERO .Q\n         BNP   HDS14               IF SO, DONE\n         CLC   0(1,COUNT),BREAKCHR A BREAK CHARACTER .Q\n         BE    HDS13               IF YES, COMPLETE STRING FOUND\n         LA    COUNT,1(,COUNT)     NO, LOOK AT NEXT CHARACTER\n         BCT   X3,HDS12            (BUT DON'T EXCEED BUFFER)\n         BCTR  COUNT,0             RESET END PTR TO STRING END\n         LA    X2,1                MAKE SURE LOOP STOPS\n         SPACE\nHDS13    DS    0H\n         LR    R1,COUNT            CHARACTER AFTER STRING END\n         SR    R1,TEMP             STRING LENGTH\n         BCTR  X3,0                ACCOUNT FOR QUOTE\n         BAL   RETURN,HDSSAV       ENTER TEXT SEGMENT\n         LR    TEMP,COUNT          WHERE TO RESUME SCAN\n         BCT   X2,HDS11            LOOP THROUGH 3 ITEMS\n         SPACE\nHDS14    DS    0H\n        $CC    POS                 SET OK EXIT\n         B     HDS16               BRANCH TO RESTORE\nHDS15    DS    0H\n        $CC    DNO                 SET ERROR EXIT\nHDS16    DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGS\n         BR    RETURN              RETURN TO CALLER\n         SPACE\nHDSSAV   DS    0H\n         STC   R1,1(,X1)           SET LENGTH OF SEGMENT\n         S     R1,F1               LENGTH-1 FOR MVC\n         BM    HDSSAV01            BRANCH IF EMPTY\n         EX    R1,HDSMVC           COPY STRING SEGMENT IN\nHDSSAV01 DS    0H\n         LA    R1,1(,R1)           RESTORE ORIGINAL LENGTH\n         LA    X1,2(R1,X1)         POINT TO NEXT DATA AREA\n         BR    RETURN              AND RETURN TO CALLER\n         SPACE\nHDSMVC   MVC   2(*-*,X1),0(TEMP)   COPIES HEADING TEXT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#HI": {"ttr": 6662, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x006\\x006\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .HI (HANGING INDENT) --- CONTROL                       *\n*                                                                     *\n***********************************************************************\n         SPACE\nHI      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BNEG+BOMIT,HI02     BRANCH IF NEGATIVE OR OMITTED\n         BC    BPOS,HI01           BRANCH IF AFFIRMATIVE\n         ST    COUNT,ARGSTART      RESCAN FOR NUMERIC\n        $CALL  GETNUM              GET OPERAND\n         BC    BDNO,HIE005         ERROR IF INVALID\n         BC    BOMIT,HI02          BRANCH IF OMITTED TO DEFAULT\n         CLI   NUMSIGN,C' '        WAS OPERAND UNSIGNED .Q\n         BE    HI03                BRANCH IF YES\n         AH    COUNT,HICNT         MAKE RELATIVE CHANGE\n         B     HI03                GO CHECK AND ENTER\n         SPACE\nHI01     DS    0H\n         LA    COUNT,5             A NICE AFFIRMATIVE VALUE\n         B     HI03                AND GO ENTER\nHI02     DS    0H\n         SR    COUNT,COUNT         DEFAULT HANGING INDENT\nHI03     DS    0H\n         LTR   COUNT,COUNT         TEST NOT TOO SMALL\n         BM    HIE014              ERROR IF TOO SMALL\n         C     COUNT,LLZ           TEST NOT TOO BIG\n         BNL   HIE013              ERROR IF TOO BIG\n         STH   COUNT,HICNT         SET HANGING INDENT\n         SR    COUNT,COUNT         THIS IS LIKE OFFSET ZERO\n         LH    TEMP,INDL           CURRENT WORKING LEFT INDENT\n         SH    TEMP,OFFL           LESS OFFSET\n         STH   TEMP,INDL           ADJUST INDENTATION\n         SH    TEMP,UNDL           ..\n         BM    HIE013              ERROR IF TOO LARGE\n         STH   TEMP,RMARGIN        ..\n         STH   COUNT,OFFL          CLEAR OFFSET VALUE\n         STH   COUNT,OFFLI         CLEAR NEXT OFFSET VALUE\n         STH   COUNT,OFUNCNT       CLEAR MARGIN VALUE FOR FORMAT\n         SPACE\nHI04     DS    0H\n        $EXIT  RC=0                RETURN TO CONTROLLER\n         SPACE\nHIE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     HI04                GO TO RETURN\nHIE013   DS    0H\n         MVI   EFLAG013,ERRSET     OPERAND TOO BIG\n         B     HI04                GO TO RETURN\nHIE014   DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     HI04                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#HIDB": {"ttr": 6664, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x83\\x00\\x83\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 131, "newlines": 131, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTIONS 'HIDB' --- ALTER HIDDEN READ BUFFS  *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  (R1>0) ->  AREA TO ENTER 'LIFO' ON HIDDEN STACK\n*                  (R1<0) ->  AREA TO ENTER 'FIFO' ON HIDDEN STACK\n*                  (TEMP) = LENGTH-1 OF DATA\n*        ON EXIT   CC  =  BPOS  IF LINE STACKED\n*                      =  BNEG  IF NOT\n         SPACE\nHIDBADD $ENTER ,\n         LA    X3,HIDBANCH+HIDBCHN-HIDB POINT TO ANCHOR\n         LTR   R1,R1               LIFO OR FIFO REQUEST .Q\n         BNM   HIDBA02             BRANCH IF LIFO\n         USING HIDB,X3             WANT END AREA LIKE THIS\nHIDBA01  DS    0H\n         OC    HIDBCHN,HIDBCHN     END OF THE CHAIN .Q\n         BZ    HIDBA02             BRANCH IF YES\n         L     X3,HIDBCHN          GET NEXT AREA\n         B     HIDBA01             AND TRY AGAIN\n         DROP  X3\n         SPACE\nHIDBA02  DS    0H\n         LPR   X1,R1               POINT TO DATA LINE\n         LTR   X2,TEMP             LENGTH-1 OF DATA\n         BM    HIDBA06             ERROR IF NEGATIVE\n         L     TEMP,0(,X3)         HIDDEN BUFFER ADDRESS\n         LTR   TEMP,TEMP           DOES ONE EXIST .Q\n         BNZ   HIDBA03             BRANCH IF YES\n         LA    R1,HIDBLN+B2LG      FIRST LEVEL BUFFER LENGTH\n        $CALL  GETCELL             GET THE AREA\n         BC    BNEG,HIDBA06        ERROR IF NO SPACE\n         ST    TEMP,0(,X3)         SET FIRST LEVEL BUFFER ADDRESS\n         USING HIDB,TEMP           AREA GOT LOOKS LIKE THIS\n         XC    HIDB(HIDBLN),HIDB   CLEAR PREFIX AREA\n         STH   R1,HIDBBLKL         SET BLOCK LENGTH\n         SPACE\nHIDBA03  DS    0H\n         OC    HIDBLEN,HIDBLEN     DATA AREA FREE .Q\n         BZ    HIDBA04             BRANCH IF YES\n         LA    R1,HIDBLN+1(,X2)    LENGTH NEEDED TO SAVE\n        $CALL  GETCELL             GET THE NEW AREA\n         BC    BNEG,HIDBA06        ERROR IF NO SPACE\n         XC    HIDB(HIDBLN),HIDB   CLEAR PREFIX AREA\n         MVC   HIDBCHN,0(X3)       MOVE 'NEXT' PTR TO CURRENT\n         ST    TEMP,0(,X3)         ANCHOR POINTS TO NEW\n         STH   R1,HIDBBLKL         SET LENGTH OF BLOCK\nHIDBA04  DS    0H\n         EX    X2,HIDBAMVC         SAVE TEXT\n         LA    X2,1(,X2)           ACTUAL DATA LENGTH\n         STH   X2,HIDBLEN          SAVE LENGTH OF DATA\n        $ON    SWITCHS,HIDBSWS     HIDDEN BUFFER DATA PRESENT\n        $CC    POS                 SUCCESSFUL TERMINATION\nHIDBA05  DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\nHIDBA06  DS    0H\n         MVI   EFLAG024,ERRSET     NO SPACE ERROR\n        $CC    NEG                 FAILURE TERMINATION\n         B     HIDBA05             GO AND RETURN\n         SPACE\nHIDBAMVC MVC   HIDBDATA(*-*),0(X1) MOVE DATA TO HIDDEN BUFFER\n         DROP  TEMP\n         SPACE\n***********************************************************************\n*                                                                     *\n*              HIDBDEL --- DELETE UNUSED HIDDEN BUFFER ELEMENTS       *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R1) POINTS TO ANCHOR\n*        ON EXIT    CC = BPOS  IF SOME DATA LEFT IN BUFFER CHAIN\n*                      = BOMIT IF NO DATA LEFT IN BUFFER CHAIN\n         SPACE\nHIDBDEL $ENTER ,                   SAVE CALLER'S REGISTERS\n         LR    X2,R1               POINT TO ANCHOR\nHIDBD01  DS    0H\n         L     X1,0(,X2)           POINT TO HIDDEN BUFFER CHAIN\n         LTR   X1,X1               ANY PRESENT .Q\n         BZ    HIDBD03             BRANCH IF NOT\n         USING HIDB,X1             AREA LOOKS LIKE THIS\n         LH    TEMP,HIDBLEN        LENGTH OF DATA\n         S     TEMP,F1             DECREMENT AND TEST LENGTH\n         BNM   HIDBD02             BRANCH IF DATA PRESENT\n         OC    HIDBCHN,HIDBCHN     LAST IN QUEUE .Q\n         BZ    HIDBD03             BRANCH IF YES, NOTHING HERE\n         MVC   0(L'HIDBANCH,X2),HIDBCHN UNCHAIN THIS ENTRY\n         LA    R0,HIDB             POINT TO AREA\n         LH    R1,HIDBBLKL         LENGTH OF BLOCK\n        $CALL  FREECELL            RELEASE AREA\n         B     HIDBD01             AND DO IT AGAIN\n         DROP  X1\n         SPACE\nHIDBD02  DS    0H\n        $ON    SWITCHS,HIDBSWS     HIDDEN BUFFER DATA PRESENT\n        $CC    POS                 SET CC FOR DATA PRESENT\n         B     HIDBD04             GO TO RETURN\nHIDBD03  DS    0H\n        $OFF   SWITCHS,HIDBSWS     NO HIDDEN BUFFER DATA PRESENT\n        $CC    OMIT                SET CC FOR NO DATA PRESENT\nHIDBD04  DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\n***********************************************************************\n*                                                                     *\n*              HIDBPUR --- DELETE ALL HIDDEN BUFFER ELEMENTS          *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R1) POINTS TO ANCHOR\n         SPACE\nHIDBPUR $ENTER ,\n         LR    X2,R1               POINT TO ANCHOR\n         L     X1,0(,X2)           HIDDEN BUFFER CHAIN ANCHOR\nHIDBP01  DS    0H\n         LTR   X1,X1               AT THE END .Q\n         BZ    HIDBP02             YES, GO AND RETURN\n         USING HIDB,X1             AREAS LOOK LIKE THIS\n         LA    R0,HIDB             FREE THIS AREA\n         LH    R1,HIDBBLKL         WITH THIS LENGTH\n         L     X1,HIDBCHN          NEXT ELEMENT IN CHAIN\n        $CALL  FREECELL            FREE AN ELEMENT\n         B     HIDBP01             GO DO NEXT ONE\n         DROP  X1\n         SPACE\nHIDBP02  DS    0H\n         XC    0(L'HIDBANCH,X2),0(X2)   CLEAR CHAIN ANCHOR\n        $OFF   SWITCHS,HIDBSWS     SAVE RESULT FOR QUICK REFERENCE\n        $EXIT  RC=0                RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#HIDTC": {"ttr": 6667, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\xb1\\x00\\xb1\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 177, "newlines": 177, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTIONS 'HIDTC' --- ALTER TC READ BUFFS     *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  (R1>0) ->  AREA TO ENTER 'LIFO' ON TC STACK\n*                  (R1<0) ->  AREA TO ENTER 'FIFO' ON TC STACK\n*                  (TEMP) = LENGTH-1 OF DATA\n*        ON EXIT   CC  =  BPOS  IF LINE STACKED\n*                      =  BNEG  IF NOT\n         SPACE\nHIDTCAD $ENTER ,\n         CLI   ICORFLG,ICORNONE    FORMATTING INCORE .Q\n         BNE   HIDTC05             BRANCH IF YES\n         SPACE\n         LR    R0,R1               REMEMBER LIFO/FIFO\n         LPR   R1,R1               SOURCE ADDRESS\n         L     X1,WRKBUFFA         WORK BUFFER ADDRESS\n         MVC   0(L'WRKBUFF,X1),BLANKS   CLEAR FOR SAFETY\n         CLC   0(1,R1),PERIND      ADDING A CONTROL WORD .Q\n         BE    HIDTC02             YES, NO PAGE NUMBER\n         LTR   R0,R0               'FIFO' ADD REQUEST .Q\n         BNM   HIDTC01             BRANCH IF NOT\n        $SAVE  ,                   REMEMBER INPUT POINTERS\n         MVC   0(L'HIDTCIN,X1),HIDTCIN  PREPARATORY INDENT\n         MVC   0(1,X1),PERIND      CONTROL WORD INDICATOR\n         LNR   R1,X1               'FIFO' REQUEST\n         LA    TEMP,L'HIDTCIN-1    LENGTH-1\n        $CALL  HIDTCCN             ADD DATA TO CHAIN\n         MVC   0(L'WRKBUFF,X1),BLANKS   CLEAR FOR SAFETY AGAIN\n        $RESTOR ,                  RESTORE ORIGINAL POINTERS\n         SPACE\nHIDTC01  DS    0H\n         EX    TEMP,HIDTCMVC       MOVE USER'S DATA\n         LA    X1,0(TEMP,X1)       LAST USED CHARACTER\n         MVI   1(X1),X'05'         ADD A TAB\n        $CALL  PNUMFMT             GET PAGE NUMBER\n         EX    COUNT,HIDTCPGE      ADD CURRENT PAGE NUMBER\n         LA    X1,2(COUNT,X1)      LAST USED CHAR\n         B     HIDTC03             PREPARE FOR ADD\n         SPACE\nHIDTC02  DS    0H\n         EX    TEMP,HIDTCMVC       MOVE USER'S COMMAND\n         LA    X1,0(TEMP,X1)       LAST USED CHARACTER\nHIDTC03  DS    0H\n         S     X1,WRKBUFFA         LESS START\n         LR    TEMP,X1             LENGTH-1 FOR SAVE CALL\n         L     R1,WRKBUFFA         NEW ADDRESS\n         LTR   R0,R0               FIFO OR LIFO .Q\n         BNM   HIDTC04             BRANCH IF LIFO\n         LNR   R1,R1               FIFO\n         SPACE\nHIDTC04  DS    0H\n        $CALL  HIDTCCN             ADD DATA TO CHAIN\n         B     HIDTC06             GO TO RETURN\n         SPACE\nHIDTCMVC MVC   0(*-*,X1),0(R1)     MOVE TC DATA\nHIDTCPGE MVC   2(*-*,X1),EBCDPAGE  MOVE TC PAGE NUMBER\nHIDTCIN  DC    C'.IN * 0-3'        RIGHT INDENT\n         SPACE\nHIDTC05  DS    0H\n        $CALL  HIDTCOR             ADD TO INCORE CHAIN\n         SPACE\nHIDTC06  DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTION 'HIDTCCN' --- CHAIN TC LINES         *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  (R1>0) ->  AREA TO ENTER 'LIFO' ON TC STACK\n*                  (R1<0) ->  AREA TO ENTER 'FIFO' ON TC STACK\n*                  (TEMP) = LENGTH-1 OF DATA\n*        ON EXIT   CC  =  BPOS  IF LINE STACKED\n*                      =  BNEG  IF NOT\n         SPACE\nHIDTCCN $ENTER ,\n         L     X3,DHNUMTC          TABLE OF CONTENTS NUMBER\n         SLL   X3,2                MULT BY FOUR\n         LA    X3,TCANCH+HIDBCHN-HIDB(X3)  POINT TO ANCHOR\n         LTR   R1,R1               LIFO OR FIFO\n         BNM   HTCCN02             BRANCH IF LIFO\n         SPACE\n         USING HIDB,X3             WANT END AREA LIKE THIS\nHTCCN01  DS    0H\n         OC    HIDBCHN,HIDBCHN     END OF CHAIN .Q\n         BZ    HTCCN02             BRANCH IF YES\n         L     X3,HIDBCHN          GET NEXT AREA\n         B     HTCCN01             AND TRY AGAIN\n         DROP  X3\n         SPACE\nHTCCN02  DS    0H\n         LPR   X1,R1               POINT TO DATA AREA\n         LTR   X2,TEMP             LENGTH-1 OF DATA\n         BM    HTCCN04             ERROR IF NEGATIVE\n         LA    R1,HIDBLN+1(,X2)    LENGTH NEEDED\n        $CALL  GETCELL             GET SOME SPACE\n         BC    BNEG,HTCCN04        ERROR IF NO SPACE\n         USING HIDB,TEMP           AREA LOOKS LIKE THIS\n         XC    HIDB(HIDBLN),HIDB   CLEAR PREFIX AREA\n         MVC   HIDBCHN,0(X3)       NEXT POINTER TO CURRENT\n         ST    TEMP,0(,X3)         CHAIN POINTER TO NEW\n         STH   R1,HIDBBLKL         SET LENGTH OF BLOCK\n         EX    X2,HTCCNMVC         SAVE TEXT\n         LA    X2,1(,X2)           ACTUAL LENGTH\n         STH   X2,HIDBLEN          SAVE LENGTH OF DATA\n        $CC    POS                 SUCCESSFUL\n         SPACE\nHTCCN03  DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\nHTCCN04  DS    0H\n         MVI   EFLAG024,ERRSET     NO SPACE FOR DATA\n        $CC    NEG                 NOT SUCCESSFUL\n         B     HTCCN03             AND GO TO RETURN\n         SPACE\nHTCCNMVC MVC   HIDBDATA(*-*),0(X1) SAVE CONTENTS DATA\n         DROP  TEMP\n         EJECT\n***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTION 'HIDTCCN' --- CHAIN TC LINES         *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  (R1>0) ->  AREA TO ENTER 'FIFO' ON TC STACK\n*                  (R1<0) ->  AREA TO ENTER 'FIFO' ON TC STACK\n*                  (TEMP) = LENGTH-1 OF DATA\n*        ON EXIT   CC  =  BPOS  IF LINE STACKED\n*                      =  BNEG  IF NOT\nHIDTCOR $ENTER ,\n         L     X1,ICORANCH         ADDR OF LINE CONTROL\n         LTR   X1,X1               IS IT VALID .Q\n         BNP   HIDCE024            ERROR IF NOT\n         SPACE\n         USING CPFKFN,X1           AREA LOOKS LIKE THIS\n         LPR   X2,R1               POINT TO USER DATA\n         LR    COUNT,TEMP          REMEMBER LENGTH-1\n         LA    R1,FNQLN+1(,COUNT)  LENGTH REQUIRED\n        $CALL  GETCELL             GET A QUEUE BUFFER\n         BC    BNEG,HIDCE024       BRANCH IF FAILURE\n         SPACE\n         LA    R1,CPFKFNA-FNQFCHN+FNQELEM  PRIME USED LOOP\n         USING FNQELEM,R1          FOR LAST ELEMENT USED\nHIDCOR01 DS    0H\n         OC    FNQFCHN,FNQFCHN     AT THE END .Q\n         BZ    HIDCOR02            BRANCH IF YES\n         L     R1,FNQFCHN          NEXT CELL ADDRESS\n         B     HIDCOR01            AND TRY AGAIN\nHIDCOR02 DS    0H\n         ST    TEMP,FNQFCHN        LINK NEW AT THE END\n         DROP  R1\n         SPACE\n         USING FNQELEM,TEMP        THIS IS THE NEW\n         XC    FNQELEM(FNQLN),FNQELEM   CLEAR PREFIX\n        $ON    FNQFLAG,FNQTC       TABLE OF CONTENTS ENTRY ONLY\n         EX    COUNT,HIDCORMV      MOVE IN DATA\n         LA    COUNT,5(,COUNT)     LENGTH + LENGTH OF RDW\n         STH   COUNT,FNQRDW        SAVE LENGTH FOUND\n         MVC   FNQCORSW,ICORFLG    RETAIN TYPE OF RECORD\n         L     COUNT,DHNUMTC       CURRENT TABLE OF CONTENTS NUMBER\n         STH   COUNT,FNQNUMTC      SAVE AS PART OF DATA FOR LATER\n        $CC    POS                 SUCCESS\n         SPACE\nHIDCOR03 DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nHIDCORMV MVC   FNQTEXT(*-*),0(X2)  SAVE USER DATA\n         DROP  TEMP,X1\n         SPACE\nHIDCE024 DS    0H\n         MVI   EFLAG024,ERRSET     NO SPACE\n        $CC    NEG                 INDICATE FAILURE\n         B     HIDCOR03            AND GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#HL": {"ttr": 6913, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\xd4\\x00\\xd4\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 212, "newlines": 212, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .HL (HEAD LEVEL) --- CONTROL                           *\n*                                                                     *\n***********************************************************************\n         SPACE\nHL      $ENTER ,\n         SPACE\n         CLI   RMCW+1,C'0'         IS THIS A .HL CPMMAND .Q\n         BL    HL01                BRANCH IF YES\n         CLI   RMCW+1,C'9'         IS THIS A .HO - .H9 COMMAND .Q\n         BNH   HL02                BRANCH IF YES\nHL01     DS    0H\n        $CALL  GETNUM              GET HEAD LEVEL NUMBER\n         BC    BPOS,HL03           BRANCH IF POSITIVE\n         BC    BOMIT,HLE1          ERROR IF OMITTED\n         BC    BNEG,HLE2           ERROR IF NEGATIVE\n         BC    BDNO,HLE3           ERROR IF NOT NUMERIC\nHL02     DS    0H                  EXTRACT NO FROM H0-H9 CW\n         IC    COUNT,RMCW+1        GET HEAD LEVEL NO\n         N     COUNT,F15           ISOLATE HEAD LEVEL NUMBER\nHL03     DS    0H                  COUNT NOW HAS HEAD LEVEL NO\n         LA    R0,DHMAXTC          GET MAX NO OF CONTENTS LEVELS\n         CR    R0,COUNT            CHECK OPERAND VS MAX\n         BNH   HLE4                ARGUMENT TOO LARGE\n         L     X1,DHNUMTC          FETCH TABLE OF CONTENTS NUMBER\n         SLL   X1,2                TIMES 4\n         L     X1,DHANCH(X1)       INDEX INTO ADDRESS VECTOR\n         LA    TEMP,DHDLEN         GET LENGTH OF DH AREA\n         STH   TEMP,SAVEH0         ALIGN ITEM LENGTH\n         MH    COUNT,SAVEH0        TIMES HEAD LEVEL NUMBER\n         LA    X2,0(COUNT,X1)      LOAD ITEM ADDRESS\n         USING DHDSECT,X2          TELL ASSEMBLER OUR BASE\n        $CALL  USARG               ISOLATE HEAD LEVEL ARGUMENT\n         BC    BOMIT,HLE1          ERROR IF NULL\n         SPACE\n         L     X3,BUFF3AD          POINT TO WORK BUFFER\n         LA    X3,4(,X3)           BUMP OVER DUMMY RDW\n         SPACE\n*                                  TO\n        $IFON  DHFLAGS,DHTO,HL05   BRANCH IF TABLE OF CONTENTS ONLY\n        $CALL  PRINTNB             FLUSH ANY PRINT LINES\n         SPACE\n*                                  SPAF\n         SR    X1,X1               CLEAR SPACE REGISTER\n         IC    X1,DHSPAF           GET NUMBER OF SPACES\n         LTR   X1,X1               WAS .SP 0 REQUESTED .Q\n         BZ    HL04                BRANCH IF YES\n         LA    TEMP,L'HLSP+6       LENGTH-1 OF BUFFER\n         BAL   RETURN,HLSETN       PLACE SPACE OPERAND IN CHAR\n         MVC   0(L'HLSP,X3),HLSP   SET SPACE CONTROL WORD\n         MVC   0(1,X3),PERIND      ADD CONTROL WORD INDICATOR\n         LR    R1,X3               POINT TO BUFFER\n        $CALL  HIDBADD             ADD LINE FIFO\n         B     HL05                SKIP CHECK FOR 'BREAK'\n         SPACE\n*                                  BR\nHL04     DS    0H\n        $IFOFF DHFLAGS,DHBR,HL05   BRANCH IF NO BREAK REQUIRED\n         LA    TEMP,L'HLBR-1       LENGTH-1 OF .BR\n         MVC   0(L'HLBR,X3),HLBR   MOVE IN BREAK CONTROL WORD\n         MVC   0(1,X3),PERIND      SET CONTROL WORD INDICATOR\n         LR    R1,X3               POINT TO LINE\n        $CALL  HIDBADD             ADD LINE FIFO\n         SPACE\n*                                  TC\nHL05     DS    0H\n        $IFOFF DHFLAGS,DHTC,HL07   BRANCH IF NO TABLE OF CONTENTS REQ'D\n         MVC   0(L'HLPT,X3),HLPT   ENTER PUT COMMAND\n         MVC   0(1,X3),PERIND      ADD CONTROL WORD INDICATOR\n         LH    TEMP,BUFF2LGZ       LENGTH OF LINE\n         BCTR  TEMP,0              LENGTH-1 OF LINE\n         EX    TEMP,MOVBUF         MOVE ARG LINE TO WORK\n         LA    TEMP,L'HLPT(,TEMP)  LENGTH-1 OF RESULT\n         LR    R1,X3               POINT TO LINE\n        $CALL  HIDBADD             ADD LINE FIFO\n         SPACE\n*                                  TCOF\n         SR    X1,X1               CLEAR OFFSET REG\n         IC    X1,DHTCOF           GET OFFSET VALUE\n         LTR   X1,X1               WAS .OF 0 REQUESTED .Q\n         BZ    HL06                BRANCH IF YES\n         LA    TEMP,L'HLPTOF+6     LENGTH-1 OF COMMAND\n         BAL   RETURN,HLSETN       PLACE OPERAND IN BUFFER\n         MVC   0(L'HLPTOF,X3),HLPTOF    SET OFFSET CONTROL WORD\n         MVC   0(1,X3),PERIND      ADD CONTROL WORD INDICATOR\n         MVC   4(1,X3),PERIND      AND AGAIN\n         LR    R1,X3               POINT TO BUFFER\n        $CALL  HIDBADD             ADD LINE FIFO\n         SPACE\n*                                  TCIN\nHL06     DS    0H\n         SR    X1,X1               CLEAR INDENT REG\n         IC    X1,DHTCIN           GET INDENT VALUE\n         LA    TEMP,L'HLPTIN+6     LENGTH-1 OF COMMAND\n         BAL   RETURN,HLSETN       PLACE OPERAND IN BUFFER\n         MVC   0(L'HLPTIN,X3),HLPTIN    SET INDENT CONTROL WORD\n         MVC   0(1,X3),PERIND      ADD CONTROL WORD INDICATOR\n         MVC   4(1,X3),PERIND      AND AGAIN\n         LR    R1,X3               POINT TO BUFFER\n        $CALL  HIDBADD             ADD LINE FIFO\n         SPACE\n*                                  TS\n        $IFOFF DHFLAGS,DHTS,HL07   BRANCH IF NO SPACE REQUIRED\n         LA    TEMP,L'HLPTSP-1     LENGTH-1 OF COMMAND\n         MVC   0(L'HLPTSP,X3),HLPTSP    SET SPACE CONTROL WORD\n         MVC   0(1,X3),PERIND      ADD CONTROL WORD INDICATOR\n         MVC   4(1,X3),PERIND      AND AGAIN\n         LR    R1,X3               POINT TO LINE\n        $CALL  HIDBADD             ADD LINE FIFO\n         SPACE\nHL07     DS    0H\n        $IFON  DHFLAGS,DHTO,HL12   BRANCH IF TABLE OF CONTENTS ONLY\n         SPACE\n*                                  US/UP\n         LA    R1,HLUC             .UP AND .US ASSUMED\n        $IFON  DHFLAGS,(DHUP,DHUS),HL08 BRANCH IF TRUE\n         LA    R1,HLUP             .UP ASSUMED\n        $IFON  DHFLAGS,DHUP,HL08   BRANCH IF TRUE\n         LA    R1,HLUS             .US ASSUMED\n        $IFON  DHFLAGS,DHUS,HL08   BRANCH IF TRUE\n         LH    R1,BUFF2LGZ         LENGTH OF BUFF2\n         BCTR  R1,0                LENGTH-1\n         EX    R1,MOVBUF           MOVE LINE TO WORK BUFFER\n         LR    TEMP,R1             LENGTH-1 IN TEMP\n         LA    R1,4(,X3)           POINT TO LINE\n         B     HL09                CONTINUE\nHL08     DS    0H\n         MVC   0(L'HLUS,X3),0(R1)  MOVE IN CONTROL WORD\n         MVC   0(1,X3),PERIND      SET CONTROL WORD INDICATOR\n         LH    R1,BUFF2LGZ         LENGTH OF BUFF2\n         BCTR  R1,0                LENGTH-1\n         EX    R1,MOVBUF           MOVE .HL ARGUMENT TO WORK BUFFER\n         LA    TEMP,L'HLUS         LENGTH OF .US/.UP/.UC\n         AR    TEMP,R1             ADD LENGTH OF BUFF2\n         LR    R1,X3               POINT TO LINE\nHL09     DS    0H\n        $CALL  HIDBADD             ADD LINE FIFO\n         SPACE\n*                                  OJ\n        $IFOFF DHFLAGS,DHOJ,HL10   BRANCH IF NO .OJ REQUIRED\n         LA    TEMP,L'HLOJ         LENGTH-1 OF .OJ\n         MVC   0(L'HLOJ,X3),HLOJ   MOVE IN .OJ CONTROL WORD\n         MVC   0(1,X3),PERIND      SET CONTROL WORD INDICATOR\n         LR    R1,X3               POINT TO LINE\n        $CALL  HIDBADD             ADD LINE FIFO\n         SPACE\n*                                  SKBF\nHL10     DS    0H\n         SR    X1,X1               CLEAR SKIP REGISTER\n         IC    X1,DHSKBF           GET NUMBER OF SKIPS\n         LTR   X1,X1               WAS .SK 0 REQUESTED .Q\n         BZ    HL11                BRANCH IF YES\n         LA    TEMP,L'HLSK+6       LENGTH-1 OF BUFFER\n         BAL   RETURN,HLSETN       PLACE SKIP OPERAND IN CHARACTER\n         MVC   0(L'HLSK,X3),HLSK   SET SKIP CONTROL WORD\n         MVC   0(1,X3),PERIND      ADD CONTROL WORD INDICATOR\n         LR    R1,X3               POINT TO BUFFER\n        $CALL  HIDBADD             ADD LINE FIFO\n         SPACE\n*                                  PA\nHL11     DS    0H\n        $IFOFF DHFLAGS,DHPA,HL12   BRANCH IF .PA NOT REQUIRED\n        $IFON  SWITCHS,FEMPTY,HL12 BRANCH IF ALREADY AT PAGE TOP\n         LA    TEMP,L'HLPA-1       LENGTH-1 OF .PA\n         MVC   0(L'HLPA,X3),HLPA   MOVE IN PAGE CONTROL WORD\n         MVC   0(1,X3),PERIND      SET CONTROL WORD INDICATOR\n         LR    R1,X3               POINT TO LINE\n        $CALL  HIDBADD             ADD LINE FIFO\nHL12     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nHLSETN   DS    0H\n        $SAVE  ,                   SAVE CALLER'S REGISTERS\n         MVC   0(B2LG,X3),BLANKS   BLANK TARGET BUFFER\n         CVD   X1,SAVED0           CONVERT NUMBER TO DECIMAL\n         LA    R1,0(TEMP,X3)       END OF TARGET\n         LA    R0,L'UREDPAT        LENGTH OF NUMBER PATTERN\n         SR    R1,R0               NUMBER TARGET\n         MVC   0(L'UREDPAT,R1),UREDPAT  INSERT EDIT PATTERN\n         ED    0(L'UREDPAT,R1),SAVED0+4 UNPACK NUMBER TO CHARACTER\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              RETURN TO CALLER\n         SPACE\nMOVBUF   MVC   4(*-*,X3),BUFF2     MOVE OPERAND 'LINE'\n         DROP  X2\n         SPACE\nHLSK     DC    C'.SK '\nHLPA     DC    C'.PA'\nHLOJ     DC    C'.OJ'\nHLUS     DC    C'.US '\nHLUP     DC    C'.UP '\nHLUC     DC    C'.UC '\nHLBR     DC    C'.BR'\nHLSP     DC    C'.SP '\nHLPTSP   DC    C'.PT .SP'\nHLPTOF   DC    C'.PT .OF '\nHLPTIN   DC    C'.PT .IN '\nHLPT     DC    C'.PT '\n         SPACE\nHLE1     DS    0H\n         MVI   EFLAG003,ERRSET     ARGUMENT OMITTED\n         B     HL12\nHLE2     DS    0H\n         MVI   EFLAG014,ERRSET     ARGUMENT TOO SMALL\n         B     HL12\nHLE3     DS    0H\n         MVI   EFLAG035,ERRSET     ARGUMENT MUST BE NUMERIC\n         B     HL12\nHLE4     DS    0H\n         MVI   EFLAG013,ERRSET     ARGUMENT TOO LARGE\n         B     HL12\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#HM": {"ttr": 6918, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00&\\x00&\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .HM (HEADING MARGIN) --- CONTROL                       *\n*                                                                     *\n***********************************************************************\n         SPACE\nHM      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n        $CALL  GETNUM              GET NUMBER\n         BC    BDNO,HM03           ERROR IF INVALID\n         BC    BOMIT,HM01          ENTER DEFAULT IF OMITTED\n         CLI   NUMSIGN,C' '        WAS ARGUMENT SIGNED .Q\n         BE    HM02                BRANCH IF NOT\n         AH    COUNT,HDMRG         ALTER EXISTING HEADING MARGIN\n         B     HM02                GO CHECK AND ENTER\nHM01     DS    0H\n         L     COUNT,DEFHDMG+TAB3DEF  DEFAULT HEADING MARGIN VALUE\nHM02     DS    0H\n         LTR   COUNT,COUNT         IS HEADING MARGIN NEGATIVE\n         BM    HM05                ERROR IF YES\n         LH    TEMP,TOPMRG         GET TOP MARGIN\n         SH    TEMP,HSCNT          LESS HEADING SPACING\n         CR    COUNT,TEMP          COMPARE VALUES\n         BH    HM04                ERROR IF BIGGER\n         STH   COUNT,HDMRG         SET HEADING MARGIN\n         B     HM06                BRANCH TO COMMON RETURN\n         SPACE\nHM03     DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     HM06                BRANCH TO COMMON RETURN\nHM04     DS    0H\n         MVI   EFLAG041,ERRSET     OPERAND TOO BIG\n         B     HM06                BRANCH TO COMMON RETURN\nHM05     DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         SPACE\nHM06     DS    0H\n        $EXIT  RC=0                RETURN TO MAIN CONTROLLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#HN": {"ttr": 6920, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\xc1\\x00\\xc1\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 193, "newlines": 193, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .HN (HEADNOTE DEFINITION) --- CONTROL                  *\n*                                                                     *\n***********************************************************************\n         SPACE\nHN      $ENTER ,\n        $CALL  GETYESNO            GET AND TEST FIRST ARG\n         LA    X1,HNEAREA          ASSUME EVEN HEADNOTE AREA\n         LA    X2,ICORHNE          AND ITS FLAG\n         CLI   YNRESULT,YNEVN      WAS ARG 'EVEN' .Q\n         BE    HN01                BRANCH IF YES\n         LA    X1,HNOAREA          ASSUME ODD HEADNOTE AREA\n         LA    X2,ICORHNO          AND ITS FLAG\n         CLI   YNRESULT,YNODD      WAS ARG 'ODD' .Q\n         BE    HN01                BRANCH IF YES\n         LA    X1,HNAREA           ORDINARY HEADNOTE AREA\n         LA    X2,ICORHN           AND ITS FLAG\n         ST    COUNT,ARGSTART      RESCAN ARGUMENT AGAIN\n         USING CPFKFN,X1           DESCRIPTOR AREA POINTER\n         SPACE\nHN01     DS    0H\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BPOS,HNBEG          BRANCH IF START\n         BC    BNEG,HNEND          BRANCH IF END\n         BC    BOMIT,HNE003        BRANCH IF ARG OMITTED\n         CLI   YNRESULT,YNDEL      WAS ARG 'DELETE' .Q\n         BE    HNCAN               BRANCH IF YES\n         CLI   YNRESULT,YNPUR      WAS ARG 'PURGE' OR 'CANCEL' .Q\n         BE    HNCAN               BRANCH IF YES\n         CLI   YNRESULT,YNDUMP     WAS ARG 'DUMP' .Q\n         BE    HNDUMP              BRANCH IF YES\n         B     HNE005              ELSE ARG IS INVALID\n         SPACE\nHNBEG    DS    0H\n         CLI   ICORFLG,ICORNONE    FORMATTING INTO CORE NOW .Q\n         BNE   HNE043              ERROR IF YES\n         LA    R1,CPFKFN           AREA TO FREE\n        $CALL  HNCLR               DELETE ANY CURRENT HEADNOTE\n         LA    R1,ICORSLEN         NEED THIS MUCH SPACE FOR STATUS\n        $CALL  GETCELL             GET THE SPACE\n         BC    BNEG,HNE024         BRANCH IF FAILURE\n         SPACE\n         USING ICORSAVE,TEMP       SAVE AREA LOOKS LIKE THIS\n         ST    TEMP,CPFKFNS        RETAIN SAVE POINTER\n         MVC   ICOROLD1,FMTOLD1    SAVE CURRENT SWITCH INFORMATION\n         MVC   ICOROLD2,FMTOLD2    SAVE CURRENT PAGE DESCRIPTORS\n         MVC   ICORBX,BXPTR        SAVE CURRENT BOX BUILD INFORMATION\n         XC    BXPTR,BXPTR         CLEAR CURRENT BOX\n         MVC   ICOROO,OOANCH       SAVE OUTPUT OVERLAY ANCHOR\n         XC    OOANCH,OOANCH       CLEAR CURRENT OUTPUT OVERLAY\n         MVC   ICORSKSP,SKSP       SAVE CONDITIONAL SKIP/SPACE\n         XC    SKSP,SKSP           CLEAR CURRENT SKIP/SPACE\n         DROP  TEMP\n         SPACE\n         XC    OLDCOUNT,OLDCOUNT   WIPE OUT PREVIOUS LINE\n         STC   X2,ICORFLG          NOW SAVING HEADNOTE\n         LA    TEMP,CPFKFN         HEADNOTE BLOCK CONTROL\n         ST    TEMP,ICORANCH       SAVE THIS FOR LATER\n         LH    TEMP,INDL           RESET INDENT\n         AH    TEMP,OFFLI          ..\n         STH   TEMP,INDL           ..\n         STH   TEMP,RMARGIN        SET RIGHT MARGIN\n         SR    TEMP,TEMP           ZERO WORK REGISTER\n         STH   TEMP,INDENTR        ZERO RIGHT INDENT VALUE\n         STH   TEMP,PICNT          ZERO PARAGRAPH INDENT\n         STH   TEMP,HICNT          ZERO HANGING INDENT\n         STH   TEMP,UNDL           ZERO UNDENT VALUE\n         STH   TEMP,OFFLI          ZERO OFFSET VALUE\n         STH   TEMP,CECNT          ZERO CENTER VALUE\n         STH   TEMP,LICNT          ZERO LITERAL VALUE\n         MVC   CLLZ,LLZ            SET LINE LENGTH TO FULL PAGE WIDTH\n         B     HNDONE              START SAVING HEADNOTE\n         SPACE\nHNEND    DS    0H\n         EX    X2,HNCLI            NOW SAVING A .HN SEQUENCE INCORE .Q\n         BNE   HNE043              ERROR IF NOT\n        $CALL  PRINT               CLEAR LAST .HN LINE FROM BUFFER\n         SPACE\n         L     TEMP,CPFKFNS        RESTORE SAVE POINTER\n         XC    CPFKFNS,CPFKFNS     CLEAR POINTER\n         USING ICORSAVE,TEMP       SAVE AREA LOOKS LIKE THIS\n        $CALL  BXCLR               DELETE ANY BOX IN EFFECT\n         LA    R1,OOANCH           OUTPUT OVERLAY ANCHOR\n        $CALL  OVCLR               DELETE ANY IN PROGRESS\n        $MVC   FMTOLD1,ICOROLD1    RESTORE CURRENT SWITCH INFORMATION\n        $MVC   FMTOLD2,ICOROLD2    RESTORE CURRENT PAGE DESCRIPTORS\n        $MVC   BXPTR,ICORBX        RESTORE BOX BUILD INFORMATION\n        $MVC   OOANCH,ICOROO       RESTORE OUTPUT OVERLAY INFORMATION\n        $MVC   SKSP,ICORSKSP       RESTORE CONDITIONAL SKIP/SPACE\n         LA    R0,ICORSAVE         SAVE AREA HERE\n         LA    R1,ICORSLEN         LENGTH OF SAVE AREA\n        $CALL  FREECELL            RELEASE THE AREA\n         DROP  TEMP\n         SPACE\n         MVI   ICORFLG,ICORNONE    RESET SAVING HEADNOTE SWITCH\n         XC    ICORANCH,ICORANCH   CLEAR HEADNOTE BLOCK CONTROL\n        $ON    CPFKFNG,CPFKKEEP    MARK DATA TO BE KEPT AFTER PRINT\n         B     HNDONE              ALL THROUGH\n         SPACE\nHNCAN    DS    0H\n         EX    X2,HNCLI            DEFINING A HEADNOTE NOW .Q\n         BE    HNE043              YES, CAN'T DELETE NOW\n         LA    R1,CPFKFN           AREA TO FREE\n        $CALL  HNCLR               FREE THE HEADNOTE DATA\n         B     HNDONE              AND GO TO RETURN\n         SPACE\nHNDUMP   DS    0H\n         EX    X2,HNCLI            DEFINING A HEADNOTE NOW .Q\n         BE    HNE043              YES, CAN'T PRINT NOW\n         LA    R1,CPFKFN           AREA TO PRINT\n        $CALL  HNPRT               PRINT HEADNOTE\n         B     HNDONE              AND GO TO RETURN\n         SPACE\nHNDONE   DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nHNCLI    CLI   ICORFLG,*-*         DEFINING SAME TYPE OF HEADNOTE .Q\n         DROP  X1\n         SPACE\nHNE003   DS    0H\n         MVI   EFLAG003,ERRSET     OMITTED OPERAND\n         B     HNDONE              GO TO TERMINATE\nHNE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     HNDONE              GO TO TERMINATE\nHNE024   DS    0H\n         MVI   EFLAG024,ERRSET     NO SPACE FOR SAVING CURRENT STATUS\n         B     HNDONE              GO TO TERMINATE\nHNE043   DS    0H\n         MVI   EFLAG043,ERRSET     NOT IN A KEEP\n         B     HNDONE              GO TO TERMINATE\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              HEADNOTE CANCEL SUBROUTINE                             *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R1) POINTS TO HEADNOTE DESCRIPTOR AREA\n         SPACE\nHNCLR   $ENTER ,\n         LR    X1,R1               DESCRIPTOR BLOCK TO FREE\n         USING CPFKFN,X1           TELL THE ASSEMBLER\n         L     TEMP,CPFKFNA        FIRST LINK OF CHAIN\n         SPACE\nHNCLR01  DS    0H\n         LTR   TEMP,TEMP           ANY DATA PRESENT .Q\n         BZ    HNCLR02             BRANCH IF NOT\n         USING FNQELEM,TEMP        ELEMENT LOOKS LIKE THIS\n         LH    R1,FNQRDW           LENGTH OF DATA\n         LA    R1,FNQOVHD(,R1)     PLUS LEADING OVERHEAD\n         LA    R0,FNQELEM          POINT TO DATA\n         L     TEMP,FNQFCHN        NEXT ELEMENT\n        $CALL  FREECELL            FREE THE ELEMENT\n         B     HNCLR01             GO DO THE NEXT\n         DROP  TEMP\n         SPACE\nHNCLR02  DS    0H\n         XC    CPFKFN(CPFKFNL),CPFKFN   CLEAR THE DESCRIPTOR BLOCK\n         DROP  X1\n         SPACE\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              HEADNOTE PRINT SUBROUTINE                              *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R1) POINTS TO HEADNOTE DESCRIPTOR AREA\n         SPACE\nHNPRT   $ENTER ,\n         LR    X1,R1               DESCRIPTOR BLOCK TO PRINT\n         USING CPFKFN,X1           TELL THE ASSEMBLER\n         L     R1,CPFKFNC          HEADNOTE LINE COUNT\n         LTR   R1,R1               ANYTHING THERE .Q\n         BZ    HNPRT01             BRANCH OUT IF NOT\n         LH    COUNT,PLCT          LINES LEFT ON THIS PAGE\n         SH    COUNT,BMMRG         LESS BOTTOM MARGIN\n         SH    COUNT,FNSEP         LESS FOOTNOTE MARGIN\n         CR    R1,COUNT            CHECK LENGTH OF HEADNOTE\n         BH    HNPE037             BRANCH IF IT WON'T FIT\n         LA    R1,CPFKFN           POINT TO HEADNOTE DESCRIPTOR\n        $CALL  CPFKPRT             PRINT HEADNOTE\n         SPACE\nHNPRT01  DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         DROP  X1\n         SPACE\nHNPE037  DS    0H\n         MVI   EFLAG037,ERRSET     HEADNOTE TOO LONG FOR PAGE\n         B     HNPRT01             AND GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#HS": {"ttr": 6924, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00,\\x00,\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .HS (HEADING SPACING) --- CONTROL                      *\n*                                                                     *\n***********************************************************************\n         SPACE\nHS      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n        $CALL  GETNUM              GET NUMBER\n         BC    BDNO,HS03           ERROR IF INVALID\n         BC    BOMIT,HS01          ENTER DEFAULT IF OMITTED\n         CLI   NUMSIGN,C' '        WAS ARGUMENT SIGNED .Q\n         BE    HS02                BRANCH IF NOT\n         AH    COUNT,HSCNT         ALTER EXISTING HEADING SPACING\n         B     HS02                GO CHECK AND ENTER\nHS01     DS    0H\n         LA    COUNT,1             DEFAULT HEADING SPACING VALUE\nHS02     DS    0H\n         LTR   COUNT,COUNT         IS HEADING SPACING NEGATIVE .Q\n         BM    HS05                ERROR IF YES\n         LH    TEMP,TOPMRG         GET TOP MARGIN\n         SH    TEMP,HDMRG          LESS HEADING MARGIN\n         CR    COUNT,TEMP          COMPARE VALUES\n         BH    HS06                ERROR IF BIGGER\n         C     COUNT,DEFHSFS+TAB3DEF    BIGGER THAN TT/BT OVERLAP .Q\n         BH    HS04                ERROR IF YES\n         STH   COUNT,HSCNT         SET HEADING SPACING\n         B     HS07                BRANCH TO RETURN\n         SPACE\nHS03     DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     HS07                BRANCH TO RETURN\nHS04     DS    0H\n         MVI   EFLAG013,ERRSET     OPERAND TOO BIG\n         B     HS07                BRANCH TO RETURN\nHS05     DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     HS07                BRANCH TO RETURN\nHS06     DS    0H\n         MVI   EFLAG041,ERRSET     ARG TOO BIG\n         B     HS07                BRANCH TO RETURN\n         SPACE\nHS07     DS    0H\n        $EXIT  RC=0                RETURN TO MAIN CONTROLLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#HV": {"ttr": 6926, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x11\\x00\\x11\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .HV (EVEN PAGE HEADING) --- CONTROL                    *\n*              .ET (EVEN TOP TITLE) --- CONTROL                       *\n*                                                                     *\n***********************************************************************\n         SPACE\nET      $ENTER ,\n        $ON    SWITCHS,FNOCASE     UPPER CASE FLAG FOR ALTERNATE FORMAT\n        $CALL  HV                  LET HIM DO THE WORK\n        $EXIT  RC=0                DONE WITH .ET\n         SPACE\nHV      $ENTER ,\n         L     X1,ADEVHEAD         PUT DATA IN EVEN HEAD AREA\n        $CALL  HEADSAVE            ..\n        $OFF   SWITCHS,FNOCASE     RESET FORMAT FLAG\n        $EXIT RC=0                 DONE WITH .HV\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#HW": {"ttr": 6928, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00Y\\x00Y\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 89, "newlines": 89, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .HW (HYPHENATE WORD) --- CONTROL                       *\n*                                                                     *\n***********************************************************************\n         SPACE\nHW      $ENTER ,\n         LA    X1,HYUSER           USER HYPHENATION CODE\n         C     X1,HYLEVEL          COMPARE WITH CURRENT\n         BE    HW02                BRANCH IF NOW 'USER'\n         L     R1,BUFF3AD          POINT TO STRING\n         LA    R1,4(,R1)           SKIP RDW AREA\n         MVC   0(B2LG,R1),BLANKS   CLEAR WORK AREA\n         MVC   0(L'HWOFF,R1),HWOFF RESTORE HYPHENATION TO OFF\n         LA    TEMP,L'HWOFF-1      LENGTH-1 OF STRING\n         BH    HW01                BRANCH IF 'OFF'\n         MVC   0(L'HWON,R1),HWON   RESTORE HYPHENATION TO ON\n         LA    TEMP,L'HWON-1       LENGTH-1 OF STRING\nHW01     DS    0H\n         MVC   0(L'PERIND,R1),PERIND    CONTROL WORD INDICATOR\n        $CALL  HIDBADD             ENTER STRING ON STACK\n         BC    BNEG,HWE024         BRANCH IF ERROR\n         ST    X1,HYLEVEL          USER HYPHENATION FOR A WHILE\n         SPACE\nHW02     DS    0H\n         L     X1,ARGSTOP          END OF THE LINE\n         SR    COUNT,COUNT         ZERO LINE SEGMENT LENGTH\nHW03     DS    0H\n         BCTR  X1,0                BACKUP POINTER BY ONE\n         C     X1,ARGSTART         AT THE BEGINNING .Q\n         BL    HW07                BRANCH IF YES\n         CLI   1(X1),C'-'          IS CHAR HYPHEN .Q\n         BNE   HW06                BRANCH IF NOT\n         LTR   COUNT,COUNT         SEGMENT LENGTH ZERO .Q\n         BZ    HW06                BRANCH IF YES\n         CLI   2(X1),C'Z'          CHAR AFTER ALPHA .Q\n         BH    HW06                BRANCH IF NOT\n         CLI   2(X1),C'A'-C' '     CHAR AFTER ALPHA .Q\n         BL    HW06                BRANCH IF NOT\n         CLI   0(X1),C'Z'          CHAR BEFORE ALPHA .Q\n         BH    HW05                BRANCH IF NOT\n         CLI   0(X1),C'A'-C' '     CHAR BEFORE ALPHA .Q\n         BL    HW05                BRANCH IF NOT\n         SPACE\n        $IFON  SWITCHS,NFSWS,HW04  BRANCH IF NO CONCATENATE\n         OC    CECNT,CECNT         ANY .CE/.LA/.RA OUTSTANDING .Q\n         BNZ   HW04                BRANCH IF YES\n         SPACE\n         LA    R1,2(,X1)           POINT TO SEGMENT OF LINE\n         LR    TEMP,COUNT          LENGTH OF STRING\n         BCTR  TEMP,0              LENGTH-1 OF STRING\n        $CALL  HIDBADD             STACK SEGMENT\n         BC    BNEG,HWE024         BRANCH IF ERROR\n         SR    COUNT,COUNT         ZERO LENGTH\n         B     HW06                AND CONTINUE SCANNING\n         SPACE\nHW04     DS    0H\n         EX    COUNT,HWMVC         REMOVE SINGLE HYPHEN\n         BCTR  COUNT,0             DECREMENT LENGTH\n         B     HW06                AND CONTINUE\n         SPACE\nHW05     DS    0H\n         CLI   0(X1),C'-'          DOUBLE HYPHEN .Q\n         BNE   HW06                BRANCH IF NOT\n         EX    COUNT,HWMVC         REMOTE DOUBLE HYPHEN\n         BCTR  X1,0                BACKUP POINTER ONE\nHW06     DS    0H\n         LA    COUNT,1(,COUNT)     INCREMENT SEGMENT LENGTH\n         B     HW03                AND CONTINUE\n         SPACE\nHW07     DS    0H\n         LTR   COUNT,COUNT         NO OPERAND AT ALL .Q\n         BZ    HW08                BRANCH IF YES\n         LA    R1,2(,X1)           POINT TO STRING\n         LR    TEMP,COUNT          LENGTH OF STRING\n         BCTR  TEMP,0              LENGTH-1\n        $CALL  HIDBADD             STACK IN INPUT\n         BC    BNEG,HWE024         BRANCH IF ERROR\nHW08     DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\nHWE024   DS    0H\n         MVI   EFLAG024,ERRSET     NO SPACE FOR WORDS\n         B     HW08                GO TO RETURN\n         SPACE\nHWMVC    MVC   1(*-*,X1),2(X1)     REMOVE DOUBLE HYPHEN\n         SPACE\nHWOFF    DC    C'.HY OFF '\nHWON     DC    C'.HY ON  '\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#HY": {"ttr": 7171, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x01\\x8c\\x01\\x8c\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 396, "newlines": 396, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .HY (HYPHENATION) --- CONTROL                          *\n*                                                                     *\n***********************************************************************\n         SPACE\nHY      $ENTER ,\n         L     BASE,VSCRICVT       COMMUNICATION VECTOR TABLE\n         L     BASE,VHYSCRIP-SCRICVT(,BASE)  LOCAL DATA BASE\n         SPACE\n        $CALL  GETYESNO            GET FIRST ARG AGAIN\n         BC    BNEG,HYD01          BRANCH IF NEGATIVE\n         BC    BPOS,HYD03          BRANCH IF AFFIRMATIVE\n         CLI   YNRESULT,YNUSER     'USER' SPECIFIED HYPHENS .Q\n         BE    HYD02               BRANCH IF YES\n         CLI   YNRESULT,YNADD      'ADD' A WORD .Q\n         BE    HYADD               BRANCH IF YES\n         CLI   YNRESULT,YNCNG      'CHANGE' A WORD .Q\n         BE    HYCNG               BRANCH IF YES\n         CLI   YNRESULT,YNDEL      'DELETE' A WORD .Q\n         BE    HYDEL               BRANCH IF YES\n         CLI   YNRESULT,YNPUR      'PURGE' ALL WORDS .Q\n         BE    HYPUR               BRANCH IF YES\n         CLI   YNRESULT,YNDUMP     'DUMP' CURRENT WORDS .Q\n         BE    HYDUMP              BRANCH IF YES\n         CLI   YNRESULT,YNTEST     'TEST' A WORD FOR HYPHENS .Q\n         BE    HYTEST              BRANCH IF YES\n         CLI   YNRESULT,YNSUP      'SUPPRESS' A LINE .Q\n         BE    HYSUP               BRANCH IF YES\n         CLI   YNRESULT,YNSET      'SET' A CONTROL .Q\n         BE    HYSET               BRANCH IF YES\n         B     HYDE005             ELSE INVALID PARAMETER\n         SPACE\nHYD01    DS    0H\n         LA    COUNT,HYNONE        NO HYPHENATION TO BE PERFORMED\n         B     HYD04               GO TO SET\nHYD02    DS    0H\n         LA    COUNT,HYUSER        USER HYPHENATION TO BE PERFORMED\n         B     HYD04               GO TO SET\nHYD03    DS    0H\n         LA    COUNT,HYAUTO        AUTO HYPHENATION TO BE PERFORMED\n         B     HYD04               GO TO SET\nHYD04    DS    0H\n         ST    COUNT,HYLEVEL       SET HYPHENATION LEVEL\n         B     HYDRET              AND GO TO RETURN\n         SPACE\nHYADD    DS    0H\n        $CALL  HYSCN               GET THE WORD TO ADD\n         BC    BDNO,HYADD03        BRANCH AROUND IF SOME ERROR\n         LR    X1,R1               INTERNAL FIRST CHARACTER\n         SLL   X1,2                TIMES FOUR\n         LA    X2,HYANCH(X1)       LETTER ANCHOR POINTER\n         L     X1,HYANCH(X1)       LETTER ANCHOR\n         SPACE\n         USING HYDSECT,X1          AND TELL THE ASSEMBLER\nHYADD01  DS    0H\n         LTR   X1,X1               AT THE END .Q\n         BZ    HYADD02             BRANCH IF YES\n         CLC   HYWORD,HYWKWORD     INSERTION POINT .Q\n         BNL   HYADD02             BRANCH IF YES\n         LR    X2,X1               NEXT LAG POINTER\n         L     X1,HYCHN            NEXT POINTER\n         B     HYADD01             CONTINUE SEARCH\n         SPACE\nHYADD02  DS    0H\n         LR    X1,X2               POINTER TO THE NEW\n         LA    R1,HYLEN            LENGTH OF ONE WORD BLOCK\n        $CALL  GETCELL             GET THE SPACE\n         BC    BNEG,HYDE024        ERROR IF FAILED\n         L     R1,HYEXCNT          EXCEPTION WORD COUNT\n         A     R1,F1               PLUS ONE\n         ST    R1,HYEXCNT          UPDATE VALUE\n         L     R1,HYCHN            FORMER FORWARD POINTER\n         ST    TEMP,HYCHN          POINT TO THE NEW\n         LR    X1,TEMP             THE NEW AREA\n         ST    R1,HYCHN            NEW FORWARD POINTER\n         MVC   HYBRK,HYPIND        BREAK POINTS\n         MVC   HYWORD,HYWKWORD     AND CHARACTERS\nHYADD03  DS    0H\n         B     HYDRET              GO TO TERMINATION\n         DROP  X1\n         SPACE\nHYCNG    DS    0H\n        $CALL  HYSCN               GET WORK TO CHANGE\n         BC    BDNO,HYCNG04        BRANCH AROUND IF SOME ERROR\n         LR    X1,R1               INTERNAL FIRST CHARACTER\n         SLL   X1,2                TIMES FOUR\n         LA    X2,HYANCH(X1)       LETTER ANCHOR POINTER\n         L     X1,HYANCH(X1)       LETTER ANCHOR\n         SPACE\n         USING HYDSECT,X1          AND TELL THE ASSEMBLER\nHYCNG01  DS    0H\n         LTR   X1,X1               AT THE END .Q\n         BZ    HYCNG02             BRANCH IF YES\n         CLC   HYWORD,HYWKWORD     INSERTION POINT\n         BE    HYCNG03             BRANCH IF REPLACEMENT\n         BH    HYCNG02             BRANCH IF INSERTION\n         LR    X2,X1               NEXT LAG POINTER\n         L     X1,HYCHN            NEXT POINTER\n         B     HYCNG01             AND CONTINUE SEARCH\n         SPACE\nHYCNG02  DS    0H\n         LR    X1,X2               POINTER TO THE NEW\n         LA    R1,HYLEN            LENGTH OF ONE WORD BLOCK\n        $CALL  GETCELL             GET THE WORD BLOCK SPACE\n         BC    BNEG,HYDE024        ERROR IF FAILED\n         L     R1,HYEXCNT          EXCEPTION WORD COUNT\n         A     R1,F1               PLUS ONE\n         ST    R1,HYEXCNT          UPDATE VALUE\n         L     R1,HYCHN            FORMER FORWARD POINTER\n         ST    TEMP,HYCHN          POINT TO THE NEW\n         LR    X1,TEMP             THE NEW AREA\n         ST    R1,HYCHN            NEW FORWARD POINTER\nHYCNG03  DS    0H\n         MVC   HYBRK,HYPIND        BREAK POINTS\n         MVC   HYWORD,HYWKWORD     AND CHARACTERS\nHYCNG04  DS    0H\n         B     HYDRET              GO TO TERMINATION\n         DROP  X1\n         SPACE\nHYDEL    DS    0H\n        $CALL  HYSCN               GET WORK TO CHANGE\n         BC    BDNO,HYDEL05        BRANCH IF SOME ERROR\n         LR    X1,R1               INTERNAL FIRST CHAR\n         SLL   X1,2                TIMES FOUR\n         LA    X2,HYANCH(X1)       LAG POINTER\n         L     X1,HYANCH(X1)       LETTER ANCHOR\n         SPACE\n         USING HYDSECT,X1          AND TELL THE ASSEMBLER\nHYDEL01  DS    0H\n         LTR   X1,X1               AT THE END .Q\n         BZ    HYDE030             ENTRY NOT FOUND IF YES\n         CLC   HYWORD,HYWKWORD     COULD IT BE THIS WORD .Q\n         BH    HYDE030             HIGH, GONE TOO FAR\n         BNE   HYDEL02             BRANCH IF NOT\n         CLC   HYBRK,HYPIND        DO BREAK POINTS MATCH .Q\n         BE    HYDEL04             YES, GO TO DELETE IT\nHYDEL02  DS    0H\n         LR    X2,X1               NEXT LAG POINTER\n         L     X1,HYCHN            NEXT POINTER\n         B     HYDEL01             AND CONTINUE SEARCH\n         SPACE\nHYDEL04  DS    0H\n         LA    R0,HYDSECT          AREA TO FREE\n         L     R1,HYCHN            FORWARD POINTER\n         LR    X1,X2               FORMER BLOCK\n         ST    R1,HYCHN            CHAIN OUT THE CURRENT\n         LA    R1,HYLEN            LENGTH OF WORD BLOCK\n        $CALL  FREECELL            FREE THE AREA\n         L     R1,HYEXCNT          EXCEPTION WORD COUNT\n         S     R1,F1               LESS ONE\n         ST    R1,HYEXCNT          UPDATE VALUE\nHYDEL05  DS    0H\n         B     HYDRET              GO TO TERMINATION\n         DROP  X1\n         SPACE\nHYPUR    DS    0H\n         LA    X3,L'HYALPHA        NUMBER OF LETTER ANCHORS\nHYPUR01  DS    0H\n         LR    X1,X3               LETTER NUMBER\n         BCTR  X1,0                LESS ONE\n         SLL   X1,2                TIMES FOUR\n         LA    X2,HYANCH(X1)       ANCHOR POINTER LAG\n         L     X1,HYANCH(X1)       INITIAL ANCHOR\n         XC    0(4,X2),0(X2)       CLEAR LETTER ANCHOR\n         SPACE\n         USING HYDSECT,X1          TELL THE ASSEMBLER\nHYPUR02  DS    0H\n         LTR   X1,X1               AT CHAIN END .Q\n         BZ    HYPUR03             BRANCH OUT IF YES\n         LA    R0,HYDSECT          THIS IS WHERE IT IS\n         L     X1,HYCHN            THIS IS THE NEXT\n         LA    R1,HYLEN            LENGTH OF BLOCK\n        $CALL  FREECELL            FREE CURRENT BLOCK\n         L     R1,HYEXCNT          EXCEPTION WORD COUNT\n         S     R1,F1               LESS ONE\n         ST    R1,HYEXCNT          UPDATE VALUE\n         B     HYPUR02             CONTINUE DOWN THE CHAIN\n         SPACE\nHYPUR03  DS    0H\n         BCT   X3,HYPUR01          DO ALL THE LETTERS\n         B     HYDRET              GO TO TERMINATION\n         DROP  X1\n         SPACE\nHYDUMP   DS    0H\n         L     R1,HYEXCNT          EXCEPTION WORD COUNT\n         CVD   R1,DECM             CONVERT COUNT TO DECIMAL\n         L     R1,BUFF3AD          BUFFER WORK AREA\n         MVC   0(HYDUMPLN,R1),HYDUMPMG  ENTER BASIC MESSAGE\n         ED    HYDUMPNM-HYDUMPMG(6,R1),DECM+5  COUNT TO CHARACTER\n         LR    R0,R1               POINT TO RESULT\n        $CALL  PRTERM              AND PRINT IT\n         SPACE\n         LA    X3,L'HYALPHA        NUMBER OF LETTER ANCHORS\nHYDUMP01 DS    0H\n         LA    X1,L'HYALPHA        MAX NUMBER OF LETTERS\n         SR    X1,X3               LETTER TO DO NOW\n         STC   X1,HYDCWORD         SAVE INTERNAL INITIAL LETTER\n         SLL   X1,2                TIMES FOUR\n         L     X1,HYANCH(X1)       INITIAL LETTER ANCHOR\n         MVI   HYPRWORD+4,C'0'     DOUBLE SPACE FIRST\n         SPACE\n         USING HYDSECT,X1          TELL THE ASSEMBLER\nHYDUMP02 DS    0H\n         LTR   X1,X1               AT CHAIN END .Q\n         BZ    HYDUMP06            BRANCH OUT IF YES\n         MVI   HYDCWORD+1,L'HYALPHA  INTERNAL BLANK\n         MVC   HYDCWORD+2(L'HYDCWORD-2),HYDCWORD+1  ALL OF IT\n         LM    R0,R1,HYWORD        WORD IF FIVE BIT\n         LA    COUNT,L'HYWORD*8/5  NUMBER CHARS PER WORD\n         LA    TEMP,HYDCWORD(COUNT)     LAST CHAR GOES HERE\nHYDUMP03 DS    0H\n         STC   R1,0(TEMP)          ADD A CHAR\n         NI    0(TEMP),B'00011111' PURIFY INTERNAL RESULT\n         SRDL  R0,5                GET NEXT CHAR\n         BCTR  TEMP,0              PUT NEXT HERE\n         BCT   COUNT,HYDUMP03      DO THEM ALL\n         TR    HYDCWORD,HYALPHA    MAKE RESULT PRINTABLE\n         SPACE\n         UNPK  HYPIND,HYBRK(L'HYBRK+1)  EXPAND BREAK POINTS\n         MVI   HYWKWORD,C' '       BLANK TARGET\n         MVC   HYWKWORD+1(L'HYWKWORD-1),HYWKWORD  ALL OF IT\n         LA    X2,HYDCWORD         FROM CHARACTER POINTER\n         LA    COUNT,HYWKWORD      TO CHARACTER POINTER\n         LA    TEMP,HYPIND         BREAK OFFSET POINTER\nHYDUMP04 DS    0H\n         IC    R1,0(,TEMP)         BREAK OFFSET\n         N     R1,F15              PURIFY IT\n         C     R1,F15              LAST OF BREAKS .Q\n         BE    HYDUMP05            BRANCH OUT IF YES\n         BCTR  R1,0                LENGTH-1 TO BREAK\n         EX    R1,HYDUMPMV         MOVE WORD SYLLABLE\n         LA    X2,1(R1,X2)         BUMP FROM PTR\n         LA    COUNT,1(R1,COUNT)   BUMP TO PTR\n         MVI   0(COUNT),C'-'       ADD HYPHEN CHARACTER\n         LA    COUNT,1(,COUNT)     BUMP TO PTR AGAIN\n         LA    TEMP,1(,TEMP)       BUMP BREAK POINTER\n         B     HYDUMP04            DO TILL EXHAUSTED\n         SPACE\nHYDUMP05 DS    0H\n         LA    R1,HYDCWORD+L'HYDCWORD-1 END OF WORD + BLANKS\n         SR    R1,X2               LENGTH-1 OF RESULT\n         EX    R1,HYDUMPMV         MOVE REMAINDER\n         LA    R0,HYPRWORD         AREA TO DISPLAY\n        $CALL  PRTERM              PRINT ON ERROR FILE\n         MVI   HYPRWORD+4,C' '     SINGLE SPACE REST OF LETTER\n         L     R1,HYPRATAD         INTERNAL LETTER TABLE\n         TR    HYDCWORD(1),0(R1)   INTERNAL FIRST CHARACTER\n         L     X1,HYCHN            NEXT WORD ON CHAIN\n         B     HYDUMP02            AND CONTINUE\n         SPACE\nHYDUMP06 DS    0H\n         BCT   X3,HYDUMP01         DO ALL LETTERS\n         B     HYDRET              GO TO TERMINATION\n         SPACE\nHYDUMPMV MVC   0(*-*,COUNT),0(X2)  EXECUTED MOVE SYLLABLE\nHYDUMPMG DC    AL2(HYDUMPLN,0),C'0'\n         DC    C'HYPHENATION EXCEPTION DICTIONARY WITH'\nHYDUMPNM DC    X'402020202120'\n         DC    C' WORDS.'\nHYDUMPLN EQU   *-HYDUMPMG\n         DROP  X1\n         SPACE\nHYTEST   DS    0H\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION\n        $CALL  GETARG              GET USER'S WORD\n         BC    BOMIT,HYDE003       ERROR IF ARG OMITTED\n         C     TEMP,HYMAXWRD       MAXIMUM WORD LENGTH\n         BNL   HYDE033             BRANCH IF TEST WORD TOO LONG\n         L     X3,BUFF3AD          POINT TO TEMP PRINT BUFFER\n         MVC   0(HYTESTL1,X3),HYTESTM1  ENTER MESSAGE START\n         LA    X3,HYTESTL1(,X3)    FIRST EMPTY SLOT\n         EX    TEMP,HYTESTV1       ENTER CALLER'S WORD\n         LA    X3,1(TEMP,X3)       AFTER CALLER'S WORD\n         MVC   0(HYTESTL2,X3),HYTESTM2  ENTER MESSAGE MIDDLE\n         LA    X3,HYTESTL2(,X3)    BUMP LINE POINTER\n         MVC   HYTESTAR,BLANKS     BLANK TEST WORD AREA\n         EX    TEMP,HYTESTMV       ENTER USER'S WORD\n         MVI   HYTESTAR,X'00'      ALL BREAK POINTS PLEASE\n         LA    R1,HYTESTAR         POINT TO WORK AREA\n        $CALL  HYPHEN              DO YOUR WORST\n         LTR   R15,R15             SUCCESS .Q\n         BNP   HYDE031             BRANCH IF ERROR\n         SPACE\n         SR    R1,R1               CLEAR CHARACTER WORK REG\n         LA    TEMP,1(,TEMP)       ACTUAL USER WORD LENGTH\nHYTEST01 DS    0H\n         MVC   0(1,X3),0(COUNT)    ENTER USER ORIGINAL CHAR\n         TM    0(R15),X'30'        DOES HYPHEN FOLLOW .Q\n         BNO   HYTEST02            BRANCH IF NOT\n         TM    0(R15),X'08'        USER'S OWN HYPHEN .Q\n         BO    HYTEST02            BRANCH IF YES\n         IC    R1,0(,R15)          GET STATUS BYTE\n         SRL   R1,6                REDUCE TO HYPHEN BREAK TYPE\n         IC    R1,HYTYPES(R1)      GET HYPHEN TYPE\n         LA    X3,1(,X3)           POINT TO NEXT OUT CHAR\n         STC   R1,0(,X3)           ENTER APPROPRIATE HYPHEN CHAR\nHYTEST02 DS    0H\n         LA    R15,1(,R15)         NEXT STATUS BYTE\n         LA    COUNT,1(,COUNT)     NEXT USER CHARACTER\n         LA    X3,1(,X3)           NEXT OUTPUT POS'N\n         BCT   TEMP,HYTEST01       DO ALL CHARACTERS\n         L     X1,BUFF3AD          POINT TO RECORD START\n         SR    X3,X1               RECORD LENGTH\n         STH   X3,0(,X1)           SET RECORD LENGTH\n         LR    R0,X1               POINT TO RESULTING RDW\n        $CALL  PRTERM              AND DISPLAY THE RESULT\n         B     HYDRET              AND GO TO RETURN\n         SPACE\nHYTYPES  DS    0CL4                HYPHENATION BREAK CHARS FOR TEST\n         DC    C'*'                X'3X'  YES/NO SCAN HYPHENS\n         DC    C'-'                X'7X'  EXCEPTION DICTIONARY HYPHENS\n         DC    C'/'                X'BX'  SUFFIX ANALYSIS HYPHENS\n         DC    C''''               X'FX'  ALGORITHM HYPHENS\nHYTESTM1 DC    AL2(0,0),C'0',C'HYPHEN TEST OF '\nHYTESTL1 EQU   *-HYTESTM1\nHYTESTM2 DC    C' GIVES '\nHYTESTL2 EQU   *-HYTESTM2\n         SPACE\nHYTESTMV MVC   HYTESTAR+1(*-*),0(COUNT) MOVE USER'S ARGUMENT\nHYTESTV1 MVC   0(*-*,X3),0(COUNT)  MOVE USER'S ORIGINAL WORD\n         SPACE\nHYSUP    DS    0H\n        $ON    SWITCHS,HYSUPSW     SET HYPHEN SUPPRESS FLAG\n         B     HYDRET              AND GO TO RETURN\n         SPACE\nHYSET    DS    0H\n        $CALL  GETYESNO            GET TYPE OF 'SET' CONTROL\n         BC    BOMIT,HYDE003       ERROR IF NOTHING ELSE\n         LA    X1,HYTHRESH         ASSUME 'THRESH'\n         LA    X2,DEFTRSH          ITS DEFAULT DESCRIPTOR\n         CLI   YNRESULT,YNTRSH     'THRESH' REQUEST\n         BE    HYSET01             BRANCH IF YES\n         LA    X1,HYMINPT          ASSUME 'MINPT'\n         LA    X2,DEFMNPT          ITS DEFAULT DESCRIPTOR\n         CLI   YNRESULT,YNMNPT     'MINPT' REQUEST .Q\n         BE    HYSET01             BRANCH IF YES\n         LA    X1,HYENDPT          ASSUME 'ENDPT'\n         LA    X2,DEFENDPT         ITS DEFAULT DESCRIPTOR\n         CLI   YNRESULT,YNENDPT    'ENDPT' REQUEST .Q\n         BE    HYSET01             BRANCH IF YES\n         LA    X1,HYSUPCNT         ASSUME 'SUPPRESS'\n         LA    X2,DEFHYSUP         ITS DEFAULT DESCRIPTOR\n         CLI   YNRESULT,YNSUP      'SUPPRESS' REQUEST .Q\n         BE    HYSET01             BRANCH IF YES\n         B     HYDE005             ALL ELSE IS INVALID\nHYSET01  DS    0H\n        $CALL  GETNUM              GET NUMERIC ARGUMENT\n         BC    BDNO,HYDE005        ERROR IF INVALID\n         BC    BOMIT,HYSET02       BRANCH TO DEFAULT IF OMITTED\n         CLI   NUMSIGN,C' '        WAS OPERAND UNSIGNED .Q\n         BE    HYSET03             BRANCH IF YES\n         AH    COUNT,0(,X1)        MAKE RELATIVE CHANGE\n         B     HYSET03             GO CHECK AND ENTER\nHYSET02  DS    0H\n         L     COUNT,TAB3DEF(,X2)  USE DEFAULT VALUE\nHYSET03  DS    0H\n         C     COUNT,TAB3MIN(,X2)  VALUE TOO SMALL .Q\n         BL    HYDE014             ERROR IF YES\n         C     COUNT,TAB3MAX(,X2)  VALUE TOO BIG .Q\n         BH    HYDE013             ERROR IF YES\n         LTR   COUNT,COUNT         VALUE OF ZERO .Q\n         BNZ   HYSET04             BRANCH IF NOT\n         L     COUNT,TAB3MAX(,X2)  TAKE LARGEST VALUE INSTEAD\nHYSET04  DS    0H\n         STH   COUNT,0(,X1)        SET NEW VALUE\n         MVC   HYSUPWRK,HYSUPCNT   SET WORKING SUPPRESS VALUE\n         B     HYDRET              AND GO TO RETURN\n         SPACE\nHYDE003  DS    0H\n         MVI   EFLAG003,ERRSET     OMITTED OPERAND\n         B     HYDRET              GO TO TERMINATION\nHYDE005  DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     HYDRET              GO TO TERMINATION\nHYDE013  DS    0H\n         MVI   EFLAG013,ERRSET     SET OPERAND TOO BIG\n         B     HYDRET              GO TO RETURN\nHYDE014  DS    0H\n         MVI   EFLAG014,ERRSET     SET OPERAND TOO SMALL\n         B     HYDRET              GO TO TERMINATION\nHYDE024  DS    0H\n         MVI   EFLAG024,ERRSET     NO WORKING STORAGE LEFT\n         B     HYDRET              GO TO TERMINATION\nHYDE030  DS    0H\n         MVI   EFLAG030,ERRSET     HYPHEN DELETE WORD NOT FOUND\n         B     HYDRET              GO TO TERMINATION\nHYDE031  DS    0H\n         MVI   EFLAG031,ERRWARN    INVALID WORD TO HYPHENATE\n         B     HYDRET              GO TO TERMINATION\nHYDE033  DS    0H\n         MVI   EFLAG033,ERRSET     HYPHEN TEST WORD TOO LONG\n         B     HYDRET              GO TO TERMINATION\n         SPACE\nHYDRET   DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#HYSCN": {"ttr": 7178, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00d\\x00d\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 100, "newlines": 100, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              HYSCN  ---  SCAN HYPHENATION WORD                      *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  WORD IN INPUT LINE BUFFER\n*        ON EXIT   --  CC = BDNO   IF SOME ERROR\n*                      CC = BPOS   IF SUCCESSFUL\n*        IF SUCCESSFUL HYPIND(4)  CONTAINS BREAK OFFSETS\n*                      HYWKWORD(8) CONTAINS RESULTING WORD\n*                      (R1) CONTAINS FIRST CHAR IN INTERNAL FORM\n         SPACE\nHYSCN   $ENTER ,\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION\n        $CALL  GETARG              GET HYPHENATED WORD\n         BC    BOMIT,HYEOMIT       ERROR IF OMITTED\n         C     TEMP,HYMAXWRD       MAXIMUM WORD LENGTH\n         BNL   HYETLONG            INVALID IF GREATER\n         L     R1,HYPRATAD         ADDR PRATT FREQUENCY TABLE\n         MVC   HYDCWORD,BLANKS     BLANK TARGET AREA\n         EX    TEMP,HYSMVC         MOVE RESULT TO WORK AREA\n         TR    HYDCWORD,0(R1)      TRANSLATE TO INTERNAL FORM\n         SPACE\n         XC    HYPLAST,HYPLAST     CLEAR POSITION OF LAST HYPHEN\n         MVI   HYPIND,X'FF'        INITIALIZE HYPHEN OFFSETS\n         MVC   HYPIND+1(L'HYPIND-1),HYPIND   ALL OF THEM\n         LA    R1,HYDCWORD         START OF STRING\n         LA    X1,HYWKWORD         START STRIPPED WORD AREA\n         LA    X2,HYPIND           START OF HYPHEN BREAK FIELD\n         SR    COUNT,COUNT         ZERO CHARACTER COUNT\n         MVI   HYALPHSW,X'00'      CLEAR ALPHA SWITCH\n         MVI   HYWKWORD,L'HYALPHA  INTERNAL BLANK TO TARGET\n         MVC   HYWKWORD+1(L'HYWKWORD-1),HYWKWORD  ALL OF IT\n         SPACE\nHYALPHCH EQU   X'01'                    ALPHA CHARACTER SWITCH\nHYS01    DS    0H\n         CLI   0(R1),X'1C'         TEST FOR HYPHEN CHARACTER\n         BE    HYS03               BRANCH IF EQUAL\n         BH    HYS05               BRANCH IF BLANK\nHYS02    DS    0H\n         MVC   0(1,X1),0(R1)       MOVE CHAR TO STRIPPED AREA\n         LA    COUNT,1(,COUNT)     BUMP CHARACTER COUNT\n         LA    X1,1(,X1)           BUMP STRIPPED AREA PTR\n        $ON    HYALPHSW,HYALPHCH   TURN ON CHARACTER SWITCH\n         B     HYS04               GO INCREMENT PTRS\n         SPACE\nHYSMVC   MVC   HYDCWORD(*-*),0(COUNT)   TO WORK AREA\n         SPACE\nHYS03    DS    0H\n        $IFOFF HYALPHSW,HYALPHCH,HYEINVLD    ERROR IF NO ALPHA FIRST\n        $OFF   HYALPHSW,HYALPHCH   RESET PRECEEDING ALPHA SWITCH\n         LA    R0,HYPIND+L'HYPIND-1     LAST BREAK POINT+1 ALLOWED\n         CR    X2,R0               TOO MANY HYPHENS IN WORD .Q\n         BNL   HYETMANY            BRANCH IF TOO MANY\n         S     COUNT,HYPLAST       LENGTH OF CURRENT SYLLABLE\n         C     COUNT,F15           SYLLABLE TOO LONG .Q\n         BNL   HYETLONG            BRANCH IF OVER MAX\n         STC   COUNT,0(,X2)        SYLLABLE LENGTH IN HYPHEN FIELD\n         A     COUNT,HYPLAST       RESTORE NUMBER OF CHARS SO FAR\n         ST    COUNT,HYPLAST       AND SAVE IT\n         LA    X2,1(,X2)           BUMP HYPHEN INDICATION POS'N\n         SPACE\nHYS04    DS    0H\n         LA    R1,1(,R1)           BUMP INPUT POINTER\n         B     HYS01               GET NEXT CHARACTER\n         SPACE\nHYS05    DS    0H\n         CLI   0(R1),X'20'         INVALID CHAR IN INPUT WORD .Q\n         BH    HYEINVLD            BRANCH IF YES\n         MVI   0(X2),X'0F'         SET HYPHEN END INDICATION\n         PACK  HYPIND,HYPIND       PACK HYPHEN INDICATION FIELD\n         MVC   HYPIND(4),HYPIND+4  LEFT ADJUST RETURN VALUE\n         SPACE\n*        THE FOLLOWING ROUTINE DECOMPOSES ALL WORDS GREATER THAN\n*        13 CHARACTERS IN LENGTH, DOWN TO THE MAXIMUM.\n         SPACE\n         BCTR  COUNT,0             GET LENGTH-1\n         STH   COUNT,NUMCHR        SET LENGTH-1 OF WORD STRING\n        $CALL  DCOMPOZ             DECOMPOSE THE WORD\n        $CC    POS                 INDICATE SUCCESS\n         B     HYSRET              AND GO TO TERMINATION\n         SPACE\nHYEOMIT  DS    0H\n         MVI   EFLAG003,ERRSET     OMITTED OPERAND\n         B     HYSERR              ERROR RETURN\nHYEINVLD DS    0H\n         MVI   EFLAG031,ERRSET     INVALID HYPHENATION WORD\n         B     HYSERR              ERROR RETURN\nHYETMANY DS    0H\n         MVI   EFLAG032,ERRSET     TOO MANY BREAK POINTS\n         B     HYSERR              ERROR RETURN\nHYETLONG DS    0H\n         MVI   EFLAG033,ERRSET     HYPHEN WORD TOO LONG\n         B     HYSERR              ERROR RETURN\nHYSERR   DS    0H\n        $CC    DNO                 ERROR CONDITION CODE\n         SPACE\nHYSRET   DS    0H\n        $EXIT  KEEP=(R1),RC=0      RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#IF": {"ttr": 7181, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\xcf\\x00\\xcf\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 207, "newlines": 207, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .IF --- CONDITIONAL CONTROL                            *\n*                                                                     *\n***********************************************************************\n         SPACE\nIF      $ENTER ,\n        $OFF   IFSTAK,IFCWIF       CLEAR .IF SWITCH\n         MVI   IFOP,X'00'          CLEAR OPERATION CODE\n         MVI   IFOPAO,YNOMIT       CLEAR LOGICAL CODE\n         XC    IFLINES,IFLINES     NO 'LINE' ARG POINTER\n         LA    R1,IFSTAK+L'IFSTAK-IFSTAKSP   LAST ENTRY IN .IF STACK\n         OC    0(IFSTAKSP,R1),0(R1)     IS IT AVAILABLE .Q\n         BNZ   IFE04               ERROR IF NOT\nIF01     DS    0H\n        $OFF   SWITCHS,FCHARIF     ASSUME NUMERIC COMPARISON\n        $CALL  GETNUM              TRY FOR A NUMERIC ARG\n         BC    BOMIT,IFE01         OMITTED ARG IS AN ERROR\n         BC    15-BDNO,IF02        BRANCH IF SUCCESSFUL\n         SPACE\n         ST    COUNT,ARGSTART      ELSE RESCAN FOR CHARACTER\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION PLEASE\n        $CALL  GETQST              GET ARGUMENT\n         BC    BDNO,IFE03          ERROR IF MISMATCHED QUOTES\n        $ON    SWITCHS,FCHARIF     CHARACTER COMPARISON\n         LA    TEMP,1(,TEMP)       REAL STRING LENGTH\n         S     TEMP,QSTRING        LESS DELIMITERS\n         CLC   QSTRING,F0          ANY DELIMITERS .Q\n         BE    IF02                BRANCH IF NONE\n         LA    COUNT,1(,COUNT)     START OF STRING\n         SPACE\nIF02     DS    0H\n         ST    TEMP,IFARGLN        SAVE LEFT ARGUMENT LENGTH\n         ST    COUNT,IFARGAD       SAVE LEFT ARGUMENT ADDRESS\n         SPACE\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION PLEASE\n        $CALL  GETARG              LOCATE OPERATOR\n         BC    BOMIT,IFE05         (NONE => ERROR)\n         LA    R1,L'IFOPTB-1       MAX OPERATOR LENGTH\n         CR    TEMP,R1             TOO LONG .Q\n         BNL   IFE05               ERROR IF YES\n         XC    IFOPCH,IFOPCH       CLEAR OPERATOR WORK AREA\n         EX    TEMP,IFOPMVC        MOVE COMPARISON OPERATOR\n         OC    IFOPCH,BLANKS       UPPER CASE PLEASE\n         LA    R0,L'IFOPTB         INCREMENT TO BXLE\n         LA    R1,IFOPTBE          ADDRESS OF LAST TABLE ENTRY\n         LA    X1,IFOPTB           ADDRESS OF FIRST ENTRY\n         LA    TEMP,1(,TEMP)       GET ACTUAL OPERAND LENGTH\n         SPACE\nIF03     DS    0H\n         EX    TEMP,IFOPCLC        CHECK FOR OPERATOR EQUALITY\n         BE    IF04                IF YES, QUIT\n         BXLE  X1,R0,IF03          KEEP LOOKING\n         B     IFE05               (NOT FOUND => ERROR)\n         SPACE\nIF04     DS    0H\n         MVC   IFOP,L'IFOPTB-1(X1) SAVE CONDITION CODE FOR COMPARE\n         SPACE\n        $IFON  SWITCHS,FCHARIF,IF05 SKIP IF CHARACTER ARGUMENT\n        $CALL  GETNUM              NUMERIC. GET IT\n         BC    BOMIT+BDNO,IFE02    ERROR IF OMITTED OR INVALID\n         BAL   RETURN,IFPUSH       PUSH CURRENT .IF STACK\n         L     TEMP,IFARGAD        LOAD LEFT ARGUMENT ADDRESS\n         IC    R1,IFOP             GET CONDITION CODE\n         CR    TEMP,COUNT          COMPARE VALUES\n         EX    R1,IFREL            TEST RELATION\n         B     IF10                RELATION UNTRUE\n         SPACE\nIF05     DS    0H\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION\n        $CALL  GETQST              GET CHARACTER ARGUMENT\n         BC    BOMIT,IFE02         (NONE => ERROR)\n         BC    BDNO,IFE03          ERROR IF MISMATCHED QUOTES\n         LA    TEMP,1(,TEMP)       REAL SECOND STRING LENGTH\n         S     TEMP,QSTRING        LESS DELIMITER COUNT\n         CLC   QSTRING,F0          ANY DELIMITERS .Q\n         BE    IF06                BRANCH IF NONE\n         LA    COUNT,1(,COUNT)     START OF STRING\nIF06     DS    0H\n         L     R1,IFARGLN          CHARACTER COMPARE, GET LENGTH ARG1\n         LR    R0,R1               REMEMBER ORIGINAL ARG1 LENGTH\n         CR    R0,TEMP             COMPARE LENGTHS\n         BNH   IF07                BRANCH IF 1ST EQUAL OR SHORT\n         LR    R1,TEMP             TAKE LESSER OF TWO\nIF07     DS    0H\n         BAL   RETURN,IFPUSH       PUSH CURRENT .IF STACK\n         LTR   R1,R1               WAS ONE OR BOTH NULL .Q\n         BZ    IF08                BRANCH IF YES\n         BCTR  R1,0                LENGTH-1 FOR COMPARE\n         L     X3,IFARGAD          GET ADDRESS OF ARG1\n         EX    R1,IFCLC            COMPARE ARGUMENTS\n         BNE   IF09                BRANCH IF ARGS DISTINGUISH\nIF08     DS    0H\n         CR    R0,TEMP             EQUAL, LENGTH ALONE COUNTS\nIF09     DS    0H\n         IC    R1,IFOP             LOAD CONDITION CODE\n         EX    R1,IFREL            TEST RELATIONAL OPERATOR\nIF10     DS    0H\n         CLI   IFOPAO,YNOR         FORMER LOGICAL AN 'OR' .Q\n         BE    IF12                YES, CURRENT VALUE STAYS\n        $ON    IFSTAK,IFFALSE      .IF WAS FALSE\n        $OFF   IFSTAK,IFTRUE       AND NOT TRUE\n         B     IF12                BRANCH TO RETURN\nIF11     DS    0H\n         CLI   IFOPAO,YNAND        FORMER LOGICAL AN 'AND' .Q\n         BE    IF12                YES, CURRENT VALUE STAYS\n        $ON    IFSTAK,IFTRUE       .IF WAS TRUE\n        $OFF   IFSTAK,IFFALSE      AND NOT FALSE\nIF12     DS    0H\n         XC    IFLINES,IFLINES     CLEAR POTENTIAL 'LINE' ARG START\n         L     X1,ARGSTART         GET POTENTIAL 'LINE' ARG START\n        $CALL  GETYESNO            GET AND TEST ARG\n         BC    BOMIT,IF14          BRANCH IF NOTHING\n         ST    X1,IFLINES          THIS MIGHT BE IT LATER\n         CLI   YNRESULT,YNAND      LOGICAL 'AND' .Q\n         BE    IF13                BRANCH IF YES\n         CLI   YNRESULT,YNOR       LOGICAL 'OR' .Q\n         BE    IF13                BRANCH IF YES\n         B     IF14                GO HANDLE WHAT WE DO HAVE\n         SPACE\nIF13     DS    0H\n         MVC   IFOPAO,YNRESULT     SAVE LOGICAL OPERATOR\n         B     IF01                AND GET NEXT COMPARISON\n         SPACE\nIF14     DS    0H\n        $IFOFF IFSTAK+IFSTAKSP,IFTHEN,IF15   BR IF NOT OBJECT OF .TH\n        $IFOFF IFSTAK+IFSTAKSP,IFFALSE,IF16  BR IF LAST .IF TRUE\n        $ON    IFSTAK,(IFTRUE,IFFALSE)  FALSE, SO PROCESS NOTHING\n         B     IF16                BRANCH TO RETURN\nIF15     DS    0H\n        $IFOFF IFSTAK+IFSTAKSP,IFELSE,IF16   BR IF NOT OBJECT OF .EL\n        $IFOFF IFSTAK+IFSTAKSP,IFTRUE,IF16   BR IF LAST .IF FALSE\n        $ON    IFSTAK,(IFTRUE,IFFALSE)  TRUE, SO PROCESS NOTHING\n         SPACE\nIF16     DS    0H\n         L     R15,IFLINES         GET 'LINE' ARG POINTER\n         LTR   R15,R15             ANY 'LINE' ARG PRESENT .Q\n         BZ    IF17                IF NOT, USE NEXT REAL LINE\n         ST    R15,ARGSTART        SET 'LINE' ARG POINTER\n        $CALL  USARG               MOVE ARG INTO BUFFER\n         LA    R15,WRETNR          PROCESS THE RESULT\nIF17     DS    0H\n        $EXIT  RC=(R15)            AND RETURN TO CALLER\n         SPACE\nIFPUSH   DS    0H\n         CLI   IFOPAO,YNOMIT       FIRST TIME TO PUSH .Q\n         BNE   IFPUSH01            BRANCH IF NOT\n         L     X3,BUFF3AD          WORKING TEMPORARY BUFFER\n         MVC   4(L'IFSTAK-IFSTAKSP,X3),IFSTAK     .IF STACK TO TEMP\n         MVC   IFSTAK+IFSTAKSP(L'IFSTAK-IFSTAKSP),4(X3)     DOWN ONE\n         XC    IFSTAK(IFSTAKSP),IFSTAK  CLEAR TOP ENTRY\n        $ON    IFSTAK,IFLAST       SET .IF SWITCH\nIFPUSH01 DS    0H\n         BR    RETURN              AND RETURN TO CALLER\n         SPACE\nIFE01    DS    0H\n         OC    IFLINES,IFLINES     ANY ARG LINE POSSIBLE .Q\n         BNZ   IF14                YES, USE IT\n         MVI   EFLAG003,ERRSET     OMITTED OPERAND\n         B     IF16                AND TAKE EXIT\nIFE02    DS    0H\n         OC    IFLINES,IFLINES     ANY ARG LINE POSSIBLE .Q\n         BNZ   IF14                YES, USE IT\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     IF16                AND TAKE EXIT\nIFE03    DS    0H\n         OC    IFLINES,IFLINES     ANY ARG LINE POSSIBLE .Q\n         BNZ   IF14                YES, USE IT\n         MVI   EFLAG015,ERRSET     MISMATCHED QUOTES\n         B     IF16                AND TAKE EXIT\nIFE04    DS    0H\n         OC    IFLINES,IFLINES     ANY ARG LINE POSSIBLE .Q\n         BNZ   IF14                YES, USE IT\n         MVI   EFLAG022,ERRSET     IF STACK FULL\n         B     IF16                AND TAKE EXIT\nIFE05    DS    0H\n         OC    IFLINES,IFLINES     ANY ARG LINE POSSIBLE .Q\n         BNZ   IF14                YES, USE IT\n         MVI   EFLAG040,ERRSET     INVALID COMPARISON OPERATOR\n         B     IF16                TAKE EXIT\n         SPACE\nIFREL    BC    *-*,IF11            TEST SUCCESS OF COMPARISON\nIFCLC    CLC   0(*-*,X3),0(COUNT)  COMPARES CHARACTER STRINGS\nIFOPCLC  CLC   0(*-*,X1),IFOPCH    IS THIS THE OPERATOR .Q\nIFOPMVC  MVC   IFOPCH(*-*),0(COUNT)     MOVE OPERATOR TO WORK\n         SPACE\nIFOPCH   EQU   SAVED1,8,C'C'       OPERATOR COMPARE WORK AREA\nIFARGAD  EQU   SAVEF0,4,C'A'       ADDRESS OF LEFT ARGUMENT\nIFARGLN  EQU   SAVEF1,4,C'A'       LENGTH OF LEFT ARGUMENT\nIFLINES  EQU   SAVEH0,4,C'A'       ADDR OF 'LINE' ARG START\nIFOP     EQU   SAVEX0,1,C'X'       CONDITION CODE FOR BRANCH SWITCH\nIFOPAO   EQU   SAVEX1,1,C'X'       LAST LOGICAL OPERATION\n         SPACE\nIFOPTB   DC    0CL5'OPOPC'         ORIGIN OF OPERATOR TABLE\n         DC    CL4'=',X'80'        =  (CL4'OP',X'CC')\n         DC    CL4'\u00ac=',X'70'       \u00ac=\n         DC    CL4'<',X'40'        <\n         DC    CL4'>',X'20'        >\n         DC    CL4'<=',X'C0'       < OR =\n         DC    CL4'>=',X'A0'       > OR =\n         DC    CL4'EQ',X'80'       EQUAL\n         DC    CL4'NE',X'70'       NOT EQUAL\n         DC    CL4'LT',X'40'       LESS THAN\n         DC    CL4'GT',X'20'       GREATER THAN\n         DC    CL4'LE',X'C0'       LESS THAN OR EQUAL\n         DC    CL4'GE',X'A0'       GREATER THAN OR EQUAL\nIFOPTBE  EQU   *-L'IFOPTB          ADDRESS OF LAST ENTRY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#IL": {"ttr": 7428, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00,\\x00,\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .IL (INDENT LINE) --- CONTROL                          *\n*                                                                     *\n***********************************************************************\n         SPACE\nIL      $ENTER ,\n        $CALL  PRINTNB             BREAK\n        $CALL  GETNUM              GET AMOUNT\n         BC    BDNO,ILE005         ERROR IF INVALID\n         BC    BOMIT,IL01          TAKE DEFAULT IF OMITTED\n         LCR   COUNT,COUNT         INDENT LINE IS INVERSE OF UNDENT\n         CLI   NUMSIGN,C' '        WAS OPERAND UNSIGNED .Q\n         BE    IL02                BRANCH IF YES\n         AH    COUNT,UNDL          MAKE RELATIVE CHANGE\n         B     IL02                GO CHECK AND ENTER\nIL01     DS    0H\n         SR    COUNT,COUNT         ZERO IS DEFAULT\nIL02     DS    0H\n         L     R1,LLZ              GET LINE LENGTH\n         AH    R1,INDENTR          PLUS RIGHT INDENT\n         LCR   R1,R1               MAKE IT NEGATIVE\n         CR    COUNT,R1            IS VALUE TOO SMALL .Q\n         BNH   ILE014              TOO SMALL IF NOT\n         CH    COUNT,INDL          COMPARE WITH INDENT\n         BH    ILE013              ERROR IF LARGER\n         STH   COUNT,UNDL          SET UNDENTATION\n         STH   COUNT,OFUNCNT       SET MARGIN VALUE FOR FORMAT\n         SH    COUNT,INDL          LESS CURRENT INDENT\n         LCR   COUNT,COUNT         POSITIVE VALUE\n         STH   COUNT,RMARGIN       SET RIGHT MARGIN\n         SPACE\nIL03     DS    0H\n        $EXIT  RC=0                AND CONTINUE\n         SPACE\nILE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     IL03                AND GO TO RETURN\nILE013   DS    0H\n         MVI   EFLAG013,ERRSET     OPERAND TOO BIG\n         B     IL03                AND GO TO RETURN\nILE014   DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     IL03                AND GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#IM": {"ttr": 7430, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .IMBED (.IM) --- CONTROL                               *\n*                                                                     *\n***********************************************************************\n         SPACE\nIM      $ENTER ,\n         XC    APIMFLAG,APIMFLAG   CLEAR FILE FLAGS\n        $ON    APIMFLAG,IO$IM      TURN IMBED FLAG ON\n        $CALL  API                 CHECK FILENAME\n        $EXIT  RC=0                AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#IN": {"ttr": 7432, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00h\\x00h\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 104, "newlines": 104, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .IN (INDENT) --- CONTROL                               *\n*                                                                     *\n***********************************************************************\n         SPACE\nIN      $ENTER ,\n        $CALL  PRINTNB             CLEAR OUT PRINT BUFFER\n        $CALL  GETYESNO            LOCATE FIRST ARGUMENT\n         BC    BOMIT,IN01          BRANCH TO DEFAULT IF OMITTED\n         CLI   YNRESULT,YNASTK     IS FIRST A '*' PLACE HOLDER .Q\n         BE    IN03                BRANCH IF YES\n         ST    COUNT,ARGSTART      ELSE RESCAN FOR NUMERIC\n        $CALL  GETNUM              GET AMOUNT OF INDENTION\n         BC    BDNO,INE005         ERROR IF INVALID\n         CLI   NUMSIGN,C' '        WAS OPERAND SIGNED .Q\n         BE    IN02                BRANCH IF NOT\n         AH    COUNT,INDL          MODIFY EXISTING INDENT VALUE\n         AH    COUNT,OFFLI         PLUS UNTRIGGERED OFFSET (IF ANY)\n         SH    COUNT,OFFL          AND MODIFY WITH OFFSET VALUE\n         BNM   IN02                BRANCH NOT MINUS\nIN01     DS    0H\n         SR    COUNT,COUNT         DEFAULT VALUE OF ZERO\nIN02     DS    0H\n         C     COUNT,LLZ           COMPARE WITH LINE LENGTH\n         BH    INE013              TOO BIG IF GREATER\n         STH   COUNT,INDL          SET INDENT VALUE\n         SH    COUNT,UNDL          CALCULATE CURRENT MARGIN\n         BM    INE014              TEST FOR ILLEGAL\n         STH   COUNT,RMARGIN       SET MARGIN (EFFECTIVE INDENT)\n         SR    R0,R0               CLEAR WORK REGISTER\n         STH   R0,OFFL             CLEAR OFFSET VALUE\n         STH   R0,OFFLI            CLEAR NEXT OFFSET VALUE\n         STH   R0,OFUNCNT          CLEAR MARGIN VALUE FOR FORMAT\n         SPACE\nIN03     DS    0H\n        $CALL  GETYESNO            SCAN SECOND ARGUMENT\n         BC    BOMIT,IN05          GO TO DEFAULT IF OMITTED\n         CLI   YNRESULT,YNASTK     '*' MEANS LEAVE OPERAND ALONE .Q\n         BNE   IN04                BRANCH IF NOT\n         LH    COUNT,INDENTR       GET CURRENT VALUE\n         B     IN06                GO CHECK FURTHER\nIN04     DS    0H\n         ST    COUNT,ARGSTART      RESCAN FOR NUMERIC\n        $CALL  GETNUM              GET SECOND NUMERIC OPERAND\n         BC    BDNO,INE005         ERROR IF INVALID\n         CLI   NUMSIGN,C' '        WAS ARGUMENT SIGNED .Q\n         BE    IN06                BRANCH IF NOT\n         AH    COUNT,INDENTR       MAKE RELATIVE CHANGE\n         B     IN06                CHECK FURTHER\nIN05     DS    0H\n         SR    COUNT,COUNT         DEFAULT CLEARS RIGHT INDENT\nIN06     DS    0H\n         XC    INDENTR,INDENTR     CLEAR RIGHT INDENT IN CASE OF ERROR\n         L     R1,LLZ              GET CURRENT LINE LENGTH\n         SH    R1,INDL             LESS INDENT FROM LEFT\n         AR    R1,COUNT            PLUS INDENT TO RIGHT\n         C     R1,DEFLL+TAB3MIN    COMPARE WITH MIN ALLOWED\n         BL    INE014              BRANCH IF TOO SMALL\n         LR    R1,COUNT            INDENT FROM RIGHT\n         A     R1,LLZ              PLUS LINE LENGTH\n         C     R1,DEFLL+TAB3MAX    COMPARE WITH MAX ALLOWED\n         BH    INE013              BRANCH IF TOO BIG\n         STH   COUNT,INDENTR       SET NEW RIGHT INDENT VALUE\n         SPACE\n         L     X1,OLDCOUNT         COUNT OF LINKED CHARACTER BLOCKS\n         LTR   X1,X1               ANY PRESENT .Q\n         BZ    IN07                BRANCH IF NOT\n         L     X1,NOCHARS          NUMBER OF CHARACTERS NOW FORMATTED\n         LTR   X1,X1               WAS IMPLIED BREAK SUCCESSFUL .Q\n         BZ    IN07                BRANCH IF YES\n         SPACE\n         L     TEMP,OLDFIRST       FIRST LINK ELEMENT\n         USING LINKELEM,TEMP       AND TELL THE ASSEMBLER\n         SR    X2,X2               ZERO WORK REGISTER\n         IC    X2,LINKMULT         INITIAL DUMMY BLANK MULT FACTOR\n         LH    R1,INDL             NEW INDENT VALUE\n         LA    R1,1(R1,X1)         NEW TOTAL LENGTH PLUS DUMMY\n         SR    R1,X2               LESS OLD INDENT VALUE\n         L     R0,LLZ              CURRENT LINE LENGTH\n         AH    R0,INDENTR          PLUS RIGHT INDENT VALUE\n         CR    R1,R0               NEW VALUE FIT ON CURRENT LINE .Q\n         BH    IN07                BRANCH TO RETURN IF NOT\n         ST    R1,NOCHARS          SET NEW LINE LENGTH\n         SR    R1,X1               NEW LINE LENGTH CHANGE\n         AR    X2,R1               ALTERATION ON FIRST DUMMY BLANK\n         STC   X2,LINKMULT         UPDATE LEADING DUMMY BLANK COUNT\n         DROP  TEMP\n         SPACE\nIN07     DS    0H\n         B     IN08                COMMON EXIT\n         SPACE\nINE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID ARGUMENT\n         B     IN08                COMMON EXIT\nINE013   DS    0H\n         MVI   EFLAG013,ERRSET     ARGUMENT TOO LARGE\n         B     IN08                COMMON EXIT\nINE014   DS    0H\n         MVI   EFLAG014,ERRSET     ARGUMENT TOO SMALL\n         B     IN08                COMMON EXIT\n         SPACE\nIN08     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#IOADJ": {"ttr": 7435, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00M\\x00M\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 77, "newlines": 77, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTION 'IOADJ' --- EVEN/ODD PAGE ADJUST     *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER  ---   LA    R0,RDW OF OUTPUT LINE\n*                       $CALL  IOADJ\n*\n*        ON EXIT   ---  (R0) -> OLD/NEW RDW OF OUTPUT LINE\n         SPACE\nIOADJ   $ENTER ,\n         LH    X3,ADJCEVN          ASSUME EVEN PAGE\n        $CALL  ODDEVN              GO AND CHECK\n         BC    BPOS,IOADJ01        BRANCH IF EVEN PAGE\n         LH    X3,ADJCODD          GET ODD PAGE ADJUST\nIOADJ01  DS    0H\n         LTR   X3,X3               ANY VALUE PRESENT\n         BNP   IOADJ05             BRANCH IF NOTHING\n         SPACE\n         L     X1,ADJBUFFA         EVEN/ODD ADJUST WORK BUFFER\n         LTR   X1,X1               DOES IT EXIST .Q\n         BNZ   IOADJ02             BRANCH IF YES\n         LA    R1,B2LG+4           LENGTH OF A WORK BUFFER\n        $CALL  GETCELL             GET SOME SPACE\n         BC    BNEG,IOADJ06        BRANCH IF FAILED\n         LR    X1,TEMP             ADDR OF AREA GOT\n         ST    X1,ADJBUFFA         RETAIN WORK BUFFER ADDR\n         SPACE\nIOADJ02  DS    0H\n         LR    TEMP,R0             POINT TO RDW AND DATA\n         LH    COUNT,0(,TEMP)      LENGTH OF DATA AND RDW\n         XC    0(4,X1),0(X1)       CLEAR THE NEW RDW\n        $IFOFF TTYPE,TONLINE,IOADJ03    BRANCH IF NOT ONLINE\n         EX    X3,IOADJBMV         BLANK ADJUST AMOUNT\n         LA    X2,4(X3,X1)         OLD DATA TARGET ADDRESS\n         S     COUNT,F5            LENGTH-1 OF DATA\n         EX    COUNT,IOADJDMV      MOVE ONLINE DATA\n         LA    COUNT,5(X3,COUNT)   NEW LENGTH\n         STH   COUNT,0(,X1)        SAVE NEW LENGTH\n         LR    R0,X1               POINT TO RESULT\n         B     IOADJ05             GO TO RETURN\n         SPACE\nIOADJ03  DS    0H\n         LA    X2,BLNKRDWL         LENGTH OF A BLANK LINE\n         CR    X2,COUNT            A CANDIDATE .Q\n         BNE   IOADJ04             BRANCH IF NOT\n         CLI   5(TEMP),C' '        BLANK DATA .Q\n         BNE   IOADJ04             BRANCH IF NOT\n         CLI   4(TEMP),SINGLSP     SINGLE SPACE BLANK .Q\n         BE    IOADJ05             QUIT IF YES\n         CLI   4(TEMP),DOUBLSP     DOUBLE SPACE BLANK .Q\n         BE    IOADJ05             QUIT IF YES\n         CLI   4(TEMP),TRIPLSP     TRIPLE SPACE BLANK .Q\n         BE    IOADJ05             QUIT IF YES\nIOADJ04  DS    0H\n         EX    X3,IOADJBMV         BLANK ADJUST\n         MVC   4(1,X1),4(TEMP)     RETAIN CARRIAGE CONTROL\n         LA    X2,5(X3,X1)         DATA TARGET ADDRESS\n         S     COUNT,F6            LENGTH-1 OF DATA\n         EX    COUNT,IOADJEMV      MOVE OFFLINE DATA\n         LA    COUNT,6(X3,COUNT)   NEW LENGTH\n         STH   COUNT,0(,X1)        SAVE NEW LENGTH\n         LR    R0,X1               POINT TO RESULT\n         B     IOADJ05             GO TO RETURN\n         SPACE\nIOADJ05  DS    0H\n        $RESTOR KEEP=(R0)          RESTORE CALLER'S REGS\n         BR    RETURN              AND RETURN TO CALLER\n         SPACE\nIOADJ06  DS    0H\n         MVI   EFLAG024,ERRSET     NO WORK SPACE AVAILABLE\n         B     IOADJ05             AND GO TO RETURN\n         SPACE\nIOADJBMV MVC   4(*-*,X1),BLANKS    LEADING BLANK MOVE\nIOADJDMV MVC   0(*-*,X2),4(TEMP)   ONLINE DATA MOVE\nIOADJEMV MVC   0(*-*,X2),5(TEMP)   OFFLINE DATA MOVE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#IOPRINT": {"ttr": 7438, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00Z\\x00Z\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 90, "newlines": 90, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTION 'IOPRINT' --- OUTPUT LINE            *\n*                                                                     *\n***********************************************************************\n         SPACE\nIOPRINT $ENTER ,\nIOPRI01  DS    0H\n        $IFOFF SWITCHS,FEMPTY,IOPRI05   BRANCH IF PAGE NOT EMPTY\n         SPACE\n        $SAVE  ,                   PRINT HEADER LINE AND MARGIN FIRST\n         LH    X1,PLCT             WE KNOW THAT WE'RE REALLY AT THE\n         MVC   PLCT,PLZ            SET LINES LEFT ON EMPTY PAGE\n        $CALL  PAGETOP             PRINT TOP TITLES AND FLOATING KEEPS\n        $CALL  PRSKSPC             PROCESS ANY EXTRA SKIP/SPACE REQUEST\n        $CALL  RMNEXT              SETUP FOR NEXT REMOTE\n         CLC   PLCT,RMTRIG         REMOTE SET FOR PAGE TOP .Q\n         BNE   IOPRI02             IF NOT, SKIP\n         LH    R1,RMTRIG           REMOTE TO IMBED\n        $CALL  RMIMBED             YES, TRIGGER IT\nIOPRI02  DS    0H\n         LH    TEMP,PLZ            DO THE SUBTRACTION THAT OUR CALLER\n         SR    TEMP,X1             DID FOR THE PAGE LENGTH COUNTER\n         SH    TEMP,PLCT           ..\n         LPR   TEMP,TEMP           ..\n         LH    R1,BMMRG            BOTTOM MARGIN\n         AH    R1,FNSEP            PLUS FOOTNOTE MARGIN\n         CR    TEMP,R1             IS PAGE EXACTLY FULL .Q\n         BNL   IOPRI03             BRANCH IF NOT\n        $CALL  PAGE                FINISH OFF THIS PAGE\n         STH   X1,PLCT             RETAIN CALLER'S ORIGINAL VALUE\n         B     IOPRI04             AND GO START THE NEXT\nIOPRI03  DS    0H\n         STH   TEMP,PLCT           SET NEW LINES LEFT ON THIS PAGE\n        $CALL  RMNEXT              SETUP FOR NEXT REMOTE (IF ANY)\nIOPRI04  DS    0H\n        $RESTOR ,                  RESTORE REGISTERS\n         B     IOPRI01             TRY AGAIN TO PRINT THE LINE\n         SPACE\nIOPRI05  DS    0H\n        $IFON  SWITCHS,OOSWS,IOPRI07    BRANCH IF DISABLED\n         L     R1,OOANCH           OUTPUT OVERLAY ANCHOR\n         LTR   R1,R1               ANYTHING PRESENT .Q\n         BZ    IOPRI06             BRANCH IF NOT\n        $CALL  OOPRT               PROCESS OUTPUT OVERLAY\nIOPRI06  DS    0H\n         L     R1,BXPTR            BOX BUILDING POINTER\n         LTR   R1,R1               ANYTHING PRESENT .Q\n         BZ    IOPRI07             BRANCH IF NOT\n        $CALL  BXVERT              PRINT SIDES OF BOX\n         SPACE\nIOPRI07  DS    0H\n         CLI   ICOLFLG,ICOLMC      IN MULTI-COLUMN MODE .Q\n         BNE   IOPRI08             BRANCH IF NOT\n        $CALL  COLSAVE             SAVE THIS COLUMN OF DATA\n         B     IOPRI12             AND GO TO RETURN\n         SPACE\nIOPRI08  DS    0H\n         CLC   PASSNO,DEFPASOF+TAB3DEF  IS THIS THE LAST PASS .Q\n         BNE   IOPRI12             GO TO RETURN NOW IF NOT\n        $IFON  SWITCHS,NPSWS,IOPRI12    RETURN IF NO PRINT MODE\n         SPACE\n         L     R1,DEFLNUM+TAB3DEF  GET LINE NUMBER COLUMN OFFSET\n         LTR   R1,R1               IS IT POSITIVE .Q\n         BNP   IOPRI09             BRANCH AROUND IF NOT\n        $CALL  PRLIN               ENTER LINE NUMBER INTO OUTPUT\n         SPACE\nIOPRI09  DS    0H\n        $IFON  TTYPE,TONLINE,IOPRI10    PRINT DIRECT IF ONLINE\n         LR    R1,R0               RECORD ADDRESS\n         CLI   4(R1),SUPRSPAC      A PRINTER OVERLAY LINE .Q\n         BE    IOPRI10             NO CHANNEL SKIPS IF YES\n         LH    X1,PLZ              PAGE LENGTH\n         SH    X1,PLCT             LESS LINES LEFT ON PAGE\n         C     X1,DEFFFTO+TAB3DEF  TOP OF FORM LINE .Q\n         BNE   IOPRI10             BRANCH IF NOT\n         MVC   4(1,R1),DEFFFCH+TAB3DEF+3     SKIP TO CHANNEL\n         OI    4(R1),C'0'          CHARACTER VALUE\nIOPRI10  DS    0H\n         LH    X1,ADJCEVN          EVEN PAGE ADJUST\n         AH    X1,ADJCODD          PLUS ODD PAGE ADJUST\n         BZ    IOPRI11             BRANCH IF NOTHING\n        $CALL  IOADJ               ADJUST THIS LINE FURTHER\n         SPACE\nIOPRI11  DS    0H\n        $CALL  SCRIPUT             GO AND PRINT THE LINE\n         SPACE\nIOPRI12  DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#IX": {"ttr": 7441, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00r\\x00r\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 114, "newlines": 114, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .IX (INDEX) --- CONTROL                                *\n*                                                                     *\n***********************************************************************\n         SPACE\nIX      $ENTER ,\n         SR    X1,X1               ZERO POINTER TARGET OFFSET\n         XC    IXPTRS(IXPTRL),IXPTRS    INITIALIZE PARSE POINTERS\n        $CALL  PNUMFMT             FORMAT CURRENT PAGE NUMBER\n         LA    R0,EBCDPAGE         RESULT LIES HERE\n         ST    R0,IXPARM           ENTER ADDRESS OF RESULT\n         STC   COUNT,IXPARM        AND ITS LENGTH-1\n        $CALL  GETNUM              GET FIRST OPTIONAL ARG\n         BC    BOMIT,IXE003        ERROR IF NONE FOUND\n         BC    BDNO,IX00           NOT NUMERIC, THEN BRANCH\n         LTR   X3,COUNT            TEST THE RESULT\n         BNP   IXE014              ERROR IF TOO SMALL\n         LA    R0,IXVCNT           MAXIMUM VALUE\n         CR    X3,R0               TOO BIG .Q\n         BH    IXE013              ERROR IF TOO BIG\n         BCTR  X3,0                OFFSET MINUS ONE\n         SLL   X3,2                TIMES FOUR GIVES REAL VECTOR OFFSET\n         B     IX01                PROCESS ARGS NOW\nIX00     DS    0H\n         ST    COUNT,ARGSTART      RESCAN FOR STRING OPERAND\n         SR    X3,X3               FIRST ENTRY OF VECTOR DEFAULTS\n         SPACE\nIX01     DS    0H\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION PLEASE\n        $CALL  GETARG              GET AN ARGUMENT\n         BC    BOMIT,IX04          BRANCH IF NONE LEFT\n         LA    R0,IXPTRL           MAXIMUM OFFSET TO OVERFLOW\n         CR    X1,R0               TOO MANY ENTRIES .Q\n         BNL   IXE005              ERROR IF YES\n         LTR   TEMP,TEMP           OPERAND LENGTH-1 OF ZERO .Q\n         BNZ   IX02                BRANCH IF NOT\n         CLC   PERIND(1),0(COUNT)  A DIVISION OF THE WATERS .Q\n         BNE   IX02                BRANCH IF NOT\n         LTR   X1,X1               FIRST OPERAND .Q\n         BZ    IX05                SPECIAL CASE OPERAND IF YES\n         LA    X1,IXPARM-IXPTRS    NEXT ENTRY GOES HERE\n         SR    R0,R0               SET NO LENGTH AND ADDRESS\n         ST    R0,IXPTRS(X1)       INITIALIZE REFERENCE PARM\n         B     IX01                AND SET RESULT\nIX02     DS    0H\n         ST    COUNT,ARGSTART      RESCAN FOR (QUOTED) STRING\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION PLEASE\n        $CALL  GETQST              GET AN ARGUMENT\n         CLC   QSTRING,F1          MISMATCHED QUOTES .Q\n         BE    IXE015              ERROR IF YES\n         S     TEMP,QSTRING        LESS STRING DELIMITERS\n         BNM   IX02A               BRANCH IF NOT NULL RESULT\n         LTR   X1,X1               FIRST OPERAND .Q\n         BZ    IXE005              IF YES, OPERAND INVALID\n         SR    COUNT,COUNT         NO ARG POINTER\n         B     IX03                ENTER AND CONTINUE\nIX02A    DS    0H\n         CLC   QSTRING,F0          ANY DELIMITERS .Q\n         BE    IX03                BRANCH IF NONE\n         LA    COUNT,1(,COUNT)     START OF STRING PTR\nIX03     DS    0H\n         LA    R0,IXEBTXTA-1-2     MAX LENGTH-1 OF TEST AND ', '\n         CR    TEMP,R0             THIS ENTRY TOO LONG .Q\n         BH    IXE013              ERROR IF YES\n         ST    COUNT,IXPTRS(X1)    ENTER OPERAND POINTER\n         STC   TEMP,IXPTRS(X1)     AND ITS LENGTH-1\n         LA    X1,L'IXPTRS(,X1)    NEXT OPERAND OFFSET\n         LA    R0,IXPTRE-IXPTRS    END PARM POINTER OFFSET\n         CR    R0,X1               ARE WE THERE .Q\n         BNE   IX01                BRANCH IF NOT\n         LA    X1,IXPARM-IXPTRS    OFFSET TO REFERENCE PARM\n         B     IX01                TRY FOR NEXT OPERAND\nIX04     DS    0H\n         LTR   X1,X1               ANY OPERANDS FOUND .Q\n         BZ    IXE003              ERROR IF NONE\n         LA    R1,IXANCHV(X3)      POINT TO APPROPRIATE ANCHOR\n        $CALL  IXPROC              PROCESS THE RESULT\n         B     IX09                AND GO TO RETURN\n         SPACE\nIX05     DS    0H\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         CLI   YNRESULT,YNDUMP     WAS OPERAND 'DUMP' .Q\n         BE    IX06                BRANCH IF YES\n         CLI   YNRESULT,YNPUR      WAS OPERAND 'PURGE' .Q\n         BE    IX07                BRANCH IF YES\n         B     IXE005              ELSE WE HAVE AN ERROR\nIX06     DS    0H\n         LA    R1,IXANCHV(X3)      POINT TO APPROPRIATE ANCHOR\n        $CALL  IXDUMP              EMPTY INFORMATION COLLECTED\n         B     IX09                GO TO RETURN\nIX07     DS    0H\n         LA    R1,IXANCHV(X3)      POINT TO APPROPRIATE ANCHOR\n        $CALL  IXCLR               PURGE INFORMATION COLLECTED\n         B     IX09                GO TO RETURN\n         SPACE\nIX09     DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\nIXE003   DS    0H\n         MVI   EFLAG003,ERRSET     OMITTED OPERAND\n         B     IX09                GO TO RETURN\nIXE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     IX09                GO TO RETURN\nIXE013   DS    0H\n         MVI   EFLAG013,ERRSET     OPERAND TOO LONG\n         B     IX09                GO TO RETURN\nIXE014   DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     IX09                GO TO RETURN\nIXE015   DS    0H\n         MVI   EFLAG015,ERRSET     MISMATCHED QUOTES\n         B     IX09                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#IXCLR": {"ttr": 7683, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00>\\x00>\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 62, "newlines": 62, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTION 'IXCLR' -- PURGE INDEX               *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER  --   LA    R1,INDEX ANCHOR POINTER\n*                      $CALL  IXCLR\n         SPACE\nIXCLR   $ENTER ,\n         L     X1,0(,R1)           GET ANCHOR POINTER\n         LTR   X1,X1               IS INDEX LEVEL EMPTY .Q\n         BZ    IXCLR05             BRANCH IF YES\n         XC    0(4,R1),0(R1)       CLEAR THE INDEX ANCHOR\n         XC    IXPTRS(IXPTRL),IXPTRS  CLEAR LEVEL POINTERS\n         ST    X1,IXPTR1           SAVE FIRST LEVEL POINTER\n         SPACE\nIXCLR01  DS    0H\n         LA    X1,IXPTR3           THIRD LEVEL POINTER\n         BAL   RETURN,IXCLR02      TRY IT\n         LA    X1,IXPTR2           SECOND LEVEL POINTER\n         BAL   RETURN,IXCLR02      TRY IT\n         LA    X1,IXPTR1           FIRST LEVEL POINTER\n         BAL   RETURN,IXCLR02      AND TRY IT\n         B     IXCLR05             END OF LIST\n         SPACE\nIXCLR02  DS    0H\n         L     X2,0(,X1)           ENTRY POINTER\n         LA    X2,0(,X2)           CLEAR HIGH BYTE\n         LTR   X2,X2                ANY PRESENT .Q\n         BZR   RETURN              BRANCH BACK IF NOT\n         USING IXHBLK,X2           TELL ASSEMBLER WHAT WE'VE GOT\n         L     TEMP,IXHBNEXT       NEXT POINTER ACROSS\n         ST    TEMP,0(,X1)         SAVE AWAY FOR FUTURE\n         L     R1,IXHBLOWR         NEXT LOWER ENTRY\n         LA    R0,IXPTR3           LAST ENTRY POINTER\n         CR    X1,R0               IS THAT WHAT WE'RE DOING .Q\n         BE    IXCLR03             BRANCH IF YES\n         ST    R1,4(,X1)           PROCESS NEXT TIME\nIXCLR03  DS    0H\n         SR    TEMP,TEMP           PREPARE LENGTH REGISTER\n         IC    TEMP,IXHBTXTL       LENGTH-1 OF STRING\n         L     X1,IXHBENTA         REFERENCE DATA POINTER\n         LA    R0,IXHBLK           WHERE IS BLOCK TO FREE\n         DROP  X2\n         LA    R1,IXHBLKL+2(TEMP,TEMP)  LENGTH OF SAME\n        $CALL  FREECELL            FREE UP THE BLOCK\n         SPACE\nIXCLR04  DS    0H\n         LA    X1,0(,X1)           CLEAR HIGH BYTE\n         LTR   X1,X1               ANY REFERENCE DATA PRESENT .Q\n         BZ    IXCLR01             BRANCH IF NOT\n         USING IXEBLK,X1           INDEX ENTRY DATA\n         LA    R0,IXEBLK           WHERE TO FREE\n         LA    R1,IXEBLKL          HOW MUCH TO FREE\n         L     X1,IXEBNEXT         NEXT ENTRY POINTER\n        $CALL  FREECELL            AND FREE REF BLOCK\n         B     IXCLR04             DO THEM ALL\n         DROP  X1\n         SPACE\nIXCLR05  DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#IXDUMP": {"ttr": 7685, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\xed\\x00\\xed\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 237, "newlines": 237, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTION 'IXDUMP' -- PRINT INDEX              *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER  --   LA    R1,INDEX ANCHOR POINTER\n*                      $CALL  IXDUMP\n         SPACE\nIXDUMP  $ENTER ,\n         LR    X3,R1               RETAIN INDEX ANCHOR POINTER\n         L     R1,0(,X3)           GET INDEX ANCHOR POINTER\n         LTR   R1,R1               ANYTHING QUEUED .Q\n         BZ    IXD01               RETURN IMMEDIATELY IF NOT\n         SPACE\n         MVC   APIMMIN,F1          DEFAULT MIN RECORD NUMBER\n         MVC   APIMMAX,F16MEG      DEFAULT MAX RECORD NUMBER\n         MVC   APIMGOTO,BLANKS     CLEAR GOTO TARGET\n         MVC   APIMMEMB,BLANKS     BLANK MEMBER NAME\n         MVC   APIMNAME,IXDNAME    DUMMY REMOTE NAME\n         XC    APIMFLAG,APIMFLAG   CLEAR FLAGS\n        $ON    APIMFLAG,(IO$RM,IO$INRM) THE WAY IT IS\n        $ON    APIMFLAG,IO$UEOF    AND THE WAY THAT I WANT IT\n        $CALL  RMFIND              GET REMOTE INSERTION POINT\n         LA    R1,RMQLEN           REMOTE QUEUE ELEMENT LENGTH\n        $CALL  GETCELL             GET A WORK AREA\n         BC    BNEG,IXDE018        BRANCH IF FAILED\n         USING RMQD,TEMP           RETURNED AREA\n         XC    RMQD(RMQLEN),RMQD   CLEAR THE AREA\n         L     R1,VSCRICVT         COMMUNICATION VECTOR ADDRESS\n         L     R1,VIXDRM-SCRICVT(,R1)   EXIT ADDRESS\n         ST    R1,RMQEXIT          ENTER REMOTE READ EXIT\n         MVC   RMQCHN,RMQCHN-RMQD(X1)   NEXT POINTER\n         ST    TEMP,RMQCHN-RMQD(X1)     LAST POINTER\n         MVI   RMQFLAG,RMQKEEP     FLAG ATTRIBUTES\n         MVC   RMQCNT,F1           CALL COUNT\n         MVC   RMQNAME,APIMNAME    REMOTE IDENTIFIER\n         MVC   RMQAD,0(X3)         SAVE DATA ANCHOR POINTER\n         XC    0(4,X3),0(X3)       CLEAR SYSTEM ANCHOR\n         DROP  TEMP\n         SPACE\n         SR    R1,R1               ZERO CALL PARM REGISTER\n         BCTR  R1,0                AND MAKE IT NEGATIVE\n        $CALL  RMIMBED             ENTER DUMMY REMOTE ONTO READER STACK\n         B     IXD01               AND GO TO RETURN\n         SPACE\nIXDE018  DS    0H\n         MVI   EFLAG018,ERRSET     NO CORE FOR DUMMY REMOTE\n         SPACE\nIXD01    DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\nIXDNAME  DC    CL8'SYSIX'          DUMMY REMOTE NAME\n         EJECT\n***********************************************************************\n*                                                                     *\n*              INTERNAL ROUTINE 'IXDRM' -- IX REMOTE READ ROUTINE     *\n*                                                                     *\n***********************************************************************\n         SPACE\nIXDRM   $ENTER ,                   DUMMY REMOTE READ EXIT\n         LR    X3,R1               ENTRY POINTER TRANSFER\n         USING FILBLOCK,X3         AND TELL THE ASSEMBLER\n         L     R15,BUFF3AD         WORK AREA\n         USING RMQR,R15            USED THIS WAY FOR RETURN\n         XC    RMQRCHN,RMQRCHN     CLEAR CHAIN\n         MVC   RMQRDATA(B2LG-2),BLANKS CLEAR DATA\n         LA    R0,B2LG-2           MAXIMUM LENGTH\n         STH   R0,RMQRLEN          SET ITS LENGTH\n         L     X1,FILIXAD          GET ENTRY DATA ADDRESS\n         LA    X1,0(,X1)           CLEAR CHARACTER\n         LTR   X1,X1               ANY ENTRY TO PROCESS .Q\n         BNZ   IXD110              BRANCH IF YES\n         LA    X1,FILH3AD          THIRD LEVEL POINTER\n         BAL   RETURN,IXD010       TRY IT\n         LA    X1,FILH2AD          SECOND LEVEL POINTER\n         BAL   RETURN,IXD010       TRY IT\n         LA    X1,FILH1AD          FIRST LEVEL POINTER\n         LA    RETURN,IXD998       END OF FILE POINTER\n         SPACE\nIXD010   DS    0H\n         L     X2,0(,X1)           ENTRY POINTER\n         LA    X2,0(,X2)           CLEAR HIGH BYTE\n         LTR   X2,X2               ANY PRESENT .Q\n         BZR   RETURN              BRANCH BACK IF NOT\n         USING IXHBLK,X2           TELL THE ASSEMBLER OF WHAT WE'VE GOT\n         LA    COUNT,FILH1AD       LEVEL ONE POINTER\n         SR    COUNT,X1            LESS WHAT WE'RE DOING NOW\n         LCR   COUNT,COUNT         POSITIVE OFFSET\n         BNZ   IXD020              BRANCH IF NOT LEVEL ONE\n         IC    TEMP,IXHBTXTU       FIRST UPPER CHARACTER\n         EX    TEMP,IXDCLI         COMPARE WITH LAST\n         BE    IXD020              BRANCH IF EQUAL\n         STC   TEMP,FILIXALF       SET LAST CHAR\n         MVC   RMQRDATA(1),PERIND  CONTROL WORD INDICATOR\n         MVC   RMQRDATA+1(2),IXDSI      SIGNAL CONTROL WORD\n         MVC   RMQRDATA+4(L'IXDNAME0),IXDNAME0  LEVEL ZERO REMOTE NAME\n         MVC   RMQRDATA+L'IXDNAME0+6(1),FILIXALF  ADD ONE ARGUMENT\n         CLI   FILIXALF,C''''      IS CHARACTER A SINGLE QUOTE .Q\n         BNE   IXD014              BRANCH IF NOT\n         MVI   RMQRDATA+L'IXDNAME0+5,C'\"'    ENTER DOUBLE QUOTE BEFORE\n         MVI   RMQRDATA+L'IXDNAME0+7,C'\"'    AND AFTER\n         B     IXD016              AND CONTINUE\nIXD014   DS    0H\n         MVI   RMQRDATA+L'IXDNAME0+5,C''''   ENTER SINGLE QUOTE BEFORE\n         MVI   RMQRDATA+L'IXDNAME0+7,C''''   AND AFTER\nIXD016   DS    0H\n         LA    R0,RMQRDATA+4       START OF REMOTE NAME\n         ST    R0,ARGSTART         SET START ADDR\n         LA    R0,RMQRDATA+L'IXDNAME0+7 END OF ARG HERE\n         ST    R0,ARGSTOP          SET END ADDR\n        $CALL  SITST               IS THERE SUCH A REMOTE .Q\n         L     R15,BUFF3AD         RESTORE WORK BUFFER ADDRESS\n         BC    15-BOMIT,IXD018     BRANCH IF NOT\n         B     IXD997              ELSE RETURN THE SIGNAL\nIXD018   DS    0H\n         MVC   RMQRDATA(B2LG-2),BLANKS  CLEAR DATA AGAIN\nIXD020   DS    0H\n         CLI   0(X1),X'FF'         HAS INTER LEVEL SIGNAL BEEN DONE .Q\n         BE    IXD024              BRANCH IF YES\n         MVI   0(X1),X'FF'         MARK IT DONE NOW\n         LA    TEMP,RMQRDATA       POINT TO START OF WORK AREA\n         MVC   0(1,TEMP),PERIND    CONTROL WORD INDICATOR\n         MVC   1(2,TEMP),IXDSI     ENTER SIGNAL CONTROL WORD\n         LA    TEMP,4(,TEMP)       NEXT FREE SLOT\n         ST    TEMP,ARGSTART       SET START ADDRESS\n         LA    R1,0(COUNT,COUNT)   DOUBLE CALL LEVEL\n         LA    R1,IXDNAME1(R1)     POINT TO APPROPRIATE SIGNAL NAME\n         MVC   0(L'IXDNAME1,TEMP),0(R1) LEVEL 'N' REMOTE NAME\n         LA    TEMP,L'IXDNAME1(,TEMP)   NEXT FREE SLOT\n         ST    TEMP,ARGSTOP        SET END ADDRESS\n         SR    R1,R1               ZERO WORK REG\n         IC    R1,IXHBTXTL         GET LENGTH-1 OF LEVEL OPERAND\n         LA    R1,1(,R1)           GET ACTUAL LENGTH\n         CVD   R1,DECM             CONVERT TO DECIMAL\n         OI    DECM+7,X'0F'        AND FIX THE SIGN\n         UNPK  1(3,TEMP),DECM+6(2) ENTER LENGTH OF INDEX LEVEL\n         LA    TEMP,4(,TEMP)       POINT PAST FIRST ARGUMENT\n        $CALL  SITST               IS THERE SUCH A REMOTE .Q\n         L     R15,BUFF3AD         RESTORE WORK BUFFER ADDR\n         BC    15-BOMIT,IXD022     BRANCH IF NOT\n         B     IXD997              ELSE RETURN SIGNAL\nIXD022   DS    0H\n         MVC   RMQRDATA(B2LG-2),BLANKS  CLEAR DATA AGAIN\nIXD024   DS    0H\n         L     TEMP,IXHBNEXT       NEXT POINTER ACROSS\n         ST    TEMP,0(,X1)         SAVE AWAY FOR THE FUTURE\n         L     R1,IXHBLOWR         NEXT LOWER POINTER\n         LA    R0,FILH3AD          LAST ENTRY\n         CR    X1,R0               IS THAT WHAT WE'RE DOING .Q\n         BE    IXD026              BRANCH IF YES\n         ST    R1,4(,X1)           PROCESS THIS NEXT TIME\nIXD026   DS    0H\n         SR    TEMP,TEMP           PREPARE LENGTH REGISTER\n         IC    TEMP,IXHBTXTL       LENGTH-1 OF STRING\n         LA    R1,IXHBTXTU+1(TEMP) POINT TO ORIGINAL STRING\n         L     X1,IXHBENTA         REFERENCE DATA POINTER\n         LA    X1,0(,X1)           CLEAR HIGH BYTE\n         LA    R0,IXHBLK           WHERE IS BLOCK TO FREE\n         DROP  X2\n         LA    X2,RMQRDATA         RESULTING TARGET\n         EX    TEMP,IXDMVC1        MOVE ORIGINAL STRING TO AREA\n         LA    X2,RMQRDATA+1(TEMP) POINT TO LAST CHAR+1\n         LA    R1,IXHBLKL+2(TEMP,TEMP)  LENGTH OF SAME\n        $CALL  FREECELL            FREE UP THE BLOCK\n         L     R15,BUFF3AD         RESTORE RMQR POINTER\n         LTR   X1,X1               ANY REFERENCE DATA PRESENT .Q\n         BZ    IXD997              BRANCH TO SIMPLE RETURN IF NOT\n         SPACE\n         USING IXEBLK,X1           INDEX ENTRY DATA\n         SR    COUNT,COUNT         PREPARE FOR LENGTH\n         IC    COUNT,IXEBTXTL      GET LENGTH OF ENTRY TEXT\n         MVC   0(L'IXDREF,X2),IXDREF    ENTER REFERENCE SEPARATOR STRNG\n         LA    X2,L'IXDREF(,X2)    BUMP OUTPUT POINTER\n         BCTR  COUNT,0             GET LENGTH-1\n         EX    COUNT,IXDMVC2       MOVE ENTRY DATA\n         L     TEMP,IXEBNEXT       NEXT ENTRY POINTER\n         LA    R0,IXEBLK           WHERE TO FREE\n         LA    R1,IXEBLKL          HOW MUCH TO FREE\n        $CALL  FREECELL            AND FREE THE BLOCK\n         L     R15,BUFF3AD         RESTORE RMQR POINTER\n         LTR   TEMP,TEMP           ANY MORE ENTRY DATA\n         BNZ   IXD030              BRANCH IF YES\n         LA    X2,0(COUNT,X2)      LAST CHAR+1\n         BCTR  X2,0                BACKUP ONE\n         MVI   0(X2),C' '          TRAILING BLANK\nIXD030   DS    0H\n         IC    R0,FILIXAD          SAVE HIGH BYTE\n         ST    TEMP,FILIXAD        SET NEXT ENTRY ADDRESS\n         STC   R0,FILIXAD          RESTORE HIGH BYTE\n         B     IXD997              AND RETURN THE DATA\n         SPACE\nIXD110   DS    0H\n         LA    X2,RMQRDATA         POINT TO TARGET\n         SR    COUNT,COUNT         TEXT LENGTH REG\n         IC    COUNT,IXEBTXTL      LENGTH OF ENTRY\n         BCTR  COUNT,0             LENGTH-1\n         EX    COUNT,IXDMVC3       ENTER THE DATA\n         L     TEMP,IXEBNEXT       NEXT ENTRY DATA\n         LA    R0,IXEBLK           WHERE TO FREE\n         LA    R1,IXEBLKL          HOW MUCH TO FREE\n        $CALL  FREECELL            AND FREE THE AREA\n         L     R15,BUFF3AD         RESTORE RMQR POINTER\n         LTR   TEMP,TEMP           ANY MORE ENTRY BLOCKS .Q\n         BNZ   IXD120              BRANCH IF NOT\n         BCTR  COUNT,0             DECREMENT LENGTH\n         LA    X2,0(COUNT,X2)      POINT TO LAST CHAR\n         MVI   0(X2),C' '          CHANGE COMMA TO BLANK\nIXD120   DS    0H\n         IC    R0,FILIXAD          SAVE HIGH BYTE\n         ST    TEMP,FILIXAD        SAVE NEXT ENTRY POINTER\n         STC   R0,FILIXAD          RESTORE HIGH BYTE\n         SPACE\nIXD997   DS    0H\n         LA    R1,RMQR             POINT TO RESULT\n         B     IXD999              AND GO TO RETURN\nIXD998   DS    0H\n         SR    R1,R1               NO RETURN POINTER FOR EOF\nIXD999   DS    0H\n        $RESTOR KEEP=(R1)          RESTORE CALLER'S REGS\n         BR    RETURN              AND RETURN TO CALLER\n         SPACE\nIXDCLI   CLI   FILIXALF,*-*        COMPARE LAST ALPHA\nIXDMVC1  MVC   0(*-*,X2),0(R1)     MOVE ENTRY LEVEL\nIXDMVC2  MVC   0(*-*,X2),IXEBTXT   MOVE ENTRY DATA\nIXDMVC3  MVC   0(*-*,X2),IXEBTXT   MOVE MORE ENTRY DATA\n         SPACE\nIXDSI    DC    C'SI'               SIGNAL CONTROL WORD\nIXDNAME0 DC    CL8'SYSIX0'         LEVEL ZERO ALPHA CHANGE\nIXDNAME1 DC    CL8'SYSIX1'         LEVEL ONE CHANGE\nIXDNAME2 DC    CL8'SYSIX2'         LEVEL TWO CHANGE\nIXDNAME3 DC    CL8'SYSIX3'         LEVEL THREE CHANGE\nIXDREF   DC    C'&&SYSIXREF.'      LEVEL/REFERENCE SEPARATOR STRING\n         SPACE\n         DROP  X1\n         DROP  X3\n         DROP  R15\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#IXPROC": {"ttr": 7690, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x95\\x00\\x95\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 149, "newlines": 149, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTION 'IXPROC' -- PROCESS INDEX            *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER --  LA    R1,INDEX ANCHOR POINTER\n*                    $CALL  IXPROC\n*\n*        WHERE -- IXPTRS  IS A VECTOR OF\n*                       AL1(LEN-1),AL3(PTR TO STRING)\n*              -- IXPARM  IS THE REFERENCE LEN-1/ADDR\n*              -- ZERO PTR MEANS POSITION HOLDER ONLY\n         SPACE\nIXPROC  $ENTER ,\n         LR    X3,R1               RETAIN HEADER BLK CHAIN START\n         L     R15,BUFF3AD         POINT TO UPPER CASE WORK AREA\n         LA    R1,IXPTRS           POINT TO PARM LIST\n         ST    R1,IXPCURR          SAVE IT IN WORK\n         SPACE\nIX010    DS    0H\n         L     R1,IXPCURR          POINT TO CURRENT PARM WORD\n         L     X1,0(,R1)           LOAD CURRENT PARM\n         SR    COUNT,COUNT         ZERO LENGTH-1 REGISTER\n         IC    COUNT,0(,R1)        GET LENGTH-1 OF PARM\n         LA    R1,L'IXPTRS(,R1)    BUMP PARMLIST CURSOR\n         ST    R1,IXPCURR          SAVE UPDATED POINTER\n         LA    X1,0(,X1)           CLEAR LENGTH-1\n         LTR   X1,X1               MORE INDEX LEVELS .Q\n         BZ    IX110               BRANCH IF NOT\n         EX    COUNT,IXHMVC1       SHIFT PARM STRING TO SCRATCH\n         EX    COUNT,IXHOC         AND CONVERT TO UPPER CASE\n         SR    TEMP,TEMP           FOR WORKING WITH LENGTH-1\nIX020    DS    0H\n         ST    X3,IXHPREV          SAVE PREVIOUS HEADER LINK FIELD ADDR\nIX030    DS    0H\n         L     X3,0(,X3)           NEXT HEADER (IXHBNEXT/IXHBLOWR)\n         LTR   X3,X3               MORE TO GO .Q\n         BZ    IX060               NO, CHAIN NEW BLK ON END\n         USING IXHBLK,X3           TELL THE ASSEMBLER\n         IC    TEMP,IXHBTXTL       LENGTH-1 OF TEXT IN BLOCK\n         LR    R0,TEMP             REMEMBER EXISTING TEXT LENGTH-1\n         CR    COUNT,TEMP          COMPARE NEW TO EXISTING TEXT LEN-1\n         BE    IX050               IF SAME, DIRECT MATCH POSSIBLE\n         BH    IX040               IF LONGER, USE SHORTER FOR MATCH\n         LR    TEMP,COUNT          ELSE SET TO TEST SHORTER\nIX040    DS    0H\n         EX    TEMP,IXHCLC         TEST FOR COLLATING SEQUENCE\n         BH    IX020               LOOP IF NOT WANTED HERE\n         BL    IX060               BRANCH IF INSERTION POINT\n         CR    COUNT,R0            IS NEW LONGER .Q\n         BH    IX020               YES, WAIT FOR NEXT CHANCE\n         B     IX060               ELSE INSERT NEW HERE\nIX050    DS    0H\n         EX    TEMP,IXHCLC         TEST FOR COLLATING SEQUENCE\n         BH    IX020               LOOP IF NOT WANTED HERE\n         BE    IX070               ENTRY ALREADY EXISTS, SKIP\nIX060    DS    0H\n         LA    R1,IXHBLKL+2(COUNT,COUNT)     LENGTH OF INDEX HEADER BLK\n        $CALL  GETCELL             GET SOME SPACE\n         L     R15,BUFF3AD         RESTORE POINTER TO UPPER CASE WORK\n         BC    BNEG,IX200          BRANCH IF FAILED\n         XC    0(IXHBLKL,TEMP),0(TEMP)  CLEAR NEW BLOCK PREFIX\n         ST    X3,IXHBNEXT-IXHBLK(,TEMP)     SET NEXT HEADER BLK ADDR\n         L     X3,IXHPREV          PTR PREVIOUS LINK FIELD LOCATION\n         ST    TEMP,0(,X3)         COMPLETE THE ENQ (IXHBNEXT/IXHBLOWR)\n         LR    X3,TEMP             SET WORKING BASE FOR NEW IXHBLK\n         STC   COUNT,IXHBTXTL      SAVE TEXT LENGTH-1\n         EX    COUNT,IXHMVC2       SHIFT UPPER CASE TEXT TO BLOCK\n         L     R1,IXPCURR          PTR CURRENT PARM ENTRY ADDR\n         L     R1,0(,R1)           PTR TEXT STRING FOR THIS PARM\n         LA    X2,IXHBTXTU+1(COUNT)     PTR END OF UPPER CASE STRING\n         EX    COUNT,IXHMVC3       SHIFT ACTUAL TEXT TO BLK ALSO\nIX070    DS    0H\n         LA    X3,IXHBLOWR         PTR LINK FIELD TO DROP TO NEXT LEVEL\n         B     IX010               PROCESS OTHER LEVELS\n         SPACE\nIXHMVC1  MVC   4(*-*,R15),0(X1)    TO SHIFT HEADER TEXT TO SCRATCH\nIXHOC    OC    4(*-*,R15),BLANKS   TO CONVERT HEADER TO UPPER CASE\nIXHCLC   CLC   4(*-*,R15),IXHBTXTU-IXHBLK(X3)     TEST HEADER COLLATION\nIXHMVC2  MVC   IXHBTXTU-IXHBLK(*-*,X3),4(R15)     ADD UPPER CASE TEXT\n         SPACE\n****************  PROCESS INDEX REFERENCE ENTRY ***********************\nIX110    DS    0H\n         LA    R0,IXHBLOWR-IXHBLK  WE'RE OFFSET THIS FAR\n         SR    X3,R0               BACKUP TO BLOCK START\n         SR    COUNT,COUNT         LOAD ENTRY REFERENCE STRING\n         IC    COUNT,IXPARM             LENGTH-1\n         L     X2,IXPARM           POINTER TO REFERENCE ENTRY\n         LA    X2,0(,X2)           CLEAR HIGH BYTE\n         LTR   X2,X2               ANY REFERENCE ENTRY .Q\n         BZ    IX210               BRANCH IF NOT\n         LA    X1,IXHBENTA         PTR LINK FIELD IN CURRENT HEADER BLK\n         L     X3,IXHBENTA         PTR FIRST ENTRY BLOCK (IF ANY YET)\n         LTR   X3,X3               HAVE ONE .Q\n         BZ    IX130               NO, SKIP TO GET IT\n         USING IXEBLK,X3\nIX120    DS    0H\n         LR    X1,X3               SAVE CURRENT ENTRY BLK ADDRESS\n         L     X3,IXEBNEXT         PTR TO NEXT ENTRY BLOCK\n         LTR   X3,X3               CHAIN END YET .Q\n         BNZ   IX120               NO, CONTINUE SEARCH\n         DROP  X3\n         USING IXEBLK,X1\n         SR    R1,R1               PREPARE LENGTH REG\n         IC    R1,IXEBTXTL         LENGTH OF TEST ALREADY IN BLK\n         S     R1,F3               BACK OVER ', ' AND LENGTH-1\n         SR    R1,COUNT            LENGTH SANS PREVIOUS ENTRY\n         LA    TEMP,IXEBTXT(R1)    PTR TO PREVIOUS ENTRY\n         L     X2,IXPARM           PTR TO ENTRY STRING TEXT\n         EX    COUNT,IXECLC        IS NEW ENTRY ALREADY PRESENT .Q\n         BE    IX210               YES, NO ADD NEEDED\n         LA    R1,3(COUNT,R1)      RESTORE CURRENT TEXT LENGTH\n         LA    TEMP,IXEBTXTA-2-1   AVAILABLE TEXT LENGTH PER BLK\n         SR    TEMP,R1             SPACE LEFT IN BLK\n         CR    COUNT,TEMP          TEST FREE SPACE\n         BNH   IX140               SKIP IF ENTRY CAN FIT WITH ', '\nIX130    DS    0H\n         LA    R1,IXEBLKL          LENGTH OF ENTRY BLOCK\n        $CALL  GETCELL             GET SOME SPACE\n         BC    BNEG,IX200          BRANCH IF ERROR\n         ST    TEMP,0(,X1)         SET TO PREV LINK (IXHBENTA/IXEBNEXT)\n         LR    X1,TEMP             SET WORKING BASE\n         XC    IXEBLK(IXEBLKL),IXEBLK   CLEAR ENTIRE AREA\n         SR    R1,R1               CURRENT TEXT LENGTH IN BLK IS ZERO\nIX140    DS    0H\n         L     TEMP,IXPARM         PTR TO ENTRY TEXT STRING\n         LA    X2,IXEBTXT(R1)      PTR TO FREE LOC IN BLOCK\n         EX    COUNT,IXEMVC        SHIFT ENTRY TEXT TO BLOCK\n         LA    R1,2+1(COUNT,R1)    TOTAL TEXT LEN IN BLK (WITH ', ')\n         STC   R1,IXEBTXTL         SAVE LENGTH\n         LA    TEMP,IXEBTXT-2(R1)  PTR TO ENTRY STRING END\n         MVI   0(TEMP),C','        ADD A COMMA\n         MVI   1(TEMP),C' '             AND A BLANK\n         B     IX210               GO TO RETURN\n         DROP  X1\n         SPACE\n**************** RETURN ***********************************************\nIX200    DS    0H\n         MVI   EFLAG024,ERRSET     THERE'S NO CORE\nIX210    DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\nIXHMVC3  MVC   0(*-*,X2),0(X1)     SHIFT ACTUAL HEADER TO BLOCK\nIXECLC   CLC   0(*-*,TEMP),0(X2)   TEST PREVIOUS ENTRY FOR MATCH\nIXEMVC   MVC   0(*-*,X2),0(TEMP)   SHIFT ENTRY TEXT TO BLOCK\n         SPACE\nIXPCURR  DC    A(*-*)              PTR CURRENT HEADER PARM WORD\nIXHPREV  DC    A(*-*)              PTR PREVIOUS HEADER BLK LINK FIELD\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#JU": {"ttr": 7694, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x005\\x005\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .JU (JUSTIFICATION) --- CONTROL                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nJU      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BPOS+BOMIT,JU01     BRANCH IF OMITTED OR POSITIVE\n         BC    BNEG,JU02           BRANCH IF NEGATIVE\n         CLI   YNRESULT,YNHALF     'HALF' OPERAND .Q\n         BE    JU00                BRANCH IF YES\n         CLI   YNRESULT,YNLEFT     'LEFT' OPERAND .Q\n         BE    JU03                BRANCH IF YES\n         CLI   YNRESULT,YNRGHT     'RIGHT' OPERAND .Q\n         BE    JU04                BRANCH IF YES\n         CLI   YNRESULT,YNCNTR     'CENTRE' OPERAND .Q\n         BE    JU05                BRANCH IF YES\n         CLI   YNRESULT,YNISDE     'INSIDE' OPERAND .Q\n         BE    JU06                BRANCH IF YES\n         CLI   YNRESULT,YNOSDE     'OUTSIDE' OPERAND .Q\n         BE    JU07                BRANCH IF YES\n         MVI   EFLAG005,ERRSET     INVALID ARGUMENT\n         B     JU08                GO TO COMMON EXIT\n         SPACE\nJU00     DS    0H\n         MVI   JUVAL,JUVHALF       HALF JUSTIFY\n         B     JU08                GO TO COMMON EXIT\nJU01     DS    0H\n         MVI   JUVAL,JUVPOS        JUSTIFY LEFT AND RIGHT\n         B     JU08                GO TO COMMON EXIT\nJU02     DS    0H\n         MVI   JUVAL,JUVNEG        NO JUSTIFY\n         B     JU08                GO TO COMMON EXIT\nJU03     DS    0H\n         MVI   JUVAL,JUVLEFT       LEFT JUSTIFY\n         B     JU08                GO TO COMMON EXIT\nJU04     DS    0H\n         MVI   JUVAL,JUVRGHT       RIGHT JUSTIFY\n         B     JU08                GO TO COMMON EXIT\nJU05     DS    0H\n         MVI   JUVAL,JUVCNTR       CENTRE JUSTIFY\n         B     JU08                GO TO COMMON EXIT\nJU06     DS    0H\n         MVI   JUVAL,JUVISDE       INSIDE JUSTIFY\n         B     JU08                GO TO COMMON EXIT\nJU07     DS    0H\n         MVI   JUVAL,JUVOSDE       OUTSIDE JUSTIFY\n         B     JU08                GO TO COMMON EXIT\n         SPACE\nJU08     DS    0H\n        $EXIT  RC=0                AND CONTINUE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#LA": {"ttr": 7696, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\n\\x00\\n\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .LA (LEFT ADJUST) --- CONTROL                          *\n*                                                                     *\n***********************************************************************\n         SPACE\nLA      $ENTER ,\n        $OFF   SWITCHS,(CESWS,RASWS)    TURN OFF .CE AND .RA\n        $CALL  CELARA              REST IS LIKE CENTER\n        $EXIT  RC=(R15)            AND GET NEXT LINE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#LB": {"ttr": 7937, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x91\\x00\\x91\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 145, "newlines": 145, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .LB (LABEL) --- CONTROL                                *\n*                                                                     *\n***********************************************************************\n         SPACE\nLB      $ENTER ,\n         MVC   LBWRK,BLANKS        CLEAR LABEL OPERAND\n        $CALL  GETNUM              GET NUMERIC OPERAND\n         BC    BOMIT,LBE01         BRANCH IF OMITTED\n         BC    BDNO,LB01           BRANCH IF NOT NUMERIC\n         C     COUNT,COMFILIT      MATCH CURRENT RECORD NUMBER .Q\n         BNE   LBE02               ERROR IF NOT\n         XC    LBWRK,LBWRK         CLEAR LABEL OPERAND\n         ST    COUNT,LBWRK+4       AND ENTER NUMERIC OPERAND\n         B     LB05                GO TO RETURN\n         SPACE\nLB01     DS    0H\n         ST    COUNT,ARGSTART      RESCAN FOR IDENTIFIER\n        $CALL  GETARG              GET IDENTIFIER\n         LA    R0,L'LBNAME-1       MAX-1 LENGTH ALLOWED\n         CR    TEMP,R0             TOO LONG .Q\n         BH    LBE02               YES, INVALID LABEL\n         EX    TEMP,LBMVCI         ENTER THE IDENTIFIER\n         SPACE\n         LA    X1,LBANCH-LBCHN+LBDSECT  GET LABEL ANCHOR POINTER\nLB02     DS    0H\n         USING LBDSECT,X1          TELL THE ASSEMBLER\n         L     X2,LBCHN            NEXT LABEL IN CHAIN\n         DROP  X1\n         LTR   X2,X2               AT THE END .Q\n         BZ    LB04                BRANCH OUT IF YES\n         USING LBDSECT,X2          NEXT ONE TO CHECK\n         CLC   LBWRK,LBNAME        INSERTION POINT .Q\n         BH    LB04                BRANCH OUT IF HIGH\n         BE    LB03                CHECK SOME MORE IF EQUAL\n         LR    X1,X2               LINK DOWN THE CHAIN\n         B     LB02                AND TRY AGAIN\nLB03     DS    0H\n         CLC   LBFILIT,COMFILIT    SAME LABEL AS BEFORE .Q\n         BNE   LBE03               DUPLICATE LABEL ERROR\n         B     LB05                AND GO TO RETURN\n         DROP  X2\n         SPACE\nLB04     DS    0H\n         LA    R1,LBLEN            LENGTH OF A NEW LABEL BLOCK\n        $CALL  GETCELL             GET THE AREA\n         BC    BNEG,LBE04          BRANCH IF FAILURE\n         USING LBDSECT,TEMP        GOTTEN AREA PTR\n         XC    LBDSECT(LBLEN),LBDSECT   CLEAR THE BLOCK\n         MVC   LBFILIT,COMFILIT    ENTER RECORD NUMBER\n         MVC   LBNAME,LBWRK        LABEL OPERAND\n         MVC   LBCHN,LBCHN-LBDSECT(X1)  FORWARD POINTER\n         ST    TEMP,LBCHN-LBDSECT(,X1)  PTR TO THE NEW\n         DROP  TEMP\n         SPACE\nLB05     DS    0H\n         CLC   LBGOTO,LBWRK        OBJECT OF A GOTO .Q\n         BNE   LB06                BRANCH IF NOT\n         MVC   LBGOTO,BLANKS       WE HAVE ARRIVED\nLB06     DS    0H\n         L     TEMP,ARGSTART       ADDR OF BLANK AFTER OPERAND\n         LA    TEMP,1(,TEMP)       START OF NEXT LINE\n         LA    R1,BUFF2            START OF THIS LINE\n         SR    R1,TEMP             NEGATIVE LENGTH TO CHOP\n         AH    R1,BUFF2LGZ         NEW LENGTH\n         BNP   LB07                BRANCH IF NOTHING\n         STH   R1,BUFF2LGZ         MOVE OVER THE REMAINDER\n         EX    R1,LBMVCO           MOVE OVER THE REMAINDER\n         LA    R15,WRETNR          RETURN CODE TO PROCESS THE RESULT\n         B     LB08                AND GO TO RETURN\nLB07     DS    0H\n         SR    R15,R15             SET RETURN CODE TO IGNORE\n         SPACE\nLB08     DS    0H\n        $EXIT  RC=(R15)            RETURN TO CALLER\n         SPACE\nLBMVCI   MVC   LBWRK(*-*),0(COUNT) MOVE OPERAND OF LABEL\nLBMVCO   MVC   BUFF2(*-*),0(TEMP)  MOVE OVER .LB ARGUMENT\n         SPACE\nLBE01    DS    0H\n         MVI   EFLAG003,ERRSET     OMITTED OPERAND\n         B     LBE99               GO TO CLEAR\nLBE02    DS    0H\n         MVI   EFLAG005,ERRSET     RECORD NUMBER DOESN'T MATCH\n         B     LBE99               GO TO CLEAR\nLBE03    DS    0H\n         MVI   EFLAG025,ERRSET     DUPLICATE LABEL\n         B     LBE99               GO TO CLEAR\nLBE04    DS    0H\n         MVI   EFLAG024,ERRSET     NO SPACE FOR LABEL\n         B     LBE99               GO TO CLEAR\nLBE99    DS    0H\n         MVC   LBWRK,BLANKS        CLEAR ERROR OPERAND\n         B     LB07                AND GO TO IGNORE RESULT\n         SPACE 2\n*\n*        ROUTINE TO CLEAR ALL LABELS IN CURRENT FILE LEVEL\n*\n         SPACE\nLBCLR   $ENTER ,\n         CLC   LBGOTO,BLANKS       A GOTO TARGET OUTSTANDING .Q\n         BE    LBCLR04             BRANCH IF NOT\n         MVI   EFLAG026,ERRSET     GO TARGET NOT FOUND\n         CLC   LBGOTO(4),F0        NUMERIC TARGET .Q\n         BE    LBCLR01             BRANCH IF YES\n        $MVC   BUFF2,LBGOTO        TARGET VALUE\n         LA    R1,L'LBGOTO         LENGTH OF SAME\n         LA    TEMP,BUFF2          WHERE BAD OPERAND WAS PLACED\n         B     LBCLR02             AND CONTINUE\nLBCLR01  DS    0H\n         L     R1,LBGOTO+4         NUMERIC TARGET\n         CVD   R1,DECM             CONVERT TO DECIMAL\n        $MVC   BUFF2,UREDPAT       MOVE EDIT PATTERN\n         ED    BUFF2(L'UREDPAT),DECM+4  INSERT TARGET LINE NUMBER\n         LA    R1,L'UREDPAT        LENGTH OF RESULT\n         LA    TEMP,BUFF2+L'UREDPAT-1   WHERE BAD OPERAND WAS PLACED\nLBCLR02  DS    0H\n         STH   R1,BUFF2LGZ         SET LENGTH OF GENERATED RESULT\n         ST    TEMP,ERRSTART       INDICATE BAD RECORD COLUMN\n         CLC   COMAGO,BLANKS       DO WE HAVE THE SOURCE GOTO .Q\n         BE    LBCLR03             BRANCH IF NOT\n        $MVC   COMAREA,COMAGO      FOR ERROR INFORMATION\nLBCLR03  DS    0H\n         MVC   LBGOTO,BLANKS       CLEAR CURRENT GOTO TARGET\n        $CALL  ERROUT              PRODUCE THE DIAGNOSTIC\n         MVC   COMAGO,BLANKS       CLEAR LAST FORWARD GOTO RECORD\n         SPACE\nLBCLR04  DS    0H\n         L     X1,LBANCH-LBCHN+LBDSECT  FIRST LABEL BLOCK POINTER\nLBCLR05  DS    0H\n         USING LBDSECT,X1          TELL THE ASSEMBLER\n         LTR   X1,X1               AT THE END .Q\n         BZ    LBCLR06             BRANCH OUT IF YES\n         LA    R0,LBDSECT          WHERE TO FREE\n         LA    R1,LBLEN            LENGTH TO FREE\n         L     X1,LBCHN            NEXT LABEL BLOCK POINTER\n        $CALL  FREECELL            FREE LABEL BLOCK\n         B     LBCLR05             DO TILL DONE\n         DROP  X1\n         SPACE\nLBCLR06  DS    0H\n         ST    X1,LBANCH           CLEAR LABEL ANCHOR BLOCK\n         MVC   COMAGO,BLANKS       RESET LAST FORWARD GOTO RECORD\n        $EXIT  RC=0                AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#LE": {"ttr": 7941, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x16\\x00\\x16\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .LE (LEADING SPACES) --- CONTROL                       *\n*                                                                     *\n***********************************************************************\n         SPACE\nLE      $ENTER ,\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BOMIT+BPOS,LE01     BRANCH IF NULL OR AFFIRMATIVE\n         BC    BNEG,LE02           BRANCH IF NEGATIVE\n         MVI   EFLAG005,ERRSET     NEITHER, QUIT WITH ERROR\n         B     LE03                GO TO RETURN\n         SPACE\nLE01     DS    0H\n        $ON    SWITCHS,FLDSP       ALLOW SPACES TO BEGIN PAGE\n         B     LE03                BRANCH TO RETURN\n         SPACE\nLE02     DS    0H\n        $OFF   SWITCHS,FLDSP       DON'T ALLOW SPACES TO BEGIN PAGE\n         SPACE\nLE03     DS    0H\n        $EXIT  RC=0                DONE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#LI": {"ttr": 7943, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00`\\x00`\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 96, "newlines": 96, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .LI (LITERAL) --- CONTROL                              *\n*                                                                     *\n***********************************************************************\n         SPACE\nLI      $ENTER ,\n         L     X3,ARGSTART         REMEMBER 'LINE' START ADDR\n        $CALL  GETNUM              GET NUMERIC ARGUMENT\n         BC    15-BDNO,LI07        BRANCH IF NOT INVALID\n         ST    COUNT,ARGSTART      RESET SCANNING START ADDR\n        $CALL  GETYESNO            GET AND TEST ARGUMENT AGAIN\n         BC    BPOS,LI05           BRANCH IF POSITIVE\n         BC    BNEG,LI06           BRANCH IF NEGATIVE\n        $IFON  SWITCHS,LISWS,LI13  BRANCH IF LITERAL 'ON'\n         LTR   TEMP,TEMP           LENGTH-1 IS ZERO .Q\n         BNZ   LI12                NO, ARGUMENT NOT SINGLE CHAR\n         LR    X1,COUNT            POINT TO CHAR\n        $CALL  GETYESNO            GET AND TEST 2ND ARG\n         BC    BOMIT,LI01          BRANCH IF ONLY SINGLE CHAR IN ARG1\n         CLI   YNRESULT,YNNOBRK    IS ARG 'NOBREAK' .Q\n         BE    LI03                BRANCH IF YES\n         B     LI12                ELSE IT IS A 'LINE' ARG\n         SPACE\nLI01     DS    0H\n         CLI   0(X1),C'*'          IS CHAR AN ASTERISK .Q\n         BNE   LI02                BRANCH IF NOT\n         LA    X1,PERIND+1         RESTORE THE DEFAULT\nLI02     DS    0H\n         MVC   PERIND(1),0(X1)     SET CONTROL WORD INDICATOR\n         B     LI14                GO TO TERMINATE\n         SPACE\nLI03     DS    0H\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION\n        $CALL  GETARG              ANYTHING AFTER 'NOBREAK' .Q\n         BC    15-BOMIT,LI12       YES, THEN A 'LINE' ARG\n         CLI   0(X1),C'*'          IS CHAR AN ASTERISK .Q\n         BNE   LI04                BRANCH IF NOT\n         LA    X1,PERNBIND+1       RESTORE THE DEFAULT\nLI04     DS    0H\n         MVC   PERNBIND(1),0(X1)   SET NOBREAK CONTROL WORD IND\n         B     LI14                GO TO TERMINATE\n         SPACE\nLI05     DS    0H\n         LH    X1,H32767           'ON' IS FOREVER\n         B     LI09                CONTINUE CHECKING\nLI06     DS    0H\n         SR    X1,X1               'OFF' IS FINISHED\n         BCTR  X1,0                NEGATIVE INDICATES 'OFF'\n         B     LI09                CONTINUE CHECKING\n         SPACE\nLI07     DS    0H\n         BC    15-BOMIT,LI08       BRANCH IF FIRST ARG NOT OMITTED\n         LA    COUNT,1             ONE LINE BY DEFAULT\nLI08     DS    0H\n         LTR   X1,COUNT            TEST NUMERIC RESULT\n         BM    LI12                NEGATIVE IS 'LINE' ARG\n         CH    X1,H32767           TOO BIG FOR USER .Q\n         BNL   LI12                YES, THEN 'LINE' ARG\nLI09     DS    0H\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION\n        $CALL  GETARG              ANYTHING AFTERWARD .Q\n         BC    15-BOMIT,LI12       YES, THEN 'LINE' ARG\n        $IFON  SWITCHS,LISWS,LI11  BRANCH IF LITERAL 'ON'\n         CH    X1,H32767           WAS THIS 'ON' .Q\n         BNE   LI10                BRANCH IF NOT\n        $ON    SWITCHS,LISWS       TURN LITERAL 'ON'\nLI10     DS    0H\n         STH   X1,LICNT            SET ARGUMENT VALUE\n         B     LI14                GO TO TERMINATE\n         SPACE\nLI11     DS    0H\n         LTR   X1,X1               WAS OPERAND 'OFF' .Q\n         BNM   LI13                NO, REPROCESS 'LINE' LITERALLY\n        $OFF   SWITCHS,LISWS       KILL LITERAL 'ON' CONDITION\n         SR    X1,X1               NO LINES LEFT\n         STH   X1,LICNT            KILL LITERAL COUNT\n         B     LI13                REPROCESS TOTAL LINE\n         SPACE\nLI12     DS    0H\n        $IFON  SWITCHS,LISWS,LI13  BRANCH IF LITERAL 'ON'\n         ST    X3,ARGSTART         IT ALL STARTED HERE\n        $CALL  USARG               RESULTING TEXT LINE\n         LA    X1,1                ONLY ONE LINE\n         STH   X1,LICNT            SET LITERAL LINE COUNT\n         LA    R15,WRETNR          PROCESS THE RESULT\n         B     LI15                GO TO EXIT\n         SPACE\nLI13     DS    0H\n         LA    R15,WRETLI          REPROCESS LINE LITERALLY\n         B     LI15                GO TO EXIT\n         SPACE\nLI14     DS    0H\n         LA    R15,0               ZERO RETURN CODE\nLI15     DS    0H\n        $EXIT  RC=(R15)            RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#LKADD": {"ttr": 7946, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x1d\\x00\\x1d\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*                            LKADD                                    *\n*                                                                     *\n*        ROUTINE TO ADD NEW CHARACTER BLOCK TO FREE STORAGE LIST      *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON EXIT  --  CC = BPOS    IF NEW CHAR BLOCK ADDED\n*                     CC = BNEG    IF FAILED\n         SPACE\nLKADD   $ENTER ,\n         L     R1,LKALEN           LENGTH OF ONE BLOCK\n        $CALL  GETCELL             GET ONE AREA\n         BC    BNEG,LKADD01        BRANCH IF FAILURE\n         USING LARAELEM,PCHAR      NEW AREA LOOKS LIKE THIS\n        $CALL  LKCHAIN             CHAIN THE NEW BLOCK\n         DROP  PCHAR\n        $CC    POS                 INDICATE SUCCESS\n         B     LKADD02             GO TO RETURN\n         SPACE\nLKADD01  DS    0H\n        $CC    NEG                 INDICATE FAILURE\n         SPACE\nLKADD02  DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nLKAONE   EQU   127                 NUMBER OF CHARS IN ONE BLOCK\nLKALEN   DC    A((LKAONE+1)*LINKBSIZ)   LENGTH OF ONE LARGE CHAR BLOCK\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#LKCHAIN": {"ttr": 7948, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00/\\x00/\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*                            LKCHAIN                                  *\n*                                                                     *\n*        ROUTINE TO INIT NEW LINK ELEMENT FREE STORAGE LIST           *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY --  (PCHAR) POINT TO NEW LARGE CHAR BLOCK\n         SPACE\nLKCHAIN $ENTER ,\n         USING LARAELEM,PCHAR      ENTRY PARM\n         XC    LARAELEM(LARABSIZ),LARAELEM   CLEAR BLOCK PREFIX\n         MVC   LARAFOR,LKANCH      NEXT LARGE BLOCK PTR\n         ST    PCHAR,LKANCH        POINT TO NEW LARGE BLOCK\n         SPACE\n         L     R1,LKASIZE          CURRENT TOTAL CHAR COUNT\n         LA    R1,LKAONE(,R1)      PLUS NUMBER WE ADD\n         ST    R1,LKASIZE          SET NEW TOTAL CHAR COUNT\n         L     R1,LKSIZE           LENGTH OF FREE LIST\n         LA    R1,LKAONE(,R1)      BUMP SAME\n         ST    R1,LKSIZE           UPDATE LENGTH OF FREE LIST\n         SPACE\n         LA    PCHAR,LARAELEM+LARABSIZ  CHARACTER BLOCKS GO HERE\n         USING LINKELEM,PCHAR      TELL THE ASSEMBLER\n         LA    R1,LINKELEM         REMEMBER THE FIRST\n         LA    COUNT,LKAONE-1      NUMBER OF BLOCKS TO LINK -1\n         SR    LAST,LAST           INITIALIZE BACKWARD POINTER\n         SR    R0,R0               CONSTANT ZERO\nLKCH01   DS    0H\n         LA    NEXT,LINKELEM+LINKBSIZ   ADDRESS OF NEXT ELEMENT\n         ST    NEXT,LINKFOR        SET FORWARD POINTER\n         ST    R0,LINKDOWN         INITIALIZE DOWNWARD LINE\n         ST    LAST,LINKBACK       SET BACKWARD LINK\n         LR    LAST,PCHAR          MOVE CURRENT TO LAST\n         LR    PCHAR,NEXT          MOVE FORWARD TO NEXT LINK ELEMENT\n         BCT   COUNT,LKCH01        TEST FOR END OF LIST\n         L     COUNT,LKSTAR        START OF FREE LIST\n         LTR   COUNT,COUNT         ANY LIST PRESENT .Q\n         BZ    LKCH02              BRANCH IF NOT\n         ST    PCHAR,LINKBACK-LINKELEM(,COUNT)    CHAIN BACKWARDS\nLKCH02   DS    0H\n         ST    COUNT,LINKFOR       LAST FORWARD POINTER TO EXISTING\n         ST    R1,LKSTAR           SET FIRST FREE ELEMENT\n         ST    R0,LINKDOWN         CLEAR LAST DOWN POINTER\n         DROP  PCHAR\n        $EXIT  RC=0                RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#LKGESC": {"ttr": 7950, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00A\\x00A\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 65, "newlines": 65, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              LKGESC  ---  ADD ESCAPE SEQUENCE TO OUTPUT             *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R1)    BASE OF CALLER'S SAVE\n*                      SAVEF0  OUTPUT POINTER\n*                      SAVEH0  COUNT OR COLUMN (IF REQUIRED)\n*                      SAVEX0  FUNCTION OFFSET IN TDEVICEA\n*\n*        ON EXIT   --  (R1)    NEXT AVAILABLE OUTPUT POINTER\n         SPACE\nLKGESC  $ENTER ,\n         LR    X1,R1               ENTRY PARM POINTER\n         USING SAVED0,X1           AND TELL THE ASSEMBLER\n         L     R1,SAVEF0           OUTPUT POINTER\n         L     X2,VDEVICEA         DEVICE POINTER\n         LTR   X2,X2               DOES IT EXIST .Q\n         BZ    LKGESC04            BRANCH IF NOT\n         USING TDEVICEA,X2         TELL THE ASSEMBLER\n         SR    TEMP,TEMP           CLEAR WORK REG\n         IC    TEMP,SAVEX0         GET FUNCTION BYTE\n         LA    TEMP,TDEVICEA(TEMP) POINT TO CODE\n         CLI   0(TEMP),X'00'       IS IT DEFINED .Q\n         BE    LKGESC04            BRANCH IF NOT\n         SPACE\n         SR    COUNT,COUNT         CLEAR LENGTH\n         IC    COUNT,0(,TEMP)      GET LENGTH\n         BCTR  COUNT,0             LENGTH-1\n         MVI   0(R1),CESCAPE       ENTER ESCAPE CHARACTER\n         EX    COUNT,LKGESCMV      ENTER FUNCTION STRING\n         LA    R1,2(COUNT,R1)      NEXT FREE CHARACTER\n         IC    COUNT,1(,TEMP)      GET FUNCTION TYPE\n         B     *+4(COUNT)          DO IT\n         B     LKGESC03                 ALL DONE\n         B     LKGESC01                 ADD COUNT TO FUNCTION\n         B     LKGESC02                 ADD COUNT+1 TO FUNCTION\n         SPACE\nLKGESC01 DS    0H\n         LH    COUNT,SAVEH0        GET FUNCTION CODE\n         A     COUNT,TDEVATEA      PLUS ASCII TO EBCDIC BASE\n         IC    R0,0(,COUNT)        GET EBCDIC CHARACTER\n         STC   R0,0(,R1)           AND SET IN OUTPUT\n         LA    R1,1(,R1)           BUMP OUTPUT POINTER\n         B     LKGESC03            AND GO TO RETURN\nLKGESC02 DS    0H\n         LH    COUNT,SAVEH0        GET FUNCTION CODE\n         A     COUNT,TDEVATEA      PLUS ASCII TO EBCDIC BASE\n         IC    R0,1(,COUNT)        GET EBCDIC CHARACTER\n         STC   R0,0(,R1)           AND SET IN OUTPUT\n         LA    R1,1(,R1)           BUMP OUTPUT POINTER\n         SPACE\nLKGESC03 DS    0H\n        $CC    POS                 SUCCESSFUL TERMINATION\n         B     LKGESC05            RETURN TO CALLER\n         SPACE\nLKGESC04 DS    0H\n        $CC    NEG                 NO FUNCTION PERFORMED\n         SPACE\nLKGESC05 DS    0H\n        $EXIT  KEEP=(R1),RC=0      RETURN TO CALLER\n         SPACE\nLKGESCMV MVC   1(*-*,R1),2(TEMP)   MOVE FUNCTION STRING\n         DROP  X1,X2\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#LKGETP": {"ttr": 7952, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00E\\x00E\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 69, "newlines": 69, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*                             LKGETP                                  *\n*                                                                     *\n*        ROUTINE TO CONVERT TOPOLOGICAL DATA STRUCTURE TO A SERIES OF *\n*        LINEAR CHARACTER STRING OVERLAYS SUITABLE FOR PRINTER OUTPUT.*\n*        ON EACH CALL TO THIS ROUTINE ONE MORE LAYER IS PEELED FROM   *\n*        THE TOPOLOGICAL DATA STRUCTURE.                              *\n*        ELEMENTS THAT ARE PEELED OFF ARE RETURNED TO FREE STORAGE.   *\n*        AFTER THE LAST LAYER HAS BEEN PEELED, THE ENTIRE REMAINING   *\n*        TOPOLOGICAL DATA STRUCTURE IS RETURNED TO FREE STORAGE.      *\n*                                                                     *\n***********************************************************************\n         SPACE\nLKGETP  $ENTER ,\n         USING LKPMLIST,R1         TELL ASSEMBLER WHAT CALLER TOLD ME\n         L     PCHAR,PMCHLOC       GET LOCATION OF CHARACTER STRING\n         L     COUNT3,PMELLNG      GET LENGTH OF PRIMARY LINE\n         L     COUNT2,LKSIZE       GET SIZE OF FREE LIST\n         L     PFOR,PMELFIR        GET LOC. OF FIRST LINK ELEMENT\n         SR    MULT,MULT           CLEAR MULTIPLIER REGISTER\n         SR    R0,R0               ASSUME NO OVERLAY LINE WILL BE LEFT\n         LA    R15,1               CONSTANT ONE\n         SPACE\nFORMP1   DS    0H\n         USING LINKELEM,PFOR\n         IC    MULT,LINKMULT       GET MULTIPLIER\n         IC    R14,LINKCHAR        GET CHARACTER\nFORMP2   DS    0H\n         STC   R14,0(,PCHAR)       SET CHARACTER\n         AR    PCHAR,R15           ADVANCE CHARACTER\n         BCT   MULT,FORMP2         MULTIPLY CHARACTER\n         SPACE\n         L     PDOWN,LINKDOWN      GET DOWN POINTER\n         LTR   PDOWN,PDOWN         DOES IT EXIST\n         BZ    FORMP3              NO, MOVE TO NEXT FORWARD LINK\n         SPACE\n         MVC   LINKCHAR,LINKCHAR-LINKELEM(PDOWN)  MOVE CHAR TO UPPER\n         MVC   LINKDOWN,LINKDOWN-LINKELEM(PDOWN)  DETACH LINK\n         MVC   LINKFOR-LINKELEM(4,PDOWN),LKSTAR   ADD TO FREE LIST\n         ST    PDOWN,LKSTAR        ...\n         AR    COUNT2,R15          BUMP SIZE OF FREE LIST\n         CLI   LINKCHAR-LINKELEM(PDOWN),CESCAPE  ESCAPE SEQUENCE .Q\n         BE    FORMP3              BRANCH IF YES\n         LA    R0,1                AT LEAST ONE OVERLAY LINE LEFT\n         B     FORMP4              BRANCH INTO LOOP\n         SPACE\nFORMP3   DS    0H\n         MVI   LINKCHAR,C' '       CLEAR CHARACTER FROM LINK\nFORMP4   DS    0H\n         L     PFOR,LINKFOR        ADVANCE LINK POINTER\n         BCT   COUNT3,FORMP1       AND GO AROUND AGAIN\n         LTR   R0,R0               ANY OVERLAY LINES LEFT .Q\n         BNZ   FORMP6              BRANCH IF YES\n         DROP  PFOR\n         SPACE\nFORMP5   DS    0H                  NO MORE OVERPRINT CHARS, UNLINK LINE\n         L     PFOR,PMELLST        GET LOC. OF LAST LINK\n         MVC   0(4,PFOR),LKSTAR    JOIN TO FREE LIST\n         MVC   LKSTAR,PMELFIR      ...\n         A     COUNT2,PMELLNG      INCREMENT FREE LIST LENGTH\n         XC    PMELLNG,PMELLNG     INDICATE END OF OVERPRINT\n         SPACE\nFORMP6   DS    0H                  ANOTHER OVERPRINT LINE REMAINS\n         ST    COUNT2,LKSIZE       UPDATE LINK SIZE\n         S     PCHAR,PMCHLOC       CURRENT OUT POINTER LESS START\n         ST    PCHAR,PMCHLNG       SET CHARACTER STRING LENGTH\n        $EXIT  RC=0                RETURN TO CALLER\n         DROP  R1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#LKGETT": {"ttr": 7954, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00c\\x00c\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 99, "newlines": 99, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*                             LKGETT                                  *\n*                                                                     *\n*        ROUTINE TO CONVERT TOPOLOGICAL DATA STRUCTURE TO A SINGLE    *\n*        LINEAR CANONICALIZED CHARACTER STRING SUITABLE FOR TYPEWRITER*\n*        OUTPUT.                                                      *\n*        THE TOPOLOGICAL DATA STRUCTURE IS RETURNED TO FREE STORAGE.  *\n*                                                                     *\n***********************************************************************\n         SPACE\nLKGETT  $ENTER ,\n         USING LKPMLIST,R1         TELL ASSEMBLER WHAT CALLER TOLD ME\n         L     PCHAR,PMCHLOC       GET LOC. OF CHARACTER STRING\n         L     COUNT3,PMELLNG      GET LENGTH OF PRIMARY LINE\n         L     COUNT2,LKSIZE       GET SIZE OF FREE LIST\n         AR    COUNT2,COUNT3       ADD PRIMARY LINE ELEMENTS\n         L     PFOR,PMELFIR        GET LOC. OF FIRST LINK ELEMENT\n         USING LINKELEM,PFOR\n         SR    MULT,MULT           CLEAR MULTIPLER REGISTER\n         MVC   SAVEH0,LINKWID      INIT LAST CHARACTER WIDTH\n         B     FORMT2              DON'T CHECK FIRST CHARACTER\n         SPACE\nFORMT1   DS    0H\n         CLC   SAVEH0,LINKWID      SAME CHARACTER WIDTH .Q\n         BE    FORMT2              BRANCH IF YES\n         MVC   SAVEH0,LINKWID      GET NEW WIDTH\n         MVI   SAVEX0,TDEVHMI-TDEVICEA  HORIZONTAL MOTION INDEX\n         ST    PCHAR,SAVEF0        WHERE TO PUT IT\n         LR    R0,R1               RETAIN INPUT PARM POINTER\n         LA    R1,SAVED0           POINT TO PARM AREA\n        $CALL  LKGESC              ADD ESCAPE SEQUENCE\n         LR    PCHAR,R1            NEXT AVAILABLE COLUMN\n         LR    R1,R0               RESTORE INPUT PARM POINTER\n         SPACE\nFORMT2   DS    0H\n         IC    MULT,LINKMULT       GET MULTIPLIER\n         ST    MULT,LKMULT         SAVE MULTIPLIER\n         IC    R0,LINKCHAR         GET CHARACTER\nFORMT3   DS    0H\n         STC   R0,0(,PCHAR)        SET CHARACTER\n         LA    PCHAR,1(,PCHAR)     ADVANCE CHARACTER POINTER\n         BCT   MULT,FORMT3         MULTIPLY CHARACTER\n         SPACE\n         LR    PDOWN,PFOR          SET POINTER\n         DROP  PFOR\n         USING LINKELEM,PDOWN\n         SPACE\nFORMT4   DS    0H\n         OC    LINKDOWN,LINKDOWN   ANY MORE DOWN POINTERS .Q\n         BZ    FORMT9              BRANCH IF NOT\n         L     PDOWN,LINKDOWN      YES, GET POINTER\n         LA    COUNT2,1(,COUNT2)   INCREMENT FREE LINK COUNTER\n         CLI   LINKCHAR,CESCAPE    ESCAPE CHARACTER .Q\n         BE    FORMT7              BRANCH IF YES\n         CLI   LINKCHAR,C' '       IS OVERSTRIKE CHARACTER BLANK .Q\n         BE    FORMT8              BRANCH AROUND IF YES\n         L     MULT,LKMULT         RETRIEVE MULTIPLIER\n         IC    R0,LINKCHAR         GET CHARACTER\n         SPACE\nFORMT5   DS    0H\n         MVI   0(PCHAR),CBACKSP    INSERT A BACKSPACE\n         LA    PCHAR,1(,PCHAR)     ADVANCE OUTPUT CHAR POINTER\n         BCT   MULT,FORMT5         AS OFTEN AS REQUIRED\n         L     MULT,LKMULT         RETRIEVE MULTIPLIER AGAIN\nFORMT6   DS    0H\n         STC   R0,0(,PCHAR)        SET OVERSTRIKE CHARACTER\n         LA    PCHAR,1(,PCHAR)     ADVANCE OUTPUT CHAR POINTER\n         BCT   MULT,FORMT6         AS OFTEN AS REQUIRED\n         B     FORMT8              AND CONTINUE\n         SPACE\nFORMT7   DS    0H\n         MVC   0(1,PCHAR),LINKCHAR ADD ESCAPE CHARACTER\n         IC    MULT,LINKMULT       LENGTH OF ESCAPE FUNCTION\n         EX    MULT,FORMTMVC       ENTER ESCAPE FUNCTION\n         LA    PCHAR,2(MULT,PCHAR) BUMP OUTPUT POINTER\nFORMT8   DS    0H\n         MVC   LINKFOR,LINKDOWN    SWITCH POINTERS\n         B     FORMT4              CHECK FOR MORE DOWN POINTERS\nFORMTMVC MVC   1(*-*,PCHAR),LINKESC     ADD ESCAPE FUNCTION\n         SPACE\nFORMT9   DS    0H\n         DROP  PDOWN\n         USING LINKELEM,PFOR\n         L     R0,LINKFOR          SAVE PRIMARY FORWARD POINTER\n         MVC   LINKFOR,LINKDOWN    RELINK PRIMARY\n         ST    R0,0(,PDOWN)        AND LINK LAST ELEMENT\n         LR    PFOR,R0             ADVANCE ALONG PRIMARY\n         BCT   COUNT3,FORMT1       PROCESS NEXT CHARACTER\n         DROP  PFOR\n         SPACE\n         MVC   0(4,PDOWN),LKSTAR   ADD TO FREE LINK LIST\n         MVC   LKSTAR,PMELFIR      ...\n         ST    COUNT2,LKSIZE       SET FREE LIST LENGTH\n         S     PCHAR,PMCHLOC       CALCULATE CHARACTER STRING LENGTH\n         ST    PCHAR,PMCHLNG       ...\n         XC    PMELLNG,PMELLNG     INDICATE STRING HAS BEEN FREED\n         DROP  R1\n        $EXIT  RC=0                RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#LKINIT": {"ttr": 8195, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00(\\x00(\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*                             LKINIT                                  *\n*                                                                     *\n*        ROUTINE TO INITIALIZE THE LINK ELEMENT FREE STORAGE LIST.    *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON EXIT  --  CC = BPOS    IF SUCCESSFUL\n*                     CC = BNEG    IF ERROR\n         SPACE\nLKINIT  $ENTER ,\nLKINIT01 DS    0H\n         L     PCHAR,LKANCH        LINK CHARACTER ANCHOR\n         LTR   PCHAR,PCHAR         FIRST TIME .Q\n         BNZ   LKINIT02            BRANCH IF NOT\n        $CALL  LKADD               ADD ONE BLOCK\n         BC    BPOS,LKINIT01       IF SUCCESSFUL, TRY AGAIN\n         MVI   EFLAG020,ERRTERM    SET ERROR MESSAGE\n        $CC    NEG                 SET ERROR CONDITION CODE\n         B     LKINIT05            AND GO TO RETURN\n         SPACE\nLKINIT02 DS    0H\n         XC    LKANCH,LKANCH       CLEAR CHARACTER BLOCK ANCHOR\n         XC    LKASIZE,LKASIZE     AND CHARACTER COUNT\n         XC    LKSTAR,LKSTAR       CLEAR START OF FREE LIST\n         XC    LKSIZE,LKSIZE       CLEAR COUNT OF FREE LIST\nLKINIT03 DS    0H\n         LTR   PCHAR,PCHAR         AT THE END .Q\n         BZ    LKINIT04            BRANCH IF YES\n         USING LARAELEM,PCHAR      CHARACTER HEADER BLOCK\n        $CALL  LKCHAIN             CHAIN ELEMENTS OF THIS BLOCK\n         L     PCHAR,LARAFOR       NEXT CHARACTER BLOCK HEADER\n         B     LKINIT03            TRY AGAIN\n         DROP  PCHAR\nLKINIT04 DS    0H\n        $CC    POS                 INDICATE SUCCESS\n         SPACE\nLKINIT05 DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#LKPUT": {"ttr": 8197, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x01\\r\\x01\\r\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 269, "newlines": 269, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*                             LKPUT                                   *\n*                                                                     *\n*        ROUTINE TO CONVERT LINEAR CHARACTER STRING, CANONICALIZED    *\n*        OR NON-CANONICALIZED TO TOPOLOGICAL DATA STRUCTURE.          *\n*                                                                     *\n*              THERE IS A CHAIN OF DOUBLY LINKED ELEMENTS,            *\n*              ONE FOR EACH COLUMN IN THE INPUT LINE.                 *\n*              EACH ELEMENT MAY HAVE A SUBSIDIARY CHAIN OF            *\n*              ELEMENTS REPRESENTING CHARACTERS TO BE PRINTED         *\n*              IN THE SAME COLUMN -- THE FORWARD AND BACKWARD         *\n*              POINTERS ARE UNUSED IN THE OVERLAY ELEMENTS.           *\n*              THE ELEMENTS IN THE MAIN CHAIN CONTAIN THE             *\n*              EBCDIC CHARACTER AND A REPETITION FACTOR (KNOWN        *\n*              AS A MULTIPLIER.                                       *\n*                                                                     *\n***********************************************************************\n         SPACE\n*              THIS ROUTINE USED THE FOLLOWING REGISTERS -            *\n*                                                                     *\n*        R0        NUMBER OF FREE LINK ELEMENTS                       *\n*        R1        PARAMETER LIST POINTER                             *\n*        PCHAR     POINTER TO CURRENT CHARACTER IN INPUT              *\n*        COUNT     CHARACTER COUNTER FOR MAIN LOOP                    *\n*        COUNT2    NUMBER OF OUTPUT COLUMNS                           *\n*                  NUMBER OF PRIMARY LINKS ALLOCATED                  *\n*        LAST      END OF CHAIN POINTER.  THIS IS THE ELEMENT FOR     *\n*                  THE RIGHTMOST COLUMN ADDED, BUT NEED NOT BE        *\n*                  THE MOST RECENTLY ADDED.                           *\n*        NEXT      POINTER TO NEXT FREE LINK TO BE USED.              *\n*        CUR       POINTER TO LINK ELEMENT OF CURRENT COLUMN.         *\n*        TOP       POINTER TO TOP LINK ELEMENT OF MOST RECENTLY       *\n*                  ADDED OR OVERLAYED COLUMN.   CHANGED TO LKTOP      *\n*        BOT       POINTER TO BOTTOM LINK ELEMENT OF MOST             *\n*                  RECENTLY ADDED OVERLAYED COLUMN.                   *\n*        COL       CARRIAGE COUNTERED.  DECREMENTED FOR EACH          *\n*                  BACKSPACE AND INCREMENTED FOR ALL ELSE.            *\n*                  CORRESPONDS TO 'CUR' LINK ELEMENT.                 *\n*        BASE      MAIN REGISTER FOR ADDRESSABILITY                   *\n*        R13       SCRIPT COMMON DATA AREA ADDRESSABILITY             *\n*        R15       CONSTANT FULLWORD ONE.                             *\n         SPACE\nLKPUT   $ENTER ,\n         USING LKPMLIST,R1         TELL ASSEMBLER WHAT CALLER TOLD ME\n         L     PCHAR,PMCHLOC       GET ADDRESS OF INPUT STRING\n         L     COUNT,PMCHLNG       GET LENGTH OF INPUT STRING\n         LTR   COUNT,COUNT         NULL BUFFER PASSED .Q\n         BNP   LKPUT19             YES, THEN IGNORE IT\nLKPUT01  DS    0H\n         SR    COL,COL             INITIALIZE CARRIAGE COUNT\n         SR    COUNT2,COUNT2       CLEAR NUMBER OF OUTPUT COLUMNS\n         LA    CUR,LKSTAR          FIRST FREE ELEMENT\n         USING LINKELEM,CUR        ADDRESSABILITY\n         L     R0,LKSIZE           NUMBER OF FREE ELEMENTS\n         CR    R0,COUNT            ENOUGH LINKS LEFT .Q\n         BH    LKPUT02             BRANCH IF YES\n        $CALL  LKADD               ADD ANOTHER CHARACTER BLOCK\n         BC    BPOS,LKPUT01        RETRY IF SUCCESSFUL\n         MVI   EFLAG020,ERRTERM    SET ERROR FLAG\n         B     LKPUT19             AND BRANCH TO RETURN\n         SPACE\nLKPUT02  DS    0H\n        $OFF   ESCFLAG,ESCSW       CLEAR ESCAPE SWITCH\n         SR    LAST,LAST           EMPTY CHAIN INITIALLY,\n         L     NEXT,LKSTAR         BEGINNING WITH FIRST FREE\n         ST    NEXT,PMELFIR        SET FIRST FREE\n         XC    LKTOP,LKTOP         NO COLUMN PROCESSED\n         SPACE\n         LR    R15,R1              TRT CAN BE DESTRUCTIVE\n         EX    COUNT,LPUTTRT       ANY BACKSPACES IN THIS STRING\n         LR    R1,R15              RESTORE REGISTER\n         L     COUNT,PMCHLNG       RESTORE LENGTH OF STRING\n         LA    R15,1               FULLWORD CONSTANT OF ONE\n         BNZ   LKPUT04             FULL CANONICAL ROUTINE IF ANY\n         SPACE\n*              CONTROL ARRIVES HERE ONLY WHEN THE INPUT CHARACTER     *\n*              STRING DOES NOT CONTAIN ANY BACKSPACE CHARACTERS.      *\n*              THIS ROUTINE WAS ADDED AS AN EFFICIENCY CONSIDERATION, *\n*              THE LKPUT04  ROUTINE HAS THE SAME RESULT WITH MORE     *\n*              CHECKING.                                              *\n         SPACE\n         AR    COUNT2,COUNT        FINAL NUMBER OF OUTPUT COLUMNS\n         SR    R0,COUNT            DECREMENT NUMBER OF FREE ELEMENTS\nLKPUT03  DS    0H\n         LA    LAST,0(,CUR)        SAVE LAST POINTER\n         L     CUR,LINKFOR         MOVE FORWARD ALONG FREE LIST\n         XC    LINKELEM+4(LINKBSIZ-4),LINKELEM+4  CLEAR CHAR BLOCK\n         ST    LAST,LINKBACK       SET BACKWARD POINTER\n         MVC   LINKCHAR,0(PCHAR)   ENTER CHARACTER\n         MVI   LINKMULT,X'01'      SET MULT FACTOR\n         MVC   LINKWID,TDEVWID     SET CHARACTER WIDTH\n         AR    PCHAR,R15           MOVE TO NEXT INPUT CHAR\n         BCT   COUNT,LKPUT03       DO THEM ALL\n         SPACE\n         LA    LAST,0(,CUR)        LAST CHAR ELEMENT POINTER\n         L     NEXT,LINKFOR        NEXT FORWARD POINTER\n         B     LKPUT16             GO TO EXIT ROUTINE\n         SPACE\nLPUTTRT  TRT   0(*-*,PCHAR),LPUTBKSP  EXECUTED TEST FOR BACKSPACE\n         DC    0D'0'\nLPUTBKSP DC    XL256'00'           INITIALIZE THE AREA\n         ORG   LPUTBKSP+CBACKSP\n         DC    X'FF'               BACKSPACE ENTRY\n         ORG   LPUTBKSP+CESCAPE\n         DC    X'FF'               ESCAPE ENTRY\n         ORG   ,\n         SPACE\nLKPUT04  DS    0H\n        $IFON  ESCFLAG,ESCSW,LKPUT05    BRANCH IF AFTER AN ESCAPE\n         CLI   0(PCHAR),CBACKSP    BACKSPACE .Q\n         BE    LKPUT11             YES, DO BACKSPACE PROCESSING\n         CLI   0(PCHAR),CESCAPE    ESCAPE CHARACTER .Q\n         BE    LKPUT14             YES, DO ESCAPE PROCESSING\n         L     CUR,LINKFOR         NEXT FORWARD POINTER\nLKPUT05  DS    0H\n         SR    R0,R15              DECREMENT NUMBER OF FREE\n         AR    COL,R15             BUMP CARRIAGE COUNTER\n         CR    CUR,NEXT            REMOVING BACKSPACES .Q\n         BNE   LKPUT06             YES, SET UP OVERLAY\n         AR    COUNT2,R15          BUMP NUMBER OF COLUMNS\n         DROP  CUR\n         USING LINKELEM,NEXT       MOVE TO NEXT BLOCK\n         XC    LINKELEM+4(LINKBSIZ-4),LINKELEM+4  CLEAR CHAR BLOCK\n         ST    LAST,LINKBACK       BACK POINTER FOR NEW ELEMENT\n         DROP  NEXT\n         USING LINKELEM,CUR        BACK TO CURRENT\n         LA    LAST,0(,NEXT)       CLEAR CHAR AND BUMP BLOCKS\n         L     NEXT,LINKFOR        NEXT FREE ELEMENT\n         ST    CUR,LKTOP           NO OVERLAY INITIALLY\n         LR    BOT,CUR\n         B     LKPUT08             MOVE IN CHAR FROM STRING\n         SPACE\n*              CONTROL ARRIVES HERE WHEN AN INPUT CHARACTER MUST      *\n*              BE PLACED IN THE SAME COLUMN AS AN EXISTING CHAR.      *\n*              IF THE BOTTOM LINK FOR THIS COLUMN IS NOT KNOWN,       *\n*              THEN IT MUST BE LOCATED.                               *\n         SPACE\nLKPUT06  DS    0H\n         C     CUR,LKTOP           THIS COLUMN LOCATED .Q\n         BE    LKPUT07             YES, SET UP OVERLAY\n         ST    CUR,LKTOP           TOP EQUALS CUR\n         LR    BOT,CUR             BOT EQUALS CUR->DOWN->DOWN...\n         SPACE\n*              CONTROL ARRIVES HERE WHEN BOTTOM LINK OF CURRENT       *\n*              COLUMN IS NOT KNOWN.  BOTTOM IS LOCATED BY             *\n*              FOLLOWING LINKDOWN FROM CUR TO THE END AT ZERO.        *\n         SPACE\n         DROP  CUR\n         USING LINKELEM,BOT        LOOKING WITH BOT\nLKPUT06A DS    0H\n         L     R14,LINKDOWN        NEXT OVERLAY LEVEL\n         LTR   R14,R14             END OF THE DOWN CHAIN .Q\n         BZ    LKPUT07             BRANCH IF YES\n         LR    BOT,R14             NEXT ATTEMPT\n         B     LKPUT06A            AND GO TRY AGAIN\n         DROP  BOT\n         SPACE\n*              CONTROL ARRIVES HERE TO ADD A NEW LINK IN THE SAME     *\n*              COLUMN AS AN EXISTING CHARACTER, AFTER THE BOTTOM      *\n*              LINK ELEMENT IN THE COLUMN HAS BEEN LOCATED AND        *\n*              POINTED TO BY REGISTER BOT.                            *\n         SPACE\n         USING LINKELEM,LAST       RECHAIN NEW TO NEXT\nLKPUT07  DS    0H\n         MVC   LINKFOR,LINKFOR-LINKELEM(NEXT)     NEW TO NEXT\n         DROP  LAST\n         USING LINKELEM,BOT        CURRENT BOTTOM ELEMENT\n         ST    NEXT,LINKDOWN       CHAIN NEW INTO DOWN CHAIN\n         LR    BOT,NEXT            SET NEW BOTTOM\n         L     NEXT,LINKFOR        NEXT FREE ELEMENT\n         ST    NEXT,LKSTAR         UPDATE FREE LIST START\n         XC    LINKELEM(LINKBSIZ),LINKELEM   CLEAR CHARACTER BLOCK\n         SPACE\nLKPUT08  DS    0H\n         MVI   LINKMULT,X'01'      SET MULT FACTOR\n         MVC   LINKWID,TDEVWID     SET CHARACTER WIDTH\n        $IFON  ESCFLAG,ESCSW,LKPUT09    BRANCH IF AFTER AN ESCAPE\n         MVC   LINKCHAR,0(PCHAR)   CHARACTER FROM STRING\n         B     LKPUT15             GO TO END OF LOOP\n         SPACE\nLKPUT09  DS    0H\n        $OFF   ESCFLAG,ESCSW       RESET ESCAPE CHARACTER SWITCH\n        $SAVE  ,                   SAVE ALL REGISTERS\n         SR    R14,R14             CLEAR WORK REG\n         L     R14,VDEVICEA        TERMINAL DESCRIPTOR AREA ADDR\n         LTR   CUR,R14             DOES IT EXIST .Q\n         BZ    LKPUT10             BRANCH IF NOT\n         USING TDEVICEA,CUR        AREA LOOKS LIKE THIS\n         SR    R14,R14             ZERO WORK REG\n         IC    R14,0(,PCHAR)       GET FUNCTION CHARACTER\n         IC    R14,TDEVAESC(R14)   GET LENGTH-1 OF FUNCTION\nLKPUT10  DS    0H\n         EX    R14,LKPUTMVC        MOVE FUNCTION STRING\n         STC   R14,LINKMULT        RETAIN LENGTH-1 OF ESCAPE STRING\n         MVI   LINKCHAR,CESCAPE    AND SET CHARACTER ITSELF TO ESCAPE\n         AR    PCHAR,R14           BUMP BY STRING LENGTH-1\n         SR    COUNT,R14           DECREMENT LENGTH LEFT BY LENGTH-1\n        $RESTOR KEEP=(PCHAR,COUNT) RESTORE REGISTERS\n         BNP   LKPUT16             BRANCH IF NOTHING LEFT\n         B     LKPUT15             ELSE CONTINUE\nLKPUTMVC MVC   LINKESC(*-*),0(PCHAR)    ENTER ESCAPE STRING\n         DROP  BOT\n         SPACE\n*              CONTROL ARRIVES HERE FOR BACKSPACE IN INPUT            *\n         SPACE\nLKPUT11  DS    0H\n         CLI   1(PCHAR),CESCAPE    NEXT CHAR AN ESCAPE .Q\n         BNE   LKPUT12             BRANCH IF NOT\n         MVC   0(2,PCHAR),1(PCHAR) DO THE ESCAPE FIRST\n         MVI   2(PCHAR),CBACKSP    RESTORE BACKSPACE\n         B     LKPUT04             AND RETRY\nLKPUT12  DS    0H\n         SR    COL,R15             BACKSPACE PAST COLUMN ONE .Q\n         BP    LKPUT13             BRANCH IF NOT\n         MVI   EFLAG021,ERRSET     SET TOO MANY BACKSPACES ERROR\n         AR    COL,R15             RESET COLUMN ONE OR ZERO\n         B     LKPUT15             RETURN TO MAIN LOOP\n         SPACE\nLKPUT13  DS    0H\n         USING LINKELEM,CUR        USE THE CURRENT BLOCK\n         L     CUR,LINKBACK        PREVIOUS COLUMN\n         DROP  CUR\n         B     LKPUT15             RETURN TO MAIN LOOP\n         SPACE\n*              CONTROL ARRIVES HERE FOR ESCAPE IN INPUT               *\n         SPACE\nLKPUT14  DS    0H\n        $ON    ESCFLAG,ESCSW       TURN ON ESCAPE CHAR SWITCH\n         SR    COL,R15             ESCAPE PAST COLUMN ZERO .Q\n         BNM   LKPUT15             BRANCH IF NOT\n         MVI   EFLAG021,ERRSET     SET TOO MANY ESCAPE ERROR\n         AR    COL,R15             RESET COLUMN ZERO\n        $OFF   ESCFLAG,ESCSW       TURN OFF ESCAPE SWITCH\n         B     LKPUT15             RETURN TO MAIN LOOP\n         SPACE\n*              CONTROL ARRIVES HERE AFTER ADDING A NEW LINK.          *\n*              THIS IS ALSO THE COMMON PATH FOR BACKSPACE.            *\n         SPACE\nLKPUT15  DS    0H\n         AR    PCHAR,R15           BUMP CHAR BY ONE\n         BCT   COUNT,LKPUT04       DO FOR ALL IN THE STRING\n         SPACE\n*              CONTROL ARRIVES HERE WHEN ALL THE INPUT HAS            *\n*              BEEN CONVERTED TO 'TOPOLOGICAL' STRUCTURE.             *\n         SPACE\nLKPUT16  DS    0H\n         LTR   COUNT2,COUNT2       ANY INPUT CONVERTED .Q\n         BNZ   LKPUT17             BRANCH IF YES\n         XC    PMELFIR,PMELFIR     CLEAR START LINK\n         SR    LAST,LAST           CLEAR END LINK\n         B     LKPUT18             AND CONTINUE\n         SPACE\n         USING LINKELEM,LAST\nLKPUT17  DS    0H\n         XC    LINKFOR,LINKFOR     DECHAIN FROM FREE LIST\n         DROP  LAST\n         SPACE\n         USING LINKELEM,NEXT\n         XC    LINKBACK,LINKBACK   DECHAIN FROM FREE LIST\n         ST    NEXT,LKSTAR         UPDATE FREE LIST START\nLKPUT18  DS    0H\n         ST    R0,LKSIZE           UPDATE NUMBER FREE ELEMENTS\n         ST    LAST,PMELLST        UPDATE PARM LIST START\n         ST    COUNT2,PMELLNG      UPDATE PARM LINK COUNT\n         SPACE\nLKPUT19  DS    0H\n         DROP  NEXT,R1\n        $EXIT  RC=0                RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#LL": {"ttr": 8202, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00)\\x00)\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .LINE LENGTH (.LL) --- CONTROL                         *\n*                                                                     *\n***********************************************************************\n         SPACE\nLL      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n        $CALL  GETNUM              GET NUMBER\n         BC    BDNO,LL03           ERROR IF INVALID\n         BC    BOMIT,LL01          BRANCH IF OMITTED\n         CLI   NUMSIGN,C' '        WAS OPERAND SIGNED .Q\n         BE    LL02                BRANCH IF NOT\n         A     COUNT,LLZ           MAKE RELATIVE CHANGE\n         B     LL02                GO CHECK AND ENTER\nLL01     DS    0H\n         L     COUNT,DEFLL+TAB3DEF  GET DEFAULT LINE LENGTH VALUE\nLL02     DS    0H\n         CH    COUNT,PICNT         TEST GREATER THAN PARAGRAPH INDENT\n         BNH   LL05                ERROR IF NOT\n         C     COUNT,DEFLL+TAB3MIN LESS THAN MINIMUM .Q\n         BL    LL05                ERROR IF YES\n         C     COUNT,DEFLL+TAB3MAX IS IT BEYOND MAX LENGTH .Q\n         BH    LL04                YES, ERROR\n         ST    COUNT,LLZ           SET LINE LENGTH\n         OC    CLLZSAVE,CLLZSAVE   HAS COLUMN LENGTH BEEN SET .Q\n         BNZ   LL06                BRANCH IF YES\n         ST    COUNT,CLLZ          SET LINE LENGTH AGAIN FOR WORK\n         B     LL06                GO TO TERMINATE\n         SPACE\nLL03     DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     LL06                GO TO TERMINATE\nLL04     DS    0H\n         MVI   EFLAG013,ERRSET     OPERAND TOO BIG\n         B     LL06                GO TO TERMINATE\nLL05     DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         SPACE\nLL06     DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#LN": {"ttr": 8204, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00E\\x00E\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 69, "newlines": 69, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .LN (IMMEDIATE LINE) --- CONTROL                       *\n*                                                                     *\n***********************************************************************\n         SPACE\nLN      $ENTER ,\n         CLI   ICORFLG,ICORNONE    SAVING FORMATTED TEXT INCORE .Q\n         BNE   LNE012              ERROR IF YES\n        $CALL  PRINTNB             CLEAR OUT PRINT BUFFER\n        $CALL  GETNUM              GET NUMBER OF TARGET LINE\n         BC    BOMIT,LNE003        ERROR IF ARG OMITTED\n         BC    BDNO,LNE005         ERROR IF INVALID\n         SPACE\n        $IFOFF SWITCHS,FEMPTY,LN01 BRANCH IF PAGE NOT EMPTY\n        $CALL  PAGETOP             START THIS PAGE GOING\nLN01     DS    0H\n         SR    X1,X1               ZERO TARGET LINE\n         CLI   NUMSIGN,C' '        OPERAND UNSIGNED .Q\n         BE    LN02                BRANCH IF YES\n         LH    X1,PLZ              PAGE LENGTH LESS REMAINDER\n         SH    X1,PLCT             IS LINES ALREADY PRINTED\n         SH    X1,TOPMRG           RELATIVE OFFSET FROM TOP MARGIN\n         A     X1,F1               PLUS CURRENT LINE\nLN02     DS    0H\n         AR    X1,COUNT            TARGET LINE NUMBER AFTER TOP MARGIN\n         S     X1,F1               LESS CURRENT LINE\n         BM    LNE014              ERROR IF TOO SMALL\n         LH    R0,PLZ              PAGE LENGTH\n         SH    R0,TOPMRG           LESS TOP MARGIN\n         SH    R0,BMMRG            LESS BOTTOM MARGIN\n         CR    X1,R0               TOO BIG .Q\n         BNL   LNE013              ERROR IF YES\n         SPACE\n         AH    X1,TOPMRG           ABSOLUTE LINE NUMBER\n         SH    X1,PLZ              LINE NUMBER LESS PAGE LENGTH\n         LPR   X1,X1               IS LINES TO BE LEFT AFTER\n         SPACE\nLN03     DS    0H\n         CH    X1,PLCT             FURTHER DOWN PAGE TO GO .Q\n         BNH   LN04                BRANCH IF YES\n        $CALL  PAGE                FINISH CURRENT PAGE\n        $IFOFF SWITCHS,FEMPTY,LN03 BRANCH IF PAGE STARTED\n        $CALL  PAGETOP             AND START THE NEXT\n         B     LN03                ALLOW FOR FLOATING KEEPS\n         SPACE\nLN04     DS    0H\n         LH    COUNT,PLCT          LINES LEFT ON THIS PAGE\n         SR    COUNT,X1            LESS WHERE WE WANT TO BE\n        $CALL  SPACER              SPACE DOWN, IGNORING REMOTES\n        $CALL  RMNEXT              SET UP FOR NEXT REMOTE\nLN05     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nLNE003   DS    0H\n         MVI   EFLAG003,ERRSET     OMITTED OPERAND\n         B     LN05                GO TO RETURN\nLNE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     LN05                GO TO RETURN\nLNE012   DS    0H\n         MVI   EFLAG012,ERRSET     CONTROL WORD ILLEGAL HERE\n         B     LN05                GO TO RETURN\nLNE013   DS    0H\n         MVI   EFLAG013,ERRSET     OPERAND TOO BIG\n         B     LN05                GO TO RETURN\nLNE014   DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     LN05                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#LS": {"ttr": 8206, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00,\\x00,\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .LS (LINE SPACING) --- CONTROL                         *\n*                                                                     *\n***********************************************************************\n         SPACE\nLS      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BOMIT+BNEG,LS02     OMITTED OR 'NO' IS SINGLE\n         BC    BPOS,LS03           'YES' IS DOUBLE\n         ST    COUNT,ARGSTART      RESET START OF SCAN\n        $CALL  GETNUM              IT IS PROBABLY NUMERIC\n         BC    BDNO,LSE005         BRANCH IF INVALID\n         CLI   NUMSIGN,C' '        WAS OPERAND UNSIGNED .Q\n         BE    LS01                BRANCH IF YES\n         AH    COUNT,DSCNT         MAKE RELATIVE CHANGE\nLS01     DS    0H\n         LTR   COUNT,COUNT         IS OPERAND TOO SMALL .Q\n         BM    LSE014              ERROR IF YES\n         CH    COUNT,PLZ           IS OPERAND TOO BIG .Q\n         BH    LSE013              ERROR IF YES\n         STH   COUNT,DSCNT         STORE LINE SPACING COUNT\n         B     LS04                GO TO TERMINATE\n         SPACE\nLS02     DS    0H\n         XC    DSCNT,DSCNT         LINE SPACING FACTOR IS ZERO\n         B     LS04                GO TO TERMINATE\nLS03     DS    0H\n         MVC   DSCNT,H1            LINE SPACING FACTOR IS ONE\n         B     LS04                GO TO TERMINATE\n         SPACE\nLS04     DS    0H\n        $EXIT  RC=0                AND RETURN\n         SPACE\nLSE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     LS04                GO TO TERMINATE\nLSE013   DS    0H\n         MVI   EFLAG013,ERRSET     OPERAND TOO BIG\n         B     LS04                GO TO TERMINATE\nLSE014   DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     LS04                GO TO TERMINATE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#MAINOC": {"ttr": 8208, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00I\\x00I\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 73, "newlines": 73, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              OVERLAY CHARACTER ON INPUT                             *\n*                                                                     *\n***********************************************************************\n         SPACE\nMAINOC  $ENTER ,\n         LH    R15,OCCNT           GET OVERLAY TEXT LINE COUNT\n         S     R15,F1              LESS ONE\n         BM    MAINOC08            BRANCH IF NONE LEFT\n         STH   R15,OCCNT           UPDATE WITH REMAINDER\n         CLI   OCCHAR,C' '         ANY OVERLAY CHARACTER .Q\n         BE    MAINOC08            BRANCH IF NONE\n         LH    TEMP,BUFF2LGZ       LENGTH OF INPUT TEXT LINE\n         LTR   TEMP,TEMP           ANY DATA PRESENT TO CHECK .Q\n         BNP   MAINOC08            BRANCH IF NONE\n         LA    R0,B2LG             MAX OUTPUT LENGTH ALLOWED\n         SPACE\nMAINOC01 DS    0H\n         LA    R1,BUFF2-1(TEMP)    LAST CHAR OF LINE\n         CLI   0(R1),C' '          IS IT A BLANK .Q\n         BE    MAINOC06            YES, NO OVERLAY CHARACTER\n         CLI   0(R1),X'05'         IS IT A TAB .Q\n         BE    MAINOC06            YES, NO OVERLAY CHARACTER\n         CLI   0(R1),X'16'         IS IT A BACKSPACE .Q\n         BE    MAINOC06            YES, NO OVERLAY CHARACTER\n         CLC   0(1,R1),OCCHAR      IS IT OVERLAY CHARACTER .Q\n         BE    MAINOC06            YES, NO OVERLAY CHARACTER\n         SR    COUNT,COUNT         ZERO WORK REG\n         IC    COUNT,OCEXCEP       GET EXCEPTION COUNT\n         CLI   OCEXCEP,X'FF'       IS EXCEPTION COUNT FOR .UL .Q\n         BNE   MAINOC02            BRANCH IF NOT\n         CLI   0(R1),C'A'-X'40'    LESS THAN LOWER 'A' .Q\n         BL    MAINOC06            YES, NO OVERLAY\n         CLI   0(R1),C'9'          MORE THAN '9' .Q\n         BH    MAINOC06            YES, NO OVERLAY\n         B     MAINOC03            ELSE OVERLAY IT\nMAINOC02 DS    0H\n         S     COUNT,F1            DECREMENT COUNT BY ONE\n         BM    MAINOC03            BRANCH OUT IF DONE\n         LA    R15,OCEXCEP+1(COUNT)  EXCEPTION CHAR TO TEST\n         CLC   0(1,R1),0(R15)      AN EXCEPTION CHAR .Q\n         BE    MAINOC06            YES, NO OVERLAY\n         B     MAINOC02            AND TRY AGAIN\nMAINOC03 DS    0H\n         LH    COUNT,BUFF2LGZ      LENGTH OF CURRENT BUFFER\n         LA    COUNT,2(,COUNT)     BUMP BY TWO\n         CR    COUNT,R0            RESULT TOO BIG .Q\n         BH    MAINOC07            BRANCH OUT IF YES\n         STH   COUNT,BUFF2LGZ      UPDATE WITH NEW LENGTH\n         LA    COUNT,BUFF2-3(COUNT)  LAST CHARACTER OF BUFFER\n         SR    COUNT,R1            REMAINDER LENGTH-1\n         L     R15,BUFF3AD         WORK BUFFER ADDRESS\n         EX    COUNT,MAINOCSV      SAVE REMAINDER\n         MVI   1(R1),X'16'         BACKSPACE\n         CLI   OCCHAR,X'00'        CHARACTER ITSELF REQUIRED .Q\n         BE    MAINOC04            BRANCH IF YES\n         MVC   2(1,R1),OCCHAR      OVERLAY CHARACTER\n         B     MAINOC05            GO TO RESTORE REMAINDER\nMAINOC04 DS    0H\n         MVC   2(1,R1),0(R1)       THE CHARACTER ITSELF\nMAINOC05 DS    0H\n         EX    COUNT,MAINOCRE      RESTORE REMAINDER\nMAINOC06 DS    0H\n         BCT   TEMP,MAINOC01       CHECK ALL CHARACTERS\n         B     MAINOC08            GO TO RETURN\nMAINOC07 DS    0H\n         MVI   EFLAG044,ERRWARN    SOMETHING HAS BEEN LOST\nMAINOC08 DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nMAINOCSV MVC   4(*-*,R15),1(R1)    SAVE BUFFER REMAINDER\nMAINOCRE MVC   3(*-*,R1),4(R15)    RESTORE BUFFER REMAINDER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#MC": {"ttr": 8449, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00!\\x00!\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .MC (MULTIPLE COLUMN) --- CONTROL                      *\n*                                                                     *\n***********************************************************************\n         SPACE\nMC      $ENTER ,\n         CLI   ICORFLG,ICORNONE    'NO KEEP' IN PROGRESS .Q\n         BNE   MCE043              ERROR IF NOT\n         L     R1,SCCOUNT          GET SINGLE COLUMN NEST COUNT\n         S     R1,F1               LESS ONE\n         BM    MC02                BRANCH IF NONE\n         ST    R1,SCCOUNT          UPDATE COUNT LEFT\n         BNZ   MC02                BRANCH IF SOME LEFT\n         SPACE\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n         L     COUNT,CLLZSAVE      SAVED COLUMN LENGTH\n         LTR   COUNT,COUNT         WAS IT SPECIFIED .Q\n         BZ    MC01                BRANCH IF NOT\n         ST    COUNT,CLLZ          AND RESET SAME\nMC01     DS    0H\n         CLI   ICOLFLG,ICOLSC      IN SINGLE COLUMN MODE .Q\n         BNE   MC02                BRANCH IF NOT\n         MVI   ICOLFLG,ICOLMC      RESTORE MULTI-COLUMN OUTPUT\n         LA    COUNT,1             FIRST COLUMN\n         ST    COUNT,CDCURR        PROCESS FIRST COLUMN FIRST\n         MVC   CDPLCT,PLCT         SAVE LINES REMAINING FOR COLUMN\nMC02     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nMCE043   DS    0H\n         MVI   EFLAG043,ERRSET     INVALID CONTROL WORD WITHIN KEEP\n         B     MC02                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#MERGE": {"ttr": 8451, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x01\\xc5\\x01\\xc5\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 453, "newlines": 453, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*                             MERGE                                   *\n*                                                                     *\n*              MERGE NEW INPUT LINE WITH RESIDUAL LINE AND PROCESS    *\n*              TAB STOPS. A COUNT OF INTER-WORD SPACES IS MAINTAINED. *\n*              IF THE COMBINED LINE EXTENDS BEYOND THE RIGHT MARGIN,  *\n*              THE LINE IS DIVIDED INTO TWO PIECES AT THE PRECEEDING  *\n*              INTER-WORD SPACE.                                      *\n*                                                                     *\n*        REGISTER USAGE:                                              *\n*                                                                     *\n*        P     POINTER TO CURRENT LINK BLOCK                          *\n*        POLD  TEMPORARY POINTER TO END OF RESIDUE STRING             *\n*        PNEW  TEMPORARY POINTER TO START OF NEW STRING               *\n*        B     LINK BLOCK COUNTER                                     *\n*        R0    TEMPORARY BLOCK COUNT CALCULATIONS                     *\n*        W     INTER-WORD SPACE COUNTER                               *\n*        L     BOOLEAN NON-BLANK FOUND INDICATOR (L=0|1) (NOW WRKL)   *\n*        C     CHARACTER (COLUMN) COUNTER                             *\n*        M     MULTIPLIER                                             *\n*        TABS  TAB TABLE POINTER                                      *\n*                                                                     *\n***********************************************************************\n         SPACE\nMERGE   $ENTER ,\n         SPACE\n         USING FOPMLIST,R1\n         USING LINKELEM,P\n         CLC   NEWCOUNT,F0         ANYTHING IN NEW STRING .Q\n         BE    MERET               NO, NOTHING TO MERGE\n         XC    WRKL,WRKL           CLEAR BLANK FOUND SWITCH\n         SR    M,M                 CLEAR HIGH ORDER BYTE FOR MULTIPLIER\n         SR    B,B                 SET BLOCK COUNTER = 0\n         L     P,NEWFIRST          SET POINTER TO FIRST LINK BLOCK\n         L     W,FOIWSPC           GET INTER-WORD SPACES COUNT\n         L     R0,FOPCOUNT         LENGTH OF OLD CHAR STRING\n         CH    R0,FOFUNCNT         OFFSET/UNDENT MARGIN .Q\n         BNH   MERG01              BRANCH IF YES\n         LA    W,1(,W)             INDICATE EXTRA BLANK ADDED TO MERGE\nMERG01   DS    0H\n         L     C,FONOCHAR          GET CHARACTER COUNT\n         LTR   R0,R0               IS OLD STRING EMPTY .Q\n         BP    MERG03              BRANCH IF NOT\n         CLI   LINKCHAR,X'40'      CHARACTER BLANK .Q\n         BE    MERG02              BRANCH IF YES\n         LA    R0,WRKOSTR          POINT AT STRING TO INSERT\n        $CALL  FOADD               ADD THE EXTRA BLANK\n         L     R0,NEWCOUNT         NUMBER OF LINK BLOCKS\n         A     R0,WRKPLIST+4       PLUS NUMBER ADDED\n         ST    R0,NEWCOUNT         NEW NUMBER OF LINK BLOCKS\n         MVC   WRKNX,NEWFIRST      SAVE LOCATION OF FIRST LINK\n         BAL   RETURN,LINK\n         L     P,WRKFLN            NEW FIRST LINK\n         MVC   NEWFIRST,WRKFLN     SET NEW FIRST LINK\nMERG02   DS    0H\n         SR    W,W                 SET INTER WORD SPACE TO ZERO\n         BCTR  W,0                 AND THEN TO MINUS ONE\n         LR    C,W                 -1 TO ADJUST FOR LEADING BLANK\n         IC    M,LINKMULT          GET MULTIPLIER FROM LEADING BLANK\n         AH    M,FOIND             ADD INDENTATION FACTOR\n         STC   M,LINKMULT          ..\n         MVC   FOPFIRST,NEWFIRST   INITIALIZE START OF RESULTANT STRING\n         B     FCH                 BRANCH FORWARD\n         SPACE\nMERG03   DS    0H\n         L     POLD,FOPFIRST       LOCATION OF LAST LINK\n         USING LOLDELEM,POLD       AND TELL THE ASSEMBLER\n         CLI   LOLDCHAR,C' '       LAST CHARACTER A BLANK .Q\n         BE    MERG04              BRANCH IF YES\n         DROP  POLD\n         LA    R0,WRKOSTR          POINT AT STRING TO INSERT\n        $CALL  FOADD               ADD THE EXTRA BLANK\n         L     R0,FOPCOUNT         NUMBER OF OLD LINK BLOCKS\n         A     R0,WRKPLIST+4       PLUS NUMBER ADDED\n         ST    R0,FOPCOUNT         NEW NUMBER OF OLD BLOCKS\n         MVC   WRKNX,FOPFIRST      SAVE LOCATION OF FIRST OLD BLOCK\n         L     P,FOPFIRST          POINT TO THE OLD\n         BAL   RETURN,LINK\n         L     P,NEWFIRST          NEW FIRST LINK\n         MVC   FOPFIRST,WRKFLN     SET NEW OLD FIRST LINK\nMERG04   DS    0H\n         L     PNEW,NEWFIRST       GET MERGE POINTS\n         L     POLD,FOPLAST        ..\n         USING LOLDELEM,POLD       USE THE OLD POINTER\n         OC    LOLDBACK,LOLDBACK   ANY FORMER CHARACTER .Q\n         BZ    DBLBNO              NOT FULL STOP IF NOT\n         BAL   RETURN,DBLFSTOP     FULL STOP CHARACTER .Q\n         BE    DBLBLK              BRANCH IF YES\n         CLI   LOLDCHAR,C')'       END WITH RIGHT PAREN .Q\n         BE    MERG05              YES, MAYBE STILL FULL STOP\n         CLI   LOLDCHAR,C'\"'       END WITH DOUBLE QUOTE .Q\n         BE    MERG05              YES, MAYBE STILL FULL STOP\n         B     DBLBNO              NOT FULL STOP\nMERG05   DS    0H\n         L     POLD,LOLDBACK       BACKWARDS POINTER\n         BAL   RETURN,DBLFSTOP     FULL STOP CHARACTER BEFORE .Q\n         L     POLD,FOPLAST        RESTORE FORMER END OF CHAIN\n         BE    DBLBLK              THIS IS ALSO A FULL STOP\n         B     DBLBNO              NOT FULL STOP\n         SPACE\nDBLFSTOP DS    0H\n         CLI   LOLDCHAR,C'.'       ENDS WITH A PERIOD .Q\n         BE    DBLFSUC             BRANCH IF YES\n         CLI   LOLDCHAR,C'?'       ENDS WITH QUESTION .Q\n         BE    DBLFSUC             BRANCH IF YES\n         CLI   LOLDCHAR,C'!'       ENDS WITH EXCLAMATION .Q\n         BE    DBLFSUC             BRANCH IF YES\n         CLI   LOLDCHAR,C':'       ENDS WITH A COLON .Q\n         BE    DBLFSUC             BRANCH IF YES\n        $CC    NEG                 SET NOT EQUAL RETURN CODE\nDBLFSUC  DS    0H\n         BR    RETURN              RETURN TO CALLER\n         SPACE\nDBLBLK   DS    0H\n         LA    R0,WRKOSTR          POINT AT BLANK STRING TO INSERT\n        $CALL  FOADD               ADD THE EXTRA BLANK\n         L     POLD,FOPLAST        FORMER END OF CHAIN\n         MVC   LOLDFOR,WRKFLN      ADDRESS FORWARD TO BLANK\n         L     POLD,WRKFLN         NEW END OF CHAIN\n         MVC   LOLDBACK,FOPLAST    ALTER BACKWARD CHAIN\n         ST    POLD,FOPLAST        AND REMEMBER THE NEW END\n         LR    P,POLD              CURRENT BECOMES THE NEW ENTRY\n         L     R0,NEWCOUNT         CURRENT NUMBER OF LINK BLOCKS\n         A     R0,F1               BUMP BY ONE\n         ST    R0,NEWCOUNT         UPDATE NUMBER BY ONE\n         USING LNEWELEM,PNEW\nDBLBNO   DS    0H\n         MVC   LNEWBACK,FOPLAST    LINK BACKWARDS\n         DROP  PNEW\n         MVC   LOLDFOR,NEWFIRST    LINK FORWARD\n         CLI   LOLDCHAR,HYUCHAR    USER HYPHEN CHARACTER .Q\n         BNE   UNLINK05            NO, DON'T UNLINK IT\n         SPACE\n         BCTR  C,0                 DECREMENT CHARACTER COUNT\n         OC    WRKBRK,WRKBRK       FIRST TIME IN LINE .Q\n         BNZ   UNLINK00            BRANCH IF NOT\n         LTR   W,W                 FIRST WORD IN LINE .Q\n         BM    UNLINK01            BRANCH IF NOT\nUNLINK00 DS    0H\n         BCTR  W,0                 DECREMENT INTER-WORD SPACE\nUNLINK01 DS    0H\n         MVC   WRKBRK,LOLDBACK     SET USER BREAK CHARACTER\n         CLI   LINKCHAR,C' '       USER HYPHEN FOLLOWED BY BLANK .Q\n         BNE   UNLINK02            BRANCH IF NOT\n         L     P,LINKFOR           POINT TO NEXT CHAR\n         L     R0,NEWCOUNT         NEW CHARACTER COUNT\n         BCTR  R0,0                LESS ONE\n         ST    R0,NEWCOUNT         SET NEW CHARACTER COUNT\nUNLINK02 DS    0H\n         L     R0,FOPCOUNT         OLD CHARACTER COUNT\n         BCTR  R0,0                LESS ONE\n         ST    R0,FOPCOUNT         SET OLD CHARACTER COUNT\n         L     POLD,LOLDBACK       BREAK CHARACTER POINTER\n         L     R15,LOLDFOR         FIRST LINK TO FREE CHAIN\n         ST    P,LOLDFOR           SET NEW FORWARD POINTER\n         ST    POLD,LINKBACK       SET BACKWARD POINTER\n         SPACE\nUNLINK03 DS    0H\n         LA    PNEW,0(,R15)        POINT TO CHARACTER\n         USING LNEWELEM,PNEW       TELL THE ASSEMBLER\n         CR    PNEW,P              AT THE END .Q\n         BE    UNLINK05            BRANCH OUT IF YES\n         SPACE\n         L     POLD,LKSTAR         START OF FREE LIST\n         MVC   LNEWBACK,LOLDBACK   POINT BACK TO START\n         ST    PNEW,LOLDBACK       BACK POINT TO NEW ENTRY\n         L     R15,LNEWFOR         REMEMBER FORWARD CHAIN PTR\n         MVC   LNEWFOR,LKSTAR      NEW TO OLD FIRST\n         ST    PNEW,LKSTAR         NEW START OF FREE LIST\n         L     R0,LKSIZE           NUMBER OF FREE CHARACTER BLOCKS\n         A     R0,F1               PLUS ONE\n         ST    R0,LKSIZE           NEW NUMBER OF FREE BLOCKS\nUNLINK04 DS    0H\n         L     PNEW,LNEWDOWN       DOWNWARD POINTER\n         LTR   PNEW,PNEW           ANY DOWN CHARS .Q\n         BZ    UNLINK03            BRANCH BACK IF NOT\n         SPACE\n         L     POLD,LKSTAR         START OF FREE LIST\n         MVC   LNEWBACK,LOLDBACK   POINT BACK TO START\n         ST    PNEW,LOLDBACK       BACK POINTER TO NEW ENTRY\n         MVC   LNEWFOR,LKSTAR      NEW TO OLD FIRST\n         ST    PNEW,LKSTAR         NEW START OF FREE LIST\n         L     R0,LKSIZE           NUMBER OF FREE CHARACTER BLOCKS\n         A     R0,F1               PLUS ONE\n         ST    R0,LKSIZE           NEW NUMBER OF FREE BLOCKS\n         B     UNLINK04            DO ALL DOWN CHARACTERS\n         DROP  PNEW\n         DROP  POLD\n         SPACE\nUNLINK05 DS    0H\n         B     FCH                 BRANCH FORWARD\n         SPACE\nBCH      DS    0H\n         LTR   R0,C                FIRST TIME IN .Q\n         BNP   BCH02               BRANCH IF YES\n         BCTR  R0,0                COLUMN NUMBER LESS ONE\n         SH    R0,FOFUNCNT         OFFSET/UNDENT PREVENT SPACE HERE\n         SH    R0,FOIND            LESS INDENT FACTOR\n         BP    BCH01               BRANCH IF PLUS\n         MVI   WRKL+3,X'00'        KILL WORD COUNT VALUE\n         B     BCH02               AND CONTINUE\nBCH01    DS    0H\n         XC    FOFUNCNT,FOFUNCNT   REMOVE OFFSET/UNDENT MARGIN\nBCH02    DS    0H\n         A     W,WRKL              INCREMENT WORD # BY L (L=0|1)\n         MVI   WRKL+3,X'00'        RESET BLANK FOUND SWITCH\nNCH      DS    0H\n         OC    LINKFOR,LINKFOR     IS THIS LAST POINTER .Q\n         BZ    SETLAST             YES\n         L     P,LINKFOR           NO, ADVANCE POINTER\nFCH      DS    0H\n         CLI   LINKCHAR,X'05'      IS CHARACTER A TAB .Q\n         BNE   NOTTAB              NO, NO TABS TO EXPAND\n        $CALL  TABIT               EXPAND USER'S TABS\n         BC    BNEG,NOTTAB         BRANCH IF TAB NOT FOUND\n         SR    W,W                 CLEAR INTER WORD COUNT\n         ST    W,WRKL              RESET IWSPC SWITCH\n         BCTR  W,0                 SET TO MINUS ONE\n         SPACE\nNOTTAB   DS    0H\n         LA    B,1(,B)             INCREMENT LINK BLOCK COUNTER\n         IC    M,LINKMULT          GET MULTIPLIER\n         AR    C,M                 UPDATE COLUMN NUMBER\n         CLI   LINKCHAR,C' '       IS CHARACTER A BLANK .Q\n         BE    BCH                 YES\n         LA    R0,HYUSER           USER HYPHEN CODE\n         C     R0,HYLEVEL          IS IT IN EFFECT .Q\n         BNE   NODWN1              BRANCH IF NOT\n         L     POLD,LINKDOWN       GET DOWNWARD POINTER\n         USING LOLDELEM,POLD\n         LTR   POLD,POLD           ANY OVERSTRIKE CHARS .Q\n         BZ    NODWN               BRANCH IF NOT\n         IC    R0,LOLDCHAR         SAVE CHARACTER\n         CLI   LOLDCHAR,HYACHAR    AN ACTUAL HYPHEN .Q\n         BE    FLIP                BRANCH IF YES\n         CLI   LOLDCHAR,HYUCHAR    A USER HYPHEN .Q\n         BNE   NODWN               BRANCH IF NOT\nFLIP     DS    0H\n         MVC   LOLDCHAR,LINKCHAR   SET NEW DOWN CHARACTER\n         STC   R0,LINKCHAR         ENTER HYPHEN\n         DROP  POLD\nNODWN    DS    0H\n         CLI   LINKCHAR,HYACHAR    IS CHARACTER A HYPHEN .Q\n         BNE   NODWN1              BRANCH IF NOT\n         L     PNEW,LINKFOR        FORWARD CHARACTER POINTER\n         USING LNEWELEM,PNEW       AND TELL THE ASSEMBLER\n         LTR   PNEW,PNEW           ANYTHING FORWARD .Q\n         BZ    NODWN1              BRANCH IF NOT\n         CLI   LNEWCHAR,C'A'-C' '  FORWARD LESS THAN LOWER 'A' .Q\n         BL    NODWN1              YES, IGNORE THIS USER BREAK\n         CLI   LNEWCHAR,C'Z'       GREATER THAN UPPER 'Z' .Q\n         BH    NODWN1              YES, IGNORE THIS BREAK\n         L     PNEW,LINKBACK       BACKWARD POINTER\n         CLI   LNEWCHAR,C'A'-C' '  FORMER LESS THAN LOWER 'A' .Q\n         BL    NODWN1              YES, IGNORE THIS BREAK\n         CLI   LNEWCHAR,C'Z'       GREATER THAN UPPER 'Z' .Q\n         BH    NODWN1              YES, IGNORE THIS BREAK\n        $ON    WRKSW,WRKUHY        HYPHEN TWIXT TWO ALPHAS IS OK\n         DROP  PNEW\n         SPACE\nNODWN1   DS    0H\n         MVI   WRKL+3,X'01'        INDICATE A NON-BLANK FOUND\n        $IFON  FOSWTCH,NFSWS,NCH   BRANCH IF IN NO FORMAT MODE\n         SPACE\n         L     R0,FOLL             GET CURRENT LINE LENGTH\n         AH    R0,FOINDR           PLUS RIGHT INDENT VALUE\n         CR    C,R0                EXCEEDED RIGHT MARGIN BOUNDARY .Q\n         BNH   NCH                 NO\n         LTR   W,W                 WERE ANY BLANKS FOUND .Q\n         BNM   BACKUP              IF YES, GO BACKUP ONE WORD\n         SPACE\n        $IFON  WRKSW,WRKUHY,BACKUP IF USER HYPHENS, BACKUP TOO\n         SPACE\n*                                                                     *\n*        (WHEN ONE- OR TWO-WORD LINE OVERFLOWS, SECOND                *\n*        OVERFLOW CHARACTER APPEARS AS PADDING ON NEXT LINE.          *\n*        THIS CODE CAUSES A \"-\" AND A \" \" TO BE INSERTED IN           *\n*        THE LINE)                                                    *\n*                                                                     *\n         SPACE\n         IC    M,LINKMULT          LENGTH OF SECOND LAST CHAR TO CHOP\n         SR    C,M                 BACKUP NEW LENGTH\n         L     P,LINKBACK          BACKUP ONE CHARACTER\n         IC    M,LINKMULT          LENGTH OF LAST CHAR TO CHOP\n         SR    C,M                 BACKUP NEW LENGTH\n         BNP   BREAKERR            BRANCH IF NOTHING LEFT\n         L     P,LINKBACK          POINT TO NEW LAST CHAR\n         BCTR  B,0                 (LOSE ONLY ONE LINK NET)\n         L     R0,NEWCOUNT         CURRENT LENGTH LEFT FOR NEXT LINE\n         A     R0,F2               BUMP BY TWO\n         ST    R0,NEWCOUNT         SET LENGTH FOR NEXT LINE\n         B     BREAK01             AND ENTER THE '- ' SEQUENCE\n         SPACE\nBREAKERR DS    0H\n         MVI   EFLAG010,ERRTERM    ERROR THAT CANNOT CONTINUE\n        $CALL  ERROUT              DISPLAY THE RESULT\n         SPACE\nBREAK    DS    0H\n         LA    C,1(,C)             ADD HYPHEN CHARACTER TO COUNT\n         L     R0,FOPCOUNT         CHARACTERS ON THIS LINE\n         A     R0,F1               PLUS ONE FOR HYPHEN\n         ST    R0,FOPCOUNT         NEW NUMBER OF CHARACTERS\n         L     R0,NEWCOUNT         CHARACTERS ON NEXT LINE\n         A     R0,F1               PLUS ONE FOR BLANK\n         ST    R0,NEWCOUNT         NEW NUMBER OF CHARACTERS ON NEXT\n         SPACE\nBREAK01  DS    0H\n        $IFOFF SWITCHS,THSWS,BREAK02 BR IF TAB HYPHEN SW OFF\n         LA    R0,WRKBLK           POINT AT STRING TO INSERT\n         B     BREAK03             CONTINUE\nBREAK02  DS    0H\n         LA    R0,WRKSTR           POINT AT STRING TO INSERT\nBREAK03  DS    0H\n        $CALL  FOADD               ADD THE EXTRA BLANK/HYPHEN\n         L     POLD,WRKFLN         ADDRESS OF \"-\" LINK\n         L     R15,WRKLLN          ADDRESS OF \" \" LINK\n         SPACE 1\n         MVC   LINKFOR-LINKELEM(4,R15),LINKFOR    \" \" -> B\n         ST    POLD,LINKFOR        A -> \"-\"\n         SPACE\n         USING LOLDELEM,POLD       LOOK AT \"-\" LINK\n         ST    P,LOLDBACK          A.<- \"-\"\n         LR    P,POLD              \"-\" NOW END OF LINE\n         SPACE\n         L     POLD,LINKFOR-LINKELEM(R15)    ADDR OF B LINK\n         ST    R15,LOLDBACK        \" \" <- B\n         DROP  POLD                BACK TO EXPECTED USAGE\n         SPACE 1\n        $ON    WRKSW,WRKBLNK       NO BLANKS FOUND\n         A     W,WRKL              BUMP INTERWORD SPACE COUNT\n         MVI   WRKL+3,X'00'        AND CLEAR COUNT\n         B     SETBACK             GO TO DONE\n         SPACE\n         USING LNEWELEM,PNEW\nLINK     DS    0H\n         L     PNEW,WRKLLN         NEW LAST LINK\n         MVC   LNEWFOR,WRKNX       SET NEW FORWARD TO NEXT\n         MVC   LINKBACK,WRKLLN     CURRENT LAST BACK PTR\n         BR    RETURN              AND RETURN TO CALLER\n         SPACE\n         DROP  PNEW\n         SPACE 2\nBACKUP   DS    0H\n         L     R15,HYLEVEL         USER'S HYPHENATION LEVEL\nBACKUP01 DS    0H\n         SLL   R15,2               LEVEL TIMES FOUR FOR BRANCH\n         B     *(R15)              AND HANDLE INDIVIDUALLY\n         B     BACKUPNO                 HYNONE - NO HYPHENATION\n         B     BACKUPUS                 HYUSER - USER HYPHENATION\n         B     BACKUPAU                 HYAUTO - AUTO HYPHENATION\n         SPACE\nBACKUPNO DS    0H\n         BCTR  B,0                 BACKTRACK\n         IC    M,LINKMULT          ..\n         SR    C,M                 ..\n         CLI   LINKCHAR,C' '       IS CURRENT CHARACTER A BLANK .Q\n         L     P,LINKBACK          (BACKUP TO PREVIOUS CHARACTER)\n         BE    SETBACK             IF YES, DONE\n         B     BACKUPNO            ELSE KEEP BACKING UP\n         SPACE\nBACKUPUS DS    0H\n         BCTR  B,0                 BACKTRACK\n         IC    M,LINKMULT          ..\n         SR    C,M                 ..\n         CLI   LINKCHAR,C' '       IS CURRENT CHARACTER A BLANK .Q\n         L     P,LINKBACK          (BACKUP TO PREVIOUS CHARACTER)\n         BE    SETBACK             IF YES, DONE\n         CLI   LINKCHAR,HYACHAR    A HYPHEN CHARACTER .Q\n         BNE   BKUS01              BRANCH IF NOT\n         L     PNEW,LINKFOR        FORWARD POINTER\n         USING LNEWELEM,PNEW       TELL THE ASSEMBLER\n         LTR   PNEW,PNEW           ANYTHING FORWARD .Q\n         BZ    BKUS01              BRANCH IF NOT\n         CLI   LNEWCHAR,C'A'-C' '  FORWARD LESS THAN LOWER 'A' .Q\n         BL    BKUS01              YES, IGNORE THIS BREAK\n         CLI   LNEWCHAR,C'Z'       GREATER THAN UPPER 'Z' .Q\n         BH    BKUS01              YES, IGNORE THIS BREAK\n         L     PNEW,LINKBACK       BACKWARD POINTER\n         CLI   LNEWCHAR,C'A'-C' '  FORMER LESS THAN LOWER 'A' .Q\n         BL    BKUS01              YES, IGNORE THIS BREAK\n         CLI   LNEWCHAR,C'Z'       GREATER THAN UPPER 'Z' .Q\n         BH    BKUS01              YES, IGNORE THIS BREAK\n         B     SETBACK             HYPHEN TWIXT TWO ALPHAS IS OK\n         DROP  PNEW\nBKUS01   DS    0H\n         CL    P,WRKBRK            IS THIS THE BREAK .Q\n         BE    BREAK               BRANCH IF YES\n         B     BACKUPUS            ELSE KEEP BACKING UP\n         SPACE\nBACKUPAU DS    0H\n        $CALL  FOHYPH              ATTEMPT HYPHENATION\n         B     BACKUP01            AND DO IT AGAIN, DIFFERENTLY\n         SPACE\nSETLAST  DS    0H\n         CLI   LINKCHAR,HYUCHAR    USER HYPHENATION CHARACTER .Q\n         BE    SET                 BRANCH IF YES\n         OC    WRKBRK,WRKBRK       ANY USER BREAK POINT DEFINED .Q\n         BZ    SET                 BRANCH IF NOT\n         LTR   W,W                 FIRST WORD .Q\n         BNP   SET                 BRANCH IF YES\n         BCTR  W,0                 DECREMENT INTERWORD COUNT\n         SPACE\nSETBACK  DS    0H\n         XC    WRKBRK,WRKBRK       CLEAR BREAK POINTER\nSET      DS    0H\n        $OFF   WRKSW,WRKUHY        CLEAR USER HYPHEN SWITCH\n         MVC   NEWFIRST,LINKFOR    SET START OF RESIDUE STRING\n         ST    P,FOPLAST           SET END OF STRING\n         L     P,LINKFOR           RESIDUE STRING\n         LTR   P,P                 ANY RESIDUE STRING .Q\n         BZ    SET02               BRANCH IF NONE\n         CLI   LINKCHAR,C' '       IS END CHARACTER A BLANK .Q\n         BNE   SET02               BRANCH IF NOT\nSET01    DS    0H\n         L     P,LINKDOWN          OVERSTRIKE CHARACTERS\n         LTR   P,P                 ANY OVERSTRIKE CHARACTER .Q\n         BZ    SET02               BRANCH IF NONE\n         MVI   LINKCHAR,C' '       MAKE SURE OVERSTRIKE DOES NOT PRINT\n         B     SET01               AND TRY AGAIN\nSET02    DS    0H\n         L     P,FOPLAST           RESTORE END OF STRING POINTER\n         XC    LINKFOR,LINKFOR     DETACH RESIDUE FROM STRING\n        $IFON  WRKSW,WRKBLNK,SETOK BRANCH IF NO BLANKS\n         LTR   W,W                 WERE THERE ANY BLANKS .Q\n         BNP   SETOK               NO\nSETADJ   DS    0H\n         CLI   LINKCHAR,C' '       ELIMINATE TRAILING BLANK FROM C\n         BNE   SETOK               NO MORE BLANKS\n         IC    M,LINKMULT          DELETE FROM FORMAT COUNT, C\n         SR    C,M                 ..\n         L     P,LINKBACK          CHECK PREVIOUS CHARACTER\n         B     SETADJ              ..\nSETOK    DS    0H\n        $OFF   WRKSW,WRKBLNK       RESET BLANKS SWITCH\n         ST    C,FONOCHAR          SET NUMBER OF CHARS IN FORMAT LINE\n         ST    W,FOIWSPC           SET INTER-WORD SPACES COUNT\n         L     R0,FOPCOUNT         GET OLD COUNT\n         AR    R0,B                BUMP\n         ST    R0,FOPCOUNT         UPDATE OLD COUNT\n         L     R0,NEWCOUNT         GET NEW COUNT\n         SR    R0,B                DECREMENT\n         ST    R0,NEWCOUNT         UPDATE NEW COUNT\n         B     MERET               RETURN TO CALLER\n         SPACE\nMERET    DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\n         DROP  P,R1\n         SPACE\nWRKOSTR  DC    H'1',C' '           NEW BLANK FOR INSERT\nWRKSTR   DC    H'2',C'- '          NEW CHARACTERS FOR INSERT\nWRKBLK   DC    H'2',C'  '\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#MS": {"ttr": 8459, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x1e\\x00\\x1e\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .MS (MACRO SUBSTITUTE) --- CONTROL                     *\n*                                                                     *\n***********************************************************************\n         SPACE\nMS      $ENTER ,\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BOMIT,MSE003        ERROR IF NO OPERAND\n         BC    BPOS,MS01           BRANCH IF POSITIVE\n         BC    BNEG,MS02           BRANCH IF NEGATIVE\n         B     MSE005              ELSE INVALID\n         SPACE\nMS01     DS    0H\n        $ON    SWITCHS,MSSWS       ENABLE MACRO SUBSTITUTE\n         B     MS03                AND GO TO RETURN\n         SPACE\nMS02     DS    0H\n        $OFF   SWITCHS,MSSWS       DISABLE MACRO SUBSTITUTE\n         B     MS03                AND GO TO RETURN\n         SPACE\nMS03     DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\nMSE003   DS    0H\n         MVI   EFLAG003,ERRSET     OMITTED OPERAND\n         B     MS03                GO TO RETURN\nMSE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     MS03                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#NC": {"ttr": 8461, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x11\\x00\\x11\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .NC (NO CONCATENATE) --- CONTROL                       *\n*                                                                     *\n***********************************************************************\n         SPACE\nNC      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BNEG,NC01           BRANCH IF NEGATIVE\n        $ON    SWITCHS,NFSWS       NO CONCATENATE\n         B     NC02                AND GO TO TERMINATE\n         SPACE\nNC01     DS    0H\n        $OFF   SWITCHS,NFSWS       CONCATENATE ON\nNC02     DS    0H\n        $EXIT  RC=0                AND CONTINUE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#NF": {"ttr": 8463, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .NF (NO FORMAT) --- CONTROL                            *\n*                                                                     *\n***********************************************************************\n         SPACE\nNF      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BPOS+BOMIT,NF01     BRANCH IF AFFIRMATIVE OR OMITTED\n         BC    BNEG,NF02           BRANCH IF NEGATIVE\n         MVI   EFLAG005,ERRSET     ELSE AN ERROR\n         B     NF04                GO TO RETURN\n         SPACE\nNF01     DS    0H\n        $ON    SWITCHS,NFSWS       TURN ON 'NO CONCATENATE'\n         MVI   JUVAL,JUVNEG        AND 'NO JUSTIFY'\n         B     NF03                AND TAKE COMMON EXIT\n         SPACE\nNF02     DS    0H\n        $OFF   SWITCHS,NFSWS       TURN OFF 'NO CONCATENATE'\n         MVI   JUVAL,JUVPOS        AND JUSTIFY LEFT AND RIGHT\nNF03     DS    0H\n         XC    CECNT,CECNT         CLEAR CE/LA/RA COUNT\nNF04     DS    0H\n        $EXIT  RC=0                AND CONTINUE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#NJ": {"ttr": 8705, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x16\\x00\\x16\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .NJ (NO JUSTIFY) --- CONTROL                           *\n*                                                                     *\n***********************************************************************\n         SPACE\nNJ      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BOMIT+BPOS,NJ01     BRANCH IF AFFIRMATIVE OR OMITTED\n         BC    BNEG,NJ02           BRANCH IF NEGATIVE\n         MVI   EFLAG005,ERRSET     ELSE AN ERROR\n         B     NJ03                GO TO RETURN\n         SPACE\nNJ01     DS    0H\n         MVI   JUVAL,JUVNEG        NO JUSTIFICATION\n         B     NJ03                AND GO TO TERMINATE\n         SPACE\nNJ02     DS    0H\n         MVI   JUVAL,JUVPOS        LEFT AND RIGHT JUSTIFICATION\nNJ03     DS    0H\n        $EXIT  RC=0                AND CONTINUE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#NL": {"ttr": 8707, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x16\\x00\\x16\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .   (NULL) --- CONTROL                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nNL      $ENTER ,\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION\n        $CALL  GETARG              SKIP ANY AND ALL BLANKS\n         BC    BOMIT,NL01          BRANCH IF NOTHING LEFT\n         BCTR  COUNT,0             BACKUP START POINTER\n         ST    COUNT,ARGSTART      START FROM THERE\n        $CALL  USARG               ISOLATE OPERAND 'LINE'\n         B     NL02                AND GO TO RETURN\n         SPACE\nNL01     DS    0H\n         LA    R1,1                CHANGE TO LENGTH ONE\n         STH   R1,BUFF2LGZ         SET LENGTH TO ONE\n         MVC   BUFF2,BLANKS        SET DATA TO BLANKS\n         SPACE\nNL02     DS    0H\n        $EXIT  RC=WRETNR           RETURN TO CALLER WITH A NEW 'LINE'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#OC": {"ttr": 8709, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00A\\x00A\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 65, "newlines": 65, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .OC (OVERLAY CHARACTER) --- CONTROL                    *\n*                                                                     *\n***********************************************************************\n         SPACE\nOC      $ENTER ,\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION\n        $CALL  GETARG              GET FIRST ARGUMENT\n         BC    BOMIT,OC07          BRANCH IF NOTHING TO OFF\n         MVI   OCEXCEP,X'00'       CLEAR EXCEPTION COUNT\n         MVC   OCCHAR(1),0(COUNT)  SET OVERLAY CHARACTER\n         XC    OCCNT,OCCNT         AND ZERO TEXT LINES COUNT\n         C     TEMP,F1             ONE IN LENGTH .Q\n         BL    OC04                BRANCH IF YES\n         CLI   1(COUNT),C'/'       REALLY TWO ARGS .Q\n         BE    OC01                BRANCH IF YES\n         MVI   OCCHAR,X'00'        OVERLAY WITH ITSELF\n         B     OC02                RESCAN FOR HOW LONG\nOC01     DS    0H\n         LA    COUNT,2(,COUNT)     BUMP OVER 'CHAR/'\n         C     TEMP,F2             MORE THAN TWO IN LENGTH .Q\n         BL    OC03                ERROR IF NOT\nOC02     DS    0H\n         ST    COUNT,ARGSTART      SET RESCAN ADDRESS\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BNEG,OC07           IF OFF, GO AND CLEAR\n         BC    BPOS,OC04           IF ON, SET COUNT AND FIND EXCEPT\n         ST    COUNT,ARGSTART      RESCAN ARGUMENT FOR NUMERIC\n        $CALL  GETNUM              GET AND TEST ARGUMENT\n         BC    BPOS,OC05           IF VALID, GO AND ENTER\nOC03     DS    0H\n         MVC   OCCHAR(1),OCCHAR+1  RESET DEFAULT FOR THIS LINE\n         B     OCE005              GO TO ERROR EXIT\nOC04     DS    0H\n         LH    COUNT,H32767        MAXIMUM TEXT LINE COUNT\nOC05     DS    0H\n         STH   COUNT,OCCNT         SET TEXT LINE COUNT FOR OVERLAY\n         SPACE\nOC06     DS    0H\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION PLEASE\n        $CALL  GETARG              GET EXCEPTION CHAR\n         BC    BOMIT,OC08          BRANCH IF DONE\n         SR    R1,R1               CLEAR WORK REG\n         IC    R1,OCEXCEP          GET CURRENT EXCEPTION COUNT\n         LA    R1,1(,R1)           BUMP BY ONE\n         LA    R0,L'OCEXCEP-1      MAX ALLOWED\n         CR    R1,R0               COMPARE\n         BH    OCE005              ERROR IF TOO MANY\n         STC   R1,OCEXCEP          UPDATE EXCEPTION COUNT\n         LA    R1,OCEXCEP(R1)      TARGET LOCATION\n         MVC   0(1,R1),0(COUNT)    ENTER EXCEPTION CHAR\n         B     OC06                AND LOOK AGAIN\n         SPACE\nOC07     DS    0H\n         MVI   OCEXCEP,X'00'       ZERO EXCEPTION COUNT\n         MVC   OCCHAR(1),OCCHAR+1  RESET DEFAULT VALUE\n         XC    OCCNT,OCCNT         AND ZERO TEXT LINES COUNT\n         SPACE\nOC08     DS    0H\n        $EXIT  RC=0                AND CONTINUE\n         SPACE\nOCE005   DS    0H\n         MVI   EFLAG005,ERRSET     SET ERROR FOR INVALID\n         B     OC08                AND GO TO TERMINATE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#ODDEVN": {"ttr": 8711, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00 \\x00 \\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        INTERNAL FUNCTION 'ODDEVN' --- ODD OR EVEN PAGE TEST         *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON EXIT --  CC=BPOS  IF EVEN PAGE\n*                    CC=BNEG  IF ODD PAGE\n         SPACE\nODDEVN  $ENTER ,\n         L     R1,PACNTI           INTEGER PART OF PAGE NUMBER\n         L     R0,PACNTD           DECIMAL PART\n         LTR   R0,R0               IS THERE ANY DECIMAL PART .Q\n         BM    ODEV01              BRANCH IF NOT\n         AR    R1,R0               TAKE THE SUM\n         SPACE\nODEV01   DS    0H\n         LR    R0,R1               TRANSFER THE RESULT\n         SRL   R0,1                DIVIDE BY TWO\n         AR    R0,R0               TIMES TWO\n         CR    R1,R0               ORIGINAL EQUAL .Q\n         BE    ODEV02              YES, THEN EVEN\n         SPACE\n        $CC    NEG                 NO, THEN ODD\n         B     ODEV03              GO TO RETURN\n         SPACE\nODEV02   DS    0H\n        $CC    POS                 SET EVEN RETURN CODE\n         SPACE\nODEV03   DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGS\n         BR    RETURN              AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#OF": {"ttr": 8713, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00L\\x00L\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 76, "newlines": 76, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .OFFSET (.OF) --- CONTROL                              *\n*                                                                     *\n***********************************************************************\n         SPACE\nOF      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n         CLC   OFFLI,H0            HAS OFFSET BEEN TRIGGERED .Q\n         BNZ   OFE012              NO, ERROR\n        $CALL  GETNUM              GET AMOUNT OF OFFSET\n         BC    BDNO,OFE005         BRANCH IF INVALID\n         BC    BOMIT,OF02          BRANCH IF OMITTED ARGUMENT\n         CLI   NUMSIGN,C' '        IS SIGN BLANK .Q\n         BE    OF03                BRANCH IF YES TO SET\n         LH    TEMP,OFFL           GET CURRENT OFFSET VALUE\n         AR    TEMP,COUNT          PLUS THE ADJUSTMENT\n         LH    R1,INDL             CURRENT LEFT INDENT\n         SH    R1,OFFL             ADJUSTED BY CURRENT OFFSET\n         LNR   R1,R1               MINUS LEFT INDENT\n         CR    TEMP,R1             COMPARE NEW WITH MAX\n         BL    OFE014              ERROR IF TOO SMALL\n         L     R1,LLZ              LINE LENGTH\n         AH    R1,INDENTR          PLUS RIGHT INDENT\n         CR    TEMP,R1             TOO BIG .Q\n         BH    OFE013              ERROR IF YES\n         STH   TEMP,OFFL           SET NEW OFFSET VALUE\n         STH   COUNT,OFFLI         IS NEGATIVE FOR ADJUSTMENT TO INDL\n         LTR   TEMP,TEMP           TEST FOR NEGATIVE\n         BNM   OF01                BRANCH IF NOT\n         SR    TEMP,TEMP           SET TO ZERO FOR FORMAT\nOF01     DS    0H\n         STH   TEMP,OFUNCNT        SET MARGIN VALUE FOR FORMAT\n         B     OF05                GO TO COMMON RETURN\n         SPACE\nOF02     DS    0H\n         SR    COUNT,COUNT         THIS IS OFFSET ZERO\nOF03     DS    0H\n         LH    R1,INDL             CURRENT LEFT INDENT\n         SH    R1,OFFL             ADJUSTED BY CURRENT OFFSET\n         LNR   R1,R1               MINUS LEFT INDENT\n         CR    COUNT,R1            COMPARE WITH NEW MAX\n         BL    OFE014              ERROR IT TOO SMALL\n         L     R1,LLZ              LINE LENGTH\n         AH    R1,INDENTR          PLUS RIGHT INDENT\n         CR    COUNT,R1            TOO BIG .Q\n         BH    OFE013              ERROR IF YES\n         LH    TEMP,INDL           CLEAR OFFSET\n         SH    TEMP,OFFL           ..\n         STH   TEMP,INDL           ADJUST INDENTATION\n         SH    TEMP,UNDL           ..\n         BM    OFE013              ..\n         STH   TEMP,RMARGIN        ..\n         STH   COUNT,OFFL          SET CURRENT VALUE\n         STH   COUNT,OFFLI         SET NEXT OFFSET VALUE\n         LTR   COUNT,COUNT         TEST OFFSET FOR NEGATIVE\n         BNM   OF04                BRANCH IF NOT\n         SR    COUNT,COUNT         ELSE SET TO ZERO\nOF04     DS    0H\n         STH   COUNT,OFUNCNT       SET MARGIN VALUE FOR FORMAT\n         SPACE\nOF05     DS    0H\n        $EXIT  RC=0                THAT'S ALL\n         SPACE\nOFE005   DS    0H\n         MVI   EFLAG005,ERRSET     OPERAND INVALID\n         B     OF05                AND GO TO TERMINATE\nOFE012   DS    0H\n         MVI   EFLAG012,ERRSET     INVALID OFFSET\n         B     OF05                AND GO TO TERMINATE\nOFE013   DS    0H\n         MVI   EFLAG013,ERRSET     OPERAND TOO LARGE\n         B     OF05                AND GO TO TERMINATE\nOFE014   DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     OF05                AND GO TO TERMINATE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#OJ": {"ttr": 8716, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x11\\x00\\x11\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .OJ (OUT JUSTIFY) --- CONTROL                          *\n*                                                                     *\n***********************************************************************\n         SPACE\nOJ      $ENTER ,\n        $CALL  ODDEVN              ODD OR EVEN PAGE\n         BC    BNEG,OJ01           BRANCH IF ODD\n        $CALL  LA                  EVEN PAGE LIKE LEFT ADJUST\n         B     OJ02                GO TO RETURN\n         SPACE\nOJ01     DS    0H\n        $CALL  RA                  ODD PAGE LIKE RIGHT ADJUST\n         SPACE\nOJ02     DS    0H\n        $EXIT  RC=(R15)            RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#OO": {"ttr": 8718, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00f\\x00f\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 102, "newlines": 102, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .OO (OVERLAY OUTPUT) --- CONTROL                       *\n*                                                                     *\n***********************************************************************\n         SPACE\nOO      $ENTER ,\n         LA    R1,OOANCH-OOQFCHN+OODSECT     POINT TO ANCHOR\n        $CALL  OVPROC              PROCESS THE OPERAND\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE 2\nOVPROC  $ENTER ,\n         SPACE\n*        ON ENTRY --  (R1) -> OVERLAY ANCHOR ELEMENT\n         SPACE\n         LR    X1,R1               REMEMBER ANCHOR ELEMENT\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BOMIT,OVP02         BRANCH IF NULL, ASSUME DEFAULT\n         BC    BPOS,OVP03          AFFIRMATIVE IS FOREVER\n         BC    BNEG,OVP04          NEGATIVE TERMINATES CURRENT\n         CLI   YNRESULT,YNDEL      IS THIS 'DELETE' .Q\n         BNE   OVP01               BRANCH IF NOT\n         LR    R1,X1               INPUT ANCHOR ELEMENT\n        $CALL  OVCLR               DELETE ALL ENTRIES\n         B     OVP10               AND GO TO RETURN\n         SPACE\nOVP01    DS    0H\n         ST    COUNT,ARGSTART      RESET START OF SCAN\n        $CALL  GETNUM              ARGUMENT BETTER BE NUMERIC\n         BC    BDNO,OVE005         ERROR IF INVALID\n         BC    BNEG,OVE014         ERROR IF NEGATIVE\n         B     OVP05               ENTER COUNT FOR OVERLAY\n         SPACE\nOVP02    DS    0H\n         LA    COUNT,1             ONE LINE BY DEFAULT\n         B     OVP05               GO ENTER VALUE\nOVP03    DS    0H\n         LH    COUNT,H32767        LARGE POSITIVE VALUE\n         B     OVP05               GO ENTER VALUE\nOVP04    DS    0H\n         LR    R1,X1               OVERLAY ANCHOR ELEMENT\n        $CALL  OVREMOV             REMOVE FIRST BUFFER FROM LIST\n         BC    BNEG,OVE012         ERROR IF NONE OUTSTANDING\n         B     OVP10               GO TO RETURN\n         SPACE\nOVP05    DS    0H\n         LR    X2,COUNT            REMEMBER OVERLAY COUNT\n         L     COUNT,ARGSTART      BLANK DELIMITER ADDRESS\n         LA    COUNT,1(,COUNT)     POTENTIAL STRING START ADDR\n         C     COUNT,ARGSTOP       ANY STRING PRESENT .Q\n         BH    OVP06               NO, READ NEXT RECORD\n         LR    X3,COUNT            REMEMBER DATA ADDRESS\n         S     COUNT,ARGSTOP       MINUS LENGTH-1 OR ARGUMENT\n         LPR   COUNT,COUNT         LENGTH-1 OF ARGUMENT\n         LA    COUNT,1(,COUNT)     GET ACTUAL LENGTH OF DATA\n         B     OVP07               BRANCH TO ENTER\nOVP06    DS    0H\n        $CALL  READ                GET NEXT INPUT LINE\n         LH    COUNT,0(,R1)        LINE LENGTH\n         LA    X3,4(,R1)           POINT TO LINE DATA\n         SPACE\nOVP07    DS    0H\n         LA    R1,OOQLEN(,COUNT)   AREA REQUIRED TO SAVE\n        $CALL  GETCELL             GET THE AREA\n         BC    BNEG,OVE024         ERROR IF FAILED\n         USING OODSECT,TEMP        TELL THE ASSEMBLER\n         XC    OODSECT(OOQLEN),OODSECT  CLEAR PREFIX AREA\n         ST    X2,OOQCNT           SAVE OVERLAY COUNT\n         STH   COUNT,OOQRDW        SAVE LENGTH OF DATA\n         S     COUNT,F1            LENGTH-1 FOR MVC\n         BM    OVP08               BRANCH IF EMPTY\n         EX    COUNT,OVPMVC        MOVE THE DATA\n         B     OVP08               AND CONTINUE\nOVPMVC   MVC   OOQDATA(*-*),0(X3)  EXECUTED MOVE DATA\nOVP08    DS    0H\n         DROP  TEMP\n         USING OODSECT,X1          SEARCH THE OLD\n         LR    R1,X1               INITIALIZE POINTER\nOVP09    DS    0H\n         LR    X1,R1               FORMER POINTER\n         L     R1,OOQFCHN          NEXT ON LIST\n         LTR   R1,R1               AT THE END .Q\n         BNZ   OVP09               NO, KEEP LOOKING\n         ST    TEMP,OOQFCHN        CHAIN TO THE END\n         DROP  X1\n         B     OVP10               BRANCH TO RETURN\n         SPACE\nOVE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     OVP10               AND GO TO RETURN\nOVE012   DS    0H\n         MVI   EFLAG012,ERRSET     ILLEGAL CONTROL WORD\n         B     OVP10               AND GO TO RETURN\nOVE014   DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     OVP10               AND GO TO RETURN\nOVE024   DS    0H\n         MVI   EFLAG024,ERRSET     NO CORE TO SAVE DATA\n         B     OVP10               AND GO TO RETURN\n         SPACE\nOVP10    DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#OOPRT": {"ttr": 8721, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00J\\x00J\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 74, "newlines": 74, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              'OOPRT' INTERNAL ROUTINE --- PROCESS OUTPUT OVERLAY    *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY --  (R0) -> RDW OF OUTPUT LINE\n         SPACE\nOOPRT   $ENTER ,\nOOPRT01  DS    0H\n         L     X1,OOANCH           OUTPUT OVERLAY ELEMENT ANCHOR\n         LTR   X1,X1               ANYTHING THERE .Q\n         BZ    OOPRT09             GO TO RETURN IF NOT\n         USING OODSECT,X1          TELL THE ASSEMBLER\n        $IFON  TTYPE,TONLINE,OOPRT02    BRANCH IF ONLINE\n         LR    R1,R0               OUTPUT BUFFER\n         CLI   4(R1),SUPRSPAC      PRINTER OVERLAY LINE .Q\n         BE    OOPRT09             YES, GO TO RETURN\nOOPRT02  DS    0H\n         L     COUNT,OOQCNT        OVERLAY COUNT\n         S     COUNT,F1            LESS ONE\n         BNM   OOPRT03             BRANCH IF WE CAN DO IT\n         LA    R1,OOANCH-OOQFCHN+OODSECT   PTR TO HEAD OF CHAIN\n        $CALL  OVREMOV             REMOVE FIRST ENTRY\n         B     OOPRT01             AND TRY AGAIN\n         SPACE\nOOPRT03  DS    0H\n         ST    COUNT,OOQCNT        UPDATE OUTPUT OVERLAY COUNT\n         LH    COUNT,OOQRDW        LENGTH OF OVERLAY BUFFER\n         LTR   COUNT,COUNT         ANYTHING THERE .Q\n         BNP   ABOO01              BRANCH TO QUIT IF NOTHING\n         LR    R1,R0               OUTPUT BUFFER\n        $IFON  TTYPE,TONLINE,OOPRT04    BRANCH IF ONLINE\n         LA    COUNT,1(,COUNT)     PLUS CARRIAGE CONTROL\nOOPRT04  DS    0H\n         LA    COUNT,4(,COUNT)     PLUS RDW LENGTH\n         AH    COUNT,ADJCNT        PLUS CURRENT ADJUST VALUE\n         MVC   SAVEH0,0(R1)        ALIGN CURRENT RECORD LENGTH\n         CH    COUNT,SAVEH0        IS OVERLAY LONGER .Q\n         BNH   OOPRT05             BRANCH IF NOT\n         STH   COUNT,SAVEH0        ALIGN LONGER RECORD LENGTH\n         MVC   0(2,R1),SAVEH0      NEW LENGTH SAME AS OVERLAY\nOOPRT05  DS    0H\n         LA    R1,3(,R1)           POINT TO OUTPUT DATA-1\n        $IFON  TTYPE,TONLINE,OOPRT06    BRANCH IF ONLINE\n         LA    R1,1(,R1)           PLUS CARRIAGE CONTROL\nOOPRT06  DS    0H\n         AH    R1,ADJCNT           PLUS ADJUST VALUE\n         LH    COUNT,OOQRDW        LENGTH OF OVERLAY\n         AR    R1,COUNT            END OF OUTPUT STRING-1\nOOPRT07  DS    0H\n         CLI   0(R1),C' '          BLANK IN OUTPUT LINE .Q\n         BNE   OOPRT08             BRANCH IF NOT\n         IC    TEMP,OOQDATA-1(COUNT)    GET OVERLAY CHARACTER\n         STC   TEMP,0(,R1)         PUT IN OUTPUT LINE\n        $IFOFF SWITCHS,TRSWS,OOPRT08    BRANCH IF NO TRANSLATE\n         L     TEMP,TRANADO        ADDRESS OF OUTPUT TRANSLATE TABLE\n         TR    0(1,R1),0(TEMP)     CONVERT SINGLE CHARACTER\nOOPRT08  DS    0H\n         BCTR  R1,0                BACKUP OUTPUT POINTER\n         BCT   COUNT,OOPRT07       DO AS REQUIRED\n         L     COUNT,OOQCNT        GET CURRENT COUNT LEFT\n         LTR   COUNT,COUNT         TEST IT\n         BP    OOPRT09             BRANCH IF SOME LEFT\n         LA    R1,OOANCH-OOQFCHN+OODSECT     PTR TO ANCHOR ELEMENT\n        $CALL  OVREMOV             REMOVE CURRENT ENTRY\n         SPACE\nOOPRT09  DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              AND RETURN TO CALLER\n         DROP  X1\n         SPACE\nABOO01   DS    0H\n        $LOGERR 1012               NO OUTPUT OVERLAY DATA\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#OPTEST": {"ttr": 8724, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\xb9\\x00\\xb9\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 185, "newlines": 185, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INVOCATION PARAMETER OPTIONS                           *\n*                                                                     *\n***********************************************************************\n         SPACE\nOPTPSTR  EQU   0                   PARM STRING\nOPTPLEN  EQU   OPTPSTR+12          MINIMUM LENGTH MINUS ONE\nOPTPADDR EQU   OPTPLEN+0           ROUTINE ADDRESS\nOPTPBITS EQU   OPTPADDR+4          SWITCHING BITS\nOPTPEND  EQU   OPTPBITS+4          THE END\n         SPACE\nOPTEST1  DS    0F                  POSITIONAL PARMS\n         DC    CL12'ADJUST',AL1(1),AL3(SWTCHEX)\n         B     ADJUST\n         DC    CL12'NOADJUST',AL1(3),AL3(SWTCHEX)\n         B     UNADJUST\n         DC    CL12'CENTER',AL1(1),AL3(SWTCHEX)\n         B     ADJUST\n         DC    CL12'CENTRE',AL1(4),AL3(SWTCHEX)\n         B     ADJUST\n         DC    CL12'NOCENTER',AL1(3),AL3(SWTCHEX)\n         B     UNADJUST\n         DC    CL12'NOCENTRE',AL1(6),AL3(SWTCHEX)\n         B     SWTCHNNM\n         DC    CL12'CONTINUE',AL1(1),AL3(SWTCHEX)\n         B     SWCONT\n         DC    CL12'NOCONTINUE',AL1(3),AL3(SWTCHEX)\n         B     SWCONTNO\n         DC    CL12'DEBUG',AL1(4),AL3(SWTCHEX)\n        $ON    PARMSWCH,DBSWS\n         DC    CL12'NODEBUG',AL1(6),AL3(SWTCHEX)\n        $OFF   PARMSWCH,DBSWS\n         DC    CL12'FORMATTED',AL1(1),AL3(SWTCHFO)\n         DC    AL1(0,0,0,0)\n         DC    CL12'UNFORMATTED',AL1(1),AL3(SWTCHNF)\n         DC    AL1(0,0,0,0)\n         DC    CL12'NOFORMATTED',AL1(3),AL3(SWTCHNF)\n         DC    AL1(0,0,0,0)\n         DC    CL12'LOCAL',AL1(2),AL3(SWTCHEX)\n        $OFF   PARMSWCH,GBLSWS\n         DC    CL12'GLOBAL',AL1(2),AL3(SWTCHEX)\n        $ON    PARMSWCH,GBLSWS\n         DC    CL12'MARK',AL1(1),AL3(SWTCHEX)\n        $ON    PARMSWCH,MASWS\n         DC    CL12'NOMARK',AL1(3),AL3(SWTCHEX)\n        $OFF   PARMSWCH,MASWS\n         DC    CL12'NUMBER',AL1(1),AL3(SWTCHEX)\n         B     SWTCHNM\n         DC    CL12'NONUMBER',AL1(3),AL3(SWTCHEX)\n         B     SWTCHNNM\n         DC    CL12'PROFILE',AL1(3),AL3(SWTCHEX)\n        $ON    PARMSWCH,PROFSW\n         DC    CL12'NOPROFILE',AL1(5),AL3(SWTCHEX)\n        $OFF   PARMSWCH,PROFSW\n         DC    CL12'QUIET',AL1(1),AL3(SWTCHEX)\n        $ON    PARMSWCH,QUSWS\n         DC    CL12'NOQUIET',AL1(3),AL3(SWTCHEX)\n        $OFF   PARMSWCH,QUSWS\n         DC    CL12'SCREEN',AL1(3),AL3(SWTCHEX)\n        $ON    TTYPE,TSCREEN\n         DC    CL12'NOSCREEN',AL1(5),AL3(SWTCHEX)\n        $OFF   TTYPE,TSCREEN\n         DC    CL12'SIX',AL1(2),AL3(SWTCHEX)\n         B     SWTCHP6\n         DC    CL12'EIGHT',AL1(2),AL3(SWTCHEX)\n         B     SWTCHP8\n         DC    CL12'SPIE',AL1(3),AL3(SWTCHEX)\n        $OFF   PARMSWCH,DBSWS\n         DC    CL12'NOSPIE',AL1(5),AL3(SWTCHEX)\n        $ON    PARMSWCH,DBSWS\n         DC    CL12'STATISTICS',AL1(3),AL3(SWTCHEX)\n        $ON    PARMSWCH,STATSWS\n         DC    CL12'NOSTATISTICS',AL1(5),AL3(SWTCHEX)\n        $OFF   PARMSWCH,STATSWS\n         DC    CL12'STOP',AL1(1),AL3(SWTCHEX)\n        $ON    PARMSWCH,STSWS\n         DC    CL12'NOSTOP',AL1(3),AL3(SWTCHEX)\n        $OFF   PARMSWCH,STSWS\n         DC    CL12'TRANSLATE',AL1(1),AL3(SWTCHEX)\n        $ON    PARMSWCH,TROSWS\n         DC    CL12'NOTRANSLATE',AL1(3),AL3(SWTCHEX)\n        $OFF   PARMSWCH,TROSWS\n         DC    CL12'TWOPASS',AL1(3),AL3(SWTCHEX)\n         MVI   DEFPASOF+TAB3DEF+3,X'02'\n         DC    CL12'ONEPASS',AL1(3),AL3(SWTCHEX)\n         MVI   DEFPASOF+TAB3DEF+3,X'01'\n         DC    CL12'2PASS',AL1(1),AL3(SWTCHEX)\n         MVI   DEFPASOF+TAB3DEF+3,X'02'\n         DC    CL12'1PASS',AL1(1),AL3(SWTCHEX)\n         MVI   DEFPASOF+TAB3DEF+3,X'01'\n         DC    CL12'UPCASE',AL1(1),AL3(SWTCHEX)\n        $ON    PARMSWCH,TROSWS\n         DC    CL12'NOUPCASE',AL1(3),AL3(SWTCHEX)\n        $OFF   PARMSWCH,TROSWS\n         DC    CL12'UPPER',AL1(2),AL3(SWTCHEX)\n        $OFF   PARMSWCH,NUPSWS\n         DC    CL12'NOUPPER',AL1(4),AL3(SWTCHEX)\n        $ON    PARMSWCH,NUPSWS\n         DC    CL12'NOWAIT',AL1(2),AL3(SWTCHEX)\n        $ON    PARMSWCH,NOSWS\n         DC    CL12'WAIT',AL1(1),AL3(SWTCHEX)\n        $OFF   PARMSWCH,NOSWS\n         SPACE\n         DC    CL12'TERMINAL',AL1(1),AL3(SWTCHEX)\n        $ON    TTYPE,TONLINE\n         DC    CL12'ONLINE',AL1(1),AL3(SWTCHEX)\n        $ON    TTYPE,TONLINE\n         DC    CL12'PRINTER',AL1(1),AL3(SWTCHEX)\n        $OFF   TTYPE,TONLINE\n         DC    CL12'PRT',AL1(1),AL3(SWTCHEX)\n        $OFF   TTYPE,TONLINE\n         DC    CL12'OFFLINE',AL1(1),AL3(SWTCHEX)\n        $OFF   TTYPE,TONLINE\n         DC    CL12'FILE',AL1(1),AL3(SWTCHEX)\n        $ON    TTYPE,TFILE\n         DC    CL12'NOFILE',AL1(3),AL3(SWTCHEX)\n        $OFF   TTYPE,TFILE\n         SPACE\n         DC    CL12'X1620',AL1(4),AL3(SWTCHEX)\n         MVI   TDEVICE,TX1620\n         DC    CL12'MULTI3',AL1(5),AL3(SWTCHEX)\n         MVI   TDEVICE,TXASM3\n         DC    CL12'QUME',AL1(3),AL3(SWTCHEX)\n         MVI   TDEVICE,TQUME\n         DC    CL12'ASISTERM',AL1(3),AL3(SWTCHEX)\n         MVI   TDEVICE,TXASIS\n         DC    CL12'MYTERM',AL1(5),AL3(SWTCHEX)\n         MVI   TDEVICE,TMYTE\n         DC    4AL1(FF)            THE END\n         SPACE\nOPTEST2  DS    0F\n         DC    CL12'ADJUST',AL1(1),AL3(SWTCHDGT)\n         DC    AL4(DEFADJ-DEFAULTS)\n         DC    CL12'BMARGIN',AL1(1),AL3(SWTCHDGT)\n         DC    AL4(DEFBM-DEFAULTS)\n         DC    CL12'CENTER',AL1(1),AL3(SWTCHDGT)\n         DC    AL4(DEFADJ-DEFAULTS)\n         DC    CL12'CENTRE',AL1(4),AL3(SWTCHDGT)\n         DC    AL4(DEFADJ-DEFAULTS)\n         DC    CL12'CONTINUE',AL1(1),AL3(SWTCHDGT)\n         DC    AL4(DEFCONT-DEFAULTS)\n         DC    CL12'CPINCH',AL1(2),AL3(SWTCHDGT)\n         DC    AL4(DEFCPI-DEFAULTS)\n         DC    CL12'DARK',AL1(1),AL3(SWTCHDGT)\n         DC    AL4(DEFDARK-DEFAULTS)\n         DC    CL12'FFCHANNEL',AL1(2),AL3(SWTCHDGT)\n         DC    AL4(DEFFFCH-DEFAULTS)\n         DC    CL12'FFTOP',AL1(2),AL3(SWTCHDGT)\n         DC    AL4(DEFFFTO-DEFAULTS)\n         DC    CL12'FMARGIN',AL1(1),AL3(SWTCHDGT)\n         DC    AL4(DEFFTMG-DEFAULTS)\n         DC    CL12'FNSIZE',AL1(2),AL3(SWTCHDGT)\n         DC    AL4(DEFFNSIZ-DEFAULTS)\n         DC    CL12'HMARGIN',AL1(1),AL3(SWTCHDGT)\n         DC    AL4(DEFHDMG-DEFAULTS)\n         DC    CL12'HSFSOVER',AL1(3),AL3(SWTCHDGT)\n         DC    AL4(DEFHSFS-DEFAULTS)\n         DC    CL12'LEGALNUMBER',AL1(2),AL3(LEGDGT)\n         DC    AL4(DEFLNUM-DEFAULTS)\n         DC    CL12'LINENUMBER',AL1(2),AL3(LINDGT)\n         DC    AL4(DEFLNUM-DEFAULTS)\n         DC    CL12'LLENGTH',AL1(1),AL3(SWTCHDGT)\n         DC    AL4(DEFLL-DEFAULTS)\n         DC    CL12'NUMBER',AL1(1),AL3(NUMDGT)\n         DC    AL4(DEFNUM-DEFAULTS)\n         DC    CL12'PAGES',AL1(1),AL3(PAGPARM)\n         DC    AL4(DEFPAGS-DEFAULTS)\nOPTPAGEL DC    CL12'PAGELAST',AL1(4),AL3(PAGPARML)\n         DC    AL4(DEFPAGL-DEFAULTS)\n         DC    CL12'PASSES',AL1(2),AL3(SWTCHDGT)\n         DC    AL4(DEFPASOF-DEFAULTS)\n         DC    CL12'PLENGTH',AL1(1),AL3(SWTCHDGT)\n         DC    AL4(DEFPL-DEFAULTS)\n         DC    CL12'RMSIZE',AL1(2),AL3(SWTCHDGT)\n         DC    AL4(DEFRMSIZ-DEFAULTS)\n         DC    CL12'SEQCOLUMN',AL1(3),AL3(SWTCHDGT)\n         DC    AL4(DEFSEQC-DEFAULTS)\n         DC    CL12'SRLENGTH',AL1(2),AL3(SWTCHDGT)\n         DC    AL4(DEFRNLEN-DEFAULTS)\n         DC    CL12'TABLEFT',AL1(3),AL3(SWTCHDGT)\n         DC    AL4(DEFTABL-DEFAULTS)\n         DC    CL12'TMARGIN',AL1(1),AL3(SWTCHDGT)\n         DC    AL4(DEFTM-DEFAULTS)\n         DC    4AL1(FF)            THE END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#OUSTAT": {"ttr": 8964, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\xdc\\x00\\xdc\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 220, "newlines": 220, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        INTERNAL FUNCTION 'OUSTAT' --- FORMAT USAGE STATISTICS       *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER:   $CALL  OUSTAT                                    *\n         SPACE\nOUSTAT  $ENTER ,\n         L     COUNT,BUFF3AD       BUFFER WORK AREA\n         L     X1,ADBASE           MAIN SCRIPT ENTRY POINT\n         SR    R1,R1               ZERO LENGTH REGISTER\n         IC    R1,4(,X1)           LENGTH OF VERSION IDENT\n         BCTR  R1,0                LENGTH-1 FOR MOVE\n         EX    R1,OUSTMVC1         MOVE SCRIPT IDENTIFIER\n         XC    0(4,COUNT),0(COUNT) CLEAR RDW\n         LA    R1,6(,R1)           LENGTH OF RESULTING RECORD\n         STH   R1,0(,COUNT)        ENTER RECORD LENGTH\n         MVI   4(COUNT),C'0'       DOUBLE SPACED\n         BAL   RETURN,OUSTPRT      DUMP THAT\n         B     OUST01              AND CONTINUE\nOUSTMVC1 MVC   5(*-*,COUNT),5(X1)  EXECUTED MOVE VERSION IDENT\n         SPACE\nOUST01   DS    0H\n         L     X1,PLSTSV           PARM LIST ADDRESS\n         L     X1,0(,X1)           GET ADDR OF ACTUAL LIST\n         LH    R1,0(,X1)           GET LENGTH OF PARM\n         LTR   R1,R1               IS IT NULL .Q\n         BZ    OUST02              BRANCH IF YES\n         MVC   0(STPRM1L,COUNT),STPRM1S PARM MESSAGE\n         BCTR  R1,0                LENGTH-1 FOR MVC\n         EX    R1,OUSTMVC2         MOVE USER PARM\n         LA    R1,1+STPRM1L(,R1)   NEW MESSAGE LENGTH\n         STH   R1,0(,COUNT)        UPDATE WITH NEW LENGTH\n         BAL   RETURN,OUSTPRT      DUMP THAT\n         B     OUST02              AND CONTINUE\nOUSTMVC2 MVC   STPRM1L(*-*,COUNT),2(X1) MOVE USER PARM\n         SPACE\nOUST02   DS    0H\n         L     TEMP,PRGHIGH        REGION MANAGER HIGH WATER MARK\n         LTR   TEMP,TEMP           ANYTHING USED .Q\n         BNP   OUST03              BRANCH IF NOT\n         MVC   0(STHGH1L,COUNT),STHGH1S HIGH CORE MESSAGE\n         CVD   TEMP,DECM           CONVERT CORE TO DECIMAL\n         ED    STHGH1B-STHGH1S(8,COUNT),DECM+4 CORE TO CHARACTER\n         BAL   RETURN,OUSTPRT      AND DUMP THE RESULT\n         SPACE\nOUST03   DS    0H\n         MVC   0(STMSG1L,COUNT),STMSG1S      FIRST MESSAGE\n         BAL   RETURN,OUSTPRT      DUMP THAT\n         SPACE\n         MVC   0(STMSG2L,COUNT),STMSG2S      SECOND MESSAGE\n         BAL   RETURN,OUSTPRT      DUMP THAT\n         SPACE\n         LM    X1,X3,INDEXS        SET CONTROL WORD INDEXS\n         SR    R0,R0               ZERO TOTAL USE COUNT\nOUST04   DS    0H\n         LH    TEMP,SPCTLC(,X1)    GET USE COUNT\n         LTR   TEMP,TEMP           IS IT ZERO .Q\n         BZ    OUST05              BRANCH IF YES\n         AR    R0,TEMP             BUMP TOTAL USE COUNT\n         MVC   0(STMSG3L,COUNT),STMSG3S      THIRD MESSAGE\n         MVC   STMSG3A-STMSG3S+3(2,COUNT),SPCTLI(X1)  ENTER ORIG NAME\n         CVD   TEMP,DECM           CONVERT COUNT TO DECIMAL\n         ED    STMSG3B-STMSG3S(6,COUNT),DECM+5  CONVERT TO CHARACTER\n         BAL   RETURN,OUSTPRT      AND DUMP THE RESULT\nOUST05   DS    0H\n         BXLE  X1,X2,OUST04        DO AS MANY AS THERE ARE\n         CVD   R0,DECM             CONVERT TOTAL COUNT TO DECIMAL\n         MVC   0(STTOT1L,COUNT),STTOT1S ENTER TOTAL MESSAGE\n         ED    STTOT1B-STTOT1S(8,COUNT),DECM+4    CONVERT TO CHARACTER\n         BAL   RETURN,OUSTPRT      AND DUMP THE RESULT\n         SPACE\n         MVC   0(STCNT1L,COUNT),STCNT1S FIRST MESSAGE\n         BAL   RETURN,OUSTPRT      DUMP THAT\n         MVC   0(STCNT2L,COUNT),STCNT2S SECOND MESSAGE\n         BAL   RETURN,OUSTPRT      DUMP THAT\n         SPACE\n         L     X3,VSCRICVT         COMMUNICATION VECTOR TABLE\n         USING SCRICVT,X3          TELL THE ASSEMBLER\n         LA    X1,VFSTATS          START OF ROUTINE ADDRS\n         LA    X2,L'VFSTATS        ENTRY LENGTH\n         LA    X3,VFSTATE          END OF ROUTINE ADDRS\n         DROP  X3\n         SR    R0,R0               ZERO TOTAL CALL COUNT\nOUST06   DS    0H\n         L     R1,0(,X1)           NEXT CANDIDATE\n         LTR   R1,R1               ANYTHING THERE .Q\n         BNP   OUST07              BRANCH IF NOT\n         USING SCVTDSCT,R1         CANDIDATE AREA\n         CLI   SCVTCCNT,X'47'      ENTRY SEQUENCE .Q\n         BE    OUST07              BRANCH IF YES\n         L     TEMP,SCVTCCNT       ROUTINE CALL COUNT\n         LTR   TEMP,TEMP           TEST COUNT\n         BNP   OUST07              BRANCH IF NOTHING\n         AR    R0,TEMP             BUMP TOTAL CALL COUNT\n         MVC   0(STCNT3L,COUNT),STCNT3S ENTER BASIC MESSAGE\n         MVC   STCNT3A-STCNT3S(8,COUNT),SCVTCSCT  ENTER ROUTINE NAME\n         CVD   TEMP,DECM           CALL COUNT TO DECIMAL\n         ED    STCNT3B-STCNT3S(6,COUNT),DECM+5    ENTER CALL COUNT\n         BAL   RETURN,OUSTPRT      AND DUMP RESULT\nOUST07   DS    0H\n         BXLE  X1,X2,OUST06        DO THEM ALL\n         DROP  R1\n         CVD   R0,DECM             CONVERT TOTAL COUNT TO DECIMAL\n         MVC   0(STTOT1L,COUNT),STTOT1S ENTER TOTAL MESSAGE\n         ED    STTOT1B-STTOT1S(8,COUNT),DECM+4    CONVERT TO CHARACTER\n         BAL   RETURN,OUSTPRT      AND DUMP THE RESULT\n         SPACE\n         MVC   0(STCHR1L,COUNT),STCHR1S MOVE CHAR BLOCK MESSAGE\n         L     TEMP,LKSIZE          FREE CHAR COUNT\n         CVD   TEMP,DECM           CONVERT TO DECIMAL\n         ED    STCHR1A-STCHR1S(6,COUNT),DECM+5    ENTER FREE CHAR COUNT\n         L     TEMP,LKASIZE        TOTAL CHAR COUNT\n         CVD   TEMP,DECM            CONVERT TO DECIMAL\n         ED    STCHR1B-STCHR1S(6,COUNT),DECM+5    ENTER TOTAL CHAR CNT\n         BAL   RETURN,OUSTPRT      DUMP THE RESULT\n         SPACE\n         MVC   0(STSAV1L,COUNT),STSAV1S SAVE AREAS MESSAGE\n         LA    TEMP,SAVEVLS        MAX NUMBER OF SAVE AREAS\n         CVD   TEMP,DECM           CONVERT TO DECIMAL\n         OI    DECM+7,X'0F'        FIX THE SIGN\n         UNPK  STSAV1-STSAV1S+8(3,COUNT),DECM+6(2)  ADD TOTAL TO MSG\n         SPACE\nOUST08   DS    0H\n         LR    R1,TEMP             CURRENT NEST LEVEL\n         BCTR  R1,0                GET LEVEL-1\n         LA    R0,SAVELEN          LENGTH OF ONE AREA\n         MR    R0,R0               STACK AREA OFFSET\n         A     R1,SAVEINIT         PLUS INITIAL STACK AREA\n         OC    0(SAVELEN,R1),0(R1) WAS IT USED .Q\n         BNZ   OUST09              BRANCH OUT IF YES\n         BCT   TEMP,OUST08         DO AS REQUIRED\nOUST09   DS    0H\n         CVD   TEMP,DECM           CONVERT TO DECIMAL\n         OI    DECM+7,X'0F'        FIX THE SIGN\n         UNPK  STSAV1-STSAV1S+1(3,COUNT),DECM+6(2)  ADD USED COUNT\n         BAL   RETURN,OUSTPRT      DUMP IT\n         SPACE\n         MVC   0(STHIT1L,COUNT),STHIT1S MOVE REF VARIABLES MESSAGE\n         L     TEMP,RNTBSRCH       TOTAL SEARCH COUNT\n         S     TEMP,RNTBFAIL       LESS LOOKASIDE FAILURES\n         CVD   TEMP,DECM           GIVES THE HIT COUNT\n         ED    STHIT1A-STHIT1S(6,COUNT),DECM+5    ENTER HIT COUNT\n         L     TEMP,RNTBSRCH       GET TOTAL SEARCH COUNT\n         CVD   TEMP,DECM           GIVES THE TOTAL SEARCH COUNT\n         ED    STHIT1B-STHIT1S(6,COUNT),DECM+5    ENTER SEARCH COUNT\n         L     TEMP,RNTBCNT        GET UNSUBSCRIPTED VARIABLE COUNT\n         CVD   TEMP,DECM           CONVERT TO DECIMAL\n         ED    STHIT1C-STHIT1S(6,COUNT),DECM+5    ENTER USER REF COUNT\n         L     TEMP,RNTBSCNT       GET USER SUBSCRIPTED VAR COUNT\n         CVD   TEMP,DECM           CONVERT TO DECIMAL\n         ED    STHIT1D-STHIT1S(6,COUNT),DECM+5    ENTER SUBSCRIPT REF\n         BAL   RETURN,OUSTPRT      DUMP THE RESULT\n         SPACE\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              AND RETURN TO CALLER\n         SPACE\nOUSTPRT  DS    0H\n        $SAVE ,                    SAVE ALL REGISTERS\n         LR    R0,COUNT            MESSAGE RDW ADDRESS\n        $CALL  PRTERM              DISPLAY RESULT ON SYSTERM\n        $RESTOR ,                  RESTORE ALL REGISTERS\n         BR    RETURN              AND RETURN TO CALLER\n         SPACE\nSTPRM1S  DC    0H'0',AL2(STPRM1L,0)\nSTPRM1   DC    C'0OVERRIDING PARM='\nSTPRM1L  EQU   *-STPRM1S\n         SPACE\nSTHGH1S  DC    0H'0',AL2(STHGH1L,0)\nSTHGH1A  DC    C'0MAXIMUM INTERNAL REGION'\nSTHGH1B  DC    X'4020202020202120'\nSTHGH1L  EQU   *-STHGH1S\n         SPACE\nSTMSG1S  DC    0H'0',AL2(STMSG1L,0)\nSTMSG1   DC    C'0CONTROL  USE'\nSTMSG1L  EQU   *-STMSG1S\n         SPACE\nSTMSG2S  DC    0H'0',AL2(STMSG2L,0)\nSTMSG2   DC    C'  WORD   COUNT'\nSTMSG2L  EQU   *-STMSG2S\n         SPACE\nSTMSG3S  DC    0H'0',AL2(STMSG3L,0)\nSTMSG3A  DC    C'  ''**'' '\nSTMSG3B  DC    X'402020202120'\nSTMSG3L  EQU   *-STMSG3S\n         SPACE\nSTSAV1S  DC    0H'0',AL2(STSAV1L,0)\nSTSAV1   DC    C'0*** OF *** STACK SAVE AREAS USED'\nSTSAV1L  EQU   *-STSAV1S\n         SPACE\nSTHIT1S  DC    0H'0',AL2(STHIT1L,0),C'0'\nSTHIT1A  DC    X'402020202120',C' OF'\nSTHIT1B  DC    X'402020202120',C' REFERENCE LOOKASIDE HITS FOR'\nSTHIT1C  DC    X'402020202120',C' VARIABLES AND'\nSTHIT1D  DC    X'402020202120',C' SUBSCRIPTS'\nSTHIT1L  EQU   *-STHIT1S\n         SPACE\nSTCNT1S  DC    0H'0',AL2(STCNT1L,0)\nSTCNT1   DC    C'0ROUTINE   CALL'\nSTCNT1L  EQU   *-STCNT1S\n         SPACE\nSTCNT2S  DC    0H'0',AL2(STCNT2L,0)\nSTCNT2   DC    C'  NAME    COUNT'\nSTCNT2L  EQU   *-STCNT2S\n         SPACE\nSTCNT3S  DC    0H'0',AL2(STCNT3L,0),C' '\nSTCNT3A  DC    C'********'\nSTCNT3B  DC    X'402020202120'\nSTCNT3L  EQU   *-STCNT3S\n         SPACE\nSTTOT1S  DC    0H'0',AL2(STTOT1L,0)\nSTTOT1A  DC    C' TOTAL '\nSTTOT1B  DC    X'4020202020202120'\nSTTOT1L  EQU   *-STTOT1S\n         SPACE\nSTCHR1S  DC    0H'0',AL2(STCHR1L,0),C'0'\nSTCHR1A  DC    X'402020202120',C' OF'\nSTCHR1B  DC    X'402020202120',C' CHARACTERS FREE'\nSTCHR1L  EQU   *-STCHR1S\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#OV": {"ttr": 8969, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\n\\x00\\n\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .OV (OVERLAY INPUT TEXT) --- CONTROL                   *\n*                                                                     *\n***********************************************************************\n         SPACE\nOV      $ENTER ,\n         LA    R1,OIANCH-OOQFCHN+OODSECT     POINT TO ANCHOR\n        $CALL  OVPROC              PROCESS THE OPERAND\n        $EXIT  RC=0                AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#OVREMOV": {"ttr": 8971, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x009\\x009\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 57, "newlines": 57, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        INTERNAL FUNCTION 'OVREMOV' --- REMOVES ONE OVERLAY BUFFER   *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER:   $CALL  OVREMOV\n*                    (R1) -> OVERLAY ANCHOR ELEMENT\n*\n*        ON EXIT:   CC=BPOS   OPERATION SUCCESSFUL\n*                   CC=BOMIT  OPERATION SUCCESSFUL, LIST EMPTY\n*                   CC=BNEG   NO BUFFER TO BE FREED\n         SPACE\nOVREMOV $ENTER ,\n         LR    X1,R1               OLD POINTER\n         LR    TEMP,R1             WORKING POINTER\n         USING OODSECT,TEMP        NEXT POINTER\n         L     TEMP,OOQFCHN        NEXT ON LIST\n         LTR   R0,TEMP             AT THE END .Q\n         BZ    OVR02               BRANCH IF YES\n         LA    R1,OOQLEN           PREFIX LENGTH\n         AH    R1,OOQRDW           PLUS DATA LENGTH\n         L     TEMP,OOQFCHN        NEXT FORWARD POINTER\n         DROP  TEMP\n         ST    TEMP,OOQFCHN-OODSECT(,X1)     UNCHAIN FIRST ELEMENT\n        $CALL  FREECELL            FREE FIRST OVERLAY ELEMENT\n         LTR   TEMP,TEMP           ANY MORE .Q\n         BP    OVR01               BRANCH IF YES\n         SPACE\n        $CC    OMIT                SUCCESS, LIST IS EMPTY\n         B     OVR03               GO TO RETURN\nOVR01    DS    0H\n        $CC    POS                 SUCCESS\n         B     OVR03               GO TO RETURN\nOVR02    DS    0H\n        $CC    NEG                 NO BUFFER TO FREE\n         SPACE\nOVR03    DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              AND RETURN TO CALLER\n         SPACE 2\nOVCLR   $ENTER ,\n         SPACE\n*        TO DELETE ALL OVERLAY ELEMENTS\n*        ON ENTRY --  (R1) -> OVERLAY ANCHOR ELEMENT\n*        ON EXIT  --  CC=BOMIT   OPERATION SUCCESSFUL\n*                     CC=BNEG    NO BUFFER TO BE FREED\n         SPACE\nOVC01    DS    0H\n        $CALL  OVREMOV             DELETE FIRST LEVEL\n         BC    BNEG,OVC02          BRANCH IF NONE\n         BC    BOMIT,OVC02         BRANCH IF DONE\n         B     OVC01               ELSE DO NEXT ONE\n         SPACE\nOVC02    DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PA": {"ttr": 8973, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00N\\x00N\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 78, "newlines": 78, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .PA (PAGE EJECT) --- CONTROL                           *\n*                                                                     *\n***********************************************************************\n         SPACE\nPA      $ENTER ,\n         CLI   ICORFLG,ICORNONE    SAVING FORMATTED TEXT INCORE .Q\n         BNE   PAE012              ERROR IF YES\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         L     X1,ARGSTOP          END  OF ALL ARGS\n         LA    X1,1(,X1)           PLUS ONE\n         ST    X1,ARGSTART         FOR GUARANTEED NULL NEXT TIME\n         BC    BOMIT+BPOS,PA03     BRANCH IF NULL OR AFFIRMATIVE\n         BC    BNEG,PA10           RETURN IF NEGATIVE\n         CLI   YNRESULT,YNODD      IS ARG 'ODD' .Q\n         BNE   PA01                BRANCH IF NOT\n        $CALL  PD                  ODD PAGE ROUTINE\n         B     PA10                GO TO RETURN\nPA01     DS    0H\n         CLI   YNRESULT,YNEVN      IS ARG 'EVEN' .Q\n         BNE   PA02                BRANCH IF NOT\n        $CALL  PV                  EVEN PAGE ROUTINE\n         B     PA10                GO TO RETURN\nPA02     DS    0H\n         ST    COUNT,ARGSTART      RESCAN FOR NUMERIC ARG\nPA03     DS    0H\n        $CALL  PRINTNB             PRINT REMAINDER OF CURRENT LINE\n         BC    BNEG,PA04           BRANCH IF NOBREAK EJECT\n        $CALL  PAGEREAL            CAUSE PAGE EJECT\n         SPACE\nPA04     DS    0H\n        $CALL  GETNUM              GET NEW INTEGER PAGE NUMBER\n         BC    BOMIT,PA09          BRANCH IF OMITTED ARGUMENT\n         BC    BDNO,PAE005         BRANCH IF INVALID ARGUMENT\n         CLI   NUMSIGN,C' '        WAS ARGUMENT UNSIGNED .Q\n         BE    PA05                BRANCH IF YES\n         A     COUNT,PACNTI        ALTER INTEGER PART ACCORDINGLY\nPA05     DS    0H\n         LTR   COUNT,COUNT         TEST RESULT\n         BNP   PAE014              ERROR IF NOT POSITIVE\n         ST    COUNT,PACNTI        UPDATE CURRENT PAGE NUMBER\n         SPACE\nPA06     DS    0H\n        $CALL  GETNUM              GET OPTIONAL DECIMAL PART\n         BC    BOMIT,PA08          BRANCH IF NOTHING THERE\n         BC    BDNO,PAE005         BRANCH IF INVALID ARGUMENT\n         CLI   NUMSIGN,C' '        WAS ARGUMENT UNSIGNED .Q\n         BE    PA07                BRANCH IF YES\n         L     R0,PACNTD           FORMER DECIMAL VALUE\n         LTR   R0,R0               IS OLD VALUE UNDEFINED .Q\n         BM    PA07                BRANCH IF YES\n         AR    COUNT,R0            ALTER THE DECIMAL PART\nPA07     DS    0H\n         LTR   COUNT,COUNT         TEST DECIMAL RESULT\n         BM    PAE014              ERROR IF NEGATIVE\n         ST    COUNT,PACNTD        UPDATE DECIMAL PART OF PAGE NUMBER\n         B     PA09                GO TO EXIT RETURN\n         SPACE\nPA08     DS    0H\n         L     R0,PACNTDI          INITIAL VALUE FOR DECIMAL PART\n         ST    R0,PACNTD           SET DEFAULT\n         SPACE\nPA09     DS    0H\n         B     PA10                GO TO RETURN\n         SPACE\nPAE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     PA10                GO TO RETURN\nPAE014   DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     PA10                GO TO RETURN\nPAE012   DS    0H\n         MVI   EFLAG012,ERRSET     ILLEGAL PLACEMENT OF CONTROL WORD\n         B     PA10                GO TO RETURN\n         SPACE\nPA10     DS    0H\n        $EXIT  RC=0                DONE WITH .PA CONTROL\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PAGE": {"ttr": 8976, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x99\\x00\\x99\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 153, "newlines": 153, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTION 'PAGE' --- GENERATE PAGE EJECT       *\n*                                                                     *\n***********************************************************************\n         SPACE\nPAGE    $ENTER ,\n         CLI   ICOLFLG,ICOLMC      IN MULTI-COLUMN MODE .Q\n         BNE   PAEJ00A             BRANCH IF NOT\n        $CALL  COLPAGE             EJECT A COLUMN IF YES\n         B     PAEJ17              GO TO RETURN\n         SPACE\nPAEJ00A  DS    0H\n         L     COUNT,PAGECNT       REAL PAGE EJECT COUNT\n         LA    COUNT,1(,COUNT)     PLUS ONE\n         ST    COUNT,PAGECNT       UPDATE REAL PAGE EJECT COUNT\nPAEJ00   DS    0H\n        $IFOFF SWITCHS,FFIRST,PAEJ01    BRANCH IF NOT FIRST PAGE\n        $IFOFF TTYPE,TONLINE,PAEJ02     BRANCH IF NOT ONLINE\nPAEJ01   DS    0H\n        $IFOFF SWITCHS,(FEMPTY,FNOEMPTY),PAEJ02 EMPTY PAGE AND .EM NO\n         OC    FNQCNT,FNQCNT       ANY FOOTNOTES QUEUED .Q\n         BNZ   PAEJ02              NOT EMPTY IF YES\n         OC    FKQCNT,FKQCNT       ANY FLOATING KEEPS QUEUED .Q\n         BNZ   PAEJ02              NOT EMPTY IF YES\n         OC    CPQCNT,CPQCNT       ANY CONDITIONAL KEEPS QUEUED .Q\n         BNZ   PAEJ02              NOT EMPTY IF YES\n         OC    RMTRIG,RMTRIG       NO, ANY REMOTES WAITING .Q\n         BNZ   PAEJ02              IF YES, ALSO NOT NULL\n        $IFON  SWITCHS,FNOEMBMP,PAEJ16  BRANCH IF NO PAGE NUMBER BUMP\n         B     PAEJ13              REALLY NULL PAGE\n         SPACE\nPAEJ02   DS    0H\n        $IFOFF SWITCHS,FEMPTY,PAEJ03    BRANCH IF PAGE NOT EMPTY\n        $CALL  PAGETOP             YES, PRINT HEADERS FIRST\n        $CALL  RMNEXT              AND SET UP FOR ANY USER REMOTE\n         SPACE\nPAEJ03   DS    0H\n         LH    R1,BMMRG            BOTTOM MARGIN\n         AH    R1,FNSEP            PLUS FOOTNOTE MARGIN\n         CH    R1,RMTRIG           REMOTE BEFORE BOTTOM MARGIN .Q\n         BNL   PAEJ04              IF NOT, SKIP\n         LH    COUNT,PLCT          YES, SPACE DOWN TO IT\n         SH    COUNT,RMTRIG        ..\n        $CALL  SPACER              ..\n         SPACE\n         L     COUNT,PAGECNT       SAVE REAL PAGE EJECT COUNT\n         LH    R1,RMTRIG           REMOTE TO IMBED\n        $CALL  RMIMBED             IMBED A REMOTE SEQUENCE\n         SPACE\n         C     COUNT,PAGECNT       DID A PAGE EJECT OCCUR .Q\n         BE    PAEJ00              IF NOT, TRY AGAIN\n         B     PAEJ17              YES, DON'T DO ANOTHER\n         SPACE\nPAEJ04   DS    0H\n         LH    COUNT,PLCT          NUMBER OF LINES LEFT ON THIS PAGE\n         SH    COUNT,BMMRG         EXCLUDING BOTTOM MARGIN\n         SH    COUNT,FNSEP         AND FOOTNOTE MARGIN\n        $ON    SWITCHS,OOSWS       DISABLE OUTPUT OVERLAY\n        $CALL  SPACER              SKIP TO BOTTOM OF PAGE\n         SPACE\n        $CALL  FNPRT               PRINT ANY FOOTNOTES NOW\n         SPACE\n         LA    R1,SYSBMRM          BOTTOM MARGIN REMOTE\n        $CALL  RMCOND              TRY IT\n         SPACE\n         L     X1,ADEVHEAD         ASSUME EVEN FOOTING\n        $CALL  ODDEVN              EVEN OR ODD PAGE .Q\n         BC    BPOS,PAEJ06         BRANCH IF EVEN\n         L     X1,ADODHEAD         ODD PAGE FOOTING\nPAEJ06   DS    0H\n         L     R1,DEFHSFS+TAB3DEF  TT/BT OVERLAP COUNT\n         BCTR  R1,0                LESS ONE\n         LA    R0,L'EVNHEAD        LENGTH FOR ONE POINTER\n         MR    R0,R0               OFFSET TO LAST POINTER\n         AR    X1,R1               POINT TO LAST ENTRY\n         CLC   FSCNT,H1            ONE ENTRY ONLY .Q\n         BL    PAEJ07              BRANCH IF ZERO\n         BNE   PAEJ08              BRANCH IF NOT ONE\n         OC    0(L'EVNHEAD,X1),0(X1)    ANY FOOTING PRESENT .Q\n         BNZ   PAEJ08              BRANCH IF NOT NULL\nPAEJ07   DS    0H\n         LH    COUNT,BMMRG         GET TOTAL BOTTOM MARGIN\n         B     PAEJ11              DO SPACING ALL AT ONCE\n         SPACE\nPAEJ08   DS    0H\n         LH    COUNT,FTMRG         SKIP FOOTING MARGIN\n        $ON    SWITCHS,OOSWS       DISABLE OUTPUT OVERLAY\n        $CALL  SPACER              SKIP DOWN TO FOOTING START\n         LH    COUNT,FSCNT         GET FOOTING SPACE\nPAEJ09   DS    0H\n         S     COUNT,F1            LESS ONE\n         BM    PAEJ10              BRANCH IF DONE\n        $CALL  HEADPRT             PRINT ONE FOOTING LINE\n         LA    R0,L'EVNHEAD        LENGTH ONE FOOTING ENTRY\n         SR    X1,R0               BACK UP TABLE PTR\n         B     PAEJ09              DO REMAINDER\n         SPACE\nPAEJ10   DS    0H\n         LH    COUNT,BMMRG         GET BOTTOM MARGIN\n         SH    COUNT,FTMRG         LESS FOOTING MARGIN\n         SH    COUNT,FSCNT         LESS FOOTING SPACING\nPAEJ11   DS    0H\n         LTR   COUNT,COUNT         GO SKIP TO BOTTOM OF PAGE\n         BNP   PAEJ12              BRANCH IF NOTHING TO DO\n        $ON    SWITCHS,OOSWS       DISABLE OUTPUT OVERLAY\n        $CALL  SPACER              SKIP DOWN TO PAGE BOTTOM\nPAEJ12   DS    0H\n         LA    R1,SYSBOTRM         BOTTOM OF PAGE REMOTE\n        $CALL  RMCOND              TRY IT\n         SPACE\nPAEJ13   DS    0H\n        $IFON  SWITCHS,PINCRNO,PAEJ16   SKIP IF NO PAGE INCREMENT\n         L     COUNT,PACNTD        DECIMAL PART OF PAGE NUMBER\n         C     COUNT,PACNTDI       ARE WE USING IT .Q\n         BE    PAEJ15              BRANCH IF NOT\n         LTR   COUNT,COUNT         ARE WE ALREADY USING IT .Q\n         BNM   PAEJ14              BRANCH IF YES\n         TM    PACNTI+L'PACNTI-1,X'01'  ODD INTEGER PAGE .Q\n         BO    PAEJ15              YES, DON'T INCREMENT YET\n         SR    COUNT,COUNT         START AT THE BEGINNING\nPAEJ14   DS    0H\n         LA    COUNT,1(,COUNT)     BUMP DECIMAL PART\n         ST    COUNT,PACNTD        UPDATE DECIMAL COUNT\n         B     PAEJ16              AND CONTINUE\nPAEJ15   DS    0H\n         L     COUNT,PACNTI        INTEGER PART OF PAGE NUMBER\n         LA    COUNT,1(,COUNT)     PLUS ONE\n         ST    COUNT,PACNTI        AND UPDATE WITH NEW\n         SPACE\nPAEJ16   DS    0H\n         MVC   PLCT,PLZ            SET PAGE COUNT FOR NEXT PAGE\n         MVC   CDPLCT,PLZ          SET COLUMN COUNT FOR NEXT PAGE\n        $ON    SWITCHS,FEMPTY      NOTE THAT NEXT PAGE IS EMPTY\n        $OFF   SWITCHS,(AFIRST,FFIRST)  IT IS NO LONGER THE FIRST PAGE\n        $IFON  SWITCHS,NPSWS,PAEJ17     BRANCH IF NOPRINT MODE\n         CLC   PASSNO,DEFPASOF+TAB3DEF  IS THIS THE LAST PASS .Q\n         BNE   PAEJ17              BRANCH IF NOT\n         L     COUNT,PACNTI        GET NEXT INTEGER PAGE NUMBER\n         C     COUNT,DEFPAGL+TAB3DEF    MORE THAN LAST TO DO .Q\n         BNH   PAEJ17              BRANCH IF NOT\n         LA    R1,WRETPA           FINAL PAGE IS COMPLETE\n        $CALL  QUITS               CALL TERMINATION ROUTINE\n         SPACE\nPAEJ17   DS    0H\n         MVC   HYSUPWRK,HYSUPCNT   RESET NUMBERED HYPHENATION SUPPRESS\n         XC    SKSP,SKSP           CLEAR ANY OUTSTANDING COND SK/SP\n        $CALL  RMNEXT              SETUP FOR NEXT REMOTE\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              AND RETURN TO CALLER\n         SPACE\nSYSBMRM  DC    CL8'SYSBM'          ABOVE BOTTOM MARGIN REMOTE\nSYSBOTRM DC    CL8'SYSBOT'         BOTTOM OF PAGE REMOTE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PAGEREA": {"ttr": 9220, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTION 'PAGEREAL' -- PHYSICAL PAGE EJECT    *\n*                                                                     *\n***********************************************************************\n         SPACE\nPAGEREAL $ENTER ,\n         CLI   ICOLFLG,ICOLMC      MULTI-COLUMN OUTPUT .Q\n         BE    PAGR01              BRANCH IF YES\n        $CALL  PAGE                NORMAL PAGE EJECT\n         B     PAGR04              GO TO EXIT\n         SPACE\nPAGR01   DS    0H\n         L     COUNT,PAGECNT       REAL PAGE EJECT COUNT\nPAGR02   DS    0H\n        $IFON  SWITCHS,FEMPTY,PAGR03    BRANCH IF PAGE IS EMPTY\n        $CALL  COLNEW              NEXT COLUMN\n         C     COUNT,PAGECNT       PAGE EJECT ALSO DONE .Q\n         BNE   PAGR04              BRANCH IF YES\nPAGR03   DS    0H\n        $CALL  PAGETOP             FLUSH OUT ANY KEEPS\n         C     COUNT,PAGECNT       PAGE EJECT ALSO DONE .Q\n         BE    PAGR02              NO, TRY AGAIN\n         SPACE\nPAGR04   DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PAGETOP": {"ttr": 9222, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x01\\r\\x01\\r\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 269, "newlines": 269, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTION 'PAGETOP' ---                        *\n*                                      CHECK FOR STOP AT PAGE BOTTOM  *\n*                                      FORMAT HEADINGS ON NEXT PAGE   *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER:   $CALL  PAGETOP\n*\n*        ON EXIT:   NORMAL RETURN IF TO CONTINUE\n*                   '$CALL QUITS'  IF TO TERMINATE\n         SPACE\nPAGETOP $ENTER ,\nPTOP01   DS    0H\n        $OFF   SWITCHS,FEMPTY      PAGE IS NO LONGER EMPTY\n         CLI   ICOLFLG,ICOLMC      IS MULTI-COLUMN MODE ON .Q\n         BNE   PTOP02              BRANCH IF NOT\n         CLC   CDCURR,F1           IN FIRST COLUMN .Q\n         BNE   PAOK04              BRANCH AHEAD IF NOT\n         MVI   ICOLFLG,ICOLTC      TITLE COLUMN IN PROGRESS\n         MVC   CLLZ,LLZ            RESTORE FULL LINE LENGTH\nPTOP02   DS    0H\n        $IFON  SWITCHS,NPSWS,NOSTOP1    NOPRINT OVERRIDES STOP\n         CLC   PASSNO,DEFPASOF+TAB3DEF  IS THIS THE LAST PASS .Q\n         BNE   NOSTOP1             NO, THIS OVERRIDES STOP\n        $IFON  TTYPE,TFILE,NOSTOP1      'FILE' OUTPUT OVERRIDES\n        $IFON  SWITCHS,NOSWS,NOSTOP1    NOWAIT OVERRIDES\n        $IFOFF TTYPE,TONLINE,NOSTOP1    BRANCH IF OUTPUT NOT ONLINE\n        $IFON  SWITCHS,FFIRST,PTOP03    BRANCH IF FIRST PAGE\n        $IFOFF SWITCHS,HITSWS,PTOP03    BRANCH IF NO LOAD MESSAGE YET\n        $IFOFF SWITCHS,STSWS,NOSTOP1    TEST FOR 'STOP'\n         B     PTOP04              PROMPT FOR CARRIAGE RETURN\n         SPACE\nPTOP03   DS    0H\n         LA    R0,LDMES            MESSAGE TO DISPLAY\n        $CALL  PUTCONS             DISPLAY THE RESULT\n         B     PTOP04              PROMPT FOR CARRIAGE RETURN\nLDMES    DC    AL2(LDMESEND-*,0)\n         DC    C'Load paper; hit return:'    'WAIT' MESSAGE\nLDMESEND EQU   *\n         SPACE\nPTOP04   DS    0H\n         MVC   CONSMAX,F1          READ ONE LINE FROM CONSOLE\n         MVC   CONSGOTO,BLANKS     CLEAR GOTO TARGET\n         XC    CONSFLAG,CONSFLAG   CLEAR CONSOLE FLAGS\n        $IFOFF SWITCHS,HITSWS,PTOP05    BRANCH IF NOT FIRST TIME\n        $ON    CONSFLAG,IO$EJCT    MOVE PAPER UP FOR EASY REMOVAL\nPTOP05   DS    0H\n        $ON    SWITCHS,HITSWS      NO LONGER FIRST TRY\n        $ON    CONSFLAG,IO$IM      IMBED THIS DUMMY TERMINAL READ\n        $ON    CONSFLAG,IO$UEOF    RETURN AFTER ANY EOF\n         LA    R1,CONSBLOK         TO 'IMBED'  THE CONSOLE FILE\n        $CALL  RDFILE              CALL INPUT COORDINATOR\n         SPACE\n        $CALL  TERMREAD            READ ONE LINE\n         CLI   1(R1),X'00'         NULL READ .Q\n         BE    NOSTOP1             YES, CONTINUE\n         L     X1,ARGSTART         RETAIN ANY SCANNING START\n         L     X2,ARGSTOP          RETAIN ANY SCANNING STOP\n         LA    R0,4(,R1)           START OF INPUT\n         ST    R0,ARGSTART         SET IT FOR SCAN\n         AH    R0,0(,R1)           PLUS RECORD LENGTH\n         ST    R0,ARGSTOP          FOR END OF SCAN\n        $CALL  GETYESNO            WHAT DID USER ENTER .Q\n         ST    X1,ARGSTART         RESTORE ANY SCANNING START\n         ST    X2,ARGSTOP          RESTORE ANY SCANNING STOP\n         BC    15-BNEG,NOSTOP0     CONTINUE ON IF NOT NEGATIVE\n         LA    R1,WRETQQ           TERMINATE IMMEDIATELY\n        $CALL  QUITS               CALL TERMINATION ROUTINE\n         SPACE\nNOSTOP0  DS    0H\n        $CALL  TERMREAD            FIND OUR OWN EOF\n         CLI   1(R1),X'00'         IS RECORD NULL .Q\n         BNE   NOSTOP0             NO, TRY AGAIN\n         SPACE\nNOSTOP1  DS    0H\n         LA    R1,SYSTOPRM         TOP OF PAGE REMOTE NAME\n        $CALL  RMCOND              TRY IT\n         SPACE\n         L     X1,ADEVHEAD         ASSUME EVEN PAGE\n        $CALL  ODDEVN              EVEN OR ODD PAGE .Q\n         BC    BPOS,NOSTOP2        BRANCH IF EVEN\n         L     X1,ADODHEAD         POINT TO ODD HEAD\nNOSTOP2  DS    0H\n         CLC   HSCNT,H1            ONE HEADING ENTRY .Q\n         BL    NOSTOP3             BRANCH IF ZERO\n         BNE   NOSTOP4             BRANCH IF NOT ONE\n         OC    0(L'EVNHEAD,X1),0(X1)    ANY HEADING INFO .Q\n         BNZ   NOSTOP4             BRANCH IF NOT NULL\nNOSTOP3  DS    0H\n         CLC   DEFPAGS+TAB3DEF,F1  ANY PAGE START OPTIONS .Q\n         BH    NOSTOP4             IF YES, DO IT IN STEPS\n         LH    COUNT,TOPMRG        GET TOP MARGIN\n         B     PAOK03              AND BRANCH TO SPACE ALL AT ONCE\n         SPACE\nNOSTOP4  DS    0H\n         LH    COUNT,TOPMRG        SKIP MOST OF TOP MARGIN\n         SH    COUNT,HDMRG         EXLUDING HEADING MARGIN\n         SH    COUNT,HSCNT         AND HEADING SPACING\n         SPACE\n        $ON    SWITCHS,OOSWS       DISABLE OUTPUT OVERLAY\n        $CALL  SPACER              ..\n         SPACE\n        $IFOFF SWITCHS,NPSWS,PAOK  BRANCH IF NOT NOPRINT MODE\n         L     COUNT,PACNTI        GET INTEGER PAGE NUMBER\n         C     COUNT,DEFPAGS+TAB3DEF  THIS THE PAGE TO BE PRINTED .Q\n         BNE   PAOK                IF NOT, SKIP\n        $OFF   SWITCHS,NPSWS       YES, START PRINTING\n        $ON    SWITCHS,FFIRST      FOR HEADING CONTROL\n         MVC   PLCT,PLZ            WE HAVEN'T PRINTED ANYTHING, REALLY\n         MVC   CDPLCT,PLCT         SET COLUMN COUNT FOR REST OF PAGE\n         B     PTOP02              BEGIN WITH STOP AND SPACE\n         SPACE\nPAOK     DS    0H\n         LH    COUNT,HSCNT         GET HEADING SPACE\nPAOK01   DS    0H\n         S     COUNT,F1            LESS ONE\n         BM    PAOK02              BRANCH IF DONE\n        $CALL  HEADPRT             PRINT ONE HEADING LINE\n         LA    X1,L'EVNHEAD(,X1)   PLUS LENGTH ONE HEADING ENTRY\n         B     PAOK01              DO REMAINDER\n         SPACE\nPAOK02   DS    0H\n         LH    COUNT,HDMRG         SPACE HEADING MARGIN\nPAOK03   DS    0H\n        $ON    SWITCHS,OOSWS       DISABLE OUTPUT OVERLAY\n        $CALL  SPACER              SPACE TO TOP OF TEXT AREA\n         SPACE\n         LA    R1,SYSTMRM          TOP MARGIN REMOTE NAME\n        $CALL  RMCOND              TRY IT\n         SPACE\n         LA    X1,HNEAREA          EVEN HEADNOTE AREA\n        $CALL  ODDEVN              CHECK EVEN OR ODD PAGE\n         BC    BPOS,PAOK03A        BRANCH IF EVEN\n         LA    X1,HNOAREA          ODD HEADNOTE AREA\nPAOK03A  DS    0H\n         USING CPFKFN,X1           DESCRIPTOR AREA\n         OC    CPFKFNC,CPFKFNC     ANY EVEN OR ODD DATA .Q\n         BNZ   PAOK03B             BRANCH IF YES\n         LA    X1,HNAREA           HEADNOTE AREA\nPAOK03B  DS    0H\n         LA    R1,CPFKFN           POINT TO DESCRIPTOR AREA\n        $CALL  HNPRT               PRINT HEADNOTES, IF ANY\n         DROP  X1\n         SPACE\n         XC    OUTSEQ,OUTSEQ       CLEAR LEGAL LINE SEQUENCE\n         MVC   CDPLCT,PLCT         SET COLUMN COUNT FOR REST OF PAGE\n         SPACE\n         CLI   ICOLFLG,ICOLTC      TITLE COLUMN IN PROGRESS .Q\n         BNE   PAOK04              BRANCH IF NOT\n         MVI   ICOLFLG,ICOLMC      MULTIPLE COLUMNS AGAIN\n         L     COUNT,CLLZSAVE      GET COLUMN LENGTH\n         LTR   COUNT,COUNT         HAS IT BEEN DEFINED .Q\n         BZ    PAOK04              BRANCH IF NOT\n         ST    COUNT,CLLZ          RESTORE COLUMN LENGTH\n         SPACE\nPAOK04   DS    0H\n         MVC   PLCT,CDPLCT         SET COLUMNS LEFT ON THIS PAGE\n         L     R1,FKQCNT           FLOATING KEEP COUNT\n         LTR   R1,R1               ANYTHING THERE .Q\n         BNP   PAOK06              BRANCH IF NOT\n         CLC   PLCT,RMTRIG         REMOTE SET FOR TOP OF PAGE .Q\n         BNE   PAOK05              BRANCH IF NOT\n         LH    R1,RMTRIG           REMOTE NUMBER TO IMBED\n        $CALL  RMIMBED             AND TRIGGER SAME FIRST\n         SR    COUNT,COUNT         NO EXTRA CHECK\n         BAL   RETURN,PAFULL       CHECK IF PAGE IS FULL\n         BC    BNEG,PTOP01         BRANCH IF IT IS\nPAOK05   DS    0H\n         LH    X1,FNSEP            FOOTNOTE MARGIN\n         XC    FNSEP,FNSEP         CLEAR FOOTNOTE MARGIN FOR CALL\n         LA    R1,FKAREA           .FK CONTROL DESCRIPTOR\n        $CALL  CPFKPRT             DUMP SAVED DATA\n         BAL   RETURN,PAFNSEP      RESTORE FOOTNOTE MARGIN\n         SPACE\n         L     COUNT,CPQCNT        CONDITIONAL PAGE COUNT\n         BAL   RETURN,PAFULL       CHECK IF PAGE IS FULL\n         BC    BNEG,PTOP01         BRANCH IF IT IS\n         SPACE\nPAOK06   DS    0H\n         L     R1,CPQCNT           CONDITIONAL KEEP COUNT\n         LTR   R1,R1               ANYTHING THERE .Q\n         BNP   PAOK08              BRANCH IF NOT\n         CLC   PLCT,RMTRIG         REMOTE SET FOR TOP OF PAGE .Q\n         BNE   PAOK07              BRANCH IF NOT\n         LH    R1,RMTRIG           REMOTE NUMBER TO IMBED\n        $CALL  RMIMBED             AND TRIGGER SAME FIRST\n         SR    COUNT,COUNT         NO EXTRA CHECK\n         BAL   RETURN,PAFULL       CHECK IF PAGE IS FULL\n         BC    BNEG,PTOP01         BRANCH IF IT IS\nPAOK07   DS    0H\n         LH    X1,FNSEP            RETAIN FOOTNOTE MARGIN\n         XC    FNSEP,FNSEP         CLEAR FOOTNOTE MARGIN FOR CALL\n         LA    R1,CPAREA           .CP CONTROL DESCRIPTOR\n        $CALL  CPFKPRT             DUMP SAVED DATA\n         BAL   RETURN,PAFNSEP      RESTORE FOOTNOTE MARGIN\n         SR    COUNT,COUNT         NO EXTRA CHECK\n         BAL   RETURN,PAFULL       CHECK IF PAGE IS FULL\n         BC    BNEG,PTOP01         BRANCH IF IT IS\n         SPACE\nPAOK08   DS    0H\n         L     R1,CCQCNT           CONDITIONAL COLUMN KEEP COUNT\n         LTR   R1,R1               ANYTHING THERE .Q\n         BNP   PAOK10              BRANCH IF NOT\n         CLC   PLCT,RMTRIG         REMOTE SET FOR TOP OF COLUMN .Q\n         BNE   PAOK09              BRANCH IF NOT\n         LH    R1,RMTRIG           REMOTE NUMBER TO IMBED\n        $CALL  RMIMBED             AND TRIGGER SAME FIRST\n         SR    COUNT,COUNT         NO EXTRA CHECK\n         BAL   RETURN,PAFULL       CHECK IF PAGE IS FULL\n         BC    BNEG,PTOP01         BRANCH IF IT IS\nPAOK09   DS    0H\n         LH    X1,FNSEP            RETAIN FOOTNOTE MARGIN\n         XC    FNSEP,FNSEP         CLEAR FOOTNOTE MARGIN FOR CALL\n         LA    R1,CCAREA           .CC CONTROL DESCRIPTOR\n        $CALL  CPFKPRT             DUMP SAVED DATA\n         BAL   RETURN,PAFNSEP      RESTORE FOOTNOTE MARGIN\n         SR    COUNT,COUNT         NO EXTRA CHECK\n         BAL   RETURN,PAFULL       CHECK IF PAGE IS FULL\n         BC    BNEG,PTOP01         BRANCH IF IT IS\n         SPACE\nPAOK10   DS    0H\n        $CALL  RMNEXT              AND SET UP FOR THE NEXT, IF ANY\n        $RESTOR ,                  RESTORE CALLER'S REGS\n         BR    RETURN              RETURN\n         SPACE\nSYSTOPRM DC    CL8'SYSTOP'         TOP OF PAGE REMOTE\nSYSTMRM  DC    CL8'SYSTM'          TOP MARGIN REMOTE\n         SPACE 2\nPAFULL   DS    0H\n        $SAVE  ,                   SAVE CALLER'S REGISTERS\n        $IFON  SWITCHS,FEMPTY,PAFULL02  BRANCH IF PAGE NOW EMPTY\n         LH    R1,PLCT             LINES LEFT ON THIS PAGE\n         BCTR  R1,0                LESS ONE\n         LH    X1,BMMRG            BOTTOM MARGIN\n         AH    X1,FNSEP            PLUS FOOTNOTE MARGIN\n         CR    R1,X1               COMPARE WITH BOTTOM MARGIN\n         BL    PAFULL01            BRANCH IT NO ROOM LEFT\n         SR    R1,COUNT            LESS CALLER'S QUALIFIER\n         CR    R1,X1               COMPARE AGAIN\n         BNL   PAFULL03            BRANCH IF ENOUGH SPACE\nPAFULL01 DS    0H\n        $CALL  PAGE                TERMINATE THIS PAGE\nPAFULL02 DS    0H\n        $CC    NEG                 SET TO START NEXT PAGE\n         B     PAFULL04            GO TO RETURN\nPAFULL03 DS    0H\n        $CC    POS                 NO NEED TO START NEXT PAGE\nPAFULL04 DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              AND RETURN TO CALLER\n         SPACE 2\nPAFNSEP  DS    0H\n        $SAVE  ,\n         LTR   X1,X1               ANY FOOTNOTES OUTSTANDING .Q\n         BZ    PAFNSE02            BRANCH IF NONE\n         LH    R1,PLCT             LINES LEFT ON PAGE\n         SH    R1,BMMRG            LESS BOTTOM MARGIN\n         CH    R1,FTCNT            NEED FOOTNOTE SEPARATOR +1\n         BNH   PAFNSE02            IF NOT AVAILABLE, IGNORE\n         CR    X1,R1               NEED MORE THAN WE'VE GOT .Q\n         BNH   PAFNSE01            BRANCH IF NOT\n         LR    X1,R1               TAKE WHAT IS AVAILABLE\nPAFNSE01 DS    0H\n         STH   X1,FNSEP            SET FOOTNOTE MARGIN\nPAFNSE02 DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#PD": {"ttr": 9227, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .PD (ODD PAGE FORCE) --- CONTROL                       *\n*              .OP (ODD PAGE EJECT) --- CONTROL                       *\n*                                                                     *\n***********************************************************************\n         SPACE\nPD      $ENTER ,\n         CLI   ICORFLG,ICORNONE    SAVING FORMATTED TEXT INCORE .Q\n         BNE   PDE012              ERROR IF YES\n        $IFOFF SWITCHS,PINCRNO,PD01     BRANCH IF PAGES NOT INCREASING\n        $CALL  PA                  ELSE JUST SIMPLE .PA\n         B     PD03                AND GO TO RETURN\n         SPACE\nPD01     DS    0H\n        $CALL  PRINTNB             ISSUE A BREAK\n        $CALL  ODDEVN              WHAT KIND OF PAGE ARE WE ON .Q\n         BC    BPOS,PD02           IF EVEN, ONE EJECT ONLY\n        $CALL  PAGEREAL            ODD. SKIP TO EVEN PAGE\nPD02     DS    0H\n        $CALL  PAGEREAL            SKIP TO ODD PAGE\nPD03     DS    0H\n        $EXIT  RC=0                GET NEXT LINE\n         SPACE\nPDE012   DS    0H\n         MVI   EFLAG012,ERRSET     ILLEGAL PLACEMENT OF CONTROL WORD\n         B     PD03                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PE": {"ttr": 9229, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00M\\x00M\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 77, "newlines": 77, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .PE (PERFORM) --- CONTROL                              *\n*                                                                     *\n***********************************************************************\n         SPACE\nPE      $ENTER ,\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BOMIT,PE01          BRANCH IF OMITTED\n         BC    BPOS,PE02           BRANCH IF AFFIRMATIVE\n         BC    BNEG,PE03           BRANCH IF NEGATIVE\n         CLI   YNRESULT,YNDEL      IS IT DELETE .Q\n         BE    PE04                BRANCH IF YES\n         ST    COUNT,ARGSTART      RESET START OF SCAN\n        $CALL  GETNUM              ARGUMENT BETTER BE NUMERIC\n         BC    BDNO,PEE005         ERROR IF INVALID\n         BC    BNEG,PEE014         ERROR IF NEGATIVE\n         B     PE05                ENTER THE VALUE\n         SPACE\nPE01     DS    0H\n         LA    COUNT,1             ONE TIME BY DEFAULT\n         B     PE05                ENTER THE VALUE\nPE02     DS    0H\n         LH    COUNT,H32767        LARGE POSITIVE VALUE\n         B     PE05                ENTER THE VALUE\nPE03     DS    0H\n         SR    COUNT,COUNT         ZERO TO PURGE THIS LINE\n         B     PE05                ENTER THE VALUE\nPE04     DS    0H\n         LA    R1,PEANCH           POINT TO PERFORM STACK ANCHOR\n        $CALL  OVCLR               DELETE ANY AND ALL ENTRIES\n         B     PE06                TERMINATE THIS LINE\n         SPACE\nPE05     DS    0H\n         SR    R0,R0               ZERO WORK REGISTER\n         LTR   COUNT,COUNT         ZERO PERFORM ARG .Q\n         BE    PE06                YES, TERMINATE THIS LINE\n         SPACE\n        $CALL  READ                GET NEXT INPUT LINE FOR OPERAND\n         LR    X1,R1               POINT TO INPUT LINE\n         LH    R1,0(,X1)           LENGTH OF LINE\n         LA    R1,OOQLEN(,R1)      PLUS OVERHEAD\n        $CALL  GETCELL             GET SOME SPACE\n         BC    BNEG,PEE024         ERROR IF NO SPACE\n         USING OODSECT,TEMP        AREA LOOKS LIKE THIS\n         XC    OODSECT(OOQLEN),OODSECT  CLEAR THE PREFIX\n         ST    COUNT,OOQCNT        SET CALL COUNT\n         MVC   OOQFCHN,PEANCH      CHAIN TO NEXT ELEMENT\n         ST    TEMP,PEANCH         ANCHOR POINTS TO NEW FIRST\n         LH    R1,0(,X1)           LENGTH OF DATA\n         STH   R1,OOQRDW           SET LENGTH OF DATA\n         BCTR  R1,0                LENGTH-1\n         EX    R1,PEMVC            ENTER DATA\n         B     PE06                AND CONTINUE\n         SPACE\nPEMVC    MVC   OOQDATA(*-*),4(X1)  ENTER PERFORM DATA LINE\n         DROP  TEMP\n         SPACE\nPE06     DS    0H\n         L     R1,HIDBANCH         REST OF CURRENT BUFFER\n         LTR   R1,R1               ANY PRESENT .Q\n         BZ    PE07                BRANCH IF NONE\n         USING HIDB,R1             TELL THE ASSEMBLER\n         STH   R0,HIDBLEN          CLEAR DATA LEFT IN LINE\n         DROP  R1\nPE07     DS    0H\n        $EXIT  RC=0                CONTINUE WITH NEXT LINE\n         SPACE\nPEE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     PE07                GO TO RETURN\nPEE014   DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     PE07                GO TO RETURN\nPEE024   DS    0H\n         MVI   EFLAG024,ERRSET     NO STORAGE FOR PERFORM LINE\n         B     PE07                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PI": {"ttr": 9232, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00-\\x00-\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .PI (PARAGRAPH INDENT) --- CONTROL                     *\n*                                                                     *\n***********************************************************************\n         SPACE\nPI      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BNEG+BOMIT,PI02     BRANCH IF NEGATIVE OR OMITTED\n         BC    BPOS,PI01           BRANCH IF AFFIRMATIVE\n         ST    COUNT,ARGSTART      RESCAN FOR NUMERIC\n        $CALL  GETNUM              GET OPERAND\n         BC    BDNO,PIE005         ERROR IF INVALID\n         BC    BOMIT,PI02          BRANCH IF OMITTED TO DEFAULT\n         CLI   NUMSIGN,C' '        WAS OPERAND UNSIGNED .Q\n         BE    PI03                BRANCH IF YES\n         AH    COUNT,PICNT         MAKE RELATIVE CHANGE\n         B     PI03                GO CHECK AND ENTER\n         SPACE\nPI01     DS    0H\n         LA    COUNT,3             SAME AS .PP\n         B     PI03                AND GO ENTER\nPI02     DS    0H\n         SR    COUNT,COUNT         DEFAULT PARAGRAPH INDENT\nPI03     DS    0H\n         LTR   COUNT,COUNT         TEST NOT TOO SMALL\n         BM    PIE014              ERROR IF TOO SMALL\n         C     COUNT,LLZ           TEST NOT TOO BIG\n         BNL   PIE013              ERROR IF TOO BIG\n         STH   COUNT,PICNT         SET PARAGRAPH INDENT\n         B     PI04                GO TO RETURN\n         SPACE\nPI04     DS    0H\n        $EXIT  RC=0                RETURN TO CONTROLLER\n         SPACE\nPIE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     PI04                GO TO RETURN\nPIE013   DS    0H\n         MVI   EFLAG013,ERRSET     OPERAND TOO BIG\n         B     PI04                GO TO RETURN\nPIE014   DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     PI04                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PL": {"ttr": 9473, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00,\\x00,\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .PL (PAGE LENGTH) --- CONTROL                          *\n*                                                                     *\n***********************************************************************\n         SPACE\nPL      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n        $CALL  GETNUM              GET NUMBER\n         BC    BDNO,PL04           ERROR IF INVALID\n         BC    BOMIT,PL01          SET DEFAULT IF OMITTED\n         CLI   NUMSIGN,C' '        WAS ARGUMENT SIGNED .Q\n         BE    PL02                ABSOLUTE ARG IF NOT\n         AH    COUNT,PLZ           ALTER ORIGINAL PAGE LENGTH\n         B     PL02                GO CHECK AND ENTER\nPL01     DS    0H\n         L     COUNT,DEFPL+TAB3DEF  DEFAULT PAGE LENGTH VALUE\nPL02     DS    0H\n         LH    R0,BMMRG            CURRENT BOTTOM MARGIN VALUE\n         AH    R0,TOPMRG           PLUS CURRENT TOP MARGIN VALUE\n         CR    COUNT,R0            IS THIS BIGGER THAN SUM .Q\n         BNH   PL05                GOT TO BE BAD IF NOT\n         LH    X1,PLZ              ORIGINAL PAGE LENGTH MINUS\n         SH    X1,PLCT             LINES REMAINING = LINES ALREADY PRT\n         STH   COUNT,PLZ           SET PAGE LENGTH\n         SR    COUNT,X1            NEW PGLN - LNS PRT = LN REM NEW PG\n         BNH   PL03                NEW PAGE NEEDED. PRT LN GT NEW PG LN\n         STH   COUNT,PLCT          SAVE LN REM ON NEW PG LENGTH\n         B     PL06                NEW LENGTH NOT YET FULFILLED\nPL03     DS    0H\n         MVC   PLCT(2),PLZ         PUT NEW .PL INTO PLCT TO EJECT PAGE\n        $CALL  PAGEREAL            NEW PGLG COMPLETE, EJECT\n         B     PL06                GO TO RETURN\n         SPACE\nPL04     DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     PL06                GO TO RETURN\nPL05     DS    0H\n         MVI   EFLAG045,ERRSET     PAGE LENGTH TOO SMALL\n         B     PL06                GO TO RETURN\n         SPACE\nPL06     DS    0H\n        $CALL  RMNEXT              SET UP AGAIN FOR NEXT AUTO REMOTE\n        $EXIT  RC=0                RETURN TO MAIN CONTROLLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PN": {"ttr": 9475, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00]\\x00]\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 93, "newlines": 93, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .PN (PAGE NUMBER) --- CONTROL                          *\n*                                                                     *\n***********************************************************************\n         SPACE\nPN      $ENTER ,\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BOMIT+BPOS,PN01     BRANCH IF NULL OR AFFIRMATIVE\n         BC    BNEG,PN02           BRANCH IF NEGATIVE\n         CLI   YNRESULT,YNARA      IS ARGUMENT 'ARABIC' .Q\n         BE    PN03                BRANCH IF YES\n         CLI   YNRESULT,YNROM      IS ARGUMENT 'ROMAN' .Q\n         BE    PN04                BRANCH IF YES\n         CLI   YNRESULT,YNOFN      IS ARGUMENT DOUBLE NEGATIVE .Q\n         BE    PN05                BRANCH IF YES\n         CLI   YNRESULT,YNPREF     IS ARGUMENT 'PREFIX' .Q\n         BE    PN06                BRANCH IF YES\n         CLI   YNRESULT,YNSUFX     IS ARGUMENT 'SUFFIX' .Q\n         BE    PN07                BRANCH IF YES\n         CLI   YNRESULT,YNFRAC     IS ARGUMENT 'FRAC' .Q\n         BE    PN11                BRANCH IF YES\n         CLI   YNRESULT,YNNORM     IS ARGUMENT 'NORM' .Q\n         BE    PN12                BRANCH IF YES\n         B     PNE005              ALL HAS FAILED, ERROR\n         SPACE\nPN01     DS    0H\n        $OFF   SWITCHS,(PAGOFF,PINCRNO) ON NUMBERING AND INCREMENTING\n         B     PN99                AND CONTINUE\n         SPACE\nPN02     DS    0H\n        $OFF   SWITCHS,PINCRNO     TURN ON INCREMENTING\n        $ON    SWITCHS,PAGOFF      TURN OFF PAGE NUMBERING\n         B     PN99                AND CONTINUE\n         SPACE\nPN03     DS    0H\n        $CALL  AR                  ARABIC ROUTINE\n         B     PN99                AND CONTINUE\nPN04     DS    0H\n        $CALL  RO                  ROMAN ROUTINE\n         B     PN99                AND CONTINUE\n         SPACE\nPN05     DS    0H\n        $ON    SWITCHS,(PAGOFF,PINCRNO) OFF NUMBER AND INCREMENTING\n         B     PN99                AND CONTINUE\n         SPACE\nPN06     DS    0H\n         LA    X1,PNPREF           PAGE PREFIX STORED HERE\n         B     PN08                ENTER COMMON SCAN CODE\nPN07     DS    0H\n         LA    X1,PNSUFX           PAGE SUFFIX STORED HERE\nPN08     DS    0H\n         XC    0(L'PNPREF,X1),0(X1)     CLEAR PREFIX/SUFFIX\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION\n        $CALL  GETARG              GET NEXT ARGUMENT\n         BC    BOMIT,PN10          BRANCH IF OMITTED\n         LA    R0,L'PNPREF-2       MAX LENGTH-1 ALLOWED\n         CR    R0,TEMP             ARG TOO LONG .Q\n         BNL   PN09                OK IF NOT\n         MVI   EFLAG013,ERRSET     ARGUMENT TOO LONG\n         LR    TEMP,R0             USE MAXIMUM LENGTH\nPN09     DS    0H\n         EX    TEMP,PNPRFMVC       ENTER PAGE NUMBER PREFIX/SUFFIX\n         LA    TEMP,1(,TEMP)       ACTUAL LENGTH\n         STC   TEMP,0(,X1)         ENTER ACTUAL LENGTH\nPN10     DS    0H\n         B     PN99                AND CONTINUE\n         SPACE\nPN11     DS    0H\n         L     R0,PACNTDI          DEFAULT DECIMAL PART\n         S     R0,F1               LESS ONE\n         ST    R0,PACNTD           SET DECIMAL PART FOR LATER\n         B     PN99                AND CONTINUE\n         SPACE\nPN12     DS    0H\n         L     R0,PACNTD           GET DECIMAL PART\n         LTR   R0,R0               IS OR WAS IT USED .Q\n         BM    PN13                BRANCH IF NOT\n        $CALL  PRINTNB             PRINT REMAINDER OF CURRENT LINE\n         BC    BNEG,PN13           BRANCH IF NOBREAK PAGE NUMBER\n        $CALL  PAGEREAL            CAUSE PAGE EJECT\nPN13     DS    0H\n         L     R0,PACNTDI          DEFAULT DECIMAL PART\n         ST    R0,PACNTD           SET DECIMAL PART TO DEFAULT\n         B     PN99                AND CONTINUE\n         SPACE\nPNE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         SPACE\nPN99     DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\nPNPRFMVC MVC   1(*-*,X1),0(COUNT)  ENTER PAGE PREFIX/SUFFIX\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PNUMFMT": {"ttr": 9478, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x8f\\x00\\x8f\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 143, "newlines": 143, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        INTERNAL FUNCTION 'PNUMFMT' --- FORMAT CURRENT PAGE NUMBER   *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON EXIT  --  (COUNT)  LENGTH-1 OF RESULTING STRING\n*                 --  EBCDPAGE CONTAINS RESULTING STRING\n         SPACE\nPNUMFMT $ENTER ,\n         MVC   EBCDPAGE,BLANKS     CLEAR TARGET AREA\n         L     R1,PACNTI           GET CURRENT INTEGER PAGE NUMBER\n         CVD   R1,DECM             CONVERT TO DECIMAL\n        $IFOFF SWITCHS,FROMAN,HPDEC01   BRANCH IF ARABIC\n         LA    X3,DECPAGE          RUNNING RESULT ADDRESS\n         LA    X2,4*4-2            SHIFT AMOUNT AND INDEX\n         LA    X1,X'0F'            DIGIT SELECT MASK\n         SLL   X1,4*4              START LEFT TO RIGHT\n         LA    R0,4                BXH INCREMENT = -4\n         LNR   R0,R0               ..\n         SR    R1,R1               STOP AT -2\n         SR    COUNT,COUNT         HOLDS COUNT BYTE\n         B     HPROM02             SKIP SHIFT FIRST TIME\n         SPACE\nHPROM01  DS    0H\n         SRL   X1,4                SET TO SELECT NEXT DIGIT\nHPROM02  DS    0H\n         L     TEMP,DECM+4         GET PAGE NUMBER\n         NR    TEMP,X1             SELECT NEXT DIGIT\n         BZ    HPROM03             (IF ZERO, NO DIGIT)\n         SPACE\n         SRL   TEMP,0(X2)          SHIFT TO POSITION\n         IC    COUNT,ROMPATL(TEMP) GET BYTE COUNT\n         LA    TEMP,ROMPAT(TEMP)   PATTERN ADDRESS\n         MVC   0(4,X3),0(TEMP)     COPY IN PATTERN\n         LA    TEMP,ROMCHAR(X2)    CHARACTERS FOR THIS DECADE\n         TR    0(4,X3),0(TEMP)     NOW ROMAN NUMERALS\n         AR    X3,COUNT            UPDATE POINTER TO TARGET\n         SPACE\nHPROM03  DS    0H\n         BXH   X2,R0,HPROM01       DO 4 DIGIT POSITIONS\n         SPACE\n         LA    X2,DECPAGE          RESULT ADDRESS\n         SR    X3,X2               COMPUTE LENGTH OF RESULT\n         BP    HPROM04             BRANCH IF SOMETHING THERE\n         MVI   0(X2),C'*'          ENTER ASTERISK INSTEAD\n         B     HPROM05             AND GO TO DONE\nHPROM04  DS    0H\n         BCTR  X3,0                COMPUTE SS-TYPE COUNT\nHPROM05  DS    0H\n         LR    COUNT,X3            TRANSFER LENGTH-1\n         EX    COUNT,PNUMMVC       ENTER ROMAN RESULT\n        $IFOFF SWITCHS,FUPCASE,HPROM06  BRANCH IF NOT UPPER CASE\n         EX    COUNT,PNUMOC        CONVERT ROMAN TO UPPER CASE\nHPROM06  DS    0H\n         B     PNUMRET             DONE WITH CONVERSION, GO TO RETURN\n         SPACE\nPNUMMVC  MVC   EBCDPAGE(*-*),0(X2) SAVE FIRST PART OF NUMBER\nPNUMOC   OC    EBCDPAGE(*-*),BLANKS     CONVERT NUMBER TO UPPER CASE\n         SPACE\nHPDEC01  DS    0H\n         OI    DECM+7,X'0F'        FIX THE SIGN FIRST\n         UNPK  DECPAGE,DECM        UNPACK TO CHARACTERS\n         LA    COUNT,L'DECPAGE-1   LOCATE FIRST CHARACTER\n         LA    X2,DECPAGE          ..\nHPDEC02  DS    0H\n         TM    0(X2),X'0F'         LOOK FOR NON-ZERO DIGIT\n         BNZ   HPDEC03             BRANCH IF FOUND\n         LA    X2,1(,X2)           ..\n         BCT   COUNT,HPDEC02       ..\nHPDEC03  DS    0H\n         EX    COUNT,PNUMMVC       ENTER INTEGER RESULT\n         SPACE\n         L     R1,PACNTD           DECIMAL PART OF PAGE NUMBER\n         LTR   R1,R1               ANYTHING THERE .Q\n         BNP   PNUMRET             NO, GO TO RETURN\n         SPACE\n         LA    COUNT,1(,COUNT)     BUMP LENGTH-1 BY ONE\n         LA    R0,C'.'             DECIMAL POINT BETWEEN\n         STC   R0,EBCDPAGE(COUNT)  ENTER IT\n         SPACE\n         CVD   R1,DECM             CONVERT DECIMAL PART\n         OI    DECM+7,X'0F'        FIX THE SIGN FIRST\n         UNPK  DECPAGE,DECM        UNPACK TO CHARACTER\n         LA    R1,L'DECPAGE-1      LENGTH OF RESULT TO CHECK\n         LA    X2,DECPAGE          WHERE IT LIES\nHPDEC04  DS    0H\n         TM    0(X2),X'0F'         LOOK FOR NON-ZERO DIGIT\n         BNZ   HPDEC05             BRANCH IF FOUND\n         LA    X2,1(,X2)           NEXT CHARACTER\n         BCT   R1,HPDEC04          CONTINUE TO LOOK\nHPDEC05  DS    0H\n         LA    TEMP,EBCDPAGE+1(COUNT)   NEXT PART GOES HERE\n         EX    R1,PNUMDECA         ADD DECIMAL PART\n         LA    COUNT,1(COUNT,R1)   NEW TOTAL LENGTH-1\n         SPACE\nPNUMRET  DS    0H\n         SR    R1,R1               CLEAR WORK REGISTER\n         IC    R1,PNPREF           LENGTH OF PAGE NUMBER PREFIX\n         S     R1,F1               LENGTH-1 OF PAGE PREFIX\n         BM    PNPRSF02            BRANCH IF NO PREFIX\n         LA    TEMP,1(,COUNT)      LENGTH OF CURRENT\n         LA    X2,EBCDPAGE(R1)     START OF TARGET\nPNPRSF01 DS    0H\n         IC    R0,EBCDPAGE-1(TEMP) END CHARACTER\n         STC   R0,0(TEMP,X2)       MOVE RESULT ABOUT\n         BCT   TEMP,PNPRSF01       DO THEM ALL\n         LA    COUNT,1(R1,COUNT)   NEW LENGTH-1\n         LA    X2,PNPREF+1         PREFIX IS HERE\n         EX    R1,PNUMMVC          ENTER PAGE NUMBER PREFIX\nPNPRSF02 DS    0H\n         SR    R1,R1               CLEAR WORK REGISTER\n         IC    R1,PNSUFX           LENGTH OF PAGE SUFFIX\n         S     R1,F1               LENGTH-1 OF PAGE SUFFIX\n         BM    PNPRSF03            BRANCH IF NO SUFFIX\n         LA    TEMP,EBCDPAGE+1(COUNT)   TARGET FOR SUFFIX\n         LA    COUNT,1(R1,COUNT)   NEW LENGTH-1\n         LA    X2,PNSUFX+1         SUFFIX IS HERE\n         EX    R1,PNUMDECA         ENTER PAGE NUMBER SUFFIX\n         SPACE\nPNPRSF03 DS    0H\n        $RESTOR KEEP=(COUNT)       RESTORE CALLER'S REGISTERS\n         BR    RETURN              AND RETURN TO CALLER\n         SPACE\nPNUMDECA MVC   0(*-*,TEMP),0(X2)   ADD DECIMAL PART TO END\n         SPACE\nROMPAT   EQU   *-4                 ORIGIN OR ROMAN NUMERAL PATTERNS\nROMPATL  EQU   *-1                 ORIGIN OF LENGTH TABLE\n         DC    X'04000001'              I    X    C    M\n         DC    X'04040002'              II   XX   CC   MM\n         DC    X'04040403'              III  XXX  CCC  MMM\n         DC    X'04030002'              IV   XL   CD   M?\n         DC    X'03000001'              V    L    D    ?\n         DC    X'03040002'              VI   LX   DC   ?M\n         DC    X'03040403'              VII  LXX  DCC  ?MM\n         DC    X'03040404'              VIII LXXX DCCC ?MMM\n         DC    X'04020002'              IX   XC   CM   *M\n         SPACE\nROMCHAR  EQU   *-4                 ORIGIN OF DECADE CHARACTERS\n         DC    XL4'A7A58900'            (XVI)\n         DC    XL4'8393A700'            (CLX)\n         DC    XL4'94848300'            (MDC)\n         DC    XL4'5C6F9400'            (*?M)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PP": {"ttr": 9482, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00)\\x00)\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .PP (PARAGRAPH START) --- CONTROL                      *\n*                                                                     *\n***********************************************************************\n         SPACE\nPP      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n        $CALL  USARG               ISOLATE 'LINE' ARGUMENT\n         BC    BOMIT,PP01          BRANCH IF NONE\n         LH    TEMP,BUFF2LGZ       LENGTH OF 'LINE' OPERAND\n         BCTR  TEMP,0              LENGTH-1\n         LA    R1,BUFF2            POINT TO 'LINE'\n        $CALL  HIDBADD             ADD LINE LIFO\n         SPACE\nPP01     DS    0H\n         L     R1,BUFF3AD          POINT TO WORK AREA\n         LA    R1,4(,R1)           SKIP RDW AREA\n         MVC   0(B2LG,R1),BLANKS   CLEAR SOME SPACE\n         MVC   0(L'PPIL,R1),PPIL   ENTER A INDENT LINE\n         MVC   0(L'PERIND,R1),PERIND    ENTER CONTROL WORD INDICATOR\n         LA    TEMP,L'PPIL-1       LENGTH-1 OF LINE\n        $CALL  HIDBADD             ADD LINE LIFO\n         SPACE\n         MVC   0(B2LG,R1),BLANKS   CLEAR SOME SPACE\n         MVC   0(L'PPCC,R1),PPCC   ENTER CONDITIONAL COLUMN\n         MVC   0(L'PERIND,R1),PERIND    ENTER CONTROL WORD INDICATOR\n         LA    TEMP,L'PPCC-1       LENGTH-1 OF LINE\n        $CALL  HIDBADD             ADD LINE LIFO\n         SPACE\n         MVC   0(B2LG,R1),BLANKS   CLEAR SOME SPACE\n         MVC   0(L'PPSK,R1),PPSK   ENTER A SKIP\n         MVC   0(L'PERIND,R1),PERIND    ENTER CONTROL WORD INDICATOR\n         LA    TEMP,L'PPSK-1       LENGTH-1 OF LINE\n        $CALL  HIDBADD             ADD LINE LIFO\n         SPACE\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nPPIL     DC    C'.IL +3'           INDENT LINE\nPPCC     DC    C'.CC 2'            CONDITIONAL COLUMN\nPPSK     DC    C'.SK'              SKIP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PR": {"ttr": 9484, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00 \\x00 \\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .PR (PRINT ON CONSOLE) --- CONTROL                     *\n*              .TY (TYPE ON TERMINAL) --- CONTROL                     *\n*                                                                     *\n***********************************************************************\n         SPACE\nPR      $ENTER ,\n         CLC   PASSNO,DEFPASOF+TAB3DEF  IS THIS THE LAST PASS .Q\n         BNE   PR01                BRANCH TO PRINT IF NOT\n        $IFON  TTYPE,TFILE,PR01    BRANCH IF NO TERMINAL CONFLICT\n        $IFOFF SWITCHS,HITSWS,PR01 BRANCH IF 'LOAD;HIT' NOT DISPLAYED\n        $IFON  TTYPE,TONLINE,PR02  IF ONLINE, IGNORE REQUEST\n         SPACE\nPR01     DS    0H\n         L     TEMP,ARGSTART       ADDRESS BLANK AFTER .PR\n         L     COUNT,ARGSTOP       ADDRESS END OF RECORD\n         SR    COUNT,TEMP          COMPUTE LENGTH OF LINE TO PRINT\n         BNP   PR02                EXIT IF NOTHING TO PRINT\n         SPACE\n         L     X1,BUFF3AD          POINT TO WORK BUFFER\n         XC    0(4,X1),0(X1)       CLEAR RDW AREA\n         EX    COUNT,PRMVC         MOVE CC/RECORD TO WORK BUFFER\n         LA    COUNT,5(,COUNT)     LENGTH INCLUDING RDW\n         STH   COUNT,0(,X1)        SET RECORD LENGTH\n         LR    R0,X1               POINT TO RECORD\n        $CALL  PRTERM              DISPLAY RESULT ON TERMINAL\n         SPACE\nPR02     DS    0H\n        $EXIT  RC=0                BACK TO MAIN CONTROL\n         SPACE\nPRMVC    MVC   4(*-*,X1),0(TEMP)   EXECUTED MOVE PRINT ARGUMENT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PRINT": {"ttr": 9486, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\xe3\\x00\\xe3\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 227, "newlines": 227, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTION 'PRINT' --- PRINT LINE FROM OUTLINK  *\n*                                                                     *\n***********************************************************************\n         SPACE\nPRINT   $ENTER ,\n         OC    OLDCOUNT,OLDCOUNT   IS PRINT BUFFER EMPTY .Q\n         BZ    PROF7               YES, RETURN\n        $IFON  SWITCHS,HDPSWS,XPRT05    BRANCH IF HEADING/FOOTING\n         CLI   ICORFLG,ICORNONE    ARE WE FORMATTING INTO CORE .Q\n         BNE   XPRT02              BRANCH IF YES\n        $IFON  SWITCHS,FNOCT,XPRT02     BRANCH IF 'DONT COUNT' LINE\nPRDEC    DS    0H\n        $OFF   SWITCHS,OOSWS       REENABLE OUTPUT OVERLAY FOR WIDOW\n         LH    COUNT,PLCT          GET LINE COUNTER\n         CH    COUNT,RMTRIG        IS THIS THE REMOTE TRIGGER .Q\n         BNE   PRDEC01             IF NOT, SKIP\n         LTR   R1,COUNT            ANY BOTTOM TITLE INFORMATION .Q\n         BZ    PRDEC01             BRANCH IF NOT\n        $CALL  RMIMBED             YES, GO IMBED REMOTE SEQUENCE\n         B     PRDEC               CHECK FOR ANOTHER REMOTE RIGHT NOW\nPRDEC01  DS    0H\n         BCTR  COUNT,0             DECREMENT LINE BY 1\n         LH    R1,BMMRG            BOTTOM MARGIN\n         AH    R1,FNSEP            PLUS FOOTNOTE MARGIN\n         CR    COUNT,R1            AT BOTTOM OF PAGE .Q\n         BNL   WIDOW               NO, CHECK IF WIDOW\nPRDEC02  DS    0H\n         CLI   ICOLFLG,ICOLMC      MULTI-COLUMN OUTPUT .Q\n         BNE   PRDEC04             BRANCH IF NOT\n         L     COUNT,CDCURR        CURRENT OUTPUT COLUMN\n         C     COUNT,CDCOUNT       IN THE LAST COLUMN .Q\n         BL    PRDEC03             BRANCH IF NOT\n        $CALL  PAGEREAL            A REAL PAGE EJECT NOW PLEASE\n         B     PRDEC               AND TRY AGAIN\nPRDEC03  DS    0H\n        $CALL  COLNEW              DO A COLUMN EJECT\n         B     PRDEC               AND TRY AGAIN\n         SPACE\nPRDEC04  DS    0H\n        $CALL  PAGE                TERMINATE CURRENT PAGE/COLUMN NOW\n         B     PRDEC               AND TRY AGAIN\n         SPACE\nFRSTLNE  DS    0H\n*  THIS IS FOR FIRST TEXT LINE TO BE PRINTED AFTER A BREAK\n        $OFF   SWITCHS,FLNESWS     NOT FIRST LINE\n         SH    COUNT,DSCNT         LESS LINE SPACING FACTOR\n         S     COUNT,F1            LESS CURRENT LINE\n         LH    R1,BMMRG            BOTTOM MARGIN\n         AH    R1,FNSEP            PLUS FOOTNOTE MARGIN\n         CR    COUNT,R1            NEED AT LEAST THREE LINES LEFT\n         BH    WIDOW02             BRANCH IF OK\n         B     WIDOW01             ELSE GO TERMINATE CURRENT PAGE NOW\n         SPACE\nFRSTSET  DS    0H\n*  THIS IS ENTERED WHEN A BREAK IS ENCOUNTERED\n        $ON    SWITCHS,FLNESWS     NEXT LINE IS FIRST AFTER BREAK\n         B     XPRT01              AND CONTINUE\n         SPACE\nWIDOW    DS    0H                                               *SOCOL*\n        $IFOFF SWITCHS,WDSWS,XPRT01     BRANCH IF NO WIDOW REQUIRED\n        $IFON  SWITCHS,HDPSWS,XPRT01    BRANCH IF IN HEADING/FOOTING\n         L     TEMP,PTELLNG        LENGTH LEFT TO PROCESS\n         LTR   TEMP,TEMP           LAST LINE OF PARAGRAPH .Q\n         BZ    FRSTSET             YES, NO PROBLEM\n         SH    COUNT,DSCNT         LESS LINE SPACING FACTOR\n        $IFON  SWITCHS,FLNESWS,FRSTLNE  BRANCH IF FIRST LINE\n         LH    R1,BMMRG            BOTTOM MARGIN\n         AH    R1,FNSEP            PLUS FOOTNOTE MARGIN\n         CR    COUNT,R1            LAST TEXT LINE ON PAGE .Q\n         BH    WIDOW02             BRANCH IF NOT\n         L     TEMP,CLLZ           GET LINE/COLUMN LENGTH\n         SRL   TEMP,2              DIVIDE BY FOUR\n         A     TEMP,CLLZ           1.25 TIMES LINE/COLUMN LENGTH\n         C     TEMP,PTELLNG        IF 1.25 * LL IN LINKAREA, THAT'S\n         BL    WIDOW02             TWO LINES ON NEXT PAGE, NO EJECT\nWIDOW01  DS    0H\n        $ON    SWITCHS,OOSWS       DISABLE OUTPUT OVERLAY FOR SPACE(S)\n         B     PRDEC02             AND CAUSE PAGE EJECT\n         SPACE\nWIDOW02  DS    0H\n         LH    COUNT,PLCT          GET CURRENT PAGE LENGTH\n         BCTR  COUNT,0             RESTORE LINE COUNT\n         SPACE\nXPRT01   DS    0H\n         STH   COUNT,PLCT          SET REMAINDER OF PAGE COUNT\n         SPACE\nXPRT02   DS    0H\n        $CALL  PRSKSPC             ADD ANY CONDITIONAL SPACE/SKIP\nXPRT05   DS    0H\n        $IFOFF SWITCHS,JUADSWS,XPRT06   BRANCH IF NO ADJUSTMENT\n         LA    R1,LINKPARM         PARM OF AREA TO ADJUST\n        $CALL  ADJUST              DO REQUIRED LINE JUSTIFICATION\nXPRT06   DS    0H\n         L     R1,OLDFIRST         SET POINTER TO FIRST ELEMENT\n         USING LINKELEM,R1         AND TELL THE ASSEMBLER\n         SR    TEMP,TEMP           CLEAR WORK REGISTER\n         IC    TEMP,LINKMULT       GET MULTIPLIER\n         AH    TEMP,ADJCNT         CENTER IF REQUIRED\n         STC   TEMP,LINKMULT       AND RESET\n         L     COUNT,NOCHARS       GET LINE SIZE\n         AH    COUNT,ADJCNT        PLUS ADJUSTMENT\n         ST    COUNT,NOCHARS       SET NEW LINE SIZE\n         DROP  R1\n         SPACE\n        $OFF   SWITCHS,FOVLY       NO PRINTER OVERLAY NEEDED YET\n        $IFOFF SWITCHS,FNOCT,PROF       BRANCH IF 'DONT COUNT' LINE\n        $ON    SWITCHS,FOVLY       IF YES, PRETEND OVERLAY LINE\n         SPACE\nPROF     DS    0H\n         L     X3,OUTPARM          OUTPUT RECORD\n         S     X3,F4               POINT AT RDW\n         MVC   5(L'BUFF1,X3),BLANKS     BLANK THE BUFFER\n         SPACE\n        $IFON  TTYPE,TONLINE,PRTYP BRANCH IF ONLINE\n         ST    COUNT,NOCHARS       RESTORE LINE LENGTH\n         LA    R1,LINKPARM         SET POINTER TO LINE PARAMETERS\n        $CALL  LKGETP              STRING OUT LINE FOR PRINTER\n         L     TEMP,NOCHARS        SETTING LINE LENGTH\n         LA    TEMP,4(TEMP)\n         STH   TEMP,0(,X3)         STORE IT AT BEGINNING OF LINE (RDW)\n         MVI   4(X3),C' '          SET FOR SINGLE SPACE\n        $IFOFF SWITCHS,FOVLY,PROF1 BRANCH IF OVERLAY NOT NEEDED\n         MVI   4(X3),SUPRSPAC      YES, SET FOR NO SPACE\nPROF1    DS    0H\n         LR    R0,X3               SET RECORD POINTER FOR OFFLINE\n         B     PRBOTH              ..\n         SPACE\nPRTYP    DS    0H\n         LA    R1,LINKPARM         SET POINTER TO LINE PARAMETERS\n        $IFOFF TTYPE,TSCREEN,PRTYP01    BRANCH IF NOT A CRT\n        $CALL  LKGETP              FOR A CRT, STRING OUT LIKE PRINTER\n         B     PRTYP02             AND CONTINUE\n         SPACE\nPRTYP01  DS    0H\n        $CALL  LKGETT              STRING OUT LINE FOR TYPEWRITER\nPRTYP02  DS    0H\n         L     TEMP,NOCHARS        GET LENGTH\n         LA    TEMP,3(,TEMP)       INCREMENT FOR LENGTH OF RDW\n         MVC   1(4,X3),F0          ZERO REC DESC WORD FIELD\n         STC   TEMP,2(,X3)         STORE LINE LENGTH\n         LA    R0,1(,X3)           SET RECORD POINTER FOR ONLINE\n         SPACE\nPRBOTH   DS    0H\n         CLI   ICORFLG,ICORNONE    ARE WE FORMATTING INTO CORE .Q\n         BNE   PRBOTH1             BRANCH IF YES\n        $IFOFF SWITCHS,TRSWS,PRBOTH1    BRANCH IF NO TRANSLATE\n         L     R1,TRANADO          ADDRESS OF OUTPUT TRANSLATE TABLE\n         L     TEMP,NOCHARS        LENGTH OF ACTUAL SCRIPT LINE\n         BCTR  TEMP,0              LENGTH LESS ONE FOR SS\n         EX    TEMP,TRANSLAT       TRANSLATE LINE\n         SPACE\nPRBOTH1  DS    0H\n        $IFON  SWITCHS,HDPSWS,NONUM     BRANCH IF HEADING/FOOTING\n        $IFOFF SWITCHS,NUSWS,NONUM BRANCH IF NO LINE NUMBERING\n         L     R1,DEFNUM+TAB3DEF   GET NUMBER COLUMN OFFSET\n         LTR   R1,R1               IS IT POSITIVE .Q\n         BNP   NONUM               NO, NO NUMBERS THEN\n        $CALL  PRNUM               ENTER NUMBER/FILE\n         SPACE\nNONUM    DS    0H\n        $CALL  PRRCADD             ADD ANY REVISION CODES\n         SPACE\n         LH    X1,DARKVAL          GET DARK OUTPUT VALUE\nPROFDA   DS    0H\n         CLI   ICORFLG,ICORNONE    ARE WE FORMATTING INTO CORE .Q\n         BNE   NONUM1              BRANCH IF YES\n        $CALL  IOPRINT             NO, PRINT THE LINE\n         B     PROF2               SKIP FOOTNOTE SAVE\nNONUM1   DS    0H\n        $CALL  FNSAVE              QUEUE FOOTNOTE LINE\n         SPACE\nPROF2    DS    0H\n        $IFON  TTYPE,TONLINE,PROF2A     BRANCH IF ONLINE\n        $ON    SWITCHS,FOVLY       OVERLAID IF DARK\n        $ON    SWITCHS,OOSWS       DISABLE OUTPUT OVERLAY, DONE ALREADY\n         LR    R1,R0               POINTER TO RECORD RDW\n         MVI   4(R1),SUPRSPAC      OVERLAY CARRIAGE CONTROL\n         BCT   X1,PROFDA           DARK OUTPUT AS REQUIRED\nPROF2A   DS    0H\n        $OFF   SWITCHS,OOSWS       REENABLE OUTPUT OVERLAY\n         CLC   OLDCOUNT,F0         ANY LEFT FROM PRINTER OUTPUT .Q\n         BE    PROF3               IF NOT, DONE WITH LINE\n        $ON    SWITCHS,FOVLY       YES, NOTE FOR NEXT TIME THROUGH\n         B     PROF                DO NEXT LAYER ON PRINTER OR CRT\n         SPACE\nPROF3    DS    0H\n        $OFF   SWITCHS,FOVLY       NO MORE OVERLAID LINES\n         LH    TEMP,INDL           ADJUST INDENT FACTOR\n         AH    TEMP,OFFLI          ..\n         STH   TEMP,INDL           ..\n         STH   TEMP,RMARGIN        SET RIGHT MARGIN\n         XC    UNDL(2),UNDL        RESET UNDENT\n         XC    OFFLI,OFFLI         RESET OFFSET\n         XC    OFUNCNT,OFUNCNT     RESET OFFSET/UNDENT MARGIN\n        $IFON  SWITCHS,HDPSWS,PROF7     NO LINE SPACING IN HEADINGS\n         LH    COUNT,DSCNT         GET LINE SPACING FACTOR\n         LTR   COUNT,COUNT         ANY LINE SPACING PRESENT .Q\n         BNP   PROF7               BRANCH IF NONE PRESENT\n         CLI   ICORFLG,ICORNONE    ARE WE FORMATTING INTO CORE .Q\n         BNE   PROF5               YES, DO IT ONE BLANK LINE AT A TIME\n         LH    TEMP,PLCT           LINES LEFT ON THIS PAGE\n         SH    TEMP,BMMRG          LESS BOTTOM MARGIN\n         SH    TEMP,FNSEP          LESS FOOTNOTE MARGIN\n         BNP   PROF7               BRANCH IF NONE LEFT\n         CR    COUNT,TEMP          COMPARE NEEDED TO AVAILABLE\n         BNH   PROF4               BRANCH IF OK\n         LR    COUNT,TEMP          DO THE LESSER\nPROF4    DS    0H\n        $ON    SKSPFLG,SKSPSK      THIS IS A SKIP\n        $CALL  SPEX                DO EXECUTION OF REAL SPACING\n         B     PROF7               GO TO RETURN\nPROF5    DS    0H\n        $ON    SKSPFLG,SKSPSK      THIS IS A SKIP\n         MVI   PRNTRCC,SINGLSP     SINGLE SPACE CARRIAGE CONTROL\n         LA    R0,BLNKLINE         POINT TO BLANK LINE RDW\nPROF6    DS    0H\n        $CALL  FNSAVE              SAVE BLANK LINE\n         BCT   COUNT,PROF6         LOOP TILL DONE\n         MVI   SKSPFLG,X'00'       CLEAR SPACING FLAGS\n         SPACE\nPROF7    DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              IF ZERO, ONLY SINGLE SPACE\n         SPACE\nTRANSLAT TR    5(*-*,X3),0(R1)     EXECUTED TRANSLATE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PRINTNB": {"ttr": 9731, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00%\\x00%\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              PRINTNB  ---  CHECK FOR NOBREAK CHAR                   *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON EXIT  --  CC=BPOS  IF NORMAL PRINT ACTION\n*                     CC=BNEG  IF BREAK BYPASSED\n         SPACE\nPRINTNB $ENTER ,\n        $IFON  SWITCHS,JUADSWS,PRNB01   BRANCH IF FORCE JUSTIFY\n         CLC   PERIND(1),BUFF2     NORMAL CONTROL WORD .Q\n         BE    PRNB01              BRANCH IF YES\n         CLC   PERNBIND(1),BUFF2   NOBREAK CONTROL WORD .Q\n         BE    PRNB04              BRANCH AROUND IF YES\nPRNB01   DS    0H\n         CLC   OLDCOUNT,F0         IS PRINT BUFFER EMPTY .Q\n         BE    PRNB03              BRANCH IF YES\n        $OFF   SWITCHS,JUADSWS     INITIALIZE JUSTIFY SWITCH\n         CLI   JUVAL,JUVPOS        MORE THAN LEFT/RIGHT JUSTIFY .Q\n         BNH   PRNB02              BRANCH IF NOT\n        $ON    SWITCHS,JUADSWS     JUSTIFY LINE LATER WITH ADJUST\nPRNB02   DS    0H\n        $CALL  PRINT               NORMAL PRINT ROUTINE\nPRNB03   DS    0H\n        $OFF   SWITCHS,HYSUPSW     KILL AUTO HYPHENATION SUPPRESSION\n         MVC   HYSUPWRK,HYSUPCNT   RESET NUMBERED HYPHENATION SUPPRESS\n        $OFF   SWITCHS,JUADSWS     RESET ADJUSTMENT/JUSTIFY FLAG\n        $CC    POS                 NORMAL PRINT ACTION\n         B     PRNB05              AND GO TO RETURN\n         SPACE\nPRNB04   DS    0H\n        $CC    NEG                 BREAK WAS BYPASSED\n         SPACE\nPRNB05   DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGS\n         BR    RETURN              AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PRLIN": {"ttr": 9733, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x006\\x006\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTION 'PRLIN' --- ENTER LINE/LEGAL         *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R0) POINTS TO OUTPUT RECORD\n*                      (R1) OFFSET IN DATA FOR RESULT\n         SPACE\nPRLIN   $ENTER ,\n        $IFON  SWITCHS,FOVLY,PRLIN03    BRANCH IF OVERLAY LINE\n        $CALL  PRTARG              GET TARGET FOR DATA\n         CLC   0(L'PRLINED,R1),BLANKS   A CLEAN TARGET AREA .Q\n         BNE   PRLIN03             NO, FORGET LINE NUMBER\n         LH    X1,PLZ              GET PAGE LENGTH\n         SH    X1,PLCT             LESS REMAINDER OF PAGE\n         SPACE\n        $IFOFF SWITCHS,OUSWS,PRLIN02    BRANCH IF NOT LEGAL NUMBERING\n         CH    X1,TOPMRG           WITHIN TOP MARGIN .Q\n         BNH   PRLIN03             YES, DO NOT NUMBER\n         CLC   PLCT,BMMRG          WITHIN BOTTOM MARGIN .Q\n         BL    PRLIN03             YES, DO NOT NUMBER\n         LR    X1,R0               POINT TO RECORD RDW\n         LH    X2,0(,X1)           GET LENGTH, INCL RDW\n         LA    X1,4(,X1)           POINT PAST RDW\n         S     X2,F5               LENGTH-1 LESS RDW\n        $IFON  TTYPE,TONLINE,PRLIN01    BRANCH IF ONLINE\n         LA    X1,1(,X1)           POINT PAST CARRIAGE CONTROL\n         BCTR  X2,0                DECREMENT LENGTH-1\nPRLIN01  DS    0H\n         EX    X2,PRLINCLC         DATA ALL BLANK .Q\n         BE    PRLIN03             YES, DO NOT NUMBER\n         L     X1,OUTSEQ           GET LAST LEGAL LINE SEQUENCE\n         LA    X1,1(,X1)           BUMP BY ONE\n         ST    X1,OUTSEQ           SAVE CURRENT VALUE\n         SPACE\nPRLIN02  DS    0H\n         CVD   X1,DECM             CONVERT NUMBER TO DECIMAL\n         MVC   0(L'PRLINED,R1),PRLINED  MOVE IN EDIT PATTERN\n         ED    0(L'PRLINED,R1),DECM+6   EDIT IN LINE NUMBER\n         LA    R1,L'PRLINED(,R1)   END OF FIELD\n         LR    X2,R0               THIS IS RECORD START\n         SR    R1,X2               LENGTH WHERE FIELD ENDED\n         SR    X1,X1               ZERO WORK REGISTER\n         IC    X1,1(,X2)           CURRENT RECORD LENGTH\n         CR    R1,X1               IS THIS NOW LONGER .Q\n         BNH   PRLIN03             BRANCH IF NOT\n         STC   R1,1(,X2)           SET LONGER LENGTH\n         SPACE\nPRLIN03  DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\nPRLINCLC CLC   0(*-*,X1),BLANKS    COMPARE FOR BLANK DATA\nPRLINED  DC    X'40202120'         LINE NUMBER EDIT PATTERN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PRNUM": {"ttr": 9735, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x002\\x002\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTION 'PRNUM' --- ADD NUMBER/FILE          *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R0)  PTR TO RDW TO INCREASE LENGTH\n*                      (R1)  OFFSET IN DATA FOR RESULT\n         SPACE\nPRNUM   $ENTER ,\n        $IFON  SWITCHS,FOVLY,PRNUM03    BRANCH IF OVERLAY LINE\n        $CALL  PRTARG              GET TARGET FOR DATA\n         CLC   0(28,R1),BLANKS     A CLEAN WORK AREA .Q\n         BNE   PRNUM03             NO, FORGET NUM FOR THIS LINE\n         SPACE\n         MVC   0(8,R1),COMFILNO    FILE RECORD NUMBER\n         LA    R1,9(,R1)           FILE NAME GOES HERE\n         CLI   COMMEMNM,C' '       BLANK MEMBER NAME .Q\n         BNE   PRNUM01             BRANCH IF NOT\n         CLC   COMFILNM,PRNUMIN    INSIGNIFICANT FILE NAME .Q\n         BE    PRNUM02             BRANCH IF YES\nPRNUM01  DS    0H\n         MVC   0(8,R1),COMFILNM    ADD CURRENT FILE NAME\n         BAL   RETURN,PRNUMSK      SKIP TO 1ST BLANK\n         CLI   COMMEMNM,C' '       IS MEMBER NAME BLANK .Q\n         BE    PRNUM02             YES, SET NEW LENGTH\n         MVI   0(R1),C'('          INITIAL PAREN\n         MVC   1(8,R1),COMMEMNM    ADD MEMBER NAME\n         BAL   RETURN,PRNUMSK      SKIP TO 1ST BLANK AGAIN\n         MVI   0(R1),C')'          CLOSING PAREN\n         LA    R1,1(,R1)           FIRST BLANK AFTER\nPRNUM02  DS    0H\n         LTR   X1,R0               THIS IS THE RECORD\n         BZ    PRNUM03             BRANCH IF NO RECORD\n         SR    R1,X1               LENGTH WHERE WE LEFT OFF\n         SR    TEMP,TEMP           ZERO WORK REGISTER\n         IC    TEMP,1(,X1)         CURRENT RECORD LENGTH\n         CR    R1,TEMP             IS THIS NOW LONGER .Q\n         BNH   PRNUM03             BRANCH IF NOT\n         STC   R1,1(,X1)           SET LONGER LENGTH\nPRNUM03  DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\nPRNUMSK  DS    0H\n         LA    R1,1(,R1)           BUMP OUTPUT POINTER\n         CLI   0(R1),C' '          IS IT BLANK .Q\n         BNE   PRNUMSK             BUMP ALONG IF NOT\n         BR    RETURN              GO BACK TO CALLER\n         SPACE\nPRNUMIN  DC    CL8'SYSIN'          INSIGNIFICANT FILE NAME\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PRRCADD": {"ttr": 9737, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x002\\x002\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              PRRCADD --- ADD REVISION CODE TO OUTPUT LINE           *\n*                                                                     *\n***********************************************************************\n         SPACE\nPRRCADD $ENTER ,\n         L     X1,RCAREAAD         REVISION CODE WORK AREA\n         LTR   X1,X1               DOES IT EXIST .Q\n         BZ    PRRC03              BRANCH IF NOT\n         SPACE\n         USING RCAREA,X1           AREA LOOKS LIKE THIS\n        $IFON  SWITCHS,FOVLY,PRRC03     NO REV CODE IF LINE OVERLAID\n        $IFON  SWITCHS,HDPSWS,PRRC03    NO REV CODE IF HEADING/FOOTING\n         LH    R1,ADJCNT           CURRENT ADJUST VALUE\n         S     R1,F1               LESS ONE FOR BLANK\n         BNP   PRRC03               BRANCH IF NO ROOM AT ALL\n         SPACE\n         LA    R0,L'RCACHAR        MAX REVISION CODE LENGTH\n         CR    R0,R1                IS IT SHORTER THAN AVAILABLE SPACE\n         BH    PRRC01              BRANCH IF YES\n         LR    R1,R0               TAKE MAX INSTEAD\nPRRC01   DS    0H\n         LA    TEMP,BUFF1          TARGET LINE ADDRESS\n         AH    TEMP,ADJCNT          PLUS ADJUST VALUE\n         S     TEMP,F1             LESS ONE FOR BLANK\n         SR    TEMP,R1             LESS LENGTH OF REV CODE\n         SPACE\n         LA    COUNT,L'RCACHAR      MAX REV CODE LENGTH\n         SR    COUNT,R1            OFFSET OF SOURCE\n         BCTR  R1,0                 LENGTH -1 OF REV CODE\n         SPACE\n         CLC   RCASTALL,BLANKS     STALLED 'RC OFF' CHARS .Q\n         BE    PRRC02              BRANCH IF NOT\n         LA    COUNT,RCASTALL(COUNT)    POINT TO SOURCE\n         EX    R1,PRRCMVC          SET REVISION CODE\n         MVC   RCASTALL,BLANKS     CLEAR STALLED REV CODE\n         B     PRRC03              AND CONTINUE\n         SPACE\nPRRC02   DS    0H\n         CLC   RCACHAR,BLANKS      ANY REVISION CODE PRESENT .Q\n         BE    PRRC03              BRANCH IF NONE\n         LA    COUNT,RCACHAR(COUNT)     POINT TO SOURCE\n         EX    R1,PRRCMVC          SET REVISION CODE\n         SPACE\nPRRC03   DS    0H\n         $EXIT  RC=0               RETURN TO CALLER\n         SPACE\nPRRCMVC  MVC   0(*-*,TEMP),0(COUNT)     ENTER REV CODE IN TEXT\n         DROP  X1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PRSKSPC": {"ttr": 9739, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00(\\x00(\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              PRSKSPC - OUTPUT ANY CONDITIONAL SPACE/SKIP LINES      *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  SKSPCCNT  CONTAINS CONDITIONAL COUNT\n*                  --  SKSPFLG2  CONTAINS TYPE OF SPACE/SKIP\n*\n*        ON EXIT   --  CC = BPOS IF ACTION PERFORMED\n*                         = BOMIT IF NO ACTION PERFORMED\n         SPACE\nPRSKSPC $ENTER ,\n         LH    COUNT,SKSPCCNT      GET CONDITIONAL SKIP/SPACE COUNT\n         LTR   COUNT,COUNT         ANYTHING PRESENT .Q\n         BZ    PRSSC04             BRANCH IF NO SPACES\n         MVC   SKSPFLG,SKSPFLG2    RESTORE FLAGS\n         MVI   SKSPFLG2,X'00'      CLEAR SAVED FLAGS\n         XC    SKSPCCNT,SKSPCCNT   CLEAR COUNT\n         CLI   ICORFLG,ICORNONE    ARE WE FORMATTING INTO CORE .Q\n         BNE   PRSSC01             BRANCH IF YES\n        $CALL  SPEX                DO THE SKIP/SPACE\n         B     PRSSC03             CONTINUE\n         SPACE\nPRSSC01  DS    0H\n         MVI   PRNTRCC,SINGLSP     SINGLE SPACE CARRIAGE CONTROL\n         LA    R0,BLNKLINE         POINT TO BLANK LINE RDW\nPRSSC02  DS    0H\n        $CALL  FNSAVE              SAVE BLANK LINE\n         BCT   COUNT,PRSSC02       LOOP TILL DONE\nPRSSC03  DS    0H\n         MVI   SKSPFLG,X'00'       CLEAR SPACING FLAGS\n        $CC    POS                 INDICATE ACTION PERFORMED\n         B     PRSSC05             AND GO TO RETURN\n         SPACE\nPRSSC04  DS    0H\n        $CC    OMIT                INDICATE NO ACTION PERFORMED\n         SPACE\nPRSSC05  DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PRTARG": {"ttr": 9741, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x000\\x000\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              'PRTARG' INTERNAL ROUTINE --- GET PRINT TARGET         *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY --  (R0) -> RDW OF OUTPUT LINE\n*                     (R1) CONTAINS DESIRED OFFSET\n*\n*        ON EXIT  --  (R1) ADDR OF POTENTIAL TARGET\n         SPACE\nPRTARG  $ENTER ,\n         LR    X1,R1               DESIRED COLUMN\n         BCTR  X1,0                CHANGE TO AN OFFSET\n         LR    R1,R0               RECORD START ADDR\n         LA    R1,4(,R1)           SKIP THE RDW\n        $IFON  TTYPE,TONLINE,PRTARG01   BRANCH IF ONLINE\n         LA    R1,1(X1,R1)         SKIP CC AND USER AMOUNT\n         B     PRTARG05            AND GO TO RETURN\n         SPACE\nPRTARG01 DS    0H\n         LTR   X1,X1               ALL DONE .Q\n         BZ    PRTARG05            BRANCH IF YES\nPRTARG02 DS    0H\n         CLI   0(R1),CBACKSP       BACKSPACE ON ONLINE OUTPUT .Q\n         BE    PRTARG03            BRANCH IF YES\n         CLI   0(R1),CESCAPE       ESCAPE ON ONLINE OUTPUT .Q\n         BNE   PRTARG04            BRANCH IF NOT\n         L     TEMP,VDEVICEA       TERMINAL DESCRIPTOR BLOCK\n         LTR   TEMP,TEMP           DOES IT EXIST .Q\n         BZ    PRTARG03            BRANCH IF NOT\n         LA    TEMP,TDEVAESC-TDEVICEA(,TEMP) AFTER ESCAPE TABLE\n         SR    R0,R0               CLEAR WORK REG\n         IC    R0,1(,R1)           FUNCTION CHARACTER\n         AR    TEMP,R0             POINT TO LENGTH-1\n         IC    R0,0(,TEMP)         LENGTH-1 AFTER ESCAPE\n         AR    R1,R0               BUMP BY LENGTH-1\nPRTARG03 DS    0H\n         LA    R1,2(,R1)           SKIP BACKSPACE AND NEXT CHAR\n         B     PRTARG02            AND TRY AGAIN\n         SPACE\nPRTARG04 DS    0H\n         LA    R1,1(,R1)           NEXT CHAR\n         BCTR  X1,0                DECREMENT LENGTH REMAINING\n         B     PRTARG01            AND TRY ONCE MORE\n         SPACE\nPRTARG05 DS    0H\n        $EXIT  KEEP=(R1),RC=0      RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PRTERM": {"ttr": 9743, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00 \\x00 \\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        INTERNAL ROUTINE 'PRTERM' -- PRINT LINE ON ERROR FILE        *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER --     LA    R0,AREA PREFACED BY RDW/CC\n*                       $CALL  PRTERM\n         SPACE\nPRTERM  $ENTER ,\n         L     R1,IOCBTERM         SYSTERM IOCB ADDRESS\n         LA    R1,0(,R1)           CLEAR HIGH BYTE\n         LTR   R1,R1               IS FILE OPEN .Q\n         BZ    PRTERM01            BRANCH IF NOT\n        $CALL  PUTTERM             OUTPUT THE DATA\n         B     PRTERM02            GO TO RETURN\n         SPACE\nPRTERM01 DS    0H\n         L     X1,WTOCOUNT         CURRENT RECORDS TO OPERATOR\n         A     X1,F1               PLUS ONE\n         C     X1,F1               TOO MANY .Q\n         ST    X1,WTOCOUNT         UPDATE ATTEMPTS\n         BH    PRTERM02            BRANCH IF TOO MANY\n         LR    R1,R0               POINT TO RDW\n         LH    R0,0(,R1)           LENGTH INCL RDW/CC\n         S     R0,F5               GET DATA LENGTH\n         BNP   PRTERM02            BRANCH IF NOTHING\n         LA    R1,5(,R1)           POINT TO DATA\n        $CALL  SYWTO               DISPLAY THE RESULT\n         SPACE\nPRTERM02 DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PS": {"ttr": 9745, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x16\\x00\\x16\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .PS (PAGE SYMBOL) --- CONTROL                          *\n*                                                                     *\n***********************************************************************\n         SPACE\nPS      $ENTER ,\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION\n        $CALL  GETARG              OBTAIN FIRST SOURCE CHARACTER\n         BC    BPOS,PS01           BRANCH IF ARGUMENT PRESENT\n         LA    COUNT,PSYMBOL+1     POINT TO DEFAULT CHARACTER\n         SR    TEMP,TEMP           LENGTH-1 IS ZERO\nPS01     DS    0H\n         LTR   TEMP,TEMP           TEST LENGTH-1 OF ARG\n         BNZ   PSE005              ERROR IF NOT ZERO\n         MVC   PSYMBOL(1),0(COUNT) SET PAGE SYMBOL CHARACTER\nPS02     DS    0H\n        $EXIT  RC=0                AND CONTINUE\n         SPACE\nPSE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     PS02                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PT": {"ttr": 9747, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x11\\x00\\x11\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .PT (PUT TABLE OF CONTENTS) --- CONTROL                *\n*                                                                     *\n***********************************************************************\n         SPACE\nPT      $ENTER ,\n        $CALL  USARG               ISOLATE 'LINE' OPERAND\n         BC    BOMIT,PT01          BRANCH IF NO 'LINE' OPERAND\n         LH    TEMP,BUFF2LGZ       LENGTH OF OPERAND\n         BCTR  TEMP,0              LENGTH-1\n         LA    R1,BUFF2            POINT TO LINE\n         LNR   R1,R1               ADD TEXT AT END\n        $CALL  HIDTCAD             ADD LINE TO TABLE OF CONTENTS\n         SPACE\nPT01     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PU": {"ttr": 9749, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00,\\x00,\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .PU (PUT WORK FILE) --- CONTROL                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nPU      $ENTER ,\n         L     X3,ARGSTART         LINE MAY FOLLOW IMMEDIATELY\n        $CALL  GETNUM              GET FILE NUMBER\n         LA    R1,1                FILE ONE BY DEFAULT\n         BC    BOMIT+BDNO,PU01     BRANCH IF OMITTED OR INVALID\n         LTR   R1,COUNT            TEST RESULT TOO SMALL .Q\n         BNP   PUE014              ERROR IF FILE NUMBER TOO SMALL\n         LA    R0,PUMAX            MAX FILE SUPPORTED\n         CR    R1,R0               FILE NUMBER TOO BIG .Q\n         BH    PUE013              ERROR IF TOO BIG\n         L     X3,ARGSTART         LINE MAY NOW FOLLOW IMMEDIATELY\nPU01     DS    0H\n         LA    X3,1(,X3)           BEGINNING OF OPERAND LINE\n         L     COUNT,ARGSTOP       END OF ARG LINE\n         SR    COUNT,X3            LENGTH-1 OF LINE\n         LA    R0,0                ASSUME NO DATA\n         BM    PU02                BRANCH IF NO ARG LINE\n         L     X1,BUFF3AD          WORKING BUFFER ADDRESS\n         XC    0(4,X1),0(X1)       CLEAR RDW\n         MVC   4(B2LG,X1),BLANKS   CLEAR DATA IN CASE FIXED\n         EX    COUNT,PUMVC         ENTER DATA\n         LA    COUNT,5(,COUNT)     LENGTH INCL RDW\n         STH   COUNT,0(,X1)        SET RECORD LENGTH\n         LR    R0,X1               POINT TO DATA\nPU02     DS    0H\n        $CALL  PUWORK              DO YOUR WORST\n         SPACE\nPU03     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nPUE013   DS    0H\n         MVI   EFLAG013,ERRSET     FILE OPERAND TOO BIG\n         B     PU03                GO TO RETURN\nPUE014   DS    0H\n         MVI   EFLAG014,ERRSET     FILE OPERAND TOO SMALL\n         B     PU03                GO TO RETURN\n         SPACE\nPUMVC    MVC   4(*-*,X1),0(X3)     ENTER LINE OPERAND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PUNCADJ": {"ttr": 9751, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00a\\x00a\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 97, "newlines": 97, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              PUNCADJ  --  ADJUST THE LINE AFTER PUNCTUATION         *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --   (A)  NUMBER OF BLANKS TO BE ADDED\n*                       (W)  INTERWORD SPACE COUNT\n*\n*        ON EXIT  --    (A)  NUMBER OF BLANKS LEFT TO BE ADDED\n*                       CC = BPOS  IF MORE TO DO\n*                       CC = BNEG  IF NOTHING LEFT TO DO\n         SPACE\nPUNCADJ $ENTER ,\n         USING FOPMLIST,R1         DATA DESCRIPTOR\n         LA    R15,3*4             NUMBER OF ITERATIONS\n         SPACE\nPADJ00   DS    0H\n         LR    C,W                 NUMBER OF INTERWORD SPACES\n         L     P,FOPLAST           POINTER TO LAST LINK BLOCK\n         USING LINKELEM,P          AND TELL THE ASSEMBLER\nPADJ01   DS    0H\n         LTR   P,P                 BACK CHARACTER EXIST .Q\n         BZ    PADJ10              BRANCH OUT IF NOT\n         CLI   LINKCHAR,C' '       TRAILING BLANKS .Q\n         BNE   PADJ03              BRANCH IF NOT\n         L     P,LINKBACK          BACKUP ONE CHARACTER\n         B     PADJ01              AND TRY AGAIN\n         SPACE\nPADJ02   DS    0H\n         L     P,LINKBACK          FIND NEXT BLANK\nPADJ03   DS    0H\n         LTR   P,P                 AT THE BEGINNING .Q\n         BZ    PADJ09              YES, THAT'S IT\n         CLI   LINKCHAR,C' '       IS THIS A BLANK .Q\n         BNE   PADJ02              BRANCH IF NOT\n         L     POLD,LINKBACK       CHARACTER BEFORE\n         LTR   POLD,POLD           DOES IT EXIST .Q\n         BZ    PADJ02              BRANCH IF NOT\n         USING LOLDELEM,POLD       LOOKS LIKE THIS\n         CLI   LOLDCHAR,C' '       MULTIPLE BLANKS .Q\n         BE    PADJ02              YES, TRY AGAIN\n         B     *(R15)              LEVEL OF CHECK\n         B     PADJ04              PAUSES\n         B     PADJ05              HALF STOPS\n         B     PADJ06              FULL STOPS\n         SPACE\nPADJ04   DS    0H\n         CLI   LOLDCHAR,C','       'COMMA' .Q\n         BE    PADJ07              BRANCH IF YES\n         CLI   LOLDCHAR,C')'       RIGHT PAREN .Q\n         BE    PADJ07              BRANCH IF YES\n         B     PADJ08              ELSE CONTINUE\n         SPACE\nPADJ05   DS    0H\n         CLI   LOLDCHAR,C':'       'COLON' .Q\n         BE    PADJ07              BRANCH IF YES\n         CLI   LOLDCHAR,C';'       'SEMI-COLON' .Q\n         BE    PADJ07              BRANCH IF YES\n         B     PADJ08              ELSE CONTINUE\n         SPACE\nPADJ06   DS    0H\n         CLI   LOLDCHAR,C'.'       'PERIOD' .Q\n         BE    PADJ07              BRANCH IF YES\n         CLI   LOLDCHAR,C'!'       'EXCLAMATION' .Q\n         BE    PADJ07              BRANCH IF YES\n         CLI   LOLDCHAR,C'?'       'QUESTION' .Q\n         BE    PADJ07              BRANCH IF YES\n         B     PADJ08              ELSE CONTINUE\n         SPACE\nPADJ07   DS    0H\n         IC    R0,LINKMULT         BLANK MULTIPLIER\n         A     R0,F1               PLUS ONE\n         STC   R0,LINKMULT         UPDATE BLANK MULTIPLIER\n         S     A,F1                DECREMENT BLANKS TO BE ADDED\n         BZ    PADJ10              BRANCH IF ALL DONE\n         SPACE\nPADJ08   DS    0H\n         S     C,F1                DECREMENT INTERWORD SPACE\n         BP    PADJ02              BRANCH IF MORE TO DO\n         SPACE\nPADJ09   DS    0H\n         S     R15,F4              DECREMENT TYPE BEING SOUGHT\n         BP    PADJ00              BRANCH IF MORE TO DO\n         SPACE\nPADJ10   DS    0H\n         LTR   A,A                 MORE BLANKS STILL TO FILL .Q\n         BP    PADJ11              BRANCH IF YES\n        $CC    OMIT                SET DONE CODE\n         B     PADJ12              GO TO RETURN\nPADJ11   DS    0H\n        $CC    POS                 SET NOT DONE CODE\n         SPACE\nPADJ12   DS    0H\n        $EXIT  RC=0,KEEP=(A)       RETURN TO CALLER\n         SPACE\n         DROP  P,POLD,R1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PUTCONS": {"ttr": 9985, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\xd5\\x00\\xd5\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 213, "newlines": 213, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              'PUTCONS' --- WRITE TO ONLINE TERMINAL                 *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER  --  (R0)  -> RDW OF RECORD TO DISPLAY\n*\n*        ON EXIT   --  CC = BPOS  IF DONE\n*                      CC = BNEG  IF NOT DONE\n         SPACE\nPUTCONS $ENTER ,\n        $IFON  TTYPE,TFILE,PUTCON01     BRANCH IF OUTPUT TO A FILE\n        $IFON  SWITCHS,TSOWS,PUTCON01   BRANCH IF TSO\n        $IFON  SWITCHS,CMSWS,PUTCON01   BRANCH IF CMS\n         SPACE\n        $CC    NEG                 SKIP THIS FUNCTION\n         B     PUTCON14            AND RETURN\n         SPACE\nPUTCON01 DS    0H\n         LR    R1,R0               RDW POINTER\n         MVC   SAVEH0,0(R1)        ALIGN RECORD LENGTH\n         LH    TEMP,SAVEH0         LENGTH INCL RDW\n         S     TEMP,F5             LENGTH-1 OF DATA\n         LA    R0,1(,TEMP)         RETAIN DATA LENGTH\n         LA    X1,4(,R1)           POINT TO DATA\n        $IFON  TTYPE,TFILE,PUTCON04     BRANCH IF OUTPUT TO A FILE\n         L     X2,VDEVICEA         TERMINAL DESCRIPTION\n         LTR   X2,X2               DOES BLOCK EXIST .Q\n         BZ    PUTCON11            BRANCH IF NOT\n         USING TDEVICEA,X2         AREA LOOKS LIKE THIS\n         CLI   TDEVHMI,X'00'       HORIZONTAL MOTION INDEX DEFINED ,Q\n         BNE   PUTCON04            BRANCH IF YES\n         CLI   TDEVNLF,X'00'       NEGATIVE LINEFEED DEFINED .Q\n         BNE   PUTCON04            BRANCH IF YES\n         DROP  X2\n         EX    TEMP,PUTCTRT        ANY INTERESTING CHARACTERS .Q\n         BZ    PUTCON11            BRANCH IF NONE\n         SPACE\nPUTCON04 DS    0H\n         L     TEMP,BUFF3AD        WORK AREA START ADDRESS\n         MVC   0(256,TEMP),BLANKS  CLEAR GOT WORK AREA\n         XC    0(4,TEMP),0(TEMP)   CLEAR AREA FOR RDW\n         MVI   SAVEX0,TDEVHMI-TDEVICEA   HORIZONTAL MOTION INDEX\n         LA    TEMP,4(,TEMP)       TARGET ADDRESS FOR DATA\n         ST    TEMP,SAVEF0         SET POINTER FOR OUTPUT\n         MVC   SAVEH0,TDEVWID      SET DEFAULT CHAR WIDTH\n         LA    R1,SAVED0           POINT TO PARM AREA\n        $CALL  LKGESC              AND ENTER ESCAPE\n         LR    X2,R1               NEXT FREE CHAR\n        $IFOFF SWITCHS,FOVLY,PUTCON05   BRANCH IF NO OVERLAY LINE\n         MVI   SAVEX0,TDEVNLF-TDEVICEA  NEGATIVE LINEFEED\n         ST    X2,SAVEF0           WHERE TO PUT IT\n         LA    R1,SAVED0           POINT TO PARM AREA\n        $CALL  LKGESC              AND ENTER ESCAPE\n         LR    X2,R1               REMEMBER FIRST FREE\nPUTCON05 DS    0H\n         LTR   R0,R0               ANY MORE TO DO .Q\n         BNP   PUTCON10            BRANCH IF NOT\n         LR    TEMP,R0             LENGTH OF REMAINDER\n         BCTR  TEMP,0              LENGTH-1 OF REMAINDER\n         SR    COUNT,COUNT         PREPARE FOR A HIT\n         EX    TEMP,PUTCTRT        ANY INTERESTING CHARS .Q\n         BZ    PUTCON09            BRANCH IF NONE\n         SPACE\n         LR    TEMP,R1             ENDED HERE\n         SR    TEMP,X1             AND STARTED HERE\n         BZ    PUTCON06            BRANCH IF IMMEDIATE\n         SR    R0,TEMP             DECREMENT LENGTH REMAINING\n         BCTR  TEMP,0              LENGTH-1 TO MOVE\n         EX    TEMP,PUTCMVC        ADD DATA\n         LA    X1,1(TEMP,X1)       STOP INPUT CHAR\n         LA    X2,1(TEMP,X2)       NEXT OUTPUT CHAR\nPUTCON06 DS    0H\n         EX    R0,PUTCEX1-4(COUNT) DO AS REQUIRED\n         ST    X2,SAVEF0           OUTPUT POINTER\n         LA    R1,SAVED0           PARM POINTER\n        $CALL  LKGESC              ADD ESCAPE\n         LR    X2,R1               NEXT FREE OUTPUT\nPUTCON07 DS    0H\n         MVC   0(1,X2),0(X1)       STOP CHARACTER\n         TR    0(1,X2),DIABOUT     TRANSLATE SAME\n         LA    X2,1(,X2)           BUMP OUTPUT POINTER\n         LA    X1,1(,X1)           AND INPUT POINTER\n         BCTR  R0,0                DECREMENT LENGTH LEFT\n         EX    R0,PUTCEX2-4(COUNT) DO AS REQUIRED\n         ST    X2,SAVEF0           OUTPUT POINTER\n         LA    R1,SAVED0           PARM POINTER\n        $CALL  LKGESC              ADD ESCAPE\n         LR    X2,R1               NEXT FREE OUTPUT\nPUTCON08 DS    0H\n         B     PUTCON05            AND CONTINUE\n         SPACE\nPUTCEX1  B     PUTCON07            TRANSLATE CHAR ONLY\n         MVI   SAVEX0,TDEVSUP-TDEVICEA  SUPERSCRIPT\n         MVI   SAVEX0,TDEVSUB-TDEVICEA  SUBSCRIPT\nPUTCEX2  B     PUTCON08            TRANSLATE CHAR ONLY\n         MVI   SAVEX0,TDEVSUB-TDEVICEA  SUPERSCRIPT\n         MVI   SAVEX0,TDEVSUP-TDEVICEA  SUBSCRIPT\n         SPACE\nPUTCMVC  MVC   0(*-*,X2),0(X1)     MOVE DATA\nPUTCTRT  TRT   0(*-*,X1),DIABIN    SEARCH FOR SPECIAL CHARS\n         SPACE\nPUTCON09 DS    0H\n         EX    TEMP,PUTCMVC        MOVE REMAINDER\n         LA    X2,1(TEMP,X2)       NEXT FREE SLOT\nPUTCON10 DS    0H\n         L     R1,BUFF3AD          START OF WORK AREA\n         SR    X2,R1               LENGTH OF RESULT\n         STH   X2,0(,R1)           SET RESULTING LENGTH\n         SPACE\nPUTCON11 DS    0H\n        $IFON  TTYPE,TFILE,PUTCON12     BRANCH IF OUTPUT TO A FILE\n         MVC   SAVEH0,0(R1)        ALIGN RECORD LENGTH\n         LH    R0,SAVEH0           RECORD LENGTH INCL RDW\n         S     R0,F4               LENGTH OF DATA\n         LA    R1,4(,R1)           POINTER TO DATA\n        $CALL  SYCONSW             LET HIM PRINT IT\n         B     PUTCON13            AND CONTINUE\nPUTCON12 DS    0H\n         LR    R0,R1               POINT TO RDW\n        $CALL  PUTPRT              AND CALL PRINT FILE ROUTINE\n         SPACE\nPUTCON13 DS    0H\n        $CC    POS                 ALL COMPLETE\n         SPACE\nPUTCON14 DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              DIABLO TERMINAL CONVERSION TABLES                      *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        INPUT CHARACTERS --  X'04'  TRANSLATE TO DIABOUT\n*                             X'08'  SUPERSCRIPT TRANSLATE TO DIABOUT\n*                             X'0C'  SUBSCRIPT TRANSLATE TO DIABOUT\n         SPACE\n         DC    0D'0'               ALIGN TRANSLATE TABLES\nDIABIN   DC    256AL1(0)           INPUT DIABLO CHARACTERS\n         ORG   DIABIN+X'00'\n         DC    X'04'                    NULL CHARACTER\n         ORG   DIABIN+X'8F'\n         DC    X'04'                    LINE INTERSECTION\n         ORG   DIABIN+X'AB'\n         DC    2X'04'                   UPPER CORNERS\n         ORG   DIABIN+X'BB'\n         DC    2X'04'                   LOWER CORNERS\n         ORG   DIABIN+X'BF'\n         DC    X'04'                    HORIZONTAL LINE\n         ORG   DIABIN+X'B0'\n         DC    10X'08'                  SUPER NUMERICS\n         ORG   DIABIN+X'8D'\n         DC    X'08'                    SUPER LEFT PAREN\n         ORG   DIABIN+X'9D'\n         DC    X'08'                    SUPER RIGHT PAREN\n         ORG   DIABIN+X'8E'\n         DC    X'08'                    SUPER PLUS\n         ORG   DIABIN+X'A0'\n         DC    X'08'                    SUPER MINUS\n         ORG   DIABIN+X'80'\n         DC    X'0C'                    SUB ZERO\n         ORG   DIABIN+X'51'\n         DC    9X'0C'                   SUB NUMERICS\n         ORG   DIABIN+X'DC'\n         DC    X'0C'                    SUB LEFT PAREN\n         ORG   DIABIN+X'CC'\n         DC    X'0C'                    SUB RIGHT PAREN\n         ORG   DIABIN+X'CA'\n         DC    X'0C'                    SUB PLUS\n         ORG   DIABIN+X'CB'\n         DC    X'0C'                    SUB MINUS\n         ORG   DIABIN+X'AF'\n         DC    X'04'                    BULLET\n         ORG   ,\n         SPACE\nDIABOUT  DC    256AL1(*-DIABOUT)   OUTPUT DIABLO CHARACTERS\n         ORG   DIABOUT+X'00'\n         DC    C' '                     NULL CHARACTER\n         ORG   DIABOUT+X'8F'\n         DC    C'+'                     LINE INTERSECTION\n         ORG   DIABOUT+X'AB'\n         DC    C'++'                    UPPER CORNERS\n         ORG   DIABOUT+X'BB'\n         DC    C'++'                    LOWER CORNERS\n         ORG   DIABOUT+X'BF'\n         DC    C'-'                     HORIZONTAL LINE\n         ORG   DIABOUT+X'B0'\n         DC    C'0123456789'            SUPER NUMERICS\n         ORG   DIABOUT+X'8D'\n         DC    C'('                     SUPER LEFT PAREN\n         ORG   DIABOUT+X'9D'\n         DC    C')'                     SUPER RIGHT PAREN\n         ORG   DIABOUT+X'8E'\n         DC    C'+'                     SUPER PLUS\n         ORG   DIABOUT+X'A0'\n         DC    C'-'                     SUPER MINUS\n         ORG   DIABOUT+X'80'\n         DC    C'0'                     SUB ZERO\n         ORG   DIABOUT+X'51'\n         DC    C'123456789'             SUB NUMERICS\n         ORG   DIABOUT+X'DC'\n         DC    C'('                     SUB LEFT PAREN\n         ORG   DIABOUT+X'CC'\n         DC    C')'                     SUB RIGHT PAREN\n         ORG   DIABOUT+X'CA'\n         DC    C'+'                     SUB PLUS\n         ORG   DIABOUT+X'CB'\n         DC    C'-'                     SUB MINUS\n         ORG   DIABOUT+X'AF'\n         DC    C'*'                     BULLET\n         ORG   ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PUTPRT": {"ttr": 9990, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00M\\x00M\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 77, "newlines": 77, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              'PUTPRT' --- I/O ROUTINE TO PRINT FILE                 *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R0)=0 AND IOCBPRT=0 TO OPEN FILE\n*                      (R0)>0 ADDRESS OF DATA TO PUT DATA\n*                      (R0)<0 TO CLOSE FILE\n*\n*        ON EXIT   --  CC = BPOS  IF OK\n*                         = BNEG  IF ERROR\n         SPACE\nPUTPRT  $ENTER ,\n         L     X1,IOCBPRT          SYSPRINT IOCB ADDRESS\n         LTR   R0,R0               TEST CALL TYPE\n         BP    PPRT04              BRANCH IF PUT CALL\n         BM    PPRT02              BRANCH IF CLOSE CALL\n         LTR   X1,X1               FILE TRIED BEFORE .Q\n         BNZ   PPRT06              YES, DON'T DO IT AGAIN\n         SPACE\n         MVI   IOCBPRT,X'80'       MARK ADDR TRIED\n         LA    TEMP,SAVED0         POINT TO SHORT WORK AREA\n         USING IOCIODEF,TEMP       IODEF LOOKS LIKE THIS\n         MVC   IOCIODEF(PPIODEFL),PPIODEF  FRESH IODEF\n         LA    R1,IOCDDNAM         POINTER TO FILENAME\n        $CALL  RDDDREP             REPLACEMENT FILENAME .Q\n         MVC   IOCDDNAM,0(R1)      ENTER REQUIRED NAME\n         SPACE\n         LA    R1,IOCDDNAM         POINT AGAIN\n        $CALL  SYTEST              CAN OPEN SUCCEED .Q\n         BC    BNEG,PPRT01         BRANCH IF NOT\n         LA    R1,IOCIODEF         POINT TO IODEF\n        $CALL  SYPUTOP             OPEN OUTPUT FILE\n         ST    R1,IOCBPRT          SAVE IOCB ADDRESS\n         BC    BPOS,PPRT01         CONTINUE IF SUCCESSFUL\n         MVI   IOCBPRT,X'80'       TRIED AND FAILED\nPPRT01   DS    0H\n         DROP  TEMP\n         TM    IOCBPRT,X'80'       TRIED AND SUCCEEDED .Q\n         BZ    PPRT05              BRANCH IF YES\n         B     PPRT06              ELSE SET FOR FAILURE\n         SPACE\n         USING IOCB,X1             FILE CONTROL BLOCK\nPPRT02   DS    0H\n         LA    X1,0(,X1)           CLEAR HIGH BYTE\n         LTR   X1,X1               DOES FILE EXIST .Q\n         BZ    PPRT03              BRANCH IF NOT\n         LA    R1,IOCB             IOCB ADDRESS\n        $CALL  SYPUTCL             CLOSE OUTPUT FILE\nPPRT03   DS    0H\n         XC    IOCBPRT,IOCBPRT     CLEAR IOCB POINTER\n         B     PPRT05              GO TO SUCCESSFUL EXIT\n         SPACE\nPPRT04   DS    0H\n         LA    X1,0(,X1)           CLEAR HIGH BYTE\n         LTR   X1,X1               DOES FILE EXIST .Q\n         BZ    PPRT05              BRANCH IF NOT\n         LA    R1,IOCB             IO CONTROL BLOCK\n        $CALL  SYPUT               OUTPUT THE RECORD\n         DROP  X1\n         SPACE\nPPRT05   DS    0H\n        $CC    POS                 ALL IS SUCCESSFUL\n         B     PPRT07              GO TO RETURN\n         SPACE\nPPRT06   DS    0H\n        $CC    NEG                 UNSUCCESSFUL\n         SPACE\nPPRT07   DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nPPIODEF  SYSIODEF FILETYP=IOC$QSAM,DDNAME=SYSPRINT,                    *\n               RECFM=IOCRECV+IOCRECCA,                                 *\n               RECMERG=IOCRECF+IOCRECV+IOCRECBR+IOCRECCA,              *\n               LRECL=137,MAXLREC=240\nPPIODEFL EQU   *-PPIODEF           LENGTH OF IODEF\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PUTTERM": {"ttr": 9993, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00M\\x00M\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 77, "newlines": 77, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              'PUTTERM' --- I/O ROUTINE TO ERROR FILE                *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R0)=0 AND IOCBTERM=0 TO OPEN FILE\n*                      (R0)>0 ADDRESS OF DATA TO PUT DATA\n*                      (R0)<0 TO CLOSE FILE\n*\n*        ON EXIT   --  CC = BPOS  IF OK\n*                         = BNEG  IF ERROR\n         SPACE\nPUTTERM $ENTER ,\n         L     X1,IOCBTERM         SYSTERM IOCB ADDRESS\n         LTR   R0,R0               TEST CALL TYPE\n         BP    PTRM04              BRANCH IF PUT CALL\n         BM    PTRM02              BRANCH IF CLOSE CALL\n         LTR   X1,X1               FILE TRIED BEFORE .Q\n         BNZ   PTRM06              YES, DON'T DO IT AGAIN\n         SPACE\n         MVI   IOCBTERM,X'80'      MARK ADDR TRIED\n         LA    TEMP,SAVED0         POINT TO SHORT WORK AREA\n         USING IOCIODEF,TEMP       IODEF LOOKS LIKE THIS\n         MVC   IOCIODEF(PTIODEFL),PTIODEF  FRESH IODEF\n         LA    R1,IOCDDNAM         POINTER TO FILENAME\n        $CALL  RDDDREP             REPLACEMENT FILENAME .Q\n         MVC   IOCDDNAM,0(R1)      ENTER REQUIRED NAME\n         SPACE\n         LA    R1,IOCDDNAM         POINT AGAIN\n        $CALL  SYTEST              CAN OPEN SUCCEED .Q\n         BC    BNEG,PTRM01         BRANCH IF NOT\n         LA    R1,IOCIODEF         POINT TO IODEF\n        $CALL  SYPUTOP             OPEN OUTPUT FILE\n         ST    R1,IOCBTERM         SAVE IOCB ADDRESS\n         BC    BPOS,PTRM01         CONTINUE IF SUCCESSFUL\n         MVI   IOCBTERM,X'80'      TRIED AND FAILED\nPTRM01   DS    0H\n         DROP  TEMP\n         TM    IOCBTERM,X'80'      TRIED AND SUCCEEDED .Q\n         BZ    PTRM05              BRANCH IF YES\n         B     PTRM06              ELSE SET FOR FAILURE\n         SPACE\n         USING IOCB,X1             FILE CONTROL BLOCK\nPTRM02   DS    0H\n         LA    X1,0(,X1)           CLEAR HIGH BYTE\n         LTR   X1,X1               DOES FILE EXIST .Q\n         BZ    PTRM03              BRANCH IF NOT\n         LA    R1,IOCB             IOCB ADDRESS\n        $CALL  SYPUTCL             CLOSE OUTPUT FILE\nPTRM03   DS    0H\n         XC    IOCBTERM,IOCBTERM   CLEAR IOCB POINTER\n         B     PTRM05              GO TO SUCCESSFUL EXIT\n         SPACE\nPTRM04   DS    0H\n         LA    X1,0(,X1)           CLEAR HIGH BYTE\n         LTR   X1,X1               DOES FILE EXIST .Q\n         BZ    PTRM05              BRANCH IF NOT\n         LA    R1,IOCB             IO CONTROL BLOCK\n        $CALL  SYPUT               OUTPUT THE RECORD\n         DROP  X1\n         SPACE\nPTRM05   DS    0H\n        $CC    POS                 ALL IS SUCCESSFUL\n         B     PTRM07              GO TO RETURN\n         SPACE\nPTRM06   DS    0H\n        $CC    NEG                 UNSUCCESSFUL\n         SPACE\nPTRM07   DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nPTIODEF  SYSIODEF FILETYP=IOC$QSAM,DDNAME=SYSTERM,                     *\n               RECFM=IOCRECV+IOCRECCA,                                 *\n               RECMERG=IOCRECF+IOCRECV+IOCRECBR+IOCRECCA,              *\n               LRECL=137,MAXLREC=240\nPTIODEFL EQU   *-PTIODEF           LENGTH OF IODEF\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PUWORK": {"ttr": 9996, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00Q\\x00Q\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 81, "newlines": 81, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              'PUWORK'  --  WORKFILE SUBROUTINE                      *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R1) = FILE NUMBER\n*                      (R0) = ZERO MEANS CLOSE REQUEST\n*                           > ZERO MEANS RDW POINTER\n         SPACE\nPUWORK  $ENTER ,\n         LR    X1,R1               GET FILE NUMBER\n         CVD   X1,DECM             SAVE FILE NUMBER AGAIN\n         SLL   X1,2                FILE NUMBER TIMES FOUR FOR OFFSET\n         A     X1,PUIOCBPT         IOCB ADDRESS POINTER\n         L     TEMP,0(,X1)         IOCB ADDRESS\n         SPACE\n         LTR   X3,R0               IS THIS A CLOSE REQUEST .Q\n         BZ    PUWK03              BRANCH IF YES\n         LTR   TEMP,TEMP           IOCB PRESENT FOR PUT .Q\n         BNZ   PUWK02              BRANCH IF YES\n         SPACE\n         LA    R1,PUIODEFL         WORK LENGTH REQUIRED FOR IDOEF\n        $CALL  GETCELL             GET AN IODEF WORK AREA\n         BC    BNEG,PUWKE024       FORGET IT IF NO SPACE\n         USING IOCIODEF,TEMP       IODEF LOOKS LIKE THIS\n         MVC   IOCIODEF(PUIODEFL),PUIODEF  ENTER A FRESH IODEF\n         MVC   IOCDDNAM(8),PUDDNAME     SET BASIC DDNAME\n         OI    DECM+7,X'0F'        FIX THE FILE NUMBER SIGN\n         UNPK  IOCDDNAM+6(2),DECM+6(2)  ENTER THE DDNAME SUFFIX\n         SPACE\n         MVI   0(X1),X'80'         MARK FILE TRIED BUT UNSUCCESSFUL\n         LA    R1,IOCDDNAM         POINT TO DDNAME\n        $CALL  SYTEST              CAN THE OPEN SUCCEED .Q\n         BC    BNEG,PUWKE058       BRANCH IF NOT\n         SPACE\n         LA    R1,IOCIODEF         POINT TO THE IODEF\n        $CALL  SYPUTOP             OPEN OUTPUT FILE\n         BC    BNEG,PUWKE058       BRANCH IF OPEN FAILED\n         ST    R1,0(,X1)           SAVE IOCB ADDRESS\nPUWK01   DS    0H\n         LA    R0,IOCIODEF         PATTERN IODEF\n         LA    R1,PUIODEFL         LENGTH OF SAME\n        $CALL  FREECELL            RELEASE WORK AREA\n         DROP  TEMP\n         SPACE\nPUWK02   DS    0H\n         L     TEMP,0(,X1)         IOCB ADDRESS\n         LA    TEMP,0(,TEMP)       CLEAR HIGH BYTE\n         LTR   TEMP,TEMP           ANY FILE PRESENT .Q\n         BZ    PUWK05              BRANCH IF NOT\n         SPACE\n         USING IOCB,TEMP           IO CONTROL BLOCK DESCRIPTOR\n         LA    R1,IOCB             IO CONTROL BLOCK\n         LR    R0,X3               OIUBT TI DATA\n        $CALL  SYPUT               OUTPUT THE RECORD\n         B     PUWK05              GO TO RETURN\n         SPACE\nPUWK03   DS    0H\n         LA    TEMP,0(,TEMP)       CLEAR HIGH BYTE\n         LTR   TEMP,TEMP           IOCB PRESENT .Q\n         BZ    PUWK04              BRANCH IF NOT\n         LA    R1,IOCB             IOCB ADDRESS\n        $CALL  SYPUTCL             CLOSE OUTPUT FILE\nPUWK04   DS    0H\n         XC    0(4,X1),0(X1)       CLEAR IOCB POINTER\n         DROP  TEMP\nPUWK05   DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nPUWKE024 DS    0H\n         MVI   EFLAG024,ERRSET     NO CORE FOR IODEF\n         B     PUWK05              GO TO RETURN\nPUWKE058 DS    0H\n         MVI   EFLAG058,ERRSET     CANNOT OPEN WORK FILE\n         B     PUWK01              FREE WORK BLOCK\n         SPACE\nPUIODEF  SYSIODEF FILETYP=IOC$QSAM,DDNAME=**,                          *\n               RECFM=IOCRECV,RECMERG=IOCRECF+IOCRECV+IOCRECBR,         *\n               LRECL=136,MAXLREC=240\nPUIODEFL EQU   *-PUIODEF           LENGTH!OF IODEF\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PV": {"ttr": 9999, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .PV (EVEN PAGE FORCE) --- CONTROL                      *\n*              .EP (EVEN PAGE EJECT) --- CONTROL                      *\n*                                                                     *\n***********************************************************************\n         SPACE\nPV      $ENTER ,\n         CLI   ICORFLG,ICORNONE    SAVING FORMATTED TEXT INCORE .Q\n         BNE   PVE012              ERROR IF YES\n        $IFOFF SWITCHS,PINCRNO,PV01     BRANCH IF PAGES NOT INCREASING\n        $CALL  PA                  ELSE JUST A PAGE EJECT\n         B     PV03                TAKE COMMON EXIT\n         SPACE\nPV01     DS    0H\n        $CALL  PRINTNB             FORCE A BREAK\n        $CALL  ODDEVN              WHAT KIND OF PAGE ARE WE ON .Q\n         BC    BNEG,PV02           IF ODD, ONE SKIP ONLY\n        $CALL  PAGEREAL            EVEN, SKIP TO ODD PAGE\nPV02     DS    0H\n        $CALL  PAGEREAL            SKIP TO EVEN PAGE\nPV03     DS    0H\n        $EXIT  RC=0                GET NEXT LINE\n         SPACE\nPVE012   DS    0H\n         MVI   EFLAG012,ERRSET     ILLEGAL PLACEMENT OF CONTROL WORD\n         B     PV03                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#QQ": {"ttr": 10001, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x13\\x00\\x13\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .QQ (QUIT QUICKLY) --- CONTROL                         *\n*                                                                     *\n***********************************************************************\n         SPACE\nQQ      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT LINE\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BOMIT+BPOS,QQ02     BRANCH IF THIS IS THE END\n         BC    BNEG,QQ01           BRANCH IF FUNCTION IS SUPPRESSED\n         MVI   EFLAG005,ERRSET     INVALID OPERAND FLAG\nQQ01     DS    0H\n         SR    R15,R15             SET RETURN CODE\n         B     QQ03                TAKE COMMON EXIT\nQQ02     DS    0H\n         LA    R15,WRETQQ          SET TERMINAL RETURN CODE\nQQ03     DS    0H\n        $EXIT  RC=(R15)            RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#QT": {"ttr": 10003, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x13\\x00\\x13\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .QT (QUIT) --- CONTROL                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nQT      $ENTER ,\n        $CALL  PRINTNB             CLEAR ANY PRINT LINE\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BOMIT+BPOS,QT02     BRANCH IF THIS IS THE END\n         BC    BNEG,QT01           BRANCH IF FUNCTION IS SUPPRESSED\n         MVI   EFLAG005,ERRSET     INVALID OPERAND FLAG\nQT01     DS    0H\n         SR    R15,R15             SET RETURN CODE\n         B     QT03                TAKE COMMON EXIT\nQT02     DS    0H\n         LA    R15,WRETQT          SET TERMINAL RETURN CODE\nQT03     DS    0H\n        $EXIT  RC=(R15)            RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#QUITS": {"ttr": 10005, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              QUITS SUBROUTINE                                       *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R1) CONTAINS TERMINATION CODE\n         SPACE\nQUITS   $ENTER ,\n         L     RETURN,VTRUEEND     TERMINATION ROUTINE ADDRESS\n         L     BASESAVE,SAVEINIT   INITIAL SAVE STACK ADDRESS\n         LA    BASESAVE,SAVELEN(,BASESAVE)   DOWN ONE LEVEL\n         ST    RETURN,RETURN*4(,BASESAVE)    ENTER RETURN ADDRESS\n         LR    R15,R1              TERMINATION CODE\n        $EXIT  RC=(R15)            RETURN TO SCRIPT DRIVER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RA": {"ttr": 10241, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .RA (RIGHT ADJUST) --- CONTROL                         *\n*              .RI (RIGHT ADJUST) --- CONTROL                         *\n*                                                                     *\n***********************************************************************\n         SPACE\nRA      $ENTER ,\n        $ON    SWITCHS,RASWS       TURN ON RIGHT ADJUST SWITCH\n        $OFF   SWITCHS,CESWS       TURN OFF CENTER SWITCH\n        $CALL  CELARA              REST IS LIKE CENTER\n        $EXIT  RC=(R15)            RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RC": {"ttr": 10243, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x01\\x0e\\x01\\x0e\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 270, "newlines": 270, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .RC (REVISION CODE) --- CONTROL                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nRC      $ENTER ,\n         L     X1,RCAREAAD         GET ADDR OF REV CODE AREA\n         LTR   X1,X1               DOES IT EXIST .Q\n         BNZ   RC01                BRANCH IF YES\n        $CALL  RCAGET              GET SUCH A WORK AREA\n         BC    BNEG,RC12           IF FAILURE, JUST RETURN\n         L     X1,RCAREAAD         ADDR OF REV CODE WORK AREA\n         SPACE\nRC01     DS    0H\n         USING RCAREA,X1           WORK AREA LOOKS LIKE THIS\n         CLC   RCANFCNT,H1         RC ON/OFF TRIGGERED YET .Q\n         BH    RCE04               ERROR IF NOT\n         BL    RC02                BRANCH IF NOTHING THERE\n        $CALL  RCOFF               CLEAR CURRENT RC\n         XC    RCANFCNT,RCANFCNT   CLEAR REMAINDER\nRC02     DS    0H\n        $CALL  GETNUM              GET NUMERIC ARGUMENT\n         BC    BOMIT,RCE01         ERROR IF OMITTED\n         BC    BDNO,RCE02          ERROR IF INVALID\n         LTR   X3,COUNT            TOO SMALL .Q\n         BNP   RCE06               ERROR IF YES\n         LA    R1,RCAMAX           MAX VALUE +1\n         CR    X3,R1               TOO BIG .Q\n         BNL   RCE05               ERROR IF YES\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BOMIT,RC11          BRANCH IF OMITTED TO RESET\n         BC    BNEG,RC10           BRANCH IF NEGATIVE\n         BC    BPOS,RC08           BRANCH IF POSITIVE\n         CLI   YNRESULT,YNMBE      WAS IT BOTH AS IN 'ON/OFF' .Q\n         BE    RC07                BRANCH IF YES\n         CLI   YNRESULT,YNSET      WAS OPERAND 'SET' .Q\n         BNE   RC03                BRANCH IF NOT\n         SPACE\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION ON OPERAND\n        $CALL  GETQST              GET STRING OPERAND\n         BC    BOMIT,RC11          BRANCH IF OMITTED TO RESET\n         CLC   QSTRING,F2          DELIMITED START AND END .Q\n         BNE   RC04                BRANCH IF NOT\n         LA    COUNT,1(,COUNT)     POINT TO START\n         S     TEMP,QSTRING        NEW LENGTH-1\n         BM    RC11                BRANCH IF ONLY NULL LEFT\n         B     RC04                 CONTINUE\n         SPACE\nRC03     DS    0H\n         LTR   TEMP,TEMP           SINGLE REVISION CODE CHAR .Q\n         BNZ   RCE02               ERROR IF NOT\nRC04     DS    0H\n         CH    X3,RCACURR          IS THIS NUMBER CURRENT .Q\n         BE    RCE04               YES, ERROR\n         LA    R1,L'RCATABLE       LENGTH OF ONE ENTRY\n         MR    R0,X3               TABLE OFFSET\n         LA    R1,RCATABLE(R1)     POINT TO ENTRY\n         MVC   0(L'RCATABLE,R1),BLANKS  FIRST CLEAR TO BLANKS\n         LA    R0,L'RCATABLE-1     MAX STRING LENGTH -1\n         CR    R0,TEMP             IS ACTUAL SHORTER .Q\n         BH    RC05                BRANCH IF YES\n         LR    TEMP,R0             USE THE MAX INSTEAD\nRC05     DS    0H\n         LA    R1,L'RCATABLE-1(,R1)     BUMP AHEAD TO END OF FIELD\n         SR    R1,TEMP             POINT TO TARGET\n         EX    TEMP,RCMVC          ENTER REVISION STRING\n         SPACE\n         LA    R1,RCADJCNT         MINIMUM RC ADJUST COUNT\n         CH    R1,ADJCNT           ENOUGH ROOM .Q\n         BNH   RC06                BRANCH IF YES\n         STH   R1,ADJCNT           SET THE MINIMUM\nRC06     DS    0H\n         B     RC12                GO TO RETURN\n         SPACE\nRCMVC    MVC   0(*-*,R1),0(COUNT)  ENTER REVISION CODE STRING\n         SPACE\nRC07     DS    0H\n         MVC   RCANFCNT,H2         SET ON/OFF TRIGGER\n         SPACE\nRC08     DS    0H\n         LTR   TEMP,TEMP           ARGUMENT LENGTH-1 ZERO .Q\n         BZ    RC03                YES, TREAT AS CHARACTER\n         CH    X3,RCACURR          IS THIS RC ALREADY ON .Q\n         BE    RCE04               ERROR IF YES\n         OC    RCACURR,RCACURR     ANY OTHER CODE NOW ON .Q\n         BZ    RC09                BRANCH IF NOT\n         LH    COUNT,RCASTKOF      CURRENT RCSTACK OFFSET\n         LA    R0,RCAMAX           THE MAX ALLOWED\n         CR    COUNT,R0            COMPARE\n         BNL   RCE03               STACK OVERFLOW\n         LR    R0,COUNT            TRANSFER CURRENT OFFSET\n         A     R0,F1               UPDATE CURRENT STACK\n         STH   R0,RCASTKOF         PUT UPDATED RESULT BACK\n         SPACE\n         LA    R1,L'RCASTACK       LENGTH OF NUMBER ENTRY\n         MR    R0,COUNT            TIMES OFFSET COUNT\n         LA    R1,RCASTACK(R1)     POINT TO NEXT NUMBER ENTRY\n         MVC   0(L'RCASTACK,R1),RCACURR SAVE CURRENT REV CODE\n         LA    R1,L'RCASTKCR       LENGTH OF SAVED REV CODE STRING\n         MR    R0,COUNT            TIMES OFFSET NUMBER\n         LA    R1,RCASTKCR(R1)     POINT TO NEXT FREE ENTRY\n         MVC   0(L'RCASTKCR,R1),RCACHAR SAVE CURRENT REV CODE STRING\n         SPACE\nRC09     DS    0H\n         STH   X3,RCACURR          SET CURRENT REVISION NUMBER\n         LA    R1,L'RCATABLE       LENGTH OF ONE REV CODE STRING\n         MR    R0,X3               TIMES REV CODE NUMBER\n         LA    R1,RCATABLE(R1)     POINT TO REV CODE STRING\n         MVC   RCACHAR,0(R1)       NEW CURRENT REV CODE STRING\n         B     RC12                BACK TO RETURN\n         SPACE\nRC10     DS    0H\n         LTR   TEMP,TEMP           ARGUMENT LENGTH-1 ZERO .Q\n         BZ    RC03                YES, TREAT AS CHARACTER\n         CH    X3,RCACURR          IS THIS ONE NOW ON .Q\n         BNE   RCE04               ERROR IF NOT\n        $CALL  RCOFF               ELSE REMOVE SAME\n         B     RC12                AND GO TO RETURN\n         SPACE\nRC11     DS    0H\n         LA    R1,L'RCATABLE       TABLE LENGTH OF EACH REV CODE STRING\n         MR    R0,X3               OFFSET INTO TABLE\n         LA    R1,RCATABLE(R1)     POINT TO REVISION CODE\n         CLC   0(L'RCATABLE,R1),BLANKS  IS REV CODE DEFINED .Q\n         BE    RCE04               ERROR IF NOT\n         CH    X3,RCACURR          IS CODE CURRENTLY ACTIVE .Q\n         BE    RCE04               ERROR IF YES\n         MVC   0(L'RCATABLE,R1),BLANKS  CLEAR REVISION CODE\n         SPACE\nRC12     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         DROP  X1\n         SPACE\nRCE01    DS    0H\n         MVI   EFLAG003,ERRSET     OMITTED OPERAND\n         B     RC12                GO TO RETURN\nRCE02    DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     RC12                GO TO RETURN\nRCE03    DS    0H\n         MVI   EFLAG011,ERRSET     STACK OVERFLOW\n         B     RC12                GO TO RETURN\nRCE04    DS    0H\n         MVI   EFLAG012,ERRSET     ILLEGAL PLACEMENT\n         B     RC12                GO TO RETURN\nRCE05    DS    0H\n         MVI   EFLAG013,ERRSET     OPERAND TOO LARGE\n         B     RC12                GO TO RETURN\nRCE06    DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     RC12                GO TO RETURN\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              RCOFF --- REVISION CODE OFF ROUTINE                    *\n*                                                                     *\n***********************************************************************\n         SPACE\nRCOFF   $ENTER ,\n         L     X1,RCAREAAD         REV CODE WORK AREA\n         LTR   X1,X1               DOES IT EXIST .Q\n         BZ    RCOFF03             BRANCH IF NOT\n         SPACE\n         USING RCAREA,X1           AREA LOOKS LIKE THIS\n         OC    OLDCOUNT,OLDCOUNT   ANYTHING IN PRINT BUFFER .Q\n         BZ    RCOFF01             BRANCH IF NOT\n         MVC   RCASTALL,RCACHAR    YES, PUT OFF RESULT FOR ONE LINE\nRCOFF01  DS    0H\n         LH    R1,RCASTKOF         GET REV CODE STACK OFFSET\n         S     R1,F1               DECREMENT BY ONE\n         BM    RCOFF02             BRANCH IF STACK EMPTY\n         STH   R1,RCASTKOF         UPDATE STACK OFFSET\n         LA    X3,L'RCASTACK       LENGTH OF ONE STACK ENTRY\n         MR    X2,R1               STACK OFFSET\n         LA    X3,RCASTACK(X3)     FORMER REV CODE POINTER\n         MVC   RCACURR,0(X3)       RESTORE FORMER REV CODE NUMBER\n         LA    X3,L'RCASTKCR       LENGTH OF ONE REV CHAR STRING\n         MR    X2,R1               CHARACTER STACK OFFSET\n         LA    X3,RCASTKCR(X3)     POINT TO REV CODE\n         MVC   RCACHAR,0(X3)       RESTORE REV CODE CHAR STRING\n         B     RCOFF03             GO TO RETURN\n         SPACE\nRCOFF02  DS    0H\n         XC    RCACURR,RCACURR     SET CURRENT REV NUMBER TO ZERO\n         MVC   RCACHAR,BLANKS      BLANK REVISION CHAR STRING\n         SPACE\nRCOFF03  DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         DROP  X1\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              RCAGET --- GET A REVISION CODE WORK AREA               *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON EXIT  --  CC = BPOS  IF SUCCESS\n*                     CC = BNEG  IF FAILURE\n         SPACE\nRCAGET   $ENTER ,\n         L     TEMP,RCAREAAD       REV CODE AREA POINTER\n         LTR   TEMP,TEMP           DOES IT EXIST .Q\n         BNZ   RCAG01              BRANCH IF YES\n         SPACE\n         LA    R1,RCALEN           LENGTH WE NEED\n        $CALL  GETCELL             GET AN AREA\n         BC    BNEG,RCAGE024       BRANCH IF FAILED\n         ST    TEMP,RCAREAAD       RETAIN AREA POINTER\n        $CALL  RCAINIT             INITIALIZE NEW AREA\nRCAG01   DS    0H\n        $CC    POS                 INDICATE SUCCESS\n         SPACE\nRCAG02   DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nRCAGE024 DS    0H\n         MVI   EFLAG024,ERRSET     NO SPACE FOR REV CODE AREA\n        $CC    NEG                 INDICATE FAILURE\n         B     RCAG02              GO TO EXIT\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              RCAINIT  ---  INITIALIZE REVISION CODE WORK AREA       *\n*                                                                     *\n***********************************************************************\n         SPACE\nRCAINIT $ENTER ,\n         L     X1,RCAREAAD         WORK AREA ADDRESS\n         LTR   X1,X1               IS IT PRESENT .Q\n         BZ    RCAI02              BRANCH IF NOT\n         USING RCAREA,X1           TELL THE ASSEMBLER\n         XC    RCASTKOF,RCASTKOF   CLEAR RCA STACK OFFSET\n         XC    RCACURR,RCACURR     CLEAR CURRENT REVISION CODE NUMBER\n         XC    RCANFCNT,RCANFCNT   CLEAR ON/OFF COUNT LEFT\n         SPACE\n         MVC   RCACHAR,BLANKS      BLANK CURRENT REVISION CODE\n         MVC   RCASTALL,BLANKS     BLANK STALLED REVISION CODE\n         SPACE\n         LA    R1,RCAMAX           TOTAL REVISIONS POSSIBLE\n         LA    TEMP,RCATABLE       POINT TO THE FIRST\nRCAI01   DS    0H\n         MVC   0(L'RCATABLE,TEMP),BLANKS     CLEAR ONE\n         LA    TEMP,L'RCATABLE(,TEMP)   POINT TO NEXT\n         BCT   R1,RCAI01           CLEAR THEM ALL\n         DROP  X1\n         SPACE\nRCAI02   DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              RCAFREE  ---  FREE A REVISION CODE WORK AREA           *\n*                                                                     *\n***********************************************************************\n         SPACE\nRCAFREE $ENTER ,\n         L     X1,RCAREAAD         ADDRESS OF REV CODE AREA\n         LTR   X1,X1               IS IT PRESENT .Q\n         BZ    RCAF01              BRANCH IF NOT\n         SPACE\n         USING RCAREA,X1           TELL THE ASSEMBLER\n         LA    R0,RCAREA           AREA TO FREE\n         LA    R1,RCALEN           LENGTH OF AREA\n        $CALL  FREECELL            FREE THE AREA\n         DROP  X1\n         XC    RCAREAAD,RCAREAAD   ZERO WORK POINTER\n         SPACE\nRCAF01   DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RD": {"ttr": 10248, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x007\\x007\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .RD (READ TERMINAL) --- POST A TERMINAL READ           *\n*                                                                     *\n***********************************************************************\n         SPACE\nRD      $ENTER ,\n        $IFON  TTYPE,TONLINE,RD01  BRANCH IF ONLINE\n        $CALL  SP                  OFFLINE PROCESS LIKE .SP\n         B     RD05                GO TO EXIT\n         SPACE\nRD01     DS    0H\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n        $CALL  GETNUM              GET COUNT FROM ARGUMENT\n         BC    BNEG+BDNO,RDE005    ERROR IF NEGATIVE OR INVALID\n         LTR   COUNT,COUNT         TEST RESULT\n         BNP   RD05                BRANCH IF NOT POSITIVE\n         SPACE\n         ST    COUNT,CONSMAX       STORE COUNT IN PARM BLOCK\n         XC    CONSFLAG,CONSFLAG   CLEAR CONSOLE FLAGS\n        $ON    CONSFLAG,IO$JIGG    SPECIFY 'JIGGLE' TYPE BALL\n        $ON    CONSFLAG,IO$UEOF    IGNORE ALL EOFS\n        $ON    CONSFLAG,IO$IM      AND IMBED THIS FILE\n         MVC   CONSGOTO,BLANKS     CLEAR GOTO TARGET\n         SPACE\n         LA    R1,CONSBLOK         'IMBED' THE CONSOLE FILE\n        $CALL  RDFILE              CALL INPUT SUPERVISOR\n         SPACE\nRD02     DS    0H\n         LH    TEMP,PLCT           ACCOUNT FOR RD SPACES\n         BCTR  TEMP,0              ..\n         CH    TEMP,RMTRIG         SHOULD REMOTE BE TRIGGERED .Q\n         BNE   RD03                IF NOT, SKIP\n         LH    R1,RMTRIG           REMOTE TO IMBED\n        $CALL  RMIMBED             YES, GO IMBED THE REMOTE SEQUENCE\n         B     RD02                BACK TO ACCOUNT FOR SPACE\nRD03     DS    0H\n         LH    R1,BMMRG            CURRENT BOTTOM MARGIN\n         AH    R1,FNSEP            PLUS FOOTNOTE MARGIN\n         CR    TEMP,R1             BELOW BOTTOM MARGIN\n         BNL   RD04                IF NOT, SKIP AHEAD\n        $CALL  PAGE                CAUSE PAGE EJECT\n         B     RD02                GO DECREMENT LINE CTR\n         SPACE\nRD04     DS    0H\n         STH   TEMP,PLCT           STORE UPDATED LINE COUNT\n        $CALL  TERMREAD            READ ONE LINE\n         CLI   1(R1),X'00'         IS IT A NULL RECORD .Q\n         BNE   RD02                IF NOT, TAKE LINE INTO ACCOUNT\nRD05     DS    0H\n        $EXIT  RC=0                BACK TO MAIN CONTROL\n         SPACE\nRDE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     RD05                GO TO EXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RDCLOSE": {"ttr": 10250, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x004\\x004\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              TO CLOSE A FILE                                        *\n*                                                                     *\n***********************************************************************\n         SPACE\n*  THIS ROUTINE CLOSES AND FREES THE CURRENT DDBLOCK IF               *\n*        1)    IT HAS A ZERO USAGE COUNT                              *\n*AND     2)    THE NEVER CLOSE OPTION HAS NOT BEEN SPECIFIED          *\n*              FOR IT.                                                *\n*                                                                     *\n*        IF DDBLOCK POINTER IS IN COMPLEMENT FORM THEN                *\n*        THAT DDBLOCK WILL BE CLOSED UNCONDITIONALLY                  *\n         SPACE 2\nRDCLOSE $ENTER ,\n         LTR   RDD,RDD             IS THERE A CURRENT DDBLOCK .Q\n         BZ    CLOSERET            IF NOT, EXIT AT ONCE\n         BNM   CLOSEIF             BRANCH IF CONDITIONAL CLOSE\n         LPR   RDD,RDD             REAL DDBLOCK POINTER\n         B     CLOSEUNC            DO UNCONDITIONAL CLOSE\n         SPACE\nCLOSEIF  DS    0H\n         OC    DDUSECT,DDUSECT     TEST USAGE COUNT\n         BNZ   CLOSERET            AND EXIT IF NOT ZERO\n         SPACE\n         TM    DDFLAG,DD$NOCLO     WAS NEVER-CLOSE OPTION SELECTED\n         BO    CLOSERET            IF SO, EXIT AT ONCE\n         SPACE\nCLOSEUNC DS    0H\n         LA    RA,DDDCB            SET UP THE OPEN/CLOSE PARAMETER LIST\n         O     RA,OPCLCLSE         INCLUDE CLOSE FLAGS\n         ST    RA,OPCLPARM         AND CLOSE THE DCB IN THIS DDBLOCK\n         CLOSE MF=(E,OPCLPARM)\n         SPACE\n         LM    RA,RB,DDNEXT        SET UP TO REMOVE THIS DDBLOCK\n         LTR   R1,RA               FROM THE DOUBLY LINKED CHAIN\n         BNZ   *+8\n         LA    R1,FIRSTDD\n         ST    RB,DDPREV-DDBLOCK(,R1) UPDTE 'PREV' PTR OF NEXT DDBLOCK\n         SPACE\n         LTR   R1,RB               NOW UPDATE 'NEXT' PTR OF THE PREV DD\n         BNZ   *+8\n         LA    R1,FIRSTDD\n         ST    RA,DDNEXT-DDBLOCK(,R1)\n         SPACE\n         LR    R0,RDD              GET ADDRESS OF THE DDBLOCK\n         LA    R1,DDBLKLN          AND THE LENGTH\n        $CALL  FREECELL            FREE THE STORAGE\n         SPACE\nCLOSERET DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              RETURN TO THE CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RDDDREP": {"ttr": 10252, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00#\\x00#\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              'RDDDREP'  ---  REPLACEMENT FILENAME ROUTINE           *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R1)  POINTS TO FILENAME\n*\n*        ON EXIT   --  (R1)  POINTS TO REPLACEMENT FILENAME\n*                      CC = BPOS  IF REPLACEMENT FOUND\n*                      CC = BNEG  IF NO REPLACEMENT FOUND\n         SPACE\nRDDDREP $ENTER ,\n         L     X1,COMREPAD         POINTER TO REPLACEMENT DDNAME LIST\n         LTR   X1,X1               ANY SUCH LIST .Q\n         BZ    RDREP02             BRANCH IF NOT\n         LH    COUNT,0(,X1)        NUMBER OF NAME PAIRS IN LIST\n         LTR   COUNT,COUNT         ANY PRESENT .Q\n         BNP   RDREP02             BRANCH IF NONE\n         SPACE\n         LA    X1,2(,X1)           ADDR OF FIRST DDNAME PAIR\nRDREP01  DS    0H\n         CLC   0(8,X1),0(R1)       OLD NAME IN LIST .Q\n         BE    RDREP03             BRANCH IF YES\n         LA    X1,16(,X1)          ADDR NEXT PAIR IN LIST\n         BCT   COUNT,RDREP01       GO BACK FOR ANOTHER CHECK\nRDREP02  DS    0H\n        $CC    NEG                 NO REPLACEMENT FOUND\n         B     RDREP04             GO TO EXIT\nRDREP03  DS    0H\n         LA    R1,8(,X1)           NEW NAME IN LIST\n        $CC    POS                 INDICATE SUCCESS\n         SPACE\nRDREP04  DS    0H\n        $EXIT  KEEP=(R1),RC=0      RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RDEJCT": {"ttr": 10254, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x13\\x00\\x13\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*   THIS ROUTINE EJECTS AN ONLINE PAGE WITH 'LINEFE' LINEFEEDS        *\n*                                                                     *\n***********************************************************************\n         SPACE\nRDEJCT  $ENTER ,\n        $IFON  TTYPE,TSCREEN,RDEJCT02   BRANCH IF SCREEN OUTPUT\n         LA    R1,LINEF            POINT TO LINEFEED STRING\n        $IFOFF FILFLAG,FIL$TSO,RDEJCT01 BRANCH IF NOT TSO TERMINAL\n         TPUT  (1),2*LINEFE,ASIS   IDLE-LINEFEED SOME SPACES\n         B     RDEJCT02            AND GO TO RETURN\n         SPACE\nRDEJCT01 DS    0H\n        $IFOFF FILFLAG,FIL$CMS,RDEJCT02 BRANCH IF NOT CMS TERMINAL\n         WRTERM (R1),2*LINEFE,EDIT=NO   IDLE-LINEFEED SOME SPACES\n         SPACE\nRDEJCT02 DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RDERROR": {"ttr": 10256, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*  THIS ROUTINE PRINTS ERROR MESSAGES                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nRDERROR $ENTER ,\n         OC    ERRFLGS,ERRFLGS     ANY ERRORS .Q\n         BZ    RDERR01             BRANCH IF NOT\n         XC    ERRSTART,ERRSTART   CLEAR ERROR POINTER\n        $CALL  ERROUT              PRINT ERROR AND LINE\nRDERR01  DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RDEXIT": {"ttr": 10258, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00D\\x00D\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INPUT FILE OPEN EXIT                                   *\n*                                                                     *\n***********************************************************************\n         SPACE\n*  THIS IS THE DCB EXIT ROUTINE.............IT'S FUNCTIONS ARE TO:    *\n*        1)    ESTABLISH THE DSORG OF THE DCB, IF                     *\n*              THIS DCB IS BEING INITIALLY OPENED                     *\n*        2)    REALLOCATE THE BUFFERS OF THE CURRENT FILE, IF         *\n*              THE ROUTINE IS ENTERED BECAUSE OF THE                  *\n*              CONCATENATION OF DATA SETS WITH UNLIKE ATTRIBUTES      *\n*        3)    SET THE ERROR FLAG IN THE CURRENT DDBLOCK, IF          *\n*              THE INPUT DATA SET DOES NOT HAVE VARIABLE LENGTH       *\n*              RECORDS.                                               *\n*        4)    CHECK TO SEE THAT THE DCBBLKSI FIELD IS NON-ZERO       *\n*              (THIS IS NECESSARY FOR FUTURE BUFFER ALLOCATION.       *\n*              NOTE THAT DCBBLKSI MIGHT BE LEGITIMATELY ZERO, EG.,    *\n*              IF A DUMMY DATA SET IS BEING READ IN.)                 *\n         SPACE\nRDEXIT   CSECT ,\n        $SAVE  ,                   STACK CALLER'S REGISTERS\n         LR    BASE2,R15           TRANSFER ENTRY ADDRESS\n         USING RDEXIT,BASE2        AND TELL THE ASSEMBLER\n         SPACE\n         LH    RA,DCBBLKSI(,R1)    GET THE BLOCKSIZE FIELD\n         LTR   RA,RA               IS BLKSIZE ZERO .Q\n         BNZ   RDEXIT01            BRANCH IF NOT\n         LA    RA,80               ASSUME THIS FOR DD DUMMY\n         STH   RA,DCBBLKSI(,R1)    FILL IN THE DCB\n         SPACE\nRDEXIT01 DS    0H\n         OC    DCBLRECL(2,R1),DCBLRECL(R1) DID USER SPECIFY LRECL .Q\n         BNZ   RDEXIT02            BRANCH IF YES\n         MVC   DCBLRECL(2,R1),DCBBLKSI(R1) SET LRECL EQUAL BLKSIZE\n         SPACE\nRDEXIT02 DS    0H\n         NI    DDFLAG,255-DD$RECFM CLEAR RECORD FORMAT ERROR\n         TM    DCBRECFM(R1),X'80'  IS RECFM 'V' .Q\n         BZ    RDEXIT04            BRANCH IF YES\n         TM    DCBRECFM(R1),X'40'  IS RECFM 'F' .Q\n         BNO   RDEXIT04            YES, THEN NOT RECFM 'U'\n         CLC   DCBBLKSI(2,R1),DCBLRECL(R1) BLKSIZE = LRECL .Q\n         BNE   RDEXIT03            NOT SQUISHED FILE IF NOT\n         CLC   DCBLRECL(2,R1),H2000 AND 2000 OR MORE .Q\n         BNL   RDEXIT04            YES, THEN MAY BE SQUISHED\nRDEXIT03 DS    0H\n         OI    DDFLAG,DD$RECFM     SET ERROR FLAG IN DDBLOCK\n         SPACE\nRDEXIT04 DS    0H\n         CLI   DCBDSORG(R1),X'00'  IS DSORG UNSPECIFIED .Q\n         BNE   RDEXIT05            BRANCH IF NOT\n         MVI   DCBDSORG(R1),DSORG$PS    MAKE IT SEQUENTIAL\n         SPACE\nRDEXIT05 DS    0H\n         TM    DCBOFLGS(R1),X'20'  IS THIS A CONCATENATE OPEN .Q\n         BZ    RDEXIT06            IF NOT, RETURN NOW TO SUPERVISOR\n         SPACE\n         OI    DDFLAG,DD$REISS     REISSUE I/O REQUEST\n         MVI   DCBDSORG(R1),DSORG$PS    BETTER BE SEQUENTIAL AGAIN\n         SPACE\n        $OFF   FILFLAG,FIL$NONM    RESET NUMBERING FLAG\n        $CALL  RDFBUFF             FREE CURRENT FILE BUFFER\n        $CALL  RDGBUFF             AND REALLOCATE IT\n         SPACE\nRDEXIT06 DS    0H\n        $RESTOR ,                  RESTORE EXIT REGISTERS\n         BR    R14                 RETURN TO THE SUPERVISOR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RDFBUFF": {"ttr": 10260, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x12\\x00\\x12\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        THIS ROUTINE FREES A BUFFER FOR THE CURRENT FILE             *\n*                                                                     *\n***********************************************************************\n         SPACE\nRDFBUFF $ENTER ,\n        $IFOFF FILFLAG,FIL$BUFF,FREE01  BRANCH IF NO BUFFER ALLOCATED\n         SPACE\n         LM    RA,RB,FILBUFAD      GET ADDRESS AND LENGTH OF THE BUFFER\n         LR    R1,RA               ADDRESS FOR A FREEMAIN\n         LR    R0,RB               LENGTH FOR A FREEMAIN\n        $CALL  SYFMAIN             RELEASE ALLOCATED BUFFER\n         SPACE\n        $OFF   FILFLAG,FIL$BUFF    INDICATE BUFFER NOT ALLOCATED\nFREE01   DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              RETURN TO THE CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RDFILE": {"ttr": 10497, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x003\\x003\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              MAIN INPUT FILE DRIVER                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R1)  >  0  ADDR OF DSECT LIKE 'IOBLOCK'\n*                      (R1)  =  0  PURGE ALL LEVELS OF NESTED FILES\n*                      (R1)  = -1  PURGE CURRENT NESTED FILE\n         SPACE\nRDFILE  $ENTER ,\n         L     BASE,VSCRICVT       COMMUNICATION VECTOR TABLE\n         L     BASE,VRDSCRIP-SCRICVT(,BASE)  LOCAL DATA BASE\n         SPACE\n*  IF THIS IS A PURGE REQUEST, CLOSE ALL INPUT FILES                  *\n         LTR   RPARMPTR,R1         IS PARM POINTER ZERO .Q\n         BZ    RFPURGE             IF SO, PURGE ALL INPUT FILES\n         BM    RFPURON             IF MINUS, PURGE ONE LEVEL ONLY\n         SPACE\n         USING IOBLOK,RPARMPTR     TELL ASSEMBLER OF PARM LIST\n         SPACE\n*  FIND OR CONSTRUCT DDBLOCK FOR THE NEW FILE..............           *\n        $CALL  RDFINDF             CALL SUBROUTINE\n         SPACE\n*  ESTABLISH THE CURRENT FILE ENVIRONMENT                             *\n         LM    RFILE,RDD,CURFILE   POINT TO FILBLOCK, DDBLOCK\n         SPACE\n*  REMOVE CURRENT FILE FROM STACK, IF 'APPEND' IS INDICATED           *\n        $IFOFF IOFLAG,IO$AP,RF01   BRANCH IF NO APPEND INDICATED\n        $CALL  RDPOP               REMOVE CURRENT FILE\n         SPACE\n*  ADD THE NEW FILE ONTO THE INPUT STACK                              *\nRF01     DS    0H\n        $CALL  RDPUSH              PUSH THE STACK DOWN\n         B     RF02                AND GO TO EXIT\n         SPACE\n*  PURGE THE INPUT STACK AND CLOSE ALL INPUT FILES\nRFPURGE  DS    0H\n        $CALL  RDPURGE\n         B     RF02                AND GO TO EXIT\n         SPACE\n*  PURGE ONE LEVEL OF INPUT STACK\nRFPURON  DS    0H\n        $CALL  RDPURON             ONE LEVEL\n         SPACE\n*  RETURN TO THE CALLER                                               *\nRF02     DS    0H\n        $RESTOR KEEP=(R15)         RESTORE CALLER'S REGISTERS\n         BR    RETURN              RETURN TO CALLER\n         SPACE\n         DROP  RPARMPTR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RDFINDF": {"ttr": 10499, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00^\\x00^\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 94, "newlines": 94, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              SEARCH AVAILABLE FILES                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\n*                                                                     *\n*  THIS SUBROUTINE  MAKES SURE THAT THERE IS AN OPEN DCB              *\n*  FOR THE FILE BEING ADDED TO THE INPUT STACK.  IT EXITS             *\n*  WITH THE ADDRESS OF A DDBLOCK (OR ZERO, IF THE FILE WAS            *\n*  UNDEFINED) IN 'NEWDD'.                                             *\n*                                                                     *\n         SPACE\nRDFINDF $ENTER ,\n         SPACE\n         USING IOBLOK,RPARMPTR\n         SPACE\n         MVC   BLDLNAME,IOMEMB     GET SPECIFIED MEMBER NAME\n         CLI   BLDLNAME,C' '       IS IT REALLY THERE\n         BNE   FIND01              IF NOT, TAKE FILE NAME\n         MVC   BLDLNAME,IONAME\n         SPACE\n*  TRY USING THE FILE NAME AS A DDNAME                                *\n         SPACE\nFIND01   DS    0H\n         MVC   NEWDDNAM,IONAME     USE FILE NAME AS DDNAME\n        $CALL  RDSCANF             TRY TO OPEN THE FILE\n         LTR   RDD,RDD             WAS THE OPEN SUCCESSFUL\n         BNZ   FIND08              IF SO, INPUT FILE HAS BEEN FOUND\n         SPACE\n*  IF EXPLICIT DDNAME/MEMBERNAME GIVEN, DON'T SEARCH THROUGH          *\n*  THE CURRENT FILE STACK                                             *\n         SPACE\n         CLI   IOMEMB,C' '         IS THE MEMBER NAME BLANK\n         BNE   FIND04              IF NOT, TRY TO FIND IN SYSLIB\n         SPACE\n         L     RFILE,CURFILE       ESTABLISH CURRENT FILE\n         SPACE\n*  SEARCH THROUGH THE LIST OF ACTIVE FILES FOR FILES                  *\n*  WHICH HAVE BEEN OPENED AS PARTITIONED DATA SETS.  CHECK            *\n*  ANY SUCH FOR A MEMBER OF THE SPECIFIED NAME.                       *\n         SPACE\nFIND02   DS    0H\n         LTR   RFILE,RFILE         ANY MORE FILES ON THE STACK .Q\n         BZ    FIND04              IF NOT, MUST SEARCH ELSEWHERE\n         L     RDD,FILDDADR        POINT TO DDBLOCK\n         SPACE\n         TM    DDDCB+DCBDSORG,DSORG$PO IS IT PARTITIONED .Q\n         BZ    FIND03              IF NOT, NO LUCK\n         SPACE\n         BLDL  DDDCB,BLDLLIST      ISSUE THE BLDL MACRO\n         LTR   R15,R15             WAS THE MEMBER THERE .Q\n         BNZ   FIND03              BRANCH IF ANSWER IS NO\n         LH    RA,DDUSECT          CURRENT DDBLOCK USE COUNT\n         LA    RA,1(,RA)           BUMP BY ONE\n         STH   RA,DDUSECT          UPDATE USE COUNT\n         B     FIND08              MEMBER FOUND\n         SPACE\nFIND03   DS    0H\n         L     RFILE,FILPREV       LINK TO PREVIOUS FILE\n         B     FIND02\n         SPACE\n*  TRY SEARCHING SYSLIB FOR A MEMBER OF THE GIVEN NAME                *\n         SPACE\nFIND04   DS    0H\n        $IFON  IOFLAG,IO$RM,FIND06 BRANCH IF A REMOTE\n         CLI   IONAME,C' '         WAS DDNAME ORIGINALLY BLANK .Q\n         BE    FIND05              YES, OK TO ASSUME AND TRY AGAIN\n         CLI   IOMEMB,C' '         WAS MEMBER ORIGINALLY BLANK .Q\n         BNE   FIND06              BOTH SPECIFIED, NO ASSUMPTIONS\nFIND05   DS    0H\n         MVC   NEWDDNAM,=CL8'SYSLIB  '\n        $CALL  RDSCANF             TRY TO OPEN THIS MEMBER\n         LTR   RDD,RDD             WAS THE MEMBER FOUND\n         BNZ   FIND07              BRANCH IF YES\n         SPACE\n*  PUT OUT AN ERROR MESSAGE.....FILE NOT FOUND                        *\n         SPACE\nFIND06   DS    0H\n         MVI   EFLAG051,ERRSET     SET ERROR FLAG\n        $CALL  RDERROR             CALL ERROR SUBROUTINE\n         SR    RDD,RDD             INDICATE NO FILE FOUND\n         SR    RRMQ,RRMQ           IN CASE IT WAS A REMOTE\n         B     FIND08\n         SPACE\nFIND07   DS    0H\n         OI    DDFLAG,DD$NOCLO     DON'T CLOSE SYSLIB\nFIND08   DS    0H\n         ST    RDD,NEWDD           SAVE ADDR OF DDBLOCK\n         ST    RRMQ,NEWRMQ         AND ADDR OF REMOTE QUEUE START\n        $RESTOR ,                  RESTORE CALLER'S REGS\n         BR    RETURN              RETURN TO THE CALLER\n         SPACE\n         DROP  RPARMPTR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RDGBUFF": {"ttr": 10502, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00 \\x00 \\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        THIS ROUTINE GETS A BUFFER FOR THE CURRENT FILE              *\n*                                                                     *\n***********************************************************************\n         SPACE\nRDGBUFF $ENTER ,\n         LTR   RDD,RDD             WAS THE FILE SUCCESSFULLY ALLOC .Q\n         BZ    RDGB02              IF NOT, UNABLE TO ALLOCATE BUFFERS\n         SPACE\n        $IFON  FILFLAG,FIL$BUFF,RDGB02  BRANCH IF BUFFER ALLOCATED\n         SPACE\n         LH    RA,DDDCB+DCBBLKSI   LOAD BLOCKSIZE FROM DCB\n         ST    RA,FILBUFLN         STORE IN BUFFER LENGTH FIELD\n         LTR   RA,RA               TEST LENGTH TO GET\n         BZ    RDGB02              LENGTH IS ZERO FOR REMOTES\n         SPACE\n         LR    R0,RA               SET DESIRED BUFFER LENGTH\n        $CALL  SYGMAIN             GET STORAGE FOR THE BUFFERS\n         LR    RA,R1               BUFFER ADDR, ZERO IF FAILED\n         BC    BNEG,RDGB01         BRANCH IF FAILED\n        $ON    FILFLAG,FIL$BUFF    INDICATE BUFFER ALLOCATED\n         SPACE\nRDGB01   DS    0H\n         LA    RA,0(,RA)           CLEAR HIGH-ORDER BYTE\n         ST    RA,FILBUFAD         THIS BECOMES THE BUFFER ADDRESS\n         ST    RA,FILENDBL         INITIALIZE POINTERS SO A READ IS FOR\n         ST    RA,FILNEXRC\n         SPACE\nRDGB02   DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RDJIGG": {"ttr": 10504, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*   THIS ROUTINE 'JIGGLES' AN ONLINE TERMINAL                         *\n*                                                                     *\n***********************************************************************\n         SPACE\nRDJIGG  $ENTER ,\n        $IFOFF FILFLAG,FIL$TSO,RDJIGG02 BRANCH IF NOT TSO TERMINAL\n        $IFON  TTYPE,TSCREEN,RDJIGG01   BRANCH IF TSO CRT TERMINAL\n         TPUT  JIGTSO,L'JIGTSO,CONTROL  JIGGLE THE TSO TYPEBALL\n         B     RDJIGG03            AND GO TO RETURN\nRDJIGG01 DS    0H\n         TPUT  JIGCRT,L'JIGCRT,ASIS     A TSO CRT WON'T DANCE\n         B     RDJIGG03            AND GO TO RETURN\n         SPACE\nRDJIGG02 DS    0H\n        $IFOFF FILFLAG,FIL$CMS,RDJIGG03 BRANCH IF NOT CMS TERMINAL\n        $IFON  TTYPE,TSCREEN,RDJIGG03   BRANCH IF SCREEN OUTPUT\n         WRTERM JIGCMS,L'JIGCMS,EDIT=NO JIGGLE THE CMS TYPEBALL\n         SPACE\nRDJIGG03 DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nJIGCMS   DC    X'40164016'         CMS TYPEBALL JIGGLE\nJIGTSO   DC    X'40360616'         TSO TYPEBALL JIGGLE\nJIGCRT   DC    C'SCRW000:'         TSO CRT JIGGLE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RDLINE": {"ttr": 10506, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\xbe\\x00\\xbe\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 190, "newlines": 190, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*  THIS ENTRY POINT TO THE SCRIPTRD CONTROL SECTION IS USED           *\n*  TO READ A SINGLE LINE.                                             *\n*                                                                     *\n*  UPON ENTRY, REGISTER ONE POINTS TO AN AREA OF STORAGE THAT         *\n*  LOOKS LIKE THE DSECT 'DATABLOK'.                                   *\n*                                                                     *\n*  UPON EXIT, R15 HOLDS A RETURN CODE THAT HAS THE FOLLOWING MEANING  *\n*        0     RECORD READ AND COPIED, NO PROBLEMS                    *\n*        4     EOF ENCOUNTERED ON BOTTOM FILE OF INPUT STACK ...      *\n*              READ MUST BE REISSUED.                                 *\n*        8     EOF ENCOUNTERED ON BOTTOM FILE OF INPUT STACK ...      *\n*              USER EOF EXIT REQUESTED                                *\n*        12    EOF ENCOUNTERED ON BOTTOM REMOTE FILE OF INPUT STACK ...\n*              USER EOF EXIT REQUESTED                                *\n*        16    NO MORE FILES LEFT IN THE INPUT STACK......FINAL EOF   *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nRDLINE  $ENTER ,\n         L     BASE,VSCRICVT       COMMUNICATION VECTOR TABLE\n         L     BASE,VRDSCRIP-SCRICVT(,BASE)  LOCAL DATA BASE\n         SPACE\n         LR    RPARMPTR,R1         SAVE PARM POINTER\n         USING DATABLOK,RPARMPTR   TELL THE ASSEMBLER\n         SPACE\n         LM    RA,RB,CCHIDBUF      GET ADDR/LENGTH OF CC BUFFER\n         LTR   RB,RB               ANYTHING THERE .Q\n         BZ    READ00              BRANCH IF NOT\n         XC    CCHIDBUF(8),CCHIDBUF  CLEAR HIDDEN BUFFER\n         B     READ02              GO PASS BACK HIDDEN BUFFER\n         SPACE\nREAD00   DS    0H\n         LM    RFILE,RDD,CURFILE   ESTABLISH CURRENT FILE ENV\n         SPACE\n         LTR   RFILE,RFILE         IS THERE ANY FILE ON THE STACK\n         BZ    FINALEOF            BRANCH IF NOT.....NOTHING TO READ\n         SPACE\n         LTR   RDD,RDD             DID ALLOCATION OF BOTTOM FILE FAIL\n         BZ    SOFTEOF2            IF SO, SIMULATE A TEMPORARY EOF\n         SPACE\n         L     RA,FILITEM          GET RECORD NUMBER\nREAD01   DS    0H\n         C     RA,FILMAX           HAVE WE READ FAR ENOUGH\n         BL    READA00             IF NOT, CONTINUE\n        $IFNONE FILFLAG,(FIL$AP,FIL$IM),SOFTEOF2  BRANCH IF A REMOTE\n        $IFOFF FILFLAG,FIL$NULL,SOFTEOF2     BRANCH IF NULL NOT EOF\n        $OFF   FILFLAG,FIL$UEOF    KILL USER EXIT OPTION FOR REREAD\n         B     SOFTEOF2            AND SIMULATE AN END OF FILE\n         SPACE\nREADA00  DS    0H\n        $CALL  RDRECD              READ ONE RECORD (LOCATE MODE)\n         BC    BOMIT,SOFTEOF       BRANCH IF END OF FILE\n         BC    BNEG,SOFTEOF2       BRANCH IF ALREADY END OF FILE\n         L     RA,FILITEM          CURRENT FILE ITEM NUMBER\n         C     RA,FILMIN           REACHED FIRST ITEM TO BE READ .Q\n         BL    READ01              IF NOT, MUST SKIP THIS LINE\n         SPACE\n         L     RA,RECDADDR         GET ADDRESS OF THE READ RECORD\n         MVC   DWORD(2),0(RA)      ALIGN RECORD LENGTH\n         LH    RB,DWORD            GET ITS LENGTH (V FORMAT)\n         S     RB,F4               ALLOW FOR THE RDW\n         TM    DDDCB+DCBRECFM,X'06'  ASA OR MACHINE FILE .Q\n         BZ    READ02              BRANCH IF NOT\n         LTR   RB,RB               WAS IT AN ALL BLANK RECORD .Q\n         BZ    READ02              BRANCH IF YES\n         TM    DDDCB+DCBRECFM,X'02'  IS IT MACHINE CC .Q\n         BO    READM01             BRANCH IF YES\n         SPACE\n         LA    R1,RDASAPA          POINT TO NEW PAGE\n         CLC   4(1,RA),0(R1)       IS IT .Q\n         BE    READA01             BRANCH IF YES\n         LA    R1,RDASASP2         POINT TO SPACE 2\n         CLC   4(1,RA),0(R1)       IS IT .Q\n         BE    READA01             BRANCH IF YES\n         LA    R1,RDASASP1         POINT TO SPACE 1\n         CLC   4(1,RA),0(R1)       IS IT .Q\n         BE    READA01             BRANCH IF YES\n         LA    R1,RDASADC          POINT TO OVERSTRIKE\n         CLC   4(1,RA),0(R1)       IS IT .Q\n         BE    READA01             BRANCH IF YES\n         LA    RA,1(,RA)           BUMP OVER CC\n         S     RB,F1               LESS CC LENGTH\n         BP    READA03             BRANCH IF SOME DATA\n         A     RB,F1               ORIGINAL LENGTH IF NONE\n         B     READA03             BRANCH TO DONE\nREADA01  DS    0H\n         LA    R0,1(,RA)           BUMP OVER CC\n         ST    R0,CCHIDBUF         SAVE ADDRESS\n         BCTR  RB,0                NEW LENGTH LESS CC\n         ST    RB,CCHIDBUF+4       SAVE NEXT LENGTH\nREADA02  DS    0H\n         LR    RA,R1               POINT TO INSERTED RECORD\n         S     RA,F3               DUMMY PREFIX RDW\n         MVC   4(1,RA),PERIND      SET CONTROL WORD INDICATOR\n         LA    RB,L'RDASAPA-1      SET LENGTH OF SAME\nREADA03  DS    0H\n         B     READ02              GO CHECK AND RETURN RECORD\n         SPACE\nREADM01  DS    0H\n         TM    4(RA),X'02'         IS IT AN IMMEDIATE .Q\n         BZ    READM02             BRANCH IF NOT\n         LA    R1,RDMIPA           POINT TO IMMEDIATE PAGE\n         CLC   4(1,RA),0(R1)       IS IT .Q\n         BE    READA02             BRANCH IF YES\n         LA    R1,RDMISP3          POINT TO SPACE 3 IMMEDIATE\n         CLC   4(1,RA),0(R1)       IS IT .Q\n         BE    READA02             BRANCH IF YES\n         LA    R1,RDMISP2          POINT TO SPACE 2 IMMEDIATE\n         CLC   4(1,RA),0(R1)       IS IT .Q\n         BE    READA02             BRANCH IF YES\n         LA    R1,RDMISP1          POINT TO SPACE 1 IMMEDIATE\n         CLC   4(1,RA),0(R1)       IS IT .Q\n         BE    READA02             BRANCH IF YES\n         LA    R1,RDMINOP          POINT TO NOP\n         CLC   4(1,RA),0(R1)       IS IT .Q\n         BE    READA02             BRANCH IF YES\n         B     READM03             DON'T KNOW, PASS BACK AS IS\n         SPACE\nREADM02  DS    0H\n         LA    R1,RDMAPA           EJECT AFTER PRINT .Q\n         CLC   4(1,RA),0(R1)       IS IT .Q\n         BE    READM04             BRANCH IF YES\n         LA    R1,RDMASP3          SPACE THREE AFTER PRINT .Q\n         CLC   4(1,RA),0(R1)       IS IT .Q\n         BE    READM04             BRANCH IF YES\n         LA    R1,RDMASP2          SPACE TWO AFTER PRINT .Q\n         CLC   4(1,RA),0(R1)       IS IT .Q\n         BE    READM04             BRANCH IF YES\n         LA    R1,RDMADC           WRITE NO SPACE .Q\n         CLC   4(1,RA),0(R1)       IS IT .Q\n         BE    READM04             BRANCH IF YES\nREADM03  DS    0H\n         LA    RA,1(,RA)           BUMP OVER CC\n         BCTR  RB,0                DECREMENT LENGTH BY ONE\n         B     READ02              GO AND PASS BACK\nREADM04  DS    0H\n         S     R1,F3               FAKE A DUMMY RDW\n         ST    R1,CCHIDBUF         SAVE NEXT RECORD POINTER\n         LA    R0,L'RDASAPA-1      LENGTH OF SAME\n         ST    R0,CCHIDBUF+4       SAVE THAT TOO\n         MVC   4(1,R1),PERIND      SET CONTROL WORD INDICATOR\n         LA    RA,1(,RA)           BUMP OVER CC\n         BCTR  RB,0                DECREMENT LENGTH BY ONE\n         SPACE\nREAD02   DS    0H\n         CH    RB,DATALEN          IF DATA LENGTH IS > AREA LENGTH\n         BNH   READ03              THE RECORD MUST BE TRUNCATED\n         LH    RB,DATALEN          TRUNCATE THE RECORD.......\nREAD03   DS    0H\n         STH   RB,DATALEN          AREA LENGTH IS ACTUAL LENGTH\n         S     RB,F1               GET SS FORMAT LENGTH\n         BM    READ04              SKIP MOVE IF THE RECORD IS EMPTY\n         EX    RB,RECDMVC          COPY RECORD INTO THE CALLER'S AREA\n         SPACE\nREAD04   DS    0H\n         SR    R15,R15             SET ZERO RETURN CODE (SUCCESS)\n         SPACE\nREAD05   DS    0H\n        $RESTOR KEEP=(R15)         RESTORE CALLER'S REGISTERS\n         BR    RETURN              RETURN TO CALLER\n         SPACE\n*  THE FOLLOWING CODE HANDLES VARIOUS EOF CONDITIONS                  *\n         SPACE\nSOFTEOF  DS    0H\n         NI    DDDCB+DCBIFLGS,B'00111111' CLEAR DCB ERROR FLAGS\n         TM    DDDCB+DCBDSORG,DSORG$PS CHECK IF SEQUENTIAL\n         BZ    SOFTEOF2            IF THIS IS A SEQUENTIAL DATA SET\n         OI    DDFLAG,DD$EOF       SET ERROR FLAG IN THE DDBLOCK\n         SPACE\nSOFTEOF2 DS    0H\n         LA    R0,4                SET TEMPORARY EOF FLAG\n        $IFOFF FILFLAG,FIL$UEOF,SOFTEOF3   BRANCH IF NO USER EOF\n         LA    R0,8                RETURN CODE FOR USER EOF\n        $IFANY FILFLAG,(FIL$AP,FIL$IM),SOFTEOF3   BRANCH IF NOT REMOTE\n         LA    R0,12               SET REMOTE EXIT\nSOFTEOF3 DS    0H\n         XC    DATALEN,DATALEN     INDICATE NULL RECORD IF NO RESTORE\n        $CALL  RDPOP               REMOVE BOTTOM FILE FROM STACK\n         LR    R15,R0              RESTORE RETURN CODE\n         B     READ05              AND RETURN TO CALLER\nFINALEOF DS    0H\n         LA    R15,16              SET NO MORE DATA FLAG\n         XC    DATALEN,DATALEN     INDICATE NULL RECORD\n         B     READ05              RETURN TO THE CALLER\n         SPACE\nRECDMVC  MVC   DATAAREA(*-*),4(RA) EXECUTED MOVE DATA PORTION\n         SPACE\n         DROP  RPARMPTR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RDPOP": {"ttr": 10510, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00r\\x00r\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 114, "newlines": 114, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*  THIS ROUTINE REMOVES THE CURRENT FILE FROM                         *\n*  THE INPUT STACK                                                    *\n*                                                                     *\n***********************************************************************\n         SPACE\nRDPOP   $ENTER ,\n         LH    R1,FILNEST          GET CURRENT FILE NEST LEVEL\n         BCTR  R1,0                DECREMENT BY ONE\n         STH   R1,FILNEST          UPDATE WITH NEW NEST LEVEL\n         SPACE\n         LTR   RFILE,RFILE         IS THERE A CURRENT FILE .Q\n         BZ    POPUP07             IF NOT, EXIT RIGHT AWAY\n         SPACE\n        $CALL  RDFBUFF             FREE THE FILE BUFFER, IF ANY\n         SPACE\n         MVC   IFSTAK,FILIFSTK     RESTORE .IF STATUS\n         LA    R1,FILSRAR          LOCAL SYMBOL DICT\n        $CALL  SYMCLR              REMOVE ANY AND ALL ENTRIES\n         SPACE\n        $IFOFF FILFLAG,FIL$RM,POPUP03  BRANCH IF NOT A REMOTE\n         LH    R1,RMNEST           GET CURRENT REMOTE NEST LEVEL\n         BCTR  R1,0                LESS ONE\n         STH   R1,RMNEST           NEW NESTED REMOTE LEVEL\n        $IFOFF FILFLAG,FIL$AURM,POPUP01 BRANCH IF NOT AUTOMATIC REMOTE\n         LH    R1,RMNMNEST         CURRENT AUTOMATIC REMOTE NEST LEVEL\n         BCTR  R1,0                LESS ONE\n         STH   R1,RMNMNEST         NEW NESTED AUTOMATIC REMOTE LEVEL\nPOPUP01  DS    0H\n         TM    FILRMFLG,RMQKEEP    KEEP THE ENVIRONMENT .Q\n         BO    POPUP02             BRANCH IF YES\n         LA    RB,FILBLOCK+FILBLKLN     END OF FILBLOCK\n         USING RMSAVE,RB           REST OF INFO STARTS HERE\n         MVC   RMIMSAV(4*16),RMSREG     RESTORE IMBEDDER'S REGISTERS\n        $IFON  FILFLAG,FIL$SYRM,POPUP02 BRANCH IF SYSTEM REMOTE\n         MVC   FMTOLD1(EFMTOLD1),RMSOLD1     RESTORE LINK DESCRIPTORS\n         MVC   SWCTL(SWCTLZ),RMSOLD1+EFMTOLD1  RESTORE LINK DESCRIPT\n        $MVC   FMTOLD2,RMSOLD2     RESTORE PAGE DESCRIPTORS\n         MVC   ICOLFLG,RMSICOL     RESTORE MULTIPLE COLUMN FORMAT\n        $MVC   OCCNT,RMSOC         RESTORE OVERLAY CHARACTER STATUS\n         LA    R1,TBANCHR          PTR TO CURRENT USER TAB ANCHOR\n        $CALL  TBFREBLK            RELEASE CURRENT TAB CHAIN\n         MVC   TBIND,RMSTABI       RESTORE USER TAB CHARACTER\n         MVC   TBANCHR,RMSTABA     RESTORE FORMER TAB ANCHOR\nPOPUP02  DS    0H\n        $MVC   ARGSTART,RMSARGS    RESTORE CURRENT BUFFER PTRS\n        $MVC   BUFF2LGZ,RMSBUFF2   RESTORE CURRENT BUFFER\n        $MVC   BUFF1LGZ,RMSBUFF1   RESTORE BUFFER ONE\n         DROP  RB\n         L     RRMQ,FILRMQAD       REMOTE QUEUE DESCRIPTOR\n         LTR   RRMQ,RRMQ           DID REMOTE ALLOCATION FAIL .Q\n         BZ    POPUP03             BRANCH IF YES\n         USING RMQD,RRMQ           TELL THE ASSEMBLER\n         L     R1,RMQUSE           GET REMOTE USE COUNT\n         S     R1,F1               LESS ONE\n         ST    R1,RMQUSE           UPDATE REMOTE USE COUNT\n         L     R1,RMQCNT           GET REMOTE CALL COUNT\n         S     R1,F1               LESS ONE\n         ST    R1,RMQCNT           UPDATE REMOTE CALL COUNT\n         BP    POPUP03             BRANCH IF NOT DONE\n         OI    RMQFLAG,RMQDEL      MARK REMOTE FOR DELETION\n         DROP  RRMQ\n         SPACE\nPOPUP03  DS    0H\n         LA    R1,HIDBANCH         POINT TO ANCHOR\n        $CALL  HIDBPUR             PURGE ANY HIDDEN BUFFER LINES\n         MVC   HIDBANCH,FILHIDB    RESTORE OLD HIDDEN BUFFER LINES\n         LA    R1,HIDBANCH         POINT TO ANCHOR\n        $CALL  HIDBDEL             DELETE ANY UNUSED ENTRIES\n         LA    R1,PEANCH           PERFORM STACK ANCHOR\n        $CALL  OVCLR               DELETE ANY AND ALL OUTSTANDING\n         MVC   PEANCH,FILPEANC     RESTORE FORMER\n        $CALL  LBCLR               CLEAR ANY LABEL BLOCKS\n         MVC   LBANCH,FILLANCH     RESTORE OLD LABEL BLOCKS\n         LA    R0,FILBLOCK         POINT TO AREA TO FREE\n         LA    R1,FILBLKLN         LENGTH OF PREFIX\n        $IFOFF FILFLAG,FIL$RM,POPUP04   BRANCH IF NOT A REMOTE\n         LA    R1,RMSLEN(,R1)      LENGTH OF REMOTE SAVE PORTION\nPOPUP04  DS    0H\n         L     RFILE,FILPREV       LINK TO PREVIOUS BLOCK\n        $CALL  FREECELL            RELEASE THE AREA\n         SPACE\n         LTR   RDD,RDD             WAS THE CURRENT FILE UNDEFINED\n         BZ    POPUP05             IF SO, DON'T CLOSE IT\n         SPACE\n         LH    RA,DDUSECT          DECREMENT USAGE COUNT IN THE\n         BCTR  RA,0                CURRENT DDBLOCK\n         STH   RA,DDUSECT\n         SPACE\n        $CALL  RDCLOSE             CLOSE THE DDBLOCK, IF NO LONGER USED\n         SPACE\nPOPUP05  DS    0H\n         LTR   RDD,RFILE           IF CURRENT FILE IS NULL, MAKE\n         BZ    POPUP06             THE CURRENT DDBLOCK NULL ALSO\n         SPACE\n         L     RDD,FILDDADR        POINT TO NEW DDBLOCK\n         SPACE\n         LTR   RDD,RDD             IS THE FILE UNDEFINED\n         BZ    POPUP06             IF SO, DON'T DO ANY MORE\n         SPACE\n         MVC   COMFILNM,FILDDNAM   COPY CORRECT FILE NAME\n         MVC   COMMEMNM,FILMEMNM   COPY CORRECT MEMBER NAME\n         MVC   COMFILIT,FILITEM    COPY CORRECT RECORD NUMBER\n         MVC   COMFILNO,FILNUMBR   RESTORE DECIMAL LINE NUMBER\n         SPACE\n        $ON    FILFLAG,FIL$FIND    INDICATE REPOSITIONING NECESSARY\n         SPACE\nPOPUP06  DS    0H\n         STM   RFILE,RDD,CURFILE   UPDATE CURRENT FILE POINTERS\n         SPACE\nPOPUP07  DS    0H\n        $RESTOR KEEP=(RFILE,RDD)   RESTORE CALLER'S REGISTERS\n         BR    RETURN              RETURN TO THE CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RDPURGE": {"ttr": 10513, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*  THIS ROUTINE PURGES THE INPUT STACK, AND CLOSES ALL INPUT FILES    *\n*                                                                     *\n***********************************************************************\n         SPACE\nRDPURGE $ENTER ,\n         LM    RFILE,RDD,CURFILE   ESTABLISH CURRENT FILE ENV\n         SPACE\nPURG01   DS    0H\n        $CALL  RDPOP               POP UP INPUT STACK\n         LTR   RFILE,RFILE         IS THERE ANOTHER FILE ON IT\n         BNZ   PURG01              IF SO, POP IT UP AGAIN\n         SPACE\nPURG02   DS    0H\n         L     RDD,FIRSTDD         GO DOWN THE DDBLOCK CHAIN\n         LTR   RDD,RDD             IS THERE ANY CHAIN\n         BZ    PURG03              IF NOT, EXIT TO CALLER\n         LNR   RDD,RDD             INDICATE UNCONDITIONAL CALL\n         SPACE\n        $CALL  RDCLOSE             CLOSE DCB UNCONDITIONALLY\n         B     PURG02              GO BACK FOR ANOTHER\n         SPACE\nPURG03   DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RDPURON": {"ttr": 10515, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x10\\x00\\x10\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*  THIS ROUTINE PURGES ONE LEVEL OF THE INPUT STACK                   *\n*                                                                     *\n***********************************************************************\n         SPACE\nRDPURON $ENTER ,\n         LM    RFILE,RDD,CURFILE   ESTABLISH CURRENT FILE ENVIRONMENT\n        $IFANY FILFLAG,(FIL$AP,FIL$IM),PURON01    BRANCH IF NOT REMOTE\n         MVC   FILMAX,FILITEM      SET MAX RECORDS TO CURRENT\n         B     PURON02             AND GO TO RETURN\nPURON01  DS    0H\n        $CALL  RDPOP               POP UP INPUT STACK ONE LEVEL\nPURON02  DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGS\n         BR    RETURN              AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RDPUSH": {"ttr": 10753, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x90\\x00\\x90\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 144, "newlines": 144, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*  THE PURPOSE OF THIS ROUTINE IS TO ADD A NEW FILE TO THE            *\n*  INPUT STACK                                                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nRDPUSH  $ENTER ,\n         SPACE\n         USING IOBLOK,RPARMPTR     POINT TO PARM BLOCK\n         SPACE\n         LH    R1,FILNEST          GET CURRENT FILE NEST LEVEL\n         LA    R1,1(,R1)           BUMP BY ONE\n         STH   R1,FILNEST          UPDATE WITH NEW NEST LEVEL\n         SPACE\n         LR    RA,RFILE            SAVE PTR TO CURRENT FILBLOCK\n         L     RDD,NEWDD           GET POINTER TO NEW DDBLOCK\n         SPACE\n         LA    R1,FILBLKLN         FILBLOCK PREFACE LENGTH\n        $IFOFF IOFLAG,IO$RM,PDOWN01     BRANCH IF NOT A REMOTE\n         LA    R1,RMSLEN(,R1)      LENGTH OF REMOTE SAVE PORTION\nPDOWN01  DS    0H\n         LR    R0,RPARMPTR         RETAIN PARM POINTER\n        $CALL  GETCELL             GET AREA FOR NEW FILBLOCK\n         LR    RFILE,TEMP          POINT TO NEW FILBLOCK\n         LR    RPARMPTR,R0         RESTORE PARM POINTER\n         BC    BNEG,PDOWN024       BRANCH IF FAILED\n         SPACE\n*   INITIALIZE THE NEW FILBLOCK                                       *\n         SPACE\n         XC    FILBLOCK(FILBLKLN),FILBLOCK   CLEAR PREFACE\n         ST    RA,FILPREV          LINK BLOCK ONTO CHAIN\n         ST    RDD,FILDDADR        POINT TO DDBLOCK\n         MVC   FILTTRK,BLDLTTRK    INITIALIZE 'FIND' DATA (USED FOR PDS\n         MVC   FILLANCH,LBANCH     SAVE LABEL BLOCK ANCHOR\n         XC    LBANCH,LBANCH       AND CLEAR CURRENT\n         MVC   LBGOTO,IOGOTO       SET IMPLIED GOTO\n         MVC   FILFLAG,IOFLAG      INITIALIZE FLAGS\n         MVC   FILMAX,IOMAX        GET LAST RECORD TO BE READ\n         MVC   FILMIN,IOMIN        GET FIRST RECORD TO BE READ\n         MVC   FILDDNAM,DDLDDNAM   SAVE LOGICAL DDNAME\n         MVC   FILMEMNM,BLDLNAME   SAVE MEMBER NAME (IF PRESENT)\n         MVC   FILNUMBR,=C'00000000'    INITIALIZE DECIMAL ITEM NUMBER\n         MVC   FILIFSTK,IFSTAK     SAVE IF STACK INFO\n         XC    IFSTAK,IFSTAK       CLEAR CURRENT INFO\n         L     R1,ASRLCL           LOCAL SYMBOL DICT\n         USING SRAREA,R1           TELL THE ASSEMBLER\n         MVC   FILSRAR(SRALEN),SRAREA   SAVE LOCAL SYMBOL DICT\n         XC    SRAREA(SRALEN),SRAREA    PURGE WORK LOCAL DICT\n         DROP  R1\n         SPACE\n         MVC   FILPEANC,PEANCH     SAVE PERFORM BUFFER ANCHOR\n         XC    PEANCH,PEANCH       CLEAR CURRENT\n         LTR   RA,RA               ANY PREVIOUS FILEBLOCK .Q\n         BZ    PDOWN02             LEAVE HIDDEN BUFFER IF NOT\n         MVC   FILHIDB,HIDBANCH    SAVE HIDDEN BUFFER ANCHOR\n         XC    HIDBANCH,HIDBANCH   CLEAR ANCHOR\n        $OFF   SWITCHS,HIDBSWS     NOTHING TO LOOK AT\n         SPACE\nPDOWN02  DS    0H\n        $IFOFF FILFLAG,FIL$RM,PDOWN07   BRANCH IF NOT REMOTE\n         LH    R1,RMNEST           GET CURRENT REMOTE NEST LEVEL\n         LA    R1,1(,R1)           BUMP BY ONE\n         STH   R1,RMNEST           NEW NESTED REMOTE LEVEL\n        $IFOFF IOFLAG,IO$AURM,PDOWN05   BRANCH IF NOT AUTOMATIC REMOTE\n         LH    R1,RMNMNEST         AUTOMATIC REMOTE NEST LEVEL\n         LA    R1,1(,R1)           BUMP BY ONE\n         STH   R1,RMNMNEST         NEW NESTED AUTOMATIC REMOTE LEVEL\nPDOWN05  DS    0H\n        $ON    FILFLAG,(FIL$NULL,FIL$NONM)   REMOTE FILE ATTRIBUTES\n         LA    RB,FILBLOCK+FILBLKLN     END OF FILBLOCK\n         USING RMSAVE,RB           PUT REST HERE\n         MVC   RMSREG(4*16),RMIMSAV     SAVE IMBEDDER'S REGISTERS\n         XC    RMIMSAV(4*16),RMIMSAV    AND CLEAR IT\n         MVC   RMSOLD1,FMTOLD1     SAVE SWITCHES\n         MVC   RMSOLD2,FMTOLD2     SAVE PAGE DESCRIPTORS\n         MVC   RMSICOL,ICOLFLG     SAVE MULTIPLE COLUMN FORMAT\n         MVC   RMSARGS,ARGSTART    SAVE CURRENT BUFFER POINTERS\n         MVC   RMSBUFF2,BUFF2LGZ   SAVE CURRENT BUFFER\n         MVC   RMSBUFF1,BUFF1LGZ   SAVE BUFFER ONE\n         MVC   RMSOC,OCCNT         SAVE OVERLAY CHARACTER STATUS\n         SPACE\n         L     RRMQ,NEWRMQ         ADDRESS OF REMOTE QUEUE START\n         ST    RRMQ,FILRMQAD       SAVE FILE DESCRIPTOR BLOCK ADDR\n         LTR   RRMQ,RRMQ           DID ALLOCATION SUCCEED .Q\n         BZ    PDOWN07             BRANCH IF NOT\n         USING RMQD,RRMQ           TELL THE ASSEMBLER\n         MVC   FILBUFAD,RMQAD      FIRST SAVED TEXT LINE\n         MVC   FILH1AD,RMQAD       OR FIRST LEVEL HEADER\n         MVC   FILRMEXT,RMQEXIT    READ EXIT ADDRESS (IF ANY)\n         L     R1,RMQUSE           REMOTE USE COUNT\n         A     R1,F1               PLUS ONE\n         ST    R1,RMQUSE           UPDATE REMOTE USE COUNT\n         MVC   FILRMFLG,RMQFLAG    SAVE REMOTE FLAG TOO\n         MVC   FILENDBL,F1         END OF BLOCK GT CURRENT PTR (0)\n        $ON    SWITCHS,FRMKP       ASSUME ENVIRONMENT TO BE KEPT\n        $IFOFF FILFLAG,FIL$SYRM,PDOWN06 BRANCH IF NOT SYSTEM REMOTE\n         NI    FILRMFLG,FF-RMQKEEP AND ENFORCE SAVING ENVIRONMENT\n         B     PDOWN07             BUT NOT TOO MUCH\nPDOWN06  DS    0H\n         TM    FILRMFLG,RMQKEEP    IS ENVIRONMENT TO BE KEPT .Q\n         BO    PDOWN07             BRANCH IF YES\n        $OFF   SWITCHS,FRMKP       DO NOT KEEP ENVIRONMENT UNCHANGED\n         XC    OLDCOUNT,OLDCOUNT   CLEAR LAST LINE\n         LH    R1,INDL             RESET INDENT, UNDENT AND OFFSET\n         AH    R1,OFFLI            ..\n         STH   R1,INDL             ..\n         STH   R1,RMARGIN          ..\n         SR    R1,R1               ZERO WORK REGISTER\n         STH   R1,UNDL             ZERO UNDENT VALUE\n         STH   R1,OFFLI            ZERO OFFSET VALUE\n         STH   R1,CECNT            ZERO CENTER VALUE\n         STH   R1,LICNT            ZERO LITERAL VALUE\n         STH   R1,OCCNT            CLEAR OVERLAY CHARACTER\n         MVC   OCCHAR,OCCHAR+1     AND RESET CHARACTER\n        $CALL  TBCOPY              DUPLICATE USER TAB CHAIN\n         MVC   RMSTABI,TBIND       SAVE USER TAB CHARACTER\n         MVC   RMSTABA,TBANCHR     SAVE CURRENT TAB\n         ST    R1,TBANCHR          SAVE COPY ANCHOR\n         DROP  RB\n         DROP  RRMQ\n         SPACE\nPDOWN07  DS    0H\n        $ON    FILFLAG,FIL$FIND    SIGNAL REPOSITIONING NECESSARY\n        $CALL  RDGBUFF             GET A BUFFER FOR THE FILE\n         SPACE\n         XC    COMFILIT,COMFILIT   INITIALIZE RECORD COUNT\n         MVC   COMFILNM,FILDDNAM   SET FILE NAME\n         MVC   COMMEMNM,FILMEMNM   SET MEMBER NAME\n         MVC   COMFILNO,FILNUMBR   SET DECIMAL ITEM NUMBER\n         SPACE\nPDOWN08  DS    0H\n         STM   RFILE,RDD,CURFILE   UPDATE CURRENT FILE POINTERS\n         MVC   NEWDD,F0            CLEAR NEXT DD BLOCK POINTER\n         SPACE\n        $RESTOR KEEP=(RFILE,RDD)   RESTORE CALLER'S REGISTERS\n         BR    RETURN              RETURN TO CALLER\n         SPACE\nPDOWN024 DS    0H\n         MVI   EFLAG024,ERRSET     NO STORAGE FOR FILBLOCK\n         SR    RFILE,RFILE         ZERO POINTER\n         B     PDOWN08             GO TO RETURN\n         SPACE\n         DROP  RPARMPTR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RDRECD": {"ttr": 10757, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x01m\\x01m\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 365, "newlines": 365, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*  THIS SUBROUTINE ATTEMPTS TO READ A SINGLE RECORD FROM THE          *\n*  FILE CURRENTLY ON THE BOTTOM OF THE INPUT STACK.                   *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON EXIT -- CC = BPOS   IF RECORD READ\n*                      = BOMIT  IF EOF\n*                      = BNEG   IF EOF ALREADY\n         SPACE\nRDRECD  $ENTER ,\n         SPACE\nRREC01   DS    0H\n         LM    RA,RB,FILNEXRC      LOAD ADDR NEXT RECORD AND EOB ADDR\n         CR    RA,RB               IS THIS BLOCK FINISHED\n         BL    RREC14              BRANCH IF IT IS NOT\n         SPACE\nRREC02   DS    0H\n         NI    DDFLAG,255-DD$REISS CLEAR 'REISSUE DUE TO CONCAT' FLAG\n         SPACE\n        $IFOFF FILFLAG,FIL$BUFF,RREC28  BRANCH IF NO BUFFER AVAILABLE\n         SPACE\n         TM    DDFLAG,DD$EOF       EOF ALREADY ENCOUNTERED FOR THIS DCB\n         BO    RREOF2              IF SO, DON'T BOTHER WITH A READ\n         SPACE\n         TM    DDFLAG,DD$RECFM     IS THE RECORD FORMAT ILLEGAL\n         BO    RREC29              IF SO, HANDLE THE ERROR\n         SPACE\n        $IFOFF FILFLAG,FIL$FIND,RREC04  BRANCH IF NO FIND REQUIRED\n         SPACE\n        $OFF   FILFLAG,FIL$FIND    CLEAR 'ISSUE FIND' FLAG\n         SPACE\n         TM    DDDCB+DCBDSORG,DSORG$PO  DON'T ISSUE A FIND\n         BNO   RREC04              FOR A SEQUENTIAL DATA SET\n         FIND  DDDCB,FILTTRK,C     POINT TO CURRENT MEMBER\n         SPACE\n         L     RA,FILNOTE          ALSO POINT TO LAST RECORD\n         LTR   RA,RA               PLUS ONE\n         BZ    RREC04              DON'T POINT IF NO NOTE HAS BEEN DONE\n         MVI   FILNOTE+3,X'01'     ADVANCE ONE RECORD\n         POINT DDDCB,FILNOTE       POINT TO NEXT RECORD TO BE READ\n         SPACE\nRREC04   DS    0H\n        $IFOFF FILFLAG,FIL$EJCT,RREC06  BRANCH IF NO PAGE EJECT\n        $CALL  RDEJCT              EJECT CURRENT PAGE\n         SPACE\nRREC06   DS    0H\n        $IFOFF FILFLAG,FIL$JIGG,RREC08  BRANCH IF NO JIGGLE REQUIRED\n        $CALL  RDJIGG              JIGGLE TYPEBALL\n         SPACE\nRREC08   DS    0H\n        $IFOFF FILFLAG,FIL$SUPR,RREC09  BRANCH IF NO SUPPRESSED\n        $IFON  FILFLAG,FIL$CMS,RREC09  BRANCH IF A CMS TERMINAL\n        $IFOFF FILFLAG,FIL$TSO,RREC09  BRANCH IF NOT A TSO TERMINAL\n         TPUT  RRECBYP,L'RRECBYP,CONTROL  SUPPRESS IT\n         SPACE\nRREC09   DS    0H\n         L     RB,FILBUFAD         GET ADDRESS OF THE BUFFER\n         LA    RA,DDDCB            GET DCB ADDRESS\n         READ  READDECB,SF,(RA),(RB),'S' READ ONE BLOCK\n         SPACE\n        $IFOFF FILFLAG,FIL$SUPR,RREC10  BRANCH IF NOT SUPPRESSED\n        $IFON  FILFLAG,FIL$CMS,RREC10  BRANCH IF A CMS TERMINAL\n        $IFOFF FILFLAG,FIL$TSO,RREC10  BRANCH IF NOT A TSO TERMINAL\n         TPUT  RRECRES,L'RRECRES,CONTROL  ISSUE RESTORE\n         SPACE\nRREC10   DS    0H\n         CHECK READDECB\n         SPACE\n         TM    DDFLAG,DD$REISS     WAS READ INTERCEPTED BECAUSE OF\n*                             CONCATENATION OF UNLIKE DATA SETS...    *\n         BO    RREC02              IF SO, REISSUE IT\n         SPACE\n         SR    R1,R1               ASSUME NO NOTE\n         TM    DDDCB+DCBDEVT,X'40' A UNIT RECORD INPUT DEVICE .Q\n         BO    RREC10A             BRANCH IF YES\n         NOTE  DDDCB               NOTE POSITION OF BLOCK JUST READ\nRREC10A  DS    0H\n         ST    R1,FILNOTE          AND SAVE FOR FUTURE REF\n         TM    DDDCB+DCBRECFM,X'C0' IS RECFM 'U' .Q\n         BO    RREC11              BRANCH IF YES\n         TM    DDDCB+DCBRECFM,X'40' IS RECFM 'V' .Q\n         BO    RREC12              BRANCH IF YES\n         L     RA,READDECB+16      COMPUTE END OF RECFM 'F' BLOCK\n         LH    R1,DDDCB+DCBBLKSI   ADDR FROM RESIDUAL LENGTH\n         SH    R1,14(,RA)          CSW, BLKSIZE IN DCB AND\n         LR    RA,RB               ADDRESS OF NEXT RECORD\n         AR    RB,R1               END OF BLOCK ADDRESS\n         B     RREC13              AND SET THEM\nRREC11   DS    0H\n         LA    RA,2(,RB)           ADDR FIRST RECFM 'U' RECORD\n         AH    RB,0(,RB)           ADDR OF END OF BLOCK\n         B     RREC13              AND CONTINUE\n         SPACE\nRREC12   DS    0H\n         LA    RA,4(,RB)           ADDR FIRST RECFM 'V' RECORD\n         AH    RB,0(,RB)           AND ADDRESS OF END OF BLOCK\nRREC13   DS    0H\n         STM   RA,RB,FILNEXRC      SAVE IN FILBLOCK\n         B     RREC01              GO BACK TO EXTRACT THE RECORD\n         SPACE\nRREC14   DS    0H\n         L     RB,FILITEM          GET FILE RECORD NUMBER\n         A     RB,F1               AND BUMP IT BY ONE\n         ST    RB,FILITEM          PUT IT BACK\n         SPACE\n         CVD   RB,DWORD            CONVERT IT TO DECIMAL\n         UNPK  FILNUMBR,DWORD+4(4) AND TAKE IT AS DECIMAL ITEM NO.\n         OI    FILNUMBR+L'FILNUMBR-1,C'0'  CORRECT THE ZONE\n        $IFANY FILFLAG,(FIL$AP,FIL$IM),RREC14A    BRANCH IF NOT REMOTE\n         SPACE\n         L     R15,FILRMEXT        REMOTE READ EXIT ADDRESS\n         LTR   R15,R15             ANYTHING THERE .Q\n         BZ    RRM01               BRANCH IF NOT\n         LA    R1,FILBLOCK         POINT TO CURRENT FILE BLOCK\n        $CALL  (R15)               LET HIM DO HIS WORST\n         LTR   RA,R1               THE RETURN 'RMQR' POINTER\n         BNZ   RRM02               CONTINUE IF RECORD RETURNED\n         XC    FILRMEXT,FILRMEXT   CLEAR EXIT ADDRESS\n         XC    FILBUFAD,FILBUFAD   NO NEXT ADDRESS\n         B     RRM02               AND CONTINUE PROCESSING\n         SPACE\nRRM01    DS    0H\n         L     RA,FILBUFAD         NEXT RECORD POINTER\nRRM02    DS    0H\n         USING RMQR,RA             DATA AREA FOR REMOTES\n         LA    RA,0(,RA)           CLEAR TOP BYTE\n         LTR   RA,RA               AT THE END .Q\n         BZ    RRM03               BRANCH IF YES\n         MVC   FILBUFAD,RMQRCHN    NEXT RECORD ADDR\n         LH    RB,RMQRLEN          LENGTH OF DATA\n         LA    RA,RMQRDATA         DATA POINTER\n         DROP  RA\n         XC    TATALEN(4),TATALEN  ZERO RESULT TARGET\n         MVC   TATAAREA,BLANKS     BLANK TARGET\n         S     RB,F1               LENGTH -1\n         BM    RRM02A              BRANCH IF NOTHING\n         EX    RB,RRECFMVC         MOVE RECORD TO TARGET\nRRM02A   DS    0H\n         A     RB,F1               RESTORE TRUE LENGTH\n         B     RREC18              SET OUTPUT POINTER\n         SPACE\nRRM03    DS    0H\n        $IFON  FILFLAG,FIL$END,RRM04    BRANCH IF 2ND TIME\n        $ON    FILFLAG,FIL$END     SET FIRST TIME SWITCH\n         TM    FILRMFLG,RMQKEEP    KEEP ENVIRONMENT .Q\n         BO    RRM04               BRANCH IF YES\n        $IFON  FILFLAG,FIL$SYRM,RRM04   BRANCH IF AUTO SYSTEM REMOTE\n         MVC   RRRMBRS,PERIND      CONTROL WORD INDICATOR\n         L     R1,INDEXS           ADDR CONTROL WORD TABLE\n         MVC   RRRMBRS+1(2),=C'BR' ADD 'BR'  (SHOULD COME FROM CTLTAB)\n         LA    RA,RRRMBRS          ADDRESS OF THE RESULT\n         LA    RB,L'RRRMBRS        LENGTH OF THE RESULT\n         B     RRM05               REMOTE READ END\n         SPACE\nRRM04    DS    0H\n         SR    RB,RB               ZERO LENGTH RECORD\nRRM05    DS    0H\n         B     RREC14B             PASS BACK RESULT\n         SPACE\nRREC14A  DS    0H\n         TM    DDDCB+DCBRECFM,X'C0' IS RECFM 'U' .Q\n         BO    RREC19              BRANCH IF YES\n         TM    DDDCB+DCBRECFM,X'40' IS RECFM 'V' .Q\n         BO    RREC21              BRANCH IF YES\n         LH    RB,DDDCB+DCBLRECL   LRECL OF RECFM 'F' FILE\n         LR    R1,RB               TRANSFER\n         LA    R1,0(R1,RA)         START OF NEXT\n         ST    R1,FILNEXRC         SAVE RESULT\nRREC14B  DS    0H\n         XC    TATALEN(4),TATALEN  ZERO RESULT TARGET\n        $IFON  FILFLAG,FIL$NONM,RREC16  BRANCH IF FILE NOT NUMBERED\n         S     RB,F8               LESS END SEQUENCE\n         BM    RREC14C             BRANCH IF NO WAY\n         LA    R1,0(RA,RB)         POINT TO POTENTIAL SEQUENCE\n         MVZ   ZERONUMR,0(R1)      GET EIGHT ZONES OF RECORD END\n         CLC   ZERONUMR,=C'00000000' ARE THEY NUMERIC .Q\n         BE    RREC15              BRANCH IF YES\nRREC14C  DS    0H\n        $ON    FILFLAG,FIL$NONM    SET NOT SEQUENCED\n         A     RB,F8               RESTORE ACTUAL LENGTH\n         B     RREC16              AND CONTINUE\nRREC15   DS    0H\n         MVC   FILNUMBR,0(R1)      SET SEQUENCE NUMBER\nRREC16   DS    0H\n         S     RB,F1               DECREMENT RECORD LENGTH\n         BM    RREC17              BRANCH IF MINUS\n         LA    R1,0(RA,RB)         POINT TO LAST CHARACTER\n         CLI   0(R1),C' '          END WITH A BLANK .Q\n         BE    RREC16              BRANCH BACK IF YES\n         CLI   0(R1),X'16'         END WITH A BACKSPACE .Q\n         BE    RREC16              BRANCH BACK IF YES\n         EX    RB,RRECFMVC         MOVE RECORD TO TARGET\n         B     RREC17A             GO TO RESTORE REAL LENGTH\nRREC17   DS    0H\n         MVC   TATAAREA,BLANKS     CLEAR RETURN DATA\n        $IFON  FILFLAG,FIL$NULL,RREC17A BRANCH IF NULL RECORDS EOF\n         A     RB,F1               PASS BACK SINGLE BLANK\nRREC17A  DS    0H\n         A     RB,F1               RESTORE ACTUAL RECORD LENGTH\nRREC18   DS    0H\n         A     RB,F4               ADD DUMMY RDW LENGTH\n         STH   RB,TATALEN          SET RECORD LENGTH\n         LA    RA,TATABLOK         POINT TO RESULT\n         ST    RA,RECDADDR         POINT TO IT\n         B     RREC26              AND EXIT\nRRECFMVC MVC   TATAAREA(*-*),0(RA) MOVE FIXED RECORD\n         SPACE\nRREC19   DS    0H\n         MVC   DWORD(4),0(RA)      ALIGN SEQUENCE NUMBER\n         L     R1,DWORD            GET NUMBER\n         CVD   R1,DWORD            CONVERT TO DECIMAL\n         UNPK  FILNUMBR,DWORD+4(4) SPREAD IT OUT\n         OI    FILNUMBR+L'FILNUMBR-1,C'0'  CORRECT THE ZONE\n         XC    TATALEN(4),TATALEN  ZERO OUTPUT LENGTH\n         MVC   TATAAREA,BLANKS     BLANK OUTPUT BLOCK\n         SR    R1,R1               ZERO RECORD LENGTH\n         IC    R1,4(,RA)           GET IN RECORD LENGTH\n         LR    R0,R1               SAVE LENGTH FOR DEBLOCK CHECKING\n         LA    R1,5(R1,RA)         POINT TO NEXT RECORD\n         ST    R1,FILNEXRC         SAVE POINTER\n         LTR   R0,R0               IS THIS A NULL RECORD .Q\n         BP    RREC20              BRANCH IF YES\n         LA    RB,1                MAKE IT ONE BLANK LONG\n         STH   RB,TATALEN          SET NEW LENGTH\n         B     RREC18              SET OUTPUT POINTER\n         SPACE\nRREC20   DS    0H\n         IC    RB,5(,RA)           GET BLANK COUNT\n         SRL   RB,4                DIVIDE BY SIXTEEN\n         N     RB,F15              PURIFY THE RESULT\n         AH    RB,TATALEN          PLUS EXISTING LENGTH\n         STH   RB,TATALEN          UPDATE LENGTH\n         IC    RB,5(,RA)           GET COUNT OF DATA\n         N     RB,F15              PURIFY IT\n         LA    R1,TATAAREA         POINT TO OUTPUT AREA\n         AH    R1,TATALEN          PLUS CURRENT LENGTH\n         S     RB,F1               GET LENGTH-1\n         BM    *+8                 BRANCH IF ZERO\n         EX    RB,SQSHMVC          ADD DATA PORTION\n         A     RB,F1               RESTORE ACTUAL LENGTH\n         SR    R0,RB               DECREMENT TOTAL\n         S     R0,F1               LESS LENGTH BYTE\n         LA    RA,1(RB,RA)         BUMP INPUT POINTER\n         AH    RB,TATALEN          PLUS EXISTING LENGTH\n         STH   RB,TATALEN          UPDATE RECORD LENGTH\n         LTR   R0,R0               ANYTHING LEFT .Q\n         BP    RREC20              LOOP BACK IF YES\n         B     RREC18              SET OUTPUT POINTER\nSQSHMVC  MVC   0(*-*,R1),6(RA)     MOVE DATA PORTION\n         SPACE\nRREC21   DS    0H\n         MVC   DWORD(2),0(RA)      ALIGN RECORD LENGTH\n         LH    RB,DWORD            GET LENGTH OF THE RCD (RDW INCL.)\n         SPACE\n        $IFON  FILFLAG,FIL$NONM,RREC25  BRANCH IF FILE NOT NUMBERED\n         SPACE\n         C     RB,F12              IS RECORD LONG ENOUGH TO HAVE NUMBER\n         BL    RREC24              BRANCH IF NOT\n         L     R1,DEFSEQC+TAB3DEF  GET POSSIBLE SEQUENCE COLUMN\n         LTR   R1,R1               IS IT POSITIVE .Q\n         BZ    RREC24              NO SEQUENCE POSSIBLE IF NOT\n         SPACE\n         LA    R1,4+7(,R1)         PLUS RDW AND SEQ LENGTH-1\n         CR    R1,RB               COMPARE TO ACTUAL\n         BNH   RREC22              BRANCH NOT GREATER\n         LR    R1,RB               USE ACTUAL RECORD LENGTH\nRREC22   DS    0H\n         S     R1,F8               SEQUENCE START OFFSET\n         AR    R1,RA               SEQUENCE START ADDR\n         SPACE\n         MVZ   ZERONUMR,0(R1)      GET FIRST EIGHT ZONES OF RECORD\n         CLC   ZERONUMR,=C'00000000' ARE THEY NUMERIC .Q\n         BNE   RREC24              IF NOT, FILE IS NOT LINE NUMBERED\n         SPACE\n         MVC   FILNUMBR,0(R1)      ASSUME FILE LINE NUMBERED\n         LA    R0,0(RB,RA)         END OF SEQUENCED RECORD\n         SR    R0,R1               LESS START OF SEQUENCE\n         S     R0,F8               LESS SEQUENCE NUMBER\n         BNP   RREC23              BRANCH IF NOTHING LEFT\n         LR    R15,R0              TRANSFER LENGTH REMAINING\n         BCTR  R15,0               LESS ONE\n         EX    R15,SEQVMVC         MOVE OVER SEQUENCE FIELD\n         SPACE\nRREC23   DS    0H\n         S     RB,F8               DECREMENT LENGTH\n         STH   RB,DWORD+2          ALIGN NEW LENGTH\n         MVC   0(2,RA),DWORD+2     PUT NEW LENGTH IN RIGHT PLACE\n         B     RREC25              DON'T SET THE NONUM FLAG\nSEQVMVC  MVC   0(*-*,R1),8(R1)     EXECUTED MOVE OVER SEQUENCE\n         SPACE\nRREC24   DS    0H\n        $ON    FILFLAG,FIL$NONM    FILE NOT LINE NUMBERED\n         SPACE\nRREC25   DS    0H\n         ST    RA,RECDADDR         SAVE ADDRESS OF THE NEW RECORD\n         SPACE\n         AH    RA,DWORD            ADD LENGTH TO STARTING ADDRESS\n         ST    RA,FILNEXRC         TO GET NEXT RECORD ADDRESS\nRREC26   DS    0H\n         S     RB,F4               LESS RDW LENGTH\n         CH    RB,DDDCB+DCBLRECL   IS RECORD TOO LONG .Q\n         BH    RREC29A             IF SO, COMPLAIN AND QUIT\n         SPACE\n         LTR   RB,RB               IS THE RECORD A NULL ONE .Q\n         BP    RREC27              BRANCH IF IT IS NOT\n         BM    RREC29A             QUIT IF RECORD TOO SHORT\n        $IFON  FILFLAG,FIL$NULL,RREOF2  BRANCH IF NULL RECORDS EOF\n         SPACE\nRREC27   DS    0H\n         MVC   COMFILIT,FILITEM    COPY FILE LINE NUMBER\n         MVC   COMFILNO,FILNUMBR   AND DECIMAL ITEM NUMBER\n         SPACE\n         B     RRET                GO TO SUCCESSFUL RETURN\n         SPACE\nRREC28   DS    0H\n         MVI   EFLAG053,ERRSET     SET ERROR FLAG\n        $CALL  RDERROR             CALL ERROR ROUTINE\n         B     RREC30              AND CONTINUE\n         SPACE\nRREC29   DS    0H\n         MVI   EFLAG054,ERRSET     SET ERROR FLAG\n        $CALL  RDERROR             CALL ERROR ROUTINE\n         B     RREC30              AND CONTINUE\n         SPACE\nRREC29A  DS    0H\n         MVI   EFLAG055,ERRSET     SET ERROR FLAG\n        $CALL  RDERROR             CALL ERROR ROUTINE\n         SPACE\nRREC30   DS    0H\n         TM    DDDCB+DCBDSORG,DSORG$PS SEQUENTIAL...\n         BZ    RREOF               IF NOT, SIGNAL EOF\n        $IFON  SWITCHS,CMSWS,RREOF BRANCH IF CMS\n         FEOV  DDDCB               ELSE GO ON TO NEXT PIECE\n         B     RREC02              IF THERE IS ANY\n         SPACE 2\n*                                                                     *\n*  THIS IS THE SYNAD ROUTINE                                          *\n*                                                                     *\n         SPACE\nSYNAD    DS    0H\n         SYNADAF ACSMETH=BSAM      GENERATE ERROR MESSAGE\n         MVC   BUFF2(78),50(R1)    COPY THE MESSAGE\n         LA    R0,78               LENGTH OF SAME\n         STH   R0,BUFF2LGZ         SET LENGTH OF SYNAD DATA\n         SYNADRLS\n         SPACE\n         MVI   EFLAG056,ERRSET     SET ERROR FLAG\n        $CALL  RDERROR             PRINT AN ERROR MESSAGE\n         B     RREOF               PRETEND THAT IT IS END OF FILE\n         SPACE\nRREOF    DS    0H\n        $CC    OMIT                END OF FILE\n         B     RRET01              GO TO RETURN\nRREOF2   DS    0H\n        $CC    NEG                 SECOND END OF FILE\n         B     RRET01              GO TO RETURN\nRRET     DS    0H\n        $CC    POS                 RECORD FOUND SUCCESSFULLY\nRRET01   DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nRRECBYP  DC    AL1(CPRTBYP)        SUPPRESS CONSOLE PRINTING\nRRECRES  DC    AL1(CPRTRES)        RESTORE CONSOLE PRINTING\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RDREWIN": {"ttr": 10764, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x007\\x007\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*  THIS ENTRY POINT TO SCRIPTRD IS USED TO REWIND THE CURRENT         *\n*  INPUT FILE, BE IT DASD OR REMOTE.                                  *\n*                                                                     *\n*  UPON ENTRY, REGISTER ONE POINTS TO AN AREA OF STORAGE THAT LOOKS   *\n*  LIKE 'IOBLOK'.                                                     *\n*                                                                     *\n*  UPON EXIT, R15 HOLDS A RETURN CODE WITH THE FOLLOWING MEANING --   *\n*        0     REWIND WAS SUCCESSFUL                                  *\n*        4     REWIND WAS UNSUCCESSFUL                                *\n*                                                                     *\n***********************************************************************\n         SPACE\nRDREWIND $ENTER ,\n         L     BASE,VSCRICVT       COMMUNICATION VECTOR TABLE\n         L     BASE,VRDSCRIP-SCRICVT(,BASE)  LOCAL DATA BASE\n         SPACE\n         LR    RPARMPTR,R1         SAVE PARM POINTER\n         USING IOBLOK,RPARMPTR     AND TELL THE ASSEMBLER\n         LM    RFILE,RDD,CURFILE   ESTABLISH CURRENT FILE ENVIRONMENT\n         LTR   RFILE,RFILE         IS ANY FILE ON STACK .Q\n         BZ    RDREW03             ERROR IF NOT\n         LTR   RDD,RDD             DID ALLOC OF BOTTOM FILE FAIL .Q\n         BZ    RDREW03             ERROR IF NOT\n         CLC   IONAME,DDLDDNAM     SAME FILE NAME .Q\n         BNE   RDREW03             ERROR IF NOT\n         CLC   IOMEMB,FILMEMNM     SAME MEMBER .Q\n         BNE   RDREW03             ERROR IF NOT\n         TM    DDDCB+DCBDEVT,X'40' UNIT RECORD INPUT FILE .Q\n         BO    RDREW03             YES, FORGET REREADING SAME\n        $IFNONE FILFLAG,(FIL$AP,FIL$IM),RDREW01   BRANCH IF A REMOTE\n         LR    R1,RPARMPTR         POINT TO CALLER'S PARM\n        $CALL  RDFILE              CALL INPUT COORDINATOR TO APPEND\n         B     RDREW02             GO TO SUCCESSFUL EXIT\n         SPACE\nRDREW01  DS    0H\n         L     RRMQ,FILRMQAD       REMOTE DESCRIPTOR BLOCKS\n         LTR   RRMQ,RRMQ           DID ALLOC SUCCEED .Q\n         BZ    RDREW03             BRANCH IF NOT\n         USING RMQD,RRMQ           AND TELL THE ASSEMBLER\n         MVC   FILBUFAD,RMQAD      POINT TO FIRST RECORD AGAIN\n         XC    FILITEM,FILITEM     STARTING POINT\n         MVC   FILMIN,IOMIN        FIRST RECORD NUMBER\n         DROP  RRMQ\n         SPACE\nRDREW02  DS    0H\n         SR    R15,R15             SET RETURN CODE\n         B     RDREW04             GO TO RETURN\n         SPACE\nRDREW03  DS    0H\n         LA    R15,4               SET UNSUCCESSFUL RETURN CODE\n         SPACE\nRDREW04  DS    0H\n        $EXIT  RC=(R15)            AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RDSCANF": {"ttr": 11009, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x01>\\x01>\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 318, "newlines": 318, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              OPEN REQUESTED FILE                                    *\n*                                                                     *\n***********************************************************************\n         SPACE\n*  THIS SUBROUTINE ATTEMPTS TO OPEN THE DD STATEMENT WHOSE            *\n*  NAME IS GIVEN IN NEWDDNAM (IF A DCB HAS ALREADY BEEN OPENED        *\n*  FOR THE DD STATEMENT, AND THE DD CARD DOES NOT                     *\n*  POINT TO A SEQUENTIAL FILE                                         *\n*  THEN THE EXISTING DCB IS USED).                                    *\n*                                                                     *\n*  IF THE DD STATEMENT IS OPENED SUCCESSFULLY, AND                    *\n*  HAPPENS TO POINT TO A PARTITIONED DATA SET, THEN THE               *\n*  DIRECTORY OF THE PDS IS FURTHER SEARCHED FOR THE MEMBER            *\n*  SPECIFIED IN BLDLNAME.                                             *\n*                                                                     *\n*  IF ANYTHING FAILS, THE ROUTINE EXITS WITH RDD SET EQUAL TO 0.      *\n*  OTHERWISE, UPON EXIT RDD POINTS TO AN OPEN DDBLOCK.                *\n*                                                                     *\n         SPACE\nRDSCANF $ENTER ,\n         SPACE\n         USING IOBLOK,RPARMPTR\n         MVI   SCANFLAG,X'00'      INITIALIZE THE SCAN FLAG\n         SPACE\n         MVC   LOGDDNAM,NEWDDNAM   SAVE LOGICAL DDNAME\n         LA    R1,NEWDDNAM         THIS IS USER'S NAME\n        $CALL  RDDDREP             ANY REPLACEMENT SPECIFIED .Q\n         MVC   NEWDDNAM,0(R1)      USE IT INSTEAD\n        $IFOFF SWITCHS,CMSWS,SCAN03     BRANCH IF NOT CMS\n         MVC   LOGDDNAM,NEWDDNAM   ALSO CHANGE LOGICAL DDNAME\n         SPACE\n*  SEARCH FOR THE INDICATED DDNAME                                    *\n         SPACE\nSCAN03   DS    0H\n         SR    RRMQ,RRMQ           ASSUME NOT A REMOTE\n        $IFANY IOFLAG,(IO$AP,IO$IM),SCAN03D  BRANCH IF NOT REMOTE\n         L     RRMQ,RMQANCH        START OF REMOTE\n         USING RMQD,RRMQ           AND TELL ASSEMBLER\nSCAN03A  DS    0H\n         LTR   RRMQ,RRMQ           AT THE END .Q\n         BZ    SCAN03B             NOT FOUND IF YES\n        $IFON  RMQFLAG,RMQDEL,SCAN03Z    BRANCH IF REMOTE DELETED\n        $IFOFF IOFLAG,IO$AURM,SCAN03Y    BRANCH IF NOT AUTO REMOTE\n         CLC   RMQPAGE,PAGECNT     REMOTE ELIGIBLE FOR SIGNAL .Q\n         BNL   SCAN03Z             BRANCH IF NOT\nSCAN03Y  DS    0H\n         CLC   RMQNAME,IONAME      IS THIS IT .Q\n         BE    SCAN03B             BRANCH IF YES\nSCAN03Z  DS    0H\n         L     RRMQ,RMQCHN         NEXT ENTRY\n         B     SCAN03A             AND TRY AGAIN\n         SPACE\nSCAN03B  DS    0H\n        $IFOFF IOFLAG,IO$AURM,SCAN03X   BRANCH IF NOT AUTO REMOTE\n         MVC   RMQPAGE,PAGECNT     DISABLE FOR REST OF PAGE\nSCAN03X  DS    0H\n         MVC   IOMEMB,IONAME       REMOTE IDENTIFIER IS MEMBER\n         CLC   F0,IONAME           A NUMBERED REMOTE .Q\n         BNE   SCAN03C             BRANCH IF NOT\n         L     RA,IONAME+4         REMOTE NUMBER\n         LA    RB,IOMEMB           WHERE TO PUT IT\n         BAL   RETURN,BTOC         CONVERT TO CHAR\nSCAN03C  DS    0H\n         MVC   IONAME,=CL8'*.RM*'  DUMMY REMOTE DDNAME\n         LTR   RRMQ,RRMQ           SUCCESSFUL .Q\n         BZ    SCAN03G             BRANCH IF NOT\n        $IFOFF RMQFLAG,RMQDM,SCAN03G    BRANCH IF NOT 'MACRO'\n         MVC   IONAME,=CL8'*.DM*'  DUMMY MACRO DDNAME\nSCAN03G  DS    0H\n         MVC   NEWDDNAM,IONAME     FOR DDBLOCK SEARCH ALSO\n         MVC   LOGDDNAM,IONAME     FOR PRINTING PURPOSES TOO\n         MVC   BLDLNAME,IOMEMB     FOR PUSHDOWN AND ERRORS\n         LTR   RRMQ,RRMQ           SUCCESS .Q\n         BZ    SCANFL04            BRANCH IF NOT\n         B     SCAN05              AND CONTINUE\n         SPACE\nSCAN03D  DS    0H\n        $IFON  SWITCHS,CMSWS,SCAN04A  BRANCH IF UNDER CMS\n         L     RA,CVTPTR           -> THE CVT\n         L     RA,CVTTCB(,RA)      -> PAIR OF TCB WORDS\n         L     RA,4(,RA)           -> CURRENT TCB\n         L     RA,TCBTIO(,RA)      -> CURRENT TIOT\n         LA    RA,24(,RA)          -> DDNAME PART OF TIOT\n         SPACE\n         SR    RB,RB               INITIALIZE IC REGISTER\nSCAN04   DS    0H\n         AR    RA,RB               ADVANCE TO NEXT ENTRY\n         IC    RB,0(,RA)           GET LENGTH OF THIS ENTRY\n         LTR   RB,RB               IS IT ZERO .Q\n         BZ    SCANFL04            IF SO, DDNAME NOT FOUND\n         CLC   NEWDDNAM,4(RA)      IS THIS THE DESIRED DDNAME .Q\n         BNE   SCAN04              LOOK AGAIN IF NOT FOUND\n         SPACE\n*  IF DDNAME POINTS TO A TERMINAL, SET SPECIAL FLAGS                  *\n         SPACE\n         TM    3(RA),X'20'         IS THIS A TERMINAL DATASET .Q\n         BZ    SCAN05              SKIP NEXT INSTRUCTION, IF NOT\n         OI    SCANFLAG,B$PSFRCE+B$TERM SET FLAGS\n        $ON    IOFLAG,IO$TSO       TURN ON IN IO BLOCK TOO\n         B     SCAN05              AND CONTINUE\n         SPACE\n*  UNDER CMS WE DO THINGS DIFFERENTLY                                 *\n         SPACE\nSCAN04A  DS    0H\n         MVC   STATE+8(8),NEWDDNAM GET FILENAME\n         MVC   STATE+16(8),FMSCR1  PRIMARY TYPE\n         XC    ODE(2),ODE          CLEAR ODE SPECIFICATION\n         LA    R1,STATE            POINT TO PLIST\n         SVC   202                 CAN WE FIND IT .Q\n         DC    AL4(SCAN04B)        ERROR EXIT\n         OI    SCANFLAG,B$PSFRCE   FORCE DSORG PS FOR TYPE 'SCRIPT'\n         B     SCAN04D             SUCCESS\nSCAN04B  DS    0H\n         MVC   STATE+16(8),FMSCR2  SECONDARY FILE TYPE\n         XC    ODE(2),ODE          CLEAR ODE SPECIFICATION\n         LA    R1,STATE            POINT TO PLIST\n         SVC   202                 CAN WE FIND IT NOW\n         DC    AL4(SCAN04C)        ERROR EXIT\n         B     SCAN04D             SUCCESS NOW\nSCAN04C  DS    0H\n         DEVTYPE NEWDDNAM,DWORD    GET SOME INFORMATION\n         LTR   R15,R15             TEST RESULT\n         BNZ   SCANFL04            NON ZERO, DDNAME NOT FOUND\n         CLC   DWORD(4),=X'10000820' A 1052 IN CMS .Q\n         BNE   SCANFL04            ERROR IF NOT\n        $ON    IOFLAG,IO$CMS       TURN ON CMS FLAG\n         OI    SCANFLAG,B$PSFRCE+B$TERM SET OTHER FLAGS\n         B     SCAN05              FILE DEF DONE IN INTERFACE\n         SPACE\nSCAN04D  DS    0H\n         L     RB,AFSTCOPY         GET ADDR OF FST\n         USING FST,RB              TELL ASSEMBLER\n         MVC   FDDDNAM,FSTN        FILE NAME\n         MVC   FDNAME,FSTN         FILE NAME\n         MVC   FDTYPE,FSTT         FILE TYPE\n         MVC   FDMODE(2),FSTM      FILE MODE\n         MVC   FDRECFM(1),FSTFV    RECFM\n         L     RA,FSTIL            ITEM LENGTH\n         DROP  RB\n         SPACE\n         CLI   FDRECFM,FDRECFMV    IS THIS A VARIABLE FILE .Q\n         BNE   SCAN04E             BRANCH IF NOT\n         A     RA,F4               BUMP TO INCLUDE RDW LENGTH\nSCAN04E  DS    0H\n         LA    RB,FDLRECL          TARGET FOR LRECL\n         BAL   RETURN,BTOC         CHANGE TO CHARACTER\n         LA    RB,FDBLOCK          TARGET FOR BLOCKSIZE\n         CLI   FDRECFM,FDRECFMV    IS RECFM VARIABLE .Q\n         BNE   SCAN04F             BRANCH IF NOT\n         A     RA,F4               BUMP BY FOUR FOR BLOCK DESCRIPTOR\nSCAN04F  DS    0H\n         BAL   RETURN,BTOC         CHANGE TO CHARACTER\n         LA    R1,FILEDEF          POINT TO PLIST\n         SVC   202                 CREATE FILE DEFINITION\n         DC    AL4(SCAN04C)        ERROR EXIT\n         B     SCAN05              AND CONTINUE\n         SPACE\nBTOC     DS    0H\n         CVD   RA,DWORD            CONVERT TO PACKED\n         MVC   OPTWORK(7),=X'20202020202120' EDIT MASK\n         LA    R1,OPTWORK+6        IN CASE NOTHING\n         EDMK  OPTWORK(7),DWORD+4  EDIT IN NUMBER\n         LR    RA,R1               THIS IS THE START\n         LA    R1,OPTWORK+6        THIS IS THE END\n         SR    R1,RA               THIS IS LENGTH-1\n         MVC   0(8,RB),BLANKS      BLANK TARGET\n         EX    R1,BTOCMVC          MOVE RESULT\n         CVB   RA,DWORD            RESTORE INPUT NUMBER\n         BR    RETURN              AND RETURN\nBTOCMVC  MVC   0(*-*,RB),0(RA)     EXECUTED MOVE RESULT\n         SPACE\n*  CHECK TO SEE IF DCB HAS ALREADY BEEN OPENED FOR THIS DD            *\n         SPACE\nSCAN05   DS    0H\n         L     RDD,FIRSTDD         ADDRESS FIRST DDBLOCK\nSCAN06   DS    0H\n         LTR   RDD,RDD             ARE WE AT END OF THE LIST\n         BZ    SCAN08              IF  SO, MUST OPEN A NEW ONE\n         CLC   DDDDNAM,NEWDDNAM    IS THE DDNAME THE SAME\n         BE    SCAN07              BRANCH IF YES\n         L     RDD,DDNEXT          ELSE ADVANCE TO NEXT DDBLOCK\n         B     SCAN06              AND CHECK AGAIN\n         SPACE\nSCAN07   DS    0H\n         TM    DDDCB+DCBDSORG,DSORG$PS IS IT SEQUENTIAL .Q\n         BZ    SCAN14              IF NOT, USE THIS OPEN DCB\n         TM    DDFLAG,DD$NOCLO     IS THIS A NEVER-CLOSED DCB\n         BO    SCAN14              IF SO, DON'T REOPEN ANOTHER COPY\n         SPACE\n         OI    SCANFLAG,B$PSFRCE   FORCE DSORG=PS IN THE DCB\n         SPACE\n*  OPEN A NEW DDBLOCK FOR THIS FILE.............                      *\n         SPACE\nSCAN08   DS    0H\n         LR    R0,RPARMPTR         RETAIN IOBLOCK BASE\n         LA    R1,DDBLKLN          NEED THIS MUCH STORAGE\n        $CALL  GETCELL             GET AN AREA\n         BC    BNEG,SCANFL01       BRANCH IF FAILED\n         LR    RDD,TEMP            POINT TO GOTTEN AREA\n         LR    RPARMPTR,R0         RESTORE IOBLOCK BASE\n         XC    DDBLOCK(DDBLKLN),DDBLOCK ZERO ENTIRE BLOCK\n         SPACE\n*  LINK THE NEW DDBLOCK ONTO THE CHAIN                                *\n         SPACE\n         L     RA,FIRSTDD          ADDRESS OF FIRST DDBLOCK\n         ST    RA,DDNEXT           LINK NEW DDBLOCK TO START OF CHAIN\n         LTR   RA,RA               IS THE CHAIN CURRENTLY NULL\n         BNZ   *+8                 IF SO, THIS IS ALSO LAST DDBLOCK\n         LA    RA,FIRSTDD\n         ST    RDD,DDPREV-DDBLOCK(,RA) SET PREV PTR ON NEXT BLOCK\n         ST    RDD,FIRSTDD         AND ANCHOR THE CHAIN\n         SPACE\n*  INITIALIZE THE NEW DDBLOCK................                         *\n         SPACE\n         MVC   DDDDNAM,NEWDDNAM    RECORD DDNAME\n         MVC   DDLDDNAM,LOGDDNAM   RECORD LOGICAL DD NAME\n         MVC   DDDCB(DCBLEN),SKELDCB INITIALIZE THE DCB\n         MVC   DDDCB+DCBDDNAM(8),NEWDDNAM DDNAME IN DCB\n         MVI   DDDCB+DCBDSORG,X'00' ZERO OUT THE DSORG\n         SPACE\n*  IF A REMOTE, VERY LITTLE WORK TO DO                                *\n         SPACE\n        $IFANY IOFLAG,(IO$AP,IO$IM),SCAN09   BRANCH IF NOT REMOTE\n         OI    DDFLAG,DD$NOCLO+DD$RM    SET REMOTE AND NOCLOSE\n         MVI   DDDCB+DCBLRECL+1,240     SET DUMMY LRECL\n         B     SCAN18              AND PROCEED\n         SPACE\n*  IF DATASET IS A TERMINAL, FORCE RECFM=V FOR A GOOD OPEN            *\n         SPACE\nSCAN09   DS    0H\n         TM    SCANFLAG,B$TERM     IS IT A TERMINAL\n         BZ    SCAN10              BRANCH IF NOT\n         MVI   DDDCB+DCBRECFM,X'40' SET RECFM=V\n         SPACE\n*  SET UP THE OPEN/CLOSE/RDJFCB PARAMETER LIST                        *\n         SPACE\nSCAN10   DS    0H\n         LA    RA,DDDCB            ADDRESS OF THE DCB\n         O     RA,OPCLOPEN         INCLUDE OPEN FLAGS\n         ST    RA,OPCLPARM         STORE IN PARM LIST\n         SPACE\n         TM    SCANFLAG,B$PSFRCE   IF DSORG=PS IS BEING FORCED, DON'T\n         BO    SCAN12              BOTHER TO READ THE JFCB\n         SPACE\n         RDJFCB MF=(E,OPCLPARM)    ELSE READ THE JFCB\n         SPACE\n         TM    JFCBTSDM,X'20'      SYSIN FILE .Q\n         BNO   SCAN11              BRANCH IF NOT\n         NI    DDDCB+DCBMACR,FF-X'40'   READ WITH NO POINT\nSCAN11   DS    0H\n         CLC   =C'NULLFILE ',JFCBDSNM IS THIS DUMMY .Q\n         BE    SCAN12              YES, FORCE 'PS'\n         CLI   JFCBELNM,C' '       ANY MEMBER NAME ON DDCARD .Q\n         BNE   SCAN12              BRANCH IF YES\n         MVC   DDDCB+DCBDSORG(1),JFCDSORG SET DSORG FOR OPEN\n         B     SCAN13              BRANCH TO OPEN\n         SPACE\nSCAN12   DS    0H\n         MVI   DDDCB+DCBDSORG,DSORG$PS FORCE DSORG=PS\n         SPACE\nSCAN13   DS    0H\n         MVC   RDEXLST+1(3),=AL3(RDEXIT)  DEFINE OPEN EXIT ADDR\n         OPEN  MF=(E,OPCLPARM)     OPEN THE INPUT FILE\n         SPACE\n         TM    DDDCB+DCBOFLGS,X'10' WAS OPEN SUCCESSFUL .Q\n         BZ    SCANFL02            BRANCH IF IT FAILED\n         OI    DDDCB+DCBOFLGS,X'08' SET CONCATENATION ALLOWED\n         SPACE\nSCAN14   DS    0H\n        $IFOFF IOFLAG,IO$NOCLO,SCAN15  BRANCH IF NOCLOSE NOT REQUESTED\n         OI    DDFLAG,DD$NOCLO     ELSE SET FLAG IN DDBLOCK\n         SPACE\nSCAN15   DS    0H\n        $IFNONE IOFLAG,(IO$AP,IO$IM),SCAN18  BRANCH IF A REMOTE\n         TM    DDDCB+DCBDSORG,DSORG$PO IF DATA SET IS PARTITIONED\n         BZ    SCAN16              MUST CHECK TO SEE THAT IT CONTAINS\n         BLDL  DDDCB,BLDLLIST      THE DESIRED MEMBER\n         LTR   R15,R15             TEST WHETHER MEMBER WAS FOUND\n         BNZ   SCANFL02            IF NOT, BRANCH TO FAILURE CODE\n         B     SCAN18              REAL MEMBER IS BEING USED\n         SPACE\nSCAN16   DS    0H\n         CLI   IOMEMB,C' '         WAS AN EXPLICIT MEMBER NAME GIVEN\n         BE    SCAN17              IF NOT, ACCEPT THE SEQUENTIAL FILE\n         SPACE\n         MVI   EFLAG052,ERRSET     SET ERROR FLAG\n        $CALL  RDERROR             ELSE COMMENT...MEMBER NAME IGNORED\n         SPACE\nSCAN17   DS    0H\n         MVC   BLDLNAME,BLANKS     MEMBER NAME NOT BEING USED\n         SPACE\nSCAN18   DS    0H\n         LH    RA,DDUSECT          BUMP THE USAGE COUNT\n         LA    RA,1(,RA)           IN THE DDBLOCK\n         STH   RA,DDUSECT          BY ONE\n         SPACE\nSCAN19   DS    0H\n        $RESTOR KEEP=(RDD,RRMQ)    RESTORE CALLER'S REGISTERS\n         BR    RETURN              RETURN TO THE CALLER\n         SPACE\n*  THIS CODE PROCESSES ERRORS WHICH CAN ARISE IN THE ABOVE SEARCH     *\n*  FOR THE FILE WHICH THE USER SPECIFIED.                             *\n         SPACE\nSCANFL01 DS    0H\n         MVI   EFLAG024,ERRSET     NO STORAGE AVAILABLE\n         B     SCANFL04            GO TO RETURN\n         SPACE\nSCANFL02 DS    0H\n        $CALL  RDCLOSE             CLOSE DDBLOCK IF NOT USED\n         SPACE\nSCANFL04 DS    0H\n         SR    RDD,RDD             SET FILE NOT FOUND FLAG\n         SR    RRMQ,RRMQ           AND IF IT IS A REMOTE\n         B     SCAN19              RETURN TO THE CALLER\n         SPACE\n         DROP  RPARMPTR,RRMQ\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RE": {"ttr": 11015, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00M\\x00M\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 77, "newlines": 77, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .RE (RESTORE STATUS) --- CONTROL                       *\n*                                                                     *\n***********************************************************************\n         SPACE\nRE      $ENTER ,\n         L     X1,STAKANCH         SAVE ELEMENT ANCHOR\n         LTR   X1,X1               FIRST ELEMENT PRESENT .Q\n         BZ    REE011              ERROR IF NOT\n         SPACE\n         USING STAKSAVE,X1         AREA LOOKS LIKE THIS\n         CLC   CDCOUNT,STAKTLD2+CDCOUNT-FMTOLD2   HAS .CD CHANGED .Q\n         BE    RE01                BRANCH IF NOT\n        $CALL  PRINT               CAUSE A BREAK\n         CLI   ICOLFLG,ICOLMC      IN MULTI-COLUMN MODE .Q\n         BNE   RE01                BRANCH IF NOT\n        $CALL  COLPRT              DUMP DATA\n         SPACE\nRE01     DS    0H\n         MVC   STAKANCH,STAKSAVE   UNCHAIN THIS FIRST ELEMENT\n         MVC   SWCTL(SWCTLZ),STAKTLD1   RESTORE LOCAL SWITCHS\n         MVC   FMTOLD2(LFMTOLD2),STAKTLD2  RESTORE PAGE DESCRIPTORS\n         MVC   ICOLFLG,STAKICOL    RESTORE TYPE OF COLUMN FORMAT\n        $MVC   OCCNT,STAKOC        RESTORE OVERLAY CHARACTER STATUS\n         L     R1,TRANADO          OUTPUT TRANSLATE TABLE ADDRESS\n         MVC   0(256,R1),STAKTRNO  RESTORE OUTPUT TRANSLATE TABLE\n         L     R1,TRANADI          INPUT TRANSLATE TABLE ADDRESS\n         MVC   0(256,R1),STAKTRNI  RESTORE INPUT TRANSLATE TABLE\n         L     TEMP,STAKESTA       ESCAPE CHAR/ TABLE ADDRESS\n         ST    TEMP,ESTABAD        RESTORE SAME\n         LA    TEMP,0(,TEMP)       CLEAR CHARACTER\n         LTR   TEMP,TEMP           ADDRESS PRESENT .Q\n         BZ    RE02                BRANCH IF NOT\n         XC    0(256,TEMP),0(TEMP) ZERO THE TABLE\n         SR    R1,R1               ZERO WORKING REGISTER\n         IC    R1,STAKESTA         GET ESCAPE CHARACTER\n         STC   R1,0(R1,TEMP)       ENTER CHARACTER IN THE TABLE\nRE02     DS    0H\n         LA    R1,TBANCHR          PTR TO CURRENT USER TAB ANCHOR\n        $CALL  TBFREBLK            FREE CURRENT USER'S TABS\n         MVC   TBIND,STAKTABI      RESTORE USER TAB CHARACTER\n         MVC   TBANCHR,STAKTABA    RESTORE FORMER TAB CHAIN\n         LA    R0,STAKSAVE         WHERE TO FREE\n         LA    R1,STAKSIZE         HOW MUCH TO FREE\n        $CALL  FREECELL            RELEASE STORAGE\n         DROP  X1\n         L     R1,STAKCTR          COUNT OF NESTED AREAS\n         S     R1,F1               LESS ONE\n         BM    REE011              CAN'T BE ZERO (OR CAN IT) .Q\n         ST    R1,STAKCTR          SET NEW NEST LEVEL\nRE03     DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\nREE011   DS    0H\n         MVI   EFLAG011,ERRSET     STACK IS EMPTY\n         B     RE03                GO TO EXIT\n         SPACE 2\nSTAKFREE $ENTER ,\n         SR    R0,R0               CLEAR WORK REGISTER\n         L     X1,STAKANCH         SAVE/RESTORE ANCHOR POINTER\n         ST    R0,STAKANCH         CLEAR ANCHOR POINTER\n         ST    R0,STAKCTR          CLEAR NEST COUNTER\nSTKF01   DS    0H\n         LTR   X1,X1               AT THE END .Q\n         BZ    STKF02              BRANCH IF YES\n         USING STAKSAVE,X1         AREA LOOKS LIKE THIS\n         LA    R1,STAKTABA         PTR TO CURRENT USER TAB ANCHOR\n        $CALL  TBFREBLK            FREE CURRENT USER'S TABS\n         LA    R0,STAKSAVE         FREE FROM HERE\n         LA    R1,STAKSIZE         FREE THIS MUCH\n         L     X1,STAKCHN          NEXT AREA POINTER\n        $CALL  FREECELL            FREE ONE AREA\n         B     STKF01              GO CHECK FOR DONE\n         DROP  X1\nSTKF02   DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#READ": {"ttr": 11018, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00j\\x00j\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 106, "newlines": 106, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTION 'READ' --- READ TO BUFF2             *\n*                                                                     *\n***********************************************************************\n         SPACE\nREAD    $ENTER ,\nREAD01   DS    0H\n         MVC   BUFF2,BLANKS        CLEAR INPUT AREA TO BLANKS\n         SPACE\n        $IFOFF SWITCHS,HIDBSWS,READ02   BRANCH IF NO HIDDEN BUFFER DATA\n         LA    R1,HIDBANCH         POINT TO ANCHOR\n        $CALL  HIDBDEL             CLEAN UP BUFFERS\n         BC    BOMIT,READ02        BRANCH IF NO DATA\n         L     X1,HIDBANCH         POINT TO HIDDEN BUFFER\n         USING HIDB,X1             AREA LOOKS LIKE THIS\n         LH    TEMP,HIDBLEN        LENGTH OF DATA\n         STH   TEMP,BUFF2LGZ       SET DATA LENGTH\n         BCTR  TEMP,0              LENGTH-1 OF DATA\n         EX    TEMP,READMVCH       MOVE DATA TO BUFFER\n         XC    HIDBLEN,HIDBLEN     ZERO HIDDEN BUFFER LENGTH\n         LA    R1,HIDBANCH         POINT TO ANCHOR\n        $CALL  HIDBDEL             CLEAN UP BUFFERS AGAIN\n         LA    R1,BUFF2LGZ         POINT TO RESULT\n         B     READ06              CONTINUE\n         SPACE\nREADMVCH MVC   BUFF2(*-*),HIDBDATA PASS BACK HIDDEN BUFFER\n         DROP  X1\n         SPACE\nREAD02   DS    0H\n         L     X1,PEANCH           PERFORM LINE ANCHOR\n         LTR   X1,X1               DOES IT EXIST .Q\n         BZ    READ04              BRANCH IF NOT\n         SPACE\n         USING OODSECT,X1          DATA LOOKS LIKE THIS\n         L     R1,OOQCNT           NUMBER OF TIMES LEFT\n         S     R1,F1               LESS ONE\n         BNM   READ03              BRANCH IF SOME LEFT\n         LA    R1,PEANCH           POINT TO ANCHOR\n        $CALL  OVREMOV             DELETE TOP ENTRY\n         B     READ02              AND TRY AGAIN\n         SPACE\nREAD03   DS    0H\n         ST    R1,OOQCNT           UPDATE TIMES LEFT\n         LH    TEMP,OOQRDW         GET DATA LENGTH\n         S     TEMP,F1             DECREMENT AND TEST LENGTH\n         BM    READ02              TRY AGAIN IF NOTHING\n         EX    TEMP,READMVCP       MOVE DATA TO BUFF2\n         LA    TEMP,1(,TEMP)       RESTORE ACTUAL DATA LENGTH\n         STH   TEMP,BUFF2LGZ       AND SET LENGTH\n         LA    R1,BUFF2LGZ         POINT TO RESULT\n         B     READ06              SUCCESSFUL READ\nREADMVCP MVC   BUFF2(*-*),OOQDATA  MOVE PERFORM DATA LINE\n         DROP  X1\n         SPACE\nREAD04   DS    0H\n         LA    R1,BUFF2LGZ         POINT TO TARGET\n         SPACE\nREAD05   DS    0H\n         LA    TEMP,B2LG           GET MAXIMUM LINE LENGTH\n         STH   TEMP,0(,R1)         AND STORE IN PARM AREA\n         SPACE\n        $CALL  RDLINE              GO TO INPUT COORDINATOR\n         B     *+4(R15)            BRANCH ON RETURN CODE\n         B     READ06              SUCCESSFUL READ\n         B     READ07              EOF ON BOTTOM FILE..REISSUE READ\n         B     READ09              EOF ON BOTTOM FILE..USER EXIT\n         B     READ08              EOF ON BOTTOM FILE..REMOTE EXIT\n         LA    R1,WRETQT           FINAL RECORD RETURN CODE\n        $CALL  QUITS               CALL TERMINATION ROUTINE\n         SPACE\nREAD06   DS    0H\n         CLI   1(R1),X'00'         IS THIS A NULL LINE\n         BNE   READ09              IF NOT, PASS IT BACK\n         B     READ05              IF SO, READ ANOTHER ONE\n         SPACE\nREAD07   DS    0H\n         B     READ01              REISSUE THE READ\n         SPACE\nREAD08   DS    0H\n        $CALL  RMNEXT              SET UP FOR NEXT REMOTE IF ANY\n         OC    RMIMSAV(4*16),RMIMSAV    ALTERNATE RETURN .Q\n         BZ    READ01              BRANCH IF NOT\n        $RESTOR ,                  RESTORE CALLER'S DUMMY REGS\n         LM    R0,R15,RMIMSAV      RESTORE STACKED SAVED AREA\n         XC    RMIMSAV(4*16),RMIMSAV    AND CLEAR IT AGAIN\n         BR    RETURN              AND  RETURN TO ITS CALLER\n         SPACE\nREAD09   DS    0H\n         MVI   3(R1),C' '          SET DUMMY CHAR ONE TO BLANK\n        $RESTOR KEEP=(R1)          RESTORE CALLER'S REGISTERS\n         BR    RETURN              AND RETURN TO CALLER\n         SPACE\n***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTION 'TERMREAD' --- READ TO BUFF3         *\n*                                                                     *\n***********************************************************************\n         SPACE\nTERMREAD $ENTER ,\n         L     R1,BUFF3AD          ADDRESS OF INPUT AREA\n         MVC   4(B2LG,R1),BLANKS   CLEAR INPUT AREA TO BLANKS\n         L     BASE2,VSCRICVT      COMMUNICATION VECTOR TABLE\n         L     BASE2,VREAD-SCRICVT(,BASE2)   BASE ADDR OF ROUTINE\n         LA    TEMP,READ05-READ(,BASE2)   WHERE TO ENTER\n         BR    TEMP                ENTER IN MID STREAM\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#REGS": {"ttr": 11021, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x16\\x00\\x16\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              SCRIPT REGISTERS                                       *\n*                                                                     *\n***********************************************************************\n         SPACE\nR0       EQU   0\nR1       EQU   1\nCOUNT    EQU   2\nTEMP     EQU   3\n*R4      EQU   4\n*R5      EQU   5\nRETURN   EQU   6\nX1       EQU   7\nX2       EQU   8\nX3       EQU   9\nBASESAVE EQU   10\nBASE2    EQU   11\nBASE     EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RGNMGR": {"ttr": 11265, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x01\\xe7\\x01\\xe7\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 487, "newlines": 487, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              REGION MANAGER FUNCTION                                *\n*                                                                     *\n***********************************************************************\n         SPACE\nRGPMLIST DSECT\nRGCELLEN DS    A(*-*)              CELL LENGTH FOR GETCELL/FREECELL\nRGCELPTR DS    A(*-*)              CELL ADDRESS FOR GETCELL/FREECELL\nRGFLAGIN DS    XL4                 INPUT FLAGS\nRGMAXEXT DS    AL1                 MAX BLOCKS ALLOCATED - 1\nRGMINEXT DS    AL1                 MIN BLOCKS ALLOCATED - 1\nRGSPNUMB DS    AL1                 SUB-POOL NUMBER\n         DS    AL1                 SPARE\nRGMNCSIZ DS    F                   MIN CELL SIZE\nRGWORKDS DS    0F                  START OF ROUTINE WORK AREA\nMAXEXTS  DS    AL1                 MAX BLOCKS ALLOCATED - 1\nMINEXTS  DS    AL1                 MIN BLOCKS ALLOCATED - 1\n         DS    AL1                 SPARE\n         DS    AL1                 SPARE\nMAXCSIZE DS    A(*-*)              2**CEIL(LOG2(MAX CELL SIZE))\nLG2MAXSZ DS    A(*-*)              CEIL(LOG2(MAX CELL SIZE))\nMINCSIZE DS    A(*-*)              2**CEIL(LOG2(MIN CELL SIZE))\nLG2MINSZ DS    A(*-*)              CEIL(LOG2(MIN CELL SIZE))\nAVLLEN   DS    A(*-*)              AVAIL TABLE LENGTH AND\nAVLPTR   DS    A(*-*,4,*-*)          BXLE SEARCH REGISTERS\n*        AVL(N) FOR N BETWEEN ZERO AND (LG2MAXSZ-LG2MINSZ) IS THE\n*        LINK POINTER TO A LIST OF CELLS OF SIZE 2**(LG2MINSZ+N)\n*        THAT ARE LINKED TOGETHER BY THEIR FIRST WORD. THE ADDRESS\n*        OF AVL(N) IS 4 * N PLUS THE ADDRESS CONTAINED IN AVLPTR.\n*        A NON-ZERO LINK POINTER IS THE EXTENT NUMBER AND ADDRESS\n*        OF THE NEXT CELL.\nEXTLEN   DS    A(*-*)              EXTENT DESCRIPTOR TABLE LENGTH\nEXTPTR   DS    A(*-*,4,*-*)          AND BXLE SEARCH REGISTERS\n*        EXT(M) FOR M BETWEEN ZERO AND MAXEXTS IS THE MTH EXTENT\n*        DESCRIPTOR. FOR M BETWEEN ZERO AND MINEXTS, EXT(M) IS A\n*        PRIMARY EXTENT DESCRIPTOR. FOR M BETWEEN (MINEXTS+1) AND\n*        MAXEXTS, EXT(M) IS A DYNAMIC EXTENT DESCRIPTOR. IF THE\n*        HIGH ORDER BIT OF EXT(M) IS ON, THE EXTENT DESCRIPTOR IS\n*        UNUSED; OTHERWISE, IT IS THE ADDRESS OF AN EXTENT OF SIZE\n*        MAXCSIZE. THE ADDRESS OF EXT(M) IS 4 * M PLUS THE ADDRESS\n*        CONTAINED IN EXTPTR.\nRGRETCDE DS    A(*-*)              FINAL RETURN CODE\nRG2CEIL  DS    A(*-*)              2**CEIL(LOG2(CELL SIZE))\nRGWORKLN EQU   *-RGPMLIST          LENGTH OF WORKAREA\n         EJECT\n***********************************************************************\n*                                                                     *\n*        THIS ROUTINE PROVIDES CELLS OF SIZE 2**K FOR K BETWEEN       *\n*        CEIL(LOG2(RGMNCSIZ)) AND CEIL(LOG2(PMXCSIZE)) BASED ON       *\n*        THE BUDDY SYSTEM RESERVATION AND LIBERATION ALGORITHM AS     *\n*        DESCRIBED IN KNUTH'S \"INFORMATION STRUCTURES\" (PP 442-5).    *\n*                                                                     *\n*        CALLING CONVENTIONS:                                         *\n*                                                                     *\n*              INITIALIZATION:     LA    R1,RGPMLIST                  *\n*                                  MVI   8(R1),X'00'                  *\n*                                 $CALL  RGNMGR                       *\n*                                  BC    15-BPOS,ERROR                *\n*                                                                     *\n*              TERMINATION:        LA    R1,RGPMLIST                  *\n*                                  MVI   8(R1),X'FF'                  *\n*                                 $CALL  RGNMGR                       *\n*                                  BC    15-BPOS,ERROR                *\n*                                                                     *\n*              GETCELL/FREECELL:   SET RGPMLIST+0 TO CELL LENGTH AND  *\n*                                  SET RGPMLIST+4 TO ZERO/CELL ADDRESS*\n*                                  LA    R1,RGPMLIST                  *\n*                                 $CALL  RGNMGR                       *\n*                                  BC    15-BPOS,ERROR                *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nRGNMGR  $ENTER ,\n         LR    BASE,R1             TRANSFER CALLING PARM\n         USING RGPMLIST,BASE       AND TELL THE ASSEMBLER\n         TM    RGFLAGIN,X'FF'      SPECIAL ACTIONS .Q\n         BZ    RMINIT              BRA IF INITIALIZATION CALL\n         BO    RMTERM              BRA IF TERMINATION CALL\n         L     R1,RGCELLEN         GET CELL SIZE\n         BAL   RETURN,RMMXLOG2     ROUND UP TO NEAREST POWER OF TWO\n         B     RET8                BRA IF INVALID REQUEST - R/C=8\n         CL    R0,MINCSIZE         IS SIZE LESS THAN MINCSIZE .Q\n         BNL   *+8                 BRA IF NOT\n         LM    R0,R1,MINCSIZE      ELSE USE MINCSIZE\n         CL    R0,MAXCSIZE         IS SIZE GREATER THAN MAXCSIZE .Q\n         BH    RET8                BRA IF SO - R/C=8\n         ST    R0,RG2CEIL          SAVE 2**CEIL(LOG2(CELL SIZE))\n         OC    RGCELPTR(4),RGCELPTR GETCELL OR FREECELL .Q\n         BZ    RMGET               BRA IF GETCELL\n         B     RMFREE              BRA IF FREECELL\n         EJECT\n***********************************************************************\n*                                                                     *\n*                                  RMINIT                             *\n*                                                                     *\n*        THIS ROUTINE PERFORMS THE FOLLOWING:                         *\n*                                                                     *\n*          (1) INITIALIZES WORKAREA                                   *\n*                                                                     *\n*          (2) SETS UP MINIMUM AND MAXIMUM CELL SIZES                 *\n*                                                                     *\n*          (3) GETMAINS AREA FOR AVAIL TABLE AND EXTENT DESCRIPTOR    *\n*              TABLE                                                  *\n*                                                                     *\n*          (4) SETS UP BXLE REGS FOR AVAIL TABLE AND EXTENT           *\n*              DESCRIPTOR TABLE                                       *\n*                                                                     *\n*          (5) INITIALIZES AVAIL TABLE AND EXTENT DESCRIPTOR TABLE    *\n*                                                                     *\n*          (6) GETMAINS ONE CONTIGUOUS BLOCK OF CORE FOR PRIMARY      *\n*              EXTENTS                                                *\n*                                                                     *\n*          (7) SUBDIVIDES THE GETMAINED AREA, FILLING IN THE EXTENT   *\n*              DESCRIPTOR FOR EACH EXTENT, AND CHAINING THEM OFF THE  *\n*              LAST AVAIL TABLE ENTRY                                 *\n*                                                                     *\n*          (8) RETURNS WITH R/C=0 IF NO ERRORS; OTHERWISE, TERMINATES *\n*              WITH THE APPROPRIATE RETURN CODE                       *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nRMINIT   XC    RGWORKDS(RGPMLIST+RGWORKLN-RGWORKDS),RGWORKDS\n         MVC   MAXEXTS(4),RGMAXEXT COPY INITIALIZATION PARMS\n         MVI   RGFLAGIN,X'80'      INDICATE INITIALIZATION DONE\n         SPACE 1\nRMINIT01 MVC   MAXCSIZE(8),=A(4096,12) SET MAX CELL SIZE\n         MVC   MINCSIZE(8),=A(8,3) SET DEFAULT MIN CELL SIZE\n         L     R1,RGMNCSIZ         GET REQUESTED MIN CELL SIZE\n         CL    R1,MINCSIZE         IS REQUESTED .LT. DEFAULT MIN .Q\n         BNH   RMINIT02            BRA IF SO - USE DEFAULT\n         CL    R1,MAXCSIZE         IS REQUESTED .GT. MAXCSIZE .Q\n         BH    RET8                ERROR IF YES\n         SPACE 1\n         BAL   RETURN,RMMXLOG2     GET 2**CEIL(LOG2(RGMNCSIZ))\n         B     *                     AND CEIL(LOG2(RGMNCSIZ))\n         STM   R0,R1,MINCSIZE          AND STORE THEM\n         SPACE 1\nRMINIT02 L     R1,MAXCSIZE+4       GET CEIL(LOG2(MAXCSIZE))\n         S     R1,MINCSIZE+4         - CEIL(LOG2(MINCSIZE))\n         LA    R1,1(,R1)               + 1\n         SLL   R1,2                GET AVAIL TABLE LENGTH\n         ST    R1,AVLLEN             AND STORE IT\n         SPACE 1\nRMINIT03 SR    R1,R1               ZAP R1\n         IC    R1,MAXEXTS          GET MAXEXTS\n         CLC   MAXEXTS(1),MINEXTS  IS MAXEXTS .LT. MINEXTS .Q\n         BNL   *+8                 BRA IF NOT\n         IC    R1,MINEXTS          ELSE USE MINEXTS\n         STC   R1,MAXEXTS          SET AS MAX EXTENTS\n         LA    R1,1(,R1)             + 1\n         SLL   R1,2                GET EXTENT DESCRIPTOR TABLE LENGTH\n         ST    R1,EXTLEN             AND STORE IT\n         SPACE 1\nRMINIT04 A     R1,AVLLEN           GET TOTAL LENGTH OF TABLES\n         LR    R0,R1               GET LENGTH TO R0\n        $CALL  SYGMAIN             GET AREA FOR TABLES\n         BC    BNEG,RET4           BRANCH IF FAILED\n         SPACE 1\n         LR    X1,R1               GET TABLE ADDRESS\n         LA    X2,4                GET BXLE INCREMENT\n         LR    X3,X1               GET\n         SR    X3,X2                BXLE\n         A     X3,AVLLEN             LIMIT\n         STM   X1,X3,AVLPTR        STORE BXLE SEARCH REGS.\n         A     X1,AVLLEN           GET BXLE START ADDRESS\n         A     X3,EXTLEN           GET BXLE LIMIT\n         STM   X1,X3,EXTPTR        STORE BXLE SEARCH REGS.\n         SPACE 1\n         SR    R0,R0               ZAP R0\n         LM    X1,X3,AVLPTR        GET BXLE REGS\nRMINIT06 ST    R0,0(,X1)           ZAP AVAIL POINTER\n         BXLE  X1,X2,RMINIT06      LOOP TILL ALL POINTERS ZAPPED\n         SPACE 1\n         LM    X1,X3,EXTPTR        LOAD BXLE REGS\nRMINIT07 MVC   0(4,X1),=X'80000000' SET EXTENT DESCRIPTOR TO UNUSED\n         BXLE  X1,X2,RMINIT07      LOOP TILL ALL DESCRIPTORS ZAPPED\n         SPACE 1\nRMINIT08 SR    X3,X3               ZAP X3\n         IC    X3,MINEXTS          GET MINEXTS\n         LA    X3,1(,X3)             + 1\n         M     X2,MAXCSIZE         COMPUTE PRIMARY EXTENT SIZE\n         LR    R0,X3               GET LENGTH TO R0\n        $CALL  SYGMAIN             GET PRIMARY EXTENTS\n         BC    BPOS,RMINIT09       BRANCH IF SUCCESS\n         LA    R0,4                RETURN CODE OF FOUR\n         ST    R0,RGRETCDE         SET EVENTUAL RETURN CODE\n         B     RMTERM03            TERMINATE WITH R/C=4\n         SPACE 1\nRMINIT09 DS    0H\n         LR    X1,R1               GET FIRST PRIMARY EXTENT ADDR\n         L     X2,MAXCSIZE         GET MAX CELL SIZE\n         SR    X3,X2               GET LAST PRIMARY\n         AR    X3,X1                 EXTENT ADDRESS\n         L     COUNT,AVLPTR+8      PTR -> PREVIOUS NODE\n         L     TEMP,EXTPTR         PTR -> EXTENT DESCRIPTOR\n         SR    R1,R1               ZAP EXTENT NUMBER\n         SPACE 1\nRMINIT10 ST    X1,0(,TEMP)         ADD CELL TO EXTENT DESCRIPTOR LIST\n         LA    TEMP,4(,TEMP)       POINT TO NEXT EXTENT DESCRIPTOR\n         ST    X1,0(,COUNT)        PREVIOUS NODE -> PRESENT NODE\n         STC   R1,0(,COUNT)        PREVIOUS NODE<-EXT# OF PRESENT NODE\n         LA    R1,1(,R1)           INCREMENT EXTENT NUMBER\n         LR    COUNT,X1            PTR -> PRESENT NODE\n         BXLE  X1,X2,RMINIT10      X1 -> NEXT NODE\n         XC    0(4,COUNT),0(COUNT) ZAP FOREWARD POINTER OF LAST NODE\n         SPACE 1\n         XC    RGCELLEN(8),RGCELLEN CLEAR CELL LENGTH & ADDRESS\n         B     RET0                RETURN WITH R/C=0\n         EJECT\n***********************************************************************\n*                                                                     *\n*                                  RMTERM                             *\n*                                                                     *\n*        THIS ROUTINE PERFORMS THE FOLLOWING:                         *\n*                                                                     *\n*          (1) FREES THE EXTENTS                                      *\n*                                                                     *\n*          (2) FREES THE AVAIL TABLE AND THE EXTENT DESCRIPTOR TABLE  *\n*                                                                     *\n*          (3) RESTORES THE RGPMLIST TO ITS ORIGINAL STATE            *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nRMTERM   DS    0H\n         XC    RGRETCDE,RGRETCDE   SET EVENTUAL RETURN CODE TO ZERO\n         LM    X1,X3,EXTPTR        LOAD BXLE REGS\n         SPACE 1\nRMTERM01 TM    0(X1),X'80'         IS EXTENT DESCRIPTOR USED .Q\n         BO    RMTERM02            BRA IF NOT\n         L     R0,MAXCSIZE         GET FREEMAIN PARM REG 0\n         L     R1,0(,X1)           GET FREEMAIN PARM REG 1\n        $CALL  SYFMAIN             FREE EXTENT\nRMTERM02 BXLE  X1,X2,RMTERM01      LOOP TILL ALL EXTENTS FREED\n         SPACE 1\nRMTERM03 DS    0H\n         L     R0,AVLLEN           GET AVAIL TABLE LENGTH\n         A     R0,EXTLEN             + EXTENT DESCRIPTOR TABLE LENGTH\n         L     R1,AVLPTR           GET FREEMAIN PARM REG 1\n        $CALL  SYFMAIN             FREE TABLES\n         SPACE 1\n         L     R15,RGRETCDE        GET RETURN CODE\n         B     *+4(R15)            GO AS REQUIRED\n         B     RET0                IF ALL OK\n         B     RET4                IF SOME ERROR\n         B     RET8                IF ALL BAD\n         EJECT\nRET0     DS    0H\n        $CC    POS                 SUCCESSFUL RETURN\n         B     RETURN0             RETURN\n         SPACE 1\nRET4     DS    0H\n        $CC    NEG                 UNSUCCESSFUL RETURN\n         B     RETURN0             RETURN\n         SPACE 1\nRET8     DS    0H\n        $CC    DNO                 VERY UNSUCCESSFUL\n         B     RETURN0\n         SPACE 1\nRETURN0  DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*                                  RMGET                              *\n*                                                                     *\n*        THIS ROUTINE PERFORMS THE FOLLOWING:                         *\n*                                                                     *\n*          (1) SEARCHES THE AVAIL TABLE FOR THE FIRST NON-EMPTY       *\n*              LIST OF NODES WITH SIZE GREATER THAN OR EQUAL TO       *\n*              THE REQUESTED CELL SIZE                                *\n*                                                                     *\n*          (2) GETS SECONDARY EXTENT IF SEARCH IS UNSUCCESSFUL,       *\n*              AN UNUSED EXTENT DESCRIPTOR IS AVAILABLE, AND THE      *\n*              GETMAIN IS SUCCESSFUL, ADDS IT TO THE EXTENT           *\n*              DESCRIPTOR TABLE, AND ENTERS IT INTO THE LAST          *\n*              AVAIL TABLE LIST                                       *\n*                                                                     *\n*          (3) REMOVES THE NODE FROM THE LIST, IF SEARCH IS           *\n*              SUCESSFUL                                              *\n*                                                                     *\n*          (4) SPLITS THE BLOCK IF THE NODE IS LARGER THAN THE        *\n*              REQUESTED CELL SIZE, ENTERS THE UNUSED HALF ON THE     *\n*              APPROPRIATE LIST AND REPEATS THIS UNTIL A NODE OF      *\n*              THE PROPER SIZE IS FOUND                               *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nRMGET    S     R1,LG2MINSZ         COMPUTE INDEX INTO\n         SLL   R1,2                  AVAIL TABLE\n         LM    X1,X3,AVLPTR        LOAD BXLE SEARCH REGS\n         AR    X1,R1               ADD INDEX TO TABLE BASE ADDRESS\n         LR    TEMP,X1             SAVE START ADDRESS FOR LATER\n         SPACE 1\nRMGET01  L     COUNT,0(,X1)        GET LIST POINTER\n         LTR   COUNT,COUNT         IS LIST EMPTY .Q\n         BNZ   RMGET04             BRA IF NOT\n         BXLE  X1,X2,RMGET01       LOOP TIL END OR NON-EMPTY LIST\n         SPACE 1\n         LM    X1,X3,EXTPTR        GET EXTENT DESCRIPTOR BXLE REGS\nRMGET02  TM    0(X1),X'80'         EXTENT DESCRIPTOR USED .Q\n         BO    RMGET03             BRA IF NOT\n         BXLE  X1,X2,RMGET02       LOOP TIL EMPTY DESCRIPTOR FOUND\n         B     RET4                BRA IF ALL EXTENTS FILLED - R/C=4\n         EJECT\nRMGET03  L     R0,MAXCSIZE         GET EXTENT LENGTH\n        $CALL  SYGMAIN             GET EXTENT\n         BC    BNEG,RET4           BRANCH IF UNSUCCESSFUL\n         LR    COUNT,R1            GET NEW EXTENT ADDRESS\n         ST    COUNT,0(,X1)        ADD TO EXTENT DESCRIPTOR TABLE\n         S     X1,EXTPTR           GET EXTENT\n         SLL   X1,22                 NUMBER TO H.O. BYTE\n         OR    COUNT,X1                OF NEW EXTENT ADDRESS\n         LM    X1,X3,AVLPTR        GET AVAIL TABLE SEARCH REGS\n         LR    X1,X3               POINT AT LAST AVAIL TABLE ENTRY\n         XC    0(4,COUNT),0(COUNT) ZAP FOREWARD LINK IN NEW EXTENT\n         ST    COUNT,0(,X1)        ADD NEW EXTENT TO AVAIL TABLE\n         SPACE 1\nRMGET04  MVC   0(4,X1),0(COUNT)    REMOVE NODE FROM LIST\n         SPACE 1\nRMGET05  CR    X1,TEMP             IS NODE RIGHT SIZE .Q\n         BE    RMGET06             BRA IF SO\n         SR    X1,X2               POINT TO PREVIOUS AVAIL TABLE ENTRY\n         LR    R1,X1               GET OFFSET INTO\n         S     R1,AVLPTR             AVAIL TABLE\n         SRL   R1,2                    / 4\n         A     R1,LG2MINSZ               + LOG2(MINCSIZE)\n         BAL   RETURN,RM2EXPR1     GET 2**(R1)\n         LR    R1,R0               LOAD IT INTO R1\n         ALR   R1,COUNT            GET BUDDY ADDRESS FOR SPLIT\n         XC    0(4,R1),0(R1)       ZAP FOREWARD LINK IN BUDDY\n         ST    R1,0(,X1)           ADD BUDDY TO LIST\n         B     RMGET05             REPEAT TIL BLOCK OF RIGHT SIZE\n         SPACE 1\nRMGET06  ST    COUNT,RGCELPTR      STORE CELL ADDRESS\n         MVC   RGCELLEN,RG2CEIL    STORE CELL LENGTH\n         B     RET0                RETURN WITH R/C=0\n         EJECT\n***********************************************************************\n*                                                                     *\n*                                  RMFREE                             *\n*                                                                     *\n*        THIS ROUTINE PERFORMS THE FOLLOWING:                         *\n*                                                                     *\n*          (1) LOCATES THE EXTENT DESCRIPTOR CONTAINING THE CELL      *\n*              TO BE FREED                                            *\n*                                                                     *\n*          (2) VERIFIES THAT THE CELL DISPLACEMENT INTO THE EXTENT    *\n*              IS DIVISIBLE BY THE FIRST POWER OF TWO GREATER THAN    *\n*              OR EQUAL TO THE SIZE OF THE CELL TO BE FREED           *\n*                                                                     *\n*          (3) GETS THE EXTENT NUMBER INTO THE HIGH-ORDER BYTE OF     *\n*              THE CELL ADDRESS                                       *\n*                                                                     *\n*          (4) GETS THE EXTENT NUMBER AND CELL ADDRESS OF ITS BUDDY,  *\n*              OR ZERO, IF THERE IS NO BUDDY (IE. IF CELL SIZE        *\n*              EQUALS MAX CELL SIZE)                                  *\n*                                                                     *\n*          (5) FREES THE EXTENT AND RETURNS, IF THE CELL SIZE IS      *\n*              EQUAL TO THE MAX CELL SIZE, AND THE EXTENT IS A        *\n*              SECONDARY EXTENT                                       *\n*                                                                     *\n*          (6) SEARCHES THE APPROPRIATE AVAIL TABLE LIST FOR THE      *\n*              BUDDY OR THE CORRECT SPOT TO INSERT THE CELL           *\n*                                                                     *\n*          (7) REMOVES BUDDY FROM LIST (IF FOUND) AND GOES TO STEP    *\n*              4 WITH (COUNT) AND RG2CEIL CONTAINING ADDR AND SIZE    *\n*              OF THE NEW BLOCK TO BE FREED, OR INSERTS THE CELL      *\n*              INTO THE LIST AND RETURNS                              *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nRMFREE   L     COUNT,RGCELPTR      GET CELL ADDRESS\n         LA    COUNT,0(,COUNT)     ZAP H.O. BYTE\n         MVC   RGCELLEN,RG2CEIL    PASS BACK ACTUAL LENGTH FREED\n         LM    X1,X3,EXTPTR        LOAD EXTENT DESCRIPTOR BXLE REGS\n         SPACE 1\nRMFREE01 TM    0(X1),X'80'         EXTENT DESCRIPTOR USED .Q\n         BO    RMFREE02            BRA IF NOT\n         CL    COUNT,0(,X1)        ADDRESS WITHIN THIS EXTENT .Q\n         BL    RMFREE02            BRA IF NOT\n         L     R0,MAXCSIZE         GET MAX CELL SIZE\n         AL    R0,0(,X1)             + EXTENT ADDRESS\n         CLR   COUNT,R0            ADDRESS WITHIN EXTENT .Q\n         BL    RMFREE03            BRA IF SO\nRMFREE02 BXLE  X1,X2,RMFREE01      LOOP TIL EXTENT FOUND\n         B     RET8                ERROR IF NOT FOUND - R/C=8\n         EJECT\nRMFREE03 LR    R1,COUNT            GET CELL ADDRESS\n         SL    R1,0(,X1)           GET CELL DISPLACEMENT\n         SR    R0,R0               ZAP TOP OF DIVIDEND\n         D     R0,RG2CEIL          GET DISPLACEMENT MOD (RG2CEIL)\n         LTR   R0,R0               IS IT ZERO .Q\n         BNZ   RET8                BRA IF NOT - R/C=8\n         SPACE 1\n         LR    R0,X1               GET EXTENT\n         S     R0,EXTPTR             NUMBER TO\n         SLL   R0,22                   H.O. BYTE\n         OR    COUNT,R0                  OF CELL ADDRESS\n         SPACE 1\nRMFREE04 LR    TEMP,COUNT          GET EXTENT NUMBER AND CELL ADDRESS\n         SL    TEMP,0(,X1)         GET CELL DISPLACEMENT\n         X     TEMP,RG2CEIL        GET BUDDY CELL DISPLACEMENT\n         AL    TEMP,0(,X1)         GET BUDDY CELL ADDRESS\n         L     R1,RG2CEIL          GET CELL SIZE\n         C     R1,MAXCSIZE         CHECK CELL SIZE\n         BM    RMFREE05            BRA IF CELL SIZE .LT. MAXCSIZE\n         SR    TEMP,TEMP           ZAP BUDDY POINTER\n         LR    R1,COUNT            GET EXTENT\n         SRL   R1,24                 NUMBER\n         EX    R1,RFREECLI         IS IT PRIMARY EXTENT .Q\n         BNL   RMFREE05            BRA IF NOT\n         L     R0,MAXCSIZE         GET FREEMAIN PARM REG 0\n         L     R1,0(,X1)           GET FREEMAIN PARM REG 1\n        $CALL  SYFMAIN             FREE SECONDARY EXTENT\n         MVC   0(4,X1),=X'80000000' SET EXTENT DESCRIPTOR TO UNUSED\n         B     RMFREE09            RETURN\n         SPACE 1\nRFREECLI CLI   MINEXTS,*-*         PRIMARY EXTENT .Q\n         EJECT\nRMFREE05 L     R1,RG2CEIL          GET CELL SIZE\n         BAL   RETURN,RMMXLOG2     GET\n         B     *                     (CEIL(LOG2(CELL SIZE))\n         S     R1,LG2MINSZ             - LG2MINSZ)\n         SLL   R1,2                      * 4\n         AL    R1,AVLPTR                   + A(AVAIL TABLE)\n         LR    X2,R1               X2 -> PROPER LIST TO INSERT NODE\n         SPACE 1\nRMFREE06 L     X3,0(X2)            X3 -> NEXT CELL\n         LTR   X3,X3               IS POINTER NULL .Q\n         BZ    RMFREE08            BRA IF SO - INSERT CELL\n         CLR   X3,TEMP             IS NEXT CELL BUDDY CELL .Q\n         BE    RMFREE07            BRA IF SO - MERGE CELL WITH BUDDY\n         CLR   COUNT,X3            IS CELL PTR .LE. NEXT CELL PTR .Q\n         BNP   RMFREE08            BRA IF SO - INSERT CELL\n         LR    X2,X3               ELSE ADVANCE PTR AND\n         B     RMFREE06              CONTINUE SEARCH\n         SPACE 1\nRMFREE07 MVC   0(4,X2),0(X3)       REMOVE BUDDY FROM LIST\n         L     R1,RG2CEIL          GET CELL SIZE\n         SLL   R1,1                DOUBLE CELL SIZE\n         ST    R1,RG2CEIL          AND PUT IT BACK\n         CLR   COUNT,TEMP          IS COUNT .LE. TEMP .Q\n         BNH   *+6                 BRA IF SO\n         LR    COUNT,TEMP          ELSE COUNT = TEMP\n         B     RMFREE04            REPEAT PROCESS\n         SPACE 1\nRMFREE08 ST    X3,0(,COUNT)        LINK(CELL PTR) = NEXT CELL PTR\n         ST    COUNT,0(,X2)        LINK(LAST CELL PTR) = CELL PTR\n         SPACE 1\nRMFREE09 XC    RGCELPTR,RGCELPTR   INDICATE CELL FREED\n         B     RET0                RETURN WITH R/C=0\n         EJECT\n***********************************************************************\n*                                                                     *\n*        THIS ROUTINE RETURNS 4(R14) WITH R1 CONTAINING CEIL(LOG2(N)) *\n*        AND R0 CONTAINING 2**CEIL(LOG2(N)), IF THE NUMBER (N),       *\n*        SUPPLIED IN R1 UPON ENTRY, IS IN THE RANGE 1 TO 2**31-1;     *\n*        OTHERWISE, IT RETURNS 0(R14) WITH R0 AND R1 CONTAINING THE   *\n*        ORIGINAL CONTENTS OF R1.                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nRMMXLOG2 LTR   R0,R1               IS NUMBER .GT. 0 .Q\n         BNPR  RETURN              BRA IF NOT - ERROR\n         LA    RETURN,4(,RETURN)   SET EXIT ADDRESS\n         SR    R1,R1               ZAP EXPONENT\n         BCT   R0,*+8              BRA IF NUMBER .GT. 1\n         B     RM2EXPR1            GET 2**(R1)\n         SPACE 1\n         LA    R1,1(,R1)           INCREMENT EXPONENT\n         SRA   R0,1                DIVIDE NUMBER BY 2\n         BNZ   *-8                 LOOP IF QUOTIENT NON-ZERO\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*        THIS ROUTINE RETURNS 0(R14) WITH R0 CONTAINING 2**(R1).      *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nRM2EXPR1 LA    R0,1                R0=1\n         SLL   R0,0(R1)            R0=2**(R1)\n         BR    RETURN              RETURN\n         SPACE 2\n         LTORG ,\n         SPACE\n         DROP  BASE\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#RIGHTAD": {"ttr": 11273, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x18\\x00\\x18\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*                                 RIGHTADJ                            *\n*                                                                     *\n*              RIGHT ADJUST A LINE.                                   *\n*                                                                     *\n***********************************************************************\n         SPACE\nRIGHTADJ $ENTER ,\n         USING FOPMLIST,R1\n         USING LINKELEM,P\n         L     C,FOLL              CURRENT LINE LENGTH\n         AH    C,FOINDR            PLUS RIGHT INDENT VALUE\n         S     C,FONOCHAR          LESS LENGTH OF CHARS IN LINE\n         BNP   RIRET               IF LINE OVERFLOWS, DON'T TRY\n         L     P,FOPFIRST          GET FIRST LINK ELEMENT\n         SR    M,M                 PICKUP OLD MULTIPLIER\n         IC    M,LINKMULT          ..\n         AR    M,C                 RIGHT ADJUST THE LINE\n         STC   M,LINKMULT          ..\nRIRET    DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\n         DROP  P,R1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RM": {"ttr": 11275, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x01\"\\x01\"\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 290, "newlines": 290, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .RM (REMOTE DEFINITION) --- CONTROL                    *\n*                                                                     *\n***********************************************************************\n         SPACE\nRM      $ENTER ,\n        $CALL  GETNUM              GET FIRST ARGUMENT\n         BC    BOMIT,RME003        WON'T ASSUME A BEGINNING\n         BC    BDNO,RM01           BRANCH IF ERROR, TRY AGAIN\n         LTR   COUNT,COUNT         TEST RESULT\n         BNP   RME014              ERROR IF TOO SMALL\n         C     COUNT,F32767        TEST AGAIN\n         BH    RME013              ERROR IF TOO BIG\n         B     RM06                VALID LINE NUMBER\n         SPACE\nRM01     DS    0H\n         ST    COUNT,ARGSTART      RESCAN FOR STRING OPERAND\n        $CALL  GETYESNO            GET AND TEST ARG\n         CLI   YNRESULT,YNDEL      IS IT 'DELETE' .Q\n         BNE   RM02                BRANCH IF NOT\n        $SAVE  ,                   SAVE CURRENT REGISTERS\n         L     R0,ARGSTART         RETAIN SCAN START POINTER\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION PLEASE\n        $CALL  GETARG              ANY ARGUMENTS AFTER 'DELETE' .Q\n         ST    R0,ARGSTART         RESTORE SCAN START POINTER\n        $RESTOR ,                  AS YOU WERE\n         BC    BOMIT,RMDALL        'DELETE' STANDS ALONE\nRM02     DS    0H\n         LTR   TEMP,TEMP           LENGTH-1 OF ZERO .Q\n         BNZ   RM03                BRANCH IF NOT\n         CLI   0(COUNT),C'*'       DEFAULT FIRST OPERAND .Q\n         BE    RM05                BRANCH IF YES\nRM03     DS    0H\n         LA    R0,L'APIMNAME-1     MAX LENGTH-1 ALLOWED\n         CR    TEMP,R0             CHECK IT\n         BNH   RM04                BRANCH IF OK\n         LR    TEMP,R0             MAX WILL DO\nRM04     DS    0H\n         MVC   APIMNAME,BLANKS     BLANK REMOTE NAME TARGET\n         EX    TEMP,RMNAMVC        MOVE IN REMOTE NAME\n         OC    APIMNAME,BLANKS     CONVERT NAME TO UPPER CASE\n         B     RM07                AND CONTINUE\nRMNAMVC  MVC   APIMNAME(*-*),0(COUNT)   FIRST REMOTE STRING ARG\n         SPACE\nRM05     DS    0H\n         LH    COUNT,TOPMRG        DEFAULT FIRST ARG, FIRST TEXT LINE\n         LA    COUNT,1(,COUNT)     BUMP TOP MARGIN BY ONE\nRM06     DS    0H\n         XC    APIMNAME,APIMNAME   ZERO NAME TARGET\n         ST    COUNT,APIMNAME+4    ADD LINE NUMBER\n         SPACE\nRM07     DS    0H\n         XC    RMFLAG,RMFLAG       ZERO SCANNING FLAG BYTE\n         MVI   RMDELIM,C' '        BLANK CHAR DELIMITER\n         MVC   RMCWIND,BUFF2       CONTROL WORD INDICATOR FOR REMOTE\n         XC    RMCNT,RMCNT         AND CALL COUNT WORD\n        $CALL  GETYESNO            GET AND TEST SECOND ARG\n         BC    BPOS,RM09           BRANCH IF POSITIVE TO SAVE\n         BC    BNEG+BOMIT,RM10     BRANCH NEGATIVE OR OMITTED TO NOSAVE\n         CLI   YNRESULT,YNDEL      IS ARGUMENT 'DELETE' .Q\n         BNE   RM08                BRANCH IF NOT\n        $CALL  RMDEL               DELETE ONE INTERNAL FILE\n         BC    BNEG,RME017         BRANCH IF NOT FOUND\n         B     RMRET               GO TO RETURN\n         SPACE\nRM08     DS    0H\n         ST    COUNT,ARGSTART      RESCAN FOR NUMERIC\n        $CALL  GETNUM              GO FOR CALL COUNT\n         BC    BDNO,RME005         BRANCH IF INVALID\n         LTR   COUNT,COUNT         TEST RESULT\n         BNP   RME014              BRANCH IF TOO SMALL\n         B     RM11                AND CONTINUE\nRM09     DS    0H\n         L     COUNT,F32767        CALL COUNT LARGE\n         B     RM11                AND CONTINUE\nRM10     DS    0H\n         LA    COUNT,1             CALL COUNT ONLY ONE\nRM11     DS    0H\n         ST    COUNT,RMCNT         RETAIN CALL COUNT\n         SPACE\n        $CALL  GETYESNO            KEEP ENVIRONMENT THRU REMOTE .Q\n         BC    BDNO,RME005         ERROR IF INVALID\n         BC    BPOS+BOMIT,RM12     BRANCH IF AFFIRMATIVE\n        $ON    RMFLAG,RMQKEEP      SET KEEP/RESTORE SWITCH\n         SPACE\nRM12     DS    0H\n        $CALL  RMFIND              FIND QUEUE ENTRY POINT\n         LA    R1,RMQLEN           QUEUE ELEMENT LENGTH\n        $CALL  GETCELL             GET AN AREA\n         BC    BNEG,RME018         BRANCH IF FAILED\n         USING RMQD,TEMP           AREA GOT\n         XC    RMQD(RMQLEN),RMQD   CLEAR THE AREA\n         MVC   RMQCHN,RMQCHN-RMQD(X1)   NEXT POINTER\n         ST    TEMP,RMQCHN-RMQD(X1)     LAST POINTER\n         MVC   RMQFLAG,RMFLAG      FLAG ATTRIBUTES\n         MVC   RMQCNT,RMCNT        CALL COUNT\n         MVC   RMQNAME,APIMNAME    REMOTE IDENTIFIER\n         SPACE\n         LA    R0,RMQD             POINT TO ANCHOR\n        $CALL  RMREAD              ENTER DATA FOR REMOTE\n         ST    R1,RMQFSIZ          ENTER COUNT OF RECORDS\n         B     RMRET               AND GO TO RETURN\n         DROP  TEMP\n         SPACE\nRMDALL   DS    0H\n        $CALL  RMCLR               DELETE ALL REMOTES\n         B     RMRET               AND GO TO RETURN\n         SPACE\nRME003   DS    0H\n         MVI   EFLAG003,ERRSET     OMITTED OPERAND\n         B     RMRET               GO TO TERMINATE\nRME005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     RMRET               GO TO TERMINATE\nRME013   DS    0H\n         MVI   EFLAG013,ERRSET     OPERAND TOO BIG\n         B     RMRET               GO TO TERMINATE\nRME014   DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     RMRET               GO TO TERMINATE\nRME017   DS    0H\n         MVI   EFLAG017,ERRSET     REMOTE UNDEFINED\n         B     RMRET               GO TO TERMINATE\nRME018   DS    0H\n         MVI   EFLAG018,ERRSET     NO ROOM TO STORE REMOTE\n         B     RMRET               GO TO TERMINATE\n         SPACE\nRMRET    DS    0H\n        $CALL  RMNEXT              SET UP FOR NEXT REMOTE\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\n***********************************************************************\n*                                                                     *\n*              INTERNAL ROUTINE RMFIND --- FIND REMOTE INSERT POINT   *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  APIMNAME CONTAINS REMOTE NAME\n*        ON EXIT   --  (X1)  IS INSERTION ADDRESS\n         SPACE\nRMFIND  $ENTER ,                   SAVE CALLER'S REGISTERS\n         LA    X1,RMQANCH-RMQCHN+RMQD   PRETEND USED QUEUE PTR\nRMFI01   DS    0H\n         L     X2,RMQCHN-RMQD(,X1) LOAD FORWARD POINTER\n         LTR   X2,X2               CHECK FOR CHAIN END\n         BZ    RMFI04              BRANCH IF AT THE END\n         USING RMQD,X2\n         CLC   F0,APIMNAME         A NUMBERED REMOTE .Q\n         BE    RMFI02              BRANCH IF YES\n         CLC   APIMNAME,RMQNAME    COMPARE REMOTE IDENTIFIER\n         BNH   RMFI04              BRANCH IF FOUND INSERT POINT (LIFO)\n         B     RMFI03              AND CONTINUE\nRMFI02   DS    0H\n         CLC   APIMNAME,RMQNAME    COMPARE REMOTE IDENTIFIER\n         BL    RMFI04              BRANCH IF FOUND INSERT POINT (FIFO)\nRMFI03   DS    0H\n         LR    X1,X2               NO, CONTINUE SEARCH\n         B     RMFI01              AND LOOP BACK\n         DROP  X2\n         SPACE\nRMFI04   DS    0H\n        $RESTOR KEEP=(X1)          RESTORE CALLER'S REGISTERS\n         BR    RETURN              AND RETURN TO CALLER\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              INTERNAL ROUTINE RMREAD --- BUILD A REMOTE             *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R0) -> RMQD\n*\n*        ON EXIT   --  (R1)   =  COUNT OF RECORDS IN REMOTE\n         SPACE\nRMREAD  $ENTER ,\n         LR    TEMP,R0             INPUT PARAMETER\n         USING RMQD,TEMP           ENTER PARAMETER\n         LA    X3,RMQAD+RMQRCHN-RMQR    POINTER TO STRING START\n         DROP  TEMP\n         USING RMQR,X3             TELL THE ASSEMBLER\n         SR    X2,X2               ZERO REMOTE LINE COUNT\nRMRD01   DS    0H\n         LA    X2,1(,X2)           BUMP REMOTE LINE COUNT\n         C     X2,DEFRMSIZ+TAB3DEF TOO MANY LINES IN ONE REMOTE\n         BH    RMRDE019            BRANCH IF YES\n        $CALL  READ                GET NEXT INPUT LINE\n         CLC   PERIND,BUFF2        CONTROL WORD INDICATOR .Q\n         BNE   RMRD03              BRANCH IF NOT\n         MVC   DECM(2),BUFF2+1     ENTER PROBABLE CONTROL WORD\n         CLC   PERIND,BUFF2+1      DOUBLE WHAMMY .Q\n         BNE   RMRD02              BRANCH IF NOT\n         MVC   DECM(2),BUFF2+2     ENTER NOW PROBABLE CONTROL WORD\nRMRD02   DS    0H\n         OC    DECM(2),BLANKS      UPPER CASE\n         CLC   RMCW,DECM           A REMOTE COMMAND .Q\n         BE    RMRD07              YES, GO TO RETURN\n         SPACE\nRMRD03   DS    0H\n         LH    R1,BUFF2LGZ         DATA LENGTH\n         LA    R1,RMQRLN(,R1)      PLUS OVERHEAD\n        $CALL  GETCELL             GET A BUFFER\n         BC    BNEG,RMRDE018       BRANCH IF FAILED\n         ST    TEMP,RMQRCHN        FORWARD POINTER\n         LR    X3,TEMP             NEW AREA\n         XC    RMQR(RMQRLN),RMQR   CLEAR RECORD PREFIX AREA\n         LH    TEMP,BUFF2LGZ       RECORD LENGTH\n         STH   TEMP,RMQRLEN        SET LENGTH\n         S     TEMP,F1             LESS ONE\n         BM    RMRD05              BRANCH IF NULL\n         EX    TEMP,RMRDMVC        MOVE DATA TOO\nRMRD05   DS    0H\n         B     RMRD01              BACK FOR MORE TEXT\n         SPACE\nRMRD07   DS    0H\n         LR    R1,X2               COUNT OF RECORDS READ\n        $EXIT  RC=0,KEEP=(R1)      RETURN TO CALLER\n         SPACE\nRMRDMVC  MVC   RMQRDATA(*-*),BUFF2 TEXT TO SAVE\n         DROP  X3\nRMRDE018 DS    0H\n         MVI   EFLAG018,ERRSET     NO ROOM TO STORE REMOTE\n         B     RMRD07              GO TO RETURN\nRMRDE019 DS    0H\n         MVI   EFLAG019,ERRSET     TOO MANY RECORDS IN ONE REMOTE\n         B     RMRD07              GO TO RETURN\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              INTERNAL ROUTINE RMCLR --- DELETE ALL REMOTES/MACROS   *\n*                                                                     *\n***********************************************************************\n         SPACE\nRMCLR   $ENTER ,\n         LA    X1,RMQANCH-RMQCHN+RMQD   PRETEND USED QUEUE PTR\nRMCLR01  DS    0H\n         USING RMQD,X1\n         L     X1,RMQCHN           LOAD FORWARD POINTER\n         LTR   X1,X1               AT THE END .Q\n         BZ    RMCLR02             BRANCH IF YES\n         OI    RMQFLAG,RMQDEL      DELETE THE REMOTE\n         B     RMCLR01             DO THE NEXT\n         DROP  X1\n         SPACE\nRMCLR02  DS    0H\n        $CALL  RMNEXT              AND CLEAN UP ENVIRONMENT\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTION 'RMDEL' --- DELETE ONE MACRO/REMOTE  *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  APIMNAME  HAS NAME TO DELETE\n*                  --  RMFLAG    INDICATES MACRO OR REMOTE\n*\n*        ON EXIT   --  CC=BPOS   IF SUCCESSFUL\n*                      CC=BNEG   IF UNSUCCESSFUL\n         SPACE\nRMDEL   $ENTER ,\n         LA    X1,RMQANCH-RMQCHN+RMQD   START OF REMOTE/MACRO QUQUE\nRMDEL01  DS    0H\n         USING RMQD,X1             QUEUE ELEMENTS LOOK LIKE THIS\n         LTR   X1,X1               AT THE END .Q\n         BZ    RMDEL07             BRANCH BACK IF YES\n         TM    RMQFLAG,RMQDEL      HAS THIS ALREADY BEEN DELETED .Q\n         BO    RMDEL02             BRANCH IF YES\n         CLC   APIMNAME,RMQNAME    COMPARE MACRO/REMOTE NAME\n         BE    RMDEL03             BRANCH IF EQUAL\nRMDEL02  DS    0H\n         L     X1,RMQCHN           NEXT MACRO/REMOTE\n         B     RMDEL01             AND TRY AGAIN\n         SPACE\nRMDEL03  DS    0H\n        $IFON  RMFLAG,RMQDM,RMDEL04     BRANCH IF MACRO CHECK\n        $IFON  RMQFLAG,RMQDM,RMDEL02    BRANCH IF THIS IS A MACRO\n         B     RMDEL05             SUCCESSFUL COMPARISON\nRMDEL04  DS    0H\n        $IFOFF RMQFLAG,RMQDM,RMDEL02    BRANCH IF THIS IS NOT A MACRO\nRMDEL05  DS    0H\n         OI    RMQFLAG,RMQDEL      DELETE THIS ENTRY\n        $CC    POS                 SET SUCCESS\n         B     RMDEL07             AND GO TO RETURN\n         SPACE\nRMDEL06  DS    0H\n        $CC    NEG                 SET UNSUCCESSFUL\n         SPACE\nRMDEL07  DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RMCOND": {"ttr": 11526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x002\\x002\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        INTERNAL FUNCTION 'RMCOND' --- CONDITIONALLY IMBED A REMOTE  *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER:   LA  R1,=CL8'NAME'\n*                   $CALL RMCOND\n*\n*        ON EXIT:    CC = BOMIT  IF REMOTE NOT FOUND\n*                       = BPOS   IF REMOTE FOUND AND IMBEDDED\n         SPACE\nRMCOND  $ENTER ,\n         LR    X3,R1               RETAIN REMOTE NAME POINTER\n         L     X1,RMQANCH          START OF REMOTE QUEUE\n         USING RMQD,X1             TELL THE ASSEMBLER\nRMC01    DS    0H\n         LTR   X1,X1               AT THE END .Q\n         BZ    RMC04               BRANCH OUT IF YES\n        $IFON  RMQFLAG,RMQDEL,RMC02     BRANCH IF REMOTE DELETED\n         L     R1,RMQUSE           GET CURRENT REMOTE USE COUNT\n         LTR   R1,R1               IS IT ACTIVE .Q\n         BNZ   RMC02               IF YES, AVOID RECURSION\n         CLC   RMQPAGE,PAGECNT     ALREADY AUTO TRIGGERED THIS PAGE .Q\n         BNL   RMC02               YES, DON'T DO IT AGAIN\n         CLC   RMQNAME,0(X3)       EQUAL IDENTIFIER\n         BH    RMC04               NOT FOUND IF TOO BIG\n         BE    RMC03               FOUND IF EQUAL\nRMC02    DS    0H\n         L     X1,RMQCHN           CHAIN TO NEXT REMOTE HEADER\n         B     RMC01               AROUND AGAIN\n         DROP  X1\n         SPACE\nRMC03    DS    0H\n         MVC   APIMNAME,0(X3)      ENTER REMOTE NAME\n         MVC   APIMMEMB,BLANKS     CLEAR MEMBER NAME\n         XC    APIMFLAG,APIMFLAG   CLEAR FLAGS\n        $ON    APIMFLAG,(IO$RM,IO$UEOF) I WANT IT LIKE THIS\n        $ON    APIMFLAG,(IO$AURM,IO$SYRM)    AND LIKE THIS\n         L     R1,FM8              NEGATIVE EIGHT MEANS NAME WORK DONE\n        $CALL  RMIMBED             DO THE REMOTE IMBED\n        $CALL  RMNEXT              SET UP FOR NEXT AUTO REMOTE, IF ANY\n        $CC    POS                 'TIS DONE\n         B     RMC05               GO TO RETURN\n         SPACE\nRMC04    DS    0H\n        $CC    OMIT                REMOTE NOT FOUND\n         SPACE\nRMC05    DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RMIMBED": {"ttr": 11528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00@\\x00@\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        INTERNAL FUNCTION 'RMIMBED' --- IMBED A REMOTE SEQUENCE.     *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER:   $CALL  RMIMBED                                   *\n*                  (R1) = -1 --  APIMBLOCK MOSTLY BUILT BY .SI        *\n*                  (R1) = -4 --  (SAME AS ABOVE SOME DAY)             *\n*                  (R1) = -8 --  AUTOMATIC NAMED REMOTE               *\n*                  (R1) = 0  --  SHOULD NEVER HAPPEN                  *\n*                  (R1) > 0  --  AUTO REMOTE NUMBER TO IMBED          *\n         SPACE\nRMIMBED $ENTER ,\n         MVC   RMIMSAV(4*16),0(BASESAVE)     SAVE REGS FOR PUSHDOWN\n         LTR   X1,R1               TEST CALL TYPE\n         BP    RMIM01              BRANCH IF NUMBERED AUTOMATIC\n         BZ    ABRMIM              BRANCH IF DON'T KNOW\n         C     X1,FM8              AUTOMATIC NAMED REMOTE .Q\n         BE    RMIM02              BRANCH IF YES\n         B     RMIM03              ELSE IDENT FILLED IN\n         SPACE\nRMIM01   DS    0H\n         XC    APIMNAME,APIMNAME   CLEAR IDENTIFIER\n         SH    R1,PLZ              LESS PAGE LENGTH\n         LCR   R1,R1               MAKE IT POSITIVE\n         A     R1,F1               PLUS ONE\n         ST    R1,APIMNAME+4       ENTER REMOTE NUMBER\n         XC    APIMFLAG,APIMFLAG   CLEAR FLAGS\nRMIM02   DS    0H\n         MVC   APIMMIN,F1          DEFAULT MIN RECORD NUMBER\n         MVC   APIMMAX,F16MEG      DEFAULT MAX RECORD NUMBER\n         MVC   APIMGOTO,BLANKS     CLEAR GOTO TARGET\n         SPACE\n        $ON    APIMFLAG,(IO$RM,IO$UEOF)  THIS IS A REMOTE\n        $ON    APIMFLAG,IO$AURM    REMOTE TRIGGERED AUTOMATICALLY\n         XC    RMTRIG,RMTRIG       PREVENT ANY MORE AUTOMATIC REMOTES\n         B     RMIM04              AND CONTINUE\n         SPACE\nRMIM03   DS    0H\n         XC    RMIMSAV(16*4),RMIMSAV    CLEAR RETURN REGS FOR SIGNAL\n         SPACE\nRMIM04   DS    0H\n         LA    R1,APIMBLOK         IN ORDER TO IMBED THIS NEW FILE\n        $CALL  RDFILE              INPUT COORDINATOR WILL DO IT\n         C     X1,FM8              AUTOMATIC NAMED REMOTE .Q\n         BE    RMIM06              BRANCH IF YES TO DRIVER\n         LTR   X1,X1               A SIGNAL REQUEST .Q\n         BM    RMIM05              BRANCH IF YES\n        $IFOFF SWITCHS,FRMKP,RMIM06  BRANCH IF DON'T KEEP ENVIRONMENT\nRMIM05   DS    0H\n        $OFF    SWITCHS,FRMKP      RESET KEEP FLAG\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              RETURN TO CALLER\n         SPACE\nRMIM06   DS    0H\n        $OFF   SWITCHS,FRMKP       RESET FLAG\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         L     RETURN,VMAIN        TOP OF SCRIPTW DRIVER\n         L     BASE,ADBASE         SCRIPT BASE\n         BR    RETURN              RETURN TO SCRIPT\n         SPACE\nABRMIM   DS    0H\n        $LOGERR 1006               REMOTE IMBED CALL ERROR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RMNEXT": {"ttr": 11530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00l\\x00l\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 108, "newlines": 108, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        INTERNAL FUNCTION 'RMNEXT' --- SET PAGE COUNT WHICH          *\n*        CORRESPONDS TO NEXT REMOTE TRIGGER                           *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER:   $CALL  RMNEXT\n*\n*        ON EXIT:   RMTRIG = 0  --  IF NO REMOTE WITHIN PAGE LENGTH\n*                   RMTRIG > 0  --  IF REMOTE FOUND\n*            AND:   RMNAMLEN    --  FLAGS SET FOR LENGTH OF REMOTE NAME\n         SPACE\nRMNEXT  $ENTER ,\n         XC    RMNAMLEN,RMNAMLEN   CLEAR ALL REMOTE NAME LENGTH FLAGS\n         LA    X3,RMQANCH-RMQCHN+RMQD   START REMOTE DESCRIPTOR QUEUE\n         USING RMQD,X1             AND TELL THE ASSEMBLER\nNRM00    DS    0H\n         L     X1,RMQCHN-RMQD(,X3) NEXT REMOTE DESCRIPTOR\n         LTR   X1,X1               AT THE END .Q\n         BZ    NRM06               BRANCH OUT IF YES\n        $IFON  RMQFLAG,RMQDEL,NRM03     BRANCH IF REMOTE DELETED\n         CLC   RMQNAME(4),F0       A NUMBERED REMOTE .Q\n         BE    NRM02               BRANCH IF YES\n         LA    R1,RMQNAME+L'RMQNAME     END OF REMOTE NAME +1\nNRM01    DS    0H\n         BCTR  R1,0                BACKUP CHAR POINTER\n         CLI   0(R1),C' '          TRAILING BLANK .Q\n         BE    NRM01               YES, KEEP SCANNING\n         LA    R0,RMQNAME          FIRST CHAR OF NAME\n         SR    R1,R0               LENGTH-1 OF NAME\n         LA    R1,RMNAMLEN(R1)     POINT TO LENGTH FLAGS\n         MVI   0(R1),RMNAMDEF      AT LEAST ONE DEFINED\nNRM02    DS    0H\n         LR    X3,X1               LAST REMOTE DESCRIPTOR\n         B     NRM00               DO THEM ALL\n         SPACE\nNRM03    DS    0H\n         L     X2,RMQAD            FIRST REMOTE TEXT LINE\n         L     R1,RMQEXIT          REMOTE READ EXIT ADDRESS\n         LTR   R1,R1               ANY ADDRESS PRESENT .Q\n         BZ    NRM04               BRANCH IF NOT\n         SR    X2,X2               IF PRESENT, THEN NO REMOTE LINES\nNRM04    DS    0H\n         LA    R0,RMQD             REMOTE QUEUE DESCRIPTOR\n         LA    R1,RMQLEN           AND ITS LENGTH\n         MVC   RMQCHN-RMQD(L'RMQCHN,X3),RMQCHN    UNCHAIN THIS REMOTE\n         L     X1,RMQCHN           NEXT REMOTE DESCRIPTOR\n         DROP  X1\n        $CALL  FREECELL            RELEASE REMOTE DESCRIPTOR\n         SPACE\nNRM05    DS    0H\n         LTR   X2,X2               END OF REMOTE TEXT LINES .Q\n         BZ    NRM00               BRANCH BACK IF YES\n         USING RMQR,X2             THIS IS WHERE THE DATA IS\n         LA    R0,RMQR             TEXT LINE INFO\n         LH    R1,RMQRLEN          LENGTH OF DATA\n         LA    R1,RMQRLN(,R1)      PLUS OVERHEAD\n         L     X2,RMQRCHN          NEXT TEXT LINE\n         DROP  X2\n        $CALL  FREECELL            RELEASE THE DATA\n         B     NRM05               DO ALL DATA LINES\n         SPACE\nNRM06    DS    0H\n         LH    R1,PLZ              CURRENT PAGE LENGTH\n         SH    R1,PLCT             LESS LINES LEFT ON PAGE\n         LA    R1,1(,R1)           LINE ABOUT TO PRINT\n         XC    APIMNAME,APIMNAME   CLEAR WORK NAME\n         ST    R1,APIMNAME+4       ENTER LINE TO PRINT\n         SPACE\nNRM07    DS    0H\n         SR    R0,R0               ZERO WORK REGISTER\n         STH   R0,RMTRIG           ASSUME AUTO TRIGGER FAILURE\n         CH    R0,RMNMNEST         IN AUTOMATIC REMOTE .Q\n         BNE   NRM11               NO AUTOMATIC REMOTES IF YES\n         L     X1,RMQANCH          START OF REMOTE QUEUE\n         USING RMQD,X1             TELL THE ASSEMBLER\nNRM08    DS    0H\n         LTR   X1,X1               AT THE END .Q\n         BZ    NRM11               BRANCH OUT IF YES\n        $IFON  RMQFLAG,RMQDEL,NRM09     BRANCH IF DELETED\n        $IFON  RMQFLAG,RMQDM,NRM09      BRANCH IF A MACRO DEFINITION\n         L     R1,RMQCNT           GET REMOTE CALL COUNT\n         S     R1,RMQUSE           LESS CURRENT USE COUNT\n         BNP   NRM09               BRANCH IF REMOTE IS THROUGH\n         CLC   RMQPAGE,PAGECNT     ALREADY AUTO TRIGGERED THIS PAGE .Q\n         BNL   NRM09               YES, DON'T DO IT AGAIN\n         SPACE\n         CLC   RMQNAME,APIMNAME    CHECK AGAINST CURRENT LINE\n         BNL   NRM10               IF CURRENT OR BIGGER, QUIT\nNRM09    DS    0H\n         L     X1,RMQCHN           CHAIN TO THE NEXT\n         B     NRM08               AND AROUND AGAIN\n         SPACE\nNRM10    DS    0H\n         C     R0,RMQNAME          IDENTIFIER OR NUMBER .Q\n         BNE   NRM11               IDENTIFIER, SO RETURN\n         L     R1,RMQNAME+4        GET LINE NUMBER OF NEXT REMOTE\n         SH    R1,PLZ              LESS PAGE LENGTH\n         BP    NRM11               NOT FOUND IF PAGE LENGTH GREATER\n         LPR   R1,R1               MAKE RESULT POSITIVE\n         LA    R1,1(,R1)           PLUS ONE\n         STH   R1,RMTRIG           SET VALUE OF PLCT FOR REMOTE\n         DROP  X1\n         SPACE\nNRM11    DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RO": {"ttr": 11533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x17\\x00\\x17\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .RO (ROMAN NUMBERING) --- CONTROL                      *\n*                                                                     *\n***********************************************************************\n         SPACE\nRO      $ENTER ,\n        $ON    SWITCHS,FROMAN      ROMAN NUMERALS NOW\n        $OFF   SWITCHS,FUPCASE     ASSUME LOWER CASE ROMAN\n        $CALL  GETYESNO            GET AND TEST ANY ARGUMENT\n         BC    BOMIT,RO02          BRANCH IF ARG OMITTED\n         CLI   YNRESULT,YNLOWER    'LOWER' CASE SPECIFIED .Q\n         BE    RO02                BRANCH IF YES\n         CLI   YNRESULT,YNNOUP     'NOUPPER' SAME AS LOWER .Q\n         BE    RO02                BRANCH IF YES\n         CLI   YNRESULT,YNUP       'UPPER' CASE SPECIFIED .Q\n         BE    RO01                BRANCH IF YES\n         MVI   EFLAG005,ERRSET     ELSE AN INVALID OPERAND\n         B     RO02                AND GO TO RETURN\nRO01     DS    0H\n        $ON    SWITCHS,FUPCASE     SET UPPER CASE ROMAN\nRO02     DS    0H\n        $EXIT  RC=0                CONTINUE WITH NEXT LINE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RV": {"ttr": 11535, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00H\\x00H\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 72, "newlines": 72, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .RV (READ VARIABLE) --- CONTROL                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nRV      $ENTER ,\n         L     X1,ARGSTART         REMEMBER OUT BEGINNINGS\n        $CALL  GETSYM              GET SYMBOL FROM INPUT STRING\n         BC    BOMIT,RV03          IF NOTHING, EXIT\n         BC    15-BDNO,RV01        BRANCH IF VALID\n        $IFON  SRNMFLG,SRNMTSYM,RVE008  BRANCH IF BAD SYMBOL\n        $IFON  SRNMFLG,SRNMTSUB,RVE038  BRANCH IF BAD SUBSCRIPT\n        $IFANY SRNMFLG,(SRNMTFR,SRNMTTO),RVE039  BR IF BAD SUBSTRING\n         CLC   SRNMFR,SRNMFR+L'SRNMFR   'FROM' SUBSTR SPECIFIED .Q\n         BNE   RVE039              ERROR IF YES\n         CLC   SRNMTO,SRNMTO+L'SRNMTO   'TO' SUBSTR SPECIFIED .Q\n         BNE   RVE039              ERROR IF YES\n         SPACE\nRV01     DS    0H\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION PLEASE\n        $CALL  GETARG              ANY MORE DATA .Q\n         BC    15-BOMIT,RVE005     YES, ERROR\n         SPACE\n         LA    COUNT,1             WE NEED ONE LINE\n         ST    COUNT,CONSMAX       STORE COUNT IN PARM BLOCK\n         XC    CONSFLAG,CONSFLAG   CLEAR CONSOLE FLAGS\n        $ON    CONSFLAG,IO$JIGG    SPECIFY 'JIGGLE' TYPEBALL\n        $ON    CONSFLAG,IO$UEOF    IGNORE ALL EOFS\n        $ON    CONSFLAG,IO$IM      AND IMBED THIS FILE\n         MVC   CONSGOTO,BLANKS     CLEAR GOTO TARGET\n         SPACE\n         LA    R1,CONSBLOK         'IMBED' THE CONSOLE FILE\n        $CALL  RDFILE              CALL INPUT SUPERVISOR\n         SPACE\n        $CALL  TERMREAD            READ ONE LINE\n         LH    COUNT,0(,R1)        LENGTH OF RESULT\n         LTR   COUNT,COUNT         ANYTHING THERE .Q\n         BZ    RV03                BRANCH IF NOTHING\n         L     TEMP,ARGSTART       ENTER OPERAND HERE\n         EX    COUNT,RVMVC         MOVE OPERAND\n         MVI   0(TEMP),C'='        ADD EQUAL SIGN\n         LA    TEMP,2(TEMP,COUNT)  POINT TO LAST CHAR\n         ST    TEMP,ARGSTOP        END HERE\n         ST    X1,ARGSTART         START HERE\n         LA    COUNT,BUFF1-1       START OF NEW STRING\n         SR    TEMP,COUNT          RESULTING LENGTH\n         STH   TEMP,BUFF2LGZ       SET LENGTH FOR ANY ERRORS\n        $CALL  SR                  MAKE ASSIGNMENT\n         SPACE\nRV02     DS    0H\n        $CALL  TERMREAD            FIND OUR OWN EOF\n         LH    COUNT,0(,R1)        GET LENGTH\n         LTR   COUNT,COUNT         BETTER BE NULL\n         BNZ   RV02                NO, TRY AGAIN\nRV03     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nRVE005   DS    0H\n         MVI   EFLAG005,ERRSET     TOO MANY OPERANDS\n         B     RV03                GO TO RETURN\nRVE008   DS    0H\n         MVI   EFLAG008,ERRSET     BAD REFERENCE SYMBOL\n         B     RV03                GO TO RETURN\nRVE038   DS    0H\n         MVI   EFLAG038,ERRSET     INVALID SUBSCRIPT\n         B     RV03                GO TO RETURN\nRVE039   DS    0H\n         MVI   EFLAG039,ERRSET     INVALID SUBSTRING\n         B     RV03                GO TO RETURN\n         SPACE\nRVMVC    MVC   1(*-*,TEMP),3(R1)   RV OPERAND STRING\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SA": {"ttr": 11777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00/\\x00/\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .SA (SAVE STATUS) --- CONTROL                          *\n*                                                                     *\n***********************************************************************\n         SPACE\nSA      $ENTER ,\n         L     X3,STAKCTR          SAVE NEST COUNTER\n         LA    X3,1(,X3)           PLUS ONE\n         LA    R0,STAKMAX          MAXIMUM NEST ALLOWED\n         CR    X3,R0               EXCEEDED THE MAXIMUM .Q\n         BH    SAE011              ERROR IF YES\n         L     X1,STAKANCH         POINTER TO FIRST SAVE ELEMENT\n         LA    R1,STAKSIZE         SPACE FOR ONE MORE LEVEL\n        $CALL  GETCELL             GET THE AREA\n         BC    BNEG,SAE024         FORGET IF NO SPACE\n         SPACE\n         USING STAKSAVE,TEMP       AREA LOOKS LIKE THIS\n         ST    TEMP,STAKANCH       SET NEW FIRST SAVE ELEMENT\n         ST    X1,STAKCHN          POINT TO NEXT ELEMENT\n         ST    X3,STAKCTR          SET NEW NEST COUNTER\n         MVC   STAKTLD1(SWCTLZ),SWCTL      SAVE SWITCHES\n         MVC   STAKTLD2(LFMTOLD2),FMTOLD2  SAVE PAGE DESCRIPTORS\n         MVC   STAKICOL,ICOLFLG         SAVE TYPE OF COLUMN FORMAT\n         MVC   STAKOC,OCCNT        SAVE OVERLAY CHARACTER STATUS\n         XC    OCCNT,OCCNT         CLEAR COUNT LEFT\n         MVC   OCCHAR,OCCHAR+1     AND RESET CHARACTER\n         L     R1,TRANADO          OUTPUT TRANSLATE TABLE ADDRESS\n         MVC   STAKTRNO,0(R1)      SAVE OUTPUT TRANSLATE TABLE\n         L     R1,TRANADI          INPUT TRANSLATE TABLE ADDRESS\n         MVC   STAKTRNI,0(R1)      SAVE INPUT TRANSLATE TABLE\n         MVC   STAKESTA,ESTABAD    SAVE ESCAPE CHAR/TABLE ADDRESS\n        $CALL  TBCOPY              COPY USER'S CURRENT TABS\n         MVC   STAKTABI,TBIND      SAVE USER TAB CHARACTER\n         MVC   STAKTABA,TBANCHR    SAVE CURRENT TAB\n         ST    R1,TBANCHR          SAVE COPY ANCHOR\n         DROP  TEMP\n         SPACE\nSA01     DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\nSAE011   DS    0H\n         MVI   EFLAG011,ERRSET     SAVE STACK EXCEEDED\n         B     SA01                GO TO RETURN\nSAE024   DS    0H\n         MVI   EFLAG024,ERRSET     NO STORAGE TO SAVE\n         B     SA01                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SC": {"ttr": 11779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00#\\x00#\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .SC (SINGLE COLUMN) --- CONTROL                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nSC      $ENTER ,\n         CLI   ICORFLG,ICORNONE    'NO KEEP' IN PROGRESS\n         BNE   SCE043              ERROR IF NOT\n         L     R1,SCCOUNT          SINGLE COLUMN NEST COUNT\n         A     R1,F1               PLUS ONE\n         ST    R1,SCCOUNT          UPDATE SINGLE COLUMN COUNT\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n         CLI   ICOLFLG,ICOLMC      IN MULTI-COLUMN MODE .Q\n         BNE   SC02                BRANCH IF NOT\n         OC    FNQCNT,FNQCNT       ANY FOOTNOTES QUEUED .Q\n         BZ    SC01                BRANCH IF NONE\n         LA    R1,1                CONSTANT ONE\n         C     R1,CDCURR           CURRENTLY IN COLUMN ONE\n         BE    SC01                YES, LET IT RIDE\n        $CALL  COLNEW              FINISH OFF THIS COLUMN\n         SPACE\nSC01     DS    0H\n        $CALL  COLPRT              PRINT COLUMNS TO THIS POINT\n         MVI   ICOLFLG,ICOLSC      IN SINGLE COLUMN MODE\nSC02     DS    0H\n         L     R1,LLZ              GET LINE LENGTH\n         ST    R1,CLLZ             AND SET TO COLUMN LENGTH\n         SPACE\nSC03     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nSCE043   DS    0H\n         MVI   EFLAG043,ERRSET     INVALID CONTROL WORD WITHIN KEEP\n         B     SC03                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SCRIPUT": {"ttr": 11781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00D\\x00D\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        INTERNAL FUNCTION 'SCRIPUT' --- OUTPUT RECORD TO FORMAT FILE *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER:   R0 -> RDW OF OUTPUT RECORD\n*                   $CALL  SCRIPUT\n         SPACE\nSCRIPUT $ENTER ,\n         LR    X1,R0               RECORD RDW POINTER\n         MVC   DECM(2),0(X1)       ALIGN LENGTH TO PUT\n         LH    X2,DECM             GET LENGTH TO PUT\n         LTR   COUNT,X2            TEST FOR VALID\n         BNP   ABSCPUT             ERROR IF TOO SMALL\n        $IFOFF TTYPE,TONLINE,SCPUT01    BRANCH IF NOT ONLINE\n         SPACE\n         LR    R0,X1               RESTORE RDW POINTER\n        $CALL  PUTCONS             DISPLAY LINE TO TERMINAL\n         B     SCPUT07             GO TO RETURN\n         SPACE\nSCPUT01  DS    0H\n         LA    R1,BLNKRDWL         LENGTH OF BLANK LINE\n         CH    R1,0(,X1)           A CANDIDATE .Q\n         BNE   SCPUT03             BRANCH IF NOT\n         CLI   5(X1),C' '          BLANK DATA .Q\n         BNE   SCPUT03             BRANCH IF NOT\n         LA    R1,1                SINGLE SPACE\n         CLI   4(X1),SINGLSP       IS IT .Q\n         BE    SCPUT02             BRANCH IF YES\n         LA    R1,2                DOUBLE SPACE\n         CLI   4(X1),DOUBLSP       IS IT .Q\n         BE    SCPUT02             BRANCH IF YES\n         LA    R1,3                TRIPLE SPACE\n         CLI   4(X1),TRIPLSP       IS IT .Q\n         BNE   SCPUT03             BRANCH IF NOT\nSCPUT02  DS    0H\n         A     R1,FLOFFSP          CURRENT OUTSTANDING SPACES\n         ST    R1,FLOFFSP          NEW OUTSTANDING TOTAL\n         B     SCPUT07             AND GO TO RETURN\n         SPACE\nSCPUT03  DS    0H\n         CLI   4(X1),SINGLSP       IS THIS JUST SINGLE SPACE .Q\n         BE    SCPUT05             BRANCH IF YES\n         CLI   4(X1),C'1'          IS THIS A CHANNEL SKIP .Q\n         BL    SCPUT04             BRANCH IF NOT\n         XC    FLOFFSP,FLOFFSP     CLEAR OUTSTANDING SPACES\n         XC    FLOFFCH,FLOFFCH     AND OUTSTANDING CHANNEL SKIP\n         SPACE\nSCPUT04  DS    0H\n         SR    R0,R0               SET PARM TO FLUSH THEM ALL\n        $CALL  FLUSHSP             FLUSH ALL SPACES\n         LR    R0,X1               RESTORE RDW POINTER\n         B     SCPUT06             AND CONTINUE\nSCPUT05  DS    0H\n        $CALL  FLUSHSP             FLUSH TRIPLE SPACES\n         L     R1,FLOFFSP          OUTSTANDING SPACES LEFT\n         IC    R1,SPACTABL+1(R1)   INDEX CARRIAGE CONTROL\n         STC   R1,4(,X1)           SET CARRIAGE CONTROL\n         XC    FLOFFSP,FLOFFSP     CLEAR OUTSTANDING SPACES\nSCPUT06  DS    0H\n        $CALL  PUTPRT              OUTPUT THE RECORD\nSCPUT07  DS    0H\n        $RESTOR ,                  RESTORE ALL REGISTERS\n         BR    RETURN              AND RETURN TO CALLER\n         SPACE\nABSCPUT  DS    0H\n        $LOGERR 1013               QUIT GRACEFULLY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SE": {"ttr": 11783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x1d\\x00\\x1d\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .SE (SET REFERENCE) --- CONTROL                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nSE      $ENTER ,\n         MVC   URMAXCNT(2),URMAXCNT+2   INITIALIZE SUBSTITUTION COUNT\n         LH    X1,URMAXCNT         DEFINE INITIAL VALUE\nSE01     DS    0H\n         LA    R1,BUFF2-1          BLANK BEFORE START OF LINE\n         ST    R1,ARGSTART         POINTER TO START OF RECORD\n         AH    R1,BUFF2LGZ         PLUS RECORD LENGTH\n         ST    R1,ARGSTOP          STORE LAST ADDR IN RECORD\n        $CALL  UR                  SUBSTITUTE SOMETHING\n         OC    ERRFLGS,ERRFLGS     ANY ERRORS FOUND .Q\n         BNZ   SE02                GO TO RETURN IF YES\n         S     X1,F1               DECREMENT SUBSTITUTES BY ONE\n         BM    SEE009              LOOPING IF MINUS\n         STH   R1,URMAXCNT         UPDATE NUMBER LEFT\n        $IFON  SWITCHS,URSWS,SE01  AGAIN IF SOME SUBSTITUTION MADE\n        $CALL  ARGINIT             INITIALIZE POINTERS AGAIN\n        $CALL  SR                  PROCESS AS IF .SR\nSE02     DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\nSEE009   DS    0H\n         MVI   EFLAG009,ERRSET     INFINITE SUBSTITUTION\n         B     SE02                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SI": {"ttr": 11785, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00o\\x00o\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 111, "newlines": 111, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .SI (SIGNAL REMOTE) --- CONTROL                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nSI      $ENTER ,\n        $CALL  SITST               GET AND TEST FIRST ARG\n         BC    BNEG,SI01           ERROR IF TOO SMALL\n         BC    BPOS,SI02           ERROR IF TOO BIG\n        $CALL  SIS                 DO THE WORK\n         B     SI03                AND GO TO COMMON EXIT\n         SPACE\nSI01     DS    0H\n         MVI   EFLAG014,ERRSET     TOO SMALL\n         B     SI03                AND GO TO COMMON EXIT\nSI02     DS    0H\n         MVI   EFLAG013,ERRSET     TOO BIG\nSI03     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nSIS     $ENTER ,\n        $CALL  APS                 GET AND SET ANY ARGS\n         BC    BNEG,SIS01          BRANCH IF ARGUMENT ERRORS\n         SR    R1,R1               IDENTIFIER ALREADY ENTERED\n         BCTR  R1,0                SO NEGATIVE PARM\n         SPACE\n         XC    APIMFLAG,APIMFLAG   CLEAR FLAGS\n        $ON    APIMFLAG,(IO$RM,IO$UEOF) THIS IS WHAT I WANT\n        $CALL  RMIMBED             DO THE REMOTE IMBED\n        $CALL  RMNEXT              SET UP FOR NEXT AUTO REMOTE, IF ANY\n         SPACE\nSIS01    DS    0H\n        $EXIT  RC=0                AND CONTINUE\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              SIGNAL NAME TEST --- SUBROUTINE                        *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON EXIT  --  CC = BNEG IF ARG TOO SMALL\n*                        = BPOS IF ARG TOO BIG\n*                        = BDNO IF NOT FOUND\n*                        = BOMIT IF SUCCESS\n         SPACE\nSITST   $ENTER ,\n        $CALL  GETNUM              GET FIRST ARGUMENT\n         BC    BOMIT,SIT04         BRANCH IF NONE FOUND\n         BC    BDNO,SIT01          BRANCH IF ERROR, TRY AGAIN\n         LTR   COUNT,COUNT         TEST RESULT\n         BNP   SIT09               ERROR IF TOO SMALL\n         C     COUNT,F32767        TEST AGAIN\n         BH    SIT10               ERROR IF TOO BIG\n         B     SIT05               VALID LINE NUMBER\n         SPACE\nSIT01    DS    0H\n         ST    COUNT,ARGSTART      RESCAN FOR STRING ARG\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION\n        $CALL  GETARG              GET IDENTIFIER\n         LTR   TEMP,TEMP           LENGTH OF ONE .Q\n         BNZ   SIT02               BRANCH IF NOT\n         CLI   0(COUNT),C'*'       DEFAULT FIRST ARG .Q\n         BE    SIT04               BRANCH IF YES\nSIT02    DS    0H\n         LA    R0,L'APIMNAME-1     MAX LENGTH-1 ALLOWED\n         CR    TEMP,R0             CHECK IT\n         BNH   SIT03               BRANCH IF LENGTH OK\n         LR    TEMP,R0             MAX-1 WILL DO\nSIT03    DS    0H\n         MVC   APIMNAME,BLANKS     BLANK REMOTE NAME\n         EX    TEMP,SINAMVC        MOVE IN NAME\n         OC    APIMNAME,BLANKS     CONVERT NAME TO UPPER CASE\n         B     SIT06               AND CONTINUE\nSINAMVC  OC    APIMNAME(*-*),0(COUNT)  MOVE UPPER SIGNAL IDENTIFIER\n         SPACE\nSIT04    DS    0H\n         LH    COUNT,TOPMRG        DEFAULT FIRST ARG\n         LA    COUNT,1(,COUNT)     BUMP TO TOP MARGIN PLUS ONE\nSIT05    DS    0H\n         XC    APIMNAME,APIMNAME   ZERO NAME FIELD\n         ST    COUNT,APIMNAME+4    ADD LINE NUMBER\n         SPACE\nSIT06    DS    0H\n         L     X1,RMQANCH          START OF REMOTE QUEUE\n         USING RMQD,X1             TELL THE ASSEMBLER\nSIT07    DS    0H\n         LTR   X1,X1               AT THE END .Q\n         BZ    SIT11               BRANCH OUT IF YES\n        $IFON  RMQFLAG,RMQDEL,SIT08     BRANCH IF REMOTE DELETED\n         CLC   RMQNAME,APIMNAME    EQUAL IDENTIFIER .Q\n         BH    SIT11               NOT FOUND IF HIGH\n         BE    SIT12               FOUND IF EQUAL\nSIT08    DS    0H\n         L     X1,RMQCHN           CHAIN TO NEXT REMOTE HEADER\n         B     SIT07               AROUND AGAIN\n         DROP  X1\n         SPACE\nSIT09    DS    0H\n        $CC    NEG                 TOO SMALL\n         B     SIT13               GO TO RETURN\nSIT10    DS    0H\n        $CC    POS                 TOO BIG\n         B     SIT13               GO TO RETURN\nSIT11    DS    0H\n        $CC    DNO                 NOT FOUND\n         B     SIT13               GO TO RETURN\nSIT12    DS    0H\n        $CC    OMIT                SUCCESS\nSIT13    DS    0H\n        $EXIT  RC=0                RESTORE CALLER'S REGS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SK": {"ttr": 11788, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .SK (SKIP) --- CONTROL                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nSK      $ENTER ,\n        $CALL  PRINTNB             CLEAR OUT PRINT BUFFER\n        $ON    SKSPFLG,SKSPSK      THIS IS A SKIP\n        $CALL  SP                  THE REST LOOKS LIKE '.SP'\n        $EXIT  RC=(R15)            AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SP": {"ttr": 11790, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x91\\x00\\x91\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 145, "newlines": 145, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .SP (SPACE) --- CONTROL                                *\n*                                                                     *\n***********************************************************************\n         SPACE\nSP      $ENTER ,\n        $CALL  PRINTNB             CLEAR OUT PRINT BUFFER\n        $OFF   SKSPFLG,(SKSPABS,SKSPCND)     CLEAR ARG TYPE\n        $IFON  SWITCHS,FLDSP,SP00  BRANCH IF LEADING SPACES ON\n        $IFON  SWITCHS,FFIRST,SP00 BRANCH IF VERY FIRST PAGE\n        $ON    SKSPFLG,SKSPSK      OTHERWISE, TREAT LIKE A SKIP\nSP00     DS    0H\n         LA    R0,1                ONE LINE BY DEFAULT\n         LNR   R0,R0               INDICATE THIS IS A DEFAULT\n         SPACE\nSP01     DS    0H\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BOMIT,SP04          BRANCH IF THAT'S ALL\n         CLI   YNRESULT,YNABS      WAS IT 'ABSOLUTE' .Q\n         BNE   SP02                BRANCH IF NOT\n        $ON    SKSPFLG,SKSPABS     SET ABSOLUTE SWITCH\n         B     SP01                CONTINUE\nSP02     DS    0H\n         CLI   YNRESULT,YNCND      WAS IT 'CONDITIONAL' .Q\n         BNE   SP03                BRANCH IF NOT\n        $ON    SKSPFLG,SKSPCND     SET CONDITIONAL SWITCH\n         B     SP01                CONTINUE\nSP03     DS    0H\n         LTR   R0,R0               GOT A VALID NUMERIC ALREADY .Q\n         BNM   SPE01               YES, ERROR\n         ST    COUNT,ARGSTART      RESCAN FOR NUMERIC\n        $CALL  GETNUM              GET NUMERIC OPERAND\n         BC    BDNO+BNEG,SPE01     ERROR IF NEGATIVE OR INVALID\n         LR    R0,COUNT            REMEMBER NUMERIC\n         B     SP01                CONTINUE\n         SPACE\nSP04     DS    0H\n         LPR   COUNT,R0            NUMERIC RESULT OF SCAN\n         BNZ   SP05                BRANCH IF NOT ZERO\n        $ON    SWITCHS,FNOCT       SET DON'T COUNT SWITCH\n         XC    SKSP,SKSP           CLEAR COND SKIP/SPACE DATA\n         LA    R15,WRETDC          SET DON'T COUNT RETURN CODE\n         B     SPDNE1              AND GO TO RETURN\n         SPACE\nSP05     DS    0H\n        $IFON  SKSPFLG,SKSPABS,SP06     BRANCH IF ABSOLUTE\n         LR    R0,COUNT            SPACE COUNT\n         MH    COUNT,DSCNT         MULT BY SPACING FACTOR\n         AR    COUNT,R0            PLUS ORIGINAL SPACING\nSP06     DS    0H\n        $IFOFF SKSPFLG,SKSPCND,SP07     BRANCH IF NOT CONDITIONAL\n         STH   COUNT,SKSPCCNT      SAVE CONDITIONAL COUNT\n         MVC   SKSPFLG2,SKSPFLG    AND FLAGS\n         MVI   SKSPFLG,X'00'       CLEAR CURRENT FLAGS\n         B     SPDNE               GO TO RETURN\n         SPACE\nSP07     DS    0H\n         MVI   SKSPFLG2,X'00'      CLEAR CONDITIONAL FLAGS\n         XC    SKSPCCNT,SKSPCCNT   CLEAR CONDITIONAL COUNT\n         CLI   ICORFLG,ICORNONE    NOT FORMATTING IN CORE .Q\n         BNE   SPFN                BRANCH IF NOT\n        $CALL  SPEX                SKIP/SPACE EXECUTION\n         B     SPDNE               GO TO RETURN\n         SPACE\nSPFN     DS    0H\n         MVI   PRNTRCC,SINGLSP     SINGLE SPACE CARRIAGE CONT\n         LA    R0,BLNKLINE         POINT TO BLANK LINE RDW\nSPFN01   DS    0H\n        $CALL  FNSAVE              SAVE BLANK LINE IN FOOTNOTE\n         BCT   COUNT,SPFN01        LOOP TILL DONE\n         MVI   SKSPFLG,X'00'       CLEAR CURRENT FLAGS\n         B     SPDNE               GET NEXT INPUT LINE\n         SPACE\nSPE01    DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         SPACE\nSPDNE    DS    0H\n         LA    R15,0               SET RETURN CODE\nSPDNE1   DS    0H\n        $EXIT  RC=(R15)            RETURN TO CALLER\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              SPACE EXECUTION ROUTINE                                *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (COUNT) IS NUMBER OF LINES TO SPACE\n         SPACE\nSPEX    $ENTER ,\nSPEX01   DS    0H\n         LH    TEMP,PLCT           LINES LEFT ON THIS PAGE\n        $IFOFF SWITCHS,FEMPTY,SPEX02    BRANCH IF PAGE NOT EMPTY\n         SH    TEMP,TOPMRG         LESS TOP MARGIN\nSPEX02   DS    0H\n         SR    TEMP,COUNT          LESS THIS SPACE OPERAND\n         LH    R1,BMMRG            BOTTOM MARGIN\n         AH    R1,FNSEP            PLUS FOOTNOTE MARGIN\n         CR    TEMP,R1             TOO CLOSE TO BOTTOM OF PAGE .Q\n         BNL   SPEX04              NO, ISSUE SPACES ONLY\n         SH    COUNT,PLCT          YES, PAGE EJECT NEEDED, ADJUST COUNT\n        $IFOFF SWITCHS,FEMPTY,SPEX03    BRANCH IF PAGE NOT EMPTY\n         AH    COUNT,TOPMRG        PLUS TOP MARGIN\nSPEX03   DS    0H\n         AH    COUNT,BMMRG         PLUS BOTTOM MARGIN\n         AH    COUNT,FNSEP         AND FOOTNOTE MARGIN\n        $CALL  PAGE                GENERATE PAGE EJECT\n        $IFON  SKSPFLG,SKSPSK,SPEX09    BRANCH IF SKIP\n        $IFOFF SWITCHS,FLDSP,SPEX09     BRANCH IF NO LEADING SPACES\n         LTR   COUNT,COUNT         TEST FOR NO MORE SPACES AT BOTTOM\n         BZ    SPEX09              NO. MORE\n         B     SPEX01              GET REMAINDING SPACES\nSPEX04   DS    0H\n         CH    TEMP,RMTRIG         SHOULD REMOTE BE TRIGGERED BEFORE\n         BNL   SPEX06              SPACES EXHAUSTED .Q\n         SPACE\n         LH    TEMP,PLCT           LINES LEFT ON THIS PAGE\n        $IFOFF SWITCHS,FEMPTY,SPEX05    BRANCH IF PAGE NOT EMPTY\n         SH    TEMP,TOPMRG         LESS TOP MARGIN\n         CH    TEMP,RMTRIG         AT VERY TOP OF PAGE .Q\n         BL    SPEX06              YES, LET PAGETOP DO IT\nSPEX05   DS    0H\n         SH    TEMP,RMTRIG         SPACES TO TRIGGER REMOTE\n         SR    COUNT,TEMP          NUMBER OF SPACES LEFT OVER\n         LR    X1,COUNT            SAVE REMAINDER\n         LR    COUNT,TEMP          ISSUE FIRST PART OF SPACES\n        $CALL  SPACER              ..\n         LH    R1,RMTRIG           REMOTE TO IMBED\n        $CALL  RMIMBED             IMBED THE REMOTE SEQUENCE\n         LTR   COUNT,X1            ANY SPACES LEFT OVER .Q\n         BZ    SPEX09              IF NOT, QUIT\n         B     SPEX01              FINISH UP THE SPACES\n         SPACE\nSPEX06   DS    0H\n        $IFOFF SWITCHS,FEMPTY,SPEX08    BRANCH IF PAGE NOT EMPTY\n        $IFON  SWITCHS,FFIRST,SPEX07    BRANCH IF VERY FIRST PAGE\n        $IFON  SKSPFLG,SKSPSK,SPEX09    BRANCH IF SKIP\nSPEX07   DS    0H\n        $CALL  PAGETOP             GENERATE PAGE HEADINGS\nSPEX08   DS    0H\n        $CALL  SPACER              GENERATE SPACES\nSPEX09   DS    0H\n         MVI   SKSPFLG,X'00'       CLEAR CURRENT FLAGS\n        $EXIT  RC=0                RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SPACEIM": {"ttr": 11794, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00?\\x00?\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTION 'SPACEIM' --- SKIP ONLINE IMMEDIATE  *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY --  (COUNT) IS NUMBER OF LINES TO SKIP\n         SPACE\nSPACEIM $ENTER ,\n         LTR   COUNT,COUNT         TEST FOR VALID ARGUMENT\n         BM    ABSPIM              BRANCH IF NOT VALID\n         BZ    SPIM07              BRANCH IF NOTHING TO DO\n        $IFOFF TTYPE,TONLINE,SPIM07     FORGET IMMEDIATE IF NOT ONLINE\n         CLC   PASSNO,DEFPASOF+TAB3DEF  IS THIS LAST PASS .Q\n         BNZ   SPIM07              NO, DO NOT SPACE THEN\n         SPACE\nSPIM01   DS    0H\n         LA    TEMP,LINEFC         MAXIMUM LINEFEED COUNT\n         CR    COUNT,TEMP          MORE THAN THAT TO DO .Q\n         BH    SPIM02              BRANCH IF YES\n         LR    TEMP,COUNT          SET FEWER LINES\nSPIM02   DS    0H\n         SR    COUNT,TEMP          LESS LINES WE DO NOW\n        $IFOFF TTYPE,TFILE,SPIM03  BRANCH IF OUTPUT NOT TO FILE\n         L     R1,BUFF3AD          POINT TO WORK AREA\n         XC    0(4,R1),0(R1)       CLEAR A RDW\n         MVC   4(L'LINEF*LINEFC,R1),LINEF    ENTER LINE FEED STRING\n         LA    TEMP,3(TEMP,TEMP)   TOTAL LENGTH LESS ONE LINEFEED\n         STH   TEMP,0(,R1)         AND SET THE LENGTH\n         LR    R0,R1               POINT TO RESULT\n        $CALL  PUTPRT              OUTPUT THE RESULT\n         B     SPIM06              GO TEST FOR DONE\n         SPACE\nSPIM03   DS    0H\n        $IFOFF SWITCHS,TSOWS,SPIM05     BRANCH IF NOT TSO\n        $IFON  TTYPE,TSCREEN,SPIM04     BRANCH IF TSO CRT\n         AR    TEMP,TEMP           DOUBLE NUMBER FOR LENGTH\n         LA    R1,LINEF            POINT TO LINEFEED STRING\n         TPUT  (1),(TEMP),ASIS     IDLE-LINEFEED SOME TSO SPACES\n         B     SPIM06              GO TEST FOR DONE\n         SPACE\nSPIM04   DS    0H\n         LA    R1,BLANKS           POINT TO A BLANK\n         TPUT  (1),1,EDIT          ONE TSO CRT LINE AT A TIME\n         BCT   TEMP,SPIM04         DO THEM ALL\n         B     SPIM06              GO TEST FOR DONE\n         SPACE\nSPIM05   DS    0H\n        $IFOFF SWITCHS,CMSWS,SPIM06     BRANCH IF NOT CMS\n         AR    TEMP,TEMP           DOUBLE NUMBER FOR LENGTH\n         LA    R1,LINEF            POINT TO LINEFEED STRING\n         WRTERM (R1),(TEMP),EDIT=NO     LINEFEED SOME CMS SPACES\n         SPACE\nSPIM06   DS    0H\n         LTR   COUNT,COUNT         ANY LINES LEFT .Q\n         BP    SPIM01              BRANCH BACK IF YES\n         SPACE\nSPIM07   DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              AND RETURN TO CALLER\n         SPACE\nABSPIM   DS    0H\n        $LOGERR 1010               NEGATIVE IMMEDIATE SPACING ERROR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SPACER": {"ttr": 12033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00S\\x00S\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 83, "newlines": 83, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL FUNCTION 'SPACER' --- SKIP LINES (LESS PAGE)  *\n*                                                                     *\n***********************************************************************\n         SPACE\nSPACER  $ENTER ,\n         LTR   COUNT,COUNT         TEST FOR VALID > 0\n         BM    ABSPACE             NOT VALID\n         BZ    SPACERET            IF 0, IGNORE\n         L     X3,DEFLNUM+TAB3DEF  SAVE LINENUM VALUE\n         MVC   DEFLNUM+TAB3DEF,F0  DISABLE LINENUM FOR SPACES\nSPACOO01 DS    0H\n         MVI   SKSPFLG2,X'00'      CLEAR CONDITIONAL FLAGS\n         XC    SKSPCCNT,SKSPCCNT   CLEAR CONDITIONAL COUNT\n         LA    X1,2                ASSUME NO OVERLAYS\n         CLI   ICOLFLG,ICOLMC      IN MULTI-COLUMN MODE .Q\n         BE    SPACOO02            BRANCH IF YES\n        $IFON  SWITCHS,OOSWS,SPACOO03   BRANCH IF NO OVERLAY\n         L     R1,OOANCH           OUTPUT OVERLAY BUFFER\n         LTR   R1,R1               ANYTHING TO OVERLAY .Q\n         BNZ   SPACOO02            BRANCH IF YES\n         L     R1,BXPTR            BOX BUILDING POINTER\n         LTR   R1,R1               ANYTHING PRESENT .Q\n         BZ    SPACOO03            BRANCH IF NOT\nSPACOO02 DS    0H\n         SR    X1,X1               ONE LINE AT A TIME ONLY\n         B     SPACPR              PRINT AS IF OFFLINE\nSPACOO03 DS    0H\n        $IFNONE SWITCHS,(CMSWS,TSOWS),SPACPR CHECK FOR TERMINALS\n        $IFON  TTYPE,TONLINE,SPACTE     GO DIFFERENTLY IF ONLINE\n         SPACE\nSPACPR   DS    0H\n         LA    TEMP,1(,X1)         GET MAXIMUM PRINTER SPACE\n         CR    COUNT,TEMP          MORE THAN THAT TO DO\n         BH    SPACPR01            BRANCH IF YES\n         LR    TEMP,COUNT          SET FEWER\nSPACPR01 DS    0H\n         LH    R1,PLZ              LINES ON A PAGE\n         SH    R1,PLCT             LESS LINES LEFT ON THIS PAGE\n         C     R1,DEFFFTO+TAB3DEF  PAST TOP OF FORM LINE .Q\n         BH    SPACPR02            BRANCH IF YES\n         AR    R1,COUNT            WHERE WE WILL BE\n         C     R1,DEFFFTO+TAB3DEF  PAST TOP OF FORM NOW .Q\n         BL    SPACPR02            BRANCH IF NOT\n         LA    TEMP,1              ONE AT A TIME FOR CHANNEL SKIP\nSPACPR02 DS    0H\n         LH    R1,PLCT             GET LINES LEFT ON PAGE\n         SR    R1,TEMP             LESS NUMBER WE DO NOW\n         STH   R1,PLCT             UPDATE LINES LEFT ON PAGE\n         SR    COUNT,TEMP          LESS NUMBER WE DO NOW\n         IC    TEMP,SPACTABL(TEMP) GET ASA CARRIAGE CONTROL\n         STC   TEMP,PRNTRCC        INSERT ASA CARRIAGE CONTROL\n         LA    R0,BLNKLINE         POINT TO BLANK LINE\n        $CALL  IOPRINT             INVOKE OUTPUT ROUTINE\n         LTR   X1,X1               TEST OUTPUT OVERLAY SITUATION\n         BNZ   SPACPR03            BRANCH IF NO OVERLAY\n         MVC   BLNKDATA,BLANKS     BLANK ALL OF DUMMY LINE\n         LA    R0,BLNKRDWL         LENGTH OF THIS DUMMY BLANK LINE\n         STH   R0,BLNKLINE         RESET LENGTH IN RDW\nSPACPR03 DS    0H\n         LTR   COUNT,COUNT         ANY LINES LEFT .Q\n         BNP   SPACEFIN            BRANCH IF NOT\n         LTR   X1,X1               TEST OUTPUT OVERLAY SITUATION\n         BNZ   SPACPR              BRANCH IF NO OVERLAY TO OFFLINE\n         B     SPACOO01            BRANCH TO TEST AGAIN\n         SPACE\nSPACTE   DS    0H\n         LH    R1,PLCT             GET LINES LEFT ON PAGE\n         SR    R1,COUNT            LESS NUMBER OF LINES WE NOW SPACE\n         STH   R1,PLCT             SET REMAINDER ON CURRENT PAGE\n        $IFON  SWITCHS,NPSWS,SPACEFIN   NO SPACE IF NO PRINT MODE\n        $CALL  SPACEIM             DO IMMEDIATE ONLINE SPACING\n         SPACE\nSPACEFIN DS    0H\n         ST    X3,DEFLNUM+TAB3DEF  RESTORE LINENUM VALUE\nSPACERET DS    0H\n        $OFF   SWITCHS,OOSWS       REENABLE OUTPUT OVERLAY\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              RETURN TO CALLER\n         SPACE\nABSPACE  DS    0H\n        $LOGERR 1001               NEGATIVE SPACING ERROR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SR": {"ttr": 12036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\xcd\\x00\\xcd\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 205, "newlines": 205, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .SR (SET REFERENCE) --- SET VALUE OF REFERENCE NAME    *\n*                                                                     *\n***********************************************************************\n         SPACE\nSR      $ENTER ,\n        $CALL  GETSYM              PICKUP TARGET NAME\n         BC    BOMIT,SRE01         ERROR IF NO OPERAND\n         BC    15-BDNO,SR010       BRANCH IF VALID\n        $IFON  SRNMFLG,SRNMTSYM,SRE04   BRANCH IF BAD SYMBOL\n        $IFON  SRNMFLG,SRNMTSUB,SRE06   BRANCH IF BAD SUBSCRIPT\n        $IFANY SRNMFLG,(SRNMTFR,SRNMTTO),SRE07  BRANCH IF BAD SUBSTRING\n         CLC   SRNMFR,SRNMFR+L'SRNMFR   'FROM' SUBSTRING SPECIFIED .Q\n         BNE   SRE07               ERROR IF YES\n         CLC   SRNMTO,SRNMTO+L'SRNMTO   'TO' SUBSTRING SPECIFIED .Q\n         BNE   SRE07               ERROR IF YES\nSR010    DS    0H\n         L     R1,ARGSTART         POINT TO TERMINATING DELIMITER\n         CLI   0(R1),C' '          BLANK AFTER .Q\n         BE    SR020               CONTINUE IF YES\n         CLI   0(R1),C'='          EQUAL AFTER .Q\n         BE    SR020               BRANCH IF YES\n         B     SRE02               ELSE BAD SYMBOL DELIMITER\n         SPACE\nSR020    DS    0H\n        $CALL  SYMSR               LOOKUP THE SYMBOL\n         LR    X1,COUNT            RETAIN RETURNED POINTER\n         BC    BPOS,SR070          IF SINGLE ENTRY, SKIP\n         BC    BNEG,SR030          BRANCH IF (0) FOUND\n         LTR   X1,X1               ROOM FOR (0) ENTRY .Q\n         BZ    SRE03               IF NOT, COMPLAIN\n         USING RND,X1              ADDRESS OF (0) ENTRY\n         XC    RND(RNLN),RND       ZERO DICTIONARY ENTRY\n         MVC   RNSYM,SRNM          COPY IN NAME\n         SPACE\nSR030    DS    0H\n         TM    SRNMFLG,SRNMALL     IMPLIED SUBSCRIPT .Q\n         BNO   SR040               BRANCH IF NOT\n         TM    RNFLAG,RNCHAR+RNPTR IS ENTRY NON NUMERIC .Q\n         BNZ   SRE06               ERROR IF NOT NUMERIC\n         L     R0,RNDVAL           CURRENT VALUE SUB (0)\n         A     R0,F1               BUMP BY ONE\n         TM    SRNMFLG,SRNMALLN    NEGATIVE IMPLICATION\n         BNO   SR032               BRANCH AROUND IF NOT\n         S     R0,F2               DECREMENT BY ONE NET\nSR032    DS    0H\n         ST    R0,SAVEF0           ALIGN RESULT\n         LPR   R0,R0               POSITIVE VALUE\n         C     R0,F32767           SMALL ENOUGH .Q\n         BH    SRE06               INVALID SUBSCRIPT IF NOT\n         MVC   RNDVAL,SAVEF0       ENTER NEW VALUE\n         MVC   SRNMSUB,RNDVAL+2    ENTER NEW SUBSCRIPT\n         SPACE\nSR040    DS    0H\n         CLC   SRNMSUB,F0          ZERO SUBSCRIPT .Q\n         BE    SR070               YES, CONTINUE\n         CLC   RNSLINK,F0          ZEROTH ENTRY THE LAST .Q\n         BE    SR042               BRANCH IF YES\n         LA    X2,RND              FORMER SUBSCRIPT POINTER\n         L     X1,RNSLINK          POINT TO FIRST SUBSCRIPT ENTRY\nSR042    DS    0H\n         LH    R0,SRNMSUB          GET TARGET SUBSCRIPT\nSR050    DS    0H\n         CH    R0,RNSUBS           COMPARE WITH TARGET SUBSCRIPT\n         BL    SR060               IF LESS, ENTER NOW\n         BE    SR070               OUT IF EQUAL\n         LA    X2,RND              SAVE OLD PTR\n         CLC   RNSLINK,F0          AT THE END .Q\n         BE    SR060               BRANCH IF YES\n         L     X1,RNSLINK          LOAD LINK PTR\n         B     SR050               AND SEARCH AGAIN\n         SPACE\nSR060    DS    0H\n         LA    R1,RNLN             LENGTH FOR ONE NEW ENTRY\n        $CALL  GETCELL             GET SOME SPACE\n         BC    BNEG,SRE03          BRANCH IF NONE LEFT\n         LR    X1,TEMP             THIS IS NEW POINTER\n         XC    RND(RNLN),RND       CLEAR DICTIONARY ENTRY\n         MVC   RNSYM,SRNM          COPY IN NAME\n         MVC   RNSUBS,SRNMSUB      AND SUBSCRIPT\n         MVC   RNSLINK,RNSLINK-RND(X2)  FORWARD POINTER\n         ST    X1,RNSLINK-RND(,X2) SET NEW POINTER\n         SPACE\nSR070    DS    0H\n        $ON    SWITCHS,FNOCASE     DON'T ALTER ANYTHING\n        $CALL  GETARG              SKIP OVER ANY BLANKS\n         BC    BOMIT,SRE01         ERROR IF OMITTED\n         ST    COUNT,ARGSTART      RESCAN FROM START\n         CLI   0(COUNT),C'='       AN EQUAL DELIMITER .Q\n         BNE   SR080               BRANCH IF NOT\n         LA    COUNT,1(,COUNT)     BUMP POINTER\n         ST    COUNT,ARGSTART      POINT TO NEXT OP\nSR080    DS    0H\n        $ON    SWITCHS,SRSWS       THIS IS .SR CALLING\n        $CALL  GETNUM              EVALUATE EXPRESSION\n         BC    BOMIT,SR088         NO OPERAND IS A NULL CHAR\n         BC    BDNO,SR082          INVALID SOMETHING IN EXPRESSION\n         BAL   RETURN,SRFRE        RELEASE FORMER LONG CHAR, IF ANY\n         ST    COUNT,RNDVAL        STORE FINAL NUMERIC VALUE\n         MVI   RNFLAG,X'00'        ZERO FLAG BYTE\n         MVI   RNCLEN,X'00'        NUMERIC STRING LENGTH IS ZERO\n         B     SR130               BRANCH TO RETURN\n         SPACE\nSR082    DS    0H\n         ST    COUNT,ARGSTART      RESCAN STRING FROM THE START\n        $ON    SWITCHS,FNOCASE     INDICATE NO CASE CONVERSION\n        $CALL  GETQST              GET FIRST OPERAND\n         BC    BOMIT,SR088         BRANCH IF NO OPERAND\n         LA    R1,1(,TEMP)         ACTUAL STRING LENGTH\n         CLC   QSTRING,F2          MATCHED DELIMITERS .Q\n         BNE   SR090               BRANCH IF NOT\n         S     R1,QSTRING          LENGTH LESS DELIMITERS\n         LA    COUNT,1(,COUNT)     START OF DELIMITED CONTENTS\n         B     SR090               AND CONTINUE\nSR088    DS    0H\n         SR    R1,R1               LENGTH OF NO OPERAND IS ZERO\n         SPACE\nSR090    DS    0H\n         C     R1,DEFRNLEN+TAB3DEF COMPARE WITH MAX ALLOWED\n         BNH   SR100               BRANCH IF OK\n         L     R1,DEFRNLEN+TAB3DEF GET MAX ALLOWED INSTEAD\n         MVI   EFLAG008,ERRSET     INDICATE LENGTH ERROR\nSR100    DS    0H\n         LR    X2,COUNT            SAVE ARGUMENT POINTER\n         EX    R1,SRCLI            LENGTHS THE SAME .Q\n         BE    SR106               BRANCH IF YES\n         BAL   RETURN,SRFRE        RELEASE FORMER LONG CHAR, IF ANY\n         SPACE\n         LA    R0,L'RNCVAL         MAX LENGTH FOR SHORT CHAR\n         CR    R1,R0               THIS A LONG CHAR .Q\n         BNH   SR106               BRANCH IF NOT\n        $CALL  GETCELL             GET A CHAR WORK AREA\n         LR    COUNT,TEMP          RETURNED ADDRESS\n         BC    BPOS,SR104          BRANCH IF A SUCCESS\n         LA    R1,L'RNCVAL         SET MAXIMUM LENGTH POSSIBLE\n         MVI   EFLAG008,ERRSET     INDICATE LENGTH TRUNCATED\n         B     SR106               ENTER REST OF DATA\n         SPACE\nSR104    DS    0H\n         ST    COUNT,RNCPTR        SET FORWARD DATA POINTER\n         L     COUNT,RNTBSCNT      GET CURRENT SUBSCRIPTED VAR COUNT\n         LA    COUNT,1(,COUNT)     PLUS ONE\n         ST    COUNT,RNTBSCNT      UPDATE SUBSCRIPTED VAR COUNT\n         SPACE\nSR106    DS    0H\n         STC   R1,RNCLEN           SET STRING LENGTH\n         LA    COUNT,RNCVAL        SHORT STRING TARGET\n         CLI   RNCLEN,L'RNCVAL     IS STRING SHORT .Q\n         BNH   SR108               BRANCH IF YES\n         L     COUNT,RNCPTR        POINTER TO LONG TARGET\n         SPACE\nSR108    DS    0H\n         OI    RNFLAG,RNCHAR       INDICATE CHARACTER STRING\n         LTR   R1,R1               TEST FOR NULL STRING\n         BNP   SR110               IF SO, DONE\n         BCTR  R1,0                NOT NULL, SS-COUNT OF STRING\n         EX    R1,SRMVC            COPY STRING TO TARGET\nSR110    DS    0H\n         CLC   QSTRING(4),F1       MISMATCHED DELIMITER SITUATION\n         BE    SRE05               BRANCH TO ERROR IF YES\n         B     SR130               DONE\n         SPACE\nSRMVC    MVC   0(*-*,COUNT),0(X2)  COPIES CHARACTER ARGUMENT\nSRCLI    CLI   RNCLEN,*-*          EXECUTED COMPARE STRING LENGTHS\n         SPACE\nSRFRE    DS    0H\n         TM    RNFLAG,RNCHAR       FORMER VALUE CHARACTER .Q\n         BZ    SRFRE01             BRANCH IF NOT\n         CLI   RNCLEN,L'RNCVAL     LONG CHAR VALUE .Q\n         BNH   SRFRE01             BRANCH IF NOT\n        $SAVE  ,                   SAVE CALLER'S REGS\n         L     R0,RNCPTR           POINTER TO LONG STRING\n         SR    R1,R1               ZERO WORK REG\n         IC    R1,RNCLEN           LENGTH OF LONG STRING\n        $CALL  FREECELL            RELEASE AREA\n        $RESTOR ,                  RESTORE CALLER'S REGS\nSRFRE01  DS    0H\n         BR    RETURN              RETURN TO CALLER\n         DROP  X1\n         SPACE\nSRE01    DS    0H\n         MVI   EFLAG003,ERRSET     OMITTED OPERAND\n         B     SR130               GO TO RETURN\nSRE02    DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     SR130               GO TO RETURN\nSRE03    DS    0H\n         MVI   EFLAG007,ERRSET     TOO MANY REF NAMES\n         B     SR130               GO TO RETURN\nSRE04    DS    0H\n         MVI   EFLAG008,ERRSET     STRING TOO LONG\n         B     SR130               GO TO RETURN\nSRE05    DS    0H\n         MVI   EFLAG015,ERRWARN    MISMATCHED DELIM\n         B     SR130               GO TO RETURN\nSRE06    DS    0H\n         MVI   EFLAG038,ERRSET     INVALID SUBSCRIPT\n         B     SR130               GO TO RETURN\nSRE07    DS    0H\n         MVI   EFLAG039,ERRSET     INVALID SUBSTRING\n         B     SR130               GO TO RETURN\n         SPACE\nSR130    DS    0H\n        $EXIT  RC=0                DONE WITH .SR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SRCHRN": {"ttr": 12040, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\xab\\x00\\xab\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 171, "newlines": 171, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        INTERNAL FUNCTION 'SRCHRN' -- LOCATE REFERENCE NAME.         *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER:   $CALL  SRCHRN                                    *\n*                                                                     *\n*        ON EXIT (SRSWS = 'ON'):                                      *\n*                                                                     *\n*        CC=BOMIT   SYMBOL NOT FOUND (COUNT=FREE SLOT|0)              *\n*        CC=BPOS    SYMBOL FOUND     (COUNT=ADDR)                     *\n*        CC=BNEG    SYMBOL(0) FOUND  (COUNT=ADDR)                     *\n*        CC=BDNO    SYMBOL(0) NOT FOUND (COUNT=FREE SLOT|0)           *\n*                                                                     *\n*        ON EXIT (SRSWS = 'OFF'):                                     *\n*                                                                     *\n*        CC=BPOS    SYMBOL FOUND     (COUNT=ADDR)                     *\n*        CC=BNEG    SYMBOL(0) FOUND  (COUNT=ADDR)                     *\n         SPACE\nSRCHRN  $ENTER ,\n         LA    R1,RNTBANCH         TRAILING POINTER\n         L     COUNT,RNTBANCH      START OF REFERENCE CHAIN\n         LTR   COUNT,COUNT         DOES REF CHAIN EXIST .Q\n         BNZ   SRN01               BRANCH IF YES\n        $IFOFF SWITCHS,SRSWS,SRN15 BRANCH IF NOT '.SR' REQUEST\n         SPACE\nSRN01    DS    0H\n         L     R14,RNTBSRCH        COUNT OF REFERENCE NAME SEARCHES\n         LA    R14,1(,R14)         PLUS ONE\n         ST    R14,RNTBSRCH        UPDATE WITH NEW TOTAL\n         LA    R14,SRNLASTC        NUMBER OF LAST REF POINTERS\n         SR    R15,R15             START OF TABLE\nSRN02    DS    0H\n         USING RND,COUNT           REF TABLE ADDRESSABILITY\n         L     COUNT,SRNLAST(R15)  TRIAL ENTRY\n         LTR   COUNT,COUNT         ANY ENTRY .Q\n         BZ    SRN02A              BRANCH IF NOT\n         CLC   RNSYM,SRNM          THIS ENTRY .Q\n         BE    SRN03               IF SO, QUIT\n         LA    R15,4(,R15)         NEXT ENTRY ADDRESS\n         BCT   R14,SRN02           TRY THEM ALL\n         SR    COUNT,COUNT         WE FAILED\n         S     R15,F4              BACKUP TO LAST TRIAL ENTRY\nSRN02A   DS    0H\n         L     R14,RNTBFAIL        GET LOOKASIDE FAILURE COUNT\n         LA    R14,1(,R14)         PLUS ONE\n         ST    R14,RNTBFAIL        UPDATE LOOKASIDE FAILURE COUNT\nSRN03    DS    0H\n         S     R15,F4              REARRANGE POINTERS\n         BM    SRN04               BRANCH OUT WHEN DONE\n         L     R14,SRNLAST(R15)    GET ENTRY TO PUSH DOWN\n         ST    R14,SRNLAST+4(R15)  PUSH IT\n         B     SRN03               GO TILL EXAUSTED\nSRN04    DS    0H\n         LTR   COUNT,COUNT         WERE WE SUCCESSFUL .Q\n         BNZ   SRN12               BRANCH IF YES\n         LA    COUNT,RNTBANCH      START PTR TO REFERENCE CHAIN\n         L     R14,SRNM            FOR FASTER FOUR CHAR COMPARES\n         B     SRN06               ENTER AT CHECK FOR END\n         SPACE\nSRN05    DS    0H\n         C     R14,RNSYM           COULD IT BE THIS ENTRY .Q\n         BE    SRN07               BRANCH IF YES\nSRN06    DS    0H\n         LA    R1,RNSCHN           REMEMBER THE TRAILER\n         L     COUNT,RNSCHN        NEXT POINTER TO TRY\n         LTR   COUNT,COUNT         AT THE CHAIN END .Q\n         BNZ   SRN05               BRANCH IF NOT\n         B     SRN08               WE HAVE FAILED\nSRN07    DS    0H\n         CLC   RNSYM+4(L'RNSYM-4),SRNM+4     CHECK TRAILER INFO\n         BE    SRN12               BRANCH IF ALL EQUAL\n         B     SRN06               NO, CHECK FOR END\nSRN08    DS    0H\n        $IFOFF SWITCHS,SRSWS,SRN15 BRANCH IF NOT .SR REQUEST\n        $OFF   SWITCHS,SRSWS       CLEAR SWITCH WHEN RETURNING\n         LR    R0,R1               REMBBER TRAILING POINTER\n         LA    R1,RNLN             LENGTH OF ONE NEW ENTRY\n        $CALL  GETCELL             GET NEW SPACE FOR REF\n         BC    BPOS,SRN09          BRANCH IF REQUEST SUCCEEDED\n         SR    COUNT,COUNT         ZERO RETURN POINTER\n         B     SRN10               AND GO TO RETURN\nSRN09    DS    0H\n         LR    R1,R0               RESTORE TRAILING PTR\n         L     R14,RNTBCNT         GET COUNT OF USER VARIABLES\n         LA    R14,1(,R14)         PLUS ONE\n         ST    R14,RNTBCNT         UPDATE COUNT OF USER VARIABLES\n         ST    TEMP,RNSCHN-RND(,R1)     FORWARD POINTER\n         LR    COUNT,TEMP          RETURN NEW POINTER\n         ST    COUNT,SRNLAST       ENTRY WILL BE CREATED HERE\nSRN10    DS    0H\n         CLC   SRNMSUB,F0          ANY SUBSCRIPT .Q\n         BE    SRN11               BRANCH IF NONE\n         EX    R0,CCBDNO           SET CC BDNO\n         B     SRN23               AND RETURN\nSRN11    DS    0H\n         EX    R0,CCBOMIT          SET CC BOMIT\n         B     SRN23               AND RETURN\n         SPACE\nSRN12    DS    0H\n         ST    COUNT,SRNLAST       SAVE SUCCESSFUL REF POINTER\n        $IFOFF SWITCHS,SRSWS,SRN18 BRANCH IF NOT .SR REQUEST\n        $OFF   SWITCHS,SRSWS       CLEAR SWITCH WHEN RETURNING\n         TM    SRNMFLG,SRNMALL     ONE OF THE ALL VARIATIONS .Q\n         BO    SRN13               BRANCH IF YES\n         CLC   SRNMSUB,F0          ANY SUBSCRIPT .Q\n         BE    SRN14               BRANCH IF NONE\nSRN13    DS    0H\n         EX    R0,CCBNEG           SET CC BNEG\n         B     SRN23               AND RETURN\nSRN14    DS    0H\n         EX    R0,CCBPOS           SET CC BPOS\n         B     SRN23               AND RETURN\n         SPACE\nSRN15    DS    0H\n         CLI   SRNM,C'$'           SYMBOL START WITH '$' .Q\n         BNE   SRN15B              BRANCH IF NOT\n         CLC   SRNM+L'SRNM-L'SRNSYS+1(L'SRNSYS-1),BLANKS  END BLANK .Q\n         BNE   SRN15B              BRANCH IF NOT\n         LA    COUNT,L'SRNM-L'SRNSYS    NUMBER OF CHARS TO MOVE\nSRN15A   DS    0H\n         IC    R0,SRNM(COUNT)      GET LAST CHAR\n         STC   R0,SRNM+L'SRNSYS-1(COUNT)  MOVE TO RIGHT\n         BCT   COUNT,SRN15A        DO ALL CHARACTERS\n        $MVC   SRNM,SRNSYS         ENTER PREFIX\nSRN15B   DS    0H\n         LM    R0,R1,SRNTBLN       PRIME SYSTEM SEARCH LOOP\n         L     COUNT,SRNTBBEG      START OF SYSTEM REFERENCE TABLE\n         SR    COUNT,R0            LESS ONE DUMMY START ENTRY\n         B     SRN17               BRANCH TO LOOP END\nSRN16    DS    0H\n         CLC   RNSYM,SRNM          THIS ENTRY .Q\n         BNE   SRN17               IF NOT, CONTINUE\n         TM    RNFLAG,RNPTR        POINTER DATA .Q\n         BZ    SRN18               BRANCH BACK IF NOT\n         L     X1,SRNTBBEG         START OF SYSTEM REFERENCE TABLE\n         BAL   R14,RNCVAL          BRANCH TO ROUTINE\n         B     SRN18               SET CONDITION CODE AND RETURN\nSRN17    DS    0H\n         BXLE  COUNT,R0,SRN16      NO, CHECK NEXT ENTRY\n         L     COUNT,SRNTBCUR      POINT TO LAST NULL ENTRY\nSRN18    DS    0H\n         TM    SRNMFLG,SRNMALL     IMPLIED SUBSCRIPT .Q\n         BO    SRN22               BRANCH IF YES\n         CLC   SRNMSUB,F0          ANY SUBSCRIPT .Q\n         BE    SRN21               BRANCH IF NONE\nSRN19    DS    0H\n         CLC   RNSUBS,SRNMSUB      COMPARE SUBSCRIPTS .Q\n         BH    SRN20               BRANCH IF GT\n         BE    SRN21               BRANCH IF FOUND\n         CLC   RNSLINK,F0          AT THE END .Q\n         BE    SRN20               BRANCH IF YES\n         L     COUNT,RNSLINK       FETCH NEXT SUB POINTER\n         B     SRN19               TRY AGAIN\n         SPACE\nSRN20    DS    0H\n         L     COUNT,SRNTBCUR      POINT TO LAST NULL ENTRY\nSRN21    DS    0H\n         EX    R0,CCBPOS           SET CC BPOS\n         B     SRN23               AND RETURN\n         SPACE\nSRN22    DS    0H\n         EX    R0,CCBNEG           SET CC BNEG\n         SPACE\nSRN23    DS    0H\n        $RESTOR KEEP=(COUNT)       RESTORE CALLER'S REGS\n         BR    RETURN              RETURN TO CALLER\n         SPACE\nSRNSYS   DC    C'SYS'              THIS PREFIX EQUIVALENT TO '$'\n         DROP  COUNT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SS": {"ttr": 12044, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\n\\x00\\n\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .SS (SINGLE SPACE) --- CONTROL                         *\n*                                                                     *\n***********************************************************************\n         SPACE\nSS      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n         XC    DSCNT,DSCNT         CLEAR LINE SPACING FACTOR\n        $EXIT  RC=0                GO TO NEXT RECORD\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SU": {"ttr": 12046, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00S\\x00S\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 83, "newlines": 83, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .SU (SUBSTITUTE SYMBOL) --- CONTROL                    *\n*                                                                     *\n***********************************************************************\n         SPACE\nSU      $ENTER ,\n         L     X3,ARGSTART         REMEMBER WHERE IT ALL STARTED\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BOMIT,SU02          BRANCH IF NULL, ASSUME ONE\n         BC    BPOS,SU03           AFFIRMATIVE IS FOREVER\n         BC    BNEG,SU04           NEGATIVE FINISHES IT\n         CLI   YNRESULT,YNUP       IS ARGUMENT 'UPPER' .Q\n         BE    SU06                BRANCH IF YES\n         CLI   YNRESULT,YNNOUP     IS ARGUMENT 'NOUPPER' .Q\n         BE    SU07                BRANCH IF YES\n         CLI   YNRESULT,YNTRON     IS ARGUMENT 'TRACEON' .Q\n         BE    SU08                BRANCH IF YES\n         CLI   YNRESULT,YNTROFF    IS ARGUMENT 'TRACEOFF' .Q\n         BE    SU09                BRANCH IF YES\n         SPACE\n         ST    COUNT,ARGSTART      RESET START OF SCAN\n        $CALL  GETNUM              IT IS PROBABLY NUMERIC\n         BC    BDNO,SU01           BRANCH IF INVALID\n         BC    BNEG,SU04           NEGATIVE IS GOOD AS ZERO\n         B     SU05                ENTER VALUE FOR SUBSEQUENT .UR\n         SPACE\nSU01     DS    0H\n         ST    X3,ARGSTART         ORIGINAL 'LINE' STARTED HERE\n        $CALL  USARG               MOVE LINE TO BEGINNING\n         LA    COUNT,1             ONE LINE SUBSTITUTE\n         STH   COUNT,URCNT         ENTER .UR VALUE\n         LA    R15,WRETSU          PROCESS THE RESULT\n         B     SU11                GO TO RETURN\n         SPACE\nSU02     DS    0H\n         LA    COUNT,1             ONE LINE BY DEFAULT\n         B     SU05                ENTER VALUE FOR .UR\nSU03     DS    0H\n         LH    COUNT,H32767        LARGE POSITIVE NUMBER\n         B     SU05                ENTER VALUE FOR .UR\nSU04     DS    0H\n         SR    COUNT,COUNT         ZERO VALUE\nSU05     DS    0H\n         LR    X1,COUNT            REMEMBER VALUE\n         BAL   RETURN,SU12         ANY MORE ARGUMENTS .Q\n         BC    BPOS,SU01           YES, THEN A 'LINE' ARGUMENT\n         STH   X1,URCNT            ENTER .UR VALUE\n         B     SU10                BRANCH TO RETURN\n         SPACE\nSU06     DS    0H\n         BAL   RETURN,SU12         ANY MORE ARGUMENTS .Q\n         BC    BPOS,SU01           YES, THEN A 'LINE' ARGUMENT\n        $OFF   SWITCHS,NUPSWS      CONVERT REF NAMES TO UPPER CASE\n         B     SU10                BRANCH TO RETURN\nSU07     DS    0H\n         BAL   RETURN,SU12         ANY MORE ARGUMENTS .Q\n         BC    BPOS,SU01           YES, THEN A 'LINE' ARGUMENT\n        $ON    SWITCHS,NUPSWS      DON'T CONVERT REF NAMES TO UPPER\n         B     SU10                BRANCH TO RETURN\n         SPACE\nSU08     DS    0H\n         BAL   RETURN,SU12         ANY MORE ARGUMENTS .Q\n         BC    BPOS,SU01           YES, THEN A 'LINE' ARGUMENT\n        $ON    SWITCHS,UTSWS       USE REFERENCE TRACE ON\n         B     SU10                BRANCH TO RETURN\nSU09     DS    0H\n         BAL   RETURN,SU12         ANY MORE ARGUMENTS .Q\n         BC    BPOS,SU01           YES, THEN 'LINE' ARGUMENT\n        $OFF   SWITCHS,UTSWS       USE REFERENCE TRACE OFF\n         B     SU10                BRANCH TO RETURN\n         SPACE\nSU10     DS    0H\n         SR    R15,R15             NO MORE DATA TO PROCESS\nSU11     DS    0H\n        $EXIT  RC=(R15)            AND GET NEXT LINE\n         SPACE\nSU12     DS    0H\n        $SAVE  ,                   SAVE CALLER'S REGISTERS\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION PLEASE\n        $CALL  GETARG              GET ONE MORE ARGUMENT (IF ANY)\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SY": {"ttr": 12289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00,\\x00,\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .SY (SYSTEM) --- CONTROL                               *\n*                                                                     *\n***********************************************************************\n         SPACE\nSY      $ENTER ,\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION PLEASE\n        $CALL  GETARG              GET ANY ARG PRESENT\n         BC    BOMIT,SYE003        ERROR IF OMITTED\n        $IFOFF SWITCHS,TSOWS,SYCMS      BRANCH IF NOT TSO\n         SPACE\nSYTSO01  DS    0H\n*        ENTER TSO EQUIVALENT (IF ANY) HERE\n         LA    R15,0               OK RETURN CODE\n         B     SY01                GO TO RETURN\n         SPACE\nSYCMS    DS    0H\n        $IFOFF SWITCHS,CMSWS,SY02  BRANCH IF NOT CMS\n         ST    COUNT,SYCMSATA      SET STRING ADDRES\n         L     R1,ARGSTOP          STRING ENDS HERE\n         SR    R1,COUNT            STRING LENGTH-1\n         LA    R1,1(,R1)           STRING LENGTH\n         STC   R1,SYCMSATA         SET STRING LENGTH\n         LA    R1,SYCMSAT          ATTENTION PLIST\n         SVC   202                 ENTER STRING\n         DC    AL4(*+4)            IGNORE ERRORS\n         LA    R1,SYCMSSB          SUBSET RETURN PLIST\n         SVC   202                 MUST DO THAT TOO\n         DC    AL4(*+4)            IGNORE ERRORS\n         B     SY01                GO TO RETURN\n         SPACE\nSY01     DS    0H\n         STH   R15,SYRET           SAVE SYSTEM RETURN CODE\nSY02     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nSYE003   DS    0H\n         MVI   EFLAG003,ERRSET     OMITTED OPERAND\n         B     SY02                GO TO RETURN\n         SPACE\nSYCMSAT  DC    0D'0',CL8'ATTN',CL4'LIFO'\nSYCMSATA DC    A(0),8X'FF'\nSYCMSSB  DC    0D'0',CL8'SUBSET',CL8'(RETURN)',8X'FF'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SYABEND": {"ttr": 12291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x12\\x00\\x12\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              'SYABEND' --- USER ABEND ROUTINE                       *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R1)  CONTAINS USER ABEND NUMBER\n         SPACE\nSYABEND $ENTER ,\n         LA    R0,X'80'            ENTER DUMP FLAG\n         SLL   R0,24               SHIFT TO HIGH BYTE\n         OR    R1,R0               MERGE DUMP FLAG\n         L     R15,=V(SYSINT)      SYSTEM DEPENDENT ROUTINE\n         BAL   R14,104(,R15)       GO TO IT\n         SPACE\n        $EXIT  RC=0                IN CASE IT SHOULD RETURN\n         SPACE\n         LTORG ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SYCONSW": {"ttr": 12293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00/\\x00/\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              'SYCONSW' --- WRITE TO ONLINE USER                     *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R0) LENGTH TO PUT\n*                  --  (R1) POINTER TO DATA\n         SPACE\nSYCONSW $ENTER ,\n         L     R2,X'10'            GET CVT POINTER\n         TM    7(R2),X'01'         IS THIS CMS .Q\n         BO    SYCW01              BRANCH IF YES\n         TPUT  (1),(0)             DISPLAY STRING\n         B     SYCW05              AND RETURN\n         SPACE\nSYCW01   DS    0H\n         LR    R3,R1               DATA POINTER\n         LR    R2,R0               LENGTH LEFT\n         LR    R4,R0               TOTAL LENGTH\nSYCW02   DS    0H\n         C     R2,SYCWCMSX         MAX PARTIAL RECORD LENGTH\n         BNH   SYCW03              BRANCH IF ALL FITS\n         L     R0,SYCWCMSX         MAX AT ONE TIME\n         WRTERM (R3),(0),EDIT=NO   FIRST PART BUT NO C/R\n         S     R2,SYCWCMSX         DECREMENT LENGTH LEFT\n         A     R3,SYCWCMSX         BUMP OUTPUT POINTER\n         B     SYCW02              AND DO IT AGAIN\nSYCW03   DS    0H\n         WRTERM (R3),(R2)          PUT REST WITH C/R\n         LR    R2,R4               TOTAL LENGTH\n         C     R2,SYCWCMSX         DID IT FIT IN ONE .Q\n         BNH   SYCW05              BRANCH IF YES\n         SRL   R2,3                DIVIDE BY EIGHT\n         LA    R1,SYCWIDLL         MAXIMUM IDLES\n         CR    R2,R1               TOO MANY .Q\n         BNH   SYCW04              BRANCH IF NOT\n         LR    R2,R1               TAKE MAXIMUM INSTEAD\nSYCW04   DS    0H\n         WRTERM SYCWIDL,(R2),EDIT=NO    AND WAIT SOME\n         SPACE\nSYCW05   DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\nSYCWCMSX DC    F'130'              MAX CMS TERMINAL LINE LENGTH\nSYCWIDL  DC    32X'17'             MAXIMUM EXTRA IDLES\nSYCWIDLL EQU   *-SYCWIDL           AND ITS LENGTH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SYFMAIN": {"ttr": 12295, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x11\\x00\\x11\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              'SYFMAIN' --- FREEMAIN ONE CONTIGUOUS SYSTEM AREA      *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R0)  CONTAINS LENGTH TO FREE\n*                      (R1)  CONTAINS ADDRESS TO FREE\n*\n*        ON EXIT   --  EITHER SUCCEEDS OR ABENDS\n         SPACE\nSYFMAIN $ENTER ,\n         L     R15,=V(SYSINT)      SYSTEM DEPENDENT ROUTINE\n         BAL   R14,16(,R15)        FREEMAIN SYSTEM STORAGE\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\n         LTORG ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SYGMAIN": {"ttr": 12297, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\"\\x00\"\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              'SYGMAIN' --- GETMAIN ROUTINE                          *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R0)  CONTAINS DESIRED LENGTH\n*        ON EXIT   --  IF SUCCESSFUL  CC = BPOS\n*                                     (R1) IS ADDR OF GOTTEN AREA\n*                    IF UNSUCCESSFUL  CC = BNEG\n*                                     (R1) IS ZERO\n         SPACE\nSYGMAIN $ENTER ,\n         L     R15,=V(SYSINT)      SYSTEM DEPENDENT ROUTINE\n         BAL   R14,4(,R15)         GET ADDRESS OF SICA\n         LR    R2,R13              RETAIN CURRENT SAVE AREA ADDR\n         LR    R13,R1              GIVE GETMAIN A WORK AREA\n         SPACE\n         LR    R1,R0               SET MAX CORE EQUAL MIN CORE\n         L     R15,=V(SYSINT)      SYSTEM DEPENDENT ROUTINE\n         BAL   R14,12(,R15)        GET SYSTEM STORAGE\n         BNZ   SYGMA01             BRANCH IF FAILURE\n        $CC    POS                 SET SUCCESSFUL RETURN\n         B     SYGMA02             AND GO TO RETURN\n         SPACE\nSYGMA01  DS    0H\n         SR    R1,R1               CLEAR RETURN POINTER\n        $CC    NEG                 SET UNSUCCESSFUL\n         SPACE\nSYGMA02  DS    0H\n         LR    R13,R2              RESTORE SAVE AREA ADDRESS\n        $EXIT  KEEP=(R1),RC=0      RETURN TO CALLER\n         SPACE\n         LTORG ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SYMCLR": {"ttr": 12299, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00A\\x00A\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 65, "newlines": 65, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        INTERNAL FUNCTION 'SYMCLR' -- DELETE REFERENCE SYMBOLS       *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER --  LA    R1,SRAREA  POINT TO DICTIONARY\n*                    $CALL  SYMCLR     DELETE DICTIONARY ENTRIES\n         SPACE\nSYMCLR  $ENTER ,\n         LR    X2,R1               POINT TO DICT ENTRY\n         USING SRAREA,X2           AND TELL THE ASSEMBLER\n         L     X1,SRANCH           FIRST SYMBOL POINTER\n         XC    SRAREA(SRALEN),SRAREA    CLEAR DICT ENTRY\n         DROP  X2\n         SPACE\nSCLR01   DS    0H\n         LTR   X1,X1               AT END OF SYMBOL CHAIN .Q\n         BZ    SCLR03              RETURN IF YES\n         USING RND,X1              SYMBOL LOOKS LIKE THIS\n         L     X2,RNSLINK          NEXT ARRAY ELEMENT\n         LA    R1,RND              POINT TO SYMBOL AREA\n         L     X1,RNSCHN           NEXT SYMBOL AREA\n         BAL   RETURN,SCLR10       DELETE THE SYMBOL\n         L     R1,RNTBCNT          VARIABLE COUNT\n         S     R1,F1               LESS ONE\n         ST    R1,RNTBCNT          UPDATE USER VARIABLE COUNT\n         DROP  X1\n         SPACE\nSCLR02   DS    0H\n         LTR   X2,X2               AT END OF ARRAY CHAIN .Q\n         BZ    SCLR01              BRANCH IF YES\n         USING RND,X2              ARRAY ELEMENT DESCRIPTOR\n         LA    R1,RND              POINT TO ARRAY ELEMENT\n         L     X2,RNSLINK          NEXT ARRAY ELEMENT\n         BAL   RETURN,SCLR10       DELETE ARRAY ELEMENT\n         L     R1,RNTBSCNT         ARRAY ELEMENT COUNT\n         S     R1,F1               LESS ONE\n         ST    R1,RNTBSCNT         UPDATE ARRAY ELEMENT COUNT\n         B     SCLR02              GO DOWN ENTIRE ARRAY CHAIN\n         DROP  X2\n         SPACE\nSCLR03   DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nSCLR10   DS    0H\n        $SAVE  ,                   SAVE ALL REGISTERS\n         LR    X1,R1               POINT TO SYMBOL\n         USING RND,X1              AND TELL THE ASSEMBLER\n         TM    RNFLAG,RNCHAR       A CHARACTER VALUE .Q\n         BNO   SCLR11              BRANCH IF NOT\n         CLI   RNCLEN,L'RNCVAL     A LONG CHARACTER VALUE .Q\n         BNH   SCLR11              BRANCH IF NOT\n         L     R0,RNCPTR           POINTER TO LONG STRING\n         SR    R1,R1               ZERO LENGTH REG\n         IC    R1,RNCLEN           LENGTH OF LONG STRING\n        $CALL  FREECELL            RELEASE THE AREA\n         SPACE\nSCLR11   DS    0H\n         LA    R0,RND              POINT TO SYMBOL AREA\n         LA    R1,RNLN             LENGTH OF SYMBOL AREA\n        $CALL  FREECELL            RELEASE SYMBOL AREA\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         BR    RETURN              RETURN TO CALLER\n         DROP  X1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SYMSR": {"ttr": 12301, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00M\\x00M\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 77, "newlines": 77, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        INTERNAL FUNCTION 'SYMSR' -- LOCATE SET REFERENCE NAME       *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER:   $CALL  SYMSR                                     *\n*                                                                     *\n*        CC=BOMIT   SYMBOL NOT FOUND (COUNT=FREE SLOT|0)              *\n*        CC=BPOS    SYMBOL FOUND     (COUNT=ADDR)                     *\n*        CC=BNEG    SYMBOL(0) FOUND  (COUNT=ADDR)                     *\n*        CC=BDNO    SYMBOL(0) NOT FOUND (COUNT=FREE SLOT|0)           *\n         SPACE\nSYMSR   $ENTER ,\n         L     R1,ASRWORK          DICTIONARY POINTER\n         LTR   R1,R1               ANY PRESENT .Q\n         BNZ   SSR02               BRANCH IF YES\n         SPACE\n         L     X1,CURFILE          CURRENT FILE CONTROL BLOCK\n         LTR   X1,X1               ANY FILE ON READER STACK .Q\n         BZ    SSR01               BRANCH IF NONE\n         USING FILBLOCK,X1         FILE CONTROL BLOCK LOOKS LIKE THIS\n         LA    R1,FILSRAR          LOCAL DICTIONARY DESCRIPTOR\n         DROP  X1\n        $CALL  SYMUSL              LOOK UP THE VARIABLE\n         BC    BPOS,SSR07          BRANCH IF FOUND LOCALLY\n         SPACE\nSSR01    DS    0H\n         L     R1,ASRGBL           GLOBAL DICTIONARY DESCRIPTOR\n        $CALL  SYMUSL              LOOK UP THE VARIABLE AGAIN\n         BC    BPOS,SSR07          BRANCH IF FOUND GLOBALLY\n         B     SSR03               CREATE NEW VARIABLE\n         SPACE\nSSR02    DS    0H\n        $CALL  SYMUSL              LOOK UP SYMBOL\n         BC    BPOS,SSR07          BRANCH IF FOUND\nSSR03    DS    0H\n         LR    X1,COUNT            REMEMBER TRAILING POINTER\n         LA    R1,RNLN             LENGTH OF ONE NEW ENTRY\n        $CALL  GETCELL             GET NEW SPACE FOR REF\n         BC    BPOS,SSR04          BRANCH IF SUCCESSFUL\n         SR    COUNT,COUNT         ZERO RETURN POINTER\n         B     SSR05               AND GO TO RETURN\n         SPACE\nSSR04    DS    0H\n         XC    0(RNLN,TEMP),0(TEMP)     CLEAR AREA\n         ST    TEMP,RNSCHN-RND(,X1)     SET NEW FORWARD POINTER\n         L     R0,RNTBCNT          GET COUNT OF USER VARIABLES\n         A     R0,F1               PLUS ONE\n         ST    R0,RNTBCNT          UPDATE COUNT OF USER VARIABLES\n         LR    COUNT,TEMP          RETURN NEW POINTER\nSSR05    DS    0H\n         OC    SRNMSUB,SRNMSUB     ANY SUBSCRIPT PRESENT .Q\n         BZ    SSR06               BRANCH IF NONE\n        $CC    DNO                 SYMBOL(0) NOT FOUND\n         B     SSR10               GO TO RETURN\n         SPACE\nSSR06    DS    0H\n        $CC    OMIT                SYMBOL NOT FOUND\n         B     SSR10               GO TO RETURN\n         SPACE\nSSR07    DS    0H\n         TM    SRNMFLG,SRNMALL     ONE OF THE 'ALL' VARIATIONS .Q\n         BO    SSR08               BRANCH IF YES\n         OC    SRNMSUB,SRNMSUB     ANY SUBSCRIPT PRESENT .Q\n         BZ    SSR09               BRANCH IF NONE\nSSR08    DS    0H\n        $CC    NEG                 SYMBOL(0) FOUND\n         B     SSR10               GO TO RETURN\n         SPACE\nSSR09    DS    0H\n        $CC    POS                 SYMBOL FOUND\n         B     SSR10               GO TO RETURN\n         SPACE\nSSR10    DS    0H\n        $RESTOR KEEP=(COUNT)       RESTORE CALLER'S REGISTERS\n         BR    RETURN              AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SYMUR": {"ttr": 12304, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00T\\x00T\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 84, "newlines": 84, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        INTERNAL FUNCTION 'SYMUR' -- LOCATE USE REFERENCE NAME       *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER  --  $CALL  SYMUR\n*\n*        ON EXIT   --  CC=BPOS  SYMBOL FOUND (COUNT=ADDR)\n*                           OR  SYMBOL(N) FOUND (COUNT=ADDR)\n*                      CC=BNEG  SYMBOL(0) FOUND (COUNT=ADDR)\n         SPACE\nSYMUR   $ENTER ,\n         L     X1,CURFILE          CURRENT FILE CONTROL BLOCK\n         LTR   X1,X1               ANY FILE ON READER STACK .Q\n         BZ    SUR01               BRANCH IF NOT\n         SPACE\n         USING FILBLOCK,X1         FILE CONTROL BLOCK LOOKS LIKE THIS\n         LA    R1,FILSRAR          LOCAL DICTIONARY DESCRIPTOR\n         DROP  X1\n        $CALL  SYMUSL              LOOK UP THE VARIABLE\n         BC    BPOS,SUR06          BRANCH IF FOUND\n         SPACE\nSUR01    DS    0H\n         L     R1,ASRGBL           GLOBAL DICTIONARY DESCRIPTOR\n        $CALL  SYMUSL              LOOK UP VARIABLE AGAIN\n         BC    BPOS,SUR06          BRANCH IF FOUND\n         SPACE\n         CLI   SRNM,C'$'           SYMBOL START WITH '$' .Q\n         BNE   SUR03               BRANCH IF NOT\n         CLC   SRNM+L'SRNM-L'SRNSYS+1(L'SRNSYS-1),BLANKS  END BLANK .Q\n         BNE   SUR03               BRANCH IF NOT\n         LA    COUNT,L'SRNM-L'SRNSYS    NUMBER OF CHARS TO MOVE\nSUR02    DS    0H\n         IC    R0,SRNM(COUNT)      GET LAST CHAR\n         STC   R0,SRNM+L'SRNSYS-1(COUNT)  MOVE TO RIGHT\n         BCT   COUNT,SUR02         DO ALL CHARACTERS\n        $MVC   SRNM,SRNSYS         ENTER PREFIX\nSUR03    DS    0H\n         LM    R0,R1,SRNTBLN       PRIME SYSTEM SEARCH LOOP\n         L     COUNT,SRNTBBEG      START OF SYSTEM REFERENCE TABLE\n         SR    COUNT,R0            LESS ONE DUMMY START ENTRY\n         B     SUR05               BRANCH TO LOOP END\nSUR04    DS    0H\n         USING RND,COUNT           SYMBOL ENTRY LOOKS LIKE THIS\n         CLC   RNSYM,SRNM          THIS ENTRY .Q\n         BNE   SUR05               IF NOT, CONTINUE\n         TM    RNFLAG,RNPTR        POINTER DATA .Q\n         BZ    SUR06               BRANCH BACK IF NOT\n         L     X1,SRNTBBEG         START OF SYSTEM REFERENCE TABLE\n         BAL   R14,RNCVAL          BRANCH TO ROUTINE\n         B     SUR06               SET CONDITION CODE AND RETURN\nSUR05    DS    0H\n         BXLE  COUNT,R0,SUR04      NO, CHECK NEXT ENTRY\n         L     COUNT,SRNTBCUR      POINT TO LAST NULL ENTRY\nSUR06    DS    0H\n         TM    SRNMFLG,SRNMALL     IMPLIED SUBSCRIPT .Q\n         BO    SUR10               BRANCH IF YES\n         CLC   SRNMSUB,F0          ANY SUBSCRIPT .Q\n         BE    SUR09               BRANCH IF NONE\nSUR07    DS    0H\n         CLC   RNSUBS,SRNMSUB      COMPARE SUBSCRIPTS .Q\n         BH    SUR08               BRANCH IF GT\n         BE    SUR09               BRANCH IF FOUND\n         CLC   RNSLINK,F0          AT THE END .Q\n         BE    SUR08               BRANCH IF YES\n         L     COUNT,RNSLINK       FETCH NEXT SUB POINTER\n         B     SUR07               TRY AGAIN\n         SPACE\nSUR08    DS    0H\n         L     COUNT,SRNTBCUR      POINT TO LAST NULL ENTRY\nSUR09    DS    0H\n        $CC    POS                 SET CC BPOS\n         B     SUR11               AND RETURN\n         SPACE\nSUR10    DS    0H\n        $CC    NEG                 SET CC BNEG\n         SPACE\nSUR11    DS    0H\n        $RESTOR KEEP=(COUNT)       RESTORE CALLER'S REGS\n         BR    RETURN              RETURN TO CALLER\n         SPACE\nSRNSYS   DC    C'SYS'              THIS PREFIX EQUIVALENT TO '$'\n         DROP  COUNT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SYMUSL": {"ttr": 12307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00Q\\x00Q\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 81, "newlines": 81, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        INTERNAL FUNCTION 'SYMUSL' -- LOCATE REFERENCE NAME          *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER  --  LA    R1,SRAREA\n*                     $CALL  SYMUSL\n*\n*        ON EXIT   --  CC=BPOS  SYMBOL FOUND (COUNT=ADDR)\n*                      CC=BNEG  SYMBOL NOT FOUND (COUNT=\n*                                          LAST ADDR IN CHAIN)\n         SPACE\nSYMUSL  $ENTER ,\n         LR    X1,R1               ENTRY POINTER\n         USING SRAREA,X1           AND IT LOOKS LIKE THIS\n         LA    X2,SRANCH           TRAILING POINTER\n         L     COUNT,SRANCH        START OF REFERENCE CHAIN\n         LTR   COUNT,COUNT         DOES REFERENCE CHAIN EXIST .Q\n         BZ    SUSL08              BRANCH IF NOT\n         SPACE\n         L     R1,RNTBSRCH         COUNT OF REF NAME SEARCHES\n         A     R1,F1               PLUS ONE\n         ST    R1,RNTBSRCH         UPDATE WITH NEW TOTAL\n         LA    R1,ASRCNT           NUMBER OF LAST REF POINTERS\n         SR    R15,R15             START OF LOOKASIDE TABLE\nSUSL01   DS    0H\n         USING RND,COUNT           REF TABLE ADDRESSABILITY\n         L     COUNT,SRLAST(R15)   TRIAL ENTRY\n         LTR   COUNT,COUNT         ANY ENTRY .Q\n         BZ    SUSL02              BRANCH IF NOT\n         CLC   RNSYM,SRNM          THIS ENTRY .Q\n         BE    SUSL03              IF SO, QUIT\n         LA    R15,4(,R15)         NEXT ENTRY ADDRESS\n         BCT   R1,SUSL01           TRY THEM ALL\n         SR    COUNT,COUNT         WE FAILED\n         S     R15,F4              BACKUP TO LAST TRIAL ENTRY\nSUSL02   DS    0H\n         L     R1,RNTBFAIL         GET LOOKASIDE FAILURE COUNT\n         A     R1,F1               PLUS ONE\n         ST    R1,RNTBFAIL         UPDATE LOOKASIDE FAILURE COUNT\nSUSL03   DS    0H\n         S     R15,F4              REARRANGE POINTERS\n         BM    SUSL04              BRANCH OUT WHEN DONE\n         L     R1,SRLAST(R15)      GET ENTRY TO PUSH DOWN\n         ST    R1,SRLAST+4(R15)    PUSH IT\n         B     SUSL03              GO UNTIL EXAUSTED\n         SPACE\nSUSL04   DS    0H\n         LTR   COUNT,COUNT         WERE WE SUCCESSFUL .Q\n         BNZ   SUSL09              BRANCH IF YES\n         LA    COUNT,SRANCH        START PTR TO REF CHAIN\n         L     R1,SRNM             FOR FASTER FOUR CHAR COMPARES\n         B     SUSL06              ENTER AT CHECK FOR END\n         SPACE\nSUSL05   DS    0H\n         C     R1,RNSYM            COULD IT BE THIS ENTRY\n         BE    SUSL07              BRANCH IF YES\nSUSL06   DS    0H\n         LA    X2,RNSCHN           REMEMBER THE TRAILER\n         L     COUNT,RNSCHN        NEXT POINTER TO TRY\n         LTR   COUNT,COUNT         AT THE CHAIN END .Q\n         BNZ   SUSL05              BRANCH IF NOT\n         B     SUSL08              WE HAVE FAILED\nSUSL07   DS    0H\n         CLC   RNSYM+4(L'RNSYM-4),SRNM+4     CHECK TRAILER INFO\n         BE    SUSL09              BRANCH IF ALL EQUAL\n         B     SUSL06              NO, CHECK FOR END\n         SPACE\nSUSL08   DS    0H\n         LR    COUNT,X2            RETURN TRAILING POINTER\n        $CC    NEG                 FAILURE RETURN CODE\n         B     SUSL10              GO TO RETURN\n         SPACE\nSUSL09   DS    0H\n         ST    COUNT,SRLAST        RETAIN SUCCESSFUL POINTER IN STACK\n        $CC    POS                 SUCCESSFUL RETURN\n         SPACE\nSUSL10   DS    0H\n        $EXIT  KEEP=(COUNT),RC=0   RETURN TO CALLER\n         DROP  COUNT,X1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SYPUT": {"ttr": 12310, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x004\\x004\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              'SYPUT' --- QSAM PUT A RECORD                          *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R1) IOCB ADDRESS\n*                      (R0) DATA POINTER TO RDW\n         SPACE\nSYPUT   $ENTER ,\n         LR    R2,R1               IOCB ADDRESS\n         LR    R1,R0               POINT TO DATA\n         TM    IOCRECFM-IOCB(R2),X'C0'  RECFM 'U' .Q\n         BO    SYPUT01             BRANCH IF YES\n         TM    IOCRECFM-IOCB(R2),X'40'  RECFM 'V' .Q\n         BO    SYPUT01             BRANCH IF YES\n         L     R3,IOCBUSER-IOCB(,R2)    WORK BUFFER ADDR\n         LTR   R3,R3               DOES IT EXIST .Q\n         BZ    SYPUT00             BRANCH IF NOT\n         SPACE\n         LH    R4,IOCLRECL-IOCB(,R2)    LENGTH OF RECORD\n         BCTR  R4,0                LENGTH-1\n         BCTR  R4,0                LENGTH-2\n         MVI   4(R3),C' '          BLANK FIRST CHARACTER\n         EX    R4,SYPUTMVC         DO ALL CHARACTERS\n         LH    R4,0(,R1)           DATA LENGTH INCL RDW\n         BCTR  R4,0                LENGTH-1\n         EX    R4,SYPUTMVD         MOVE DATA TO TEMP\n         LR    R1,R3               POINT TO TEMP BUFFER\nSYPUT00  DS    0H\n         LA    R1,4(,R1)           POINT TO DATA\n         LH    R0,IOCLRECL-IOCB(,R2)    FILE LRECL\n         B     SYPUT03             GO TO PUT\n         SPACE\nSYPUT01  DS    0H\n         LH    R0,0(,R1)           RECORD LENGTH\n         LA    R1,4(,R1)           POINT TO DATA\n         S     R0,=F'4'            DECREMENT LENGTH BY RDW LENGTH\n         CH    R0,IOCLRECL-IOCB(,R2)    TOO LONG .Q\n         BNH   SYPUT02             BRANCH IF NOT\n         LH    R0,IOCLRECL-IOCB(,R2)    TAKE MAXIMUM LENGTH\nSYPUT02  DS    0H\n         SPACE\nSYPUT03  DS    0H\n         L     R15,=V(SYSINT)      SYSTEM DEPENDENT ROUTINE\n         BAL   R14,52(,R15)        GO DO THE PUT\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nSYPUTMVC MVC   5(*-*,R3),4(R3)     BLANK WORK BUFFER\nSYPUTMVD MVC   0(*-*,R3),0(R1)     ENTER RDW AND DATA\n         SPACE\n         LTORG ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SYPUTCL": {"ttr": 12545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x1d\\x00\\x1d\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              'SYPUTCL' --- QSAM CLOSE FOR OUTPUT                    *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R1)  IOCB ADDRESS\n*\n*        ON EXIT   --  (R1)  ZERO!!!!!!!!!\n*                      CC = BPOS  IF SUCCESSFUL\n*                         = BNEG  IF UNSUCCESSFUL\n         SPACE\nSYPUTCL $ENTER ,\n         LA    R2,0(,R1)           ADDRESS OF IOCB\n         LTR   R2,R2               ANY FILE TO CLOSE\n         BZ    SYCLQ01             BRANCH IF NOT\n         SR    R1,R1               CLEAR CLOSE CODE REGISTER\n         IC    R1,SYCLCLSE         CLOSE CODE\n         L     R15,=V(SYSINT)      SYSTEM DEPENDENT ROUTINE\n         BAL   R14,36(,R15)        DO THE CLOSE\nSYCLQ01  DS    0H\n         SR    R1,R1               RETURN ZERO POINTER\n        $CC    POS                 SUCCESSFUL RETURN\n         SPACE\n        $EXIT  KEEP=(R1),RC=0      RETURN TO CALLER\n         SPACE\nSYCLCLSE CLOSE (*-*,LEAVE),MF=L    LIST FORM OF CLOSE\n         SPACE\n         LTORG ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SYPUTOP": {"ttr": 12547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x000\\x000\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              'SYPUTOP' --- QSAM OPEN FOR OUTPUT                     *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R1)  IODEF ADDRESS\n*\n*        ON EXIT   --  (R1)  IOCB ADDRESS\n*                      CC = BPOS  IF SUCCESSFUL\n*                         = BNEG  IF UNSUCCESSFUL\n         SPACE\nSYPUTOP $ENTER ,\n         LR    R2,R1               ADDRESS OF IODEF SECTION OF IOCB\n         SR    R1,R1               CLEAR OPEN CODE REGISTER\n         IC    R1,SYOPOPEN         OPEN CODE\n         L     R15,=V(SYSINT)      SYSTEM DEPENDENT ROUTINE\n         BAL   R14,32(,R15)        DO THE OPEN\n         SPACE\n         LTR   R15,R15             TEST SUCCESS\n         BZ    SYOPQ01             BRANCH IF YES\n         SR    R1,R1               RETURN NO IOCB POINTER\n        $CC    NEG                 SET ERROR CONDITION\n         B     SYOPQ04             GO TO RETURN\n         SPACE\nSYOPQ01  DS    0H\n         TM    IOCRECFM-IOCB(R2),X'C0'  RECFM 'U' .Q\n         BO    SYOPQ03             BRANCH IF YES\n         TM    IOCRECFM-IOCB(R2),X'40'  RECFM 'V' .Q\n         BO    SYOPQ03             BRANCH IF YES\n         LH    R1,IOCLRECL-IOCB(,R2)    FILE RECORD LENGTH\n         LA    R1,4(,R1)           PLUS LENGTH OF DUMMY RDW\n        $CALL  GETCELL             GET A WORK BUFFER\n         BC    BPOS,SYOPQ02        BRANCH IF SUCCESSFUL\n         MVI   EFLAG024,ERRSET     NO STORAGE AVAILABLE\nSYOPQ02  DS    0H\n         ST    R3,IOCBUSER-IOCB(,R2)    SAVE WORK BUFFER ADDRESS\n         SPACE\nSYOPQ03  DS    0H\n         LA    R1,0(,R2)           RETURN IOCB ADDRESS\n        $CC    POS                 SUCCESSFUL RETURN\n         SPACE\nSYOPQ04  DS    0H\n        $EXIT  KEEP=(R1),RC=0      RETURN TO CALLER\n         SPACE\nSYOPOPEN OPEN  (*-*,(OUTPUT,DISP)),MF=L  LIST FORM OF OPEN\n         SPACE\n         LTORG ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SYSPIE": {"ttr": 12549, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x14\\x00\\x14\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              'SYSPIE' --- SPECIFY PROGRAM INTERRUPTION EXIT         *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY -- (R1)  CONTAINS INTERRUPTION EXIT ADDRESS\n         SPACE\nSYSPIE  $ENTER ,\n         LH    R0,=X'7FFF'         WE WANT ALL INTERRUPTS\n         SR    R2,R2               CAN CHECK FOR ZERO IN EXIT\n         L     R15,=V(SYSINT)      SYSTEM DEPENDENT ROUTINE\n         BAL   R14,72(,R15)        SET THE TRAP\n         SPACE\n         SR    R1,R1               CLEAR A REGISTER\n         SPM   R1                  SET ZERO PROGRAM MASK\n         SPACE\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\n         LTORG ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SYSREFS": {"ttr": 12551, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x01\\xdd\\x01\\xdd\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 477, "newlines": 477, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              SYSTEM REFERENCE SYMBOLS                               *\n*                                                                     *\n***********************************************************************\n         SPACE\nSYSREFS  CSECT ,                   SYSTEM REFERENCE SYMBOLS\n         USING SYSREFS,X1          CALLER PROVIDED\n        $SYSREF SYSYEAR,TYPE=CHAR,LENGTH=2,VALUE='**'\n        $SYSREF SYSPYEAR,TYPE=CHAR,LENGTH=4,VALUE='19**'\n        $SYSREF SYSMONTH,TYPE=CHAR,LENGTH=2,VALUE='**'\n        $SYSREF SYSPMONTH,TYPE=CHAR,LENGTH=*-*,VALUE='ULLLL'\n        $SYSREF SYSDAYOFY,TYPE=CHAR,LENGTH=3,VALUE='***'\n        $SYSREF SYSDAYOFM,TYPE=CHAR,LENGTH=2,VALUE='**'\n        $SYSREF SYSDAYOFW,TYPE=CHAR,LENGTH=1,VALUE='*'\n        $SYSREF SYSPDAYOFW,TYPE=CHAR,LENGTH=*-*,VALUE='ULLLL'\n        $SYSREF SYSDATE,TYPE=PTR,BRANCH=SDATE\n        $SYSREF SYSHOUR,TYPE=CHAR,LENGTH=2,VALUE='**'\n        $SYSREF SYSMINUTE,TYPE=CHAR,LENGTH=2,VALUE='**'\n        $SYSREF SYSSECOND,TYPE=CHAR,LENGTH=2,VALUE='**'\n        $SYSREF SYSTIME,TYPE=CHAR,LENGTH=8,VALUE='**:**:**'\n         SPACE\n        $SYSREF SYSRECNO,TYPE=PTR,BRANCH=SRECNO\n        $SYSREF SYSLINE,TYPE=PTR,BRANCH=SLINE\n        $SYSREF SYSFILE,TYPE=PTR,BRANCH=SFILE\n        $SYSREF SYSMEMBER,TYPE=PTR,BRANCH=SMEMBER\n        $SYSREF SYSSEQNO,TYPE=PTR,BRANCH=SSEQNO\n        $SYSREF SYSPARM,TYPE=PTR,BRANCH=SPARM\n        $SYSREF SYSCONT,TYPE=PTR,BRANCH=SCONT\n        $SYSREF SYSRETCODE,TYPE=PTR,BRANCH=SRETCODE\n        $SYSREF SYSRET,TYPE=PTR,BRANCH=SRET\n         SPACE\n        $SYSREF SYSAD,TYPE=PTR,BRANCH=SAD\n        $SYSREF SYSADEVEN,TYPE=PTR,BRANCH=SADEVN\n        $SYSREF SYSADODD,TYPE=PTR,BRANCH=SADODD\n        $SYSREF SYSBC,TYPE=PTR,BRANCH=SBC\n        $SYSREF SYSBS,TYPE=PTR,BRANCH=SBS\n        $SYSREF SYSBX,TYPE=PTR,BRANCH=SBX\n        $SYSREF SYSCC,TYPE=PTR,BRANCH=SCC\n        $SYSREF SYSCCC,TYPE=PTR,BRANCH=SCCC\n        $SYSREF SYSCD,TYPE=PTR,BRANCH=SCD\n        $SYSREF SYSCL,TYPE=PTR,BRANCH=SCL\n        $SYSREF SYSCPI,TYPE=PTR,BRANCH=SCPI\n        $SYSREF SYSDA,TYPE=PTR,BRANCH=SDA\n        $SYSREF SYSDHSET,TYPE=PTR,BRANCH=SDHSET\n        $SYSREF SYSHI,TYPE=PTR,BRANCH=SHI\n        $SYSREF SYSLL,TYPE=PTR,BRANCH=SLL\n        $SYSREF SYSLS,TYPE=PTR,BRANCH=SLS\n        $SYSREF SYSMC,TYPE=PTR,BRANCH=SMC\n        $SYSREF SYSPI,TYPE=PTR,BRANCH=SPI\n        $SYSREF SYSPL,TYPE=PTR,BRANCH=SPL\n        $SYSREF SYSSC,TYPE=PTR,BRANCH=SSC\n        $SYSREF SYSTM,TYPE=PTR,BRANCH=STM\n        $SYSREF SYSBM,TYPE=PTR,BRANCH=SBM\n        $SYSREF SYSHM,TYPE=PTR,BRANCH=SHM\n        $SYSREF SYSHN,TYPE=PTR,BRANCH=SHN\n        $SYSREF SYSHNC,TYPE=PTR,BRANCH=SHNC\n        $SYSREF SYSHS,TYPE=PTR,BRANCH=SHS\n        $SYSREF SYSHY,TYPE=PTR,BRANCH=SHY\n        $SYSREF SYSHYC,TYPE=PTR,BRANCH=SHYC\n        $SYSREF SYSFM,TYPE=PTR,BRANCH=SFM\n        $SYSREF SYSCP,TYPE=PTR,BRANCH=SCP\n        $SYSREF SYSCPC,TYPE=PTR,BRANCH=SCPC\n        $SYSREF SYSFB,TYPE=PTR,BRANCH=SFB\n        $SYSREF SYSFBC,TYPE=PTR,BRANCH=SFBC\n        $SYSREF SYSFBF,TYPE=PTR,BRANCH=SFBF\n        $SYSREF SYSFK,TYPE=PTR,BRANCH=SFK\n        $SYSREF SYSFKC,TYPE=PTR,BRANCH=SFKC\n        $SYSREF SYSFN,TYPE=PTR,BRANCH=SFN\n        $SYSREF SYSFNC,TYPE=PTR,BRANCH=SFNC\n        $SYSREF SYSFNCOUNT,TYPE=PTR,BRANCH=SFNCOUNT\n        $SYSREF SYSFS,TYPE=PTR,BRANCH=SFS\n        $SYSREF SYSPAGE,TYPE=PTR,BRANCH=SPAGE\n        $SYSREF SYSDPAGE,TYPE=PTR,BRANCH=SDPAGE\n        $SYSREF SYSPPAGE,TYPE=PTR,BRANCH=SPPAGE\n        $SYSREF SYSIN,TYPE=PTR,BRANCH=SIN\n        $SYSREF SYSINR,TYPE=PTR,BRANCH=SINR\n        $SYSREF SYSIXREF,TYPE=CHAR,LENGTH=2,VALUE=', '\n        $SYSREF SYSTCTB,TYPE=CHAR,LENGTH=2,VALUE='. '\n        $SYSREF SYSRMNEST,TYPE=PTR,BRANCH=SRMN\n        $SYSREF SYSFLNEST,TYPE=PTR,BRANCH=SFLN\n        $SYSREF SYSPASSNO,TYPE=PTR,BRANCH=SPSNO\n        $SYSREF SYSPASSOF,TYPE=PTR,BRANCH=SPSOF\n        $SYSREF SYSWD,TYPE=PTR,BRANCH=SWD\n         SPACE\n        $SYSREF SYSOUT,TYPE=PTR,BRANCH=SOUT\n        $SYSREF SYSONLINE,TYPE=PTR,BRANCH=SONLINE\n        $SYSREF SYSOFFLINE,TYPE=PTR,BRANCH=SOFFLINE\n        $SYSREF SYSSCREEN,TYPE=PTR,BRANCH=SSCREEN\n         SPACE\n        $SYSREF SYSBLANK,TYPE=PTR,BRANCH=SBLANK\n        $SYSREF SYSVERSION,TYPE=PTR,BRANCH=SVERSN\n         SPACE\n        $SYSREF SYSNULL,TYPE=CHAR,LENGTH=0,VALUE=' ',LAST=0\n         SPACE\n        $SYSREF SYSBIN,TYPE=NUM,LENGTH=4,VALUE='****'\n        $SYSREF SYSCHAR,TYPE=CHAR,LENGTH=*-*,VALUE='**'\n        $SYSREF SYSNO,TYPE=CHAR,LENGTH=1,VALUE='N'\n        $SYSREF SYSYES,TYPE=CHAR,LENGTH=1,VALUE='Y'\n        $SYSREF SYSOFF,TYPE=CHAR,LENGTH=2,VALUE='OFF'\n        $SYSREF SYSON,TYPE=CHAR,LENGTH=2,VALUE='ON'\n        $SYSREF SYSUSER,TYPE=CHAR,LENGTH=4,VALUE='USER'\n        $SYSREF SYSPRT,TYPE=CHAR,LENGTH=5,VALUE='PRINT'\n        $SYSREF SYSTRM,TYPE=CHAR,LENGTH=4,VALUE='TERM'\n         SPACE\nSRECNO   DS    0H\n         L     COUNT,COMFILIT      FILE ITEM NUMBER\nSBINRET  DS    0H\n         ST    COUNT,@BIN+RNDVAL-RND    STORE NUMERIC RESULT\n         LA    COUNT,@BIN          POINT TO IT\nSRETURN  DS    0H\n         BR    R14                 RETURN TO CALLER\n         SPACE\nSLINE    DS    0H\n         LH    COUNT,PLZ           GET PAGE LENGTH\n         SH    COUNT,PLCT          LESS REMAINDER OF PAGE\n         LA    COUNT,1(,COUNT)     PLUS ONE\n         B     SBINRET             AND RETURN\n         SPACE\nSFILE    DS    0H\n         LA    COUNT,COMFILNM      POINT TO FILE NAME\n         LA    R1,8                MAX LENGTH\nSCHARET  DS    0H\n         AR    R1,COUNT            LAST CHAR +1\n         MVI   @CHAR+RNCLEN-RND,X'00'   ASSUME NULL STRING\nSCHARLP  DS    0H\n         BCTR  R1,0                LAST CHAR IN STRING\n         CLI   0(R1),C' '          IS IT BLANK .Q\n         BE    SCHARLP             YES, TRY AGAIN\n         SR    R1,COUNT            LENGTH -1 OF STRING\n         BM    SCHARDN             BRANCH OUT IF NULL\n         LA    R1,1(,R1)           TRUE CHARACTER LENGTH\nSCHARNB  DS    0H\n         STC   R1,@CHAR+RNCLEN-RND      SET TRUE LENGTH\n         CLI   @CHAR+RNCLEN-RND,L'RNCVAL     LONG CHARACTER VALUE\n         BNH   SCHARST             BRANCH IF SHORT\n         ST    COUNT,@CHAR+RNCPTR-RND   SET CHARACTER POINTER\n         B     SCHARDN             BRANCH TO RETURN\nSCHARST  DS    0H\n         BCTR  R1,0                LENGTH-1\n         EX    R1,SCHARMV          MOVE THE STRING\nSCHARDN  DS    0H\n         LA    COUNT,@CHAR         POINT TO IT\n         B     SRETURN             AND RETURN\n         SPACE\nSDATE    DS    0H\n         LA    COUNT,SDATEWRK      POINT TO FORMATTED DATE\n         LA    R1,L'SDATEWRK       MAX LENGTH\n         B     SCHARET             ENTER THE RESULT\n         SPACE\nSMEMBER  DS    0H\n         LA    COUNT,COMMEMNM      POINT TO MEMBER NAME\n         LA    R1,8                MAX LENGTH\n         B     SCHARET             ENTER RESULT\n         SPACE\nSSEQNO   DS    0H\n         LA    COUNT,COMFILNO      POINT TO SEQUENCE NUMBER\n         LA    R1,8                MAX LENGTH\n         B     SCHARET             ENTER THE RESULT\n         SPACE\nSPARM    DS    0H\n         L     COUNT,PLSTSV        GET PARM LIST ADDRESS\n         L     COUNT,0(,COUNT)     GET ADDR OF ACTUAL LIST\n         LH    R1,0(,COUNT)        GET LENGTH OF PARM\n         LA    COUNT,2(,COUNT)     POINT TO ACTUAL PARM STRING\n         B     SCHARET             AND ENTER THE RESULT\n         SPACE\nSCONT    DS    0H\n         L     COUNT,ERCONT        COUNT OF ERRORS LEFT\n         B     SBINRET             AND RETURN\nSRETCODE DS    0H\n         LH    COUNT,RETCODE       GET CURRENT SCRIPT RETURN CODE\n         B     SBINRET             AND RETURN\nSRET     DS    0H\n         LH    COUNT,SYRET         GET LAST SYSTEM RETURN CODE\n         B     SBINRET             AND RETURN\n         SPACE\nSAD      DS    0H\n         LH    COUNT,ADJCNT        ADJUST VALUE\n         B     SBINRET             AND RETURN\nSADEVN   DS    0H\n         LH    COUNT,ADJCEVN       EVEN PAGE ADJUST VALUE\n         B     SBINRET             AND RETURN\nSADODD   DS    0H\n         LH    COUNT,ADJCODD       ODD PAGE ADJUST VALUE\n         B     SBINRET             AND RETURN\n         SPACE\nSBC      DS    0H\n         LA    COUNT,@NO           ASSUME NOT BALANCED COLUMNS\n        $IFOFF SWITCHS,BCSWS,SBC01 BRANCH IF TRUE\n         LA    COUNT,@YES          POINT TO YES\nSBC01    DS    0H\n         B     SRETURN             GO TO RETURN\n         SPACE\nSBS      DS    0H\n         LA    COUNT,BSIND         USER BACKSPACE CHARACTER\n         LA    R1,1                LENGTH OF SAME\n         B     SCHARNB             REMOVE NO TRAILING BLANKS\n         SPACE\nSBX      DS    0H\n         LA    COUNT,@NO           ASSUME NOT IN A BOX\n         OC    BXPTR,BXPTR         ANY BOX POINTER .Q\n         BZ    SBX01               BRANCH IF NOT\n         LA    COUNT,@YES          POINT TO AFFIRMATIVE\nSBX01    DS    0H\n         B     SRETURN             GO TO RETURN\n         SPACE\nSCC      DS    0H\n         LA    COUNT,@YES          ASSUME WITHIN CONDITIONAL COLUMN\n         CLI   ICORFLG,ICORCC      WITHIN A CONDITIONAL COLUMN .Q\n         BE    SCC01               BRANCH IF YES\n         LA    COUNT,@NO           POINT TO NO\nSCC01    DS    0H\n         B     SRETURN             GO TO RETURN\nSCCC     DS    0H\n         L     COUNT,CCQCNT        GET CONDITIONAL COLUMN LINE COUNT\n         B     SBINRET             AND RETURN\n         SPACE\nSCD      DS    0H\n         L     COUNT,CDCOUNT       GET COLUMN COUNT\n         B     SBINRET             AND RETURN\n         SPACE\nSCL      DS    0H\n         L     COUNT,CLLZSAVE      GET COLUMN LENGTH\n         B     SBINRET             AND RETURN\n         SPACE\nSCPI     DS    0H\n         L     COUNT,DEFCPI+TAB3DEF     CHARACTERS PER INCH\n         B     SBINRET              AND RETURN\n         SPACE\nSDA      DS    0H\n         LH    COUNT,DARKVAL       DARK OUTPUT VALUE\n         B     SBINRET             AND RETURN\n         SPACE\nSDHSET   DS    0H\n         L     COUNT,DHNUMTC       CURRENT TABLE OF CONTENTS\n         B     SBINRET             AND RETURN\n         SPACE\nSHI      DS    0H\n         LH    COUNT,HICNT         HANGING INDENT\n         B     SBINRET             AND RETURN\n         SPACE\nSLL      DS    0H\n         L     COUNT,LLZ           LINE LENGTH\n         B     SBINRET             AND RETURN\n         SPACE\nSLS      DS    0H\n         LH    COUNT,DSCNT         CURRENT LINE SPACING\n         B     SBINRET             AND RETURN\n         SPACE\nSMC      DS    0H\n         LA    COUNT,@YES          ASSUME IN MULTIPLE COLUMN MODE\n         CLI   ICOLFLG,ICOLMC      WITHIN MULTIPLE COLUMN MODE .Q\n         BE    SMC01               BRANCH IF YES\n         LA    COUNT,@NO           POINT TO NO\nSMC01    DS    0H\n         B     SRETURN             GO TO RETURN\n         SPACE\nSPI      DS    0H\n         LH    COUNT,PICNT         PARAGRAPH INDENT\n         B     SBINRET             AND RETURN\n         SPACE\nSPL      DS    0H\n         LH    COUNT,PLZ           CURRENT PAGE LENGTH\n         B     SBINRET             AND RETURN\n         SPACE\nSSC      DS    0H\n         LA    COUNT,@YES          ASSUME IN SINGLE COLUMN MODE\n         CLI   ICOLFLG,ICOLSC      WITHIN SINGLE COLUMN MODE .Q\n         BE    SSC01               BRANCH IF YES\n         LA    COUNT,@NO           POINT TO NO\nSSC01    DS    0H\n         B     SRETURN             GO TO RETURN\n         SPACE\nSTM      DS    0H\n         LH    COUNT,TOPMRG        CURRENT TOP MARGIN\n         B     SBINRET             AND RETURN\n         SPACE\nSBM      DS    0H\n         LH    COUNT,BMMRG         CURRENT BOTTOM MARGIN\n         B     SBINRET             AND RETURN\n         SPACE\nSHM      DS    0H\n         LH    COUNT,HDMRG         CURRENT HEADING MARGIN\n         B     SBINRET             AND RETURN\n         SPACE\nSHN      DS    0H\n         LA    COUNT,@YES          ASSUME WITHIN HEADNOTE DEFINITION\n         CLI   ICORFLG,ICORHN      WITHIN A HEADNOTE DEFINITION .Q\n         BE    SHN01               BRANCH IF YES\n         LA    COUNT,@NO           POINT TO NO\nSHN01    DS    0H\n         B     SRETURN             GO TO RETURN\nSHNC     DS    0H\n         L     COUNT,HNQCNT        GET HEADNOTE LINE COUNT\n         B     SBINRET             AND RETURN\n         SPACE\nSHS      DS    0H\n         LH    COUNT,HSCNT         CURRENT HEADING SPACING\n         B     SBINRET             AND RETURN\n         SPACE\nSHY      DS    0H\n         LA    COUNT,@OFF          ASSUME HYPHENATION OFF\n         LA    R1,HYNONE           THE OFF VALUE\n         C     R1,HYLEVEL          IS HYPHENATION OFF .Q\n         BE    SHY01               BRANCH IF YES\n         LA    COUNT,@ON           ASSUME HYPHENATION ON\n         LA    R1,HYAUTO           THE ON VALUE\n         C     R1,HYLEVEL          IS HYPHENATION ON .Q\n         BE    SHY01               BRANCH IF YES\n         LA    COUNT,@USER         ELSE MUST BE USER\nSHY01    DS    0H\n         B     SRETURN             GO TO RETURN\nSHYC     DS    0H\n         L     COUNT,HYEXCNT       GET CURRENT EXCEPTION WORD COUNT\n         B     SBINRET             AND RETURN\n         SPACE\nSFM      DS    0H\n         LH    COUNT,FTMRG         CURRENT FOOTING MARGIN\n         B     SBINRET             AND RETURN\n         SPACE\nSCP      DS    0H\n         LA    COUNT,@YES          ASSUME WITHIN CONDITIONAL KEEP\n         CLI   ICORFLG,ICORCP      WITHIN A CONDITIONAL KEEP .Q\n         BE    SCP01               BRANCH IF YES\n         LA    COUNT,@NO           POINT TO NO\nSCP01    DS    0H\n         B     SRETURN             GO TO RETURN\n         SPACE\nSCPC     DS    0H\n         L     COUNT,CPQCNT        GET QUEUED CONDITIONAL KEEP COUNT\n         B     SBINRET             AND RETURN\n         SPACE\nSFB      DS    0H\n         LA    COUNT,@YES          ASSUME WITHIN FLOATING BLOCK\n         CLI   ICORFLG,ICORFB      WITHIN A FLOATING BLOCK .Q\n         BE    SFB01               BRANCH IF YES\n         LA    COUNT,@NO           POINT TO NO\nSFB01    DS    0H\n         B     SRETURN             GO TO RETURN\nSFBC     DS    0H\n         L     COUNT,FBQCNT        GET QUEUED FLOATING BLOCK COUNT\n         B     SBINRET             AND RETURN\nSFBF     DS    0H\n         L     COUNT,FBQCNTF       GET FIRST QUEUED BLOCK COUNT\n         B     SBINRET             AND RETURN\n         SPACE\nSFK      DS    0H\n         LA    COUNT,@YES          ASSUME WITHIN FLOATING KEEP\n         CLI   ICORFLG,ICORFK      WITHIN A FLOATING KEEP .Q\n         BE    SFK01               BRANCH IF YES\n         LA    COUNT,@NO           POINT TO NO\nSFK01    DS    0H\n         B     SRETURN             GO TO RETURN\n         SPACE\nSFKC     DS    0H\n         L     COUNT,FKQCNT        GET QUEUED FLOATING KEEP COUNT\n         B     SBINRET             AND RETURN\n         SPACE\nSFN      DS    0H\n         LA    COUNT,@YES          ASSUME WITHIN FOOTNOTE\n         CLI   ICORFLG,ICORFN      WITHIN A FOOTNOTE .Q\n         BE    SFN01               BRANCH IF YES\n         LA    COUNT,@NO           POINT TO NO\nSFN01    DS    0H\n         B     SRETURN             GO TO RETURN\n         SPACE\nSFNC     DS    0H\n         L     COUNT,FNQCNT        GET QUEUED FOOTNOTE COUNT\n         B     SBINRET             AND RETURN\n         SPACE\nSFNCOUNT DS    0H\n         LH    COUNT,SFNCNT        CURRENT FOOTNOTE NUMBER\n         B     SBINRET             AND RETURN\n         SPACE\nSFS      DS    0H\n         LH    COUNT,FSCNT         CURRENT FOOTING SPACING\n         B     SBINRET             AND RETURN\n         SPACE\nSPAGE    DS    0H\n         L     COUNT,PACNTI        CURRENT INTEGER PAGE NUMBER\n         B     SBINRET             AND RETURN\n         SPACE\nSDPAGE   DS    0H\n         L     COUNT,PACNTD        CURRENT DECIMAL PART OF PAGE NUMBER\n         LTR   COUNT,COUNT         DOES IT EXIST .Q\n         BNM   SBINRET             BRANCH IF YES\n         LA    COUNT,@NULL         OTHERWISE POINT TO NULL\n         B     SRETURN             GO TO RETURN\n         SPACE\nSPPAGE   DS    0H\n        $CALL  PNUMFMT             FORMAT CURRENT PAGE NUMBER\n         LA    COUNT,EBCDPAGE      POINT TO FORMATTED PAGE NUMBER\n         LA    R1,L'EBCDPAGE       MAX LENGTH\n         B     SCHARET             ENTER THE RESULT\n         SPACE\nSIN      DS    0H\n         LH    COUNT,INDL          CURRENT INDENT\n         B     SBINRET             AND RETURN\n         SPACE\nSINR     DS    0H\n         LH    COUNT,INDENTR       CURRENT RIGHT INDENT VALUE\n         B     SBINRET             AND RETURN\n         SPACE\nSWD      DS    0H\n         LA    COUNT,@YES          ASSUME WIDOW IS ON\n        $IFON  SWITCHS,WDSWS,SWD01 BRANCH IF WIDOW IS ON\n         LA    COUNT,@NO           WIDOW IS OFF\nSWD01    DS    0H\n         B     SRETURN             GO TO RETURN\n         SPACE\nSRMN     DS    0H\n         LH    COUNT,RMNEST        CURRENT NESTED REMOTE COUNT\n         B     SBINRET             AND RETURN\n         SPACE\nSFLN     DS    0H\n         LH    COUNT,FILNEST       CURRENT NESTED FILE COUNT\n         B     SBINRET             AND RETURN\n         SPACE\nSPSNO    DS    0H\n         L     COUNT,PASSNO        GET CURRENT PASS NUMBER\n         B     SBINRET             AND RETURN\n         SPACE\nSPSOF    DS    0H\n         L     COUNT,DEFPASOF+TAB3DEF   TOTAL NUMBER OF PASSES\n         B     SBINRET             AND RETURN\n         SPACE\nSOUT     DS    0H\n         LA    COUNT,@PRT          ASSUME OFFLINE PRINTER\n        $IFOFF TTYPE,TONLINE,SOUT01     BRANCH IF NOT ONLINE\n         LA    COUNT,@TRM          POINT TO ONLINE TERMINAL\nSOUT01   DS    0H\n         B     SRETURN             AND RETURN\n         SPACE\nSONLINE  DS    0H\n         LA    COUNT,@NO           ASSUME NOT ONLINE\n        $IFOFF TTYPE,TONLINE,SONL01     BRANCH IF NOT ONLINE\n         LA    COUNT,@YES          POINT TO YES\nSONL01   DS    0H\n         B     SRETURN             AND RETURN\n         SPACE\nSOFFLINE DS    0H\n         LA    COUNT,@YES          ASSUME OFFLINE\n        $IFOFF TTYPE,TONLINE,SOFFL01    BRANCH IF OFFLINE\n         LA    COUNT,@NO           POINT TO NO\nSOFFL01  DS    0H\n         B     SRETURN             AND RETURN\n         SPACE\nSSCREEN  DS    0H\n         LA    COUNT,@YES          ASSUME SCREEN\n        $IFON  TTYPE,TSCREEN,SSCRE01    BRANCH IF SCREEN\n         LA    COUNT,@NO           POINT TO NO\nSSCRE01  DS    0H\n         B     SRETURN             AND RETURN\n         SPACE\nSBLANK   DS    0H\n         CLC   SRNMFR,SRNMFR+L'SRNMFR   'FROM' SUBSTRING SPECIFIED .Q\n         BNE   SBLANK01            BRANCH IF YES\n         CLC   SRNMTO,SRNMTO+L'SRNMTO   'TO' SUBSTRING SPECIFIED .Q\n         BNE   SBLANK01            BRANCH IF YES\n         MVC   SRNMTO,SRNMFR       ELSE DEFAULT SUBSTRING IS ONE CHAR\nSBLANK01 DS    0H\n         LA    R1,L'BLANKS         MAX LENGTH OF RESULT\n         LA    COUNT,BLANKS        POINT TO BLANK STRING\n         B     SCHARNB             REMOVE NO TRAILING BLANKS\n         SPACE\nSVERSN   DS    0H\n         L     COUNT,ADBASE        MAIN SCRIPT ENTRY POINT\n         SR    R1,R1               ZERO LENGTH REGISTER\n         IC    R1,4(,COUNT)        LENGTH OF VERSION IDENT\n         LA    COUNT,5(,COUNT)     POINT TO VERSION IDENT\n         B     SCHARET             AND RETURN\n         SPACE\nSDATEWRK DC    C'MMMMMMMMM DD, YYYY'    SYSDATE WORK AREA\n         SPACE\nSCHARMV  MVC   @CHAR+RNCVAL-RND(*-*),0(COUNT)     MOVE CHAR ARGUMENT\n         DROP  X1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SYTEST": {"ttr": 12801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x19\\x00\\x19\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              'SYTEST' --- TEST IF FILE PRESENT                      *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R1) POINTS TO FILENAME\n*\n*        ON EXIT   --  CC = BPOS  IF FILE PRESENT\n*                      CC = BNEG  IF FILE NOT PRESENT\n         SPACE\nSYTEST  $ENTER ,\n         L     R15,=V(SYSINT)      SYSTEM DEPENDENT ROUTINE\n         BAL   R14,24(,R15)        CHECK FILE PRESENCE\n         BZ    SYTEST01            BRANCH IF FOUND\n        $CC    NEG                 FILE NOT FOUND\n         B     SYTEST02            GO TO RETURN\n         SPACE\nSYTEST01 DS    0H\n        $CC    POS                 FILE FOUND\n         SPACE\nSYTEST02 DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\n         LTORG ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SYTIME": {"ttr": 12803, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00$\\x00$\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              'SYTIME' --- SYSTEM TIME OF DAY                        *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  $CALL  SYTIME\n*\n*        ON EXIT   --  (R0)  HAS TIME IN 'HHMMSS00'\n*                      (R1)  HAS DATE IN '00YYDDDF'\n         SPACE\nSYTIME  $ENTER ,\n         L     R15,=V(SYSINT)      SYSTEM DEPENDENT ROUTINE\n         BAL   R14,76(,R15)        LET HIM DO IT\n         SPACE\n         LR    R2,R0               TIME IN TIMER UNITS\n         SRDL  R2,32               PREPARE FOR A DIVIDE\n         D     R2,=F'38400'        TIME IN SECONDS\n         LR    R2,R3               SECONDS\n         SRDL  R2,32               PREPARE FOR A DIVIDE\n         D     R2,=F'60'           SECONDS IN R2, MINUTES IN R3\n         LR    R0,R2               SAVE SECONDS\n         LR    R2,R3               MINUTES\n         SRDL  R2,32               PREPARE FOR DIVIDE\n         D     R2,=F'60'           MINUTES IN R2, HOURS IN R3\n         MH    R2,=H'100'          SCALE MINUTES BY 100\n         AR    R0,R2               MINUTES,SECONDS IN BINARY\n         MH    R3,=H'100'          SCALE HOURS BY 100\n         MH    R3,=H'100'          AND AGAIN BY 10000\n         AR    R0,R3               HOURS,MINUTES,SECONDS IN BINARY\n         CVD   R0,DECM             CONVERT TO DECIMAL\n         L     R0,DECM+4           GET '0HHMMSSF'\n         SLL   R0,4                GET 'HHMMSSF0'\n        $EXIT  RC=0,KEEP=(R0,R1)   RETURN TO CALLER\n         SPACE\n         LTORG ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SYWTO": {"ttr": 12805, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x10\\x00\\x10\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*               'SYWTO' --- SYSTEM WRITE TO OPERATOR                  *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R0) CONTAINS DATA LENGTH\n*                  --  (R1) CONTAINS DATA ADDRESS\n         SPACE\nSYWTO   $ENTER ,\n         L     R15,=V(SYSINT)      SYSTEM DEPENDENT ROUTINE\n         BAL   R14,96(,R15)        DISPLAY THE DATA\n         SPACE\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\n         LTORG ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#TABCHK": {"ttr": 12807, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x1c\\x00\\x1c\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              TABCHK ---  ADJUST FOR POSSIBLE HYPHENATION            *\n*                                                                     *\n***********************************************************************\n         SPACE\nTABCHK  $ENTER ,\n         USING TBAREA,TABS\n         LTR   PNEW,PNEW           ANY MORE CHARS .Q\n         BZ    TABCHK1             BRANCH IF NOT\n         USING LNEWELEM,PNEW       TELL THE ASSEMBLER\n         CLI   LNEWCHAR,C' '       TAB FOLLOWED BY BLANK .Q\n         BE    TABCHK1             BRANCH IF YES\n         LH    R1,TBLEN            LENGTH OF FILL\n         C     R1,F1               FILL LENGTH = 1 .Q\n         BE    TABCHK1             BR IF YES\n         DROP  PNEW\n        $ON    SWITCHS,THSWS       TURN ON HYPHEN SWITCH\n         BCTR  TEMP,0              ADJUST FOR HYPHEN\n         LTR   TEMP,TEMP           ZERO FILL LENGTH .Q\n         BNZ   TABCHK1             BR IF NO\n        $CC    NEG                 INDICATE ADJUSTMENT\n         B     TABCHK2             RETURN\nTABCHK1  DS    0H\n        $CC    POS                 SUCCESS\nTABCHK2  DS    0H\n        $EXIT  KEEP=(TEMP),RC=0    RETURN TO CALLER\n         DROP  TABS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#TABFILL": {"ttr": 12809, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00k\\x00k\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 107, "newlines": 107, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              TABFILL---  SET UP FILL CHARACTERS                     *\n*                                                                     *\n***********************************************************************\n         SPACE\nTABFILL $ENTER ,\n         USING LINKELEM,P\n         USING TBAREA,TABS\n         LR    R0,COUNT            SAVE PTR TO CHAR AFTER TAB\n         LR    R14,R1              SAVE PTR TO FOPMLIST\n         SR    COUNT,COUNT         ASSUME NO NEW BLOCKS ADDED\n         USING FOPMLIST,R1\n        $IFOFF SWITCHS,TCSWS,TABF05     BRANCH IF NOT IN TC MODE\n         STH   COUNT,FOINDR        CLEAR RIGHT INDENT VALUE\nTABF05   DS    0H\n         DROP  R1\n         LTR   TABS,TABS           USER TABS DEFINED .Q\n         BZ    TABF60              BR IF NO\n         CLI   LINKMULT,X'01'      WAS TAB FILL LENGTH SET TO 1 .Q\n         BE    TABF10              BR IF YES\n         BH    TABF07              BR IF GREATER THAN 1\n         MVI   LINKMULT,X'01'      SET TO 1\n         B     TABF20              AND CONTINUE\nTABF07   DS    0H\n         LH    TEMP,TBLEN          LENGTH OF FILL STRING\n         C     TEMP,F1             LENGTH = 1 .Q\n         BNE   TABF30              BR IF NO\nTABF10   DS    0H\n        $IFOFF SWITCHS,THSWS,TABF20     ADJUSTED FOR HYPHEN .Q\n         MVI   LINKMULT,X'02'      CHANGE HYPHEN TO BLANK\nTABF20   DS    0H\n         MVC   LINKCHAR,TBFILL     MOVE IN FILL CHAR\n        $IFOFF SWITCHS,TCSWS,TABF60     ARE WE IN TC MODE .Q\n         MVI   LINKCHAR,C' '       YES -> BLANK INITIAL FILL CHAR\n         B     TABF60              SINGLE CHAR PROCESSED\nTABF30   DS    0H\n         LR    R1,C                SAVE CURRENT COLUMN\n         L     X1,BUFF3AD          FETCH ADDRESS OF BUFFER\n         LA    X1,4(,X1)           SKIP OVER RDW\n         LR    X2,TEMP             SAVE FILL LENGTH\n         AR    X2,X1               INDEX INTO BUFFER\n         BCTR  TEMP,0              SETUP FOR INITIAL MOVE\n         EX    TEMP,TBFMVE1        MOVE IN FILL STRING TO BUFFER\n         LA    COUNT,B2LG          LENGTH OF INPUT BUFFER\n         SR    COUNT,TEMP          MINUS FIELD ALREADY MOVED\n         BCTR  COUNT,0             ADJUST FOR MOVE\n         EX    COUNT,TBFMVE2       PROPOGATE FILL STRING\n         AR    R1,X1               POINT TO START OF ACTUAL FILL\n         MVC   LINKCHAR(1),0(R1)   SET 1ST CHAR TO REPLACE TAB\n        $IFOFF SWITCHS,TCSWS,TABF40     ARE WE IN TC MODE .Q\n         MVI   LINKCHAR,C' '       YES -> BLANK INITIAL FILL CHAR\nTABF40   DS    0H\n         LA    R1,1(,R1)           SKIP OVER 1ST CHAR\n         SR    COUNT,COUNT         CLEAR FOR EXECUTE\n         IC    COUNT,LINKMULT      SET LENGTH OF FILL MOVE\n        $IFON  SWITCHS,TCSWS,TABF42     BRANCH IF IN TC MODE\n        $IFON  SWITCHS,THSWS,TABF45     BRANCH IF TAB HYPHEN SWITCH\nTABF42   DS    0H\n         BCTR  COUNT,0             DECREMENT FOR MVC\nTABF45   DS    0H\n        $IFOFF SWITCHS,TCSWS,TABF50  BRANCH IF NOT IN TC MODE\n         LR    TEMP,R1             START OF FILL STRING\n         AR    TEMP,COUNT          POINT TO LAST CHAR\n         MVI   0(TEMP),C' '        BLANK IT\nTABF50   DS    0H\n         EX    COUNT,TBFMVE3       SET FILL STRING\n         MVI   LINKMULT,X'01'      CHANGE MULTIPLIER BACK TO 1\n         L     TEMP,BUFF3AD        FETCH ADDRESS OF BUFFER\n         LR    X1,R0               RESTORE PTR TO CHAR AFTER TAB\n         LR    R1,R14              RESTORE FOPMLIST PTR\n         USING FOPMLIST,R1         SET UP BASE\n         L     R0,FOLL             CURRENT LINE LENGTH\n         AH    R0,FOINDR           PLUS RIGHT INDENT LINE VALUE\n         CH    R0,TBVALUE          TAB EQUAL TO LINE LENGTH .Q\n         BNE   TABF55              BR IF NO\n         USING LNEWELEM,X1         SET UP BASE\n         CLI   LNEWCHAR,C' '       NEXT CHAR A BLANK .Q\n         BE    TABF55              BR IF YES\n         LA    COUNT,1(,COUNT)     BUMP LENGTH BY 1 DUE TO BCTR\nTABF55   DS    0H\n         ST    COUNT,0(TEMP)       UPDATE LENGTH OF FIELD\n         LA    TEMP,2(,TEMP)       POINT TO BUFFER START\n         LR    R0,TEMP             POINT AT STRING TO INSERT\n        $CALL  FOADD               ADD THE FILL STRING\n         L     POLD,WRKFLN         ADDRESS OF FILL(1) LINK\n         L     R15,WRKLLN          ADDRESS OF FILL(N) LINK\n         SPACE 1\n         MVC   LINKFOR-LINKELEM(4,R15),LINKFOR    FILL(N) -> B\n         ST    POLD,LINKFOR        A -> FILL(1)\n         SPACE\n         USING LOLDELEM,POLD       LOOK AT FILL(1) LINK\n         ST    P,LOLDBACK          A <- FILL(1)\n         LR    P,POLD              FILL(1) NOW END OF LINE\n         SPACE\n         L     POLD,LINKFOR-LINKELEM(R15)    ADDR OF B LINK\n         LTR   POLD,POLD           ANY CHARS FOLLOWING TAB .Q\n         BZ    TABF60              BRANCH IF NONE\n         ST    R15,LOLDBACK        FILL(N) <- B\n         DROP  POLD                BACK TO EXPECTED USAGE\n         SPACE 1\nTABF60   DS    0H\n        $EXIT  KEEP=(COUNT),RC=0\nTBFMVE1  MVC   0(*-*,X1),TBFILL\nTBFMVE2  MVC   0(*-*,X2),0(X1)\nTBFMVE3  MVC   0(*-*,X1),0(R1)\n         DROP  P,TABS,X1,R1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#TABIT": {"ttr": 12812, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x82\\x00\\x82\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 130, "newlines": 130, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              TABIT  ---  EXPAND USER'S TABS                         *\n*                                                                     *\n*                                                                     *\n*        REGISTER USAGE:                                              *\n*                                                                     *\n*        R1    POINTER TO FORMAT PARAMETER LIST                       *\n*        PNEW  POINTER TO LINKED CHARACTER BLOCK                      *\n*        TEMP  NEXT TABSTOP                                           *\n*        P     POINTER TO LINKED CHARACTER BLOCK                      *\n*        C     CURRENT COLUMN POINTER                                 *\n*        TABS  POINTER TO LINKED TAB BLOCKS                           *\n*                                                                     *\n*        ON EXIT  --  CC = BPOS   IF TAB FOUND                        *\n*                     CC = BNEG   IF NO TAB FOUND                     *\n*                                                                     *\n***********************************************************************\n         SPACE\nTABIT   $ENTER ,\n         USING FOPMLIST,R1\n         USING LINKELEM,P          CALLER PROVIDED CHAR POINTER\n        $OFF   SWITCHS,THSWS       CLEAR HYPHEN SWITCH\n         L     TABS,FOPTAB         GET ADDRESS OF POINTER\n         L     TABS,0(,TABS)       GET POINTER TO TAB TABLE\n         MVI   LINKCHAR,C' '       SET CHARACTER TO BLANK\n         LTR   TABS,TABS           USER TABS DEFINED .Q\n         BNZ   TAB20               BRANCH IF YES\nTAB10    DS    0H\n         LR    TEMP,C              COLUMN WE'RE AT\n         LA    COUNT,6(,TEMP)      BUMP BY FIVE PLUS ONE FOR TAB\n         SRDL  COUNT,32            PREPARE FOR DIVIDE\n         D     COUNT,F5            MOD FIVE\n         MH    TEMP,H5             THIS IS THE DEFAULT\n         B     TAB30               ENTER ROUTINE ALREADY IN PROGRESS\n         SPACE\nTAB20    DS    0H\n         USING TBAREA,TABS         USER TAB AREA\n         CH    C,TBVALUE           IS THIS APPROPRIATE TAB STOP .Q\n         BNL   TAB120              BRANCH IF NOT\n         LH    TEMP,TBVALUE        YES, GET LOC OF NEXT TABSTOP\nTAB30    DS    0H\n         SR    PNEW,PNEW           ASSUME NO NEXT CHAR\n        $IFON  FOSWTCH,NFSWS,TAB50 BRANCH IF IN NO FORMAT MODE\n         L     R0,FOLL             CURRENT LINE LENGTH\n        $IFON  SWITCHS,TCSWS,TAB40 USE REAL LINE LENGTH IF TC MODE\n         AH    R0,FOINDR           PLUS RIGHT INDENT VALUE\nTAB40    DS    0H\n         CR    TEMP,R0             TAB LESS THAN LINE LENGTH .Q\n         BL    TAB50               BRANCH IF YES\n         LR    TEMP,R0             ONLY TO LINE END THEN\nTAB50    DS    0H\n         LTR   TABS,TABS           USER TABS DEFINED .Q\n         BZ    TAB52               BRANCH IF NOT\n         L     PNEW,LINKFOR        LOOK AT NEXT CHAR\nTAB52    DS    0H\n         SR    TEMP,C              CALC NUMBER OF FILL CHAR TO ADD\n         BP    TAB60               BRANCH IF RESULT VALID\n         B     TAB110\nTAB60    DS    0H\n        $CALL  TABPCC              COUNT CHARS IN NEXT PHRASE\n         LTR   X2,X2               WAS PHRASE COUNT ZERO .Q\n         BZ    TAB70               BR IF YES\n         LTR   TABS,TABS           USER TABS DEFINED .Q\n         BZ    TAB70               BR IF NO\n         CLI   TBTYPE,TBLEFT       WAS LEFT MODE SPECIFIED .Q\n         BNE   TAB80               BR IF NO\nTAB70    DS    0H\n        $CALL  TABITL              CALL LEFT TAB ROUTINE\n         BC    BNEG,TAB120         UNABLE TO LEFT TAB - TRY NEXT TAB\n         B     TAB170\nTAB80    DS    0H\n         CLI   TBTYPE,TBRIGHT      WAS RIGHT MODE SPECIFIED .Q\n         BNE   TAB90               BR IF NO\n        $CALL  TABITR              CALL RIGHT TAB ROUTINE\n         BC    BNEG,TAB120         UNABLE TO TAB RIGHT - TRY NEXT TAB\n         B     TAB170\nTAB90    DS    0H\n         CLI   TBTYPE,TBCENTRE     WAS CENTRE MODE SPECIFIED .Q\n         BNE   TAB100              BR IF NO\n        $CALL  TABITC              CALL CENTRE TAB ROUTINE\n         BC    BNEG,TAB120         UNABLE TO CENTRE TEXT - TRY NEXT TAB\n         B     TAB170              RETURN\nTAB100   DS    0H\n         CLI   TBTYPE,TBOK         WAS ALIGN MODE SPECIFIED .Q\n         BNE   TAB110              BR IF NO\n        $CALL  TABITA              CALL ALIGN TAB ROUTINE\n         BC    BNEG,TAB120         UNABLE TO ALIGN - TRY NEXT TAB\n         B     TAB170\nTAB110   DS    0H\n         MVI   LINKMULT,X'01'      SET MULTIPLIER FIELD TO 1\n         B     TAB170              AND RETURN\nTAB120   DS    0H\n        $IFOFF SWITCHS,TCSWS,TAB150  BR IF NOT IN TC MODE\n         LTR   TABS,TABS           USER TABS DEFINED .Q\n         BZ    TAB122              BRANCH IF NOT\n         OC    TBCHN,TBCHN         MORE TABS DEFINED .Q\n         BNZ   TAB150              BRANCH IF YES\nTAB122   DS    0H\n         MVI   LINKCHAR,X'05'      RESET TAB CHAR\n         L     TEMP,LINKBACK       PTR TO BACKWARD LINK\n         USING LOLDELEM,TEMP       TELL ASSEMBLER\nTAB130   DS    0H\n         CLI   LOLDCHAR,C' '       DID WE FIND A BLANK .Q\n         BE    TAB140              EXIT IF YES\n         L     TEMP,LOLDBACK       BACKUP AGAIN\n         B     TAB130              LOOP\nTAB140   DS    0H\n         L     TABS,LOLDFOR        LINK FORWARD\n        $ON    SWITCHS,THSWS       TURN ON TAB HYPHEN SW FOR MERGE\n         B     TAB160              RETURN TO MERGE\nTAB150   DS    0H\n         LTR   TABS,TABS           USER TABS DEFINED .Q\n         BZ    TAB10               BR IF NO\n         L     TABS,TBCHN          NEXT USER TAB\n         LTR   TABS,TABS           DOES IT EXIST .Q\n         BNZ   TAB20               BRANCH IF YES\nTAB160   DS    0H\n        $CC    NEG                 INDICATE JOB NOT DONE\n         B     TAB180              NO TAB FOUND\n         SPACE\nTAB170   DS    0H\n        $CALL  TABFILL             SET FILL CHARACTER(S)\n         L     TEMP,NEWCOUNT       OBTAIN CURRENT CHAR COUNT\n         AR    TEMP,COUNT          ADD LENGTH OF FILL\n         ST    TEMP,NEWCOUNT       SAVE NEW LENGTH BACK\n        $CC    POS                 INDICATE THE JOB WAS DONE\nTAB180   DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         DROP  R1,P,TABS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#TABITA": {"ttr": 12815, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00(\\x00(\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              TABITA ---  ALIGN PHRASE ON TAB ALIGNMENT CHARACTER    *\n*                                                                     *\n***********************************************************************\n         SPACE\nTABITA  $ENTER ,\n         USING LINKELEM,P\n         USING TBAREA,TABS\n         LR    R0,X1               SAVE CURRENT PTR\n         L     X1,LINKFOR          POINT TO NEXT CHAR BLOCK\n         USING LNEWELEM,X1         INFORM ASSEMBLER\n         LR    R1,TEMP             GET INTER TAB COUNT\n         LA    X2,1                INITIALIZE CHAR COUNT\nTBA1     DS    0H\n         CLC   LNEWCHAR,TBCHAR     FOUND ALIGNMENT CHAR .Q\n         BE    TBA2                BR IF YES\n         CLI   LNEWCHAR,X'05'      DID WE HIT NEXT TAB .Q\n         BE    TBA15               EXIT IF YES\n         LA    X2,1(,X2)           BUMP CHAR COUNT\n         L     X1,LNEWFOR          CHAIN TO NEXT BLOCK\n         LTR   X1,X1               ANY MORE CHARS .Q\n         BZ    TBA15               EXIT IF NO\n         BCT   R1,TBA1             LOOP TILL TAB COLUMN\nTBA15    DS    0H\n         LR    C,R0                RETURN PTR IN C\n        $CC    NEG                 INDICATE NO ALIGNMENT\n         B     TBA4                RETURN\nTBA2     DS    0H\n         LR    X1,R0               RESTOR START PTR\n        $CALL  TABCHK              ADJUST FOR HYPHEN\n         SR    TEMP,X2             CALC NUMBER OF FILL CHAR\n         BP    TBA3                BR IF POSITIVE\n         LA    TEMP,1              ELSE SET TO 1\nTBA3     DS    0H\n         STC   TEMP,LINKMULT       UPDATE MULTIPLIER FIELD\n        $CC    POS                 INDICATE ALIGNMENT OK\nTBA4     DS    0H\n        $EXIT  KEEP=(C),RC=0\n         DROP  P,X1,TABS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#TABITC": {"ttr": 12817, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              TABITC ---  CENTRE TEXT ON USER'S TAB                  *\n*                                                                     *\n***********************************************************************\n         SPACE\nTABITC  $ENTER ,\n         USING LINKELEM,P\n         SRL   X2,1                HALVE PHRASE CHAR COUNT\n         BCTR  TEMP,0              TEMP GETS MAX # OF FILL CHAR\n         CR    X2,TEMP             WILL CENTRED PHRASE FIT .Q\n         BNL   TBC1                BR IF NO\n         SR    TEMP,X2             CALC # OF FILL CHARS REQ'D\n         B     TBC2                SAVE LENGTH\nTBC1     DS    0H\n         LA    TEMP,1              SET FILL LENGTH TO 1\n        $CC    NEG                 INDICATE FAILURE\n         B     TBC3\nTBC2     DS    0H\n        $CALL  TABCHK              ADJUST FOR HYPHEN\n         BC    BNEG,TBC1           SET ZERO FILL TO 1\n         STC   TEMP,LINKMULT       SAVE LENGTH OF FILL STRING\n        $CC    POS                 INDICATE SUCCESS\nTBC3     DS    0H\n        $EXIT  RC=0                RETURN\n         DROP  P\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#TABITL": {"ttr": 12819, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x15\\x00\\x15\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              TABITL ---  LEFT JUSTIFY TEXT ON USER'S TAB            *\n*                                                                     *\n***********************************************************************\n         SPACE\nTABITL  $ENTER ,\n         USING LINKELEM,P\n         BCTR  TEMP,0              DECREMENT FILL COUNT BY 1\n        $CALL  TABCHK              ADJUST FOR HYPHEN\n         LTR   TEMP,TEMP           CAN WE TAB LEFT .Q\n         BZ    TBL1                BR IF NO\n         STC   TEMP,LINKMULT       SAVE IN MULTIPLIER FIELD\n        $CC    POS                 INDICATE SUCCESS\n         B     TBL2\nTBL1     DS    0H\n         MVI   LINKMULT,X'01'      SET TAB TO 1 BLANK\n        $CC    NEG                 INDICATE FAILURE\nTBL2     DS    0H\n        $EXIT  RC=0                RETURN\n         DROP  P\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#TABITR": {"ttr": 12821, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x17\\x00\\x17\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              TABITR ---  RIGHT JUSTIFY TEXT ON USER'S TAB           *\n*                                                                     *\n***********************************************************************\n         SPACE\nTABITR  $ENTER ,\n         USING LINKELEM,P\n         SR    TEMP,X2             SUBTRACT PHRASE CHAR COUNT\n*                                  FROM LENGTH OF USER FILL\n         BP    TBR1                BR IF POSITIVE LENGTH\nTBR0     DS    0H\n         MVI   LINKMULT,X'01'      AND LENGTH TO 1\n        $CC    NEG                 INDICATE FAILURE\n         B     TBR2\nTBR1     DS    0H\n        $CALL  TABCHK              CHECK FOR GOOD FIT\n         BC    BNEG,TBR0           SET ZERO FILL TO 1\n         STC   TEMP,LINKMULT       SAVE IN MULTIPLIER FIELD\n        $CC    POS                 INDICATE SUCCESS\nTBR2     DS    0H\n        $EXIT  RC=0                RETURN\n         DROP  P\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#TABPCC": {"ttr": 12823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x18\\x00\\x18\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              TABPCC ---  COUNT # OF CHARACTERS IN PHRASE            *\n*                                                                     *\n***********************************************************************\n         SPACE\n         SPACE\nTABPCC   $ENTER\n         USING LINKELEM,P\n         SR    X2,X2               ZERO PHRASE CHAR COUNT\n         LR    X1,P                SET UP PTR TO CHAR BLOCKS\n         L     X1,LINKFOR          START AFTER TAB CHAR\n         USING LNEWELEM,X1         INFORM ASSEMBLER\nTABPC1   DS    0H\n         LTR   X1,X1               END OF BLOCK .Q\n         BZ    TABPC2              BRANCH IF YES\n         CLI   LNEWCHAR,X'05'      TAB CHAR FOUND .Q\n         BE    TABPC2              BRANCH IF YES\n         LA    X2,1(,X2)           BUMP CHAR COUNT\n         L     X1,LNEWFOR          CHAIN TO NEXT BLOCK\n         B     TABPC1              CONTINUE UNTIL END OF PHRASE\nTABPC2   DS    0H\n         $EXIT   KEEP=(X2),RC=0    RETURN CHAR COUNT IN PHRASE\n         DROP  P,X1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#TB": {"ttr": 13057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\xc4\\x00\\xc4\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 196, "newlines": 196, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .TB (TABS) --- CONTROL                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        .TB COMMAND FORMAT\n*\n*        .TB OP1 <OP2 ... >>\n*\n*        WHERE OP1 IS: T1 | SET <CHAR> | C1/T1<MODE> | <STRING>T1<MODE>\n*\n*        WHERE  <STRING> IS:  'STRING' | \"STRING\" | /STRING/\n*\n*        AND    <MODE>   IS:  LEFT | RIGHT| CENTRE | 'CHAR'\n*\n         SPACE\n*        REGISTER USAGE:\n*\n*              TEMP:  LENGTH OF FILL STRING\n*              COUNT: ADDRESS OF FILL STRING\n*              X1:    BASE REGISTER USED TO ADDRESS TAB BUFFER\n*              X3:    CURRENT TAB VALUE\n         SPACE\nTB      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION\n         USING TBAREA,X1           SET UP X1 FOR PERMANENT USING\n        $CALL  GETARG              GET CHARACTER ARGUMENT\n         BC    15-BOMIT,TB10       BRANCH IF ARGUMENT FOUND\n         LA    R1,TBANCHR          PTR TO CURRENT USER TAB ANCHOR\n        $CALL  TBFREBLK            ELSE FREE ALLOCATED TAB FIELDS\n         B     TB120               THEN RETURN\nTB10     DS    0H\n         SR    X3,X3               X3 CONTAINS CURRENT TAB VALUE\n         ST    COUNT,ARGSTART      RESET SCAN PTR TO FIRST .TB OPERAND\nTB20     DS    0H                  LOOP FOR .TB OPERANDS\n        $CALL  GETYESNO            SCAN OFF FIRST ARGUMENT\n         BC    BOMIT,TB120         RETURN IF NO MORE\n         CLI   YNRESULT,YNSET      WAS OPERAND 'SET' .Q\n         BNE   TB40                BRANCH IF NO\n         SPACE\n*                                  .TB SET <CHAR>\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION\n        $CALL  GETARG              GET CHARACTER ARGUMENT\n         BC    BOMIT,TB30          BRANCH TO RESET DEFAULT IF OMITTED\n         LTR   TEMP,TEMP           LENGTH-1 OF ARG ZERO .Q\n         BNZ   TBE02               ERROR IF NOT\n         MVC   TBIND(1),0(COUNT)   ENTER EXTRA USER TAB CHAR\n         B     TB20                AND RESUME SCANNING\nTB30     DS    0H\n         MVC   TBIND(1),TBIND+1    RESET TO INITIAL VALUE\n         B     TB120               GO TO RETURN\n         SPACE\nTB40     DS    0H                  CHECK FOR STRING ARGUMENT\n         ST    COUNT,ARGSTART      SAVE PTR FOR RESCANNING\n         CLI   0(COUNT),C''''      1ST CHAR = SINGLE QUOTE .Q\n         BE    TB60                BRANCH IF YES\n         CLI   0(COUNT),C'\"'       1ST CHAR = DOUBLE QUOTE .Q\n         BE    TB60                BRANCH IF YES\n         CLI   1(COUNT),C'/'       2ND CHAR = SLASH .Q\n         BNE   TB50                BRANCH IF NO\n         SPACE\n*                                  .TB C1/T1\n         LA    TEMP,1              SET LENGTH OF FILL CHAR\n         BAL   RETURN,TBGETBLK     GET TAB AREA AND CHAIN IT\n         BC    BNEG,TBE06          ERROR IF NO CORE\n         BAL   RETURN,TBMFILL      SET FILL CHAR AND LENGTH\n         LA    COUNT,2(,COUNT)     POINT TO T1 FIELD\n         ST    COUNT,ARGSTART      SAVE PTR TO RESUME SCANNING\n         B     TB80                NOW PROCESS T1 FIELD\nTB50     DS    0H\n         CLI   0(COUNT),C'/'       FIRST CHAR = SLASH .Q\n         BNE   TB70                BRANCH IF NO\n         SPACE\nTB60     DS    0H                  .TB <STRING>T1\n         LR    TEMP,COUNT          START OF STRING\nTB62     DS    0H\n         LA    TEMP,1(,TEMP)       NEXT CHARACTER\n         C     TEMP,ARGSTOP        PAST THE END OF OPERANDS .Q\n         BH    TBE05               ERROR IF YES\n         CLC   0(1,TEMP),0(COUNT)  SAME DELIMITER CHARACTER .Q\n         BNE   TB62                BRANCH IF NOT\n         LA    R1,1(,TEMP)         NEXT CHAR TO SCAN\n         ST    R1,ARGSTART         SET SCANNING ADDRESS\n         LA    COUNT,1(,COUNT)     POINT TO ARGUMENT\n         SR    TEMP,COUNT          LENGTH OF STRING\n         BNP   TBE01               ERROR IF NOTHING THERE\n         BAL   RETURN,TBGETBLK     GET SPACE FOR RESULT\n         BC    BNEG,TBE06          BRANCH IF NO SPACE\n         BAL   RETURN,TBMFILL      SET FILL CHAR AND LENGTH\n         B     TB80                PROCESS T1 FIELD\n         SPACE\nTB70     DS    0H                  .TB T1\n         ST    COUNT,ARGSTART      SAVE PTR TO T1 FIELD\n         LA    TEMP,1              DEFAULT LENGTH OF FILL = 1\n         BAL   RETURN,TBGETBLK     OBTAIN CORE FOR TBAREA\n         BC    BNEG,TBE06          ERROR IF NO CORE\n         LA    COUNT,BLANKS        DEFAULT FILL IS BLANK\n         BAL   RETURN,TBMFILL      SET FILL CHAR AND LENGTH\nTB80     DS    0H\n         BAL   RETURN,TBGETMON     GET T1 FIELD AND ENSURE MONOTONIC\n         BC    BDNO,TB90           BRANCH IF NOT NUMERIC\n         BC    BOMIT,TBE01         ISSUE ERROR IF OMITTED\n         BC    BNEG,TB120          ERROR ALREADY SET, NOW RETURN\n         A     X3,DEFTABL+TAB3DEF  ADJUST FOR LEFT TABS\n         STH   X3,TBVALUE          SET VALUE FOR T1 FIELD\n         L     COUNT,ARGSTART      RESTORE CURRENT PTR\n         B     TB20                RESUME SCAN OF ARGUMENTS\nTB90     DS    0H\n         L     TEMP,ARGSTOP        SET STOP ADDRESS IN TEMP\n         L     R1,ARGSTART         OBTAIN CURRENT STARTING PTR\n         BCTR  R1,0                BACKUP BY ONE\n         ST    R1,ARGSTOP          SET NEW STOP PTR\n         ST    COUNT,ARGSTART      RESET STARTING PTR\n         BAL   RETURN,TBGETMON     SECOND TRY TO GET T1 OPERAND\n         BC    BDNO,TBE02          ERROR IF T1 NOT NUMERIC\n         BC    BOMIT,TBE01         ISSUE ERROR IF OMITTED\n         BC    BNEG,TB120          ERROR ALREADY SET, NOW RETURN\n         STH   X3,TBVALUE          SAVE VALUE OF T1 FIELD\n         ST    TEMP,ARGSTOP        RESTORE ORIGINAL STOP PTR\n        $CALL  GETYESNO            CHECK FOR LEFT,RIGHT, OR CENTRE\n         BC    BOMIT,TB120         THAT'S ALL FOLKS\n         CLI   YNRESULT,YNLEFT     WAS LEFT SPECIFIED .Q\n         BNE   TB95                BRANCH IF NOT\n         A     X3,DEFTABL+TAB3DEF  ADJUST FOR LEFT TABS\n         STH   X3,TBVALUE          RESET TAB\n         B     TB20                AND CONTINUE\nTB95     DS    0H\n         CLI   YNRESULT,YNRGHT     WAS RIGHT SPECIFIED .Q\n         BNE   TB100               BRANCH IF NO\n         LA    R1,TBRIGHT          INDICATE RIGHT SPECIFIED\n         STC   R1,TBTYPE           SAVE FLAG IN TYPE FIELD\n         B     TB20                CONTINUE SCANNING\nTB100    DS    0H\n         CLI   YNRESULT,YNCNTR     WAS CENTRE SPECIFIED .Q\n         BE    TB105               BRANCH IF YES\n         CLI   YNRESULT,YNCND      WAS COND SPECIFIED .Q\n         BNE   TB110               BRANCH IF NO\nTB105    DS    0H\n         LA    R1,TBCENTRE         INDICATE CENTRE SPECIFIED\n         STC   R1,TBTYPE           SAVE FLAG IN TYPE FIELD\n         B     TB20                RESUME SCANNING\nTB110    DS    0H\n         CLI   0(COUNT),C''''      WAS SINGLE QUOTE FOUND .Q\n         BNE   TBE02               ERROR IF NO\n         CLI   2(COUNT),C''''      WAS 3RD CHAR A QUOTE .Q\n         BNE   TBE05               ERROR IF NO\n         LA    R1,TBOK             INDICATE ALIGN CHAR FOUND\n         STC   R1,TBTYPE           SAVE FLAG IN TYPE FIELD\n         MVC   TBCHAR(1),1(COUNT)  MOVE IN ALIGNMENT CHARACTER\n         CLC   1(3,COUNT),0(COUNT) WAS '''' SPECIFIED .Q\n         BNE   TB115               BRANCH IF NO\n         LA    COUNT,1(,COUNT)     SKIP OVER FIRST QUOTE\nTB115    DS    0H\n         LA    COUNT,2(,COUNT)     BUMP PTR OVER NEXT 2 QUOTES\n         ST    COUNT,ARGSTART      NOW POINTING TO LAST QUOTE\n        $CALL  GETARG              GET NEXT ARGUMENT\n         LTR   TEMP,TEMP           WAS LENGTH-1 ZERO .Q\n         BZ    TB20                CONTINUE SCANNING IF YES\n         B     TBE02               ELSE ISSUE ERROR\nTBE01    DS    0H\n         MVI   EFLAG003,ERRSET     OMITTED CONTROL WORD PARM\n         B     TB120               RETURN TO MAIN CONTROLLER\nTBE02    DS    0H\n         MVI   EFLAG005,ERRSET     ILLEGAL CONTROL WORD PARM\n         B     TB120               RETURN TO MAIN CONTROLLER\nTBE05    DS    0H\n         MVI   EFLAG015,ERRSET     MISMATCHED DELIMITER\n         B     TB120               RETURN TO MAIN CONTROLLER\nTBE06    DS    0H\n         MVI   EFLAG024,ERRSET     WORKING STORAGE EXHAUSTED\n         B     TB120               RETURN TO MAIN CONTROLLER\nTBE07    DS    0H\n         MVI   EFLAG035,ERRSET     ARGUMENT NOT NUMERIC\n         B     TB120               RETURN TO MAIN CONTROLLER\n         SPACE\nTBMFILL  DS    0H\n         STH   TEMP,TBLEN          SAVE LENGTH OF FILL CHAR\n         BCTR  TEMP,0              DECREMENT LENGTH BY 1\n         EX    TEMP,TBMVE          MOVE IN FILL STRING\n         BR    RETURN              RETURN TO CALLER\nTBMVE    MVC   TBFILL(*-*),0(COUNT) MOVE IN STRING\n         SPACE\nTB120    DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\n         DROP  X1\n         EJECT\n         COPY  #TBGBLK\n         EJECT\n         COPY  #TBGMON\n         EJECT\n         COPY  #TBCBLK\n         EJECT\n         COPY  #TBFBLK\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#TBCBLK": {"ttr": 13061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x000\\x000\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL ROUTINE 'TBCOPY'  -- COPY A TAB BUFFER        *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        COPIES TAB STRING BLOCK POINTED TO BY TBANCHR FIELD\n         SPACE\n*        ON EXIT  -  R1     ADDRESS OF NEW TBANCHR FIELD\n*                 -  IF ORIGINAL VALUE OF TBANCHR WAS\n*                    ZERO THEN R1 IS SET TO 0\n         SPACE\n*        CC=BPOS     TAB BUFFER COPIED SUCCESSFULLY\n*        CC=BNEG     UNABLE TO COPY TAB BUFFER\n         SPACE\nTBCOPY   $ENTER\n         SR    X3,X3               INITIALIZE RETURNED NEW ANCHOR\n         L     X1,TBANCHR          POINT TO BUFFER ANCHOR\n         LTR   X1,X1               HAS ANCHOR BEEN USED .Q\n         BZ    TBC04               BRANCH IF NO\n         USING TBAREA,X1           INFORM ASSEMBLER\nTBC01    DS    0H\n         LA    R1,TBLKSZE          LENGTH OF TAB BUFFER\n         AH    R1,TBLEN            PLUS LENGTH OF FILL STRING\n        $CALL  GETCELL             PASS LENGTH OF BLOCK REQ'D\n         BC    BNEG,TBC05          ERROR IF NO CORE\n         BCTR  R1,0                LENGTH-1 OF DATA\n         EX    R1,TBCMVC           MOVE TAB ELEMENT\n         XC    TBCHN-TBAREA(L'TBCHN,TEMP),TBCHN-TBAREA(TEMP)  CLEAR PTR\n         LTR   X3,X3               FIRST ELEMENT .Q\n         BNZ   TBC02               BRANCH IF NOT\n         LA    X3,TBCHN-TBAREA(,TEMP)  REMEMBER FIRST POINTER\n         B     TBC03               AND CONTINUE\nTBC02    DS    0H\n         ST    TEMP,TBCHN-TBAREA(,X2)   SET NEXT AREA POINTER\nTBC03    DS    0H\n         LA    X2,TBCHN-TBAREA(,TEMP)   KEEP LAG POINTER\n         L     X1,TBCHN            CHAIN TO NEXT BUFFER\n         LTR   X1,X1               ARE WE AT END OF CHAIN .Q\n         BNZ   TBC01               BR IF NO\nTBC04    DS    0H\n        $CC    POS                 INDICATE SUCCESS\nTBC05    DS    0H\n         LR    R1,X3               RETURN VALUE OF ANCHOR OR ZERO\n        $EXIT  KEEP=(R1),RC=0      RETURN WITH PTR TO ANCHOR FIELD\n         SPACE\nTBCMVC   MVC   0(*-*,TEMP),TBAREA  DUPLICATE TAB DATA\n         DROP  X1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#TBFBLK": {"ttr": 13063, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*        INTERNAL ROUTINE 'TBFREBLK' -- FREE ALL TAB BUFFERS          *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  (R1) POINTS TO TAB ANCHOR\n*\n*        ON EXIT   --  TAB ANCHOR CLEARED\n         SPACE\nTBFREBLK $ENTER\n         L     X1,0(,R1)           SAVE ANCHOR VALUE\n         XC    0(L'TBANCHR,R1),0(R1)    CLEAR ANCHOR FOR CALLER\nTBF1     DS    0H\n         LTR   X1,X1               CHECK IF NEXT TAB SET .Q\n         BZ    TBF2                RETURN IF NO\n         USING TBAREA,X1           INFORM ASSEMBLER\n         LA    R0,TBAREA           POINT TO AREA TO FREE\n         LA    R1,TBLKSZE          GET LENGTH OF TAB BUFFER\n         AH    R1,TBLEN            PLUS LENGTH OF FILL CHARACTER\n         L     X1,TBCHN            GET NEXT PTR\n        $CALL  FREECELL            FREE CURRENT TAB BUFFER\n         B     TBF1                GO AROUND AGAIN\n         DROP  X1\n         SPACE\nTBF2     DS    0H\n        $EXIT  RC=0                RESTORE CALLER'S REGISTERS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#TBGBLK": {"ttr": 13065, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00&\\x00&\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              INTERNAL ROUTINE 'TBGETBLK' -- GET A TAB BUFFER        *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY -  TEMP   LENGTH OF FILL CHARACTER\n*                    X3     CURRENT TAB COLUMN\n         SPACE\n*        ON EXIT  -  X1     POINTER TO TAB BUFFER\n*                 -  IF FIRST CALL TBANCHR FILLED IN\n*                    OTHERWISE TBCHN VALUE SET\n         SPACE\n*        CC=BPOS     TAB BUFFER OBTAINED AND INITIALIZED\n*        CC=BNEG     UNABLE TO OBTAIN TAB BUFFER\n         SPACE\nTBGETBLK $SAVE\n         USING TBAREA,X1           CALLER PROVIDED\n         LA    X2,TBCHN            POINT TO CHAIN FIELD IN BUFFER\n         LTR   X3,X3               IS THIS 1ST OPERAND OF .TB .Q\n         BNZ   TBG01               BR IF NO\n         LA    R1,TBANCHR          PTR TO CURRENT USER TAB ANCHOR\n        $CALL  TBFREBLK            FREE ALL TAB BUFFERS\n         LA    X2,TBANCHR          POINT TO BUFFER ANCHOR\nTBG01    DS    0H\n         LA    R1,TBLKSZE(TEMP)    GET LENGTH OF TAB BUFFER\n        $CALL  GETCELL             GET CORE FOR BUFFER\n         BC    BNEG,TBG03          ERROR IF NOT AVAILABLE\n         LR    X1,TEMP             X1 NOW POINTS TO TAB BUFFER\n         XC    TBAREA(TBLKSZE),TBAREA   ZERO OUT TAB BUFFER PREFIX\nTBG02    DS    0H\n         ST    TEMP,0(X2)          LINK CURRENT BUFFER TO CHAIN\n        $CC    POS                 SET POSITIVE CONDITION CODE\nTBG03    DS    0H\n        $RESTOR KEEP=(X1)          RESTORE REGISTERS EXCEPT X1\n         BR    RETURN              RETURN TO CALLER\n         SPACE\n         DROP  X1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#TBGMON": {"ttr": 13067, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x003\\x003\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n* INTERNAL ROUTINE 'TBGETMON' -- GET A NUMBER (T1 FIELD)              *\n*                        --   VERIFY SEQUENCE INCREASES MONOTONICALLY *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY -  X1     BASE REGISTER FOR TAB BUFFER\n         SPACE\n*        ON EXIT  -  X3     NEW TAB VALUE (CURRENT T1 FIELD\n         SPACE\n*        CC=BPOS     SUCCESSFUL COMPLETION\n*        CC=BNEG     TAB VALUE TOO BIG OR SMALL\n*                    (ERROR FLAG SET IN THIS ROUTINE)\n*        CC=BOMIT    ARGUMENT OMITTED\n*        CC=BDNO     ARGUMENT NOT NUMERIC\n*                    (COUNT) = START ADDR OF ERROR\n         SPACE\nTBGETMON $SAVE\n         USING TBAREA,X1           INFORM ASSEMBLER\n        $CALL  GETNUM              GET NUMERIC ARGUMENT\n         BC    BOMIT,TBM2          ERROR IF OMITTED\n         BC    BDNO,TBM2           ERROR IF NOT NUMERIC\n         LR    X2,X3               GET PREVIOUS TAB VALUE\n         CLI   NUMSIGN,C' '        WAS A SIGN SPECIFIED .Q\n         BNE   TBM1                BRANCH IF YES\n         SR    X2,X2               CLEAR BASE TAB VALUE\nTBM1     DS    0H                  RELATIVE OR ABSOLUTE TABS\n*                                  ARE PROCESSED THE SAME\n         AR    COUNT,X2            ADD BASE TAB VALUE\n         C     COUNT,DEFLL+TAB3MAX IS T1 GREATER THAN MAX .LL .Q\n         BH    TBME01              ERROR IF YES\n         CR    COUNT,X3            IS T1 > PREVIOUS T1 FIELD .Q\n         BNH   TBME02              ERROR IF NOT\n        $CC    POS                 SET POSITIVE COND CODE\n         LR    X3,COUNT            CURRENT T1 VALUE\nTBM2     DS    0H                  RETURN TO CALLER\n        $RESTOR KEEP=(COUNT,X3)    SAVE T1 VALUE AND PTR TO NUMBER\n         BR    RETURN              AND RETURN\n         SPACE\n         DROP  X1\n         SPACE\nTBME01   DS    0H\n         MVI   EFLAG013,ERRSET     NUMERIC ARGUMENT TOO BIG\n         B     TBME99              SET CONDITION CODE\nTBME02   DS    0H\n         MVI   EFLAG014,ERRSET     NUMERIC ARGUMENT TOO SMALL\n         B     TBME99              SET CONDITION CODE\nTBME99   DS    0H\n        $CC    NEG                 ERROR RETURN\n         B     TBM2                AND GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#TC": {"ttr": 13069, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\xbf\\x00\\xbf\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 191, "newlines": 191, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .TC (TABLE OF CONTENTS) --- CONTROL                    *\n*                                                                     *\n***********************************************************************\n         SPACE\nTC      $ENTER ,\n        $CALL  PRINTNB             CLEAR ANY PRINT DATA\n        $CALL  GETYESNO            GET AND TEST FIRST OPERAND\n         BC    BPOS,TC07           BRANCH IF POSITIVE\n         BC    BNEG,TC10           BRANCH IF NEGATIVE\n         CLI   YNRESULT,YNDEL      WAS OPERAND 'DELETE' .Q\n         BE    TC13                BRANCH IF YES\n         CLI   YNRESULT,YNADD      WAS OPERAND 'ADD' .Q\n         BE    TC14                BRANCH IF YES\n         CLI   YNRESULT,YNASTK     WAS OPERAND '*' .Q\n         BE    TC01                BRANCH IF YES\n         SPACE\n         ST    COUNT,ARGSTART      RESCAN FOR NUMERIC\n        $CALL  GETNUM              GET NUMERIC ARGUMENT\n         BC    BDNO,TCE005         ERROR IF INVALID\n         BC    15-BOMIT,TC02       BRANCH IF NOT OMITTED\nTC01     DS    0H\n         LA    COUNT,1             ONE PAGE BY DEFAULT\nTC02     DS    0H\n         L     X1,DHNUMTC          TABLE OF CONTENTS NUMBER\n         SLL   X1,2                TIMES FOUR\n         L     X1,DHANCH(X1)       CURRENT HEADER DESCRIPTOR\n         LTR   X1,X1               PRESENT .Q\n         BZ    TCE012              HOW DID WE EVER GET HERE .Q\n         LA    X1,DHDLEN(,X1)      ITEM NUMBER ONE\n         USING DHDSECT,X1          HEAD DESCRIPTOR LIKE THIS\n        $IFON  SWITCHS,FEMPTY,TC03 BRANCH IF PAGE EMPTY\n        $IFOFF DHFLAGS,DHPA,TC03   BRANCH IF LEVEL ONE DOESN'T EJECT\n        $CALL  PAGEREAL            START AT TOP OF PAGE\nTC03     DS    0H\n         A     COUNT,PACNTI        ADD CURRENT PAGE NUMBER\n         BNP   TCE014              BRANCH IF TOO SMALL\n         CLI   YNRESULT,YNASTK     WAS FIRST OPERAND '*' .Q\n         BNE   TC04                BRANCH IF NOT\n         SR    COUNT,COUNT         ZERO PAGE NUMBER (NORMALLY INVALID)\nTC04     DS    0H\n         ST    COUNT,TCPAGE        THAT IS WHERE WE WILL BE\n         SPACE\n         L     R1,BUFF3AD          WORKING BUFFER\n         LA    R1,4(,R1)           BUMP OVER RDW\n         MVC   0(L'TCON,R1),TCON   THIS WILL GET US GOING\n         MVC   0(1,R1),PERIND      MAKE IT A CONTROL WORD\n         LA    TEMP,L'TCON-1       LENGTH-1\n        $CALL  HIDBADD             STACK SAME LIFO\n         SPACE\n        $CALL  USARG               ISOLATE OPERAND LINE\n         BC    BOMIT,TC05          BRANCH IF NONE\n         LH    COUNT,BUFF2LGZ      LENGTH OF OPERAND\n         LA    TEMP,BUFF2          POINT TO SAME\n         B     TC06                CONTINUE\nTC05     DS    0H\n         LA    COUNT,L'TCCONTS     DEFAULT LENGTH\n         LA    TEMP,TCCONTS        DEFAULT STRING\nTC06     DS    0H\n         L     R1,BUFF3AD          WORKING BUFFER\n         LA    R1,4(,R1)           BUMP OVER RDW\n         BCTR  COUNT,0             LENGTH-1 OF TITLE\n         EX    COUNT,TCCMVC1       MOVE TITLE\n         MVC   BUFF2,BLANKS        CLEAR INPUT BUFFER\n        $MVC   BUFF2,TCHL1         DUMMY HEAD LEVEL\n         MVC   BUFF2(1),PERIND     CONTROL WORD INDICATOR\n         EX    COUNT,TCCMVC2       MOVE TITLE BACK\n         LA    COUNT,L'TCHL1+1(,COUNT)  RESULT LENGTH\n         STH   COUNT,BUFF2LGZ      SET LENGTH IN INPUT BUFFER\n        $CALL  ARGINIT             INITIALIZE FOR SCAN\n         SPACE\n         MVC   TCDHSAVE,DHDSECT    SAVE ALL\n        $OFF   DHFLAGS,(DHTO,DHTC,DHPA) I'LL DO IT MY WAY\n        $CALL  HL                  PRINT TITLE\n        $MVC   DHDSECT,TCDHSAVE    RESTORE HEADER DESCRIPTOR\n         DROP  X1\n         B     TC17                RETURN TO PROCESS HEAD LEVEL\n         SPACE\nTC07     DS    0H\n        $IFON  SWITCHS,TCSWS,TCE012     TEST INVALID PLACEMENT\n         L     R1,BUFF3AD          WORKING BUFFER\n         LA    R1,4(,R1)           SKIP THE RDW\n         MVC   0(L'TCOFF,R1),TCOFF THIS TERMINATES .TC\n         MVC   0(1,R1),PERIND      CONTROL WORD INDICITOR\n         LA    TEMP,L'TCOFF-1      LENGTH-1 OF DATA\n         LNR   R1,R1               ENTER 'FIFO'\n         SPACE\n         L     X3,DHNUMTC          TABLE OF CONTENTS NUMBER\n         SLL   X3,2                TIMES FOUR\n         LA    X2,TCANCH(X3)       .TC LINE ANCHOR\n         L     X1,HIDBANCH         RETAIN HIDDEN BUFFERS\n         MVC   HIDBANCH,0(X2)      ENTER CONTENTS LINES INSTEAD\n         XC    0(L'TCANCH,X2),0(X2)     CLEAR CONTENTS ANCHOR\n        $CALL  HIDBADD             ENTER CONTENTS TERMINATOR\n         SPACE\n         LA    X3,HIDBANCH+HIDBCHN-HIDB START OF HIDDEN CHAIN\n         USING HIDB,X3             AND TELL THE ASSEMBLER\nTC08     DS    0H\n         OC    HIDBCHN,HIDBCHN     END OF CONTENTS CHAIN .Q\n         BZ    TC09                BRANCH IF YES\n         L     X3,HIDBCHN          NEXT ENTRY\n         B     TC08                GO AND TRY AGAIN\nTC09     DS    0H\n         ST    X1,HIDBCHN          ADD FORMER HIDDEN BUFFER LINES\n         DROP  X3\n         SPACE\n        $CALL  SA                  SAVE FORMATTING ENVIRONMENT\n        $OFF   SWITCHS,NFSWS       CONCATENATE ON\n         MVI   JUVAL,JUVNEG        AND NO JUSTIFY\n         L     R1,BUFF3AD          WORKING BUFFER\n         LA    R1,4(,R1)           SKIP THE RDW\n         MVC   0(L'TCTBSET,R1),TCTBSET  DEFINE CONTENTS TAB\n         MVC   0(1,R1),PERIND      CONTROL WORD INDICATOR\n         MVC   4(1,R1),PERIND      AND AGAIN\n         LA    TEMP,L'TCTBSET-1    LENGTH OF THE STRING\n        $CALL  HIDBADD             ADD LIFO ON CHAIN\n        $ON    SWITCHS,TCSWS       NOW IN TABLE OF CONTENTS MODE\n         B     TC17                AND GO TO RETURN\n         SPACE\nTC10     DS    0H\n        $IFOFF SWITCHS,TCSWS,TCE012     TEST INVALID PLACEMENT\n        $OFF   SWITCHS,TCSWS       NO LONGER IN TABLES OF CONTENTS\n        $IFON  SWITCHS,FEMPTY,TC11 BRANCH IF PAGE EMPTY\n        $IFOFF TCDHSAVE+DHFLAGS-DHDSECT,DHPA,TC11 IF .DH 1 NOPAGE\n        $CALL  PAGE                TERMINATE PAGE OR COLUMN\nTC11     DS    0H\n        $CALL  RE                  RESTORE FORMATTING ENVIRONMENT\n         L     COUNT,TCPAGE        POTENTIAL NEXT PAGE NUMBER\n         LTR   COUNT,COUNT         IS IT VALID .Q\n         BNP   TC12                BRANCH IF NOT\n         ST    COUNT,PACNTI        SET NEXT PAGE NUMBER\nTC12     DS    0H\n         B     TC17                GO TO RETURN\n         SPACE\nTC13     DS    0H\n         L     X3,DHNUMTC          TABLE OF CONTENTS NUMBER\n         SLL   X3,2                MULT BY FOUR\n         LA    R1,TCANCH(X3)       POINT TO DATA ANCHOR\n        $CALL  HIDBPUR             AND DELETE IT ALL\n         B     TC17                GO TO RETURN\n         SPACE\nTC14     DS    0H\n         L     X3,DHNUMTC          TABLE OF CONTENTS NUMBER\n         SLL   X3,2                MULT BY FOUR\n         LA    X1,TCANCH-HIDBCHN+HIDB(X3)  POINT TO DATA ANCHOR\n         SPACE\n         USING HIDB,X1             TELL THE ASSEMBLER\nTC15     DS    0H\n         OC    HIDBCHN,HIDBCHN     END OF THE LINE .Q\n         BZ    TC16                BRANCH IF YES\n         L     X1,HIDBCHN          NEXT ENTRY\n         B     TC15                TRY AGAIN\nTC16     DS    0H\n        $CALL  GETNUM              GET NUMERIC ARGUMENT\n         BC    BNEG,TCE014         BRANCH IF TOO SMALL\n         BC    BOMIT,TC17          ALL DONE IF NOTHING\n         LA    R0,DHMAXTC          MAXIMUM ALLOWED\n         CR    COUNT,R0            TOO BIG .Q\n         BNL   TCE013              ERROR IF TOO HIGH\n         C     COUNT,DHNUMTC       ADDING THE CURRENT .Q\n         BE    TC16                YES, FORGET IT\n         SLL   COUNT,2             MULT BY FOUR\n         LA    COUNT,TCANCH(COUNT) POINT TO NEW\n         MVC   HIDBCHN,0(COUNT)    NEW TO OLD\n         XC    0(L'HIDBCHN,COUNT),0(COUNT)  CLEAR OLD CHAIN\n         B     TC15                GET NEW END AND CONTINUE\n         SPACE\nTC17     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nTCE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     TC17                GO TO RETURN\nTCE012   DS    0H\n         MVI   EFLAG012,ERRSET     INVALID PLACEMENT\n         B     TC17                GO TO RETURN\nTCE013   DS    0H\n         MVI   EFLAG013,ERRSET     OPERAND TOO BIG\n         B     TC17                GO TO RETURN\nTCE014   DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     TC17                GO TO RETURN\n         SPACE\nTCCMVC1  MVC   0(*-*,R1),0(TEMP)   SAVE LINE OPERAND\nTCCMVC2  MVC   BUFF2+L'TCHL1(*-*),0(R1) RESTORE LINE OPERAND\nTCCONTS  DC    C'CONTENTS'         DEFAULT CONTENTS TITLE\nTCHL1    DC    C'.HL 1 '           DUMMY HEAD LEVEL ONE\nTCON     DC    C'.TC ON'           TO INITIATE TABLE OF CONTENTS\nTCOFF    DC    C'.TC OFF'          TO TERMINATE TABLE OF CONTENTS\nTCTBSET  DC    C'.UR .TB ''&&SYSTCTB''&&SYSLL.R'  RIGHT CONTENTS TAB\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#TE": {"ttr": 13313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x004\\x004\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .TE (READ TERMINAL) --- READ INPUT FROM CONSOLE        *\n*                                                                     *\n***********************************************************************\n         SPACE\nTE      $ENTER ,\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BOMIT,TE01          BRANCH IF NULL, ASSUME ONE\n         BC    BPOS,TE02           AFFIRMATIVE IS FOREVER\n         BC    BNEG,TE03           NEGATIVE FINISHES IT\n         ST    COUNT,ARGSTART      RESET START OF SCAN\n        $CALL  GETNUM              IT IS PROBABLY NUMERIC\n         BC    BNEG,TEE014         TREAT NEGATIVE AS ERROR\n         BC    BDNO,TEE005         BRANCH IF INVALID\n         B     TE04                ENTER VALUE FOR TERMINAL INPUT\n         SPACE\nTE01     DS    0H\n         LA    COUNT,1             ONE LINE BY DEFAULT\n         B     TE04                ENTER VALUE FOR READ\nTE02     DS    0H\n         LH    COUNT,H32767        LARGE POSITIVE NUMBER\n         B     TE04                ENTER VALUE FOR READS\nTE03     DS    0H\n         SR    COUNT,COUNT         ZERO VALUE\nTE04     DS    0H\n         ST    COUNT,CONSMAX       STORE IN PARAMETER BLOCK\n         MVC   CONSGOTO,BLANKS     CLEAR GOTO TARGET\n         XC    CONSFLAG,CONSFLAG   INITIALIZE CONSOLE FLAGS\n        $ON    CONSFLAG,IO$JIGG    SPECIFY 'JIGGLE' TYPE BALL\n        $ON    CONSFLAG,IO$IM      AND IMBED THIS TERMINAL FILE\n         SPACE\n        $IFOFF TTYPE,TONLINE,TE05  SUPPRESS PRINT NOT ONLINE\n         CLC   PASSNO,DEFPASOF+TAB3DEF  IS THIS THE LAST PASS .Q\n         BNE   TE05                NO, DON'T SUPPRESS PRINT\n        $IFON  TTYPE,TFILE,TE05    BRANCH IF NO TERMINAL CONFLICT\n         SPACE\n        $ON    CONSFLAG,IO$SUPR    SUPPRESS PRINTING\n         SPACE\nTE05     DS    0H\n         LA    R1,CONSBLOK         TO 'IMBED' THE CONSOLE FILE\n        $CALL  RDFILE              CALL THE INPUT SUPERVISOR\n         SPACE\nTE06     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nTEE014   DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     TE06                GO TO RETURN\nTEE005   DS    0H\n         MVI   EFLAG005,ERRSET     OPERAND INVALID\n         B     TE06                GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#TH": {"ttr": 13315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x19\\x00\\x19\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              THEN (.TH) --- CONTROL                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nTH      $ENTER ,\n        $IFOFF IFSTAK,IFLAST,TH01  MUST FOLLOW A .IF\n        $OFF   IFSTAK,IFLAST       .IF IS NO LONGER LAST\n        $IFNONE IFSTAK,(IFTRUE,IFFALSE),TH01 MUST BE TRUE OR FLASE\n        $IFANY IFSTAK,(IFTHEN,IFELSE),TH01   NOT OBJECT OF .TH/.EL\n        $IFON  IFSTAK,IFDO,TH01    NOT WITHIN A DO GROUP\n        $ON    IFSTAK,IFTHEN       THIS IS A THEN\n        $CALL  USARG               MOVE OVER ARGUMENT\n         BC    BOMIT,TH02          BRANCH IF NO OPERAND\n         LA    R15,WRETNR          RETURN CODE TO PROCESS THE RESULT\n         B     TH03                AND GO TO RETURN\n         SPACE\nTH01     DS    0H\n         MVI   EFLAG023,ERRSET     INVALID ELSE FLAG\nTH02     DS    0H\n         SR    R15,R15             SET RETURN CODE TO IGNORE\n         SPACE\nTH03     DS    0H\n        $EXIT  RC=(R15)            RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#TI": {"ttr": 13317, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00,\\x00,\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              TRANSLATE ON INPUT (.TI) --- CONTROL                   *\n*                                                                     *\n***********************************************************************\n         SPACE\nTI      $ENTER ,\n         MVC   TRANAD,TRANADI      ADDR OF INPUT TRANSLATE TABLE\n        $CALL  GETYESNO            LOOK AT FIRST ARGUMENT\n         BC    15-BOMIT,TI02       BRANCH IF SOME ARGS\n         L     TEMP,TRANADI        ADDR OF INPUT TRANSLATE TABLE\n         L     R1,TRINITAD         IDENTITY TRANS TABLE ADDR\n         MVC   0(256,TEMP),0(R1)   ENTER THE IDENTITY TRANS TABLE\nTI01     DS    0H\n         XC    ESTABAD(4),ESTABAD  ZERO ESCAPE TABLE POINTER\n         B     TI06                AND GO TO RETURN\n         SPACE\nTI02     DS    0H\n         CLI   YNRESULT,YNSET      IS ARGUMENT SET .Q\n         BE    TI04                BRANCH IF YES\n         ST    COUNT,ARGSTART      RESCAN FROM START\n        $CALL  TRSCN               PROCESS REST AS .TR\n         B     TI06                AND GO TO RETURN\n         SPACE\nTI04     DS    0H\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION PLEASE\n        $CALL  GETARG              GET 'SET' ARGUMENT\n         BC    BOMIT,TI01          ZERO POINTER, NOT TABLE IF MISSING\n         LTR   TEMP,TEMP           IS LENGTH-1 OF OPERAND ZERO .Q\n         BNZ   TI05                ERROR IF NOT\n         L     TEMP,ESTABAD+4      GET REAL TABLE\n         ST    TEMP,ESTABAD        SET THE WORKING TABLE POINTER\n         XC    0(256,TEMP),0(TEMP) ZERO THE TABLE\n         SR    R1,R1               ZERO WORKING REGISTER\n         IC    R1,0(,COUNT)        GET FIRST CHAR OF ARGUMENT\n         STC   R1,0(R1,TEMP)       ENTER IN THE TABLE\n         STC   R1,ESTABAD          SAVE CHAR IN TABLE ADDRESS\n         B     TI06                AND GO TO RETURN\n         SPACE\nTI05     DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         SPACE\nTI06     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#TM": {"ttr": 13319, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00.\\x00.\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .TOP MARGIN (.TM) --- CONTROL                          *\n*                                                                     *\n***********************************************************************\n         SPACE\nTM      $ENTER ,\n        $CALL  PRINTNB             CLEAR PRINT BUFFER\n        $CALL  GETNUM              GET NUMBER\n         BC    BDNO,TM03           ERROR IF INVALID\n         BC    BOMIT,TM01          ENTER DEFAULT IF INVALID\n         CLI   NUMSIGN,C' '        WAS ARGUMENT SIGNED .Q\n         BE    TM02                BRANCH IF NOT\n         AH    COUNT,TOPMRG        ALTER TOP MARGIN VALUE\n         B     TM02                GO CHECK AND ENTER\nTM01     DS    0H\n         L     COUNT,DEFTM+TAB3DEF DEFAULT TOP MARGIN VALUE\nTM02     DS    0H\n         LTR   COUNT,COUNT         IS TOP MARGIN NEGATIVE .Q\n         BM    TM05                ERROR IF YES\n         LH    TEMP,HDMRG          HEADING MARGIN VALUE\n         AH    TEMP,HSCNT          PLUS HEADING SPACING\n         CR    COUNT,TEMP          COMPARE VALUES\n         BL    TM06                ERROR IF LESS\n         LH    TEMP,PLZ            GET CURRENT PAGE LENGTH\n         SH    TEMP,BMMRG          LESS BOTTOM MARGIN\n         CR    COUNT,TEMP          TOO BIG .Q\n         BNL   TM04                ERROR IF TOO BIG\n         STH   COUNT,TOPMRG        SET TOP MARGIN SIZE\n         B     TM07                BRANCH TO RETURN\n         SPACE\nTM03     DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     TM07                BRANCH TO RETURN\nTM04     DS    0H\n         MVI   EFLAG045,ERRSET     OPERAND TOO BIG\n         B     TM07                BRANCH TO RETURN\nTM05     DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     TM07                BRANCH TO RETURN\nTM06     DS    0H\n         MVI   EFLAG041,ERRSET     OPERAND TOO BIG\n         B     TM07                BRANCH TO RETURN\n         SPACE\nTM07     DS    0H\n        $EXIT  RC=0                RETURN TO MAIN CONTROLLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#TR": {"ttr": 13321, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00g\\x00g\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 103, "newlines": 103, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .TRANSLATE (.TR) --- SPECIFY TRANSLATE TABLE.          *\n*                                                                     *\n***********************************************************************\n         SPACE\nTR      $ENTER ,\n         MVC   TRANAD,TRANADO      ADDR OF OUTPUT TRANSLATE TABLE\n        $CALL  TRSCN               GO DO THE WORK\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nTRSCN   $ENTER ,\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION IN ARG. FETCH\n        $CALL  GETARG              OBTAIN FIRST SOURCE CHAR\n         BC    BPOS,TR02           BRANCH IF SOME ARGUMENT(S)\n        $CALL  TRRESET             RESET TRANSLATE TABLE\n         B     TR07                AND GO TO RETURN\n         SPACE\nTR01     DS    0H\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION\n        $CALL  GETARG              OBTAIN NEXT SOURCE CHARACTER\n         BC    BOMIT,TR05          IF NO MORE, QUIT\nTR02     DS    0H\n        $CALL  TRHEX               GET HEX OFFSET OF SOURCE\n         BC    BDNO,TR06           BRANCH IF INVALID OPERAND\n         LR    X1,R1               SAVE IT\n         SPACE\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION\n        $CALL  GETARG              GET TRANSLATED CHARACTER\n         BC    BPOS,TR03           IF FOUND, SKIP AHEAD\n         LR    R1,X1               IF NO ARGUMENT, SOURCE -> SOURCE\n         B     TR04                ..\nTR03     DS    0H\n        $CALL  TRHEX               GET HEX OFFSET\n         BC    BDNO,TR06           BRANCH IF INVALID OPERAND\n         SPACE\nTR04     DS    0H\n         A     X1,TRANAD           PLUS BASE ADDR OF TABLE\n         STC   R1,0(,X1)           STORE VALUE IN TRANSLATE TABLE\n         B     TR01                DO MORE PAIRS\n         SPACE\nTR05     DS    0H\n        $ON    SWITCHS,TRSWS       TURN ON TRANSLATE SWITCH\n         B     TR07                AND GO TO RETURN\n         SPACE\nTR06     DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         SPACE\nTR07     DS    0H\n        $EXIT  RC=0                AND RETURN\n         SPACE\n*        ON ENTRY   (COUNT) ADDR OF STRING TO CONVERT\n*                   (TEMP)  LENGTH-1 OF STRING\n*        ON EXIT    (R1)    HEX VALUE OF OPERAND\n*                   CC = BPOS IF SUCCESSFUL\n*                      = BDNO IF ERROR\n         SPACE\nTRHEX   $ENTER ,                   SAVE CALLER'S REGISTERS\n         C     TEMP,F1             TEST LENGTH-1\n         BH    TRHEX03             ERROR IF HIGH\n         BE    TRHEX01             BRANCH IF TWO CHARS\n         SR    R1,R1               CLEAR RETURN REGISTER\n         IC    R1,0(,COUNT)        GET RETURN VALUE\n         B     TRHEX02             BRANCH TO SUCCESSFUL RETURN\n         SPACE\nTRHEX01  DS    0H\n         L     X1,HEXTABAD         HEX TRANSLATE TABLE ADDR\n         XC    SAVEF0,SAVEF0       CLEAR WORK AREA\n         MVC   SAVEF0+3(1),0(COUNT)     FIRST CHARACTER\n         TR    SAVEF0+3(1),0(X1)   HEX EQUIVALENT\n         CLI   SAVEF0+3,15         TOO BIG .Q\n         BH    TRHEX03             ERROR IF YES\n         L     R1,SAVEF0           FIRST HEX DIGIT\n         SLL   R1,4                SHIFT SUM TO POWER OF SIXTEEN\n         MVC   SAVEF0+3(1),1(COUNT)     SECOND CHARACTER\n         TR    SAVEF0+3(1),0(X1)   HEX EQUIVALENT\n         CLI   SAVEF0+3,15         TOO BIG FOR HEX\n         BH    TRHEX03             ERROR IF YES\n         A     R1,SAVEF0           FINAL RESULT\n         SPACE\nTRHEX02  DS    0H\n        $CC    POS                 OK CONDITION CODE\n         B     TRHEX04             BRANCH TO RETURN\n         SPACE\nTRHEX03  DS    0H\n        $CC    DNO                 ERROR CONDITION CODE\n         SPACE\nTRHEX04  DS    0H\n        $RESTOR KEEP=(R1)          RESTORE CALLER'S REGISTERS\n         BR    RETURN              RETURN TO CALLER\n         SPACE\nTRRESET $ENTER ,\n         L     TEMP,TRANAD         POINT TO TRANSLATE TABLE TARGET\n         L     R1,TRINITAD         IDENTITY TRANSLATE ADDRESS\n         MVC   0(256,TEMP),0(R1)   ENTER THE IDENTITY TRANS TABLE\n        $OFF   SWITCHS,TRSWS       NO NEED TO TRANSLATE\n        $IFOFF SWITCHS,TROSWS,TRRESETF TEST TRANSLATE OPTION\n         OC    X'81'(9,TEMP),BLANKS  UPPER 'A' TO 'I'\n         OC    X'91'(9,TEMP),BLANKS  UPPER 'J' TO 'R'\n         OC    X'A2'(8,TEMP),BLANKS  UPPER 'S' TO 'Z'\n        $ON    SWITCHS,TRSWS       TURN ON TRANSLATE SWITCH\nTRRESETF DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#UC": {"ttr": 13324, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .UC (UNDERSCORE AND CAPITALIZE) --- CONTROL            *\n*                                                                     *\n***********************************************************************\n         SPACE\nUC      $ENTER ,\n        $CALL  UP                  FIRST CONVERT TO UPPERCASE\n         LTR   R15,R15             ANY OPERAND LINE .Q\n         BZ    UC01                BRANCH IF NONE\n        $CALL  USOP                UNDERSCORE LINE\n         LA    R15,WRETNR          PROCESS THE RESULT\nUC01     DS    0H\n        $EXIT  RC=(R15)            RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#UD": {"ttr": 13326, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00[\\x00[\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 91, "newlines": 91, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .UD (UNDERSCORE DEFINITION) --- CONTROL                *\n*                                                                     *\n***********************************************************************\n         SPACE\nUD      $ENTER ,\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BOMIT,UD01          BRANCH IF OMITTED TO RESET\n         BC    BPOS,UD02           BRANCH IF TURN ON\n         BC    BNEG,UD03           BRANCH IF TURN OFF\n         LA    X1,UDINCCHR         TARGET FOR UNDERSCORE INCLUDE\n         LR    X2,X1               SECOND TARGET THE SAME\n         CLI   YNRESULT,YNINC      WAS OPERAND 'INCLUDE' .Q\n         BE    UD05                BRANCH IF YES\n         LA    X1,UDIGNCHR         TARGET FOR UNDERSCORE IGNORE\n         LR    X2,X1               SECOND TARGET THE SAME\n         CLI   YNRESULT,YNIGN      WAS OPERAND 'IGNORE' .Q\n         BE    UD05                BRANCH IF YES\n         LA    X1,UDINCCHR         TARGET FOR UNDERSCORE SET\n         LA    X2,UDIGNCHR         SECOND TARGET DIFFERENT\n         CLI   YNRESULT,YNSET      WAS OPERAND 'SET' .Q\n         BE    UD05                BRANCH IF YES\n         B     UDE005              ELSE, MUST BE INVALID\n         SPACE\nUD01     DS    0H\n        $CALL  UDRESET             RESET UNDERSCORE TABLE\n         B     UD08                GO TO RETURN\n         SPACE\nUD02     DS    0H\n         LA    X1,UDON             TURN CHAR UNDERSCORE ON\n         B     UD04                CONTINUE\nUD03     DS    0H\n         LA    X1,UDOFF            TURN CHAR UNDERSCORE OFF\nUD04     DS    0H\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION PLEASE\n        $CALL  GETARG              GET AN ARGUMENT\n         BC    BOMIT,UD08          NONE LEFT, GO TO RETURN\n        $CALL  TRHEX               GET HEX EQUIVALENT\n         BC    BDNO,UDE005         ERROR IF DOES NOT CONVERT\n         A     R1,UDTABAD          POINT TO RESULT SLOT\n         STC   X1,0(,R1)           TURN CHAR ON OR OFF\n         B     UD04                DO ALL CHARS IN LIST\n         SPACE\nUD05     DS    0H\n        $ON    SWITCHS,FNOCASE     NO CASE CONVERSION PLEASE\n        $CALL  GETARG              GET CHARACTER ARGUMENT\n         BC    BOMIT,UD06          BRANCH TO RESET IF NONE\n        $CALL  TRHEX               GET HEX EQUIVALENT\n         BC    BDNO,UDE005         ERROR IF DOES NOT CONVERT\n         B     UD07                GO ENTER RESULT\nUD06     DS    0H\n         LA    R1,C' '             THIS DEFAULT KILLS FACILITY\nUD07     DS    0H\n         STC   R1,0(,X1)           SET UNDERSCORE ESCAPE CHAR\n         STC   R1,0(,X2)           AND SET IT AGAIN\n         SPACE\nUD08     DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nUDE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     UD08                GO TO RETURN\n         SPACE\nUDRESET $ENTER ,\n         L     R1,UDTABAD          UNDERSCORE TABLE ADDRESS\n         MVI   0(R1),UDON          ASSUME THIS CHAR UNDERSCORED\n         MVC   1(L'UDTABLE-1,R1),0(R1)  THEN TURN THEM ALL ON\n         SPACE\n         MVI   X'05'(R1),UDOFF     NOT THE TAB\n         MVI   X'16'(R1),UDOFF     NOT THE BACKSPACE\n         MVI   X'40'(R1),UDOFF     NOT THE BLANK\n         MVI   X'4B'(R1),UDOFF     NOT THE PERIOD\n         MVI   X'4D'(R1),UDOFF     NOT THE LEFT PAREN\n         MVI   X'5A'(R1),UDOFF     NOT THE EXCLAMATION MARK\n         MVI   X'5D'(R1),UDOFF     NOT THE RIGHT PAREN\n         MVI   X'5E'(R1),UDOFF     NOT THE SEMI-COLON\n         MVI   X'6B'(R1),UDOFF     NOT THE COMMA\n         MVI   X'6D'(R1),UDOFF     NOT THE UNDERSCORE ITSELF\n         MVI   X'6F'(R1),UDOFF     NOT THE QUESTION MARK\n         MVI   X'7A'(R1),UDOFF     NOT THE COLON\n         MVI   X'7F'(R1),UDOFF     NOT THE DOUBLE QUOTE\n         MVI   X'8B'(R1),UDOFF     NOT THE LEFT BRACE\n         MVI   X'9B'(R1),UDOFF     NOT THE RIGHT BRACE\n         MVI   X'AD'(R1),UDOFF     NOT LEFT SQUARE BRACKET\n         MVI   X'BD'(R1),UDOFF     NOT RIGHT SQUARE BRACKET\n         SPACE\n         MVI   UDINCCHR,C' '       CLEAR UNDERSCORE INCLUDE CHAR\n         MVI   UDIGNCHR,C' '       CLEAR UNDERSCORE IGNORE CHAR\n         SPACE\n        $EXIT  RC=0                AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#UL": {"ttr": 13329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x001\\x001\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 49, "newlines": 49, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .UL (UNDERLINE ALPHANUMERICS) --- CONTROL              *\n*                                                                     *\n***********************************************************************\n         SPACE\nUL      $ENTER ,\n         L     X1,ARGSTART         REMEMBER BEGINNING OF ARGUMENT\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BOMIT,UL01          BRANCH TO DEFAULT IF OMITTED\n         BC    BPOS,UL02           BRANCH IF BEGIN UNDERLINE\n         BC    BNEG,UL03           BRANCH IF END UNDERLINE\n         SPACE\n         ST    X1,ARGSTART         RESCAN FOR NUMERIC ARGUMENT\n        $CALL  GETNUM              GET NUMERIC ARGUMENT\n         BC    BPOS,UL04           BRANCH IF ZERO OR POSITIVE ARG\n         ST    X1,ARGSTART         ALL FAILED, ONLY UNDERLINE OPERAND\n         SPACE\nUL01     DS    0H\n         LA    COUNT,1             ONE UNDERLINED LINE BY DEFAULT\n         B     UL04                MAKE THE ENTRY\nUL02     DS    0H\n         L     COUNT,F32767        DO IT FOREVER IF BEGIN\n         B     UL04                MAKE THE ENTRY\nUL03     DS    0H\n         XC    OCCNT,OCCNT         CLEAR OVERLAY CHAR LINE COUNT\n         MVC   OCCHAR(1),OCCHAR+1  RESET DEFAULT OVERLAY CHAR\n         MVI   OCEXCEP,X'00'       AND RESET EXCEPTION CHAR COUNT\n         B     UL05                AND GO TEST FURTHER TEXT\nUL04     DS    0H\n         MVI   OCCHAR,C'_'         SET UNDERSCORE FOR OVERLAY CHAR\n         MVI   OCEXCEP,X'FF'       SET MAX EXCEPTION COUNT\n         STH   COUNT,OCCNT         AND SET COUNT OF TEXT LINES\n         SPACE\nUL05     DS    0H\n        $CALL  USARG               PROCESS ARGUMENT LINE\n         BC    BOMIT,UL06          CONTINUE WITH NEXT LINE IF EMPTY\n         LA    R15,WRETNR          RETURN CODE TO PROCESS THE RESULT\n         B     UL07                AND GO TO FINAL RETURN\n         SPACE\nUL06     DS    0H\n         SR    R15,R15             SET RETURN CODE TO IGNORE\n         SPACE\nUL07     DS    0H\n        $EXIT  RC=(R15)            AND RETURN TO CALLER\n         SPACE\nULE014   DS    0H\n         MVI   EFLAG014,ERRSET     ARGUMENT TOO SMALL\n         B     UL06                AND GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#UN": {"ttr": 13331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00+\\x00+\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 43, "newlines": 43, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .UN (UNDENT) --- CONTROL                               *\n*                                                                     *\n***********************************************************************\n         SPACE\nUN      $ENTER ,\n        $CALL  PRINTNB             BREAK\n        $CALL  GETNUM              GET AMOUNT\n         BC    BDNO,UNE005         ERROR IF INVALID\n         BC    BOMIT,UN01          TAKE DEFAULT IF OMITTED\n         CLI   NUMSIGN,C' '        WAS OPERAND UNSIGNED .Q\n         BE    UN02                BRANCH IF YES\n         AH    COUNT,UNDL          MAKE RELATIVE CHANGE\n         B     UN02                GO CHECK AND ENTER\nUN01     DS    0H\n         SR    COUNT,COUNT         ZERO IS DEFAULT\nUN02     DS    0H\n         L     R1,LLZ              GET LINE LENGTH\n         AH    R1,INDENTR          PLUS RIGHT INDENT\n         LCR   R1,R1               MAKE IT NEGATIVE\n         CR    COUNT,R1            IS VALUE TOO SMALL .Q\n         BNH   UNE014              TOO SMALL IF NOT\n         CH    COUNT,INDL          COMPARE WITH INDENT\n         BH    UNE013              ERROR IF LARGER\n         STH   COUNT,UNDL          SET UNDENTATION\n         STH   COUNT,OFUNCNT       SET MARGIN VALUE FOR FORMAT\n         SH    COUNT,INDL          LESS CURRENT INDENT\n         LCR   COUNT,COUNT         POSITIVE VALUE\n         STH   COUNT,RMARGIN       SET RIGHT MARGIN\n         SPACE\nUN03     DS    0H\n        $EXIT  RC=0                AND CONTINUE\n         SPACE\nUNE005   DS    0H\n         MVI   EFLAG005,ERRSET     INVALID OPERAND\n         B     UN03                AND GO TO RETURN\nUNE013   DS    0H\n         MVI   EFLAG013,ERRSET     OPERAND TOO BIG\n         B     UN03                AND GO TO RETURN\nUNE014   DS    0H\n         MVI   EFLAG014,ERRSET     OPERAND TOO SMALL\n         B     UN03                AND GO TO RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#UP": {"ttr": 13333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x16\\x00\\x16\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .UP (UPPERCASE) --- CONTROL                            *\n*                                                                     *\n***********************************************************************\n         SPACE\nUP      $ENTER ,\n        $CALL  USARG               ISOLATE ARGUMENT LINE\n         BC    BOMIT,UP01          BRANCH IF NULL ARGUMENT\n         LH    R1,BUFF2LGZ         GET NEW LENGTH\n         L     X1,UPTABAD          UPPERCASE TRANSLATE TABLE\n         EX    R1,UPTR             LOWER TO UPPER CASE TRANSFORM\n         LA    R15,WRETNR          RETURN CODE TO PROCESS RESULT\n         B     UP02                AND GO TO RETURN\n         SPACE\nUP01     DS    0H\n         SR    R15,R15             SET RETURN CODE TO IGNORE\n         SPACE\nUP02     DS    0H\n        $EXIT  RC=(R15)            RETURN TO CALLER\n         SPACE\nUPTR     TR    BUFF2(*-*),0(X1)    TRANSLATE TO UPPER CASE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#UR": {"ttr": 13569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x01w\\x01w\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 375, "newlines": 375, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .UR (USE REFERENCE) --- RE-FORMAT WITH SUBSTITUTION.   *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON EXIT:  R15 = 0   IF NULL LINE RESULTS FROM SUBSTITUTION\n*                  R15 = 8   IF NON-NULL LINE RESULTS\n         SPACE\nUR      $ENTER ,\n        $OFF   SWITCHS,URSWS       SET NO SUBSTITUTES\n         XC    URBBACK,URBBACK     CLEAR URBUMP BACKUP COUNT\n         SPACE\n         MVC   BUFF1,BUFF2         COPY INPUT LINE\n         LA    R0,BUFF2            TARGET ADDRESS FOR RESULT\n         ST    R0,URCURPTR         SET CURRENT POINTER\n         L     TEMP,ARGSTART       ADDRESS OF BLANK AFTER \".UR\"\n         SR    TEMP,R0             RELATIVE ADDRESS\n         LA    TEMP,BUFF1+1(TEMP)  ADDRESS OF OPERAND COPY START\n         L     R1,ARGSTOP          LAST CHARACTER TO SCAN IN ORIGINAL\n         SR    R1,R0               RELATIVIZE IT\n         LA    R1,BUFF1(R1)        REAL ADDRESS OF COPY\n         SPACE\n         LA    R0,BUFF2+B2LG       END OF AREA FOR RESULT\n         ST    R0,URENDPTR         SET END POINTER\n        $IFOFF SWITCHS,UTSWS,UR01  BRANCH IF NO TRACE\n         CLC   URMAXCNT(2),URMAXCNT+2  FIRST TIME .Q\n         BNE   UR01                BRANCH IF NOT\n         BAL   RETURN,URTRAC       PRINT OUT INPUT LINE\nUR01     DS    0H\n         MVC   BUFF2(B2LG),BUFF2M1 BLANK OUT BUFFER FOR DIAGNOSTICS\n         SPACE\nUR02     DS    0H\n         MVI   URFLAG,X'00'        INITIALIZE LOCAL FLAGS\n         LR    R15,TEMP            SAVE SCAN START ADDRESS\n         LA    R0,1                INCREMENT FOR BXLE\nUR03     DS    0H\n         CLI   0(TEMP),URAMPCHR    IS THIS A PARAMETER .Q\n         BE    UR04                IF MAYBE, SKIP AHEAD\n         BXLE  TEMP,R0,UR03        NO, KEEP LOOKING\nUR04     DS    0H\n         LR    X1,TEMP             COMPUTE STRING COUNT\n         SR    X1,R15              ..\n         BNP   UR05                IF NOTHING TO MOVE, DON'T TRY\n         BAL   RETURN,URBUMP       BUMP PTRS AND MOVE DATA\nUR05     DS    0H\n         CLR   TEMP,R1             DID END OF STRING STOP US .Q\n         BH    UR22                IF YES, GO FINISH UP\n         BE    UR07                CHECK FOR ENDING VARIABLE INDIC\n         SPACE\n         CLI   1(TEMP),C' '        VARIABLE INDIC ALL ALONE .Q\n         BNE   UR06                BRANCH IF NOT\n         LA    TEMP,1(,TEMP)       BUMP OVER AMPERSAND\n         B     UR08                AND GO TO ENTER ONE\nUR06     DS    0H\n         CLI   1(TEMP),URAMPCHR    NO, DOUBLED VARIABLE INDIC .Q\n         BNE   UR09                IF NOT, MUST BE A REFERENCE NAME\nUR07     DS    0H\n         LA    TEMP,2(,TEMP)       SKIP DOUBLE \"&\" IN SOURCE\nUR08     DS    0H\n         LA    R15,URAMPER         SINGLE AMPERSAND POINTER\n         LA    X1,L'URAMPER        LENGTH OF AMPERSAND\n         BAL   RETURN,URBUMP       BUMP PTRS AND MOVE DATA\n         CLR   TEMP,R1             END OF SOURCE STRING YET .Q\n         BNH   UR02                IF NOT, CONTINUE SCAN\n         B     UR22                YES, QUIT\n         SPACE\nUR09     DS    0H\n         LA    TEMP,1(,TEMP)       UP TO START OF NAME\n         ST    TEMP,ARGSTART       SCAN FROM THERE\n         ST    R1,ARGSTOP          AND THIS WILL BE THE END\n         STM   R0,R15,URSV         SAVE REGISTERS\n        $CALL  GETSYM              GET SYMBOL FROM INPUT STRING\n         BC    15-BOMIT,UR10       BRANCH IF NOT OMITTED\n         LM    R0,R15,URSV         RESTORE REGS\n         B     UR08                AND GO BACK\n         SPACE\nUR10     DS    0H\n         BC    15-BDNO,UR11        BRANCH IF NOT INVALID\n        $IFON  SRNMFLG,SRNMTSYM,URE01   BRANCH IF BAD SYMBOL\n        $IFON  SRNMFLG,SRNMTSUB,URE02   BRANCH IF BAD SUBSCRIPT\n        $IFANY SRNMFLG,(SRNMTFR,SRNMTTO),URE03  BRANCH IF BAD SUBSTRING\nUR11     DS    0H\n         LR    X1,COUNT            POINT TO AMPERSAND\n         S     X1,F3               BACK UP THREE CHARACTERS (*'&)\n         CLI   1(X1),C''''         QUOTE BEFORE AMPERSAND .Q\n         BNE   UR15                BRANCH IF NOT\n         CLI   0(X1),C'L'          LQUOTE BEFORE AMPERSAND .Q\n         BE    UR12                BRANCH IF YES\n         CLI   0(X1),C'T'          TQUOTE BEFORE AMPERSAND .Q\n         BE    UR13                BRANCH IF YES\n         B     UR15                CONTINUE\nUR12     DS    0H\n        $ON    URFLAG,URLQUT       SET LQUOTE FLAG\n         B     UR14                GO MARK LENGTH\nUR13     DS    0H\n        $ON    URFLAG,URTQUT       SET TQUOTE FLAG\nUR14     DS    0H\n         LA    X1,2                LENGTH OF CHARQUOTE\n         ST    X1,URBBACK          SET BUMP BACK LENGTH\n         SPACE\nUR15     DS    0H\n         LA    TEMP,1(TEMP,COUNT)  POINT TO NEXT CHAR TO SCAN\n         ST    TEMP,URSV+4*TEMP    RESTORE NEXT CHAR POINTER LATER\n        $OFF   SWITCHS,UCSWS       TURN OFF .UR COMMA SWITCH\n        $CALL  SYMUR               LOOK UP SYMBOL\n         ST    COUNT,URSV+4*COUNT  RESTORE POINTER\n         USING RND,COUNT           RETURNED POINTER\n         LM    R0,R15,URSV         RESTORE REGISTERS\n         BC    BPOS,UR20           BRANCH IF SINGLE ENTRY\n         SPACE\nUR16     DS    0H\n         CLC   RNSLINK,F0          AT THE SUBSCRIPT END .Q\n         BE    UR21                BRANCH OUT IF YES\n         L     COUNT,RNSLINK       LOAD NEXT POINTER\n         TM    SRNMFLG,SRNMALLP+SRNMALLN  ONLY NEG OR POS SUBS .Q\n         BZ    UR18                BRANCH TO ENTER IF NOT\n         TM    SRNMFLG,SRNMALLN    NEGATIVE ONLY .Q\n         BO    UR17                BRANCH IF YES\n         TM    RNSUBS,X'80'        TEST FOR POSITIVE SUBSCRIPT .Q\n         BO    UR19                BRANCH IF NOT POSITIVE\n         B     UR18                GO ENTER POSITIVE SUBSCRIPT\nUR17     DS    0H\n         TM    RNSUBS,X'80'        TEST FOR NEGATIVE SUBSCRIPT .Q\n         BNO   UR19                BRANCH IF NOT NEGATIVE\nUR18     DS    0H\n         BAL   RETURN,URENTER      ENTER NEXT PORTION\nUR19     DS    0H\n         B     UR16                LOOK FOR MORE ENTRIES\n         SPACE\nUR20     DS    0H\n         BAL   RETURN,URENTER      ENTER SINGLE ITEM\n         SPACE\nUR21     DS    0H\n        $ON    SWITCHS,URSWS       SET SUBSTITUTE MADE SWITCH\n         CLR   TEMP,R1             DID STRING END STOP US .Q\n         BH    UR22                IF YES, GO FINISH UP\n         CLI   0(TEMP),C'.'        NO, DID PERIOD END SCAN .Q\n         BNE   UR02                IF NOT, CONTINUE SCAN\n         LA    TEMP,1(,TEMP)       YES, A PERIOD IS IGNORED\n         B     UR02                NOW CONTINUE SCAN\n         SPACE\nUR22     DS    0H\n         L     R1,URCURPTR         CURRENT END OF RECORD POINTER\n         LA    TEMP,BUFF2          START OF STRING\n         SR    R1,TEMP             COMPUTE RE-FORMATTED LENGTH\n         STH   R1,BUFF2LGZ         SET IT FOR MAIN CONTROLLER'S USE\n        $IFOFF SWITCHS,UTSWS,UR23  BRANCH IF NO TRACE\n        $IFOFF SWITCHS,URSWS,UR23  BRANCH IF NO CHANGES\n         BAL   RETURN,URTRAC       PRINT OUT NEW LINE\n         SPACE\nUR23     DS    0H\n         LH    R15,BUFF2LGZ        GET LENGTH OF SUBSTITUTED RESULT\n         LTR   R15,R15             IS IT NULL .Q\n         BZ    UR24                BRANCH IF YES\n         LA    R15,WRETNR          SET OK RETURN CODE\nUR24     DS    0H\n        $EXIT  RC=(R15)            GO PROCESS THE NEW LINE\n         SPACE\nURE01    DS    0H\n         MVI   EFLAG008,ERRSET     INVALID SYMBOL\n         B     URE04               GO TO COMMON ERROR EXIT\nURE02    DS    0H\n         MVI   EFLAG038,ERRSET     INVALID SUBSCRIPT\n         B     URE04               GO TO COMMON ERROR EXIT\nURE03    DS    0H\n         MVI   EFLAG039,ERRSET     INVALID SUBSTRING\n         B     URE04               GO TO COMMON ERROR EXIT\nURE04    DS    0H\n        $IFON  SWITCHS,URSWS,URE05 BRANCH IF SOME SUBSTITUTION\n         MVC   BUFF2,BUFF1         RESTORE ORIGINAL INPUT LINE\nURE05    DS    0H\n         B     UR23                GO TO RETURN\n         SPACE\n***********************************************************************\n*                                                                     *\n*              SUBROUTINE TO ENTER DATA IN OUTPUT STRING              *\n*                                                                     *\n***********************************************************************\n         SPACE\nURENTER  DS    0H\n        $SAVE  ,                   SAVE REGISTERS THRU URENT\n         LH    X2,SRNMFR           SAVE 'FROM' SUBSTRING\n         LH    X3,SRNMTO           SAVE 'TO' SUBSTRING\n        $IFNONE URFLAG,(URLQUT,URTQUT),URENT05    BRANCH IF NO SPECIAL\n        $IFON  URFLAG,URTQUT,URENT03    BRANCH IF TQUOTE\n         SR    R0,R0               PREPARE LENGTH REGISTER\n         IC    R0,RNCLEN           GET CHARACTER LENGTH\n         TM    RNFLAG,RNCHAR       CHARACTER VARIABLE .Q\n         BO    URENT02             BRANCH IF YES\n         L     R0,RNDVAL           LOAD NUMERIC VALUE\n         CVD   R0,DECM             CONVERT TO PACKED\n         LA    R1,UREDWRK+L'UREDWRK-1   IN CASE SIGNIFICANCE FORCED\n         MVC   UREDWRK,UREDPTN     INSERT EDIT PATTERN FOR EDIT\n         EDMK  UREDWRK,DECM+3      UNPACK TO CHARACTER\n         BNM   URENT01             BRANCH IF POSITIVE\n         BCTR  R1,0                BACK UP OUTPUT POINTER\n         MVI   0(R1),C'-'          ENTER LEADING MINUS\nURENT01  DS    0H\n         LA    R0,UREDWRK+L'UREDWRK     END OF FORMATTED NUMBER\n         SR    R0,R1               LENGTH OF RESULT\nURENT02  DS    0H\n         LH    R1,SRNMTO           'END' SUBSTR VALUE\n         CR    R1,R0               COMPARE WITH ACTUAL LEN\n         BNH   URENT02A            BRANCH IF NOT GREATER\n         LR    R1,R0               TAKE ACTUAL LENGTH\nURENT02A DS    0H\n         SH    R1,SRNMFR           LESS 'START' SUBSTR\n         A     R1,F1               PLUS ONE IS LENGTH\n         CR    R1,R0               IS SUBSTR SHORTER .Q\n         BNL   URENT02B            BRANCH IF NOT\n         LTR   R0,R1               USE SUBSTR LENGTH AND TEST\n         BNM   URENT02B            BRANCH IF OK\n         SR    R0,R0               ELSE USE ZERO\nURENT02B DS    0H\n         LA    COUNT,URDLQUT       POINT TO NUMERIC WORK\n         ST    R0,RNDVAL           ENTER LENGTH OF VARIABLE\n         B     URENT04A            CONTINUE WITH RESULT\nURENT03  DS    0H\n         LA    R0,C'N'             ASSUME NUMERIC\n         TM    RNFLAG,RNCHAR       IS IT CHARACTER .Q\n         BNO   URENT04             BRANCH IF NOT\n         LA    R0,C'C'             SET TO CHARACTER TYPE\nURENT04  DS    0H\n         LA    COUNT,URDTQUT       POINT TO CHARACTER WORK\n         STC   R0,RNCVAL           ENTER TYPE OF VARIABLE\nURENT04A DS    0H\n         MVC   SRNMFR,SRNMFR+L'SRNMFR   RESTORE DEFAULT 'FROM' SUBSTR\n         MVC   SRNMTO,SRNMTO+L'SRNMTO   RESTORE DEFAULT 'TO' SUBSTR\n         SPACE\nURENT05  DS    0H\n         TM    RNFLAG,RNCHAR       CHARACTER STRING .Q\n         BNO   URENT08             IF NOT, SKIP AHEAD\n         CLI   RNCLEN,X'00'        YES, IS IT NULL STRING .Q\n         BE    URENT11             IF YES, NO COPY\n        $IFOFF SWITCHS,UCSWS,URENT06  BRANCH IF NO CONCATENATOR\n         LA    R15,URCOMBL         CONCATENATOR STRING\n         LA    X1,L'URCOMBL        LENGTH OF STRING\n         BAL   RETURN,URBUMP       BUMP PTRS AND MOVE DATA\nURENT06  DS    0H\n         SR    X1,X1               NOT NULL, ZERO REG\n         IC    X1,RNCLEN           GET STRING LENGTH\n         LA    R15,RNCVAL          SHORT CHARACTER OPERAND\n         CLI   RNCLEN,L'RNCVAL     LONG CHARACTER VALUE .Q\n         BNH   URENT07             BRANCH IF NOT\n         L     R15,RNCPTR          POINTER TO LONG VALUE\nURENT07  DS    0H\n         BAL   RETURN,URSUBSTB     BUMP PTRS AND MOVE DATA\n        $ON    SWITCHS,UCSWS       SET COMMA SWITCH\n         B     URENT11             GO TO RETURN\n         SPACE\nURENT08  DS    0H\n         L     X1,RNDVAL           LOAD NUMERIC VALUE\n         CVD   X1,DECM             CONVERT TO PACKED\n         LA    R1,UREDWRK+L'UREDWRK-1   IN CASE SIGNIFICANCE FORCED\n         MVC   UREDWRK,UREDPTN     INSERT PATTERN FOR EDIT\n         EDMK  UREDWRK,DECM+3      UNPACK TO CHARACTER\n         BNM   URENT09             BRANCH IF POSITIVE\n         BCTR  R1,0                BACK UP OUTPUT POINTER\n         MVI   0(R1),C'-'          ENTER LEADING MINUS\nURENT09  DS    0H\n        $IFOFF SWITCHS,UCSWS,URENT10  BRANCH IF NO ', '\n         LA    R15,URCOMBL         CONCATENATOR STRING\n         LA    X1,L'URCOMBL        LENGTH OF STRING\n         BAL   RETURN,URBUMP       BUMP PTRS AND MOVE DATA\nURENT10  DS    0H\n         LA    X1,UREDWRK+L'UREDWRK     END OF FORMATTED NUMBER\n         SR    X1,R1               LENGTH OF RESULT\n         LR    R15,R1              ADDRESS OF NUMBER\n         BAL   RETURN,URSUBSTB     BUMP PTRS AND MOVE DATA\n        $ON    SWITCHS,UCSWS       SET COMMA SWITCH\nURENT11  DS    0H\n         STH   X2,SRNMFR           RESTORE 'FROM' SUBSTRING\n         STH   X3,SRNMTO           RESTORE 'TO' SUBSTRING\n        $RESTOR ,                  RESTORE URENT REGISTERS\n         BR    RETURN              RETURN TO CALLER\n         SPACE\n***********************************************************************\n*                                                                     *\n*              SUBROUTINE TO ADD A STRING OF TEXT TO THE              *\n*              OUTPUT BUFFER.  IT HAS TWO ENTRY POINTS.               *\n*              THE FIRST 'URBUMP' ADDS TEXT WITH NO QUESTIONS.        *\n*              THE SECOND 'URSUBSTB' ALLOWS FOR L' OR T' AND          *\n*              FOR SUBSTRING.                                         *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY     (X1)  LENGTH OF STRING TO ADD\n*                     (R15) POINTER TO STRING TO ADD\n         SPACE\nURBUMP   DS    0H\n        $SAVE  ,                   SAVE CALLER'S REGS\n         L     X2,URCURPTR         CURRENT OUTPUT PTR\n         B     URBUMP03            ADD SIMPLE STRING\nURSUBSTB DS    0H\n        $SAVE  ,                   SAVE CALLER'S REGS AT ALT ENTRY\n         L     X2,URCURPTR         CURRENT OUTPUT PTR\n         L     X3,URBBACK          BACKUP OUTPUT LENGTH\n         S     X3,F1               LENGTH-1\n         BNP   URBUMP01            BRANCH IF NONE\n         S     X2,URBBACK          BACKUP CURRENT POINTER\n         EX    X3,URMVCBL          BLANK BACKUP RESULT\n         XC    URBBACK,URBBACK     CLEAR BACKUP VALUE\nURBUMP01 DS    0H\n         AH    R15,SRNMFR          POINTER PLUS START OFFSET\n         BCTR  R15,0               LESS ONE\n         SH    X1,SRNMFR           LENGTH LESS START OFFSET\n         A     X1,F1               PLUS ONE\n         BNM   URBUMP02            BRANCH IF SOMETHING LEFT\n         SR    X1,X1               ELSE ONLY NULL STRING LEFT\nURBUMP02 DS    0H\n         LH    R0,SRNMTO           END SUBSTRING POINT\n         SH    R0,SRNMFR           LESS FROM SUBSTRING\n         A     R0,F1               PLUS ONE IS LENGTH\n         CR    R0,X1               IS SUBSTRING SHORTER .Q\n         BNL   URBUMP03            BRANCH IF NOT\n         LR    X1,R0               USE SUBSTRING LENGTH\nURBUMP03 DS    0H\n         LTR   X1,X1               IS LENGTH VALID .Q\n         BNM   URBUMP04            BRANCH IF YES\n         SR    X1,X1               ELSE ONLY NULL STRING\nURBUMP04 DS    0H\n         AR    X2,X1               PLUS THIS LENGTH\n         C     X2,URENDPTR         OFF THE TOP .Q\n         BH    URBUMP05            YES, IGNORE ERROR FOR NOW\n         ST    X2,URCURPTR         UPDATE CURRENT POINTER\n         SR    X2,X1               RESTORE ORIGINAL POINTER\n         S     X1,F1               SS LENGTH-1\n         BM    URBUMP05            BRANCH IF NOTHING LEFT\n         EX    X1,URMVC            MOVE DATA SEGMENT\nURBUMP05 DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGS\n         BR    RETURN              RETURN TO CALLER\n         SPACE\n***********************************************************************\n*                                                                     *\n*              SUBROUTINE TO DISPLAY SUBSTITUTED RESULT               *\n*                                                                     *\n***********************************************************************\n         SPACE\nURTRAC   DS    0H\n        $SAVE  ,                   SAVE CALLER'S REGS\n         L     COUNT,BUFF3AD       POINT TO WORK AREA\n         XC    0(4,COUNT),0(COUNT) CLEAR RDW\n         MVC   4(B2LG,COUNT),BLANKS     CLEAR CC AND DATA AREA\n        $IFON  SWITCHS,URSWS,URTRAC01   BRANCH IF SOME SUBSTITUTION\n         CLC   URMAXCNT(2),URMAXCNT+2   FIRST LEVEL CALL .Q\n         BNE   URTRAC01                 BRANCH IF NOT\n         MVI   4(COUNT),C'0'            DOUBLE SPACE FIRST LINE\nURTRAC01 DS    0H\n         LR    R0,COUNT            POINT TO RECORD TO DISPLAY\n         LA    R1,1                OFFSET ONE IF OFFLINE\n        $IFOFF TTYPE,TONLINE,URTRAC02   BRANCH IF NOT ONLINE\n         LA    R1,2                OFFSET IF ONLINE\nURTRAC02 DS    0H\n        $CALL  PRNUM               ENTER LINE NUMBER FIRST\n         MVC   4+1+28(B2LG-1-28,COUNT),BUFF2  ENTER DATA TO PRINT\n         LH    R1,BUFF2LGZ         DATA LENGTH\n         LA    R1,5+28(,R1)        PLUS RDW, CC AND LINE NUMBER\n         STH   R1,0(,COUNT)        SET LRECL FOR PRINT\n        $CALL  PRTERM              DISPLAY THE TRACE LINE\n        $RESTOR ,                  RESTORE CALLER'S REGS\n         BR    RETURN              RETURN TO CALLER\n         SPACE\nURMVC    MVC   0(*-*,X2),0(R15)    EXECUTED MOVE DATA SEGMENT\nURMVCBL  MVC   0(*-*,X2),BLANKS    EXECUTED CLEAR REMAINDER\n         SPACE\nURCOMBL  DC    C', '               INTER ENTRY CONCATENATOR\nURAMPCHR EQU   C'&&'               REFERENCE NAME INDICATOR CHAR\nURAMPER  DC    AL1(URAMPCHR)       SINGLE AMPERSAND REPLACES ONE\n         SPACE\n        $SYSREF URDLQUT,TYPE=NUM,VALUE=*-*\n        $SYSREF URDTQUT,TYPE=CHAR,LENGTH=1,VALUE='*'\n         SPACE\n         DROP  COUNT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#US": {"ttr": 13576, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00j\\x00j\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 106, "newlines": 106, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .US (UNDERSCORE) --- CONTROL                           *\n*                                                                     *\n***********************************************************************\n         SPACE\nUS      $ENTER ,\n        $CALL  USARG               ISOLATE ARG TO UNDERSCORE\n         BC    BOMIT,US01          BRANCH IF NONE\n        $CALL  USOP                UNDERSCORE OPERAND\n         LA    R15,WRETNR          PROCESS THE RESULT\n         B     US02                GO TO RETURN\nUS01     DS    0H\n         SR    R15,R15             SET NO OPERAND RETURN CODE\nUS02     DS    0H\n        $EXIT  RC=(R15)            AND RETURN TO CALLER\n         SPACE\nUSARG   $ENTER ,\n         L     TEMP,ARGSTART       ADDR OF BLANK DELIMITER\n         LA    TEMP,1(,TEMP)       BEGINNING OF OPERAND LINE\n         LA    R1,BUFF2            START OF LINE\n         SR    R1,TEMP             NEGATIVE LENGTH TO CHOP\n         AH    R1,BUFF2LGZ         NEW LENGTH\n         BNP   USARG01             BRANCH IF NOTHING THERE\n         STH   R1,BUFF2LGZ         SET NEW LENGTH\n         EX    R1,USARGMVC         MOVE OVER THE REMAINDER\n        $CC    POS                 SET RETURN CC\n         B     USARG02             GO TO RETURN\nUSARG01  DS    0H\n        $CC    OMIT                SET NO OPERAND CC\nUSARG02  DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nUSARGMVC MVC   BUFF2(*-*),0(TEMP)  MOVE OVER ARGUMENT LINE\n         SPACE\nUSOP    $ENTER ,\n         MVI   UDFLAG,UDON         ASSUME CHARS TO BE UNDERSCORED\n         LH    TEMP,BUFF2LGZ       LENGTH OF INPUT TEXT LINE\n         LTR   TEMP,TEMP           ANY DATA PRESENT\n         BNP   USOP08              BRANCH IF NONE\n         LA    R0,B2LG             MAX OUTPUT LENGTH ALLOWED\n         L     X3,BUFF3AD          WORK BUFFER ADDRESS\n         SR    TEMP,TEMP           START AT THE BEGINNING\nUSOP01   DS    0H\n         LA    R1,BUFF2(TEMP)      NEXT CHAR OF LINE\n         CLI   UDINCCHR,C' '       IS NO INCLUDE CHAR SPECIFIED .Q\n         BE    USOP03              BRANCH IF YES\n         CLC   UDINCCHR,0(R1)      IS THIS THE INCLUDE CHAR .Q\n         BNE   USOP03              BRANCH IF NOT\n         CLC   UDINCCHR,UDIGNCHR   INCLUDE AND IGNORE CHARS THE SAME .Q\n         BE    USOP02              BRANCH IF YES\n         MVI   UDFLAG,UDON         TURN INCLUDE FLAG ON\n         B     USOP04              REMOVE ESCAPE CHAR\nUSOP02   DS    0H\n         XI    UDFLAG,UDON         REVERSE SWITCH\n         B     USOP04              REMOVE ESCAPE CHAR\nUSOP03   DS    0H\n         CLI   UDIGNCHR,C' '       IS NO IGNORE CHAR SPECIFIED .Q\n         BE    USOP05              BRANCH IF YES\n         CLC   UDIGNCHR,0(R1)      IS THIS THE IGNORE CHAR .Q\n         BNE   USOP05              BRANCH IF NOT\n         MVI   UDFLAG,UDOFF        TURN IGNORE FLAG ON\nUSOP04   DS    0H\n         LH    COUNT,BUFF2LGZ      LENGTH OF INPUT LINE\n         LA    COUNT,BUFF2(COUNT)  LAST CHARACTER PLUS ONE\n         SR    COUNT,R1            LENGTH OF REMAINDER\n         EX    COUNT,USOPDE        DELETE THE ESCAPE CHAR\n         LH    COUNT,BUFF2LGZ      GET FORMER LENGTH\n         S     COUNT,F1            LESS ONE\n         BM    USOP08              RETURN IF NOTHING LEFT\n         STH   COUNT,BUFF2LGZ      SET NEW LENGTH\n         B     USOP01              DO NEXT CHARACTER\n         SPACE\nUSOP05   DS    0H\n         CLI   UDFLAG,UDOFF        ARE UNDERSCORES TO BE IGNORED .Q\n         BE    USOP06              BRANCH IF YES\n         SR    COUNT,COUNT         ZERO WORK REGISTER\n         IC    COUNT,0(,R1)        LAST CHAR OF LINE\n         A     COUNT,UDTABAD       POINT TO UNDERSCORE DEFINITION\n         CLI   0(COUNT),UDOFF      DON'T UNDERSCORE THIS CHAR .Q\n         BE    USOP06              BRANCH AROUND IF YES\n         LH    COUNT,BUFF2LGZ      LENGTH OF CURRENT BUFFER\n         LA    COUNT,2(,COUNT)     BUMP BY TWO\n         CR    COUNT,R0            RESULT TOO BIG .Q\n         BH    USOP07              BRANCH OUT IF YES\n         STH   COUNT,BUFF2LGZ      UPDATE WITH NEW LENGTH\n         LA    COUNT,BUFF2-3(COUNT)     LAST CHAR OF BUFFER\n         SR    COUNT,R1            REMAINDER LENGTH-1\n         EX    COUNT,USOPSV        SAVE THE REMAINDER\n         MVI   1(R1),X'16'         ENTER BACKSPACE\n         MVI   2(R1),C'_'          ENTER UNDERSCORE\n         EX    COUNT,USOPRE        RESTORE THE REMAINDER\n         LA    TEMP,2(,TEMP)       BUMP OFFSET BY TWO NEW CHARS\nUSOP06   DS    0H\n         LA    TEMP,1(,TEMP)       BUMP OFFSET BY ONE\n         CH    TEMP,BUFF2LGZ       AT THE END .Q\n         BL    USOP01              BRANCH BACK IF NOT\n         B     USOP08              GO TO RETURN\nUSOP07   DS    0H\n         MVI   EFLAG044,ERRWARN    GENERATED LINE TOO LONG\nUSOP08   DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n         SPACE\nUSOPSV   MVC   4(*-*,X3),1(R1)     SAVE BUFFER REMAINDER\nUSOPRE   MVC   3(*-*,R1),4(X3)     RESTORE BUFFER REMAINDER\nUSOPDE   MVC   0(*-*,R1),1(R1)     DELETE UNDERSCORE ESCAPE CHAR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#VTRAPS": {"ttr": 13579, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x006\\x006\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              VTRAPS ROUTINE --- REPLACE WITH CALLER'S TRAP ADDRS    *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        ON ENTRY  --  COMPARM3 IS ADDR OF OVERRIDING VCONS\n*\n*        ON EXIT   --  CC = BPOS  IF OK\n*                      CC = BNEG  IF NO ROUTINE MATCH\n         SPACE\nVTRAPS  $ENTER ,\n         L     TEMP,COMPARM3       CALLER'S OVERRIDING VCON LIST\n         LA    TEMP,0(,TEMP)       CLEAR HIGH BYTE\n         LTR   TEMP,TEMP           ANY LIST PRESENT .Q\n         BZ    VTR05               BRANCH TO SUCCESS IF NOT\nVTR01    DS    0H\n         L     COUNT,0(,TEMP)      NEXT ROUTINE ENTRY ADDR\n         LA    COUNT,0(,COUNT)     CLEAR HIGH BYTE\n         LTR   COUNT,COUNT         ANYTHING THERE .Q\n         BZ    VTR04               BRANCH IF NOT\n         SPACE\n         L     X3,VSCRICVT         COMMUNICATION VECTOR TABLE\n         USING SCRICVT,X3          AND TELL THE ASSEMBLER\n         LA    X1,VFSTATS          START OF ROUTINE ADDRS\n         LA    X2,L'VFSTATS        ENTRY LENGTH\n         LA    X3,VFSTATE          END OF ROUTINE ADDRS\n         DROP  X3\nVTR02    DS    0H\n         L     R1,0(,X1)           NEXT CANDIDATE\n         LTR   R1,R1               ANYTHING THERE .Q\n         BNP   VTR03               BRANCH IF NOT\n         USING SCVTDSCT,R1         CANDIDATE AREA\n         CLC   SCVTCSCT,SCVTCSCT-SCVTDSCT(COUNT)  SAME NAME .Q\n         DROP  R1\n         BNE   VTR03               BRANCH IF NOT\n         XC    1(3,X1),1(TEMP)     INTERCHANGE\n         XC    1(3,TEMP),1(X1)     ENTRY\n         XC    1(3,X1),1(TEMP)     ADDRESSES\n         B     VTR04               GO CHECK FOR END\nVTR03    DS    0H\n         BXLE  X1,X2,VTR02         CHECK THEM ALL\n        $CC    NEG                 ERROR CONDITION CODE\n         B     VTR06               GO TO RETURN\n         SPACE\nVTR04    DS    0H\n         TM    0(TEMP),X'80'       END OF USER'S LIST .Q\n         LA    TEMP,4(,TEMP)       NEXT USER ADDRESS\n         BNO   VTR01               BRANCH IF NOT LAST\nVTR05    DS    0H\n        $CC    POS                 SUCCESSFUL CONDITION CODE\n         SPACE\nVTR06    DS    0H\n        $EXIT  RC=0                RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#WD": {"ttr": 13581, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x13\\x00\\x13\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "CBT249"}, "text": "***********************************************************************\n*                                                                     *\n*              .WD (WIDOW) --- CONTROL                        *SOCOL* *\n*                                                                     *\n***********************************************************************\n         SPACE\nWD      $ENTER ,\n        $CALL  GETYESNO            GET AND TEST ARGUMENT\n         BC    BPOS+BOMIT,WD01     BRANCH IF AFFIRMATIVE OR OMITTED\n         BC    BNEG,WD02           BRANCH IF NEGATIVE\n         MVI   EFLAG005,ERRSET     SET ERROR FLAG\n         B     WD03                AND GO TO RETURN\nWD01     DS    0H\n        $ON    SWITCHS,WDSWS       TURN ON WIDOW SWITCH\n         B     WD03                AND GO TO RETURN\nWD02     DS    0H\n        $OFF   SWITCHS,WDSWS       NO WIDOW PROCESSING\nWD03     DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SYSDSECT": {"ttr": 13825, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00L\\x00L\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 76, "newlines": 76, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n         SYSDSECT  &X,&Y,&REGS=NO\n*\n*        SYSTEM INTERFACE CONTROL AREA DESCRIPTION\n*\nSICA     DSECT ,                   SYSTEM INTERFACE CONTROL AREA\nSICAID   DS    1F                  SICA ID FIELD\nSICABKWD DS    1F                  POINTER TO PREVIOUS SAVEAREA\nSICAFWRD DS    1F                  POINTER TO NEXT SAVE AREA\nSICASAVE DS    15F                 REMAINDER OF OS SAVEAREA\nSICAUSRQ DS    1F                  ORIGIN OF USER QUEUE\nSICAINTA DS    1F                  ADDRESS OF SYSINT ROUTINE\nSICAIOCQ DS    1F                  POINTER TO START OF IOCB QUEUE\nSICATRCE DS    1F                  ADDRESS OF TRACE\nSICASETA DS    1F                  ADDRESS OF SETAREA ROUTINE\nSICACORE DS    1F                  CORE TO BE LEFT FOR SYSTEM\nSICACEND DS    0F                  END OF COMMON PART OF SICA\n*\n*        IO CONTROL BLOCK DESCRIPTION\n*\nIOCB     DSECT ,                   IO CONTROL BLOCK\nIOCUSRA  DS    256D                SPACE FOR USER-DEFINED PREFIX\nIOCIODEF DS    0F                  IO DEFINITION SECTION\nIOCFTYPE DS    1C                  FILE TYPE(ONE OF FOLLOWING)\nIOC$QSAM EQU   1                   QSAM WITH NO ERROR RETURN CODES\nIOC$BSAM EQU   2                   BSAM WITH NO ERROR RETURN CODES\nIOC$BPAM EQU   3                   BPAM WITH NO ERROR RETURN CODES\nIOC$QSAR EQU   4                   QSAM WITH ERROR RETURN CODES\nIOC$BSAR EQU   5                   BSAM LOAD MODE(RELATIVE RECORD)\nIOC$BSAK EQU   6                   BSAM LOAD MODE(KEYED RECORD)\nIOC$BDAR EQU   7                   BDAM RELATIVE RECORD\nIOC$BDAK EQU   8                   BDAM KEYED RECORD\nIOCUSRLN DS    1C                  LENGTH OF USER AREA IN DBLWORDS\nIOCOPTNS DS    2C                  OPTIONS USED\nIOCDDNAM DS    CL8                 FILE NAME\nIOCRECFM DS    1C                  RECORD FORMAT\nIOCRECF  EQU   X'80'                    FIXED RECORD LENGTH\nIOCRECV  EQU   X'40'                    VARIABLE RECORD LENGTH\nIOCRECU  EQU   X'C0'                    UNDEFINED RECORD LENGTH\nIOCRECBR EQU   X'10'                    BLOCKED RECORDS\nIOCRECCA EQU   X'04'                    ASA CONTROL CHARACTER\nIOCRECMG DS    1C                  MASK TO MERGE RECFM BITS\nIOCKEYLN DS    1C                  KEY LENGTH\nIOCBUFNO DS    1C                  NUMBER OF BUFFERS\nIOCLRECL DS    1H                  LRECL OR DEFAULT LRECL\nIOCMAXLR DS    1H                  MAXIMUM LRECL\nIOCBLKSI DS    1H                  BLKSI(>0) OR DEFAULT BLKSI(<0)\nIOCRKP   DS    1H                  OFFSET OF KEY IN RECORD\nIOCTRKLM EQU   IOCRKP              NUMBER OF TRACKS\n         DS    1F                  RESERVED FOR FUTURE USE\nIOCDEFND DS    0F                  END OF IODEF\nIOCMAXRN DS    1F                  MAXIMUM RECORD NUMBER FOR BDAM\nIOCBLINK DS    1F                  LINK TO NEXT IOCB(AFTER OPEN)\nIOCBUSER DS    1F                  USER FIELD(NOT USED BY SYSINT)\nIOCBSYS  DS    1F                  POINTER TO SYSTEM DEPENDENT DATA\nIOCBCEND DS    0F                  END OF COMMON PART OF IOCB\n*\n         AIF       ('&REGS' EQ 'NO').END\nR0       EQU       0\nR1       EQU       1\nR2       EQU       2\nR3       EQU       3\nR4       EQU       4\nR5       EQU       5\nR6       EQU       6\nR7       EQU       7\nR8       EQU       8\nR9       EQU       9\nR10      EQU       10\nR11      EQU       11\nR12      EQU       12\nR13      EQU       13\nR14      EQU       14\nR15      EQU       15\n*\n.END     MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SYSIODEF": {"ttr": 13828, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x14\\x00\\x14\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n&ADDR    SYSIODEF  &FILETYP=1,&DDNAME=,&LRECL=0,&MAXLREC=0,&BLKSI=0,   X\n               &RECFM=0,&RECMERG=0,&KEYLEN=0,&BUFNO=0,&RKP=0,          X\n               &OPTIONS=0,&USERLNT=0\n&ADDR    DC        0A(0)               ALIGN TO FULL WORD\n         DC        AL1(&FILETYP)       FILE TYPE\n         DC        AL1(&USERLNT)       USER LENGTH IN DOUBLE WORDS\n         DC        AL2(&OPTIONS)       OPTIONS\n         DC        CL8'&DDNAME'        DDNAME\n         DC        AL1(&RECFM)         RECFM\n         DC        AL1(&RECMERG)       RECMERGE\n         DC        AL1(&KEYLEN)        KEY LENGTH\n         DC        AL1(&BUFNO)         BUFNO\n         DC        AL2(&LRECL)         LRECL\n         DC        AL2(&MAXLREC)       MAXLRECL\n         DC        AL2(&BLKSI)         BLKSI\n         DC        AL2(&RKP)           RKP\n         DC        AL2(0)              RESERVED\n         DC        AL2(0)              RESERVED\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TPUT": {"ttr": 13830, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\xf0\\x00\\xf0\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 240, "newlines": 240, "modlines": 0, "user": "CBT249"}, "text": "         MACRO\n&NAME    TPUT  &BFF,&SIZE,&EDIT,&WAIT,&HOLD,&BRKI,&PRTY,&TJID=,        *\n               &TJIDLOC=\n.*********************************************************************.\n.*                                                                   *.\n.*RELEASE 23 DELETIONS                                               *.\n.*                                                                   *.\n.*RELEASE 22 DELETIONS                                               *.\n.*                                                                   *.\n.*RELEASE 21 DELETIONS                                               *.\n.*                                                                   *.\n.*STATUS - CHANGE LEVEL 001                                     SA60002\n.*                                                                   *.\n.*NAME - TPUT                                                        *.\n.*                                                                   *.\n.*FUNCTION - THE TPUT MACRO IS USED TO MOVE A RECORD FROM THE USER'S *.\n.*   BUFFER TO A TS OUTPUT BUFFER TO BE TRANSMITTED TO A TERMINAL.   *.\n.*                                                                    *\n.*********************************************************************.\n.*\n.*  TPUT BUFFER ADDR,BUFFER SIZE,EDIT   ,WAIT  ,NOHOLD,NOBREAK,HIGHP\n.*        (2-12)      (2-12)     ASIS    NOWAIT HOLD   BREAKIN LOWP\n.*                               CONTROL\n.*                               FULLSCR                        SA60002\n.*       TJID=XX   (EDIT,WAIT,NOHOLD,NOBREAK,HIGHP ARE DEFAULTS)\n.*\n.*        TJIDLOC=ADDR\n.*\n         LCLA  &OPT\n         LCLA  &RET\n         LCLB  &E,&W,&H,&B,&P\n         LCLC  &PARM,&ID\n&ID      SETC  '0'                      SET TJID TO '0'\n         AIF   ('&BFF' EQ '' OR '&SIZE' EQ '').ERROR1  MNOTE\n         AIF   ('&TJID' NE '' AND '&TJIDLOC' NE '').ERROR2  MNOTE\n         AIF   ('&EDIT' EQ 'R').RF      CHECK FOR R FORM\n&PARM    SETC  '&EDIT'\n.CKPARM  ANOP\n&RET     SETA  &RET+1\n         AIF   ('&PARM' EQ '').RET           NULL, TRY NEXT\n         AIF   ('&PARM' EQ 'EDIT').EDI       SET EDIT\n         AIF   ('&PARM' EQ 'ASIS').ASI       SET ASIS\n         AIF   ('&PARM' EQ 'CONTROL').CON    SET CONTROL\n         AIF   ('&PARM' EQ 'FULLSCR').FULLS SET FULL SCREEN     SA60002\n         AIF   ('&PARM' EQ 'WAIT').WAI       SET WAIT\n         AIF   ('&PARM' EQ 'NOWAIT').NOW     SET NOWAIT\n         AIF   ('&PARM' EQ 'HOLD').HOL       SET HOLD\n         AIF   ('&PARM' EQ 'NOHOLD').NOH     SET NOHOLD\n         AIF   ('&PARM' EQ 'NOBREAK').NOB    SET NOBREAK\n         AIF   ('&PARM' EQ 'BREAKIN').BRE    SET BREAKIN\n         AIF   ('&PARM' EQ 'HIGHP').HPR      SET HIGHP\n         AIF   ('&PARM' EQ 'LOWP').LPR       SET LOWP\n         AGO   .ERROR3\n.*\n.*  CHECK REGISTER NOTATION IS USED\n.*\n.CHKREG  SPACE 1\n         AIF   ('&BFF'(1,1) EQ '(' OR '&SIZE'(1,1) EQ '(').REGFM  REG.\n.*                                      FORM MACRO\n         AIF   ('&TJID' EQ '').CHKLOC   GOTO CHECK TJIDLOC\n         AIF   ('&TJID'(1,1) EQ '(').REGFM   REG. FORM MACRO\n&ID      SETC  '&TJID'                  SET TJID\n         AGO   .EXPAND                  GOTO EXPANSION\n.CHKLOC  AIF   ('&TJIDLOC' EQ '').EXPAND  GO EXPAND IF NO 'TJIDLOC'\n         AIF   ('&TJIDLOC'(1,1) EQ '(').REGFM  REG. FORM MACRO\n.*\n.*   REGULAR FORMAT OF MACRO\n.*\n.EXPAND  CNOP  0,4\n         AIF   ('&TJIDLOC' NE '').LOC   TJLOC SPECIFIED\n&NAME    B     *+12                     BRANCH AROUND CONSTANTS\n         DC    AL2(&ID)                 TJID\n         DC    AL2(&SIZE)               BUFFER SIZE\n         DC    AL1(&OPT)                OPTIONS\n         DC    AL3(&BFF)                BUFFER ADDR\n         LM    0,1,*-8                  LOAD PARAMETER REGISTERS\n.SVC     SVC   93                       ISSUE TGET/TPUT SVC\n         SPACE 1\n         MEXIT\n.*\n.*   TJIDLOC IS SPECIFIED\n.*\n.LOC     ANOP\n&NAME    IC    0,&TJIDLOC               LOAD 1ST BYTE OF TJID\n         SLL   0,8                      SHIFT IT\n         IC    0,&TJIDLOC+1             LOAD 2ND BYTE OF TJID\n         SLL   0,16                     SHIFT TJID TO HI-ORDER BYTE\n         AIF   (&OPT EQ 0).ZERO         BRANCH IF OPTIONS ARE ZERO\n         O     0,*+8                    LOAD BUFFER SIZE\n         B     *+12                     BRANCH AROUND CONSTANT\n         DC    AL2(0)                   TJID\n         DC    AL2(&SIZE)               BUFFER SIZE\n         DC    AL1(&OPT)                OPTIONS\n         DC    AL3(&BFF)                BUFFER ADDR\n         L     1,*-4                    LOAD OPTIONS & BUFFER ADDR\n         AGO   .SVC                     GOTO ISSUE SVC\n.ZERO    LA    1,&SIZE                  LOAD BUFFER SIZE\n         OR    0,1                      OR IT INTO REGISTER 1\n         LA    1,&BFF                   Z HIGH ORDR BYTE & LD BFR ADDR\n         AGO   .SVC                     GOTO ISSUE SVC\n.*\n.*   REGISTER FORMAT\n.*\n.REGFM   AIF   ('&TJIDLOC' EQ '').NOLOC   SKIP IF TJIDLOC NOT SPECIFIED\n         AIF   ('&TJIDLOC'(1,1) EQ '(').REGLOC    LOC IN REG  FORM\n&NAME    IC    15,&TJIDLOC              INSERT 1ST BYTE OF TJID\n         SLL   15,8                     MOVE IT TO NEXT BYTE\n         IC    15,&TJIDLOC+1            INSERT 2ND BYTE OF TJID\n         SLL   15,16                    MOVE TJID TO HI-ORDER 2 BYTES\n         AGO   .CHKSIZE                 GOTO CHECK SIZE\n.REGLOC  ANOP\n&NAME    IC    15,0(,&TJIDLOC(1))       INSERT 1ST BYTE OF TJID\n         SLL   15,8                     MOVE IT TO NEXT BYTE\n         IC    15,1(,&TJIDLOC(1))       INSERT 2ND BYTE OF TJID\n         SLL   15,16                    MOVE TJID TO HI-ORDER 2 BYTES\n         AGO   .CHKSIZE                 GOTO CHECK SIZE\n.*\n.*   WHEN TJIDLOC IS NOT SPECIFIED\n.*\n.NOLOC   AIF   ('&TJID' NE '').TJIDYES\n&NAME    DS    0H                       TJID IS '0'\n         AGO   .CHKSIZE                 GOTO CHECK SIZE\n.TJIDYES AIF   ('&TJID'(1,1) EQ '(').IDREG   TJID IN REG FORM\n&NAME    LA    15,&TJID                 LOAD TJID\n         AGO   .SHIFT                   GOTO SHIFT REG.0\n.IDREG   ANOP\n&NAME    LR    15,&TJID(1)              LOAD TJID IN REG 0\n.SHIFT   SLL   15,16                    SHIFT TJID TO HI-ORDER BYTE\n.*\n.*   CHECK SIZE OF BUFFER (BY NOW TJID IS IN HI-ORDER 2 BYTES OF REG 0)\n.*\n.CHKSIZE AIF   ('&SIZE'(1,1) EQ '(').SZREG   SKIP IF SIZE IN REG\n         LA    0,&SIZE                  LOAD SIZE IN REG.0\n         AGO   .ORSIZE                  GOTO OR SIZE\n.SZREG   AIF   ('&SIZE' EQ '(0)').ORSIZE  GOTO SET SIZE IN REG. 0\n         LR    0,&SIZE(1)               LOAD BUFFER SIZE\n.ORSIZE  AIF   ('&TJID' EQ '' AND '&TJIDLOC' EQ '').PAST\n         OR    0,15                     LOAD TJID + BUFFER SIZE\n.PAST    AIF   (&OPT EQ 0 AND '&BFF'(1,1) EQ '(').ORONE\n         AIF   (&OPT EQ 0 AND '&BFF'(1,1) NE '(').ZOPT ZERO OPTN\n         CNOP  0,4\n         B     *+8\n         DC    AL1(&OPT)                OPTION BITS\n         AIF   ('&BFF'(1,1) EQ '(').REGGO   BFFR IN REG.\n         DC    AL3(&BFF)                BUFFER ADDR\n         L     1,*-4                    LOAD PARAMETER IN REG.1\n         AGO   .SVC                     GOTO ISSUE SVC\n.ZOPT    LA    1,&BFF                   LOAD BUFFER ADDR IN REG 1\n         AGO   .SVC                     ISSUE SVC\n.REGGO   DC    AL3(0)                   BUFFER ADDR\n         AIF   ('&BFF' EQ '(1)').ORONE  GOTO OR OPTIONS\n         L     1,*-4                    LOAD OPTIONS\n         OR    1,&BFF(1)                SET OPTIONS AND BUFFER ADDR\n         AGO   .SVC                     GOTO ISSUE SVC\n.ORONE   LA    1,0(,&BFF(1))            CLR HIGH ORDR BYTE + LD BFR ADR\n         AIF   (&OPT EQ 0).SVC          GOTO ISSUE SVC IF OPT EQ 0\n         O     1,*-8                    SET OPTIONS\n         AGO   .SVC\n.EDI     ANOP\n         AIF   (&E).ERROR2              DUP OPTION\n&E       SETB  1                        EDIT OPTION SPECFIED\n         AGO   .RET\n.ASI     ANOP\n         AIF   (&E).ERROR2              DUP OPTION\n&E       SETB  1                        EDIT OPTION SPECFIED\n&OPT     SETA  &OPT+1                   SET EDIT=ASIS\n         AGO   .RET\n.CON     ANOP\n         AIF   (&E).ERROR2              DUP OPTION\n&E       SETB  1                        EDIT OPTION SPECFIED\n&OPT     SETA  &OPT+2                   SET EDIT=CONTROL\n         AGO   .RET\n.FULLS   ANOP                                                   SA60002\n         AIF   (&E).ERROR2              DUP OPTION              SA60002\n&E       SETB  1                        EDIT OPTION SPECIFIED   SA60002\n&OPT     SETA  &OPT+3                   CNTL+ASIS FOR FULLSCR   SA60002\n         AGO   .RET                                             SA60002\n.WAI     ANOP\n         AIF   (&W).ERROR2              DUP OPTION\n&W       SETB  1                        WAIT OPTION SPECIFIED\n         AGO   .RET\n.NOW     ANOP\n         AIF   (&W).ERROR2              DUP OPTION\n&W       SETB  1                        WAIT OPTION SPECIFIED\n&OPT     SETA  &OPT+X'10'               SET WAIT=NOWAIT\n         AGO   .RET\n.HOL     ANOP\n         AIF   (&H).ERROR2              DUP OPTION\n&H       SETB  1                        HOLD OPTION SPECIFIED\n&OPT     SETA  &OPT+X'08'               SET HOLD=HOLD\n         AGO   .RET\n.NOH     ANOP\n         AIF   (&H).ERROR2              DUP OPTION\n&H       SETB  1                        HOLD OPTION SPECIFIED\n         AGO   .RET\n.BRE     ANOP\n         AIF   (&B).ERROR2              DUP OPTION\n&B       SETB  1                        BREAK OPTION SPECIFIED\n&OPT     SETA  &OPT+X'04'               SET BREAKIN\n         AGO   .RET\n.NOB     ANOP\n         AIF   (&B).ERROR2              DUP OPTION\n&B       SETB  1                        BREAK OPTION SPECIFIED\n         AGO   .RET\n.HPR     ANOP\n         AIF   (&P).ERROR2              DUP OPTION\n&P       SETB  1                        PRIORITY OPTION SPECIFIED\n         AGO   .RET\n.LPR     ANOP\n         AIF   (&P).ERROR2              DUP OPTION\n&P       SETB  1                        PRIORITY OPTION SPECIFIED\n&OPT     SETA  &OPT+X'20'               SET  LOW PRIORITY OPTION\n.RET     ANOP\n&PARM    SETC  '&WAIT'\n         AIF   ('&RET' EQ '1').CKPARM   CHECK WAIT\n&PARM    SETC  '&HOLD'\n         AIF   ('&RET' EQ '2').CKPARM   CHECK HOLD\n&PARM    SETC  '&BRKI'\n         AIF   ('&RET' EQ '3').CKPARM   CHECK BRKI\n&PARM    SETC  '&PRTY'\n         AIF   ('&RET' EQ '4').CKPARM   CHECK PRTY\n         AGO   .CHKREG                  DONE WITH OPTIONS\n.RF      ANOP\n         AIF   ('&WAIT' NE '' OR '&HOLD' NE '' OR '&BRKI' NE '' OR '&PRX\n               TY' NE '' OR '&TJID' NE '' OR '&TJIDLOC' NE '').RERR\n         AIF   ('&BFF'(1,1) NE '(' OR '&SIZE'(1,1) NE '(').RERR\n&NAME    DS    0H\n         AIF   ('&BFF' EQ '(1)').SIZE\n         LR    1,&BFF(1)                LOAD OPTIONS & BUFFER ADDR\n.SIZE    AIF   ('&SIZE' EQ '(0)').SVC\n         LR    0,&SIZE(1)               LOAD TJID & BUFFER SIZE\n         AGO   .SVC\n.RERR    IHBERMAC 192\n         MEXIT\n.ERROR1  IHBERMAC 24\n         MEXIT\n.ERROR2  IHBERMAC 54,,,\n         MEXIT\n.ERROR3  IHBERMAC 49,,&PARM\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WRTERM": {"ttr": 13835, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19R\\x00\\x82\\x00\\x82\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:52:00", "lines": 130, "newlines": 130, "modlines": 0, "user": "CBT249"}, "text": "         MACRO                                                          WRT00010\n&LABEL   WRTERM &UMSG,&ULEN,&EDIT=YES,&COLOR=B                          WRT00020\n         LCLA  &PNT,&CNT,&END                                           WRT00030\n         LCLC  &FLG,&CLR,&LEN,&MSG                                      WRT00040\n         LCLB  &MR,&LR,&MSD                                             WRT00050\n.****                                                                   WRT00060\n.** LCLA'S USED TO COMPUTE LENGTH OF SELF-DEFINING MESSAGE              WRT00070\n.** LCLC'S USED TO ASSEMBLE PLIST VALUES                                WRT00080\n.** LCLB'S CONTAIN CODE-GENERATION FLAGS                                WRT00090\n.****                                                                   WRT00100\n.** MAKE SURE A MESSAGE OF SOME TYPE WAS GIVEN, AND NOTE                WRT00110\n.** IF IT'S SELF-DEFINING OR GIVEN AS A REGISTER                        WRT00120\n.****                                                                   WRT00130\n         AIF   (T'&UMSG NE 'O').UMSGOK                                  WRT00140\n         MNOTE 8,'LINE ADDRESS NOT SPECIFIED'                           WRT00150\n         MEXIT                                                          WRT00160\n.*                                                                      WRT00170\n.UMSGOK  AIF   ('&UMSG'(1,1) NE '''').UMSGR                             WRT00180\n&MSD     SETB  1              NOTE SELF-DEFINING MSG                    WRT00190\n&MSG     SETC  'DMS&SYSNDX.D' ASSEMBLE MSG-ADDRESS                      WRT00200\n         AGO   .UMSGZ                                                   WRT00210\n.*                                                                      WRT00220\n.UMSGR   AIF   ('&UMSG'(1,1) NE '(').UMSGA                              WRT00230\n&MR      SETB  1              NOTE MSG REGISTER-ADDRESSED               WRT00240\n&MSG     SETC  '&UMSG(1)'     DUMMY ASSEMBLE-VALUE                      WRT00250\n         AGO   .UMSGZ                                                   WRT00260\n.*                                                                      WRT00270\n.UMSGA   ANOP                                                           WRT00280\n&MSG     SETC  '&UMSG'        MESSAGE SYMBOLIC NAME                     WRT00290\n.UMSGZ   ANOP                                                           WRT00300\n.****                                                                   WRT00310\n.** GET THE VALUE OF THE MESSAGE LENGTH.  COMPUTE IT, IF IT             WRT00320\n.** WASN'T GIVEN OR IF THE MESSAGE IS SELF-DEFINING.                    WRT00330\n.****                                                                   WRT00340\n         AIF   (T'&ULEN EQ 'O').ULENO                                   WRT00350\n         AIF   ('&ULEN'(1,1) EQ '(').ULENR                              WRT00360\n&LEN     SETC  '&ULEN'        SELF-DEFINING LENGTH                      WRT00370\n         AGO   .ULENZ                                                   WRT00380\n.*                                                                      WRT00390\n.ULENR   ANOP                                                           WRT00400\n&LR      SETB  1              NOTE LENGTH IN REGISTER                   WRT00410\n         AGO   .COMPL                                                   WRT00420\n.*                                                                      WRT00430\n.ULENO   AIF   (&MSD).COMPL                                             WRT00440\n         MNOTE 8,'LENGTH PARAMETER NOT SPECIFIED'                       WRT00450\n         MEXIT                                                          WRT00460\n.*                                                                      WRT00470\n.COMPL   ANOP                 PREPARE TO COMPUTE MSG-LENGTH             WRT00480\n&PNT     SETA  2              FIRST-CHARACTER INDEX                     WRT00490\n&END     SETA  K'&UMSG-2      LAST CHARACTER INDEX                      WRT00500\n         AIF   (&END GT 0).COMPGO                                       WRT00510\n         MNOTE 8,'INVALID LINE SPECIFICATION'                           WRT00520\n         MEXIT                                                          WRT00530\n.*                                                                      WRT00540\n.COMPGO  AIF   (&PNT GT &END).COMPZ                                     WRT00550\n         AIF   ('&UMSG'(&PNT,2) EQ '''''').QUOTE                        WRT00560\n&PNT     SETA  &PNT+1                                                   WRT00570\n         AGO   .COMPGO                                                  WRT00580\n.QUOTE   ANOP                                                           WRT00590\n&CNT     SETA  &CNT+1                                                   WRT00600\n&PNT     SETA  &PNT+2                                                   WRT00610\n         AGO   .COMPGO                                                  WRT00620\n.COMPZ   ANOP                                                           WRT00630\n&CNT     SETA  K'&UMSG-&CNT-2                                           WRT00640\n&LEN     SETC  '&CNT'         ASSEMBLE LENGTH-VALUE                     WRT00650\n.*                                                                      WRT00660\n.ULENZ   ANOP                                                           WRT00670\n.****                                                                   WRT00680\n.** EXAMINE THE EDIT PARAMETER, TRANSLATE IT TO                         WRT00690\n.** FLAG BITS FOR 'DMSCWR' TO USE.                                      WRT00700\n.****                                                                   WRT00710\n&FLG     SETC  '00'                                                     WRT00720\n         AIF   ('&EDIT' EQ 'YES').UEDITZ                                WRT00730\n&FLG     SETC  '80'                                                     WRT00740\n         AIF   ('&EDIT' EQ 'NO').UEDITZ                                 WRT00750\n&FLG     SETC  '90'                                                     WRT00760\n         AIF   ('&EDIT' EQ 'LONG').UEDITZ                               WRT00770\n         MNOTE 4,'INVALID EDIT SPECIFICATION - YES ASSUMED'             WRT00780\n&FLG     SETC  '00'                                                     WRT00790\n.UEDITZ  ANOP                                                           WRT00800\n.****                                                                   WRT00810\n.** EXAMINE THE COLOR PARAMETER FOR 'B' OR 'R'                          WRT00820\n.****                                                                   WRT00830\n&CLR     SETC  'B'                                                      WRT00840\n         AIF   ('&COLOR' EQ 'B').UCLRZ                                  WRT00850\n         AIF   ('&FLG' EQ '90').UCLRERR                                 WRT00860\n         AIF   ('&COLOR' NE 'R').UCLRERR                                WRT00870\n&CLR     SETC  'R'                                                      WRT00880\n         AGO   .UCLRZ                                                   WRT00890\n.UCLRERR MNOTE 4,'INVALID COLOR SPECIFICATION - B ASSUMED'              WRT00900\n.UCLRZ   ANOP                                                           WRT00910\n.****                                                                   WRT00920\n.** ALIGN TO A WORD, GENERATE LABEL                                     WRT00930\n.****                                                                   WRT00940\n         CNOP  0,4                                                      WRT00950\n&LABEL   DS    0H                                                       WRT00960\n.****                                                                   WRT00970\n.** GENERATE ADDRESS-STORE, IF NEEDED.                                  WRT00980\n.****                                                                   WRT00990\n         AIF   (NOT &MR).CONT5                                          WRT01000\n         ST    &MSG,DMS&SYSNDX.B  STORE MESSAGE-ADDRESS                 WRT01010\n         MVI   DMS&SYSNDX.B,X'01' RESTORE FLAG                          WRT01020\n.CONT5   ANOP                                                           WRT01030\n.****                                                                   WRT01040\n.** GENERATE LENGTH-STORE, IF NEEDED                                    WRT01050\n.****                                                                   WRT01060\n         AIF   (NOT &LR).CONT6                                          WRT01070\n         STH   &ULEN(1),DMS&SYSNDX.C+2  STORE LENGTH IN PLIST           WRT01080\n.CONT6   ANOP                                                           WRT01090\n.****                                                                   WRT01100\n.** GENERATE PLIST, BAL ON R1 AROUND IT                                 WRT01110\n.****                                                                   WRT01120\n         BAL   1,DMS&SYSNDX.E  POINT R1 TO PLIST                        WRT01130\nDMS&SYSNDX.A DC   CL8'TYPLIN'                                           WRT01140\nDMS&SYSNDX.B DC   X'01',AL3(&MSG)                                       WRT01150\nDMS&SYSNDX.C DC   C'&CLR',X'&FLG',AL2(&LEN)                             WRT01160\n.****                                                                   WRT01170\n.** GENERATE MESSAGE TEXT, IF SELF-DEFINING                             WRT01180\n.****                                                                   WRT01190\n         AIF   (NOT &MSD).CONTZ                                         WRT01200\nDMS&SYSNDX.D DC   CL&LEN&UMSG                                           WRT01210\n.CONTZ   ANOP                                                           WRT01220\n.****                                                                   WRT01230\n.** GENERATE SVC, ALIGNED ON HALFWORD                                   WRT01240\n.****                                                                   WRT01250\nDMS&SYSNDX.E DS   0H                                                    WRT01260\n         SVC   202            CALL CMS TO TYPE                          WRT01270\n         DC    AL4(*+4)                                                 WRT01280\n         MEXIT                                                          WRT01290\n         MEND                                                           WRT01300\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT282/FILE282.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT282", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}