{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013356000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 293930, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE903.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE903.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x06\\x03'", "DS1TRBAL": "b'\\xb3\\xb2'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x08\\xdc\\x00\\x00\\x08\\xdc\\x00\\x06\\x00\\x07'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04X\\x00!\\x01\\x132O\\x01\\x132O\"Y\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf8@@@'", "ispf": {"version": "04.88", "flags": 0, "createdate": "2013-11-20T00:00:00", "modifydate": "2013-11-20T22:59:21", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-488"}, "text": "REGULAR CBT TAPE - VERSION 488    FILE:  903\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT488.FILE903\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 18 MEMBERS COUNTED; CUMULATIVE SIZE IS 2,343 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/20/13    22:59:20    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$FMTDOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x132O\\x01\\x132O\"V\\x002\\x002\\x00\\x00\\xd1\\xc1\\xe8\\xc6\\xd6\\xd9\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-20T00:00:00", "modifydate": "2013-11-20T22:56:54", "lines": 50, "newlines": 50, "modlines": 0, "user": "JAYFORM"}, "text": "Input/Output Field Editing Routines\n\n    (Assembler)  I first started putting together this collection\n    when I discovered BIF DEDIT didn't do much for fields entered\n    into my CICS programs.  But the collection first became a\n    set, and also became re-entrant, back in 1993 when I had some\n    spare time.  The logic for the numbers to words routine\n    (OFMTMONY) was originally in written in COBOL back in 1976\n    when another programmer told me I couldn't write the routine\n    in COBOL efficiently enough to run in production.\n\n    I updated the installation procedure on September 3, 2003.\n    So if you have an earlier version, and have checked back here\n    and are worried that the version you got on an earlier date\n    needs updating, relax.  There have been no significant\n    changes to the routines themselves, just an update to the\n    jobstreams that load them onto your system.  And I made a\n    minor change to the Installation Verification COBOL program's\n    report (the output for IFMTLJST was not printing the field\n    returned from the assembler routine).\n\n    The installation/verification jobstream is in fmt$load.tgz\n    \u00ddMD5: DF68D84AB0B125FB0797D25DCEF4254D\u00a8.  This is an IEBUPDTE\n    job that will create a PDS containing the assembler and COBOL\n    source and three jobstreams, plus an index member ($INDEX).\n    As configured for my system, the source/jobstream PDS is on a\n    3330, VOL=SER=JAY001, and is named JAY01.FORMAT.SOURCE.  You\n    will probably want to change all of those parameters for your\n    system.  When the installation jobs run, they will create a\n    PDS load library.  Again, on my system it is configured to\n    reside on the same 3330 as the source library and is named\n    JAY01.FORMAT.LOADLIB.  These two datasets are referenced in a\n    number of DD cards in the jobstreams, so it would probably be\n    easiest for you to use a text editor on your host OS\n    (Linux/Windows/???) and make all the changes in the \"reload\"\n    jobstream before you submit it to MVS.\n\n    Once the changes above are correct for your system, and you\n    have created the source/JCL PDS, submit the jobstream:\n    FMT$INST from the source/JCL PDS.  The first step of this job\n    deletes the target load library so you can resubmit this job\n    if you need to restart it or want to recreate the load\n    library for any reason.  The second step simply submits the\n    jobstream:  FMT$ASM from the source/JCL PDS.  This job\n    assembles and link-edits all eight of the routines to the\n    load library PDS.  If you want to run the installation\n    verification program, submit the jobstream:  FMT$IVP.  This\n    will compile and run a COBOL program which calls all the\n    routines with a test data value.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$INDEX": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\'\\x01\\x132O\\x01\\x132O\"X\\x00\\x11\\x00\\x0f\\x00\\x00\\xd1\\xc1\\xe8\\xc6\\xd6\\xd9\\xd4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-11-20T00:00:00", "modifydate": "2013-11-20T22:58:27", "lines": 17, "newlines": 15, "modlines": 0, "user": "JAYFORM"}, "text": "This is the partitioned dataset for the Format/Edit routines.\n\n$FMTDOC  - documentation of the history of this collection\n$INDEX   - this text\nEYEC     - ALC macro\nFMT$ASM  - jobstream to assemble/link the routines\nFMT$INST - jobstream to allocate load library & submit FMT$ASM\nFMT$IVP  - jobstream to run the installation verification program\nFMTIVP   - COBOL Installation Verification program\nIFMTFILL - input field must be filled\nIFMTFLPT - input field floating point format\nIFMTHEX  - input field hex digits\nIFMTLJST - input field left justify\nIFMTMASK - input field extract using mask\nIFMTNIB  - input field no imbedded blanks\nOFMTHEX  - output field printable hex digits\nOFMTMONY - output field monetary field as words\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE903": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04X\\x00\\x07\\x01\\x132O\\x01\\x132O\"Y\\x00\\x17\\x00\\x17\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf8@@@'", "ispf": {"version": "04.88", "flags": 0, "createdate": "2013-11-20T00:00:00", "modifydate": "2013-11-20T22:59:07", "lines": 23, "newlines": 23, "modlines": 0, "user": "CBT-488"}, "text": "//***FILE 903 is from Jay Moseley and contains field formatting     *   FILE 903\n//*           routines that can be used in CICS transactions to     *   FILE 903\n//*           verify the contents of entered fields.                *   FILE 903\n//*                                                                 *   FILE 903\n//*           email:  dino@jaymoseley.com                           *   FILE 903\n//*                                                                 *   FILE 903\n//*     Description of PDS members:                                 *   FILE 903\n//*     EYEC     - ALC macro                                        *   FILE 903\n//*     FMT$ASM  - jobstream to assemble/link the routines          *   FILE 903\n//*     FMT$INST - jobstream to allocate load library & submit      *   FILE 903\n//*                FMT$ASM                                          *   FILE 903\n//*     FMT$IVP  - jobstream to run the installation                *   FILE 903\n//*                verification program                             *   FILE 903\n//*     FMTIVP   - COBOL Installation Verification program          *   FILE 903\n//*     IFMTFILL - input field must be filled                       *   FILE 903\n//*     IFMTFLPT - input field floating point format                *   FILE 903\n//*     IFMTHEX  - input field hex digits                           *   FILE 903\n//*     IFMTLJST - input field left justify                         *   FILE 903\n//*     IFMTMASK - input field extract using mask                   *   FILE 903\n//*     IFMTNIB  - input field no imbedded blanks                   *   FILE 903\n//*     OFMTHEX  - output field printable hex digits                *   FILE 903\n//*     OFMTMONY - output field monetary field as words             *   FILE 903\n//*                                                                 *   FILE 903\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EYEC": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132O\\x01\\x132O\"A\\x00\\x0c\\x00\\x0c\\x00\\x00\\xd1\\xc1\\xe8\\xc6\\xd6\\xd9\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-20T00:00:00", "modifydate": "2013-11-20T22:41:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "JAYFORM"}, "text": "         MACRO\n         EYEC  &DESC\nEC$$B    B     EC$$L(,R15)             BRANCH AROUND EYECATCHER\n         DC    AL1(EC$$E-EC$$V)        LENGTH OF VERSION INFO\nEC$$V    DC    C'&SYSECT '             CSECT NAME\n         DC    C'&SYSDATE &SYSTIME - '  WHEN ASSEMBLED\n         AIF   (T'&DESC EQ 'O').NODESC\n         DC    C&DESC\n.NODESC  ANOP\nEC$$E    DS    0H\nEC$$L    EQU   (*-EC$$B)               LENGTH OF EYECATCHER FIELDS\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FMT$ASM": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132O\\x01\\x132O\"A\\x00_\\x00_\\x00\\x00\\xd1\\xc1\\xe8\\xc6\\xd6\\xd9\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-20T00:00:00", "modifydate": "2013-11-20T22:41:00", "lines": 95, "newlines": 95, "modlines": 0, "user": "JAYFORM"}, "text": "//FMT$ASM  JOB (FMT),'ASSEMBLE FMT',CLASS=A,MSGCLASS=X,COND=(0,NE)\n//ALLOC   EXEC PGM=IEFBR14\n//LLIB     DD  DSN=JAY01.FORMAT.LOADLIB,DISP=(NEW,CATLG,DELETE),\n//             UNIT=3330,VOL=SER=JAY001,\n//             SPACE=(TRK,(38,19,10)),DCB=(SYS1.LINKLIB)\n//*****************************************************************\n//IFILL EXEC ASMFCL,PARM.ASM='LIST,OBJECT,NODECK,RENT',\n//             MAC1='JAY01.FORMAT.SOURCE',\n//             PARM.LKED='LIST,XREF,MAP,RENT,REUS'\n//ASM.SYSPRINT DD SYSOUT=*\n//ASM.SYSIN DD DISP=SHR,DSN=JAY01.FORMAT.SOURCE(IFMTFILL)\n//LKED.SYSLMOD DD DSN=JAY01.FORMAT.LOADLIB,DISP=OLD\n//LKED.SYSPRINT DD SYSOUT=*\n//LKED.SYSLIB DD DSN=JAY01.FORMAT.LOADLIB,DISP=SHR\n//LKED.SYSIN DD *\n  NAME IFMTFILL(R)\n//*****************************************************************\n//IFLPT EXEC ASMFCL,PARM.ASM='LIST,OBJECT,NODECK,RENT',\n//             MAC1='JAY01.FORMAT.SOURCE',\n//             PARM.LKED='LIST,XREF,MAP,RENT,REUS'\n//ASM.SYSPRINT DD SYSOUT=*\n//ASM.SYSIN DD DISP=SHR,DSN=JAY01.FORMAT.SOURCE(IFMTFLPT)\n//LKED.SYSLMOD DD DSN=JAY01.FORMAT.LOADLIB,DISP=OLD\n//LKED.SYSPRINT DD SYSOUT=*\n//LKED.SYSLIB DD DSN=JAY01.FORMAT.LOADLIB,DISP=SHR\n//LKED.SYSIN DD *\n  NAME IFMTFLPT(R)\n//*****************************************************************\n//IHEX EXEC ASMFCL,PARM.ASM='LIST,OBJECT,NODECK,RENT',\n//             MAC1='JAY01.FORMAT.SOURCE',\n//             PARM.LKED='LIST,XREF,MAP,RENT,REUS'\n//ASM.SYSPRINT DD SYSOUT=*\n//ASM.SYSIN DD DISP=SHR,DSN=JAY01.FORMAT.SOURCE(IFMTHEX)\n//LKED.SYSLMOD DD DSN=JAY01.FORMAT.LOADLIB,DISP=OLD\n//LKED.SYSPRINT DD SYSOUT=*\n//LKED.SYSLIB DD DSN=JAY01.FORMAT.LOADLIB,DISP=SHR\n//LKED.SYSIN DD *\n  NAME IFMTHEX(R)\n//*****************************************************************\n//ILJST EXEC ASMFCL,PARM.ASM='LIST,OBJECT,NODECK,RENT',\n//             MAC1='JAY01.FORMAT.SOURCE',\n//             PARM.LKED='LIST,XREF,MAP,RENT,REUS'\n//ASM.SYSPRINT DD SYSOUT=*\n//ASM.SYSIN DD DISP=SHR,DSN=JAY01.FORMAT.SOURCE(IFMTLJST)\n//LKED.SYSLMOD DD DSN=JAY01.FORMAT.LOADLIB,DISP=OLD\n//LKED.SYSPRINT DD SYSOUT=*\n//LKED.SYSLIB DD DSN=JAY01.FORMAT.LOADLIB,DISP=SHR\n//LKED.SYSIN DD *\n  NAME IFMTLJST(R)\n//*****************************************************************\n//IMASK EXEC ASMFCL,PARM.ASM='LIST,OBJECT,NODECK,RENT',\n//             MAC1='JAY01.FORMAT.SOURCE',\n//             PARM.LKED='LIST,XREF,MAP,RENT,REUS'\n//ASM.SYSPRINT DD SYSOUT=*\n//ASM.SYSIN DD DISP=SHR,DSN=JAY01.FORMAT.SOURCE(IFMTMASK)\n//LKED.SYSLMOD DD DSN=JAY01.FORMAT.LOADLIB,DISP=OLD\n//LKED.SYSPRINT DD SYSOUT=*\n//LKED.SYSLIB DD DSN=JAY01.FORMAT.LOADLIB,DISP=SHR\n//LKED.SYSIN DD *\n  NAME IFMTMASK(R)\n//*****************************************************************\n//INIB EXEC ASMFCL,PARM.ASM='LIST,OBJECT,NODECK,RENT',\n//             MAC1='JAY01.FORMAT.SOURCE',\n//             PARM.LKED='LIST,XREF,MAP,RENT,REUS'\n//ASM.SYSPRINT DD SYSOUT=*\n//ASM.SYSIN DD DISP=SHR,DSN=JAY01.FORMAT.SOURCE(IFMTNIB)\n//LKED.SYSLMOD DD DSN=JAY01.FORMAT.LOADLIB,DISP=OLD\n//LKED.SYSPRINT DD SYSOUT=*\n//LKED.SYSLIB DD DSN=JAY01.FORMAT.LOADLIB,DISP=SHR\n//LKED.SYSIN DD *\n  NAME IFMTNIB(R)\n//*****************************************************************\n//OHEX EXEC ASMFCL,PARM.ASM='LIST,OBJECT,NODECK,RENT',\n//             MAC1='JAY01.FORMAT.SOURCE',\n//             PARM.LKED='LIST,XREF,MAP,RENT,REUS'\n//ASM.SYSPRINT DD SYSOUT=*\n//ASM.SYSIN DD DISP=SHR,DSN=JAY01.FORMAT.SOURCE(OFMTHEX)\n//LKED.SYSLMOD DD DSN=JAY01.FORMAT.LOADLIB,DISP=OLD\n//LKED.SYSPRINT DD SYSOUT=*\n//LKED.SYSLIB DD DSN=JAY01.FORMAT.LOADLIB,DISP=SHR\n//LKED.SYSIN DD *\n  NAME OFMTHEX(R)\n//*****************************************************************\n//OMONY EXEC ASMFCL,PARM.ASM='LIST,OBJECT,NODECK,RENT',\n//             MAC1='JAY01.FORMAT.SOURCE',\n//             PARM.LKED='LIST,XREF,MAP,RENT,REUS'\n//ASM.SYSPRINT DD SYSOUT=*\n//ASM.SYSIN DD DISP=SHR,DSN=JAY01.FORMAT.SOURCE(OFMTMONY)\n//LKED.SYSLMOD DD DSN=JAY01.FORMAT.LOADLIB,DISP=OLD\n//LKED.SYSPRINT DD SYSOUT=*\n//LKED.SYSLIB DD DSN=JAY01.FORMAT.LOADLIB,DISP=SHR\n//LKED.SYSIN DD *\n  NAME OFMTMONY(R)\n//*****************************************************************\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FMT$INST": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132O\\x01\\x132O\"A\\x00\\x14\\x00\\x14\\x00\\x00\\xd1\\xc1\\xe8\\xc6\\xd6\\xd9\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-20T00:00:00", "modifydate": "2013-11-20T22:41:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "JAYFORM"}, "text": "//FMT$INST JOB (FMT),'INSTALL FMT',CLASS=A,MSGCLASS=A\n//DELETE  EXEC PGM=IDCAMS,REGION=4096K\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  *\n\n  /* DELETE FORMAT ROUTINES LOAD LIBRARY                    */\n\n  DELETE (JAY01.FORMAT.LOADLIB)                                -\n         NONVSAM SCRATCH PURGE\n\n  SET MAXCC=0\n  SET LASTCC=0\n\n//*****************************************************************\n//SUBMIT  EXEC PGM=IEBGENER\n//SYSIN    DD  DUMMY\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=JAY01.FORMAT.SOURCE(FMT$ASM),DISP=SHR\n//SYSUT2   DD  SYSOUT=(A,INTRDR)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FMT$IVP": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132O\\x01\\x132O\"A\\x00\\t\\x00\\t\\x00\\x00\\xd1\\xc1\\xe8\\xc6\\xd6\\xd9\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-20T00:00:00", "modifydate": "2013-11-20T22:41:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "JAYFORM"}, "text": "//FMT$IVP JOB (FMT),'FMT VERIFY',CLASS=A,MSGCLASS=A\n//FMTIVP EXEC COBUCLG,REGION.COB=4096K,\n//             PARM.COB='LOAD,LIST,DMAP,SIZE=2048K,BUF=1024K'\n//COB.SYSIN DD DSN=JAY01.FORMAT.SOURCE(FMTIVP),DISP=SHR\n//LKED.SYSLIB DD\n//         DD DSN=JAY01.FORMAT.LOADLIB,DISP=SHR\n//GO.TESTDATA DD DSN=JAY01.FORMAT.SOURCE(FMTIVPD),DISP=SHR\n//GO.REPORT DD SYSOUT=*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FMTIVP": {"ttr": 533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132O\\x01\\x132O\"A\\x01\\xfe\\x01\\xfe\\x00\\x00\\xd1\\xc1\\xe8\\xc6\\xd6\\xd9\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-20T00:00:00", "modifydate": "2013-11-20T22:41:00", "lines": 510, "newlines": 510, "modlines": 0, "user": "JAYFORM"}, "text": "000100 IDENTIFICATION DIVISION.\n000200 PROGRAM-ID. FMTIVP.\n000300 AUTHOR. JAY MOSELEY.\n000400 DATE-WRITTEN. JULY, 2000.\n000500 DATE-COMPILED.\n000600\n000700* ************************************************************* *\n000800* THE PURPOSE OF THIS PROGRAM IS TO VERIFY THE FUNCTIONALITY    *\n000900* OF THE 370 ASSEMBLER FIELD INPUT/OUTPUT FORMATTING ROUTINES   *\n001000* AFTER THEIR INSTALLATION UNDER HERCULES/MVT.                  *\n001100* ************************************************************* *\n001200/\n001300 ENVIRONMENT DIVISION.\n001400 CONFIGURATION SECTION.\n001500 SPECIAL-NAMES.\n001600     C01 IS TO-FIRST-LINE.\n001700 INPUT-OUTPUT SECTION.\n001800 FILE-CONTROL.\n001900     SELECT DATA-FILE\n002000         ASSIGN TO UT-S-TESTDATA.\n002100\n002200     SELECT PRINT-FILE\n002300         ASSIGN TO UR-S-REPORT.\n002400 DATA DIVISION.\n002500\n002600 FILE SECTION.\n002700 FD  DATA-FILE\n002800     LABEL RECORDS ARE STANDARD\n002850     BLOCK CONTAINS 0 RECORDS\n002900     RECORD CONTAINS 80 CHARACTERS\n003000     DATA RECORD IS DATA-RECD.\n003100 01  DATA-RECORD                 PIC X(80).\n003200\n003300 FD  PRINT-FILE\n003400     LABEL RECORDS ARE OMITTED\n003500     RECORD CONTAINS 133 CHARACTERS\n003600     DATA RECORD IS PRINT-RECD.\n003700 01  PRINT-RECORD               PIC X(133).\n003800/\n003900 WORKING-STORAGE SECTION.\n004000\n004100* ************************************************************* *\n004200* THESE ARE PROGRAM CONTROL SWITCHES AND MISCELLANEOUS FIELDS.  *\n004300* ************************************************************* *\n004400 01  PROGRAM-CONTROL-FIELDS.\n004500     02  END-OF-DATA-SWITCH      PIC X(1) VALUE 'N'.\n004600         88  END-OF-DATA         VALUE 'Y'.\n004700     02  SYSTEM-TIME             PIC 9(8).\n004800     02  FILLER                  REDEFINES SYSTEM-TIME.\n004900         03  SYSTEM-TIME-SHORT   PIC 9(4).\n005000         03  FILLER              PIC 9(4).\n005100     02  PAGE-COUNT              PIC 999 VALUE ZERO.\n005200     02  LINE-COUNT              PIC 99  VALUE 99.\n005300     02  PAGE-SIZE               PIC 99  VALUE 42.\n005400\n005500     02  UNFORMATTED-GDATE       PIC X(8).\n005600     02  FILLER                  REDEFINES UNFORMATTED-GDATE.\n005700         03  UNFORMATTED-GMONTH  PIC 9(2).\n005800         03  UNFORMATTED-GDAY    PIC 9(2).\n005900         03  UNFORMATTED-GYEAR   PIC 9(4).\n006000\n006100     02  FORMATTED-GDATE         PIC X(10).\n006200     02  FILLER                  REDEFINES FORMATTED-GDATE.\n006300         03  FORMATTED-GMONTH    PIC Z9.\n006400         03  FILLER              PIC X(1).\n006500         03  FORMATTED-GDAY      PIC 9(2).\n006600         03  FILLER              PIC X(1).\n006700         03  FORMATTED-GYEAR     PIC 9(4).\n006800\n006900* ************************************************************* *\n007000* FOLLOWING ARE SPECIFIC RECORD DESCRIPTIONS USED TO REDEFINE   *\n007100* THE TEST DATA INPUT RECORD FOR EACH OF THE 12 ROUTINES.       *\n007200* ************************************************************* *\n007300 01  TEST-RECORD.\n007400     02  TR-IDENTIFICATION       PIC X(4).\n007500     02  FILLER                  PIC X(1).\n007600     02  TR-DATA                 PIC X(75).\n007700\n007800     02  FILLER                  REDEFINES TR-DATA.\n007900         03  TR-FILL-DATA        PIC X(12).\n008000         03  FILLER              PIC X(1).\n008100         03  TR-FILL-SIZE        PIC 9(2).\n008200         03  FILLER              PIC X(60).\n008300\n008400     02  FILLER                  REDEFINES TR-DATA.\n008500         03  TR-FLPT-DATA        PIC X(12).\n008600         03  FILLER              PIC X(1).\n008700         03  TR-FLPT-SIZE        PIC 9(2).\n008800         03  FILLER              PIC X(60).\n008900\n009000     02  FILLER                  REDEFINES TR-DATA.\n009100         03  TR-IHEX-DATA        PIC X(12).\n009200         03  FILLER              PIC X(1).\n009300         03  TR-IHEX-SIZE        PIC 9(2).\n009400         03  FILLER              PIC X(60).\n009500\n009600     02  FILLER                  REDEFINES TR-DATA.\n009700         03  TR-LJST-DATA        PIC X(12).\n009800         03  FILLER              PIC X(1).\n009900         03  TR-LJST-SIZE        PIC 9(2).\n010000         03  FILLER              PIC X(60).\n010100\n010200     02  FILLER                  REDEFINES TR-DATA.\n010300         03  TR-MASK-DATA        PIC X(16).\n010400         03  FILLER              PIC X(1).\n010500         03  TR-MASK-SIZE        PIC 9(2).\n010600         03  FILLER              PIC X(1).\n010700         03  TR-MASK-MASK        PIC X(16).\n010800         03  FILLER              PIC X(39).\n010900\n011000     02  FILLER                  REDEFINES TR-DATA.\n011100         03  TR-NIB-DATA         PIC X(12).\n011200         03  FILLER              PIC X(1).\n011300         03  TR-NIB-SIZE         PIC 9(2).\n011400         03  FILLER              PIC X(60).\n011500\n011600     02  FILLER                  REDEFINES TR-DATA.\n011700         03  TR-OHEX-DATA        PIC X(12).\n011800         03  FILLER              PIC X(1).\n011900         03  TR-OHEX-SIZE        PIC 9(2).\n012000         03  FILLER              PIC X(60).\n012100\n012200     02  FILLER                  REDEFINES TR-DATA.\n012300         03  TR-MONY-DATA        PIC S9(11)V9(2).\n012400         03  FILLER              PIC X(62).\n012500\n012600* ************************************************************* *\n012700* FOLLOWING ARE INTERMEDIATE FIELDS USING TO PREPARE AND        *\n012800* INTERPRET DATA PASSED TO/FROM THE ROUTINES                    *\n012900* ************************************************************* *\n013000 01  INTER-PROGRAM-DATA.\n013100     02  FIELD-SIZE              PIC S9(4)   COMP.\n013200\n013300     02  FLPT-OUTPUT             PIC S9(11)V9(7).\n013400\n013500     02  OUTPUT-FIELD            PIC X(160).\n013600     02  FILLER                  REDEFINES OUTPUT-FIELD.\n013700         03  OUTPUT-NUMEDIT      PIC 9(11)V9(7)-.\n013800         03  FILLER              PIC X(141).\n013900     02  FILLER                  REDEFINES OUTPUT-FIELD.\n014000         03  OUTPUT-CHUNK1       PIC X(55).\n014100         03  OUTPUT-CHUNK2       PIC X(55).\n014200         03  OUTPUT-CHUNK3       PIC X(50).\n014300\n014400* ************************************************************* *\n014500* FOLLOWING ARE THE REPORT HEADING AND DETAIL DESCRIPTIONS.     *\n014600* ************************************************************* *\n014700\n014800 01  HEADING-1.\n014900     02  FILLER  PIC X(1) VALUE ' '.\n015000     02  FILLER  PIC X(6) VALUE 'DATE: '.\n015100     02  H1-DATE PIC X(8).\n015200     02  FILLER  PIC X(32) VALUE SPACES.\n015300     02  FILLER  PIC X(36) VALUE\n015400         'INPUT/OUTPUT FIELD EDIT SUBROUTINES '.\n015500     02  FILLER  PIC X(35) VALUE SPACES.\n015600     02  FILLER  PIC X(15) VALUE 'PROGRAM: FMTIVP'.\n015700\n015800 01  HEADING-2.\n015900     02  FILLER  PIC X(1) VALUE ' '.\n016000     02  FILLER  PIC X(6) VALUE 'TIME: '.\n016100     02  H2-TIME PIC X(5).\n016200     02  FILLER  PIC X(36) VALUE SPACES.\n016300     02  FILLER  PIC X(33) VALUE\n016400         'INSTALLATION VERIFICATION PROGRAM'.\n016500     02  FILLER  PIC X(40) VALUE SPACES.\n016600     02  FILLER  PIC X(9) VALUE 'PAGE:   '.\n016700     02  H2-PAGE PIC ZZ9.\n016800\n016900 01  HEADING-3.\n017000     02  FILLER  PIC X(1) VALUE ' '.\n017100     02  FILLER  PIC X(22) VALUE\n017200         'TEST DATA INPUT RECORD'.\n017300     02  FILLER  PIC X(39) VALUE SPACES.\n017400     02  FILLER  PIC X(7) VALUE 'ROUTINE'.\n017500     02  FILLER  PIC X(2) VALUE SPACES.\n017600     02  FILLER  PIC X(3) VALUE 'R/C'.\n017700     02  FILLER  PIC X(59) VALUE SPACES.\n017800\n017900 01  DETAIL-LINE.\n018000     02  FILLER  PIC X(1) VALUE ' '.\n018100     02  DL-TEST-RECORD          PIC X(50).\n018200     02  FILLER                  PIC X(11) VALUE SPACES.\n018300     02  DL-ROUTINE-NAME         PIC X(7).\n018400     02  FILLER                  PIC X(2) VALUE SPACES.\n018500     02  DL-SLASH-1              PIC X.\n018600     02  DL-RETURN-CODE          PIC 9.\n018610     02  DL-RETURN-CODE-X        REDEFINES DL-RETURN-CODE\n018620                                 PIC X.\n018700     02  DL-SLASH-2              PIC X.\n018800     02  FILLER                  PIC X(2) VALUE SPACES.\n018900     02  DL-COMMON-FORMAT        PIC X(57).\n019000\n019100 01  DETAIL-FLPT.\n019200     02  DCONV-DATEG             PIC X(10).\n019300     02  FILLER                  PIC X(2) VALUE SPACES.\n019400     02  DCONV-DATEJ             PIC X(8).\n019500     02  FILLER                  PIC X(2) VALUE SPACES.\n019600     02  DCONV-ANUM              PIC 9,999,999.\n019700/\n019800 PROCEDURE DIVISION.\n019900\n020000 0000-MAIN SECTION.\n020100\n020200 0050-SETUP.\n020300     MOVE TIME-OF-DAY TO UNFORMATTED-GDATE.\n020400     MOVE '  :  ' TO FORMATTED-GDATE.\n020500     MOVE UNFORMATTED-GMONTH TO FORMATTED-GMONTH.\n020600     MOVE UNFORMATTED-GDAY   TO FORMATTED-GDAY.\n020700     MOVE FORMATTED-GDATE TO H2-TIME.\n020800     MOVE CURRENT-DATE TO H1-DATE.\n020900\n021000 0100-CONTROL.\n021100     OPEN INPUT DATA-FILE,\n021200          OUTPUT PRINT-FILE.\n021300\n021400     PERFORM 0200-READ-DATA-FILE\n021500        THRU 0299-READ-DATA-FILE-EXIT.\n021600\n021700     PERFORM 0300-PROCESS-DATA\n021800        THRU 0399-PROCESS-DATA-EXIT\n021900       UNTIL END-OF-DATA.\n022000\n022100     CLOSE DATA-FILE, PRINT-FILE.\n022200\n022300     STOP RUN.\n022400* - - - - - - - - - - - - - - - - PROGRAM EXIT POINT\n022500\n022600 0200-READ-DATA-FILE.\n022700     READ DATA-FILE\n022800         AT END MOVE 'Y' TO END-OF-DATA-SWITCH.\n022900\n023000 0299-READ-DATA-FILE-EXIT.\n023100     EXIT.\n023200* - - - - - - - - - - - - - - - - PERFORM EXIT POINT\n023300\n023400 0300-PROCESS-DATA.\n023500     MOVE SPACES TO DETAIL-LINE.\n023600     MOVE DATA-RECORD TO TEST-RECORD, DL-TEST-RECORD.\n023700\n023800     IF TR-IDENTIFICATION EQUAL 'FILL'\n023900         PERFORM 0400-CALL-FILL THRU 0400-CALL-FILL-EXIT\n024000         GO TO 0300-CONTINUE.\n024100\n024200     IF TR-IDENTIFICATION EQUAL 'FLPT'\n024300         PERFORM 0410-CALL-FLPT THRU 0410-CALL-FLPT-EXIT\n024400         GO TO 0300-CONTINUE.\n024500\n024600     IF TR-IDENTIFICATION EQUAL 'IHEX'\n024700         PERFORM 0415-CALL-IHEX THRU 0415-CALL-IHEX-EXIT\n024800         GO TO 0300-CONTINUE.\n024900\n025000     IF TR-IDENTIFICATION EQUAL 'LJST'\n025100         PERFORM 0420-CALL-LJST THRU 0420-CALL-LJST-EXIT\n025200         GO TO 0300-CONTINUE.\n025300\n025400     IF TR-IDENTIFICATION EQUAL 'MASK'\n025500         PERFORM 0425-CALL-MASK THRU 0425-CALL-MASK-EXIT\n025600         GO TO 0300-CONTINUE.\n025700\n025800     IF TR-IDENTIFICATION EQUAL 'NIB '\n025900         PERFORM 0430-CALL-NIB THRU 0430-CALL-NIB-EXIT\n026000         GO TO 0300-CONTINUE.\n026100\n026200     IF TR-IDENTIFICATION EQUAL 'OHEX'\n026300         PERFORM 0435-CALL-OHEX THRU 0435-CALL-OHEX-EXIT\n026400         GO TO 0300-CONTINUE.\n026500\n026600     IF TR-IDENTIFICATION EQUAL 'MONY'\n026700         PERFORM 0440-CALL-MONY THRU 0440-CALL-MONY-EXIT\n026800         GO TO 0300-CONTINUE.\n026900\n027000     MOVE '-------' TO DL-ROUTINE-NAME\n027100     MOVE '*' TO DL-SLASH-1, DL-SLASH-2, DL-RETURN-CODE-X\n027200     MOVE 'INVALID ROUTINE SPECIFIED' TO DL-COMMON-FORMAT.\n027300\n027400  0300-CONTINUE.\n027500     MOVE +0 TO RETURN-CODE.\n027600\n027700     IF DETAIL-LINE NOT EQUAL SPACES\n027800         PERFORM 0500-PRINT-ROUTINE THRU 0500-EXIT.\n027900\n028000     PERFORM 0200-READ-DATA-FILE\n028100        THRU 0299-READ-DATA-FILE-EXIT.\n028200\n028300 0399-PROCESS-DATA-EXIT.\n028400     EXIT.\n028500* - - - - - - - - - - - - - - - - PERFORM EXIT POINT\n028600\n028700 0400-CALL-FILL.\n028800     MOVE 'I-FILL ' TO DL-ROUTINE-NAME.\n028900     MOVE TR-FILL-SIZE TO FIELD-SIZE.\n029000\n029100     CALL 'IFMTFILL' USING TR-FILL-DATA, FIELD-SIZE.\n029200\n029300     MOVE RETURN-CODE TO DL-RETURN-CODE.\n029400\n029500     IF RETURN-CODE EQUAL 0\n029600         GO TO 0400-CALL-FILL-EXIT.\n029700\n029800     MOVE '*' TO DL-SLASH-1, DL-SLASH-2.\n029900     IF RETURN-CODE EQUAL 8\n030000         MOVE 'FIELD WAS NOT FILLED'\n030100           TO DL-COMMON-FORMAT\n030200         GO TO 0400-CALL-FILL-EXIT.\n030300\n030400 0400-CALL-FILL-EXIT.\n030500     EXIT.\n030600* - - - - - - - - - - - - - - - - PERFORM EXIT POINT\n030700\n030800 0410-CALL-FLPT.\n030900     MOVE 'I-FLPT ' TO DL-ROUTINE-NAME.\n031000     MOVE TR-FLPT-SIZE TO FIELD-SIZE.\n031100\n031200     CALL 'IFMTFLPT' USING TR-FLPT-DATA, FIELD-SIZE,\n031300                           FLPT-OUTPUT.\n031400\n031500     MOVE RETURN-CODE TO DL-RETURN-CODE.\n031600\n031700     IF RETURN-CODE EQUAL 0\n031800         MOVE SPACES TO OUTPUT-FIELD\n031900         MOVE FLPT-OUTPUT TO OUTPUT-NUMEDIT\n032000         MOVE OUTPUT-FIELD TO DL-COMMON-FORMAT\n032100         GO TO 0410-CALL-FLPT-EXIT.\n032200\n032300     MOVE '*' TO DL-SLASH-1, DL-SLASH-2.\n032400     IF RETURN-CODE EQUAL 8\n032500         MOVE 'INVALID FLOATING POINT FORMAT'\n032600           TO DL-COMMON-FORMAT\n032700         GO TO 0410-CALL-FLPT-EXIT.\n032800\n032900 0410-CALL-FLPT-EXIT.\n033000     EXIT.\n033100* - - - - - - - - - - - - - - - - PERFORM EXIT POINT\n033200\n033300 0415-CALL-IHEX.\n033400     MOVE 'I-HEX  ' TO DL-ROUTINE-NAME.\n033500     MOVE TR-IHEX-SIZE TO FIELD-SIZE.\n033600     MOVE SPACES TO OUTPUT-FIELD.\n033700\n033800     CALL 'IFMTHEX' USING TR-IHEX-DATA, FIELD-SIZE,\n033900                          OUTPUT-FIELD.\n034000\n034100     MOVE RETURN-CODE TO DL-RETURN-CODE.\n034200\n034300     IF RETURN-CODE EQUAL 0\n034400         MOVE OUTPUT-FIELD TO DL-COMMON-FORMAT\n034500         GO TO 0415-CALL-IHEX-EXIT.\n034600\n034700     MOVE '*' TO DL-SLASH-1, DL-SLASH-2.\n034800     IF RETURN-CODE EQUAL 8\n034900         MOVE 'INVALID HEX DIGIT IN INPUT'\n035000           TO DL-COMMON-FORMAT\n035100         GO TO 0415-CALL-IHEX-EXIT.\n035200\n035300 0415-CALL-IHEX-EXIT.\n035400     EXIT.\n035500* - - - - - - - - - - - - - - - - PERFORM EXIT POINT\n035600\n035700 0420-CALL-LJST.\n035800     MOVE 'I-LJST ' TO DL-ROUTINE-NAME.\n035900     MOVE TR-LJST-SIZE TO FIELD-SIZE.\n036000     MOVE SPACES TO OUTPUT-FIELD.\n036100\n036200     CALL 'IFMTLJST' USING TR-LJST-DATA, FIELD-SIZE.\n036400\n036500     MOVE RETURN-CODE TO DL-RETURN-CODE.\n036600\n036700     IF RETURN-CODE EQUAL 0\n036800         MOVE TR-LJST-DATA TO DL-COMMON-FORMAT\n036900         GO TO 0420-CALL-LJST-EXIT.\n037000\n037100 0420-CALL-LJST-EXIT.\n037200     EXIT.\n037300* - - - - - - - - - - - - - - - - PERFORM EXIT POINT\n037400\n037500 0425-CALL-MASK.\n037600     MOVE 'I-MASK ' TO DL-ROUTINE-NAME.\n037700     MOVE TR-MASK-SIZE TO FIELD-SIZE.\n037800     MOVE SPACES TO OUTPUT-FIELD.\n037900\n038000     CALL 'IFMTMASK' USING TR-MASK-DATA, FIELD-SIZE,\n038100                           TR-MASK-MASK, OUTPUT-FIELD.\n038200\n038300     MOVE RETURN-CODE TO DL-RETURN-CODE.\n038400\n038500     IF RETURN-CODE EQUAL 0\n038600         MOVE OUTPUT-FIELD TO DL-COMMON-FORMAT\n038700         GO TO 0425-CALL-MASK-EXIT.\n038800\n038900     MOVE '*' TO DL-SLASH-1, DL-SLASH-2.\n039000     IF RETURN-CODE EQUAL 8\n039100         MOVE 'INPUT DOES NOT CONFORM TO MASK'\n039200           TO DL-COMMON-FORMAT\n039300         GO TO 0425-CALL-MASK-EXIT.\n039400\n039500 0425-CALL-MASK-EXIT.\n039600     EXIT.\n039700* - - - - - - - - - - - - - - - - PERFORM EXIT POINT\n039800\n039900 0430-CALL-NIB.\n040000     MOVE 'I-NIB  ' TO DL-ROUTINE-NAME.\n040100     MOVE TR-NIB-SIZE TO FIELD-SIZE.\n040200\n040300     CALL 'IFMTNIB' USING TR-NIB-DATA, FIELD-SIZE.\n040400\n040500     MOVE RETURN-CODE TO DL-RETURN-CODE.\n040600\n040700     IF RETURN-CODE EQUAL 0\n040800         GO TO 0430-CALL-NIB-EXIT.\n040900\n041000     MOVE '*' TO DL-SLASH-1, DL-SLASH-2.\n041100     IF RETURN-CODE EQUAL 8\n041200         MOVE 'FIELD CONTAINS EMBEDDED BLANKS'\n041300           TO DL-COMMON-FORMAT\n041400         GO TO 0430-CALL-NIB-EXIT.\n041500\n041600 0430-CALL-NIB-EXIT.\n041700     EXIT.\n041800* - - - - - - - - - - - - - - - - PERFORM EXIT POINT\n041900\n042000 0435-CALL-OHEX.\n042100     MOVE 'O-HEX  ' TO DL-ROUTINE-NAME.\n042200     MOVE TR-OHEX-SIZE TO FIELD-SIZE.\n042300     MOVE SPACES TO OUTPUT-FIELD.\n042400\n042500     CALL 'OFMTHEX' USING TR-OHEX-DATA, FIELD-SIZE,\n042600                          OUTPUT-FIELD.\n042700\n042800     MOVE RETURN-CODE TO DL-RETURN-CODE.\n042900\n043000     IF RETURN-CODE EQUAL 0\n043100         MOVE OUTPUT-FIELD TO DL-COMMON-FORMAT\n043200         GO TO 0435-CALL-OHEX-EXIT.\n043300\n043400 0435-CALL-OHEX-EXIT.\n043500     EXIT.\n043600* - - - - - - - - - - - - - - - - PERFORM EXIT POINT\n043700\n043800 0440-CALL-MONY.\n043900     MOVE 'O-MONY ' TO DL-ROUTINE-NAME.\n044000     MOVE SPACES TO OUTPUT-FIELD.\n044100\n044200     CALL 'OFMTMONY' USING TR-MONY-DATA, OUTPUT-FIELD.\n044300\n044400     MOVE RETURN-CODE TO DL-RETURN-CODE.\n044500\n044600     IF RETURN-CODE EQUAL 0\n044700         GO TO 0440-CALL-MONY-OK.\n044800\n044900     MOVE '*' TO DL-SLASH-1, DL-SLASH-2.\n045000     IF RETURN-CODE EQUAL 4\n045100         MOVE 'NEGATIVE INPUT VALUE'\n045200           TO DL-COMMON-FORMAT\n045300         GO TO 0440-CALL-MONY-EXIT.\n045400\n045500     IF RETURN-CODE EQUAL 8\n045600         MOVE 'NON-NUMERIC CHARACTER IN INPUT'\n045700           TO DL-COMMON-FORMAT\n045800         GO TO 0440-CALL-MONY-EXIT.\n045900\n046000 0440-CALL-MONY-OK.\n046100     MOVE OUTPUT-CHUNK1 TO DL-COMMON-FORMAT.\n046200     PERFORM 0500-PRINT-ROUTINE THRU 0500-EXIT.\n046300     MOVE SPACES TO DETAIL-LINE.\n046400\n046500     IF OUTPUT-CHUNK2 EQUAL SPACES\n046600         GO TO 0440-CALL-MONY-EXIT.\n046700\n046800     MOVE OUTPUT-CHUNK2 TO DL-COMMON-FORMAT.\n046900     PERFORM 0500-PRINT-ROUTINE THRU 0500-EXIT.\n047000     MOVE SPACES TO DETAIL-LINE.\n047100\n047200     IF OUTPUT-CHUNK3 EQUAL SPACES\n047300         GO TO 0440-CALL-MONY-EXIT.\n047400\n047500     MOVE OUTPUT-CHUNK3 TO DL-COMMON-FORMAT.\n047600     PERFORM 0500-PRINT-ROUTINE THRU 0500-EXIT.\n047700     MOVE SPACES TO DETAIL-LINE.\n047800\n047900 0440-CALL-MONY-EXIT.\n048000     EXIT.\n048100* - - - - - - - - - - - - - - - - PERFORM EXIT POINT\n048200\n048300 0500-PRINT-ROUTINE.\n048400     IF LINE-COUNT LESS THAN PAGE-SIZE\n048500         GO TO 0500-DETAIL.\n048600\n048700     IF LINE-COUNT LESS THAN 99\n048800         GO TO 0500-PAGEHEAD.\n048900\n049000     MOVE SPACES TO PRINT-RECORD.\n049100     WRITE PRINT-RECORD AFTER ADVANCING TO-FIRST-LINE.\n049200\n049300  0500-PAGEHEAD.\n049400     ADD 1 TO PAGE-COUNT\n049500     MOVE PAGE-COUNT TO H2-PAGE\n049600     WRITE PRINT-RECORD FROM HEADING-1 BEFORE ADVANCING 1\n049700     WRITE PRINT-RECORD FROM HEADING-2 BEFORE ADVANCING 2\n049800     WRITE PRINT-RECORD FROM HEADING-3 BEFORE ADVANCING 1\n049900     MOVE 4 TO LINE-COUNT.\n050000\n050100 0500-DETAIL.\n050200     WRITE PRINT-RECORD FROM DETAIL-LINE BEFORE ADVANCING 1.\n050300     ADD 1 TO LINE-COUNT.\n050400\n050500 0500-EXIT.\n050600     EXIT.\n050700* - - - - - - - - - - - - - - - - PERFORM EXIT POINT\n050800\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FMTIVPD": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132O\\x01\\x132O\"A\\x00\\'\\x00\\'\\x00\\x00\\xd1\\xc1\\xe8\\xc6\\xd6\\xd9\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-20T00:00:00", "modifydate": "2013-11-20T22:41:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "JAYFORM"}, "text": "FILL 123456       06                              <\nFILL 123          05                         <ERR><\nFILL   345        05                         <ERR><\nFLPT 123          12                              <\nFLPT 123.45       12                              <\nFLPT -123         12                              <\nFLPT 123-         12                              <\nFLPT    -123.45   12                              <\nFLPT   123.45-    12                              <\nFLPT      123.45- 12                              <\nFLPT    --123     12                         <ERR><\nFLPT 1.12345678   12                         <ERR><\nFLPT 123456789012 12                         <ERR><\nFLPT    123.A5    12                         <ERR><\nIHEX C1C2C3F8F9   10                              <\nIHEX C            01                         <ERR><\nLJST    905       10                              <\nLJST  307 AB      10                              <\nMASK (864) 555-1212   14 (999) 999-9999           <\nMASK (A64) 555-1212   14 (999) 999-9999      <ERR><\nMASK 29307-1792       10 99999-9999               <\nMASK SS#155 23 4871   14 SS#999-99-9999      <ERR><\nMASK SS#155-23-4871   14 SS#999-99-9999           <\nMASK Y408             04 X999                     <\nMASK 408Y             04 X999                <ERR><\nNIB    1234       08                              <\nNIB  123          04                              <\nNIB           123 12                              <\nNIB   1  456      08                         <ERR><\nOHEX ABCDEF123    09                              <\nOHEX $}@.         04                              <\nMONY 0000000000000                          <VOID><\nMONY 000000000005L                           <NEG><\nMONY 0000000A00500                           <ERR><\nMONY 0000000513429                                <\nMONY 0000001000000                                <\nMONY 7777777777777                       <MAX OUT><\nMONY 9999999999999                        <MAX IN><\nMONY 0000000001201                                <\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IFMTFILL": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132O\\x01\\x132O\"A\\x00k\\x00k\\x00\\x00\\xd1\\xc1\\xe8\\xc6\\xd6\\xd9\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-20T00:00:00", "modifydate": "2013-11-20T22:41:00", "lines": 107, "newlines": 107, "modlines": 0, "user": "JAYFORM"}, "text": "         TITLE 'IFMTFILL - ENSURE ALL CHARACTERS FILLED ON INPUT'\n* ******************************************************************* *\n*                                                                     *\n*    IIII   FFFFFFF M     M TTTTTTTT FFFFFFF  IIII   LL      LL       *\n*     II    FF      MM   MM    TT    FF        II    LL      LL       *\n*     II    FF      MMM MMM    TT    FF        II    LL      LL       *\n*     II    FFFFF   MMMMMMM    TT    FFFFF     II    LL      LL       *\n*     II    FF      MM M MM    TT    FF        II    LL      LL       *\n*     II    FF      MM   MM    TT    FF        II    LL      LL       *\n*     II    FF      MM   MM    TT    FF        II    LL      LL       *\n*    IIII   FF      MM   MM    TT    FF       IIII   LLLLLLL LLLLLLL  *\n*                                                                     *\n* ******************************************************************* *\n* THIS SUBROUTINE SCANS AN INPUT FIELD (DISPLAY FORMAT) TO VERIFY     *\n* THAT ALL CHARACTERS ARE FILLED (NO LEADING, TRAILING, OR EMBEDDED   *\n* BLANKS).                                                            *\n*                                                                     *\n* NONE OF THE INITIALIZED VARIABLES ARE CHANGED DURING THE ROUTINE'S  *\n* EXECUTION AND THERE ARE NO INTERNAL DATA FIELDS. ALL MANIPULATION   *\n* IS DONE THROUGH REGISTERS. THE ROUTINE IS COMPLETELY REENTRANT.     *\n*                                                                     *\n* TWO FIELDS ARE PASSED AS PARAMETERS TO THE ROUTINE:                 *\n*                                                                     *\n*   1. A FIELD OF VARYING LENGTH CONTAINING THE INPUT DATA, AND       *\n*   2. A 2 BYTE FIELD (IN BINARY FORMAT) CONTAINING THE LENGTH OF     *\n*      THE FIRST FIELD PASSED.                                        *\n*                                                                     *\n* SUGGESTED CALLING SYNTAX FOR ALC CALLERS:                           *\n*                                                                     *\n*              CALL IFMTFILL,(INFIELD,INLENGTH)                       *\n*                 . . .                                               *\n*     INFIELD  DS   CL12'ABCDEF-12345'                                *\n*     INLENGTH DS   H'12'                                             *\n*                                                                     *\n* SUGGESTED CALLING SYNTAX FOR COBOL CALLERS:                         *\n*                                                                     *\n*     01  INPUT-FIELD           PIC X(12) VALUE 'ABCDEF-12345'.       *\n*     01  INPUT-FIELD-LENGTH    PIC S9(4) COMP VALUE 12.              *\n*                                                                     *\n*     CALL 'IFMTFILL' USING INPUT FIELD, INPUT-FIELD-LENGTH.          *\n*                                                                     *\n* POSSIBLE RETURN CODE VALUES:                                        *\n*     0 - NO BLANK CHARACTERS FOUND WITHIN FIELD                      *\n*     8 - BLANK CHARACTER(S) FOUND WITHIN FIELD                       *\n* ******************************************************************* *\n* ******************************************************************* *\n         EJECT\n         PRINT NOGEN\nIFMTFILL CSECT\n         EYEC  'VERIFY INPUT FIELD IS FILLED'\n         SAVE  (14,12)                 SAVE CALLER'S REGISTERS\n*\n         BALR  BASE,0                  ESTABLISH BASE REGISTER\n         USING *,BASE                  ASSUME BASE REGISTER\n*\n         LM    INREG,LGTHREG,0(R1)     LOAD ADDRESSES OF PARAMETERS\n*\n         SR    R15,R15                 ASSUME RETURN CODE OF ZERO\n*\n         LH    LGTHREG,0(,LGTHREG)     GET LENGTH OF INPUT FIELD\n         LTR   LGTHREG,LGTHREG         IS INPUT FIELD LENGTH ZERO?\n         BZ    RETURN                     IF YES, RETURN TO CALLER\n*\n         BCTR  LGTHREG,0               DECREASE BY 1 FOR EXECUTE\n         EX    LGTHREG,FINDBL          SCAN FOR BLANK\n         BZ    RETURN                  IF NO BLANKS FOUND\n*\n*    IF ANY BLANKS WERE FOUND, RETURN CODE IS SET TO \"8\"\n*\nERROR    LA    R15,8                    RETURN CODE OF 8\n*\n*    RETURN TO CALLING PROGRAM WITH RETURN CODE IN REGISTER 15\n*\nRETURN   RETURN (14,12),RC=(15)\n*\n*    TRT PERFORMED VIA EXECUTE WITH FIELD LENGTH MODIFIER\n*\nFINDBL   TRT   0(0,INREG),TABLEBL       SCAN FOR BLANK CHARACTER\n*\n* ******************************************************************* *\n* *************************** CONSTANTS ***************************** *\n* ******************************************************************* *\nTABLEBL  DC    64X'00'\n         DC    X'01'\n         DC    191X'00'\n         LTORG\n         EJECT\n* ******************************************************************* *\n* ***************************** EQUATES ***************************** *\n* ******************************************************************* *\nR0       EQU   0                       REGISTER 0\nR1       EQU   1                       REGISTER 1\nR2       EQU   2                       REGISTER 2\nR3       EQU   3                       REGISTER 3\nR4       EQU   4                       REGISTER 4\nINREG    EQU   5                       INPUT FIELD\nLGTHREG  EQU   6                       INPUT FIELD LENGTH\nR7       EQU   7                       REGISTER 7\nR8       EQU   8                       REGISTER 8\nR9       EQU   9                       REGISTER 9\nR10      EQU   10                      REGISTER 10\nR11      EQU   11                      REGISTER 11\nBASE     EQU   12                      BASE REGISTER\nR13      EQU   13                      REGISTER 13\nR14      EQU   14                      REGISTER 14\nR15      EQU   15                      REGISTER 15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IFMTFLPT": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132O\\x01\\x132O\"A\\x00\\xd0\\x00\\xd0\\x00\\x00\\xd1\\xc1\\xe8\\xc6\\xd6\\xd9\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-20T00:00:00", "modifydate": "2013-11-20T22:41:00", "lines": 208, "newlines": 208, "modlines": 0, "user": "JAYFORM"}, "text": "         TITLE 'IFMTFLPT - PARSE SIGNED FLOATING POINT INPUT FIELD'\n* ******************************************************************* *\n*                                                                     *\n*    IIII   FFFFFFF M     M TTTTTTTT FFFFFFF LL      PPPPPP TTTTTTTT  *\n*     II    FF      MM   MM    TT    FF      LL      PP   PP   TT     *\n*     II    FF      MMM MMM    TT    FF      LL      PP   PP   TT     *\n*     II    FFFFF   MMMMMMM    TT    FFFFF   LL      PP   PP   TT     *\n*     II    FF      MM M MM    TT    FF      LL      PPPPPP    TT     *\n*     II    FF      MM   MM    TT    FF      LL      PP        TT     *\n*     II    FF      MM   MM    TT    FF      LL      PP        TT     *\n*    IIII   FF      MM   MM    TT    FF      LLLLLLL PP        TT     *\n*                                                                     *\n* ******************************************************************* *\n* THIS SUBROUTINE SCANS AN INPUT FIELD (DISPLAY FORMAT) ASSUMED TO    *\n* CONTAIN A FLOATING POINT NUMERIC VALUE. THE EXPECTED FORMAT IS:     *\n*                                                                     *\n*    1. ANY NUMBER OF LEADING OR TRAILING SPACES (WILL BE IGNORED)    *\n*    2. A LEADING OR TRAILING SIGN (+ OR - CHARACTER; OPTIONAL)       *\n*    3. ONE TO ELEVEN DIGITS REPRESENTING THE INTEGRAL (WHOLE) VALUE  *\n*    4. A DECIMAL POINT (OPTIONAL)                                    *\n*    5. ONE TO SEVEN DIGITS REPRESENTING THE DECIMAL VALUE (OPTIONAL) *\n*                                                                     *\n*  NONE OF THE INITIALIZED VARIABLES ARE CHANGED DURING THE ROUTINE'S *\n*  EXECUTION AND THERE ARE NO INTERNAL DATA FIELDS. ALL MANIPULATION  *\n*  IS DONE THROUGH REGISTERS. THE ROUTINE IS COMPLETELY REENTRANT.    *\n*                                                                     *\n* THREE FIELDS ARE PASSED AS PARAMETERS TO THE ROUTINE:               *\n*                                                                     *\n*    1. A FIELD OF VARYING LENGTH CONTAINING THE INPUT CHARACTERS,    *\n*    2. A 2 BYTE FIELD (IN BINARY FORMAT) CONTAINING THE LENGTH OF    *\n*       THE FIELD IN THE FIRST PARAMETER, AND                         *\n*    4. AN 18 BYTE FIELD (ZONED-DECIMAL FORMAT) TO RECEIVE THE        *\n*       EXTRACTED NUMERIC DATA.                                       *\n*                                                                     *\n* SUGGESTED CALLING SYNTAX FOR ALC CALLERS:                           *\n*                                                                     *\n*              CALL IFMTFLPT,(INFIELD,INLEN,OUTFIELD)                 *\n*                 . . .                                               *\n*     INFIELD  DS   CL10'  -107.10 '                                  *\n*     INLEN    DS   H'10'                                             *\n*     OUTFIELD DS   ZL18                                              *\n*                                                                     *\n* SUGGESTED CALLING SYNTAX FOR COBOL CALLERS:                         *\n*                                                                     *\n*     01  IFMTFLPT-PARMS.                                             *\n*         02  INPUT-FIELD         PIC X(10) VALUE '  -107.10 '.       *\n*         02  INPUT-FIELD-LENGTH  PIC S9(4) COMP VALUE 10.            *\n*         02  OUTPUT-FIELD        PIC X9(11)V9(7).                    *\n*                                                                     *\n*     CALL 'IFMTFLPT' USING INPUT-FIELD, INPUT-FIELD-LENGTH,          *\n*                           OUTPUT-FIELD.                             *\n*                                                                     *\n* THE POSSIBLE VALUE FOR THE RETURN CODE ARE:                         *\n*                                                                     *\n*     0 - FIELD SUCCESSFULLY CONVERTED                                *\n*     8 - INPUT FIELD DOES NOT CONFORM TO ACCEPTABLE FORMAT RULES     *\n* ******************************************************************* *\n* ******************************************************************* *\n         EJECT\n         PRINT NOGEN\nIFMTFLPT CSECT\n         EYEC  'EXTRACT NUMERIC VALUE FROM FLOATING POINT INPUT FIELD'\n         SAVE  (14,12)                 SAVE CALLER'S REGISTERS\n*\n         BALR  BASE,0                  ESTABLISH BASE REGISTER\n         USING *,BASE                  ASSUME BASE REGISTER\n*\n         LM    INREG,OUTREG,0(R1)      LOAD ADDRESSES OF PARAMETERS\n*\n         LH    FLDLEN,0(,FLDLEN)       LOAD LENGTH OF INPUT FIELD\n*\n         SR    R15,R15                 ASSUME GOOD RETURN\n*\n         ICM   STATUS,B'0001',=C'0'    INITIAL STATUS IS \"FIELD BEGIN\"\n         ICM   STATUS,B'0010',=C'+'    DEFAULT SIGN IS POSITIVE\n         SR    INTBEG,INTBEG           ZERO TO INTEGER BEGIN,\n         SR    INTLEN,INTLEN                    INTEGER LENGTH\n         SR    DECBEG,DECBEG                    DECIMAL BEGIN,\n         SR    DECLEN,DECLEN                    DECIMAL LENGTH\n*\n         MVI   0(OUTREG),C'0'          SET OUTPUT FIELD TO\n         MVC   1(17,OUTREG),0(OUTREG)     ALL ZEROS\n*\n         LTR   FLDLEN,FLDLEN           IS INPUT LENGTH ZERO?\n         BZ    RETURN                     YES, RETURN TO CALLER\n*\nLOOP     CLI   0(INREG),C' '           IS CHARACTER BLANK?\n         BE    INBLANK                    YES, PROCESS\n         CLI   0(INREG),C'-'           IS CHARACTER MINUS SIGN?\n         BE    INSIGN                     YES, PROCESS\n         CLI   0(INREG),C'+'           IS CHARACTER PLUS SIGN?\n         BE    INSIGN                     YES, PROCESS\n         CLI   0(INREG),C'.'           IS CHARACTER DECIMAL POINT?\n         BE    INPOINT                    YES, PROCESS\n*\nDIGIT    CLI   0(INREG),X'F0'          IS CHARACTER LESS THAN 0?\n         BL    ERROR                      YES, RETURN ERROR CODE\n         CLI   0(INREG),X'F9'          IS CHARACTER GREATER THAN 9?\n         BH    ERROR                      YES, RETURN ERROR CODE\nDIGIT0   CLM   STATUS,B'0001',=C'0'    AT \"FIELD BEGIN\"?\n         BNE   DIGIT2                     NO, TEST FURTHER\nDIGIT1   ICM   STATUS,B'0001',=C'2'    SET STATUS \"INTEGER STARTED\"\n         LR    INTBEG,INREG            STORE INTEGER BEGINNING ADDR\n         LA    INTLEN,1                INITIALIZE INTEGER LENGTH\n         B     NEXT                    CONTINUE SCANNING\nDIGIT2   CLM   STATUS,B'0001',=C'1'    AT \"FIELD STARTED\"?\n         BE    DIGIT1                     PROCESS SAME AS \"FIELD BEGIN\"\n         CLM   STATUS,B'0001',=C'2'    IS \"INTEGER STARTED\"?\n         BNE   DIGIT3                     NO, TEST FURTHER\n         LA    INTLEN,1(,INTLEN)       INCREASE INTEGER COUNT\n         B     NEXT                    CONTINUE SCANNING\nDIGIT3   CLM   STATUS,B'0001',=C'3'    IS \"DECIMAL STARTED\"?\n         BNE   ERROR                      NO, RETURN ERROR CODE\n         LA    DECLEN,1(,DECLEN)       INCREASE DECIMAL COUNT\n*\nNEXT     LA    INREG,1(,INREG)         ADDRESS NEXT INPUT CHARACTER\n         BCT   FLDLEN,LOOP              AND CONTINUE UNTIL INPUT END\n*\n         CH    INTLEN,=H'11'           IF INTEGER LENGTH IS GREATER\n         BH    ERROR                      THAN 11 RETURN ERROR CODE\n         CH    DECLEN,=H'7'            IF DECIMAL LENGTH IS GREATER\n         BH    ERROR                      THAN 7 RETURN ERROR CODE\nINTEGER  LTR   INTLEN,INTLEN           IS INTEGER LENGTH ZERO?\n         BZ    DECIMAL                    YES, GO CHECK DECIMAL\n         LA    R3,11(,OUTREG)          RIGHT ADJUST INTEGER IN\n         SR    R3,INTLEN                  OUTPUT FIELD\n         BCTR  INTLEN,0                DECREASE BY 1 FOR EXECUTE\n         EX    INTLEN,MOVEINT          MOVE INTEGER TO OUTPUT FIELD\nDECIMAL  LTR   DECLEN,DECLEN           IS DECIMAL LENGTH ZERO?\n         BZ    SETSIGN                    YES, GO SET SIGN\n         LA    R3,11(,OUTREG)          LEFT ADJUST DECIMAL IN OUTPUT\n         BCTR  DECLEN,0                DECREASE BY 1 FOR EXECUTE\n         EX    DECLEN,MOVEDEC          MOVE DECIMAL TO OUTPUT FIELD\n*\nSETSIGN  CLM   STATUS,B'0010',=C'-'    WAS INPUT SIGN NEGATIVE?\n         BE    SEGSIGN0                   YES, GO SET NEGATIVE\n         NI    17(OUTREG),X'CF'        SET POSITIVE\n         B     RETURN                   AND RETURN TO CALLER\nSEGSIGN0 NI    17(OUTREG),X'DF'        SET NEGATIVE\n         B     RETURN                   AND RETURN TO CALLER\n*\nINBLANK  CLM   STATUS,B'0001',=C'0'    AT \"FIELD BEGIN\"?\n         BE    NEXT                       YES, CONTINUE SCANNING\n         CLM   STATUS,B'0001',=C'2'    IS \"INTEGER STARTED\"?\n         BE    INBLANKX                   YES, MARK END OF FIELD\n         CLM   STATUS,B'0001',=C'3'    IS \"DECIMAL STARTED\"?\n         BE    INBLANKX                   YES, MARK END OF FIELD\n         CLM   STATUS,B'0001',=C'4'    AT \"FIELD END\"?\n         BE    NEXT                       YES, CONTINUE SCANNING\n         B     ERROR                   EMBEDDED BLANK, RETURN ERROR\nINBLANKX ICM   STATUS,B'0001',=C'4'    SET STATUS \"FIELD END\"\n         B     NEXT                    CONTINUE SCANNING\n*\nINSIGN   CLM   STATUS,B'0001',=C'0'    AT \"FIELD BEGIN\"?\n         BE    INSIGN1                    YES, STORE SIGN/UPDATE STATUS\n         CLM   STATUS,B'0001',=C'2'    IS \"INTEGER STARTED\"?\n         BE    INSIGN2                    YES, STORE SIGN/UPDATE STATUS\n         CLM   STATUS,B'0001',=C'3'    IS \"DECIMAL STARTED\"?\n         BE    INSIGN2                    YES, STORE SIGN/UPDATE STATUS\n         B     ERROR                   BAD SIGN LOCATION\nINSIGN1  ICM   STATUS,B'0010',0(INREG) STORE SIGN\n         ICM   STATUS,B'0001',=C'1'    SET STATUS \"FIELD STARTED\"\n         B     NEXT                    CONTINUE SCANNING\nINSIGN2  ICM   STATUS,B'0010',0(INREG) STORE SIGN\n         ICM   STATUS,B'0001',=C'4'    SET STATUS \"FIELD END\"\n         B     NEXT                    CONTINUE SCANNING\n*\nINPOINT  CLM   STATUS,B'0001',=C'0'    AT \"FIELD BEGIN\"?\n         BE    INPOINTX                   YES, STORE ADDR/UPDATE STATUS\n         CLM   STATUS,B'0001',=C'1'    AT \"FIELD STARTED\"?\n         BE    INPOINTX                   YES, STORE ADDR/UPDATE STATUS\n         CLM   STATUS,B'0001',=C'2'    IS \"INTEGER STARTED\"?\n         BNE   ERROR                      BAD PERIOD LOCATION\nINPOINTX ICM   STATUS,B'0001',=C'3'    SET STATUS \"DECIMAL STARTED\"\n         LA    DECBEG,1(,INREG)        STORE DECIMAL BEGIN ADDRESS\n         B     NEXT                    CONTINUE SCANNING\n*\nERROR    LA    R15,8                   RETURN CODE OF 8\nRETURN   RETURN (14,12),RC=(15)        RETURN TO CALLER\n*\nMOVEINT  MVC   0(0,R3),0(INTBEG)       MOVE INTEGER TO OUTPUT FIELD\nMOVEDEC  MVC   0(0,R3),0(DECBEG)       MOVE DECIMAL TO OUTPUT FIELD\n*\n* ******************************************************************* *\n* *************************** CONSTANTS ***************************** *\n* ******************************************************************* *\n         LTORG\n* ******************************************************************* *\n* **************************** EQUATES ****************************** *\n* ******************************************************************* *\nR0       EQU   0                       REGISTER 0\nR1       EQU   1                       REGISTER 1\nR2       EQU   2                       REGISTER 2\nR3       EQU   3                       REGISTER 3\nSTATUS   EQU   4                       STATUS OF EXTRACTION\nINREG    EQU   5                       INPUT FIELD ADDRESS\nFLDLEN   EQU   6                       INPUT FIELD LENGTH\nOUTREG   EQU   7                       OUTPUT FIELD ADDRESS\nINTBEG   EQU   8                       INTEGER BEGIN ADDRES\nINTLEN   EQU   9                       INTEGER LENGTH\nDECBEG   EQU   10                      DECIMAL BEGIN ADDRESS\nDECLEN   EQU   11                      DECIMAL LENGTH\nBASE     EQU   12                      BASE REGISTER\nR13      EQU   13                      REGISTER 13\nR14      EQU   14                      REGISTER 14\nR15      EQU   15                      REGISTER 15\n         EJECT\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IFMTHEX": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132O\\x01\\x132O\"A\\x00\\x8e\\x00\\x8e\\x00\\x00\\xd1\\xc1\\xe8\\xc6\\xd6\\xd9\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-20T00:00:00", "modifydate": "2013-11-20T22:41:00", "lines": 142, "newlines": 142, "modlines": 0, "user": "JAYFORM"}, "text": "         TITLE 'IFMTHEX - CONVERT INPUT HEX DATA FIELD TO HEX DIGITS'\n* ******************************************************************* *\n*                                                                     *\n*    IIII   FFFFFFF M     M TTTTTTTT HH   HH EEEEEE  XX   XX          *\n*     II    FF      MM   MM    TT    HH   HH EE      XX   XX          *\n*     II    FF      MMM MMM    TT    HH   HH EE       XX XX           *\n*     II    FFFFF   MMMMMMM    TT    HHHHHHH EEEE      XXX            *\n*     II    FF      MM M MM    TT    HH   HH EE        XXX            *\n*     II    FF      MM   MM    TT    HH   HH EE       XX XX           *\n*     II    FF      MM   MM    TT    HH   HH EE      XX   XX          *\n*    IIII   FF      MM   MM    TT    HH   HH EEEEEEE XX   XX          *\n*                                                                     *\n* ******************************************************************* *\n* THIS SUBROUTINE READS AN INPUT FIELD (DISPLAY FORMAT) WHERE EACH    *\n* 2 BYTES REPRESENT THE CHARACTER REPRESENTATION OF A PAIR OF HEX     *\n* DIGITS AND CONVERTS THEM INTO THE CORRESPONDING OUTPUT CHARACTER.   *\n*                                                                     *\n* NONE OF THE INITIALIZED VARIABLES ARE CHANGED DURING THE ROUTINE'S  *\n* EXECUTION AND THERE ARE NO INTERNAL DATA FIELDS. ALL MANIPULATION   *\n* IS DONE THROUGH REGISTERS. THE ROUTINE IS COMPLETELY REENTRANT.     *\n*                                                                     *\n* THREE FIELDS ARE PASSED AS PARAMETERS TO THE ROUTINE:               *\n*                                                                     *\n*   1. A FIELD OF VARYING LENGTH CONTAINING THE INPUT CHARACTERS,     *\n*   2. A 2 BYTE FIELD (IN BINARY FORMAT) CONTAINING THE LENGTH OF     *\n*      THE INPUT FIELD (THIS NUMBER MUST BE EVENLY DIVISIBLE BY 2),   *\n*   3. A FIELD TO CONTAIN THE GENERATED HEX CHARACTERS.               *\n*                                                                     *\n* SUGGESTED CALLING SYNTAX FOR ALC CALLERS:                           *\n*                                                                     *\n*             CALL IFMTHEX,(INFIELD,INLENGTH,OUTFIELD)                *\n*                . . .                                                *\n*    INFIELD  DS   CL12'F1F2F3C1C2C3'                                 *\n*    INLENGTH DS   H'12'                                              *\n*    OUTFIELD DS   CL6'123ABC'                                        *\n*                                                                     *\n* SUGGESTED CALLING SYNTAX FOR COBOL CALLERS:                         *\n*                                                                     *\n*     01  INPUT-FIELD           PIC X(12) VALUE 'F1F2F3C1C2C3'.       *\n*     01  INPUT-FIELD-LENGTH    PIC S9(4) COMP VALUE 12.              *\n*     01  OUTPUT-FIELD          PIC X(6).                             *\n*                                                                     *\n*     CALL 'IFMTHEX' USING INPUT-FIELD, INPUT-FIELD-LENGTH,           *\n*                          OUTPUT-FIELD.                              *\n*                                                                     *\n* NOTE: INPUT-FIELD-LENGTH MUST BE EVENLY DIVISIBLE BY 2. THE LENGTH  *\n*       OF THE OUTPUT-FIELD SHOULD BE HALF THAT OF THE INPUT-FIELD.   *\n*                                                                     *\n* POSSIBLE RETURN CODE VALUES:                                        *\n*     0 - FIELD SUCCESSFULLY CONVERTED                                *\n*     8 - INPUT FIELD DOES NOT CONTAIN VALID \"HEX\" DIGITS             *\n* ******************************************************************* *\n* ******************************************************************* *\n         EJECT\n         PRINT NOGEN\nIFMTHEX  CSECT\n         EYEC  'CONVERT INPUT HEX FIELD INTO HEX DIGITS'\nBEGIN    SAVE  (14,12)                 SAVE SALLER'S REGISTERS\n*\n         BALR  BASE,0                  ESTABLISH BASE REGISTER\n         USING *,BASE                  ASSUME BASE REGISTER\n*\n         LM    INREG,OUTREG,0(R1)      LOAD ADDRESSES OF PARAMETERS\n*\n         SR    R15,R15                 ASSUME RETURN CODE OF ZERO\n*\n         LH    LGTHREG,0(,LGTHREG)     LOAD FIELD LENGTH\n         LTR   LGTHREG,LGTHREG         IS OUTPUT FIELD LENGTH ZERO?\n         BZ    RETURN                    YES, JUST RETURN TO CALLER\n*\n         LR    R2,LGTHREG              COPY LENGTH FOR TEST\n         N     R2,=F'1'                IS LENGTH EVEN (1 BIT OFF)?\n         BNZ   ERROR                      NO, RETURN ERROR\n*\n         SRA   LGTHREG,1                DIVIDE LENGTH BY 2\n*\n*    MAIN LOOP EXECUTED 1 PASS FOR EACH 2 BYTES INPUT\n*\nBYTELOOP SR    R2,R2                   CLEAR WORK REGISTER\n         LA    R4,2                    DO NIBBLE LOOP TWICE\n*\n*    SUBORDINATE LOOP EXECUTED 2 PASSES FOR EACH INPUT BYTE\n*\nNIBLLOOP SR    R3,R3                   CLEAR WORK REGISTER\n         IC    R3,0(,INREG)            GET CHARACTER FROM INPUT\n         C     R3,=F'193'              COMPARE TO CHARACTER \"A\"\n         BL    ERROR                      IF LESS, BAD CHARACTER\n         C     R3,=F'198'              COMPARE TO CHARACTER \"F\"\n         BH    DIGIT                      IF GREATER, CHECK FOR DIGIT\n         SH    R3,=H'183'              CONVERT TO BINARY\n         B     SAVENIBL                SAVE NIBBLE\nDIGIT    C     R3,=F'240'              COMPARE TO DIGIT \"0\"\n         BL    ERROR                      IF LESS, BAD CHARACTER\n         C     R3,=F'249'              COMPARE TO DIGIT \"9\"\n         BH    ERROR                      IF GREATER, BAD CHARACTER\n         SH    R3,=F'240'              CONVERT TO BINARY\nSAVENIBL SLL   R3,28                   SHIFT NIBBLE LEFT IN REGISTER\n         SLDL  R2,4                    SHIFT NIBBLE INTO R2\n         LA    INREG,1(,INREG)         BUMP INPUT ADDRESS\n         BCT   R4,NIBLLOOP             CONVERT NEXT NIBBLE\n*\n         STC   R2,0(,OUTREG)           STORE CONVERTED BYTE\n         LA    OUTREG,1(,OUTREG)       BUMP OUTPUT ADDRESS\n         BCT   LGTHREG,BYTELOOP        CONVERT NEXT BYTE\n*\n*    AT COMPLETION OF OUTER LOOP, JUMP TO COMMON RETURN POINT\n*\n         B     RETURN                  RETURN TO CALLER\n*\n*    ERROR OCCURRED, SET RETURN CODE\n*\nERROR    LA    R15,8                   RETURN CODE OF 8\n*\n*    RETURN TO CALLER WITH RETURN CODE IN REGISTER 15\n*\nRETURN   RETURN (14,12),RC=(15)\n         SPACE\n* ******************************************************************* *\n* *************************** CONSTANTS ***************************** *\n* ******************************************************************* *\n         LTORG\n         EJECT\n* ******************************************************************* *\n* ***************************** EQUATES ***************************** *\n* ******************************************************************* *\nR0       EQU   0                       REGISTER 0\nR1       EQU   1                       REGISTER 1\nR2       EQU   2                       REGISTER 2\nR3       EQU   3                       REGISTER 3\nR4       EQU   4                       REGISTER 4\nINREG    EQU   5                       INPUT FIELD\nLGTHREG  EQU   6                       INPUT FIELD LENGTH\nOUTREG   EQU   7                       OUTPUT FIELD\nR8       EQU   8                       REGISTER 8\nR9       EQU   9                       REGISTER 9\nR10      EQU   10                      REGISTER 10\nR11      EQU   11                      REGISTER 11\nBASE     EQU   12                      BASE REGISTER\nR13      EQU   13                      REGISTER 13\nR14      EQU   14                      REGISTER 14\nR15      EQU   15                      REGISTER 15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IFMTLJST": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132O\\x01\\x132O\"A\\x00\\x89\\x00\\x89\\x00\\x00\\xd1\\xc1\\xe8\\xc6\\xd6\\xd9\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-20T00:00:00", "modifydate": "2013-11-20T22:41:00", "lines": 137, "newlines": 137, "modlines": 0, "user": "JAYFORM"}, "text": "         TITLE 'IFMTLJST - LEFT JUSTIFY DATA IN FIELD'\n* ******************************************************************* *\n*                                                                     *\n*    IIII   FFFFFFF M     M TTTTTTTT LL           JJ  SSSSS TTTTTTTT  *\n*     II    FF      MM   MM    TT    LL           JJ SS   SS   TT     *\n*     II    FF      MMM MMM    TT    LL           JJ SS        TT     *\n*     II    FFFFF   MMMMMMM    TT    LL           JJ  SSSSS    TT     *\n*     II    FF      MM M MM    TT    LL           JJ      SS   TT     *\n*     II    FF      MM   MM    TT    LL      JJ   JJ SS   SS   TT     *\n*     II    FF      MM   MM    TT    LL      JJ   JJ SS   SS   TT     *\n*    IIII   FF      MM   MM    TT    LLLLLLL  JJJJJ   SSSSS    TT     *\n*                                                                     *\n* ******************************************************************* *\n* THIS SUBROUTINE LEFT JUSTIFIES THE DATA IN AN INPUT FIELD (DISPLAY  *\n* FORMAT) BY LOCATING THE FIRST NON-BLANK CHARACTER AND THEN MOVING   *\n* THE CONTENTS OF THE FIELD FROM THAT POSITION TO THE END OF THE      *\n* FIELD INTO THE LEFT-MOST BYT OF THE FIELD. THE REMAINDER OF THE     *\n* FIELD IS THEN FILLED WITH BLANKS.                                   *\n*                                                                     *\n* NONE OF THE INITIALIZED VARIABLES ARE CHANGED DURING THE ROUTINE'S  *\n* EXECUTION AND THERE ARE NO INTERNAL DATA FIELDS. ALL MANIPULATION   *\n* IS DONE THROUGH REGISTERS. THE ROUTINE IS COMPLETELY REENTRANT.     *\n*                                                                     *\n* TWO FIELDS ARE PASSED AS PARAMETERS TO THE ROUTINE:                 *\n*                                                                     *\n*   1. A FIELD OF VARYING LENGTH CONTAINING THE INPUT DATA, AND       *\n*   2. A 2 BYTE FIELD (IN BINARY FORMAT) CONTAINING THE LENGTH OF     *\n*      THE FIRST FIELD PASSED.                                        *\n*                                                                     *\n* SUGGESTED CALLING SYNTAX FOR ALC CALLERS:                           *\n*                                                                     *\n*              CALL IFMTLJST,(INFIELD,INLENGTH)                       *\n*                 . . .                                               *\n*     INFIELD  DS   CL12'   128.25   '                                *\n*     INLENGTH DS   H'12'                                             *\n*                                                                     *\n* SUGGESTED CALLING SYNTAX FOR COBOL CALLERS:                         *\n*                                                                     *\n*     01  INPUT-FIELD           PIC X(12) VALUE '   128.25   '.       *\n*     01  INPUT-FIELD-LENGTH    PIC S9(4) COMP VALUE 12.              *\n*                                                                     *\n*     CALL 'IFMTLJST' USING INPUT FIELD, INPUT-FIELD-LENGTH.          *\n*                                                                     *\n* POSSIBLE RETURN CODE VALUES:                                        *\n*     0 - FIELD SUCCESSFULLY LEFT-JUSTIFIED                           *\n* ******************************************************************* *\n* ******************************************************************* *\n         EJECT\n         PRINT NOGEN\nIFMTLJST CSECT\n         EYEC  'LEFT JUSTIFY DATA IN INPUT FIELD'\nBEGIN    SAVE  (14,12)                 SAVE CALLER'S REGISTERS\n*\n         BALR  BASE,0                  ESTABLISH BASE REGISTER\n         USING *,BASE                  ASSUME BASE REGISTER\n*\n         LM    INREG,LGTHREG,0(R1)     LOAD ADDRESSES OF PARAMETERS\n*\n         LH    LGTHREG,0(,LGTHREG)     GET LENGTH OF INPUT FIELD\n         LTR   LGTHREG,LGTHREG         IS FIELD LENGTH ZERO?\n         BZ    RETURN                    IF YES, RETURN TO CALLER\n*\n         CLI   0(INREG),C' '           IS FIRST CHARACTER BLANK\n         BNE   RETURN                    IF NOT, RETURN TO CALLER\n*\n         LR    R7,LGTHREG              LENGTH OF FIELD\n         BCTR  R7,0                    DECREASE BY 1 FOR EXECUTE\n         EX    R7,FINDNB               FIND FIRST NON-BLANK\n         BC    0,RETURN                  IF ALL BLANKS, RETURN\n*\n*    COMPUTE LENGTH OF DATA TO MOVE LEFT\n*\n         AR    R7,INREG                ADD BEGINNING OF FIELD ADDRESS\n         SR    R7,R1                   SUBTRACT 1ST NON-BLANK ADDRESS\n         EX    R7,VARMOVE              MOVE NON-BLANK CONTENTS LEFT\n         LA    R7,1(,R7)               RESTORE ACTUAL LENGTH OF DATA\n*\n*    COMPUTE ADDRESS TO BEGIN BLANK FILLING REMAINDER OF FIELD\n*\n         LR    R8,INREG                BEGINNING OF FIELD ADDRESS\n         AR    R8,R7                   ADD SIGNIFICANT CHARACTERS\n         MVI   0(R8),C' '              MOVE FIRST BLANK\n*\n*    COMPUTE NUMBER OF BLANKS TO BE INSERTED\n*\n         LR    R9,LGTHREG              LENGTH OF INPUT FIELD\n         SR    R9,R7                   SUBTRACT SIGNIFICANT CHARACTERS\n         BCTR  R9,0                    DECREASE BY THE FIRST BLANK\n         LTR   R9,R9                   CHECK FOR ZERO LENGTH\n         BZ    RETURN                     IF ZERO, JUST RETURN\n         BCTR  R9,0                    DECREASE BY 1 FOR EXECUTE\n         EX    R9,BLANKS               MOVE BLANKS TO FILL FIELD\n*\n*    RETURN TO CALLER WITH RETURN CODE (0) IN REGISTER 15\n*\nRETURN   RETURN (14,12),RC=0\n*\n*    TRT PERFORMED VIA EXECUTE FROM ABOVE TO FIND 1ST NON-BLANK\n*\nFINDNB   TRT   0(0,INREG),TRTABLE       SCAN FOR NON-BLANK CHARACTERS\n*\n*    MVC PERFORMED VIA EXECUTE FROM ABOVE TO MOVE DATA LEFT IN FIELD\n*\nVARMOVE  MVC   0(0,INREG),0(R1)         MOVE NON-BLANK PORTION LEFT\n*\n*    MVC PERFORMED VIA EXECUTE FROM ABOVE TO BLANK REMAINDER OF FIELD\n*\nBLANKS   MVC   1(0,R8),0(R8)            BLANK REMAINDER OF FIELD\n*\n* ******************************************************************* *\n* *************************** CONSTANTS ***************************** *\n* ******************************************************************* *\nTRTABLE  DC    64X'01'                 TABLE TO FIND NON-BLANK\n         DC    X'00'\n         DC    191X'01'\n         LTORG\n         EJECT\n* ******************************************************************* *\n* ***************************** EQUATES ***************************** *\n* ******************************************************************* *\nR0       EQU   0                       REGISTER 0\nR1       EQU   1                       REGISTER 1\nR2       EQU   2                       REGISTER 2\nR3       EQU   3                       REGISTER 3\nR4       EQU   4                       REGISTER 4\nINREG    EQU   5                       INPUT FIELD\nLGTHREG  EQU   6                       INPUT FIELD LENGTH\nR7       EQU   7                       REGISTER 7\nR8       EQU   8                       REGISTER 8\nR9       EQU   9                       REGISTER 9\nR10      EQU   10                      REGISTER 10\nR11      EQU   11                      REGISTER 11\nBASE     EQU   12                      BASE REGISTER\nR13      EQU   13                      REGISTER 13\nR14      EQU   14                      REGISTER 14\nR15      EQU   15                      REGISTER 15\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IFMTMASK": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132O\\x01\\x132O\"A\\x00\\x99\\x00\\x99\\x00\\x00\\xd1\\xc1\\xe8\\xc6\\xd6\\xd9\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-20T00:00:00", "modifydate": "2013-11-20T22:41:00", "lines": 153, "newlines": 153, "modlines": 0, "user": "JAYFORM"}, "text": "         TITLE 'IFMTMASK - EDIT INPUT FIELD BY USING FORMAT MASK'\n* ******************************************************************* *\n*                                                                     *\n*    IIII   FFFFFFF M     M TTTTTTTT M     M    A     SSSSS  KK   KK  *\n*     II    FF      MM   MM    TT    MM   MM   AAA   SS   SS KK  KK   *\n*     II    FF      MMM MMM    TT    MMM MMM  AA AA  SS      KK KK    *\n*     II    FFFFF   MMMMMMM    TT    MMMMMMM AA   AA  SSSSS  KKKK     *\n*     II    FF      MM M MM    TT    MM M MM AA   AA      SS KKKK     *\n*     II    FF      MM   MM    TT    MM   MM AAAAAAA SS   SS KK KK    *\n*     II    FF      MM   MM    TT    MM   MM AA   AA SS   SS KK  KK   *\n*    IIII   FF      MM   MM    TT    MM   MM AA   AA  SSSSS  KK   KK  *\n*                                                                     *\n* ******************************************************************* *\n* THIS SUBROUTINE SCANS AN INPUT FIELD (DISPLAY FORMAT) AND MOVES THE *\n* CHARACTERS TO AN OUTPUT FIELD BASED UPON THE CORRESPONDING BYTE IN  *\n* A FORMAT MASK AS FOLLOWS:                                           *\n*                                                                     *\n*    1. IF A FORMAT BYTE IS '9' THEN THE CORRESPONDING INPUT BYTE     *\n*       MUST BE NUMERIC (0 THROUGH 9). THE INPUT BYTE IS MOVED TO THE *\n*       OUTPUT FIELD.                                                 *\n*    2. IF A FORMAT BYTE IS 'X' THEN NO EDIT IS PERFORMED. THE INPUT  *\n*       BYTE IS MOVED TO THE OUTPUT FIELD.                            *\n*    3. IF A FORMAT BYTE IS ANYTHING OTHER THAN '9' OR 'X' THEN THE   *\n*       CORRESPONDING INPUT BYTE MUST BE THE SAME CHARACTER. THE      *\n*       INPUT BYTE IS NOT MOVED TO THE OUTPUT FIELD.                  *\n*                                                                     *\n* NONE OF THE INITIALIZED VARIABLES ARE CHANGED DURING THE ROUTINE'S  *\n* EXECUTION AND THERE ARE NO INTERNAL DATA FIELDS. ALL MANIPULATION   *\n* IS DONE THROUGH REGISTERS. THE ROUTINE IS COMPLETELY REENTRANT.     *\n*                                                                     *\n* FOUR FIELDS ARE PASSED AS PARAMETERS TO THE ROUTINE:                *\n*                                                                     *\n*   1. A FIELD OF VARYING LENGTH CONTAINING THE INPUT CHARACTERS,     *\n*   2. A 2 BYTE FIELD (IN BINARY FORMAT) CONTAINING THE LENGTH OF     *\n*      THE FORMAT MASK FIELD (BY DEFINITION, THIS IS ALSO THE         *\n*      LENGTH OF THE INPUT FIELD),                                    *\n*   3. A FIELD CONTAINING THE FORMAT MASK, AND                        *\n*   4. A FIELD TO CONTAIN THE CHARACTERS EXTRACTED FROM THE INPUT     *\n*      FIELD.                                                         *\n*                                                                     *\n* SUGGESTED CALLING SYNTAX FOR ALC CALLERS:                           *\n*                                                                     *\n*              CALL IFMTMASK,(INFIELD,FMTLEN,FMTMASK,OUTFIELD)        *\n*                 . . .                                               *\n*     INFIELD  DS   CL14'(915) 695-7000'                              *\n*     FMTLEN   DS   H'14'                                             *\n*     FMTMASK  DS   CL14'(999) 999-9999'                              *\n*     OUTFIELD DS   ZL10                                              *\n*                                                                     *\n* SUGGESTED CALLING SYNTAX FOR COBOL CALLERS:                         *\n*                                                                     *\n*     01  INPUT-FIELD         PIC X(14) VALUE '(915) 695-7000'.       *\n*     01  FORMAT-FIELD-LENGTH PIC S9(4) COMP VALUE 14.                *\n*     01  FORMAT-MASK         PIC X(14) VALUE '(999) 999-9999'.       *\n*     01  OUTPUT-FIELD        PIC 9(10).                              *\n*                                                                     *\n*     CALL 'IFMTMASK' USING INPUT-FIELD, INPUT-FIELD-LENGTH,          *\n*                           FORMAT-MASK, OUTPUT-FIELD.                *\n*                                                                     *\n* NOTE: BY DEFINITION, THE INPUT FIELD AND THE FORMAT MASK FIELD WILL *\n*       HAVE THE SAME LENGTH.                                         *\n*                                                                     *\n* POSSIBLE RETURN CODE VALUES:                                        *\n*     0 - FIELD SUCCESSFULLY CONVERTED                                *\n*     8 - INPUT FIELD DOES NOT CONFORM TO ACCEPTABLE FORMAT RULES     *\n* ******************************************************************* *\n* ******************************************************************* *\n         EJECT\n         PRINT NOGEN\nIFMTMASK CSECT\n         EYEC  'EDIT INPUT FIELD USING FORMAT MASK'\nBEGIN    SAVE  (14,12)                 SAVE CALLER'S REGISTERS\n*\n         BALR  BASE,0                  ESTABLISH BASE REGISTER\n         USING *,BASE                  ASSUME BASE REGISTER\n*\n         LM    INREG,OUTREG,0(R1)      LOAD ADDRESSES OF PARAMETERS\n*\n         SR    R15,R15                 ASSUME RETURN CODE OF ZERO\n*\n         LH    LGTHREG,0(,LGTHREG)     LOAD FIELD LENGTH\n         LTR   LGTHREG,LGTHREG         IS INPUT FIELD LENGTH ZERO?\n         BZ    RETURN                     YES, JUST RETURN TO CALLER\n*\n*    MAIN FIELD PROCESSING LOOP\n*\nLOOP     CLI   0(MASKREG),C'9'         IS NUMERIC BYTE EXPECTED?\n         BE    NUMMOVE                    YES, GO PROCESS\n         CLI   0(MASKREG),C'X'         IS ANY CHARACTER ACCEPTABLE?\n         BE    ALPMOVE                    YES, GO PROCESS\n*\n*    INPUT BYTE MUST MATCH MASK BYTE\n*\n         CLC   0(1,MASKREG),0(INREG)   DO THEY MATCH?\n         BNE   ERROR                      NO, RETURN ERROR\n         B     ENDLOOP                 JUMP TO COMMON EXIT POINT\n*\n*    INPUT BYTE MUST BE NUMERIC DIGIT (X'F0' - X'F9')\n*\nNUMMOVE  CLI   0(INREG),C'0'           IS BYTE LESS THAN X'F0'\n         BL    ERROR                      YES, RETURN ERROR\n         CLI   0(INREG),C'9'           IS BYTE GREATER THAN X'F9'\n         BH    ERROR                      YES, RETURN ERROR\n*\n*    ANY BYTE IS ACCEPTABLE, MOVE TO OUTPUT FIELD\n*\nALPMOVE  MVC   0(1,OUTREG),0(INREG)    MOVE INPUT BYTE TO OUTPUT FIELD\n         LA    OUTREG,1(OUTREG)        POINT TO NEXT OUTPUT CHARACTER\n*\n*    TERMINATION POINT FOR MAIN LOOP\n*\nENDLOOP  LA    MASKREG,1(,MASKREG)     POINT TO NEXT FORMAT CHARACTER\n         LA    INREG,1(,INREG)         POINT TO NEXT INPUT CHARACTER\n         BCT   LGTHREG,LOOP            LOOP FOR EACH CHARACTER IN MASK\n*\n*    AT END OF LOOP, BRANCH AROUND ERROR TO COMMON RETURN POINT\n*\n         B     RETURN\n*\n*    AN ERROR WAS FOUND IN THE INPUT, RETURN CODE IS SET TO \"8\"\n*\nERROR    LA    R15,8                   RETURN CODE OF 8\n*\n*    RETURN TO CALLER WITH RETURN CODE IN REGISTER 15\n*\nRETURN   RETURN (14,12),RC=(15)\n*\n* ******************************************************************* *\n* *************************** CONSTANTS ***************************** *\n* ******************************************************************* *\n         LTORG\n         EJECT\n* ******************************************************************* *\n* **************************** EQUATES ****************************** *\n* ******************************************************************* *\nR0       EQU   0                       REGISTER 0\nR1       EQU   1                       REGISTER 1\nR2       EQU   2                       REGISTER 2\nR3       EQU   3                       REGISTER 3\nR4       EQU   4                       REGISTER 4\nINREG    EQU   5                       INPUT FIELD\nLGTHREG  EQU   6                       INPUT LENGTH\nMASKREG  EQU   7                       FORMAT MASK\nOUTREG   EQU   8                       OUTPUT FIELD\nR9       EQU   9                       REGISTER 9\nR10      EQU   10                      REGISTER 10\nR11      EQU   11                      REGISTER 11\nBASE     EQU   12                      BASE REGISTER\nR13      EQU   13                      REGISTER 13\nR14      EQU   14                      REGISTER 14\nR15      EQU   15                      REGISTER 15\n* ******************************************************************* *\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IFMTNIB": {"ttr": 1038, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132O\\x01\\x132O\"A\\x00\\x8b\\x00\\x8b\\x00\\x00\\xd1\\xc1\\xe8\\xc6\\xd6\\xd9\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-20T00:00:00", "modifydate": "2013-11-20T22:41:00", "lines": 139, "newlines": 139, "modlines": 0, "user": "JAYFORM"}, "text": "         TITLE 'IFMTNIB - VERIFY NO EMBEDED BLANKS IN INPUT FIELD'\n* ******************************************************************* *\n*                                                                     *\n*    IIII   FFFFFFF M     M TTTTTTTT NN   NN  IIII   BBBBBB           *\n*     II    FF      MM   MM    TT    NNN  NN   II    BB   BB          *\n*     II    FF      MMM MMM    TT    NNN  NN   II    BB   BB          *\n*     II    FFFFF   MMMMMMM    TT    NNNN NN   II    BBBBBB           *\n*     II    FF      MM M MM    TT    NN NNNN   II    BB   BB          *\n*     II    FF      MM   MM    TT    NN  NNN   II    BB   BB          *\n*     II    FF      MM   MM    TT    NN  NNN   II    BB   BB          *\n*    IIII   FF      MM   MM    TT    NN   NN  IIII   BBBBBB           *\n*                                                                     *\n* ******************************************************************* *\n* THIS SUBROUTINE SCANS AN INPUT FIELD (DISPLAY FORMAT) TO VERIFY     *\n* THAT THERE ARE NO EMBEDDED BLANKS. THERE CAN BE LEADING BLANKS AND  *\n* TRAILING BLANKS, BUT NO BLANKS MAY OCCUR AFTER THE FIRST NON-BLANK  *\n* CHARACTER IS ENCOUNTERED.                                           *\n*                                                                     *\n* NONE OF THE INITIALIZED VARIABLES ARE CHANGED DURING THE ROUTINE'S  *\n* EXECUTION AND THERE ARE NO INTERNAL DATA FIELDS. ALL MANIPULATION   *\n* IS DONE THROUGH REGISTERS. THE ROUTINE IS COMPLETELY REENTRANT.     *\n*                                                                     *\n* TWO FIELDS ARE PASSED AS PARAMETERS TO THE ROUTINE:                 *\n*                                                                     *\n*   1. A FIELD OF VARYING LENGTH CONTAINING THE INPUT DATA, AND       *\n*   2. A 2 BYTE FIELD (IN BINARY FORMAT) CONTAINING THE LENGTH OF     *\n*      THE FIRST FIELD PASSED.                                        *\n*                                                                     *\n* SUGGESTED CALLING SYNTAX FOR ALC CALLERS:                           *\n*                                                                     *\n*              CALL IFMTNIB,(INFIELD,INLENGTH)                        *\n*                 . . .                                               *\n*     INFIELD  DS   CL12'   128.25   '                                *\n*     INLENGTH DS   H'12'                                             *\n*                                                                     *\n* SUGGESTED CALLING SYNTAX FOR COBOL CALLERS:                         *\n*                                                                     *\n*     01  INPUT-FIELD           PIC X(12) VALUE '   128.25   '.       *\n*     01  INPUT-FIELD-LENGTH    PIC S9(4) COMP VALUE 12.              *\n*                                                                     *\n*     CALL 'IFMTNIB' USING INPUT FIELD, INPUT-FIELD-LENGTH.           *\n*                                                                     *\n* POSSIBLE RETURN CODE VALUES:                                        *\n*     0 - DATA IN FIELD CONTAINS NO IMBEDDED BLANKS                   *\n*     8 - FIELD CONTAINS IMBEDDED BLANKS                              *\n* ******************************************************************* *\n* ******************************************************************* *\n         EJECT\n         PRINT NOGEN\nIFMTNIB  CSECT\n         EYEC  'VERIFY NO EMBEDDED BLANKS IN INPUT FIELD'\nBEGIN    SAVE  (14,12)                 SAVE CALLER'S REGISTERS\n*\n         BALR  BASE,0                  ESTABLISH BASE REGISTER\n         USING *,BASE                  ASSUME BASE REGISTER\n*\n         LM    INREG,LGTHREG,0(R1)     LOAD ADDRESSES OF PARAMETERS\n*\n         SR    R15,R15                 ASSUME RETURN CODE OF ZERO\n*\n         LH    LGTHREG,0(,LGTHREG)     GET LENGTH OF INPUT FIELD\n         LTR   LGTHREG,LGTHREG         IS LENGTH OF FIELD ZERO?\n         BZ    RETURN                     IF YES, RETURN TO CALLER\n*\n*    FIND FIRST NON-BLANK CHARACTER IN FIELD\n*\n         LR    R7,INREG                BEGINNING OF FIELD\n         LR    R8,LGTHREG              LENGTH OF FIELD\n         BCTR  R8,0                    DECREASE BY 1 FOR EXECUTE\n         EX    R8,FINDNB               FIND FIRST NON-BLANK\n         BZ    RETURN                     IF ALL BLANKS, RETURN\n*\n*    FIND NEXT BLANK AFTER FIRST NON-BLANK\n*\n         LR    R7,R1                   FIRST NON-BLANK CHARACTER\n         LR    R8,INREG                BEGINNING OF FIELD ADDRESS\n         AR    R8,LGTHREG              ADD LENGTH OF FIELD\n         SR    R8,R7                   SUBTRACT NON-BLANK CHAR ADDRESS\n         BCTR  R8,0                    DECREASE BY 1 FOR EXECUTE\n         EX    R8,FINDBL               FIND NEXT BLANK\n         BZ    RETURN                     IF NO OTHER BLANKS, RETURN\n*\n*    MAKE SURE NO OTHER NON-BLANKS FOLLOW\n*\n         LR    R7,R1                   TRAILING BLANK CHARACTER\n         LR    R8,INREG                BEGINNING OF FIELD ADDRESS\n         AR    R8,LGTHREG              ADD LENGTH OF FIELD\n         SR    R8,R7                   SUBTRACT TRAILING BLANK ADDRESS\n         BCTR  R8,0                    DECREASE BY 1 FOR EXECUTE\n         EX    R8,FINDNB               LOOK FOR NEXT NON-BLANK\n         BZ    RETURN                     IF NONE FOUND, RETURN\n*\n*    RETURN CODE OF \"8\" INDICATES EMBEDDED BLANKS DETECTED\n*\nERROR    LA    R15,8                    RETURN CODE OF 8\n*\n*    RETURN TO CALLER WITH RETURN CODE IN REGISTER 15\n*\nRETURN   RETURN (14,12),RC=(15)\n*\n*    TRT PERFORMED BY EXECUTE FROM ABOVE TO FIND NON-BLANKS\n*\nFINDNB   TRT   0(0,R7),TABLENB          SCAN FOR NON-BLANK CHARACTERS\n*\n*    TRT PERFORMED BY EXECUTE FROM ABOVE TO FIND BLANKS\n*\nFINDBL   TRT   0(0,R7),TABLEBL          SCAN FOR BLANK CHARACTER\n         SPACE\n* ******************************************************************* *\n* *************************** CONSTANTS ***************************** *\n* ******************************************************************* *\nTABLENB  DC    64X'01'                 TABLE TO FIND NON-BLANKS\n         DC    X'00'\n         DC    191X'01'\nTABLEBL  DC    64X'00'                 TABLE TO FIND BLANKS\n         DC    X'01'\n         DC    191X'00'\n         LTORG\n         EJECT\n* ******************************************************************* *\n* ***************************** EQUATES ***************************** *\n* ******************************************************************* *\nR0       EQU   0                       REGISTER 0\nR1       EQU   1                       REGISTER 1\nR2       EQU   2                       REGISTER 2\nR3       EQU   3                       REGISTER 3\nR4       EQU   4                       REGISTER 4\nINREG    EQU   5                       INPUT FIELD\nLGTHREG  EQU   6                       INPUT FIELD LENGTH\nR7       EQU   7                       REGISTER 7\nR8       EQU   8                       REGISTER 8\nR9       EQU   9                       REGISTER 9\nR10      EQU   10                      REGISTER 10\nR11      EQU   11                      REGISTER 11\nBASE     EQU   12                      BASE REGISTER\nR13      EQU   13                      REGISTER 13\nR14      EQU   14                      REGISTER 14\nR15      EQU   15                      REGISTER 15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OFMTHEX": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132O\\x01\\x132O\"A\\x00w\\x00w\\x00\\x00\\xd1\\xc1\\xe8\\xc6\\xd6\\xd9\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-20T00:00:00", "modifydate": "2013-11-20T22:41:00", "lines": 119, "newlines": 119, "modlines": 0, "user": "JAYFORM"}, "text": "         TITLE 'OFMTHEX - CONVERT HEX DATA TO PRINTABLE CHARACTERS'\n* ******************************************************************* *\n*                                                                     *\n*    OOOOO  FFFFFFF M     M TTTTTTTT HH   HH EEEEEE  XX   XX          *\n*   OO   OO FF      MM   MM    TT    HH   HH EE      XX   XX          *\n*   OO   OO FF      MMM MMM    TT    HH   HH EE       XX XX           *\n*   OO   OO FFFFF   MMMMMMM    TT    HHHHHHH EEEE      XXX            *\n*   OO   OO FF      MM M MM    TT    HH   HH EE        XXX            *\n*   OO   OO FF      MM   MM    TT    HH   HH EE       XX XX           *\n*   OO   OO FF      MM   MM    TT    HH   HH EE      XX   XX          *\n*    OOOOO  FF      MM   MM    TT    HH   HH EEEEEEE XX   XX          *\n*                                                                     *\n* ******************************************************************* *\n* THIS SUBROUTINE READS AN INPUT FIELD AND CONVERTS EACH BYTE TO      *\n* THE CORRESPONDING CHARACTER REPRESENTATION OF THE 2 HEX DIGITS      *\n* THAT CORRESPOND TO THE ORIGINAL BYTE.                               *\n*                                                                     *\n* NONE OF THE INITIALIZED VARIABLES ARE CHANGED DURING THE ROUTINE'S  *\n* EXECUTION AND THERE ARE NO INTERNAL DATA FIELDS. ALL MANIPULATION   *\n* IS DONE THROUGH REGISTERS. THE ROUTINE IS COMPLETELY REENTRANT.     *\n*                                                                     *\n* THREE FIELDS ARE PASSED AS PARAMETERS TO THE ROUTINE:               *\n*                                                                     *\n*   1. A FIELD OF VARYING LENGTH CONTAINING THE INPUT CHARACTERS,     *\n*   2. A 2 BYTE FIELD (IN BINARY FORMAT) CONTAINING THE LENGTH OF     *\n*      THE INPUT FIELD, AND                                           *\n*   3. A FIELD TO CONTAIN THE GENERATED OUTPUT.                       *\n*                                                                     *\n* SUGGESTED CALLING SYNTAX FOR ALC CALLERS:                           *\n*                                                                     *\n*              CALL OFMTHEX,(INFIELD,INLENGTH,OUTFIELD)               *\n*                 . . .                                               *\n*     INFIELD  DS   XL5'C180F0F140'                                   *\n*     INLENGTH DS   H'5'                                              *\n*     OUTFIELD DS   CL10'C180F0F140'                                  *\n*                                                                     *\n* SUGGESTED CALLING SYNTAX FOR COBOL CALLERS:                         *\n*                                                                     *\n*     01  INPUT-FIELD           PIC X(5) VALUE X'C180F0F140'.         *\n*     01  INPUT-FIELD-LENGTH    PIC S9(4) COMP VALUE 5.               *\n*     01  OUTPUT-FIELD          PIC X(10).                            *\n*                                                                     *\n*     CALL 'OFMTHEX' USING INPUT-FIELD, INPUT-FIELD-LENGTH,           *\n*                          OUTPUT-FIELD.                              *\n*                                                                     *\n* NOTE: THE SIZE OF THE OUTPUT FIELD MUST BE TWICE THAT OF THE INPUT  *\n*       FIELD.                                                        *\n*                                                                     *\n* POSSIBLE RETURN CODE VALUES:                                        *\n*     0 - FIELD SUCCESSFULLY CONVERTED                                *\n* ******************************************************************* *\n* ******************************************************************* *\n         EJECT\n         PRINT NOGEN\nOFMTHEX  CSECT\n         EYEC  'CONVERT HEX DIGITS TO PRINTABLE CHARACTERS'\nBEGIN    SAVE  (14,12)                 SAVE CALLER'S REGISTERS\n*\n         BALR  BASE,0                  ESTABLISH BASE REGISTER\n         USING *,BASE                  ASSUME BASE REGISTER\n*\n         LM    INREG,OUTREG,0(R1)      LOAD ADDRESSES OF PARAMETERS\n*\n         SR    R15,R15                 ASSUME RETURN CODE OF ZERO\n*\n         LH    LGTHREG,0(,LGTHREG)     LOAD FIELD LENGTH\n         LTR   LGTHREG,LGTHREG         IS INPUT FIELD LENGTH ZERO?\n         BZ    RETURN                     IF YES, RETURN TO CALLER\n*\n*    OUTER LOOP EXECUTES 1 PASS FOR EACH INPUT CHARACTER\n*\nBYTELOOP LA    R4,2                    CONVERT 2 NIBBLES (1 BYTE)\n         ICM   R3,B'1000',0(INREG)     GET 1 BYTE TO CONVERT\n*\n*    INNER LOOP EXECUTES 2 PASSES FOR EACH INPUT CHARACTER\n*\nNIBLLOOP SR    R2,R2                   CLEAR EVEN WORK REGISTER\n         SLDL  R2,4                    SHIFT LEFT 1 NIBBLE\n         C     R2,=F'10'               COMPARE VALUE WITH DECIMAL 10\n         BM    DIGITS                  BRANCH IF DIGIT 0-9\n         LA    R2,X'C0'-9(,R2)         ADD X'C0'-9 TO REGISTER 2\n         B     SAVENIBL                STORE THE CHARACTER\nDIGITS   LA    R2,X'F0'(,R2)           ADD X'F0' TO REGISTER 2\nSAVENIBL STC   R2,0(,OUTREG)           STORE CONVERTED BYTE\n         LA    OUTREG,1(,OUTREG)       BUMP OUTPUT ADDRESS\n         BCT   R4,NIBLLOOP             CONVERT 2ND NIBBLE\n*\n         LA    INREG,1(,INREG)         BUMP INPUT ADDRESS\n         BCT   LGTHREG,BYTELOOP        CONVERT NEXT BYTE\n*\n*    RETURN TO CALLER WITH RETURN CODE IN REGISTER 15\n*\nRETURN   RETURN (14,12),RC=(15)\n*\n* ******************************************************************* *\n* *************************** CONSTANTS ***************************** *\n* ******************************************************************* *\n         LTORG\n         EJECT\n* ******************************************************************* *\n* ***************************** EQUATES ***************************** *\n* ******************************************************************* *\nR0       EQU   0                       REGISTER 0\nR1       EQU   1                       REGISTER 1\nR2       EQU   2                       REGISTER 2\nR3       EQU   3                       REGISTER 3\nR4       EQU   4                       REGISTER 4\nINREG    EQU   5                       INPUT FIELD\nLGTHREG  EQU   6                       INPUT FIELD LENGTH\nOUTREG   EQU   7                       OUTPUT FIELD\nR8       EQU   8                       REGISTER 8\nR9       EQU   9                       REGISTER 9\nR10      EQU   10                      REGISTER 10\nR11      EQU   11                      REGISTER 11\nBASE     EQU   12                      BASE REGISTER\nR13      EQU   13                      REGISTER 13\nR14      EQU   14                      REGISTER 14\nR15      EQU   15                      REGISTER 15\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OFMTMONY": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132O\\x01\\x132O\"A\\x02\\'\\x02\\'\\x00\\x00\\xd1\\xc1\\xe8\\xc6\\xd6\\xd9\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-20T00:00:00", "modifydate": "2013-11-20T22:41:00", "lines": 551, "newlines": 551, "modlines": 0, "user": "JAYFORM"}, "text": "         TITLE 'OFMTMONY - FORMAT MONETARY AMOUNT IN WORDS'\n* ******************************************************************* *\n*                                                                     *\n*    OOOOO  FFFFFFF M     M TTTTTTTT M     M  OOOOO  NN   NN YY   YY  *\n*   OO   OO FF      MM   MM    TT    MM   MM OO   OO NNN  NN YY   YY  *\n*   OO   OO FF      MMM MMM    TT    MMM MMM OO   OO NNN  NN YY   YY  *\n*   OO   OO FFFFF   MMMMMMM    TT    MMMMMMM OO   OO NNNN NN  YY YY   *\n*   OO   OO FF      MM M MM    TT    MM M MM OO   OO NN NNNN   YYY    *\n*   OO   OO FF      MM   MM    TT    MM   MM OO   OO NN  NNN   YY     *\n*   OO   OO FF      MM   MM    TT    MM   MM OO   OO NN  NNN   YY     *\n*    OOOOO  FF      MM   MM    TT    MM   MM  OOOOO  NN   NN   YY     *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n* THIS SUBROUTINE CONVERTS A NUMERIC INPUT FIELD INTO THE EQUIVALENT  *\n* WRITTEN WORDS DESCRIBING THE VALUE (SUCH AS USED IN WRITING CHECKS) *\n*                                                                     *\n* NONE OF THE INITIALIZED VARIABLES ARE CHANGED DURING THE ROUTINE'S  *\n* EXECUTION AND THERE ARE NO INTERNAL DATA FIELDS. ALL MANIPULATION   *\n* IS DONE THROUGH REGISTERS. THE ROUTINE IS COMPLETELY REENTRANT.     *\n*                                                                     *\n* TWO FIELDS ARE PASSED AS PARAMETERS TO THE ROUTINE:                 *\n*                                                                     *\n*   1) A 13 BYTE NUMERIC INPUT FIELD (IN ZONED-DECIMAL FORMAT), AND   *\n*   2) A 160 BYTE BUFFER WHICH WILL CONTAIN THE FORMATTED OUTPUT      *\n*      (OUTPUT WILL BE LEFT JUSTIFIED AND PADDED WITH ASTERISKS).     *\n*                                                                     *\n* THE UPPER LIMIT FOR THE INPUT VALUE IS 99,999,999,999.99 = NINETY-  *\n* NINE BILLION, NINE HUNDRED AND NINETY-NINE MILLION, NINE HUNDRED    *\n* AND NINETY-NINE THOUSAND, NINE HUNDRED AND NINETY-NINE DOLLARS AND  *\n* 99 CENTS. THE LONGEST OUTPUT STRING POSSIBLE IS FOR THE AMOUNT OF   *\n* 77,777,777,777.77 AND IS 158 CHARACTERS.                            *\n*                                                                     *\n* SUGGESTED CALLING SYNTAX FOR ALC CALLERS:                           *\n*                                                                     *\n*              CALL OFMTMONY,(VALUEIN,VALUEOUT)                       *\n*                 . . .                                               *\n*     VALUEIN  DS   ZL13'0000000152995'                               *\n*     VALUEOUT DS   CL160' '                                          *\n*                                                                     *\n* SUGGESTED CALLING SYNTAX FOR COBOL CALLERS:                         *\n*                                                                     *\n*     01  OFMTMONY-PARAMETERS.                                        *\n*         02  VALUE-INPUT   PIC S9(11)V99 VALUE +1529.95.             *\n*         02  VALUE-OUTPUT  PIC X(160).                               *\n*                                                                     *\n*         CALL 'OFMTMONY' USING VALUE-INPUT, VALUE-OUTPUT.            *\n*                                                                     *\n* THE POSSIBLE VALUES FOR THE RETURN CODE FIELD ARE:                  *\n*                                                                     *\n*     0 - FIELD SUCCESSFULLY CONVERTED                                *\n*     4 - INPUT WAS NEGATIVE, VOID MESSAGE RETURNED                   *\n*     8 - INPUT CONTAINED NON-NUMERIC CHARACTERS                      *\n***********************************************************************\n***********************************************************************\n         EJECT\n         PRINT NOGEN\nOFMTMONY CSECT\n         EYEC  'FORMAT MONEYTARY AMOUNT IN WORDS'\nBEGIN    SAVE  (14,12)                 SAVE CALLER'S REGISTERS\n*\n         BALR  BASE,0                  ESTABLISH BASE REGISTER\n         USING *,BASE                  ASSUME BASE REGISTER\n*\n         LM    INREG,OUTREG,0(R1)      LOAD ADDRESSES OF PARAMETERS\n*\n*    INITIALIZE RETURN CODE\n*\n         SR    R15,R15                 ASSUME GOOD RETURN\n*\n*    TEST FOR NON-NUMERIC CHARACTERS IN INPUT FIELD\n*\n         LR    R2,INREG                ADDRESS INPUT FIELD\n         LA    R3,12                   FIELD LENGTH MINUS 1\nP1NLOOP  CLI   0(R2),X'F0'             TEST LESS THAN C'0'\n         BL    P1NERR                  IF YES, FIELD CONTAINS BAD DATA\n         CLI   0(R2),X'F9'             TEST GREATER THAN C'9'\n         BH    P1NERR                  IF YES, FIELD CONTAINS BAD DATA\n         LA    R2,1(0,R2)              ADDRESS NEXT BYTE\n         BCT   R3,P1NLOOP              CONTINUE TESTING\n         IC    R3,0(,R2)               LOAD RIGHT-MOST CHARACTER\n         LR    R2,R3                   COPY INTO R2\n         N     R3,=F'15'               ISOLATE DIGIT PORTION\n         CH    R3,=H'9'                TEST GREATER THAN 9\n         BH    P1NERR                  IF YES, FIELD CONTAINS BAD DATA\n         SRL   R2,4                    ISOLATE ZONE PORTION\n         CH    R2,=H'12'               TEST FOR 'C' ZONE\n         BE    P1OK2                   IF YES, FIELD IS VALID NUMERIC\n         CH    R2,=H'13'               TEST FOR 'D' ZONE\n         BE    P1OK1                   IF YES, FIELD IS VALID NUMERIC\n         CH    R2,=H'15'               TEST FOR 'F' ZONE\n         BE    P1OK2                   IF YES, FIELD IS VALID NUMERIC\n*\n*    INPUT AMOUNT CONTAINED NON-NUMERIC CHARACTER\n*\nP1NERR   LA    R15,8                   INDICATE BAD DATA\n         B     RETURN                  AND RETURN TO CALLER\n*\n*    SET RETURN CODE TO INDICATE NEGATIVE INPUT VALUE\n*\nP1OK1    LA    R15,4                   SET RETURN CODE TO '4'\n*\n*    SAVE LOW ORDER BYTE OF INPUT VALUE AND CLEAR ANY SIGN\n*\nP1OK2    IC    R11,12(,INREG)          SAVE LOW ORDER BYTE\n         OI    12(INREG),X'F0'         CLEAR SIGN NIBBLE\n*\n*    INITIALIZE REGISTERS FOR CONVERSION\n*\n         SR    WLREG,WLREG             CLEAR WORD LENGTH REGISTER\n         ICM   FLAGS,B'0100',=C' '     SET SEPARATOR TO SPACE\n         ICM   FLAGS,B'0010',=C'S'     DEFAULT PLURAL DOLLARS\n         CLC   0(11,INREG),ZEROS1+3    IS DOLLAR AMOUNT ONLY 1?\n         BNE   INIT1                   NO, USE PLURAL \"DOLLARS\"\n         ICM   FLAGS,B'0010',=C' '     INDICATE SINGULAR DOLLAR\nINIT1    ICM   FLAGS,B'0001',=C'S'     DEFAULT PLURAL CENTS\n         CLC   11(2,INREG),ZEROS1+12   IS CENTS AMOUNT ONLY 1?\n         BNE   INIT2                   NO, USE PLURAL \"CENTS\"\n         ICM   FLAGS,B'0001',=C' '     INDICATE SINGULAR CENT\n*\n*    FILL OUTPUT BUFFER WITH ASTERISKS\n*\nINIT2    MVI   0(OUTREG),C'*'          INITIALIZE OUTPUT\n         MVC   1(159,OUTREG),0(OUTREG) AREA OF 160 BYTES\n*\n*    IF INPUT WAS NEGATIVE, RETURN \"V O I D\"\n*\n         LTR   R15,R15                 WAS INPUT NEGATIVE?\n         BNZ   VOIDCK                  YES, RETURN \"V O I D\"\n*\n         CLC   0(13,INREG),ZEROS1      IS ENTIRE AMOUNT ZERO?\n         BNE   $DOLLARS                NO, GO BEGIN CONVERSION\n*\n*    IF AMOUNT WAS NEGATIVE OR ZERO, RETURN \"V O I D\"\n*\nVOIDCK   LA    WORDREG,VOID            \"V O I D\"\n         ICM   FLAGS,B'0100',=C'!'     INDICATE NO SEPARATOR FOLLOWS\n         BAL   SECBAL,PUTWORD\n         B     RESTORE                 RESTORE INPUT VALUE AND RETURN\n*\n*    IF THE ENTIRE DOLLAR PORTION OF THE FIELD IS ZEROS, OUTPUT THE\n*    WORD \"ONLY\" AND JUMP TO PROCESS CENTS AREA\n*\n$DOLLARS CLC   0(11,INREG),ZEROS1      IS ENTIRE DOLLAR AMOUNT ZERO?\n         BNE   $BILLCK                 NO, GO CHECK BILLIONS\n*\n         LA    WORDREG,ONLY            \"ONLY\"\n         BAL   SECBAL,PUTWORD\n         LA    INREG,11(,INREG)        ADDRESS CENTS\n         B     $CENTS                  GO FORMAT CENTS\n*\n*    IF THE 2 PLACES THAT CONTAIN THE BILLIONS PORTION ARE ZERO,\n*    JUMP TO PROCESS THE MILLIONS PORTION\n*\n$BILLCK  CLC   0(2,INREG),ZEROS1       IS BILLIONS AMOUNT ZERO?\n         BNE   $BILLGO                 NO, CONTINUE\n*\n         LA    INREG,2(,INREG)         ADDRESS MILLIONS\n         B     $MILLCK                 GO CHECK MILLIONS\n*\n$BILLGO  ICM   FLAGS,B'1000',=C'Y'     INDICATE BILLIONS GROUP\n         BAL   PRIBAL,$GROUP           PROCESS GROUP\n         ICM   FLAGS,B'1000',=C'N'     RESET BILLIONS GROUP INDICATOR\n*\n         CLC   0(9,INREG),ZEROS1       IS REMAINDER OF DOLLARS ZERO?\n         BE    $BILL2                  YES, LEAVE SEPARATOR AS SPACE\n*\n         CLC   0(6,INREG),ZEROS1       ARE NEXT TWO GROUPS ZERO?\n         BNE   $BILL1                  NO, INSERT COMMA\n*\n         ICM   FLAGS,B'1000',=C'A'     FLAG TO INSERT \"AND\"\n         B     $BILL2                  CONTINUE\n*\n$BILL1   ICM   FLAGS,B'0100',=C','     CHANGE SEPARATOR TO COMMA\n*\n$BILL2   LA    WORDREG,BILLION         \"BILLION\"\n         BAL   SECBAL,PUTWORD\n*\n         CLM   FLAGS,B'0100',=C','     IS SEPARATOR A COMMA?\n         BNE   $BILL3                  NO, GO CHECK \"AND\" FLAG\n*\n         MVI   0(OUTREG),C' '          INSERT SPACE\n         LA    OUTREG,1(,OUTREG)       BUMP OUTPUT ADDRESS\n         ICM   FLAGS,B'0100',=C' '     CHANGE SEPARATOR TO SPACE\n         B     $MILLCK                 GO CHECK MILLIONS\n*\n$BILL3   CLM   FLAGS,B'1000',=C'A'     IS \"AND\" FLAG SET?\n         BNE   $MILLCK                 NO, GO CHECK MILLIONS\n*\n         LA    WORDREG,AND             \"AND\"\n         BAL   SECBAL,PUTWORD\n         ICM   FLAGS,B'1000',=C'N'     RESET \"AND\" FLAG\n*\n*    IF THE 3 PLACES THAT CONTAIN THE MILLIONS PORTION ARE ZERO,\n*    JUMP TO PROCESS THE THOUSANDS PORTION\n*\n$MILLCK  CLC   0(3,INREG),ZEROS1       IS MILLIONS AMOUNT ZERO?\n         BNE   $MILLGO                 NO, CONTINUE\n*\n         LA    INREG,3(,INREG)         ADDRESS THOUSANDS\n         B     $THOUCK                 GO CHECK THOUSANDS\n*\n$MILLGO  BAL   PRIBAL,$GROUP           PROCESS GROUP\n*\n         CLC   0(6,INREG),ZEROS1       IS REMAINDER OF DOLLARS ZERO?\n         BE    $MILL2                  YES, LEAVE SEPARATOR AS SPACE\n*\n         CLC   0(3,INREG),ZEROS1       IS NEXT GROUP ZERO?\n         BNE   $MILL1                  NO, INSERT COMMA\n*\n         ICM   FLAGS,B'1000',=C'A'     FLAG TO INSERT \"AND\"\n         B     $MILL2                  CONTINUE\n*\n$MILL1   ICM   FLAGS,B'0100',=C','     CHANGE SEPARATOR TO COMMA\n*\n$MILL2   LA    WORDREG,MILLION         \"MILLION\"\n         BAL   SECBAL,PUTWORD\n*\n         CLM   FLAGS,B'0100',=C','     IS SEPARATOR A COMMA?\n         BNE   $MILL3                  NO, GO CHECK \"AND\" FLAG\n*\n         MVI   0(OUTREG),C' '          INSERT SPACE\n         LA    OUTREG,1(,OUTREG)       BUMP OUTPUT ADDRESS\n         ICM   FLAGS,B'0100',=C' '     CHANGE SEPARATOR TO SPACE\n         B     $THOUCK                 GO CHECK THOUSANDS\n*\n$MILL3   CLM   FLAGS,B'1000',=C'A'     IS \"AND\" FLAG SET?\n         BNE   $THOUCK                 NO, GO CHECK THOUSANDS\n*\n         LA    WORDREG,AND             \"AND\"\n         BAL   SECBAL,PUTWORD\n         ICM   FLAGS,B'1000',=C'N'     RESET \"AND\" FLAG\n*\n*    IF THE 3 PLACES THAT CONTAIN THE THOUSANDS PORTION ARE ZERO,\n*    JUMP TO PROCESS THE HUNDREDS PORTION\n*\n$THOUCK  CLC   0(3,INREG),ZEROS1       IS THOUSANDS AMOUNT ZERO?\n         BNE   $THOUGO                 NO, CONTINUE\n*\n         LA    INREG,3(,INREG)         ADDRESS HUNDREDS\n         B     $HUNDCK                 GO CHECK HUNDREDS\n*\n$THOUGO  BAL   PRIBAL,$GROUP           PROCESS GROUP\n*\n         CLC   0(3,INREG),ZEROS1       IS REMAINDER OF DOLLARS ZERO?\n         BE    $THOU2                  YES, LEAVE SEPARATOR AS SPACE\n*\n         CLC   0(1,INREG),ZEROS1       IS HUNDREDS PLACE ZERO?\n         BNE   $THOU1                  NO, CHANGE SEPARATOR TO COMMA\n*\n         ICM   FLAGS,B'1000',=C'A'     FLAG TO INSERT \"AND\"\n         B     $THOU2                  CONTINUE\n*\n$THOU1   ICM   FLAGS,B'0100',=C','     CHANGE SEPARATOR TO COMMA\n*\n$THOU2   LA    WORDREG,THOUSAND        \"THOUSAND\"\n         BAL   SECBAL,PUTWORD\n*\n         CLM   FLAGS,B'0100',=C','     IS SEPARATOR A COMMA?\n         BNE   $THOU3                  NO, GO CHECK \"AND\" FLAG\n*\n         MVI   0(OUTREG),C' '          INSERT SPACE\n         LA    OUTREG,1(,OUTREG)       BUMP OUTPUT ADDRESS\n         ICM   FLAGS,B'0100',=C' '     CHANGE SEPARATOR TO SPACE\n         B     $HUNDCK                 GO CHECK HUNDREDS\n*\n$THOU3   CLM   FLAGS,B'1000',=C'A'     IS \"AND\" FLAG SET?\n         BNE   $HUNDCK                 NO, GO CHECK HUNDREDS\n*\n         LA    WORDREG,AND             \"AND\"\n         BAL   SECBAL,PUTWORD\n         ICM   FLAGS,B'1000',=C'N'     RESET \"AND\" FLAG\n*\n*    IF THE 3 PLACES THAT CONTAIN THE HUNDREDS PORTION ARE ZERO,\n*    JUMP TO FINISH THE DOLLARS PORTION\n*\n$HUNDCK  CLC   0(3,INREG),ZEROS1       IS HUNDREDS AMOUNT ZERO?\n         BNE   $HUNDGO                 NO, CONTINUE\n*\n         LA    INREG,3(,INREG)         ADDRESS CENTS GROUP\n         B     $DFINI                  GO PUT \"DOLLARS\"\n*\n$HUNDGO  BAL   PRIBAL,$GROUP           PROCESS GROUP\n*\n*    FINISH THE DOLLARS PORTION BY DETERMINING IF THE WORD\n*    \"DOLLARS\" SHOULD BE SINGULAR OR PLURAL\n*\n$DFINI   CLM   FLAGS,B'0010',=C'S'     IS DOLLARS AMOUNT PLURAL?\n         BE    $DFINI0                 YES, USE PLURAL\n         LA    WORDREG,DOLLAR          \"DOLLAR\"\n         B     $DFINI1\n$DFINI0  LA    WORDREG,DOLLARS         \"DOLLARS\"\n$DFINI1  BAL   SECBAL,PUTWORD\n*\n*    CONNECT DOLLARS AND CENTS WITH \"AND\"\n*\n         LA    WORDREG,AND             \"AND\"\n         BAL   SECBAL,PUTWORD\n*\n*    IF CENTS PORTION IS ZERO, OUTPUT \"NO CENTS\"\n*\n$CENTS   CLC   0(2,INREG),ZEROS1       IS CENTS ZERO?\n         BNE   $CENTS1                 NO, FORMAT DIGITS\n*\n         LA    WORDREG,NO              \"NO\"\n         BAL   SECBAL,PUTWORD\n         B     $CFINI                  GO FINISH\n*\n*    CENTS PORTION WASN'T ZERO, SO OUTPUT DIGITS OF CENTS\n*    ZERO SUPPRESSING THE FIRST DIGIT\n*\n$CENTS1  CLI   0(INREG),C'0'           IS FIRST DIGIT ZERO?\n         BE    $CENTS2                 YES, OUTPUT SECOND DIGIT\n*\n         MVC   0(1,OUTREG),0(INREG)    OUTPUT FIRST DIGIT\n         LA    OUTREG,1(,OUTREG)       BUMP OUTPUT ADDRESS\n*\n$CENTS2  MVC   0(1,OUTREG),1(INREG)    OUTPUT SECOND DIGIT\n         LA    OUTREG,1(,OUTREG)       BUMP OUTPUT ADDRESS\n*\n         MVI   0(OUTREG),C' '          INSERT SPACE\n         LA    OUTREG,1(,OUTREG)       BUMP OUTPUT ADDRESS\n*\n*    FINISH THE CENTS PORTION BY DETERMINING IF THE WORD\n*    \"CENTS\" SHOULD BE SINGULAR OR PLURAL\n*\n$CFINI   CLM   FLAGS,B'0001',=C'S'     IS CENTS AMOUNT PLURAL?\n         BE    $CFINI0                 YES, USE PLURAL\n         LA    WORDREG,CENT            \"CENT\"\n         B     $CFINI1\n$CFINI0  LA    WORDREG,CENTS           \"CENTS\"\n$CFINI1  ICM   FLAGS,B'0100',=C'!'     INDICATE NO SEPARATOR FOLLOWS\n         BAL   SECBAL,PUTWORD\n*\n*    RESTORE LOW ORDER BYTE OF INPUT VALUE\n*\nRESTORE  L     R2,0(,R1)               ADDRESS INPUT FIELD\n         STC   R11,12(,R2)             RESTORE SAVED BYTE\n*\n*    RETURN TO CALLER WITH RETURN CODE IN R15\n*\nRETURN   RETURN (14,12),RC=(15)\n*\n*     EACH GROUP OF 3 DIGITS TO THE LEFT OF THE DECIMAL POINT\n*     ARE PROCESSED WITH THE CODE BELOW. ONLY THE BILLIONS GROUP\n*     REQUIRES A UNIQUE TEST AS THERE IS NO HUNDRED BILLION BYTE\n*\n$GROUP   CLM   FLAGS,B'1000',=C'Y'     IS THIS BILLIONS GROUP\n         BE    $GTENS                  YES, SKIP HUNDRED'S DIGIT\n*\n         CLI   0(INREG),C'0'           IS HUNDREDS DIGIT ZERO?\n         BNE   $GHUND                  NO, CONTINUE\n*\n         LA    INREG,1(,INREG)         ADDRESS TEN'S DIGIT\n         B     $GTENS                  GO TEST TEN'S DIGIT\n*\n*    OUTPUT THE EQUIVALENT WORD FOR THE HUNDREDS DIGIT\n*\n$GHUND   IC    DIGREG,0(,INREG)        GET DIGIT\n         LA    TABREG,UNITS            UNITS TABLE\n         LA    TELENREG,6              ENTRY IS 6 CHARACTERS LONG\n         BAL   SECBAL,PUTDIGIT\n*\n         LA    WORDREG,HUNDRED         \"HUNDRED\"\n         BAL   SECBAL,PUTWORD\n*\n         LA    INREG,1(,INREG)         ADDRESS TEN'S DIGIT\n*\n         CLC   0(2,INREG),ZEROS1       ARE TENS AND UNITS ZERO\n         BNE   $GHUND0                 NO, MUST INSERT \"AND\"\n*\n         LA    INREG,2(,INREG)         ADDRESS NEXT GROUP\n         B     $GROUPX                 JUMP TO COMMON SUBROUTINE EXIT\n*\n$GHUND0  LA    WORDREG,AND             \"AND\"\n         BAL   SECBAL,PUTWORD\n*\n$GTENS   CLI   0(INREG),C'0'           IS TENS DIGIT ZERO?\n         BNE   $GTENS0                 NO, CONTINUE\n*\n         LA    INREG,1(,INREG)         ADDRESS UNIT'S DIGIT\n         B     $GUNITS                 GO TEST UNIT'S DIGIT\n*\n$GTENS0  CLI   0(INREG),C'1'           IS TEN'S DIGIT '1'?\n         BNE   $GTENSR                 NO, NORMAL TEN'S PROCESS\n*\n         CLI   1(INREG),C'0'           IS UNIT'S DIGIT '0' (10 EVEN)?\n         BE    $GTENSR                 YES, NORMAL TEN'S PROCESS\n*\n*    OUTPUT THE EQUIVALENT WORD FOR THE TEENS DIGIT\n*\n         IC    DIGREG,1(,INREG)        GET DIGIT (UNIT'S FOR TEEN'S)\n         LA    TABREG,TEENS            TEENS TABLE\n         LA    TELENREG,10             ENTRY IS 10 CHARACTERS LONG\n         BAL   SECBAL,PUTDIGIT\n*\n         LA    INREG,2(,INREG)         ADDRESS NEXT GROUP\n         B     $GROUPX                 JUMP TO COMMON SUBROUTINE EXIT\n*\n$GTENSR  CLI   1(INREG),C'0'           IS UNIT'S DIGIT '0' (10 EVEN)?\n         BE    $GTENSRX                YES, NO HYPHEN SEPARATOR\n*\n         ICM   FLAGS,B'0100',=C'-'     CHANGE SEPARATOR TO HYPHEN\n*\n*    OUTPUT THE EQUIVALENT WORD FOR THE EVEN TENS DIGIT\n*\n$GTENSRX IC    DIGREG,0(,INREG)        GET DIGIT\n         LA    TABREG,TENS             TENS TABLE\n         LA    TELENREG,8              ENTRY IS 8 CHARACTERS LONG\n         BAL   SECBAL,PUTDIGIT\n*\n         ICM   FLAGS,B'0100',=C' '     CHANGE SEPARATOR TO SPACE\n*\n         LA    INREG,1(,INREG)         ADDRESS UNIT'S DIGIT\n*\n$GUNITS  CLI   0(INREG),C'0'           IS UNIT'S DIGIT ZERO?\n         BNE   $GUNITS0                NO, CONTINUE\n*\n         LA    INREG,1(,INREG)         ADDRESS NEXT GROUP\n         B     $GROUPX                 JUMP TO COMMON SUBROUTINE EXIT\n*\n*    OUTPUT THE EQUIVALENT WORD FOR THE UNITS DIGIT\n*\n$GUNITS0 IC    DIGREG,0(,INREG)        GET DIGIT\n         LA    TABREG,UNITS            UNITS TABLE\n         LA    TELENREG,6              ENTRY IS 6 CHARACTERS LONG\n         BAL   SECBAL,PUTDIGIT\n*\n         LA    INREG,1(,INREG)         ADDRESS NEXT GROUP\n*\n*     THIS IS THE END OF THE GROUP SUBROUTINE\n*\n$GROUPX  BR    PRIBAL                  RETURN TO CALLING POINT IN MAIN\n*\n*    THIS SECONDARY LEVEL SUBROUTINE USES THE VALUE OF THE DIGIT\n*    LOADED INTO REGISTER 9 TO COMPUTE AN OFFSET INTO THE CONSTANT\n*    TABLE AND COPIES THE CONSTANT WORD INTO THE OUTPUT BUFFER\n*\nPUTDIGIT N     DIGREG,=F'15'           REMOVE SIGN\n         BCTR  DIGREG,0                DECREASE BY 1 (0 BASED OFFSET)\n         MR    R8,TELENREG             MULTIPLY BY ENTRY LENGTH\n         LA    WORDREG,0(DIGREG,TABREG) LOAD ADDRESS OF DIGIT WORD\n*\n*    PUTWORD IS NESTED WITHIN PUTDIGIT TO AVOID A THIRD LEVEL CALL\n*    FROM PUTDIGIT, BUT PUTWORD IS CALLED FROM THE MAIN ROUTINE\n*    TO COPY CONTANT WORDS INTO THE OUTPUT BUFFER\n*\nPUTWORD  IC    WLREG,0(,WORDREG)       GET LENGTH OF WORD\nPUTLOOP  LA    WORDREG,1(,WORDREG)     BUMP ADDRESS PAST LENGTH\n         LR    R8,WLREG                COPY WORD LENGTH\n         BCTR  R8,0                    DECREASE BY 1 FOR EXECUTE\n         EX    R8,VARMOVE              MOVE WORD TO OUTPUT\n         LA    OUTREG,0(WLREG,OUTREG)  UPDATE OUTPUT ADDRESS\n         CLM   FLAGS,B'0100',=C'!'     IS SEPARATOR TO BE INSERTED?\n         BE    PUTX                    NO, JUMP TO EXIT\n         STCM  FLAGS,B'0100',0(OUTREG) INSERT SEPARATOR CHARACTER\n         LA    OUTREG,1(,OUTREG)       UPDATE OUTPUT ADDRESS\nPUTX     BR    SECBAL                  RETURN TO CALLING POINT\n*\n*     THIS IS THE END OF THE PUTDIGIT / PUTWORD SUBROUTINE\n*\nVARMOVE  MVC   0(0,OUTREG),0(WORDREG)  MOVE DIGIT WORD\n*\n****************************** CONSTANTS ******************************\nZEROS1   DC    C'00000000000001'\n*\n*    THE FOLLOWING TABLE CONSISTS OF ENTRIES DESCRIBING WORDS THAT\n*    ARE SELECTED FOR COPYING INTO THE OUTPUT STRING BASED ON THE\n*    INPUT VALUE. EACH TABLE ENTRY IS A ONE BYTE FIELD CONTAINING\n*    THE NUMBER OF BYTES IN THE WORD THAT IS THE REMAINDER OF THE\n*    TABLE ENTRY. THE ORDER OF THE TABLE MUST NOT BE CHANGED.\n*\nVOID     DC    X'07',CL7'V O I D'\nBILLION  DC    X'07',CL7'BILLION'\nMILLION  DC    X'07',CL7'MILLION'\nTHOUSAND DC    X'08',CL8'THOUSAND'\nHUNDRED  DC    X'07',CL7'HUNDRED'\nDOLLAR   DC    X'06',CL6'DOLLAR'\nDOLLARS  DC    X'07',CL7'DOLLARS'\nONLY     DC    X'04',CL4'ONLY'\nAND      DC    X'03',CL3'AND'\nNO       DC    X'02',CL2'NO'\nCENT     DC    X'04',CL4'CENT'\nCENTS    DC    X'05',CL5'CENTS'\nUNITS    DC    X'03',CL5'ONE  '\n         DC    X'03',CL5'TWO  '\n         DC    X'05',CL5'THREE'\n         DC    X'04',CL5'FOUR '\n         DC    X'04',CL5'FIVE '\n         DC    X'03',CL5'SIX  '\n         DC    X'05',CL5'SEVEN'\n         DC    X'05',CL5'EIGHT'\n         DC    X'04',CL5'NINE '\nTEENS    DC    X'06',CL9'ELEVEN   '\n         DC    X'06',CL9'TWELVE   '\n         DC    X'08',CL9'THIRTEEN '\n         DC    X'08',CL9'FOURTEEN '\n         DC    X'07',CL9'FIFTEEN  '\n         DC    X'07',CL9'SIXTEEN  '\n         DC    X'09',CL9'SEVENTEEN'\n         DC    X'08',CL9'EIGHTEEN '\n         DC    X'08',CL9'NINETEEN '\nTENS     DC    X'03',CL7'TEN    '\n         DC    X'06',CL7'TWENTY '\n         DC    X'06',CL7'THIRTY '\n         DC    X'05',CL7'FORTY  '\n         DC    X'05',CL7'FIFTY  '\n         DC    X'05',CL7'SIXTY  '\n         DC    X'07',CL7'SEVENTY'\n         DC    X'06',CL7'EIGHTY '\n         DC    X'06',CL7'NINETY '\n         LTORG\n* ******************************************************************* *\n* ***************************** EQUATES ***************************** *\n* ******************************************************************* *\nR0       EQU   0                       REGISTER 0\nR1       EQU   1                       REGISTER 1\nFLAGS    EQU   2                       TASK FLAGS DURING CONVERSION\n*\n*    REGISTER 2 IS USED TO CONTAIN INDICATORS WHICH CONTROL THE\n*    PROCESSING. THE POSSIBLE VALUES ARE:\n*\n*      B'1000' = 'Y': BILLIONS GROUP IS BEING PROCESSED\n*      B'1000' = 'A': INSERT \"AND\" AFTER WORD INSERTION\n*      B'1000' = 'N': DO NOT INSERT \"AND\" AFTER WORD INSERTION\n*      B'0100' = ' ': INSERT BLANK AFTER WORD INSERTION\n*      B'0100' = ',': INSERT COMMA AFTER WORD INSERTION\n*      B'0100' = '-': INSERT HYPHEN AFTER WORD INSERTION\n*      B'0100' = '!': INSERT NOTHING AFTER WORD INSERTION\n*      B'0010' = 'S': INSERT PLURAL \"DOLLARS\"\n*      B'0010' = ' ': INSERT SINGULAR \"DOLLAR\"\n*      B'0001' = 'S': INSERT PLURAL \"CENTS\"\n*      B'0001' = ' ': INSERT SINGULAR \"CENT\"\n*\nR2       EQU   2                       REGISTER 2\nSECBAL   EQU   3                       SECONDARY INTERNAL BAL REGISTER\nR3       EQU   3                       REGISTER 3\nPRIBAL   EQU   4                       PRIMARY INTERNAL BAL REGISTER\nINREG    EQU   5                       INPUT FIELD POINTER\nOUTREG   EQU   6                       OUTPUT FIELD POINTER\nWORDREG  EQU   7                       LITERAL WORD POINTER\nTABREG   EQU   7                       WORD LOOKUP TABLE BASE\nR8       EQU   8                       REGISTER 8\nDIGREG   EQU   9                       DIGIT\nWLREG    EQU   9                       WORD LENGTH\nTELENREG EQU   10                      ENTRY LENGTH\nR11      EQU   11                      REGISTER 11\nBASE     EQU   12                      BASE REGISTER\nR14      EQU   14                      REGISTER 14\nR15      EQU   15                      REGISTER 15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT903/FILE903.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT903", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}