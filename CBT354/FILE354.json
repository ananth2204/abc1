{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011824000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 5819814, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 20, "INMDSNAM": "CBT.V500.FILE354.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 5819814, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 5819814, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE354.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00[\\x0b'", "DS1TRBAL": "b'@\\xae'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\x91\\x00\\x04\\x02\\x97\\x00\\x05\\x00\\\\'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$$$DOC": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x04/\\x13\\x03\\x01\\x0e\\x00h\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-11T13:03:00", "lines": 270, "newlines": 104, "modlines": 0, "user": "RH87944"}, "text": "  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n              $$$$$DOC\n             ----------------\n\n  February 1999. This file contains several programs created or\n                 modified by:\n         Randy Hall,\n         1151 Palmer Road,\n         Victoria, B.C.\n         V8P-2H5\n         Phone: Home: 250-385-1061         Work: 250-413-8229\n         E-MAil:randy.hall@i.am            randy.hall@gems9.gov.bc.ca\n                randy.hall@usa.net\n\n$$$$$DOC is the \"master doc\" for this file. This file contains\nseveral different programs that are further documented in individual\n$$DOC... members if the installation is more complicated than just\nrunning the job.\n\nIf there is no $$DOC... member, the program should hopefully be\nself-contained and self-explanatory.\n\nJCL in all jobs will have to be modified for your dataset names\nand your procedure names.\n\nAlso note that I'm one of those programmers who doesn't delete code...\nI just comment it out, so some source may have a lot of commented\ncode!\n\nA lot of the programs in this file do not specifically have a\ncopyright notice imbedded in them, so this notice applies to\nALL my source....\n\n           COPYRIGHT\n   THE METHODS AND CODE IN THIS PROGRAM ARE COPYRIGHTED BY:\n   RANDY HALL,\n   1151 PALMER ROAD,\n   VICTORIA, B.C. CANADA, V8P-2H5\n   E-MAIL...BITRON@ISLANDNET.COM or randy.hall@i.am\n\n   YOU MUST LEAVE IT AS IS, AND CANNOT SELL IT TO ANYONE,\n   OR MODIFY IT, WITHOUT MY  PERMISSION.\n\nIf you do make changes, I would appreciate it if you sent me a copy\nso that I can keep my source up-to-date. Thanks...\n\nThe programs, and their individual \"doc\"s are:\n\nProgram   \"doc\"        description\n====================================================================\nABS.......             Macro to simulate the pli abs function\n                       Written 90/01/03\n\nA31BITMD..             Example of 31 bit mode and see if a module\n                       is loaded\n\nBACKDSNS..             Utility to backup a list of datasets.\n                       Last assembled 99/01/29\nBACKSAMP..             Sample jcl to backup datasets.\nBACKSAM2..             Sample jcl to restore datasets.\n\nBLNKSCRN..             Sample code to blank a 3270 screen\n                       Last assembled 96/02/02\n\nCALLIDC...             How to call IDCAMS in a program\n                       Last assembled 99/02/02\nCALLIDCT..             Sample jcl to run CALLIDC\n\nCDSCB.....             TSO command to modify DSCB's.\n                       Originally written by BILL GODFREY.\n                       I added RACF support for control. See the\n                       comments in the program.\n                       Last assembled 98/08/28\n\nCHKOTMA...             Program to check that TCPIP/IMSOTMA interface\n                       is working. This requires a transaction\n                       called WHOAMI.\n                       Last assembled 98/12/21\nCHKOTMAR..             Rexx exec to invoke CHKOTMA.\n                       CHKOTMA and CHKOTMAR will have to be modified\n                       for your port numbers, etc...\n\nDATEFB....             Read a fixed length file and change the date\n                       field to include the century.\n                       Last assembled 97/02/14\nDATEFBJ...             Sample jcl to run DATEFB\n\nDATEVB....             Read a variable length file and change the\n                       date field to include the century.\n                       Last assembled 97/02/14\nDATEVBJ...             Sample jcl to run DATEVB\n\nDAYDATE...             Time of day and date subroutine.\n                       DAYDATE is INCLUDEd in IUTDEL and JDATE.\n                       Last assembled 98/01/09\n\nDELMEMS...             Delete list of members from pds\n                       Last assembled 91/06/19\nDELMEMSJ..             Sample jcl to run DELMEMS\n\nDISALINK..$$DOCDIS     Program to dis-assemble CSECTs\nDISASM\nDISASM1\nDISASM2\nDISASM3A\nDISASM3B\nDISASPRM\n                       Last assembled 99/01/08\nDISASRUN..             Sample jcl to run DISASM\n\nDSPACE....             Tso command to display dataset information.\n(DS)                   Can also be run in batch.\n                       Last assembled 99/01/14\nDSB.......             REXX exec to run DS\n\nENQ.......             This version is for pre-sp3 systems\n                       command to list enqueued dataset names\n                       Last assembled 82/07/16...may need work!\n\nFILEDUMP..             A program that will list (dump) any file\n                       in an abend type listing.\n                       See HOWFDUMP for documentation.\n                       Last assembled 90/03/13...still works.\nFILEDUMJ..             Sample jcl to run FILEDUMP\n\nFREEALL...             TSO command processor used to free\n                       all dynamically allocated data sets\n                       which have been allocated by a tso user.\n                       Originally from CBT320, 10/20/75...\n                       Last assembled 92/10/28...still works.\n\nGENQ......             Command to list enqueued dataset names.\n                       This version is for sp3 systems\n                       Last assembled 96/07/11...still works.\nGENQCLST..             CLIST to run GENQ\n\nGETDSNS...             Get a list of all catalogued datasets\n                       for hli in sysin\n                       Can be used to get dataset names for BACKDSNS.\n                       Last assembled 95/10/30...still works.\nGETDSNSJ..             Sample jcl to run GETDSNS\n\nHALLDUMP..             Example of how to use HDUMP\n                       Last assembled 98/12/13\n\nHDUMP.....             Macro to dump core in a running program.\n                       Last assembled 98/12/13\n\nHLASMC                 The assembler compile proc used here.\n\nHLASMCL                The assembler compile and link proc used here.\n\nHOWBACK                SCRIPT documentation for BACKDSNS\n\nHOWDELM                SCRIPT documentation for DELMEMS\n\nHOWDISAS               Documentation for DISASM\n\nHOWDS                  Documentation for DS(PACE) for paper\n                       There is a SYS1.HELP version with the program.\n\nHOWFDUMP               Documentation for FILEDUMP\n\nHOWHDUMP               Documentation for HDUMP\n\nHOWSETDT               Documentation for SETDATE\n\nHOWTCOPY               Documentation for TAPECOPY\n\nHOWVSPLT               Documentation for VSPLIT\n\nIUTDEL....             Delete members from a pds with an audit trail\n                       Last assembled 91/06/19\nIUTDELJ...             Sample jcl to run IUTDEL\n\nJDATE.....             TSO command to Display todays julian date, etc.\n                       Last assembled 97/03/16\n\nJOBNAME...             Get job name and number from jes2,\n                       compare to tiot\n                       See SETDATEC for an example of how to use it.\n                       Last assembled 93/12/13\n\nLINKDATE.....          Program to create list of member\n                       names and link dates in a pds.\n                       Last assembled 99/01/18\nLINKDATJ..             Sample jcl to run LINKDATE\n\nMEMLIST......          Produce a list of members in a pds.\n                       names are in columns 1-8\n                       Last assembled 93/10/18\nMEMLISTJ..             Sample jcl to run MEMLIST\n\n\nMACROS....             macro     used for...\n                       begin     generate entry code with base\n                                 regs r13,&b,&c\n                       debug     generate code  to print a\n                                  csect trace\n                       ibmmac    generate dcb and jfcb dsects\n                       msgrtn    generate code to print messages\n                       olcmsg    generate code to print a msg\n                       perform   generate code  to branch to a csect\n                       requate   generate register equates, and\n                                 a savearea dsect\n                       saveset   generate ims style save areas\n                       secexit   generate csect exit code\n                       section   generate csect entry code\n\nMOD.......             Macro that simulates the pli mod function\n\nPGMDATE......          Produce list of members in a pds\n                       older than specified date.\n                       Last assembled 99/01/19\nPGMDATEJ..             Sample jcl to run PGMDATE\n\nPRINTDOC               Sample jcl to print SCRIPT documentation.\n                       This will have to be modified a lot...\n\nSETDATE...             Put date into a control record in a dataset, or\n                       pass it back in the parm.\n                       Last assembled 97/10/30\nSETDATEC..             Sample pli program calling SETDATE\n                       Last assembled 97/08/19\nSETDATEJ..             Sample JCL calling SETDATE\n\nSLOCATE...             Sample code to call SUPER LOCATE\n                       See DSPACE for usage...\n\nSMFEXIT...             This  little program is  used to produce\n                       a readable report based on type 14, 15,\n                       17 and 18 smf records\n                       Last assembled 92/11/17\n\nSUBEDIT....            Submit any 1-126 byte command from\n                       parm= or  //sysin\nSUBEDITJ..             Sample JCL calling SUBEDIT\n\nTAPECOPY..             A program that will list (dump) or copy\n                       a tape.\n                       See HOWTCOPY for documentation.\n                       Last assembled 90/03/15.\nTAPECOPJ..             Sample jcl to run TAPECOPY\n\nVSPLIT....             Utility program to select records from a\n                       VB file.\n                       Last assembled 96/07/03\nVSPLITJ...             Sample JCL calling VSPLIT to select specific\n                       records from an IMS log\n\nWHOAMI....             IMS transaction called by CHKOTMA.\n                       Last assembled 98/11/03\n\nYRDOC                  Documentation for YR2000\n\nYR2000....             Utility program to determine if load modules\n                       access the system date ro a date routine\n                       Last assembled 99/01/27\nYR2000J...             Sample JCL calling YR2000\n\nZELLERS...             Assembler version of T.F. Wong's\n                       calculate day of week formula.\n                       See DAYDATE for usage...\n                   See http://www/asiaonlin.net.hk/~tfwong/maths.htm\n\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$DOCBAC": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x99\\x02\\x9f\\x00\\x99\\x02\\x9f\\t\\x19\\x00,\\x00*\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-01-29T00:00:00", "modifydate": "1999-01-29T09:19:00", "lines": 44, "newlines": 42, "modlines": 0, "user": "RH87944"}, "text": "  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n              REFERENCE INDEX\n             ----------------\n\n  January 1999. This version of BACKDSNS was written by:\n\n         Randy Hall,\n         1151 Palmer Road,\n         Victoria, B.C.\n         V8P-2H5\n         Phone:250-386-1061          Work: 250-413-8229\n         E-MAil:randy.hall@i.am  or randy.hall@gems9.gov.bc.ca\n\n The program BACKDSNS is used to backup datasets to tape, based on\n the dataset names contained in the //DSNS control stream.\n\n The program BACKDSNS is used to restore datasets from tape,\n based on the dataset names contained in the //RESTORE control stream.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  MEMBER    Description or purpose\n  ========  ============================================================\n  --------  ------------------------------------------------------------\n  $DOC      This file. Describes the contents of the PDS.\n\n  BACKDSNS  Jcl to assemble BACKDSNS in one job.\n            Dataset names must be changed.\n\n  HOWPRINT  Sample Jcl to print the BACKDSNS documentation.\n            The manual is in SCRIPT format.\n            Dataset names must be changed.\n            This jcl will probably have to be modified quite\n            a bit for your system.....\n\n  HOWBACK   SCRIPT format BACKDSNS documentation.\n\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  If you have any questions or comments, please contact me at\n  randy.hall@i.am or randy.hall@usa.net\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$DOCDIS": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x99\\x00\\x9f\\x00\\x99\\x03/\\x11V\\x00e\\x01\\xa3\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1999-01-09T00:00:00", "modifydate": "1999-02-01T11:56:00", "lines": 101, "newlines": 419, "modlines": 0, "user": "RH87944"}, "text": "  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n              REFERENCE INDEX\n             ----------------\n\n  January 1999. This version of DISASM has been modified by:\n\n         Randy Hall,\n         1151 Palmer Road,\n         Victoria, B.C.\n         V8P-2H5\n         Phone:250-385-1061          Work: 250-413-8229\n         E-MAil:randy.hall@i.am            randy.hall@gems9.gov.bc.ca\n\n  DISASM was heavily modified to produce a more useable and readable\n  assembler listing type of output. If a source deck is produced, it\n  can, in most cases, be passed through the assembler compiler to\n  produce a valid load module. This is a very usefull feature if the\n  original source for a load module has been lost, and modifications\n  are to be made to the module.\n  All (hopefully) changes have RH in columns 69-70.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  MEMBER    Description or purpose\n  ========  ============================================================\n  $ASM      Jcl to assemble DISASM in one job. To run this jcl,\n            the jcl around members DISASM, DISASM1, and DISASM2\n            must be removed.\n            Dataset names must be changed.\n\n  $REQU     Macro for register equates. This is not used in this\n            version of DISASM.\n\n  CBTJCL    Jcl to ??\n\n  CLIST     Sample clist to run DISASM under TSO. I have not tested\n            this...\n\n  CLIST2    Sample clist to run DISASM under TSO TEST.\n            Dataset names must be changed.\n\n  DISALINK  Jcl to link object modules DISASM, DISASM1, and DISASM2\n            to produce load module DISASM.\n            Dataset names must be changed.\n            This jcl assumes you have an object module library.\n\n  DISASM    The is part 1 of the DISASM program.\n            Dataset names must be changed.\n            This job creates an object module in SYSLIN.\n            This jcl assumes you have an object module library.\n            Dataset names must be changed.\n\n  DISASM1   The is part 2 of the DISASM program.\n            Dataset names must be changed.\n            This job creates an object module in SYSLIN.\n            This jcl assumes you have an object module library.\n            Dataset names must be changed.\n\n  DISASM2   The is part 3 of the DISASM program.\n            Dataset names must be changed.\n            This job creates an object module in SYSLIN.\n            This jcl assumes you have an object module library.\n            Dataset names must be changed.\n\n  DISASM3A  Copy member used by DISASM, DISASM1, and DISASM2.\n            This member defines valid instruction op codes, etc.\n\n  DISASM3B  Copy member used by DISASM, DISASM1, and DISASM2.\n            This member defines valid SVC op codes, etc.\n\n  DISASPRM  Copy member used by DISASM, DISASM1, and DISASM2.\n            This member contains DSECTS used by DISASM.\n            They are: COMMPARM, LABELD, USINGD, DSECTD, RLDTBLD,\n                      and SYMTBL. I have changed COMMPARM.\n\n  HOWDISAS  DISASM documentation and jcl to print it.\n\n  OLDDOC    Old DISASM documentation.\n\n  REQU      Macro to generate register equates. I don't use this.\n\n  RUNDIS    Jcl to run DISASM.\n            Dataset names must be changed.\n\n  SVLNK     Macro to generate program entry code.\n\n  SYSIN     SYSIN control statements used by CLIST2.\n\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  This PDS is set up to run members DISASM, DISASM1, and DISASM2 to\n  create object modules which are then linked together in DISALINK\n  to create the DISASM load module.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  If you have any questions or comments, please contact the people\n  in the documemntation.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$ASM": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x00\\x8f\\x00\\x99\\x00\\x9f\\x12I\\x00\\x1b\\x00\\x17\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-01-08T00:00:00", "modifydate": "1999-01-09T12:49:00", "lines": 27, "newlines": 23, "modlines": 0, "user": "RH87944"}, "text": "//$ASM     JOB (87944,348496),HALL.S1BL,MSGCLASS=A,\n//             USER=RH87944,PASSWORD=*,GROUP=IMSVS\n/*ROUTE PRINT R7\n//* JOB($ASM) - ASSEMBLE DISASSEMBLER\n//*\n//*  BEFORE RUNNING THIS JOB, CHANGE RH87944.SOURCE.CNTL AND\n//*  HALL.LOAD TO YOUR DATASET NAMES AND REMOVE THE JCL\n//*  FROM THE DISASM, DISASM1, AND DISASM2 SOURCE FILES.\n//*\n//S0  EXEC HLASMCL,CLASS='*',\n// PARM.ASM='OBJECT,NODECK,BATCH',\n// PARM.LKED='XREF,LET,LIST,NCAL'\n//ASM.SYSLIB DD DISP=SHR,DSN=SYS1.MACLIB\n//           DD DISP=SHR,DSN=SYS1.MODGEN\n//           DD DISP=SHR,DSN=SYS1.ATSOMAC\n//           DD DISP=SHR,DSN=RH87944.SOURCE.CNTL\n//ASM.SYSIN  DD DISP=SHR,DSN=RH87944.SOURCE.CNTL(DISASM)\n//           DD DISP=SHR,DSN=RH87944.SOURCE.CNTL(DISASM1)\n//           DD DISP=SHR,DSN=RH87944.SOURCE.CNTL(DISASM2)\n//LKED.SYSLMOD DD DISP=SHR,DSN=HALL.LOAD\n//LKED.SYSIN DD *\n ENTRY DISASM\n SETCODE AC(0)\n MODE    AMODE(24) RMODE(24)\n NAME    DISASM(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$REQU": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x00\\x9f\\x00\\x99\\x00\\x9f\\x12X\\x00\\x1a\\x00\\x1a\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-01-09T00:00:00", "modifydate": "1999-01-09T12:58:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "RH87944"}, "text": "         MACRO\n         REQU\n**                           EQUATES FOR SYMBOLIC REG USAGE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nRA       EQU   10\nRB       EQU   11\nRC       EQU   12\nRD       EQU   13\nRE       EQU   14\nRF       EQU   15\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "A31BITMD": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x140\\x00\\xf6\\x00\\xf6\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T14:30:00", "lines": 246, "newlines": 246, "modlines": 0, "user": "RH87944"}, "text": "//ADMASP   JOB\n/*ROUTE PRINT R115\n//S EXEC HLASMC,PARMC='NOALIGN,NORLD',CLASS='*'\n//ASM.SYSLIN DD DISP=SHR,DSN=VSAPL.OBJLIB(ADMASP)\n//ASM.SYSIN DD *\n*\n*        NOTE. CSECT CODE STARTS  AT LINE 12100\n*\n         TITLE 'ADMASPT FAKEOUT MODULE FOR VSAPL'\n*              RANDY HALL, DIVERSIFIED DEVELOPMENTS, 1984'\n*              1151 PALMER ROAD,\n*              VICTORIA, B.C. CANADA\n*              604-386-1061\n*\n***********************************************************************\n*                                                                     *\n*   DIVERSIFIED DEVELOPMENTS ADMASPT, VERSION 14.0                    *\n*                                                                     *\n*   THIS PROGRAM IS LINKED WITH VSAPL TO LOAD THE REAL ADMASPT IF     *\n* AND WHEN THE USER WANTS GDDM SERVICES. BY LOADING ADMASPT AT        *\n* EXECUTION TIME RATHER THAN AT LINK TIME, WE ENSURE THAT WE          *\n* ALWAYS USE AN UP-TO-DATE VERSION OF GDDM, AND IT ALSO AVOIDS        *\n* THE RE-LINKING OF VSAPL EVERY TIME GDDM IS CHANGED.                 *\n*                                                                     *\n* WE ALSO CHECK TO SEE IF WE ARE BEING CALLED FROM 24 OR 31 BIT       *\n* MODE AND CALL ADMASPT IN THE APPROPRIATE MODE.                      *\n*                                                                     *\n***********************************************************************\n         EJECT\n         MACRO\n&NAME    BEGIN &A,&B,&C\n         USING   *,15        GET TEMP ADDRESSABLIITY\n&NAME    SAVE  (14,12),,*\n         CNOP  0,4           ALIGN ON WORD BOUNDARY\n         BAL   14,*+76       BRANCH ROUND SAVE AREA\n         AIF   (T'&B NE 'O').NO1\n         USING *,13          GET ADDRESSABLIIT\n         AGO   .NO3\n.NO1     AIF   (T'&C NE 'O').NO2\n         USING *,13,&B\n         AGO   .NO3\n.NO2     USING *,13,&B,&C\n.NO3     ANOP\n         DC    F'0'          SET HIGH ORDER WORD TO 0 FOR PL1\n         DS    17F\n         DROP  15\n         ST    13,4(14)      SAVE REGS 13 AND\n         ST    14,8(13)      BACK CHAIN)\n         LR    13,14         GET SAVE AREA ADDRESS\n         AIF   (T'&B EQ 'O').NO4\n         LA    &B,2048(13)   GET SECOND BASE REGISTER\n         LA    &B,2048(&B)   GET SECOND BASE REGISTER\n         AIF   (T'&C EQ 'O').NO4\n         LA    &C,4095(0,&B)      SET UP THIRD BASE REGISTER        RH\n         LA    &C,1(0,&C)         *                                 RH\n.NO4     AIF   (T'&A NE 'O').B\n         MEXIT\n.B       XC    &A.X,&A.X     CLEAR RETURN CODE\n&NAME    B     A23K&SYSNDX   BRANCH ROUND RETURN\n         SPACE 1\n&A       LA    15,0          GET RETURN CODE\n         ORG   *-2\n&A.X     DS    H             HALF WORD RETURN CODE, INITIALY ZERO\n         L     13,4(13)      GET OLD SAVE AREA\n         L     14,12(13)     GET REG 14\n         LM    0,12,20(13)   GET REST OF REGS\n         BR    14\n         SPACE 1\nA23K&SYSNDX    DS    0H      START OF MAIN LINE CODE\n         MEND\n         MACRO\n         REGEQU\n         SPACE 1\n*        STANDARD REGISTER EQUATES. B.C. GOVERNMENT.\n         SPACE 1\n*        GENERAL PURPOSE REGISTERS.\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\n*        FLOATING POINT\nFL0      EQU   0\nFL2      EQU   2\nFL4      EQU   4\nFL6      EQU   6\n         SPACE 2\n         MEND\n         EJECT\n***********************************************************************\n*                                                                     *\n*   REGISTER USAGE.                                                   *\n*   R0, ........................ WORK                                 *\n*   R1  ........................ WORK                                 *\n*   R2  ........................ NOT USED                             *\n*   R3  ........................ NOT USED                             *\n*   R4  ........................ NOT USED                           RH*\n*   R5  ........................ NOT USED                             *\n*   R6  ........................ NOT USED                           RH*\n*   R7  ........................ NOT USED                           RH*\n*   R8  ........................ NOT USED                             *\n*   R9  ........................ NOT USED                             *\n*   R10 ........................ NOT USED                             *\n*   R11 ........................ NOT USED                             *\n*   R12  ....................... BASE REGISTER                        *\n*   R13  ....................... SAVE                                 *\n*   R14, R15 ................... WORK ,OS LINK REGISTERS              *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n         REGEQU\n         ENTRY ADMASP\nADMASP   CSECT\nADMASP   AMODE ANY\nADMASP   RMODE ANY\n*        BEGIN                                                      RH\n         USING ADMASP,R15         SET TEMP BASE REG                 RH\n         B     AROUND             GO AROUND ID\n         DC    X'07'\n         DC    CL7'ADMASP '\n         SPACE 1\nAROUND   DS    0H\n         LA    R1,0(0,R1)         CLEAR R1 HI-ORDER BYTE FOR 31     RH\n         LR    R2,R1              SAVE PARM ADDR                    RH\n         LA    R13,0(0,R13)       CLEAR R13 HI-ORDER BYTE FOR 31    RH\n         BSM   14,0               SAVE CURRENT AMODE                RH\n         STM   R14,R12,12(R13)    SAVE VSAPL REGS\n         LA    R12,SAVE           R12 -> TO OUR SAVE AREA           RH\n         ST    R13,SAVE+4         SAVE A(VSAPLS SAVE AREA)          RH\n         ST    R12,8(0,R13)       SAVE A(OUR SAVE AREA)             RH\n         LR    R13,R12            R13 -> TO OUR SAVE AREA           RH\n*        STM   R14,R12,12(R13)    SAVE VSAPL REGS IN OUR SAVE AREA  RH\n         LR    R12,R15            LOAD OUR BASE REG                 RH\n         DROP  R15                DROP TEMP BASE REG                RH\n         USING ADMASP,R12         SET OUR BASE REG                  RH\n         SPACE\nADMASP31 DS    0H\n         ICM   R15,15,CADMASPT    HAS ADMASPT BEEN LOADED ALREADY ?\n         BNZ   SKIPLOAD           YES, ON WE GO\n         SPACE 1\n         LOAD  EP=ADMASPT,ERRET=BADLOAD LOAD ADMASPT\n         SPACE 1\nFOUNDIT  DS    0H\n         ST    R0,CADMASPT        SAVE ENTRY ADDRESS\n         LR    R15,R0             PUT ENTRY ADDRESS INTO R15        RH\n         SPACE 1\nSKIPLOAD DS    0H\n         LR    R1,R2              RELOAD VSAPL PARM ADDRESS         RH\n*        L     R1,20(R13)         RELOAD VSAPL PARM ADDRESS         RH\n*              GET INTO PROPER MODE AND GO TO REAL ADMASPT          RH\n         BASSM R14,R15                                              RH\n         SPACE 1\n         L     R13,4(0,R13)       R13 -> BACK TO VSAPL SAVE AREA    RH\n         ST    R15,16(0,R13)      PUT RC INTO VSAPL SAVE AREA       RH\n         LM    R14,R12,12(R13)    RELOAD VSAPL REGS\n*              GET INTO PROPER MODE AND GO BACK TO VSAPL            RH\n         BSM   0,R14                                                RH\n         SPACE 1\nBADLOAD  DS    0H\n         L     R13,4(0,R13)       R13 -> BACK TO VSAPL SAVE AREA    RH\n         ST    R15,16(R13)        SAVE LOAD'S RC\n         TPUT  MSG,LMSG           SEND HIM A MSG\n         LM    R14,R12,12(R13)    RELOAD VSAPL'S REGS\n*              GET INTO PROPER MODE AND GO BACK TO VSAPL            RH\n         BSM   0,R14              GO BACK TO VSAPL WITH BAD RC\n         SPACE 1\nMSG      DC    C'INVALID LOADLIB FOR GDDM'\nLMSG     EQU   *-MSG\nCADMASPT DC    F'0'\nSAVE     DC    18F'0'\n         LTORG\n         END\n         SPACE 1\n*\n*        THE FOLLOWING CODE COULD ALSO BE USED FOR PART\n*        OF YOUR CODE TO BE EXECUTED AS 31 BIT CODE\n*\n*\n*        BECAUSE SOME OF THE CONTROL BLOCKS MUST BE ACCESSED IN 31\n*        BIT MODE (OUXB FOR ONE) PUT US INTO 31 BIT MODE ADDRESSING\n*\n*        LA    R7,0(0,R7)         CLEAR BYTE 0 OF BASE REG 7        RH\n         L     R1,XADDR1          GET 31 BIT MODE ADDRESS           RH\n         BSM   0,R1               GET INTO 31 BIT MODE              RH\n         DS    0F                 ALIGN ON A FULLWORD BOUNDARY      RH\nXADDR1   DC    X'80',AL3(*+3)     NEXT ADDRESS IS 31 BIT MODE       RH\n*\n*              OR WITHOUT LABELS. ..\n*\n         CNOP  0,4                ALIGN ON A FULLWORD BOUNDARY      RH\n         L     R1,*+8             GET 31 BIT MODE ADDRESS           RH\n         BSM   0,R1               GET INTO 31 BIT MODE              RH\n         BSM   0,R1               TO FILL 4 BYTES                   RH\n         DC    X'80',AL3(*+3)     NEXT ADDRESS IS 31 BIT MODE       RH\n         SPACE 1\n*\n*        YOUR  CODE GOES HERE\n*\n*\n*        NOW GO BACK TO 24 BIT MODE ADDRESSING\n*\n         LA    R1,XADDR4          GET BACK INTO 24 BIT MODE         RH\n  OR     LA    R1,*+4+2           GET BACK INTO 24 BIT MODE         RH\n         BSM   0,R1               ''                                RH\nXADDR4   DS    0H                                                   RH\n*\n         SPACE 1\n*\n*        OR ANOTHER METHOD OF SETTING AMODE...THANKS TERRY C...\n*\n*\n*\n*      THIS ROUTINE SWITCHES THE AMODE TO 24\n*      ENTRY TO THIS ROUTINE IS THROUGH A BAS  R14,@AMODE24\n*\n         DS    0F\n         DC    X'7FFFFFFF'\n@AMODE24 EQU   *\n         N     R14,*-4\n         BSM   0,R14\n*\n*      THIS ROUTINE SWITCHES THE AMODE TO 31\n*      ENTRY TO THIS ROUTINE IS THROUGH A BAS  R14,@AMODE31\n*\n         DS    0F\n         DC    X'80000000'\n@AMODE31 EQU   *\n         O     R14,*-4\n         BSM   0,R14\n*\n*\n*\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BACKDSNS": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x04/\\x12X\\x1a\\x06\\x1aw\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-11T12:58:00", "lines": 6662, "newlines": 6775, "modlines": 0, "user": "RH87944"}, "text": "//BACKDSNS JOB\n/*ROUTE PRINT R7\n//*\n//* JOB(BACKDSNS) - ASSEMBLE BACKDSNS AND HALLDUMP...\n//*\n//*\n//*  DSN=CBT.SOURCE(BACKDSNS)\n//*\n//* JOB(BACKDSNS) - ASSEMBLE BACKDSNS AND HALLDUMP...\n//*\n//*  BEFORE RUNNING THIS JOB, CHANGE RH87944.SOURCE.CNTL AND\n//*  HALL.LINKLIB TO YOUR DATASET NAMES.\n//*\n//*            NOTE...HALLDUMP IS  ASSEMBLED HERE TO MAKE SURE IT\n//*            IS 24 BIT MODE, AS  BACKDSNS IS STILL 24 BIT MODE!\n//*            ALSO, HDUMP MACRO  IS INCLUDED, AS IT IS A BIT\n//*            DIFFERENT FROM THE 31-BIT VERSION.\n//*\n//S1     EXEC  HLASMC,PARMC='ESD',CLASS='*'    ,PARML='AC=1',\n//*  COND.LKED=(7,LT,ASM)\n//ASM.SYSLIB DD DSN=SYS1.MACLIB,DISP=SHR\n//   DD DSN=SYS1.AMODGEN,DISP=SHR\n//*  DD DSN=RH87944.SOURCE.CNTL,DISP=SHR\n//ASM.SYSLIN   DD DSN=&&OBJECT(HALLDUMP),DISP=(,PASS),\n//             UNIT=DISK,SPACE=(TRK,(1,1,5)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=8880)\n//ASM.SYSIN DD *\n*\n*      COPYRIGHT\n*  THE METHODS AND CODE IN THIS PROGRAM ARE COPYRIGHTED BY:\n*  RANDY HALL,\n*  1151 PALMER ROAD,\n*  VICTORIA, B.C. CANADA, V8P-2H5\n*  E-MAIL...BITRON@ISLANDNET.COM\n*\n*  YOU MUST LEAVE IT AS IS, AND CANNOT SELL IT TO ANYONE,\n*  OR MODIFY IT, WITHOUT MY PERMISSION.\n*\n*                                                                   RH\n*              MACRO TO DUMP CORE                                   RH\n*                                                                   RH\n*        COPY  HDUMP                                                RH\n******************************************************************* RH\n*                                                                   RH\n*              MACRO TO DUMP CORE                                   RH\n*              REMEMBER TO STEPLIB TO HALL.LINKLIB FOR HALLDUMP     RH\n*              IF YOU USE AN EXISTING DCB, IT SHOULD BE             RH\n*              RECFM=FBA,LRECL=133.                                 RH\n*                                                                   RH\n         MACRO                                                      RH\n&L       HDUMP &DCB,&START,&STOP,&DISPO,&DISPC,&V=NO,&TITLE=,       RH +\n               &GENDCB=YES                                          RH\n         GBLA  &N                                                   RH\n         GBLC  &L0,&L1,&L2,&L3,&L4,&L5,&L6                          RH\n.*&N     SETA  1                                                    RH\n.*                                                                  RH\n.******* ***** ****************** ********************************* RH\n.*                                                                  RH\n.*       HDUMP IS USED TO DYNAMICALLY DUMP CORE IN A PROGRAM        RH\n.*             &DCB   IS THE NAME FOR THE SYSOUT DCB                RH\n.*             &START IS A REGISTER CONTAINING THE ADDRESS TO DUMP, RH\n.*                    OR 0 TO DUMP JUST THE REGISTERS               RH\n.*             &STOP  IS THE LENGTH TO DUMP, MAX IS 4095,           RH\n.*                    OR 0 TO DUMP JUST THE REGISTERS               RH\n.*             &DISPO IS THE DISPOSITION OF THE DUMP DCB            RH\n.*             &DISPC IS THE DISPOSITION AT THE END OF THE MACRO    RH\n.*             &V=YES WILL GENERATE A CONTROL BLOCK SET(EXCEPT DCB) RH\n.*                    EVERY TIME THE MACRO IS CALLED                RH\n.*             &TITLE IS A TITLE TO BE PRINTED BEFORE THE DUMP      RH\n.*         &GENDCB=NO WILL USE THE EXISTING &DCB                    RH\n.*                                                                  RH\n.*       AN EXAMPLE USAGE WOULD BE:                                 RH\n.*                                                                  RH\n.*       1)    DUMP 1024 BYTES STARTING AT MESSAGES. (A DCB)        RH\n.*             THE 'OUTDCB' FILE IS NOT OPEN, AND SHOULD BE LEFT    RH\n.*             OPEN AT END OF THE MACRO.                            RH\n.*                                                                  RH\n.*       LA    R3,MESSAGES        R3 = ADDRESS TO DUMP       DEBUG  RH\n.*       HDUMP OUTDCB,R3,1024,NOTOPEN,OPEN                   DEBUG  RH\n.*       ...                                                        RH\n.*       ...   MORE OF YOUR CODE                                    RH\n.*       ...                                                        RH\n.*                                                                  RH\n.*       2)    DUMP 1024 BYTES STARTING AT THE ADDRESS STORED       RH\n.*             AT MESSAGES+44. (A DEB)                              RH\n.*             THE 'OUTDCB' FILE IS OPEN, AND SHOULD BE CLOSED      RH\n.*             AT END OF THE MACRO.                                 RH\n.*                                                                  RH\n.*       L     R3,MESSAGES+44     R3 -> TO DEB               DEBUG  RH\n.*       HDUMP OUTDCB,R3,1024,OPEN,CLOSE                     DEBUG  RH\n.*                                                                  RH\n.******* ***** ****************** ********************************* RH\n.*                                                                  RH\n         AIF   (&STOP LT 4096).STOPOK                               RH\n         MNOTE 'STOP MUST BE LESS THAN 4096'                        RH\n         MEXIT                                                      RH\n.STOPOK  ANOP                                                       RH\n.*       AIF   (&N EQ 1).FRST                                       RH\n         AIF   (&N EQ 0).FRST                                       RH\n         AIF   ('&V' EQ 'NO').NDC1                                  RH\n.FRST    ANOP                                                       RH\n&L0      SETC  'SREG&SYSNDX'                                        RH\n&L1      SETC  'HREG&SYSNDX'                                        RH\n&L2      SETC  'REGA&SYSNDX'                                        RH\n&L3      SETC  'DCBA&SYSNDX'                                        RH\n&L4      SETC  'STRT&SYSNDX'                                        RH\n&L5      SETC  'STPA&SYSNDX'                                        RH\n&L6      SETC  'TITL&SYSNDX'                                        RH\n         AIF   (&N GT 1).LBL2                                       RH\n*&L      B     BPAS&SYSNDX                                   DEBUG  RH\n&L       B     LOADHDMP                                      DEBUG  RH\n         AGO   .LBL9                                         DEBUG  RH\n.LBL2    ANOP                                                DEBUG  RH\n&L       B     HDMP&SYSNDX                                   DEBUG  RH\n.LBL9    ANOP                                                DEBUG  RH\n         SPACE 1                                             DEBUG  RH\n&L0      DC    18F'-1'            SAVE AREA FOR HALLDUMP RTN DEBUG  RH\n&L1      DC    16F'-1'            SAVE AREA FOR CALLERS REGS DEBUG  RH\n&L2      DC    A(&L1)             ADDRESS OF CALLERS REGS    DEBUG  RH\n&L3      DC    A(&DCB)            ADDRESS OF OUTPUT DCB      DEBUG  RH\n&L4      DC    A(0)               ADDRESS OF START OF DUMP   DEBUG  RH\n&L5      DC    A(0)               ADDRESS OF END OF DUMP     DEBUG  RH\n&L6      DC    A(0)               ADDRESS OF TITLE           DEBUG  RH\n         AIF   (&N GT 1).NDC1                                DEBUG  RH\n         ENTRY DMPRADDR                                      DEBUG  RH\nDMPRADDR DC    F'0'               DUMP FORMATTER ADDRESS     DEBUG  RH\n         AIF   ('&GENDCB' EQ 'NO').NODCB                            RH\n         ENTRY &DCB                                          DEBUG  RH\n*&DCB    DCB   DDNAME=SYSOUT,RECFM=FBA,LRECL=133,BLKSIZE=3990,      RHXX\n               DSORG=PS,MACRF=(PM)                           DEBUG  RH\n&DCB     DCB   DDNAME=&DCB,RECFM=FBA,LRECL=133,BLKSIZE=3990,        RHXX\n               DSORG=PS,MACRF=(PM)                           DEBUG  RH\n.NODCB   ANOP                                                DEBUG  RH\n         SPACE 1                                             DEBUG  RH\n*PAS&SYSNDX DS    0H                                         DEBUG  RH\nLOADHDMP DS       0H                                         DEBUG  RH\n         STM   0,15,&L1           SAVE CALLERS REGS          DEBUG  RH\n*        L     1,=V(DMPRADDR)     R1 -> TO DUMPER CODE       DEBUG  RH\n*        ICM   1,15,0(1)          IS DUMP FORMATTER LOADED?  DEBUG  RH\n         ICM   1,15,=V(HALLDUMP)  IS DUMP FORMATTER LOADED?  DEBUG  RH\n         BNZ   LOADHEND           YES                        DEBUG  RH\n         DC    H'0'               NO, ABEND                  DEBUG  RH\n         SPACE 1                                             DEBUG  RH\nLOADHEND DS    0H                                            DEBUG  RH\n         LM    0,15,&L1           RELOAD CALLERS REGS        DEBUG  RH\n.NDC1    ANOP                                                DEBUG  RH\n         SPACE 1                                             DEBUG  RH\n*PAS&SYSNDX DS    0H                                         DEBUG  RH\nHDMP&SYSNDX DS    0H                                         DEBUG  RH\n         STM   0,15,&L1           SAVE CALLERS REGS          DEBUG  RH\n*        LR    15,&START          R15 -> TO START ADDRESS    DEBUG  RH\n         AIF   ('&START'(1,1) LT '0').STARTR1                       RH\n         LA    15,0               R15 = 0 IF DUMP ONLY REGS  DEBUG  RH\n         AGO   .STARTR9\n.STARTR1 ANOP                                                DEBUG  RH\n         LR    15,&START          R15 -> TO START ADDRESS    DEBUG  RH\n.STARTR9 ANOP                                                DEBUG  RH\n         ST    15,&L4             SAVE IT                    DEBUG  RH\n         LA    15,&STOP.(0,15)    R15 -> TO STOP ADDRESS     DEBUG  RH\n         ST    15,&L5             SAVE IT                    DEBUG  RH\n         AIF   ('&TITLE' EQ '').NTTL                         DEBUG  RH\n         LA    15,=CL80&TITLE     R15 -> TO TITLE            DEBUG  RH\n         ST    15,&L6             SAVE IT                    DEBUG  RH\n.NTTL    ANOP                                                DEBUG  RH\n         LA    13,&L0             GIVE HALLDUMP ITS OWN SA   DEBUG  RH\n         AIF   (&N GT 1).NDC2                                DEBUG  RH\n&N       SETA  2                                             DEBUG  RH\n         L     2,=V(&DCB)         R2 -> TO OUTPUT DCB        DEBUG  RH\n         ST    2,&L3              SAVE IT                    DEBUG  RH\n         AGO   .NDC3                                                RH\n.NDC2    ANOP                                                DEBUG  RH\n         SPACE 1                                             DEBUG  RH\n         L     2,=V(&DCB)         R2 -> TO OUTPUT DCB        DEBUG  RH\n         ST    2,&L3              SAVE IT                    DEBUG  RH\n         AIF   ('&DISPO' EQ '').NDC3                                RH\n         AIF   ('&DISPO' EQ 'OPEN').NDC4                            RH\n.NDC3    ANOP                                                       RH\n         TM    48(2),X'10'        IS DEBUG FILE OPEN ?       DEBUG  RH\n         BO    OPEN&SYSNDX        YES, DON'T OPEN IT AGAIN   DEBUG  RH\n*        OPEN  ((2),(OUTPUT)),MODE=24                        DEBUG  RH\n         OPEN  ((2),(OUTPUT)),MODE=24                        DEBUG  RH\n         SPACE 1                                             DEBUG  RH\nOPEN&SYSNDX DS 0H                                            DEBUG  RH\n*        L     R15,=V(DMPRADDR)   R15 -> TO DUMPER CODE      DEBUG  RH\n*        ICM   1,15,0(R15)        IS DUMP FORMATTER LOADED?  DEBUG  RH\n         ICM   1,15,=V(HALLDUMP)  IS DUMP FORMATTER LOADED?  DEBUG  RH\n         BNZ   LOAD&SYSNDX        YES                        DEBUG  RH\n         DC    H'0'               NO, ABEND                  DEBUG  RH\n         SPACE 1                                             DEBUG  RH\nLOAD&SYSNDX DS 0H                                            DEBUG  RH\n.NDC4    ANOP                                                       RH\n         TM    48(2),X'10'        IS DEBUG FILE OPEN ?       DEBUG  RH\n         BZ    DBUG&SYSNDX        NO                         DEBUG  RH\n         LA    1,&L2              R1 -> TO PARM LIST         DEBUG  RH\n*        ICM   15,15,=V(HALLDUMP) R15 -> TO DUMP ROUTINE     DEBUG  RH\n*        L     R15,=V(DMPRADDR)   R15 -> TO DUMPER CODE      DEBUG  RH\n*        ICM   15,15,0(R15)       R15 -> TO DUMP ROUTINE     DEBUG  RH\n         ICM   15,15,=V(HALLDUMP) IS DUMP FORMATTER LOADED?  DEBUG  RH\n         BZ    DBUG&SYSNDX        NO, DUMP ROUTINE, EXIT     DEBUG  RH\n         BALR  14,15              GO TO IT                   DEBUG  RH\n         AIF   ('&DISPC' EQ '').NDC5                                RH\n         AIF   ('&DISPC' EQ 'OPEN').NDC6                            RH\n.NDC5    ANOP                                                       RH\n*        CLOSE ((2)),MODE=24      CLOSE THE O/P FILE         DEBUG  RH\n         CLOSE ((2)),MODE=24      CLOSE THE O/P FILE         DEBUG  RH\n.NDC6    ANOP                                                       RH\n         SPACE 1                                             DEBUG  RH\nDBUG&SYSNDX DS    0H                                         DEBUG  RH\n         LM    0,15,&L1           RELOAD CALLERS REGS        DEBUG  RH\n         MEND                                                       RH\n*                                                                   RH\n*              END OF MACRO                                  DEBUG  RH\n*                                                                   RH\n*                                                                   RH\n*                                                                   RH\n*              EXAMPLE OF JCL TO  USE HDUMP                         RH\n*                                                                   RH\n*        JCL MUST STEPLIB TO HALL.LINKLIB                           RH\n*                                                                   RH\n*                  THIS IS CODE TO DUMP CORE                 DEBUG  RH\n*        SPACE 4                                             DEBUG  RH\n*                                 DUMP 1024 BYTES AT R12     DEBUG  RH\n*        HDUMP OUTDCB,R12,1024,NOTOPEN,OPEN                  DEBUG  RH\n*        L     R3,DSSEJFCB        R3 -> TO JFCB              DEBUG  RH\n*                                 DUMP 1024 BYTES AT JFCB    DEBUG  RH\n*        HDUMP OUTDCB,R3,1024,OPEN,CLOSE                     DEBUG  RH\n*        HDUMP OUTDCB,0,0,TITLE='DUMP REGS ONLY'             DEBUG  RH\n*        SPACE 1                                             DEBUG  RH\n*                  THIS IS END OF CODE TO DUMP CORE          DEBUG  RH\n*                                                                   RH\n*\n* DUMP THE REGS AND SPECIFIED MEMORY LOCATIONS\n*\n* ON ENTRY:\n*    R1 = ADDR PASSED PARMS\n*       1) ADDR OF SAVED CALLERS REGS\n*       2) ADDR OF SYSPRINT DCB\n*       3) ADDR OF FIRST BYTE TO DUMP\n*       4) ADDR OF LAST BYTE (PLUS ONE) TO DUMP\n*       5) ADDR OF A TITLE, OR 0\n*                                                                   RH\n         EJECT                                                      RH\nHALLDUMP CSECT\nHALLDUMP AMODE 24\nHALLDUMP RMODE 24\n         SPACE 2\n*\n* PERFORM STANDARD LINKAGE\n*\n         BSM   R14,0              SAVE CURRENT AMODE\n         PRINT NOGEN\n         STM   R14,R12,12(R13)         SAVE HIS REGS\n         USING HALLDUMP,R15            TEMP BASE ADDR\n         B     CONTINUE                BR AROUND MODULE NAME & DATE\n         DC    AL1(EYELTH)        LTH OF EYE CATCHER\nEYECATCH DC    CL8'HALLDUMP'           MODULE NAME\n         DC    CL8'&SYSDATE'           DATE ASSEMBLED\n         DC    CL8'&SYSTIME'           TIME ASSEMBLED\n         DC    C' VERSION 4...MAKE 24-BIT MODE FOR BACKDSNS'\n*        DC    C' VERSION 3...ADDED TITLE OPTION'\nEYELTH   EQU   *-EYECATCH\n         DROP  R15                     RELEASE TEMP BASE REG\n         SPACE 1\nCONTINUE DS    0H\n         LR    R12,R15                 BASE REG\n         USING HALLDUMP,R12            EST. ADDR.\n         CNOP  0,4                     ALIGNMENT\n         BAL   R11,*+76                BR AROUND SAVE AREA\nSAVEAREA DS    18F                     SAVE AREA\n         ST    R13,4(0,R11)            HIS 4 PAST MINE\n         ST    R11,8(0,R13)            MINE 8 PAST HIS\n         LR    R13,R11                 ADDR MY SAVE AREA\n*\n* LOAD UP SOME  REGISTERS..\n*\n*                                 R1 -> TO PARMS                    RH\n         L     R5,0(0,R1)         R5 -> TO REG SAVE AREA\n         MVC   DUMPREGS(64),0(R5)  MOVE REGS TO WORK AREA\n         L     R2,4(0,R1)         R2 -> TO OUTPUT PRINT DCB\n         LM    R3,R5,8(R1)        R3 -> TO START ADDR TO DUMP\n*                                 R4 -> TO STOP ADDR TO DUMP\n*                                 R5 -> TO TITLE, IF ANY\n*\n* DUMP OUT THE TITLE IF THERE IS ONE...\n*\n         LTR   R5,R5              IS THERE A TITLE?\n         BZ    NOTITLE            NO\n         MVC   DUMPLINE+1(80),0(R5)  MOVE HEADING TO PRINT LINE\n         PUT   (R2),DUMPLINE      PRINT THE TITLE\n*\n* DUMP OUT THE VALUES OF THE REGISTERS\n*\nNOTITLE  DS    0H\n         MVC   DUMPRGLO(64),DUMPREGS COPY THE REGS\n         TR    DUMPREGS(64),DUMPTBHI  CONVERT HI ORDER DIGITS\n         TR    DUMPRGLO(64),DUMPTBLO   CONVERT LO ORDER DIGITS\n         MVC   DUMPLINE+1(10),DUMPREG0  LINE HEADING\n         MVC   DUMPLINE+11(72),DUMPSELR DIGITS TO SELECT\n         TR    DUMPLINE+11(72),DUMPREGS REG CONTENTS => O/P LINE\n         PUT   (R2),DUMPLINE           WRITE THE O/P LINE\n         MVC   DUMPLINE+1(10),DUMPREG8  LINE HEADING\n         MVC   DUMPLINE+11(72),DUMPSELR DIGITS TO SELECT\n         TR    DUMPLINE+11(72),DUMPREGS+32 REG CONTENTS => O/P LINE\n         PUT   (R2),DUMPLINE           WRITE THE O/P LINE\n         MVI   DUMPLINE,C'0'      DOUBLE SPACE NEXT LINE\n*\n* DUMP THE DATA FROM THE SPECIFIED STORAGE AREA\n*\n         MVI   DUMPLINE+85,X'5C'       DELIMETER OF CHARS\n         MVI   DUMPLINE+118,X'5C'      DELIMETER OF CHARS\n         LTR   R5,R3                   STARTING ADDR\n         BZ    DUMPEND            IF START = 0, END OF DUMP\n         SRL   R3,5                    ROUND ADDR TO ...\n         SLL   R3,5                    ... A MULTIPLE OF 32\n* COMPUTE NUMBER BYTES TO BLANK OUT\n         SR    R5,R3                   # BYTES TO BLANK\n         LR    R7,R5              # BYTES TO BLANK ON RIGHT SIDE...\n         SLL   R5,1                    DOUBLE THE NUMBER\n         LR    R6,R5                   SAVE THIS VALUE\n         SRL   R6,3                    # ADD'NL BLANKS\n         AR    R5,R6                   SUBTOTAL # BLANK BYTES\n         SRL   R6,2                    # ADD'NL DOUBLE BLANKS\n         AR    R5,R6                   TOTAL # BLANKS\nDUMPRINT EQU   *\n         MVC   DUMPDATA(32),0(R3)      GET DATA TO TRANSLATE\n         MVC   DUMPDALO(32),0(R3)      GET DATA TO TRNASLATE\n         TR    DUMPDATA(32),DUMPTBHI   CONVERT HO ORDER HEX\n         TR    DUMPDALO(32),DUMPTBLO   CONVERT LO ORDER HEX\n         ST    R3,DUMPADHI             SAVE STARTING ADDR\n         ST    R3,DUMPADLO             SAVE STARTING ADDR\n         TR    DUMPADHI(4),DUMPTBHI    CONVERT HI OEDER HEX\n         TR    DUMPADLO(4),DUMPTBLO    CONVERT LO ORDER HEX\n         MVC   DUMPLINE+1(8),DUMPSELA  HEX DIGIT SELECT PATTERN\n         TR    DUMPLINE+1(8),DUMPADHI  SELECT THE HEX DIGITS\n         MVC   DUMPLINE+11(72),DUMPSELD DIGITS TO SELECT\n         TR    DUMPLINE+11(72),DUMPDATA DATA => O/P LINE\n         MVC   DUMPLINE+86(32),0(R3)   DATA BEING DUMPED\n         LTR   R5,R5                   ANY BLANKS ?\n         BZ    DUMPNXT1                NO, SKIP IT\n         BCTR  R5,0                    REAL LEN FOR MOVE\n         EX    R5,DUMPMVC              MOVE IN THE BLANKS\n*        SRL   R5,2               NBR OF BLANKS ON RIGHT SIDE....\n         BCTR  R7,0                    REAL LEN FOR MOVE\n         EX    R7,DUMPMVC2             MOVE IN THE BLANKS\n         SLR   R5,R5                   NO BLANKS !\nDUMPNXT1 EQU   *\n         PUT   (R2),DUMPLINE           WRITE THE O/P LINE\nDUMPEND  DS    0H\n         MVI   DUMPLINE,C' '           SINGLE SPACE\n         LA    R3,32(0,R3)             PT @ NEXT DATUM\n         CR    R3,R4                   DATA EXHAUSTED ?\n         BL    DUMPRINT                NO, CONTINUE PROCESSING IT\n*\n* PRINT END OF DUMP SEPARATOR\n*\n         MVI   DUMPLINE,X'F0'          DOUBLE SPACE\n         MVI   DUMPLINE+1,X'5C'        SET THE O/P LINE ...\n         MVC   DUMPLINE+2(131),DUMPLINE+1  ... TO ASTERISKS\n         PUT   (R2),DUMPLINE           WRITE THE O/P LINE\n         MVI   DUMPLINE,X'40'          SINGLE SPACE\n         MVC   DUMPLINE+1(132),DUMPLINE  CLR O/P LINE TO BLANKS\n         PUT   (R2),DUMPLINE           WRITE THE O/P LINE\n*\n* GET BACK TO THE CALLING ROUTINE\n*\n         L     R13,4(0,R13)            ADDR HIS SAVE AREA\n         LM    R14,R12,12(R13)         RESTORE HIS REGS\n*              GET INTO PROPER MODE AND GO BACK TO CALLER\n         BSM   0,R14              RETURN TO CALLING PROGRAM\n*        BR    R14                     RETURN TO HIM\n*\n* DEFINE STORAGE\n*\nDUMPMVC  MVC   DUMPLINE+11(1),DUMPBLNK\nDUMPMVC2 MVC   DUMPLINE+86(1),DUMPBLNK\nDUMPREGS DS    16F\nDUMPRGLO DS    16F\nDUMPBLNK DC    CL80' '\nDUMPREG0 DC    CL10'  R0-R7   '\nDUMPREG8 DC    CL10'  R8-R15  '\nDUMPDATA DS    8F\nDUMPDALO DS    8F\nDUMPBLK2 DC    CL8' '\nDUMPADHI DS    F\nDUMPADLO DS    F\nDUMPTBHI DC    16X'F0'\n         DC    16X'F1'\n         DC    16X'F2'\n         DC    16X'F3'\n         DC    16X'F4'\n         DC    16X'F5'\n         DC    16X'F6'\n         DC    16X'F7'\n         DC    16X'F8'\n         DC    16X'F9'\n         DC    16X'C1'\n         DC    16X'C2'\n         DC    16X'C3'\n         DC    16X'C4'\n         DC    16X'C5'\n         DC    16X'C6'\nDUMPTBLO DC    16X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\nDUMPSELR DC    X'00400141024203438004440545064607'\n         DC    X'4780084809490A4A0B4B800C4C0D4D0E'\n         DC    X'4E0F4F80801050115112521353801454'\n         DC    X'15551656175780185819591A5A1B5B80'\n         DC    X'1C5C1D5D1E5E1F5F'\nDUMPSELD DC    X'00200121022203234004240525062607'\n         DC    X'2740082809290A2A0B2B400C2C0D2D0E'\n         DC    X'2E0F2F40401030113112321333401434'\n         DC    X'15351636173740183819391A3A1B3B40'\n         DC    X'1C3C1D3D1E3E1F3F'\nDUMPSELA DC    X'0004010502060307'\nDUMPLINE DC    C' '\n         DC    CL132' '\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n/*\n//*\n//STEP1  EXEC HLASMCL,CLASS='*',MAC1='SYS1.AMODGEN',\n//            PARMC='SYSPARM(1,ESD)'\n//*           PARMC='SYSPARM=1,ESD'\n//ASM.SYSLIB  DD DSN=SYS1.MACLIB\n//  DD DSN=SYS1.MODGEN,DISP=SHR\n//  DD DSN=SYS1.AMODGEN,DISP=SHR\n//* DD DSN=RH87944.SOURCE.CNTL,DISP=SHR\n//ASM.SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,(5,5))\n//ASM.SYSIN DD *\n*\n*      COPYRIGHT\n*  THE METHODS AND CODE IN THIS PROGRAM ARE COPYRIGHTED BY:\n*  RANDY HALL,\n*  1151 PALMER ROAD,\n*  VICTORIA, B.C. CANADA, V8P-2H5\n*  E-MAIL...BITRON@ISLANDNET.COM\n*\n*  YOU MUST LEAVE IT AS IS, AND CANNOT SELL IT TO ANYONE, OR MODIFY IT,\n*  WITHOUT MY  PERMISSION.\n*\n         MACRO\n&LABEL   REQUATE &SAVE=NO,&REGS=YES,&E=YES\n         AIF   ('&REGS'(1,1) NE 'Y').SAVETS\n***********************************************************************\n*                                                                     *\n*                 REGISTER EQUATES                                    *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         AIF   ('&E'(1,1) EQ 'N').SAVETS\n         EJECT\n.SAVETS  AIF   ('&SAVE'(1,1) EQ 'Y').SAVEOK\n         MEXIT\n.SAVEOK  ANOP\n***********************************************************************\n*                                                                     *\n*                  SAVE AREA DESCRIPTOR SECTION                       *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nSAVEAREA DSECT ,\nSAVEWRD1 DS    F .            PL1 WORD\nSAVELAST DS    F .            CHAIN POINTER TO LAST SAVE AREA\nSAVENEXT DS    F .            CHAIN POINTER TO NEXT SAVE AREA\nSAVEREGS DS    0CL60 .        WORKING REGISTER STORAGE AREA\nSAVER14  DS    F .            R14 SLOT\nSAVER15  DS    F .            R15 SLOT\nSAVER0   DS    F .            R0 SLOT\nSAVER1   DS    F .            R1 SLOT\nSAVER2   DS    F .            R2 SLOT\nSAVER3   DS    F .            R3 SLOT\nSAVER4   DS    F .            R4 SLOT\nSAVER5   DS    F .            R5 SLOT\nSAVER6   DS    F .            R6 SLOT\nSAVER7   DS    F .            R7 SLOT\nSAVER8   DS    F .            R8 SLOT\nSAVER9   DS    F .            R9 SLOT\nSAVER10  DS    F .            R10 SLOT\nSAVER11  DS    F .            R11 SLOT\nSAVER12  DS    F .            R12  SLOT\nSAVESIZE EQU   *-SAVEAREA\n        AIF   ('&E'(1,1) EQ 'N').ENDMAC\n         EJECT\n.ENDMAC  ANOP\n         MEND\n*                                                                   RH\n*        COPY  HDUMP                                                RH\n******************************************************************* RH\n*                                                                   RH\n*              MACRO TO DUMP CORE                                   RH\n*              REMEMBER TO STEPLIB TO HALL.LINKLIB FOR HALLDUMP     RH\n*              IF YOU USE AN EXISTING DCB, IT SHOULD BE             RH\n*              RECFM=FBA,LRECL=133.                                 RH\n*                                                                   RH\n         MACRO                                                      RH\n&L       HDUMP &DCB,&START,&STOP,&DISPO,&DISPC,&V=NO,&TITLE=,       RH +\n               &GENDCB=YES                                          RH\n         GBLA  &N                                                   RH\n         GBLC  &L0,&L1,&L2,&L3,&L4,&L5,&L6                          RH\n.*&N     SETA  1                                                    RH\n.*                                                                  RH\n.******* ***** ****************** ********************************* RH\n.*                                                                  RH\n.*       HDUMP IS USED TO DYNAMICALLY DUMP CORE IN A PROGRAM        RH\n.*             &DCB   IS THE NAME FOR THE SYSOUT DCB                RH\n.*             &START IS A REGISTER CONTAINING THE ADDRESS TO DUMP, RH\n.*                    OR 0 TO DUMP JUST THE REGISTERS               RH\n.*             &STOP  IS THE LENGTH TO DUMP, MAX IS 4095,           RH\n.*                    OR 0 TO DUMP JUST THE REGISTERS               RH\n.*             &DISPO IS THE DISPOSITION OF THE DUMP DCB            RH\n.*             &DISPC IS THE DISPOSITION AT THE END OF THE MACRO    RH\n.*             &V=YES WILL GENERATE A CONTROL BLOCK SET(EXCEPT DCB) RH\n.*                    EVERY TIME THE MACRO IS CALLED                RH\n.*             &TITLE IS A TITLE TO BE PRINTED BEFORE THE DUMP      RH\n.*         &GENDCB=NO WILL USE THE EXISTING &DCB                    RH\n.*                                                                  RH\n.*       AN EXAMPLE USAGE WOULD BE:                                 RH\n.*                                                                  RH\n.*       1)    DUMP 1024 BYTES STARTING AT MESSAGES. (A DCB)        RH\n.*             THE 'OUTDCB' FILE IS NOT OPEN, AND SHOULD BE LEFT    RH\n.*             OPEN AT END OF THE MACRO.                            RH\n.*                                                                  RH\n.*       LA    R3,MESSAGES        R3 = ADDRESS TO DUMP       DEBUG  RH\n.*       HDUMP OUTDCB,R3,1024,NOTOPEN,OPEN                   DEBUG  RH\n.*       ...                                                        RH\n.*       ...   MORE OF YOUR CODE                                    RH\n.*       ...                                                        RH\n.*                                                                  RH\n.*       2)    DUMP 1024 BYTES STARTING AT THE ADDRESS STORED       RH\n.*             AT MESSAGES+44. (A DEB)                              RH\n.*             THE 'OUTDCB' FILE IS OPEN, AND SHOULD BE CLOSED      RH\n.*             AT END OF THE MACRO.                                 RH\n.*                                                                  RH\n.*       L     R3,MESSAGES+44     R3 -> TO DEB               DEBUG  RH\n.*       HDUMP OUTDCB,R3,1024,OPEN,CLOSE                     DEBUG  RH\n.*                                                                  RH\n.******* ***** ****************** ********************************* RH\n.*                                                                  RH\n         AIF   (&STOP LT 4096).STOPOK                               RH\n         MNOTE 'STOP MUST BE LESS THAN 4096'                        RH\n         MEXIT                                                      RH\n.STOPOK  ANOP                                                       RH\n.*       AIF   (&N EQ 1).FRST                                       RH\n         AIF   (&N EQ 0).FRST                                       RH\n         AIF   ('&V' EQ 'NO').NDC1                                  RH\n.FRST    ANOP                                                       RH\n&L0      SETC  'SREG&SYSNDX'                                        RH\n&L1      SETC  'HREG&SYSNDX'                                        RH\n&L2      SETC  'REGA&SYSNDX'                                        RH\n&L3      SETC  'DCBA&SYSNDX'                                        RH\n&L4      SETC  'STRT&SYSNDX'                                        RH\n&L5      SETC  'STPA&SYSNDX'                                        RH\n&L6      SETC  'TITL&SYSNDX'                                        RH\n         AIF   (&N GT 1).LBL2                                       RH\n*&L      B     BPAS&SYSNDX                                   DEBUG  RH\n&L       B     LOADHDMP                                      DEBUG  RH\n         AGO   .LBL9                                         DEBUG  RH\n.LBL2    ANOP                                                DEBUG  RH\n&L       B     HDMP&SYSNDX                                   DEBUG  RH\n.LBL9    ANOP                                                DEBUG  RH\n         SPACE 1                                             DEBUG  RH\n&L0      DC    18F'-1'            SAVE AREA FOR HALLDUMP RTN DEBUG  RH\n&L1      DC    16F'-1'            SAVE AREA FOR CALLERS REGS DEBUG  RH\n&L2      DC    A(&L1)             ADDRESS OF CALLERS REGS    DEBUG  RH\n&L3      DC    A(&DCB)            ADDRESS OF OUTPUT DCB      DEBUG  RH\n&L4      DC    A(0)               ADDRESS OF START OF DUMP   DEBUG  RH\n&L5      DC    A(0)               ADDRESS OF END OF DUMP     DEBUG  RH\n&L6      DC    A(0)               ADDRESS OF TITLE           DEBUG  RH\n         AIF   (&N GT 1).NDC1                                DEBUG  RH\n         ENTRY DMPRADDR                                      DEBUG  RH\nDMPRADDR DC    F'0'               DUMP FORMATTER ADDRESS     DEBUG  RH\n         AIF   ('&GENDCB' EQ 'NO').NODCB                            RH\n         ENTRY &DCB                                          DEBUG  RH\n*&DCB    DCB   DDNAME=SYSOUT,RECFM=FBA,LRECL=133,BLKSIZE=3990,      RHXX\n               DSORG=PS,MACRF=(PM)                           DEBUG  RH\n&DCB     DCB   DDNAME=&DCB,RECFM=FBA,LRECL=133,BLKSIZE=3990,        RHXX\n               DSORG=PS,MACRF=(PM)                           DEBUG  RH\n.NODCB   ANOP                                                DEBUG  RH\n         SPACE 1                                             DEBUG  RH\n*PAS&SYSNDX DS    0H                                         DEBUG  RH\nLOADHDMP DS       0H                                         DEBUG  RH\n         STM   0,15,&L1           SAVE CALLERS REGS          DEBUG  RH\n*        L     1,=V(DMPRADDR)     R1 -> TO DUMPER CODE       DEBUG  RH\n*        ICM   1,15,0(1)          IS DUMP FORMATTER LOADED?  DEBUG  RH\n         ICM   1,15,=V(HALLDUMP)  IS DUMP FORMATTER LOADED?  DEBUG  RH\n         BNZ   LOADHEND           YES                        DEBUG  RH\n         DC    H'0'               NO, ABEND                  DEBUG  RH\n         SPACE 1                                             DEBUG  RH\nLOADHEND DS    0H                                            DEBUG  RH\n         LM    0,15,&L1           RELOAD CALLERS REGS        DEBUG  RH\n.NDC1    ANOP                                                DEBUG  RH\n         SPACE 1                                             DEBUG  RH\n*PAS&SYSNDX DS    0H                                         DEBUG  RH\nHDMP&SYSNDX DS    0H                                         DEBUG  RH\n         STM   0,15,&L1           SAVE CALLERS REGS          DEBUG  RH\n*        LR    15,&START          R15 -> TO START ADDRESS    DEBUG  RH\n         AIF   ('&START'(1,1) LT '0').STARTR1                       RH\n         LA    15,0               R15 = 0 IF DUMP ONLY REGS  DEBUG  RH\n         AGO   .STARTR9\n.STARTR1 ANOP                                                DEBUG  RH\n         LR    15,&START          R15 -> TO START ADDRESS    DEBUG  RH\n.STARTR9 ANOP                                                DEBUG  RH\n         ST    15,&L4             SAVE IT                    DEBUG  RH\n         LA    15,&STOP.(0,15)    R15 -> TO STOP ADDRESS     DEBUG  RH\n         ST    15,&L5             SAVE IT                    DEBUG  RH\n         AIF   ('&TITLE' EQ '').NTTL                         DEBUG  RH\n         LA    15,=CL80&TITLE     R15 -> TO TITLE            DEBUG  RH\n         ST    15,&L6             SAVE IT                    DEBUG  RH\n.NTTL    ANOP                                                DEBUG  RH\n         LA    13,&L0             GIVE HALLDUMP ITS OWN SA   DEBUG  RH\n         AIF   (&N GT 1).NDC2                                DEBUG  RH\n&N       SETA  2                                             DEBUG  RH\n         L     2,=V(&DCB)         R2 -> TO OUTPUT DCB        DEBUG  RH\n         ST    2,&L3              SAVE IT                    DEBUG  RH\n         AGO   .NDC3                                                RH\n.NDC2    ANOP                                                DEBUG  RH\n         SPACE 1                                             DEBUG  RH\n         L     2,=V(&DCB)         R2 -> TO OUTPUT DCB        DEBUG  RH\n         ST    2,&L3              SAVE IT                    DEBUG  RH\n         AIF   ('&DISPO' EQ '').NDC3                                RH\n         AIF   ('&DISPO' EQ 'OPEN').NDC4                            RH\n.NDC3    ANOP                                                       RH\n         TM    48(2),X'10'        IS DEBUG FILE OPEN ?       DEBUG  RH\n         BO    OPEN&SYSNDX        YES, DON'T OPEN IT AGAIN   DEBUG  RH\n*        OPEN  ((2),(OUTPUT)),MODE=24                        DEBUG  RH\n         OPEN  ((2),(OUTPUT)),MODE=24                        DEBUG  RH\n         SPACE 1                                             DEBUG  RH\nOPEN&SYSNDX DS 0H                                            DEBUG  RH\n*        L     R15,=V(DMPRADDR)   R15 -> TO DUMPER CODE      DEBUG  RH\n*        ICM   1,15,0(R15)        IS DUMP FORMATTER LOADED?  DEBUG  RH\n         ICM   1,15,=V(HALLDUMP)  IS DUMP FORMATTER LOADED?  DEBUG  RH\n         BNZ   LOAD&SYSNDX        YES                        DEBUG  RH\n         DC    H'0'               NO, ABEND                  DEBUG  RH\n         SPACE 1                                             DEBUG  RH\nLOAD&SYSNDX DS 0H                                            DEBUG  RH\n.NDC4    ANOP                                                       RH\n         TM    48(2),X'10'        IS DEBUG FILE OPEN ?       DEBUG  RH\n         BZ    DBUG&SYSNDX        NO                         DEBUG  RH\n         LA    1,&L2              R1 -> TO PARM LIST         DEBUG  RH\n*        ICM   15,15,=V(HALLDUMP) R15 -> TO DUMP ROUTINE     DEBUG  RH\n*        L     R15,=V(DMPRADDR)   R15 -> TO DUMPER CODE      DEBUG  RH\n*        ICM   15,15,0(R15)       R15 -> TO DUMP ROUTINE     DEBUG  RH\n         ICM   15,15,=V(HALLDUMP) IS DUMP FORMATTER LOADED?  DEBUG  RH\n         BZ    DBUG&SYSNDX        NO, DUMP ROUTINE, EXIT     DEBUG  RH\n         BALR  14,15              GO TO IT                   DEBUG  RH\n         AIF   ('&DISPC' EQ '').NDC5                                RH\n         AIF   ('&DISPC' EQ 'OPEN').NDC6                            RH\n.NDC5    ANOP                                                       RH\n*        CLOSE ((2)),MODE=24      CLOSE THE O/P FILE         DEBUG  RH\n         CLOSE ((2)),MODE=24      CLOSE THE O/P FILE         DEBUG  RH\n.NDC6    ANOP                                                       RH\n         SPACE 1                                             DEBUG  RH\nDBUG&SYSNDX DS    0H                                         DEBUG  RH\n         LM    0,15,&L1           RELOAD CALLERS REGS        DEBUG  RH\n         MEND                                                       RH\n*                                                                   RH\n*\n         TITLE '  --- CHANGE HISTORY FOR BACKDSNS'\n*\n*        FEB   1999..CHANGED THE WAY THE UCB NAME IS CALCULATED...\n*                    4 DIGIT UCB NAMES ARE NOT STORED IN THE UCB\n*                    LIKE A 3 DIGIT UCB IS...I NOW COVERT THE\n*                    BINARY DEVICE NUMBER TO CHAR...FIND TRTAB.\n*\n*        OCT   1998..DFSMSRMM TAPE MANAGEMENT SYSTEM DOESN'T ALLOW\n*                    YOU TO USE THE LAST 17 CHARS OF A TAPE DATASET\n*                    NAME...YOU MUST USE THE CORRECT FULL NAME.\n*                    SO WE WILL AGAIN USE THE SYSUT2 DSN TO CREATE\n*                    THE DATASET NAME ON THE TAPE BY ADDING F001,\n*                    F002, ETC. TO CREATE A UNIQUE DATASET NAME\n*                    FOR ALL THE TAPE DATASET NAMES.\n*                    OTHERWISE WE GET RC=4, REASON=220 WHEN ALLOCATING\n*                    THE DISK DATASET.\n*                  ..THIS FORCED A CHANGE TO THE LRECL OF THE\n*                    //RESTORE FILE FROM 133 TO 200, MAKING THIS\n*                    VERSION INCOMPATIBLE WITH THE PREVIOUS VERSION.\n*                  ..FIX CODE THAT DETERMINES IF WE ARE STARTING AT\n*                    A SEQUENCE NBR > 1.\n*                  ..CHECK FOR BLKSIZE ON //RESTORE, DEFAULT=LRECL*50\n*\n*        FEB   1998..ADD CODE AT LABEL NEXTUSR AND NEXTUSR3 TO CHECK\n*                    FOR * IN 1ST COLUMN.AND IGNORE COMMENTS.\n*\n*        AUG   1997..LOT'S OF CHANGES TO TRY TO GET IT TO RUN ON Y2K\n*                  ..ADD 'IEBCOPY' PARM TO SAY ALWAYS USE IEBCOPY,\n*                    NOT PDSFAST. PDSFAST GETS 713'S UNDER Y2K.\n*                  ..ADDED CODE TO DUMP DCB'S AND JFCB'S TO //OUTDCB\n*                    IF //DEBUG DD IS FOUND.\n*              NOTE..LINK WITH AC(1) INTO AN AUTHORIZED LIBRARY\n*                    TO AVOID IEBCOPY ERROR MSG THAT SAYS...\n*                    *** IEBCOPY IS NOT APF AUTHORIZED ***\n*\n*        OCT   1996..BUILDDSN...FIX BUG SAYING CREATING DSN ON BACKUP\n*                    IF DATASET IS NOT CATALOGED.\n*\n*        JUNE  1996..CHANGE UCB LOOKUP TO USE UCBSCAN MACRO\n*\n*                  ..ADD CODE (EXPALLOC SECTION) TO CREATE A DUMMY\n*                    FILE 1 TO AVOID S713 ABENDS ON THE FIRST FILE.\n*                    THAT WAY, FILE 1 WILL HAVE ANY EXPIRY DATE AND\n*                    THEN A MULTIPLE OPEN ON THE FIRST FILE IS NOT\n*                    NECESSARY.  THIS APPEARS TO BE A RECENT SYSTEM\n*                    CHANGE PROBLEM.\n*\n*                  ..ALSO WE WILL NO LONGER ADD THE SYSUT2 DSN TO THE\n*                    DISK FILE DSN, BUT THE DATASET NAME ON THE TAPE\n*                    MUST BE DIFFERENT THAN THE DISK DATASET NAME, SO\n*                    START ALL THE TAPE DATASET NAMES WITH \"BACKUP.\",\n*                    OTHERWISE WE GET RC=4, REASON=220 WHEN ALLOCATING\n*                    THE DISK DATASET.\n*\n*                  ..ALSO RACF WON'T LET US USE \"NONE\" AS THE FIRST\n*                    TAPE DSN NOW THE 1ST FILE DSN IS NOT CHANGED.\n*\n*        NOV   1995..ADD CODE TO RECALL A MIGRATED DATASET IN SECTION\n*                    BUILDDSN...\n*\n*        APR   1995..DON'T FREE VSAM FILES AS IT SEEMS IDCAMS DOES IT.\n*                    FIX BUG IN ABOVE CODE....\n*\n*        JULY  1990..CHECK FOR PDSFAST, AND IF NOT FOUND, USE IEBCOPY\n*                  ..CHECK FOR RACF, AND BYPASS IF NOT ACTIVE\n*                  ..CHECK FOR BLKSIZE ON //RESTORE, DEFAULT=9044\n*                  ..ADD 'KEEP' PARM TO ALLOW ALLOCATE BUT NOT CATLG\n*                  ..ADD 'ALLOC' PARM TO USE ALLOCATED SPACE, NOT USED\n*                  ..ADD 'VOL=' PARM TO ALLOW UP TO 4 VOLS FOR\n*                    ALLOCATION OF NEW FILES.\n*                  ..ADD 'UNIT=' PARM TO ALLOW ALLOCATION OF NEW\n*                    FILES TO A SPECIFIC UNIT TYPE.\n*                  ..ADD 'TUNIT=' PARM TO SPECIFY TAPE UNIT\n*\n*        JUNE  1990..ADD CODE TO READ DSCB4 TO CONVERT TRKS TO CYLS\n*                  ..ALLOCATE VSAM FILES TO SYSUT1 TO BE ABLE TO COPY\n*                    ALLOCATED FILES.\n*\n*        FEB   1990..ADD CODE TO RESTORE FILES FROM TAPE\n*\n*        JUNE  1989..ADD CHECK FOR DSN=NONE, TO USE JUST DISK NAME\n*                    ON TAPE\n*                  ..AFTER 1ST FILE ON TAPE, SET EXPIRY DATE TO NULL\n*                  ..CREATE //RESTORE FILE\n*\n*\n         SPACE    2\n* SAVESET MACRO:\n*\n*        USED - TO DEFINE THE SAVE AREAS\n*\n         MACRO\n&LABEL   SAVESET &NBR\n         PRINT GEN\n&N1      SETA  1\n&N2      SETA  2\n&N3      SETA  3\n&LABEL   DS    0F\nSAVE&N1  DC    F'0'\n         DC    A(0)        PTR TO  PREV\n         DC    A(SAVE&N2)  PTR TO NEXT\n         DC    15F'0'      FOR R14 TO R12\n.LOOP    ANOP\nSAVE&N2  DC    F'0'\n         DC    A(SAVE&N1)  PTR TO  PREV\n         DC    A(SAVE&N3)  PTR TO NEXT\n         DC    15F'0'      FOR R14 TO R12\n&N1      SETA  &N1+1\n&N2      SETA  &N2+1\n&N3      SETA  &N3+1\n         AIF   (&N2 LT &NBR).LOOP\nSAVE&N2  DC    F'0'\n         DC    A(SAVE&N1)  PTR TO  PREV\n         DC    A(0)        PTR TO NEXT\n         DC    15F'0'      FOR R14 TO R12\n         MEND\n         SPACE    2\n* SECTION MACRO:\n*\n*        USED - TO DEFINE THE VARIOUS SECTIONS OF CODE HEREIN\n*\n         MACRO\n&LABEL   SECTION &GEN=NO,&DROP=YES,&SAVE=NO,&AMODE=24,&RMODE=24\n         PRINT GEN\n&LABEL   CSECT\n&LABEL   AMODE &AMODE\n&LABEL   RMODE &RMODE\n         PRINT &GEN.GEN\n.*       PRINT NOGEN\n         SAVE     (14,12),,&LABEL   SAVE CALLER'S REGISTERS\n         AIF ('&DROP' EQ 'NO').NODROP\n         DROP  R12                DROP PREVIOUS SECTION BASE\n.NODROP  ANOP\n         USING    &LABEL,R12        ESTABLISH ADDRESABILITY\n         LR       R12,R15\n         AIF ('&SAVE' EQ 'NO').NOSAVE\n         BAL      R15,PS&SYSNDX     BRANCH AROUND SAVE AREA         RH\nSV&SYSNDX DS      18F'0'            SAVE AREA                       RH\nPS&SYSNDX DS      0H                                                RH\n         USING    SAVEAREA,R15      SET SAVE AREA BASE              RH\n         ST       R13,SAVELAST      CHAIN SYSTEM SAVE AREA TO MINE  RH\n         DROP     R15               DROP SAVE AREA BASE             RH\n         USING    SAVEAREA,R13      SET SAVE AREA BASE              RH\n         ST       R15,SAVENEXT      CHAIN MY SAVE AREA TO SYSTEMS   RH\n         LR       R13,R15           R13 -> TO MY SAVE AREA          RH\n         AGO      .GOTSAVE\n.NOSAVE  ANOP\n         USING    SAVEAREA,R13\n*        L        R13,SAVENEXT      POINT TO NEXT SAVE AREA IN CHAIN\n         ICM      R13,15,SAVENEXT   POINT TO NEXT SAVE AREA IN CHAIN\n         BZ    *+2                ABEND IF NO SAVE AREA\n.GOTSAVE ANOP\n         AIF ('&LABEL' EQ 'DEBUGRTN').NDB\n         LR       R2,R0             SAVE REGS OVER DEBUG\n         LR       R3,R1\n         LA       R1,=CL8'&LABEL'\n         SR       R0,R0             R0=0 MEANS SECTION ENTRY\n         PERFORM  DEBUGRTN\n         LR       R0,R2\n         LR       R1,R3\n.NDB     ANOP\n         MEND\n         AGO   .MYMAC\n         MACRO\n&LABEL   SECTION\n&LABEL   CSECT\n         SAVE     (14,12),,&LABEL   SAVE CALLER'S REGISTERS\n         USING    &LABEL,R12        ESTABLISH ADDRESABILITY\n         LR       R12,R15\n         BAL      R15,A&SYSNDX      BRANCH AROUND SAVE AREA         RH\nSAVE&SYSNDX DS    18F'0'            SAVE AREA                       RH\nA&SYSNDX DS       0H                                                RH\n         USING    SAVEAREA,R15      SET SAVE AREA BASE              RH\n         ST       R13,SAVELAST      CHAIN SYSTEM SAVE AREA TO MINE  RH\n         DROP     R15               DROP SAVE AREA BASE             RH\n         USING    SAVEAREA,R13      SET SAVE AREA BASE              RH\n         ST       R15,SAVENEXT      CHAIN MY SAVE AREA TO SYSTEMS   RH\n         LR       R13,R15           R13 -> TO MY SAVE AREA          RH\n         AIF ('&LABEL' EQ 'DEBUGRTN').NDB\n         LR       R2,R0             SAVE REGS OVER DEBUG\n         LR       R3,R1\n         LA       R1,=CL8'&LABEL'\n         SR       R0,R0             R0=0 MEANS SECTION ENTRY\n         PERFORM  DEBUGRTN\n         LR       R0,R2\n         LR       R1,R3\n.NDB     ANOP\n         MEND\n.MYMAC   ANOP\n         SPACE    2\n         MACRO\n&LABEL   SECEXIT\n.* PUT RET CODE IN R15 BEFORE CALLING\n         PRINT GEN\n&LABEL   DS    0H\n         PRINT NOGEN\n         AIF ('&LABEL' EQ 'DEBUGRET').NDB\n         LR       R4,R15            SAVE RETURN CODE\n         LR       R2,R0             SAVE REGS OVER DEBUG\n         LR       R3,R1\n         LA       R1,=CL8'&LABEL'\n         LA       R0,1              R0 NOT= 0 MEANS SECTION EXIT\n         PERFORM  DEBUGRTN\n         LR       R0,R2\n         LR       R1,R3\n         LR       R15,R4            RESTORE RETURN CODE\n.NDB     ANOP\n         L        R13,SAVELAST      POINT TO CALLER'S SAVEAREA\n         LM       R0,R12,SAVER0     RESTORE REGISTERS 0 TO 12\n         L        R14,SAVER14       RESTORE R14\n         MVI      SAVER14,X'FF'     MARK THAT WE'VE EXITED UP 1 LEVEL\n         BR       R14               RETURN TO CALLER\n         LTORG\n         MEND\n         EJECT\n         MACRO\n&LABEL   PERFORM  &ROUTINE,&ERR=\n.**********************************************************************\n*\n&LABEL   ICM   R15,15,=V(&ROUTINE)  GET ADDRESS OF ROUTINE TO CALL\n         BZ    X&SYSNDX           EXIT IF BAD ADDRESS\n         BALR     R14,R15           BRANCH TO IT\nX&SYSNDX DS       0H                                                RH\n         AIF ('&ERR' EQ '').PEXIT   ANY ERROR ROUTINE SPECIFIED?\n         LTR      R15,R15           CHECK THE RETURN CODE\n         BNZ      &ERR\n.PEXIT   ANOP\n***********************************************************************\n         MEND\n         SPACE    2\n* OLCMSG MACRO:\n*\n*        USED - TO WRITE MSG TO OLCPRINT DDNAME,\n*             - TO WRITE MSG TO THE JOB LOG\n*             - TO WRITE MSG TO THE CONSOLE\n*             - TO START THE \"SIGNAL\" MESSAGE REGION TO NOTIFY TAF AND\n*               IMF/SM OF COMPLETION OF THIS PROGRAM\n*             - TO ABEND THIS PROGRAM IF NECESSARY AFTER MSG HAVE BEEN\n*               WRITTEN.\n*\nMSGPOINT EQU      1                   REGISTER TO POINT TO ERROR MSG\n         SPACE    2\n         MACRO\n&LABEL   OLCMSG   &MSG                MACRO PARM MAPPED BY MSGDSECT\n&LABEL   DS       0H\n         LA       MSGPOINT,&MSG       POINT AT THE ERROR MSG\n*        L        R15,=V(MSGRTN)      LOAD ADDRESS OF OLCMSG ROUTINE\n*        BALR     R14,R15             GO TO MSG ROUTINE\n         ICM   R15,15,=V(MSGRTN)   GET ADDRESS OF OLCMSG ROUTINE\n         BZ    OL&SYSNDX           EXIT IF BAD ADDRESS\n         BALR     R14,R15           BRANCH TO IT\nOL&SYSNDX DS      0H                                                RH\n         MEND\n         EJECT\nBACKDSNS CSECT\nBACKDSNS AMODE 24\nBACKDSNS RMODE 24\n*\n*        M A I N L I N E :\n*\n         PRINT NOGEN\n*\n*  ON ENTRY :\n*                 R1  = A(PARM LIST)\n*                 R13 = A(SAVEAREA)\n*                 R14 = RETURN ADDRESS\n*                 R15 = A(BACKDSNS)\n*\n*  PARM  LIST :\n*                 NONE\n*\n*        SAVE REGS ON ENTRY IN SYSTEMS SAVEAREA\n         SAVE     (14,12),,BACKDSNS-V1R2M0-&SYSDATE-&SYSTIME\n*\n         USING    BACKDSNS,R12        R12 IS BASE REGISTER\n         LR       R12,R15             SET IT UP\n*\n         L        R15,=V(SAVE)        R15 <-- ADDR OF OUR SAVEAREA\n         USING    SAVEAREA,R13\n         ST       R15,SAVENEXT        R15 --> HIS SAVEAREA, PT TO NEXT\n*\n         DROP     R13\n         USING    SAVEAREA,R15        SET SAVEAREA DSECT ON OUR SA\n         ST       R13,SAVELAST        HIS SA --> OUR SA PTR TO PREV\n         LR       R13,R15             R13 <-- OUR SAVEAREA\n         DROP     R15\n         USING    SAVEAREA,R13\n         ST       R1,PARMADDR         SAVE PARM ADDRESS\n         SPACE 2\n*\n         PERFORM  OPENSYSP    OPEN OLCPRINT,DEBUG AND PUT DATE TIME MSG\n*\n         PERFORM  EDITPARM    GO EDIT THE PARM LIST\n         LTR      R15,R15     IS THIS A PROPER INVOCATION?\n         BNZ      EXITLOGC\n*\n*        MVC   USRDDNAM,USRDFMT   SET UP DDNAME OF USER LIB LIST\n         PERFORM  DETUSER     DETERMINE & COPY USER LIBS TO TAPE\n*\n         PERFORM  CLOSSYSP    CLOSE OLCPRINT\n         SPACE 2\n*\n* MAINLINE EXIT LOGIC :\n*\n*              NOW PUT THE ORIGINAL JFCB INFO FOR SYSUT2 BACK\n*              IN CASE THEY CATALOG THE DATASET NAME...\n*\n*        L     R2,=V(SYSUT2)      R2 -> TO SYSUT2 DCB               RH\n*        RDJFCB ((2))             GET THE SYSUT2 JFCB               RH\n*        LTR   R15,R15            GET IT?                           RH\n*        BNZ   EXITLOGC           NO, TOO BAD                       RH\n*        L     R2,=V(UT2JFCB)     R2 -> TO SYSUT2 JFCB              RH\n*        L     R1,=V(FIRSTJFC)    R1 -> TO FIRST SYSUT2 JFCB        RH\n*        MVC   0(176,R2),0(R1)    RE-LOAD 1ST JFCB\n*\nEXITLOGC DS    0H\n*        L        R15,=V(SAVE)        R15 <-- ADDR OF OUR SAVEAREA\n*        USING    SAVEAREA,R15        SET SAVEAREA DSECT ON OUR SA\n         L        R13,SAVELAST        RETURN TO HIS SAVEAREA\n         RETURN   (14,12),RC=(15)     RETURN TO SUPERVISOR\n         DROP     R13\n         LTORG\n TITLE 'BACKDSNS - LOCAL STORAGE '\n         ENTRY IEBSYSIN\n         ENTRY IEBHLDIN\n*\n*                   THE IEBCOPY SYSIN DDNAME FOR COPYING USER LIBS\nIEBSYSIN DC  CL8'SYSIN'\n*\n*\n* THE FIELD BELOW WILL BE DETERMINED BY READDIR\nIEBHLDIN DC    CL8'SYSUT1  ' WILL MOVE IN CORRECT DDNAME WHEN KNOWN\n*\n         ENTRY    USRDDNAM\nUSRDDNAM DC       CL8'DSNS   ' DDNAME FOR LIST OF USR LIBS TO BACK UP\n*\n         ENTRY PARMADDR,PARMOLC,PARMFLAG\nPARMADDR DC       F'0'   SAVE AREA FOR PARAMETER LIST POINTER\n*                        ON THE START REGION TO SIGNAL TAF AND IMF/SM\nPARMOLC  DC    CL8' '             PARM SAVE AREA (RESTORE)\nPARMFLAG DC    X'00'              PARM FLAG AREA\nKEEPFLG  EQU   X'80'              'KEEP' PARM WAS SPECIFIED\nALLOCFLG EQU   X'40'              'ALLOC' PARM WAS SPECIFIED\nVOLFLAG  EQU   X'20'              'VOL=' PARM WAS SPECIFIED\nOLC061   DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    C'DSB061 - DATA SET BACKUP DONE'\n         ORG   OLC061+81\n*\n         SPACE 3\n*\n* PRECHAINED IMS TYPE SAVEAREAS NEEDED TO CALL DFSMODE0 AND DFSMODS0\n* THESE IMS TYPE SAVEAREAS ARE USED EXTENSIVELY HEREIN BY SECTION MACRO\n*\n         ENTRY    SAVE     DEFINE ENTRY POINT USED OUTSIDE THIS CSECT\nSAVE     SAVESET 15\n         AGO   .SKIPSAV\nSAVE     DC       F'0'\n         DC       F'0'     PTR TO PREV\n         DC       A(SAVE2) PTR TO NEXT\n         DC       15F'0'   FOR R14 TO R12\nSAVE2    DC       F'0'\n         DC       A(SAVE)  PTR TO PREV\n         DC       A(SAVE3) PTR TO NEXT\n         DC       15F'0'   FOR R14 TO R12\nSAVE3    DC       F'0'\n         DC       A(SAVE2) PTR TO PREV\n         DC       A(SAVE4) PTR TO NEXT\n         DC       15F'0'   FOR R14 TO R12\nSAVE4    DC       F'0'\n         DC       A(SAVE3) PTR TO PREV\n         DC       A(SAVE5) PTR TO NEXT\n         DC       15F'0'   FOR R14 TO R12\nSAVE5    DC       F'0'\n         DC       A(SAVE4) PTR TO PREV\n         DC       A(SAVE6) PTR TO NEXT\n         DC       15F'0'   FOR R14 TO R12\nSAVE6    DC       F'0'\n         DC       A(SAVE5) PTR TO PREV\n         DC       A(SAVE7) PTR TO NEXT\n         DC       15F'0'   FOR R14 TO R12\nSAVE7    DC       F'0'\n         DC       A(SAVE6) PTR TO PREV\n         DC       A(SAVE8) PTR TO NEXT\n         DC       15F'0'   FOR R14 TO R12\nSAVE8    DC       F'0'\n         DC       A(SAVE7) PTR TO PREV\n         DC       A(SAVE9) PTR TO NEXT\n         DC       15F'0'   FOR R14 TO R12\nSAVE9    DC       F'0'\n         DC       A(SAVE8) PTR TO PREV\n         DC       F'0'     PTR TO NEXT   - END\n         DC       15F'0'   FOR R14 TO R12\n.SKIPSAV ANOP\n TITLE 'OPENSYSP - OPEN OLCPRINT DATASET AND WRITE HEADING'\n*\n* OPEN THE OLCPRINT DATASET, PUT OUT TIME AND DATE MSG\n*\n         DS    0H\nOPENSYSP SECTION\n         OPEN     (OLCPRINT,(OUTPUT))          OPEN IT\n         LA       R1,OLCPRINT\n         USING    IHADCB,R1\n         TM       DCBOFLGS,DCBOFOPN            DID IT OPEN ?\n         BZ       ERROPENP                     NO, GO TO ERR RTN\n         DROP     R1\n*\n         LA    R1,OLC000D\n         PERFORM  GETTOD          GO GET DATE, TIME\n         OLCMSG   OLC000          PUT OUT 1ST MSG\n         OLCMSG   OLC098          PUT OUT COMPILED DATE MSG\n         SPACE 1\n         RDJFCB RESTORE           IS RESTORE DD CARD THERE?\n         LTR   R15,R15            WELL?\n         BNZ   NOREST             NO, DON'T TRY TO OPEN IT THEN\n         LA    R5,DEBUGE          R5 -> TO JFCB\n         USING INFMJFCB,R5        SET DSECT\n         TM    JFCBIND2,X'48'     DISP=OLD OR SHR?\n         BM    RESTOPEN           YES\n         OC    JFCBLKSI,JFCBLKSI  BLKSIZE SPECIFIED ?\n         BNZ   RESTOPEN           YES\n         LA    R1,RESTORE         R1 -> TO DCB\n         USING IHADCB,R1          SET DCB BASE REG\n         LH    R15,DCBLRECL       R15 = DCB LRECL\n         MH    R15,=H'50'         BLKSIZE = LRECL*50\n         DROP  R1                 DROP DCB BASE\n         STH   R15,JFCBLKSI       SET DEFAULT BLKSIZE\n         DROP  R5                 DROP JFCB ADDRESSABILITY\n         SPACE 1\nRESTOPEN DS    0H\n         OPEN  (RESTORE,(OUTPUT)),TYPE=J   OPEN IT\n         LA    R1,RESTORE         R1 -> TO DCB\n         USING IHADCB,R1          SET DCB BASE REG\n         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?\n         BO    NOREST             YES\n         DROP  R1                 DROP DCB BASE\n         OLCMSG   OLC041          SAY OPEN FAILED\n         SPACE 1\nNOREST   DS    0H\n         RDJFCB DEBUG             IS THE DEBUG DD CARD THERE?\n         LTR   R15,R15\n         BNZ   RETOPNP            IF NOT  NO TRACE\n         OPEN  (DEBUG,(OUTPUT)),TYPE=J\n         LA    R1,DEBUG\n         USING IHADCB,R1\n         TM    DCBOFLGS,DCBOFOPN            DID IT OPEN ?\n         BZ    ERROPEND                     NO, GO TO ERR RTN\n         DROP  R1\n         OLCMSG   OLC039\n         B     RETOPNP                      RETURN TO CALLER\n         SPACE    2\nERROPEND DS       0H\n         OLCMSG   OLC040\n         B     RETOPNP                      RETURN TO CALLER\nERROPENP DS       0H\n         OLCMSG   OLC005\nRETOPNP  SECEXIT                               RETURN TO CALLER\n         SPACE 2\n* OPENSYSP DATA:\n*\n         DC    CL81' '\n         ORG   *-81\nOLC000   DS    0A\n         DC    AL1(MSGPRT)\n         DC    C'DSB000 - DIVERSIFIED DEVELOPMENTS '\n         DC    C'BACKUP UTILITY STARTING - '\nOLC000D  DC       CL6'YY.DDD'\n         DC       CL2' '\nOLC000T  DC       CL8'HH:MM:SS'\n         DC       CL7' '\n         ORG   OLC000+81\n         DC    CL81' '\n         ORG   *-81\nOLC098   DS    0A\n         DC    AL1(MSGPRT)\n         DC    C'DSB098 - BACKDSNS VERSION 7.0 COMPILED ON '\n         DC    CL8'&SYSDATE'\n         DC    CL2' '\n         DC    CL8'&SYSTIME'\n         ORG   OLC098+81\n         SPACE\n         DC    CL81' '\n         ORG   *-81\nOLC039   DS    0A\n         DC    AL1(MSGPRT)\n         DC    C'DSB039 - DEBUG OPTION IN EFFECT - '\n         DC    C'A TRACE WILL BE PRODUCED IN FILE ''DEBUG'' '\n         ORG   OLC039+81\n         DC    CL81' '\n         ORG   *-81\nOLC040   DS    0A\n         DC    AL1(MSGPRT)\n         DC    C'DSB040 - DEBUG OPTION CANCELLED - '\n         DC    C'OPEN ERROR ON FILE ''DEBUG'' '\n         ORG   OLC040+81\n         SPACE 1\nOLC041   DS    0CL81\n         DC    AL1(MSGPRT)\n         DC    C'DSB041 - RESTORE LIST CANCELLED - '\n         DC    C'OPEN ERROR ON FILE ''RESTORE'' '\n         DC    CL(81-(*-OLC041))'  '\n         SPACE 1\n         DC    CL81' '\n         ORG   *-81\nOLC005   DS    0A\n         DC    AL1(MSGPRT+MSGSGNL+MSGABND)\n         DC    C'DSB005 - ABEND, CANNOT OPEN SYSPRINT DD'\n         ORG   OLC005+81\n         PRINT   NOGEN\n         ENTRY OLCPRINT\nOLCPRINT DCB   MACRF=(PM),DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=800,      +\n               DDNAME=REPORT\n         ENTRY RESTORE\nRESTORE  DCB   MACRF=(PM),DSORG=PS,RECFM=FB,LRECL=200,  BLKSIZE=9044,  +\n               DDNAME=RESTORE,EXLST=DEBUGE\n         ENTRY DEBUG\nDEBUG    DCB   MACRF=(PM),DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=800,      +\n               DDNAME=DEBUG,EXLST=DEBUGE\nDEBUGE   DC    0F'0',X'87',AL3(*+3),XL176'00'\n*\n*\n TITLE 'DEBUGRTN - PRODUCE A TRACE IN FILE ''DEBUG'' '\n*\n* PRODUCE A TRACE OF SECTION ENTRIES AND EXITS\n*\n*   NOTE - SINCE DEBUG DCB OPEN BY OPENSYSP, WE GET NO TRACE UNTIL\n*          AFTER THAT SECTION HAS RUN\n*\n         DS    0H\nDEBUGRTN SECTION\n*\n*              ON ENTRY, RC IS IN  R4\n*\n         ST    R4,SAVERC          SAVE RETURN CODE\n         L     R2,=V(DEBUG)     IS DEBUG IN EFFECT\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?\n         BZ    DEBUGRET           NO\n         LR    R5,R1              R5 -> TO CSECT NAME               RH\n         SPACE 1\n         LTR   R0,R0            WAS IT A SECTION OR SECEXIT.\n         BNZ   DEBUGEX            SECEXIT\n         MVI   DEBUGN1,C' '       CLEAR MODULE NAME AREA\n         MVC   DEBUGN1+1(68),DEBUGN1 ''\n         L     R3,OFFSET        OFFSET MODULE NAME TO SHOW NESTING\n         LA    R3,4(R3)         AND INCREMENT\n         ST    R3,OFFSET\n         CH    R3,=H'69'        MAX LINE LENGTH\n         BNH   *+8\n         LA    R3,61\n         LA    R3,DEBUGN1(R3)\n         MVC   0(8,R3),0(R5)    MOVE SECTION NAME TO TEXT           RH\n         PUT   (R2),DEBUGN\n         B     DEBUGRET\nDEBUGEX  EQU   *\n         MVI   DEBUGM1,C' '       CLEAR MODULE NAME AREA\n         MVC   DEBUGM1+1(68),DEBUGM1 ''\n         L     R3,OFFSET        OFFSET MODULE NAME TO SHOW NESTING\n         LR    R4,R3\n         SH    R4,=H'4'         AND DECRMENT\n         BP    *+6\n         SR    R4,R4            DO NOT LET IT GO NEG.\n         ST    R4,OFFSET\n         CH    R3,=H'69'        MAX LINE LENGTH\n         BNH   *+8\n         LA    R3,61\n         LA    R3,DEBUGM1(R3)\n         MVC   0(8,R3),0(R5)    MOVE SECTION NAME TO TEXT           RH\n         L     R1,SAVERC          R1 = PREV SECTIONS RETURN CODE\n         LTR   R1,R1              WAS THERE A RETURN CODE?\n         BZ    NORC               NO\n         CVD   R1,DWORD2          CONVERT TO DECIMAL\n         UNPK  DWORD2(5),DWORD2+5(3) CONVERT TO DISPLAY\n         MVZ   DWORD2+4(1),DWORD2 FIX SIGN BITS\n         MVC   8(5,R3),=C', RC='  SET UP RC PART OF MSG             RH\n         MVC   13(3,R3),DWORD2+2  PUT RC IN MSG                     RH\n         SPACE 1\nNORC     DS    0H\n         PUT   (R2),DEBUGM\nDEBUGRET SECEXIT\n         DROP   R2\nDWORD2   DC    D'0'\nOFFSET   DC    F'0'\nSAVERC   DC    F'0'\nDEBUGN   DC    CL11' ENTRY TO:'\nDEBUGN1  DC    CL69' '\nDEBUGM   DC    CL11'EXIT FROM:'\nDEBUGM1  DC    CL69' '\n*\n*\n TITLE 'CLOSESYSP - CLOSE OLCPRINT DATASET AND WRITE HEADING'\n*\n* PUT OUT LAST MSG AND CLOSE OLCPRINT\n*\n         DS    0H\nCLOSSYSP SECTION\n         LA    R1,OLC999D\n         PERFORM  GETTOD                       GO GET DATE, TIME\n         L     R2,MAXCC           R2 = MAX CC\n         CVD   R2,MAXWORD         CONVERT TO DECIMAL\n         UNPK  MAXWORD(5),MAXWORD+5(3) CONVERT TO DISPLAY\n         MVZ   MAXWORD+4(1),MAXWORD FIX SIGN BITS\n         MVC   OLC999C,MAXWORD+1  SET UP RETURN CODE\n*\n*\n         L     R3,=V(OLCBLNK)     R3 -> TO BLANKS\n         OLCMSG 0(0,R3)           PRINT A BLANK LINE BEFORE OLC999\n         OLCMSG OLC999                       PUT OUT LAST MSG\n         L     R5,=V(RESTORE)     R5 -> TO RESTORE DCB\n         USING IHADCB,R5          SET DCB BASE\n         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?\n         BZ    CLOSE1             NO, DON'T CLOSE IT\n         CLOSE (R5)               CLOSE RESTORE FILE\n         DROP  R5                 DROP DCB BASE\n         SPACE 1\nCLOSE1   DS    0H\n         L     R5,=V(DEBUG)                  LOAD ADDRESS OF DCB\n         USING IHADCB,R5          SET DCB BASE\n         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?\n         BZ    CLOSE2             NO, DON'T CLOSE IT\n         CLOSE (R5)               CLOSE DEBUG FILE\n         DROP  R5                 DROP DCB BASE\n         SPACE 1\nCLOSE2   DS    0H\n         L     R4,=V(OLCPRINT)               LOAD ADDRESS OF DCB\n         USING IHADCB,R4          SET DCB BASE\n         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?\n         BZ    SETRC              NO, DON'T CLOSE IT\n         CLOSE (R4)               CLOSE OLCPRINT FILE\n         DROP  R4                 DROP DCB BASE\n         SPACE 1\nSETRC    DS    0H\n         L     R15,MAXCC          R15 = MAX CC\nCLOSSYSE SECEXIT                               RETURN TO CALLER\n         SPACE    2\n         DC    CL81' '\n         ORG   *-81\nOLC999   DS    0A\n         DC    AL1(MSGPRT)\n         DC    C'DSB999 - DATA SET BACKUP UTILITY END  '\nOLC999D  DC    CL6'YY.DDD'\n         DC    CL2' '\nOLC999T  DC    CL8'HH:MM:SS'\n         DC    C'    RETURN CODE = '\nOLC999C  DC    CL4'0000'\n         ORG   OLC999+81\n         ENTRY MAXCC\nMAXCC    DC    F'0'\nMAXWORD  DC    D'0'\n TITLE 'GETTOD - GET TIME OF DAY AND DATE'\n         DS    0H\nGETTOD   SECTION\n*\n* GET TIME OF DAY (TOD) AND FORMAT IT INTO TODDATE AND TODTIME FIELDS\n*\n* ON ENTRY R1 WILL POINT TO A 17 CHAR TEXT AREA WHICH WILL BE SET UP AS\n* FOLLOWS:\n*\n*                  'YY.DDD  HH:MM:SS '\n*\n         LR    R2,R1              TOD OUTPUT AREA\n         USING TIMEPARM,R2\n         TIME  DEC\n         STM   R0,R1,TIME\n         MVC   TODDATE(7),DATEDIT  SET UP EDIT FIELD\n         MVC   TODTIME(10),TIMEEDIT  SET UP EDIT FIELD\n         ED    TODDATE(7),DATE+1 MAKE DATE PRINTABLE\n         ED    TODTIME(10),TIME  MAKE TIME PRINTABLE\n         MVI   TODTIME+9,C' '\n         DROP  R2\n         B     RETTOD\n         SPACE    2\nDATEDIT  DC    X'4021204B202020'\nTIMEEDIT DC    X'4021207A21207A212020'\nTIME     DC    F'0'\nDATE     DC    F'0'\nCL6      DC       CL6' '\nTOD      DC       D'0'          TODTIME OF DAY FROM STCK\nRETTOD   SECEXIT                           RETURN TO CALLER\nTIMEPARM DSECT\nTODDATE  DC    CL6'YY.DDD',C'  '\nTODTIME  DC    CL8'HH:MM:SS',C' '\n TITLE 'EDITPARM - EXAMINE AND SAVE PARM PASSED TO PROGRAM'\n*\n* EDIT THE PARM WE WERE PASSED :\n*\n* ASSUMPTION: R1 IS AS ON ENTRY TO PROGRAM AFTER CALL BY SUPERVISOR\n*\n         DS    0H\nEDITPARM SECTION\n         L     R4,=V(PARMADDR)    GET A(PARM ADDRESS)\n         L     R4,0(0,R4)         R4 -> TO A(PARM)\n         L     R2,0(0,R4)         R2 -> TO PARM\n         SPACE 1\n***********************************************************************\n*\n*              SEE IF THERE IS A  PARM\n*\n*        VALID PARMS ARE:\n*              IEBCOPY   USE IEBCOPY, NOT PDSFAST\n*              RESTORE   THIS IS A RESTORE RUN\n*                 VOL=   VOLUME FOR DISK RESTORE\n*                        UP TO 4 VOLS CAN BE SPECIFIED, AS (V1,V2..)\n*                UNIT=   UNIT FOR DISK RESTORE\n*               TUNIT=   UNIT FOR TAPE\n*                 KEEP   DON'T CATALOG NEW DATASETS\n*                ALLOC   GET ALLOCATED SPACE, NOT USED SPACE\n*\n*        ANY OTHER PARMS ARE INVALID\n*        IF NO PARMS ARE SPECIFIED, THE DEFAULTS WILL BE\n*              PARM='UNIT=SYSDA,TUNIT=TAPE,VOL='\n*\n***********************************************************************\n         SPACE 1\n*              GET PARM, IF ANY\n         SPACE 1\nPARM0    DS    0H\n         LA    R10,2(0,R2)        R10 -> TO PARM\n         LH    R2,0(0,R2)         R2 = PARM LTH\n         LTR   R2,R2              IS THERE A PARM ?\n         BZ    ENDPARM            NO\n         LR    R4,R10             YES, R4 -> TO PARM\n         SPACE 1\nPARM1    DS    0H\n         CLC   =C'VOL=',0(R4)     IS IT THE 'VOL=' PARM?\n         BNE   PARM2              NO, CHECK FOR NEXT PARM\n         SPACE 1\n         L     R5,=V(PARMFLAG)    R5 -> TO PARM FLAG                RH\n         OI    0(R5),VOLFLAG      SAY VOL= WAS SPECIFIED            RH\n         LA    R4,4(0,R4)         R4 -> PAST VOL=\n         SH    R2,=H'4'           R2 = LTH OF REST OF PARM\n         LR    R5,R4              R5 -> TO VOLSERS\n         SPACE 1\nPARM1B   DS    0H\n         CLI   0(R4),C','         AT END OF VOL ?\n         BE    PARM1C             YES, GO GET NEXT PARM\n         LA    R4,1(0,R4)         R4 -> TO NEXT VOL BYTE, IF ANY\n         BCT   R2,PARM1B          CHECK ALL CHARS LEFT\n         SPACE 1\nPARM1C   DS    0H\nGOTVOL2  DS    0H\n         L     R7,=V(TUPAR2)      R7 -> WHERE VOLSER GOES\n         L     R14,=V(TUNUM2)     R14 -> TO  NBR OF VOLSERS\n         MVI   1(R14),X'01'       DEFAULT TO 1 VOLSER\n         SPACE 1\n         CLI   0(R5),C'('         MORE THAN 1 VOL?\n         BE    MULTVOL            YES\n         MVC   0(6,R7),0(R5)      MOVE VOLSER TO TEXT UNIT 2\n         B     ENDVOL             ON WE GO\n         SPACE 1\nMULTVOL  DS    0H\n         LA    R5,1(0,R5)         R5 -> TO 1ST VOL\n         LA    R15,4              R15 = MAX VOLSERS\n         B     MOVVOL2            MOVE 1ST VOLSER\n         SPACE 1\nMOVVOL   DS    0H\n         L     R14,=V(TUNUM2)     R14 -> TO  NBR OF VOLSERS\n         LH    R8,0(0,R14)        R8 = NBR OF VOLSERS\n         LA    R8,1(0,R8)         ADD ONE TO NBR OF VOLSERS\n         STH   R8,0(0,R14)        SAVE IT\n         SPACE 1\nMOVVOL2  DS    0H\n         MVC   0(6,R7),0(R5)      MOVE VOLSER TO TEXT UNIT 2\n         LA    R5,6(0,R5)         R5 -> PAST VOLSER\n         CLI   0(R5),C')'         END OF MULT VOLS?\n         BE    ENDVOL             YES\n         LA    R5,1(0,R5)         R5 -> TO NEXT VOLSER\n         LA    R7,8(0,R7)         R7 -> TO WHERE NEXT VOLSER GOES\n         BCT   R15,MOVVOL         SAVE NEXT VOLSER, TO MAX OF 4\n         SPACE 1\nENDVOL   DS    0H\n         B     NEXTPARM           GO CHECK FOR ANOTHER PARM\n         SPACE 1\nPARM2    DS    0H\n         CLC   =C'UNIT=',0(R4)    IS IT THE 'UNIT=' PARM?\n         BNE   PARM3              NO, CHECK FOR NEXT PARM\n         SPACE 1\n         LA    R4,5(0,R4)         R4 -> PAST UNIT=\n         SH    R2,=H'5'           R2 = LTH OF REST OF PARM\n         LR    R5,R4              R5 -> TO UNIT NAME\n         SPACE 1\nPARM2B   DS    0H\n         CLI   0(R4),C','         AT END OF UNIT?\n         BE    PARM2C             YES, GO GET NEXT PARM\n         LA    R4,1(0,R4)         R4 -> TO NEXT KEY BYTE, IF ANY\n         BCT   R2,PARM2B          CHECK ALL CHARS LEFT\n         SPACE 1\nPARM2C   DS    0H\n         LR    R6,R4              R6 -> TO END OF UNIT\n         SR    R6,R5              R6 = LTH OF UNIT\n         L     R7,=V(TULNG3)      R7 -> TO UNIT LTH FIELD\n         STH   R6,0(0,R7)         PUT UNIT LTH IN SVC99 FIELD\n         BCTR  R6,0               R6 = HEX LTH\n         L     R7,=V(TUPAR3A)     R7 -> TO UNIT NAME FIELD\n         MVC   0(8,R7),=CL8' '    CLEAR UNIT NAME FIELD\n         EX    R6,MVCUNIT         SET UP UNIT NAME\n         B     NEXTPARM           GO CHECK FOR ANOTHER PARM\n         SPACE 1\n*VCUNIT  MVC   0(0,R7),0(R5)      MOVE UNIT NAME\n         SPACE 1\nPARM3    DS    0H\n         CLC   =C'TUNIT=',0(R4)   IS IT THE TUNIT= PARM?\n         BNE   PARM4              NO, CHECK FOR NEXT PARM\n         SPACE 1\n         LA    R4,6(0,R4)         R4 -> PAST TUNIT=\n         SH    R2,=H'6'           R2 = LTH OF REST OF PARM\n         LR    R5,R4              R5 -> TO TAPE UNIT NAME\n         SPACE 1\nPARM3B   DS    0H\n         CLI   0(R4),C','         AT END OF UNIT?\n         BE    PARM3C             YES, GO GET NEXT PARM\n         LA    R4,1(0,R4)         R4 -> TO NEXT KEY BYTE, IF ANY\n         BCT   R2,PARM3B          CHECK ALL CHARS LEFT\n         SPACE 1\nPARM3C   DS    0H\n         LR    R6,R4              R6 -> TO END OF UNIT\n         SR    R6,R5              R6 = LTH OF UNIT\n         L     R7,=V(TULNG6)      R7 -> TO UNIT LTH FIELD\n         STH   R6,0(0,R7)         PUT UNIT LTH IN SVC99 FIELD\n         BCTR  R6,0               R6 = HEX LTH\n         L     R7,=V(TUPAR6)      R7 -> TO TAPE UNIT NAME FIELD\n         MVC   0(8,R7),=CL8' '    CLEAR UNIT NAME FIELD\n         EX    R6,MVCUNIT         SET UP UNIT NAME\n         B     NEXTPARM           GO CHECK FOR ANOTHER PARM\n         SPACE 1\nMVCUNIT  MVC   0(0,R7),0(R5)      MOVE UNIT NAME\n         SPACE 1\nPARM4    DS    0H\n         CLC   =C'RESTORE',0(R4)  IS PARM RESTORE?\n         BNE   PARM5              NO, GO CHECK FOR NEXT PARM        RH\n         SPACE 1\n         L     R5,=V(PARMOLC)     R5 -> TO OLC NAME                 RH\n         MVC   0(7,R5),0(R4)      SAVE PARM                         RH\n         SPACE 1\n         LA    R4,7(0,R4)         R4 -> TO NEXT PARM, IF ANY\n         SH    R2,=H'7'           R2 = LTH OF REST OF PARM\n         B     NEXTPARM           LOOK AT ALL CHARS IN PARM\n         SPACE 1\nPARM5    DS    0H\n         CLC   =C'KEEP',0(R4)     IS PARM KEEP ?\n         BNE   PARM6              NO, GO CHECK FOR NEXT PARM        RH\n         SPACE 1\n         L     R5,=V(PARMFLAG)    R5 -> TO PARM FLAG                RH\n         OI    0(R5),KEEPFLG      SAY KEEP WAS SPECIFIED            RH\n         L     R5,=V(TUPAR7A)     R5 -> TO S99 PARM                 RH\n         MVI   0(R5),X'08'        CHANGE DISP TO NEW,KEEP           RH\n         SPACE 1\n         LA    R4,4(0,R4)         R4 -> TO NEXT PARM, IF ANY\n         SH    R2,=H'4'           R2 = LTH OF REST OF PARM\n         B     NEXTPARM           LOOK AT ALL CHARS IN PARM\n         SPACE 1\nPARM6    DS    0H\n         CLC   =C'ALLOC',0(R4)    IS PARM ALLOC ?\n         BNE   PARM7              NO, GO CHECK FOR NEXT PARM        RH\n         SPACE 1\n         L     R5,=V(PARMFLAG)    R5 -> TO PARM FLAG                RH\n         OI    0(R5),ALLOCFLG     SAY ALLOC WAS SPECIFIED           RH\n         SPACE 1\n         LA    R4,5(0,R4)         R4 -> TO NEXT PARM, IF ANY\n         SH    R2,=H'5'           R2 = LTH OF REST OF PARM\n         B     NEXTPARM           LOOK AT ALL CHARS IN PARM\n         SPACE 1                                                    RH\nPARM7    DS    0H\n         CLC   =C'IEBCOPY',0(R4)  IS PARM IEBCOPY?\n         BNE   PARM99             NO, GO CHECK FOR NEXT PARM        RH\n         SPACE 1\n         L     R5,=V(MBRNAME)     R5 -> TO LINK NAME                RH\n         MVC   0(8,R5),=CL8'IEBCOPY' ALWAYS USE IEBCOPY\n         SPACE 1\n         LA    R4,7(0,R4)         R4 -> TO NEXT PARM, IF ANY\n         SH    R2,=H'7'           R2 = LTH OF REST OF PARM\n         B     NEXTPARM           LOOK AT ALL CHARS IN PARM\n         SPACE 1                                                    RH\nPARM99   DS    0H\n         B     ERRPARM            GO TO ERROR ROUTINE FOR NOW\n         SPACE 1                                                    RH\nNEXTPARM DS    0H\n         LTR   R2,R2              ANY PARM LEFT?\n         BNP   ENDPARM            NO\n         LA    R4,1(0,R4)         YES, R4 -> TO NEXT BYTE\n         BCTR  R2,0               TAKE 1 OFF PARM LTH\n         CLI   0(R4),C','         COMMA?\n         BNE   PARM1              NO, GO SEE WHAT IT IS\n         B     NEXTPARM           LOOK AT ALL CHARS IN PARM\n         SPACE 1\nENDPARM  DS    0H\n         SR    R15,R15            SET RETURN CODE\n         B     EXITEDIT           RETURN TO MAINLINE                RH\n         SPACE 1                                                    RH\nERRPARM  OLCMSG OLC001\n         LA    R15,4              SET BAD RETURN CODE\n         B     EXITEDIT           GO TO RETURN TO MAINLINE\n         SPACE 1                                                    RH\nEXITEDIT SECEXIT                      RETURN TO MAINLINE\n*\n* EDITPARM DATA:\n*\n         DC    CL81' '\n         ORG   *-81\nOLC001   DS    0A\n         DC    AL1(MSGPRT+MSGSGNL)\n         DC    C'DSB001 - PARM INFORMATION INVALID'\n         ORG   OLC001+81\n         SPACE 1                                                    RH\nPARMIN   DSECT\nPARMLEN  DS    H\nPARMF3   DS    CL7                FIRST 7 CHARS OF PARM\nPARMF4   DS    C                  NBR OF REGIONS TO START           RH\nPARM     DS    CL4                PARM IS AT MAX 8 CHARS LONG\n TITLE 'IEBCOPY - LINK TO IEBCOPY'\n         DS    0H\nIEBCOPY  SECTION\n*\n*  ON ENTRY TO THIS SECTION R1 POINTS TO 8 CHAR IEBCOPY SYSIN DDNAME\n*\n*  SET UP IEBCOPY PARMS\n         MVC     IEBDDNAM,0(R1)      PASS SYSIN DDNAME TO COPY\n*        MVC     OLC025DD,0(R1)      IN CASE OF ERRORS\n*        L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM\n*        CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?\n*        BNE   NOSCRCH            NO\n         PERFORM SCRATCHU         GO SCRATCH DIRECTORY OF SYSUT2\n*                                 OR READ DIRECTORY OF SYSUT1\n         SPACE 1\nNOSCRCH  DS    0H\n*\n*  GIVE IEBCOPY ITS OWN SAVE AREA AND CHAIN IT TO THE SUPERV.\n*  SAVE AREA. OTHERWISE, IEBCOPY WILL DESTROY OUR IMS TYPE\n*  SAVE AREA CHAIN\n        ST       R13,OURSA           OUR SAVE AREA POINTER\n        LA       R13,IEBSAVE         GIVE IEBCOPY ITS OWN\n        L        R5,=V(SAVE)         GET ADDR OF OUR SAVE AREA\n        L        R6,4(,R5)           GET ADDR OF SUP'S SAVE AREA\n        ST       R6,IEBSAVE+4        CHAIN SUP'S SAVEAREA TO IEBSAVE\n*\n*        SEE IF WE CAN FIND PDSFAST\n*\nBLDLNOP  NOP   NOFIND             B AFTER FIRST TIME\n         MVI   BLDLNOP+1,X'F0'    CHANGE NOP TO B\n         CLC   MBRNAME,=CL8'IEBCOPY' USE IEBCOPY ?\n         BE    NOFIND             YES, WE DON'T NEED BLDL...\n         BLDL  0,BLDLIST\n         LTR   R15,R15\n         BZ   NOFIND              WE FOUND PDSFAST\n         MVC   MBRNAME,=CL8'IEBCOPY' CAN'T FIND PDSFAST, USE IEBCOPY\n         SPACE 1\nNOFIND   DS    0H\n*                                                                   RH\n*                  THIS IS CODE TO DUMP CORE                 DEBUG  RH\n*                                                                   RH\n         L     R2,=V(DEBUG)     IS DEBUG IN EFFECT\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?\n         BZ    LINKINA            NO\n         DROP  R2                 DROP BASE...\n         SPACE 4                                             DEBUG  RH\n         L     R3,=V(JFCB)        R3 -> TO SYSUT1 JFCB       DEBUG  RH\n         PRINT   GEN\n         HDUMP OUTDCB,R3,200,NOTOPEN,OPEN,V=YES,             DEBUG  RH +\n               TITLE='SYSUT1 JFCB FOR IEBCOPY',GENDCB=YES\n         L     R3,=V(JFCBXLSJ)    R1 -> TO SYSUT2 JFCB EXIT LIST\n         HDUMP OUTDCB,R3,200,OPEN,CLOSE,                     DEBUG  RH +\n               TITLE='SYSUT2 JFCB FOR IEBCOPY'\n         SPACE 1                                             DEBUG  RH\n         PRINT NOGEN\n*                                                                   RH\n*                  THIS IS END OF CODE TO DUMP CORE          DEBUG  RH\n*                                                                   RH\nLINKINA  DS    0H                                                   RH\n         SR    R15,R15            MAKE SURE R15 IS 0\n*\n*  CALL IEBCOPY\n*\n         LINK  EPLOC=MBRNAME,PARAM=(IEBLIST,IEBDD),VL=1\n*\n*  CHECK RETURN CODE FROM PREVIOUS IEBCOPY CALL\n*\n         L        R13,OURSA          PLUG BACK INTO OUR SAVE AREA CHAIN\n         CH       R15,=H'8'          RC OVER 8?\n         BNH      *+4+4              NO, IT'S OKAY\n         LA       R15,4              YES, CHANGE IT TO 4\n         LR       R9,R15             SAVE RETURN CODE\n         SPACE    2\n         CVD      R15,IEBHRC\n         OI       IEBHRC+7,X'0F'     MAKE POSITIVE\n         UNPK     OLC025RC,IEBHRC\n         OLCMSG   OLC025\n         LR       R15,R9             SET RETURN CODE\nIEBCOPYE SECEXIT\n         SPACE 2\n* IEBCOPY DATA:\n*\n         DC    CL81' '\n         ORG   *-81\nOLC025   DC    AL1(MSGPRT)\n         DC    C'DSB025 - PDSFAST RETURN CODE ==> '\nOLC025RC DC    CL7' '          ,C' FOR SYSIN DDNAME '\n         ORG   OLC025+81\nIEBHRC   DC    D'0'\n*\n* PARMS FOR CALLING IEBCOPY\n*\n         CNOP     2,4                HALFWORD NOT FW BOUNDARY\nIEBDD    DC       AL2(IEBDDE-IEBDD-2) DDNAMES FOR IEBCOPY\n         DC       32X'00'\nIEBDDNAM DC       CL8' '             SYSIN DDNAME FOR IEBCOPY\nIEBDDE   EQU      *                  IEBDD END\n*\n         CNOP     2,4                HW, NOT FW BOUNDARY\nIEBLIST  DC       H'0'               NULL LIST\nOURSA    DC       F'0'            SAVE OUR S.A. POINTER OVER IEBCOPY\nIEBSAVE  DC       18F'0'          SPECIAL SAVE AREA FOR IEBCOPY\n*\n         ENTRY MBRNAME\nMBRNAME  DC    CL8'PDSFAST '\n*\nBLDLIST  DS    0F\n         DC    H'1',H'74'\nBLDLNAME DC    CL8'PDSFAST'       DEFAULT TO PDSFAST\nTTRC     DS    CL4\nUSERDATA DS    0CL62\n         DS    CL12\nMBRLTH   DS    CL3\n         DS    CL13\n         DS    CL34\n*\n*\n         SPACE 2\n TITLE 'SEQCOPY - SEQUENTIAL COPY '\n         DS    0H\nSEQCOPY  SECTION\n*\n*\n*        SET SYSUT2 DCB BLKSIZE AND LRECL                           RH1\n*                                                                   RH1\n         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM\n         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?\n         BNE   BACKSET            NO\n         SPACE 1\n         L     R5,=V(UT2JFCB)     R5 -> TO SYSUT2 JFCB\n         USING INFMJFCB,R5              SET DSECT\n*        XC    0(176,R5),0(R5)    MAKE SURE JFCB IS CLEAN\n         L     R4,=V(SYSUT2)      R4 -> TO SYSUT2 DCB\n         USING IHADCB,R4                SET DCB DSECT\n         RDJFCB ((4))\n         LTR   R15,R15            WAS RDJFCB OKAY?\n         BNZ   FAIL1              NO\n*\n*              MAKE SURE JFCB IS  CLEAN TO FORCE SYSTEM TO USE\n*              INFO FROM DISK DSCB\n*\n         XC    JFCRECFM,JFCRECFM  SET JFCB RECFM TO 0\n         XC    JFCBLKSI,JFCBLKSI  SET JFCB BLKSIZE TO 0\n         XC    JFCLRECL,JFCLRECL  SET JFCB LRECL TO 0\n*\n*              MAKE SURE DCB  IS  CLEAN\n*\n         XC    DCBBLKSI,DCBBLKSI  SET SYSUT2 BLKSIZE TO 0\n         XC    DCBLRECL,DCBLRECL  SET SYSUT2 LRECL TO 0\n         XC    DCBRECFM,DCBRECFM  SET SYSUT2 RECFM TO 0\n         XC    DCBDSORG,DCBDSORG  SET SYSUT2 DSORG TO 0\n*\n         SPACE 1\n         DROP  R4                 DROP R4 AS DCB BASE\n*\n*              MAKE SURE SYSUT1 DCB  IS  CLEAN\n*\n         LA    R1,INFILE          R1 -> TO SYSUT1 DCB\n         USING IHADCB,R1          SET R1 AS DCB DSECT\n         XC    DCBBLKSI,DCBBLKSI  SET SYSUT1 BLKSIZE TO 0\n         XC    DCBLRECL,DCBLRECL  SET SYSUT1 LRECL TO 0\n         XC    DCBRECFM,DCBRECFM  SET SYSUT1 RECFM TO 0\n         MVI   DCBDSORG,X'40'     SET SYSUT1 DSORG TO PS\n         DROP  R1                 DROP R1 AS DCB BASE\n         B     OPENCOPY           ON WE GO\n         B     SETDCB             ON WE GO\n         SPACE 1\nBACKSET  DS    0H\n         LA    R5,JFCB            R5 -> TO SYSUT1 JFCB\n         USING INFMJFCB,R5              SET DSECT\n         XC    0(176,R5),0(R5)    MAKE SURE JFCB IS CLEAN\n         LA    R4,INFILE          R4 -> TO SYSUT1 DCB\n         USING IHADCB,R4                SET DCB DSECT\n         RDJFCB ((4))\n         LTR   R15,R15            WAS RDJFCB OKAY?\n         BNZ   FAIL1              NO\n         L     R4,=V(SYSUT2)      R4 -> TO SYSUT2 DCB\n         SPACE 1\nSETDCB   DS    0H\n         MVC   DCBBLKSI,JFCBLKSI  SET SYSUT2 BLKSIZE\n         MVC   DCBLRECL,JFCLRECL  SET SYSUT2 LRECL\n         DROP  R4,R5\n         SPACE 1                                                    RH1\nOPENCOPY DS    0H\n         PRINT GEN\n         OPEN  ((4),(OUTPUT))     OPEN NEW FILE\n         TM    48(R4),X'10'       DID SYSUT2 OPEN OKAY ?\n         BZ    FAIL2              NO, TOO BAD\n         SPACE 1\nOPENOK   DS    0H\n         ICM   R1,15,INREC        R1 = ADDRESS OF WORK AREA\n         BNZ   GOTAREA            WE HAVE ONE ALREADY\n         GETMAIN R,LV=32768       GET A RECORD WORK AREA\n         ST    R1,INREC           SAVE ADDRESS OF RECORD AREA\n         SPACE 1\nGOTAREA  DS    0H\n*                                                                   RH\n*                  THIS IS CODE TO DUMP CORE                 DEBUG  RH\n*                                                                   RH\n         L     R2,=V(DEBUG)     IS DEBUG IN EFFECT\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?\n         BZ    OPENINA            NO\n         DROP  R2                 DROP BASE...\n         SPACE 4                                             DEBUG  RH\n         LA    R3,INFILE          R3 -> TO INFILE DCB        DEBUG  RH\n         PRINT   GEN\n         HDUMP OUTDCB,R3,100,NOTOPEN,OPEN,V=YES,             DEBUG  RH +\n               TITLE='SYSUT1 DCB FOR COPY',GENDCB=YES\n         LA    R3,OPENINA         R3 -> TO OPEN CODE         DEBUG  RH\n         HDUMP OUTDCB,R3,100,OPEN,OPEN,                      DEBUG  RH +\n               TITLE='SYSUT1 OPEN CODE'\n         L     R3,=V(JFCB)        R3 -> TO JFCB              DEBUG  RH\n         HDUMP OUTDCB,R3,200,OPEN,OPEN,                      DEBUG  RH +\n               TITLE='SYSUT1 JFCB FOR COPY'\n         HDUMP OUTDCB,0,0,OPEN,CLOSE, DUMP REGS ONLY         DEBUG  RH +\n               TITLE='REGS AT OPEN INFILE,INPUT'\n         SPACE 1                                             DEBUG  RH\n*        PRINT NOGEN\n*                                                                   RH\n*                  THIS IS END OF CODE TO DUMP CORE          DEBUG  RH\n*                                                                   RH\nOPENINA  DS    0H                                                   RH\n         OPEN  (INFILE,(INPUT)),TYPE=J   OPEN SYSUT1\n         PRINT NOGEN\n         TM    INFILE+48,X'10'    DID SYSUT1 OPEN OKAY ?\n         BZ    FAIL3              NO, TOO BAD\n*                                                                   RH\n         SPACE 1\nFPROCESS DS    0H\n         SPACE 1\n         L     R0,INREC           R0 -> TO INPUT RECORD AREA        VBS\n         GET   INFILE,(0)          READ RECORD                      VBS\n         L     R0,INREC           R0 -> TO INPUT RECORD             VBS\n         PUT   (4),(0)            WRITE RECORD ON TO NEW FILE\n         B     FPROCESS\n         SPACE 1\nFENDJOB  EQU   *\n         CLOSE ((4))              CLOSE NEW FILE\n         USING IHADCB,R4          SET R4 AS DCB DSECT\n         L     R15,DCBBUFCB       R15 = A(BUFFER)\n         BCTR  R15,0              -1\n         LTR   R15,R15            IS THERE A BUFFER?\n         BZ    NOPOOL1            NO\n         DROP  R4                 DROP R4 AS DCB DSECT\n         FREEPOOL (4)             FREE BUFFER POOL BECAUSE DUMB\n*                                 IBM DON'T\n         SPACE\nNOPOOL1  DS    0H\n         TM    INFILE+48,X'10'    DID SYSUT1 OPEN ?\n         BZ    NOCLOSE3           NO, DON'T CLOSE IT THEN\n         CLOSE INFILE             YES, CLOSE IT\n         LA    R4,INFILE          R4 -> TO INFILE DCB\n         USING IHADCB,R4          SET R4 AS DCB DSECT\n         L     R15,DCBBUFCB       R15 = A(BUFFER)\n         BCTR  R15,0              -1\n         LTR   R15,R15            IS THERE A BUFFER?\n         BZ    NOCLOSE3           NO, DON'T TRY TO FREE IT\n         DROP  R4                 DROP R4 AS DCB DSECT\n         FREEPOOL INFILE          FREE BUFFER POOL BECAUSE DUMB\n*                                 IBM DON'T\n         SPACE 1\nNOCLOSE3 DS    0H\n         SPACE 2\nSEQCOPYE SECEXIT\n         SPACE 1                                                    RH1\nFAIL1    DS    0H\n         OLCMSG   OLC015          PRINT ERROR MSG\n         LA    R15,40             SET RC=40\n         B     SEQCOPYE           END FOR NOW\n         SPACE 1                                                    RH1\nFAIL2    DS    0H\n         OLCMSG   OLC016          PRINT ERROR MSG\n         LA    R15,40             SET RC=40\n         B     SEQCOPYE           END FOR NOW\n         SPACE 1                                                    RH1\nFAIL3    DS    0H\n         OLCMSG   OLC018          PRINT ERROR MSG\n*        L     R4,=V(SYSUT2)      R4 -> TO SYSUT2 DCB\n         CLOSE ((4))              CLOSE SYSUT2 FILE\n         USING IHADCB,R4          SET R4 AS DCB DSECT\n         L     R15,DCBBUFCB       R15 = A(BUFFER)\n         BCTR  R15,0              -1\n         LTR   R15,R15            IS THERE A BUFFER?\n         BZ    NOPOOL2            NO, DON'T TRY TO FREE IT\n         DROP  R4                 DROP R4 AS DCB DSECT\n         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB\n*                                 IBM DON'T\n         SPACE 1\nNOPOOL2  DS    0H\n         LA    R15,40             SET RC=40\n         B     SEQCOPYE           END FOR NOW\n         SPACE 1\n* SEQCOPY  DATA:\n*\n         SPACE 1\nOLC015   DS    0CL81\n         DC    AL1(MSGPRT)\n         DC    CL75'DSB015 - RDJFCB OF SYSUT1 FAILED'\n         DC    C'ERROR'\n         SPACE 1\nOLC016   DS    0CL81\n         DC    AL1(MSGPRT)\n         DC    CL75'DSB016 - OPEN FAILED FOR SYSUT2'\n         DC    C'ERROR'\n         SPACE 1\nOLC018   DS    0CL81\n         DC    AL1(MSGPRT)\n         DC    CL75'DSB018 - OPEN FAILED FOR SYSUT1'\n         DC    C'ERROR'\n*\nINREC    DC    F'0'               ADDRESS OF INPUT RECORD AREA      VBS\n         SPACE\n         LTORG\n         SPACE 1\n         ENTRY INFILE,JFCB\nINFILE   DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=GM,EODAD=FENDJOB,       VBS+\n               SYNAD=FREADER,EROPT=ACC,EXLST=JFCBADD                VBS\n*              RECFM=U,BLKSIZE=31768,    FOR BLK COPIES             VBS+\n               INSERT BEFORE SYNAD ABOVE\n         SPACE 1\n         DS    0F\n         DC    C'JFCB'                                              RH1\nJFCB     DC    176X'00'\nJFCBADD  DC    X'05'              DCB OPEN EXIT                     RH1\n         DC    AL3(DCBEXIT)       *                                 RH1\n         DC    X'87'              JFCB ADDRESS                      RH1\n         DC    AL3(JFCB)          *                                 RH1\n         SPACE 2\nFREADER EQU    *\n         BR    R14                      RETURN TO GET ROUTINE\n         SPACE 3                                                    RH1\n*        IF RECFM=U ON SYSUT1, MAKE SURE CHAINED SCHEDULING BIT     RH1\n*        IN DCBOPTCD IS TURNED OFF BECAUSE STUPID OS WILL LEAVE     RH1\n*        IT ON AND THEN DCBLRECL IS NOT SET CORRECTLY.              RH1\n         SPACE 1                                                    RH1\nDCBEXIT  DS    0H                OPEN EXIT TO CHECK RECFM AND OPTCD RH1\n         USING IHADCB,R1          SET DCB DSECT BASE                RH1\n         TM    DCBRECFM,DCBRECU   IS IT A RECFM U FILE?             RH1\n         BNOR  R14                NO, RETURN TO OPEN                RH1\n         SPACE 1                                                    RH1\n         NI    DCBOPTCD,255-DCBOPTC  MAKE SURE CHAIN BIT IS OFF     RH1\n         SPACE 1                                                    RH1\nEXITEND  DS    0H                                                   RH1\n         BR    R14                RETURN TO OPEN ROUTINE            RH1\n         DROP  R1                 DROP DCB DSECT BASE               RH1\n         SPACE 1\n         LTORG\n         SPACE 2\n TITLE 'IDCCOPY - LINK TO IDCAMS'\n         DS    0H\nIDCCOPY  SECTION\n*\n*              SEE IF THIS IS A RESTORE\n*\n         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM\n         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?\n         BNE   NOTRSTOR           NO\n*\n*              SET UP THE DELETE COMMAND\n*\n         LA    R1,DELLTH          R1 -> TO DELETE CMD\n         ST    R1,EXREC           SAVE IT FOR IDCAMS\n         ST    R1,EXITREC         SAVE IT FOR IDCAMS OPEN EXIT\n         MVI   DELNAME,C' '       CLEAR DSN PART OF CMD AREA\n         MVC   DELNAME+1(CLRLTHD-1),DELNAME   ''\n         L     R1,=V(USRDSN)      R1 -> TO VSAM DSNAME\n         MVC   DELNAME,0(R1)      PUT DSN INTO DELETE CMD\n         MVC   IMPNAME,0(R1)      PUT DSN INTO IMPORT CMD\n         MVC   OBJNAME,0(R1)      PUT DSN INTO OBJECTS CMD\n         L     R1,=V(DYNTUNT1)    R1 -> TO VSAM DSNAME LTH\n         LH    R2,4(0,R1)         R2 = DSNAME LTH\n         LA    R1,DELNAME(R2)     R1 -> TO WHERE REST OF CMD GOES\n         MVC   0(L'PART4,R1),PART4 PUT REST OF DELETE CMD IN\n*\n*              SET UP THE IMPORT COMMAND\n*\n*        MVI   IMPNAME,C' '       CLEAR DSN PART OF CMD AREA\n*        MVC   IMPNAME+1(CLRLTH3-1),IMPNAME   ''\n*        L     R1,=V(USRDSN)      R1 -> TO VSAM DSNAME\n*        MVC   IMPNAME,0(R1)      PUT DSN INTO IMPORT CMD\n*        L     R1,=V(DYNTUNT1)    R1 -> TO VSAM DSNAME LTH\n*        LH    R1,4(0,R1)         R1 = DSNAME LTH\n         LA    R1,IMPNAME(R2)     R1 -> TO WHERE REST OF CMD GOES\n         MVI   0(R1),C')'         PUT ENDING ) ON\n         L     R5,=V(PARMFLAG)    R5 -> TO PARM FLAG\n         TM    0(R5),VOLFLAG      WAS THE VOL= PARM SPECIFIED?\n         BZ    GETOBJ             NO, WE ARE FINISHED\n         MVI   2(R1),C'-'         PUT ENDING - ON\n         B     GETOBJ2            GO GET VOLS\n         SPACE 1\nGETOBJ   DS    0H\n         MVC   IMLTH3(4),ENDREC   CHANGE TO /*\n         SPACE 1\nGETOBJ2  DS    0H\n*        MVC   0(L'PART3,R1),PART3 PUT REST OF IMPORT CMD IN\n*\n*        MVI   OBJNAME,C' '       CLEAR DSN PART OF OBJ AREA\n*        MVC   OBJNAME+1(CLRLTH4-1),OBJNAME   ''\n*        L     R1,=V(USRDSN)      R1 -> TO VSAM DSNAME\n*        MVC   OBJNAME,0(R1)      PUT DSN INTO OBJECTS CMD\n*        L     R1,=V(DYNTUNT1)    R1 -> TO VSAM DSNAME LTH\n*        LH    R1,4(0,R1)         R1 = DSNAME LTH\n         LA    R1,OBJNAME(R2)     R1 -> TO WHERE REST OF CMD GOES\n         MVI   1(R1),C'-'         PUT DASH IN\n*\nSKIPVOLS NOP   NOSMCA             B AFTER FIRST PASS\n         MVI   SKIPVOLS+1,X'F0'   WE ONLY NEED TO MOVE VOLS ONCE\n         MVI   VOLNAME,C' '       CLEAR VOL PART OF OBJ AREA\n         MVC   VOLNAME+1(CLRLTH5-1),VOLNAME   ''\n         LA    R7,VOLNAME         R7 -> WHERE VOLSERS GO\n         L     R1,=V(PARMFLAG)    R1 -> TO PARM FLAG\n         TM    0(R1),VOLFLAG      WAS THE VOL= PARM SPECIFIED?\n         BZ    ENDVOLO            NO, GO CALL IDCAMS\n         L     R5,=V(TUPAR2)      R5 -> WHERE VOLSERS ARE\n         L     R14,=V(TUNUM2)     R14 -> TO  NBR OF VOLSERS\n         LH    R8,0(0,R14)        R8 = NBR OF VOLSERS\n         SPACE 1\nMOVVOLO  DS    0H\n         MVC   0(6,R7),0(R5)      MOVE VOLSER TO VOLUME PARM\n         LA    R5,8(0,R5)         R5 -> TO NEXT VOLSER\n         LA    R7,6(0,R7)         R7 -> TO WHERE COMMA GOES\n         BCT   R8,MOVVOL1         SAVE NEXT VOLSER, TO MAX OF 4\n         B     ENDVOLO            ALL 4 MOVED...\n         SPACE 1\nMOVVOL1  DS    0H\n         MVI   0(R7),C','         PUT IN A COMMA\n         LA    R7,1(0,R7)         R7 -> TO WHERE NEXT VOLSER GOES\n         B     MOVVOLO            MOVE NEXT VOL\n         SPACE 1\nENDVOLO  DS    0H\n         MVC   0(3,R7),=C')))'    PUT ON ENDING PARENS\n         B     NOSMCA             GO TRY TO IMPORT IT\n         SPACE 1\n*\n*              PUT THE VSAM DSN INTO THE EXPORT COMMAND\n*\nNOTRSTOR DS    0H\n         MVI   IDCNAME,C' '       CLEAR REST OF CMD AREA\n         MVC   IDCNAME+1(CLRLTH-1),IDCNAME   ''\n         L     R1,=V(USRDSN)      R1 -> TO VSAM DSNAME\n         MVC   IDCNAME,0(R1)      PUT DSN INTO EXPORT CMD\n*        L     R1,=V(DYNTUNT1)    R1 -> TO VSAM DSNAME LTH\n*        LH    R1,4(0,R1)         R1 = DSNAME LTH\n*        LA    R1,IDCNAME(R1)     R1 -> TO WHERE REST OF CMD GOES\n*        MVC   0(L'PART3,R1),PART3 PUT REST OF EXPORT CMD IN\n         SPACE 1\nNOSMCA   DS    0H\n*\n*  GIVE IDCAMS ITS OWN SAVE AREA  AND CHAIN IT TO THE SUPERV.\n*  SAVE AREA. OTHERWISE, IDCAMS WILL DESTROY OUR IMS TYPE\n*  SAVE AREA CHAIN\n        ST       R13,OURSA2          OUR SAVE AREA POINTER\n        LA       R13,IDCSAVE         GIVE IDCAMS ITS OWN\n        L        R5,=V(SAVE)         GET ADDR OF OUR SAVE AREA\n        L        R6,4(,R5)           GET ADDR OF SUP'S SAVE AREA\n        ST       R6,IDCSAVE+4        CHAIN SUP'S SAVEAREA TO IDCSAVE\n*\n*  CALL IDCAMS\n*\n         LINK  EP=IDCAMS,PARAM=(OPTIONS,DNAMES,PGNO,IOLIST),VL=1\n*\n*  CHECK RETURN CODE FROM ABOVE IDCAMS CALL\n*\n         L        R13,OURSA2         PLUG BACK INTO OUR SAVE AREA CHAIN\n         LR       R9,R15             SAVE RETURN CODE\n         CVD      R15,IDCHRC\n         OI       IDCHRC+7,X'0F'     MAKE POSITIVE\n         UNPK     OLC026RC,IDCHRC\n         OLCMSG   OLC026          PRINT RETURN CODE MSG\n         LR       R15,R9             SET RETURN CODE\n         SPACE 1\nIDCCOPYE SECEXIT\n         SPACE 3\n*\n* IDCCOPY DATA:\n*\n         DC    CL81' '\n         ORG   *-81\nOLC026   DC    AL1(MSGPRT)\n         DC    C'DSB026 - IDCAMS  RETURN CODE ==> '\nOLC026RC DC    CL7' '\n         ORG   OLC026+81\nIDCHRC   DC    D'0'\nOURSA2   DC    F'0'               SAVE OUR S.A. POINTER OVER IDCAMS\nIDCSAVE  DC    18F'0'             SPECIAL SAVE AREA FOR IDCAMS\n         SPACE 1\nOPTIONS  DC    H'0'\nDNAMES   DC    H'0'\nPGNO     DC    H'0'\nIOLIST   DC    F'1'               NBR OF GROUPS OF 3\n         DC    A(ASYSIN)          CONTROLLER FOR SYSIN (GROUP 1)\n         DC    A(INRTN)\n         DC    A(AUDATA)\nASYSIN   DC    CL10'DDSYSIN'\nAUDATA   DC    CL100' '\n*\n         SPACE 1\nINRTN    DS    0H\n         STM    14,12,12(13)\n         BALR  R12,0\n         USING *,R12,R11\n         LA    R11,4095(0,R12)   LOAD SECOND BASE REGISTER\n         LA    R11,1(0,R11)      LOAD SECOND BASE REGISTER\n         LA    15,INSAVE\n         ST    13,4(15)\n         ST    15,8(13)\n         LR    13,15\n         B     CONT2\n         SPACE\nINSAVE   DC    18A(0)\n         SPACE\nCONT2    DS    0H\n         L     R2,4(0,R1)         R2 -> TO IOFLAGS                  RH\n         USING IOFLAGS,R2         SET BASE                          RH\n         CLI   IOFLAG1,IOFOPEN    OPENING SYSIN?\n         BE    OPENIN             YES, SAY OPEN WAS OK\n         CLI   IOFLAG1,IOFCLOS    CLOSE SYSIN?\n         BE    RETRC0             YES, SAY CLOSE WAS OKAY\n         TM    IOFLAG1,IOFGET     DOES IDCAMS WANT A RECORD?\n         BO    GIVEREC            YES, PASS IT AN EXPORT CMD\n         B     RETRC12            IGNORE EVERYTHING ELSE\n         SPACE 1\nGIVEREC  DS    0H\n         L     R3,8(0,R1)         R3 -> TO RECORD AREA\n         USING IOINFO,R3          SET BASE                          RH\n         L     R15,EXREC          R15 -> TO EXPORT CTL RECORD\n         LH    R14,0(0,R15)       R14 = LTH OF RECORD\n         ST    R14,IOIRECL        PASS IT TO IDCAMS\n         LA    R1,2(0,R15)        R1 -> TO RECORD\n         ST    R1,IOIREC          PASS IT TO IDCAMS\n         AR    R15,R14            ADD REC LTH TO R15\n         LA    R15,2(0,R15)       R15 -> TO NEXT REC\n         ST    R15,EXREC          SAVE ITS ADDRESS\n         CLC   0(2,R1),ENDATA     END OF INPUT TO IDCAMS?\n         BE    RETRC4             YES\n         SPACE 1\nRETRC0   DS    0H\n         LA    R15,0              SAY  GET WAS OK                   RH\n         B     RET2               GO BACK TO IDCAMS                 RH\nRETRC4   DS    0H\n         LA    R15,4              SAY  NO MORE SYSIN                RH\n         B     RET2               GO BACK TO IDCAMS                 RH\n         SPACE 1\nCLOSIN   DS    0H\n         SPACE 1\nOPENIN   DS    0H\n         L     R15,EXITREC        R15 -> TO 1ST INPUT AREA\n         ST    R15,EXREC          RESET INPUT REC ADDRESS\n         B     RETRC0             GO SET RC AND RETURN\n         SPACE 1\nRETRC12  DS    0H\n         LA    R15,12             SAY CALL WAS BAD                  RH\n         B     RET2               GO BACK TO IDCAMS                 RH\n         SPACE 1\nRET      LA    15,0          GET RETURN CODE\n         ORG   *-2\nRETRC    DS    H             HALF WORD RETURN CODE, INITIALY ZERO\nRET2     DS    0H\n         L     13,4(13)      GET OLD SAVE AREA\n         L     14,12(13)     GET REG 14\n         LM    0,12,20(13)   GET REST OF REGS\n         BR    14\n         SPACE 1\nPART3    DC    C' OUTFILE(SYSUT2) TEMPORARY'\nPART4    DC    C'''  PURGE'\n         SPACE 1\nEXREC    DC    A(INLTH)           -> TO DELLTH FOR RESTORE\nEXITREC  DC    A(INLTH)           -> TO DELLTH FOR RESTORE\n         SPACE 1\n*\n*                                 1ST PART OF EXPORT CMD\n*\nINLTH    DC    AL2(INCTLL)\nINCTL    DC    C' EXPORT '\nIDCNAME  DC    CL44' '\nCLRLTH   EQU   *-IDCNAME\n         DC    C' -'\n         DC    CL(80-(*-INCTL))'  '\nINCTLL   EQU   *-INCTL\n*\n*                                 2ND PART OF EXPORT CMD\n*\nINLTH2   DC    AL2(INCTLL2)\nINCTL2   DC    CL5' '\n         DC    C' INFILE(SYSUT1)'\n         DC    C' OUTFILE(SYSUT2) TEMPORARY'\n         DC    CL(80-(*-INCTL2))' '\nINCTLL2  EQU   *-INCTL2\n*\n*                                 /* TO END INPUT\n*\n         DC    H'2'\nENDATA   DC    C'/*'\n         SPACE 2\n*\n*                                 DELETE COMMAND\n*\nDELLTH   DC    AL2(DELCTLL)\nDELCTL   DS    0C\n         DC    C'  DELETE '''\nDELNAME  DC    CL44' '                       44\n*        DC    C''' PURGE'\n         DC    CL(80-(*-DELCTL))' '\nCLRLTHD  EQU   *-DELNAME\nDELCTLL  EQU   *-DELCTL\n*\n*                                 1ST PART OF IMPORT CMD\n*\nIMLTH    DC    AL2(IMCTLL)\nIMCTL    DC    C' IMP '                      5\n         DC    C'IFILE(SYSUT1) IEMPTY PURGE -' 28\n         DC    CL(80-(*-IMCTL))'  '\nCLRLTH2  EQU   *-IMPNAME\nIMCTLL   EQU   *-IMCTL\n*\n*                                 2ND PART OF IMPORT CMD\n*\nIMLTH2   DC    AL2(IMCTLL2)\nIMCTL2   DS    0C\n         DC    C'    ODS('\nIMPNAME  DC    CL44' '                       44\n*        DC    C') -'\n         DC    CL(80-(*-IMCTL2))' '\nCLRLTH3  EQU   *-IMPNAME\nIMCTLL2  EQU   *-IMCTL2\n*\n*                                 3RD PART OF IMPORT CMD\n*\nIMLTH3   DC    AL2(IMCTLL3)\nIMCTL3   DS    0C\n         DC    C'    OBJ(('\nOBJNAME  DC    CL44' '                       44\n*        DC    C'-'                          1\n         DC    CL(80-(*-IMCTL3))' '\nCLRLTH4  EQU   *-OBJNAME\nIMCTLL3  EQU   *-IMCTL3\n*\n*                                 4TH PART OF IMPORT CMD\n*\nIMLTH4   DC    AL2(IMCTLL4)\nIMCTL4   DS    0C\n         DC    C'       VOLUMES('\nVOLNAME  DC    CL27' '                       44\n         DC    C')))'\n         DC    CL(80-(*-IMCTL4))' '\nCLRLTH5  EQU   *-VOLNAME\nIMCTLL4  EQU   *-IMCTL4\n*\n*                                 /* TO END INPUT\n*\nENDREC   DC    H'2'\nENDATA2  DC    C'/*'\n         SPACE 2\n         LTORG\nIOFLAGS  DSECT\nIOFLAG1  DS    X\nIOFOPEN  EQU   X'00'\nIOFCLOS  EQU   X'04'\nIOFGET   EQU   X'08'\nIOFPUT   EQU   X'0C'\nIOFLAG2  DS    X\nIOFIN    EQU   X'80'\nIOFOUT   EQU   X'40'\nIOFLAG3  DS    X\nIOFLAG4  DS    X\n         SPACE 1\nIOINFO   DSECT\nIOIREC   DS    F\nIOIRECL  DS    F\n         SPACE 1\n         SPACE 1\n TITLE 'DETUSER - OPEN AND READ THE APPROPRIATE LIB CONTROL MEMBER'\nDETUSER SECTION\n*\n*           //DSNS GIVES US THE NAMES OF THE USER LIBRARIES\n*\n* READ //DSNS, GO PROCESS THE USER LIBS SPECIFIED THEREIN\n*\n*        ON ENTRY, OUTPUT DDNAME IS IN VARIABLE IEBHLDIN\n*\nDCBPT    EQU     8\n         LA      DCBPT,USRCNTL            GET ADDR OF DCB\n         USING   IHADCB,DCBPT             ESTABLISH DCB ADDRESABILITY\n         L       R4,=V(USRDDNAM)          GET ADDR OF USR LIB LIST MEM\n         MVC     DCBDDNAM,0(R4)           MOVE DDNAME INTO DCB\n         MVC     OLC042DD,0(R4)           MOVE IT IN CASE OF ERR MSG\n         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM\n         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?\n         BE    RSTOR              YES, DON'T GET SYSUT2 INFO\n*\n         PERFORM HOLDBLKS,ERR=SEND71   GET SOME INFO ON SYSUT2\n*\n         L     R2,=V(UT2JFCB)     R2 -> TO SYSUT2 JFCB              RH\n         USING IHAJFCB,R2\n         LH    R5,JFCBFLSQ        R5 = STARTING SEQ NBR\n         DROP  R2                 DROP JFCB BASE\n         CH    R5,=H'1'           STARTING AT FILE 1?\n         BH    RSTOR              NO, DON'T CREATE EXPIRY DATE FILE\n*\n         PERFORM EXPALLOC ERR=ESTAEOFF  GO CREATE EXPIRY DATE FILE\n*\nRSTOR    DS    0H\n         OPEN    ((DCBPT),(INPUT))\n         TM      DCBOFLGS,DCBOFOPN        DID IT OPEN ?\n         BO      NEXTUSR                  YES\n         OLCMSG  OLC042                   PUT OUT MSG AND ABEND\n         SPACE 1\nNEXTUSR  L       R2,=V(USRDSN)\n         GET     (DCBPT),(R2)       ON EOF, WILL BRANCH TO EOFUSRC\n         CLI   0(R2),C'*'         COMMENT RECORD?\n         BE    NEXTUSR            YES, IGNORE IT\n         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM\n         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?\n         BNE   NOTREST            NO, DON'T COPY THIS RECORD\n         SPACE 1\n         L     R1,=V(RESTREC)     R1 -> TO RESTORE RECORD AREA\n         MVC   0(L'RESTREC,R1),0(R2) MOVE RECORD TO RESTORE AREA\n         USING RESTRECD,R1        SET BASE\n*\n*              SEE IF THERE IS ANOTHER VOLSER\n*\n         L     R3,=V(VOLSER2)     R3 -> TO MULTIPLE VOLSER NBR\n         LA    R4,7(0,R3)         R4 -> TO MULTIPLE VOLSER AREA\n         LA    R5,1               SAY AT LEAST 1 VOLSER\n         MVC   1(6,R3),RESTVSER   SAVE FIRST VOLSER\n         SPACE 1\nNEXTUSR2 DS    0H\n         CLI   RESTVSER+6,C' '    IS THERE ANOTHER VOLSER?\n         BE    NOVOL2F            NO\n         SPACE 1\nNEXTUSR3 DS    0H\n         GET   (DCBPT),NEXTREC    READ 2ND LINE, ON EOF -> EOFUSRC\n         LA    R1,NEXTREC         R1 -> TO NEXT RESTORE RECORD\n         CLI   0(R1),C'*'         COMMENT RECORD?\n         BE    NEXTUSR3           YES, IGNORE IT\n         MVC   0(6,R4),RESTVSER   SAVE NEXT VOLSER\n         LA    R4,6(0,R4)         R4 -> TO WHERE NEXT VOLSER GOES\n         LA    R5,1(0,R5)         R5 = NBR OF VOLS\n         B     NEXTUSR2           GO SEE IF THERES ANOTHER ONE\n*\n*              NOW SET UP THE DSORG FOR SYSUT2\n*\nNOVOL2F  DS    0H\n         STC   R5,0(0,R3)         SAVE NBR OF VOLS\n         L     R1,=V(RESTREC)     R1 -> TO RESTORE RECORD AREA AGAIN\n         L     R14,=V(SYSDSORG)   R14 -> TO SYSUT2 DSORG\n         MVC   0(2,R14),=X'0008'  ASSUME IT'S VSAM\n         CLC   RESTTYPE,=C'VS'    IS IT A VSAM FILE?\n         BE    DSORGSET           YES, DSORG IS SET\n         MVC   0(2,R14),=X'0200'  ASSUME IT'S PO\n         CLC   RESTTYPE,=C'PO'    IS IT A PO FILE?\n         BE    DSORGSET           YES, DSORG IS SET\n         MVC   0(2,R14),=X'2000'  ASSUME IT'S DA\n         CLC   RESTTYPE,=C'DA'    IS IT A DA FILE?\n         BE    DSORGSET           YES, DSORG IS SET\n         MVC   0(2,R14),=X'4000'  ASSUME IT'S SEQ\n         CLC   RESTTYPE,=C'PS'    IS IT A SEQ FILE?\n         BE    DSORGSET           YES, DSORG IS SET\n         SPACE 1\nDSORGSET DS    0H\n         DROP  R1                 DROP BASE\n         SPACE 1\nNOTREST  DS    0H\n         PERFORM USRPROC            GO PROCESS THE USERS LIBRARY\n         L     R2,=V(MAXCC)       ADDRESS OF MAX RC\n         C     R15,0(0,R2)        THIS RC BIGGER THAN THE LAST ONE?\n         BNH   NOTBIG             NO\n         ST    R15,0(0,R2)        YES, SAVE THIS RC\n         SPACE 1\nNOTBIG   DS    0H\n         CH      R15,=H'20'         ANY SERIOUS ERRORS?\n         BNH     NEXTUSR            IF NOT, CONTINUE WITH USER DSN LIST\n         SPACE 1\nSEND71   DS    0H\n         OLCMSG  OLC071             PUT OUT MSG AND ABEND\n         B     EOFUSRC2           END OF BACKDSNS...\n         SPACE   2\nEOFUSRC  DS      0H                 BRANCH HERE ON EOF FILE FMTCNTL\n*\n*              RE-WRITE FIRST DSN  IN CASE THEY SPECIFIED\n*              NEW,CATLG.....     DOESN'T WORK YET...OCT 1/98       RH\n*\n*        L     R2,=V(FREEFLAG)    R2 -> TO FREEFLAG\n*        OI    0(R2),LASTDSN      SAY WRITE LAST DSN\n*        PERFORM EXPALLOC ERR=ESTAEOFF  GO CREATE EXPIRY DATE FILE\n*\n         SPACE   2\nEOFUSRC2 DS      0H                 BRANCH HERE ON EOF FILE FMTCNTL\n         CLOSE   ((DCBPT))          CLOSE THE FMT CONTROL DATASET\n         USING IHADCB,DCBPT       SET DCBPT AS DCB DSECT\n         L     R15,DCBBUFCB       R15 = A(BUFFER)\n         BCTR  R15,0              -1\n         LTR   R15,R15            IS THERE A BUFFER?\n         BZ    NOPOOL3            NO, DON'T TRY TO FREE IT\n         DROP  DCBPT              DROP DCBPT AS DCB DSECT\n         FREEPOOL (DCBPT)         FREE BUFFER POOL BECAUSE DUMB     RH\n*                                 IBM DON'T                         RH\n         SPACE 1\nNOPOOL3  DS    0H\n         SR      R15,R15\nDETUSERE SECEXIT                    RETURN\n         SPACE   2\nOLC042   DC      CL81' '\n         ORG     *-81\n         DC      AL1(MSGPRT+MSGSGNL+MSGABND)\n         DC    C'DSB042 - UNABLE TO OPEN COPY CONTROL DDCARD '\nOLC042DD DC      CL8'UNKNOWN'\n         ORG     OLC042+75\n         DC      CL5'ERROR'\n         ORG     OLC042+81\nOLC071   DC      CL81' '\n         ORG     *-81\n         DC      AL1(MSGPRT+MSGABND)\n         DC    C'DSB071 - SERIOUS ERROR PROCESSING USER LIBRARY'\n         ORG     OLC071+75\n         DC      CL5'ERROR'\n         ORG     OLC071+81\n         SPACE 1\n         DS    0F                 PUT ON FULLWORD BOUNDARY\nNEXTREC  DS    CL200              INPUT AREA FOR MULT VOLS\n         SPACE 1\n         PRINT     NOGEN\nUSRCNTL  DCB     MACRF=(GM),DSORG=PS,DDNAME=DCBDDNAM,EODAD=EOFUSRC\n         SPACE 2\n TITLE 'HOLDBLKS - GET SYSUT2 INFORMATION'\n*\n*\n*        ON ENTRY, OUTPUT DDNAME IS IN VARIABLE IEBHLDIN\n*\n*\nHOLDBLKS SECTION\n*\n*              GET THE DEVICE TYPE\n*\n*\n*  SEARCH THROUGH THE TIOT TO FIND THE DDNAME 'SYSUT2'.\n*\nCHEKTIOT L         R1,16               A(CVT)\n         L         R1,0(R1)            A(TCB ADDRESSES)\n         L         R1,4(R1)            A(OUT TCB)\n         L         R1,12(R1)           A(TIOT)\n         LA        R3,24               OFFSET OF FIRST DDNAME ENTRY\n*\n*   NOW CHECK THE NEXT ENTRY IN THE TIOT. AN ENTRY LENGTH OF\n*   ZERO SIGNALS THE END.\n*\nTIOLOOP  AR        R1,R3               GO ON TO NEXT ENTRY\n         IC        R3,0(R1)            LENGTH OF ENTRY\n         LTR       R3,R3               LENGTH OF ZERO?\n         BZ        TIOEND              YES, SO MUST BE END OF TABLE\n         CLC       4(6,R1),=C'SYSUT2'  SYSUT2 ENTRY?\n         BNE       TIOLOOP             NO, SO BACK FOR NEXT ONE\n*\n*   WE'VE FOUND SYSUT2 DD ENTRY, SO PLACE THE UNIT ADDRESS INTO\n*   THE SVC99  FIELD.\n*\n*        L     R5,16(0,R1)        R5 -> TO UCB\n*        LA    R5,1(0,R5)         CLEAR HI BYTE\n*        L     R7,=V(TUPAR6)      R7 -> TO UNIT FIELD FOR SVC99\n*        MVC   0(3,R7),12(R5)     PUT UNIT NAME INTO SVC99 BLOCK\n*        MVC   3(5,R7),=CL5' '    BLANK OUT REST OF UNIT NAME\n*\n*   THE ONLY PROBLEM IS THAT THE ABOVE CODE DOESN'T WORK FOR\n*   4 DIGIT UCB ADDRESSES, AS THE UCBNAME FIELD CONTAINS 'UCB'.\n*   SO WE MUST CONVERT THE REAL UCB ADDRESS FROM THE HEX ADDRESS\n*   AT OFFSET +4 IN THE UCB...FEB 10/99\n*\n*   ALSO, IF YOU ARE ALLOCATING BY UNIT, IT MUST BE PRECEDED BY /   RH\n*              ..EG../190A.....\n*\n         L     R5,16(0,R1)        R5 -> TO UCB\n*        LA    R5,1(0,R5)         CLEAR HI BYTE\n*        L     R7,=V(TUPAR6)      R7 -> TO UNIT FIELD FOR SVC99\n         L     R7,=V(TULNG6)      R7 -> TO UNIT FIELD FOR SVC99\n*\n*              CONVERT UCB ADDRESS FOR UNIT NAME\n*\n*        MVI   2(R7),C'/'         SAY WE ARE USING A 4-DIGIT UCB    RH\n*        MVI   TULNG3+1,X'05'     MAKE SURE LTH IS 5                RH\n         MVI   1(R7),X'04'        MAKE SURE LTH IS 4                RH\n         UNPK  2(5,R7),4(3,R5)    UNPACK 4 DIGIT UNIT ADDRESS\n         MVI   6(R7),X'EF'        TRANSLATES TO BLANK\n         TR    2(5,R7),TRTAB-239  TRANSLATE TO DISPLAY\n         MVC   7(3,R7),=CL5' '    BLANK OUT REST OF UNIT NAME\n*\n*                                                                   RH\n*                  THIS IS CODE TO DUMP CORE                 DEBUG  RH\n*                                                                   RH\n         L     R2,=V(DEBUG)     IS DEBUG IN EFFECT\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?\n         BZ    TIOT2              NO\n         DROP  R2                 DROP BASE...\n         SPACE 1                                             DEBUG  RH\n         PRINT   GEN\n         HDUMP OUTDCB,R1,200,NOTOPEN,OPEN,V=YES,             DEBUG  RH +\n               TITLE='TIOT FOR SYSUT2'        ,GENDCB=YES\n         HDUMP OUTDCB,R5,200,NOTOPEN,OPEN,V=NO,              DEBUG  RH +\n               TITLE='UCB FROM TIOT'          ,GENDCB=YES\n         HDUMP OUTDCB,R7,20,NOTOPEN,OPEN,V=NO,              DEBUG   RH +\n               TITLE='TUPAR6 AT TIOT'          ,GENDCB=YES\n         SPACE 1                                             DEBUG  RH\n         PRINT NOGEN\n*                                                                   RH\n*                  THIS IS END OF CODE TO DUMP CORE          DEBUG  RH\n*                                                                   RH\n         SPACE 1                                             DEBUG  RH\nTIOT2    DS    0H                                            DEBUG  RH\n         SPACE 1\nHB20     DS    0H\n         L     R2,=V(SYSUT2)      R2 -> TO SYSUT2 DCB               RH\n         RDJFCB ((2))             GET THE SYSUT2 JFCB               RH\n         LTR   R15,R15            GET IT?                           RH\n         BNZ   FAIL4              IF NOT  NO BLKSIZE                RH\n         L     R2,=V(UT2JFCB)     R2 -> TO SYSUT2 JFCB              RH\n         USING IHAJFCB,R2\n         MVC   FIRSTJFC,0(R2)     SAVE 1ST JFCB\n*\n*   PUT SOME OF THE JFCB INFO INTO THE SVC99 PARMS\n*\n*       NOTE...THE DATASET NAME ON THE TAPE MUST BE DIFFERENT\n*              THAN THE DISK DATASET NAME, SO START ALL THE TAPE\n*              DATASET NAMES WITH \"BACKUP.\".\n*\n         L     R6,=V(TUPAR1)      R6 -> WHERE DSN GOES FOR SVC99\n*        MVC   0(6,R6),=C'BACKUP' START BACKED UP DSN WITH BACKUP.\n         MVC   0(44,R6),JFCBDSNM  PUT DSN IN\n*\n         L     R6,=V(FIRSTDSN)    R6 -> WHERE DSN GETS SAVED\n         MVC   0(44,R6),JFCBDSNM  PUT DSN IN\n         CLI   JFCBVLSQ,X'00'     IS THERE A VOLSEQ IN JFCB?\n         BE    NOVLSQ             NO, DON'T SAVE IT\n         L     R5,=V(VOLSEQ)      R5 -> WHERE VOL SEQ NBR GOES\n         MVC   0(2,R5),JFCBVLSQ   SAVE JFCB VOL SEQ NBR\n         SPACE 1\nNOVLSQ   DS    0H\n         LH    R5,JFCBFLSQ        R5 = STARTING SEQ NBR\n*        DC    H'0'                                           DEBUG\n*        B     NOVLSQ2                               WHY???   DEBUG\n         CH    R5,=H'1'           FILE SEQ NBR = 0?\n         BL    NOVLSQ2            YES, DON'T SUBTRACT 1\n         BCTR  R5,0               -1 FOR NEWALLOC SECTION\n         SPACE 1\nNOVLSQ2  DS    0H\n         L     R6,=V(TUPAR7)      R6 -> WHERE SEQNBR GOES\n         STH   R5,0(0,R6)         SAVE 1ST SEQ NBR FOR OPEN TYPE J\n*\n*              FIND LTH OF DSN START\n*\n         L     R6,=V(TUPAR1)      R6 -> TO DSN\n         SR    R5,R5              R5 = 0\n         CLC   0(4,R6),=C'NONE '  DSN=NONE ?\n         BE    OUT9A              YES, MAKE SURE HLILTH = 0\n         SPACE 1\nLOOP1    DS    0H\n         CLI   0(R6),C' '         AT END OF DSN ?\n         BE    OUT1               YES, CHECK LTH\n         LA    R6,1(0,R6)         ADD 1 DSN POSITION REG\n         LA    R5,1(0,R5)         ADD 1 TO LTH CTR\n         B     LOOP1              LOOK AT NEXT CHAR\n         SPACE 1\nOUT1     DS    0H\n         CH    R5,=H'39'          DSN TOO LONG TO ADD TRAILER?\n         BL    PUTDOT             NO, ADD PERIOD\n         SPACE 1\nLOOP1A   DS    0H                 YES, FIND PREVIOUS PERIOD\n         BCTR  R6,0               SUBT 1 FROM DSN POSITION REG\n         BCTR  R5,0               SUBT 1 FROM LTH CTR\n         CLI   0(R6),C'.'         AT PREV PERIOD?\n         BE    OUT1               YES, CHECK LTH\n         MVI   0(R6),C' '         BLANK CHAR\n         B     LOOP1A             LOOK AT NEXT CHAR\n         SPACE 1\n         SPACE 1\nPUTDOT   DS    0H\n         MVI   0(R6),C'.'         PUT THE PERIOD IN\n         L     R7,=V(TULNG1)      R7 -> LTH SAVE AREA FOR SVC99\n         STH   R5,0(0,R7)         SET UP LTH FIELD FOR FREE\n         LA    R5,1(0,R5)         ADD 1 TO LTH CTR\n         SPACE 1\nOUT9A    DS    0H\n         L     R7,=V(HLILTH)      R7 -> LTH SAVE AREA\n         STH   R5,0(0,R7)         SET UP LTH FIELD OF HLI\n         B     HBRETN             END FOR NOW\n         SPACE 2\nTIOEND   DS    0H\n         OLCMSG   OLC020          SEND DD STATEMENT MISSING MSG     RH\n         LA    R15,44             SET RC=44\n         B     HBRETN2            ABEND FOR NOW\n         SPACE 1\nFAIL4    DS    0H\n         OLCMSG   OLC060          SEND RDJFCB FAILED MSG            RH\n         LA    R15,44             SET RC=44\n         B     HBRETN2            ABEND FOR NOW\n         SPACE 1\nHBRETN   DS    0H\n         SR    R15,R15            RC = 0\n         SPACE 1\nHBRETN2  SECEXIT                               RETURN TO CALLER\n         SPACE 2\n*\n* HOLDBLKS DATA:\n*\n         SPACE 3\nTRTAB    DC    C' 0123456789ABCDE '\n         SPACE 2\n         ENTRY FIRSTJFC\n         DS    0F\n         DC    C'FIRSTJFCB'                                         RH1\nFIRSTJFC DC    XL176'00'\n         SPACE 1\n         DC    CL81' '\n         ORG   *-81\nOLC020   DS    0A\n         DC    AL1(MSGPRT)\n         DC    C'DSB020 - '\n         DC    CL6'SYSUT2 DD STATEMENT MISSING '\n         ORG   OLC020+75\n         DC    CL5'ERROR'\n         ORG   OLC020+81\n         SPACE 1\n         DC    CL81' '\n         ORG   *-81\nOLC060   DS    0A\n         DC    AL1(MSGPRT)\n         DC    C'DSB060 - '\nOLC060A  DC    C'INITIAL READ OF JFCB FOR SYSUT2 FAILED'\n         ORG   OLC060+75\n         DC    CL5'ERROR'\n         ORG   OLC060+81\n         SPACE 2\n TITLE 'USRPROC - PROCESS THE FORMAT/PGM LIBRARY FOR A GIVEN USER'\nUSRPROC SECTION\n*\n* PROCESS THE LIBRARY NAME OBTAINED IN DETUSER SECTION\n*\n         PERFORM BUILDDSN,ERR=RETUPROC  GO BUILD THE USR LIB DSNAME\n*\n         MVI   FREEFLAG,X'00'     TURN FREE FLAG OFF\n         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM\n         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?\n         BNE   NOTREST2           NO\n         L     R3,=V(RESTREC)     R3 -> TO RESTORE RECORD\n         USING RESTRECD,R3        SET RECORD BASE\n         CLC   RESTTYPE,=C'DA'    IS IT A DA FILE?\n         BE    CANTREST           YES, WE CAN'T RESTORE IT\n         PERFORM TAPALLOC,ERR=RETUPROC  GO DYNALLOC THE TAPE FILE\n         CLC   RESTTYPE,=C'VS'    IS IT A VSAM FILE?\n         BNE   PERFDYN            NO, GO ALLOCATE IT\n         L     R1,=V(DYNTUNT4)    R1 -> TO VOLSER TEXT UNIT\n         MVC   6(6,R1),RESTVOL    PUT IN THE CATALOG VOLSER\n         SPACE 1\nPERFDYN  DS    0H\n         PERFORM DYNALLOC         GO DYNALLOC THE USER LIB\n         LTR   R15,R15            WAS ALLOC OKAY?\n         BZ    ALLOK2             YES, ON WE GO\n         CH    R15,=H'99'         SHOULD WE CREATE THE DSN?\n         BNE   RETUPROC           NO, END FOR NOW\n         CLC   RESTTYPE,=C'VS'    IS IT A VSAM FILE?\n         BE    ALLOK4             YES, SAY WE DIDN'T ALLOCATE IT\n         SPACE 1\n         L     R1,=V(DSNFLAG)     R1 -> TO ALLOCATE FLAG\n         OI    0(R1),X'08'        SAY ALLOCATE NEW DATASET\n         PERFORM GETDS,ERR=RETUPROC  GO CREATE THE USER LIB\n*        LTR   R15,R15            DID WE ALLOC IT?\n*        BNZ   NOALLOC            NO, TOO BAD\n         L     R14,=V(TUPL2D)     PUT IT HERE\n         ST    R15,0(0,R14)       CLEAR DCB TEXT UNIT ADDRESS\n         B     ALLOK2             ON WE GO IF IT WORKED\n         SPACE 1\nNOTREST2 DS    0H\n         PERFORM DYNALLOC,ERR=RETUPROC  GO DYNALLOC THE USER LIB\n*\nALLOK2   DS    0H\n         CLC   RESTTYPE,=C'VS'    IS IT A VSAM FILE?\n         BE    ALLOK4             YES, SAY WE DIDN'T ALLOCATE IT\n         DROP  R3                 DROP RECORD BASE\n         OI    FREEFLAG,X'80'     SAY WE ALLOCATED THE DATASET\n*\nALLOK4   DS    0H\n         L     R14,=V(SYSDSORG)   R14 -> TO SYSUT1 DSORG\n         CLC   0(2,R14),=X'0008'  IS IT VSAM?\n         BE    DSORGOK            YES, ON WE GO\n         TM    0(R14),X'02'       IS IT PO OR POU?\n         BO    DSORGOK            YES, WE CAN HANDLE IT\n         TM    0(R14),X'20'       IS IT DA OR DAU?\n         BO    DSORGOK            YES, WE CAN HANDLE IT\n         TM    0(R14),X'40'       IS IT PS OR PSU?\n         BO    DSORGOK            YES, WE CAN HANDLE IT\n         SPACE 1\nBADDSORG DS    0H\n*        L     R3,=V(USRDSN)      GET ADDRESS OF INPUT DSNAME\n*        MVC   OLC100DS(44),0(R3) MOVE DSNAME TO ERROR TEXT\n         OLCMSG OLC100            PRINT BAD DSORG MSG\n         LA    R15,4              SET RC=4\n         B     IGNORLIB           END FOR NOW\n         SPACE 1\nCANTREST DS    0H\n         OLCMSG CANTMSG           SAY WE CAN'T RESTORE DA FILES\n         OLCMSG OLC100            PRINT BAD DSORG MSG\n         LA    R15,4              SET RC=4\n         B     RETUPROC           END FOR NOW\n         SPACE 1\nDSORGOK  DS    0H\n*\n         PERFORM RACCHECK,ERR=IGNORLIB  CHECK AUTH TO ACCESS LIBRARY\n*\n         NI      RECOFLG,255-RECOYES    CLEAR RECOVERY IN PROGRESS FLAG\n         PERFORM SYNCRECO               INIT THE RECOVERY REGS\n         TM      RECOFLG,RECOYES        ARE WE IN RECOVERY MODE ?\n         BO      IGNORLIB               IF SO, IGNORE THE CURRENT LIB\n*\n*        PERFORM ESTAEON                GO TURN RECOVERY TRAP ON\n*\n         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM\n         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?\n         BE    NOEMPTY2           YES\n         PERFORM EMPTYCHK,ERR=ESTAEOFF  GO CHECK IF LIB IS EMPTY\n*\n         PERFORM NEWALLOC,ERR=ESTAEOFF  GO FIX SYSUT2 JFCB\n*\nNOEMPTY2 DS    0H\n         PERFORM COPYUSER,ERR=ESTAEOFF  GO COPY USR LIB TO HOLD\n*\nESTAEOFF DS    0H\n         LR    R4,R15             SAVE RC\n*        PERFORM ESTAEOF                GO TURN ESTAE OFF\n         LR    R15,R4             LOAD RC\n*\nIGNORLIB DS    0H\n         AGO   .SKIPVS\n         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM\n         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?\n         BNE   IGNORLB1           NO\n         L     R3,=V(RESTREC)     R3 -> TO RESTORE RECORD\n         USING RESTRECD,R3        SET RECORD BASE\n         CLC   RESTTYPE,=C'VS'    IS IT A VSAM FILE?\n         BE    RETUPROC           YES, WE DIDN'T ALLOCATE IT\n         DROP  R3                 DROP RECORD BASE\n         SPACE 1\nIGNORLB1 DS    0H\n.SKIPVS  ANOP\n         LR    R4,R15             SAVE RC OVER FREE\n         PERFORM DYNFREE,ERR=RETUPROC  GO DYNFREE THE USER LIB\n         LR    R15,R4             LOAD RC OVER FREE\n*\nRETUPROC SECEXIT                        RETURN TO CALLER\n         ENTRY   RECOFLG\nRECOFLG  DC      X'00'\nRECOYES  EQU     1\n         ENTRY FREEFLAG\nFREEFLAG DC    X'00'              ALLOCATION FLAG\n*        EQU   X'80'              DATASET WAS ALLOCATED\nLASTDSN  EQU   X'40'              WRITE LAST DATASET ON TAPE\n         SPACE 1\n         DC    CL81' '\n         ORG   *-81\nOLC100   DS    0A\n         DC    AL1(MSGPRT)\n         DC    C'DSB100 - DATASET NOT COPIED. DSORG INVALID: '\n         ORG   OLC100+75\n         DC    CL5'ERROR'\n         ORG   OLC100+81\n         SPACE 1\nCANTMSG  DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    C'CANTMSG- DA FILES MUST BE RESTORED WITH A DA'\n         DC    C' LOAD PROGRAM'\n         ORG   OLC100+75\n         DC    CL5'ERROR'\n         ORG   OLC100+81\n         SPACE 2\n TITLE 'ESTAEON - SET STAE ROUITNE'\n*\n* PROCESS THE LIBRARY FOR A GIVEN USER\n*\n* --------------------------------------------------------------------\n         DS    0H\nESTAEON  SECTION\n         L        R8,=V(STAEEXIT)     POINT AT THE ESTAE EXIT ROUTINE\n         ESTAE    (R8),CT             PUT ON ESTAE\n         LTR      R15,R15             WENT ON OK?\n         BZ       ESEXIT              GO RETURN TO CALLER\n         ABEND    1213,DUMP           TAKE A USER 1213 ABEND WITH DUMP\nESEXIT   SECEXIT                      RETURN TO CALLER\n TITLE 'SYNCRECO - RECOVERY POINT FROM AN ERROR DURING A COPY PROCESS'\n         DS    0H\nSYNCRECO SECTION\n* --------------------------------------------------------------------\n* THIS SECTION IS ENTERED IN TWO DIFFERENT WAYS:\n*\n*  IT IS ENTERED FROM THE USRPROC MAINLINE TO STORE STATUS, IE) TO\n*    TAKE A SYNC POINT WHICH HERE MEANS TO SAVE ALL REGS.\n*\n*  IT IS ALSO ENTERED AFTER AN ERROR CONDITION TO RESYNCRONIZE\n*    PROCESSING. IE) THE ESTAE EXIT ROUTINE JUMPS TO LABEL STAERTRY\n*    DIRECTLY AFTER RESTORING ALL REGISTERS EXCEPT R7 TO WHAT THEY WERE\n*    THE LAST TIME THIS SECTION WAS ENTERED NORMALLY.\n* --------------------------------------------------------------------\n         LA       R7,0                INIT R7 TO SAY NOT IN ABEND\n         STM      R0,R15,SYNCSAVE     SAVE THE REGISTERS AS THEY ARE\n         B        OVERSAVE\n         ENTRY    SYNCSAVE\nSYNCSAVE DC       16F'0'              THE RECOVERY SAVE AREA\nOVERSAVE DS       0H\n         ENTRY    STAERTRY\nSTAERTRY DS       0H                  THIS IS THE ESTAE RETRY LABEL\n         LA    R15,0              RC=0\n         LTR      R7,R7          TEST R7 TO SEE IF WE CAME FROM RETRY\n         BZ       SYNCRECE       IF 0 THEN WE DID NOT COME FROM RETRY\n*\n* WE ARE IN RETRY, IE) THE ESTAE EXIT SENT US HERE\n* WE KNOW BECAUSE IT SET R7 IN THE RUB TO NON-ZERO EG) X'FFFFABED'\n*\n* USE OLCMSG TO PUT OUT MSG TO USER THAT WE ARE SKIPPING HIS DATASET.\n* ABEND CODE IS IN ABENDCDE BELOW, THE ADDRESS OF ABEND IS IN ABENDADR\n*\n* WE SET THE RECOVERY FLAG ON TO TELL MAINLINE TO SKIP THE DATASET\n         L     R5,=V(RECOFLG)          GET ADDRESS OF RECOVERY FLG\n         OI    0(R5),RECOYES           SET TO IN_RECOVERY\n         UNPK  OLC019W(16),ABENDCDE(8) MAKE HEX RETURN CODE PRINTABLE\n         TR    OLC019W(17),HEXTRANA\n         MVC   OLC019IN(8),OLC019W+1   MOVE ADDRESS OF ABEND TO MSG\n         MVC   OLC019ER(3),OLC019W+11  MOVE ABEND CODE TO MSG\n         MVC   OLC019CS(8),ABENDCST    MOVE CSECT NAME TO MSG\n         OLCMSG OLC019\nSYNCRECE SECEXIT                      RETURN TO CALLER\n         SPACE 1\nOLC019   DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    C'DSB019 - ABEND '\nOLC019ER DC    CL3' ',C', OFF='\nOLC019IN DC    CL8' ',C' IN CSECT '\nOLC019CS DC    CL8' '\n         DC    C' WHILE COPYING DATASET'\n         ORG   OLC019+75\n         DC    CL5'ERROR'\n         ORG   OLC019+81\nOLC019W  DC    XL17'00'\nHEXTRANA EQU   *-240\n         DC    C'0123456789ABCDEF'\n         ENTRY ABENDCDE\n         DS    0D\nABENDCDE DC    XL8'00'     ABEND CODE AND ADDRESS SET BY ESTAE EXIT\nABENDCST DC    CL8'??'     ABEND CSECT NAME..MUST FOLLOW ABENDCDE\n TITLE 'BUILDDSN - ISOLATE DSNAME FROM CONTROL CARD'\n*\n*  ISOLATE DSNAME FROM CONTROL CARD'\n*\n         DS    0H\nBUILDDSN SECTION\n*\n*\n*\n*              FIND LTH OF DSN\n*\n         SR    R5,R5              R5 = 0\n         LA    R6,USRDSN          R6 -> TO DSN\nLOOP2    DS    0H\n         CLI   0(R6),C' '         AT END OF DSN ?\n         BE    OUT2               YES, MOVE IT TO SVC 99 FIELD\n         LA    R6,1(0,R6)         ADD 1 DSN POSITION REG\n         LA    R5,1(0,R5)         ADD 1 TO LTH CTR\n         B     LOOP2              LOOK AT NEXT CHAR\n         SPACE 1\nOUT2     DS    0H\n         CH    R5,=H'44'          LTH OVER 44?\n         BH    BADCARD            YES\n*\n         CLI   USRDSN,C' '        FIRST CHAR A BLANK?\n         BE    NODSNAME\n         L     R2,=V(DYNT1LTH)    R2 -> DSNAME LTH FIELD\n         STH   R5,0(0,R2)         STORE LENGTH FOR DYNALLOC\n         LA    R2,USRDSN          R2 -> TO START OF DSNAME\n         AR    R2,R5              R2 -> TO END OF DSNAME\n         LH    R3,=H'44'          CALC LENGTH OF AREA TO BLANK\n         SR    R3,R5              LENGTH OF REST OF DSN AREA\n         BNP   NOCLEAR            NOTHING TO CLEAR\n         BCTR  R3,0               -1 TO MAKE HEX\n         BCTR  R3,0               -1 MORE JUST BECAUSE\n         EX    R3,BUILDCLR        CLEAR OUT REST OF DSN AREA\n         SPACE 1\nNOCLEAR  DS    0H\n         LA    R15,USRDSN         R15 -> TO DSN\n         ST    R15,TCAMDSN        PUT A(DSN) INTO TCAM LIST\n         L     R2,=V(DYNT1DSN)    R2 -> DSNAME FIELD\n         MVC   0(44,R2),0(R15)    PUT DSN INTO DYNALLOC FIELD\n         MVC   TVOL,=CL6' '       BLANK OUT TVOL\n         LOCATE TCAML             FIND IT\n         LTR   R0,R15             LOCATE OK?\n         BZ    CHKMIG             YES, SEE IF MIGRATED\n         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM\n         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?\n         BNE   NOTCAT             NO, DON'T SAY CREATING...\n         MVC   OLC043A,OLC043C    NO, SAY CREATING DATASET\n         B     NOTCAT             THEY BETTER HAVE GIVEN A VOLSER\n*\n*              SEE IF DATASET IS MIGRATED\n*\n         SPACE 1\nCHKMIG   DS    0H\n         MVC   OLC043A,OLC043P    SAY PROCESSING DATASET\n         CLC   =C'MIGRAT',TVOL    IS DSN MIGRATED?\n         BNE   NOTMIG             NO\n*\n*              BEFORE WE CONTINUE, RECALL THE DATASET....\n*\n*        CLC   OLC008M,=CL40' RECALLING' BEEN HERE ALREADY?\n*        BE    NOVOL2             YES, DON'T RECALL AGAIN....\n*        MVC   OLC043M,=CL44' RECALLING DATASET FROM MIGRAT'\n*        OLCMSG OLC043\n*\n*  GIVE ARCHRCAL ITS OWN SAVE AREA AND CHAIN IT TO THE SUPERV.\n*  SAVE AREA. OTHERWISE, IT WILL DESTROY OUR IMS TYPE\n*  SAVE AREA CHAIN\n         ST      R13,HSMSA           OUR SAVE AREA POINTER\n         LA      R13,HSMSAVE         GIVE IEBCOPY ITS OWN\n         L       R5,=V(SAVE)         GET ADDR OF OUR SAVE AREA\n         L       R6,4(,R5)           GET ADDR OF SUP'S SAVE AREA\n         ST      R6,HSMSAVE+4        CHAIN SUP'S SAVEAREA TO IEBSAVE\n         L     R3,=V(USRDSN)      GET ADDRESS OF DISK DSNAME\n         ARCHRCAL DSN=(R3),WKAREA=HSMWORK,WAIT=YES\n         L        R13,HSMSA          PLUG BACK INTO OUR SAVE AREA CHAIN\n         MVI   OLC033F,X'01'      SAY WE RECALLED THE DSN...\n         LTR   R15,R15            WAS RECALL SUCCESSFUL?\n         BZ    NOCLEAR            YES, GO GET THE REAL VOLSER...\n         SPACE 1\nNOTMIG   DS    0H\n         MVC   INKEY,USRDSN       PUT DSN INTO OBTAIN KEY\n         OBTAIN INCAM             GET FORMAT 1\n         LTR   R0,R15             OBTAIN OK?\n         BZ    OBTNOK             YES\n         L     R15,=V(SYSDSORG)   R15 -> TO DSORG FIELD\n         MVC   0(2,R15),=X'0008'  ASSUME IT IS A VSAM DATASET\n         B     NOTCAT             AS WE CAN'T DETERMINE DSORG\n         SPACE 1\nOBTNOK   DS    0H\n         USING IECSDSL1,R2             ESTABLISH DSCB ADDRESSABILITY\n         LA    R2,INDSCB               POINT TO DSCB\n         CLI   DS1FMTID,C'1'           IS THIS A FORMAT 1 DSCB\n         BNE   NOTCAT             NO, CAN'T DETERMINE DSORG\n         SPACE 1\n         L     R15,=V(SYSDSORG)   R15 -> TO DSORG FIELD\n         MVC   0(2,R15),DS1DSORG  PUT DSORG INTO FIELD\n         DROP  R2                 DROP DSCB BASE\n         SPACE 1\nNOTCAT   DS    0H\n         MVC   OLC043M,USRDSN     MOVE DSN INTO MSG\n         OLCMSG OLCBLNK           PRINT A BLANK LINE BEFORE OLC043\n         TM    OLC033F,X'01'      DID WE RECALL THE DSN?\n         BZ    NORCAL             NO, DON'T PRINT MESSAGE\n         MVI   OLC033F,X'00'      CLEAR FLAG\n         OLCMSG OLC033            SAY IT WAS RECALLED\n         SPACE 1\nNORCAL   DS    0H\n         OLCMSG OLC043            PRT OUT THE DSN IN OLCPRINT AND WTL\n         SR    R15,R15            NO ERRORS\n         B     BUILDRET\n         SPACE 1\nBUILDCLR MVC   1(0,R2),0(R2)      CLEAR REST OF CARD\n         SPACE 1\nNODSNAME MVC   OLC002M,USRDSN     DISPLAY CARD IN ERROR\n         OLCMSG OLC002\n         B     BADRC1             INDICATE MINOR ERROR\n         SPACE 1\nBADCARD  DS    0H\n         MVC   OLC003M,USRDSN     DISPLAY CARD IN ERROR\n         OLCMSG OLC003\n         SPACE 1\nBADRC1   DS    0H\n         LA    R15,4              INDICATE A MINOR ERROR\nBUILDRET SECEXIT                  RETURN TO CALLER\n         SPACE 2\n*\n* BUILDRET DATA:\n*\n         SPACE 2\nHSMSA    DC       F'0'            SAVE OUR S.A. POINTER OVER ARCHRCAL\nHSMSAVE  DC       18F'0'          SPECIAL SAVE AREA FOR ARCHRCAL\n*\n*        TCAM   LIST\nTCAML    DS     0F\nTCFLGS   DC     X'44000000'              TCAM ON DSN\nTCAMDSN  DC     A(0)                     A(DSN)\n         DC     A(0)                     VOL POINTER\n         DC     A(TWORK)                 A(256 BYTE WORK AREA)\n         DS    0D                 PUT ON DOUBLE WORD BOUNDARY\nTWORK    DS     0CL256\nVOLCNT   DC     H'0'                     VOL COUNT\nDEVTYP   DC     XL4'00'                  DEVICE TYPE\n         ENTRY TVOL\nTVOL     DC     CL6' '                   FIRST VOL SER\n         DC     CL244' '                 REST OF TCAML DATA\n         DC     CL12' '                  REST OF TCAML DATA\n         SPACE 2\nHSMWORK  DS    0D                 PUT HSM WORAKAREA ON DOUBLE WORD\n         DC    XL200'00'\n*\n* DSCB I/O AREA AND CONTROL BLOCKS\n*\nINDSCB   DS    0C\nINKEY    DC    CL44' '\nDSCBIN   DC    XL140'00'\n         SPACE\nINCAM    CAMLST SEARCH,INKEY,TVOL,DSCBIN\n         SPACE 3\n         DC    CL81' '\n         ORG   *-81\nOLC002   DS    0A\n         DC    AL1(MSGPRT)\n         DC    C'DSB002 - NO DSNAME ON CONTROL CARD: '\nOLC002M  DC    CL44' '\n         ORG   OLC002+75\n         DC    CL5'ERROR'\n         ORG   OLC002+81\n         DC    CL81' '\n         ORG   *-81\nOLC003   DS    0A\n         DC    AL1(MSGPRT)\n         DC    C'DSB003 - INVALID CONTROL CARD:'\nOLC003M  DC    CL44' '\n         ORG   OLC003+75\n         DC    CL5'ERROR'\n         ORG   OLC003+81\n*\nOLC043   DC    AL1(MSGPRT)\n         DC    C'DSB043 - '\nOLC043A  DC    C'PROCESSING '\n         DC    C'DATASET = '\nOLC043M  DC    CL44' '\n         DC    CL(81-(*-OLC043))' '\n*\nOLC043C  DC    C'CREATING   '\nOLC043P  DC    C'PROCESSING '\n*\nOLC033F  DC    X'00'              01 IF RECALL DONE....\nOLC033   DC    AL1(MSGPRT)\n         DC    CL80'DSB033 - DATASET RECALLED FROM MIGRAT'\n         ENTRY OLCBLNK\nOLCBLNK  DC    AL1(MSGPRT)\n         DC    CL81' '\n         ENTRY USRDSN,USRVOL\nUSRDSN   DS    0CL200             BUFFER FOR INPUT/RESTORE CARD\n         DC    CL44' '            DATASET NAME\n         DC    C' '               BLANK\nUSRVOL   DC    CL6' '             DATASET VOLUME\n         DC    CL(200-(*-USRDSN))' '\n         SPACE 1\n TITLE 'DYNALLOC - DYNAMICALLY ALLOCATE A DATASET'\n*\n         DS    0H\nDYNALLOC SECTION\n*\n         LA    R2,DYNRB1          R2 -> TO SVC 99 PARMS\n         USING S99RB,R2           SET BASE\n         XC    S99RSC,S99RSC      CLEAR OUT RETURN AREA\n         SR    R1,R1              CLEAR R1\n         ST    R1,DYNTUPLB        ASSUME NO VOLSER\n         MVC   DYNTVOL6(6),BLANK  CLEAR VOLSER FIELD\n         MVC   DYNTVOL4(6),BLANK  CLEAR RETURNED VOLSER FIELD\n         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM\n         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?\n         BE    RSTOR2             YES, DON'T USE A VOL\n         L     R14,=V(SYSDSORG)   R14 -> TO SYSUT1 DSORG\n         CLC   0(2,R14),=X'0008'  IS IT VSAM?\n         BE    NOVOL0             YES, DON'T USE A VOL\n         L     R3,=V(TVOL)        GET ADDRESS OF LOCATE VOLSER\n         MVC   DYNTVOL6(6),0(R3)  PUT IT IN TEXT UNIT\n         B     NOVOL0             ON WE GO\n         SPACE 1\nRSTOR2   DS    0H\n         MVI   SYSNUM,C'2'        CHANGE SYSUT TO 2\n         SPACE 1\nNOVOL0   DS    0H\n         MVC   OLC006M(ALOCVOLL),BLANK CLEAR VOL MSG\n         CLI   DYNTVOL6,C' '      IS THERE A VOLSER?\n         BE    NOVOL1             NO\n         LA    R1,DYNTUNT6        YES, SET TEXT UNIT ADDRESS\n         ST    R1,DYNTUPLB        SAVE ADDRESS\n         MVC   ALOCVOL,DYNTVOL6   PUT VOLSER INTO MSG\n         MVC   OLC006M(ALOCVOLL),ALOCVOLM ''\n         SPACE 1\nNOVOL1   DS    0H\n         LA    R1,DYNPTR1            POINTER TO PARM LIST FOR DYNALLOC\n         DYNALLOC\n         LTR   R10,R15               SAVE RET CODE OVER MSG PRINT\n         BZ    DYNARET               RETURN IF NO ERRORS\n         DC    X'0700'            ZAP TO ABEND\n         CLI   DYNTVOL4,C' '      DID DYNALLOC GET A VOLSER?\n         BE    NOVOL2             NO\n         MVC   ALOCVOL,DYNTVOL4   PUT VOLSER INTO MSG\n         MVC   OLC006M(ALOCVOLL),ALOCVOLM ''\n         SPACE 1\nNOVOL2   DS    0H\n         OLCMSG OLC006\n         UNPK  OLC007W(9),S99RSC(5)  MAKE HEX RETURN CODE PRINTABLE\n         TR    OLC007W(8),HEXTRANS\n         MVC   OLC007ER(4),OLC007W   MOVE ERROR CODE TO TEXT LINE\n         MVC   OLC007IN(4),OLC007W+4 MOVE INFO CODE TO TEXT LINE\n         OLCMSG OLC007\n         CLC   S99ERROR,=X'020C'     DS UNAVAILBLE FOR DISP=SHR\n         BE    DISPOLD\n         CLC   S99ERROR,=X'0210'     DS UNAVAILBLE FOR DISP=SHR\n         BE    DISPOLD\n         CLC   S99ERROR,=X'0218'     VOLUME NOT MOUNTED\n         BE    NOVOL\n         CLC   S99ERROR,=X'0220'     VOLUME NOT MOUNTED\n         BE    NOVOL\n         CLC   S99ERROR,=X'1708'     DS NOT FOUND\n         BE    CHKRSTOR              YES\n         CLC   S99ERROR,=X'6708'     DS NOT FOUND ON CAT VOL\n         BNE   DYNRETRC           NO, JUST SET RETURN CODE\n         SPACE 1\nCHKRSTOR DS    0H\n         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM\n         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?\n         BNE   NOTFOUND           NO, SAY NOT FOUND\n         LA    R10,99             SAY WE MUST TRY A CREATE ALLOC\n         B     DYNRETRC           RETURN TO CALLER\n         SPACE 1\nNOTFOUND MVC   OLC008M,=CL40' DATASET DOES NOT EXIST'\n         B     PRTOLC8\n         SPACE 1\nDISPOLD  MVC   OLC008M,=CL40' DATASET ALLOCATED TO SOME OTHER JOB'\n         B     PRTOLC8\n         SPACE 1\nNOVOL    MVC   OLC008M,=CL40' DATASET ON AN OFFLINE VOLUME'\n         SPACE 1\nPRTOLC8  OLCMSG OLC008\n         SPACE 1\nDYNRETRC LR    R15,R10               RESTORE RETURN CODE\n         SPACE 1\nDYNARET  SECEXIT\n         SPACE 2\n*\n* DYNALLOC  DATA:\n*\n         ENTRY BLANK\nBLANK    DC    CL80'  '\n         SPACE 1                                                    RH\nOLC008   DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    C'DSB008 - PROBABLE CAUSE: '\nOLC008M  DC    CL40' '\n         ORG   OLC008+75\n         DC    CL5'ERROR'\n         ORG   OLC008+81\n         ENTRY OLC007,OLC007ER,OLC007IN,OLC007W,HEXTRANS\nOLC007   DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    C'DSB007 - ERROR REASON CODE: '\nOLC007ER DC    CL4' ',C'   INFORMATION REASON CODE: '\nOLC007IN DC    CL4' ',CL5' '\n         ORG   OLC008+75\n         DC    CL5'ERROR'\n         ORG   OLC007+81\nOLC007W  DC    XL9'00'\nHEXTRANS EQU   *-240\n         DC    C'0123456789ABCDEF'\nOLC006   DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    C'DSB006 - ALLOCATE FAILED FOR DSN '\nOLC006M  DC    C' '               VOLSER IF VOL SER SPECIFIED\n*LC006M  DC    CL40' '            ONLY USE 1ST 40 BYTES OF DSN\n         ORG   OLC006+75\n         DC    CL5'ERROR'\n         ORG   OLC006+81\n         SPACE 1\nALOCVOLM DC    C' ON VOLUME '\nALOCVOL  DC    CL6' '\nALOCVOLL EQU   *-ALOCVOLM\n         SPACE 2\n         AGO   .DYN1\n         DS    0F                 PUT ON FULLWORD BOUNDARY\nDYNPTR1  DC    0F'0',X'80',AL3(DYNRB1)\nDYNRB1   DC    0F'0',AL1(20,S99VRBAL,S99NOMNT,0),AL4(0,DYNTUPLA,0,0)\nDYNTUPLA DC    AL4(DYNTUNT1,DYNTUNT2,DYNTUNT3),AL4(DYNTUNT4)\nDYNTUPLB DC    A(DYNTUNT6)\n         DC    X'80',AL3(DYNTUNT5)\n*YNTUNT1 DC    0F'0',AL2(DALDSNAM,1,0) DYNAMIC ALLOCATION TEXT FIELD\n         DS    0F                 PUT ON FULLWORD BOUNDARY\nDYNTUNT2 DC    AL2(DALSTATS,1,1),X'08'  DISP=SHR\n         DS    0F                 PUT ON FULLWORD BOUNDARY\nDYNTUNT3 DC    AL2(DALDDNAM,1,6),C'SYSUT'\nSYSNUM   DC    C'1'\n         ENTRY DYNTUNT4\n         DS    0F                 PUT ON FULLWORD BOUNDARY\nDYNTUNT4 DC    AL2(DALRTVOL,1,6),C'      '    RETURNED VOLSER\nDYNTVOL4 EQU   DYNTUNT4+6\n         DS    0F                 PUT ON FULLWORD BOUNDARY\nDYNTUNT5 DC    AL2(DALRTORG,1,2),AL2(0)\n         ENTRY SYSDSORG\nSYSDSORG EQU   DYNTUNT5+6\n         DS    0F                 PUT ON FULLWORD BOUNDARY\nDYNTUNT6 DC    AL2(DALVLSER,1,6),CL6' ' VOLSER UNIT,VOLSER\nDYNTVOL6 EQU   DYNTUNT6+6\n.DYN1    ANOP\n*\n*              CONTROL BLOCKS FOR  SVC 99 (DYNALLOC)\n*\n         SPACE 1\n         DS    0F                 PUT ON FULLWORD BOUNDARY\nDYNPTR1  DC    XL1'80'\n         DC    AL3(DYNRB1)\nDYNRB1   DS    0F\nDYNRBLN  DC    AL1(20)\nDYNVERB  DC    AL1(1)             ALLOCATE BY DSNAME\nDYNFLAG1 DC    XL2'2000'          DON'T MOUNT VOLS OR CONSIDER OFFLINES\nDYNERROR DC    AL2(0)\nDYNINFO  DC    AL2(0)\nDYNTXTPP DC    A(DYNTUPLA)\nDYNRES1  DC    A(0)\nDYNFLAG2 DC    A(0)\n         SPACE 1\nDYNTUPLA DS    0F\n         DC    A(DYNTUNT1)        DSNAME\n         DC    A(DYNTUNT2)        DISP\n         DC    A(DYNTUNT3)        DDNAME\n         DC    A(DYNTUNT4)        RETURNED VOLSER\n         SPACE 1\nDYNTUPLB DC    A(DYNTUNT6)        VOLSER UNIT\n         DC    XL1'80'            END OF PARMS FOR DYNALLOC\n         DC    AL3(DYNTUNT5)      DSORG\n         SPACE 1\n*\n         ENTRY DYNTUNT1,DYNT1LTH,DYNT1DSN\nDYNTUNT1 DS    0F\n         DC    AL2(2)             ALLOCATE BY DSNAME\n         DC    AL2(1)\n         DS    0C\nDYNT1LTH DC    AL2(00)            LTH OF DSNAME\nDYNT1DSN DC    CL44' '            REQUEST QUEUE DSNAME\n         SPACE 1\nDYNTUNT2 DS    0F\nTUKEY62  DC    XL2'0004'          STATUS OF UNIT\nTUNUM62  DC    AL2(1)\nTUENT62  DS    0C\nTULNG62  DC    AL2(1)             LTH OF STATUS\nTUPAR62  DC    X'08'              STATUS = SHR\n*        DC    X'02'              STATUS = MOD\n*        DC    X'04'              STATUS = NEW\n*        DC    X'01'              STATUS = OLD\n         SPACE 1\nDYNTUNT3 DS    0F\nTUKEY23  DC    AL2(DALDDNAM)      ALLOCATE BY DDNAME (1)\nTUNUM23  DC    AL2(1)\nTUENT23  DS    0C\nTULNG23  DC    AL2(6)             LTH OF DDNAME\nTUPAR23  DC    CL5'SYSUT'         DDNAME\nSYSNUM   DC    CL1'1'\n         DC    CL2' '             MAKE DDNAME 8 LONG...\n         SPACE 1\n         ENTRY DYNTUNT4\n         DS    0F                 PUT ON FULLWORD BOUNDARY\nDYNTUNT4 DS    0F\n         DC    AL2(DALRTVOL)      SAY RETURN VOLSER\n         DC    AL2(1)\nDYNTVL4L DC    AL2(6)             LTH OF RETURNED VOLSER\nDYNTVOL4 DC    CL6' '             VOLSER RETURNED\n         SPACE 1\n         DS    0F                 PUT ON FULLWORD BOUNDARY\nDYNTUNT5 DC    AL2(DALRTORG,1,2),AL2(0)\n         ENTRY SYSDSORG\nSYSDSORG EQU   DYNTUNT5+6\n*\n         DS    0F                 PUT ON FULLWORD BOUNDARY\n*                                 VOLSER UNIT,VOLSER\nDYNTUNT6 DS    0F\n         DC    AL2(DALVLSER)      SAY UNIT ID\n         DC    AL2(1)\nDYNTVL6L DC    AL2(6)             LTH OF UNIT\nDYNTVOL6 DC    CL6' '             UNIT NAME ?\n         SPACE 1\nTUNIT77  DS    0C\nTUKEY77  DC    XL2'0005'          STATUS 2..DISP=(OLD,KEEP)\nTUNUM77  DC    AL2(1)\nTUENT77  DS    0C\nTULNG77  DC    AL2(1)             LTH OF STATUS 2\nTUPAR77  DC    X'08'              DISP= KEEP\n         SPACE 1\n.DYN2    ANOP\n         SPACE 2\n TITLE 'EXPALLOC - ALLOCATE FIRST OUTPUT DATASET WITH EXPDT'\n*                  USING DSNAME FROM JCL\n*\n         DS    0H\nEXPALLOC SECTION\n*\n*\n*              FIND LTH OF DSN\n*\n         SPACE 1\nLTHLOOPE DS    0H\n         SR    R5,R5              R5 = 0\n         L     R6,=V(FIRSTDSN)    R6 -> WHERE DSN GETS SAVED\n         MVC   INFO03M,0(R6)      PUT IT IN MSG\n         SPACE 1\nLOOP3E   DS    0H\n         CLI   0(R6),C' '         AT END OF DSN ?\n         BE    OUT3E              YES, MOVE IT TO SVC 99 FIELD\n         LA    R6,1(0,R6)         ADD 1 DSN POSITION REG\n         LA    R5,1(0,R5)         ADD 1 TO LTH CTR\n         B     LOOP3E             LOOK AT NEXT CHAR\n         SPACE 1\nOUT3E    DS    0H\n         L     R6,=V(TULNG1)      R6 -> TO SVC99 FIELD\n         STH   R5,0(0,R6)         SET UP LTH FIELD FOR SVC99\n*\n*              ADD 1 TO SEQ NBR\n*\n         L     R6,=V(TUPAR7)      R6 -> TO SVC99 FIELD\n         LH    R5,0(0,R6)         R5 = SEQ NBR\n         LA    R5,1(0,R5)         R5 = NEXT SEQ NBR\n         STH   R5,0(0,R6)         SAVE NEXT SEQ NBR\n*\n*              MODIFY THE DCB\n*\n*\n*        COPY SYSUT2 DCB/JFCB INFO\n*\n*                                 NO, TREAT AS PS\n*\n         SPACE 1\n         L     R4,=V(SYSUT2)      R4 -> TO SYSUT2 DCB\n         USING IHADCB,R4          SET DCB DSECT\n         MVC   DCBBLKSI,=H'800'   SET SYSUT2 BLKSIZE TO 800\n         SPACE 1\nBLKSIOKE DS    0H\n         MVC   DCBLRECL,=H'80'    SYSUT2 LRECL = 80\n         SPACE 1\nLRECOKE  DS    0H\n         MVC   DCBRECFM,=X'90'    SET SYSUT2 RECFM TO FB\n         MVI   DCBDSORG,X'40'     SET SYSUT2 DSORG TO PS\n         DROP  R4\n*                                                                   RH1\n         SPACE 1\nDCBSETE  DS    0H\n*\n*              MODIFY THE JFCB\n*\n         L     R2,=V(UT2JFCB)     R2 -> TO SYSUT2 JCFB              RH\n         USING IHAJFCB,R2\n*\n*        MVC   JFCBDSNM,TUPAR1    PUT DSN IN\n*        MVC   JFCBFLSQ,TUPAR7    PUT NEW SEQ NBR IN\n*        MVC   JFCBVLSQ,VOLSEQ    PUT VOLUME SEQUENCE NBR IN\n         MVI   JFCBIND2,X'C0'     PUT DISP=NEW IN\n*\n         AGO   .CAT1\n*\n*              THIS DOESN'T WORK. ..OCT 1/98...\n*\n         L     R6,=V(FREEFLAG)    R6 -> TO FREEFLAG\n         TM    0(R6),LASTDSN      WRITING LAST FILE?\n         BO    OUT3E2             YES, JFCB DSN IS OKAY\n         L     R6,=V(TULNG1)      R6 -> TO SVC99 FIELD\n         LH    R5,0(0,R6)         R5 = 1ST DSN LTH\n         LA    R1,JFCBDSNM        R1 -> AT JFCB DSNAME\n         AR    R1,R5              R1 -> AT END OF NAME\n         MVC   0(5,R1),=CL5'.F001'\n         LA    R5,5(0,R5)         ADD 5 TO LTH CTR\n         STH   R5,0(0,R6)         SET UP LTH FIELD FOR SVC99\n         SPACE 1\nOUT3E2   DS    0H\n         L     R6,=V(FREEFLAG)    R6 -> TO FREEFLAG\n         TM    0(R6),LASTDSN      WRITING LAST FILE?\n         BZ    JFCSETE            NO, JFCB DSN IS OKAY\n         L     R6,=V(FIRSTDSN)    R6 -> WHERE 1ST DSN WAS SAVED\n         MVC   JFCBDSNM,0(R6)     PUT IT IN JFCB\n*        MVC   JFCBDSNM,INFO03M   PUT DSN IN\n         L     R6,=V(TUPAR7)      R6 -> TO SVC99 FIELD\n         LH    R5,0(0,R6)         R5 = SEQ NBR\n         STH   R5,JFCBFLSQ        PUT NEW SEQ NBR IN\n         MVI   JFCBIND2,X'80'     PUT DISP=MOD IN\n*\nJFCSETE  DS    0H\n.CAT1    ANOP\n*\n*              ALSO PUT BLKSIZE, LRECL AND RECFM IN JFCB\n*\n         L     R4,=V(SYSUT2)      R4 -> TO SYSUT2 DCB\n         USING IHADCB,R4          SET DCB DSECT\n         MVC   JFCBLKSI,DCBBLKSI  SET JFCB BLKSIZE\n         MVC   JFCLRECL,DCBLRECL  SET JFCB LRECL\n         MVC   JFCRECFM,DCBRECFM  SET JFCB RECFM\n         DROP  R4\n         AGO   .CAT2\n*                                                                   RH\n*                  THIS IS CODE TO DUMP CORE                 DEBUG  RH\n*                                                                   RH\n         L     R2,=V(DEBUG)     IS DEBUG IN EFFECT\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?\n         BZ    OPENINE            NO\n         DROP  R2                 DROP BASE...\n         SPACE 1                                             DEBUG  RH\n         PRINT   GEN\n         L     R2,=V(SYSUT2)      R2 -> TO SYSUT2 DCB        DEBUG  RH\n         HDUMP OUTDCB,R4,100,NOTOPEN,OPEN,V=YES,             DEBUG  RH +\n               TITLE='SYSUT2 DCB AT EXPALLOC',GENDCB=NO\n         L     R2,=V(UT2JFCB)     R2 -> TO SYSUT2 JCFB       DEBUG  RH\n         HDUMP OUTDCB,R2,200,OPEN,OPEN,                      DEBUG  RH +\n               TITLE='SYSUT2 JFCB AT EXPALLOC'\n         HDUMP OUTDCB,0,0,OPEN,CLOSE,  DUMP REGS ONLY        DEBUG  RH +\n               TITLE='REGS AT EXPALLOC'\n         SPACE 1                                             DEBUG  RH\n         PRINT NOGEN\n*                                                                   RH\n*                  THIS IS END OF CODE TO DUMP CORE          DEBUG  RH\n*                                                                   RH\n         SPACE 1\nOPENINE  DS    0H                                                   RH\n.CAT2    ANOP\n         SPACE 1\n         OPEN  ((4),(OUTPUT)),TYPE=J   OPEN IT\n         L     R1,=V(SYSUT2)      R1 -> TO DCB\n         USING IHADCB,R1\n         TM    DCBOFLGS,DCBOFOPN            DID IT OPEN ?\n         BZ    FAIL8E             NO, GO TO ERR RTN\n*\n*              IN CASE WE SWITCHED TO ANOTHER UNIT, CHAIN THRU THE\n*              DEB TO THE UCB AND  SAVE THE UNIT NAME\n*\n         L     R4,DCBDEBAD        R4 -> TO THE DEB\n         LA    R4,0(0,R4)         CLEAR FLAG BYTE\n         USING DEBBASIC,R4        SET DEB BASE\n         L     R4,DEBSUCBA        R4 -> TO THE DEB UCB\n         LA    R4,0(0,R4)         CLEAR FLAG BYTE\n         DROP  R4                 DROP DEB BASE\n         USING UCBOB,R4           SET UCB BASE\n         L     R6,=V(TUPAR6)      R6 -> TO SVC99 FIELD\n*        MVC   0(3,R6),UCBNAME    SAVE THIS UNIT ADDRESS\n*\n*   THE ONLY PROBLEM IS THAT THE ABOVE CODE DOESN'T WORK FOR\n*   4 DIGIT UCB ADDRESSES, AS THE UCBNAME FIELD CONTAINS 'UCB'.\n*   SO WE MUST CONVERT THE REAL UCB ADDRESS FROM THE HEX ADDRESS\n*   AT OFFSET +4 IN THE UCB...FEB 10/99\n*\n*\n*   ALSO, IF YOU ARE ALLOCATING BY UNIT, IT MUST BE PRECEDED BY /   RH\n*              ..EG../190A.....\n*\n*              CONVERT UCB ADDRESS FOR UNIT NAME\n*\n         UNPK  0(5,R6),4(3,R4)    UNPACK 4 DIGIT UNIT ADDRESS\n         MVI   4(R6),X'EF'        TRANSLATES TO BLANK\n         TR    0(5,R6),TRTAB2-239 TRANSLATE TO DISPLAY\n         MVC   5(3,R6),=CL5' '    BLANK OUT REST OF UNIT NAME\n*\n         DROP  R1,R4\n*\n         L     R4,=V(SYSUT2)      R4 -> TO SYSUT2 DCB\n         PUT   (R4),DUMMYREC      WRITE RECORD\n*\nCLOSFIL  DS    0H\n*        L     R4,=V(SYSUT2)      R4 -> TO SYSUT2 DCB\n         CLOSE ((4))              CLOSE IT                          RH\n         USING IHADCB,R4          SET R4 AS DCB DSECT\n         L     R15,DCBBUFCB       R15 = A(BUFFER)\n         BCTR  R15,0              -1\n         LTR   R15,R15            IS THERE A BUFFER?\n         BZ    NOPOOL4E           NO\n         DROP  R4                 DROP R4 AS DCB DSECT\n         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB\n*                                 IBM DON'T\n         SPACE\nNOPOOL4E DS    0H\n*        L     R2,=V(FREEFLAG)    R2 -> TO FREEFLAG\n*        TM    0(R2),LASTDSN      WRITING LAST FILE?\n*        BO    EXPARET            YES, END OF EXPALLOC\n*\n*              MODIFY THE JFCB AGAIN. IF THERE IS NO VOLSER,\n*              READ IT AGAIN INTO  A DIFFERENT AREA AND SAVE THE\n*              VOLSER IN THE FIRST JFCB.\n*\n*        LA    R2,UT2JFCB         R2 -> TO SYSUT2 JCFB              RH\n         USING IHAJFCB,R2         SET JFCB BASE AGAIN\n         CLI   JFCBVOLS,C' '      IS THERE A VOLSER?\n         BE    BADVOLE            NO, DO RDJFCB AGAIN\n         CLI   JFCBVOLS,C'A'      IS IT ALPHANUMERIC?\n         BL    BADVOLE            NO, DO RDJFCB AGAIN\n         CLI   JFCBVOLS,C'9'      IS IT ALPHANUMERIC?\n         BNH   JFCBOKE            YES, DON'T GET JFCB AGAIN\n         SPACE 1\nBADVOLE  DS    0H\n         L     R4,=V(UT2JFCB2)    R4 -> TO JFCB AREA 2\n         L     R15,=V(JFCBXLSJ)   R15 -> TO JFCB EXIT LIST\n         STCM  R4,7,0(R15)        PUT IT IN EXIT LIST\n*        XC    0(176,R4),0(R4)    MAKE SURE JFCB IS CLEAN\n         RDJFCB SYSUT2            GET THE SYSUT2 JFCB               RH\n         L     R2,=V(UT2JFCB)     R1 -> TO JFCB AREA\n         L     R1,=V(JFCBXLSJ)    R15 -> TO JFCB EXIT LIST\n         STCM  R2,7,0(R1)         PUT IT IN EXIT LIST\n         LTR   R15,R15            GET IT?                           RH\n         BNZ   FAIL6E             IF NOT  NO BLKSIZE                RH\n         MVC   JFCBVOLS,JFCBVOLS-IHAJFCB(R4) PUT VOLSER IN JFCB 1\n         CLI   JFCBVOLS,C' '      IS THERE A VOLSER?\n         BE    UT2ABENE           NO, ABEND\n         SPACE 1\nJFCBOKE  DS    0H\n         MVC   INFO04B,JFCBVOLS   PUT VOLSER IN MSG\n         L     R3,=V(OLCBLNK)     R3 -> TO BLANKS\n         OLCMSG 0(0,R3)           PRINT A BLANK LINE\n         OLCMSG   INFO01          PRINT MSG\n         OLCMSG   INFO02          PRINT MSG\n         OLCMSG   INFO03          PRINT MSG\n         OLCMSG   INFO04          PRINT MSG\n         AGO   .ESKIP1\n*\n*              IF WE ARE PAST THE  1ST FILE, WE MUST OPEN THE FILE\n*              AGAIN WITH DISP=MOD SO PDSFAST ETC. CAN 'ADD TO IT'\n*\n         CH    R5,=H'1'           PAST 1ST FILE?\n         BH    OPEN2AE            YES, ON WE GO\n         MVC   JFCBXPDT,SAVEXPDT  SET  JFCB EXPIRY DATE\n         B     OPEN4E             END FOR NOW\n         SPACE 1\nOPEN2AE  DS    0H\n         MVI   JFCBIND2,X'80'     PUT DISP=MOD IN\n         DROP  R2\n         SPACE 1\nOPEN2E   DS    0H\n         OPEN  (SYSUT2,(OUTPUT)),TYPE=J   OPEN IT\n         LA    R1,SYSUT2          R1 -> TO DCB\n         USING    IHADCB,R1\n         TM       DCBOFLGS,DCBOFOPN            DID IT OPEN ?\n         BZ    FAIL8E             NO, GO TO ERR RTN\n         DROP     R1\n         CLOSE (SYSUT2)           CLOSE IT                          RH\n         LA    R4,SYSUT2          R4 -> TO SYSUT2 DCB\n         USING IHADCB,R4          SET R4 AS DCB DSECT\n         L     R15,DCBBUFCB       R15 = A(BUFFER)\n         BCTR  R15,0              -1\n         LTR   R15,R15            IS THERE A BUFFER?\n         BZ    NOPOOL5            NO\n         DROP  R4                 DROP R4 AS DCB DSECT\n         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB\n*                                 IBM DON'T\n         SPACE\nNOPOOL5E DS    0H\n.ESKIP1  ANOP\n         SPACE 1\nOPEN4E   DS    0H\n         SR    R15,R15            R15 = 0\n         B     EXPARET            END FOR NOW\n         SPACE 1\nFAIL5E   DS    0H\n*        OLCMSG   OLC022          PRINT ERROR MSG\n         LA    R15,48             SET RC=40\n         B     EXPARET            END FOR NOW\n         SPACE 1                                                    RH1\nFAIL6E   DS    0H\n*        OLCMSG   OLC023          PRINT ERROR MSG\n         LA    R15,48             SET RC=40\n         B     EXPARET            END FOR NOW\n         SPACE 1                                                    RH1\nFAIL7E   DS    0H\n*        OLCMSG   OLC024          PRINT ERROR MSG\n         LA    R15,48             SET RC=40\n         B     EXPARET            END FOR NOW\n         SPACE 1                                                    RH1\nFAIL8E   DS    0H\n*        OLCMSG   OLC027          PRINT ERROR MSG\n         DC    H'0'               ABEND FOR NOW\n         LA    R15,48             SET RC=40\n         B     EXPARET            END FOR NOW\n         SPACE 1\nUT2ABENE DS    0H\n*        OLCMSG NEW006\n*        DC    H'0'               0C1 FOR NOW\n         LA    R15,16             R15 = 16\n*        B     EXPARET            END FOR NOW\n         SPACE 1\nEXPARET  SECEXIT\n         DROP  R2\n         SPACE 2\n*\n* EXPALLOC  DATA:\n*\n         SPACE 3\nTRTAB2   DC    C' 0123456789ABCDE '\n         SPACE 2\nDUMMYREC DC    CL80'DUMMY RECORD FOR EXPIRY DATE FILE'\n*\nINFO01   DC    AL1(MSGPRT)\n         DC    C'INFO01 - FILE 1 IS USED FOR SYSTEM INFORMATION'\n         DC    C' LIKE CATALOG NAME,'\n         DC    CL(81-(*-INFO01))'  '\n*\nINFO02   DC    AL1(MSGPRT)\n         DC    C'INFO02 -        EXPIRY DATE, OR GDG NAME'\n         DC    CL(81-(*-INFO02))'  '\n*\nINFO03   DC    AL1(MSGPRT)\n         DC    C'INFO03 - PROCESSING DATASET = '\nINFO03M  DC    CL44' '\n         DC    CL(81-(*-INFO03))'  '\n*\nINFO04   DS    0CL81' '\n         DC    AL1(MSGPRT)\n         DC    C'INFO04 - ABOVE '\nINFO04A  DC    CL2'PS'            DEFAULT FILE TYPE IS PO\n         DC    C' DATASET CREATED IN FILE '\nINFO04F  DC    CL4'0001'\n         DC    C' ON TAPE '\nINFO04B  DC    CL6' '             TAPE VOLSER GOES HERE\n         DC    CL(81-(*-INFO04))'  '\n*\n         SPACE 2\n TITLE 'NEWALLOC - ALLOCATE OUTPUT DATASET WITH JFCB MODS'\n*\n         DS    0H\nNEWALLOC SECTION GEN=\n*\n         LH    R14,TUPAR7         R14 = FILE NBR\n         LA    R14,1(0,R14)       R15 = NEXT SEQ NBR\n         CVD   R14,DWORDE         CONVERT TO DECIMAL\n         UNPK  DWORDE(5),DWORDE+5(3) CONVERT TO DISPLAY\n         MVZ   DWORDE+4(1),DWORDE FIX SIGN\n         MVC   ENDDSNN(3),DWORDE+2 MOVE FILE NBR TO ENDDSN...\n         LA    R3,ENDDSN          GET ADDRESS OF DISK DSNAME\n         LA    R6,4               R6 = LTH OF DSN ENDING\n         B     LTHOKAY2           DSN IS OKAY\n*\n*\n         L     R3,=V(USRDSN)      GET ADDRESS OF DISK DSNAME\n         L     R6,=V(DYNTUNT1)    R6 -> TO LTH TEXT UNIT\n         LH    R6,4(0,R6)         R6 = LTH INPUT DSN\n         AH    R6,HLILTH          R6 = LTH INPUT DSN + HLILTH\n         CH    R6,=H'44'          OVER MAX OF 44?\n         BNH   LTHOKAY            NO, DSN IS OKAY\n         LA    R6,44              R6 = MAX DSN LTH\n         SH    R6,HLILTH          R6 = LTH INPUT DSN TO USE\n         LA    R3,44(0,R3)        R3 -> TO END INPUT DSN\n         SR    R3,R6              R3 -> TO START OF DSN TO USE\n         SPACE 1\nCHKALPHA DS    0H                 FIND 1ST ALPHA CHAR\n         CLI   0(R3),C'0'         IS CHAR NUMERIC?\n         BL    CHKDOT             NO, CHECK FOR A DOT\n         LA    R3,1(0,R3)         R3 -> TO NEXT INPUT DSN CHAR\n         BCT   R6,CHKALPHA        GO SEE IF ALPHA\n         SPACE 1\nCHKDOT   DS    0H\n         CLI   0(R3),C'.'         IS CHAR A PERIOD ?\n         BNE   LTHOKAY2           NO, DSN IS OKAY\n         LA    R3,1(0,R3)         R3 -> TO NEXT INPUT DSN CHAR\n         BCTR  R6,0               R6 = LTH OF DSN LEFT\n         B     LTHOKAY2           DSN IS OKAY\n         SPACE 1\nLTHOKAY  DS    0H\n         LA    R6,44              R6 = MAX DSN LTH\n         SH    R6,HLILTH          R6 = MAX LTH - HLI LTH\n         SPACE 1\nLTHOKAY2 DS    0H\n         LA    R5,TUPAR1          R5 -> TO SVC99 DSN\n         AH    R5,HLILTH          R5 -> TO WHERE REST OF DSN GOES\n         BCTR  R6,0               R6 = HEX LTH\n         STC   R6,NEWMVC+1        SET MVC LTH\nNEWMVC   MVC   0(0,R5),0(R3)      PUT DSNAME BESIDE HLI.\n*\n*              FIND LTH OF DSN\n*\n         SPACE 1\nLTHLOOP  DS    0H\n         SR    R5,R5              R5 = 0\n         LA    R6,TUPAR1          R6 -> TO DSN\n         SPACE 1\nLOOP3    DS    0H\n         CLI   0(R6),C' '         AT END OF DSN ?\n         BE    OUT3               YES, MOVE IT TO SVC 99 FIELD\n         LA    R6,1(0,R6)         ADD 1 DSN POSITION REG\n         LA    R5,1(0,R5)         ADD 1 TO LTH CTR\n         B     LOOP3              LOOK AT NEXT CHAR\n         SPACE 1\nMVCDSN   MVC   TUPAR1(0),0(R1)    MVC DSN TO S99 BLOCK\n         SPACE 1\nOUT3     DS    0H\n         STH   R5,TULNG1          SET UP LTH FIELD FOR SVC99\n*\n*              ADD 1 TO SEQ NBR\n*\n         LH    R5,TUPAR7          R5 = SEQ NBR\n         LA    R5,1(0,R5)         R5 = NEXT SEQ NBR\n         STH   R5,TUPAR7          SAVE NEXT SEQ NBR\n*\n*              MODIFY THE JFCB\n*\n*\n*        COPY SYSUT2 DCB/JFCB INFO FROM SYSUT1\n*\n*\n*\n         L     R14,=V(SYSDSORG)   R14 -> TO SYSUT1 DSORG\n         CLC   0(2,R14),=X'0008'  IS IT VSAM?\n         BE    SETDCBVS           YES, SET UP DCB FOR EXPORT\n         TM    0(R14),X'02'       IS IT PO OR POU?\n         BO    SETDCBPO           YES, SET DCB FOR PDSFAST\n         TM    0(R14),X'20'       IS IT DA OR DAU?\n         BO    SETDCBDA           YES\n*                                 NO, TREAT AS PS\n*\n*        TM    0(R14),X'40'       IS IT PS OR PSU?\n*        BZ    UT2ABEND           NO, END FOR NOW\n         SPACE 1\nSETDCBPS DS    0H\nSETDCBDA DS    0H\n         L     R5,=V(JFCB)        R5 -> TO SYSUT1 JFCB\n         USING INFMJFCB,R5              SET DSECT\n         XC    0(176,R5),0(R5)    MAKE SURE JFCB IS CLEAN\n         L     R4,=V(INFILE)      R4 -> TO SYSUT1 DCB\n         RDJFCB ((4))             READ SYSUT1 JFCB\n         LTR   R15,R15            WAS RDJFCB OKAY?\n         BNZ   FAIL5              NO\n         LA    R4,SYSUT2          R4 -> TO SYSUT2 DCB\n         USING IHADCB,R4          SET DCB DSECT\n         MVC   DCBBLKSI,JFCBLKSI  SET SYSUT2 BLKSIZE TO SYSUT1\n         CLC   DCBBLKSI,=H'0'     SYSUT2 BLKSIZE = 0?\n         BNE   BLKSIOK            NO\n         MVC   DCBBLKSI,=H'32767' SET SYSUT2 BLKSIZE TO 32767\n         SPACE 1\nBLKSIOK  DS    0H\n         MVC   DCBLRECL,JFCLRECL  SET SYSUT2 LRECL TO SYSUT1\n         CLC   DCBLRECL,=H'0'     SYSUT2 LRECL = 0?\n         BNE   LRECOK             NO\n         MVC   DCBLRECL,DCBBLKSI  YES, SYSUT2 LRECL = BLKSIZE\n         SPACE 1\nLRECOK   DS    0H\n         MVC   DCBRECFM,JFCRECFM  SET SYSUT2 RECFM TO SYSUT1\n         DROP  R4,R5\n         B     DCBSET             ON WE GO\n         SPACE 1\nSETDCBVS DS    0H                 SET UP DCB FOR VSAM EXPORT\n         LA    R4,SYSUT2          R4 -> TO SYSUT2 DCB\n         USING IHADCB,R4          SET DCB DSECT\n         MVC   DCBBLKSI,=H'23220' SET SYSUT2 BLKSIZE TO 23220\n         MVC   DCBLRECL,=H'0'     SET SYSUT2 LRECL TO 0\n         MVI   DCBRECFM,X'58'     SET SYSUT2 RECFM TO VBS\n         DROP  R4\n         B     DCBSET             ON WE GO\n         SPACE 1\nSETDCBPO DS    0H                 SET UP DCB FOR PDSFAST\n         LA    R4,SYSUT2          R4 -> TO SYSUT2 DCB\n         USING IHADCB,R4          SET DCB DSECT\n         MVC   DCBBLKSI,=H'19089' SET SYSUT2 BLKSIZE TO 19089\n         MVC   DCBLRECL,=H'19085' SET SYSUT2 LRECL TO 19085\n         MVI   DCBRECFM,X'48'     SET SYSUT2 RECFM TO VS\n         DROP  R4\n*        B     DCBSET             ON WE GO\n*                                                                   RH1\n         SPACE 1\nDCBSET   DS    0H\n         LA    R2,UT2JFCB         R2 -> TO SYSUT2 JCFB              RH\n         USING IHAJFCB,R2\n*\n         MVC   JFCBDSNM,TUPAR1    PUT DSN IN\n         MVC   JFCBFLSQ,TUPAR7    PUT NEW SEQ NBR IN\n         MVC   JFCBVLSQ,VOLSEQ    PUT VOLUME SEQUENCE NBR IN\n         MVI   JFCBIND2,X'C0'     PUT DISP=NEW IN\n*\n*              ALSO PUT BLKSIZE, LRECL AND RECFM IN JFCB\n*\n         LA    R4,SYSUT2          R4 -> TO SYSUT2 DCB\n         USING IHADCB,R4          SET DCB DSECT\n         MVC   JFCBLKSI,DCBBLKSI  SET JFCB BLKSIZE\n         MVC   JFCLRECL,DCBLRECL  SET JFCB LRECL\n         MVC   JFCRECFM,DCBRECFM  SET JFCB RECFM\n         DROP  R4\n         SPACE 1\n         LH    R5,TUPAR7          R5 = SEQ NBR\n         CH    R5,=H'1'           PAST 1ST FILE?\n         BH    OPEN1              YES\n         MVI   JFCBIND2,X'80'     PUT DISP=MOD IN\n         MVC   SAVEXPDT,JFCBXPDT  SAVE JFCB EXPIRY DATE\n         XC    JFCBXPDT,JFCBXPDT  SET JFCB EXPIRY DATE TO NULL\n         B     UCBFOUND           BYPASS UCB SEARCH IF LABEL=1\n         SPACE 1\n*\nOPEN1    DS    0H\n         XC    JFCBXPDT,JFCBXPDT  SET JFCB EXPIRY DATE TO NULL\n*                                 BYPASS UCB SEARCH THE 1ST TIME\nOPENNOP  NOP   FINDUCB            B AFTER 1ST TIME\n         MVI   OPENNOP+1,X'F0'    CHANGE NOP TO B\n         B     UCBFOUND           BYPASS UCB SEARCH THE 1ST TIME\n*\n*      SEARCH THE UCB TABLE TO GET THE VOLSER\n*\n         SPACE 1                                                    RH\nFINDUCB  DS    0H                                                   RH\n         XC    WORKAREA,WORKAREA  CLEAR UCBSCAN WORKAREA\n         SPACE 1\nNEXTUCB  DS    0H\n         PRINT GEN\n*        UCBSCAN COPY,WORKAREA=WORKAREA,UCBAREA=UCBAREA,               +\n               DYNAMIC=YES,DEVCLASS=TAPE      ,VOLSER=TUPAR6\n         UCBSCAN COPY,WORKAREA=WORKAREA,UCBAREA=UCBAREA,               +\n               DYNAMIC=YES,DEVCLASS=TAPE,  VOLSER=TUPAR1,              +\n               RANGE=ALL,CMXTAREA=CMXTAREA,DCEAREA=DCEAREA,            +\n               DCELEN=DCELEN\n         PRINT NOGEN\n         LTR   R15,R15            HAS A UCB BEEN RETURNED?\n         BZ    UCBOK              YES\n         MVC   OLC024A(3),=C'UCB' SAY NO UCB\n         B     FAIL7              NO, AT END OF DEVICE CLASS AND\n*                                 NO MATCH FOUND.\n         SPACE 1\nUCBOK    DS    0H\n         LA    R3,UCBAREA         R3 -> TO UCB THAT THE SCAN\n*                                 SERVICE RETURNED.\n         USING UCBOB,R3           SET UP ADDRESSIBILITY TO UCB\n*                                                                   RH\n*                  THIS IS CODE TO DUMP CORE                 DEBUG  RH\n*                                                                   RH\n         L     R2,=V(DEBUG)     IS DEBUG IN EFFECT\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?\n         BZ    LINKUCB            NO\n         DROP  R2                 DROP BASE...\n         SPACE 1                                             DEBUG  RH\n         PRINT   GEN\n         HDUMP OUTDCB,R3,200,NOTOPEN,OPEN,V=YES,             DEBUG  RH +\n               TITLE='UCB RETURNED BY UCBSCAN' ,GENDCB=YES\n         SPACE 1                                             DEBUG  RH\n         PRINT NOGEN\n*                                                                   RH\n*                  THIS IS END OF CODE TO DUMP CORE          DEBUG  RH\n*                                                                   RH\n         SPACE 1                                             DEBUG  RH\nLINKUCB  DS    0H                                            DEBUG  RH\n*        CLC   UCBNAME,TUPAR6     IS THIS OUR UCB?\n*        BNE   NEXTUCB            NO, DON'T USE IT THEN\n*\n*   THE ONLY PROBLEM IS THAT THE ABOVE CODE DOESN'T WORK FOR\n*   4 DIGIT UCB ADDRESSES, AS THE UCBNAME FIELD CONTAINS 'UCB'.\n*   SO WE MUST CONVERT THE REAL UCB ADDRESS FROM THE HEX ADDRESS\n*   AT OFFSET +4 IN THE UCB...FEB 10/99\n*\n*   ALSO, IF YOU ARE ALLOCATING BY UNIT, IT MUST BE PRECEDED BY /   RH\n*              ..EG../190A.....\n*\n*              CONVERT UCB ADDRESS FOR UNIT NAME\n*\n         UNPK  TESTUCB(5),4(3,R3) UNPACK 4 DIGIT UNIT ADDRESS\n         MVI   TESTUCB+4,X'EF'    TRANSLATES TO BLANK\n         TR    TESTUCB(5),TRTAB3-239  TRANSLATE TO DISPLAY\n         MVC   TESTUCB+5(3),=CL5' '    BLANK OUT REST OF UNIT NAME\n*\n*                                                                   RH\n*                  THIS IS CODE TO DUMP CORE                 DEBUG  RH\n*                                                                   RH\n         L     R2,=V(DEBUG)     IS DEBUG IN EFFECT\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?\n         BZ    LINKUCB2           NO\n         DROP  R2                 DROP BASE...\n         SPACE 1                                             DEBUG  RH\n         LA    R2,TESTUCB         R2 -> AREA TO DUMP\n         PRINT   GEN\n         HDUMP OUTDCB,R2,20,NOTOPEN,OPEN,V=NO,               DEBUG  RH +\n               TITLE='TESTUCB'                 ,GENDCB=YES\n         LA    R2,TUPAR6          R2 -> AREA TO DUMP\n         HDUMP OUTDCB,R2,20,NOTOPEN,OPEN,V=NO,               DEBUG  RH +\n               TITLE='TUPAR6'                  ,GENDCB=YES\n         SPACE 1                                             DEBUG  RH\n         PRINT NOGEN\n*                                                                   RH\n*                  THIS IS END OF CODE TO DUMP CORE          DEBUG  RH\n*                                                                   RH\n         SPACE 1                                             DEBUG  RH\nLINKUCB2 DS    0H                                            DEBUG  RH\n         CLC   TESTUCB,TUPAR6     IS THIS OUR UCB?\n         BNE   NEXTUCB            NO, DON'T USE IT THEN\n*\n         CLI   UCBVOLI,X'00'      IS THERE A VOL SER?\n         BNE   UCBOK2             YES\n         MVC   OLC024A(3),=C'VOL' SAY NO VOL\n         B     FAIL7              NO, AT END OF DEVICE CLASS AND\n*                                 NO MATCH FOUND.\nTESTUCB  DC    CL8' '\n         SPACE 3\nTRTAB3   DC    C' 0123456789ABCDE '\n         SPACE 3\n         SPACE 1\nUCBOK2   DS    0H\n         LA    R2,UT2JFCB         R2 -> TO SYSUT2 JCFB              RH\n         USING IHAJFCB,R2         SET JFCB BASE AGAIN\n         MVC   JFCBVOLS(6),UCBVOLI PUT VOLSER IN JFCB 1\n         SPACE 1\nUCBFOUND DS    0H\n         SPACE 1\nNOMORE   DS    0H\n         DROP  R3                 DROP UCB BASE\n         OPEN  (SYSUT2,(OUTPUT)),TYPE=J   OPEN IT\n         LA    R1,SYSUT2          R1 -> TO DCB\n         USING    IHADCB,R1\n         TM       DCBOFLGS,DCBOFOPN            DID IT OPEN ?\n         BZ    FAIL8              NO, GO TO ERR RTN\n*\n*              IN CASE WE SWITCHED TO ANOTHER UNIT, CHAIN THRU THE\n*              DEB TO THE UCB AND  SAVE THE UNIT NAME\n*\n         L     R4,DCBDEBAD        R4 -> TO THE DEB\n         LA    R4,0(0,R4)         CLEAR FLAG BYTE\n         USING DEBBASIC,R4        SET DEB BASE\n         L     R4,DEBSUCBA        R4 -> TO THE DEB UCB\n         LA    R4,0(0,R4)         CLEAR FLAG BYTE\n         DROP  R4                 DROP DEB BASE\n         USING UCBOB,R4           SET UCB BASE\n*        MVC   TUPAR6(3),UCBNAME  SAVE THIS UNIT ADDRESS\n*\n*   THE ONLY PROBLEM IS THAT THE ABOVE CODE DOESN'T WORK FOR\n*   4 DIGIT UCB ADDRESSES, AS THE UCBNAME FIELD CONTAINS 'UCB'.\n*   SO WE MUST CONVERT THE REAL UCB ADDRESS FROM THE HEX ADDRESS\n*   AT OFFSET +4 IN THE UCB...FEB 10/99\n*\n*\n*   ALSO, IF YOU ARE ALLOCATING BY UNIT, IT MUST BE PRECEDED BY /   RH\n*              ..EG../190A.....\n*\n*              CONVERT UCB ADDRESS FOR UNIT NAME\n*\n         LA    R6,TUPAR6          R6 -> WHERE UCB NAME GETS SAVED\n         UNPK  0(5,R6),4(3,R4)    UNPACK 4 DIGIT UNIT ADDRESS\n         MVI   4(R6),X'EF'        TRANSLATES TO BLANK\n         TR    0(5,R6),TRTAB4-239 TRANSLATE TO DISPLAY\n         MVC   5(3,R6),=CL5' '    BLANK OUT REST OF UNIT NAME\n*\n         DROP  R1,R4\n*\n*              IF WE AT THE 1ST FILE, CREATE A DUMMY FILE TO\n*              CONTAIN THE EXPIRY DATE....\n*\n         CH    R5,=H'1'           PAST 1ST FILE?\n         BH    CLOSFILE           YES, ON WE GO\n         MVC   JFCBXPDT,SAVEXPDT  SET  JFCB EXPIRY DATE\n         B     OPEN4              END FOR NOW\n*\n*              ADD 1 TO SEQ NBR\n*\n         LH    R5,TUPAR7          R5 = SEQ NBR\n         LA    R5,1(0,R5)         R5 = NEXT SEQ NBR\n         STH   R5,TUPAR7          SAVE NEXT SEQ NBR\n*\n*        LA    R2,UT2JFCB         R2 -> TO SYSUT2 JCFB              RH\n*        USING IHAJFCB,R2\n         MVC   JFCBDSNM,TUPAR1    PUT DSN IN\n         MVC   JFCBFLSQ,TUPAR7    PUT NEW SEQ NBR IN\n         MVC   JFCBVLSQ,VOLSEQ    PUT VOLUME SEQUENCE NBR IN\n         MVI   JFCBIND2,X'C0'     PUT DISP=NEW IN\n         SPACE 1\nCLOSFILE DS    0H\n         CLOSE (SYSUT2)           CLOSE IT                          RH\n         LA    R4,SYSUT2          R4 -> TO SYSUT2 DCB\n         USING IHADCB,R4          SET R4 AS DCB DSECT\n         L     R15,DCBBUFCB       R15 = A(BUFFER)\n         BCTR  R15,0              -1\n         LTR   R15,R15            IS THERE A BUFFER?\n         BZ    NOPOOL4            NO\n         DROP  R4                 DROP R4 AS DCB DSECT\n         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB\n*                                 IBM DON'T\n         SPACE\nNOPOOL4  DS    0H\n*\n*              MODIFY THE JFCB AGAIN. IF THERE IS NO VOLSER,\n*              READ IT AGAIN INTO  A DIFFERENT AREA AND SAVE THE\n*              VOLSER IN THE FIRST JFCB.\n*\n*        LA    R2,UT2JFCB         R2 -> TO SYSUT2 JCFB              RH\n         USING IHAJFCB,R2         SET JFCB BASE AGAIN\n         CLI   JFCBVOLS,C' '      IS THERE A VOLSER?\n         BE    BADVOL             NO, DO RDJFCB AGAIN\n         CLI   JFCBVOLS,C'A'      IS IT ALPHANUMERIC?\n         BL    BADVOL             NO, DO RDJFCB AGAIN\n         CLI   JFCBVOLS,C'9'      IS IT ALPHANUMERIC?\n         BNH   JFCBOK             YES, DON'T GET JFCB AGAIN\n         SPACE 1\nBADVOL   DS    0H\n         LA    R4,UT2JFCB2        R4 -> TO JFCB AREA 2\n         STCM  R4,7,JFCBXLSJ      PUT IT IN EXIT LIST\n*        XC    0(176,R4),0(R4)    MAKE SURE JFCB IS CLEAN\n         RDJFCB SYSUT2            GET THE SYSUT2 JFCB               RH\n         LA    R1,UT2JFCB         R1 -> TO JFCB AREA\n         STCM  R1,7,JFCBXLSJ      PUT IT BACK IN EXIT LIST\n         LTR   R15,R15            GET IT?                           RH\n         BNZ   FAIL6              IF NOT  NO BLKSIZE                RH\n         MVC   JFCBVOLS,JFCBVOLS-IHAJFCB(R4) PUT VOLSER IN JFCB 1\n         CLI   JFCBVOLS,C' '      IS THERE A VOLSER?\n         BE    UT2ABEND           NO, ABEND\n         SPACE 1\nJFCBOK   DS    0H\n*\n*              IF WE ARE PAST THE  1ST FILE, WE MUST OPEN THE FILE\n*              AGAIN WITH DISP=MOD SO PDSFAST ETC. CAN 'ADD TO IT'\n*\n         CH    R5,=H'1'           PAST 1ST FILE?\n         BH    OPEN2A             YES, ON WE GO\n         MVC   JFCBXPDT,SAVEXPDT  SET  JFCB EXPIRY DATE\n         B     OPEN4              END FOR NOW\n         SPACE 1\nOPEN2A   DS    0H\n         MVI   JFCBIND2,X'80'     PUT DISP=MOD IN\n         DROP  R2\n         SPACE 1\nOPEN2    DS    0H\n         OPEN  (SYSUT2,(OUTPUT)),TYPE=J   OPEN IT\n         LA    R1,SYSUT2          R1 -> TO DCB\n         USING    IHADCB,R1\n         TM       DCBOFLGS,DCBOFOPN            DID IT OPEN ?\n         BZ    FAIL8              NO, GO TO ERR RTN\n         DROP     R1\n         CLOSE (SYSUT2)           CLOSE IT                          RH\n         LA    R4,SYSUT2          R4 -> TO SYSUT2 DCB\n         USING IHADCB,R4          SET R4 AS DCB DSECT\n         L     R15,DCBBUFCB       R15 = A(BUFFER)\n         BCTR  R15,0              -1\n         LTR   R15,R15            IS THERE A BUFFER?\n         BZ    NOPOOL5            NO\n         DROP  R4                 DROP R4 AS DCB DSECT\n         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB\n*                                 IBM DON'T\n         SPACE\nNOPOOL5  DS    0H\n         SPACE 1\nOPEN4    DS    0H\n         SR    R15,R15            R15 = 0\n         B     NEWARET            END FOR NOW\n         SPACE 1\nFAIL5    DS    0H\n         OLCMSG   OLC022          PRINT ERROR MSG\n         LA    R15,48             SET RC=40\n         B     NEWARET            END FOR NOW\n         SPACE 1                                                    RH1\nFAIL6    DS    0H\n         OLCMSG   OLC023          PRINT ERROR MSG\n         LA    R15,48             SET RC=40\n         B     NEWARET            END FOR NOW\n         SPACE 1                                                    RH1\nFAIL7    DS    0H\n         OLCMSG   OLC024          PRINT ERROR MSG\n         LA    R15,48             SET RC=40\n         B     NEWARET            END FOR NOW\n         SPACE 1                                                    RH1\nFAIL8    DS    0H\n         OLCMSG   OLC027          PRINT ERROR MSG\n         DC    H'0'               ABEND FOR NOW\n         LA    R15,48             SET RC=40\n         B     NEWARET            END FOR NOW\n         SPACE 1\nUT2ABEND DS    0H\n         OLCMSG NEW006\n*        DC    H'0'               0C1 FOR NOW\n         LA    R15,16             R15 = 16\n*        B     NEWARET            END FOR NOW\n         SPACE 1\nNEWARET  SECEXIT\n         SPACE 2\n*\n* NEWALLOC  DATA:\n*\n*\n         SPACE 3\nTRTAB4   DC    C' 0123456789ABCDE '\n         SPACE 2\n         SPACE 1\nENDDSN   DS    0CL4\nENDDSNA  DC    C'F'\nENDDSNN  DC    CL3'001'\nDWORDE   DC    D'0'\n         SPACE 1\nSAVEXPDT DC    XL3'0'\n         ENTRY FIRSTDSN\nFIRSTDSN DC    CL44' '\n         SPACE 1\nOLC022   DS    0CL81\n         DC    AL1(MSGPRT)\n         DC    CL75'DSB022 - RDJFCB OF SYSUT1 FAILED'\n         DC    C'ERROR'\n         SPACE 1\nOLC023   DS    0CL81\n         DC    AL1(MSGPRT)\n         DC    CL75'DSB023 - SECOND READ OF SYSUT2 JFCB FAILED'\n         DC    C'ERROR'\n         SPACE 1\nOLC024   DS    0CL81\n         DC    AL1(MSGPRT)\n         DC    CL9'DSB024 - '\nOLC024A  DC    CL66'UCB NOT FOUND FOR SYSUT2'\n         DC    C'ERROR'\n         SPACE 1\nOLC027   DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    C'DSB027 - ERROR OPENING SYSUT2'\n         ORG   OLC027+75\n         DC    CL5'ERROR'\n         ORG   OLC027+81\n         SPACE 1\nNEW006   DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    C'DSB06N - NO VOLSER IN JFCB FOR SYSUT2 '\n         ORG   NEW006+75\n         DC    CL5'ERROR'\n         ORG   NEW006+81\n*\nOLC010   DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    C'DSB010 - MAX OF 5 TAPES EXCEEDED. '\n         DC    C'RUN AS 2 JOBS'\n         ORG   OLC010+75\n         DC    CL5'ERROR'\n         ORG   OLC010+81\n         SPACE 2\n         SPACE 1\nPARMLST2 DS    3F                 PARMLIST MAPPING\n         ORG   PARMLST2\nPARMWA   DC    A(WORKAREA)        ADDRESS OF 100-BYTE WORKAREA\nPARMDEVT DC    A(DEVCLASS)        ADDRESS OF BYTE CONTAINING\n*                                 THE DEVICE TYPE TO BE SEARCHED\nPARMUCB  DC    AL1(80)            ADDRESS OF WORD TO CONTAIN THE\n         DC    AL3(ADDRUCB)       THE UCB ADDRESS\n         SPACE 1\nDEVCLASS DC    XL1'80'            BYTE CONTAINING DEVICE CLASS\n*                                 TO BE SEARCHED FOR\n*                                 X'80' IS TAPE\nADDRUCB  DS    F                  WORD IN WHICH UCBSCAN WILL\n*                                 PLACE THE ADDRESS OF THE UCB\n         DS    0D                 ALIGN TO DOUBLE-WORD BOUNDARY\n*                                 THE WORKAREA FOR SCAN SERVICE\n*                                 MUST BE ON A DOUBLE-WORD BOUNDARY\nWORKAREA DS    CL100              WORKAREA\nUCBAREA  DS    CL48               WORKAREA FOR UCB\nCMXTAREA DS    CL32               WORKAREA FOR UCB\nDCELEN   DC    AL2(128)           WORKAREA FOR UCB\nDCEAREA  DS    CL128              WORKAREA FOR UCB\n         SPACE 1\n         SPACE 1\n         ENTRY TUPAR1,TULNG1,HLILTH,TUPAR3,TULNG6,TUPAR6,TUPAR7\n         ENTRY VOLSEQ\nHLILTH   DC    H'0'               LTH OF HLI\n         SPACE 1\nTULNG1   DC    AL2(44)            LTH OF DSNAME\nTUPAR1   DC    CL44' '            DSNAME\n         SPACE 1\nTUPAR3   DC    CL6' '             1ST VOLSER\n         SPACE 1\nTULNG6   DC    AL2(4)             LTH OF UNIT\nTUPAR6   DC    CL8'TAPE'          UNIT=TAPE\n         SPACE 1\nTULNG7   DC    AL2(2)             LTH OF SEQ\nTUPAR7   DC    AL2(1)             LABEL=1 TO START\nVOLSEQ   DC    AL2(1)             VOLSQ=1 TO START\n         SPACE 2\n         ENTRY SYSUT2,JFCBXLS2,JFCBXLSJ,UT2JFCB,UT2JFCB2\nSYSUT2   DCB   MACRF=(PM),DSORG=PS,DDNAME=SYSUT2,EXLST=JFCBXLS2\n         SPACE 1\nJFCBXLS2 DS    0F\n         DC    X'17',AL3(DCBOPEN2) OPEN EXIT\n         DC    X'11',AL3(DCBTRAP2) OPEN ABEND EXIT\n         DC    X'87'               JFCB EXIT\nJFCBXLSJ DC    AL3(UT2JFCB)        JFCB ADDRESS\n         DS    0F\n         DC    C'JFCB'                                              RH1\nUT2JFCB  DC    XL176'00'\n         DS    0F\n         DC    C'JFCB'                                              RH1\nUT2JFCB2 DC    XL176'00'\n         SPACE 1\n         DROP  R12                DROP SECTION BASE\nDCBTRAP2 DS    0H\n         USING *,R15\n         CLI   3(1),X'00'         MUST ABEND ?\n         BER   R14                YES, LET ESTAE CATCH THIS ABEND\n         MVI   3(1),X'04'         TRY TO IGNORE ABEND CONDITION\n         BR    R14\n         DROP  R15\n         SPACE 1\nDCBOPEN2 DS    0H\n         USING *,R15\n         SR    R15,R15            CONTINUE WITH OPEN\n         BR    R14\n         DROP  R15\n         SPACE 2\n TITLE 'TAPALLOC - ALLOCATE INPUT TAPE FILE WITH JFCB MODS'\n*\n*              HERE WE WILL OPEN AND CLOSE SYSUT1 IN ORDER TO\n*              MODIFY THE JFCB.\n*\n         DS    0H\nTAPALLOC SECTION DROP=NO\n*\n         L     R3,=V(RESTREC)     R3 -> TO RESTORE RECORD\n         USING RESTRECD,R3        SET RECORD BASE\n*\n*              MODIFY THE JFCB WITH OPEN/CLOSE\n*\n         SPACE 1\n         L     R5,=V(JFCB)        R5 -> TO SYSUT1 JFCB\n         USING INFMJFCB,R5              SET DSECT\n         XC    0(176,R5),0(R5)    MAKE SURE JFCB IS CLEAN\n         L     R4,=V(INFILE)      R4 -> TO SYSUT1 DCB\n         RDJFCB ((4))             READ SYSUT1 JFCB\n         LTR   R15,R15            WAS RDJFCB OKAY?\n         BNZ   FAIL5T             NO\n*\n*              MAKE SURE JFCB IS  CLEAN TO FORCE SYSTEM TO USE\n*              INFO FROM TAPE HDR\n*\n         XC    JFCRECFM,JFCRECFM  SET JFCB RECFM TO 0\n         XC    JFCBLKSI,JFCBLKSI  SET JFCB BLKSIZE TO 0\n         XC    JFCLRECL,JFCLRECL  SET JFCB LRECL TO 0\n         MVI   JFCBDSNM,C' '      CLEAR DSN AREA\n         MVC   JFCBDSNM+1(43),JFCBDSNM ''\n         MVC   JFCBDSNM(44),RESTDSN  PUT DSN IN   ... WAS (17)...\n         OI    JFCBFLG2,X'80'     TREAT INOUT AS INPUT              V2\n         MVI   JFCBIND2,X'08'     MAKE SURE DISP=SHR                V2\n         OI    JFCDSORG,X'40'     TAPE HAS TO BE PS                 V2\n*\n*              MAKE SURE DCB  IS  CLEAN\n*\n         USING IHADCB,R4          SET R4 AS DCB DSECT\n         XC    DCBBLKSI,DCBBLKSI  SET SYSUT1 BLKSIZE TO 0\n         XC    DCBLRECL,DCBLRECL  SET SYSUT1 LRECL TO 0\n         XC    DCBRECFM,DCBRECFM  SET SYSUT1 RECFM TO 0\n         XC    DCBDSORG,DCBDSORG  SET SYSUT1 DSORG TO 0\n         DROP  R4                 DROP R4 AS DCB BASE\n*\n         PACK  DWORDV,RESTVSEQ    PACK SEQUENCE NBR\n         CVB   R15,DWORDV         CONVERT TO BINARY\n         STH   R15,JFCBFLSQ       PUT NEW SEQ NBR IN JFCB\n         DROP  R3                 DROP RECORD BASE\n*\n*              PUT VOLSERS INTO JFCB\n*\n         SR    R14,R14            CLEAR R14\n         L     R3,=V(VOLSER2)     R3 -> VOLSERS\n         IC    R14,0(0,R3)        R14 = NBR OF VOLSERS\n         STC   R14,JFCBNVOL       PUT NBR IN JFCB\n         LA    R15,JFCBVOLS       R15 -> TO WHERE JFCB VOLSERS GO\n         LA    R3,1(0,R3)         R3 -> TO VOLSERS\n         SPACE 1\nMVCVOLS  DS    0H\n         MVC   0(6,R15),0(R3)     PUT VOLUME SERIAL NBR IN JFCB\n         LA    R15,6(0,R15)       R15 -> TO WHERE NEXT VOLSER GOES\n         LA    R3,6(0,R3)         R3 -> TO NEXT VOLSER\n         BCT   R14,MVCVOLS        PUT ALL VOLS INTO JFCB\n         SPACE 1\n         MVI   JFCBIND2,X'08'     PUT DISP=SHR IN\n*                                                                   RH\n*                  THIS IS CODE TO DUMP CORE                 DEBUG  RH\n*                                                                   RH\n         L     R2,=V(DEBUG)     IS DEBUG IN EFFECT\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?\n         BZ    OPENINB            NO\n         DROP  R2                 DROP BASE...\n         SPACE 1                                             DEBUG  RH\n         L     R2,=V(INFILE)      R2 -> TO INFILE DCB        DEBUG  RH\n         PRINT   GEN\n         HDUMP OUTDCB,R4,100,NOTOPEN,OPEN,V=YES,             DEBUG  RH +\n               TITLE='SYSUT1 DCB AT JFCB SETUP',GENDCB=NO\n         L     R2,=V(JFCB)        R2 -> TO JFCB              DEBUG  RH\n         HDUMP OUTDCB,R2,200,OPEN,OPEN,                      DEBUG  RH +\n               TITLE='SYSUT1 JFCB AT SETUP'\n         HDUMP OUTDCB,0,0,OPEN,CLOSE,  DUMP REGS ONLY         DEBUG RH +\n               TITLE='REGS AT SETUP'\n         SPACE 1                                             DEBUG  RH\n*                                                                   RH\n*                  THIS IS END OF CODE TO DUMP CORE          DEBUG  RH\n*                                                                   RH\n         SPACE 1\nOPENINB  DS    0H                                                   RH\n         OPEN  ((R4),(INPUT)),TYPE=J   OPEN IT\n         PRINT NOGEN\n         USING IHADCB,R4          SET DCB BASE\n         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?\n         BZ    FAIL8T             NO, GO TO ERR RTN\n*\n         CLOSE ((R4))             CLOSE IT                          RH\n         L     R15,DCBBUFCB       R15 = A(BUFFER)\n         BCTR  R15,0              -1\n         LTR   R15,R15            IS THERE A BUFFER?\n         BZ    NOPOOL6            NO\n         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB\n*                                 IBM DON'T\n         SPACE\nNOPOOL6  DS    0H\n         SPACE 1\nOPEN4T   DS    0H\n         SR    R15,R15            R15 = 0\n         B     TAPARET            END FOR NOW\n         SPACE 1\nFAIL5T   DS    0H\n         OLCMSG   OLC022T         PRINT ERROR MSG\n         LA    R15,48             SET RC=40\n         B     TAPARET            END FOR NOW\n         SPACE 1                                                    RH1\nFAIL8T   DS    0H\n         OLCMSG   OLC027T         PRINT ERROR MSG\n         DC    H'0'               ABEND FOR NOW\n         LA    R15,48             SET RC=48\n         B     TAPARET            END FOR NOW\n         SPACE 1\n         SPACE 1\nTAPARET  SECEXIT\n         DROP  R4,R5              DROP BASE REGS\n         SPACE 2\n*\n* TAPALLOC  DATA:\n*\n*\nDWORDV   DS    D\n         SPACE 1\nOLC022T  DS    0CL81\n         DC    AL1(MSGPRT)\n         DC    CL75'DSB022T - RDJFCB OF SYSUT1 FAILED'\n         DC    C'ERROR'\n         SPACE 1\nOLC027T  DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    C'DSB027T - ERROR OPENING SYSUT2'\n         ORG   OLC027T+75\n         DC    CL5'ERROR'\n         ORG   OLC027T+81\n         SPACE 1\n         SPACE 2\n TITLE 'CREATDSN - ALLOCATE NEW DATASET ON DISK'\n*\n         DS    0H\nCREATDSN SECTION\n*\n         SPACE 1\nCREATERC LA    R15,16             FAIL FOR NOW\n         SPACE 1\nDYNARETC SECEXIT\n         SPACE 2\n         SPACE 2\n TITLE 'RACCHECK - MAKE SURE WE HAVE ACCESS TO DATASET'\n*\n*  MAKE SURE WE HAVE READ ACCESS TO DS FOR BACKUP, UPDATE\n*  ACCESS FOR RESTORE, AND ALTER  ACCESS FOR VSAM\n*  ALSO, FOR VSAM, THE VOLUME SPECIFIED MUST BE THE CATALOG VOLUME\n*\n         DS    0H\nRACCHECK SECTION\n*\n         RACSTAT ,                IS RACF ACTIVE?\n         BZ    RACHEK2            YES\n         SR    R15,R15            NO, SAY ACCESS IS OKAY\n         B     RACRET             ON WE GO\n         SPACE 1\nRACHEK2  DS    0H\n         LA    R3,2               R3 = 2, FOR READ ACCESS\n         MVC   OLC11A,=C'READ  '  SAY ACCESS IS READ\n         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM\n         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?\n         BNE   NOTREST3           NO\n         LA    R3,4               R3 = 4, FOR UPDATE ACCESS\n         MVC   OLC11A,=C'UPDATE'  SAY ACCESS IS UPDATE\n         SPACE 1\nNOTREST3 DS    0H\n         L     R4,=V(USRDSN)      ADDRESS OF DSNAME\n         L     R5,=V(DYNTUNT4)    ADDRESS OF VOLSER TEXT UNIT\n         LA    R5,6(,R5)          ADDRESS OF VOLUME = ADDR UNIT + 6\n         SPACE 1\n         L     R14,=V(SYSDSORG)   R14 -> TO SYSUT1 DSORG\n         CLC   0(2,R14),=X'0008'  IS IT VSAM?\n         BE    VSAMCHK            YES\n         SPACE 1\n         PRINT NOGEN\n*        RACHECK ENTITY=((R4)),VOLSER=(R5),CLASS='DATASET',ATTR=READ\n*              LOG=NONE,DSTYPE=N\n*                WHEN THIS RUNS AUTHORIZED, TURN OFF ERROR LOGGING\n         RACHECK ENTITY=((R4)),VOLSER=(R5),CLASS='DATASET',ATTR=(R3),  +\n               DSTYPE=N\n         LTR   R15,R15        ARE WE OKAY?\n         BZ    RACRET\n         B     SENDMSG            GO SEND ERROR MSG\n         SPACE 1\nVSAMCHK  DS    0H\n*        L     R3,=V(TVOL)        GET ADDRESS OF LOCATE VOLSER\n         LA    R3,X'80'           R3 = 80, FOR ALTER ACCESS\n         L     R5,=V(USRVOL)      GET ADDRESS OF CATALOG VOL, IF THERE\n         MVC   OLC11A,=C'ALTER '  SAY ACCESS IS ALTER\n         RACHECK ENTITY=((R4)),VOLSER=(R5),CLASS='DATASET',ATTR=(R3),  +\n               DSTYPE=V\n         PRINT NOGEN\n         LTR   R15,R15        ARE WE OKAY?\n         BZ    RACRET\n         B     SENDMSG            GO SEND ERROR MSG\n         SPACE 1\nSENDMSG  DS    0H\n         OLCMSG OLC011        IF NOT PRINT OUT ERROR MSG\n         LA    R15,4\nRACRET   SECEXIT\n         SPACE 2\n         DC    CL81' '\n         ORG   *-81\nOLC011   DS    0A\n         DC    AL1(MSGPRT)\n         DC    C'DSB011 - RACF '\nOLC11A   DC    C'UPDATE'\n         DC    C' ACCESS DENIED '\n         ORG   OLC011+75\n         DC    CL5'ERROR'\n         ORG   OLC011+81\n TITLE 'EMPTYCHK - DETERMINE IF LIBRARY IS EMPTY'\n         DS    0H\nEMPTYCHK SECTION\n*\n         L     R14,=V(SYSDSORG)   R14 -> TO SYSUT1 DSORG\n         CLC   0(2,R14),=X'0008'  IS IT VSAM?\n         BE    BADORG             YES, ERROR\n         TM    0(R14),X'02'       IS IT PO OR POU?\n         BO    DSORGPO            YES, WE CAN HANDLE IT\n         TM    0(R14),X'20'       IS IT DA OR DAU?\n         BO    DSORGPS            YES, TREAT LIKE PS FOR NOW\n         TM    0(R14),X'40'       IS IT PS OR PSU?\n         BO    DSORGPS            YES, WE CAN HANDLE IT\n         SPACE 1\nBADORG   DS    0H\n         OLCMSG OLC110            PRINT BAD DSORG MSG\n         SR    R15,R15            RC = 0\n         B     EMPRET             END FOR NOW\n         SPACE 1\nDSORGPS  DS    0H\n         OPEN  (DCB2,(INPUT))     OPEN SYSUT1\n         TM    DCB2+48,X'10'         OPEN OKAY?\n         BZ    EMPERR                NO  TERMINATE WITH RC=8\n         GET   DCB2               GO READ A RECORD\n         CLOSE (DCB2)             CLOSE FILE\n         LA    R4,DCB2            R4 -> TO DCB\n         USING IHADCB,R4          SET R4 AS DCB DSECT\n         L     R15,DCBBUFCB       R15 = A(BUFFER)\n         BCTR  R15,0              -1\n         LTR   R15,R15            IS THERE A BUFFER?\n         BZ    NOPOOL7            NO\n         DROP  R4                 DROP R4 AS DCB DSECT\n         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB\n*                                 IBM DON'T\n         SPACE\nNOPOOL7  DS    0H\n         SR    R15,R15            CLEAR FOR RETURN CODE\n         B     EMPRET             NOT EMPTY\n         SPACE 1\nDSORGPSE DS    0H\n         CLOSE (DCB2)             CLOSE FILE\n         LA    R4,DCB2            R4 -> TO DCB\n         USING IHADCB,R4          SET R4 AS DCB DSECT\n         L     R15,DCBBUFCB       R15 = A(BUFFER)\n         BCTR  R15,0              -1\n         LTR   R15,R15            IS THERE A BUFFER?\n         BZ    NOPOOL8            NO\n         DROP  R4                 DROP R4 AS DCB DSECT\n         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB\n*                                 IBM DON'T\n         SPACE\nNOPOOL8  DS    0H\n         B     DSEMPTY            SAY FILE EMPTY\n         SPACE 1\nDSORGPO  DS    0H\n         OPEN  (DIRECTRY,(INPUT))\n         TM    DIRECTRY+48,X'10'     OPEN OKAY?\n         BZ    EMPERR                NO  TERMINATE WITH RC=8\n         READ  DIRDECB,SF,DIRECTRY,DIRECTAR,'S'\n         CHECK DIRDECB               WAIT FOR COMPLETION\n         CLOSE (DIRECTRY)\n         SR    R15,R15               CLEAR FOR RETURN CODE\n*  R1 POINTS TO NEXT MEMBER IN DIRECTORY BLOCK\n         LA    R1,DIRECTAR+2\n         USING PDS2,R1\n         CLI   PDS2NAME,X'FF'        NO MEMBERS?\n         BNE   EMPRET\n         SPACE 1\nDSEMPTY  DS    0H\n         L     R2,=V(USRDSN)      GET ADDRESS OF INPUT DSNAME\n         CLC   0(6,R2),=CL6' '    ANY DSNAME?\n         BE    SETRC4             NO\n         OLCMSG OLC013\n         SPACE 1\nSETRC4   DS    0H\n         LA    R15,4              INDICATE EMPTY LIBRARY\n         B     EMPRET\nEMPRDER  CLOSE (DIRECTRY)\n         LA    R4,DIRECTRY        R4 -> TO DCB\n         USING IHADCB,R4          SET R4 AS DCB DSECT\n         L     R15,DCBBUFCB       R15 = A(BUFFER)\n         BCTR  R15,0              -1\n         LTR   R15,R15            IS THERE A BUFFER?\n         BZ    NOPOOL9            NO\n         DROP  R4                 DROP R4 AS DCB DSECT\n         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB\n*                                 IBM DON'T\n         SPACE\nNOPOOL9  DS    0H\nEMPERR   EQU   *\n         OLCMSG OLC012\n         LA    R15,8              INDICATE ERROR\nEMPRET   SECEXIT\n         DROP  R1\n         SPACE 2\nOLC012   DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    C'DSB012 - DIRECTORY READ FAILED FOR DSNAME IN DSB043'\n         ORG   OLC012+75\n         DC    CL5'ERROR'\n         ORG   OLC012+81\n         SPACE 1\nOLC013   DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    C'DSB013 - LIBRARY EMPTY : '\nOLC013M  DC    CL44' '\n         ORG   OLC013+75\n         DC    CL5'ERROR'\n         ORG   OLC013+81\n         SPACE 1\n         DC    CL81' '\n         ORG   *-81\nOLC110   DS    0A\n         DC    AL1(MSGPRT)\n         DC    C'DSB110 - EMPTY CHECK NOT DONE: '\nOLC110DS DC    CL44' '\n         ORG   OLC110+81\n         ENTRY DIRECTRY\n         PRINT   NOGEN\nDCB2     DCB   MACRF=(GL),DSORG=PS,EODAD=DSORGPSE,DDNAME=SYSUT1\nDIRECTRY DCB   MACRF=R,RECFM=F,BLKSIZE=256,                          XXX\n               LRECL=256,DSORG=PS,DEVD=DA,EODAD=EMPRDER,DDNAME=SYSUT1\nDIRECTAR DC    256X'00'\n         PRINT   NOGEN\n TITLE 'COPYUSER - SET UP COPY FOR USER LIB MEMBERS'\n         DS    0H\nCOPYUSER SECTION\n*\n         XC    COPYRC,COPYRC      RETURN CODE = 0\n*\n         MVI   OLC122M,C' '       CLEAR RESTORE MSG\n         MVC   OLC122M+1(43),OLC122M  ''\n*\n         L     R14,=V(SYSDSORG)   R14 -> TO SYSUT1 DSORG\n         CLC   0(2,R14),=X'0008'  IS IT VSAM?\n         BE    COPYVS             YES, CALL IDCAMS\n         TM    0(R14),X'02'       IS IT PO OR POU?\n         BO    COPYPO             YES, WE CAN HANDLE IT\n         TM    0(R14),X'20'       IS IT DA OR DAU?\n         BO    COPYDA             YES, COPY LIKE PS\n         TM    0(R14),X'40'       IS IT PS OR PSU?\n         BZ    RESTM8             NO, END FOR NOW\n         SPACE 1\nCOPYPS   DS    0H\n         PERFORM SEQCOPY          CALL THE SEQUENTIAL COPIER\n         MVC   OLC120A,=C'PS'     SAY IT WAS A PS FILE\n         B     COPYDONE           END FOR NOW\n         SPACE 1\nCOPYDA   DS    0H\n         PERFORM SEQCOPY          CALL THE SEQUENTIAL COPIER\n         MVC   OLC120A,=C'DA'     SAY IT WAS A DA FILE\n         MVC   OLC122M(L'DAREST),DAREST  FINISH RESTORE MSG\n         B     COPYDONE           END FOR NOW\n         SPACE 1\nCOPYVS   DS    0H\n         PERFORM IDCCOPY          CALL IDCAMS FOR EXPORT TEMPORARY\n         MVC   OLC120A,=C'VS'     SAY IT WAS A VSAM FILE\n         B     COPYDONE           END FOR NOW\n         SPACE 1\nCOPYPO   DS    0H\n         L       R1,=V(IEBSYSIN)    SET THE IEBCOPY SYSIN POINTER\n         PERFORM IEBCOPY\n         MVC   OLC120A,=C'PO'     SAY IT WAS A PO FILE\n         SPACE 1\nCOPYDONE DS    0H\n*        L     R2,=V(MAXCC)       ADDRESS OF MAX RC\n*        C     R15,0(0,R2)        THIS RC BIGGER THAN THE LAST ONE?\n*        BNH   NOTBIG2            NO\n*        ST    R15,0(0,R2)        YES, SAVE THIS RC\n         ST    R15,COPYRC         SAVE THIS RC\n         SPACE 1\nNOTBIG2  DS    0H\n         LTR   R15,R15            WAS COPY RC = 0 ?\n         BZ    COPYDON2           YES\n         OLCMSG OLC120E           NO, PRINT A WARNING MSG\n         SPACE 1\nCOPYDON2 DS    0H\n         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM\n         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?\n         BNE   COPYBACK           NO\n         SPACE 1\n         L     R6,=V(RESTREC)     R6 -> TO RESTORE RECORD\n         USING RESTRECD,R6        SET BASE\n         MVC   OLC120FR(4),RESTVSEQ MOVE FILE NBR TO MSG\n*        MVC   OLC120BR,RESTVSER  PUT VOLSER IN MSG\n         MVC   OLC120AR,RESTTYPE  PUT TYPE IN MSG\n         DROP  R6                 DROP RESTREC BASE\n*\n*              PUT VOLSERS INTO MSG\n*\n         SR    R4,R4              CLEAR R4\n         L     R1,=V(VOLSER2)     R1 -> TO VOLSERS\n         IC    R4,0(0,R1)         R4 = NBR VOLS\n         LA    R14,1(0,R1)        R14 -> TO VOLSERS\n         LA    R1,OLC120BR        R1 -> TO WHERE VOLSERS GO\n         SPACE 1\nVLOOP4   DS    0H\n         MVC   0(6,R1),0(R14)     PUT VOLSER IN MSG\n         MVI   6(R1),C','         PUT IN A COMMA\n         LA    R14,6(0,R14)       R14 -> TO NEXT VOLSER\n         LA    R1,7(0,R1)         R1 -> TO WHERE NEXT VOL GOES\n         BCT   R4,VLOOP4          PUT ALL VOLS IN\n         BCTR  R1,0               R1 -> TO LAST COMMA\n         MVI   0(R1),C' '         TAKE IT OFF\n         SPACE 1\n         OLCMSG  OLC120R          PRINT MSG\n         B     RESTM8             ON WE GO\n         SPACE 1\nCOPYBACK DS    0H\n         L     R1,=V(TUPAR7)      R1 -> TO OUTPUT FILE NBR\n         LH    R14,0(0,R1)        R14 = FILE NBR\n         CVD   R14,DWORD          CONVERT TO DECIMAL\n         UNPK  DWORD(5),DWORD+5(3) CONVERT TO DISPLAY\n         MVZ   DWORD+4(1),DWORD   FIX SIGN\n         MVC   OLC120F(4),DWORD+1 MOVE FILE NBR TO MSG\n*\n*              PUT TAPE VOLSER IN  MSG\n*\n         L     R2,=V(UT2JFCB)     R2 -> TO SYSUT2 JCFB              RH\n         USING IHAJFCB,R2         SET JFCB BASE AGAIN\n         SR    R1,R1              CLEAR R1\n         IC    R1,JFCBNVOL        R1 = NBR VOLUMES\n         BCTR  R1,0               -1 FOR HEX\n         MH    R1,=H'6'           R1 = OFFSET TO LAST VOL SLOT\n         LA    R1,JFCBVOLS(R1)    R1 -> TO LAST VOL\n         MVC   OLC120B,0(R1)      PUT VOLSER IN MSG\n         DROP  R2                 DROP JFCB BASE\n*\n*              READ THE SYSUT2 JFCB  AGAIN TO SEE IF THE VOLSER\n*              CHANGED DURING THE COPY....\n*\n         MVI   VOLSER2,X'01'      SAY ONLY 1 VOLSER\n         MVI   VOLSER2+1,X'40'    CLEAR VOLSERS AREA\n         MVC   VOLSER2+2(29),VOLSER2+1   ''\n         MVI   OLC120D,X'40'      CLEAR VOLSERS AREA\n         MVC   OLC120D+1(27),OLC120D  ''\n         L     R1,=V(JFCBXLSJ)    R1 -> TO JFCB EXIT LIST\n         L     R4,=V(UT2JFCB2)    R4 -> TO JFCB AREA 2\n         STCM  R4,7,0(R1)         PUT IT IN EXIT LIST\n*        XC    0(176,R4),0(R4)    MAKE SURE JFCB IS CLEAN\n         L     R2,=V(SYSUT2)      R2 -> SYSUT2 DCB\n         RDJFCB ((2))             GET THE SYSUT2 JFCB               RH\n         L     R1,=V(JFCBXLSJ)    R1 -> TO JFCB EXIT LIST\n         L     R2,=V(UT2JFCB)     R2 -> TO JFCB AREA 1\n         STCM  R2,7,0(R1)         PUT IT BACK IN EXIT LIST\n         LTR   R15,R15            WAS RDJFCB OKAY?                  RH\n         BNZ   NOVOL2A            IF NOT, NO VOLSER                 RH\n         MVC   VOLSER2,JFCBNVOL-IHAJFCB(R4) SAVE COUNT AND VOLSERS\n         IC    R15,VOLSER2        R15 = NBR VOLS\n         LA    R14,VOLSER2+1      R14 -> TO VOLSERS\n         LA    R1,OLC120B         R1 -> TO WHERE VOLSERS GO\n         SPACE 1\nVLOOP1   DS    0H\n         MVC   0(6,R1),0(R14)     PUT VOLSER IN MSG\n         MVI   6(R1),C','         PUT IN A COMMA\n         LA    R14,6(0,R14)       R14 -> TO NEXT VOLSER\n         LA    R1,7(0,R1)         R1 -> TO WHERE NEXT VOL GOES\n         BCT   R15,VLOOP1         PUT ALL VOLS IN\n         SPACE 1\nNOVOL2A  DS    0H\n         OLCMSG  OLC120           PRINT MSG\n         L       R1,=V(TUPAR1)    R1 -> TO OUTPUT DSN\n         MVC     OLC121M,0(R1)    PUT DSN INTO MSG\n         OLCMSG  OLC121           PRINT DSN PART OF MSG\n         CLC   OLC122M(5),=CL5' ' IS THERE A RESTORE MSG?\n         BE    RESTM1             NO\n         OLCMSG  OLC122           PRINT RESTORE MSG\n         SPACE 1\nRESTM1   NOP   RESTM8             B IF NO RESTORE FILE\n         SPACE 1\n         L     R5,=V(RESTORE)     R5 -> TO RESTORE DCB\n         USING IHADCB,R5          SET DCB BASE\n         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?\n         BZ    RESTM7             NO, DON'T SET UP AND WRITE RECORD\n         SPACE 1\n         MVI   SPCFLAG,0          ASSUME WE WILL GET SPACE\n         L     R14,=V(SYSDSORG)   R14 -> TO SYSUT1 DSORG\n         CLC   0(2,R14),=X'0008'  IS IT VSAM?\n         BE    NOMORE1            YES, CAN'T FIND SPACE USED\n*\n         L     R1,=V(VTOCDDN)     R1 -> TO VTOC DDNAME FIELD\n         MVC   0(6,R1),=C'SYSUT1' MOVE DDNAME TO VTOC DDN\n*\n         PERFORM RDVTOC           GO GET SPACE FOR SYSUT1\n         LTR   R15,R15            DID WE GET IT?\n         BZ    NOMORE2            YES, ON WE GO\n         SPACE 1\nNOMORE1  DS    0H\n         MVI   SPCFLAG,1          SAY NO SPACE\n         SPACE 1\nNOMORE2  DS    0H\n         LA    R1,OLC121M+43      R1 -> TO END OF TAPE DSN\n         LA    R14,44             R14 MAX DSN LTH\n         SPACE 1\nDSNLOOP  DS    0H\n         CLI   0(R1),C' '         FOUND END OF DSN?\n         BNE   DSNLOOP2           YES\n         BCTR  R14,0              NO, SUBT 1 FROM R14\n         BCT   R1,DSNLOOP         CHECK NEXT PREV CHAR\n         SPACE 1\nDSNLOOP2 DS    0H\n         LA    R1,OLC121M         NO, R1 -> TO START OF DSN\n         SPACE 1\nDSNLOOP4 DS    0H\n         LA    R6,RESTREC         R6 -> TO RESTORE RECORD\n         USING RESTRECD,R6        SET RECORD BASE\n         MVC   RESTDSN,0(R1)      PUT TAPE DSN IN RECORD\n         MVC   RESTTYPE,OLC120A   PUT TYPE IN RECORD\n         MVC   RESTVSER,OLC120B   PUT VOLSER IN RECORD\n         CLI   VOLSER2,X'01'      IS THERE A 2ND VOLSER?\n         BE    NOVOL2B            NO, ON WE GO\n         MVI   RESTVSER+6,C'*'    FLAG FOR 2ND VOLSER\n         SPACE 1\nNOVOL2B  DS    0H\n         MVC   RESTVSEQ,OLC120F   PUT VOL SEQ NBR IN RESTORE RECORD\n         L     R1,=V(USRDSN)      R1 -> TO DISK DSN\n         MVC   RESTDSN2,0(R1)     PUT DISK DSN IN RECORD\n         SPACE 1\n         CLI   SPCFLAG,1          DID WE GET SPACE ?\n         BE    NOSPACE            NO, CAN'T FILL IN RESTORE RECORD\n         L     R1,=V(SPCUSED)     R1 -> TO TRACKS USED\n         LH    R1,0(0,R1)         R1 =     TRACKS USED\n         CVD   R1,DWORD           CONVERT TO DECIMAL\n         UNPK  DWORD(5),DWORD+5(3) CONVERT TO DISPLAY\n         MVZ   DWORD+4(1),DWORD   FIX SIGN\n         MVC   RESTUSED,DWORD+1   PUT IT IN RECORD\n         SPACE 1\n         L     R1,=V(SPCSECN)     R1 -> TO SECONDARY ALLOCATION\n         LH    R1,0(0,R1)         R1 =     TRACKS USED\n         CVD   R1,DWORD           CONVERT TO DECIMAL\n         UNPK  DWORD(5),DWORD+5(3) CONVERT TO DISPLAY\n         MVZ   DWORD+4(1),DWORD   FIX SIGN\n         MVC   RESTSECN,DWORD+1   PUT IT IN RECORD\n         SPACE 1\n         MVC   RESTDIR,=CL4' '    CLEAR OUT DIRECTORY SIZE FIELD\n         CLC   RESTTYPE,=C'PO'    IS IT A PDS?\n         BNE   NOTPDS             NO, CAN'T BE ANY DIR BLKS THEN\n         L     R1,=V(DIRBLKS)     R1 -> TO DIRECTORY BLOCKS, IF ANY\n         LH    R1,0(0,R1)         R1 = NBR DIRECTORY BLKS\n         CVD   R1,DWORD           CONVERT TO DECIMAL\n         UNPK  DWORD(5),DWORD+5(3) CONVERT TO DISPLAY\n         MVZ   DWORD+4(1),DWORD   FIX SIGN\n         MVC   RESTDIR,DWORD+1    PUT IT IN RECORD\n         SPACE 1\nNOTPDS   DS    0H\n         L     R1,=V(SPCBLK)      R1 -> TO BLKSIZE\n         LH    R1,0(0,R1)         R1 =     TRACKS USED\n         CVD   R1,DWORD           CONVERT TO DECIMAL\n         UNPK  DWORD(5),DWORD+5(3) CONVERT TO DISPLAY\n         MVZ   DWORD+4(1),DWORD   FIX SIGN\n         MVC   RESTBLK,DWORD      PUT IT IN RECORD\n         SPACE 1\n         L     R1,=V(SPCLRECL)    R1 -> TO LRECL\n         LH    R1,0(0,R1)         R1 =     TRACKS USED\n         CVD   R1,DWORD           CONVERT TO DECIMAL\n         UNPK  DWORD(5),DWORD+5(3) CONVERT TO DISPLAY\n         MVZ   DWORD+4(1),DWORD   FIX SIGN\n         MVC   RESTLREC,DWORD     PUT IT IN RECORD\n         SPACE 1\n         L     R1,=V(DSNRECFM)    R1 -> TO RECFM\n         MVC   DWORD(1),0(R1)     SAVE RECFM\n         LA    R1,DWORD           R1 -> TO WORK RECFM\n         MVC   RESTRCFM,=C'   '   CLEAR OUT RECFM\n         MVI   RESTRCFM,C'U'      DEFAULT TO U\n         TM    0(R1),X'C0'        IS IT U?\n         BO    RECFMSET           YES\n*\n         LA    R14,RESTRCFM       R14 -> TO 1ST RECFM FIELD BYTE\n         BAL   R15,SETREC         GO SET RECFM...\n         LA    R14,RESTRCFM+1     R14 -> TO 2ND RECFM FIELD BYTE\n         BAL   R15,SETREC         GO SET RECFM...\n         LA    R14,RESTRCFM+2     R14 -> TO 3RD RECFM FIELD BYTE\n         BAL   R15,SETREC         GO SET RECFM...\n         B     RECFMSET           END OF RECFM STUFF...\n         SPACE 1\nSETREC   DS    0H\n         TM    0(R1),X'80'        IS IT FIXED?\n         BZ    SETRECA            NO\n         MVI   0(R14),C'F'        PUT F IN RECFM\n         NI    0(R1),255-X'80'    TURN OFF BIT\n         BR    R15                RETURN\n         SPACE 1\nSETRECA  DS    0H\n         TM    0(R1),X'40'        IS IT VARIABLE?\n         BZ    SETRECB            NO\n         NI    0(R1),255-X'40'    TURN OFF BIT\n         MVI   0(R14),C'V'        PUT V IN RECFM\n         BR    R15                RETURN\n         SPACE 1\nSETRECB  DS    0H\n         TM    0(R1),X'10'        IS IT BLOCKED?\n         BZ    SETRECC            NO\n         NI    0(R1),255-X'10'    TURN OFF BIT\n         MVI   0(R14),C'B'        PUT B IN RECFM\n         BR    R15                RETURN\n         SPACE 1\nSETRECC  DS    0H\n         TM    0(R1),X'08'        IS IT SPANNED?\n         BZ    SETRECD            NO\n         NI    0(R1),255-X'08'    TURN OFF BIT\n         MVI   0(R14),C'S'        PUT S IN RECFM\n         BR    R15                RETURN\n         SPACE 1\nSETRECD  DS    0H\n         TM    0(R1),X'04'        IS IT ANSI CONTROL?\n         BZ    SETRECE            NO\n         NI    0(R1),255-X'04'    TURN OFF BIT\n         MVI   0(R14),C'A'        PUT A IN RECFM\n         BR    R15                RETURN\n         SPACE 1\nSETRECE  DS    0H\n         TM    0(R1),X'02'        IS IT MACHINE CONTROL?\n         BZ    SETRECF            NO, END OF TESTS\n*        BZ    *+4+4+4            NO, END OF TESTS\n         NI    0(R1),255-X'02'    TURN OFF BIT\n         MVI   0(R14),C'M'        PUT M IN RECFM\n         SPACE 1\nSETRECF  DS    0H\n         BR    R15                RETURN\n         SPACE 1\nRECFMSET DS    0H\n         L     R1,=V(SPCTYPE)     R1 -> TO SPACE TYPE\n         MVC   RESTALOC,0(R1)     PUT IT IN RECORD\n         SPACE 1\nNOSPACE  DS    0H\n         L     R1,=V(USRVOL)      R1 -> TO INPUT VOLSER\n         MVC   RESTVOL,0(R1)      PUT VOLSER IN RECORD IN CASE VSAM\n         SPACE 1\n         PUT   (R5),RESTREC       WRITE RECORD\n         MVI   RESTREC,C' '       CLEAR RESTORE RECORD AREA\n         MVC   RESTREC+1(132),RESTREC  ''\n         CLI   VOLSER2,X'01'      IS THERE A 2ND VOLSER?\n         BE    NOVOL2C            NO, ON WE GO\n*\n         SR    R2,R2              CLEAR R2\n         IC    R2,VOLSER2         R2 = NBR VOLS\n         BCTR  R2,0               -1 CAUSE WE DID THE 1ST ONE\n         LA    R3,VOLSER2+7       R3 -> TO 2ND VOLSER\n         SPACE 1\nVLOOP2   DS    0H\n         MVC   RESTVSER,0(R3)     PUT VOLSER IN MSG\n         CH    R2,=H'1'           ONLY 1 LEFT?\n         BE    VLOOP3             YES, DON'T TURN ON MULT FLAG\n         MVI   RESTVSER+6,C'*'    FLAG FOR 2ND VOLSER\n         SPACE 1\nVLOOP3   DS    0H\n         PUT   (R5),RESTREC       WRITE RECORD\n         MVI   RESTVSER+6,C' '    TURN FLAG FOR 2ND VOLSER OFF\n         LA    R3,6(0,R3)         R3 -> TO NEXT VOLSER\n         BCT   R2,VLOOP2          -1 FOR THIS VOLSER\n*\n         SPACE 1\nNOVOL2C  DS    0H\n         B     RESTM8             END FOR NOW\n         DROP  R5                 DROP DCB BASE\n         DROP  R6                 DROP RECORD BASE\n         SPACE 1\nRESTM7   DS    0H\n         MVI   RESTM1+1,X'F0'     SAY NO FILE\n         SPACE 1\nRESTM8   DS    0H\n         L     R15,COPYRC         LOAD RETURN CODE\n         SPACE 1\nCOPYUSRE SECEXIT\n         SPACE 2\nSPCFLAG  DC    C'0'\nDWORD    DS    D\nCOPYRC   DC    F'0'\n*\n         ENTRY VOLSER2,OLC120B\nVOLSER2  DC    CL31' '            ROOM FOR 5 VOLSERS\nPATN     DC    X'4020202020'      SET UP EDIT PATTERN\nOLC120   DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    C'DSB120 - ABOVE '\nOLC120A  DC    CL2'PO'            DEFAULT FILE TYPE IS PO\n         DC    C' DATASET COPIED TO FILE '\nOLC120F  DC    CL4'0001'\n         DC    C' ON TAPE '\nOLC120B  DC    CL6' '             TAPE VOLSER GOES HERE\nOLC120C  DC    C','\nOLC120D  DC    4CL7' '            ROOM FOR 4 MORE VOLSERS\n         ORG   OLC120+81\n*\nOLC120E  DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    C'DSB120E - WARNING.... THIS COPY HAD A NON-ZERO'\n         DC    C' RETURN CODE. CHECK OUTPUT......'\n         ORG   OLC120E+75\n         DC    CL5'ERROR'\n         ORG   OLC120E+81\n         SPACE 1\nOLC120R  DS    0CL81\n         DC    AL1(MSGPRT)\n         DC    C'DSB120R - ABOVE '\nOLC120AR DC    CL2'PO'            DEFAULT FILE TYPE IS PO\n         DC    C' DATASET RESTORED FROM FILE '\nOLC120FR DC    CL4'0001'\n         DC    C' ON TAPE '\nOLC120BR DC    CL6' '             TAPE VOLSER GOES HERE\n         DC    CL(81-(*-OLC120R))' '\n*\nOLC121   DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    CL14' '\n         DC    C' DSN='\nOLC121M  DC    CL44' '\n         ORG   OLC121+81\n*\nOLC122   DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    C'DSB122 - FOR RESTORE, USE '\nOLC122M  DC    CL54' '\n         ORG   OLC122+81\nPSREST   DC    C'IEBGENER OR ANY SEQUENTIAL COPY PGM'\nDAREST   DC    C'A DIRECT ACCESS LOAD PROGRAM'\nPOREST   DC    C'PDSFAST OR IEBCOPY'\nVSREST   DC    C'IDCAMS IMPORT COMMAND'\n         SPACE 1\n         ENTRY RESTREC    ,RESTTYPE,RESTVSEQ,RESTDSN\n         DS    0F                 PUT ON FULLWORD BOUNDARY...\nRESTREC  DC    CL200' '\nRESTRECD DSECT\nRESTDSN2 DC    CL44' '            DISK DATASET NAME\n         DC    C' '\nRESTTYPE DC    CL2' '\n         DC    C' '\nRESTVSER DC    CL6' '\n         DC    C' '\nRESTVSEQ DC    CL4' '\n         DC    C' '\nRESTUSED DC    CL4' '             NBR OF TRKS USED\n         DC    C' '\nRESTSECN DC    CL4' '             SECONDARY ALLOCATION\n         DC    C' '\nRESTDIR  DC    CL4' '             NUMBER OF DIR BLOCKS IF PDS\n         DC    C' '\nRESTBLK  DC    CL5' '             BLKSIZE\n         DC    C' '\nRESTLREC DC    CL5' '             LRECL\n         DC    C' '\nRESTRCFM DC    CL3' '             DATASET RECFM\n         DC    C' '\nRESTALOC DC    CL3'CYL'           TYPE OF ALLOCATION\n         DC    C' '\nRESTVOL  DC    CL6' '             VOLSER FOR UNCATALOGUED DATASETS,\n         DC    C' '\nRESTDSN  DC    CL44' '            TAPE DATASET NAME\n*                                 OR THE VOLSER OF THE CATALOG FOR VSAM\n         DC    CL(L'RESTREC-(*-RESTDSN2))' ' FOR FUTURE EXPANSION.. RH\n*\n TITLE 'DYNFREE - FREE A USER LIBRARY'\n*\n*  FREE A USER LIBRARY'\n*\n         DS    0H\nDYNFREE  SECTION\n*\n         L     R4,=V(INFILE)      R4 -> TO SYSUT1 DCB\n         TM    48(R4),X'10'       DID SYSUT1 GET CLOSED?\n         BZ    NOCLOSE4           YES\n         CLOSE ((4))              NO, CLOSE IT\n         USING IHADCB,R4          SET R4 AS DCB DSECT\n         L     R15,DCBBUFCB       R15 = A(BUFFER)\n         BCTR  R15,0              -1\n         LTR   R15,R15            IS THERE A BUFFER?\n         BZ    NOPOOL10           NO\n         DROP  R4                 DROP R4 AS DCB DSECT\n         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB\n*                                 IBM DON'T\n         SPACE\nNOPOOL10 DS    0H\n         SPACE 1\nNOCLOSE4 DS    0H\n         L     R4,=V(SYSUT2)      R4 -> TO SYSUT2 DCB\n         TM    48(R4),X'10'       DID SYSUT2 GET CLOSED?\n         BZ    NOCLOSE5           YES\n         CLOSE ((4))              NO, CLOSE IT THEN\n         USING IHADCB,R4          SET R4 AS DCB DSECT\n         L     R15,DCBBUFCB       R15 = A(BUFFER)\n         BCTR  R15,0              -1\n         LTR   R15,R15            IS THERE A BUFFER?\n         BZ    NOPOOL11           NO\n         DROP  R4                 DROP R4 AS DCB DSECT\n         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB\n*                                 IBM DON'T\n         SPACE\nNOPOOL11 DS    0H\n         SPACE 1\nNOCLOSE5 DS    0H\n         SR    R15,R15            MAKE SURE R15 = 0\n         L     R2,=V(FREEFLAG)    R2 -> TO FREEFLAG\n         TM    0(R2),X'80'        DID THE ALLOCATE WORK?\n         BZ    DYNFRET            NO, DON'T TRY TO FREE IT\n*\n*              APR 4/95...IT LOOKS LIKE SOMETHING HAS CHANGED AND\n*              THE VSAM DATASET IS NOT ALLOCATED, SO DON'T TRY\n*              TO FREE IT....\n*\n         L     R3,=V(RESTREC)     R3 -> TO RESTORE RECORD\n         USING RESTRECD,R3        SET RECORD BASE\n         CLC   RESTTYPE,=C'VS'    IS IT A VSAM FILE?\n         BE    DYNFRET            YES, DON'T TRY TO FREE IT\n         DROP  R3                 DROP RECORD BASE\n         SPACE 1\n         LA    R2,DYNRB2          CLEAR OUT RETURN AREA\n         USING S99RB,R2\n         XC    S99RSC,S99RSC\n         LA    R1,DYNPTR2         POINTER TO PARM LIST FOR DYNALLOC\n         DYNALLOC\n         LTR   R11,R15            SAVE RET CODE OVER MSG PRINT\n         BZ    DYNFRET            IT WAS OKAY\n         SPACE 1\n         AGO   .SKIP99\n         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM\n         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?\n         BNE   SENDMSG            NO\n         SPACE 1\n         L     R4,=V(SYSUT2)      R4 -> TO SYSUT2 DCB\n*        USING IHADCB,R4          SET DCB DSECT\n         TM    48(R4),X'10'       IS SYSUT2 OPEN ?\n         BZ    SENDMSG            NO, TOO BAD\n         CLOSE ((4))              CLOSE IT THEN\n         USING IHADCB,R4          SET R4 AS DCB DSECT\n         L     R15,DCBBUFCB       R15 = A(BUFFER)\n         BCTR  R15,0              -1\n         LTR   R15,R15            IS THERE A BUFFER?\n         BZ    NOPOOL12           NO\n         DROP  R4                 DROP R4 AS DCB DSECT\n         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB\n*                                 IBM DON'T\n         SPACE\nNOPOOL12 DS    0H\n*                                 TRY FREEING IT AGAIN\n         LA    R2,DYNRB2          CLEAR OUT RETURN AREA\n         USING S99RB,R2\n         XC    S99RSC,S99RSC\n         LA    R1,DYNPTR2         POINTER TO PARM LIST FOR DYNALLOC\n         DYNALLOC\n         LTR   R11,R15            SAVE RET CODE OVER MSG PRINT\n         BZ    DYNFRET            IT WAS OKAY\n         SPACE 1                                                    RH1\nSENDMSG  DS    0H\n.SKIP99  ANOP\n         L     R2,=V(USRDSN)      GET ADDRESS OF INPUT DSNAME\n         MVC   OLC009M,0(R2)       MOVE DSNAME TO ERROR MSG\n         OLCMSG OLC009\n         L     R2,=V(OLC007W)     GET ADDRESS OF MSG\n         L     R3,=V(HEXTRANS)    GET ADDRESS OF TRANS TABLE\n         L     R4,=V(OLC007ER)    GET ADDRESS OF MSG\n         L     R5,=V(OLC007IN)    GET ADDRESS OF MSG\n         UNPK  0(9,R2),S99RSC(5)  MAKE HEX RETURN CODE PRINTABLE\n         TR    0(8,R2),0(R3)      TRANSLATE\n         MVC   0(4,R4),0(R2)      MOVE ERROR CODE TO TEXT LINE\n         MVC   0(4,R5),4(R2)      MOVE INFO CODE TO TEXT LINE\n         L     R2,=V(OLC007)      GET ADDRESS OF MSG\n         OLCMSG 0(0,R2)\n         LA    R15,36             END FOR NOW\n*        SR    R15,R15            IGNORE DE-ALLOC ERRORS (FOR NOW)\n         SPACE 1\nDYNFRET  SECEXIT\n         DROP  R2                 DROP RB BASE\n         SPACE 2\nOLC009   DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    C'DSB009 - DE-ALLOCATE FAILED FOR DSN: '\nOLC009M  DC    CL44' '\n         ORG   OLC009+81\nDYNPTR2  DC    0F'0',X'80',AL3(DYNRB2)\nDYNRB2   DC    0F'0',AL1(20,S99VRBUN,0,0),AL4(0,DYNTUPLU,0,0)\nDYNTUPLU DC    X'80',AL3(DYNTUNT3)\n*\n TITLE 'ESTAEOF  - TURN OFF ESTAE'\n*\n*  TURN OFF ESTAE\n*\n         DS    0H\nESTAEOF  SECTION\n         ESTAE    0               TURN OFF MOST CURRENT ESTAE\n         LTR   R15,R15            WENT OFF OK?\n         BZ    RETESTH            GO RETURN TO CALLER\n         LR    R9,R15             ESTAE RETURN CODE WAS NOT = 0\n         CVD   R15,ESTHRC\n         OI    ESTHRC+7,X'0F'     MAKE POSITIVE\n         UNPK  OLC017RC,ESTHRC\n         OLCMSG OLC017\n         LR    R15,R9             SET RETURN CODE\nRETESTH  SECEXIT\n         SPACE    2\nOLC017   DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    C'DSB017 - NON-ZERO RETURN CODE FROM ESTAE CANCEL. RC='\nOLC017RC DC    CL7' '\n         ORG   OLC017+75\n         DC    CL5'ERROR'\n         ORG   OLC017+81\nESTHRC   DC       D'0'\n TITLE 'STAEEXIT - RECEIVE CONTROL IF AN ABEND OCCURS'\nSTAEEXIT CSECT\nSTAEEXIT AMODE 24\nSTAEEXIT RMODE 24\n**********************************************************************\n***                                                                ***\n***             S T A E   E X I T   R O U T I N E                  ***\n***                                                                ***\n**********************************************************************\n         SPACE    2\n         USING    STAEEXIT,R10\n         LR       R10,R15          SET UP BASE REGISTER R10\n         LR       R8,R14           R8 <--- RETURN ADDRESS TO RTM\n         LM       R4,R7,=V(RUBAREA,ABENDCDE,STAERTRY,SYNCSAVE)\n         C        R0,=F'12'        NO SDWA ALLOCATED ?\n         BE       NOSDWA\n         SPACE    1\n* PREPARE THE REGISTER UPDATE BLOCK USED TO SET UP REGS FOR RETRY:\n         MVC      2(L'RUBREGS,R4),0(R7)  SET UP THE RUB REGISTERS\n*                                        FROM SYNCSAVE\n         MVC      RUBREG7,=X'FFFFABED' SET R7 IN RUB TO SHOW THAT\n*                                      WE ARE IN ABEND\n         USING    SDWA,R1\n         PRINT   GEN\n         SETRP    RETADDR=(R6),RC=4,FRESDWA=YES,RETREGS=YES,           +\n               RUB=(R4),DUMP=NO\n         PRINT NOGEN\n         MVC      5(3,R5),SDWACMPC     GET ABEND CODE\n         MVC      0(4,R5),SDWACTL1+4   GET ABEND ADDRESS\n         MVI      0(R5),X'00'     CLEAR 1ST BYTE\n         L     R2,SDWAGR12        R2 = CSECT BASE REG\n         MVC   8(8,R5),=CL8'??'   ASSUME NO CSECT NAME\n         CLI   5(R2),C'A'         IS THERE A CSECT NAME?\n         BL    NOCSECT            NO\n         CLI   5(R2),C'Z'         IS THERE A CSECT NAME?\n         BH    NOCSECT            NO\n         MVC   8(8,R5),5(R2)      SAVE CSECT NAME\n         L     R15,0(0,R5)        R15 = ABEND ADDRESS\n         SR    R15,R2             R15 = OFFSET IN CSECT\n         ST    R15,0(0,R5)        PASS OFFSET TO RETRY RTN\n         SPACE 1\nNOCSECT  DS    0H\n         BR       R8              RETURN TO RTM SO HE CAN GO TO RETRY\n         SPACE    2\nNOSDWA   LA       R15,4                ASK FOR RETRY ANYWAY ????\n*                                      WHAT ABOUT MY REGS AT RETRY????\n         LA       R0,0(,R6)            SET UP RETRY ADDRESS\n         ST       R1,4(0,R5)           STORE THE ABEND CODE\n         MVC      0(4,R5),=XL4'AAAAAAAA'  ABEND ADDRESS UNKNOWN\n*        ST       R1,0(,R5)            STORE THE ABEND CODE\n*        MVC      4(4,R5),=XL4'AAAAAAAA'  ABEND ADDRESS UNKNOWN\n         BR       R8              RETURN TO RTM SO HE CAN GO TO EXIT\n         LTORG\n         SPACE 2\n**********************************************************************\n*\n*  STAEEXIT:\n*\n*        S T A E   R E G I S T E R   U P D A T E   B L O C K  (RUB)\n*\n**********************************************************************\n         SPACE    1\n         ENTRY  RUBREGS,RUBAREA\n         CNOP   2,4                   GUARANTEE NOT FULLWORD ALLIGN\nRUBAREA  DC     XL2'FFFF'           SET UP TO RESTORE ALL REGS\nRUBREGS  DS     0CL64\nRUBREG0  DC     F'1311'  THIS ARE SET BY ESTAE EXIT TO CORRECT VALUE\nRUBREG1  DC     F'1311'     \"       RUB FOR SEGMENT ADDRESS\nRUBREG2  DC     F'1311'             RUB FOR SEGMENT ADDRESS\nRUBREG3  DC     F'1311'             RUB FOR SEGMENT ADDRESS\nRUBREG4  DC     F'1311'             RUB FOR SEGMENT ADDRESS\nRUBREG5  DC     F'1311'             RUB FOR SEGMENT ADDRESS\nRUBREG6  DC     F'1311'             RUB FOR SEGMENT ADDRESS\nRUBREG7  DC     F'1311'             RUB FOR SEGMENT ADDRESS\nRUBREG8  DC     F'1311'             RUB FOR SEGMENT ADDRESS\nRUBREG9  DC     F'1311'             RUB FOR SEGMENT ADDRESS\nRUBREG10 DC     F'1311'             RUB FOR SEGMENT ADDRESS\nRUBREG11 DC     F'1311'             RUB FOR SEGMENT ADDRESS\nRUBREG12 DC     F'1311'             RUB FOR SEGMENT ADDRESS\nRUBREG13 DC     F'1311'             RUB FOR SEGMENT ADDRESS\nRUBREG14 DC     F'1311'             RUB FOR SEGMENT ADDRESS\nRUBREG15 DC     F'1311'             RUB FOR SEGMENT ADDRESS\n**********************************************************************\n         DROP  R1,R10\n TITLE 'MSGRTN - MESSAGE PRINT ROUTINE'\n         DS    0H\nMSGRTN   SECTION\n*\n* ERROR RTN. PUT OUT ALL SORTS OF ERROR MSGS. ABEND IF NECESSARY.\n*    WARNING - THIS CODE IS NOT REENTRANT. IN CASE OF MULTI-TCB IMPL.\n*\n         USING MSGDSECT,R2        R1 POINTS TO MSG\n         LR    R2,R1              CANNOT USE R1 OVER SYSTEM CALLS\n         TM    MSGCODE,MSGWTL     REQUESTED TO WRITE TO LOG ?\n         BNO   MSGLPUT            NO, JUMP OVER\n         MVC   WTLL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTLL\n         MVC   WTLL+8(L'MSGTEXT),MSGTEXT\n         WTO   MF=(E,WTLL)        WRITE MSG TO THE JOB LOG\nMSGLPUT  TM    MSGCODE,MSGPRT     REQUESTED TO WRITE TO OLCPRINT ?\n         BNO   MSGLWTOG           NO, JUMP OVER\n         L     R5,=V(OLCPRINT)     LOAD DCB ADDRESS\n         PUT   (R5),MSGTEXT       WRITE MSG ON OLCPRINT\nMSGLWTOG TM    MSGCODE,MSGWTOLG   REQ TO WRITE CONSOLE EYECATCHER ?\n         BNO   MSGLWTO            NO, JUMP OVER\n         MVC   WTOL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTOL\n         MVC   WTOL+8(L'WTOEYE1),WTOEYE1\n         WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE\n         MVC   WTOL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTOL\n         MVC   WTOL+8(L'WTOEYE2),WTOEYE2\n         WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE\n         MVC   WTOL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTOL\n         MVC   WTOL+8(L'WTOEYE3),WTOEYE3\n         WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE\n         MVC   WTOL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTOL\n         MVC   WTOL+8(L'WTOEYE2),WTOEYE2\n         WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE\nMSGLWTO  TM    MSGCODE,MSGWTO     REQUESTED TO WRITE TO CONSOLE ?\n         BNO   MSGWTOG2           NO, JUMP OVER\n         MVC   WTOL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTOL\n         MVC   WTOL+8(L'MSGTEXT),MSGTEXT\n         WTO   MF=(E,WTOL)        WRITE MSG TO CONSOLE\nMSGWTOG2 TM    MSGCODE,MSGWTOLG   REQ TO WRITE CONSOLE EYECATCHER ?\n         BNO   MSGLSGNL           NO, JUMP OVER\n         MVC   WTOL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTOL\n         MVC   WTOL+8(L'WTOEYE2),WTOEYE2\n         WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE PART 2\n         MVC   WTOL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTOL\n         MVC   WTOL+8(L'WTOEYE1),WTOEYE1\n         WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE PART 2\nMSGLSGNL DS    0H\n         SPACE 1                                                    RH\nMSGLABND TM    MSGCODE,MSGABND    REQUESTED TO ABEND ?\n         BNO   MSGRC0             NO - THEN RETURN WITH RC=0\n         ABEND 1211,DUMP\n         SPACE 1                                                    RH\nMSGRC0   DS    0H\n         LA    R15,0              RC = 0                            RH\n         SPACE 1                                                    RH\nMSGEXIT  SECEXIT                  RETURN TO CALLER\n         DROP  R2\n* WTLL BELOW MUST BE 88 LONG TO HANDLE 80 BYTE MSGS.\nWTLL     WTO      '                                                    +\n                                                    ',MF=L,  LEN=88    +\n               ROUTCDE=11\n* WTOL BELOW MUST BE 88 LONG TO HANDLE 80 BYTE MSGS.\nWTOL     WTO      '                                                    +\n                                                    ',MF=L,  LEN=88    +\n               ROUTCDE=11         ROUTCDE=1 WHEN TO CONSOLE\nWTOEYE1  DC       CL45'**********************************************'\nWTOEYE2  DC       CL45'***                                        ***'\nWTOEYE3  DC       CL45'***        ATTENTION - IMSTEST MTO         ***'\n*\nMSGBLK   DC       CL80' '    TO BLANK OUT THE WTOL AND WTLL AREAS\n*                 CL80  ABOVE MUST BE LENGTH 80 IF WTOL AND WTLL LISTS\n*                       ARE 88 LONG. ALL MSG HAVE 1ST 4 CHARS AS BLANK\n*                       SO AS NOT TO CLOBBER STUPID WTL MACRO.\n*-----------------------------------------------------------------\n*\n         SPACE 2\nMSGDSECT DSECT\nMSGCODE  DS       X\nMSGPRT   EQU      X'01' PRINT THE MSG ON DDNAME=OLCPRINT\nMSGWTL   EQU      X'02' WRITE THE MSG TO THE JOB LOG\nMSGWTO   EQU      X'04' WRITE THE MSG TO THE OPERATOR CONSOLE/SYSLOG\nMSGWTOLG EQU      X'08' WRITE A LARGE EYE CATCHER ON THE CONSOLE/SYSLOG\nMSGSGNL  EQU      X'10' START THE \"SIGNAL\" MESSAGE REGION\nMSGABND  EQU      X'80' ABEND AFTER PUTTING OUT MSGS AND SIGNAL MPR\nMSGTEXT  DS       CL80  THE TEXT OF THE ERROR MSG\n         SPACE    2\n         AGO   .NOBLKS\n TITLE 'USERBLKS - GET BLKSIZE OF USER DATASET'\n*\n*\nUSERBLKS SECTION\n         L     R1,=V(HOLDDCB)     R1 -> TO HOLD DCB                 RH\n         USING IHADCB,R1\n         MVC   DCBDDNAM,=C'USERLIB ' PUT USER DDNAME INTO DCB       RH\n         DROP  R1\n         STCM  R1,7,USRJFCB       PUT A(DCB) INTO RDJFCB BLOCK      RH\n         L     R2,=V(USRDSN)      R2 -> TO USER DATASET NAME        RH\n         SPACE 1\n*        RDJFCB (1)               GET THE USER JFCB                 RH\n         CNOP  0,4                GET ON TO A FULLWORD BOUNDARY     RH\n         BAL   R1,JFCBSVC         POINT R1 TO DCB ADDRESS, DO SVC   RH\n         DC    X'80'              1ST BYTE IS 80                    RH\nUSRJFCB  DC    AL3(0)             DCB ADDRESS, SET ABOVE            RH\nJFCBSVC  SVC   64                 DO RDJFCB                         RH\n         LTR   R15,R15            GET IT?                           RH\n         BNZ   USRABEND           IF NOT  NO BLKSIZE                RH\n         L     R1,=V(HOLDJFCB)    R1 -> TO USER JCFB                RH\n         USING IHAJFCB,R1\n         L     R2,=V(HBLKSIZE)    R2 -> TO HOLD BLKSIZE             RH\n         LH    R2,0(0,R2)         R2 = HOLD BLKSIZE                 RH\n         CH    R2,JFCBLKSI        HOLD BLKSIZE >= LIB BLKSIZE       RH\n         BNL   USRRETN            YES, BLKSIZE IS OKAY              RH\n         DROP     R1\n         OLCMSG   OLC080          SEND MSG                          RH\n         B     USRERR             GO SET RC AND RETURN              RH\n         SPACE    2\nUSRABEND DS       0H\n         OLCMSG   OLC070          SEND MSG AND SET RC               RH\nUSRERR   DS    0H\n         LA    R15,4              SET RC = 4\n         B     USRRETN2           RETURN\nUSRRETN  DS    0H\n         SR    R15,R15            SET RC = 0\nUSRRETN2 DS    0H\nUSRRETN9 SECEXIT                  RETURN TO CALLER\n         EJECT\n*\n* USERBLKS DATA:\n*\nOLC070   DC    AL1(MSGWTL+MSGWTOLG+MSGWTO+MSGSGNL+MSGABND)\n         DC    C'OLC070 - RDJFCB FAILED, DATASET NOT PROCESSED'\n         DC    CL(81-(*-OLC070))'  '\nOLC080   DC    AL1(MSGWTL+MSGPRT)\n         DC    C'OLC080 - BLKSIZE TOO LARGE, DATASET NOT PROCESSED'\n         DC    CL(81-(*-OLC080))'  '\n.NOBLKS  ANOP\n         PRINT     GEN\n TITLE 'SCRATCHU - READ/CLEAR OUT LIBRARY DIRECTORY'\n         DS    0H\nSCRATCHU SECTION\n*\n         USING    IHADCB,R5          DCB BASE\n         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM\n         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?\n         BE    SCRCHU             YES\n         MVI   SCRFLAG,C'B'       NO, SET FLAG\n         LA       R5,IDCB         R5 -> TO INPUT DCB\n         MVI   DCBDDNAM+5,C'1'    CHANGE DDNAME TO SYSUT1\n         SPACE 1\nSCRCHU   DS    0H\n***********************************************************************\n* SET UP THE OUTPUT DATASET\n***********************************************************************\n*\n* FILL IN THE DCB\n*\n         LA       R5,ODCB\n*\n* ISSUE DEVTYPE TO GET DEVICE INFO\n*\n         DEVTYPE  DCBDDNAM,DEVINFO,DEVTAB\n         LTR      R15,R15            ANY ERRORS?\n         BNZ      SCRERR1            THEN PRINT MSG AND RETURN\n*\n* OPEN THE DIRECTORY FOR INPUT\n*\n         OPEN     (IDCB,(INPUT))\n         LA       R5,IDCB            INPUT DCB\n         TM       DCBOFLGS,DCBOFOPN  OPEN OKAY?\n         BZ       SCRERR2            IF NOT THEN PRINT MSG AND RETURN\n         CLI   SCRFLAG,C'B'       IS THIS A BACKUP?\n         BE    READDIR1           YES\n*\n* OPEN THE DIRECTORY FOR OUTPUT\n*\n         OPEN     (ODCB,(OUTPUT))\n         LA       R5,ODCB            OUTPUT DCB\n         TM       DCBOFLGS,DCBOFOPN  OPEN OKAY?\n         BZ       SCRERR1            IF NOT THEN PRINT MSG AND RETURN\n         DROP     R5\n*\n* POINT TO THE FIRST DIRECTORY RECORD\n*\n         POINT    ODCB,=F'512'       POINT TO DIRECTORY\n*\n* ISSUE XDAP MACRO WRITE A RECORD OF ALL 'FF' TO INDICATE EMPTY PDS\n*\n         XDAP     XDAPECB,WI,ODCB,FOX,8+256,,DCBFDAD-IHADCB+ODCB\n         WAIT     ECB=XDAPECB        WAIT FOR COMPLETION OF XDAP\nREADDIR1 DS       0H\n         POINT    IDCB,=F'512'       POINT TO DIRECTORY\n         LA    R2,1               SET R2 TO 1\n*        SR    R2,R2              CLEAR R2\n*\n* LOOP TO COUNT DIRECTORY RECORDS\n*\nREADLOOP DS       0H\n*\n* READ DIRECTORY BLOCKS\n*\n         READ     RDECB,SF,IDCB,DUMMY,256   READ\n         CHECK    RDECB              WAIT FOR COMPLETION OF READ\n         LA    R2,1(0,R2)         ADD 1 TO COUNTER\n         B        READLOOP           DO IT AGAIN\n*\n* GET HERE VIA EODAD AT END OF DIRECTORY\n*\nENDREAD  DS       0H\n         CLI   SCRFLAG,C'B'       IS THIS A BACKUP?\n         BE    READDIR2           YES\n         NOTE     IDCB             GET TTR OF LAST DIRRECTORY BLOCK\n         STH      R1,DEVCYLS       SAVE NUM RECS ON THIS TRK\n         AH       R1,=H'256'       INCREMENT RECORD # TO POINT TO EOF\n         ST       R1,DCBRELAD-IHADCB+ODCB STORE TTR IN DCB SO THAT\n*                                  NEXT STOW WILL POINT TO FIRST MEMBER\n*                                  - IT WILL ALSO BE USED AS POINT PARM\n         EJECT\n**************************************************************\n*       CALL STAR ROUTINE TO CALCULATE THE TRACK BALANCE     *\n*       REMAINING AFTER THE LAST DIRECTORY BLOCK.            *\n**************************************************************\n         LA       R0,STARDEND-STARDSEC SIZE OF STAR AREA\n         GETMAIN  R,LV=(0)         GET STORAGE\n         STM      R2,R13,STARSAVE-STARDSEC(R1) SAVE REGISTERS\n         LR       R2,R1            SET STAR AREA BASE\n         USING    STARDSEC,R2\n         XC       STARDSEC(12),STARDSEC CLEAR STAR AREA\n         L        R4,DCBDVTBL-IHADCB+ODCB DEV CHAR ENTRY\n         LA       R4,0(R4)\n         SR       R0,R0            CLEAR RKDD REGISTER\n         ICM      R0,8,DCBRELAD+2-IHADCB+ODCB LAST R +1\n         ICM      R0,4,=X'08'      SET KEY LENGTH (8)\n         ICM      R0,3,=H'256'     SET DATA LENGTH (256)\n         LA       R1,STARDSEC      ADDRESS OF STAR AREA\n         TRKCALC  FUNCTN=TRKBAL,DEVTAB=(R4),RKDD=(R0),                 X\n               MF=(E,(1))\n         STH      R0,DCBTRBAL-IHADCB+ODCB TRACK BALANCE\n         LR       R1,R2            STAR AREA BASE\n         LM       R2,R13,STARSAVE-STARDSEC(R1) RELOAD REGS\n         DROP     R2\n         LA       R0,STARDEND-STARDSEC SIZE TO FREE\n         FREEMAIN R,LV=(0),A=(1)   FREE STORAGE\n         L        R1,DCBRELAD-IHADCB+ODCB     RELOAD ADJ TTR\n         MVI      DCBDIRCT+1-IHADCB+ODCB,0 INDICATE THAT LAST\n*                                  DIRECTORY BLOCK IS UNUSED\n         CL       R1,=F'512'       ONLY ONE DIRECTORY BLOCK?\n         BH       NOTONEB          NO\n         MVI      DCBDIRCT+1-IHADCB+ODCB,12 INDICATE 12 BYTES USED\nNOTONEB  DS       0H               POINT TO START OF MEMBER SPACE\n         POINT    ODCB,DCBRELAD-IHADCB+ODCB\n         OI       DCBOFLGS-IHADCB+ODCB,X'80' SET WRITE BIT IN DCB SO\n*                                  THAT DCBFDAD IS USED TO UPDATE DSCB\n*                                  AND DCBTRBAL IS CONSIDERED VALID\n*\n* CLOSE THE OUTPUT DATASET\n*\n         CLOSE    ODCB\n         SPACE 1\nCLOSIDCB DS    0H\n         CLOSE    IDCB\n         SR    R15,R15            ZERO RETURN CODE\n         B     SCRRET\n         SPACE 1\nREADDIR2 DS    0H\n         STH   R2,DIRBLKS         SAVE NBR DIRECTORY BLKS\n         B     CLOSIDCB           GO CLOSE DCB\n         SPACE 1\nSCRERR2  EQU   *\n         CLOSE ODCB\nSCRERR1  EQU   *\n         L     R2,=V(USRDSN)      GET ADDRESS OF INPUT DSNAME\n         MVC   OLC004M,0(R2)      MOVE DSNAME TO ERROR MSG\n         OLCMSG OLC004\n         LA    R15,4              INDICATE EMPTY LIBRARY\nSCRRET   SECEXIT\n         EJECT\n***********************************************************************\n* SCRATCHU CONSTANTS AND DEFINITIONS\n***********************************************************************\nOLC004   DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGWTL+MSGPRT)\n         DC    C'OLC004 - ERROR IN CLEARING DS: '\nOLC004M  DC    CL44' '\n         ORG   OLC004+81\n*\n* DUMMY DIRECTORY ENTRY FOR XDAP\n*\nFOX      DC       8X'FF'           HARDWARE DEFINED KEY\n         DC       AL2(14)          LENGTH OF DUMMY ENTRY\n         DC       8X'FF'           NAME OF DUMMY ENTRY\n         DC       4X'0'            TTRC\nDUMMY    DC       256X'00'         256 BYTE DUMMY RECORD\n         PRINT   NOGEN\nODCB     DCB   MACRF=(W),DSORG=PO,EXLST=EXLST,DDNAME=SYSUT2\nIDCB     DCB   MACRF=(R),DSORG=PO,EODAD=ENDREAD,EXLST=EXLST,RECFM=U,   +\n               DDNAME=SYSUT2\nEXLST    DS    0F\n         DC    AL1(133)\n         DC    AL3(DCBEXI2)        ADDR OF EXIT ROUTINE\n         DROP  R12                DROP SECTION BASE\nDCBEXI2  DS    0H\n         USING IHADCB,R1\n         USING *,R15\n         L     R5,DEVBLKSZ         GET MAX BLOCK SIZE\n         OC    DCBBLKSI,DCBBLKSI   DO WE HAVE A BLOCK SIZE?\n         BNZ   DCBEXI2A            YES - BRANCH\n         STH   R5,DCBBLKSI         NO - USE TRACK CAPACITY\nDCBEXI2A DS    0H\n         BR    R14\n         SPACE 1\nSCRFLAG  DC    C' '               BACKUP/RESTORE FLAG\n         ENTRY DIRBLKS\nDIRBLKS  DC    H'0'               NUMBER OF DIR BLKSG\nDEVINFO  DS    0D\n         DS    F\nDEVBLKSZ DS    F                   MAX TRACK CAPACITY\nDEVCYLS  DS    H                   NUMBER OF CYLS ON DEVICE\nDEVTRKS  DS    H                   NUMBER OF TRKS ON DEVICE\nDEVMTRKL DS    H                   MAXIMUM TRACK LENGTH\nDEVKBNL  DS    X                   KEYED BLOCK OVERHEAD - NOT LAST\nDEVKBL   DS    X                   KEYED BLOCK OVERHEAD - LAST\nDEVNKB   DS    X                   NON KEYED BLOCK OVERHEAD\nDEVTOLFG DS    X                   DEVICE TOLERANCE FLAG\nDEVTOLRQ EQU   X'01'                  TOLERANCE FACTOR REQUIRED\nDEVOHHWD EQU   X'08'                  BLOCK OVERHEAD HALFWORD\nDEVTOLFT DS    H                   TOLERANCE FACTOR AMOUNT\nSTARDSEC DSECT\n         TRKCALC MF=D              STAR PARAMETER AREA\nSTARSAVE DS    12F                 REGISTER SAVEAREA\nSTARDEND DS    0F                  SIZE DELIMITER\n         DROP  R15\n*\n*\n TITLE 'READ VTOC TO GET DSCB FOR DATA SET'\n         DS    0H\nRDVTOC   SECTION DROP=NO\n*\n*/*\n***********************************************************************\n*                                                                     *\n*             MODULE NAME = VTOCRD                                    *\n*                                                                     *\n*             DESCRIPTIVE NAME =  VRH SUPPLIED ROUTINE TO READ A      *\n*                RECORD FROM A VTOC USING THE DATASET NAME AS THE     *\n*                KEY.                                                 *\n*                                                                     *\n*                 REGISTER CONVENTIONS = STANDARD CONVENTIONS.        *\n*                    REGISTERS 0 - 2   = WORK REGISTERS               *\n*                    REGISTERS 3 - 11  = UNUSED                       *\n*                    REGISTERS 12      = BASE REGISTER                *\n*                    REGISTER  13 -15  = STANDARD OS USAGE            *\n*                                                                     *\n*                ATTRIBUTES = PROBLEM STATE                           *\n*                                                                     *\n*             ENTRY POINTS = VTOCRD                                   *\n*                                                                     *\n*             INPUT = DATASET NAM E                                   *\n*                                                                     *\n*             OUTPUT = NONE                                           *\n*                                                                     *\n*             EXIT - NORMAL = AT PROGRAM END VIA BRANCH REGISTER 14   *\n*                                                                     *\n*                OUTPUT = NONE                                        *\n*                                                                     *\n*                RETURN CODE = ZERO                                   *\n*                                                                     *\n*             EXIT - ERROR = NONE                                     *\n*                                                                     *\n*                OUTPUT = NONE                                        *\n*                                                                     *\n*                RETURN CODE = 16  DD-STATEMENT 'VTOC' IS MISSING     *\n*                                                                     *\n*             EXTERNAL REFERENCES =                                   *\n*                                                                     *\n*                ROUTINES = NONE                                      *\n*                                                                     *\n*                DATA AREAS = NONE                                    *\n*                                                                     *\n*                CONTROL BLOCKS = DSCB, JFCB, TIOT, DCB               *\n*                                                                     *\n*             TABLES = NONE                                           *\n*                                                                     *\n*             MACROS = SAVE, RETURN, RDJFCB, OPEN, CLOSE, EXTRACT,    *\n*                      RESERVE, DEQ, DCB, DCBD                        *\n*                                                                     *\n*             CHANGE ACTIVITY = NONE                                  *\n*                                                                     *\n*             MESSAGES = NONE                                         *\n*                                                                     *\n*             ABEND CODES = NONE                                      *\n*                                                                     *\n***********************************************************************\n         EJECT\n         B     AROUND             BRANCH AROUND DUMP TITLE\n         DC    C'VTOCRD'          PROGRAM NAME\n         DC    CL8'&SYSDATE'      DATE WRITTEN\n         DC    CL6'&SYSTIME'      TIME WRITTEN\nPROGID   DC    C'VTOCRD_R01.0_&SYSDATE'\n$$$CODD  DC    C'$$$CODD: COPYRIGHT DIVERSIFIED DEVELOPMENTS'\n         SPACE 1\nAROUND   DS    0H\n*        GETMAIN R,LV=LDYNAMIC    GET CORE FOR WORK AREA\n*        LR    R3,R1              R3 -> TO WORK AREA\n*        USING WORK,R3            SET WORK BASE\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*              UPDATE THE JFCB WITH VTOC NAME                         *\n*                                                                     *\n***********************************************************************\n         L     R2,=V(VTOCDDN)     R2 -> TO DDNAME TO READ           RH\n         MVC   VTOC+40(8),0(R2)   MOVE DDNAME TO VTOC DCB\n         RDJFCB VTOC                   READ THE JFCB\n         USING INFMJFCB,R2             ESTABLISH ADDRESSABILITY\n         LA    R2,JFCBAREA             POINT TO JFCB\n         LTR   R15,R15                 TEST IF DD CARD PRESENT\n         BNZ   CLOSEIT2                NO DD CARD - BAD RETURN\n         MVC   KEY,JFCBDSNM       SAVE DSNAME AS KEY\n         MVC   RNAME,JFCBVOLS          SAVE VOLUME SERIAL NUMBER\n         L     R15,=V(OUTDISP)    R15 -> TO OUTPUT FILE DISP        RH\n         MVC   0(1,R15),JFCBIND2  SAVE DISP                         RH\n         DROP  R2\n         SPACE 1\nOBTAIN1  DS    0H\n         OBTAIN F1CAM             GET FORMAT 1\n         USING IECSDSL1,R2             ESTABLISH DSCB ADDRESSABILITY\n         LA    R2,FULLDSCB             POINT TO DSCB\n         CLI   DS1FMTID,C'1'           IS THIS A FORMAT 1 DSCB\n         BNE   NOMORE3            NO, CAN'T GET SPACE\n         SPACE 1\n         LH    R4,DS1LSTAR        R4 = NBR TRKS USED\n         CLI   DS1LSTAR+2,X'00'   USING PART OF NEXT TRACK\n         BE    *+8                NO, DON'T ADD 1\n         LA    R4,1(0,R4)         + 1 IN CASE PARTIAL USED\n         STH   R4,SPCUSED         SAVE SPACE USED\n         L     R1,=V(VTOCSPC)     R1 -> TO SAVE SPACE FIELD\n         MVC   1(2,R1),SPCUSED    PUT SPACE USED IN IT\n         MVC   TRKUSED,DS1LSTAR   SAVE SPACE USED FROM DSCB\n         MVC   TRKBAL,DS1TRBAL    SAVE TRACK BALANCE FROM DSCB\n         MVC   SPCBLK,DS1BLKL     SAVE BLKSIZE\n         MVC   SPCLRECL,DS1LRECL  SAVE LRECL\n         MVC   SPCSECN,DS1SCALO+2 SAVE SECONDARY ALLOC\n         MVC   DSNRECFM,DS1RECFM  SAVE RECFM                        RH\n         MVC   SPCTYPE,=C'CYL'    DEFAULT TO CYLS\n         CLI   DS1SCALO,X'C0'     IS IT CYLS?\n         BE    CHKALLOC           YES, SEE IF SPACE ALLOC'D WANTED\n         MVC   SPCTYPE,=C'TRK'    CHANGE TO TRKS\n*        B     NOMORE3            ON WE GO\n         SPACE 1\nCHKALLOC DS    0H\n         L     R5,=V(PARMFLAG)    R5 -> TO PARM FLAG                RH\n         TM    0(R5),ALLOCFLG     WAS ALLOC SPECIFIED               RH\n         BZ    CHKFILE            NO, USED SPACE IS WANTED\n         SPACE 1\n         OBTAIN F4CAM             GET FORMAT 4\n         USING IECSDSL4,R5        ESTABLISH DSCB ADDRESSABILITY\n         LA    R5,DSCB4           POINT TO DSCB\n         CLI   DS4IDFMT,C'4'      IS THIS A FORMAT 4 DSCB\n         BNE   NOF4A              NO, CAN'T GET TRKS/CYL\n         SPACE 1\n         LH    R3,DS4DEVSZ+2      R3 = NBR TRKS/CYL\n         STH   R3,TRKPCYL         SAVE IT FOR LATER\n         SPACE 1\nNOF4A    DS    0H\n         DROP  R5                 DROP DSCB4 ADDRESSABILITY\n         BAL   R14,ALOCSPC1       GO GET SPACE ALLOCATED\n         SPACE 1\n         CLC   DS1PTRDS,=CL5'00'  IS THERE A FORMAT 3 DSCB ?\n         BE    CHKFILE2           NO, END OF ALLOCATED SPACE\n         OBTAIN F3CAM             GET FORMAT 3\n         LA    R2,DSCB3           POINT TO DSCB3\n*        USING IECSDSL1,R2             ESTABLISH DSCB ADDRESSABILITY\n         CLI   DS1FMTID,C'3'      IS THIS A FORMAT 3 DSCB\n         BNE   CHKFILE2           NO, END OF ALLOCATED SPACE\n         BAL   R14,ALOCSPC3       GO GET SPACE ALLOCATED\n         SPACE 1\nCHKFILE2 DS    0H\n         STH   R11,SPCUSED        SAVE TRKS ALLOCATED\n         L     R1,=V(VTOCSPC)     R1 -> TO SAVE SPACE FIELD\n         MVC   1(2,R1),SPCUSED    PUT SPACE ALLOCATED IN IT\n         B     CHKFILE            END OF ALLOCATED SPACE\n         DROP  R2\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*              CALCULATE SPACE ALLOCATED                              *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nALOCSPC1 SR    R11,R11            CLEAR ACCUM REG\n         ST    R14,RETSAVE        SAVE RETURN ADDRESS\n*        LA    R2,FULLDSCB             POINT TO DSCB\n         USING IECSDSL1,R2        ESTABLISH DSCB1  ADDRESSABILITY\n         LA    R1,DS1EXT1         F1 FIRST EXTENT\n         SR    R5,R5              CLEAR R5\n         IC    R5,DS1NOEPV        NUMBER OF EXTENTS\n         ST    R5,EXTKNT          SAVE NUMBER OF EXTENTS\n         LTR   R5,R5              TEST FOR AN EMPTY DATA SET\n         BZ    DS1RET             JUMP IF EMPTY\n         C     R5,=F'4'           CHECK FOR ALL EXTENTS IN F1\n         BL    EXTSS1\n         LA    R5,3               SET FOR LAST 3\nEXTSS1   BAL   R14,ALLSUM         SUM UP ALLOCATION\n         SPACE 1\nDS1RET   DS    0H\n         L     R14,RETSAVE        LOAD RETURN ADDRESS\n         BR    R14                RETURN TO CALLER\n         DROP  R2                 DROP DSCB1 BASE\n         SPACE 1\nALOCSPC3 DS    0H\n         ST    R14,RETSAVE        SAVE RETURN ADDRESS\n*        LA    R2,DSCB3           POINT TO DSCB3\n         USING IECSDSL3,R2        ESTABLISH DSCB3 ADDRESSABILITY\n         LA    R1,DS3EXTNT        START OF GROUP\n         L     R5,EXTKNT          EXTENT COUNT BACK\n         S     R5,=F'3'           REDUCE BY THOSE ALREADY DONE\n         C     R5,=F'5'           FOUR MORE FIELDS\n         BL    EXTSS2\n         LA    R5,4               SET TO 4\nEXTSS2   BAL   R14,ALLSUM         SUM UP SOME MORE\n         L     R5,EXTKNT          GET EXTENT COUNT BACK\n         S     R5,=F'7'           SET TO DO LAST 9\n         BNH   EXTSS3             THRU\n         LA    R1,DS3ADEXT\n         BAL   R14,ALLSUM         DO LAST OF THEM\n         SPACE 1\nEXTSS3   DS    0H\n         L     R14,RETSAVE        LOAD RETURN ADDRESS\n         BR    R14                RETURN TO CALLER\n         DROP  R2                 DROP DSCB BASE\n         SPACE 1\nALLSUM   ST    R14,HOLD8          TAKE CARE OF FETCHING ALLOCATIONS\nALLSUM1  BAL   R14,ABTOREL        CONVERT TO RELATIVE TRACKS\n         BAL   R14,LENGTH         GET LENGTH IN R7\n         AR    R11,R7             TOTAL UP ALL LENGTHS FOR DS\n         LA    R1,10(R1)          SET FOR NEXT\n         BCT   R5,ALLSUM1         LOOP\n         L     R14,HOLD8          RESTORE\n         BR    R14                BACK OUT\n         SPACE 1\nABTOREL  MVC   HOLD(8),2(R1)      MOVE FOR BOUNDRIES\n         LH    R8,HOLD            CC\n         MH    R8,TRKPCYL          CHANGE TO TRACKS\n         AH    R8,HOLD+2          HH\nABTOREL2 EQU   *\n         LH    R7,HOLD4           CC SECOND\n         MH    R7,TRKPCYL          CHANGE TO TRACKS\n         AH    R7,HOLD4+2         HH FOR SECOND\n         SPACE 1\nABTOREL3 EQU   *\n         SLL   R8,16              MOVE TO TOP\n         ALR   R8,R7              PUT TOGETHER\n         BR    R14                EXIT\n         SPACE 1\nLENGTH   ST    R8,HOLD            SAVE VALUE FOR TEMP\n         LH    R7,HOLD+2          BRING IN LAST POSITION\n         A     R7,=F'1'           UPDATE\n         STH   R7,HOLD12          SAVE LAST TRACK FOR NEXT CHECK\n         SH    R7,HOLD            TAKE OFF START TRACK VALUE\n         BR    R14                GO ON BACK\n         SPACE 1\nCHKFILE  DS    0H\n         CLC   SPCTYPE,=C'CYL'    SPACE ALLOCATED IN CYLS?\n         BNE   NOMORE3            NO, WE ARE DONE\n*\n*              IF SPACE WAS ALLOCATED IN CYLS, WE MUST CONVERT\n*              THE SPACE TO ALLOC FROM TRK TO CYL....\n*\n         SPACE 1\nOBTAIN4  DS    0H\n         USING IECSDSL4,R2        ESTABLISH DSCB ADDRESSABILITY\n         LA    R2,DSCB4           POINT TO DSCB4\n         CLI   DS4IDFMT,C'4'      IS THIS A FORMAT 4 DSCB\n         BNE   NOF4               NO, CAN'T CHANGE TRK TO CYL\n         SPACE 1\n         SR    R4,R4              R4 = 0\n         LH    R5,SPCUSED         R5 = SPACE IN TRKS\n         LH    R3,DS4DEVSZ+2      R3 = NBR TRKS/CYL\n         DR    R4,R3              CONVERT TRKS TO CYLS\n         LTR   R4,R4              IS THERE A REMAINDER?\n         BZ    OB4A               NO\n         LA    R5,1(0,R5)         YES, + 1 IN CASE PARTIAL USED\n         SPACE 1\nOB4A     DS    0H\n         LA    R5,1(0,R5)         ADD 1 FOR GOOD LUCK....\n         STH   R5,SPCUSED         SAVE SPACE USED IN CYLS\n         L     R1,=V(VTOCSPC)     R1 -> TO SAVE SPACE FIELD\n         MVC   1(2,R1),SPCUSED    PUT SPACE USED IN IT\n         SPACE 1\n         SR    R4,R4              R4 = 0\n         LH    R5,DS4DEVSZ+2      R5 = NBR TRKS/CYL\n         LH    R3,SPCSECN         R3 = SECONDARY SPACE IN TRKS\n         LTR   R3,R3              IS THERE A SEC SPACE?\n         BZ    NOMORE3            NO\n         DR    R4,R3              CONVERT TRKS TO CYLS\n         LTR   R4,R4              IS THERE A REMAINDER?\n         BZ    OB4B               NO\n         LA    R5,1(0,R5)         YES, + 1 IN CASE PARTIAL USED\n         SPACE 1\nOB4B     DS    0H\n         STH   R5,SPCSECN         SAVE SECONDARY SPACE IN CYLS\n         B     NOMORE3            END FOR NOW\n         SPACE 1\nNOF4     DS    0H\n         MVC   SPCTYPE,=C'TRK'    MUST ALLOC NEW DSN IN TRKS\n         SPACE 1\nCLOSEIT2 DS    0H\n         SPACE 1\nNOMORE3  DS    0H\n*        FREEMAIN R,LV=LDYNAMIC,A=(3)  FREE GOTTEN CORE\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*              RETURN TO CALLER                                       *\n*                                                                     *\n***********************************************************************\n*\nENDVTOC  SECEXIT                  RETURN TO CALLER\n         SPACE 3\n* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n*        WORK AREAS\n* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\nDUMPTITL DC    C'WORKING STORAGE SECTION'\n         SPACE 3\n*\n* MISC FIELDS\n*\nRETSAVE  DC    F'0'\nHOLD     DC    F'0'               TEMPORARY HOLD OF R14 AND VALUES\nHOLD4    DC    F'0'               TEMP WORK AREA\nHOLD8    DC    F'0'               TEMP R14\nHOLD12   DC    F'0'               TEMP FL   CHECK\nHOLD16   DC    F'0'               TEMP R14\nEXTKNT   DC    F'0'               SAVE EXTENT COUNT OF F1\nTRKPCYL  DC    H'0'               SAVE TRKS/CYL\n         SPACE 3\n*\n* DSCB I/O AREA AND CONTROL BLOCKS\n*\n         ENTRY RNAME\nRNAME    DC    CL6' '\nBLKA     DC    XL8'00'\nFULLDSCB DS    0C\nKEY      DC    CL44' '\nDSCB     DC    XL140'00'\nDSCB3    DC    XL140'00'\nKEY4     DC    44X'04'\nDSCB4    DC    XL140'00'\n         SPACE\nF1CAM    CAMLST SEARCH,KEY,RNAME,DSCB\nF3CAM    CAMLST SEEK,FULLDSCB+135,RNAME,DSCB3\nF4CAM    CAMLST SEEK,KEY4,RNAME,DSCB4\n         SPACE\n         ENTRY SPCSECN,SPCBLK,SPCLRECL,SPCUSED,SPCTYPE\n         ENTRY DSNRECFM,TRKUSED,TRKBAL\nSPCSECN  DC    H'0'               SECONDARY ALLOCATION\nSPCBLK   DC    H'0'               BLKSIZE\nSPCLRECL DC    H'0'               LRECL\nSPCUSED  DC    H'0'               NBR OF TRKS USED\nSPCTYPE  DC    CL3'CYL'           TYPE OF ALLOCATION\nDSNRECFM DC    X'00'              DATASET RECFM\nTRKUSED  DC    XL3'00'            DS1LSTAR DATA\nTRKBAL   DC    H'0'               DS1TRBAL DATA\n         SPACE 1\n         ENTRY DSNIN,DSNINSP,DSNOUT,DSNOUTSP,VTOCDDN,VTOCSPC\n         ENTRY DSNFLAG,OUTDISP\n*                                 THESE MUST STAY IN THIS ORDER\nDSNIN    DC    CL8'SYSUT1'        1   DEFAULT INPUT FILE NAME\nDSNIFLG  DC    X'00'              2\nDSNINSP  DC    XL3'000000'        3\nDSNOUT   DC    CL8'SYSUT2'        4   DEFAULT OUTPUT FILE NAME\nDSNOFLG  DC    X'00'              5\nDSNOUTSP DC    XL3'000000'        6\nVTOCDDN  DC    CL8'SYSUT1'        7\nDSNFLAG  DC    X'00'              8\n*              01                   DS CAN BE DELETED AND REALLOCATED\n*              02                   DS MUST BE COPIED\n*              04                   DELETE DATASET\n*              08                   ALLOCATE DATASET\n*              10                   OUTPUT DATASET IS EMPTY\n*              20                   ALLOCATE WITH DISP=(MOD,KEEP)\n*              40                   FREE\n*              80                   FREE\nVTOCSPC  DC    XL3'000000'        9\nOUTDISP  DC    X'00'              10\n*\n         ENTRY SAVEDDN,SAVEDSN,SAVEDSN2,SAVEVOL\nSAVEDDN  DC    CL8'SYSUT2'        SAVE AREA FOR OUTPUT DDN\nSAVEDSN  DC    CL44' '            SAVE AREA FOR DSNAME\nSAVEDSN2 DC    CL44' '            SAVE AREA FOR NEW DSNAME\nSAVEVOL  DC    CL6' '             SAVE AREA FOR OLD VOLSER\nTRAPDATA DS    CL80\nATTANAME DC    CL8' '\nATTAPARM DS    0H\nPARMLTH  DC    H'0'\nPARMDATA DC    CL100' '\n         SPACE 1\n         ENTRY VOLADDR\nVOLADDR  DC    A(VOLDATA)\nVOLDATA  DC    4XL31'00'     VOL=VOLSER,VOLSER,VOLSER,VOLSER\nVOLDEF   DC    XL31'00'           VOL CURRENT DSN IS ON\nVOLTH    EQU   *-VOLDEF           LTH OF EACH ENTRY\nVOLEND   DC    X'FF'\n         SPACE 1\n         PRINT NOGEN\nVTOC     DCB   DDNAME=VTOC,DSORG=DA,RECFM=U,KEYLEN=44,BLKSIZE=96,      X\n               MACRF=(RKIC),EODAD=CLOSEIT2,EXLST=RDJFLIST,             X\n               OPTCD=E,LIMCT=255\n         SPACE\nOPENBIT  EQU   X'10'\nRDJFLIST DC    X'07',AL3(JFCBAREA)\nJFCBAREA DC    176X'0'\n         SPACE 3\n         LTORG\n         SPACE 1\n*ORK     DSECT                    IF DO GETMAIN AT START...\n*AVEW    DC    18F'-1'\n*AVECHG  DC    F'0'\n*        DS    A\n*        DS    CL6\n*        DS    CL60\n*DYNAMIC EQU   *-WORK\n         SPACE 1\n         EJECT\n*\n TITLE 'REALLOCATE OUTPUT FILE TO  SYSUT2'\n         DS    0H\nGETDS    SECTION\n         B     AROUND2            BRANCH AROUND DUMP TITLE\n         DC    C'GETDS'           PROGRAM NAME\n         DC    CL8'&SYSDATE'      DATE WRITTEN\n         DC    CL6'&SYSTIME'      TIME WRITTEN\n         SPACE 1\nAROUND2  DS    0H\n         LA    R3,S99RBS          R3 -> TO SVC99 PARMS\n         USING S99RB,R3           SET ADDRESSABILITY\n         L     R6,=V(USRDSN)      R6 -> TO DSNAME\n         L     R1,=V(USRDSN)      R1 -> TO DSNAME\n         SR    R5,R5              R5 = 0\n         MVI   TUPAR11,C' '       CLEAR DSN TEXT UNIT\n         MVC   TUPAR11+1(43),TUPAR11\n         SPACE 1\nNOVOL2D  DS    0H\n         CLI   0(R6),C' '         AT END OF DSN ?\n         BE    OUT4               YES, MOVE IT TO SVC 99 FIELD\n         LA    R6,1(0,R6)         ADD 1 TO DSN POSITION REG\n         LA    R5,1(0,R5)         ADD 1 TO LTH CTR\n         B     NOVOL2D            LOOK AT NEXT CHAR\n         SPACE 1\nOUT4     DS    0H\n         STH   R5,TULNG11         SET UP LTH FIELD\n         BCTR  R5,0               LTH - 1 FOR EX\n*        STC   R5,MVCLTH+1        SET MVC LTH\n*        LA    R5,TUPAR11         R5 -> TO TUPAR11 UNIT\n*MVCLTH  MVC   0(0,R5),0(R1)      MVC DSN TO TEXT UNIT\n         EX    R5,MVCDSN11        MOVE DSN TO TEXT UNIT\n*VCDSN11 MVC   TUPAR11(0),0(R1)   MVC DSN TO TEXT UNIT\n         SPACE 1\nFREEUNIT DS    0H\n         L     R1,=V(DSNFLAG)     R1 -> TO ALLOCATE TYPE FLAG\n         TM    0(R1),X'04'        DELETE DATASET?\n         BZ    NODELETE           NO, BYPASS DELETE\n         SPACE 1\n         MVI   S99VERB,X'02'      CHANGE TO UNALLOCATE\n         LA    R1,S99TUPL2        R1 -> TO SVC 99 PARMS FOR FREE\n         ST    R1,S99TXTPP        PUT IT IN SVC 99 RB\n         LA    R1,S99PARMS        R1 -> TO SVC 99 PARMS\n         SVC   99\n         LTR   R15,R15            WAS SVC OKAY ?\n         BZ    SVCOKAY2           YES\n         SPACE 1\n         MVC   LINKTYPE,SVCTYP3   SAY ITS A DEALLOCATE\n         BAL   R6,SVCMSG          PRINT RETURN CODES\n         SPACE 1\n*        LA    R15,12             SET RETURN CODE\n         ST    R15,RETCODE        ''\n         OLCMSG LOCMSG4           GO PRINT MSG\n         B     GETEND             END OF GETDS\n         SPACE 1\nSVCOKAY2 DS    0H                                                   RH\n         MVC   MSG(44),TUPAR11    MOVE DSNAME TO MSG                RH\n         LA    R6,MSG             R6 -> TO DSNAME\n         SPACE 1\nNEXTCHR2 DS    0H\n         CLI   0(R6),C' '         AT END OF DSN ?\n         BE    ENDSN2             YES, ADD REST OF MSG\n         LA    R6,1(0,R6)         ADD 1 TO DSN POSITION REG\n         B     NEXTCHR2           LOOK AT NEXT CHAR\n         SPACE 1\nENDSN2   DS    0H\n         L     R1,=V(RNAME)       R1 -> TO OLD VOLSER\n         MVC   DELVOL,0(R1)       MOVE VOLSER TO MSG                RH\n         OLCMSG DELMSG            GO PRINT MSG\n         L     R1,=V(DSNFLAG)     R1 -> TO ALLOCATE TYPE FLAG\n         SPACE 1\nNODELETE DS    0H                                                   RH\n         TM    0(R1),X'08'        ALLOCATE DATASET?\n         BZ    NOALLOC2           NO, BYPASS ALLOCATE\n         SPACE 1\n         MVI   S99VERB,X'01'      CHANGE TO ALLOCATE\n         SPACE 1\n         TM    0(R1),X'20'        ALLOCATE DISP=(MOD,KEEP) ?\n         BZ    ALLOCNEW           NO, DISP=(NEW,KEEP)\n         SPACE 1\n         LA    R1,S99TUPL3        R1 -> TO SVC 99 PARMS FOR ALLOCATE\n         ST    R1,S99TXTPP        PUT IT IN SVC 99 RB\n         B     DOSVC99            GO DO SVC 99\n         SPACE 1\nALLOCNEW DS    0H\n         LA    R1,S99TUPL1        R1 -> TO SVC 99 PARMS FOR ALLOCATE\n         ST    R1,S99TXTPP        PUT IT IN SVC 99 RB\n*\n*              GET PARM, IF ANY\n*\n         SPACE 1\nGETCTL   DS    0H\nGETCTL1  NOP   GETCTL2            B AFTER 1ST ENTRY\n         SPACE 1\nLOOP4    DS    0H\n         SPACE 1\nENDLOOP4 DS    0H\n         SPACE 1\nENDLOOP5 DS    0H\n         B     GETSPACE           GO SET UP SPACE, ETC.\n         SPACE 1\nGETCTL2  DS    0H\nGETCTL3  NOP   GETVOL             B AFTER 2ND ENTRY\n         MVI   GETCTL3+1,X'F0'    CHANGE NOP TO B\n         LR    R10,R11            R10 -> TO VOL= PARM\n         CLC   =C'VOL=',0(R10)    IS IT VOL= PARM?\n         BNE   GETVOL             NO, IGNORE IT\n         BCTR  R2,0               -1 TO GET HEX LTH\n         EX    R2,SETJCLC         SET UP VOL= PARM\n         B     GETVOL             GO SET UP VOL= PAMRS\n         SPACE 1\nSETJCLC  MVC   JCLCARD(0),0(R10)  MOVE PARM TO JCLCARD AREA\n         SPACE 1\nGETCTL4  MVI   GETCTL3+1,X'F0'    CHANGE NOP TO B\n         SPACE 1\nGETSPACE DS    0H\n         L     R8,=V(RESTREC)     R8 -> TO RESTORE RECORD\n         USING RESTRECD,R8        SET BASE\n         SPACE 1\n         LA    R1,0               DEFAULT TO 0 TRK\n         CLC   RESTUSED,=C'0000'  IS THERE A PRIMARY SPACE?\n         BL    GETSEC             NO, TRY FOR A SECONDARY\n         PACK  DUB,RESTUSED       PACK SPACE USED IN A DWORD\n         CVB   R1,DUB             CONVERT TO BINARY\n         SPACE 1\nGETSEC   DS    0H\n         STCM  R1,7,TUPAR10       PUT PRIMARY SPACE IN TEXT UNIT\n         SPACE 1\n         LA    R1,1               DEFAULT TO 1 TRK\n         CLC   RESTSECN,=C'0000'  IS THERE A SECONDARY SPACE?\n         BL    GETSEC2            NO, DEFAULT TO 1\n         PACK  DUB,RESTSECN       PACK SECONDARY SPACE IN A DWORD\n         CVB   R1,DUB             CONVERT TO BINARY\n         SPACE 1\nGETSEC2  DS    0H\n         STCM  R1,7,TUPAR12       PUT SECONDARY SPACE IN TEXT UNIT\n         SPACE 1\n         SR    R1,R1              R1 = 0\n         ST    R1,TUPL13          ASSUME NO DIR\n         CLC   =C'PO',RESTTYPE    IS IT A PO FILE?\n         BNE   NODIR              NO\n         LA    R1,TUNIT13         YES, WE NEED DIR BLKS\n         ST    R1,TUPL13          SAY SO IN S99 PARMS\n         SPACE 1\n         LA    R1,1               DEFAULT TO 1 DIR BLK\n         CLC   RESTDIR,=C'0000'   IS THERE A DIRECTORY SPACE?\n         BL    GETSEC3            NO, USE THE DEFAULT\n         PACK  DUB,RESTDIR        PACK DIRECTORY BLOCKS IN A DWORD\n         CVB   R1,DUB             CONVERT TO BINARY\n         SPACE 1\nGETSEC3  DS    0H\n         STCM  R1,7,TUPAR13       PUT DIRECTORY SPACE IN TEXT UNIT\n         SPACE 1\nNODIR    DS    0H\n         LA    R1,3120            DEFAULT TO BLKSIZE OF 3120\n         CLC   RESTBLK,=C'00000'  IS THERE A BLKSIZE?\n         BL    GETSEC4            NO, DEFAULT TO 3120\n         PACK  DUB,RESTBLK        PACK BLKSIZE IN A DWORD\n         CVB   R1,DUB             CONVERT TO BINARY\n         SPACE 1\nGETSEC4  DS    0H\n         STH   R1,DUB             PUT BLKSIZE IN TEXT UNIT\n         MVC   TUPAR30,DUB        PUT BLKSIZE IN TEXT UNIT\n         SPACE 1\n         LA    R1,80              DEFAULT TO LRECL=80\n         CLC   RESTBLK,=C'00000'  IS THERE AN LRECL ?\n         BL    GETSEC5            NO, DEFAULT TO 80\n         PACK  DUB,RESTLREC       PACK LRECL IN A DWORD\n         CVB   R1,DUB             CONVERT TO BINARY\n         SPACE 1\nGETSEC5  DS    0H\n         STH   R1,DUB             PUT LRECL IN TEXT UNIT\n         MVC   TUPAR42,DUB        PUT LRECL IN TEXT UNIT\n         SPACE 1\n         LA    R1,TUPAR49         R1 -> TO RECFM TEXT UNIT\n         MVI   TUPAR49,X'C0'      DEFAULT TO U\n         CLI   RESTRCFM,C'U'      IS IT U?\n         BE    TUNITSET           YES\n         MVI   TUPAR49,X'00'      NO RECFM\n         LA    R14,RESTRCFM       R14 -> TO 1ST RECFM FIELD BYTE\n         CLI   RESTRCFM,C' '      IS IT BLANK?\n         BE    TUNITSET           YES\n         BAL   R15,SETREC2        GO SET RECFM...\n         LA    R14,RESTRCFM+1     R14 -> TO 2ND RECFM FIELD BYTE\n         CLI   RESTRCFM,C' '      IS IT BLANK?\n         BE    TUNITSET           YES\n         BAL   R15,SETREC2        GO SET RECFM...\n         LA    R14,RESTRCFM+2     R14 -> TO 3RD RECFM FIELD BYTE\n         CLI   RESTRCFM,C' '      IS IT BLANK?\n         BE    TUNITSET           YES\n         BAL   R15,SETREC2        GO SET RECFM...\n         B     TUNITSET           END OF RECFM STUFF...\n         SPACE 1\nSETREC2  DS    0H\n         CLI   0(R14),C'F'        IS F IN RECFM\n         BNE   SETREC2A           NO\n*        BNE   *+4+4+0            NO\n         OI    0(R1),X'80'        SAY IT'S FIXED\n         SPACE 1\nSETREC2A DS    0H\n         CLI   0(R14),C'V'        IS V IN RECFM\n         BNE   SETREC2B           NO\n         OI    0(R1),X'40'        SAY IT'S VARIABLE\n         SPACE 1\nSETREC2B DS    0H\n         CLI   0(R14),C'B'        B IN RECFM\n         BNE   SETREC2C           NO\n         OI    0(R1),X'10'        SAY IT'S BLOCKED\n         SPACE 1\nSETREC2C DS    0H\n         CLI   0(R14),C'S'        S IN RECFM\n         BNE   SETREC2D           NO\n         OI    0(R1),X'08'        SAY IT'S SPANNED\n         SPACE 1\nSETREC2D DS    0H\n         CLI   0(R14),C'A'        A IN RECFM\n         BNE   SETREC2E           NO\n         OI    0(R1),X'04'        SAY IT'S ANSI CONTROL\n         SPACE 1\nSETREC2E DS    0H\n         CLI   0(R14),C'M'        M IN RECFM\n         BNE   SETREC2F           NO\n         OI    0(R1),X'02'        SAY IT'S MACHINE CONTROL\n         SPACE 1\nSETREC2F DS    0H\n         BR    R15                END OF THIS RECFM BYTE....\n         SPACE 1\nTUNITSET DS    0H\n         CLI   0(R1),X'00'        DID WE SET THE RECFM?\n         BH    *+4+4              YES, ON WE GO\n         MVI   0(R1),X'90'        NO, DEFAULT TO RECFM=FB\n         SPACE 1\n         MVI   TUKEY9+1,X'08'     ASSUME ALLOCATE IN CYLS\n         CLC   RESTALOC,=C'CYL'   ALLOCATE IN CYLINDERS?\n         BE    GETVOL             YES, WE ARE DONE\n         SPACE 1\nVOLSET   DS    0H\n         MVI   TUKEY9+1,X'07'     CHANGE TO TRK ALLOCATE\n*        B     GETVOL             GO ALLOCATE NEW DSN\n         DROP  R8                 DROP RESTREC BASE\n         SPACE 1\nGETVOL   DS    0H                 ALLOCATE NEW DSN\n         XC    TUPL2,TUPL2        DEFAULT TO NO VOLSER TEXT UNIT\n         L     R5,=V(PARMFLAG)    R5 -> TO PARM FLAG                RH\n         TM    0(R5),VOLFLAG      WAS VOL= SPECIFIED                RH\n         BZ    NOMORE4            NO\n*\n*\n         AGO   .SKIP87\n*\n         L     R2,=V(VOLADDR)     R2 -> TO VOL TABLE\n         L     R1,0(0,R2)         R1 -> TO VOL ENTRY\n         CLI   0(R1),X'00'        IS THERE A VOLSER?\n         BE    NOMORE4            NO, TRY SYSTEM VOLS\n         CLI   0(R1),X'FF'        END OF VOL TABLE?\n         BE    NOMORE4            YES, TRY SYSTEM VOLS\n         MVC   JCLCARD(VOLTH),0(R1)   PUT VOL SER IN PARM\n         LA    R1,VOLTH(0,R1)     R1 -> TO NEXT VOL TABLE ENTRY\n         ST    R1,0(0,R2)         SAVE NEXT VOL TABLE ENTRY ADDRESS\n*        L     R2,=V(RNAME)       R2 -> TO OLD VOLSER\n*        MVC   JCLCARD(4),=C'VOL=' SET UP VOL PARM\n*        MVC   JCLCARD+4(6),0(R2)  PUT VOL SER IN PARM\n         SPACE 1\n*        GET   SYSIN,JCLCARD      READ NEXT CARD TO GET VOL PARM\n         CLC   =C'VOL=',JCLCARD   IS IT A VOL= PARM?\n         BNE   GETVOL             NO, READ NEXT CARD\n         SPACE 1\nGOTVOL   DS    0H\n         LA    R1,JCLCARD+4       R1 -> TO VOLSER 1\n         LA    R7,TUPAR2          R7 -> WHERE VOLSER GOES\n         LA    R15,4              R15 -> = MAX VOLSERS\n         SPACE 1\nMOVVOL   DS    0H\n         LH    R8,TUNUM2          R8 = NBR OF VOLSERS\n         LA    R8,1(0,R8)         ADD ONE TO NBR OF VOLSERS\n         STH   R8,TUNUM2          SAVE IT\n         MVC   0(6,R7),0(R1)      MOVE VOLSER TO TEXT UNIT 2\n         LA    R1,6(0,R1)         R1 -> TO COMMA\n         CLI   0(R1),C' '         IS THERE ONE?\n         BE    ENDVOL             NO\n         LA    R1,1(0,R1)         R1 -> TO NEXT VOLSER\n         LA    R7,8(0,R7)         R7 -> TO WHERE NEXT VOLSER GOES\n         BCT   R15,MOVVOL         SAVE NEXT VOLSER\n         SPACE 1\nENDVOL   DS    0H\n*\n.SKIP87  ANOP\n*\n*\n         LA    R7,TUNIT2          R7 -> TO VOLSER TEXT UNIT\n         ST    R7,TUPL2           PUT IT IN SVC99 LIST\n         SPACE 1\nNOMORE4  DS    0H\n*        B     DOSVC99            GO ALLOCATE DATASET\n*\n         SPACE 1\nDOSVC99  DS    0H                 ALLOCATE DATASET\n         LA    R1,S99PARMS        R1 -> TO SVC 99 PARMS\n         SVC   99\n         LTR   R15,R15            WAS SVC OKAY ?\n         BZ    SVCOKAY            YES\n         SPACE 1\n         MVC   LINKTYPE,SVCTYP2   SAY ITS AN ALLOCATE\n         BAL   R6,SVCMSG          PRINT RETURN CODES\n         SPACE 1\nPHEAD    DS    0H\n         LA    R7,0               R7 = 0\n         C     R7,TUPL2           DID WE SPECIFY A VOLUME?\n         BNE   PHEAD2             YES, SAY NO SPACE ON THIS VOLUME  RH\n         SPACE 1\n         OLCMSG LOCMSG3           GO PRINT MSG\n         LA    R15,12             SET RETURN CODE\n         ST    R15,RETCODE        ''\n         B     GETEND             END OF GETDS\n         SPACE 1\nPHEAD2   DS    0H\n         ST    R7,TUPL2           SAY TRY ANY PACK\n         MVC   VOLMSG2,TUPAR2     MOVE VOLSER TO MSG                RH\n         OLCMSG LOCMSG2           GO PRINT MSG\n         B     DOSVC99            GO TRY ON ANY PACK\n         SPACE 1\nSVCOKAY  DS    0H                                                   RH\n         MVC   MSG(44),TUPAR11    MOVE DSNAME TO MSG                RH\n         LA    R6,MSG             R6 -> TO DSNAME\n         SPACE 1\nNEXTCHAR DS    0H\n         CLI   0(R6),C' '         AT END OF DSN ?\n         BE    ENDSN              YES, ADD REST OF MSG\n         LA    R6,1(0,R6)         ADD 1 DSN POSITION REG\n         B     NEXTCHAR           LOOK AT NEXT CHAR\n         SPACE 1\nENDSN    DS    0H\n         MVC   VOLMSG,TUPAR14     MOVE VOLSER TO MSG                RH\n         OLCMSG LOCMSG            GO PRINT MSG\n         SPACE 1\nGETEND   DS    0H\nNOALLOC2 DS    0H\n         L     R15,RETCODE        R15 = RETURN CODE\n*        ST    R15,16(0,R13)      PUT RC IN SYSTEM SAVEAREA\n*        FREEMAIN R,LV=LDYNAMIC,A=(3)  FREE GOTTEN CORE\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*              RETURN TO CALLER                                       *\n*                                                                     *\n***********************************************************************\n*\nENDGETDS SECEXIT                  RETURN TO CALLER\n         SPACE 2                                                   RH\nSVCMSG   DS    0H               BAD READ OF VSAM DATA SET\n         CVD   R15,DUB            CONVERT RC TO DECIMAL\n         ED    LINKRC,DUB+6       CONVERT TO DISPLAY\n         UNPK  LINKERR(5),S99ERROR(3) CONVERT ERROR CODE TO DECIMAL RH\n         TR    LINKERR(4),TRTBL-240  TRANS TO DISPLAY               RH\n         MVI   LINKERR+4,C' '     CLEAR GARBAGE BYTE                RH\n         UNPK  LINKINFO(5),S99INFO(3) CONVERT INFO CODE TO DECIMAL  RH\n         TR    LINKINFO(4),TRTBL-240  TRANS TO DISPLAY              RH\n         MVI   LINKINFO+4,C' '    CLEAR GARBAGE BYTE                RH\n         OLCMSG LINKMSG           GO PRINT MSG\n         BR    R6                 GO BACK TO CALLER\n         SPACE 1\nMVCDSN11 MVC   TUPAR11(0),0(R1)   MVC DSN TO TEXT UNIT\n         SPACE 1\n* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n*        WORK AREAS\n* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n         SPACE 1\n         DC    C'WORKING STORAGE SECTION'\n         SPACE 1\nDUB      DC    D'0'\nLINKMSG  DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    C'SVC 99 WAS UNSUCCESSFUL FOR '\nLINKTYPE DC    C'UNALLOCATE '\n         DC    C', RC = '\nLINKRC   DC    X'40202020'\n         DC    C' S99ERROR = '\nLINKERR  DC    CL5' '\n         DC    C' S99INFO = '\nLINKINFO DC    CL5' '\nLINKMSGL EQU   *-LINKMSG\n         ORG   LINKMSG+81\n         SPACE 1\nSVCTYP2  DC    CL11'ALLOCATE   '\nSVCTYP3  DC    CL11'UNALLOCATE '\nTRTBL    DC    C'0123456789ABCDEF '   TRANSLATE TABLE               RH\n         SPACE 1\n* ------ INPUT AREA               ------------------------------------\nJCLCARD  DC    CL80' '            CARD INPUT AREA\n         SPACE 1\n* ------ WORK  AREAS              ------------------------------------\n         SPACE 1\nDELMSG   DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    C'DELETED SUCCESSFULLY FROM '\nDELVOL   DC    CL6' '\nLDELMSG  EQU   *-DELMSG\n         ORG   DELMSG+81\n         SPACE 1\nLOCMSG   DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    C'LOCMSG - ALLOCATED SUCCESSFULLY ON '\nVOLMSG   DC    CL6' '\nLLOCMSG  EQU   *-LOCMSG\n         ORG   LOCMSG+81\n         SPACE 1\nLOCMSG2  DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    C'NO SPACE FOR DATASET ON '\nVOLMSG2  DC    CL6' '\nLLOCMS2  EQU   *-LOCMSG2\n         ORG   LOCMSG2+81\n         SPACE 1\nLOCMSG3  DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    C'NO SPACE IN SYSTEM FOR DATASET. '\n         DC    C'CHANGE VOL= PARMS IN //SYSIN DATASET.'\nLLOCMS3  EQU   *-LOCMSG3\n         ORG   LOCMSG2+81\n         SPACE 1\nLOCMSG4  DC    CL81' '\n         ORG   *-81\n         DC    AL1(MSGPRT)\n         DC    C'SVC 99 WAS UNSUCCESSFUL FOR UNALLOCATE'\n         ORG   LOCMSG4+81\nINFO1    DS    0CL133\n         DC    C'0'\nMSG      DC    CL44' '\nCTLTOTAL DC    CL8' '\n         DC    CL80' '\n         EJECT\nDWORD3   DS    D\nRSAVE    DS    9D\nRETCODE  DC    F'0'\n         SPACE 1\n*              CONTROL BLOCKS FOR  SVC 99\nS99PARMS DS    0F                 PUT ON FULLWORD BOUNDARY\n         DC    XL1'80'\n         DC    AL3(S99RBS)\nS99RBS   DS    0F\n         DC    AL1(20)\n         DC    AL1(1)             ALLOCATE BY DSNAME\n         DC    XL2'2000'          DON'T MOUNT VOLS OR CONSIDER OFFLINES\n         DC    AL2(0)\n         DC    AL2(0)\n         DC    A(S99TUPL1)\n         DC    A(0)\n         DC    A(0)\n         SPACE 1\n         ENTRY TUPL2D\nS99TUPL1 DS    0F\nTUPL1    DC    A(TUNIT1)          DDNAME\nTUPL11   DC    A(TUNIT11)         DSNAME\nTUPL2    DC    A(TUNIT2)          VOLSER\nTUPL3    DC    A(TUNIT3)          UNIT TYPE\nTUPL4    DC    A(TUNIT4)          NBR OF DEVICES TO ALLOC = 1\nTUPL5    DC    A(0)               DUMMY\nTUPL6    DC    A(TUNIT6)          STATUS..DISP=(NEW,\nTUPL7    DC    A(TUNIT7)          STATUS..DISP=(NEW,CATLG)\nTUPL9    DC    A(TUNIT9)          SPACE IN CYLS\nTUPL10   DC    A(TUNIT10)         PRIMARY SPACE (DEFAULT=50)\nTUPL12   DC    A(TUNIT12)         SECONDARY SPACE (DEFAULT=10)\nTUPL13   DC    A(TUNIT13)         DIRECTORY BLOCKS, IF PO\nTUPL14   DC    A(TUNIT14)         RETURN VOLSER IF ALLOCATED\nTUPL2D   DC    A(0)               GET DCB INFO FROM DDNAME\nTUPL30   DC    A(TUNIT30)         BLKSIZE\nTUPL3C   DC    A(TUNIT3C)         DSORG\nTUPL42   DC    A(TUNIT42)         LRECL\nTUPL49   DC    A(TUNIT49)         RECFM\nTUPLAST  DC    XL1'80'            END OF TEXT UNITS\n         DC    AL3(0)\n         SPACE 1\nS99TUPL2 DS    0F\nTUPL21   DC    A(TUNIT1)          DDNAME\nTUPL16   DC    A(TUNIT11)         DSNAME\nTUPL15   DC    A(TUNIT15)         DISP=(OLD,DELETE)\nTUPL22   DC    A(TUNIT22)         UNALLOC EVEN IF PERM ALLOC\nTUPL27   DC    XL1'80'\n         DC    AL3(0)\n         SPACE 1\nS99TUPL3 DS    0F\nTUPL31   DC    A(TUNIT1)          DDNAME\nTUPL311  DC    A(TUNIT11)         DSNAME\n*UPL32   DC    A(TUNIT2)          VOLSER\nTUPL36   DC    A(TUNIT6M)         STATUS..DISP=(MOD,\nTUPL37   DC    A(TUNIT7K)         STATUS..DISP=(MOD,KEEP)\nTUPL314  DC    A(TUNIT14)         RETURN VOLSER IF ALLOCATED\nTUPLAST3 DC    XL1'80'            END OF TEXT UNITS\n         DC    AL3(0)\n         SPACE 1\nTUNIT1   DS    0C\nTUKEY1   DC    AL2(1)             ALLOCATE BY DDNAME\nTUNUM1   DC    AL2(1)\nTUENT1   DS    0C\nTULNG1A  DC    AL2(8)             LTH OF DDNAME\nTUPAR1A  DC    CL8'SYSUT2  '      DDNAME\n         SPACE 1\nTUNIT11  DS    0C\nTUKEY11  DC    AL2(2)             DSNAME\nTUNUM11  DC    AL2(1)\nTUENT11  DS    0C\nTULNG11  DC    AL2(8)             LTH OF DSNAME\nTUPAR11  DC    CL44'NULLFILE'     DSNAME = NULLFILE\n         SPACE 1\n         ENTRY TUPAR2,TUPAR2A,TUPAR2B,TUPAR2C,TUNUM2\nTUNIT2   DS    0C\nTUKEY2   DC    XL2'0010'          VOL SER\nTUNUM2   DC    AL2(1)\nTUENT2   DS    0H\nTULNG2   DC    XL2'0006'          LTH OF VOL SER\nTUPAR2   DC    CL6' '             VOL SER 1\nTULNG2A  DC    XL2'0006'          LTH OF VOL SER\nTUPAR2A  DC    CL6' '             VOL SER 2\nTULNG2B  DC    XL2'0006'          LTH OF VOL SER\nTUPAR2B  DC    CL6' '             VOL SER 3\nTULNG2C  DC    XL2'0006'          LTH OF VOL SER\nTUPAR2C  DC    CL6' '             VOL SER 4\n         SPACE 1\n         ENTRY TULNG3,TUPAR3A\nTUNIT3   DS    0C\nTUKEY3   DC    XL2'0015'          UNIT TYPE\nTUNUM3   DC    AL2(1)\nTUENT3   DS    0C\nTULNG3   DC    AL2(5)             LTH OF UNIT TYPE\nTUPAR3A  DC    CL8'SYSDA'         UNIT TYPE IS DISK\n         SPACE 1\nTUNIT4   DS    0C\nTUKEY4   DC    XL2'0016'          UNIT COUNT\nTUNUM4   DC    AL2(1)\nTUENT4   DS    0C\nTULNG4   DC    AL2(1)             LTH OF UNIT COUNT\nTUPAR4   DC    XL1'01'            UNIT COUNT IS 1\n         SPACE 1\nTUNIT5   DS    0C\nTUKEY5   DC    XL2'0024'          ALLOCATE DUMMY\nTUNUM5   DC    AL2(0)\n         SPACE 1\nTUNIT6   DS    0C\nTUKEY6   DC    XL2'0004'          STATUS OF UNIT\nTUNUM6   DC    AL2(1)\nTUENT6   DS    0C\nTULNG6A  DC    AL2(1)             LTH OF STATUS\nTUPAR6A  DC    X'04'              STATUS = NEW\n*        DC    X'08'              STATUS = SHR\n*        DC    X'04'              STATUS = NEW\n*        DC    X'02'              STATUS = MOD\n*        DC    X'01'              STATUS = OLD\n         SPACE 1\nTUNIT6M  DS    0C\nTUKEY6M  DC    XL2'0004'          STATUS OF UNIT\nTUNUM6M  DC    AL2(1)\nTUENT6M  DS    0C\nTULNG6M  DC    AL2(1)             LTH OF STATUS\nTUPAR6M  DC    X'04'              STATUS = NEW\n*        DC    X'08'              STATUS = SHR\n*        DC    X'04'              STATUS = NEW\n*        DC    X'02'              STATUS = MOD\n*        DC    X'01'              STATUS = OLD\n         SPACE 1\n         ENTRY TUPAR7A\nTUNIT7   DS    0C\nTUKEY7   DC    XL2'0005'          STATUS 2..DISP=(NEW,CATLG)\nTUNUM7   DC    AL2(1)\nTUENT7   DS    0C\nTULNG7A  DC    AL2(1)             LTH OF STATUS 2\nTUPAR7A  DC    X'02'              DISP= CATLG\n*        DC    X'08'              DISP= KEEP\n*        DC    X'04'              DISP= DELETE\n*        DC    X'02'              DISP= CATLG\n*        DC    X'01'              DISP= UNCATLG\n         SPACE 1\n         ENTRY TUPAR7K\nTUNIT7K  DS    0C\nTUKEY7K  DC    XL2'0005'          STATUS 2..DISP=(MOD,KEEP)\nTUNUM7K  DC    AL2(1)\nTUENT7K  DS    0C\nTULNG7K  DC    AL2(1)             LTH OF STATUS 2\nTUPAR7K  DC    X'02'              DISP= CATLG\n*        DC    X'08'              DISP= KEEP\n*        DC    X'04'              DISP= DELETE\n*        DC    X'02'              DISP= CATLG\n*        DC    X'01'              DISP= UNCATLG\n         SPACE 1\nTUNIT8   DS    0C\nTUKEY8   DC    XL2'0055'          RETURN DDNAME\nTUNUM8   DC    AL2(1)\nTUENT8   DS    0C\nTULNG8   DC    AL2(8)             LTH OF DDNAME\nTUPAR8   DC    CL8' '             DDNAME\n         SPACE 1\nTUNIT9   DS    0C\nTUKEY9   DC    XL2'0008'          SPACE IN CYLS\nTUNUM9   DC    AL2(0)\n         SPACE 1\nTUNIT10  DS    0C\nTUKEY10  DC    XL2'000A'          PRIMARY SPACE\nTUNUM10  DC    AL2(1)\nTUENT10  DS    0C\nTULNG10  DC    AL2(3)             LTH OF SPACE PARM\nTUPAR10  DC    XL3'000032'        QUANTITY IN HEX (DEFAULT = 50)\n         SPACE 1\nTUNIT12  DS    0C\nTUKEY12  DC    XL2'000B'          SECONDARY SPACE\nTUNUM12  DC    AL2(1)\nTUENT12  DS    0C\nTULNG12  DC    AL2(3)             LTH OF SPACE PARM\nTUPAR12  DC    XL3'00000A'        QUANTITY IN HEX (DEFAULT = 10)\n         SPACE 1\nTUNIT13  DS    0C\nTUKEY13  DC    XL2'000C'          DIRECTORY SPACE\nTUNUM13  DC    AL2(1)\nTUENT13  DS    0C\nTULNG13  DC    AL2(3)             LTH OF SPACE PARM\nTUPAR13  DC    XL3'00000A'        QUANTITY IN HEX (DEFAULT = 10)\n         SPACE 1\nTUNIT14  DS    0C\nTUKEY14  DC    XL2'005D'          RETURN VOLSER IF ALLOCATED\nTUNUM14  DC    AL2(1)\nTUENT14  DS    0C\nTULNG14  DC    AL2(6)\nTUPAR14  DC    CL6' '             VOLSER OF ALLOCATED DSN\n         SPACE 1\nTUNIT15  DS    0C\nTUKEY15  DC    XL2'0005'          STATUS 2..DISP=(OLD,DELETE)\nTUNUM15  DC    AL2(1)\nTUENT15  DS    0C\nTULNG15  DC    AL2(1)             LTH OF STATUS 2\nTUPAR15  DC    X'04'              DISP= DELETE\n*        DC    X'08'              DISP= KEEP\n*        DC    X'04'              DISP= DELETE\n*        DC    X'02'              DISP= CATLG\n*        DC    X'01'              DISP= UNCATLG\n         SPACE 1\nTUNIT30  DS    0C\nTUKEY30  DC    XL2'0030'          BLKSIZE\nTUNUM30  DC    AL2(1)\nTUENT30  DS    0C\nTULNG30  DC    AL2(2)             LTH OF BLKSIZE\nTUPAR30  DC    XL2'0000'          BLKSIZE\n         SPACE 1\nTUNIT3C  DS    0C\nTUKEY3C  DC    XL2'003C'          DSORG\nTUNUM3C  DC    AL2(1)\nTUENT3C  DS    0C\nTULNG3C  DC    AL2(2)             LTH OF DSORG\nTUPAR3C  DC    XL2'4000'          DSORG = PS\n         SPACE 1\nTUNIT42  DS    0C\nTUKEY42  DC    XL2'0042'          LRECL\nTUNUM42  DC    AL2(1)\nTUENT42  DS    0C\nTULNG42  DC    AL2(2)             LTH OF LRECL\nTUPAR42  DC    XL2'0000'          LRECL\n         SPACE 1\nTUNIT49  DS    0C\nTUKEY49  DC    XL2'0049'          RECFM\nTUNUM49  DC    AL2(1)\nTUENT49  DS    0C\nTULNG49  DC    AL2(1)             LTH OF RECFM\nTUPAR49  DC    X'90'              RECFM = FB\n         SPACE 1\nTUNIT22  DS    0C\nTUKEY22  DC    XL2'0007'          UNALLOC EVEN IF PERM ALLOC\nTUNUM22  DC    AL2(0)\n         SPACE 1\n         ENTRY TUNIT2D,TUPAR2D\nTUNIT2D  DS    0C\nTUKEY2D  DC    XL2'002D'          GET DCB INFO FROM SPECIFIED DDNAME\nTUNUM2D  DC    AL2(1)\nTUENT2D  DS    0C\nTULNG2D  DC    AL2(8)             LTH OF DDNAME\nTUPAR2D  DC    CL8'DSN     '      DDNAME\n         SPACE 1\n         SPACE 1\n         LTORG\n         SPACE 1\n*ORK     DSECT                    IF GETMAIN AT START...\n*AVE     DC    18F'-1'\n*AVECHG  DC    F'0'\n*        DS    A\n*        DS    CL6\n*        DS    CL60\n*DYNAMIC EQU   *-WORK\n         SPACE 1\n*\n* DUMMY SECTIONS\n*\n         SPACE 3\n         SPACE 3\n* DUMMY DSCB\nDSCB1    DSECT\n         IECSDSL1 (1,3)\n         SPACE 3\nDSCB4D   DSECT\n         IECSDSL1 4               DSCB4 LAYOUT\n         SPACE    2\n         REQUATE  SAVE=YES\n         PRINT    NOGEN\nSDWA     IHASDWA\n         DCBD     DSORG=(PS,PO),DEVD=DA\n         IEFZB4D0\n         IEFZB4D2\n         IHAPDS   PDSBLDL=NO\nIHAJFCB  DSECT\n         IEFJFCBN\n         SPACE 1\n         PRINT GEN\nUCBDSECT DSECT\n*        IEFUCBOB                 UCB MAPPING MACRO\n         IEFUCBOB LIST=YES  ,PREFIX=NO,SSMD=NO,DEVCLAS=TAPE\n         PRINT    NOGEN\n* DUMMY DEB\n         IEZDEB LIST=NO           DEB MAPPING MACRO\n         CVT   DSECT=YES\n*              NOTE..THE ABOVE MACROS ARE IN SYS1.AMODGEN\n         SPACE 1\n*\n         END\n/*\n//LKED.IN1     DD DSN=&&OBJECT,DISP=(SHR,PASS)\n//*            UNIT=DISK,SPACE=(TRK,(1,1,5)),\n//*            DCB=(RECFM=FB,LRECL=80,BLKSIZE=8880)\n//LKED.SYSLMOD  DD DISP=SHR,DSN=HALL.LINKLIB\n//LKED.SYSIN DD *\n INCLUDE IN1(HALLDUMP)\n ENTRY BACKDSNS\n SETCODE AC(1)\n MODE    AMODE(24) RMODE(24)\n NAME    BACKDSNS(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BACKSAMP": {"ttr": 3585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x15\\x08\\x00P\\x00P\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T15:08:00", "lines": 80, "newlines": 80, "modlines": 0, "user": "RH87944"}, "text": "//BACKDSNS JOB\n//*\n//*     DSN=CBT.SOURCE(BACKSAMP)\n//*\n//*     REMEMBER TO CHANGE MMYY IN //RESTORE!!!\n//*\n/*ROUTE PRINT R7\n//*\n//*\n//*     GET A LIST OF ALL IMSX.DBT.V23 DATASETS...\n//*\n//*      IF    PARM='ALL' IS SPECIFIED, ALL INFO WILL BE SHOWN\n//*\n//GETDSNS EXEC PGM=GETDSNS,REGION=80K\n//STEPLIB  DD DSN=HALL.LINKLIB,DISP=SHR  <=== CHANGE\n//REPORT   DD SYSOUT=*\n//*SNS     DD SYSOUT=*\n//DSNS     DD DSN=&&DSNS,\n//            UNIT=DISK,SPACE=(TRK,(1,1)),\n//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),\n//            DISP=(,PASS)\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\nIMSX.DBT.V23\n/*\n//*\n//*     BACKUP ALL IMSX.DBT.V23 DATASETS...\n//*\n//BACKDSNS EXEC PGM=BACKDSNS,REGION=4000K,COND=(0,NE)\n//STEPLIB  DD DSN=HALL.LINKLIB,DISP=SHR   <=== CHANGE\n//REPORT   DD SYSOUT=*               FOR AUDIT TRAIL\n//SYSPRINT DD SYSOUT=*               FOR PDSFAST/COPY\n//RESTORE  DD DSN=IMSX.DBT.RESTORE.JCL(DBTMMYY),DISP=SHR  <= CHANGE\n//*ESTORE  DD DSN=IMSX.DBT.RESTORE.JCL(DBTMMYY),\n//*           UNIT=DISK,SPACE=(TRK,(1,1,3)),\n//*           DCB=(RECFM=FB,LRECL=200,BLKSIZE=4000),\n//*           DISP=(,CATLG)\n//*SYSABEND DD SYSOUT=*\n//*DEBUG    DD SYSOUT=*\n//SYSUT3 DD SPACE=(CYL,20),UNIT=SYSDA\n//SYSUT4 DD SPACE=(CYL,20),UNIT=SYSDA\n//SYSUT2   DD DSN=IMSX.DBT.BACKUP.JAN0998,      <=== CHANGE\n//            UNIT=(TAPE,,DEFER),VOL=(,RETAIN),\n//            DATACLAS=NOTMM,\n//            DISP=(,KEEP),LABEL=(1,SL,EXPDT=99365)\n//SYSIN    DD *\n COPY  I=SYSUT1,O=SYSUT2\n/*\n//DSNS     DD DSN=&&DSNS,DISP=(OLD,PASS)\n//\n//*      OR DSNS COULD BE A LIST OF DATASET NAMES.....\n//DSNS     DD *\nIMSX.DBT.RESTORE.JCL\nIMSX.DBT.V23.AFABCLIB\nIMSX.DBT.V23.AFABJCL0       DIST LIB\nIMSX.DBT.V23.AFABMAC0       DIST LIB\nIMSX.DBT.V23.AFABMAC1       DIST LIB\nIMSX.DBT.V23.AFABMOD0       DIST LIB\nIMSX.DBT.V23.AFABPLIB       DIST LIB\nIMSX.DBT.V23.AFABMLIB       DIST LIB\nIMSX.DBT.V23.AFABSLIB\nIMSX.DBT.V23.FAB.CMDLIB\nIMSX.DBT.V23.FAB.INSTALLD\nIMSX.DBT.V23.FAB.INSTLIB\nIMSX.DBT.V23.FAB.JCL\nIMSX.DBT.V23.INSTALL.MANUAL\nIMSX.DBT.V23.SFABCLIB\nIMSX.DBT.V23.SFABJCL0       TARG LIB\nIMSX.DBT.V23.SFABLMD0       TARG LIB\nIMSX.DBT.V23.SFABMAC0       TARG LIB\nIMSX.DBT.V23.SFABMAC1       TARG LIB\nIMSX.DBT.V23.SFABPLIB       TARG LIB\nIMSX.DBT.V23.SFABMLIB       TARG LIB\nIMSX.DBT.V23.SFABSLIB\nIMSX.DBT.V23.SMPCSI.CSI        CSI\nIMSX.DBT.V23.SMPMTS\nIMSX.DBT.V23.SMPPTS\nIMSX.DBT.V23.SMPSCDS\nIMSX.DBT.V23.SMPSTS\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BACKSAM2": {"ttr": 3588, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03?\\t1\\x00 \\x00\"\\x00\\x05\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-02T09:31:00", "lines": 32, "newlines": 34, "modlines": 5, "user": "RH87944"}, "text": "//BACKRES2 JOB\n//*\n//*     DSN=CBT.SOURCE((BACKRES2)\n//*      SAMPLE JCL TO RESTORE DATASETS WITH BACKDSNS....\n//*\n//*    NOTE....PUT REAL VOLSER ON //SYSUT1....\n//*\n/*ROUTE PRINT R7\n//*\n//*\n//*ACKDSNS EXEC PGM=BACKDSNS,REGION=4000K,PARM='RESTORE,VOL=IMSX01'\n//BACKDSNS EXEC PGM=BACKDSNS,REGION=4000K,PARM='RESTORE'\n//STEPLIB  DD DSN=HALL.LINKLIB,DISP=SHR\n//SYSOUT   DD SYSOUT=*\n//REPORT   DD SYSOUT=*                FOR AUDIT TRAIL\n//SYSPRINT DD SYSOUT=*                FOR PDSFAST/COPY\n//DSNS     DD DSN=HALL.RESTORE2(TEST2), FOR A RESTORE LIST OF DSNS\n//            DISP=SHR\n//SYSABEND DD SYSOUT=*\n//DEBUG    DD SYSOUT=*\n//OUTDCB   DD SYSOUT=*\n//SYSUT3 DD SPACE=(CYL,20),UNIT=SYSDA\n//SYSUT4 DD SPACE=(CYL,20),UNIT=SYSDA\n//*\n//SYSUT1   DD DSN=HALL.BACKUP,\n//           UNIT=(TAPE,,DEFER),VOL=(,RETAIN,SER=VOLSER),\n//           DISP=(OLD,KEEP),LABEL=(1,SL,RETPD=0)\n//*\n//SYSIN    DD *\n COPY  I=SYSUT1,O=SYSUT2\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BLNKSCRN": {"ttr": 3590, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x12!\\x00-\\x00-\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T12:21:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "RH87944"}, "text": "//STEP1 EXEC   HLASMC\n//ASM.SYSIN DD *\n         TITLE '- SUBROUTINE TO BLANK OUT A 3270 SCREEN -'\nBLNKSCN  CSECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         USING *,R12                    DEFINE BASE REGISTER\n         STM   R14,R12,12(R13)          SAVE INCOMING REGISTERS\n         LR    R12,R15                  INITIALIZE BASE REGISTER\n         LR    R11,R13                  COPY OLD SAVE AREA POINTER\n         LA    R13,SAVE                 POINT AT NEW SAVE AREA\n         ST    R13,8(,R11)              CHAIN NEW OFF OLD\n         ST    R11,SAVE+4               AND OLD OFF NEW\nBRANCH1  BC    0,BRANCH2                NOP/BYPASS\n         OI    BRANCH1+1,X'F0'          DO THE GTSIZE ONLY ONCE\n         GTSIZE\n         LTR   R0,R0                    SEE IF A SCREEN\n         BNZ   BRANCH2                  BYPASS INSTRUCTION IF IS\n         OI    BRANCH2+1,X'F0'          NOT A SCREEN. BYPASS TPUT\nBRANCH2  BC    0,RETURN                 NOP/RETURN\n         STFSMODE ON,INITIAL=YES        TELL TSO/VTAM IN FULLSCRN\n         TPUT  BLANKOUT,L'BLANKOUT,FULLSCR    BLANK OUT THE SCREEN\n         STFSMODE OFF                   TELL TSO/VTAM OUT OF FULLSCRN\nRETURN   L     R13,SAVE+4               GET OLD SAVE AREA POINTER\n         LM    R14,R12,12(R13)          RESTORE ALL THE REGISTERS\n         SLR   R15,R15                  ZERO CONDITION CODE\n         BR    R14                      RETURN TO CALLER\nSAVE     DC    18F'0'                   SAVE AREA\nBLANKOUT DC    X'401140403C404000114040'    MESSAGE TO BLANK OUT SCREEN\n         END\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CALLIDC": {"ttr": 3592, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03?\\x122\\x03\\xbf\\x02\\xdd\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-02T12:32:00", "lines": 959, "newlines": 733, "modlines": 0, "user": "RH87944"}, "text": "//CALLIDC  JOB\n//*    DSN=CBT.SOURCE(CALLIDC)\n/*ROUTE PRINT R7\n//* EXEC HLASMCL,PARMC='NOALIGN,NORLD',CLASS='*',COND.LKED=(7,LT,ASM)\n//S EXEC HLASMCL,PARMC='ALIGN,NORLD,ESD',\n//             CLASS='*',COND.LKED=(7,LT,ASM)\n//ASM.SYSLIB DD DSN=SYS1.MACLIB,DISP=SHR\n//   DD DSN=CBT.SOURCE,DISP=SHR  IF HDUMP USED.....\n//ASM.SYSIN DD *\n*                                                                   RH\n*        THIS  VERSION USES IDCAMS TO GET THE VOLSERS               RH\n*        A DATA SET IS CATALOGED TO....                             RH\n*                                                                   RH\n*                                                                   RH\n*                                                                   RH\n*              MACRO TO DUMP CORE                                   RH\n*                                                                   RH\n*        COPY  HDUMP                                                RH\n*                                                                   RH\n*              END OF MACRO                                  DEBUG  RH\n*                                                                   RH\n*                                                                   RH\n*        JCL MUST STEPLIB TO DSN CONTAINING HALLDUMP...             RH\n*                                                                   RH\n*                  THIS IS CODE TO DUMP CORE                 DEBUG  RH\n*        SPACE 4                                             DEBUG  RH\n*                                 DUMP 1024 BYTES AT R12     DEBUG  RH\n*        HDUMP OUTDCB,R12,1024,NOTOPEN,OPEN                  DEBUG  RH\n*        L     R3,DSSEJFCB        R3 -> TO JFCB              DEBUG  RH\n*                                 DUMP 1024 BYTES AT JFCB    DEBUG  RH\n*        HDUMP OUTDCB,R3,1024,OPEN,CLOSE                     DEBUG  RH\n*        HDUMP OUTDCB,0,0,TITLE='DUMP REGS ONLY'             DEBUG  RH\n*        SPACE 1                                             DEBUG  RH\n*                  THIS IS END OF CODE TO DUMP CORE          DEBUG  RH\n*                                                                   RH\n*                                                                   RH\n         SPACE 1\n*        STANDARD REGISTER EQUATES. B.C. GOVERNMENT.\n         SPACE 1\n*        GENERAL PURPOSE REGISTERS.\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\n*        FLOATING POINT\nFL0      EQU   0\nFL2      EQU   2\nFL4      EQU   4\nFL6      EQU   6\n         SPACE 2\nBASE     EQU   12\n*DAMSV   CSECT\n*START   DS    0H\n*\n*        ENTRY POINT\n*\nCALLIDC  CSECT\nCALLIDC  AMODE 24\nCALLIDC  RMODE 24\n         USING *,R15      GET TEMP ADDRESSABILITY\n         B     AROUND             BRANCH AROUND DUMP TITLE\n         DC    AL1(EYELTH)        LTH OF EYE CATCHER\nEYECATCH DS    0C\n         DC    C'CALLIDC'         PROGRAM NAME\n         DC    C' VERSION 2.0 '   VERSION\n         DC    CL8'&SYSDATE'      DATE WRITTEN\n         DC    CL6'&SYSTIME'      TIME WRITTEN\n         DC    C'..MAKE 31-BIT COMPLIANT'    COMMENT\n*        DC    C'..HANDLE AMODE 31 MODULES'    COMMENT\nEYELTH   EQU   *-EYECATCH         LTH OF EYE CATCHER\n         SPACE 1\nAROUND   DS    0H\n         LA    R1,0(0,R1)         CLEAR HI-ORDER BYTE FOR 31 BIT\n         LA    R13,0(0,R13)       CLEAR HI-ORDER BYTE FOR 31 BIT\n         BSM   R14,0              SAVE CURRENT AMODE\n         STM   R14,R12,12(R13)    SAVE CALLERS REGS\n         LR    R12,R15            SET OUR 1ST BASE REG\n         DROP  R15                DROP TEMP BASE\n         USING CALLIDC,R12,R11    SET OUR ADDRESSABILITY\n         LA    R11,4095(0,R12)   LOAD SECOND BASE REGISTER\n         LA    R11,1(0,R11)      LOAD SECOND BASE REGISTER\n         SPACE 1\n         LA    15,SAVEAREA\n         ST    13,4(15)\n         ST    15,8(13)\n         LR    13,15\n         B     CONTINUE\n         SPACE\nSAVEAREA DC    18F'0'\n         SPACE\nCONTINUE DS    0H\n         ST    R1,PARMADDR        SAVE PARM ADDRESS\n         OPEN  (REPORT,(OUTPUT))\n         TM    REPORT+48,X'10'    DID REPORT FILE OPEN ?            RH\n         BO    GETCAT2            YES                               RH\n         DC    H'0'\n*        BZ    NEXTCAT            NO                                RH\n         SPACE\nGETCAT2  DS    0H\n*        RDJFCB STEPCAT           READ STEPCAT JFCB\n         GETMAIN LU,LA=VVDSLTH,A=VVDSADDR GET CORE FOR VVDS RECS\n         L     R1,VVDSADDR        R1 ->  VVDS  CORE\n         ST    R1,VVDSREC         SAVE IT'S ADDRESS FOR IDCAMS EXIT\n         OPEN  (INFILE,(INPUT))   OPEN CATALOG NAME FILE\n         L     R1,VVDSLTH         R1 = LTH OF AREA\n         LA    R1,0(0,R1)         CLEAR HI ORDER BYTE\n         SR    R0,R0              CLEAR R0\n         D     R0,=F'12'          R1 NOW = NBR VVDS AREAS\n         L     R14,=V(MAXVVDS)    R14 -> TO VVDS MAX CTR\n         ST    R1,0(0,R14)        SAVE IT\n         SPACE\n         L     R1,PARMADDR        R1 ->  PARM, IF ANY\n         L     R1,0(0,R1)         R1 -> TO PARMS\n         LH    R2,0(0,R1)         R2 = PARM LTH\n         LTR   R2,R2              IS THERE A PARM ?\n         BZ    NEXTCAT            NO, GO READ CATIN\n         LA    R3,2(0,R1)         R3 -> TO PARM\n         LR    R4,R3              R4 -> TO PARM\n         SPACE 1\nLOOP     DS    0H\n         CLI   0(R4),C'.'         IS CHAR A PERIOD?\n         BE    ENDLOOP            YES, END OF LOCATE NAME\n         LA    R4,1(0,R4)         NO, R4 -> TO NEXT BYTE\n         BCT   R2,LOOP            LOOK AT ALL CHARS IN PARM\n         LH    R2,0(0,R1)         R2 = LTH OF PARM\n         CH    R2,=H'8'           IS LTH OVER 8?\n         BH    SVC3               YES, ERROR ALSO\n         BCTR  R2,0               R2 = HEX LTH\n         EX    R2,SETNAME         SET UP ATTACH NAME\n         B     GETCAT             GO LOCATE CATALOG NAME\n         SPACE 1\nENDLOOP  DS    0H\n         BCTR  R2,0               -1 FOR PERIOD\n         SR    R4,R3              R4 = LTH OF ATTACH NAME\n         CH    R4,=H'8'           IS LTH OVER 8 ?\n         BH    SVC3               YES, ERROR\n         BCTR  R4,0               -1 TO GET HEX LTH\n         EX    R4,SETNAME         SET UP ATTACH NAME\n         B     GETCAT             GO AROUND DC'S\n         SPACE\nSETNAME  MVC   DSNAME(0),2(R1)    SET UP ATTACH NAME\nPARMADDR DS    F                  SET UP ATTACH NAME\n         SPACE 2\n*        TCAM   LIST\nTCAML    DS     0F\nTCFLGS   DC     X'44000000'              TCAM ON DSN\nTCAMDSN  DC     A(DSNAME)                A(DSN)\n         DC     A(0)                     VOL POINTER\n         DC     A(TWORK)                 A(265 BYTE WORK AREA)\n         DS    0D                 PUT ON DOUBLE WORD BOUNDARY\nTWORK    DS     0CL265\nVOLCNT   DC     H'0'                     VOL COUNT\nDEVTYP   DC     XL4'00'                  DEVICE TYPE\nTVOL     DC     CL6' '                   FIRST VOL SER\n         DC     CL244' '                 REST OF TCAML DATA\n         DC     CL12' '                  REST OF TCAML DATA\n         SPACE 2\nDSNAME   DC    CL44' '            DSNAME FOR LOCATE\n         SPACE\nGETCAT   DS    0H\n         LOCATE TCAML                    GO FIND VOL SER\n         LTR    R15,R15                  WAS IT FOUND ?\n         BNZ   NEXTCAT            NO, GO READ CATIN\n         SPACE 1\n         CLC   DSNAME(8),=C'CATALOG.' ICF CATALOG POINTER?       XA RH\n         BNE   NEXTCAT            NO, GO READ CATIN                 RH\n         MVC   INCATLG,DSNAME     MOVE CATALOG NAME TO IDCAMS CTL STMT\n         B     NOSMCA             GO DO IDCAMS CALL\n         SPACE\nNEXTCAT  DS    0H\n         L     R1,VVDSADDR        R1 ->  VVDS  CORE\n         ST    R1,VVDSREC         SAVE IT'S ADDRESS FOR IDCAMS EXIT\n         SPACE\n         TM    INFILE+48,X'10'    DID NAME FILE OPEN ?              RH\n         BZ    SVC3               NO                                RH\n         GET   INFILE,JFCB        READ A CATALOG NAME\n         MVC   INCATLG,JFCBDSNM   MOVE CATALOG NAME TO IDCAMS CTL STMT\n         SPACE\nNOSMCA   DS    0H                                                   RH\n         LINK  EP=IDCAMS,PARAM=(OPTIONS,DNAMES,PGNO,IOLIST),VL=1\n         LTR   R15,R15            WAS LINK OKAY\n         BZ    SVCOKAY2           YES\n         SPACE 1\n*\n*              CONVERT RC TO DECIMAL\n*\n         ST    R15,DWORD          SAVE RC\n         MVC   LOCRC(3),DWORD+1   PUT IN HEX RC\n         UNPK  LOCRC(4),DWORD+2(3) UNPACK ECB             DEBUG\n         MVI   LOCRC+3,X'EF'      TRANSLATES TO BLANK     DEBUG\n         TR    LOCRC(4),TRTAB-239 TRANSLATE TO DISPLAY    DEBUG\n         SPACE 1\n         SPACE 1\n         MVC   MSG(L'LOCMSG3),LOCMSG3  MOVE MSG TO LINE             RH\n         LA    R15,MSG+L'LOCMSG3+2                                  RH\n         MVC   0(LOCMSGRL,R15),LOCMSGR PUT RC IN LINE               RH\n         B     PRINTIT            PRINT LOCATE ERROR MSG            RH\n         SPACE 1\nSVCOKAY2 DS    0H                                                   RH\n         MVC   MSG(L'LOCMSG4),LOCMSG4  MOVE MSG TO LINE             RH\n         SPACE 1\nPRINTIT  DS    0H\n*\n*              IDCAMS EXITS WILL  HAVE CLOSED THE REPORT            RH\n*              DCB, SO RE-OPEN IT                                   RH\n*\n         OPEN  (REPORT,(OUTPUT))\n         TM    REPORT+48,X'10'    DID REPORT FILE OPEN ?            RH\n         BO    GETCAT3            YES                               RH\n         DC    H'0'\n         SPACE\nGETCAT3  DS    0H\n         PUT   REPORT,INFO1       OUTPUT THE MSG\n         MVI   MSG,C' '           CLEAR PRINT LINE\n         MVC   MSG+1(131),MSG     *\n         SPACE 1\n\n\n\n         TM    SW,X'40'           END OF LINKS ?\n         BZ    NOSMCA             NO,  DO ANOTHER ONE\n         SPACE 1\n         NI    SW,255-X'40'       CLEAR SWITCH\n         L     R1,VVDSADDR        R1 -> TO 1ST VVDS\n         ST    R1,VVDSREC         SAVE IT'S ADDRESS\n*        OPEN  (REPORT,(OUTPUT))\n*        TM    REPORT+48,X'10'    DID REPORT FILE OPEN ?            RH\n*        BZ    NEXTCAT            NO                                RH\n\n*        HDUMP OUTDCB,0,0,NOTOPEN,OPEN   OPEN SYSOUT         DEBUG  RH\n*        HDUMP OUTDCB,0,0,TITLE='BACK FROM IDCAMS'           DEBUG  RH\n         SPACE 1\nDYNLOOP  DS    0H\n         L     R2,VVDSREC         R2 -> TO VVDS NAME\n*                                 DUMP 44 BYTES AT R2        DEBUG  RH\n*        HDUMP OUTDCB,R2,44,OPEN,OPEN                        DEBUG  RH\n*        L     R3,DSSEJFCB        R3 -> TO JFCB              DEBUG  RH\n*                                 DUMP 1024 BYTES AT JFCB    DEBUG  RH\n*        HDUMP OUTDCB,R3,1024,OPEN,CLOSE                     DEBUG  RH\n*        HDUMP OUTDCB,0,0,TITLE='DUMP REGS ONLY'             DEBUG  RH\n         MVC   PRINT+1(6),6(R2)   MVC IT TO PRINT AREA\n         PUT   REPORT,PRINT       PRINT IT\n         LA    R2,12(0,R2)        R2 -> TO NEXT VVDS NAME\n         ST    R2,VVDSREC         SAVE IT\n         L     R1,VVDSCTR         R1 = NUMBER OF VVDS'S\n         LTR   R1,R1              ANY MORE ?\n         BZ    NEXTCAT            NO, GET NEXT CATALOG NAME\n         BCTR  R1,0               -1\n         ST    R1,VVDSCTR         SAVE NUMBER LEFT\n         SPACE 1\n         B     DYNLOOP            GO FOR NEXT VVDS\n         SPACE 1\nSVC3     DS    0H\n         CLOSE INFILE             CLOSE SYSIN\n         L     R15,0              LOAD RC\n         L     R13,4(R13)         R13 -> TO CALLERS SAVE AREA\n         L     R14,12(R13)        SET R14 TO WHAT CALLER'S R14\n         LM    R0,R12,20(R13)     SET R0-R12 TO CALLERS REGS\n*              GET INTO PROPER MODE AND GO BACK TO CALLER\n         BSM   0,R14              RETURN TO CALLING PROGRAM\n*\n*        ABEND\n*\n         SPACE 3\nABEND    ABEND 81,DUMP,STEP      BAD READ OF VSAM DATA SET\n         SPACE 3\nDWORD    DC    D'0'\nLOCMSG3  DC    C'LINK TO IDCAMS FAILED...'\nLOCMSG4  DC    C'LINK TO IDCAMS WAS OKAY.'\nLOCMSGR  DS    0C\n         DC    C'RC='\nLOCRC    DC    C'XXX'\n         DC    C' ... FDBK='\nLOCFDBK  DC    C'YYYY'\nLOCMSGRL EQU   *-LOCMSGR\n*\nINFO1    DS    0CL133\n         DC    C'0'\nMSG      DC    CL44' '\nCTLTOTAL DC    CL8' '\n         DC    CL80' '\n*\nTRTAB    DC    C' 0123456789ABCDEF'\n*\nOPTIONS  DC    H'0'\nDNAMES   DC    H'0'\nPGNO     DC    H'0'\nIOLIST   DC    F'2'\n         DC    A(ASYSIN)          CONTROLLER FOR SYSIN\n         DC    A(INRTN)\n         DC    A(AUDATA)\n         DC    A(BSYSOUT)         CONTROLLER FOR SYSPRINT\n         DC    A(OUTRTN)\n         DC    A(BUDATA)\nASYSIN   DC    CL10'DDSYSIN'\nBSYSOUT  DC    CL10'DDSYSPRINT'\nAUDATA   DC    CL256' '\nBUDATA   DC    CL256' '\n         SPACE 5\n* DYNALLOC PARAMETER LIST\n         DS    0D\n         ENTRY VVDSADDR\nVVDSADDR DC    A(VVDSNAME)\nVVDSLTH  DC    AL1(128)\n         DC    AL3(1200)          ROOM FOR 100 VOLSERS....\nPARML    DC    A(VVDSNAME)\n         DC    XL1'80',AL3(VVDSVOL)\n*\nVVDSNAME DC    CL44' '\nVVDSVOL  DC    CL6' '\n*\n         SPACE 1\n*\n*        ENTRY POINT\n*\n*NRTN    CSECT\n*NRTN    AMODE 24\n*NRTN    RMODE 24\nINRTN    DS    0H\n         USING *,R15      GET TEMP ADDRESSABILITY\n         B     AROUND2            BRANCH AROUND DUMP TITLE\n         DC    AL1(EYELTH2)       LTH OF EYE CATCHER\nEYECAT2  DS    0C\n         DC    C'INRTN  '         PROGRAM NAME\n         DC    C' VERSION 2.0 '   VERSION\n         DC    CL8'&SYSDATE'      DATE WRITTEN\n         DC    CL6'&SYSTIME'      TIME WRITTEN\n         DC    C'..MAKE 31-BIT COMPLIANT'    COMMENT\n*        DC    C'..HANDLE AMODE 31 MODULES'    COMMENT\nEYELTH2  EQU   *-EYECAT2          LTH OF EYE CATCHER\n         SPACE 1\nAROUND2  DS    0H\n         LA    R1,0(0,R1)         CLEAR HI-ORDER BYTE FOR 31 BIT\n         LA    R13,0(0,R13)       CLEAR HI-ORDER BYTE FOR 31 BIT\n         BSM   R14,0              SAVE CURRENT AMODE\n         STM   R14,R12,12(R13)    SAVE CALLERS REGS\n         LR    R12,R15            SET OUR 1ST BASE REG\n         DROP  R15                DROP TEMP BASE\n         USING INRTN,R12,R11      SET OUR ADDRESSABILITY\n         LA    R11,4095(0,R12)   LOAD SECOND BASE REGISTER\n         LA    R11,1(0,R11)      LOAD SECOND BASE REGISTER\n         SPACE 1\n         LA    15,INSAVE\n         ST    13,4(15)\n         ST    15,8(13)\n         LR    13,15\n         B     CONT2\n         SPACE\nINSAVE   DC    18F'0'\n         SPACE\nCONT2    DS    0H\n         L     R2,4(0,R1)         R2 -> TO IOFLAGS                  RH\n         USING IOFLAGS,R2         SET BASE                          RH\n         CLI   IOFLAG1,IOFOPEN    OPENING SYSIN?\n*        BE    RETRC0             YES, SAY OPEN WAS OK\n         BE    OPENIN             YES, SAY OPEN WAS OK\n         CLI   IOFLAG1,IOFCLOS    CLOSE SYSIN?\n         BE    RETRC0             YES, SAY CLOSE WAS OKAY\n*        BE    CLOSIN             YES, GO CLOSE IT\n         TM    IOFLAG1,IOFGET     DOES IDCAMS WANT A RECORD?\n         BO    GIVEREC            YES, PASS IT A PRINT CMD\n         B     RETRC12            IGNORE EVERYTHING ELSE\n         SPACE 1\nGIVEREC  DS    0H\n         L     R3,8(0,R1)         R3 -> TO RECORD AREA\n         USING IOINFO,R3          SET BASE                          RH\n         L     R15,INREC          R15 -> TO PRINT CTL RECORD\n         LH    R14,0(0,R15)       R14 = LTH OF RECORD\n         ST    R14,IOIRECL        PASS IT TO IDCAMS\n         LA    R1,2(0,R15)        R1 -> TO RECORD\n         ST    R1,IOIREC          PASS IT TO IDCAMS\n         AR    R15,R14            ADD REC LTH TO R15\n         LA    R15,2(0,R15)       R15 -> TO NEXT REC\n         ST    R15,INREC          SAVE ITS ADDRESS\n         CLC   0(2,R1),ENDATA     END OF INPUT TO IDCAMS?\n         BE    RETRC4             YES\n         SPACE 1\nRETRC0   DS    0H\n         LA    R15,0              SAY  GET WAS OK                   RH\n         B     RET2               GO BACK TO IDCAMS                 RH\nRETRC4   DS    0H\n         LA    R15,4              SAY  NO MORE SYSIN                RH\n         B     RET2               GO BACK TO IDCAMS                 RH\n         SPACE 1\nCLOSIN   DS    0H\n*        CLOSE INFILE             CLOSE SYSIN\n*        B     RETRC0             RETURN\n         SPACE 1\nOPENIN   DS    0H\n         LA    R15,INLTH          R15 -> TO 1ST INPUT AREA\n         ST    R15,INREC          RESET INPUT REC ADDRESS\n         B     RETRC0             GO SET RC AND RETURN\n*        OPEN  (INFILE,(INPUT))\n*        TM    INFILE+48,X'10'    DID REPORT FILE OPEN ?            RH\n*        BO    RETRC0             YES                               RH\n         SPACE 1\nRETRC12  DS    0H\n         LA    R15,12             SAY CALL WAS BAD                  RH\n         B     RET2               GO BACK TO IDCAMS                 RH\n         SPACE 1\nRET      LA    15,0          GET RETURN CODE\n         ORG   *-2\nRETRC    DS    H             HALF WORD RETURN CODE, INITIALY ZERO\nRET2     DS    0H\n         L     R13,4(R13)         R13 -> TO CALLERS SAVE AREA\n         L     R14,12(R13)        SET R14 TO CALLER'S R14\n         LM    R0,R12,20(R13)     SET R0-R12 TO CALLERS REGS\n*              GET INTO PROPER MODE AND GO BACK TO CALLER\n         BSM   0,R14              RETURN TO CALLING PROGRAM\n*\n         SPACE 1\n*NREC    DC    A(INLTH)\n*NLTH    DC    AL2(INCTLL)\n*NCTL    DC    C' LISTCAT CATALOG ( '                   19\n*NCATLG  DC    CL38' '                                  38\n*        DC    C' ) LEVEL ( SYS1.VVDS  )'               23\n*\nINREC    DC    A(INLTH)\nINLTH    DC    AL2(INCTLL)\nINCTL    DC    C' LISTCAT ENT( '                        14\nINCATLG  DC    CL44' '                                  44\n         DC    C' ) VOL '                                7\n         DC    CL(80-(*-INCTL))'  '                     80 LONG...\nINCTLL   EQU   *-INCTL\n*\nINLTH2   DC    AL2(2)\nENDATA   DC    C'/*'\n         SPACE 1\nINFILE   DCB   DSORG=PS,DDNAME=CATIN,LRECL=80,RECFM=FB,             XXXX\n               MACRF=(GM),EODAD=SVC3\nSTEPCAT  DCB   DSORG=PS,DDNAME=STEPCAT,LRECL=80,RECFM=FB,           XXXX\n               MACRF=(GM),BLKSIZE=80,EXLST=JFCBADD\n         DS    0F\n         DC    C'JFCB'            KEEP JFCB AT REPORT+352           RH1\nJFCBDSNM DS    0C\nJFCB     DC    CL176' '\n*        ORG   JFCB               BACK TO START OF JFCB\n*        IEFJFCBN                 GEN JFCB LABELS\nJFCBADD  DC    X'87'              JFCB ADDRESS                      RH1\n         DC    AL3(JFCB)          *                                 RH1\n         EJECT\n*\n*        ENTRY POINT\n*\n*UTRTN   CSECT\n*UTRTN   AMODE 24\n*UTRTN   RMODE 24\nOUTRTN   DS    0H\n         USING *,R15      GET TEMP ADDRESSABILITY\n         B     AROUND3            BRANCH AROUND DUMP TITLE\n         DC    AL1(EYELTH3)       LTH OF EYE CATCHER\nEYECAT3  DS    0C\n         DC    C'OUTRTN '         PROGRAM NAME\n         DC    C' VERSION 2.0 '   VERSION\n         DC    CL8'&SYSDATE'      DATE WRITTEN\n         DC    CL6'&SYSTIME'      TIME WRITTEN\n         DC    C'..MAKE 31-BIT COMPLIANT'    COMMENT\n*        DC    C'..HANDLE AMODE 31 MODULES'    COMMENT\nEYELTH3  EQU   *-EYECAT3          LTH OF EYE CATCHER\n         SPACE 1\nAROUND3  DS    0H\n         LA    R1,0(0,R1)         CLEAR HI-ORDER BYTE FOR 31 BIT\n         LA    R13,0(0,R13)       CLEAR HI-ORDER BYTE FOR 31 BIT\n         BSM   R14,0              SAVE CURRENT AMODE\n         STM   R14,R12,12(R13)    SAVE CALLERS REGS\n         LR    R12,R15            SET OUR 1ST BASE REG\n         DROP  R15                DROP TEMP BASE\n         USING OUTRTN,R12,R11     SET OUR ADDRESSABILITY\n         LA    R11,4095(0,R12)   LOAD SECOND BASE REGISTER\n         LA    R11,1(0,R11)      LOAD SECOND BASE REGISTER\n         LA    15,OUTSAVE\n         ST    13,4(15)\n         ST    15,8(13)\n         LR    13,15\n         B     CONT3\n         SPACE\nOUTSAVE  DC    18A(0)\n         SPACE\nCONT3    DS    0H\n         L     R2,4(0,R1)         R2 -> TO IOFLAGS                  RH\n         USING IOFLAGS,R2         SET BASE                          RH\n         CLI   IOFLAG1,IOFOPEN    OPENING SYSPRINT ?\n         BE    OPENSYS            YES, SAY OPEN WAS OK\n         CLI   IOFLAG1,IOFCLOS    CLOSE SYSPRINT ?\n         BE    CLOSOUT            YES, GO CLOSE IT\n         TM    IOFLAG1,IOFPUT     DOES IDCAMS HAVE A RECORD FOR US?\n         BO    GETREC             YES, GO GET IT\n         B     OUTRC12            IGNORE EVERYTHING ELSE\n         SPACE 1\nCLOSOUT  DS    0H\n         CLOSE REPORT             CLOSE SYSPRINT\n         OI    SW,X'40'           SAY END OF CALLS\n*        B     OUTRC12            RETURN\n         B     OUTRC0             RETURN\n         SPACE 1\nGETREC   DS    0H\n         L     R3,8(0,R1)         R3 -> TO RECORD AREA\n         USING IOINFO,R3          SET BASE                          RH\n         L     R5,IOIREC          R5 -> TO RECORD FROM IDCAMS\n         L     R4,IOIRECL         R4 = LTH OF RECORD\n         SPACE 1\nCHKLTH   CH    R4,=H'133'         LTH OVER 133?\n         BL    LTHOK              NO\n         MVC   PRINT,0(R5)        MOVE 133 BYTES\n         LA    R5,133(0,R5)       R5 -> TO NEXT 133 BYTES\n         SH    R4,=H'133'         R4 = LTH LEFT\n         B     PUTIT              PRINT IT\n         SPACE 1\nLTHOK    DS    0H\n         BCTR  R4,0               -1 FOR HEX LTH\n         STC   R4,PUTLTH+1        SET LTH\nPUTLTH   MVC   PRINT(0),0(R5)     MOVE DATA\n         SR    R4,R4              R4=0\n         SPACE 1\nPUTIT    DS    0H\n         PUT   REPORT,PRINT       PRINT IT\n         LA    R14,PRINT+1        R14 -> TO DATA AFTER CC\n         LA    R15,20             R15 = NBR CHARS TO CHECK\n*\nPUTIT2   DS    0H\n         CLI   0(R14),C' '        FOUND NON BLANK?\n         BNE   PUTIT4             YES\n         LA    R14,1(0,R14)       NO, R14 -> AT NEXT BYTE\n         BCT   R15,PUTIT2         CHECK MAX CHARS\n         B     ENDPUT             MUST BE A BLANK LINE....\n*\nPUTIT4   DS    0H\n         CLC   =C'VOLSER---',0(R14)  DO WE WANT THIS RECORD?\n         BNE   ENDPUT             NO\n*\n*    ONCE WE FIND THE VOL INFO IN THE IDCAMS OUTPUT,\n*    IT SHOULD LOOK LIKE THIS.....\n*\n*    VOLSER------------B16038     DEVTYPE------X'78048081'\n*\n*    THE DEVTYPE HAS TO BE CONVERTED TO HEX\n*\n*VOLREC  DSECT\n*        DS    CL18               JUNK BEFORE VOLSER...\n*IDCVOL  DS    CL6                THE VOLSER\n*        DS    CL20               JUNK BEFORE THE DEVTYPE...\n*IDCDEV  DS    CL8                THE VOLSER DEVTYPE IN DECIMAL\n*\n         USING VOLREC,R14         SET VOLSER RECORD BASE\n         PACK  PACKDEV(5),IDCDEV(9)  PACK DEVTYPE TO MAKE IT HEX...\n*\n*              NOW SET UP PSEUDO LOCATE WORK AREA....\n*\n\n*\nGOTVVDS  DS    0H\n         L     R6,VVDSREC         R6 -> TO WHERE VVDS NAME IS SAVED\n         MVC   0(2,R6),=X'0001'   SET COUNT TO 1\n         MVC   2(4,R6),PACKDEV    SET DEVTYPE\n         MVC   6(6,R6),IDCVOL     SET VOLSER\n         DROP  R14                DROP VOLSER RECORD BASE\n         LA    R6,12(0,R6)        ADD 12 TO R6\n         ST    R6,VVDSREC         SAVE IT\n         L     R6,VVDSCTR         R6 = VVDS COUNTER\n         LA    R6,1(0,R6)         ADD 1 TO R6\n         ST    R6,VVDSCTR         SAVE IT\n         L     R1,=V(VVDSADDR)    R1 -> A(FIRST VOLSER ENTRY)\n         L     R1,0(0,R1)         R1 ->   FIRST VOLSER ENTRY\n         STH   R6,0(0,R1)         SET NBR ENTRIES\n         C     R6,MAXVVDS         MORE THAN MAX VVDS RECORDS?\n         BNH   ENDPUT             NO\n*        SAY   TOO MANY VOLSERS.. ...\n         B     OUTRC12            YES, END OF IDCAMS\n*        BH    ABEND2             YES\n         SPACE 1\n*        PUT   REPORT,PRINT       PRINT IT\n         SPACE 1\nENDPUT   DS    0H\n         MVI   PRINT,C' '         CLEAR PRINT LINE\n         MVC   PRINT+1(132),PRINT ''\n         LTR   R4,R4              ANY LEFT?\n         BP    CHKLTH             YES, GO PRINT IT\n         SPACE 1\n         B     OUTRC0             GO GET THE NEXT RECORD\n         SPACE 1\nABEND2   ABEND 82,DUMP,STEP      BAD READ OF VSAM DATA SET\n         SPACE 1\nOPENSYS  DS    0H\n         OPEN  (REPORT,(OUTPUT))\n         TM    REPORT+48,X'10'    DID REPORT FILE OPEN ?            RH\n         BZ    OUTRC12            NO                                RH\n         SPACE 1\nOUTRC0   DS    0H\n         LA    R15,0              SAY  GET WAS OK                   RH\n         B     RET4               GO BACK TO IDCAMS                 RH\n         SPACE 1\nOUTRC12  DS    0H\n         LA    R15,12             SAY CALL WAS BAD                  RH\n         B     RET4               GO BACK TO IDCAMS                 RH\n         SPACE 1\nRET3     LA    15,0          GET RETURN CODE\n         ORG   *-2\nRETRC2   DS    H             HALF WORD RETURN CODE, INITIALY ZERO\nRET4     DS    0H\n         L     R13,4(R13)         R13 -> TO CALLERS SAVE AREA\n         L     R14,12(R13)        SET R14 TO CALLER'S R14\n         LM    R0,R12,20(R13)     SET R0-R12 TO CALLERS REGS\n*              GET INTO PROPER MODE AND GO BACK TO CALLER\n         BSM   0,R14              RETURN TO CALLING PROGRAM\n*\nPACKDEV  DC    PL5'0'\n         SPACE 1\nREPORT   DCB   DSORG=PS,DDNAME=IDCPRINT,LRECL=133,RECFM=FBA,        XXXX\n               MACRF=(PM),BLKSIZE=133\n         SPACE 1\nSW       DC    X'00'\nPRINT    DC    CL133' '\nVVDSCTR  DC    F'0'\n         ENTRY MAXVVDS\nMAXVVDS  DC    A(1)\nVVDSREC  DC    A(VVDSREC1)\nVVDSREC1 DC    CL44' '\n*        DC    19CL44' '\n         LTORG\nIOFLAGS  DSECT\nIOFLAG1  DS    X\nIOFOPEN  EQU   X'00'\nIOFCLOS  EQU   X'04'\nIOFGET   EQU   X'08'\nIOFPUT   EQU   X'0C'\nIOFLAG2  DS    X\nIOFIN    EQU   X'80'\nIOFOUT   EQU   X'40'\nIOFLAG3  DS    X\nIOFLAG4  DS    X\n         SPACE 1\nIOINFO   DSECT\nIOIREC   DS    F\nIOIRECL  DS    F\n         SPACE 1\n*\n*    ONCE WE FIND THE VOL INFO IN THE IDCAMS OUTPUT,\n*    IT SHOULD LOOK LIKE THIS.....\n*\n*    VOLSER------------B16038     DEVTYPE------X'78048081'\n*\nVOLREC   DSECT\n         DS    CL18               JUNK BEFORE VOLSER...\nIDCVOL   DS    CL6                THE VOLSER\n         DS    CL20               JUNK BEFORE THE DEVTYPE...\nIDCDEV   DS    CL8                THE VOLSER DEVTYPE IN DECIMAL\n         SPACE 1\n         END\n/*\n//LKED.SYSLMOD  DD  DISP=(NEW,PASS),DSN=&&GOSET,\n//             SPACE=(CYL,(2,1,2)),UNIT=SYSDA\n//LKED.DD1     DD DSN=HALL.LINKLIB,DISP=SHR\n//LKED.SYSIN DD *\n    SETCODE AC(1)\n   ENTRY CALLIDC\n    NAME CALLIDC(R)\n/*\n//*\n//S EXEC HLASMCL,PARMC='ALIGN,NORLD',CLASS='*',COND.LKED=(7,LT,ASM)\n//ASM.SYSIN DD *\n*\n*\n*\n*              THIS LITTLE PROGRAM IS AN EXAMPLE OF HOW TO\n*              USE SVC99 TO DYNAMICALLY ALLOC DDNAMES AND DCBS,\n*              THEN TO OPEN/READ/CLOSE THE FILE, THEN TO\n*              DYNAMICALLY DE-ALLOCATE THE FILE.\n*\n*              THERE IS AN EXAMPLE OF A DCB ABEND EXIT AND AN\n*              ESTAE EXIT IN HERE ALSO. THESE ARE USED TO TRAP ANY\n*              OPEN OR PROGRAM ERRORS.\n*\n*              INPUT TO DYNALLOC  IS THROUGH //SYSIN AND ALL THAT\n*              IS NEEDED IS THE DATASET NAME.\n*\n*\n*\n*\n         TITLE 'TRY TO DO SVC99 TO DYNAMICALLY ALLOCATE DATASETS'\n         SPACE 3\nDYNALOC  CSECT\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         USING DYNALOC,R12\n         B     AROUND             BRANCH AROUND DUMP TITLE\n         DC    C'DYNALOC'         PROGRAM NAME\n         DC    CL8'&SYSDATE'      DATE WRITTEN\n         DC    CL6'&SYSTIME'      TIME WRITTEN\n         SPACE 1\nAROUND   DS    0H\n         LR    R2,R1              R2 -> TO PARM ADDRESS\n         GETMAIN R,LV=LDYNAMIC    GET CORE FOR WORK AREA\n         LR    R3,R1              R3 -> TO WORK AREA\n         USING WORK,R3            SET WORK BASE\n         LA    R4,SAVE            R4 -> TO SAVE AREA\n         ST    R13,SAVE+4         SAVE A(WYLBURS SAVE AREA)\n         ST    R4,8(0,R13)        CHAIN OUR SAVE AREA\n         LR    R13,R4             R13 -> TO OUR SAVE AREA\n         OPEN  (REPORT,(OUTPUT))\n         SPACE 1\nREADCARD DS    0H\n         L     R1,0(0,R2)         R1 -> TO VVDS NAME                RH\n         SPACE 1\nPACKIT   DS    0H\n         MVI   S99VERB,X'01'      SAY WE WANT TO ALLOCATE BY DSNAME\n         MVI   TUPL5,X'00'        MAKE SURE WE USE ALL OF TEXT UNITS\n         LA    R5,0               ASSUME THERE IS NO PASSWORD\n         ST    R5,TUPL3           *\n         LA    R5,TUNIT4          MAKE SURE WE USE STATUS 1 TEXT UNIT\n         ST    R5,TUPL4           *\n         LA    R5,TUNIT2          ALSO USE VOL SER  TEXT UNIT\n         ST    R5,TUPL2           *\n         SPACE 1\nLTHLOOP  DS    0H\n         SR    R5,R5              R5 = 0\n         LR    R6,R1              R6 -> TO DSN\nLOOP1    DS    0H\n         CLI   0(R6),C' '         AT END OF DSN ?\n         BE    OUT1               YES, MOVE IT TO SVC 99 FIELD\n         LA    R6,1(0,R6)         ADD 1 DSN POSITION REG\n         LA    R5,1(0,R5)         ADD 1 TO LTH CTR\n         B     LOOP1              LOOK AT NEXT CHAR\nMVCDSN   MVC   TUPAR1(0),0(R1)    MVC DSN TO S99 BLOCK\nOUT1     DS    0H\n         STH   R5,TULNG1          SET UP LTH FIELD FOR SVC99\n         BCTR  R5,0               - 1 FOR EX\n         EX    R5,MVCDSN          MOVE DSN TO S99 BLOCK\n         SH    R6,=H'6'           R6 -> TO VOL SER IN VVDS NAME\n         MVC   TUPAR2,0(R6)       MOVE VOLSER TO SVC99 PARM\n         MVC   MSG(07),=C'DSNAME=' SET UP DSNAME MSG\n         MVC   MSG+7(44),TUPAR1    PUT DSNAME IN MSG\n         PUT   REPORT,INFO1       OUTPUT THE MSG\n         MVI   MSG,C' '           CLEAR PRINT LINE\n         MVC   MSG+1(131),MSG     *\n         SPACE 1\nDOSVC99  DS    0H\n         LA    R1,S99RBPTR        R1 -> TO SVC 99 PARMS\n         SVC   99\n         LTR   R15,R15            WAS SVC OKAY ?\n         BZ    SVCOKAY            YES\n         SPACE 1\nPHEAD    DS    0H\n         MVC   MSG(L'LOCMSG2),LOCMSG2  MOVE MSG TO LINE             RH\n         B     PRINTIT            PRINT LOCATE ERROR MSG            RH\n         SPACE 1\nSVCOKAY  DS    0H                                                   RH\n*        MVC   DDNMSG,TUPAR6      MOVE DDNAME TO MSG                RH\n*        MVC   MSG(L'LOCMSG1),LOCMSG1  MOVE MSG TO LINE             RH\n         SPACE 1\nCLOSEIT2 DS    0H\n         MVI   S99VERB,X'02'      CHANGE TO UNALLOCATE\n         LA    R5,0               DON'T USE PASSWORD TEXT UNIT FOR FREE\n         ST    R5,TUPL3           *\n         ST    R5,TUPL4           CAN'T USE STATUS 1 EITHER\n         ST    R5,TUPL2           CAN'T USE VOL SER  EITHER\n         MVI   TUPL5,X'80'        END LIST AT STATUS 2..DISP=KEEP\n         LA    R1,S99RBPTR        R1 -> TO SVC 99 PARMS\n         SVC   99                 FREE DDNAME AND FILE\n         LTR   R15,R15            WAS SVC OKAY ?\n         BZ    SVCOKAY2           YES\n         SPACE 1\n         MVC   MSG(L'LOCMSG3),LOCMSG3  MOVE MSG TO LINE             RH\n         B     PRINTIT            PRINT LOCATE ERROR MSG            RH\n         SPACE 1\nSVCOKAY2 DS    0H                                                   RH\n         MVC   MSG(L'LOCMSG4),LOCMSG4  MOVE MSG TO LINE             RH\n         SPACE 1\nPRINTIT  DS    0H\n         PUT   REPORT,INFO1       OUTPUT THE MSG\n         MVI   MSG,C' '           CLEAR PRINT LINE\n         MVC   MSG+1(131),MSG     *\n*        B     READCARD           GO GET ANOTHER CARD\n         SPACE 1\nNOMORE   DS    0H\n         CLOSE REPORT             CLOSE FILES\n         L     R13,4(0,R13)       POINT R13 BACK TO WYLBUR SAVEAREA\n         FREEMAIN R,LV=LDYNAMIC,A=(3)  FREE GOTTEN CORE\n*        L     R3,VVDSADDR        R3 -> TO VVDS GOTTEN CORE\n*        FREEMAIN R,LV=LDYNAMIC,A=(3)  FREE GOTTEN CORE\n         LM    R14,R12,12(R13)    RELOAD WYLBURS REGS\n         SLR   R15,R15            SET RETURN CODE\n         BR    R14\n         SPACE 1\n* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n*        WORK AREAS\n* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\nDUMPTITL DC    C'WORKING STORAGE SECTION'\n* ------ INPUT AREA               ------------------------------------\nJCLCARD  DC    CL80' '            CARD INPUT AREA\n         SPACE 1\n* ------ WORK  AREAS              ------------------------------------\nNOCARDS  DC    PL4'0'             NUMBER OF CARDS READ\nLOCMSG   DC    C'SVC 99 WAS SUCCESSFUL FOR ALLOCATE, DDNAME = '\nDDNMSG   DC    CL8' '\nLLOCMSG  EQU   *-LOCMSG\nINPMSG   DC    C'ENTER A DSNAME(MBR)/PSWD OR ''END'''\nLINPMSG  EQU   *-INPMSG\nLOCMSG1  DC    C'SVC 99 WAS SUCCESSFUL FOR ALLOCATE'\nLOCMSG2  DC    C'SVC 99 WAS UNSUCCESSFUL FOR ALLOCATE'\nLOCMSG3  DC    C'SVC 99 WAS UNSUCCESSFUL FOR UNALLOCATE'\nLOCMSG4  DC    C'SVC 99 WAS SUCCESSFUL FOR ALLOCATE/UNALLOCATE'\nINFO1    DS    0CL133\n         DC    C'0'\nMSG      DC    CL44' '\nCTLTOTAL DC    CL8' '\n         DC    CL80' '\n         EJECT\nRPWORK   DS    D\nRSAVE    DS    9D\nRFELD1   DC    PL4'0'\nRHEADING DC    CL1'-'\nRDATE    DS    CL12\n         DC    CL120'     LISTING OF BACKUP TAPES'\n*        DCB'S  FOR FILES\n*\n* ------ DCB'S                    ------------------------------------\n*ARDIN   DCB   DSORG=PS,DDNAME=SYSIN,EODAD=NOMORE,MACRF=(GM)\nREPORT   DCB   DSORG=PS,DDNAME=SYSPRINT,LRECL=133,RECFM=FBA,        XXXX\n               MACRF=(PM),BLKSIZE=133\n*ILEDCB  DCB   DSORG=PS,DDNAME=VARIES,EODAD=CLOSEIT,MACRF=(GL),     ++++\n               EXLST=DCBABEND\n         SPACE 1\n*              CONTROL BLOCKS FOR  SVC 99\n         DS    0F                 PUT ON FULLWORD BOUNDARY\nS99RBPTR DC    XL1'80'\n         DC    AL3(S99RB)\nS99RB    DS    0F\nS99RBLN  DC    AL1(20)\nS99VERB  DC    AL1(1)             ALLOCATE BY DSNAME\nS99FLAG1 DC    XL2'2000'          DON'T MOUNT VOLS OR CONSIDER OFFLINES\nS99ERROR DC    AL2(0)\nS99INFO  DC    AL2(0)\nS99TXTPP DC    A(S99TUPL)\nS99RES1  DC    A(0)\nS99FLAG2 DC    A(0)\n         SPACE 1\nS99TUPL  DS    0F\nTUPL1    DC    A(TUNIT1)\nTUPL2    DC    A(TUNIT2)\nTUPL3    DC    A(TUNIT3)\nTUPL4    DC    A(TUNIT4)\nTUPL5    DC    A(TUNIT5)\nTUPL6    DC    XL1'80'\n         DC    AL3(TUNIT6)\n         SPACE 1\nTUNIT1   DS    0C\nTUKEY1   DC    AL2(2)             ALLOCATE BY DSNAME\nTUNUM1   DC    AL2(1)\nTUENT1   DS    0C\nTULNG1   DC    AL2(44)            LTH OF DSNAME\nTUPAR1   DC    CL44' '            DSNAME\n         SPACE 1\nTUNIT2   DS    0C\nTUKEY2   DC    XL2'0010'          VOL SER\nTUNUM2   DC    AL2(1)\nTUENT2   DS    0C\nTULNG2   DC    XL2'0006'          LTH OF VOL SER\nTUPAR2   DC    CL6' '             VOL SER\n         SPACE 1\nTUNIT3   DS    0C\nTUKEY3   DC    XL2'0050'          PASSWORD OF DATA SET\nTUNUM3   DC    AL2(1)\nTUENT3   DS    0C\nTULNG3   DC    AL2(8)             LTH OF PASSWORD\nTUPAR3   DC    CL8' '             PASSWORD\n         SPACE 1\nTUNIT4   DS    0C\nTUKEY4   DC    XL2'0004'          STATUS OF DATA SET\nTUNUM4   DC    AL2(1)\nTUENT4   DS    0C\nTULNG4   DC    AL2(1)             LTH OF STATUS\nTUPAR4   DC    X'08'              STATUS = SHR\n*        DC    X'02'              STATUS = MOD\n*        DC    X'04'              STATUS = NEW\n*        DC    X'01'              STATUS = OLD\n         SPACE 1\nTUNIT5   DS    0C\nTUKEY5   DC    XL2'0005'          STATUS 2..DISP=(SHR,KEEP)\nTUNUM5   DC    AL2(1)\nTUENT5   DS    0C\nTULNG5   DC    AL2(1)             LTH OF STATUS 2\nTUPAR5   DC    X'08'              STATUS = KEEP\n*        DC    X'04'              STATUS = DELETE\n*        DC    X'02'              STATUS = CATLG\n*        DC    X'01'              STATUS = UNCATLG\n         SPACE 1\nTUNIT6   DS    0C\nTUKEY6   DC    XL2'0001'          DDNAME\nTUNUM6   DC    AL2(1)\nTUENT6   DS    0C\nTULNG6   DC    AL2(8)             LTH OF DDNAME\nTUPAR6   DC    CL8'MASTER'        DDNAME\n         SPACE 1\n         LTORG\n         SPACE 1\nWORK     DSECT\nSAVE     DC    18F'-1'\nSAVECHG  DC    F'0'\n         DS    A\n         DS    CL6\n         DS    CL60\nLDYNAMIC EQU   *-WORK\n         SPACE 1\n*        IHASDWA\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   DYNALOC\n/*\n//*\n//LKED.SYSLMOD DD DISP=(OLD,PASS),DSN=&&GOSET\n//LKED.SYSIN DD *\n    SETCODE AC(1)\n   ENTRY DYNALOC\n    NAME DYNALOC(R)\n/*\n//*\n//LKED     EXEC PGM=IEWL,REGION=512K,\n//         PARM='XREF,LIST,LET,NCAL'\n//SYSPRINT DD SYSOUT=*\n//SYSUT1 DD UNIT=SYSALLDA,SPACE=(CYL,5)\n//INSOBJ  DD DISP=(OLD,DELETE),DSN=&&GOSET\n//SYSLMOD DD DSN=HALL.LINKLIB,DISP=SHR     <==== CHANGE\n//SYSLIN  DD *\n INCLUDE INSOBJ(CALLIDC)\n INCLUDE INSOBJ(DYNALOC)\n ORDER   CALLIDC\n ORDER   DYNALOC\n ENTRY   CALLIDC\n SETCODE AC(1)\n NAME    CALLIDC(R)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CALLIDCT": {"ttr": 3850, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03?\\x122\\x00\\x10\\x00\\x11\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-02T12:32:00", "lines": 16, "newlines": 17, "modlines": 0, "user": "RH87944"}, "text": "//CALLIDC   JOB\n//*\n/*ROUTE PRINT R7\n//STEP1 EXEC PGM=CALLIDC,REGION=0M\n//STEPLIB  DD DSN=SYS9.LOADLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//IDCPRINT DD SYSOUT=*\n//SYSABEND DD SYSOUT=*\n//AMSDUMP  DD SYSOUT=*\n//SYSOUT   DD SYSOUT=*                   THIS IS FOR HALLDUMP\n//CATIN  DD *\nSMS.TFE107.BACKUP\nCATALOG.IMS.CAT01\nCATALOG.MASTA\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CBTJCL": {"ttr": 3852, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x00\\x9f\\x00\\x99\\x00\\x9f\\x12Y\\x00\\x0c\\x00\\x0c\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-01-09T00:00:00", "modifydate": "1999-01-09T12:59:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "RH87944"}, "text": "//CBT839 JOB 527TSO000S0008,ARNIE,CLASS=8,MSGCLASS=5,NOTIFY=TA15500\n//STEP01 EXEC BANNER,\n// PARM='SYSPRINTCBT839  DISASMBLCBT839  CBT839'\n//STEP02 EXEC ASMBLR,SO=5,P=AEV90,LIB='TS15500.CBT839.PDS'\n//SYSIN DD DISP=SHR,DSN=TS15500.CBT839.PDS(DISASM)\n//STEP03 EXEC TESTLINK,SO=5,LIB='SYS2.MLINKLIB',NAME=CBT839\n//STEP04 EXEC ASMBLR,SO=5,P=AEV90,LIB='TS15500.CBT839.PDS'\n//SYSIN DD DISP=SHR,DSN=TS15500.CBT839.PDS(DISASM1)\n//STEP05 EXEC TESTLINK,SO=5,LIB='SYS2.MLINKLIB',NAME=DISASM1\n//STEP06 EXEC ASMBLR,SO=5,P=AEV90,LIB='TS15500.CBT839.PDS'\n//SYSIN DD DISP=SHR,DSN=TS15500.CBT839.PDS(DISASM2)\n//STEP07 EXEC TESTLINK,SO=5,LIB='SYS2.MLINKLIB',NAME=DISASM2\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CDSCB": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03?\\x125\\x08\\x8c\\x08\\x8d\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-02T12:35:00", "lines": 2188, "newlines": 2189, "modlines": 0, "user": "RH87944"}, "text": "//CDSCB    JOB\n/*ROUTE PRINT R7\n//*\n//ASM     EXEC HLASMCL,\n//             PARMC='ALIGN,NORLD',\n//             CLASS='*',COND.LKED=(7,LT,ASM)\n//*            PARMC='NOALIGN,NORLD,XREF(LONG)',\n//ASM.SYSLIB DD DSN=SYS1.MACLIB\n//    DD DSN=SYS1.AMODGEN,DISP=SHR\n//    DD DISP=SHR,DSN=CBT.SOURCE\n//ASM.SYSIN DD *\n         COPY  MACROS                                               RH\n*\n         TITLE '    C D S C B              '\n***********************************************************************\n*                                                                     *\n*        'CDSCB' TSO COMMAND                                          *\n*                                                                     *\n*        THE COMMAND IS:                                              *\n*                                                                     *\n*        CDSCB DSNAME                  DATASET NAME OF DSCB TO CHANGE *\n*              VOLUME(VOLSER)          VOLSER IF NOT CATALOGUED       *\n*              UNIT(CCCCCCCC)          UNIT IF NOT CATALOGUED         *\n*              ZAP(OFFSET,VERDATA,REPDATA) ZAP IF NO KEYWORD          *\n*              RECFM(F/FB/FBA ETC)     ANY VALID RECFM                *\n*              LRECL(NNNNN)            MAX = 32767                    *\n*              BLKSIZE(NNNNN)          MAX = 32767                    *\n*              DSORG(PS/PO ETC)        ANY VALID DSORG                *\n*              PW                                                     *\n*              PWREAD                                                 *\n*              PWWRITE                                                *\n*              NOPW                                                   *\n*              RACF                    RACF INDICATED                 *\n*              NORACF                  NOT RACF INDICATED             *\n*              ALLOC(NONE/BLOCKS/TRACKS/CYLINDERS) ALLOCATION TYPE    *\n*              SPACE(NNNN)             SECONDARY SPACE AMOUNT (9999)  *\n*              CREATE(YYDDD)           CREATE DATE                    *\n*              EXPDT(YYDDD)            EXPIRY DATE                    *\n*              REFDT(YYDDD)            LAST REFERENCED DATA           *\n*              LOG                     LOG TO CONSOLE IF EXPDT CHANGED*\n*              NOLOG                   DON'T LOG TO CONSOLE           *\n*              CHBIT(ON/OFF)           HSM MODIFIED BIT ON/OFF        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        'CDSCB' TSO COMMAND                                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n*        MODIFIED BY.. RANDY HALL , DIVERSIFIED DEVELOPMENTS.\n*        INSTALLATION. ITSD COMPUTER CENTER, VICTORIA BC\n*        DATE UPDATED. AUG.24 1998.\n*        CHANGES...... ADDED RACF CHECKING VIA RACHECK FOR\n*                      CLASS=DASDVOL,ENTITY=VTOC_VOLSER\n*\n*                      TO USE CDSCB, YOU MUST BE IN A GROUP\n*                      THAT HAS ALTER ACCESS TO DASDVOL/VOLSER.\n*\n*              NOTE .. YOU STILL MUST AUTHORIZE IT BY ADDING THE\n*                      NAME OF THE COMMAND TO THE TABLE IN MODULE\n*                      IKJEFT02 CSECT IKJEFTE2.  OR, WRITE AN SVC\n*                      AND REPLACE THE 'NOPR' INSTRUCTION AT LABELS\n*                      USRSVC & USRSVC2 IN THIS PROGRAM WITH THE SVC.\n*               ...... MODIFIED EXPDT() TO ACCEPT * (TODAYS DATE)\n*               ...... ADDED THIS DOC HERE....\n*\n*    MULTIPLE KEYWORDS CAN BE PROCESSED WITH ONE COMMAND\n*\n*  * ZAP(OFFSET,VER). ALLOCATE DATASET SHARE.....\n*  * VERIFY ONLY...OFFSET MUST BE OVER 2D...NO DSNAME ZAP\n*  CDSCB 'HALL.MYVTOC2' ZAP(40,C1) SHR\n*\n*  * ZAP(OFFSET,VER)\n*  * VERIFY ONLY...OFFSET MUST BE OVER 2D...NO DSNAME ZAP\n*  CDSCB 'HALL.MYVTOC2' ZAP(40,C1)\n*\n*  * ZAP(OFFSET,VER,REP)\n*  * VERIFY, AND REPLACE...OFFSET MUST BE OVER 2D...NO DSNAME ZAP\n*  CDSCB 'HALL.MYVTOC2' ZAP(40,D4,C1)\n*\n*  * CHANGE RECFM...ANY VALID RECFM\n*  CDSCB 'HALL.MYVTOC2' RECFM(FB)\n*\n*  * CHANGE LRECL MAX 5 DIGITS...32767\n*  CDSCB 'HALL.MYVTOC2' LRECL(80)\n*\n*  * CHANGE BLKSIZE MAX 5 DIGITS...32767\n*  CDSCB 'HALL.MYVTOC2' BLKSIZE(80)\n*\n*  * CHANGE DSORG...ANY VALID DSORG\n*  CDSCB 'HALL.MYVTOC2' DSORG(PS)\n*\n*  * CHANGE ALLOCATION TYPE..NONE, BLOCKS, TRACKS, CYLINDERS\n*  CDSCB 'HALL.MYVTOC2' ALLOC(TRACKS)\n*\n*  * CREATE, EXPDT, AND REFDT CAN BE (*) TO SAY TODAY...\n*  CDSCB 'HALL.MYVTOC2' CREATE(98204)\n*  CDSCB 'HALL.MYVTOC2' EXPDT(99365)\n*  CDSCB 'HALL.MYVTOC2' REFDT(99365)\n*  CDSCB 'HALL.MYVTOC2' REFDT(*)\n*\n*  * TURN DS1IND02 BIT ON OR OFF\n*  CDSCB 'HALL.MYVTOC2' CHBIT(ON)\n*\n*  * TURN DS1IND02 BIT ON, AND SET REFDATE TO TODAY\n*  CDSCB 'HALL.MYVTOC2' CHBIT(ON) REFDT(*)\n*\n*  * TURN ON RACF INDICATE BIT\n*  CDSCB 'HALL.MYVTOC2' RACF\n*\n*  * TURN OFF RACF INDICATE BIT\n*  CDSCB 'HALL.MYVTOC2' NORACF\n*  *\n*\n*        DATE UPDATED. JUNE 5 1998.\n*        CHANGES...... ADDED A CHBIT(ON)/(OFF) KEYWORD TO INDICATE\n*                      DATASET WAS MODIFIED. (FOR HSM)\n*                   .. ADDED CHECK FOR PROPER RACF GROUP\n*\n         SPACE 1\n*        WRITTEN BY. BILL GODFREY, PRC (PLANNING RESEARCH CORPORATION).\n*        INSTALLATION. PRC COMPUTER CENTER, MCLEAN VA.\n*        DATE WRITTEN. MAY 20 1975.\n*        DATE UPDATED. FEBRUARY 12 1982.\n*        ATTRIBUTES. RE-ENTRANT, REFRESHABLE, REUSABLE.\n*        COMMENTS.\n*            THIS TSO COMMAND ALTERS THE CONTENTS OF A\n*            FORMAT-1 DSCB IN A VTOC.\n*\n*            THE DATA SET IS ALLOCATED, THEN THE VTOC OF THE\n*            VOLUME CONTAINING IT IS OPENED VIA TYPE-J OPEN.\n*            THE DSCB IS READ USING THE DSNAME AS A KEY. THE\n*            TTR (BLOCK ADDRESS) OF THE RECORD IS RETURNED BY\n*            THE READ.  THE DSCB IS RE-WRITTEN USING THE DSNAME\n*            AS THE KEY, WITH THE KEY SEARCH STARTING AT THE\n*            TTR ADDRESS FROM THE READ.\n*\n*            NOTE. UNDER VS2 MVS, A VTOC MAY BE OPENED FOR\n*            UPDATE ONLY BY AUTHORIZED PROGRAMS. THEREFORE\n*            THIS WILL ABEND WITH A 913-10 UNLESS THE COMMAND\n*            CAN BE MADE TO RUN AUTHORIZED.\n*\n*            AUTHORIZE IT BY ADDING THE NAME OF THE COMMAND\n*            TO THE TABLE IN MODULE IKJEFT02 CSECT IKJEFTE2.\n*            OR, WRITE AN SVC AND REPLACE THE 2 'NOPR'\n*            INSTRUCTIONS IN THIS PROGRAM WITH THE SVC.\n*\n*            04NOV77 - ADDED RECFM, DSORG, CREATE, EXPDT, UNIT\n*            09DEC77 - ADDED IMPLEXEC, EXIT12\n*            29MAR78 - JFCB+52 SET ON TO PREVENT WRITE-BACK\n*            26JUL78 - PREFIXING DONE BY PARSE (USID)\n*            22NOV78 - REMOVE LOCATE IF VOL NOT SPEC\n*            24NOV78 - ADD CLEAR, PUTLINE, PUTMSG, 2ND BASE REG\n*            12OCT79 - ADD GBLB, RESERVE, DEVTYPE FOR LIMCT.\n*            14OCT79 - ADD STACK DELETE.\n*            10APR80 - USID REMOVED FROM IKJPOSIT FOR SVS/MVT.\n*            11APR80 - SHR KEYWORD ADDED.\n*            25JUL80 - TESTAUTH ADDED. ASTERISK IN CREATE DATE.\n*            01APR81 - ERROR MESSAGE FOR BAD DATES. COMMON EXIT PATH\n*                      USING STATUS. MESSAGE IF NOTHING CHANGED.\n*                      MORE RECFMS AND DSORGS. REFDT. FORMAT1 DSECT.\n*                      ALLOW TO RUN IF UNDER STARTED TASK (TSSO).\n*                      WTO MESSAGE WHEN CHANGING EXPDT.\n*            20APR81 - RACF/NORACF KEYWORDS ADDED.\n*            08MAY81 - MORE RECFMS ADDED (UA UM UT).\n*            07JUL81 - CK FOR ASMI USERID INSTEAD OF ASFI.\n*            12FEB82 - CHECK DSORG RECFM LRECL BLKSI CREDT\n*                      FOR CHANGING TO SAME AS EXISTING VALUE.\n*\n*            SPECIFYING 'SYSPARM(OS)' TO THE ASSEMBLER WILL CAUSE\n*            A VERSION FOR OS/MVT TO BE ASSEMBLED.\n*            THE VS ASSEMBLER (OR H ASSEMBLER) MUST BE USED.\n         SPACE 1\n         GBLB  &MVS\n&MVS     SETB  ('&SYSPARM' NE 'OS')\n         EJECT\nCDSCB    CSECT\nCDSCB    AMODE 24\nCDSCB    RMODE 24\n         USING *,R15              GET  ADDRESSABILITY               RH\n         B     @PROLOG-*(,R15)    BRANCH AROUND EYE CATCHER         RH\n         DC    AL1(@PROLOG-*)     LTH OF EYE CATCHER                RH\nEYECATCH DS    0C                                                   RH\n         DC    C'CDSCB'           PROGRAM NAME                      RH\n         DC    C' VERSION 2.0 '   VERSION                           RH\n         DC    CL8'&SYSDATE'      DATE WRITTEN                      RH\n         DC    CL6'&SYSTIME'      TIME WRITTEN                      RH\n         DC    C'..VTOC MODIFIER TSO COMMAND'    COMMENT            RH\n$$$COIBM DC    C' COPYRIGHT RANDY HALL AND BILL GODFREY'            RH\nEYELTH   EQU   *-EYECATCH         LTH OF EYE CATCHER                RH\n@SIZE    DC    0F'0',AL1(1),AL3(@DATAL)  SUBPOOL AND LENGTH         RH\n         SPACE 1                                                    RH\n@PROLOG  DS    0H                                                   RH\n         LA    R1,0(0,R1)         CLEAR HI-ORDER BYTE FOR 31 BIT    RH\n         LA    R13,0(0,R13)       CLEAR HI-ORDER BYTE FOR 31 BIT    RH\n         BSM   R14,0              SAVE CURRENT AMODE                RH\n*                                                                   RH\nSAVEREG  SAVE  (14,12)            SAVE REGISTERS                    RH\n         DROP  R15                DROP TEMP BASE                    RH\n         LR    R10,R15            SET 1ST BASE REG                  RH\n         LA    R11,1(0,R10)       SET 2ND BASE REG                  RH\n         LA    R11,4095(0,R11)    ''                                RH\n         USING CDSCB,R10,R11      TELL ASSEMBLER                    RH\n         LR    R2,R1\n         USING CPPL,R2\n         L     R0,@SIZE\n         GETMAIN R,LV=(0)\n         LR    R9,R1               SET WORKAREA POINTER\n         USING @DATA,R9           SET DSECT BASE\n         SPACE 1\n         LR    R15,R1              POINT TO AREA TO CLEAR\n         L     R1,@SIZE            GET LENGTH TO CLEAR\n         LA    R0,0(,R1)           CLEAR HIGH ORDER BYTE\n         SRDL  R0,8                DIVIDE BY 256\n         SRL   R1,24               ISOLATE REMAINDER\n         LTR   R0,R0               IS QUOTIENT ZERO\n         BZ    CLEARR              YES, GO DO REMAINDER\nCLEARQ   XC    0(256,R15),0(R15)   ZERO 256 BYTES\n         LA    R15,256(,R15)       INCREMENT ADDRESS\n         BCT   R0,CLEARQ           DECREMENT QUOTIENT AND BRANCH\nCLEARR   LTR   R1,R1               IS REMAINDER ZERO?\n         BZ    CLEARX              YES, BRANCH TO EXIT\n         BCTR  R1,0                LENGTH MINUS 1 FOR EX\n         B     *+10                GO AROUND EXECUTED INST\n         XC    0(0,R15),0(R15)     EXECUTED\n         EX    R1,*-6              DO THE ABOVE XC\nCLEARX   EQU   *\n         SPACE 1\n         ST    R13,4(,R9)\n         ST    R9,8(,R13)\n         LR    R13,R9\n         SPACE 1\n         MVC   SIZE,@SIZE\n         EJECT\n         AIF   (NOT &MVS).SKIP1\n         L     R1,548              PSAAOLD\n         L     R15,172(,R1)        ASCBJBNI\n         LTR   R15,R15             IS THIS A JOB\n         BNZ   AUTHID              YES, ASSUME BATCH TSO            RH\n*        BNZ   IMPLEXEC            YES, QUIT\n         L     R15,60(,R1)         ASCBTSB\n         LTR   R15,R15             IS THIS A TSO SESSION\n         BZ    PROCEED             NO, BRANCH IF STARTED TASK\n.SKIP1   ANOP\n*\nAUTHID   DS    0H\n         L     R1,16               CVTPTR\n         L     R15,0(,R1)          TCB WORDS CVTTCBP\n         L     R15,4(,R15)         CURRENT TCB\n         L     R1,180(,R15)        TCBJSCB\n         L     R1,264(,R1)         JSCBPSCB\n         LTR   R1,R1               ANY PSCB?\n         BNZ   PROCEED             YES, BRANCH IF TSO SESSION\n*        BZ    IMPLEXEC            NO - NOT A TSO SESSION\n         USING PSCB,R1\n         SPACE 1\nIMPLEXEC DS    0H                                                   RH\n         L     R1,CPPLCBUF\n         XC    2(2,R1),2(R1)       SET CBUF TO IMPLICIT EXEC\n         L     R1,CPPLECT          GET ECT ADDRESS\n         USING ECT,R1\n         CLI   ECTSCMD,C' '        IS THIS A SUBCOMMAND\n         BNE   *+10                YES - SAY SUBCOMMAND NOT FOUND\n         MVC   ECTPCMD,=CL8'EXEC'  NO  - SAY COMMAND NOT FOUND\n         DROP  R1                  ECT\n         LR    R1,R13\n         L     R0,@SIZE\n         L     R13,4(,R13)\n         FREEMAIN R,A=(1),LV=(0)\n         L     R1,24(,R13)         RESTORE CPPL POINTER\n         LA    R15,12(,R13)        POINT TO 2-WORD XCTL PARM\n         XC    0(8,R15),0(R15)     CLEAR IT\n         XCTL  (2,12),EP=EXEC,SF=(E,(15))\n         EJECT\n************************************************************\n*                                                          *\n*        SET UP IOPL FOR PUTLINE                           *\n*                                                          *\n************************************************************\n         SPACE 1\nPROCEED  LA    R15,MYIOPL\n         USING IOPL,R15\n         MVC   IOPLUPT(4),CPPLUPT\n         MVC   IOPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,IOPLECB\n         XC    MYECB,MYECB\n         LA    R0,MYPTPB\n         ST    R0,IOPLIOPB\n         DROP  R15\n         SPACE 1\n         AIF   (NOT &MVS).SKIP2\n         L     R15,16              LOAD CVT POINTER\n         TM    444(R15),X'80'      IS PUTLINE LOADED? (VS2)\n         BNO   PUTLOAD             NO - BRANCH TO LOAD\n         L     R15,444(,R15)       YES - USE CVTPUTL\n         B     PUTLOADX            BRANCH AROUND LOAD\n.SKIP2   ANOP\n*\nPUTLOAD  LA    R0,=CL8'IKJPUTL '\n         LOAD  EPLOC=(0)\n         LR    R15,R0              GET ENTRY ADDRESS\n         LA    R15,0(,R15)         CLEAR HI BYTE FOR DELETE ROUTINE\nPUTLOADX ST    R15,MYPUTLEP        SAVE PUTLINE ENTRY ADDRESS\n*                                                                   RH\n*                                                                   RH\n*                                                                   RH\n************************************************************\n*                                                          *\n*        SET UP PPL FOR PARSE                              *\n*                                                          *\n************************************************************\n         SPACE 1\nSETPPL   DS    0H                                                   RH\n         LA    R15,MYPPL\n         USING PPL,R15\n         MVC   PPLUPT(4),CPPLUPT\n         MVC   PPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,PPLECB\n         XC    MYECB,MYECB\n*        L     R0,=A(CDSCBPCL)\n         LA    R0,PCLADDR\n         ST    R0,PPLPCL\n         LA    R0,MYANS\n         ST    R0,PPLANS\n         MVC   PPLCBUF(4),CPPLCBUF\n         ST    R9,PPLUWA\n         DROP  R15                 PPL\n         SPACE 1\n************************************************************\n*                                                          *\n*        CALL THE PARSE SERVICE ROUTINE                    *\n*                                                          *\n************************************************************\n         SPACE 1\n         LR    R1,R15              POINT TO PPL\n         AIF   (NOT &MVS).SKIP3\n         L     R15,16              CVTPTR\n         TM    524(R15),X'80'      IF HI ORDER BIT NOT ON\n         BNO   PARSELNK               THEN DO LINK, NOT CALL\n         L     R15,524(,R15)       CVTPARS\n         BALR  R14,R15             CALL IKJPARS\n         B     PARSEEXT            SKIP AROUND LINK\nPARSELNK EQU   *\n.SKIP3   ANOP\n         LINK  EP=IKJPARS,SF=(E,LINKAREA)\nPARSEEXT EQU   *\n         SPACE 1\n         LTR   R15,R15\n         BNZ   PARSERR\n         EJECT\n         L     R12,MYANS\n         USING IKJPARMD,R12\n         SPACE 1\n************************************************************\n*                                                          *\n*        PROCESS THE 'ZAP' PARAMETER'                      *\n*                                                          *\n************************************************************\n         SPACE 1\n         CLI   ZAPKW+1,0           ZAP SPECIFIED?\n         BE    NOREP               NO - BRANCH\n         TM    REP+6,X'80'         ZAP SPECIFIED?\n         BZ    NOREP\n         CLI   REP+8,X'FF'         ONLY ONE REP PARAMETER?\n         BE    INVREP              YES - ERROR - BRANCH\n         MVC   OFFSET(5),=XL5'00'\n         LA    R1,OFFSET\n         CLI   REP+5,4\n         BE    MOVEOFF\n         CLI   REP+5,2\n         BNE   INVREP              OFFSET MUST BE 2 OR 4 CHARS\n         LA    R1,OFFSET+1\nMOVEOFF  L     R14,REP             REG 14 --> OFFSET\n         LH    R15,REP+4           REG 15  =  LENGTH (2 OR 4)\n         BCTR  R15,0\n         B     *+10\n         MVC   0(0,R1),0(R14)      MOVE 1ST REP TO OFFSET\n         EX    R15,*-6\n         SPACE 1\n         LH    R0,REP+4\n         SRL   R0,1                CUT LENGTH IN HALF\n         BAL   R14,PACK            CONVERT TO BINARY\n         CLI   OFFSET+1,44+1       OFFSETS START WITH X'2D'\n         BL    REPOERR             IF LESS ISSUE MESSAGE\n         SPACE 1\n         L     R6,REP+8            REG 6 --> NEXT PDE IN LIST (VER DATA\n         L     R14,0(,R6)          REG 14 --> VERDATA\n         LH    R15,4(,R6)          REG 15  =  LENGTH\n         BCTR  R15,0\n         B     *+10\n         MVC   VERDATA+1(0),0(R14) MOVE 2ND REP TO VERDATA\n         EX    R15,*-6\n         LH    R0,4(,R6)\n         SRL   R0,1                CUT LENGTH IN HALF\n         BCTR  R0,0\n         STC   R0,VERDATA\n         LH    R0,4(,R6)\n         SRL   R0,1                CUT LENGTH IN HALF\n         LA    R1,VERDATA+1\n         BAL   R14,PACK\n         SR    R14,R14\n         IC    R14,VERDATA         R14 = LEN-1 OF VERDATA\n         AH    R14,OFFSET\n         CH    R14,ENDOFREC        BEYOND END OF RECORD?\n         BH    REPVERR             YES - ISSUE MESSAGE\n         SPACE 1\n         CLI   8(R6),X'FF'         3RD REP (REPDATA) SPECIFIED?\n         MVI   VR,C'V'\n         BE    REPX\n         L     R6,8(,R6)           REG 6 --> NEXT PDE (REP DATA)\n         MVI   VR,C'R'\n         L     R14,0(,R6)          REG 14 --> REPDATA\n         LH    R15,4(,R6)          R15  =  LENGTH\n         BCTR  R15,0\n         B     *+10\n         MVC   REPDATA+1(0),0(R14) MOVE 3RD REP TO REPDATA\n         EX    R15,*-6\n         LH    R0,4(,R6)\n         SRL   R0,1                CUT LENGTH IN HALF\n         BCTR  R0,0\n         STC   R0,REPDATA\n         LH    R0,4(,R6)\n         SRL   R0,1                CUT LENGTH IN HALF\n         LA    R1,REPDATA+1\n         BAL   R14,PACK\n         CLC   VERDATA(1),REPDATA  COMPARE LENGTHS\n         BL    REPDERR             VER DATA MUST NOT BE SHORTER\nREPX     EQU   *\nNOREP    EQU   *\n         SPACE 1\n************************************************************\n*                                                          *\n*        PROCESS THE 'RECFM' KEYWORD                       *\n*                                                          *\n************************************************************\n         SPACE 1\n         LH    R1,RECFM            GET RECFM\n         LTR   R1,R1               RECFM SPECIFIED?\n         BZ    NOREC               NO - BRANCH\n         IC    R14,RECFMTAB(R1)    GET RECFM BITS\n         STC   R14,NEWRECFM        SAVE NEW RECFM\n         MVI   NEWRECSW,C'R'       SET SWITCH ON\nNOREC    EQU   *\n         SPACE 1\n************************************************************\n*                                                          *\n*        PROCESS THE 'BLKSIZE' KEYWORD                     *\n*                                                          *\n************************************************************\n         SPACE 1\n         CLI   BLKKW+1,0           BLKSIZE SPECIFIED?\n         BE    NOBLK               NO - BRANCH\n         TM    BLK+6,X'80'         VALUE PRESENT?\n         BZ    NOBLK               NO - BRANCH\n         LH    R14,BLK+4           GET LENGTH\n         LTR   R14,R14             LENGTH ZERO?\n         BZ    NOBLK               YES - BRANCH\n         L     R1,BLK              POINT TO VALUE\n         BCTR  R14,0\n         B     *+10\n         PACK  DOUBLE(8),0(0,R1)\n         EX    R14,*-6\n         CVB   R1,DOUBLE           GET BINARY VALUE\n         C     R1,=F'32767'        TOO LARGE?\n         BNH   *+8                 NO - BRANCH\n         L     R1,=F'32767'        YES - REDUCE IT\n         STH   R1,NEWBLK           SAVE IT\n         MVI   NEWBLKSW,C'B'       SET SWITCH ON\nNOBLK    EQU   *\n         SPACE 1\n************************************************************\n*                                                          *\n*        PROCESS THE 'LRECL' KEYWORD                       *\n*                                                          *\n************************************************************\n         SPACE 1\n         CLI   LREKW+1,0           LRECL SPECIFIED?\n         BE    NOLRE               NO - BRANCH\n         TM    LRE+6,X'80'         VALUE PRESENT?\n         BZ    NOLRE               NO - BRANCH\n         LH    R14,LRE+4           GET LENGTH\n         LTR   R14,R14             LENGTH ZERO?\n         BZ    NOLRE               YES - BRANCH\n         L     R1,LRE              POINT TO VALUE\n         BCTR  R14,0\n         B     *+10\n         PACK  DOUBLE(8),0(0,R1)\n         EX    R14,*-6\n         CVB   R1,DOUBLE           GET BINARY VALUE\n         C     R1,=F'32767'        TOO LARGE?\n         BNH   *+8                 NO - BRANCH\n         L     R1,=F'32767'        YES - REDUCE IT\n         STH   R1,NEWLRE           SAVE IT\n         MVI   NEWLRESW,C'L'       SET SWITCH ON\nNOLRE    EQU   *\n         SPACE 1\n************************************************************\n*                                                          *\n*        PROCESS THE 'DSORG' KEYWORD                       *\n*                                                          *\n************************************************************\n         SPACE 1\n         LH    R1,DSORG            GET DSORG\n         LTR   R1,R1               DSORG SPECIFIED?\n         BZ    NODSO               NO - BRANCH\n         IC    R14,DSORGTAB(R1)    GET DSORG BITS\n         STC   R14,NEWDSORG        SAVE NEW DSORG\n         MVI   NEWDSORG+1,0        NEW DSORG PART 2\n         MVI   NEWDSOSW,C'R'       SET SWITCH ON\nNODSO    EQU   *\n         SPACE 1\n************************************************************\n*                                                          *\n*        PROCESS THE PROTECTION KEYWORDS                   *\n*                                                          *\n************************************************************\n         SPACE 1\n         CLI   PROKW+1,0           ANY PROTECTION KEYWORDS?\n         BE    NOPRO               NO - BRANCH\n         MVI   NEWPRO0,X'FF'       START WITH NO BITS TO SET OFF\n         MVI   NEWPRO1,X'00'              AND NO BITS TO SET ON.\n         CLI   PROKW+1,2           'PW' OR 'PWREAD'?\n         BH    PRO3                NO - BRANCH\n         MVI   NEWPRO0,B'11111011' SET OFF 1 BIT\n         MVI   NEWPRO1,B'00010000' SET ON 1 BIT\n         B     PROX\nPRO3     CLI   PROKW+1,3           'PWWRITE'?\n         BNE   PRO4                NO - BRANCH\n         MVI   NEWPRO1,B'00010100' SET ON 2 BITS\n         B     PROX\nPRO4     CLI   PROKW+1,4           'NOPW'?\n         BNE   PRO5                NO - BRANCH\n         MVI   NEWPRO0,B'11101011' SET OFF 2 BITS\n         B     PROX\nPRO5     CLI   PROKW+1,5           'RACF'\n         BNE   PRO6\n         MVI   NEWPRO1,X'40'       SET ON 1 BIT\n         B     PROX\nPRO6     CLI   PROKW+1,6           'NORACF'\n         BNE   NOPRO\n         MVI   NEWPRO0,255-X'40'   SET OFF 1 BIT\nPROX     MVI   NEWPROSW,C'P'       SET SWITCH ON\nNOPRO    EQU   *\n         SPACE 1                                                    RH\n************************************************************        RH\n*                                                          *        RH\n*        PROCESS THE CHBIT   KEYWORDS                      *        RH\n*                                                          *        RH\n************************************************************        RH\n         SPACE 1                                                    RH\n         CLI   BACKBIT+1,0         ANY CHBIT KEYWORDS?              RH\n         BE    NOCHB               NO - BRANCH                      RH\n         MVI   NEWCHB0,X'FF'       START WITH NO BITS TO SET OFF    RH\n         MVI   NEWCHB1,X'00'              AND NO BITS TO SET ON.    RH\n         CLI   BACKBIT+1,1         'ON' ?                           RH\n         BH    CHB3                NO - BRANCH                      RH\n         MVI   NEWCHB0,B'11111101' SET OFF 1 BIT                    RH\n         MVI   NEWCHB1,B'00000010' SET ON 1 BIT                     RH\n         B     CHBX                                                 RH\nCHB3     CLI   BACKBIT+1,2         'OFF'?                           RH\n         BNE   NOCHB               NO - BRANCH                      RH\n         MVI   NEWCHB0,255-X'02'   SET OFF 1 BIT                    RH\nCHBX     MVI   NEWCHBSW,C'P'       SET SWITCH ON                    RH\nNOCHB    EQU   *                                                    RH\n         SPACE 1\n************************************************************\n*                                                          *\n*        PROCESS THE 'ALLOC' KEYWORD                       *\n*                                                          *\n************************************************************\n         SPACE 1\n         CLI   ALLKW+1,0           'ALLOC' SPECIFIED?\n         BE    NOALL               NO - BRANCH\n         CLI   ALL+1,0             ANY SUBKEYWORDS?\n         BE    NOALL               NO - BRANCH\n         MVI   NEWALL0,X'FF'       START WITH NO BITS TO SETOFF\n         MVI   NEWALL1,X'00'              AND NO BITS TO SETON\n         CLI   ALL+1,1             'NONE'?\n         BNE   ALL2                NO - BRANCH\n         MVI   NEWALL0,B'00111111' SET OFF 2 BITS\n         B     ALLX\nALL2     CLI   ALL+1,2             'BLOCKS'\n         BNE   ALL3                NO - BRANCH\n         MVI   NEWALL0,B'01111111' SET OFF 1 BIT\n         MVI   NEWALL1,B'01000000' SET ON 1 BIT\n         B     ALLX\nALL3     CLI   ALL+1,3             'TRACKS'\n         BNE   ALL4                NO - BRANCH\n         MVI   NEWALL0,B'10111111' SET OFF 1 BIT\n         MVI   NEWALL1,B'10000000' SET ON 1 BIT\n         B     ALLX\nALL4     CLI   ALL+1,4             'CYLINDERS'\n         BNE   NOALL               NO - BRANCH\n         MVI   NEWALL1,B'11000000' SET ON 2 BITS\nALLX     MVI   NEWALLSW,C'A'       SET ON SWITCH\nNOALL    EQU   *\n         SPACE 1\n************************************************************\n*                                                          *\n*        PROCESS THE 'SPACE' PARAMETER                     *\n*                                                          *\n************************************************************\n         SPACE 1\n         CLI   SPAKW+1,0           SPACE SPECIFIED?\n         BE    NOSPA               NO - BRANCH\n         TM    SPA+6,X'80'         VALUE PRESENT?\n         BZ    NOSPA               NO - BRANCH\n         LH    R14,SPA+4           GET LENGTH\n         LTR   R14,R14             LENGTH ZERO?\n         BZ    NOSPA               YES - BRANCH\n         L     R1,SPA              POINT TO VALUE\n         BCTR  R14,0\n         B     *+10\n         PACK  DOUBLE(8),0(0,R1)\n         EX    R14,*-6\n         CVB   R1,DOUBLE           GET BINARY VALUE\n         C     R1,=F'32767'        TOO LARGE?\n         BNH   *+8                 NO - BRANCH\n         L     R1,=F'32767'        YES - REDUCE IT\n         ST    R1,NEWSPA           SAVE IT\n         MVI   NEWSPASW,C'S'       SET SWITCH ON\nNOSPA    EQU   *\n         EJECT\n************************************************************\n*                                                          *\n*        PROCESS THE 'CREATE' KEYWORD                      *\n*                                                          *\n************************************************************\n         SPACE 1\n         CLI   CREATEKW+1,0        CREATE SPECIFIED?\n         BE    CREATEX             NO - BRANCH\n         TM    CREATE+6,X'80'      VALUE PRESENT?\n         BZ    CREATEX             NO - BRANCH\n         LH    R14,CREATE+4        GET LENGTH\n         LTR   R14,R14             LENGTH ZERO?\n         BZ    CREATEX             YES - BRANCH\n         L     R1,CREATE           POINT TO VALUE\n         CLI   0(R1),C'*'          ASTERISK\n         BE    CTODAY              YES, BRANCH\n         BCTR  R14,0\n         B     *+10\n         PACK  DOUBLE(8),0(0,R1)\n         EX    R14,*-6\n         CVB   R15,DOUBLE          GET BINARY VALUE\n         LTR   R15,R15             IS IT ZERO?\n         BZ    CREOK               YES - BRANCH\n         CH    R14,=H'4'           WERE 5 DIGITS SPECIFIED?\n         BNE   ERRCDATE            NO - BRANCH TO ERROR (IGNORE)\nCREPACK  PACK  DOUBLE(8),0(2,R1)   PACK YY\n         CVB   R14,DOUBLE          GET BINARY YY\n         SLL   R14,16              00YY0000\n         PACK  DOUBLE(8),2(3,R1)   PACK DDD\n         CVB   R15,DOUBLE          GET BINARY DDD\n         OR    R15,R14             00YY0DDD\nCREOK    ST    R15,NEWCRE          SAVE NEW CREATION DATE\n         MVI   NEWCRESW,C'C'       SET SWITCH ON\n         B     CREATEX\nCTODAY   EQU   *\n         TIME  BIN\n         ST    R1,DOUBLE           STORE 00YYDDDC\n         LA    R1,DATE5            POINT TO FAKE OPERAND\n         UNPK  0(5,R1),DOUBLE+1(3) YYDDD\n         OI    4(R1),C'0'          FIX SIGN BITS\n         B     CREPACK             JUMP BACK IN WITH FAKE OPERAND\nCREATEX  EQU   *\n         EJECT\n************************************************************\n*                                                          *\n*        PROCESS THE 'EXPDT' KEYWORD                       *\n*                                                          *\n************************************************************\n         SPACE 1\n         CLI   EXPDTEKW+1,0        EXPDTE SPECIFIED?\n         BE    NOEXP               NO - BRANCH\n         TM    EXPDTE+6,X'80'      VALUE PRESENT?\n         BZ    NOEXP               NO - BRANCH\n         LH    R14,EXPDTE+4        GET LENGTH\n         LTR   R14,R14             LENGTH ZERO?\n         BZ    NOEXP               YES - BRANCH\n         MVC   EXPCH,=C'00000'\n         L     R1,EXPDTE           POINT TO VALUE\n         CLI   0(R1),C'*'          ASTERISK                         RH\n         BE    ETODAY              YES, BRANCH                      RH\n         BCTR  R14,0\n         B     *+10\n         PACK  DOUBLE(8),0(0,R1)\n         EX    R14,*-6\n         CVB   R15,DOUBLE          GET BINARY VALUE\n         LTR   R15,R15             IS IT ZERO?\n         BZ    EXPOK               YES - BRANCH\n         CH    R14,=H'4'           WERE 5 DIGITS SPECIFIED?\n         BNE   ERRXDATE            NO - BRANCH TO ERROR (IGNORE)\n         MVC   EXPCH,0(R1)         SAVE EXPDT\n*                                                                   RH\nEXPPACK  DS    0H                                                   RH\n         PACK  DOUBLE(8),0(2,R1)   PACK YY\n         CVB   R14,DOUBLE          GET BINARY YY\n         SLL   R14,16              00YY0000\n         PACK  DOUBLE(8),2(3,R1)   PACK DDD\n         CVB   R15,DOUBLE          GET BINARY DDD\n         OR    R15,R14             00YY0DDD\nEXPOK    ST    R15,NEWEXP          SAVE NEW EXPIRATION DATE\n         MVI   NEWEXPSW,C'C'       SET SWITCH ON\nNOEXP    EQU   *\n         SPACE 1\nENDEXP   DS    0H\n         B     EXPEXIT                                              RH\n*                                                                   RH\nETODAY   EQU   *                                                    RH\n         TIME  BIN                                                  RH\n         ST    R1,DOUBLE           STORE 00YYDDDC                   RH\n         LA    R1,DATE5            POINT TO FAKE OPERAND            RH\n         UNPK  0(5,R1),DOUBLE+1(3) YYDDD                            RH\n         OI    4(R1),C'0'          FIX SIGN BITS                    RH\n         B     EXPPACK             JUMP BACK IN WITH FAKE OPERAND   RH\n         SPACE 1                                                    RH\nEXPEXIT  DS    0H                                                   RH\n         SPACE 3                                                    RH\n************************************************************\n*                                                          *\n*        PROCESS THE 'REFDT' KEYWORD                       *\n*                                                          *\n************************************************************\n         SPACE 1\n         CLI   REFDTEKW+1,0        REFDT SPECIFIED?\n         BE    REFDTEX             NO - BRANCH\n         TM    REFDTE+6,X'80'      VALUE PRESENT?\n         BZ    REFDTEX             NO - BRANCH\n         LH    R14,REFDTE+4        GET LENGTH\n         LTR   R14,R14             LENGTH ZERO?\n         BZ    REFDTEX             YES - BRANCH\n         L     R1,REFDTE           POINT TO VALUE\n         CLI   0(R1),C'*'          ASTERISK\n         BE    RTODAY              YES, BRANCH\n         BCTR  R14,0\n         B     *+10\n         PACK  DOUBLE(8),0(0,R1)\n         EX    R14,*-6\n         CVB   R15,DOUBLE          GET BINARY VALUE\n         LTR   R15,R15             IS IT ZERO?\n         BZ    REFOK               YES - BRANCH\n         CH    R14,=H'4'           WERE 5 DIGITS SPECIFIED?\n         BNE   ERRRDATE            NO - BRANCH TO ERROR (IGNORE)\nREFPACK  PACK  DOUBLE(8),0(2,R1)   PACK YY\n         CVB   R14,DOUBLE          GET BINARY YY\n         SLL   R14,16              00YY0000\n         PACK  DOUBLE(8),2(3,R1)   PACK DDD\n         CVB   R15,DOUBLE          GET BINARY DDD\n         OR    R15,R14             00YY0DDD\nREFOK    ST    R15,NEWREF          SAVE NEW REFERENCED DATE\n         MVI   NEWREFSW,C'C'       SET SWITCH ON\n         B     REFDTEX\nRTODAY   EQU   *\n         TIME  BIN\n         ST    R1,DOUBLE           STORE 00YYDDDC\n         LA    R1,DATE5            POINT TO FAKE OPERAND\n         UNPK  0(5,R1),DOUBLE+1(3) YYDDD\n         OI    4(R1),C'0'          FIX SIGN BITS\n         B     REFPACK             JUMP BACK IN WITH FAKE OPERAND\nREFDTEX  EQU   *\n         EJECT\n************************************************************\n*                                                          *\n*        PROCESS THE DSNAME PARAMETER                      *\n*                                                          *\n************************************************************\n         SPACE 1\n         LA    R1,DSN\n         L     R8,0(,R1)           R8  -> DSNAME\n         LH    R7,4(,R1)           R7  =  LENGTH\n         LTR   R7,R7               IS LENGTH ZERO?\n         BZ    ERRDSN              YES, WAS (MEMBER) ONLY\n         LR    R6,R7\n         MVI   DSNAME,C' '\n         MVC   DSNAME+1(43),DSNAME\n         SLR   R14,R14\n         AIF   (&MVS).SKIP4        PREFIX DSNAME WITH USERID\n         TM    6(R1),X'40'         IS DSN QUOTED?\n         BO    DSNQUOTE\n         SPACE 1\n*\n*              GET THE USERID AND PREFIX THE DSNAME\n*\n         SPACE 1\n         L     R15,CPPLPSCB\n         USING PSCB,R15\n         IC    R14,PSCBUSRL        LENGTH OF PREFIX\n         LTR   R14,R14             NOPREFIX\n         BZ    DSNQUOTE            SAME AS QUOTED\n         LA    R6,1(R14,R6)        R6 = TOTAL LEN\n         MVC   DSNAME(7),PSCBUSER\n         DROP  R15                 UPT\n         LA    R14,DSNAME(R14)\n         MVI   0(R14),C'.'         ADD PERIOD\n         LA    R14,1(,R14)         PERIOD LENGTH\n         B     *+8\n.SKIP4   ANOP\nDSNQUOTE LA    R14,DSNAME(R14)\n         BCTR  R7,0\n         B     *+10\n         MVC   0(0,R14),0(R8)\n         EX    R7,*-6\n         STH   R6,DSNAMEL\n         EJECT\n************************************************************\n*                                                          *\n*        PROCESS THE VOLUME PARAMETER                      *\n*                                                          *\n************************************************************\n         SPACE 1\n         MVC   WRKUNIT,=CL8' '\n         MVC   WRKVOL(6),=CL8' '\n         TM    VOL+6,X'80'         VOLUME SPECIFIED?\n         BZ    NOVOL               NO - BRANCH\n         L     R14,VOL             R14 --> VOLUME\n         LH    R15,VOL+4           R15  =  LENGTH\n         BCTR  R15,0\n         B     *+10\n         MVC   WRKVOL(0),0(R14)\n         EX    R15,*-6\n         SPACE 1\n************************************************************\n*                                                          *\n*        IF VOLUME SPECIFIED, CHECK FOR UNIT PARAMETER     *\n*                                                          *\n************************************************************\n         SPACE 1\n         TM    UNIT+6,X'80'        UNIT SPECIFIED?\n         BZ    NOUNIT              NO - BRANCH\n         L     R14,UNIT            POINT TO UNIT NAME\n         LH    R15,UNIT+4          LENGTH OF UNIT NAME\n         BCTR  R15,0\n         B     *+10\n         MVC   WRKUNIT(0),0(R14)\n         EX    R15,*-6\nNOUNIT   EQU   *\nNOVOL    EQU   *\n         EJECT\n************************************************************\n*                                                          *\n*        CALL DYNAMIC ALLOCATION                           *\n*                                                          *\n************************************************************\n         SPACE 1\nDYNALLOC EQU   *\n         LA    R1,MYDAPL\n         USING DAPL,R1\n         MVC   DAPLUPT(4),CPPLUPT\n         MVC   DAPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,DAPLECB\n         MVC   DAPLPSCB(4),CPPLPSCB\n         LA    R0,MYDAPB\n         ST    R0,DAPLDAPB\n         SPACE 1\n         XC    MYECB,MYECB\n         L     R15,DAPLDAPB\n         USING DAPB08,R15\n         XC    0(84,R15),0(R15)\n         MVI   DA08CD+1,X'08'\n         LA    R14,DA08DDN\n         MVI   0(R14),X'40'\n         MVC   1(23,R14),0(R14)  DD,UNIT,VOL\n         MVC   DA08SER(6),WRKVOL\n         MVC   DA08UNIT(8),WRKUNIT\n         MVC   DA08MNM(16),0(14)\n         MVC   DA08ALN(8),0(R14)\n         LA    R0,DSNAMEL\n         ST    R0,DA08PDSN\n         MVI   DA08DSP1,DA08OLD\n         CLI   SHRKW+1,0           'SHR' SPECIFIED ?\n         BE    *+8                 BRANCH IF NOT\n         MVI   DA08DSP1,DA08SHR    'SHR' SPECIFIED\n         MVI   DA08DPS2,DA08KEEP\n         MVI   DA08DPS3,DA08KEP\n         BAL   R14,CALLDAIR\n         SPACE 1\n         LTR   R15,R15\n         BNZ   DAIRERR\n         OI    STATUS,STATA        INDICATE ALLOCATED\n         EJECT\n************************************************************\n*                                                          *\n*        SET UP THE DCB                                    *\n*                                                          *\n************************************************************\n         SPACE 1\n         MVC   DCB(DCBLEN),DCBMODEL\n         LA    R15,MYDAPB\n         LA    R3,DCB\n         USING IHADCB,R3\n         MVC   DCBDDNAM(8),DA08DDN\n         LA    R15,JFCB\n         ST    R15,EXLSTD\n         MVI   EXLSTD,X'87'\n         LA    R15,EXLSTD\n         IC    R14,DCBEXLST\n         ST    R15,DCBEXLST        SET DCB EXLST=EXLSTD\n         STC   R14,DCBEXLST\n         SPACE 1\n************************************************************\n*                                                          *\n*        READ THE JFCB                                     *\n*                                                          *\n************************************************************\n         SPACE 1\n         MVC   RDJFCBD,RDJFCB\n         RDJFCB ((R3)),MF=(E,RDJFCBD)\n         SPACE 1\n************************************************************\n*                                                          *\n*        DEFER ATTENTION INTERRUPTS                        *\n*                                                          *\n************************************************************\n         SPACE 1\n         MVC   STAXD(20),STAXDEF\n         STAX  DEFER=YES,MF=(E,STAXD)\n         SPACE 1\n************************************************************\n*                                                          *\n*        INSTALLATION-DEPENDENT CODE                       *\n*        TO GET AROUND ABEND 913-10                        *\n*                                                          *\n************************************************************\n         SPACE 1\n         L     1,16\n         L     1,0(,1)\n         L     1,4(,1)             R1 --> TCB\n         L     4,180(,1)           R4 --> JSCB\n         TM    236(4),X'01'        ARE WE AUTHORIZED\n         BO    KEY0X               YES, BYPASS AUTHSET\n         LA    0,0                 R0 = FUNCTION CODE FOR USER SVC\n         LA    15,KEY0A            R15 POINTS TO ROUTINE TO BE CALLED\nUSRSVC   NOPR  0                   *** REPLACE WITH USER SVC ***\n         B     KEY0B               BRANCH AROUND ROUTINE\nKEY0A    OI    236(4),X'01'        SET ON JSCBAUTH\n         BR    14                  RETURN TO SVC\nKEY0B    OI    STATUS,STATM        INDICATE AUTH HAS BEEN CHANGED\nKEY0X    EQU   *\n         SPACE 1\n         AIF   (NOT &MVS).SKIP5    TESTAUTH\n         TESTAUTH FCTN=1\n         LTR   R15,R15            WAS AUTH OKAY?\n         BNZ   NOTAUTH3           NO. DOESN'T MATTER IF RACF OKAY   RH\n*                                                                   RH\n*        GO SEE IF WE HAVE ACCESS TO VTOC RESOURCE CLASS            RH\n*                                                                   RH\n         L     R5,=V(USRDSN)      R5 -> TO CLASS AREA               RH\n         LA    R15,JFCB                                             RH\n         USING JFCBD,R15          SET JFCB BASE                     RH\n         MVC   0(6,R5),JFCBVOLS   VOLSER IS THE CLASS               RH\n         DROP  R15                DROP JFCB BASE                    RH\n         PERFORM RACHEC    ,ERR=BADAUTH                             RH\n         LTR   R15,R15            WAS AUTH OKAY?                    RH\n         BZ    DODEV              YES, AUTH OKAY....                RH\n*                                                                   RH\nNOTAUTH3 DS    0H                                                   RH\n         OI    STATUS,STATNA      SAY NOT AUTH'D                    RH\n         LA    R1,AUTHMSG                                           RH\n         LA    R0,L'AUTHMSG                                         RH\n         BAL   R14,PUTMSG                                           RH\n         B     DODEV              AUTH OKAY....                     RH\n*                                                                   RH\nAUTHMSG  DC    C'YOU ARE NOT AUTHORIZED TO CHANGE A VTOC'           RH\n*                                                                   RH\n.SKIP5   ANOP\n         SPACE 1\n************************************************************\n*                                                          *\n*        OPEN THE VTOC                                     *\n*                                                          *\n************************************************************\n         SPACE 1\nDODEV    DEVTYPE DCBDDNAM,DEVAREA,DEVTAB\n         SPACE 1\n         LH    R1,DEVAREA+10       TRACKS PER CYL\n         MH    R1,=H'5'            ASSUME 5 CYLINDER VTOC\n         STH   R1,TRACKS\n         SPACE 1\n         GETPOOL (R3),2,96\n         SPACE 1\n         OI    STATUS,STATG        INDICATE GETPOOL ISSUED\n         MVI   JFCB,X'04'\n         MVC   JFCB+1(43),JFCB\n         OI    JFCB+52,X'08'       DO NOT WRITE BACK      29MAR78\n         MVC   OPENJD,OPENJ\n         TM    STATUS,STATNA      ARE WE AUTH'D                     RH\n         BNO   OPENU              YES                               RH\n*        CLC   =X'9604',OPENA+8   GOT UPDAT BIT?                    RH\n*        BNE   AUTHERR            NO, TOO BAD                       RH\n*        MVI   OPENA+9,X'00'      YES, CHANGE UPDAT TO INPUT        RH\n         OPEN  ((R3),INPUT),TYPE=J,MF=(E,OPENJD)                    RH\n         B     CHKOPEN            SEE IF VTOC OPENED...             RH\n*                                                                   RH\nOPENU    OPEN  ((R3),UPDAT),TYPE=J,MF=(E,OPENJD)                    RH\n*                                                                   RH\nCHKOPEN  DS    0H                                                   RH\n         TM    DCBOFLGS,X'10'\n         BZ    OPENERR\n         OI    STATUS,STATO        INDICATE OPENED\n         EJECT\n************************************************************\n*                                                          *\n*        ENQ ON THE VTOC                                   *\n*                                                          *\n************************************************************\n         SPACE 1\n         TM    STATUS,STATNA      ARE WE AUTH'D                     RH\n         BO    NOENQ              NO, DON'T DO ENQ                  RH\n         L     R1,DCBDEBAD         POINT TO DEB\n         L     R1,32(,R1)          POINT TO UCB\n         ST    R1,UCBAD            STORE UCB ADDRESS\n         MVC   RNAME,28(R1)        MOVE VOLUME TO RNAME\n         MVC   QNAME,=CL8'SYSVTOC'\n         MVC   RW(RL),R            MOVE MF=L TO WORK AREA\n         SPACE 1\n         RESERVE (QNAME,RNAME,E,6,SYSTEMS),RET=HAVE,UCB=UCBAD,MF=(E,RW)\n         SPACE 1\n         OI    STATUS,STATQ        INDICATE ENQ ACTIVE\n         SPACE 1\n************************************************************\n*                                                          *\n*        READ THE FORMAT 1 DSCB USING DSNAME AS KEY        *\n*                                                          *\n************************************************************\n         SPACE 1\nNOENQ    GETBUF (R3),(R4)\n         SPACE 1\n         LH    R1,TRACKS\n         STH   R1,DCBLIMCT+1\n         MVC   READDECB(READL),DECBMODR\n         MVC   TTR(3),=X'000001'\n         SPACE 1\n         READ  READDECB,DKF,(R3),(R4),'S',DSNAME,TTR,MF=E\n         SPACE 1\n         MVI   SYNADSWT,0\n         SPACE 1\n         CHECK READDECB\n         SPACE 1\n         CLI   SYNADSWT,0          SYNAD EXIT TAKEN?\n         BNE   READERR             YES - BRANCH\n         L     R4,READDECB+12      R4 --> AREA ADDRESS\n         LR    R5,R4\n         SH    R5,=H'44'           R5 --> IMAGINARY KEY-DATA AREA\n         USING FORMAT1,R5\n         SPACE 1\n************************************************************\n*                                                          *\n*        VERIFY                                            *\n*                                                          *\n************************************************************\n         SPACE 1\n         CLI   VR,0                REP SPECIFIED?\n         BE    VRX                 NO - BRANCH\n         LR    R1,R5\n         AH    R1,OFFSET           R1 --> LOCATION OF VICTIM\n         SR    R14,R14\n         IC    R14,VERDATA\n         B     *+10\n         CLC   0(0,R1),VERDATA+1\n         EX    R14,*-6             COMPARE VICTIM TO VER DATA\n         BNE   VERREJ              NOT EQUAL - REJECT\n         SPACE 1\n         CLI   VR,C'R'             WAS REP DATA SPECIFIED?\n         BE    REPROUT             YES - BRANCH\n         LA    R1,=C'VERIFIED'\n         LA    R0,8\n         BAL   R14,PUTMSG\n         SPACE 1\n         B     VRX\n         SPACE 1\n************************************************************\n*                                                          *\n*        REPLACE                                           *\n*                                                          *\n************************************************************\n         SPACE 1\nREPROUT  IC    R14,REPDATA\n         B     *+10\n         MVC   0(0,R1),REPDATA+1\n         EX    R14,*-6              MOVE REP DATA TO RECORD\n         MVI   CHANGED,C'C'         SET CHANGED SWITCH\nVRX      EQU   *\n         SPACE 1\n         CLI   NEWRECSW,0          RECFM SPECIFIED?\n         BE    NURECX              NO - BRANCH\n         CLC   DS1RECFM,NEWRECFM   ALREADY THAT\n         BE    NURECX              YES - BRANCH\n         MVC   DS1RECFM,NEWRECFM   MOVE IN NEW RECFM\n         MVI   CHANGED,C'C'        SET SWITCH ON\nNURECX   EQU   *\n         SPACE 1\n         CLI   NEWDSOSW,0          DSORG SPECIFIED?\n         BE    NUDSOX              NO - BRANCH\n         CLC   DS1DSORG,NEWDSORG   ALREADY THAT\n         BE    NUDSOX              YES, BRANCH\n         MVC   DS1DSORG,NEWDSORG   MOVE IN NEW DSORG\n         MVI   CHANGED,C'C'        SET SWITCH ON\nNUDSOX   EQU   *\n         SPACE 1\n         CLI   NEWBLKSW,0          BLKSIZE SPECIFIED?\n         BE    NUBLKX              NO - BRANCH\n         CLC   DS1BLKL,NEWBLK      ALREADY THAT\n         BE    NUBLKX              YES - BRANCH\n         MVC   DS1BLKL,NEWBLK      MOVE IN NEW BLKSIZE\n         MVI   CHANGED,C'C'        SET SWITCH ON\nNUBLKX   EQU   *\n         SPACE 1\n         CLI   NEWLRESW,0          LRECL SPECIFIED?\n         BE    NULREX              NO - BRANCH\n         CLC   DS1LRECL,NEWLRE     ALREADY THAT\n         BE    NULREX              YES - BRANCH\n         MVC   DS1LRECL,NEWLRE     MOVE IN NEW LRECL\n         MVI   CHANGED,C'C'        SET SWITCH ON\nNULREX   EQU   *\n         SPACE 1\n         CLI   NEWPROSW,0          PROTECTION MODIFIED?\n         BE    NUPROX              NO - BRANCH\n         MVC   NEWPROSV,DS1DSIND   HOLD A COPY\n         NC    DS1DSIND,NEWPRO0    SET REQUIRED BITS OFF\n         OC    DS1DSIND,NEWPRO1    SET REQUIRED BITS ON\n         CLC   NEWPROSV,DS1DSIND   ANY CHANGE?\n         BE    *+8                 NO - LEAVE SWITCH OFF\n         MVI   CHANGED,C'C'        YES - SET SWITCH ON\nNUPROX   EQU   *\n         CLI   NEWALLSW,0          SEC. ALLOCATION ALTERED?\n         BE    NUALLX              NO - BRANCH\n         MVC   NEWPROSV,DS1SCALO   HOLD A COPY\n         NC    DS1SCALO(1),NEWALL0 SET REQUIRED BITS OFF\n         OC    DS1SCALO(1),NEWALL1 SET REQUIRED BITS ON\n         CLC   NEWPROSV,DS1SCALO   ANY CHANGE?\n         BE    *+8                 NO - LEAVE SWITCH OFF\n         MVI   CHANGED,C'C'        YES - SET SWITCH ON\nNUALLX   EQU   *\n         CLI   NEWSPASW,0          SPACE SPECIFIED?\n         BE    NUSPAX              NO - BRANCH\n         MVC   DS1SCALO+1(3),NEWSPA+1 MOVE IN NEW SPACE 1\n         MVI   CHANGED,C'C'        SET SWITCH ON\nNUSPAX   EQU   *\n         SPACE 1\n         CLI   NEWCRESW,0          CREATE SPECIFIED?\n         BE    NUCREX              NO - BRANCH\n         CLC   DS1CREDT,NEWCRE+1   IS IT ALREADY THAT VALUE\n         BE    NUCREX              YES, BRANCH\n         MVC   DS1CREDT,NEWCRE+1   MOVE IN NEW CREATION DATE\n         MVI   CHANGED,C'C'        SET SWITCH ON\nNUCREX   EQU   *\n         SPACE 1\n         MVI   EXPSW,X'FF'\n         CLI   NEWEXPSW,0          EXPDT SPECIFIED?\n         BE    NUEXPX              NO - BRANCH\n         CLC   DS1EXPDT,NEWEXP+1   IS IT ALREADY THAT VALUE\n         BE    NUEXPX              YES, BRANCH\n         MVC   DS1EXPDT,NEWEXP+1   MOVE IN NEW EXPIRATION DATE\n         MVI   CHANGED,C'C'        SET SWITCH ON\n         MVI   EXPSW,1             INDICATE NEW EXPDT\n         CLC   NEWEXP+1(3),=AL3(0)\n         BNE   *+8\n         MVI   EXPSW,0             INDICATE NEW EXPDT ZERO\nNUEXPX   EQU   *\n         SPACE 1\n         CLI   NEWREFSW,0          REFDT SPECIFIED?\n         BE    NUREFX              NO - BRANCH\n         CLC   DS1REFD,NEWREF+1    IS IT ALREADY THAT VALUE\n         BE    NUREFX              YES, BRANCH\n         MVC   DS1REFD,NEWREF+1    MOVE IN NEW REFERENCE DATE\n         MVI   CHANGED,C'C'        SET SWITCH ON\n         SPACE 1                                                    RH\nNUREFX   EQU   *\n         CLI   NEWCHBSW,0          DS1IND02 MODIFIED?               RH\n         BE    NUCHBX              NO - BRANCH                      RH\n         MVC   NEWCHBSV,DS1DSIND   HOLD A COPY                      RH\n         NC    DS1DSIND,NEWCHB0    SET REQUIRED BITS OFF            RH\n         OC    DS1DSIND,NEWCHB1    SET REQUIRED BITS ON             RH\n         CLC   NEWCHBSV,DS1DSIND   ANY CHANGE?                      RH\n         BE    *+8                 NO - LEAVE SWITCH OFF            RH\n         MVI   CHANGED,C'C'        YES - SET SWITCH ON              RH\n         SPACE 1                                                    RH\nNUCHBX   EQU   *                                                    RH\n         DROP  R5                  FORMAT1\n         CLI   CHANGED,0           ANYTHING CHANGED?\n         BNE   REWRITE             YES, GO REWRITE THE DSCB\n         LA    R1,SAMEMSG\n         LA    R0,L'SAMEMSG\n         BAL   R14,PUTMSG\n         B     EXIT0\nSAMEMSG  DC    C'NOTHING CHANGED'\n         SPACE 1\n************************************************************\n*                                                          *\n*        REWRITE THE FORMAT 1 DSCB                         *\n*                                                          *\n************************************************************\n         SPACE 1\nREWRITE  DS    0H                                                   RH\n         TM    STATUS,STATNA      ARE WE AUTH'D                     RH\n         BNO   REWRITE2           YES, DO RE-WRITE                  RH\n         LA    R1,CHNGMSG                                           RH\n         LA    R0,L'CHNGMSG                                         RH\n         BAL   R14,PUTMSG                                           RH\n         B     EXIT0                                                RH\nCHNGMSG  DC    C'CDSCB NOT AUTHORIZED. VTOC NOT CHANGED'            RH\n*HNGMSG  DC    C'IF AUTH''D, VTOC WOULD HAVE BEEN CHANGED'          RH\n*                                                                   RH\nREWRITE2 DS    0H                                                   RH\n         MVC   WRITDECB(WRITEL),DECBMODW\n         WRITE WRITDECB,DK,(R3),(R4),,DSNAME,TTR,MF=E\n         SPACE 1\n         MVI   SYNADSWT,0\n         SPACE 1\n         CHECK WRITDECB\n         SPACE 1\n         CLI   SYNADSWT,0          SYNAD EXIT TAKEN?\n         BNE   WRITERR             YES - BRANCH\nTEMPJUMP EQU   *\n         LA    R1,=C'CHANGED'\n         LA    R0,7\n         BAL   R14,PUTMSG\n         SPACE 1\n************************************************************\n*                                                          *\n*         WRITE A MESSAGE ON THE CONSOLE LOG               *\n*                                                          *\n************************************************************\n         SPACE 1\n         CLI   LOGKW+1,2           NOLOG\n         BE    NOLOG\n         CLI   EXPSW,X'FF'         WAS EXPDT CHANGED\n         BE    NOLOG               NO, BRANCH\n         MVC   MSGW(LOGL),LOG\n         L     R1,16\n         L     R1,0(,R1)\n         L     R1,4(,R1)\n         L     R1,12(,R1)          TIOT\n         LA    R15,MSGW+21\n         MVC   0(8,R15),0(R1)      INSERT JOBNAME/USERID IN MESSAGE\n         LA    R15,7(,R15)         POINT TO LAST BYTE OF JOBNAME\n         CLI   0(R15),C' '\n         BNE   *+8\n         BCT   R15,*-8\n         MVC   2(44,R15),DSNAME\n         LA    R15,45(,R15)        POINT TO LAST BYTE OF DSNAME\n         CLI   0(R15),C' '\n         BNE   *+8\n         BCT   R15,*-8\n         MVC   2(2,R15),=C'ON'\n         AH    R1,40(,R3)          DCBTIOT\n         L     R1,16(,R1)          TIOEFSRT-1, PTR TO UCB\n         MVC   5(6,R15),28(R1)     UCBVOLI\n         MVC   12(5,R15),EXPCH     NEW EXPDT\n         WTO   MF=(E,MSGW)\nNOLOG    B     EXIT0\n         EJECT\n************************************************************\n*                                                          *\n*        THIS ROUTINE IS ENTERED DURING THE 'CHECK' MACRO  *\n*        IF AN I/O ERROR OCCURS.                           *\n*                                                          *\n************************************************************\n         SPACE 1\nSYNAD    SYNADAF ACSMETH=BDAM\n         MVC   SYNADMSG(78),50(R1)\n         MVI   SYNADSWT,X'FF'      INDICATE EXIT TAKEN\n         SYNADRLS\n         BR    R14\n         EJECT\n************************************************************\n*                                                          *\n*        CALL IKJDAIR                                      *\n*                                                          *\n************************************************************\n         SPACE 1\nCALLDAIR EQU   *\n         AIF   (NOT &MVS).SKIP6\n         L     R15,16              CVTPTR\n         TM    X'02DC'(R15),X'80'  IF HI ORDER BIT NOT ON\n         BNO   CALLDLNK               THEN DO LINK, NOT CALL\n         L     R15,X'02DC'(,R15)   CVTDAIR\n         BR    R15                 CALL IKJDAIR (R14 IS SET)\nCALLDLNK EQU   *\n.SKIP6   ANOP\n         ST    R14,CALLDR14\n         LINK  EP=IKJDAIR,SF=(E,LINKAREA)\n         L     R14,CALLDR14\n         BR    R14\n         EJECT\n************************************************************\n*                                                          *\n*        PARSE VALIDITY CHECK ROUTINE FOR 'REP' KEYWORD    *\n*                                                          *\n************************************************************\n         SPACE 1\nREPVALCK EQU   *\n         DROP  R10,R11\n         USING *,R6\n         STM   R14,R12,12(R13)\n         LR    R6,R15\n         L     R7,0(,R1)           REG 7 --> PDE\n         L     R4,0(,R7)           REG 4 --> CHARACTER STRING\n         LH    R0,4(,R7)           REG 0  =  LENGTH\n         LA    R15,4               RETURN 4 IF CHECK FAILS\n         TM    5(R7),X'01'         LENGTH AN EVEN NUMBER?\n         BO    VALEXIT             NO - EXIT WITH RC=4\nVALLOOP  CLI   0(R4),C'0'          NUMERIC?\n         BNL   VALINCR             YES - THIS CHAR OK\n         CLI   0(R4),C'F'          IN RANGE A THRU F?\n         BH    VALEXIT             NO - EXIT WITH RC=4\nVALINCR  LA    R4,1(,R4)           POINT TO NEXT CHAR\n         BCT   R0,VALLOOP\n         SR    R15,R15             SET RC=0\nVALEXIT  L     R14,12(,R13)\n         LM    0,12,20(R13)\n         BR    R14\n         DROP  R6\n         USING CDSCB,R10,R11\n         EJECT\n************************************************************\n*                                                          *\n*        THIS ROUTINE CONVERTS EXTERNAL HEX TO BINARY HEX  *\n*                                                          *\n************************************************************\n         SPACE 1\nPACK     ST    R14,PACK14\n         LR    R15,R1              REG 15 --> SENDING/RECEIVING FIELD\n         SR    R14,R14\n         IC    R14,0(,R1)          REG 14  =  1ST CHAR\n         CLI   0(R1),C'0'          NUMBER OR LETTER\n         BNL   *+8                 NUMBER - BRANCH\n         LA    R14,57(,R14)        LETTER - CONVERT TO FA-FF\n         SLL   R14,4               SHIFT LEFT 4 BITS\n         STC   R14,0(,R15)         STORE THE LEFT HALF\n         IC    R14,1(,R1)          REG 14  =  2ND CHAR\n         CLI   1(R1),C'0'          NUMBER OR LETTER\n         BNL   *+8                 NUMBER - BRANCH\n         LA    R14,57(,R14)        LETTER - CONVERT\n         SLL   R14,28              SHIFT LEFT HALF TO OBLIVION\n         SRL   R14,28              SHIFT BACK AGAIN\n         STC   R14,1(,R15)         STORE RIGHT HALF\n         OC    0(1,R15),1(R15)     'OR' RIGHT HALF OVER LEFT HALF\n         LA    R1,2(,R1)           INCREMENT SENDING FIELD\n         LA    R15,1(,R15)         INCREMENT RECEIVING FLD\n         BCT   R0,PACK+6           LOOP USING LENGTH IN REG 0\n         L     R14,PACK14\n         BR    R14                 EXIT\n         SPACE 1\n         SPACE 1\n************************************************************\n*                                                          *\n*  UNPACK - CONVERT A FIELD TO HEXADECIMAL.                *\n*  REG 1 --> INPUT   REG 15 --> OUTPUT                     *\n*  REG 0  =  INPUT LENGTH  (OUTPUT IS TWICE PLUS 1 BLANK)  *\n*  REG 14 --> RETURN ADDRESS ( BAL   R14,UNPACK )          *\n*                                                          *\n************************************************************\n         SPACE 1\nUNPACK   UNPK  0(3,R15),0(2,R1)    UNPACK\n         TR    0(2,R15),UNPACKT-240\n         LA    R15,2(,R15)         INCREMENT OUTPUT PTR\n         LA    R1,1(,R1)           INCREMENT INPUT PTR\n         BCT   R0,UNPACK           DECREMENT LENGTH, THEN LOOP\n         MVI   0(R15),C' '         BLANK THE TRAILING BYTE\n         BR    R14                 RETURN TO CALLER\nUNPACKT  DC    C'0123456789ABCDEF' TRANSLATE TABLE\n         EJECT\n************************************************************\n*                                                          *\n*        ERROR MESSAGES                                    *\n*                                                          *\n************************************************************\n         SPACE 1\nINVREP   LA    R1,INVREPM\n         LA    R0,L'INVREPM\n         B     ERRMSG\nINVREPM  DC    C'MISSING OR INVALID REP PARAMETER'\n         SPACE 1\nREADERR  EQU   *\nWRITERR  LA    R1,SYNADMSG\n         LA    R0,78\n         B     ERRMSG\n         SPACE 1\nREPDERR  LA    R1,REPDERRM\n         LA    R0,L'REPDERRM\n         B     ERRMSG\nREPDERRM DC    CL44'INVALID REP - REP LENGTH EXCEEDS VER LENGTH '\n         SPACE 1\nREPOERR  LA    R1,REPOERRM\n         LA    R0,40\n         B     ERRMSG\nREPOERRM DC    CL40'REP OFFSET INVALID - MUST BE AT LEAST 2D'\n         SPACE 1\nREPVERR  LA    R1,REPVERRM\n         LA    R0,L'REPVERRM\n         B     ERRMSG\nREPVERRM DC    CL32'REP GOES BEYOND END OF RECORD   '\n         SPACE 1\nVERREJ   LA    R1,VERREJM\n         LA    R0,L'VERREJM\n         B     ERRMSG\nVERREJM  DC    CL14'VERIFY REJECT '\n         SPACE 1\nLOCERR   LA    R1,LOCERRM\n         LA    R0,L'LOCERRM\n         B     ERRMSG\nLOCERRM  DC    CL22'DATASET NOT IN CATALOG'\n         SPACE 1\nDAIRERR  BAL   R14,DAIRFAIL\n         B     EXIT12\n         SPACE 1\nAUTHERR  LA    R1,AUTHERRM\n         LA    R0,L'AUTHERRM\n         B     ERRMSG\nAUTHERRM DC    C'ENVIRONMENT IS NOT APF AUTHORIZED'\n         SPACE 1\nOPENERR  LA    R1,OPENERRM\n         LA    R0,L'OPENERRM\n         B     ERRMSG\nOPENERRM DC    CL12'OPEN FAILED '\n         SPACE 1\nPARSERR  LA    R1,PARSERRM\n         LA    R0,L'PARSERRM\n         B     ERRMSG\nPARSERRM DC    C'PARSE FAILED'\n         SPACE 1\nERRCDATE LA    R1,CDATERRM\n         LA    R0,L'CDATERRM\n         B     ERRMSG\nCDATERRM DC    C'INVALID CREATE DATE'\n         SPACE 1\nERRXDATE LA    R1,XDATERRM\n         LA    R0,L'XDATERRM\n         B     ERRMSG\nXDATERRM DC    C'INVALID EXPIRATION DATE'\n         SPACE 1\nERRRDATE LA    R1,RDATERRM\n         LA    R0,L'RDATERRM\n         B     ERRMSG\nRDATERRM DC    C'INVALID REFERENCE DATE'\n         SPACE 1\nERRDSN   LA    R1,MSGDSN\n         LA    R0,L'MSGDSN\nERRMSG   BAL   R14,PUTMSG\n         B     EXIT12\nMSGDSN   DC    C'DATA SET NAME MUST NOT CONTAIN MEMBER NAME'\n         SPACE 1\n************************************************************\n*                                                          *\n*        PUTMSG ROUTINE                                    *\n*                                                          *\n************************************************************\n         SPACE 1\nPUTMSG   STM   R14,R1,PUTSAVE\n         XC    MYOLD(8),MYOLD\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPM\n         LA    R14,1               NO. OF MESSAGE SEGMENTS\n         ST    R14,MYOLD\n         LA    R14,MYSEG1          POINT TO 1ST SEGMENT\n         ST    R14,MYOLD+4\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         LA    R15,MYSEG1+4\n         CLC   0(3,R1),=C'IKJ'     IS DATA PRECEEDED BY MESSAGE ID?\n         BE    *+16                YES - BRANCH\n         LA    R14,1(,R14)         ADD 1 TO LENGTH\n         MVI   0(R15),C' '         INSERT LEADING BLANK\n         LA    R15,1(,R15)         BUMP POINTER\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   0(0,R15),0(R1)      MOVE MESSAGE IN\n         EX    R14,*-6\n         LA    R1,MYIOPL\n         L     R15,MYPUTLEP\n         SPACE 1\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYOLD),ENTRY=(15),MF=(E,(1))\n         SPACE 1\n         LM    R14,R1,PUTSAVE\n         BR    R14\n         SPACE 1\n************************************************************\n*                                                          *\n*        PUTLINE ROUTINE                                   *\n*                                                          *\n************************************************************\n         SPACE 1\nPUTLINE  STM   R14,R1,PUTSAVE\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPB\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   MYSEG1+4(0),0(R1)   MOVE TEXT IN\n         EX    R14,*-6\n         LA    R1,MYIOPL\n         L     R15,MYPUTLEP\n         SPACE 1\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYSEG1,DATA),ENTRY=(15),MF=(E,(1))\n         SPACE 1\n         LM    R14,R1,PUTSAVE\n         BR    R14\n         SPACE 1\n         PRINT GEN\n         EJECT\n************************************************************\n*                                                          *\n*        DYNAMIC ALLOCATION FAILURE ROUTINE                *\n*                                                          *\n************************************************************\n         SPACE 1\nDAIRFAIL ST    R14,MYDFREGS\n         LA    R1,MYDFPARM\n*        USING DFDSECTD,R1         MAPPED BY IKJEFFDF DFDSECT=YES MACRO\n         ST    R15,MYDFRC\n         LA    R15,MYDFRC\n         ST    R15,4(,R1)          DFRCP\n         LA    R15,MYDAPL\n         ST    R15,0(,R1)          DFDAPLP\n         SLR   R15,R15\n         ST    R15,MYJEFF02\n         LA    R15,MYJEFF02\n         ST    R15,8(,R1)          DFJEFF02\n         LA    R15,1               DFDAIR\n         STH   R15,MYDFID\n         LA    R15,MYDFID\n         ST    R15,12(,R1)         DFIDP\n         ST    R2,16(,R1)          DFCPPLP\n         LINK  EP=IKJEFF18,SF=(E,LINKAREA)\n         L     R15,MYDFRC\n*        DROP  R1                  DFDSECTD\n         L     R14,MYDFREGS\n         BR    R14\n         SPACE 1\n         EJECT\n************************************************************\n*                                                          *\n*        CLOSE THE VTOC                                    *\n*                                                          *\n************************************************************\n         SPACE 1\nEXIT12   LA    R15,12\n         B     EXIT\nEXIT0    SR    R15,R15             RETURN CODE ZERO\nEXIT     ST    R15,RC\n         TM    STATUS,STATQ        IS ENQ ACTIVE\n         BZ    EXITNODQ            NO, SKIP DEQ\n         MVC   DW(DL),D            MOVE MF=L TO WORK AREA\n         SPACE 1\n         DEQ   (QNAME,RNAME,6,SYSTEMS),RET=HAVE,MF=(E,DW)\n         SPACE 1\n         NI    STATUS,255-STATQ    DEQ\nEXITNODQ EQU   *\n         TM    STATUS,STATO        IS DCB OPEN\n         BZ    EXITNOCL            NO, SKIP CLOSE\n         FREEBUF (R3),(R4)\n         SPACE 1\n         MVC   CLOSED,CLOSE\n         CLOSE ((R3)),MF=(E,CLOSED)\n         NI    STATUS,255-STATO    CLOSED\nEXITNOCL EQU   *\n         SPACE 1\n         TM    STATUS,STATG        WAS GETPOOL ISSUED\n         BZ    EXITNOFP            NO, SKIP FREEPOOL\n         FREEPOOL (R3)\n         NI    STATUS,255-STATG    CLOSED\nEXITNOFP EQU   *\n         SPACE 1\n************************************************************\n*                                                          *\n*        INSTALLATION-DEPENDENT CODE                       *\n*        TO UNDO THE EARLIER INSTALLATION-DEPENDENT CODE   *\n*                                                          *\n************************************************************\n         SPACE 1\n         L     1,16                CVTPTR\n         L     1,0(,1)             TCB WORDS\n         L     1,4(,1)             CURRENT TCB\n         L     4,180(,1)           JSCB\n         TM    STATUS,STATM        WAS AUTH CHANGED\n         BZ    EXITNOMS            NO, BRANCH\n         LA    0,0                 R0 = FUNCTION CODE FOR USER SVC\n         LA    15,KEYUA            R15 POINTS TO ROUTINE TO BE CALLED\nUSRSVC2  NOPR  0                   *** REPLACE WITH USER SVC ***\n         B     KEYUB               BRANCH AROUND THE ROUTINE\nKEYUA    NI    236(4),X'FE'        SET OFF JSCBAUTH\n         BR    14                  RETURN TO SVC\nKEYUB    NI    STATUS,255-STATM\nEXITNOMS EQU   *\n         SPACE 1\n************************************************************\n*                                                          *\n*        UNALLOCATE VIA DYNAMIC ALLOCATION                 *\n*                                                          *\n************************************************************\n         SPACE 1\n         TM    STATUS,STATA        WAS ALLOCATE DONE\n         BZ    EXITNOFR            NO, BYPASS FREE\n         LA    R1,MYDAPL\n         USING DAPL,R1\n         L     14,DAPLECB\n         XC    0(4,14),0(14)\n         L     15,DAPLDAPB\n         DROP  R1\n         USING DAPB18,15\n         XC    0(40,15),0(15)\n         MVI   DA18CD+1,X'18'\n         MVC   DA18MNM,=CL8' '\n         MVI   DA18DPS2,DA18KEEP\n         MVI   DA18CTL,X'00'\n         MVC   DA18SCLS(2),=CL8' '\n         MVC   DA18JBNM(8),=CL8' '\n         MVC   DA18DDN(8),DCBDDNAM\n         SPACE 1\n         BAL   R14,CALLDAIR\n         NI    STATUS,255-STATA\nEXITNOFR EQU   *\n         SPACE 1\n************************************************************\n*                                                          *\n*        FINAL EXIT FROM PROGRAM                           *\n*                                                          *\n************************************************************\n         SPACE 1\n         IKJRLSA MYANS\n         CLI   RC+3,0              IS RC ZERO?\n         BE    STACKDX             YES, BRANCH\n         MVC   MYSTPB(STACKDL),STACKD\n         SPACE 1\n         STACK DELETE=ALL,PARM=MYSTPB,MF=(E,MYIOPL)\n         SPACE 1\n         TCLEARQ\nSTACKDX  EQU   *\n         SPACE 1\n         L     R15,RC\n         LR    R1,R13\n         L     R0,SIZE\n         L     R13,4(0,R13)       R13 -> TO CALLERS SAVE AREA       RH\n         LR    R2,R15\n         FREEMAIN R,A=(1),LV=(0)\n         LR    R15,R2\n*        RETURN (14,12),RC=(15)\n*        L     R15,RETCODE        LOAD RC\n*        L     R13,4(R13)         R13 -> TO CALLERS SAVE AREA\n         L     R14,12(R13)        SET R14 TO WHAT CALLER'S R14\n         LM    R0,R12,20(R13)     SET R0-R12 TO CALLERS REGS\n*              GET INTO PROPER MODE AND GO BACK TO CALLER\n         BSM   0,R14              RETURN TO CALLING PROGRAM\n         SPACE 1\n************************************************************\n*                                                          *\n*        CONSTANTS                                         *\n*                                                          *\n************************************************************\n         SPACE 1\n         LTORG\n         SPACE 1\n*              THE BYTES IN THE FOLLOWING TABLE\n*              MUST BE IN THE SAME ORDER AS THE\n*              'IKJNAME' ENTRIES IN THE PARSE\n*              PCL PARAMETERS.\nRECFMTAB DC    X'00'              NO RECFM\n         DC    X'80'               F\n         DC    X'88'               FS\n         DC    X'84'               FA\n         DC    X'82'               FM\n         DC    X'90'               FB\n         DC    X'98'               FBS\n         DC    X'94'               FBA\n         DC    X'92'               FBM\n         DC    X'40'               V\n         DC    X'48'               VS\n         DC    X'44'               VA\n         DC    X'42'               VM\n         DC    X'50'               VB\n         DC    X'58'               VBS\n         DC    X'54'               VBA\n         DC    X'52'               VBM\n         DC    X'C0'               U\n         DC    X'C4'               UA\n         DC    X'C2'               UM\n         DC    X'E0'               UT\nDSORGTAB DC    X'00'\n         DC    X'40'               PS\n         DC    X'41'               PSU\n         DC    X'02'               PO\n         DC    X'03'               POU\n         DC    X'20'               DA\n         DC    X'21'               DAU\n         SPACE 1\nMODLPTPM PUTLINE OUTPUT=(1,TERM,SINGLE,INFOR),                         X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE 1\nMODLPTPB PUTLINE OUTPUT=(1,TERM,SINGLE,DATA),                          X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE 1\nENDOFREC DC    0H'0',AL2(44+96-1) OFFSET TO LAST BYTE OF RECORD\n         PRINT GEN                 LIST DCB SO LIMCT CAN BE ZAPPED\n         SPACE 1\nDCBMODEL DCB   DDNAME=DYNAM,DSORG=DA,MACRF=(RKC,WKC),                  X\n               BUFL=96,OPTCD=EF,LIMCT=57,                              X\n               RECFM=F,BLKSIZE=96,KEYLEN=44,                           X\n               EXLST=0,SYNAD=SYNAD\nDCBLEN   EQU   *-DCBMODEL\n         PRINT GEN\n         SPACE 1\nRDJFCB   RDJFCB 0,MF=L\n         SPACE 1\nOPENJ    OPEN  0,TYPE=J,MF=L\n         SPACE 1\nCLOSE    CLOSE 0,MF=L\n         SPACE 1\nREAD     READ  DECBMODR,DKF,0,'S','S',0,0,MF=L\nREADL    EQU   *-DECBMODR\n         SPACE 1\nWRITE    WRITE  DECBMODW,DK,0,'S','S',0,0,MF=L\nWRITEL   EQU   *-DECBMODW\n         SPACE 1\nSTAXDEF  STAX  DEFER=YES,MF=L\n         SPACE 1\nSTAXDEN  STAX  DEFER=NO,MF=L\n         SPACE 1\nR        RESERVE (77,88,E,6,SYSTEMS),RET=HAVE,UCB=99,MF=L\nRL       EQU   *-R\n         SPACE 1\nD        DEQ   (77,88,6,SYSTEMS),RET=HAVE,MF=L\nDL       EQU   *-D\n         SPACE 1\nLOG      WTO   'CMI000I CDSCB BY                                       +\n                                                 ',ROUTCDE=(2),MF=L\nLOGL     EQU   *-LOG\n*        WTO   'CMI000I CDSCB BY UUUUUUUU TO DSNAME78901234567890123456\n*              789012345678901234 ON VVVVVV EEEEE',ROUTCDE=(2),MF=L\n         SPACE 1\nSTACKD   STACK DELETE=ALL,MF=L\nSTACKDL  EQU   *-STACKD\nPCLADDR  DC    0D'0'               END OF CSECT, BEGIN PARSE PCL CSECT\n         SPACE 1\n************************************************************\n*                                                          *\n*         PARSE PCL CSECT AND PDL DSECT                    *\n*                                                          *\n************************************************************\n         PRINT NOGEN\n         SPACE 1\nCDSCBPCL IKJPARM\n         AIF   (NOT &MVS).SKIP7\nDSN      IKJPOSIT DSNAME,USID,PROMPT='DATASET NAME'\n.SKIP7   AIF   (&MVS).SKIP8\nDSN      IKJPOSIT DSNAME,PROMPT='DATA SET NAME'\n.SKIP8   ANOP\nSHRKW    IKJKEYWD\n         IKJNAME 'SHR'\nVOLKW    IKJKEYWD\n         IKJNAME 'VOLUME',SUBFLD=VOLSUB\nUNIKW    IKJKEYWD\n         IKJNAME 'UNIT',SUBFLD=UNISUB\nZAPKW    IKJKEYWD\n         IKJNAME 'ZAP',SUBFLD=ZAPSUB\nRECKW    IKJKEYWD\n         IKJNAME 'RECFM',SUBFLD=RECSF\nLREKW    IKJKEYWD\n         IKJNAME 'LRECL',SUBFLD=LRESF\nBLKKW    IKJKEYWD\n         IKJNAME 'BLKSIZE',SUBFLD=BLKSF\nDSOKW    IKJKEYWD\n         IKJNAME 'DSORG',SUBFLD=DSOSF\nPROKW    IKJKEYWD\n         IKJNAME 'PW'\n         IKJNAME 'PWREAD'\n         IKJNAME 'PWWRITE'\n         IKJNAME 'NOPW'\n         IKJNAME 'RACF'\n         IKJNAME 'NORACF'\nALLKW    IKJKEYWD\n         IKJNAME 'ALLOC',SUBFLD=ALLSF\nSPAKW    IKJKEYWD\n         IKJNAME 'SPACE',SUBFLD=SPASF\nCREATEKW IKJKEYWD\n         IKJNAME 'CREATE',SUBFLD=CRESF\nEXPDTEKW IKJKEYWD\n         IKJNAME 'EXPDT',SUBFLD=EXPSF\nREFDTEKW IKJKEYWD\n         IKJNAME 'REFDT',SUBFLD=REFSF\nLOGKW    IKJKEYWD\n         IKJNAME 'LOG'\n         IKJNAME 'NOLOG'\nCHBIT    IKJKEYWD                        ,                          RH\n         IKJNAME 'CHBIT',SUBFLD=CHBSF    ,                          RH\n*\n*              SUBFIELDS\n*\nVOLSUB   IKJSUBF\nVOL      IKJIDENT 'VOLUME',FIRST=ALPHANUM,OTHER=ALPHANUM,MAXLNTH=6,    X\n               PROMPT='VOLUME SERIAL'\nUNISUB   IKJSUBF\nUNIT     IKJIDENT 'UNIT',FIRST=ALPHANUM,OTHER=ANY,MAXLNTH=8,           +\n               PROMPT='UNIT NAME'\nZAPSUB   IKJSUBF\nREP      IKJIDENT 'ZAP PARAMETER',LIST,                                +\n               FIRST=ALPHANUM,OTHER=ALPHANUM,MAXLNTH=12,               +\n               PROMPT='ZAP IN FORMAT OFFSET,VERDATA,REPDATA',          +\n               VALIDCK=REPVALCK\nCHBSF    IKJSUBF                  ,                                 RH\nBACKBIT  IKJKEYWD                 ,                                 RH\n         IKJNAME 'ON'             ,                                 RH\n         IKJNAME 'OFF'            ,                                 RH\n*                                                                   RH\nRECSF    IKJSUBF\nRECFM    IKJKEYWD\n         IKJNAME 'F'\n         IKJNAME 'FS'\n         IKJNAME 'FA'\n         IKJNAME 'FM'\n         IKJNAME 'FB'\n         IKJNAME 'FBS'\n         IKJNAME 'FBA'\n         IKJNAME 'FBM'\n         IKJNAME 'V'\n         IKJNAME 'VS'\n         IKJNAME 'VA'\n         IKJNAME 'VM'\n         IKJNAME 'VB'\n         IKJNAME 'VBS'\n         IKJNAME 'VBA'\n         IKJNAME 'VBM'\n         IKJNAME 'U'\n         IKJNAME 'UA'\n         IKJNAME 'UM'\n         IKJNAME 'UT'\nLRESF    IKJSUBF\nLRE      IKJIDENT 'LRECL',                                             +\n               FIRST=NUMERIC,OTHER=NUMERIC,MAXLNTH=5,                  +\n               PROMPT='LOGICAL RECORD LENGTH'\nBLKSF    IKJSUBF\nBLK      IKJIDENT 'BLOCK SIZE',                                        +\n               FIRST=NUMERIC,OTHER=NUMERIC,MAXLNTH=5,                  +\n               PROMPT='BLOCK SIZE'\nDSOSF    IKJSUBF\nDSORG    IKJKEYWD\n         IKJNAME 'PS'\n         IKJNAME 'PSU'\n         IKJNAME 'PO'\n         IKJNAME 'POU'\n         IKJNAME 'DA'\n         IKJNAME 'DAU'\nALLSF    IKJSUBF\nALL      IKJKEYWD\n         IKJNAME 'NONE'\n         IKJNAME 'BLOCKS'\n         IKJNAME 'TRACKS'\n         IKJNAME 'CYLINDERS'\nSPASF    IKJSUBF\nSPA      IKJIDENT 'SECONDARY SPACE AMOUNT',                            +\n               FIRST=NUMERIC,OTHER=NUMERIC,MAXLNTH=4,                  +\n               PROMPT='SECONDARY SPACE AMOUNT'\nCRESF    IKJSUBF\nCREATE   IKJIDENT 'CREATION DATE',ASTERISK,                            +\n               FIRST=NUMERIC,OTHER=NUMERIC,MAXLNTH=5,                  +\n               PROMPT='CREATION DATE'\nEXPSF    IKJSUBF\nEXPDTE   IKJIDENT 'EXPIRATION DATE',ASTERISK,                       RH +\n               FIRST=NUMERIC,OTHER=NUMERIC,MAXLNTH=5,                  +\n               PROMPT='EXPIRATION DATE'\nREFSF    IKJSUBF\nREFDTE   IKJIDENT 'REFERENCE DATE',ASTERISK,                           +\n               FIRST=NUMERIC,OTHER=NUMERIC,MAXLNTH=5,                  +\n               PROMPT='REFERENCE DATE'\n         IKJENDP\n         SPACE 1\n         LTORG\n         SPACE 1\n************************************************************\n*                                                          *\n*        DSECTS                                            *\n*                                                          *\n************************************************************\n         PRINT GEN\n         SPACE 1\n@DATA    DSECT\n         DS    18F\nSIZE     DS    F\nLINKAREA DS    2F\nSTATUS   DS    F\nSTATA    EQU   X'80'\nSTATM    EQU   X'40'\nSTATG    EQU   X'20'\nSTATO    EQU   X'10'\nSTATQ    EQU   X'08'\nSTATNA   EQU   X'04'              NOT AUTH'D                        RH\nMYPPL    DS    8F                                                   RH\nMYANS    DS    F\nMYECB    DS    F                   USED BY PUTLINE ROUTINE\nMYIOPL   DS    4F                  USED BY PUTLINE ROUTINE\nMYPTPB   DS    3F                  USED BY PUTLINE ROUTINE\nMYPUTLEP DS    F                   USED BY PUTLINE ROUTINE\nMYOLD    DS    2F                  USED BY PUTLINE ROUTINE\nMYSEG1   DS    2H,CL100            USED BY PUTLINE ROUTINE\nPUTSAVE  DS    4F                  USED BY PUTLINE ROUTINE\nMYSTPB   DS    5F\nMYDAPL   DS    5F\nMYDAPB   DS    21F\nCALLDR14 DS    F\nDSNAMEL  DS    H\nDSNAME   DS    CL44\nRW       DS    4F\nQNAME    DS    CL8\nRNAME    DS    CL6\nUCBAD    DS    F\nDW       DS    3F\nDEVAREA  DS    5F\nTRACKS   DS    H\nSYNADMSG DS    0CL78\nMSGW     DS    CL100\nSYNADSWT DS    C\nCHANGED  DS    C\nEXPSW    DS    C\nEXPCH    DS    CL5\nNEWPROSW DS    C\nNEWPRO0  DS    C\nNEWPRO1  DS    C\nNEWPROSV DS    C\nNEWBLKSW DS    C\nNEWLRESW DS    C\nNEWBLK   DS    H\nNEWLRE   DS    H\nNEWALLSW DS    C\nNEWALL0  DS    C\nNEWALL1  DS    C\nNEWSPASW DS    C\nNEWSPA   DS    F\nNEWCRESW DS    C\nNEWEXPSW DS    C\nNEWREFSW DS    C\nNEWCRE   DS    F\nNEWEXP   DS    F\nNEWREF   DS    F\nNEWRECSW DS    C\nNEWRECFM DS    C\nNEWDSOSW DS    CL2\nNEWDSORG DS    C\nNEWCHBSW DS    C\nNEWCHB0  DS    C\nNEWCHB1  DS    C\nNEWCHBSV DS    C\nTTR      DS    D\nOPEND    DS    F\nOPENJD   DS    F\nRDJFCBD  DS    F\nREADDECB DS    7F\nWRITDECB DS    7F\nCLOSED   DS    F\nDCB      DS    0D,XL104\nJFCB     DS    0D,XL176\nEXLSTD   DS    F\nWRKUNIT  DS    CL8\nDATE5    DS    0CL5\nWRKVOL   DS    CL6\nOFFSET   DS    H,CL3\nVERDATA  DS    CL14     LENGTH TIED TO MAXLNTH IN IKJPOSIT\nREPDATA  DS    CL14     1ST BYTE IS LENGTH, LAST BYTE USED BY 'PACK'\nVR       DS    C\nPACK14   DS    F\nEXTRACTD DS    3F\nEXTRACT  DS    2F\nSTAXD    DS    5F\nDOUBLE   DS    D\nRC       DS    F\nMYDFPARM DS    5F  USED BY DAIRFAIL\nMYDFREGS DS    F   USED BY DAIRFAIL\nMYDFRC   DS    F   USED BY DAIRFAIL\nMYJEFF02 DS    F   USED BY DAIRFAIL\nMYDFID   DS    H   USED BY DAIRFAIL\n         DS    0D\n@DATAL   EQU   *-@DATA\n*                                                                   RH\n TITLE 'RACHEC - GO SEE IF THEY HAVE UPDATE ACCESS TO RESOURCE'     RH\n         DS    0H                                                   RH\nRACHEC   SECTION GEN=YES                                            RH\n*                                                                   RH\n*                                                                   RH\n********************************************************************RH\n*                                                                   RH\n* RETRIEVE THE USERS RACF USERID AND GROUP FROM THE ACEE TO         RH\n* SEE IF WE HAVE ACCESS TO GROUP SPECIAL OR OPERATNS                RH\n*                                                                   RH\n********************************************************************RH\n*                                                                   RH\n*                                                                   RH\nGETUSER  DS    0H                                                   RH\n         L     R15,PSAAOLD-PSA         LOAD ADDRESS OF CURRENT ASCB RH\n         L     R15,ASCBASXB-ASCB(R15)  LOAD ASXB ADDRESS            RH\n         L     R15,ASXBSENV-ASXB(R15)  LOAD ACEE ADDRESS            RH\n         ST    R15,ACEEADDR       SAVE IT                           RH\n         MVC   USRLTH(9),ACEEUSER-ACEE(R15) SAVE USERID FROM ACEE   RH\n         MVC   RACGROUP(9),ACEEGRP-ACEE(R15) SAVE ACEE GROUP        RH\n*                                                                   RH\n         SPACE 1                                                    RH\n***********************************************************************\n*                                                                   RH\n*  MAKE SURE WE HAVE RACF ACCESS TO GROUP/CLASS....                 RH\n*                                                                   RH\n***********************************************************************\n         SR    R6,R6              CLEAR R6                          RH\n         IC    R6,USERACC         R6 = ACCESS CODE                  RH\n         LA    R7,RACGROUP+1      ADDRESS OF GROUP                  RH\n         LA    R5,LTHCLAS2        ADDRESS OF CLASS                  RH\n         LA    R2,ACEEUSR         ADDRESS OF USRID                  RH\n         ICM   R3,15,ACEEADDR     R3 -> TO ACEE                     RH\n         SPACE 1                                                    RH\nACEEOK2  DS    0H                                                   RH\n*              DO RACHECK....DOESN'T NEED APF...                    RH\n         LA    R4,USRDSN          ADDRESS OF RESOURCE BUFFER        RH\n*        RACHECK ENTITY=((R4)),CLASS=(R5),ATTR=(6),                 RH\n         RACHECK ,                                                  RH +\n               ATTR=(6),          ALTER....                         RH +\n               CLASS=(5),         S/B DASDVOL                       RH +\n               ENTITY=((4)),      THE VOLSER IN CLASS               RH +\n               LOG=NONE                                             RH\n         AGO   .SKIPRTE                                             RH\n*        NOTE  YOU MUST BE APF'D  TO USE RACROUTE....               RH\n         LA    R4,LTHDSNB         ADDRESS OF RESOURCE BUFFER        RH\n         LA    R1,RACMAC          ADDRESS OF RACROUTE LIST          RH\n         RACROUTE REQUEST=AUTH,                                     RH +\n               ACEE=(3),          NEEDS AC(1)                       RH +\n               ATTR=(6),          WAS UPDATE                        RH +\n               CLASS=(5),         S/B DASDVOL                       RH +\n               ENTITYX=((4)),     THE VOLSER IN CLASS               RH +\n               GROUPID=(7),                                         RH +\n               RELEASE=1.9,                                         RH +\n               USERID=(2),        NEEDS AC(1)                       RH +\n               WORKA=RACWORK,                                       RH +\n               MF=(E,(1))                                           RH\n*                                                                   RH\n         SPACE 1                                                    RH\n.SKIPRTE ANOP                                                       RH\n*        LTR   R15,R15            ARE WE OKAY?                      RH\n*        BZ    RACRET             YES                               RH\n*        LA    R15,4              RC = 4                            RH\nRACRET   DS    0H                                                   RH\n         SPACE 1                                                    RH\nRACHEC9  SECEXIT GEN=YES                                            RH\n         SPACE 2                                                    RH\n**********************************************************************\n         SPACE 2                                                    RH\n         ENTRY USRCLAS2,LTHCLAS2                                    RH\nLTHCLAS2 DC    X'07'              CLASS LTH                         RH\nUSRCLAS2 DC    CL08'DASDVOL '     CLASS                             RH\n*                                                                   RH\nRACGROUP DC    AL1(4),CL8'SYS1'                                     RH\n         ENTRY USRDSN,LTHDSND                                       RH\n         CNOP  0,4                ON FULLWORD BOUNDARY....          RH\nACEEADDR DC    F'0'                                                 RH\nLTHDSNB  DC    AL2(44)            LTH OF RESOURCE BUFFER            RH\nLTHDSND  DC    AL2(6)             LTH OF RESOURCE IN BUFFER         RH\nUSRDSN   DC    CL44'VOLSER '      RESOURCE                          RH\nUSERACC  DC    X'80'              USER ACCESS                       RH\n*        EQU   X'02'              ACCESS=READ                       RH\n*        EQU   X'04'              ACCESS=UPDATE                     RH\n*        EQU   X'08'              ACCESS=CONTROL                    RH\n*        EQU   X'80'              ACCESS=ALTER                      RH\n*                                                                   RH\n*                                                                   RH\nRACWORK  DS    CL512                                                RH\nWORK64   DS    CL64                64 BYTE WKA                      RH\nWORK716  DS    CL716               716 BYTE WKA                     RH\nUSRLTH   DC    X'08'              USERID LTH                        RH\nACEEUSR  DC    CL8' '             ACEE USERID...MUST BE AFTER USRLTHRH\n*                                                                   RH\nRACMAC   RACROUTE REQUEST=AUTH,                                     RH +\n               WORKA=RACWORK,                                       RH +\n               RELEASE=1.9,                                         RH +\n               MF=L                                                 RH\n*                                                                   RH\n*                                 OTHER RACROUTE PARMS.....         RH\n*              ATTR=UPDATE,                                         RH\n*              LOG=ASIS                                             RH\n         LTORG                                                      RH\n*                                                                   RH\n         SPACE 2                                                    RH\nIHADCB   DSECT\n         DS    XL36\nDCBEXLST DS    F\nDCBDDNAM DS    XL8\nDCBDEBAD EQU   *-4,4\nDCBOFLGS DS    X\nDCBLIMCT EQU   IHADCB+81,3\n         SPACE 1\n         IKJCPPL\n         SPACE 2\n         IKJIOPL\n         SPACE 2\n         IKJUPT\n         SPACE 2\n         IKJPSCB\n         SPACE 2\n         IKJECT\n         SPACE 2\n         IKJPPL\n         SPACE 2\n         IKJDAPL\n         SPACE 2\n         IKJDAP08\n         SPACE 2\n         IKJDAP18\n         SPACE 2\nFORMAT1  DSECT\nIECSDSL1 EQU   *                   FORMAT 1 DSCB\nIECSDSF1 EQU   IECSDSL1\nDS1DSNAM DS    CL44                DATA SET NAME\nDS1FMTID DS    CL1                 FORMAT IDENTIFIER\nDS1DSSN  DS    CL6                 DATA SET SERIAL NUMBER\nDS1VOLSQ DS    XL2                 VOLUME SEQUENCE NUMBER\nDS1CREDT DS    XL3                 CREATION DATE\nDS1EXPDT DS    XL3                 EXPIRATION DATE\nDS1NOEPV DS    XL1                 NUMBER OF EXTENTS ON VOLUME\nDS1NOBDB DS    XL1                 NUMBER OF BYTES USED IN LAST\n*                                     DIRECTORY BLOCK\n         DS    XL1                 RESERVED\nDS1SYSCD DS    CL13                SYSTEM CODE\nDS1REFD  DS    XL3                 DATE LAST REFERENCED OR    @G60ASBJ\n*                                     ZERO IF NOT MAINTAINED  @G60ASBJ\n         DS    XL4                 RESERVED                   @G60ASBJ\nDS1DSORG DS    XL2                 DATA SET ORGANIZATION\nDS1RECFM DS    XL1                 RECORD FORMAT\nDS1OPTCD DS    XL1                 OPTION CODE\nDS1BLKL  DS    XL2                 BLOCK LENGTH\nDS1LRECL DS    XL2                 RECORD LENGTH\nDS1KEYL  DS    XL1                 KEY LENGTH\nDS1RKP   DS    XL2                 RELATIVE KEY POSITION\nDS1DSIND DS    XL1                 DATA SET INDICATORS\nDS1IND80 EQU   X'80'               LAST VOLUME ON WHICH A DATA@G60ASBJ\n*                                  SET RESIDES                @G60ASBJ\nDS1IND40 EQU   X'40'               DATA SET IS RACF DEFINED   @G60ASBJ\nDS1IND20 EQU   X'20'               BLOCK LENGTH IS A MULTIPLE @G60ASBJ\n*                                  OF 8 BYTES                 @G60ASBJ\nDS1IND10 EQU   X'10'               PASSWORD IS REQUIRED TO    @G60ASBJ\n*                                  READ OR WRITE OR BOTH-SEE  @G60ASBJ\n*                                  DS1IND04                   @G60ASBJ\nDS1IND08 EQU   X'08'               RESERVED                   @G60ASBJ\nDS1IND04 EQU   X'04'               IF DS1IND10 IS 1 THEN IF   @G60ASBJ\n*                                  DS1IND04 IS . . .          @G60ASBJ\n*                                  1-PASSWORD REQUIRED TO     @G60ASBJ\n*                                  WRITE BUT NOT TO READ      @G60ASBJ\n*                                  0-PASSWORD REQUIRED TO     @G60ASBJ\n*                                  WRITE AND TO READ          @G60ASBJ\nDS1IND02 EQU   X'02'               DATASET OPENED FOR OTHER   @G60ASBJ\n*                                  THAN INPUT SINCE LAST      @G60ASBJ\n*                                  BACKUP COPY MADE.          @G60ASBJ\nDS1DSCHA EQU   DS1IND02            SAME USE AS BIT DS1IND02   @G60ASBJ\nDS1IND01 EQU   X'01'               RESERVED                   @G60ASBJ\nDS1SCALO DS    XL4                 SECONDARY ALLOCATION\nDS1LSTAR DS    XL3                 LAST USED TRACK AND BLOCK ON TRACK\nDS1TRBAL DS    XL2                 BYTES REMAINING ON LAST TRACK USED\n         DS    XL2                 RESERVED\nDS1EXT1  DS    XL10                FIRST EXTENT DESCRIPTION\n*        FIRST BYTE                EXTENT TYPE INDICATOR\n*        SECOND BYTE               EXTENT SEQUENCE NUMBER\n*        THIRD - SIXTH BYTES       LOWER LIMIT\n*        SEVENTH - TENTH BYTES     UPPER LIMIT\nDS1EXT2  DS    XL10                SECOND EXTENT DESCRIPTION\nDS1EXT3  DS    XL10                THIRD EXTENT DESCRIPTION\nDS1PTRDS DS    XL5                 POSSIBLE PTR TO A FORMAT 2 OR 3 DSCB\nDS1END   EQU   *\n         SPACE 1                                                    RH\n         REQUATE                                                    RH\n         IHAPSA                                                     RH\n         IHAACEE                                                    RH\n         IHAASCB                                                    RH\n         IHAASXB                                                    RH\n         SPACE 3                                                    RH\n* DUMMY JFCB                                                        RH\nJFCBD    DSECT                                                      RH\n         IEFJFCBN ,                                                 RH\n         END\n/*\n//LKED.SYSLMOD DD DSN=IMSVS.AUTHLIB1,DISP=SHR\n//LKED.SYSIN DD *\n    SETCODE AC(1)\n    NAME CDSCB(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CHKOTMA": {"ttr": 4871, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x12T\\x06\\x01\\x06\\x01\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T12:54:00", "lines": 1537, "newlines": 1537, "modlines": 0, "user": "RH87944"}, "text": "//CHKOTMA  JOB\n/*ROUTE  PRINT  R7\n//S1        EXEC  HLASMCL,CLASS='*',        PARMC=RENT,PARML=RENT,\n//   COND.LKED=(7,LT,ASM)\n//ASM.SYSLIB  DD DSN=SYS1.MACLIB\n//  DD DSN=IMSVS.GENLIB,DISP=SHR\n//  DD DSN=IMSVS.GENLIBA,DISP=SHR\n//  DD DSN=IMSVS.GENLIBB,DISP=SHR\n//  DD DSN=SYS1.AMODGEN,DISP=SHR\n//  DD DSN=IMSVS.OTMA.V2R1M3.GENLIBB,DISP=SHR  NOT NEEDED??\n//ASM.SYSIN DD  *\n*********************************************************************\n*   CHKOTMA - ACCEPT PARMS FROM CALL AND VERIFY IMS TCPIP IMSTOC    *\n*   OPERATION BY SUBMITTING IMS TRANSACTION \"WHOAMI\" AND RECEIVING  *\n*   RESPONSE                                                        *\n*                                                                   *\n*   DEFAULTS: IMSTOC - OTMAHWSD, PORT - 7010, HOST - BCSC01D        *\n*                                                                   *\n*   TO RUN AS A TSO CMD...CHKOTMA OTMAHWSD,7010(,PSWD=,DEBUG)       *\n*         YOU WILL BE PROMPTED FOR YOUR PASSWORD IF NO PSWD=        *\n*                                                                   *\n*   TO RUN AS A BATCH JOB...PARM='OTMAHWSD,7010,PSWD=(,DEBUG)       *\n*         YOU MUST SPECIFY YOUR PASSWORD WITH PSWD=                 *\n*                                                                   *\n*                                                                   *\n*   CREATED: DEC 98 BY R. HALL......THANKS TO DAN AND IMS LISTENER  *\n*                                                                   *\n*   MODIFIED:                                                       *\n*                                                                   *\n*                                                                   *\n*********************************************************************\n*\n*              THIS PGM CAN BE CALLED AS A TSO COMMAND, A BATCH JOB,\n*              OR FROM AN IMF EXEC\n*\n*              THIS PGM IS NOT RE-ENTRANT AND RUNS IN 31 BIT MODE\n*\n*        PARMS PASSED TO THIS PROGRAM AS AN IMF EXEC ARE:\n*\n*  OFFSET 0    1) A COUNT OF THE NUMBER OF PARAMETERS...ALWAYS 5\n*         4    2) A POINTER TO AN 8 BYTE FIELD OF THE EXEC NAME\n*         8    3) A POINTER TO A  4 BYTE FIELD OF THE BBI SS\n*        12    4) THE LTH OF THE  PARAMETER STRING\n*        16    5) A POINTER TO THE PARAMETER STRING\n*                 IT IS THE IMSTOC NAME, THE PORT, AND DEBUG\n*\n*        PARMS PASSED TO THIS PROGRAM AS A BATCH JOB ARE:\n*\n*  OFFSET 0    1) A POINTER TO THE PARAMETER STRING\n*                 IT IS THE IMSTOC NAME, THE PORT, AND \"DEBUG\"\n*                 IF IMSTOC IS RACF'D ALSO PSWD= FOR YOUR USERID\n*\n*        IF RUN AS A TSO CMD, THE 1ST WORD OF THE CPPL POINTS TO\n*        THE COMMAND AND PARMS. IT IS USED TO SIMULATE PARMS LIKE\n*        A BATCH JOB TO USE THE PARM PROCESSOR.\n*\n*\n*********************************************************************\n         TITLE '******* PROGRAM TO CHECK IMSTOC *****'\n         SPACE 3\n         ENTRY CHKOTMA            ESTABLISH ENTRY POINT\nCHKOTMA  CSECT\nCHKOTMA  AMODE 31\nCHKOTMA  RMODE 24\n         USING *,R15              SET TEMP BASE\n         B     AROUND             BRANCH AROUND DUMP TITLE\n         DC    AL1(EYELTH)        LTH OF EYE CATCHER\nEYECATCH DS    0C\n         DC    C'CHKOTMA  '       PROGRAM NAME\n         DC    C' VERSION 1.0 '   VERSION\n         DC    CL8'&SYSDATE'      DATE WRITTEN\n         DC    CL6'&SYSTIME'      TIME WRITTEN\n         DC    C'..CHECK IF OTMA  IS WORKING'  COMMENT\nEYELTH   EQU   *-EYECATCH         LTH OF EYE CATCHER\nAROUND   DS    0H\n*        LA    R1,0(0,R1)         CLEAR HI-ORDER BYTE FOR 31 BIT\n*        LA    R13,0(0,R13)       CLEAR HI-ORDER BYTE FOR 31 BIT\n         BSM   R14,0              SAVE CURRENT AMODE\n         STM   R14,R12,12(R13)\n         LR    R12,R15            SET 1ST BASE REG....R12\n         DROP  R15\n         USING CHKOTMA,R12,R9\n         SPACE 1\n         LA    R9,4095(0,R12)     SET 2ND BASE REG...R9\n         LA    R9,1(0,R9)         ''\n         SPACE 1\n         LR    R11,R1             R11 -> TO A(PARMS)\n         GETMAIN R,LV=LDYNAMIC,LOC=(RES,ANY)  GET CORE FOR WORK AREA\n         LR    R10,R1             R10 -> TO WORK AREA\n         USING WORK,R10           SET WORK BASE\n         LA    R4,SAVE            R4 -> TO SAVE AREA\n         ST    R13,SAVE+4         SAVE A(CALLERS SAVE AREA)\n         ST    R4,8(0,R13)        CHAIN OUR SAVE AREA\n         LR    R13,R4             R13 -> TO OUR SAVE AREA\n         SPACE 1\n*\n*        BECAUSE SOME OF THE TCP MODULES CAN BE ACCESSED IN 31\n*        BIT MODE PUT US INTO 31 BIT MODE ADDRESSING\n*\n*        CNOP  0,4                PUT ON FULLWORD BOUNDARY\n*        L     R1,*+8             GET 31 BIT MODE ADDRESS\n*        BSM   0,R1               GET INTO 31 BIT MODE\n*        DC    H'0'               ALIGN ON A FULLWORD BOUNDARY\n*        DC    X'80',AL3(*+3)     NEXT ADDRESS IS 31 BIT MODE\n*\n*********************************************************************\n*\n*        INIT  SOME STUFF IN THE  WORKAREA....\n*\n*********************************************************************\n         SPACE 1\n         MVI   WORKINIT,X'00'     CLEAR WORK AREA TO ZERO....\n         LA    R2,WORKINIT+1      R2 -> TO WHERE DATA GOES\n         LA    R3,LINIT-1         R3 = TOTAL LTH TO MOVE TO\n         LA    R4,WORKINIT        R4 -> TO WHERE DATA COMES FROM\n         LA    R5,1               R5 = TOTAL LTH TO MOVE FROM\n         SPACE 1\n         MVCL  R2,R4              SET UP NEW RECORD DEFAULTS\n*                IF NECESSARY, RELOAD R2 'CAUSE MVCL BUGGERS IT\n*        LA    R2,WRKAREA         R2 -> TO NEW RECORD\n         SPACE 1\n         MVC   SYSPRINT(PDCBLTH),PRINTDCB   INIT DCB...\n         MVC   DSOPEN(OPENLTH),OPENMAC    INIT OPEN MACRO CODE\n         MVC   DSCLOSE(CLOSLTH),CLOSMAC   INIT CLOSE MACRO CODE\n         MVC   TITLE_IMSTOC,=CL8'OTMAHWSD'    INIT IMSTOC\n         MVC   HOSTNAME(24),=CL24'BCSC01D' INIT HOSTNAME\n         MVC   TITLE_PORT,=CL4'7010'     INIT PORT\n*        LA    R8,7010            R8 = PORT 7010\n*        STH   R8,PORT            SET DEFAULT PORT\n         MVC   TITLE_DEBUG,=CL2'NO'   ASSUME WE DON'T DO DEBUG...\n         MVI   HOSTNAME_VALUE,C' '     INIT HOSTNAME_VALUE\n         MVC   HOSTNAME_VALUE+1(254),HOSTNAME_VALUE  ''\n         MVC   HOSTALIAS_VALUE,HOSTNAME_VALUE  INIT ALIAS...\n         MVC   RESERVED,HOSTNAME_VALUE  INIT RESERVED AREA\n         LA    R8,7               R8 = 7\n         ST    R8,NAMELEN         SET HOST NAME LTH\n         LA    R8,2               R8 = 2\n         STH   R8,FAMILY          SET FAMILY\n*\n*\n         LA    R6,0               ASSUME EVERYTHING WORKS\n         ST    R6,CPKECB          SET RETURN CODE\n*\n***********************************************************************\n*\n* RETRIEVE THE USERS RACF USERID AND GROUP FROM THE ACEE.             *\n*\n***********************************************************************\n*\nGETUSER  DS    0H\n         L     R8,PSAAOLD-PSA          LOAD ADDRESS OF CURRENT ASCB\n         L     R8,ASCBASXB-ASCB(R8)    LOAD ASXB ADDRESS\n         L     R8,ASXBSENV-ASXB(R8)    LOAD ACEE ADDRESS\n*                                      PUT USERID IN OTMA HEADER\n         MVC   IRM_RACF_USERID,ACEEUSRI-ACEE(R8)\n*                                      PUT GROUP IN OTMA HEADER\n         MVC   IRM_RACF_GRNAME,ACEEGRPN-ACEE(R8)\n*                                      PUT LTERM IN OTMA HEADER\n         MVC   IRM_LTERM,ACEETRID-ACEE(R8)\n*                                                                   RH\n         SPACE 1\n         L    R15,16               CVT POINTER\n         L    R15,0(R15)           TCB PTR PTR\n         L    R15,0(R15)           TCB POINTER\n         L     R15,180(0,R15)     R15 -> TO JSCB                    RH\n         L     R15,264(0,R15)     R15 -> TO TSO PSCB                RH\n         LTR   R15,R15            IS THERE A PSCB?                  RH\n         BP    BYPASSF            YES, IT'S A TSO TERMINAL          RH\n*        BZ    NOTTSO             NO, IT'S A BATCH JOB.             RH\n*\nSAYBATCH DS    0H\n         OI    BFLAG,X'80'        NO, SAY IT'S A BATCH JOB\n         B     NOTTSO             ON WE GO\n*\nBYPASSF  DS    0H\n*        L     R7,0(0,R11)        R7 -> AT 1ST PARM\n*        LA    R7,4(0,R7)         R7 -> WHERE CP NAME COULD BE\n*        CLC   =C'CHKOTMA',0(R7)  IS IT THERE?\n*        BE    CPCMD              YES, IT MUST BE A TSO CMD\n         TM    0(R11),X'80'       ONLY 1 PARM?\n         BO    SAYBATCH           YES, TREAT AS A BATCH JOB...\n         LA    R3,5               R3 = NBR PARMS FOR IMF\n         C     R3,0(0,R11)        1ST PARM = 5?\n         BE    SAYBATCH           YES, CALLED FROM IMF...\n*\nCPCMD    DS    0H\n         ST    R11,CPPLADDR         SAVE A(CPPL)\n         USING CPPL,R11           ADDRESS IT\n         SPACE 1\n         L     R3,=V(IOPLADD)     R3 -> TO IOPL\n         USING IOPL,R3            SET IOPL BASE\n         L     R4,CPPLUPT\n         ST    R4,IOPLUPT         SET UP IOPL\n         L     R4,CPPLECT\n         ST    R4,IOPLECT\n         L     R4,=V(ECB)\n         ST    R4,IOPLECB\n         SR    R4,R4\n         ST    R4,IOPLIOPB\n         DROP  R3                 DROP IOPL BASE....\n         SPACE 1\n         L     R11,0(0,R11)       R11 -> AT CP BUFFER\n         LH    R7,0(0,R11)        R7 = LTH OF BUFFER\n         LH    R6,2(0,R11)        R6 = OFFSET TO PARMS\n         SR    R7,R6              R7 = LTH OF PARMS\n         SH    R7,=H'4'           -4 FOR LLLL\n         LTR   R7,R7              ANY PARM?\n         BZ    ATTACHIT           NONE, USE DEFAULTS\n         LA    R6,4(R6,R11)       SET R6 FOR PARM ANALYSIS\n         SH    R6,=H'2'           SET R6 FOR PARM ANALYSIS\n         EX    R7,MAKEUPR         MAKE SURE PARMS ARE UPPER CASE    RH\n         B     PARM1              GO DO IT\nMAKEUPR  OC    2(0,R6),HOSTNAME_VALUE MAKE PARMS UPPER CASE         RH\n         SPACE 1\nNOTTSO   DS    0H\n*********************************************************************\n*\n*              SEE IF THERE IS A  PARM\n*\n*        PARMS PASSED TO THIS PROGRAM FROM IMF ARE:\n*  OFFSET 0    1) A COUNT OF THE NUMBER OF PARAMETERS...ALWAYS 5\n*         4    2) A POINTER TO AN 8 BYTE FIELD OF THE EXEC NAME\n*         8    3) A POINTER TO A  4 BYTE FIELD OF THE BBI SS\n*        12    4) THE LTH OF THE  PARAMETER STRING\n*        16    5) A POINTER TO THE PARAMETER STRING\n*                 IT IS THE IMSTOC NAME, THE PORT, AND DEBUG\n*\n*        PARMS PASSED TO THIS PROGRAM AS A BATCH JOB ARE:\n*\n*  OFFSET 0    1) A POINTER TO THE PARAMETER STRING\n*                 IT IS THE IMSTOC NAME, THE PORT, AND \"DEBUG\"\n*                 IF IMSTOC IS RACF'D ALSO PSWD= FOR YOUR USERID\n*\n*        IF RUN AS A TSO CMD, THE 1ST WORD OF THE CPPL POINTS TO\n*        THE COMMAND AND PARMS. IT IS USED TO SIMULATE PARMS LIKE\n*        A BATCH JOB TO USE THE PARM PROCESSOR.\n*\n*\n*********************************************************************\n         SPACE 1\n*              GET PARM, IF ANY\n         SPACE 1\n         LR    R6,R11             R6 -> TO PARMS\n         TM    0(R11),X'80'       ONLY 1 PARM?\n         BZ    PARM4              NO, MUST BE IMF CALL...\n*\n         L     R6,0(0,R11)        R6 -> TO PARMS\n         SR    R7,R7              CLEAR R7\n         ICM   R7,3,0(R6)         R7 = PARM LTH\n         BZ    ATTACHIT           NONE, USE DEFAULTS\n*\nPARM1    DS    0H\n         LA    R2,2(0,R6)         R2 -> TO OUR PARMS\n         LR    R4,R2              R4 -> TO IMSTOC NAME\n         B     PARM1B             GO PROCESS PARMS\n*\nPARM4    DS    0H\n         ICM   R7,15,12(R6)       R7 = PARM LTH\n         BZ    ATTACHIT           NONE, USE DEFAULTS\n*\n         L     R2,16(0,R6)        R2 -> TO OUR PARMS\n         L     R4,16(0,R6)        R4 -> TO IMSTOC NAME\n         SPACE 1\nPARM1B   DS    0H\n         CLI   0(R4),C','         AT END OF NAME?\n         BE    GOTPGM             YES, GO SET IT UP\n         CLI   0(R4),C' '         AT END OF NAME FOR TSO CMD?\n         BE    GOTPGM             YES, GO SET IT UP\n         LA    R4,1(0,R4)         R4 -> TO NEXT KEY BYTE, IF ANY\n         BCT   R7,PARM1B          CHECK NEXT BYTE\n         SPACE 1\nGOTPGM   DS    0H\n         LR    R8,R4              R8 -> AT COMMA\n         SR    R8,R2              R8 = LTH OF PGM NAME\n         CH    R8,=H'8'           TOO LONG?\n         BNH   GOTPGM2            NO\n         LA    R8,8               YES, USE 1ST 8 BYTES...\n         SPACE 1\nGOTPGM2  DS    0H\n         BCTR  R8,0               R8 = HEX LTH\n         EX    R8,SETNAME         SET UP ATTACH NAME\n         SPACE 1\n         CH    R7,=H'1'           ANY MORE PARM?\n         BL    ATTACHIT           NO, GO DO ATTACH\n         SPACE 1\n         BCTR  R7,0               -1 FOR COMMA...\n         LA    R4,1(0,R4)         R4 -> TO NEXT PARM\n         LR    R2,R4              R2 -> AT NEXT PARM...PORT #..\n         SPACE 1\nPARM2B   DS    0H\n         CLI   0(R4),C','         AT END OF PORT\n         BE    GOTPORT            YES, GO SET IT UP\n         CLI   0(R4),C' '         AT END OF PORT FOR TSO CMD?\n         BE    GOTPORT            YES, GO SET IT UP\n         LA    R4,1(0,R4)         R4 -> TO NEXT KEY BYTE, IF ANY\n         BCT   R7,PARM2B          CHECK NEXT BYTE\n         SPACE 1\nGOTPORT  DS    0H\n         LR    R8,R4              R8 -> AT COMMA\n         SR    R8,R2              R8 = LTH OF PORT NAME\n         CH    R8,=H'4'           TOO LONG?\n         BNH   GOTPORT2           NO\n         LA    R8,4               YES, USE 1ST 4 BYTES...\n         SPACE 1\nGOTPORT2 DS    0H\n         BCTR  R8,0               R8 = HEX LTH\n         EX    R8,SETPORT         SET UP PORT NUMBER\n         SPACE 1\n         CH    R7,=H'1'           ANY MORE PARM?\n         BL    ATTACHIT           NO, GO DO ATTACH\n         LA    R4,1(0,R4)         R4 -> TO NEXT PARM\n         LR    R2,R4              R2 -> AT NEXT PARM\n         SPACE 1\nCHKPSWD  DS    0H\n         CLC   =C'PSWD=',0(R4)    IS IT THE 'PSWD=' PARM?\n         BNE   PARM5              NO, CHECK FOR NEXT PARM\n         SPACE 1\n         LA    R4,5(0,R4)         R4 -> TO PSWD= PARM, IF ANY\n         SH    R7,=H'5'           R7 = LTH OF REST OF PARM\n         SPACE 1\n         LA    R15,IRM_RACF_PW    R15 -> TO PSWD SAVE AREA\n         MVC   0(8,R15),=CL8' '   CLEAR OUT DEFAULT\n         SPACE 1\nPARM3    DS    0H\n         MVC   0(1,R15),0(R4)     SAVE PSWD BYTE\n         LA    R15,1(0,R15)       R15 -> TO NEXT SAVE BYTE\n         LA    R4,1(0,R4)         R4 -> TO NEXT KEY BYTE, IF ANY\n         BCTR  R7,0               R2 = LTH OF REST OF PARM\n         CLI   0(R4),C','         AT END OF PSWD?\n         BE    NEXTPARM           YES, GO GET NEXT PARM\n         CLI   0(R4),C' '         AT END OF PSWD FOR TSO CMD?\n         BE    NEXTPARM           YES, GO GET NEXT PARM\n         LTR   R7,R7              ANY MORE PARM?\n         BP    PARM3              YES, GO CHECK IT\n*        B     NEXTPARM           GO CHECK FOR ANOTHER PARM\n         SPACE 1\nPARM5    DS    0H\nNEXTPARM DS    0H\n         SPACE 1\n         MVC   TITLE_DEBUG,=CL2'  '   CAN ONLY BE DEBUG...\n         SPACE 1\nATTACHIT DS    0H\n         CLI   IRM_RACF_PW,C' '   IS THERE A PSWD ?\n         BNE   PSWDOK             YES.\n         TM    BFLAG,X'80'        IS IT A BATCH JOB ?\n         BO    PSWDOK             YES, CAN'T PROMPT FOR PASSWORD\n         SPACE 1\n*                                                                   RH\n*              ASK FOR PASSWORD                                     RH\n*                                                                   RH\nREADPSWD DS    0H                                                   RH\n         MVC   USERID,IRM_RACF_USERID MOVE USRID TO MSG\n*\nPSWRD_01 DS    0H\nPSWRD_02 DS    0H\n         LA    R0,1               NBR MSGS TO SEND\n         LA    R1,GETPSWD         R1 -> TO MSG TO SEND\n         LA    R2,0\n*\n*              PROMPT FOR AND READ A PARAMETER\n*\nPSWRD_03 DS    0H\n         STM   R0,R2,MSG_ADDR\n        PUTGET MF=(E,IOPLADD),                                         X\n               OUTPUT=(,,PTBYPS),                                      X\n               PARM=MSG_PGPB\n         SPACE 1\n         LTR   R15,R15            WAS PUTGET OKAY?\n         BNZ   PSWDOK             NO, IGNORE IT AND GET RACF'D\n*\nPARSPASS DS    0H\n*              SET-UP TO PARSE THE RESPONSE\n*\n         L     R1,MSG_PGPB+PGPBIBUF-PGPB\n         LA    R15,3(,R1)\n         LA    R0,1\n         AH    R1,0(,R1)\n*\n*              LOCATE THE FIRST NON-BLANK CHARACTER\n*\n         CLI   1(R15),C' '\n         BXH   R15,R0,PSWRD_02\n         BE    *-8\n*\n*              CALCULATE THE LENGTH REMAINING TO BE PARSED\n*\n         LR    R14,R1\n         SR    R14,R15\n         BZ    PSWRD_01\n         BCTR  R14,0\n         AGO   .ENDPARS           END OF PARSING FOR NOW....\n*\n*              LOCATE THE DELIMINATING CHARACTER\n*\n         LA    R2,4\n*        EX    R14,TRTINSTR\n         B     *(R2)\n         B     PSWRD_04                 04 - BLANK\n*        BC    0,*                      08 - INVALID\n*\n*\n         L     R1,MSG_PGPB+PGPBIBUF-PGPB\n         AH    R1,0(,R1)\n         B     PSWRD_01\n*\n*RTINSTR TRT   0(*-*,R15),$TRTABLE\n*\n*              CALCULATE & SAVE THE LENGTH OF THE PARSED PARAMETER\n.ENDPARS ANOP\n*\nPSWRD_04 SR    R1,R15\n         STC   R1,PASSWORD\n*\n*              VALIDATE THE LENGTH OF THE PARSED PARAMETER\n*\n         CLI   PASSWORD,8\n         BH    PSWRD_01\n*\n*              INITIALIZE THE PASSWORD OPERAND\n*\n         MVI   PASSWORD+1,C' '\n         MVC   PASSWORD+1(7),PASSWORD+1\n         SPACE 1\n         LA    R14,PASSWORD+1\n         BCTR  R1,0\n         EX    R1,OC_INSTR\n*        OC    RACPSWD(8),OLDNAME MAKE SURE ANSWER IS UPPER CASE    RH\n*\n*              SET UP THE PASSWORD FOR IMSTOC\n*\n         MVC   IRM_RACF_PW,PASSWORD+1 SET UP PSWD FOR TOC\n         B     PSWDOK\n*\nOC_INSTR OC    0(*-*,R14),0(R15)\n*\n         SPACE 1                                                    RH\nPSWDOK   DS    0H\n\n*   /*****************************************************************/\n*   /*                                                               */\n*   /* END OF PARM ANALYSIS...                                       */\n*   /*                                                               */\n*   /*****************************************************************/\n*\n         AGO   .NOLOAD\n*\n*              USE THE FOLLOWING  CODE TO DYNAMICALLY LOAD\n*              THE REQUIRED MODULES\n*\n*              LOAD EZASOKET AND EZACIC08 IF NOT ALREADY LOADED\n*\n         LA    R4,EZASOKET        R4 -> TO MODULE NAME\n         LOAD  EPLOC=((R4))       LOAD PGM...\n         LTR   R15,R15            DID IT LOAD?\n         BNZ   NOMORE             NO.\n         ST    R0,SOKETAD         SAVE ITS ENTRY ADDRESS\n*\n         LA    R4,EZACIC08        R4 -> TO MODULE NAME\n         LOAD  EPLOC=((R4))       LOAD PGM...\n         LTR   R15,R15            DID IT LOAD?\n         BNZ   NOMORE             NO.\n         ST    R0,CIC08AD         SAVE ITS ENTRY ADDRESS\n*\n         SPACE 1\n.NOLOAD  ANOP\n         SPACE 1\n         LA    R2,PRINTDCB        R2 -> TO SYSPRINT DCB\n*        LA    R2,SYSPRINT        R2 -> TO SYSPRINT DCB\n*                                 OPEN IT FOR OUTPUT\n         OPEN  ((R2),(OUTPUT)),MODE=24,MF=(E,DSOPEN)\n         TM    48(R2),X'10'       DID SYSPRINT DATASET OPEN         RH\n         BNO   NOSYSOUT           NO, CAN'T PRINT INFO MSG THEN     RH\n         MVC   LINE1,HEADINFO     PRINT INFO MSG                    RH\n         BAL   R8,PRINT2               ''                           RH\n         MVI   LINE1,C'-'         PUT CARRIAGE CTL BACK             RH\n         SPACE 1                                                    RH\nNOSYSOUT DS    0H                                                   RH\n\n*/*******************************************************************/\n*/* INITIALIZE SCREEN OUTPUT                                        */\n*/*******************************************************************/\n\n         MVC   TCPNAME,=CL8'TCPIP '\n         MVC   ADSNAME,TITLE_IMSTOC\n         PACK  DWORD,TITLE_PORT   CONVERT PORT NBR TO PACKED\n         CVB   R8,DWORD           CONVERT PORT NBR TO HEX\n         STH   R8,PORT            SAVE IT FOR TESTING\n         MVC   HOSTNAME(8),=CL8'BCSC01A'\n         CLC   =CL8'OTMAHWSA',ADSNAME    IS IMSTOC OTMAHWSA?\n         BE    HOSTSET                  YES, HOSTNAME IS SET\n         MVC   HOSTNAME(24),=CL24'BCSC01D.GOV.BC.CA'\n*        MVC   HOSTNAME(8),=CL8'BCSC01D'\n*        B     HOSTSET            BETTER BE ON BCSC01D THEN...\n*\n*        CLC   =CL8'IMSTLN1',ADSNAME    IS IMSTOC IMSTLN1?\n*        BE    HOSTSET                  YES, HOSTNAME IS SET\n*        MVC   HOSTNAME(8),=CL8'BCSC01D'\n*        CLC   =CL8'IMSDLN1',ADSNAME    IS IMSTOC IMSDLN1?\n*        BE    HOSTSET                  YES, HOSTNAME IS SET\n*        MVC   HOSTNAME(8),=CL8'BCSC01D'\n*        CLC   =CL8'IMSELN1',ADSNAME    IS IMSTOC IMSELN1?\n*        BNE   NOMORE                   NO, TOO BAD...\n*\nHOSTSET  DS    0H\n         CLI   TITLE_DEBUG,C' '   PRINT DEBUG INFO?\n         BNE   NODB1              NO\n         MVC   LINE1(DB1LTH),DB1  PRINT INFO MSG                    RH\n         MVC   LINE1+(DB1NAME-DB1)(8),ADSNAME\n         MVC   LINE1+(DB1PORT-DB1)(4),TITLE_PORT\n         MVC   LINE1+(DB1HOST-DB1)(24),HOSTNAME\n         BAL   R8,PRINT2          PRINT MSG                         RH\n*\nNODB1    DS    0H\n*\n*        USE THE DATE/TIME TO MAKE A UNIQUE SUBTASK ID....\n*\n*/*       SVC INVOCATIONS                                            */\n*/*         THE TIME OF DAY IS RETURNED IN R0 FOR DEC, BIN, AND      */\n*/*         TU. FOR MIC AND STCK, THE TIME OF DAY IS RETURNED        */\n*/*         IN THE SPECIFIED ADDRESS.                                */\n*/*         THE DATE IS RETURNED IN R1 AS PACKED DECIMAL IN THE      */\n*/*         FORM CCYYDDDF, WHERE:                                    */\n*/*              CC  - IS THE CENTURY                                */\n*/*              YY  - IS THE LAST TWO DIGITS OF THE YEAR            */\n*/*              DDD - IS THE DAY OF THE YEAR                        */\n*/*              F   - ALLOWS FOR UNPACKING                          */\n*/*                                                                  */\n*/*       PC INVOCATIONS                                             */\n*/*         THE TIME OF DAY IS RETURNED TO THE FIRST TWO WORDS OF    */\n*/*         A USER SPECIFIED FOURWORD AREA.  THE DATE IS RETURNED    */\n*/*         TO THE THIRD WORD IN DECIMAL FORMAT (NOT PACKED DECIMAL) */\n*/*         IN THE FORMS GIVEN BELOW.                                */\n*\n*\nTOD3     DS    0H                                                   RH\n         TIME  DEC,SAVETIME,            GET THE SYS TIME            Y2 +\n               LINKAGE=SYSTEM,DATETYPE=YYYYMMDD,    IN THIS CASE    Y2 +\n               MF=(E,TIMED)\n         XC    DWORD(8),DWORD           CLEAR DWORD                 Y2\n         UNPK  DWORD(9),SAVETIME+8(5)      MAKE IT DECIMAL          Y2\n         MVC   SUBTASK(8),DWORD         SET UP FOR EZASOKET\n*\n*/*******************************************************************/\n*/* ESTABLISH TCP/IP WITH OTMAHWS?                                  */\n*/*******************************************************************/\n*\n*CHECK_IMSTOC: PROC;\n*\n*       PUT FILE (SYSPRINT)\n*                EDIT ('TESTING IMSTOC ',ADSNAME,', PORT=',\n*                       PORT,', HOSTNAME=',HOSTNAME)\n*              (SKIP(1), A, A, A, F(4), A, A) ;\n*\n         MVC   LINE1(MSG1LTH),MSG1 PRINT INFO MSG                    RH\n         MVC   LINE1+(MS1NAME-MSG1)(8),ADSNAME\n         MVC   LINE1+(MS1PORT-MSG1)(4),TITLE_PORT\n         MVC   LINE1+(MS1HOST-MSG1)(24),HOSTNAME\n         BAL   R8,PRINT2          PRINT MSG                         RH\n*\n         L     R15,SOKETAD        R15 -> TO EZASOKET ROUTINE\n         LA    R1,CALLD           R1 -> TO CALL LIST\n*                                 CALL IT\n         CALL  (15),                                                   +\n               (INITAPI,MAXSOC,IDENT,SUBTASK,MAXSNO,ERRNO,RETCODE),VL, +\n               MF=(E,(R1))\n*\n         ICM   R15,15,RETCODE     R15 = RETURN CODE\n         BZ    INITOK             IT'S ZERO...OKAY...\n*\n         LA    R15,16             SET BAD RETURN CODE\n         ST    R15,CPKECB         ''\n         MVC   LINE1(L'BADINIT),BADINIT PRINT INFO MSG              RH\n         LA    R14,LINE1+(INITRC-BADINIT)\n         BAL   R8,DECRC           CONVERT RC TO DECIMAL             RH\n         BAL   R8,PRINT2          PRINT MSG                         RH\n         B     NOMORE             END FOR NOW\n*\n**********************************************************************\n*\n*              CONVERT RETCODE AND ERRNO TO DECIMAL\n*\n**********************************************************************\n*\n*              CONVERT RETCODE TO DISPLAY\n*\nDECRC    DS    0H\n         MVC   0(10,R14),=C'RETCODE = '  PUT ERR ID IN MSG\n         LA    R14,10(0,R14)      R14 -> TO NBR GOES\n         UNPK  WORKERR(9),RETCODE(5)\n         MVI   WORKERR+8,X'EF'  TRANSLATES TO BLANK\n         TR    WORKERR(9),TRTAB-239 TRANS TO DISPLAY\n         LA    R15,WORKERR        R15 -> AT ERROR CODE\n         LA    R1,8               R1 = MAX CHARS TO CHECK\n*\nDEC10    DS    0H\n         CLI   0(R15),C'0'        LEADING 0?\n         BNE   DEC11              NO\n         MVI   0(R15),C' '        YES, BLANK IT OUT\n*\nDEC11    DS    0H\n         CLI   0(R15),C' '        LEADING BLANK?\n         BNE   DEC20              NO\n         LA    R15,1(0,R15)       R15 -> AT NEXT BYTE\n         BCT   R1,DEC10           GO CHECK IT\n         MVI   0(R15),C'0'        ALL BLANK, SO RC=0...\n*\nDEC20    DS    0H\n         CH    R1,=H'1'           MORE THAN 1 CHAR?\n         BL    DEC21              NO, DON'T SUBTRACT 1\n         BCTR  R1,0               R1 = HEX LTH TO MOVE\n*\nDEC21    DS    0H\n         EX    R1,MVCRC1          PUT RC IN MSG\n         LA    R14,1(R1,R14)      R14 -. WHERE ( GOES...\n         CLI   0(R15),C'F'        FIRST CHAR F?\n         BNE   DEC22              NO, ON WE GO\n         MVC   0(3,R14),=C'(<1'   PUT IN (<1\n         LA    R14,3(0,R14)       R14 -> WHERE ) GOES...\n         BE    DEC42              YES, NO DECIMAL NBR....\n*\nDEC22    DS    0H\n         MVI   0(R14),C'('        PUT IN (\n         LA    R14,1(0,R14)       R14 -> WHERE DECIMAL GOES...\n         L     R15,RETCODE        R15 = ERROR CODE\n         CVD   R15,DWORD          CONVERT RC TO DECIMAL\n         MVC   WORKERR(6),EDPATN  PUT EDIT PATTERN IN MSG\n         ED    WORKERR(6),DWORD+5 CONVERT TO DISPLAY\n         LA    R15,WORKERR        R15 -> AT ERROR CODE\n         LA    R1,6               R1 = MAX CHARS TO CHECK\n*\nDEC30    DS    0H\n         CLI   0(R15),C'0'        LEADING 0?\n         BNE   DEC31              NO\n         MVI   0(R15),C' '        YES, BLANK IT OUT\n*\nDEC31    DS    0H\n         CLI   0(R15),C' '        LEADING BLANK?\n         BNE   DEC40              NO\n         LA    R15,1(0,R15)       R15 -> AT NEXT BYTE\n         BCT   R1,DEC30           GO CHECK IT\n         MVI   0(R15),C'0'        ALL BLANK, SO RC=0...\n*\nDEC40    DS    0H\n         CH    R1,=H'1'           MORE THAN 1 CHAR?\n         BL    DEC41              NO, DON'T SUBTRACT 1\n         BCTR  R1,0               R1 = HEX LTH TO MOVE\n*\nDEC41    DS    0H\n         EX    R1,MVCRC1          PUT RC IN MSG\n         LA    R14,1(R1,R14)      R14 -> WHERE ) GOES...\n*\nDEC42    DS    0H\n         MVC   0(3,R14),=C'), '   PUT IN )\n*\nDEC43    DS    0H\n         LA    R14,3(0,R14)       R14 -> WHERE ERRNO GOES...\n*\n*              CONVERT ERRNO TO DISPLAY\n*\nDEC50    DS    0H\n         MVC   0(8,R14),=C'ERRNO = '  PUT ERR ID IN MSG\n         LA    R14,8(0,R14)       R14 -> TO NBR GOES\n         UNPK  WORKERR(9),ERRNO(5)\n         MVI   WORKERR+8,X'EF'  TRANSLATES TO BLANK\n         TR    WORKERR(9),TRTAB-239 TRANS TO DISPLAY\n         LA    R15,WORKERR        R15 -> AT ERROR CODE\n         LA    R1,8               R1 = MAX CHARS TO CHECK\n*\nDEC60    DS    0H\n         CLI   0(R15),C'0'        LEADING 0?\n         BNE   DEC61              NO\n         MVI   0(R15),C' '        YES, BLANK IT OUT\n*\nDEC61    DS    0H\n         CLI   0(R15),C' '        LEADING BLANK?\n         BNE   DEC70              NO\n         LA    R15,1(0,R15)       R15 -> AT NEXT BYTE\n         BCT   R1,DEC60           GO CHECK IT\n         MVI   0(R15),C'0'        ALL BLANK, SO RC=0...\n*\nDEC70    DS    0H\n         CH    R1,=H'1'           MORE THAN 1 CHAR?\n         BL    DEC71              NO, DON'T SUBTRACT 1\n         BCTR  R1,0               R1 = HEX LTH TO MOVE\n*\nDEC71    DS    0H\n         EX    R1,MVCRC1          PUT RC IN MSG\n         LA    R14,1(R1,R14)      R14 -. WHERE ( GOES...\n*\nDEC72    DS    0H\n         MVI   0(R14),C'('        PUT IN (\n         LA    R14,1(0,R14)       R14 -> WHERE DECIMAL GOES...\n         L     R15,ERRNO          R15 = ERROR CODE\n         CVD   R15,DWORD          CONVERT RC TO DECIMAL\n         MVC   WORKERR(6),EDPATN  PUT EDIT PATTERN IN MSG\n         ED    WORKERR(6),DWORD+5 CONVERT TO DISPLAY\n         LA    R15,WORKERR        R15 -> AT ERROR CODE\n         LA    R1,6               R1 = MAX CHARS TO CHECK\n*\nDEC73    DS    0H\n         CLI   0(R15),C'0'        LEADING 0?\n         BNE   DEC74              NO\n         MVI   0(R15),C' '        YES, BLANK IT OUT\n*\nDEC74    DS    0H\n         CLI   0(R15),C' '        LEADING BLANK?\n         BNE   DEC80              NO\n         LA    R15,1(0,R15)       R15 -> AT NEXT BYTE\n         BCT   R1,DEC73           GO CHECK IT\n         MVI   0(R15),C'0'        ALL BLANK, SO RC=0...\n*\nDEC80    DS    0H\n         CH    R1,=H'1'           MORE THAN 1 CHAR?\n         BL    DEC81              NO, DON'T SUBTRACT 1\n         BCTR  R1,0               R1 = HEX LTH TO MOVE\n*\nDEC81    DS    0H\n         EX    R1,MVCRC1          PUT RC IN MSG\n         LA    R14,1(R1,R14)      R14 -> WHERE ) GOES...\n*\n         MVI   0(R14),C')'        PUT IN )\n*\nDEC90    DS    0H\n         BR    R8                 RETURN TO CALLER\n*\nEDPATN   DC    X'402020202120'\nMVCRC1   MVC   0(0,R14),0(R15)    PUT RC IN MSG\n*\nINITOK   DS    0H\n*\n*   CALL EZASOKET('SOCKET          ',\n*                 TWO,             /* I/P PARMS        */\n*                 ONE,\n*                 ZERO,\n*                 ERRNO,\n*                 RETCODE);\n*\n         L     R15,SOKETAD        R15 -> TO EZASOKET ROUTINE\n         LA    R1,CALLD           R1 -> TO CALL LIST\n*                                 CALL IT\n         CALL  (15),                                                   +\n               (SOCKET,TWO,ONE,ZERO,ERRNO,RETCODE),VL,                 +\n               MF=(E,(R1))\n*\n         ICM   R15,15,RETCODE     R15 = RETURN CODE\n         BNM   SOCKOK             IT'S ZERO OR GREATER...OKAY...\n*\n         LA    R15,16             SET BAD RETURN CODE\n         ST    R15,CPKECB         ''\n         MVC   LINE1(L'BADSOCK),BADSOCK PRINT INFO MSG              RH\n         LA    R14,LINE1+(SOCKRC-BADSOCK)\n         BAL   R8,DECRC           CONVERT RC TO DECIMAL             RH\n         BAL   R8,PRINT2          PRINT MSG                         RH\n         B     CALLCLOS           END FOR NOW\n*\nSOCKOK   DS    0H\n         STH   R15,SOCDESC        SAVE IT FOR LATER\n*\n*   SOCDESC = RETCODE;\n*\n*   IF TITLE_DEBUG   = '  ' THEN  DO ;   /* IF FLAG IS BLANK,       */\n*      PUT FILE (SYSPRINT) SKIP(1)\n*          EDIT ('SOCKET SUCCESSFUL.  RETCODE=',RETCODE)\n*             (SKIP(1), A, F(3)) ;\n*      PUT SKIP(1) DATA (SOCDESC) ;\n*   END ;\n         CLI   TITLE_DEBUG,C' '   PRINT DEBUG INFO?\n         BNE   NODB2              NO\n         MVC   LINE1(24),=CL24'-SOCKET CALL SUCCESSFUL.'            RH\n         BAL   R8,PRINT2          PRINT MSG                         RH\n*\nNODB2    DS    0H\n*\n*   CALL EZASOKET('GETHOSTBYNAME   ',\n*                  NAMELEN,\n*                  HOSTNAME,\n*                  HOSTENT,\n*                  RETCODE);\n*\n         L     R15,SOKETAD        R15 -> TO EZASOKET ROUTINE\n         LA    R1,CALLD           R1 -> TO CALL LIST\n*                                 CALL IT\n         CALL  (15),                                                   +\n               (GETHOST,NAMELEN,HOSTNAME,HOSTENT,RETCODE),VL,          +\n               MF=(E,(R1))\n*\n         ICM   R15,15,RETCODE     R15 = RETURN CODE\n         BZ    HOSTOK             IT'S ZERO...OKAY...\n*\n         LA    R15,16             SET BAD RETURN CODE\n         ST    R15,CPKECB         ''\n         MVC   ERRNO,HOSTENT      ERROR IS IN HOSTENT???            RH\n         MVC   LINE1(L'BADHOST),BADHOST SET UP ERROR MSG            RH\n         LA    R14,LINE1+(HOSTRC-BADHOST)\n         BAL   R8,DECRC           CONVERT RC TO DECIMAL             RH\n         BAL   R8,PRINT2          PRINT MSG                         RH\n         B     CALLCLOS           END FOR NOW\n*\nHOSTOK   DS    0H\n*   IF TITLE_DEBUG   = '  ' THEN  DO ;   /* IF FLAG IS BLANK,       */\n*      PUT FILE (SYSPRINT)\n*          EDIT ('GETHOSTBYNAME SUCESSFUL')\n*             (SKIP(2), A);\n*   END ;\n         CLI   TITLE_DEBUG,C' '   PRINT DEBUG INFO?\n         BNE   NODB3              NO\n         MVC   LINE1(26),=CL26'-GETHOSTBYNAME SUCCESSFUL.'\n         BAL   R8,PRINT2          PRINT MSG\n*\nNODB3    DS    0H\n*\n*     CALL EZACIC08(HOSTENT,\n*                    HOSTNAME_LENGTH,\n*                    HOSTNAME_VALUE,\n*                    HOSTALIAS_COUNT,\n*                    HOSTALIAS_SEQ,\n*                    HOSTALIAS_LENGTH,\n*                    HOSTALIAS_VALUE,\n*                    HOSTADDR_TYPE,\n*                    HOSTADDR_LENGTH,\n*                    HOSTADDR_COUNT,\n*                    HOSTADDR_SEQ,\n*                    HOSTADDR_VALUE,\n*                    RETCODE);\n*\n         L     R15,CIC08AD        R15 -> TO EZACIC08 ROUTINE\n         LA    R1,CALLD           R1 -> TO CALL LIST\n*                                 CALL IT\n         CALL  (15),                                                   +\n               (HOSTENT,                                               +\n               HOSTNAME_LENGTH,                                        +\n               HOSTNAME_VALUE,                                         +\n               HOSTALIAS_COUNT,                                        +\n               HOSTALIAS_SEQ,                                          +\n               HOSTALIAS_LENGTH,                                       +\n               HOSTALIAS_VALUE,                                        +\n               HOSTADDR_TYPE,                                          +\n               HOSTADDR_LENGTH,                                        +\n               HOSTADDR_COUNT,                                         +\n               HOSTADDR_SEQ,                                           +\n               HOSTADDR_VALUE,                                         +\n               RETCODE),VL,                                            +\n               MF=(E,(R1))\n*\n         ICM   R15,15,RETCODE     R15 = RETURN CODE\n         BZ    HOSTOK3            IT'S ZERO...OKAY...\n*\n         LA    R15,16             SET BAD RETURN CODE\n         ST    R15,CPKECB         ''\n         MVC   LINE1(L'BADHOSTE),BADHOSTE SET UP ERROR MSG          RH\n         LA    R14,LINE1+(HOSTRCE-BADHOSTE)\n         BAL   R8,DECRC           CONVERT RC TO DECIMAL             RH\n         BAL   R8,PRINT2          PRINT MSG                         RH\n         B     CALLCLOS           END FOR NOW\n*\nHOSTOK3  DS    0H\n         CLC   HOSTALIAS_COUNT,=H'1'   MORE THAN 1 ALIAS?\n         BH    NODB3              YES, GO GET THEM ALL\n         CLC   HOSTADDR_COUNT,=H'1' MORE THAN 1 HOST?\n         BH    NODB3              YES, GO GET THEM ALL\n*\n         L     R15,HOSTADDR_VALUE R15 = HOST ADDRESS\n         ST    R15,SERVIADD       SAVE IT FOR NEXT CALL\n*\n*   IF TITLE_DEBUG   = '  ' THEN  DO ;   /* IF FLAG IS BLANK,       */\n*     PUT FILE (SYSPRINT) LIST ('EZACIC08 CALL:') SKIP(2);\n*     PUT FILE (SYSPRINT) LIST(HOSTENT,\n*                     HOSTNAME_LENGTH,\n*                     HOSTNAME_VALUE,\n*                     HOSTALIAS_COUNT,\n*                     HOSTALIAS_SEQ,\n*                     HOSTALIAS_LENGTH,\n*                     HOSTALIAS_VALUE,\n*                     HOSTADDR_TYPE,\n*                     HOSTADDR_LENGTH,\n*                     HOSTADDR_COUNT,\n*                     HOSTADDR_SEQ,\n*                     HOSTADDR_VALUE,\n*                     RETCODE);\n*   END ;\n*\n         CLI   TITLE_DEBUG,C' '   PRINT DEBUG INFO?\n         BNE   NODB3A             NO\n         MVC   LINE1(21),=CL21'-EZACIC08 SUCCESSFUL.'\n         MVC   LINE1+21(14),=CL14' HOST ADDRESS='\n         LA    R14,LINE1+35\n         UNPK  0(9,R14),HOSTADDR_VALUE(5)\n         MVI   8(R14),X'EF'  TRANSLATES TO BLANK\n         TR    0(9,R14),TRTAB-239 TRANS TO DISPLAY\n         BAL   R8,PRINT2          PRINT MSG                         RH\n*\nNODB3A   DS    0H\n*\n*   NAME.SERVIADD = HOSTADDR_VALUE;\n*\n*   CALL EZASOKET('CONNECT         ',\n*                 SOCDESC,          /* I/P PARMS        */\n*                 NAME,\n*                 ERRNO,\n*                 RETCODE);\n*\n         L     R15,SOKETAD        R15 -> TO EZASOKET ROUTINE\n         LA    R1,CALLD           R1 -> TO CALL LIST\n*                                 CALL IT\n         CALL  (15),                                                   +\n               (CONNECT,SOCDESC,NAME,ERRNO,RETCODE),VL,                +\n               MF=(E,(R1))\n*\n         ICM   R15,15,RETCODE     R15 = RETURN CODE\n         BZ    CONNOK             IT'S ZERO...OKAY...\n*\n         LA    R15,16             SET BAD RETURN CODE\n         ST    R15,CPKECB         ''\n         MVC   LINE1(L'BADCONN),BADCONN SET UP ERROR MSG            RH\n         LA    R14,LINE1+(CONNRC-BADCONN)\n         BAL   R8,DECRC           CONVERT RC TO DECIMAL             RH\n         BAL   R8,PRINT2          PRINT MSG                         RH\n         B     CALLCLOS           END FOR NOW\n*\nCONNOK   DS    0H\n*\n*   IF TITLE_DEBUG   = '  ' THEN  DO ;   /* IF FLAG IS BLANK,       */\n*      PUT FILE (SYSPRINT) LIST ('CONNECT SUCCESSFUL') SKIP(2);\n*      PUT FILE (SYSPRINT)\n*          EDIT ('   SOCDESC=',SOCDESC,' BUFFLEN=',BUFFLEN)\n*             (SKIP(1), A, F(3), A, F(3)) ;\n*      PUT DATA(TRM) SKIP(1) ;\n*   END ;\n*\n         CLI   TITLE_DEBUG,C' '   PRINT DEBUG INFO?\n         BNE   NODB4              NO\n         MVC   LINE1(20),=CL20'-CONNECT SUCCESSFUL.'\n         BAL   R8,PRINT2          PRINT MSG                         RH\n         MVC   LINE1(11),=CL11'   SOCDESC='\n         LA    R14,LINE1+11\n         UNPK  0(5,R14),SOCDESC(3)\n         MVI   4(R14),X'EF'  TRANSLATES TO BLANK\n         TR    0(5,R14),TRTAB-239 TRANS TO DISPLAY\n         MVC   LINE1+16(10),=CL10' BUFFLEN='\n         UNPK  LINE1+26(9),BUFFLEN(5)\n         MVI   LINE1+34,X'EF'  TRANSLATES TO BLANK\n         TR    LINE1+26(9),TRTAB-239 TRANS TO DISPLAY\n         BAL   R8,PRINT2          PRINT MSG                         RH\n*\nNODB4    DS    0H\n*\n*   CALL EZASOKET('WRITE           ',\n*                 SOCDESC,          /* I/P PARMS        */\n*                 BUFFLEN,\n*                 HWSDATA,\n*                 ERRNO,\n*                 RETCODE);\n*\n*        LA    R15,IROLTH         SET BUFFER LENGTH\n*        LA    R15,256            SET BUFFER LENGTH\n*        LA    R15,HWSDATAL       SET BUFFER LENGTH\n         LA    R15,INBUFL         SET BUFFER LENGTH\n         ST    R15,BUFFLEN        SAVE IT\n         L     R15,SOKETAD        R15 -> TO EZASOKET ROUTINE\n         LA    R1,CALLD           R1 -> TO CALL LIST\n*                                 CALL IT\n         CALL  (15),                                                   +\n               (WRITE,SOCDESC,BUFFLEN,HWSDATA,ERRNO,RETCODE),VL,       +\n               MF=(E,(R1))\n*\n         ICM   R15,15,RETCODE     R15 = RETURN CODE\n         BNM   WRIT1OK            IT'S ZERO...OKAY...\n*\n         LA    R15,16             SET BAD RETURN CODE\n         ST    R15,CPKECB         ''\n         MVC   LINE1(L'BADWRIT1),BADWRIT1 SET UP ERROR MSG          RH\n         LA    R14,LINE1+(WRIT1RC-BADWRIT1)\n         BAL   R8,DECRC           CONVERT RC TO DECIMAL             RH\n         BAL   R8,PRINT2          PRINT MSG                         RH\n         B     CALLCLOS           END FOR NOW\n*\nWRIT1OK  DS    0H\n*\n*   IF TITLE_DEBUG   = '  ' THEN  DO ;   /* IF FLAG IS BLANK,       */\n*      PUT FILE (SYSPRINT) LIST ('WRITE1 SUCCESSFUL') SKIP(2);\n*   END ;\n*\n         CLI   TITLE_DEBUG,C' '   PRINT DEBUG INFO?\n         BNE   NODB5              NO\n         MVC   LINE1(20),=CL20'-WRITE1 SUCCESSFUL. '\n         BAL   R8,PRINT2          PRINT MSG                         RH\n         LA    R14,LINE1+20       R14 -> WHERE RC GOES\n         BAL   R8,DECRC           CONVERT RC TO DISPLAY             RH\n         BAL   R8,PRINT2          PRINT MSG                         RH\n*\nNODB5    DS    0H\n*\n*   CALL EZASOKET('RECV            ',\n*                 SOCDESC,          /* I/P PARMS        */\n*                 FLAG,\n*                 BUFFLEN,\n*                 OUTBUFF,\n*                 ERRNO,\n*                 RETCODE);\n*\n         LA    R15,OUTBUFL        SET BUFFER LENGTH\n         ST    R15,BUFFLEN        SAVE IT\n*\n         L     R15,SOKETAD        R15 -> TO EZASOKET ROUTINE\n         LA    R1,CALLD           R1 -> TO CALL LIST\n*                                 CALL IT\n         CALL  (15),                                                   +\n               (RECV,SOCDESC,FLAG,BUFFLEN,OUTBUFF,ERRNO,RETCODE),VL,   +\n               MF=(E,(R1))\n*\n         ICM   R15,15,RETCODE     R15 = RETURN CODE\n         BZ    SOKCLOS            IT'S ZERO...SOCKET CLOSED.\n         BNM   RECVOK             IT'S > THAN ZERO...OKAY...\n*\nRECVMSG  DS    0H\n         LA    R15,16             SET BAD RETURN CODE\n         ST    R15,CPKECB         ''\n         MVC   LINE1(L'BADRECV),BADRECV SET UP ERROR MSG            RH\n         LA    R14,LINE1+(RECVRC-BADRECV)\n         BAL   R8,DECRC           CONVERT RC TO DECIMAL             RH\n         BAL   R8,PRINT2          PRINT MSG                         RH\n         B     CALLCLOS           END FOR NOW\n*\nSOKCLOS  DS    0H\n         LA    R15,16             SET BAD RETURN CODE\n         ST    R15,CPKECB         ''\n         MVC   LINE1(L'BADSOCK2),BADSOCK2 SET UP ERROR MSG          RH\n         LA    R14,LINE1+(SOCK2RC-BADSOCK2)\n         BAL   R8,DECRC           CONVERT RC TO DECIMAL             RH\n         BAL   R8,PRINT2          PRINT MSG                         RH\n         B     CALLCLOS           END FOR NOW\n*\nRECVOK   DS    0H\n         CLI   TITLE_DEBUG,C' '   PRINT DEBUG INFO?\n         BNE   NODB8              NO\n         MVC   LINE1(10),=CL10'-AT RECV. '\n         LA    R14,LINE1+10\n         BAL   R8,DECRC           CONVERT RC TO DISPLAY             RH\n         BAL   R8,PRINT2          PRINT MSG                         RH\n*\nNODB8    DS    0H\n         MVC   LINE1(RECVMSGL),RECVMSGD PUT MSG IN PRINT LINE       RH\n         BAL   R8,PRINT2          PRINT MSG                         RH\n         BAL   R8,PRINT2          PRINT A BLANK LINE...             RH\n         LA    R6,OUTBUFF         R6 -> AT OUTPUT DATA\n*\nRECVOK1  DS    0H\n         SR    R8,R8              CLEAR R8\n         ICM   R8,3,0(R6)         R8 = LTH OF DATA SEGMENT\n         BZ    RECVOK8            IF 0, ALL DONE\n*\nRECVOK2  DS    0H\n*        CH    R8,=H'132'         TOO MUCH DATA?\n*        BNH   RECVOK3            NO\n*        LA    R8,132             YES, PRINT 1ST 132\n*\nRECVOK3  DS    0H\n         BCTR  R8,0               MAKE LTH HEX...\n         EX    R8,MOVEDATA        PUT DATA IN PRINT LINE\n*OVEDATA MVC   LINE1+2(0),4(R6)   PUT RECV DATA IN MSG              RH\n         BAL   R8,PRINT2          PRINT MSG                         RH\n         CLC   =C'*REQSTS*',4(R6) BAD READ?\n         BE    RECVOK4            YES, PRINT ERROR MSG\n         CLC   =C'SECFAIL',4(R6)  SECURITY FAIL?\n         BNE   RECVOK7            NO, LOOKS OKAY. ON WE GO\n*\nRECVOK4  DS    0H\n         MVC   RETCODE,12(R6)     YES, SET UP RETCODE\n         MVC   ERRNO,16(R6)       YES, SET UP ERRNO\n         B     RECVMSG            GO PRINT THEM\n*\nRECVOK7  DS    0H\n         SR    R8,R8              CLEAR R8\n         ICM   R8,3,0(R6)         R8 = LTH OF DATA SEGMENT\n         AR    R6,R8              R6 -> AT NEXT DATA SEGMENT\n         B     RECVOK1            GO PRINT IT\n*\n*   IF TITLE_DEBUG   = '  ' THEN  DO ;   /* IF FLAG IS BLANK,       */\n*       PUT FILE (SYSPRINT)\n*           EDIT ('AT RECV. ERRNO=',ERRNO,' RETCODE=',RETCODE)\n*             (SKIP(1), A, F(3), A, F(3)) ;\n*   END ;\n*\n*\nRECVOK8  DS    0H\n*\n*   CALL EZASOKET('CLOSE           ',\n*                 SOCDESC,          /* I/P PARMS        */\n*                 ERRNO,\n*                 RETCODE);\n*\nCALLCLOS DS    0H\n         L     R15,SOKETAD        R15 -> TO EZASOKET ROUTINE\n         LA    R1,CALLD           R1 -> TO CALL LIST\n*                                 CALL IT\n         CALL  (15),                                                   +\n               (CLOSE,SOCDESC,ERRNO,RETCODE),VL,                       +\n               MF=(E,(R1))\n*\n         ICM   R15,15,RETCODE     R15 = RETURN CODE\n         BZ    CLOSOK             IT'S ZERO...OKAY...\n*\n         LA    R15,16             SET BAD RETURN CODE\n         ST    R15,CPKECB         ''\n         MVC   LINE1(L'BADCLOS),BADCLOS SET UP ERROR MSG            RH\n         LA    R14,LINE1+(CLOSRC-BADCLOS)\n         BAL   R8,DECRC           CONVERT RC TO DECIMAL             RH\n         BAL   R8,PRINT2          PRINT MSG                         RH\n         B     NOMORE             END FOR NOW\n*\nCLOSOK   DS    0H\n*\n*   IF TITLE_DEBUG   = '  ' THEN  DO ;   /* IF FLAG IS BLANK,       */\n*       PUT FILE (SYSPRINT)\n*           EDIT ('AT CLOSE. ERRNO=',ERRNO,' RETCODE=',RETCODE)\n*             (SKIP(1), A, F(3), A, F(3)) ;\n*   END ;\n         CLI   TITLE_DEBUG,C' '   PRINT DEBUG INFO?\n         BNE   NODB10             NO\n         MVC   LINE1(11),=CL11'-AT CLOSE. '\n         LA    R14,LINE1+11\n         BAL   R8,DECRC           CONVERT RC TO DISPLAY             RH\n         BAL   R8,PRINT2          PRINT MSG                         RH\n*\nNODB10   DS    0H\n*\nNOMORE   DS    0H\n         BAL   R8,PRINT2          PRINT A BLANK LINE...             RH\n         MVC   LINE1,LINE2        SET UP END MSG                    RH\n         BAL   R8,PRINT2          SAY END OF CHKOTMA                RH\n*\n*        MAKE SURE WE ARE IN 24 BIT MODE ADDRESSING\n*\n*        LA    R1,*+4+2           GET BACK INTO 24 BIT MODE\n*        BSM   0,R1               ''\n*\n         LA    R2,PRINTDCB        R2 -> TO SYSPRINT DCB\n*        LA    R2,SYSPRINT        R2 -> TO SYSPRINT DCB\n         CLI   48(R2),X'40'       DCB SCREWED?                      RH\n         BNE   CLOSE2             NO, DON'T TRY TO CLOSE IT         RH\n         DC    H'0'\n         SPACE 1\nCLOSE2   DS    0H\n         TM    48(R2),X'10'       DID THE SYSPRINT FILE OPEN?       RH\n         BZ    CLOSE3             NO, DON'T TRY TO CLOSE IT         RH\n*        CLOSE (R2),MF=(E,DSCLOSE)                             DBUG RH\n         CLOSE (R2),MODE=24,MF=(E,DSCLOSE)\n         SPACE 1\nCLOSE3   DS    0H\n         AGO   .NODEL\n*\n*              USE THE FOLLOWING  CODE TO DELETE DYNAMICALLY LOADED\n*              MODULES\n*\n*              DELETE EZASOKET AND EZACIC08\n*\n         L     R4,SOKETAD         R4 -> TO MODULE NAME\n         DELETE EPLOC=((R4))      DELETE PGM...\n*\n         L     R4,CIC08AD         R4 -> TO MODULE NAME\n         DELETE EPLOC=((R4))      DELETE PGM...\n*\n         SPACE 1\n.NODEL   ANOP\n         L     R1,CPKECB          R1 = RETURN CODES\n         LA    R1,0(0,R1)         CLEAR HIGH BYTE\n         SPACE 1\n         L     R13,SAVE+4         POINT R13 BACK TO CALLER SAVEAREA\n         ST    R1,16(0,R13)       PASS RC BACK TO CALLING PLI PGM\n         FREEMAIN R,LV=LDYNAMIC,A=((R10))  FREE GOTTEN CORE\n         LM    R14,R12,12(R13)    RELOAD CALLERS REGS\n*              GET INTO PROPER MODE AND GO BACK TO CALLER\n         BSM   0,R14              RETURN TO CALLING PROGRAM\n         SPACE 1\nSETNAME  MVC   TITLE_IMSTOC(0),0(R2) SET UP IMSTOC NAME\nSETPORT  MVC   TITLE_PORT(0),0(R2) SET UP IMSTOC PORT\nMOVEDATA MVC   LINE1+2(0),4(R6)      PUT READ DATA IN MSG           RH\n         SPACE 1                                                    RH\n*\n*              PRINT ROUTINE\n*\nPRINT2   DS    0H                                                   RH\n         LA    R2,PRINTDCB        R2 -> TO SYSPRINT DCB\n*        LA    R2,SYSPRINT        R2 -> TO SYSPRINT DCB\n         TM    48(R2),X'10'       DID SYSPRINT DATASET OPEN         RH\n         BNO   NOPRINT2           NO, CAN'T PRINT INFO MSG THEN     RH\n*\n*        GO TO 24 BIT MODE ADDRESSING FOR PRINTING\n*\n*        LA    R1,*+4+2           GET BACK INTO 24 BIT MODE\n*        BSM   0,R1               ''\n*\n         PUT   (R2),LINE1         PRINT LINE                        RH\n*\n*        NOW GO BACK TO 31 BIT MODE ADDRESSING\n*\n*        CNOP  0,4                PUT ON FULLWORD BOUNDARY\n*        L     R1,*+8             GET 31 BIT MODE ADDRESS\n*        BSM   0,R1               GET INTO 31 BIT MODE\n*        DC    H'0'               ALIGN ON A FULLWORD BOUNDARY\n*        DC    X'80',AL3(*+3)     NEXT ADDRESS IS 31 BIT MODE\n*\nNOPRINT2 DS    0H                                                   RH\n         MVI   LINE1+1,C' '       CLEAR LINE 1                      RH\n         MVC   LINE1+2(131),LINE1+1  *                              RH\n         SPACE 1                                                    RH\n         BR    R8                 RETURN                            RH\n         SPACE 3\n* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n*        WORK AREAS\n* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\nDUMPTITL DC    C'WORKING STORAGE SECTION'\n         SPACE 1                                               DBUG RH\nBFLAG    DC    X'00'\nBFLAG80  EQU   X'80'              THIS IS A BATCH JOB\n         ENTRY ECB,IOPLADD\nECB      DC    F'0'\nIOPLADD  DC    A(*-*)                   ADDRESS OF THE UPT\n         DC    A(*-*)                   ADDRESS OF THE ECT\n         DC    A(MSG_ECB)               ADDRESS OF THE ECB\n         DC    A(*-*)                   ADDRESS OF THE --PB\n         SPACE 1                                               DBUG RH\nSOKETAD  DC    V(EZASOKET)\nCIC08AD  DC    V(EZACIC08)\nEZASOKET DC    CL8'EZASOKET'\nEZACIC08 DC    CL8'EZACIC08'\nTRTAB    DC    C' 0123456789ABCDEF'\n         SPACE 1                                               DBUG RH\nPASSWORD DC    AL1(0),CL8' '\n         SPACE 1\nGETPSWD  DC    AL2(LGETPSWD,0)\n         DC    C'ENTER PASSWORD FOR '\nUSERID   DC    CL7' '\nLGETPSWD EQU   *-GETPSWD\n         SPACE 3\nOLDNAME  DC    CL8' '\nRACPSWD  DC    CL11' '            RACF PASSWORD                     RH\n         SPACE 1\nMSG_PGPB PUTGET MF=L,                                                  +\n               OUTPUT=(MSG_ADDR,SINGLE,PROMPT)\n         SPACE 2\nMSG_ADDR DC    A(1)\n         DC    3A(*-*)              ADDRESS OF THE MESSAGE TEXT\n         SPACE 2\nMSG_ECB  DC    A(0)\n         SPACE 1                                               DBUG RH\nHEADINFO DS    0CL133\n         DC    CL2'1'\n         DC    CL72' '\n         ORG   *-72\n         DC    C'DIVERSIFIED DEVELOPMENTS IMSTOC/OTMA CHECKER '\n         DC    C'UTILITY, VERSION 1.0'\n         ORG\n         DC    CL(133-(*-HEADINFO))' '\n         SPACE 1\nLINE2    DC    CL133'- END OF IMSTOC/OTMA CHECKER...'\n*\nDB1      DC    C'- ADSNAME='\nDB1NAME  DC    CL8' '\n         DC    C', PORT='\nDB1PORT  DC    CL4' '\n         DC    C', HOSTNAME='\nDB1HOST  DC    CL24' '\nDB1LTH   EQU   *-DB1\n*\nRECVMSGD DC    C'-RECV DATA FOR WHOAMI TRAN IS...'                  RH\nRECVMSGL EQU   *-RECVMSGD\n*\nBADRECV  DC    C'- RECV CALL FAILED. '\nRECVRC   DC    CL8' '\n*\nBADCLOS  DC    C'- CLOSE CALL FAILED. '\nCLOSRC   DC    CL8' '\n*\nBADWRIT1 DC    C'- WRITE1 CALL FAILED. '\nWRIT1RC  DC    CL8' '\n*\nBADCONN  DC    C'- CONNECT CALL FAILED. '\nCONNRC   DC    CL8' '\n*\nBADINIT  DC    C'- INITAPI CALL FAILED. '\nINITRC   DC    CL8' '\n*\nBADHOST  DC    C'- GETHOSTBYNAME CALL FAILED. '\nHOSTRC   DC    CL8' '\n*\nBADHOSTE DC    C'- INVALID HOSTENT ADDRESS. '\nHOSTRCE  DC    CL8' '\n*\nBADSOCK  DC    C'- SOCKET CALL FAILED. '\nSOCKRC   DC    CL8' '\n*\nBADSOCK2 DC    C'- RECV CALL FAILED. SOCKET CLOSED. '\nSOCK2RC  DC    CL8' '\n*\nMSG1     DC    C'- TESTING IMSTOC '\nMS1NAME  DC    CL8' '\n         DC    C', PORT='\nMS1PORT  DC    CL4' '\n         DC    C', HOSTNAME='\nMS1HOST  DC    CL24' '\nMSG1LTH  EQU   *-MSG1\n         SPACE 1                                                    RH\nOPENMAC  OPEN  (PRINTDCB,(OUTPUT)),MF=L\nOPENLTH  EQU   *-OPENMAC\n         SPACE 1\nCLOSMAC  CLOSE PRINTDCB,MF=L                                   DBUG RH\nCLOSLTH  EQU   *-CLOSMAC\n         SPACE 1\n         DC    F'0'\nPRINTDCB DCB   DSORG=PS,DDNAME=SYSPRINT,LRECL=133,RECFM=FBA,   XXXXXXXXX\n               MACRF=(PM),BLKSIZE=3990\nPDCBLTH  EQU   *-PRINTDCB                                      DBUG RH\n*\nCLOSE    DC    CL16'CLOSE          '\nWRITE    DC    CL16'WRITE          '\nREAD     DC    CL16'READ           '\nRECV     DC    CL16'RECV           '\nCONNECT  DC    CL16'CONNECT        '\nGETHOST  DC    CL16'GETHOSTBYNAME  '\nSOCKET   DC    CL16'SOCKET         '\nINITAPI  DC    CL16'INITAPI        '\n*\nMAXSOC   DC    H'55'\nMAXSNO   DC    F'54'\nTHREE    DC    F'3'   FIXED BIN (31) INIT (3);\nTWO      DC    F'2'   FIXED BIN (31) INIT (2);\nONE      DC    F'1'   FIXED BIN (31) INIT (1);\nZERO     DC    F'0'   FIXED BIN (31) INIT (0);\n         SPACE 1\n               SPACE 1\n***********************************************************************\n*  IRM   V2.1.3 IMS REQUEST MESSAGE\n*                                                                    *\n*        INPUT: THE DATA SENT TO TOC/OTMA LOOKS AS FOLLOWS:\n*\n*        |LLLL|IRM|LLZZDATA|LLZZDATA|LLZZDATA...|00040000 WHERE\n*\n*        LLLL     = FULLWORD FIELD CONTAINING TOTAL LEN OF ALL DATA\n*        IRM      = THE STRUCTURE IRM(SEE HWSIMSCB FOR MAPPING)\n*        LLZZDATA = USER DATA FROM THE CLIENT DESTINED FOR IMS TRAN\n*        00040000 = TERMINATING STRING FROM CLIENT\n*\n***********************************************************************\nHWSDATA        DS   0F            DATA SENT TO HWS\n*\nINBUFF         DS   0C            IMS REQUEST MESSAGE BUFFER\nIRM_TOTLEN     DC   A(INBUFL)     LENGTH OF BUF, INCLUDING THIS FIELD\n*\nIRM_FIXED32    DS   0CL32         TCPIP OTMA 32 BYTE HEADER\nIRMMASK        DS   0F            IMS REQUEST MESSAGE DSECT\nIRM_LEN        DC   AL2(IRMMASK_LEN) LTH OF IRM, INCLUDING RACF DATA\nIRM_RSV        DC   H'0'          RESERVED\nIRM_ID         DC   CL8'*SAMPLE*' TRM ID '*IRMREQ*' ASCII/EBCDIC\nIRM_RES_WORD   DC   F'0'          RESERVED WORD\nIRM_F5         DC   X'00'         FLAG 5 - MESSAGE STRUCTURE\nIRM_F5_OTMA    EQU  X'80'         OTMA HEADERS BUILT BY CLIENT\nIRM_F5_TRANS   EQU  X'40'         TRANSLATION PERFORMED BY CLIENT\nIRM_RSV02      DC   3X'00'        RESERVED FOR FUTURE USE\nIRM_CLIENTID   DC   CL8'      '   8 BYTE UNIQUE CLIENT ID - IF\n*                                 BLANK, EXIT WILL BUILD IT\n*                                 END OF 32 BYTE HEADER\nIRM_F1         DC   X'00'         FLAG 1\nIRM_F1_MFSREQ  EQU  X'80'         USER REQUESTS MFS MOD NAME RETURNED\nIRM_F2         DC   X'20'         FLAG 2\nIRM_F2_CMODE0  EQU  X'40'         CLIENT REQUESTS COMMIT MODE 0\nIRM_F2_CMODE1  EQU  X'20'         CLIENT REQUESTS COMMIT MODE 1\nIRM_F3         DC   X'00'         FLAG 3\nIRM_F3_CONFIRM EQU  X'01'         CLIENT REQ SYNCH LEVEL CONFIRM\n*                                 IF COMMIT MODE = 0 THEN\n*                                    SYNCH LEVEL MUST BE \"CONFIRM\"\n*                                 IF COMMIT MODE = 1 THEN\n*                                    SYNCH LEVEL CAN BE \"CONFIRM\"\n*                                    OR \"NONE\"\nIRM_F4         DC   C' '          FLAG 4 - CONVERSATION FLAG\nIRM_F4_ACK     EQU  C'A'          CLIENT ACK WHEN MSG RECEIVED\n*                                 SUCCESSFULLY AND CONV TO CONTINUE\nIRM_F4_NACK    EQU  C'N'          CLIENT NEG ACK WHEN MSG RECEIVED\n*                                 BUT CLIENT WANTS CONV ABORTED\nIRM_F4_DEALLOC EQU  C'D'          CLIENT WISHED TO DEALLOC CONNECTION\n*\nIRM_F4_RESUMET EQU  C'R'          RESUME OUTPUT FOR TPIPES\n*\nIRM_F4_SENDONLY EQU  C'S'         SENDONLY WORK WITH COMMIT MODE 0 ONLY\n*\nIRM_TRNCOD     DC   CL8'WHOAMI '  IMS TRAN CODE\nIRM_IMSDESTID  DC   CL8'IMSDEVL'  IMS DESTINATION ID FOR THIS TRAN CODE\nIRM_LTERM      DC   CL8'       '  USER PROVIDED LTERM OR BLANKS\n*                                 DEFAULT IS IRM_IMSDESTID....      RH\n*\nIRM_USRDAT      DS   0C      BEGINNING OF USER SECURITY DATA - OPTIONAL\nIRM_RACF_USERID DC  CL8'RH87944'   RACF USERID - OPTIONAL\nIRM_RACF_GRNAME DC  CL8'IMSVS'     RACF GROUP NAME - OPTIONAL\nIRM_RACF_PW     DC   CL8'      '   RACF PASSWORK - OPTIONAL\nIRMMASK_LEN    EQU  *-IRMMASK     SIZE OF REQUIRED IRM\n*\nIRM_LEN2       DC   AL2(IRMLTH2)  FIRST DATA SEGMENT\nIRM_RSV2       DC   AL2(0)        RESERVED\nIRM_TRNCOD2    DC   CL8'WHOAMI '  IMS TRAN CODE\nIRMLTH2  EQU   *-IRM_LEN2         TOTAL LTH\n*\nIRM_LEN3       DC   AL2(IRMLTH3)  2ND SEGMENT, IS ANY\nIRM_RSV3       DC   AL2(0)        RESERVED\nIRM_DATA3      DC   CL1' '        IMS TRAN CODE\nIRMLTH3  EQU   *-IRM_LEN3         TOTAL LTH\n*\nIRM_LEN9       DC   XL2'0004'     END OF MSG....\nIRM_RSV9       DC   AL2(0)        RESERVED\nDATALTH9 EQU   *-IRM_LEN2         TOTAL LTH\n*\nINBUFL   EQU   *-INBUFF           INPUT BUFFER LTH\nHWSDATAL EQU   *-HWSDATA          LTH OF DATA SENT TO HWS\n*\n*\n*              END OF DATA TO OTMA EXIT....\n*\n*\n         LTORG\n         SPACE 1\n*\n******** ***** ****************** ****************************\n*\n*              DSECT USED FOR ALL DATA ACCESS...TO BE RE-ENTRANT\n*\n******** ***** ****************** ****************************\nWORK     DSECT\nSAVE     DC    18F'-1'\nWORKINIT DS    0H                 START INIT HERE...\nCPKECB   DS    F                  RETURN CODE\nCPPLADDR DC    F'0'\n         SPACE 1                                               DBUG RH\nDSOPEN   OPEN  (2,(OUTPUT)),MF=L\n         SPACE 1\nDSCLOSE  CLOSE (R2),MF=L                                       DBUG RH\n         SPACE 1\nLINE1    DC    CL133'- '   THIS IS USED FOR DEBUGGING.\n         SPACE 1                                                    RH\n         DC    F'0'\nSYSPRINT DCB   DSORG=PS,DDNAME=SYSPRINT,LRECL=133,RECFM=FBA,   XXXXXXXXX\n               MACRF=(PM),BLKSIZE=3990\n         SPACE 1                                               DBUG RH\nTITLE_IMSTOC DS CL8                 INIT('OTMAHWSA') ;\nTITLE_PORT     DS CL4               INIT('7010') ;\nTITLE_DEBUG    DS CL2               INIT('NO') ;\n*\nWORKERR  DS    CL10               FOR TRANSLATING ERROR CODES\n*\n*SOKETAD DS    F      FIXED BIN(31); USE IF LOAD PGM, NOT INCLUDE\n*CIC08AD DS    F      FIXED BIN(31); USE IF LOAD PGM, NOT INCLUDE\nERRNO    DS    F      FIXED BIN(31);\nRETCODE  DS    F      FIXED BIN(31);\nBUFFLEN  DS    F      FIXED BIN(31);\nFLAG     DS    F      FIXED BIN(31) INIT(0);\nHOSTNAME DS    CL24   CHAR(24) INIT('BCSC01A');\nNAMELEN  DS    F      FIXED BIN(31) INIT(7);\nHOSTENT  DS    F      FIXED BIN(31) INIT(0);\nHOSTNAME_LENGTH DS H  FIXED BIN(15) INIT(0);\nHOSTNAME_VALUE  DS CL255  CHAR(255) INIT(' ');\nHOSTALIAS_COUNT DS H  FIXED BIN(15) INIT(0);\nHOSTALIAS_SEQ   DS H  FIXED BIN(15) INIT(0);\nHOSTALIAS_LENGTH DS H FIXED BIN(15) INIT(0);\nHOSTALIAS_VALUE DS CL255  CHAR(255) INIT(' ');\nHOSTADDR_TYPE   DS H  FIXED BIN(15) INIT(0);\nHOSTADDR_LENGTH DS H  FIXED BIN(15) INIT(0);\nHOSTADDR_COUNT  DS H  FIXED BIN(15) INIT(0);\nHOSTADDR_SEQ    DS H  FIXED BIN(15) INIT(0);\nHOSTADDR_VALUE  DS F  FIXED BIN(31) INIT(0);\n*\nIDENT    DS    0C\nTCPNAME  DS    CL8    CHAR(08),\nADSNAME  DS    CL8    CHAR(08);\n*\nNAME     DS    0H\nFAMILY   DS    H      FIXED BIN (15) INIT (2),\nPORT     DS    H      FIXED BIN (15) INIT (3083),\nSERVIADD DS    F      FIXED BIN (31) INIT (0),\nRESERVED DS    CL8    CHAR(08);\n*\nSUBTASK  DS    CL8    CHAR(08);\n*\nSOCDESC  DS    H      FIXED BIN (15) INIT (0);\n*\nDWORD    DS    D\nSAVETIME DC    XL16'00'                                             Y2\n*\nCALLD    CALL  ,(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),MF=L\n*\nTIMED    TIME  LINKAGE=SYSTEM,MF=L      GET THE SYS TIME            Y2\n*\nOUTBUFF  DS    CL512              OUTPUT BUFFER\nOUTBUFL  EQU   *-OUTBUFF          OUTPUT BUFFER LTH\nLINIT    EQU   *-WORKINIT         LTH OF INIT AREA\nLDYNAMIC EQU   *-WORK             LTH OF WORK DSECT\n         SPACE 1\n*        HWSIMSCB\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\n         PRINT GEN\n         IKJCPPL\n         IKJIOPL\n         IKJPSCB\n         IKJPGPB\n*\n         IHAACEE\n         IHAPSA\n         IHAASCB\n         IHAASXB\n*\n         END   CHKOTMA            END OF CHKOTMA\n/*\n//*\n//LKED.SYSLMOD DD DSN=HALL.LINKLIB,DISP=SHR\n//INCLUD       DD DISP=SHR,DSN=TCPIP.SEZATCP\n//LKED.SYSIN DD *\n  INCLUDE INCLUD(EZASOKET,EZACIC08)\n  ENTRY CHKOTMA\n  SETCODE AC(0)\n  MODE   AMODE(31) RMODE(24)\n  NAME CHKOTMA(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHKOTMAR": {"ttr": 5633, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03?\\x00\\x99\\x03?\\x12H\\x00w\\x00w\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-02T00:00:00", "modifydate": "1999-02-02T12:48:00", "lines": 119, "newlines": 119, "modlines": 0, "user": "RH87944"}, "text": "/* REXX */\n/* LISTENER ***********************************************************/\n/*                                                                    */\n/*  This REXX EXEC is used to run the chklsnr program which submits   */\n/*  tran whoami to the requested listener.                            */\n/*                                                                    */\n/*                                                                    */\n/* ITSD*************************************** R.Hall  98/10/19       */\n/* LISTENER ***********************************************************/\n\n/*      TRACE ON                         /* OPTIONS AND DROP */\n        TRACE RESULTS;                   /* DEBUG FROM PARMS */\n  */\n   X=PROMPT(ON)       /* ALLOW PROMPTING */\n   PARSE UPPER ARG @ARGS               /* GET PARMS, IF ANY */\n\n   TSOCMD = \"CHKOTMA\"\n   CMD = \"CALL 'HALL.LINKLIB(CHKOTMA)'\"\n/* CMD = \"CALL 'SYS9.IMSUTIL.LOAD(CHKLSNR)'\" */\n   DEBUG = \"\"                  /* set variable for VPUT */\n\nchkarg:\n     @NBR = FIND(@ARGS,'DEBUG')          /* SEE IF DEBUG WAS */\n     IF @NBR > 0 THEN DO                 /* SPECIFIED. IF IT */\n        @ARGS = DELWORD(@ARGS,@NBR,1)    /* WAS, TURN ON DEBUG */\n        TRACE ON                         /* OPTIONS AND DROP */\n        TRACE RESULTS;                   /* DEBUG FROM PARMS */\n        DEBUG = \"DEBUG\"                  /* set variable for VPUT */\n     END\n\n     @NBR = FIND(@ARGS,'HELP')          /* SEE IF HELP WAS */\n     IF @NBR > 0 THEN DO                 /* SPECIFIED. IF IT */\n        @ARGS = DELWORD(@ARGS,@NBR,1)    /* WAS, PROMPT... */\n         call help\n         say \"Enter parms(END to exit): \"\n         Pull @ARGS               /* GET PARMS, IF ANY */\n/*       IF LENGTH(@ARGS) = 0 THEN EXIT */\n         @NBR = FIND(@ARGS,'END')          /* SEE IF END WAS */\n         IF @NBR > 0 THEN exit               /* SPECIFIED.  */\n         signal chkarg\n      END\n\n                                     /* WHAT SHOULD BE LEFT */\n                                     /* IS THE TASK NAME */\n                                     /* AND THE PORT NBR*/\n                                     /* PARSE THEM INTO VARIABLES */\n       PARSE UPPER VAR @ARGS LTASK PORT\n\n      prm = \"\"\n      IF LENGTH(LTASK) = 0 THEN LTASK = \"OTMAHWSD\"\n      IF LENGTH(PORT)  = 0 THEN PORT  = \"7010\"\n\n                                   /*  remove any leading blanks   */\n                                   /*  from the parms               */\n      IF LENGTH(LTASK) > 1 THEN do\n         do while substr(LTASK,1,1) = ' '\n            LTASK = substr(LTASK,2,(length(LTASK)-1))\n         end\n         prm = LTASK\n      end\n      IF LENGTH(PORT) > 1 THEN do\n         do while substr(PORT,1,1) = ' '\n            PORT = substr(PORT,2,(length(PORT)-1))\n         end\n         PORT = substr(PORT,1,4)\n         prm = prm\",\"PORT\n      end\n/*    say \"lth of PORT = \"length(PORT) */\n\n      IF LENGTH(LTASK) > 1 THEN do\n       IF LENGTH(PORT) = 0 THEN do\n         IF LTASK = \"OTMAHWSA\" THEN PORT = \"7010\"\n         IF LTASK = \"OTMAHWSD\" THEN PORT = \"7010\"\n         prm = prm\",\"PORT\n       end\n      end\n/*    say \"lth of PORT = \"length(PORT) */\n\nchksys:\n      IF LENGTH(DEBUG) > 1 THEN do\n         IF LENGTH(prm) > 1 THEN do\n            prm = prm\",\"DEBUG\n         end\n         else do\n            prm = DEBUG\n         end\n      end\n\naddress ISPEXEC\n\nmainrc = ''\n /*  ADDRESS  TSO \"alloc da(*) f(sysprint) reuse\"  */\n     ADDRESS \"TSO\" CMD \"'\"prm\"'\"\n/*   ADDRESS \"TSO\" TSOCMD prm */\n\n  exit      /* end of PERMIT exec...     */\n\nHELP:\n    address ispexec \"CONTROL DISPLAY REFRESH\"\n    CLRSCRN\n    say\n    say \"Command syntax is: 'CHKOTMA name port debug help', where \"\n    say\n    say \" 'name'   is the OTMA task name\"\n    say \"          The default is OTMAHWSP\"\n    say\n    say \" 'port'   is the tcpip port number\"\n    say \"          The default is 7010\"\n    say \"          if PORT is specified, NAME must be specified.\"\n    say\n    say \" 'debug'  will turn on Rexx's trace mode for debugging purposes\n    say \"          and also cause CHKOTMA to display messages\"\n    say\n    say \" 'help'   will display this help screen\"\n    say\n    say \" All parms are optional. If none are specified, the OTMAHWSD\"\n    say \" IMSTOC will be checked.\"\n    say\n    return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLIST": {"ttr": 5636, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x00\\x9f\\x00\\x99\\x00\\x9f\\x12Y\\x00?\\x00?\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-01-09T00:00:00", "modifydate": "1999-01-09T12:59:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "RH87944"}, "text": "PROC 1 LIB PUNCHOUT(PUNCHOUT) PRINTOUT(PRINTOUT) SUPVR FLTPT LIST -\n       DIAGNOSE CONTROL(*) CALL(CALL) LOAD('')\n/*\n/*    THIS CLIST INVOLVES THE DISASSEMBLER:\n/*      (DISASSEMBLER IS A PRODUCT OF:\n/*        DISK THORNTON\n/*        BLUE CROSS OF VIRGINIA\n/*        2015 STAPLES MILL ROAD\n/*        RICHMOND, VA. 23279).\n/*\nIF ('&DIAGNOSE.' EQ 'DIAGNOSE')  -\n   THEN CONTROL   PROMPT   LIST   CONLIST   SYMLIST MSG\n   ELSE CONTROL NOPROMPT NOLIST NOCONLIST NOSYMLIST MSG\nIF &SUPVR = SUPVR THEN +\n    IF &FLTPT = FLTPT THEN +\n        SET &PARM = 'SUPVR,FLTPT'\n    ELSE +\n        SET &PARM = 'SUPVR'\nELSE +\n    IF &FLTPT = FLTPT THEN +\n        SET &PARM = 'FLTPT'\n    ELSE\n        SET &PARM = &STR()\nALLOC FI(SYSLIB) DA(&LIB) SHR REU\nCONTROL NOMSG\nFREE FI(SYSPUNCH) ATTR(DAPRATTR DAPUATTR)\nCONTROL MSG\nATTR DAPUATTR BLKSIZE(19040)\n%ALLOCDS FI(SYSPUNCH) DA(&PUNCHOUT) PRIME(60) USING(DAPUATTR)\nATTR DAPRATTR BLKSIZE(18997)\n%ALLOCDS FI(SYSPRINT) DA(&PRINTOUT) PRIME(90) USING(DAPRATTR)\nALLOC FI(SYSIN) DA(&STR(&CONTROL)) REUSE\nIF &STR(&CONTROL) \u00ac= &STR(*) -\nTHEN -\n   GOTO DOIT\nCLEAR\nWRITE ENTER CONTROL STATEMENTS:\nWRITE 1ST CARD: MODULE CSECT  (CSECT IS OPTIONAL)   <== REQUIRED 1ST CARD\nWRITE ALL OTHER CARDS ARE OPTIONAL--THEY INCLUDE:\nWRITE DATA ONLY CARD: 1-4='DATA';6-11=START OFFSET(HEX);13-18=END OFFSET(HEX)\nWRITE DSECT DEFINITIONS--HEADER AND DEFINITION CARDS:\n/* W AT THE END OF THE NEXT LINE WAS TRUNCATED, ADD IT BACK PLEASE\nWRITE  HEADER: 1-8=DSECT NAME;10-14='DSECT';16-19=# OF DEFINITION CARDS TO FOLLO\n/* TH AT THE END OF THE NEXT LINE WAS TRUNCATED, ADD IT BACK PLEASE\nWRITE  DEFINITION: 1-8=FIELD-NAME;10-13=DECIMAL OFFSET TO FIELD;15-17=FIELD LENG\nWRITE ULABL CARDS: 1-5='ULABL';7-14=LABEL-NAME;16-21=HEX OFFSET TO START;\nWRITE              23-25=LENGTH(DEC)\nWRITE USING CARD: 1-5='USING';7-12=BEGIN LOC(HEX)-IE, WHERE USING GOES;\nWRITE             14-19=END LOC(HEX)-IE, WHERE DROP GOES; 21=BASE(0-F);\nWRITE             23=TYPE('P'=PROGRAM,'D'=DSECT);\nWRITE             25-30=INITIAL BASE VALUE-FOR TYPE 'P'\nWRITE             25-32=DSECT NAME-FOR TYPE 'D'\nWRITE ---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+\nDOIT: +\n&CALL. 'QC22505.TSO&LOAD..LOAD(DISASM)' &PARM\nIF &CALL=TEST THEN GOTO DONE\nWRITE ******  END OF DISASSEMBLY  ******\nIF &LIST=LIST THEN -\n   LIST PUNCHOUT\nWRITE SEE DATASET &PRINTOUT FOR LISTING;\nWRITE SEE DATASET &PUNCHOUT FOR DECK.\nTERMIO\nDONE: SET A = 1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CLIST2": {"ttr": 5638, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x01\\x1f\\x00\\x99\\x01\\x1f\\x13$\\x00\\x16\\x00\\x16\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-01-11T00:00:00", "modifydate": "1999-01-11T13:24:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "RH87944"}, "text": "PROC 0 SYSLIB(IMSX.IMF.LOAD) SYSPRINT(HALL.OUTLIST) +\n       TEST(NO) MBR(DISASM) +\n       SYSIN(HALL.DISASM.SOURCE(SYSIN))\n/*     SYSIN(*)          /* TO PROMPT FOR SYSIN...\n     CONTROL   LIST   CONLIST NOFLUSH\n     IF &TEST = NO THEN GOTO NOTEST\n     SET &SYSLIB = HALL.LINKLIB\n     SET &SYSIN = RH87944.DISASM.SOURCE(SYSIN)\n\nNOTEST:FREE F(A1,A2,SYSPUNCH)\n     ALLOC DA('&SYSLIB') F(SYSLIB) SHR REUSE\n     ATTR A2 BLKSIZE(19019)\n     ALLOC DA('&SYSPRINT') F(SYSPRINT) SHR REUSE USING(A2)\n     ATTR A1 BLKSIZE(80)\n     ALLOC DA('NULLFILE') F(SYSPUNCH) REUSE USING(A1)\n/*   ALLOC DA(SYSPUNCH) F(SYSPUNCH) NEW  REUSE USING(A1) SP(1,1) TR  DEL\n     ALLOC DA(&SYSIN) F(SYSIN) SHR REUSE\n     TSOEXEC TEST 'HALL.LOAD(&MBR)' 'FLTPT,SUPVR'\n     EQ AA +0\n     AT AA+C60\n     AT AA+EAA\n     AT AA+10E6\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DATEFB": {"ttr": 5640, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x12A\\x08\\x9a\\x08\\x9a\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T12:41:00", "lines": 2202, "newlines": 2202, "modlines": 0, "user": "RH87944"}, "text": "//DATEFB   JOB\n/*ROUTE  PRINT R7\n//STEP1 EXEC PGM=IEBGENER,REGION=50K\n//SYSPRINT DD SYSOUT=A\n//SYSIN DD DUMMY\n//SYSUT2 DD DSN=&&T(SDP10),UNIT=SYSDA,DISP=(,PASS),SPACE=(TRK,(5,1,5)),\n//  DCB=(RECFM=FB,LRECL=80,BLKSIZE=9440),VOL=SER=WORK01\n//SYSUT1 DD *\nSTART1   DC    F'0'                     CONTROL FIELD 1\nLENGTH1  DC    F'0'                     *\nTYPE1    DC    C'A'                     *\nSTART2   DC    F'0'                     CONTROL FIELD 2\nLENGTH2  DC    F'0'                     *\nTYPE2    DC    C'A'                     *\nSTART3   DC    F'0'                     CONTROL FIELD 3\nLENGTH3  DC    F'0'                     *\nTYPE3    DC    C'A'                     *\nSTART4   DC    F'0'                     CONTROL FIELD 4\nLENGTH4  DC    F'0'                     *\nTYPE4    DC    C'A'                     *\nSTART5   DC    F'0'                     CONTROL FIELD 5\nLENGTH5  DC    F'0'                     *\nTYPE5    DC    C'A'                     *\n         SPACE\nOPENFLGS DC    BL1'0'                   OPEN FLAGS\nSTRTPOS  DC    C' '                START POSITION\n*        DC    C' '                START AT DATA, NOT RDW\n*        DC    C'R'                START AT RDW, POS 1 IN DECIMAL\n*        DC    C'H'                START AT RDW, POS 0 IN HEX\nOUT1CTR  DC    F'0'                     OUT1 COUNTER\nOUT2CTR  DC    F'0'                     OUT2 COUNTER\nOUT3CTR  DC    F'0'                     OUT3 COUNTER\nOUT4CTR  DC    F'0'                     OUT4 COUNTER\nOUT5CTR  DC    F'0'                     OUT5 COUNTER\nOUT6CTR  DC    F'0'                     OUT6 COUNTER\nOUT7CTR  DC    F'0'                     OUT7 COUNTER\nHEAD1    DC    CL74'RECORDS SPLIT TO OUT1'\nHEAD2    DC    CL74'RECORDS SPLIT TO OUT2'\nHEAD3    DC    CL74'RECORDS SPLIT TO OUT3'\n/*\n//*\n//STEP2 EXEC PGM=IEBGENER,REGION=50K\n//SYSPRINT DD SYSOUT=A\n//SYSIN DD DUMMY\n//SYSUT2 DD DSN=&&T(SDP20),UNIT=SYSDA,DISP=(SHR,PASS)\n//SYSUT1 DD *\n         DC    F'0'                     SELECT 1\n         DC    X'80'                    CF1\n         DC    111X'FF'                 *\n         DC    F'12'                    CF2 CONTROL TABLE DISPLACEMENT\n         DC    X'80'                    *   COMPARE CODE\n         DC    111X'FF'                 *   SEARCH VALUE\n         DC    F'24'                    CF3\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'36'                    CF4\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'48'                    CF5\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         SPACE\n         DC    F'0'                     SELECT 2\n         DC    X'80'                    CF1\n         DC    111X'FF'                 *\n         DC    F'12'                    CF2\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'24'                    CF3\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'36'                    CF4\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'48'                    CF5\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         SPACE\n         DC    F'0'                     SELECT 3\n         DC    X'80'                    CF1\n         DC    111X'FF'                 *\n         DC    F'12'                    CF2\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'24'                    CF3\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'36'                    CF4\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'48'                    CF5\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         SPACE\n*                                       SELECT 4\n         DC    F'0'                     CF1\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'12'                    CF2\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'24'                    CF3\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'36'                    CF4\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'48'                    CF5\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         SPACE\n*                                       SELECT 5\n         DC    F'0'                     CF1\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'12'                    CF2\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'24'                    CF3\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'36'                    CF4\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'48'                    CF5\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n/*\n//*\n//STEP3 EXEC HLASMC,PARMC='XREF(FULL)'\n//ASM.SYSLIB DD\n//          DD\n//    DD DSN=&&T,DISP=(SHR,PASS)\n//SYSIN DD *\n**********************************************************************\n*\n*        MODIFICATIONS:\n*        JULY 03, 1996...ADDED COMMENT CHECK IN INPUT VERIFY\n*                        ROUTINE. COMMENTS CAN START WITH * OR /.\n*\n*        JUNE 24, 1996...ADDED START=HEX PARM THAT SAYS START AT\n*                        OFFSET 0 AND USE HEXADECIMAL START POSITION\n*                        NOTE...START=HEX MUST BE FIRST CONTROL CARD\n*\n**********************************************************************\n*\n*                    DATEFB\n*\n*DATEFB CAN BE USED TO SPLIT RECORDS FROM A VARIABLE LENGTH FILE\n*TO A SYSOUT FILE OR TO ANOTHER VARIABLE LENGTH FILE.\n*DATEFB CAN ALSO BE USED TO CREATE A FIXED LENGTH FILE FROM A\n*VARIABLE LENGTH FILE.\n*\n*                    JCL\n*\n*TO EXECUTE DATEFB THE FOLLOWING JCL IS REQUIRED:\n*\n*//   JOBCARD\n*//STEPNAME   EXEC PGM=DATEFB,REGION=60K\n*//STEPLIB    DD   DSN=SYS1.USERLIB2,DISP=SHR\n*//SYSPRINT   DD   SYSOUT=A\n*//TAPEIN     DD   DSN=....ETC.\n*//OUT1\n*//OUT7\n*//SYSIN      DD  *\n*CONTROL CARDS\n*//\n*\n*THE OUT1 TO OUT7 DD CARDS ARE:\n*//OUT1       DD  SYSOUT=A\n*//OUT2       DD  SYSOUT=A\n*//OUT3       DD  SYSOUT=A\n*//OUT4       DD  DSN=, UNIT=, DISP=, SPACE=, DCB=\n*//OUT5       DD  ''\n*//OUT6       DD  ''\n*//OUT7       DD  ''\n*\n*FOR OUT4, OUT5, OUT6:\n*DSN= ANY NAME UP TO 44 CHARACTERS LONG CONSISTING OF\n*     1-8 CHARS.1-8 CHARS.ETC\n*UNIT= TAPE FOR TAPE\n*      USER  FOR PERMANENT DISK FILES\n*      SYSDA   FOR TEMPORARY FILES\n*DISP= (,CATLG) FOR PERMANENT FILES\n*      (,PASS)  FOR TEMPORARY FILES\n*SPACE= IS REQUIRED ONLY IF UNIT=SYSDA OR USER\n*      (TRK,(NBR OF TRKS,3),RLSE)\n*      NBR OF TRKS DEPENDS ON THE NUMBER OF RECORDS BEING SPLIT.\n*      IF BLKSIZE=3532, THERE WILL BE 5 BLOCKS PER TRACK ON A\n*      3350, SO 100 BLOCKS WOULD NEED 20 TRACKS.\n*DCB=  (LRECL=REC LEN+4,BLKSIZE=(REC LEN+4)*BLK FACTOR)+4)\n*      EG- IF REC LEN = 1760 AND BLK FACTOR = 2,\n*      LRECL=1764,BLKSIZE=3532\n*      IF RECFM IS LEFT OFF OUT4 - OUT6 DCB'S, IT WILL\n*      DEFAULT TO THE RECFM OF THE INPUT FILE.\n*\n*FOR OUT7:\n*DCB=  (RECFM=FB,LRECL=REC LEN,BLKSIZE=REC LEN*BLK FACTOR)\n*      THE VB FILE IS REBLOCKED TO THE REC LEN SPECIFIED IN\n*      THE LRECL=. IF THE FB LRECL IS LARGER THAN THE VB LRECL,\n*      THE FB RECORD IS PADDED WITH BLANKS.\n*\n*\n*                    CONTROL CARDS\n*\n*DATEFB IS CONTROLLED BY THE FOLLOWING CONTROL CARDS:\n*INPUT=TAPEIN,CONTROL=(CF1 CONTROL DATA,....CF5 CONTROL DATA)\n*OUTPUT=OUT1,OUT2,.....OUT7\n*START=HEX\n*START=RDW\n*SELECT=OUT1,CF1=\n*HEAD1=\n*HEAD2=\n*HEAD3=\n*\n*THE INPUT= STATEMENT IS USED TO SET UP THE SELECTION CRITERIA\n*FOR THE 1 TO 5 CONTROL FIELDS.\n*\n*THE OUTPUT= STATEMENT DETERMINES WHICH OF THE 7 OUTPUT\n*FILES WILL BE USED.\n*\n*THE START=HEX STATEMENT INDICATES THAT THE SEARCH STARTS\n*              AT OFFSET 0(THE RECORD LENGTH FIELD) AND THAT\n*              THE START POSITION IS IN HEXADECIMAL.\n*\n*THE START=RDW STATEMENT INDICATES THAT THE SEARCH STARTS\n*              AT OFFSET 0(THE RECORD LENGTH FIELD) AND THAT\n*              THE START POSITION IS IN DECIMAL.\n*\n*IF  START=RDW OR START=HEX IS NOT SPECIFIED, THE SEARCH\n*              STARTS AT OFFSET 5(THE RECORD DATA) AND THE\n*              START POSITION IS IN DECIMAL.\n*\n*THE SELECT= STATEMENT IS USED TO DETERMINE WHICH OUTPUT\n*FILE WILL RECEIVE THE DATA SELECTED BY THE SPECIFIED 1\n*TO 5 CONTROL FIELDS.\n*\n*THE HEAD1= STATEMENT IS USED TO CHANGE THE DEFAULT HEADING\n*ON THE OUT1 LISTING.\n*\n*THE HEAD2= STATEMENT IS USED TO CHANGE THE DEFAULT HEADING\n*ON THE OUT2 LISTING.\n*\n*THE HEAD3= STATEMENT IS USED TO CHANGE THE DEFAULT HEADING\n*ON THE OUT3 LISTING.\n*\n*THE FOLLOWING RESTRICTIONS MUST BE OBSERVED:\n*\n*OUT1, OUT2, OUT3 CAN ONLY BE SYSOUT=A FILES.\n*\n*OUT4, OUT5, OUT6 CAN ONLY BE VB FILES ON TAPE OR DISK.\n*\n*OUT7 CAN ONLY BE AN FB FILE ON TAPE OR DISK.\n*\n*ON THE OUTPUT= CARD, THE OUT'S MUST BE IN SEQUENCE.\n*\n*\n*THERE CAN BE 1 TO 5 CONTROL FIELDS IN THE CONTROL=(START,LENGTH,TYPE)\n*PARAMETER.\n*\n*START\n*START IS THE STARTING POSITION WITHIN THE RECORD.\n*IF THE START POSITION IS OUTSIDE THE LENGTH OF THE VB RECORD,\n*IT IS TREATED THE SAME AS CONDITION NOT MET.\n*\n*LENGTH\n*LENGTH IS THE NUMBER OF CHARACTERS IN THE FIELD.\n*\n*THE MAXIMUM LENGTH ALLOWED FOR ALPHANUMERIC FIELDS IS 111.\n*\n*THE MAXIMUM LENGTH ALLOWED FOR PACKED OR HEXADECIMAL FIELDS IS 16.\n*\n*FOR PACKED FIELDS, THE LENGTH IS THE NUMBER OF DIGITS IN THE\n*FIELD, NOT THE NUMBER OF BYTES IN THE FIELD...EG...A 2 BYTE\n*PACKED FIELD WILL HOLD 3 DIGITS...123C, SO THE LENGTH IS 3, NOT 2.\n*TO SPECIFY A POSITIVE(+) OR A NEGATIVE(-) PACKED NUMBER, THE LAST\n*DIGIT MUST CONSIST OF THE NUMBER AND A 12 OR 11 PUNCH. THIS CAN\n*BE ACCOMPLISHED BY USING THE CHARACTER '{' AND THE LETTERS\n*'A - I' TO DESIGNATE +0 TO +9  OR THE CHARACTER '}' AND THE\n*LETTERS 'J - R' TO DESIGNATE -0 TO -9. FOR EXAMPLE, TO SELECT +1230,\n*YOU WOULD CODE 123{, AND TO SELECT -1230 YOU WOULD CODE 123}. TO\n*SELECT +1234 YOU WOULD CODE 123D, AND TO SELECT -1879, YOU WOULD\n*CODE 187R.\n*THE CORRESPONDING LETTERS FOR THE POSITIVE AND NEGATIVE NUMBERS ARE:\n*     +0 = {            -0 = }\n*     +1 = A            -1 = J\n*     +2 = B            -2 = K\n*     +3 = C            -3 = L\n*     +4 = D            -4 = M\n*     +5 = E            -5 = N\n*     +6 = F            -6 = O\n*     +7 = G            -7 = P\n*     +8 = H            -8 = Q\n*     +9 = I            -9 = R\n*\n*FOR HEXADECIMAL FIELDS, THE LENGTH IS A MULTIPLE OF 2, AS IT TAKES\n*2 DIGITS TO REPRESENT 1 HEXADECIMAL DIGIT...EG...X'12' WOULD BE\n*12 IN YOUR CONTROL FIELD, SO THE LENGTH IS 2, NOT 1.\n*\n*TYPE\n*THE TYPE SPECIFIED CAN BE 1 OF THE FOLLOWING:\n*'A' TO INDICATE ALPHANUMERIC DATA,\n*'P' TO INDICATE PACKED DATA,\n*'H' TO INDICATE HEXADECIMAL DATA.\n*\n*THERE CAN BE 1 TO 5 SELECT STATEMENTS FOR EACH OUT FILE.\n*\n*RECORDS CAN BE SELECTED ON:\n*  1- ALL CONDITIONS           - CF1=ALL,...CF5=...\n*  2- EQUAL CONDITIONS         - CF1=(= ),...CF5=...\n*  3- GREATER THAN CONDITIONS  - CF1=(> ),...CF5=...\n*  4- LESS THAN CONDITIONS     - CF1=(< ),...CF5=...\n*  5- NOT EQUAL CONDITIONS     - CF1=(# ),...CF5=...\n*\n*THE ABILITY TO PUT A HEADING ON OUT1, OUT2, OUT3 HAS BEEN INCLUDED.\n*THE CONTROL CARDS ARE:\n*HEAD1=\n*HEAD2=\n*HEAD3=\n*THE HEADINGS CAN BE 1-74 CHARACTERS LONG. IF HEADING CARDS ARE NOT\n*INCLUDED, THE DEFAULTS ARE:\n*   HEAD1=RECORDS SPLIT TO OUT1\n*   HEAD2=RECORDS SPLIT TO OUT2\n*   HEAD3=RECORDS SPLIT TO OUT3\n*\n*\n*                         CONTROL CARDS EXAMPLE\n*\n*INPUT=TAPEIN,CONTROL=(1,1,A,59,6,A,72,5,P,32,2,H)\n*OUTPUT=OUT1,OUT2,OUT3,OUT4,OUT7\n*SELECT=OUT1,CF1=ALL\n*SELECT=OUT2,CF2=(>111100)\n*SELECT=OUT3,CF3=(<40406)\n*SELECT=OUT4,CF3=(=40405)\n*SELECT=OUT4,CF3=(=40405)\n*SELECT=OUT7,CF1=ALL\n*HEAD1=NEW HEADING FOR OUT1\n*\n*ADDITIONAL COPIES OF THIS DOCUMENTATION CAN BE OBTAINED BY LISTING\n*   HALL.SOURCE.CNTL(HOWVSPLT)\n*\n**********************************************************************\n         EJECT\nROOTSECT CSECT\n         SAVE  (14,12)\n         LR    R12,R15                  LOAD BASE REGISTER\n         USING ROOTSECT,R12             ESTABLISH ADDRESSABILITY\n         ST    R13,ROOTSAVE+4           CHAIN SAVE AREAS\n         LR    R11,R13                  *\n         LA    R13,ROOTSAVE             *\n         ST    R13,8(R11)               *\n         SPACE 2\n***********************************************************************\n*        CALL ROUTINE TO ANALYZE CONTROL CARDS AND TO SET UP          *\n*        THE TABLES USED TO PRINT THE REPORTS                         *\n***********************************************************************\n         SPACE\n         CALL  CTRLEDIT,(CONTROLS,SELECTS)\n         SPACE 2\n***********************************************************************\n*        CALL ROUTINE USED TO SELECT RECORDS AND PRODUCE ALL          *\n*        THE OUTPUTS                                                  *\n***********************************************************************\n         SPACE\n         CALL  VPRINT,(CONTROLS,SELECTS)\n         SPACE 2\n*                                       RETURN CONTROL TO SYSTEM\n         L     R13,ROOTSAVE+4           *\n         RETURN (14,12),RC=0            *\n         SPACE\nROOTSAVE DC    18F'0'                   REGISTER SAVE AREA\nR0       EQU   0                        REGISTER EQUATES\nR1       EQU   1                        *\nR2       EQU   2                        *\nR3       EQU   3                        *\nR4       EQU   4                        *\nR5       EQU   5                        *\nR6       EQU   6                        *\nR7       EQU   7                        *\nR8       EQU   8                        *\nR9       EQU   9                        *\nR10      EQU   10                       *\nR11      EQU   11                       *\nR12      EQU   12                       *\nR13      EQU   13                       *\nR14      EQU   14                       *\nR15      EQU   15                       *\n*\n*        THIS TABLE CONTAINS THE START POSITION WITHIN THE RECORD,\n*        THE LENGTH OF THE FIELD AND THE TYPE OF DATA FOR CF'S\n*        1 TO 5. WHEN FIRST CALLED, THE TABLE IS INITIALIZED AS\n*        FOLLOWS : START = 0, LENGTH = 0, TYPE = A\n*\nCONTROLS DS    0F\n         COPY  SDP10\n*\n*        THIS TABLE CONTAINS THE CF DISPLACEMENT, TYPE OF COMPARE\n*        (=,<,>), AND THE VALUE TO BE TESTED FOR IN THE CONTROL FIELD.\n*        THERE IS A SECTION FOR OUT1 - OUT6. EACH SECTION ALLOWS\n*        FOR 5 SETS OF CONTROL FIELDS. WHEN FIRST CALLED, EACH SECTION\n*        IS INITIALIZED AS FOLLOWS :\n*              CF DISPLACEMENT = 0 TO 36\n*              TYPE OF COMPARE = X'80'\n*              VALUE = 11X'FF'\n*\nSELECTS  DS    0F\n*                                       SELECT FOR OUT1\n         COPY  SDP20\n*                                       SELECT FOR OUT2\n         COPY  SDP20\n*                                       SELECT FOR OUT3\n         COPY  SDP20\n*                                       SELECT FOR OUT4\n         COPY  SDP20\n*                                       SELECT FOR OUT5\n         COPY  SDP20\n*                                       SELECT FOR OUT6\n         COPY  SDP20\n*                                       SELECT FOR OUT7\n         COPY  SDP20\n         END   ROOTSECT\n/*\n//*\n//STEP4 EXEC HLASMC,PARMC='XREF(FULL)'\n//ASM.SYSLIB DD\n//          DD\n//    DD DSN=&&T,DISP=(SHR,PASS)\n//ASM.SYSIN DD *\n         EJECT\n***********************************************************************\n*        E D I T   C O N T R O L   C A R D S                          *\n***********************************************************************\n         SPACE 2\nCTRLEDIT CSECT                          NAME CSECT\n         B     12+4(R0,R15)             BRANCH AROUND IDENTIFIER\n         DC    C'EDIT SECTION'\nA10SAVE  DS    0H\n         SAVE  (14,12)                  SAVE REGISTERS\n         BALR  R12,0                    LOAD BASE REGISTER\n         USING *,R12                    ESTABLISH ADDRESSABILITY\n         ST    R13,EDITSAVE+4           CHAIN SAVE AREAS\n         LR    R11,R13                  *\n         LA    R13,EDITSAVE             *\n         ST    R13,8(R11)               *\n         L     R5,0(0,R1)               LOAD TABLE BASE REG\n         USING TABLED,R5                ESTABLISH TABLE ADDRESSABILITY\n         SPACE 2\n         OPEN  (INFILE,,OUTFILE,(OUTPUT)) OPEN CONTROL FILES\n         SPACE\n         BAL   R11,Y10SKIP1             SKIP TO NEW PAGE\n         MVC   P(L'CTLHEAD),CTLHEAD     MOVE HEADING TO PRINT\n         BAL   R11,Y10WSP3              PRINT, SPACE 3\n         SPACE\nA20READ  DS    0H\n         GET   INFILE                   READ CONTROL CARD\n         LR    R2,R1                    MOVE RECORD ADDRESS TO REG 2\n         MVC   P(80),0(R1)              MOVE RECORD TO PRINT\n         BAL   R11,Y10WSP2              PRINT, SPACE 2\n         CLI   0(R2),C'*'         START WITH *?\n         BE    A20READ            YES, IT'S A COMMENT\n         CLI   0(R2),C'/'         START WITH /?\n         BE    A20READ            YES, IT'S A COMMENT\n         ST    R2,EDITSAVE        SAVE RECORD ADDRESS\n         SPACE\nA30      NOP   A60\nA40      NOP   A50\n         SPACE\n         CLC   0(6,R2),INPUT            IS CONTROL = INPUT= ?\n         BNE   A50                      NO, CHECK FOR OUTPUT=\n         SPACE\n         OI    A40+1,X'F0'              CHANGE A40 TO A BRANCH\n         BAL   R11,B10INPUT             EDIT INPUT CARD\n         B     A20READ                  READ NEXT CARD\n         SPACE\nA50      CLC   0(7,R2),OUTPUT           IS CONTROL = OUTPUT= ?\n         BNE   A60                      NO, CHECK FOR SELECT=\n         SPACE\n         OI    A30+1,X'F0'              CHANGE A30 TO A BRANCH\n         BAL   R11,C10OUT1              EDIT OUTPUT CARD\n         B     A20READ                  READ NEXT CARD\n         SPACE\nA60      DS    0H\n         CLC   0(7,R2),SELECT           IS CONTROL = SELECT=\n         BNE   A70HEAD1                 NO, CHECK FOR HEADING CARDS\n         SPACE\n         BAL   R11,D10SLECT             EDIT SELECT CARD\n         B     A20READ                  READ NEXT CARD\n         SPACE\nA70HEAD1 DS    0H\n         CLC   0(6,R2),HD1              CONTROL = HEAD1 ?\n         BNE   A70HEAD2                 NO, CHECK FOR HEAD2\n         MVC   HEAD1,6(R2)              STORE OUT1 HEADING\n         B     A20READ                  READ NEXT CONTROL CARD\n         SPACE\nA70HEAD2 DS    0H\n         CLC   0(6,R2),HD2              CONTROL = HEAD2 ?\n         BNE   A70HEAD3                 NO, CHECK FOR HEAD3\n         MVC   HEAD2,6(R2)              STORE OUT2 HEADING\n         B     A20READ                  READ NEXT CONTROL CARD\n         SPACE\nA70HEAD3 DS    0H\n         CLC   0(6,R2),HD3              CONTROL = HEAD3 ?\n         BNE   A75START                 NO, PRINT ERROR MESSAGE\n         MVC   HEAD3,6(R2)              STORE OUT3 HEADING\n         B     A20READ                  READ NEXT CONTROL CARD\n         SPACE\nA75START DS    0H\n         CLC   0(9,R2),STARTRDW         CONTROL = START=RDW ?\n         BNE   A76START                 NO, SEE IF START=HEX\n         MVI   STRTPOS,C'R'             YES, SAY START AT RDW\n         B     A20READ                  READ NEXT CONTROL CARD\n         SPACE 1\nA76START DS    0H\n         CLC   0(9,R2),STARTHEX         CONTROL = START=HEX ?\n         BNE   A80ERROR                 NO, PRINT ERROR MESSAGE\n         MVI   STRTPOS,C'H'             YES, SAY START AT RDW & HEX\n         B     A20READ                  READ NEXT CONTROL CARD\n         SPACE 1\nA80ERROR DS    0H\n         MVC   P(L'CTLMS1),CTLMS1       MOVE MESSAGE TO PRINT\n         BAL   R11,Y10WSP2              PRINT, SPACE 2\n         B     A20READ            GET NEXT CARD\n         SPACE 2\n***********************************************************************\n*        E N D   O F   C O N T R O L   C A R D S                      *\n***********************************************************************\n         SPACE 2\nA90END   DS    0H\n         MVC   P(L'CTLMS13),CTLMS13     MOVE MESSAGE TO PRINT\n         BAL   R11,Y10WSP3              PRINT, SPACE 3\n         SPACE\n         CLOSE (INFILE,,OUTFILE)        CLOSE FILES\n         L     R13,EDITSAVE+4           RETURN TO ROOT SEGMENT\n         RETURN (14,12),RC=0            *\n         EJECT\n***********************************************************************\n*        E D I T   I N P U T   C A R D                                *\n***********************************************************************\n         SPACE 2\nB10INPUT DS    0H\n         LA    R2,6(R2)                 ADD 6 TO RECORD ADDRESS\n         CLC   0(6,R2),TAPEIN           INPUT = TAPEIN\n         BE    B20CTL                   YES, CHECK FOR CONTROL=\n         SPACE\n         MVC   P(L'CTLMS2),CTLMS2       MVC MESSAGE TO PRINT\n         B     B90ABEND                 PRINT, SPACE 1, CANCEL JOB\n         SPACE\nB20CTL   DS    0H\n         LA    R2,7(R2)                 POINT TO CONTROL=\n         CLC   0(9,R2),CONTROL          IS CONTROL = CONTROL=( ?\n         BE    B30LA                    YES, STORE VALUES\n         SPACE\n         MVC   P(L'CTLMS3),CTLMS3       MOVE MESSAGE TO PRINT\n         B     B90ABEND                 PRINT, SPACE 1, CANCEL JOB\n         SPACE\nB30LA    DS    0H\n         LA    R10,CONTROLS             LOAD ADDRESS CONTROL TABLE\n         LA    R2,9(R2)                 POINT TO START LOCATION\nB40LOOP  DS    0H\n         LR    R3,R2                    STORE START ADDRESS\nB41      DS    0H\n         CLI   0(R2),C'0'               IS DIGIT LESS THAN 0 ?\n         BL    B42                      YES, CHECK FOR COMMA\n         SPACE\n         CLI   0(R2),C'9'               IS DIGIT GREATER THAN 9 ?\n         BH    B50ERROR                 YES, GO TO ERROR ROUTINE\n         SPACE\n         LA    R2,1(R2)                 POINT TO NEXT DIGIT\n         B     B41                      CHECK NEXT DIGIT\n*\nB42      DS    0H\n         CLI   STRTPOS,C'H'       START AT RDW & OFFSET IN HEX?\n         BNE   B43                NO, CAN JUST HAVE COMMA\n*        BNE   B50ERROR           NO, GO TO ERROR ROUTINE\n*\n         CLI   0(R2),C'A'               IS DIGIT LESS THAN A ?\n         BL    B43                      YES, CHECK FOR COMMA\n         SPACE\n         CLI   0(R2),C'F'               IS DIGIT GREATER THAN F ?\n         BH    B50ERROR                 YES, GO TO ERROR ROUTINE\n         SPACE\n         LA    R2,1(R2)                 POINT TO NEXT DIGIT\n         B     B42                      CHECK NEXT DIGIT\n*\nB43      DS    0H\n         CLI   0(R2),C','               IS DIGIT = , ?\n         BNE   B50ERROR                 NO, GO TO ERROR ROUTINE\n         SPACE\n         LR    R4,R2                    CALCULATE NUMBER OF DIGITS\n         SR    R4,R3                    IN START LOCATION PARAMETER\n         CLI   STRTPOS,C'H'       START AT RDW & OFFSET IN HEX?\n         BNE   B43A               NO, ON WE GO\n         XC    DWORD,DWORD        CLEAR DWORD\n         XC    TRANDATA,TRANDATA  CLEAR TRANDATA\n         SR    R15,R15            CLEAR R15\n         LA    R15,DWORD+4        R15 -> AT END OF DWORD\n         LA    R15,TRANDATA+4     R15 -> AT END OF DWORD\n*        SRL   R4,1               DIVIDE BY FOR (HEX DATA)\n         SR    R15,R4             R15 -> WHERE DATA GOES\n*        SLL   R4,1               PUT BACK\n         BCTR  R4,0               SUBTRACT 1 TO GET MACHINE LGTH\n         EX    R4,MVCDATA         PUT CHAR DATA IN DWORD\n*        EX    R4,LOADDATA        PUT CHAR DATA IN R15\n*        ST    R15,DWORD+4        PUT IT IN DWORD\n*        EX    R4,TRHEX2          TRANSLATE INPUT TO 00-0F\n*        TR    DWORD,TRTAB        TRANSLATE TO 00-0F\n         TR    TRANDATA(4),TRTAB2 TRANSLATE TO 00-0F\n         PACK  DWORD(5),TRANDATA(5) PACK FIELD\n         L     R4,DWORD           PUT IT IN R4\n*        L     R4,DWORD+4         PUT IT IN R4\n*        LA    R15,1(0,R7)        R15 = REAL LTH OF INPUT\n*        C     R15,MAXPACK        AT MAX LTH OF 16 ?\n*        BE    F50MAX             YES, TREAT DIFFERENTLY\n*        EX    R15,F50PACK        NO, PACK ALL OF FIELD\n*        BCTR  R4,0                     SUBTRACT 1 TO GET MACHINE LGTH\n*        EX    R4,B48PACK               PACK START LOC IN DOUBLE WORD\n*        CVB   R4,DWORD                 CONVERT TO BINARY\n*        SRL   R4,8               DROP GARBAGE BYTE\n         B     B43C               GO SAVE HEX OFFSET\nTRHEX2   TR    TRANDATA(0),TRTAB2 TRANSLATE TO 00-0F\nMVCDATA  MVC   0(0,R15),0(R3)     SET UP DATA FOR TRANSLATE\n*VCDATA  MVC   DWORD(0),0(R3)     SET UP DATA FOR TRANSLATE\nLOADDATA ICM   R15,0,0(R3)        PUT DATA IN R15\nB10PACK  PACK  DWORD,TRANDATA(4)        PACK FIELD\nTRANDATA DC    D'0'\n*RTAB2   EQU   *-193              SET START OF SHORT TRANS TABLE\nTRTAB2   DS    0XL256             SET START OF SHORT TRANS TABLE\n         DC    X'00'              CHANGE 00 TO 00\n         DC    XL192'00'          CHANGE 01-C0 TO 00\n         DC    X'FAFBFCFDFEFF'    CHANGE C1-C6 TO FA-FF\n         DC    41X'00'            CHANGE C7-EF TO 00\n         DC    X'F0F1F2F3F4F5F6F7F8F9'   CHANGE F0-F9 TO F0-F9\n         DC    XL(256-(*-TRTAB2))'00'    CHANGE FA-FF TO 00\n*\nB43A     DS    0H\n         BCTR  R4,0                     SUBTRACT 1 TO GET MACHINE LGTH\n         EX    R4,B48PACK               PACK START LOC IN DOUBLE WORD\n         CVB   R4,DWORD                 CONVERT TO BINARY\n         BCTR  R4,0                     SUBT 1 TO GIVE MACHINE LENGTH\n*\nB43C     DS    0H\n         ST    R4,0(R10)                STORE START LOCATION IN TABLE\n         SPACE\n         LA    R2,1(R2)                 POINT TO LENGTH PARAMETER\n         LR    R3,R2                    STORE START OF LENGTH PARM\nB44      DS    0H\n         CLI   0(R2),C'0'               DIGIT LESS THAN 0 ?\n         BL    B46                      YES, CHECK FOR COMMA\n         SPACE\n         CLI   0(R2),C'9'               DIGIT GREATER THAN 9 ?\n         BH    B60ERROR                 YES, GO TO ERROR ROUTINE\n         SPACE\n         LA    R2,1(R2)                 POINT TO NEXT DIGIT\n         B     B44                      CHECK NEXT DIGIT\nB46      DS    0H\n         CLI   0(R2),C','               DIGIT A COMMA ?\n         BNE   B60ERROR                 NO, GO TO ERROR ROUTINE\n         SPACE\n         LR    R4,R2                    CALCULATE NUMBER OF DIGITS\n         SR    R4,R3                    IN LENGTH PARAMETER\n         SPACE\n         BCTR  R4,0                     SUBTRACT 1 TO GET MACHINE LTH\n         EX    R4,B48PACK               PACK LENGTH PARM IN DOUBLE WORD\n         CVB   R4,DWORD                 CONVERT TO BINARY\n         CLI   1(R2),C'A'               IS TYPE = A ?\n         BNE   B47PACK                  NO, MAXLEN = 16\n         C     R4,MAXLEN                LENGTH OVER MAXIMUM LTH ?\n         BH    B70ERROR                YES, GO TO ERROR ROUTINE\n         SPACE 1\nB47      DS    0H\n         L     R3,ADDLTH          R3 = LTH OF DATA TO ADD\n         AR    R3,R4              ADD THIS LTH\n         ST    R3,ADDLTH          SAVE NEW LTH TO ADD\n         BCTR  R4,0                     SUBT 1 TO GIVE MACHINE LENGTH\n         ST    R4,4(R10)                STORE LENGTH IN TABLE\n         SPACE\n         LA    R2,1(R2)                 POINT TO TYPE PARAMETER\n         CLI   0(R2),C'P'               IS TYPE = P ?\n         BE    B80STORE                 YES, STORE TYPE\n         SPACE\n         CLI   0(R2),C'A'               IS TYPE = A ?\n         BE    B80STORE                 YES, STORE TYPE\n         SPACE\n         CLI   0(R2),C'H'         IS TYPE = H ?\n         BE    B80STORE           YES, STORE TYPE\n         BAL   R11,G10SET2        POINT R2 TO WHERE ERROR MSG GOES\n         MVC   0(L'CTLMS4,R2),CTLMS4     MOVE MESSAGE TO PRINT\n         B     B90ABEND                 PRINT, SPACE 1, CANCEL JOB\n         SPACE 1\nB47PACK  DS    0H\n         C     R4,MAXPACK         IS LTH OVER 16 ?\n         BH    B75ERROR           YES, TOO BAD\n         CLI   1(R2),C'P'         PACKED DATA ?\n         BE    B47PACK2           YES, FIX PACKED LENGTH\n         SRL   R4,1               HEX LTH = LTH/2\n         B     B47                LTH NOW OKAY\n         SPACE 1\nB47PACK2 DS    0H\n         LA    R4,1(0,R4)         MAKE LTH EVEN\n         SRL   R4,1               LTH/2 = PACKED LTH\n         B     B47                PACKED LTH OKAY NOW TOO\n         SPACE 2\nB48PACK  PACK  DWORD,0(0,R3)            PACK FIELD\n         SPACE 2\nB50ERROR DS    0H\n         BAL   R11,G10SET2        POINT R2 TO WHERE ERROR MSG GOES\n         MVC   0(L'CTLMS6,R2),CTLMS6    PUT MSG UNDER BAD CHAR\n         B     B90ABEND                 PRINT, SPACE 1, CANCEL JOB\n         SPACE\nB60ERROR DS    0H\n         BAL   R11,G10SET2        POINT R2 TO WHERE ERROR MSG GOES\n         MVC   0(L'CTLMS7,R2),CTLMS7    PUT MSG UNDER BAD CHAR\n         B     B90ABEND                 PRINT, SPACE 1, CANCEL JOB\n         SPACE\nB70ERROR DS    0H\n         BAL   R11,G10SET2        POINT R2 TO WHERE ERROR MSG GOES\n         MVC   0(L'CTLMS9,R2),CTLMS9    PUT MSG UNDER BAD CHAR\n         B     B90ABEND                 PRINT, SPACE 1, CANCELL JOB\n         SPACE\nB75ERROR DS    0H\n         BAL   R11,G10SET2        POINT R2 TO WHERE THE ERROR MSG GOES\n         MVC   0(L'CTLMS9),CTLMS9 MOVE MESSAGE TO PRINT LINE\n         MVI   23(R2),C'6'        CHANGE LTH IN MSG TO 16\n         MVI   24(R2),C' '        *\n         B     B90ABEND           PRINT MSG, CANCEL JOB\n         SPACE 1\nB80STORE DS    0H\n         MVC   8(1,R10),0(R2)           STORE TYPE IN TABLE\n         CLI   1(R2),C','               ANY MORE PARAMETERS ?\n         BCR   7,R11                    NO, RETURN TO CALLER\n         SPACE 2\n         LA    R10,12(R10)              POINT TO NEXT CONTROL FIELD\n         LA    R2,2(R2)                 POINT TO NEXT START PARM\n         AP    CFCTR,ONE                ADD 1 TO CONTROL FIELD CTR\n         CP    CFCTR,FIVE               OVER 5 PARAMETERS ?\n         BNH   B40LOOP                  NO, PROCESS NEXT FIELD\n         SPACE\n         MVC   P(L'CTLMS5),CTLMS5       MOVE MESSAGE TO PRINT\n         BAL   R11,Y10WSP1              PRINT, SPACE 1\n         SPACE\nB90ABEND BAL   R11,Y10WSP1              PRINT, SPACE 1\n         ABEND 16                       CANCEL JOB\n         EJECT\n***********************************************************************\n*        E D I T   O U T P U T   C O N T R O L   C A R D              *\n***********************************************************************\n         SPACE 2\nC10OUT1  DS    0H\n         MVI   OPENFLGS,X'00'           CLEAR OPEN FLAGS\n         LA    R2,7(R2)                 POINT TO OUTPUT FILES\n         CLC   0(4,R2),OUT1             USING FILE OUT1 ?\n         BNE   C20OUT2                  NO, CHECK FOR OUT2.\n         SPACE\n         OI    OPENFLGS,B'10000000'     TURN OPEN OUT1 FLAG ON\n         LA    R2,5(R2)                 POINT TO NEXT FILE NAME\n         SPACE\nC20OUT2  DS    0H\n         CLC   0(4,R2),OUT2             USING FILE OUT2 ?\n         BNE   C30OUT3                  NO, CHECK FOR OUT3\n         SPACE\n         OI    OPENFLGS,B'01000000'     TURN OPEN OUT2 FLAG ON\n         LA    R2,5(R2)                 POINT TO NEXT FILE NAME\nC30OUT3  DS    0H\n         CLC   00(4,R2),OUT3            USING FILE OUT3 ?\n         BNE   C40OUT4                  NO, CHECK FOR OUT4\n         SPACE\n         OI    OPENFLGS,B'00100000'     TURN OPEN OUT3 FLAG ON\n         LA    R2,5(R2)                 POINT TO NEXT FILE NAME\n         SPACE\nC40OUT4  DS    0H\n         CLC   00(4,R2),OUT4            USING FILE OUT4 ?\n         BNE   C50OUT5                  NO, CHECK FOR OUT5\n         SPACE\n         OI    OPENFLGS,B'00010000'     TURN OPEN OUT4 FLAG ON\n         LA    R2,5(R2)                 POINT TO NEXT FILE NAME\n         SPACE\nC50OUT5  DS    0H\n         CLC   00(4,R2),OUT5            USING FILE OUT5 ?\n         BNE   C60OUT6                  NO, CHECK FOR OUT6\n         SPACE\n         OI    OPENFLGS,B'00001000'    TURN OPEN OUT5 FLAG ON\n         LA    R2,5(R2)                 POINT TO NEXT FILE NAME\nC60OUT6  DS    0H\n         CLC   00(4,R2),OUT6            USING FILE OUT6 ?\n         BNE   C60OUT7                  NO, CHECK FOR OUT7\n         SPACE\n         OI    OPENFLGS,B'00000100'     TURN OPEN OUT6 FLAG ON\n         LA    R2,5(R2)                 POINT TO NEXT FILE NAME\n         SPACE\nC60OUT7  DS    0H\n         CLC   0(4,R2),OUT7             USING FILE OUT7 ?\n         BNE   C70END                   NO, CHECK FOR END OF INPUT\n         SPACE\n         OI    OPENFLGS,X'02'           TURN OPEN OUT7 FLAG ON\n         LA    R2,5(0,R2)         POINT TO NEXT FILE NAME\n         SPACE\nC70END   DS    0H\n         CLI   0(R2),C' '               AT END OF CONTROL CARD ?\n         BE    C90END                   YES, RETURN TO CALLER\n         SPACE\n         MVC   P(L'CTLMS8),CTLMS8       MOVE MESSAGE TO PRINT\n         BAL   R11,Y10WSP1              PRINT, SPACE 1\n         ABEND 16                       CANCEL JOB\nC90END   BR    R11                      RETURN TO CALLER\n         EJECT\n***********************************************************************\n*        E D I T   S E L E C T   C O N T R O L   C A R D              *\n***********************************************************************\n         SPACE 2\nD10SLECT DS    0H\n         LA    R3,SELECTS               LOAD ADDRESS SELECT TABLE\n         LA    R2,7(R2)                 POINT TO SELECTED FILE NAME\n         CLC   0(4,R2),OUT1             FILE = OUT1 ?\n         BNE   D20OUT2                  NO, CHECK FOR OUT2\n         SPACE\n         LA    R9,OUT1CTR               LOAD ADDRESS OUT1 COUNTER\nD10LOOP  DS    0H\n         LA    R2,5(R2)                 POINT TO CF\n         BAL   R10,F10EDIT              EDIT CONTROL FIELDS\n         L     R15,0(0,R9)              LOAD COUNTER IN REG 15\n         LA    R10,4                    R10 = 4\n         CR    R15,R10                  IF SELECT COUNTER > 4\n         BH    D85ERROR                 BOMB RUN\n         SPACE\n         M     R14,ENTLTH               MULTIPLY BY TABLE ENTRY LENGTH\n         AR    R3,R15                   ADD DISP TO SELECT BASE REG\n         CLI   CFWK1,X'FF'              IS CONTROL FIELD 1 USED\n         BE    D12CF2                   NO, CHECK CF2\n         SPACE\n         MVC   4(L'CFWK1,R3),CFWK1           STORE CF1\n         SPACE\nD12CF2   DS    0H\n         LA    R3,116(R3)                POINT TO CF2\n         CLI   CFWK2,X'FF'              CONTROL FIELD 2 USED ?\n         BE    D14CF3                   NO, CHECK FOR CF3\n         SPACE\n         MVC   4(L'CFWK2,R3),CFWK2           STORE CF2\n         SPACE\nD14CF3   DS    0H\n         LA    R3,116(R3)                POINT TO CF3\n         CLI   CFWK3,X'FF'              CONTROL FIELD 3 USED ?\n         BE    D16CF4                   NO, CHECK FOR CF4\n         SPACE\n         MVC   4(L'CFWK3,R3),CFWK3      STORE CF3\n         SPACE\nD16CF4   DS    0H\n         LA    R3,116(R3)                POINT TO CF4\n         CLI   CFWK4,X'FF'              CONTROL FIELD 4 USED ?\n         BE    D18CF5                   NO, CHECK FOR CF5\n         SPACE\n         MVC   4(L'CFWK4,R3),CFWK4      STORE CF4\n         SPACE\nD18CF5   DS    0H\n         LA    R3,116(R3)                POINT TO CF5\n         CLI   CFWK5,X'FF'              CONTROL FIELD 5 USED ?\n         BE    D19ADD                   NO, ADD 1 TO COUNTER\n         SPACE\n         MVC   4(L'CFWK5,R3),CFWK5      STORE CF5\n         SPACE\nD19ADD   DS    0H\n         L     R10,0(0,R9)              ADD 1 TO OUT  COUNTER\n         LA    R10,1(R10)               *\n         ST    R10,0(0,R9)              *\n         B     D80END                   RETURN TO CALLER\n         SPACE\nD20OUT2  DS    0H\n         LA    R3,2900(0,R3)         POINT TO OUT2 SELECT\n         CLC   0(4,R2),OUT2             FILE = OUT2 ?\n         BNE   D30OUT3                  NO, CHECK FOR OUT3\n         SPACE\n         LA    R9,OUT2CTR               LOAD ADDRESS OUT2 COUNTER\n         B     D10LOOP                  PROCESS CF'S\n         SPACE\nD30OUT3  DS    0H\n         LA    R3,2900(0,R3)         POINT TO OUT3 SELECT\n         CLC   0(4,R2),OUT3             FILE = OUT3 ?\n         BNE   D40OUT4                  NO, CHECK FOR OUT4\n         SPACE\n         LA    R9,OUT3CTR               LOAD ADDRESS OUT3 COUNTER\n         B     D10LOOP                  PROCESS\n         SPACE\nD40OUT4  DS    0H\n         LA    R3,2900(0,R3)         POINT TO OUT4 SELECT\n         CLC   0(4,R2),OUT4             FILE = OUT4 ?\n         BNE   D50OUT5                  NO, CHECK FOR OUT5\n         SPACE\n         LA    R9,OUT4CTR               LOAD ADDRESS OUT4 COUNTER\n         B     D10LOOP                  PROCESS OUT4\n         SPACE\nD50OUT5  DS    0H\n         LA    R3,2900(0,R3)         POINT TO OUT5 SELECT\n         CLC   0(4,R2),OUT5             FILE = OUT5 ?\n         BNE   D60OUT6                  NO, CHECK FOR OUT6\n         SPACE\n         LA    R9,OUT5CTR               LOAD ADDRESS OUT5 COUNTER\n         B     D10LOOP                  PROCESS OUT5\n         SPACE\nD60OUT6  DS    0H\n         LA    R3,2900(0,R3)         POINT TO OUT6 SELECT\n         CLC   0(4,R2),OUT6             FILE = OUT6 ?\n         BNE   D70OUT7                  NO, CHECK FOR OUT7\n         SPACE\n         LA    R9,OUT6CTR               LOAD ADDRESS OUT6 COUNTER\n         B     D10LOOP                  PROCESS OUT6\n         SPACE\nD70OUT7  DS    0H\n         LA    R3,2900(0,R3)         POINT TO OUT7 SELECT\n         CLC   0(4,R2),OUT7       FILE = OUT7 ?\n         BNE   D90ERROR           NO, PRINT ERROR MSG\n         SPACE 1\n         LA    R9,OUT7CTR               LOAD ADDR OUT7 COUNTER\n         B     D10LOOP                  PROCESS OUT7\n         SPACE\nD80END   DS    0H\n         BR    R11                      RETURN TO CALLER\n         SPACE\nD90ERROR DS    0H\n         MVC   P(L'CTLMS8),CTLMS8       MOVE MESSAGE TO PRINT\nD95      DS    0H\n         BAL   R11,Y10WSP1              PRINT, SPACE 1\n         ABEND 16                       CANCEL JOB\n         SPACE\nD85ERROR DS    0H\n         MVC   P(L'CTLMS14),CTLMS14     PRINT ERROR MESSAGE\n         B     D95                      *\n         EJECT\n***********************************************************************\n*        E D I T   C O N T R O L   F I E L D S                        *\n***********************************************************************\n         SPACE 2\nF10EDIT  DS    0H\n         MVC   CFWK1(112),WKFILL         INITIALIZE WORK AREAS\n         MVC   CFWK2(112),WKFILL         INITIALIZE WORK AREAS\n         MVC   CFWK3(112),WKFILL         INITIALIZE WORK AREAS\n         MVC   CFWK4(112),WKFILL         INITIALIZE WORK AREAS\n         MVC   CFWK5(112),WKFILL         INITIALIZE WORK AREAS\n         CLC   0(4,R2),CF1              CONTROL FIELD 1 ?\n         BNE   F20CF2                   NO, CHECK FOR CF2\n         LA    R8,CFWK1                 LOAD ADDRESS WORK 1\n         L     R7,LENGTH1               LOAD LENGTH\n         LA    R14,TYPE1          R14 -> TO TYPE FIELD\n         BAL   R6,F10LOOP               CHECK CF1\n         B     F20CF2\nF10LOOP  LA    R2,4(R2)                 POINT TO COMPARE OPERAND\n         CLC   0(3,R2),ALL              CF = ALL ?\n         BNE   F12                      NO, EDIT CF1\n         LA    R2,4(R2)                 POINT TO NEXT CF\n         MVI   0(R8),C'0'               ZERO WORK AREA\n         MVC   1(111,R8),0(R8)          *\n         BR    R6                       RETURN\nF12      DS    0H\n         CLI   0(R2),C'('               LEFT BRACKET ?\n         BNE   F60ERROR                 NO, PRINT MESSAGE\n         SPACE\n         LA    R2,1(R2)                 POINT TO COMPARE OPERAND\n         CLI   0(R2),C'='               EQUAL COMPARE ?\n         BNE   F14                      NO, CHECK FOR <\n         MVI   0(R8),X'80'              SET COMPARE CODE\n         B     F18\nF14      DS    0H\n         CLI   0(R2),C'<'               LESS THAN COMPARE ?\n         BNE   F16                      NO, CHECK FOR >\n         MVI   0(R8),X'40'              SET COMPARE CODE\n         B     F18\nF16      DS    0H\n         CLI   0(R2),C'>'               GREATER THAN COMPARE ?\n         BNE   F17                      NO, CHECK FOR \\\n         MVI   0(R8),X'20'              SET COMPARE CODE\n         B     F18\n         SPACE\nF17      DS    0H\n         CLI   0(R2),C'#'               NOT EQUAL COMPARE ?\n         BNE   F70ERROR                 NO, PRINT ERROR MESSAGE\n         MVI   0(R8),X'70'              SET COMPARE NOT EQUAL CODE\n         SPACE\nF18      LA    R2,1(R2)                 POINT TO COMPARE VALUE\n         LA    R8,1(R8)                 POINT TO VALUE WORK AREA\n         CLI   0(R14),C'A'        IS IT CHARACTER DATA?\n         BNE   F50HEX             NO, CHECK FOR HEX OR PACKED\n         EX    R7,F20                   MVC VALUE TO WORK AREA\nF19      DS    0H\n         AR    R2,R7                    POINT TO CLOSING BRACKET\n         LA    R2,1(R2)                 *\n         CLI   0(R2),C')'               CLOSING BRACKET ?\n         BNE   F60ERROR                 NO, PRINT MESSAGE\n         SPACE\nF19NEXT  DS    0H\n         LA    R2,2(R2)                 POINT TO NEXT CF\n         BR    R6                       RETURN TO CALLER\n         SPACE\nF20      MVC   0(0,R8),0(R2)            MOVE VALUE TO WORKAREA\n         SPACE\nF20CF2   DS    0H\n         CLC   0(4,R2),CF2              CF2 ?\n         BNE   F30CF3                   NO, CHECK FOR CF3\n         SPACE\n         LA    R8,CFWK2                 LOAD ADDRESS WORK 2\n         L     R7,LENGTH2               LOAD LENGTH 2\n         LA    R14,TYPE2          R14 -> TO TYPE FIELD\n         BAL   R6,F10LOOP               CHECK CF2\n         SPACE\nF30CF3   DS    0H\n         CLC   0(4,R2),CF3              CF3 ?\n         BNE   F40CF4                   NO, CHECK FOR CF4\n         LA    R8,CFWK3                 LOAD ADDRESS WORK 3\n         L     R7,LENGTH3               LOAD LENGTH 3\n         LA    R14,TYPE3          R14 -> TO TYPE FIELD\n         BAL   R6,F10LOOP               CHECK CF3\nF40CF4   DS    0H\n         CLC   0(4,R2),CF4              CF4 ?\n         BNE   F50CF5                   NO, CHECK FOR CF5\n         LA    R8,CFWK4                 LOAD ADDRESS WORK 4\n         L     R7,LENGTH4               LOAD LENGTH 4\n         LA    R14,TYPE4          R14 -> TO TYPE FIELD\n         BAL   R6,F10LOOP               CHECK CF4\n         SPACE\nF50CF5   DS    0H\n         CLC   0(4,R2),CF5              CF5 ?\n         BNE   F80ERROR                 NO, CHECK FOR END OF SELECT\n         LA    R8,CFWK5                 LOAD ADDRESS WORK 5\n         L     R7,LENGTH5               LOAD LENGTH 5\n         LA    R14,TYPE5          R14 -> TO TYPE FIELD\n         BAL   R6,F10LOOP               CHECK CF5\n         BR    R10                      RETURN TO CALLER\n         SPACE 2\nF50HEX   DS    0H\n         CLI   0(R14),C'P'        IS DATA PACKED ?\n         BE    F51PACK            YES, SET UP PACKED DATA\n         SPACE 1\n         LA    R7,1(0,R7)         ADD 1 TO R7\n         SLL   R7,1               R7*2 = REAL INPUT LTH\n         BCTR  R7,0               R7 = HEX LTH OF INPUT\n         SPACE 1\n         EX    R7,TRHEX           TRANSLATE INPUT TO 00-0F\n         LA    R15,1(0,R7)        R15 = REAL LTH OF INPUT\n         C     R15,MAXPACK        AT MAX LTH OF 16 ?\n         BE    F50MAX             YES, TREAT DIFFERENTLY\n         EX    R15,F50PACK        NO, PACK ALL OF FIELD\n         SPACE 1\nF50HEX2  DS    0H\n         SRL   R15,1              LTH/2 = LTH OF HEX FIELD\n         LA    R14,CTLHEAD+14     R14 -> TO LAST BYTE OF HEX DATA\n         SR    R14,R15            R14 -> TO FIRST BYTE OF HEX DATA\n         BCTR  R15,0              R15 = HEX LTH\n         EX    R15,F50MOVE        MOVE HEX VALUE TO WORK AREA\n         B     F19                DO REST OF EDIT\n         SPACE 1\nF50MAX   DS    0H\n         PACK  CTLHEAD(5),0(9,R2) PACK 1ST 8 DIGITS\n         PACK  CTLHEAD+4(5),8(9,R2) PACK 2ND 8 DIGITS\n         MVC   0(8,R8),CTLHEAD    MOVE HEX CHARS TO WORK AREA\n         B     F19                DO REST OF EDIT\n         SPACE 1\nF51PACK  DS    0H\n         SLL   R7,1               R7*2 = HEX LTH OF IN INPUT\n         EX    R7,F50PACK         PACK INPUT DATA\n         LR    R15,R7             R15 = LTH\n         SRL   R15,1              LTH /2 = PACKED LTH\n         LA    R14,CTLHEAD+14     R14 -> TO LAST PACKED BYTE\n         SR    R14,R15            R14 -> TO FIRST PACKED BYTE\n         EX    R15,F50MOVE        MOVE PACKED DATA TO WORK AREA\n         B     F19                DO REST OF EDIT\n         SPACE 2\nTRHEX    TR    0(0,R2),TRTAB      TRANSLATE TO 00-0F\nF50PACK  PACK  CTLHEAD(15),0(0,R2)  PACK INPUT\nF50MOVE  MVC   0(0,R8),0(R14)     MOVE TO TABLE AREA\n         SPACE 2\nF60ERROR DS    0H\n         BAL   R11,G10SET2        POINT R2 TO WHERE ERROR MSG GOES\n         MVC   0(L'CTLMS10,R2),CTLMS10  PUT ERROR MSG UNDER BAD CHAR\n         B     F90WRITE                 PRINT, CANCEL JOB\n         SPACE\nF70ERROR DS    0H\n         BAL   R11,G10SET2        POINT R2 TO WHERE ERROR MSG GOES\n         MVC   0(L'CTLMS11,R2),CTLMS11  PUT ERROR MSG UNDER BAD CHAR\n         B     F90WRITE                 PRINT, CANCEL JOB\n         SPACE\nF80ERROR DS    0H\n         CLI   0(R2),C' '               ANY MORE FIELDS ?\n         BCR   8,R10                    NO, RETURN TO CALLER\n         SPACE\n         BAL   R11,G10SET2        POINT R2 TO WHERE ERROR MSG GOES\n         MVC   0(L'CTLMS12,R2),CTLMS12  PUT ERROR MSG UNDER BAD CHAR\nF90WRITE DS    0H\n         BAL   R11,Y10WSP1              PRINT, SPACE 1\n         ABEND 16                       CANCEL JOB\n         EJECT\n***********************************************************************\n*        POINT R2 TO THE PRINT POSITION AT WHICH THE ERROR OCCURRED   *\n***********************************************************************\n         SPACE 2\nG10SET2  DS    0H\n         S     R2,EDITSAVE        R2 = DISP TO BAD CHARACTER\n         LA    R2,P(R2)           R2 -> TO WHERE ERROR MSG GOES\n         BR    R11                RETURN TO CALLER\n         EJECT\n***********************************************************************\n*        P R I N T   C O N T R O L   R O U T I N E                    *\n***********************************************************************\n         SPACE 2\nY10SKIP1 DS    0H\n         MVI   CTLCHR,X'8B'             SKIP TO CHANNEL 1\n         B     Y40\n         SPACE\nY10WSP1  DS    0H\n         MVI   CTLCHR,X'09'             PRINT, SPACE 1\n         B     Y40\n         SPACE\nY10WSP2  DS    0H\n         MVI   CTLCHR,X'11'             PRINT, SPACE 2\n         B     Y40\n         SPACE\nY10WSP3  DS    0H\n         MVI   CTLCHR,X'19'             PRINT, SPACE 3\n         SPACE\nY40      DS    0H\n         PUT   OUTFILE,PRINT            PRINT\n         MVI   P,C' '                   CLEAR PRINT BUFFER\n         MVC   P+1(L'P-1),P             *\n         SPACE\n         BR    R11                      RETURN TO CALLER\n         EJECT\n***********************************************************************\n*        F I L E   D E C L A R E S                                    *\n***********************************************************************\n         SPACE 2\n         PRINT NOGEN\nINFILE   DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GL,EODAD=A90END\nOUTFILE  DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,RECFM=FBM,LRECL=133,  +\n               BLKSIZE=9310\n         PRINT GEN\n         SPACE 2\n***********************************************************************\n*              D E C L A R A T I V E S                                *\n***********************************************************************\n         SPACE\nEDITSAVE DC    18F'0'\nELEVEN   DC    F'11'\nMAXLEN   DC    F'111'\nDWORD    DC    D'0'\nMAXPACK  DC    F'16'\n         ENTRY ADDLTH\nADDLTH   DC    F'0'               LTH OF DATA TO ADD\nCTLHEAD  DC    C'*****  CONTROL STATEMENT LISTING  *****'\nPRINT    DS    0CL133\nCTLCHR   DC    X'09'\nP        DC    CL132' '\nINPUT    DC    C'INPUT='\nOUTPUT   DC    C'OUTPUT='\nSELECT   DC    C'SELECT='\nTAPEIN   DC    C'TAPEIN'\nCONTROL  DC    C'CONTROL=('\nHD1      DC    C'HEAD1='\nHD2      DC    C'HEAD2='\nHD3      DC    C'HEAD3='\nSTARTRDW DC    C'START=RDW'       START AT POS 1, OFFSET IN DECIMAL\nSTARTHEX DC    C'START=HEX'       START AT POS 0, OFFSET IN HEX\nCFCTR    DC    P'1'\nONE      DC    P'1'\nFIVE     DC    P'5'\nALL      DC    C'ALL'\nCTLMS1   DC    C'       INVALID CONTROL CARD IGNORED '\nCTLMS2   DC    C'       DDNAME MUST BE TAPEIN'\nCTLMS3   DC    C'       INVALID CONTROL'\nCTLMS4   DC    C'TYPE NOT P, H OR A'\nCTLMS5   DC    C'       ONLY 5 CONTROL FIELDS ALLOWED'\nCTLMS6   DC    C'START LOCATION NOT NUMERIC OR HEXADECIMAL'\nCTLMS7   DC    C'LENGTH NOT NUMERIC'\nCTLMS8   DC    C'       INVALID FILE NAME'\nCTLMS9   DC    C' LENGTH CANNOT EXCEED 111'\nCTLMS10  DC    C'CF VALUE NOT IN ( ) OR SIZE NOT = TO CONTROL SIZE'\nCTLMS11  DC    C'COMPARE OPERAND MUST BE = # > OR <'\nCTLMS12  DC    C'CF FIELD MUST BE CF1 - CF5'\nCTLMS13  DC    C'*****  END OF CONTROL CARD LISTING  *****'\nCTLMS14  DC    C'       ONLY 5 SELECTS PER FILE ALLOWED'\nOUT1     DC    C'OUT1'\nOUT2     DC    C'OUT2'\nOUT3     DC    C'OUT3'\nOUT4     DC    C'OUT4'\nOUT5     DC    C'OUT5'\nOUT6     DC    C'OUT6'\nOUT7     DC    C'OUT7'\nCFWK1    DS    CL112\nCFWK2    DS    CL112\nCFWK3    DS    CL112\nCFWK4    DS    CL112\nCFWK5    DS    CL112\nENTLTH   DC    F'580'\nWKFILL   DC    112X'FF'\nCF1      DC    C'CF1='\nCF2      DC    C'CF2='\nCF3      DC    C'CF3='\nCF4      DC    C'CF4='\nCF5      DC    C'CF5='\nZEROS    DC    12C'0'\nTRTAB    EQU   *-193              SET START OF SHORT TRANS TABLE\n         DC    X'0A0B0C0D0E0F'\n         DC    41X'00'\n         DC    X'00010203040506070809'\nR0       EQU   0                        REGISTER EQUATES\nR1       EQU   1                        *\nR2       EQU   2                        *\nR3       EQU   3                        *\nR4       EQU   4                        *\nR5       EQU   5                        *\nR6       EQU   6                        *\nR7       EQU   7                        *\nR8       EQU   8                        *\nR9       EQU   9                        *\nR10      EQU   10                       *\nR11      EQU   11                       *\nR12      EQU   12                       *\nR13      EQU   13                       *\nR14      EQU   14                       *\nR15      EQU   15                       *\n         SPACE\n*\n*              T A B L E S\n*\nTABLED   DSECT\nCONTROLS DS    0F\n         COPY  SDP10\nSELECTS  DS    0F\n         COPY  SDP20\nCTRLEDIT CSECT\n         LTORG\n         END   CTRLEDIT\n/*\n//*\n//STEP5 EXEC HLASMCL,PARMC='XREF(FULL)',\n//             PARM.LKED='LIST,LET,MAP'\n//*            PARM.LKED='OVLY,LIST,LET,MAP'\n//ASM.SYSLIB DD\n//          DD\n//    DD DSN=&&T,DISP=(SHR,PASS)\n//ASM.SYSIN DD *\n         EJECT\n***********************************************************************\n*        W R I T E   R E P O R T S   R E Q U I R E D                  *\n***********************************************************************\n         SPACE 2\nVPRINT   CSECT                          NAME CONTROL SECTION\n         USING *,R15\n         B     A10SAVE                  BRANCH AROUND IDENTIFIER\n         DC    AL1(14)\n         DC    C'VPRINT SECTION'        IDENTIFIER\nA10SAVE  DS    0H\n         DROP  R15\n         SAVE  (14,12)                  SAVE REGISTERS\n         BALR  R12,0                    LOAD BASE REGISTER\n         USING *,R12,R10,R4             ESTABLISH ADDRESSABILITY\n         LA    R11,1                    LOAD BASE REGISTER 2\n         LA    R10,4095(R11,R12)        *\n         LA    R4,4095(R11,R10)         LOAD BASE REGISTER 3\n         ST    R13,VSAVE+4              CHAIN SAVE AREAS\n         LR    R11,R13                  *\n         LA    R13,VSAVE                *\n         ST    R13,8(R11)               *\n         L     R6,0(0,R1)               LOAD DSECT BASE REG\n         USING CONTROLS,R6              ESTABLISH DSECT ADDRESSABILITY\n         SPACE 2\n         OPEN  (INFILE)                 OPEN INPUT FILE\n         SPACE 1\n         LH    R0,INFILE+82       R0 = LRECL\n         GETMAIN R,LV=(0)         GET RECORD WORK AREA\n         LTR   R15,R15            IS RC = 0 ?\n         BZ    A15OK              YES, CONTINUE\n         ABEND 4                  NO, ABEND WITH RC = 4\n         SPACE 1\nA15OK    DS    0H\n         ST    R1,RECADDR         SAVE A(RECORD AREA)\n         ST    R1,OFFADDR         SAVE A(RECORD AREA)\n         SPACE\n         SR    R14,R14            R14 = 0\n         LH    R15,INFILE+62      R15 = BLKSIZE\n         LH    R1,INFILE+82       R1 = LRECL\n         DR    R14,R1             CALC RECORDS/BLK IN R15\n         L     R2,=V(ADDLTH)      R2 -> AT NEW LTH\n         A     R1,0(0,R2)         ADD NEW LTH TO OLD LRECL\n         MR    R14,R1             NEW BLKSIZE = NEW LRECL * RECS/BLK\n         STH   R15,OUT4DCB+62     PUT NEW BLKSIZE IN OUTPUT DCB\n         STH   R1,OUT4DCB+82      PUT NEW LRECL IN OUTPUT DCB\n         LR    R0,R1              PUT NEW LRECL IN R0\n         SPACE\n*        AH    R0,INFILE+82       R0 = LRECL + MAX NEW BYTES\n         GETMAIN R,LV=(0)         GET RECORD WORK AREA\n         LTR   R15,R15            IS RC = 0 ?\n         BZ    A15OK2             YES, CONTINUE\n         ABEND 5                  NO, ABEND WITH RC = 5\n         SPACE 1\nA15OK2   DS    0H\n         ST    R1,RECADDRO        SAVE A(RECORD AREA)\n         ST    R1,OFFADDRO        SAVE A(RECORD AREA)\n         SPACE\nA20OPEN1 DS    0H\n         TM    OPENFLGS,B'10000000'     OPEN OUT1 ?\n         BNO   A20OPEN2                 NO, CHECK FOR OPEN OUT2\n         SPACE\n         OPEN  (OUT1DCB,(OUTPUT))       OPEN OUT1\n         NI    A50WRT1+1,X'0F'          SET SWITCH TO WRITE OUT1\n         NI    A30DATE+1,X'0F'          SET SWITCH TO GET DATE\n         NI    A70STAT1+1,X'0F'         SET STATS 1 SWITCH\n         SPACE\nA20OPEN2 DS    0H\n         TM    OPENFLGS,B'01000000'     OPEN OUT2 ?\n         BNO   A20OPEN3                 NO, OPEN OUT3?\n         SPACE\n         OPEN  (OUT2DCB,(OUTPUT))       OPEN OUT2\n         NI    A50WRT2+1,X'0F'          SET SWITCH TO WRITE OUT2\n         NI    A30DATE+1,X'0F'          SET SWITCH TO GET DATE\n         NI    A70STAT2+1,X'0F'         SET STATS 2 SWITCH\nA20OPEN3 DS    0H\n         TM    OPENFLGS,B'00100000'     OPEN OUT3 ?\n         BNO   A20OPEN4                 NO, OPEN OUT4?\n         SPACE\n         OPEN  (OUT3DCB,(OUTPUT))       OPEN OUT3\n         NI    A50WRT3+1,X'0F'          SET SWITCH TO WRITE OUT3\n         NI    A30DATE+1,X'0F'          SET SWITCH TO GET DATE\n         NI    A70STAT3+1,X'0F'         SET STATS 3 SWITCH\nA20OPEN4 DS    0H\n         TM    OPENFLGS,B'00010000'     OPEN OUT4 ?\n         BNO   A20OPEN5                 NO, OPEN OUT5 ?\n         SPACE\n         OPEN  (OUT4DCB,(OUTPUT))       OPEN OUT4\n         NI    A50WRT4+1,X'0F'          SET SWITCH TO WRITE OUT4\n         NI    A70STAT4+1,X'0F'         SET STATS 4 SWITCH ON\n         TM    OUT4DCB+36,X'98'   RECFM=F, FB, OR FBS ?\n         BNZ   *+10               YES, DON'T CHANGE IT\n         MVC   OUT4DCB+36(2),INFILE+36 NO, SET IT THE SAME AS THE INPUT\nA20OPEN5 DS    0H\n         TM    OPENFLGS,B'00001000'     OPEN OUT5 ?\n         BNO   A20OPEN6                 NO, OPEN OUT6 ?\n         SPACE\n         OPEN  (OUT5DCB,(OUTPUT))       OPEN OUT5\n         NI    A50WRT5+1,X'0F'          SET SWITCH TO WRITE OUT5\n         NI    A70STAT5+1,X'0F'         SET STATS 5 SWITCH ON\n         TM    OUT5DCB+36,X'58'   RECFM=V, VB, OR VBS ?\n         BNZ   *+10               YES, DON'T CHANGE IT\n         MVC   OUT5DCB+36(2),INFILE+36 NO, SET IT THE SAME AS THE INPUT\nA20OPEN6 DS    0H\n         TM    OPENFLGS,B'00000100'     OPEN OUT6 ?\n         BNO   A20OPEN7                 NO, OPEN OUT7 ?\n         SPACE\n         OPEN  (OUT6DCB,(OUTPUT))       OPEN OUT6\n         NI    A50WRT6+1,X'0F'          SET SWITCH TO WRITE OUT6\n         NI    A70STAT6+1,X'0F'         SET STATS 6 SWITCH ON\n         TM    OUT6DCB+36,X'58'   RECFM=V, VB, OR VBS ?\n         BNZ   *+10               YES, DON'T CHANGE IT\n         MVC   OUT6DCB+36(2),INFILE+36 NO, SET IT THE SAME AS THE INPUT\n         SPACE\nA20OPEN7 DS    0H\n         TM    OPENFLGS,X'02'           OPEN OUT7 ?\n         BNO   A25RDW             NO, START AT RDW ??\n         SPACE\n         OPEN  (OUT7DCB,(OUTPUT))       OPEN OUT7\n         NI    A50WRT7+1,X'0F'          SET SWITCH TO WRITE OUT7\n         NI    A70STAT7+1,X'0F'         SET SWITCH TO WRITE STATS7\n         SPACE\nA25RDW   DS    0H\n*        CLI   STRTPOS,C'R'       START AT RDW ?\n*        BNE   A26RDW             NO, START AT RDW IN HEX?\n*        MVI   H4+1,X'00'         YES, START AT RDW (OFFSET 0)\n         SPACE 1\nA26RDW   DS    0H\n*        CLI   STRTPOS,C'H'       START AT RDW WITH HEX OFFSET?\n*        BNE   A30DATE            NO, START AT DATA (OFFSET 4)\n         MVI   H4+1,X'00'         YES, START AT RDW (OFFSET 0)\n         SPACE 1\nA30DATE  B     A40READ                  DATE SWITCH\n         BAL   R11,B10DATE              PERFORM DATE ROUTINE\n         SPACE\nA40READ  DS    0H\n         L     R0,RECADDR         R0 -> TO RECORD AREA\n         GET   INFILE,(0)               READ INPUT RECORD\n         L     R1,RECADDR         R1 -> TO INPUT RECORD\n         L     R2,RECADDR         R2 -> TO INPUT RECORD\n         AH    R2,H4                 ADD OFFSET (0 IF RDW, 4 IF DATA)\n         ST    R2,OFFADDR         SAVE IT\n         L     R2,RECADDRO        R2 -> TO OUTPUT RECORD AREA\n*        MVI   0(R2),C' '         BLANK OUT RECORD BYTE 1\n         SPACE 1\n         STM   R2,R5,SAVE2TO5     SAVE SOME REGS\n*                                 CAUSE MVCL CLOBBERS \"TO\" REG...\n*        FIRST FILL AREA WITH SPACES\n         L     R9,=X'40000000'    MAKE BLANK THE PAD, LENGTH =0\n         LA    R8,0               NOT THAT IT REALLY MATTERS\n         LH    R3,OUT4DCB+82      R3 = TOTAL LTH TO MOVE TO\n         SPACE 1\n         MVCL  R2,R8              CLEAR THE BUFFER\n*\n         LM    R2,R5,SAVE2TO5     LOAD SOME REGS\n*\n\n         AH    R2,H4                 ADD OFFSET (0 IF RDW, 4 IF DATA)\n         ST    R2,OFFADDRO        SAVE IT\n         LH    R2,INFILE+82             GET LTH OF RECORD\n         ST    R2,VRLTHO                SAVE LTH OF RECORD\n         SH    R2,H4                    DROP LTH OF CW\n         ST    R2,VRLTH                 SAVE LTH OF RECORD\n         ST    R2,VRLTHL                SAVE LTH OF RECORD\n         LR    R2,R1                    POINT REG 2 TO INPUT RECORD\n         AH    R2,H4                 ADD OFFSET (0 IF RDW, 4 IF DATA)\n         AP    INCTR,ONE                ADD 1 TO RECORD COUNTER\n         LA    R3,0               RESET LAST OFFSET\n         ST    R3,LASTOFF               FIELD\n         SPACE\nA50WRT1  DS    0H\n         B     A50WRT2                  WRITE 1 SWITCH\n         LA    R3,A50WRT2               LOAD RETURN ADDRESS\n         LA    R5,SELECTS+0             LOAD ADDRESS OUT1 TABLE\n         L     R15,OUT1CTR              LOAD OUT1 COUNTER\n         BAL   R11,D10COMP              CHECK CONTROL FIELDS\n         SPACE\n         LA    R1,OUT1                  LOAD DCB ADDRESS\n         MVC   PHD,HEAD1                MOVE HEAD1 TO PRINT\n         BAL   R11,E10PRT               PRINT,REPORT 1\n         AP    OUTCTR1,ONE              ADD 1 TO OUT1 COUNTER\n         BAL   R3,D70BR                 RETURN TO D10COMP\n         SPACE\nA50WRT2  DS    0H\n         B     A50WRT3                  WRITE 2 SWITCH\n         LA    R3,A50WRT3               LOAD RETURN ADDRESS\n         L     R15,OUT2CTR              LOAD OUT2 COUNTER\n         LA    R5,SELECTS            LOAD ADDRESS OUT2 TABLE\n         A     R5,OFF2               *\n         BAL   R11,D10COMP              CHECK CONTROL FIELDS\n         SPACE\n         LA    R1,OUT2                  LOAD OUT2 DCB ADDRESS\n         MVC   PHD,HEAD2                MOVE HEAD2 TO PRINT\n         BAL   R11,E10PRT               PRINT REPORT 2\n         AP    OUTCTR2,ONE              ADD 1 TO OUT2 COUNTER\n         BAL   R3,D70BR                 RETURN TO D10COMP\n         SPACE\nA50WRT3  DS    0H\n         B     A50WRT4                  WRITE 3 SWITCH\n         LA    R3,A50WRT4               LOAD RETURN ADDRESS\n         L     R15,OUT3CTR              LOAD OUT3 COUNTER\n         LA    R5,SELECTS            LOAD ADDRESS OUT3 TABLE\n         A     R5,OFF3               *\n         BAL   R11,D10COMP              CHECK CONTROL FIELDS\n         SPACE\n         LA    R1,OUT3                  LOAD OUT3 DCB ADDRESS\n         MVC   PHD,HEAD3                MOVE HEAD3 TO PRINT\n         BAL   R11,E10PRT               PRINT REPORT 3\n         AP    OUTCTR3,ONE              ADD 1 TO OUT3 COUNTER\n         BAL   R3,D70BR                 RETURN TO D10COMP\n         SPACE\nA50WRT4  DS    0H\n         B     A50WRT5                  WRITE 4 SWITCH\n         LA    R3,A50WRT5               LOAD RETURN ADDRESS\n         L     R15,OUT4CTR              LOAD OUT4 COUNTER\n         LA    R5,SELECTS            LOAD ADDRESS OUT4 TABLE\n         A     R5,OFF4               *\n         BAL   R11,D10COMP              CHECK CONTROL FIELDS\n         SPACE\n         LA    R1,OUT4DCB               LOAD OUT4 DCB ADDRESS\n         BAL   R11,F10WRITE             WRITE OUT4\n         AP    OUTCTR4,ONE              ADD 1 TO OUT4 COUNTER\n         BAL   R3,D70BR                 RETURN TO D10COMP\n         SPACE\nA50WRT5  DS    0H\n         B     A50WRT6                  WRITE 5 SWITCH\n         LA    R3,A50WRT6               LOAD RETURN ADDRESS\n         L     R15,OUT5CTR              LOAD OUT5 COUNTER\n         LA    R5,SELECTS           LOAD ADDRESS OUT5 TABLE\n         A     R5,OFF5               *\n         BAL   R11,D10COMP              CHECK CONTROL FIELDS\n         SPACE\n         LA    R1,OUT5DCB               LOAD ADDRESS OUT5 DCB\n         BAL   R11,F10WRITE             WRITE OUT5\n         AP    OUTCTR5,ONE              ADD 1 TO OUT5 COUNTER\n         BAL   R3,D70BR                 RETURN TO D10COMP\n         SPACE\nA50WRT6  DS    0H\n         B     A50WRT7                  WRITE 6 SWITCH\n         LA    R3,A60LOOP               LOAD RETURN ADDRESS\n         L     R15,OUT6CTR              LOAD OUT6 COUNTER\n         LA    R5,SELECTS           LOAD OUT6 TABLE ADDRESS\n         A     R5,OFF6               *\n         BAL   R11,D10COMP              CHECK CONTROL FIELDS\n         SPACE\n         LA    R1,OUT6DCB               LOAD OUT6 DCB ADDRESS\n         BAL   R11,F10WRITE             WRITE OUT6\n         AP    OUTCTR6,ONE              ADD 1 TO OUT6 COUNTER\n         BAL   R3,D70BR                 RETURN TO D10COMP\n         SPACE\nA50WRT7  DS    0H\n         B     A60LOOP                  WRITE 7 SWITCH\n         LA    R3,A60LOOP               LOAD RETURN ADDRESS\n         L     R15,OUT7CTR              LOAD OUT7 COUNTER\n         LA    R5,SELECTS           LOAD OUT7 TABLE ADDRESS\n         A     R5,OFF7               *\n         BAL   R11,D10COMP              CHECK CONTROL FIELDS\n         SPACE\n         LA    R1,OUT7DCB               LOAD OUT7 DCB ADDRESS         1\n         BAL   R11,F50WRITE             WRITE OUT7                    2\n         AP    OUTCTR7,ONE              ADD 1 TO OUT7 COUNTER         3\n         BAL   R3,D70BR                 RETURN TO D10COMP             4\n         SPACE\nA60LOOP  DS    0H\n         B     A40READ\n         SPACE\nA70STATS DS    0H\n         OPEN  (SYSOUT,(OUTPUT))        OPEN SYSPRINT FILE\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         MVI   P,C' '                    CLEAR PRINT LINE\n         MVC   P+1(L'P-1),P             *\n         MVC   SEDWDUT1,PLEDWD1         EDIT INPUT RECORDS COUNTER\n         ED    SEDWDUT1,INCTR           *\n         MVC   P(L'SHDUT1),SHDUT1       MOVE STATS HEAD TO PRINT\n         BAL   R11,Y10WSP2              PRINT, SPACE 2\n         SPACE\nA70STAT1 DS    0H\n         B     A70STAT2                 STATS 1 SWITCH\n         MVC   SEDWD1,PLEDWD1           EDIT OUT1 COUNTER\n         ED    SEDWD1,OUTCTR1           *\n         MVC   P(L'SHD1),SHD1           MOVE STATS TO PRINT\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         BAL   R11,Y10WSP2              PRINT STATS 1\n         SPACE\nA70STAT2 DS    0H\n         B     A70STAT3                 STATS 2 SWITCH\n         MVC   SEDWD2,PLEDWD1           EDIT OUT2 COUNTER\n         ED    SEDWD2,OUTCTR2           *\n         MVC   P(L'SHD2),SHD2           MOVE STATS2 HEADING TO PRINT\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         BAL   R11,Y10WSP2              PRINT STATS 2\n         SPACE\nA70STAT3 DS    0H\n         B     A70STAT4                 STATS 3 SWITCH\n         MVC   SEDWD3,PLEDWD1           EDIT OUT3 COUNTER\n         ED    SEDWD3,OUTCTR3           *\n         MVC   P(L'SHD3),SHD3           MOVE STATS 3 HEAD TO PRINT\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         BAL   R11,Y10WSP2              PRINT STATS 3\n         SPACE\nA70STAT4 DS    0H\n         B     A70STAT5                 STATS 4 SWITCH\n         MVC   SEDWD4,PLEDWD1           EDIT OUT4 COUNTER\n         ED    SEDWD4,OUTCTR4           *\n         MVC   P(L'SHD4),SHD4           MOVE STATS 4 HEAD TO PRINT\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         BAL   R11,Y10WSP2              PRINT STATS 4\n         SPACE\nA70STAT5 DS    0H\n         B     A70STAT6                 STATS 5 SWITCH\n         MVC   SEDWD5,PLEDWD1           EDIT OUT5 COUNTER\n         ED    SEDWD5,OUTCTR5           *\n         MVC   P(L'SHD5),SHD5           MOVE STATS HEAD 5 TO PRINT\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         BAL   R11,Y10WSP2              PRINT STATS 5\n         SPACE\nA70STAT6 DS    0H\n         B     A70STAT7                 STATS 6 SWITCH\n         MVC   SEDWD6,PLEDWD1           EDIT OUT6 COUNTER\n         ED    SEDWD6,OUTCTR6           *\n         MVC   P(L'SHD6),SHD6           MOVE STATS 6 HEAD TO PRINT\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         BAL   R11,Y10WSP2              PRINT STATS 6\n         SPACE\nA70STAT7 DS    0H\n         B     A90END                   STATS 7 SWITCH\n         MVC   SEDWD7,PLEDWD1           EDIT OUT7 COUNTER\n         ED    SEDWD7,OUTCTR7           *\n         MVC   P(L'SHD7),SHD7           MOVE STATS 7 HEAD TO PRINT\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         BAL   R11,Y10WSP2              PRINT STATS 7\n         SPACE\nA90END   DS    0H\n         L     R13,VSAVE+4              RETURN TO ROOT SECTION\n         RETURN (14,12),RC=0            *\n         SPACE 2\nOFF2     DC    F'2900'               OFFSET TO CF2\nOFF3     DC    F'5800'               OFFSET TO CF3\nOFF4     DC    F'8700'               OFFSET TO CF4\nOFF5     DC    F'11600'              OFFSET TO CF5\nOFF6     DC    F'14500'              OFFSET TO CF6\nOFF7     DC    F'17400'              OFFSET TO CF7\n         EJECT\n***********************************************************************\n*        R O U T I N E   T O   S E T   U P   D A T E                  *\n***********************************************************************\n         SPACE 2\nB10DATE  DS    0H\n         TIME  DEC,SAVETIME,            GET THE SYS TIME            Y2 +\n               LINKAGE=SYSTEM,DATETYPE=YYYYMMDD     IN THIS CASE    Y2\n         L     R0,SAVETIME              R= TIME                     Y2\n         L     R1,SAVETIME+8            R1 = 0YYYYDDD               Y2\n         SLL   R1,4                     SHIFT LEFT 4 BITS           Y2\n         AH    R1,=H'15'                ADD SIGN...15=F             Y2\n*\n*        TIME  DEC                      GET DATE\n         ST    R1,DWRK1                 STORE DATE\n         MVO   DWRK2,DWRK1(2)           SAVE DAY\n         UNPK  HD1YR,DWRK2+1(2)         UNPACK YEAR\n         MVZ   HD1YR+1(1),HD1YR         CHANGE ZONE TO F\n         SPACE\n         DP    DWRK2,FOUR               DIVIDE YEAR BY 4\n         CP    DWRK2+2(1),ZERO          REMAINDER = 0 ?\n         BNE   B30NOLEP                 NO, GO TO PROCESS NO LEAP YEAR\n         SPACE\n         LA    R7,YTAB3+6               ADD 1 TO JULIAN DAY\n         LA    R8,10                    IN TABLE TO COMPENSATE\nB20LEAP  AP    0(2,R7),ONE              FOR LEAP YEAR TO\n         LA    R7,8(R7)                 MONTHS MARCH\n         BCT   R8,B20LEAP               TO DECEMBER\n         SPACE\nB30NOLEP DS    0H\n         ZAP   DWRK3,DWRK1+2(2)         MOVE JULIAN DAY TO WORK AREA\n         LA    R7,TABEND                LOAD ADDRESS TABLE END\n         LA    R8,8                     LOAD 8\nB40      DS    0H\n         CP    6(2,R7),DWRK3            COMPARE JUL DAY TO TABLE JUL\n         BL    B50                      BRANCH LOW\n         SR    R7,R8                    POINT TO NEXT ENTRY\n         B     B40                      LOOP BACK TO  40\n         SPACE\nB50      DS    0H\n         MVC   HD1MTH,4(R7)             MOVE MONTH TO REPORT DATE\n         SP    DWRK3,6(2,R7)            SUBTRACT JUL DAY IN TABLE\n         ED    HD1DAY,DWRK3             FROM CURRENT JUL DAY AND EDIT\n         SPACE\nB90END   DS    0H\n         BR    R11                      RETURN TO CALLER\n         SPACE 2\n         CNOP  0,4                      ALIGN ON FULLWORD BOUNDARY\nDWRK1    DC    PL4'0'\nDWRK2    DC    PL3'0'\nDWRK3    DC    PL2'0'\nFOUR     DC    P'4'\nZERO     DC    P'0'\n*\n         CNOP  0,4                      ALIGN ON FULLWORD BOUNDARY\nSAVETIME DC    XL16'00'                                             Y2\n*\n         SPACE\nYTAB     DC    C' JAN01'\n         DC    P'000'\n         DC    C' FEB02'\n         DC    P'031'\nYTAB3    DC    C' MAR03'\n         DC    P'059'\n         DC    C' APR04'\n         DC    P'090'\n         DC    C' MAY05'\n         DC    P'120'\n         DC    C'JUNE06'\n         DC    P'151'\n         DC    C'JULY07'\n         DC    P'181'\n         DC    C' AUG08'\n         DC    P'212'\n         DC    C'SEPT09'\n         DC    P'243'\n         DC    C' OCT10'\n         DC    P'273'\n         DC    C' NOV11'\n         DC    P'304'\nTABEND   DC    C' DEC12'\n         DC    P'334'\n         EJECT\n***********************************************************************\n*        C O M P A R E   C O N T R O L   F I E L D S   T O   T A B L E*\n***********************************************************************\n         SPACE 2\nD10COMP  DS    0H\n         ST    R11,STORED               SAVE RETURN ADDRESS\n*        ST    R2,OFFADDR         SAVE INPUT DATA ADDRESS  ...\n*        L     R2,RECADDRO        R2 -> TO OUTPUT DATA ADDRESS  ...\n*        ST    R2,OFFADDRO        SAVE IT\nD10STBCT LA    R7,5                     LOAD 5 IN REG 7\n         NI    OPENFLGS,X'FE'           TURN WRITE SWITCH OFF\n         ST    R15,STORED4              SAVE OUT COUNTER\n         SPACE\nD20LOOP  DS    0H\n         CLI   5(R5),X'FF'              SELECT CF USED ?\n         BE    D60PTCF                  NO, CHECK NEXT CF\n         SPACE\n*        CLI   4(R5),C'0'               SELECT ALL VALUES ?\n*        BE    D50SWON                  YES, TURN WRITE SWITCH ON\n         SPACE\n         LA    R8,CONTROLS              LOAD CONTROLS ADDRESS\n         A     R8,0(R0,R5)              ADD DISPLACEMENT FROM SELECTAB\n         SPACE\n         L     R11,VRLTH                GET LTH OF VARIABLE RECORD\n         C     R11,0(0,R8)              START LOC IN RECORD ?\n         BL    D40NO                    NO, CAN'T COMPARE THIS FIELD\n*        LR    R1,R2                    POINT TO VARIABLE RECORD\n         SPACE\nD20OUT   DS    0H\n*        A     R1,0(R0,R8)              ADD START TO RECORD ADDRESS\n*        L     R9,0(0,R8)               MOVE HEX LTH TO REG 9\n         L     R11,OFFADDRO       R11 -> TO WHERE DATA GOES...\n*        L     R9,OFFADDR         R9 -> TO START OF INPUT DATA\n*        AR    R2,R9              ADD NEXT START OFFSET\n*        A     R9,0(0,R8)         ADD HEX LTH\n         L     R9,0(0,R8)         R9 = OFFSET TO THIS FIELD\n         S     R9,LASTOFF         - OFFSET TO LAST FIELD\n         L     R2,0(0,R8)         R2 = OFFSET TO THIS FIELD\n         ST    R2,LASTOFF         SAVE IT\n         L     R2,OFFADDR         R2 -> TO WHERE DATA COMES FROM\n         LTR   R9,R9              R9 ALREADY 0?\n         BZ    D40BR              YES, NO DATA TO MOVE\n*        BZ    NOBCTR1            YES, DON'T SUBT 1\n         BCTR  R9,0               R9 = HEX LTH TO MOVE\n         SPACE\nNOBCTR1  DS    0H\n*        L     R2,0(0,R8)         R2 = OFFSET TO THIS FIELD\n*        ST    R2,LASTOFF         SAVE IT\n*        L     R2,OFFADDR         R2 -> TO WHERE DATA COMES FROM\n         SPACE\nD40SETBR DS    0H\n*        MVC   D40BR+1(1),4(R5)         SET BRANCH CONDITION\n*        EX    R9,D40MVC                MOVE DATA\n         SPACE 1\n         LA    R9,1(0,R9)         R9 = REAL LTH MOVED\n         STM   R2,R5,SAVE2TO5     SAVE SOME REGS\n*                                 CAUSE MVCL CLOBBERS \"TO\" REG...\n         LR    R4,R11             R4 -> TO WHERE DATA GOES\n         LR    R5,R9              R5 = TOTAL LTH TO MOVE TO\n*                                 R2 -> TO WHERE DATA COMES FROM\n         LR    R3,R9              R3 = TOTAL LTH TO MOVE FROM\n         SPACE 1\n         MVCL  R4,R2              MOVE PART OF RECORD\n         LM    R2,R5,SAVE2TO5     LOAD SOME REGS\n*\n*        LA    R9,1(0,R9)         R9 = LTH MOVED\nD40BR    BC    0,D50SWON                BRANCH\n         AR    R11,R9             R11 -> TO WHERE NEXT DATA GOES...\n         CLI   8(R8),C'A'         IS DATE ALPHA?\n         BNE   NOTALPHA           NO\n         L     R1,4(0,R8)         R1 = LTH TO MOVE\n*        BCTR  R1,0               R1 = HEX LTH TO MOVE\n         EX    R1,D40MVC2               MOVE DATA\n*        LA    R1,1(0,R1)         R1 = LTH MOVED\n*        MVC   0(2,R11),=C'19'    SET ALPHA CENTURY TO 19\n*        LA    R11,2(0,R11)       SET R11\n*        AR    R11,R1             ADD TO LTH\n         LA    R11,1(R1,R11)      ADD TO LTH, +1\n         ST    R11,OFFADDRO       R11 -> TO WHERE NEXT DATA GOES...\n         L     R11,VRLTHL         R11 = DATA LEFT TO MOVE...\n         SR    R11,R9             - WHAT WE MOVED\n         ST    R11,VRLTHL         R11 = DATA LEFT TO MOVE...\n         LR    R11,R2             R11 -> AT INPUT DATA\n         AR    R11,R9             R11 -> AT NEXT DATA TO MOVE\n         ST    R11,OFFADDR        SAVE IT\n         L     R11,VRLTHO         R11 = LTH OF DATA MOVED...\n*        AH    R11,=H'2'          + 2 FOR \"19\"\n*        AR    R11,R1             ADD LTH OF ADDED DATA\n         LA    R11,1(R1,R11)      ADD TO LTH, +1\n         ST    R11,VRLTHO         SAVE LTH MOVED...\n         B     D50SWON            TURN WRITE SWITCH ON\n         SPACE\nNOTALPHA DS    0H\n*        CLI   8(R8),C'P'         IS DATE PACKED?\n*        BNE   NOTPACK            NO\n*        MVC   0(1,R11),X'19'     SET PACKED CENTURY TO 19\n         L     R1,4(0,R8)         R1 = LTH TO MOVE\n*        BCTR  R1,0               R1 = HEX LTH TO MOVE\n         EX    R1,D40MVC2               MOVE DATA\n*        LA    R1,1(0,R1)         R1 = LTH MOVED\n*        AR    R11,R1             ADD TO LTH\n         LA    R11,1(R1,R11)      ADD TO LTH, +1\n*        MVI   0(R11),X'19'       SET PACKED CENTURY TO 19\n*        LA    R11,1(0,R11)       SET R11\n         ST    R11,OFFADDRO       R11 -> TO WHERE DATA GOES...\n         L     R11,VRLTHL         R11 = DATA LEFT TO MOVE...\n         SR    R11,R9             - WHAT WE MOVED\n         ST    R11,VRLTHL         R11 = DATA LEFT TO MOVE...\n         LR    R11,R2             R11 -> AT INPUT DATA\n         AR    R11,R9             R11 -> AT NEXT DATA TO MOVE\n         ST    R11,OFFADDR        SAVE IT\n         L     R11,VRLTHO         R11 = LTH OF DATA MOVED...\n*        AH    R11,=H'1'          + 1 FOR \"19\"\n*        AR    R11,R1             ADD LTH OF ADDED DATA\n         LA    R11,1(R1,R11)      ADD TO LTH, +1\n         ST    R11,VRLTHO         SAVE LTH MOVED...\n         B     D50SWON            TURN WRITE SWITCH ON\n         SPACE\nNOTPACK  DS    0H\n         SPACE\nD40NO    DS    0H\n         NI    OPENFLGS,X'FE'           TURN WRITE SWITCH OFF\n         LR    R11,R7                R11 = NBR OF CF'S LEFT\n         MH    R11,H116              R11 * 116 = LTH OF CF'S LEFT\n         AR    R5,R11                R5 -> TO NEXT CF SET FOR THIS OUT\n         B     D70BR                    CONDITION NOT MET, REJECT TEST\n         SPACE\nD40MVC   MVC   0(0,R11),0(R2)     MOVE DATA\nD40MVC2  MVC   0(0,R11),5(R5)     MOVE DATA 2...\nD40CLC   CLC   0(0,R1),5(R5)            COMPARE\n         SPACE\nD50SWON  DS    0H\n         OI    OPENFLGS,X'01'           TURN WRITE SWITCH ON\n         SPACE\nD60PTCF  DS    0H\n         LA    R5,116(R5)               POINT TO NEXT CF\nH116     EQU   *-2                   HALFWORD OF 116\n         BCT   R7,D20LOOP               5 CF'S PROCESSED ?\n*\n         L     R9,VRLTHL          R9 = DATA LEFT TO MOVE...\n         LTR   R9,R9              R9 ALREADY 0?\n         BZ    NOMOVE2            YES, DON'T SUBT 1\n*        BCTR  R9,0               R9 = HEX LTH TO MOVE\n         SPACE\nNOBCTR2  DS    0H\n         L     R2,OFFADDR         R2 -> TO WHERE DATA COMES FROM\n         L     R11,OFFADDRO       R11 -> TO WHERE DATA GOES...\n*        EX    R9,D40MVC                MOVE DATA\n         SPACE 1\n*        LA    R9,1(0,R9)         R9 = REAL LTH TO MOVE\n         STM   R2,R5,SAVE2TO5     SAVE SOME REGS\n*                                 CAUSE MVCL CLOBBERS \"TO\" REG...\n         LR    R4,R11             R4 -> TO WHERE DATA GOES\n         LR    R5,R9              R5 = TOTAL LTH TO MOVE TO\n*                                 R2 -> TO WHERE DATA COMES FROM\n         LR    R3,R9              R3 = TOTAL LTH TO MOVE FROM\n         SPACE 1\n         MVCL  R4,R2              MOVE PART OF RECORD\n         LM    R2,R5,SAVE2TO5     LOAD SOME REGS\n*\n         SPACE\nNOMOVE2  DS    0H\n*        LA    R9,1(0,R9)         R9 = LTH MOVED\n         L     R11,VRLTHO         R11 = LTH OF DATA MOVED...\n*        AH    R11,H4                ADD OFFSET (0 IF RDW, 4 IF DATA)\n*        ST    R11,VRLTHO         SAVE LTH MOVED...\n*        L     R9,RECADDRO        R9 -> TO OUTPUT RECORD\n*        STH   R11,0(0,R9)        UPDATE LTH\n*\n         TM    OPENFLGS,X'01'           YES, WRITE RECORD ?\n         BNO   D70BR                    NO, GO TO D70BR\n         SPACE\n         L     R11,STORED               LOAD RETURN ADDRESS\n         BR    R11                      RETURN TO WRITE RECORD\n         SPACE\nD70BR    DS    0H\n         TM    OPENFLGS,X'01'           RECORD ALREADY WRITTEN ?\n         BO    D80BR                    YES, CHECK NEXT FILE\n         SPACE\n         L     R15,STORED4              LOAD OUT COUNTER\n         BCT   R15,D10STBCT             ANY MORE OUTS FOR THIS TEST ?\nD80BR    DS    0H\n         BR    R3                       NO, SET UP NEXT OUT TEST\n         SPACE\nSTORED   DS    F\nSTORED4  DS    F                        OUT COUNTER\nSAVE2TO5 DS    4F                 SAVE AREA\n         EJECT\n***********************************************************************\n*        R O U T I N E   T O   P R I N T   R E P O R T S   1,2,3      *\n***********************************************************************\n         SPACE 2\nE10PRT   DS    0H\n         ST    R11,STORE1               SAVE RETURN ADDRESS\n         ST    R1,STORE2          SAVE A(OUT1) PARMS\n         L     R7,VRLTH           R7 = VARIABLE RECORD LTH\n         LR    R9,R2              R9 -> TO V RECORD\nE20LOOP  L     R3,8(0,R1)         R3 -> LINE COUNTER\n         CP    0(3,R3),FULLPAGE   IS PAGE FULL ?\n         BL    E30                NO\n         BAL   R11,Y10SKIP1       YES, SKIP TO NEW PAGE\n         L     R1,STORE2          R1 -> TO PARMS\n         BAL   R11,Y10SPCE3       SKIP DOWN 3 LINES\n         L     R1,STORE2          R1 -> TO PARMS\n         L     R3,4(0,R1)         R3 -> TO PAGE COUNTER\n         MVC   HD1PAGE,PLEDWD1    EDIT PAGE COUNTER\n         ED    HD1PAGE,0(R3)      *\n         MVC   P(L'PHD),PHD       MOVE HEADING TO PRINT\n         MVC   P+100(L'HD1),HD1   *\n         BAL   R11,Y10WSP2        PRINT HEADING, SPACE 2\n         SPACE\nE30      DS    0H\n         LA    R8,132             R8 = LTH OF OUTPUT LINE\nH132     EQU   *-2                HALFWORD 132\nE40      DS    0H\n         CR    R7,R8              REC LTH OVER 132?\n         BH    E50                YES, PRINT IN 132 BYTE CHUNKS\n         SPACE\n         SH    R7,H1              R7 = LRECL - 1\n         EX    R7,MOVETOP         MOVE DATA TO PRINT LINE\n         L     R1,STORE2          R1 -> TO PARMS\n         BAL   R11,Y10WSP2        PRINT LAST LINE, SPACE 2\n         L     R11,STORE1         LOAD RETURN ADDRESS\n         BR    R11                GO BACK TO CALLER\n         SPACE\nE50      DS    0H\n         SH    R8,H1              R8= 131\n         EX    R8,MOVETOP         MOVE 132 BYTES TO PRINT\n         L     R1,STORE2          R1 -> TO PARMS\n         BAL   R11,Y10WSP1        PRINT,SPACE 1\n         SPACE\n         SH    R7,H132            R7 = LRECL REMAINING\n         AH    R9,H132            R9 -> TO NEXT PART OF RECORD\n         L     R1,STORE2          R1 -> TO PARMS\n         B     E20LOOP            PRINT NEXT CHUNK OF RECORD\n         SPACE 2\nMOVETOP  MVC   P(1),0(R9)         MOVE DATA TO P\nFULLPAGE DC    PL3'50'\nH1       DC    H'1'\nH4       DC    H'4'\nOUT1     DC    A(OUT1DCB)\n         DC    A(PAGECTR1)\n         DC    A(LINECTR1)\n         SPACE\nOUT2     DC    A(OUT2DCB)\n         DC    A(PAGECTR2)\n         DC    A(LINECTR2)\n         SPACE\nOUT3     DC    A(OUT3DCB)\n         DC    A(PAGECTR3)\n         DC    A(LINECTR3)\n         SPACE\nOUT4     DC    A(SYSOUT)\n         DC    A(PAGECTR4)\n         DC    A(LINECTR4)\n         SPACE\nPAGECTR4 DC    PL3'0'\nLINECTR4 DC    PL3'75'\n         SPACE\n         SPACE\nSTORE1   DS    F                        RETURN ADDRESS\nSTORE2   DS    F\nSTORE5   DS    F\nSTOREDCB DS    F                        DCB ADDRESS\nNINES    DC    C' 999999999'\nSPACES   DC    CL10' '\nPHD      DS    CL74\n         EJECT\n***********************************************************************\n*        R O U T I N E   T O   P R I N T   R E P O R T S   4,5,6      *\n***********************************************************************\n         SPACE 2\nF10WRITE DS    0H\n         L     R0,RECADDRO              R0 -> TO NEW RECORD\n         PUT   (1),(0)                  PRINT\n         BR    R11                      RETURN\n         SPACE\nF50WRITE DS    0H\n         PUT   (1)                      GET OUTPUT AREA\n         LR    R15,R1                   R15 -> TO OUTPUT BUFFER\n         L     R7,VRLTH                 R7 = LTH OF INPUT RECORD\n         LH    R8,OUT7DCB+82            R8 = OUTPUT LRECL\n         SPACE\nF55COMP  DS    0H\n         CH    R8,H256            LRECL OVER 256 ?\n         BH    F60                YES, CLEAR IN CHUNKS\n         SPACE\n         SH    R8,=H'2'           R8 = LRECL - 2\n         MVI   0(R1),X'40'        CLEAR BUFFER\n         EX    R8,CLEAROUT        *\n         B     F65MOVE            MOVE INPUT TO OUTPUT\n         SPACE\nF60      DS    0H\n         MVI   0(R1),X'40'        CLEAR OUTPUT BUFFER\n         MVC   1(255,R1),0(R1)    *\n         LA    R1,256(R1,0)       ADD 256 TO R1\nH256     EQU   *-2                HALFWORD 256\n         SH    R8,H256            R8 = LRECL - 256\n         B     F55COMP            CLEAR NEXT CHUNK OF BUFFER\n         SPACE\nF65MOVE  DS    0H\n         LR    R3,R2              R3 -> TO INPUT RECORD\n         LH    R8,OUT7DCB+82      R8 = OUTPUT LRECL\n         CR    R7,R8              IS OUTPUT LONGER THAN INPUT ?\n         BL    F70COMP2           YES, MOVE ALL OF INPUT\n         LR    R7,R8              NO, MOVE OUTPUT LENGTH ONLY\n         SPACE\nF70COMP2 DS    0H\n         CH    R7,H256            INPUT LTH OVER 256 ?\n         BH    F80                YES, MOVE IN CHUNKS\n         SH    R7,H1              R7 = IBM LTH OF INPUT\n         EX    R7,MOVEDATA        MOVE INPUT TO OUTPUT\n         BR    R11                RETURN TO CALLER\n         SPACE\nCLEAROUT MVC   1(0,R1),0(R1)      CLEAR BUFFER\nMOVEDATA MVC   0(0,R15),0(R3)     MOVE INPUT TO OUTPUT\n         SPACE\nF80      DS    0H\n         MVC   0(256,R15),0(R3)   MOVE INPUT TO OUTPUT\n         SH    R7,H256            R7 = LTH LEFT\n         AH    R3,H256            R3 -> REST OF INPUT\n         AH    R15,H256           R15 -> TO REST OF OUTPUT\n         B     F70COMP2           MOVE REST OF DATA\n         EJECT\n***********************************************************************\n*        P R I N T E R   A N D   C A R R I A G E   C O N T R O L      *\n***********************************************************************\n         SPACE 2\nY10SKIP1 DS    0H\n         MVI   CTLCHR,X'8B'             SKIP1 TO CHANNEL 1\n         L     R3,4(0,R1)         R3 -> TO PAGE COUNTER\n         AP    0(3,R3),ONE        ADD 1 TO PAGE COUNT\n         L     R3,8(0,R1)         R3 -> TO LINE COUNTER\n         SP    0(3,R3),0(3,R3)    CLEAR LINE COUNTER\n         B     Y40\n         SPACE\nY10SPCE1 DS    0H\n         MVI   CTLCHR,X'0B'             SPACE 1 IMMEDIATE\n         L     R3,8(0,R1)         R3 -> TO LINE COUNTER\n         AP    0(3,R3),ONE        ADD 1 TO LINE COUNT\n         B     Y40\n         SPACE\nY10SPCE2 DS    0H\n         MVI   CTLCHR,X'13'             SPACE 2 IMMEDIATE\n         L     R3,8(0,R1)         R3 -> TO LINE COUNTER\n         AP    0(3,R3),TWO        ADD 2 TO LINE COUNTER\n         B     Y40\n         SPACE\nY10SPCE3 DS    0H\n         MVI   CTLCHR,X'1B'             SPACE 3 IMMEDIATE\n         L     R3,8(0,R1)         R3 -> TO LINE COUNTER\n         AP    0(3,R3),THREE      ADD 3 TO LINE COUNTER\n         B     Y40\n         SPACE\nY10WSP1  DS    0H\n         MVI   CTLCHR,X'09'             PRINT, SPACE 1\n         L     R3,8(0,R1)         R3 -> TO LINE COUNTER\n         AP    0(3,R3),ONE        ADD 1 TO LINE COUNTER\n         B     Y40\n         SPACE\nY10WSP2  DS    0H\n         MVI   CTLCHR,X'11'             PRINT, SPACE 2\n         L     R3,8(0,R1)         R3 -> TO LINE COUNTER\n         AP    0(3,R3),TWO        ADD 2 TO LINE COUNTER\n         B     Y40\n         SPACE\nY10WSP3  DS    0H\n         MVI   CTLCHR,X'19'             PRINT, SPACE 3\n         L     R3,8(0,R1)         R3 -> TO LINE COUNTER\n         AP    0(3,R3),THREE      ADD 3 TO LINE COUNTER\n         SPACE\nY40      DS    0H\n         L     R1,0(0,R1)               LOAD DCB ADDRESS\n         PUT   (1),PRINT                PRINT\n         MVI   P,C' '                   CLEAR PRINT BUFFER\n         MVC   P+1(L'P-1),P             *\n         SPACE\n         BR    R11                      RETURN\n         EJECT\n***********************************************************************\n*        IF THERE IS NO RECFM, LRECL OR BLKSIZE ON FILES              *\n*        OUT4, OUT5, OUT6 OR OUT7 AND THE OPEN BOMBS, WE              *\n*        WILL TRY TO RECOVER BY MAKING THEIR DCB INFORMATION          *\n*        THE SAME AS THE INPUT FILE.                                  *\n***********************************************************************\n         SPACE 2\nDCBEXIT  DS    0H\n         USING DCBEXIT,R15        SET BASE ADDRESSABLITY\n         CLI   36(R1),X'00'       RECFM SET ?\n         BNE   DCB10              YES, CHECK BLKSIZE\n         MVC   36(1,R1),INFILE+36 NO, SET SAME AS INPUT FILE\n         SPACE 1\nDCB10    DS    0H\n         CLC   62(2,R1),DWRK1     BLKSIZE SET ?\n         BNE   DCB20              YES, CHECK LRECL\n         MVC   62(2,R1),INFILE+62 NO, SET SAME AS INPUT FILE\n         SPACE 1\nDCB20    DS    0H\n         CLC   82(2,R1),DWRK1     LRECL SET ?\n         BNE   DCB30              YES, GO BACK TO OPEN\n         MVC   82(2,R1),INFILE+82 NO, SET SAME AS INPUT FILE\n         SPACE 1\nDCB30    DS    0H\n         BR    R14                GO BACK TO OPEN\n         DROP  R15                DROP R15 AS A BASE\n         EJECT\n***********************************************************************\n*        F I L E    D E C L A R E S   F O R   V P R I N T             *\n***********************************************************************\n         SPACE 2\n         PRINT NOGEN\nOUT1DCB  DCB   DDNAME=OUT1,DSORG=PS,MACRF=PM,RECFM=FBM,                +\n               LRECL=133,BLKSIZE=665\nOUT2DCB  DCB   DDNAME=OUT2,DSORG=PS,MACRF=PM,RECFM=FBM,                +\n               LRECL=133,BLKSIZE=665\nOUT3DCB  DCB   DDNAME=OUT3,DSORG=PS,MACRF=PM,RECFM=FBM,                +\n               LRECL=133,BLKSIZE=665\nOUT4DCB  DCB   DDNAME=OUT4,DSORG=PS,MACRF=PM,EXLST=BLKEXLST\nOUT5DCB  DCB   DDNAME=OUT5,DSORG=PS,MACRF=PM,EXLST=BLKEXLST\nOUT6DCB  DCB   DDNAME=OUT6,DSORG=PS,MACRF=PM,EXLST=BLKEXLST\nOUT7DCB  DCB   DDNAME=OUT7,DSORG=PS,MACRF=PL,RECFM=FB,EXLST=BLKEXLST\nBLKEXLST DC    X'85',AL3(DCBEXIT)\nINFILE   DCB   DDNAME=TAPEIN,DSORG=PS,MACRF=GM,EODAD=A70STATS\nSYSOUT   DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,RECFM=FBM,            +\n               LRECL=133,BLKSIZE=665\n         PRINT GEN\n         SPACE 2\n***********************************************************************\n*        D E C L A R A T I V E S   F O R   V P R I N T                *\n***********************************************************************\n         SPACE\nVSAVE    DC    18F'0'                   REGISTER SAVE AREA\nVRLTH    DC    F'0'               LTH OF INPUT RECORD\nVRLTHL   DC    F'0'               LTH OF INPUT RECORD LEFT TO MOVE\nVRLTHO   DC    F'0'               LTH OF OUTPUT RECORD\n*VRLTH2L DC    F'0'               LTH OF OUTPUT RECORD LEFT TO MOVE\nRECADDR  DC    F'0'               ADDRESS OF INPUT RECORD\nOFFADDR  DC    F'0'               OFFSET TO INPUT DATA TO MOVE\nLASTOFF  DC    F'0'               OFFSET TO LAST MOVED DATA\nRECADDRO DC    F'0'               ADDRESS OF OUTPUT RECORD\nOFFADDRO DC    F'0'               OFFSET TO OUTPUT DATA AREA\nPAGECTR1 DC    PL3'0'                   OUT1 PAGE COUNTER\nPAGECTR2 DC    PL3'0'                   OUT2 PAGE COUNTER\nPAGECTR3 DC    PL3'0'                   OUT3 PAGE COUNTER\nLINECTR1 DC    PL3'75'            OUT1 LINE COUNTER\nLINECTR2 DC    PL3'75'            OUT2 LINE COUNTER\nLINECTR3 DC    PL3'75'            OUT3 LINE COUNTER\nINCTR    DC    PL4'0'                   INPUT RECORDS COUNTER\nOUTCTR1  DC    PL4'0'                   RECORDS ON OUT1 COUNTER\nOUTCTR2  DC    PL4'0'                   RECORDS ON OUT2 COUNTER\nOUTCTR3  DC    PL4'0'                   RECORDS ON OUT3 COUNTER\nOUTCTR4  DC    PL4'0'                   RECORDS ON OUT4 COUNTER\nOUTCTR5  DC    PL4'0'                   RECORDS ON OUT5 COUNTER\nOUTCTR6  DC    PL4'0'                   RECORDS ON OUT6 COUNTER\nOUTCTR7  DC    PL4'0'             RECORDS ON OUT7 COUNTER\nONE      DC    P'1'\nTWO      DC    P'2'\nTHREE    DC    P'3'\nHD1      DS    0CL30\n         DC    C'DATE'\nHD1DAY   DC    X'40202020'\n         DC    C'/'\nHD1MTH   DS    CL2\n         DC    C'/'\nHD1YR    DS    CL2\n         DC    CL10'     PAGE'\nHD1PAGE  DS    CL6\nPRINT    DS    0CL133\nCTLCHR   DC    X'09'\nP        DS    CL132\nPLEDWD1  DC    12X'4020202020202020212040'\n         SPACE\n*                                       END OF FILE MESSAGES\n         SPACE\nSHD1     DS    0CL58\n         DC    CL20' '\nSEDWD1   DS    CL8\n         DC    CL30'  RECORDS WRITTEN ON OUT1'\nSHD2     DS    0CL58\n         DC    CL20' '\nSEDWD2   DS    CL8\n         DC    CL30'  RECORDS WRITTEN ON OUT2'\nSHD3     DS    0CL58\n         DC    CL20' '\nSEDWD3   DS    CL8\n         DC    CL30'  RECORDS WRITTEN ON OUT3'\nSHD4     DS    0CL58\n         DC    CL20' '\nSEDWD4   DS    CL8\n         DC    CL30'  RECORDS WRITTEN ON OUT4'\nSHD5     DS    0CL58\n         DC    CL20' '\nSEDWD5   DS    CL8\n         DC    CL30'  RECORDS WRITTEN ON OUT5'\nSHD6     DS    0CL58\n         DC    CL20' '\nSEDWD6   DS    CL8\n         DC    CL30'  RECORDS WRITTEN ON OUT6'\nSHD7     DS    0CL58\n         DC    CL20' '\nSEDWD7   DS    CL8\n         DC    CL30'  RECORDS WRITTEN ON OUT7'\nSHDUT1   DS    0CL58\n         DC    CL20' '\nSEDWDUT1 DS    CL8\n         DC    CL30'  RECORDS READ ON TAPEIN'\n         SPACE\n         LTORG\nR0       EQU   0                       REGISTER EQUATES\nR1       EQU   1                       *\nR2       EQU   2                       *\nR3       EQU   3                       *\nR4       EQU   4                       *\nR5       EQU   5                       *\nR6       EQU   6                       *\nR7       EQU   7                       *\nR8       EQU   8                       *\nR9       EQU   9                       *\nR10      EQU   10                      *\nR11      EQU   11                      *\nR12      EQU   12                      *\nR13      EQU   13                      *\nR14      EQU   14                      *\nR15      EQU   15                      *\nCONTROLS DSECT\n         COPY  SDP10\nSELECTS  DS    0F\n         COPY  SDP20\nVPRINT   CSECT\n         END   VPRINT\n//LKED.SYSLMOD DD DSN=HALL.LINKLIB(DATEFB),DISP=SHR\n//\n//*                 NO OVERLAY FOR TESTING...\n//*\n//LKED.OLDIN DD *\n         ENTRY ROOTSECT\n       OVERLAY ONE\n        INSERT CTRLEDIT\n       OVERLAY ONE\n        INSERT VPRINT\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DATEFBJ": {"ttr": 6657, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03?\\x00\\x99\\x03?\\x12U\\x00)\\x00)\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-02T00:00:00", "modifydate": "1999-02-02T12:55:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "RH87944"}, "text": "//DATEFB   JOB                                                          JOB11965\n/*ROUTE  PRINT R7\n//*\n//*            DSN=CBT.SOURCE(DATEFBJ)\n//*\n//*\n//*********************************************************************\n//*\n//*      TEST DATEFB AGAINST A KNOWN RESULT....\n//*\n//*********************************************************************\n//TIME  EXEC PGM=DATEFB\n//STEPLIB DD DSN=HALL.LINKLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//SYSABEND DD SYSOUT=*\n//OUT1 DD SYSOUT=*\n//TAPEIN   DD  DSN=HALL.DATAFB,       INPUT FILE TO BE CHANGED\n//         DISP=SHR\n//OUT4     DD  DSN=HALL.DATAFB2,      OUTPUT FILE\n//         DISP=SHR\n//*\n//*\n//*      DATEFB CONTROL CARDS\n//*\n//TIME.SYSIN DD *\nINPUT=TAPEIN,CONTROL=(20,2,A,59,2,H)\n//*                   |  | | |  | |DATA TYPE = HEX\n//*                   |  | | |  |LTH OF HEX DATA (MULT OF 2)\n//*                   |  | | |OFFSET TO HEX DATA\n//*                   |  | |DATA TYPE = CHARACTER\n//*                   |  |LTH OF DATA\n//*                   |OFFSET TO CHAR DATA\nOUTPUT=OUT4\nSELECT=OUT4,CF1=(=19),CF2=(=19)\n/*                |         |\n//*               |         |\n//*               |         |\n//*               |         |HEX DATA TO INSERT AT OFFSET 59\n//*               |CHAR DATA TO INSERT AT OFFSET 20\n//*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DATEVB": {"ttr": 6659, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x12F\\x08\\x90\\x08\\x90\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T12:46:00", "lines": 2192, "newlines": 2192, "modlines": 0, "user": "RH87944"}, "text": "//DATEVB   JOB\n/*ROUTE  PRINT R7\n//STEP1 EXEC PGM=IEBGENER,REGION=50K\n//SYSPRINT DD SYSOUT=A\n//SYSIN DD DUMMY\n//SYSUT2 DD DSN=&&T(SDP10),UNIT=SYSDA,DISP=(,PASS),SPACE=(TRK,(5,1,5)),\n//  DCB=(RECFM=FB,LRECL=80,BLKSIZE=9440),VOL=SER=WORK01\n//SYSUT1 DD *\nSTART1   DC    F'0'                     CONTROL FIELD 1\nLENGTH1  DC    F'0'                     *\nTYPE1    DC    C'A'                     *\nSTART2   DC    F'0'                     CONTROL FIELD 2\nLENGTH2  DC    F'0'                     *\nTYPE2    DC    C'A'                     *\nSTART3   DC    F'0'                     CONTROL FIELD 3\nLENGTH3  DC    F'0'                     *\nTYPE3    DC    C'A'                     *\nSTART4   DC    F'0'                     CONTROL FIELD 4\nLENGTH4  DC    F'0'                     *\nTYPE4    DC    C'A'                     *\nSTART5   DC    F'0'                     CONTROL FIELD 5\nLENGTH5  DC    F'0'                     *\nTYPE5    DC    C'A'                     *\n         SPACE\nOPENFLGS DC    BL1'0'                   OPEN FLAGS\nSTRTPOS  DC    C' '                START POSITION\n*        DC    C' '                START AT DATA, NOT RDW\n*        DC    C'R'                START AT RDW, POS 1 IN DECIMAL\n*        DC    C'H'                START AT RDW, POS 0 IN HEX\nOUT1CTR  DC    F'0'                     OUT1 COUNTER\nOUT2CTR  DC    F'0'                     OUT2 COUNTER\nOUT3CTR  DC    F'0'                     OUT3 COUNTER\nOUT4CTR  DC    F'0'                     OUT4 COUNTER\nOUT5CTR  DC    F'0'                     OUT5 COUNTER\nOUT6CTR  DC    F'0'                     OUT6 COUNTER\nOUT7CTR  DC    F'0'                     OUT7 COUNTER\nHEAD1    DC    CL74'RECORDS SPLIT TO OUT1'\nHEAD2    DC    CL74'RECORDS SPLIT TO OUT2'\nHEAD3    DC    CL74'RECORDS SPLIT TO OUT3'\n/*\n//*\n//STEP2 EXEC PGM=IEBGENER,REGION=50K\n//SYSPRINT DD SYSOUT=A\n//SYSIN DD DUMMY\n//SYSUT2 DD DSN=&&T(SDP20),UNIT=SYSDA,DISP=(SHR,PASS)\n//SYSUT1 DD *\n         DC    F'0'                     SELECT 1\n         DC    X'80'                    CF1\n         DC    111X'FF'                 *\n         DC    F'12'                    CF2 CONTROL TABLE DISPLACEMENT\n         DC    X'80'                    *   COMPARE CODE\n         DC    111X'FF'                 *   SEARCH VALUE\n         DC    F'24'                    CF3\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'36'                    CF4\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'48'                    CF5\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         SPACE\n         DC    F'0'                     SELECT 2\n         DC    X'80'                    CF1\n         DC    111X'FF'                 *\n         DC    F'12'                    CF2\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'24'                    CF3\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'36'                    CF4\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'48'                    CF5\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         SPACE\n         DC    F'0'                     SELECT 3\n         DC    X'80'                    CF1\n         DC    111X'FF'                 *\n         DC    F'12'                    CF2\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'24'                    CF3\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'36'                    CF4\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'48'                    CF5\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         SPACE\n*                                       SELECT 4\n         DC    F'0'                     CF1\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'12'                    CF2\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'24'                    CF3\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'36'                    CF4\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'48'                    CF5\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         SPACE\n*                                       SELECT 5\n         DC    F'0'                     CF1\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'12'                    CF2\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'24'                    CF3\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'36'                    CF4\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'48'                    CF5\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n/*\n//*\n//STEP3 EXEC HLASMC,PARMC='XREF(FULL)'\n//ASM.SYSLIB DD\n//          DD\n//    DD DSN=&&T,DISP=(SHR,PASS)\n//SYSIN DD *\n**********************************************************************\n*\n*        MODIFICATIONS:\n*        JULY 03, 1996...ADDED COMMENT CHECK IN INPUT VERIFY\n*                        ROUTINE. COMMENTS CAN START WITH * OR /.\n*\n*        JUNE 24, 1996...ADDED START=HEX PARM THAT SAYS START AT\n*                        OFFSET 0 AND USE HEXADECIMAL START POSITION\n*                        NOTE...START=HEX MUST BE FIRST CONTROL CARD\n*\n**********************************************************************\n*\n*                    DATEVB\n*\n*DATEVB CAN BE USED TO SPLIT RECORDS FROM A VARIABLE LENGTH FILE\n*TO A SYSOUT FILE OR TO ANOTHER VARIABLE LENGTH FILE.\n*DATEVB CAN ALSO BE USED TO CREATE A FIXED LENGTH FILE FROM A\n*VARIABLE LENGTH FILE.\n*\n*                    JCL\n*\n*TO EXECUTE DATEVB THE FOLLOWING JCL IS REQUIRED:\n*\n*//   JOBCARD\n*//STEPNAME   EXEC PGM=DATEVB,REGION=60K\n*//STEPLIB    DD   DSN=SYS1.USERLIB2,DISP=SHR\n*//SYSPRINT   DD   SYSOUT=A\n*//TAPEIN     DD   DSN=....ETC.\n*//OUT1\n*//OUT7\n*//SYSIN      DD  *\n*CONTROL CARDS\n*//\n*\n*THE OUT1 TO OUT7 DD CARDS ARE:\n*//OUT1       DD  SYSOUT=A\n*//OUT2       DD  SYSOUT=A\n*//OUT3       DD  SYSOUT=A\n*//OUT4       DD  DSN=, UNIT=, DISP=, SPACE=, DCB=\n*//OUT5       DD  ''\n*//OUT6       DD  ''\n*//OUT7       DD  ''\n*\n*FOR OUT4, OUT5, OUT6:\n*DSN= ANY NAME UP TO 44 CHARACTERS LONG CONSISTING OF\n*     1-8 CHARS.1-8 CHARS.ETC\n*UNIT= TAPE FOR TAPE\n*      USER  FOR PERMANENT DISK FILES\n*      SYSDA   FOR TEMPORARY FILES\n*DISP= (,CATLG) FOR PERMANENT FILES\n*      (,PASS)  FOR TEMPORARY FILES\n*SPACE= IS REQUIRED ONLY IF UNIT=SYSDA OR USER\n*      (TRK,(NBR OF TRKS,3),RLSE)\n*      NBR OF TRKS DEPENDS ON THE NUMBER OF RECORDS BEING SPLIT.\n*      IF BLKSIZE=3532, THERE WILL BE 5 BLOCKS PER TRACK ON A\n*      3350, SO 100 BLOCKS WOULD NEED 20 TRACKS.\n*DCB=  (LRECL=REC LEN+4,BLKSIZE=(REC LEN+4)*BLK FACTOR)+4)\n*      EG- IF REC LEN = 1760 AND BLK FACTOR = 2,\n*      LRECL=1764,BLKSIZE=3532\n*      IF RECFM IS LEFT OFF OUT4 - OUT6 DCB'S, IT WILL\n*      DEFAULT TO THE RECFM OF THE INPUT FILE.\n*\n*FOR OUT7:\n*DCB=  (RECFM=FB,LRECL=REC LEN,BLKSIZE=REC LEN*BLK FACTOR)\n*      THE VB FILE IS REBLOCKED TO THE REC LEN SPECIFIED IN\n*      THE LRECL=. IF THE FB LRECL IS LARGER THAN THE VB LRECL,\n*      THE FB RECORD IS PADDED WITH BLANKS.\n*\n*\n*                    CONTROL CARDS\n*\n*DATEVB IS CONTROLLED BY THE FOLLOWING CONTROL CARDS:\n*INPUT=TAPEIN,CONTROL=(CF1 CONTROL DATA,....CF5 CONTROL DATA)\n*OUTPUT=OUT1,OUT2,.....OUT7\n*START=HEX\n*START=RDW\n*SELECT=OUT1,CF1=\n*HEAD1=\n*HEAD2=\n*HEAD3=\n*\n*THE INPUT= STATEMENT IS USED TO SET UP THE SELECTION CRITERIA\n*FOR THE 1 TO 5 CONTROL FIELDS.\n*\n*THE OUTPUT= STATEMENT DETERMINES WHICH OF THE 7 OUTPUT\n*FILES WILL BE USED.\n*\n*THE START=HEX STATEMENT INDICATES THAT THE SEARCH STARTS\n*              AT OFFSET 0(THE RECORD LENGTH FIELD) AND THAT\n*              THE START POSITION IS IN HEXADECIMAL.\n*\n*THE START=RDW STATEMENT INDICATES THAT THE SEARCH STARTS\n*              AT OFFSET 0(THE RECORD LENGTH FIELD) AND THAT\n*              THE START POSITION IS IN DECIMAL.\n*\n*IF  START=RDW OR START=HEX IS NOT SPECIFIED, THE SEARCH\n*              STARTS AT OFFSET 5(THE RECORD DATA) AND THE\n*              START POSITION IS IN DECIMAL.\n*\n*THE SELECT= STATEMENT IS USED TO DETERMINE WHICH OUTPUT\n*FILE WILL RECEIVE THE DATA SELECTED BY THE SPECIFIED 1\n*TO 5 CONTROL FIELDS.\n*\n*THE HEAD1= STATEMENT IS USED TO CHANGE THE DEFAULT HEADING\n*ON THE OUT1 LISTING.\n*\n*THE HEAD2= STATEMENT IS USED TO CHANGE THE DEFAULT HEADING\n*ON THE OUT2 LISTING.\n*\n*THE HEAD3= STATEMENT IS USED TO CHANGE THE DEFAULT HEADING\n*ON THE OUT3 LISTING.\n*\n*THE FOLLOWING RESTRICTIONS MUST BE OBSERVED:\n*\n*OUT1, OUT2, OUT3 CAN ONLY BE SYSOUT=A FILES.\n*\n*OUT4, OUT5, OUT6 CAN ONLY BE VB FILES ON TAPE OR DISK.\n*\n*OUT7 CAN ONLY BE AN FB FILE ON TAPE OR DISK.\n*\n*ON THE OUTPUT= CARD, THE OUT'S MUST BE IN SEQUENCE.\n*\n*\n*THERE CAN BE 1 TO 5 CONTROL FIELDS IN THE CONTROL=(START,LENGTH,TYPE)\n*PARAMETER.\n*\n*START\n*START IS THE STARTING POSITION WITHIN THE RECORD.\n*IF THE START POSITION IS OUTSIDE THE LENGTH OF THE VB RECORD,\n*IT IS TREATED THE SAME AS CONDITION NOT MET.\n*\n*LENGTH\n*LENGTH IS THE NUMBER OF CHARACTERS IN THE FIELD.\n*\n*THE MAXIMUM LENGTH ALLOWED FOR ALPHANUMERIC FIELDS IS 111.\n*\n*THE MAXIMUM LENGTH ALLOWED FOR PACKED OR HEXADECIMAL FIELDS IS 16.\n*\n*FOR PACKED FIELDS, THE LENGTH IS THE NUMBER OF DIGITS IN THE\n*FIELD, NOT THE NUMBER OF BYTES IN THE FIELD...EG...A 2 BYTE\n*PACKED FIELD WILL HOLD 3 DIGITS...123C, SO THE LENGTH IS 3, NOT 2.\n*TO SPECIFY A POSITIVE(+) OR A NEGATIVE(-) PACKED NUMBER, THE LAST\n*DIGIT MUST CONSIST OF THE NUMBER AND A 12 OR 11 PUNCH. THIS CAN\n*BE ACCOMPLISHED BY USING THE CHARACTER '{' AND THE LETTERS\n*'A - I' TO DESIGNATE +0 TO +9  OR THE CHARACTER '}' AND THE\n*LETTERS 'J - R' TO DESIGNATE -0 TO -9. FOR EXAMPLE, TO SELECT +1230,\n*YOU WOULD CODE 123{, AND TO SELECT -1230 YOU WOULD CODE 123}. TO\n*SELECT +1234 YOU WOULD CODE 123D, AND TO SELECT -1879, YOU WOULD\n*CODE 187R.\n*THE CORRESPONDING LETTERS FOR THE POSITIVE AND NEGATIVE NUMBERS ARE:\n*     +0 = {            -0 = }\n*     +1 = A            -1 = J\n*     +2 = B            -2 = K\n*     +3 = C            -3 = L\n*     +4 = D            -4 = M\n*     +5 = E            -5 = N\n*     +6 = F            -6 = O\n*     +7 = G            -7 = P\n*     +8 = H            -8 = Q\n*     +9 = I            -9 = R\n*\n*FOR HEXADECIMAL FIELDS, THE LENGTH IS A MULTIPLE OF 2, AS IT TAKES\n*2 DIGITS TO REPRESENT 1 HEXADECIMAL DIGIT...EG...X'12' WOULD BE\n*12 IN YOUR CONTROL FIELD, SO THE LENGTH IS 2, NOT 1.\n*\n*TYPE\n*THE TYPE SPECIFIED CAN BE 1 OF THE FOLLOWING:\n*'A' TO INDICATE ALPHANUMERIC DATA,\n*'P' TO INDICATE PACKED DATA,\n*'H' TO INDICATE HEXADECIMAL DATA.\n*\n*THERE CAN BE 1 TO 5 SELECT STATEMENTS FOR EACH OUT FILE.\n*\n*RECORDS CAN BE SELECTED ON:\n*  1- ALL CONDITIONS           - CF1=ALL,...CF5=...\n*  2- EQUAL CONDITIONS         - CF1=(= ),...CF5=...\n*  3- GREATER THAN CONDITIONS  - CF1=(> ),...CF5=...\n*  4- LESS THAN CONDITIONS     - CF1=(< ),...CF5=...\n*  5- NOT EQUAL CONDITIONS     - CF1=(# ),...CF5=...\n*\n*THE ABILITY TO PUT A HEADING ON OUT1, OUT2, OUT3 HAS BEEN INCLUDED.\n*THE CONTROL CARDS ARE:\n*HEAD1=\n*HEAD2=\n*HEAD3=\n*THE HEADINGS CAN BE 1-74 CHARACTERS LONG. IF HEADING CARDS ARE NOT\n*INCLUDED, THE DEFAULTS ARE:\n*   HEAD1=RECORDS SPLIT TO OUT1\n*   HEAD2=RECORDS SPLIT TO OUT2\n*   HEAD3=RECORDS SPLIT TO OUT3\n*\n*\n*                         CONTROL CARDS EXAMPLE\n*\n*INPUT=TAPEIN,CONTROL=(1,1,A,59,6,A,72,5,P,32,2,H)\n*OUTPUT=OUT1,OUT2,OUT3,OUT4,OUT7\n*SELECT=OUT1,CF1=ALL\n*SELECT=OUT2,CF2=(>111100)\n*SELECT=OUT3,CF3=(<40406)\n*SELECT=OUT4,CF3=(=40405)\n*SELECT=OUT4,CF3=(=40405)\n*SELECT=OUT7,CF1=ALL\n*HEAD1=NEW HEADING FOR OUT1\n*\n*ADDITIONAL COPIES OF THIS DOCUMENTATION CAN BE OBTAINED BY LISTING\n*   HALL.SOURCE.CNTL(HOWVSPLT)\n*\n**********************************************************************\n         EJECT\nROOTSECT CSECT\n         SAVE  (14,12)\n         LR    R12,R15                  LOAD BASE REGISTER\n         USING ROOTSECT,R12             ESTABLISH ADDRESSABILITY\n         ST    R13,ROOTSAVE+4           CHAIN SAVE AREAS\n         LR    R11,R13                  *\n         LA    R13,ROOTSAVE             *\n         ST    R13,8(R11)               *\n         SPACE 2\n***********************************************************************\n*        CALL ROUTINE TO ANALYZE CONTROL CARDS AND TO SET UP          *\n*        THE TABLES USED TO PRINT THE REPORTS                         *\n***********************************************************************\n         SPACE\n         CALL  CTRLEDIT,(CONTROLS,SELECTS)\n         SPACE 2\n***********************************************************************\n*        CALL ROUTINE USED TO SELECT RECORDS AND PRODUCE ALL          *\n*        THE OUTPUTS                                                  *\n***********************************************************************\n         SPACE\n         CALL  VPRINT,(CONTROLS,SELECTS)\n         SPACE 2\n*                                       RETURN CONTROL TO SYSTEM\n         L     R13,ROOTSAVE+4           *\n         RETURN (14,12),RC=0            *\n         SPACE\nROOTSAVE DC    18F'0'                   REGISTER SAVE AREA\nR0       EQU   0                        REGISTER EQUATES\nR1       EQU   1                        *\nR2       EQU   2                        *\nR3       EQU   3                        *\nR4       EQU   4                        *\nR5       EQU   5                        *\nR6       EQU   6                        *\nR7       EQU   7                        *\nR8       EQU   8                        *\nR9       EQU   9                        *\nR10      EQU   10                       *\nR11      EQU   11                       *\nR12      EQU   12                       *\nR13      EQU   13                       *\nR14      EQU   14                       *\nR15      EQU   15                       *\n*\n*        THIS TABLE CONTAINS THE START POSITION WITHIN THE RECORD,\n*        THE LENGTH OF THE FIELD AND THE TYPE OF DATA FOR CF'S\n*        1 TO 5. WHEN FIRST CALLED, THE TABLE IS INITIALIZED AS\n*        FOLLOWS : START = 0, LENGTH = 0, TYPE = A\n*\nCONTROLS DS    0F\n         COPY  SDP10\n*\n*        THIS TABLE CONTAINS THE CF DISPLACEMENT, TYPE OF COMPARE\n*        (=,<,>), AND THE VALUE TO BE TESTED FOR IN THE CONTROL FIELD.\n*        THERE IS A SECTION FOR OUT1 - OUT6. EACH SECTION ALLOWS\n*        FOR 5 SETS OF CONTROL FIELDS. WHEN FIRST CALLED, EACH SECTION\n*        IS INITIALIZED AS FOLLOWS :\n*              CF DISPLACEMENT = 0 TO 36\n*              TYPE OF COMPARE = X'80'\n*              VALUE = 11X'FF'\n*\nSELECTS  DS    0F\n*                                       SELECT FOR OUT1\n         COPY  SDP20\n*                                       SELECT FOR OUT2\n         COPY  SDP20\n*                                       SELECT FOR OUT3\n         COPY  SDP20\n*                                       SELECT FOR OUT4\n         COPY  SDP20\n*                                       SELECT FOR OUT5\n         COPY  SDP20\n*                                       SELECT FOR OUT6\n         COPY  SDP20\n*                                       SELECT FOR OUT7\n         COPY  SDP20\n         END   ROOTSECT\n/*\n//*\n//STEP4 EXEC HLASMC,PARMC='XREF(FULL)'\n//ASM.SYSLIB DD\n//          DD\n//    DD DSN=&&T,DISP=(SHR,PASS)\n//ASM.SYSIN DD *\n         EJECT\n***********************************************************************\n*        E D I T   C O N T R O L   C A R D S                          *\n***********************************************************************\n         SPACE 2\nCTRLEDIT CSECT                          NAME CSECT\n         B     12+4(R0,R15)             BRANCH AROUND IDENTIFIER\n         DC    C'EDIT SECTION'\nA10SAVE  DS    0H\n         SAVE  (14,12)                  SAVE REGISTERS\n         BALR  R12,0                    LOAD BASE REGISTER\n         USING *,R12                    ESTABLISH ADDRESSABILITY\n         ST    R13,EDITSAVE+4           CHAIN SAVE AREAS\n         LR    R11,R13                  *\n         LA    R13,EDITSAVE             *\n         ST    R13,8(R11)               *\n         L     R5,0(0,R1)               LOAD TABLE BASE REG\n         USING TABLED,R5                ESTABLISH TABLE ADDRESSABILITY\n         SPACE 2\n         OPEN  (INFILE,,OUTFILE,(OUTPUT)) OPEN CONTROL FILES\n         SPACE\n         BAL   R11,Y10SKIP1             SKIP TO NEW PAGE\n         MVC   P(L'CTLHEAD),CTLHEAD     MOVE HEADING TO PRINT\n         BAL   R11,Y10WSP3              PRINT, SPACE 3\n         SPACE\nA20READ  DS    0H\n         GET   INFILE                   READ CONTROL CARD\n         LR    R2,R1                    MOVE RECORD ADDRESS TO REG 2\n         MVC   P(80),0(R1)              MOVE RECORD TO PRINT\n         BAL   R11,Y10WSP2              PRINT, SPACE 2\n         CLI   0(R2),C'*'         START WITH *?\n         BE    A20READ            YES, IT'S A COMMENT\n         CLI   0(R2),C'/'         START WITH /?\n         BE    A20READ            YES, IT'S A COMMENT\n         ST    R2,EDITSAVE        SAVE RECORD ADDRESS\n         SPACE\nA30      NOP   A60\nA40      NOP   A50\n         SPACE\n         CLC   0(6,R2),INPUT            IS CONTROL = INPUT= ?\n         BNE   A50                      NO, CHECK FOR OUTPUT=\n         SPACE\n         OI    A40+1,X'F0'              CHANGE A40 TO A BRANCH\n         BAL   R11,B10INPUT             EDIT INPUT CARD\n         B     A20READ                  READ NEXT CARD\n         SPACE\nA50      CLC   0(7,R2),OUTPUT           IS CONTROL = OUTPUT= ?\n         BNE   A60                      NO, CHECK FOR SELECT=\n         SPACE\n         OI    A30+1,X'F0'              CHANGE A30 TO A BRANCH\n         BAL   R11,C10OUT1              EDIT OUTPUT CARD\n         B     A20READ                  READ NEXT CARD\n         SPACE\nA60      DS    0H\n         CLC   0(7,R2),SELECT           IS CONTROL = SELECT=\n         BNE   A70HEAD1                 NO, CHECK FOR HEADING CARDS\n         SPACE\n         BAL   R11,D10SLECT             EDIT SELECT CARD\n         B     A20READ                  READ NEXT CARD\n         SPACE\nA70HEAD1 DS    0H\n         CLC   0(6,R2),HD1              CONTROL = HEAD1 ?\n         BNE   A70HEAD2                 NO, CHECK FOR HEAD2\n         MVC   HEAD1,6(R2)              STORE OUT1 HEADING\n         B     A20READ                  READ NEXT CONTROL CARD\n         SPACE\nA70HEAD2 DS    0H\n         CLC   0(6,R2),HD2              CONTROL = HEAD2 ?\n         BNE   A70HEAD3                 NO, CHECK FOR HEAD3\n         MVC   HEAD2,6(R2)              STORE OUT2 HEADING\n         B     A20READ                  READ NEXT CONTROL CARD\n         SPACE\nA70HEAD3 DS    0H\n         CLC   0(6,R2),HD3              CONTROL = HEAD3 ?\n         BNE   A75START                 NO, PRINT ERROR MESSAGE\n         MVC   HEAD3,6(R2)              STORE OUT3 HEADING\n         B     A20READ                  READ NEXT CONTROL CARD\n         SPACE\nA75START DS    0H\n         CLC   0(9,R2),STARTRDW         CONTROL = START=RDW ?\n         BNE   A76START                 NO, SEE IF START=HEX\n         MVI   STRTPOS,C'R'             YES, SAY START AT RDW\n         B     A20READ                  READ NEXT CONTROL CARD\n         SPACE 1\nA76START DS    0H\n         CLC   0(9,R2),STARTHEX         CONTROL = START=HEX ?\n         BNE   A80ERROR                 NO, PRINT ERROR MESSAGE\n         MVI   STRTPOS,C'H'             YES, SAY START AT RDW & HEX\n         B     A20READ                  READ NEXT CONTROL CARD\n         SPACE 1\nA80ERROR DS    0H\n         MVC   P(L'CTLMS1),CTLMS1       MOVE MESSAGE TO PRINT\n         BAL   R11,Y10WSP2              PRINT, SPACE 2\n         B     A20READ            GET NEXT CARD\n         SPACE 2\n***********************************************************************\n*        E N D   O F   C O N T R O L   C A R D S                      *\n***********************************************************************\n         SPACE 2\nA90END   DS    0H\n         MVC   P(L'CTLMS13),CTLMS13     MOVE MESSAGE TO PRINT\n         BAL   R11,Y10WSP3              PRINT, SPACE 3\n         SPACE\n         CLOSE (INFILE,,OUTFILE)        CLOSE FILES\n         L     R13,EDITSAVE+4           RETURN TO ROOT SEGMENT\n         RETURN (14,12),RC=0            *\n         EJECT\n***********************************************************************\n*        E D I T   I N P U T   C A R D                                *\n***********************************************************************\n         SPACE 2\nB10INPUT DS    0H\n         LA    R2,6(R2)                 ADD 6 TO RECORD ADDRESS\n         CLC   0(6,R2),TAPEIN           INPUT = TAPEIN\n         BE    B20CTL                   YES, CHECK FOR CONTROL=\n         SPACE\n         MVC   P(L'CTLMS2),CTLMS2       MVC MESSAGE TO PRINT\n         B     B90ABEND                 PRINT, SPACE 1, CANCEL JOB\n         SPACE\nB20CTL   DS    0H\n         LA    R2,7(R2)                 POINT TO CONTROL=\n         CLC   0(9,R2),CONTROL          IS CONTROL = CONTROL=( ?\n         BE    B30LA                    YES, STORE VALUES\n         SPACE\n         MVC   P(L'CTLMS3),CTLMS3       MOVE MESSAGE TO PRINT\n         B     B90ABEND                 PRINT, SPACE 1, CANCEL JOB\n         SPACE\nB30LA    DS    0H\n         LA    R10,CONTROLS             LOAD ADDRESS CONTROL TABLE\n         LA    R2,9(R2)                 POINT TO START LOCATION\nB40LOOP  DS    0H\n         LR    R3,R2                    STORE START ADDRESS\nB41      DS    0H\n         CLI   0(R2),C'0'               IS DIGIT LESS THAN 0 ?\n         BL    B42                      YES, CHECK FOR COMMA\n         SPACE\n         CLI   0(R2),C'9'               IS DIGIT GREATER THAN 9 ?\n         BH    B50ERROR                 YES, GO TO ERROR ROUTINE\n         SPACE\n         LA    R2,1(R2)                 POINT TO NEXT DIGIT\n         B     B41                      CHECK NEXT DIGIT\n*\nB42      DS    0H\n         CLI   STRTPOS,C'H'       START AT RDW & OFFSET IN HEX?\n         BNE   B43                NO, CAN JUST HAVE COMMA\n*        BNE   B50ERROR           NO, GO TO ERROR ROUTINE\n*\n         CLI   0(R2),C'A'               IS DIGIT LESS THAN A ?\n         BL    B43                      YES, CHECK FOR COMMA\n         SPACE\n         CLI   0(R2),C'F'               IS DIGIT GREATER THAN F ?\n         BH    B50ERROR                 YES, GO TO ERROR ROUTINE\n         SPACE\n         LA    R2,1(R2)                 POINT TO NEXT DIGIT\n         B     B42                      CHECK NEXT DIGIT\n*\nB43      DS    0H\n         CLI   0(R2),C','               IS DIGIT = , ?\n         BNE   B50ERROR                 NO, GO TO ERROR ROUTINE\n         SPACE\n         LR    R4,R2                    CALCULATE NUMBER OF DIGITS\n         SR    R4,R3                    IN START LOCATION PARAMETER\n         CLI   STRTPOS,C'H'       START AT RDW & OFFSET IN HEX?\n         BNE   B43A               NO, ON WE GO\n         XC    DWORD,DWORD        CLEAR DWORD\n         XC    TRANDATA,TRANDATA  CLEAR TRANDATA\n         SR    R15,R15            CLEAR R15\n         LA    R15,DWORD+4        R15 -> AT END OF DWORD\n         LA    R15,TRANDATA+4     R15 -> AT END OF DWORD\n*        SRL   R4,1               DIVIDE BY FOR (HEX DATA)\n         SR    R15,R4             R15 -> WHERE DATA GOES\n*        SLL   R4,1               PUT BACK\n         BCTR  R4,0               SUBTRACT 1 TO GET MACHINE LGTH\n         EX    R4,MVCDATA         PUT CHAR DATA IN DWORD\n*        EX    R4,LOADDATA        PUT CHAR DATA IN R15\n*        ST    R15,DWORD+4        PUT IT IN DWORD\n*        EX    R4,TRHEX2          TRANSLATE INPUT TO 00-0F\n*        TR    DWORD,TRTAB        TRANSLATE TO 00-0F\n         TR    TRANDATA(4),TRTAB2 TRANSLATE TO 00-0F\n         PACK  DWORD(5),TRANDATA(5) PACK FIELD\n         L     R4,DWORD           PUT IT IN R4\n*        L     R4,DWORD+4         PUT IT IN R4\n*        LA    R15,1(0,R7)        R15 = REAL LTH OF INPUT\n*        C     R15,MAXPACK        AT MAX LTH OF 16 ?\n*        BE    F50MAX             YES, TREAT DIFFERENTLY\n*        EX    R15,F50PACK        NO, PACK ALL OF FIELD\n*        BCTR  R4,0                     SUBTRACT 1 TO GET MACHINE LGTH\n*        EX    R4,B48PACK               PACK START LOC IN DOUBLE WORD\n*        CVB   R4,DWORD                 CONVERT TO BINARY\n*        SRL   R4,8               DROP GARBAGE BYTE\n         B     B43C               GO SAVE HEX OFFSET\nTRHEX2   TR    TRANDATA(0),TRTAB2 TRANSLATE TO 00-0F\nMVCDATA  MVC   0(0,R15),0(R3)     SET UP DATA FOR TRANSLATE\n*VCDATA  MVC   DWORD(0),0(R3)     SET UP DATA FOR TRANSLATE\nLOADDATA ICM   R15,0,0(R3)        PUT DATA IN R15\nB10PACK  PACK  DWORD,TRANDATA(4)        PACK FIELD\nTRANDATA DC    D'0'\n*RTAB2   EQU   *-193              SET START OF SHORT TRANS TABLE\nTRTAB2   DS    0XL256             SET START OF SHORT TRANS TABLE\n         DC    X'00'              CHANGE 00 TO 00\n         DC    XL192'00'          CHANGE 01-C0 TO 00\n         DC    X'FAFBFCFDFEFF'    CHANGE C1-C6 TO FA-FF\n         DC    41X'00'            CHANGE C7-EF TO 00\n         DC    X'F0F1F2F3F4F5F6F7F8F9'   CHANGE F0-F9 TO F0-F9\n         DC    XL(256-(*-TRTAB2))'00'    CHANGE FA-FF TO 00\n*\nB43A     DS    0H\n         BCTR  R4,0                     SUBTRACT 1 TO GET MACHINE LGTH\n         EX    R4,B48PACK               PACK START LOC IN DOUBLE WORD\n         CVB   R4,DWORD                 CONVERT TO BINARY\n         BCTR  R4,0                     SUBT 1 TO GIVE MACHINE LENGTH\n*\nB43C     DS    0H\n         ST    R4,0(R10)                STORE START LOCATION IN TABLE\n         SPACE\n         LA    R2,1(R2)                 POINT TO LENGTH PARAMETER\n         LR    R3,R2                    STORE START OF LENGTH PARM\nB44      DS    0H\n         CLI   0(R2),C'0'               DIGIT LESS THAN 0 ?\n         BL    B46                      YES, CHECK FOR COMMA\n         SPACE\n         CLI   0(R2),C'9'               DIGIT GREATER THAN 9 ?\n         BH    B60ERROR                 YES, GO TO ERROR ROUTINE\n         SPACE\n         LA    R2,1(R2)                 POINT TO NEXT DIGIT\n         B     B44                      CHECK NEXT DIGIT\nB46      DS    0H\n         CLI   0(R2),C','               DIGIT A COMMA ?\n         BNE   B60ERROR                 NO, GO TO ERROR ROUTINE\n         SPACE\n         LR    R4,R2                    CALCULATE NUMBER OF DIGITS\n         SR    R4,R3                    IN LENGTH PARAMETER\n         SPACE\n         BCTR  R4,0                     SUBTRACT 1 TO GET MACHINE LTH\n         EX    R4,B48PACK               PACK LENGTH PARM IN DOUBLE WORD\n         CVB   R4,DWORD                 CONVERT TO BINARY\n         CLI   1(R2),C'A'               IS TYPE = A ?\n         BNE   B47PACK                  NO, MAXLEN = 16\n         C     R4,MAXLEN                LENGTH OVER MAXIMUM LTH ?\n         BH    B70ERROR                YES, GO TO ERROR ROUTINE\n         SPACE 1\nB47      DS    0H\n         L     R3,ADDLTH          R3 = LTH OF DATA TO ADD\n         AR    R3,R4              ADD THIS LTH\n         ST    R3,ADDLTH          SAVE NEW LTH TO ADD\n         BCTR  R4,0                     SUBT 1 TO GIVE MACHINE LENGTH\n         ST    R4,4(R10)                STORE LENGTH IN TABLE\n         SPACE\n         LA    R2,1(R2)                 POINT TO TYPE PARAMETER\n         CLI   0(R2),C'P'               IS TYPE = P ?\n         BE    B80STORE                 YES, STORE TYPE\n         SPACE\n         CLI   0(R2),C'A'               IS TYPE = A ?\n         BE    B80STORE                 YES, STORE TYPE\n         SPACE\n         CLI   0(R2),C'H'         IS TYPE = H ?\n         BE    B80STORE           YES, STORE TYPE\n         BAL   R11,G10SET2        POINT R2 TO WHERE ERROR MSG GOES\n         MVC   0(L'CTLMS4,R2),CTLMS4     MOVE MESSAGE TO PRINT\n         B     B90ABEND                 PRINT, SPACE 1, CANCEL JOB\n         SPACE 1\nB47PACK  DS    0H\n         C     R4,MAXPACK         IS LTH OVER 16 ?\n         BH    B75ERROR           YES, TOO BAD\n         CLI   1(R2),C'P'         PACKED DATA ?\n         BE    B47PACK2           YES, FIX PACKED LENGTH\n         SRL   R4,1               HEX LTH = LTH/2\n         B     B47                LTH NOW OKAY\n         SPACE 1\nB47PACK2 DS    0H\n         LA    R4,1(0,R4)         MAKE LTH EVEN\n         SRL   R4,1               LTH/2 = PACKED LTH\n         B     B47                PACKED LTH OKAY NOW TOO\n         SPACE 2\nB48PACK  PACK  DWORD,0(0,R3)            PACK FIELD\n         SPACE 2\nB50ERROR DS    0H\n         BAL   R11,G10SET2        POINT R2 TO WHERE ERROR MSG GOES\n         MVC   0(L'CTLMS6,R2),CTLMS6    PUT MSG UNDER BAD CHAR\n         B     B90ABEND                 PRINT, SPACE 1, CANCEL JOB\n         SPACE\nB60ERROR DS    0H\n         BAL   R11,G10SET2        POINT R2 TO WHERE ERROR MSG GOES\n         MVC   0(L'CTLMS7,R2),CTLMS7    PUT MSG UNDER BAD CHAR\n         B     B90ABEND                 PRINT, SPACE 1, CANCEL JOB\n         SPACE\nB70ERROR DS    0H\n         BAL   R11,G10SET2        POINT R2 TO WHERE ERROR MSG GOES\n         MVC   0(L'CTLMS9,R2),CTLMS9    PUT MSG UNDER BAD CHAR\n         B     B90ABEND                 PRINT, SPACE 1, CANCELL JOB\n         SPACE\nB75ERROR DS    0H\n         BAL   R11,G10SET2        POINT R2 TO WHERE THE ERROR MSG GOES\n         MVC   0(L'CTLMS9),CTLMS9 MOVE MESSAGE TO PRINT LINE\n         MVI   23(R2),C'6'        CHANGE LTH IN MSG TO 16\n         MVI   24(R2),C' '        *\n         B     B90ABEND           PRINT MSG, CANCEL JOB\n         SPACE 1\nB80STORE DS    0H\n         MVC   8(1,R10),0(R2)           STORE TYPE IN TABLE\n         CLI   1(R2),C','               ANY MORE PARAMETERS ?\n         BCR   7,R11                    NO, RETURN TO CALLER\n         SPACE 2\n         LA    R10,12(R10)              POINT TO NEXT CONTROL FIELD\n         LA    R2,2(R2)                 POINT TO NEXT START PARM\n         AP    CFCTR,ONE                ADD 1 TO CONTROL FIELD CTR\n         CP    CFCTR,FIVE               OVER 5 PARAMETERS ?\n         BNH   B40LOOP                  NO, PROCESS NEXT FIELD\n         SPACE\n         MVC   P(L'CTLMS5),CTLMS5       MOVE MESSAGE TO PRINT\n         BAL   R11,Y10WSP1              PRINT, SPACE 1\n         SPACE\nB90ABEND BAL   R11,Y10WSP1              PRINT, SPACE 1\n         ABEND 16                       CANCEL JOB\n         EJECT\n***********************************************************************\n*        E D I T   O U T P U T   C O N T R O L   C A R D              *\n***********************************************************************\n         SPACE 2\nC10OUT1  DS    0H\n         MVI   OPENFLGS,X'00'           CLEAR OPEN FLAGS\n         LA    R2,7(R2)                 POINT TO OUTPUT FILES\n         CLC   0(4,R2),OUT1             USING FILE OUT1 ?\n         BNE   C20OUT2                  NO, CHECK FOR OUT2.\n         SPACE\n         OI    OPENFLGS,B'10000000'     TURN OPEN OUT1 FLAG ON\n         LA    R2,5(R2)                 POINT TO NEXT FILE NAME\n         SPACE\nC20OUT2  DS    0H\n         CLC   0(4,R2),OUT2             USING FILE OUT2 ?\n         BNE   C30OUT3                  NO, CHECK FOR OUT3\n         SPACE\n         OI    OPENFLGS,B'01000000'     TURN OPEN OUT2 FLAG ON\n         LA    R2,5(R2)                 POINT TO NEXT FILE NAME\nC30OUT3  DS    0H\n         CLC   00(4,R2),OUT3            USING FILE OUT3 ?\n         BNE   C40OUT4                  NO, CHECK FOR OUT4\n         SPACE\n         OI    OPENFLGS,B'00100000'     TURN OPEN OUT3 FLAG ON\n         LA    R2,5(R2)                 POINT TO NEXT FILE NAME\n         SPACE\nC40OUT4  DS    0H\n         CLC   00(4,R2),OUT4            USING FILE OUT4 ?\n         BNE   C50OUT5                  NO, CHECK FOR OUT5\n         SPACE\n         OI    OPENFLGS,B'00010000'     TURN OPEN OUT4 FLAG ON\n         LA    R2,5(R2)                 POINT TO NEXT FILE NAME\n         SPACE\nC50OUT5  DS    0H\n         CLC   00(4,R2),OUT5            USING FILE OUT5 ?\n         BNE   C60OUT6                  NO, CHECK FOR OUT6\n         SPACE\n         OI    OPENFLGS,B'00001000'    TURN OPEN OUT5 FLAG ON\n         LA    R2,5(R2)                 POINT TO NEXT FILE NAME\nC60OUT6  DS    0H\n         CLC   00(4,R2),OUT6            USING FILE OUT6 ?\n         BNE   C60OUT7                  NO, CHECK FOR OUT7\n         SPACE\n         OI    OPENFLGS,B'00000100'     TURN OPEN OUT6 FLAG ON\n         LA    R2,5(R2)                 POINT TO NEXT FILE NAME\n         SPACE\nC60OUT7  DS    0H\n         CLC   0(4,R2),OUT7             USING FILE OUT7 ?\n         BNE   C70END                   NO, CHECK FOR END OF INPUT\n         SPACE\n         OI    OPENFLGS,X'02'           TURN OPEN OUT7 FLAG ON\n         LA    R2,5(0,R2)         POINT TO NEXT FILE NAME\n         SPACE\nC70END   DS    0H\n         CLI   0(R2),C' '               AT END OF CONTROL CARD ?\n         BE    C90END                   YES, RETURN TO CALLER\n         SPACE\n         MVC   P(L'CTLMS8),CTLMS8       MOVE MESSAGE TO PRINT\n         BAL   R11,Y10WSP1              PRINT, SPACE 1\n         ABEND 16                       CANCEL JOB\nC90END   BR    R11                      RETURN TO CALLER\n         EJECT\n***********************************************************************\n*        E D I T   S E L E C T   C O N T R O L   C A R D              *\n***********************************************************************\n         SPACE 2\nD10SLECT DS    0H\n         LA    R3,SELECTS               LOAD ADDRESS SELECT TABLE\n         LA    R2,7(R2)                 POINT TO SELECTED FILE NAME\n         CLC   0(4,R2),OUT1             FILE = OUT1 ?\n         BNE   D20OUT2                  NO, CHECK FOR OUT2\n         SPACE\n         LA    R9,OUT1CTR               LOAD ADDRESS OUT1 COUNTER\nD10LOOP  DS    0H\n         LA    R2,5(R2)                 POINT TO CF\n         BAL   R10,F10EDIT              EDIT CONTROL FIELDS\n         L     R15,0(0,R9)              LOAD COUNTER IN REG 15\n         LA    R10,4                    R10 = 4\n         CR    R15,R10                  IF SELECT COUNTER > 4\n         BH    D85ERROR                 BOMB RUN\n         SPACE\n         M     R14,ENTLTH               MULTIPLY BY TABLE ENTRY LENGTH\n         AR    R3,R15                   ADD DISP TO SELECT BASE REG\n         CLI   CFWK1,X'FF'              IS CONTROL FIELD 1 USED\n         BE    D12CF2                   NO, CHECK CF2\n         SPACE\n         MVC   4(L'CFWK1,R3),CFWK1           STORE CF1\n         SPACE\nD12CF2   DS    0H\n         LA    R3,116(R3)                POINT TO CF2\n         CLI   CFWK2,X'FF'              CONTROL FIELD 2 USED ?\n         BE    D14CF3                   NO, CHECK FOR CF3\n         SPACE\n         MVC   4(L'CFWK2,R3),CFWK2           STORE CF2\n         SPACE\nD14CF3   DS    0H\n         LA    R3,116(R3)                POINT TO CF3\n         CLI   CFWK3,X'FF'              CONTROL FIELD 3 USED ?\n         BE    D16CF4                   NO, CHECK FOR CF4\n         SPACE\n         MVC   4(L'CFWK3,R3),CFWK3      STORE CF3\n         SPACE\nD16CF4   DS    0H\n         LA    R3,116(R3)                POINT TO CF4\n         CLI   CFWK4,X'FF'              CONTROL FIELD 4 USED ?\n         BE    D18CF5                   NO, CHECK FOR CF5\n         SPACE\n         MVC   4(L'CFWK4,R3),CFWK4      STORE CF4\n         SPACE\nD18CF5   DS    0H\n         LA    R3,116(R3)                POINT TO CF5\n         CLI   CFWK5,X'FF'              CONTROL FIELD 5 USED ?\n         BE    D19ADD                   NO, ADD 1 TO COUNTER\n         SPACE\n         MVC   4(L'CFWK5,R3),CFWK5      STORE CF5\n         SPACE\nD19ADD   DS    0H\n         L     R10,0(0,R9)              ADD 1 TO OUT  COUNTER\n         LA    R10,1(R10)               *\n         ST    R10,0(0,R9)              *\n         B     D80END                   RETURN TO CALLER\n         SPACE\nD20OUT2  DS    0H\n         LA    R3,2900(0,R3)         POINT TO OUT2 SELECT\n         CLC   0(4,R2),OUT2             FILE = OUT2 ?\n         BNE   D30OUT3                  NO, CHECK FOR OUT3\n         SPACE\n         LA    R9,OUT2CTR               LOAD ADDRESS OUT2 COUNTER\n         B     D10LOOP                  PROCESS CF'S\n         SPACE\nD30OUT3  DS    0H\n         LA    R3,2900(0,R3)         POINT TO OUT3 SELECT\n         CLC   0(4,R2),OUT3             FILE = OUT3 ?\n         BNE   D40OUT4                  NO, CHECK FOR OUT4\n         SPACE\n         LA    R9,OUT3CTR               LOAD ADDRESS OUT3 COUNTER\n         B     D10LOOP                  PROCESS\n         SPACE\nD40OUT4  DS    0H\n         LA    R3,2900(0,R3)         POINT TO OUT4 SELECT\n         CLC   0(4,R2),OUT4             FILE = OUT4 ?\n         BNE   D50OUT5                  NO, CHECK FOR OUT5\n         SPACE\n         LA    R9,OUT4CTR               LOAD ADDRESS OUT4 COUNTER\n         B     D10LOOP                  PROCESS OUT4\n         SPACE\nD50OUT5  DS    0H\n         LA    R3,2900(0,R3)         POINT TO OUT5 SELECT\n         CLC   0(4,R2),OUT5             FILE = OUT5 ?\n         BNE   D60OUT6                  NO, CHECK FOR OUT6\n         SPACE\n         LA    R9,OUT5CTR               LOAD ADDRESS OUT5 COUNTER\n         B     D10LOOP                  PROCESS OUT5\n         SPACE\nD60OUT6  DS    0H\n         LA    R3,2900(0,R3)         POINT TO OUT6 SELECT\n         CLC   0(4,R2),OUT6             FILE = OUT6 ?\n         BNE   D70OUT7                  NO, CHECK FOR OUT7\n         SPACE\n         LA    R9,OUT6CTR               LOAD ADDRESS OUT6 COUNTER\n         B     D10LOOP                  PROCESS OUT6\n         SPACE\nD70OUT7  DS    0H\n         LA    R3,2900(0,R3)         POINT TO OUT7 SELECT\n         CLC   0(4,R2),OUT7       FILE = OUT7 ?\n         BNE   D90ERROR           NO, PRINT ERROR MSG\n         SPACE 1\n         LA    R9,OUT7CTR               LOAD ADDR OUT7 COUNTER\n         B     D10LOOP                  PROCESS OUT7\n         SPACE\nD80END   DS    0H\n         BR    R11                      RETURN TO CALLER\n         SPACE\nD90ERROR DS    0H\n         MVC   P(L'CTLMS8),CTLMS8       MOVE MESSAGE TO PRINT\nD95      DS    0H\n         BAL   R11,Y10WSP1              PRINT, SPACE 1\n         ABEND 16                       CANCEL JOB\n         SPACE\nD85ERROR DS    0H\n         MVC   P(L'CTLMS14),CTLMS14     PRINT ERROR MESSAGE\n         B     D95                      *\n         EJECT\n***********************************************************************\n*        E D I T   C O N T R O L   F I E L D S                        *\n***********************************************************************\n         SPACE 2\nF10EDIT  DS    0H\n         MVC   CFWK1(112),WKFILL         INITIALIZE WORK AREAS\n         MVC   CFWK2(112),WKFILL         INITIALIZE WORK AREAS\n         MVC   CFWK3(112),WKFILL         INITIALIZE WORK AREAS\n         MVC   CFWK4(112),WKFILL         INITIALIZE WORK AREAS\n         MVC   CFWK5(112),WKFILL         INITIALIZE WORK AREAS\n         CLC   0(4,R2),CF1              CONTROL FIELD 1 ?\n         BNE   F20CF2                   NO, CHECK FOR CF2\n         LA    R8,CFWK1                 LOAD ADDRESS WORK 1\n         L     R7,LENGTH1               LOAD LENGTH\n         LA    R14,TYPE1          R14 -> TO TYPE FIELD\n         BAL   R6,F10LOOP               CHECK CF1\n         B     F20CF2\nF10LOOP  LA    R2,4(R2)                 POINT TO COMPARE OPERAND\n         CLC   0(3,R2),ALL              CF = ALL ?\n         BNE   F12                      NO, EDIT CF1\n         LA    R2,4(R2)                 POINT TO NEXT CF\n         MVI   0(R8),C'0'               ZERO WORK AREA\n         MVC   1(111,R8),0(R8)          *\n         BR    R6                       RETURN\nF12      DS    0H\n         CLI   0(R2),C'('               LEFT BRACKET ?\n         BNE   F60ERROR                 NO, PRINT MESSAGE\n         SPACE\n         LA    R2,1(R2)                 POINT TO COMPARE OPERAND\n         CLI   0(R2),C'='               EQUAL COMPARE ?\n         BNE   F14                      NO, CHECK FOR <\n         MVI   0(R8),X'80'              SET COMPARE CODE\n         B     F18\nF14      DS    0H\n         CLI   0(R2),C'<'               LESS THAN COMPARE ?\n         BNE   F16                      NO, CHECK FOR >\n         MVI   0(R8),X'40'              SET COMPARE CODE\n         B     F18\nF16      DS    0H\n         CLI   0(R2),C'>'               GREATER THAN COMPARE ?\n         BNE   F17                      NO, CHECK FOR \\\n         MVI   0(R8),X'20'              SET COMPARE CODE\n         B     F18\n         SPACE\nF17      DS    0H\n         CLI   0(R2),C'#'               NOT EQUAL COMPARE ?\n         BNE   F70ERROR                 NO, PRINT ERROR MESSAGE\n         MVI   0(R8),X'70'              SET COMPARE NOT EQUAL CODE\n         SPACE\nF18      LA    R2,1(R2)                 POINT TO COMPARE VALUE\n         LA    R8,1(R8)                 POINT TO VALUE WORK AREA\n         CLI   0(R14),C'A'        IS IT CHARACTER DATA?\n         BNE   F50HEX             NO, CHECK FOR HEX OR PACKED\n         EX    R7,F20                   MVC VALUE TO WORK AREA\nF19      DS    0H\n         AR    R2,R7                    POINT TO CLOSING BRACKET\n         LA    R2,1(R2)                 *\n         CLI   0(R2),C')'               CLOSING BRACKET ?\n         BNE   F60ERROR                 NO, PRINT MESSAGE\n         SPACE\nF19NEXT  DS    0H\n         LA    R2,2(R2)                 POINT TO NEXT CF\n         BR    R6                       RETURN TO CALLER\n         SPACE\nF20      MVC   0(0,R8),0(R2)            MOVE VALUE TO WORKAREA\n         SPACE\nF20CF2   DS    0H\n         CLC   0(4,R2),CF2              CF2 ?\n         BNE   F30CF3                   NO, CHECK FOR CF3\n         SPACE\n         LA    R8,CFWK2                 LOAD ADDRESS WORK 2\n         L     R7,LENGTH2               LOAD LENGTH 2\n         LA    R14,TYPE2          R14 -> TO TYPE FIELD\n         BAL   R6,F10LOOP               CHECK CF2\n         SPACE\nF30CF3   DS    0H\n         CLC   0(4,R2),CF3              CF3 ?\n         BNE   F40CF4                   NO, CHECK FOR CF4\n         LA    R8,CFWK3                 LOAD ADDRESS WORK 3\n         L     R7,LENGTH3               LOAD LENGTH 3\n         LA    R14,TYPE3          R14 -> TO TYPE FIELD\n         BAL   R6,F10LOOP               CHECK CF3\nF40CF4   DS    0H\n         CLC   0(4,R2),CF4              CF4 ?\n         BNE   F50CF5                   NO, CHECK FOR CF5\n         LA    R8,CFWK4                 LOAD ADDRESS WORK 4\n         L     R7,LENGTH4               LOAD LENGTH 4\n         LA    R14,TYPE4          R14 -> TO TYPE FIELD\n         BAL   R6,F10LOOP               CHECK CF4\n         SPACE\nF50CF5   DS    0H\n         CLC   0(4,R2),CF5              CF5 ?\n         BNE   F80ERROR                 NO, CHECK FOR END OF SELECT\n         LA    R8,CFWK5                 LOAD ADDRESS WORK 5\n         L     R7,LENGTH5               LOAD LENGTH 5\n         LA    R14,TYPE5          R14 -> TO TYPE FIELD\n         BAL   R6,F10LOOP               CHECK CF5\n         BR    R10                      RETURN TO CALLER\n         SPACE 2\nF50HEX   DS    0H\n         CLI   0(R14),C'P'        IS DATA PACKED ?\n         BE    F51PACK            YES, SET UP PACKED DATA\n         SPACE 1\n         LA    R7,1(0,R7)         ADD 1 TO R7\n         SLL   R7,1               R7*2 = REAL INPUT LTH\n         BCTR  R7,0               R7 = HEX LTH OF INPUT\n         SPACE 1\n         EX    R7,TRHEX           TRANSLATE INPUT TO 00-0F\n         LA    R15,1(0,R7)        R15 = REAL LTH OF INPUT\n         C     R15,MAXPACK        AT MAX LTH OF 16 ?\n         BE    F50MAX             YES, TREAT DIFFERENTLY\n         EX    R15,F50PACK        NO, PACK ALL OF FIELD\n         SPACE 1\nF50HEX2  DS    0H\n         SRL   R15,1              LTH/2 = LTH OF HEX FIELD\n         LA    R14,CTLHEAD+14     R14 -> TO LAST BYTE OF HEX DATA\n         SR    R14,R15            R14 -> TO FIRST BYTE OF HEX DATA\n         BCTR  R15,0              R15 = HEX LTH\n         EX    R15,F50MOVE        MOVE HEX VALUE TO WORK AREA\n         B     F19                DO REST OF EDIT\n         SPACE 1\nF50MAX   DS    0H\n         PACK  CTLHEAD(5),0(9,R2) PACK 1ST 8 DIGITS\n         PACK  CTLHEAD+4(5),8(9,R2) PACK 2ND 8 DIGITS\n         MVC   0(8,R8),CTLHEAD    MOVE HEX CHARS TO WORK AREA\n         B     F19                DO REST OF EDIT\n         SPACE 1\nF51PACK  DS    0H\n         SLL   R7,1               R7*2 = HEX LTH OF IN INPUT\n         EX    R7,F50PACK         PACK INPUT DATA\n         LR    R15,R7             R15 = LTH\n         SRL   R15,1              LTH /2 = PACKED LTH\n         LA    R14,CTLHEAD+14     R14 -> TO LAST PACKED BYTE\n         SR    R14,R15            R14 -> TO FIRST PACKED BYTE\n         EX    R15,F50MOVE        MOVE PACKED DATA TO WORK AREA\n         B     F19                DO REST OF EDIT\n         SPACE 2\nTRHEX    TR    0(0,R2),TRTAB      TRANSLATE TO 00-0F\nF50PACK  PACK  CTLHEAD(15),0(0,R2)  PACK INPUT\nF50MOVE  MVC   0(0,R8),0(R14)     MOVE TO TABLE AREA\n         SPACE 2\nF60ERROR DS    0H\n         BAL   R11,G10SET2        POINT R2 TO WHERE ERROR MSG GOES\n         MVC   0(L'CTLMS10,R2),CTLMS10  PUT ERROR MSG UNDER BAD CHAR\n         B     F90WRITE                 PRINT, CANCEL JOB\n         SPACE\nF70ERROR DS    0H\n         BAL   R11,G10SET2        POINT R2 TO WHERE ERROR MSG GOES\n         MVC   0(L'CTLMS11,R2),CTLMS11  PUT ERROR MSG UNDER BAD CHAR\n         B     F90WRITE                 PRINT, CANCEL JOB\n         SPACE\nF80ERROR DS    0H\n         CLI   0(R2),C' '               ANY MORE FIELDS ?\n         BCR   8,R10                    NO, RETURN TO CALLER\n         SPACE\n         BAL   R11,G10SET2        POINT R2 TO WHERE ERROR MSG GOES\n         MVC   0(L'CTLMS12,R2),CTLMS12  PUT ERROR MSG UNDER BAD CHAR\nF90WRITE DS    0H\n         BAL   R11,Y10WSP1              PRINT, SPACE 1\n         ABEND 16                       CANCEL JOB\n         EJECT\n***********************************************************************\n*        POINT R2 TO THE PRINT POSITION AT WHICH THE ERROR OCCURRED   *\n***********************************************************************\n         SPACE 2\nG10SET2  DS    0H\n         S     R2,EDITSAVE        R2 = DISP TO BAD CHARACTER\n         LA    R2,P(R2)           R2 -> TO WHERE ERROR MSG GOES\n         BR    R11                RETURN TO CALLER\n         EJECT\n***********************************************************************\n*        P R I N T   C O N T R O L   R O U T I N E                    *\n***********************************************************************\n         SPACE 2\nY10SKIP1 DS    0H\n         MVI   CTLCHR,X'8B'             SKIP TO CHANNEL 1\n         B     Y40\n         SPACE\nY10WSP1  DS    0H\n         MVI   CTLCHR,X'09'             PRINT, SPACE 1\n         B     Y40\n         SPACE\nY10WSP2  DS    0H\n         MVI   CTLCHR,X'11'             PRINT, SPACE 2\n         B     Y40\n         SPACE\nY10WSP3  DS    0H\n         MVI   CTLCHR,X'19'             PRINT, SPACE 3\n         SPACE\nY40      DS    0H\n         PUT   OUTFILE,PRINT            PRINT\n         MVI   P,C' '                   CLEAR PRINT BUFFER\n         MVC   P+1(L'P-1),P             *\n         SPACE\n         BR    R11                      RETURN TO CALLER\n         EJECT\n***********************************************************************\n*        F I L E   D E C L A R E S                                    *\n***********************************************************************\n         SPACE 2\n         PRINT NOGEN\nINFILE   DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GL,EODAD=A90END\nOUTFILE  DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,RECFM=FBM,LRECL=133,  +\n               BLKSIZE=9310\n         PRINT GEN\n         SPACE 2\n***********************************************************************\n*              D E C L A R A T I V E S                                *\n***********************************************************************\n         SPACE\nEDITSAVE DC    18F'0'\nELEVEN   DC    F'11'\nMAXLEN   DC    F'111'\nDWORD    DC    D'0'\nMAXPACK  DC    F'16'\n         ENTRY ADDLTH\nADDLTH   DC    F'0'               LTH OF DATA TO ADD\nCTLHEAD  DC    C'*****  CONTROL STATEMENT LISTING  *****'\nPRINT    DS    0CL133\nCTLCHR   DC    X'09'\nP        DC    CL132' '\nINPUT    DC    C'INPUT='\nOUTPUT   DC    C'OUTPUT='\nSELECT   DC    C'SELECT='\nTAPEIN   DC    C'TAPEIN'\nCONTROL  DC    C'CONTROL=('\nHD1      DC    C'HEAD1='\nHD2      DC    C'HEAD2='\nHD3      DC    C'HEAD3='\nSTARTRDW DC    C'START=RDW'       START AT POS 1, OFFSET IN DECIMAL\nSTARTHEX DC    C'START=HEX'       START AT POS 0, OFFSET IN HEX\nCFCTR    DC    P'1'\nONE      DC    P'1'\nFIVE     DC    P'5'\nALL      DC    C'ALL'\nCTLMS1   DC    C'       INVALID CONTROL CARD IGNORED '\nCTLMS2   DC    C'       DDNAME MUST BE TAPEIN'\nCTLMS3   DC    C'       INVALID CONTROL'\nCTLMS4   DC    C'TYPE NOT P, H OR A'\nCTLMS5   DC    C'       ONLY 5 CONTROL FIELDS ALLOWED'\nCTLMS6   DC    C'START LOCATION NOT NUMERIC OR HEXADECIMAL'\nCTLMS7   DC    C'LENGTH NOT NUMERIC'\nCTLMS8   DC    C'       INVALID FILE NAME'\nCTLMS9   DC    C' LENGTH CANNOT EXCEED 111'\nCTLMS10  DC    C'CF VALUE NOT IN ( ) OR SIZE NOT = TO CONTROL SIZE'\nCTLMS11  DC    C'COMPARE OPERAND MUST BE = # > OR <'\nCTLMS12  DC    C'CF FIELD MUST BE CF1 - CF5'\nCTLMS13  DC    C'*****  END OF CONTROL CARD LISTING  *****'\nCTLMS14  DC    C'       ONLY 5 SELECTS PER FILE ALLOWED'\nOUT1     DC    C'OUT1'\nOUT2     DC    C'OUT2'\nOUT3     DC    C'OUT3'\nOUT4     DC    C'OUT4'\nOUT5     DC    C'OUT5'\nOUT6     DC    C'OUT6'\nOUT7     DC    C'OUT7'\nCFWK1    DS    CL112\nCFWK2    DS    CL112\nCFWK3    DS    CL112\nCFWK4    DS    CL112\nCFWK5    DS    CL112\nENTLTH   DC    F'580'\nWKFILL   DC    112X'FF'\nCF1      DC    C'CF1='\nCF2      DC    C'CF2='\nCF3      DC    C'CF3='\nCF4      DC    C'CF4='\nCF5      DC    C'CF5='\nZEROS    DC    12C'0'\nTRTAB    EQU   *-193              SET START OF SHORT TRANS TABLE\n         DC    X'0A0B0C0D0E0F'\n         DC    41X'00'\n         DC    X'00010203040506070809'\nR0       EQU   0                        REGISTER EQUATES\nR1       EQU   1                        *\nR2       EQU   2                        *\nR3       EQU   3                        *\nR4       EQU   4                        *\nR5       EQU   5                        *\nR6       EQU   6                        *\nR7       EQU   7                        *\nR8       EQU   8                        *\nR9       EQU   9                        *\nR10      EQU   10                       *\nR11      EQU   11                       *\nR12      EQU   12                       *\nR13      EQU   13                       *\nR14      EQU   14                       *\nR15      EQU   15                       *\n         SPACE\n*\n*              T A B L E S\n*\nTABLED   DSECT\nCONTROLS DS    0F\n         COPY  SDP10\nSELECTS  DS    0F\n         COPY  SDP20\nCTRLEDIT CSECT\n         LTORG\n         END   CTRLEDIT\n/*\n//*\n//STEP5 EXEC HLASMCL,PARMC='XREF(FULL)',\n//             PARM.LKED='LIST,LET,MAP'\n//*            PARM.LKED='OVLY,LIST,LET,MAP'\n//ASM.SYSLIB DD\n//          DD\n//    DD DSN=&&T,DISP=(SHR,PASS)\n//ASM.SYSIN DD *\n         EJECT\n***********************************************************************\n*        W R I T E   R E P O R T S   R E Q U I R E D                  *\n***********************************************************************\n         SPACE 2\nVPRINT   CSECT                          NAME CONTROL SECTION\n         USING *,R15\n         B     A10SAVE                  BRANCH AROUND IDENTIFIER\n         DC    AL1(14)\n         DC    C'VPRINT SECTION'        IDENTIFIER\nA10SAVE  DS    0H\n         DROP  R15\n         SAVE  (14,12)                  SAVE REGISTERS\n         BALR  R12,0                    LOAD BASE REGISTER\n         USING *,R12,R10,R4             ESTABLISH ADDRESSABILITY\n         LA    R11,1                    LOAD BASE REGISTER 2\n         LA    R10,4095(R11,R12)        *\n         LA    R4,4095(R11,R10)         LOAD BASE REGISTER 3\n         ST    R13,VSAVE+4              CHAIN SAVE AREAS\n         LR    R11,R13                  *\n         LA    R13,VSAVE                *\n         ST    R13,8(R11)               *\n         L     R6,0(0,R1)               LOAD DSECT BASE REG\n         USING CONTROLS,R6              ESTABLISH DSECT ADDRESSABILITY\n         SPACE 2\n         OPEN  (INFILE)                 OPEN INPUT FILE\n         SPACE 1\n         LH    R0,INFILE+82       R0 = LRECL\n         GETMAIN R,LV=(0)         GET RECORD WORK AREA\n         LTR   R15,R15            IS RC = 0 ?\n         BZ    A15OK              YES, CONTINUE\n         ABEND 4                  NO, ABEND WITH RC = 4\n         SPACE 1\nA15OK    DS    0H\n         ST    R1,RECADDR         SAVE A(RECORD AREA)\n         ST    R1,OFFADDR         SAVE A(RECORD AREA)\n         SPACE\n         SR    R14,R14            R14 = 0\n         LH    R15,INFILE+62      R15 = BLKSIZE\n         LH    R1,INFILE+82       R1 = LRECL\n         DR    R14,R1             CALC RECORDS/BLK IN R15\n         L     R2,=V(ADDLTH)      R2 -> AT NEW LTH\n         A     R1,0(0,R2)         ADD NEW LTH TO OLD LRECL\n         MR    R14,R1             NEW BLKSIZE = NEW LRECL * RECS/BLK\n         STH   R15,OUT4DCB+62     PUT NEW BLKSIZE IN OUTPUT DCB\n         STH   R1,OUT4DCB+82      PUT NEW LRECL IN OUTPUT DCB\n         STH   R1,MAXLTHO         SAVE NEW LRECL FOR CLEAR INST\n         LR    R0,R1              PUT NEW LRECL IN R0\n         SPACE\n*        LA    R0,32              R0 = MAX BYTES TO ADD\n*        AH    R0,INFILE+82       R0 = LRECL + MAX NEW BYTES\n         GETMAIN R,LV=(0)         GET RECORD WORK AREA\n         LTR   R15,R15            IS RC = 0 ?\n         BZ    A15OK2             YES, CONTINUE\n         ABEND 5                  NO, ABEND WITH RC = 5\n         SPACE 1\nA15OK2   DS    0H\n         ST    R1,RECADDRO        SAVE A(RECORD AREA)\n         ST    R1,OFFADDRO        SAVE A(RECORD AREA)\n         SPACE\nA20OPEN1 DS    0H\n         TM    OPENFLGS,B'10000000'     OPEN OUT1 ?\n         BNO   A20OPEN2                 NO, CHECK FOR OPEN OUT2\n         SPACE\n         OPEN  (OUT1DCB,(OUTPUT))       OPEN OUT1\n         NI    A50WRT1+1,X'0F'          SET SWITCH TO WRITE OUT1\n         NI    A30DATE+1,X'0F'          SET SWITCH TO GET DATE\n         NI    A70STAT1+1,X'0F'         SET STATS 1 SWITCH\n         SPACE\nA20OPEN2 DS    0H\n         TM    OPENFLGS,B'01000000'     OPEN OUT2 ?\n         BNO   A20OPEN3                 NO, OPEN OUT3?\n         SPACE\n         OPEN  (OUT2DCB,(OUTPUT))       OPEN OUT2\n         NI    A50WRT2+1,X'0F'          SET SWITCH TO WRITE OUT2\n         NI    A30DATE+1,X'0F'          SET SWITCH TO GET DATE\n         NI    A70STAT2+1,X'0F'         SET STATS 2 SWITCH\nA20OPEN3 DS    0H\n         TM    OPENFLGS,B'00100000'     OPEN OUT3 ?\n         BNO   A20OPEN4                 NO, OPEN OUT4?\n         SPACE\n         OPEN  (OUT3DCB,(OUTPUT))       OPEN OUT3\n         NI    A50WRT3+1,X'0F'          SET SWITCH TO WRITE OUT3\n         NI    A30DATE+1,X'0F'          SET SWITCH TO GET DATE\n         NI    A70STAT3+1,X'0F'         SET STATS 3 SWITCH\nA20OPEN4 DS    0H\n         TM    OPENFLGS,B'00010000'     OPEN OUT4 ?\n         BNO   A20OPEN5                 NO, OPEN OUT5 ?\n         SPACE\n         OPEN  (OUT4DCB,(OUTPUT))       OPEN OUT4\n         NI    A50WRT4+1,X'0F'          SET SWITCH TO WRITE OUT4\n         NI    A70STAT4+1,X'0F'         SET STATS 4 SWITCH ON\n         TM    OUT4DCB+36,X'58'   RECFM=V, VB, OR VBS ?\n         BNZ   *+10               YES, DON'T CHANGE IT\n         MVC   OUT4DCB+36(2),INFILE+36 NO, SET IT THE SAME AS THE INPUT\nA20OPEN5 DS    0H\n         TM    OPENFLGS,B'00001000'     OPEN OUT5 ?\n         BNO   A20OPEN6                 NO, OPEN OUT6 ?\n         SPACE\n         OPEN  (OUT5DCB,(OUTPUT))       OPEN OUT5\n         NI    A50WRT5+1,X'0F'          SET SWITCH TO WRITE OUT5\n         NI    A70STAT5+1,X'0F'         SET STATS 5 SWITCH ON\n         TM    OUT5DCB+36,X'58'   RECFM=V, VB, OR VBS ?\n         BNZ   *+10               YES, DON'T CHANGE IT\n         MVC   OUT5DCB+36(2),INFILE+36 NO, SET IT THE SAME AS THE INPUT\nA20OPEN6 DS    0H\n         TM    OPENFLGS,B'00000100'     OPEN OUT6 ?\n         BNO   A20OPEN7                 NO, OPEN OUT7 ?\n         SPACE\n         OPEN  (OUT6DCB,(OUTPUT))       OPEN OUT6\n         NI    A50WRT6+1,X'0F'          SET SWITCH TO WRITE OUT6\n         NI    A70STAT6+1,X'0F'         SET STATS 6 SWITCH ON\n         TM    OUT6DCB+36,X'58'   RECFM=V, VB, OR VBS ?\n         BNZ   *+10               YES, DON'T CHANGE IT\n         MVC   OUT6DCB+36(2),INFILE+36 NO, SET IT THE SAME AS THE INPUT\n         SPACE\nA20OPEN7 DS    0H\n         TM    OPENFLGS,X'02'           OPEN OUT7 ?\n         BNO   A25RDW             NO, START AT RDW ??\n         SPACE\n         OPEN  (OUT7DCB,(OUTPUT))       OPEN OUT7\n         NI    A50WRT7+1,X'0F'          SET SWITCH TO WRITE OUT7\n         NI    A70STAT7+1,X'0F'         SET SWITCH TO WRITE STATS7\n         SPACE\nA25RDW   CLI   STRTPOS,C'R'       START AT RDW ?\n         BNE   A26RDW             NO, START AT RDW IN HEX?\n         MVI   H4+1,X'00'         YES, START AT RDW (OFFSET 0)\n         SPACE 1\nA26RDW   CLI   STRTPOS,C'H'       START AT RDW WITH HEX OFFSET?\n         BNE   A30DATE            NO, START AT DATA (OFFSET 4)\n         MVI   H4+1,X'00'         YES, START AT RDW (OFFSET 0)\n         SPACE 1\nA30DATE  B     A40READ                  DATE SWITCH\n         BAL   R11,B10DATE              PERFORM DATE ROUTINE\n         SPACE\nA40READ  DS    0H\n         L     R0,RECADDR         R0 -> TO RECORD AREA\n         GET   INFILE,(0)               READ INPUT RECORD\n         L     R1,RECADDR         R1 -> TO INPUT RECORD\n         L     R2,RECADDR         R2 -> TO INPUT RECORD\n         AH    R2,H4                 ADD OFFSET (0 IF RDW, 4 IF DATA)\n         ST    R2,OFFADDR         SAVE IT\n         L     R2,RECADDRO        R2 -> TO OUTPUT RECORD AREA\n         SPACE 1\n         STM   R2,R5,SAVE2TO5     SAVE SOME REGS\n*                                 CAUSE MVCL CLOBBERS \"TO\" REG...\n*        FIRST FILL AREA WITH SPACES\n         L     R9,=X'40000000'    MAKE BLANK THE PAD, LENGTH =0\n         LA    R8,0               NOT THAT IT REALLY MATTERS\n         LH    R3,MAXLTHO         R3 = TOTAL LTH TO CLEAR\n*        LH    R3,OUT4DCB+82      R3 = TOTAL LTH TO MOVE TO\n         SPACE 1\n         MVCL  R2,R8              CLEAR THE BUFFER\n*\n         LM    R2,R5,SAVE2TO5     LOAD SOME REGS\n*\n         AH    R2,H4                 ADD OFFSET (0 IF RDW, 4 IF DATA)\n         ST    R2,OFFADDRO        SAVE IT\n         LH    R2,0(0,R1)               GET LTH OF RECORD+CW\n         ST    R2,VRLTHO                SAVE LTH OF RECORD\n         SH    R2,H4                    DROP LTH OF CW\n         ST    R2,VRLTH                 SAVE LTH OF RECORD\n         ST    R2,VRLTHL                SAVE LTH OF RECORD\n         LR    R2,R1                    POINT REG 2 TO INPUT RECORD\n         AH    R2,H4                 ADD OFFSET (0 IF RDW, 4 IF DATA)\n         AP    INCTR,ONE                ADD 1 TO RECORD COUNTER\n         LA    R3,0               RESET LAST OFFSET\n         ST    R3,LASTOFF               FIELD\n         SPACE\nA50WRT1  DS    0H\n         B     A50WRT2                  WRITE 1 SWITCH\n         LA    R3,A50WRT2               LOAD RETURN ADDRESS\n         LA    R5,SELECTS+0             LOAD ADDRESS OUT1 TABLE\n         L     R15,OUT1CTR              LOAD OUT1 COUNTER\n         BAL   R11,D10COMP              CHECK CONTROL FIELDS\n         SPACE\n         LA    R1,OUT1                  LOAD DCB ADDRESS\n         MVC   PHD,HEAD1                MOVE HEAD1 TO PRINT\n         BAL   R11,E10PRT               PRINT,REPORT 1\n         AP    OUTCTR1,ONE              ADD 1 TO OUT1 COUNTER\n         BAL   R3,D70BR                 RETURN TO D10COMP\n         SPACE\nA50WRT2  DS    0H\n         B     A50WRT3                  WRITE 2 SWITCH\n         LA    R3,A50WRT3               LOAD RETURN ADDRESS\n         L     R15,OUT2CTR              LOAD OUT2 COUNTER\n         LA    R5,SELECTS            LOAD ADDRESS OUT2 TABLE\n         A     R5,OFF2               *\n         BAL   R11,D10COMP              CHECK CONTROL FIELDS\n         SPACE\n         LA    R1,OUT2                  LOAD OUT2 DCB ADDRESS\n         MVC   PHD,HEAD2                MOVE HEAD2 TO PRINT\n         BAL   R11,E10PRT               PRINT REPORT 2\n         AP    OUTCTR2,ONE              ADD 1 TO OUT2 COUNTER\n         BAL   R3,D70BR                 RETURN TO D10COMP\n         SPACE\nA50WRT3  DS    0H\n         B     A50WRT4                  WRITE 3 SWITCH\n         LA    R3,A50WRT4               LOAD RETURN ADDRESS\n         L     R15,OUT3CTR              LOAD OUT3 COUNTER\n         LA    R5,SELECTS            LOAD ADDRESS OUT3 TABLE\n         A     R5,OFF3               *\n         BAL   R11,D10COMP              CHECK CONTROL FIELDS\n         SPACE\n         LA    R1,OUT3                  LOAD OUT3 DCB ADDRESS\n         MVC   PHD,HEAD3                MOVE HEAD3 TO PRINT\n         BAL   R11,E10PRT               PRINT REPORT 3\n         AP    OUTCTR3,ONE              ADD 1 TO OUT3 COUNTER\n         BAL   R3,D70BR                 RETURN TO D10COMP\n         SPACE\nA50WRT4  DS    0H\n         B     A50WRT5                  WRITE 4 SWITCH\n         LA    R3,A50WRT5               LOAD RETURN ADDRESS\n         L     R15,OUT4CTR              LOAD OUT4 COUNTER\n         LA    R5,SELECTS            LOAD ADDRESS OUT4 TABLE\n         A     R5,OFF4               *\n         BAL   R11,D10COMP              CHECK CONTROL FIELDS\n         SPACE\n         LA    R1,OUT4DCB               LOAD OUT4 DCB ADDRESS\n         BAL   R11,F10WRITE             WRITE OUT4\n         AP    OUTCTR4,ONE              ADD 1 TO OUT4 COUNTER\n         BAL   R3,D70BR                 RETURN TO D10COMP\n         SPACE\nA50WRT5  DS    0H\n         B     A50WRT6                  WRITE 5 SWITCH\n         LA    R3,A50WRT6               LOAD RETURN ADDRESS\n         L     R15,OUT5CTR              LOAD OUT5 COUNTER\n         LA    R5,SELECTS           LOAD ADDRESS OUT5 TABLE\n         A     R5,OFF5               *\n         BAL   R11,D10COMP              CHECK CONTROL FIELDS\n         SPACE\n         LA    R1,OUT5DCB               LOAD ADDRESS OUT5 DCB\n         BAL   R11,F10WRITE             WRITE OUT5\n         AP    OUTCTR5,ONE              ADD 1 TO OUT5 COUNTER\n         BAL   R3,D70BR                 RETURN TO D10COMP\n         SPACE\nA50WRT6  DS    0H\n         B     A50WRT7                  WRITE 6 SWITCH\n         LA    R3,A60LOOP               LOAD RETURN ADDRESS\n         L     R15,OUT6CTR              LOAD OUT6 COUNTER\n         LA    R5,SELECTS           LOAD OUT6 TABLE ADDRESS\n         A     R5,OFF6               *\n         BAL   R11,D10COMP              CHECK CONTROL FIELDS\n         SPACE\n         LA    R1,OUT6DCB               LOAD OUT6 DCB ADDRESS\n         BAL   R11,F10WRITE             WRITE OUT6\n         AP    OUTCTR6,ONE              ADD 1 TO OUT6 COUNTER\n         BAL   R3,D70BR                 RETURN TO D10COMP\n         SPACE\nA50WRT7  DS    0H\n         B     A60LOOP                  WRITE 7 SWITCH\n         LA    R3,A60LOOP               LOAD RETURN ADDRESS\n         L     R15,OUT7CTR              LOAD OUT7 COUNTER\n         LA    R5,SELECTS           LOAD OUT7 TABLE ADDRESS\n         A     R5,OFF7               *\n         BAL   R11,D10COMP              CHECK CONTROL FIELDS\n         SPACE\n         LA    R1,OUT7DCB               LOAD OUT7 DCB ADDRESS         1\n         BAL   R11,F50WRITE             WRITE OUT7                    2\n         AP    OUTCTR7,ONE              ADD 1 TO OUT7 COUNTER         3\n         BAL   R3,D70BR                 RETURN TO D10COMP             4\n         SPACE\nA60LOOP  DS    0H\n         B     A40READ\n         SPACE\nA70STATS DS    0H\n         OPEN  (SYSOUT,(OUTPUT))        OPEN SYSPRINT FILE\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         MVI   P,C' '                    CLEAR PRINT LINE\n         MVC   P+1(L'P-1),P             *\n         MVC   SEDWDUT1,PLEDWD1         EDIT INPUT RECORDS COUNTER\n         ED    SEDWDUT1,INCTR           *\n         MVC   P(L'SHDUT1),SHDUT1       MOVE STATS HEAD TO PRINT\n         BAL   R11,Y10WSP2              PRINT, SPACE 2\n         SPACE\nA70STAT1 DS    0H\n         B     A70STAT2                 STATS 1 SWITCH\n         MVC   SEDWD1,PLEDWD1           EDIT OUT1 COUNTER\n         ED    SEDWD1,OUTCTR1           *\n         MVC   P(L'SHD1),SHD1           MOVE STATS TO PRINT\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         BAL   R11,Y10WSP2              PRINT STATS 1\n         SPACE\nA70STAT2 DS    0H\n         B     A70STAT3                 STATS 2 SWITCH\n         MVC   SEDWD2,PLEDWD1           EDIT OUT2 COUNTER\n         ED    SEDWD2,OUTCTR2           *\n         MVC   P(L'SHD2),SHD2           MOVE STATS2 HEADING TO PRINT\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         BAL   R11,Y10WSP2              PRINT STATS 2\n         SPACE\nA70STAT3 DS    0H\n         B     A70STAT4                 STATS 3 SWITCH\n         MVC   SEDWD3,PLEDWD1           EDIT OUT3 COUNTER\n         ED    SEDWD3,OUTCTR3           *\n         MVC   P(L'SHD3),SHD3           MOVE STATS 3 HEAD TO PRINT\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         BAL   R11,Y10WSP2              PRINT STATS 3\n         SPACE\nA70STAT4 DS    0H\n         B     A70STAT5                 STATS 4 SWITCH\n         MVC   SEDWD4,PLEDWD1           EDIT OUT4 COUNTER\n         ED    SEDWD4,OUTCTR4           *\n         MVC   P(L'SHD4),SHD4           MOVE STATS 4 HEAD TO PRINT\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         BAL   R11,Y10WSP2              PRINT STATS 4\n         SPACE\nA70STAT5 DS    0H\n         B     A70STAT6                 STATS 5 SWITCH\n         MVC   SEDWD5,PLEDWD1           EDIT OUT5 COUNTER\n         ED    SEDWD5,OUTCTR5           *\n         MVC   P(L'SHD5),SHD5           MOVE STATS HEAD 5 TO PRINT\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         BAL   R11,Y10WSP2              PRINT STATS 5\n         SPACE\nA70STAT6 DS    0H\n         B     A70STAT7                 STATS 6 SWITCH\n         MVC   SEDWD6,PLEDWD1           EDIT OUT6 COUNTER\n         ED    SEDWD6,OUTCTR6           *\n         MVC   P(L'SHD6),SHD6           MOVE STATS 6 HEAD TO PRINT\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         BAL   R11,Y10WSP2              PRINT STATS 6\n         SPACE\nA70STAT7 DS    0H\n         B     A90END                   STATS 7 SWITCH\n         MVC   SEDWD7,PLEDWD1           EDIT OUT7 COUNTER\n         ED    SEDWD7,OUTCTR7           *\n         MVC   P(L'SHD7),SHD7           MOVE STATS 7 HEAD TO PRINT\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         BAL   R11,Y10WSP2              PRINT STATS 7\n         SPACE\nA90END   DS    0H\n         L     R13,VSAVE+4              RETURN TO ROOT SECTION\n         RETURN (14,12),RC=0            *\n         SPACE 2\nOFF2     DC    F'2900'               OFFSET TO CF2\nOFF3     DC    F'5800'               OFFSET TO CF3\nOFF4     DC    F'8700'               OFFSET TO CF4\nOFF5     DC    F'11600'              OFFSET TO CF5\nOFF6     DC    F'14500'              OFFSET TO CF6\nOFF7     DC    F'17400'              OFFSET TO CF7\n         EJECT\n***********************************************************************\n*        R O U T I N E   T O   S E T   U P   D A T E                  *\n***********************************************************************\n         SPACE 2\nB10DATE  DS    0H\n         TIME  DEC,SAVETIME,            GET THE SYS TIME            Y2 +\n               LINKAGE=SYSTEM,DATETYPE=YYYYMMDD     IN THIS CASE    Y2\n         L     R0,SAVETIME              R= TIME                     Y2\n         L     R1,SAVETIME+8            R1 = 0YYYYDDD               Y2\n         SLL   R1,4                     SHIFT LEFT 4 BITS           Y2\n         AH    R1,=H'15'                ADD SIGN...15=F             Y2\n*\n*        TIME  DEC                      GET DATE\n         ST    R1,DWRK1                 STORE DATE\n         MVO   DWRK2,DWRK1(2)           SAVE DAY\n         UNPK  HD1YR,DWRK2+1(2)         UNPACK YEAR\n         MVZ   HD1YR+1(1),HD1YR         CHANGE ZONE TO F\n         SPACE\n         DP    DWRK2,FOUR               DIVIDE YEAR BY 4\n         CP    DWRK2+2(1),ZERO          REMAINDER = 0 ?\n         BNE   B30NOLEP                 NO, GO TO PROCESS NO LEAP YEAR\n         SPACE\n         LA    R7,YTAB3+6               ADD 1 TO JULIAN DAY\n         LA    R8,10                    IN TABLE TO COMPENSATE\nB20LEAP  AP    0(2,R7),ONE              FOR LEAP YEAR TO\n         LA    R7,8(R7)                 MONTHS MARCH\n         BCT   R8,B20LEAP               TO DECEMBER\n         SPACE\nB30NOLEP DS    0H\n         ZAP   DWRK3,DWRK1+2(2)         MOVE JULIAN DAY TO WORK AREA\n         LA    R7,TABEND                LOAD ADDRESS TABLE END\n         LA    R8,8                     LOAD 8\nB40      DS    0H\n         CP    6(2,R7),DWRK3            COMPARE JUL DAY TO TABLE JUL\n         BL    B50                      BRANCH LOW\n         SR    R7,R8                    POINT TO NEXT ENTRY\n         B     B40                      LOOP BACK TO  40\n         SPACE\nB50      DS    0H\n         MVC   HD1MTH,4(R7)             MOVE MONTH TO REPORT DATE\n         SP    DWRK3,6(2,R7)            SUBTRACT JUL DAY IN TABLE\n         ED    HD1DAY,DWRK3             FROM CURRENT JUL DAY AND EDIT\n         SPACE\nB90END   DS    0H\n         BR    R11                      RETURN TO CALLER\n         SPACE 2\n         CNOP  0,4                      ALIGN ON FULLWORD BOUNDARY\nDWRK1    DC    PL4'0'\nDWRK2    DC    PL3'0'\nDWRK3    DC    PL2'0'\nFOUR     DC    P'4'\nZERO     DC    P'0'\n*\n         CNOP  0,4                      ALIGN ON FULLWORD BOUNDARY\nSAVETIME DC    XL16'00'                                             Y2\n*\n         SPACE\nYTAB     DC    C' JAN01'\n         DC    P'000'\n         DC    C' FEB02'\n         DC    P'031'\nYTAB3    DC    C' MAR03'\n         DC    P'059'\n         DC    C' APR04'\n         DC    P'090'\n         DC    C' MAY05'\n         DC    P'120'\n         DC    C'JUNE06'\n         DC    P'151'\n         DC    C'JULY07'\n         DC    P'181'\n         DC    C' AUG08'\n         DC    P'212'\n         DC    C'SEPT09'\n         DC    P'243'\n         DC    C' OCT10'\n         DC    P'273'\n         DC    C' NOV11'\n         DC    P'304'\nTABEND   DC    C' DEC12'\n         DC    P'334'\n         EJECT\n***********************************************************************\n*        C O M P A R E   C O N T R O L   F I E L D S   T O   T A B L E*\n***********************************************************************\n         SPACE 2\nD10COMP  DS    0H\n         ST    R11,STORED               SAVE RETURN ADDRESS\n*        ST    R2,OFFADDR         SAVE INPUT DATA ADDRESS  ...\n*        L     R2,RECADDRO        R2 -> TO OUTPUT DATA ADDRESS  ...\n*        ST    R2,OFFADDRO        SAVE IT\nD10STBCT LA    R7,5                     LOAD 5 IN REG 7\n         NI    OPENFLGS,X'FE'           TURN WRITE SWITCH OFF\n         ST    R15,STORED4              SAVE OUT COUNTER\n         SPACE\nD20LOOP  DS    0H\n         CLI   5(R5),X'FF'              SELECT CF USED ?\n         BE    D60PTCF                  NO, CHECK NEXT CF\n         SPACE\n*        CLI   4(R5),C'0'               SELECT ALL VALUES ?\n*        BE    D50SWON                  YES, TURN WRITE SWITCH ON\n         SPACE\n         LA    R8,CONTROLS              LOAD CONTROLS ADDRESS\n         A     R8,0(R0,R5)              ADD DISPLACEMENT FROM SELECTAB\n         SPACE\n         L     R11,VRLTH                GET LTH OF VARIABLE RECORD\n         C     R11,0(0,R8)              START LOC IN RECORD ?\n         BL    D40NO                    NO, CAN'T COMPARE THIS FIELD\n*        LR    R1,R2                    POINT TO VARIABLE RECORD\n         SPACE\nD20OUT   DS    0H\n*        A     R1,0(R0,R8)              ADD START TO RECORD ADDRESS\n*        L     R9,0(0,R8)               MOVE HEX LTH TO REG 9\n         L     R11,OFFADDRO       R11 -> TO WHERE DATA GOES...\n*        L     R9,OFFADDR         R9 -> TO START OF INPUT DATA\n*        AR    R2,R9              ADD NEXT START OFFSET\n*        A     R9,0(0,R8)         ADD HEX LTH\n         L     R9,0(0,R8)         R9 = OFFSET TO THIS FIELD\n         S     R9,LASTOFF         - OFFSET TO LAST FIELD\n         BCTR  R9,0               R9 = HEX LTH TO MOVE\n         L     R2,0(0,R8)         R2 = OFFSET TO THIS FIELD\n         ST    R2,LASTOFF         SAVE IT\n         L     R2,OFFADDR         R2 -> TO WHERE DATA COMES FROM\n         SPACE\nD40SETBR DS    0H\n*        MVC   D40BR+1(1),4(R5)         SET BRANCH CONDITION\n*        EX    R9,D40MVC                MOVE DATA\n*        LA    R9,1(0,R9)         R9 = LTH MOVED\n         SPACE 1\n         LA    R9,1(0,R9)         R9 = REAL LTH TO MOVE\n         STM   R2,R5,SAVE2TO5     SAVE SOME REGS\n*                                 CAUSE MVCL CLOBBERS \"TO\" REG...\n         LR    R4,R11             R4 -> TO WHERE DATA GOES\n         LR    R5,R9              R5 = TOTAL LTH TO MOVE TO\n*                                 R2 -> TO WHERE DATA COMES FROM\n         LR    R3,R9              R3 = TOTAL LTH TO MOVE FROM\n         SPACE 1\n         MVCL  R4,R2              MOVE PART OF RECORD\n         LM    R2,R5,SAVE2TO5     LOAD SOME REGS\n*\nD40BR    BC    0,D50SWON                BRANCH\n         AR    R11,R9             R11 -> TO WHERE NEXT DATA GOES...\n         CLI   8(R8),C'A'         IS DATE ALPHA?\n         BNE   NOTALPHA           NO\n         L     R1,4(0,R8)         R1 = LTH TO MOVE\n*        BCTR  R1,0               R1 = HEX LTH TO MOVE\n         EX    R1,D40MVC2               MOVE DATA\n*        LA    R1,1(0,R1)         R1 = LTH MOVED\n*        MVC   0(2,R11),=C'19'    SET ALPHA CENTURY TO 19\n*        LA    R11,2(0,R11)       SET R11\n*        AR    R11,R1             ADD TO LTH\n         LA    R11,1(R1,R11)      ADD TO LTH, +1\n         ST    R11,OFFADDRO       R11 -> TO WHERE NEXT DATA GOES...\n         L     R11,VRLTHL         R11 = DATA LEFT TO MOVE...\n         SR    R11,R9             - WHAT WE MOVED\n         ST    R11,VRLTHL         R11 = DATA LEFT TO MOVE...\n         LR    R11,R2             R11 -> AT INPUT DATA\n         AR    R11,R9             R11 -> AT NEXT DATA TO MOVE\n         ST    R11,OFFADDR        SAVE IT\n         L     R11,VRLTHO         R11 = LTH OF DATA MOVED...\n*        AH    R11,=H'2'          + 2 FOR \"19\"\n*        AR    R11,R1             ADD LTH OF ADDED DATA\n         LA    R11,1(R1,R11)      ADD TO LTH, +1\n         ST    R11,VRLTHO         SAVE LTH MOVED...\n         B     D50SWON            TURN WRITE SWITCH ON\n         SPACE\nNOTALPHA DS    0H\n*        CLI   8(R8),C'P'         IS DATE PACKED?\n*        BNE   NOTPACK            NO\n*        MVC   0(1,R11),X'19'     SET PACKED CENTURY TO 19\n         L     R1,4(0,R8)         R1 = LTH TO MOVE\n*        BCTR  R1,0               R1 = HEX LTH TO MOVE\n         EX    R1,D40MVC2               MOVE DATA\n*        LA    R1,1(0,R1)         R1 = LTH MOVED\n*        AR    R11,R1             ADD TO LTH\n         LA    R11,1(R1,R11)      ADD TO LTH, +1\n*        MVI   0(R11),X'19'       SET PACKED CENTURY TO 19\n*        LA    R11,1(0,R11)       SET R11\n         ST    R11,OFFADDRO       R11 -> TO WHERE DATA GOES...\n         L     R11,VRLTHL         R11 = DATA LEFT TO MOVE...\n         SR    R11,R9             - WHAT WE MOVED\n         ST    R11,VRLTHL         R11 = DATA LEFT TO MOVE...\n         LR    R11,R2             R11 -> AT INPUT DATA\n         AR    R11,R9             R11 -> AT NEXT DATA TO MOVE\n         ST    R11,OFFADDR        SAVE IT\n         L     R11,VRLTHO         R11 = LTH OF DATA MOVED...\n*        AH    R11,=H'1'          + 1 FOR \"19\"\n*        AR    R11,R1             ADD LTH OF ADDED DATA\n         LA    R11,1(R1,R11)      ADD TO LTH, +1\n         ST    R11,VRLTHO         SAVE LTH MOVED...\n         B     D50SWON            TURN WRITE SWITCH ON\n         SPACE\nNOTPACK  DS    0H\n         SPACE\nD40NO    DS    0H\n         NI    OPENFLGS,X'FE'           TURN WRITE SWITCH OFF\n         LR    R11,R7                R11 = NBR OF CF'S LEFT\n         MH    R11,H116              R11 * 116 = LTH OF CF'S LEFT\n         AR    R5,R11                R5 -> TO NEXT CF SET FOR THIS OUT\n         B     D70BR                    CONDITION NOT MET, REJECT TEST\n         SPACE\nD40MVC   MVC   0(0,R11),0(R2)     MOVE DATA\nD40MVC2  MVC   0(0,R11),5(R5)     MOVE DATA 2...\nD40CLC   CLC   0(0,R1),5(R5)            COMPARE\n         SPACE\nD50SWON  DS    0H\n         OI    OPENFLGS,X'01'           TURN WRITE SWITCH ON\n         SPACE\nD60PTCF  DS    0H\n         LA    R5,116(R5)               POINT TO NEXT CF\nH116     EQU   *-2                   HALFWORD OF 116\n         BCT   R7,D20LOOP               5 CF'S PROCESSED ?\n*\n         L     R9,VRLTHL          R9 = DATA LEFT TO MOVE...\n*        BCTR  R9,0               R9 = HEX LTH TO MOVE\n         LTR   R9,R9              R9 ALREADY 0?\n         BZ    NOMOVE2            YES, DON'T SUBT 1\n         L     R2,OFFADDR         R2 -> TO WHERE DATA COMES FROM\n         L     R11,OFFADDRO       R11 -> TO WHERE DATA GOES...\n*        EX    R9,D40MVC                MOVE DATA\n         SPACE 1\n*        LA    R9,1(0,R9)         R9 = REAL LTH TO MOVE\n         STM   R2,R5,SAVE2TO5     SAVE SOME REGS\n*                                 CAUSE MVCL CLOBBERS \"TO\" REG...\n         LR    R4,R11             R4 -> TO WHERE DATA GOES\n         LR    R5,R9              R5 = TOTAL LTH TO MOVE TO\n*                                 R2 -> TO WHERE DATA COMES FROM\n         LR    R3,R9              R3 = TOTAL LTH TO MOVE FROM\n         SPACE 1\n         MVCL  R4,R2              MOVE PART OF RECORD\n         LM    R2,R5,SAVE2TO5     LOAD SOME REGS\n*\n         SPACE\nNOMOVE2  DS    0H\n*        LA    R9,1(0,R9)         R9 = LTH MOVED\n         L     R11,VRLTHO         R11 = LTH OF DATA MOVED...\n*        AH    R11,H4                ADD OFFSET (0 IF RDW, 4 IF DATA)\n*        ST    R11,VRLTHO         SAVE LTH MOVED...\n         L     R9,RECADDRO        R9 -> TO OUTPUT RECORD\n         STH   R11,0(0,R9)        UPDATE LTH\n*\n         TM    OPENFLGS,X'01'           YES, WRITE RECORD ?\n         BNO   D70BR                    NO, GO TO D70BR\n         SPACE\n         L     R11,STORED               LOAD RETURN ADDRESS\n         BR    R11                      RETURN TO WRITE RECORD\n         SPACE\nD70BR    DS    0H\n         TM    OPENFLGS,X'01'           RECORD ALREADY WRITTEN ?\n         BO    D80BR                    YES, CHECK NEXT FILE\n         SPACE\n         L     R15,STORED4              LOAD OUT COUNTER\n         BCT   R15,D10STBCT             ANY MORE OUTS FOR THIS TEST ?\nD80BR    DS    0H\n         BR    R3                       NO, SET UP NEXT OUT TEST\n         SPACE\nSTORED   DS    F\nSTORED4  DS    F                        OUT COUNTER\nSAVE2TO5 DS    4F                 SAVE AREA\nMAXLTHO  DC    H'0'               MAX LTH OF OUTPUT BUFFER\n         EJECT\n***********************************************************************\n*        R O U T I N E   T O   P R I N T   R E P O R T S   1,2,3      *\n***********************************************************************\n         SPACE 2\nE10PRT   DS    0H\n         ST    R11,STORE1               SAVE RETURN ADDRESS\n         ST    R1,STORE2          SAVE A(OUT1) PARMS\n         L     R7,VRLTH           R7 = VARIABLE RECORD LTH\n         LR    R9,R2              R9 -> TO V RECORD\nE20LOOP  L     R3,8(0,R1)         R3 -> LINE COUNTER\n         CP    0(3,R3),FULLPAGE   IS PAGE FULL ?\n         BL    E30                NO\n         BAL   R11,Y10SKIP1       YES, SKIP TO NEW PAGE\n         L     R1,STORE2          R1 -> TO PARMS\n         BAL   R11,Y10SPCE3       SKIP DOWN 3 LINES\n         L     R1,STORE2          R1 -> TO PARMS\n         L     R3,4(0,R1)         R3 -> TO PAGE COUNTER\n         MVC   HD1PAGE,PLEDWD1    EDIT PAGE COUNTER\n         ED    HD1PAGE,0(R3)      *\n         MVC   P(L'PHD),PHD       MOVE HEADING TO PRINT\n         MVC   P+100(L'HD1),HD1   *\n         BAL   R11,Y10WSP2        PRINT HEADING, SPACE 2\n         SPACE\nE30      DS    0H\n         LA    R8,132             R8 = LTH OF OUTPUT LINE\nH132     EQU   *-2                HALFWORD 132\nE40      DS    0H\n         CR    R7,R8              REC LTH OVER 132?\n         BH    E50                YES, PRINT IN 132 BYTE CHUNKS\n         SPACE\n         SH    R7,H1              R7 = LRECL - 1\n         EX    R7,MOVETOP         MOVE DATA TO PRINT LINE\n         L     R1,STORE2          R1 -> TO PARMS\n         BAL   R11,Y10WSP2        PRINT LAST LINE, SPACE 2\n         L     R11,STORE1         LOAD RETURN ADDRESS\n         BR    R11                GO BACK TO CALLER\n         SPACE\nE50      DS    0H\n         SH    R8,H1              R8= 131\n         EX    R8,MOVETOP         MOVE 132 BYTES TO PRINT\n         L     R1,STORE2          R1 -> TO PARMS\n         BAL   R11,Y10WSP1        PRINT,SPACE 1\n         SPACE\n         SH    R7,H132            R7 = LRECL REMAINING\n         AH    R9,H132            R9 -> TO NEXT PART OF RECORD\n         L     R1,STORE2          R1 -> TO PARMS\n         B     E20LOOP            PRINT NEXT CHUNK OF RECORD\n         SPACE 2\nMOVETOP  MVC   P(1),0(R9)         MOVE DATA TO P\nFULLPAGE DC    PL3'50'\nH1       DC    H'1'\nH4       DC    H'4'\nOUT1     DC    A(OUT1DCB)\n         DC    A(PAGECTR1)\n         DC    A(LINECTR1)\n         SPACE\nOUT2     DC    A(OUT2DCB)\n         DC    A(PAGECTR2)\n         DC    A(LINECTR2)\n         SPACE\nOUT3     DC    A(OUT3DCB)\n         DC    A(PAGECTR3)\n         DC    A(LINECTR3)\n         SPACE\nOUT4     DC    A(SYSOUT)\n         DC    A(PAGECTR4)\n         DC    A(LINECTR4)\n         SPACE\nPAGECTR4 DC    PL3'0'\nLINECTR4 DC    PL3'75'\n         SPACE\n         SPACE\nSTORE1   DS    F                        RETURN ADDRESS\nSTORE2   DS    F\nSTORE5   DS    F\nSTOREDCB DS    F                        DCB ADDRESS\nNINES    DC    C' 999999999'\nSPACES   DC    CL10' '\nPHD      DS    CL74\n         EJECT\n***********************************************************************\n*        R O U T I N E   T O   P R I N T   R E P O R T S   4,5,6      *\n***********************************************************************\n         SPACE 2\nF10WRITE DS    0H\n         L     R0,RECADDRO              R0 -> TO NEW RECORD\n         PUT   (1),(0)                  PRINT\n         BR    R11                      RETURN\n         SPACE\nF50WRITE DS    0H\n         PUT   (1)                      GET OUTPUT AREA\n         LR    R15,R1                   R15 -> TO OUTPUT BUFFER\n         L     R7,VRLTH                 R7 = LTH OF INPUT RECORD\n         LH    R8,OUT7DCB+82            R8 = OUTPUT LRECL\n         SPACE\nF55COMP  DS    0H\n         CH    R8,H256            LRECL OVER 256 ?\n         BH    F60                YES, CLEAR IN CHUNKS\n         SPACE\n         SH    R8,=H'2'           R8 = LRECL - 2\n         MVI   0(R1),X'40'        CLEAR BUFFER\n         EX    R8,CLEAROUT        *\n         B     F65MOVE            MOVE INPUT TO OUTPUT\n         SPACE\nF60      DS    0H\n         MVI   0(R1),X'40'        CLEAR OUTPUT BUFFER\n         MVC   1(255,R1),0(R1)    *\n         LA    R1,256(R1,0)       ADD 256 TO R1\nH256     EQU   *-2                HALFWORD 256\n         SH    R8,H256            R8 = LRECL - 256\n         B     F55COMP            CLEAR NEXT CHUNK OF BUFFER\n         SPACE\nF65MOVE  DS    0H\n         LR    R3,R2              R3 -> TO INPUT RECORD\n         LH    R8,OUT7DCB+82      R8 = OUTPUT LRECL\n         CR    R7,R8              IS OUTPUT LONGER THAN INPUT ?\n         BL    F70COMP2           YES, MOVE ALL OF INPUT\n         LR    R7,R8              NO, MOVE OUTPUT LENGTH ONLY\n         SPACE\nF70COMP2 DS    0H\n         CH    R7,H256            INPUT LTH OVER 256 ?\n         BH    F80                YES, MOVE IN CHUNKS\n         SH    R7,H1              R7 = IBM LTH OF INPUT\n         EX    R7,MOVEDATA        MOVE INPUT TO OUTPUT\n         BR    R11                RETURN TO CALLER\n         SPACE\nCLEAROUT MVC   1(0,R1),0(R1)      CLEAR BUFFER\nMOVEDATA MVC   0(0,R15),0(R3)     MOVE INPUT TO OUTPUT\n         SPACE\nF80      DS    0H\n         MVC   0(256,R15),0(R3)   MOVE INPUT TO OUTPUT\n         SH    R7,H256            R7 = LTH LEFT\n         AH    R3,H256            R3 -> REST OF INPUT\n         AH    R15,H256           R15 -> TO REST OF OUTPUT\n         B     F70COMP2           MOVE REST OF DATA\n         EJECT\n***********************************************************************\n*        P R I N T E R   A N D   C A R R I A G E   C O N T R O L      *\n***********************************************************************\n         SPACE 2\nY10SKIP1 DS    0H\n         MVI   CTLCHR,X'8B'             SKIP1 TO CHANNEL 1\n         L     R3,4(0,R1)         R3 -> TO PAGE COUNTER\n         AP    0(3,R3),ONE        ADD 1 TO PAGE COUNT\n         L     R3,8(0,R1)         R3 -> TO LINE COUNTER\n         SP    0(3,R3),0(3,R3)    CLEAR LINE COUNTER\n         B     Y40\n         SPACE\nY10SPCE1 DS    0H\n         MVI   CTLCHR,X'0B'             SPACE 1 IMMEDIATE\n         L     R3,8(0,R1)         R3 -> TO LINE COUNTER\n         AP    0(3,R3),ONE        ADD 1 TO LINE COUNT\n         B     Y40\n         SPACE\nY10SPCE2 DS    0H\n         MVI   CTLCHR,X'13'             SPACE 2 IMMEDIATE\n         L     R3,8(0,R1)         R3 -> TO LINE COUNTER\n         AP    0(3,R3),TWO        ADD 2 TO LINE COUNTER\n         B     Y40\n         SPACE\nY10SPCE3 DS    0H\n         MVI   CTLCHR,X'1B'             SPACE 3 IMMEDIATE\n         L     R3,8(0,R1)         R3 -> TO LINE COUNTER\n         AP    0(3,R3),THREE      ADD 3 TO LINE COUNTER\n         B     Y40\n         SPACE\nY10WSP1  DS    0H\n         MVI   CTLCHR,X'09'             PRINT, SPACE 1\n         L     R3,8(0,R1)         R3 -> TO LINE COUNTER\n         AP    0(3,R3),ONE        ADD 1 TO LINE COUNTER\n         B     Y40\n         SPACE\nY10WSP2  DS    0H\n         MVI   CTLCHR,X'11'             PRINT, SPACE 2\n         L     R3,8(0,R1)         R3 -> TO LINE COUNTER\n         AP    0(3,R3),TWO        ADD 2 TO LINE COUNTER\n         B     Y40\n         SPACE\nY10WSP3  DS    0H\n         MVI   CTLCHR,X'19'             PRINT, SPACE 3\n         L     R3,8(0,R1)         R3 -> TO LINE COUNTER\n         AP    0(3,R3),THREE      ADD 3 TO LINE COUNTER\n         SPACE\nY40      DS    0H\n         L     R1,0(0,R1)               LOAD DCB ADDRESS\n         PUT   (1),PRINT                PRINT\n         MVI   P,C' '                   CLEAR PRINT BUFFER\n         MVC   P+1(L'P-1),P             *\n         SPACE\n         BR    R11                      RETURN\n         EJECT\n***********************************************************************\n*        IF THERE IS NO RECFM, LRECL OR BLKSIZE ON FILES              *\n*        OUT4, OUT5, OUT6 OR OUT7 AND THE OPEN BOMBS, WE              *\n*        WILL TRY TO RECOVER BY MAKING THEIR DCB INFORMATION          *\n*        THE SAME AS THE INPUT FILE.                                  *\n***********************************************************************\n         SPACE 2\nDCBEXIT  DS    0H\n         USING DCBEXIT,R15        SET BASE ADDRESSABLITY\n         CLI   36(R1),X'00'       RECFM SET ?\n         BNE   DCB10              YES, CHECK BLKSIZE\n         MVC   36(1,R1),INFILE+36 NO, SET SAME AS INPUT FILE\n         SPACE 1\nDCB10    DS    0H\n         CLC   62(2,R1),DWRK1     BLKSIZE SET ?\n         BNE   DCB20              YES, CHECK LRECL\n         MVC   62(2,R1),INFILE+62 NO, SET SAME AS INPUT FILE\n         SPACE 1\nDCB20    DS    0H\n         CLC   82(2,R1),DWRK1     LRECL SET ?\n         BNE   DCB30              YES, GO BACK TO OPEN\n         MVC   82(2,R1),INFILE+82 NO, SET SAME AS INPUT FILE\n         SPACE 1\nDCB30    DS    0H\n         BR    R14                GO BACK TO OPEN\n         DROP  R15                DROP R15 AS A BASE\n         EJECT\n***********************************************************************\n*        F I L E    D E C L A R E S   F O R   V P R I N T             *\n***********************************************************************\n         SPACE 2\n         PRINT NOGEN\nOUT1DCB  DCB   DDNAME=OUT1,DSORG=PS,MACRF=PM,RECFM=FBM,                +\n               LRECL=133,BLKSIZE=665\nOUT2DCB  DCB   DDNAME=OUT2,DSORG=PS,MACRF=PM,RECFM=FBM,                +\n               LRECL=133,BLKSIZE=665\nOUT3DCB  DCB   DDNAME=OUT3,DSORG=PS,MACRF=PM,RECFM=FBM,                +\n               LRECL=133,BLKSIZE=665\nOUT4DCB  DCB   DDNAME=OUT4,DSORG=PS,MACRF=PM,EXLST=BLKEXLST\nOUT5DCB  DCB   DDNAME=OUT5,DSORG=PS,MACRF=PM,EXLST=BLKEXLST\nOUT6DCB  DCB   DDNAME=OUT6,DSORG=PS,MACRF=PM,EXLST=BLKEXLST\nOUT7DCB  DCB   DDNAME=OUT7,DSORG=PS,MACRF=PL,RECFM=FB,EXLST=BLKEXLST\nBLKEXLST DC    X'85',AL3(DCBEXIT)\nINFILE   DCB   DDNAME=TAPEIN,DSORG=PS,MACRF=GM,EODAD=A70STATS\nSYSOUT   DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,RECFM=FBM,            +\n               LRECL=133,BLKSIZE=665\n         PRINT GEN\n         SPACE 2\n***********************************************************************\n*        D E C L A R A T I V E S   F O R   V P R I N T                *\n***********************************************************************\n         SPACE\nVSAVE    DC    18F'0'                   REGISTER SAVE AREA\nVRLTH    DC    F'0'               LTH OF INPUT RECORD\nVRLTHL   DC    F'0'               LTH OF INPUT RECORD LEFT TO MOVE\nVRLTHO   DC    F'0'               LTH OF OUTPUT RECORD\n*VRLTH2L DC    F'0'               LTH OF OUTPUT RECORD LEFT TO MOVE\nRECADDR  DC    F'0'               ADDRESS OF INPUT RECORD\nOFFADDR  DC    F'0'               OFFSET TO INPUT DATA TO MOVE\nLASTOFF  DC    F'0'               OFFSET TO LAST MOVED DATA\nRECADDRO DC    F'0'               ADDRESS OF OUTPUT RECORD\nOFFADDRO DC    F'0'               OFFSET TO OUTPUT DATA AREA\nPAGECTR1 DC    PL3'0'                   OUT1 PAGE COUNTER\nPAGECTR2 DC    PL3'0'                   OUT2 PAGE COUNTER\nPAGECTR3 DC    PL3'0'                   OUT3 PAGE COUNTER\nLINECTR1 DC    PL3'75'            OUT1 LINE COUNTER\nLINECTR2 DC    PL3'75'            OUT2 LINE COUNTER\nLINECTR3 DC    PL3'75'            OUT3 LINE COUNTER\nINCTR    DC    PL4'0'                   INPUT RECORDS COUNTER\nOUTCTR1  DC    PL4'0'                   RECORDS ON OUT1 COUNTER\nOUTCTR2  DC    PL4'0'                   RECORDS ON OUT2 COUNTER\nOUTCTR3  DC    PL4'0'                   RECORDS ON OUT3 COUNTER\nOUTCTR4  DC    PL4'0'                   RECORDS ON OUT4 COUNTER\nOUTCTR5  DC    PL4'0'                   RECORDS ON OUT5 COUNTER\nOUTCTR6  DC    PL4'0'                   RECORDS ON OUT6 COUNTER\nOUTCTR7  DC    PL4'0'             RECORDS ON OUT7 COUNTER\nONE      DC    P'1'\nTWO      DC    P'2'\nTHREE    DC    P'3'\nHD1      DS    0CL30\n         DC    C'DATE'\nHD1DAY   DC    X'40202020'\n         DC    C'/'\nHD1MTH   DS    CL2\n         DC    C'/'\nHD1YR    DS    CL2\n         DC    CL10'     PAGE'\nHD1PAGE  DS    CL6\nPRINT    DS    0CL133\nCTLCHR   DC    X'09'\nP        DS    CL132\nPLEDWD1  DC    12X'4020202020202020212040'\n         SPACE\n*                                       END OF FILE MESSAGES\n         SPACE\nSHD1     DS    0CL58\n         DC    CL20' '\nSEDWD1   DS    CL8\n         DC    CL30'  RECORDS WRITTEN ON OUT1'\nSHD2     DS    0CL58\n         DC    CL20' '\nSEDWD2   DS    CL8\n         DC    CL30'  RECORDS WRITTEN ON OUT2'\nSHD3     DS    0CL58\n         DC    CL20' '\nSEDWD3   DS    CL8\n         DC    CL30'  RECORDS WRITTEN ON OUT3'\nSHD4     DS    0CL58\n         DC    CL20' '\nSEDWD4   DS    CL8\n         DC    CL30'  RECORDS WRITTEN ON OUT4'\nSHD5     DS    0CL58\n         DC    CL20' '\nSEDWD5   DS    CL8\n         DC    CL30'  RECORDS WRITTEN ON OUT5'\nSHD6     DS    0CL58\n         DC    CL20' '\nSEDWD6   DS    CL8\n         DC    CL30'  RECORDS WRITTEN ON OUT6'\nSHD7     DS    0CL58\n         DC    CL20' '\nSEDWD7   DS    CL8\n         DC    CL30'  RECORDS WRITTEN ON OUT7'\nSHDUT1   DS    0CL58\n         DC    CL20' '\nSEDWDUT1 DS    CL8\n         DC    CL30'  RECORDS READ ON TAPEIN'\n         SPACE\n         LTORG\nR0       EQU   0                       REGISTER EQUATES\nR1       EQU   1                       *\nR2       EQU   2                       *\nR3       EQU   3                       *\nR4       EQU   4                       *\nR5       EQU   5                       *\nR6       EQU   6                       *\nR7       EQU   7                       *\nR8       EQU   8                       *\nR9       EQU   9                       *\nR10      EQU   10                      *\nR11      EQU   11                      *\nR12      EQU   12                      *\nR13      EQU   13                      *\nR14      EQU   14                      *\nR15      EQU   15                      *\nCONTROLS DSECT\n         COPY  SDP10\nSELECTS  DS    0F\n         COPY  SDP20\nVPRINT   CSECT\n         END   VPRINT\n//LKED.SYSLMOD DD DSN=HALL.LINKLIB(DATEVB),DISP=SHR\n//\n//*                 NO OVERLAY FOR TESTING...\n//*\n//LKED.OLDIN DD *\n         ENTRY ROOTSECT\n       OVERLAY ONE\n        INSERT CTRLEDIT\n       OVERLAY ONE\n        INSERT VPRINT\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DATEVBJ": {"ttr": 7432, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03?\\x00\\x99\\x03?\\x12X\\x00$\\x00$\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-02T00:00:00", "modifydate": "1999-02-02T12:58:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "RH87944"}, "text": "//DATEVB   JOB                                                          JOB11965\n/*ROUTE  PRINT R7\n//*\n//*            DSN=CBT.SOURCE(DATEVBJ)\n//*\n//*********************************************************************\n//*\n//*      TEST DATEVB AGAINST A KNOWN RESULT....\n//*\n//*********************************************************************\n//TIME  EXEC PGM=DATEVB\n//STEPLIB DD DSN=HALL.LINKLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//SYSABEND DD SYSOUT=*\n//OUT1 DD SYSOUT=*\n//TAPEIN   DD  DSN=HALL.OUTLIST,\n//         DISP=SHR\n//OUT4     DD  DSN=HALL.OUTLIST2,\n//         DISP=SHR\n//*\n//*\n//*      DATEVB CONTROL CARDS\n//*\n//TIME.SYSIN DD *\n*START=HEX\n*  START=HEX MUST BE FIRST TO USE HEX OFFSETS IN CONTROL= FIELDS\nINPUT=TAPEIN,CONTROL=(20,2,A,59,2,H)\nOUTPUT=OUT4\nSELECT=OUT4,CF1=(=20),CF2=(=19)\n/*                |         |\n//*               |         |\n//*               |         |\n//*               |         |HEX DATA TO INSERT AT OFFSET 59\n//*               |CHAR DATA TO INSERT AT OFFSET 20\n//*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DAYDATE": {"ttr": 7434, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03?\\x00\\x99\\x03?\\x085\\x03]\\x03]\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-02T00:00:00", "modifydate": "1999-02-02T08:35:00", "lines": 861, "newlines": 861, "modlines": 0, "user": "RH87944"}, "text": "//DAYDATE  JOB\n/*ROUTE PRINT R7\n//*\n//*    DSN=CBT.SOURCE(DAYDATE)\n//*\n//S EXEC HLASMCL,PARMC='NOALIGN,NORLD',CLASS='*',COND.LKED=(7,LT,ASM)\n//ASM.SYSIN DD *\nDAYDATE   TITLE 'TIME OF DAY AND DATE SUBROUTINE.'\n         PRINT ON,GEN,DATA\n*                                                                   Y2\n*              MODIFIED  BY R. HALL, DIVERSIFIED DEVELOPMENTS,      Y2\n*              JAN 06 1997, TO SHOW 4 DIGIT YEAR FOR YEAR 2000      Y2\n*              CHANGES FOR YEAR 2000 HAVE Y2 IN COLS 69-70          Y2\n*\n*              MODIFIED BY R. HALL, DIVERSIFIED DEVELOPMENTS,\n*              JUL 23, 1991, TO   ACCEPT A JULIAN DATE PASSED IN\n*              POSITION 1 OF THE TIMEDATE FIELD.\n*\n*              CORRECTED BY R. HALL, DIVERSIFIED DEVELOPMENTS,\n*              OCT 10, 1987,      CHANGE TO ONLY ASSEMBLER TYPE CALL.\n*\n*              CORRECTED BY R. HALL, DIVERSIFIED DEVELOPMENTS,\n*              MAY 11, 1987,      TO WORK EVEN BETTER.\n*\n*              CORRECTED BY R. HALL, DIVERSIFIED DEVELOPMENTS,\n*              DECEMBER 31, 1985, TO WORK PROPERLY!\n*\n*\n*        THIS VERSION OF DAYDATE IS RE-ENTRANT. IT WILL ONLY\n*        RUN ON A 370 BECAUSE OF BYTE ALIGNMENT AND EXISTENCE OF THE\n*        TIME-OF-DAY CLOCK.\n*\n*\n*        DAYDATE IS AN ASSEMBLER SUBROUTINE WHICH WILL PLACE IN THE\n*        40 BYTE AREA PROVIDED BY THE CALLER THE IPL DATE AND CURRENT\n*        TIME, IN EBCDIC, AS:\n*\n*                   HH.MM.SS YYYY.DDD  DAY DD MON YYYY              Y2\n*\n*        THE SIGNIFICANT FEATURE OF THIS ROUTINE, IS THAT THE EXACT\n*        DAY OF THE WEEK (SUNDAY THROUGH SATURDAY) IS RETURNED AS\n*        PART OF THE GREGORIAN FORM DATE.(9 CHARACTERS IN THIS VERSION)\n*\n*\n*\n*  * * * DAYDATE ALSO SUPPORTS THE TIME-OF-DAY CLOCK OF S/370. * * *\n*\n*        A SECOND PARAMETER PASSED TO DAYDATE IMPLIES TOD CLOCK\n*        PROCESSING IS REQUIRED.  ONE OF TWO MANIPULATIONS WILL\n*        BE PERFORMED, DETERMINED BY THE CONTENTS OF THE 8 BYTE\n*        FIELD PASSED TO DAYDATE, AS THE SECOND PARAMETER:\n*\n*        1. A BINARY ZERO FILLED FIELD ON INPUT WILL CONTAIN THE\n*           CURRENT TOD CLOCK VALUE ON OUTPUT, AND THIS VALUE WILL\n*           HAVE BEEN USED TO CALCULATE THE TIME AND DATE INSERTED\n*           INTO THE 40 BYTE FIRST PARAMETER. UF A SECOND PARAMETER\n*           IS NOT PASSED THE PROGRAM PUTS THE TOD VALUE IN THE\n*           40 BYTE AREA AS A WORK.\n*\n*        2. A NON-ZERO FIELD IS ASSUMED TO BE A VALID TOD CLOCK\n*           VALUE, AND THIS VALUE IS USED TO CALCULATE THE TIME\n*           AND DATE RETURNED IN THE 40 BYTE FIRST PARAMETER.\n         EJECT\n*\n*\n*\n*\n*\n*  * * * EXAMPLE INVOCATION OF THIS ROUTINE:\n*\n*        (A)  FROM PL/I:\n*\n*\n*             DCL  TIMEDATE  CHAR (40),\n*\n*                  1  TOD_CLOCK,\n*                     2  SECONDS FIXED BINARY (31,0),\n*                     2  MIC_SEC FIXED BINARY (31,0);\n*\n*\n*             TIMEDATE = ' ';           /* SIGNAL CURRENT DATE REQD */\n*             CALL DAYDATE(TIMEDATE);\n*\n*             TOD_CLOCK = 0B;\n*             CALL DAYDATE(TIMEDATE,SECONDS);\n*             /* NOTE SCALER (SECONDS), NOT STRUCTURE (TOD_CLOCK) ARG*/\n*\n*\n*\n*\n*\n*        (B)  FORTRAN\n*\n*\n*             INTEGER*4  DATE(10), TOD(2)/0,0/\n*\n*             CALL DAYDATE(DATE,TOD)\n*\n*             CALL DAYDATE(DATE)\n*\n*\n         EJECT\nDAYDATE  CSECT\nDAYDATE  AMODE 24                 WAS 31\nDAYDATE  RMODE 24                 WAS ANY\n         ENTRY DAYDAT\nDAYDAT   DS    0H\n         USING *,R15              SET TEMP BASE\n         B     AROUND             BRANCH AROUND DUMP TITLE\n         DC    AL1(EYELTH)\nEYECATCH DC    C'DAYDATE '        PROGRAM NAME\n         DC    C'VERSION 3.0 '    VERSION                           Y2\n         DC    C'&SYSDATE'        DATE WRITTEN\n         DC    C' '               BLANK\n         DC    C'&SYSTIME'        TIME WRITTEN\n         DC    C' CHANGE JULIAN OUTPUT TO 4 CHARS FOR YEAR 2000'    Y2\n*        DC    C' CREATE ALPHABETIC DATE MSG, VERSION 2'\nEYELTH   EQU   *-EYECATCH         LTH OF EYE CATCHER\n         SPACE 1\nAROUND   DS    0H\n*        USING *,R15\nSTART    SR    R15,R15                  SIGNAL NON-PL/1 ENTRY\n         DROP  R15\n         LA    R1,0(0,R1)         CLEAR HI-ORDER BYTE FOR 31 BIT\n         LA    R13,0(0,R13)       CLEAR HI-ORDER BYTE FOR 31 BIT\n         BSM   R14,0              SAVE CURRENT AMODE\n         STM   R14,R10,12(R13)          SAVE CALLER'S REGS\n         BALR  R10,0                    EST. BASE REG\n         USING *,R10,R9\n         LA    R9,4095(0,R10)     SET 2ND BASE REG...\n         LA    R9,1(0,R9)         ''\n*        ST    R13,SAVE+4         CHAIN SAVE AREAS\n*        LA    R3,SAVE            ''\n*        ST    R3,8(0,R13)        CHAIN SAVE AREAS\n*        LA    R13,SAVE           ''\n         USING DDSECT,R13               BASE FOR DOUBLE WORD WORK AREA\n*                                       IS 2ND & 3RD WORD OF SAVE AREA\n*\n*\n*        ANALYSE PARAMETER LIST PASSED IN R1  (PARM)\n*\n*\n         L     R3,0(R1)                 GET PTR TO FIRST ARGUMENT\n         USING FELDMASK,R3\n         SPACE 1\n         TM    0(R1),X'80'              IS FRST ARG LAST?\n         BZ    TODCLOCK                 NO - XTRA ARG FOR TOD CLOCK\n         SPACE 1\n         CLI   TIMEDATE,C' '      IS A DATE SUPPLIED?\n         BE    NODATE             NO\n         TM    TIMEDATE+3,X'0F'   IS IT A PACKED FIELD?\n         BNO   NODATE             NO\n         SR    R0,R0              YES, SET TIME TO ZERO\n         L     R1,TIMEDATE        PUT JULIAN DATE IN R1\n         MVC   TIMEDATE(4),=CL4' ' CLEAR TIMEDATE\n         LR    R4,R1              R4 = JULIAN DATE\n         SRL   R4,24              R4 = CENTURY\n*        ST    R4,DOUBLE\n*        PACK  DOUBLE+4(2),DOUBLE+3(4)\n*        SR    R1,R1                    CLEAR R1                    Y2\n*        IC    R1,SAVETIME+8            R1 = CENTURY FROM YYYY      Y2\n         SLL   R4,4                     MULT BY 16                  Y2\n         LA    R4,15(R4)                ADD SIGN                    Y2\n         XC    DOUBLE(8),DOUBLE         CLEAR DOUBLE                Y2\n         ST    R4,DOUBLE+4              STORE YEAR                  Y2\n         CVB   R4,DOUBLE                GET YEARS IN CENTURY        Y2\n         ST    R4,CENTURY               SAVE CENTURY                Y2\n*        MVC   CENTURY+3(1),DOUBLE+4 SET CENTURY\n         SR    R4,R4              CLEAR R4\n*        LA    R4,DOUBLE                POINT TO AREA IN 1ST PARAM\n         B     GOTTIME            GO CONVERT IT...\n         SPACE 1\nNODATE   DS    0H\n         LA    R4,DOUBLE                POINT TO AREA IN 1ST PARAM\n         B     TOD3               SINCE STCK CODE DOESN'T WORK      RH\n*        B     TOD2                                                 RH\n         SPACE 1\nGOTTIME  DS    0H\n         STM   R0,R1,DOUBLE             PLACE TIME & DATE IN WORKAREA\n         STM   R0,R1,DOUBLE2      SAVE DATE FOR LEAP TEST TOO       RH\n         ST    R1,SAVEJUL         SAVE DATE                         RH\n         SPACE 1\n         OI    DOUBLE+3,X'0F'           MAKE TIME A VALID PACKED DEC NO\n         MVO   DOUBLE(4),DOUBLE(3)      NOW HAVE \"0H HM MS S+\"\n         MVI   HHMMSS,C' '              BLANK OUT OUTPUT FIELD\n         MVC   HHMMSS+1(39),HHMMSS      ''\n         ED    TIMEPTRN(10),DOUBLE      EDIT THE TIME TO \"  HH.MM.SS\"\n         MVC   0(8,R3),TIMEPTRN+2       SHIFT STRING TO START OF FIELD\n         MVI   HHMMSS+8,X'40'           BLANK OUT EXTRA FIELD\n*\nNOTIME   DS    0H\n         ED    DATEMASK(9),DOUBLE+4     EDIT THE JULIAN DATE        Y2\n         MVC   YYYYDDD,DATEMASK+1       PUT JULIAN DATE IN OUTPUT   Y2\n*\n******** ***** ****************** **********\n         LA    R8,4                     OFFSET TO LEAP YEAR ENTRIES\n*\n         LA    R4,DOUBLE2+4       R4 -> AT CC IN CCYY\n         CLI   DOUBLE2+5,X'00'    IS IT A CENTURY?\n         BE    LEAPCENT           YES\n         LA    R4,DOUBLE2+5       R4 -> AT YY IN CCYY\n*\nLEAPCENT DS    0H\n*\n*        TEST FOR LEAP YEAR\n*\n*        NI    DOUBLE2+5,X'13'     EXTRACT BITS FOR TESTING YEAR FOR\n         NI    0(R4),X'13'         EXTRACT BITS FOR TESTING YEAR FOR\n*                                  DIVISIBILITY BY 4\n         BZ    LEAPYEAR            DIVISIBLE - EVEN HIGH DIGIT\n*        XI    DOUBLE2+5,X'12'     TEST FOR DIVIDE BY 4- ODD HIGH DIGIT\n         XI    0(R4),X'12'         TEST FOR DIVIDE BY 4- ODD HIGH DIGIT\n         BZ    LEAPYEAR            DIVISIBLE - ODD HIGH DIGIT\n         LA    R8,6               OFFSET TO NON-LEAP YEAR ENTRIES\n*\nLEAPYEAR DS    0H\n*\nMYCODE   DS    0H\n*        SR    R1,R1                    CLEAR FOR WORK\n*        IC    R1,DOUBLE+5              SAVE YEAR\n*        SLL   R1,4                     MULT BY 16\n*        LA    R1,15(R1)                ADD SIGN\n         XC    DOUBLE(6),DOUBLE         CLEAR DOUBLE\n         CVB   R0,DOUBLE                GET DAYS IN BINARY\n         C     R0,=F'366'         *IF #  OF DAYS > 366\n         BH    BADDATE                  YES REPORT ERROR.\n         ST    R0,SAVEDAY         STORE DAY OF YEAR\n*        ST    R1,DOUBLE+4              STORE YEAR\n*        CVB   R1,DOUBLE                GET YEARS IN CENTURY\n*\nFINDMON  EQU   *\n*        ST    R1,DOUBLE                PLACE BINARY YEAR OF CENTURY\n         AGO   .SKIP1\n**       ST    R1,ZYEAR           SAVE YEAR FOR ZELLER'S CONGRUENCE\n*\n*        L     R3,ZYEAR           *LOAD FOR WEEKDAY CALC'N          CUL\n         SR    R0,R0              *CALC                             CUL\n         D     R0,=F'4'           *  YY MOD(4)                      CUL\n         LA    R4,DAYTAB-4        *ASSUME NOT LEAP YEAR             CUL\n         LTR   R0,R0              *REMAINDER (YY/4) \u00ac= 0            CUL\n         BNZ   *+8                *  =>  NOT LEAP YEAR              CUL\n         LA    R4,DAYTABLP-4      *  ELSE LOAD LEAP YEAR DAY TABLE  CUL\n         SPACE 1                                                    CUL\n         LA    R2,8               *OFFSET OF FEB IN DAYS TABLE      CUL\n         L     R5,SAVEDAY         R5 = DAY OF YEAR                  RH\nGETMON1  DS    0H                                                   RH\n         C     R5,0(R2,R4)        *# DAYS < OR = ENTRY IN TABLE     CUL\n         BNH   GETDAY             *  => HAVE FOUND MONTH+1          CUL\n         LA    R2,4(,R2)          *  ELSE GO CHECK                  CUL\n         B     GETMON1            *    NEXT ENTRY                   CUL\n         SPACE 1                                                    CUL\nGETDAY   S     R2,=F'4'           *BACKUP 1 MONTH                   CUL\n         S     R5,0(R2,R4)        *CALCULATE DAY OF MONTH           CUL\n*        ST    R5,ZDAY            *  & SAVE FOR LATER               CUL\n         SRL   R2,2               *CONVERT INDEX TO MONTH           CUL\n*        ST    R2,ZMONTH          *  AND SAVE IT                    CUL\n         SPACE 1                                                    CUL\n*        TM    DOUBLE+3,X'03'           IS IT A LEAP YEAR (DIVISIBLE 4)\n*        BC    7,NOTLEAP                \u00ac0 => NOT LEAP\n*        LA    R8,4                     0 => LEAP YR.  RESET TABLE OFST\n.SKIP1   ANOP\n*\nNOTLEAP  DS    0H\n*        L     R0,SAVEDAY         R0 = DAY OF YEAR AGAIN            RH\n         LA    R5,LASTDAY-4             SET PTR FOR LAST DAY PROCESSING\n         CH    R0,0(R8,R5)              IS DAY OF YEAR TOO HIGH?\n         BH    BADDATE                  YES REPORT ERROR.\n         LA    R5,12                    12 MONTHS / YEAR\n         MVC   YEAR,YYYYDDD       EBCDIC YYYY FIELD REQD AT END TOO Y2\n         LA    R2,LASTMON               GET ADDR OF EBCDIC MONTH TABLE\n*\nPREVMON  CH    R0,0(R8,R2)              IS   DAY OF YEAR IN THIS MONTH\n         BH    FOUNDMON                 YES -\n         LA    R2,8(0,R2)               NO - CHECK PREVIOUS MONTH\n         BCT   R5,PREVMON\n*\nBADDATE  MVC   DAY(13),=C'INVALID DATE ' MOVE \"INVALID DATE\" MESSAGE IN\n         LA    R15,16\n         B     EXIT\n         EJECT\n*\n*\n*\nFOUNDMON DS    0H\n         LR    R6,R0                    SAVE DAY OF YEAR\n*        ST    R5,MONTH           SAVE MTH FOR ZELLER'S CONGRUENCE\n         SH    R0,0(R8,R2)              CALC DAY OF MONTH\n*        ST    R0,ZDAY            SAVE DAY FOR ZELLER'S CONGRUENCE\n         CVD   R0,DOUBLE                CONVERT DAY OF MONTH TO DEC\n         ED    DDMASK(4),DOUBLE+6       EDIT THE DAY                Y2\n         MVC   DD(2),DDMASK+2           SAVE THE DAY                Y2\n*\nMOVEMON  MVC   MON,0(R2)                MOVE IN EBCDIC MONTH\n*\n**********************************************************************\n*                                                                    *\n*        CALCULATE DAY OF WEEK USING T.F. WONG'S FORMULA             *\n*        SEE HTTP://WWW/ASIAONLIN.NET.HK/~TFWONG/MATHS.HTM\n*                                                                    *\n*        DAY OF WEEK\n*\n*                     Y - 1        Y - 1        Y - 1\n*   S = (Y - 1) + INT(-----) - INT(-----) + INT(-----) + D\n*                       4           100          400\n*\n*        WHERE: 1) ALL OPERATIONS ARE DONE USING INTEGER ARITH\n*               2) D = JULIAN DAY OF YEAR\n*               3) Y = YEAR\n*\n*   AFTER CALCULATING THE VALUE S, DIVIDE IT BY 7, AND GET THE\n*   REMAINDER. IF THE REMAINDER IS 0, THE DAY IS SUNDAY, IF IT IS 1,\n*   THE DAY IS MONDAY, ..., IF IT IS 6, THE DAY IS SATURDAY.\n*\n*        R1 : ACCUMULATOR\n*\n**********************************************************************\n*\n*              GET YEAR\n*\n         SR    R4,R4              CLEAR R4\n         L     R5,SAVEJUL         R5 = JULIAN DATE\n         SRL   R5,16              DROP DAY\n         SLL   R5,4               LEFT 4 BITS\n         LA    R5,15(0,R5)        ADD SIGN\n         XC    DOUBLE,DOUBLE      CLEAR DWORD\n         ST    R5,DOUBLE+4        SAVE IT\n         CVB   R5,DOUBLE          CONVERT TO BINARY\n         BCTR  R5,0               -1\n         LR    R1,R5              S STARTS WITH YEAR-1\n*\n*              GET (YEAR-1)/4\n*\n         SR    R6,R6              CLEAR R6\n         LR    R7,R5              R7 = Y-1\n         D     R6,=F'4'           CALC IF LEAP YEAR\n         AR    R1,R7              ADD IT TO S\n*\n*              GET (YEAR-1)/100\n*\n         SR    R6,R6              CLEAR R6\n         LR    R7,R5              R7 = Y-1\n         D     R6,=F'100'\n         SR    R1,R7              SUBTRACT IT FROM S\n*\n*              GET (YEAR-1)/400\n*\n         SR    R6,R6              CLEAR R6\n         LR    R7,R5              R7 = Y-1\n         D     R6,=F'400'\n         AR    R1,R7              ADD IT TO S\n*\n*              GET JULIAN DAY OF YEAR\n*\n         SR    R6,R6              CLEAR R6\n         L     R7,SAVEJUL         R7 = JULIAN DATE\n         SLL   R7,16              DROP YEAR\n         SRL   R7,16              ''\n         XC    DOUBLE,DOUBLE      CLEAR DWORD\n         ST    R7,DOUBLE+4        SAVE IT\n         CVB   R7,DOUBLE          CONVERT TO BINARY\n         AR    R1,R7              ADD IT TO S\n*\n*              DIVIDE S BY 7\n*\n         SR    R4,R4              CLEAR R4\n         LR    R5,R1              R5 = ??\n         D     R4,=F'7'           CALC WEEKS IN YEAR\n*\n*              GET DAY OF WEEK BASED ON REMAINDER IN R4\n*\n         MH    R4,=H'9'           R4 -> TO WEEK DAY\n         LA    R5,WEEKDAYS(R4)          GET DAY OF WEEK\nSETDAY   MVC   DAY,0(R5)                MOVE EBCDIC DAY TO FIELD\n*\n         LA    R15,0                    SIGNAL NORMAL RETURN\n*\nEXIT     DS    0H\n         L     R14,12(0,R13)      R14 -> TO CALLER'S R13\n         LM    R0,R10,20(R13)     SET R0-R10 TO CALLERS REGS\n         OI    15(13),X'01'       SAY WE ARE FINISHED WITH SAVEAREA\n*              GET INTO PROPER MODE AND GO BACK TO CALLER\n         BSM   0,R14              RETURN TO CALLING PROGRAM\n         EJECT\n*\n*\n*        A SECOND ARGUMENT HAS BEEN RECEIVED, IMPLYING TOD CLOCK\n*        PROCESSING IS REQUIRED.\n*\nTODCLOCK L     R4,4(R1)                 GET PTR TO 2ED ARG\n         NC    0(8,R4),0(R4)            TOD VALUE SUPPLIED BY USER?\n         BNZ   CONVERT                  YES - AVOID STCK\n         SPACE 1\nTOD2     STCK  0(R4)                    GET CURRENT TOD CLOCK VALUE.\n         BZ    CONVERT                  CLOCK OPERATIVE? ... YES\n         SPACE 1\n         LA    R15,8                    NO - WARN USER\n*                                                                   Y2\n*\n*/*       SVC INVOCATIONS                                            */\n*/*         THE TIME OF DAY IS RETURNED IN R0 FOR DEC, BIN, AND      */\n*/*         TU. FOR MIC AND STCK, THE TIME OF DAY IS RETURNED        */\n*/*         IN THE SPECIFIED ADDRESS.                                */\n*/*         THE DATE IS RETURNED IN R1 AS PACKED DECIMAL IN THE      */\n*/*         FORM CCYYDDDF, WHERE:                                    */\n*/*              CC  - IS THE CENTURY                                */\n*/*              YY  - IS THE LAST TWO DIGITS OF THE YEAR            */\n*/*              DDD - IS THE DAY OF THE YEAR                        */\n*/*              F   - ALLOWS FOR UNPACKING                          */\n*/*                                                                  */\n*/*       PC INVOCATIONS                                             */\n*/*         THE TIME OF DAY IS RETURNED TO THE FIRST TWO WORDS OF    */\n*/*         A USER SPECIFIED FOURWORD AREA.  THE DATE IS RETURNED    */\n*/*         TO THE THIRD WORD IN DECIMAL FORMAT (NOT PACKED DECIMAL) */\n*/*         IN THE FORMS GIVEN BELOW.                                */\n*\n*\nTOD3     DS    0H                                                   RH\n         TIME  DEC,SAVETIME,            GET THE SYS TIME            Y2 +\n               LINKAGE=SYSTEM,DATETYPE=YYYYMMDD     IN THIS CASE    Y2\n         SR    R1,R1                    CLEAR R1                    Y2\n         IC    R1,SAVETIME+8            R1 = CENTURY FROM YYYY      Y2\n         SLL   R1,4                     MULT BY 16                  Y2\n         LA    R1,15(R1)                ADD SIGN                    Y2\n         XC    DOUBLE(8),DOUBLE         CLEAR DOUBLE                Y2\n         ST    R1,DOUBLE+4              STORE YEAR                  Y2\n         CVB   R1,DOUBLE                GET YEARS IN CENTURY        Y2\n         ST    R1,CENTURY               SAVE CENTURY                Y2\n         TIME  DEC                      GET THE SYS TIME IN R0-R1\n         ST    R1,DOUBLE                SAVE R1                     Y2\n         MVC   DOUBLE(1),SAVETIME+8     CHANGE 00YY TO YYYY         Y2\n         L     R1,DOUBLE                RELOAD R1                   Y2\n         B     GOTTIME                  GO WITH O.S. TIME & DATE\n*\nSAVETIME DC    XL16'00'                                             Y2\n*\n*\nCONVERT  L     R7,0(R4)                 HI-ORD WORD OF TOD CLOCK\n*\n* DROP HIGH ORDER BIT, WHICH IS 11.56.54, MAY 11, 1971              RH\n*\n         N     R7,=XL4'7FFFFFFF'        CLEAR HIGH ORDER BIT\n*\n*              CONVERT FROM TIMER UNITS TO SECONDS, WHERE\n*              1 TIMER UNIT IS 1.048576 SECONDS.\n*\n         M     R6,D16384                CONVERT FROM 1.048576 MIC-SEC\n         D     R6,D15625                DIVIDE TO GET SECONDS\n*\n* CALCULATE NUMBER OF DAYS SINCE 11.56.54, MAY 11, 1971             RH\n*\n         XR    R6,R6                    CLEAR REMAINDER\n*\n* WE HAVE CUT OFF HIGH BIT IN CLOCK WORD WHICH IS MAY 11 11.56.54   RH\n* SO ADD 11.56.54 BACK IN SECONDS                                   RH\n*\n         A     R7,=A(11*3600+56*60+54)\n         D     R6,D86400                DIV BY SEC/DAY TO GET DAY #\n         LR    R4,R6                    SAVE REM. SEC FOR TIME CALC\n         XR    R6,R6\n         D     R6,D1461                 DIV # DAYS BY #DAYS IN 4 YEARS\n         LR    R5,R7                    SAVE # 4 YEAR BLOCKS\n         SRDL  R6,32\n         D     R6,D365            GET # YEARS SINCE LEAP YEAR\n*                                 IN R7 AND DAY OF YEAR IN R6       RH\n*\n* WE HAVE CUT OFF HIGH BIT IN CLOCK WORD WHICH IS MAY 11 11.56.54   RH\n* SO ADD DAYS UP TO MAY 11 (130)  TO DAY OF YEAR                    RH\n*\n         LA    R6,130(0,R6)                                         RH\n         CH    R6,=H'365'         OVER 365?                         RH\n         BNH   DAYOK              NO                                RH\n         SH    R6,=H'365'         YES, SUBT 365 AND                 RH\n         LA    R7,1(0,R7)         ADD 1 TO THE YEAR                 RH\n         SPACE 1                                                    RH\nDAYOK    DS    0H                                                   RH\n         LA    R7,71(R7)                1971 IS FIRST YR OF CLOCK\n         SLL   R5,2               NBR YRS = 4(NBR 4 YR BLKS)\n         AR    R7,R5\n*\n*        PLACE RESULT JULIAN DATE IN REG 1 TO SIMULATE TIME MACRO.\n*\nSETR1    SR    R1,R1                    CLEAR REG\n         MH    R7,D10                   FROM X'072+' TO X'720+'\n         CVD   R7,DOUBLE\n         ICM   R1,4,DOUBLE+6            R1 = X'00720000'\n         CVD   R6,DOUBLE                CVD DAY OF YEAR\n         ICM   R1,3,DOUBLE+6            R1 = X'0072DDD+'\n         EJECT\n*\n*\n*\n*        CONVERT SECONDS TO HHMMSS AND PLACE IN REG 0 LIKE TIME MACRO.\n*\n         SR    R0,R0                    CLEAR RESULT REG\n         LR    R7,R4                    GET SAVED # SEC\n         SR    R6,R6\n         D     R6,D3600                 CALC # HOURS (3600 SEC/HR)\n         MH    R7,D10\n         CVD   R7,DOUBLE                PACK # HOURS\n         ICM   R0,8,DOUBLE+6            R0 = P'HH000000'\n         SRDL  R6,32                    SECONDS LEFT OVER (ABOVE HRS)\n         D     R6,D60                   CALC # MIN  (60 SEC/MIN)\n         MH    R7,D10\n         CVD   R7,DOUBLE                PACK # MIN\n         ICM   R0,4,DOUBLE+6            R0 = P'HHMM0000'\n         MH    R6,D10\n         CVD   R6,DOUBLE                PACK # SECONDS\n         ICM   R0,2,DOUBLE+6            R0 = P'HHMMSS00'\n         B     GOTTIME\n*\n*\nDOUBLE   DC    D'0'\nDOUBLE2  DC    D'0'                                                 RH\nSAVE     DS    18F\nSAVE05   DS    6F\nCENTURY  DC    F'19'                    PROGRAM ASSUMES 1900\nD16384   DC    F'16384'\nD15625   DC    F'15625'\nD86400   DC    F'86400'\nD366     DC    F'366'\nD1461    DC    F'1461'\nD365     DC    F'365'\nD3600    DC    F'3600'\nD60      DC    F'60'\nD10      DC    F'10'\n*\n*ZYEAR   DC    F'0'\n*ZMONTH  DC    F'0'\n*ZDAY    DC    F'0'\n*\n*MONTH   DC    F'0'\n*MONTH1  DC    F'0'\n*WEEKDAY DC    F'0'\n*WEEKDAYA DC    A(WEEKDAYS)\nSAVEDAY  DC    F'0'\nSAVEJUL  DC    F'0'\n*\nWEEKDAYS EQU   *\n*        DC    CL9'      '\n         DC    CL9'SUNDAY'\n         DC    CL9'MONDAY'\n         DC    CL9'TUESDAY'\n         DC    CL9'WEDNESDAY'\n         DC    CL9'THURSDAY'\n         DC    CL9'FRIDAY'\n         DC    CL9'SATURDAY'\n*\nLASTDAY  DC    H'366'                   NUMBER OF DAYS IN LEAP YEAR\n         DC    H'365'                   NUMBER OF DAYS IN NON-LEAP YEAR\nLASTMON  DC    C'DEC '\n         DC    H'335'             JULIAN DEC 1 IF NOT A LEAP YEAR\n         DC    H'334'             JULIAN DEC 1 IF     A LEAP YEAR\n         DC    C'NOV '\n         DC    H'305'\n         DC    H'304'\n         DC    C'OCT '\n         DC    H'274'\n         DC    H'273'\n         DC    C'SEP '\n         DC    H'244'\n         DC    H'243'\n         DC    C'AUG '\n         DC    H'213'\n         DC    H'212'\n         DC    C'JUL '\n         DC    H'182'\n         DC    H'181'\n         DC    C'JUN '\n         DC    H'152'\n         DC    H'151'\n         DC    C'MAY '\n         DC    H'121'\n         DC    H'120'\n         DC    C'APR '\n         DC    H'91'\n         DC    H'90'\n         DC    C'MAR '\n         DC    H'60'\n         DC    H'59'\n         DC    C'FEB '\n         DC    H'31'\n         DC    H'31'\n         DC    C'JAN '\n         DC    H'0'\n         DC    H'0'\n*\n*\n         AGO   .SKIP2\nDAYTAB   DC    F'0'               *DAYS IN YEAR TABLE FOR NORMAL YEACUL\n         DC    F'31'                                                CUL\n         DC    F'59'                                                CUL\n         DC    F'90'                                                CUL\n         DC    F'120'                                               CUL\n         DC    F'151'                                               CUL\n         DC    F'181'                                               CUL\n         DC    F'212'                                               CUL\n         DC    F'243'                                               CUL\n         DC    F'273'                                               CUL\n         DC    F'304'                                               CUL\n         DC    F'334'                                               CUL\n         DC    F'365'                                               CUL\nDAYTABLP DC    F'0'               *DAYS IN YEAR TABLE FOR LEAP YEAR CUL\n         DC    F'31'                                                CUL\n         DC    F'60'                                                CUL\n         DC    F'91'                                                CUL\n         DC    F'121'                                               CUL\n         DC    F'152'                                               CUL\n         DC    F'182'                                               CUL\n         DC    F'213'                                               CUL\n         DC    F'244'                                               CUL\n         DC    F'274'                                               CUL\n         DC    F'305'                                               CUL\n         DC    F'335'                                               CUL\n         DC    F'366'                                               CUL\n         AGO   .SKIP2\n.SKIP2   ANOP\n*\nTIMEPTRN DC    X'402120204B20204B2020'                              Y2\nDATEMASK DC    X'40212020204B202020'                                Y2\n*        DC    C'  '\n         DS    CL8                                                  Y2\nDDMASK   DC    X'40212020'                                          Y2\n         DC    C' '                                                 Y2\n         DS    CL1                                                  Y2\n*        DS    CL3                                                  Y2\n         DC    C' 19'\n         AGO   .YEARO\n*\n*              COMMON YEARS, 1995  - 2050\n*\nYEARTAB1 DS    0H\n         DC    CL30'1998 2026 2009 2037 2015 2043 '\nTAB1OFF  EQU   *-YEARTAB1\nINDXTAB1 DC    XL12'040707030501030602040702'\nLINDTAB1 EQU   *-INDXTAB1\n*\n         DC    CL30'1999 2027 2010 2038 2021 2049 '\n         DC    XL12'050101040602040703050103'\n*\n         DC    CL30'2005 2033 2011 2039 2022 2050 '\n         DC    XL12'060202050703050104060204'\n*\n         DC    CL30'2019 2047 2002 2030 2013 2041 '\n         DC    XL12'020505010306010407020507'\n*\n         DC    CL30'1997 2025 2003 2031 2014 2042 '\n         DC    XL12'030606020407020501030601'\n*\n         DC    CL30'1995 2023 2006 2034 2017 2045 '\n         DC    XL12'070303060104060205070305'\n*\n         DC    CL30'2001 2029 2007 2035 2018 2046 '\n         DC    XL12'010404070205070306010406'\n*\n*\n*              LEAP YEARS, 1996  - 2048\n*\nYEARTAB2 DS    0H\n         DC    CL10'2012 2040 '\nTAB2OFF   EQU    *-YEARTAB2\nINDXTAB2 DC    XL12'070304070205070306010406'\nLYRTAB2  EQU   *-YEARTAB2\nLINDTAB2 EQU   *-INDXTAB2\n*\n         DC    CL10'2016 2044 '\n         DC    XL12'050102050703050104060204'\n*\n         DC    CL10'2020 2048 '\n         DC    XL12'030607030501030602040702'\n*\n         DC    CL10'1996 2024 '\n         DC    XL12'010405010306010407020507'\n*\n         DC    CL10'2000 2028 '\n         DC    XL12'060203060104060205070305'\n*\n         DC    CL10'2004 2032 '\n         DC    XL12'040701040602040703050103'\n*\n         DC    CL10'2006 2036 '\n         DC    XL12'020506020407020501030601'\n*\n*              COMMON YEARS, 1800 - 2078\n*\nYEARTAB1 DS    0H\n         DC    C'1801 1829 1857 1885 1914 1942 197O 1998 2026 2054 '\n         DC    C'1807 1835 1863 1891 1925 1953 1981 2009 2037 2065 '\n         DC    C'1818 1646 1874 1903 1931 1959 1987 2015 2043 2071 '\nNBRYEAR1 EQU   (*-YEARTAB1)/5\nTAB1OFF  EQU   *-YEARTAB1\nINDXTAB1 DC    XL12'040707030501030602040702'\nLINDTAB1 EQU   *-INDXTAB1\n*\n         DC    C'1802 1830 1858 1886 1915 1943 1971 1999 2027 2055 '\n         DC    C'1813 1841 1869 1897 1926 1954 1982 2010 2038 2066 '\n         DC    C'1819 1847 1975 1909 1937 1965 1993 2021 2049 2077 '\n         DC    XL12'050101040602040703050103'\n*\n         DC    C'1803 1831 1859 1887 1921 1949 1977 2005 2033 2061 '\n         DC    C'1814 1842 1870 1898 1927 1955 1983 2011 2039 2067 '\n         DC    C'1825 1853 1881 1910 1938 1966 1994 2022 2050 2078 '\n         DC    XL12'060202050703050104060204'\n*\n         DC    C'1805 1833 1861 1889 1907 1935 1963 1991 2019 2047 '\n         DC    C'1811 1839 1867 1895 1918 1946 1974 2002 2030 2058 '\n         DC    C'1822 1850 1878 1901 1929 1957 1985 2013 2041 2069 '\n         DC    XL12'020505010306010407020507'\n*\n         DC    C'1800 1823 1851 1879 1913 1941 1869 1997 2025 2053 '\n         DC    C'1806 1834 1862 1890 1919 1947 1975 2003 2031 2059 '\n         DC    C'1817 1845 1873 1902 1930 1958 1966 2014 2042 2070 '\n         DC    XL12'030606020407020501030601'\n*\n         DC    C'1809 1837 1865 1893 1911 1939 1967 1995 2023 2051 '\n         DC    C'1815 1843 1871 1899 1922 1950 1978 2006 2034 2062 '\n         DC    C'1826 1854 1882 1905 1933 1961 1989 2017 2045 2073 '\n         DC    XL12'070303060104060205070305'\n*\n         DC    C'1810 1838 1866 1894 1917 1945 1973 2001 2029 2057 '\n         DC    C'1821 1849 1877 1900 1923 1951 1979 2007 2035 2062 '\n         DC    C'1827 1855 1883 1906 1934 1962 1990 2018 2046 2074 '\n         DC    XL12'010404070205070306010406'\n*\n*              LEAP YEARS, 1804  - 2068\n*\nYEARTAB2 DS    0H\n         DC    C'1804 1832 1860 1888 1928 1956 1984 2012 2040 2068 '\nNBRYEAR2 EQU   (*-YEARTAB2)/5\nTAB2OFF  EQU   *-YEARTAB2\nINDXTAB2 DC    XL12'070304070205070306010406'\nLYRTAB2  EQU   *-YEARTAB2\nLINDTAB2 EQU   *-INDXTAB2\n*\n*\n         DC    C'1808 1836 1864 1892 1904 1932 1960 1988 2016 2044 '\n         DC    XL12'050102050703050104060204'\n*\n         DC    C'1812 1840 1868 1896 1908 1936 1964 1992 2020 2048 '\n         DC    XL12'030607030501030602040702'\n*\n         DC    C'1816 1844 1872 1912 1940 1968 1996 2024 2024 2052 '\n         DC    XL12'010405010306010407020507'\n*\n         DC    C'1820 1848 1976 1916 1944 1972 2000 2028 2028 2056 '\n         DC    XL12'060203060104060205070305'\n*\n         DC    C'1824 1852 1880 1920 1948 1976 2004 2032 2032 2060 '\n         DC    XL12'040701040602040703050103'\n*\n         DC    C'1828 1856 1884 1924 1952 1980 2008 2036 2036 2064 '\n         DC    XL12'020506020407020501030601'\n*\n*\n*              DAY OF MONTH TO DAY OF WEEK TABLE\n*\n*              DAY OFFSET = REMAINDER OF DAY-OF-MONTH/7\n*\n         DS    0H\nDAYTABOF DC    AL2(LDAYTAB)\nDAYTAB1  DS    0H\n         DC    1CL9'         '    FOR OFFSET 0.....\n         DC    CL45'MONDAY   TUESDAY  WEDNESDAYTHURSDAY FRIDAY   '\n         DC    CL18'SATURDAY SUNDAY   '\nLDAYTAB  EQU   *-DAYTAB1\n*\nDAYTAB2  DS    0H\n         DC    1CL9'         '    FOR OFFSET 0.....\n         DC    CL45'TUESDAY  WEDNESDAYTHURSDAY FRIDAY   SATURDAY '\n         DC    CL18'SUNDAY   MONDAY   '\n*\nDAYTAB3  DS    0H\n         DC    1CL9'         '    FOR OFFSET 0.....\n         DC    1CL9'WEDNESDAY'\n         DC    CL45'THURSDAY FRIDAY   SATURDAY SUNDAY   MONDAY   '\n         DC    CL09'TUESDAY  '\n*\nDAYTAB4  DS    0H\n         DC    1CL9'         '    FOR OFFSET 0.....\n         DC    CL45'THURSDAY FRIDAY   SATURDAY SUNDAY   MONDAY   '\n         DC    CL18'TUESDAY  WEDNESDAY'\n*\nDAYTAB5  DS    0H\n         DC    1CL9'         '    FOR OFFSET 0.....\n         DC    CL45'FRIDAY   SATURDAY SUNDAY   MONDAY   TUESDAY  '\n         DC    CL18'WEDNESDAYTHURSDAY '\n*\nDAYTAB6  DS    0H\n         DC    1CL9'         '    FOR OFFSET 0.....\n         DC    CL45'SATURDAY SUNDAY   MONDAY   TUESDAY  WEDNESDAY'\n         DC    CL18'THURSDAY FRIDAY   '\n*\nDAYTAB7  DS    0H\n         DC    1CL9'         '    FOR OFFSET 0.....\n         DC    CL45'SUNDAY   MONDAY   TUESDAY  WEDNESDAYTHURSDAY '\n         DC    CL18'FRIDAY   SATURDAY '\n*\nDAYTABA  DS    0H\n*        DC    1CL9'         '    FOR OFFSET 0.....\n*        DC    5CL9'MONDAY   TUESDAY  WEDNESDAYTHURSDAY FRIDAY   '\n*        DC    5CL9'SATURDAY SUNDAY   MONDAY   TUESDAY  WEDNESDAY'\n*        DC    5CL9'THURSDAY FRIDAY   SATURDAY SUNDAY   MONDAY   '\n*        DC    5CL9'TUESDAY  WEDNESDAYTHURSDAY FRIDAY   SATURDAY '\n*        DC    5CL9'SUNDAY   MONDAY   TUESDAY  WEDNESDAYTHURSDAY '\n*        DC    5CL9'FRIDAY   SATURDAY SUNDAY   MONDAY   TUESDAY  '\n*        DC    1CL9'WEDNESDAY'\n*\n.YEARO   ANOP\n         LTORG\n*\n*              FELDMASK OVERLAYS THE 40 BYTE WORKAREA PASSED TO US\n*              BY THE CALLING PROGRAM\n*\nFELDMASK DSECT\nTIMEDATE DS    0C\nHHMMSS   DS    CL8\n         DS    CL1                                                  Y2\nYYYYDDD  DS    CL8                                                  Y2\n         DS    CL2\nDAY      DS    CL9\n         DS    CL1\nDD       DS    CL2\n         DS    CL1\nMON      DS    CL3\n         DS    CL1                                                  Y2\nYEAR     DS    CL4                                                  Y2\n*\nDDSECT   DSECT\n         DS    16F    RESERVE FOR PLI\n*\n*        STANDARD EQUATES AND REGISTER USAGE\n*\n*\nR0       EQU   0                        BINARY DAY OF YEAR OR DAY OF MO\nR1       EQU   1                        BINARY YEAR OF CENTURY\nR2       EQU   2                        PTR TO EBCDIC MONTH\nR3       EQU   3\nR4       EQU   4                        WORK REGISTER\nR5       EQU   5                        BINARY MONTH OF YEAR\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10                       PGM BASE REG\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13                       SAVE AREA PTR\nR14      EQU   14                       RETURN ADDRESS\nR15      EQU   15                       RETURN CODE REGISTER\n*        EJECT\n         END\n/*\n//*\n//*\n//LKED.SYSLMOD DD DSN=IMSVS.AUTHLIB1,DISP=SHR\n//LKED.SYSIN DD *\n*  ALIAS DAYDAT\n   ENTRY DAYDATE\n   SETCODE AC(1)          IF CALLED FROM AN AUTH'D LIB/MODULE\n   NAME DAYDATE(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELMEMS": {"ttr": 7940, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x12I\\x05\\x17\\x05\\x17\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T12:49:00", "lines": 1303, "newlines": 1303, "modlines": 0, "user": "RH87944"}, "text": "//DELMEMS  JOB\n//*\n//*    DSN=CBT.SOURCE(DELMEMS)\n//*\n/*ROUTE PRINT R7\n//*\n//*\n//DELMEMS EXEC HLASMCL,\n//             MAC='SYS1.AMODGEN',\n//             PARMC='ALIGN,NORLD,XREF',\n//             CLASS='*',COND.LKED=(7,LT,ASM)\n//ASM.SYSIN DD *\nDELMEMS  TITLE 'DELETE LIST OF MEMBERS FROM PDS'\n*\n***********************************************************************\n*                                                                     *\n*             MODULE NAME = DELMEMS                                   *\n*                                                                     *\n*             DESCRIPTIVE NAME =  PROGRAM TO DELETE LIST OF MEMBER    *\n*                NAMES FROM A PDS.                                    *\n*                                                                     *\n*             COPYRIGHT = DIVERSIFIED DEVELOPMENTS, VICTORIA          *\n*                                                                     *\n*             STATUS = RELEASE 01.0                                   *\n*                                                                     *\n*             FUNCTION =                                              *\n*                READS SYSIN TO GET A LIST OF MEMBER NAMES TO BE      *\n*                DELETED FROM THE PARTITIONED DATASET IN //PDS.       *\n*                                                                     *\n*                OPERATION =                                          *\n*                   READ SYSIN.                                       *\n*                   READ PDS DIRECTORY AND COMPARE MEMBER NAME FROM   *\n*                   SYSIN TO MEMBER NAME FROM DIRECTORY.              *\n*                   IF MEMBER NAME MEETS CRITERIA, IT WILL BE         *\n*                   DELETED.                                          *\n*                   LIST MEMBER NAMES DELETED.                        *\n*                   PROCESS NEXT SYSIN RECORD.                        *\n*                   AT END OF LIST CLOSE DATASETS AND FREE ANY        *\n*                      AQUIRED AREAS.S.                               *\n*                                                                     *\n*              NOTES =                                                *\n*                                                                     *\n*                 DEPENDENCIES = CHARACTER SET IS EBCDIC.  REASSEMBLE *\n*                    IF A DIFFERENT CHARACTER SET IS NEEDED.          *\n*                                                                     *\n*                 RESTRICTIONS = DATASETS MUST HAVE LRECL LESS THAN   *\n*                    255 AND MUST BE EITHER FIXED OR VARIABLE FORMAT. *\n*                                                                     *\n*                 REGISTER CONVENTIONS = STANDARD CONVENTIONS.        *\n*                    REGISTERS 0 TO 10 = WORK REGISTERS               *\n*                    REGISTER  11      = SECOND BASE REGISTER         *\n*                    REGISTER  12      = ADDRESSABILITY TO DELMEMS    *\n*                                        CSECT                        *\n*                    REGISTER  13      = SAVE AREA REGISTER AND       *\n*                                        ADDRESSABILITY TO GETMAINED  *\n*                                        WORK AREA                    *\n*                    REGISTERS 14,15   = WORK REGISTERS               *\n*                                                                     *\n*                SYSIN SYNTAX = - MEMBER NAME, OR                     *\n*                               - PARTIAL MEMBER NAME* TO DELETE      *\n*                                 ALL MEMBERS IN GROUP, OR            *\n*                               - MEMBER NAME-MEMBER NAME TO DELETE   *\n*                                 ALL MEMBERS IN GROUP, OR            *\n*                               - PARTIAL MBR NAME-PARTIAL MBR NAME   *\n*                                 TO DELETE ALL MEMBERS IN GROUP      *\n*                                                                     *\n*             MODULE TYPE = PROCEDURE                                 *\n*                                                                     *\n*                PROCESSOR = ASM                                      *\n*                                                                     *\n*                MODULE SIZE = 5K BYTES                               *\n*                                                                     *\n*                ATTRIBUTES = SCHEDULER KEY 8, NON-REENTRANT,         *\n*                   PROBLEM PROGRAM STATE                             *\n*                                                                     *\n*             ENTRY POINTS = DELMEMS (ONLY ENTRY POINT)               *\n*                                                                     *\n*                LINKAGE =                                            *\n*                   FROM SYSTEM                                       *\n*                                                                     *\n*             INPUT = MEMBER NAMES IN SYSIN                           *\n*                                                                     *\n*             OUTPUT = LIST OF DELETED MEMBERS                        *\n*                                                                     *\n*             EXIT - NORMAL = AT PROGRAM END VIA BRANCH REGISTER 14   *\n*                                                                     *\n*                OUTPUT = LIST OF DELETED MEMBERS                     *\n*                                                                     *\n*                RETURN CODE = ZERO                                   *\n*                                                                     *\n*             EXIT - ERROR = NONE - PROGRAM WILL DISPLAY DECIMAL      *\n*                RETURN CODE AND RETURN VIA BRANCH REGISTER 14        *\n*                                                                     *\n*                OUTPUT = NONE                                        *\n*                                                                     *\n*                RETURN CODE = ZERO                                   *\n*                                                                     *\n*             EXTERNAL REFERENCES =                                   *\n*                                                                     *\n*                ROUTINES = NONE?                                     *\n*                                                                     *\n*                DATA AREAS = NONE                                    *\n*                                                                     *\n*                CONTROL BLOCKS = DCB, RDJFCB, ETC.                   *\n*                                                                     *\n*             TABLES = DATA AREA TO BE GETMAINED.  MAPPED BY DSECT    *\n*                BEGINNING AT LABEL RDATD.                            *\n*                                                                     *\n*             MACROS = SAVE, GETMAIN, FREEMAIN,                       *\n*                   OPEN, PUT, GET, CLOSE, RDJFCB,                    *\n*                   DCB, DCBD                                         *\n*                                                                     *\n*             CHANGE ACTIVITY = NONE                                  *\n*                                                                     *\n*             MESSAGES =                                              *\n*                                                                     *\n*                THOSE ISSUED BY THE PROGRAM ARE FOUND FOLLOWING THE  *\n*                LABEL GNRLERR AND ARE ISSUED USING PUT.              *\n*                                                                     *\n*             ABEND CODES = NONE                                      *\n*                                                                     *\n***********************************************************************\n*\nDELMEMS  CSECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SAVE  (14,12),,DELMEMS.&SYSDATE.&SYSTIME SAVE REGISTERS\n         LR    R12,R15                 LOAD REGISTER 12 WITH ENTRY\n*                                      ADDRESS\n         USING DELMEMS,R12             ESTABLISH ADDRESSABILITY TO\n*                                      PROGRAM CSECT\n         LA    R11,4095(R12)           LOAD REGISTER 11 WITH ENTRY\n*                                      ADDRESS 4095\n         USING DELMEMS+4095,R11        ESTABLISH ADDRESSABILITY TO THE\n*                                      REST OF THE PROGRAM CSECT\n         LR    R8,R1                   LOAD REGISTER 8 TO PRESERVE\n*                                      POINTER TO COMMAND PROCESSOR\n*                                      PARAMETER LIST\n         GETMAIN R,LV=LDYNAMIC         GETMAIN DYNAMIC WORKAREA\n         LR    R10,R1                  LOAD REGISTER 10 TO PRESERVE\n*                                      POINTER TO WORKAREA\n         ST    R13,4(R10)              STORE ADDRESS OF PREVIOUS\n*                                      SAVEAREA\n         ST    R10,8(,R13)             STORE ADDRESS OF CURRENT\n*                                      SAVEAREA IN PREVIOUS SAVEAREA\n         LR    R13,R10                 LOAD REGISTER 13 WITH ADDRESS OF\n*                                      CURRENT SAVEAREA\n         USING WORKAREA,R13            ESTABLISH ADDRESSABILITY TO\n*                                      DYNAMIC WORKAREA\n*\n***********************************************************************\n*                                                                     *\n*        SEE IF A PARM WAS PASSED....                                 *\n*                                                                     *\n***********************************************************************\n*\n         L     R8,0(0,R8)         R8 -> TO PARM\n         LH    R1,2(0,R8)         R1 = PARM LTH\n         LTR   R1,R1              IS THERE A PARM?\n         BZ    NOPARM             NO\n         CLC   =X'0A15',STOWDEL+8 FIND SVC 21?\n         BE    ZAPSVC             YES\n         ABEND 21,,,USER          NO, ABEND\n         SPACE 1\nZAPSVC   MVC   STOWDEL+8(2),=X'1BFF'  CHANGE SVC TO SR 15,15\n         MVC   HEADER3W,=C'WOULD  BE '  CHANGE MSG 1\n         MVC   NOTDEL,=C'NOT '          CHANGE MSG 2\n*\n***********************************************************************\n*                                                                     *\n*        INITIALIZE OUTPUT DATA CONTROL BLOCKS IN WORKAREA            *\n*                                                                     *\n***********************************************************************\n*\nNOPARM   DS    0H\n         MVC   OUTPUTA(OUTPUTAL),OUTPUTAC  MOVE ASA DCB CONSTANT INTO\n*                                      ASA DCB IN WORKAREA\n*        MVC   OUTPUTM(OUTPUTML),OUTPUTMC  MOVE MACHINE DCB CONSTANT\n*                                      INTO MACHINE DCB IN WORKAREA\n*\n         OPEN  (SYSIN,(INPUT))    OPEN INPUT DCB\n         LA    R14,SCROLLIT       SET R14 FOR 1ST TIME THRU\n         SPACE 1\nREADSYS  DS    0H\n         STM   R0,R15,SAVEALL     SAVE ALL REGS\n         GET   SYSIN,MBRNAME           GET INPUT RECORD\n         LA    R1,MBRNAME         R1 -> TO INPUT DATA\n         LA    R2,MBRNAME         R2 -> TO INPUT DATA\n         SPACE 1\n         MVC   STARTMBR,BLANKS    CLEAR START MBR NAME\n         MVC   ENDMBR,BLANKS      CLEAR END MEMBER NAME\n         MVI   MBRTYPE,C' '       CLEAR FLAG BYTE\n         XC    SMBRLTH,SMBRLTH    CLEAR START MBR LTH\n         XC    EMBRLTH,EMBRLTH    CLEAR END MEMBER LTH\n         XC    WILDSLTH,WILDSLTH  CLEAR NBR WILD CHARS (BACKSLASH)\n         XC    WILDELTH,WILDELTH  CLEAR NBR WILD CHARS (BACKSLASH)\n         SPACE 1\nCHKBYTE  DS    0H\n         CLI   0(R2),C' '         AT END OF DATA ?\n         BE    END1               YES\n         CLI   0(R1),C'A'         IF 1ST CHAR IS NOT ALPHA,\n         BL    NXTBYTE            THIS MUST BE AN IMS FORMAT LIB\n         CLI   0(R2),C'\\'         FIND WILD CHAR ?\n         BE    GOTWILD            YES\n         CLI   0(R2),C'*'         FIND * ?\n         BE    GOTAST             YES\n         CLI   0(R2),C'-'         FIND - ?\n         BE    GOTDASH            YES\n         SPACE 1\nNXTBYTE  DS    0H\n         LA    R2,1(0,R2)         R2 -> TO NEXT DATA CHAR\n         B     CHKBYTE            GO CHECK IT\n         SPACE 1\nEND1     DS    0H\n         LR    R3,R2              SAVE R2\n         SR    R2,R1              R2 = LTH OF DATA\n         CH    R2,=H'8'           OVER 8?\n         BH    BADATA             YES\n         SPACE 1\n*        CLI   MBRTYPE,C'-'       ARE WE PROCESSING 2ND MEMBER NAME ?\n*        BE    GOTDASH2           YES\n*        STH   R2,SMBRLTH         SAVE MBR LTH\n         MVI   EMBRLTH+1,8        SET END MBR LTH TO 8\n         BCTR  R2,0               R2 = HEX LTH\n         STC   R2,MOVE1+1         SAVE MBR NAME LTH\nMOVE1    MVC   ENDMBR(0),0(R1)    SAVE END MBR NAME\n*OVE1    MVC   STARTMBR(0),0(R1)  SAVE START MBR NAME\n         CLI   SMBRLTH+1,0        IS THERE A START MEMBER?\n         BH    ENDREAD            YES, ON WE GO\n         MVC   STARTMBR,ENDMBR    NO, SET UP START MBR NAME\n         MVI   SMBRLTH+1,8        SET START MBR LTH TO 8\n         B     ENDREAD            ON WE GO\n         SPACE 1\nGOTWILD  DS    0H\n         CLI   MBRTYPE,C' '       ARE WE PROCESSING 2ND MEMBER NAME ?\n         BNE   GOTWILD1           YES\n         LH    R4,WILDSLTH        R4 = NBR START WILD CARDS\n         LA    R4,1(0,R4)         ADD 1\n         STH   R4,WILDSLTH        SAVE NBR\n         B     NXTBYTE            GO CHECK NEXT BYTE...\n         SPACE 1\nGOTWILD1 DS    0H\n         LH    R4,WILDELTH        R4 = NBR START WILD CARDS\n         LA    R4,1(0,R4)         ADD 1\n         STH   R4,WILDELTH        SAVE NBR\n         B     NXTBYTE            GO CHECK NEXT BYTE...\n         SPACE 1\nGOTAST   DS    0H\n         CLI   MBRTYPE,C' '       ARE WE PROCESSING 2ND MEMBER NAME ?\n         BNE   GOTAST1            YES\n         MVI   MBRTYPE,C'*'       SAY WE GOT * TYPE\n         SPACE 1\nGOTAST1  DS    0H\n         LR    R3,R2              SAVE R2\n         SR    R2,R1              R2 = LTH OF DATA\n         CH    R2,=H'8'           OVER 8?\n         BH    BADATA             YES\n         SPACE 1\n         CLI   SMBRLTH+1,0        IS THERE A START MEMBER?\n         BH    GOTAST2            YES, ON WE GO\n         STH   R2,SMBRLTH         SAVE MBR LTH\n         BCTR  R2,0               R2 = HEX LTH\n         STC   R2,MOVE2+1         SAVE MBR NAME LTH\nMOVE2    MVC   STARTMBR(0),0(R1)  SAVE START MBR NAME\n         CLI   1(R3),C'-'         NEXT CHAR DASH(-) ?\n         BE    GOTEND1            YES\n         MVC   ENDMBR,STARTMBR    SET UP END MBR NAME\n         MVC   EMBRLTH,SMBRLTH    SET END MBR LTH\n         B     ENDREAD            ON WE GO\n         SPACE 1\nGOTEND1  DS    0H\n         LA    R1,2(0,R3)         R1 -> TO SECOND MEMBER\n         LR    R2,R1              R2 -> TO SECOND MEMBER\n         B     CHKBYTE            GO CHECK SECOND MEMBER NAME\n         SPACE 1\nGOTAST2  DS    0H\n         STH   R2,EMBRLTH         SET END MBR LTH\n         BCTR  R2,0               R2 = HEX LTH\n         STC   R2,MOVE2A+1        SAVE MBR NAME LTH\nMOVE2A   MVC   ENDMBR(0),0(R1)    SAVE END MBR NAME\n         B     ENDREAD            ON WE GO\n         SPACE 1\nGOTDASH  DS    0H\n         MVI   MBRTYPE,C'-'       SAY WE GOT - TYPE\n         LR    R3,R2              SAVE R2\n         SR    R2,R1              R2 = LTH OF DATA\n         CH    R2,=H'8'           OVER 8?\n         BH    BADATA             YES\n         SPACE 1\n*        STH   R2,SMBRLTH         SAVE MBR LTH\n         BCTR  R2,0               R2 = HEX LTH\n         STC   R2,MOVE3+1         SAVE MBR NAME LTH\nMOVE3    MVC   STARTMBR(0),0(R1)  SAVE START MBR NAME\n         MVI   SMBRLTH+1,8        SET START MBR LTH TO 8\n         LA    R1,1(0,R3)         R1 -> TO SECOND MEMBER\n         LR    R2,R1              R2 -> TO SECOND MEMBER\n         B     CHKBYTE            GO CHECK SECOND MEMBER NAME\n         SPACE 1\nGOTDASH2 DS    0H\n         LR    R3,R2              SAVE R2\n         STH   R2,EMBRLTH         SAVE MBR LTH\n         BCTR  R2,0               R2 = HEX LTH\n         STC   R2,MOVE4+1         SAVE MBR NAME LTH\nMOVE4    MVC   ENDMBR(0),0(R1)    SAVE END MBR NAME\n*        B     ENDREAD            ON WE GO\n         SPACE 1\nENDREAD  DS    0H\n         LM    R0,R15,SAVEALL     RELOAD ALL REGS\n         BR    R14                RETURN TO CALLER\n         SPACE 1\nBADATA   DS    0H\n         ABEND 999\n*\nEOFREAD  DS    0H\n         CLOSE (SYSIN)                 CLOSE INPUT DCB\n         MVI   STARTMBR,X'FF'     SIGNAL END OF SYSIN\n         B     ENDREAD            RETURN TO CALLER\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        OPEN THE DIRECTORY OF THE PDS                                *\n*                                                                     *\n***********************************************************************\n*\nSCROLLIT DS    0H\n         CLI   STARTMBR,X'FF'     END OF SYSIN?\n         BE    RETURN             YES, JUST RETURN\n*        ST    R6,SAVER6               SAVE REGISTER 6\n         LA    R8,DIRECT               LOAD POINTER TO DIRECTORY DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         MVC   DIRECT(DIRECTL),DIRECTC MOVE DIRECTORY DCB CONSTANT INTO\n*                                      DIRECTORY DCB IN WORKAREA\n         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO OPEN LIST IN WORKAREA\n         OPEN  ((R8),INPUT),MF=(E,OPENLST)  OPEN DIRECTORY DCB\n         TM    DCBOFLGS,DCBOFOPN       SEE IF DCB OPENED SUCCESSFULLY\n         BNO   NOTPMESS                NO.....GO PUT OUT NOT PRINTED\n*                                      MESSAGE\n         DROP  R8                      DROP ADDRESSABILITY TO DCB\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        GETMAIN MEMBER TABLE FOR STORAGE OF DIRECTORY NAMES, ETC.    *\n*           INITIALIZE TABLE                                          *\n*                                                                     *\n***********************************************************************\n*\n         L     R0,MEMDATL              LOAD LENGTH OF GETMAIN FOR\n*                                      MEMBER TABLE\n         LR    R2,R0                   SAVE IN REGISTER 2\n         GETMAIN R,LV=(0)              GETMAIN MEMBER TABLE STORAGE\n         ST    R1,MEMTABLE             SAVE ADDRESS OF MEMBER TABLE\n         ST    R1,PRESENT              ALSO SAVE ADDRESS AS TABLE\n*                                      IN USE\n         LA    R3,0(R2,R1)             LOAD ADDRESS OF END OF TABLE\n         ST    R3,ENDTABLE             STORE ADDRESS OF TABLE END\n         SLR   R4,R4                   ZERO REGISTER 4\n         ST    R4,0(R1)                STORE AS FIRST WORD OF MEMBER\n*                                      TABLE\n         LA    R4,8(R1)                LOAD REGISTER 4 AS POINTER TO\n*                                      THE FIRST ENTRY\n         USING MEMDSECT,R4             ESTABLISH ADDRESSABILITY TO\n*                                      MEMBER TABLE DSECT\n         SLR   R5,R5                   INITIALIZE MEMBER COUNT TO ZERO\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        READ DIRECTORY AND BUILD MEMBER TABLE                        *\n*                                                                     *\n***********************************************************************\n*\nGETDIR   EQU   *\n         GET   (R8),DATA               GET A DIRECTORY BLOCK\n         CLC   DATA(2),HALF12          SEE IF BLOCK IS UNUSED\n         BL    FREEBLK                 YES....GO HANDLE DIRECTORY END\n         LA    R9,DATA+2               LOAD POINTER TO FIRST DIRECTORY\n*                                      ENTRY\n         SLR   R7,R7                   ZERO REGISTER 7 FOR INSERT\n         ICM   R7,3,DATA               INSERT LENGTH USED OF THIS BLOCK\n         LA    R7,DATA-1(R7)           LOAD LAST USED BYTE OF BLOCK\nUNBLOCK  DS    0H\n         MVC   MEMNTTR,0(R9)           PUT NAME AND TTR IN TABLE\n         MVC   CFIELD,11(R9)           PUT C FIELD IN TABLE\n         CLI   MEMBER,HEXFF            SEE IF LAST MEMBER\n         BE    FREEBLK                 YES....GO HANDLE DIRECTORY END\n         IC    R6,CFIELD               INSERT CFIELD INTO REGISTER 6\n         SLL   R6,27                   SHIFT OUT HIGH ORDER BITS\n         SRL   R6,26                   SHIFT RIGHT TO GET LENGTH OF\n*                                      USER DATA\n         LA    R6,12(R6)               ADD STANDARD ENTRY LENGTH\n         SPACE 1\n         LH    R1,SMBRLTH         R1 = START MEMBER NAME LTH\n         LH    R14,WILDSLTH       R14 = NBR WILD CHARS IN START MBR\n         LTR   R14,R14            ARE THERE ANY?\n         BZ    NOWILDS            NO\n         LA    R14,STARTMBR       R14 -> TO START MBR NAME\n         LA    R10,STARTMBR       R10 -> TO END   MBR NAME\n         LA    R15,MEMBER         R15 -> TO DIR MEMBER NAME\n         SPACE 1\nCHKWILD1 DS    0H\n         CLI   0(R14),C'\\'        WILD CARD?\n         BNE   CHKWILD3           NO\n         SPACE 1\nCHKWILD2 DS    0H\n         LA    R14,1(0,R14)       ADD 1 TO R14\n         LA    R10,1(0,R10)       ADD 1 TO R10\n         LA    R15,1(0,R15)       ADD 1 TO R15\n         BCT   R1,CHKWILD1        CHECK FOR MORE....\n         B     NOTWANT            DELETE THIS MEMBER...\n         SPACE 1\nCHKWILD3 DS    0H\n         CLC   0(1,R15),0(R14)    IS THIS A CHAR WE WANT ?\n         BL    NEXTNTRY           NO\n         CLC   0(1,R15),0(R10)    IS THIS A CHAR WE WANT ?\n         BH    NEXTNTRY           NO, BUT CHECK ALL MEMBERS....\n*        BH    GETMBR             NO\n         B     CHKWILD2           YES, CHECK NEXT BYTE...\n         SPACE 1\nNOWILDS  DS    0H\n         BCTR  R1,0               R1 = HEX LTH\n         STC   R1,CLC1+1          PUT IT IN CLC INST\nCLC1     CLC   MEMBER,STARTMBR    DO WE WANT THIS MEMBER?\n*LC1     CLC   0(0,R9),STARTMBR   DO WE WANT THIS MEMBER?\n         BL    NEXTNTRY           NO\n         SPACE 1\n         LH    R1,EMBRLTH         R1 = END MEMBER NAME LTH\n         BCTR  R1,0               R1 = HEX LTH\n         STC   R1,CLC2+1          PUT IT IN CLC INST\nCLC2     CLC   MEMBER,ENDMBR      DO WE WANT THIS MEMBER?\n*LC2     CLC   0(0,R9),ENDMBR     DO WE WANT THIS MEMBER?\n         BH    GETMBR             NO\n         B     NOTWANT            YES, ON WE GO\n         SPACE 1\nGETMBR   DS    0H\n         BAL   R14,READSYS        GO GET NEXT SYSIN CONTROL CARD\n         CLI   STARTMBR,X'FF'     END OF SYSIN?\n         BE    FREEBLK            YES, GO HANDLE DIRECTORY END\n         B     UNBLOCK            NO, SEE IF WE WANT IT/THEM\n         SPACE 1\nNOTWANT  DS    0H\n         LA    R4,MEMSECTN        LOAD POINTER TO NEXT TABLE ENTRY\n         LA    R5,1(R5)                INCREMENT NUMBER OF MEMBERS IN\n*                                      TABLE\n         C     R4,ENDTABLE             SEE IF END OF TABLE\n         BL    NEXTNTRY                LOW.....GO PROCESS NEXT ENTRY\n         LR    R0,R2                   LOAD LENGTH OF TABLE FOR GETMAIN\n         GETMAIN R,LV=(0)              GET NEXT TABLE\n         L     R14,PRESENT             LOAD REGISTER 14 WITH ADDRESS OF\n*                                      LAST TABLE\n         ST    R1,0(R14)               CHAIN MEMBER TABLES TOGETHER\n         ST    R1,PRESENT              ALSO SAVE ADDRESS AS TABLE\n*                                      IN USE\n         LA    R3,0(R2,R1)             LOAD ADDRESS OF TABLE END\n         ST    R3,ENDTABLE             STORE ADDRESS OF TABLE END\n         SLR   R4,R4                   ZERO REGISTER 4\n         ST    R4,0(R1)                STORE AS FIRST WORD OF MEMBER\n*                                      TABLE\n         LA    R4,8(R1)                LOAD REGISTER 4 AS POINTER TO\n*                                      THE FIRST ENTRY\n         STH   R5,4(R14)               STORE MEMBER COUNT IN OLD TABLE\n         SLR   R5,R5                   INITIALIZE MEMBER COUNT TO ZERO\nNEXTNTRY DS    0H\n         BXLE  R9,R6,UNBLOCK           INCREMENT REGISTER 9 WITH\n*                                      REGISTER 6 AND BRANCH\n*                                      LESS THAN OR EQUAL TO\n*                                      REGISTER 7 TO UNBLOCK\n         B     GETDIR                  NO.....GO GET NEXT DIRECTORY\n*                                      BLOCK\n         DROP  R4                      DROP ADDRESSABILITY TO TABLE\n*\n***********************************************************************\n*                                                                     *\n*        CLOSE PDS DIRECTORY                                          *\n*        OPEN SYSPRINT DCB                                            *\n*        OPEN PDS DATASET FOR OUTPUT WITH A MEMBER NAME OF 99999999   *\n*        LIST MEMBERS IF:                                             *\n*           LIST SPECIFIED OR                                         *\n*           BOTH PRINT AND NOLIST WERE NOT SPECIFIED                  *\n*                                                                     *\n***********************************************************************\n*\nFREEBLK  DS    0H\n         MVC   OPENLST,OPENCLOS        MOVE CONSTANT INTO CLOSE LIST\n         CLOSE ((R8),),MF=(E,OPENLST)  CLOSE DIRECTORY DCB\n         L     R2,PRESENT              LOAD POINTER TO LAST TABLE\n         STH   R5,4(R2)                STORE COUNT OF MEMBERS\n         L     R4,MEMTABLE             LOAD POINTER TO FIRST TABLE\n         CLC   4(2,R4),HALF0           SEE IF THERE WERE ANY MEMBERS\n         BE    ENDMEMB                 ZERO...GO FREE MEMBER TABLE\n         LA    R8,INPUT                LOAD POINTER TO INPUT DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         MVC   INPUT(INPUTL),INPUTC    MOVE INPUT DCB CONSTANT INTO\n*                                      INPUT DCB IN WORKAREA\n         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO OPEN LIST IN WORKAREA\n         LA    R1,XLIST                LOAD ADDRESS OF EXIT LIST\n         ST    R1,DCBEXLST             STORE ADDRESS OF EXIT LIST IN\n*                                      DCB\n         LA    R2,JFCBAREA             LOAD ADDRESS OF JFCBAREA\n         ST    R2,XLIST                STORE ADDRESS IN EXIT LIST\n         MVI   XLIST,X'87'             SET END OF LIST AND JFCB BYTE\n         MVC   RDJL,OPENCLOS           MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO READJFCB LIST IN\n*                                      WORKAREA\n         RDJFCB ((8),),MF=(E,RDJL)   READ JFCB INTO JFCBAREA\n         MVC   JFCBELNM,=C'99999999'   MOVE MEMBER NAME INTO JFCB\n         OI    JFCBIND1,JFCPDS         SET JFCB TO INDICATE PDS MEMBER\n         MVI   JFCDSRG1,HEX00          SET JFCB TO REMOVE OTHER DSORG\n*                                      INDICATORS\n         OPEN  ((R8),(OUTPUT)),TYPE=J,MF=(E,OPENLST)  OPEN INPUT DCB\n         MVC   HEADER,HEADERM          MOVE HEADER INTO DATA AREA\nSUSEA    DS    0H\n         LA    R5,OUTPUTA              LOAD ADDRESS OF OUTPUT DCB FOR\n*                                      ASA CODE\n         LA    R4,EJECTA               LOAD ADDRESS OF EJECT DATA\n         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN\n         BO    SPUTDSN                 YES....GO PUT OUT HEADERS\n         LA    R3,PRINTA               LOAD POINTER TO PRINTA\n         OPEN  ((R5),(OUTPUT)),MF=(E,OPENLST)\n*        BAL   R14,ALLOCOUT            LOAD ADDRESS FOR RETURN AND GO\n*                                      DO SYSOUT ALLOCATION\nSPUTDSN  DS    0H\n         PUT   (R5),(R4)               PUT OUT PAGE EJECT\n         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER\n         MVC   HEADER2,LDSNAME         MOVE LENGTH AND 'DSNAME=' INTO\n*                                      INTO SECOND HEADER\n         MVC   DSNAME,JFCBAREA         MOVE DSNAME INTO DATA AREA\n         MVC   HEADER2+4(1),HDRCNTL    MOVE IN CONTROL BYTE\n         MVI   OPENPRN,BLANK           BLANK OUT MEMBER NAME\n         MVC   MEMNAME(9),OPENPRN      FINISH BLANKING OUT MEMBER NAME\n         PUT   (R5),HEADER2            PUT OUT PAGE 1 HEADER 2\n         PUT   (R5),HEADER3            PUT OUT PAGE 1 HEADER 3\n         L     R2,MEMTABLE             LOAD ADDRESS OF FIRST TABLE\n         MVC   LENGTH,HALF85           SET LENGTH TO 85 BYTES\n         MVC   LENGTH+2,HALF0          ZERO RESERVED BYTES\n         MVC   CNTLBYTE,HDRCNTL        MOVE IN HEADER CONTROL BYTE\n*\n***********************************************************************\n*                                                                     *\n*        DELETE AND LIST MEMBER NAMES                                 *\n*                                                                     *\n***********************************************************************\n*\nSCROLLER DS    0H\n         LA    R10,LINECNT             LOAD LINE COUNT\n         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE\n         LH    R7,4(R2)                LOAD NUMBER OF MEMBERS IN TABLE\n         LTR   R7,R7                   SEE IF THERE ARE ENTRIES\n         BZ    NOLIST                  NO.....END OF DELETE PROGRAM\n         LA    R2,8(R2)                LOAD ADDRESS OF FIRST MEMBER\n         USING MEMDSECT,R2             ESTABLISH ADDRESSABILITY TO\n*                                      MEMBER TABLE ENTRY\nLOOP1    DS    0H\n         LA    R6,DATA                 LOAD ADDRESS OF OUTPUT BUFFER\n         MVI   DATA,BLANK              BLANK OUT OUTPUT BUFFER\n         MVC   DATA+1(79),DATA         FINISH BLANKING BUFFER\n         SPACE 1\nDEL1     DS    0H\n         TM    CFIELD,HIGH             SEE IF THIS IS AN ALIAS\n         BZ    NOTALIAS                NO.....CONTINUE WITH MAIN NAME\n         BAL   R14,LOOKLOOP            GO LOOK FOR MAIN NAME\nNOTALIAS DS    0H\n*\n*              DELETE MEMBER HERE\n*\n         LA    R8,INPUT           LOAD POINTER TO PDS DCB\nSTOWDEL  STOW  (8),MEMBER,D       DELETE MEMBER\n         LTR   R15,R15            WAS DELETE OKAY?\n         BNZ   NODEL1             NO, DON'T PUT NAME IN LIST\n         MVC   2(8,R6),MEMBER          PUT MEMBER NAME IN OUTPUT BUFFER\n         AP    DELETED,ONE        ADD 1 TO COUNTER\n         SPACE 1\nNODEL1   DS    0H\n         ST    R2,SAVER2               SAVE REGISTER 2\n         LA    R6,10(R6)               LOAD POINTER TO NEXT OUTPUT\n         LA    R2,DATA+70         R2 -> TO LAST PRINT ENTRY\n         CR    R6,R2              IS LINE FULL?\n         BH    END2               YES, GO PRINT LINE\n         L     R2,SAVER2               RELOAD REGISTER 2\n         LA    R2,MEMSECTN             LOAD POINTER TO NEXT MEMBER NAME\n*                                      BUFFER LOCATION\n         BCT   R7,DEL1                 DECREMENT MEMBER COUNT FOR\n*                                 CURRENT TABLE AND GO DELETE MBR\n         B     LOOP3              GO GET NEXT TABLE, IF ANY\n         SPACE 1\nEND2     DS    0H\n         PUT   (R5),LINE               PUT OUT OUTPUT LINE\n         LA    R6,DATA                 LOAD ADDRESS OF OUTPUT BUFFER\n         MVI   DATA,BLANK              BLANK OUT OUTPUT BUFFER\n         MVC   DATA+1(79),DATA         FINISH BLANKING BUFFER\n         SPACE 1\n         SPACE 1\nEND3     DS    0H\n         L     R2,SAVER2               RELOAD REGISTER 2\n         LA    R2,MEMSECTN             LOAD POINTER TO NEXT MEMBER NAME\n         BCT   R10,MOREROW             DECREMENT ROW COUNT\n         PUT   (R5),(R4)               PUT OUT PAGE EJECT WHEN ZERO\n         LA    R10,LINECNT             LOAD LINE COUNT\n         SPACE 1                       RESET COUNTERS\nMOREROW  DS    0H\n         BCT   R7,DEL1                 DECREMENT MEMBER COUNT FOR\n*        BCT   R7,LOOP1                DECREMENT MEMBER COUNT FOR\n*                                      CURRENT TABLE\nLOOP3    L     R2,PRESENT              LOAD POINTER TO CURRENT TABLE\n         L     R2,0(R2)                LOAD POINTER TO NEXT TABLE\n         LTR   R2,R2                   SEE IF IT WAS THE LAST TABLE\n         BZ    NOROLLER           YES\n         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE\n         LH    R7,4(R2)                LOAD NUMBER OF MEMBERS IN TABLE\n         LTR   R7,R7                   SEE IF THERE ARE ENTRIES\n         BZ    NOROLLER                NO.....END OF DELETE PROGRAM\n         LA    R2,8(R2)                LOAD ADDRESS OF FIRST MEMBER\n         B     DEL1               GO DELETE MEMBERS\n*        BNZ   SCROLLER                NO.....GO LIST OUT NEXT TABLE\n*\nNOROLLER DS    0H\n         PUT   (R5),LINE               PUT OUT LAST OUTPUT LINE\n         ED    DELCOUNT,DELETED   CONVERT DELETE COUNT TO DISPLAY\n         PUT   (R5),HEADER4            PUT OUT NBR DELETED\n*\n***********************************************************************\n*                                                                     *\n*        END OF DELETE PROGRAM                                        *\n*                                                                     *\n***********************************************************************\n*\nNOTPMESS DS    0H\nNOLIST   DS    0H\nCONTPRT  DS    0H\n         L     R6,SAVER6               RESTORE REGISTER 6\nENDMEMB  DS    0H\n         L     R2,MEMTABLE             LOAD POINTER TO FIRST TABLE\nFREETABS DS    0H\n         LR    R1,R2                   LOAD AREA TO BE FREED\n         L     R2,0(R2)                LOAD POINTER TO NEXT TABLE\n         L     R0,MEMDATL              LOAD SIZE OF AREA TO BE FREED\n         FREEMAIN R,LV=(0),A=(1)       FREE STORAGE GETMAINED FOR TABLE\n         LTR   R2,R2                   SEE IF THERE WAS ANOTHER TABLE\n         BNZ   FREETABS                YES....GO FREE NEXT TABLE\n         L     R6,SAVER6               RESTORE REGISTER 6\n         LA    R8,INPUT                LOAD POINTER TO INPUT DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         TM    DCBOFLGS,DCBOFOPN       SEE IF INPUT DCB IS STILL OPEN\n         BNO   RETURN                  NO.....GO RETURN\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST IN WORKAREA\n         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB\n         DROP  R8                      DROP ADDRESSABILITY TO DCB\n         B     RETURN                  RETURN\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        PUT OUT SYNAD ERROR MESSAGE,                                 *\n*           GO FREE MEMBER TABLES, AND                                *\n*           CONTINUE WITH NEXT DATASET                                *\n*                                                                     *\n***********************************************************************\n*\nSERRI    DS    0H\n*        PUTLINE OUTPUT=(SYNADI,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED DUE TO SYNAD\n*                                      ERROR ON INPUT DATASET MESSAGE\n         B     ENDMEMB                 GO FREE MEMBER TABLES\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        SEARCH FOR MAIN NAME,                                        *\n*           SAME TTR AND NOT AN ALIAS                                 *\n*                                                                     *\n***********************************************************************\n*\nLOOKLOOP DS    0H\n         STM   R3,R4,SAVER3            SAVE REGISTERS 3 AND 4\n         L     R3,MEMTABLE             LOAD ADDRESS OF FIRST TABLE\n         USING MEMDSECT,R3             ESTABLISH ADDRESSABILITY TO\n*                                      MEMBER ENTRY\nLOOP4    DS    0H\n         ST    R3,CURRENT              SAVE ADDRESS OF PRESENT TABLE\n         LH    R4,4(R3)                LOAD NUMBER OF ELEMENTS IN TABLE\n         LTR   R4,R4                   SEE IF THERE ARE ZERO ELEMENTS\n         BZ    NOMAIN                  YES....GO HANDLE MAIN NOT FOUND\n         LA    R3,8(R3)                LOAD ADDRESS OF FIRST MEMBER\nLOOP5    DS    0H\n         CLC   MEMTTR,8(R2)            SEE IF TTRS ARE THE SAME\n         BE    SAMETTR                 YES....GO SEE IF IT IS AN ALIAS\nENDLP5   DS    0H\n         LA    R3,MEMSECTN             LOAD ADDRESS OF NEXT MEMBER\n         BCT   R4,LOOP5                DECREMENT MEMBER COUNT\n         L     R3,CURRENT              LOAD ADDRESS OF THIS TABLE\n         L     R3,0(R3)                LOAD ADDRESS OF NEXT TABLE\n         LTR   R3,R3                   SEE IF IT WAS THE LAST TABLE\n         BNZ   LOOP4                   NO.....GO CHECK NEXT TABLE\n         B     NOMAIN                  GO HANDLE MAIN NOT FOUND\nSAMETTR  DS    0H\n         TM    CFIELD,HIGH             SEE IF THIS IS ALSO AN ALIAS\n         BO    ENDLP5                  YES....GO LOOK FOR ANOTHER TTR\n         MVC   11(8,R6),MEMBER         MOVE MEMBER NAME INTO OUTPUT\n         B     ENDLOOK                 GO TO RETURN TO CALLER\nNOMAIN   DS    0H\n         MVC   11(8,R6),ALIAS          INDICATE THIS IS AN ALIAS\nENDLOOK  DS    0H\n         LM    R3,R4,SAVER3            RESTORE REGISTERS 3 AND 4\n         BR    R14                     RETURN TO CALLER\n         DROP  R3                      DROP ADDRESSABILITY TO TABLE\n*\n         AGO   .BYPASS2\nCONTINUE DS    0H\n*        L     R6,24(R6)               LOAD POINTER TO NEXT DSNAME ON\n*                                      CHAIN\n*        C     R6,ENDCHAIN             SEE IF END OF CHAIN IS REACHED\n*        BNE   NEXT                    NO.....GO DO NEXT DATASET NAME\nCLOSDCBS DS    0H\n         TM    INPUT+48,DCBOFOPN       SEE IF INPUT DCB IS STILL OPEN\n         BNO   CHKOUTA                 NO.....GO CHECK DCB FOR ASA CODE\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST WORKAREA\n         LA    R5,INPUT                LOAD POINTER TO INPUT DCB\n         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE INPUT DCB\nCHKOUTA  DS    0H\n         TM    OUTPUTA+48,DCBOFOPN     SEE IF OUTPUT DCB FOR ASA WAS\n*                                      OPENED\n         BNO   CHKOUTM                 NO.....GO CHECK DCB FOR MACHINE\n*                                      CODE\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST WORKAREA\n         LA    R5,OUTPUTA              LOAD POINTER TO ASA CODE DCB\n         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE ASA CODE OUTPUT DCB\n         LA    R1,PRINTA               LOAD ADDRESS OF PRINT DDNAME\n*        BAL   R2,FREEDD               GO FREE ASA CODE OUTPUT DDNAME\nCHKOUTM  DS    0H\n         TM    OUTPUTM+48,DCBOFOPN     SEE IF OUTPUT DCB FOR MACHINE\n*                                      CODE WAS OPENED\n         BNO   RETURN                  NO.....GO FREE GETMAINED AREAS\n*                                      AND RETURN\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST WORKAREA\n         LA    R5,OUTPUTM              LOAD POINTER TO MACHINE CODE DCB\n         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE MACHINE CODE OUTPUT DCB\n         LA    R1,PRINTM               LOAD ADDRESS OF PRINT DDNAME\n*        BAL   R2,FREEDD               GO FREE MACHINE CODE OUTPUT\n*                                      DDNAME\n.BYPASS2 ANOP\n*\n***********************************************************************\n*                                                                     *\n*        CLEANUP AREAS GETMAINED,                                     *\n*           SET RETURN CODE, RESTORE REGISTERS AND                    *\n*           RETURN TO CALLER                                          *\n*                                                                     *\n***********************************************************************\n*\nRETURN   DS    0H\n         LR    R1,R13                  LOAD ADDRESS OF GETMAINED AREA\n         L     R13,4(,R13)             RELOAD ADDRESS OF PREVIOUS SAVE\n*                                      AREA\n         LA    R0,LDYNAMIC             LOAD LENGTH OF GETMAINED AREA\n         FREEMAIN R,LV=(0),A=(1)       FREE GETMINED AREA\n         SLR   R15,R15                 ZERO REGISTER 15.  RETURN CODE\n*                                      CODE WILL ALWAYS BE ZERO\n         L     R14,12(,R13)            LOAD REGISTER 14 WITH RETURN\n*                                      ADDRESS\n         LM    R0,R12,20(R13)          RESTORE REGISTERS\n         BR    R14                     RETURN\n         AGO   .BYPASS3\n*\n***********************************************************************\n*                                                                     *\n*        ROUTINE TO CONVERT NONZERO RETURN CODES TO DECIMAL           *\n*           FOR DISPLAY                                               *\n*                                                                     *\n***********************************************************************\n*\nSETCODE  DS    0H\n         CVD   R8,DEC                  CONVERT RETURN CODE TO DECIMAL\n         UNPK  CONV(8),DEC(8)          UNPACK RETURN CODE\n         MVZ   CONV+1(7),CONV          MOVE ZONES IN CONVERTED RETURN\n*                                      CODE\n         MVC   RETNCD(2),HALF12        MOVE LENGTH OF DATA FOR PUTLINE\n         MVC   RETNCD+2(2),HALF0       MOVE IN ZEROES FOR PUTLINE\n         BR    R14                     RETURN\n.BYPASS3 ANOP\n         AGO   .BYPASS4\n*\n***********************************************************************\n*                                                                     *\n*        READS RECORDS USING GET MOVE                                 *\n*           AND ATTRIBUTES OF GIVEN DATASET                           *\n*        WRITES THESE SAME RECORDS USING PUT MOVE                     *\n*           AND THE INPUT DATASET ATTRIBUTES                          *\n*                                                                     *\n***********************************************************************\n*\nPRINTIT  DS    0H\n         LA    R8,INPUT                LOAD POINTER TO INPUT DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         MVC   INPUT(INPUTL),INPUTC    MOVE INPUT DCB CONSTANT INTO\n*                                      INPUT DCB IN WORKAREA\n         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO OPEN LIST IN WORKAREA\n         OPEN  ((R8),INPUT),MF=(E,OPENLST)  OPEN INPUT DCB\nPRINTS   DS    0H                      BRANCH ADDRESS FOR PRINTING\n*                                      MEMBERS\n         TM    DCBOFLGS,DCBOFOPN       SEE IF DCB OPENED SUCCESSFULLY\n         BNO   NOTPMESS                NO.....GO PUT OUT NOT PRINTED\n*                                      MESSAGE\n         TM    DCBRECFM,DCBRECU        SEE IF RECFM IS UNDEFINED\n         BO    ERRORU                  NO.....GO PUT OUT ERROR MESSAGE\n         BZ    ERRORU                  ZERO...NOT FIXED OR VARIABLE SO\n*                                      GO PUT OUT ERROR MESSAGE\n         CLC   DCBLRECL,HALF256        SEE IF LRECL IS GREATER THAN 256\n         BH    ERRORL                  YES....GO PUT OUT RECORD LENGTH\n*                                      MESSAGE\n         LA    R9,LINE                 LOAD ADDRESS FOR INPUT\n         SLR   R4,R4                   ZERO OUT REGISTER 4\n         ST    R4,LENGTH               STORE ZERO IN LENGTH (PLUS 2\n*                                      RESERVED BYTES) FIELD\n         TM    DCBRECFM,DCBRECV        SEE IF RECFM IS VARIABLE\n         BO    CHKCNTRL                YES....GO PUT OUT DSNAME\n*                                      NO.....RECFM MUST BE FIXED\n*                                      SO CONTINUE\n         A     R9,FULL4                SET TO HAVE FIXED LENGTH\n         LH    R4,DCBLRECL             LOAD LOGICAL RECORD LENGTH\n         A     R4,FULL4                ADD 4 FOR LENGTH FIELD PREFIX\n         STH   R4,LENGTH               STORE IN LENGTH FIELD\nCHKCNTRL DS    0H\n         MVC   HEADER,HEADERC          MOVE HEADER INTO DATA AREA\n         TM    DCBRECFM,DCBRECCM       SEE IF CONTROL IS MACHINE\n         BNO   USEA                    NO.....GO TO USE ASA CONTROL\n         LA    R5,OUTPUTM              LOAD ADDRESS OF OUTPUT DCB FOR\n*                                      MACHINE CODE\n         LA    R4,EJECTM               LOAD ADDRESS OF EJECT DATA\n         MVI   HDRCNTL,SKIPM           MOVE INTO HEADER MACHINE CODE\n*                                      FOR SPACE\n         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN\n         BO    PUTDSN                  YES....GO PUT OUT HEADERS\n         LA    R3,PRINTM               LOAD POINTER TO PRINTM\n         LA    R14,PUTDSN              LOAD ADDRESS FROM RETURN FROM\n*                                      SYSOUT ALLOCATION\n*        B     ALLOCOUT                GO TO ALLOCATE SYSOUT\nUSEA     DS    0H\n         TM    DCBRECFM,DCBRECCA       SEE IF CONTROL IS ASA\n         BO    GOODLENA                YES....GO SEE IF DCB IS OPEN\n         A     R9,FULL1                SET GET AREA TO ALLOW FOR NO\n*                                      CONTROL\n         A     R4,FULL1                ADD ONE FOR A CONTROL BYTE\n         STH   R4,LENGTH               STORE LENGTH IN PUT AREA\nGOODLENA DS    0H\n         LA    R5,OUTPUTA              LOAD ADDRESS OF OUTPUT DCB FOR\n*                                      ASA CODE\n         LA    R4,EJECTA               LOAD ADDRESS OF EJECT DATA\n         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN\n         BO    PUTDSN                  YES....GO PUT OUT HEADERS\n         LA    R3,PRINTA               LOAD POINTER TO PRINTA\n*        BAL   R14,ALLOCOUT            LOAD ADDRESS FOR RETURN AND GO\n*                                      DO SYSOUT ALLOCATION\nPUTDSN   DS    0H\n         PUT   (R5),(R4)               PUT OUT PAGE EJECT\n         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER\n         MVC   HEADER2,LDSNAME         MOVE LENGTH AND 'DSNAME=' INTO\n*                                      INTO SECOND HEADER\n         MVC   HEADER2+4(1),HDRCNTL    MOVE IN CONTROL BYTE\n         CLI   MEMNAME,BLANK           SEE IF MEMBER NAME IS BLANK\n         BE    NOMEM                   YES....NO NEED TO PUT IN PARENS\n         MVI   OPENPRN,C'('            MOVE OPEN PAREN INTO DSNAME\n         MVI   CLOSEPRN,C')'           MOVE CLOSE PAREN INTO DSNAME\n         B     PUTHDR2                 GO PUT OUT HEADER 2\nNOMEM    DS    0H\n         MVI   OPENPRN,BLANK           MOVE BLANK INSTEAD OF OPEN AND\n         MVI   CLOSEPRN,BLANK          CLOSE PARENS\nPUTHDR2  DS    0H\n         PUT   (R5),HEADER2            PUT OUT PAGE 1 HEADER 2\n         MVC   HEADER2(4),SPACE        CHANGE HEADER 2 FOR PUT OF BLANK\n*                                      LINE\n         PUT   (R5),HEADER2            PUT OUT BLANK LINE\n         MVC   CNTLBYTE,HDRCNTL        MOVE IN SPACE AS CONTROL\n*                                      CHARACTER\n         TM    VOLBIT,LOW              SEE IF FOLD IS REQUESTED\n         BO    FOLDIT                  YES....GO FOLD OUTPUT\n         TM    DCBRECFM,DCBRECV        SEE IF RECFM IS VARIABLE\n         BNO   COPYF                   NO.....GO HANDLE FIXED INPUT\n         TM    DCBRECFM,DCBRECCC       SEE IF THERE IS A CONTROL BYTE\n         BZ    COPYVNO                 NO.....GO TO ADD CONTROL FOR\n*                                      VARIABLE\nCOPYV    DS    0H\n         GET   INPUT,(R9)              GET INPUT RECORD\n         PUT   (R5),LINE               PUT OUT OUTPUT LINE\n         B     COPYV                   GO GET NEXT RECORD\n*\nCOPYVNO  DS    0H\n         GET   INPUT,(R9)              GET INPUT RECORD\n         SLR   R15,R15                 ZERO REGISTER 15 FOR INSERT\n         ICM   R15,7,LENGTH+1          INSERT LENGTH AND RESERVED BYTE\n         A     R15,FULL256             ADD 1 TO LENGTH\n         STCM  R15,7,LENGTH            STORE LENGTH AND RESERVED BYTE\n         MVC   CNTLBYTE,HDRCNTL        MOVE IN CONTROL SAVED IN HEADER\n         PUT   (R5),LINE               PUT OUT LINE\n         B     COPYVNO                 GO GET NEXT INPUT RECORD\n*\nCOPYF    DS    0H\n         GET   INPUT,(R9)              GET INPUT RECORD\n         PUT   (R5),LINE               PUT OUT OUTPUT LINE\n         B     COPYF                   GO GET NEXT RECORD\n*\nFOLDIT   DS    0H\n         TM    DCBRECFM,DCBRECV        SEE IF RECFM IS VARIABLE\n         BNO   FOLDF                   NO.....GO HANDLE FIXED INPUT\n         TM    DCBRECFM,DCBRECCC       SEE IF THERE IS A CONTROL BYTE\n         BZ    FOLDVNO                 NO.....GO TO ADD CONTROL FOR\n*                                      VARIABLE\nFOLDV    DS    0H\n         GET   INPUT,(R9)              GET INPUT RECORD\n         LH    R15,LENGTH              LOAD LENGTH OF LINE\n         SH    R15,HALF6               DECREMENT FOR EXECUTE\n         EX    R15,FOLDLINE            EXECUTE FOLD OF LINE\n         PUT   (R5),LINE               PUT OUT OUTPUT LINE\n         B     FOLDV                   GO GET NEXT RECORD\n*\nFOLDVNO  DS    0H\n         GET   INPUT,(R9)              GET INPUT RECORD\n         SLR   R15,R15                 ZERO REGISTER 15 FOR INSERT\n         ICM   R15,7,LENGTH+1          INSERT LENGTH AND RESERVED BYTE\n         A     R15,FULL256             ADD 1 TO LENGTH\n         STCM  R15,7,LENGTH            STORE LENGTH AND RESERVED BYTE\n         MVC   CNTLBYTE,HDRCNTL        MOVE IN CONTROL SAVED IN HEADER\n         LH    R15,LENGTH              LOAD LENGTH OF LINE\n         SH    R15,HALF6               DECREMENT FOR EXECUTE\n         EX    R15,FOLDLINE            EXECUTE FOLD OF LINE\n         PUT   (R5),LINE               PUT OUT LINE\n         B     FOLDVNO                 GO GET NEXT INPUT RECORD\n*\nFOLDF    DS    0H\n         LH    R4,LENGTH               LOAD LENGTH INTO REGISTER 4\n         SH    R4,HALF6                SUBTRACT TO SET UP FOR EXECUTE\nFOLDFLP  DS    0H\n         GET   INPUT,(R9)              GET INPUT RECORD\n         EX    R4,FOLDLINE             FOLD DATA\n         PUT   (R5),LINE               PUT OUT OUTPUT LINE\n         B     FOLDFLP                 GO GET NEXT RECORD\nFOLDLINE OC    DATA(0),BLANKS          OC INSTRUCTION TO BE EXECUTED\n*\nEXIT     DS    0H\n         TM    DCBOFLGS,DCBOFOPN       SEE IF INPUT DCB IS OPEN\n         BNO   EXITMSG                 NO....GO PUT OUT DATASET AND\n*                                      MEMBER NAMES\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST IN WORKAREA\n         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB\nEXITMSG  DS    0H\n         PUTLINE OUTPUT=(DSNMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATA SET NAME MESSAGE\n         LH    R4,4(R6)                LOAD LENGTH OF DSNAME\n         A     R4,FULL4                INCREMENT LENGTH FOR PUTLINE\n         SLL   R4,16                   SHIFT LENGTH TO HIGH ORDER BYTES\n         STCM  R4,15,DSNLENP           STORE LENGTH OF PUTLINE\n         PUTLINE OUTPUT=(DSNLENP,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATA SET NAME MESSAGE\n         TM    14(R6),HIGH             SEE IF MEMBER NAME IS PRESENT\n         BNO   CONTINUE                NO.....GO CHECK FOR ANOTHER\n*                                      DATASET NAME\n         PUTLINE OUTPUT=(MEMMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATA SET NAME MESSAGE\n         LH    R4,12(R6)               LOAD LENGTH OF MEMBER NAME\n         A     R4,FULL4                INCREMENT LENGTH FOR PUTLINE\n         SLL   R4,16                   SHIFT LENGTH TO HIGH ORDER BYTES\n         STCM  R4,15,MEMNAMEL          STORE LENGTH OF PUTLINE\n         PUTLINE OUTPUT=(MEMNAMEL,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      MEMBER NAME\n         B     CONTINUE                GO CONTINUE WITH NEXT DATASET\n         DROP  R8                      DROP ADDRESSABILITY TO INPUT DCB\nERRORL   DS    0H\n         PUTLINE OUTPUT=(DSNISL,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED DUE TO\n*                                      RECORD LENGTH TOO LONG MESSAGE\n         B     EXIT                    GO SEE IF INPUT DCB IS OPEN\nERRORU   DS    0H\n         PUTLINE OUTPUT=(DSNISU,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED DUE TO\n*                                      UNDEFINED RECORD FORMAT MESSAGE\n         B     EXIT                    GO SEE IF INPUT DCB IS OPEN\nERRI     DS    0H\n         PUTLINE OUTPUT=(SYNADI,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED DUE TO SYNAD\n*                                      ERROR ON INPUT DATASET MESSAGE\n         B     EXIT                    GO SEE IF INPUT DCB IS OPEN\nERRO     DS    0H\n         PUTLINE OUTPUT=(SYNADO,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED DUE TO\n*                                      UNDEFINED RECORD FORMAT MESSAGE\n         B     CLOSDCBS                GO CLOSE OPEN DCBS AND RETURN\n.BYPASS4 ANOP\n.BYPASS1 ANOP\n*\n***************************WORK AREAS *********************************\n*\n         SPACE 2\nMBRTYPE  DC    C' '\nSTARTMBR DC    CL8' '\nENDMBR   DC    CL8' '\nMBRNAME  DS    CL80\nSMBRLTH  DC    H'0'\nEMBRLTH  DC    H'0'\nWILDSLTH DC    H'0'               NBR WILD CHARS IN 1ST NAME...\nWILDELTH DC    H'0'               NBR WILD CHARS IN END NAME...\nSAVEALL  DC    18F'0'\n*\n***************************** CONSTANTS *******************************\n*\n         SPACE 2\n         PRINT NOGEN\nSYSIN    DCB   DSORG=PS,MACRF=(GM),EODAD=EOFREAD,                      +\n               DDNAME=SYSIN\nSYSINL   EQU   *-SYSIN\n*\n*NPUTC   DCB   DSORG=PS,MACRF=(GM),EODAD=EXIT,SYNAD=ERRI,DDNAME=PDS\n*NPUTL   EQU   *-INPUTC\nINPUTC   DCB   DSORG=PO,MACRF=(W),DDNAME=PDS\nINPUTL   EQU   *-INPUTC\n*\n*UTPUTAC DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=SYSPRINT,\nOUTPUTAC DCB   DSORG=PS,MACRF=(PM),DDNAME=SYSPRINT,                    X\n               LRECL=256,BLKSIZE=3120,RECFM=VBA\nOUTPUTAL EQU   *-OUTPUTAC\n*\n*UTPUTMC DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=SYSPRINT,         X\n               LRECL=256,BLKSIZE=3120,RECFM=VBM\n*UTPUTML EQU   *-OUTPUTMC\n*\nDIRECTC  DCB   DDNAME=PDS,MACRF=(GM),RECFM=U,BLKSIZE=256,              X\n               SYNAD=SERRI,EODAD=FREEBLK,DSORG=PS\nDIRECTL  EQU   *-DIRECTC\n         PRINT GEN\n*\nDELETED  DC    PL3'0'\nONE      DC    P'1'\nOPENCLOS OPEN  (,),MF=L\n         SPACE 2\nHEADERC  DS    0F\n         DC    H'48'\n         DC    H'0'\nHDRCNTLC DC    C' '\n         DC    CL43'**** TSO FOREGROUND HARDCOPY ****'\nHEADERM  DS    0F\n         DC    H'62'              LTH OF DATA + 4\n         DC    H'0'\n         DC    C' '               DATA STARTS HERE\n         DC    CL46'DIVERSIFIED DEVELOPMENTS DELETE MEMBER UTILITY'\n         DC    CL11', VERSION 2'\nHEADERML EQU   *-HEADERM\n*        DC    CL43'*** TSO FOREGROUND MEMBER LIST **'\nHEADER3  DS    0F\n         DC    H'44'              LTH OF DATA + 4\n         DC    H'0'\n         DC    C' '               DATA STARTS HERE\n         DC    C'THE FOLLOWING MEMBERS '\nHEADER3W DC    C'HAVE BEEN'\n         DC    C' DELETED'\nHEADER3L EQU   *-HEADER3\nHEADER4  DS    0F\n         DC    H'32'              LTH OF DATA + 4\n         DC    H'0'\n         DC    C'0'               DATA STARTS HERE\nDELCOUNT DC    X'402020202021'\n         DC    C' MEMBERS '\nNOTDEL   DC    C'WERE'\n         DC    C' DELETED'\nHEADER4L EQU   *-HEADER4\nLDSNAME  DS    0CL12\n         ORG   LDSNAME\n         DC    H'66'\n         DC    H'0'\n         DC    CL8' DSNAME='\nEJECTM   DS    0F\n         DC    H'5'\n         DC    H'0'\n         DC    X'8B'\nEJECTA   DS    0F\n         DC    H'5'\n         DC    H'0'\n         DC    C'1'\nSPACE    EQU   EJECTA\n         SPACE 2\nFULL0    DC    F'0'\nFULL1    DC    F'1'\nFULL4    DC    F'4'\nFULL20   DC    F'20'\nFULL28   DC    F'28'\nFULL256  DC    F'256'\nPRINTILN DC    H'12',H'0'\nPRINTI   DC    CL8'PRINTI'\nPRINTALN DC    H'12',H'0'\nPRINTA   DC    CL8'PRINTA'\nPRINTMLN DC    H'12',H'0'\nPRINTM   DC    CL8'PRINTM'\nBLANKS   DC    256CL1' '\nALIAS    DC    CL8' *ALIAS*'\nENDCHAIN DS    0F\n         DC    X'FF000000'\nMEMDATL  DC    X'00'                   SUBPOOL NUMBER\n         DC    AL3(LINECNT*36+8)       CALC TABLE SPACE\nLINECNT  EQU   50                      DEFAULT LINES PER PAGE FOR\n*                                      MEMBER NAME LIST.  MODIFY\n*                                      ABOVE STATEMENT TO CHANGE\n*                                      NUMBER OF LINES PER PAGE\n*                                      IN MEMBER NAME LIST.\nHALF0    DC    H'0'\nHALF1    DC    H'1'\nHALF2    DC    H'2'\nHALF6    DC    H'6'\nHALF12   DC    H'12'\nHALF85   DC    H'85'\nHALF256  DC    H'256'\nHEXFF    EQU   X'FF'\nHIGH     EQU   X'80'\nBLANK    EQU   X'40'\nLOW      EQU   X'01'\nJFCPDS   EQU   X'01'\nHEX00    EQU   X'00'\nSCLSA    EQU   C'A'\nSKIPM    EQU   X'09'\nDSOPS    EQU   X'40'\nDSOPO    EQU   X'02'\nNOWTP    EQU   X'00'\n         SPACE 2\n****************************** MESSAGES *******************************\nOPENMSG  DC    AL2(OPENMSGL),AL2(0)\n         DC    C'OUPUT PROCESSING IS BEING TERMINATED.  AN ERROR WAS ENX\n               COUNTERED ATTEMPTING TO OPEN THE OUTPUT DATASET ASSOCIATX\n               ED WITH DDNAME: '\nOPENMSGL EQU   *-OPENMSG\n*\nDSNMSG   DC    AL2(DSNMSGL),AL2(0)\n         DC    C'PROCESSING HAS BEEN COMPLETED FOR DATASET: '\nDSNMSGL  EQU   *-DSNMSG\n*\nMEMMSG   DC    AL2(MEMMSGL),AL2(0)\n         DC    C' MEMBER: '\nMEMMSGL  EQU   *-MEMMSG\n*\nSYNADI   DC    AL2(SYNADIL),AL2(0)\n         DC    C'A SYNAD ERROR OCURRED READING YOU INPUT DATASET AND ONX\n               LY PART OF YOUR DATASET MAY HAVE BEEN PRINTED.'\nSYNADIL  EQU   *-SYNADI\n*\nSYNADO   DC    AL2(SYNADOL),AL2(0)\n         DC    C'A SYNAD ERROR OCURRED WRITING THE OUTPUT DATASET AND NX\n               O MORE DATASETS WILL BE PRINTED.'\nSYNADOL  EQU   *-SYNADO\n*\nDSNISU   DC    AL2(DSNISUL),AL2(0)\n         DC    C'DATASET HAS UNDEFINED RECORD LENGTH AND WILL NOT BE PRX\n               INTED.'\nDSNISUL  EQU   *-DSNISU\n*\nDSNISL   DC    AL2(DSNISLL),AL2(0)\n         DC    C'DATASET HAS RECORD LENGTH GREATER THAN 256.'\nDSNISLL  EQU   *-DSNISL\n         SPACE 2\n************************ DSECTS (MAPPING MACROS) **********************\nMEMDSECT DSECT\nMEMNTTR  DS    CL11\n         ORG   MEMNTTR\nMEMBER   DS    CL8\nMEMTTR   DS    CL3\nCFIELD   DS    CL1\nMEMSECTN EQU   *\n         AGO   .BYPASS5\n         IKJDAP08\nDAP08LEN EQU   *-DAPB08\n         IKJDAP18\nDAP18LEN EQU   *-DAPB18\n         IKJDAPL\nDAPLLEN  EQU   *-DAPL\n         IKJCPPL\nCPPLLEN  EQU   *-CPPL\n         IKJPPL\nPPLLEN   EQU   *-PPL\n         IKJIOPL\nIOPLLEN  EQU   *-IOPL\n         IHADSAB\nTIOEDDNM EQU   4           X'1C'(OFFSET) - X'18'(JOB STEP)\n         CVT\n         IEFZB4D0\n         IEFZB4D2\nRBLEN    EQU   S99RBEND-S99RB\n.BYPASS5 ANOP\n         PRINT NOGEN\n         DCBD  DSORG=(PS,PO)\n         PRINT GEN\n         EJECT\n*********************** DSECT FOR DYNAMIC WORKAREA ********************\nWORKAREA DSECT\nSAVEAREA DS    18F\nALCSAVE  DS    12F\n         DS    0D\nDEC      DS    2F\nRETNCD   DS    F\nCONV     DS    2F\n         AGO   .BYPASS6\nIOPB     PUTLINE MF=L\nDAP08    DS    0F\n         ORG   DAP08+DAP08LEN\nDAP18    DS    0F\n         ORG   DAP18+DAP18LEN\nDAPLSECT DS    0F\n         ORG   DAPLSECT+DAPLLEN\nPPLSECT  DS    0F\n         ORG   PPLSECT+PPLLEN\nIOPLSECT DS    0F\n         ORG   IOPLSECT+IOPLLEN\nECB      DS    F\nPARSBACK DS    F\n.BYPASS6 ANOP\nLINE     DS    0H\nLENGTH   DS    H\n         DS    H\nCNTLBYTE DS    CL1\nDATA     DS    CL256\nHEADER2  DS    CL12\nDSNAME   DS    CL44\nOPENPRN  DS    CL1\nMEMNAME  DS    CL8\nCLOSEPRN DS    CL1\n         ORG   DSNAME-4\nDSNLENP  DS    CL2\nDSNLEN   DS    CL2\nDSNBUF   DS    CL44\n         ORG   MEMNAME-4\nMEMNAMEL DS    CL2\n         ORG\n*EADER   DS    CL62               SAME LTH AS HEADERM\nHEADER   DS    CL(HEADERML)       SAME LTH AS HEADERM\n         ORG   HEADER+4\nHDRCNTL  DS    CL1\nDFID     DS    CL2\n         ORG\nVOLBIT   DS    CL1\nVOLUME   DS    CL8\nMEMTABLE DS    F\nENDTABLE DS    F\nCURRENT  DS    F\nPRESENT  DS    F\nCOLUMN   DS    F\nXLIST    DS    F\nRDJL     RDJFCB (,),MF=L\nJFCBAREA DS    44F\n         ORG   JFCBAREA+44\nJFCBELNM DS    CL8\n         ORG   JFCBAREA+86\nJFCBIND1 DS    CL1\n         ORG   JFCBAREA+98\nJFCDSRG1 DS    CL1\n         ORG\nSAVER6   DS    F\nSAVER2   DS    2F\nSAVER3   DS    2F\n*\n         PRINT NOGEN\n*\nINPUT    DCB   DSORG=PS,MACRF=(GM),DDNAME=PRINTI\n*NPUT    DCB   DSORG=PS,MACRF=(GM),EODAD=EXIT,SYNAD=ERRI,DDNAME=PRINTI\n*\nOUTPUTA  DCB   DSORG=PS,MACRF=(PM),DDNAME=PRINTA,RECFM=VBA,            +\n               LRECL=256,BLKSIZE=3120\n*UTPUTA  DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTA,RECFM=VBA, X\n               LRECL=256,BLKSIZE=3120\n*\n*UTPUTM  DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTM,RECFM=VBM, X\n               LRECL=256,BLKSIZE=3120\n*\nDIRECT   DCB   DDNAME=PRINTI,DSORG=PS,MACRF=(GM),RECFM=U,BLKSIZE=256,  X\n               SYNAD=SERRI,EODAD=FREEBLK\n*\nOPENLST  OPEN  (,),MF=L\n*\nCLOSLST  CLOSE (,),MF=L\n*\n         PRINT GEN\n*\nRETCODE  DS    F\nGFPARMP  DS    F\nLDYNAMIC EQU   *-WORKAREA\n         END\n/*\n//LKED.SYSLMOD DD DSN=SYS9.IMSUTIL.LOAD,DISP=SHR\n//LKED.SYSIN DD *\n    SETCODE AC(0)\n    NAME DELMEMS(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DELMEMSJ": {"ttr": 8453, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03?\\x00\\x99\\x03?\\x13\\x00\\x00\\x13\\x00\\x13\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-02T00:00:00", "modifydate": "1999-02-02T13:00:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "RH87944"}, "text": "//DELMEMS  JOB\n/*ROUTE PRINT R7\n//DELMEMS EXEC PGM=DELMEMS\n//STEPLIB  DD DSN=SYS9.IMSUTIL.LOAD,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//PDS    DD DISP=SHR,DSN=HALL.PTS.BACKUP.SEP18\n//*\n//*\n//* SYSIN SYNTAX = - MEMBER NAME, OR\n//*                - PARTIAL MEMBER NAME* TO DELETE\n//*                  ALL MEMBERS IN GROUP, OR\n//*                - MEMBER NAME-MEMBER NAME TO DELETE\n//*                  ALL MEMBERS IN GROUP, OR\n//*                - PARTIAL MBR NAME-PARTIAL MBR NAME\n//*                  TO DELETE ALL MEMBERS IN GROUP\n//*\n//SYSIN  DD *\nBPI*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DISALINK": {"ttr": 8455, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x00\\x8f\\x00\\x99\\x00\\x9f\\x12T\\x00\\x18\\x00\\x15\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-01-08T00:00:00", "modifydate": "1999-01-09T12:54:00", "lines": 24, "newlines": 21, "modlines": 0, "user": "RH87944"}, "text": "//DISALINK JOB (87944,348496),HALL.S1BL,MSGCLASS=A,\n//          USER=RH87944,PASSWORD=*\n/*ROUTE        PRINT R7\n//*\n//*   DSN=RH87944.SOURCE.CNTL(DISALINK)\n//*   LINK DISASM OBJECT MODULES\n//*\n//*  BEFORE RUNNING THIS JOB, CHANGE HALL.OBJECT AND\n//*  HALL.LOAD TO YOUR DATASET NAMES.\n//*\n//LINKASM  EXEC PGM=HEWL,REGION=0M,\n//         PARM='XREF,LIST,LET,NCAL,MAP'\n//SYSPRINT DD SYSOUT=*\n//SYSUT1 DD UNIT=DISK,SPACE=(CYL,5)\n//INSOBJ  DD DISP=SHR,DSN=HALL.OBJECT\n//SYSLMOD DD DISP=SHR,DSN=HALL.LOAD\n//SYSLIN  DD *\n INCLUDE INSOBJ(DISASM,DISASM1,DISASM2)\n ENTRY DISASM\n SETCODE AC(0)\n MODE    AMODE(24) RMODE(24)\n NAME    DISASM(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DISASM": {"ttr": 8457, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x99\\x00\\x8f\\x00\\x99\\x02\\x0f\\x10G\\x07/\\x07c\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1999-01-08T00:00:00", "modifydate": "1999-01-20T10:47:00", "lines": 1839, "newlines": 1891, "modlines": 0, "user": "RH87944"}, "text": "//DISASM JOB (87944,348496),HALL.S1BL,MSGCLASS=A,\n//             USER=RH87944,PASSWORD=*\n/*ROUTE  PRINT R7\n//STEP1  EXEC HLASMC,CLASS='*',\n//            PARMC='SYSPARM(1,ESD)'\n//ASM.SYSLIB DD DSN=HALL.DISASM.SOURCE,DISP=SHR\n//   DD DSN=SYS1.MACLIB,DISP=SHR\n//   DD DSN=SYS1.AMODGEN,DISP=SHR\n//ASM.SYSLIN   DD DSN=HALL.OBJECT(DISASM),DISP=SHR\n//ASM.SYSIN DD *\n*                                                                   RH\n*   MODIFIED JAN 1999 BY RANDY HALL                                 RH\n*      HOPEFULLY ALL MODS HAVE \"RH\" IN COL 69-70...                 RH\n*      1) MADE THE HEX DUMP AN OPTION WITH PARM=TEXT                RH\n*      2) CLEANED UP THE PARM PROCESSING                            RH\n*      3) CHANGED SYSPRINT DCB TO LRECL=133 FROM 121                RH\n*      4) AT LABEL GETCTL1, USE RDJFCB ON SYSLIB TO GET MBR NAME    RH\n*         IF SPECIFIED AND TEST FOR SYSIN OPEN                      RH\n*      5) AT LABEL FREESTRG, TEST FOR \"TEXT\" PARM TO PRINT HEX DUMP RH\n*      6) ADDED CODE TO PRINT AN ASSEMBLER COMPILER TYPE HEADING    RH\n*         WITH PAGE COUNT AND STATEMENT NUMBER                      RH\n*      7) AT LABEL EOJ, ADDED CODE TO PRINT REGISTER EQUATES,       RH\n*         RATHER THAN \"REQU\".                                       RH\n*      8) AT LABEL DFMTFLD/CFL1, ADDED CODE TO PRINT DSECTS WITH    RH\n*         \"DS\" RATHER THAN \"EQU\". CHANGE \"AGO\" FOR EQU VERSION...   RH\n*      9) ADDED MORE CHARACTERS TO \"PRTCHAR\" TABLE                  RH\n*     10) INCLUDE DSECTS FROM SYSLIB WITH \"DISASPRM\" COPY AT END    RH\n*                                                                   RH\n*                                                                   RH\n*                                                                   RH\nDIS      TITLE '***** DISASSEMBLY PHASE 0 *****'\n         MACRO\n&NAME    SVLNK &REG1,&REG2,&REG3,&IND,&LV=\n         GBLC  &EQU\n         GBLC  &GM\n         GBLC  &CSECT\n         LCLC  &REGA\n         AIF   (T'&NAME EQ 'O').NOCSECT\n         AIF   ('&NAME' EQ '*').NOCSECT\n&CSECT   SETC  '&NAME'\n&CSECT   CSECT                         NAME OF PROGRAM\n         AGO   .RST\n.NOCSECT ANOP\n&CSECT   SETC  '*'\n         CSECT                         BEGINNING OF PROGRAM\n.RST     ANOP\n         AIF   ('&EQU' EQ 'ON').NRQ\n&EQU     SETC  'ON'\n*\n***REGISTER EQUATES***\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n.NRQ     ANOP\n*\n*******************  PROGRAM INITIALIZATION  *************************\n*\n         AIF   (T'&REG1 EQ 'O').NOREG\n&REGA    SETC  '&REG1'\n         AIF   (T'&REG2 EQ 'O').ONEREG\n         USING &CSECT,&REGA,&REG2          ESTABLISH ADDRESSABILITY\n         AGO   .BYUSE\n.NOREG   ANOP\n&REGA    SETC  'R3'\n.ONEREG  USING &CSECT,&REGA              ESTABLISH ADDRESSABILITY\n.BYUSE   ANOP\n         STM   R14,R12,12(R13) :       STORE REGS IN HIGH SAVE AREA\n         LR    &REGA,R15                  INITIALIZE BASE REG\n         AIF   (T'&REG2 EQ 'O').NOLA\n         LA    &REG2,4095(&REGA)       INITIALIZE THE SECOND\n         LA    &REG2,1(&REG2)                BASE REGISTER\n.NOLA    ANOP\n         AIF   (T'&REG3 EQ 'O').NOLNK\n         L     &REG3,0(R1)                GET PARAMETER LIST ADDR\n.NOLNK   ANOP\n         AIF (T'&IND EQ 'O').GETIT\n         CNOP  0,4\n         BAL   R15,SAVEAREA+72         BRANCH AROUND SAVE AREA\nSAVEAREA DS    18F                     REGISTER SAVE AREA\n         ST    R15,8(R13)\n         ST    R13,SAVEAREA+4\n         LR    R13,R15\n         AGO   .NOSAVE\n.GETIT   ANOP\n         AIF   (T'&LV EQ 'O').GMD\n&GM      SETC  '&LV'\n         AGO   .DGM\n.GMD     ANOP\n&GM      SETC  '72'\n.DGM     ANOP\n*\n***GET MAIN STORAGE FOR SAVE AREA***\n*\n         AIF   ('&GM' LT '4096').LA\n         GETMAIN R,LV=&GM              GET CORE FOR SAVE AREA\n         AGO   .EGM\n.LA      ANOP\n         LA    R0,&GM                  GET &GM BYTES\n         GETMAIN R,LV=(0)\n.EGM     ANOP\n*\n***SET UP SAVE AREA POINTERS***\n*\n         ST    R1,8(R13)               STORE LOW SAVE POINTER\n         ST    R13,4(R1)               STORE HIGH SAVE POINTER\n         LR    R13,R1                  INITIALIZE SAVE POINTER\n         AIF   (T'&REG3  NE 'O').NOSAVE\n         L     R1,4(R13)               GET POINTER TO RESTORE PARA REG\n         L     R1,24(R1)               RESTORE PARAMETER REGISTER\n.NOSAVE  ANOP\n         AIF   ('&CSECT' EQ '*').EXIT\n         B     *+12\n         DC    CL8'&CSECT'             END INITIAL., BEGIN THIS PROG.\n.EXIT    ANOP\n*\n*********************  END INITIALIZATION  ***************************\n*\n         MEND\n         EJECT\nDISASM   SVLNK R3,R4\n         PRINT   GEN\n*DISASSEMBLER PROGRAM TO CREATE AN ASSEMBLER SOURCE PROGRAM\n*FROM A LOAD MODULE IN A PDS. DD CARDS REQUIRED INCLUDE\n*SYSPRINT FOR MESSAGES AND DIAGNOSTICS USING BLKSIZE A MULTIPLE\n*OF 121, SYSLIB SPECIFYING THE PDS CONTAINING THE MEMBER,        FIX***\n*WHICH MUST BE A PDS, SYSPUNCH FOR THE ASSEMBLER SOURCE\n*PROGRAM, HAVING BLKSIZE A MULTIPLE OF 80, AND SYSIN\n*FOR THE CONTROL CARD INPUT. CONTROL INPUT MAY OPTIONALLY\n*BE ENTERED VIA THE PARM ON THE EXECUTE CARD. CONTROL\n*INFORMATION INCLUDES THE MEMBER NAME AND CSECT NAME\n*TO BE DISASSEMBLED. IF CSECT NAME IS OMITTED, THE CSECT\n*FOR ESD-ID 0001 WILL BE USED.\n*\n*\n* FILES USED BY THIS PROGRAM INCLUDE THE FOLLOWING:\n*\n* DDNAME SYSLIB: RECFM=U. INPUT LOAD MODULE LIBRARY.\n*\n* DDNAME SYSPUNCH: RECFM=FB,LRECL=80. OUTPUT FILE CONTAINING\n*                 DISASSEMBLED TEXT. (MAXBLK=18,960)\n*\n* DDNAME SYSPRINT: RECFM=FBA,LRECL=121.  PRINTED OUTPUT CONTAINING A\n*                LIST OF THE ESD TABLE, RLD TABLE, AND TEXT.\n*                (MAXBLK=18997)\n* DDNAME LOADLIB: (OPTIONAL) NAMES A PDS CONTAINING THE\n*                 MODULES OF DISASM IF DIFFERENT FROM\n*                 THE STEPLIB. USED PRIMARILY FOR TSO.\n*\n* DDNAME SYSIN: RECFM=FB, LRECL=80. CONTROL CARD INPUT.\n*\n*\n* THE CONTROL CARD PROVIDES THE MEMBER NAME AND CSECT NAME\n* OF THE PROGRAM TO BE DISASSEMBLED. MEMBER NAME IS REQUIRED.\n* IF CSECT NAME IS OMITTED, THE CSECT WITH ESDID 0001 WILL\n* BE USED. FORMAT IS FREE-FORM. MEMBER NAME MUST PRECEDE CSECT\n* NAME. ANY NUMBER OF BLANKS MAY PRECEDE AND FOLLOW MEMBER NAME.\n* A COMMA MAY IMMEDIATELY FOLLOW MEMBER NAME IF DESIRED.\n*\n*\n* PARM DATA FROM THE EXECUTE CARD MAY BE USED TO SPECIFY\n* VALIDITY OF PRIVILEGED OR FLOATING POINT INSTRUCTIONS.\n* IF NOT SPECIFIED, PRIVILEGED AND FLOATING POINT OPERATION\n* CODES WILL NOT BE TREATED AS INSTRUCTION OP-CODES. TO\n* INCLUDE THESE INSTRUCTIONS, CODE:\n*     PARM=(SUPVR)      PRIVILEGED INSTRUCTIONS\n*     PARM=(FLTPT)      FLOATING POINT INSTRUCTIONS\n*     PARM=(SUPVR,FLTPT) BOTH\n*\n*\n*PROCESSING FLOW:\n* 1. PROCESS THE CONTROL INFORMATION TO OBTAIN THE MEMBER\n*    AND CSECT NAMES.\n* 2. ISSUE BLDL AGAINST SYSLIB TO OBTAIN DIRECTORY INFO FOR\n*    THE MEMBER SPECIFIED. IF THE SPECIFIED MEMBER IS AN\n*    ALIAS, RE-ISSUE A BLDL FOR THE REAL MEMBER. PRINT\n*    DIRECTORY INFORMATION.\n* 3. POINT TO THE MEMBER IN THE SYSLIB PDS, AND PROCESS THE\n*    MEMBER. LOAD MODULES CONTAIN AN EXTERNAL SYMBOL DICTIONARY\n*    FOLLOWED BY TEXT AND RELOCATION DICTIONARY INFORMATION.\n*    ALL ESD INFO FOR THE MODULE PRECEDES THE FIRST CONTROL\n*    RECORD. A CONTROL RECORD PRECEDES EACH BLOCK OF TEXT.\n*    RLD INFO FOR THE TEXT FOLLOWS EACH TEXT BLOCK. PROCESSING\n*    OF LOAD MODULE INFORMATION IS AS FOLLOWS:\n*    A. BUILD AN EXTERNAL SYMBOL TABLE, USING THE CESD BLOCKS.\n*    B. SEARCH FOR THE DESIRED CSECT AS THE TABLE IS BEING\n*       BUILT. THIS CSECT MUST BE FOUND BEFORE THE FIRST\n*       CONTROL RECORD.\n*    C. READ BLOCKS UNTIL A CONTROL RECORD FOR THE DESIRED\n*       CSECT IS FOUND (BY ESD-ID). WHEN FOUND, SAVE THE\n*       TEXT FOR DISASSEMBLY, AND USE THE FOLLOWING RLD\n*       INFORMATION TO BUILD A RELOCATION DICTIONARY TO BE USED\n*       DURING DISASSEMBLY.\n* 4. DISASSEMBLY USES THE EXTERNAL SYMBOL TABLE, RELOCATION\n*    DICTIONARY, AND TEXT BUILT BY THE PREVIOUS STEPS.\n*\n*\n* AUTHOR R THORNTON - NOV 1977\n*\n* UPDATES BY R. STYMA  JAN 1989\n* UPDATE SGLOP TABLES IN PHASE 1 AND PHASE2 TO CONTAIN XA ONLY\n* INSTRUCTIONS LIKE BSM, BAS, AND SO ON.  ALSO IDENTIFY BSM AND\n* BAS AS BRANCH INSTRUCTIONS IN PHASES 1 AND 2.\n* UPDATE INPUT BUFFER LENGTH TO CONTAIN MAX BSAM BLOCK SIZE.\n* CHANGE GETMAIN LENGTHS TO CONSTANTS.\n*\n* UPDATED ALAN C FIELD - APR 1990\n*\n* UPDATES BY R. STYMA  MAR 1991\n* MERGED CHANGES BY ALAN C FIELD WITH PREVIOUS CHANGES BY MYSELF\n*\n*\n****************************************************************\n*                                                              *\n* PROCESS THE PARM FIELD, IF ANY.                              *\n*                                                              *\n****************************************************************\n*\n         L     R12,0(R1)               GET PARM FIELD ADDRESS\n         SR    R1,R1                   CLEAR WORK REG\n         ICM   R1,3,0(R12)             PICK UP PARM LENGTH\n         BZ    OPENS                   NO PARM INFO ENTERED\n*        CH    R1,H5                   5-BYTES OF PARM\n*        BE    SGLPARM                 YES, SINGLE PARM FIELD\n*        CH    R1,H11                  11-BYTES OF PARM\n*        BE    DBLPARM                 YES, BOTH PARMS\n*ADPARM  WTO   'INVALID PARM, SPECIFY ONLY SUPVR AND/OR FLTPT',        X\n               ROUTCDE=11\n*        ABEND 777,DUMP\n*SGLPARM CLC   2(5,R12),=C'SUPVR'      IS PARM=SUPVR\n*        BE    SUPARM                  YES\n*        CLC   2(5,R12),=C'FLTPT'      PARM IS FLTPT\n*        BNE   BADPARM                 NO, ERROR\n*        MVI   FLPTASM,1               SET FLOATING POINT O.K.\n*        B     OPENS                   CONTINUE\n*DBLPARM CLC   2(5,R12),=C'SUPVR'      IS 1ST PARM SUPVR\n*        BE    CK2FPT                  YES\n*        CLC   2(5,R12),=C'FLTPT'      IS 1ST PARM FLTPT\n*        BNE   BADPARM                 NO, ERROR\n*        CLC   8(5,R12),=C'SUPVR'      IS 2ND PARM SUPVR         FIX***\n*        BNE   BADPARM                 NO, ERROR\n*        B     FPT2PARM                BOTH O.K.\n*CK2FPT  CLC   8(5,R12),=C'FLTPT'      IS 2ND PARM FLTPT         FIX***\n*        BNE   BADPARM                 YES\n*FPT2PARM MVI   FLPTASM,1               SET FLOATING POINT O.K.\n*SUPARM  MVI   PRIVASM,1               SET PRIVILEGED INSTR O.K.\n*\n*\nSGLPARM  DS    0H                 PROCESS PARM                      RH\n         CLC   2(4,R12),=C'TEXT'  DOES HE WANT A HEX DUMP OF MODULE RH\n         BNE   SGLPARM2           NO, SEE IF FLTPT                  RH\n         MVI   TEXTFLAG,1         SAY HE WANTS A DUMP               RH\n         SH    R1,=H'5'           TAKE LTH OFF TOTAL PARM LTH       RH\n         AH    R12,=H'5'          R12 -> TO NEXT PARM               RH\n         SPACE 1                                                    RH\nSGLPARM2 DS    0H                                                   RH\n         CLC   2(5,R12),=C'FLTPT' IS PARM FLTPT                     RH\n         BNE   SGLPARM3           NO, SEE IF SUPVR\n         MVI   FLPTASM,1               SET FLOATING POINT O.K.\n         SH    R1,=H'6'           TAKE LTH OFF TOTAL PARM LTH       RH\n         AH    R12,=H'6'          R12 -> TO NEXT PARM               RH\n         SPACE 1                                                    RH\nSGLPARM3 DS    0H                                                   RH\n         CLC   2(5,R12),=C'SUPVR' IS PARM SUPVR                     RH\n         BNE   SGLPARM4           NO, SEE IF END                    RH\n         MVI   PRIVASM,1          SET PRIVILEGED INSTR O.K.         RH\n         SH    R1,=H'6'           TAKE LTH OFF TOTAL PARM LTH       RH\n         AH    R12,=H'6'          R12 -> TO NEXT PARM               RH\n         SPACE 1                                                    RH\nSGLPARM4 DS    0H                                                   RH\n         LTR   R1,R1              ANY PARMS LEFT ?                  RH\n         BP    SGLPARM            YES, GO CHECK IT OUT              RH\n*                                                                   RH\nOPENS    RDJFCB LOADLIB                WAS LOADLIB DD CARD INCLUDED\n         LTR   R15,R15                 JFCB READ O.K.\n         BNZ   OPEN1                   NO, DONT OPEN\n         OPEN  LOADLIB                 GOT DD CARD, OPEN FILE\n*\n****************************************************************\n*                                                              *\n* GET STORAGE FOR THE SYMBOL TABLE, RLD TABLE, AND DATA-ONLY   *\n* TABLES, AND OPEN FILES.                                      *\n*                                                              *\n****************************************************************\n*\nOPEN1    OPEN  (SYSPRINT,OUTPUT,SYSPUNCH,OUTPUT)\n         OPEN  (SYSLIB,,SYSIN)         OPEN FILES\n*        TM    SYSIN+48,X'10'          DID SYSIN OPEN O.K.          RH\n*        BZ    NOCTL                   NO                           RH\n         BAL   R9,GETCTL               EXTRACT DESIRED MEMBER AND CSECT\n         BAL   R9,BLDL                 ISSUE BLDL AND PRINT\n         MVI   CCAT,0                  INSURE TTR0\n         POINT SYSLIB,TTRMOD           POINT TO 1ST BLOCK OF MODULE\n*        GETMAIN R,LV=20000            GET BUFFER STORAGE\n*        GET BUFFER STORAGE\n         GETMAIN RU,LV=32768,BNDRY=PAGE,LOC=BELOW\n         ST    R1,BUFAD                SAVE BUFFER ADDRESS\n*        GETMAIN R,LV=38000            GET SYMBOL TABLE STORAGE\n         GETMAIN R,LV=SYMTABL          GET SYMBOL TABLE STORAGE\n         ST    R1,SYMTBAD              SAVE SYMBOL TABLE ADDRESS\n         ST    R1,CURRSYM              SAVE CURRENT SYMBOL ADDR\n         MVI   0(R1),X'FF'             TABLE END INDIC\n         A     R1,ENDSYM               COMPUTE END ADDR\n         ST    R1,ENDSYM               STORE TBL END ADDR\n*        GETMAIN R,LV=60000            GET RLD TABLE STORAGE\n         GETMAIN R,LV=RLDTABL          GET RLD TABLE STORAGE\n         ST    R1,RLDTBL               SAVE RLD TABLE ADDRESS\n         ST    R1,CURRLD               SAVE CURRENT RLD ADDR\n         MVI   0(R1),X'FF'             TABLE END INDIC\n         A     R1,ENDRLD               COMPUTE END ADDR\n         ST    R1,ENDRLD               STORE TBL END ADDR\n*        GETMAIN R,LV=1544             GET DATA ONLY TABLE STORAGE\n         GETMAIN R,LV=DATOLEN+8        GET DATA ONLY TABLE STORAGE\n         ST    R1,DATONLY              SAVE TBL ADDRESS\n         MVC   0(3,R1),HIVAL           SET END VALUE\n         ST    R1,DATOCUR              SET CURRENT ADDRESS\n         A     R1,ENDATO               COMPUTE TABLE END ADDR\n         ST    R1,DATOEND              SAVE END ADDR\n         MVC   PRT+15(29),=C'*** EXTERNAL SYMBOL TABLE ***'\n         MVI   PCC,C'-'                SET SKIP 3 LINES\n         BAL   R9,PRINT                PRINT\n         MVC   PRTLINE(LSYMHDR),SYMHDR SYM TBL HEADER               RH\n         BAL   R9,PRINT                PRINT\n*\n*\n*\n****************************************************************\n*                                                              *\n* MAINLINE PROCESSING FOR THE LOAD MODULE. THE DIRECTORY ENTRY *\n* AND TEXT ARE PROCESSED.                                      *\n*                                                              *\n****************************************************************\n*\nMAINLINE EQU   *                       MAINLINE ROUTINE\n         L     R6,BUFAD                GET BUFFER ADDRESS\n         READ  DECB,SF,SYSLIB,(6),'S'  READ BLOCK FROM MEMBER\n         CHECK DECB                    AWAIT COMPLETION\n         CLI   0(R6),X'20'             CESD RECORD\n         BNE   TESTOTHR                NO\n         BAL   R9,CESDREC              PROCESS CESD RECORDS\n         B     MAINLINE                GO READ AGAIN\nTESTOTHR LA    R9,CNTLRECS             ASSUME CONTROL RECORD\n         CLI   0(R6),1                 IT IS CONTROL\n         BE    PERFORM                 YES\n         CLI   0(R6),5                 IS IT CONTROL\n         BE    PERFORM                 YES\n         CLI   0(R6),13                IS IT CONTROL\n         BE    PERFORM                 YES\n         LA    R9,RLDRECS              ASSUME RLD RECORD\n         CLI   0(R6),2                 IS IT RLD\n         BE    PERFORM                 YES\n         CLI   0(R6),6                 IS IT RLD\n         BE    PERFORM                 YES\n         CLI   0(R6),14                IS IT RLD\n         BE    PERFORM                 YES\n         LA    R9,CTRLRECS             ASSUME CONTROL AND RLD\n         CLI   0(R6),3                 IS IT CTL AND RLD\n         BE    PERFORM                 YES\n         CLI   0(R6),7                 IS IT CTL AND RLD\n         BE    PERFORM                 YES\n         CLI   0(R6),15                IS IT CTL AND RLD\n         BE    PERFORM                 YES\n         B     MAINLINE                NONE OF THESE, SKIP\nPERFORM  TM    PROCESS,X'80'           WAS CSECT FOUND\n         BZ    MISSCS                  NO, ERROR\n         BALR  R9,R9                   PERFORM APPROPRIATE ROUTINE\n         TM    PROCESS,X'40'           MODULE PROCESSING DONE\n         BZ    MAINLINE                NO, GO READ AGAIN\n         MVI   EOFSW+1,0               SET END OF FILE SWITCH\n         B     ENDINIT                 GO COMPLETE PROCESSING\n*\n*\n*\n****************************************************************\n*                                                              *\n* PROCESS LOAD MODULE CONTROL RECORDS. THESE RECORDS PRECEDE   *\n* TEXT RECORDS, WHICH ARE READ AND PLACED IN STORAGE IN CONTIG-*\n* UOUS LOCATIONS SO THAT THE TEXT FOR THE DESIRED CSECT WILL   *\n* ALL BE IN STORAGE FOR THE REMAINDER OF DISASSEMBLY.          *\n*                                                              *\n****************************************************************\n*\nCNTLRECS EQU   *                       CONTROL RECORD PROCESSING\n         ST    R9,CT9                  SAVE RETURN ADDR\n         SR    R8,R8                   CLEAR WORK\n         ICM   R8,7,9(R6)              LKED ASGND @ OF TXT\n         TM    0(R6),X'08'             RECORD PRECEDES LAST RECORD OF M\n         BZ    CNCKTYP                 NO\n         OI    PROCESS,X'40'           YES, SHOW PROCESSING COMPLETE\nCNCKTYP  TM    0(R6),X'02'             CONTROL AND RLD\n         BO    CNPASRLD                YES\n         LA    R12,16(R6)              @ CESD ENTRY NBR\n         B     CNCKESD                 CONTINUE\nCNPASRLD LH    R12,6(R6)               GET RLD SECTION LENGTH\n         LA    R12,16(R6,R12)          @ CESD ENTRY NBR\nCNCKESD  LH    R11,4(R6)               LENGTH OF CONTROL INFO SECTION\n         SRL   R11,2                   COMPUTE NBR CNTL ENTRIES\n         SR    R10,R10                 OFFSET TO 1ST BYTE\n         SR    R9,R9                   LENGTH OF TEXT\nCNCKESD1 CLC   ESDID,0(R12)            THIS THE DESIRED ESD   FIX***\n         BE    CNFNDIT                 YES\n         AH    R10,2(R12)              MAINTAIN OFFSET TO 1ST TEXT BYTE\n         LA    R12,4(R12)              TO NEXT CNTL ENTRY\n         BCT   R11,CNCKESD1            LOOP THRU CNTL ENTRIES  FIX***\n         B     READTEXT                GO READ FOLLOWING TEXT\nCNFNDIT  LH    R9,2(R12)               GET TEXT LENGTH\nREADTEXT READ  DECB,SF,,(6),MF=E       READ FOLLOWING TEXT RECORD\n         CHECK DECB                    AWAIT COMPLETION\n         LTR   R9,R9                   DOES IT CONTAIN DESIRED TEXT\n         BZ    CTXIT                   NO, SKIP IT\n         S     R8,START                (-) OFFSET IN MODULE    FIX***\n         AR    R8,R10                  ADD OFFSET OF PORTION IN RCD  **\n*           R8 SHOULD NOW CONTAIN THE OFFSET WITHIN THE CSECT\n*           THAT THIS BLOCK CONTAINS (TRICKY).\n*\n         A     R10,BUFAD               @ 1ST TEXT BYTE\n***      S     R8,START    MOVED UP    RELATIVIZE TEXT ADDR    FIX***\n         A     R8,TXTSTRT              @ PLACE TO MOVE TEXT\n         LR    R11,R9                  COPY LENGTH TO MOVE\n         MVCL  R8,R10                  MOVE TEXT TO STORAGE\nCTXIT    L     R9,CT9                  GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n****************************************************************\n*                                                              *\n* PROCESS RLD RECORDS. A TABLE OF RLD DATA IS BUILT WHICH WILL *\n* LATER BE USED TO BUILD PROGRAM LABELS AND ADCONS.            *\n*                                                              *\n****************************************************************\n*\nRLDRECS  EQU   *                       RLD RECORD PROCESSING\n         TM    0(R6),X'08'             LAST RECORD OF MODULE\n         BZ    RLSV9                   NO\n         OI    PROCESS,X'40'           SHOW PROCESSING COMPLETE\nRLSV9    ST    R9,RL9                  SAVE RETURN ADDR\nRLDSW    NOP   RLDST                   FIRST TIME SWITCH\n         MVI   RLDSW+1,C'0'            RESET 1ST TIME SW\n         MVC   PRT+15(20),=C'***** RLD INFO *****'\n         MVI   PCC,C'-'                SKIP 3 LINES\n         BAL   R9,PRINT                PRINT\n         MVC   PRTLINE(LRLDHDR),RLDHDR RLD HEADER                   RH\n         BAL   R9,PRINT                PRINT RLD HEADER\nRLDST    LH    R8,6(R6)                NBR BYTES OF RLD DATA\n         LA    R6,16(R6)               @ 1ST BYTE OF RLD DATA\n         AR    R8,R6                   END OF RLD DATA ADDR\n         L     R7,CURRLD               @ NEXT RLD TBL ENTRY\n         USING RLDTBLD,R7\n         LH    R10,0(R6)               RELOCATION POINTER\n         LH    R11,2(R6)               POSITION POINTER\n         LA    R6,4(R6)                PASS POINTERS\nRLDNXT   CLC   1(3,R6),START+1         RLD ADDR BELOW CSECT\n         BL    RLDSTEP                 LOW, IGNORE\n         CLC   1(3,R6),END+1           RLD ADDR ABOVE CSECT\n         BH    RLDSTEP                 HIGH, IGNORE\n         C     R7,ENDRLD               END OF RLD TBL\n         BE    RLDFULL                 YES, ERROR\n         STH   R10,RLDRP               SAVE RELOC PTR\n         STH   R11,RLDPP               POS PTR\n         PACK  RLDTYPE,0(1,R6)         INVERT FLAG BYTE\n         NI    RLDTYPE,X'0F'           CLEAR HI-ORDER\n         CLI   RLDTYPE,9               UNRESOLVED\n         BNE   RLDMOVLN                NO\n         MVI   RLDTYPE,8               YES, USE PREFERRED VALUE\nRLDMOVLN MVC   RLDLEN,0(R6)            FLAG BYTE\n         NI    RLDLEN,X'0F'            CLEAR HI-ORDER\n         SR    R12,R12                 CLEAR WORK\n         IC    R12,RLDLEN              PICK UP BYTE\n         SRL   R12,2                   SHIFT OUT DIR, IND BITS\n         LA    R12,1(R12)              ADD 1 = LENGTH\n         STC   R12,RLDLEN              LENGTH CODE\n         MVI   RLDDIR,C'+'             ASSUME POS RELOC\n         TM    0(R6),2                 IS IT POSITIVE\n         BZ    RLADMV                  YES\n         MVI   RLDDIR,C'-'             NO, SHOW NEGATIVE\nRLADMV   SR    R1,R1                   CLEAR WORK REG\n         ICM   R1,7,1(R6)              PICK UP ADDRESS\n         S     R1,START                RELATIVIZE WITHIN CSECT\n         STCM  R1,7,RLDADDR            SAVE RELATIVE ADDRESS\n         LA    R12,RLDRP               @ RELOC PTR\n         BAL   R9,HEXPRT2              CONVERT\n         MVC   PRT+6(4),PRTABL         RELOC PTR\n         LA    R12,RLDPP               @ POS PTR\n         BAL   R9,HEXPRT2              CONVERT\n         MVC   PRT+14(4),PRTABL        POS PTR\n         MVC   PRT+24(4),=C'ACON'      ASSUME A TYPE ADCON\n         CLI   RLDTYPE,0               IS IT ADCON\n         BE    RLDLN                   YES\n         MVC   PRT+24(4),=C'VCON'      ASSUME VCON\n         CLI   RLDTYPE,1               IS IT VCON\n         BE    RLDLN                   YES\n         MVC   PRT+22(6),=C'PRDISP'    ASSUME PSEUDO REG DISPL\n         CLI   RLDTYPE,2               IS IT P.R. DISPL\n         BE    RLDLN                   YES\n         MVC   PRT+22(6),=C'PRCUM'     ASSUME PSEUDO REG CUMUL DISPL\n         CLI   RLDTYPE,3               IS IT P.R. CUM DISPL\n         BE    RLDLN                   YES\n         MVC   PRT+21(10),=C'UNRESOLVED' ASSUME UNRESOLVED\n         CLI   RLDTYPE,8               IS IT UNRESOLVED\n         BE    RLDLN                   YES\n         MVC   PRT+21(10),BLANX        CLEAR FIELD\n         MVC   PRT+24(3),=C'??:'\n         LA    R12,RLDTYPE             @ TYPE\n         BAL   R9,HEXPRT1              CONVERT\n         MVC   PRT+27(1),PRTABL+1      TYPE\nRLDLN    MVC   PRT+35(1),RLDLEN        LENGTH\n         OI    PRT+35,C'0'             CLEAR ZONE\n         MVC   PRT+42(1),RLDDIR        RELOCATION DIRECTION\n         LA    R12,RLDADDR             @ ADDRESS\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   PRT+46(6),PRTABL        ADDRESS\n         XC    RLDNAME(9),RLDNAME      CLEAR\n         LH    R15,RLDRP               GET RELOCATION POINTER\n         BCTR  R15,R0                  DEDUCT 1\n         LTR   R15,R15                 TEST DIFFERENCE\n         BM    RLPRT                   NEG, ERROR\n         MH    R15,SYMLEN              TIMES SYM TBL ENTRY LENG\n         A     R15,SYMTBAD             @ ESD SYMBOL TBL ENTRY\n         C     R15,CURRSYM             PAST END OF TABLE\n         BH    RLPRT                   YES, ERROR\n         USING SYMTBL,R15\n         MVC   RLDNAME,EXTSYM          ESD SYMBOL TO RLD TBL ENTRY\n         MVC   RLDESDTP,TYPSYM         ESD TYPE TO RLD ENTRY\n         DROP  R15\n         MVC   PRT+60(8),RLDNAME       NAME TO PRINT\n         MVC   PRT+70(2),=C'LR'        ASSUME LR\n         CLI   RLDESDTP,3              IS IT LR\n         BE    RLPRT                   YES\n         MVC   PRT+70(2),=C'SD'        ASSUME SD\n         CLI   RLDESDTP,0              IS IT SD\n         BE    RLPRT                   YES\n         MVC   PRT+70(2),=C'ER'        ASSUME ER\n         CLI   RLDESDTP,2              IS IT ER\n         BE    RLPRT                   YES\n         MVC   PRT+70(2),=C'PC'        ASSUME PC\n         CLI   RLDESDTP,4              IS IT PC\n         BE    RLPRT                   YES\n         MVC   PRT+70(2),=C'PR'        ASSUME PR\n         CLI   RLDESDTP,6              IS IT PR\n         BE    RLPRT                   YES\n         MVC   PRT+70(2),=C'CM'        ASSUME CM\n         CLI   RLDESDTP,5              IS IT CM\n         BE    RLPRT                   YES\n         MVC   PRT+70(2),=C'WX'        ASSUME WX\n         CLI   RLDESDTP,X'0A'          IS IT WX\n         BE    RLPRT                   YES\n         MVC   PRT+70(4),=C'NULL'      ASSUME NULL\n         CLI   RLDESDTP,7              IS IT NULL\n         BE    RLPRT                   YES\n         MVC   PRT+70(6),=C'E/STAB'    ASSUME E/STAB\n         CLI   RLDESDTP,X'0F'          IS IT E/STAB\n         BE    RLPRT                   YES\n         MVC   PRT+70(6),=C'??????'    UNKNOWN TYPE\nRLPRT    BAL   R9,PRINT                PRINT\n         CLC   RLDNAME,CSECT           RLD NAME IS CSECT NAME\n         BNE   GOODRLD                 NO\n         CLC   RLDADDR,XZROS           RELATIVE OFFSET IS ZERO\n         BE    RLDSTEP                 YES, IGNORE ENTRY\nGOODRLD  LA    R7,L'RLDENT(R7)         TO NEXT TBL ENTRY\nRLDSTEP  TM    0(R6),1                 NEXT ITEM HAS REL AND POS PTRS\n         BO    RLSAME                  NO\n         LH    R10,4(R6)               PICK UP NEW REL PTR\n         LH    R11,6(R6)               PICK UP NEW POS PTR\n         LA    R6,4(R6)                STEP OVER 4 BYTES\nRLSAME   LA    R6,4(R6)                TO NEXT RLD ITEM\n         CR    R6,R8                   END OF RLD DATA\n         BL    RLDNXT                  NO\n         MVI   0(R7),X'FF'             SET TBL END INDIC\n         ST    R7,CURRLD               SET NEW CURRENT ADDRESS\n         L     R9,RL9                  GET RETURN ADDR\n         BR    R9                      EXIT\n         DROP  R7\n*\n*\n*\n****************************************************************\n*                                                              *\n* PROCESS CONTROL AND RLD RECORDS. THESE RECORDS CONTAIN BOTH  *\n* RLD AND CONTROL INFORMATION, AND ARE PROCESSED BY BOTH       *\n* THE RLDRECS AND CNTLRECS ROUTINES.                           *\n*                                                              *\n****************************************************************\n*\nCTRLRECS EQU   *                       CONTROL AND RLD RECORDS\n         ST    R9,CR9                  SAVE RETURN ADDR\n         BAL   R9,RLDRECS              PROCESS RLD DATA\n         L     R6,BUFAD                RESET BUFFER ADDRESS\n         BAL   R9,CNTLRECS             PROCESS CONTROL DATA\n         L     R9,CR9                  GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n*\n*\n*\n****************************************************************\n*                                                              *\n* PROCESS COMPOSITE ESD RECORDS. DATA FROM THESE RECORDS IS    *\n* PLACED IN THE SYMBOL TABLE, AND IS USED TO CREATE PROGRAM    *\n* ENTRY STATEMENTS, AND TO IDENTIFY THE NAMES OF EXTERNAL      *\n* SYMBOLS USED BY THE PROGRAM.                                 *\n*                                                              *\n****************************************************************\n*\nCESDREC  EQU   *                       CESD RECORD PROCESSING\n         ST    R9,CES9                 SAVE RETURN\n         L     R7,CURRSYM              GET SYMBOL TBL ADDR\n         USING SYMTBL,R7\n         LH    R10,4(R6)               GET ESD ID OF 1ST ITEM\n         LH    R8,6(R6)                NBR BYTES OF ESD DATA\n         SRL   R8,4                    COMPUTE NBR ENTRIES\n         LA    R6,8(R6)                STEP TO 1ST RECORD ESD ITEM\nCESDNXT  C     R7,ENDSYM               END OF TABLE\n         BNL   SYMFULL                 YES, ERROR\n         MVC   EXTSYM,0(R6)            SYMBOL NAME\n         MVC   TYPSYM,8(R6)            TYPE\n         NI    TYPSYM,X'0F'            CLEAR BITS 0-3\n         MVC   SYMIND,8(R6)            INDICATOR BYTE\n         NI    SYMIND,X'0F'            CLEAR BITS 4-7\n         MVC   SYMARMOD,12(R6)         COPY RSECT/AMODE/RMODE BYTE\n         TM    8(R6),X'14'             POSSIBLE ENTAB/SEGTAB\n         BNO   CEMVAD                  NO\n         TM    8(R6),X'03'             IS IT ENTAB/SEGTAB\n         BNZ   CEMVAD                  NO\n         MVC   TYPSYM(2),=X'0F00'      SHOW ENTAB/SEGTAB\nCEMVAD   MVC   SYMADDR,9(R6)           ADDRESS OF SYMBOL\n         MVC   SYMSEG,12(R6)           SEGMENT WHERE DEFINED\n         MVC   SYMLENG,13(R6)          LENGTH OR LR ESD ID\n         STCM  R10,3,SYMESDID          ESD ID\n         MVC   PRT+5(8),EXTSYM         SYMBOL NAME\n         MVC   PRT+20(2),=C'SD'        ASSUME SD\n         CLI   TYPSYM,0                IS IT SD\n         BE    CEPIND                  YES\n         MVC   PRT+20(2),=C'LR'        ASSUME LR\n         CLI   TYPSYM,3                IS IT LR\n         BE    CEPIND                  YES\n         MVC   PRT+20(2),=C'ER'        ASSUME ER\n         CLI   TYPSYM,2                IS IT ER\n         BE    CEPIND                  YES\n         MVC   PRT+20(2),=C'PC'        ASSUME PC\n         CLI   TYPSYM,4                IS IT PC\n         BE    CEPIND                  YES\n         MVC   PRT+20(2),=C'PR'        ASSUME PR\n         CLI   TYPSYM,6                IS IT PR\n         BE    CEPIND                  YES\n         MVC   PRT+20(2),=C'CM'        ASSUME CM\n         CLI   TYPSYM,5                IS IT CM\n         BE    CEPIND                  YES\n         MVC   PRT+20(2),=C'WX'        ASSUME WX\n         CLI   TYPSYM,X'0A'            IS IT WX\n         BE    CEPIND                  YES\n         MVC   PRT+19(4),=C'NULL'      ASSUME NULL\n         CLI   TYPSYM,7                IS IT NULL\n         BE    CEPIND                  YES\n         MVC   PRT+18(6),=C'E/STAB'    ASSUME ENTAB/SEGTAB\n         CLI   TYPSYM,X'0F'            IS IT ENTAB/SEGTAB\n         BE    CEPIND                  YES\n         MVC   PRT+18(4),=C' ??: '     UNIDENTIFIABLE TYPE\n         LA    R12,TYPSYM              @ TYPE\n         BAL   R9,HEXPRT1              CONVERT\n         MVC   PRT+23(2),PRTABL        TYPE\nCEPIND   LA    R12,SYMIND              @ INDICATOR\n         BAL   R9,HEXPRT1              CONVERT\n         MVC   PRT+27(1),PRTABL        INDICATOR\n         LA    R12,SYMADDR             @ SYMBOL ADDR\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   PRT+30(6),PRTABL        SYMBOL ADDR\n         LA    R12,SYMSEG              @ SEGMENT NBR\n         BAL   R9,HEXPRT1              CONVERT\n         MVC   PRT+39(2),PRTABL        SEGMENT NBR\n         CLI   TYPSYM,2                IS IT ER\n         BE    CEESD                   YES\n         CLI   TYPSYM,3                IS IT AN LR\n         BNE   CENOTLR                 NO\n         LA    R12,SYMLRID             @ LR ESD ID\n         BAL   R9,HEXPRT2              CONVERT\n         MVC   PRT+43(4),PRTABL        LR ESD ID\n         B     CEESD                   CONTINUE\nCENOTLR  LA    R12,SYMLENG             @ LENGTH\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   PRT+49(6),PRTABL        SYMBOL LENGTH\nCEESD    LA    R12,SYMESDID            @ ESD ID\n         BAL   R9,HEXPRT2              CONVERT\n         MVC   PRT+57(4),PRTABL        ESD ID\n         MVC   PRT+65(3),=C'YES'       RSECT\n         TM    SYMARMOD,X'08'          YES\n         BO    CEAMODE\n         MVC   PRT+65(3),=C'NO '       RSECT\nCEAMODE  MVC   PRT+72(3),=C'ANY'       AMODE\n         TM    SYMARMOD,X'03'\n         BO    CERMODE\n         MVC   PRT+72(3),=C'31 '       31\n         TM    SYMARMOD,X'20'\n         BO    CERMODE\n         MVC   PRT+72(3),=C'24 '       24\nCERMODE  MVC   PRT+79(3),=C'ANY'       RMODE\n         TM    SYMARMOD,X'04'\n         BO    CECONT\n         MVC   PRT+79(3),=C'24 '\nCECONT   TM    PROCESS,X'80'           FOUND CSECT\n         BO    CESDPT                  YES\n         CLI   TYPSYM,0                SD\n         BE    CECKCSB                 YES\n         CLI   TYPSYM,4                PC\n         BNE   CESDPT                  NO\nCECKCSB  CLC   CSECT,BLANX             ANY CSECT NAME ENTERED\n         BNE   CECKNM                  YES\n         MVC   CSECT,EXTSYM            NAME TO CSECT\n         B     CSGOTCS                 CONTINUE\nCECKNM   CLI   TYPSYM,4                PC\n         BE    CESDPT                  YES\n         CLC   CSECT,EXTSYM            FOUND DESIRED NAME\n         BNE   CESDPT                  NO\n         TM    PROCESS,X'80'           ALREADY FOUND CSECT\n         BZ    CSGOTCS                 NO\n         MVC   PRT+15(2),=C'??'        SHOW DUPL\n         B     CESDPT                  CONTINUE\nCSGOTCS  OI    PROCESS,X'80'           SHOW CSECT FOUND\n         MVC   PRT+15(2),=C'**'        FLAG ON PRINTOUT\n         MVC   ESDID,SYMESDID          SAVE ESD ID FOUND\n         MVC   START+1,SYMADDR         SAVE CSECT START ADDR\n         MVC   LENGTH+1(3),SYMLENG     SAVE CSECT LENGTH\n         L     R1,LENGTH               PICK UP LENGTH\n         A     R1,START                COMPUTE CSECT END ADDR\n         ST    R1,END                  SAVE CSECT END ADDR\n         L     R11,LENGTH              TEXT LENGTH\n         LA    R11,256(R11)            ADD FOR SAFETY\n         GETMAIN R,LV=(11)             GET STORAGE FOR TEXT\n         ST    R1,TXTSTRT              SAVE TEXT ADDR\n         SH    R11,H256                DEDUCT SAFETY FACTOR\n         AR    R1,R11                  TXT END ADDR\n         ST    R1,TXTEND               SAVE TEXT END ADDR\nCESDPT   BAL   R9,PRINT                PRINT\n         LA    R7,L'SYMENT(R7)         TO NEXT TBL ENTRY LOCATION\n         LA    R10,1(R10)              ADD 1 TO ESD COUNTER\n         LA    R6,16(R6)               TO NEXT ESD ITEM IN INPUT\n         BCT   R8,CESDNXT              LOOP THRU INPUT RECORD\n         MVI   0(R7),X'FF'             SET END OF TABLE INDIC\n         ST    R7,CURRSYM              SAVE NEXT TABLE ADDR\n         L     R9,CES9                 GET RETURN ADDR\n         BR    R9                      EXIT\n         DROP  R7\n*\n*\n*\n****************************************************************\n*                                                              *\n* ISSUE BLDL FOR THE MAIN MODULE, AND PRINT MODULE RELATED INFO*\n*                                                              *\n****************************************************************\n*\nBLDL     EQU   *                       ISSUE BLDL AND PRINT INFO\n         ST    R9,BL9                  SAVE RETURN ADDR\nISSBLDL  BLDL  SYSLIB,BLDLIST          ISSUE BLDL\n         LTR   R15,R15                 ANY ERRORS\n         BNZ   MISSMEM                 YES\n         LA    R1,MEMBER+35            END OF BASIC PORTION\n         TM    ATTR2,X'10'             SSI PRESENT\n         BZ    BLREFA1                 NO\n         LA    R1,4(R1)                ADD FOR SSI\n         LR    R15,R1                  COPY FOR HALF WORD CHECK   ACF\n         SRL   R15,1                   SHIFT OUT LAST BIT         ACF\n         SLL   R15,1                   AND BACK AGAIN             ACF\n         CR    R1,R15                  CHECK AGAINST ORIGINAL     ACF\n         BE    BLREFA1                 NO ADJUSTMENT NECESSARY    ACF\n         LA    R1,1(R1)                NOW PTS TO HALFWORD BNDRY  ACF\nBLREFA1  TM    ALIASIND,X'80'          ALIAS\n         BZ    BLREFA2                 NO\n         LA    R1,11(R1)               ADD FOR ALIAS\nBLREFA2  TM    ATTR1A,X'04'            SCATTER FORMAT\n         BZ    BLREFA3                 NO\n         LA    R1,8(R1)                ADD FOR SCATTER\nBLREFA3  MVC   AUTHLEN(2),0(R1)        AUTH LENGTH AND CODE\n         TM    ATTR2,X'10'             SSI PRESENT\n         BZ    BLCKALI                 NO\n         LA    R1,MEMBER+35            END OF BASIC PORTION\n         TM    ATTR1A,X'04'            SCATTER FORMAT\n         BZ    BLSSI2                  NO\n         TM    ALIASIND,X'80'          ALIAS\n         BO    BLFMTED                 YES, NO REFORMAT NEEDED\n         LA    R1,8(R1)                NO, STEP PAST SCATTER SECTION\n         B     BLMVSSI                 GO MOVE SSI\nBLSSI2   TM    ALIASIND,X'80'          ALIAS\n         BZ    BLMVSSI                 NO\n         LA    R1,11(R1)               YES, STEP PAST ALIAS SECTION\nBLMVSSI  EQU   *                                                  ACF\n         LR    R15,R1                  COPY FOR HALF WORD CHECK   ACF\n         SRL   R15,1                   SHIFT OUT LAST BIT         ACF\n         SLL   R15,1                   AND BACK AGAIN             ACF\n         CR    R1,R15                  CHECK AGAINST ORIGINAL     ACF\n         BE    BLMVSSI1                NO ADJUSTMENT NECESSARY    ACF\n         LA    R1,1(R1)                NOW PTS TO HALFWORD BNDRY  ACF\nBLMVSSI1 MVC   SSI,0(R1)               MOVE SSI DATA\nBLCKALI  TM    ALIASIND,X'80'          ALIAS\n         BO    BLASC                   YES\n         B     BLFMTED                 FINISHED\nBLASC    TM    ATTR1A,X'04'            SCATTER FORMAT\n         BO    BLFMTED                 YES, NO REFORMAT NEEDED\n         MVC   ALMEM,MEMBER+38         MOVE ALIAS MEMBER\n         MVC   ALEPA(3),MEMBER+35      YES, MOVE ALIAS DATA\nBLFMTED  MVC   PRT(26),=C'DIRECTORY INFO FOR MODULE '\n         MVC   PRT+27(8),MEMBER        MEMBER NAME TO PRINT\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(14),=C'TTR OF MODULE='\n         LA    R12,TTRMOD              @ TTR\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   PRT+24(6),PRTABL        TTR TO PRINT\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(18),=C'CONCATENATION NBR='\n         LA    R12,CCAT                @ CONCATENATION NBR\n         BAL   R9,HEXPRT1              CONVERT\n         MVC   PRT+28(2),PRTABL        CONCATENATION NBR\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(12),=C'ALIAS INDIC='\n         LA    R12,ALIASIND            @ ALIAS INDICATOR\n         BAL   R9,HEXPRT1              CONVERT\n         MVC   PRT+22(2),PRTABL        ALIAS INDICATOR\n         TM    ALIASIND,X'80'          IS IT AN ALIAS\n         BZ    BLALPRT                 NO\n         MVC   PRT+50(13),=C'*** ALIAS ***'\nBLALPRT  BAL   R9,PRINT                PRINT\n         MVC   PRT+10(18),=C'TTR, 1ST TXT RECD='\n         LA    R12,TTR1TXT             @ TTR\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   PRT+28(6),PRTABL        TTR OF 1ST TXT BLOCK\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(25),=C'TTR OF NOTE/SCATTER LIST='\n         LA    R12,TTRNS               @ TTR\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   PRT+35(6),PRTABL        TTR OF NOTE/SCATTER\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(17),=C'NBR NOTE ENTRIES='\n         LA    R12,NNOTE               @ NBR NOTES\n         BAL   R9,HEXPRT1              CONVERT\n         MVC   PRT+27(2),PRTABL        NBR NOTE ENTRIES\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(13),=C'ATTRIBUTES 1='\n         LA    R12,ATTR1A              @ ATTRIBUTES\n         BAL   R9,HEXPRT2              CONVERT\n         MVC   PRT+23(4),PRTABL        ATTRIBUTES 1\n         TM    ATTR1A,X'80'            RENT\n         BZ    BLAT1A                  NO\n         MVC   PRT+30(4),=C'RENT'\nBLAT1A   TM    ATTR1A,X'40'            REUS\n         BZ    BLAT1B                  NO\n         MVC   PRT+35(4),=C'REUS'\nBLAT1B   TM    ATTR1A,X'20'            OVLY\n         BZ    BLAT1C                  NO\n         MVC   PRT+40(4),=C'OVLY'\nBLAT1C   TM    ATTR1A,X'10'            TEST\n         BZ    BLAT1D                  NO\n         MVC   PRT+45(4),=C'TEST'\nBLAT1D   TM    ATTR1B,X'08'            OL\n         BZ    BLAT1E                  NO\n         MVC   PRT+50(2),=C'OL'\nBLAT1E   TM    ATTR1A,X'04'            SCTR\n         BZ    BLAT1F                  NO\n         MVC   PRT+53(4),=C'SCTR'\nBLAT1F   TM    ATTR1A,X'02'            EXEC\n         BZ    BLAT1G                  NO\n         MVC   PRT+58(4),=C'EXEC'\nBLAT1G   TM    ATTR1B,X'01'            REFR\n         BZ    BLAT1PRT                NO\n         MVC   PRT+63(4),=C'REFR'\nBLAT1PRT BAL   R9,PRINT                PRINT\n         MVC   PRT+10(13),=C'TOTAL LENGTH='\n         LA    R12,TOTVIRT             @ TOTAL LENGTH\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   PRT+23(6),PRTABL        TOTAL LENGTH OF MODULE\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(23),=C'LENGTH OF 1ST TXT RECD='\n         LA    R12,LENG1               @ 1ST TXT LENG\n         BAL   R9,HEXPRT2              CONVERT\n         MVC   PRT+33(4),PRTABL        LENGTH OF 1ST TXT BLOCK\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(11),=C'E. P. ADDR='\n         LA    R12,LKEPA               @ E.P. ADDR\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   PRT+21(6),PRTABL        E.P. ADDR\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(13),=C'ATTRIBUTES 2='\n         LA    R12,ATTR2               @ ATTRIBUTES 2\n         BAL   R9,HEXPRT1              CONVERT\n         MVC   PRT+23(2),PRTABL        ATTRIBUTES 2\n         TM    ATTR2,X'20'             PAGE ALIGNMENT\n         BZ    BLAT3A                  NO\n         MVC   PRT+30(16),=C'PAGE ALIGN REQRD'\nBLAT3A   TM    ATTR2,X'10'             SSI PRESENT\n         BZ    BLAT3PRT                NO\n         MVC   PRT+50(11),=C'SSI PRESENT'\nBLAT3PRT BAL   R9,PRINT                PRINT\n         TM    ATTR1A,X'04'            SCATTER FORMAT\n         BZ    BLFAL                   NO\n         MVC   PRT+10(8),=C'SCTRLEN='\n         LA    R12,SCTRLEN             @ SCATTER LIST LENGTH\n         BAL   R9,HEXPRT2              CONVERT\n         MVC   PRT+18(4),PRTABL        SCATTER LIST LENGTH\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(18),=C'TRANSLATE TBL LEN='\n         LA    R12,TTLEN               @ TRANS TBL LEN\n         BAL   R9,HEXPRT2              CONVERT\n         MVC   PRT+28(4),PRTABL        TRANSLATION TABLE LENGTH\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(18),=C'ESD ID OF 1ST TXT='\n         LA    R12,SCESDID             @ ESD ID\n         BAL   R9,HEXPRT2              CONVERT\n         MVC   PRT+28(4),PRTABL        ESD ID OF 1ST TXT\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(23),=C'ESD ID CONTAINING E.P.='\n         LA    R12,SCEPESD             @ ESD ID\n         BAL   R9,HEXPRT2              CONVERT\n         MVC   PRT+33(4),PRTABL        @ ESD ID OF CSECT CONTAINING E.P\n         BAL   R9,PRINT                PRINT\nBLFAL    TM    ALIASIND,X'80'          ALIAS\n         BZ    BLFSSI                  NO\n         MVC   PRT+10(28),=C'E.P. ADDRESS OF THIS MEMBER='\n         LA    R12,ALEPA               @ E.P. ADDR\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   PRT+38(6),PRTABL        E.P. ADDR\n         BAL   R9,PRINT\n         MVC   PRT+10(17),=C'REAL MEMBER NAME='\n         MVC   PRT+27(8),ALMEM         REAL MEMBER NAME\n         BAL   R9,PRINT\nBLFSSI   TM    ATTR2,X'10'             ANY SSI INFO\n         BZ    BLAUTHC                 NO\n         MVC   PRT+10(9),=C'SSI INFO='\n         LA    R12,SSI                 @ SSI INFO\n         BAL   R9,HEXPRT4              CONVERT\n         MVC   PRT+19(8),PRTABL        SSI INFO\n         BAL   R9,PRINT                PRINT\nBLAUTHC  MVC   PRT+10(10),=C'AUTH CODE='\n         LA    R12,AUTHCOD             @ AUTH CODE\n         BAL   R9,HEXPRT1              CONVERT\n         MVC   PRT+20(2),PRTABL        AUTH CODE\n         BAL   R9,PRINT                PRINT\nBLMODES  MVC   PRT+10(9),=C'AMODE=24 '\n         LA    R9,3                    BIT MASK FOR TM OF MAIN MEMBER\n         TM    ALIASIND,X'80'          ALIAS\n         BZ    *+8\n         LA    R9,12                   BIT MASK FOR TM OF ALIAS\n         EX    R9,EXTM                 AMODE OF MAIN/ALIAS\n         BZ    BLMODEP\n         MVC   PRT+16(3),=C'ANY'\n         BO    BLMODEP\n         MVC   PRT+16(3),=C'31 '\nBLMODEP  BAL   R9,PRINT                PRINT\n         MVC   PRT+10(9),=C'RMODE=24 '\n         TM    ATTR2A,X'10'            TEST FOR ANY RESIDENCE MODE\n         BZ    *+10                    BR ROUND NEXT MVC INSTR\n         MVC   PRT+16(3),=C'ANY'       MOVE IN ANY\n         BAL   R9,PRINT                PRINT\n         TM    ALIASIND,X'80'          ALIAS\n         BZ    BLXIT                   NO\n         MVC   PRT+5(38),=C'***** REAL MEMBER DIRECTORY INFO *****'\n         MVI   PCC,C'0'                DOUBLE SPACE\n         BAL   R9,PRINT                PRINT\n         MVC   MEMBER,ALMEM            REAL MEMBER NAME TO LIST\n         B     ISSBLDL                 DO OVER FOR REAL MEMBER\nBLXIT    L     R9,BL9                  GET RETURN ADDR\n         BR    R9                      EXIT\n*\nEXTM     TM    ATTR2A,X'00'            AMODE OF MAIN X'03', ALIAS X'0C'\n*\n*\n****************************************************************\n*                                                              *\n* CREATE PRINTABLE HEX FROM HEX. ON ENTRY, REG 12 CONTAINS THE *\n* ADDRESS OF THE DATA TO BE REFORMATTED. ENTRY POINT USED      *\n* DETERMINES THE SIZE OF THE FIELD. OUTPUT DATA IS PLACED IN   *\n* THE PRTABL FIELD, 2 CHARACTERS PER BYTE.                     *\n*                                                              *\n****************************************************************\n*\nHEXPRT   EQU   *                       HEX TO PRINTABLE ROUTINE\nHEXPRT1  UNPK  PRTABL(3),0(2,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT2  UNPK  PRTABL(5),0(3,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT3  UNPK  PRTABL(7),0(4,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT4  UNPK  PRTABL(9),0(5,R12)      UNPACK HEX\nHEXCLTR  MVZ   PRTABL(8),XZROS         CLEAR FOR TRANSLATE\n         TR    PRTABL(8),TRTBL         MAKE PRINTABLE\n         BR    R9                      EXIT\n*\n*\n*\n****************************************************************\n*                                                              *\n* PRINT USING SYSPRINT.                                        *\n*                                                              *\n****************************************************************\n*\nPRINT    EQU   *                       PRINT ROUTINE\n         TM    SYSPRINT+48,X'10'       IS SYSPRINT OPEN\n         BNO   TPUT                    NO\n         PUT   SYSPRINT,PRTLINE        WRITE PRINT LINE\nCLRPRT   MVC   PRT,BLANX               CLEAR PRINT LINE\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C' '                SINGLE SPACED\n         BE    SETSGL                  YES\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C'0'                DOUBLE SPACED\n         BE    SETSGL                  YES\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C'-'                TRIPLE SPACED\n         BE    SETSGL                  YES\n         ZAP   LINECT,P0               NO, MUST BE NEW PAGE\nSETSGL   MVI   PCC,C' '                SET SINGLE SPACING\n         CP    LINECT,P58              PAST END OF PAGE\n         BH    NEWPAGE                 YES\n         BR    R9                      EXIT\nNEWPAGE  MVI   PCC,C'1'                SET SKIP TO HOF\n         ZAP   LINECT,P0               RESET LINE COUNTER\n         BR    R9                      EXIT\nTPUT     DS    0H\n         TPUT  PRT,L'PRT\n         BR    R9                      EXIT\n*\n*\n****************************************************************\n*                                                              *\n* PROCESS THE CONTROL CARD CONTAINING MODULE NAME AND CSECT.   *\n* THIS MUST BE THE FIRST CARD IN THE SYSIN DECK.               *\n*                                                              *\n****************************************************************\n*\nGETCTL   EQU   *                       EXTRACT DESIRED MEMBER/CSECT\n         SPACE 1                                                    RH\n         RDJFCB SYSLIB                   GET MEMBER NAME FROM JFCB  RH\n         LTR   R15,R15                   RDJFCB SUCCESSFUL ?        RH\n         BNZ   GETCTL2                   NO, GO READ SYSIN          RH\n         SPACE 1                                                    RH\n         CLI   JFCBMBR,C' '              ANY MEMBER NAME ?          RH\n         BE    GETCTL2                   NO, GO READ SYSIN          RH\n         SPACE 1                                                    RH\n         MVC   MEMBER,JFCBMBR          MOVE MEMBER TO BLDL LIST     RH\n         BR    R9                      RETURN TO CALLER             RH\n         SPACE 1                                                    RH\nGETCTL2  DS    0H                                                   RH\n         TM    SYSIN+48,X'10'          DID SYSIN OPEN O.K.          RH\n         BZ    NOCTL                   NO                           RH\n         GET   SYSIN                   READ THE CONTROL CARD\n         LA    R12,72                  LENGTH OF CONTROL CARD\n         LA    R11,8                   MAX LENGTH OF MEMBER NAME\n         LA    R10,MEMBER              @ MEMBER NAME FIELD\nCKBLK1   CLI   0(R1),C' '              CONTROL BYTE IS BLANK\n         BNE   GCMEMOV                 NO, GO MOVE MEMBER NAME\n         LA    R1,0(R1)                TO NEXT CONTROL BYTE\n         BCT   R12,CKBLK1              SUBTRACT 1 FROM REMAINING LENGTH\n         B     GCEND                   ALL BLANKS, EXIT\nGCMEMOV  MVC   0(1,R10),0(R1)          CONTROL BYTE TO MEMBER NAME\n         LA    R1,1(R1)                TO NEXT CONTROL BYTE\n         BCTR  R12,R0                  SUBTRACT 1 FROM LENGTH\n         LA    R10,1(R10)              TO NEXT NAME BYTE\n         BCTR  R11,R0                  SUBTRACT 1 FROM LENGTH\n         CLI   0(R1),C' '              GOT A BLANK\n         BE    GCSETUP2                YES\n         CLI   0(R1),C','              GOT A COMMA\n         BE    GCSETUP2                YES\n         LTR   R12,R12                 END OF CONTROL DATA\n         BE    GCEND                   YES\n         LTR   R11,R11                 NAME FULL\n         BNZ   GCMEMOV                 NO, CONTINUE\n         B     NAMEOV8                 YES, NAME TOO LONG\nGCSETUP2 LA    R11,8                   CSECT NAME MAX LENGTH\n         LA    R10,CSECT               @ CSECT NAME FIELD\nGCSTEP2  LA    R1,1(R1)                STEP PAST BLANK\n         BCT   R12,GCHKBK2             CHECK NEXT FOR BLANK\n         B     GCEND                   END OF SCAN\nGCHKBK2  CLI   0(R1),C' '              CONTROL DATA IS BLANK\n         BE    GCSTEP2                 YES\nGCCSMOV  MVC   0(1,R10),0(R1)          CONTROL BYTE TO CSECT NAME\n         LA    R1,1(R1)                TO NEXT CONTROL BYTE\n         LA    R10,1(R10)              TO NEXT NAME BYTE\n         BCTR  R12,R0                  DEDUCT 1 FROM CONTROL LENGTH\n         BCTR  R11,R0                  DEDUCT 1 FROM NAME LENGTH\n         LTR   R12,R12                 ANY CONTROL BYTES LEFT\n         BZ    GCEND                   NO\n         CLI   0(R1),C' '              NEXT CONTROL BYTE BLANK\n         BE    GCEND                   YES\n         LTR   R11,R11                 ANY NAME BYTES LEFT\n         BNZ   GCCSMOV                 YES, LOOP\n         B     NAMEOV8                 NAME TOO LONG, ERROR\nGCEND    CLC   MEMBER,BLANX            ANY MEMBER NAME FOUND\n         BE    NOMBR                   NO\n         BR    R9                      EXIT\n*\n*\n*\n****************************************************************\n*                                                              *\n* MISCELLANEOUS ERROR MESSAGES.                                *\n*                                                              *\n****************************************************************\n*\nERRORS   EQU   *                       ERROR END MESSAGES\nNOCTL    MVC   PRT(L'NOCNTRL),NOCNTRL  NO CONTROL INFO MESSAGE\n         B     ERREND                  GO PRINT\nNAMEOV8  MVC   PRT(L'OVER8),OVER8      NAME OVER 8 MESSAGE\n         B     ERREND                  GO PRINT\nNOMBR    MVC   PRT(L'NOMEM),NOMEM      MISSING MEMBER NAME MESSAGE\n         B     ERREND                  GO PRINT\nMISSMEM  MVC   PRT(L'INVMEM),INVMEM    MEMBER NOT IN PDS MESSAGE\n         B     ERREND                  GO PRINT\nMISSCS   MVC   PRT(L'INVCSECT),INVCSECT CSECT NOT IN MEMBER MESSAGE\n         B     ERREND                  GO PRINT\nSYMFULL  MVC   PRT(L'FULLSYM),FULLSYM  FULL SYM TBL MSG\n         B     ERREND                  GO PRINT\nRLDFULL  MVC   PRT(L'FULLRLD),FULLRLD  RLD TBL FULL MSDG\n         B     ERREND                  GO PRINT\nERREND   DS    0H\n         TPUT  PRT,L'PRT\n         BAL   R9,PRINT                GO PRINT MESSAGE\n         CLOSE (SYSPRINT)\n         ABEND 888,DUMP                ABEND\n*\n*\n*\n*\n****************************************************************\n*                                                              *\n* COUNT THE ENTRIES IN THE ESD TABLE WHICH WILL RESULT IN      *\n* ENTRIES IN THE LABEL TABLE.                                  *\n*                                                              *\n****************************************************************\nENDINIT  EQU   *                       *** FINAL PROCESSING ***\n*\n         L     R6,SYMTBAD              GET @ ESD TABLE\n         USING SYMTBL,R6\n         LA    R7,4                    INITIAL LABEL COUNT VALUE\nSYMCNT   CLI   0(R6),X'FF'             END OF ESD TBL\n         BE    RLDCNT                  YES\n         CLI   TYPSYM,3                IS ESD AN LR ENTRY\n         BNE   SCSTP                   NO, IGNORE\n         CLC   SYMADDR,START+1         ADDR BELOW DESIRED CSECT\n         BL    SCSTP                   YES, IGNORE\n         CLC   SYMADDR,END+1           ADDR ABOVE DESIRED CSECT\n         BH    SCSTP                   YES, IGNORE\n         LA    R7,1(R7)                ADD TO LABEL COUNT\n         MVC   SYMLENG,=C'***'         FLAG AS USABLE\nSCSTP    LA    R6,L'SYMENT(R6)         TO NEXT ESD ENTRY\n         B     SYMCNT\n         DROP  R6\n*\n****************************************************************\n*                                                              *\n* COUNT THE ENTRIES IN THE RLD TABLE WHICH WILL RESULT IN      *\n* ENTRIES IN THE LABEL TABLE.                                  *\n*                                                              *\n****************************************************************\n*\nRLDCNT   L     R6,RLDTBL               GET RLD TBL ADDR\n         USING RLDTBLD,R6\nRLDCEND  CLI   0(R6),X'FF'             END OF RLD TABLE\n         BE    LBLGET                  YES\n         CLC   RLDRP,ESDID             ESDID SAME AS DESIRED CSECT\n         BNE   RLDC1                   NO, EXTRN REF\n         LA    R7,1(R7)                ADD 1 TO LABEL COUNT\nRLDC1    LA    R7,1(R7)                ADD 1 TO LABEL COUNT\n         LA    R6,L'RLDENT(R6)         TO NEXT RLD ENTRY\n         B     RLDCEND                 LOOP THRU RLD TBL\n         DROP  R6\nLBLGET   MH    R7,LBLLGTH              COMPUTE LABEL TABLE SIZE\n         L     R1,LENGTH               GET CSECT LENGTH\n         SRL   R1,2                    DIVIDE BY 4\n         MH    R1,LBLLGTH              TIMES LABEL ENTRY LENGTH\n         AR    R7,R1                   TOTAL LABEL TABLE LENGTH\n*\n****************************************************************\n*                                                              *\n* CREATE INITIAL ENTRIES IN THE LABEL TABLE USING DATA FROM    *\n* THE ESD AND RLD TABLES.                                      *\n*                                                              *\n****************************************************************\n*\n         GETMAIN R,LV=(7)              GET LABEL TBL STORAGE\n         ST    R1,LBLTBL               SAVE LABEL TBL ADDR\n         ST    R1,CURRLBL              SAVE CURRENT LABEL ADDR\n         AR    R1,R7                   COMPUTE LABEL TBL END ADDR\n         ST    R1,ENDLBL               SAVE END OF LBL TBL ADDR\n         L     R6,LBLTBL               GET @ LABEL TABLE\n         USING LABELD,R6\n         L     R7,SYMTBAD              GET ESD TBL ADDR\n         USING SYMTBL,R7\n         CLC   LKEPA,XZROS             E.P. ADDR ZERO\n         BE    LRENTS                  YES\n         SR    R1,R1                   CLEAR WORK\n         ICM   R1,7,LKEPA              PICK UP E.P. ADDR\n         S     R1,START                RELATIVIZE IN CSECT\n         BM    LRENTS                  NEG, ERROR\n         STCM  R1,7,LBLADR             SAVE OFFSET\n         MVI   LBLTYP,C'L'             SET LABEL TYPE IN ENTRY\n         LA    R12,LBLADR              POINT TO OFFSET\n         BAL   R9,HEXPRT3              CONVERT TO PRINTABLE\n         MVI   LBLNAME,C'A'            1ST CHAR OF LABEL IS 'A'\n         MVC   LBLNAME+1(6),PRTABL     END OF LABEL IS OFFSET\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY\n         ST    R6,CURRLBL              SAVE IT'S ADDRESS\nLRENTS   CLI   0(R7),X'FF'             END OF ESD TBL\n         BE    RLDLBLS                 YES\n         CLC   SYMLENG,=C'***'         THIS DESIRED LR ENTRY\n         BE    GOTLR                   YES\nLRESTP   LA    R7,L'SYMENT(R7)         TO NEXT ESD ENTRY\n         B     LRENTS                  LOOP THRU ESD TBL\nGOTLR    SR    R12,R12                 CLEAR WORK REG\n         ICM   R12,7,SYMADDR           GET SYMBOL ADDR\n         S     R12,START               RELATIVIZE IN CSECT\n         STCM  R12,7,LBLADR            SAVE RELATIVE ADDR\n         MVC   LBLNAME,EXTSYM          SYMBOL NAME TO OUTPUT\n         MVI   LBLTYP,C'L'             SHOW LABEL ENTRY\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY\n         ST    R6,CURRLBL              SAVE NEXT LABEL ENTRY ADDR\n         B     LRESTP                  CONTINUE ESD PROCESSING\n         DROP  R7\nRLDLBLS  L     R7,RLDTBL               GET RLD TBL ADDR\n         USING RLDTBLD,R7\nRLDLBND  CLI   0(R7),X'FF'             END OF RLD TABLE\n         BE    PHASE1                  YES\n         CLC   RLDRP,ESDID             RLD ESDID = DESIRED CSECT ESDID\n         BE    INTREFS                 YES, INTERNAL ADCON\n         CLI   RLDTYPE,1               VCON\n         BE    EXTREFS                 YES\n         CLI   RLDTYPE,8               IS IT UNRESOLVED\n         BE    EXTREFS                 YES\nRLLSTP   LA    R7,L'RLDENT(R7)         TO NEXT RLD ENTRY\n         B     RLDLBND                 LOOP THRU RLD TABLE\nEXTREFS  CLI   RLDESDTP,X'0A'          W-CON\n         BNE   VCONLBL                 NO, BUILD V-CON\n         MVI   LBLTYP,C'W'             SHOW W-CON\n         B     FXTLBL                  CONTINUE LABEL ENTRY FORMAT\nVCONLBL  MVI   LBLTYP,C'V'             SHOW V-CON\nFXTLBL   MVC   LBLNAME,RLDNAME         NAME TO LABEL ENTRY\nFINLBL   MVC   LBLADR,RLDADDR          ADDRESS TO LABEL ENTRY\n         MVC   LBLLEN,RLDLEN           LENGTH TO LABEL ENTRY\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL TBL ENTRY\n         ST    R6,CURRLBL              SAVE CURRENT LABEL TBL ADDR\n         B     RLLSTP                  CONTINUE LABEL TABLE BUILD\nINTREFS  CLI   RLDTYPE,0               A-CON\n         BNE   RLLSTP                  NO, IGNORE\n         MVI   LBLTYP,C'L'             SHOW LABEL ENTRY TYPE\n         SR    R12,R12                 CLEAR WORK REG\n         ICM   R12,7,RLDADDR           GET RLD ADDR\n         A     R12,TXTSTRT             FIND LOC IN TEXT\n         MVC   LBLADR,1(R12)           MOVE TO LABEL ENTRY\n         CLI   RLDLEN,4                ADCON IS 4-BYTES\n         BE    INTGOTL                 YES\n         MVC   LBLADR,0(R12)           TEXT TO LABEL ENTRY\n         CLI   RLDLEN,3                ADCON IS 3-BYTES\n         BE    INTGOTL                 YES\n         MVC   LBLADR+1(2),0(R12)      TEXT TO LABEL ENTRY\n         MVI   LBLADR,0                CLEAR 1ST BYTE\n         CLI   RLDLEN,2                ADCON IS 2-BYTES\n         BE    INTGOTL                 YES\n         XC    LBLADR,LBLADR           CLEAR LABEL ENTRY ADDR\n         MVC   LBLADR+2(1),0(R12)      TEXT TO LABEL ENTRY\nINTGOTL  SR    R12,R12                 CLEAR WORK\n         ICM   R12,7,LBLADR            GET ADDRESS\n         S     R12,START               RELATIVIZE IN CSECT\n         BM    RLLSTP                  NEGATIVE, IGNORE\n         STCM  R12,7,LBLADR            STORE RELATIVE ADDRESS\n         LA    R12,LBLADR              POINT TO ADDRESS\n         BAL   R9,HEXPRT3              CONVERT TO PRINTABLE\n         MVI   LBLNAME,C'A'            SET LABEL ENTRY TYPE\n         MVC   LBLNAME+1(6),PRTABL     LOW ORDER NAME POSITIONS\n         MVI   LBLNAME+7,C' '          CLEAR LAST NAME BYTE\n         MVC   L'LABEL(L'LABEL,R6),0(R6) COPY THIS ENTRY TO NEXT\n         MVI   LBLLEN,0                SET LENGTH = 0\n         LA    R6,L'LABEL(R6)          STEP TO NEXT\n         MVI   LBLTYP,C'A'             SHOW TYPE\n         B     FINLBL                  FINISH LABEL\n         DROP  R6\n         DROP  R7\n*\n****************************************************************\n*                                                              *\n* LOAD AND EXECUTE PHASE 1: DISASM1                            *\n*                                                              *\n****************************************************************\n*\nPHASE1   MVC   0(3,R6),HIVAL           SET END OF LABEL TABLE  FIX***\n*        TM    LOADLIB+48,X'10'        LOADLIB DD CARD ENTERED\n*        BZ    NODCB1                  NO\n*        LOAD  EP=DISASM1,DCB=LOADLIB  LOAD PHASE1\n*        B     EXEC1                   CONTINUE\n*NODCB1   LOAD  EP=DISASM1              LOAD PHASE1\n*EXEC1    LR    R15,R0                  COPY E.P. ADDRESS\n*         LA    R1,=A(COMMPARM)         @ PARAMETER LIST\n*         BALR  R14,R15                 LINK TO PHASE1\n*         DELETE EP=DISASM1             DELETE AFTER USE\n****************************************************************\n*        CALLING SEQUENCE CODE\n         CALL  DISASM1,(COMMPARM)\n****************************************************************\n         CLI   USERR,0                 ANY ERRORS\n         BNE   CLOSES                  YES, STOP THE RUN\n*\n****************************************************************\n*                                                              *\n* PRINT THE LABEL TABLE AFTER PHASE 1 COMPLETION.              *\n*                                                              *\n****************************************************************\n*\n         MVC   PRTLINE(LPH1LBL),PH1LBL HEADER 1                     RH\n         BAL   R9,PRINT                PRINT IT\n         MVC   PRTLINE(LPH1HDR),PH1HDR HEADER 2                     RH\n         BAL   R9,PRINT                PRINT IT\n         L     R6,LBLTBL               GET LABEL TABLE ADDR\n         USING LABELD,R6\nLPEND    C     R6,CURRLBL              END OF TABLE       FIX****\n         BNL   FREESTRG                YES                FIX****\n         LA    R12,LBLADR              @ LABEL ADDRESS\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   PRT(6),PRTABL           ADDRESS TO PRINT\n         MVC   PRT+9(1),LBLTYP         TYPE TO PRINT\n         MVC   PRT+16(8),LBLNAME       SYMBOL TO PRINT\n         CLI   LBLLEN,0                ANY LENGTH\n         BE    LTPPRT                  NO\n         LA    R12,LBLLEN              GET @ LENGTH\n         BAL   R9,HEXPRT1              CONVERT\n         MVC   PRT+26(2),PRTABL        LENGTH TO PRINT\nLTPPRT   BAL   R9,PRINT                PRINT TBL ENTRY\n         LA    R6,L'LABEL(R6)          TO NEXT ENTRY\n         B     LPEND                   LOOP THRU TABLE\nFREESTRG L     R12,RLDTBL              @ RLD TABLE\n         FREEMAIN R,A=(12),LV=RLDTABL  FREE RLD TABLE\n*\n****************************************************************\n*                                                              *\n* PRINT THE TEXT FOR THE CSECT TO BE DISASSEMBLED,             *\n* IF HE  WANTS  IT,                                            *    RH\n*                                                              *\n****************************************************************\n*\n         CLI   TEXTFLAG,1         DOES HE WANT A HEX DUMP ?         RH\n         BNE   NOHEX              NO, BYPASS SOME CODE              RH\n         MVI   PCC,C'1'                SET SKIP TO HEAD\n         MVC   PRT+50(19),=C'***** T E X T *****'\n         BAL   R9,PRINT                PRINT TEXT HEADER\n         MVI   PCC,C'0'                SET DOUBLE SPACING\n         L     R11,TXTSTRT             GET TEXT START ADDRESS\nPNEXLIN  LA    R10,2                   GROUPS PER LINE\n         LA    R12,POFSET+1            @ OFFSET\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   PRT(6),PRTABL           OFFSET TO PRINT\n         MVC   PRT+85(32),0(R11)       TEXT TO PRINT\n         TR    PRT+85(32),PRTCHAR      TRANSLATE TO PRINTABLE\n         LA    R8,PRT+9                @ 1ST PRINT WORD\n         LA    R7,4                    4 WORDS PER GROUP\nPGRP     LA    R12,0(R11)              @ TEXT WORD\n         BAL   R9,HEXPRT4              CONVERT\n         MVC   0(8,R8),PRTABL          TEXT TO PRINT WORD\n         LA    R11,4(R11)              TO NEXT TEXT WORD\n         LA    R8,9(R8)                TO NEXT PRINT LOC\n         BCT   R7,PGRP                 DO 4 TIMES\n         LA    R8,2(R8)                SPACE BETWEEN GROUPS\n         LA    R7,4                    FOR 2ND GROUP\n         BCT   R10,PGRP                DO 4 MORE TIMES\n         BAL   R9,PRINT                PRINT THE LINE\n         L     R9,POFSET               GET OFFSET\n         LA    R9,32(R9)               ADD 32 BYTES\n         ST    R9,POFSET               UPDATE OFFSET\n         C     R11,TXTEND              END OF TEXT\n         BL    PNEXLIN                 NO, CONTINUE\n         SPACE 1                                                    RH\nNOHEX    DS    0H                                                   RH\n         MVI   PCC,C'1'                SET SKIP TO HEAD\n         MVC   WORKREC,BLANX           CLEAR OUTPUT RECORD\n         MVC   NAME,CSECT              CSECT NAME\n*\n****************************************************************\n*                                                              *\n* CREATE THE INITIAL CSECT INSTRUCTION, AND ANY ENTRY STATE-   *\n* MENTS WHICH MAY BE INDICATED BY ESD TABLE ENTRIES.           *\n*                                                              *\n****************************************************************\n*\n         SPACE 3                                                    RH\n********************************************************************RH*\n*                                                                   RH*\n*        ROUTINE TO PRINT HEADING.                                  RH*\n*                                                                   RH*\n********************************************************************RH*\n         SPACE 2                                                    RH\nL10HEAD  DS    0H                                                   RH\n         ZAP   LINECT,P0          SET LINE COUNTER TO 0             RH\n         AP    PAGECTR,P1         ADD 1 TO PAGE COUNTER             RH\n         L     R1,PRINTDCB             @ SYSPRINT DCB               RH\n         TM    48(R1),X'10'            IS SYSPRINT OPEN             RH\n         BNO   CLRPRT1                 NO                           RH\n         PUT   (1),PRTLINE        SKIP TO NEW PAGE                  RH\n         SPACE 1                                                    RH\n         MVC   PAGENO,=X'40202020'      EDIT PAGE NUMBER            RH\n         ED    PAGENO,PAGECTR           *                           RH\n         MVC   PRT,HEAD1                MOVE HEADING TO PRINT       RH\n         MVI   PCC,C' '           PRINT, SPACE 1                    RH\n         AP    LINECT,P1          ADD 1 TO LINE COUNT               RH\n         L     R1,PRINTDCB             @ SYSPRINT DCB               RH\n         PUT   (1),PRTLINE        PRINT HEADING                     RH\n         MVI   PRT,C' '           CLEAR PRINT LINE                  RH\n         MVC   PRT+1(131),PRT     CLEAR PRINT LINE                  RH\n         MVI   PCC,C'0'           SPACE 2 LINES                     RH\n         SPACE 1                                                    RH\nCLRPRT1  DS    0H                                                   RH\n*        BR    R9                       RETURN TO CALLER\n*                                                                   RH*\n********************************************************************RH*\n*                                                                   RH*\n         MVC   MNEMONIC,=C'CSECT'      SET MNEMONIC\n         BAL   R9,WRTOUT               WRITE OUTPUT RECORD\n         AP    STMTCTR,P1               ADD 1 TO STATEMENT COUNTER  RH\n         MVC   PSTMT-2(6),=X'402020202120' EDIT STATEMENT COUNTER   RH\n         ED    PSTMT-2(6),STMTCTR       *                           RH\n         BAL   R9,PRINT                AND PRINT IT\n         L     R7,SYMTBAD              GET ESD TBL ADDR\n         USING SYMTBL,R7\nLREFSS   CLI   0(R7),X'FF'             END OF ESD TBL\n         BE    CKLDLB                  YES\n         CLC   SYMLENG,=C'***'         THIS DESIRED LR ENTRY\n         BE    MAKEXT                  YES\nESDTSTP  LA    R7,L'SYMENT(R7)         TO NEXT ESD ENTRY\n         B     LREFSS                  LOOP THRU ESD TBL\nMAKEXT   MVC   MNEMONIC,=C'ENTRY'      MNEMONIC IS ENTRY\n         MVC   OPNDS(8),EXTSYM         SYMBOL TO OPERAND\n         BAL   R9,WRTOUT               WRITE OUTPUT RECORD\n         AP    STMTCTR,P1               ADD 1 TO STATEMENT COUNTER  RH\n         MVC   PSTMT-2(6),=X'402020202120' EDIT STATEMENT COUNTER   RH\n         ED    PSTMT-2(6),STMTCTR       *                           RH\n         BAL   R9,PRINT                AND PRINT IT\n         B     ESDTSTP                 CONTINUE ESD PROCESSING\n         DROP  R7\n         DROP  R6\nCKLDLB   L     R12,SYMTBAD             @ ESD SYMBOL TABLE\n*\n****************************************************************\n*                                                              *\n* LOAD AND EXECUTE PHASE 2: DISASM2                            *\n*                                                              *\n****************************************************************\n*\n         FREEMAIN R,A=(12),LV=SYMTABL  FREE SYMBOL TABLE\n*         TM    LOADLIB+48,X'10'        LOADLIB DD CARD SUPPLIED\n*         BZ    NODCB                   NO\n*         LOAD  EP=DISASM2,DCB=LOADLIB  LOAD DISASM2\n*         B     EXEC2                   CONTINUE\n*NODCB    LOAD  EP=DISASM2              LOAD DISASM2\n*EXEC2    LR    R15,R0                  COPY E.P. ADDRESS\n*         LA    R1,=A(COMMPARM)         GET PARAMETER ADDRESS\n*         BALR  R14,R15                 CALL DISASM2\n*         DELETE EP=DISASM2             DELETE AFTER USE\n****************************************************************\n*        CALLING SEQUENCE CODE\n         CALL  DISASM2,(COMMPARM)\n****************************************************************\n         B     EOJ                     GO FINISH\n*\n*\n*\n*\n*\n*\n****************************************************************\n*                                                              *\n* WRITE OUTPUT TO SYSPUNCH.                                    *\n*                                                              *\n****************************************************************\n*\nWRTOUT   EQU   *                       WRITE OUTPUT RECORDS\n*        MVC   PRT+30(80),WORKREC      SAVE IN PRINT            ACF RH\n         MVC   PLABEL(80),WORKREC SAVE IN PRINT                     RH\n         TM    SYSPUNCH+48,X'10'       IS FILE OPEN\n         BZ    CLRWKR                  NO\n         AP    CARDNO,=P'10'           INCREMENT CARD NO\n         UNPK  SEQNBR,CARDNO           UNPACK INTO CARD\n         OI    SEQNBR+7,C'0'           CLEAR SIGN\n         MVC   PSEQ,SEQNBR        PUT SEQ NBR ON PRINTOUT RECORD    RH\n         PUT   SYSPUNCH,WORKREC        WRITE SOURCE CARD\nCLRWKR   MVC   WORKREC,BLANX           CLEAR OUTPUT RECORD\n         BR    R9                      RETURN\n*\n*\n*\n****************************************************************\n*                                                              *\n* END OF JOB. DISASSEMBLY COMPLETE.                            *\n*                                                              *\n****************************************************************\nEOJ      EQU   *                       END OF JOB\nEOFSW    B     NOCTL                   RESET IF CTL CARD FOUND\n*        MVC   MNEMONIC,=CL5'REQU'     SET MNEMONIC                 RH\n*        BAL   R9,WRTOUT               WRITE RECORD                 RH\n*        BAL   R9,PRINT                GO PRINT IT                  RH\n*                                                                   RH\n****************************************************************    RH\n*                                                              *    RH\n* PRINT  REGISTER EQUATES.                                     *    RH\n*                                                              *    RH\n****************************************************************    RH\n         BAL   R9,PRINT           PRINT A BLANK LINE                RH\n         LA    R12,ENDTAB         R12 -> TO END TABLE               RH\n         LA    R11,16             R11 = # OF ENTRIES IN TABLE       RH\n         SPACE 1                                                    RH\nJ92      DS    0H                                                   RH\n         MVC   NAME(17),0(R12)           MOVE ENTRY TO PRINT        RH\n         LA    R12,17(0,R12)             R12 -> TO NEXT ENTRY       RH\n         BAL   R9,WRTOUT               WRITE RECORD                 RH\n         BAL   R9,PRINT                GO PRINT IT                  RH\n         BCT   R11,J92                 IF R11 > 0, BRANCH           RH\n         SPACE 1                                                    RH\n*                                                                   RH\n****************************************************************    RH\n*                                                              *    RH\n* PRINT  DSECTS.                                               *    RH\n*                                                              *    RH\n****************************************************************    RH\n         L     R12,DTBSTRT             @ DSECT HEADER TBL\nCENDSTB  CLI   0(R12),X'FF'            END OF TABLE\n         BE    ENDSTMT                 YES\n         BAL   R9,PRINT           PRINT A BLANK LINE                RH\n         MVC   NAME,0(R12)             DSECT NAME TO RECORD\n         MVC   MNEMONIC(5),=C'DSECT'   OPERATION IS DSECT\n         BAL   R9,WRTOUT               WRITE DSECT HEADER\n         BAL   R9,PRINT                AND PRINT IT\n         ICM   R11,7,8(R12)            GET FIELD TABLE ADDR\n         USING DSECTD,R11\nCENDFTB  CLI   0(R11),X'FF'            END OF FIELD TABLE\n         BNE   DFMTFLD                 NO\n         LA    R12,11(R12)             TO NEXT DSECT HEADER\n         B     CENDSTB                 LOOP\nDFMTFLD  MVC   NAME,DSNAME             NAME TO RECORD\n         AGO   .DROP1                                               RH\n****************************************************************    RH\n*                                                              *    RH\n* THIS CODE PRODUCES DSECTS LIKE SO:                           *    RH\n*                                                              *    RH\n* A   DSECT                                                    *    RH\n* B   EQU A,10                                                 *    RH\n* C   EQU A+10,10                                              *    RH\n* C   EQU A+20,10                                              *    RH\n* C   EQU A+30,10                                              *    RH\n*            . .....ETC.                                       *    RH\n*                                                              *    RH\n*                                                              *    RH\n*                                                              *    RH\n****************************************************************    RH\n         MVC   MNEMONIC(3),=C'EQU'     OPERATION IS EQU\n         MVC   OPNDS(8),0(R12)         BASE NAME TO OPERAND\n         LA    R10,OPNDS+7             @ NAME RHE\nCFRHE    CLI   0(R10),C' '             AT RHE\n         BNE   CFPLUS                  YES\n         BCT   R10,CFRHE               BACK UP 1 AND LOOP\nCFPLUS   LA    R10,1(R10)              TO NEXT POS\n         MVI   0(R10),C'+'             DELIMITER\n         SR    R1,R1                   CLEAR WORK\n         ICM   R1,7,DSOFSET            GET OFFSET\n         CVD   R1,DBLWD                CONVERT\n         UNPK  DBLWD(4),DBLWD+4(4)     UNPACK\n         OI    DBLWD+3,C'0'            CLEAR SIGN\n         CH    R1,H1000                OFFSET < 1000\n         BL    CFO100                  YES\n         MVC   1(4,R10),DBLWD          NO, MOVE 4-DIGIT OFFSET\n         LA    R10,5(R10)              TO NEXT POS\n         B     CFCMA                   CONTINUE\nCFO100   CH    R1,H100                 OFFSET < 100\n         BL    CFO10                   YES\n         MVC   1(3,R10),DBLWD+1        NO, MOVE 3-DIGIT OFFSET\n         LA    R10,4(R10)              TO NEXT POS\n         B     CFCMA                   CONTINUE\nCFO10    CH    R1,H10                  OFFSET < 10\n         BL    CFO1                    YES\n         MVC   1(2,R10),DBLWD+2        MOVE 2-DIGIT OFFSET\n         LA    R10,3(R10)              TO NEXT POS\n         B     CFCMA                   CONTINUE\nCFO1     LTR   R1,R1                   ANY OFFSET\n         BZ    CFCMA                   NO\n         MVC   1(1,R10),DBLWD+3        YES, MOVE 1-DIGIT OFFSET\n         LA    R10,2(R10)              TO NEXT POS\nCFCMA    MVI   0(R10),C','             DELIMITER\n         SR    R1,R1                   CLEAR WORK\n         ICM   R1,1,DSLENG             PICK UP LENGTH               RH\n         BNZ   CFL30              IF LTH = 0, IT'S REALLY 256       RH\n         LA    R1,256             SO SET R1 TO 256                  RH\nCFL30    DS    0H                                                   RH\n         CVD   R1,DBLWD                CONVERT\n         UNPK  DBLWD(3),DBLWD+4(4)     UNPACK\n         OI    DBLWD+2,C'0'            CLEAR SIGN\n         CH    R1,H100                 LENGTH < 100\n         BL    CFL10                   YES\n         MVC   1(3,R10),DBLWD          NO, MOVE 3-DIGIT LENGTH\n         B     CFWRT                   CONTINUE\nCFL10    CH    R1,H10                  LENGTH < 10\n         BL    CFL1                    YES\n         MVC   1(2,R10),DBLWD+1        NO, MOVE 2-DIGIT LENGTH\n         B     CFWRT                   CONTINUE\nCFL1     MVC   1(1,R10),DBLWD+2        MOVE 1-DIGIT LENGTH\n         AGO   .DROP2                                               RH\n.DROP1   ANOP                                                       RH\n****************************************************************    RH\n*                                                              *    RH\n* THIS CODE PRODUCES DSECTS LIKE SO:                           *    RH\n*                                                              *    RH\n* A   DSECT                                                    *    RH\n* B   DS  10X                                                  *    RH\n* C   DS  10X                                                  *    RH\n* C   DS  10X                                                  *    RH\n* C   DS  10X                                                  *    RH\n*            . .....ETC.                                       *    RH\n*                                                              *    RH\n*                                                              *    RH\n*                                                              *    RH\n****************************************************************    RH\n         MVC   MNEMONIC(2),=C'DS'      OPERATION IS DS              RH\n         LA    R10,OPNDS          R10 -> TO WHERE OPNDS GO          RH\n         SR    R1,R1                   CLEAR WORK                   RH\n         ICM   R1,1,DSLENG        R1 = LENGTH OF DS                 RH\n         BNZ   CFO20              LENGTH IS OKAY                    RH\n         LA    R1,256             R1 = 256                          RH\n*        LA    R9,L'DSECT(R11)    R9 -> TO NEXT DSECT FIELD         RH\n*        SR    R8,R8                   CLEAR WORK                   RH\n*        ICM   R1,7,DSOFSET-DSECT(R9) R1 = OFFSET OF NEXT FIELD     RH\n*        ICM   R8,7,DSOFSET       R8 = OFFSET OF THIS FIELD         RH\n*        SR    R1,R8              R1 = LTH OF THIS FIELD            RH\nCFO20    DS    0H                                                   RH\n         CVD   R1,DBLWD                CONVERT                      RH\n         UNPK  DBLWD(4),DBLWD+4(4)     UNPACK                       RH\n         OI    DBLWD+3,C'0'            CLEAR SIGN                   RH\n         CH    R1,H1000                OFFSET < 1000                RH\n         BL    CFO100                  YES                          RH\n         MVC   1(4,R10),DBLWD          NO, MOVE 4-DIGIT OFFSET      RH\n         LA    R10,5(R10)              TO NEXT POS                  RH\n         B     CFCMA                   CONTINUE                     RH\nCFO100   CH    R1,H100                 OFFSET < 100                 RH\n         BL    CFO10                   YES                          RH\n         MVC   1(3,R10),DBLWD+1        NO, MOVE 3-DIGIT OFFSET      RH\n         LA    R10,4(R10)              TO NEXT POS                  RH\n         B     CFCMA                   CONTINUE                     RH\nCFO10    CH    R1,H10                  OFFSET < 10                  RH\n         BL    CFO1                    YES                          RH\n         MVC   1(2,R10),DBLWD+2        MOVE 2-DIGIT OFFSET          RH\n         LA    R10,3(R10)              TO NEXT POS                  RH\n         B     CFCMA                   CONTINUE                     RH\nCFO1     LTR   R1,R1                   ANY OFFSET                   RH\n         BZ    CFCMA                   NO                           RH\n         MVC   1(1,R10),DBLWD+3        YES, MOVE 1-DIGIT OFFSET     RH\n         LA    R10,2(R10)              TO NEXT POS                  RH\nCFCMA    DS    0H                                                   RH\n         MVI   0(R10),C'X'        FIELD TYPE = X                    RH\n.DROP2   ANOP                                                       RH\nCFWRT    BAL   R9,WRTOUT               WRITE THE RECORD\n         BAL   R9,PRINT                PRINT THE RECORD\n         LA    R11,L'DSECT(R11)        TO NEXT FIELD ENTRY\n         B     CENDFTB                 LOOP\nENDSTMT  MVC   MNEMONIC,=CL5'END'      MNEMONIC TO OUTPUT RECORD\n         MVC   OPNDS(8),ENDLBLNM       POINT END STMT TO BEGIN LOC\n         BAL   R9,WRTOUT               WRITE THE RECORD\n         BAL   R9,PRINT                GO PRINT IT\nCLOSES   CLOSE (SYSLIB,,SYSPUNCH,,SYSPRINT,,SYSIN) CLOSE FILES\n         L     R13,4(R13)              GET POINTER TO CALLER'S SAVE ARE\n         LM    R14,R12,12(R13)         RESTORE CALLER'S REGS\n         SR    R15,R15                 CLEAR RETURN CODE\n         BR    R14                     RETURN TO CALLER\n         DROP  R11\n*\n*\n*\n*                 *** DATA AND WORK AREAS ***\n*\n*\n*\nBUFAD    DS    F                       SYSLIB BUFFER ADDR\nSYMTBAD  DS    F                       SYMBOL TABLE ADDRESS\nCURRSYM  DS    F                       CURRENT SYM TBL ADDR\nENDSYM   DC    A(SYMTABL)              SYM TBL END ADDR\nSYMTABL  EQU   80000       *** ACF - WAS 40000\nRLDTBL   DS    F                       ADDR OF RLD TABLE\nCURRLD   DS    F                       CURR RLD TBL ADDR\nENDRLD   DC    A(RLDTABL)              RLD TBL END ADDR\nRLDTABL  EQU   60000\nENDATO   DC    A(DATOLEN)              DATA ONLY TBL LENGTH\nDATOLEN  EQU   1536\nPROCESS  DC    XL1'00'                 PROCESS INDIC 80=SYM TBL BUILT\nCES9     DS    F                       CESDREC RETURN ADDR\nBL9      DS    F                       BLDL RTN RETURN ADDR\nCR9      DS    F                       CTRLRECS RETURN ADDR\nCT9      DS    F                       CNTLRECS RETURN ADDR\nRL9      DS    F                       RLDRECS RETURN ADDR\nTX9      DS    F                       TXTFMT RETURN ADDR\nHIVAL    DC    4X'FF'                  CONSTANT F'S\nH1000    DC    H'1000'                 CONSTANT 1000\nH100     DC    H'100'                  CONSTANT 100\nH10      DC    H'10'                   CONSTANT 10\nSYMLEN   DC    AL2(L'SYMENT)           LENGTH OF SYMTBL ENTRY        */\nPRTABL   DS    CL9                     HEX-PRINTABLE CONVERSION AREA\nP0       DC    P'0'                    CONSTANT 0\nP1       DC    P'1'                    CONSTANT 1\nP58      DC    P'58'                   CONSTANT 58\nJFCBAD   DS    0F                      DCB EXIT LIST\n         DC    X'87'                   RDJFCB, END OF LIST\n         DC    AL3(JFCB)               ADDRESS OF JFCB READ AREA\nJFCB     DS    CL176                   JFCB\n         ORG   JFCB                                                 RH\nJFCBDSN  DC    CL44' '                                              RH\nJFCBMBR  DC    CL8' '                                               RH\n         DC    CL124' '                                             RH\n         ORG   ,                                                    RH\n         SPACE 1                                                    RH\nSYMHDR   DC    C'0     SYMBOL        TYPE   IND  ADDR'\n         DC    C'    SEG  LRID   LENG  ESDID  RSECT  AMODE  RMODE'\n*        DC    CL64' '\nLSYMHDR  EQU   *-SYMHDR                                             RH\n*\nHEAD1    DS    0CL132                                               RH\n         DC    C'   LOC  OBJECT CODE    ADDR1 ADDR2  STMT'          RH\n         DC    C'    SOURCE STATEMENT'                              RH\n         DC    CL17' '                                              RH\n         DC    C'CHARACTER REP'                                     RH\n         DC    CL20' '                                              RH\n         DC    C'PAGE'                                              RH\nPAGENO   DS    CL4                                                  RH\n         DC    CL14' '                                              RH\n*\n*\nRLDHDR   DC    C'0     RELPTR  POSPTR      TYPE     LEN'\n         DC    C'    DIR   ADDR'\n*        DC    CL90' '\nLRLDHDR  EQU   *-RLDHDR                                             RH\n*\n*\n*\nPH1LBL   DC    C'1***** PHASE     1 LABEL TABLE *****'              RH\nLPH1LBL  EQU   *-PH1LBL                                             RH\nPH1HDR   DC    C'0  ADDR TYPE      SYMBOL  LEN'                     RH\nLPH1HDR  EQU   *-PH1HDR                                             RH\n*PH1LBL   DC    CL121'1***** PHASE 1 LABEL TABLE *****'             RH\n*PH1HDR   DC    CL121'0  ADDR TYPE  SYMBOL  LEN'                    RH\n*                                                                   RH\n         SPACE 1                                                    RH\n*              REGISTER EQUATES TABLE                               RH\n         SPACE 1                                                    RH\nENDTAB   DC    CL17'R0       EQU   0 '                              RH\n         DC    CL17'R1       EQU   1 '                              RH\n         DC    CL17'R2       EQU   2 '                              RH\n         DC    CL17'R3       EQU   3 '                              RH\n         DC    CL17'R4       EQU   4 '                              RH\n         DC    CL17'R5       EQU   5 '                              RH\n         DC    CL17'R6       EQU   6 '                              RH\n         DC    CL17'R7       EQU   7 '                              RH\n         DC    CL17'R8       EQU   8 '                              RH\n         DC    CL17'R9       EQU   9 '                              RH\n         DC    CL17'R10      EQU   10'                              RH\n         DC    CL17'R11      EQU   11'                              RH\n         DC    CL17'R12      EQU   12'                              RH\n         DC    CL17'R13      EQU   13'                              RH\n         DC    CL17'R14      EQU   14'                              RH\n         DC    CL17'R15      EQU   15'                              RH\n         SPACE 1                                                    RH\n*\n*\nH1       DC    H'1'                    CONSTANT 1\nH5       DC    H'5'                    CONSTANT 5\nH11      DC    H'11'                   CONSTANT 11\nH16      DC    H'16'                   CONSTANT 16\nH256     DC    H'256'                  CONSTANT 256\nBLANX    DC    CL133' '                CONSTANT BLANKS              RH\nXZROS    DC    8X'00'                  CONSTANT ZEROS\nTRTBL    DC    C'0123456789ABCDEF'     TRANSLATE TBL\nNOCNTRL  DC    C'MEMBER AND CSECT MUST BE ENTERED VIA SYSIN'\nOVER8    DC    C'MEMBER OR CSECT NAME OVER 8 CHARACTERS'\nNOMEM    DC    C'NO MEMBER NAME FOUND IN CONTROL CARD OR PARM'\nINVMEM   DC    C'SPECIFIED MEMBER NOT FOUND IN SYSLIB PDS'\nINVCSECT DC    C'SPECIFIED CSECT NOT FOUND IN MEMBER'\nFULLSYM  DC    C'SYMBOL TABLE FULL: OVER 4000 ENTRIES'\nFULLRLD  DC    C'RLD TABLE FULL: OVER 3000 ENTRIES'\nPOFSET   DC    F'0'                    OFFSET FOR TEXT PRINT\nPRTCHAR  DC    256C'.'                 CHARACTER TRANSLATE TABLE\n         ORG   PRTCHAR+C' '\n         DC    C' '\n         ORG   PRTCHAR+74                                           RH\n         DC    7X'00'             \u00a2.<(+|&                           RH\n         ORG   PRTCHAR+90                                           RH\n         DC    8X'00'             !$*);\u00ac-/                          RH\n         ORG   PRTCHAR+106                                          RH\n         DC    6X'00'             |,%_>?                            RH\n         ORG   PRTCHAR+121                                          RH\n         DC    7X'00'             ':#@'=\"                           RH\n         ORG   PRTCHAR+C'A'\n         DC    C'ABCDEFGHI'\n         ORG   PRTCHAR+C'J'\n         DC    C'JKLMNOPQR'\n         ORG   PRTCHAR+C'S'\n         DC    C'STUVWXYZ'\n         ORG   PRTCHAR+C'0'\n         DC    C'0123456789'\n         ORG\n*\n*\n*\nSYSPUNCH DCB   DSORG=PS,MACRF=(PM,GM),DDNAME=SYSPUNCH,                 X\n               RECFM=FB,LRECL=80\nSYSIN    DCB   DSORG=PS,MACRF=GL,DDNAME=SYSIN,                         X\n               RECFM=FB,LRECL=80,EODAD=NOCTL\nSYSLIB   DCB   DSORG=PO,MACRF=R,DDNAME=SYSLIB,                         X\n               RECFM=U,NCP=1,EXLST=JFCBAD                           RH\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,                      X\n               RECFM=FBA,LRECL=133                                  RH\n*              RECFM=FBA,LRECL=121\nLOADLIB  DCB   DSORG=PO,MACRF=R,DDNAME=LOADLIB,EXLST=JFCBAD\n*\n         PRINT GEN                                                  RH\n         DISASPRM DSECT=NO                                          RH\n*\n*\n*                                                                   RH\n         END\n/*\n//\n//*            END IF JUST WANT OBJECT MODULE\n//*\n//LKED.SYSLMOD  DD DISP=SHR,DSN=HALL.LOAD\n//LKED.SYSIN DD *\n     SETCODE AC(0)\n     NAME DISASMM(R)\n//\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DISASM1": {"ttr": 9222, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x99\\x00\\x8f\\x00\\x99\\x01\\x1f\\x13C\\x07C\\x07T\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1999-01-08T00:00:00", "modifydate": "1999-01-11T13:43:00", "lines": 1859, "newlines": 1876, "modlines": 0, "user": "RH87944"}, "text": "//DISASM1 JOB (87944,348496),HALL.S1BL,MSGCLASS=A,\n//             USER=RH87944,PASSWORD=*\n/*ROUTE  PRINT R7\n//STEP1  EXEC HLASMC,CLASS='*',\n//            PARMC='SYSPARM(1,ESD)'\n//ASM.SYSLIB DD DSN=HALL.DISASM.SOURCE,DISP=SHR\n//   DD DSN=SYS1.MACLIB,DISP=SHR\n//   DD DSN=SYS1.AMODGEN,DISP=SHR\n//ASM.SYSLIN   DD DSN=HALL.OBJECT(DISASM1),DISP=SHR\n//ASM.SYSIN DD *\n*                                                                   RH\n*   MODIFIED JAN 1999 BY RANDY HALL                                 RH\n*      HOPEFULLY ALL MODS HAVE \"RH\" IN COL 69-70...                 RH\n*      1) CHANGED DSECT OFFSET TO HEX FROM DEC                      RH\n*      2) AT LABEL RDFLD, ADDED CODE TO PRINT DSECT OFFSET IN       RH\n*         HEX OR DECIMAL VIA \"AGO\"                                  RH\n*      3) AT LABEL INSTR, HOPEFULLY BEEFED UP INSTRUCTION TESTS     RH\n*      4) AT LABEL CHEX, TEST DATA TYPE                             RH\n*      5) AT LABEL LBSTCUR, ADDED CODE TO RESORT LABEL TABLE        RH\n*      6) AT LABEL EOJ, ADDED CODE TO RESORT LABEL TABLE            RH\n*      7) ADDED MORE CHARACTERS TO \"HEXTRAN\" TABLE                  RH\n*      8) INCLUDE DSECTS FROM SYSLIB WITH \"DISASPRM\" COPY AT END    RH\n*                                                                   RH\n*                                                                   RH\n*                                                                   RH\nDIS1     TITLE '*** DISASSEMBLY PHASE 1 ***'\n         MACRO\n&NAME    SVLNK &REG1,&REG2,&REG3,&IND,&LV=\n         GBLC  &EQU\n         GBLC  &GM\n         GBLC  &CSECT\n         LCLC  &REGA\n         AIF   (T'&NAME EQ 'O').NOCSECT\n         AIF   ('&NAME' EQ '*').NOCSECT\n&CSECT   SETC  '&NAME'\n&CSECT   CSECT                         NAME OF PROGRAM\n         AGO   .RST\n.NOCSECT ANOP\n&CSECT   SETC  '*'\n         CSECT                         BEGINNING OF PROGRAM\n.RST     ANOP\n         AIF   ('&EQU' EQ 'ON').NRQ\n&EQU     SETC  'ON'\n*\n***REGISTER EQUATES***\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n.NRQ     ANOP\n*\n*******************  PROGRAM INITIALIZATION  *************************\n*\n         AIF   (T'&REG1 EQ 'O').NOREG\n&REGA    SETC  '&REG1'\n         AIF   (T'&REG2 EQ 'O').ONEREG\n         USING &CSECT,&REGA,&REG2          ESTABLISH ADDRESSABILITY\n         AGO   .BYUSE\n.NOREG   ANOP\n&REGA    SETC  'R3'\n.ONEREG  USING &CSECT,&REGA              ESTABLISH ADDRESSABILITY\n.BYUSE   ANOP\n         STM   R14,R12,12(R13)         STORE REGS IN HIGH SAVE AREA\n         LR    &REGA,R15                  INITIALIZE BASE REG\n         AIF   (T'&REG2 EQ 'O').NOLA\n         LA    &REG2,4095(&REGA)       INITIALIZE THE SECOND\n         LA    &REG2,1(&REG2)                BASE REGISTER\n.NOLA    ANOP\n         AIF   (T'&REG3 EQ 'O').NOLNK\n         L     &REG3,0(R1)                GET PARAMETER LIST ADDR\n.NOLNK   ANOP\n         AIF (T'&IND EQ 'O').GETIT\n         CNOP  0,4\n         BAL   R15,SAVEAREA+72         BRANCH AROUND SAVE AREA\nSAVEAREA DS    18F                     REGISTER SAVE AREA\n         ST    R15,8(R13)\n         ST    R13,SAVEAREA+4\n         LR    R13,R15\n         AGO   .NOSAVE\n.GETIT   ANOP\n         AIF   (T'&LV EQ 'O').GMD\n&GM      SETC  '&LV'\n         AGO   .DGM\n.GMD     ANOP\n&GM      SETC  '72'\n.DGM     ANOP\n*\n***GET MAIN STORAGE FOR SAVE AREA***\n*\n         AIF   ('&GM' LT '4096').LA\n         GETMAIN R,LV=&GM              GET CORE FOR SAVE AREA\n         AGO   .EGM\n.LA      ANOP\n         LA    R0,&GM                  GET &GM BYTES\n         GETMAIN R,LV=(0)\n.EGM     ANOP\n*\n***SET UP SAVE AREA POINTERS***\n*\n         ST    R1,8(R13)               STORE LOW SAVE POINTER\n         ST    R13,4(R1)               STORE HIGH SAVE POINTER\n         LR    R13,R1                  INITIALIZE SAVE POINTER\n         AIF   (T'&REG3  NE 'O').NOSAVE\n         L     R1,4(R13)               GET POINTER TO RESTORE PARA REG\n         L     R1,24(R1)               RESTORE PARAMETER REGISTER\n.NOSAVE  ANOP\n         AIF   ('&CSECT' EQ '*').EXIT\n         B     *+12\n         DC    CL8'&CSECT'             END INITIAL., BEGIN THIS PROG.\n.EXIT    ANOP\n*\n*********************  END INITIALIZATION  ***************************\n*\n         MEND\n         EJECT\nDISASM1  SVLNK R3,R4\n         PRINT NOGEN\n* THIS SUB-PROGRAM IS CALLED BY DISASM, AND IS PHASE 2 OF\n* THE DISASSEMBLY PROCESS. A COMMON DATA\n* AREA IS DEFINED IN DISASM, AND PASSED TO THIS PROGRAM.\n*\n*    THE SYSIN FILE IS READ TO EXHAUSTION. USING CARDS ARE\n* REFORMATTED AND STORED IN A TABLE - UP TO 256 USING\n* STATEMENTS MAY BE ENTERED. DSECT CARDS MAY FOLLOW THE\n* USING STATEMENTS. WHEN USED, DSECT STATEMENTS ARE\n* REFORMATTED, AND BUILT INTO TABLES. A MAXIMUM OF 256 DSECTS\n* MAY BE ENTERED. DATA ONLY CARDS MAY BE INCLUDED BEFORE, BETWEEN,\n* OR AFTER DSECTS TO SHOW AREAS IN THE PROGRAM WHERE NO INSTRUCTIONS\n* OCCUR. UP TO 256 DATA ONLY AREAS MAY BE SPECIFIED.\n*\n*     AT EOF ON SYSIN, A PSEUDO DIS-ASSEMBLY PASS IS MADE\n* USING THE TEXT STORED BY DISASM. ANY RESOLVABLE ADDRESS\n* WITHIN THE TEXT IS USED TO CREATE A NEW ENTRY IN THE\n* LABEL TABLE, WHICH WILL BE USED BY DISASM2 IN THE\n* ACTUAL DIS-ASSEMBLY PASS.\n*\n* THE USING CARDS FOR BASE REGISTERS ASSOCIATED WITH DSECT DEFINITIONS\n* MUST BE ENTERED AT SOME POINT AFTER THE DSECT CARDS HAVE BEEN\n* INCLUDED. USING CARDS FOR PROGRAM BASE REGISTERS MAY BE ENTERED\n* AT ANY POINT. THE USING CARD FORMAT IS:\n*       COL 1-5   : LITERAL 'USING'\n*       COL 6     : BLANK\n*       COL 7-12  : OFFSET TO BEGIN LOCATION FOR USING RANGE (HEX)\n*       COL 13    : BLANK\n*       COL 14-19 : OFFSET TO ENDING LOCATION FOR USING RANGE (HEX)\n*       COL 20    : BLANK\n*       COL 21    : BASE RESISTER TO BE USED (HEX, 1-F)\n*       COL 22    : BLANK\n*       COL 23    : TYPE, P=PROGRAM BASE, D=DSECT BASE\n*       COL 24    : BLANK\n*       COL 25-30 : INITIAL BASE REGISTER VALUE IF TYPE P (HEX)\n*       COL 25-32 : DSECT NAME IF TYPE D\n*\n*     A DSECT IS ENTERED USING A HEADER CARD,FOLLOWED BY\n* ONE OR MORE FIELD DEFINITION CARDS. ALL FIELD DEFINITION\n* CARDS MUST FOLLOW THE DSECT HEADER CARD. USING CARDS MAY\n* NOT BE INTERSPERSED WITH DSECT DEFINITIONS, BUT MAY PRECEDE\n* OR FOLLOW ANY DSECT.\n*     DSECT HEADER CARD FORMAT:\n*        COL 1-8    : DSECT NAME\n*        COL 9      : BLANK\n*        COL 10-14  : LITERAL 'DSECT'\n*        COL 15     : BLANK\n*        COL 16-19  : NUMBER OF FIELD CARDS TO FOLLOW (DECIMAL)\n*\n*     DSECT FIELD CARD FORMAT:\n*        COL 1-8    : FIELD NAME\n*        COL 9      : BLANK\n*        COL 10-13  : OFFSET TO LEFT END OF FIELD IN HEXADECIMAL    RH\n*        COL 14     : BLANK\n*        COL 15-17  : LENGTH OF FIELD IN BYTES (DECIMAL)\n*\n*     A DATA ONLY CARD IS USED TO DESIGNATE A RANGE OF OFFSETS\n* BETWEEN WHICH NO INSTRUCTIONS EXIST. USE OF THESE CARDS ELIMINATES\n* THE CHANCE THAT DATA ELEMENTS WILL BE TREATED AS INSTRUCTIONS\n* BETWEEN THE OFFSETS SPECIFIED. FORMAT IS:\n*        COL 1-4    : LITERAL 'DATA'\n*        COL 5      : BLANK\n*        COL 6-11   : OFFSET TO BEGINNING OF AREA (HEX)\n*        COL 12     : BLANK\n*        COL 13-18  : OFFSET TO END OF AREA (HEX)\n*\n*\n*     USER LABEL CARDS ARE USED TO PERMIT SPECIFICATION OF\n* LABELS OTHER THAN THE AXXXXXX NAMES CREATED BY DISASM. THEY\n* MAY APPEAR ANYWHERE IN THE SYSIN STREAM EXCEPT AS THE FIRST\n* CARD, OR WITHIN A DSECT DEFINITION.\n*        COL  1-5  : LITERAL 'ULABL'\n*        COL   6   : BLANK\n*        COL  7-14 : FIELD NAME\n*        COL   15  : BLANK\n*        COL 16-21 : OFFSET TO LEFT END OF AREA (HEX)\n*        COL   22  : BLANK\n*        COL 23-25 : FIELD LENGTH (DECIMAL)\n*\n*      DISASSEMBLY TABLES ARE SET UP IDENTICALLY TO THOSE USED BY\n* DISASM2 FOR THE SIMULATED DISASSEMBLY PERFORMED IN THIS\n* MODULE WHEN ANY PROGRAM BASE REGISTER USING STATEMENTS\n* ARE ENTERED.\n*\n*     STORAGE IS OBTAINED FOR THE DSECT TABLE AND USING TABLE,\n* AND ADDRESSES OF THESE TABLES ARE STORED IN THE COMMON PARAMETER\n* AREA. USING AND DSECT CARDS ARE EDITED, REFORMATTED, AND PLACED\n* IN THE APPROPRIATE TABLES. IF ANY ERRORS ARE FOUND, THEY ARE\n* PRINTED, AND THE DISASSEMBLY WILL BE TERMINATED ON RETURN\n* TO DISASM.\n*\n*     STORAGE IS OBTAINED FOR THE LABEL TABLE, AND A SIMULATED\n* DIS-ASSEMBLY IS PERFORMED TO CREATE LABEL TABLE ENTRIES FOR\n* LABELS WHICH WILL BE GENERATED FOR BASE-DISPLACEMENT ADDRESSES\n* BY DISASM2. ON RETURN TO DISASM, THESE LABELS WILL BE SORTED\n* WITH EXTERNAL SYMBOL AND RLD LABELS TO FORM THE FINAL LABEL\n* TABLE TO BE USED BY DISASM2.\n*\n*\n*\n*\n* AUTHOR R THORNTON - FEB 1978\n* UPDATED ROBERT STYMA - JAN 1989 AND MARCH 1991\n* UPDATED ALAN C FIELD - APR 1990\n*\n*\n******************************************************************\n*                                                                *\n* CHECK FOR PRIVILEGED AND/OR FLOATING POINT INSTRUCTION OPTION. *\n* IF THESE INSTRUCTIONS ARE NOT TO BE ASSEMBLED, CLEAR THEIR     *\n* INSTRUCTION TABLE ENTRIES.                                     *\n*                                                                *\n******************************************************************\n*\n         L     R5,0(R1)                GET PARM FIELD ADDRESS\n         USING COMMPARM,R5\n         CLI   FLPTASM,1               FLOATING POINT INSTR O.K.\n         BE    TSTPRIV                 YES\n         LA    R12,SGLOP               POINT TO OP-CODE TBL\nTSTOPND  CLI   0(R12),X'FF'            END OF TBL\n         BE    TSTPRIV                 YES\n         TM    ICLASS-INSTENT(R12),FLTPT IS IT FLOATING POINT\n         BZ    FLPSTP                  NO\n         XC    0(L'SGLOP,R12),0(R12)   CLEAR ENTRY\nFLPSTP   LA    R12,L'SGLOP(R12)        TO NEXT ENTRY\n         B     TSTOPND                 LOOP THRU TABLE\nTSTPRIV  CLI   PRIVASM,1               PRIVILEGED INSTR O.K.\n         BE    GETUSGTB                YES\n         LA    R12,SGLOP               POINT TO OP-CODE TBL\nTTOPND   CLI   0(R12),X'FF'            END OF TABLE\n         BE    CKDBLS                  YES\n         TM    ICLASS-INSTENT(R12),PRIV PRIVILEGED INSTR\n         BZ    PRIVSTP                 NO\n         XC    0(L'SGLOP,R12),0(R12)   YES, CLEAR ENTRY\nPRIVSTP  LA    R12,L'SGLOP(R12)        TO NEXT ENTRY\n         B     TTOPND                  LOOP THRU TABLE\nCKDBLS   L     R12,DBLOPAD             @ 2-BYTE OP-CODE TBL\nCKDBND   CLI   0(R12),X'FF'            END OF TBL\n         BE    GETUSGTB                YES\n         TM    ICLASS-INSTENT+2(R12),PRIV PRIVILEGED OP-CODE\n         BZ    DBSTP                   NO\n         XC    0(L'DBLOP,R12),0(R12)   YES, CLEAR ENTRY\nDBSTP    LA    R12,L'DBLOP(R12)        TO NEXT ENTRY\n         B     CKDBND                  LOOP THRU TABLE\n*\n******************************************************************\n*                                                                *\n* GET STORAGE FOR USING AND DSECT POINTER TABLES.                *\n*                                                                *\n******************************************************************\n*\nGETUSGTB GETMAIN R,LV=2864             GET STORAGE FOR USING TABLE\n         MVI   0(R1),X'FF'             SET TABLE END INDIC\n         ST    R1,USGSTRT              SAVE TABLE START ADDR\n         ST    R1,USGCUR               SET TABLE CURRENT ADDR\n         LA    R1,2816(R1)             COMPUTE TABLE END ADDR\n         ST    R1,USGEND               SAVE USING TABLE END ADDR\n         L     R2,INDCB                GET SYSIN DCB ADDR\n         LA    R1,EOFCARD              GET EOF ADDR\n         STCM  R1,7,33(R2)             SET EOF ADDR IN DCB\n         GETMAIN R,LV=2864             GET STORAGE FOR DSECT TABLE\n         MVI   0(R1),X'FF'             SET TABLE END ADDR\n         ST    R1,DTBSTRT              SAVE DSECT TABLE START ADDR\n         ST    R1,DTBCUR               SAVE DSECT TABLE CURRENT ADDR\n         LA    R1,2816(R1)             COMPUTE TABLE END ADDR\n         ST    R1,DTBEND               SAVE DSECT TABLE END ADDR\n         L     R1,INDCB                @ SYSIN DCB\n         TM    48(R1),X'10'            IS IT OPEN\n         BZ    EOFCARD                 NO\n*\n*\n*\n******************************************************************\n*                                                                *\n* READ SYSIN CARDS, AND DISTRIBUTE TO THE APPROPRIATE PROCESSING *\n* ROUTINE: USINGS, DSECTS, OR DATAS. DETECT ANY ERRORS AND PRINT *\n* ALL CARDS WITH MESSAGES AS NECESSARY.                          *\n*                                                                *\n******************************************************************\n*\nRDCARD   EQU   *                       *** PROCESS SYSIN CARDS ***\n         L     R1,INDCB                GET SYSIN DCB ADDR\n         GET   (1)                     READ NEXT CARD\n         MVC   WORKREC,0(R1)           MOVE IT TO WORK AREA\n         NOP   MVPRT                   FIRST TIME SWITCH\n         MVI   *-3,C'0'                RESET FIRST TIME SWITCH\n         MVI   PCC,C'1'                SET SKIP TO HEAD\n         MVC   PRT+10(26),=C'*** USER ENTERED CARDS ***'\n         BAL   R9,PRINT                GO PRINT\nMVPRT    MVC   PRT(80),WORKREC         CARD TO PRINT\nRDGRTN   LA    R9,RCCKERR              GET RETURN ADDRESS\n         CLC   WORKREC(5),=C'USING'    IS IT A USING CARD\n         BE    USINGS                  YES\n         CLC   WORKREC+9(5),=C'DSECT'  IS IT A DSECT HEADER\n         BE    DSECTS                  YES\n         CLC   WORKREC(4),=C'DATA'     IS IT DATA ONLY CARD\n         BE    DATAS                   YES\n         CLC   WORKREC(5),=C'ULABL'    IS IT A USER LABEL\n         BE    ULABLS                  YES\n         MVC   PRT+85(21),=C'UNIDENT OR OUT OF SEQ'\n         MVI   USERR,X'FF'             SET ERROR FLAG\nRCCKERR  NI    USERR,X'FE'             RESET CURRENT ERROR FLAG\n         BAL   R9,PRINT                GO PRINT\n         B     RDCARD                  CONTINUE\nEOFCARD  CLI   USERR,0                 ANY ERRORS FOUND\n         BNE   EOJ                     YES, EXIT\n*\n******************************************************************\n*                                                                *\n* CHECK FOR ANY USING CARDS ENTERED. IF NOT, NO PRE-ASSEMBLY IS  *\n* NECESSARY. IF ANY USING CARDS FOUND, CREATE LABEL TABLE ENTRIES*\n* SO THAT USING STATEMENTS WILL BE VALID.                        *\n*                                                                *\n******************************************************************\n*\n         L     R1,DATOCUR              GET CURRENT DATA ONLY @\n         MVC   NOINAD,DATONLY          SAVE DATA ONLY TBL ADDR\n         MVC   0(3,R1),HIVAL           SET END\n         L     R11,USGSTRT             GET USING TBL ADDR\nCUSNGND  CLI   0(R11),X'FF'            END OF TABLE\n         BE    CKPRE                   GO CHECK FOR PRE-DISASM\n         L     R10,CURRLBL             GET LABEL ADDRESS\n         USING USINGD,R11\n         USING LABELD,R10\n         MVC   LBLADR,USVALU           OFFSET TO LABEL\n         MVI   LBLTYP,C'L'             LABEL TYPE ENTRY\n         MVI   LBLLEN,1                SET LENGTH TO 1\n         MVI   LBLNAME,C'A'            1ST CHAR OF NAME\n         LA    R12,USVALU              @ OFFSET\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   LBLNAME+1(6),PRTABL     MIDDLE OF NAME\n         MVI   LBLNAME+7,C' '          BLANK LAST POS\n         LA    R10,L'LABEL(R10)        STEP TO NEXT LABEL\n         ST    R10,CURRLBL             SAVE IN CURRLBL     FIX******\n         MVC   0(3,R10),HIVAL          SET END VALUE       FIX******\n         LA    R11,L'USING(R11)        STEP TO NEXT USING\n         B     CUSNGND                 LOOP\n         DROP  R10\n         DROP  R11\nCKPRE    L     R1,USGSTRT              GET USING TBL START ADDR\n         CLI   0(R1),X'FF'             ANY ENTRIES\n         BNE   MAINLINE                YES, GO TO PRE-DISASM\n         B     EOJ                     OTHERWISE GET OUT\n*\n*\n*\n*\n******************************************************************\n*                                                                *\n* EDIT USING CARDS FOR VALIDITY. PUT APPROPRIATE COMMENT IN PRINT*\n* LINE WHEN INVALID. WHEN NO ERRORS FOUND, CREATE AN ENTRY IN THE*\n* USING TABLE.                                                   *\n*                                                                *\n******************************************************************\n*\nUSINGS   EQU   *                       *** USING CARD PROCESSING ***\n         L     R12,USGCUR              GET CURRENT USING TBL ADDR\n         C     R12,USGEND              END OF TBL\n         BNL   UERR6                   YES, TABLE FULL\n         USING USINGD,R12\n         TR    WORKREC+6(6),TRHEX      TRANSLATE TO MAKE HEX\n         TRT   WORKREC+6(6),TRTHEX     CHECK VALID\n         BNZ   UERR1                   INVALID BEGIN ADDR\n         TR    WORKREC+13(6),TRHEX     TRANSLATE TO MAKE HEX\n         TRT   WORKREC+13(6),TRTHEX    CHECK VALID\n         BNZ   UERR2                   INVALID END ADDR\n         TR    WORKREC+20(1),TRHEX     TRANSLATE TO MAKE HEX\n         TRT   WORKREC+20(1),TRTHEX    CHECK VALID\n         BNZ   UERR3                   INVALID BASE REG\n*        CLI   WORKREC+20,0            VALID BASE REG\n*        BE    UERR3                   NO\n         CLI   WORKREC+22,C'P'         VALID TYPE\n         BE    CKINIT                  YES, PROGRAM BASE\n         CLI   WORKREC+22,C'D'         VALID TYPE\n         BNE   UERR8                   NO, ERROR\n         L     R1,DTBSTRT              GET DSECT TABLE STRT\nCKDSEND  CLI   0(R1),X'FF'             END OF TABLE\n         BE    UERR5                   YES, MISSING DSECT\n         CLC   0(8,R1),WORKREC+24      THIS THE DSECT ENTRY\n         BE    USDSMV                  YES\n         LA    R1,11(R1)               TO NEXT ENTRY\n         B     CKDSEND                 LOOP THRU DSECT TABLE\nUSDSMV   MVC   USVALU,8(R1)            MOVE DSECT TBL ADDR\n         B     USFINI                  CONTINUE\nCKINIT   TR    WORKREC+24(6),TRHEX     TRANSLATE TO MAKE HEX\n         TRT   WORKREC+24(6),TRTHEX    CHECK VALIDITY\n         BNZ   UERR4                   INVALID BASE REG VALUE\n         PACK  DBLWD(4),WORKREC+24(7)  PACK TO MAKE HEX\n         MVC   USVALU,DBLWD            BASE REG VALUE TO USING TBL\nUSFINI   PACK  DBLWD(4),WORKREC+6(7)   PACK TO MAKE HEX\n         MVC   USBGN,DBLWD             BEGIN ADDR TO USING TABLE\n         PACK  DBLWD(4),WORKREC+13(7)  PACK TO MAKE HEX\n         MVC   USEND,DBLWD             END ADDR TO USING TABLE\n         TM    USEND+2,1               IS IT ODD\n         BO    UERR2                   YES, ERROR\n         CLI   WORKREC+22,C'D'         DSECT BASE\n         BE    USFREG                  YES\n         CLC   USEND,LENGTH+1          WITHIN PROGRAM\n         BH    UERR2                   YES, ERROR\nUSFREG   MVC   USREG,WORKREC+20        BASE REG TO USING TABLE\n         MVC   USTYPE,WORKREC+22       TYPE TO USING TABLE\n         CLC   USBGN,USEND             END < BEGIN\n         BH    UERR7                   YES, ERROR\n         LA    R12,L'USING(R12)        TO NEXT USING TBL ENTRY\n         MVI   0(R12),X'FF'            SET TABLE END INDIC\n         ST    R12,USGCUR              SAVE UPDATED TABLE ADDR\n         BR    R9                      EXIT\nUERR1    MVC   PRT+85(22),=C'INVALID BEGIN COL 7-12'\n         B     UERRS                   CONTINUE\nUERR2    MVC   PRT+85(21),=C'INVALID END COL 14-19'\n         B     UERRS                   CONTINUE\nUERR3    MVC   PRT+85(18),=C'INVALID REG COL 21'\n         B     UERRS                   CONTINUE\nUERR4    MVC   PRT+85(25),=C'INVALID ADDRESS COL 25-30'\n         B     UERRS                   CONTINUE\nUERR5    MVC   PRT+85(25),=C'UNDEFINED DSECT COL 25-32'\n         B     UERRS                   CONTINUE\nUERR6    MVC   PRT+85(20),=C'OVER 256 USING CARDS'\n         B     UERRS                   CONTINUE\nUERR7    MVC   PRT+85(16),=C'END BEFORE BEGIN'\n         B     UERRS                   CONTINUE\nUERR8    MVC   PRT+85(19),=C'INVALID TYPE COL 23'\nUERRS    MVI   USBGN,X'FF'             INSURE TABLE END INDIC\n         MVI   USERR,X'FF'             SHOW ERROR\n         BR    R9                      EXIT\n         DROP  R12\n*\n*\n*\n******************************************************************\n*                                                                *\n* EDIT ULABL CARDS FOR VALIDITY. PUT APPROPRIATE COMMENT IN PRINT*\n* LINE WHEN INVALID. WHEN NO ERRORS FOUND, CREATE AN ENTRY IN THE*\n* LABEL TABLE. SEARCH FOR ANY TYPE A (ADCON) ENTRIES HAVING A    *\n* SYMBOL OF AXXXXXX, WHERE XXXXXX IS THE HEX OFFSET TO THE USER  *\n* LABEL. IF AN A TYPE ENTRY IS FOUND, CHANGE ITS SYMBOLIC NAME TO*\n* THAT OF THE USER LABEL.                                        *\n*                                                                *\n******************************************************************\n*\nULABLS   EQU   *                       PROCESS USER LABEL CARDS\n         STM   R6,R12,ULSAV            SAVE REGS\n         CLI   WORKREC+6,C' '          NAME VALID\n         BE    ULERR1                  NO, 1ST CHAR CANNOT BE BLANK\n         MVC   UNAME+1(6),WORKREC+15   BUILD AXXXXXX NAME\n         TR    WORKREC+15(6),TRHEX     TRANSLATE TO MAKE HEX\n         TRT   WORKREC+15(6),TRTHEX    CHECK VALID HEX\n         BNZ   ULERR2                  NOT VALID\n         MVZ   NUMCK,WORKREC+22        ZONES FOR NUMERIC TEST\n         CLC   NUMCK(3),ZEROS          LENGTH IS NUMERIC\n         BNE   ULERR3                  NO, ERROR\n         L     R6,CURRLBL              GET CURRENT LABEL TABLE ADDRESS\n         USING LABELD,R6\n         C     R6,ENDLBL               END OF TABLE\n         BNL   ULERR4                  YES, ERROR\n         MVC   LBLNAME,WORKREC+6       NAME TO LABEL ENTRY\n         MVI   LBLTYP,C'U'             TYPE TO LABEL ENTRY\n         PACK  DBLWD,WORKREC+22(3)     PACK LENGTH\n         CP    DBLWD,P256              LENGTH > 256\n         BH    ULERR2                  YES, ERROR\n         CVB   R12,DBLWD               CONVERT TO BINARY\n         STC   R12,LBLLEN              LENGTH TO LABEL ENTRY\n         PACK  DBLWD(4),WORKREC+15(7)  PACK TO MAKE VALID HEX\n         MVC   LBLADR,DBLWD            OFFSET TO LABEL\n         LA    R7,L'LABEL(R6)          @ NEXT LABEL ENTRY\n         MVC   0(3,R7),HIVAL           SET END INDIC\n         ST    R7,CURRLBL              SET NEW TABLE END ADDR\n         LR    R7,R6                   SAVE NEW ENTRY ADDRESS\n         L     R6,LBLTBL               GET 1ST LABEL ENTRY ADDR\nULBCKND  C     R6,CURRLBL              END OF TABLE\n         BNL   ULXIT                   YES, EXIT\n         CLI   LBLTYP,C'A'             IS IT ADCON ENTRY\n         BNE   ULBSTEP                 NO\n         CLC   LBLNAME,UNAME           ADCON SYMBOL AT USER LBL ADDR\n         BNE   ULBSTEP                 NO\n         MVC   LBLNAME,LBLNAME-LABEL(R7) SET USER SYMBOL IN ADCON\nULBSTEP  LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY\n         B     ULBCKND                 LOOP THRU LABEL TABLE\n         B     ULXIT                   EXIT\nULERR1   MVC   PRT+85(21),=C'INVALID NAME COL 7-14'\n         B     ULERRS                  CONTINUE\nULERR2   MVC   PRT+85(28),=C'INVALID HEX OFFSET COL 16-21'\n         B     ULERRS                  CONTINUE\nULERR3   MVC   PRT+85(32),=C'INVALID DECIMAL LENGTH COL 23-25'\n         B     ULERRS                  CONTINUE\nULERR4   MVC   PRT+85(20),=C'LABEL TABLE OVERFLOW'\nULERRS   MVI   USERR,X'FF'             SET ERROR FLAG\nULXIT    LM    R6,R12,ULSAV            RESTORE REGS\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* EDIT DSECT CARDS FOR VALIDITY. PUT APPROPRIATE COMMENT IN PRINT*\n* LINE WHEN INVALID. WHEN NO ERRORS FOUND, CREATE AN ENTRY IN THE*\n* DSECT HEADER TABLE, GETMAIN AN AREA TO CONTAIN THE FIELD       *\n* DESCRIPTION ENTRIES, READ AND BUILD FIELD ENTRIES FOR ALL FIELD*\n* DESCRIPTION CARDS ENTERED.                                     *\n*                                                                *\n******************************************************************\n*\nDSECTS   EQU   *                       *** DSECT PROCESSING ***\n         ST    R9,DSCT9                SAVE RETURN ADDR\n         CLI   WORKREC,C' '            NAME IS BLANK\n         BE    DSERR1                  YES, ERROR\n         MVZ   NUMCK,WORKREC+15        ZONES FOR CHECK\n         CLC   NUMCK,ZEROS             IS NBR FIELDS NUMERIC\n         BNE   DSERR2                  NO, ERROR\n         L     R12,DTBCUR              GET CURRENT DSECT TBL ADDR\n         C     R12,DTBEND              AT END OF TABLE\n         BNL   DSERR3                  YES, ERROR\n         MVC   0(8,R12),WORKREC        NAME TO DSECT TABLE\n         PACK  DBLWD,WORKREC+15(4)     PACK NBR ENTRIES\n         CVB   R10,DBLWD               CONVERT TO BINARY\n         LA    R10,4(R10)              ADD FOR SAFETY\n         MH    R10,DTBLEN              TIMES ENTRY LENGTH\n         GETMAIN R,LV=(10)             GET STORAGE FOR FIELD TABLE\n         STCM  R1,7,8(R12)             SAVE FIELD TABLE ADDRESS\n         LA    R12,11(R12)             TO NEXT DSECT TABLE ENTRY\n         ST    R12,DTBCUR              UPDATE CURRENT DSECT TBL ADDR\n         MVI   0(R12),X'FF'            SET END INDIC\n         LR    R12,R1                  COPY FIELD TABLE ADDR\n         BAL   R9,PRINT                PRINT DSECT RECORD\n         USING DSECTD,R12\n         CVB   R11,DBLWD               NBR ENTRIES IN LOOP REG\nRDFLD    L     R1,INDCB                GET SYSIN DCB ADDR\n         GET   (1)                     READ NEXT CARD\n         MVC   WORKREC,0(R1)           MOVE RECORD TO WORK AREA\n         MVC   PRT(80),WORKREC         MOVE RECORD TO PRINT AREA\n         CLI   WORKREC,C' '            NAME FIELD BLANK\n         BE    DSERR1                  YES, ERROR\n         MVC   DSNAME,WORKREC          NAME TO ENTRY\n         MVI   DSLBTYP,C'L'            SET LABEL TYPE\n         AGO   .DROP1                                               RH\n******************************************************************  RH\n*                                                                *  RH\n*        USE THIS CODE IF DSECT OFFSETS ARE IN DECIMAL           *  RH\n*                                                                *  RH\n******************************************************************  RH\n         MVZ   NUMCK,WORKREC+9         ZONES FOR TEST               RH\n         CLC   NUMCK,ZEROS             IS OFFSET NUMERIC            RH\n         BNE   DSERR3                  NO, ERROR                    RH\n         PACK  DBLWD,WORKREC+9(4)      PACK OFFSET                  RH\n         CP    DBLWD,P4096             OFFSET > 4096                RH\n         BH    DSERR3                  YES, ERROR                   RH\n         CVB   R1,DBLWD                CONVERT                      RH\n         AGO   .DROP2                                               RH\n.DROP1   ANOP                                                       RH\n******************************************************************  RH\n*                                                                *  RH\n*        USE THIS CODE IF DSECT OFFSETS ARE IN HEXADECIMAL       *  RH\n*                                                                *  RH\n******************************************************************  RH\n         TR    WORKREC+9(4),TRHEX     TRANSLATE TO MAKE HEX         RH\n         TRT   WORKREC+9(4),TRTHEX    CHECK VALID HEX               RH\n         BNZ   DSERR3                  NOT VALID                    RH\n         PACK  DBLWD(4),WORKREC+9(5)   PACK OFFSET                  RH\n         SR    R1,R1              CLEAR R1                          RH\n         ICM   R1,7,DBLWD         R1 = OFFSET TO TABLE ENTRY        RH\n         CH    R1,H4095           OFFSET > 4095                     RH\n         BH    DSERR3                  YES, ERROR                   RH\n.DROP2   ANOP                                                       RH\n         STCM  R1,7,DSOFSET            OFFSET TO TABLE ENTRY\n         MVZ   NUMCK(3),WORKREC+14     ZONES FOR TEST\n         CLC   NUMCK(3),ZEROS          IS LENGTH NUMERIC\n         BNE   DSERR4                  NO, ERROR\n         PACK  DBLWD,WORKREC+14(3)     PACK LENGTH\n         CP    DBLWD,P256              LENGTH OVER 256\n         BH    DSERR4                  YES, ERROR\n         CVB   R1,DBLWD                CONVERT\n         LTR   R1,R1                   LENGTH IS ZERO\n         BZ    DSERR4                  YES, ERROR\n         STC   R1,DSLENG               LENGTH TO TABLE ENTRY\n         LA    R12,L'DSECT(R12)        TO NEXT ENTRY\n         MVI   0(R12),X'FF'            SET TBL END INDIC\n         BAL   R9,PRINT                GO PRINT CARD\n         BCT   R11,RDFLD               LOOP THRU DSECT\n         MVC   DSOFSET,HIVAL           TABLE STOPPER\n         L     R9,DSCT9                GET RETURN ADDR\n         BR    R9                      EXIT\nDSERR1   MVC   PRT+85(20),=C'INVALID NAME COL 1-8'\n         B     DSERRS                  CONTINUE\nDSERR2   MVC   PRT+85(28),=C'INVALID NBR FIELDS COL 16-19'\n         B     DSERRS                  CONTINUE\nDSERR3   MVC   PRT+85(24),=C'INVALID OFFSET COL 10-13'\n         B     DSERRS                  CONTINUE\nDSERR4   MVC   PRT+85(24),=C'INVALID LENGTH COL 15-18'\n         B     DSERRS                  CONTINUE\nDSERRS   MVI   USERR,X'FF'             SHOW ERROR FOUND\n         L     R9,DSCT9                GET RETURN ADDR\n         BR    R9                      EXIT\n         DROP  R12\n*\n*\n*\n******************************************************************\n*                                                                *\n* EDIT DATA ONLY CARDS FOR VALIDITY. PLACE ERROR DESCRIPTION IN  *\n* PRINT LINE IF ERRORS FOUND. CREATE DATA ONLY TABLE ENTRY IF NO *\n* ERRORS ARE FOUND.                                              *\n*                                                                *\n******************************************************************\n*\nDATAS    EQU   *                       *** DATA CARD PROCESSING ***\n         TR    WORKREC+5(6),TRHEX      TRANSLATE TO MAKE HEX\n         TRT   WORKREC+5(6),TRTHEX     CHECK VALID\n         BNZ   DERR1                   INVALID HEX\n         TR    WORKREC+12(6),TRHEX     TRANSLATE TO MAKE HEX\n         TRT   WORKREC+12(6),TRTHEX    CHECK VALID\n         BNZ   DERR2                   INVALID HEX\n         PACK  DBLWD(4),WORKREC+5(7)   PACK TO MAKE HEX\n         PACK  DBLWD+4(4),WORKREC+12(7) PACK TO MAKE HEX\n         CLC   DBLWD(3),DBLWD+4        CHECK 1ST LOW\n         BNL   DERR3                   1ST NOT LOW, ERROR\n         L     R1,DATOCUR              GET TBL ADDR\n         MVC   0(3,R1),DBLWD           MOVE 1ST OFFSET TO TBL\n         MVC   3(3,R1),DBLWD+4         MOVE 2ND OFFSET TO TBL\n         LA    R1,6(R1)                TO NEXT ENTRY\n         ST    R1,DATOCUR              SAVE CURRENT ENTRY ADDR\n         BR    R9                      EXIT\nDERR1    MVC   PRT+85(22),=C'1ST OFFSET INVALID HEX'\n         B     DERRS                   CONTINUE\nDERR2    MVC   PRT+85(22),=C'2ND OFFSET INVALID HEX'\n         B     DERRS                   CONTINUE\nDERR3    MVC   PRT+85(23),=C'END OFFSET BEFORE BEGIN'\nDERRS    MVI   USERR,X'FF'             FLAG ERROR\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* MAINLINE ROUTINE FOR THE PRE-DISASSEMBLY. PURPOSE OF THIS PART *\n* OF THE PROGRAM IS TO ATTEMPT TO CREATE A LABEL ENTRY FOR INSTR-*\n* UCTIONS HAVING STORAGE OPERANDS. THE RESULTING LABEL TABLE WILL*\n* BE SORTED, AND DUPLICATE ENTRIES ELIMINATED BEFORE EXIT FROM   *\n* THIS PHASE OF DISASSEMBLY.                                     *\n*                                                                *\n******************************************************************\n*\nMAINLINE EQU   *                       MAINLINE ROUTINE\n         L     R6,LBLTBL               @ LABEL TABLE\n         USING LABELD,R6\n         MVC   TXTCURR,TXTSTRT         COPY TEXT START ADDR\nGETCURR  L     R7,TXTCURR              @ CURRENT TXT BYTE\n         C     R7,TXTEND               END OF TEXT\n         BNL   EOJ                     YES             FIX********\n         LR    R12,R7                  COPY TEXT ADDR\n         S     R12,TXTSTRT             COMPUTE OFFSET\n         ST    R12,TXTOFST             SAVE OFFSET TO THIS BYTE\n         CLC   NEXCHG,TXTOFSET         TIME TO CHANGE USING TBLS\n         BH    CKDARNG                 NO\n         BAL   R9,NEXUSG               YES, GO DO IT\nCKDARNG  L     R12,NOINAD              GET DATA ONLY ENTRY ADDRESS\n         CLC   TXTOFSET,0(R12)         NOT YET TO THIS RANGE\n         BL    CKLOSEQ                 TRUE\n         CLC   TXTOFSET,3(R12)         NOW IN THE RANGE\n         BNH   CONST                   TRUE, TREAT AS CONSTANT\n         LA    R12,6(R12)              PAST THIS ONE, STEP TO NEXT\n         ST    R12,NOINAD              SAVE NEW ADDRESS\n         B     CKDARNG                 AND CHECK AGAIN\nCKLOSEQ  DS    0H\n         C     R6,CURRLBL              END OF USED LABEL TABLE?\n         BNL   GCKODD                  IF SO, IGNORE LABEL STUFF\n         CLC   TXTOFSET,LBLADR         LABEL ENTRY OUT OF SEQ\n         BNH   GCKODD                  NO, CONTINUE\n         BAL   R9,FORCONST             YES, FORCE ANY CONSTANT OUT\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL\n         B     CKLOSEQ                 CONTINUE SEQ CHK\nGCKODD   TM    TXTCURR+3,1             ODD ADDRESS\n         BO    CONST                   YES, NOT INSTR\n         CLC   1(3,R7),0(R7)           4 CONSEC IDENTICAL BYTES\n         BE    CONST                   YES, NOT INSTR\n         TRT   0(1,R7),CHARTRAN        TEST TEXT BYTE\n         BNZ   CKINSTR                 NOT CHARACTER\n         CLI   CONPROG,1               IS CONSTANT IN PROGRESS\n         BNE   CK6                     NO\n         CLI   CONTYPE,C'C'            IS IT CHARACTER TYPE\n         BE    CONST                   YES, ADD THIS TO CONSTANT\nCK6      TRT   0(6,R7),CHARTRAN        6 CONSECUTIVE CHARACTERS\n         BZ    CONST                   YES, NOT INSTRUCTION\nCKINSTR  SR    R8,R8                   CLEAR WORK\n         IC    R8,0(R7)                PICK UP TXT BYTE\n         MH    R8,SGOPLEN              TIMES TABLE LENGTH\n         LA    R8,SGLOP(R8)            @ INSTR TBL ENTRY\n         MVC   INSTENT,0(R8)           SAVE INSTRUCTION TBL ENTRY\n         CLI   INAME,0                 IS IT AN INSTR OP-CODE\n         BE    CONST                   NO\n         CLI   ITYPE,TWO               TWO-BYTE OP-CODE\n         BNE   INSTR                   NO\n         L     R8,DBLOPAD              YES, GET 2-BYTE TBL ADDR\nDBLND    CLI   0(R8),X'FF'             END OF TABLE\n         BE    CONST                   YES, NOT INSTR\n         CLC   0(2,R8),0(R7)           THIS ENTRY MATCHES TXT\n         BE    GOTDBLI                 YES\n         LA    R8,L'DBLOP(R8)          TO NEXT ENTRY\n         B     DBLND                   LOOP THRU TBL\nGOTDBLI  LA    R8,2(R8)                PASS OP-CODE BYTES\n*\n*\n*\n******************************************************************\n*                                                                *\n* CHECK TO SEE IF THIS BYTE OF THE PROGRAM IS AN INSTRUCTION OP  *\n* CODE. IF SO, PERFORM THE APPROPRIATE PROCESSING ROUTINE.       *\n*                                                                *\n******************************************************************\n*\nINSTR    EQU   *                       *** INSTRUCTIONS (POSSIBLY) ***\n*                                                                   RH\n*                                 CHECK THIS INSTRUCTION            RH\n*                                                                   RH\n         CLI   0(R7),X'80'        IS IT AN SSM INSTR?               RH\n         BNE   INSTR2             NO, ON WE GO                      RH\n         CLI   1(R7),X'00'        YES, IS THERE A BASE REG?         RH\n         BE    CONST              NO, IT'S NOT AN SSM INSTR THEN    RH\n         SPACE 1                                                    RH\nINSTR2   DS    0H                      *** INSTRUCTIONS (POSSIBLY)  RH\n*                                                                   RH\n*                                 CHECK NEXT INSTRUCTION            RH\n*                                                                   RH\n         MVC   ILENG+1(1),INLNG        SET INSTR LENGTH\n         LH    R12,ILENG               PICK UP LENGTH\n         AR    R12,R7                  ADDR OF NEXT OP CODE\n         SR    R15,R15                 CLEAR WORK\n         IC    R15,0(R12)              PICK UP NEXT OP-CODE\n         MH    R15,SGOPLEN             TIMES TBL ENTRY LENG\n         LA    R15,SGLOP(R15)          INSTR TBL ENTRY ADDR\n         CLI   INAME-INSTENT(R15),0    IS IT AN OP-CODE\n         BNE   ICKSEC                  YES\n*                                                                   RH\n*              CHECK 2ND BYTE ALONG FOR INSTRUCTION                 RH\n*                                                                   RH\n         AH    R15,SGOPLEN        R15 -> TO NEXT BYTE               RH\n         AH    R15,SGOPLEN        R15 MAY -> TO NEXT INST           RH\n         CLI   INAME-INSTENT(R15),0    IS IT AN OP-CODE             RH\n         BNE   ICKSEC                  YES                          RH\n*                                                                   RH\n*                                 CHECK FIRST INSTRUCTION           RH\n*                                                                   RH\n         SPACE 1                                                    RH\n         LR    R12,R7             R12 -> TO FIRST INSTRUCTION       RH\n         B     ICKSEC2            GO CHECK THIS INST                RH\n         SPACE 1                                                    RH\n*        CLI   0(R7),X'45'             IS IT BAL\n*        BE    ICKTBL                  YES, CONTINUE\n*        CLI   0(R12),X'4D'            IS IT BAS\n*        BE    ICKTBL                  YES, CONTINUE\n*        CLI   0(R12),X'0B'            IS IT BSM\n*        BE    ICKTBL                  YES, CONTINUE\n*        CLI   0(R7),7                 NO, IS IT BCR\n*        BE    POSSB                   YES\n*        CLI   0(R7),X'47'             IS IT BC\n*        BNE   CONST                   NO, THEN THIS NOT INSTR\n*POSSB   TM    1(R7),X'F0'             IS IT UNCONDL BRCH\n*        BNO   CONST                   NO, THEN THIS NOT INSTR\n*        B     ICKTBL                  ACCEPT UNCOND BRCHS\n*                                                                   RH\n*                                 CHECK THIRD INSTRUCTION           RH\n*                                                                   RH\nICKSEC   SR    R1,R1                   CLEAR WORK\n         IC    R1,INLNG-INSTENT(R15)   GET INSTR LENGTH\n         AR    R1,R12                  ADDR OF NEXT OP CODE\n         SR    R14,R14                 CLEAR WORK\n         IC    R14,0(R1)               PICK UP NEXT OP-CODE\n         MH    R14,SGOPLEN             TIMES TBL ENTRY LENG\n         LA    R14,SGLOP(R14)          INSTR TBL ENTRY ADDR\n         CLI   INAME-INSTENT(R14),0    IS IT AN OP-CODE\n         BNE   ICKTBL                  YES\n*                                                                   RH\n*                                 CHECK 1ST INSTRUCTION             RH\n*                                                                   RH\n*        CLI   0(R7),X'45'        IS FIRST INST A BAL?              RH\n*        BE    ICKTBL             YES, CONTINUE                     RH\n*        CLI   0(R12),X'4D'            IS IT BAS\n*        BE    ICKTBL                  YES, CONTINUE\n*        CLI   0(R12),X'0B'            IS IT BSM\n*        BE    ICKTBL                  YES, CONTINUE\n         CLI   0(R7),X'05'             NO, IS IT BALR?              RH\n         BE    ICKTBL                  YES                          RH\n         CLI   0(R7),X'06'             NO, IS IT BCTR?              RH\n         BE    ICKTBL                  YES                          RH\n         CLI   0(R7),X'07'             NO, IS IT BCR?               RH\n         BE    ICKTBL                  YES                          RH\n         CLI   0(R7),X'45'             IS IT BAL                    RH\n         BE    ICKTBL                  YES, CONTINUE                RH\n         CLI   0(R7),X'46'             IS IT BCT?                   RH\n         BE    ICKTBL                  YES, CONTINUE                RH\n         CLI   0(R7),X'47'             IS IT BC?                    RH\n         BE    ICKTBL                  YES                          RH\n         CLI   0(R7),X'86'             IS IT BXH?                   RH\n         BE    ICKTBL                  YES, CONTINUE                RH\n         CLI   0(R7),X'87'             IS IT BXLE?                  RH\n         BE    ICKTBL                  YES                          RH\n*                                                                   RH\n*                                 CHECK 1ST OR 2ND INSTRUCTION      RH\n*                                                                   RH\nICKSEC2  DS    0H                                                   RH\n         CLI   0(R12),X'05'            NO, IS IT BALR?              RH\n         BE    ICKTBL                  YES                          RH\n         CLI   0(R12),X'06'            NO, IS IT BCTR?              RH\n         BE    ICKTBL                  YES                          RH\n         CLI   0(R12),X'07'            NO, IS IT BCR?               RH\n         BE    POSSB2                  YES                          RH\n         CLI   0(R12),X'45'            IS IT BAL                    RH\n         BE    ICKTBL                  YES, CONTINUE                RH\n         CLI   0(R12),X'46'            IS IT BCT?                   RH\n         BE    ICKTBL                  YES, CONTINUE                RH\n         CLI   0(R12),X'47'            IS IT BC?                    RH\n         BE    POSSB3                  YES                          RH\n         CLI   0(R12),X'86'            IS IT BXH?                   RH\n         BE    ICKTBL                  YES, CONTINUE                RH\n         CLI   0(R12),X'87'            IS IT BXLE?                  RH\n         BNE   CONST                   NO, THEN THIS NOT INSTR\n         SPACE 1                                                    RH\nPOSSB2   DS    0H                 CHECK MASK FOR BCR INST           RH\n         TM    1(R12),X'F0'       IS IT UNCONDL BRCH                RH\n         BO    ICKTBL             YES                               RH\n         TM    1(R12),X'E0'       IS IT A BNO ?                     RH\n         BO    ICKTBL             YES                               RH\n         TM    1(R12),X'D0'       IS IT A BNH/BNP ?                 RH\n         BO    ICKTBL             YES                               RH\n         TM    1(R12),X'B0'       IS IT A BNL/BNM ?                 RH\n         BO    ICKTBL             YES                               RH\n         TM    1(R12),X'80'       IS IT A BE/BZ ?                   RH\n         BO    ICKTBL             YES                               RH\n         TM    1(R12),X'70'       IS IT A BNE/BNZ ?                 RH\n         BM    ICKTBL             YES                               RH\n         TM    1(R12),X'40'       IS IT A BL/BM ?                   RH\n         BO    ICKTBL             YES                               RH\n         TM    1(R12),X'20'       IS IT A BH/BP ?                   RH\n         BO    ICKTBL             YES                               RH\n         SPACE 1                                                    RH\n         TM    1(R12),X'10'       IS IT A NOP?                      RH\n         BZ    ICKTBL             YES                               RH\n         BO    ICKTBL             NO, BUT ITS A BO                  RH\n         SPACE 1                                                    RH\n         B     CONST              NOT AN INST                       RH\n         SPACE 1                                                    RH\nPOSSB3   DS    0H                 CHECK MASK FOR BC INST            RH\n         TM    1(R12),X'0F'       OVER X...0?                       RH\n         BM    CONST              YES, NOT AN INST                  RH\n         SPACE 1                                                    RH\n         CLI   1(R12),X'10'            IS IT A NOP?                 RH\n         BL    ICKTBL             YES                               RH\n         BE    ICKTBL             NO, BUT ITS A BO                  RH\n         SPACE 1                                                    RH\n         CLI   1(R12),X'20'       IS IT A BH/BP ?                   RH\n         BE    ICKTBL             YES                               RH\n         CLI   1(R12),X'40'       IS IT A BL/BM ?                   RH\n         BE    ICKTBL             YES                               RH\n         CLI   1(R12),X'70'       IS IT A BNE/BNZ ?                 RH\n         BE    ICKTBL             YES                               RH\n         SPACE 1                                                    RH\n         CLI   1(R12),X'80'       IS IT A BE/BZ ?                   RH\n         BE    ICKTBL             YES                               RH\n         CLI   1(R12),X'B0'       IS IT A BNL/BNM ?                 RH\n         BE    ICKTBL             YES                               RH\n         CLI   1(R12),X'D0'       IS IT A BNH/BNP ?                 RH\n         BE    ICKTBL             YES                               RH\n         CLI   1(R12),X'E0'       IS IT A BNO ?                     RH\n         BE    ICKTBL             YES                               RH\n         CLI   1(R12),X'F0'            IS IT BRCH\n         BNE   CONST                   NO, THEN THIS NOT INSTR\nICKTBL   LH    R12,ILENG               GET INSTR LENGTH\n         AR    R12,R7                  @ NEXT TEXT LOC\n         BCTR  R12,R0                  BACK UP 1\n         S     R12,TXTSTRT             RELATIVIZE IN CSECT\n         CLM   R12,7,LBLADR            LBL TBL ADDR HERE\n         BL    NOILBL                  NO\n         CLC   TXTOFSET,LBLADR         LABEL AT INSTR START\n         BNE   CONST                   NO, MUST BE CONSTANT\n         CLI   LBLTYP,C'L'             IS IT A LABEL ONLY\n         BNE   CONST                   NO\n         CLI   CONPROG,1               CONSTANT IN PROGRESS\n         BNE   SETLBL                  NO\n         BAL   R9,FORCONST             YES, FORCE IT OUT\nSETLBL   LA    R6,L'LABEL(R6)          TO NEXT LABEL TBL ENTRY\n         B     ICKTBL                  GO CHECK NEXT LABEL\nNOILBL   CLI   CONPROG,1               CONSTANT IN PROGRESS\n         BNE   MVMNE                   NO\n         BAL   R9,FORCONST             YES, FORCE IT OUT\nMVMNE    MVC   MNEMONIC,0(R8)          SET INSTR MNEMONIC\n         MVC   OFFSET,TXTOFSET         SET OFFSET\n         MVC   INSTYP,5(R8)            SET INSTR TYPE\n         MVI   TYPE,X'0D'              SHOW IT IS AN INSTRUCTION\n         MVC   LEN,ILENG+1             SHOW LENGTH\n         MVC   TEXT(6),0(R7)           MOVE ACTUAL TEXT\nOPNDFMT  TM    ICLASS,FLTPT            FLOATING POINT OP-CODE\n         BO    FPVERFY                 YES, GO VERIFY\n         CLI   IEDT,0                  ANY EDIT REQUIRED\n         BE    PFMFMT                  NO\n         B     IVERFY                  YES, GO EDIT\nPFMFMT   SR    R1,R1                   CLEAR WORK\n         IC    R1,INSTYP               GET INSTRUCTION TYPE\n         L     R9,OPND9                GET FORMAT ROUTINE RETURN ADDR\n         B     *+4(R1)                 TO APPROPRIATE FORMATTING ROUTIN\n         B     INSTOUT                 TYPE=0, RR\n         B     RXOPND                  TYPE=4, RX\n         B     SOPND                   TYPE=8, S\n         B     SIOPND                  TYPE=C, SI\n         B     RSOPND                  TYPE=10, RS\n         B     SS1OPND                 TYPE=14, 1-LENGTH SS\n         B     SS2OPND                 TYPE=18, 2-LENGTH SS\n         B     SOPND                   TYPE=1C, 2-BYTE OP-CODES\n         B     RXOPND                  TYPE=20, CONDITIONAL BRANCH\n         B     SVCOPND                 TYPE=24, SVC\n         B     SSEOPND                 TYPE=28, SSE\n         B     EOPND                   TYPE=2C, E\n         B     INSTOUT                 TYPE=30, RRE 1 OPERAND\n         B     INSTOUT                 TYPE=34, RRE 2 OPERANDS\nOPNDRTN  B     INSTOUT                 NORMAL OPERAND FORMAT RETURN\n         B     CONST                   ERROR INSTRUCTION, TREAT AS CONS\nINSTOUT  AH    R7,ILENG                STEP TO NEXT TEXT BYTE\n         ST    R7,TXTCURR              SAVE NEXT ADDR\n         MVC   CCTYPE,ICCSET           SHOW COND CODE SET TYPE\n         B     GETCURR                 CONTINUE TXT PROCESSING\n*\n*\n*\n******************************************************************\n*                                                                *\n* GENERAL OP-CODE TESTS TO VERIFY THAT NON-FLOATING-POINT OP     *\n* CODES ARE INDEED OP-CODES.                                     *\n*                                                                *\n******************************************************************\n*\nIVERFY   EQU   *                       *** VERIFY POSSIBLE INSTRUCTION\n         TM    IEDT,EPR                EVEN-ODD REG PAIR\n         BZ    IVE2                    NO\n         TM    1(R7),X'10'             R1 IS ODD\n         BO    CONST                   YES, NOT INSTR\n         CLI   0(R7),X'0E'             IS IT MVCL\n         BE    IVTRG2                  YES\n         CLI   0(R7),X'0F'             IS IT CLCL\n         BNE   IVE2                    NO\nIVTRG2   TM    1(R7),X'01'             R2 IS ODD\n         BO    CONST                   YES, NOT INSTR\n         SR    R1,R1                   CLEAR WORK\n         SR    R2,R2                   CLEAR WORK\n         IC    R1,1(R7)                GET R1R2\n         SRL   R1,4                    SHIFT OUT R2\n         PACK  DBLWD(1),1(1,R7)        FLIP R1R2 BYTE\n         IC    R2,DBLWD                PICK UP R2R1\n         SRL   R2,4                    SHIFT OUT R1\n         CR    R1,R2                   R1=R2\n         BE    CONST                   YES, NOT INSTR\n         B     PFMFMT                  NO, GOOD INSTR\nIVE2     TM    IEDT,E2                 HALFWORD STORAGE ALIGNMENT\n         BZ    IVE4                    NO\n         TM    3(R7),X'01'             DISPL IS ODD\n         BZ    IVES2                   NO, O.K.\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   IVES2                   NO, CONTINUE\n         CLI   0(R7),X'44'             EX OP CODE\n         BE    CONST                   YES, NOT INSTR\n         CLI   0(R7),X'47'             BC OP CODE\n         BE    CONST                   YES, NOT INSTR\n         CLI   ITYPE,RS                RS INSTRUCTION\n         BE    CONST                   YES, NOT INSTR\n         TM    1(R7),X'0F'             INDEX REG IS 0\n         BZ    CONST                   YES, NOT INSTR\n         B     IVES2                   CONTINUE\nIVE4     TM    IEDT,E4                 2ND OPND ON FULLWORD BOUND\n         BZ    IVE8                    NO\n         TM    3(R7),X'03'             DISPL DIV BY 4\n         BZ    IVES2                   YES, O.K.\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   IVES2                   NO, CONTINUE\n         CLI   ITYPE,RS                RS INSTRUCTION OP CODE\n         BE    CONST                   YES, NOT INSTR\n         TM    1(R7),X'0F'             INDEX REG = 0\n         BZ    CONST                   YES, NOT INSTR\n         B     IVES2                   NO, CONTINUE\nIVE8     TM    IEDT,E8                 2ND OPND ON DBLWD BOUND\n         BZ    IVES2                   NO\n         TM    3(R7),X'07'             DISPL DIV BY 8\n         BZ    IVES2                   YES, O.K.\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   IVES2                   NO\n         TM    1(R7),X'0F'             INDEX REG = 0\n         BZ    CONST                   YES, NOT INSTR\nIVES2    CLI   PRIVASM,1               PRIVILEGED INSTR O.K.\n         BE    PFMFMT                  YES\n         TM    IEDT,S2                 OPND2 MUST HAVE BASE\n         BZ    IVES1                   NO\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   PFMFMT                  NO, O.K.\n         CLI   ITYPE,RS                RS INSTRUCTION\n         BE    CONST                   YES, NOT INSTR\n         CLI   0(R7),X'92'             IS IT MVI OP CODE\n         BE    CONST                   YES, NOT INSTR\n         TM    1(R7),X'0F'             INDEX REG = 0\n         BZ    CONST                   YES, NOT INSTR\n         B     PFMFMT                  NO, GOOD INSTR\nIVES1    TM    IEDT,S1                 1ST OPND MUST HAVE BASE\n         BZ    PFMFMT                  NO, CONTINUE\n         TM    2(R7),X'F0'             1ST OPND HAS BASE\n         BZ    CONST                   NO, NOT INSTR\n         B     PFMFMT                  YES, INSTR O.K.\n*\n*\n*\n******************************************************************\n*                                                                *\n* GENERAL OP-CODE TESTS TO VERIFY THAT FLOATING-POINT OP-CODES   *\n* ARE INDEED OP-CODES.                                           *\n*                                                                *\n******************************************************************\n*\nFPVERFY  EQU   *                       *** VALIDATE FLOATING POINT OP-C\n         TM    1(R7),X'90'             R1 IS 0, 2, 4, OR 6\n         BNZ   CONST                   NO, NOT INSTR\n         CLI   0(R7),X'27'             MXDR OP-CODE\n         BE    FPR1EXT                 YES\n         CLI   0(R7),X'67'             MXD OP-CODE\n         BNE   FPCKTYP                 NO\nFPR1EXT  TM    1(R7),X'B0'             R1 IS 0 OR 4\n         BNZ   CONST                   NO, NOT INSTR\nFPCKTYP  CLI   ITYPE,RR                RR TYPE INSTRUCTION\n         BNE   FPRXVER                 NO\n         TM    1(R7),X'09'             R2 IS 0, 2, 4, 6\n         BNZ   CONST                   NO, NOT INSTR\n         CLI   0(R7),X'25'             LRDR OP CODE\n         BE    FPR2EXT                 YES\n         CLI   0(R7),X'37'             SXR OP-CODE\n         BE    FPR2EXT                 YES\n         CLI   0(R7),X'26'             MXR OP-CODE\n         BE    FPR2EXT                 YES\n         CLI   0(R7),X'36'             AXR OP-CODE\n         BNE   PFMFMT                  NO, GOOD INSTR\nFPR2EXT  TM    1(R7),X'0B'             R2 IS 0 OR 4\n         BZ    PFMFMT                  YES, GOOD INSTR\n         B     CONST                   NO, NOT INSTR\nFPRXVER  CLI   PRIVASM,1               PRIVILEGED INSTRUCTIONS O.K.\n         BE    FPALIGN                 YES\n         TM    2(R7),X'F0'             ANT BASE REG\n         BNZ   FPALIGN                 YES\n         TM    1(R7),X'0F'             ANY INDEX REG\n         BZ    CONST                   NO, NOT INSTR\nFPALIGN  TM    2(R7),X'F0'             ANY BASE REG\n         BNZ   PFMFMT                  YES, ACCEPT INSTR\n         TM    1(R7),X'0F'             ANY INDEX REG\n         BNZ   PFMFMT                  YES, ACCEPT INSTR\n         TM    3(R7),X'03'             DISPL DIV BY 4\n         BNZ   CONST                   NO, NOT INSTR\n         TM    ICLASS,FLSHT            SHORT PRECISION\n         BO    PFMFMT                  YES, ACCEPT INSTRUCTION\n         TM    3(R7),X'07'             DISPL DIV BY 8\n         BZ    PFMFMT                  YES, ACCEPT INSTR\n         B     CONST                   NO, NOT INSTR\n*\n*\n*\n******************************************************************\n*                                                                *\n* PROCESS TEXT BYTES DETERMINED TO BE CONSTANT DATA.             *\n*                                                                *\n******************************************************************\n*\nCONST    EQU   *                       *** PROCESS CONSTANTS ***\n         MVC   WORKREC,BLANX           CLEAR WORK RECORD AREA\n         CLI   CONPROG,1               CONSTANT IN PROGRESS\n         BNE   CCNEW                   NO\n         CLC   TXTOFSET,LBLADR         LABEL ENTRY HAS THIS OFFSET\n         BNE   CGETYP                  NO\nCSTNEW   BAL   R9,FORCONST             FORCE IT OUT\n         B     CCNEW                   GO START A NEW ONE\nCGETYP   TRT   0(1,R7),CHARTRAN        CHECK DATA TYPE OF BYTE\n         BNZ   CHEX                    IT'S HEX\n         SPACE 1                                                    RH\nNOTHEX   DS    0H                                                   RH\n         MVI   CCKTYP+1,C'C'           SET TYPE IN COMPARE\n         B     CCKTYP                  GO COMPARE\nCHEX     MVI   CCKTYP+1,C'X'           SET TYPE IN COMPARE\n         TRT   0(1,R7),HEXTRAN         CHECK DATA TYPE OF BYTE      RH\n         BZ    NOTHEX                  IT'S CHARACTER               RH\n         MVI   CCKTYP+1,C'X'           SET TYPE IN COMPARE          RH\nCCKTYP   CLI   CONTYPE,C' '            TYPE IN PROG SAME AS THIS BYTE\n         BNE   CSTNEW                  NO\nCUPDCON  LH    R11,CONLEN              GET CURRENT LENGTH\n         LA    R11,1(R11)              ADD 1\n         STH   R11,CONLEN              UPDATE LENGTH\n         CLI   CONTYPE,C'C'            CHARACTER CONSTANT\n         BE    CCK8                    YES\n         TM    CONOFST+3,1             OFFSET IS ODD\n         BO    CCFIN1                  YES\n         TM    CONOFST+3,2             HALFWORD OFFSET\n         BZ    CCFWD                   NO\n         CLI   CONLEN+1,1              HALFWORD, IS LENGTH = 1\n         BE    CCXIT1                  YES\n         B     CCFIN1                  NO\nCCFWD    CLI   CONLEN+1,4              NO, IS HEX CONST 4 BYTES\n         BL    CCXIT1                  NOT YET\nCCFIN1   BAL   R9,FORCONST             MAX LENG, FORCE IT OUT\n         B     CCXIT1                  FINISH\nCCK8     CLC   CONLEN,H8               CHAR CONSTANT 8 BYTES\n         BNL   CCFIN1                  YES\nCCXIT1   LA    R7,1(R7)                STEP OVER 1 BYTE IN TEXT\n         ST    R7,TXTCURR              UPDATE TEXT ADDR\n         B     GETCURR                 CONTINUE TEXT PROCESSING\nCCNEW    MVI   CONPROG,1               SHOW CONSTANT IN PROGRESS\n         MVC   CONOFST,TXTOFST         SET OFFSET TO 1ST BYTE\n         MVC   CONLEN,XZROS            CLEAR LENGTH\n         CLC   TXTOFSET,LBLADR         LABEL AT THIS OFFSET\n         BE    CLBLD                   YES\nTRTYPE   TRT   0(1,R7),CHARTRAN        CHECK DATA TYPE OF BYTE\n         BNZ   CCSHX                   IT'S HEX\n         MVI   CONTYPE,C'C'            IT'S CHAR, SO INDICATE\n         B     CUPDCON                 GO COMPLETE\nCCSHX    MVI   CONTYPE,C'X'            IT'S HEX, SO INDICATE\n         B     CUPDCON                 GO COMPLETE\nCLBLD    CLI   LBLTYP,C'L'             IS IT A LABEL ONLY\n         BNE   CDATACON                NO\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY\n         CLC   TXTOFSET,LBLADR         THIS LABEL AT SAME ADDR\n         BNE   TRTYPE                  NO\n         CLI   LBLTYP,C'L'             THIS ANOTHER LABEL ONLY\n         BNE   CDATACON                NO\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY\n         B     CCNEW                   GO TO NEXT LABEL\nCDATACON MVC   CONTYPE,LBLTYP          TYPE TO CONSTANT AREA\n         SR    R1,R1                   CLEAR WORK\n         IC    R1,LBLLEN               PICK UP CONSTNT LENGTH\n         STH   R1,CONLEN               SAVE CONSTANT LENGTH\n         SR    R11,R11                 CLEAR WORK REG\n         IC    R11,LBLLEN              PICK UP LENGTH\n         AR    R7,R11                  STEP PAST TEXT\n         ST    R7,TXTCURR              UPDATE TEXT ADDRESS\n         BAL   R9,FORCONST             FORCE CONSTANT OUT\n         LA    R6,L'LABEL(R6)          STEP TO NEXT LABEL ENTRY\n         B     GETCURR                 CONTINUE TEXT PROCESS\n         DROP  R6\n*\n*\n*\n******************************************************************\n*                                                                *\n* CLEAR OUT AREAS SET UP FOR CONSTANT DATA.                      *\n*                                                                *\n******************************************************************\n*\nFORCONST EQU   *                       *** FORCE OUT CONSTANT IN PROGRE\n         MVI   CONPROG,0               RESET CONSTANT IN PROGRESS\n         MVI   CONTYPE,0               RESET TYPE\n         XC    CONLEN,CONLEN           CLEAR LENGTH\n         MVC   CONOFST,XZROS           CLEAR OFFSET TO CONSTANT\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* PROCESS RX-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS  *\n* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *\n*                                                                *\n******************************************************************\n*\nRXOPND   EQU   *                       *** RX FORMAT INSTRUCTIONS ***\n         SR    R11,R11                 CLEAR WORK REG\n         ICM   R11,3,TEXT+2            GET BDDD\n         LA    R10,4                   SET LENGTH = 4\n         TM    INLNG,E4                FULLWORD OPERAND\n         BO    RXBDDD                  YES\n         LA    R10,2                   SET LENGTH = 2\n         TM    INLNG,E2                HALFWORD OPERAND\n         BO    RXBDDD                  YES\n         LA    R10,1                   SET LENGTH = 1\n         TM    INLNG,E8                DOUBLEWORD OPERAND\n         BZ    RXBDDD                  NO\n         LA    R10,8                   YES, SET LENGTH = 8\nRXBDDD   B     BDLADR                  CHECK LABEL\n*\n*\n*\n******************************************************************\n*                                                                *\n* PROCESS S-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS   *\n* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *\n*                                                                *\n******************************************************************\n*\nSOPND    EQU   *                       *** S FORMAT INSTRUCTIONS ***\n         CLI   1(R7),0                 BYTE 2 OF INSTR IS ZERO\n         BE    SCK2                    YES\n         CLI   0(R7),X'80'             NO, IS IT SSM\n         BE    4(R9)                   YES, NOT INSTR\n         CLI   0(R7),X'82'             NO, IS IT LPSW\n         BE    4(R9)                   YES, NOT INSTR\n         CLI   0(R7),X'93'             NO, IS IT TS\n         BE    4(R9)                   YES, NOT INSTR\nSCK2     CLI   0(R7),X'B2'             OP-CODE IS B2\n         BNE   SSTRT                   NO\n         CLC   2(2,R7),XZROS           3RD AND 4TH BYTES ZERO\n         BE    SSTRT                   YES\n         CLI   1(R7),X'0B'             IPK INSTRUCTION\n         BE    4(R9)                   YES, NOT INSTR\n         CLI   1(R7),X'0D'             PTLB INSTR\n         BE    4(R9)                   YES, NOT INSTR\nSSTRT    SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDDD\n         LA    R10,4                   SET LENGTH = 4\n         TM    INLNG,E4                FULLWORD OPERAND\n         BO    SBDDD                   YES\n         LA    R10,2                   SET LENGTH = 2\n         TM    INLNG,E2                HALFWORD OPERAND\n         BO    SBDDD                   YES\n         LA    R10,1                   SET LENGTH = 1\n         TM    INLNG,E8                DOUBLEWORD OPERAND\n         BZ    SBDDD                   NO\n         LA    R10,8                   YES, SET LENGTH = 8\nSBDDD    B     BDLADR                  CHECK FOR LABEL\n*\n*\n*\n******************************************************************\n*                                                                *\n* PROCESS SI-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS  *\n* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *\n*                                                                *\n******************************************************************\n*\nSIOPND   EQU   *                       *** SI FORMAT INSTRUCTIONS ***\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDDD ADDRESS\n         LA    R10,0                   LENGTH=DON'T CARE\n         B     BDLADR                  CHECK FOR LABEL\n*\n*\n*\n******************************************************************\n*                                                                *\n* PROCESS RS-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS  *\n* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *\n*                                                                *\n******************************************************************\n*\nRSOPND   EQU   *                       *** RS FORMAT INSTRUCTIONS ***\n         CLI   0(R7),X'88'             IS IT SHIFT INSTR\n         BL    RSCMA1                  NO\n         CLI   0(R7),X'8F'             IS IT SHIFT INSTR\n         BH    RSCMA1                  NO\n         TM    1(R7),X'0F'             SHIFT, IS R3 POS = 0\n         BZ    0(R9)                   YES, GOOD SHIFT\n         B     4(R9)                   NO, NOT INSTR\nRSCMA1   SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDD ADDRESS\n         LA    R10,4                   SET LENGTH = 4\n         TM    INLNG,E4                FULLWORD OPERAND\n         BO    RSBDDD                  YES\n         LA    R10,2                   SET LENGTH = 2\n         TM    INLNG,E2                HALFWORD OPERAND\n         BO    RSBDDD                  YES\n         LA    R10,1                   SET LENGTH = 1\n         TM    INLNG,E8                DOUBLEWORD OPERAND\n         BZ    RSBDDD                  NO\n         LA    R10,8                   YES, SET LENGTH = 8\nRSBDDD   B     BDLADR                  CHECK FOR LABEL\n*\n*\n*\n******************************************************************\n*                                                                *\n* PROCESS SS-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESSES*\n* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION. THE     *\n* SINGLE-LENGTH SS FORMAT INSTRUCTIONS ARE HANDLED HERE.         *\n*                                                                *\n******************************************************************\n*\nSS1OPND  EQU   *                       *** SS FORMAT INSTRUCTIONS - SIN\n         SR    R10,R10                 CLEAR WORK\n         IC    R10,TEXT+1              GET LENGTH CODE\n         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDDD ADDRESS\n         LA    R1,SS1RTN               GET RTEURN ADDR\n         MVC   SAVOP9,OPND9            SAVE NORMAL RETURN ADDR\n         ST    R1,OPND9                CHANGE RETURN ADDR\n         B     BDLADR                  CHECK LABEL\nSS1RTN   MVC   OPND9,SAVOP9            RESTORE NORMAL RETURN ADDR\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+4            GET SECOND BDDD ADDRESS\n         SR    R10,R10                 CLEAR LENGTH REG\n         IC    R10,TEXT+1              GET INSTR LENGTH\n         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH\n         B     BDLADR                  CHECK FOR LABEL\n*\n*\n*\n******************************************************************\n*                                                                *\n* PROCESS SS-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESSES*\n* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION. THE     *\n* DOUBLE-LENGTH SS FORMAT INSTRUCTIONS ARE HANDLED HERE.         *\n*                                                                *\n******************************************************************\n*\nSS2OPND  EQU   *                       *** SS FORMAT INSTRUCTIONS - 2 L\n         SR    R10,R10                 CLEAR WORK\n         IC    R10,TEXT+1              GET L1L2\n         SRL   R10,4                   SHIFT OUT L2\n         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDDD ADDRESS\n         LA    R1,SS2RTN               GET RETURN ADDR\n         MVC   SAVOP9,OPND9            SAVE NORMAL RETURN ADDR\n         ST    R1,OPND9                CHANGE RETURN ADDRESS\n         B     BDLADR                  CHECK LABEL\nSS2RTN   MVC   OPND9,SAVOP9            RESTORE NORMAL RETURN ADDR\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+4            GET 2ND BDDD ADDR\n         PACK  DBLWD(1),TEXT+1(1)      FLIP LENGTH BYTE\n         SR    R10,R10                 CLEAR WORK\n         IC    R10,DBLWD               PICK UP L2L1\n         SRL   R10,4                   SHIFT OUT L1\n         CLI   TEXT,X'F0'              SRP OP-CODE\n         BNE   SS2BDDD                 NO\n         IC    R10,TEXT+1              GET INSTR LENGTH\n         SRL   R10,4                   SHIFT OUT I3\nSS2BDDD  LA    R10,1(R10)              COMPUTE ACTUAL LENGTH\n         B     BDLADR                  CHECK LABEL\n*\n*\n*\n******************************************************************\n*                                                                *\n* PROCESS SVC INSTRUCTIONS. THE SOLE PROCESSING IS TO VERIFY THAT*\n* THIS IS A VALID SVC.                                           *\n*                                                                *\n******************************************************************\n*\nSVCOPND  EQU   *                       *** SVC INSTRUCTIONS ***\n         CLI   TEXT+1,126              VALID OPERAND\n         BH    NOTSVC                  NO, NOT SVC\n         L     R1,SVCTBLAD             GET SVC TABLE ADDRESS\nSVCKND   CLI   0(R1),X'FF'             END OF SVC TABLE\n         BE    NOTSVC                  YES, MUST NOT BE SVC\n         CLC   0(1,R1),TEXT+1          THIS THE ENTRY\n         BE    GOTSVC                  YES\n         LA    R1,L'SVCOP(R1)          STEP TO NEXT ENTRY\n         B     SVCKND                  LOOP THRU TABLE\nNOTSVC   B     4(R9)                   ERROR RETURN\nGOTSVC   BR    R9                      EXIT, NO STORAGE OPND\n*\n*\n*\n******************************************************************\n*                                                                *\n* PROCESS SSE INSTRUCTIONS.                                      *\n*                                                                *\n******************************************************************\n*\nSSEOPND  EQU   *                       *** SSE INSTRUCTIONS ***\n         LA    R1,SSERTN               GET RTEURN ADDR\n         MVC   SAVOP9,OPND9            SAVE NORMAL RETURN ADDR\n         ST    R1,OPND9                CHANGE RETURN ADDR\n         SR    R10,R10                 CLEAR LENGTH REG\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET FIRST BDDD ADDRESS\n         B     BDLADR                  CHECK LABEL\nSSERTN   MVC   OPND9,SAVOP9            RESTORE NORMAL RETURN ADDR\n         SR    R10,R10                 CLEAR LENGTH REG\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+4            GET SECOND BDDD ADDRESS\n         B     BDLADR                  CHECK FOR LABEL\n*\n*\n*\n******************************************************************\n* PROCESS E INSTRUCTIONS                                         *\n******************************************************************\nEOPND    EQU   *\n         BR    R9\n*\n*\n*\n******************************************************************\n*                                                                *\n* SET UP CURRENT BASE REGISTERS IN THE BASE TABLE. THE USING     *\n* TABLE IS SCANNED FOR ENTRIES VALID AT THE CURRENT TEXT OFFSET. *\n* WHEN A BASE REGISTER ENTRY IS FOUND TO BE VALID AT THE CURRENT *\n* TEXT OFFSET, THE USING ENTRY IS MOVED TO THE APPROPRIATE LOC-  *\n* ATION IN THE BASE TABLE FOR USE BY THE BDLADR ROUTINE. THE TEXT*\n* OFFSET TO THE NEXT BASE REGISTER CHANGE IS SET SO THAT THIS    *\n* ROUTINE WILL AGAIN BE ENTERED WHEN THE CURRENT BASE REGISTERS  *\n* ARE EXHAUSTED.                                                 *\n*                                                                *\n******************************************************************\n*\nNEXUSG   EQU   *                       *** GET NEXT BASE REGS ***\n         MVI   MORUSG,0                RESET INDICATOR\n         XC    BASES,BASES             CLEAR OLD BASE REG VALUES\n         MVC   NEXCHG,HIVAL            SET NEXT CHANGE LOC HIGH\n         L     R2,USGSTRT              GET USING TBL START\n         USING USINGD,R2\nENDUS    CLI   0(R2),X'FF'             END OF TABLE\n         BCR   8,R9                    YES, EXIT\n         CLC   TXTOFSET,USEND          PAST THIS ONE\n         BNL   ECSTEP                  YES\n         OI    MORUSG,1                SHOW MORE BASES AVAILABLE\nUSBGCK   CLC   TXTOFSET,USBGN          THIS STARTS LATER\n         BNL   CKNEWLO                 NO\n         CLC   USBGN,NEXCHG            BEGINS BEFORE NEXT CHG\n         DS    0H\n         BNL   ECSTEP                  NO\n         MVC   NEXCHG,USBGN            YES, SET NEW CHANGE OFFSET\n         B     ECSTEP                  CONTINUE\nCKNEWLO  CLC   USEND,NEXCHG            NEW LOW CHANGE ADDR\n         BNL   ECMVC                   NO\n         MVC   NEXCHG,USEND            YES, SET LOWER OFFSET\nECMVC    SR    R1,R1                   CLEAR WORK\n         IC    R1,USREG                PICK UP REGISTER\n         MH    R1,USGLEN               TIMES ENTRY LENGTH\n         LA    R1,BASES(R1)            @ TABLE ENTRY\n         MVC   0(L'USING,R1),USING     ENTRY TO TABLE\n         OI    MORUSG,X'80'            SHOW BASE REG CURRENT\nECSTEP   LA    R2,L'USING(R2)          TO NEXT USING TBL ENTRY\n         B     ENDUS                   LOOP THRU USING TBL\n         DROP  R2\n*\n*\n*\n******************************************************************\n*                                                                *\n* A BASE-DISPLACEMENT IS PROVIDED IN REG 11 ON ENTRY. IF ANY     *\n* BASE REGISTERS ARE CURRENT, AND THE BASE REGISTER FOR THE GIVEN*\n* ADDRESS IS A CURRENT PROGRAM BASE REGISTER, A LABEL ENTRY IS   *\n* BUILT. OFFSET TO THE LABEL WILL BE FOUND BY ADDING THE ASSUMED *\n* BASE REGISTER VALUE TO THE GIVEN DISPLACEMENT. THE LABEL NAME  *\n* WILL BE THE LETTER 'A' FOLLOWED BY THE OFFSET.                 *\n*                                                                *\n******************************************************************\n*\nBDLADR   EQU   *                       *** BUILD LABEL ENTRIES ***\n         TM    MORUSG,1                ANY BASES CURRENT\n         BZ    BDLXIT                  NO\n         LR    R2,R11                  COPY BDDD ADDRESS\n         SRL   R2,12                   RIGHT JUSTIFY BASE REG\n         MH    R2,USGLEN               TIMES ENTRY LENGTH\n         LA    R2,BASES(R2)            @ BASE REG TABLE ENTRY\n         USING USINGD,R2\n         CLI   USTYPE,C'P'             IS IT A PROGRAM BASE\n         BNE   BDLXIT                  NO\n         SLL   R11,20                  ISOLATE THE\n         SRL   R11,20                  DDD IN R11\n         SR    R1,R1                   CLEAR WORK\n         ICM   R1,7,USVALU             GET BASE REG VALUE\n         AR    R11,R1                  COMPUTE PROGRAM OFFSET\n         DROP  R2\n         L     R1,CURRLBL              GET LBL TBL ADDR\n         C     R1,ENDLBL               END OF TABLE\n         BL    GOTHOLE                 NO\n         BAL   R9,COMPLBL              YES, COMPRESS DUPLICATES\n         L     R1,CURRLBL              GET NEW CURRENT LBL ADDR\n         C     R1,ENDLBL               STILL AT END\n         BNL   TXTEND                  YES, TERMINATE THIS STAGE\n         USING LABELD,R1\nGOTHOLE  STCM  R11,7,LBLADR            SET LABEL ENTRY OFFSET\n         MVI   LBLNAME,C'A'            BEGIN LABEL NAME\n         LA    R12,LBLADR              @ OFFSET\n         BAL   R9,HEXPRT3              GO CONVERT\n         MVC   LBLNAME+1(6),PRTABL     REST OF NAME\n         MVI   LBLNAME+7,C' '          FINAL BLANK IN NAME\n         MVI   LBLTYP,C'L'             SET LABEL TYPE\n         CLI   TEXT,X'47'              THIS A CONDITIONAL BRANCH\n         BE    INSTREF                 YES\n         CLI   TEXT,X'45'              BAL INSTR\n         BE    INSTREF                 YES\n         CLI   TEXT,X'46'              BCT INSTR\n         BE    INSTREF                 YES\n         CLI   TEXT,X'44'              EX INSTR\n         BE    INSTREF                 YES\n         CLI   TEXT,X'87'              BXLE INSTRUCTION\n         BE    INSTREF                 YES\n         CLI   TEXT,X'86'              BXH INSTRUCTION\n         BNE   BDLSTP                  NO\nINSTREF  SR    R12,R12                 CLEAR WORK REG\n         A     R11,TXTSTRT             BRCH ADDR IN STORED TEXT\n         LA    R10,4                   ASSUME LENGTH IS 4\n         TM    0(R11),X'C0'            TEST HI 2-BITS OF OP-CODE\n         BM    BDLSTP                  01 OR 10 IS 4-BYTE INSTR\n         BO    BDLSIX                  YES, SIX-BYTE INSTR\n         LA    R10,2                   BOTH OFF, 2-BYTE INSTR\n         B     BDLSTP                  CONTINUE\nBDLSIX   LA    R10,6                   SET LENGTH TO 6\nBDLSTP   STC   R10,LBLLEN              LENGTH TO LABEL ENTRY\n         LA    R1,L'LABEL(R1)          TO NEXT ENTRY\n         ST    R1,CURRLBL              SAVE UPDATED TBL ADDR\nBDLXIT   L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\n         DROP  R1\n*\n*\n*\n******************************************************************\n*                                                                *\n* SORT THE LABEL TABLE AND ELIMINATE ANY DUPLICATE ENTRIES.      *\n*                                                                *\n******************************************************************\n*\nCOMPLBL  EQU   *                       *** COMPRESS AND SORT LABEL TABL\n         USING LABELD,R6\n         L     R6,LBLTBL               GET LABEL TABLE ADDR\nLBSTPASS LA    R7,L'LABEL(R6)          @ NEXT LABEL TABLE ENTRY\nLBLND    C     R7,CURRLBL              AT TABLE END\n         BL    LBSAMPS                 NO\nNEXPAS0  LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY\n         C     R6,CURRLBL              END OF TABLE\n         BL    LBSTPASS                NO\n         B     LBFEND                  YES, FIND END\nLBSAMPS  CLC   LBLADR,LBLADR-LABEL(R7) IDENTICAL OFFSETS\n         BH    LBSWCH                  NO, FIRST HIGH, SWITCH\n         BL    LBSTP                   NO, LOW, CONTINUE SCAN\n         CLC   LABEL,0(R7)             ENTRIES ARE IDENTICAL\n         BNE   LBCKLBL                 NO\nLBNULL2  MVC   LBLADR-LABEL(3,R7),HIVAL YES, NULL 2ND\n         B     LBSTP                   AND CONTINUE SCAN\nLBCKLBL  CLC   LBLNAME,LBLNAME-LABEL(R7) IDENTICAL LABELS\n         BNE   LBCKTYP                 NO, CHECK TYPES\nLBCKLN   CLI   LBLLEN,0                THIS ENTRY LENGTH = 0\n         BNE   LBCKLN2                 NO\n         MVI   LBLLEN,X'FF'            YES, SET HIGH LENGTH\nLBCKLN2  CLC   LBLLEN,LBLLEN-LABEL(R7) COMPARE LENGTHS\n         BH    LBSWCH                  1ST LENGTH HIGH, SWITCH ENTRIES\n         B     LBNULL2                 1ST LOW/=, NULL 2ND\nLBCKTYP  CLC   LBLTYP,LBLTYP-LABEL(R7) SAME ENTRY TYPE\n         BNE   LBCK1L                  NO, CHK TYPE ORDER\n         CLI   LBLTYP,C'L'             ARE THEY TYPE L\n         BE    LBSTP                   YES, CONTINUE SCAN\n         CLI   LBLTYP,C'U'             USER LABEL\n         BNE   LBNULL2                 NO\n         B     LBSTP                   YES\nLBCK1L   CLI   LBLTYP,C'U'             1ST IS USER LABEL\n         BNE   LBCK2L                  NO\n         CLI   LBLTYP-LABEL(R7),C'L'   2ND IS TYPE L\n         BE    LBNULL2                 YES, NULL THE 2ND\n         B     LBSTP                   CONTINUE SCAN\nLBCK2L   CLI   LBLTYP-LABEL(R7),C'U'   2ND IS USER LABEL\n         BE    LBSWCH                  YES\n         CLI   LBLTYP,C'L'             1ST IS LABEL TYPE\n         BE    LBSTP                   YES, CONTINUE SCAN\nLBSWCH   MVC   WORKREC(L'LABEL),LABEL  HOLD 1ST ENTRY\n         MVC   LABEL,0(R7)             MOVE 2ND ENTRY TO 1ST\n         MVC   0(L'LABEL,R7),WORKREC   1ST ENTRY TO 2ND LOCATION\n         B     LBSAMPS                 GO RECHECK\nLBSTP    LA    R7,L'LABEL(R7)          TO NEXT LABEL ENTRY\n         B     LBLND                   CONTINUE SCAN\nLBFEND   L     R6,LBLTBL               @ LABEL TABLE\nLBFCKFF  CLI   LABEL,X'FF'             NULL ENTRY\n         BE    LBSTCURR                YES\n         C     R6,CURRLBL              AT FORMER END\n         BE    LBSTCURR                YES\n         LA    R6,L'LABEL(R6)          TO NEXT ENTRY\n         B     LBFCKFF                 LOOP TO FIND END\nLBSTCURR ST    R6,CURRLBL              SAVE NEW TBL END ADDR\n         BR    R9                      EXIT\n         DROP  R6\n*                                                                   RH\n*                                                                   RH\n*                                                                   RH\n******************************************************************  RH\n*                                                                *  RH\n* RESORT THE LABEL TABLE AND ELIMINATE ANY DUPLICATE ENTRIES.    *  RH\n* BASED  ON THE LBLADR AND THE LBLTYPE. WHEN A DUPLICATE IS      *  RH\n* FOUND  DETERMINE  IF THE 2ND LABEL IS ONE OF OUR LABELS. IF    *  RH\n* IT IS,  THEN  SEARCH THE REST OF THE LABEL TABLE LOOKING       *  RH\n* FOR THE SAME LABEL NAME. IF ONE IS FOUND, CHANGE IT FROM OUR   *  RH\n* LABEL TO WHATEVER THE NAME IS IN THE ENTRY POINTED TO BY R6.   *  RH\n*                                                                *  RH\n*                                                                *  RH\n*                                                                *  RH\n******************************************************************  RH\n*                                                                   RH\nCOMPLBL2 EQU   *                  COMPRESS AND RESORT LABEL TABL    RH\n         USING LABELD,R6                                            RH\n         L     R6,LBLTBL               GET LABEL TABLE ADDR         RH\nLBSTPAS1 LA    R7,L'LABEL(R6)          @ NEXT LABEL TABLE ENTRY     RH\nLBLND1   C     R7,CURRLBL              AT TABLE END                 RH\n         BL    LBSAMP1                 NO                           RH\nNEXPAS1  LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY          RH\n         C     R6,CURRLBL              END OF TABLE                 RH\n         BL    LBSTPAS1                NO                           RH\n         B     LBFEND1                 YES, FIND END                RH\nLBSAMP1  CLC   LBLADR,LBLADR-LABEL(R7) IDENTICAL OFFSETS            RH\n         BH    LBSWCH1                 NO, FIRST HIGH, SWITCH       RH\n         BL    LBSTP1                  NO, LOW, CONTINUE SCAN       RH\n         CLC   LBLTYP,LBLTYP-LABEL(R7) IDENTICAL TYPE?              RH\n         BNE   LBSTP1                  NO, CONTINUE SCAN            RH\n         UNPK  WORKREC(7),LBLADR(4)    CREATE LABEL ADDR            RH\n         CLC   WORKREC(6),LBLNAME-LABEL+1(R7) LABEL SAME AS ADDR?   RH\n         BNE   LBSTP1                  NO, ON WE GO                 RH\n         MVC   LBLADR-LABEL(3,R7),HIVAL YES, NULL 2ND               RH\n         LR    R14,R7                  R14 -> AT THIS ENTRY         RH\nNXTLBL   LA    R7,L'LABEL(R7)          @ NEXT LABEL TABLE ENTRY     RH\n         C     R7,CURRLBL              AT TABLE END                 RH\n         BNL   NEXPAS1                 YES, GO START LOOP AT NEXT 1 RH\n         CLC   LBLNAME-LABEL(8,R14),LBLNAME-LABEL(R7) IDENT LABELS  RH\n         BNE   NXTLBL                  NO                           RH\n         MVC   LBLNAME-LABEL(8,R7),LBLNAME CHANGE LABEL             RH\n         B     NXTLBL                  FIND MORE IF ANY             RH\nLBNULL3  MVC   LBLADR-LABEL(3,R7),HIVAL YES, NULL 2ND               RH\n         B     LBSTP1                  AND CONTINUE SCAN            RH\nLBSWCH1  MVC   WORKREC(L'LABEL),LABEL  HOLD 1ST ENTRY               RH\n         MVC   LABEL,0(R7)             MOVE 2ND ENTRY TO 1ST        RH\n         MVC   0(L'LABEL,R7),WORKREC   1ST ENTRY TO 2ND LOCATION    RH\n         B     LBSAMP1                 GO RECHECK                   RH\nLBSTP1   LA    R7,L'LABEL(R7)          TO NEXT LABEL ENTRY          RH\n         B     LBLND1                  CONTINUE SCAN                RH\nLBFEND1  L     R6,LBLTBL               @ LABEL TABLE                RH\nLBFCKFF1 CLI   LABEL,X'FF'             NULL ENTRY                   RH\n         BE    LBSTCUR1                YES                          RH\n         C     R6,CURRLBL              AT FORMER END                RH\n         BE    LBSTCUR1                YES                          RH\n         LA    R6,L'LABEL(R6)          TO NEXT ENTRY                RH\n         B     LBFCKFF1                LOOP TO FIND END             RH\nLBSTCUR1 ST    R6,CURRLBL              SAVE NEW TBL END ADDR        RH\n         BR    R9                      EXIT                         RH\n         DROP  R6                                                   RH\n*                                                                   RH\n*                                                                   RH\n*                                                                   RH\n*\n*\n*\n******************************************************************\n*                                                                *\n* END OF PHASE 1. SORT/COMPRESS THE LABEL TABLE AND RETURN.      *\n*                                                                *\n******************************************************************\n*\nEOJ      EQU   *                       END OF JOB\n         BAL   R9,COMPLBL              SORT/COMPRESS LABEL TBL\n         BAL   R9,COMPLBL2        RESORT/COMPRESS LABEL TBL         RH\n         L     R6,LBLTBL               GET LABEL TABLE ADDR\n         USING LABELD,R6\nEOJCKND  C     R6,CURRLBL              END OF TABLE\n         BNL   EOJ2                    YES\n         CLI   LBLTYP,C'U'             USER LABEL\n         BNE   EOJSTEP                 NO\n         MVI   LBLTYP,C'L'             YES, CHANGE TO TYPE L\nEOJSTEP  LA    R6,L'LABEL(R6)          TO NEXT ENTRY\n         B     EOJCKND                 CONTINUE LOOP\n         DROP  R6\nEOJ2     MVC   PRT,BLANX               CLEAR PRINT\n         L     R13,4(R13)              GET POINTER TO CALLER'S SAVE ARE\n         LM    R14,R12,12(R13)         RESTORE CALLER'S REGS\n         SR    R15,R15                 CLEAR RETURN CODE\n         BR    R14                     RETURN TO CALLER\n*\n*\n*\n******************************************************************\n*                                                                *\n* CONVERT HEX BYTES TO THEIR PRINTABLE EQUIVALENTS. ON ENTRY, REG*\n* 12 CONTAINS THE ADDRESS OF THE FIRST BYTE TO BE CONVERTED. THE *\n* NUMBER OF BYTES IS DETERMINED BY THE ENTRY SELECTED. PRINTABLE *\n* HEX IS PLACED IN THE FIELD PRTABL, TWO CHARACTERS PER BYTE.    *\n*                                                                *\n******************************************************************\n*\nHEXPRT   EQU   *                       HEX TO PRINTABLE ROUTINE\nHEXPRT1  UNPK  PRTABL(3),0(2,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT2  UNPK  PRTABL(5),0(3,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT3  UNPK  PRTABL(7),0(4,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT4  UNPK  PRTABL(9),0(5,R12)      UNPACK HEX\nHEXCLTR  MVZ   PRTABL(8),XZROS         CLEAR FOR TRANSLATE\n         TR    PRTABL(8),TRTBL         MAKE PRINTABLE\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* PRINT A LINE USING THE SYSPRINT DCB DEFINED IN DISASM PHASE 0. *\n*                                                                *\n******************************************************************\n*\nPRINT    EQU   *                       PRINT ROUTINE\n         L     R1,PRINTDCB             @ SYSPRINT DCB\n         TM    48(R1),X'10'            IS SYSPRINT OPEN\n         BNO   CLRPRT                  NO\n         PUT   (1),PRTLINE             WRITE PRINT LINE\nCLRPRT   MVC   PRT,BLANX               CLEAR PRINT LINE\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C' '                SINGLE SPACED\n         BE    SETSGL                  YES\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C'0'                DOUBLE SPACED\n         BE    SETSGL                  YES\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C'-'                TRIPLE SPACED\n         BE    SETSGL                  YES\n         ZAP   LINECT,P0               NO, MUST BE NEW PAGE\nSETSGL   MVI   PCC,C' '                SET SINGLE SPACING\n         CP    LINECT,P58              PAST END OF PAGE\n         BH    NEWPAGE                 YES\n         BR    R9                      EXIT\nNEWPAGE  MVI   PCC,C'1'                SET SKIP TO HOF\n         ZAP   LINECT,P0               RESET LINE COUNTER\n         BR    R9                      EXIT\n*\n*\n*\n*                 *** DATA AND WORK AREAS ***\n*\n*\n*\n*\nSVCTBLAD DC    A(SVCOP)                @ SVC TABLE\nDBLOPAD  DC    A(DBLOP)                @ TWO-BYTE OP-CODE TBL\nOPND9    DC    A(OPNDRTN)              RETURN ADDR FOR OPERAND ROUTINES\nDSCT9    DS    F                       RETURN FOR DSECTS\nSAVOP9   DS    F                       SAVE AREA FOR OPND9\nULSAV    DS    7F                      SAVE AREA FOR CKADCON\nNOINAD   DS    F                       DATA ONLY TABLE ADDRESS\nSGOPLEN DC AL2(L'SGLOP) SINGLE BYTE OP COD TBL LEN                   */\nDTBLEN DC AL2(L'DSECT) DSECT TABLE ENTRY LENGTH                      */\nNUMCK    DC    C'0000'                 NUMERIC CHECK AREA\nZEROS    DC    C'0000'                 CONSTANT ZEROS\nILENG    DC    H'0'                    INSTRUCTION LENGTH  FIX***\nCONPROG  DC    X'00'                   CONSTANT IN PROGRESS INDIC\nBASES    DC    XL256'0'                CURRENT BASE REGS\nHIVAL    DC    4X'FF'                  CONSTANT F'S\n         DS    0H\nUSGLEN DC AL2(L'USING) LENGTH OF USING TBL ENTRY                     */\nNEXCHG   DC    XL3'00'                 NEXT BASE REG CHG OFFSET\nMORUSG   DC    X'00'                   80=CURRENT BASE, 0=NO MORE BASES\nCONTYPE  DS    CL1                     TYPE\nCONLEN   DS    H                       CONSTANT LENGTH\nCONOFST  DS    F                       RELATIVE OFFSET TO CONSTANT\nCCTYPE   DC    X'00'                   CC SET TYPE OF INSTR SETTING\nTXTOFST  DS    0F\n         DS    X\nTXTOFSET DS    XL3                     OFFSET TO TEXT BYTE\nOFFSET   DS    XL3                     OFFSET FROM PGM START\nINSTYP   DS    CL1                     INSTRUCTION TYPE\nTYPE     DS    XL1                     TYPE CODE\n*                                       0=CSECT, 1=ADCON, 2=CONST\n*                                       E=USING, D=INSTRUCTION\n*                                       C=COMMENT, 9=ENTRY\n*                                       A=EQU\nLEN      DS    XL1                     TEXT LENGTH\n*EXT     DS    XL8                     TEXT\nTEXT     DS    XL50                    TEXT                         RH\nH1       DC    H'1'                    CONSTANT 1\nH2       DC    H'2'                    CONSTANT 2\nH4       DC    H'4'                    CONSTANT 4\nH7       DC    H'7'                    CONSTANT 7\nH8       DC    H'8'                    CONSTANT 8\nH10      DC    H'10'                   CONSTANT 10\nH11      DC    H'11'                   CONSTANT 11\nH13      DC    H'13'                   CONSTANT 13\nH14      DC    H'14'                   CONSTANT 14\nH100     DC    H'100'                  CONSTANT 100\nH1000    DC    H'1000'                 CONSTANT 1000\nP0       DC    P'0'                    CONSTANT 0\nP1       DC    P'1'                    CONSTANT 1\nP58      DC    P'58'                   CONSTANT 58\nP256     DC    P'256'                  CONSTANT 256\nH4095    DC    H'4095'            CONSTANT HEX 4095                 RH\nP4096    DC    P'4096'                 CONSTANT 4096\nBLANX    DC    CL133' '                CONSTANT BLANKS              RH\nUNAME    DC    CL8'A'                  USER NAME AREA\nXZROS    DC    8X'00'                  CONSTANT ZEROS\nTRTBL    DC    C'0123456789ABCDEF'     TRANSLATE TBL\nPRTABL   DS    CL9                     PRINTABLE HEX WORK\nCHARTRAN DC    256X'FF'                TRT TABLE FOR CHAR/HEX DETERMINA\n         ORG   CHARTRAN+C' '\n         DC    X'00'                   BLANK IS CHARACTER\n         ORG   CHARTRAN+C'A'\n         DC    9X'00'                  A-I ARE CHARACTERS\n         ORG   CHARTRAN+C'J'\n         DC    9X'00'                  J-R ARE CHARACTERS\n         ORG   CHARTRAN+C'S'\n         DC    8X'00'                  S-Z ARE CHARACTERS\n         ORG   CHARTRAN+C'0'\n         DC    10X'00'                 0-9 ARE CHARACTERS\n         ORG\nHEXTRAN  DC    256X'FF'                TRT TABLE FOR CHAR/HEX DETERMINA\n         ORG   HEXTRAN+C' '\n         DC    X'00'                   BLANK IS CHARACTER\n         ORG   HEXTRAN+74                                           RH\n         DC    7X'00'             \u00a2.<(+|&                           RH\n         ORG   HEXTRAN+90                                           RH\n         DC    8X'00'             !$*);\u00ac-/                          RH\n         ORG   HEXTRAN+106                                          RH\n         DC    6X'00'             |,%_>?                            RH\n         ORG   HEXTRAN+121                                          RH\n         DC    7X'00'             ':#@'=\"                           RH\n         ORG   HEXTRAN+C'A'\n         DC    9X'00'                  A-I ARE CHARACTERS\n         ORG   HEXTRAN+C'J'\n         DC    9X'00'                  J-R ARE CHARACTERS\n         ORG   HEXTRAN+C'S'\n         DC    8X'00'                  S-Z ARE CHARACTERS\n         ORG   HEXTRAN+C'0'\n         DC    10X'00'                 0-9 ARE CHARACTERS\n         ORG\nTRHEX    DC    256X'FF'                HEX TRANSLATION TABLE\n         ORG   TRHEX+C'A'\n         DC    X'0A0B0C0D0E0F'\n         ORG   TRHEX+C'0'\n         DC    X'00010203040506070809'\n         ORG\nTRTHEX   DS    0X                      VERIFY HEX TABLE\n         DC    XL16'00'\n         DC    XL240'FF'\n         ORG\n         LTORG\n*\n         COPY  DISASM3A                COPY INSTRUCTION TABLES\n         COPY  DISASM3B                COPY SVC TABLE\n*\n         PRINT GEN                                                  RH\n         DISASPRM DSECT=YES                                         RH\n         END\n/*\n//\n//*            END IF JUST WANT OBJECT MODULE\n//*\n//LKED.SYSLMOD  DD DISP=SHR,DSN=HALL.LOAD\n//LKED.SYSIN DD *\n     SETCODE AC(0)\n     NAME DISASM1(R)\n//\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DISASM2": {"ttr": 9990, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x99\\x00\\x8f\\x00\\x99\\x01\\x1f\\x13D\\n\\xe1\\n\\xd6\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1999-01-08T00:00:00", "modifydate": "1999-01-11T13:44:00", "lines": 2785, "newlines": 2774, "modlines": 0, "user": "RH87944"}, "text": "//DISASM2 JOB (87944,348496),HALL.S1BL,MSGCLASS=A,\n//             USER=RH87944,PASSWORD=*\n/*ROUTE  PRINT R7\n//STEP1  EXEC HLASMC,CLASS='*',\n//            PARMC='SYSPARM(1,ESD)'\n//ASM.SYSLIB DD DSN=HALL.DISASM.SOURCE,DISP=SHR\n//   DD DSN=SYS1.MACLIB,DISP=SHR\n//   DD DSN=SYS1.AMODGEN,DISP=SHR\n//ASM.SYSLIN   DD DSN=HALL.OBJECT(DISASM2),DISP=SHR\n//ASM.SYSIN DD *\n*                                                                   RH\n*   MODIFIED JAN 1999 BY RANDY HALL                                 RH\n*      HOPEFULLY ALL MODS HAVE \"RH\" IN COL 69-70...                 RH\n*      1) REMOVED MACRO CALL TO \"SVLNK\" TO USE 3 BASE REGS          RH\n*      2) AT LABEL CKLOSEQ, TEST IF PAST END OF LABEL TABLE         RH\n*      3) AT LABEL INSTR, HOPEFULLY BEEFED UP INSTRUCTION TESTS     RH\n*      4) AT LABEL ICKTBL, TEST IF PAST END OF LABEL TABLE          RH\n*         ADD CODE TO CALCULATE OFFSET IN INST TO LABEL,            RH\n*         AND  PUT A COMMENT LINE BEFORE THE LABEL, AND             RH\n*              PUT THE INSTRUCTION LABEL ON A SEPARATE LINE         RH\n*              AS A \"DS 0H'                                         RH\n*      5) AT LABEL NOTINST, ADD CODE TO SHOW COMMENTS               RH\n*      6) AT LABEL CHEX, TEST DATA TYPE                             RH\n*      7) AT LABEL CCFWD, ADD CODE TO JOIN MULTIPLE DECLARES        RH\n*      8) AT LABEL CDATACON, ADD CODE TO PRINT V TYPE AD CON        RH\n*      9) AT LABEL FORCONST, CHECK FOR PSEUDO LABEL                 RH\n*     10) AT LABEL FCHAR, ADD CODE TO JOIN MULTIPLE DECLARES        RH\n*     11) AT LABEL MVHX, SET UP MULT DC'S EG..DC 4C'AA'             RH\n*     12) AT LABEL SSTRT ETC, SET UP ASSEMBLER TYPE ADDR1           RH\n*     13) AT LABEL RSBBD ETC, SET UP ASSEMBLER TYPE ADDR2           RH\n*     14) AT LABEL EQUSTMT, CHANGE \"EQU\" STATEMENT OUTPUT           RH\n*     15) AT LABEL SCHLBL, ADDED CODE TO BETTER TEST FOR A BASE REG RH\n*         ADDED CODE (G10ADDR) TO SHOW DISPLACEMENT AS DECIMAL      RH\n*     16) AT LABEL SETSGL, ADDED CODE TO PRINT ASSEMBLER OUTPUT     RH\n*         TYPE HEADING ON EACH PAGE                                 RH\n*     17) AT LABEL TXTFMT, ADDED CODE (H10OBJEC) TO SET UP          RH\n*         ASSEMBLER TYPE OBJECT CODE IN LISTING                     RH\n*     18) ADDED MORE CHARACTERS TO \"CHARTRAN\" TABLE                 RH\n*     19) INCLUDE DSECTS FROM SYSLIB WITH \"DISASPRM\" COPY AT END    RH\n*                                                                   RH\n*                                                                   RH\nDIS2     TITLE '*** DISASSEMBLY PHASE 2 ***'\n         MACRO\n&NAME    SVLNK &REG1,&REG2,&REG3,&IND,&LV=\n         GBLC  &EQU\n         GBLC  &GM\n         GBLC  &CSECT\n         LCLC  &REGA\n         AIF   (T'&NAME EQ 'O').NOCSECT\n         AIF   ('&NAME' EQ '*').NOCSECT\n&CSECT   SETC  '&NAME'\n&CSECT   CSECT                         NAME OF PROGRAM\n         AGO   .RST\n.NOCSECT ANOP\n&CSECT   SETC  '*'\n         CSECT                         BEGINNING OF PROGRAM\n.RST     ANOP\n         AIF   ('&EQU' EQ 'ON').NRQ\n&EQU     SETC  'ON'\n*\n***REGISTER EQUATES***\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n.NRQ     ANOP\n*\n*******************  PROGRAM INITIALIZATION  *************************\n*\n         AIF   (T'&REG1 EQ 'O').NOREG\n&REGA    SETC  '&REG1'\n         AIF   (T'&REG2 EQ 'O').ONEREG\n         USING &CSECT,&REGA,&REG2          ESTABLISH ADDRESSABILITY\n         AGO   .BYUSE\n.NOREG   ANOP\n&REGA    SETC  'R3'\n.ONEREG  USING &CSECT,&REGA              ESTABLISH ADDRESSABILITY\n.BYUSE   ANOP\n         STM   R14,R12,12(R13) :       STORE REGS IN HIGH SAVE AREA\n         LR    &REGA,R15                  INITIALIZE BASE REG\n         AIF   (T'&REG2 EQ 'O').NOLA\n         LA    &REG2,4095(&REGA)       INITIALIZE THE SECOND\n         LA    &REG2,1(&REG2)                BASE REGISTER\n.NOLA    ANOP\n         AIF   (T'&REG3 EQ 'O').NOLNK\n         L     &REG3,0(R1)                GET PARAMETER LIST ADDR\n.NOLNK   ANOP\n         AIF (T'&IND EQ 'O').GETIT\n         CNOP  0,4\n         BAL   R15,SAVEAREA+72         BRANCH AROUND SAVE AREA\nSAVEAREA DS    18F                     REGISTER SAVE AREA\n         ST    R15,8(R13)\n         ST    R13,SAVEAREA+4\n         LR    R13,R15\n         AGO   .NOSAVE\n.GETIT   ANOP\n         AIF   (T'&LV EQ 'O').GMD\n&GM      SETC  '&LV'\n         AGO   .DGM\n.GMD     ANOP\n&GM      SETC  '72'\n.DGM     ANOP\n*\n***GET MAIN STORAGE FOR SAVE AREA***\n*\n         AIF   ('&GM' LT '4096').LA\n         GETMAIN R,LV=&GM              GET CORE FOR SAVE AREA\n         AGO   .EGM\n.LA      ANOP\n         LA    R0,&GM                  GET &GM BYTES\n         GETMAIN R,LV=(0)\n.EGM     ANOP\n*\n***SET UP SAVE AREA POINTERS***\n*\n         ST    R1,8(R13)               STORE LOW SAVE POINTER\n         ST    R13,4(R1)               STORE HIGH SAVE POINTER\n         LR    R13,R1                  INITIALIZE SAVE POINTER\n         AIF   (T'&REG3  NE 'O').NOSAVE\n         L     R1,4(R13)               GET POINTER TO RESTORE PARA REG\n         L     R1,24(R1)               RESTORE PARAMETER REGISTER\n.NOSAVE  ANOP\n         AIF   ('&CSECT' EQ '*').EXIT\n         B     *+12\n         DC    CL8'&CSECT'             END INITIAL., BEGIN THIS PROG.\n.EXIT    ANOP\n*\n*********************  END INITIALIZATION  ***************************\n*\n         MEND\n         EJECT\n*ISASM2  SVLNK R3,R4\nDISASM2  CSECT                         NAME OF PROGRAM\n*\n***REGISTER EQUATES***\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\n*******************  PROGRAM INITIALIZATION  ************************\n*\n         USING DISASM2,R15                 ESTABLISH ADDRESSABILITY\n         STM   R14,R12,12(R13) :       STORE REGS IN HIGH SAVE AREA\n*\n***SET UP SAVE AREA POINTERS***\n*\n         LA    R1,SAVEAREA        R1 -> TO MY SAVEAREA              RH\n         ST    R1,8(R13)               STORE LOW SAVE POINTER       RH\n         ST    R13,4(R1)               STORE HIGH SAVE POINTER      RH\n         LR    R13,R1                  INITIALIZE SAVE POINTER      RH\n         L     R1,4(R13)               GET POINTER TO RESTORE PARM  RH\n         L     R1,24(R1)               RESTORE PARAMETER REGISTER   RH\n         B     CONTINUE                                             RH\n         DC    CL8'DISASM2'            END INITIAL., BEGIN THIS PROG.H\nSAVEAREA DC    18F'-1'            MY SAVE AREA                      RH\nCONTINUE DS    0H                                                   RH\n         DROP  R15                DROP TEMP BASE                    RH\n         USING SAVEAREA,R13,R3,R4 SET NEW BASES                     RH\n         LA    R3,4095(0,R13)     SET BASE REG 2                    RH\n         LA    R3,1(0,R3)         ''                                RH\n         LA    R4,4095(R3)             INITIALIZE THE THIRD         RH\n         LA    R4,1(R4)                      BASE REGISTER          RH\n*\n*********************  END INITIALIZATION  **************************\n*\n         PRINT NOGEN\n* THIS SUB-PROGRAM IS CALLED BY DISASM AFTER THE DIRECTORY\n* ENTRY AND LOAD MODULE ARE PROCESSED. THE ESD AND RLD\n* ENTRIES HAVE BEEN USED TO CREATE A PROGRAM LABEL TABLE,\n* AND MODULE TEXT IS IN AN AREA OF STORAGE. A COMMON PARAMETER\n* AREA IS DEFINED IN DISASM, AND PASSED TO THIS PROGRAM.\n*\n* TEXT BYTES ARE USED TO CREATE ASSEMBLY LANGUAGE STATEMENTS,\n* AND MACHINE INSTRUCTION STATEMENTS. OUTPUT IS WRITTEN\n* TO THE WORK1 DATASET FOR FURTHER PROCESSING BY OTHER\n* MODULES.\n*   A TEXT BYTE IS CONSIDERED TO BE AN INSTRUCTION IF\n* IT OCCURS ON A HALFWORD BOUNDARY, IS A VALID OP-CODE,\n* AND IS FOLLOWED BY A VALID OP-CODE. UNCONDITIONAL BRANCHES\n* NEED NOT BE FOLLOWED BY A VALID OP-CODE, HOWEVER. THE\n* PRIVILEGED AND FLOATING POINT INSTRUCTIONS ARE NOT\n* TREATED AS INSTRUCTIONS UNLESS THE USER SPECIFIED\n* THEIR INCLUSION AT EXEC TIME.\n*\n*\n*\n*\n* AUTHOR R THORNTON - NOV 1977\n* UPDATED ROBERT STYMA - JAN 1989 AND MARCH 1991\n* UPDATED ALAN C FIELD - APR 1990\n*\n*\n******************************************************************\n*                                                                *\n* CHECK IF USER WISHES FLOATING POINT AND PRIVILEGED INSTRUCTIONS*\n* IF NOT, CLEAR THE APPROPRIATE ENTRIES IN THE INSTRUCTION OP    *\n* CODE TABLES.                                                   *\n*                                                                *\n******************************************************************\n*\n         L     R5,0(R1)                GET PARM FIELD ADDRESS\n         USING COMMPARM,R5\n         CLI   FLPTASM,1               FLOATING POINT INSTR O.K.\n         BE    TSTPRIV                 YES\n         LA    R12,SGLOP               POINT TO OP-CODE TBL\nTSTOPND  CLI   0(R12),X'FF'            END OF TBL\n         BE    TSTPRIV                 YES\n         TM    ICLASS-INSTENT(R12),FLTPT IS IT FLOATING POINT\n         BZ    FLPSTP                  NO\n         XC    0(L'SGLOP,R12),0(R12)   CLEAR ENTRY\nFLPSTP   LA    R12,L'SGLOP(R12)        TO NEXT ENTRY\n         B     TSTOPND                 LOOP THRU TABLE\nTSTPRIV  CLI   PRIVASM,1               PRIVILEGED INSTR O.K.\n         BE    MAINLINE                YES\n         LA    R12,SGLOP               POINT TO OP-CODE TBL\nTTOPND   CLI   0(R12),X'FF'            END OF TABLE\n         BE    CKDBLS                  YES\n         TM    ICLASS-INSTENT(R12),PRIV PRIVILEGED INSTR\n         BZ    PRIVSTP                 NO\n         XC    0(L'SGLOP,R12),0(R12)   YES, CLEAR ENTRY\nPRIVSTP  LA    R12,L'SGLOP(R12)        TO NEXT ENTRY\n         B     TTOPND                  LOOP THRU TABLE\nCKDBLS   L     R12,DBLOPAD             @ 2-BYTE OP-CODE TBL\nCKDBND   CLI   0(R12),X'FF'            END OF TBL\n         BE    MAINLINE                YES\n         TM    ICLASS-INSTENT+2(R12),PRIV PRIVILEGED OP-CODE\n         BZ    DBSTP                   NO\n         XC    0(L'DBLOP,R12),0(R12)   YES, CLEAR ENTRY\nDBSTP    LA    R12,L'DBLOP(R12)        TO NEXT ENTRY\n         B     CKDBND                  LOOP THRU TABLE\n*\n*\n*\n******************************************************************\n*                                                                *\n* MAINLINE ROUTINE FOR DISASSEMBLY. EACH BYTE OF TEXT IS CHECKED *\n* TO DETERMINE WHETHER IT MAY BE AN INSTRUCTION OP-CODE. IF NOT, *\n* THE CONST ROUTINE IS PERFORMED TO HANDLE CONSTANT DATA. IF IT  *\n* APPEARS TO BE AN OP-CODE, THE INSTR ROUTINE IS PERFORMED.      *\n* WHEN TEXT IS EXHAUSTED, THIS PHASE TERMINATES.                 *\n*                                                                *\n******************************************************************\n*\nMAINLINE EQU   *                       MAINLINE ROUTINE\n         L     R6,LBLTBL               @ LABEL TABLE\n         USING LABELD,R6\n         MVC   TXTCURR,TXTSTRT         COPY TEXT START ADDR\nGETCURR  L     R7,TXTCURR              @ CURRENT TXT BYTE\n         C     R7,TXTEND               END OF TEXT\n         BNL   EOJ                     YES          FIX******\n         LR    R12,R7                  COPY TEXT ADDR\n         S     R12,TXTSTRT             COMPUTE OFFSET\n         ST    R12,TXTOFST             SAVE OFFSET TO THIS BYTE\n         CLC   NEXCHG,TXTOFSET         TIME TO CHANGE BASES\n         BH    CKDARNG                 NO\n         BAL   R9,NEXUSG               YES, GO DO IT\nCKDARNG  L     R12,DATONLY             GET DATA ONLY TBL ADDR\n         CLC   TXTOFSET,0(R12)         RANGE BEGINS LATER\n         BL    CKLOSEQ                 YES\n         CLC   TXTOFSET,3(R12)         THIS BYTE IN THE RANGE\n         BNH   CONST                   YES\n         LA    R12,6(R12)              PAST THIS ENTRY, STEP OVER 1\n         ST    R12,DATONLY             SAVE UPDATED ADDR\n         B     CKDARNG                 GO CHECK AGAIN\nCKLOSEQ  CLC   TXTOFSET,LBLADR         LABEL ENTRY OUT OF SEQ\n         BNH   GCKODD                  NO, CONTINUE\n         C     R6,CURRLBL         ARE WE PAST LAST LABEL IN TABLE?  RH\n         BNL   GCKODD             YES                               RH\n         BAL   R9,FORCONST             YES, FORCE ANY CONSTANT OUT\n         MVC   NAME,LBLNAME            NAME TO OUTPUT\n         MVC   MNEMONIC,=CL5'EQU'      MNEMONIC\n         MVI   OPNDS,C'*'              OPERAND\n         MVC   COMMENT(14),=14C'?'     SHOW ERROR\n         BAL   R9,WRTOUT               WRITE ERROR RECORD\n         BAL   R9,PRINT                GO PRINT IT\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL\n         B     CKLOSEQ                 CONTINUE SEQ CHK\nGCKODD   TM    TXTCURR+3,1             ODD ADDRESS\n         BO    CONST                   YES, NOT INSTR\n         CLC   1(3,R7),0(R7)           4 CONSEC IDENTICAL BYTES\n         BE    CONST                   YES, NOT INSTR\n         TRT   0(1,R7),CHARTRAN        TEST TEXT BYTE\n         BNZ   CKINSTR                 NOT CHARACTER\n         CLI   CONPROG,1               IS CONSTANT IN PROGRESS\n         BNE   CK6                     NO\n         CLI   CONTYPE,C'C'            IS IT CHARACTER TYPE\n         BE    CONST                   YES, ADD THIS TO CONSTANT\nCK6      TRT   0(6,R7),CHARTRAN        6 CONSECUTIVE CHARACTERS\n         BZ    CONST                   YES, NOT INSTRUCTION\nCKINSTR  SR    R8,R8                   CLEAR WORK\n         IC    R8,0(R7)                PICK UP TXT BYTE\n         MH    R8,SGOPLEN              TIMES TABLE LENGTH\n         LA    R8,SGLOP(R8)            @ INSTR TBL ENTRY\n         MVC   INSTENT,0(R8)           SAVE INSTRUCTION TBL ENTRY\n         CLI   INAME,0                 IS IT AN INSTR OP-CODE\n         BE    CONST                   NO\n         CLI   ITYPE,TWO               TWO-BYTE OP-CODE\n         BNE   INSTR                   NO\n         L     R8,DBLOPAD              YES, GET 2-BYTE TBL ADDR\nDBLND    CLI   0(R8),X'FF'             END OF TABLE\n         BE    CONST                   YES, NOT INSTR\n         CLC   0(2,R8),0(R7)           THIS ENTRY MATCHES TXT\n         BE    GOTDBLI                 YES\n         LA    R8,L'DBLOP(R8)          TO NEXT ENTRY\n         B     DBLND                   LOOP THRU TBL\nGOTDBLI  LA    R8,2(R8)                PASS OP-CODE BYTES\n         MVC   INSTENT,0(R8)           SAVE INSTR TBL ENTRY\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS ENTERED WHEN CURSORY CHECKS IN THE MAINLINE    *\n* INDICATE THIS TEXT BYTE IS AN INSTRUCTION OP-CODE. FURTHER     *\n* TESTING IS DONE BY THE IVERFY (NON-FLOATING POINT), OR FPVERFY *\n* (FLOATING POINT) ROUTINES. BYTES PASSING THESE TESTS ARE       *\n* ACCEPTED AS OP-CODES, AND ARE PASSED TO THE APPROPRIATE FORMAT *\n* ROUTINES. FORMAT ROUTINES ARE ENTERED VIA A BRANCH TABLE USING *\n* A BYTE IN THE INSTRUCTION OP-CODE TABLE ENTRY.                 *\n*                                                                *\n******************************************************************\n*\nINSTR    EQU   *                       *** INSTRUCTIONS (POSSIBLY) ***\n*                                                                   RH\n*                                 CHECK THIS INSTRUCTION            RH\n*                                                                   RH\n         AGO   .B2\n         CLI   0(R7),X'B2'        IS IT A X'B2' INSTR?              RH\n         BNE   INSTR1             NO, ON WE GO                      RH\n         CLI   1(R7),X'13'        YES, OVER VALID TYPE CODE?        RH\n         BH    CONST              YES, IT'S NOT A B2 INSTR THEN     RH\n*                                                                   RH\n*              SET UP B2 OP CODE                                    RH\n*                                                                   RH\n         SR    R12,R12            CLEAR R12                         RH\n         IC    R12,1(R7)          R12 = TYPE CODE                   RH\n         MH    R12,=H'5'          MULT BY TABLE ENTRY LTH           RH\n         LA    R12,B2TABLE(R12)   R12 -> TO B2 OP CODE              RH\n         MVC   INAME,0(R12)       SET UP REAL BE MNEMONIC           RH\n         B     INSTR2             ON WE GO                          RH\n         SPACE 1                                                    RH\nINSTR1   DS    0H                      *** INSTRUCTIONS (POSSIBLY)  RH\n.B2      ANOP\n         CLI   0(R7),X'80'        IS IT AN SSM INSTR?               RH\n         BNE   INSTR2             NO, ON WE GO                      RH\n         CLI   1(R7),X'00'        YES, IS THERE A BASE REG?         RH\n         BE    CONST              NO, IT'S NOT AN SSM INSTR THEN    RH\n         SPACE 1                                                    RH\nINSTR2   DS    0H                      *** INSTRUCTIONS (POSSIBLY)  RH\n*                                                                   RH\n*                                 CHECK NEXT INSTRUCTION            RH\n*                                                                   RH\n         MVC   ILENG+1(1),INLNG        SET INSTR LENGTH\n         LH    R12,ILENG               PICK UP LENGTH\n         AR    R12,R7                  ADDR OF NEXT OP CODE\n         SR    R15,R15                 CLEAR WORK\n         IC    R15,0(R12)              PICK UP NEXT OP-CODE\n         MH    R15,SGOPLEN             TIMES TBL ENTRY LENG\n         LA    R15,SGLOP(R15)          INSTR TBL ENTRY ADDR\n         CLI   INAME-INSTENT(R15),0    IS IT AN OP-CODE\n         BNE   ICKSEC                  YES\n*                                                                   RH\n*              CHECK 2ND BYTE ALONG FOR INSTRUCTION                 RH\n*                                                                   RH\n         AH    R15,SGOPLEN        R15 -> TO NEXT BYTE               RH\n         AH    R15,SGOPLEN        R15 MAY -> TO NEXT INST           RH\n         CLI   INAME-INSTENT(R15),0    IS IT AN OP-CODE             RH\n         BNE   ICKSEC                  YES                          RH\n*                                                                   RH\n*                                 CHECK FIRST INSTRUCTION           RH\n*                                                                   RH\n*        CLI   0(R7),X'45'             IS IT BAL\n*        BE    ICKTBL                  YES, CONTINUE\n*        CLI   0(R7),X'0B'             IS IT BSM\n*        BE    ICKTBL                  YES, CONTINUE\n*        CLI   0(R7),X'4D'             IS IT BAS\n*        BE    ICKTBL                  YES, CONTINUE\n         SPACE 1                                                    RH\n         LR    R12,R7             R12 -> TO FIRST INSTRUCTION       RH\n         B     ICKSEC2            GO CHECK THIS INST                RH\n         SPACE 1                                                    RH\n*        CLI   0(R7),7                 NO, IS IT BCR\n*        BE    POSSB                   YES\n*        CLI   0(R7),X'47'             IS IT BC\n*        BNE   CONST                   NO, THEN THIS NOT INSTR\n*OSSB    TM    1(R7),X'F0'             IS IT UNCONDL BRCH\n*        BNO   CONST                   NO, THEN THIS NOT INSTR\n*        B     ICKTBL                  ACCEPT UNCOND BRCHS\n*                                                                   RH\n*                                 CHECK THIRD INSTRUCTION           RH\n*                                                                   RH\nICKSEC   SR    R1,R1                   CLEAR WORK\n         IC    R1,INLNG-INSTENT(R15)   GET INSTR LENGTH\n         AR    R1,R12                  ADDR OF NEXT OP CODE\n         SR    R14,R14                 CLEAR WORK\n         IC    R14,0(R1)               PICK UP NEXT OP-CODE\n         MH    R14,SGOPLEN             TIMES TBL ENTRY LENG\n         LA    R14,SGLOP(R14)          INSTR TBL ENTRY ADDR\n         CLI   INAME-INSTENT(R14),0    IS IT AN OP-CODE\n         BNE   ICKTBL                  YES\n*                                                                   RH\n*                                 CHECK 1ST INSTRUCTION             RH\n*                                                                   RH\n*        CLI   0(R7),X'45'        IS FIRST INST A BAL?              RH\n*        BE    ICKTBL             YES, CONTINUE                     RH\n         CLI   0(R7),X'05'             NO, IS IT BALR?              RH\n         BE    ICKTBL                  YES                          RH\n         CLI   0(R7),X'06'             NO, IS IT BCTR?              RH\n         BE    ICKTBL                  YES                          RH\n         CLI   0(R7),X'07'             NO, IS IT BCR?               RH\n         BE    ICKTBL                  YES                          RH\n         CLI   0(R7),X'45'             IS IT BAL                    RH\n         BE    ICKTBL                  YES, CONTINUE                RH\n         CLI   0(R7),X'46'             IS IT BCT?                   RH\n         BE    ICKTBL                  YES, CONTINUE                RH\n         CLI   0(R7),X'47'             IS IT BC?                    RH\n         BE    ICKTBL                  YES                          RH\n         CLI   0(R7),X'86'             IS IT BXH?                   RH\n         BE    ICKTBL                  YES, CONTINUE                RH\n         CLI   0(R7),X'87'             IS IT BXLE?                  RH\n         BE    ICKTBL                  YES                          RH\n*                                                                   RH\n*                                 CHECK 1ST OR 2ND INSTRUCTION      RH\n*                                                                   RH\nICKSEC2  DS    0H                                                   RH\n         CLI   0(R12),X'05'            NO, IS IT BALR?              RH\n         BE    ICKTBL                  YES                          RH\n         CLI   0(R12),X'06'            NO, IS IT BCTR?              RH\n         BE    ICKTBL                  YES                          RH\n         CLI   0(R12),X'07'            NO, IS IT BCR?               RH\n         BE    POSSB2                  YES                          RH\n         CLI   0(R12),X'45'            IS IT BAL                    RH\n         BE    ICKTBL                  YES, CONTINUE                RH\n         CLI   0(R12),X'46'            IS IT BCT?                   RH\n         BE    ICKTBL                  YES, CONTINUE                RH\n         CLI   0(R12),X'47'            IS IT BC?                    RH\n         BE    POSSB3                  YES                          RH\n         CLI   0(R12),X'86'            IS IT BXH?                   RH\n         BE    ICKTBL                  YES, CONTINUE                RH\n         CLI   0(R12),X'87'            IS IT BXLE?                  RH\n         BNE   CONST                   NO, THEN THIS NOT INSTR\n         SPACE 1                                                    RH\nPOSSB2   DS    0H                 CHECK MASK FOR BCR INST           RH\n         TM    1(R12),X'F0'       IS IT UNCONDL BRCH                RH\n         BO    ICKTBL             YES                               RH\n         TM    1(R12),X'E0'       IS IT A BNO ?                     RH\n         BO    ICKTBL             YES                               RH\n         TM    1(R12),X'D0'       IS IT A BNH/BNP ?                 RH\n         BO    ICKTBL             YES                               RH\n         TM    1(R12),X'B0'       IS IT A BNL/BNM ?                 RH\n         BO    ICKTBL             YES                               RH\n         TM    1(R12),X'80'       IS IT A BE/BZ ?                   RH\n         BO    ICKTBL             YES                               RH\n         TM    1(R12),X'70'       IS IT A BNE/BNZ ?                 RH\n         BM    ICKTBL             YES                               RH\n         TM    1(R12),X'40'       IS IT A BL/BM ?                   RH\n         BO    ICKTBL             YES                               RH\n         TM    1(R12),X'20'       IS IT A BH/BP ?                   RH\n         BO    ICKTBL             YES                               RH\n         SPACE 1                                                    RH\n         TM    1(R12),X'10'       IS IT A NOP?                      RH\n         BZ    ICKTBL             YES                               RH\n         BO    ICKTBL             NO, BUT ITS A BO                  RH\n         SPACE 1                                                    RH\n         B     CONST              NOT AN INST                       RH\n         SPACE 1                                                    RH\nPOSSB3   DS    0H                 CHECK MASK FOR BC INST            RH\n         TM    1(R12),X'0F'       OVER X...0?                       RH\n         BM    CONST              YES, NOT AN INST                  RH\n         SPACE 1                                                    RH\n         CLI   1(R12),X'10'            IS IT A NOP?                 RH\n         BL    ICKTBL             YES                               RH\n         BE    ICKTBL             NO, BUT ITS A BO                  RH\n         SPACE 1                                                    RH\n         CLI   1(R12),X'20'       IS IT A BH/BP ?                   RH\n         BE    ICKTBL             YES                               RH\n         CLI   1(R12),X'40'       IS IT A BL/BM ?                   RH\n         BE    ICKTBL             YES                               RH\n         CLI   1(R12),X'70'       IS IT A BNE/BNZ ?                 RH\n         BE    ICKTBL             YES                               RH\n         SPACE 1                                                    RH\n         CLI   1(R12),X'80'       IS IT A BE/BZ ?                   RH\n         BE    ICKTBL             YES                               RH\n         CLI   1(R12),X'B0'       IS IT A BNL/BNM ?                 RH\n         BE    ICKTBL             YES                               RH\n         CLI   1(R12),X'D0'       IS IT A BNH/BNP ?                 RH\n         BE    ICKTBL             YES                               RH\n         CLI   1(R12),X'E0'       IS IT A BNO ?                     RH\n         BE    ICKTBL             YES                               RH\n         CLI   1(R12),X'F0'       IS IT UNCONDL BRCH\n         BNE   CONST              NO, THEN THIS NOT INSTR\nICKTBL   LH    R12,ILENG               GET INSTR LENGTH\n         AR    R12,R7                  @ NEXT TEXT LOC\n         BCTR  R12,R0                  BACK UP 1\n         S     R12,TXTSTRT             RELATIVIZE IN CSECT\n         CLM   R12,7,LBLADR            LBL TBL ADDR HERE\n         BL    NOILBL                  NO\n         C     R6,CURRLBL         ARE WE PAST LAST LABEL IN TABLE?  RH\n         BNL   NOILBL             YES                               RH\n*        CLC   TXTOFSET,LBLADR         LABEL AT INSTR START         RH\n*        BNE   NOTINST                 NO, MUST BE CONSTANT   FIX** RH\n         CLI   LBLTYP,C'L'             IS IT A LABEL ONLY\n         BNE   NOTINST                 NO                        FIX***\n         CLI   CONPROG,1               CONSTANT IN PROGRESS\n         BNE   CKLBLNG                 NO\n         BAL   R9,FORCONST             YES, FORCE IT OUT\n         SPACE 1                                                    RH\nCKLBLNG  DS    0H                                                   RH\n         SPACE 1                                                    RH\n         CLC   TXTOFSET,LBLADR    LABEL AT INSTR START              RH\n         BE    SETLBL             YES                               RH\n*        BE    SAMELTH            YES                               RH\n*                                                                   RH\n*              CALCULATE OFFSET IN INST TO LABEL                    RH\n*                                                                   RH\n         SR    R9,R9              CLEAR R9                          RH\n         SR    R15,R15            CLEAR R15                         RH\n         ICM   R15,7,LBLADR       R15 = LABEL ADDRESS               RH\n         ICM   R9,7,TXTOFSET      R9 = LABEL OFFSET                 RH\n         SR    R15,R9             R15 = OFFSET TO LABEL             RH\n         STC   R15,LBLLEN         SAVE LABEL OFFSET                 RH\n         MVI   LBLOFSET,X'FF'     SAY WE NEED AN EQU+1              RH\n         SPACE 1                                                    RH\nSAMELTH  DS    0H                                                   RH\n*                                                                   RH\n         CLC   LBLLEN,INLNG            LENGTHS SAME\n         BE    SETLBL                  YES\n         CLI   LBLLEN,0                DON'T CARE LENGTH\n         BE    SETLBL                  YES\n         BAL   R9,EQUSTMT              NO, BUILD EQU STATEMENT\n         B     ISTPLBL                 CONTINUE\n*                                                                   RH\n*              PUT A COMMENT LINE BEFORE THE LABEL, AND             RH\n*              PUT THE INSTRUCTION LABEL ON A SEPARATE LINE         RH\n*              AS A \"DS 0H'                                         RH\n*                                                                   RH\nSETLBL   DS    0H                                                   RH\n         MVI   NAME,C'*'               SET UP A \"BLANK\" LINE        RH\n         BAL   R9,WRTOUT               WRITE PUNCH RECORD           RH\n         BAL   R9,PRINT                GO PRINT IT                  RH\n         MVC   NAME,LBLNAME            LABEL ENTRY NAME TO INSTR\n         MVC   CONLEN,LBLLEN           SET CONSTANT LENGTH IN CASE\n         MVC   MNEMONIC,=CL5'DS '      MNEMONIC                     RH\n         MVC   OPNDS(2),=C'0H'         OPERAND                      RH\n         BAL   R9,WRTOUT               WRITE PUNCH RECORD           RH\n         BAL   R9,PRINT                GO PRINT IT                  RH\n         SPACE 1                                                    RH\nISTPLBL  DS    0H                                                   RH\n         LR    R9,R6                   GET TEMP COPY OF LABEL TAB ENT\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL TBL ENTRY\n         CLC   LBLADR(3),LBLADR-LABEL(R9)  THIS ENTRY SAME ADDR?\n         BNE   ICKTBL                  NO\n         LR    R6,R9                   BACK UP TO PREV ENTRY\n         C     R6,CURRLBL         ARE WE PAST LAST LABEL IN TABLE?  RH\n         BNL   NOILBL             YES                               RH\n         CLC   TXTOFSET,LBLADR    THIS ENTRY SAME ADDR?             RH\n*        CLM   R6,7,LBLADR             THIS ENTRY SAME ADDR\n         BNE   ICKTBL                  NO\n         SH    R6,LBLLGTH              BACK UP TO 1ST ENTRY\n         BAL   R9,EQUSTMT              GO BUILD EQU STATEMENT\n         LA    R6,L'LABEL(R6)          TO NEXT ENTRY\n         B     ICKTBL                  GO CHECK NEXT LABEL\nNOILBL   CLI   CONPROG,1               CONSTANT IN PROGRESS\n         BNE   MVMNE                   NO\n         BAL   R9,FORCONST             YES, FORCE IT OUT\nMVMNE    MVC   MNEMONIC,0(R8)          SET INSTR MNEMONIC\n         MVC   OFFSET,TXTOFSET         SET OFFSET\n         MVC   INSTYP,5(R8)            SET INSTR TYPE\n         MVI   TYPE,X'0D'              SHOW IT IS AN INSTRUCTION\n         MVC   LEN,ILENG+1             SHOW LENGTH\n         MVC   TEXT(6),0(R7)           MOVE ACTUAL TEXT\nOPNDFMT  TM    ICLASS,FLTPT            FLOATING POINT OP-CODE\n         BO    FPVERFY                 YES, GO VERIFY\n         CLI   IEDT,0                  ANY EDIT REQUIRED\n         BE    PFMFMT                  NO\n         B     IVERFY                  YES, GO EDIT\nPFMFMT   SR    R1,R1                   CLEAR WORK\n         IC    R1,INSTYP               GET INSTRUCTION TYPE\n         L     R9,OPND9                GET FORMAT ROUTINE RETURN ADDR\n         B     *+4(R1)                 TO APPROPRIATE FORMATTING ROUTIN\n         B     RROPND                  TYPE=0, RR\n         B     RXOPND                  TYPE=4, RX\n         B     SOPND                   TYPE=8, S\n         B     SIOPND                  TYPE=C, SI\n         B     RSOPND                  TYPE=10, RS\n         B     SS1OPND                 TYPE=14, 1-LENGTH SS\n         B     SS2OPND                 TYPE=18, 2-LENGTH SS\n         B     SOPND                   TYPE=1C, 2-BYTE OP-CODES\n         B     BCOPND                  TYPE=20, CONDITIONAL BRANCH\n         B     SVCOPND                 TYPE=24, SVC\n         B     SSEOPND                 TYPE=28, SSE\n         B     EOPND                   TYPE=2C, E\n         B     RROPND                  TYPE=30, RRE 1 OPERAND\n         B     RROPND                  TYPE=34, RRE 2 OPERANDS\nOPNDRTN  B     INSTOUT                 NORMAL OPERAND FORMAT RETURN\n         MVC   CONNAME,NAME            ANY NAME TO CONSTANT AREA\n         B     CONST                   ERROR INSTRUCTION, TREAT AS CONS\nNOTINST  CLC   NAME,BLANX              IS NAME FILLED IN?        FIX***\n         BE    CONST                                             FIX***\n         SH    R6,LBLLGTH              BACK UP                   FIX***\n         B     CONST                                             FIX***\n         SPACE 1                                                    RH\nINSTOUT  DS 0H                                                      RH\n         CLI   DCINST,C'D'        WAS PREV INST A DC ?              RH\n         BNE   INSTOUT2           NO                                RH\n         LH    R9,ILENG           R9 = LTH OF THIS INST             RH\n         BCTR  R9,0               R9 = HEX LTH                      RH\n         EX    R9,TRTTEXT         TEST TEXT                         RH\n*RTTEXT  TRT   TEXT(0),HEXTRAN    TEST TEXT BYTE                    RH\n         BNZ   INSTOUT2           NOT CHARACTER                     RH\n         EX    R9,MVCTEXT         SET UP TEXT AS COMMENT            RH\n         SPACE 1                                                    RH\nINSTOUT2 DS 0H                                                      RH\n         BAL   R9,WRTOUT               WRITE INSTRUCTION RECORD\n         BAL   R9,TXTFMT               FORMAT HEX DATA\n         BAL   R9,PRINT                GO PRINT IT\n         MVI   DCINST,C' '        SAY WE DID A REAL INST            RH\n         AH    R7,ILENG                STEP TO NEXT TEXT BYTE\n         ST    R7,TXTCURR              SAVE NEXT ADDR\n         MVC   CCTYPE,ICCSET           SHOW COND CODE SET TYPE\n         B     GETCURR                 CONTINUE TXT PROCESSING\n*\nTRTTEXT  TRT   TEXT(0),HEXTRAN    TEST TEXT BYTE                    RH\nMVCTEXT  MVC   COMMENT(0),TEXT    SET UP COMMENT                    RH\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS ENTERED FROM THE INSTR ROUTINE FOR NON FLOATING*\n* POINT INSTRUCTIONS. VARIOUS EDITS ARE PERFORMED TO INSURE THE  *\n* INPUT TEXT BYTE IS AN OP-CODE. IF IT IS, RETURN IS TO LABEL    *\n* PFMFMT, OTHERWISE THE CONST ROUTINE IS PERFORMED.              *\n*                                                                *\n******************************************************************\n*\nIVERFY   EQU   *                       *** VERIFY POSSIBLE INSTRUCTION\n         TM    IEDT,EPR                EVEN-ODD REG PAIR\n         BZ    IVE2                    NO\n         TM    1(R7),X'10'             R1 IS ODD\n         BO    CONST                   YES, NOT INSTR\n         CLI   0(R7),X'0E'             IS IT MVCL\n         BE    IVTRG2                  YES\n         CLI   0(R7),X'0F'             IS IT CLCL\n         BNE   IVE2                    NO\nIVTRG2   TM    1(R7),X'01'             R2 IS ODD\n         BO    CONST                   YES, NOT INSTR\n         SR    R1,R1                   CLEAR WORK\n         SR    R2,R2                   CLEAR WORK\n         IC    R1,1(R7)                GET R1R2\n         SRL   R1,4                    SHIFT OUT R2\n         PACK  DBLWD(1),1(1,R7)        FLIP R1R2 BYTE\n         IC    R2,DBLWD                PICK UP R2R1\n         SRL   R2,4                    SHIFT OUT R1\n         CR    R1,R2                   R1=R2\n         BE    CONST                   YES, NOT INSTR\n         B     PFMFMT                  NO, GOOD INSTR\nIVE2     TM    IEDT,E2                 HALFWORD STORAGE ALIGNMENT\n         BZ    IVE4                    NO\n         TM    3(R7),X'01'             DISPL IS ODD\n         BZ    IVES2                   NO, O.K.\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   IVES2                   NO, CONTINUE\n         CLI   0(R7),X'44'             EX OP CODE\n         BE    CONST                   YES, NOT INSTR\n         CLI   0(R7),X'47'             BC OP CODE\n         BE    CONST                   YES, NOT INSTR\n         CLI   ITYPE,RS                RS INSTRUCTION\n         BE    CONST                   YES, NOT INSTR\n         TM    1(R7),X'0F'             INDEX REG IS 0\n         BZ    CONST                   YES, NOT INSTR\n         B     IVES2                   CONTINUE\nIVE4     TM    IEDT,E4                 2ND OPND ON FULLWORD BOUND\n         BZ    IVE8                    NO\n         TM    3(R7),X'03'             DISPL DIV BY 4\n         BZ    IVES2                   YES, O.K.\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   IVES2                   NO, CONTINUE\n         CLI   ITYPE,RS                RS INSTRUCTION OP CODE\n         BE    CONST                   YES, NOT INSTR\n         TM    1(R7),X'0F'             INDEX REG = 0\n         BZ    CONST                   YES, NOT INSTR\n         B     IVES2                   NO, CONTINUE\nIVE8     TM    IEDT,E8                 2ND OPND ON DBLWD BOUND\n         BZ    IVES2                   NO\n         TM    3(R7),X'07'             DISPL DIV BY 8\n         BZ    IVES2                   YES, O.K.\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   IVES2                   NO\n         TM    1(R7),X'0F'             INDEX REG = 0\n         BZ    CONST                   YES, NOT INSTR\nIVES2    CLI   PRIVASM,1               PRIVILEGED INSTR O.K.\n         BE    PFMFMT                  YES\n         TM    IEDT,S2                 OPND2 MUST HAVE BASE\n         BZ    IVES1                   NO\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   PFMFMT                  NO, O.K.\n         CLI   ITYPE,RS                RS INSTRUCTION\n         BE    CONST                   YES, NOT INSTR\n         CLI   0(R7),X'92'             IS IT MVI OP CODE\n         BE    CONST                   YES, NOT INSTR\n         TM    1(R7),X'0F'             INDEX REG = 0\n         BZ    CONST                   YES, NOT INSTR\n         B     PFMFMT                  NO, GOOD INSTR\nIVES1    TM    IEDT,S1                 1ST OPND MUST HAVE BASE\n         BZ    PFMFMT                  NO, CONTINUE\n         TM    2(R7),X'F0'             1ST OPND HAS BASE\n         BZ    CONST                   NO, NOT INSTR\n         B     PFMFMT                  YES, INSTR O.K.\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS ENTERED FROM THE INSTR ROUTINE FOR FLOATING    *\n* POINT INSTRUCTIONS. VARIOUS EDITS ARE PERFORMED TO INSURE THE  *\n* INPUT TEXT BYTE IS AN OP-CODE. IF IT IS, RETURN IS TO LABEL    *\n* PFMFMT, OTHERWISE THE CONST ROUTINE IS PERFORMED.              *\n*                                                                *\n******************************************************************\n*\nFPVERFY  EQU   *                       *** VALIDATE FLOATING POINT OP-C\n         TM    1(R7),X'90'             R1 IS 0, 2, 4, OR 6\n         BNZ   CONST                   NO, NOT INSTR\n         CLI   0(R7),X'27'             MXDR OP-CODE\n         BE    FPR1EXT                 YES\n         CLI   0(R7),X'67'             MXD OP-CODE\n         BNE   FPCKTYP                 NO\nFPR1EXT  TM    1(R7),X'B0'             R1 IS 0 OR 4\n         BNZ   CONST                   NO, NOT INSTR\nFPCKTYP  CLI   ITYPE,RR                RR TYPE INSTRUCTION\n         BNE   FPRXVER                 NO\n         TM    1(R7),X'09'             R2 IS 0, 2, 4, 6\n         BNZ   CONST                   NO, NOT INSTR\n         CLI   0(R7),X'25'             LRDR OP CODE\n         BE    FPR2EXT                 YES\n         CLI   0(R7),X'37'             SXR OP-CODE\n         BE    FPR2EXT                 YES\n         CLI   0(R7),X'26'             MXR OP-CODE\n         BE    FPR2EXT                 YES\n         CLI   0(R7),X'36'             AXR OP-CODE\n         BNE   PFMFMT                  NO, GOOD INSTR\nFPR2EXT  TM    1(R7),X'0B'             R2 IS 0 OR 4\n         BZ    PFMFMT                  YES, GOOD INSTR\n         B     CONST                   NO, NOT INSTR\nFPRXVER  CLI   PRIVASM,1               PRIVILEGED INSTRUCTIONS O.K.\n         BE    FPALIGN                 YES\n         TM    2(R7),X'F0'             ANT BASE REG\n         BNZ   FPALIGN                 YES\n         TM    1(R7),X'0F'             ANY INDEX REG\n         BZ    CONST                   NO, NOT INSTR\nFPALIGN  TM    2(R7),X'F0'             ANY BASE REG\n         BNZ   PFMFMT                  YES, ACCEPT INSTR\n         TM    1(R7),X'0F'             ANY INDEX REG\n         BNZ   PFMFMT                  YES, ACCEPT INSTR\n         TM    3(R7),X'03'             DISPL DIV BY 4\n         BNZ   CONST                   NO, NOT INSTR\n         TM    ICLASS,FLSHT            SHORT PRECISION\n         BO    PFMFMT                  YES, ACCEPT INSTRUCTION\n         TM    3(R7),X'07'             DISPL DIV BY 8\n         BZ    PFMFMT                  YES, ACCEPT INSTR\n         B     CONST                   NO, NOT INSTR\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS ENTERED FROM VARIOUS OTHER ROUTINES WHEN THE   *\n* CURRENT TEXT BYTE IS DETERMINED NOT TO BE AN INSTRUCTION OP    *\n* CODE. A CONSTANT AREA IS BUILT TO CONTAIN THE CONSTANT, IT'S   *\n* DATA TYPE, SYMBOL TO BE USED FOR ADCONS, LABEL TO BE USED, IF  *\n* ANY, ETC. THE CONSTANT IS BUILT BYTE BY BYTE, AND IS TERMINATED*\n* FOR OUTPUT BY THE FORCONST ROUTINE. THIS ROUTINE DETECTS END OF*\n* CONSTANT WHEN THE CONSTANT IN PROGRESS EXCEEDS 2 BYTES FOR A   *\n* HALFWORD, 4 BYTES FOR A FULLWORD, OR 8 BYTES AS A MAXIMUM. IT  *\n* IS ALSO TERMINATED WHEN A CHANGE IN DATA TYPE OCCURS.          *\n*                                                                *\n******************************************************************\n*\nCONST    EQU   *                       *** PROCESS CONSTANTS ***\n         MVC   WORKREC,BLANX           CLEAR WORK RECORD AREA\n         CLI   CONPROG,1               CONSTANT IN PROGRESS\n         BNE   CCNEW                   NO\n         CLC   TXTOFSET,LBLADR         LABEL ENTRY HAS THIS OFFSET\n         BNE   CGETYP                  NO\nCSTNEW   BAL   R9,FORCONST             FORCE IT OUT\n         B     CCNEW                   GO START A NEW ONE\nCGETYP   TRT   0(1,R7),CHARTRAN        CHECK DATA TYPE OF BYTE\n         BNZ   CHEX                    IT'S HEX\nNOTHEX   MVI   CCKTYP+1,C'C'           SET TYPE IN COMPARE\n         B     CCKTYP                  GO COMPARE\nCHEX     DS    0H         SET TYPE IN COMPARE\n         TRT   0(1,R7),HEXTRAN         CHECK DATA TYPE OF BYTE      RH\n         BZ    NOTHEX                  IT'S CHARACTER               RH\n         MVI   CCKTYP+1,C'X'           SET TYPE IN COMPARE\nCCKTYP   CLI   CONTYPE,C' '            TYPE IN PROG SAME AS THIS BYTE\n         BNE   CSTNEW                  NO\nCUPDCON  LH    R11,CONLEN              GET CURRENT LENGTH\n         LA    R11,1(R11)              ADD 1\n         STH   R11,CONLEN              UPDATE LENGTH\n         L     R11,CONLOC              GET CURRENT LOC IN CONST DATA\n         MVC   0(1,R11),0(R7)          MOVE BYTE TO DATA\n         LA    R11,1(R11)              STEP OVER ONE BYTE\n         ST    R11,CONLOC              SAVE UPDATED DATA ADDR\n         CLI   CONTYPE,C'C'            CHARACTER CONSTANT\n         BE    CCK8                    YES\n         TM    CONOFST+3,1             OFFSET IS ODD\n         BO    CCFIN1                  YES\n         TM    CONOFST+3,2             HALFWORD OFFSET\n         BZ    CCFWD                   NO\n         CLI   CONLEN+1,1              HALFWORD, IS LENGTH = 1\n         BE    CCXIT1                  YES\n         B     CCFIN1                  NO\nCCFWD    CLI   CONLEN+1,4              NO, IS HEX CONST 4 BYTES\n         BL    CCXIT1                  NOT YET\n*              NOW LET'S SEE IF WE HAVE MULTIPLE 4 BYTE CHUNKS      RH\n*                                                                   RH\n         LA    R9,1               WE HAVE AT LEAST 1 SET OF 4       RH\n         LA    R11,1(0,R7)        R11 -> TO NEXT 4 BYTES            RH\n         SPACE 1                                                    RH\nMULTLOOP DS    0H                                                   RH\n         LR    R14,R11            R14 -> TO NEXT 4 BYTES            RH\n         S     R14,TXTSTRT        R14 = OFFSET TO NEXT 4 BYTES      RH\n         CLM   R14,7,LBLADR       IS THERE A LABEL IN THESE 4 BYTES RH\n         BNL   OUTMULT            YES, GO PRINT DC                  RH\n         CLC   CONDATA(4),0(R11)  NEXT 4 BYTES THE SAME ?           RH\n         BNE   OUTMULT            NO                                RH\n         LA    R9,1(0,R9)         ADD 1 TO MULTIPLE COUNTER         RH\n         LA    R11,4(0,R11)       R11 -> TO NEXT 4 BYTES            RH\n         C     R11,TXTEND         PAST END OF MODULE?               RH\n         BL    MULTLOOP           NO, GO CHECK THEM OUT             RH\n*        BNL   OUTMULT            YES, END OF MULT CODE             RH\n*        B     MULTLOOP           GO CHECK THEM OUT                 RH\n         SPACE 1                                                    RH\nOUTMULT  DS    0H                                                   RH\n         STH   R9,CONDUP          SAVE DUPLICATION COUNTER          RH\n         LR    R7,R11             UPDATE R7                         RH\n         BCTR  R7,0               ''                                RH\n         SPACE 1                                                    RH\n*                                                                   RH\nCCFIN1   BAL   R9,FORCONST             MAX LENG, FORCE IT OUT\n         B     CCXIT1                  FINISH\n*CK8     CLC   CONLEN,H8               CHAR CONSTANT 8 BYTES\nCCK8     CLC   CONLEN,MAXCON           CHAR CONSTANT AT MAX BYTES ? RH\n         BNL   CCFIN1                  YES\nCCXIT1   LA    R7,1(R7)                STEP OVER 1 BYTE IN TEXT\n         ST    R7,TXTCURR              UPDATE TEXT ADDR\n         B     GETCURR                 CONTINUE TEXT PROCESSING\nCCNEW    MVI   CONPROG,1               SHOW CONSTANT IN PROGRESS\n         MVC   CONOFST,TXTOFST         SET OFFSET TO 1ST BYTE\n         MVC   CONNAME,BLANX           CLEAR NAME\n         XC    CONDATA,CONDATA         CLEAR DATA AREA\n         MVC   CONSYM,BLANX            CLEAR SYMBOL NAME\n         MVC   CONLEN,XZROS            CLEAR LENGTH\n         LA    R11,CONDATA             GET 1ST DATA BYTE ADDR\n         ST    R11,CONLOC              SET STARTING ADDRESS OF DATA\n         CLC   TXTOFSET,LBLADR         LABEL AT THIS OFFSET\n         BE    CLBLD                   YES\nTRTYPE   TRT   0(1,R7),CHARTRAN        CHECK DATA TYPE OF BYTE\n         BNZ   CCSHX                   IT'S HEX\n         MVI   CONTYPE,C'C'            IT'S CHAR, SO INDICATE\n         B     CUPDCON                 GO COMPLETE\nCCSHX    MVI   CONTYPE,C'X'            IT'S HEX, SO INDICATE\n         B     CUPDCON                 GO COMPLETE\nCLBLD    CLI   LBLTYP,C'L'             IS IT A LABEL ONLY\n         BNE   CDATACON                NO\n         MVC   CONNAME,LBLNAME         NAME TO CONSTANT WORK AREA\n         MVC   CONLLEN,LBLLEN         SAVE LENGTH\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY\n         CLC   TXTOFSET,LBLADR         THIS LABEL AT SAME ADDR\n         BNE   TRTYPE                  NO\n         CLI   LBLTYP,C'L'             THIS ANOTHER LABEL ONLY\n         BNE   CDATACON                NO\n         SH    R6,LBLLGTH             BACK UP TO LABEL ENTRY\n         BAL   R9,EQUSTMT             GO BUILD EQU STATEMENT\n         LA    R6,L'LABEL(R6)          TO NEXT LABELENTRY\n         B     CCNEW                   GO TO NEXT LABEL\nCDATACON MVC   CONTYPE,LBLTYP          TYPE TO CONSTANT AREA\n         SPACE 1                                                    RH\n         CLI   LBLTYP,C'W'        WEAK EXTERNAL ?                   RH\n         BNE   *+4+4              NO                                RH\n         MVI   CONTYPE,C'V'       YES, CHANGE TO V TYPE             RH\n         SPACE 1                                                    RH\n         SR    R1,R1                   CLEAR WORK\n         IC    R1,LBLLEN               PICK UP CONSTNT LENGTH\n         STH   R1,CONLEN               SAVE CONSTANT LENGTH\n         BCTR  R1,R0                   COMPUTE CONSTANT LENGTH CODE\n         STC   R1,MCD+1                SET MOVE LENGTH CODE\nMCD      MVC   CONDATA,0(R7)           MOVE DATA TO RECORD\n         MVC   CONSYM,LBLNAME          SYMBOL TO CONSTANT AREA\n         SR    R11,R11                 CLEAR WORK REG\n         IC    R11,LBLLEN              PICK UP LENGTH\n         AR    R7,R11                  STEP PAST TEXT\n         ST    R7,TXTCURR              UPDATE TEXT ADDRESS\n         BAL   R9,FORCONST             FORCE CONSTANT OUT\n         LA    R6,L'LABEL(R6)          STEP TO NEXT LABEL ENTRY\n         B     GETCURR                 CONTINUE TEXT PROCESS\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS ENTERED BY VARIOUS ROUTINES WHEN IT IS         *\n* NECESSARY TO WRITE THE CONSTANT CURRENTLY IN PROGRESS, AND     *\n* CLEAR FIELDS FOR THE NEXT CONSTANT TO BE CREATED.              *\n*                                                                *\n******************************************************************\n*\nFORCONST EQU   *                       *** FORCE OUT CONSTANT IN PROGRE\n         ST    R9,FC9                  SAVE RETURN ADDR\n         CLC   CONNAME,BLANX           ANY LABEL NAME SET UP\n         BE    CKCNPRG                 NO, CONTINUE\n         CLC   CONLLEN,CONLEN+1        LENGTHS SAME\n         BE    CKCNPRG                 YES, CONTINUE\n         CLI   CONLLEN,X'00'           IS LENGTH ZERO ?             RH\n         BE    CKCNPRG                 YES, CONTINUE                RH\n         CLC   CONNAME,CONPSLBL+4 LABEL SAME AS PSEUDO LABEL?       RH\n         BE    CKCNPRG                 YES, CONTINUE                RH\n         ST    R6,FC6                  SAVE LABEL TABLE ADDR\n         LA    R6,CONPSLBL             @ PSEUDO LABEL ENTRY\n         BAL   R9,EQUSTMT              GO BUILD EQU STATEMENT\n         MVC   CONNAME,BLANX           CLEAR STATEMENT LABEL FIELD\n         L     R6,FC6                  RESTORE LABEL TABLE POINTER\nCKCNPRG  CLI   CONPROG,1               CONSTANT IN PROGRESS\n         BNE   FCCLR                   NO\n         CLI   CONLEN+1,0              ANY DATA LENGTH\n         BE    FCCLR                   NO\n         XC    TEXT,TEXT               CLEAR TEXT FIELD\n*****************************************************************\n         CLI   CONTYPE,C'W'            IS THIS A WEAK EXTERN?\n         BNE   NOTWEXT                 IF NOT, LEAVE IT ALONE\n         MVC   MNEMONIC(5),=C'WXTRN'   BUILD AN ENTRY STATEMENT\n         MVC   OPNDS(8),CONSYM         FOR THE WEAK EXTERNAL REF\n         BAL   R9,WRTOUT               PUT WEXTRN RECORD OUT\n         BAL   R9,PRINT                TO THE PRINT FILE ALSO.\n         MVI   CONTYPE,C'A'            CHANGE TO AN A CONSTANT\nNOTWEXT  DS    0H\n*****************************************************************\n         MVC   MNEMONIC(2),=C'DC'      SET MNEMONIC\n         MVC   OPNDS(1),CONTYPE        SET TYPE\n         MVI   OPNDS+1,C''''           OPERAND DELIMITER\n*        LH    R11,CONLEN         R11 = DATA LENGTH                 RH\n*        CH    R11,H1             IS IT A 1 BYTE DC ?               RH\n*        BE    NOLTH              YES                               RH\n*        CVD   R11,DBLWD          CONVERT TO DECIMAL                RH\n*        UNPK  OPNDS+1(3),DBLWD+6(2) UNPACK LTH                     RH\n*        MVI   OPNDS+1,C'L'       SET 'L' PART OF CL                RH\n*        MVI   OPNDS+4,C''''      SET '                             RH\n*        SPACE 1                                                    RH\n*NOLTH   DS    0H                                                   RH\n         MVC   NAME,CONNAME            NAME TO RECORD\n         MVC   OFFSET,CONOFST+1        OFFSET TO RECORD\n         MVI   INSTYP,0                NOT AN INSTRUCTION\n         MVI   TYPE,2                  NON-ADDRESS CONSTANT\n         MVC   LEN,CONLEN+1            DATA LENGTH\n         LH    R11,CONLEN              DATA LENGTH\n         BCTR  R11,R0                  DATA LENGTH CODE\n         STC   R11,FMCON+1             MOVE LENGTH TO MVC\nFMCON    MVC   TEXT,CONDATA            DATA TO RECORD\n         CLI   CONTYPE,C'C'            CHARACTER TYPE\n         BE    FCHAR                   YES\n         CLI   CONTYPE,C'X'            HEX TYPE\n         BNE   FSYMBOL                 NO\n         TM    CONOFST+3,1             OFFSET TO CONSTANT IS ODD\n         BO    FHEX                    YES\n         TM    CONLEN+1,1              LENGTH IS ODD\n         BO    FHEX                    YES\n         TM    CONOFST+3,2             OFFSET DIVISIBLE BY 4\n         BO    FHWD                    NO\n         CLI   CONLEN+1,4              IS IT 4-BYTES\n         BNE   FHWD                    NO, JUST HALFWORD\n         CLC   CONDATA(4),XZROS        CONSTANT IS ALL ZEROS\n         BNE   FFCKNEG                 NO\n         MVC   OPNDS(4),=C'F''0'''     BUILD OPERANDS\n         B     FCWRT                   CONTINUE\nFFCKNEG  ICM   R11,15,CONDATA          GET DATA\n         BM    FHEX                    NEG, TREAT AS HEX\n         C     R11,=F'99999'           VALUE EXCEEDS 99,999\n         BH    FHEX                    YES, TREAT AS HEX\n         MVC   OPNDS(2),=C'F'''        OPERAND DATA TYPE IS F\n         CVD   R11,DBLWD               CONVERT VALUE TO PACKED\n         UNPK  OPNDS+2(5),DBLWD+5(3)   UNPACK INTO OPERAND\n         OI    OPNDS+6,C'0'            SET SIGN = F\n         MVI   OPNDS+7,C''''           ENDING QUOTE\n         B     FCWRT                   CONTINUE\nFHWD     LH    R11,CONDATA             PICK UP HALFWORD\n         LTR   R11,R11                 TEST CONSTANT VALUE\n         BM    FHEX                    NEGATIVE, TREAT AS HEX\n         BNZ   FHCMAX                  NOT ZERO, CHECK MAX VALUE\n         MVC   OPNDS(4),=C'H''0'''     SET OPERAND FOR ZERO\n         B     FCWRT                   CONTINUE\nFHCMAX   CH    R11,=H'9999'            VALUE EXCEEDS 9,999\n         BH    FHEX                    YES, TREAT AS HEX\n         CVD   R11,DBLWD               CONVERT TO PACKED\n         OI    DBLWD+7,X'0F'           CLEAR SIGN TO F\n         MVC   OPNDS(2),=C'H'''        SET DELIMITER IN OPERAND\n         UNPK  OPNDS+2(4),DBLWD+5(3)   UNPACK VALUE TO OPERAND\n         MVI   OPNDS+6,C''''           ENDING DELIMITER\n         B     FCWRT                   CONTINUE\nFCHAR    MVC   OPNDS(2),=C'C'''        OPERAND DELIMITER FOR CHARACTER\n         LH    R11,CONLEN              GET DATA LENGTH\n         LA    R12,OPNDS+2        R12 -> TO WHERE DATA GOES         RH\n         CH    R11,H1             IS IT A 1 BYTE DC ?               RH\n         BE    NOLTH              YES                               RH\n         CVD   R11,DBLWD          CONVERT TO DECIMAL                RH\n         UNPK  OPNDS+1(3),DBLWD+6(2) UNPACK LTH                     RH\n         MVZ   OPNDS+3(1),OPNDS+2 FIX ZONE                          RH\n         MVI   OPNDS+1,C'L'       SET 'L' PART OF CL                RH\n         MVI   OPNDS+4,C''''      SET '                             RH\n*                                                                   RH\n*              NOW LETS CHECK TO  SEE IF THE DC IS ALL THE SAME     RH\n*                                                                   RH\n         LA    R12,CONDATA+1      R12 -> TO FIRST BYTE TO TEST      RH\n         LR    R9,R11             R9 = LTH TO TEST                  RH\n         BCTR  R9,R0              -1 FOR BYTE 1                     RH\n         SPACE 1                                                    RH\nLOOP1    DS    0H                                                   RH\n         CLC   CONDATA(1),0(R12)  IS THIS BYTE SAME AS THE FIRST?   RH\n         BNE   NOTSAME            NO, PUT IT OUT AS IS              RH\n         LA    R12,1(0,R12)       R12 -> TO NEXT BYTE TO TEST       RH\n         BCT   R9,LOOP1           GO CHECK IT                       RH\n         MVC   OPNDS+5(1),CONDATA MOVE 1 BYTE TO DC                 RH\n         MVI   OPNDS+6,C''''      MOVE IN END QUOTE                 RH\n         B     FCWRT              CONTINUE                          RH\n         SPACE 1                                                    RH\nNOTSAME  DS    0H                                                   RH\n*                                                                   RH\n         LA    R12,OPNDS+5        R12 -> TO WHERE DATA GOES         RH\n         SPACE 1                                                    RH\nNOLTH    DS    0H                                                   RH\n         BCTR  R11,R0                  LENGTH CODE\n         STC   R11,FMCNT+1             SET MOVE LENGTH\nFMCNT    MVC   0(1,R12),CONDATA        DATA TO OPERAND              RH\n         LA    R11,1(R12,R11)          STEP PAST OPERAND DATA       RH\n*MCNT    MVC   OPNDS+2,CONDATA         DATA TO OPERAND\n*        LA    R11,OPNDS+3(R11)        STEP PAST OPERAND DATA\n         MVI   0(R11),C''''            ENDING QUOTE\n         B     FCWRT                   CONTINUE\nFSYMBOL  CLC   CONSYM,BLANX            IS IT BLANK\n         BE    FHEX                    YES, TREAT AS HEX\n         CLI   CONLEN+1,4              LENGTH IS 4\n         BH    FHEX                    NO, GREATER\n         BE    AC4                     YES, 4 BYTES\n         CLI   CONLEN+1,3              LENGTH IS 3\n         BE    AC3                     YES\n         CLI   CONLEN+1,2              LENGTH IS 2\n         BE    AC2                     YES\n         MVC   OPNDS+1(2),=C'L1'       OPND LENGTH\n         B     FSLHE1                  CONTINUE\nAC2      MVC   OPNDS+1(2),=C'L2'       OPND LGTH\n         B     FSLHE1                  CONTINUE\nAC3      MVC   OPNDS+1(2),=C'L3'       OPND LENGTH\n         B     FSLHE1                  CONTINUE\nAC4      LA    R11,OPNDS+1             STEP TO ( POS\n         B     FSLHE                   CONTINUE\nFSLHE1   LA    R11,OPNDS+3             STEP TO ( POS\nFSLHE    MVI   0(R11),C'('             DELIMITER\n         MVC   1(8,R11),CONSYM         SYMBOL TO RECORD\n         LA    R11,9(R11)              @ RHE SYMBOL IN OPERAND\nFRHE     CLI   0(R11),C' '             CHARACTER IS BLANK\n         BNE   SETRPAR                 NO\n         BCT   R11,FRHE                LOOP TO FIND RHE\nSETRPAR  MVI   1(R11),C')'             SET CLOSING PAREN\n         B     FCWRT                   CONTINUE\nFHEX     MVC   OPNDS(2),=C'X'''        TYPE AND BEGIN QUOTE\n         LA    R12,CONDATA             @ CONSTANT DATA\n         BAL   R9,HEXPRT4              CONVERT TO PRINTABLE\n         LH    R12,CONLEN              GET DATA LENGTH\n         SLL   R12,1                   DOUBLE IT\n         BCTR  R12,R0                  -1 = LENGTH CODE\n         STC   R12,MVHX+1              SET MOVE LENGTH\nMVHX     MVC   OPNDS+2(1),PRTABL       HEX CHARS TO OPERAND\n         LA    R12,OPNDS+2(R12)        OPERAND END ADDRESS\n         MVI   1(R12),C''''            ENDING QUOTE\n         B     FCWRT                   CONTINUE\n         SPACE 1                                                    RH\nFCWRT    DS    0H                                                   RH\n         CLI   CONDUP+1,1         IS THERE A DUPLICATION COUNT?     RH\n         BNH   FCWRT2             NO                                RH\n         MVC   CONDATA(10),OPNDS  SAVE DC OPERAND                   RH\n         LH    R11,CONDUP         R11 = DUPLICATION COUNT           RH\n         CVD   R11,DBLWD          CONVERT TO DECIMAL                RH\n         UNPK  OPNDS(3),DBLWD+6(2) UNPACK                           RH\n         MVZ   OPNDS+2(1),OPNDS+1 FIX ZONE                          RH\n         LA    R11,OPNDS+3        HERES WHERE OPERAND GOES          RH\n         SPACE 1                                                    RH\nGETDUP   DS    0H                                                   RH\n         CLI   OPNDS,C'0'         LEADING 0?                        RH\n         BNE   GETOPND            NO                                RH\n         BCTR  R11,0              HERES WHERE OPERAND GOES          RH\n         MVC   OPNDS(2),OPNDS+1   DROP 0 BYTE                       RH\n         B     GETDUP             GO CHECK IT NOW                   RH\n         SPACE 1                                                    RH\nGETOPND  DS    0H                                                   RH\n         MVC   0(10,R11),CONDATA  PUT DC OPERAND BACK IN            RH\n         SPACE 1                                                    RH\nFCWRT2   DS    0H                                                   RH\n*                                                                   RH\n         BAL   R9,WRTOUT               WRITE RECORD\n         BAL   R9,TXTFMT               GO FORMAT HEX DATA\n         BAL   R9,PRINT                GO PRINT IT\n         MVI   DCINST,C'D'        SAY WE PRINTED A DC               RH\n         SPACE 1                                                    RH\nFCCLR    MVI   CONPROG,0               RESET CONSTANT IN PROGRESS\n         MVC   CONNAME,BLANX           CLEAR NAME\n         MVI   CONTYPE,0               RESET TYPE\n         XC    CONDATA,CONDATA         CLEAR CONSTANT DATA\n         MVC   CONSYM,BLANX            CLEAR SYMBOL\n         XC    CONLEN,CONLEN           CLEAR LENGTH\n         XC    CONDUP,CONDUP           CLEAR DUP COUNTER            RH\n         MVC   CONLOC,XZROS            CLEAR LOCATION\n         MVC   CONOFST,XZROS           CLEAR OFFSET TO CONSTANT\n         L     R9,FC9                  GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE FORMATS RR-FORMAT INSTRUCTIONS FOR OUTPUT.        *\n*                                                                *\n******************************************************************\n*\nRROPND   EQU   *                       *** RR FORMAT INSTRUCTIONS ***\n         CLI   0(R7),X'05'             IS IT BALR\n         BNE   RRSTRT\n         CLI   1(R7),X'EF'             IS IT BALR 14,15\n         BE    RRSTDL                  YES\n         TM    1(R7),X'0F'             NO, IS R2 = 0\n         BNZ   RRNSTD                  NO\n         MVC   COMMENT(11),=C'ADDRESS SET'\n         B     RRSTRT                  CONTINUE\nRRSTDL   MVC   COMMENT(11),=C'STD LINKAGE'\n         B     RRSTRT                  CONTINUE\nRRNSTD   MVC   COMMENT(14),=C'NONSTD LINKAGE'\nRRSTRT   EQU   *\n         LA    R15,TEXT+1              POINT TO TEXT\n         LR    R11,R1                  COPY INSTRUCTION TYPE\n         CH    R11,=H'48'              RRE TYPE?\n         BL    *+8                     NO, JUST RR\n         LA    R15,2(R15)              ADJ FO 2 BYTE OPCODE\n         SR    R1,R1                   CLEAR WORK\n         IC    R1,TEXT+1               GET 2ND BYTE\n         SRL   R1,4                    SHIFT OUT R2\n         CVD   R1,DBLWD                CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         MVI   OPNDS,C'R'              BEGIN R1 OPERAND\n         CH    R1,H10                  REG NBR > 9\n         BL    RR11                    NO, 0-9\n         MVC   OPNDS+1(2),DBLWD        YES, 10-15\n         LA    R1,OPNDS+3              TO NEXT POS\n         B     RRCMA                   CONTINUE\nRR11     MVC   OPNDS+1(1),DBLWD+1      MOVE REG NBR\n         LA    R1,OPNDS+2              TO NEXT POS\nRRCMA    EQU   *\n         CH    R11,=H'48'              RRE WITH ONE OPERAND?\n         BE    RRXIT                   YES\n         CLI   TEXT,X'04'              IS IT SPM\n         BNE   RRCMA1                  NO\n         TM    1(R7),X'0F'             YES, IS R2 FIELD = 0\n         BZ    RRXIT                   YES, GOOD INSTR\n         B     4(R9)                   ERROR RETURN (NOT INSTR)\nRRCMA1   MVC   0(2,R1),=C',R'          DELIMITERS\n         PACK  DBLWD(1),0(1,R15)       FLIP 2ND BYTE\n         SR    R15,R15                 CLEAR WORK\n         IC    R15,DBLWD               GET R2R1\n         SRL   R15,4                   SHIFT OUT R1\n         CVD   R15,DBLWD               CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R15,H10                 R2 > 9\n         BL    RR21                    NO, 0-9\n         MVC   2(2,R1),DBLWD           YES, MOVE REG 10-15\n         BR    R9                      EXIT\nRR21     MVC   2(1,R1),DBLWD+1         MOVE REG 0-9\nRRXIT    BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RX-TYPE  *\n* INSTRUCTIONS. THE BDXADR ROUTINE IS CALLED TO FORMAT THE       *\n* STORAGE OPERAND.                                               *\n*                                                                *\n******************************************************************\n*\nRXOPND   EQU   *                       *** RX FORMAT INSTRUCTIONS ***\n         CLI   0(R7),X'45'             IS IT BAL OP CODE\n         BNE   RXSTRT                  NO\n         MVC   COMMENT(7),=C'PERFORM'\n         TM    1(R7),X'E0'             R1 = 0 OR 1\n         BNZ   RXSTRT                  NO\n         MVC   COMMENT(13),=C'PARM SET BRCH'\nRXSTRT   SR    R1,R1                   CLEAR WORK\n         IC    R1,TEXT+1               GET R1X2\n         SRL   R1,4                    SHIFT OUT X2\n         CVD   R1,DBLWD                CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         MVI   OPNDS,C'R'              BEGIN 1ST OPERAND\n         CH    R1,H10                  R1 < 10\n         BL    RXR11                   YES, 0-9\n         MVC   OPNDS+1(2),DBLWD        NO, MOVE REG 10-15\n         LA    R15,OPNDS+3             TO NEXT POS\n         B     RXCMA                   CONTINUE\nRXR11    MVC   OPNDS+1(1),DBLWD+1      MOVE REG 0-9\n         LA    R15,OPNDS+2             TO NEXT POS\nRXCMA    MVI   0(R15),C','             DELIMITER\n         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE\n         SR    R10,R10                 CLEAR WORK\n         IC    R10,DBLWD               PICK UP X2R1\n         SRL   R10,4                   SHIFT OUT R1\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDDD\n         BAL   R9,BDXADR               CONVERT RX ADDRESS\n         STC   R10,BDXMVC+1            SET MOVE LENGTH\nBDXMVC   MVC   1(1,R15),OPNDWK         MOVE RX OPERAND\n         L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT S-TYPE   *\n* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *\n* STORAGE OPERAND.                                               *\n*                                                                *\n******************************************************************\n*\nSOPND    EQU   *                       *** S FORMAT INSTRUCTIONS ***\n         CLI   1(R7),0                 BYTE 2 OF INSTR IS ZERO\n         BE    SCK2                    YES\n         CLI   0(R7),X'80'             NO, IS IT SSM\n         BE    4(R9)                   YES, NOT INSTR\n         CLI   0(R7),X'82'             NO, IS IT LPSW\n         BE    4(R9)                   YES, NOT INSTR\n         CLI   0(R7),X'93'             NO, IS IT TS\n         BE    4(R9)                   YES, NOT INSTR\nSCK2     CLI   0(R7),X'B2'             OP-CODE IS B2\n         BNE   SSTRT                   NO\n         CLC   2(2,R7),XZROS           3RD AND 4TH BYTES ZERO\n         BE    SSTRT                   YES\n         CLI   1(R7),X'0B'             IPK INSTRUCTION\n         BE    4(R9)                   YES, NOT INSTR\n         CLI   1(R7),X'0D'             PTLB INSTR\n         BE    4(R9)                   YES, NOT INSTR\nSSTRT    SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDDD\n         BAL   R9,BDADR                CONVERT BDDD ADDRESS\n         MVC   PADDR1,ADDRVAL     SET UP ADDR 1                     RH\n         STC   R10,SOPMVC+1            SET MOVE LENGTH\nSOPMVC   MVC   OPNDS,OPNDWK            MOVE OPERAND\n         L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SI-TYPE  *\n* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *\n* STORAGE OPERAND.                                               *\n*                                                                *\n******************************************************************\n*\nSIOPND   EQU   *                       *** SI FORMAT INSTRUCTIONS ***\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDDD ADDRESS\n         BAL   R9,BDADR                CONVERT ADDRESS\n         MVC   PADDR1,ADDRVAL     SET UP ADDR 1                     RH\n         STC   R10,SIOMVC+1            SET MOVE LENGTH\nSIOMVC   MVC   OPNDS,OPNDWK            MOVE BDDD OPERAND\n         LA    R15,OPNDS+1(R10)        TO NEXT POS\n         MVI   0(R15),C','             DELIMITER\n         TRT   TEXT+1(1),CHARTRAN      TEST IF CHARACTER\n         BNZ   HEXIMM                  NO, HEX\n         CLI   TEXT,X'95'              IS IT CLI\n         BE    CHIMM                   YES\n         CLI   TEXT,X'92'              IS IT MVI\n         BNE   HEXIMM                  NO\nCHIMM    MVC   1(2,R15),=C'C'''        DELIMITER\n         MVC   3(1,R15),TEXT+1         CHARACTER TO OPERAND\n         MVI   4(R15),C''''            ENDING DELIMITER\n         L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\nHEXIMM   MVC   1(2,R15),=C'X'''        DELIMITER FOR HEX\n         LA    R12,TEXT+1              @ HEX BYTE\n         BAL   R9,HEXPRT1              CONVERT\n         MVC   3(2,R15),PRTABL         PRINTABLE HEX TO OPERAND\n         MVI   5(R15),C''''            FINAL QUOTE\n         L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RS-TYPE  *\n* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *\n* STORAGE OPERAND.                                               *\n*                                                                *\n******************************************************************\n*\nRSOPND   EQU   *                       *** RS FORMAT INSTRUCTIONS ***\n         CLI   TEXT,X'90'              IS IT STM\n         BE    RSSTM                   YES\n         CLI   TEXT,X'98'              IS IT LM\n         BNE   RSCLR1                  NO\n         MVC   COMMENT(12),=C'RESTORE REGS'\n         B     RSCLR1                  CONTINUE\nRSSTM    MVC   COMMENT(9),=C'SAVE REGS'\nRSCLR1   SR    R1,R1                   CLEAR WORK\n         IC    R1,TEXT+1               PICK UP R1R3\n         SRL   R1,4                    SHIFT OUT R3\n         CVD   R1,DBLWD                CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         MVI   OPNDS,C'R'              BEGINNING OPERAND 1\n         CH    R1,H10                  REG NBR < 10\n         BL    RSR11                   YES\n         MVC   OPNDS+1(2),DBLWD        MOVE REG 10-15\n         LA    R15,OPNDS+3             TO NEXT POS\n         B     RSCMA                   CONTINUE\nRSR11    MVC   OPNDS+1(1),DBLWD+1      MOVE REG 0-9\n         LA    R15,OPNDS+2             TO NEXT POS\nRSCMA    CLI   0(R7),X'88'             IS IT SHIFT INSTR\n         BL    RSCMA1                  NO\n         CLI   0(R7),X'8F'             IS IT SHIFT INSTR\n         BH    RSCMA1                  NO\n         TM    1(R7),X'0F'             SHIFT, IS R3 POS = 0\n         BZ    RSBDD                   YES, GOOD SHIFT\n         B     4(R9)                   NO, NOT INSTR\nRSCMA1   MVC   0(2,R15),=C',R'         DELIMITERS\n         CLI   0(R7),X'BD'             CLM, STCM, OR ICM\n         BL    RSPK2                   NO\n         CLI   0(R7),X'BF'             CLM,STCM, OR ICM\n         BH    RSPK2                   NO\n         BCTR  R15,R0                  CLM, STCM, ICM HAVE MASK IN R3 P\nRSPK2    PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE\n         SR    R1,R1                   CLEAR WORK\n         IC    R1,DBLWD                GET R3R1\n         SRL   R1,4                    SHIFT OUT R1\n         CVD   R1,DBLWD                CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R1,H10                  REG NBR < 10\n         BL    RSR31                   YES, 0-9\n         MVC   2(2,R15),DBLWD          MOVE REG 10-15\n         LA    R15,4(R15)              TO NEXT POS\n         B     RSBDD                   CONTINUE\nRSR31    MVC   2(1,R15),DBLWD+1        MOVE REG 0-9\n         LA    R15,3(R15)              TO NEXT POS\nRSBDD    MVI   0(R15),C','             DELIMITER\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDD ADDRESS\n         BAL   R9,BDADR                CONVERT BDDD ADDRESS\n         MVC   PADDR2,ADDRVAL     SET UP ADDR 2                     RH\n         STC   R10,RSMVC+1             SET MOVE LENGTH\nRSMVC    MVC   1(1,R15),OPNDWK         MOVE BDDD ADDRESS\n         L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SS-TYPE  *\n* INSTRUCTIONS OF THE SINGLE LENGTH VARIETY. THE BDLADR ROUTINE  *\n* IS CALLED TO FORMAT THE 1ST STRG OPND, AND BDADR FOR THE 2ND.  *\n*                                                                *\n******************************************************************\n*\nSS1OPND  EQU   *                       *** SS FORMAT INSTRUCTIONS - SIN\n         SR    R10,R10                 CLEAR WORK\n         IC    R10,TEXT+1              GET LENGTH CODE\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDDD ADDRESS\n         BAL   R9,BDLADR               CONVERT ADDRESS\n         MVC   PADDR1,ADDRVAL     SET UP ADDR 1                     RH\n         STC   R10,SS1MV1+1            SET MOVE LENGTH\nSS1MV1   MVC   OPNDS,OPNDWK            MOVE ADDRESS\n         LA    R15,OPNDS+1(R10)        TO NEXT POS\n         MVI   0(R15),C','             DELIMITER\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+4            GET SECOND BDDD ADDRESS\n         BAL   R9,BDADR                CONVERT ADDRESS\n         MVC   PADDR2,ADDRVAL     SET UP ADDR 2                     RH\n         STC   R10,SS1MV2+1            SET MOVE LENGTH\nSS1MV2   MVC   1(1,R15),OPNDWK         MOVE 2ND OPERAND\n         L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SS-TYPE  *\n* INSTRUCTIONS OF THE DOUBLE LENGTH VARIETY. THE BDLADR ROUTINE  *\n* IS CALLED TO FORMAT THE STORAGE OPERANDS.                      *\n*                                                                *\n******************************************************************\n*\nSS2OPND  EQU   *                       *** SS FORMAT INSTRUCTIONS - 2 L\n         SR    R10,R10                 CLEAR WORK\n         IC    R10,TEXT+1              GET L1L2\n         SRL   R10,4                   SHIFT OUT L2\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDDD ADDRESS\n         BAL   R9,BDLADR               CONVERT ADDRESS\n         MVC   PADDR1,ADDRVAL     SET UP ADDR 1                     RH\n         STC   R10,SS2MV1+1            SET MOVE LENGTH\nSS2MV1   MVC   OPNDS,OPNDWK            MOVE 1ST OPERAND\n         LA    R15,OPNDS+1(R10)        TO NEXT POS\n         MVI   0(R15),C','             DELIMITER\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+4            GET 2ND BDDD ADDR\n         PACK  DBLWD(1),TEXT+1(1)      FLIP LENGTH BYTE\n         SR    R10,R10                 CLEAR WORK\n         IC    R10,DBLWD               PICK UP L2L1\n         SRL   R10,4                   SHIFT OUT L1\n         CLI   TEXT,X'F0'              SRP OP-CODE\n         BE    SRPOP2                  YES\n         TM    IEDT,M1                 SPECIAL MOVE INST OP-CODE\n         BO    SRPOP2                  YES\n         BAL   R9,BDLADR               CONVERT ADDRESS\n         MVC   PADDR2,ADDRVAL     SET UP ADDR 2                     RH\n         STC   R10,SS2MV2+1            SET MOVE LENGTH\nSS2MV2   MVC   1(1,R15),OPNDWK         MOVE 2ND OPERAND\nSS2XIT   L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\nSRPOP2   BAL   R9,BDADR                GO BUILD OPERAND 2\n         MVC   PADDR2,ADDRVAL     SET UP ADDR 2                     RH\n         STC   R10,SRMV1+1             SET MOVE LENGTH\nSRMV1    MVC   1(1,R15),OPNDWK         MOVE OPERAND 2\n         LA    R15,2(R10,R15)          TO NEXT OPERAND POS  FIX***\n         PACK  DBLWD(1),TEXT+1(1)      FLIP LENGTH BYTE\n         SR    R10,R10                 CLEAR WORK\n         IC    R10,DBLWD               PICK UP I3/R3\n         SRL   R10,4                   SHIFT OUT L1\n         CVD   R10,DBLWD               CONVERT I3/R3\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         MVI   0(R15),C','             OPERAND SEPARATOR    FIX***\n         UNPK  1(1,R15),DBLWD+7(1)     UNPACK I3/R3 TO OPERAND FIX***\n         CH    R2,H10                  I3/R3 < 10\n         BL    SS2XIT                  YES\n         UNPK  1(2,R15),DBLWD+6(2)     NO, UNPACK MORE\n         B     SS2XIT                  CONTINUE\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT COND-    *\n* ITIONAL BRANCH INSTRUCTIONS. AN ATTEMPT IS MADE TO USE THE     *\n* EXTENDED MNEMONICS WHERE POSSIBLE. FOR RR-TYPE BRANCHES, ONLY  *\n* THE BR AND NOPR MNEMONICS ARE USED. FOR RX-TYPE BRANCHES, THE  *\n* FULL SET OF EXTENDED MNEMONICS IS USED. THE TYPES USED ARE     *\n* ARITHMETIC, COMPARE, AND 8=ZERO TYPES. THE SET TO BE USED IS   *\n* DETERMINED BY THE TYPE SAVED BY THE LAST CONDITION-CODE-SETTING*\n* INSTRUCTION GENERATED.                                         *\n*\n******************************************************************\n*\nBCOPND   EQU   *                       *** CONDITIONAL BRANCH INSTRUCTI\n         TM    TEXT+1,X'F0'            UNCONDITIONAL BRANCH\n         BZ    NOPS                    NO, NOP\n         BO    UNCNDS                  YES, UNCONDITIONAL\n         SR    R11,R11                 CLEAR WORK\n         IC    R11,TEXT+1              PICK UP M1X2\n         SRL   R11,4                   SHIFT OUT ALL BUT M1\n         CLI   TEXT,X'07'              BCR OP CODE\n         BE    NOEXTND                 YES, NO EXTENDED MNEMONICS\n         CLI   CCTYPE,0                LAST INSTR SET CC\n         BE    NOEXTND                 NO\n         TM    CCTYPE,ARITH            YES, WAS IT ARITHMETIC\n         BO    EXTARITH                YES\n         TM    CCTYPE,CPR              WAS IT COMPARE\n         BO    EXTCPR                  YES\n         TM    CCTYPE,ZRO8             IS IT VALID FOR 8 = BZ\n         BO    EXTZRO                  YES\nNOEXTND  CVD   R11,DBLWD               CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R11,H10                 MASK < 10\n         BL    BCM1                    YES, SINGLE DIGIT MASK\n         MVC   OPNDS(2),DBLWD          2-DIGIT MASK TO OPERAND\n         LA    R15,OPNDS+2             TO NEXT POS\n         B     BCCMA                   CONTINUE\nBCM1     MVC   OPNDS(1),DBLWD+1        SINGLE DIGIT MASK TO OPERAND\n         LA    R15,OPNDS+1             TO NEXT POS\nBCCMA    MVI   0(R15),C','             DELIMITER\n         CLI   TEXT,X'07'              RR BRANCH\n         BE    BCROPND                 YES\nBCXOPND  PACK  DBLWD(1),TEXT+1(1)      PACK 2ND BYTE\n         SR    R10,R10                 CLEAR WORK\n         IC    R10,DBLWD               PICK UP X2M1\n         SRL   R10,4                   SHIFT OUT M1\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            PICK UP BDDD ADDRESS\n         BAL   R9,BDXADR               CONVERT ADDRESS\n         STC   R10,BLDXMVC+1           SET MOVE LENGTH\nBLDXMVC  MVC   1(1,R15),OPNDWK         MOVE OPERAND\n         B     BCOXIT                  GO TO EXIT\nBCROPND  MVI   1(R15),C'R'             REGISTER DELIMITER\n         SR    R10,R10                 CLEAR WORK\n         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE\n         IC    R10,DBLWD               PICK UP R2M1\n         SRL   R10,4                   SHIFT OUT M1\n         CVD   R10,DBLWD               CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R10,H10                 REG NBR < 10\n         BL    BCRR1                   YES, 0-9\n         MVC   2(2,R15),DBLWD          MOVE 2-DIGIT REG NBR\n         B     BCOXIT                  GO TO EXIT\nBCRR1    MVC   2(1,R15),DBLWD+1        MOVE 1-DIGIT REG NBR\n         B     BCOXIT                  GO TO EXIT\nNOPS     CLI   TEXT,X'07'              RR NOP\n         BNE   BCXNOP                  NO, RX\n         MVC   MNEMONIC,=CL5'NOPR'     SET MNEMONIC\n         LA    R15,OPNDS-1             TO OPND POS\n         B     BCROPND                 FINISH\nBCXNOP   MVC   MNEMONIC,=CL5'NOP'      SET MNEMONIC\n         LA    R15,OPNDS-1             TO OPND POS\n         B     BCXOPND                 FINISH\nUNCNDS   CLI   TEXT,X'07'              IS IT RR BRANCH\n         BNE   BCXBRCH                 NO, RX\n         MVC   MNEMONIC,=CL5'BR'       SET MNEMONIC\n         LA    R15,OPNDS-1             OPERAND ADDR\n         CLI   TEXT+1,X'FE'            IS IT BR 14\n         BNE   BCROPND                 NO\n         MVC   COMMENT(4),=C'EXIT'     COMMENT\n         B     BCROPND                 FINISH FORMATTING\nBCXBRCH  MVC   MNEMONIC(5),=CL5'B'     SET MNEMONIC\nBCXTFIN  LA    R15,OPNDS-1             SET OPND POS\n         B     BCXOPND                 FINISH FORMAT\nBCOXIT   L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\nEXTARITH CH    R11,H8                  COND CODE = 8\n         BE    ARBZ                    YES\n         BL    ARLOW                   NO, LOWER\n         CH    R11,H14                 COND CODE = 14\n         BE    ARBNO                   YES\n         CH    R11,H13                 COND CODE = 13\n         BE    ARBNP                   YES\n         CH    R11,H11                 COND CODE = 11\n         BE    ARBNM                   YES\n         B     NOEXTND                 NO, NOT EXTENDED\nARLOW    CH    R11,H7                  COND CODE = 7\n         BE    ARBNZ                   YES\n         CH    R11,H1                  COND CODE = 1\n         BE    ARBO                    YES\n         CH    R11,H2                  COND CODE = 2\n         BE    ARBP                    YES\n         CH    R11,H4                  COND CODE = 4\n         BE    ARBM                    YES\n         B     NOEXTND                 NO, NOT EXTENDED\nARBZ     MVC   MNEMONIC(2),=C'BZ'      SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nARBNO    MVC   MNEMONIC(3),=C'BNO'     SET EXTENDED MNEMONIC\n         B     BCXTFIN                 CONTINUE\nARBNP    MVC   MNEMONIC(3),=C'BNP'     SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nARBNM    MVC   MNEMONIC(3),=C'BNM'     SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nARBNZ    MVC   MNEMONIC(3),=C'BNZ'     SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nARBO     MVC   MNEMONIC(2),=C'BO'      SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nARBP     MVC   MNEMONIC(2),=C'BP'      SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nARBM     MVC   MNEMONIC(2),=C'BM'      SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nEXTZRO   CH    R11,H8                  COND CODE = 8\n         BE    ARBZ                    YES, USE BZ MNEMONIC\n         CH    R11,H7                  COND CODE IS 7\n         BE    ARBNZ                   YES\n         B     NOEXTND                 NO, NOT EXTENDED\nEXTCPR   CH    R11,H8                  COND CODE = 8\n         BE    CPBE                    YES\n         CH    R11,H7                  COND CODE = 7\n         BE    CPBNE                   YES\n         BL    CPLOW                   NO, LOWER\n         CH    R11,H13                 COND CODE = 13\n         BE    CPBNH                   YES\n         CH    R11,H11                 COND CODE = 11\n         BE    CPBNL                   YES\n         B     NOEXTND                 NO, NOT EXTENDED\nCPLOW    CH    R11,H4                  COND CODE = 4\n         BE    CPBL                    YES\n         CH    R11,H2                  COND CODE = 2\n         BE    CPBH                    YES\n         B     NOEXTND                 NO, NOT EXTENDED\nCPBE     MVC   MNEMONIC(2),=C'BE'      SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nCPBNE    MVC   MNEMONIC(3),=C'BNE'     SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nCPBNH    MVC   MNEMONIC(3),=C'BNH'     SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nCPBNL    MVC   MNEMONIC(3),=C'BNL'     SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nCPBL     MVC   MNEMONIC(2),=C'BL'      SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nCPBH     MVC   MNEMONIC(2),=C'BH'      SET EXTENDED MNEMONIC\n         B     BCXTFIN                 CONTINUE\n*\n*\n*\n******************************************************************\n*                                                                *\n* VALIDATE AND FORMAT SVC INSTRUCTIONS. IF THE SVC OP-CODE IS    *\n* FOUND IN THE SVC TABLE, IT IS ACCEPTED AS AN SVC, AND THE TABLE*\n* LITERAL IS MOVED TO THE COMMENTS FIELD OF THE INSTRUCTION.     *\n*                                                                *\n******************************************************************\n*\nSVCOPND  EQU   *                       *** SVC INSTRUCTIONS ***\n         CLI   TEXT+1,126              VALID OPERAND\n         BH    NOTSVC                  NO, NOT SVC\n         L     R1,SVCTBLAD             GET SVC TABLE ADDRESS\nSVCKND   CLI   0(R1),X'FF'             END OF SVC TABLE\n         BE    NOTSVC                  YES, MUST NOT BE SVC\n         CLC   0(1,R1),TEXT+1          THIS THE ENTRY\n         BE    GOTSVC                  YES\n         LA    R1,L'SVCOP(R1)          STEP TO NEXT ENTRY\n         B     SVCKND                  LOOP THRU TABLE\nNOTSVC   B     4(R9)                   ERROR RETURN\nGOTSVC   MVC   COMMENT(14),1(R1)       COMMENT TO WORK AREA\n         SR    R1,R1                   CLEAR WORK\n         IC    R1,TEXT+1               GET SVC OPERAND\n         CVD   R1,DBLWD                CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK\n         CH    R1,H100                 OPERAND > 100\n         BL    SVCK10                  YES\n         MVC   OPNDS(3),DBLWD          MOVE 3-DIGIT OPERAND\n         B     SVCXIT                  EXIT\nSVCK10   CH    R1,H10                  OPERAND < 10\n         BL    SVCL10                  YES\n         MVC   OPNDS(2),DBLWD+1        MOVE 2-DIGIT OPERAND\n         B     SVCXIT                  EXIT\nSVCL10   MVC   OPNDS(1),DBLWD+2        MOVE 1-DIGIT OPERAND\nSVCXIT   BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SSE-TYPE *\n* INSTRUCTIONS. THE BDADDR ROUTINE IS CALLED TO FORMAT THE STOR- *\n* AGE OPERANDS.                                                  *\n*                                                                *\n******************************************************************\nSSEOPND  EQU   *\n         SR    R10,R10                 CLEAR WORK\n         IC    R10,TEXT+1              GET LENGTH CODE\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDDD ADDRESS\n         BAL   R9,BDADR                CONVERT ADDRESS\n         STC   R10,SSEMV1+1            SET MOVE LENGTH\nSSEMV1   MVC   OPNDS,OPNDWK            MOVE ADDRESS\n         LA    R15,OPNDS+1(R10)        TO NEXT POS\n         MVI   0(R15),C','             DELIMITER\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+4            GET BDDD ADDRESS\n         BAL   R9,BDADR                CONVERT ADDRESS\n         STC   R10,SSEMV2+1            SET MOVE LENGTH\nSSEMV2   MVC   1(1,R15),OPNDWK         MOVE ADDRESS\n         L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*   E INSTR, NO OPERANDS                                         *\n******************************************************************\nEOPND    EQU   *\n         BR    R9\n*\n*\n*\n******************************************************************\n*   RRE INSTRUCTIONS, 1 OR 2 OPERANDS                            *\n******************************************************************\nRREOPND  EQU   *\n         BR    R9\n*\n*\n*\n******************************************************************\n* BUILD EQU STATEMENTS USING THE LABEL TABLE ENTRY ADDRESSED BY  *\n* REG 6 ON ENTRY.                                                *\n*                                                                *\n******************************************************************\n*                                                                *\nEQUSTMT  EQU   *                       BUILD EQU STATEMENTS\n         ST    R9,EQU9                 SAVE RETURN ADDR\n         USING LABELD,R6\n         MVC   PADDR2,LBLNAME+2   PUT IT IN PRINT RECORD            RH\n         MVC     NAME,LBLNAME          NAME TO EQU STMT\n         MVC   MNEMONIC,=CL5'EQU'      BUILD EQU STATEMENT\n         MVI   OPNDS,C'*'              SET EQU OPERAND\n         CLI   LBLOFSET,X'FF'     DO WE NEED AN EQU+1               RH\n         BE    EQU1               YES                               RH\n         CLI   LBLLEN,1                LENGTH 0 OR 1\n*        BNH   CCXEQU                  YES\n         BE    CCXEQU             YES, IT'S 1                       RH\n         BH    EQU1               NO, ON WE GO                      RH\n*        BL    *+4                YES, IT'S 0, SET UP ADDR2         RH\n         CLI   PADDR2,C'0'        DO WE HAVE A VALID ADDR?          RH\n         BE    CCXEQU             YES, AS NEAR AS WE CAN TELL       RH\n         MVC   PADDR2,BLANX       NO, BLANK IT OUT                  RH\n         CLC   0(3,R6),13(R6)     ADDR SAME AS NEXT ENTRY?          RH\n         BNE   CCXEQU             NO, ON WE GO                      RH\n         MVC   PADDR2,19(R6)      YES, PUT IT IN PRINT RECORD       RH\n         B     CCXEQU             ON WE GO                          RH\n         SPACE 1                                                    RH\nEQU1     DS    0H                                                   RH\n         SR    R9,R9                   CLEAR WORK\n         IC    R9,LBLLEN               GET LENGTH\n         CVD   R9,DBLWD                CONVERT\n         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK\n         OI    DBLWD+2,C'0'            CLEAR SIGN\n         CH    R9,H100                 LENGTH < 100\n         BL    CCXQ10                  YES\n         MVC   OPNDS+2(3),DBLWD        MOVE LENGTH\n         B     CCXEQC                  GO SET COMMA\nCCXQ10   CH    R9,H10                  LENGTH < 10\n         BL    CCXQ1                   YES\n         MVC   OPNDS+2(2),DBLWD+1      MOVE 2-DIGIT LENGTH\n         B     CCXEQC                  GO SET COMMA\nCCXQ1    MVC   OPNDS+2(1),DBLWD+2      MOVE 1-DIGIT LENGTH\nCCXEQC   MVI   OPNDS+1,C','            SET COMMA\n         CLI   CONPROG,1               CONSTANT IN PROGRESS         RH\n         BE    CCXEQU             YES                               RH\n         MVI   OPNDS+1,C'+'       CHANGE COMMA TO PLUS              RH\n         SPACE 1                                                    RH\nCCXEQU   BAL   R9,WRTOUT               OUTPUT EQU STATEMENT\n         BAL   R9,PRINT                GO PRINT IT\n         MVI   LBLOFSET,X'00'     CLEAR EQU+1 FLAG                  RH\n         L     R9,EQU9                 GET RETURN ADDR\n         BR    R9                      RETURN\n         DROP  R6\n*\n*\n*\n******************************************************************\n*                                                                *\n* BUILDS STORAGE OPERANDS CONTAINING BASE, DISPLACEMENT, AND     *\n* LENGTH. ON ENTRY, REG 11 CONTAINS THE BDDD ADDRESS, AND REG 10 *\n* CONTAINS THE LENGTH. THE SCHLBL ROUTINE IS CALLED TO CREATE A  *\n* LABEL REFERENCE, IF THE BASE REG IS CURRENT, AND A LABEL EXISTS*\n* IF SCHLBL IS UNSUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM     *\n* DDDD(LLL,RRR) IS CREATED.                                      *\n*                                                                *\n******************************************************************\n*\nBDLADR   EQU   *                       *** FORMAT DDDD(LLL,RRR) OPERAND\n         ST    R9,BDL9                 SAVE RETURN ADDR\n         SR    R0,R0                   CLEAR WORK REG\n         LR    R1,R11                  COPY BDDD ADDRESS\n         SLDL  R0,20                   BASE REG TO R0\n         LTR   R0,R0                   IS BASE REG 0\n         BNZ   BDLSCHL                 NO\n         SRL   R1,20                   RIGHT JUSTIFY DISPL\n         CH    R1,H16                  REFERENCE TO CVT ADDR\n         BE    BDLCVTR                 YES\n         CH    R1,H76                  REF TO ALTERNATE CVT ADDR\n         BE    BDLCVTR                 YES\n         MVC   COMMENT(13),=C'PSA REFERENCE'\n         B     BDLSCHL                 CONTINUE\nBDLCVTR  MVC   COMMENT(11),=C'CVT ADDRESS'\nBDLSCHL  BAL   R9,SCHLBL               SEARCH FOR LABEL\n         B     BDLGLBL                 BRANCH IF LABEL FOUND\n*        MVC   PADDR2,ADDRVAL     SET UP ADDR 2                     RH\n         LR    R1,R11                  COPY BDDD ADDRESS\n         SLL   R1,20                   SHIFT OUT B\n         SRL   R1,20                   RIGHT JUSTIFY DDD\n         CVD   R1,DBLWD                CONVERT DDD\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(4),DBLWD+5(3)     UNPACK\n         MVC   OPNDWK,BLANX            CLEAR WORK AREA\n         CH    R1,H1000                DISPL < 1000\n         BL    BDLD100                 YES\n         MVC   OPNDWK(4),DBLWD         MOVE 4-DIGIT DISPL\n         LA    R1,OPNDWK+4             TO NEXT POS\n         B     BDLLPN                  CONTINUE\nBDLD100  CH    R1,H100                 DISPL < 100\n         BL    BDLD10                  YES\n         MVC   OPNDWK(3),DBLWD+1       MOVE 3-DIGIT DISPL\n         LA    R1,OPNDWK+3             TO NEXT POS\n         B     BDLLPN                  CONTINUE\nBDLD10   CH    R1,H10                  DISPL < 10\n         BL    BDLD1                   YES\n         MVC   OPNDWK(2),DBLWD+2       MOVE 2-DIGIT DISPL\n         LA    R1,OPNDWK+2             TO NEXT POS\n         B     BDLLPN                  CONTINUE\nBDLD1    MVC   OPNDWK(1),DBLWD+3       MOVE 1-DIGIT DISPL\n         LA    R1,OPNDWK+1             TO NEXT POS\nBDLLPN   MVI   0(R1),C'('              LEFT PAREN DELIMITER\n         TM    IEDT,M1                 IS THIS A SPECIAL MOVE INSTR\n         BO    *+8                     DON'T ADJUST LENGTH\n         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH FROM LENG\n         CVD   R10,DBLWD               CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK\n         CH    R10,H100                LENGTH < 100\n         BL    BDLL10                  YES\n         MVC   1(3,R1),DBLWD           MOVE 3-DIGIT LENGTH\n         LA    R1,4(R1)                TO NEXT POS\n         B     BDLCMA                  CONTINUE\nBDLL10   CH    R10,H10                 LENGTH < 10\n         BL    BDLL1                   YES\n         MVC   1(2,R1),DBLWD+1         MOVE 2-DIGIT LENGTH\n         LA    R1,3(R1)                TO NEXT POS\n         B     BDLCMA                  CONTINUE\nBDLL1    MVC   1(1,R1),DBLWD+2         MOVE 1-DIGIT LENGTH\n         LA    R1,2(R1)                TO NEXT POS\nBDLCMA   MVC   0(2,R1),=C',R'          DELIMITERS\n         SRL   R11,12                  RT JUSTIFY BASE REG\n         CVD   R11,DBLWD               CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R11,H10                 REG < 10\n         BL    BDLR1                   YES\n         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT REGISTER\n         LA    R1,4(R1)                TO NEXT POS\n         B     BDLRPN                  CONTINUE\nBDLR1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT REG\n         CLI   2(R1),C'0'              IS REG = 0\n         BNE   BDLB1                   NO\n         MVC   0(2,R1),BLANX           YES, BLANK IT\n***      BCTR  R1,R0                   BACK UP 1            FIX***\n         B     BDLRPN                  CONTINUE\nBDLB1    LA    R1,3(R1)                TO NEXT POS\nBDLRPN   MVI   0(R1),C')'              FINAL DELIMITER\n         LR    R10,R1                  COPY END ADDRESS\n         S     R10,OWSTRT              COMPUTE OPERAND LENGTH CODE\n         L     R9,BDL9                 GET RETURN ADDR\n         BR    R9                      EXIT\n         USING LABELD,R12\nBDLGLBL  MVC   OPNDWK(8),LBLNAME       LABEL ENTRY NAME TO WORK\n*        MVC   PADDR2,ADDRVAL     SET UP ADDR 2                     RH\n         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH\n         LA    R1,OPNDWK+7             @ LAST POSS CHARACTER\nBDLGRHE  CLI   0(R1),C' '              AT RHE\n         BNE   BDLGCKLN                YES\n         BCT   R1,BDLGRHE              LOOP TO RHE\nBDLGCKLN DS    0H                                                   RH\n******************************************************************  RH\n*              ALWAYS PUT THE LTH ON THE INSTRUCTION OPERANDS       RH\n******************************************************************  RH\n*        CLM   R10,1,LBLLEN            LBL AND INSTR LENGTHS SAME   RH\n*        BE    BDLGCMP                 YES                          RH\n******************************************************************  RH\n         MVI   1(R1),C'('              NO, DELIMITER\n         CVD   R10,DBLWD               CONVERT LENGTH\n         UNPK  DBLWD(3),DBLWD+5(3)     UNPACK\n         OI    DBLWD+2,C'0'            CLEAR SIGN\n         CH    R10,H100                LENGTH < 100\n         BL    BDLG10                  YES\n         MVC   2(3,R1),DBLWD           MOVE 3-DIGIT LENGTH\n         LA    R1,5(R1)                TO NEXT POS\n         B     BDLGRPN                 CONTINUE\nBDLG10   CH    R10,H10                 LENGTH < 10\n         BL    BDLG1                   YES\n         MVC   2(2,R1),DBLWD+1         MOVE 2-DIGIT LENGTH\n         LA    R1,4(R1)                TO NEXT POS\n         B     BDLGRPN                 CONTINUE\nBDLG1    MVC   2(1,R1),DBLWD+2         MOVE 1-DIGIT LENGTH\n         LA    R1,3(R1)                TO NEXT POS\nBDLGRPN  MVI   0(R1),C')'              FINAL DELIMITER\nBDLGCMP  LR    R10,R1                  COPY END ADDRESS\n         S     R10,OWSTRT              COMPUTE LENGTH CODE\n         L     R12,SLSAV+12            RESTORE R12\n         L     R9,BDL9                 GET RETURN ADDR\n         BR    R9                      EXIT\n         DROP  R12\n*\n*\n*\n******************************************************************\n*                                                                *\n* BUILDS STORAGE OPERANDS CONTAINING BASE AND DISPLACEMENT.      *\n* THE SCHLBL ROUTINE IS CALLED TO SEE WHETHER A LABEL REFERENCE  *\n* MAY BE USED, RATHER THAN AN EXPLICIT ADDRESS. IF LBLSCH IS NOT *\n* SUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM DDDD(RRR) IS FORMED*\n* ON ENTRY, REG 11 CONTAINS THE BDDD ADDRESS.                    *\n*                                                                *\n******************************************************************\n*\nBDADR    EQU   *                       *** FORMAT DDDD(RRR) OPERANDS **\n         ST    R9,BD9                  SAVE RETURN ADDR\n         SR    R0,R0                   CLEAR WORK REG\n         LR    R1,R11                  COPY BDDD ADDRESS\n         SLDL  R0,20                   BASE REG TO R0\n         LTR   R0,R0                   IS BASE REG 0\n         BNZ   BDSCHL                  NO\n         CLI   TEXT,X'8F'              IS IT SLDA??              FIX***\n         BH    BDSADR1                 YES                       FIX***\n         CLI   TEXT,X'88'              IS IT SRL                 FIX***\n         BNL   BDSCHL                  YES                       FIX***\nBDSADR1  SRL   R1,20                   RIGHT JUSTIFY DISPL       FIX***\n         CH    R1,H16                  REFERENCE TO CVT ADDR\n         BE    BDCVTR                  YES\n         CH    R1,H76                  REF TO ALTERNATE CVT ADDR\n         BE    BDCVTR                  YES\n         MVC   COMMENT(13),=C'PSA REFERENCE'\n         B     BDSCHL                  CONTINUE\nBDCVTR   MVC   COMMENT(11),=C'CVT ADDRESS'\nBDSCHL   BAL   R9,SCHLBL               GO SEARCH FOR LABEL\n         B     BDGLBL                  BRANCH IF FOUND\n*        MVC   PADDR1,ADDRVAL     SET UP ADDR 1                     RH\n         LR    R1,R11                  COPY BDDD ADDRESS\n         SLL   R1,20                   SHIFT OUT B\n         SRL   R1,20                   RIGHT JUSTIFY DDD\n         CVD   R1,DBLWD                CONVERT DISPL\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(4),DBLWD+5(3)     UNPACK\n         CH    R1,H1000                DISPL < 1000\n         BL    BDAD100                 YES\n         MVC   OPNDWK(4),DBLWD         MOVE 4-DIGIT DISPL\n         LA    R1,OPNDWK+4             TO NEXT POS\n         B     BDALPN                  CONTINUE\nBDAD100  CH    R1,H100                 DISPL < 100\n         BL    BDAD10                  YES\n         MVC   OPNDWK(3),DBLWD+1       MOVE 3-DIGIT DISPL\n         LA    R1,OPNDWK+3             TO NEXT POS\n         B     BDALPN                  CONTINUE\nBDAD10   CH    R1,H10                  DISPL < 10\n         BL    BDAD1                   YES\n         MVC   OPNDWK(2),DBLWD+2       MOVE 2-DIGIT DISPL\n         LA    R1,OPNDWK+2             TO NEXT POS\n         B     BDALPN                  CONTINUE\nBDAD1    MVC   OPNDWK(1),DBLWD+3       MOVE 1-DIGIT DISPL\n         LA    R1,OPNDWK+1             TO NEXT POS\nBDALPN   MVC   0(2,R1),=C'(R'          DELIMITERS\n         SRL   R11,12                  RT JUSTIFY BASE REG\n         CVD   R11,DBLWD               CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R11,H10                 BASE REG < 10\n         BL    BDAR1                   YES\n         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT BASE REG\n         LA    R1,4(R1)                TO NEXT POS\n         B     BDARPN                  CONTINUE\nBDAR1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT BASE REG\n         LA    R1,3(R1)                TO NEXT POS\nBDARPN   MVI   0(R1),C')'              FINAL DELIMITER\n         LR    R2,R1                   COPY END ADDRESS\n         SH    R2,H4                   BACK UP 4\n         CLC   1(4,R2),=C'(R0)'        BASE REG IS ZERO\n         BNE   BDCE                    NO\n         MVC   1(4,R2),BLANX           CLEAR BASE REG\n         LR    R1,R2                   COPY NEW END ADDR\nBDCE     LR    R10,R1                  COPY END ADDR\n         S     R10,OWSTRT              COMPUTE LENGTH CODE\n         L     R9,BD9                  GET RETURN ADDR\n         BR    R9                      EXIT\n         USING LABELD,R12\nBDGLBL   MVC   OPNDWK(8),LBLNAME       LABEL ENTRY NAME TO WORK\n*        MVC   PADDR1,ADDRVAL     SET UP ADDR 1                     RH\n         LA    R1,OPNDWK+7             @ LAST POSS CHARACTER\nBDGRHE   CLI   0(R1),C' '              AT RHE\n         BNE   BDGCMP                  YES\n         BCT   R1,BDGRHE               LOOP TO RHE\nBDGCMP   LR    R10,R1                  COPY END ADDRESS\n         S     R10,OWSTRT              COMPUTE LENGTH CODE\n         L     R12,SLSAV+12            RESTORE R12\n         L     R9,BD9                  GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* BUILDS STORAGE OPERANDS CONTAINING BASE, DISPLACEMENT, AND     *\n* INDEX. ON ENTRY, REG 11 CONTAINS THE BDDD ADDRESS, AND REG 10  *\n* CONTAINS THE INDEX. THE SCHLBL ROUTINE IS CALLED TO CREATE A   *\n* LABEL REFERENCE, IF THE BASE REG IS CURRENT, AND A LABEL EXISTS*\n* IF SCHLBL IS UNSUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM     *\n* DDDD(XXX,RRR) IS CREATED.                                      *\n*                                                                *\n******************************************************************\n*\nBDXADR   EQU   *                       *** FORMAT DDDD(XXX,BBB) OPERAND\n         ST    R9,BDX9                 SAVE RETURN ADDR\n         LTR   R10,R10                 ANY INDEX REG\n         BNZ   BDXSCHL                 YES\n         SR    R0,R0                   CLEAR WORK REG\n         LR    R1,R11                  COPY BDDD ADDRESS\n         SLDL  R0,20                   BASE REG TO R0\n         LTR   R0,R0                   IS BASE REG 0\n         BNZ   BDXSCHL                 NO\n         CLI   TEXT,X'41'              IS IT LA\n         BE    BDXSCHL                 YES\n         SRL   R1,20                   RIGHT JUSTIFY DISPL\n         CH    R1,H16                  REFERENCE TO CVT ADDR\n         BE    BDXCVTR                 YES\n         CH    R1,H76                  REF TO ALTERNATE CVT ADDR\n         BE    BDXCVTR                 YES\n         MVC   COMMENT(13),=C'PSA REFERENCE'\n         B     BDXSCHL                 CONTINUE\nBDXCVTR  MVC   COMMENT(11),=C'CVT ADDRESS'\nBDXSCHL  BAL   R9,SCHLBL               GO SEARCH FOR LABEL\n         B     BDXGLBL                 BRANCH IF FOUND\n         MVC   PADDR2,ADDRVAL     SET UP ADDR 2                     RH\n         LR    R1,R11                  COPY BDDD ADDRESS\n         SLL   R1,20                   SHIFT OUT BASE REG\n         SRL   R1,20                   RIGHT JUSTIFY DISPL\n         SRL   R11,12                  RT JUSTIFY BASE REG\n         CVD   R1,DBLWD                CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(4),DBLWD+5(3)     UNPACK\n         CH    R1,H1000                DISPL < 1000\n         BL    BDXD100                 YES\n         MVC   OPNDWK(4),DBLWD         MOVE 4-DIGIT DISPL\n         LA    R1,OPNDWK+4             TO NEXT POS\n         B     BDXLPN                  CONTINUE\nBDXD100  CH    R1,H100                 DISPL < 100\n         BL    BDXD10                  YES\n         MVC   OPNDWK(3),DBLWD+1       MOVE 3-DIGIT DISPL\n         LA    R1,OPNDWK+3             TO NEXT POS\n         B     BDXLPN                  CONTINUE\nBDXD10   CH    R1,H10                  DISPL < 10\n         BL    BDXD1                   YES\n         MVC   OPNDWK(2),DBLWD+2       MOVE 2-DIGIT DISPL\n         LA    R1,OPNDWK+2             TO NEXT POS\n         B     BDXLPN                  CONTINUE\nBDXD1    MVC   OPNDWK(1),DBLWD+3       MOVE 1-DIGIT DISPL\n         LA    R1,OPNDWK+1             TO NEXT POS\nBDXLPN   LTR   R10,R10                 ANY INDEX REG\n         BNZ   BDXLPNR                 YES\n         LTR   R11,R11                 ANY BASE REG\n         BNZ   PREPB                   YES\n         BCTR  R1,R0                   NO, BACK UP TO RHE\n         B     BDXCE                   CONTINUE\nPREPB    MVC   0(3,R1),=C'(,R'         DELIMITERS\n         LA    R1,1(R1)                STEP OVER 1 BYTE\n         B     BDXCBAS                 CONTINUE\nBDXLPNR  MVC   0(2,R1),=C'(R'          DELIMITERS\n         CVD   R10,DBLWD               CONVERT INDEX REG\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R10,H10                 INDEX REG < 10\n         BL    BDXX1                   YES\n         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT INDEX REG\n         LA    R1,4(R1)                TO NEXT POS\n         B     BDXCMA                  CONTINUE\nBDXX1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT INDEX REG\n         LA    R1,3(R1)                TO NEXT POS\nBDXCMA   LTR   R11,R11                 ANY BASE REG\n         BZ    BDXRPN                  NO\n         MVC   0(2,R1),=C',R'          DELIMITERS\nBDXCBAS  CVD   R11,DBLWD               CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R11,H10                 BASE REG < 10\n         BL    BDXB1                   YES\n         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT BASE REG\n         LA    R1,4(R1)                TO NEXT POS\n         B     BDXRPN                  CONTINUE\nBDXB1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT BASE REG\n         LA    R1,3(R1)                TO NEXT POS\nBDXRPN   MVI   0(R1),C')'              FINAL DELIMITER\nBDXCE    LR    R10,R1                  COPY END ADDR\n         S     R10,OWSTRT              COMPUTE LENGTH CODE\n         L     R9,BDX9                 GET RETURN ADDR\n         BR    R9                      EXIT\n         USING LABELD,R12\nBDXGLBL  MVC   OPNDWK(8),LBLNAME       LABEL ENTRY NAME TO WORK\n         MVC   PADDR2,ADDRVAL     SET UP ADDR 2                     RH\n         LA    R1,OPNDWK+7             @ LAST POSS CHARACTER\nBDXGRHE  CLI   0(R1),C' '              AT RHE\n         BNE   BDXGCKLN                YES\n         BCT   R1,BDXGRHE              LOOP TO RHE\nBDXGCKLN LTR   R10,R10                 ANY INDEX REGISTER\n         BZ    BDXGCMP                 NO\n         MVI   1(R1),C'('              YES, DELIMITER\n         CVD   R10,DBLWD               CONVERT LENGTH\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         OI    DBLWD+1,C'0'            CLEAR SIGN\nBDXG10   CH    R10,H10                 LENGTH < 10\n         BL    BDXG1                   YES\n         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT LENGTH\n         LA    R1,4(R1)                TO NEXT POS\n         B     BDXGRPN                 CONTINUE\nBDXG1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT LENGTH\n         LA    R1,3(R1)                TO NEXT POS\nBDXGRPN  MVI   0(R1),C')'              FINAL DELIMITER\nBDXGCMP  LR    R10,R1                  COPY END ADDRESS\n         S     R10,OWSTRT              COMPUTE LENGTH CODE\n         L     R12,SLSAV+12            RESTORE R12\n         L     R9,BDX9                 GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\nWRTOUT   EQU   *                       WRITE OUTPUT RECORDS\n         L     R1,PUNCHDCB             @ SYSPUNCH DCB\n         MVC   PLABEL(80),WORKREC      SAVE IN PRINT                RH\n*        MVC   PRT(80),WORKREC         SAVE IN PRINT\n         TM    48(R1),X'10'            IS FILE OPEN\n         BZ    CLRWKR                  NO\n         AP    CARDNO,=P'10'           INCREMENT CARD NO\n         UNPK  SEQNBR,CARDNO           UNPACK INTO CARD\n         OI    SEQNBR+7,C'0'           CLEAR SIGN\n         MVC   PSEQ,SEQNBR        PUT SEQUENCE NUMBER IN LISTING    RH\n         PUT   (1),WORKREC             WRITE SOURCE CARD\nCLRWKR   MVC   WORKREC,BLANX           CLEAR OUTPUT RECORD\n         BR    R9                      RETURN\n*\n*\n*\n******************************************************************\n*                                                                *\n* SEARCHES THE BASE REGISTER TABLE TO FIND THE BASE REGISTER     *\n* ASSOCIATED WITH THE BDDD OPERAND ADDRESS PASSED IN REG 11 ON   *\n* ENTRY. IF THE BASE REGISTER GIVEN IS NOT A CURRENT BASE REG    *\n* THE UNSUCCESSFUL RETURN IS MADE TO 4 BYTES PAST THE ADDRESS    *\n* IN REG 9 ON ENTRY. WHEN THE CURRENT BASE REGISTER ENTRY IS FOR *\n* A PROGRAM BASE REG, THE DISPLACEMENT IS ADDED TO THE ASSUMED   *\n* BASE REGISTER VALUE IS ADDED TO THE DISPLACEMENT TO GIVE AN    *\n* OFFSET IN THE PROGRAM. THE LABEL TABLE IS SEARCHED FOR AN ENTRY*\n* WITH THIS OFFSET, AND IF FOUND, IS RETURNED TO THE CALLER. WHEN*\n* THE BASE REGISTER FOUND IS FOR A DSECT, THE DSECT HEADER ENTRY *\n* ADDRESS IS GIVEN IN THE BASE TABLE ENTRY. THE DSECT HEADER HAS *\n* THE ADDRESS OF THE FIELD DEFINITION TABLE FOR THE DSECT. THE   *\n* FIELD DEFINITION TABLE IS SEARCHED FOR AN ENTRY HAVING THE     *\n* DISPLACEMENT IN THE BDDD INSTRUCTION, AND IF FOUND IS PASSED   *\n* BACK TO THE CALLER. IF THE LABEL/FIELD TABLE SEARCHES ARE      *\n* UNSUCCESSFUL, RETURN IS TO 4 BYTES PAST REG 9.                 *\n*                                                                *\n******************************************************************\n*\nSCHLBL   EQU   *                       *** SEARCH FOR LABEL AT BDDD ADD\n*        TM    MORUSG,X'80'            ANY BASES ACTIVE             RH\n*        BZ    4(R9)                   NO, UNSUCCESSFUL EXIT        RH\n         STM   R9,R12,SLSAV            YES, SAVE REGS USED\n         LR    R12,R11                 COPY BDDD ADDRESS\n         SRL   R12,12                  CLEAR WORK REG\n*        LTR   R12,R12                 IS BASE REG ZERO             RH\n*        BZ    SCHNF                   YES, NO LABEL                RH\n         MH    R12,USGLEN              BASE X BASE TBL ENTRY LENG\n         LA    R12,BASES(R12)          @ BASE TBL ENTRY\n         USING USINGD,R12\n*        CLI   USTYPE,0                ENTRY IN USE                 RH\n*        BE    SCHNF                   NO, EXIT                     RH\n         LR    R9,R11                  COPY BDDD ADDRESS\n         SLL   R9,20                   SHIFT OUT BASE\n         SRL   R9,20                   RIGHT JUSTIFY DDD\n         LR    R14,R9                  SAVE DISPLACEMENT            RH\n         TM    MORUSG,X'80'            ANY BASES ACTIVE             RH\n         BZ    SCHNF                   NO, UNSUCCESSFUL EXIT        RH\n         USING USINGD,R12\n         CLI   USTYPE,0                ENTRY IN USE                 RH\n         BE    SCHNF                   NO, EXIT                     RH\n         ICM   R11,7,USVALU            GET BASE REG VALUE\n         LA    R11,0(R11)              CLEAR HI-ORDER\n         CLI   USTYPE,C'P'             PROGRAM BASE REG\n         BE    PGMBASE                 YES\n         DROP  R12\n         LR    R12,R11                 COPY DSECT FIELD TBL ADDRESS\n         USING DSECTD,R12\nCKDSCTND CLM   R9,7,DSOFSET            THIS THE ENTRY\n         BE    SCHFD                   YES\n         CLC   DSOFSET,HIVAL           NO, AT TABLE END\n         BE    SCHNF                   YES, NO LABEL FOUND\n         LA    R12,L'DSECT(R12)        STEP TO NEXT ENTRY\n         B     CKDSCTND                LOOP THRU DSECT FIELDS\nPGMBASE  AR    R9,R11                  COMPUTE OFFSET\n         LR    R14,R9                  SAVE DISPLACEMENT            RH\n         DROP  R12\n         L     R12,LBLTBL              @ LABEL TABLE\n         USING LABELD,R12\nCKENTFD  CLM   R9,7,LBLADR             THIS THE ENTRY\n         BE    SCHFD                   YES\n         LA    R12,L'LABEL(R12)        TO NEXT ENTRY\n         C     R12,CURRLBL             END OF TBL\n         BNL   SCHNF                   YES, NO LABEL\n         B     CKENTFD                 NO, CONTINUE SEARCH\nSCHNF    DS    0H                                                   RH\n         BAL   R10,G10ADDR        CONVERT DISP TO DISPLAY           RH\n         LM    R9,R12,SLSAV            NOT FOUND, RESTORE REGS\n         B     4(R9)                   NOT FOUND RETURN\nSCHFD    DS    0H                                                   RH\n         BAL   R10,G10ADDR        CONVERT DISP TO DISPLAY           RH\n         LM    R9,R11,SLSAV            FOUND RESTORE ALL BUT 12\n         BR    R9                      FOUND RETURN\n         DROP  R12\n*\nG10ADDR  DS    0H                                                   RH\n         ST    R14,DWORD                SAVE ADDRESS 2              RH\n         SR    R14,R14                  CLEAR R14                   RH\n         IC    R14,DWORD+1              R14 = BYTE 2                RH\n         STC   R14,ADDRVAL              STORE IN ADDR               RH\n         IC    R14,DWORD+2              R14 = BYTE 3 OF ADDR        RH\n         STC   R14,ADDRVAL+2            SET UP BYTE 3 OF ADDR       RH\n         SRL   R14,4                    DROP BYTE 3                 RH\n         STC   R14,ADDRVAL+1            SET UP BYTE 2               RH\n         IC    R14,DWORD+3              R14 = BYTE 4                RH\n         STC   R14,ADDRVAL+4            SET UP BYTE 5               RH\n         SRL   R14,4                    DROP BYTE 5                 RH\n         STC   R14,ADDRVAL+3            SET UP BYTE 4               RH\n         MVZ   ADDRVAL+2(3),ADDRVAL+1   ZONE = 0                    RH\n         MVZ   ADDRVAL(1),ADDRVAL+1     ZONE = 0                    RH\n         TR    ADDRVAL(5),OPTRT         TRANSLATE ADDRESS           RH\n         BR    R10                      RETURN TO CALLER            RH\n         SPACE 1                                                    RH\nDWORD    DS    D                                                    RH\nADDRVAL  DS    CL5                                                  RH\n*\n*\n******************************************************************\n*                                                                *\n* PRINT A LINE USING THE SYSPRINT DCB DEFINED IN DISASM PHASE 0. *\n*                                                                *\n******************************************************************\n*\nPRINT    DS    0H                      PRINT ROUTINE                RH\n         AP    STMTCTR,P1               ADD 1 TO STATEMENT COUNTER  RH\n         MVC   PSTMT-2(6),=X'402020202120' EDIT STATEMENT COUNTER   RH\n         ED    PSTMT-2(6),STMTCTR       *                           RH\n         L     R1,PRINTDCB             @ SYSPRINT DCB\n         TM    48(R1),X'10'            IS SYSPRINT OPEN\n         BNO   CLRPRT                  NO\n         PUT   (1),PRTLINE             WRITE PRINT LINE\nCLRPRT   MVC   PRT,BLANX               CLEAR PRINT LINE\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C' '                SINGLE SPACED\n         BE    SETSGL                  YES\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C'0'                DOUBLE SPACED\n         BE    SETSGL                  YES\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C'-'                TRIPLE SPACED\n         BE    SETSGL                  YES\n         ZAP   LINECT,P0               NO, MUST BE NEW PAGE\nSETSGL   MVI   PCC,C' '                SET SINGLE SPACING\n         CP    LINECT,P58              PAST END OF PAGE\n         BH    NEWPAGE                 YES\n         BR    R9                      EXIT\n         SPACE 1                                                    RH\nNEWPAGE  DS    0H                                                   RH\n         MVI   PCC,C'1'                SET SKIP TO HOF\n         ZAP   LINECT,P0               RESET LINE COUNTER\n*        BR    R9                      EXIT                         RH\n         SPACE 3                                                    RH\n********************************************************************RH*\n*                                                                   RH*\n*        ROUTINE TO PRINT HEADING. RETURN ON R9                     RH*\n*                                                                   RH*\n********************************************************************RH*\n         SPACE 2                                                    RH\nL10HEAD  DS    0H                                                   RH\n         AP    PAGECTR,P1         ADD 1 TO PAGE COUNTER             RH\n         L     R1,PRINTDCB             @ SYSPRINT DCB               RH\n         TM    48(R1),X'10'            IS SYSPRINT OPEN             RH\n         BNO   CLRPRT1                 NO                           RH\n         PUT   (1),PRTLINE        SKIP TO NEW PAGE                  RH\n         SPACE 1                                                    RH\n         MVC   PAGENO,=X'40202020'      EDIT PAGE NUMBER            RH\n         ED    PAGENO,PAGECTR           *                           RH\n         MVC   PRT,HEAD1                MOVE HEADING TO PRINT       RH\n         MVI   PCC,C' '           PRINT, SPACE 1                    RH\n         AP    LINECT,P1          ADD 1 TO LINE COUNT               RH\n         L     R1,PRINTDCB             @ SYSPRINT DCB               RH\n         PUT   (1),PRTLINE        PRINT HEADING                     RH\n         MVC   PRT,BLANX          CLEAR PRINT LINE                  RH\n         MVI   PCC,C'0'           SPACE 2 LINES                     RH\n         SPACE 1                                                    RH\nCLRPRT1  DS    0H                                                   RH\n         BR    R9                       RETURN TO CALLER\n*AGECTR  DC    PL2'0'             PAGE COUNTER                      RH\n*TMTCTR  DC    PL3'0'             STATEMENT COUNTER                 RH\n*EQNUM   DC    PL4'0'             SEQUENCE NUMBER                   RH\n*EQINC   DC    P'100'             SEQUENCE INCREMENT                RH\n*\n*\n*\n******************************************************************\n*                                                                *\n* CONVERT HEX DATA TO PRINTABLE FORM: 2 CHARACTERS PER BYTE. ON  *\n* ENTRY, REG 12 CONTAINS THE ADDRESS OF THE LEFT END OF THE FIELD*\n* TO BE CONVERTED, AND THE ENTRY POINT USED DETERMINES THE LENGTH*\n* FORMATTED OUTPUT IS PLACED IN THE PRTABL FIELD.                *\n*                                                                *\n******************************************************************\n*\nHEXPRT   DS    0H                      HEX TO PRINTABLE ROUTINE\nHEXPRT1  UNPK  PRTABL(3),0(2,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT2  UNPK  PRTABL(5),0(3,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT3  UNPK  PRTABL(7),0(4,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT4  UNPK  PRTABL(9),0(5,R12)      UNPACK HEX\nHEXCLTR  MVZ   PRTABL(8),XZROS         CLEAR FOR TRANSLATE\n         TR    PRTABL(8),TRTBL         MAKE PRINTABLE\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* FORMATS THE HEX DATA CORRESPONDING TO THE FORMATTED INSTRUCTION*\n* BEING OUTPUT. PRINTABLE HEX IS PLACED AT THE RIGHT OF THE LINE *\n* ON THE SYSPRINT OUTPUT.                                        *\n*                                                                *\n******************************************************************\n*\nTXTFMT   EQU   *                       *** FORMAT TEXT FOR PRINT ***\n         ST    R9,TX9                  SAVE RETURN ADDR\n         LA    R11,PRT                 @ PRINT LINE\n         CLI   TYPE,1                  ADCON\n         BE    TFOFST                  YES\n         CLI   TYPE,2                  CONSTANT\n         BE    TFOFST                  YES\n         CLI   TYPE,X'0D'              INSTRUCTION\n         BNE   TXTCLEAN                NO\nTFOFST   LA    R12,OFFSET              @ OFFSET TO INSTR\n         BAL   R9,HEXPRT3              CONVERT TO PRINTABLE\n         MVC   PLOCN(6),PRTABL         OFFSET TO PRINT              RH\n*        MVC   PRT+00(6),PRTABL        OFFSET TO PRINT\n*        LA    R12,LEN                 @ DATA LENGTH\n*        BAL   R9,HEXPRT1              MAKE PRINTABLE\n*        MVC   PRT+08(2),PRTABL        LENGTH TO PRINT\n*        LA    R12,TEXT                @ TEXT TO PRINT\n         SPACE 1                                                    RH\n********************************************************************RH\n*                                                                  *RH\n*        ROUTINE TO SET UP OBJECT CODE                             *RH\n*                                                                  *RH\n********************************************************************RH\n         SPACE 2                                                    RH\nH10OBJEC DS    0H                                                   RH\n         LA    R2,TEXT                @ TEXT TO PRINT               RH\n         SR    R14,R14                  CLEAR R14                   RH\n         IC    R14,0(0,R2)              R14 = 1ST BYTE OF OBJ CODE  RH\n         STC   R14,POBJ2+1              SET UP 2ND BYTE             RH\n         SRL   R14,4                    SET UP 1ST BYTE             RH\n         STC   R14,POBJ2                *                           RH\n         MVZ   POBJ2+1(1),POBJ2         ZONE = 0                    RH\n         CLI   LEN,X'01'                INST LTH = 1 ?              RH\n         BE    H60                      YES, 1 BYTE DC              RH\n         SPACE 1                                                    RH\n         IC    R14,1(0,R2)              R14 = 2ND BYTE OF OBJ CODE  RH\n         STC   R14,POBJ2+3              SET UP 4TH BYTE             RH\n         SRL   R14,4                    SET UP 3RD BYTE             RH\n         STC   R14,POBJ2+2              *                           RH\n         MVZ   POBJ2+3(1),POBJ2+2       ZONE = 0                    RH\n         TR    POBJ2,OPTRT              TRANSLATE OBJECT CODE 1 & 2 RH\n         CLI   LEN,X'02'                INST LTH = 2 ?              RH\n         BE    H50                      YES, END OF SET-UP          RH\n         SPACE 1                                                    RH\n         IC    R14,2(0,R2)              R14 = 3RD BYTE OF OBJ CODE  RH\n         STC   R14,POBJ4+1              SET UP 6TH BYTE             RH\n         SRL   R14,4                    SET UP 5TH BYTE             RH\n         STC   R14,POBJ4                *                           RH\n         MVZ   POBJ4+1(1),POBJ4         ZONE = 0                    RH\n         CLI   LEN,X'03'                INST LTH = 3 ?              RH\n         BE    H70                      YES, 3 BYTE DC              RH\n         SPACE 1                                                    RH\n         IC    R14,3(0,R2)              R14 = 4TH BYTE OF OBJ CODE  RH\n         STC   R14,POBJ4+3              SET UP 8TH BYTE             RH\n         SRL   R14,4                    SET UP 7TH BYTE             RH\n         STC   R14,POBJ4+2              *                           RH\n         MVZ   POBJ4+3(1),POBJ4+2       ZONE = 0                    RH\n         TR    POBJ4,OPTRT              TRANSLATE OBJECT CODE 3 & 4 RH\n         CLI   LEN,X'04'                INST LTH = 4 ?              RH\n         BE    H50                      YES, END OF SET-UP          RH\n         SPACE 1                                                    RH\n         IC    R14,4(0,R2)              R14 = 5TH BYTE OF OBJ CODE  RH\n         STC   R14,POBJ6+1              SET UP 10TH BYTE            RH\n         SRL   R14,4                    SET UP  9TH BYTE            RH\n         STC   R14,POBJ6                *                           RH\n         MVZ   POBJ6+1(1),POBJ6         ZONE = 0                    RH\n         SPACE 1                                                    RH\n         IC    R14,5(0,R2)              R14 = 6TH BYTE OF OBJ CODE  RH\n         STC   R14,POBJ6+3              SET UP 12TH BYTE            RH\n         SRL   R14,4                    SET UP 11TH BYTE            RH\n         STC   R14,POBJ6+2              *                           RH\n         MVZ   POBJ6+3(1),POBJ6+2       ZONE = 0                    RH\n         TR    POBJ6,OPTRT              TRANSLATE OBJECT CODE 5 & 6 RH\n         SPACE 1                                                    RH\nH50      DS    0H                       END OF SET-UP               RH\n         CLC   PCODE,=CL5'DC'     IS THIS INST A DC ?               RH\n         BNE   H90                NO, RETURN TO CALLER              RH\n         MVC   POBJ2+4(4),POBJ4   DROP FIRST BLANK                  RH\n         MVC   POBJ2+8(4),POBJ6   DROP 2ND BLANK                    RH\n         MVC   POBJ6+2(2),PCODE+2 CLEAR LAST 2 BYTES                RH\n*                                                                   RH\n*        SINCE WE ARE DOING A DE- COMPILE, DON'T CHANGE             RH\n*        ANY OF THE ACTUAL OBJECT CODE, AS IT REPRESENTS            RH\n*        WHAT  IS REALLY IN THE LOAD  MODULE.....                   RH\n*                                                                   RH\n*        CLI   POPNDS,C'V'        IS IT A VCON?                     RH\n*        BNE   H90                NO                                RH\n*        MVI   POBJ2,C'0'         YES, OBJECT CODE IS ZERO          RH\n*        MVC   POBJ2+1(5),POBJ2     ''                              RH\n*                                                                   RH\n         B     H90                      RETURN TO CALLER            RH\n         SPACE 1                                                    RH\nH60      DS    0H                                                   RH\n         TR    POBJ2(2),OPTRT           TRANSLATE 1 BYTE            RH\n         B     H50                      GET OUT                     RH\n         SPACE 1                                                    RH\nH70      DS    0H                                                   RH\n         TR    POBJ4(2),OPTRT           TRANSLATE 1 BYTE            RH\n         B     H50                      GET OUT                     RH\n         SPACE 1                                                    RH\nOPTRT    DS    0H                                                   RH\n         DC    C'0123456789ABCDEF'                                  RH\n         SPACE 1                                                    RH\n*        BAL   R9,HEXPRT4              CONVERT 1ST 4 BYTES\n*        CLI   LEN,4                   IS IT 4 BYTES\n*        BNL   TXT4                    YES, OR MORE\n*        CLI   LEN,3                   IS IT 3 BYTES\n*        BE    TXT3                    YES\n*        CLI   LEN,2                   IS IT 2 BYTES\n*        BE    TXT2                    YES\n*        MVC   PRT+94(2),PRTABL        TEXT TO PRINT\n*        B     TXTCLEAN                FINISH\n*XT2     MVC   PRT+94(4),PRTABL        TEXT TO PRINT\n*        B     TXTCLEAN                FINISH\n*XT3     MVC   PRT+94(6),PRTABL        TEXT TO PRINT\n*        B     TXTCLEAN                FINISH\n*XT4     MVC   PRT+94(8),PRTABL        TEXT TO PRINT\n*        CLI   LEN,4                   IS IT 4 BYTES\n*        BE    TXTCLEAN                YES, FINISH\n*        LA    R12,TEXT+4              @ TEXT\n*        BAL   R9,HEXPRT4              CONVERT\n*        CLI   LEN,8                   8 BYTES OF TEXT\n*        BNL   TXT8                    YES                          RH\n*        BE    TXT8                    YES\n*        CLI   LEN,7                   7 BYTES OF TEXT\n*        BE    TXT7                    YES\n*        CLI   LEN,6                   6 BYTES OF TEXT\n*        BE    TXT6                    YES\n*        MVC   PRT+98(2),PRTABL        TEXT TO PRINT\n*        B     TXTCLEAN                FINISH\n*XT6     MVC   PRT+102(4),PRTABL       TEXT TO PRINT\n*        B     TXTCLEAN                FINISH\n*XT7     MVC   PRT+102(6),PRTABL       TEXT TO PRINT\n*        B     TXTCLEAN                FINISH\n*XT8     MVC   PRT+102(8),PRTABL       TEXT TO PRINT\n         SPACE 1\nH90      DS    0H\nTXTCLEAN XC    OFFSET,OFFSET           CLEAR\n         L     R9,TX9                  GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* ENTERED WHENEVER THE CURRENT TEXT OFFSET IS PAST THE NEXCHG    *\n* FIELD VALUE. THIS ROUTINE CREATES DROP CARDS FOR EXHAUSTED BASE*\n* REGISTERS, AND USING STATEMENTS FOR NEW BASE REGISTERS. THE    *\n* BASES TABLE IS SCANNED, AND ANY ENTRY WHICH IS NO LONGER IN USE*\n* IS ZEROED OUT, AND A DROP RECORD IS CREATED. NEXT, THE USING   *\n* TABLE IS SCANNED. WHEN AN ENTRY IS FOUND WHICH IS VALID AT THE *\n* CURRENT OFFSET, THE BASE TABLE IS CHECKED. IF THE ENTRY IS NOT *\n* IN USE, A USING STATEMENT IN CREATED, AND THE USING TABLE ENTRY*\n* IS MOVED TO THE BASES TABLE. THE NEXCHG FIELD IS CHANGED TO    *\n* CONTAIN THE OFFSET AT WHICH THE NEXT SCAN MUST BE MADE. AN IND-*\n* ICATOR CALLED MORUSG IS SET TO SHOW WHEN ANY BASE REGISTERS ARE*\n* CURRENTLY IN USE. WHEN NO MORE REGISTERS ARE AVAILABLE, THE    *\n* NEXCHG FIELD IS SET TO HEX FF'S.                               *\n*                                                                *\n******************************************************************\n*\nNEXUSG   EQU   *                       *** GET NEXT BASE REG SET ***\n         MVC   NEXCHG,HIVAL            RESET NEXT CHANGE ADDR\n         MVI   MORUSG,0                CLEAR BASE REG AVAIL INDIC\n         ST    R9,USG9                 SAVE RETURN ADDR\n*        XC    BASES(L'USING),BASES    CLEAR R0 ELEMENT\n         MVC   BASES+16*L'USING(4),HIVAL SET TABLE STOPPER\n         USING USINGD,R2\n         LA    R2,BASES                @ R0'S ELEMENT\n*        LA    R2,BASES+L'USING        @ R1'S ELEMENT\nDRPCKND  CLI   0(R2),X'FF'             END OF TABLE\n         BE    USGUSG                  YES\n         CLC   USEND,XZROS             ENTRY USED\n         BE    DRPSTEP                 NO\n         CLC   TXTOFSET,USEND          PAST END OF THIS ONE\n         BL    DRPSTEP                 NO\n         MVC   MNEMONIC(4),=C'DROP'    OPERATION IS DROP\n         MVI   OPNDS,C'R'              DELIMITER FOR REGS\n         SR    R12,R12                 CLEAR WORK\n         IC    R12,USREG               GET REG\n         CVD   R12,DBLWD               CONVERT TO PACKED\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         OI    DBLWD+1,C'0'            CLEAR SIGN\n         CH    R12,H10                 REG < 10\n         BL    DPR1                    YES\n         MVC   OPNDS+1(2),DBLWD        MOVE REG NBR\n         B     WRTDROP                 GO WRITE DROP\nDPR1     MVC   OPNDS+1(1),DBLWD+1      MOVE 1-DIGIT REG\nWRTDROP  BAL   R9,WRTOUT               WRITE DROP RECORD\n         BAL   R9,PRINT                PRINT DROP RECORD\n         XC    USING,USING             CLEAR THE ENTRY\nDRPSTEP  LA    R2,L'USING(R2)          TO NEXT BASE ELEMENT\n         B     DRPCKND                 LOOP\nUSGUSG   L     R2,USGSTRT              GET FIRST USING TBL ADDR\nENDUS    CLI   0(R2),X'FF'             END OF TABLE\n         BE    XITUS                   YES\n         CLC   TXTOFSET,USEND          PAST END OF THIS ONE\n         BNL   ECSTEP                  YES\n         OI    MORUSG,1                SHOW MORE BASES AVAIL\nUSBGCK   CLC   TXTOFSET,USBGN          CURR LOC BEFORE THIS\n         BNL   CKNEWLO                 NO\n         CLC   USBGN,NEXCHG            BEGINS BEFORE NEXT CHANGE\n         BNL   ECSTEP                  NO\n         MVC   NEXCHG,USBGN            YES, SET LOWER CHANGE OFFSET\n         B     ECSTEP                  CONTINUE\nCKNEWLO  CLC   USEND,NEXCHG            THIS ENTRY ENDS EARLIER\n         BNL   ECMVC                   NO\n         MVC   NEXCHG,USEND            YES, SET NEW END\nECMVC    SR    R1,R1                   CLEAR WORK\n         IC    R1,USREG                PICK UP REG\n         MH    R1,USGLEN               TIMES ENTRY LENGTH\n         LA    R1,BASES(R1)            @ BASE TABLE ENTRY\n         OI    MORUSG,X'80'            SHOW BASE IN USE\n         CLC   USING,0(R1)             OLD AND NEW IDENTICAL\n         BE    ECSTEP                  YES\nMAKUSG   MVC   0(L'USING,R1),USING     NEW USING TO TABLE\n         MVC   MNEMONIC(5),=C'USING'   OPERATION IS USING\n         CLI   USTYPE,C'D'             IS IT A DSECT\n         BNE   CKUTPS                  NO\n         ICM   R12,7,USVALU            YES, GET DSECT HEADER ADDR\n         L     R11,DTBSTRT             @ 1ST DSECT HEADER ENTRY\nDSCTEND  C     R11,DTBCUR              END OF TABLE\n         BH    MVDSNAME                YES\n         CLM   R12,7,8(11)             THIS THE HEADER ENTRY\n         BNE   DSCTSTEP                NO\n         LR    R12,R11                 YES, COPY IT'S ADDRESS\n         B     MVDSNAME                CONTINUE\nDSCTSTEP LA    R11,11(R11)             TO NEXT HEADER ENTRY\n         B     DSCTEND                 LOOP THRU TABLE\nMVDSNAME MVC   OPNDS(8),0(R12)         DSECT NAME TO OPERANDS\n         LA    R12,OPNDS+7             TO END OF NAME\nUSFRHED  CLI   0(R12),C' '             FOUND RHE\n         BNE   USFMADD                 YES\n         BCT   R12,USFRHED             BACK UP 1 AND LOOP\nUSFMADD  LA    R12,1(R12)              TO NEXT BYTE\nUSFMCMA  MVC   0(2,R12),=C',R'         DELIMITERS\n         SR    R11,R11                 CLEAR WORK\n         IC    R11,USREG               GET REGISTER NBR\n         CVD   R11,DBLWD               CONVERT TO PACKED\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK REG NBR\n         OI    DBLWD+1,C'0'            CLEAR SIGN\n         CH    R11,H10                 REG < 10\n         BL    USFMR1                  YES\n         MVC   2(2,R12),DBLWD          MOVE 2-DIGIT REG NBR\n         B     USINGOUT                GO WRITE USING\nUSFMR1   MVC   2(1,R12),DBLWD+1        MOVE 1-DIGIT REG NBR\nUSINGOUT BAL   R9,WRTOUT               WRITE USING STMT\n         BAL   R9,PRINT                PRINT USING STMT\n         B     ECSTEP                  CONTINUE\nCKUTPS   CLC   USVALU,TXTOFSET         USING AT CURR LOC\n         BNE   USFMLBL                 NO\n         MVI   OPNDS,C'*'              SET CURRENT LOC SYMBOL IN OPERAN\n         LA    R12,OPNDS+1             GET NEXT POS ADDR\n         B     USFMCMA                 GO FORMAT REG\nUSFMLBL  MVI   OPNDS,C'A'              SET 1ST CHAR OF LABEL NAME\n         LA    R12,USVALU              GET OFFSET\n         BAL   R9,HEXPRT3              CONVERT TO PRINTABLE\n         MVC   OPNDS+1(6),PRTABL       PRINTABLE HEX TO LABEL\n         LA    R12,OPNDS+7             TO NEXT LOC\n         B     USFMCMA                 FORMAT REG\nECSTEP   LA    R2,L'USING(R2)          TO NEXT USING ENTRY\n         B     ENDUS                   CONTINUE SCAN\nXITUS    L     R9,USG9                 GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* END OF PHASE 2 - RETURN TO PHASE 0                             *\n*                                                                *\n******************************************************************\n*\nEOJ      EQU   *                       END OF JOB\n         BAL   R9,FORCONST             YES, FORCE IT OUT\n         L     R13,4(R13)              GET POINTER TO CALLER'S SAVE ARE\n         LM    R14,R12,12(R13)         RESTORE CALLER'S REGS\n         SR    R15,R15                 CLEAR RETURN CODE\n         BR    R14                     RETURN TO CALLER\n*\n*\n*                 *** DATA AND WORK AREAS ***\n*\n*\nDCINST   DC    C' '               = D IF PREV INST WAS A DC         RH\nSVCTBLAD DC    A(SVCOP)                @ SVC TABLE\nDBLOPAD  DC    A(DBLOP)                @ TWO-BYTE OP-CODE TBL\nOWSTRT   DC    A(OPNDWK)               @ OPERAND WORK AREA\nOPND9    DC    A(OPNDRTN)              RETURN ADDR FOR OPERAND ROUTINES\nUSG12    DS    2F                      REG SAVE AREA\nUSG9     DS    F                       RETURN SAVE\nEQU9     DS    F                       RETURN ADDR FOR EQUSTMT\nFC6      DS    F                       SAVE AREA FOR R6\nFC9      DS    F                       FORCONST RETURN ADDR\nTX9      DS    F                       RETURN ADDR FOR TXTFMT\nBD9      DS    F                       RETURN FOR BDADR\nBDX9     DS    F                       RETURN FOR BDXADR\nBDL9     DS    F                       RETURN FOR BDLADR\nSLSAV    DS    4F                      SAVE FOR SCHLBL\nSGOPLEN DC AL2(L'SGLOP) SINGLE BYTE OP COD TBL LEN                   */\nILENG    DC    H'0'                    INSTRUCTION LENGTH  FIX***\nCONPROG  DC    X'00'                   CONSTANT IN PROGRESS INDIC\nCONPSLBL DS    0CL13                   PSEUDO LABEL ENTRY FOR CONSTANTS\n         DS    XL4\nCONNAME  DS    CL8                     CONSTANT NAME\nCONLLEN  DS    XL1                     LABEL LENGTH\nCONTYPE  DS    CL1                     TYPE\n         DS    0H\nCONDATA  DS    XL50                    CONSTANT DATA                RH\n*ONDATA  DS    XL8                     CONSTANT DATA\nCONSYM   DS    CL8                     CONSTANT SYMBOL\nCONLEN   DS    H                       CONSTANT LENGTH\nCONDUP   DS    H                  DUPLICATION COUNTER               RH\nCONOFST  DS    F                       RELATIVE OFFSET TO CONSTANT\nCONLOC   DS    F                       @ CURRENT BYTE IN CONSTANT\nCCTYPE   DC    X'00'                   CC SET TYPE OF INSTR SETTING\nTXTOFST  DS    0F\n         DS    X\nTXTOFSET DS    XL3                     OFFSET TO TEXT BYTE\nOPNDWK   DS    CL13                    OPERAND BUILD AREA\nOFFSET   DS    XL3                     OFFSET FROM PGM START\nINSTYP   DS    CL1                     INSTRUCTION TYPE\nTYPE     DS    XL1                     TYPE CODE\n*                                       0=CSECT, 1=ADCON, 2=CONST\n*                                       E=USING, D=INSTRUCTION\n*                                       C=COMMENT, 9=ENTRY\n*                                       A=EQU\nLEN      DS    XL1                     TEXT LENGTH\nTEXT     DS    XL50                    TEXT                         RH\n*EXT     DS    XL8                     TEXT\nLBLOFSET DC    X'00'              EQU+1 LABEL NEEDED IF X'FF'       RH\nH1       DC    H'1'                    CONSTANT 1\nH2       DC    H'2'                    CONSTANT 2\nH4       DC    H'4'                    CONSTANT 4\nH7       DC    H'7'                    CONSTANT 7\nH8       DC    H'8'                    CONSTANT 8\nH10      DC    H'10'                   CONSTANT 10\nH11      DC    H'11'                   CONSTANT 11\nH13      DC    H'13'                   CONSTANT 13\nH14      DC    H'14'                   CONSTANT 14\nH16      DC    H'16'                   CONSTANT 16\nH76      DC    H'76'                   CONSTANT 76\nH100     DC    H'100'                  CONSTANT 100\nH1000    DC    H'1000'                 CONSTANT 1000\nP0       DC    P'0'                    CONSTANT 0\nP1       DC    P'1'                    CONSTANT 1\nP58      DC    P'58'                   CONSTANT 58\nMAXCON   DC    H'50'                   MAX CONSTANT LTH             RH\nBLANX    DC    CL133' '                CONSTANT BLANKS              RH\n*LANX    DC    CL121' '                CONSTANT BLANKS\nXZROS    DC    16X'00'                 CONSTANT ZEROS\nHIVAL    DC    4X'FF'                  CONSTANT X F'S\nNEXCHG   DC    XL3'00'                 OFFSET TO NEXT BASE REG CHG\n         DS    0H                 ALIGN ON HALFWORD BOUNDARY        RH\nUSGLEN   DC    AL2(L'USING)       LENGTH OF USING TBL ENTRIES\nMORUSG   DC    X'00'                   0=NO MORE BASES, 80=MORE BASES A\nTRTBL    DC    C'0123456789ABCDEF'     TRANSLATE TBL\nPRTABL   DS    CL9                     PRINTABLE HEX WORK\nBASES    DC    XL256'00'               BASE REG TABLE\n*        TRT TABLE FOR CHAR/HEX DETERMINATION\n*        00 FOR VALID CHARACTERS, FF FOR HEX VALUES\n*\n*                 0 1 2 3 4 5 6 7 8 9 A B C D E F\nCHARTRAN DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 0\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 1\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 2\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 3\n         DC    X'00FFFFFFFFFFFFFFFFFFFF00FFFFFFFF' 4   BLANK AND DOT\n         DC    X'FFFFFFFFFFFFFFFFFFFFFF00FFFFFFFF' 5   $\n         DC    X'0000FFFFFFFFFFFFFFFFFFFFFF00FFFF' 6   /, -, AND _\n         DC    X'FFFFFFFFFFFFFFFFFFFFFF0000FFFFFF' 7   # AND @\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 8\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 9\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' A\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' B\n         DC    X'FF000000000000000000FFFFFFFFFFFF' C   A-I\n         DC    X'FF000000000000000000FFFFFFFFFFFF' D   J-R\n         DC    X'FFFF0000000000000000FFFFFFFFFFFF' E   S-Z\n         DC    X'00000000000000000000FFFFFFFFFFFF' F   0-9\n*                 0 1 2 3 4 5 6 7 8 9 A B C D E F\n         ORG   CHARTRAN+C' '                                        RH\n         DC    X'00'                   BLANK IS CHARACTER           RH\n         ORG   CHARTRAN+C'A'                                        RH\n         DC    9X'00'                  A-I ARE CHARACTERS           RH\n         ORG   CHARTRAN+C'J'                                        RH\n         DC    9X'00'                  J-R ARE CHARACTERS           RH\n         ORG   CHARTRAN+C'S'                                        RH\n         DC    8X'00'                  S-Z ARE CHARACTERS           RH\n         ORG   CHARTRAN+C'0'                                        RH\n         DC    10X'00'                 0-9 ARE CHARACTERS           RH\n         ORG   ,                                                    RH\n*                                                                   RH\nHEXTRAN  DC    256X'FF'        TRT TABLE FOR CHAR/HEX DETERMINATION RH\n         ORG   HEXTRAN+C' '                                         RH\n         DC    X'00'                   BLANK IS CHARACTER           RH\n         ORG   HEXTRAN+74                                           RH\n         DC    7X'00'             \u00a2.<(+|&                           RH\n         ORG   HEXTRAN+90                                           RH\n         DC    8X'00'             !$*);\u00ac-/                          RH\n         ORG   HEXTRAN+106                                          RH\n         DC    6X'00'             |,%_>?                            RH\n         ORG   HEXTRAN+121                                          RH\n         DC    7X'00'             ':#@'=\"                           RH\n         ORG   HEXTRAN+C'A'                                         RH\n         DC    9X'00'                  A-I ARE CHARACTERS           RH\n         ORG   HEXTRAN+C'J'                                         RH\n         DC    9X'00'                  J-R ARE CHARACTERS           RH\n         ORG   HEXTRAN+C'S'                                         RH\n         DC    8X'00'                  S-Z ARE CHARACTERS           RH\n         ORG   HEXTRAN+C'0'                                         RH\n         DC    10X'00'                 0-9 ARE CHARACTERS           RH\n         ORG   ,                                                    RH\nHEAD1    DS    0CL132                                               RH\n         DC    C'   LOC  OBJECT CODE    ADDR1 ADDR2  STMT'          RH\n         DC    C'    SOURCE STATEMENT'                              RH\n         DC    CL17' '                                              RH\n         DC    C'CHARACTER REP'                                     RH\n         DC    CL20' '                                              RH\n         DC    C'PAGE'                                              RH\nPAGENO   DS    CL4                                                  RH\n         DC    CL14' '                                              RH\n         LTORG                                                      RH\n*                                                                   RH\n*                                                                   RH\n*                                                                   RH\n         COPY  DISASM3A                COPY INSTRUCTION TABLES\n         COPY  DISASM3B                COPY SVC TABLE\n*                                                                   RH\n*                                                                   RH\n*                                                                   RH\n*                                                                   RH\n         PRINT GEN                                                  RH\n         DISASPRM DSECT=YES            COMMON AREAS                 RH\n         END\n/*\n//\n//*            END IF JUST WANT OBJECT MODULE\n//*\n//LKED.SYSLMOD  DD DISP=SHR,DSN=HALL.LOAD\n//LKED.SYSIN DD *\n     SETCODE AC(0)\n     NAME DISASM2(R)\n//\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DISASM3A": {"ttr": 11018, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x00\\x8f\\x00\\x99\\x00\\x8f\\x13\\x17\\x01\\xa2\\x01\\xa2\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-01-08T00:00:00", "modifydate": "1999-01-08T13:17:00", "lines": 418, "newlines": 418, "modlines": 0, "user": "RH87944"}, "text": "         EJECT\n***********************************************************************\n*                                                                     *\n* INSTRUCTION DISASSEMBLY TABLES. THESE TABLES DEFINE VALID           *\n* INSTRUCTION OP-CODES, AND GIVE MNEMONICS, FORMAT-TYPES,             *\n* AND AN INDICATOR TO SHOW CONDITION SETTING INSTRUCTIONS,            *\n* PRIVILEGED INSTRUCTIONS, AND FLOATING POINT INSTRUCTIONS.           *\n*                                                                     *\n***********************************************************************\nINSTENT  DS    0CL10                   CURRENT INSTRUCTION ENTRY\nINAME    DS    CL5                   * INSTR NAME (MNEMONIC)\nITYPE    DS    XL1                   * INSTRUCTION TYPE\nRR       EQU   0                       RR FORMAT\nRX       EQU   4                       RX FORMAT\nS        EQU   8                       S FORMAT\nSI       EQU   12                      SI FORMAT\nRS       EQU   16                      RS FORMAT\nSS1      EQU   20                      SS FORMAT, SINGLE LENGTH\nSS2      EQU   24                      SS FORMAT, 2 LENGTHS\nTWO      EQU   28                      TWO BYTE OP-CODE\nCONDBR   EQU   32                      CONDITIONAL BRANCH\nSVC      EQU   36                      SUPERVISOR CALL\nSSE      EQU   40                      SS EXTENDED FORMAT\nE        EQU   44                      E FORMAT\nRRE1     EQU   48                      RR EXTENDED FORMAT, 1 OPERAND\nRRE2     EQU   52                      RR EXTENDED FORMAT, 2 OPERANDS\nICLASS   DS    XL1                   * INSTRUCTION CLASS\nPRIV     EQU   2                       PRIVILEGED INSTRUCTION\nFLTPT    EQU   4                       FLOATING POINT INSTRUCTION\nFLSHT    EQU   5                       SHORT PREC FLT PT INSTR\nIEDT     DS    XL1                   * INSTRUCTION EDITS\nEPR      EQU   X'40'                   EVEN-ODD REGISTER PAIR\nE2       EQU   X'20'                   2ND OPND ON HALFWORD BOUND\nE4       EQU   X'10'                   2ND OPND ON FULLWORD BOUND\nE8       EQU   X'08'                   2ND OPND ON DBL WORD BOUND\nM1       EQU   X'04'                   SPECIAL MOVE TYPE\nS1       EQU   X'02'                   1ST OPND MUST HAVE BASE/INDEX\nS2       EQU   X'01'                   2ND OPND MUST HAVE BASE\nICCSET   DS    XL1                   * TYPE CONDITION CODE SET\nARITH    EQU   X'80'                   ARITHMETIC TYPE\nCPR      EQU   X'40'                   COMPARE TYPE\nZRO8     EQU   X'20'                   BC 8 MAY BE BZ\nINLNG    DS    XL1                     INSTRUCTION LENGTH\n*\n         EJECT\n***********************************************************************\n* THESE ARE THE INSTRUCTION OP CODE AND SVC TABLES COPIED INTO        *\n* DISASM1 AND DISASM2. THEY HAVE BEEN UPDATED TO XA LEVELS.           *\n* NON XA INSTRUCTIONS STILL APPEAR IN THE TABLES.                     *\n* PARTIALLY UPDATED FOR SORTING AND VECTOR INSTRUCTION FORMATS.       *\n***********************************************************************\nSGLOP    DS    0CL10                   SINGLE BYTE OP-CODE TABLE\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'02' NOT INSTR 00\n         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04'          01\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'02' NOT INSTR 02\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'02' NOT INSTR 03\n         DC    CL5'SPM',AL1(RR),AL1(0),AL1(0),AL1(0),X'02'         04\n         DC    CL5'BALR',AL1(RR),AL1(0),AL1(0),AL1(0),X'02'        05\n         DC    CL5'BCTR',AL1(RR),AL1(0),AL1(0),AL1(0),X'02'        06\n         DC    CL5'BCR',AL1(CONDBR),AL1(0),AL1(0),AL1(0),X'02'     07\n         DC    CL5'SSK',AL1(RR),AL1(PRIV),AL1(0),AL1(0),X'02'  \u00acXA 08\n         DC    CL5'ISK',AL1(RR),AL1(PRIV),AL1(0),AL1(0),X'02'  \u00acXA 09\n         DC    CL5'SVC',AL1(SVC),AL1(0),AL1(0),AL1(0),X'02'        0A\n         DC    CL5'BSM',AL1(RR),AL1(0),AL1(0),AL1(0),X'02'      XA 0B\n         DC    CL5'BASSM',AL1(RR),AL1(0),AL1(0),AL1(0),X'02'    XA 0C\n         DC    CL5'BASR',AL1(RR),AL1(0),AL1(0),AL1(0),X'02'     XA 0D\n         DC    CL5'MVCL',AL1(RR),AL1(0),AL1(EPR),AL1(0),X'02'      0E\n         DC    CL5'CLCL',AL1(RR),AL1(0),AL1(EPR),AL1(0),X'02'      0F\n         DC    CL5'LPR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02'     10\n         DC    CL5'LNR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02'     11\n         DC    CL5'LTR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02'     12\n         DC    CL5'LCR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02'     13\n         DC    CL5'NR',AL1(RR),AL1(0),AL1(0),AL1(ZRO8),X'02'       14\n         DC    CL5'CLR',AL1(RR),AL1(0),AL1(0),AL1(CPR),X'02'       15\n         DC    CL5'OR',AL1(RR),AL1(0),AL1(0),AL1(ZRO8),X'02'       16\n         DC    CL5'XR',AL1(RR),AL1(0),AL1(0),AL1(ZRO8),X'02'       17\n         DC    CL5'LR',AL1(RR),AL1(0),AL1(0),AL1(0),X'02'          18\n         DC    CL5'CR',AL1(RR),AL1(0),AL1(0),AL1(CPR),X'02'        19\n         DC    CL5'AR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02'      1A\n         DC    CL5'SR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02'      1B\n         DC    CL5'MR',AL1(RR),AL1(0),AL1(EPR),AL1(0),X'02'        1C\n         DC    CL5'DR',AL1(RR),AL1(0),AL1(EPR),AL1(0),X'02'        1D\n         DC    CL5'ALR',AL1(RR),AL1(0),AL1(0),AL1(0),X'02'         1E\n         DC    CL5'SLR',AL1(RR),AL1(0),AL1(0),AL1(0),X'02'         1F\n         DC    CL5'LPDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 20\n         DC    CL5'LNDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 21\n         DC    CL5'LTDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 22\n         DC    CL5'LCDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 23\n         DC    CL5'HDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02'     24\n         DC    CL5'LRDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02'    25\n         DC    CL5'MXR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02'     26\n         DC    CL5'MXDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02'    27\n         DC    CL5'LDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02'     28\n         DC    CL5'CDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(CPR),X'02'   29\n         DC    CL5'ADR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 2A\n         DC    CL5'SDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 2B\n         DC    CL5'MDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02'     2C\n         DC    CL5'DDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02'     2D\n         DC    CL5'AWR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 2E\n         DC    CL5'SWR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 2F\n         DC    CL5'LPER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 30\n         DC    CL5'LNER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 31\n         DC    CL5'LTER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 32\n         DC    CL5'LCER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 33\n         DC    CL5'HER',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02'     34\n         DC    CL5'LRER',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02'    35\n         DC    CL5'AXR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 36\n         DC    CL5'SXR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 37\n         DC    CL5'LER',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02'     38\n         DC    CL5'CER',AL1(RR),AL1(FLTPT),AL1(0),AL1(CPR),X'02'   39\n         DC    CL5'AER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 3A\n         DC    CL5'SER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 3B\n         DC    CL5'MER',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02'     3C\n         DC    CL5'DER',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02'     3D\n         DC    CL5'AUR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 3E\n         DC    CL5'SUR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 3F\n         DC    CL5'STH',AL1(RX),AL1(0),AL1(E2+S2),AL1(0),X'04'     40\n         DC    CL5'LA',AL1(RX),AL1(0),AL1(0),AL1(0),X'04'          41\n         DC    CL5'STC',AL1(RX),AL1(0),AL1(S2),AL1(0),X'04'        42\n         DC    CL5'IC',AL1(RX),AL1(0),AL1(0),AL1(0),X'04'          43\n         DC    CL5'EX',AL1(RX),AL1(0),AL1(E2+S2),AL1(0),X'04'      44\n         DC    CL5'BAL',AL1(RX),AL1(0),AL1(E2),AL1(0),X'04'        45\n         DC    CL5'BCT',AL1(RX),AL1(0),AL1(E2+S2),AL1(0),X'04'     46\n         DC    CL5'BC',AL1(CONDBR),AL1(0),AL1(E2),AL1(0),X'04'     47\n         DC    CL5'LH',AL1(RX),AL1(0),AL1(E2),AL1(0),X'04'         48\n         DC    CL5'CH',AL1(RX),AL1(0),AL1(E2),AL1(CPR),X'04'       49\n         DC    CL5'AH',AL1(RX),AL1(0),AL1(E2),AL1(ARITH),X'04'     4A\n         DC    CL5'SH',AL1(RX),AL1(0),AL1(E2),AL1(ARITH),X'04'     4B\n         DC    CL5'MH',AL1(RX),AL1(0),AL1(E2),AL1(0),X'04'         4C\n         DC    CL5'BAS',AL1(RX),AL1(0),AL1(0),AL1(0),X'04'      XA 4D\n         DC    CL5'CVD',AL1(RX),AL1(0),AL1(E8+S2),AL1(0),X'04'     4E\n         DC    CL5'CVB',AL1(RX),AL1(0),AL1(E8),AL1(0),X'04'        4F\n         DC    CL5'ST',AL1(RX),AL1(0),AL1(E4+S2),AL1(0),X'04'      50\n         DC    CL5'LAE',AL1(RS),AL1(0),AL1(0),AL1(0),X'04'         51\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR 52\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR 53\n         DC    CL5'N',AL1(RX),AL1(0),AL1(E4),AL1(ZRO8),X'04'       54\n         DC    CL5'CL',AL1(RX),AL1(0),AL1(E4),AL1(CPR),X'04'       55\n         DC    CL5'O',AL1(RX),AL1(0),AL1(E4),AL1(ZRO8),X'04'       56\n         DC    CL5'X',AL1(RX),AL1(0),AL1(E4),AL1(ZRO8),X'04'       57\n         DC    CL5'L',AL1(RX),AL1(0),AL1(E4),AL1(0),X'04'          58\n         DC    CL5'C',AL1(RX),AL1(0),AL1(E4),AL1(CPR),X'04'        59\n         DC    CL5'A',AL1(RX),AL1(0),AL1(E4),AL1(ARITH),X'04'      5A\n         DC    CL5'S',AL1(RX),AL1(0),AL1(E4),AL1(ARITH),X'04'      5B\n         DC    CL5'M',AL1(RX),AL1(0),AL1(E4+EPR),AL1(0),X'04'      5C\n         DC    CL5'D',AL1(RX),AL1(0),AL1(E4+EPR),AL1(0),X'04'      5D\n         DC    CL5'AL',AL1(RX),AL1(0),AL1(E4),AL1(0),X'04'         5E\n         DC    CL5'SL',AL1(RX),AL1(0),AL1(E4),AL1(0),X'04'         5F\n         DC    CL5'STD',AL1(RX),AL1(FLTPT),AL1(0),AL1(0),X'04'     60\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR 61\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR 62\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR 63\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR 64\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR 65\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR 66\n         DC    CL5'MXD',AL1(RX),AL1(FLTPT),AL1(0),AL1(0),X'04'     67\n         DC    CL5'LD',AL1(RX),AL1(FLTPT),AL1(0),AL1(0),X'04'      68\n         DC    CL5'CD',AL1(RX),AL1(FLTPT),AL1(0),AL1(CPR),X'04'    69\n         DC    CL5'AD',AL1(RX),AL1(FLTPT),AL1(0),AL1(ARITH),X'04'  6A\n         DC    CL5'SD',AL1(RX),AL1(FLTPT),AL1(0),AL1(ARITH),X'04'  6B\n         DC    CL5'MD',AL1(RX),AL1(FLTPT),AL1(0),AL1(0),X'04'      6C\n         DC    CL5'DD',AL1(RX),AL1(FLTPT),AL1(0),AL1(0),X'04'      6D\n         DC    CL5'AW',AL1(RX),AL1(FLTPT),AL1(0),AL1(ARITH),X'04'  6E\n         DC    CL5'SW',AL1(RX),AL1(FLTPT),AL1(0),AL1(ARITH),X'04'  6F\n         DC    CL5'STE',AL1(RX),AL1(FLSHT),AL1(0),AL1(0),X'04'     70\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR 71\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR 72\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR 73\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR 74\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR 75\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR 76\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR 77\n         DC    CL5'LE',AL1(RX),AL1(FLSHT),AL1(0),AL1(0),X'04'      78\n         DC    CL5'CE',AL1(RX),AL1(FLSHT),AL1(0),AL1(CPR),X'04'    79\n         DC    CL5'AE',AL1(RX),AL1(FLSHT),AL1(0),AL1(ARITH),X'04'  7A\n         DC    CL5'SE',AL1(RX),AL1(FLSHT),AL1(0),AL1(ARITH),X'04'  7B\n         DC    CL5'ME',AL1(RX),AL1(FLSHT),AL1(0),AL1(0),X'04'      7C\n         DC    CL5'DE',AL1(RX),AL1(FLSHT),AL1(0),AL1(0),X'04'      7D\n         DC    CL5'AU',AL1(RX),AL1(FLSHT),AL1(0),AL1(ARITH),X'04'  7E\n         DC    CL5'SU',AL1(RX),AL1(FLSHT),AL1(0),AL1(ARITH),X'04'  7F\n         DC    CL5'SSM',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'       80\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR 81\n         DC    CL5'LPSW',AL1(S),AL1(PRIV),AL1(E8),AL1(0),X'04'     82\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' DIAGNOSE  83\n         DC    CL5'WRD',AL1(SI),AL1(PRIV),AL1(0),AL1(0),X'04'  \u00acXA 84\n         DC    CL5'RDD',AL1(SI),AL1(PRIV),AL1(0),AL1(0),X'04'  \u00acXA 85\n         DC    CL5'BXH',AL1(RS),AL1(0),AL1(E2+S2),AL1(0),X'04'     86\n         DC    CL5'BXLE',AL1(RS),AL1(0),AL1(E2+S2),AL1(0),X'04'    87\n         DC    CL5'SRL',AL1(RS),AL1(0),AL1(0),AL1(ARITH),X'04'     88\n         DC    CL5'SLL',AL1(RS),AL1(0),AL1(0),AL1(ARITH),X'04'     89\n         DC    CL5'SRA',AL1(RS),AL1(0),AL1(0),AL1(ARITH),X'04'     8A\n         DC    CL5'SLA',AL1(RS),AL1(0),AL1(0),AL1(ARITH),X'04'     8B\n         DC    CL5'SRDL',AL1(RS),AL1(0),AL1(EPR),AL1(ARITH),X'04'  8C\n         DC    CL5'SLDL',AL1(RS),AL1(0),AL1(EPR),AL1(ARITH),X'04'  8D\n         DC    CL5'SRDA',AL1(RS),AL1(0),AL1(EPR),AL1(ARITH),X'04'  8E\n         DC    CL5'SLDA',AL1(RS),AL1(0),AL1(EPR),AL1(ARITH),X'04'  8F\n         DC    CL5'STM',AL1(RS),AL1(0),AL1(E4+S2),AL1(0),X'04'     90\n         DC    CL5'TM',AL1(SI),AL1(0),AL1(0),AL1(ARITH),X'04'      91\n         DC    CL5'MVI',AL1(SI),AL1(0),AL1(S2),AL1(0),X'04'        92\n         DC    CL5'TS',AL1(S),AL1(0),AL1(0),AL1(0),X'04'           93\n         DC    CL5'NI',AL1(SI),AL1(0),AL1(0),AL1(ZRO8),X'04'       94\n         DC    CL5'CLI',AL1(SI),AL1(0),AL1(0),AL1(CPR),X'04'       95\n         DC    CL5'OI',AL1(SI),AL1(0),AL1(0),AL1(ZRO8),X'04'       96\n         DC    CL5'XI',AL1(SI),AL1(0),AL1(0),AL1(ZRO8),X'04'       97\n         DC    CL5'LM',AL1(RS),AL1(0),AL1(E4),AL1(0),X'04'         98\n*        DC    CL5'TRACE',AL1(RS),AL1(0),AL1(0),AL1(0),X'04'  - XA 99\n         DC    CL5'TRACE',AL1(RS),AL1(PRIV),AL1(E2+S2),AL1(0),X'04' RH\n         DC    CL5'LAM',AL1(RS),AL1(0),AL1(0),AL1(0),X'04'   - ESA 9A\n         DC    CL5'STAM',AL1(RS),AL1(0),AL1(0),AL1(0),X'04'  - ESA 9B\n         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04'          9C\n         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04'          9D\n         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04'          9E\n         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04'          9F\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR A0\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR A1\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR A2\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR A3\n         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04'          A4\n         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04'          A5\n         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04'          A6\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR A7\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR A8\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR A9\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR AA\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR AB\n         DC    CL5'STNSM',AL1(SI),AL1(PRIV),AL1(0),AL1(0),X'04'    AC\n         DC    CL5'STOSM',AL1(SI),AL1(PRIV),AL1(0),AL1(0),X'04'    AD\n         DC    CL5'SIGP',AL1(RS),AL1(PRIV),AL1(0),AL1(0),X'04'     AE\n         DC    CL5'MC',AL1(SI),AL1(0),AL1(0),AL1(0),X'04'          AF\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR B0\n         DC    CL5'LRA',AL1(RX),AL1(PRIV),AL1(0),AL1(0),X'04'      B1\n         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04'          B2\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR B3\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR B4\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR B5\n         DC    CL5'STCTL',AL1(RS),AL1(PRIV),AL1(0),AL1(0),X'04'    B6\n         DC    CL5'LCTL',AL1(RS),AL1(PRIV),AL1(E4),AL1(0),X'04'    B7\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR B8\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR B9\n         DC    CL5'CS',AL1(RS),AL1(0),AL1(E4+EPR),AL1(0),X'04'     BA\n         DC    CL5'CDS',AL1(RS),AL1(0),AL1(E4+EPR),AL1(0),X'04'    BB\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR BC\n         DC    CL5'CLM',AL1(RS),AL1(0),AL1(0),AL1(CPR),X'04'       BD\n         DC    CL5'STCM',AL1(RS),AL1(0),AL1(S2),AL1(0),X'04'       BE\n         DC    CL5'ICM',AL1(RS),AL1(0),AL1(0),AL1(ZRO8),X'04'      BF\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR C0\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR C1\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR C2\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR C3\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR C4\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR C5\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR C6\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR C7\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR C8\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR C9\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR CA\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR CB\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR CC\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR CD\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR CE\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR CF\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR D0\n         DC    CL5'MVN',AL1(SS1),AL1(0),AL1(S1),AL1(0),X'06'       D1\n         DC    CL5'MVC',AL1(SS1),AL1(0),AL1(S1),AL1(0),X'06'       D2\n         DC    CL5'MVZ',AL1(SS1),AL1(0),AL1(S1),AL1(0),X'06'       D3\n         DC    CL5'NC',AL1(SS1),AL1(0),AL1(S1),AL1(ZRO8),X'06'     D4\n         DC    CL5'CLC',AL1(SS1),AL1(0),AL1(0),AL1(CPR),X'06'      D5\n         DC    CL5'OC',AL1(SS1),AL1(0),AL1(S1),AL1(ZRO8),X'06'     D6\n         DC    CL5'XC',AL1(SS1),AL1(0),AL1(S1),AL1(ZRO8),X'06'     D7\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR D8\n         DC    CL5'MVCK',AL1(SS2),AL1(0),AL1(S1+M1),AL1(ARITH),X'06' D9\n         DC    CL5'MVCP',AL1(SS2),AL1(0),AL1(S1+M1),AL1(ARITH),X'06' DA\n         DC    CL5'MVCS',AL1(SS2),AL1(0),AL1(S1+M1),AL1(ARITH),X'06' DB\n         DC    CL5'TR',AL1(SS1),AL1(0),AL1(S1),AL1(0),X'06'        DC\n         DC    CL5'TRT',AL1(SS1),AL1(0),AL1(0),AL1(ZRO8),X'06'     DD\n         DC    CL5'ED',AL1(SS1),AL1(0),AL1(S1),AL1(ARITH),X'06'    DE\n         DC    CL5'EDMK',AL1(SS1),AL1(0),AL1(S1),AL1(ARITH),X'06'  DF\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR E0\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR E1\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR E2\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR E3\n         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04'          E4\n         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04'      XA  E5\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR E6\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR E7\n         DC    CL5'MVCIN',AL1(SS1),AL1(0),AL1(S1),AL1(0),X'06'     E8\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR E9\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR EA\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR EB\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR EC\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR ED\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR EE\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR EF\n         DC    CL5'SRP',AL1(SS2),AL1(0),AL1(S1),AL1(ARITH),X'06'   F0\n         DC    CL5'MVO',AL1(SS2),AL1(0),AL1(S1),AL1(0),X'06'       F1\n         DC    CL5'PACK',AL1(SS2),AL1(0),AL1(S1),AL1(0),X'06'      F2\n         DC    CL5'UNPK',AL1(SS2),AL1(0),AL1(S1),AL1(0),X'06'      F3\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR F4\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR F5\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR F6\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR F7\n         DC    CL5'ZAP',AL1(SS2),AL1(0),AL1(S1),AL1(ARITH),X'06'   F8\n         DC    CL5'CP',AL1(SS2),AL1(0),AL1(0),AL1(CPR),X'06'       F9\n         DC    CL5'AP',AL1(SS2),AL1(0),AL1(S1),AL1(ARITH),X'06'    FA\n         DC    CL5'SP',AL1(SS2),AL1(0),AL1(S1),AL1(ARITH),X'06'    FB\n         DC    CL5'MP',AL1(SS2),AL1(0),AL1(S1),AL1(0),X'06'        FC\n         DC    CL5'DP',AL1(SS2),AL1(0),AL1(S1),AL1(0),X'06'        FD\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR FE\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR FF\n         DC    X'FFFF'                 TABLE END\n         EJECT\n***********************************************************************\n* TWO-BYTE OP CODES                                                   *\n***********************************************************************\nDBLOP    DS    0CL12                   TWO-BYTE OP-CODE TABLE\n         DC    X'0101',CL5'PR ',AL1(E),AL1(0),AL1(0),AL1(0),X'02'\n         DC    X'0102',CL5'UPT',AL1(E),AL1(0),AL1(0),AL1(0),X'02'\n*\n         DC    X'9C00',CL5'SIO',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'9C01',CL5'SIOF',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'9D00',CL5'TIO',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'9D01',CL5'CLRIO',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'9E00',CL5'HIO',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'9E01',CL5'HDV',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'9F00',CL5'TCH',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n*\n         DC    X'A400',CL5'VAE',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'A500',CL5'VAER',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'A600',CL5'VMXSE',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n*\n         DC    X'B202',CL5'STIDP',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B203',CL5'STIDC',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B204',CL5'SCK',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B205',CL5'STCK',AL1(S),AL1(0),AL1(E8+S2),AL1(0),X'04'\n         DC    X'B206',CL5'SCKC',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B207',CL5'STCKC',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B208',CL5'SPT',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B209',CL5'STPT',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B20A',CL5'SPKA',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B20B',CL5'IPK',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B20D',CL5'PTLB',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B210',CL5'SPX',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B211',CL5'STPX',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B212',CL5'STAP',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B213',CL5'RRB',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B214',CL5'SIE',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B218',CL5'PC',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B219',CL5'SAC',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B21A',CL5'CFC',AL1(S),AL1(0),AL1(0),AL1(0),X'04'\n*\n         DC  X'B220',CL5'SERVC',AL1(RRE2),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B221',CL5'IPTE',AL1(RRE2),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B222',CL5'IPM',AL1(RRE1),AL1(0),AL1(0),AL1(0),X'04'\n         DC  X'B223',CL5'IVSK',AL1(RRE2),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B224',CL5'IAC',AL1(RRE1),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B225',CL5'SSAR',AL1(RRE1),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B226',CL5'EPAR',AL1(RRE1),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B227',CL5'ESAR',AL1(RRE1),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B228',CL5'PT',AL1(RRE2),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B229',CL5'ISKE',AL1(RRE2),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B22A',CL5'RRBE',AL1(RRE2),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B22B',CL5'SSKE',AL1(RRE2),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B22C',CL5'TB',AL1(RRE2),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B22D',CL5'DXR',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n*\n         DC   X'B230',CL5'CSCH',AL1(E),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B231',CL5'HSCH',AL1(E),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B232',CL5'MSCH',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B233',CL5'SSCH',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B234',CL5'STSCH',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B235',CL5'TSCH',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B236',CL5'TPI',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B237',CL5'SAL',AL1(E),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B238',CL5'RSCH',AL1(E),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B239',CL5'STCRW',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B23A',CL5'STCPS',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B23B',CL5'RCHP',AL1(E),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B23C',CL5'SCHM',AL1(E),AL1(PRIV),AL1(0),AL1(0),X'04'\n*\n         DC  X'B240',CL5'BAKR',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC  X'B246',CL5'STURA',AL1(RRE2),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B247',CL5'MSTA',AL1(RRE1),AL1(0),AL1(0),AL1(0),X'04'\n         DC  X'B248',CL5'PALB',AL1(RRE1),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B249',CL5'EREG',AL1(RRE1),AL1(0),AL1(0),AL1(0),X'04'\n         DC  X'B24A',CL5'ESTA',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC  X'B24B',CL5'LURA',AL1(RRE2),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B24C',CL5'TAR ',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC  X'B24D',CL5'CPYA',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC  X'B24E',CL5'SAR ',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC  X'B24F',CL5'EAR ',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC  X'B254',CL5'MVPG',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC  X'B259',CL5'IESBE',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n***********************************************************************\n* THESE ARE MATHEMATICAL ASSIST INSTRUCTIONS DESCRIBED IN SA22-7094   *\n***********************************************************************\n         DC   X'B243',CL5'MADS',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC   X'B244',CL5'SQDR',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC   X'B245',CL5'SQER',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC   X'B280',CL5'LGND',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC   X'B281',CL5'LGNE',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC   X'B282',CL5'EXPD',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC   X'B283',CL5'EXPE',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC   X'B284',CL5'LGCD',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC   X'B285',CL5'LGCE',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n*\n         DC    X'E400',CL5'VLI ',AL1(SSE),AL1(PRIV),AL1(0),AL1(0)\n         DC    X'06'\n*\n         DC    X'E500',CL5'LASP',AL1(SSE),AL1(PRIV),AL1(0),AL1(0)\n         DC    X'06'\n         DC    X'E501',CL5'TPROT',AL1(SSE),AL1(PRIV),AL1(0),AL1(0)\n         DC    X'06'\n         DC    X'E50E',CL5'MVCSK',AL1(SSE),AL1(PRIV),AL1(0),AL1(0)\n         DC    X'06'\n         DC    X'E50F',CL5'MVCDK',AL1(SSE),AL1(PRIV),AL1(0),AL1(0)\n         DC    X'06'\n         DC    X'FFFF'                 TABLE END\n         EJECT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DISASM3B": {"ttr": 11271, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x00\\x8f\\x00\\x99\\x00\\x8f\\x13\\x10\\x00\\xa3\\x00\\xa3\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-01-08T00:00:00", "modifydate": "1999-01-08T13:10:00", "lines": 163, "newlines": 163, "modlines": 0, "user": "RH87944"}, "text": "         EJECT\n***********************************************************************\n* SVC NAME TABLE - SYSTEM SVCS                                        *\n***********************************************************************\nSVCOP    DS    0CL15                          SVC NAME TABLE\n         DC    AL1(0),CL14'EXCP/XDAP'\nSVCNAML  EQU   *-SVCOP                        LENGTH OF EACH ENTRY\n         DC    AL1(1),CL14'WAIT/WAITR/...'\n         DC    AL1(2),CL14'POST'\n         DC    AL1(3),CL14'EXIT'\n         DC    AL1(4),CL14'GETMAIN'\n         DC    AL1(5),CL14'FREEMAIN'\n         DC    AL1(6),CL14'LINK'\n         DC    AL1(7),CL14'XCTL'\n         DC    AL1(8),CL14'LOAD'\n         DC    AL1(9),CL14'DELETE'\n         DC    AL1(10),CL14'GET/FREEMAIN R'\n         DC    AL1(11),CL14'TIME'\n         DC    AL1(12),CL14'SYNCH'\n         DC    AL1(13),CL14'ABEND'\n         DC    AL1(14),CL14'SPIE'\n         DC    AL1(15),CL14'ERREXCP'\n         DC    AL1(16),CL14'PURGE'\n         DC    AL1(17),CL14'RESTORE'\n         DC    AL1(18),CL14'BLDL/FIND'\n         DC    AL1(19),CL14'OPEN'\n         DC    AL1(20),CL14'CLOSE'\n         DC    AL1(21),CL14'STOW'\n         DC    AL1(22),CL14'OPEN TYPE J'\n         DC    AL1(23),CL14'CLOSE TYPE T'\n         DC    AL1(24),CL14'DEVTYPE'\n         DC    AL1(25),CL14'TRKBAL'\n         DC    AL1(26),CL14'LOCATE, ETC'\n         DC    AL1(27),CL14'OBTAIN'\n         DC    AL1(28),CL14'''RESERVED'''\n         DC    AL1(29),CL14'SCRATCH'\n         DC    AL1(30),CL14'RENAME'\n         DC    AL1(31),CL14'FEOV'\n         DC    AL1(32),CL14'ALLOC'\n         DC    AL1(33),CL14'IOHALT'\n         DC    AL1(34),CL14'MGCR/QEDIT'\n         DC    AL1(35),CL14'WTO/WTOR'\n         DC    AL1(36),CL14'WTL'\n         DC    AL1(37),CL14'SEGLD/SEGWT'\n         DC    AL1(38),CL14'''RESERVED'''\n         DC    AL1(39),CL14'LABEL'\n         DC    AL1(40),CL14'EXTRACT'\n         DC    AL1(41),CL14'IDENTIFY'\n         DC    AL1(42),CL14'ATTACH'\n         DC    AL1(43),CL14'CIRB'\n         DC    AL1(44),CL14'CHAP'\n         DC    AL1(45),CL14'OVLYBRCH'\n         DC    AL1(46),CL14'TTIMER'\n         DC    AL1(47),CL14'STIMER'\n         DC    AL1(48),CL14'DEQ'\n         DC    AL1(49),CL14'''RESERVED'''\n         DC    AL1(50),CL14'''RESERVED'''\n         DC    AL1(51),CL14'SNAP/SDUMP'\n         DC    AL1(52),CL14'RESTART'\n         DC    AL1(53),CL14'RELEX'\n         DC    AL1(54),CL14'DISABLE'\n         DC    AL1(55),CL14'EOV'\n         DC    AL1(56),CL14'ENQ/RESERVE'\n         DC    AL1(57),CL14'FREEDBUF'\n         DC    AL1(58),CL14'RELBUF/REQBUF'\n         DC    AL1(59),CL14'OLTEP'\n         DC    AL1(60),CL14'(E)STAE/STAI'\n         DC    AL1(61),CL14'IKJEGS6A'\n         DC    AL1(62),CL14'DETACH'\n         DC    AL1(63),CL14'CHKPT'\n         DC    AL1(64),CL14'RDJFCB'\n         DC    AL1(65),CL14'''RESERVED'''\n         DC    AL1(66),CL14'BTAMTEST'\n         DC    AL1(67),CL14'''RESERVED'''\n         DC    AL1(68),CL14'SYNAD...'\n         DC    AL1(69),CL14'BSP'\n         DC    AL1(70),CL14'GSERV'\n         DC    AL1(71),CL14'ASGNBFR, ETC'\n         DC    AL1(72),CL14'''NO MACRO'''\n         DC    AL1(73),CL14'SPAR'\n         DC    AL1(74),CL14'DAR'\n         DC    AL1(75),CL14'DQUEUE'\n         DC    AL1(76),CL14'IFBSTAT'\n         DC    AL1(78),CL14'LSPACE'\n         DC    AL1(79),CL14'STATUS'\n         DC    AL1(81),CL14'SETPRT'\n         DC    AL1(82),CL14'     '\n         DC    AL1(83),CL14'SMFWTM'\n         DC    AL1(84),CL14'GRAPHICS'\n         DC    AL1(85),CL14'DDRSWAP'\n         DC    AL1(86),CL14'ATLAS'\n         DC    AL1(87),CL14'DOM'\n         DC    AL1(88),CL14'     '\n         DC    AL1(91),CL14'VOLSTAT'\n         DC    AL1(92),CL14'TCBEXCP'\n         DC    AL1(93),CL14'TGET/TPUT'\n         DC    AL1(94),CL14'STCC'\n         DC    AL1(95),CL14'SYSEVENT'\n         DC    AL1(96),CL14'STAX'\n         DC    AL1(97),CL14'IKJEGS9G'\n         DC    AL1(98),CL14'PROTECT'\n         DC    AL1(99),CL14'DYNALLOC'\n         DC    AL1(100),CL14'IKJEFFIB'\n         DC    AL1(101),CL14'QTIP'\n         DC    AL1(102),CL14'AQCTL (TCAM)'\n         DC    AL1(103),CL14'XLATE'\n         DC    AL1(104),CL14'TOPCTL (TCAM)'\n         DC    AL1(105),CL14'IMGLIB'\n         DC    AL1(107),CL14'MODESET'\n         DC    AL1(109),CL14'ESR TYPE 4'\n         DC    AL1(110),CL14'DSTATUS'\n         DC    AL1(111),CL14'''NO MACRO'''\n         DC    AL1(112),CL14'PGRLSE'\n         DC    AL1(113),CL14'PGFIX/PGFREE/..'\n         DC    AL1(114),CL14'EXCPVR'\n         DC    AL1(116),CL14'ESR TYPE 1'\n         DC    AL1(117),CL14'DEBCHK'\n         DC    AL1(119),CL14'TESTAUTH'\n         DC    AL1(120),CL14'GETMAIN/FREEMAIN'\n         DC    AL1(121),CL14'VSAM'\n         DC    AL1(122),CL14'ESR TYPE 2'\n         DC    AL1(123),CL14'PURGEDQ'\n         DC    AL1(124),CL14'TPIO'\n         DC    AL1(125),CL14'EVENTS'\n         DC    AL1(126),CL14'MSS INTERFACE'\n         DC    AL1(127),CL14' '\n         DC    AL1(128),CL14' '\n         DC    AL1(129),CL14' '\n         DC    AL1(130),CL14'RACHECK'\n         DC    AL1(131),CL14'RACINIT'\n         DC    AL1(132),CL14'RACLIST'\n         DC    AL1(133),CL14'RACDEF'\n         DC    AL1(134),CL14' '\n         DC    AL1(135),CL14' '\n         DC    AL1(136),CL14' '\n         DC    AL1(137),CL14'ESR TYPE 6'\n         DC    AL1(138),CL14'PGSER (XA)'\n         DC    AL1(139),CL14'CVAF...'\n***********************************************************************\n* SVC NAME TABLE - USER SVCS (SVCS BELOW 200 ARE RESERVED FOR IBM)    *\n***********************************************************************\nSVCUSR   DC    AL1(200),CL14'             '    FIRST USER SVC\n         DC    AL1(215),CL14'CICS(HPSVC)  '\n         DC    AL1(216),CL14'CICS(CSVC)   '\n         DC    AL1(235),CL14'             '\n         DC    AL1(238),CL14'TMON CICS    '\n         DC    AL1(240),CL14'             '\n         DC    AL1(241),CL14'             '\n         DC    AL1(242),CL14'CA-7         '\n         DC    AL1(243),CL14'             '\n         DC    AL1(244),CL14'             '\n         DC    AL1(245),CL14'CA-11        '\n         DC    AL1(246),CL14'             '\n         DC    AL1(247),CL14'CA-1 (X)     '\n         DC    AL1(248),CL14'CA-1 (Y)     '\n         DC    AL1(249),CL14'             '\n         DC    AL1(250),CL14'             '\n         DC    AL1(251),CL14'             '\n         DC    AL1(252),CL14'             '\n         DC    AL1(253),CL14'             '\n         DC    AL1(254),CL14'             '\n         DC    AL1(255),CL14'JES3 SDF     '\n         DC    X'FF'                   END OF TABLE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DISASPRM": {"ttr": 11275, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x99\\x00\\x8f\\x00\\x99\\x01\\x1f\\x13\\x07\\x00\\xfa\\x00\\xb2\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1999-01-08T00:00:00", "modifydate": "1999-01-11T13:07:00", "lines": 250, "newlines": 178, "modlines": 0, "user": "RH87944"}, "text": "         MACRO\n         DISASPRM  &DSECT=NO\n*\n*              COMMPARM AND DSECTS FOR DISASM PROGRAMS...\n*\n****************************************************************\n*\n* FOLLOWING FIELDS: COMMPARM THRU COMMEND ARE COMMON AREAS SHARED\n* BY THIS, AND CALLED SUB-PROGRAMS. ALL CHANGES MUST BE COORDINTAED\n* WITH ALL OTHER PROGRAMS.\n*\n****************************************************************\n*\n         AIF   ('&DSECT' EQ 'NO').LBL1\nCOMMPARM DSECT\n         AGO   .LBL2\n.LBL1    ANOP\n         DS    0D\nCOMMPARM DS    0D                      COMMON AREAS\n.LBL2    ANOP\nDBLWD    DS    D                       DOUBLEWORD WORK AREA\n         AIF   ('&DSECT' EQ 'NO').LBL3\nPUNCHDCB DS    A                       @ SYSPUNCH DCB\nPRINTDCB DS    A                       @ SYSPRINT DCB\nINDCB    DS    A                       @ SYSIN DCB\nDTBSTRT  DS    A                       DSECT TABLE START ADDR\nUSGSTRT  DS    A                       USING TABLE START ADDR\nLBLLGTH  DS    AL2                     LENGTH OF LABEL ENTRY\n         AGO   .LBL4\n.LBL3    ANOP\nPUNCHDCB DC    A(SYSPUNCH)             @ SYSPUNCH DCB\nPRINTDCB DC    A(SYSPRINT)             @ SYSPRINT DCB\nINDCB    DC    A(SYSIN)                @ SYSIN DCB\nDTBSTRT  DC    A(HIVAL)                DSECT TABLE START ADDR\nUSGSTRT  DC    A(HIVAL)                USING TABLE START ADDR\nLBLLGTH  DC    AL2(L'LABEL)            LENGTH OF LABEL ENTRY\n.LBL4    ANOP\nCSECT    DC    CL8' '                  SPECIFIED CSECT NAME\nESDID    DC    X'0001'                 ESD ID OF SPECIFIED CSECT\nENDLBLNM DC    CL8' '                  SYMBOL FOR END STMT BEGIN POINTE\nLINECT   DC    PL2'0'                  PRINT LINE COUNTER\nSTART    DC    F'0'                    LKED ASSIGNED START ADDR OF CSEC\nEND      DC    F'0'                    CSECT END ADDRESS\nLENGTH   DC    F'0'                    LENGTH OF SPECIFIED CSECT\nLBLTBL   DS    F                       @ LABEL TABLE\nCURRLBL  DS    F                       CURRENT LABEL ENTRY ADDR\nENDLBL   DS    F                       @ END OF LABEL TBL\nTXTSTRT  DS    F                       @ TEXT STORAGE AREA\nTXTEND   DS    F                       @ END OF TEXT AREA\nTXTCURR  DS    F                       @ CURRENT TEXT LOC\nDTBCUR   DC    F'0'                    DSECT TABLE CURRENT ENTRY ADDR\nDTBEND   DC    F'0'                    DSECT TABLE END ADDR\nUSGCUR   DC    F'0'                    USING TABLE CURRENT ADDR\nUSGEND   DC    F'0'                    USING TABLE END ADDR\nDATONLY  DS    F                       DATA ONLY TABLE ADDR\nDATOCUR  DS    F                       CURRENT DATA ONLY ADDR\nDATOEND  DS    F                       END OF DATA ONLY TABLE\nFLPTASM  DC    X'00'                   FLOATING POINT INDICATOR\nPRIVASM  DC    X'00'                   PRIVILEGED INDICATOR\nTEXTFLAG DC    X'00'                   HEX DUMP INDICATOR           RH\nUSERR    DC    X'00'                   ERROR INDIC FOR DISASM1\nNBRLBLS  DC    H'0'                    NBR LABELS FROM DISASM1\nPAGECTR  DC    PL2'0'             PAGE COUNTER                      RH\nSTMTCTR  DC    PL3'0'             STATEMENT COUNTER                 RH\n*\n*\n*\nWORKREC  DS    0CL80                   DISASSEMBLY WORK AREA\nNAME     DS    CL8                     NAME\n         DS    CL1\nMNEMONIC DS    CL5                     INSTRUCTION MNEMONIC\n         DS    CL1\nOPNDS    DS    CL27                    1ST OPERAND\n         DS    CL1\nCOMMENT  DS    CL28                    COMMENT\nCOL72    DS    CL1\nSEQNBR   DS    CL8                     CARD SEQ NBR\n*\n*\n*\nCARDNO   DC    PL4'0'                  OUTPUT CARD NBR\n*RTLINE  DS    0CL121                  PRINT LINE\n*CC      DC    C'1'                    CARRIAGE CONTROL\n*RT      DC    CL120' '                PRINT DATA\nPRTLINE  DC    CL133' '                PRINT LINE                   RH\n         ORG   PRTLINE                                              RH\nPCC      DS    CL1                     CARRIAGE CONTROL             RH\nPRT      DS    CL132                   PRINT DATA                   RH\n         ORG   PRT                                                  RH\n         DS    CL1                                                  RH\nPLOCN    DS    CL6                      LOCATION                    RH\n         DS    C                                                    RH\nPOBJ2    DS    CL4                      FIRST 2 BYTES OBJECT CODE   RH\n         DS    C                                                    RH\nPOBJ4    DS    CL4                      SECOND 2 BYTES OBJECT CODE  RH\n         DS    C                                                    RH\nPOBJ6    DS    CL4                      THIRD 2 BYTES OBJECT CODE   RH\nPOBJEND  DS    C                                                    RH\nPADDR1   DS    CL5                      ADDRESS 1                   RH\n         DS    C                                                    RH\nPADDR2   DS    CL5                      ADDRESS 2                   RH\n         DS    CL2                                                  RH\nPSTMT    DS    CL4                      STATEMENT NUMBER            RH\n         DS    C                                                    RH\nPLABEL   DS    CL9                      STATEMENT LABEL             RH\nPCODE    DS    CL5                      OPERATION CODE              RH\nPBLANK   DS    C                                                    RH\nPOPNDS   DS    CL30                     OPERANDS                    RH\n         ORG   PLABEL+40                                            RH\nPCOMMENT DS    CL31                     COMMENTS                    RH\n         DS    CL1                                                  RH\nPSEQ     DS    CL8                      SEQUENCE NUMBER             RH\n         DS    CL12                                                 RH\n         ORG   ,                                                    RH\n*\n*\n*\n         DS    0F\nBLDLIST  DS    0CL62                   BLDL LIST\n         DC    H'1'                    ONE ENTRY\n         DC    H'58'                   LENGTH OF ENTRY\nMEMBER   DC    CL8' '                  MEMBER NAME\nTTRMOD   DC    XL3'000000'             TTR OF MODULE\nCCAT     DC    XL1'00'                 CONCATENATION NUMBER\n         DC    XL1'00'\nALIASIND DC    XL1'00'                 ALIAS AND MISC INDICATOR\n*                           80=ALIAS\nTTR1TXT  DC    XL3'000000'             TTR OF 1ST TXT RECORD\n         DC    XL1'00'\nTTRNS    DC    XL3'000000'             TTR OF NOTE OR SCATTER LIST\nNNOTE    DC    XL1'00'                 NBR ENTRIES IN NOTE LIST\nATTR1A   DC    XL1'00'                 MODULE ATTRIBUTES 1, BYTE 1\n*                           80=RENT\n*                           40=REUS\n*                           20=OVERLAY\n*                           10=UNDER TEST\n*                           08=ONLY LOADABLE\n*                           04=SCATTER FORMAT\n*                           02=EXECUTABLE\n*                           01=ONE TXT, NO RLD RECORDS\nATTR1B   DC    XL1'00'                 ATTRIBUTES 1, BYTE 2\n*                           80=CANNOT BE REPROCESSED BY LKED E\n*                           40=ORIGIN OF 1ST TXT RECORD IS ZERO\n*                           20=ASSIGNED ENTRY POINT ADDR IS ZERO\n*                           10=CONTAINS NO RLD RECORD\n*                           08=CANNOT BE REPROCESSED BY LKED\n*                           04=CONTAINS TESTRAN SYMBOLS\n*                           02=CREATED BY LKED\n*                           01=REFR\nTOTVIRT  DC    XL3'000000'             TOTAL VIRTUAL STRG REQRD FOR MOD\nLENG1    DC    XL2'0000'               LENGTH OF 1ST TEXT RECORD\nLKEPA    DC    XL3'000000'             ASSIGNED ENTRY POINT ADDR\nATTR2    DC    XL1'00'                 ATTRIBUTES 2\n*                           80=PROCESSED BY OS/VS LKED\n*                           20=PAGE ALIGNMENT REQUIRED FOR MODULE\n*                           10=SSI PRESENT\nATTR2A   DC    XL1'00'\n*                           X'10' - RMODE = 24 IF 0, ELSE ANY\n*                           B'....XX..' ALIAS ADDRESS MODE\n*                           B'......XX' MAIN ADDRESS MODE\n*                           AMODE = 24 IF 00, 31 IF 10, ANY IF 11\nATTR2B   DC    XL1'00'\nSCTRLEN  DC    XL2'0000'               SCATTER LIST LENGTH\nTTLEN    DC    XL2'0000'               TRANSLATION TABLE LENGTH\nSCESDID  DC    XL2'0000'               CESD NBR FOR 1ST TXT RECD\nSCEPESD  DC    XL2'0000'               CESD NBR FOR ENTRY POINT\nALEPA    DC    XL3'000000'             ENTRY POINT OF THE MEMBER NAME\nALMEM    DC    CL8' '                  REAL MEMBER NAME FOR ALIAS\nSSI      DS    XL4'00000000'           SSI BYTES\nAUTHLEN  DC    XL1'00'                 AUTH CODE LENGTH\nAUTHCOD  DC    XL1'00'                 AUTH CODE\n*\n*\n*\nCOMMEND  EQU   *\n*\n*\n*\nLABELD   DSECT ,                       LABEL TABLE ENTRY\nLABEL    DS    0CL13                   13-BYTE ENTRIES\nLBLADR   DS    XL3                     RELATIVE ADDR IN TEXT\nLBLTYP   DS    CL1                     TYPE: L=LABEL, A=ADCON, V=VCON,\nLBLNAME  DS    CL8                     NAME (SYMBOL)\nLBLLEN   DS    XL1                     LENGTH IF A, V, OR W\n*\n*\n*\nUSINGD   DSECT ,                       USING TABLE ENTRY\nUSING    DS    0CL11\nUSBGN    DS    XL3                     OFFSET TO BEGINNING OF RANGE\nUSEND    DS    XL3                     OFFSET TO END OF RANGE\nUSREG    DS    XL1                     BASE REGISTER USED\nUSTYPE   DS    XL1                     TYPE:P=PGM,D=DSECT\nUSVALU   DS    XL3                     BASE REG VALUE\n*\n*\n*\nDSECTD   DSECT ,                       DSECT FIELD TABLE ENTRY\nDSECT    DS    0CL13\nDSOFSET  DS    XL3                     OFFSET TO 1ST BYTE OF FIELD\nDSLBTYP  DS    CL1                     LABEL TYPE = L\nDSNAME   DS    CL8                     FIELD NAME\nDSLENG   DS    XL1                     FIELD LENGTH\n*\nRLDTBLD  DSECT ,                       RELOCATION DICTIONARY TABLE\nRLDENT   DS    0CL20                   11 BYTE ENTRIES\nRLDRP    DS    XL2                     RELOCATION POINTER\nRLDPP    DS    XL2                     POS PTR (SYMBOL CESD NBR)\nRLDTYPE  DS    XL1                     TYPE\n*                    00=A-TYPE ADCON\n*                    01=V-TYPE ADCON\n*                    02=PSEUDO REGISTER DISPLACEMENT\n*                    03=PSEUDO REG CUMULATIVE DISPL\n*                    08=UNRESOLVED\nRLDLEN   DS    XL1                     LENGTH OF CONSTANT\nRLDDIR   DS    CL1                     RELOCATION DIRECTION, + OR\nRLDADDR  DS    XL3                     LKED ASSGND ADDR OF CONSTANT\nRLDNAME  DS    CL8                     NAME FROM ASSOC ESD\nRLDESDTP DS    XL1                     TYPE FROM ASSOC ESD\n         DS    XL1\n*\nSYMTBL   DSECT ,                       EXTERNAL SYMBOL TABLE ENTRY\nSYMENT   DS    0CL19                   19 BYTE ENTRIES\nEXTSYM   DS    CL8                     EXTERNAL SYMBOL NAME\nTYPSYM   DS    XL1                     SYMBOL TYPE\n*                        00=SD (NAMED CSECT)\n*                        02=ER (EXTRN)\n*                        03=LR (ENTRY)\n*                        04=PC (UNNAMED CSECT)\n*                        05=CM (COM)\n*                        06=PR (PSEUDO REGISTER)\n*                        07=NULL\n*                        0A=WX (WXTRN)\n*                        0F=ENTAB OR SEGTAB\nSYMIND   DS    XL1                     INDICATOR\n*                        BIT 0 = MAP\n*                        BIT 1 = CHAIN\n*                        BIT 2 = INSERT\n*                        BIT 3 = DELETE/REPLACE\nSYMADDR  DS    XL3                     SYMBOL ADDRESS (0 FOR ER, WX, NU\nSYMARMOD DS    XL1                     AMODE/RMODE                  ACF\n*                       X'08' - RSECT; READ ONLY IF ON              ACF\n*                       X'04' - RMODE; ANY IF ONE, 24 IF 0          ACF\n*                       X'03' - AMODE 00,01 = 24, 10 = 31, 11 = ANY ACF\nSYMSEG   DS    XL1                     SEGMENT ID (0 FOR ER, WX, NULL)\nSYMLRID  DS    0XL2                    ESD ID OF DEF FOR LR\nSYMLENG  DS    XL3                     LENGTH FOR SD, PC, CM, PR\n*                        0 FOR ER, WX, NULL\nSYMESDID DS    XL2                     ESD ID OF THIS ITEM\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DISASRUN": {"ttr": 11525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x99\\x00\\x8f\\x00\\x99\\x03?\\x13\\x02\\x00\\x18\\x00\\x19\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1999-01-08T00:00:00", "modifydate": "1999-02-02T13:02:00", "lines": 24, "newlines": 25, "modlines": 0, "user": "RH87944"}, "text": "//RUNDIS JOB\n/*ROUTE  PRINT R7\n//*\n//*      THIS  IS TEST JCL FOR DSECT OFFSETS IN DECIMAL\n//*\n//DISASM EXEC PGM=DISASM,PARM=(SUPVR,FLTPT,TEXT)\n//STEPLIB DD DSN=HALL.LOAD,DISP=SHR\n//SYSPRINT DD SYSOUT=*,DCB=BLKSIZE=133\n//SYSLIB DD DSN=SYS1.LPALIB,DISP=SHR\n//SYSPUNCH DD SYSOUT=Z,DCB=BLKSIZE=80\n//*YSPUNCH DD DSN=HALL.IECIOSCN.ASM,DISP=(,CATLG),\n//*           UNIT=SYSDA,DCB=BLKSIZE=18960,\n//*           SPACE=(TRK,(5,2),RLSE)\n//SYSIN DD *\nCSVEXFP CSVEXFP\nUSING 000000 000B28 C P 000000\n/*\n//SYSIN2 DD *\nIEFJRASP IEFJRASR\nUSING 000000 000E10 C P 000022\nIEFJRASP IEFJRASP\nUSING 000022 000980 C P 000022\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DSB": {"ttr": 11527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03?\\x00\\x99\\x03?\\x13\"\\x00@\\x00@\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-02T00:00:00", "modifydate": "1999-02-02T13:22:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "RH87944"}, "text": "/*REXX*/\n/*   TRACE O */\n/*   TRACE ?r to set a break point to read input from terminal */\n/*   TRACE     RESULTS; */\n   X=PROMPT(ON)       /* ALLOW PROMPTING */\n   PARSE UPPER ARG @HLI @args            /* GET PARMS, IF ANY */\n\n   IF LENGTH(@HLI) = 0 THEN DO\n      @HLI = \"'\"SYSVAR(\"SYSUID\")\"'\"\n   END\n\n   IF @HLI = 'DEBUG' THEN DO\n      @HLI = \"'\"SYSVAR(\"SYSUID\")\"'\"\n      TRACE ON\n      TRACE RESULTS\n   END\n\n   @nbr = FIND(@args,'DEBUG')\n   IF @nbr > 0 THEN DO\n      @args = DELWORD(@args,@nbr)\n      @debug = ''\n      TRACE ON\n      TRACE RESULTS\n   END\n\n      \"ISPEXEC VGET (ZSCREEN)\"\n      @TN = ZSCREEN\n\n      \"free f(a1)\"\n      \"attr a1 recfm(f b a) lrecl(121) blksize(6050) dsorg(ps)\"\n      \"alloc f(temp\"@tn\") da(temp\"@tn\") mod reuse using(a1) delete\"\n      if RC \u00ac= 0 then do\n         say \"Error allocating file\"\n         exit\n      end\n\n\n/* SET UP THE DS CMD */\nCMND  = \"ds \"@HLI @args\n\nx=outtrap(\"LINES.\")\n/* RUN THE DS CMD */\ninterpret 'cmnd'\n/* turn of trapping                  */\nx=outtrap(\"OFF\")\n\nallocok:\n   X=PROMPT(ON)       /* ALLOW PROMPTING */\n/* Stuff the lines into the output dataset */\n\nif LINES.0 = 0 then signal END\n\nDO I=1 TO LINES.0\n   queue lines.i\n   \"EXECIO 1 DISKW temp\"@tn\nend\n      if sysvar(sysispf) \u00ac= 'ACTIVE' then exit\n\n\"EXECIO 0 DISKW temp\"@tn\" (FINIS\"\n\"ISPEXEC BROWSE DATASET(temp\"@tn\")\"\n\nEND:\n          \"FREE F(temp\"@tn\")\"\n           EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSPACE": {"ttr": 11529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03?\\t\\x19\\x15\\xef\\x16\\x11\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-02T09:19:00", "lines": 5615, "newlines": 5649, "modlines": 0, "user": "RH87944"}, "text": "//DSPACE   JOB\n/*ROUTE  PRINT R7\n//*\n//*    DSN=CBT.SOURCE(DSPACE)\n//*\n//*     FIND 'END FOR NOW' TO GET  TO LKED STEP....\n//*\n//*\n//SPACE EXEC HLASMCL,PARMC='ESD',PARML='LIST,LET,MAP,NCAL'\n//ASM.SYSLIB DD DSN=SYS1.MACLIB,DISP=SHR\n//           DD DISP=SHR,DSN=RH87944.SOURCE.CNTL\n//           DD DSN=SYS1.MODGEN,DISP=SHR\n//ASM.SYSPRINT DD SYSOUT=*\n//ASM.SYSIN DD *\n*    THIS VERSION OF DS USES SUPER LOCATE TO SEARCH THE\n*    CATALOG, AND UCBSCAN TO SEARCH THE UCB TABLE.\n*\n*      THIS  VERSION ALSO HANDLES MIGRATED DATASETS\n*\n*      JAN 99...SINCE I FIGURED OUT HOW TO USE THE UNIT ADDRESS,\n*               CHANGE DEFAULT UNIT IN VARIABLE TUPAR3 TO BLANK\n*               AND USE THE 4 DIGIT UNIT ADDRESSES FROM THE UCB\n*               FOR THE UNIT NAME...IT S/B IN FORMAT /1234...\n*               SEE CODE AT LABEL MOVEVOLS.\n*               OF COURSE, SPECIFYING UNIT() OVERRIDES THIS...\n*            ...ADD CODE AT LABEL DOSVC99 TO SHOW REASON CODE\n*               AND INFO CODE IF SVC 99 FAILS....\n*\n*      MAR 98...ADD CODE AT LABEL NOPRINT TO DETERMINE WHAT\n*               SYSTEM WE ARE ON.\n*               IF ON THE Y1YY, CHANGE THE SMS MCDS DATASET.\n*\n*      MAR 98...CHANGE DEFAULT UNIT IN VARIABLE TUPAR3 TO SYSDA\n*               SO THAT DS CAN HANDLE 4 DIGIT UNIT ADDRESSES\n*               AND DON'T USE UNIT NAME FROM UCB.\n*               IT APPEARS THAT SVC 99 AND DAIRFAIL DON'T LIKE\n*               4 DIGIT UNIT NAMES SUCH AS 1530...\n*\n*      MAR 97...USE IDCAMS TO GET VOLSERS IF LOCATE SHOWS MORE\n*               THAN 6 FOR A DATASET, AS LOCATE ONLY GIVES\n*               1ST 20 VOLSERS.\n*            ...ADDED AN MCDS(...) KEYWORD TO ALLOW CHANGING\n*               DEFAULT OF \"SMS.DFHSM.MCDS\" AT LABEL MCDDSN...\n*\n*      JAN 96...CHANGED VTCREAD TO STOP READING VTOC WHEN 255\n*               EMPTY BLOCKS ARE FOUND.\n*            ...DON'T PRINT GDG AND TAPE MSGS IF NOLIST\n*      OCT 95...CHANGED VTCREAD TO STOP READING VTOC WHEN THE 2ND\n*               EMPTY BLOCK IS  FOUND.\n*      MAY 95...FIX 66D ABEND IN TSOPUT/PUTLINE...CLEAR ECB/IOPLUPT\n*      JAN 95...CHANGED TPUT TO PUTLINE FOR DATASET OUTPUT.\n*            ...CHANGED INDEX OUTPUT TO INCLUDE CREATE/USED DATES.\n*            ...CHANGED VTCREAD TO GET TRKS/CYL FROM DSCB 4\n*      FEB 94...CHANGED IKJPARS FOR DSNAME FROM IKJPOSIT TO\n*               IKJIDENT SO GDGS COULD BE SPECIFIED.\n*      JUL 93...ADDED DYNAMIC=YES TO UCBSCAN MACRO.\n*               (AT LABEL NEXTUCB).\n*      NOV 89...FIX FREE OF MCDS DATASET, AND PRINT MSG IF NOT.\n*               (AT LABEL CLSNVSAM).\n*      NOV 89...MODIFIED TO SEE IF PRINT(...) DATASET IS MIGRATED.\n*               (AT LABEL LISTEMOK).\n*      AUG 88...MODIFIED TO PROPERLY HANDLE MULTI-VOLUME DATASETS.\n*\nSP       TITLE  'TSO SPACE COMMAND'\n         MACRO\n&LAB     PUTIT &MESS,&LTH,&RET=NO\n         LCLC  &L\n&L       SETC  'L'''\n         AIF   ('&MESS'(1,1) EQ '''').NOLTH TITLE IN QUOTES?\n         AIF   ('&LTH' EQ '').DOLTH  LTH SPECIFIED?\n.*       DC    C'&TITLE'          COMMENT...\n.*       AGO   .NOCOMM\n&LAB     MVC   MSG+1(&LTH),&MESS    MOVE MSG TO PRINT\n         LA    R14,0              SET R14 = 0\n         AIF   ('&RET' EQ 'NO').NORET  B IF NO RETURN\n         LA    R14,*+4+4          SET R14 = A(AFTER PUTIT)\n.NORET   ANOP\n         B     PRINTMSG           GO PRINT IT\n         MEXIT\n.DOLTH   ANOP\n&LAB     MVC   MSG+1(&L.&MESS),&MESS    MOVE MSG TO PRINT\n         LA    R14,0              SET R14 = 0\n         AIF   ('&RET' EQ 'NO').NORET2 B IF NO RETURN\n         LA    R14,*+4+4          SET R14 = A(AFTER PUTIT)\n.NORET2  ANOP\n         B     PRINTMSG           GO PRINT IT\n         MEXIT\n.INQ     ANOP\n.*       DC    C&TITLE            COMMENT...\n.NOLTH   ANOP\n&LAB     MVC   MSG+1(&L.M&SYSNDX),M&SYSNDX  MOVE MSG TO PRINT\n         LA    R14,0              SET R14 = 0\n         AIF   ('&RET' EQ 'NO').NORET3 B IF NO RETURN\n         LA    R14,M&SYSNDX.R     SET R14 = A(AFTER PUTIT)\n*        LA    R14,8(0,R14)       SET R14 = A(AFTER PUTIT)\n.NORET3  ANOP\n         B     PRINTMSG           GO PRINT IT\nM&SYSNDX DC    C&MESS\nM&SYSNDX.R DS  0H\n         MEND\n         MACRO\n&LAB     TPUTIT &MESS\n         LCLC  &L\n&L       SETC  'L'''\n&LAB     TPUT  M&SYSNDX,&L.M&SYSNDX\n         B     RETURN\nM&SYSNDX DC    C&MESS\n         MEND\n         MACRO\n&LAB     PUTIT1 &MESS\n&LAB     BAL   LINK,CLOSRDR\n         STAX  DEFER=NO\n         PUTIT &MESS\n         MEND\n*\n         COPY  MACROS             THESE ARE IN RH87944.SOURCE.CNTL\n*\n*              END OF MACROS....\n*\n         EJECT\nSPACE    CSECT\nSPACE    AMODE 31\nSPACE    RMODE 24\n* SPACE LEVEL(--------)\n* NOTE LEVEL DEFAULTS TO USERID\nBASE     EQU   12\n         ENTRY SW3,MSG,REPORT,INFO1\nSTART    DS    0H\n         USING *,R15\n         B     AROUND             BRANCH AROUND DUMP TITLE\nEYECATCH DC    AL1(EYELTH)        LTH OF EYECATCHER\n         DC    C'DSPACE  '        PROGRAM NAME\n         DC    C'VERSION 5.1 '    VERSION\n         DC    CL8'&SYSDATE'      DATE WRITTEN\n         DC    CL6'&SYSTIME'      TIME WRITTEN\n         DC    C' '\n         DC    C'CHANGE VTCREAD TO STOP AT 255TH EMPTY DSCB BLOCK'\n         DC    C' AND ADD HELP SCREENS'\nEYELTH   EQU   *-EYECATCH\n*        DC    C'VERSION 5.0 '    VERSION\n*        DC    C'CHANGE VTCREAD TO STOP AT 2ND BINARY DSCB BLOCK'\n         SPACE 1\nAROUND   DS    0H\n         DROP  R15\n         STM    14,12,12(13)\n         LR    BASE,15\n         USING SPACE,BASE,R11,R7\n         LA    R11,4095(0,R12)   LOAD SECOND BASE REGISTER\n         LA    R11,1(0,R11)      LOAD SECOND BASE REGISTER\n         LA    R7,4095(0,R11)    LOAD THIRD  BASE REGISTER\n         LA    R7,1(0,R7)        LOAD THIRD  BASE REGISTER\n         L     15,=A(SUPRSAVE)\n         ST    13,4(15)\n         ST    15,8(13)\n         LR    13,15\n         B     SUPRSAVE+72\nSUPRSAVE DC    18A(0)\n         LR    R10,R1  SAVE PARM LIST\n         ST    R10,CPPLADDR         SAVE A(CPPL)\n         USING CPPL,R10           ADDRESS IT\n         USING PSCB,R9\n         SPACE 1\n         L     R3,=V(IOPLADD)     R3 -> TO IOPL\n         USING IOPL,R3            SET IOPL BASE\n         L     R4,CPPLUPT\n         ST    R4,IOPLUPT         SET UP IOPL\n         L     R4,CPPLECT\n         ST    R4,IOPLECT\n         L     R4,=V(ECB)\n         ST    R4,IOPLECB\n         DROP  R3                 DROP IOPL BASE....\n         SPACE 1\n         L    R15,16               CVT POINTER\n         L    R15,0(R15)           TCB PTR PTR\n         L    R15,0(R15)           TCB POINTER\n         L     R15,180(0,R15)     R15 -> TO JSCB                    RH3\n         L     R15,264(0,R15)     R15 -> TO TSO PSCB                RH3\n         LTR   R15,R15            IS THERE A PSCB?                  RH3\n         BP    BYPASSF            YES, IT'S A TSO TERMINAL          RH3\n*                                 NO, IT'S A BATCH JOB. SET FLAG    RH3\n         OI    SW3,SW380           SAY BATCH PROCESSING\n         OPEN  (REPORT,(OUTPUT))\n         TM    REPORT+48,X'10'    DID REPORT FILE OPEN ?            RH\n         BZ    ABEND1             NO                                RH\n         MVI   PRINTNOP+1,X'00'   YES, CHANGE B TO NOP              RH\n         MVI   RETNOP+1,X'00'     YES, CHANGE B TO NOP              RH\n         OPEN  (SYSIN,(INPUT))    OPEN INPUT FILE                   RH\n         TM    SYSIN+48,X'10'     DID SYSIN FILE OPEN ?             RH\n         BZ    USEPARM            NO                                RH\n         OI    SW3,SW340          YES, SAY WE HAVE SYSIN            RH\n         SPACE 1\nGETIN    DS    0H\n         GET   SYSIN              READ A RECORD\n         LR    R2,R1              R2 -> TO DATASET NAME\n         SPACE 1\nBATLOOP1 DS    0H\n         CLI   0(R2),C' '         END OF DSN ?\n         BE    ENDLOOP1           YES\n         LA    R2,1(0,R2)         R2 -> TO NEXT DSN CHAR\n         B     BATLOOP1           CHECK IT\n         SPACE 1\nENDLOOP1 DS    0H\n         SR    R2,R1              R2 = LTH OF DSN\n         LR    R3,R1              R3 -> TO DSN\n         LA    R4,LVLBUF+2        R4 -> TO WHERE DSN GOES\n         MVC   LVLBUF(2),=XL2'00' LTH = 0\n         MVI   0(R4),C' '         CLEAR DSN FIELD\n         MVC   1(43,R4),0(R4)     ''\n         MVC   DSNAME(44),0(R4)   CLEAR FIELD CALLED DSNAME\n         B     BATCH0             CONTINUE\n         SPACE 1\nUSEPARM  DS    0H\n         L     R9,0(0,R10)        R9 -> TO PARM\n         LA    R4,LVLBUF+2        R4 -> TO WHERE DSN GOES\n         MVC   LVLBUF(2),=XL2'00' LTH = 0\n         LH    R2,0(0,R9)         R2 = LTH OF DSN\n         LA    R3,2(0,R9)         R3 -> TO DSN\n         SPACE 1\nBATCH0   DS    0H\n         LA    R10,FAKECPPL       R10 -> TO FAKE CPPL\n         LA    R6,FAKEVOL         R6 -> TO FAKE VOL LIST\n         USING VOLDX,R6           SET BASE\n         L     R9,CPPLPSCB        R9 -> TO FAKE PSCB\n         ST    R9,PSCBADDR        SAVE PSCB ADDR\n         SR    R8,R8              CLEAR R8\n         B     BATCH1             ON WE GO\n         SPACE 1\nFAKECPPL DS    0F\n         DC    2F'0'\n         DC    A(FAKEPSCB)\n         DC    F'0'\nFAKEPSCB DS    0F\n         DC    CL7' '\n         DC    CL1' '\n         DC    CL8' '\n         DC    X'80'\n         DC    CL56' '\nFAKEVOL  DS    0C\n         DC    6X'00'\n         DC    2X'00'\n         DC    X'FF000000'\n         SPACE 1\n*        SET UP PARM FOR PARSE\n         SPACE 2\nREPOPEN  DS    0H                                                   RH\nBYPASSF  DS    0H                                                   RH\n         L     R9,CPPLPSCB\n         ST    R9,PSCBADDR        SAVE PSCB ADDR\n         MVC   PPLUPT,CPPLUPT\n         MVC   PPLECT,CPPLECT\n         MVC   PPLCBUF,CPPLCBUF\n         LA    R1,PPLUPT  POINT TO IT\n         LINK  EP=IKJPARS\n         B     *+4(R15)  BRANCH ON RETURNED CODE\n         B     PARSOK\n         B     ERROR2\n         B     RETURN  USER ATTNED OUT\n         B     ABEND1  PROGRAM BUG\n         B     ERROR3  SPACE NOT AVAILABLE IN REGION\n         B     ERROR4  INVALID PARM\n         EJECT\nPARSOK   L     R8,PPLANS  CHECK ANSWER ADDRESS\n         LTR   R8,R8\n         BZ    ABEND2  PARSE ERROR\n         USING IKJPARMD,R8\n         SPACE 5\n*        SET UP FOR CALL TO DAIR\n         MVC   DAPLUPT,CPPLUPT\n         MVC   DAPLECT,CPPLECT\n         MVC   DAPLPSCB,CPPLPSCB\n         SPACE 1\nPRINTSET DS    0H                                                   RH\n         LH    R5,PRNTKWD         R5 -> TO PRINT KEYWORD            RH\n         CH    R5,=H'1'           IS THERE A PRINT KEYWORD ?        RH\n         BNE   NOPRINT            NO, PRINT AT TERMINAL             RH\n         SPACE 1                                                    RH\n         OI    SWITCHWD,PRINTIT   YES, TURN ON SWITCH               RH\n         LA    R5,PRINTDD         R5 -> TO PRINT DSN                RH\n         USING SVDDX,R5           SET BASE FOR PRINT DSN KEYWORD    RH\n         MVC   PRTDSNL,SVDLTH     MOVE DSNAME LTH TO DAIR WORK AREA RH\n         L     R2,SVDPTR          R2 -> TO PRINT DSNAME             RH\n         LH    R14,SVDLTH         R14 = DSN LTH                     RH\n         BCTR  R14,0              SUBT 1 FOR MVC LTH                RH\n         STC   R14,MVC1+1         SET MVC LTH                       RH\nMVC1     MVC   PRTDSN,0(R2)       MOVE DSN TO DAIR WORK AREA        RH\n         SPACE 1                                                    RH\nNOPRINT  DS    0H\n*\n*              FIND WHAT SYSTEM WE ARE ON.\n*              IF ON THE Y2K, CHANGE SMS DSN\n*\n         L     R5,16              R5 -> TO ASCB\n         L     R5,196(0,R5)       R5 -> TO BATCH JOB PTR\n         LA    R5,16(0,R5)        R5 -> AT SYSTEM ID\n         CLC   =C'Y1YY',0(R5)     ARE WE ON Y1YY?\n         BNE   MCDSSET            NO, SMS DSN IS OKAY\n*        LA    R5,MCDDSNL2        YES, R5 -> AT Y2K SMS DSN\n*        ST    R5,MCDDDSN         SAVE IT\n         MVC   MCDDSNL(46),MCDDSNL2    CHANGE MCD DSN\n*\nMCDSSET  DS    0H                                                   RH\n         LH    R5,MCDSKWD         R5 -> TO MCDS  KEYWORD            RH\n         CH    R5,=H'1'           IS THERE AN MCDS KEYWORD ?        RH\n         BNE   NOMCDS             NO, USE DEFAULT                   RH\n         SPACE 1                                                    RH\n         MVI   MCDDSN,C' '        CLEAR OUT DEFAULT MCDS NAME       RH\n         MVC   MCDDSN+1(43),MCDDSN ....                             RH\n         LA    R5,MCDSDSN         R5 -> TO MCDS DSN                 RH\n         USING SVDDX,R5           SET BASE FOR PRINT DSN KEYWORD    RH\n         MVC   MCDDSNL,SVDLTH     MOVE DSNAME LTH TO DAIR WORK AREA RH\n         L     R2,SVDPTR          R2 -> TO MCDS  DSNAME             RH\n         LH    R14,SVDLTH         R14 = DSN LTH                     RH\n         BCTR  R14,0              SUBT 1 FOR MVC LTH                RH\n         STC   R14,MVC2+1         SET MVC LTH                       RH\nMVC2     MVC   MCDDSN,0(R2)       MOVE DSN TO DAIR WORK AREA        RH\n         SPACE 1                                                    RH\nNOMCDS   DS    0H\n         LA         R5,DSNCT      R5 -> TO MAX PARM\n         DROP       R5\n         USING      DSNCTDX,R5\n         TM         DSNCTFLG,DSNCTON\n         BZ         NODSNCT\n         MVC   MAXBUF(2),DSNCTLTH\n         L     R5,DSNCTPTR\n         MVC   MAXBUF+2(8),0(R5)\nNODSNCT  LA         R5,ACCUMKWD   R5 -> TO TOTAL PARM\n         DROP       R5\n         USING      TOTDX,R5\n         TM    TOTTYPE+1,TOTON    WAS TOTAL KEYWORD SPECIFIED ?\n         BZ    NOTOTAL            NO, TAKE DEFAULTS OF\n*                                     YES IF HLI,\n*                                     NO, IF DSN\n         LA         R5,PERCKWD\n         DROP       R5\n         USING      PERCDX,R5\n         TM    PERCTYPE+1,PERCNO  IS IT TOTAL(NO) ?\n         BO    NOTOTAL            YES, ON WE GO, AS THATS DEFAULT\n         OI    SWITCHWD,PERCENTS+TOTALIT CHANGE TO TOTAL(YES)\nNOTOTAL  LA         R5,LISTKWD    R5 -> TO LIST KEYWORD\n         DROP       R5\n         USING      LISTDX,R5\n         TM         LISTTYPE+1,LISTOFF\n         BZ         LISTEM\n         OI         SWITCHWD,OFFLIST\n         DROP       R5\nLISTEM   EQU        *\n         TM    SWITCHWD,PRINTIT   PRINT TO A FILE?                  RH\n         BZ    PDEADDR            NO, SKIP ALLOC CRAP               RH\n         LA     R4,PRTDSN         R4 -> TO PRINT DSN                RH\n         ST     R4,TCAMDSN        PUT A(DSN) IN TCAM LIST           RH\n         LOCATE TCAML             GO FIND VOL SER FOR PRINT DSN     RH\n         LTR    R15,R15           WAS IT FOUND ?                    RH\n         BZ    LISTEMOK           YES                               RH\n         SPACE 1\nLISTBAD  DS    0H\n         NI    SWITCHWD,255-PRINTIT  TURN OFF PRINT TO A FILE SW    RH\n         B      ERROR10           SAY NOT CATALOGUED                RH\n         SPACE 1\nLISTEMOK DS    0H\n         CLC   =C'MIGRAT',TWORK+6 BUT WAS IT MIGRATED?              RH\n         BE    LISTBAD            YES, TOO BAD                      RH\n         MVC   PRTDVSER(6),TWORK+6 MOVE VOLSER TO DAIR BLOCK        RH\n         MVI   PRTDDSP1,X'01'     DISP=OLD                          RH\n         LA    R14,PRTDRBLK       PUT A(PRINT DAIR BLOCK)           RH\n         ST    R14,DAPLDAPB       IN DAIR PARM LIST                 RH\n         LA    R1,DAPLUPT         R1 -> TO DAIR LIST                RH\n         LINK  EP=IKJDAIR         CALL DAIR                         RH\n         B     *+4(R15)           BRANCH ON RETURNED CODE           RH\n         B     DAIROK1            DAIR OK, CONTINUE                 RH\n         B     ABEND1  INVALID PARM LIST                            RH\n         B     ERROR10  DATA SET NOT IN CATALOG                     RH\n         B     DAIRERR  DAIR ERROR                                  RH\n         B     ERROR5  NO TIOT ENTRIES AVAILABLE                    RH\n         B     ERROR6 DDNAME NOT AVAILABLE                          RH\n         B     ERROR7 DSNAME IS MEMBER OF CONCAT GRP                RH\n         B     ABEND1 DDNAME OR DSNAME NOT ALLOC                    RH\n         B     ERROR8  OLD DATA SET                                 RH\n         B     ABEND1  ERROR IN CATALOG ROUTINE                     RH\n         B     ABEND1  OUT OF QUALIFIER ROOM                        RH\n         B     ERROR11  DELETED DATA SET                            RH\nDAIROK1  DS    0H                                                   RH\n         OPEN  (PRTDCB,(OUTPUT))  OPEN FILE AS OUTPUT TO POINT      RH\n         CLOSE (PRTDCB)           TO FRONT, THEN CLOSE IT           RH\n         LA    R1,DA18CD          R1 -> TO FREE DAIR BLK            RH\n         ST    R1,DAPLDAPB        PUT FREE BLK ADDR IN DAIR UPT     RH\n         MVC   DA18DDN(8),PRTDDDNM MOVE PRINT DDN TO DA18 BLOCK     RH\n         LA    R1,DAPLUPT         R1 -> TO DAIR UPT                 RH\n         LINK  EP=IKJDAIR         LINK TO DAIR                      RH\n         LTR   R15,R15            WAS FREE OKAY ?                   RH\n         BNZ   DAIRERR2           NO, GO TO ERROR ROUTINE           RH\n         MVI   PRTDDSP1,X'02'     CHANGE DISP TO MOD                RH\n         LA    R14,PRTDRBLK       PUT A(PRINT DAIR BLOCK)           RH\n         ST    R14,DAPLDAPB       IN DAIR PARM LIST                 RH\n         LA    R1,DAPLUPT         R1 -> TO DAIR LIST                RH\n         LINK  EP=IKJDAIR  CALL DAIR                                RH\nDAIRERR2 B     *+4(R15)  BRANCH ON RETURNED CODE                    RH\n         B     RESETDRB           DAIR OK, CONTINUE                 RH\n         B     ABEND1  INVALID PARM LIST                            RH\n         B     ERROR10  DATA SET NOT IN CATALOG                     RH\n         B     DAIRERR  DAIR ERROR                                  RH\n         B     ERROR5  NO TIOT ENTRIES AVAILABLE                    RH\n         B     ERROR6 DDNAME NOT AVAILABLE                          RH\n         B     ERROR7 DSNAME IS MEMBER OF CONCAT GRP                RH\n         B     ABEND1 DDNAME OR DSNAME NOT ALLOC                    RH\n         B     ERROR8  OLD DATA SET                                 RH\n         B     ABEND1  ERROR IN CATALOG ROUTINE                     RH\n         B     ABEND1  OUT OF QUALIFIER ROOM                        RH\n         B     ERROR11  DELETED DATA SET                            RH\n         SPACE 1                                                    RH\nRESETDRB DS    0H                                                   RH\n         OPEN  (PRTDCB,(OUTPUT))  OPEN FILE AS OUTPUT AGAIN         RH\n         SPACE 1                                                    RH\nPDEADDR  LA        R5,SVDSN              R5 -> TO ALLOC PARMS\n         USING     SVDDX,R5\n         LA        R6,SERS        R6 -> TO VOL KEYWORD\n         USING     VOLDX,R6\n         LA        R9,LEVEL       R9 -> TO SEARCH NAME\n         USING     LVLDX,R9\n         DROP       R10\n*        L     R10,0(0,R9)        R10 -> TO DSNAME\n         ICM   R10,15,0(R9)       R10 -> TO DSNAME        JAN96\n         BZ    SETR10             NO DSNAME.....          JAN96\n         CLC   =C'HELP',0(R10)    SHOW HELP PANEL?        JAN96\n         BNE   NOHELP             NO                      JAN96\n         EXTRN HELPPAN\n         L     R15,=V(HELPPAN)    LOAD A(HELP PANEL)\n         CALL  (15)               GO PRINT HELP PANEL     JAN96\n*        CALL  HELPPAN            GO PRINT HELP PANEL     JAN96\n         B     RETURN             END OF DS CMD           JAN96\n         SPACE 1                                          JAN96\nNOHELP   DS    0H                                         JAN96\n*\n*                  SEE IF DSNAME WAS QUOTED....\n*\n         BCTR  R10,0              R10 -> TO CHAR BEFORE DSNAME\n         CLI   0(R10),C''''       IS DSNAME QUOTED?\n         BNE   SETR10             NO\n         OI    LVLFLG,X'40'       YES, SAY DSNAME IS QUOTED\n         SPACE 1\nSETR10   DS    0H\n         LA        R10,UNIT       R10 -> TO UNIT KEYWORD\n         USING     UNTDX,R10\n         LH        R8,SUPV               R8 = NBR OF ALLOC DSNS\n         DROP      R8\nLVLSTRNG TM        LVLFLG,B'11000000'\n         BNO       NOQUOTE\n         LA        R4,LVLBUF+2\n         MVC       LVLBUF(2),=X'0000'                               RH\nMOVELVL  LH        R2,LVLLTH\n         L         R3,LVLPTR\n         SPACE 1                                                    RH\nBATCH1   DS    0H\n         SH        R2,=H'1'\n         EX        R2,XMOVE\n         AH        R2,=H'1'\n         AH        R2,LVLBUF\n         STH       R2,LVLBUF\n         B     VOLDSNMX           GO TEST FOR UNIT PARM             RH\n         SPACE 1                                                    RH\nNOQUOTE  DS    0H\n         SR    R2,R2               R2 = 0\n         L     R3,DAPLUPT          R3 -> TO UPT\n         LA    R3,16(0,R3)         R3 -> UPT USER NAME\n         CLI   7(R3),X'00'         UPT HAVE HIGH LEVEL INDEX ?\n         BE    NOUPT               NO, USE TSOID\n         IC    R2,7(R3)            R2 = LTH OF UPTUSER\n         B     MOVEUSER            SET UP BUFFER\nNOUPT    DS    0H\n         ST    R9,SAVER9A         SAVE R9\n         DROP  R9                 DROP LVLDX BASE\n         L     R9,PSCBADDR        LOAD PSCB ADDR\n*        L     R9,CPPLPSCB        R9 -> TO FAKE PSCB\n         USING PSCB,R9            SET PSCB BASE\n         LA    R3,PSCBUSER         R3 -> TO PSCB USERID\n         IC    R2,PSCBUSRL         R2 = LTH OF PSCBUSER\n         DROP  R9                 DROP PSCB BASE\n         L     R9,SAVER9A         RELOAD R9\n         USING LVLDX,R9           SET LVLDX BASE\n         SPACE 1\nMOVEUSER DS    0H\n         MVC   LVLBUF+2(7),0(R3)   MOVE HLI TO BUFFER\n         TM    LVLFLG,X'C0'        ANY LEVEL PARM ?\n         BZ    NOLEVEL             NO, USE TSOID\n         LA    R4,LVLBUF+2         R4 -> TO TSOID\n         LA    R4,0(R2,R4)         R4 -> END OF TSOID\n         MVI   0(R4),C'.'          ADD . TO END OF TSOID\n         LA    R4,1(0,R4)          R4 -> TO NEXT AVAILABLE BYTE\n         LA    R2,1(0,R2)          R2 = LTH OF TSOID.\n         STH   R2,LVLBUF           SAVE TSOID. LTH\n         B     MOVELVL             ADD REST OF NAME\n         DROP  R9                 DROP R9 BASE\n         SPACE 2\nNOLEVEL  DS    0H\n         STH   R2,LVLBUF           SAVE TSOID LTH\nVOLDSNMX TM       UNTFLG,B'10000000'\n         BZ       NOUNIT\n         MVC       TUPAR3(5),=CL5'     '\n         LH       R2,UNTLTH\n         STH      R2,TULNG3           PUT UNIT LTH IN SVC99 BLK\n         SH       R2,=H'1'\n          L       R3,UNTPTR\n          LA      R4,TUPAR3\n          EX      R2,XMOVE\nNOUNIT   DS     0H\n         CH        R8,=H'1'              ARE THERE ANY ALLOC DSNS?\n         BNE       NOTSUPV               NO\n         SPACE 1\nSUPVDSRT LH        R2,SVDLTH             R2 = LTH OF ALLOC DSN\n         L         R3,SVDPTR             R3 -> TO ALLOC DSN\n         LA     R4,DDSNAM                R4 -> TO WHERE DSN GOES\n         ST     R4,TCAMDSN               PUT A(DSN) IN TCAM LIST\n         SH        R2,=H'1'\n         EX        R2,XMOVE\n         AH        R2,=H'1'\n         STH       R2,DDSNAML\n         B      LOCVOL                   GO DO LOCATE\n         SPACE 1\nNOTSUPV  DS        0H\n         TM        SW1,X'01'       WANT ALL VOLS?\n         BO        NEXTVOL         YES, GET NEXT VOL\n         TM        VOLFLG,B'10000000'\n         BZ        VOLTABLX\n         L         R3,VOLPTR\n         CLC   0(6,R3),=C'ALLVOL'  WANT ALL VOLS ?\n         BE    GETVOLS             YES, GET FIRST VOL\n         MVC   TUPAR1(6),0(R3)    SAVE VOLSER SER FOR LATER         RH\n         TM    SW1,X'01'           WANT ALL VOLS?\n         BO    NEXTVOL             YES, GET NEXT VOL\n         CLC   =C'MIGRAT',TUPAR1  ONLY WANT MIGRATED DATASETS?      RH\n         BNE   FINDUCB            NO, GO FIND UCB FOR SPECIFIED VOL RH\n         MVI   MIGRAT1+1,X'F0'    YES, CHANGE NOP TO BRANCH\n         MVI   MIGRAT2+1,X'F0'    YES, CHANGE NOP TO BRANCH\n         MVI   MIGRAT3+1,X'F0'    YES, CHANGE NOP TO BRANCH\n         MVI   MIGRAT4+1,X'F0'    YES, CHANGE NOP TO BRANCH\n         B     VOLTABLX           YES, DON'T LOOK FOR UCB           RH\n         SPACE 1                                                    RH\nMOVEVOLS DS    0H\n         MVC   TUPAR1(6),0(R3)    MOVE VOLSER TO S99 BLOCK\n         MVI   FAILSW+1,X'32'     CHANGE DAIRFAIL TO SAY SVC 99     RH\n*\n*              SVC 99 AND DAIRFAIL DON'T LIKE A 4 DIGIT UNIT\n*              NAME SO USE UNIT(SYSDA)\n*\n*              JAN 1999...AH, BUT  IT WILL IF IT IS PRECEDED BY /   RH\n*              ..EG../190A.....\n*\n         TM    UNTFLG,B'10000000' DID USER SPECIFY UNIT()?          RH\n         BO    DAIRLINK           YES, DON'T CHANGE IT              RH\n*        CLI   TUPAR3,C' '        IS UNIT NAME BLANK?               RH\n*        BNE   DAIRLINK           NO, THEY USED UNIT() PARM\n*\n*              CONVERT UCB ADDRESS FOR UNIT NAME\n*\n         MVI   TUPAR3,C'/'        SAY WE ARE USING A 4-DIGIT UCB    RH\n         MVI   TULNG3+1,X'05'     MAKE SURE LTH IS 5                RH\n         UNPK  TUPAR3+1(5),4(3,R1)  UNPACK 4 DIGIT UNIT ADDRESS\n         MVI   TUPAR3+5,X'EF'     TRANSLATES TO BLANK\n         TR    TUPAR3+1(5),TRTAB-239 TRANSLATE TO DISPLAY\n*\n*        UNPK  TUPAR3(5),4(3,R1)  UNPACK 4 DIGIT UNIT ADDRESS\n*        MVI   TUPAR3+4,X'EF'     TRANSLATES TO BLANK\n*        TR    TUPAR3(5),TRTAB-239 TRANSLATE TO DISPLAY\n* OLD    MVC   TUPAR3(3),13(R1)   MOVE UNIT NAME TO S99 BLOCK       RH\n         B         DAIRLINK\n         SPACE 1                                                    RH\nGETVOLS  DS    0H\n         OI    SW1,X'01'           TURN ON ALL VOLS SWITCH\n         SPACE 1                                                    RH\nFINDUCB  DS    0H                                                   RH\n         NI    SW2,255-SW204      TURN VOL FOUND SWITCH OFF         RH\n         STM   R2,R6,VOLSAVE       SAVES REGS\n         XC    WORKAREA,WORKAREA  CLEAR UCBSCAN WORKAREA\n         SPACE 1                                                    RH\nNEXTVOL  DS    0H\n         SPACE 1                                                    RH\nNEXTUCB  DS    0H\n         UCBSCAN COPY,WORKAREA=WORKAREA,UCBAREA=UCBAREA,               +\n               DYNAMIC=YES,DEVCLASS=DASD,VOLSER=TUPAR1,                +\n               RANGE=ALL,CMXTAREA=CMXTAREA,DCEAREA=DCEAREA,            +\n               DCELEN=DCELEN\n         LTR   R15,R15            HAS A UCB BEEN RETURNED?\n         BNZ   NOMORE             NO, AT END OF DEVICE CLASS AND\n*                                 NO MATCH FOUND.\n         LA    R3,UCBAREA         R3 -> TO UCB THAT THE SCAN\n*                                 SERVICE RETURNED.\n         TM    3(R3),X'80'           ONLINE?\n         BZ    NEXTUCB\n         TM    6(R3),X'40'        IS DEVICE READY ?\n         BO    NEXTUCB            NO, DON'T USE IT THEN\n         TM    35(R3),X'80'       IS IT MOUNTED ?\n         BO    NEXTUCB            NO, ASSUME IT IS OFFLINE\n         CLI   28(R3),X'00'       IS THERE A VOL SER?\n         BE    NEXTUCB            NO, DON'T USE IT THEN\n         SPACE 1\n         TM    SW1,X'01'          DOING ALLVOL ?                    RH\n         BO    DOALLVOL           YES                               RH\n         CLC   28(6,R3),TUPAR1    IS THIS OUR VOL ?                 RH\n         BNE   NEXTUCB            NO, GET NEXT UCB                  RH\n         B     UCBFOUND           YES, ON WE GO                     RH\n         SPACE 1                                                    RH\nDOALLVOL DS    0H\n****** CHECK TO SEE IF THIS UCB HAS ALREADY BEEN PROCESSED.\n         LA    R5,UCBTABLE  TABLE OF ALREADY-PROCESSED UCBS\n         L     R6,NUMENTS   CURRENT NO. OF ACTIVE ENTRIES\nUCBSRCH  CLM   R3,3,0(R5)   CURRENT UCB ADDR=ALREADY DONE UCB ADDR?\n         BE    NEXTUCB      SKIP THIS ONE (ALREADY DONE)\n         LA    R5,2(,R5)    NEXT ENTRY\n         BCT   R6,UCBSRCH   REPEAT FOR CURRENT TABLE SIZE\n         STCM  R3,3,0(R5)   FILL IN NEW ADDRESS IN TABLE\n         L     R6,NUMENTS\n         LA    R6,1(,R6)    ADD 1 NEW ADDR\n         C     R6,UCBTABLN        IS UCB TABLE FULL ?               RH\n         BNL   TABLFULL           YES, END OF DS                    RH\n         ST    R6,NUMENTS\n****** END OF TABLE LOOKUP.\n         SPACE 1                                                    RH\nUCBFOUND DS    0H\n         OI    SW2,SW204          TURN ON VOL FOUND SWITCH          RH\n         LR    R1,R3               R1 -> TO UCB DATA\n         LM    R2,R6,VOLSAVE       RELOAD REGS\n         LA    R3,28(0,R1)         R3 -> TO VOLSER\n         SPACE 1\n         B     MOVEVOLS            MOVE VOL TO WORK AREA\n         SPACE 1\nTABLFULL DS    0H                                                   RH\n         L     R6,VOLSAVE+16      RELOAD R6                         RH\n         NI    SW1,255-X'01'      MAKE SURE ALLVOLS SWITCH IS OFF   RH\n         MVC   VOLNXT(4),=XL4'FF000000'  SAY END OF VOLS            RH\n         PUTIT 'UCB TABLE FULL. CALL SYSTEMS SUPPORT' TELL HIM      RH\n         SPACE 1\nNOMORE   DS    0H\n         NI    SW1,X'FF'-X'01'     TURN OFF LOOP SWITCH\n         TM    SW2,SW204          WAS VOLUME FOUND ?\n         BO    RETURN             YES, END OF DSPACE\n         B     VOLERR             NO, SAY ERROR\n         SPACE 2\nVOLTABLX DS     0H\n         LH     R2,LVLBUF                R2 = LTH OF DSN\n         LA     R3,LVLBUF+2              R3 -> TO DSN\n         LA     R4,DDSNAM                R4 -> TO WHERE DSN GOES\n         ST     R4,TCAMDSN               PUT A(DSN) IN TCAM LIST\n         SH        R2,=H'1'\n         EX        R2,XMOVE\n         AH        R2,=H'1'\n         STH       R2,DDSNAML\n         MVC   SAVPART(46),LVLBUF  SAVE INPUT DSN IN CASE WE\n*                                 HAVE A PARTIAL DSN\nMIGRAT1  NOP   SCATDSN2           B IF ONLY WANT MIGRATED DSNS\n*        L     R15,VOLPTR         R15 -> TO VOL TO SEARCH FOR\n*        CLC   =C'MIGRAT',0(R15)  ONLY WANT MIGRATED DATASETS?      RH\n*        BE    SCATDSN2           YES, DON'T DO LOCATE              RH\n         SPACE 1\nLOCVOL   DS     0H\n*        B     SCATDSN2           ALWAYS LET SUPER LOCATE TRY IT\n*                                 THIS ALSO PRINTS THE HEADING      RH\n*                                 ON MULTI TAPE FILES!!             RH\n*\n*              WE DON'T NEED HEADING INFO ON A TAPE DATASET,\n*              SO DO LOCATE WITH  NO HEADING....\n*\n         LOCATE TCAML                    GO FIND VOL SER\n         LTR    R15,R15                  WAS IT FOUND ?\n         BNZ   SCATDSN2           NO, LET SUPER LOCATE TRY IT\n         SPACE 1\n**  ENTRY HERE FOR DSNAME OR HLI SPECIFIED TO ORIG LOCATE\nSCATDSN  DS    0H                                               MVS\n         CLC   DSNAME(8),=C'CATALOG.' ICF CATALOG POINTER?       XA RH\n         BE    SCATDSN2               YES, USE SUPERLOCATE       XA RH\n         CLC   DSNAME(8),=C'SYSCTLG.'   CVOL POINTER?           MVS\n         BNE   SCATDSN0                 -NO, GOT DSNAME         MVS\n         SPACE 1\n**  ENTRY HERE FOR PARTIAL INDEX SPECIFIED TO ORIG LOCATE\nSCATDSN2 DS    0H                                               MVS\n         MVC   DSNAME,SAVPART+2   RESTORE DSNAME\n         MVC   SUPERLVL(45),SAVPART+1  SET UP NAME FOR SUPER LOCATE\n         SR    R1,R1              CLEAR R1\n         IC    R1,SUPERLVL        R1 = LTH OF DSN\n*\n*              SEE IF THERE IS A  PERIOD IN DSN ALREADY\n*\n         LA    R15,SUPERLVL+1     R15 -> TO DSNAME\n         SPACE 1\nSCATDSN3 DS    0H                                               MVS\n         CLI   0(R15),C'.'        FIND A PERIOD?\n         BE    SLOC               YES, LEAVE LTH ALONE\n         LA    R15,1(0,R15)       R15 -> TO NEXT DSN CHAR\n         BCT   R1,SCATDSN3        CHECK FOR PERIOD\n         SPACE 1\nSCATDSN4 DS    0H                 NO PERIOD FOUND               MVS\n         IC    R1,SUPERLVL        R1 = LTH OF DSN\n         LA    R15,1(0,R1)        R15 = LTH OF DSN + .\n         STC   R15,SUPERLVL       SAVE NEW LTH\n         LA    R15,SUPERLVL+1     R15 -> TO DSN\n         LA    R15,0(R1,R15)      R15 -> TO END OF DSN\n         MVI   0(R15),C'.'        PUT . AT END OF DSN\n         SPACE 1\nSLOC     DS    0H\n         LOCATE SUPERLOC          GO GET ALL ENTRIES\n         LTR   R15,R15            WAS SUPER LOCATE OKAY ?\n         BZ    SHOWCAT            YES, GO PROCESS DSNS\n         CH    R15,=H'40'         RC = 40 ?\n         BE    GET#MORE           YES, IT'S OKAY TOO\n         CH    R15,=H'44'         RC = 44 ?\n         BNE   ERROR10            NO, SAY NOT CATALOGUED\n*\n*              LOAD THE CURRENT & REQUIRED WORKAREA SIZE\n*\nGET#MORE L     R1,WORKADDR\n         LH    R0,0(,R1)\n         SR    R2,R2              CLEAR R2\n         ICM   R2,3,2(R1)         GET REQUIRED WORKAREA LTH\n         CH    R0,H265            IS THIS THE 1ST TIME THRU?\n         BNE   NOTFIRST           NO, GO FREE AND GET\n*\n*              CHECK SIZE OF NEW WORKAREA\n*\n         C     R2,=F'65524'       IS NEW SIZE = X'FFF4'?\n         BL    GETNEXT            NO, GO GET A LARGER WORKAREA\n         LH    R2,=H'32767'       YES, R2 = MAX HALFWORD SIZE\n         B     GETNEXT            GO GET MAX SIZE\n         SPACE 1\nNOTFIRST DS    0H\n*\n*              CHECK SIZE OF NEW WORKAREA\n*\n         C     R2,=F'65524'       IS NEW SIZE = X'FFF4'?\n*        BE    SHOWCAT            YES, TOO MANY ENTRIES IN CAT,\n         BE    TOOBIG             YES, TOO MANY ENTRIES IN CAT,\n*                                 PROCESS WHAT WE CAN\n*\n*              FREEMAIN THE CURRENT WORKAREA\n*\n*       FREEMAIN R,                                                    X\n               A=(1),                                                  X\n               LV=(0)\n         SPACE 1\nGETNEXT  DS    0H\n*\n*              GETMAIN AN EXPANDED WORKAREA\n*\n        GETMAIN R,                                                     X\n               LV=(2)\n         LTR   R15,R15            DID WE GET IT?\n         BNZ   NOROOM             NO, SAY NO ROOM\n*\n*              INITIALIZE THE WORKAREA ADDRESS & HEADER\n*\n         SLL   R2,16\n         ST    R2,0(,R1)\n         ST    R1,WORKADDR\n*\n         MVI   SUPERLOC+3,X'00'   TURN ALL RESERVED BITS OFF        RH\n         XC    CTGFDBK,CTGFDBK    CLEAR FEEDBACK AREA               RH\n*\n*              GO ISSUE SUPERLOCATE AGAIN\n*\n         B     SLOC\n         SPACE 2                                                MVS\nNOROOM   DS    0H                                               MVS\n         PUTIT 'CAN''T GET SUPERLOCATE WORKAREA. REGION SIZE TOO SMALL'+\n               ,RET=YES\n         B     LOCVOL2            EXIT\n         SPACE 2                                                MVS\nTOOBIG   DS    0H                                               MVS\n         CALL  TSOPUT,(TOOBIG1),VL  PRINT 1ST PART OF MSG\n         CALL  TSOPUT,(TOOBIG2),VL  PRINT 2ND PART OF MSG\n*        PUTIT BIGMSG1,BIGLTH1      PRINT 1ST PART OF MSG\n*        PUTIT BIGMSG2,BIGLTH2      PRINT 2ND PART OF MSG\n         B     SHOWCAT            PROCESS WHAT WE HAVE\n*\n*        NOTE  ... THE FOLLOWING PARMS ARE SET UP IN PL1 FORMAT\n*                  FOR TSOPUT.\n*\n         DS    0H\nTOOBIG1  DC    A(BIG1MSG)\nBIG1MSG  DC    AL2(BIGLTH1)\nBIGMSG1  DC    C' TOO MANY ENTRIES TO LIST. QUALIFY SEARCH WITH'\n         DC    C' ANOTHER LEVEL.'\nBIGLTH1  EQU   *-BIGMSG1\n         DS    0H\nTOOBIG2  DC    A(BIG2MSG)\nBIG2MSG  DC    AL2(BIGLTH2)\nBIGMSG2  DC    C'0WILL PROCESS WHAT IS AVAILABLE.'\nBIGLTH2  EQU   *-BIGMSG2\n*        PUTIT 'TOO MANY ENTRIES TO LIST. QUALIFY SEARCH WITH ANOTHER L+\n               EVEL'\n*        PUTIT 'WILL PROCESS WHAT IS AVAILABLE.'\n*        B     ANYMORE            SEE IF ANY MORE VOLS\n         SPACE 2                                                MVS\nSCATDSN0 DS    0H                                               MVS\n         CLC   DSNAME,LVLBUF+2    DID LOCATE CHANGE DSNAME?\n         BE    LOCVOL2            NO, EXIT\n         MVC   LVLBUF+2(44),DSNAME YES, PUT IT IN LVLBUF\n         LA    R2,DSNAME+43       R2 -> TO END OF DSNAME\n         LA    R1,DSNAME          R1 -> TO DSNAME\n         SPACE 1\nCHKDSN   DS    0H\n         CLI   0(R2),C' '         END OF DSNAME?\n         BNE   ENDDSN             YES\n         BCT   R2,CHKDSN          NO, R2 -> AT NEXT DSN CHAR TO CHK\n         SPACE 1\nENDDSN   DS    0H\n         SR    R2,R1              R2 = NEW HEX LTH OF DSNAME\n         LA    R2,1(0,R2)         R2 = DECIMAL LTH OF DSNAME\n         STH   R2,LVLBUF          SAVE IT\n         B     LOCVOL2             EXIT\n         SPACE 2\n*\n***  ROUTINE TO PROCESS SUPER LOCATE WORK AREA\n*\nSHOWCAT  DS    0H\n         OI    SW2,X'80'          TURN INDEX SWITCH ON\n         OI    SWITCHWD,HLILIST   TURN HLI SWITCH ON\n         L     R1,PPLANS          R1 -> TO PARSE AREA\n         USING IKJPARMD,R1\n         LA    R1,ACCUMKWD        R1 -> TO TOTAL KEYWORD\n         DROP  R1\n         USING TOTDX,R1           SET BASE\n         TM    TOTTYPE+1,TOTON    TOTAL KEYWORD SUPPLIED ?\n         BO    TOTALSET           IT'S THERE, USE IT\n         DROP  R1\n         OI    SWITCHWD,PERCENTS+TOTALIT ELSE, SAY TOTAL(YES)\nTOTALSET DS    0H                                               MVS\n         OI    SWITCHWD,HEADING   SAY PRINT HEADING ONLY\n         LA    R1,PARML           R1 -> TO PLI PARMS\n         L     R15,=V(PLICALLA)   R15 -> TO PLI PGM\n         BALR  R14,R15            GO FOR IT\n         NI    SWITCHWD,255-HEADING  TURN PRINT HEADING ONLY OFF\n         OI    SWITCHWD,MULTIVOL  SAY DOING MULTI VOLUMES\n*\n         L     R2,WORKADDR        R2 -> TO SUPER WORK AREA\n         SR    R0,R0              R0 = 0                            RH\n         SR    R1,R1              R1 = 0                            RH\n         ICM   R1,3,0(R2)         R1 = LTH OF WORKAREA\n         ICM   R0,3,2(R2)         R0 = LTH OF WORKAREA USED\n         CR    R0,R1              IS USED < THAN SIZE?\n         BL    R0OKAY             YES\n         LR    R0,R1              NO, PROCESS MAX SIZE\n         SPACE 1\nR0OKAY   DS    0H\n         LA    R14,4(0,R2)        R14 -> TO 1ST DSN\n*        CLI   0(R14),C'X'        IS IT THE HLI POINTER\n*        BNE   SCATGO             NO, SO MUST BE A DSN\n*        LA    R14,45(0,R14)      YES, R14 -> TO NEXT DSN\n         SPACE 1\nSCATGO   DS    0H\n         LA    R14,1(0,R14)       R14 -> PAST ID\n         ST    R14,TCAMDSN        SAVE ADDR OF FIRST DSN\n         MVC   LVLBUF+2(44),0(R14) PUT DSN INTO PLI WORK AREA\n         LA    R15,44             ALWAYS USE LTH OF\n         STH   R15,LVLBUF         44 FOR HLI SEARCH\n         LA    R15,0(0,R2)        R15 -> TO SUPER WORK AREA\n         AR    R15,R0             R15 -> TO END OF DSNS\n         ST    R15,LASTDSN        SAVE ADDR OF LAST DSN\n         SPACE 1\nSCATGO2  DS    0H\n         BCTR  R14,0              R14 -> TO DSN TYPE\n         CLI   0(R14),C'A'        IS THIS A NONVSAM DATASET?\n         BE    SCATGO3            YES\nMIGRAT4  NOP   ANYMORE            B IF ONLY WANT MIGRATED DSNS\n         CLI   0(R14),C'B'        IS THIS A GDG BASE NAME?\n         BE    GDGBASE            YES\n         SPACE 1\nSCATGO3  DS    0H\n         LOCATE TCAML             FIND IT\n         LTR   R0,R15              LOCATE OK?\n         BNZ   ERROR9              BR IF NOT\n         B     LOCVOL2             NOW GO AHEAD\n         SPACE 1\nNEXTDSNA DS    0H\n         L     R14,TCAMDSN        R14 -> TO DSN WE JUST DID\n         LA    R14,45(0,R14)      R14 -> TO NEXT DSN\n         C     R14,LASTDSN        HAVE WE DONE LAST DSN ?\n         BH    DONE               YES, END OF SEARCH, PRINT TOTALS\n         ST    R14,TCAMDSN        PUT IT IN LOCATE LIST\n         MVC   LVLBUF+2(44),0(R14) PUT DSN INTO PLI WORK AREA\n         B     SCATGO2            GO GET IT\n         SPACE  1\n*              ALL LOCATES EVENTUALLY GET HERE....\n         SPACE  1\nLOCVOL2  DS     0H\n*******************************************************************\n*\n*              CHECK HOW MANY VOLUMES ARE IN THE LOCATE WORK AREA.\n*              IF THERE ARE 20, CALL IDCAMS TO MAKE SURE\n*              THAT ALL VOLUMES ARE IN THE LIST, TO A MAX OF 50,\n*              AS LOCATE RETURNS A MAX OF 20....\n*\n*******************************************************************\n         SPACE 1\n         LH    R15,TWORK          R15 = NBR VOLSERS\n         CH    R15,=H'20'         AT LEAST 20?\n         BL    LOCVOL4            NO\n*        CH    R15,=H'6'          MORE THAN 6?\n*        BNH   LOCVOL4            NO\n*\n         LA    R1,TCAML           R1 -> TO CAMLST\n         PERFORM CALLIDC          GO GET VOLSERS USING IDCAMS\n         LTR   R15,R15            DID WE GET IT?\n         BZ    LOCVOL3            YES\n*        BNZ   GETSIZE2           NO, TOO BAD\n         LH    R15,TWORK          R15 = NBR VOLSERS\n         CVD   R15,DWORD2         CONVERT TO DECIMAL\n         UNPK  DWORD2(5),DWORD2+5(3) CONVERT TO DISPLAY\n         MVZ   DWORD2+4(1),DWORD2 FIX SIGN BITS\n         MVC   IDCVOLM(3),DWORD2+2 PUT TOT IN MSG\n         MVI   TWORK,X'00'        DROP MAX VOLS\n         MVC   MSG(IDCMSGL),IDCMSG  MOVE MSG TO PRINT\n         B     PRINTMS1           PRINT IT, THEN GOTO ANYMORE\n*        LA    R14,ANYMORE        GO HERE AFTER PRINTING\n*        B     PRINTMSG           PRINT IT\n*\nLOCVOL3  DS     0H\n         LH    R15,TWORK          R15 = NBR VOLSERS\n         CH    R15,=H'50'         MORE THAN 50?\n         BNH   LOCVOL4            NO\n         SRL   R15,8              R15 = TOT VOLSERS\n         CVD   R15,DWORD2         CONVERT TO DECIMAL\n         UNPK  DWORD2(5),DWORD2+5(3) CONVERT TO DISPLAY\n         MVZ   DWORD2+4(1),DWORD2 FIX SIGN BITS\n         MVC   MAXVOL(3),DWORD2+2 PUT TOT IN MSG\n         MVI   TWORK,X'00'        DROP MAX VOLS\n         MVC   MSG(MAXMSGL),MAXMSG  MOVE MSG TO PRINT\n         B     PRINTMS1           PRINT IT, THEN GOTO ANYMORE\n*        LA    R14,ANYMORE        GO HERE AFTER PRINTING\n*        B     PRINTMSG           PRINT IT\n*\nLOCVOL4  NOP   LOCVOL5            ONLY DO THIS ONCE\n         MVI   LOCVOL4+1,X'F0'    CHANGE NOP TO B\n         TM    TWORK+4,X'80'      IS DSN ON A TAPE ?\n         BZ    LOCVOL5            NO\n         CH    R15,=H'1'          MORE THAN 1?\n         BNH   LOCVOL5            NO\n*\n         LA    R1,0               SET VOLCNT2 TO 0 SO THAT WE WILL\n         STH   R1,VOLCNT2         REPROCESS THE 1ST TAPE VOLSER..\n         CVD   R15,DWORD2         CONVERT TO DECIMAL\n         UNPK  DWORD2(5),DWORD2+5(3) CONVERT TO DISPLAY\n         MVZ   DWORD2+4(1),DWORD2 FIX SIGN BITS\n         MVC   MAXVOL(3),DWORD2+2 PUT TOT IN MSG\n         MVI   TWORK,X'00'        DROP MAX VOLS\n         MVC   MSG(VOLMSGL),MAXMSG  MOVE MSG TO PRINT\n         B     PRINTMS1           PRINT IT, THEN GOTO ANYMORE\n*        LA    R14,ANYMORE        GO HERE AFTER PRINTING\n*        B     PRINTMSG           PRINT IT\n*\nLOCVOL5  DS     0H\n         MVC   TUPAR1(6),TWORK+6        MOVE VOLSER TO DAIR BLOCK\n         L     R14,TCAMDSN        R14 -> TO DSN WE JUST DID\n         BCTR  R14,0              R14 -> TO DSN TYPE\n         CLI   0(R14),C'X'        IS THIS AN ALIAS NAME?\n         BE    ALIASNAM           YES\n         SPACE  1\nOBTAIN1  DS     0H\n         CLC   =C'MIGRAT',TUPAR1  HAS DATASET BEEN MIGRATED?        RH\n         BE    MCDLBL0            YES, GO DO HSM STUFF              RH\nMIGRAT2  NOP   ANYMORE            B IF ONLY WANT MIGRATED DSNS\n         CLI   TWORK+4,X'20'      IS DSN ON A DISK VOLUME?\n         BNE   NOTDISK            NO, GO SEE WHAT IT IS\n         B     FINDUCB            YES, GO FIND UCB FOR THIS PACK    RH\n         SPACE 1\n******** ***** ****************** *********************************\n*\n*              DATASET HAS BEEN MIGRATED. GO TO HSM TO GET THE\n*              INFO. ALLOCATE MCDS DATASET ONLY ONCE.\n*\n******** ***** ****************** *********************************\n         SPACE 1\nMCDLBL0  NOP   FINDUCB            B IF ANY MCDS ERRORS              RH\nMCDLBL1  NOP   MCDLBL2            B AFTER 1ST PASS                  RH\n         MVI   MCDLBL1+1,X'F0'    CHANGE NOP TO B                   RH\n         NI    MCDSW,255-PRINTIT  TURN OFF MCD ALLOCATED SW         RH\n*\n*  MAKE SURE WE HAVE READ ACCESS TO MCDS\n*\n*              GET THE VOLUME THE  MCDS HLI IS ON\n*\n         L     R4,TCAMDSN         SAVE LAST LOCATE DSN POINTER      RH\n         LA    R14,MCDHLI         R14 -> TO MCD DSN HLI             RH\n         ST    R14,TCAMDSN        PUT A(HLI) IN TCAM LIST           RH\n         LOCATE TCAML             GO FIND VOL SER                   RH\n         ST    R4,TCAMDSN         RELOAD LAST LOCATE DSN POINTER    RH\n         LTR    R15,R15           WAS IT FOUND ?                    RH\n         BZ    HLIOK              YES                               RH\n         MVI   MCDLBL0+1,X'F0'    CHANGE NOP TO B                   RH\n         B      ERROR10           SAY NOT CATALOGUED                RH\n         SPACE 1\nHLIOK    DS    0H\n         LA    R5,TWORK+6         R5 -> TO VOLSER\n*                WHEN THIS RUNS AUTHORIZED, TURN OFF ERROR LOGGING\n*                BY ADDING ,LOG=NONE AFTER CLASS=READ\n         RACHECK ENTITY=(MCDDSN),VOLSER=(R5),                          +\n               DSTYPE=V,          IT'S A VSAM FILE                     +\n               CLASS='DATASET',ATTR=READ     LOG=NONE\n         LTR   R15,R15            ARE WE OKAY?\n         BZ    RACRET             YES\n         MVI   MCDLBL0+1,X'F0'    NO, CHANGE NOP TO B               RH\n         B     FINDUCB            GO TO REST OF CODE\n         SPACE 1\nRACRET   DS    0H\n         L     R4,TCAMDSN         SAVE LAST LOCATE DSN POINTER      RH\n         LA    R14,MCDDSN         R14 -> TO MCD DSN                 RH\n         ST    R14,TCAMDSN        PUT A(DSN) IN TCAM LIST           RH\n         LOCATE TCAML             GO FIND VOL SER                   RH\n         ST    R4,TCAMDSN         RELOAD LAST LOCATE DSN POINTER    RH\n         LTR    R15,R15           WAS IT FOUND ?                    RH\n         BZ    MCDMOK             YES                               RH\n         MVI   MCDLBL0+1,X'F0'    CHANGE NOP TO B                   RH\n*        B      ERROR10           SAY NOT CATALOGUED                RH\n         PUTIT MCDDSN,RET=YES     PRINT DEFAULT MCDS NAME\n         PUTIT 'MCDS DATA NOT FOUND. USE MCDS(''...'') KEYWORD.'\n         B     FINDUCB            GO TO REST OF CODE\n         SPACE 1\nMCDSW    DC    X'00'              MCD SWITCH                        RH\n         SPACE 2\nMCDDRBLK DS    0F\nMCDDCD   DC    X'0008'\nMCDDFLG  DC    H'0'\nMCDDDARC DC    H'0'\nMCDDCTRC DC    H'0'\nMCDDDSN  DC    A(MCDDSNL)\nMCDDDDNM DC    CL8'MCDS    '\nMCDDUNIT DC    CL8'SYSALLDA'\nMCDDVSER DC    CL8' '\nMCDDBLK  DC    F'00'\nMCDDPQTY DC    F'0'\nMCDDSQTY DC    F'0'\nMCDDDQTY DC    F'0'\nMCDDMNAM DC    CL8' '\nMCDDPSWD DC    CL8' '\nMCDDDSP1 DC    X'08' SHR\nMCDDDSP2 DC    X'08' KEEP\nMCDDDSP3 DC    X'08' KEEP\nMCDDCTL  DC    X'00'\nMCDDUID  EQU   X'20'  OR IN TO CONCAT USERID\n         DC    3X'00'\nMCDDFLG2 DC    XL1'00'\nMCDDALN  DC    CL8' '\n         SPACE 1\nMCDDSNL  DC    AL2(14)            LTH OF MCDS DSN                   RH\nMCDDSN   DC    CL44'SMS.DFHSM.MCDS'  MCDS DATASET NAME              RH\nMCDDSNL2 DC    AL2(21)            LTH OF MCDS DSN                   RH\nMCDDSN2  DC    CL44'SMS.Y2K.DFSMSHSM.MCDS'  MCDS DATASET NAME       RH\nMCDHLI   DC    CL44'SMS'          MCDS DSN HLI                      RH\n         SPACE 1\nMCDMOK   DS    0H\n*        MVC   PRTDSNL(46),MCDDSNL SET UP MCDS DSNAME AND LTH       RH\n*        MVC   PRTDDDNM(8),=CL8'MCDS' DDNAME = MCDS                 RH\n         MVC   MCDDVSER(6),TWORK+6 MOVE VOLSER TO DAIR BLOCK        RH\n*        MVI   PRTDDSP1,X'08'     DISP=SHR                          RH\n         LA    R14,MCDDRBLK       PUT A(MCDS DAIR BLOCK)            RH\n         ST    R14,DAPLDAPB       IN DAIR PARM LIST                 RH\n         LA    R1,DAPLUPT         R1 -> TO DAIR LIST                RH\n         LINK  EP=IKJDAIR         CALL DAIR                         RH\n         LTR   R15,R15            DAIR OKAY?\n         BZ    MCDMOK2            YES\n         MVI   MCDLBL0+1,X'F0'    CHANGE NOP TO B                   RH\n         SPACE 1\nMCDMOK2  DS    0H\n         B     *+4(R15)           BRANCH ON RETURNED CODE           RH\n         B     MCDSOK1            DAIR OK, CONTINUE                 RH\n         B     ABEND1  INVALID PARM LIST                            RH\n         B     ERROR10  DATA SET NOT IN CATALOG                     RH\n         B     DAIRERR  DAIR ERROR                                  RH\n         B     ERROR5  NO TIOT ENTRIES AVAILABLE                    RH\n         B     ERROR6 DDNAME NOT AVAILABLE                          RH\n         B     ERROR7 DSNAME IS MEMBER OF CONCAT GRP                RH\n         B     ABEND1 DDNAME OR DSNAME NOT ALLOC                    RH\n         B     ERROR8  OLD DATA SET                                 RH\n         B     ABEND1  ERROR IN CATALOG ROUTINE                     RH\n         B     ABEND1  OUT OF QUALIFIER ROOM                        RH\n         B     ERROR11  DELETED DATA SET                            RH\n         SPACE  1\nMCDSOK1  DS    0H                                                   RH\n         OI    MCDSW,PRINTIT      TURN ON  MCD ALLOCATED SW         RH\n         SPACE 1                                                    RH\n***********************************************************************\n*                                                                     *\n*    OPEN THE MCDS FILE.                                              *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n*\n*    BUILD THE ACB.\n*\nOPNVSAM  DS    0H\n*        TM    FLAG,FLAGEXP       SHOULD WE OPEN MCDS FILE ?        RH\n*        BO    ACBOPEN            NO, IT'S ALREADY OPEN             RH\n         L     R15,=V(MCDS)        GET ADDRESS OF ACB\n*        LA    R15,MCDS            GET ADDRESS OF ACB\n         OPEN  ((R15),(INPUT))\n         LTR   R15,R15             ERROR OPENING ACB ???\n         BZ    CKOPENS             NO, SO SEE IF ERROR WERE FOUND\n*\n*    'MCDS' ACB DID NOT OPEN.\n*\n         MVI   MCDLBL0+1,X'F0'    CHANGE NOP TO B                   RH\n         WTO   '**ERROR** MCDS ACB FAILED TO OPEN.',                   *\n               ROUTCDE=(11)\n         B     FINDUCB            BYPASS HSM FOR NOW                RH\n         SPACE 1                                                    RH\nCKOPENS  DS    0H\n         L     R1,=V(FLAG)        R1 -> TO ACB OPEN FLAG\n         OI    0(R1),FLAGEXP      SAY WE OPENED MCDS FILE           RH\n         SPACE 1                                                    RH\nACBOPEN  DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*    GETMAIN AN AREA LARGE ENOUGH TO HOLD A DSCB                      *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n         L     R2,DSCB#LEN         LENGTH FOR EACH DSCB\n         AGO   .NOLEN\n*\n*    CALCULATE THE AMOUNT OF STORAGE REQUIRED\n*\n         LA    R2,4095(,R3)        ALIGN SIZE TO 4K BOUNDARY\n         N     R2,=X'FFFFF000'\n*        C     R2,GETMLEN          DO WE HAVE ALREADY HAVE AN AREA ???\n*        BNH   READVTOC            YES, SO USE IT\n*\n*    FREEMAIN ANY PREVIOUSLY OBTAINED AREA.\n*\n*        L     R0,GETMLEN          LOAD CURRENT LENGTH\n*        L     R1,GETMADDR         LOAD CURRENT ADDRESS\n*        LTR   R0,R0               SIZE > 0 ???\n*        BZ    GETDSCB             NO\n*        FREEMAIN RU,                                                  *\n               A=(R1),                                                 *\n               LV=(R0)\n*\n*    GETMAIN A DYNAMIC WORKAREA\n*\nGETDSCB  EQU   *\n.NOLEN   ANOP\n         ST    R2,GETMLEN          STORE THE GETMAIN SIZE\n         LR    R0,R2              R0 = LTH TO GET\n         GETMAIN RU,                                                   *\n               LV=(R0)\n         ST    R1,GETMADDR         STORE THE GETMAIN ADDRESS\n         EJECT\n         SPACE 1                                                    RH\nMCDLBL2  DS    0H                                                   RH\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*    GO TO HSM TO GET A 'DSCB'                                        *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n         L     R15,=V($CHGMCDS)   R15 -> TO HSM CODE                RH\n         BALR  R14,R15            GO TO IT                          RH\n         LTR   R15,R15            DID WE GET OUR INFO?              RH\n         BZ    MCDLBL3            YES, GO ON                        RH\n         CH    R15,=H'16'         DID WE GET A VSAM DATA ALIAS?\n         BE    SAYDATA            YES\n         CH    R15,=H'20'         DID WE GET A VSAM INDEX ALIAS?\n         BE    SAYINDEX           YES\nMIGRAT3  NOP   ANYMORE            B IF ONLY WANT MIGRATED DSNS\n         B     HSMERR             NO, SAY HSM READ ERROR            RH\n         SPACE 1                                                    RH\nMCDLBL3  DS    0H                                                   RH\n*        L     R15,=V(MCDBUFF)    R15 -> TO A(HSM DATA BUFFER)      RH\n*        L     R15,0(0,R15)       R15 -> TO HSM DATA BUFFER         RH\n         L     R15,GETMADDR       R15 -> TO FORMATTED HSM DSCB      RH\n         ST    R15,PARMLMCD       PASS IT TO PLI PGM                RH\n         B     PLILINK            GO TO PLI CODE                    RH\n         SPACE  1\n         ENTRY GETMADDR\nGETMADDR DC    F'0'\nGETMLEN  DC    F'0'\nDSCB#LEN DC    A(148)\n         SPACE  1\nXMOVE    MVC   0(0,R4),0(R3)\n         SPACE  1\nDAIRLINK DS    0H\n*                                                                   RH\n*              SINCE WE NO LONGER  USE  OPER AS A MEANS             RH\n*              OF DETERMINING WHICH  PACKS A USER CAN               RH\n*              SEE, DROP THE VOLSER TESTS.                          RH\n*                                                                   RH\n*        TM    PSCBATR1,PSCBCTRL   CAN HE USE OPER ?\n*        BO    NOCHEK              YES, LET HIM LOOK AT ANY PACK\n*        CLI   TUPAR1,C'I'         IPO PACK?\n*        BE    VOLERR              YES, HE CAN'T LOOK AT IT\n*        CLI   TUPAR1,C'S'         OTHER SYSTEM PACKS? (SSG)\n*        BE    VOLERR              YES, HE CAN'T SEE THEM EITHER\n*        CLI   TUPAR1,C'P'         OTHER SYSTEM PACKS? (PAGE)\n*        BE    VOLERR              YES, HE CAN'T SEE THEM EITHER\n*        L     R15,UCBADDR        R15 -> TO UCB ENTRY               RH\n*        SR    R1,R1              CLEAR R1                          RH\n*        ICM   R1,3,0(R15)        R1 -> TO UCB                      RH\n*        CLI   19(R1),X'0B'       IS IT A 3350 ?\n*        BNE   VOLERR             NO, HE CAN'T SEE THEM EITHER\n         SPACE 1\nNOCHEK   DS    0H\nDOSVC99  DS    0H\n         MVI   S99VERB,X'01'      SAY WE WANT TO ALLOCATE BY DSNAME\n*                                 BECAUSE FOR SOME STRANGE REASON\n*                                 ALLOCATE BY DDNAME (06) DOES\n*                                 NOT WANT TO WORK\n         MVC   TUPAR2,TUPAR1      MOVE VOLSER TO TEXT UNIT 2\n         LA    R1,S99RB           R1 -> TO SVC 99 RB FOR ALLOC\n         ST    R1,FAILPARM        PUT SVC99 PARM LIST IN DAIRFAIL\n         LA    R1,S99TUPL         R1 -> TO SVC 99 PARMS FOR ALLOC\n         ST    R1,S99TXTPP        PUT IT IN SVC 99 RB\n         LA    R1,S99RBPTR        R1 -> TO SVC 99 PARMS\n         SVC   99\n         LTR   R15,R15            WAS SVC99 OKAY?\n         BZ    DAIROK             YES\n         ST    R15,DAIR15         SAVE SVC 99 ERROR CODE\n*        B     *+4(R15)  BRANCH ON RETURNED CODE\n*        B     DAIROK\n*        B     ERR04              DAIR ERROR\n*        B     ERROR12            DENIED BY INSTALLATION EXIT\n*        B     ABEND1  INVALID PARM LIST\nERR04    EQU   *\n*\n*              CONVERT REASON CODE TO DECIMAL\n*\n         UNPK  ERR04RC(5),S99ERROR(3) UNPACK 4 DIGIT REASON CODE\n         MVI   ERR04RC+4,X'EF'    TRANSLATES TO BLANK\n         TR    ERR04RC(5),TRTAB-239 TRANSLATE TO DISPLAY\n         MVI   ERR04RC+4,C'-'     CHANGE BLANK TO DASH\n*\n*              CONVERT INFO CODE TO DECIMAL\n*\n         UNPK  ERR04IN(5),S99INFO(3) UNPACK 4 DIGIT INFO CODE\n         MVI   ERR04IN+4,X'EF'    TRANSLATES TO BLANK\n         TR    ERR04IN(5),TRTAB-239 TRANSLATE TO DISPLAY\n*\n*        LA    R1,X'218'          CHECK FOR 218 ERROR...\n*        CH    R1,S99ERROR        WAS IT?\n*        BNE   DAIRERR            NO, GO SET UP DAIR ERROR\n         MVC   ERR04DSN,LVLBUF+2  PUT DSN IN MSG\n         MVC   ERR04VOL,TUPAR1    PUT VOLSER IN MSG\n         PUTIT ERR04MSG,ERR04LTH,RET=YES PRINT IT\n*        B     DAIROK             ON WE GO...IF RET=YES...\n         L     R15,DAIR15         LOAD SVC 99 ERROR CODE\n         B     *+4(R15)           BRANCH ON RETURNED CODE\n         B     DAIROK             IT WAS OKAY...\n         B     DAIRERR            DAIR ERROR\n         B     ERROR12            DENIED BY INSTALLATION EXIT\n         B     ABEND1  INVALID PARM LIST\n*\n         SPACE 5\nDAIROK   DS    0H\n         SPACE 5\nPLILINK  LA    R1,PARML\n         L     R15,=V(PLICALLA)\n         BALR  R14,R15\n         CLC   =C'MIGRAT',TUPAR1  HAS DATASET BEEN MIGRATED?        RH\n         BE    ANYMORE            YES, DON'T DO DEALLOCATE          RH\n         SPACE 1\nFREEUNIT DS    0H\n         MVI   S99VERB,X'02'      CHANGE TO UNALLOCATE\n         LA    R1,S99TUPL2        R1 -> TO SVC 99 PARMS FOR FREE\n         ST    R1,S99TXTPP        PUT IT IN SVC 99 RB\n         LA    R1,S99RBPTR        R1 -> TO SVC 99 PARMS\n         SVC   99\n         B     *+4(R15)  BRANCH ON RETURNED CODE\n         B     ANYMORE            0, SEE IF ANY MORE PACKS TO TRY\n         B     DAIRERR            4, DAIR ERROR\n         B     ERROR12            8, DENIED BY INSTALLATION EXIT\n         B     ABEND1             12,  INVALID PARM LIST\n         SPACE 1\nANYMORE  DS    0H\n         SPACE 1\nNXTVOL   DS    0H\n         CLC   VOLCNT,=H'0'       ANY VOLS TO PROCESS?\n         BE    ENDVOLS2           NO\n         SR    R15,R15            MAKE SURE R15 IS 0\n         LH    R1,VOLCNT2         R1 = NBR VOLS PROCESSED\n         CH    R1,VOLCNT          HAVE WE DONE THEM ALL?\n         BE    ENDVOLS            YES\n         MH    R1,=H'12'          R1 = OFFSET TO NEXT VOL\n         LA    R15,TVOL           R15 -> 1ST VOLSER\n         AR    R15,R1             R15 -> TO NEXT VOLSER\n         MVC   TUPAR1(6),0(R15)   PUT NEXT VOLSER IN OBTAIN AREA\n         LH    R1,VOLCNT2         R1 = NBR VOLS PROCESSED\n         LA    R1,1(0,R1)         ADD 1\n         STH   R1,VOLCNT2         SAVE IT\n         B     OBTAIN1            GO PROCESS IT\n         SPACE 1\nENDVOLS  DS    0H\n         LA    R1,0               R1 = 0\n         STH   R1,VOLCNT          CLEAR VOLCNT FROM LOCATE\n         LA    R1,1               R1 = 1\n         STH   R1,VOLCNT2         R1 = NBR VOLS PROCESSED\n         SPACE 1\nENDVOLS2 DS    0H\n         CLC       VOLNXT(4),=XL4'FF000000'  ANY MORE VOLS ?\n         BE        RETURN         NO\n         OI        SWITCHWD,MULTIVOL  INSERT FOR CUMMULATIVE TOTALING\n         L     R6,VOLNXT\n         CH    R8,=H'1'                  ALLOC DSN SUPPLIED?\n         BNE   NOTSUPV                   NO\n         CLC   SVDNXT,=XL4'FF000000'     ANY MORE ALLOC DSNS?\n         BE    RETURN                    NO, END OF DSPACE\n         L     R5,SVDNXT                 YES, R5 -> TO NEXT ALLOC  DSN\n         B     SUPVDSRT                  GO GET IT\nSW1RTN   DS    0H\n         OI    SWITCHWD,MULTIVOL      INSERT FOR CUMMULATIVE TOTALING\n         B     NOTSUPV\n         SPACE 1\nSAYDATA  DS    0H\n         MVI   ABENDFLG,X'00'     SET ABEND FLAG TO CONTINUE\n         MVC   ERRMSG,DATAMSG     MSG = VSAM DATA OBJECT NAME\n         B     VOLERR2            SET UP REST OF MSG\n         SPACE 1\nSAYINDEX DS    0H\n         MVI   ABENDFLG,X'00'     SET ABEND FLAG TO CONTINUE\n         MVC   ERRMSG,INDEXMSG    MSG = VSAM INDEX OBJECT NAME\n         B     VOLERR2            SET UP REST OF MSG\n         SPACE 1\nHSMERR   DS    0H\n         MVI   ABENDFLG,X'00'     SET ABEND FLAG TO CONTINUE\n         MVC   ERRMSG,HSMMSG      MSG = ERROR READING HSM\n         B     VOLERR2            SET UP REST OF MSG\n         SPACE 1\nGDGBASE  DS    0H\n         MVI   ABENDFLG,X'00'     SET ABEND FLAG TO CONTINUE\n         MVC   ERRMSG,BASEMSG     MSG = GDG BASE\n         MVC   TUPAR1,=CL6' '     BLANK OUT VOLSER FIELD\n         B     VOLERR2            SET UP REST OF MSG\n         SPACE 1\nALIASNAM DS    0H\n         MVI   ABENDFLG,X'00'     SET ABEND FLAG TO CONTINUE\n         MVC   ERRMSG,ALIASMSG    MSG = ALIAS NAME\n*        MVC   TUPAR1,=CL6' '     BLANK OUT VOLSER FIELD\n         B     VOLERR2            SET UP REST OF MSG\n         SPACE 1\nNOTDISK  DS    0H\n         MVI   ABENDFLG,X'00'     SET ABEND FLAG TO CONTINUE\n         TM    TWORK+4,X'80'      IS DSN ON A TAPE ?\n         BZ    NOTTAPE            NO\n*        BNE   NOTTAPE            NO\n         TM    TWORK+5,X'80'      IS DSN ON A TAPE CARTRIDGE?\n         BZ    NOTCART            NO\n*        BNE   NOTCART            NO\n         MVC   ERRMSG,CARTMSG     MSG = CARTRIDGE TAPE DATASET\n         B     VOLERR2            SET UP REST OF MSG\n*\nNOTCART  DS    0H\n         MVC   ERRMSG,TAPEMSG     MSG = TAPE DATASET\n         B     VOLERR2            SET UP REST OF MSG\n*\nNOTTAPE  DS    0H\n         MVC   ERRMSG,UNKNMSG     MSG = UNKNOWN DEVICE TYPE\n         B     VOLERR2            SET UP REST OF MSG\n         SPACE 2\nVOLERR   DS    0H\n         MVC   ERRMSG,NTVALMSG    MSG = NOT VALID FOR YOUR USE\n         CLC   =C'MIGRAT',TUPAR1  WANT MIGRATED DATASETS            RH\n         BNE   VOLERR2            NO, SAY NOT VALID                 RH\n         MVC   ERRMSG,MIGMSG      MSG = DATASET WAS MIGRATED BY HSM\n         SPACE 1\nVOLERR2  DS    0H\n         MVC   ERRVOL,TUPAR1         MOVE BAD VOL TO MSG\n         MVC   ERRDSN,LVLBUF+2       MOVE DSN TO ERR MSG\n         MVC   MSG(L'VOLMSG),VOLMSG  MOVE BAD VOL MSG TO PRINT\n         B     PRINTMS1           PRINT IT, THEN GOTO ANYMORE\n*        LA    R14,ANYMORE        GO HERE NEXT...\n*        B     PRINTNOP           ON WE GO                          RH\n         SPACE 1\nPRINTMSG DS    0H\n         LTR   R14,R14            IS R14 SET?\n         BP    PRINTMS2           YES\n         SPACE 1\nPRINTMS1 DS    0H\n         LA    R14,ANYMORE        NO, GO HERE NEXT...\n         SPACE 1\nPRINTMS2 DS    0H\n         ST    R14,RETADDR        SAVE RETURN ADDRESS\nPRINTNOP B     PRINTPUT           NOP IF BATCH  FILE OPEN           RH\n         PUT   REPORT,INFO1       OUTPUT THE MSG\n         SPACE 1\nCLEARMSG DS    0H\n         MVI   MSG,C' '           CLEAR PRINT LINE\n         MVC   MSG+1(131),MSG     *\n         CLI   ABENDFLG,X'FF'     SHOULD WE END DS CMD ?\n         BE    RETURN             YES\n*        B     ANYMORE            NO, GO SEE IF ANY MORE PACKS\n         L     R14,RETADDR        LOAD RETURN ADDRESS\n         BR    R14                GO DO NEXT INST...\n         SPACE 1\nPRINTPUT DS    0H                                                   RH\n         TM    SWITCHWD,PRINTIT   DOES HE WANT OUTPUT IN A FILE?\n         BO    PRINTOUT           YES\n         TM    SWITCHWD,OFFLIST   PRINT THE MSG?            JAN96   RH\n         BO    CLEARMSG           NO                        JAN96   RH\n*        TPUT  MSG,88   (WAS 44)  TPUT MSG RATHER THAN PUT          RH\n*        LA    R1,88              LTH TO PRINT\n         CALL  TSOPUT,(PUTMSG),VL  PRINT IT\n         B     CLEARMSG           CLEAR OUT MSG AREA                RH\n         SPACE 1\nPRINTOUT DS    0H                                                   RH\n         PUT   PRTDCB,INFO1       PUT MSG IN FILE                   RH\n         B     CLEARMSG           CLEAR OUT MSG AREA                RH\n         SPACE  1\nDONE     DS     0H\n         MVI   SW2,X'00'          TURN ALL SW2 OFF\n         TM    SWITCHWD,TOTALIT   DOES HE WANT TOTALS ?\n         BZ    RETURN             NO, END OF DS\n         OI    SWITCHWD,TOTALS+PERCENTS SAY PRINT TOTALS ONLY\n         LA    R1,PARML           R1 -> TO PLI PARMS\n         L     R15,=V(PLICALLA)   R15 -> TO PLI PGM\n         BALR  R14,R15            GO FOR IT\n         NI    SWITCHWD,255-TOTALS-PERCENTS TURN PRINT TOTALS ONLY OFF\n         SPACE 5\nRETURN   TM    SW1,X'01'           DOING ALL VOLS?\n         BO    SW1RTN              YES, GET NEXT VOL\n         TM    SW2,X'80'          DOING ALL DSNAMES BY CATLG ?\n         BO    NEXTDSNA           YES, GET NEXT DSNAME ADDRESS\n         SPACE 1\nRETURN2  DS    0H\n         TM    SW3,SW380+SW340    DOING BATCH WITH SYSIN ?\n         BO    GETIN              YES, GET NEXT DSNAME\n         SPACE 1                                                    RH\nENDBATCH DS    0H\n         TM    MCDSW,PRINTIT      WAS MCD ALLOCATED ?               RH\n         BZ    RET0               NO, DON'T TRY TO CLOSE IT         RH\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*    CLOSE THE VSAM FILE:  MCDS.                                      *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n*\n*    CLOSE THE VSAM FILES.\n*\n         SPACE\nCLSVSAM  DS    0H\n         L     R6,=V(FLAG)        R6 -> TO ACB OPEN FLAG\n         TM    0(R6),FLAGEXP      DID WE OPEN MCDS FILE ?           RH\n         BZ    CLSNVSAM           NO, DON'T TRY TO CLOSE IT         RH\n         L     R6,=V(MCDS)        R6 -> TO MCDS ACB\n*        LA    R6,MCDS\n         CLOSE ((R6))\n*        LTR   R15,R15             CLOSE SUCCESSFUL ???\n*        BZ    CLSNVSAM            YES, SO CLOSE NON-VSAM FILES\n*\n*    ISSUE MESSAGE THAT THE MCDS DID NOT CLOSE.  THIS ISN'T VERY\n*    SERIOUS AS THE PROGRAM HAS FINISHED.\n*\n*        CALL  $CHGERR,(MAIN03),VL\n*        LA    R1,2                LOAD WARNING RETURN CODE\n*        C     R1,RETCODE          WARNING <= RETURN CODE ???\n*        BNH   CLSNVSAM            YES, SO DO NOT UPDATE RETURN CODE\n*        ST    R1,RETCODE          STORE WARNING RETURN CODE\n         SPACE 1\nCLSNVSAM DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*    DEALLOCATE THE MCDS FILE                                         *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n         LA    R1,DA18CD          R1 -> TO FREE DAIR BLK            RH\n         ST    R1,DAPLDAPB        PUT FREE BLK ADDR IN DAIR UPT     RH\n         MVC   DA18DDN(8),MCDDDDNM MOVE MCDS DDN TO DA18 BLOCK      RH\n         MVI   DA18DPS2,X'08'      KEEP MCDS DATA SET               RH\n         LA    R1,DAPLUPT         R1 -> TO DAIR UPT                 RH\n         LINK  EP=IKJDAIR         LINK TO DAIR                      RH\n         LTR   R15,R15            WAS MCDS FREED?\n         BZ    MCDSFREE           YES, SO CLOSE NON-VSAM FILES\n         NI    MCDSW,255-PRINTIT  SAY MCD NOT ALLOCATED             RH\n         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND\n         PUTIT 'HSM FILE(MCDS) NOT FREED. DO A FREE COMMAND'\n*\n         SPACE 1\nMCDSFREE DS    0H\n*\n*    FREEMAIN ANY PREVIOUSLY OBTAINED AREA.\n*\n         L     R0,GETMLEN          LOAD CURRENT LENGTH\n         L     R1,GETMADDR         LOAD CURRENT ADDRESS\n         LTR   R0,R0               SIZE > 0 ???\n         BZ    RET0                NO\n         FREEMAIN R,              DON'T ABEND IF IT CAN'T BE FREED     *\n               A=(R1),                                                 *\n               LV=(R0)\n         SPACE 1\nRET0     DS    0H\n         TM    SWITCHWD,PRINTIT   DID WE PRINT TO A FILE?           RH\n         BZ    RET1               NO, SKIP DEALLOC CRAP             RH\n         CLOSE (PRTDCB)           CLOSE IT                          RH\n         LA    R1,DA18CD          R1 -> TO FREE DAIR BLK            RH\n         ST    R1,DAPLDAPB        PUT FREE BLK ADDR IN DAIR UPT     RH\n         MVC   DA18DDN(8),=C'PRTDDNAM' MOVE PRINT DDN TO DA18 BLOCK RH\n         MVI   DA18DPS2,X'08'      KEEP PRINT DATA SET              RH\n         LA    R1,DAPLUPT         R1 -> TO DAIR UPT                 RH\n         LINK  EP=IKJDAIR         LINK TO DAIR                      RH\n         SPACE 1                                                    RH\nRET1     DS    0H\nRETNOP   B     NOCLOSE            NOP IF REPORT FILE OPEN           RH\n         CLOSE (REPORT)           CLOSE OUTPUT FILE\n         SPACE 1                                                    RH\nNOCLOSE  DS    0H\n         L     R13,4(,R13)\n         RETURN (14,12),RC=0\n         SPACE 3\n*        PRINT NOGEN\n*\nERROR2   DS    0H\n         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND\n         PUTIT 'INCOMPLETE PARAMETERS'\n*\nERROR3   DS    0H\n         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND\n         PUTIT 'NOT ENOUGH SPACE IN REGION'\n*\nERROR4   DS    0H\n         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND\n         PUTIT 'INVALID PARAMETERS'\n*\nABEND1   ABEND 1004,DUMP\nABEND2   EQU   ABEND1\n*\nERROR5   DS    0H\n         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND\n         PUTIT 'NO TIOT ENTRIES AVAILABLE'\n*\nERROR6   DS    0H\n         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND\n         PUTIT 'DDNAME NOT AVAILABLE'\n*\nERROR7   DS    0H\n         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND\n         PUTIT 'DSNAME IS MEMBER OF CONCAT. DATA SET'\n*\nERROR8   DS    0H\n         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND\n         PUTIT 'SVC 99 ERROR'\n*\nERROR9   DS    0H\n         MVI   ABENDFLG,X'00'     SET ABEND FLAG TO CONTINUE\n         MVC   MSG+40(44),LVLBUF+2 PUT DSNAME INTO MSG              RH\n         B     ERROR14            GO PRINT MSG\n*\nERROR10  DS    0H\n         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND\n         B     ERROR13            GO PRINT MSG\n*\nERROR11  DS    0H\n         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND\n         PUTIT 'DATA SET HAS BEEN DELETED'\n*\nERROR12  DS    0H\n         MVI   ABENDFLG,X'00'     SET ABEND FLAG TO CONTINUE\n         PUTIT 'REQUEST DENIED BY INSTALLATION EXIT'\n*\nERROR13  DS    0H\n         MVI   SW2,X'00'          TURN ALL CATLG BITS OFF\n*\nERROR14  DS    0H\n         PUTIT 'DATA SET NOT IN CATALOG'\n*\nDAIRERR  DS    0H\n         ST    R15,DAIR15          SAVE IKJDAIR ERROR CODE\n         LA    R1,FAILPARM         R1 -> TO DAIRFAIL PARM LIST\n         LINK  EP=IKJEFF18         LINK TO DAIRFAIL\n         LTR   R15,R15             WAS DAIRFAIL OKAY ?\n         BZ    ANYMORE             YES, ANY MORE VOLS ?\n         PUTIT 'DAIRFAIL ERROR.    CALL SYSTEMS SUPPORT'\n         SPACE 2\n         EJECT\n* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n*        WORK AREAS\n* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\nDUMPTITL DC    C'WORKING STORAGE SECTION'\n* ------ WORK  AREAS              ------------------------------------\n         LTORG\nRETADDR  DS    F                  SAVE AREA FOR RETURN ADDRESS\nSAVER9A  DS    F                  SAVE AREA FOR R9\nPSCBADDR DS    F                  PSCBADDR\n*SVCERR  DC    F'0'               SVC 99 RC IF > 0\nVOLCNT2  DC    H'1'                      VOL COUNT\nVOLLTH2  DS    0F              LTH OF MSG\n         DC    AL2(0)          TSID\n         DC    AL2(L'VOLMSG)   BUFFER SIZE\nVOLMSG   DS    0CL96              WAS 84\n         DC    CL1' '\n         DC    CL12' '            SKIP PAST CREATE/USED DATES...\nERRVOL   DC    CL6' '\nERRMSG   DC    CL32' '\n         DC    C' '\nERRDSN   DS    CL44\n*        DC    CL1' '\nERRLTH   EQU   *-ERRVOL\nNTVALMSG DC    CL32'    NOT VALID FOR YOUR USE'\nDATAMSG  DC    CL32'    VSAM DATA  OBJECT NAME'\nINDEXMSG DC    CL32'    VSAM INDEX OBJECT NAME'\nHSMMSG   DC    CL32'    ERROR READING HSM DATASET'\nBASEMSG  DC    CL32'    GDG BASE'\nCARTMSG  DC    CL32'    CARTRIDGE TAPE DATASET'\nTAPEMSG  DC    CL32'    TAPE DATASET'\nUNKNMSG  DC    CL32'    UNKNOWN DEVICE TYPE'\nMIGMSG   DC    CL32'    DATASET WAS MIGRATED BY HSM'\nALIASMSG DC    CL32'    ALIAS NAME'\n*\n*RR04MSG DS    0C\n*        DC    CL12' '\n*RR04VOL DS    CL6' '\n*        DC    CL33'   ERROR GETTING DATASET INFO'\n*RR04DSN DC    CL44' '\n*RR04LTH EQU   *-ERR04MSG\n*\nERR04MSG DS    0C\n         DC    CL12' '\nERR04VOL DS    CL6' '\nERR0433  DS    0C\n*        DC    CL33'   ERROR GETTING DATASET INFO'\n         DC    C'   SVC99 ERROR. RC='\nERR04RC  DC    CL5' '\nERR04IN  DC    CL5' '\n         DC    CL(33-(*-ERR0433))' '\nERR04DSN DC    CL44' '\nERR04LTH EQU   *-ERR04MSG\n*\nMAXMSG   DC    C' DATASET USES '\nMAXVOL   DC    CL3' '\n         DC    C' VOLUMES.'\nVOLMSGL  EQU   *-MAXMSG\n         DC    C' ONLY THE FIRST 50 ARE SHOWN'\n         DC    CL(80-(*-MAXMSG))'  '\nMAXMSGL  EQU   *-MAXMSG\n*\nIDCMSG   DC    C' ERROR CALLING IDCAMS. '\n         DC    C' DATASET MAY USE MORE THAN '\nIDCVOLM  DC    CL3' '\n         DC    C' VOLUMES.'\n         DC    CL(80-(*-IDCMSG))'  '\nIDCMSGL  EQU   *-IDCMSG\nDWORD2   DS    D\n*\nLASTDSN  DC    F'0'\n         SPACE 2\n*        TCAM   LIST\nTCAML    DS     0F\nTCFLGS   DC     X'44000000'              TCAM ON DSN\nTCAMDSN  DC     A(0)                     A(DSN)\n         DC     A(0)                     VOL POINTER\n         DC     A(TWORK)                 A(265 BYTE WORK AREA)\n         DS    0D                 PUT ON DOUBLE WORD BOUNDARY\nTWORK    DS     0CL265\nVOLCNT   DC     H'0'                     VOL COUNT\nDEVTYP   DC     XL4'00'                  DEVICE TYPE\nTVOL     DC     CL6' '                   FIRST VOL SER\n         DC     CL(265-(*-TWORK))' '     ROOM FOR 19 MORE...\n         DC     360C' '           ROOM FOR 30 MORE BY IDCAMS....\n         DC     12X'FF'           END OF LIST...\n         SPACE 2\n*\n*              SEE DIAGNOSIS:SYSTEM REFERENCE, SECTION 7, SVC 26,\n*              FOR SUPERLOC WORK AREA, OR MACRO IEZCTGPL.\n*                  NOTE... THIS WAS # LY28-1011 IN 1989.\n*\n         DS    0F\nSUPERLOC DC    X'07001100'\n         DC    A(SUPERLVL)\n         DC    A(0)\nWORKADDR DC    A(SWORK)\n         DC    A(0)\nCTGFDBK  DC    A(0)               SUPERLOCATE FEEDBACK AREA         RH\n         DC    A(0)\n         DC    A(0)\n         SPACE 3\nSWORK    DS    0F\nH265     DC    H'265'\n         DC    H'0'\n         DS    CL265\n         SPACE 3\nTRTAB    DC    C' 0123456789ABCDEF'\n         SPACE 3\n*        PARSE PARAMETER LIST\n         SPACE 2\nPPLUPT   DC    A(0)\nPPLECT   DC    A(0)\nPPLECB   DC    A(PPLECBS)\nPPLPCL   DC    A(PARMLIST)\n         DC    A(PPLANS)\nPPLCBUF  DC    A(0)\nPPLUWA   DC    A(0)\n         SPACE 1\nPPLECBS  DC    A(0)\nPPLANS   DC    A(0)  ANSWER PLACE\n         SPACE 5\n*        DAIR ALLOCATE BY DSNAME BLOCK FOR PRINT FILE               RH\n         SPACE 2\nPRTDRBLK DS    0F\nPRTDCD   DC    X'0008'\nPRTDFLG  DC    H'0'\nPRTDDARC DC    H'0'\nPRTDCTRC DC    H'0'\nPRTDDSN  DC    A(PRTDSNL)\nPRTDDDNM DC    C'PRTDDNAM'\nPRTDUNIT DC    CL8'SYSALLDA'\nPRTDVSER DC    CL8' '\nPRTDBLK  DC    F'00'\nPRTDPQTY DC    F'0'\nPRTDSQTY DC    F'0'\nPRTDDQTY DC    F'0'\nPRTDMNAM DC    CL8' '\nPRTDPSWD DC    CL8' '\nPRTDDSP1 DC    X'08' SHR\nPRTDDSP2 DC    X'08' KEEP\nPRTDDSP3 DC    X'08' KEEP\nPRTDCTL  DC    X'00'\nPRTDUID  EQU   X'20'  OR IN TO CONCAT USERID\n         DC    3X'00'\nPRTDFLG2 DC    XL1'00'\nPRTDALN  DC    CL8' '\n         SPACE 1\n         ENTRY DDSNAML,DSNAME\n*DDSNAML  DC    AL2(L'SPACDSN+L'DSPADSN)\nDDSNAML  DC    AL2(44)\nDDSNAM   DS    0CL44\nDSNAME   DS    0CL44\nDSPADSN  DC    C'            '\nSPACDSN  DC    C'      '\n         DC    CL(44-L'SPACDSN-L'DSPADSN)' '\nPRTDSNL  DC    AL2(44)\nPRTDSN   DC    CL44' '\n         SPACE 1                                                    RH\n         ENTRY PRTDCB\nPRTDCB   DCB   DSORG=PS,DDNAME=PRTDDNAM,MACRF=PM,RECFM=FBA,         RH C\n               LRECL=133,BLKSIZE=19019                              RH\n         SPACE 5\n*        DAIR PARAMETER LIST\n         SPACE 2\nDAPLUPT  DC    A(0)\nDAPLECT  DC    A(0)\nDAPLECB  DC    A(DAPLECBS)\nDAPLPSCB DC    A(0)\nDAPLDAPB DC    A(PRTDRBLK)\nDAPLECBS DC    A(0)\n         SPACE 5\n*        DAIR DEALLOCATE BY DDNAME BLOCK\n         SPACE 2\n         DS    0F\nDA18CD   DC    X'0018'\nDA18FLG  DC    H'0'\nDA18DARC DC    H'0'\nDA18CTRC DC    H'0'\nDA18DSN  DC    F'0'\nDA18DDN  DC    CL8' '\nDA18MEM  DC    CL8' '\nDA18SCLS DC    CL2' '\nDA18DPS2 DC    X'08'\nDA18CTL  DC    X'10'              UNALLOCATE PERM. ALLOC DSNS\n         DC    8X'00'\n         SPACE 5\n* PL/1 PARAMETER LIST\n         DS    0D\nPARML    DC         A(PLEVEL)\n         DC         A(PVOL)\n         DC         A(PMAX)\n         DC         A(PDD)\n         DC    A(PLSW)\n         DC    XL1'80',AL3(PARMLMCD)\n*\n         ENTRY LVLBUF\nPLEVEL   DC    A(LVLBUF),H'44',X'8000'\nLVLBUF   DC    AL2(*-*),CL44' '\nSUPERLVL DC    AL1(*-*),CL45' '\nSAVPART  DC    AL2(*-*),CL44' '\n**\nABENDFLG DC    X'00'              FLAG FOR ABEND OR NOT\n**\nPVOL     DC    A(TUPAR1),H'6',X'0000'\n*\nPMAX     DC    A(MAXBUF),H'8',X'8000'\nMAXBUF   DC    AL2(*-*),CL8' '\n*\nPDD      DC    A(PRTDDDNM)                                          RH\nPDDLTH   DC    H'8',X'0000'\n*\nPARMLMCD DC    A(0),H'1',X'0000'\n*\nPLSW     DC    A(SWITCHWD),H'1',X'0000'\n         ENTRY SWITCHWD\nSWITCHWD DC    BL1'00000000'      DEFAULT IS TOTAL(NO)\n*W1      DC         X'00'\nPRINTIT  EQU   B'10000000'\nTOTALIT  EQU   B'01000000'\nPERCENTS EQU   B'00100000'\nMULTIVOL EQU   B'00010000'\nOFFLIST  EQU   B'00001000'\nHLILIST  EQU   B'00000100'        HIGH LEVEL INDEX SWITCH\nHEADING  EQU   B'00000010'        PRINT HEADING ONLY SWITCH\nTOTALS   EQU   B'00000001'        PRINT TOTALS ONLY SWITCH\n*\nSW1      DC    X'00'\nSW101    EQU   X'01'              DO ALL VOLS SWITCH\n*\nSW2      DC         X'00'\nSW280    EQU   X'80'              PROCESSING AN INDEX\nSW240    EQU   X'40'              DSN IS OK\nSW220    EQU   X'20'              PROCESSING A GDG\nSW210    EQU   X'10'              PROCESSING A PARTIAL DSN\nSW204    EQU   X'04'              SPECIFIED VOLUME NOT FOUND\n*\nSW3      DC         X'00'\nSW380    EQU   X'80'              THIS IS A BATCH RUN\nSW340    EQU   X'40'\nSW320    EQU   X'20'\nSW310    EQU   X'10'\n*\n         SPACE 1\nNUMENTS  DC    F'1'               INITIALLY 1 ENTRY (0)\nUCBTABLE DC    500Y(0)\nUCBTABLN DC    A((*-UCBTABLE)/2)  NBR OF 2 BYTE ENTRIES IN TABLE    RH\nVOLSAVE  DC    5F'0'\nUCBADDR  DC    F'0'\nPRTDDN   DC    CL8' '             DEFAULT TO NO PRINT DDNAME        RH\n         SPACE 2\nFAILPARM DC    A(DAPLUPT)         OR A(S99RB  ) FOR SVC 99...       RH\n         DC    A(DAIR15)\n         DC    A(JEFF02)\n         DC    A(FAILSW)\nCPPLADDR DC    A(0)\n         DC    A(DFBUFS)\nDAIR15   DC    F'0'               SVC 99 RETURN CODE\nJEFF02   DC    A(0)\nFAILSW   DC    X'0001'            DAIR\n*              X'0032'            SVC 99\n*              X'0033'            SVC 99 FREE\nDFBUFS   DS    0F\n         DS    AL2\n         DS    AL2\n         DS    CL251\n*        DS    0H\n         DS    AL2\n         DS    AL2\n         DS    CL251\n         SPACE 1\n         DS    0H\nPUTMSG   DC    A(PUT1MSG)\nPUT1MSG  DC    AL2(88)            AL2(PUTLTH1) CAUSES 66D-08 ABEND.\nINFO1    DS    0CL133\n*        DC    C'0'\nMSG      DC    CL44' '\nCTLTOTAL DC    CL8' '\n         DC    CL80' '\n         DC    C' '\nPUTLTH1  EQU   *-INFO1\n         EJECT\n*        DCB'S  FOR FILES\n*\n* ------ DCB'S                    ------------------------------------\nREPORT   DCB   DSORG=PS,DDNAME=SYSPRINT,LRECL=133,RECFM=FBA,        XXXX\n               MACRF=(PM),BLKSIZE=133\nSYSIN    DCB   DSORG=PS,DDNAME=SYSIN,LRECL=80,RECFM=FB,             XXXX\n               MACRF=(GL),EODAD=ENDBATCH\n         EJECT\n*              CONTROL BLOCKS FOR  SVC 99\n         SPACE 1\n         DS    0F                 PUT ON FULLWORD BOUNDARY\nS99RBPTR DC    XL1'80'\n         DC    AL3(S99RB)\nS99RB    DS    0F\nS99RBLN  DC    AL1(20)\nS99VERB  DC    AL1(1)             ALLOCATE BY DSNAME\nS99FLAG1 DC    XL2'2000'          DON'T MOUNT VOLS OR CONSIDER OFFLINES\nS99ERROR DC    AL2(0)\nS99INFO  DC    AL2(0)\nS99TXTPP DC    A(S99TUPL)\nS99RES1  DC    A(0)\nS99FLAG2 DC    A(0)\n         SPACE 1\nS99TUPL  DS    0F\nTUPL1    DC    A(TUNIT1)\nTUPL2    DC    A(TUNIT2)\nTUPL3    DC    A(TUNIT3)\nTUPL4    DC    A(TUNIT4)\nTUPL6    DC    A(TUNIT6)\nTUPL7    DC    XL1'80'\n         DC    AL3(TUNIT7)\n         SPACE 1\nS99TUPL2 DS    0F\nTUPL21   DC    A(TUNIT1)\nTUPL22   DC    A(TUNIT22)\nTUPL27   DC    XL1'80'\n         DC    AL3(TUNIT7)\n         SPACE 1\nTUNIT1   DS    0C\nTUKEY1   DC    AL2(1)             ALLOCATE BY DDNAME\nTUNUM1   DC    AL2(1)\nTUENT1   DS    0C\nTULNG1   DC    AL2(6)             LTH OF DDNAME\nTUPAR1   DC    CL6'XXXXXX'        DDNAME\n         SPACE 1\nTUNIT2   DS    0C\nTUKEY2   DC    XL2'0010'          VOL SER\nTUNUM2   DC    AL2(1)\nTUENT2   DS    0C\nTULNG2   DC    XL2'0006'          LTH OF VOL SER\nTUPAR2   DC    CL6' '             VOL SER\n         SPACE 1\nTUNIT3   DS    0C\nTUKEY3   DC    XL2'0015'          UNIT TYPE\nTUNUM3   DC    AL2(1)\nTUENT3   DS    0C\nTULNG3   DC    AL2(5)             LTH OF UNIT TYPE\nTUPAR3   DC    CL8'     '         DEFAULT UNIT TYPE  WAS SYSDA.0199\n         SPACE 1\nTUNIT4   DS    0C\nTUKEY4   DC    XL2'0016'          UNIT COUNT\nTUNUM4   DC    AL2(1)\nTUENT4   DS    0C\nTULNG4   DC    AL2(1)             LTH OF UNIT COUNT\nTUPAR4   DC    XL1'01'            UNIT COUNT IS 1\n         SPACE 1\nTUNIT6   DS    0C\nTUKEY6   DC    XL2'0004'          STATUS OF UNIT\nTUNUM6   DC    AL2(1)\nTUENT6   DS    0C\nTULNG6   DC    AL2(1)             LTH OF STATUS\nTUPAR6   DC    X'08'              STATUS = SHR\n*        DC    X'02'              STATUS = MOD\n*        DC    X'04'              STATUS = NEW\n*        DC    X'01'              STATUS = OLD\n         SPACE 1\nTUNIT7   DS    0C\nTUKEY7   DC    XL2'0005'          STATUS 2..DISP=(OLD,KEEP)\nTUNUM7   DC    AL2(1)\nTUENT7   DS    0C\nTULNG7   DC    AL2(1)             LTH OF STATUS 2\nTUPAR7   DC    X'08'              DISP= KEEP\n         SPACE 1\nTUNIT22  DS    0C\nTUKEY22  DC    XL2'0007'          UNALLOC EVEN IF PERM ALLOC\nTUNUM22  DC    AL2(0)\n         SPACE 1\nPARMLST2 DS    3F                 PARMLIST MAPPING\n         ORG   PARMLST2\nPARMWA   DC    A(WORKAREA)        ADDRESS OF 100-BYTE WORKAREA\nPARMDEVT DC    A(DEVCLASS)        ADDRESS OF BYTE CONTAINING\n*                                 THE DEVICE TYPE TO BE SEARCHED\nPARMUCB  DC    AL1(80)            ADDRESS OF WORD TO CONTAIN THE\n         DC    AL3(ADDRUCB)       THE UCB ADDRESS\n         SPACE 1\nDEVCLASS DC    XL1'20'            BYTE CONTAINING DEVICE CLASS\n*                                 TO BE SEARCHED FOR\n*                                 X'20' IS DIRECT ACCESS\nADDRUCB  DS    F                  WORD IN WHICH UCBSCAN WILL\n*                                 PLACE THE ADDRESS OF THE UCB\n         DS    0D                 ALIGN TO DOUBLE-WORD BOUNDARY\n*                                 THE WORKAREA FOR SCAN SERVICE\n*                                 MUST BE ON A DOUBLE-WORD BOUNDARY\nWORKAREA DS    CL100              WORKAREA\nUCBAREA  DS    CL48               WORKAREA FOR UCB\nCMXTAREA DS    CL32               WORKAREA FOR UCB\nDCELEN   DC    AL2(128)           WORKAREA FOR UCB\nDCEAREA  DS    CL128              WORKAREA FOR UCB\n         SPACE 1\n         LTORG\n         SPACE 1\n*        IEFUCBOB                 UCB MAPPING MACRO\n*        CVT   DSECT=YES\n*              NOTE..THE ABOVE MACROS ARE IN SYS1.AMODGEN\n         SPACE 1\n*\n*\nCHECKPTR EQU  3\nCHECKPDE EQU  4\nUT2      EQU  2\n*0       EQU   0\n*1       EQU   1\n*2       EQU   2\n*3       EQU   3\n*4       EQU   4\n*5       EQU   5\n*6       EQU   6\n*7       EQU   7\n*8       EQU   8\n*9       EQU   9\n*10      EQU   10\n*11      EQU   11\n*12      EQU   12\n*13      EQU   13\n*14      EQU   14\n*15      EQU   15\nPARMLIST IKJPARM\n*EVEL    IKJPOSIT  DSNAME,                                             X\n               VALIDCK=DSNCHECK,                                       X\n               HELP=('LEVEL OF INDEX','STRING FOR DSNAME SEARCH')\nLEVEL    IKJIDENT  'DSNAME',LIST,MAXLNTH=44,                           X\n               FIRST=ALPHANUM,OTHER=ANY,CHAR,                          X\n               VALIDCK=DSNCHECK,                                       X\n               HELP=('LEVEL OF INDEX','STRING FOR DSNAME SEARCH')\nVOLKWD   IKJKEYWD   DEFAULT='VOL'\n         IKJNAME    'VOL',SUBFLD=VOLSUB\nSUPV     IKJKEYWD\n         IKJNAME    'ALLOC',SUBFLD=SUPERALL\nUNTKWD   IKJKEYWD\n         IKJNAME    'UNIT',SUBFLD=UNTSUB\nPRNTKWD  IKJKEYWD\n         IKJNAME    'PRINT',SUBFLD=PRNTDD\nMCDSKWD  IKJKEYWD\n         IKJNAME    'MCDS',SUBFLD=MCDSDD\nACCUMKWD IKJKEYWD\n         IKJNAME    'TOTAL',SUBFLD=PERCENT\nDSNCTKW  IKJKEYWD   DEFAULT='MAX'\n         IKJNAME    'MAX',SUBFLD=DSNCTSBF\nLISTKWD  IKJKEYWD   DEFAULT='LIST'\n         IKJNAME    'LIST'\n         IKJNAME    'NOLIST'\nVOLSUB   IKJSUBF\nSERS     IKJIDENT  'VOL SERS',LIST,MAXLNTH=6,                          X\n               FIRST=ALPHANUM,OTHER=ALPHANUM,                          X\n               VALIDCK=VOLCHECK,                                       X\n               HELP=('VOLUME TO BE SEARCHED FOR DATA SETS')\nSUPERALL IKJSUBF\nSVDSN    IKJPOSIT  DSNAME,LIST,PROMPT='DSN TO BE ALLOCATED'\nUNTSUB   IKJSUBF\nUNIT     IKJIDENT  'UNIT TYPE',FIRST=ANY,OTHER=ANY,MAXLNTH=5\nPRNTDD   IKJSUBF\nPRINTDD  IKJPOSIT   DSNAME,USID,HELP='DSNAME OF PRINT OUTPUT FILE'  RH\nMCDSDD   IKJSUBF\nMCDSDSN  IKJPOSIT   DSNAME,USID,HELP='DSNAME OF HSM MIGRATE FILE'   RH\nPERCENT  IKJSUBF\nPERCKWD  IKJKEYWD   DEFAULT='YES'\n         IKJNAME    'NO'\n         IKJNAME    'YES'\nDSNCTSBF IKJSUBF\nDSNCT    IKJIDENT   '# OF DATA SETS',FIRST=NUMERIC,OTHER=NUMERIC,      X\n               MAXLNTH=8,DEFAULT='9999'\n         IKJENDP\n*\n*\n         PRINT GEN\n         IKJCPPL\n         IKJIOPL\n         IKJPSCB\nLVLDX    DSECT\nLVLPTR   DS    A\nLVLLTH   DS    H\nLVLFLG   DS    BL2\nLVLNXT   DS    A\n*\n*\nVOLDX    DSECT\nVOLPTR   DS    A\nVOLLTH   DS    H\nVOLFLG   DS    BL2\nVOLNXT   DS    A\n*\n*\nSVDDX    DSECT\nSVDPTR   DS    A\nSVDLTH   DS        H\nSVDFLG   DS    BL2\nSVDXXX   DS    2D\nSVDNXT   DS    A\n*\n*\nUNTDX    DSECT\nUNTPTR   DS     A\nUNTLTH   DS     H\nUNTFLG   DS     BL2\n*\nPRNTDX   DSECT      DESCRIPTION OF PRINTDD SUBF OF PRINT KWD\nPRNTPTR  DS         A\nPRNTLTH  DS         H\nPRNTFLG  DS         BL2\nPRINTON  EQU        X'80'\n*\nTOTDX    DSECT      DESCRIPTION OF TOTAL KWD\nTOTTYPE  DS         H\nTOTON    EQU        X'01'\nTOTOFF   EQU        X'00'\n*\nPERCDX   DSECT      DESCRIPTION OF PERCENT KWD\nPERCTYPE DS         H\nPERCYES  EQU        X'02'\nPERCNO   EQU        X'01'\n*\nDSNCTDX  DSECT      DESCRIPTION OF MAX KWD SUBF\nDSNCTPTR DS         A\nDSNCTLTH DS         H\nDSNCTFLG DS         BL2\nDSNCTON  EQU        X'80'\n*\nLISTDX   DSECT       LIST KEYWORD DSECT\nLISTTYPE DS         H\nLISTON   EQU        X'01'\nLISTOFF  EQU        X'02'\n*\n         EJECT\nVOLCHECK CSECT\n         STM   R14,R12,12(R13)\n         BALR  BASE,0\n         USING *,BASE\n         LR    CHECKPTR,R1\n         L     R0,ALWORK\n         GETMAIN   R,LV=(0)\n         XC    0(LWORK,R1),0(R1)\n         ST    R1,8(R13)\n         ST    R13,4(R1)\n         LR    R13,R1\n         L     CHECKPDE,0(CHECKPTR)\n         LH    UT2,4(CHECKPDE)\n         CH    UT2,=H'6'\n         BNE   BADLTH\n         LA    R15,0\nGOBACK   LR    R1,R13\n         L     R13,4(R1)\n         L     R0,ALWORK\n         LR    R10,R15            SAVE R15 OVER FREEMAIN\n         FREEMAIN  R,LV=(0),A=(1)\n         LR    R15,R10            RELOAD R15\n         LM    R0,R12,20(R13)\n         L     R14,12(R13)\n         BR    R14\nBADLTH   LA    R15,4\n         LA    UT2,MBADLTH\n         ST    UT2,8(CHECKPTR)\n         B     GOBACK\n         DS    0D\nALWORK   DC    AL1(0),AL3(LWORK)\nLWORK    EQU   72\nMBADLTH  DC    AL4(0),AL2(L'MSGBADL+4),AL2(0)\nMSGBADL  DC    C' VOL SER MUST BE SIX CHARACTERS IN LENGTH '\nLIT2     LTORG\n         EJECT\n*\n*              CHECK THE DSN TO SEE IF IT IS TOO LONG....\n*\nDSNCHECK CSECT\n         STM   R14,R12,12(R13)\n         BALR  BASE,0\n         USING *,BASE\n         LR    CHECKPTR,R1\n         L     R0,DLWORK\n         GETMAIN   R,LV=(0)\n         XC    0(LWORK,R1),0(R1)\n         ST    R1,8(R13)\n         ST    R13,4(R1)\n         LR    R13,R1\n         L     CHECKPDE,0(CHECKPTR)\n         LH    UT2,4(CHECKPDE)\n         CH    UT2,=H'44'\n         BH    BADLTHD\n         LA    R15,0\nGOBACKD  LR    R1,R13\n         L     R13,4(R1)\n         L     R0,DLWORK\n         LR    R10,R15            SAVE R15 OVER FREEMAIN\n         FREEMAIN  R,LV=(0),A=(1)\n         LR    R15,R10            RELOAD R15\n         LM    R0,R12,20(R13)\n         L     R14,12(R13)\n         BR    R14\nBADLTHD  LA    R15,4\n         LA    UT2,MBADLTH2\n         ST    UT2,8(CHECKPTR)\n         B     GOBACKD\n         DS    0D\nDLWORK   DC    AL1(0),AL3(LWORK)\n*WORK    EQU   72\nMBADLTH2 DC    AL4(0),AL2(L'MSGBADL2+4),AL2(0)\nMSGBADL2 DC    C' DSNAME MUST BE LESS THAN 44 CHARACTERS IN LENGTH '\nLIT2D    LTORG\n*        EJECT\n         TITLE  'TSO SPACE COMMAND - CODE FOR PL/I TPUT'\n*\n*            CODE FOR PL/1 TPUT\n*\nTSOPUT   CSECT\n         STM       R14,R12,12(R13)\n         LR    R11,R15\n         USING     TSOPUT,R11\n         LR        PARMPTR,R1\n*        L         R0,ALWORK\n*ETWORK  GETMAIN   R,LV=(0)\n*        XC        0(LWORK,R1),0(R1)\n         LA    R1,PUTSAVE\n         ST        R13,4(0,R1)\n         ST        R1,8(R13)\n         LR    R13,R1             R13 -> TO OUR SAVE AREA\n*        LR        WORKPTR,R1\n*        USING     WORK,WORKPTR\n         L         PARMPTR,0(PARMPTR)\n         USING     SDV,PARMPTR\n         L         R1,SDVADDR\n         LH    R0,0(,R1)          R0 = LTH OF MSG\n         LA    R1,2(,R1)          R1 -> TO MSG\n         L     R3,=V(SW3)         R3 -> TO SW3 IN SPACE PGM\n         TM    0(R3),SW380        IS THIS A BATCH RUN ?\n         BZ    PUTIT              NO, GO DO A TPUT\n         LR    R4,R0              R4 = LTH OF MSG\n         BCTR  R4,0               R4 = HEX LTH OF MSG\n         L     R3,=V(INFO1)       R3 -> TO MSG AREA\n         EX    R4,MVCMSG          MOVE MSG TO PRINT LINE\n*VCMSG   MVC   0(0,R3),0(R1)      MVC MSG TO PRINT LINE\n         L     R1,=V(REPORT)      R1 -> TO REPORT DCB\n         SPACE 1\nPUTITP   DS    0H\n         L     R0,=V(INFO1)       R0 -> TO REPORT PRINT LINE\n         PUT   (1),(0)            OUTPUT THE MSG\n         SPACE 1\n         MVI   0(R3),C'0'         CHANGE CC TO DOUBLE SPACE\n         MVI   1(R3),C' '         CLEAR PRINT LINE\n         MVC   2(131,R3),1(R3)    *\n         B     TSOEND             RETURN TO PLI PGM\n         SPACE 1\nPUTIT    DS    0H\n         L     R3,=V(SWITCHWD)    R3 -> TO SWITCHWD IN SPACE PGM\n         TM    0(R3),PRINTIT      PRINT TO A FILE?\n         BZ    PUTIT2             NO, GO DO A TPUT\n         LR    R4,R0              R4 = LTH OF MSG\n         BCTR  R4,0               R4 = HEX LTH OF MSG\n         L     R3,=V(INFO1)       R3 -> TO MSG AREA\n         EX    R4,MVCMSG          MOVE MSG TO PRINT LINE\n*VCMSG   MVC   0(0,R3),0(R1)      MVC MSG TO PRINT LINE\n         L     R1,=V(PRTDCB)      R1 -> TO OUTPUT DCB\n         B     PUTITP             GO PUT RECORD IN FILE\n         SPACE 1\nPUTIT2   DS    0H\n         MVI   0(R1),C' '         REMOVE CC FOR TPUT\n*        TPUT  (1),(0),R\n*        AGO   .PUT1\n*        LA    R2,L'DLINE         ENTIRE LINE LENGTH\n*        LA    R2,4(0,R2)         ADD RDW LEN\n*        STH   R2,RDWP\n*        LA    R2,L'DLINE         ENTIRE LINE LENGTH\n*        MVI   BUFFER,C' '        CLEAR BUFFER\n*        MVC   BUFFER,+1(119),BUFFER    ....\n         LR    R2,R0              R2 = LINE LTH\n         BCTR  R2,R0              R2 = HEX LINE LTH\n         EX    R2,MOVEDATA        SET UP PRINT LINE.\n         LA    R2,5(0,R2)         ADD RDW LEN + 1 WE TOOK OFF\n         STH   R2,RDWP\n*        ST    R1,PUTMSG          SAVE A(LINE) IN PLI PGM....\n*        MVC   BUFFER,DLINE\n         L     R1,=V(ECB)         R1 -> TO ECB\n         XC    0(4,R1),0(R1)      MAKE SURE IT'S CLEAR\n         L     R1,=V(IOPLADD)     R1 -> TO IOPL LIST\n         XC    0(4,R1),0(R1)      MAKE SURE IOPLUPT IS CLEAR....\n         PUTLINE PARM=PUTLIST,OUTPUT=(RDWP,TERM,SINGLE,DATA),          +\n               MF=(E,IOPLADD)\n.PUT1    ANOP\n*        LR        R1,WORKPTR\n*        L         R13,4(WORKPTR)\n         SPACE 1\nTSOEND   DS    0H\n         L     R13,PUTSAVE+4\n*        L         R0,ALWORK\n*REEWORK FREEMAIN  R,LV=(0),A=(1)\n         LM        R14,R12,12(R13)\n         BR        R14\nMOVEDATA MVC   BUFFER,0(R1)       SET UP PRINT LINE.\n         DS        0D\n*LWORK   DC        AL1(0),AL3(LWORK)\nPUTSAVE  DS    9D\nMVCMSG   MVC   0(0,R3),0(R1)      MVC MSG TO PRINT LINE\nPUTLIST  PUTLINE MF=L\nRDWP     DC    F'0'\nBUFFER   DS    CL120' '\n*\n*        NOTE  ... THE FOLLOWING PARMS ARE SET UP IN PL1 FORMAT\n*                  FOR TSOPUT.\n*\n         DS    0H\n*PUTMSG  DC    A(PUT1MSG)\n*UT1MSG  DC    AL2(PUTLTH1)\n*UTMSG1  DC    CL120' '\n*UTLTH1  EQU   *-PUTMSG1\n         ENTRY ECB,IOPLADD\nECB      DC    F'0'\nIOPLADD  DS    4F\nLITERALS LTORG\nSDV      DSECT\nSDVADDR  DS        A\nSDVMAXL  DS        H\nSDVFLAG  DS        H\n*\n*    REGISTER EQUATES\nPARMPTR  EQU   10\n         SPACE 2\n*        END\n         TITLE  'TSO SPACE COMMAND - RETRIEVE RECORDS FROM THE HSM MAST+\n               ER CONTROL DATASET.'\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*  PURPOSE:                                                           *\n*  -------                                                            *\n*                                                                     *\n*      TO RETRIEVE RECORDS FROM THE HSM MCDS.  THE DATASET NAME OF    *\n*    MIGRATED DATASET IS CONVERTED TO THE TRUE DATASET NAME AND THE   *\n*    RECORD DESCRIBING THE MIGRATED DATASET IS READ.                  *\n*                                                                     *\n*                                                                     *\n*  CALLING SEQUENCE:                                                  *\n*  ------- --------                                                   *\n*                                                                     *\n*      CALL $CHGMCDS                                                  *\n*                                                                     *\n*                                                                     *\n*  RETURN CODES:                                                      *\n*  ------ -----                                                       *\n*                                                                     *\n*     0 - RECORD SUCCESSFULLY READ.                                   *\n*     4 - RECORD WAS NOT FOUND.                                       *\n*                                                                     *\n*                                                                     *\n*  ABENDS:                                                            *\n*  ------                                                             *\n*                                                                     *\n*    NONE.                                                            *\n*                                                                     *\n***********************************************************************\n         EJECT\n         SPACE 3\n*\n*    RETURN CODES\n*\n         SPACE\nNORECORD EQU   4                   RECORD NOT FOUND READING MCDS\n         EJECT\n***********************************************************************\n*                                                                     *\n*    EXTERNAL ROUTINES.                                               *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n*\n*    ROUTINES USED BY $CHGMCDS.\n*\n         SPACE\n*        EXTRN $CHGDATA\n*        EXTRN $CHGERR\n*        EXTRN $CHGHEX\n         EJECT\n***********************************************************************\n*                                                                     *\n*    ENTRY POINTS.                                                    *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n*\n*    LOCATIONS THAT ARE KNOWN EXTERNALY.\n*\n         SPACE\n         ENTRY MCDS\n         ENTRY $CHGMCDS\n         EJECT\n***********************************************************************\n*                                                                     *\n*    STANDARD HIGH-LEVEL SUBROUTINE LINKAGE.                          *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n$CHGMCDS CSECT\n         USING *,R15              SET TEMP BASE\n         B     CONTINUE\n         DC    FL1'24',CL9'$CHGMCDS'\n         DC    CL6'&SYSTIME'\n         DC    CL8'&SYSDATE'\n         SPACE 1\nCONTINUE DS    0H\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         DROP  R15                DROP TEMP BASE\n         USING $CHGMCDS,R12\n         LA    R14,MCDSAVE\n         ST    R13,4(,R14)\n         ST    R14,8(,R13)\n         LR    R13,R14\n*\n*    SETUP DATA AREA ADDRESSABILITY.\n*\n*        L     R11,=V($CHGDATA)\n*        USING $CHGDA,R11\n*\n*    ZERO RETURN CODE.\n*\n         XC    RETCODE(4),RETCODE\n*        PRINT ON,NOGEN\n         EJECT\n         AGO   .NOALIAS\n***********************************************************************\n*                                                                     *\n*    READ THE MCA (MIGRATION CONTROL DATASET ALIAS) RECORD.           *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n*\n*    ASSUME NO MCD (MIGRATION CONTROL DATASET) RECORD WILL BE\n*    FOUND.  SET THE ADDRESS OF THE RECORD TO ZERO.\n*\n         XC    MCDSADDR(4),MCDSADDR\n*\n*    COPY THE DATASET NAME, WHICH IS THE KEY FOR THE ALIAS RECORD.\n*\n         L     R10,DSCBADDR        LOAD ADDRESS OF DSCB\n         USING $DYNAREA,R10\n         MVC   DSNAME2(44),DS1DSNAM STORE KEY FOR ALIAS RECORD\n*\n*    ATTEMPT TO READ THE ALIAS RECORD.\n*\n         GET   RPL=GETMCA\n         LTR   R15,R15             ANY ERRORS ???\n         BNZ   $CHGEND             YES, SO EXIT\n*\n*    AN ALIAS RECORD WAS READ.  THE RECORD'S KEY MUST CONTAIN THE\n*    GENERATED NAME OF A MIGRATED DATASET.\n*\n         L     R04,MCABUFF         LOAD ADDRESS OF DATA RECORD\n         USING MCA,R04\n         CLI   MCAINTTP,C'M'       GENERATED NAME ???\n         BNE   SETNTFND            NO, SO RECORD NOT FOUND\n         EJECT\n.NOALIAS ANOP\n***********************************************************************\n*                                                                     *\n*    READ THE MCD (MIGRATION CONTROL DATASET) RECORD.                 *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n         TM    FLAG,FLAGEXP       DID WE OPEN MCDS FILE ?           RH\n         BZ    $CHGEND            NO, DON'T TRY TO READ IT          RH\n*\n*    COPY THE DATASET NAME, WHICH IS THE KEY FOR THE RECORD.\n*\n*        MVC   DSNAME2(44),MCAINTNM COPY NAME OF USER DATASET\n*        L     R15,=V(DSNAME)     R15 -> TO DSNAME\n         L     R15,=V(LVLBUF)     R15 -> TO DSNAME LTH\n         MVC   DSNAME2(44),2(R15)   COPY NAME OF USER DATASET\n*        DROP  R04\n*\n*    ATTEMPT TO READ THE RECORD.\n*\n         GET   RPL=GETMCD\n*        ST    R15,RETCODE        SAVE RETURN CODE SHOULDN'T NEED\n         LTR   R15,R15             ANY ERRORS ???\n         BNZ   $CHGEND             YES, SO EXIT\n         EJECT\n***********************************************************************\n*                                                                     *\n*    VERIFY MCD RECORD POINTS TO A SUITABLE DATASET.                  *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n*\n*    A MCD RECORD WAS FOUND THAT MATCHED THE DATASET NAME.  NOW WE MUST\n*    COMPARE VOLUME SERIALS.  THE VOLUME HSM THINKS THE DATASET IS ON\n*    SHOULD MATCH THE VOLUME SERIAL OF OUR CURRENT UCB.\n*\n*        L     R1,UCBADDR2         LOAD ADDRESS OF UCB\n*        USING UCBOB,R1\n         L     R5,MCDBUFF          LOAD ADDRESS OF DATA RECORD\n         USING MCD,R5\n*        CLC   UCBVOLI(6),MCDVSN   VOLUME SERIALS MATCH ???\n*        BE    ON#VOL              YES\n         B     ON#VOL              YES\n*\n*    YIKES.  HSM THINKS THIS DATASET IS ON ANOTHER VOLUME.  THE\n*    DSCB WE FOUND SHOULD NOT BE THERE.  ISSUE AN ERROR MESSAGE THAT\n*    WE HAVE FOUND AN ORPHAN MIGRATED DATASET.\n*\n*        MVC   MCDS03+74(44),DS1DSNAM\n*        MVC   MCDS03B+23(6),UCBVOLI\n*        MVC   MCDS03B+31(3),UCBNAME\n*        CALL  $CHGERR,(MCDS03,MCDS03B),VL\n         B     SETNTFND            WE DID NOT FIND A MIGRATED DATASET\n*        DROP  R1\n*\n*    CHECK THAT A MIGRATED COPY EXISTS.\n*\nON#VOL   EQU   *\n         CLI   MCDTYPE,X'00'      IS THIS A DATASET TYPE RECORD?\n         BNE   CHKTYPE             NO\n         TM    MCDFLGS,MCDFASN     MIGRATED COPY EXISTS ???\n         BZ    SETNTFND            NO\n*\n*    CHECK THAT THE DATASET HAS NOT BEEN RECALLED.\n*\n         TM    MCDFLGS,MCDFNSCR    DATASET BEEN RECALLED ???\n         BO    SETNTFND            YES\n*\n*    CHECK THAT THIS IS NOT A DUMMY RECORD.\n*\n         TM    MCDFLGS+1,MCDFDUMD  DUMMY RECORD ???\n         BO    SETNTFND            YES\n*\n*    CHECK THE DEVICE TYPE OF THE PRIMARY VOLUME THE DATASET RESIDED\n*    ON.  DEVICE MUST BE DASD 3350 3380, OR 3390.\n*\n         CLI   MCDUCBTY+2,X'20'    DASD DEVICE ???\n         BNE   SETNTFND            NO\n         CLI   MCDUCBTY+3,X'0B'    3350 ???\n         BE    GOOD#DEV            YES\n         CLI   MCDUCBTY+3,X'0E'    3380 ???\n         BE    GOOD#DEV            YES\n         CLI   MCDUCBTY+3,X'0F'    3390 ???\n         BE    GOOD#DEV            YES\n         B     SETNTFND\n*\n*    CHECK THE RECORD TYPE FOR VSAM\n*\n         SPACE 1\nCHKTYPE  DS    0H\n         CLI   MCDTYPE,X'11'      IS THIS AN ALIAS TYPE RECORD?\n         BNE   SETNTFND            NO, SAY RECORD NOT FOUND\n*\n         CLI   MCDVSN,C'D'        IS ALIAS FOR A VSAM DATA OBJECT?\n         BNE   CHKINDEX           NO, SEE IF FOR INDEX\n         MVI   RETCODE+3,16       YES, SET RC = 16\n         B     $CHGEND            RETURN TO CALLER\n         SPACE 1\nCHKINDEX DS    0H\n         CLI   MCDVSN,C'I'        IS ALIAS FOR A VSAM INDEX OBJECT?\n         BNE   SETNTFND           NO, SAY NOT FOUND\n         MVI   RETCODE+3,20       YES, SET RC = 20\n         B     $CHGEND            RETURN TO CALLER\n*\n*    RETURN THE ADDRESS OF THE MCD.\n*\nGOOD#DEV EQU   *\n         ST    R5,MCDSADDR         STORE ADDRESS\n         SPACE 1\n***********************************************************************\n*\n*    SET UP A 'DSCB' FOR THE PRINT PROGRAM\n*\n***********************************************************************\n         SPACE 1\n         L     R10,=V(GETMADDR)    LOAD A(ADDRESS OF DSCB)_\n         L     R10,0(0,R10)       R10 -> TO DSCB AREA\n         USING $DYNAREA,R10\n         MVI   DS1DSNAM,X'00'     ZERO OUT DSCB\n         MVC   DS1DSNAM+1(139),DS1DSNAM  ''\n         MVC   DS1DSNAM,MCDKEY    PUT DSNAME INTO DSCB\n         MVI   DS1FMTID,C'1'      PUT IDENTIFIER INTO DSCB\n*        MVC   DS1CREDT,MCDDLC    PUT CREATE DATE INTO DSCB\n*\n*              CONVERT CREATE DATE FROM PACKED TO HEX\n*\n         LH    R14,MCDDLC         R14 = PACKED YEAR\n         LTR   R14,R14            IS THERE A DATE?\n         BZ    NODATE1            NO\n         SLL   R14,4              MAKE ROOM FOR SIGN\n         AH    R14,=H'12'         PUT IN 'C' SIGN\n         ST    R14,DWORD+4        SAVE IT FOR CONVERT\n         CVB   R14,DWORD          CONVERT TO BINARY\n         STC   R14,DS1CREDT       PUT YEAR IN DSCB\n*\n         LH    R14,MCDDLC+2       R14 = PACKED DAY\n         ST    R14,DWORD+4        SAVE IT FOR CONVERT\n         CVB   R14,DWORD          CONVERT TO BINARY\n         STH   R14,DS1CREDT+1     PUT DAY IN DSCB\n*\n         MVI   DS1NOEPV,X'01'     SAY 1 EXTENT IN DSCB\n*        MVC   DS1REFD,MCDDLR     PUT LAST U DATE INTO DSCB\n*\n*              CONVERT LAST REF DATE FROM PACKED TO HEX\n*\n         SPACE 1\nNODATE1  DS    0H\n         LH    R14,MCDDLR         R14 = PACKED YEAR\n         LTR   R14,R14            IS THERE A DATE?\n         BZ    NODATE2            NO\n         SLL   R14,4              MAKE ROOM FOR SIGN\n         AH    R14,=H'12'         PUT IN 'C' SIGN\n         ST    R14,DWORD+4        SAVE IT FOR CONVERT\n         CVB   R14,DWORD          CONVERT TO BINARY\n         STC   R14,DS1REFD        PUT YEAR IN DSCB\n*\n         LH    R14,MCDDLR+2       R14 = PACKED DAY\n         ST    R14,DWORD+4        SAVE IT FOR CONVERT\n         CVB   R14,DWORD          CONVERT TO BINARY\n         STH   R14,DS1REFD+1      PUT DAY IN DSCB\n*\n         SPACE 1\nNODATE2  DS    0H\n         MVC   DS1DSORG,MCDDSORG  PUT DSORG INTO DSCB\n         MVC   DS1RECFM,MCDRECFM  PUT RECFM INTO DSCB\n         MVC   DS1BLKL,MCDBLKSZ   PUT BLKSIZE INTO DSCB\n*        MVC   DS1LRECL,MCDLRECL  PUT LRECL INTO DSCB\n         MVC   DS1DSIND,MCDDSIND  PUT INDICATORS INTO DSCB\n         L     R14,MCDSIZE        R14 = NBR TRKS ALLOC\n*\n*              CREATE 1ST EXTENT DESCRIPTION\n*\n         STCM  R14,3,DS1EXT1+6    SET ENDING CCH\n         MVI   DS1EXT1,X'01'      SAY 1ST EXTENT\n*\n*              CREATE LAST USED TTB\n*\n         SLL   R14,8              MAKE IT TT AND BLOCK\n         STCM  R14,7,DS1LSTAR     SAVE IT IN DSCB\n         DROP  R5\n         EJECT\n***********************************************************************\n*                                                                     *\n*    RETURN TO CALLING ROUTINE.                                       *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n*\n*    NORMAL TERMINATION.\n*\n$CHGEND  EQU   *\n         L     R13,4(,R13)\n         L     R14,12(,R13)\n         L     R15,RETCODE\n         LM    R0,R12,20(R13)\n         MVI   12(R13),X'FF'\n         BR    R14\n         SPACE 1\nDWORD    DS    D\n*MAIN03  $MSG  '0<MAIN03> MCDS CLOSE FAILED.'\n*MAIN04  $MSG  '0<MAIN04> MCDS OPEN FAILED. '\n         SPACE 1\n*        DROP  R10\n*        DROP  R11\n         EJECT\n***********************************************************************\n*                                                                     *\n*    INFORM CALLER VALID MCD RECORD WAS NOT FOUND.                    *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n*\n*    VALID MCD RECORD WAS NOT FOUND.  POSSIBLE REASONS ARE:\n*\n*        - NO MCA RECORD EXISTS.  SOME JOKER HAPPENED TO CHOOSE 'HMIG'\n*          AS A SECOND LEVEL INDEX.\n*\n*        - MCD RECORD EXISTS BUT THE DATASET IS NOT YET MIGRATED.\n*\n*        - MCD RECORD EXISTS BUT THE DATASET HAS BEEN RECALLED.\n*\n*        - MCD RECORD EXISTS BUT IT IS DUMMY.\n*\n*        - MCD RECORD EXISTS BUT THE PRIMARY VOLUME IT REFERENCES IS\n*          NOT A 3350 3380, OR 3390 DASD.\n*\n*\nSETNTFND EQU   *\n         LA    R15,NORECORD           SET THE RETURN CODE\n         ST    R15,RETCODE            STORE THE RETURN CODE\n         B     $CHGEND                RETURN TO CALLING ROUTINE\n         EJECT\n***********************************************************************\n*                                                                     *\n*    VSAM LOGICAL ERROR RECOVERY.                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n*\n*    A LOGICAL ERROR OCCURRED.  SAVE THE REGISTERS.\n*\nLOG#ERR  EQU   *\n         STM   R0,R15,ERRSAVE+4       SAVE THE REGISTERS\n         LA    R13,SHOWSAVE           GET ADDR OF SAVE AREA FOR SHOWCB\n*\n*    GET THE FEEDBACK CODE.\n*\n         SHOWCB RPL=(R1),                                              *\n               AREA=LOG#AREA,                                          *\n               LENGTH=4,                                               *\n               FIELDS=(FDBK)\n*\n*    FEEDBACK CODE OF 16 INDICATES THE RECORD WAS NOT FOUND.\n*\n         L     R2,LOG#AREA         LOAD FEEDBACK CODE\n         C     R2,=F'16'           RECORD NOT FOUND ???\n         BNE   BAD#FD              NO\n*\n*    SET THE RETURN CODE TO 4.\n*\n         LA    R15,NORECORD        SET RETURN CODE\n         ST    R15,RETCODE         STORE RETURN CODE\n         B     LOG#EXIT            RETURN TO VSAM\n*\n*    UNRECOVERABLE LOGICAL ERROR.\n*\n*        *ERROR* LOGICAL ERROR READING HSM MCDS.\n*                KEY = 'DATASET.NAME'\n*                FEEDBACK CODE = X'00000000'.\n*\nBAD#FD   EQU   *\n*        MVC   ERR#KEY+20(44),DSNAME2\n*        CALL  $CHGHEX,(ERR#FBC+31,LOG#AREA,F4),VL\n*        CALL  $CHGERR,(MCDS01,ERR#KEY,ERR#FBC),VL\n*\n*    SET THE RETURN CODE TO 4.\n*\n         LA    R15,NORECORD        SET RETURN CODE\n         ST    R15,RETCODE         STORE RETURN CODE\n*\n*    RETURN TO VSAM.\n*\nLOG#EXIT EQU   *\n         LM    R0,R15,ERRSAVE+4    RESTORE REGISTERS\n         BR    R14                 RETURN TO VSAM\n         EJECT\n***********************************************************************\n*                                                                     *\n*    VSAM PHYSICAL ERROR RECOVERY.                                    *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n*\n*    A PHYSICAL ERROR OCCURRED.  SAVE THE REGISTERS.\n*\nPHY#ERR  EQU   *\n         STM   R0,R15,ERRSAVE+4       SAVE THE REGISTERS\n         LA    R13,SHOWSAVE           GET ADDR OF SAVE AREA FOR SHOWCB\n*\n*    GET THE FEEDBACK CODE.\n*\n         SHOWCB RPL=(R1),                                              *\n               AREA=PHY#AREA,                                          *\n               LENGTH=4,                                               *\n               FIELDS=(FDBK)\n*\n*    UNRECOVERABLE PHYSICAL ERROR.\n*\n*        *ERROR* PHYSICAL ERROR READING HSM MCDS.\n*                KEY = 'DATASET.NAME'\n*                FEEDBACK CODE = X'00000000'.\n*                SYNAD ERROR MESSAGE.\n*\n*        MVC   ERR#KEY+20(44),DSNAME2 COPY DATASET NAME\n*        CALL  $CHGHEX,(ERR#FBC+31,PHY#AREA,F4),VL\n*\n*    COPY PORTION OF SYNAD ERROR MESSAGE.\n*\n         MVC   ERR#SYN+13(116),PHY#MSG+12\n*\n*    OUTPUT ERROR MESSAGES.\n*\n*        CALL  $CHGERR,(MCDS02,ERR#KEY,ERR#FBC,ERR#SYN),VL\n*\n*    SET THE RETURN CODE TO 4.\n*\n         LA    R15,NORECORD        SET RETURN CODE\n         ST    R15,RETCODE         STORE RETURN CODE\n*\n*    RETURN TO VSAM.\n*\nPHY#EXIT EQU   *\n         LM    R0,R15,ERRSAVE+4    RESTORE REGISTERS\n         BR    R14                 RETURN TO VSAM\n         EJECT\n***********************************************************************\n*                                                                     *\n*    DATA SECTION.                                                    *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n*\n*    REGISTER SAVE AREA.\n*\n         SPACE\nMCDSAVE  DC    C'SAVE'\n         DC    17F'-1'\n         SPACE 3\n*\n*    REGISTER SAFE STORE WHILE PROCESSING LOGICAL AND PHYSICAL ERRORS.\n*\n         SPACE\nERRSAVE  DC    C'REGS'\n         DC    16F'-1'\n         SPACE 3\n*\n*    SAVE AREA FOR SHOWCB MACRO IN LOGICAL AND PHYSICAL ERROR EXITS.\n*\n         SPACE\nSHOWSAVE DC    C'SHOW'\n         DC    17F'-1'\n         SPACE 3\n*\n*    RETURN CODE.\n*\n         SPACE\nRETCODE  DS    F\n         SPACE 3\n*\n*    LENGTHS USED BY $CHGHEX.\n*\n         SPACE\nF4       DC    F'4'\n         EJECT\n*\n*    CONTROL BLOCKS TO READ AND PROCESS RECORDS FROM THE HSM MASTER\n*    CONTROL DATASET.\n*\n         SPACE 3\n*\n*    ACB TO READ HSM MASTER CONTROL DATA SET.\n*\n         SPACE 1\n         PRINT ON,NOGEN\nMCDS     ACB   AM=VSAM,                                                *\n               BUFND=2,                                                *\n               BUFNI=1,                                                *\n               DDNAME=MCDS,                                            *\n               EXLST=EXTNAMES,                                         *\n               MACRF=(KEY,DIR),                                        *\n               STRNO=1\n         SPACE 3\n*\n*    RETRIEVE MCA RECORD FROM THE DATA SET.\n*\n         SPACE\nGETMCA   RPL   ACB=MCDS,                                               *\n               AM=VSAM,                                                *\n               AREA=MCABUFF,                                           *\n               AREALEN=4,                                              *\n               ARG=DSNAME2,                                            *\n               MSGAREA=PHY#MSG,                                        *\n               MSGLEN=128,                                             *\n               OPTCD=(KEY,DIR,FKS,LOC)\n         SPACE 3\n*\n*    RETRIEVE MCD RECORD FROM THE DATA SET.\n*\n         SPACE\nGETMCD   RPL   ACB=MCDS,                                               *\n               AM=VSAM,                                                *\n               AREA=MCDBUFF,                                           *\n               AREALEN=4,                                              *\n               ARG=DSNAME2,                                            *\n               MSGAREA=PHY#MSG,                                        *\n               MSGLEN=128,                                             *\n               OPTCD=(KEY,DIR,FKS,LOC)\n         SPACE 3\n*\n*    DEFINITION OF ERROR EXITS.\n*\n         SPACE\nEXTNAMES EXLST AM=VSAM,                                                *\n               LERAD=(LOG#ERR,A),                                      *\n               SYNAD=(PHY#ERR,A)\n         SPACE 3\n*\n*    ADDRESSES OF MCA AND MCD RECORDS.\n*\n         ENTRY MCDBUFF\n         SPACE\nMCABUFF  DC    A(0)\nMCDBUFF  DC    A(0)\n         SPACE 3\n*\n*    ADDRESSES USED BY SHOWCB TO RETRIEVE FEEDBACK CODE.\n*\n         SPACE\nLOG#AREA DS    F\nPHY#AREA DS    F\n         SPACE 3\n*\n*    KEYS OF RECORDS TO BE RETREIVED.\n*\n         SPACE\nDSNAME2  DC    CL44' '\n         SPACE 3\n*\n*    PHYSICAL ERROR MESSAGE AREA.\n*\n         SPACE\nPHY#MSG  DS    0H\n         DS    CL128\n         EJECT\n*\n*    OUTPUT ERROR MESSAGES.\n*\n         SPACE 3\n*ERR#FBC $MSG  '         FEEDBACK CODE = X''00000000''.'\n*ERR#KEY $MSG  '         KEY = ''XXXXXXXX.XXXXXXXX.XXXXXXXX.XXXXXXXX.XX*\n               XXXXXX''.'\nERR#SYN  DC    Y(129),Y(0)\n         DC    CL125' '\n*MCDS01  $MSG  '0<MCDS01> LOGICAL ERROR READING HSM MCDS.'\n*MCDS02  $MSG  '0<MCDS02> PHYSICAL ERROR READING HSM MCDS.'\n*MCDS03  $MSG  '0<MCDS03> AN ORPHAN MIGRATED DATASET WAS FOUND.  HSM HA*\n               S NO RECORD OF ''XXXXXXX.XXXXXXXX.XXXXXXXX.XXXXXXXX.XXXX*\n               XXXXX'''\n*MCDS03B $MSG  '         ON VOLUME XXXXXX (XXX).'\n         EJECT\n*\n*    LITERAL POOL.\n*\n         SPACE\n         LTORG\n         EJECT\n*\n*    DATA AREA DSECT.\n*\n         SPACE 3\n*$CHGDA  DSECT\n*        COPY  $CHGDA\n         DC    FL1'24',CL9'$CHGDATA'\n         DC    CL6'&SYSTIME'\n         DC    CL8'&SYSDATE'\nDTEMP    DS    D                   DOUBLEWORD WORK AREA\n*\nVTOCEXTS DS    0D                  VTOC EXTENTS FROM FORMAT 4 DSCB\nVTOC#BEG DS    XL4                 STARTING CC HH\nVTOC#END DS    XL4                 ENDING   CC HH\n*\nJOBNAME  DC    CL8'$CHARGER'       JOBNAME\nVERSION  DC    CL4'02.00'          VERSION\nSYSID    DS    CL4                 SYSTEM IDENTIFICATION\nBINTIME  DS    F                   BINARY TIME OF DAY (1/100 SEC)\nJULDATE  DS    PL4                 JULIAN DATE\n*\n*ETMADDR DS    A                   ADDRESS OF AREA TO HOLD VTOC\n*ETMLEN  DS    F                   LENGTH  OF AREA TO HOLD VTOC\nHI#DSCB  DS    A                   ADDRESS OF HIGHEST DSCB\nVTOCFENC DS    A\n*\nUCBADDR2 DS    A                   UCB ADDRESS OF CURRENT DEVICE\nDEVADDR  DS    A                   ADDRESS OF DEVICE TABLE ENTRY\nDSCBADDR DS    A                   ADDRESS OF FORMAT 1 DSCB\nMCDSADDR DS    A                   ADDRESS OF MCDS RECORD\n*\nDSTYPE   DS    CL1                 DATA SET TYPE (O=OS, V=VSAM)\n*\nTEMP#CNT DC    F'0'                NUMBER OF TEMP DATASETS ON VOLUME\nVSAM#CNT DC    F'0'                NUMBER OF VSAM DATASETS ON VOLUME\nPERM#CNT DC    F'0'                NUMBER OF PERM DATASETS ON VOLUME\nHSM#CNT  DC    F'0'                NUMBER OF HSM  DATASETS ON VOLUME\n*\nTEMP#TRK DC    F'0'                NUMBER OF TEMP TRACKS   ON VOLUME\nVSAM#TRK DC    F'0'                NUMBER OF VSAM TRACKS   ON VOLUME\nPERM#TRK DC    F'0'                NUMBER OF PERM TRACKS   ON VOLUME\nHSM#TRK  DC    F'0'                NUMBER OF HSM  TRACKS   ON VOLUME\n*\nS136#VOL DC    F'0'                NUMBER OF 136 RECORDS ON VOLUME\nS136#TOT DC    F'0'                NUMBER OF 136 RECORDS IN TOTAL\n*\nTRK#DSN  DS    F                   NUMBER OF TRACKS IN DATASET\nTRK#VOL  DS    F                   NUMBER OF TRACKS ON VOLUME\nTRK#TOT  DS    F                   NUMBER OF TRACKS IN TOTAL\n*\nERR#LC   DC    H'65'               'ERROR' LINE COUNT\nERR#MLC  DC    H'64'               'ERROR' LINES PER PAGE\nERR#PAGE DC    H'0'                'ERROR' PAGE COUNT\n*\nRPT#LC   DC    H'65'               'REPORT' LINE COUNT\nRPT#MLC  DC    H'64'               'REPORT' LINES PER PAGE\nRPT#PAGE DC    H'0'                'REPORT' PAGE COUNT\n*\n*    DEVICE TABLE.  AN ENTRY EXITS FOR EACH VALID DASD DEVICE.\n*\nDEV#CNT  DC    H'2'                NO. OF VALID DASD DEVICES\nDEV#ELN  DC    H'24'               LENGTH OF EACH ENTRY\n*\n*              DEV             TRK   DSCB   BYTES   UNIT\n*              TYPE            /CYL  /TRK   /TRK    NAME\n*\nDEV#TAB  DS    0F\n         DC    X'0B',X'000000',F'30',F'47',F'19069',CL8'3350'\n         DC    X'0E',X'000000',F'15',F'53',F'47476',CL8'3380'\n         DC    X'0F',X'000000',F'15',F'53',F'56664',CL8'3390'\n*\n         ENTRY FLAG\nFLAG     DC    XL1'40'             FLAG BYTE                        RH\nFLAGINC  EQU   X'80'               INCLUDE VOLUMES\nFLAGEXC  EQU   X'40'               EXCLUDE VOLUMES\nFLAGEXP  EQU   X'20'               EXPAND HSM MIGRATED DATASETS     RH\nFLAGTRUE EQU   X'10'               OUTPUT DS TRUE NAME (HSM MIG DS) SS\n*\nKEYCOUNT DC    F'3'               CURRENT NUMBER OF KEYWORD ENTRIES RH\nKEYLENG  DC    F'8'                LENGTH OF ONE KEYWORD ENTRY\nKEYLSIZE DC    F'200'              MAXIMUM NUMBER OF KEYWORD ENTRIES\nKEYWSIZE DC    F'1200'             LENGTH OF AREA TO HOLD KEYWORDS\nKEYLIST  DS    0F                  KEYWORD ENTRIES                  RH\n         DC    A(KEYWORD1)        DEFAULT KEYWORD ENTRY             RH\n         DC    X'07'              DEFAULT KEYWORD LTH               RH\n         DC    X'01'              DEFAULT KEYWORD POSITION          RH\n         DC    X'0001'            DEFAULT KEYWORD CARD NUMBER       RH\n         DC    A(KEYWORD2)        DEFAULT KEYWORD ENTRY             RH\n         DC    X'03'              DEFAULT KEYWORD LTH               RH\n         DC    X'09'              DEFAULT KEYWORD POSITION          RH\n         DC    X'0001'            DEFAULT KEYWORD CARD NUMBER       RH\n         DC    A(KEYWORD3)        DEFAULT KEYWORD ENTRY             RH\n         DC    X'03'              DEFAULT KEYWORD LTH               RH\n         DC    X'0D'              DEFAULT KEYWORD POSITION          RH\n         DC    X'0001'            DEFAULT KEYWORD CARD NUMBER       RH\nKEYDEFS  EQU   (*-KEYLIST)        NUMBER OF DEFAULTS                RH\n         DS    (400-(KEYDEFS/4))F MAKE UP 400 KEYWORD ENTRIES       RH\nKEYWORDS DS    0CL1200             KEYWORDS                         RH\nKEYWORD1 DC    CL6'EXCLUDE'       DEFAULT KEYWORD 1                 RH\nKEYWORD2 DC    CL3'OLD'           DEFAULT KEYWORD 2                 RH\nKEYWORD3 DC    CL3'SMS'           DEFAULT KEYWORD 3                 RH\n         DS    CL(1200-(*-KEYWORDS)) REST OF KEYWORDS               RH\n         SPACE 2\n         EJECT\n*\n*    DSECT TO MAP MCA (MIGRATION CONTROL DATASET ALIAS) RECORD\n*\nMCA      DSECT\nMCAKEY   DS    CL44                MCA KEY (DSNAME PADDED WITH BLANKS)\nMCAHDR   DS    CL20                HEADER\nMCAINTTP DS    CL1                 RECALL INTERCEPT TYPE\nMCAVSATP DS    CL1                 VSAM ASSOCIATION TYPE\n         DS    CL2                 RESERVED\nMCAINTNM DS    CL44                MCD KEY\n         EJECT\n*\n*    DSECT TO MAP MCD (MIGRATION CONTROL DATASET) RECORD\n*    SEE  HSM  DIAGNOSIS REFERENCE, VOL 2, LY35-0077\n*\n         SPACE\nMCD      DSECT\nMCDKEY   DS    CL44                MCD KEY (DSNAME PADDED WITH BLANKS)\nMCDHDR   DS    0CL20               HEADER\nMCDLEN   DS    CL2                 LENGTH OF RECORD\nMCDTYPE  DS    CL1                 RECORD TYPE\n         DS    CL17                REST OF HEADER\n*\n*                       THE REST OF THIS LAYOUT IS FOR A TYPE D RECORD\n*\nMCDVSN   DS    CL6                 VOLSER OF MIGRATION VOLUME\nMCDFLGS  DS    XL2                 FLAGS\nMCDFASN  EQU   X'80'                   MIGRATED COPY EXISTS\nMCDFMIG  EQU   X'40'                   DATASET IS TO BE MIGRATED\nMCDFNOMG EQU   X'20'                   DATASET RETAINED FROM MIGRATION\nMCDFDEL  EQU   X'10'                   DATASET WAS DELETED\nMCDFSDP  EQU   X'08'                   DATASET IN VSAM SMALL-PACKING\nMCDFL2   EQU   X'04'                   DATASET IS ON LEVEL 2\nMCDFNSCR EQU   X'02'                   DS RECALLED, BUT NOT SCRATCHED\nMCDJES3  EQU   X'01'                   PROCESSED DURING HSM JES3 SETUP\nMCDFSMVL EQU   X'04'                   SPACE MNGT FLAGS ARE VALID\nMCDFDUMD EQU   X'02'                   DUMMY RECORD\nMCDFR3   EQU   X'01'                   RECORD CREATED IN RELEASE 3\nMCDCOMPR DS    XL1                 PERCENT OF SPACE SAVED\n         DS    CL3                 RESERVED\nMCDDLC   DS    XL4                 DATE DATASET CREATED\nMCDTLR   DS    XL4                 TIME DATASET LAST USED\nMCDDLR   DS    XL4                 DATE DATASET LAST REFERENCED\nMCDTLU   DS    XL4                 TIME VSAM DATASET LAST UPDATED\nMCDDLU   DS    XL4                 DATE VSAM DATASET LAST UPDATED\nMCDTMIG  DS    XL4                 TIME DATASET WAS MIGRATED\nMCDDMIG  DS    XL4                 DATE DATASET WAS MIGRATED\nMCDDSORG DS    XL2                 DATASET ORGANIZATION\nMCDBLKSZ DS    XL2                 MAX BLOCKSIZE\nMCDKEYLN DS    XL1                 KEY LENGTH\nMCDRECFM DS    XL1                 RECORD FORMAT\nMCDRFTYP EQU   X'C0'                   F, V, OR B FORMAT\nMCDRFTO  EQU   X'20'                   TRACK OVERFLOW\nMCDDSIND DS    XL1                 DATASET INDICATORS FROM FMT 1 DSCB\nMCDFRACF EQU   X'40'                   RACF PROTECTED\nMCDFSCTY EQU   X'10'                   PASSWORD PROTECTED\nMCDFWSEC EQU   X'04'                   WRITE PASSWORD PROTECTED\nMCDFCHNG EQU   X'02'                   DATASET OPENED FOR UPDATE\nMCDHID   DS    XL1                 ID OF PROCESSOR USING RECORD\nMCDSIZE  DS    XL4                 SIZE, IN TRACKS,    ON USER'S VOL\nMCDSIZEB DS    XL4                 SIZE, IN BYTES,     ON USER'S VOL\nMCDCSZ   DS    XL4                 SIZE, IN 2K BLOCKS, ON MIGRATION VOL\nMCDNMIG  DS    XL2                 NO. TIMES DATASET MIGRATED\nMCDDAYS  DS    XL2                 NO. DAYS BEFORE DS ELIGIBLE FOR MIG\nMCDFRVSN DS    CL6                 VOLSER OF PRIMARY VOL BEFORE MIG\n         DS    XL1                 RESERVED\nMCDMCL43 DS    XL1                 KEY FOR MCL RECORD\nMCDCTID  DS    XL4                 COMPACTION TABLE ID\nMCDUCBTY DS    XL4                 DEVICE TYPE OF PRIMARY VOL\nMCDTRES  DS    XL4                 TIME DATASET WAS RECALLED OR DELETED\nMCDDRES  DS    XL4                 DATE DATASET WAS RECALLED OR DELETED\nMCDMDEVT DS    XL4                 DEVICE TYPE OF MIGRATION VOL\nMCDJDAYS DS    XL1                 DEFAULT NO. DAYS TO DELAY MIGRATION\nMCDJDATE DS    XL3                 LAST DATE HSM WILL DELAY MIGRATION\nMCDJVEXD DS    XL3                 LAST DATE HSM WILL HOLD VOLSERS\nMCDPDEP  DS    XL1                 DEFINE POOL\nMCDJCT   DS    XL1                 NO. VOL ELIGIBLE FOR RECALL\nMCDJVOLS DS    XL50                5 VOLUMES ELIGIBLE FOR RECALL\nMCDEXPDT DS    XL4                 DATASET EXPIRATION DATE\nMCDMCANM DS    CL44                KEY TO MCA RECORD\n         EJECT\n*\n*    MISCELLANEOUS DSECTS.\n*\n         SPACE 3\n         PRINT ON,NOGEN\n         CVT   DSECT=YES\n         SPACE 3\n         IEESMCA\n         SPACE 3\n         DCBD  DSORG=PS\n$DYNAREA DSECT\nDSCB#CHR DS    XL5\nDSCB#KDL DS    XL3\nDSCB     DS    XL140\n         ORG   DSCB\n        IECSDSL1 (1)\n         ORG   DSCB\n        IECSDSL1 (2)\n         ORG   DSCB\n        IECSDSL1 (3)\n         ORG   DSCB+44\n        IECSDSL1 (4)\n         ORG   DSCB\n        IECSDSL1 (5)\n         ORG   DSCB\n        IECSDSL1 (6)\n$DYNSIZE EQU   *-$DYNAREA\n         SPACE 3\n         IEFUCBOB\n         SPACE 1\n TITLE 'READ CATALOG WITH IDCAMS'\n*\n*/*\n***********************************************************************\n*                                                                     *\n*             MODULE NAME = CALLIDC                                   *\n*                                                                     *\n*             DESCRIPTIVE NAME =  VRH SUPPLIED ROUTINE TO IVOKE       *\n*                IDCAMS TO GET VOLSERS FROM THE CATALOG FOR A         *\n*                DATASET.                                             *\n*                                                                     *\n*                 REGISTER CONVENTIONS = STANDARD CONVENTIONS.        *\n*                    REGISTERS 0 - 2   = WORK REGISTERS               *\n*                    REGISTERS 3 - 11  = UNUSED                       *\n*                    REGISTERS 12      = BASE REGISTER                *\n*                    REGISTER  13 -15  = STANDARD OS USAGE            *\n*                                                                     *\n*                ATTRIBUTES = PROBLEM STATE                           *\n*                                                                     *\n*        THE PARM PASSED TO CALLIDC IS THE LOCATE CAMLST              *\n*                                                                     *\n*    *        TCAM   LIST\n*    TCAML    DS     0F\n*    TCFLGS   DC     X'44000000'              TCAM ON DSN\n*    TCAMDSN  DC     A(0)                     A(DSN)\n*             DC     A(0)                     VOL POINTER\n*             DC     A(TWORK)                 A(265 BYTE WORK AREA)\n*             DS    0D                 PUT ON DOUBLE WORD BOUNDARY\n*    TWORK    DS     0CL265\n*    VOLCNT   DC     H'0'                     VOL COUNT\n*    DEVTYP   DC     XL4'00'                  DEVICE TYPE\n*    TVOL     DC     CL6' '                   FIRST VOL SER\n*             DC     CL(265-(*-TWORK))' '     ROOM FOR 19 MORE...\n*             DC     CL(12*30)' '      ROOM FOR 30 MORE BY IDCAMS....\n*             DC     12X'FF'           END OF LIST...\n***********************************************************************\n*\n*        ENTRY POINT\n*\n         DS    0H\nCALLIDC  SECTION  GEN=YES,BASE=2\n*        RDJFCB STEPCAT           READ STEPCAT JFCB\n         ST    R1,PARMADDR        SAVE PARM ADDRESS\n         L     R14,12(0,R1)       R14 -> AT TCAM WORK AREA\n         ST    R14,VVDSADDR       SAVE IT'S ADDRESS\n         ST    R14,VVDSREC        SAVE IT'S ADDRESS FOR IDCAMS EXIT\n*        GETMAIN LU,LA=VVDSLTH,A=VVDSADDR GET CORE FOR IDCAMS DATA\n*        L     R1,VVDSADDR        R1 ->  CORE\n*        ST    R1,VVDSREC         SAVE IT'S ADDRESS FOR IDCAMS EXIT\n*        L     R1,VVDSLTH         R1 = LTH OF AREA\n*        LA    R1,0(0,R1)         CLEAR HI ORDER BYTE\n*        SR    R0,R0              CLEAR R0\n*        D     R0,=F'12'          R1 NOW = NBR VVDS AREAS\n         LA    R1,50              R1 NOW = NBR VOLSER AREAS\n         L     R14,=V(MAXVVDS)    R14 -> TO VVDS MAX CTR\n         ST    R1,0(0,R14)        SAVE IT\n         SPACE\n         L     R1,PARMADDR        R1 ->  PARM, IF ANY\n*        L     R1,0(0,R1)         R1 -> TO PARMS\n*        LH    R2,0(0,R1)         R2 = PARM LTH\n*        LTR   R2,R2              IS THERE A PARM ?\n*        BZ    NEXTCAT            NO, GO READ CATIN\n         L     R3,4(0,R1)         R3 -> TO TCAM DSN\n         LR    R4,R3              R4 -> TO PARM\n         SPACE 1\n         AGO   .IDC1\n         MVC   DSNAME,0(R3)       SET UP ATTACH NAME\n         B     GETCAT             GO AROUND DC'S\n         SPACE\nSETNAME  MVC   DSNAME(0),2(R1)    SET UP ATTACH NAME\nPARMADDR DS    F                  SET UP ATTACH NAME\n         SPACE 2\n*        TCAM   LIST\nTCAML    DS     0F\nTCFLGS   DC     X'44000000'              TCAM ON DSN\nTCAMDSN  DC     A(DSNAME)                A(DSN)\n         DC     A(0)                     VOL POINTER\n         DC     A(TWORK)                 A(265 BYTE WORK AREA)\n         DS    0D                 PUT ON DOUBLE WORD BOUNDARY\nTWORK    DS     0CL265\nVOLCNT   DC     H'0'                     VOL COUNT\nDEVTYP   DC     XL4'00'                  DEVICE TYPE\nTVOL     DC     CL6' '                   FIRST VOL SER\n         DC     CL244' '                 REST OF TCAML DATA\n         DC     CL12' '                  REST OF TCAML DATA\n         SPACE 2\nDSNAME   DC    CL44' '            DSNAME FOR LOCATE\n         SPACE\nGETCAT   DS    0H\n         MVC   INCATLG,DSNAME     MOVE CATALOG NAME TO IDCAMS CTL STMT\n.IDC1    ANOP\n         MVC   INCATLG,0(R3)      SET UP DATASET NAME\n         SPACE\nNOSMCA   DS    0H                                                   RH\n         LINK  EP=IDCAMS,PARAM=(OPTIONS,DNAMES,PGNO,IOLIST),VL=1\n         ST    R15,IDCCODE        SAVE RC\n         AGO   .IDC2\n         LTR   R15,R15            WAS LINK OKAY\n         BNZ   ABEND              NO, ABEND\n         TM    SW,X'40'           END OF LINKS ?\n         BZ    NOSMCA             NO,  DO ANOTHER ONE\n         SPACE 1\n         NI    SW,255-X'40'       CLEAR SWITCH\n         L     R1,VVDSADDR        R1 -> TO 1ST VVDS\n         ST    R1,VVDSREC         SAVE IT'S ADDRESS\n         OPEN  (REPORT,(OUTPUT))\n         TM    REPORT+48,X'10'    DID REPORT FILE OPEN ?            RH\n         BZ    NEXTCAT            NO                                RH\n*        HDUMP OUTDCB,0,0,NOTOPEN,OPEN   OPEN SYSOUT         DEBUG  RH\n*        HDUMP OUTDCB,0,0,TITLE='BACK FROM IDCAMS'           DEBUG  RH\n         SPACE 1\nDYNLOOP  DS    0H\n         L     R2,VVDSREC         R2 -> TO VVDS NAME\n*                                 DUMP 44 BYTES AT R2        DEBUG  RH\n*        HDUMP OUTDCB,R2,44,OPEN,OPEN                        DEBUG  RH\n*        L     R3,DSSEJFCB        R3 -> TO JFCB              DEBUG  RH\n*                                 DUMP 1024 BYTES AT JFCB    DEBUG  RH\n*        HDUMP OUTDCB,R3,1024,OPEN,CLOSE                     DEBUG  RH\n*        HDUMP OUTDCB,0,0,TITLE='DUMP REGS ONLY'             DEBUG  RH\n         MVC   PRINT+1(6),6(R2)   MVC IT TO PRINT AREA\n         PUT   REPORT,PRINT       PRINT IT\n         LA    R2,12(0,R2)        R2 -> TO NEXT VVDS NAME\n         ST    R2,VVDSREC         SAVE IT\n         L     R1,VVDSCTR         R1 = NUMBER OF VVDS'S\n*        LTR   R1,R1              ANY MORE ?\n*        BZ    NEXTCAT            NO, GET NEXT CATALOG NAME\n*        BZ    SVC3               NO\n         BCTR  R1,0               -1\n         ST    R1,VVDSCTR         SAVE NUMBER LEFT\n         LTR   R1,R1              ANY MORE ?\n         BZ    NEXTCAT            NO, GET NEXT CATALOG NAME\n         SPACE 1\n*        LA    R1,PARML           R1 -> TO DYNALLOC PARMS\n*        L     R15,=V(DYNALOC)    R15 -> TO DYNALLOC CODE\n*        BALR  R14,R15            GO FOR IT\n         B     DYNLOOP            GO FOR NEXT VVDS\n.IDC2    ANOP\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              RETURN TO CALLER WITH RC IN R15                        *\n*                                                                     *\n***********************************************************************\n*\nSVC3     DS    0H\nENDVTOC  SECEXIT BASE=2,GEN=YES   RETURN TO CALLER\n         SPACE 3\n*\nPARMADDR DS    F                  SET UP ATTACH NAME\nIDCCODE  DC    F'0'\nOPTIONS  DC    H'0'\nDNAMES   DC    H'0'\nPGNO     DC    H'0'\nIOLIST   DC    F'2'\n         DC    A(ASYSIN)          CONTROLLER FOR SYSIN\n         DC    A(INRTN)\n         DC    A(AUDATA)\n         DC    A(BSYSOUT)         CONTROLLER FOR SYSPRINT\n         DC    A(OUTRTN)\n         DC    A(BUDATA)\nASYSIN   DC    CL10'DDSYSIN'\nBSYSOUT  DC    CL10'DDSYSPRINT'\nAUDATA   DC    CL256' '\nBUDATA   DC    CL256' '\n         SPACE 5\n* DYNALLOC PARAMETER LIST\n         DS    0D\n         ENTRY VVDSADDR\nVVDSADDR DC    A(VVDSNAME)\nVVDSLTH  DC    AL1(128)\n         DC    AL3(600)           ROOM FOR 50 VOLSERS....\nPARML2   DC    A(VVDSNAME)\n         DC    XL1'80',AL3(VVDSVOL)\n*\nVVDSNAME DC    CL44' '\nVVDSVOL  DC    CL6' '\n*\n         SPACE 1\n*\n*        ENTRY POINT\n*\n*NRTN    CSECT\n*NRTN    AMODE 24\n*NRTN    RMODE 24\nINRTN    DS    0H\n         USING *,R15      GET TEMP ADDRESSABILITY\n         B     AROUND2            BRANCH AROUND DUMP TITLE\n         DC    AL1(EYELTH2)       LTH OF EYE CATCHER\nEYECAT2  DS    0C\n         DC    C'INRTN  '         PROGRAM NAME\n         DC    C' VERSION 2.0 '   VERSION\n         DC    CL8'&SYSDATE'      DATE WRITTEN\n         DC    CL6'&SYSTIME'      TIME WRITTEN\n         DC    C'..MAKE 31-BIT COMPLIANT'    COMMENT\n*        DC    C'..HANDLE AMODE 31 MODULES'    COMMENT\nEYELTH2  EQU   *-EYECAT2          LTH OF EYE CATCHER\n         SPACE 1\nAROUND2  DS    0H\n         LA    R1,0(0,R1)         CLEAR HI-ORDER BYTE FOR 31 BIT\n         LA    R13,0(0,R13)       CLEAR HI-ORDER BYTE FOR 31 BIT\n         BSM   R14,0              SAVE CURRENT AMODE\n         STM   R14,R12,12(R13)    SAVE CALLERS REGS\n         LR    R12,R15            SET OUR 1ST BASE REG\n         DROP  R15                DROP TEMP BASE\n         USING INRTN,R12,R11      SET OUR ADDRESSABILITY\n         LA    R11,4095(0,R12)   LOAD SECOND BASE REGISTER\n         LA    R11,1(0,R11)      LOAD SECOND BASE REGISTER\n         SPACE 1\n         LA    15,INSAVE\n         ST    13,4(15)\n         ST    15,8(13)\n         LR    13,15\n*        B     CONT2\n         SPACE\n*NSAVE   DC    18F'0'\n         SPACE\nCONT2    DS    0H\n         L     R2,4(0,R1)         R2 -> TO IOFLAGS                  RH\n         USING IOFLAGS,R2         SET BASE                          RH\n         CLI   IOFLAG1,IOFOPEN    OPENING SYSIN?\n*        BE    RETRC0             YES, SAY OPEN WAS OK\n         BE    OPENIN             YES, SAY OPEN WAS OK\n         CLI   IOFLAG1,IOFCLOS    CLOSE SYSIN?\n         BE    RETRC0             YES, SAY CLOSE WAS OKAY\n*        BE    CLOSIN             YES, GO CLOSE IT\n         TM    IOFLAG1,IOFGET     DOES IDCAMS WANT A RECORD?\n         BO    GIVEREC            YES, PASS IT A PRINT CMD\n         B     RETRC12            IGNORE EVERYTHING ELSE\n         SPACE 1\nGIVEREC  DS    0H\n         L     R3,8(0,R1)         R3 -> TO RECORD AREA\n         USING IOINFO,R3          SET BASE                          RH\n         L     R15,INREC          R15 -> TO PRINT CTL RECORD\n         LH    R14,0(0,R15)       R14 = LTH OF RECORD\n         ST    R14,IOIRECL        PASS IT TO IDCAMS\n         LA    R1,2(0,R15)        R1 -> TO RECORD\n         ST    R1,IOIREC          PASS IT TO IDCAMS\n         AR    R15,R14            ADD REC LTH TO R15\n         LA    R15,2(0,R15)       R15 -> TO NEXT REC\n         ST    R15,INREC          SAVE ITS ADDRESS\n         CLC   0(2,R1),ENDATA     END OF INPUT TO IDCAMS?\n         BE    RETRC4             YES\n         SPACE 1\nRETRC0   DS    0H\n         LA    R15,0              SAY  GET WAS OK                   RH\n         B     RET2               GO BACK TO IDCAMS                 RH\nRETRC4   DS    0H\n         LA    R15,4              SAY  NO MORE SYSIN                RH\n         B     RET2               GO BACK TO IDCAMS                 RH\n         SPACE 1\nCLOSIN   DS    0H\n*        CLOSE INFILE             CLOSE SYSIN\n*        B     RETRC0             RETURN\n         SPACE 1\nOPENIN   DS    0H\n         LA    R15,INLTH          R15 -> TO 1ST INPUT AREA\n         ST    R15,INREC          RESET INPUT REC ADDRESS\n         B     RETRC0             GO SET RC AND RETURN\n*        OPEN  (INFILE,(INPUT))\n*        TM    INFILE+48,X'10'    DID REPORT FILE OPEN ?            RH\n*        BO    RETRC0             YES                               RH\n         SPACE 1\nRETRC12  DS    0H\n         LA    R15,12             SAY CALL WAS BAD                  RH\n         B     RET2               GO BACK TO IDCAMS                 RH\n         SPACE 1\nRET      LA    15,0          GET RETURN CODE\n         ORG   *-2\nRETRC    DS    H             HALF WORD RETURN CODE, INITIALY ZERO\nRET2     DS    0H\n         L     R13,4(R13)         R13 -> TO CALLERS SAVE AREA\n         L     R14,12(R13)        SET R14 TO CALLER'S R14\n         LM    R0,R12,20(R13)     SET R0-R12 TO CALLERS REGS\n*              GET INTO PROPER MODE AND GO BACK TO CALLER\n         BSM   0,R14              RETURN TO CALLING PROGRAM\n*\n         SPACE 1\nINSAVE   DC    18F'0'\n*\nINREC    DC    A(INLTH)\nINLTH    DC    AL2(INCTLL)\nINCTL    DC    C' LISTCAT ENT( '                        14\nINCATLG  DC    CL44' '                                  44\n         DC    C' ) VOL '                                7\n         DC    CL(80-(*-INCTL))'  '                     80 LONG...\nINCTLL   EQU   *-INCTL\n*\nINLTH2   DC    AL2(2)\nENDATA   DC    C'/*'\n         SPACE 1\n         AGO   .IDC3\nINFILE   DCB   DSORG=PS,DDNAME=CATIN,LRECL=80,RECFM=FB,             XXXX\n               MACRF=(GM),EODAD=SVC3\nSTEPCAT  DCB   DSORG=PS,DDNAME=STEPCAT,LRECL=80,RECFM=FB,           XXXX\n               MACRF=(GM),BLKSIZE=80,EXLST=JFCBADD\n         DS    0F\n         DC    C'JFCB'            KEEP JFCB AT REPORT+352           RH1\nJFCBDSNM DS    0C\nJFCB     DC    CL176' '\n*        ORG   JFCB               BACK TO START OF JFCB\n*        IEFJFCBN                 GEN JFCB LABELS\nJFCBADD  DC    X'87'              JFCB ADDRESS                      RH1\n         DC    AL3(JFCB)          *                                 RH1\n         EJECT\n.IDC3    ANOP\n         DROP  R12,R11            DROP OUR BASE\n*\n*        ENTRY POINT\n*\n*UTRTN   CSECT\n*UTRTN   AMODE 24\n*UTRTN   RMODE 24\nOUTRTN   DS    0H\n         USING *,R15      GET TEMP ADDRESSABILITY\n         B     AROUND3            BRANCH AROUND DUMP TITLE\n         DC    AL1(EYELTH3)       LTH OF EYE CATCHER\nEYECAT3  DS    0C\n         DC    C'OUTRTN '         PROGRAM NAME\n         DC    C' VERSION 2.0 '   VERSION\n         DC    CL8'&SYSDATE'      DATE WRITTEN\n         DC    CL6'&SYSTIME'      TIME WRITTEN\n         DC    C'..MAKE 31-BIT COMPLIANT'    COMMENT\n*        DC    C'..HANDLE AMODE 31 MODULES'    COMMENT\nEYELTH3  EQU   *-EYECAT3          LTH OF EYE CATCHER\n         SPACE 1\nAROUND3  DS    0H\n         LA    R1,0(0,R1)         CLEAR HI-ORDER BYTE FOR 31 BIT\n         LA    R13,0(0,R13)       CLEAR HI-ORDER BYTE FOR 31 BIT\n         BSM   R14,0              SAVE CURRENT AMODE\n         STM   R14,R12,12(R13)    SAVE CALLERS REGS\n         LR    R12,R15            SET OUR 1ST BASE REG\n         DROP  R15                DROP TEMP BASE\n         USING OUTRTN,R12,R11     SET OUR ADDRESSABILITY\n         LA    R11,4095(0,R12)   LOAD SECOND BASE REGISTER\n         LA    R11,1(0,R11)      LOAD SECOND BASE REGISTER\n         LA    15,OUTSAVE\n         ST    13,4(15)\n         ST    15,8(13)\n         LR    13,15\n         SPACE\nCONT3    DS    0H\n         L     R2,4(0,R1)         R2 -> TO IOFLAGS                  RH\n         USING IOFLAGS,R2         SET BASE                          RH\n         CLI   IOFLAG1,IOFOPEN    OPENING SYSPRINT ?\n         BE    OPENSYS            YES, SAY OPEN WAS OK\n         CLI   IOFLAG1,IOFCLOS    CLOSE SYSPRINT ?\n         BE    CLOSOUT            YES, GO CLOSE IT\n         TM    IOFLAG1,IOFPUT     DOES IDCAMS HAVE A RECORD FOR US?\n         BO    GETREC             YES, GO GET IT\n         B     OUTRC12            IGNORE EVERYTHING ELSE\n         SPACE 1\nCLOSOUT  DS    0H\n*        CLOSE REPORT             CLOSE SYSPRINT\n         OI    SW,X'40'           SAY END OF CALLS\n         B     OUTRC0             RETURN\n*        B     OUTRC12            RETURN\n         SPACE 1\nGETREC   DS    0H\n         L     R3,8(0,R1)         R3 -> TO RECORD AREA\n         USING IOINFO,R3          SET BASE                          RH\n         L     R5,IOIREC          R5 -> TO RECORD FROM IDCAMS\n         L     R4,IOIRECL         R4 = LTH OF RECORD\n         SPACE 1\nCHKLTH   CH    R4,=H'133'         LTH OVER 133?\n         BL    LTHOK              NO\n         MVC   PRINT,0(R5)        MOVE 133 BYTES\n         LA    R5,133(0,R5)       R5 -> TO NEXT 133 BYTES\n         SH    R4,=H'133'         R4 = LTH LEFT\n         B     PUTITI             PRINT IT\n         SPACE 1\nLTHOK    DS    0H\n         BCTR  R4,0               -1 FOR HEX LTH\n         STC   R4,PUTLTH+1        SET LTH\nPUTLTH   MVC   PRINT(0),0(R5)     MOVE DATA\n         SR    R4,R4              R4=0\n         SPACE 1\nPUTITI   DS    0H\n*        PUT   REPORT,PRINT       PRINT IT\n         LA    R14,PRINT+1        R14 -> TO DATA AFTER CC\n         LA    R15,20             R15 = NBR CHARS TO CHECK\n*\nPUTIT2I  DS    0H\n         CLI   0(R14),C' '        FOUND NON BLANK?\n         BNE   PUTIT4I            YES\n         LA    R14,1(0,R14)       NO, R14 -> AT NEXT BYTE\n         BCT   R15,PUTIT2I        CHECK MAX CHARS\n         B     ENDPUT             MUST BE A BLANK LINE....\n*\nPUTIT4I  DS    0H\n         CLC   =C'VOLSER---',0(R14)  DO WE WANT THIS RECORD?\n         BNE   ENDPUT             NO\n*\n*    ONCE WE FIND THE VOL INFO IN THE IDCAMS OUTPUT,\n*    IT SHOULD LOOK LIKE THIS.....\n*\n*    VOLSER------------B16038     DEVTYPE------X'78048081'\n*\n*    THE DEVTYPE HAS TO BE CONVERTED TO HEX\n*\n*VOLREC  DSECT\n*        DS    CL18               JUNK BEFORE VOLSER...\n*IDCVOL  DS    CL6                THE VOLSER\n*        DS    CL20               JUNK BEFORE THE DEVTYPE...\n*IDCDEV  DS    CL8                THE VOLSER DEVTYPE IN DECIMAL\n*\n         USING VOLREC,R14         SET VOLSER RECORD BASE\n         PACK  PACKDEV(5),IDCDEV(9)  PACK DEVTYPE TO MAKE IT HEX...\n*\n*              NOW SET UP PSEUDO LOCATE WORK AREA....\n*\nGOTVVDS  DS    0H\n         L     R6,VVDSCTR         R6 = VVDS COUNTER\n         LA    R6,1(0,R6)         ADD 1 TO R6\n         ST    R6,VVDSCTR         SAVE IT\n         L     R1,=V(VVDSADDR)    R1 -> A(FIRST VOLSER ENTRY)\n         L     R1,0(0,R1)         R1 ->   FIRST VOLSER ENTRY\n         C     R6,MAXVVDS         MORE THAN MAX VVDS RECORDS?\n         BNH   GOTVVDS2           NO\n         STC   R6,0(0,R1)         COUNT ALL VOLS\n         B     OUTRC0             GO GET THE NEXT RECORD\n*        MVI   0(R1),X'FF'        SAY TOO MANY VOLSERS.....\n*        B     OUTRC12            YES, END OF IDCAMS\n         SPACE 1\n*        PUT   REPORT,PRINT       PRINT IT\n         SPACE 1\n*\nGOTVVDS2 DS    0H\n         STH   R6,0(0,R1)         SET NBR ENTRIES\n*\n         L     R6,VVDSREC         R6 -> TO WHERE VVDS NAME IS SAVED\n         MVC   0(2,R6),=X'0001'   SET COUNT TO 1\n         MVC   2(4,R6),PACKDEV    SET DEVTYPE\n         MVC   6(6,R6),IDCVOL     SET VOLSER\n         DROP  R14                DROP VOLSER RECORD BASE\n         LA    R6,12(0,R6)        ADD 12 TO R6\n         ST    R6,VVDSREC         SAVE IT\n*\n*        L     R6,VVDSCTR         R6 = VVDS COUNTER\n*        LA    R6,1(0,R6)         ADD 1 TO R6\n*        ST    R6,VVDSCTR         SAVE IT\n*        L     R1,=V(VVDSADDR)    R1 -> A(FIRST VOLSER ENTRY)\n*        L     R1,0(0,R1)         R1 ->   FIRST VOLSER ENTRY\n*        STH   R6,0(0,R1)         SET NBR ENTRIES\n*        C     R6,MAXVVDS         MORE THAN MAX VVDS RECORDS?\n*        BNH   ENDPUT             NO\n*        MVI   0(R1),X'FF'        SAY TOO MANY VOLSERS.....\n*        B     OUTRC12            YES, END OF IDCAMS\n*        SPACE 1\n*        PUT   REPORT,PRINT       PRINT IT\n         SPACE 1\nENDPUT   DS    0H\n         MVI   PRINT,C' '         CLEAR PRINT LINE\n         MVC   PRINT+1(132),PRINT ''\n         LTR   R4,R4              ANY LEFT?\n         BP    CHKLTH             YES, GO PRINT IT\n         SPACE 1\n         B     OUTRC0             GO GET THE NEXT RECORD\n         SPACE 1\nOPENSYS  DS    0H\n*        OPEN  (REPORT,(OUTPUT))\n*        TM    REPORT+48,X'10'    DID REPORT FILE OPEN ?            RH\n*        BZ    OUTRC12            NO                                RH\n         SPACE 1\nOUTRC0   DS    0H\n         LA    R15,0              SAY  GET WAS OK                   RH\n         B     RET4               GO BACK TO IDCAMS                 RH\n         SPACE 1\nOUTRC12  DS    0H\n         LA    R15,12             SAY CALL WAS BAD                  RH\n         B     RET4               GO BACK TO IDCAMS                 RH\n         SPACE 1\nRET3     LA    15,0          GET RETURN CODE\n         ORG   *-2\nRETRC2   DS    H             HALF WORD RETURN CODE, INITIALY ZERO\nRET4     DS    0H\n         L     R13,4(R13)         R13 -> TO CALLERS SAVE AREA\n         L     R14,12(R13)        SET R14 TO CALLER'S R14\n         LM    R0,R12,20(R13)     SET R0-R12 TO CALLERS REGS\n*              GET INTO PROPER MODE AND GO BACK TO CALLER\n         BSM   0,R14              RETURN TO CALLING PROGRAM\n*\nOUTSAVE  DC    18A(0)\nPACKDEV  DC    PL5'0'\n         SPACE 1\n*        AGO   .IDC4\n*REPORT  DCB   DSORG=PS,DDNAME=IDCPRINT,LRECL=133,RECFM=FBA,        XXXX\n               MACRF=(PM),BLKSIZE=133\n         SPACE 1\nSW       DC    X'00'\nPRINT    DC    CL133' '\nVVDSCTR  DC    F'0'\n         ENTRY MAXVVDS\nMAXVVDS  DC    A(1)\nVVDSREC  DC    A(VVDSREC1)\nVVDSREC1 DC    CL44' '\n*        DC    19CL44' '\n         LTORG\nIOFLAGS  DSECT\nIOFLAG1  DS    X\nIOFOPEN  EQU   X'00'\nIOFCLOS  EQU   X'04'\nIOFGET   EQU   X'08'\nIOFPUT   EQU   X'0C'\nIOFLAG2  DS    X\nIOFIN    EQU   X'80'\nIOFOUT   EQU   X'40'\nIOFLAG3  DS    X\nIOFLAG4  DS    X\n         SPACE 1\nIOINFO   DSECT\nIOIREC   DS    F\nIOIRECL  DS    F\n         SPACE 1\n*\n*    ONCE WE FIND THE VOL INFO IN THE IDCAMS OUTPUT,\n*    IT SHOULD LOOK LIKE THIS.....\n*\n*    VOLSER------------B16038     DEVTYPE------X'78048081'\n*\nVOLREC   DSECT\n         DS    CL18               JUNK BEFORE VOLSER...\nIDCVOL   DS    CL6                THE VOLSER\n         DS    CL20               JUNK BEFORE THE DEVTYPE...\nIDCDEV   DS    CL8                THE VOLSER DEVTYPE IN DECIMAL\n         SPACE 1\n         REQUATE SAVE=YES,REGS=YES,E=NO\n         END\n/*\n//*\n//LKED.SYSLMOD DD DSN=&&TEMP,UNIT=SYSDA,DISP=(NEW,PASS),\n//   SPACE=(TRK,(15,5,5))\n//LKED.SYSIN DD *\n    ENTRY SPACE\n    SETCODE AC(0)\n    MODE    AMODE(31) RMODE(24)\n    NAME  DSSUPER(R)\n/*\n//*\n//*      ASSEMBLE HELP PANEL CODE....\n//*\n//HELP  EXEC HLASMCL,PARMC='ESD',PARML='LIST,LET,MAP,NCAL'\n//ASM.SYSLIB DD DSN=SYS1.MACLIB,\n//   DISP=SHR\n//   DD DSN=SYS1.MODGEN,DISP=SHR\n//ASM.SYSPRINT DD SYSOUT=*\n//ASM.SYSIN DD *\nSP       TITLE  'TSO SPACE COMMAND HELP PANEL'\nHELPPAN  CSECT\nHELPPAN  AMODE 31\nHELPPAN  RMODE 24\n         STM       R14,R12,12(R13)\n         LR    R11,R15\n         USING     HELPPAN,R11\n         LR        PARMPTR,R1\n*        L         R0,ALWORK\n*ETWORK  GETMAIN   R,LV=(0)\n*        XC        0(LWORK,R1),0(R1)\n         LA    R1,HELPSAVE\n         ST        R13,4(0,R1)\n         ST        R1,8(R13)\n         LR    R13,R1             R13 -> TO OUR SAVE AREA\n         AGO   .HELP1\n*        LR        WORKPTR,R1\n*        USING     WORK,WORKPTR\n         L         PARMPTR,0(PARMPTR)\n         USING     SDV,PARMPTR\n         L         R1,SDVADDR\n         LH    R0,0(,R1)          R0 = LTH OF MSG\n         LA    R1,2(,R1)          R1 -> TO MSG\n         L     R3,=V(SW3)         R3 -> TO SW3 IN SPACE PGM\n         TM    0(R3),SW380        IS THIS A BATCH RUN ?\n         BZ    PUTIT              NO, GO DO A TPUT\n         LR    R4,R0              R4 = LTH OF MSG\n         BCTR  R4,0               R4 = HEX LTH OF MSG\n         L     R3,=V(INFO1)       R3 -> TO MSG AREA\n         EX    R4,MVCMSG          MOVE MSG TO PRINT LINE\n*VCMSG   MVC   0(0,R3),0(R1)      MVC MSG TO PRINT LINE\n         L     R1,=V(REPORT)      R1 -> TO REPORT DCB\n         SPACE 1\nPUTITP   DS    0H\n         L     R0,=V(INFO1)       R0 -> TO REPORT PRINT LINE\n         PUT   (1),(0)            OUTPUT THE MSG\n         SPACE 1\n         MVI   0(R3),C'0'         CHANGE CC TO DOUBLE SPACE\n         MVI   1(R3),C' '         CLEAR PRINT LINE\n         MVC   2(131,R3),1(R3)    *\n         B     HELPEND            RETURN TO PLI PGM\n         SPACE 1\nPUTIT    DS    0H\n         L     R3,=V(SWITCHWD)    R3 -> TO SWITCHWD IN SPACE PGM\n         TM    0(R3),PRINTIT      PRINT TO A FILE?\n         BZ    PUTIT2             NO, GO DO A TPUT\n         LR    R4,R0              R4 = LTH OF MSG\n         BCTR  R4,0               R4 = HEX LTH OF MSG\n         L     R3,=V(INFO1)       R3 -> TO MSG AREA\n         EX    R4,MVCMSG          MOVE MSG TO PRINT LINE\n*VCMSG   MVC   0(0,R3),0(R1)      MVC MSG TO PRINT LINE\n         L     R1,=V(PRTDCB)      R1 -> TO OUTPUT DCB\n         B     PUTITP             GO PUT RECORD IN FILE\n         SPACE 1\nPUTIT2   DS    0H\n         MVI   0(R1),C' '         REMOVE CC FOR TPUT\n*        TPUT  (1),(0),R\n*        AGO   .PUT1\n*        LA    R2,L'DLINE         ENTIRE LINE LENGTH\n*        LA    R2,4(0,R2)         ADD RDW LEN\n*        STH   R2,RDWP\n*        LA    R2,L'DLINE         ENTIRE LINE LENGTH\n*        MVI   BUFFER,C' '        CLEAR BUFFER\n*        MVC   BUFFER,+1(119),BUFFER    ....\n         LR    R2,R0              R2 = LINE LTH\n         BCTR  R2,R0              R2 = HEX LINE LTH\n         EX    R2,MOVEDATA        SET UP PRINT LINE.\n         LA    R2,5(0,R2)         ADD RDW LEN + 1 WE TOOK OFF\n         STH   R2,RDWP\n*        ST    R1,PUTMSG          SAVE A(LINE) IN PLI PGM....\n*        MVC   BUFFER,DLINE\n.HELP1   ANOP\n         GTSIZE ,                 GET SCREEN SIZE\n         LTR   R0,R0                    SEE IF A SCREEN\n         BZ    NOCLR1             NOT, SO NO CLEAR\n         STFSMODE ON,INITIAL=YES        TELL TSO/VTAM IN FULLSCRN\n         TPUT  BLANKOUT,L'BLANKOUT,FULLSCR    BLANK OUT THE SCREEN\n         STFSMODE OFF                   TELL TSO/VTAM OUT OF FULLSC N\n         SPACE 1\nNOCLR1   DS    0H\n         L     R1,=V(ECB)         R1 -> TO ECB\n         XC    0(4,R1),0(R1)      MAKE SURE IT'S CLEAR\n         L     R1,=V(IOPLADD)     R1 -> TO IOPL LIST\n         XC    0(4,R1),0(R1)      MAKE SURE IOPLUPT IS CLEAR....\n         PUTLINE PARM=PUTHELP,OUTPUT=(HELPPG1,TERM,MULTLIN,DATA),      +\n               MF=(E,(1))\n*              MF=(E,IOPLADD)\n         TGET  REPLY,80,EDIT,WAIT GET INPUT\n         GTSIZE ,                 GET SCREEN SIZE\n         LTR   R0,R0                    SEE IF A SCREEN\n         BZ    NOCLR2             NOT, SO NO CLEAR\n         STFSMODE ON,INITIAL=YES        TELL TSO/VTAM IN FULLSCRN\n         TPUT  BLANKOUT,L'BLANKOUT,FULLSCR    BLANK OUT THE SCREEN\n         STFSMODE OFF                   TELL TSO/VTAM OUT OF FULLSC N\n         SPACE 1\nNOCLR2   DS    0H\n         L     R1,=V(ECB)         R1 -> TO ECB\n         XC    0(4,R1),0(R1)      MAKE SURE IT'S CLEAR\n         L     R1,=V(IOPLADD)     R1 -> TO IOPL LIST\n         XC    0(4,R1),0(R1)      MAKE SURE IOPLUPT IS CLEAR....\n         PUTLINE PARM=PUTHELP,OUTPUT=(HELPPG2,TERM,MULTLIN,DATA),      +\n               MF=(E,(1))\n*              MF=(E,IOPLADD)\n         TGET  REPLY,80,EDIT,WAIT GET INPUT\n.PUT1    ANOP\n*        LR        R1,WORKPTR\n*        L         R13,4(WORKPTR)\n         SPACE 1\nHELPEND  DS    0H\n         L     R13,HELPSAVE+4\n*        L         R0,ALWORK\n*REEWORK FREEMAIN  R,LV=(0),A=(1)\n         LM        R14,R12,12(R13)\n         BR        R14\nMOVEDATA MVC   BUFFER,0(R1)       SET UP PRINT LINE.\nBLANKOUT DC    X'401140403C404000114040'    MESSAGE TO BLANK OUT SCREEN\n         DS        0D\n*LWORK   DC        AL1(0),AL3(LWORK)\nHELPSAVE DS    9D\nMVCMSG   MVC   0(0,R3),0(R1)      MVC MSG TO PRINT LINE\nPUTHELP  PUTLINE MF=L\nRDWP     DC    F'0'\nREPLY    DC    CL80' '            TGET BUFFER\nBUFFER   DS    CL120' '\n*\n*        NOTE  ... THE FOLLOWING PARMS ARE SET UP IN PL1 FORMAT\n*                  FOR HELPPAN.\n*\n         DS    0H\n*PUTMSG  DC    A(PUT1MSG)\n*UT1MSG  DC    AL2(PUTLTH1)\n*UTMSG1  DC    CL120' '\n*UTLTH1  EQU   *-PUTMSG1\n*        ENTRY ECB,IOPLADD\n*ECB     DC    F'0'\n*IOPLADD DS    4F\n*\nLITERALS LTORG\n*\n*    REGISTER EQUATES\nPARMPTR  EQU   10\nHELPMSG  DS    0C\n*\n*              PAGE 1\n*\nHELPPG1  DS    0A\nP1L1     DC    A(P1L2)\n         DC    AL2(L'L1P1+4),H'0'\n*        DC    H'0'\nL1P1     DC    C'THE DS COMMAND CAN BE USED TO DISPLAY OR PRINT'\nP1L2     DC    A(P1L3)\n*        DC    AL2(84)\n*        DC    H'0'\n         DC    AL2(L'L2P1+4),H'0'\nL2P1     DC    C'DATA SET CHARACTERISTICS, CURRENT SPACE ALLOCATION'\nP1L3     DC    A(P1L4)\n         DC    AL2(L'L3P1+4),H'0'\nL3P1     DC    C'AND USAGE, TOTALS, AND PERCENT CALCULATION FOR A'\nP1L4     DC    A(P1L5)\n         DC    AL2(L'L4P1+4),H'0'\nL4P1     DC    C'SPECIFIED DATA SET OR GROUP OF DATA SETS AT THE'\nP1L5     DC    A(P1L6)\n         DC    AL2(L'L5P1+4),H'0'\nL5P1     DC    C'TERMINAL, TO A SEQUENTIAL DATA SET, OR TO SYSPRINT'\nP1L6     DC    A(P1L7)\n         DC    AL2(L'L6P1+4),H'0'\nL6P1     DC    C'IF THE DS COMMAND IS RUN IN BATCH.'\nP1L7     DC    A(P1L8)\n         DC    AL2(L'L7P1+4),H'0'\nL7P1     DC    C' '\nP1L8     DC    A(P1L9)\n         DC    AL2(L'L8P1+4),H'0'\nL8P1     DC    C'SYNTAX:'\nP1L9     DC    A(P1L10)\n         DC    AL2(L'L9P1+4),H'0'\nL9P1     DC    C'DS ''SEARCH-KEY'' VOL(''VOL-SER-LIST''/''VOL-SER'')'\nP1L10    DC    A(P1L11)\n         DC    AL2(L'L10P1+4),H'0'\nL10P1    DC    C' UNIT(''UNIT-NAME'') MAX(''NNNN'') PRINT(''DSNAME'')'\n*10P1    DC    CL33'   UNIT(''UNIT-NAME'') MAX(''NNNN'') '\n*        DC    CL47'PRINT(''DSNAME'')'\nP1L11    DC    A(P1L12)\n         DC    AL2(L'L11P1+4),H'0'\nL11P1    DC    C'   TOTAL(YES/NO) NOLIST ALLOC(''DSN'')'\nP1L12    DC    A(P1L13)\n         DC    AL2(L'L12P1+4),H'0'\nL12P1    DC    C' '\nP1L13    DC    A(P1L14)\n         DC    AL2(L'L13P1+4),H'0'\nL13P1    DC    C'REQUIRED - NONE.'\nP1L14    DC    A(P1L15)\n         DC    AL2(L'L14P1+4),H'0'\nL14P1    DC    C'DEFAULTS - ''SEARCH-KEY'' TO USER ID.'\nP1L15    DC    A(P1L16)\n         DC    AL2(L'L15P1+L'L15AP1+4),H'0'\n*15P1    DC    C'   ''VOL-SER'' TO USERS HIGH-LEVEL-INDEX VOLUME.'\nL15P1    DC    C'           ''VOL-SER'' TO USERS HIGH-LEVEL'\nL15AP1   DC    C'-INDEX VOLUME.'\nP1L16    DC    A(P1L17)\n         DC    AL2(L'L16P1+4),H'0'\nL16P1    DC    C'           ''UNIT-NAME'' TO ''USER'''\nP1L17    DC    A(P1L18)\n         DC    AL2(L'L17P1+4),H'0'\nL17P1    DC    C'           ''NNNN'' TO 9999'\nP1L18    DC    A(P1L19)\n         DC    AL2(L'L18P1+4),H'0'\nL18P1    DC    C'           ''DSNAME'' TO TERMINAL (NO FILE)'\nP1L19    DC    A(P1L20)\n         DC    AL2(L'L19P1+4),H'0'\nL19P1    DC    C'            TOTAL(YES) IF SEARCH-KEY IS A DATA SET.'\nP1L20    DC    A(P1L21)\n*        DC    AL2(L'L20P1+4),H'0'\n         DC    AL2(L'L20P1+L'L20AP1+4),H'0'\n*20P1    DC    C' TOTAL(NO) IF SEARCH-KEY IS A HIGH LEVEL INDEX.'\nL20P1    DC    C'            TOTAL(NO) IF SEARCH-KEY IS A HIGH '\nL20AP1   DC    C'LEVEL INDEX.'\nP1L21    DC    A(P1L22)\n         DC    AL2(L'L21P1+4),H'0'\nL21P1    DC    C'            LIST.'\nP1L22    DC    A(P1L23)\n         DC    AL2(L'L22P1+4),H'0'\nL22P1    DC    C' '\nP1L23    DC    A(P1L24)\n         DC    AL2(L'L23P1+4),H'0'\nL23P1    DC    C'ALIAS - NONE'\nP1L24    DC    A(0)\n         DC    AL2(L'L24P1+4),H'0'\nL24P1    DC    C'*** PRESS ENTER TO CONTINUE...'\n*        DC    C' '\n*\n*              PAGE 2\n*\nHELPPG2  DS    0A\nP2L1     DC    A(P2L2)\n*        DC    AL2(84)\n*        DC    H'0'\n         DC    AL2(L'L1P2+4),H'0'\nL1P2     DC    C'TO RUN THE DS COMMAND IN BATCH, THE FOLLOWING JCL'\nP2L2     DC    A(P2L3)\n         DC    AL2(L'L2P2+4),H'0'\nL2P2     DC    C'CAN BE USED :'\nP2L3     DC    A(P2L4)\n         DC    AL2(L'L3P2+4),H'0'\nL3P2     DC    C' //       JOB (PIN,CHGNBR),...ETC.'\nP2L4     DC    A(P2L5)\n         DC    AL2(L'L4P2+4),H'0'\nL4P2     DC    C' /*ROUTE PRINT R...      IF DESIRED'\nP2L5     DC    A(P2L6)\n         DC    AL2(L'L5P2+4),H'0'\nL5P2     DC    C' //S0      EXEC  PGM=DS,PARM=''SEARCH-KEY'''\nP2L6     DC    A(P2L7)\n         DC    AL2(L'L6P2+4),H'0'\nL6P2     DC    C' //SYSPRINT DD SYSOUT=*'\nP2L7     DC    A(P2L8)\n         DC    AL2(L'L7P2+4),H'0'\nL7P2     DC    C' //'\nP2L8     DC    A(P2L9)\n         DC    AL2(L'L8P2+4),H'0'\nL8P2     DC    C' OR '\nP2L9     DC    A(P2L10)\n         DC    AL2(L'L9P2+4),H'0'\nL9P2     DC    C' //       JOB (PIN,CHGNBR),...ETC.'\nP2L10    DC    A(P2L11)\n         DC    AL2(L'L10P2+4),H'0'\nL10P2    DC    C' /*ROUTE PRINT R...      IF DESIRED'\nP2L11    DC    A(P2L12)\n         DC    AL2(L'L11P2+4),H'0'\nL11P2    DC    C' //S0    EXEC PGM=DS'\nP2L12    DC    A(P2L13)\n         DC    AL2(L'L12P2+4),H'0'\nL12P2    DC    C' //SYSPRINT DD SYSOUT=*'\nP2L13    DC    A(P2L14)\n         DC    AL2(L'L13P2+4),H'0'\nL13P2    DC    C' //SYSIN  DD  *'\nP2L14    DC    A(P2L15)\n         DC    AL2(L'L14P2+4),H'0'\nL14P2    DC    C' HLI'\nP2L15    DC    A(P2L16)\n         DC    AL2(L'L15P2+4),H'0'\nL15P2    DC    C' DSN'\nP2L16    DC    A(P2L17)\n         DC    AL2(L'L16P2+4),H'0'\nL16P2    DC    C' HLI.INDEX.INDEX'\nP2L17    DC    A(P2L18)\n         DC    AL2(L'L17P2+4),H'0'\nL17P2    DC    C' //'\nP2L18    DC    A(P2L19)\n         DC    AL2(L'L18P2+4),H'0'\nL18P2    DC    C'WHEN RUN AS A BATCH JOB, THE SEARCH-KEY IS THE ONLY'\nP2L19    DC    A(P2L20)\n         DC    AL2(L'L19P2+4),H'0'\nL19P2    DC    C'OPERAND THAT WILL BE RECOGNIZED.'\nP2L20    DC    A(P2L21)\n         DC    AL2(L'L20P2+4),H'0'\nL20P2    DC    C' '\nP2L21    DC    A(P2L22)\n         DC    AL2(L'L21P2+4),H'0'\nL21P2    DC    C'FOR DETAILED HELP, USE ''HELP DS'' COMMAND.'\nP2L22    DC    A(0)\n         DC    AL2(L'L22P2+4),H'0'\nL22P2    DC    C'*** PRESS ENTER TO CONTINUE...'\n*        DC    C'EOF'\nSDV      DSECT\nSDVADDR  DS        A\nSDVMAXL  DS        H\nSDVFLAG  DS        H\n         SPACE 2\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   HELPPAN\n/*\n//*\n//LKED.SYSLMOD DD DSN=&&TEMP,UNIT=SYSDA,DISP=(SHR,PASS),\n//   SPACE=(TRK,(15,5,5))\n//LKED.SYSIN DD *\n    SETCODE AC(0)\n    MODE    AMODE(31) RMODE(24)\n    NAME  HELPPAN(R)\n/*\n//*\n//*\n//*DSSPART3   JOB (87944,799588),HALL.S1BL,MSGCLASS=A,\n//*  PRTY=1,USER=RH87944,GROUP=SYS1,PASSWORD=*\n//*ROUTE  PRINT  R7\n//*\n//*\n//*    THIS VERSION USES OBTAIN SEARCH AND OBTAIN SEEK\n//*    TO READ FORMAT 1 AND FORMAT 3 DSCBS IF A HLI IS\n//*    SPECIFIED, OR EXCPS TO READ THE VTOC IF 'ALL.HLI'\n//*    IS SPECIFIED.\n//*\n//*    MODIFIED DEC/87 TO HANDLE MIGRATED DATASET 'DSCBS'.\n//*    MODIFIED NOV/89 TO HANDLE 3390'S IN VTCREAD.\n//*\n//*      JUL 31/93....ADDED CODE TO READ FORMAT 4 DSCB FOR A 'NEW'\n//*                   DEVICE TO GET #DSCBS/TRK AND ADD TO TABLE\n//*                   (DSCB+44=X'F4' AND DSCB+74=X'DSCBS/TRK')\n//*\n//PRINT EXEC PLIXCL,\n//           COND=EVEN,\n//           PARMC='MARGINS(2,72,1),LIST',CLASS='*',\n//           PARML='LIST,LET,MAP,NCAL,SIZE=(1024K,512K)'\n//*          PARML='LIST,LET,MAP,SIZE=(1024K,512K)'\n//PLI.SYSIN DD *\n DSPACE:PROC(USERID,VOLSER,MAXDSN,PRINTDD,SWITCHES,MCDDSCB)\n        OPTIONS(MAIN) REORDER;\n /*    *******************************************************  */\n /*    *   DSPACE : FORMATTING AND ACCUMULATION MODULE OF THE*  */\n /*    * TSO DSPACE COMMAND PROCESSOR.                       *  */\n /*    * INPUT: R1 POINTS TO 5 FULLWORD ADDRESSES OF SDV'S   *  */\n /*    *    1). SEARCH_KEY ,STRING FOR SELECTING DATA SETS   *  */\n /*    *    2). VOLSER , VOLUME SERIAL OF VOL TO BE SEARCHED *  */\n /*    *    3). MAXDSN , MAXIMUM NUMBER OF DATA SETS TO BE   *  */\n /*    *        PRINTED.                                     *  */\n /*    *    4). PRINTDD ,FILE NAME OF OUTPUT PRINT IF NOT    *  */\n /*    *        TERMINAL.                                    *  */\n /*    *    5). SWITCHES , 1 BYTE OF BIT SWITCHES DESCRIBING *  */\n /*    *        OPTIONS TO BE USED.                          *  */\n /*    * PROCESSING:                                         *  */\n /*    *     CALLS 'VTCREAD' FOR ALL VTOC I/O                *  */\n /*    *     CALLS 'TSOPUT' FOR ALL TERMINAL I/O             *  */\n /*    *                                                     *  */\n /*    * SWITCH FUNCTIONS:                                   *  */\n /*    *    BIT 1 ON) OUTPUT IS TO BE PRINTED ON FILE.       *  */\n /*    *    BIT 2 ON) TOTALS ARE TO BE PRINTED.              *  */\n /*    *    BIT 3 ON) PERCENTS ARE TO BE CALCULATED.         *  */\n /*    *    BIT 4 ON) DON'T ZERO OUT FIELDS BEFORE           *  */\n /*    *              ACCUMULATING.                          *  */\n /*    *    BIT 5 ON) DON'T PRINT DATA SET STATISTICS,       *  */\n /*    *              (AUTOMATICALLY CAUSES TOTALING)        *  */\n /*    *    BIT 6 ON) HIGH LEVEL INDEX BEING PROCESSED.      *  */\n /*    *    BIT 7 ON) PRINT HEADING ONLY.                    *  */\n /*    *    BIT 8 ON) PRINT TOTALS ONLY.                     *  */\n /*    *                                                     *  */\n /*    * OUTPUT :                                            *  */\n /*    *    LISTING TO TERMINAL OR PRINTER FILE.             *  */\n /*    *    TOTALS OVER ALL VOLUMES.                         *  */\n /*    *                                                     *  */\n /*    * PRESENT CALCULATIONS ARE BASED ON 19 TRACKS PER     *  */\n /*    * CYLINDER.                                           *  */\n /*    *                                                     *  */\n /*    *                                                     *  */\n /*    *                                                     *  */\n /*    *                                                     *  */\n /*    *                                                     *  */\n /*    *******************************************************  */\n DCL    MAXDSN CHAR(8) VAR,\n        PRINTDD CHAR(8) VAR, SWITCHES CHAR(1) VAR,\n        SW_ARRAY(8) BIT(1) BASED(SWPTR),PRINTR FILE PRINT STREAM,\n        (TRACK_TOTAL,USED_TOTAL,TOTAL_EXT) STATIC FIXED BIN(31),\n        TRK_PER_CYL FIXED BIN(31) INIT(30) STATIC,\n        TOTDS STATIC FIXED BIN(31),\n        DSNMAX FIXED BIN(15),\n /*     USERID CHAR(44) VAR, ULEN1 FIXED BIN(15) STATIC,            */\n        USERID CHAR(44) VAR,\n        ULEN1 FIXED BIN(15) STATIC,\n        VOLSER CHAR(6),\n        (DEC_PERC,DEC_FRAG) FIXED\n            DEC(7,3),\n        (DEC_USED,DEC_TOT,DEC_TRKS,DEC_EXT) FIXED\n            DEC(7,0) ;\n\n DCL    MCDDSCB      CHAR(140) VAR ;  /* EXT ; */\n\n DCL    TSOPUT ENTRY(CHAR(120) VAR) EXT,\n        LINE CHAR(120) VAR,\n        VTCREAD\n       ENTRY(FIXED BIN(31,0),CHAR(8),PTR,FIXED BIN(31,0),CHAR(44) VAR)\n            EXTERNAL;\n     /* ASM SUB TO READ VTOC - LIFTED FROM SPRLIST */\n     /* AND MODIFIED TO BE CALLABLE FROM PL/1. */\n DCL BITDSCB(296) BIT(4) BASED(PDSCB),\n     1 F1DSCB BASED(PDSCB),\n       2 CCHHR       CHAR(5),\n       2 MBB         CHAR(3),\n       2 DSN         CHAR(44),\n       2 FORMAT#     CHAR(1),\n       2 DS1DSSN     CHAR(6),\n       2 DS1VOLSQ    BIT(16),\n       2 DS1CREDT,\n         3 CREDT1       BIT(8),\n         3 CREDT2      BIT(16),\n       2 DS1EXPDT    CHAR(3),\n       2 DS1NOEPV    BIT(8),\n       2 DS1NOBDB    BIT(8),\n       2 RESERVE1    CHAR(1),\n               /*  2 DS1SYSCD    CHAR(10), */\n               /*  2 DS1USEDT    FIXED DEC(5), */\n       2 DS1SYSCD    CHAR(13),                      /*SU60*/\n       2 DS1USEDT,                                  /*SU60*/\n         3 USEDT1       BIT(8),                     /*SU60*/\n         3 USEDT2      BIT(16),                     /*SU60*/\n               /*  2 RESERVE2    CHAR(7), */\n       2 RESERVE2    CHAR(4),                       /*SU60*/\n       2 DS1DSORG(16)BIT(1),\n       2 DS1RECFM(8) BIT(1),\n       2 DS1OPTCD(8) BIT(1),\n       2 DS1BLKL     FIXED BIN(15),\n       2 DS1LRECL    FIXED BIN(15),\n       2 DS1KEYL     BIT(8),\n       2 DS1RKP      BIT(16),\n       2 DS1DSIND(8) BIT(1),\n       2 DS1SCALO(8) BIT(1),\n       2 DS1SCAL2    BIT(24),\n       2 DS1LSTAR,\n         3 TT        BIT(16),\n         3 R         BIT(8),\n       2 DS1TRBAL    BIT(16),\n       2 RESERVE3    CHAR(2),\n       2 DS1EXT(3),\n         3 EXTENT_TYPE BIT(8),\n         3 SEQ_NUMBER  BIT(8),\n         3 LCC         BIT(16),\n         3 LHH         BIT(16),\n         3 UCC         BIT(16),\n         3 UHH         BIT(16),\n       2 DS1PTRDS     CHAR(5),\n     1 F1DSCB_OVERLAY BASED(PDSCB),\n       2 XXX         CHAR(80),\n       2 BINUSEDT,\n         3 BINUSEDT_DATA   BIT(20),\n         3 BINUSEDT_SIGN   BIT(4),\n     1 F3DSCB BASED(PDSCB),\n       2 SAME_AS_F1  CHAR(8),\n       2 KEY03       CHAR(4),\n       2 DS3EXTNT(4),\n         3 EXTENT_TYPE BIT(8),\n         3 SEQ_NUMBER  BIT(8),\n         3 LCC         BIT(16),\n         3 LHH         BIT(16),\n         3 UCC         BIT(16),\n         3 UHH         BIT(16),\n       2 DS3FMTID    CHAR(1),\n       2 DS3ADEXT(9),\n         3 EXTENT_TYPE BIT(8),\n         3 SEQ_NUMBER  BIT(8),\n         3 LCC         BIT(16),\n         3 LHH         BIT(16),\n         3 UCC         BIT(16),\n         3 UHH         BIT(16),\n       2 DS3PTRDS     CHAR(5),\n     1 DATA(DSNMAX) CTL,\n       2 DSNAME      CHAR(44),\n       2 TRACKS      FIXED BIN(31),\n       2 CREDT       FIXED DEC(5),\n       2 USEDT       FIXED DEC(5),\n       2 F#          CHAR(1),\n       2 KEY         CHAR(5),\n       2 DSORG       CHAR(3),\n       2 RECFM       CHAR(4) VAR,\n       2 BLKL        FIXED BIN(15),\n       2 LRECL       FIXED BIN(15),\n       2 USED        FIXED BIN(15),\n       2 NOEPV       FIXED BIN(15),\n     1 FORMAT3(DSNMAX*2) CTL,\n       2 F3KEY       CHAR(5),\n       2 F3TRACKS    FIXED BIN(31);\n DCL (ENTRY_TYPE,ERROR_IND,NUMDS,NUMF3) FIXED BIN(31) STATIC,\n     DDNAME CHAR(8),\n     ENTRY_TYPE2 FIXED BIN(31) STATIC INIT(0),\n     PDSCB PTR;\n /*    *******************************************************  */\n /*    *   DSPACE : MAIN CODE FOLLOWS.                       *  */\n /*    *******************************************************  */\n /*                                                             */\n ON ERROR BEGIN;\n     LINE='0ERROR CONDITION IN FORMAT PGM OF SPACE';\n /*  IF SW_ARRAY(1) THEN PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);    */\n     CALL TSOPUT(LINE);\n     GOTO END_S;\n     END;\n ALLOC :ULEN1=LENGTH(USERID);\n        DSNMAX=MAXDSN;\n         IF DSNMAX<100 THEN DSNMAX=100;\n        ALLOCATE DATA,FORMAT3;\n        SWPTR=ADDR(SWITCHES);\n /*     IF SW_ARRAY(1) THEN DO;\n  *         OPEN FILE(PRINTR) TITLE(PRINTDD) PAGESIZE(55);\n  *\n  *     END;\n  */\n /*\n  * ON ENDPAGE(PRINTR) BEGIN;\n  *   IF  SW_ARRAY(6) THEN\n  *     PUT FILE(PRINTR) SKIP(3)  EDIT('TSO SPACE ALLOCATION',\n  *         ' AND USAGE LISTING FOR ',INDEX,' LEVEL ',\n  *         USERID,'            ') (COL(1),SKIP,A,A,A,A,A,A);\n  *   ELSE\n  *     PUT FILE(PRINTR) SKIP(3)  EDIT('TSO SPACE ALLOCATION',\n  *         ' AND USAGE LISTING FOR ',VOLSER,' AT ',\n  *         USERID,' INDEX LEVEL') (COL(1),SKIP,A,A,A,A,A,A);\n  *     END;\n  */\n START:\n     IF  VOLSER = 'MIGRAT' THEN PDSCB = ADDR(MCDDSCB) ;\n\n     IF SUBSTR(USERID,1,4)  \u00ac= 'ALL.' THEN GOTO START2;\n     ENTRY_TYPE2 = 4 ;\n     IF USERID = 'ALL.DSNAMES' THEN GOTO START2 ;\n     ULEN1 = ULEN1-4 ;\n     USERID = SUBSTR(USERID,5,ULEN1) ;\n\n START2 :\n   IF SW_ARRAY(8) THEN GOTO TOTALS;    /* ONLY WANT TOTALS ?         */\n        NUMDS,NUMF3=0;\n /*\n  *           IF SW_ARRAY(1) THEN SIGNAL ENDPAGE(PRINTR);\n  */\n        IF \u00ac SW_ARRAY(4) THEN DO;     /* ZERO SOME FIELDS           */\n           TOTDS=0;\n                 TRACK_TOTAL=0;\n                 USED_TOTAL=0;\n                 TOTAL_EXT=0;\n        END;\n\n   IF SW_ARRAY(7) THEN DO;        /* PRINT HEADING                  */\n        LINE=' ';\n        PUT STRING(LINE)          EDIT('1TSO SPACE ALLOCATION',\n            ' AND USAGE LISTING FOR INDEX LEVEL ',\n            USERID) (A,A,A);\n /*     IF SW_ARRAY(1) THEN DO;\n  *        SUBSTR(LINE,1,1) = ' ' ;\n  *        PUT FILE(PRINTR) SKIP(3)  EDIT(LINE) (COL(1),A);\n  *     END ;\n  *     ELSE CALL TSOPUT(LINE);\n  */\n        CALL TSOPUT(LINE);\n\n     IF \u00ac SW_ARRAY(5) THEN DO ;\n        LINE=' ';\n        PUT STRING(LINE)\n            EDIT(' CREDT USEDT VOLSER DSO RCFM  BLK  REC TRKS',\n           ' USED EX DATA SET') (A,A);\n /*     IF SW_ARRAY(1) THEN PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);\n  *     ELSE CALL TSOPUT(LINE);\n  */\n         CALL TSOPUT(LINE);\n        GOTO END_S;\n     END;\n   END;                           /* END OF SW_ARRAY(7) CODE...     */\n\n     TRACKS=0;\n     F3TRACKS=0;\n     DDNAME=VOLSER;\n     ENTRY_TYPE=1 + ENTRY_TYPE2;\n     IF  VOLSER = 'MIGRAT' THEN GOTO MCD1 ;\n\n     CALL VTCREAD(ENTRY_TYPE,DDNAME,PDSCB,ERROR_IND,'OPEN'); /* OPEN */\n     IF ERROR_IND=4 THEN GOTO END_S;\n     IF ERROR_IND=8 THEN DO;\n         PUT STRING(LINE) EDIT('0OPEN RETURN CODE=8 - DDNAME='||DDNAME\n         ||' - CONTINUING') (A);\n /*      IF SW_ARRAY(1) THEN DO ;\n  *            SUBSTR(LINE,1,1) = ' ' ;\n  *            PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);\n  *                          END ;\n  *      ELSE CALL TSOPUT(LINE);\n  */\n         CALL TSOPUT(LINE);\n         GOTO STOP;\n     END;                         /* END OF ERROR_IND=8             */\n\n MCD1 :\n          TRK_PER_CYL = ENTRY_TYPE;   /*SET TRKS/CYL FROM RDVTOC    */\n\n GET_DSCB:\n          ENTRY_TYPE  = 0 + ENTRY_TYPE2 ;      /* READ */\n     IF  VOLSER = 'MIGRAT' THEN GOTO MCD2 ;\n\n          CALL VTCREAD(ENTRY_TYPE,DDNAME,PDSCB,ERROR_IND,USERID);\n     IF ERROR_IND=4 THEN GOTO STOP;\n     IF ERROR_IND=8 THEN DO;\n         PUT STRING(LINE) EDIT('0READ RETURN CODE=8 - DDNAME='||DDNAME\n         ||' CCHHR=',UNSPEC(CCHHR),' - CONTINUING WITH NEXT TRACK')\n         (A,B,A);\n /*      IF SW_ARRAY(1) THEN PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);\n  *      ELSE CALL TSOPUT(LINE);\n  */\n         CALL TSOPUT(LINE);\n         LINE=' ';\n /*      IF SW_ARRAY(1) THEN PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);\n  *      ELSE CALL TSOPUT(LINE);\n  */\n         CALL TSOPUT(LINE);\n         IF ENTRY_TYPE = 0 THEN GOTO STOP;\n         GOTO GET_DSCB;\n      END;\n\n\n MCD2 :\n     IF ENTRY_TYPE2 = 4 THEN GOTO TEST_F1;\n     IF FORMAT#  = '3' THEN GOTO F3;\n\n TEST_F1:\n     IF FORMAT# \u00ac= '1' THEN GOTO TEST_TYPE;\n     IF USERID   = 'ALL.DSNAMES' THEN GOTO GET_ALL;\n     IF USERID   = SUBSTR(DSN,1,ULEN1) THEN GOTO GET_ALL;\n\n TEST_TYPE:\n     IF  ENTRY_TYPE = 0 THEN GOTO STOP ;\n     IF  ENTRY_TYPE2 = 0 THEN GOTO STOP ;\n     GOTO GET_DSCB ;\n\n GET_ALL :\n     IF NUMDS=DSNMAX THEN DO;\n       LINE=' MORE THAN '||MAXDSN||' DATA SETS AT THIS LEVEL,ONLY '\n            ||MAXDSN||' LISTED';\n /*    IF SW_ARRAY(1) THEN PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);\n  *    ELSE CALL TSOPUT(LINE);\n  */\n       CALL TSOPUT(LINE);\n       LINE=' USE MAX(...) KEYWORD TO LIST MORE THAN '\n            ||MAXDSN||' DATASETS';\n       CALL TSOPUT(LINE);\n       GOTO STOP;\n     END;\n     NUMDS=NUMDS+1;\n     DSNAME(NUMDS)=DSN;\n /*    LINE=NUMDS||DSN ;          /*   DEBUG                        */\n /*    CALL TSOPUT(LINE);         /*   DEBUG                        */\n     IF DS1NOBDB THEN DSNAME(NUMDS) =\n                 SUBSTR(DSNAME(NUMDS)||'***',1,44) ;\n     CREDT(NUMDS)=(1000.0*CREDT1)+CREDT2;\n     /* IF BINUSEDT_SIGN='1111'B THEN USEDT(NUMDS)=DS1USEDT;  */\n     IF USERDT1 = 0 THEN\n                    USEDT(NUMDS)=(1000.0*USEDT1)+USEDT2;\n                    ELSE\n                    USEDT(NUMDS)=0;\n     KEY(NUMDS)=DS1PTRDS;\n     BLKL(NUMDS)=DS1BLKL;\n     LRECL(NUMDS)=DS1LRECL;\n     USED(NUMDS)=DS1LSTAR.TT+(DS1LSTAR.R>0);\n     NOEPV(NUMDS)=DS1NOEPV;\n     IF DS1DSORG(1) THEN DSORG(NUMDS)='IS';\n         ELSE IF DS1DSORG(2) THEN DSORG(NUMDS)='PS';\n         ELSE IF DS1DSORG(3) THEN DSORG(NUMDS)='DA';\n         ELSE IF DS1DSORG(7) THEN DSORG(NUMDS)='PO';\n         ELSE IF DS1DSORG(13) THEN DSORG(NUMDS)='VS';\n         ELSE DSORG(NUMDS)='??';\n     IF DS1DSORG(8) THEN SUBSTR(DSORG(NUMDS),3,1)='U';\n     IF DS1RECFM(1) & DS1RECFM(2) THEN RECFM(NUMDS)='U';\n         ELSE IF DS1RECFM(1) THEN RECFM(NUMDS)='F';\n         ELSE IF DS1RECFM(2) THEN RECFM(NUMDS)='V';\n         ELSE RECFM(NUMDS)='?';\n     IF DS1RECFM(3) THEN RECFM(NUMDS)=RECFM(NUMDS)||'T';\n     IF DS1RECFM(4) THEN RECFM(NUMDS)=RECFM(NUMDS)||'B';\n     IF DS1RECFM(5) THEN RECFM(NUMDS)=RECFM(NUMDS)||'S';\n     IF DS1RECFM(6) THEN RECFM(NUMDS)=RECFM(NUMDS)||'A';\n         ELSE IF DS1RECFM(7) THEN RECFM(NUMDS)=RECFM(NUMDS)||'M';\n     DO I=1 TO 3;\n         IF DS1EXT(I).EXTENT_TYPE = '00000000'B THEN GOTO GET_F3;\n      /* IF DS1EXT(I).EXTENT_TYPE = '00000000'B THEN GOTO GET_DSCB; */\n         TRACKS(NUMDS)=TRACKS(NUMDS)+TRK_PER_CYL*(DS1EXT(I).UCC\n              -DS1EXT(I).LCC)+(DS1EXT(I).UHH-DS1EXT(I).LHH)+1;\n         IF VOLSER = 'MIGRAT' THEN TRACKS(NUMDS) =\n                                   TRACKS(NUMDS) - 1 ;\n         END;\n GET_F3:\n     IF UNSPEC(DS1PTRDS) = (5)'00000000'B THEN GOTO TEST_TYPE;\n   /*IF  ENTRY_TYPE \u00ac= 0 THEN GOTO GET_DSCB; */\n   /*    IF UNSPEC(DS1PTRDS) = (5)'00000000'B THEN GOTO STOP;  */\n\n GET_NEXT_F3:\n         ENTRY_TYPE = 3 ;   /* READ FORMAT 3 */\n     IF  VOLSER = 'MIGRAT' THEN GOTO MCD3 ;\n\n          CALL VTCREAD(ENTRY_TYPE,DDNAME,PDSCB,ERROR_IND,USERID);\n     IF ERROR_IND=4 THEN GOTO TEST_TYPE;\n  /* IF ERROR_IND=4 THEN GOTO STOP;  */\n     IF ERROR_IND=8 THEN DO;\n         PUT STRING(LINE) EDIT('0READ RETURN CODE=8 - DDNAME='||DDNAME\n         ||' CCHHR=',UNSPEC(CCHHR),' - CONTINUING WITH NEXT TRACK')\n         (A,B,A);\n /*      IF SW_ARRAY(1) THEN DO ;\n  *            SUBSTR(LINE,1,1) = ' ' ;\n  *            PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);\n  *                          END ;\n  *      ELSE CALL TSOPUT(LINE);\n  */\n         CALL TSOPUT(LINE);\n         LINE=' ';\n /*      IF SW_ARRAY(1) THEN PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);\n  *      ELSE CALL TSOPUT(LINE);\n  */\n         CALL TSOPUT(LINE);\n         GOTO TEST_TYPE;\n     /*  GOTO STOP; */\n     /*  GOTO GET_DSCB;   */\n      END;\n\n MCD3 :\n     IF FORMAT# \u00ac= '3' THEN GOTO TEST_TYPE;\n  /* IF FORMAT# \u00ac= '3' THEN GOTO STOP ; */\n\n F3:\n     NUMF3=NUMF3+1;\n     F3KEY(NUMF3)=KEY(NUMDS);\n /*  F3KEY(NUMF3)=CCHHR; */\n     DO I=1 TO 4;\n         IF DS3EXTNT(I).EXTENT_TYPE = '00000000'B THEN GOTO TEST_TYPE;\n      /* IF DS3EXTNT(I).EXTENT_TYPE = '00000000'B THEN GOTO GET_DSCB; */\n         F3TRACKS(NUMF3)=F3TRACKS(NUMF3)\n             +TRK_PER_CYL*(DS3EXTNT(I).UCC-DS3EXTNT(I).LCC)\n                +(DS3EXTNT(I).UHH-DS3EXTNT(I).LHH)+1;\n      END;\n     DO I=1 TO 9;\n         IF DS3ADEXT(I).EXTENT_TYPE = '00000000'B THEN GOTO TEST_TYPE;\n      /* IF DS3ADEXT(I).EXTENT_TYPE = '00000000'B THEN GOTO GET_DSCB; */\n         F3TRACKS(NUMF3)=F3TRACKS(NUMF3)\n             +TRK_PER_CYL*(DS3ADEXT(I).UCC-DS3ADEXT(I).LCC)\n                +(DS3ADEXT(I).UHH-DS3ADEXT(I).LHH)+1;\n      END;\n     IF UNSPEC(DS3PTRDS) = (5)'00000000'B THEN GOTO TEST_TYPE;\n  /* DS1PTRDS = DS3PTRDS ;  */\n     GOTO GET_NEXT_F3;\n\n STOP:\n       ENTRY_TYPE=2;\n     IF  VOLSER = 'MIGRAT' THEN GOTO MCD4 ;\n\n     CALL VTCREAD(ENTRY_TYPE,DDNAME,PDSCB,ERROR_IND,'CL'); /* CLOSE */\n\n MCD4 :\n     IF NUMDS=0 THEN DO;\n       DDNAME = (16)' ' ;         /* SET EMPTY DDNAME               */\n       LINE='0    '||DDNAME||VOLSER ;\n       LINE=LINE||'    DOES NOT CONTAIN DATA SET    ' ;\n       LINE=LINE||USERID;\n /*    LINE='0'||DDNAME||'  DOES NOT CONTAIN DATA SET    '||USERID; */\n /*    IF SW_ARRAY(1) THEN DO ;\n  *            SUBSTR(LINE,1,1) = ' ' ;\n  *            PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);\n  *    END ;                      /* END OF SW_ARRAY(1) CODE...     */\n /*    ELSE CALL TSOPUT(LINE);\n  */\n       CALL TSOPUT(LINE);\n       GOTO END_S;\n     END;                         /* END OF NUMDS=0                 */\n         TOTDS=TOTDS+NUMDS;\n     DO I=1 TO NUMDS;             /* TOTAL F3 SPACE IF ANY...       */\n         DO J=1 TO NUMF3;\n             IF F3KEY(J)=KEY(I) THEN DO;\n                 TRACKS(I)=TRACKS(I)+F3TRACKS(J);\n          /*     GOTO E_M;    */\n             END;                 /* END OF F3KEY(J)=KEY(I)         */\n         END;                     /* END OF J=1 TO NUMF3            */\n E_M :\n     END;                         /* END OF I=1 TO NUMDS            */\n /*                                                                 */\n /*      TEST  TO SEE IF DOING A  HIGH LEVEL INDEX                  */\n /*                                                                 */\n     IF \u00ac SW_ARRAY(6) THEN GOTO NOTHLI;\n     LINE=' ';\n /*\n  *  PUT STRING(LINE) EDIT(' VOLSER DSO RCFM  BLK  REC TRKS',\n  *    ' USED EX DATA SET') (A,A);\n  *  IF SW_ARRAY(1) THEN PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);\n  *  ELSE CALL TSOPUT(LINE);\n  *\n  */\n     DO I=1 TO NUMDS;\n        IF \u00acSW_ARRAY(5) THEN DO;\n         IF DSORG(I) \u00ac= 'VS' THEN DO ; /* NOT_VSAM ;                */\n NOT_VSAM:\n            PUT STRING(LINE)\n              EDIT('0',CREDT(I),USEDT(I),DDNAME,DSORG(I),RECFM(I),\n                BLKL(I),LRECL(I),TRACKS(I),USED(I),NOEPV(I),DSNAME(I))\n              (A,P'99999',X(1),P'99999',X(1),A(6),X(1),A(4),\n /*           (A,F(5),X(1),P'ZZZZZ',X(1),A(6),X(1),A(4),            */\n                 A(4),F(5),F(5),F(5),F(5),\n                 F(3),X(1),A);\n            GOTO  PRINT_1;\n         END ;\n\n VSAM:\n         IF BLKL(I) < 0 THEN GOTO CLUSTER_NAME;\n         PUT STRING(LINE)\n           EDIT('0',CREDT(I),USEDT(I),DDNAME,DSORG(I),\n             BLKL(I),TRACKS(I),USED(I),NOEPV(I),DSNAME(I))\n           (A,P'99999',X(1),P'99999',X(1),A(6),X(1),A(4),\n /*        (A,F(5),X(1),P'ZZZZZ',X(1),A(6),X(1),A(4),               */\n             X(4),F(5),X(5),F(5),F(5),\n             F(3),X(1),A);\n         GOTO  PRINT_1;\n\n CLUSTER_NAME:\n         PUT STRING(LINE) EDIT('0',DDNAME,\n             'CLUSTER NAME',DSNAME(I))\n             (A,X(12),A(6),X(3),A(12),X(18),A);\n\n PRINT_1:\n /*          IF SW_ARRAY(1) THEN  DO ;\n  *            SUBSTR(LINE,1,1) = ' ' ;\n  *            PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);\n  *                               END ;\n  *          ELSE CALL TSOPUT(LINE);\n  */\n             CALL TSOPUT(LINE);\n        END;                      /* END OF \u00acSW_ARRAY(5)            */\n\n       TOTAL_EXT=TOTAL_EXT+NOEPV(I);\n       TRACK_TOTAL=TRACK_TOTAL+TRACKS(I);\n       USED_TOTAL=USED_TOTAL+USED(I);\n     END;                         /* END OF I=1 TO NUMDS            */\n\n     GO  TO TOTALS;\n /*                                                                 */\n /*      END OF TEST TO SEE IF DOING A  HIGH LEVEL INDEX            */\n /*                                                                 */\n NOTHLI  :\n   IF \u00acSW_ARRAY(5) THEN DO;\n     LINE=' ';\n /*  PUT STRING(LINE) EDIT('0DATA SETS ON VOLUME '||DDNAME) (A);    */\n        PUT STRING(LINE) EDIT('0TSO SPACE ALLOCATION',\n            ' AND USAGE LISTING FOR ',\n            USERID) (A,A,A);\n /*  IF SW_ARRAY(1) THEN DO;\n  *            SUBSTR(LINE,1,1) = ' ' ;\n  *            PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);\n  *  END ;\n  *  ELSE CALL TSOPUT(LINE);\n  */\n     CALL      TSOPUT(LINE);\n     LINE=' ';\n     PUT STRING(LINE)\n         EDIT(' CREDT USEDT VOLSER DSO RCFM  BLK  REC TRKS',\n       ' USED EX DATA SET') (A,A);\n /*  IF SW_ARRAY(1) THEN PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);\n  *  ELSE CALL TSOPUT(LINE);\n  */\n     CALL      TSOPUT(LINE);\n   END;                           /* END OF \u00acSW_ARRAY(5)            */\n\n     DO I=1 TO NUMDS;\n        IF \u00acSW_ARRAY(5) THEN DO;\n         PUT STRING(LINE)\n             EDIT('0',CREDT(I),USEDT(I),DDNAME,DSORG(I),RECFM(I),\n             BLKL(I),LRECL(I),TRACKS(I),USED(I),NOEPV(I),DSNAME(I))\n             (A,P'99999',X(1),P'99999',X(1),A(6),X(1),A(4),A(4),\n /*          (A,F(5),X(1),P'ZZZZZ',X(1),A(6),X(1),A(4),A(4),        */\n             F(5),F(5),F(5),F(5),F(3),X(1),A);\n /*          IF SW_ARRAY(1) THEN  DO ;\n  *            SUBSTR(LINE,1,1) = ' ' ;\n  *            PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);\n  *          END ;\n  *          ELSE CALL TSOPUT(LINE);\n  */\n             CALL TSOPUT(LINE);\n        END;                      /* END OF \u00acSW_ARRAY(5)            */\n       TOTAL_EXT=TOTAL_EXT+NOEPV(I);\n       TRACK_TOTAL=TRACK_TOTAL+TRACKS(I);\n       USED_TOTAL=USED_TOTAL+USED(I);\n     END;                         /* END OF I=1 TO NUMDS            */\n\n TOTALS:\n        IF \u00acSW_ARRAY(6) THEN GOTO TOTALS2 ;               /*        */\n        IF \u00acSW_ARRAY(8) THEN GOTO END_S ;\n\n TOTALS2 :\n        IF SW_ARRAY(5)|SW_ARRAY(2)|SW_ARRAY(8) THEN DO;\n        PUT STRING(LINE) EDIT('0TOTALS: TRKS=',TRACK_TOTAL,' USED=',\n            USED_TOTAL,' DATA SETS=',TOTDS,' EXTENTS=',TOTAL_EXT)\n            (A,F(6),A,F(6),A,F(6),A,F(6));\n /*      IF SW_ARRAY(1) THEN DO;\n  *            SUBSTR(LINE,1,1) = ' ' ;\n  *            PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);\n  *                          END ;\n  *      ELSE CALL TSOPUT(LINE);\n  */\n         CALL TSOPUT(LINE);\n         IF SW_ARRAY(3) THEN DO;\n             DEC_USED=USED_TOTAL;\n             DEC_TRKS=TRACK_TOTAL;\n             DEC_TOT=TOTDS;\n             DEC_EXT=TOTAL_EXT;\n             IF TRACK_TOTAL\u00ac=0 THEN\n                 DEC_PERC=DIVIDE(DEC_USED,DEC_TRKS,5,2);\n             ELSE DEC_PERC=1;\n          DEC_PERC = DEC_PERC * 100.00 ;\n             IF TOTDS \u00ac= 0 THEN\n                DEC_FRAG=DIVIDE(DEC_EXT,DEC_TOT,4,2);\n             ELSE DEC_FRAG = 0 ;\n             PUT STRING(LINE) EDIT(' PERCENT TRKS USED/ALLOC=',\n                 DEC_PERC,'    EXTENTS/TOTAL # DS=',\n                 DEC_FRAG)\n                 (A,F(5,1),A,F(4,2));\n /*          IF SW_ARRAY(1) THEN PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);\n  *          ELSE CALL TSOPUT(LINE);\n  */\n             CALL TSOPUT(LINE);\n         END;\n       END;\n        IF SW_ARRAY(6) THEN GOTO END_S ;\n        IF SW_ARRAY(1)|SW_ARRAY(5) THEN DO;\n           LINE='0DSPACE COMPLETED SUCCESSFULLY ON VOLUME '||VOLSER;\n           CALL TSOPUT(LINE);\n        END;\n END_S:\n END DSPACE;\n/*\n//*\n//LKED.SYSLMOD DD DSN=&&TEMP,UNIT=SYSDA,DISP=(SHR,PASS),\n//   SPACE=(TRK,(15,5,5))\n//LKED.SYSIN DD *\n    SETCODE AC(0)\n    MODE    AMODE(31) RMODE(24)\n    NAME  DSPACE1(R)\n/*\n//*\n//VTCREAD EXEC HLASMCL,COND=EVEN,\n//           MAC1='SYS1.MODGEN',\n//           PARMC='ESD',PARML='LIST,LET,MAP',CLASS='*'\n//ASM.SYSPRINT DD SYSOUT=*\n//ASM.SYSIN DD *\nVTRD     TITLE 'VTCREAD - VTOC READING SUBROUTINE'\n* STATUS:  VERSION 3, 9 MARCH 1984.\n         SPACE\n* AUTHOR:  R.HALL. DIVERSIFIED DEVELOPMENTS.\n         SPACE\n         SPACE\n* FUNCTION: THIS SUBROUTINE READS THE VOLUME TABLE OF CONTENTS (VTOC)\n*        FROM A DIRECT-ACCESS DEVICE USING OBTAIN SEARCH FOR THE\n*        FORMAT 1 AND OBTAIN SEEK FOR ANY FORMAT 3 DSCB'S AND\n*        PRESENTS IT TO THE CALLER ONE RECORD (DSCB) AT A TIME.\n         SPACE\n* OPERATION: THE ROUTINE HAS 6 CALL MODES:\n*\n*        0 - READ.  RETURNS WITH THE CORE ADDRESS OF A DSCB IN THE 3RD\n*              PARAMETER.  THE CORE CONSISTS OF 148 CONSECUTIVE BYTES,\n*              CONTAINING THE COUNT (8 BYTES), KEY (44 BYTES), AND DATA\n*              (96 BYTES) FOR ONE DSCB.  RETURN CODES (4TH PARAMETER)\n*              ARE:\n*                      0 - NORMAL;\n*                      4 - END OF FILE, NO DATA PRESENTED;\n*\n*        1 - OPEN.  THE SECOND PARAMETER SHOULD POINT TO THE SDV OF\n*              AN 8-BYTE FIELD CONTAINING THE DDNAME TO BE USED IN THE\n*              DCB.  THE CORRESPONDING DD CARD SHOULD SPECIFY A DISP OF\n*              (OLD,KEEP).  ON A NORMAL RETURN, THE DDNAME WILL BE SET\n*              TO THE VOLUME SERIAL NUMBER OF THE DISK WHICH THAT\n*              DD CARD POINTS TO,  AND THE ENTRY TYPE CONTAINS THE\n*              NUMBER OF TRKS/CYL. RETURN CODES (4TH PARAMETER) ARE:\n*                      0 - NORMAL;\n*                      4 - UNABLE TO OPEN (PROBABLY MISSING DD CARD);\n*                      8 - DD CARD DID NOT REFER TO A DIRECT-ACCESS\n*                          DEVICE, OR DEVICE TYPE UNKNOWN.\n*\n*        2 - CLOSE.  NO ARGUMENTS ARE REQUIRED OR RETURNED.  RETURN\n*              CODE (4TH PARAMETER) IS 0.\n*\n*        3 - READ3. RETURNS WITH THE CORE ADDRESS OF A DSCB3 IN THE 3RD\n*              PARAMETER.  THE CORE CONSISTS OF 104 CONSECUTIVE BYTES,\n*              CONTAINING THE CCHHR (8 BYTES) OF THE FORMAT 3 DSCB,\n*              AND THE DATA PORTION (96 BYTES) OF THE FORMAT 3 DSCB.\n*              RETURN CODES (4TH PARAMETER) ARE:\n*                      0 - NORMAL;\n*                      4 - END OF FILE, NO DATA PRESENTED;\n*\n*        4 - READ.  RETURNS WITH THE CORE ADDRESS OF A DSCB IN THE 3RD\n*              PARAMETER.  THE CORE CONSISTS OF 148 CONSECUTIVE BYTES,\n*              CONTAINING THE COUNT (8 BYTES), KEY (44 BYTES), AND DATA\n*              (96 BYTES) FOR ONE DSCB.  RETURN CODES (4TH PARAMETER)\n*              ARE:\n*                      0 - NORMAL;\n*                      4 - END OF FILE, NO DATA PRESENTED;\n*                      8 - PERMANENT I/O ERROR.  THE KEY AND DATA AREAS\n*                          WILL BE SET TO ZEROS; THE COUNT AREA WILL\n*                          CONTAIN THE CORRECT CCHHR.  SINCE READING\n*                          IS DONE A TRACK AT A TIME, ALL THE DSCB'S\n*                          FOR THAT TRACK WILL BE MARKED IN ERROR.\n*                          READING MAY CONTINUE ON TO THE NEXT TRACK.\n*\n*        5 - OPEN.  THE SECOND PARAMETER SHOULD POINT TO THE SDV OF\n*              AN 8-BYTE FIELD CONTAINING THE DDNAME TO BE USED IN THE\n*              DCB.  THE CORRESPONDING DD CARD SHOULD SPECIFY A DISP OF\n*              (OLD,KEEP).  ON A NORMAL RETURN, THE DDNAME WILL BE SET\n*              TO THE VOLUME SERIAL NUMBER OF THE DISK WHICH THAT\n*              DD CARD POINTS TO,  AND THE ENTRY TYPE CONTAINS THE\n*              NUMBER OF TRKS/CYL. RETURN CODES (4TH PARAMETER) ARE:\n*                      0 - NORMAL;\n*                      4 - UNABLE TO OPEN (PROBABLY MISSING DD CARD);\n*                      8 - DD CARD DID NOT REFER TO A DIRECT-ACCESS\n*                          DEVICE, OR DEVICE TYPE UNKNOWN.\n*\n         SPACE\n* ENTRY POINTS:  ENTRY IS ALWAYS TO 'CVTREAD' VIA A PL/1 CALL.\n*        ARGUMENTS ARE:\n*                      1 - A(FULL-WORD BINARY ENTRY TYPE);\n*                      2 - A(DDNAME);\n*                      3 - A(PTR FOR DSCB);\n*                      4 - A(FULL-WORD BINARY RETURN CODE);\n*                      4 - A(DSNAME TO USE AS A KEY).\n         SPACE\n* DATA SETS:  READS VOLUME TABLE OF CONTENTS FROM ANY DIRECT-ACCESS\n*        DEVICE.\n         SPACE\n* EXTERNAL ROUTINES:  USES SUPERVISOR ROUTINE 'OBTAIN'.\n         SPACE\n* EXITS - NORMAL:  RETURNS TO PL/I AFTER PUTTING RETURN\n*        CODE IN FOURTH PARAMETER.  (SEE ABOVE FOR RETURN CODE VALUES.)\n         SPACE\n* EXITS - ERROR:  NONE.\n         SPACE\n* TABLES AND WORK AREAS:  TABLE OF DEVICE TYPES.\n         SPACE\n* ATTRIBUTES:  SERIALLY REUSABLE, NON-RECURSIVE, NON-REENTRANT.\n         EJECT\n* SECTION DEFINITION AND REGISTER ASSIGNMENTS:\n         SPACE\nVTCREAD CSECT\n         SPACE 2\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR9       EQU   9\nR10      EQU   10              RETURN CODE REGISTER\nR11      EQU   11              LOCAL SUBROUTINE EXIT REGISTER\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 3\n* TAGS FOR CHANNEL COMMANDS AND FLAG BITS:\n         SPACE\nREADR0   EQU   X'16'           READ RECORD 0\nREADCKD  EQU   X'1E'           READ COUNT, KEY, AND DATA\n         SPACE\nCC       EQU   X'40'           COMMAND CHAIN FLAG\nSLI      EQU   X'20'           SUPPRESS LENGTH INDICATION FLAG\nSKIP     EQU   X'10'           SKIP DATA TRANSFER FLAG\n         SPACE 3\n* COMMUNICATION VECTOR TABLE (CVT) DEFINITIONS:\n         SPACE\nCVT      EQU   16              LOCATION OF CVT BASE ADDRESS\nCVTPCNVT EQU   28              OFFSET TO CONVERT ROUTINE ADDRESS\n         EJECT\n************\n* PROLOGUE *\n************\n         SPACE\n* ENTER HERE AND PERFORM STANDARD REGISTER SAVE AREA HOUSEKEEPING.\n         SPACE\n         SAVE  (14,11),,VTCREAD        SAVE PL/I REGS IN PL/I DSA.\n         USING VTCREAD,R15\n         ST    R13,VTCRSAVE+4          STORE PL/I DSA ADDRESS.\n         LA    R13,VTCRSAVE\n         DROP  R15\n         SPACE\n         BALR  8,0                     SET LOCAL BASE REGISTER\n         USING *,8\nSTART    LR    R9,R1                    SAVE PARAMETER REGISTER\n         L     R1,0(R9)                ADDR OF ENTRY TYPE\n         SR    R10,R10                 ZERO RETURN CODE REGISTER\n         SPACE\n* SELECT MODE FROM CONTENTS AT ADDRESS IN REGISTER 1.\n         SPACE\n*        LA    R2,3                    MASK FOR LOW 2 BITS\n*        N     R2,0(R1)                GET CALL MODE\n         L     R2,0(R1)                GET CALL MODE\n         SLL   R2,2                    MODE TIMES 4\n         B     *+4(R2)                 BRANCH ON MODE\n         SPACE\n         B     GET                 0   MODE 0, GET A DSCB\n         B     OPEN                4   MODE 1, OPEN A NEW VTOC\n         B     CLOSE               8   MODE 2, CLOSE\n         B     GETF3               C   MODE 3, READ FORMAT 3\n         B     GET4               10   MODE 4, READ USING EXCP\n         B     OPEN5              14   MODE 5, OPEN FOR EXCP READ\n         SPACE 1\n*        B     RETURN0             C   MODE 3 NOT DEFINED, NO OP\n         SPACE 3\n***********\n* RETURNS *\n***********\n         SPACE\nRETURN8  LA    R10,4(R10)              ENTRY FOR RETURN CODE 8\nRETURN4  LA    R10,4(R10)              ENTRY FOR RETURN CODE 4\nRETURN0  L     R15,12(R9)              ENTRY FOR RETURN CODE 0\n         ST    R10,0(R15)\n         L     R15,8(R9)               GET ADDR OF PTR FOR DSCB\n         ST    R1,0(R15)\n         L     R13,4(R13)\n         LM    R14,11,12(R13)          RESTORE PL/I REGISTERS.\n         BR    R14                     RETURN TO PL/I.\n         EJECT\n*********************\n* MODE 0 - GET DSCB *\n*********************\n         SPACE\n         SPACE\nGET      DS    0H\n         SPACE\n***********************************************************************\n*                                                                     *\n*              SET UP THE KEY FOR THE VTOC READ                       *\n*                                                                     *\n***********************************************************************\n*        MVI   KEY,C' '           CLEAR KEY AREA\n*        MVC   KEY+1(43),KEY      \"\"\n         L     R4,16(R9)          R4 -> TO A(DATASET NAME)\n         L     R4,0(0,R4)         R4 -> TO DATASET NAME LTH\n         LA    R4,2(0,R4)         R4 -> TO DATASET NAME\n         MVC   KEY(44),0(R4)      SET UP KEY\n         SPACE\n***********************************************************************\n*                                                                     *\n*              READ THE VTOC BY KEY USING OBTAIN SEARCH               *\n*                                                                     *\n***********************************************************************\n         SPACE\nREADVT   DS    0H\n         OBTAIN F1CAM             GET FORMAT 1 DSCB\n         LTR   R15,R15            WAS OBTAIN OKAY ?\n         BNZ   RETURN4            NO, SAY NOT FOUND\n         LA    R2,FULLDSCB             POINT TO DSCB\n         SPACE\nPASSDSCB DS    0H\n         LR    R1,R2                   PASS ADDRESS TO USER\n*ETOUT   DS    0H\n         B     RETURN0                 RETURN CODE 0\n         EJECT\n******************************\n* MODE 3 - GET FORMAT 3 DSCB *\n******************************\n         SPACE\nGETF3    DS    0H\n         SPACE\n***********************************************************************\n*                                                                     *\n*              SET UP THE KEY FOR THE VTOC READ                       *\n*              USING THE CCHHR IN THE FORMAT 1                        *\n*                                                                     *\n***********************************************************************\n         LA    R4,KEY             R4 -> FORMAT 1 DSCB\n         MVC   BLKA+3(5),135(R4)  MOVE CCHHR TO BLKA FIELD\n         MVC   DSCB3(5),135(R4)   SET UP CCHHR FOR PLI TEST\n         SPACE\n***********************************************************************\n*                                                                     *\n*              READ THE VTOC BY CCHHR USING OBTAIN SEEK               *\n*                                                                     *\n***********************************************************************\n         SPACE\n         SPACE\nREADF3   DS    0H\n         OBTAIN F3CAM             GET FORMAT 3 DSCB\n         LTR   R15,R15            WAS OBTAIN OKAY ?\n         BNZ   RETURN4            NO, SAY NOT FOUND\n         LA    R2,FULLDSCB        POINT TO DSCB3\n*        LA    R2,DSCB3           POINT TO DSCB3\n         B     PASSDSCB           PASS DSCB ADDRESS TO USER\n         SPACE\n         EJECT\n*****************\n* MODE 1 - OPEN *\n*****************\n         SPACE\n* ENTER WITH A DDNAME IN SECOND PARAMETER POSITION.\n         SPACE\nOPEN     DS    0H\n         SPACE\n         BAL   R11,CLOSESUB            CALL CLOSE SUBROUTINE\n         L     1,4(R9)                 GET ADDR OF DDNAME\n         L     1,0(1)\n         MVC   DCBDDNAM(8),0(1)    INSERT DDNAME IN DCB\n         SPACE\n* CHECK DEVICE TYPE TO BE SURE IT IS DIRECT ACCESS.\n         SPACE\n         DEVTYPE  DCBDDNAM,DWORK       GET DEVICE TYPE\n         LTR   R15,R15                 TEST IF IT FOUND DD CARD\n         BNZ   RETURN4                 ERROR, DD CARD MISSING\n         CLI   DWORK+2,X'20'           TEST DEVICE TYPE\n         BNE   RETURN8                 ERROR IF NOT DIRECT ACCESS\n         SPACE\n         CLI   DWORK+3,MAXDVT          TEST FOR MAX DEVICE TYPE\n         BNL   RETURN8                 ERROR IF TOO LARGE\n         L     R2,0(R9)                ADDR OF ENTRY TYPE\n         SR    R1,R1\n         IC    R1,DWORK+3              LOAD DEVICE NUMBER\n         SLL   R1,1               X 2 FOR LTH OF TABLE ENTRIES\n         LA    R4,DVICETAB+1(R1) R4 -> TRKS/CYL BYTE OF TABLE\n*        AGO   .SKIP1\n*\n*              FOLLOWING CODE ADDED JUL 93\n*\n         CLI   0(R4),X'00'        IS TABLE ENTRY USED?   JUL93\n         BH    TABLSET            YES                    JUL93\n         MVC   0(1,R4),DWORK+11   PUT TRKS/CYL IN TABLE  JUL93\n         SPACE 1                                         JUL93\nTABLSET  DS    0H                                        JUL93\n         ST    R4,SAVE4           SAVE TABLE ENTRY ADDRESS JUL93\n*\n*              ABOVE     CODE ADDED JUL 93\n*\n.SKIP1   ANOP\n         MVC   3(1,R2),0(R4)      PUT TRKS/CYL INTO ENTRY TYPE\n         IC    R1,DVICETAB(R1)         LOAD DSCB'S/TRK FROM TABLE\n         LTR   R1,R1                   ZERO IS UNDEFINED DEVICE\n*        BZ    RETURN8                 EXIT IF UNKNOWN      JUL93\n*        AGO   .SKIP2\n*\n*              FOLLOWING CODE ADDED JUL 93\n*\n         BP    SAVNBRD            DEVICE IS DEFINED, BRANCH JUL93\n         LA    R1,100             SAY GET BIG AREA FOR DSCB JUL93\n         MVI   DSCBFLG,X'80'      SAY NO DSCB/TRK           JUL93\n         SPACE 1                                         JUL93\nSAVNBRD  DS    0H                                        JUL93\n*\n*              ABOVE     CODE ADDED JUL 93\n*\n.SKIP2   ANOP\n         ST    R1,NDSCBS               STORE NUMBER OF DSCB'S/TRACK\n         SPACE\n* READ JFCB TO GET VOL SER\n         SPACE\n         RDJFCB  VTOCDCB\n         L     1,4(R9)                 GET DDNAME ADDRESS BACK\n         L     1,0(1)\n         MVC   RNAME,JFCBVOLS     SAVE VOLSER FOR OBTAINS\n         MVC   0(6,1),JFCBVOLS         MOVE IN VOL SER #\n         MVC   6(2,1),=C'  '\n         SPACE\n         B     RETURN0                 INDICATE SUCCESSFUL OPEN\n         EJECT\n******************\n* MODE 2 - CLOSE *\n******************\n         SPACE\nCLOSE    DS    0H\n         BAL   R11,CLOSESUB            CALL CLOSE SUBROUTINE\n         B     RETURN0            INDICATE SUCCESSFUL CLOSE\n         SPACE 2\n* IF THE CHANNEL PROGRAM IS RUNNING, WAIT FOR IT BEFORE TAKING FURTHER\n* ACTION.\n         SPACE\nCLOSESUB DS    0H\n         TM    MODESW,XCPRUN           TEST IF CHANNEL PROGRAM RUNNING\n         BZ    NOEXCP                  BRANCH IF NOT\n         WAIT  ECB=VTOCECB             WAIT UNTIL COMPLETE\n         NI    MODESW,X'FF'-XCPRUN     TURN RUNNING SWITCH OFF\nNOEXCP   DS    0H\n         SPACE\n* CLOSE THE DCB.\n         SPACE\n         TM    DCBOFLGS,OPENBIT        TEST IF DCB OPEN\n         BZ    NOCLOSE                 BRANCH IF NOT\n         CLOSE VTOCDCB\nNOCLOSE  DS    0H\n         SPACE\n* RELEASE CORE OBTAINED FOR DSCB BUFFERS.\n         SPACE\n         TM    MODESW,CBGOT            TEST IF CORE GOTTEN\n         BZ    NOFREE                  BRANCH IF NOT\n         LM    R0,R1,CBSIZE            LOAD SIZE AND LOCATION\n         FREEMAIN  R,LV=(0),A=(1)      FREE CORE\n         NI    MODESW,X'FF'-CBGOT      SET CORE GOTTEN BIT OFF\nNOFREE   DS    0H\n         SPACE\n         NI    MODESW,X'FF'-RDERR      CLEAR ERROR SWITCH\n         BR    R11\n         EJECT\n*********************\n* MODE 5 - GET DSCB VIA EXCP. *\n*********************\n         SPACE\n* IF END-OF-FILE WAS REACHED, RETURN AT ONCE.\n         SPACE\nGET4     DS    0H\n         TM    MODESW,EOFSW            TEST END-OF-FILE BIT\n         BO    RETURN4                 RETURN CODE 4 IF ON\n         SPACE\n* IF CHANNEL PROGRAM HAS BEEN STARTED, GO TO CHECK IT.  OTHERWISE,\n* ASSUME THERE IS AT LEAST ONE FULL BUFFER.\n         SPACE\n         TM    MODESW,XCPRUN           TEST IF EXCP ISSUED\n         BO    XCPTEST                 BRANCH IF SO\n         SPACE\n* SET BUFFER ADDRESS TO NEXT DSCB AND TEST IF LAST ON TRACK.  IF NOT,\n* EXIT WITH ITS ADDRESS IN R1.\n         SPACE\n         L     R2,DSCBADR              LOAD BUFFER POINTER\n         LA    R2,148(R2)              ADVANCE TO NEXT DSCB\nNDXSTORE ST    R2,DSCBADR              STORE UPDATED POINTER\n         C     R2,DSCBLIM              TEST IF LAST DSCB IN BUFFER\n         BNL   LASTDSCB                BRANCH IF SO\n         LR    R1,R2                   PASS ADDRESS TO USER\n*OCT95   CLC   =X'00000000',0(R1) 1ST 4 BYTES OF NAME BINARY 0'S?\n*OCT95   BE    GET4               YES, EMPTY DSCB\n         SPACE 1\nGETOUT   DS    0H\n         MVC   FULLDSCB(148),0(R1) SET UP FULLDSCB IN CASE WE NEED F3\n         TM    MODESW,RDERR            TEST IF ERROR ON THIS TRACK\n         BZ    RETURN0                 RETURN CODE 0 IF NOT\n         B     RETURN8                 RETURN CODE 8 IF ERROR\n         SPACE\n* IF THIS IS THE LAST DSCB, MOVE IT TO THE JFCB BUFFER AND START\n* READING THE NEXT TRACK.\n         SPACE\nLASTDSCB MVC   JFCB(148),0(R2)         MOVE LAST DSCB\n         L     R3,TTRN                 LOAD RELATIVE TRACK NUMBER\n         AL    R3,=X'00010000'         INCREMENT TO NEXT TRACK\n         ST    R3,TTRN\n         BAL   R11,EXCP                START CHANNEL PROGRAM\n         LA    R1,JFCB                 LOAD DSCB ADDRESS FOR CALLER\n         B     GETOUT                  TO RETURN\n         EJECT\n* WAIT FOR CHANNEL PROGRAM COMPLETION AND TEST THE OUTCOME.\n         SPACE\nXCPTEST  WAIT  ECB=VTOCECB\n         SPACE\n         NI    MODESW,X'FF'-XCPRUN     TURN EXCP STARTED BIT OFF\n         CLI   VTOCECB,X'7F'           TEST COMPLETION CODE\n         BNE   PERMERR                 BRANCH IF ERROR\nSETDSCBA L     R2,DSCBSTRT             SET BUFFER POINTER TO 1ST DSCB\n*\n*              CODE ADDED TO CHECK FOR EOF ON DSCB....OCT95\n*              UPDATED TO CHECK 255 TIMES....         JAN96\n*\n         CLC   =X'00000000',8(R2) 1ST 4 BYTES OF BUF DATA X'0'S?\n         BNE   NDXSTORE           NO, IT'S A GOOD DSCB\n*OCT95   TM    MODESW2,EOFSW2     YES, HAVE WE BEEN HERE BEFORE?\n         TM    MODESW2,X'FF'      YES, HAVE WE BEEN HERE 255 TIMES?\n         BO    SETEOFSW           YES, SAY EOF.\n*OCT95   OI    MODESW2,EOFSW2     NO, SAY WE'VE BEEN HERE BEFORE\n         IC    R1,MODESW2         R1 = COUNT\n         LA    R1,1(0,R1)         ADD 1\n         STC   R1,MODESW2         SAVE NEW COUNT\n         B     NDXSTORE\n         SPACE 1\nSETEOFSW DS    0H\n         OI    MODESW,EOFSW       YES, SET END-OF-FILE BIT\n*\n*              CODE ABOVE ADDED TO CHECK FOR EOF ON DSCB....OCT95\n*\n         B     NDXSTORE\n         SPACE\n* PERMANENT ERROR FOR THIS TRACK.  ZERO THE DSCB'S AND FILL IN THE\n* CCHHR PORTIONS OF THE COUNT AREAS.\n         SPACE\nPERMERR  OI    MODESW,RDERR            SIGNAL READ ERROR\n         NI    IOBFLAG1,X'FB'          TURN OFF BIT 5 OF IOB FLAG\n         NI    DCBIFLGS,X'3F'          TURN OFF BITS 0 AND 1\n         L     R2,DSCBSTRT             LOAD ADDRESS OF FIRST DSCB\n         LA    R3,1                    LOAD RECORD NUMBER\n         SPACE\nDSCBELUP XC    0(148,R2),0(R2)         ZERO DSCB BUFFER\n         MVC   0(4,R2),IOBSEEK+3       INSERT CCHH IN COUNT FIELD\n         STC   R3,4(R2)                INSERT R IN COUNT FIELD\n         LA    R2,148(R2)              POINT TO NEXT BUFFER\n         LA    R3,1(R3)                INCREMENT RECORD NUMBER\n         C     R2,DSCBLIM              TEST FOR LAST BUFFER\n         BNH   DSCBELUP\n         B     SETDSCBA                BRANCH TO RESET BUFFER POINTER\n         EJECT\n*****************\n* MODE 4 - OPEN VTOC FOR READ USING EXCP. *\n*****************\n         SPACE\n* ENTER WITH A DDNAME IN SECOND PARAMETER POSITION.  PERFORM CLOSE\n* SUBROUTINE FIRST TO BE SURE EVERYTHING IS INITIALIZED.\n         SPACE\nOPEN5    DS    0H\n         BAL   R11,CLOSESUB            CALL CLOSE SUBROUTINE\n         SPACE\n         L     1,4(R9)                 GET ADDR OF DDNAME\n         L     1,0(1)\n         MVC   DCBDDNAM(8),0(1)    INSERT DDNAME IN DCB\n         SPACE\n* CHECK DEVICE TYPE TO BE SURE IT IS DIRECT ACCESS.\n         SPACE\n         DEVTYPE  DCBDDNAM,DWORK       GET DEVICE TYPE\n         LTR   R15,R15                 TEST IF IT FOUND DD CARD\n         BNZ   RETURN4                 ERROR, DD CARD MISSING\n         CLI   DWORK+2,X'20'           TEST DEVICE TYPE\n         BNE   RETURN8                 ERROR IF NOT DIRECT ACCESS\n         SPACE\n         CLI   DWORK+3,MAXDVT          TEST FOR MAX DEVICE TYPE\n         BNL   RETURN8                 ERROR IF TOO LARGE\n         L     R2,0(R9)                ADDR OF ENTRY TYPE\n         SR    R1,R1\n         IC    R1,DWORK+3              LOAD DEVICE NUMBER\n         SLL   R1,1               X 2 FOR LTH OF TABLE ENTRIES\n         LA    R4,DVICETAB+1(R1) R4 -> TRKS/CYL BYTE OF TABLE\n*        AGO   .SKIP4\n*\n*              FOLLOWING CODE ADDED JUL 93\n*\n         CLI   0(R4),X'00'        IS TABLE ENTRY USED?   JUL93\n         BH    TABLESET           YES                    JUL93\n         MVC   0(1,R4),DWORK+11   PUT TRKS/CYL IN TABLE  JUL93\n         SPACE 1                                         JUL93\nTABLESET DS    0H                                        JUL93\n         ST    R4,SAVE4           SAVE TABLE ENTRY ADDRESS JUL93\n*\n*              ABOVE     CODE ADDED JUL 93\n*\n.SKIP4   ANOP\n         MVC   3(1,R2),0(R4)      PUT TRKS/CYL INTO ENTRY TYPE\n         IC    R1,DVICETAB(R1)         LOAD DSCB'S/TRK FROM TABLE\n         LTR   R1,R1                   ZERO IS UNDEFINED DEVICE\n*        BZ    RETURN8                 EXIT IF UNKNOWN      JUL93\n*        AGO   .SKIP5\n*\n*              FOLLOWING CODE ADDED JUL 93\n*\n         BP    SAVENBRD           DEVICE IS DEFINED, BRANCH JUL93\n         LA    R1,100             SAY GET BIG AREA FOR DSCB JUL93\n         MVI   DSCBFLG,X'80'      SAY NO DSCB/TRK           JUL93\n         SPACE 1                                         JUL93\nSAVENBRD DS    0H                                        JUL93\n*\n*              ABOVE     CODE ADDED JUL 93\n*\n.SKIP5   ANOP\n         ST    R1,NDSCBS               STORE NUMBER OF DSCB'S/TRACK\n         SPACE\n* READ JFCB AND INSERT DATA SET NAME OF 44 X'04'.\n         SPACE\n         RDJFCB  VTOCDCB\n         MVI   JFCBDSNM,X'04'          GENERATE DATA SET NAME\n         MVC   JFCBDSNM+1(43),JFCBDSNM OF THE VTOC.\n         OI    JFCBTSDM,JFCNWRIT       INHIBIT JFCB WRITE BACK\n         L     1,4(R9)                 GET DDNAME ADDRESS BACK\n         L     1,0(1)\n         MVC   RNAME,JFCBVOLS     SAVE VOLSER FOR OBTAINS\n         MVC   0(6,1),JFCBVOLS         MOVE IN VOL SER #\n         MVC   6(2,1),=C'  '\n         SPACE\n* OPEN THE DSCB.\n         SPACE\n         OPEN  (VTOCDCB,(INPUT)),TYPE=J\n         TM    DCBOFLGS,OPENBIT        TEST IF OPEN WORKED\n         BZ    RETURN4                 ERROR IF OPEN FAILED\n         SPACE\n* OBTAIN CORE FOR CHANNEL PROGRAM AND DSCB BUFFERS.\n         SPACE\n         LA    R0,156                  CORE FOR ONE DSCB AND ITS CCW\n         MH    R0,NDSCBS+2             TIMES NUMBER PER TRACK\n         AH    R0,=H'15'               PLUS 1 CCW AND ROUNDING\n         N     R0,=X'FFFFFFF8'         ROUND TO DOUBLE-WORD MULTIPLE\n         ST    R0,CBSIZE               SAVE SIZE OF GOTTEN CORE\n         GETMAIN  R,LV=(0)             GET TRACK BUFFERS\n         ST    R1,CBADDR               SAVE ADDRESS OF GOTTEN CORE\n         OI    MODESW,CBGOT            INDICATE CORE GOTTEN\n         SPACE\n* GENERATE CHANNEL PROGRAM.  IT CONSISTS OF A 'READ R0' ORDER WITH\n* THE SKIP FLAG ON, FOLLOWED BY A 'READ COUNT-KEY-AND-DATA' ORDER FOR\n* EACH DSCB.\n         SPACE\nGENCHAN  DS    0H\n         L     R2,NDSCBS               NUMBER OF DSCB'S\n         SLL   R2,3                    TIMES   8\n         LA    R2,8(R2,R1)             PLUS 8 AND BASE = 1ST BUFFER ADD\n         ST    R2,DSCBSTRT             SAVE ADDRESS OF FIRST BUFFER\n         SPACE\n         ST    R1,IOBSTART             ADDRESS OF CHANNEL PROGRAM\n         MVC   0(8,R1),INITCCW         INSERT FIRST CCW\n         LA    R3,8(R1)                PLACE FOR NEXT CCW\n         LA    R4,1                    BUFFER COUNTER\n         SPACE\nCCWLOOP  MVC   0(8,R3),READCCW         INSERT READ CCW FOR ONE DSCB\n         ST    R2,0(R3)                SET ITS BUFFER ADDRESS\n         MVI   0(R3),READCKD           RESTORE COMMAND CODE\n         C     R4,NDSCBS               TEST BUFFER COUNTER\n         BNL   LASTCCW                 BRANCH IF LAST BUFFER\n         LA    R3,8(R3)                INCREMENT CCW ADDRESS\n         LA    R2,148(R2)              INCREMENT BUFFER ADDRESS\n         LA    R4,1(R4)                INCREMENT BUFFER COUNTER\n         B     CCWLOOP                 DO NEXT BUFFER\n         SPACE\nLASTCCW  NI    4(R3),X'FF'-CC          TURN OFF COMMAND CHAIN BIT\n         ST    R2,DSCBLIM              SAVE ADDRESS OF LAST DSCB BUFFER\n         SPACE\n* SET OTHER THINGS AND START PROGRAM TO FILL BUFFER.\n         SPACE\n         SR    R0,R0\n         ST    R0,TTRN                 SET RELATIVE TRACK NUMBER TO 0\n         NI    MODESW,X'FF'-XCPRUN-RDERR-EOFSW   SET FLAGS OFF\n         BAL   R11,EXCP                START CHANNEL PROGRAM\n*        AGO   .SKIP6\n*\n*              FOLLOWING CODE ADDED JUL 93\n*\n         TM    DSCBFLG,X'80'      DEVICE FOUND?\n         BZ    RETURN0            YES\n         NI    DSCBFLG,X'FF'-X'80'  TURN DEVICE NOT FOUND BIT OFF\n         L     R2,0(R9)           R2 -> TO WHERE TRK GOES\n         L     R4,SAVE4           RELOAD R4\n* WAIT FOR CHANNEL PROGRAM COMPLETION AND TEST THE OUTCOME.\n         SPACE\n         WAIT  ECB=VTOCECB\n         SPACE\n         NI    MODESW,X'FF'-XCPRUN     TURN EXCP STARTED BIT OFF\n         CLI   VTOCECB,X'7F'           TEST COMPLETION CODE\n         BNE   RETURN8                 BRANCH IF ERROR\n*        BNE   PERMERR                 BRANCH IF ERROR\n         L     R2,DSCBSTRT             SET BUFFER POINTER TO 1ST DSCB\n         ST    R2,DSCBADR              STORE UPDATED POINTER\n         L     R3,DSCB-FULLDSCB(R2)    R3 -> TO DSCB\n         CLI   0(R3),X'F4'             IS IT A TYPE 4 DSCB\n         BNE   RETURN8            NO, BAD READ\n         MVC   0(1,R4),30(R3)     SAVE DSCB/TRK IN TABLE\n         MVC   NDSCBS+3(1),30(R3)      SAVE DSCB/TRK\n         B     GENCHAN            GO TRY TO READ IT ONE MORE TIME\n*\n*              ABOVE     CODE ADDED JUL 93\n*\n.SKIP6   ANOP\n         B     RETURN0                 INDICATE SUCCESSFUL OPEN\n         EJECT\n****************\n* EXCP ROUTINE *\n****************\n         SPACE\n* CONVERT RELATIVE TRACK ADDRESS IN 'TTRN' TO ABSOLUTE SEEK ADDRESS IN\n* 'IOBSEEK', USING SUPERVISOR CONVERSION ROUTINE.\n         SPACE\nEXCP     DS    0H\n         STM   R2,R13,EXCPSAVE         SAVE IMPORTANT REGISTERS\n         L     R0,TTRN                 LOAD RELATIVE TRACK NUMBER\n         L     R1,DCBDEBAD             LOAD DEB ADDRESS\n         LA    R2,IOBSEEK              LOAD ADDR TO RECEIVE MBBCCHHR\n         L     R15,CVT                 LOAD CVT ADDRESS\n         L     R15,CVTPCNVT(R15)       LOAD ADDR OF CONVERT ROUTINE\n         BALR  R14,R15                 CONVERT TTRN TO MBBCCHHR\n         DROP  8                       THAT CLOBBERED BASE REG\n         USING *,R14                   R14 SET BY BALR ABOVE\n         LM    R2,R13,EXCPSAVE         RESTORE REGISTERS\n         DROP  R14\n         USING START,8                 BASE REGISTER RECOVERED\n         LTR   R15,R15                 TEST IF EXTENT VIOLATED (RC=4)\n         BNZ   SETEOF                  IF SO, MEANS END-OF-FILE\n         SPACE\n* ZERO ECB AND START CHANNEL PROGRAM.\n         SPACE\n         SR    R0,R0\n         ST    R0,VTOCECB              CLEAR ECB\n         NI    MODESW,X'FF'-RDERR      RESET ERROR SWITCH\n         EXCP  VTOCIOB                 START CHANNEL PROGRAM\n         OI    MODESW,XCPRUN           SET 'RUNNING' FLAG\n         BR    R11\n         SPACE\n* WHEN EXTENT IS VIOLATED, SET END-FILE AND EXIT VIA CLOSE ROUTINE.\n         SPACE\nSETEOF   OI    MODESW,EOFSW            SET END-OF-FILE BIT\n         BR    R11                RETURN TO CALLER\n*                                 I THINK GOING TO CLOSESUB SKIPS\n*                                 THE LAST DSCB......JAN96\n         B     CLOSESUB                EXIT VIA CLOSE SUBROUTINE\n         EJECT\n********************************\n* CONSTANTS, VARIABLES, ETC... *\n********************************\n         SPACE\nINITCCW  CCW   READR0,0,CC+SLI+SKIP,8\nREADCCW  CCW   READCKD,0,CC,148\n         SPACE\nDVICETAB DC    X'00',X'00'     TABLE OF NUMBER OF DSCB'S/TRACK\n*                              AND OF TRKS/CYL\n         DC    AL1(16),X'00'      2311\n         DC    AL1(63),X'00'      2301\n         DC    AL1(17),X'00'      2303\n         DC    AL1(22),X'00'      2302\n         DC    AL1(8),X'00'       2321\n         DC    X'00',X'00'\n         DC    X'00',X'00'\n         DC    AL1(25),X'00'      2314\n         DC    AL1(39),AL1(19)    3330\n         DC    X'00',X'00'\n         DC    AL1(47),AL1(30)    3350\n         DC    X'00',X'00'\n         DC    AL1(39),AL1(19)    3330-1\n         DC    AL1(53),AL1(15)    3380                              RH\n         DC    AL1(50),AL1(15)    3390                              RH\n         DC    AL1(00),AL1(00)    FOR NEW DEVICES                   RH\n         DC    AL1(00),AL1(00)    FOR NEW DEVICES                   RH\nMAXDVT   EQU   (*-DVICETAB)/2\n         SPACE\nDWORK    DS    3D              WORK CELL\nSAVE4    DC    F'0'\nVTCRSAVE DC    20F'0'\nEXCPSAVE EQU   VTCRSAVE+12\nCBSIZE   DS    2F              SIZE AND LOCATION OF GOTTEN CORE\nCBADDR   EQU   CBSIZE+4\nNDSCBS   DS    F               NUMBER OF DSCB'S PER TRACK\nDSCBSTRT DS    F               ADDRESS OF 1ST DSCB BUFFER\nDSCBLIM  DS    F               ADDRESS OF LAST DSCB BUFFER\nDSCBADR  DS    F               ADDRESS OF CURRENT DSCB\nTTRN     DS    F               RELATIVE TRACK NUMBER\n         SPACE\n* MODE SWITCH AND BIT DEFINITIONS:\n         SPACE\nMODESW   DC    X'00'\nCBGOT    EQU   X'80'           CORE GOTTEN FOR BUFFER\nXCPRUN   EQU   X'40'           CHANNEL PROGRAM STARTED BUT NOT CHECKED\nRDERR    EQU   X'20'           PERMANENT I/O ERROR\nEOFSW    EQU   X'10'           END-OF-FILE SENSED\n         SPACE\nMODESW2  DC    X'00'\nEOFSW2   EQU   X'10'           END-OF-FILE SENSED\n         SPACE\nDSCBFLG  DC    F'0'\n*        EQU   X'80'           DSCB NOT FOUND FOR DEVICE\n         SPACE\n* DATA CONTROL BLOCK\n         SPACE\nVTOCDCB  DCB   DDNAME=VOLUME01,MACRF=(E),EXLST=JFCBADDR\n         SPACE\nDCBDDNAM EQU   VTOCDCB+40\nDCBIFLGS EQU   VTOCDCB+44\nDCBDEBAD EQU   VTOCDCB+44\nDCBOFLGS EQU   VTOCDCB+48\nOPENBIT  EQU   X'10'\n         EJECT\n* IOB FOR CHANNEL PROGRAM:\n         SPACE\nVTOCIOB  DS    0D\nIOBFLAG1 DC    X'42000000'     COMMAND CHAIN, NOT RELATED\n         DC    A(VTOCECB)\n         DC    2F'0'\nIOBSTART DC    A(0)            CHANNEL PROGRAM BEGINNING\n         DC    A(VTOCDCB)\n         DC    X'03000000'\n         DC    F'0'\nIOBSEEK  DC    D'0'            INITIAL SEEK ADDRESS\n         SPACE\n* EVENT CONTROL BLOCK FOR CHANNEL PROGRAM:\n         SPACE\nVTOCECB  DC    F'0'            EVENT CONTROL BLOCK\n         SPACE 3\n* BUFFER FOR JFCB AND DCB EXIT LIST:\n         SPACE\nJFCBADDR DS    0F\n         DC    X'87'\n         DC    AL3(JFCB)\n         SPACE\nJFCB     DS    0D\n         DS    CL176\n         SPACE\nJFCBDSNM EQU   JFCB            DATA SET NAME\nJFCBTSDM EQU   JFCB+52         SWITCHES\nJFCNWRIT EQU   X'08'           DO NOT WRITE BACK JFCB\nJFCBVOLS EQU   JFCB+118        VOLUME SERIAL NUMBER\n         SPACE\n*\n* DSCB I/O AREA AND CONTROL BLOCKS\n*\nRNAME    DC    CL6' '\nFULLDSCB DS    0C\nBLKA     DC    XL8'00'\nDSCB3    EQU   *                  DSCB3\nKEY      DC    CL44' '\nDSCB     DC    XL140'00'\n         SPACE\nF1CAM    CAMLST SEARCH,KEY,RNAME,DSCB\nF3CAM    CAMLST SEEK,BLKA+3,RNAME,DSCB3\n         SPACE\n         LTORG\n         END\n/*\n//LKED.SYSLMOD DD DSN=&&TEMP,UNIT=SYSDA,DISP=(SHR,PASS),\n//   SPACE=(TRK,(15,5,5))\n//LKED.SYSIN DD *\n    SETCODE AC(0)\n    MODE    AMODE(31) RMODE(24)\n    NAME  VTCREAD(R)\n/*\n//TSOPUT EXEC HLASMC,PARMC='ESD',CLASS='*',COND=EVEN\n//*TEP4 EXEC ASMGCL,PARMC='ESD',PARML='LIST,LET,MAP'\n//ASM.SYSPRINT DD SYSOUT=*\n//ASM.SYSIN DD *\n         TITLE     'PL/1 TSO PUT ROUTINE'\n*\n*              NOTE.............. ..\n*              TSOPUT HAS BEEN MOVED TO DSPART1.\n*              THIS COPY IS HERE ONLY AS AN EXAMPLE\n*              OF TSOPUT AS A RE- ENTRANT VERSION.\n*\n*\n*  REENTRANT CODE FOR PL/1 TPUT\n*\n*TSOPUT   CSECT\n*         STM       R14,R12,12(R13)\n*         LR        BASE,R15\n*         USING     TSOPUT,BASE\n*         LR        PARMPTR,R1\n*         L         R0,ALWORK\n*GETWORK  GETMAIN   R,LV=(0)\n*         XC        0(LWORK,R1),0(R1)\n*         ST        R13,4(R1)\n*         ST        R1,8(R13)\n*         LR        WORKPTR,R1\n*         USING     WORK,WORKPTR\n*         L         PARMPTR,0(PARMPTR)\n*         USING     SDV,PARMPTR\n*         L         R1,SDVADDR\n*         LH    R0,0(,R1)\n*         LA    R1,2(,R1)\n*PUTIT    TPUT      (1),(0),R\n*         LR        R1,WORKPTR\n*         L         R13,4(WORKPTR)\n*         L         R0,ALWORK\n*FREEWORK FREEMAIN  R,LV=(0),A=(1)\n*         LM        R14,R12,12(R13)\n*         BR        R14\n*         DS        0D\n*ALWORK   DC        AL1(0),AL3(LWORK)\n*LITERALS LTORG\n*SDV      DSECT\n*SDVADDR  DS        A\n*SDVMAXL  DS        H\n*SDVFLAG  DS        H\n**\n**    REGISTER EQUATES\n*R0       EQU   0\n*R1       EQU   1\n*R2       EQU   2\n*R3       EQU   3\n*R4       EQU   4\n*R5       EQU   5\n*R6       EQU   6\n*R7       EQU   7\n*R8       EQU   8\n*R9       EQU   9\n*R10      EQU   10\n*R11      EQU   11\n*R12      EQU   12\n*R13      EQU   13\n*R14      EQU   14\n*R15      EQU   15\n*BASE     EQU   11\n*PARMPTR  EQU   10\n*WORKPTR  EQU   9\n*WORK     DSECT\n*SAVEAREA DS        9D\n*WORKEND  DS        0D\n*LWORK    EQU       WORKEND-WORK\n         END\n/*\n//*\n//LINK  EXEC LKED,PARML='LIST,LET,MAP',CLASS='*',COND=EVEN\n//LKED.SYSLIB   DD  DISP=SHR,DSN=SYSPP.PLI.PROD.SIBMBASE\n//              DD  DISP=SHR,DSN=SYSPP.PLI.PROD.PLILINK\n//              DD  DISP=SHR,DSN=SYSPP.LE.PROD.SCEELKED\n//LKED.SYSLMOD DD DSN=HALL.LINKLIB,DISP=SHR                FOR TEST\n//*KED.SYSLMOD DD DSN=SYS1.DYNAMIC.PROD.LINKLIB,DISP=SHR   FOR PROD\n//LKED.LINKMOD DD DSN=&&TEMP,DISP=(OLD,DELETE)\n//LKED.SYSIN DD *\n    INCLUDE LINKMOD(DSSUPER)\n    INCLUDE LINKMOD(HELPPAN)\n    INCLUDE LINKMOD(DSPACE1,VTCREAD)\n    ENTRY   SPACE\n    SETCODE AC(0)\n    MODE    AMODE(31) RMODE(24)\n    NAME    DS(R)\n/*\n//* ALIAS DS\n//* NAME DSSPART3(R)\n//* NAME  DSSUPER(R)\n//\n//*     END FOR NOW....\n//*\n//*\n//*\n//HELP   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN DD DUMMY\n//SYSUT2 DD SYSOUT=A,DCB=(RECFM=FB,LRECL=80,BLKSIZE=80)\n//*SYSUT2 DD DSN=SYS1.HELP(DS),DISP=SHR\n//SYSUT1 DD *\n)F FUNCTION:\n    THE DS COMMAND CAN BE USED TO DISPLAY OR PRINT\n    DATA SET CHARACTERISTICS, CURRENT SPACE ALLOCATION\n    AND USAGE, TOTALS, AND PERCENT CALCULATION FOR A\n    SPECIFIED DATA SET OR GROUP OF DATA SETS AT THE\n    TERMINAL, TO A SEQUENTIAL DATA SET, OR TO SYSPRINT\n    IF THE DS COMMAND IS RUN IN BATCH.\n\n)X SYNTAX:\n    DS 'SEARCH-KEY' VOL('VOL-SER-LIST'/'VOL-SER')\n       UNIT('UNIT-NAME') MAX('NNNN') PRINT('DSNAME')\n       TOTAL(YES/NO) NOLIST ALLOC('DSN')\n\n   REQUIRED - NONE.\n   DEFAULTS - 'SEARCH-KEY' TO USER ID.\n              'VOL-SER' TO USERS HIGH LEVEL INDEX VOLUME.\n              'UNIT-NAME' TO 'USER'\n              'NNNN' TO 100\n              'DSNAME' TO TERMINAL (NO FILE)\n              TOTAL(YES) IF SEARCH-KEY IS A DATA SET.\n              TOTAL(NO) IF SEARCH-KEY IS A HIGH LEVEL INDEX.\n              LIST.\n\n   ALIAS - NONE\n\n   TO RUN THE DS COMMAND IN BATCH, THE FOLLOWING JCL\n   CAN BE USED :\n      //         JOB (PIN,CHGNBR),...ETC.\n      /*ROUTE  PRINT  R...      IF DESIRED\n      //S0      EXEC PGM=DS,PARM='SEARCH-KEY'\n      //SYSPRINT DD  SYSOUT=*\n      //\n      OR\n      //         JOB (PIN,CHGNBR),...ETC.\n      /*ROUTE  PRINT  R...      IF DESIRED\n      //S0      EXEC PGM=DS\n      //SYSPRINT DD  SYSOUT=*\n      //SYSIN    DD  *\n      HLI\n      DSN\n      HLI.INDEX.INDEX\n      //\n   WHEN RUN AS A BATCH JOB, THE SEARCH-KEY IS THE ONLY\n   OPERAND THAT WILL BE RECOGNIZED.\n\n)O OPERANDS:\n    'SEARCH-KEY' IS A POSITIONAL OPERAND.\n  IF ANY KEYWORD OPERANDS ARE SPECIFIED 'SEARCH KEY'\n  MUST ALSO BE SPECIFIED.\n   'SEARCH-KEY' IS THE KEY ON WHICH DATA SET NAMES\n  ARE COMPARED. IF IT IS ENCLOSED IN QUOTES IT WILL BE\n  USED AS IS, OTHERWISE THE USERS ID WILL BE\n  CONCATENATED TO THE LEFT.\n        E.G. - STRING WILL BE 'USERID.STRING'.\n  NOTE - SEARCH-KEY CANNOT END WITH A PERIOD (.) .\n       - IF SEARCH-KEY IS A HIGH LEVEL INDEX, ALL DATASETS\n         CATALOGED UNDER THE HLI WILL BE LISTED.\n       - IF SEARCH-KEY IS SPECIFIED AS 'ALL.DSNAMES', ALL\n         DATASETS ON THE SPECIFIED VOLUME WILL BE LISTED.\n       - IF SEARCH-KEY IS SPECIFIED AS 'ALL.HLI', ALL\n         DATASETS BEGINNING WITH 'HLI' ON THE SPECIFIED\n         VOLUME WILL BE LISTED.\n  DEFAULT - USER'S ID.\n\n))VOL('VOL-SER-LIST'/'VOL-SER')\n    'VOL-SER-LIST'/'VOL-SER' - THE VOLUME SERIAL\n   OF THE VOLUME OR VOLUMES YOU WISH TO BE SEARCHED\n   FOR DATA SETS.\n   IF VOL(ALLVOL) IS SPECIFIED, ALL VOLUMES CURRENTLY\n   ON-LINE AND AVAILABLE FOR YOUR USE WILL BE SEARCHED.\n\n   DEFAULT - USERS LIBRARY VOLUME.\n\n))UNIT('UNIT-NAME')\n    'UNIT-NAME' OF THE DEVICE TO BE SEARCHED.\n\n  DEFAULT - 'USER'\n\n))MAX('NNNN')\n    'NNNN' IS THE NUMBER OF DATA SETS THAT FIT THE\n   SEARCH KEY THAT YOU WISH TO HAVE LISTED. IF THERE ARE\n   MORE DATA SETS THAN YOU SPECIFY A MESSAGE WILL\n   INFORM YOU OF THIS.\n\n   DEFAULT - 100.\n\n))PRINT('DSNAME')\n    'DSNAME' IS THE DATA SET NAME OF A FILE THAT\n     YOU WANT THE DS INFORMATION PRINTED IN.\n     THE DCB INFORMATION OF THIS FILE WILL BE CHANGED\n     TO DCB=(RECFM=FBA,LRECL=133,BLKSIZE=19019) AND\n     ANY DATA IN THIS FILE WILL BE WIPED OUT BY THE DS\n     INFORMATION. THIS DATA SET SHOULD NOT BE A MEMBER\n     OF A PARTITIONED DATA SET. IT SHOULD ONLY BE A\n     SEQUENTIAL DATA SET.\n\n     NOTE : IF THE DATA SET NAME IS NOT ENCLOSED IN\n            QUOTES, YOUR USERID WILL AUTOMATICALLY\n            BE APPENDED TO THE FRONT OF THE DSN YOU\n            HAVE SPECIFIED.\n\n     DEFAULT - NO FILE , IE. PRINT AT TERMINAL.\n\n     EXAMPLE:\n     DS 'HLI' PRINT('HLI.DSLIST')\n     IN THE ABOVE EXAMPLE, THE DS OUTPUT WOULD BE\n     PRINTED ON THE DATASET 'HLI.DSLIST'.\n\n))TOTAL(YES/NO)\n    TOTAL CAUSES THE NUMBER OF DATA SETS, TOTAL NUMBER\n   OF TRACKS, USED TRACKS, AND EXTENTS TO BE PRINTED.\n   IF YES IS SPECIFIED IT WILL ALSO CALCULATE THE\n   PERCENTAGE OF TRACKS ALLOCATED TO TRACKS USED AND\n   THE RATIO OF DATA SETS TO EXTENTS.\n\n   DEFAULT - YES IF SEARCH-KEY IS A DATASET NAME,\n           - NO IF SEARCH-KEY IS A HIGH LEVEL INDEX\n\n))NOLIST\n   NOLIST CAUSES ONLY THE TOTAL LINE TO BE PRINTED.\n\n))ALLOC('DSN')\n    IF YOU DO NOT KNOW THE VOLSER OF THE VOLUME\n    YOU WANT TO SEARCH, 'ALLOC' ALLOWS YOU TO\n    POINT TO A VOLUME BY SPECIFYING THE NAME OF\n    A CATALOGUED DATA SET.\n    'DSN' IS THE FULLY QUALIFIED DATA SET NAME.\n\n   DEFAULT - NONE\n/*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ENQ": {"ttr": 13831, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x13\\x00\\x00\\xe6\\x00\\xe6\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T13:00:00", "lines": 230, "newlines": 230, "modlines": 0, "user": "RH87944"}, "text": "//ENQ      JOB\n//* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n//* $  CBT.SOURCE(ENQ)\n//* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n//S1        EXEC  ASMFCLG,CLASS='*'\n//ASM.SYSIN DD  *\n*\n*              THIS VERSION IS FOR PRE-SP3 SYSTEMS\n*\nENQ      CSECT\n         TITLE 'COMMAND TO LIST ENQUEUED DATASET NAMES'\n         USING *,R15\n         B     AROUND             BRANCH AROUND DUMP TITLE\n         DC    C'ENQ     '        PROGRAM NAME\n         DC    C'&SYSDATE'        DATE WRITTEN\n         DC    C'&SYSTIME'        TIME WRITTEN\n         SPACE 1\nAROUND   DS    0H\n         DROP  R15\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         USING ENQ,R12\n         ST    R13,SAVE+4\n         LR    R11,R13\n         LA    R13,SAVE\n         ST    R13,8(,R11)\n         L     R1,0(,R1)        GET ADDR OF PARM LIST\n         LA    R10,2(,R1)       SAVE PARM STRING ADDR FOR LATER\n         LH    R11,0(,R1)       GET LENGTH OF PARM STRING\n         SPACE 1                                                    RH\nDECODE   DS    0H                                                   RH\n         LTR   R11,R11          CHECK FOR NO PARMS\n         BZ    HELP             GIVE HELP MSG\n         LA    R7,7               R7 = MAX QNAME LTH                RH\n         CLC   0(2,R10),=C'Q='    IS IT Q= PARM?                    RH\n         BNE   NOQ                NO, USE DEFAULT OF SYSDSN         RH\n         MVC   QNAME,OLDNAME      MAKE SURE QNAME IS BLANK          RH\n         LA    R10,2(0,R10)       R10 -> TO QNAME                   RH\n         LR    R7,R10             R7 -> TO QNAME                    RH\n         BCTR  R11,0              R11 = LTH OF REST OF PARM         RH\n         BCTR  R11,0              ''                                RH\n         SPACE 1                                                    RH\nQLOOP    DS    0H                                                   RH\n         CLI   0(R7),C','         FOUND COMMA ?                     RH\n         BE    COMMAFND           YES, SET UP QNAME                 RH\n         LA    R7,1(0,R7)         R7 -> TO NEXT BYTE                RH\n         BCT   R11,QLOOP          LOOK AT IT                        RH\n         TPUT  MISSPARM,LMISS     SAY MISSING PARM                  RH\n         B     GETANS             GO GET NEXT REPLY                 RH\n         SPACE 1                                                    RH\nCOMMAFND DS    0H                                                   RH\n         BCTR  R11,0              R11 = LTH OF REST 0F PARM         RH\n         SR    R7,R10             R7 = LTH OF QNAME                 RH\n         BCTR  R7,0               R7 = HEX LTH                      RH\n         EX    R7,MVCQ            MOVE QNAME                        RH\n         LA    R10,2(R7,R10)      R10 -> TO NEXT PARM               RH\n         SPACE 1                                                    RH\nNOQ      DS    0H                                                   RH\n         CLC   0(2,R10),=C'*J'  LIST DSNS BY JOBNAME?\n         BNE   NOJOBN           NO, DON'T GET JOBNAME LENGTH\n         LR    R9,R11           GET LENGTH OF PARM STRING\n         S     R9,=F'3'         SUBTRACT 1 FOR EX, 2 FOR '*J'\nNOJOBN   BCTR  R11,R0           DECR FOR EXECUTE LATER\n         L     R2,16            GET CVT PTR\n         L     R1,556(,R2)      GET ASVT ADDR\n         LA    R6,524(,R1)      ADD OFFSET TO VECTOR SEGMENT\n         L     R2,640(,R2)      ADDR OF FIRST MAJOR QCB\n         SPACE 2\nQTEST    DS    0H                                                   RH\n         CLC   QNAME,=CL8'ALL'    DO ALL QNAMES?                    RH\n         BE    FOUNDIT            YES, GO TO IT !                   RH\n         SPACE 1                                                    RH\nMAJORLP  DS    0H                                                   RH\n         EX    R7,CLCQ          LOOK FOR THIS MAJOR QCB             RH\n         BE    FOUNDIT          GO PROCESS THE SYSDSN QCB\n         ICM   R2,7,1(R2)       GET PTR TO NEXT MAJOR QCB\n         BNZ   MAJORLP          CONTINUE SCANNING\n         SPACE 1                                                    RH\nQNFOUND  NOP   RETURN             B IF QNAME FOUND                  RH\n         MVC   QMSGNAM,QNAME      MOVE QNAME TO MSG                 RH\n         TPUT  QMSG,LQMSG         PUT MSG TO TERMINAL               RH\n         SPACE 2\nRETURN   L     R13,SAVE+4       COMMON RETURN POINT\n         L     R14,12(,R13)\n         LM    R0,R12,20(R14)\n         BR    R14\n         SPACE 2\nMVCQ     MVC   QNAME(0),0(R10)    MOVE QNAME TO SAVE AREA           RH\nCLCQ     CLC   QNAME(0),16(R2)    COMPARE QNAMES                    RH\n         SPACE 2\nFOUNDIT  L     R3,8(,R2)        GET ADDR OF FIRST MINOR QCB\n         MVI   QNFOUND+1,X'F0'    CHANGE NOP TO B                   RH\n         MVC   QMSGNAM,16(R2)     MOVE QNAME TO MSG                 RH\n         TPUT  QMSG,14            SEND MSG                          RH\n         SPACE 1                                                    RH\nMINORLP  CLI   0(R10),C'*'      DO ALL DSNAMES?\n         BE    SKIPCHEK\n         EX    R11,DSNCOMP      IS IT OUR DSN?\n         BNE   NEXTMIN          CHECK NEXT MINOR QCB\nSKIPCHEK DS    0H\n         SLR   R8,R8\n         IC    R8,17(,R3)         GET FLAG BYTE\n         STC   R8,TYPE+15         SET UP BYTE 2                     RH\n         SRL   R8,4               DROP LOW ORDER 4 BITS             RH\n         STC   R8,TYPE+14         SET UP BYTE 1                     RH\n*        MVI   TYPE+13,C' '       MOVE LTH TO MSG                   RH\n         MVZ   TYPE+14(1),=X'F0'  FIX ZONE                          RH\n         MVZ   TYPE+15(1),TYPE+14 FIX ZONE                          RH\n*\n         SLR   R8,R8\n         IC    R8,16(,R3)       GET LENGTH OF DSNAME\n         CVD   R8,DWORD           CONVERT TO DECIMAL                RH\n         UNPK  TYPE+10(3),DWORD+6(2) MOVE LTH TO MSG                RH\n         MVI   TYPE+10,C' '       MOVE LTH TO MSG                   RH\n         MVZ   TYPE+12(1),TYPE+11 FIX ZONE                          RH\n         CH    R8,=H'52'          IS LTH OKAY?                      RH\n         BNH   *+4+4              YES                               RH\n         LH    R8,=H'52'          NO, SET TO MAX                    RH\n         BCTR  R8,R0            MINUS ONE FOR EXECUTE\n         MVI   DSNBUFF,C' '     CLEAR FIELD TO BLANKS FIRST\n         MVC   DSNBUFF+1(51),DSNBUFF\n         EX    R8,DSNMOVE       MOVE DSN TO OUR BUFF\n         L     R4,8(,R3)        GET ADDR OF FIRST QEL\nQELLP    MVC   TYPE(10),=CL10'SHARE'\n         TM    12(R4),X'80'     IS IT ENQUEUED SHARE?\n         BO    *+10             YES\n         MVC   TYPE(10),=CL10'EXCLUSIVE'\n         LH    R5,14(,R4)       GET ASID ASSOCIATED WITH QEL\n         SLL   R5,2             MULT BY 4 TO INDEX TABLE\n         LA    R5,0(R5,R6)      GET ASSOCIATED ASCB ADDR.\n         ICM   R5,7,1(R5)\n         BZ    PUTMSG\n         CLC   0(4,R5),=C'ASCB'\n         BNE   PUTMSG\n         ICM   R1,7,173(R5)     GET JOBNAME PTR\n         BZ    TRYSTC\n         MVC   JOBNAME(8),0(R1) MOVE IN JOBNAME\n         B     PUTMSG\nTRYSTC   ICM   R1,7,177(R5)     GET STC NAME PTR\n         BZ    PUTMSG\n         MVC   JOBNAME(8),0(R1) MOVE IN STC NAME\nPUTMSG   CLI   1(R10),C'E'      LIST ONLY EXCLUSIVE REQUESTS?\n         BNE   DOALL\n         CLC   TYPE(10),=CL10'EXCLUSIVE'\n         BNE   NEXTQEL\nDOALL    CLC   0(2,R10),=C'*J'  LIST A PARTICULAR JOBNAME?\n         BNE   SKIPJOB          NO, LIST ALL JOBS\n         EX    R9,JOBCOMP       DO JOBNAMES MATCH?\n         BNE   NEXTQEL\nSKIPJOB  CLC   DSNBUFF(52),OLDNAME\n         BNE   TPUT\n         MVI   DSNBUFF,C' '\n         MVC   DSNBUFF+1(51),DSNBUFF\n         MVI   DSNBUFF+4,C'\"'\nTPUT     TPUT  DSNBUFF,87\n         CLI   DSNBUFF,C' '\n         BE    NEXTQEL\n         MVC   OLDNAME(52),DSNBUFF SAVE DSNAME\nNEXTQEL  ICM   R4,7,1(R4)       GET ADDR OF NEXT QEL\n         BNZ   QELLP\n         SPACE 2\nNEXTMIN  ICM   R3,7,1(R3)       GET ADDR OF NEXT MINOR QCB\n         BNZ   MINORLP\n         ICM   R2,7,1(R2)         R2 -> TO NEXT MAJOR QCB           RH\n         BNZ   QTEST              GO SEE IF WE DO THIS ONE TOO      RH\n         B     RETURN\nHELP     TPUT  HELP1,L'HELP1\n         TPUT  HELP2,L'HELP2\n         TPUT  HELP3,L'HELP3\n         TPUT  HELP4,L'HELP4\n         TPUT  HELP5,L'HELP5\n         TPUT  HELP6,L'HELP6\n         TPUT  HELP7,L'HELP7\n         TPUT  HELP8,L'HELP8      PUT ENTER MSG                     RH\n         SPACE 1                                                    RH\nGETANS   DS    0H                                                   RH\n         TGET  REPLY,80,EDIT,WAIT GET INPUT                         RH\n         LTR   R15,R15            WAS TGET OKAY ?                   RH\n         BNZ   RETURN             NO, RETURN                        RH\n         LR    R11,R1             PUT LTH IN R11                    RH\n         LA    R10,REPLY          R10 -> TO REPLY                   RH\n         OC    REPLY,OLDNAME      MAKE SURE ANSWER IS UPPER CASE    RH\n         B     DECODE             GO DECODE ANSWER                  RH\n         EJECT\nDSNMOVE  MVC   DSNBUFF(0),20(R3) COPY DSN FROM MINOR QCB\nDSNCOMP  CLC   0(0,R10),20(R3)  DO THE DSNS MATCH?\nJOBCOMP  CLC   2(0,R10),JOBNAME DO JOBNAMES MATCH?\n         SPACE 2\nSAVE     DC    18F'-1'\nDWORD    DC    D'0'\nOLDNAME  DC    CL52' '\nDSNBUFF  DC    CL52' ',CL1' '\nJOBNAME  DC    CL8' ',CL2' '\nTYPE     DC    CL10' ',CL60' '\nHELP1    DC    C'PARM FIELD OPTIONS:'\nHELP2    DC    C'Q=ENQ NAME(ABBREV) AS 1ST PARM. DEFAULT = SYSDSN'  RH\nHELP3    DC    C'     *       ..... LIST ALL DSNAMES IN USE'\nHELP4    DC    C'     *E      ..... LIST ALL EXCLUSIVE REQUESTS'\nHELP5    DC    C'     XXXX    ..... LIST ALL DSNS STARTING WITH XXXX'\nHELP6    DC    C'                   (CAN BE ANY LENGTH UP TO 44)'\nHELP7    DC    C'     *JXXXX  ..... LIST ALL DSNS FOR JOBNAME XXXX'\nHELP8    DC    C'ENTER PARM -EG- Q=SPF,*E'                          RH\nQNAME    DC    CL8'SYSDSN'                                          RH\nQMSG     DC    C'QNAME='                                            RH\nQMSGNAM  DC    CL8' '                                               RH\n         DC    C' NOT FOUND'                                        RH\nLQMSG    EQU   *-QMSG                                               RH\nREPLY    DC    CL80' '            TGET BUFFER                       RH\nMISSPARM DC    C'MISSING PARAMETER, RE-ENTER'                       RH\nLMISS    EQU   *-MISSPARM                                           RH\n         SPACE 2\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   ENQ\n//LKED.SYSLMOD DD DSN=HALL.LINKLIB(ENQ),DISP=OLD\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FILEDUMJ": {"ttr": 13836, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03?\\x00\\x99\\x03?\\x14\\x14\\x00\\x13\\x00\\x13\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-02T00:00:00", "modifydate": "1999-02-02T14:14:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "RH87944"}, "text": "//FILEDUMP JOB\n/*ROUTE  PRINT R7\n//OUT1   OUTPUT DEFAULT=NO,COPIES=1,CLASS=A,          LANDSCAPE 67X138\n//             PAGEDEF=L1C100,FORMDEF=L1C000\n//OUT2   OUTPUT DEFAULT=NO,COPIES=1,CLASS=A,          PORTRAIT 88X96\n//             PAGEDEF=P1E100,FORMDEF=P1E000\n//OUT3   OUTPUT DEFAULT=NO,COPIES=1,CLASS=A,          PORTRAIT 64X80\n//             PAGEDEF=P1B000,FORMDEF=P1B000\n//OUT4   OUTPUT FORMDEF=DCF,LINECT=0          FOR LASER/DCF, SYSOUT=1\n//*\n//*      PARMS HEX...PRINT OFFSET  IN HEX\n//*\n//*\n//STEP1 EXEC PGM=FILEDUMP,PARM='HEX,START=85,SKIP=13,STOP=99'\n//STEPLIB DD DSN=SYS9.UTIL.LOAD,DISP=SHR\n//SYSPRINT DD SYSOUT=(,),OUTPUT=*.OUT1\n//*YSPRINT DD SYSOUT=1,OUTPUT=*.OUT4         FOR LASER PRINTER\n//SYSUT1 DD DSN=IMSVS.DEVL.SIRUF.G0041V00,DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FILEDUMP": {"ttr": 14081, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03?\\x00\\x99\\x03?\\x13U\\n\\xcc\\n\\xcc\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-02T00:00:00", "modifydate": "1999-02-02T13:55:00", "lines": 2764, "newlines": 2764, "modlines": 0, "user": "RH87944"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "FREEALL": {"ttr": 15110, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x13\\x03\\x01\\xbc\\x01\\xbc\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T13:03:00", "lines": 444, "newlines": 444, "modlines": 0, "user": "RH87944"}, "text": "//FREEALL  JOB\n/*ROUTE  PRINT R7\n//*\n//*   DSN=CBT.SOURCE(FREEALL)\n//*\n//S1        EXEC  HLASMCL,CLASS='*',\n//        MAC='SYS1.MACLIB',\n//        MAC1='SYS1.AMODGEN'\n//ASM.SYSIN DD  *\n*          DATA SET CBT320     AT LEVEL 002 AS OF 10/20/75\n TITLE 'FREEALL ALIAS(FA) FREE ALL DYNAMICALLY ALLOCATED DATASETS(TSO)'\n***********************************************************************\n*       FREEALL  ALIAS FA          (NO OPERANDS EXPECTED)             *\n*                                                                     *\n*       THIS COMMAND PROCESSOR IS USED TO FREE ALL DYNAMICALLY        *\n*       ALLOCATED DATA SETS WHICH HAVE BEEN ALLOCATED BY A GIVEN      *\n*       TSO USER.                                                     *\n*                                                                     *\n*       IT WILL FREE ALL DATA SETS WHICH:                             *\n*         1. HAVE BEEN DYNAMICALLY ALLOCATED                          *\n*         2. ARE NOT CURRENTLY IN USE.                                *\n*         3. ARE NOT CURRENTLY OPEN.                                  *\n*                                                                     *\n*                                                                     *\n*      BASIC LOGIC:                                                   *\n*      GET CVT ADDRESS;GET TCB ADDRESS;GET CURRENT JSCB ADDRESS;      *\n*      GET POINTER TO QDB; GET POINTER TO DSAB CHAIN FROM QDB;        *\n*      FOLLOW DSAB CHAIN LOOKING FOR CANDIDATES TO FREE; WHEN FOUND   *\n*      BUILD DAIR (IKJDAP18) PARAMETER LIST AND ISSUE LINK TO IKJDAIR *\n*      WHO FREES THE DATA SET; WHEN AT END OF CHAIN TERMINATE EXECUTIO*\n*                                                                     *\n*                                                                     *\n*  THE ASSEMBLY OF THIS MODULE REQUIRES SYS1.MACLIB AND SYS1.AMODGEN  *\n*                                                                     *\n***********************************************************************\nFREEALL  CSECT\nFREEALL  AMODE ANY\nFREEALL  RMODE ANY\n         LA    R1,0(0,R1)         CLEAR R1 HI-ORDER BYTE FOR 31     RH\n         LA    R13,0(0,R13)       CLEAR R13 HI-ORDER BYTE FOR 31    RH\n         BSM   14,0               SAVE CURRENT AMODE                RH\n         STM   R14,R12,12(R13)     SAVE REGS\n*        BALR  R12,0\n*        USING *,R12\n         LR    R12,R15            SET BASE REG\n         USING FREEALL,R12        SET ADDRESSABILITY\n         B     AROUND\n         DC    CL8'FREEALL'   MODULE NAME\n         DC    C'VERSION 2.0' VERSION NUMBER\n         DC    C' '\n         DC    CL8'&SYSDATE'  DATE MODULE COMPILED\n         DC    C' '\n         DC    CL8'&SYSTIME'  TIME MODULE COMPILED\nAROUND   DS    0H\n         LR    R8,R1\n         USING CPPL,R8\n*\n*        BECAUSE SOME OF THE CONTROL BLOCKS MAY BE ACCESSED IN 31\n*        BIT MODE PUT US INTO 31 BIT MODE ADDRESSING\n*\n*        L     R1,XADDR1          GET 31 BIT MODE ADDRESS           RH\n         ICM   R1,15,XADDR1       GET 31 BIT MODE ADDRESS           RH\n         BSM   0,R1               GET INTO 31 BIT MODE              RH\n*        CNOP  0,4                ALIGN ON A FULLWORD BOUNDARY      RH\nXADDR1   DC    AL4(*+4+X'80000000') NEXT ADDRESS IS 31 BIT MODE     RH\n*\n         GETMAIN R,LV=LDYNAMIC    GET AREA IN 24-BIT ADDR (R OPT)\n         LR    R11,R1\n         USING WORKAREA,R11\n         LA    R9,SAVEAREA\n         ST    R13,SAVEAREA+4\n         ST    R9,8(,R13)\n         LR    R13,R9\n         L     R1,CPPLUPT\n         L     R2,CPPLECT\n         LA    R3,ECB\n         L     R4,CPPLPSCB\n         LA    R5,DAPB\n         ST    R8,FAILCPPL        SAVE A(CPPL) FOR DAIRFAIL         RH\n         STM   R1,R5,DAPL\n         XC    ECB,ECB\n         L     R2,CPPLCBUF        R2 -> TO INPUT PARM               RH\n         DROP  R8\n         LH    R4,0(0,R2)         R4 = LTH OF CMD\n         CH    R4,=H'6'           LTH OVER 6? EG FA ALL?\n         BNH   NOPARM             NO\n         LA    R8,4(0,R2)         R8 -> TO CMD\n         CLC   =C'FREEALL',0(R8)  IS CMD FREEALL?\n         BNE   NOTFREEA           NO, MUST BE A PARM\n         CH    R4,=H'11'          LTH OVER 11? EG FREEALL ALL?\n         BNH   NOPARM             NO\n         SPACE 1\nNOTFREEA DS    0H\n         AH    R8,2(0,R2)         R8 -> TO CMD PARM\n         SH    R4,=H'4'           R4 = LTH OF CMD\n         SH    R4,2(0,R2)         R4 = LTH OF PARM\n         BZ    *+4+2              NO BCTR IF R4 = 0\n         BCTR  R4,0               R4 = HEX LTH OF PARM\n         EX    R4,MAKEUP          MAKE PARM UPPER CASE\n         CLC   =C'ALL',0(R8)      IS PARM = ALL?\n         BE    FREEPARM           YES\n         EX    R4,SAVEDD          SAVE DDNAME\n         OI    PARMFLAG,X'40'     SAY FREE SPECIFIED DD\n         B     NOPARM             ON WE GO\n         SPACE 1\nSAVEDD   MVC   FREEDD(0),0(R8)    SAVE DD TO FREE\nMAKEUP   OC    0(0,R8),UPPERC     MAKE IT UPPER CASE\nFREEDD   DC    CL8' '\nUPPERC   DC    CL8' '\n         SPACE 1\nFREEPARM DS    0H\n         MVI   PARMFLAG,X'80'     SAY FREE EVERYTHING!\n         SPACE 1\nNOPARM   DS    0H\n         MVI   FREEFLAG,C' '      CLEAR FREED DSNS FLAG             RH\n         SPACE 1\nFRSTDSAB DS    0H\n         L     R2,CVTPTR      CVT ADDR\n         USING CVTMAP,R2\n         L     R2,CVTTCBP     TCB-TCB ADDR   (TCBHEAD)\n         L     R2,4(,R2)      TCB ADDR       (CURRENT TCB)\n         USING TCB,R2\n         L     R2,TCBJSCB     JOB STEP CONTROL BLOCK ADDR\n         USING IEZJSCB,R2\n         L     R2,JSCDSABQ    LOAD ADDRESS OF QDB FOR DSAB CHAIN\n         CLC   8(4,R2),=F'0'  ZERO DATA SETS FOR THIS USER\n         BE    NODSNS         IF HE DONT HAVE ANY WE CANT FREE EM   RH\n         L     R2,12(R2)      LOAD ADDRESS OF FIRST DSAB\n         USING DSAB,R2\n         SPACE 1\nINLOOP   DS    0H\n         CLC   =CL4'DSAB',0(R2)   DO WE REALLY POINT TO A DSAB ?    RH\n         BNE   INCRE              NO, GO SEE IF ANY MORE            RH\n         TM    PARMFLAG,X'80'     FREE EVERYTHING????               RH\n         BO    INLOOP2            YES!                              RH\n         TM    PARMFLAG,X'40'     FREE SPECIFIC DD ??               RH\n         BZ    INLOOP1            NO                                RH\n         L     R3,16(0,R2)        R3 -> TO TIOT\n         CLC   FREEDD,4(R3)       IS THIS SPECIFIED DD?\n         BE    INLOOP2            YES, GO FREE IT\n         B     NOFREE0            NO, GO LOOK AT NEXT ONE\n         SPACE 1\nINLOOP1  DS    0H\n         TM    DSABFLG1,DSABDALC   DATA SET DYNAMICALLY ALLOCATED\n         BZ    NOFREE0        NO, GO LOOK AT NEXT ONE\n*        TM    DSABFLG1,DSABPALC  WAS DSN PERMANENTLY ALLOCATED?    RH\n*        BO    NOFREE0            YES, DON'T FREE IT THEN           RH\n*        TM    DSABFLG1,DSABNUSE   DATA SET IN USE\n*        BO    NOFREE1        YES DONT FREE IT\n*                                                                   RH\n*              FREE DATA SET EVEN IF IT'S PERMANENTLY ALLOCATED     RH\n*              BECAUSE CALL AND TEST ALLOCATE THIS WAY.             RH\n*                                                                   RH\n*              FREE DATA SET EVEN IF IT'S IN USE BECAUSE IT MAY     RH\n*              BE IN USE BECAUSE  IT WAS NOT CLOSED PROPERLY        RH\n*                                                                   RH\n         SPACE 1\nINLOOP2  DS    0H\n         MVI   FMMSG,C' '         CLEAR MSG AREA                    RH\n         MVC   FMMSG+1(83),FMMSG  *                                 RH\n         L     R3,DSABTIOT    LOAD ADDRESS OF TIOT ENTRY\n         USING TIOELNGH,R3    SET ADDRESSABILITY TO TIOT ENTRY\n         TM    DSABFLG1,DSABCATM  DATA SET CONCATENATED?            RH\n         BZ    NOTCAT         NO, ON WE GO                          RH\n         CLI   TIOEDDNM,C' '      IS THERE A DDNAME?                RH\n         BNH   NOFREE0            NO, NOT 1ST CONCAT DSN            RH\n         SPACE 1                                                    RH\nNOTCAT   DS    0H                                                   RH\n         MVC   FMDDN,TIOEDDNM MOVE IN DDNAME FROM TIOT\n         L     R4,TIOEJFCB    LOAD ADDRESS OF JFCB\n         SRL   R4,8           SHIFT OFF UNWANTED BYTE\n         LA    R4,16(R4)      SKIP OVER PREFIX\n         TM    TIOEJFCB+2,X'01' IS IT REALLY A TOKEN?\n         BNO   ISADDR             NO, IT'S AN ADDRESS\n         SPACE 1\n         LA    R7,EPA             R7 -> TO EPA\n         ST    R7,SWEPAPTR        INIT EPA POINTER\n         USING ZB505,R7           SET EPA BASE\n         XC    SWAEPA,SWAEPA      INIT EPA\n         MVC   SWVA,TIOEJFCB      SAY WE WANT JFCB FROM TIOT\n*\n*              USE SWAREQ TO LOCATE THE JFCB\n*\n         SWAREQ FCODE=RL,EPA=SWEPAPTR,MF=(E,SWAPARMS),UNAUTH=YES\n         LTR   R15,R15            WAS SWAREQ SUCCESSFUL?\n         BNZ   NOFREE1            NO, BYPASS THIS JFCB\n         L     R4,SWBLKPTR        R4 -> TO JFCB\n         SPACE 1\nISADDR   DS    0H\n         USING INFMJFCB,R4\n         MVC   FMDSN,JFCBDSNM  MOVE IN DSNAME\n*        CLC   FMDSN(8),=C'NULLFILE' IS THE DSN 'NULLFILE' ?        RH\n*        BE    NOFREE1            YES DON'T FREE IT THEN            RH\n         LA    R5,FMDSN       GET START OF DSN                      RH\n         LA    R6,44          DSN LENGTH - (XXXXXXXX)               RH\nMBRLOOP1 EQU   *                                                    RH\n         CLI   0(R5),C' '     BLANK FOUND                           RH\n         BE    MBRBLANK       GOT FIRST BLANK                       RH\n         LA    R5,1(R5)       INCREMENT ADDRESS                     RH\n         BCT   R6,MBRLOOP1    GO DO IT AGAIN                        RH\nMBRBLANK EQU   *                                                    RH\n         CLC   JFCBELNM,=CL8' '    MEMBER NAME PRESENT\n         BE    NOMBR\n         MVI   0(R5),C'('     MOVE IN L PAREN\n         MVC   1(8,R5),JFCBELNM  MOVE IN MEMBER NAME\n         LA    R5,2(R5)       SKIP OVER ( AND FIRST CHAR OF MEMBER\n         LA    R6,7           MAX LENGTH OF MEMBER NAME\nMBRLOOP2 EQU   *\n         CLI   0(R5),C' '     BLANK FOUND\n         BE    MBREND         GOT BLANK AFTER MEMBER NAME\n         LA    R5,1(R5)       INCREMENT INDEX\n         BCT   R6,MBRLOOP2    GO FIND END\nMBREND   EQU   *\n         MVI   0(R5),C')'\n         LA    R5,1(R5)       R5 -> TO NEXT BLANK                   RH\nNOMBR    EQU   *\n         DROP  R4\n*        MVC   1(6,R5),=CL6' '    BLANK VOL SER\n         SR    R4,R4              CLEAR R4\n         ICM   R4,7,TIOEFSRT      LOAD UCB ADDRESS\n*        L     R4,TIOEFSRT-1    LOAD UCB ADDRESS\n*        LA    R4,0(R4)       CLEAR HIGH ORDER BYTE\n         LTR   R4,R4          ZERO ?\n         BE    NOVOL\n         USING UCBOB,R4\n         CLI   UCBTBYT3,UCB3DACC\n         BNE   NOVOL\n         MVC   2(3,R5),=CL3'ON '  MOVE 'ON ' TO MSG                 RH\n         MVC   5(6,R5),UCBVOLI  MOVE IN VOL SER                     RH\n         CLI   5(R5),C' '         IS THERE A VOLSER?\n         BNE   VOLSET             YES\n         MVC   5(3,R5),=C'VIO'    NO, SAY ON VIO\n         SPACE 1\nVOLSET   DS    0H\n         LA    R5,12(R5)       R5 -> TO NEXT BLANK                  RH\n         DROP  R4\nNOVOL    EQU   *\n         AGO   .NOVOL\n*                                                                   RH\n*              IN CASE PAGE CONTAINING DSAB GETS FREED,             RH\n*              GET POINTER TO NEXT DSAB BEFORE WE RELEASE           RH\n*              THIS ONE                                             RH\n*                                                                   RH\n*        ICM   R2,7,DSABFCHN+1    R2 -> TO NEXT DSAB ENTRY          RH\n*                                                                   RH\n.NOVOL   ANOP\n         MVC   DAPB(DAPB18L),DAPB18C INITIALIZE DAPB\n         LA    R8,DAPB        MAKE DAIR 18 ADDRESSABLE\n         USING DAPB18,R8\n         MVC   DA18DDN,TIOEDDNM MOVE IN DDNAME FROM TIOT\n         LA    R1,DAPL        ADDRESS OF DAPL\n         LINK  EP=IKJDAIR     FREE DSE\n         LTR   R15,R15            WAS DAIR SUCCESSFUL ?             RH\n         BZ    FREEOK             YES, CONTINUE                     RH\n*        BNZ   INCRE              NO, GET NEXT DSAB                 RH\n*        AGO   .SKIP2\n*        TM    PARMFLAG,X'40'     FREE SPECIFIC DD ??               RH\n*        BZ    INCRE              NO, GET NEXT DSAB                 RH\n*        BZ    FREEOK YES, CONTINUE                                 RH\n         SPACE 1                                                    RH\n         ST    R15,DAIRCODE       SAVE DAIR ERROR CODE              RH\n         LA    R15,DAPL           R15 -> TO DAIR PARM LIST          RH\n         ST    R15,FAILPL         SAVE IT FOR DAIRFAIL              RH\n         LA    R1,FAILPL          R1 -> TO DAIRFAIL PARM LIST       RH\n         LINK  EP=IKJEFF18        LINK TO DAIRFAIL                  RH\n         LTR   R15,R15            WAS DAIRFAIL OKAY ?               RH\n         BNZ   ERROR              NO, ISSUE ERROR MSG               RH\n*        MVC   1(18,R5),=CL18'WAS NOT FREED'                        RH\n*        LA    R1,FMMSG       LOAD ADDRESS OF MESSAGE TO TERMINAL   RH\n*        TPUT  (1),84             PUT FREED MSG                     RH\n         B     INCRE              GET NEXT DSN                      RH\n.SKIP2   ANOP\n         SPACE 1                                                    RH\nFREEOK   EQU   *\n         MVC   1(18,R5),=CL18'SUCCESSFULLY FREED'                   RH\n         LA    R1,FMMSG       LOAD ADDRESS OF MESSAGE TO TERMINAL\n         TPUT  (1),84             PUT FREED MSG                     RH\n         MVI   FREEFLAG,C'F'      SAY A DSN WAS FREED               RH\n*                                 DATASET WAS FREED, SO DSAB CHAIN\n*                                 HAS BEEN RECHAINED AND THE\n*                                 POINTER TO THE NEXT DSAB IS IN\n*                                 THE PREVIOUS DSAB, IF NOT THE 1ST\n         SR    R1,R1              CLEAR R1\n         ICM   R1,7,DSABBCHN+1    R1 -> TO PREV DSAB ENTRY          RH\n*                                 SO WE CAN GET NEXT ONE...\n         LTR   R1,R1              IS R1 0?                          RH\n         BZ    INCRE              YES, NO PREV DSAB'S               RH\n*                                 SO GET NEXT ONE FROM FCHN...\n         LR    R2,R1              R2 -> TO PREV DSAB\n         B     INCRE              GO CHECK FOR ANOTHER DSAB\n*        LTR   R2,R2              ANY MORE DSABS?                   RH\n*        BNE   INLOOP             YES, GO DO THE REST OF EM         RH\n*        B     NODSNS             NO, END OF FREEALL                RH\n         SPACE 1                                                    RH\nNOFREE0  EQU   *\nNOFREE1  EQU   *\nNOFREE2  EQU   *\n         SPACE 1                                                    RH\nINCRE    EQU   *\n         LTR   R2,R2              IS R2 0?                          RH\n         BZ    NODSNS             YES, END OF DSAB'S                RH\n         CLC   =CL4'DSAB',0(R2)   DO WE REALLY POINT TO A DSAB ?    RH\n         BE    INCRE2             YES, ON WE GO                     RH\n         SPACE 1                                                    RH\n*                                                                   RH\n*              PAGE CONTAINING DSAB WAS PROBABLY FREED,             RH\n*              GO START AT THE FIRST DSAB AGAIN...                  RH\n*                                                                   RH\n         B     FRSTDSAB           GO START AT CVT AGAIN             RH\n         AGO   .SKIP1\n         LA    R1,DSABMSG         NO, POINT R1 TO MSG               RH\n         LA    R0,L'DSABMSG       R0 = LTH OF MSG                   RH\n         TPUT  (1),(0)            SEND MSG TO TERMINAL              RH\n         B     NODSNS             END OF DSAB'S                     RH\n.SKIP1   ANOP\n         SPACE 1                                                    RH\nINCRE2   DS    0H                                                   RH\n         ICM   R2,7,DSABFCHN+1    R2 -> TO NEXT DSAB ENTRY          RH\n         BNZ   INLOOP             IF MORE, GO DO THEM TOO           RH\n*        L     R2,DSABFCHN    LOAD POINTER TO NEXT DSAB ENTRY\n*        LTR   R2,R2          END OF CHAIN\n*        BNE   INLOOP         NO GO DO THE REST OF EM\n         DROP  R2,R3\n         SPACE 1                                                    RH\nNODSNS   DS    0H                                                   RH\n         CLI   FREEFLAG,C' '      WERE ANY DSNS FREED?              RH\n         BNE   RETURN             YES, DON'T PRINT MSG              RH\n         MVC   FMMSG,MSG2         PUT MSG IN ARE BELOW 24 BIT LINE\n         TPUT  FMMSG,50,,,HOLD,BREAKIN                              RH\n         SPACE 1\nRETURN   LR    R1,R13         DYNAMIC AREA ADDR IN R1\n         LA    R0,LDYNAMIC    SIZE OF AREA\n         L     R13,4(,R13)    PREV SAVE AREA\n         LA    R1,0(,R1)      CLEAR HI ORDER\n         SVC   10             FREEMAIN\n*        ST    R15,16(0,R13)      PUT RC INTO SAVE AREA             RH\n         LM    14,12,12(13)   RESTORE REGS\n         LA    15,0           RETURN CODE\n         MVI   12(13),X'FF'   INDICATE RETURN\n*              GET INTO PROPER MODE AND GO BACK TO CALLER           RH\n         BSM   0,R14                                                RH\n         SPACE 1\nERROR    DS    0H\n         LR    R3,R15\n         MVC   FMMSG,MSG          PUT MSG IN ARE BELOW 24 BIT LINE\n         TPUT  FMMSG,50,,,HOLD,BREAKIN\n         ABEND 400,DUMP\nMSG      DC    CL50'ERROR FROM DAIR, PLEASE SEND DUMP TO SOFTWARE'\nMSG2     DC    CL50'NO DATA SETS TO BE FREED'                       RH\nDSABMSG  DC    C'INVALID DSAB CHAIN, CALL CUSTOMER SERVICE CENTER'  RH\nPARMFLAG DC    X'00'\n*              X'80'              FREE EVERYTHING\n*              X'40'              FREE SPECIFIED DD\n         SPACE 1\nSWEPAPTR DS    F                  FOR SWAREQ\nEPA      DS    CL28               FOR SWAREQ\nSWAPARMS SWAREQ MF=L              FOR SWAREQ\n         EJECT\nDAPB18C  DS    0F\n         DC    X'0018'        DA18CD\n         DC    H'0'           DA18FLG\n         DC    H'0'           DA18DARC\n         DC    H'0'           DA18CTRC\n         DC    A(0)           DA18PDSN\n         DC    CL8' '         DA18DDN\n         DC    CL8' '         DA18MNM\n         DC    CL2' '         DA18SCLS\n         DC    X'00'          DA18DSP2\n         DC    X'10'          DA18CTL  -  RLSE PERM ALLOC\n         DC    CL8' '         DA18JBNM\nDAPB18L  EQU   *-DAPB18C      LENGTH\n         SPACE 1                                                    RH\nFAILPL   DC    A(DAIRPL)                                            RH\n         DC    A(DAIRCODE)                                          RH\n         DC    A(JEFF02)                                            RH\n         DC    A(FAILSW)                                            RH\nFAILCPPL DC    A(0)                                                 RH\n         SPACE 1                                                    RH\nDAIRPL   DC    F'0'                                                 RH\nDAIRCODE DC    F'0'                                                 RH\nJEFF02   DC    F'0'                                                 RH\nFAILSW   DC    X'0001'                                              RH\n         EJECT\nWORKAREA DSECT\nSAVEAREA DS    18F\nDAPB     DS    0F\n         ORG   DAPB+DAPB18L\nDAPL     DS     5F\nECB      DS     F\nFREEFLAG DS    C                  SET TO 'F' IF ANY DSNS FREED      RH\nFMMSG    DS    0CL84           MESSAGE TO USER\nFMDDN    DS    CL8             DDNAME\nFMB1     DS    CL1\nFMDSN    DS    CL44            DSNAME\nFMB2     DS    CL1\nFMVOL    DS    CL6             VOL SER (IF DASD)\nFMB3     DS    CL1\nFMTEXT   DS    CL23            ACTION CODE\n         DS    0D\nLDYNAMIC EQU   *-WORKAREA\n         EJECT\n         PRINT   GEN\n         IKJDAP18\n         EJECT\n         IKJCPPL\n         EJECT\n         CVT   DSECT=YES                                            RH\n         EJECT\n         IKJTCB\n         EJECT\n         IEZJSCB\n         EJECT\nDSAB     IHADSAB\n         EJECT\n         DSECT\n         IEFUCBOB LIST=YES\n         EJECT\n         DSECT\n         IEFJFCBN LIST=YES\n         EJECT\nTIOT     DSECT\n         IEFTIOT1\n         IEFJESCT                 FOR SWQREQ\n         IEFZB505                 FOR SWAREQ\n*        EQUATE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   FREEALL\n//LKED.SYSLMOD  DD DSN=HALL.LINKLIB(FREEALL),DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GENQ": {"ttr": 15364, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x13\\x12\\x028\\x028\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T13:12:00", "lines": 568, "newlines": 568, "modlines": 0, "user": "RH87944"}, "text": "//GENQ     JOB\n/*ROUTE  PRINT R7\n//* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n//* $  CBT.SOURCE(GENQ)\n//* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n//S1        EXEC  HLASMCL,CLASS='*'\n//ASM.SYSIN DD  *\n*        MODIFICATIONS.....\n*              JUL 11/96...ADDED  CODE TO PRINT 1ST 32 CHARS OF\n*                          QNAME IN HEX IF IT CONTAINS UNPRINTABLES\n*\n*\n*\n*              THIS VERSION IS FOR SP3 SYSTEMS\n*              NOTE..FIXUP CODE AT GQSCAN MACRO FOR 'BAD' GEN'D CODE\n*                    TO AVOID NEEDING 2 GQSCANS, AS RESNAME PARM\n*                    CAUSES GEN'D CODE TO DEFAULT TO QNAME LTH & FLAG\n*\nENQ      CSECT\n         TITLE 'COMMAND TO LIST ENQUEUED DATASET NAMES'\n         USING *,R15\n         B     AROUND             BRANCH AROUND DUMP TITLE\n         DC    C'ENQ     '        PROGRAM NAME\n         DC    C'&SYSDATE'        DATE WRITTEN\n         DC    C'&SYSTIME'        TIME WRITTEN\n         SPACE 1\nAROUND   DS    0H\n         DROP  R15\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         USING ENQ,R12\n         ST    R13,SAVE+4\n         LR    R11,R13\n         LA    R13,SAVE\n         ST    R13,8(,R11)\n         L     R1,0(,R1)        GET ADDR OF PARM LIST\n         LA    R10,2(,R1)       SAVE PARM STRING ADDR FOR LATER\n         LH    R11,0(,R1)       GET LENGTH OF PARM STRING\n         EJECT\n         L    R4,GQLTH             LOAD LENGTH OF REQUEST FOR GETMAIN\n*\n*    ROUND THE LENGTH UP TO A DOUBLEWORD BOUNDARY.\n*\n         A    R4,=F'7'             ADD 7 BYTES\n         N    R4,=XL4'FFFFFFF8'    ROUND TO DOUBLEWORD BOUNDARY\n         ST   R4,GQLTH             STORE UPDATED LENGTH\n*\n*    ISSUE THE REQUEST FOR VIRTUAL STORAGE.\n*\n         GETMAIN RC,LV=(R4)\n*\n*    DETERMINE IF VIRTUAL STORAGE WAS ALLOCATED.  A RETURN CODE OF 0\n*    INDICATES SUCCESS.\n*\n         LTR  R15,R15              RETURN CODE = 0 ???\n         BNZ  CFATAL               NO, SO SET THE RETURN CODE TO 4.\n*\n*    STORE THE ADDRESS OF THE VIRTUAL STORAGE.\n*\n         ST   R1,GQCORE\n         SPACE 1                                                    RH\nDECODE   DS    0H                                                   RH\n         LTR   R11,R11          CHECK FOR NO PARMS\n         BZ    HELP             GIVE HELP MSG\n         LA    R7,7               R7 = MAX QNAME LTH                RH\n         CLC   0(2,R10),=C'Q='    IS IT Q= PARM?                    RH\n         BNE   NOQ                NO, USE DEFAULT OF SYSDSN         RH\n         MVC   QNAME,OLDNAME      MAKE SURE QNAME IS BLANK          RH\n         LA    R10,2(0,R10)       R10 -> TO QNAME                   RH\n         LR    R7,R10             R7 -> TO QNAME                    RH\n         BCTR  R11,0              R11 = LTH OF REST OF PARM         RH\n         BCTR  R11,0              ''                                RH\n         SPACE 1                                                    RH\nQLOOP    DS    0H                                                   RH\n         CLI   0(R7),C','         FOUND COMMA ?                     RH\n         BE    COMMAFND           YES, SET UP QNAME                 RH\n         LA    R7,1(0,R7)         R7 -> TO NEXT BYTE                RH\n         BCT   R11,QLOOP          LOOK AT IT                        RH\n         TPUT  MISSPARM,LMISS     SAY MISSING PARM                  RH\n         B     GETANS             GO GET NEXT REPLY                 RH\n         SPACE 1                                                    RH\nCOMMAFND DS    0H                                                   RH\n         BCTR  R11,0              R11 = LTH OF REST 0F PARM         RH\n         SR    R7,R10             R7 = LTH OF QNAME                 RH\n         BCTR  R7,0               R7 = HEX LTH                      RH\n         EX    R7,MVCQ            MOVE QNAME                        RH\n         LA    R10,2(R7,R10)      R10 -> TO NEXT PARM               RH\n         SPACE 1                                                    RH\nNOQ      DS    0H                                                   RH\n         CLC   0(2,R10),=C'*J'  LIST DSNS BY JOBNAME?\n         BNE   NOJOBN           NO, DON'T GET JOBNAME LENGTH\n         LR    R9,R11           GET LENGTH OF PARM STRING\n         S     R9,=F'3'         SUBTRACT 1 FOR EX, 2 FOR '*J'\nNOJOBN   BCTR  R11,R0           DECR FOR EXECUTE LATER\n         SPACE 2\nQTEST    DS    0H                                                   RH\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*     GQSCAN  QNAME=ALL OR QNAME,                                     *\n*             RNAME=ALL,                                              *\n*             SCOPE=ALL                                               *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n         L     R1,GQCORE           R1 -> TO CORE FOR GQSCAN\n         L     R4,GQLTH            R4 = LTH OF CORE\n         LA    R5,0                R5 = 0 IF Q=ALL\n*                                                                   RH\n*              SINCE YOU CAN'T TELL GQSCAN THAT THERE IS A QNAME,   RH\n*              RATHER THAN HAVE 2  OR MORE GQSCAN'S, FUDGE THE      RH\n*              GQSCAN PARM LIST.                                    RH\n*                                                                   RH\n*                                                                   RH\n         LA    R2,SCANALL4+12      R2 -> TO WHERE BAL R1 S/B        RH\n         CLC   0(2,R2),=X'4510'    IS IT HERE?                      RH\n         BE    QTEST2              YES                              RH\n         LA    R2,2(0,R2)          NO, CNOP MUST BE HERE, GO AROUND RH\n         SPACE 2\nQTEST2   DS    0H                                                   RH\n         LA    R2,4(0,R2)          GO AROUND BAL INST               RH\n*                                                                   RH\n*              SET THE 'QNAME LTH SPECIFIED' BIT IN THE PARM OFF,   RH\n*              AND SET THE 'QNAME LTH' TO 0, IN CASE THE QNAME IS   RH\n*              'ALL'.                                               RH\n*                                                                   RH\n         NI    45(R2),255-X'02'    DEFAULT TO NO QNAME SPECIFIED    RH\n         MVI   47(R2),X'00'        DEFAULT LTH IS 0                 RH\n*        MVI   SCANALL4+63,X'08'   FIX BAD GQSCAN GEN               RH\n*        MVI   SCANALL4+65,X'00'   FIX BAD GQSCAN GEN               RH\n         CLC   QNAME,=CL8'ALL'     Q=ALL SPECIFIED ?\n         BE    SCANALL4            YES, R5 IS SET\n*                                                                   RH\n*              A SPECIFIC QNAME IS WANTED, SO, ......               RH\n*              SET THE 'QNAME LTH SPECIFIED' BIT IN THE PARM ON,    RH\n*              AND SET THE 'QNAME LTH' TO 8.                        RH\n*                                                                   RH\n         OI    45(R2),X'02'        SET TO QNAME IS SPECIFIED        RH\n         MVI   47(R2),X'08'        SET LTH TO 8                     RH\n*        MVI   SCANALL4+63,X'0A'   FIX BAD GQSCAN GEN               RH\n*        MVI   SCANALL4+65,X'08'   FIX BAD GQSCAN GEN               RH\n         LA    R5,QNAME            NO, R5 -> TO QNAME\nSCANALL4 GQSCAN AREA=((1),(4)),                                        *\n               SCOPE=ALL,RESNAME=((5)),                                *\n               TOKEN=GQTOKEN\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*     PROCESS THE GQSCAN RETURN CODE.                                 *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n*\n*    GQSCAN REGISTER VALUES ARE:\n*\n*       R0 - UPPER HALF CONTAINS THE RIB LENGTH.  THE LOWER HALF\n*            CONTAINS THE RIBE LENGTH.\n*\n*       R1 - INDICATES THE NUMBER OF RIB'S IN THE GQSCAN BUFFER.\n*\n*      R15 -  0 = ALL THE DATA HAS BEEN COPIED INTO THE GQSCAN BUFFER.\n*             4 = NO RESOURCES MATCHED THE CALLER'S REQUEST.\n*             8 = NOT ALL OF THE DATA WILL FIT INTO THE GQSCAN BUFFER.\n*            12 = ABNORMAL SITUATION ENCOUNTERED.\n*            16 = INVALID 'SYSNAME' SPECIFIED.  SHOULD NOT OCCUR.\n*\nCHECKGQ  EQU   *\n         ST    R1,RIBNBR           STORE NO. OF RIB'S IN BUFFER\n         ST    R1,RIBNBR2          STORE NO. OF RIB'S FOR DEBUGGING\n         SRDL  R0,16               ISOLATE RIB LENGTH\n         ST    R0,RIBLTH           STORE RIB LENGTH\n         SRL   R1,16               ISOLATE RIBE LENGTH\n         ST    R1,RIBELTH          STORE RIBE LENGTH\n         C     R15,=F'0'           ALL RIB'S RETURNED IN BUFFER ???\n         BE    NORMAL              YES\n         C     R15,=F'4'           NO RIB'S RETURNED ???\n         BE    NORIBS              YES\n         C     R15,=F'8'           WAS BUFFER FILLED ???\n         BE    NORMAL              YES, NORMAL FOR NOW\n*        BE    FATAL1              YES\n         C     R15,=F'12'          ABNORMAL SITUATION ???\n         BE    FATAL2              YES\n         C     R15,=F'16'          INVALID 'SYSNAME' SPECIFIED ???\n         BE    FATAL3              YES\n         BE    FATAL4              UNKNOWN RETURN CODE\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*     PROCESS FATAL ERRORS.                                           *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n*\n*    FATAL ERROR 1.  THE GQSCAN MACRO'S RETURN CODE WAS 8.  THIS MEANS\n*    THE GQSCAN BUFFER WAS FILLED.\n*\nFATAL1   EQU   *\n*        LA    R01,PFATAL1         ADDRESS OF PARAMETER LIST\n         B     CFATAL              GO CALL DQFATAL\n*\n*    FATAL ERROR 2.  THE GQSCAN MACRO'S RETURN CODE WAS 12.  THIS MEANS\n*    AN ABORMAL SITUATION OCCURRED WHILE PROCESSING THE GQSCAN MACRO.\n*\nFATAL2   EQU   *\n*        LA    R01,PFATAL2         ADDRESS OF PARAMETER LIST\n         B     CFATAL              GO CALL DQFATAL\n*\n*    FATAL ERROR 3.  THE GQSCAN MACRO'S RETURN CODE WAS 16.  THIS MEANS\n*    AN INVALID 'SYSNAME' WAS SPECIFIED.  THIS SHOULD NOT OCCUR AS THE\n*    'SYSNAME' PARAMETER IS NOT USED.\n*\nFATAL3   EQU   *\n*        LA    R01,PFATAL3         ADDRESS OF PARAMETER LIST\n         B     CFATAL              GO CALL DQFATAL\n*\n*    FATAL ERROR 4.  THE GQSCAN MACRO'S RETURN CODE WAS NOT DOCUMENTED.\n*\nFATAL4   EQU   *\n*        LA    R01,PFATAL4          ADDRESS OF PARAMETER LIST\n*\n*    ENTER HERE IF THE RETURN CODE IS NOT DOCUMENTED.\n*\nCFATAL   EQU   *\n         DC    H'0'\n*        L     R15,=V(DQFATAL)      ADDRESS OF ERROR ROUTINE\n*        BALR  R14,R15              CALL DQFATAL\n*        B     ABNORMAL             SET RETURN CODE TO 4\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*    END ROUTINE.                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n*\n*    NORMAL TERMINATION.\n*\nNORMAL   EQU   *\n         L     R4,GQCORE           R4 -> TO GQSCAN RIBS\n         LR    R2,R4               R2 -> TO GQSCAN RIBS\n         B     FOUNDIT             GQSCAN GIVES US THE QNAME\n*                                  WE WANT\n         SPACE 1                                                    RH\nNORIBS   DS    0H                 NO RIBS, NO QCB                   RH\n         CLC   20(4,R2),24(R2)    DID WE LOSE SOME RIBES ?\n         BH    LOSTRIBE           YES, END FOR NOW\n         ICM   R15,15,GQTOKEN      ARE THERE MORE RIBS IN GRS ?\n         BNZ   QTEST               YES, GO GET EM\n         SPACE 1                                                    RH\nQNFOUND  NOP   RETURN             B IF QNAME FOUND                  RH\nLOSTRIBE MVC   QMSGNAM,QNAME      MOVE QNAME TO MSG                 RH\n         TPUT  QMSG,LQMSG         PUT MSG TO TERMINAL               RH\n         SPACE 2\nRETURN   DS    0H               COMMON RETURN POINT\n         L     R4,GQCORE        R4 -> TO GOTTEN CORE\n         L     R5,GQLTH         R5 = LTH OF GOTTEN CORE\n         FREEMAIN RU,A=(4),LV=(5)  FREE GOTTEN CORE\n         L     R13,SAVE+4       COMMON RETURN POINT\n         L     R14,12(,R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n         SPACE 2\nMVCQ     MVC   QNAME(0),0(R10)    MOVE QNAME TO SAVE AREA           RH\n         SPACE 2\nFOUNDIT  DS    0H\n         L     R3,24(0,R2)         R3 = NBR OF RIBES IN RIB\n         ST    R3,NBRRIBES         SAVE IT\n         LA    R3,0(0,R2)          R3 -> TO RIB\n         A     R3,RIBLTH           R3 -> TO MINOR RNAME\n         MVI   QNFOUND+1,X'F0'    CHANGE NOP TO B                   RH\n         MVC   QMSGNAM,32(R2)     MOVE QNAME TO MSG                 RH\n         SPACE 1                                                    RH\nMINORLP  CLI   0(R10),C'*'      DO ALL DSNAMES?\n         BE    SKIPCHEK            YES\n         EX    R11,DSNCOMP      IS IT OUR DSN?\n         BNE   NEXTMIN          CHECK NEXT MINOR QCB\n         SPACE 1                                                    RH\nSKIPCHEK DS    0H\n         MVC   SCOPE,=CL7'SYSTEM ' DEFAULT SCOPE TO SYTEM\n         TM    30(R2),X'80'        IS SCOPE SYSTEM ?\n         BO    SCOPESET            YES\n         MVC   SCOPE,=CL7'SYSTEMS' SET SCOPE TO SYTEMS\n         TM    30(R2),X'40'        IS SCOPE SYSTEMS?\n         BO    SCOPESET            YES\n         MVC   SCOPE,=CL7'STEP   ' SET SCOPE TO STEP\n         TM    30(R2),X'40'        IS SCOPE STEP ?\n         BO    SCOPESET            YES\n         MVC   SCOPE,=CL7'GLOBAL ' SET SCOPE TO GLOBAL\n         TM    30(R2),X'40'        IS SCOPE GLOBAL ?\n         BO    SCOPESET            YES\n         MVC   SCOPE,=CL7'LOCAL  ' IT MUST BE LOCAL THEN\n         SPACE 1                                                    RH\nSCOPESET DS    0H\n*        SLR   R8,R8\n*        IC    R8,30(,R2)         GET SCOPE FLAG BYTE\n*        STC   R8,HEXSCOPE+1      SET UP BYTE 2                     RH\n*        SRL   R8,4               DROP LOW ORDER 4 BITS             RH\n*        STC   R8,HEXSCOPE        SET UP BYTE 1                     RH\n*        MVZ   HEXSCOPE(1),=X'F0'  FIX ZONE                         RH\n*        MVZ   HEXSCOPE+1(1),=X'F0' FIX ZONE                        RH\n*\n         SLR   R8,R8\n         IC    R8,31(,R2)       GET LENGTH OF DSNAME\n         CVD   R8,DWORD           CONVERT TO DECIMAL                RH\n         UNPK  QLTH(3),DWORD+6(2) MOVE LTH TO MSG                   RH\n         MVI   QLTH,C' '           BLANK FIRST CHAR                 RH\n         MVZ   QLTH+2(1),QLTH+1    FIX ZONE                         RH\n         CH    R8,=H'52'          IS LTH OKAY?                      RH\n         BNH   *+4+4              YES                               RH\n         LH    R8,=H'52'          NO, SET TO MAX                    RH\n         BCTR  R8,R0            MINUS ONE FOR EXECUTE\n         MVI   DSNBUFF,C' '     CLEAR FIELD TO BLANKS FIRST\n         MVC   DSNBUFF+1(51),DSNBUFF\n         EX    R8,DSNMOVE       MOVE DSN TO OUR BUFF\n         LH    R4,28(0,R2)         R4 = LTH OF RIBVAR\n         LA    R4,40(R4,R2)        R4 -> TO RIBE\nQELLP    MVC   TYPE(3),=CL3'SHR'\n         TM    30(R4),X'80'     IS IT ENQUEUED SHARE?\n         BO    *+10             YES\n         MVC   TYPE(3),=CL3'OLD'\n*        LH    R5,28(,R4)       GET ASID ASSOCIATED WITH QEL\n*        SLL   R5,2             MULT BY 4 TO INDEX TABLE\n*        LA    R5,0(R5,R6)      GET ASSOCIATED ASCB ADDR.\n*        ICM   R5,7,1(R5)\n*        BZ    PUTMSG\n*        CLC   0(4,R5),=C'ASCB'\n*        BNE   PUTMSG\n*        ICM   R1,7,173(R5)     GET JOBNAME PTR\n*        BZ    TRYSTC\n         MVC   JOBNAME(8),0(R4) MOVE IN JOBNAME\n         B     PUTMSG\n*RYSTC   ICM   R1,7,177(R5)     GET STC NAME PTR\n*        BZ    PUTMSG\n*        MVC   JOBNAME(8),0(R1) MOVE IN STC NAME\nPUTMSG   DS    0H\n         CLC   =C'*E',0(R10)      LIST ONLY EXCLUSIVE REQUESTS?\n         BNE   DOALL\n         CLC   TYPE(3),=CL3'OLD'\n         BNE   NEXTQEL\nDOALL    CLC   0(2,R10),=C'*J'  LIST A PARTICULAR JOBNAME?\n         BNE   SKIPJOB          NO, LIST ALL JOBS\n         EX    R9,JOBCOMP       DO JOBNAMES MATCH?\n         BNE   NEXTQEL\nSKIPJOB  CLC   DSNBUFF(52),OLDNAME\n         BNE   TPUT\n         MVI   DSNBUFF,C' '\n         MVC   DSNBUFF+1(51),DSNBUFF\n         MVI   DSNBUFF+4,C'\"'\nTPUT     DS    0H\n         CLC   GQNAME,QMSGNAM      STILL SAME QNAME ?\n         BE    TPUT2               YES, ON WE GO\n         MVC   GQNAME,QMSGNAM      NO, SAVE NEW QNAME               RH\n         TPUT  QMSG,14             SEND QNAME MSG                   RH\n         SPACE 1                                                    RH\nTPUT2    DS    0H\n         TPUT  DSNBUFF,80          PRINT ENQ LINE\n         CLI   DSNBUFF,C' '\n         BE    TPUT3\n         MVC   OLDNAME(52),DSNBUFF SAVE DSNAME\n*\nTPUT3    DS    0H\n*\n* SEE IF ANY UNPRINTABLE CHARS IN QNAME...\n*\n         ST    R2,SAVE2           SAVE R2 OVER TRT\n         EX    R8,TRANS1          LOOK FOR ANY UNPRINTABLE CHAR\n         L     R2,SAVE2           RELOAD R2\n         BZ    BUFOKAY            NONE\n         SPACE 1\nCHKLTH   DS    0H\n         LR    R1,R8              R1 = LTH\n         CH    R8,=H'31'          MORE THAN 33 CHARS?\n         BL    UNDER8             NO\n         LA    R1,31              YES, HEX 1ST 32 BYTES\n         SPACE 1\nUNDER8   DS    0H                 CLEAR SOME FIELDS\n         MVI   DUMPLINE,C' '\n         MVC   DUMPLINE+1(79),DUMPLINE\n         MVC   DUMPLINE+4(4),=C'HEX='\n         MVI   DUMPDATA,C' '\n         MVC   DUMPDATA+1(79),DUMPDATA\n         MVI   DUMPDALO,C' '\n         MVC   DUMPDALO+1(79),DUMPDALO\n*\n* DUMP THE DATA FROM THE SPECIFIED STORAGE AREA\n*\n*\nDUMPRINT EQU   *\n         EX    R1,MVC1   DUMPDATA(00),DSNBUFF    GET DATA TO TRANSLATE\n         EX    R1,MVC2   DUMPDALO(00),DSNBUFF    GET DATA TO TRNASLATE\n         EX    R1,TR1    DUMPDATA(00),DUMPTBHI   CONVERT HO ORDER HEX\n         EX    R1,TR2    DUMPDALO(00),DUMPTBLO   CONVERT LO ORDER HEX\n         MVC   DUMPLINE+8(64),DUMPSELD DIGITS TO SELECT WAS 72\n         TR    DUMPLINE+8(64),DUMPDATA DATA => O/P LINE\nDUMPNXT1 EQU   *\n         TPUT  DUMPLINE,80         PRINT ENQ LINE\nDUMPEND  DS    0H\n         SPACE 1\nBUFOKAY  DS    0H\n*\nNEXTQEL  DS    0H\n         L     R15,NBRRIBES        R15 = NBR RIBES\n         SH    R15,=H'1'           -1\n         BZ    NEXTMIN             NO RIBES LEFT, GET NEXT RIB\n         ST    R15,NBRRIBES        SAVE NBR RIBES LEFT\n         A     R4,RIBELTH          R4 -> TO NEXT RIBE\n         B     QELLP               GO PROCESS IT\n         SPACE 2\nNEXTMIN  DS    0H\n         L     R15,RIBNBR          R15 = NBR OF RIBS LEFT\n         SH    R15,=H'1'           - 1\n         BZ    NORIBS              IF NONE LEFT, END OF GENQ\n         ST    R15,RIBNBR          SAVE NBR OF RIBS LEFT\n         SPACE 1\n         LA    R4,40(0,R2)         R4 -> TO END OF FIXED RIB\n         LH    R15,28(0,R2)        R15 = LTH OF RIBVAR\n         AR    R4,R15              R4 NOW -> TO FIRST RIBE IN RIB\n         L     R3,24(0,R2)         R3 = NBR OF RIBES IN RIB\n         MH    R3,RIBELTH+2        R3 = LTH OF ALL RIBES\n         AR    R4,R3               R4 SHOULD NOW -> TO NEXT RIB\n         LR    R2,R4               SO SHOULD R2\n         B     FOUNDIT             GO CHECK IT OUT\n         SPACE 2\nHELP     TPUT  HELP1,L'HELP1\n         TPUT  HELP2,L'HELP2\n         TPUT  HELP3,L'HELP3\n         TPUT  HELP4,L'HELP4\n         TPUT  HELP5,L'HELP5\n         TPUT  HELP6,L'HELP6\n         TPUT  HELP7,L'HELP7\n         TPUT  HELP8,L'HELP8      PUT ENTER MSG                     RH\n         SPACE 1                                                    RH\nGETANS   DS    0H                                                   RH\n         TGET  REPLY,80,EDIT,WAIT GET INPUT                         RH\n         LTR   R15,R15            WAS TGET OKAY ?                   RH\n         BNZ   RETURN             NO, RETURN                        RH\n         LR    R11,R1             PUT LTH IN R11                    RH\n         LA    R10,REPLY          R10 -> TO REPLY                   RH\n         OC    REPLY,OLDNAME      MAKE SURE ANSWER IS UPPER CASE    RH\n         B     DECODE             GO DECODE ANSWER                  RH\n         EJECT\nMVC1     MVC   DUMPDATA(00),DSNBUFF    GET DATA TO TRANSLATE\nMVC2     MVC   DUMPDALO(00),DSNBUFF    GET DATA TO TRNASLATE\nTR1      TR    DUMPDATA(00),DUMPTBHI   CONVERT HO ORDER HEX\nTR2      TR    DUMPDALO(00),DUMPTBLO   CONVERT LO ORDER HEX\nDSNMOVE  MVC   DSNBUFF(0),0(R3)    COPY DSN FROM MINOR QCB\nDSNCOMP  CLC   0(0,R10),0(R3)      DO THE DSNS MATCH?\nJOBCOMP  CLC   2(0,R10),JOBNAME DO JOBNAMES MATCH?\nTRANS1   TRT   DSNBUFF(0),TRTAB   LOOK FOR ANY UNPRINTABLE CHAR\nTRTAB    DC    256X'FF'           UNPRINTABLE\n         ORG   TRTAB+64\n         DC    XL1'00'            BLANK IS OKAY\n         ORG   TRTAB+X'4B'\n         DC    XL1'00'            PERIOD IS OKAY\n         ORG   TRTAB+C'\"'\n         DC    XL1'00'            DOUBLE QUOTE IS OKAY\n         ORG   TRTAB+C'#'\n         DC    XL1'00'            POUND SIGN IS OKAY\n         ORG   TRTAB+C'A'\n         DC    9X'00'             ABCDEFGHI IS OKAY\n         ORG   TRTAB+C'J'\n         DC    9X'00'             JKLMNOPQR IS OKAY\n         ORG   TRTAB+C'S'\n         DC    8X'00'             STUVWXYZ IS OKAY\n         ORG   TRTAB+C'0'\n         DC    10X'00'            0123456789 IS OKAY\n         ORG\n         SPACE 1\nWORKU    DC    CL52' '\n         SPACE 2\nSAVE2    DC    F'-1'\nSAVE     DC    18F'-1'\nDWORD    DC    D'0'\nOLDNAME  DC    CL52' '\nDSNBUFF  DC    CL52' '\n         DC    CL1' '\nJOBNAME  DC    CL8' '\n         DC    CL1' '\nTYPE     DC    CL3' '\nQLTH     DC    CL3' '\n         DC    CL1' '\nSCOPE    DC    CL7' '\n         DC    CL1' '\nHEXSCOPE DC    CL2' '\n         DC    CL1' '\n         SPACE 1\nHELP1    DC    C'PARM FIELD OPTIONS:'\nHELP2    DC    C'Q=ENQ NAME(ABBREV) AS 1ST PARM. DEFAULT = SYSDSN'  RH\nHELP3    DC    C'     *       ..... LIST ALL DSNAMES IN USE'\nHELP4    DC    C'     *E      ..... LIST ALL EXCLUSIVE REQUESTS'\nHELP5    DC    C'     XXXX    ..... LIST ALL DSNS STARTING WITH XXXX'\nHELP6    DC    C'                   (CAN BE ANY LENGTH UP TO 44)'\nHELP7    DC    C'     *JXXXX  ..... LIST ALL DSNS FOR JOBNAME XXXX'\nHELP8    DC    C'ENTER PARM -EG- Q=SPF,*E'                          RH\nQNAME    DC    CL8'SYSDSN'                                          RH\nQMSG     DC    C'QNAME='                                            RH\nQMSGNAM  DC    CL8' '                                               RH\n         DC    C' NOT FOUND'                                        RH\nLQMSG    EQU   *-QMSG                                               RH\nGQNAME   DC    CL8' '                                               RH\nREPLY    DC    CL80' '            TGET BUFFER                       RH\nMISSPARM DC    C'MISSING PARAMETER, RE-ENTER'                       RH\nLMISS    EQU   *-MISSPARM                                           RH\n         SPACE 2\nGQCORE   DS    F\nGQLTH    DC    F'32000'\nGQTOKEN  DS    F\nRIBNBR   DS    F\nRIBNBR2  DS    F\nRIBLTH   DS    F\nRIBELTH  DS    F\nNBRRIBES DS    F\nDUMPDATA DS    8F\nDUMPDALO DS    8F\nDUMPBLK2 DC    CL8' '             LEAVE AFTER DUMPDALO\nDUMPBLNK DC    CL80' '\nDUMPTBHI DC    16X'F0'\n         DC    16X'F1'\n         DC    16X'F2'\n         DC    16X'F3'\n         DC    16X'F4'\n         DC    16X'F5'\n         DC    16X'F6'\n         DC    16X'F7'\n         DC    16X'F8'\n         DC    16X'F9'\n         DC    16X'C1'\n         DC    16X'C2'\n         DC    16X'C3'\n         DC    16X'C4'\n         DC    16X'C5'\n         DC    16X'C6'\nDUMPTBLO DC    16X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\nDUMPSELR DC    X'00400141024203438004440545064607'\n         DC    X'4780084809490A4A0B4B800C4C0D4D0E'\n         DC    X'4E0F4F80801050115112521353801454'\n         DC    X'15551656175780185819591A5A1B5B80'\n         DC    X'1C5C1D5D1E5E1F5F'\nDUMPSELD DC    X'00200121022203234004240525062607'\n         DC    X'2740082809290A2A0B2B400C2C0D2D0E'\n         DC    X'2E0F2F40401030113112321333401434'\n         DC    X'15351636173740183819391A3A1B3B40'\n         DC    X'1C3C1D3D1E3E1F3F'\nDUMPSELA DC    X'010502060307'\nDUMPLINE DC    C' '\n         DC    CL79' '\n*        DC    CL132' '\n         SPACE 2\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   ENQ\n//LKED.SYSLMOD DD DSN=SYS9.LOADLIB(GENQ),DISP=SHR\n//*KED.SYSLMOD DD DSN=HALL.LINKLIB(GENQ1),DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GENQCLST": {"ttr": 15620, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03?\\x00\\x99\\x03?\\x13\\t\\x007\\x007\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-02T00:00:00", "modifydate": "1999-02-02T13:09:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "RH87944"}, "text": "PROC 0 DSN() QNAME() DEBUG\nCONTROL NOLIST NOCONLIST NOFLUSH\nSEND '** USER &SYSUID IS USING THE ENQ CLIST ON &SYSDATE AT &SYSSTIME '\nIF &DEBUG = DEBUG THEN CONTROL LIST CONLIST NOFLUSH\n\nIF &STR(&QNAME) = THEN SET QNAME = ALL\nIF &STR(&DSN)  \u00ac= THEN GOTO ROKAY\n\nCLRSCRN\nWRITE CMD FORMAT IS \"ENQ DSN(...) QNAME(...)\nWRITE\nWRITE     WHERE DSN CAN BE...\nWRITE\nWRITE       *   TO GIVE YOU ALL DSNAMES IN USE FOR THE QNAME\nWRITE           ..EG..%ENQ DSN(*) WOULD LIST ALL ENQUEUES ON THE SYSTEM\nWRITE                 %ENQ DSN(*) QNAME(SYSDSN) WOULD LIST ALL ENQUEUES\nWRITE                                           TO QNAME SYSDSN.\nWRITE\nWRITE      *E   TO GIVE YOU ALL DSNAMES USED WITH DISP=OLD\nWRITE           ..EG..%ENQ DSN(*E) WOULD LIST ALL ENQUEUES ON THE SYSTEM\nWRITE                 %ENQ DSN(*E) QNAME(SYSDSN) WOULD LIST ALL ENQUEUES\nWRITE                                           TO QNAME SYSDSN.\nWRITE\nWRITE    XXXX   TO GIVE YOU ALL DSNAMES USED STARTING WITH XXXX\nWRITE           WHERE XXXX CAN BE ANYTHING UP TO 44 BYTES\nWRITE           ..EG..%ENQ DSN(ABC) WOULD LIST ALL DATASETS STARTING\nWRITE                               WITH ABC ENQUEUED ON THE SYSTEM\nWRITE\nWRITE  *JXXXX   TO GIVE YOU ALL DSNAMES USED BY JOB  XXXX\nWRITE           ..EG..%ENQ DSN(*JABC) WOULD LIST ALL DATASETS ENQUEUED\nWRITE                                 BY JOB ABC, ON THE SYSTEM\nWRITE\nWRITE THE DEFAULT QNAME IS 'ALL'.\nWRITE\nWRITE FOR EXAMPLE, THE CMD \"ENQ DSN(*J&SYSUID) QNAME(SPFEDIT)\"\nWRITE WOULD LIST ALL DATASETS YOU ARE USING UNDER SPF\nWRITE\nWRITE IF THE RESOURCE (DATASET NAME) YOU ENTER DOES NOT GET LISTED,\nWRITE IT IS NOT ENQUEUED (IN USE).\nWRITE\nWRITE NOTE...THIS ONLY SHOWS ENQUEUES FOR THE SYSTEM YOU ARE LOGGED\nWRITE        ON TO....EG...THE A1AA, D1DD, ETC.\nWRITE\nWRITENR ENTER RESOURCE NAME...\nREAD &DSN\nIF &LENGTH(&STR(&DSN)) = 0 THEN EXIT\n\n\nROKAY:+\n     CLRSCRN\n     WRITE CMD IS...TSOEXEC CALL 'SYS9.LOADLIB(GENQ)' 'Q=&QNAME,&DSN'\n     WRITE\n/* NOTE... TSOEXEC IS USED FOR EXECUTE PROTECTED LIBRARY....*/\n     TSOEXEC CALL 'SYS9.LOADLIB(GENQ)' 'Q=&QNAME,&DSN'\n     IF &LASTCC \u00ac= 0 THEN WRITE DATASET NOT ENQUEUED ON THIS SYSTEM...\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETDSNS": {"ttr": 15622, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x13\\x15\\x02\\xe8\\x02\\xe8\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T13:15:00", "lines": 744, "newlines": 744, "modlines": 0, "user": "RH87944"}, "text": "//GETDSNS   JOB\n/*ROUTE  PRINT R7\n//*\n//*    DSN=CBT.SOURCE(GETDSNS)\n//*\n//*    THIS VERSION OF GETDSNS USES SUPER LOCATE TO SEARCH THE\n//*    CATALOG.\n//*\n//*      THIS  VERSION ALSO HANDLES MIGRATED DATASETS\n//*\n//STEP1 EXEC HLASMCL,PARMC='ESD',PARML='LIST,LET,MAP'\n//ASM.SYSLIB DD DSN=SYS1.MACLIB,\n//   DISP=SHR\n//   DD DSN=SYS1.AMODGEN,DISP=SHR\n//   DD DSN=RH87944.SOURCE.CNTL,DISP=SHR\n//ASM.SYSPRINT DD SYSOUT=*\n//ASM.SYSIN DD *\n*\n*        PARM: ALL  SHOW ALL INFO\n*              VOL  PUT VOLSERS IN POSITION 1 AND DSNAME IN 37\n*              DISK LIST ONLY DATASETS ON DISK\n*              ???  ANY OTHER PARM IS CONSIDERED TO BE THE HLI\n*\nSP       TITLE  'GET DATASET NAMES FROM CATALOG'\n         MACRO\n&LAB     PUTIT &MESS\n         LCLC  &L\n&L       SETC  'L'''\n&LAB     MVC   MSG+45(&L.M&SYSNDX),M&SYSNDX  MOVE MSG TO PRINT\n         B     PRINTMSG           GO PRINT IT\nM&SYSNDX DC    C&MESS\n         MEND\n         MACRO\n&LAB     TPUTIT &MESS\n         LCLC  &L\n&L       SETC  'L'''\n&LAB     TPUT  M&SYSNDX,&L.M&SYSNDX\n         B     RETURN\nM&SYSNDX DC    C&MESS\n         MEND\n         MACRO\n&LAB     PUTIT1 &MESS\n&LAB     BAL   LINK,CLOSRDR\n         STAX  DEFER=NO\n         PUTIT &MESS\n         MEND\n*        COPY  MACROS\n         EJECT\nGETDSNS  CSECT\nBASE     EQU   12\nSTART    DS    0H\n         STM    14,12,12(13)\n         LR    BASE,15\n         USING GETDSNS,BASE,R11\n         LA    R11,4095(0,R12)   LOAD SECOND BASE REGISTER\n         LA    R11,1(0,R11)      LOAD SECOND BASE REGISTER\n         B     AROUND             BRANCH AROUND DUMP TITLE\n         DC    C'GETDSNS  '       PROGRAM NAME\n         DC    C'VERSION 2'       VERSION NUMBER\n         DC    CL8'&SYSDATE'      DATE WRITTEN\n         DC    CL6'&SYSTIME'      TIME WRITTEN\n         DC    C' '\n         DC    C'ADDED HLI OPTION TO PARM'\n         SPACE 1\nAROUND   DS    0H\n         L     15,=A(SAVEAREA)\n         ST    13,4(15)\n         ST    15,8(13)\n         LR    13,15\n         B     SAVEAREA+72\nSAVEAREA DC    18A(0)\n         LR    R10,R1  SAVE PARM LIST\n         ST    R10,CPPLADDR         SAVE A(CPPL)\n         RDJFCB DSNS              GET DSNS JFCB\n         LTR   R15,R15            WAS RDJFCB OKAY?\n         BNZ   ABEND1             NO, ABEND\n         OC    JFCBLKSI,JFCBLKSI  IS THERE A BLKSIZE IN JFCB?\n         BNZ   *+4+6              YES\n         MVC   JFCBLKSI,=H'6160'  NO, DEFAULT TO 6160\n         OPEN  (DSNS,(OUTPUT)),TYPE=J   OPEN OUTPUT DSNS FILE\n         TM    DSNS+48,X'10'      DID DSNS FILE OPEN ?              RH\n         BZ    ABEND1             NO                                RH\n         SPACE 1\n         OPEN  (REPORT,(OUTPUT))\n         TM    REPORT+48,X'10'    DID REPORT FILE OPEN ?            RH\n         BZ    ABEND1             NO                                RH\n         MVI   PRINTNOP+1,X'00'   YES, CHANGE B TO NOP              RH\n         MVI   RETNOP+1,X'00'     YES, CHANGE B TO NOP              RH\n         SPACE 1\n******** ***** ****************** *********************************\n*\n*              CHECK FOR A PARM.  THE PARMS CAN BE:\n*\n*        PARM: ALL  SHOW ALL INFO\n*              VOL  PUT VOLSERS IN POSITION 1 AND DSNAME IN 37\n*              DISK LIST ONLY DATASETS ON DISK\n*              ???  ANY OTHER PARM IS CONSIDERED TO BE THE HLI\n*\n******** ***** ****************** *********************************\n         L     R7,0(0,R10)        R7 -> TO PARM\n         LH    R2,0(0,R7)         R2 = LTH OF DSN\n         LTR   R2,R2              IS THERE A PARM?\n         BZ    OPENSYS            NO\n*        BZ    GETIN              NO\n         LA    R3,2(0,R7)         R3 -> TO DSN\n         SPACE 1\nCHKALL   DS    0H\n         CLC   =C'ALL',0(R3)      IS PARM = ALL?\n         BNE   NOTALL             NO, LOOK FOR VOL\n         OI    SW3,SW380          YES, SAY SHOW ALL DSNAMES         RH\n         LA    R3,4(R3,0)         R3 -> TO WHERE NEXT PARM WILL BE\nH4       EQU   *-2                HALFWORD OF 4\n         SH    R2,H4              R2 = LTH LEFT\n         BNP   OPENSYS            NONE LEFT\n*        BNP   GETIN              NONE LEFT\n         SPACE 1\nNOTALL   DS    0H\n         CLC   =C'VOL',0(R3)      IS PARM = VOL?\n         BNE   NOTVOL             NO, LOOK FOR DISK\n         OI    SW3,SW310          YES, SAY PUT VOLS FIRST           RH\n         LA    R3,4(R3,0)         R3 -> TO WHERE NEXT PARM WILL BE\n         SH    R2,H4              R2 = LTH LEFT\n         BP    CHKALL             CHECK NEXT PARM, IF ANY\n         BNP   OPENSYS            NONE LEFT\n*        BNP   GETIN              NONE LEFT\n         SPACE 1\nNOTVOL   DS    0H\n         CLC   =C'DISK',0(R3)     IS PARM = DISK?\n         BNE   NOTDISK            NO, ASSUME IT'S THE HLI....\n         OI    SW3,SW320          YES, SAY SHOW ONLY DISK VOLSERS   RH\n         LA    R3,5(R3,0)         R3 -> TO WHERE NEXT PARM WILL BE\nH5       EQU   *-2                HALFWORD OF 5\n         SH    R2,H5              R2 = LTH LEFT\n         BP    CHKALL             CHECK NEXT PARM, IF ANY\n         BNP   OPENSYS            NONE LEFT\n*        BNP   GETIN              NONE LEFT\n         SPACE 1\nNOTDISK  DS    0H\n         B     ENDLOOP2           GO PROCESS IT\n         SPACE 1\nOPENSYS  DS    0H\n         OPEN  (SYSIN,(INPUT))    OPEN INPUT FILE                   RH\n         TM    SYSIN+48,X'10'     DID SYSIN FILE OPEN ?             RH\n         BZ    ABEND1             NO                                RH\n*        BZ    USEPARM            NO                                RH\n         OI    SW3,SW340          YES, SAY WE HAVE SYSIN            RH\n         SPACE 1\nGETIN    DS    0H\n         GET   SYSIN              READ A RECORD\n         LR    R2,R1              R2 -> TO DATASET NAME\n         SPACE 1\nBATLOOP1 DS    0H\n         CLI   0(R2),C' '         END OF DSN ?\n         BE    ENDLOOP1           YES\n         LA    R2,1(0,R2)         R2 -> TO NEXT DSN CHAR\n         B     BATLOOP1           CHECK IT\n         SPACE 1\nENDLOOP1 DS    0H\n         SR    R2,R1              R2 = LTH OF DSN\n         LR    R3,R1              R3 -> TO DSN\n         SPACE 1\nENDLOOP2 DS    0H\n         LA    R4,LVLBUF+2        R4 -> TO WHERE DSN GOES\n         MVC   LVLBUF(2),=XL2'00' LTH = 0\n         MVI   0(R4),C' '         CLEAR DSN FIELD\n         MVC   1(43,R4),0(R4)     ''\n         MVC   DSNAME(44),0(R4)   CLEAR FIELD CALLED DSNAME\n         B     BATCH0             CONTINUE\n         SPACE 1\nUSEPARM  DS    0H\n         L     R7,0(0,R10)        R7 -> TO PARM\n         LA    R4,LVLBUF+2        R4 -> TO WHERE DSN GOES\n         MVC   LVLBUF(2),=XL2'00' LTH = 0\n         LH    R2,0(0,R7)         R2 = LTH OF DSN\n         LA    R3,2(0,R7)         R3 -> TO DSN\n         SPACE 1\nBATCH0   DS    0H\n         SH        R2,=H'1'\n         EX        R2,XMOVE\n*XMOVE   MVC   0(0,R4),0(R3)\n         AH        R2,=H'1'\n         AH        R2,LVLBUF\n         STH       R2,LVLBUF\n         SPACE 1\n**  ENTRY HERE FOR PARTIAL INDEX SPECIFIED TO ORIG LOCATE\nSCATDSN2 DS    0H                                               MVS\n*        MVC   DSNAME,SAVPART+2   RESTORE DSNAME\n         MVC   SUPERLVL(45),LVLBUF+1  SET UP NAME FOR SUPER LOCATE\n         SR    R1,R1              CLEAR R1\n         IC    R1,SUPERLVL        R1 = LTH OF DSN\n*\n*              SEE IF THERE IS A  PERIOD IN DSN ALREADY\n*\n         LA    R15,SUPERLVL+1     R15 -> TO DSNAME\n         SPACE 1\nSCATDSN3 DS    0H                                               MVS\n         CLI   0(R15),C'.'        FIND A PERIOD?\n         BE    SLOC               YES, LEAVE LTH ALONE\n         LA    R15,1(0,R15)       R15 -> TO NEXT DSN CHAR\n         BCT   R1,SCATDSN3        CHECK FOR PERIOD\n         SPACE 1\nSCATDSN4 DS    0H                 NO PERIOD FOUND               MVS\n         IC    R1,SUPERLVL        R1 = LTH OF DSN\n         LA    R15,1(0,R1)        R15 = LTH OF DSN + .\n         STC   R15,SUPERLVL       SAVE NEW LTH\n         LA    R15,SUPERLVL+1     R15 -> TO DSN\n         LA    R15,0(R1,R15)      R15 -> TO END OF DSN\n         MVI   0(R15),C'.'        PUT . AT END OF DSN\n         SPACE 1\nSLOC     DS    0H\n         LOCATE SUPERLOC          GO GET ALL ENTRIES\n         LTR   R15,R15            WAS SUPER LOCATE OKAY ?\n         BZ    SHOWCAT            YES, GO PROCESS DSNS\n         CH    R15,=H'40'         RC = 40 ?\n         BE    GET#MORE           YES, IT'S OKAY TOO\n         CH    R15,=H'44'         RC = 44 ?\n         BNE   ERROR10            NO, SAY NOT CATALOGUED\n*\n*              LOAD THE CURRENT & REQUIRED WORKAREA SIZE\n*\nGET#MORE L     R1,WORKADDR\n         L     R0,0(,R1)          R0 = CURRENT LTH\n         L     R2,4(,R1)          R2 = REQUIRED LTH\n*        LH    R0,0(,R1)\n*        SR    R2,R2              CLEAR R2\n*        ICM   R2,3,2(R1)         GET REQUIRED WORKAREA LTH\n*\n*              FREEMAIN THE CURRENT WORKAREA\n*\n*       FREEMAIN R,                                                    X\n               A=(1),                                                  X\n               LV=(0)\n*\n*              CHECK SIZE OF NEW WORKAREA\n*\n*        C     R2,=F'65524'       IS NEW SIZE = X'FFF4'?\n*        BE    TOOBIG             YES, TOO MANY ENTRIES IN CAT\n*\n*              GETMAIN AN EXPANDED WORKAREA\n*\n*        LA    R2,1024(0,R2)      ADD 1K FOR GOOD MEASURE\n        GETMAIN R,                                                     X\n               LV=(2)\n         LTR   R15,R15            DID WE GET OUR WORK AREA?\n         BNZ   ERROR3             NO, ABEND\n*\n*              INITIALIZE THE WORKAREA ADDRESS & HEADER\n*\n*        SLL   R2,16\n         ST    R2,0(,R1)          SAVE LTH IN WORKAREA\n         LA    R2,8               R2 = 8\n         ST    R2,4(0,R1)         SET ??? IN WORKAREA\n         ST    R1,WORKADDR        SAVE A(WORKAREA) IN SUPERLOC AREA\n*\n         MVI   SUPERLOC+3,X'00'   TURN ALL RESERVED BITS OFF        RH\n         XC    CTGFDBK,CTGFDBK    CLEAR FEEDBACK AREA               RH\n*\n*              GO ISSUE SUPERLOCATE AGAIN\n*\n         B     SLOC\n         SPACE 2                                                MVS\nTOOBIG   DS    0H                                               MVS\n         PUTIT ' TOO MANY ENTRIES TO LIST. QUALIFY SEARCH WITH ANOTHER +\n               LEVEL'\n*        B     ANYMORE            SEE IF ANY MORE VOLS\n         SPACE 2                                                MVS\nSCATDSN0 DS    0H                                               MVS\n         B     LOCVOL2             EXIT\n         SPACE 2\n*\n***  ROUTINE TO PROCESS SUPER LOCATE WORK AREA\n*\nSHOWCAT  DS    0H\n         OI    SW2,X'80'          TURN INDEX SWITCH ON\n         OI    SWITCHWD,HLILIST   TURN HLI SWITCH ON\n         SR    R5,R5              MAKE SURE R5 IS 0\n*\n         L     R2,WORKADDR        R2 -> TO SUPER WORK AREA\n         L     R0,4(0,R2)         R0 = LTH OF WORKAREA USED\n         LA    R14,8(0,R2)        R14 -> TO 1ST DSN\n         SPACE 1\nCHKCAT1  DS    0H\n         LA    R14,45(0,R14)      SKIP PAST CATALOG NAME\n         CLC   =X'000000',1(R14)  1ST ENTRY NULLS?\n         BE    ERROR9             YES, NO HLI IN CAT\n         SPACE 1\nCHKCAT2  DS    0H\n         CLC   =C'CATALOG',1(R14) 1ST ENTRY A CATALOG ?\n         BNE   SCATGO0            NO\n         SPACE 1\n         CLC   =C'CATALOG',LVLBUF+2 DID HE WANT THE CATALOGS ?\n         BNE   ERROR9             NO\n         SPACE 1\nSCATGO0  DS    0H\n*        SR    R0,R0              R0 = 0                            RH\n*        ICM   R0,3,2(R2)         R0 = LTH OF WORKAREA\n*        LA    R14,4(0,R2)        R14 -> TO 1ST DSN\n*        CLI   0(R14),C'X'        IS IT THE HLI POINTER\n*        BNE   SCATGO             NO, SO MUST BE A DSN\n*        LA    R14,45(0,R14)      YES, R14 -> TO NEXT DSN\n         SPACE 1\nSCATGO   DS    0H\n         LA    R14,1(0,R14)       R14 -> PAST ID\n         ST    R14,TCAMDSN        SAVE ADDR OF FIRST DSN\n         MVC   OUTDSN(44),0(R14)  PUT DSN INTO OUTPUT LINE\n*        MVC   OUTDSN+44(32),BLANKS  CLEAR MSG AREA\n         LA    R15,0(0,R2)        R15 -> TO SUPER WORK AREA\n         AR    R15,R0             R15 -> TO END OF DSNS\n         CLC   =C'CATALOG',LVLBUF+2 DID HE WANT THE CATALOGS ?\n         BE    SCATGO1            YES\n         SH    R15,=H'45'         NO, TAKE OFF LAST ENTRY\n         SPACE 1\nSCATGO1  DS    0H\n         ST    R15,LASTDSN        SAVE ADDR OF LAST DSN\n         SPACE 1\nSCATGO2  DS    0H\n         BCTR  R14,0              R14 -> TO DSN TYPE\n         CLI   0(R14),C'A'        IS THIS A NONVSAM DATASET?\n         BE    SCATGO3            YES\n*IGRAT4  NOP   ANYMORE            B IF ONLY WANT MIGRATED DSNS\n         CLI   0(R14),C'B'        IS THIS A GDG BASE NAME?\n         BE    GDGBASE            YES\n         SPACE 1\nSCATGO3  DS    0H\n         LOCATE TCAML             FIND IT\n         LTR   R0,R15              LOCATE OK?\n         BNZ   ERROR9              BR IF NOT\n         B     LOCVOL2             NOW GO AHEAD\n         SPACE 1\nNEXTDSNA DS    0H\n         L     R14,TCAMDSN        R14 -> TO DSN WE JUST DID\n         LA    R14,45(0,R14)      R14 -> TO NEXT DSN\n         C     R14,LASTDSN        HAVE WE DONE LAST DSN ?\n         BH    RETURN2            YES, END OF SEARCH\n         ST    R14,TCAMDSN        PUT IT IN LOCATE LIST\n         MVC   OUTDSN(44),0(R14)  PUT DSN INTO OUTPUT LINE\n*        MVC   LVLBUF+2(44),0(R14) PUT DSN INTO PLI WORK AREA\n         B     SCATGO2            GO GET IT\n         SPACE  1\nLOCVOL2  DS     0H\n         LH    R5,VOLCNT          R5 = NBR VOLS FROM CATALOG\n         LA    R6,TVOL            R6 -> TO VOLSERS\n         LA    R8,OUTDSN+45       R8 -> TO WHERE VOLS GO\n         LA    R9,5               R9 = MAX VOLS PER LINE\n         CLI   TWORK+4,X'20'      IS DSN ON A DISK VOLUME?\n         BNE   NOTDISK2           NO, GO SEE WHAT IT IS\n*        MVC   OUTDSN+45(6),TWORK+6 PUT VOLSER IN OUTPUT LINE\n         SPACE  1\nVOLAA    DS    0H\n         MVC   0(6,R8),0(R6)      PUT VOLSER IN OUTPUT\n         BCT   R5,VOLBB           GET NEXT ONE, IF ANY\n         B     PRINTDSN           ELSE PRINT THE LINE\n         SPACE 1\nVOLBB    DS    0H\n         BCT   R9,VOLCC           B IF LINE NOT FULL\n         B     PRINTDSN           ELSE PRINT THE LINE\n         SPACE 1\nVOLCC    DS    0H\n         MVI   6(R8),C','         PUT IN A COMMA\n         LA    R8,7(0,R8)         R8 -> TO WHERE NEXT VOL GOES\n         LA    R6,12(0,R6)        R6 -> TO NEXT VOL\n         B     VOLAA              GO PUT IT IN LINE\n         SPACE  1\nPRINTDSN DS     0H\n         TM    SW3,SW310          PUT VOLS IN COL 1?                RH\n         BZ    PRINTDS2           NO\n         MVC   SAVEDSN,OUTDSN     SAVE DSNAME\n         MVC   OUTDSN(35),OUTDSN+45 PUT VOLSERS FIRST\n         MVI   OUTDSN+35,C' '     PUT IN A BLANK\n         MVC   OUTDSN+36(44),SAVEDSN PUT DSN IN POSN 36\n         SPACE  1\nPRINTDS2 DS     0H\n         PUT   DSNS,OUTDSN        PUT DSN INTO FILE\n         MVC   OUTDSN(44),BLANKS  CLEAR DSN AREA\n         MVC   OUTDSN+44(36),BLANKS  CLEAR MSG AREA\n         LTR   R5,R5              ANY MORE VOLS?\n         BZ    ANYMORE            NO, GO GET NEXT DSN\n         LA    R8,OUTDSN+45       R8 -> TO WHERE VOLS GO\n         LA    R9,5               R9 = MAX VOLS PER LINE\n         B     VOLAA              GO SET UP VOLS                    RH\n         SPACE 1\nXMOVE    MVC   0(0,R4),0(R3)\n         SPACE  1\nDAIRLINK DS    0H\n         SPACE 1\nANYMORE  DS    0H\n         B         RETURN         NO\n         SPACE 1\nGDGBASE  DS    0H\n         TM    SW3,SW380          SHOW ALL DSNAMES ?                RH\n         BZ    ANYMORE            NO, SEE IF ANY MORE DSNS\n         MVI   ABENDFLG,X'00'     SET ABEND FLAG TO CONTINUE\n         MVC   ERRMSG,BASEMSG     MSG = GDG BASE\n*        MVC   TUPAR1,=CL6' '     BLANK OUT VOLSER FIELD\n         SR    R5,R5              MAKE SURE R5 IS 0\n         B     VOLERR2            SET UP REST OF MSG\n         SPACE 1\nNOTDISK2 DS    0H\n         TM    SW3,SW320          SHOW ONLY DISK VOLSERS ?          RH\n         BO    ANYMORE            NO, SEE IF ANY MORE DSNS\n         TM    SW3,SW380          SHOW ALL DSNAMES ?                RH\n         BZ    VOLAA              NO, PUT VOL SER IN ANYWAY\n*        BZ    ANYMORE            NO, SEE IF ANY MORE DSNS\n         MVI   ABENDFLG,X'00'     SET ABEND FLAG TO CONTINUE\n         CLC   =C'MIGRAT',TWORK+6 HAS DATASET BEEN MIGRATED?        RH\n         BE    VOLERR             YES, SAY IT WAS MIGRATED          RH\n         SPACE  1\n         CLI   TWORK+4,X'80'      IS DSN ON A TAPE ?\n         BNE   NOTTAPE            NO\n         CLI   TWORK+5,X'80'      IS DSN ON A TAPE CARTRIDGE?\n         BNE   NOTCART            NO\n         MVC   ERRMSG,CARTMSG     MSG = CARTRIDGE TAPE DATASET\n         B     VOLERR2            SET UP REST OF MSG\n*\nNOTCART  DS    0H\n         MVC   ERRMSG,TAPEMSG     MSG = TAPE DATASET\n         B     VOLERR2            SET UP REST OF MSG\n*\nNOTTAPE  DS    0H\n         MVC   ERRMSG,UNKNMSG     MSG = UNKNOWN DEVICE TYPE\n         B     VOLERR2            SET UP REST OF MSG\n         SPACE 2\nVOLERR   DS    0H\n         MVC   ERRMSG,NTVALMSG    MSG = NOT VALID FOR YOUR USE\n*        CLC   =C'MIGRAT',TUPAR1  WANT MIGRATED DATASETS            RH\n*        BNE   VOLERR2            NO, SAY NOT VALID                 RH\n         MVC   ERRMSG,MIGMSG      MSG = DATASET WAS MIGRATED BY HSM\n         SPACE 1\nVOLERR2  DS    0H\n         MVC   OUTDSN+44(32),ERRMSG  PUT ERROR MSG BESIDE DSN\n         B     PRINTDSN           GO PRINT LINE\n**       MVC   ERRVOL,TUPAR1         MOVE BAD VOL TO MSG\n*        MVC   ERRDSN,LVLBUF+2       MOVE DSN TO ERR MSG\n*        MVC   MSG+1(L'VOLMSG),VOLMSG MOVE BAD VOL MSG TO PRINT\n         SPACE 1\nPRINTMSG DS    0H\nPRINTNOP B     PRINTPUT           NOP IF SYSPRINT FILE OPEN         RH\n         PUT   REPORT,INFO1       OUTPUT THE MSG\n         SPACE 1\nCLEARMSG DS    0H\n         MVI   MSG,C' '           CLEAR PRINT LINE\n         MVC   MSG+1(131),MSG     *\n         CLI   ABENDFLG,X'FF'     SHOULD WE END DS CMD ?\n         BE    RETURN             YES\n         B     ANYMORE            NO, GO SEE IF ANY MORE PACKS\n         SPACE 1\nPRINTPUT DS    0H                                                   RH\n         SPACE 5\nRETURN   DS    0H\n         TM    SW2,X'80'          DOING ALL DSNAMES BY CATLG ?\n         BO    NEXTDSNA           YES, GET NEXT DSNAME ADDRESS\n         SPACE 1\nRETURN2  DS    0H\n*\n*              LOAD THE CURRENT WORKAREA SIZE\n*\n         L     R1,WORKADDR        R1 -> TO WORKAREA\n         L     R0,0(,R1)          R0 = CURRENT LTH\n*\n*              FREEMAIN THE CURRENT WORKAREA\n*\n*       FREEMAIN R,                                                    X\n               A=(1),                                                  X\n               LV=(0)\n*\n*\n*              INITIALIZE THE DEFAULT WORKAREA ADDRESS & HEADER\n*\n*        SLL   R2,16\n         LA    R1,SWORK           R1 -> TO DEFAULT WORKAREA\n         ST    R1,WORKADDR        SAVE A(WORKAREA) IN SUPERLOC AREA\n         LA    R2,256             R2 = DEFAULT WORKAREA LTH\n         ST    R2,0(0,R1)         SAVE LTH IN WORKAREA\n         LA    R2,8               R2 = 8\n         ST    R2,4(0,R1)         SET ??? IN WORKAREA\n         XC    SWORKA,SWORKA      CLEAR WORK AREA                   RH\n         MVI   SUPERLOC+3,X'00'   TURN ALL RESERVED BITS OFF        RH\n         XC    CTGFDBK,CTGFDBK    CLEAR FEEDBACK AREA               RH\n*\n         TM    SW3,SW340          DOING BATCH WITH SYSIN ?\n         BO    GETIN              YES, GET NEXT DSNAME\n         SPACE 1                                                    RH\nENDBATCH DS    0H\n         SPACE 1\nRET0     DS    0H\nRETNOP   B     NOCLOSE            NOP IF REPORT FILE OPEN           RH\n         CLOSE (REPORT)           CLOSE OUTPUT FILE\n         CLOSE (DSNS)             CLOSE DSNS FILE\n         SPACE 1                                                    RH\nNOCLOSE  DS    0H\n         L     R13,4(,R13)\n         RETURN (14,12),RC=0\n         SPACE 3\n*        PRINT NOGEN\n*\nERROR2   DS    0H\n         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND\n         PUTIT ' INCOMPLETE PARAMETERS'\n*\nERROR3   DS    0H\n         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND\n         PUTIT ' NOT ENOUGH SPACE IN REGION'\n*\nERROR4   DS    0H\n         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND\n         PUTIT ' INVALID PARAMETERS'\n*\nABEND1   ABEND 1004,DUMP\nABEND2   EQU   ABEND1\n*\nERROR5   DS    0H\n         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND\n         PUTIT ' NO TIOT ENTRIES AVAILABLE'\n*\nERROR6   DS    0H\n         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND\n         PUTIT ' DDNAME NOT AVAILABLE'\n*\nERROR7   DS    0H\n         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND\n         PUTIT ' DSNAME IS MEMBER OF CONCAT. DATA SET'\n*\nERROR8   DS    0H\n         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND\n         PUTIT ' SVC 99 ERROR'\n*\nERROR9   DS    0H\n         TM    SW3,SW380          SHOW ALL DSNAMES ?                RH\n         BZ    ANYMORE            NO, SEE IF ANY MORE DSNS\n         MVI   ABENDFLG,X'00'     SET ABEND FLAG TO CONTINUE\n         MVC   MSG+1(44),SUPERLVL+1 PUT DSNAME INTO MSG             RH\n*        MVC   MSG+40(44),LVLBUF+2 PUT DSNAME INTO MSG              RH\n         B     ERROR14            GO PRINT MSG\n*\nERROR10  DS    0H\n         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND\n         B     ERROR13            GO PRINT MSG\n*\nERROR11  DS    0H\n         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND\n         PUTIT ' DATA SET HAS BEEN DELETED'\n*\nERROR12  DS    0H\n         MVI   ABENDFLG,X'00'     SET ABEND FLAG TO CONTINUE\n         PUTIT ' REQUEST DENIED BY INSTALLATION EXIT'\n*\nERROR13  DS    0H\n         MVI   SW2,X'00'          TURN ALL CATLG BITS OFF\n*\nERROR14  DS    0H\n         PUTIT ' DATA SET NOT IN CATALOG'\n         SPACE 2\n         EJECT\n* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n*        WORK AREAS\n* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\nDUMPTITL DC    C'WORKING STORAGE SECTION'\n* ------ WORK  AREAS              ------------------------------------\nVOLLTH2  DS    0F              LTH OF MSG\n         DC    AL2(0)          TSID\n         DC    AL2(L'VOLMSG)   BUFFER SIZE\nVOLMSG   DS    0CL84\n         DC    CL1' '\nERRVOL   DC    CL6' '\nERRMSG   DC    CL32' '\n         DC    C' '\nERRDSN   DS    CL44\nERRLTH   EQU   *-ERRVOL\nNTVALMSG DC    CL32'    NOT VALID FOR YOUR USE'\nDATAMSG  DC    CL32'    VSAM DATA  OBJECT NAME'\nINDEXMSG DC    CL32'    VSAM INDEX OBJECT NAME'\nHSMMSG   DC    CL32'    ERROR READING HSM DATASET'\nBASEMSG  DC    CL32'    GDG BASE'\nCARTMSG  DC    CL32'    CARTRIDGE TAPE DATASET'\nTAPEMSG  DC    CL32'    TAPE DATASET'\nUNKNMSG  DC    CL32'    UNKNOWN DEVICE TYPE'\nMIGMSG   DC    CL32'    DATASET WAS MIGRATED TO TAPE'\nLASTDSN  DC    F'0'\n         SPACE 2\n*        TCAM   LIST\nTCAML    DS     0F\nTCFLGS   DC     X'44000000'              TCAM ON DSN\nTCAMDSN  DC     A(0)                     A(DSN)\n         DC     A(0)                     VOL POINTER\n         DC     A(TWORK)                 A(256 BYTE WORK AREA)\n         DS    0D                 PUT ON DOUBLE WORD BOUNDARY\nTWORK    DS     0CL256\nVOLCNT   DC     H'0'                     VOL COUNT\nDEVTYP   DC     XL4'00'                  DEVICE TYPE\nTVOL     DC     CL6' '                   FIRST VOL SER\n         DC     CL244' '                 REST OF TCAML DATA\n         DC     CL12' '                  REST OF TCAML DATA\n         SPACE 2\n*\n*              SEE DEBUGGING HAND BOOK NBR1, SECTION 5, SVC 26,\n*              FOR SUPERLOC WORK AREA, OR MACRO IEZCTGPL.\n*\n         DS    0F\nSUPERLOC DC    X'05201100'\n         DC    A(SUPERLVL)\n         DC    A(0)\nWORKADDR DC    A(SWORK)\n         DC    X'04'\n         DC    AL3(0)\nCTGFDBK  DC    A(0)               SUPERLOCATE FEEDBACK AREA         RH\n         DC    A(0)\n         DC    A(0)\n         SPACE 3\nSWORK    DS    0F\n         DC    H'0'\n         DC    H'256'\n         DC    H'0'\n         DC    H'8'\nSWORKA   DS    CL256\n         SPACE 3\n*        PARSE PARAMETER LIST\n         SPACE 2\n         ENTRY DDSNAML,DSNAME\n*DDSNAML  DC    AL2(L'SPACDSN+L'DSPADSN)\nDDSNAML  DC    AL2(44)\nDDSNAM   DS    0CL44\nDSNAME   DS    0CL44\nDSPADSN  DC    C'            '\nSPACDSN  DC    C'      '\n         DC    CL(44-L'SPACDSN-L'DSPADSN)' '\nPRTDSNL  DC    AL2(44)\nPRTDSN   DC    CL44' '\n*\n         ENTRY LVLBUF\nPLEVEL   DC    A(LVLBUF),H'44',X'8000'\nLVLBUF   DC    AL2(*-*),CL44' '\nSUPERLVL DC    AL1(*-*),CL45' '\nSAVPART  DC    AL2(*-*),CL44' '\nTUPAR1   DC    CL6' '\n**\nABENDFLG DC    X'00'              FLAG FOR ABEND OR NOT\n**\n*\nSWITCHWD DC    BL1'00000000'      DEFAULT IS TOTAL(NO)\nHLILIST  EQU   B'00000100'        HIGH LEVEL INDEX SWITCH\nHEADING  EQU   B'00000010'        PRINT HEADING ONLY SWITCH\nTOTALS   EQU   B'00000001'        PRINT TOTALS ONLY SWITCH\n*\nSW2      DC         X'00'\nSW280    EQU   X'80'              PROCESSING AN INDEX\nSW240    EQU   X'40'              DSN IS OK\nSW220    EQU   X'20'              PROCESSING A GDG\nSW210    EQU   X'10'              PROCESSING A PARTIAL DSN\nSW204    EQU   X'04'              SPECIFIED VOLUME NOT FOUND\n*\nSW3      DC         X'00'\nSW380    EQU   X'80'              SHOW ALL DSNAMES\nSW340    EQU   X'40'              THIS IS A BATCH RUN\nSW320    EQU   X'20'              SHOW ONLY DISK VOLSERS\nSW310    EQU   X'10'              PUT VOLSERS FIRST\n*\n         SPACE 1\nCPPLADDR DC    A(0)\n         SPACE 1\nOUTDSN   DC    CL80' '            OUTPUT DSN AREA\nBLANKS   DC    CL44' '            32 BLANKS\nSAVEDSN  DC    CL44' '            SAVE AREA FOR DSNAME\n         SPACE 1\nINFO1    DS    0CL133\nMSG      DC    CL44' '\n         DC    CL89' '\n         SPACE 2\n*        DCB'S  FOR FILES\n*\n* ------ DCB'S                    ------------------------------------\n         SPACE 1                                                    RH\nDSNS     DCB   DSORG=PS,DDNAME=DSNS,MACRF=PM,RECFM=FB,              RH C\n               LRECL=80,EXLST=JFCBADD  ,BLKSIZE=6160                RH\nREPORT   DCB   DSORG=PS,DDNAME=SYSPRINT,LRECL=133,RECFM=FBA,        XXXX\n               MACRF=(PM),BLKSIZE=133\nSYSIN    DCB   DSORG=PS,DDNAME=SYSIN,LRECL=80,RECFM=FB,             XXXX\n               MACRF=(GL),EODAD=ENDBATCH\n         SPACE 1\n         SPACE 1\nJFCBADD  DS    0F\n         DC    X'87'              JFCB ADDRESS\n         DC    AL3(JFCB)\n         DS    0H                 PUT JFCB ON HALFWORD BOUNDARY\nJFCB     DS    0CL176' '\n         IEFJFCBN  LIST=NO\n         SPACE 1\nPARMLST2 DS    3F                 PARMLIST MAPPING\n         ORG   PARMLST2\nPARMWA   DC    A(WORKAREA)        ADDRESS OF 100-BYTE WORKAREA\nPARMDEVT DC    A(DEVCLASS)        ADDRESS OF BYTE CONTAINING\n*                                 THE DEVICE TYPE TO BE SEARCHED\nPARMUCB  DC    AL1(80)            ADDRESS OF WORD TO CONTAIN THE\n         DC    AL3(ADDRUCB)       THE UCB ADDRESS\n         SPACE 1\nDEVCLASS DC    XL1'20'            BYTE CONTAINING DEVICE CLASS\n*                                 TO BE SEARCHED FOR\n*                                 X'20' IS DIRECT ACCESS\nADDRUCB  DS    F                  WORD IN WHICH UCBSCAN WILL\n*                                 PLACE THE ADDRESS OF THE UCB\n         DS    0D                 ALIGN TO DOUBLE-WORD BOUNDARY\n*                                 THE WORKAREA FOR SCAN SERVICE\n*                                 MUST BE ON A DOUBLE-WORD BOUNDARY\nWORKAREA DS    CL100              WORKAREA\n         SPACE 1\n         LTORG\n         SPACE 1\n*\nCHECKPTR EQU  3\nCHECKPDE EQU  4\nUT2      EQU  2\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\n         PRINT NOGEN\n         DCBD  DSORG=(PS,PO),DEVD=DA\n         IKJCPPL\n         IKJPSCB\nLVLDX    DSECT\nLVLPTR   DS    A\nLVLLTH   DS    H\nLVLFLG   DS    BL2\nLVLNXT   DS    A\n*\n         END\n//LKED.SYSLMOD DD DSN=HALL.LINKLIB,DISP=SHR\n//LKED.SYSIN DD *\n    ENTRY GETDSNS\n    NAME  GETDSNS(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GETDSNSJ": {"ttr": 15879, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03?\\x00\\x99\\x03?\\x13$\\x00\\x19\\x00\\x19\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-02T00:00:00", "modifydate": "1999-02-02T13:24:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "RH87944"}, "text": "//GETDSNS  JOB\n//*\n//*     DSN=CBT.SOURCE(GETDSNSJ)\n//*\n//*\n/*ROUTE PRINT R7\n//*\n//*  IF    PARM='ALL' IS SPECIFIED, ALL INFO WILL BE SHOWN\n//*  IF    PARM='VOL' IS SPECIFIED, VOLSERS ARE PUT IN POSITION 1\n//*                                 AND THE DSNAME IN 37\n//*  IF    PARM='DISK' IS SPECIFIED, ONLY DATASETS ON DISK ARE LISTED\n//*\n//*                    ANY OTHER PARM IS ASSUMED TO BE THE HLI.\n//*\n//GETDSNS EXEC PGM=GETDSNS,REGION=80K PARM=ALL\n//STEPLIB  DD DSN=HALL.LINKLIB,DISP=SHR\n//*REPORT   DD SYSOUT=*\n//DSNS     DD SYSOUT=*     DSN LIST GOES IN HERE\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\nRH87944\nHALL.IMS\nIMSVS\nHALL.INPUT.CNTL\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HALLDUMP": {"ttr": 15881, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x13&\\x00\\xf5\\x00\\xf5\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T13:26:00", "lines": 245, "newlines": 245, "modlines": 0, "user": "RH87944"}, "text": "//HALLDUMP JOB\n/*ROUTE  PRINT  R7\n//*\n//*  DSN=CBT.SOURCE(HALLDUMP)\n//*\n//S1     EXEC  HLASMCL,PARMC='ESD',CLASS='*',PARML='AC=1',\n//   COND.LKED=(7,LT,ASM)\n//ASM.SYSLIB DD DSN=SYS1.MACLIB,DISP=SHR\n//   DD DSN=CBT.SOURCE,DISP=SHR             <====CHANGE\n//   DD DSN=SYS1.AMODGEN,DISP=SHR\n//ASM.SYSIN DD *\n*                                                                   RH\n*              MACRO TO DUMP CORE                                   RH\n*                                                                   RH\n         COPY  HDUMP                                                RH\n*                                                                   RH\n*              END OF MACRO                                  DEBUG  RH\n*                                                                   RH\n*                                                                   RH\n*                                                                   RH\n*              EXAMPLE OF JCL TO  USE HDUMP                         RH\n*                                                                   RH\n*        JCL MUST STEPLIB TO HALL.LINKLIB                           RH\n*                                                                   RH\n*                  THIS IS CODE TO DUMP CORE                 DEBUG  RH\n*        SPACE 4                                             DEBUG  RH\n*                                 DUMP 1024 BYTES AT R12     DEBUG  RH\n*        HDUMP OUTDCB,R12,1024,NOTOPEN,OPEN                  DEBUG  RH\n*        L     R3,DSSEJFCB        R3 -> TO JFCB              DEBUG  RH\n*                                 DUMP 1024 BYTES AT JFCB    DEBUG  RH\n*        HDUMP OUTDCB,R3,1024,OPEN,CLOSE                     DEBUG  RH\n*        HDUMP OUTDCB,0,0,TITLE='DUMP REGS ONLY'             DEBUG  RH\n*        SPACE 1                                             DEBUG  RH\n*                  THIS IS END OF CODE TO DUMP CORE          DEBUG  RH\n*                                                                   RH\n*\n* DUMP THE REGS AND SPECIFIED MEMORY LOCATIONS\n*\n* ON ENTRY:\n*    R1 = ADDR PASSED PARMS\n*       1) ADDR OF SAVED CALLERS REGS\n*       2) ADDR OF SYSPRINT DCB\n*       3) ADDR OF FIRST BYTE TO DUMP\n*       4) ADDR OF LAST BYTE (PLUS ONE) TO DUMP\n*       5) ADDR OF A TITLE, OR 0\n*                                                                   RH\n         EJECT                                                      RH\nHALLDUMP CSECT\nHALLDUMP AMODE 31\nHALLDUMP RMODE ANY\n         SPACE 2\n*\n* PERFORM STANDARD LINKAGE\n*\n         BSM   R14,0              SAVE CURRENT AMODE\n         PRINT NOGEN\n         STM   R14,R12,12(R13)         SAVE HIS REGS\n         USING HALLDUMP,R15            TEMP BASE ADDR\n         B     CONTINUE                BR AROUND MODULE NAME & DATE\n         DC    AL1(EYELTH)        LTH OF EYE CATCHER\nEYECATCH DC    CL8'HALLDUMP'           MODULE NAME\n         DC    CL8'&SYSDATE'           DATE ASSEMBLED\n         DC    CL8'&SYSTIME'           TIME ASSEMBLED\n         DC    C' VERSION 4...MAKE 31-BIT MODE  '\n*        DC    C' VERSION 3...ADDED TITLE OPTION'\nEYELTH   EQU   *-EYECATCH\n         DROP  R15                     RELEASE TEMP BASE REG\n         SPACE 1\nCONTINUE DS    0H\n         LR    R12,R15                 BASE REG\n         USING HALLDUMP,R12            EST. ADDR.\n         CNOP  0,4                     ALIGNMENT\n         BAL   R11,*+76                BR AROUND SAVE AREA\nSAVEAREA DS    18F                     SAVE AREA\n         ST    R13,4(0,R11)            HIS 4 PAST MINE\n         ST    R11,8(0,R13)            MINE 8 PAST HIS\n         LR    R13,R11                 ADDR MY SAVE AREA\n*\n* LOAD UP SOME  REGISTERS..\n*\n*                                 R1 -> TO PARMS                    RH\n         L     R5,0(0,R1)         R5 -> TO REG SAVE AREA\n         MVC   DUMPREGS(64),0(R5)  MOVE REGS TO WORK AREA\n         L     R2,4(0,R1)         R2 -> TO OUTPUT PRINT DCB\n         LM    R3,R5,8(R1)        R3 -> TO START ADDR TO DUMP\n*                                 R4 -> TO STOP ADDR TO DUMP\n*                                 R5 -> TO TITLE, IF ANY\n*\n* DUMP OUT THE TITLE IF THERE IS ONE...\n*\n         LTR   R5,R5              IS THERE A TITLE?\n         BZ    NOTITLE            NO\n         MVC   DUMPLINE+1(80),0(R5)  MOVE HEADING TO PRINT LINE\n         PUT   (R2),DUMPLINE      PRINT THE TITLE\n*\n* DUMP OUT THE VALUES OF THE REGISTERS\n*\nNOTITLE  DS    0H\n         MVC   DUMPRGLO(64),DUMPREGS COPY THE REGS\n         TR    DUMPREGS(64),DUMPTBHI  CONVERT HI ORDER DIGITS\n         TR    DUMPRGLO(64),DUMPTBLO   CONVERT LO ORDER DIGITS\n         MVC   DUMPLINE+1(10),DUMPREG0  LINE HEADING\n         MVC   DUMPLINE+11(72),DUMPSELR DIGITS TO SELECT\n         TR    DUMPLINE+11(72),DUMPREGS REG CONTENTS => O/P LINE\n         PUT   (R2),DUMPLINE           WRITE THE O/P LINE\n         MVC   DUMPLINE+1(10),DUMPREG8  LINE HEADING\n         MVC   DUMPLINE+11(72),DUMPSELR DIGITS TO SELECT\n         TR    DUMPLINE+11(72),DUMPREGS+32 REG CONTENTS => O/P LINE\n         PUT   (R2),DUMPLINE           WRITE THE O/P LINE\n         MVI   DUMPLINE,C'0'      DOUBLE SPACE NEXT LINE\n*\n* DUMP THE DATA FROM THE SPECIFIED STORAGE AREA\n*\n         MVI   DUMPLINE+85,X'5C'       DELIMETER OF CHARS\n         MVI   DUMPLINE+118,X'5C'      DELIMETER OF CHARS\n         LTR   R5,R3                   STARTING ADDR\n         BZ    DUMPEND            IF START = 0, END OF DUMP\n         SRL   R3,5                    ROUND ADDR TO ...\n         SLL   R3,5                    ... A MULTIPLE OF 32\n* COMPUTE NUMBER BYTES TO BLANK OUT\n         SR    R5,R3                   # BYTES TO BLANK\n         LR    R7,R5              # BYTES TO BLANK ON RIGHT SIDE...\n         SLL   R5,1                    DOUBLE THE NUMBER\n         LR    R6,R5                   SAVE THIS VALUE\n         SRL   R6,3                    # ADD'NL BLANKS\n         AR    R5,R6                   SUBTOTAL # BLANK BYTES\n         SRL   R6,2                    # ADD'NL DOUBLE BLANKS\n         AR    R5,R6                   TOTAL # BLANKS\nDUMPRINT EQU   *\n         MVC   DUMPDATA(32),0(R3)      GET DATA TO TRANSLATE\n         MVC   DUMPDALO(32),0(R3)      GET DATA TO TRNASLATE\n         TR    DUMPDATA(32),DUMPTBHI   CONVERT HO ORDER HEX\n         TR    DUMPDALO(32),DUMPTBLO   CONVERT LO ORDER HEX\n         ST    R3,DUMPADHI             SAVE STARTING ADDR\n         ST    R3,DUMPADLO             SAVE STARTING ADDR\n         TR    DUMPADHI(4),DUMPTBHI    CONVERT HI OEDER HEX\n         TR    DUMPADLO(4),DUMPTBLO    CONVERT LO ORDER HEX\n         MVC   DUMPLINE+1(8),DUMPSELA  HEX DIGIT SELECT PATTERN\n         TR    DUMPLINE+1(8),DUMPADHI  SELECT THE HEX DIGITS\n         MVC   DUMPLINE+11(72),DUMPSELD DIGITS TO SELECT\n         TR    DUMPLINE+11(72),DUMPDATA DATA => O/P LINE\n         MVC   DUMPLINE+86(32),0(R3)   DATA BEING DUMPED\n         LTR   R5,R5                   ANY BLANKS ?\n         BZ    DUMPNXT1                NO, SKIP IT\n         BCTR  R5,0                    REAL LEN FOR MOVE\n         EX    R5,DUMPMVC              MOVE IN THE BLANKS\n*        SRL   R5,2               NBR OF BLANKS ON RIGHT SIDE....\n         BCTR  R7,0                    REAL LEN FOR MOVE\n         EX    R7,DUMPMVC2             MOVE IN THE BLANKS\n         SLR   R5,R5                   NO BLANKS !\nDUMPNXT1 EQU   *\n         PUT   (R2),DUMPLINE           WRITE THE O/P LINE\nDUMPEND  DS    0H\n         MVI   DUMPLINE,C' '           SINGLE SPACE\n         LA    R3,32(0,R3)             PT @ NEXT DATUM\n         CR    R3,R4                   DATA EXHAUSTED ?\n         BL    DUMPRINT                NO, CONTINUE PROCESSING IT\n*\n* PRINT END OF DUMP SEPARATOR\n*\n         MVI   DUMPLINE,X'F0'          DOUBLE SPACE\n         MVI   DUMPLINE+1,X'5C'        SET THE O/P LINE ...\n         MVC   DUMPLINE+2(131),DUMPLINE+1  ... TO ASTERISKS\n         PUT   (R2),DUMPLINE           WRITE THE O/P LINE\n         MVI   DUMPLINE,X'40'          SINGLE SPACE\n         MVC   DUMPLINE+1(132),DUMPLINE  CLR O/P LINE TO BLANKS\n         PUT   (R2),DUMPLINE           WRITE THE O/P LINE\n*\n* GET BACK TO THE CALLING ROUTINE\n*\n         L     R13,4(0,R13)            ADDR HIS SAVE AREA\n         LM    R14,R12,12(R13)         RESTORE HIS REGS\n*              GET INTO PROPER MODE AND GO BACK TO CALLER\n         BSM   0,R14              RETURN TO CALLING PROGRAM\n*        BR    R14                     RETURN TO HIM\n*\n* DEFINE STORAGE\n*\nDUMPMVC  MVC   DUMPLINE+11(1),DUMPBLNK\nDUMPMVC2 MVC   DUMPLINE+86(1),DUMPBLNK\nDUMPREGS DS    16F\nDUMPRGLO DS    16F\nDUMPBLNK DC    CL80' '\nDUMPREG0 DC    CL10'  R0-R7   '\nDUMPREG8 DC    CL10'  R8-R15  '\nDUMPDATA DS    8F\nDUMPDALO DS    8F\nDUMPBLK2 DC    CL8' '\nDUMPADHI DS    F\nDUMPADLO DS    F\nDUMPTBHI DC    16X'F0'\n         DC    16X'F1'\n         DC    16X'F2'\n         DC    16X'F3'\n         DC    16X'F4'\n         DC    16X'F5'\n         DC    16X'F6'\n         DC    16X'F7'\n         DC    16X'F8'\n         DC    16X'F9'\n         DC    16X'C1'\n         DC    16X'C2'\n         DC    16X'C3'\n         DC    16X'C4'\n         DC    16X'C5'\n         DC    16X'C6'\nDUMPTBLO DC    16X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\nDUMPSELR DC    X'00400141024203438004440545064607'\n         DC    X'4780084809490A4A0B4B800C4C0D4D0E'\n         DC    X'4E0F4F80801050115112521353801454'\n         DC    X'15551656175780185819591A5A1B5B80'\n         DC    X'1C5C1D5D1E5E1F5F'\nDUMPSELD DC    X'00200121022203234004240525062607'\n         DC    X'2740082809290A2A0B2B400C2C0D2D0E'\n         DC    X'2E0F2F40401030113112321333401434'\n         DC    X'15351636173740183819391A3A1B3B40'\n         DC    X'1C3C1D3D1E3E1F3F'\nDUMPSELA DC    X'0004010502060307'\nDUMPLINE DC    C' '\n         DC    CL132' '\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n//LKED.SYSLMOD DD DSN=IMSVS.AUTHLIB5(HALLDUMP),DISP=SHR\n//LKED.SYSIN DD *\n    SETCODE AC(0)\n    MODE AMODE(31) RMODE(ANY)\n    NAME HALLDUMP(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HDUMP": {"ttr": 16129, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x13'\\x00\\xd3\\x00\\xd3\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T13:27:00", "lines": 211, "newlines": 211, "modlines": 0, "user": "RH87944"}, "text": "******************************************************************* RH\n*                                                                   RH\n*              MACRO TO DUMP CORE                                   RH\n*              REMEMBER TO STEPLIB TO HALL.LINKLIB FOR HALLDUMP     RH\n*              IF YOU USE AN EXISTING DCB, IT SHOULD BE             RH\n*              RECFM=FBA,LRECL=133.                                 RH\n*                                                                   RH\n         MACRO                                                      RH\n&L       HDUMP &DCB,&START,&STOP,&DISPO,&DISPC,&V=NO,&TITLE=,       RH +\n               &GENDCB=YES                                          RH\n         GBLA  &N                                                   RH\n         GBLC  &L0,&L1,&L2,&L3,&L4,&L5,&L6                          RH\n.*&N     SETA  1                                                    RH\n.*                                                                  RH\n.******* ***** ****************** ********************************* RH\n.*                                                                  RH\n.*       HDUMP IS USED TO DYNAMICALLY DUMP CORE IN A PROGRAM        RH\n.*             &DCB   IS THE NAME FOR THE SYSOUT DCB                RH\n.*             &START IS A REGISTER CONTAINING THE ADDRESS TO DUMP, RH\n.*                    OR 0 TO DUMP JUST THE REGISTERS               RH\n.*             &STOP  IS THE LENGTH TO DUMP, MAX IS 4095,           RH\n.*                    OR 0 TO DUMP JUST THE REGISTERS               RH\n.*             &DISPO IS THE DISPOSITION OF THE DUMP DCB            RH\n.*             &DISPC IS THE DISPOSITION AT THE END OF THE MACRO    RH\n.*             &V=YES WILL GENERATE A CONTROL BLOCK SET(EXCEPT DCB) RH\n.*                    EVERY TIME THE MACRO IS CALLED                RH\n.*             &TITLE IS A TITLE TO BE PRINTED BEFORE THE DUMP      RH\n.*         &GENDCB=NO WILL USE THE EXISTING &DCB                    RH\n.*                                                                  RH\n.*       AN EXAMPLE USAGE WOULD BE:                                 RH\n.*                                                                  RH\n.*       1)    DUMP 1024 BYTES STARTING AT MESSAGES. (A DCB)        RH\n.*             THE 'OUTDCB' FILE IS NOT OPEN, AND SHOULD BE LEFT    RH\n.*             OPEN AT END OF THE MACRO.                            RH\n.*                                                                  RH\n.*       LA    R3,MESSAGES        R3 = ADDRESS TO DUMP       DEBUG  RH\n.*       HDUMP OUTDCB,R3,1024,NOTOPEN,OPEN                   DEBUG  RH\n.*       ...                                                        RH\n.*       ...   MORE OF YOUR CODE                                    RH\n.*       ...                                                        RH\n.*                                                                  RH\n.*       2)    DUMP 1024 BYTES STARTING AT THE ADDRESS STORED       RH\n.*             AT MESSAGES+44. (A DEB)                              RH\n.*             THE 'OUTDCB' FILE IS OPEN, AND SHOULD BE CLOSED      RH\n.*             AT END OF THE MACRO.                                 RH\n.*                                                                  RH\n.*       L     R3,MESSAGES+44     R3 -> TO DEB               DEBUG  RH\n.*       HDUMP OUTDCB,R3,1024,OPEN,CLOSE                     DEBUG  RH\n.*                                                                  RH\n.******* ***** ****************** ********************************* RH\n.*                                                                  RH\n         AIF   (&STOP LT 4096).STOPOK                               RH\n         MNOTE 'STOP MUST BE LESS THAN 4096'                        RH\n         MEXIT                                                      RH\n.STOPOK  ANOP                                                       RH\n.*       AIF   (&N EQ 1).FRST                                       RH\n         AIF   (&N EQ 0).FRST                                       RH\n         AIF   ('&V' EQ 'NO').NDC1                                  RH\n.FRST    ANOP                                                       RH\n&L0      SETC  'SREG&SYSNDX'                                        RH\n&L1      SETC  'HREG&SYSNDX'                                        RH\n&L2      SETC  'REGA&SYSNDX'                                        RH\n&L3      SETC  'DCBA&SYSNDX'                                        RH\n&L4      SETC  'STRT&SYSNDX'                                        RH\n&L5      SETC  'STPA&SYSNDX'                                        RH\n&L6      SETC  'TITL&SYSNDX'                                        RH\n         AIF   (&N GT 1).LBL2                                       RH\n*&L      B     BPAS&SYSNDX                                   DEBUG  RH\n&L       B     LOADHDMP                                      DEBUG  RH\n         AGO   .LBL9                                         DEBUG  RH\n.LBL2    ANOP                                                DEBUG  RH\n&L       B     HDMP&SYSNDX                                   DEBUG  RH\n.LBL9    ANOP                                                DEBUG  RH\n         SPACE 1                                             DEBUG  RH\n&L0      DC    18F'-1'            SAVE AREA FOR HALLDUMP RTN DEBUG  RH\n&L1      DC    16F'-1'            SAVE AREA FOR CALLERS REGS DEBUG  RH\n&L2      DC    A(&L1)             ADDRESS OF CALLERS REGS    DEBUG  RH\n&L3      DC    A(&DCB)            ADDRESS OF OUTPUT DCB      DEBUG  RH\n&L4      DC    A(0)               ADDRESS OF START OF DUMP   DEBUG  RH\n&L5      DC    A(0)               ADDRESS OF END OF DUMP     DEBUG  RH\n&L6      DC    A(0)               ADDRESS OF TITLE           DEBUG  RH\n         AIF   (&N GT 1).NDC1                                DEBUG  RH\n         ENTRY DMPRADDR                                      DEBUG  RH\nDMPRADDR DC    F'0'               DUMP FORMATTER ADDRESS     DEBUG  RH\n         AIF   ('&GENDCB' EQ 'NO').NODCB                            RH\n         ENTRY &DCB                                          DEBUG  RH\n*&DCB    DCB   DDNAME=SYSOUT,RECFM=FBA,LRECL=133,BLKSIZE=3990,      RHXX\n               DSORG=PS,MACRF=(PM)                           DEBUG  RH\n&DCB     DCB   DDNAME=&DCB,RECFM=FBA,LRECL=133,BLKSIZE=3990,        RHXX\n               DSORG=PS,MACRF=(PM)                           DEBUG  RH\n.NODCB   ANOP                                                DEBUG  RH\n         SPACE 1                                             DEBUG  RH\n*PAS&SYSNDX DS    0H                                         DEBUG  RH\nLOADHDMP DS       0H                                         DEBUG  RH\n         STM   0,15,&L1           SAVE CALLERS REGS          DEBUG  RH\n         L     1,=V(DMPRADDR)     R1 -> TO DUMPER CODE       DEBUG  RH\n         ICM   1,15,0(1)          IS DUMP FORMATTER LOADED?  DEBUG  RH\n         BNZ   LOADHEND           YES                        DEBUG  RH\n         BLDL  0,BLDLLIST         FIND HALLDUMP              DEBUG  RH\n         BLDL  0,BLDLLIST         FIND HALLDUMP              DEBUG  RH\n         LTR   R15,R15            DID WE FIND IT?            DEBUG  RH\n         BZ    BLDLOK             YES, GO LOAD IT            DEBUG  RH\n         DC    H'0'               NO, ABEND                  DEBUG  RH\n*        BNZ   LOADHEND           NO, DON'T TRY TO LOAD IT   DEBUG  RH\nBLDLOK   DS    0H                 ALIGN ON HALFWORD...       DEBUG  RH\n*        LOAD  EP=HALLDUMP        LOAD DUMP FORMATTER        DEBUG  RH\n         LA    0,DUMPPGM          R0 -> TO DUMP PGM NAME     DEBUG  RH\n         LOAD  EPLOC=(0)          LOAD DUMP FORMATTER        DEBUG  RH\n         LTR   R15,R15            DID WE LOAD IT?            DEBUG  RH\n         BZ    LOADOK             YES, GO SAVE IT            DEBUG  RH\n         DC    H'0'               NO, ABEND                  DEBUG  RH\nLOADOK   DS    0H                 ALIGN ON HALFWORD...       DEBUG  RH\n         L     R15,=V(DMPRADDR)   R15 -> TO DUMPER CODE      DEBUG  RH\n         ST    0,0(0,R15)         SAVE IT                    DEBUG  RH\n         B     LOADHEND           ON WE GO                   DEBUG  RH\n*                                                            DEBUG  RH\n         ENTRY BLDLLIST,DUMPPGM                              DEBUG  RH\nBLDLLIST DS    0H                 ALIGN ON HALFWORD...       DEBUG  RH\n         DC    H'1'               ONE NAME TO FIND           DEBUG  RH\n         DC    H'12'              LTH OF ENTRY               DEBUG  RH\nDUMPPGM  DC    CL8'HALLDUMP'      NAME OF DUMP PGM           DEBUG  RH\n         DC    AL4(0)             TTR, AND K FIELD           DEBUG  RH\n*                                                            DEBUG  RH\n         SPACE 1                                             DEBUG  RH\nLOADHEND DS    0H                                            DEBUG  RH\n         LM    0,15,&L1           RELOAD CALLERS REGS        DEBUG  RH\n.NDC1    ANOP                                                DEBUG  RH\n         SPACE 1                                             DEBUG  RH\n*PAS&SYSNDX DS    0H                                         DEBUG  RH\nHDMP&SYSNDX DS    0H                                         DEBUG  RH\n         STM   0,15,&L1           SAVE CALLERS REGS          DEBUG  RH\n*        LR    15,&START          R15 -> TO START ADDRESS    DEBUG  RH\n         AIF   ('&START'(1,1) LT '0').STARTR1                       RH\n         LA    15,0               R15 = 0 IF DUMP ONLY REGS  DEBUG  RH\n         AGO   .STARTR9\n.STARTR1 ANOP                                                DEBUG  RH\n         LR    15,&START          R15 -> TO START ADDRESS    DEBUG  RH\n.STARTR9 ANOP                                                DEBUG  RH\n         ST    15,&L4             SAVE IT                    DEBUG  RH\n         LA    15,&STOP.(0,15)    R15 -> TO STOP ADDRESS     DEBUG  RH\n         ST    15,&L5             SAVE IT                    DEBUG  RH\n         AIF   ('&TITLE' EQ '').NTTL                         DEBUG  RH\n         LA    15,=CL80&TITLE     R15 -> TO TITLE            DEBUG  RH\n         ST    15,&L6             SAVE IT                    DEBUG  RH\n.NTTL    ANOP                                                DEBUG  RH\n         LA    13,&L0             GIVE HALLDUMP ITS OWN SA   DEBUG  RH\n         AIF   (&N GT 1).NDC2                                DEBUG  RH\n&N       SETA  2                                             DEBUG  RH\n         L     2,=V(&DCB)         R2 -> TO OUTPUT DCB        DEBUG  RH\n         ST    2,&L3              SAVE IT                    DEBUG  RH\n         AGO   .NDC3                                                RH\n.NDC2    ANOP                                                DEBUG  RH\n         SPACE 1                                             DEBUG  RH\n         L     2,=V(&DCB)         R2 -> TO OUTPUT DCB        DEBUG  RH\n         ST    2,&L3              SAVE IT                    DEBUG  RH\n         AIF   ('&DISPO' EQ '').NDC3                                RH\n         AIF   ('&DISPO' EQ 'OPEN').NDC4                            RH\n.NDC3    ANOP                                                       RH\n         TM    48(2),X'10'        IS DEBUG FILE OPEN ?       DEBUG  RH\n         BO    OPEN&SYSNDX        YES, DON'T OPEN IT AGAIN   DEBUG  RH\n*        OPEN  ((2),(OUTPUT)),MODE=31                        DEBUG  RH\n         OPEN  ((2),(OUTPUT)),MODE=31                        DEBUG  RH\n         SPACE 1                                             DEBUG  RH\nOPEN&SYSNDX DS 0H                                            DEBUG  RH\n         L     R15,=V(DMPRADDR)   R15 -> TO DUMPER CODE      DEBUG  RH\n         ICM   1,15,0(R15)        IS DUMP FORMATTER LOADED?  DEBUG  RH\n         BNZ   LOAD&SYSNDX        YES                        DEBUG  RH\n*        AGO   .NOLOAD\n*        BLDL  0,BLDLLIST         FIND HALLDUMP              DEBUG  RH\n         L     0,=V(BLDLLIST)     R0 -> AT BLDL LIST         DEBUG  RH\n         BLDL  0,(0)              FIND HALLDUMP              DEBUG  RH\n         LTR   R15,R15            DID WE FIND IT?            DEBUG  RH\n         BNZ   LOAD&SYSNDX .      NO, DON'T TRY TO LOAD IT   DEBUG  RH\n*        LOAD  EP=HALLDUMP        LOAD DUMP FORMATTER        DEBUG  RH\n*        LA    0,DUMPPGM          R0 -> TO DUMP PGM NAME     DEBUG  RH\n         L     0,=V(DUMPPGM)      R0 -> TO DUMP PGM NAME     DEBUG  RH\n         LOAD  EPLOC=(0)          LOAD DUMP FORMATTER        DEBUG  RH\n         L     R15,=V(DMPRADDR)   R15 -> TO DUMPER CODE      DEBUG  RH\n         ST    0,0(0,R15)         SAVE IT                    DEBUG  RH\n         B     LOAD&SYSNDX .      ON WE GO                   DEBUG  RH\n*LDLLIST DS    0H                 ALIGN ON HALFWORD...       DEBUG  RH\n*        DC    H'1'               ONE NAME TO FIND           DEBUG  RH\n*        DC    H'12'              LTH OF ENTRY               DEBUG  RH\n*UMPPGM  DC    CL8'HALLDUMP'      NAME OF DUMP PGM           DEBUG  RH\n*        DC    AL4(0)             TTR, AND K FIELD           DEBUG  RH\n*                                                            DEBUG  RH\n.NOLOAD  ANOP                                                DEBUG  RH\n         SPACE 1                                             DEBUG  RH\nLOAD&SYSNDX DS 0H                                            DEBUG  RH\n.NDC4    ANOP                                                       RH\n         TM    48(2),X'10'        IS DEBUG FILE OPEN ?       DEBUG  RH\n         BZ    DBUG&SYSNDX        NO                         DEBUG  RH\n         LA    1,&L2              R1 -> TO PARM LIST         DEBUG  RH\n*        ICM   15,15,=V(HALLDUMP) R15 -> TO DUMP ROUTINE     DEBUG  RH\n         L     R15,=V(DMPRADDR)   R15 -> TO DUMPER CODE      DEBUG  RH\n         ICM   15,15,0(R15)       R15 -> TO DUMP ROUTINE     DEBUG  RH\n         BZ    DBUG&SYSNDX        NO, DUMP ROUTINE, EXIT     DEBUG  RH\n         BALR  14,15              GO TO IT                   DEBUG  RH\n         AIF   ('&DISPC' EQ '').NDC5                                RH\n         AIF   ('&DISPC' EQ 'OPEN').NDC6                            RH\n.NDC5    ANOP                                                       RH\n*        CLOSE ((2)),MODE=31      CLOSE THE O/P FILE         DEBUG  RH\n         CLOSE ((2)),MODE=31      CLOSE THE O/P FILE         DEBUG  RH\n.NDC6    ANOP                                                       RH\n         SPACE 1                                             DEBUG  RH\nDBUG&SYSNDX DS    0H                                         DEBUG  RH\n         LM    0,15,&L1           RELOAD CALLERS REGS        DEBUG  RH\n         MEND                                                       RH\n*                                                                   RH\n*              END OF MACRO                                  DEBUG  RH\n*                                                                   RH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HLASMC": {"ttr": 16134, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x04/\\x00\\x99\\x04/\\x13\\x01\\x00\\x1e\\x00\\x1e\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-11T00:00:00", "modifydate": "1999-02-11T13:01:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "RH87944"}, "text": "//HLASMC  PROC CLASS=$,\n//             MAC='SYS1.MACLIB',\n//             MAC1='SYS1.MACLIB',\n//             PARMC=,\n//             UNIT=VIO\n//*\n//***   HLASMC\n//*\n//* THIS PROCEDURE RUNS THE HIGH LEVEL ASSEMBLER AND CAN BE USED\n//* TO ASSEMBLE PROGRAMS.\n//*\n//ASM     EXEC PGM=ASMA90,\n//             PARM='&PARMC',\n//             REGION=1024K\n//SYSLIB   DD  DISP=SHR,\n//             DSN=&MAC\n//         DD  DISP=SHR,\n//             DSN=&MAC1\n//SYSLIN   DD  DCB=(BLKSIZE=3040,BUFNO=1,LRECL=80,RECFM=FBS),\n//             DISP=(MOD,PASS),\n//             DSN=&&LOADSET,\n//             SPACE=(CYL,(5,5)),\n//             UNIT=&UNIT\n//SYSPRINT DD  DCB=BLKSIZE=3509,\n//             SYSOUT=&CLASS\n//SYSPUNCH DD  SYSOUT=B\n//SYSUT1   DD  DISP=(NEW,DELETE),\n//             DSN=&&SYSUT1,\n//             SPACE=(1700,(600,100)),\n//             UNIT=&UNIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HLASMCL": {"ttr": 16136, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x04/\\x00\\x99\\x04/\\x13\\x01\\x00+\\x00+\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-11T00:00:00", "modifydate": "1999-02-11T13:01:00", "lines": 43, "newlines": 43, "modlines": 0, "user": "RH87944"}, "text": "//HLASMCL PROC CLASS=$,\n//             MAC='SYS1.MACLIB',\n//             MAC1='SYS1.MACLIB',\n//             PARMC=,\n//             PARML=,\n//             UNIT=VIO\n//*\n//***   HLASMCL\n//*\n//* THIS PROCEDURE RUNS THE HIGH LEVEL ASSEMBLER, LINK-EDITS THE\n//* NEWLY ASSEMBLED PROGRAM.\n//*\n//ASM     EXEC PGM=ASMA90,\n//             PARM='&PARMC',\n//             REGION=1024K\n//SYSLIB   DD  DISP=SHR,\n//             DSN=&MAC\n//         DD  DISP=SHR,\n//             DSN=&MAC1\n//SYSLIN   DD  DCB=(BLKSIZE=3040,BUFNO=1,LRECL=80,RECFM=FBS),\n//             DISP=(MOD,PASS),\n//             DSN=&&LOADSET,\n//             SPACE=(CYL,(5,5)),\n//             UNIT=&UNIT\n//SYSPRINT DD  DCB=BLKSIZE=3509,\n//             SYSOUT=&CLASS\n//SYSPUNCH DD  SYSOUT=B\n//SYSUT1   DD  DISP=(NEW,DELETE),\n//             DSN=&&SYSUT1,\n//             SPACE=(1700,(600,100)),\n//             UNIT=&UNIT\n//LKED    EXEC PGM=IEWL,\n//             COND=(7,LT,ASM),\n//             PARM='LET,LIST=SUMMARY,MAP,NCAL,XREF,&PARML'\n//SYSLIN   DD  DISP=(OLD,DELETE),\n//             DSN=&&LOADSET\n//         DD  DDNAME=SYSIN\n//SYSPRINT DD  DCB=(BLKSIZE=3509,RECFM=FB),\n//             SYSOUT=&CLASS\n//SYSUT1   DD  DISP=(NEW,DELETE),\n//             DSN=&&SYSUT1,\n//             SPACE=(1024,(50,20)),\n//             UNIT=&UNIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HOWBACK": {"ttr": 16138, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x13(\\x03\\x10\\x03\\x10\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T13:28:00", "lines": 784, "newlines": 784, "modlines": 0, "user": "RH87944"}, "text": ".cm this is documentation for BACKDSNS.\n.HY OFF;\n.dc cont off\n.pl 64      11.00i for page length\n.tm 2       0.33i\n.bm 4       0.66i  for page printers, not line printers\n.ll 72      7.20i\n.dc cont off\n:gdoc sec='BACKDSNS Users Guide.'\n:frontm.\n:titlep.\n:title.BACKDSNS Users Guide\n:docnum.\n:date.&date\n:author.Randy Hall\n:author.1151 Palmer Rd,\n:author.Victoria, B.C.\n:address.\n:aline.Distribution List:\n:aline.Anybody who wants it\n:aline.Randy Hall\n:eaddress.\n:etitlep.\n:toc.\n:body.\n.tm 3\n.bm 1\n.hy off;\n.fo off\n:h1        Preface\n\n      This publication,   the BACKDSNS REFERENCE MANUAL,  8th          |\n      edition, October, 1998, describes how to use the BACKDSNS        |\n      dataset backup/restore utility program.\n\n      This publication is provided by Diversified Developmemts to\n      users of the  BACKDSNS dataset backup/restore utility program.\n\n      Changes to this manual are indicated with a solid bar (|) on     |\n      the outside edge of the changed line.                            |\n\n:h1.Modification Log\n.bx 1 9 23 75\n:hp2.\n Rev no.     Date      Description of Revision  :ehp2.\n.bx\n   08     Oct    1998  Eighth issue ...Because of DFSMSRMM, the        |\n                       SYSUT2 dsn will again be used to create the     |\n                       backup dataset names. The name on tape will     |\n                       be the SYSUT2 DSN= with F001, F002, etc.        |\n                       added to the end to make a unique name. If      |\n                       the SYSUT2 dsn is too long, it will be          |\n                       shortened until it is valid.                    |\n                       The layout of the //RESTORE record had to be    |\n                       increased because of this.                      |\n.bx\n   07     Aug    1997..Seventh issue ...Added 'IEBCOPY' parm to\n                       force use of IEBCOPY, not PDSFAST, as PDSFAST\n                       doesn't work under Y2K...\n                       Use //STEPLIB of IMSVS.AUTHLIB1 rather than\n                       HALL.LINKLIB to avoid IEBCOPY error messages.\n                     ..If a //OUTDCB as well as a //DEBUG dd is used,\n                       a dump of DCB's and JFCB's will occur.\n.bx\n   06     Sept   1996  Sixth issue ...documentation revision with\n                       information on cataloging the 1st file.\n                       See JCL COMMENTS for SYSUT2..\n                       Also add more documentation on PARMs...\n.bx\n   05     June   1996  Fifth issue ...This revision uses the SYSUT2\n                       DD information to create the first file on\n                       the tape. This was necessary to use expiry\n                       dates after system changes sometime before\n                       June, 1996. The DSN can now be used to catalog\n                       the backup tape. Also, the DSN must be a valid\n                       dataset name. NONE is no longer valid if RACF\n                       does dsn checking. The SYSUT2 dsn will no longer\n                       be used to create the backup dataset names. The\n                       name on tape will be the same as the disk file\n                       name.\n                       There is no FILE 0001 in the //REPORT listing.\n                       It is now a control dataset created from the\n                       //SYSUT2 jcl parameters.\n.bx off\n.pa\n:h2.MODIFICATION LOG, continued...\n.bx 1 9 23 72\n:hp2.\n Rev no.     Date      Description of Revision  :ehp2.\n.bx\n   04     Feb    1990  Fourth issue ...This is a major revision\n                       that handles multi-volume tape datasets, and\n                       allows a parm to specify UNIT= and VOL=\n                       for RESTORES.\n.bx\n   03     Feb    1990  Third issue ...This is a major revision\n                       that includes documentation on the NEW\n                       RESTORE option.\n.bx\n   02     June   1989  Second issue ...DSN=NONE and //RESTORE\n.bx\n   01     Feb    1989  First issue\n.bx off\n:h1.Copyright\n                         Copyright 1989-1998 by                        |\n                       Diversified Developments,\n                          1151 Palmer Road,\n                            Victoria, B.C.\n                              V8P 2H5\n\n                          All Rights Reserved\n\n                              8th Edition                              |\n                              October, 1998                            |\n\n\n                         Questions or comments?\n            E-mail to randy.hall@i.am or randy.hall@usa.net\n\n:h1.       Introduction\n\n The program BACKDSNS is used to backup datasets to tape, based on\n the dataset names contained in the //DSNS control stream.\n\n The program BACKDSNS is used to restore datasets from tape,\n based on the dataset names contained in the //DSNS control stream.\n\n BACKDSNS is written using standard IBM macros, and should run on\n any IBM mainframe running MVS software in 24 bit mode with RACF\n installed.\n Any IBM compatible disk or tape drive should be accessible.\n\n\n SEQUENTIAL datasets are copied using QSAM.\n            IEBGENER could be used to restore these datasets.\n\n PARTITIONED datasets are copied using PDSFAST.\n            PDSFAST could be used to restore these datasets.\n\n DIRECT access datasets are copied sequentially using QSAM.\n            A BDAM load program would have to be used to\n            restore these datasets.\n\n VSAM datasets are copied using IDCAMS EXPORT TEMPORARY.\n            IDCAMS IMPORT could be used to restore these datasets.\n\n\n\n IEBGENER and IDCAMS are IBM utility programs.\n RACF is an IBM security system.\n PDSFAST is a Software Engineering of America utility program.\n\n\n\n\n:h1. Program Description\nBACKDSNS reads a dataset name from //DSNS to determine what dataset\nto copy to the //SYSUT2 output tape.\n\nThe dataset is dynamically allocated to //SYSUT1 and is checked to see\nif it is empty and if RACF will allow read access.\n\nSelected datasets are copied to tape and a listing is produced showing\nthe disk dataset name, tape file number, tape volume serial number(s),\nand tape dataset name for each disk dataset backed up.\n\nAn optional //RESTORE dataset can be produced showing the disk dataset\nname, dataset type, tape volume serial number(s), tape file sequence\nnumber, dcb information, disk volume, and tape dataset name.           |\nThe primary purpose of this file is to contain information needed to\nrestore the dataset.\n\nNote that from version 5 up, the first dataset is not shown in the     |\n//RESTORE file, as it is now used just for system information.\n\n\nIf this is a RESTORE operation, the data in //DSNS must be the data\ncreated in the //RESTORE dataset in the backup job.\nIf the dataset does not exist, a new one will be created based on the\nrestore information.\nIf the dataset is a PDS, the directory will be erased before the copy\nis done.\nDIRECT access (BDAM) datasets CANNOT be restored with BACKDSNS. They\nMUST be restored using a program specifically designed for the data.\n\n\nThe //SYSUT2 DCB attributes are set as follows:\n\n SEQUENTIAL datasets:\n            BLKSIZE = SYSUT1 blksize\n              LRECL = SYSUT1 lrecl\n              RECFM = SYSUT1 recfm\n\n PARTITIONED datasets:\n    PDSFAST BLKSIZE = 19089\n              LRECL = 19085\n              RECFM = VS\n\n DIRECT access datasets:\n            BLKSIZE = SYSUT1 blksize or 32767 if blksize=0\n              LRECL = SYSUT1 lrecl or blksize if lrecl=0\n              RECFM = SYSUT1 recfm or U if no sysut1 recfm\n\n:h2. PROGRAM DESCRIPTION, continued...\n VSAM datasets:\n     EXPORT BLKSIZE = 23220\n              LRECL = 516\n              RECFM = VBS\n\nFor a more detailed description of the above DCB attributes, see the\nIBM JCL manual.\n\nIf SYSUT2 becomes a multi-volume file, check the JOBLOG as well as\nthe REPORT file to make sure you have the volume serial numbers of\nall the tapes used to backup/restore the disk datasets.\n\n\n:h1. Program Parameters\n\nBACKDSNS allows the following parameters:\n\n    IEBCOPY...Use IEBCOPY, not PDSFAST to copy partitioned datasets.\n              As of August 12, 1997, our version of PDSFAST cannot\n              copy tapes created under the current date to a Y2K date.\n              Use //STEPLIB of IMSVS.AUTHLIB1 rather than\n              HALL.LINKLIB to avoid IEBCOPY error messages.\n\n    RESTORE...This tells BACKDSNS that this is a restore run.\n\n       VOL=...For a RESTORE run, all datasets that do not already\n              exist will be allocated on the specified volume(s).\n              Up to 4 volumes can be specified, as VOL=(v1,v2...).\n\n      UNIT=...For a RESTORE run, all datasets that do not already\n              exist will be allocated to the specified UNIT.\n              The default is UNIT=SYSDA.\n\n       KEEP...For a RESTORE run, all datasets created during a\n              RESTORE will not be cataloged.\n\n      ALLOC...When gathering size statistics, use allocated space,\n              not used space.\n\n     TUNIT=...For a RESTORE run, specify tape unit\n              The default is TUNIT=TAPE.\n\n:h1. Backup Jcl Example\n\nThe following JCL is required to run BACKDSNS to backup files:\n\n//*\n//*    backup datasets to tape\n//*\n//BACKDSNS EXEC PGM=BACKDSNS,REGION=4000K\n//STEPLIB  DD DSN=HALL.LINKLIB,DISP=SHR\n//REPORT   DD SYSOUT=*               FOR AUDIT TRAIL\n//SYSPRINT DD SYSOUT=*               FOR PDSFAST/COPY\n//SYSABEND DD SYSOUT=*               for a dump, if needed\n//DEBUG    DD SYSOUT=*               for an internal module trace\n//OUTDCB   DD SYSOUT=*               for a DCB/JFCB trace\n//RESTORE  DD DSN=hli.RESTORE,       for a list of DSNS\n//            DISP=SHR                    LRECL must be 200            |\n//SYSUT2   DD DSN=hli.BACKUP,\n//            UNIT=(TAPE,,DEFER),\n//            DISP=(,KEEP),LABEL=(1,SL,RETPD=nnn),\n   and one of....\n//            VOL=(,RETAIN)          for a new scratch tape, or...\n//            VOL=(,RETAIN,SER=xxxxxx)    for a specific volser, or...\n//            VOL=(,RETAIN,REF=*.STEP1.SYSUT2)  to refer to a prev step\n   plus....\n//SYSIN    DD *\n COPY  I=SYSUT1,O=SYSUT2\n/*\n    or, if the control statement is in a dataset:\n//SYSIN    DD DSN=dsname,DISP=SHR\n//*\n        //DSNS is the list of dataset names to be backed up.....\n               The DSN starts in column 1, and if specified,\n               the VOLSER is in column 46.\n               An asterisk (*) in column 1 is a comment.               |\n\n\n//DSNS     DD *\n* THIS IS A COMMENT\nHALL.ATS2.TEXT                                      this is a pds\nHALL.BTSOUT                                         this is a seq dsn\nIMSRCF1V.HALL.ALECON                         IMST80 volser of catalog\n                                                    for vsam...\nHALL.MASTER                                         this is a da file\nHALL.AAAAAAAA.BBBBBBBB.CCCCCCCC.DDDDDDDD.EEE        max lth dsn\nHALL.TEST.VOLSER                             USR800 uncat'd dsn vol\n//\n\n:h1. Restore Jcl Example\n\nThe following JCL is required to run BACKDSNS to restore files:\n\n//*\n//*    restore datasets from tape\n//*\n//BACKDSNS EXEC PGM=BACKDSNS,PARM=RESTORE,REGION=4000K\n//STEPLIB  DD DSN=HALL.LINKLIB,DISP=SHR\n//REPORT   DD SYSOUT=*               FOR AUDIT TRAIL\n//SYSPRINT DD SYSOUT=*               FOR PDSFAST/COPY\n//SYSABEND DD SYSOUT=*               for a dump, if needed\n//DEBUG    DD SYSOUT=*               for an internal module trace\n//OUTDCB   DD SYSOUT=*               for a DCB/JFCB trace\n//DSNS     DD DSN=hli.RESTORE,       for a list of DSNS to RESTORE\n//            DISP=SHR                   LRECL must be 200             |\n//*YSUT1   DD UNIT=(TAPE,,DEFER)     TO GET A TAPE DRIVE\n//SYSUT1   DD  DSN=the name you used on the backup,\n//             UNIT=(TAPE,,DEFER),VOL=SER=the volser,\n//             DATACLAS=TAPEONLY,\n//             DISP=(OLD,KEEP),\n//             LABEL=(1,SL,EXPDT=99365) may not be needed...\n//SYSIN    DD *\n COPY  I=SYSUT1,O=SYSUT2\n/*\n    or, if the control statement is in a dataset:\n//SYSIN    DD DSN=dsname,DISP=OLD\n//*\n//\n\n:h1. Rename dataset at restore\n\nAll datasets can be renamed at restore time EXCEPT vsam files.\nTo rename a dataset, change the name in the RESTORE file, columns 1-44.\n\nTo rename a VSAM file, you must use IDCAMS, with the NEWNAME option.\nThe following jcl is an example of how to RENAME a VSAM file at\nrestore time:\n\n     //*\n     //*   RESTORE A VSAM FILE, AND RENAME ALL ENTRIES\n     //*\n     //STEP1    EXEC PGM=IDCAMS\n     //SYSPRINT DD SYSOUT=*\n     //SYSUT1   DD  DISP=SHR,DSN=vsam.name.in.restore.file,UNIT=TAPE,\n     //             VOL=SER=volser,LABEL=(seqno)\n     //SYSIN DD *\n          IMPORT INFILE(SYSUT1) -\n                    OUTDATASET(new.vsam.csi.name) -\n                    INTOEMPTY -\n                    OBJECTS( -\n                                 (old.vsam.csi.name     -\n                          NEWNAME(new.vsam.csi.name))   -\n                                 (old.vsam.data.name    -\n                          NEWNAME(new.vsam.data.name))  -\n                                 (old.vsam.index.name   -\n                          NEWNAME(new.vsam.index.name)) -\n                           )\n     //\n\nNote...The dsn, volser, and seqno in the //SYSUT1 is obtained from\n       the //RESTORE file created when you backed up the files....\n\n\n.pa\n:h2. JCL COMMENTS\n\nThe STEPLIB  DD statement is not required if the BACKDSNS program is\n                in a system linklist library.\n\nThe REPORT   DD statement will contain information on backed up or\n                restored datasets.\n\nThe SYSPRINT DD statement will contain a list of members for PO datasets\n                and the output from any IDCAMS calls for VSAM backups.\n                The SYSPRINT statement could be DUMMY if a list of\n                members is not required.\n\nThe DEBUG    DD statement will produce an internal trace of the program,\n                and is used for error determination.\n                The DEBUG statement is optional.\n\nThe OUTDCB   DD statement will produce an internal trace of the DCB and\n                JFCB control blocks for SYSUT1 and SYSUT2.\n                This is used for error determination.\n                The OUTDCB statement is optional. If specified, the\n                the DEBUG statement must also be specified.\n\nThe RESTORE  DD statement will contain a list of backed up datasets\n                that can be used for restoring datasets.\n                The RESTORE statement is optional but should be\n                included if you intend to use BACKDSNS for restoring.\n                The DCB attributes of RESTORE are:\n                RECFM=FB,LRECL=200,BLKSIZE=mult of 200                 |\n\nThe SYSUT2   DD statement defines the output tape.\n                The  UNIT= MUST specify DEFER.\n                The   VOL= MUST specify RETAIN.\n                           If there are other files on the tape,\n                           the REF= parameter can be specified.\n                The LABEL= must be  specified to indicate the file\n                           number.\n                The  DISP= MUST be (NEW,KEEP).\n                The   DSN= will be used for system information, such as\n                           an EXPIRY DATE, or for CATALOGing the tape.\n\n      NOTE..... DSN=NONE will no longer work if RACF does dsn checking.\n\n      NOTE 2... DISP= MUST be (NEW,KEEP), because of the way the system\n                handles cataloging functions. If you specify\n                NEW,CATLG, the LAST file copied to the tape will be\n                cataloged. If you  wish to catalog the FIRST file, you\n                will have to add a 2nd step that references the first\n                file with a disp of (OLD,CATLG).\n                For example, use.......\n\n                //CATALOG EXEC PGM=IEFBR14\n                //MASTER DD DISP=(OLD,CATLG),UNIT=TAPE,\n                //   VOL=REF=*.BACKDSNS.SYSUT2,\n                //   DSN=*.BACKDSNS.SYSUT2\n\n\n:h2. JCL COMMENTS, continued...\nThe SYSUT1   DD statement defines the input tape.\n                This DD is only required in a RESTORE job.\n                The UNIT= MUST specify DEFER.\n\nThe SYSIN    DD statement defines the IEBCOPY control statement file.\n                The statement must be COPY  I=SYSUT1,O=SYSUT2\n\nThe DSNS     DD statement contains a list of the datasets to be backed\n                up for a BACKUP job, or a list of datasets to be\n                restored if this is a RESTORE job.\n                The datasets can be PARTITIONED(PDS), SEQUENTIAL, VSAM,\n                or DIRECT.\n                DIRECT files are read as SEQUENTIAL files and are\n                written to tape as a sequential file.\n                If the data set is not catalogued, the volser can be\n                specified starting in column 46.\n\n       NOTE...  For a VSAM dataset, the volser of the CATALOG for the\n                dataset MUST be specified for RACF access, and it must\n                start in column 46.\n                The dataset must reside on a disk volume.\n\n:h1.Control Statements\n\nThe only control statement needed is the COPY statement for\nPDSFAST/IEBCOPY.\n\nThe //DSNS file contains a list of dataset names starting in column 1,\nand, optionally, the volser starting in column 46.\n\n:h1.RESTORE record layout\n\nNOTE...this had changed for version 6.0                                |\n\nThe NEW record layout of the RESTORE dataset is as follows:            |\n\n    Columns           Usage\n     1-44             This is the name of the DISK dataset.\n       45             must be blank.\n    46-47             Dataset type. This can be PO, PS, VS, or DA.\n       48             must be blank.\n    49-54             TAPE volser that contains the backup file.\n       55             blank, or * to indicate multiple volume.\n    56-59             File sequence number of the file on the tape.\n       60             must be blank.\n    61-64             The amount of space used by the disk dataset     |\n                      in TRACKS. If the dataset is to be created, this |\n                      can be changed.                                  |\n       65             must be blank.                                   |\n    66-69             This is the original secondary allocation        |\n                      specified for the disk dataset.                  |\n       70             must be blank.                                   |\n    71-74             If the disk dataset is a PDS, this is the number |\n                      of directory blocks allocated.                   |\n       75             must be blank.                                   |\n    76-80             Is the BLKSIZE of the file. If the dataset is to |\n                      be created, this can be changed.                 |\n       81             must be blank.                                   |\n    82-86             This is the LRECL of the file.                   |\n       87             must be blank.                                   |\n    88-90             This is the RECFM of the file.                   |\n       91             must be blank.                                   |\n    92-94             This shows the TYPE of space allocated. It can   |\n                      be TRK or CYL.                                   |\n       95             must be blank.                                   |\n    96-101            This is the volser if the disk dataset is not    |\n                      catalogued, OR if the disk file is VSAM, this is |\n                      the volser of the VSAM CATALOG that owns the     |\n                      VSAM file.                                       |\n      102             must be blank.                                   |\n   103-146            The TAPE dataset name of the backed up file.     |\n   147-200            reserved for future expansion.                   |\n\nFor multiple volumes, the only item on the next record will be the\nvolume serial number.\n\n.pa\nThe OLD record layout of the RESTORE dataset was:\n\n    Columns           Usage\n     1-44             This is the name of the DISK dataset.\n       45             must be blank.\n    46-47             Dataset type. This can be PO, PS, VS, or DA.\n       48             must be blank.\n    49-54             TAPE volser that contains the backup file.\n       55             blank, or * to indicate multiple volume.\n    56-59             File sequence number of the file on the tape.\n       60             must be blank.\n    61-77             The TAPE dataset name of the backed up file.\n       78             must be blank.\n    79-82             The amount of space used by the disk dataset\n                      in TRACKS. If the dataset is to be created, this\n                      can be changed.\n       83             must be blank.\n    84-87             This is the original secondary allocation\n                      specified for the disk dataset.\n       88             must be blank.\n    89-92             If the disk dataset is a PDS, this is the number\n                      of directory blocks allocated.\n       93             must be blank.\n    94-98             Is the BLKSIZE of the file. If the dataset is to\n                      be created, this can be changed.\n       99             must be blank.\n   100-104            This is the LRECL of the file.\n       105            must be blank.\n   106-108            This is the RECFM of the file.\n       109            must be blank.\n   110-112            This shows the TYPE of space allocated. It can\n                      be TRK or CYL.\n       113            must be blank.\n   114-119            This is the volser if the disk dataset is not\n                      catalogued, OR if the disk file is VSAM, this is\n                      the volser of the VSAM CATALOG that owns the\n                      VSAM file\n\nIf you HAVE to restore from an old backup, you will have to convert\nthe old record layout above to the new record layout.\nYou must also change the tape dataset name to BACKUP.the.disk.dsn,\nand the disk dataset name to a new one, such as the.disk.dsn.NEW.\n\n\n:h1.BACKDSNS return codes\n\nThe following return codes and abends can occur:\n\n       4 - An invalid //DSNS control card was found.\n         - Racf access to a dataset was denied.\n         - A dataset is empty and was not backed up.\n         - A dataset is allocated to some other job.\n         - An error was encountered processing a dataset.\n\n      12 - An error occurred. See the //SYSPRINT file.                 |\n\n    0486 - A serious error occurred. RACF will not let you use NONE\n           as the dataset name on the //SYSUT2 dd statement.\n\n    1211 - A serious error occurred. BACKDSNS abended.\n\n    1213 - The error trap ESTAE failed. Call BACKDSNS support.\n\n\n:h1.BACKDSNS messages\n\nThe messages produced by BACKDSNS are self-explanatory and start\nwith DSB. An error will cause a non-zero return code.\nThe messages and their meanings are:\n\nDSB000 - DIVERSIFIED DEVELOPMENTS BACKUP UTILITY STARTING -\n                                                 yy.ddd hh&gml.mm&gml.ss\n         BACKDSNS was started at yy.ddd  hh&gml.mm&gml.ss\n\nDSB001 - PARM INFORMATION IS INVALID\n         A parameter in the parm is incorrect.\n\nDSB002 - NO DSNAME ON CONTROL CARD:                               ERROR\n         A control card in //DSNS has no dataset name.\n\nDSB003 - INVALID CONTROL CARD:                                    ERROR\n         A control card in //DSNS is invalid.\n\nDSB005 - ABEND, CANNOT OPEN SYSPRINT DD\n         The //SYSPRINT dd statement is missing or is invalid.\n\nDSB006 - ALLOCATE FAILED FOR DSN  volser                          ERROR\n         The dsname in DSB043 could not be allocated to //SYSUT1\n         on a backup, or to //SYSUT2 on a restore.\n\nDSB007 - ERROR REASON CODE: xxx   INFORMATION REASON CODE: yyy    ERROR\n         The DYNALLOC reason code for DSB006.\n\nDSB008 - PROBABLE CAUSE:                                          ERROR\n         The reason //SYSUT1 could not be allocated, for example,\n         the dataset is allocated to another job as DISP=OLD.\n\nDSB009 - DE-ALLOCATE FAILED FOR DSN: dsname\n         DYNALLOC could not free //SYSUT1.\n\nDSB010 - MAX OF 5 TAPES EXCEEDED. RUN AS 2 JOBS                   ERROR\n         The datasets to be backed up need more than 5 tapes.\n         BACKDSNS can only handle 5 tapes per run.\n\nDSB011 - RACF READ ACCESS DENIED                                  ERROR\n         You do not have RACF access to the dsname in DSB043.\n\nDSB012 - DIRECTORY READ FAILED FOR DSNAME IN DSB043               ERROR\n         The directory of the PDS listed in DSB043 could not be read.\n\nDSB013 - LIBRARY EMPTY :                                          ERROR\n         The dataset listed in DSB043 is empty.\n\n.pa\nDSB015 - RDJFCB OF SYSUT2 FAILED                                  ERROR\n         The JFCB for //SYSUT2 could not be obtained.\n         //SYSUT2 may be missing or is invalid.\n\nDSB016 - OPEN FAILED FOR SYSUT2                                   ERROR\n         The output file for //SYSUT2 could not be opened. There\n         may be a problem with the tape, tape drive or jcl.\n\nDSB017 - NON-ZERO RETURN CODE FROM ESTAE CANCEL. RC=              ERROR\n         The error trap code failed. Call BACKDSNS support.\n\nDSB018 - OPEN FAILED FOR SYSUT1                                   ERROR\n         The dataset listed in DSB043 could not be opened for input.\n         Processing will try to continue with the next dataset.\n\nDSB019 - ABEND xxx, OFF=yyy IN CSECT name WHILE COPYING THE\n                                                ABOVE DATASET     ERROR\n         An xxx abend occurred at offset yyy in BACKDSNS csect name.\n         Processing will try to continue with the next dataset.\n\nDSB020 - SYSUT2 DD STATEMENT MISSING                              ERROR\n         The //SYSUT2 dd statement MUST be specified. See the JCL\n         section of this document.\n\nDSB022 - RDJFCB OF SYSUT2 FAILED                                  ERROR\n         The JFCB for //SYSUT2 could not be obtained. //SYSUT2 may\n         be missing or is invalid.\n\nDSB022T- RDJFCB OF SYSUT1 FAILED                                  ERROR\n         The JFCB for //SYSUT1 could not be obtained. //SYSUT1 may\n         be missing or is invalid.\n\nDSB023 - SECOND READ OF SYSUT2 JFCB FAILED                        ERROR\n         The JFCB for //SYSUT2 could not be obtained. //SYSUT2 may\n         be missing or is invalid.\n\nDSB024 - UCB NOT FOUND FOR SYSUT2                                 ERROR\n         The //SYSUT2 DD does not specify UNIT=TAPE.\n\nDSB025 - PDSFAST RETURN CODE ==> nnnnnnn\n         PDSFAST ended with a return code of nnnnnn.\n\nDSB026 - IDCAMS  RETURN CODE ==> nnnnnnn\n         IDCAMS ended with a return code of nnnnnn.\n\nDSB027T/\nDSB027 - ERROR OPENING SYSUT2                                     ERROR\n         The //SYSUT2 DD could not be opened. Check that\n         DATACLAS=NOTMM is specified\n\nDSB039 - DEBUG OPTION IN EFFECT - A TRACE WILL BE PRODUCED IN FILE\n         'DEBUG'. You included a //DEBUG dd statement in your jcl.\n\n.pa\nDSB040 - DEBUG OPTION CANCELLED - OPEN ERROR ON FILE 'DEBUG'\n         The DEBUG option was cancelled. The //DEBUG file could\n         not be opened.\n\nDSB041 - RESTORE OPTION CANCELLED - OPEN ERROR ON FILE 'RESTORE'\n         The RESTORE option was cancelled. The //RESTORE file could\n         not be opened.\n\nDSB042 - UNABLE TO OPEN COPY CONTROL DDCARD ddname                ERROR\n         The //DSNS file is missing or is invalid.\n\nDSB043 - PROCESSING DATASET = dsname\n         The dataset named dsname is being processed.\n\nDSB06N - NO VOLSER IN JFCB FOR SYSUT2                             ERROR\n         The volume for SYSUT2 was not specified, or could not\n         be obtained from the UCB.\n\nDSB060 - INITIAL READ OF JFCB FOR SYSUT2 FAILED                   ERROR\n         The //SYSUT2 dd statement is missing or is invalid.\n\nDSB061 - DATA SET BACKUP DONE\n         BACKDSNS has ended.\n\nDSB071 - SERIOUS ERROR PROCESSING USER LIBRARY                    ERROR\n         A serious error has occurred. BACKDSNS is ended.\n\nDSB098 - BACKDSNS VERSION COMPILED ON mm/dd/yy  hh&gml.mm\n         The date and time BACKDSNS was assembled.\n\nDSB100 - DATASET NOT COPIED. DSORG INVALID:                       ERROR\n         The dataset organization was not PO, PS, DA, or VS.\n\nDSB110 - EMPTY CHECK NOT DONE: dsname\n         The dataset could not be checked to see if it was empty.\n\nDSB120 - ABOVE dsorg DATASET COPIED TO FILE nnnn ON TAPE vvvvvv,\n               DSN=tape.data.set.name\n         The dataset was copied to file nnnn on tape vvvvvv with a\n         dataset name of tape.data.set.name.\n\nDSB120R - ABOVE dsorg DATASET RESTORED FROM FILE nnnn ON TAPE vvvvvv\n\nDSB122 - FOR RESTORE, USE pgm to restore this file\n         Indicates how the file could be restored.\n\nDSB999 - DATA SET BACKUP UTILITY END  yy.ddd  hh&gml.mm&gml.ss RETURN\n         CODE = 0000. The date, time and return code when BACKDSNS ended.\n\nCANTMSG- The dataset is a BDAM dataset, and cannot be restored with\n         BACKDSNS.\n:h1.Sample Backup output\n    Note that FILE 0001 is now a control dataset created\n    from the //SYSUT2 jcl parameters.\n\nINFO01 - FILE 1 IS USED FOR SYSTEM INFORMATION LIKE CATALOG NAME,\nINFO02 -        EXPIRY DATE, OR GDG NAME\nINFO03 - PROCESSING DATASET = HALL.BACKUP (DSN= on //SYSUT2)\nINFO04 - ABOVE PS DATASET CREATED IN FILE 0001 ON TAPE C12345\n\nDSB000 - DATA SET BACKUP UTILITY STARTING -  97.224  12:38:39\nDSB098 - BACKDSNS VERSION 6.0 COMPILED ON 01/10/98  11.09\nDSB039 - DEBUG OPTION IN EFFECT - A TRACE WILL BE PRODUCED IN FILE 'DEBUG'.\n\nDSB043 - PROCESSING DATASET = HALL.ATS2.TEXT\nDSB025 - PDSFAST RETURN CODE ==> 0000000\nDSB120 - ABOVE PO FILE COPIED TO FILE 0002 ON TAPE C12345,\n               DSN=HALL.BACKUP.F002                                    |\n\nDSB043 - PROCESSING DATASET = HALL.BTSOUT\nDSB120 - ABOVE PS FILE COPIED TO FILE 0003 ON TAPE C12345,\n               DSN=HALL.BACKUP.F003                                    |\n\nDSB043 - PROCESSING DATASET = IMSRCF1V.HALL.ALECON\nDSB011 - RACF READ ACCESS DENIED                                    ERROR\n\nDSB043 - PROCESSING DATASET = HALL.MASTER\nDSB120 - ABOVE DA FILE COPIED TO FILE 0004 ON TAPE C12345,\n               DSN=HALL.BACKUP.F004                                    |\nDSB122 - FOR RESTORE, USE A DIRECT ACCESS LOAD PROGRAM\n\nDSB043 - PROCESSING DATASET = HALL.A0000000.BBBBBBBB.CCCCCCCC.DDDDDDDD.EEE\nDSB120 - ABOVE PS FILE COPIED TO FILE 0005 ON TAPE C12345,\n               DSN=HALL.BACKUP.F005                                    |\n\nDSB043 - PROCESSING DATASET = HALL.TEST.VOLSER\nDSB120 - ABOVE DATASET COPIED TO FILE 0006 ON TAPE C12345,\n               DSN=HALL.BACKUP.F006                                    |\n\nDSB999 - DATA SET BACKUP UTILITY END  90.039  12:39:19  RETURN CODE = 0000\n\n:h1.Sample Restore output\n\nDSB000 - DATA SET BACKUP UTILITY STARTING -  97.224  12:38:39\nDSB098 - BACKDSNS VERSION 6.0 COMPILED ON 01/10/98  13.09\nDSB039 - DEBUG OPTION IN EFFECT - A TRACE WILL BE PRODUCED IN FILE 'DEBUG'.\n\nDSB043 - PROCESSING DATASET = HALL.ATS2.TEXT\nDSB025 - PDSFAST RETURN CODE ==> 0000000\nDSB120 - ABOVE PO FILE RESTORED FROM FILE 0002 ON TAPE C12345\n\nDSB043 - CREATING   DATASET = HALL.BTSOUT\nDSB006 - ALLOCATE FAILED FOR DSN                                    ERROR\nDSB007 - ERROR REASON CODE: 1708   INFORMATION REASON CODE: 0002\nLOCMSG - ALLOCATED SUCCESSFULLY ON SS19PA\nDSB120R - ABOVE PS DATASET RESTORED FROM FILE 0003 ON TAPE C12345\n\nDSB043 - PROCESSING DATASET = IMSRCF1V.HALL.ALECON\nDSB025 - IDCAMS  RETURN CODE ==> 0000000\nDSB120 - ABOVE VS DATASET RESTORED FROM FILE 0004 ON TAPE C12345\n\nDSB043 - PROCESSING DATASET = HALL.MASTER\nCANTMSG- DA FILES MUST BE RESTORED WITH A DA LOAD PROGRAM           ERROR\nDSB100 - DATASET NOT COPIED. DSORG INVALID.\n\nDSB043 - PROCESSING DATASET = HALL.A0000000.BBBBBBBB.CCCCCCCC.DDDDDDDD.EEE\nDSB120 - ABOVE PS FILE RESTORED FROM FILE 0005 ON TAPE C12345\n\nDSB043 - PROCESSING DATASET = HALL.TEST.VOLSER\nDSB120 - ABOVE DATASET RESTORED FROM FILE 0006 ON TAPE C12345\n\nDSB999 - DATA SET BACKUP UTILITY END  97.224  12:39:19 RETURN CODE = 0004\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HOWDISAS": {"ttr": 16394, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x00\\x9f\\x00\\x99\\x01\\x1f\\x10P\\x02B\\x01\\xdb\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-01-09T00:00:00", "modifydate": "1999-01-11T10:50:00", "lines": 578, "newlines": 475, "modlines": 0, "user": "RH87944"}, "text": "//HOWDISAS  JOB (87944,348496),'HALL.S1BL',CLASS=S,\n//             MSGCLASS=A,PRTY=1,\n//             USER=*,PASSWORD=*\n//*\n//*\n/*JOBPARM  K=0\n/*ROUTE PRINT R0\n//* /*OUTPUT F306 PDE=TEXT,FLASH=NONE,DUPLEX=YES,COPIES=3\n//STEP1  EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//*\n//*    NOTE....THIS JCL IS SET UP TO USE THE XEROX PRINTER, AND TO\n//*            PRINT ON BOTH SIDES OF THE PAPER.\n//*\n//*            IF YOU DO NOT WANT YOUR MANUALS ON 8 1/2 X 11\n//*            3-HOLE PAPER, PRINTED ON BOTH SIDES, REVERSE\n//*            THE SYSUT2 STATEMENTS SHOWN BELOW, OR MODIFY\n//*            THE JCL TO DO WHAT YOU WANT.\n//*\n//SYSUT2 DD SYSOUT=*,\n//*YSUT2 DD SYSOUT=(*,,F306),\n//          DCB=(RECFM=FA,LRECL=80,BLKSIZE=80)\n//SYSUT1 DD *\n1\n-\n-\n                                  DISASM REFERENCE MANUAL\n0                                       RELEASE 1.0\n-\n-\n0                                       1st Edition\n                                       October, 1986\n\n1      DISASM ACKNOWLEDGEMENTS\n-\n       DISASM was orginally obtained from a share tape and was written by\n\n                  Dick Thornton\n                  Blue Cross of Virginia\n                  2015 Staples Mill Road\n                  Richmond, Va. 23279\n\n       DISASM has been modified by:                                     y\n\n0      January 1999 by:\n0        Randy Hall,\n         1151 Palmer Road,\n         Victoria, B.C.\n         V8P-2H5\n         Phone:250-385-1061\n\n0      DISASM was heavily modified to produce a more useable and readable\n       assembler listing type of output. If a source deck is produced, it\n       can, in most cases, be passed through the assembler compiler to\n       produce a valid load module. This is a very usefull feature if the\n       original source for a load module has been lost, and modifications\n       are to be made to the module.\n       All (hopefully) changes have RH in columns 69-70.\n\n       Version updated and modified January 1991 by:\n         Alan C Field\n         Wetterau Inc.,\n         345 Dunn Road,\n         Florissant, Mo., 63031-7995\n         Phone: (314) 839-7040\n\n       Version updated and modified March 1991 by:\n         Robert Styma\n         AG Communication Systems\n         P.O. Box 52179\n         Phoenix, Az 85702-2179\n         Phone: (602) 582-7323\n\n       Made the 3 module format into a 1 module format. Changed the\n       work area sizes to be symbolics and bumped buffer area to\n       handle max length records. This is in DISASM1. Fatal messages\n       are written to the screen using TPUT in addition to going to\n       the print file.  DISASM1 and DISASM2 have code which deals with\n       BAS, BASSM and similar instructions. Minor fixes for handling\n       weak externs and label problems. Changes to some of the 2 byte\n       opcodes to show they are not proviledged.\n\n       Version updated and modified May 1992 by:\n         Alan C Field\n         Wetterau Inc.,\n         345 Dunn Road,\n         Florissant, Mo., 63031-7995\n         Phone: (314) 839-7040\n\n       Extensions to opcode tables, change format of printed listing\n       to look more like ASSEMBLER output (easier to read on 80 col\n       screen) and bug fixes where some instructions didn't\n       dis-assemble correctly, increases to some table sizes to handle\n       BIG modules.\n\n\n0                                         - 1 -\n1      DISASM USERS GUIDE\n-\n       DISASM is a one-pass disassembler which produces an assembler\n       language source program from a CSECT within a load module.\n       Control cards permit specification of areas containing no\n       instructions, allow base registers to be provided so that\n       symbolic labels may be created during disassembly, and\n       definition of DSECTS to be used during disassembly. Conditional\n       branch instructions use the extended mnemonics, where possible,\n       and explicit registers are denoted by R0, R1, ... R15. Informational\n       comments are given on SVC's, and various BAL instructions to aid\n       in creating a documented source program.\n\n       1. JCL requirements:\n             A. EXEC card:        To execute PGM=DISASM. A parm field may\n                                  be specified if floating point and/or\n                                  privileged instructions are to be\n                                  found in the module, or if you want a\n                                  hex dump listing of the csect.\n             B. STEPLIB DD card:  Optional. Specify the pds containing\n                                  the module DISASM.\n             C. LOADLIB DD card:  Optional. Specify the pds containing the\n                                  modules DISASM1 and DISASM2, if other than\n                                  SYS1.LINKLIN or STEPLIB.\n             D. SYSLIB DD card:   Specify the pds containing the module to be\n                                  disassembled.\n                                  If there is only one csect in the\n                                  module, or you want the first csect\n                                  in the module, the member name can\n                                  be specified with the dsname.\n             E. SYSPRINT DD card: Optional. Specify the printed\n                                  output dataset. Blksize must be\n                                  specified as a multiple of 133.\n                                  RECFM=FBA,LRECL=133 is hard coded.\n             F. SYSPUNCH DD card: Optional. Specify printed output\n                                  dataset. Blksize must be specified\n                                  as a multiple of 80.\n                                  RECFM=FB,LRECL=80 is hard coded.\n             G. SYSIN DD card:    Optional. Contains control cards.\n                                  The MODULE-CSECT card is required if\n                                  other than the first csect is to be\n                                  disassembled. Blksize must be a\n                                  multiple of 80. RECFM=FB,LRECL=80 is\n                                  hard-coded.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0                                         - 2 -\n1      DISASM USERS GUIDE\n-\n         Jcl example:  Disassemble csect IECIOSCN in module IEANUC01,\n                       which is in the pds SYS1.NUCLEUS. The modules\n                       DISASM, DISASM1, and DISASM2 are all in the pds\n                       SYS1.TECHLOAD. A printed listing is to be made,\n                       and the source program output will be placed in\n                       the sequential dataset USER02.IECIOSCN.ASM.\n\n             //DISASM EXEC PGM=DISASM\n             //STEPLIB DD DSN=SYS1.TECHLOAD,DISP=SHR\n             //SYSPRINT DD SYSOUT=A,DCB=BLKSIZE=133\n             //SYSLIB DD DSN=SYS1.NUCLEUS,DISP=SHR\n             //SYSPUNCH DD DSN=USER02.IECIOSCN.ASM,DISP=(,CATLG),\n             //            UNIT=DISK,\n             //            DCB=BLKSIZE=3120,\n             //            SPACE=(TRK,(5,2),RLSE)\n             //SYSIN DD *\n             IEANUC01 IECIOSCN\n             /*\n\n       2. Parm field on the EXEC card:\n               Omit the parm field, unless a hex dump of the module, or\n               floating point and/or privileged instructions are to\n               be found in the csect being disassembled. When the parm\n               field is not specified, entries for the privileged and\n               floating point instructions are erased from the internal\n               instruction tables used during disassembly, and no hex\n               dump of the module is done. Valid parm fields are :\n\n                 PARM=(TEXT)      Print a hex dump of the module\n                 PARM=(SUPVR)     Assemble privileged instructions\n                 PARM=(FLTPT)     Assemble floating point instructions\n                 PARM=(SUPVR,FLTPT) Assemble both privileged and\n                                  floating point instructions.\n                 PARM=(TEXT,SUPVR,FLTPT) Assemble both privileged and\n                                  floating point instructions, and\n                                  print a hex dump of the module.\n\n       3. SYSIN control cards.\n                        Data for the control cards is\n                        contained only in columns 1-72. Columns\n                        73-80 may be used for any desired purpose.\n                        Comment cards may be entered with an asterisk\n                        (*) in column 1.\n                        In addition, columns beyond the last\n                        specified may be used for any purpose.\n                        Leading zeros must be included in all\n                        fields giving hex or decimal data.\n                        Name fields must be left justified with\n                        trailing blanks.\n                        Hex fields may contain only the hex digits\n                        0-9 and A-F.\n                        Decimal fields may contain only digits 0-9.\n                        The MODULE-CSECT card must be the first\n                        card in the input stream.\n                        DSECT definitions may not include any other\n                        control cards.\n\n\n\n\n0                                         - 3 -\n1      DISASM USERS GUIDE\n-\n                        USING cards for dsects must be entered at\n                        some point after the dsect definition.\n                        DATA-ONLY cards and PROGRAM USING cards\n                        may be entered in any order except\n                        within dsect definitions.\n\n          A. MODULE-CSECT card (required), must be the first card in\n                          the SYSIN stream. It specifies the module name\n                          and csect name. Module name is required, and\n                          must name an entry in the directory of the\n                          pds specified by the SYSLIB DD card. The CSECT\n                          name is optional. If specified, the named\n                          csect must exist in the module. If omitted, the\n                          csect with ESDID=0001 is disassembled.\n\n             Format:\n                     Free-form, with module name preceding csect name.\n                     At least one blank must separate module name and\n                     csect name. The names may be surrounded by any number\n                     of blanks.\n                     For an example, see the JCL example.\n\n          B. DATA-ONLY card (optional)\n                       The DATA-ONLY card is used to describe areas of the\n                       CSECT being disassembled which contain no\n                       instructions. Use of this card eliminates\n                       creation of instructions from constant data.\n                       Up to 256 DATA-ONLY cards may be entered. These\n                       cards may occur anywhere in the SYSIN stream\n                       after the MODULE-CSECT card, but not within\n                       a DSECT definition set.\n\n             Format:\n                     Col  1-4  : Literal 'DATA'\n                     Col   5   : Blank\n                     Col  6-11 : Offset to beginning of area in hex\n                     Col   12  : Blank\n                     Col 13-18 : Offset to end of area in hex\n\n             Example: DATA 0001C0 0002F0\n\n          C. DSECT definitions (optional).\n                     A DSECT is defined by a header card followed\n                     by a variable number of field definition cards\n                     (up to 9999 of them).\n                     No other control card may be entered within a\n                     dsect definition. Up to 256 dsect definitions\n                     may be entered.\n\n             DSECT header card format:\n                  Col 1-8    : Dsect name\n                  Col 9      : Blank\n                  Col 10-14  : Literal 'DSECT'\n                  Col 15     : Blank\n                  Col 16-19  : Number of field cards to follow (decimal)\n\n\n0                                         - 4 -\n1      DISASM USERS GUIDE\n-\n             DSECT field card format:\n                  Col 1-8    : Field name\n                  Col 9      : Blank\n                  Col 10-13  : Offset to left end of field, in hex.\n                               Maximum offset is x'0FFF' (4095)\n                  Col 14     : Blank\n                  Col 15-17  : Length of field in bytes (decimal).\n                               Maximum length is 256\n\n             Example: HDR      DSECT 0004\n                      PGMNAME  0000 007\n                      DATE     0007 008\n                      TIME     000F 005\n                      FILL     0014 002\n                      GETCORE  DSECT 0002\n                      SAVE     0000 072\n                      REST     0048 074\n\n          D. ULABL cards.\n                        These cards define user labels to be placed\n                        on statements within the program. If program\n                        base registers are set up with USING cards,\n                        these will also be generated as symbolic\n                        operands on instructions.\n\n              Format:\n                  Col  1-5   : Literal 'ULABL'\n                  Col   6    : Blank\n                  Col  7-14  : Label name\n                  Col  15    : Blank\n                  Col 16-21  : Offset to left end of field, in hex.\n                  Col  22    : Blank\n                  Col 23-25  : Length of field in dec. 256 is max.\n\n             Example: ULABL START    000000 004\n\n          E. USING cards.\n                        These cards define base register usage.\n                        Up to 256 using cards may be entered. Use\n                        of these cards permits the disassembler to\n                        convert explicit base-displacement addresses\n                        to symbolic labels. Labels created within\n                        the program will be 7 characters long. The\n                        first character is 'A', followed by the\n                        6-hex-digit offset to the label. A USING\n                        card must be entered for each dsect to\n                        be used.\n\n            Format:\n\n                 Col 1-5   : Literal 'USING'\n                 Col 6     : Blank\n                 Col 7-12  : Offset to begin loc for using range in hex\n                             (this is where the using statement will occur)\n                 Col 13    : Blank\n                 Col 14-19 : Offset to ending loc for using range in hex\n                             (this is where the drop statement will occur)\n0                                         - 5 -\n1      DISASM USERS GUIDE\n-\n                 Col 20    : Blank\n                 Col 21    : Base register to be used (hex, 1-F)\n                 Col 22    : Blank\n                 Col 23    : Type, P=program base, D=dsect base\n                 Col 24    : Blank\n                 Col 25-30 : Initial base register value in hex if type P\n                 Col 25-32 : Dsect name if type D\n\n             Example: USING 000000 000760 C P 000000\n                      USING 000000 000092 3 D GETCORE\n\n            Example2: The program has 3 base registers..12, 10, 7\n                      and it is H'2966' bytes long.\n                      USING 000000 001000 C P 000000\n                      USING 000000 002000 A P 001000\n                      USING 000000 002966 7 P 002000\n\n       4. Suggestions for use:\n                      On the first pass, do not use a SYSPUNCH\n                      DD card, but print the SYSPRINT listing. Use the\n                      listing to determine which registers are used as\n                      program base registers, their initial values, and\n                      their ranges. Make up USING cards for these. Find\n                      any places where no instructions should be generated\n                      (only constants), and make up DATA-ONLY cards for\n                      these ranges. If you can determine any registers\n                      that are bases for areas which can be used for\n                      dsects (CVT reference, etc.), determine the\n                      range of valid use, and make up DSECT definitions\n                      and USING cards for these. Make a second run,\n                      including the above cards, and creating\n                      a source program output with the SYSPUNCH\n                      DD card.\n\n       5. Output description:\n\n          A. SYSPUNCH: This output contains the disassembled source\n                       program. Statement names begin in column 1,\n                       mnemonics begin in column 10, operands in col\n                       16, and an occasional comment begins in col-\n                       umn 44. A sequence number (by tens) is in\n                       columns 73-80. Comments are included to show\n                       the macro name associated with SVC's, and other\n                       statements are flagged to aid in identification\n                       of certain operations:\n                       BALR 14,15              STD LINKAGE\n                       BALR X,0                ADDRESS SET\n                       OTHER BALR'S            NON-STD LINKAGE\n                       BAL 0,XXX AND BAL 1,XXX PARM SET BRCH\n                       BAL X,XXX               PERFORM\n                       STM INSTRUCTIONS        SAVE REGS\n                       LM  INSTRUCTIONS        RESTORE REGS\n                       BR R14                  EXIT\n                       Abs. location Hex 10    CVT address\n                       Abs. location Hex 4C    CVT address\n                       Other abs. locations    PSA reference\n\n0                                         - 6 -\n1      DISASM USERS GUIDE\n-\n                       When used explicitly in instructions, registers\n                       are specified as R0, R1, R2,... R15.\n                       Register equate statements are generated at the\n                       end of the program.\n\n                       If any DSECTs were defined in the SYSIN dataset,\n                       they will be near the end of the source program.\n                       The extended mnemonics are used for conditional\n                       branches wherever possible.\n\n           B. SYSPRINT content:\n\n              Directory information: Contains data from the directory\n                                     entry of the module containing\n                                     the CSECT to be disassembled.\n\n                          ESD table: A formatted list of all external\n                                     entries found in the module.\n\n                          RLD table: A formatted listing of all relocation\n                                     dictionary entries pertaining to this\n                                     CSECT.\n\n                 User entered cards: A list of the cards entered by the\n                                     user, with diagnostics, if appropriate.\n\n                Phase 1 label table: A list of all the labels to be used\n                                     during disassembly, including those\n                                     developed from ESD entries, RLD\n                                     entries, and generated names\n                                     resulting from USING card processing.\n\n                               Text: If requested, a storage-dump formatted\n                                     listing of the text which comprises\n                                     the CSECT being disassembled.\n\n                     Source listing: A printout of the generated source\n                                     program statements, including the hex\n                                     value which resulted in the instruction's\n                                     creation, in an assembly source\n                                     listing format.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0                                         - 7 -\n1      DISASM USERS GUIDE\n-\n0      User Abends:\n\n        DISASM may end with one of two user abends:\n\n        U0777 - There is an invalid parm specified.\n        U0888 - Check in the SYSPRINT listing for an error message\n                describing the error causing the abend (e.g. table\n                overflow).\n\n\n0      Program processing description.\n\n       DISASM functions:\n\n       . Process the parm field, if any: set indicators used by\n         DISASM1 and DISASM2 to set up their instruction tables.\n       . Open all files.\n       . Get storage for the symbol table, RLD table, and data-only\n         tables (109,544 bytes total).\n       . Process the module-CSECT card to obtain the member\n         and CSECT names.\n       . Issue BLDL against SYSLIB to obtain directory info for\n         the member specified. If the specified member is an\n         alias, re-issue a BLDL for the real member. Print\n         directory information.\n       . Point to the member in the SYSLIB PDS, and process the\n         member. Load modules contain an external symbol dictionary\n         followed by text and relocation dictionary information.\n         all ESD info for the module precedes the first control\n         record. A control record precedes each block of text.\n         RLD info for the text follows each text block. Processing\n         of load module information is as follows:\n         a. Build an external symbol table, using the CESD blocks.\n         b. Search for the desired CSECT as the table is being built.\n            This CSECT must be found before the first control record.\n         c. Read blocks until a control record for the desired CSECT is\n            found (by ESD-id).\n         d. When found, issue GETMAIN for an area large enough to contain\n            the entire text.\n         e. Place text blocks in contiguous storage locations and maintain\n            during disassembly.\n         f. Use RLD information for the CSECT to build the RLD table.\n       . Load and perform DISASM1.\n       . If any errors found by DISASM1, terminate processing.\n       . Print the final label table to be used during disassembly.\n       . Load and execute DISASM2.\n       . Generate the DSECT entries.\n       . Generate the REQU macro and end statements\n       . Terminate processing\n\n\n\n0                                         - 8 -\n1      DISASM USERS GUIDE\n-\n0      DISASM1 functions:\n\n       DISASM1 is the second phase of disassembly, and is performed by\n       DISASM. A common data area, defined in DISASM, is passed to this\n       program on entry.\n\n       The SYSIN file is read to exhaustion. Using cards are reformatted\n       and stored in a table - up to 256 using statements may be\n       entered. DSECT cards may follow the using statements. When used,\n       DSECT statements are reformatted, and built into tables. A\n       maximum of 256 DSECTs may be entered. Data only cards may be\n       included before, between, or after DSECTs to show areas in the\n       program where no instructions occur. Up to 256 data only areas\n       may be specified.\n\n       At eof on SYSIN, a pseudo dis-assembly pass is made using the\n       text stored by disasm. Any resolvable address within the text is\n       used to create a new entry in the label table, which will be used\n       by DISASM2 in the actual dis-assembly pass.\n\n       Disassembly tables are set up similarly to those used by DISASM2\n       for the simulated disassembly performed in this module when any\n       program base register using statements are entered.\n\n       Storage is obtained for the DSECT table and using table, and\n       addresses of these tables are stored in the common parameter\n       area. Using and DSECT cards are edited, reformatted, and placed\n       in the appropriate tables. If any errors are found, they are\n       printed, and the disassembly will be terminated on return to\n       disasm.\n\n       Storage is obtained for the label table, and a simulated\n       dis-assembly is performed to create label table entries for\n       labels which will be generated for base-displacement addresses by\n       DISASM2. On return to disasm, these labels will be sorted with\n       external symbol and RLD labels to form the final label table to\n       be used by DISASM2.\n\n\n0      DISASM2 functions:\n\n       This sub-program is called by DISASM after completion of\n       processing by DISASM1. The final label table and module text is\n       in an area of storage. A common parameter area is defined in\n       disasm, and passed to this program.\n\n       Text bytes are used to create assembly language statements, and\n       machine instruction statements. Output is written to the SYSPUNCH\n       dataset for further processing by other modules.\n\n       A text byte is considered to be an instruction if it occurs on a\n       halfword boundary, is a valid op-code, and is followed by a valid\n       op-code. Unconditional branches need not be followed by a valid\n       op-code, however. The privileged and floating point instructions\n       are not treated as instructions unless the user specified their\n       inclusion at exec time.\n\n\n\n0                                         - 8 -\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HOWFDUMP": {"ttr": 16650, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x13@\\x01\\xb7\\x01\\xb7\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T13:40:00", "lines": 439, "newlines": 439, "modlines": 0, "user": "RH87944"}, "text": "//HOWFDUMP  JOB\n//*\n//*\n/*JOBPARM  K=0\n/*ROUTE PRINT R0\n/*OUTPUT F306 PDE=TEXT,FLASH=NONE,DUPLEX=YES,COPIES=10\n//STEP1  EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//*\n//*    NOTE....THIS JCL IS SET UP TO USE THE XEROX PRINTER, AND TO\n//*            PRINT ON BOTH SIDES OF THE PAPER.\n//*\n//*            IF YOU DO NOT WANT YOUR MANUALS ON 8 1/2 X 11\n//*            3-HOLE PAPER, PRINTED ON BOTH SIDES, REVERSE\n//*            THE SYSUT2 STATEMENTS SHOWN BELOW, OR MODIFY\n//*            THE JCL TO DO WHAT YOU WANT.\n//*\n//*YSUT2 DD SYSOUT=*,\n//SYSUT2 DD SYSOUT=(*,,F306),\n//          DCB=(RECFM=FA,LRECL=80,BLKSIZE=80)\n//SYSUT1 DD *\n1\n-\n-\n                                     Copyright 1986 by\n0                                 Diversified Developments\n0                                   All Rights Reserved\n-\n0                                       1st Edition\n                                       October, 1986\n\n-\n\n\n\n\n\n\n\n-\n-\n-\n-                               FILEDUMP REFERENCE MANUAL\n0                                       RELEASE 1.0\n-\n\n0                                Diversified Developments,\n                                    1151 Palmer Road,\n                                      Victoria, B.C.\n                                        V8P-2H5\n0\n                                randy.hall@i.am\n1     FILEDUMP REFERENCE MANUAL\n-\n0          Preface\n+          _______\n0          This publication,   the FILEDUMP REFERENCE  MANUAL,  1st\n           edition, October, 1986,  describes how to use the FILEDUMP\n           file utility program.\n-\n           Who This Publication Is For\n+          ___ ____ ___________ __ ___\n-          This publication is provided by Diversified Developmemts\n           to users of the  FILEDUMP utility program and is for the\n           exclusive use of those users.\n-\n0\n0\n\n0\n\n\n\n\n0\n\n\n0\n\n0\n\n\n\n0\n\n-\n-\n-\n\n\n-\n                                       -I-\n1     FILEDUMP REFERENCE MANUAL\n-\n0          TABLE OF CONTENTS\n+          _____ __ ________\n-\n0          Introduction . . . . . . . . . . . . . . . . . . . . . . . . . 1\n              Using This Manual . . . . . . . . . . . . . . . . . . . . . 1\n              Program Description . . . . . . . . . . . . . . . . . . . . 1\n0          Detailed Description . . . . . . . . . . . . . . . . . . . . . 2\n              Jcl . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n              Parameters. . . . . . . . . . . . . . . . . . . . . . . . . 3\n              Examples. . . . . . . . . . . . . . . . . . . . . . . . . . 4\n              Return Codes. . . . . . . . . . . . . . . . . . . . . . . . 5\n0\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0                                     -II-\n1     FILEDUMP REFERENCE MANUAL\n-\n0          Introduction\n                                                                    Introduction\n-          The program FILEDUMP is used to produce a formatted report in\n           an OS dump format.\n\n           It can also be used to copy all or specific portions of the input\n           file to an output file.\n-          Using This Manual\n+          _____ ____ ______\n-          This manual is intended  primarily   as  a  reference  manual.\n-\n-          Program Description\n+          _______ ___________\n-\n           FILEDUMP will process records created by any standard IBM access\n           method. Records are printed 32 characters per line in an OS dump\n           format. Overflow ISAM records are flagged with an asterisk to the\n           right of the record length. Read errors will be accompanied by\n           messages, and an attempt will be made to print the bad data.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0                                         - 1 -\n1     FILEDUMP REFERENCE MANUAL\n-\n\n\n                              JCL Statements\n+                             ___ __________\n\n\n           The following JCL is required to run FILEDUMP:\n\n           //stepname EXEC PGM=FILEDUMP,REGION=20K,PARM='....'\n           //STEPLIB    DD DSN=SYS9.UTIL.LOAD,DISP=SHR\n           //SYSPRINT   DD SYSOUT=A\n           //SYSUT1     DD DSN=input.file,DISP=SHR\n           //SYSUT2     DD DSN=copy.of.input.file,UNIT=unit,DISP=(disp),\n           //              SPACE=(TRK,(pri,sec)),\n           //              DCB=(RECFM=,LRECL=,BLKSIZE=)\n\n\n           EXEC statement   This statement specifies the program name\n                            (PGM=FILEDUMP), and the region size (REGION=20K\n                            for sequential datasets with blocksize of\n                            4240 or less). The region should be increased\n                            for ISAM and larger blocksizes. An optional\n                            field (PARM=), may be coded if other than\n                            defaults are required.\n\n           STEPLIB          This statement may be needed if FILEDUMP\n              DD statement  is not in a system linklist library.\n                            at BCSC, this statement should point to\n                            SYS9.UTIL.LOAD\n\n           SYSPRINT         Output file, normally SYSOUT=A\n             DD statement\n\n           SYSUT1           The input data set. The following are\n             DD statement   valid.\n\n                            DD * - for card files.\n\n                            DD DISP=SHR,DSN=dataset.name - for\n                            catalogued datasets.\n\n                            DD DISP=SHR,DSN=dataset.name(member name) -\n                            for a member of a partitioned data set. If a\n                            member name is not coded for a partitioned\n                            dataset, the directory will be printed.\n\n                            DD DISP=SHR,DSN=,UNIT=,VOL=SER=  - for\n                            uncatalgued, standard labelled, datasets.\n\n                            DD DISP=OLD,UNIT=TAPE,VOL=SER=,\n                            LABEL=(2,BLP),DCB=(RECFM=U,BLKSIZE=32196)\n                            - to dump the contents of an unknown tape.\n                            If LABEL=(1,BLP) is coded, the header\n                            labels will be printed.\n\n           SYSUT2           The output file of a COPY operation.\n             DD statement   Used only if PARM=C or B is specified.\n                            DCB information must be specified.\n0                                         - 2 -\n1     FILEDUMP REFERENCE MANUAL\n-\n                              CONTROL PARAMETERS\n+                             _______ __________\n\n           The defaults are:\n\n           1) TITLE is dataset name and volume serial numbers.\n           2) The first 100 records will be printed.\n\n           To override the defaults code PARM= on the EXEC card.\n           Example 2 shows how to continue a parm field on a\n           second and third card.\n\n           C  or  COPY\n\n           If the parameter is C or COPY, all records wanted will be\n           copied from SYSUT1 to SYSUT2.\n\n           B  or  BOTH\n\n           If the parameter is B or BOTH, all records wanted will be\n           printed on SYSPRINT and will also be copied to SYSUT2.\n\n           HEX              The default is DECIMAL\n\n           If HEX is coded, the offsets at the beginning of each\n           printed line will be printed in HEXADECIMAL rather\n           than DECIMAL.\n\n           START=n          The default is 1\n\n           Where n is a 1 to 6 digit value representing the record number\n           to start printing at.\n\n           SKIP=n           The default is 1\n\n           Where n is a 1 to 6 digit value representing the number of\n           records skipped between printed records.\n           The SKIP= parm is added to the START= parm to get the number\n           of the next record to print.\n           The default of 1 will print every record.\n           If a SKIP= parm is specified, it will be used for all sub-\n           sequent default SKIP= parms until another SKIP= parm is\n           encountered.\n           The SKIP= parm must be coded before the STOP= parm in a\n           SKIP, START, STOP parameter set.\n\n           STOP=n           The default is 100\n\n           Where n is a 1 to 6 digit value representing the record\n           number to stop printing at.\n           To stop printing at end of file, code STOP=EOF.\n\n           TITLE=t          The default is dataset name and volume serial\n                            number(s).\n                            Title must be the last parameter coded.\n\n           Where t is a character string that will be used in place of\n           the default title.\n0                                         - 3 -\n1     FILEDUMP REFERENCE MANUAL\n-\n                              EXAMPLES\n+                             ________\n0                             Example 1\n\n           //STEP1 EXEC PGM=FILEDUMP,REGION=20K\n           //STEPLIB DD DSN=SYS9.UTIL.LOAD,DISP=SHR\n           //SYSPRINT DD SYSOUT=A\n           //SYSUT1   DD DISP=SHR,DSN=DNN.SOURCE(MYDATA)\n\n           The first 100 records of the member MYDATA on the dataset\n           DNN.SOURCE will be printed after a complete description\n           of the dataset.\n\n                              Example 2\n\n           //STEP1  EXEC PGM=FILEDUMP,REGION=20K,PARM=('STOP=10',\n           //   'START=100,SKIP=10,STOP=900,START=1000,SKIP=1',\n           //   'TITLE=I MAKE WORK FOR MYSELF')\n           //STEPLIB DD DSN=SYS9.UTIL.LOAD,DISP=SHR\n           //SYSPRINT DD SYSOUT=A\n           //SYSUT1   DD DSN=VOLUME.TEST,UNIT=2400-3,VOL=SER=012345,\n           //            DISP=(OLD,KEEP)\n\n           The information on the tape labels, including creation date\n           will be printed, followed by:\n\n           1) The first 10 records,\n           2) Every 10th record from 100 to 900,\n           3) Record 1000 to end of file.\n\n           Note that STOP=EOF is the default after the first STOP=\n           is coded.\n           Note that SKIP=1 is coded to go back to printing every\n           record from 1000 on.\n\n                              Example 3\n\n           //STEP1  EXEC PGM=FILEDUMP,REGION=20K,PARM='C,STOP=EOF'\n           //STEPLIB DD DSN=SYS9.UTIL.LOAD,DISP=SHR\n           //SYSPRINT DD SYSOUT=A\n           //SYSUT1   DD DSN=DNN.MYFILE,DISP=SHR\n           //SYSUT2   DD DSN=COPY.OF.MYFILE,UNIT=2400-3,DISP=(NEW,KEEP),\n           //            DCB=(RECFM=FB,LRECL=(80,BLKSIZE=4000)\n\n           All records on the input file will be copied to the output file.\n\n\n\n\n\n\n\n\n\n\n\n\n0                                         - 4 -\n1     FILEDUMP REFERENCE MANUAL\n-\n           RETURN CODES\n+          ______ _____\n\n               16 (Hex 10) - Parm field on EXEC card has invalid parameters.\n                             Check error messages.\n\n               88 (Hex 58) - Error occurred while processing tape label\n                             If SYSUT1 is tape input. rerun the job.\n\n             1111 (Hex 457)- Unsuccessful open for SYSPRINT or SYSUT1.\n\n             2222 (Hex 8AE)- Unsuccessful open for SYSUT2.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0                                         - 5 -\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HOWHDUMP": {"ttr": 16904, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x13B\\x00I\\x00I\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T13:42:00", "lines": 73, "newlines": 73, "modlines": 0, "user": "RH87944"}, "text": "\n\n\n  HDUMP is a macro/program  used to dynamically dump memory in a\n  running program. It can be used to help determine what is going on\n  in the data portion and the registers at specific points in the\n  program. It can be a usefull debugging tool for obscure problems.\n\n  HDUMP is used as follows:\n\n  A) To include HDUMP in the source program.....\n\n     1) Add RH87944.SOURCE.CNTL to the SYSLIB dd....\n     2) Add a COPY HDUMP assembler statement at the beginning of the\n        program. NOTE...you cannot use register 13 as a base register\n        if you use HDUMP.\n     3) Add an HDUMP macro to the source at the point you want the\n        dump to be taken.\n\n         HDUMP &DCB,&START,&STOP,&DISPO,&DISPC,&V=NO,&TITLE=\n\n               &DCB   is the name for the output DD and dcb.\n               &START is a register containing the address to dump\n               &STOP  is the length to dump, max is 4095\n               &DISPO is the disposition of the dump dcb\n                      OPEN....The dcb is already open. The dcb will\n                              ALWAYS be opened at the first call to\n                              HDUMP. This would be use for subsequent\n                              invocations of HDUMP.\n                      Anything else means issue an OPEN for the dcb.\n               &DISPC is the disposition at the end of the macro\n                      OPEN....The dcb is to be left open for more\n                              calls to HDUMP.\n                      CLOSE...This is the last invocation of HDUMP.\n                              Close the dcb.\n               &V=YES will generate a control block set(except dcb)\n                      every time the macro is called\n               &TITLE is a title to be printed before the dump\n\n         An example usage would be:\n\n         1)    Dump 1024 bytes starting at label MESSAGES (a dcb)..\n               The 'OUTDCB' file is not open, and should be left\n               open at the end of the macro.\n\n              LA    R3,MESSAGES        R3 = ADDRESS TO DUMP       DEBUG\n              HDUMP OUTDCB,R3,1024,NOTOPEN,OPEN                   DEBUG\n              ...\n              ...   more of your code\n              ...\n\n         2)    Dump 1024 bytes starting at the address stored\n               at MESSAGES+44. (a deb)\n               The 'OUTDCB' file is open, and should be closed\n               at the end of the macro.\n\n              L     R3,MESSAGES+44     R3 -> TO DEB               DEBUG\n              HDUMP OUTDCB,R3,1024,OPEN,CLOSE                     DEBUG\n\n         3)    Dump the just the registers...\n\n              HDUMP OUTDCB,0,0,TITLE='DUMP JUST THE REGS\"         DEBUG\n\n\n  B) To activate HDUMP at execution time.....\n\n     1) Concatenate HALL.LINKLIB to the STEPLIB dd..\n     2) Add a //&DCB  DD SYSOUT=  jcl statement.\n        ...eg....//OUTDCB DD SYSOUT=A\n        If you have an open output dcb, such as SYSPRINT, you can ADD\n        HDUMP output to it.\n\n     NOTE. If you forget these, you will not get any output.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HOWPRINT": {"ttr": 16907, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x02\\x9f\\x00\\x99\\x02\\x9f\\x08V\\x00[\\x00[\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-01-29T00:00:00", "modifydate": "1999-01-29T08:56:00", "lines": 91, "newlines": 91, "modlines": 0, "user": "RH87944"}, "text": "//DCFPRINT JOB (87944,348496),'R.HALL.S1BL',\n//         MSGCLASS=A,\n//         GROUP=*,USER=*,PASSWORD=*\n/*ROUTE PRINT R7\n/*JOBPARM      K=0,COPIES=1\n//*\n//*   DSN=RH87944.SOURCE.CNTL(HOWPRIN2)\n//*\n//*   FOR THE NEW LEXMARK PRINTER\n//*\n//*  /*OUTPUT F306 DUPLEX=YES,FLASH=NONE,COPIES=1\n//*  /*OUTPUT *    PMODE=P,CHARS=TS12,TWOUP=NO\n//*\n//*    THE FOLLOWING JCL IS USED TO PRINT ON THE 3816 OR THE NEW 3825\n//*\n//*    THE //JES DD INDICATES HOW TO PRINT THE JCL.\n//*    JESDS= CAN BE ALL, LOG, JCL, OR MSG\n//*\n//*    THE OUT1 AND OUT1 DD'S ARE USED TO PRINT ALL OR SOME, OF THE\n//*    INDIVIDUAL OUTPUT FILES.\n//*\n//*    THE //SYSPRINT DD SHOWS HOW TO USE THE  //OUT1/OUT2 INFO....\n//*\n//*JES    OUTPUT JESDS=ALL,PAGEDEF=P1E100,FORMDEF=P1E000\n//*UT1   OUTPUT DEFAULT=NO,COPIES=1,FORMS=X3NA,CLASS=1,\n//OUT1   OUTPUT DEFAULT=NO,COPIES=1,CLASS=A,          LANDSCAPE 67X138\n//             PAGEDEF=L1C100,FORMDEF=L1C000\n//OUT2   OUTPUT DEFAULT=NO,COPIES=1,CLASS=A,          PORTRAIT 88X96\n//             PAGEDEF=P1E100,FORMDEF=P1E000\n//OUT3   OUTPUT DEFAULT=NO,COPIES=1,CLASS=A,          PORTRAIT 64X80\n//             PAGEDEF=P1B000,FORMDEF=P1B000\n//OUT4   OUTPUT FORMDEF=DCF,LINECT=0          FOR LASER/DCF, SYSOUT=1\n//*\n//*\n//*         IF YOU WANT MORE THAN 1 COPY, CHANGE \"PRINT(1,A)\" IN LINE\n//*         43 TO THE NUMBER OF COPIES YOU WANT..EG..\"PRINT(5,A)\"\n//*         WOULD GIVE YOU 5 COPIES.\n//*\n//DCF     EXEC PGM=IKJEFT01,\n//             DYNAMNBR=25,\n//             REGION=2048K\n//STEPLIB   DD DISP=SHR,\n//             DSNAME=SYSPP.DCF.PROD.DCFLOAD\n//          DD DISP=SHR,\n//             DSNAME=SYS9.LOADLIB\n//SYSHELP   DD DISP=SHR,\n//             DSNAME=SYS9.HELP\n//          DD DISP=SHR,\n//             DSNAME=SYS1.HELP\n//SYSPROC   DD DISP=SHR,\n//             DSNAME=SYS9.SYSPROC\n//SCRPTLIB  DD DISP=SHR,\n//             DSNAME=HALL.DCF.MACLIB\n//          DD DISP=SHR,DSNAME=SYSPP.DCF.PROD.MACLIB\n//SYSTSPRT  DD SYSOUT=*,COPIES=1\n//SYSPRINT  DD SYSOUT=*\n//*YSPRINT DD SYSOUT=(,),OUTPUT=*.OUT3,\n//*YSPRINT DD SYSOUT=(,),OUTPUT=*.OUT3,\n//* DCB=(RECFM=VBM,LRECL=00255,BLKSIZE=03156,OPTCD=J)\n//*\n//SYSTSIN   DD  *\n SCRIPT 'RH87944.SOURCE.CNTL(HOWBACK)' -\n         BIND(11 5) -\n         DEVICE(3800N6) -\n         FILE(DCFPRINT.LIST) -\n         INDEX -\n         M(D I T) -\n         QUIET -\n         SYSVAR(H YES) -\n         TWOPASS -\n         PROF('SYSPP.DCF.PROD.MACLIB(DSMPROF4)') -\n         CONTINUE;\n/*\n//*      SEARCH('SC57057.ACCUDCF.LIB') -\n//*      BIND(1I 1.1I) - ODD EVEN\n//*      BIND(1 5) -\n//*      PROF('SYS9.DCF.MACLIB(DSMPROF3)') -\n//*---------------------------------------------------------------------\n//*  HARDCOPY PRINT ON XEROX DRILLED, UNSTAPLED PAPER\n//*---------------------------------------------------------------------\n//STEP1 EXEC PGM=IEBGENER,COND=(8,LT)\n//SYSPRINT DD SYSOUT=*\n//*YSUT2   DD SYSOUT=(*,,F306),\n//* DCB=(RECFM=VBM,LRECL=00255,BLKSIZE=03156,OPTCD=J)\n//*YSUT2   DD SYSOUT=(,),OUTPUT=*.OUT3,\n//SYSUT2   DD SYSOUT=(F),OUTPUT=*.OUT3,DEST=PSFSC002, NEW LEXMARK...\n//  DCB=(RECFM=VBM,LRECL=00255,BLKSIZE=03156,OPTCD=J)\n//SYSIN  DD DUMMY\n//SYSUT1 DD DSN=HALL.DCFPRINT.LIST,DISP=(OLD,DELETE)\n//\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HOWSETDT": {"ttr": 17153, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x13G\\x00U\\x00U\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T13:47:00", "lines": 85, "newlines": 85, "modlines": 0, "user": "RH87944"}, "text": "August 19, 1997\n\nSETDATE is used to put the current date into a control record or\nto pass the current date to a calling program in the format specified.\nSETDATE also prints the date to //SYSPRINT.\n\nThe control record file can contain only 1 record.\n\nNote that SETDATE does not insert the date, it REPLACES any data\nwhere the date is to go.\n\nThe following jcl is needed to run SETDATE.\n\n     //STEP1    EXEC PGM=SETDATE\n     //STEPLIB  DD DSN=SYS9.IMSUTIL.LOAD,DISP=SHR\n     //SYSPRINT DD SYSOUT=*\n     //DATEREC DD DSN=file.containing.date.record,DISP=SHR\n\nIf the //DATEREC file is not specified, SETDATE will replace\nthe format after the FMT= parm with todays date.\nFor example, if you pass SETDATE a parm of FMT=MTH DD YYYY,\nSETDATE will return FMT=AUG 19 1997.\n\nThe parameters that can be passed to SETDATE are:\n\n               POS=nnn         Decimal position of where to put\n                               the date.\n\n               VAR=variable    Find 'variable' and then put\n                               the date after it.\n\n               FMT=mmddyy      Format for the date field.\n                   mmddyyyy    If not specified, the default is\n                   ddmmyy      mmddyy.\n                   ddmmyyyy    Pretty well any date format can be\n                   mm/dd/yy    specified. Both separators must be\n                   mm-dd-yy    the same.\n                   mm/dd/yyyy\n                   dd/mm/yy\n                   dd/mm/yyyy\n                   dd mth yyyy\n                   yyyy mth dd ...etc....\n\nAny other parms are invalid\nIf no parms are specified, the defaults will be\n      PARM='POS=1,FMT=MMDDYY'\n\n\n    To call SETDATE from PL/I, use the following, or something\n    similar....\n\n /*\n  *      SINCE  SETDATE IS A NORMAL ASSEMBLER PROGRAM, IT MUST\n  *      HAVE THE OPTIONS(ASSEMBLER) PARM.\n  *      NOTE THAT THE LTH HERE IS 2 MORE THAN THE LTH OF THE PARM\n  */\n    DCL  SETDATE        EXTERNAL ENTRY(CHAR(16))         /* */\n                        OPTIONS(ASSEMBLER,INTER);\n\n       DECLARE\n          I_PTR\n                          POINTER ;\n    DECLARE\n       1 PARM,\n           3   PARM_LTH           FIXED BIN INIT(14) ,\n           3   FILL2     CHARACTER(4) INIT('FMT='),\n           3   PARM_DATE CHARACTER(10) INIT('MM/DD/YYYY'),\n\n\n         SETDATE_PARM             BASED (I_PTR)\n                                  CHARACTER(16) ;\n\n /*               STEPLIB TO SYS9.IMSUTIL.LOAD FOR SETDATE          */\n\n          FETCH SETDATE ;         /* LOAD SETDATE                   */\n\n /*\n  *            CALL SETDATE TO GET DATE\n  */\n          I_PTR =  ADDR(PARM) ;\n          CALL SETDATE(SETDATE_PARM) ;\n\nAt this point, the  MM/DD/YYYY at PARM_DATE is todays date...\n....08/19/1997....\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HOWTCOPY": {"ttr": 17156, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x13I\\x01\\xce\\x01\\xce\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T13:49:00", "lines": 462, "newlines": 462, "modlines": 0, "user": "RH87944"}, "text": "//HOWTCOPY  JOB\n//*\n//*\n/*JOBPARM  K=0\n/*ROUTE PRINT U1956\n//*\n//*    THE FOLLOWING JCL IS USED TO PRINT ON THE 3816 OR THE NEW 3825\n//*\n//*    THE //JES DD INDICATES HOW TO PRINT THE JCL.\n//*    JESDS= CAN BE ALL, LOG, JCL, OR MSG\n//*\n//*    THE OUT1 AND OUT1 DD'S ARE USED TO PRINT ALL OR SOME, OF THE\n//*    INDIVIDUAL OUTPUT FILES.\n//*\n//*    THE //EREPPT DD SHOWS HOW TO USE THE  //OUT1/OUT2 INFO....\n//*\n//*JES    OUTPUT JESDS=ALL,PAGEDEF=P1E100,FORMDEF=P1E000\n//*UT1   OUTPUT DEFAULT=NO,COPIES=1,FORMS=X3NA,CLASS=1,\n//OUT1   OUTPUT DEFAULT=NO,COPIES=1,CLASS=A,          LANDSCAPE 67X138\n//             PAGEDEF=L1C100,FORMDEF=L1C000\n//OUT2   OUTPUT DEFAULT=NO,COPIES=1,CLASS=A,          PORTRAIT 88X96\n//             PAGEDEF=P1E100,FORMDEF=P1E000\n//OUT3   OUTPUT DEFAULT=NO,COPIES=10,CLASS=A,         PORTRAIT 64X80\n//             PAGEDEF=P1B000,FORMDEF=P1B000\n//OUT4   OUTPUT FORMDEF=DCF,LINECT=0          FOR LASER/DCF, SYSOUT=1\n//*\n//*REPPT   DD SYSOUT=(,),OUTPUT=*.OUT2\n//*YSUT2   DD SYSOUT=1,OUTPUT=*.OUT4         FOR LASER PRINTER\n//*\n//STEP1  EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//*\n//*    NOTE....THIS JCL IS SET UP TO USE THE XEROX PRINTER, AND TO\n//*            PRINT ON BOTH SIDES OF THE PAPER.\n//*\n//*            IF YOU DO NOT WANT YOUR MANUALS ON 8 1/2 X 11\n//*            3-HOLE PAPER, PRINTED ON BOTH SIDES, REVERSE\n//*            THE SYSUT2 STATEMENTS SHOWN BELOW, OR MODIFY\n//*            THE JCL TO DO WHAT YOU WANT.\n//*\n//*YSUT2 DD SYSOUT=*,\n//*YSUT2 DD SYSOUT=(*,,F306),\n//SYSUT2 DD SYSOUT=(,),OUTPUT=*.OUT3,\n//          DCB=(RECFM=FA,LRECL=80,BLKSIZE=80)\n//SYSUT1 DD *\n1\n-\n-\n                                     Copyright 1986 by\n0                                 Diversified Developments\n0                                   All Rights Reserved\n-\n0                                       1st Edition\n                                       October, 1986\n\n-\n\n\n\n\n\n\n\n-\n-\n-\n-                               TAPECOPY REFERENCE MANUAL\n0                                       RELEASE 1.0\n-\n\n0                                Diversified Developments,\n                                    1151 Palmer Road,\n                                      Victoria, B.C.\n                                         V8P-2H5\n0\n                                  randy.hall@i.am\n1     TAPECOPY REFERENCE MANUAL\n-\n0          Preface\n+          _______\n0          This publication,   the TAPECOPY REFERENCE  MANUAL,  1st\n           edition, October, 1986,  describes how to use the TAPECOPY\n           tape file utility program.\n-\n           Who This Publication Is For\n+          ___ ____ ___________ __ ___\n-          This publication is provided by Diversified Developmemts\n           to users of the  TAPECOPY utility program and is for the\n           exclusive use of those users.\n-\n0\n0\n\n0\n\n\n\n\n0\n\n\n0\n\n0\n\n\n\n0\n\n-\n-\n-\n\n\n-\n                                       -I-\n1     TAPECOPY REFERENCE MANUAL\n-\n0          TABLE OF CONTENTS\n+          _____ __ ________\n-\n0          Introduction . . . . . . . . . . . . . . . . . . . . . . . . . 1\n              Using This Manual . . . . . . . . . . . . . . . . . . . . . 1\n              Program Description . . . . . . . . . . . . . . . . . . . . 1\n0          Detailed Description . . . . . . . . . . . . . . . . . . . . . 2\n              Jcl . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n              Parameters. . . . . . . . . . . . . . . . . . . . . . . . . 3\n              Return Codes. . . . . . . . . . . . . . . . . . . . . . . . 5\n0\n0\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0                                     -II-\n1     TAPECOPY REFERENCE MANUAL\n-\n0          Introduction\n+          ____________\n                                                                    Introduction\n-          The program TAPECOPY is used to produce a formatted report on\n           the files on a tape.\n\n           It can also be used to copy all or specific files of the input\n           file to an output file.\n-          Using This Manual\n+          _____ ____ ______\n-          This manual is intended  primarily   as  a  reference  manual.\n-\n-          Program Description\n+          _______ ___________\n-\n           TAPECOPY can be used for the following purposes:\n\n           1) It can be used to print information about data sets on\n              a tape, or,\n           2) It can be used to print information and to copy data\n              sets from one tape to 1 or more output tapes, or,\n           3) It can be used to copy data sets from an input tape\n              to 1 or more output tapes without printing any\n              information, or,\n           4) It can be used to reset the block count in the trailer\n              label of a tape that is causing 237 abends. This is\n              automatically done when the tape is copied to a\n              new tape. A message will be printed showing the old\n              block count and the new count, or,\n           5) It can  be used to print records from each file on\n              the tape in a hexadecimal or a standard print format.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0                                         - 1 -\n1     TAPECOPY REFERENCE MANUAL\n-\n                              JCL Statements\n+                             ___ __________\n\n\n           The following JCL is required to run TAPECOPY:\n\n           //COPY    EXEC PGM=TAPECOPY,PARM='parameters'\n           //STEPLIB   DD DSN=HALL.LINKLIB,DISP=SHR\n           //SYSPRINT  DD SYSOUT=A\n           //MASTER    DD UNIT=TAPE,DISP=OLD,DSN=first.data.set.name,\n           //             VOL=SER=if not cataloged\n\n           The above JCL is all that is necessary if PARM='DEBE'\n           is coded.\n\n           If PARM='DUMP' is coded, the following JCL must be added\n           to that above:\n\n           //TAPE1     DD DSN=any.valid.data.set.name,\n           //             UNIT=TAPE,DISP=(NEW,CATLG or KEEP)\n\n           If 2 copies of the MASTER tape are required, add the\n           following JCL:\n\n           //TAPE2     DD DSN=any.valid.data.set.name,\n           //             UNIT=TAPE,DISP=(NEW,CATLG or KEEP)\n\n           A valid data set name must be supplied on the TAPE1 and\n           TAPE2 DD statements if LABEL=SL (the default) is used,\n           otherwise the system will not keep the tape.\n\n           If DSN= is coded on the MASTER jcl statement, the job\n           can be run in CLASS=A\n           If the dsn of the first data set you want is not known,\n           LABEL=(,BLP) must be added to the //MASTER jcl and the\n           job must be run in CLASS=Z\n\n           NOTE ...\n           Unless otherwize specified, DCB information for NL and BLP\n           MASTER tapes defaults to :\n           DCB=(DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=32000)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0                                         - 2 -\n1     TAPECOPY REFERENCE MANUAL\n-\n                              Parameters\n+                             __________\n0\n           The following parameters can be coded in the PARM= field:\n\n             DEBE - This causes information only to be printed\n\n             DUMP - This causes information to be printed and the\n                    tape to be copied\n\n          NEWVOL= - The specified 6 character volume serial number\n                    will be put on the output tapes\n\n            COPY= - Indicates which files are to be processed from\n                    the input MASTER tape.\n                    if COPY=x is coded, files 1 through x will be\n                    processed.\n                    If COPY=(x,y) is coded, files x through y will\n                    be processed.\n          NEWSEQ= - If the files are to be copied to the output\n                    tapes, the starting output file sequence number\n                    can be specified with NEWSEQ=.\n                    A maximum of 4 characters can be specified.\n                    the default starting sequence will be the\n                    sequence number specified in the LABEL=\n                    parameter on the //TAPE1 JCL statement.\n\n           NODUMP - If NODUMP is specified, the complete MASTER tape\n                    will be copied to the output tapes and no\n                    information will be printed.\n                    No file sequence checking will be done.\n                    All input files will be copied from the input tape\n                    to all output tapes.\n\n         IGNOREOF - If the MASTER tape has been written over, IGNOREOF\n                    will cause TAPECOPY to ignore the first end of\n                    file it encounters and to continue reading the tape.\n\n                    ... NOTE ...\n                    If there is only 1 eof on the tape, IGNOREOF will\n                    cause TAPECOPY to read off the end of the reel.\n\n\n             TEST - Will cause the following events to occur :\n\n                    The message 'TAPE MARK READ' to be printed\n                    when a tape mark is read on the input tape.\n\n                    The message 'TAPE MARK WRITTEN AFTER .... RECORDS'\n                    to be printed when a tape mark is written on\n                    the output tapes.\n\n                    If the PRINT= parm is supplied, label records\n                    will be printed.\n\n\n\n0                                         - 3 -\n1     TAPECOPY REFERENCE MANUAL\n-\n           RENAME - Indicates that the dataset name on the output\n                    file is to be changed. The new file name will\n                    be obtained from 1 of 2 sources...\n                      1) If the MASTER tape contains only 1 file,\n                         the new dataset name may be obtained from\n                         the DSN specified on the JCL for the TAPE1\n                         or the TAPE2 DD statement.\n                         If TAPE1 and TAPE2 DD's are used, the dsname\n                         from TAPE2 will be used on both output tapes\n                      2) If the MASTER is a multi-file tape or a single\n                         file tape, the SLPARMS file described\n                         in the 'SL' parm below will be used for the\n                         dataset names. For the RENAME parm, only the\n                         first 17 characters of each SLPARMS record\n                         are required.\n\n               SL - Indicates creation of a standard labelled\n                    output tape. All DCB parameters must be specified\n                    through the SLPARMS file. The SLPARMS records\n                    must be coded as follows :\n\n                     1-17 = The last 17 characters of the dataset name\n                       18 = blank\n                    19-22 = File sequence number -eg- 0001\n                       23 = blank\n                    24-25 = Recfm -eg- FB (FR for FBS)\n                       26 = blank\n                    27-31 = Block size -eg- 04000\n                       32 = blank\n                    33-37 = Record length -eg- 00080\n                       38 = blank\n                    38-80 = blank\n\n                    There must be 1 SLPARMS record for each file\n                    to be copied. If there is not, the TAPECOPY\n                    job will be terminated.\n\n           PRINT= - Indicates the number of records to be printed\n                    from each file. PRINT=ALL will cause all\n                    records of each file to be printed.\n                    A maximum of 4 characters can be specified.\n\n                  NOTE ...\n                    If the records are longer than 132 characters,\n                    they will be printed in 132 byte chunks.\n\n\n              HEX - Causes records printed to be printed in a\n                    hex dump format.\n                  - If there is a //HEXPRINT DD SYSOUT=A dd statement\n                    in the job stream, the hex listing will be printed\n                    there rather than on SYSPRINT with the DEBE\n                    information.\n\n\n\n\n0                                         - 4 -\n1     TAPECOPY REFERENCE MANUAL\n-\n           RETURN CODES\n+          _______ ____\n0\n           TAPECOPY can produce the following abend codes:\n\n            U500 - SYSPRINT  could not be opened. Ensure that the\n                   SYSPRINT JCL is correct.\n\n           U1000 - An I/O error occurred reading the MASTER file.\n\n           U1111 - An error occurred processing a tape label\n\n           U1500 - An I/O error occurred when writing to SYSPRINT.\n\n           U2000 - An I/O error occurred on unit xxx\n\n           U3000 - An error occurred when writing to an output tape.\n\n           U4000 - The MASTER tape file could not be opened. Verify\n                   that the MASTER JCL is correct.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0                                         - 5 -\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HOWVSPLT": {"ttr": 17164, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x13Q\\x02\\x0f\\x02\\x0f\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T13:51:00", "lines": 527, "newlines": 527, "modlines": 0, "user": "RH87944"}, "text": "//HOWVSPLT  JOB\n//*\n//*\n/*JOBPARM  K=0\n/*ROUTE PRINT U1956\n//*\n//*UT1   OUTPUT DEFAULT=NO,COPIES=1,FORMS=X3NA,CLASS=1,\n//OUT1   OUTPUT DEFAULT=NO,COPIES=1,CLASS=A,          LANDSCAPE 67X138\n//             PAGEDEF=L1C100,FORMDEF=L1C000\n//OUT2   OUTPUT DEFAULT=NO,COPIES=1,CLASS=A,          PORTRAIT 88X96\n//             PAGEDEF=P1E100,FORMDEF=P1E000\n//OUT3   OUTPUT DEFAULT=NO,COPIES=1,CLASS=A,          PORTRAIT 64X80\n//             PAGEDEF=P1B000,FORMDEF=P1B000\n//OUT4   OUTPUT FORMDEF=DCF,LINECT=0          FOR LASER/DCF, SYSOUT=1\n//*\n//*OUTPUT F306 PDE=TEXT,FLASH=NONE,DUPLEX=YES,COPIES=10\n//*\n//STEP1  EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//*\n//*    NOTE....THIS JCL IS SET UP TO USE THE XEROX PRINTER, AND TO\n//*            PRINT ON BOTH SIDES OF THE PAPER.\n//*\n//*            IF YOU DO NOT WANT YOUR MANUALS ON 8 1/2 X 11\n//*            3-HOLE PAPER, PRINTED ON BOTH SIDES, REVERSE\n//*            THE SYSUT2 STATEMENTS SHOWN BELOW, OR MODIFY\n//*            THE JCL TO DO WHAT YOU WANT.\n//*\n//*YSUT2 DD SYSOUT=*,\n//*YSUT2 DD SYSOUT=(*,,F306),\n//*         DCB=(RECFM=FA,LRECL=80,BLKSIZE=80)\n//SYSUT2   DD SYSOUT=(,),OUTPUT=*.OUT3,\n//          DCB=(RECFM=FA,LRECL=80,BLKSIZE=80)\n//*YSUT2   DD SYSOUT=1,OUTPUT=*.OUT4         FOR LASER PRINTER\n//SYSUT1 DD *\n1\n-\n-\n                                     Copyright 1986 by\n0                                 Diversified Developments\n0                                   All Rights Reserved\n-\n0|                                      2nd Edition\n |                                      July, 1986\n\n-\n\n\n\n\n\n\n\n-\n-\n-\n-                                 VSPLIT REFERENCE MANUAL\n0|                                      RELEASE 2.0\n-\n\n0                                Diversified Developments,\n                                    1151 Palmer Road,\n                                      Victoria, B.C.\n                                         V8P-2H5\n0\n                                  randy.hall@i.am\n1\n-\n0|    MODIFICATION LOG\n+|    ________________\n0|Rev no.     Date      Description of Revision  :ehp2.\n+|______________________________________________________\n0|  01     Oct    1986  First issue\n0|  02     July   1996  Second issue ...\n |                      ...Added comment check in input verify\n |                         routine. comments can start with * or /.\n |                      ...Added START=HEX parm that says start at\n |                         offset 0 and use hexadecimal start position\n |                         note...START=HEX must be first control card.\n1     VSPLIT REFERENCE MANUAL\n-\n0          Preface\n+          _______\n0|         This publication,   the VSPLIT REFERENCE  MANUAL,  2nd\n |         edition, July, 1996,  describes how to use the VSPLIT\n |         variable length file utility program.\n-\n           Who This Publication Is For\n+          ___ ____ ___________ __ ___\n-          This publication is provided by Diversified Developmemts\n           to users of the  VSPLIT utility program and is for the\n           exclusive use of those users.\n-\n0\n0\n\n0\n\n\n\n\n0\n\n\n0\n\n0\n\n\n\n0\n\n-\n-\n-\n\n\n-\n                                       -I-\n1     VSPLIT REFERENCE MANUAL\n-\n0          TABLE OF CONTENTS\n+          _____ __ ________\n-\n0          Introduction . . . . . . . . . . . . . . . . . . . . . . . . . 1\n              Using This Manual . . . . . . . . . . . . . . . . . . . . . 1\n              Program Description . . . . . . . . . . . . . . . . . . . . 1\n0          Detailed Description . . . . . . . . . . . . . . . . . . . . . 2\n              Jcl . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n              Control Cards . . . . . . . . . . . . . . . . . . . . . . . 3\n              Control Cards Example . . . . . . . . . . . . . . . . . . . 6\n0\n0\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0                                      -II-\n1     VSPLIT REFERENCE MANUAL\n-\n0          Introduction\n+          ____________\n                                                                    Introduction\n-          The program VSPLIT is used to process data  in  a  variable\n           length file.\n\n-          Using This Manual\n+          _____ ____ ______\n-          This manual is intended  primarily   as  a  reference  manual.\n-\n-          Program Description\n+          _______ ___________\n-\n\n           VSPLIT can be used to split records from a variable length file\n           to a SYSOUT file or to another variable length file.\n           VSPLIT can also be used to create a fixed length file from a\n           variable length file.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0                                         - 1 -\n1     VSPLIT REFERENCE MANUAL\n-\n0          DETAILED DESCRIPTION\n+          ____________________\n                                                            Detailed Description\n                               JCL\n+                              ___\n\n           To execute VSPLIT the following JCL is required:\n\n           //jobname    JOB\n           //STEPNAME   EXEC PGM=VSPLIT,REGION=60K\n           //STEPLIB    DD   DSN=SYS9.UTIL.LOAD,DISP=SHR\n           //SYSPRINT   DD   SYSOUT=A\n           //TAPEIN     DD   DSN=....etc.\n           //OUT1\n           //OUT7\n           //SYSIN      DD  *\n           control cards\n           //\n\n           The OUT1 to OUT7 DD cards are:\n           //OUT1       DD  SYSOUT=A\n           //OUT2       DD  SYSOUT=A\n           //OUT3       DD  SYSOUT=A\n           //OUT4       DD  DSN=, UNIT=, DISP=, SPACE=, DCB=\n           //OUT5       DD  ''\n           //OUT6       DD  ''\n           //OUT7       DD  ''\n\n           For OUT4, OUT5, OUT6:\n           DSN= Any name up to 44 characters long consisting of\n                1-8 chars.1-8 chars.etc\n\n           UNIT= TAPE for tape\n                 USER  for permanent disk files\n                 SYSDA   for temporary files\n\n           DISP= (,CATLG) for permanent files\n                 (,PASS)  for temporary files\n\n           SPACE= Is required only if UNIT=SYSDA or USER is specified.\n                 (TRK,(nbr of trks,3),RLSE)\n                 nbr of trks depends on the number of records being split.\n                 if BLKSIZE=3532, there will be 5 blocks per track on a\n                 3350, so 100 blocks would need 20 tracks.\n           DCB=  (LRECL=rec len+4,BLKSIZE=(rec len+4)*blk factor)+4)\n                 eg- if rec len = 1760 and blk factor = 2,\n                 LRECL=1764,BLKSIZE=3532\n\n                 If DCB information is left off OUT4 - OUT7 DCB's, it will\n                 default to the DCB information of the input file.\n\n           For OUT7:\n           DCB=  (RECFM=FB,LRECL=rec len,BLKSIZE=rec len*blk factor)\n                 the VB file is reblocked to the rec len specified in\n                 the LRECL=. If the FB LRECL is larger than the VB LRECL,\n                 the FB record is padded with blanks.\n\n\n0                                         - 2 -\n1     VSPLIT REFERENCE MANUAL\n-\n                               CONTROL CARDS\n+                              _______ _____\n\n           VSPLIT is controlled by the following control cards:\n |         Comments can now be included in the control statements.\n |         Any statement with * or / in column 1 is ignored.\n\n |         START=RDW or HEX\n |         * THIS IS A COMMENT\n           INPUT=TAPEIN,CONTROL=(CF1 control data,....CF5 control data)\n           OUTPUT=OUT1,OUT2,.....OUT7\n           START=RDW\n           SELECT=OUT1,CF1=,......CF5=\n           HEAD1=\n           HEAD2=\n           HEAD3=\n\n           The INPUT= statement is used to set up the selection criteria\n           for the 1 to 5 control fields.\n\n           The OUTPUT= statement determines which of the 7 output\n           files will be used.\n\n |         The START=HEX statement indicates that the search starts\n |                       at offset 0(the record length field) and that\n |                       the start position is in hexadecimal.\n |                NOTE...the hex start position uses 2 chars..eg..05.\n |\n |         The START=RDW statement indicates that the search starts\n |                       at offset 0(the record length field) and that\n |                       the start position is in decimal.\n |\n |         If  START=RDW or START=HEX is not specified, the search\n |                       starts at offset 5(the record data) and the\n |                       start position is in decimal.\n\n           The SELECT= statement is used to determine which output\n           file will receive the data selected by the specified 1\n           to 5 control fields.\n\n           The HEAD1= statement is used to change the default heading\n           on the OUT1 listing.\n\n           The HEAD2= statement is used to change the default heading\n           on the OUT2 listing.\n\n           The HEAD3= statement is used to change the default heading\n           on the OUT3 listing.\n\n           The following RESTRICTIONS must be observed:\n\n           OUT1, OUT2, OUT3 can only be SYSOUT=A files.\n\n           OUT4, OUT5, OUT6 can only be VB files on TAPE or DISK.\n\n           OUT7 can only be an FB file on TAPE or DISK.\n\n           On the OUTPUT= card, the OUT's must be in sequence.\n\n0                                         - 3 -\n1     VSPLIT REFERENCE MANUAL\n-\n\n           There can be 1 to 5 control fields in the CONTROL=(start,length,type)\n           parameter.\n\n           START\n           START is the starting position within the record.\n           If the START position is outside the length of the VB record,\n           it is treated the same as condition not met.\n\n           LENGTH\n           LENGTH is the number of characters in the field.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0                                         - 4 -\n1     VSPLIT REFERENCE MANUAL\n-\n           The maximum length allowed for alphanumeric fields is 111.\n\n           The maximum length allowed for packed or hexadecimal fields is 16.\n\n           For packed fields, the length is the number of digits in the\n           field, not the number of bytes in the field...eg...a 2 byte\n           packed field will hold 3 digits...123c, so the length is 3, not 2.\n\n           To specify a positive(+) or a negative(-) packed number, the last\n           digit must consist of the number and a 12 or 11 punch. This can\n           be accomplished by using the character '{' (x'c0') and the letters\n           'A - I' to designate +0 to +9  or the character '}' (x'd0') and the\n           letters 'J - R' to designate -0 to -9. For example, to select +1230,\n           you would code 123{, and to select -1230 you would code 123}. To\n           select +1234 you would code 123D, and to select -1879, you would\n           code 187R.\n           The corresponding letters for the positive and negative numbers are:\n                +0 = {            -0 = }\n                +1 = A            -1 = J\n                +2 = B            -2 = K\n                +3 = C            -3 = L\n                +4 = D            -4 = M\n                +5 = E            -5 = N\n                +6 = F            -6 = O\n                +7 = G            -7 = P\n                +8 = H            -8 = Q\n                +9 = I            -9 = R\n\n           For hexadecimal fields, the length is a multiple of 2, as it takes\n           2 digits to represent 1 hexadecimal digit...eg...x'12' would be\n           12 in your control field, so the length is 2, not 1.\n\n           TYPE\n           the TYPE specified can be 1 of the following:\n           'A' to indicate alphanumeric data,\n           'P' to indicate packed data,\n           'H' to indicate hexadecimal data.\n\n           There can be 1 to 5 SELECT statements for each OUT file.\n\n           Records can be selected on:\n             1- All conditions           - CF1=ALL,...CF5=...\n             2- Equal conditions         - CF1=(= ),...CF5=...\n             3- Greater than conditions  - CF1=(> ),...CF5=...\n             4- Less than conditions     - CF1=(< ),...CF5=...\n             5- Not equal conditions     - CF1=(# ),...CF5=...\n\n           The ability to put a heading on OUT1, OUT2, OUT3 has been included.\n           The control cards are:\n           HEAD1=\n           HEAD2=\n           HEAD3=\n           The headings can be 1-74 characters long. If heading cards are not\n           included, the defaults are:\n              HEAD1=RECORDS SPLIT TO OUT1\n              HEAD2=RECORDS SPLIT TO OUT2\n              HEAD3=RECORDS SPLIT TO OUT3\n0                                         - 5 -\n1     VSPLIT REFERENCE MANUAL\n-\n                        CONTROL CARDS EXAMPLE\n+                       _______ _____ _______\n\n           INPUT=TAPEIN,CONTROL=(1,1,A,59,6,A,72,5,P,32,2,H)\n           OUTPUT=OUT1,OUT2,OUT3,OUT4,OUT7\n           SELECT=OUT1,CF1=ALL\n           SELECT=OUT2,CF2=(>111100)\n           SELECT=OUT3,CF3=(<40406)\n           SELECT=OUT4,CF3=(=40405)\n           SELECT=OUT4,CF4=(=40)\n           SELECT=OUT7,CF1=ALL\n           HEAD1=NEW HEADING FOR OUT1\n\n                        EXAMPLE OF HEX STARTS...\n\n           START=HEX\n           INPUT=TAPEIN,CONTROL=(00,1,A,3A,6,A,47,5,P,1F,2,H)\n           OUTPUT=OUT1,OUT2,OUT3,OUT4,OUT7\n           SELECT=OUT1,CF1=ALL\n           SELECT=OUT2,CF2=(>111100)\n           SELECT=OUT3,CF3=(<40406)\n           SELECT=OUT4,CF3=(=40405)\n           SELECT=OUT4,CF4=(=40)\n           SELECT=OUT7,CF1=ALL\n           HEAD1=NEW HEADING FOR OUT1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0                                         - 6 -\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IUTDEL": {"ttr": 17417, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x13R\\x05\\x98\\x05\\x98\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T13:52:00", "lines": 1432, "newlines": 1432, "modlines": 0, "user": "RH87944"}, "text": "//IUTDEL   JOB\n/*ROUTE  PRINT  R7\n//*\n//*            DSN=CBT.SOURCE(IUTDEL)\n//*\n//S1        EXEC  HLASMCL,CLASS='*',\n//   COND.LKED=(7,LT,ASM)\n//ASM.SYSLIB DD DSN=SYS1.MACLIB\n//   DD DSN=SYS1.MACLIB,DISP=SHR\n//   DD DSN=IMSVS.GENLIB,DISP=SHR\n//   DD DSN=IMSVS.GENLIBA,DISP=SHR\n//   DD DSN=IMSVS.GENLIBB,DISP=SHR\n//*  DD DSN=SYS1.HASPSRC,DISP=SHR\n//   DD DSN=SYS1.AMODGEN,DISP=SHR\n//ASM.SYSIN DD  *\n*\n*              JUNE18/91...ADDED  WILD CHAR FACILITY\n*\n*\n*              THIS VERSION CREATES THE AUDIT DATASET NAME AS &VER.\n*              IUTDEL.AUDIT(0) THEN DYNAMICALLY ALLOCATES IT.\n*\n*              IT ALSO JUST CHECKS FOR 'IMSVS.' TO DETERMINE IF WE\n*              SHOULD ENQ TO PROTECT THE OUTDS DATASET.\n*              THIS WAS DONE TO ACCOMADATE THE DEVL SYSTEM...\n*\n*              TO WORK PROPERLY,  THIS PROGRAM MUST BE IN A LINKLIST\n*              DATASET, AND THE RACF PROFILE FOR IMSVS.TEST.PGMLIBA\n*              MUST BE MODIFIED:\n*                PERMIT 'IMSVS.TEST.PGMLIBA' CLASS(DATASET) ID(*) +\n*                        ACCESS(UPDATE) WHEN(PROG(IUTDEL))\n*\n*              THE PROGRAM NAME MUST BE ADDED TO THE RACF CLASS\n*              PROGRAM, VIA A RACF RDEF COMMAND, WHICH YOU MUST BE\n*              SPECIAL TO RUN, UNLESS IT IS IN SYS1.BCSCLINK,\n*              WHICH IS SET UP SO ANY MEMBER CAN BE RACF'D.\n*                RDEF PROGRAM IUTDEL UACC(READ) +\n*                     ADDMEM('SYS1.SEC.LOAD'/SYS005/NOPADCHK)\n*\n*              SYS1.BCSCLINK IS APF AND LINKLISTED.\n*\n         TITLE '******* EXECUTE PROGRAM IUTDEL ******'\n         SPACE 3\nIUTDEL   CSECT\n         USING *,R15              SET TEMP BASE\n         B     AROUND             BRANCH AROUND DUMP TITLE\n         DC    AL1(EYELTH)\nEYECATCH DC    C'IUTDEL '         PROGRAM NAME\n         DC    C'&SYSDATE'        DATE WRITTEN\n         DC    C' '               BLANK\n         DC    C'&SYSTIME'        TIME WRITTEN\n         DC    C' DYNAMICALLY ALLOCATE THE AUDIT DATASET'\nEYELTH   EQU   *-EYECATCH         LTH OF EYE CATCHER\n         SPACE 1\nAROUND   DS    0H\n         LA    R1,0(0,R1)         CLEAR HI-ORDER BYTE FOR 31 BIT\n         LA    R13,0(0,R13)       CLEAR HI-ORDER BYTE FOR 31 BIT\n         BSM   R14,0              SAVE CURRENT AMODE\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         DROP  R15\n         USING IUTDEL,R12,R11\n         LA    R11,4095(0,R12)    LOAD 2ND BASE REG\n         LA    R11,1(0,R11)       ''\n         L     R2,0(0,R1)         R2 -> TO SYSTEM PARM\n*        LR    R8,R1                   LOAD REGISTER 8 TO PRESERVE\n*                                      POINTER TO COMMAND PROCESSOR\n*                                      PARAMETER LIST\n         GETMAIN R,LV=LDYNAMIC         GETMAIN DYNAMIC WORKAREA\n         LR    R10,R1                  LOAD REGISTER 10 TO PRESERVE\n*                                      POINTER TO WORKAREA\n         ST    R13,4(R10)              STORE ADDRESS OF PREVIOUS\n*                                      SAVEAREA\n         ST    R10,8(,R13)             STORE ADDRESS OF CURRENT\n*                                      SAVEAREA IN PREVIOUS SAVEAREA\n         LR    R13,R10                 LOAD REGISTER 13 WITH ADDRESS OF\n*                                      CURRENT SAVEAREA\n         USING WORKAREA,R13            ESTABLISH ADDRESSABILITY TO\n*        ST    R13,SAVE+4\n*        LA    R13,SAVE\n*\n***********************************************************************\n*                                                                     *\n*        SEE IF A PARM WAS PASSED....                                 *\n*                                                                     *\n***********************************************************************\n*\n         LH    R1,2(0,R2)         R1 = TO PARM LTH\n         LTR   R1,R1              IS THERE A PARM?\n         BZ    NOPARM             NO\n         CLC   =X'0A15',STOWDEL+8 FIND SVC 21?\n         BE    ZAPSVC             YES\n         ABEND 21,,,USER          NO, ABEND\n         SPACE 1\nZAPSVC   MVC   STOWDEL+8(2),=X'1BFF'  CHANGE SVC TO SR 15,15\n         MVC   HEADER3W,=C'WOULD  BE '  CHANGE MSG 1\n         MVC   NOTDEL,=C'NOT '          CHANGE MSG 2\n*\nNOPARM   DS    0H\n         OPEN  (REPORT,(OUTPUT))  OPEN SYSPRINT FILE\n         SPACE 1\n*\n*        GET DATE AND TIME\n*\n*        LOAD  EP=DAYDATE         LOAD DAYDATE ROUTINE\n*        LR    R15,R0             PUT ITS ENTRY ADDRESS IN R15\n         L     R15,=V(DAYDATE)    R15 -> TO DAYDATE ROUTINE\n         CALL  (15),(TIMEDATE),VL CALL DAYDATE\n         MVC   CTLDATE,TDDATE     PUT DATE IN AUDIT RECORD\n         MVC   CTLTIME,TDTIME     PUT TIME IN AUDIT RECORD\n*\n*        GET THE //PGMLIB DATASET NAME\n*\n         RDJFCB PGMLIB            IS THERE A PGMLIB?\n         LTR   R15,R15            WELL???\n         BNZ   RETURN9            NO, NOTHING TO DELETE\n*\n*        CHECK PGMLIB DATASET NAME\n*\n         MVC   TPGMLIB,JFCBDSNM   SET UP DSN FOR ENQ\n         CLC   JFCBDSNM(6),=C'IMSVS.' IS IT ONE OF OUR DATASETS?\n         BNE   OPEN               NO, NO MORE TESTING\n*\n*        GET 1ST PART OF AUDIT DATASET NAME FROM PGMLIB\n*\n         LA    R15,JFCBDSNM+6     R15 -> TO DSN AFTER IMSVS.\n         SPACE 1\nFNDCMA0  DS    0H\n         CLI   0(R15),C'.'        FOUND SECOND PERIOD?\n         BE    GOTCMA0            YES\n         LA    R15,1(0,R15)       NO, ADD 1 TO R15\n         B     FNDCMA0            AND TRY AGAIN\n         SPACE 1\nGOTCMA0  DS    0H\n         MVC   0(LAUDEND,R15),AUDEND END WITH OUR NAME\n         MVC   AUDTDSN,JFCBDSNM   SAVE THE AUDIT DSNAME\n         SPACE 1\n*\n*        CONVERT //AUDIT GDG RELATIVE TO ABSOLUTE\n*\n*              DO A LOCATE AND LET THE                              RH\n*              SYSTEM EXTEND THE GDG NAME FOR (0) AS WELL AS (+1).  RH\n*                                                                   RH\n         MVC   CMLDSN(LAUD),AUDTDSN  SET UP LOCATE DSN              RH\n         SPACE 1                                                    RH\n         LOCATE CAMLOCM\n         LTR   R15,R15             DID LOCATE WORK\n         BNZ   LOCERR             NO, GIVE ERROR MSG                RH\n         SPACE 1                                                    RH\nLOCOK    DS    0H                                                   RH\n         CLC   CMLDSN,AUDTDSN     DID LOCATE CHANGE DSN ?           RH\n         BE    LOCERR             NO, SOMETHING IS WRONG            RH\n         CLC   CMLDSN(8),=C'SYSCTLG.' CVOL POINTER NAME ?           RH\n         BE    LOCERR             YES, SOMETHING IS WRONG           RH\n         SPACE 1                                                    RH\nNEWDSN   DS    0H                                                   RH\n         MVC   TUPAR1,CMLDSN      NO, PUT NEW DSN IN TUPAR1         RH\n*                                                                   RH\n*              //AUDIT IS A GDG, SO                                 RH\n*              LOCATE WILL HAVE EXPANDED THE                        RH\n*              NAME. WE MUST RECALCULATE THE DSN LTH.               RH\n*                                                                   RH\n         LA    R3,TUPAR1+43       R3 -> TO END OF DSNAME            RH\n         SPACE 1                                                    RH\nCHKDSLTH DS    0H                                                   RH\n         CLI   0(R3),C' '         FOUND END OF DSN ?                RH\n         BNE   GOTDSLTH           YES, GO GET NEW LTH               RH\n         BCT   R3,CHKDSLTH        CHECK NEXT PREV CHAR              RH\n         SPACE 1                                                    RH\nGOTDSLTH DS    0H                                                   RH\n         LA    R4,TUPAR1-1        R4 -> TO DSNAME -1                RH\n         SR    R3,R4              R3 = LTH OF LOCATED DSN           RH\n         STH   R3,TULNG1          RESET DSNAME LTH FIELD            RH\n         SPACE 1                                                    RH\nDSOK     DS    0H                                                   RH\n         SPACE 1                                                    RH\nVOLOK    DS    0H                                                   RH\n*\n*        ALLOCATE AUDIT DATASET NAME SO WE CAN HAVE THE\n*        SYSTEM ENQ THE AUDIT DSN WITH DISP=MOD.\n*\n         SPACE 1\nDOSVC99A DS    0H\n         LA    R1,S99RBPTR        R1 -> TO SVC 99 PARMS\n         SVC   99\n         LTR   R15,R15            WAS SVC OKAY ?\n         BZ    AUDOPEN            YES, GO OPEN AUDIT DATASET\n         SPACE 1\n         CLC   LOOPCTR2,=X'000A'  DONE 10 LOOPS ALREADY?\n         BH    BADLOOP            YES, TOO BAD\n         SPACE 1\n         LH    R1,LOOPCTR2        R1 = NBR OF TIMES LOOPED\n         LA    R1,1(0,R1)         ADD 1\n         STH   R1,LOOPCTR2        SAVE IT\n         STIMER WAIT,BINTVL=WAITTIME   WAIT A BIT\n         SPACE 1\n         B     DOSVC99A           GO TRY AGAIN\n         SPACE 1\nBADAUDT  DS    0H\n         MVC   HDR1(L'BADAUDTM),BADAUDTM  SET UP MSG\n         MVI   IMFLRC+3,40        SET RC=40\n         B     PRINTHEX           PRINT MSG AND ABEND\n         SPACE 1\nBADAUDTD DS    0H\n         MVC   HDR1(L'BADAUDT2),BADAUDT2  SET UP MSG\n         MVI   IMFLRC+3,40        SET RC=40\n         B     PRINTHEX           PRINT MSG AND ABEND\n         SPACE 1\nBADAUDOP DS    0H\n         MVC   HDR1(L'BAUDOP),BAUDOP    SET UP MSG\n         MVI   IMFLRC+3,40        SET RC=40\n         B     PRINTHEX           PRINT MSG AND ABEND\n         SPACE 1\n*\n*\nAUDOPEN  DS    0H\n*\n*        OPEN AUDIT DATASET\n*\n         LA    R6,AUDIT           R6 -> TO DCB\n         USING IHADCB,R6\n         TM    DCBOFLGS,DCBOFOPN  TEST IF OPEN\n         BNZ   SINOPEN          IF ALREADY OPEN\n         OPEN  (AUDIT,(OUTPUT))\n         TM    DCBOFLGS,DCBOFOPN  TEST IF OPEN\n         BZ    BADAUDOP         IF CANNOT OPEN\n         DROP  R6\n*\n*\nSINOPEN  EQU   *\n*\n*\n* SET UP THE AUDIT RECORD\n*\n*        GET JOBNAME, STEPNAME, PROCNAME, AND JOB NUMBER\n*\nGETJOBN  EQU   *\n         L     R1,PSATOLD-PSA\n         ST    R1,TCBHOLD        SAVE THE TCB ADDR\n         L     R2,TCBTIO-TCB(0,R1)\n         USING TIOT1,R2\n         MVC   JOBNAME,TIOCNJOB\n*        MVC   PROCNAME,TIOCSTEP\n         MVC   STEPNAME,TIOCSTEP+8\n*\n*\n***********************************************************************\n*\n* RETRIEVE THE USERS RACF USERID FROM THE ACEE.                       *\n*\n***********************************************************************\n*\nGETUSER  DS    0H\n         L     R3,PSAAOLD-PSA          LOAD ADDRESS OF CURRENT ASCB\n         L     R3,ASCBASXB-ASCB(R3)    LOAD ASXB ADDRESS\n         L     R3,ASXBSENV-ASXB(R3)    LOAD ACEE ADDRESS\n*        IC    R14,ACEEUSRL-ACEE(R3)   GET USERID LENGTH\n*        SH    R14,=H'1'               SUB 1 FOR \"EX\" INSTRUCTION\n         MVC   ACEEUSR,ACEEUSRI-ACEE(R3) PUT USERID IN AUDIT RECORD\n*                                                                   RH\n*\n* GET THE JOB NUMBER\n*\n         DROP  R2\n         L     R1,TCBHOLD        RESTORE THE TCB ADDR\n         L     R2,TCBJSCB-TCB(0,R1)        -> JSCB\n         L     R2,JSCBACT-IEZJSCB(0,R2)    -> ACTIVE JSCB\n         L     R2,JSCBSSIB-IEZJSCB(0,R2)   -> SSIB\n         MVC   JOBNUMBR,SSIBJBID-SSIB(R2) MOVE IN THE JOB NUMBER\n         SPACE 1\n*\n* WRITE OUT THE AUDIT RECORD\n*\n         MVC   HDR180,CONTROL     PUT  AUDIT RECORD IN PRINT LINE\n         LA    R1,AUDIT           R1 -> TO DCB\n         TM    48(R1),DCBOFOPN    TEST IF OPEN\n         BZ    NOAUDIT1           NO\n         PUT   AUDIT,HDR1         WRITE AUDIT RECORD\n         SPACE 1\nNOAUDIT1 DS    0H\n         MVI   HDR180,C' '        CLEAR PRINT LINE\n         MVC   HDR180+1(79),HDR180 ''\n         SPACE 1\nOPEN     DS    0H\n*        GETMAIN R,LV=LDYNAMIC         GETMAIN DYNAMIC WORKAREA\n*        LR    R10,R1                  LOAD REGISTER 10 TO PRESERVE\n*                                      POINTER TO WORKAREA\n*        USING WORKAREA,R10            ESTABLISH ADDRESSABILITY TO\n*                                      DYNAMIC WORKAREA\n*\n***********************************************************************\n*                                                                     *\n*        INITIALIZE OUTPUT DATA CONTROL BLOCKS IN WORKAREA            *\n*                                                                     *\n***********************************************************************\n*\n         MVC   OUTPUTA(OUTPUTAL),OUTPUTAC  MOVE ASA DCB CONSTANT INTO\n*                                      ASA DCB IN WORKAREA\n*        MVC   OUTPUTM(OUTPUTML),OUTPUTMC  MOVE MACHINE DCB CONSTANT\n*                                      INTO MACHINE DCB IN WORKAREA\n*\n         OPEN  (SYSIN,(INPUT))    OPEN INPUT DCB\n         LA    R14,SCROLLIT       SET R14 FOR 1ST TIME THRU\n         SPACE 1\nREADSYS  DS    0H\n         STM   R0,R15,SAVEALL     SAVE ALL REGS\n         GET   SYSIN,MBRNAME           GET INPUT RECORD\n         LA    R1,MBRNAME         R1 -> TO INPUT DATA\n         LA    R2,MBRNAME         R2 -> TO INPUT DATA\n         SPACE 1\n         MVC   STARTMBR,BLANKS    CLEAR START MBR NAME\n         MVC   ENDMBR,BLANKS      CLEAR END MEMBER NAME\n         MVI   MBRTYPE,C' '       CLEAR FLAG BYTE\n         XC    SMBRLTH,SMBRLTH    CLEAR START MBR LTH\n         XC    EMBRLTH,EMBRLTH    CLEAR END MEMBER LTH\n         XC    WILDSLTH,WILDSLTH  CLEAR NBR OF WILD CARDS (BACKSLASH)\n         XC    WILDELTH,WILDELTH  CLEAR NBR OF WILD CARDS (BACKSLASH)\n         SPACE 1\nCHKBYTE  DS    0H\n         CLI   0(R2),C' '         AT END OF DATA ?\n         BE    END1               YES\n         CLI   0(R1),C'A'         IF 1ST CHAR IS NOT ALPHA,\n         BL    NXTBYTE            THIS MUST BE AN IMS FORMAT LIB\n         CLI   0(R2),C'\\'         FIND BACKSLASH WILD CHAR ?\n         BE    GOTWILD            YES\n         CLI   0(R2),C'*'         FIND * ?\n         BE    GOTAST             YES\n         CLI   0(R2),C'-'         FIND - ?\n         BE    GOTDASH            YES\n         SPACE 1\nNXTBYTE  DS    0H\n         LA    R2,1(0,R2)         R2 -> TO NEXT DATA CHAR\n         B     CHKBYTE            GO CHECK IT\n         SPACE 1\nEND1     DS    0H\n         LR    R3,R2              SAVE R2\n         SR    R2,R1              R2 = LTH OF DATA\n         CH    R2,=H'8'           OVER 8?\n         BH    BADATA             YES\n         SPACE 1\n*        CLI   MBRTYPE,C'-'       ARE WE PROCESSING 2ND MEMBER NAME ?\n*        BE    GOTDASH2           YES\n*        STH   R2,SMBRLTH         SAVE MBR LTH\n         MVI   EMBRLTH+1,8        SET END MBR LTH TO 8\n         BCTR  R2,0               R2 = HEX LTH\n         STC   R2,MOVE1+1         SAVE MBR NAME LTH\nMOVE1    MVC   ENDMBR(0),0(R1)    SAVE END MBR NAME\n*OVE1    MVC   STARTMBR(0),0(R1)  SAVE START MBR NAME\n         CLI   SMBRLTH+1,0        IS THERE A START MEMBER?\n         BH    ENDREAD            YES, ON WE GO\n         MVC   STARTMBR,ENDMBR    NO, SET UP START MBR NAME\n         MVI   SMBRLTH+1,8        SET START MBR LTH TO 8\n         B     ENDREAD            ON WE GO\n         SPACE 1\nGOTWILD  DS    0H\n         CLI   MBRTYPE,C' '       ARE WE PROCESSING 2ND MEMBER NAME ?\n         BNE   GOTWILD1           YES\n         LH    R4,WILDSLTH        R4 = NBR START WILD CARDS\n         LA    R4,1(0,R4)         ADD 1\n         STH   R4,WILDSLTH        SAVE NBR\n         B     NXTBYTE            GO CHECK NEXT BYTE...\n         SPACE 1\nGOTWILD1 DS    0H\n         LH    R4,WILDELTH        R4 = NBR START WILD CARDS\n         LA    R4,1(0,R4)         ADD 1\n         STH   R4,WILDELTH        SAVE NBR\n         B     NXTBYTE            GO CHECK NEXT BYTE...\n         SPACE 1\nGOTAST   DS    0H\n         CLI   MBRTYPE,C' '       ARE WE PROCESSING 2ND MEMBER NAME ?\n         BNE   GOTAST1            YES\n         MVI   MBRTYPE,C'*'       SAY WE GOT * TYPE\n         SPACE 1\nGOTAST1  DS    0H\n         LR    R3,R2              SAVE R2\n         SR    R2,R1              R2 = LTH OF DATA\n         CH    R2,=H'8'           OVER 8?\n         BH    BADATA             YES\n         SPACE 1\n         CLI   SMBRLTH+1,0        IS THERE A START MEMBER?\n         BH    GOTAST2            YES, ON WE GO\n         STH   R2,SMBRLTH         SAVE MBR LTH\n         BCTR  R2,0               R2 = HEX LTH\n         STC   R2,MOVE2+1         SAVE MBR NAME LTH\nMOVE2    MVC   STARTMBR(0),0(R1)  SAVE START MBR NAME\n         CLI   1(R3),C'-'         NEXT CHAR DASH(-) ?\n         BE    GOTEND1            YES\n         MVC   ENDMBR,STARTMBR    SET UP END MBR NAME\n         MVC   EMBRLTH,SMBRLTH    SET END MBR LTH\n         B     ENDREAD            ON WE GO\n         SPACE 1\nGOTEND1  DS    0H\n         LA    R1,2(0,R3)         R1 -> TO SECOND MEMBER\n         LR    R2,R1              R2 -> TO SECOND MEMBER\n         B     CHKBYTE            GO CHECK SECOND MEMBER NAME\n         SPACE 1\nGOTAST2  DS    0H\n         STH   R2,EMBRLTH         SET END MBR LTH\n         BCTR  R2,0               R2 = HEX LTH\n         STC   R2,MOVE2A+1        SAVE MBR NAME LTH\nMOVE2A   MVC   ENDMBR(0),0(R1)    SAVE END MBR NAME\n         B     ENDREAD            ON WE GO\n         SPACE 1\nGOTDASH  DS    0H\n         MVI   MBRTYPE,C'-'       SAY WE GOT - TYPE\n         LR    R3,R2              SAVE R2\n         SR    R2,R1              R2 = LTH OF DATA\n         CH    R2,=H'8'           OVER 8?\n         BH    BADATA             YES\n         SPACE 1\n*        STH   R2,SMBRLTH         SAVE MBR LTH\n         BCTR  R2,0               R2 = HEX LTH\n         STC   R2,MOVE3+1         SAVE MBR NAME LTH\nMOVE3    MVC   STARTMBR(0),0(R1)  SAVE START MBR NAME\n         MVI   SMBRLTH+1,8        SET START MBR LTH TO 8\n         LA    R1,1(0,R3)         R1 -> TO SECOND MEMBER\n         LR    R2,R1              R2 -> TO SECOND MEMBER\n         B     CHKBYTE            GO CHECK SECOND MEMBER NAME\n         SPACE 1\nGOTDASH2 DS    0H\n         LR    R3,R2              SAVE R2\n         STH   R2,EMBRLTH         SAVE MBR LTH\n         BCTR  R2,0               R2 = HEX LTH\n         STC   R2,MOVE4+1         SAVE MBR NAME LTH\nMOVE4    MVC   ENDMBR(0),0(R1)    SAVE END MBR NAME\n*        B     ENDREAD            ON WE GO\n         SPACE 1\nENDREAD  DS    0H\n         LM    R0,R15,SAVEALL     RELOAD ALL REGS\n         BR    R14                RETURN TO CALLER\n         SPACE 1\nBADATA   DS    0H\n         ABEND 999\n*\nEOFREAD  DS    0H\n         CLOSE (SYSIN)                 CLOSE INPUT DCB\n         MVI   STARTMBR,X'FF'     SIGNAL END OF SYSIN\n         B     ENDREAD            RETURN TO CALLER\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        OPEN THE DIRECTORY OF THE PDS                                *\n*                                                                     *\n***********************************************************************\n*\nSCROLLIT DS    0H\n         CLI   STARTMBR,X'FF'     END OF SYSIN?\n         BE    RETURN             YES, JUST RETURN\n*        ST    R6,SAVER6               SAVE REGISTER 6\n         LA    R8,DIRECT               LOAD POINTER TO DIRECTORY DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         MVC   DIRECT(DIRECTL),DIRECTC MOVE DIRECTORY DCB CONSTANT INTO\n*                                      DIRECTORY DCB IN WORKAREA\n         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO OPEN LIST IN WORKAREA\n         OPEN  ((R8),INPUT),MF=(E,OPENLST)  OPEN DIRECTORY DCB\n         TM    DCBOFLGS,DCBOFOPN       SEE IF DCB OPENED SUCCESSFULLY\n         BNO   NOTPMESS                NO.....GO PUT OUT NOT PRINTED\n*                                      MESSAGE\n         DROP  R8                      DROP ADDRESSABILITY TO DCB\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        GETMAIN MEMBER TABLE FOR STORAGE OF DIRECTORY NAMES, ETC.    *\n*           INITIALIZE TABLE                                          *\n*                                                                     *\n***********************************************************************\n*\n         L     R0,MEMDATL              LOAD LENGTH OF GETMAIN FOR\n*                                      MEMBER TABLE\n         LR    R2,R0                   SAVE IN REGISTER 2\n         GETMAIN R,LV=(0)              GETMAIN MEMBER TABLE STORAGE\n         ST    R1,MEMTABLE             SAVE ADDRESS OF MEMBER TABLE\n         ST    R1,PRESENT              ALSO SAVE ADDRESS AS TABLE\n*                                      IN USE\n         LA    R3,0(R2,R1)             LOAD ADDRESS OF END OF TABLE\n         ST    R3,ENDTABLE             STORE ADDRESS OF TABLE END\n         SLR   R4,R4                   ZERO REGISTER 4\n         ST    R4,0(R1)                STORE AS FIRST WORD OF MEMBER\n*                                      TABLE\n         LA    R4,8(R1)                LOAD REGISTER 4 AS POINTER TO\n*                                      THE FIRST ENTRY\n         USING MEMDSECT,R4             ESTABLISH ADDRESSABILITY TO\n*                                      MEMBER TABLE DSECT\n         SLR   R5,R5                   INITIALIZE MEMBER COUNT TO ZERO\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        READ DIRECTORY AND BUILD MEMBER TABLE                        *\n*                                                                     *\n***********************************************************************\n*\nGETDIR   EQU   *\n         GET   (R8),DATA               GET A DIRECTORY BLOCK\n         CLC   DATA(2),HALF12          SEE IF BLOCK IS UNUSED\n         BL    FREEBLK                 YES....GO HANDLE DIRECTORY END\n         LA    R9,DATA+2               LOAD POINTER TO FIRST DIRECTORY\n*                                      ENTRY\n         SLR   R7,R7                   ZERO REGISTER 7 FOR INSERT\n         ICM   R7,3,DATA               INSERT LENGTH USED OF THIS BLOCK\n         LA    R7,DATA-1(R7)           LOAD LAST USED BYTE OF BLOCK\nUNBLOCK  DS    0H\n         MVC   MEMNTTR,0(R9)           PUT NAME AND TTR IN TABLE\n         MVC   CFIELD,11(R9)           PUT C FIELD IN TABLE\n         CLI   MEMBER,HEXFF            SEE IF LAST MEMBER\n         BE    FREEBLK                 YES....GO HANDLE DIRECTORY END\n         IC    R6,CFIELD               INSERT CFIELD INTO REGISTER 6\n         SLL   R6,27                   SHIFT OUT HIGH ORDER BITS\n         SRL   R6,26                   SHIFT RIGHT TO GET LENGTH OF\n*                                      USER DATA\n         LA    R6,12(R6)               ADD STANDARD ENTRY LENGTH\n         SPACE 1\n         LH    R1,SMBRLTH         R1 = START MEMBER NAME LTH\n         LH    R14,WILDSLTH       R14 = NBR WILD CHARS IN START MBR\n         LTR   R14,R14            ARE THERE ANY?\n         BZ    NOWILDS            NO\n         LA    R14,STARTMBR       R14 -> TO START MBR NAME\n         LA    R10,STARTMBR       R10 -> TO END   MBR NAME\n         LA    R15,MEMBER         R15 -> TO DIR MEMBER NAME\n         SPACE 1\nCHKWILD1 DS    0H\n         CLI   0(R14),C'\\'        WILD CARD?\n         BNE   CHKWILD3           NO\n         SPACE 1\nCHKWILD2 DS    0H\n         LA    R14,1(0,R14)       ADD 1 TO R14\n         LA    R10,1(0,R10)       ADD 1 TO R10\n         LA    R15,1(0,R15)       ADD 1 TO R15\n         BCT   R1,CHKWILD1        CHECK FOR MORE....\n         B     NOTWANT            DELETE THIS MEMBER...\n         SPACE 1\nCHKWILD3 DS    0H\n         CLC   0(1,R15),0(R14)    IS THIS A CHAR WE WANT ?\n         BL    NEXTNTRY           NO\n         CLC   0(1,R15),0(R10)    IS THIS A CHAR WE WANT ?\n         BH    NEXTNTRY           NO, BUT CHECK ALL MEMBERS....\n*        BH    GETMBR             NO\n         B     CHKWILD2           YES, CHECK NEXT BYTE...\n         SPACE 1\nNOWILDS  DS    0H\n         BCTR  R1,0               R1 = HEX LTH\n         STC   R1,CLC1+1          PUT IT IN CLC INST\nCLC1     CLC   MEMBER,STARTMBR    DO WE WANT THIS MEMBER?\n*LC1     CLC   0(0,R9),STARTMBR   DO WE WANT THIS MEMBER?\n         BL    NEXTNTRY           NO\n         SPACE 1\n         LH    R1,EMBRLTH         R1 = END MEMBER NAME LTH\n         BCTR  R1,0               R1 = HEX LTH\n         STC   R1,CLC2+1          PUT IT IN CLC INST\nCLC2     CLC   MEMBER,ENDMBR      DO WE WANT THIS MEMBER?\n*LC2     CLC   0(0,R9),ENDMBR     DO WE WANT THIS MEMBER?\n         BH    GETMBR             NO\n         B     NOTWANT            YES, ON WE GO\n         SPACE 1\nGETMBR   DS    0H\n         BAL   R14,READSYS        GO GET NEXT SYSIN CONTROL CARD\n         CLI   STARTMBR,X'FF'     END OF SYSIN?\n         BE    FREEBLK            YES, GO HANDLE DIRECTORY END\n         B     UNBLOCK            NO, SEE IF WE WANT IT/THEM\n         SPACE 1\nNOTWANT  DS    0H\n         LA    R4,MEMSECTN        LOAD POINTER TO NEXT TABLE ENTRY\n         LA    R5,1(R5)                INCREMENT NUMBER OF MEMBERS IN\n*                                      TABLE\n         C     R4,ENDTABLE             SEE IF END OF TABLE\n         BL    NEXTNTRY                LOW.....GO PROCESS NEXT ENTRY\n         LR    R0,R2                   LOAD LENGTH OF TABLE FOR GETMAIN\n         GETMAIN R,LV=(0)              GET NEXT TABLE\n         L     R14,PRESENT             LOAD REGISTER 14 WITH ADDRESS OF\n*                                      LAST TABLE\n         ST    R1,0(R14)               CHAIN MEMBER TABLES TOGETHER\n         ST    R1,PRESENT              ALSO SAVE ADDRESS AS TABLE\n*                                      IN USE\n         LA    R3,0(R2,R1)             LOAD ADDRESS OF TABLE END\n         ST    R3,ENDTABLE             STORE ADDRESS OF TABLE END\n         SLR   R4,R4                   ZERO REGISTER 4\n         ST    R4,0(R1)                STORE AS FIRST WORD OF MEMBER\n*                                      TABLE\n         LA    R4,8(R1)                LOAD REGISTER 4 AS POINTER TO\n*                                      THE FIRST ENTRY\n         STH   R5,4(R14)               STORE MEMBER COUNT IN OLD TABLE\n         SLR   R5,R5                   INITIALIZE MEMBER COUNT TO ZERO\nNEXTNTRY DS    0H\n         BXLE  R9,R6,UNBLOCK           INCREMENT REGISTER 9 WITH\n*                                      REGISTER 6 AND BRANCH\n*                                      LESS THAN OR EQUAL TO\n*                                      REGISTER 7 TO UNBLOCK\n         B     GETDIR                  NO.....GO GET NEXT DIRECTORY\n*                                      BLOCK\n         DROP  R4                      DROP ADDRESSABILITY TO TABLE\n*\n***********************************************************************\n*                                                                     *\n*        CLOSE PDS DIRECTORY                                          *\n*        OPEN SYSPRINT DCB                                            *\n*        OPEN PDS DATASET FOR OUTPUT WITH A MEMBER NAME OF 99999999   *\n*        LIST MEMBERS IF:                                             *\n*           LIST SPECIFIED OR                                         *\n*           BOTH PRINT AND NOLIST WERE NOT SPECIFIED                  *\n*                                                                     *\n***********************************************************************\n*\nFREEBLK  DS    0H\n         MVC   OPENLST,OPENCLOS        MOVE CONSTANT INTO CLOSE LIST\n         CLOSE ((R8),),MF=(E,OPENLST)  CLOSE DIRECTORY DCB\n         L     R2,PRESENT              LOAD POINTER TO LAST TABLE\n         STH   R5,4(R2)                STORE COUNT OF MEMBERS\n         L     R4,MEMTABLE             LOAD POINTER TO FIRST TABLE\n         CLC   4(2,R4),HALF0           SEE IF THERE WERE ANY MEMBERS\n         BE    ENDMEMB                 ZERO...GO FREE MEMBER TABLE\n*\n*              ENQ THE PGMLIB DATASET OLD FOR QNAME=SYSIEWLP\n*\n         XC    LOOPCTR2,LOOPCTR2  CLEAR LOOP COUNTER\n         SPACE 1\nPGMENQ   DS    0H\n         ENQ   MF=(E,ENQL)        ENQ PGMLIB\n         LTR   R15,R15            DID IT WORK\n         BZ    ENQOK              YES\n         SPACE 1\n         CLC   LOOPCTR2,=X'000A'  DONE 10 LOOPS ALREADY?\n         BH    BADENQ             YES, TOO BAD\n         SPACE 1\n         LH    R1,LOOPCTR2        R1 = NBR OF TIMES LOOPED\n         LA    R1,1(0,R1)         ADD 1\n         STH   R1,LOOPCTR2        SAVE IT\n         STIMER WAIT,BINTVL=WAITTIME   WAIT A BIT\n         SPACE 1\n         B     PGMENQ             GO TRY AGAIN\n*        BNZ   BADENQ             NO, TOO BAD FOR NOW\n         SPACE 1\nENQOK    DS    0H\n         MVI   ENQFLAG,X'FF'      SAY WE ENQUEUED\n         LA    R8,INPUT                LOAD POINTER TO INPUT DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         MVC   INPUT(INPUTL),INPUTC    MOVE INPUT DCB CONSTANT INTO\n*                                      INPUT DCB IN WORKAREA\n         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO OPEN LIST IN WORKAREA\n         LA    R1,XLIST                LOAD ADDRESS OF EXIT LIST\n         ST    R1,DCBEXLST             STORE ADDRESS OF EXIT LIST IN\n*                                      DCB\n         LA    R2,JFCBAREA             LOAD ADDRESS OF JFCBAREA\n         ST    R2,XLIST                STORE ADDRESS IN EXIT LIST\n         MVI   XLIST,X'87'             SET END OF LIST AND JFCB BYTE\n         MVC   RDJL,OPENCLOS           MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO READJFCB LIST IN\n*                                      WORKAREA\n         RDJFCB ((8),),MF=(E,RDJL)   READ JFCB INTO JFCBAREA\n         MVC   JFCBELNM,=C'99999999'   MOVE MEMBER NAME INTO JFCB\n         OI    JFCBIND1,JFCPDS         SET JFCB TO INDICATE PDS MEMBER\n         MVI   JFCDSRG1,HEX00          SET JFCB TO REMOVE OTHER DSORG\n*                                      INDICATORS\n         OPEN  ((R8),(OUTPUT)),TYPE=J,MF=(E,OPENLST)  OPEN INPUT DCB\n         MVC   HEADER,HEADERM          MOVE HEADER INTO DATA AREA\nSUSEA    DS    0H\n         LA    R5,OUTPUTA              LOAD ADDRESS OF OUTPUT DCB FOR\n*                                      ASA CODE\n         LA    R4,EJECTA               LOAD ADDRESS OF EJECT DATA\n         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN\n         BO    SPUTDSN                 YES....GO PUT OUT HEADERS\n         LA    R3,PRINTA               LOAD POINTER TO PRINTA\n         OPEN  ((R5),(OUTPUT)),MF=(E,OPENLST)\n*        BAL   R14,ALLOCOUT            LOAD ADDRESS FOR RETURN AND GO\n*                                      DO SYSOUT ALLOCATION\nSPUTDSN  DS    0H\n         PUT   (R5),(R4)               PUT OUT PAGE EJECT\n         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER\n         MVC   HEADER2,LDSNAME         MOVE LENGTH AND 'DSNAME=' INTO\n*                                      INTO SECOND HEADER\n         MVC   DSNAME,JFCBAREA         MOVE DSNAME INTO DATA AREA\n         MVC   HEADER2+4(1),HDRCNTL    MOVE IN CONTROL BYTE\n         MVI   OPENPRN,BLANK           BLANK OUT MEMBER NAME\n         MVC   MEMNAME(9),OPENPRN      FINISH BLANKING OUT MEMBER NAME\n         PUT   (R5),HEADER2            PUT OUT PAGE 1 HEADER 2\n         PUT   (R5),HEADER3            PUT OUT PAGE 1 HEADER 3\n         LA    R1,AUDIT           R1 -> TO DCB\n         TM    48(R1),DCBOFOPN    TEST IF OPEN\n         BZ    NOAUDIT2           NO\n         LH    R1,HEADER2         R1 = LTH OF HEADER2\n         SH    R1,=H'5'           MAKE LTH HEX -4\n         STC   R1,MVC1+1          PUT LTH IN MVC CMD\nMVC1     MVC   HDR1(0),HEADER2+4  PUT HEADER IN AUDIT LINE\n         PUT   AUDIT,HDR1         PUT IT IN AUDIT TRAIL TOO\n         LH    R1,HEADER3         R1 = LTH OF HEADER3\n         SH    R1,=H'5'           MAKE LTH HEX -4\n         STC   R1,MVC2+1          PUT LTH IN MVC CMD\nMVC2     MVC   HDR1(0),HEADER3+4  PUT HEADER IN AUDIT LINE\n         PUT   AUDIT,HDR1         PUT IT IN AUDIT TRAIL TOO\n         SPACE 1\nNOAUDIT2 DS    0H\n         L     R2,MEMTABLE             LOAD ADDRESS OF FIRST TABLE\n         MVC   LENGTH,HALF85           SET LENGTH TO 85 BYTES\n         MVC   LENGTH+2,HALF0          ZERO RESERVED BYTES\n         MVC   CNTLBYTE,HDRCNTL        MOVE IN HEADER CONTROL BYTE\n*\n***********************************************************************\n*                                                                     *\n*        DELETE AND LIST MEMBER NAMES                                 *\n*                                                                     *\n***********************************************************************\n*\nSCROLLER DS    0H\n         LA    R10,LINECNT             LOAD LINE COUNT\n         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE\n         LH    R7,4(R2)                LOAD NUMBER OF MEMBERS IN TABLE\n         LTR   R7,R7                   SEE IF THERE ARE ENTRIES\n         BZ    NOLIST                  NO.....END OF DELETE PROGRAM\n         LA    R2,8(R2)                LOAD ADDRESS OF FIRST MEMBER\n         USING MEMDSECT,R2             ESTABLISH ADDRESSABILITY TO\n*                                      MEMBER TABLE ENTRY\nLOOP1    DS    0H\n         LA    R6,DATA                 LOAD ADDRESS OF OUTPUT BUFFER\n         MVI   DATA,BLANK              BLANK OUT OUTPUT BUFFER\n         MVC   DATA+1(79),DATA         FINISH BLANKING BUFFER\n         SPACE 1\nDEL1     DS    0H\n         TM    CFIELD,HIGH             SEE IF THIS IS AN ALIAS\n         BZ    NOTALIAS                NO.....CONTINUE WITH MAIN NAME\n         BAL   R14,LOOKLOOP            GO LOOK FOR MAIN NAME\nNOTALIAS DS    0H\n*\n*              DELETE MEMBER HERE\n*\n         LA    R8,INPUT           LOAD POINTER TO PDS DCB\nSTOWDEL  STOW  (8),MEMBER,D       DELETE MEMBER\n         LTR   R15,R15            WAS DELETE OKAY?\n         BNZ   NODEL1             NO, DON'T PUT NAME IN LIST\n         MVC   2(8,R6),MEMBER          PUT MEMBER NAME IN OUTPUT BUFFER\n         AP    DELETED,ONE        ADD 1 TO NBR DELETED\n         SPACE 1\nNODEL1   DS    0H\n         ST    R2,SAVER2               SAVE REGISTER 2\n         LA    R6,10(R6)               LOAD POINTER TO NEXT OUTPUT\n         LA    R2,DATA+70         R2 -> TO LAST PRINT ENTRY\n         CR    R6,R2              IS LINE FULL?\n         BH    END2               YES, GO PRINT LINE\n         L     R2,SAVER2               RELOAD REGISTER 2\n         LA    R2,MEMSECTN             LOAD POINTER TO NEXT MEMBER NAME\n*                                      BUFFER LOCATION\n         BCT   R7,DEL1                 DECREMENT MEMBER COUNT FOR\n*                                 CURRENT TABLE AND GO DELETE MBR\n         B     LOOP3              GO GET NEXT TABLE, IF ANY\n         SPACE 1\nEND2     DS    0H\n         PUT   (R5),LINE               PUT OUT OUTPUT LINE\n         LA    R1,AUDIT           R1 -> TO DCB\n         TM    48(R1),DCBOFOPN    TEST IF OPEN\n         BZ    NOAUDIT3           NO\n         LH    R1,LINE            R1 = LTH OF LINE DATA\n         SH    R1,=H'5'           MAKE LTH HEX -4\n         STC   R1,MVC3+1          PUT LTH IN MVC CMD\nMVC3     MVC   HDR1(0),LINE+4     PUT DATA IN AUDIT LINE\n         PUT   AUDIT,HDR1         PUT OUTPUT LINE IN AUDIT TRAIL\n         SPACE 1\nNOAUDIT3 DS    0H\n         LA    R6,DATA                 LOAD ADDRESS OF OUTPUT BUFFER\n         MVI   DATA,BLANK              BLANK OUT OUTPUT BUFFER\n         MVC   DATA+1(79),DATA         FINISH BLANKING BUFFER\n         SPACE 1\n         SPACE 1\nEND3     DS    0H\n         L     R2,SAVER2               RELOAD REGISTER 2\n         LA    R2,MEMSECTN             LOAD POINTER TO NEXT MEMBER NAME\n         BCT   R10,MOREROW             DECREMENT ROW COUNT\n         PUT   (R5),(R4)               PUT OUT PAGE EJECT WHEN ZERO\n         LA    R10,LINECNT             LOAD LINE COUNT\n         SPACE 1                       RESET COUNTERS\nMOREROW  DS    0H\n         BCT   R7,DEL1                 DECREMENT MEMBER COUNT FOR\n*        BCT   R7,LOOP1                DECREMENT MEMBER COUNT FOR\n*                                      CURRENT TABLE\nLOOP3    L     R2,PRESENT              LOAD POINTER TO CURRENT TABLE\n         L     R2,0(R2)                LOAD POINTER TO NEXT TABLE\n         LTR   R2,R2                   SEE IF IT WAS THE LAST TABLE\n         BZ    NOROLLER           YES\n         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE\n         LH    R7,4(R2)                LOAD NUMBER OF MEMBERS IN TABLE\n         LTR   R7,R7                   SEE IF THERE ARE ENTRIES\n         BZ    NOROLLER                NO.....END OF DELETE PROGRAM\n         LA    R2,8(R2)                LOAD ADDRESS OF FIRST MEMBER\n         B     DEL1               GO DELETE MEMBERS\n*        BNZ   SCROLLER                NO.....GO LIST OUT NEXT TABLE\n*\nNOROLLER DS    0H\n         PUT   (R5),LINE               PUT OUT LAST OUTPUT LINE\n         ED    DELCOUNT,DELETED   CONVERT DELETE COUNT TO DISPLAY\n         PUT   (R5),HEADER4            PUT OUT NBR DELETED\n         LA    R1,AUDIT           R1 -> TO DCB\n         TM    48(R1),DCBOFOPN    TEST IF OPEN\n         BZ    NOAUDIT4           NO\n         LH    R1,LINE            R1 = LTH OF LINE DATA\n         SH    R1,=H'5'           MAKE LTH HEX -4\n         STC   R1,MVC4+1          PUT LTH IN MVC CMD\nMVC4     MVC   HDR1(0),LINE+4     PUT DATA IN AUDIT LINE\n         PUT   AUDIT,HDR1         PUT OUTPUT LINE IN AUDIT TRAIL\n         SPACE 1\nNOAUDIT4 DS    0H\n*\n***********************************************************************\n*                                                                     *\n*        END OF DELETE PROGRAM                                        *\n*                                                                     *\n***********************************************************************\n*\nNOTPMESS DS    0H\nNOLIST   DS    0H\nCONTPRT  DS    0H\n         SPACE 1\nENDMEMB  DS    0H\n         L     R2,MEMTABLE             LOAD POINTER TO FIRST TABLE\nFREETABS DS    0H\n         LR    R1,R2                   LOAD AREA TO BE FREED\n         L     R2,0(R2)                LOAD POINTER TO NEXT TABLE\n         L     R0,MEMDATL              LOAD SIZE OF AREA TO BE FREED\n         FREEMAIN R,LV=(0),A=(1)       FREE STORAGE GETMAINED FOR TABLE\n         LTR   R2,R2                   SEE IF THERE WAS ANOTHER TABLE\n         BNZ   FREETABS                YES....GO FREE NEXT TABLE\n         L     R6,SAVER6               RESTORE REGISTER 6\n         LA    R8,INPUT                LOAD POINTER TO INPUT DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         TM    DCBOFLGS,DCBOFOPN       SEE IF INPUT DCB IS STILL OPEN\n         BNO   DEQPGM                  NO.....GO DO DEQ\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST IN WORKAREA\n         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB\n         DROP  R8                      DROP ADDRESSABILITY TO DCB\n         SPACE 1\nDEQPGM   DS    0H\n*\n*              DEQ THE PGMLIB DATASET FROM QNAME=SYSIEWLP\n*\n         CLI   ENQFLAG,X'FF'      DID WE ENQ?\n         BNE   RETURN             NO, THEN DON'T DEQ\n         DEQ   MF=(E,ENQL)        DEQ PGMLIB\n         B     RETURN                  RETURN\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        PUT OUT SYNAD ERROR MESSAGE,                                 *\n*           GO FREE MEMBER TABLES, AND                                *\n*           CONTINUE WITH NEXT DATASET                                *\n*                                                                     *\n***********************************************************************\n*\nSERRI    DS    0H\n*        PUTLINE OUTPUT=(SYNADI,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED DUE TO SYNAD\n*                                      ERROR ON INPUT DATASET MESSAGE\n         B     ENDMEMB                 GO FREE MEMBER TABLES\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        SEARCH FOR MAIN NAME,                                        *\n*           SAME TTR AND NOT AN ALIAS                                 *\n*                                                                     *\n***********************************************************************\n*\nLOOKLOOP DS    0H\n         STM   R3,R4,SAVER3            SAVE REGISTERS 3 AND 4\n         L     R3,MEMTABLE             LOAD ADDRESS OF FIRST TABLE\n         USING MEMDSECT,R3             ESTABLISH ADDRESSABILITY TO\n*                                      MEMBER ENTRY\nLOOP4    DS    0H\n         ST    R3,CURRENT              SAVE ADDRESS OF PRESENT TABLE\n         LH    R4,4(R3)                LOAD NUMBER OF ELEMENTS IN TABLE\n         LTR   R4,R4                   SEE IF THERE ARE ZERO ELEMENTS\n         BZ    NOMAIN                  YES....GO HANDLE MAIN NOT FOUND\n         LA    R3,8(R3)                LOAD ADDRESS OF FIRST MEMBER\nLOOP5    DS    0H\n         CLC   MEMTTR,8(R2)            SEE IF TTRS ARE THE SAME\n         BE    SAMETTR                 YES....GO SEE IF IT IS AN ALIAS\nENDLP5   DS    0H\n         LA    R3,MEMSECTN             LOAD ADDRESS OF NEXT MEMBER\n         BCT   R4,LOOP5                DECREMENT MEMBER COUNT\n         L     R3,CURRENT              LOAD ADDRESS OF THIS TABLE\n         L     R3,0(R3)                LOAD ADDRESS OF NEXT TABLE\n         LTR   R3,R3                   SEE IF IT WAS THE LAST TABLE\n         BNZ   LOOP4                   NO.....GO CHECK NEXT TABLE\n         B     NOMAIN                  GO HANDLE MAIN NOT FOUND\nSAMETTR  DS    0H\n         TM    CFIELD,HIGH             SEE IF THIS IS ALSO AN ALIAS\n         BO    ENDLP5                  YES....GO LOOK FOR ANOTHER TTR\n         MVC   11(8,R6),MEMBER         MOVE MEMBER NAME INTO OUTPUT\n         B     ENDLOOK                 GO TO RETURN TO CALLER\nNOMAIN   DS    0H\n         MVC   11(8,R6),ALIAS          INDICATE THIS IS AN ALIAS\nENDLOOK  DS    0H\n         LM    R3,R4,SAVER3            RESTORE REGISTERS 3 AND 4\n         BR    R14                     RETURN TO CALLER\n         DROP  R3                      DROP ADDRESSABILITY TO TABLE\n*\n*\n***********************************************************************\n*                                                                     *\n*        CLEANUP AREAS GETMAINED,                                     *\n*           SET RETURN CODE, RESTORE REGISTERS AND                    *\n*           RETURN TO CALLER                                          *\n*                                                                     *\n***********************************************************************\n*\nRETURN   DS    0H\n*        LA    R0,LDYNAMIC             LOAD LENGTH OF GETMAINED AREA\n*        FREEMAIN R,LV=(0),A=(10)      FREE GETMAINED AREA\n*\n         SPACE 1\nRETURN9  DS    0H\n         CLOSE (REPORT)           CLOSE SYSPRINT FILE\n         LA    R1,AUDIT           R1 -> TO DCB\n         TM    48(R1),DCBOFOPN    TEST IF OPEN\n         BZ    NOAUDIT9           NO\n         CLOSE (AUDIT)            CLOSE AUDIT FILE\n         SPACE 1\nNOAUDIT9 DS    0H\n         LR    R1,R13                  LOAD ADDRESS OF GETMAINED AREA\n         L     R13,4(,R13)             RELOAD ADDRESS OF PREVIOUS SAVE\n*                                      AREA\n         LA    R0,LDYNAMIC             LOAD LENGTH OF GETMAINED AREA\n         FREEMAIN R,LV=(0),A=(1)       FREE GETMINED AREA\n         SLR   R15,R15                 ZERO REGISTER 15.  RETURN CODE\n*                                      CODE WILL ALWAYS BE ZERO\n         L     R14,12(,R13)            LOAD REGISTER 14 WITH RETURN\n*                                      ADDRESS\n         LM    R0,R12,20(R13)          RESTORE REGISTERS\n*\n*              GET INTO PROPER MODE AND GO BACK TO CALLER           RH\n         BSM   0,R14                                                RH\n         SPACE 1\nLOCERR   DS    0H\n         MVC   HDR1(L'BADLOCM),BADLOCM  SET UP MSG\n         MVI   IMFLRC+3,40        SET RC=40\n         B     PRINTHEX           PRINT MSG AND ABEND\n         SPACE 1\nBADLOOP  DS    0H\n         MVC   HDR1(LOOPLTH),LOOPMSG  SET UP MSG\n         MVI   IMFLRC+3,40        SET RC=40\n         B     PRINTHEX           PRINT MSG AND ABEND\n         SPACE 1\nPRINTHEX DS    0H\n*        PUT   REPORT,HDR1        PRINT RC MESSAGE\n         BAL   R5,PRINTLNE        PRINT RC MESSAGE\n         SPACE 1\nRET20    DS    0H\n         L     R1,IMFLRC          PUT ABEND CODE IN R1\n         ABEND (1),,,USER         ABEND WITH A SYSTEM CODE\n         SPACE 1\n         SPACE 1\nBADENQ   DS    0H\nBADSYSOP DS    0H\n         MVC   HDR1(L'BADSYSP),BADSYSP    SET UP MSG\n         MVI   IMFLRC+3,40        SET RC=40\n         B     PRINTHEX           PRINT MSG AND ABEND\n         SPACE 1\nPRINTLNE DS    0H\n         PUT   REPORT,HDR1        PRINT RC MESSAGE\n         MVI   HDR1,C' '          CLEAR PRINT LINE\n         MVC   HDR1+1(120),HDR1      ''\n         BR    R5                 RETURN TO CALLER\n         SPACE 3\n* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n*        WORK AREAS\n* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\nDUMPTITL DC    C'WORKING STORAGE SECTION'\nDWORD    DC    D'0'\nSAVE     DC    18F'-1'\nCPKECB   DC    F'0'\nIMFLRC   DC    F'0'\nATTTCB   DC    F'0'\nTCBHOLD  DC    F'0'\n         SPACE 1\nENQFLAG  DC    X'00'\nTPGMLIB  DC    CL44'IMSVS.TEST.PGMLIBA'\nBADLOCM  DC    C'0 AUDIT DATASET GDG NOT FOUND'\nLOOPMSG  DC    C'0 TIMER EXPIRED.'\n         DC    C' AUDIT DATASET IS IN USE. TRY AGAIN'\nLOOPLTH  EQU   *-LOOPMSG\nHDR1     DS    0CL121\n         DC    C'0'\nHDR180   DS    0CL80\nHDR1RC   DC    C' IUTDEL RC IS '\nBYTE1    DC    C' '\nBYTE2    DC    C' '\nSYSRC    DS    0CL3\nBYTE3    DC    C' '\nBYTE4    DC    C' '\nBYTE5    DC    C' '\nBYTE6    DC    C' '\nBYTE7    DC    C' '\nUSRRC    DS    0CL3\nBYTE8    DC    C' '\nBYTE9    DC    C' '\n         DC    CL(121-(*-HDR1))'  '\n         SPACE 2\nLOOPCTR  DC    H'00'\nLOOPCTR2 DC    H'00'\n         SPACE 1\nWAITTIME DC    F'500'             WAIT FOR 5 SECONDS\nMULTSEC  DC    H'100'             MULTIPLIER FACTOR TO GET TIMER UNITS\nTESTDAT  DC    CL6'90.134'        TEST DATE....MAY 14/90            DT\n*\nCONTROL  DS    0CL80              AUDIT RECORD\nCTLDATE  DC    CL6' '             DATE\n         DC    C'/'               /\nCTLTIME  DC    CL8' '             TIME\n         DC    C' '\nJOBNUMBR DC    CL8' '             JOB NUMBER\n         DC    C' '\nJOBNAME  DC    CL8' '             JOBNAME\n         DC    C' '\nSTEPNAME DC    CL8' '             STEPNAME\n*ROCNAME DC    CL8' '             PROC NAME\nACEEUSR  DC    CL8' '             ACEE USERID\nDBSTATUS DC    CL2' '             COMMAND STATUS\nAUDITCMD DC    CL20' '            COMMAND\n         DC    CL(80-(*-CONTROL))' '\n*\n         LTORG\n*                                        PLACE FOR TIME/DATE\nTIMEDATE DS    0CL40              TIMEDATE2,\nTDTIME   DS    CL8                TD_TIME\n         DS    CL3                TD_FILL1\nTDDATE   DS    0C                 TD_DATE,\nTDYEAR   DS    CL2                TD_YEAR\nTDDOT    DS    C                  TD_DOT\nTDDAY    DS    CL3                TD_DAY\n         DS    CL2                TD_FILL2\nTDWKDAY  DS    CL8                TD_WEEK_DAY\n         DS    CL13\n*\n         SPACE 2\nENQL     ENQ   (QNAME,TPGMLIB,E,44,SYSTEMS),MF=L\n         SPACE 1\nQNAME    DC    CL8'SYSIEWLP'            MAJOR QUEUE NAME\n         SPACE 2\n*UDTDSN  DC    C'IMSVS.IMSTEST.CHANGE.REPORT(0)'\n*UDTDSN  DC    C'IMSVS.IMSTEST.CHANGE.SYSPRINT(0)'\n         SPACE 1\nAUDTDSN  DC    CL44'IMSVS.TEST.IUTDEL.AUDIT(0)'\nLAUD     EQU   *-AUDTDSN\n         SPACE 1\nAUDEND   DC    C'.IUTDEL.AUDIT(0)'\nLAUDEND  EQU   *-AUDEND\n         SPACE 1\nBADAUDTM DC    C'0 INVALID AUDIT DATASET NAME'\n         AGO   .AUDIT3\nNOAUDTM  DC    C'0 AUDIT DD STATEMENT MISSING'\n.AUDIT3  ANOP\nBADAUDT2 DC    C'0 AUDIT DD STATEMENT DISP MUST BE MOD'\nBAUDOP   DC    C'0 AUDIT FILE  OPEN FAILED. CALL TECH SUPPORT'\n         SPACE 1\nNOSYSPM  DC    CL121'0 PDSPRINT DD STATEMENT MISSING'\nBADSYSP  DC    C'0 PDSPRINT FILE OPEN FAILED. CALL TECH SUPPORT'\n         SPACE 1\n*              CONTROL BLOCKS FOR  SVC 99\n         DS    0F                 PUT ON FULLWORD BOUNDARY\nS99RBPTR DC    XL1'80'\n         DC    AL3(S99RB)\nS99RB    DS    0F\nS99RBLN  DC    AL1(20)\nS99VERB  DC    AL1(1)             ALLOCATE BY DSNAME\nS99FLAG1 DC    XL2'2000'          DON'T MOUNT VOLS OR CONSIDER OFFLINES\nS99ERROR DC    AL2(0)\nS99INFO  DC    AL2(0)\nS99TXTPP DC    A(S99TUPL)\nS99RES1  DC    A(0)\nS99FLAG2 DC    X'40000000'        WAIT FOR DSNAME\n         SPACE 1\nS99TUPL  DS    0F\nTUPL1    DC    A(TUNIT1)          DSNAME\nTUPL2    DC    A(TUNIT2)          DDNAME\nTUPL4    DC    A(TUNIT4)          STATUS 1 = OLD\nTUPL5    DC    XL1'80'            STATUS 2 = KEEP\n         DC    AL3(TUNIT5)\n         SPACE 1\nTUNIT1   DS    0C\nTUKEY1   DC    AL2(2)             ALLOCATE BY DSNAME\nTUNUM1   DC    AL2(1)\nTUENT1   DS    0C\nTULNG1   DC    AL2(44)            LTH OF DSNAME\nTUPAR1   DC    CL44' '            AUDIT DSNAME\n*UPAR1   DC    CL44'IMSVS.IMSTEST.CHANGE.'    AUDIT DSNAME\n         SPACE 1\nTUNIT2   DS    0C\nTUKEY2   DC    AL2(1)             ALLOCATE DDNAME\nTUNUM2   DC    AL2(1)\nTUENT2   DS    0C\nTULNG2   DC    AL2(8)             LTH OF DDNAME\nTUPAR2   DC    CL8'AUDIT  '       DDNAME\n         SPACE 1\nTUNIT4   DS    0C\nTUKEY4   DC    XL2'0004'          STATUS OF DATA SET\nTUNUM4   DC    AL2(1)\nTUENT4   DS    0C\nTULNG4   DC    AL2(1)             LTH OF STATUS\nTUPAR4   DC    X'02'              STATUS = MOD\n         DC    X'01'              STATUS = OLD\n*        DC    X'02'              STATUS = MOD\n*        DC    X'04'              STATUS = NEW\n*        DC    X'08'              STATUS = SHR\n         SPACE 1\nTUNIT5   DS    0C\nTUKEY5   DC    XL2'0005'          STATUS 2..DISP=(OLD,KEEP)\nTUNUM5   DC    AL2(1)\nTUENT5   DS    0C\nTULNG5   DC    AL2(1)             LTH OF STATUS 2\nTUPAR5   DC    X'08'              STATUS = KEEP\n*        DC    X'04'              STATUS = DELETE\n*        DC    X'02'              STATUS = CATLG\n*        DC    X'01'              STATUS = UNCATLG\n         SPACE 3\n* ------ DCB'S                    ------------------------------------\n         SPACE 3\nREPORT   DCB   DSORG=PS,DDNAME=SYSPRINT,MACRF=(PM),LRECL=121,       XXXX\n               EXLST=JFCBADD,RECFM=FBA,BLKSIZE=6292\n         SPACE 1\nAUDIT    DCB   DSORG=PS,DDNAME=AUDIT,MACRF=(PM),LRECL=121,          XXXX\n               EXLST=JFCBADD,RECFM=FBA,BLKSIZE=6292\n         SPACE 1\nPGMLIB   DCB   DSORG=PS,DDNAME=PDS,MACRF=(GL),                      XXXX\n               EXLST=JFCBADD\n         SPACE 1\nJFCBADD  DS    0F\n         DC    X'87'              JFCB ADDRESS\n         DC    AL3(JFCB)\n         DS    0H                 PUT JFCB ON HALFWORD BOUNDARY\nJFCB     DS    0CL176' '\n         IEFJFCBN  LIST=NO\n         SPACE 5\n***********************************************************\n**                                                       **\n**   CAMLST - LOCATE A CATLG ENTRY BY DSNAME             **\n**                                                       **\n***********************************************************\nCAMLOCM  CAMLST NAME,CMLDSN,,CMLRESP\n*\nCMLRESP  DS    0D                  CAMLST ANSWER AREA\nCMLNVOL  DS    1H                         VOLUME COUNT\nCMLDEVTY DS    CL4                        UNIT TYPE\nCMLVOL1  DS    CL6                        FIRST VOLUME\nCMLDSEQ  DS    CL6                        DS SEQ NO\n         DS    CL(265-(*-CMLRESP))  EXTEND TO 265 CHAR CAMLST SIZE\nCMLDSN   DC    CL44' '            WORK AREA FOR CAMLST DSN          RH\nCMLSTWAL EQU   *-CMLRESP\n*\n*\n***************************WORK AREAS *********************************\n*\n         SPACE 2\nMBRTYPE  DC    C' '\nSTARTMBR DC    CL8' '\nENDMBR   DC    CL8' '\nMBRNAME  DS    CL80\nSMBRLTH  DC    H'0'\nEMBRLTH  DC    H'0'\nWILDSLTH DC    H'0'               NBR WILD CHARS IN 1ST NAME...\nWILDELTH DC    H'0'               NBR WILD CHARS IN END NAME...\nSAVEALL  DC    18F'0'\n*\n***************************** CONSTANTS *******************************\n*\n         SPACE 2\nSYSIN    DCB   DSORG=PS,MACRF=(GM),EODAD=EOFREAD,                      +\n               DDNAME=SYSIN\nSYSINL   EQU   *-SYSIN\n*\n*NPUTC   DCB   DSORG=PS,MACRF=(GM),EODAD=EXIT,SYNAD=ERRI,DDNAME=PDS\n*NPUTL   EQU   *-INPUTC\nINPUTC   DCB   DSORG=PO,MACRF=(W),DDNAME=PDS\nINPUTL   EQU   *-INPUTC\n*\n*UTPUTAC DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=SYSPRINT,\nOUTPUTAC DCB   DSORG=PS,MACRF=(PM),DDNAME=SYSPRINT,                    X\n               LRECL=256,BLKSIZE=3120,RECFM=VBA\nOUTPUTAL EQU   *-OUTPUTAC\n*\n*UTPUTMC DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=SYSPRINT,         X\n               LRECL=256,BLKSIZE=3120,RECFM=VBM\n*UTPUTML EQU   *-OUTPUTMC\n*\nDIRECTC  DCB   DDNAME=PDS,MACRF=(GM),RECFM=U,BLKSIZE=256,              X\n               SYNAD=SERRI,EODAD=FREEBLK,DSORG=PS\nDIRECTL  EQU   *-DIRECTC\n*\nDELETED  DC    PL3'0'\nONE      DC    P'1'\n*\nOPENCLOS OPEN  (,),MF=L\n         SPACE 2\nHEADERC  DS    0F\n         DC    H'48'\n         DC    H'0'\nHDRCNTLC DC    C' '\n         DC    CL43'**** TSO FOREGROUND HARDCOPY ****'\nHEADERM  DS    0F\n         DC    H'62'              LTH OF DATA + 4\n         DC    H'0'\n         DC    C' '               DATA STARTS HERE\n         DC    CL46'DIVERSIFIED DEVELOPMENTS DELETE MEMBER UTILITY'\n         DC    CL11', VERSION 3'\nHEADERML EQU   *-HEADERM\n*        DC    CL43'*** TSO FOREGROUND MEMBER LIST **'\nHEADER3  DS    0F\n         DC    H'44'              LTH OF DATA + 4\n         DC    H'0'\n         DC    C' '               DATA STARTS HERE\n*        DC    CL39'THE FOLLOWING MEMBERS HAVE BEEN DELETED'\n         DC    C'THE FOLLOWING MEMBERS '\nHEADER3W DC    C'HAVE BEEN'\n         DC    C' DELETED'\nHEADER3L EQU   *-HEADER3\nHEADER4  DS    0F\n         DC    H'32'              LTH OF DATA + 4\n         DC    H'0'\n         DC    C'0'               DATA STARTS HERE\nDELCOUNT DC    X'402020202021'\n*        DC    C' MEMBERS WERE DELETED'\n         DC    C' MEMBERS '\nNOTDEL   DC    C'WERE'\n         DC    C' DELETED'\nHEADER4L EQU   *-HEADER4\nLDSNAME  DS    0CL12\n         ORG   LDSNAME\n         DC    H'66'\n         DC    H'0'\n         DC    CL8' DSNAME='\nEJECTM   DS    0F\n         DC    H'5'\n         DC    H'0'\n         DC    X'8B'\nEJECTA   DS    0F\n         DC    H'5'\n         DC    H'0'\n         DC    C'1'\nSPACE    EQU   EJECTA\n         SPACE 2\nFULL0    DC    F'0'\nFULL1    DC    F'1'\nFULL4    DC    F'4'\nFULL20   DC    F'20'\nFULL28   DC    F'28'\nFULL256  DC    F'256'\nPRINTILN DC    H'12',H'0'\nPRINTI   DC    CL8'PRINTI'\nPRINTALN DC    H'12',H'0'\nPRINTA   DC    CL8'PRINTA'\nPRINTMLN DC    H'12',H'0'\nPRINTM   DC    CL8'PRINTM'\nBLANKS   DC    256CL1' '\nALIAS    DC    CL8' *ALIAS*'\nENDCHAIN DS    0F\n         DC    X'FF000000'\nMEMDATL  DC    X'00'                   SUBPOOL NUMBER\n         DC    AL3(LINECNT*36+8)       CALC TABLE SPACE\nLINECNT  EQU   50                      DEFAULT LINES PER PAGE FOR\n*                                      MEMBER NAME LIST.  MODIFY\n*                                      ABOVE STATEMENT TO CHANGE\n*                                      NUMBER OF LINES PER PAGE\n*                                      IN MEMBER NAME LIST.\nHALF0    DC    H'0'\nHALF1    DC    H'1'\nHALF2    DC    H'2'\nHALF6    DC    H'6'\nHALF12   DC    H'12'\nHALF85   DC    H'85'\nHALF256  DC    H'256'\nHEXFF    EQU   X'FF'\nHIGH     EQU   X'80'\nBLANK    EQU   X'40'\nLOW      EQU   X'01'\n*JFCPDS  EQU   X'01'\nHEX00    EQU   X'00'\nSCLSA    EQU   C'A'\nSKIPM    EQU   X'09'\nDSOPS    EQU   X'40'\nDSOPO    EQU   X'02'\nNOWTP    EQU   X'00'\n         SPACE 2\n****************************** MESSAGES *******************************\nOPENMSG  DC    AL2(OPENMSGL),AL2(0)\n         DC    C'OUPUT PROCESSING IS BEING TERMINATED.  AN ERROR WAS ENX\n               COUNTERED ATTEMPTING TO OPEN THE OUTPUT DATASET ASSOCIATX\n               ED WITH DDNAME: '\nOPENMSGL EQU   *-OPENMSG\n*\nDSNMSG   DC    AL2(DSNMSGL),AL2(0)\n         DC    C'PROCESSING HAS BEEN COMPLETED FOR DATASET: '\nDSNMSGL  EQU   *-DSNMSG\n*\nMEMMSG   DC    AL2(MEMMSGL),AL2(0)\n         DC    C' MEMBER: '\nMEMMSGL  EQU   *-MEMMSG\n*\nSYNADI   DC    AL2(SYNADIL),AL2(0)\n         DC    C'A SYNAD ERROR OCURRED READING YOU INPUT DATASET AND ONX\n               LY PART OF YOUR DATASET MAY HAVE BEEN PRINTED.'\nSYNADIL  EQU   *-SYNADI\n*\nSYNADO   DC    AL2(SYNADOL),AL2(0)\n         DC    C'A SYNAD ERROR OCURRED WRITING THE OUTPUT DATASET AND NX\n               O MORE DATASETS WILL BE PRINTED.'\nSYNADOL  EQU   *-SYNADO\n*\nDSNISU   DC    AL2(DSNISUL),AL2(0)\n         DC    C'DATASET HAS UNDEFINED RECORD LENGTH AND WILL NOT BE PRX\n               INTED.'\nDSNISUL  EQU   *-DSNISU\n*\nDSNISL   DC    AL2(DSNISLL),AL2(0)\n         DC    C'DATASET HAS RECORD LENGTH GREATER THAN 256.'\nDSNISLL  EQU   *-DSNISL\n         SPACE 2\n************************ DSECTS (MAPPING MACROS) **********************\nMEMDSECT DSECT\nMEMNTTR  DS    CL11\n         ORG   MEMNTTR\nMEMBER   DS    CL8\nMEMTTR   DS    CL3\nCFIELD   DS    CL1\nMEMSECTN EQU   *\n         EJECT\n*********************** DSECT FOR DYNAMIC WORKAREA ********************\nWORKAREA DSECT\nSAVEAREA DS    18F\nALCSAVE  DS    12F\n         DS    0D\nDEC      DS    2F\nRETNCD   DS    F\nCONV     DS    2F\nLINE     DS    0H\nLENGTH   DS    H\n         DS    H\nCNTLBYTE DS    CL1\nDATA     DS    CL256\n         DS    0F\nHEADER2  DS    CL12\nDSNAME   DS    CL44\nOPENPRN  DS    CL1\nMEMNAME  DS    CL8\nCLOSEPRN DS    CL1\n         ORG   DSNAME-4\nDSNLENP  DS    CL2\nDSNLEN   DS    CL2\nDSNBUF   DS    CL44\n         ORG   MEMNAME-4\nMEMNAMEL DS    CL2\n         ORG\n*EADER   DS    CL62               SAME LTH AS HEADERM\nHEADER   DS    CL(HEADERML)       SAME LTH AS HEADERM\n         ORG   HEADER+4\nHDRCNTL  DS    CL1\nDFID     DS    CL2\n         ORG\nVOLBIT   DS    CL1\nVOLUME   DS    CL8\nMEMTABLE DS    F\nENDTABLE DS    F\nCURRENT  DS    F\nPRESENT  DS    F\nCOLUMN   DS    F\nXLIST    DS    F\nRDJL     RDJFCB (,),MF=L\nJFCBAREA DS    44F\n         ORG   JFCBAREA+44\n*FCBELNM DS    CL8\n         ORG   JFCBAREA+86\n*FCBIND1 DS    CL1\n         ORG   JFCBAREA+98\n*FCDSRG1 DS    CL1\n         ORG\nSAVER6   DS    F\nSAVER2   DS    2F\nSAVER3   DS    2F\n*\n         PRINT NOGEN\n*\nINPUT    DCB   DSORG=PS,MACRF=(GM),DDNAME=PRINTI\n*\nOUTPUTA  DCB   DSORG=PS,MACRF=(PM),DDNAME=PRINTA,RECFM=VBA,            +\n               LRECL=256,BLKSIZE=3120\n*\nDIRECT   DCB   DDNAME=PRINTI,DSORG=PS,MACRF=(GM),RECFM=U,BLKSIZE=256,  X\n               SYNAD=SERRI,EODAD=FREEBLK\n*\nOPENLST  OPEN  (,),MF=L\n*\nCLOSLST  CLOSE (,),MF=L\n*\n         PRINT GEN\n*\nRETCODE  DS    F\nGFPARMP  DS    F\nLDYNAMIC EQU   *-WORKAREA\n         SPACE 1\n         PRINT NOGEN\n         DCBD  DEVD=DA,DSORG=(PS,PO)\n*\n         IHAPSA\n         IKJTCB\n         IEFTIOT1\n         IEZJSCB\n         IEFJSSIB\n*        PARMBLK DSECT\n         IHAACEE\n         IHAASCB\n         IHAASXB\n*\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   IUTDEL\n//LKED.SYSLMOD DD DSN=SYS1.BCSCLINK,DISP=SHR\n//LKED.SYSLIN2 DD DSN=SYS9.IMSUTIL.LOAD,DISP=SHR\n//LKED.SYSIN DD *\n  INCLUDE SYSLIN2(DAYDATE)\n  SETCODE AC(1)\n  NAME IUTDEL(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IUTDELJ": {"ttr": 18179, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03?\\x00\\x99\\x03?\\x13&\\x00\\x0f\\x00\\x0f\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-02T00:00:00", "modifydate": "1999-02-02T13:26:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "RH87944"}, "text": "//IUTDEL   JOB\n/*ROUTE PRINT R7\n//*\n//*      DSN=CBT.SOURCE(IUTDELJ)\n//*\n//*\n//*    NOTE.... IF PRM=TEST IS ADDED TO YOUR EXEC STATEMENT,\n//*             IUTDEL WILL GIVE YOU A LIST OF MEMBERS THAT WILL\n//*             BE DELETED, BUT WILL NOT ACTUALLY DO THE DELETE\n//*\n//DELMEMS EXEC IUTDEL,VER='IMSVS.TEST'   ,PRM=TEST\n//PDS     DD   DSN=IMSVS.DEVL.PGMLIB2,DISP=SHR\n//SYSIN  DD *\nTEMPNAME\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JDATE": {"ttr": 18181, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03?\\x13)\\x00\\xe5\\x00\\xf3\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-02T13:29:00", "lines": 229, "newlines": 243, "modlines": 0, "user": "RH87944"}, "text": "//JDATE    JOB\n/*ROUTE PRINT R7\n//JDATE     EXEC  HLASMCL,\n//             PARMC='NOALIGN,NORLD',CLASS='*',COND.LKED=(7,LT,ASM)\n//ASM.SYSIN DD  *\n*                                                                   Y2\n*              MODIFIED JAN 06/97 TO ACCEPT A 7 CHAR JULIAN DATE    Y2\n*              TO BE YEAR 2000 COMPLIANT                            Y2\n*              CHANGES FOR YEAR 2000 HAVE Y2 IN COLS 69-70          Y2\n*\n*              MODIFIED JUL24/91  TO ACCEPT A JULIAN DATE\n*              THAT WILL BE CONVERTED TO DAY/DATE, AND USE PUTLINE\n*              NOT TPUT SO OUTPUT CAN BE TRAPPED IN A CLIST IF\n*              JDATE IS CALLED AS A TSO COMMAND....\n*\n*\nJDATE    CSECT      DISPLAY TODAYS JULIAN DATE, ETC.\n         USING *,R15              SET TEMP BASE\n         B     AROUND             BRANCH AROUND DUMP TITLE\n         DC    AL1(EYELTH)\nEYECATCH DC    C'JDATE '          PROGRAM NAME\n         DC    C'VERSION 3.0 '    VERSION                           Y2\n         DC    C'&SYSDATE'        DATE WRITTEN\n         DC    C' '               BLANK\n         DC    C'&SYSTIME'        TIME WRITTEN\n         DC    C' '               BLANK\n         DC    C'ACCEPT 7 CHAR PARM FOR YEAR 2000'                  Y2\n*        DC    C'VERSION 2. ACCEPT PARM'\nEYELTH   EQU   *-EYECATCH         LTH OF EYECATCHER\n         SPACE 1\nAROUND   DS    0H\n         LA    R1,0(0,R1)         CLEAR HI-ORDER BYTE FOR 31 BIT\n         LA    R13,0(0,R13)       CLEAR HI-ORDER BYTE FOR 31 BIT\n         BSM   R14,0              SAVE CURRENT AMODE\n         SPACE 1\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         DROP  R15\n         USING JDATE,R12\n         ST    R13,SAVE+4\n         LA    R13,SAVE\n         ST    R1,SAVE            SAVE R1 (ADDR INPUT PARM)\n         SPACE 1\n*        XC    CONID,CONID\n*        EXTRACT ANSWER,FIELDS=(TSO,TIOT)\n*        L     R2,TSO             TSO USER?\n*        TM    0(R2),X'80'\n*        BZ    PARM0              NO\n**       L     R2,TIOT            GET USERID\n**       MVC   USERID,0(R2)       FROM TIOT\n**       MVC   JOBSAVE,=CL8' '    CLEAR JOB NAME SAVE FIELD\n         SPACE 2\n*        UNDER TSO. INVOKED AS A  COMMAND PROCESSOR.\n*        SET UP THE IOPL FOR PUTLINE.\n*\n         L     R2,SAVE            R2 -> TO INPUT PARM\n         USING CPPL,R2\n*\n*        WE MAY BE RUNNING UNDER TSO, BUT DO WE HAVE A CPPL\n*        OR WAS THIS A CALL TO JDATE???\n*\n         TM    0(R2),X'80'        IS HIGH BIT ON?\n         BZ    NOTCALL            NO, WE PROBABLY HAVE A CPPL\n         MVI   NOCPPL,X'FF'       SAY WE DON'T HAVE A CPPL\n         B     PARM0              ON WE GO\n         SPACE 1\nNOTCALL  DS    0H\n         LA    R3,IOPLADD\n         USING IOPL,R3\n         L     R4,CPPLUPT\n         ST    R4,IOPLUPT         SET UP IOPL\n         L     R4,CPPLECT\n         ST    R4,IOPLECT\n         LA    R4,ECB\n         ST    R4,IOPLECB\n*        L     R2,CPPLCBUF\n         DROP  R2,R3\n         SPACE 1\n***********************************************************************\n*\n*              SEE IF THERE IS A  PARM\n*\n*        VALID PARMS ARE:\n*              A 5 BYTE JULIAN DATE...  YYDDD...\n*              A 7 BYTE JULIAN DATE...YYYYDDD...                    Y2\n*\n***********************************************************************\n         SPACE 1\n*              GET PARM, IF ANY\n         SPACE 1\nPARM0    DS    0H\n         L     R1,SAVE            R1 = -> TO PARM\n         L     R2,0(0,R1)         R2 -> TO PARM\n         LA    R10,2(0,R2)        R10 -> TO PARM\n         LH    R2,0(0,R2)         R2 = PARM LTH\n         LTR   R2,R2              IS THERE A PARM ?\n         BZ    ENDPARM            NO\n         LR    R4,R10             YES, R4 -> TO PARM\n         CH    R2,=H'5'           MORE OR LESS THAN 5 CHARS?\n         BE    PARM1              NO, ON WE GO...\n         CH    R2,=H'7'           MORE OR LESS THAN 7 CHARS?        Y2\n         BE    PARM2              NO, ON WE GO...                   Y2\n*\n         CLI   NOCPPL,X'FF'       DO WE HAVE A CPPL ?\n         BE    ENDPARM            NO, IGNORE PARM...\n         LR    R15,R2             R15 = LTH OF CPPL PARM\n         SH    R15,=H'4'          - 4 FOR RDW...\n         SH    R15,0(0,R10)       - OFFSET TO PARM...\n         AH    R10,0(0,R10)       R10 -> TO CMD\n         LA    R10,2(0,R10)       R10 -> TO REAL PARM\n         LR    R4,R10             SO DOES R4\n         LA    R2,5               SET LTH TO 5\n         CH    R15,=H'5'          IS PARM LTH 5?\n         BE    PARM1              YES                               Y2\n         LA    R2,7               SET LTH TO 7                      Y2\n         CH    R15,=H'7'          IS PARM LTH 7?                    Y2\n         BE    PARM2              YES                               Y2\n         B     ENDPARM            NO, IGNORE IT                     Y2\n*        BNE   ENDPARM            NO, IGNORE IT\n*\n*              WE WILL ASSUME SOMEONE ON TSO CALLED JDATE AS A CMD...\n*\n*        AH    R10,0(0,R10)       R10 -> TO CMD\n*        LA    R10,2(0,R10)       R10 -> TO REAL PARM\n*        LR    R4,R10             SO DOES R4\n*        LA    R2,5               SET LTH TO 5\n         SPACE 1\nPARM1    DS    0H                 5 BYTE PARM                       Y2\n         TIME  DEC,SAVETIME,            GET THE SYS TIME            Y2 +\n               LINKAGE=SYSTEM,DATETYPE=YYYYMMDD     IN THIS CASE    Y2\n         UNPK  PARMDATA(3),SAVETIME+8(2) SET CENTURY                Y2\n*        MVC   PARMDATA(2),=C'19' SAY CENTURY IS 19                 Y2\n         MVC   PARMDATA+2(5),0(R10) SAVE PARM                       Y2\n         B     PARM3              ON WE GO                          Y2\n         SPACE 1                                                    Y2\nSAVETIME DC    XL16'00'                                             Y2\nPARMDATA DC    CL7' '                                               Y2\n         SPACE 1                                                    Y2\nPARM2    DS    0H                 7 BYTE PARM                       Y2\n         MVC   PARMDATA(7),0(R10) SAVE PARM                         Y2\n         SPACE 1                                                    Y2\nPARM3    DS    0H                                                   Y2\n         LA    R4,PARMDATA        R4 -> TO PARM                     Y2\n         LR    R10,R4             R10 -> TO PARM                    Y2\n         SPACE 1                                                    Y2\nPARM5    DS    0H\n         CLI   0(R4),C'0'         IS IT LESS THAN 0?\n         BL    ENDPARM            YES, IGNORE IT\n         CLI   0(R4),C'9'         IS IT MORE THAN 9?\n         BH    ENDPARM            YES, IGNORE IT\n         LA    R4,1(0,R4)         R4 -> TO NEXT KEY BYTE, IF ANY\n         BCT   R2,PARM5           CHECK ALL CHARS LEFT\n         PACK  LINE(4),PARMDATA   CONVERT DATE TO DECIMAL           Y2\n*        PACK  LINE(4),0(5,R10)   CONVERT DATE TO DECIMAL\n         SPACE 1\nENDPARM  DS    0H\n         CALL  DAYDATE,(LINE),VL  GO GET TODAYS DATE\n         CLI   NOCPPL,X'00'       DO WE HAVE A CPPL ?\n         BE    USEPUTL            YES, USE PUTLINE..\n         LA    R0,40              MESSAGE LENGTH\n         LA    R1,LINE            MESSAGE ADDR\n         TPUT  (1),(0)            TSO MESSAGE SENT\n         B     ERREXIT            ON WE GO\n         SPACE 1\nUSEPUTL  DS    0H\n*        LA    R2,L'LINE          ENTIRE LINE LENGTH\n*        LA    R2,4(0,R2)         ADD RDW LEN\n*        STH   R2,RDWP\n         PUTLINE PARM=PUTLIST,OUTPUT=(RDWP,TERM,SINGLE,DATA),          +\n               MF=(E,IOPLADD)\nERREXIT  DS     0H\n*        L      R13,4(0,R13)      R13 -> TO SYSTEM SAVE AREA\n*        RETURN (14,12),RC=0      RETURN TO SYSTEM\n         LA    R15,0              R15 = RC=0\n         L     R13,4(R13)         R13 -> TO CALLERS SAVE AREA\n         L     R14,12(R13)        SET R14 TO WHAT CALLER'S R14\n         LM    R0,R12,20(R13)     SET R0-R12 TO CALLERS REGS\n*              GET INTO PROPER MODE AND GO BACK TO CALLER\n         BSM   0,R14              RETURN TO CALLING PROGRAM\n         SPACE 2\nSAVE     DC    18F'-1'\nANSWER   DS    0F\nTIOT     DS    F\nTSO      DS    F\nPUTLIST  PUTLINE MF=L\n         DS    0F                 ALIGN ON FULLWORD\nRDWP     DC    H'44'              LTH OF LINE + 4\n         DC    H'0'               FILLER\nLINE     DC    CL40' '\nECB      DC    F'0'\nIOPLADD  DS    4F\nNOCPPL   DC    X'00'              FF IF NO CPPL\n         SPACE 1\n         LTORG\n         SPACE 1\n         IKJCPPL\n         IKJIOPL\n         SPACE 1\n*    REGISTER EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n          END   JDATE\n/*\n//*\n//* NOTE...IF SYSLMOD IS A DATASET IN YOUR STEPLIB OR LINKLIST,\n//* JDATE CAN BE RUN IN TSO BY JUST ENTERING JDATE\n//*\n//LKED.SYSLMOD DD DSN=HALL.LINKLIB,DISP=SHR\n//LKED.SYSLIN2 DD DSN=IMSVS.AUTHLIB1,DISP=SHR\n//LKED.SYSIN DD *\n  INCLUDE SYSLIN2(DAYDATE)\n  SETCODE AC(0)\n  NAME JDATE(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JOBNAME": {"ttr": 18186, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x14G\\x01 \\x01 \\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T14:47:00", "lines": 288, "newlines": 288, "modlines": 0, "user": "RH87944"}, "text": "//JOBNAME JOB\n/*ROUTE  PRINT  R7\n//* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n//* $  CBT.SOURCE(JOBNAME)\n//* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n//S1        EXEC  HLASMCL,CLASS='*',\n//   COND.LKED=(7,LT,ASM)\n//ASM.SYSLIB DD DSN=SYS1.MACLIB\n//   DD DSN=SYS2.HASPMODS.PROD.SOURCE,DISP=SHR  BCSC SOURCE\n//   DD DSN=SYS1.HASPSRC,DISP=SHR\n//   DD DSN=SYS1.AMODGEN,DISP=SHR\n//   DD DSN=SYS1.MODGEN,DISP=SHR\n//ASM.SYSIN DD  *\n*\n*              NOTE... THIS VERSION WILL WORK ON STARTED TASKS!\n*\n*              THIS LITTLE PROGRAM IS USED TO GET THE\n*              JOBNAME AND THE JOB NUMBER FOR THE CALLING JOB,\n*\n*              INPUT TO JOBNAME   IS THROUGH A PASSED PARM.\n*\n*              INPUT IS :\n*              A(JOBNAME)     PLACE  TO PUT JOB NAME\n*              A(JOBNUMBER)   PLACE  TO PUT JOB NUMBER\n*\n*\n*              THIS PGM IS AN EXAMPLE OF HOW TO USE JES2\n*              CONTROL BLOCKS TO  GET YOUR JOB NUMBER\n*              SEE SYS2.SMP.SOURCE($GETWHO) ALSO\n*\n*              WE ALSO USE 31 BIT  ADDRESSING\n*\n         PRINT ON                  RESTORE THE PRINT ENVIRONMENT   @136\n         TITLE 'GET JOB NAME AND NUMBER FROM JES2'\n         SPACE 3\nJOBNAME  CSECT\n*OBNAME  AMODE 31\n*OBNAME  RMODE ANY\n         USING JOBNAME,R15\n         B     AROUND             BRANCH AROUND DUMP TITLE\n         DC    AL1(EYELTH)\nEYECATCH DS    0C                 IDENTIFIER\n         DC    C'JOBNAME '        PROGRAM NAME\n         DC    C'VERSION 2 '      VERSION NUMBER\n         DC    C' '               BLANK\n         DC    C'&SYSDATE'        DATE WRITTEN\n         DC    C' '               BLANK\n         DC    C'&SYSTIME'        TIME WRITTEN\n         DC    C' '               BLANK\n         DC    C'GET JOBNAME/NUMBER'\n         DC    C' '               BLANK\nEYELTH   EQU   *-EYECATCH         LTH OF EYE CATCHER\n         SPACE 1\nAROUND   DS    0H\n         DROP  R15                DROP R15 BASE\n         LA    R1,0(0,R1)         CLEAR HI-ORDER BYTE FOR 31 BIT\n         LA    R13,0(0,R13)       CLEAR HI-ORDER BYTE FOR 31 BIT\n         BSM   R14,0              SAVE CURRENT AMODE\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         USING JOBNAME,R12\n         LR    R6,R1              R6 -> TO PARM ADDRESS\n         LA    R4,SAVE            R4 -> TO SAVE AREA\n         ST    R13,SAVE+4         CHAIN\n         ST    R4,8(0,R13)              SAVE\n         LA    R13,SAVE                    AREAS\n*\n*        BECAUSE SOME OF THE CONTROL BLOCKS MUST BE ACCESSED IN 31\n*        BIT MODE (SVT  FOR ONE) PUT US INTO 31 BIT MODE ADDRESSING\n*\n         LA    R12,0(0,R12)       CLEAR BYTE 0 OF BASE REG 12       RH\n*        LA    R1,*+4             GET 31 BIT MODE ADDRESS           RH\n*        A     R1,EIGHTBIT        GET 31 BIT MODE ADDRESS           RH\n         L     R1,XADDR1          GET 31 BIT MODE ADDRESS           RH\n         BSM   0,R1               GET INTO 31 BIT MODE              RH\n         DS    0F                 ALIGN ON FULLWORD\nXADDR1   DC    A(*+4+X'80000000') NEXT ADDRESS IS 31 BIT MODE       RH\n*ADDR1   DC    X'80',AL3(*+3)     NEXT ADDRESS IS 31 BIT MODE       RH\n*\n*\n*********************************************************************\n*\n*              GET THE TIOT SO WE  CAN GET OUR JOBNAME\n*\n*********************************************************************\n*\nCHEKTIOT DS    0H\n         USING PSA,R0             SET PSA  BASE\n         L     R1,PSATOLD         R1 = A(OUR TCB)\n         DROP  R0                 DROP PSA BASE\n         L         R1,12(R1)      R1 = A(TIOT)\n         MVC   JOBSNAME,0(R1)     SAVE OUR JOBNAME\n         SPACE 1\n*\n*********************************************************************\n*\n*              GET THE JES2 SJB SO WE CAN GET OUR JOBNAME/NUMBER\n*              THIS IS TAKEN FROM  SYS1.HASPMODS.PROD.SOURCE($SETWHO)\n*              THIS WAS TAKEN FROM  SYS2.SMP.SOURCE($SETWHO)\n*\n*********************************************************************\n*\n         USING PSA,R0             SET PSA  BASE\n         L     R1,PSATOLD         R1 = A(OUR TCB)\n         DROP  R0                 DROP PSA BASE\n         L     R1,TCBJSCB-TCB(,R1)      R1 -> TO OUR TCB\n         L     R1,JSCBACT-IEZJSCB(,R1)  R1 -> TO OUR JSCB\n         L     R1,JSCBSSIB-IEZJSCB(,R1) R1 -> TO OUR SSIB\n         L     R5,SSIBSUSE-SSIB(,R1)    R5 -> TO OUR SJB\n         USING SJB,R5             SET BASE\n         CLC   =C'SJB',0(R5)      DO WE REALLY HAVE THE SJB?\n         BNE   NOMOVE             NO, BYPASS MVC'S\n         LA    R1,64              R1 = LTH TO SEARCH\n         LA    R2,SJBJOBNM        R2 -> TO WHERE JOBNAME S/B IN SJB\n         SPACE 1\nFNDJOBNM DS    0H                                                   RH\n         CLC   JOBSNAME,0(R2)     SAME JOBNAME AS IN TIOT?\n         BE    GOTJOBNM           YES, JOBNAME IS SET\n         LA    R2,1(0,R2)         R2 -> TO NEXT BYTE\n         BCT   R1,FNDJOBNM        GO CHECK AGAIN\n         B     NOMOVE             NO JOBNAME, LEAVE FIELDS BLANK\n         SPACE 1\nGOTJOBNM DS    0H                                                   RH\n         SH    R2,=H'8'           R2 -> TO JOB NUMBER\n         MVC   JOBSNUMB,0(R2)     SAVE THE JOB NUMBER FROM THE SJB\n*        MVC   JOBSNAME,SJBJOBNM  SAVE THE JOB NAME   FROM THE SJB\n*        MVC   JOBSNUMB,SJBJOBID  SAVE THE JOB NUMBER FROM THE SJB\n         SPACE 1\nNOMOVE   DS    0H                                                   RH\n*\n*        NOW GO BACK TO 24 BIT MODE ADDRESSING\n*\n         LA    R1,XADDR4          GET BACK INTO 24 BIT MODE         RH\n         BSM   0,R1               ''                                RH\nXADDR4   DS    0H                                                   RH\n*\n         TM    0(R6),X'80'        IS 1ST PARM ONLY PARM?\n         BO    NOPARM             YES, PUT JOBNAME TO SYSPRINT\n         SPACE 1\n         L     R1,0(0,R6)         R1 -> TO PLI JOBNAME FIELD\n*        L     R1,0(0,R1)         R1 -> PLI ARGUMENT IN SDV\n         MVC   0(8,R1),JOBSNAME   PUT JOBNAME IN PLI FIELD\n         L     R1,4(0,R6)         R1 -> TO PLI JOBNBR FIELD\n*        L     R1,0(0,R1)         R1 -> PLI ARGUMENT IN SDV\n         MVC   0(8,R1),JOBSNUMB   PUT JOBNBR IN PLI FIELD\n         B     RETURN9            WE ARE FINISHED\n         SPACE 1\nNOPARM   DS    0H\n         MVC   PRTJOB,JOBSNAME    PUT JOBNAME IN OUTPUT\n         MVC   PRTNBR,JOBSNUMB    PUT JOBNBR IN OUTPUT\n*\n*        OPEN SYSPRINT DATASET\n*\n         LA    R6,SYSPRINT        R6 -> TO DCB\n         USING IHADCB,R6\n*        TM    DCBOFLGS,DCBOFOPN  TEST IF OPEN\n*        BNZ   RPTOPEN          IF ALREADY OPEN\n         OPEN  (SYSPRINT,(OUTPUT))\n         TM    DCBOFLGS,DCBOFOPN  TEST IF OPEN\n         BNO   RETURN9          IF CANNOT OPEN\n         DROP  R6\n         SPACE 1\nRPTOPEN  DS    0H\n*\n*            GO TO 24 BIT MODE ADDRESSING FOR PRINTING\n*\n         LA    R1,*+4+2           GET INTO 24 BIT MODE              RH\n         BSM   0,R1               ''                                RH\n*\n         PUT   SYSPRINT,HDR1      PRINT 1ST 120 CHARS OF MSG\n*\n*        GET BACK TO 31 BIT MODE ADDRESSING\n*\n         L     R1,XADDR2          GET 31 BIT MODE ADDRESS           RH\n*        LA    R1,*+4             GET 31 BIT MODE ADDRESS           RH\n*        A     R1,=F'80000000'    GET 31 BIT MODE ADDRESS           RH\n         BSM   0,R1               GET INTO 31 BIT MODE              RH\n         DS    0F                 ALIGN ON A FULLWORD BOUNDARY      RH\nXADDR2   DC    A(*+4+X'80000000') NEXT ADDRESS IS 31 BIT MODE       RH\n*ADDR1   DC    X'80',AL3(*+3)     NEXT ADDRESS IS 31 BIT MODE       RH\n         SPACE 1\n*        LA    R6,SYSPRINT        R6 -> TO DCB\n*        USING IHADCB,R6\n*        TM    DCBOFLGS,DCBOFOPN  TEST IF OPEN\n*        BZ    RPNTOPEN           NOT OPEN, SO DON'T CLOSE IT\n         CLOSE (SYSPRINT)         CLOSE SYSPRINT FILE\n         SPACE 1\nRPNTOPEN DS    0H\n         SPACE 1\nRETURN9  DS    0H\n         L     R13,SAVE+4\n         LM    R14,R12,12(R13)\n         SLR   R15,R15\n         BR    R14\n         SPACE 3\n* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n*        WORK AREAS\n* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\nDUMPTITL DC    C'WORKING STORAGE SECTION'\nSAVE     DC    18F'-1'\nJOBSNUMB DC    CL8'NO PIT'\nJOBSNAME DC    CL8'NONE'\n*\nEIGHTBIT EQU   X'80000000'\n         SPACE 1\n*PRTLINE DS    CL121\nHDR1     DS    0CL121\n         DC    C' '\nPRTJOB   DC    CL8' '\nBYTE2    DC    C' '\nPRTNBR   DC    CL8' '\n         DC    CL(121-(*-HDR1))'  '\n         SPACE 2\n         LTORG\n         SPACE 3\n* ------ DCB'S                    ------------------------------------\n         SPACE 3\n         PRINT NOGEN\n*\nSYSPRINT DCB   DSORG=PS,DDNAME=SYSPRINT,LRECL=121,RECFM=FBA,        XXXX\n               MACRF=(PM),BLKSIZE=121\n         SPACE 1\n*\n         SPACE 1\n         LTORG\n         SPACE 1\n         PRINT NOGEN\n         CVT   DSECT=YES,LIST=NO\n         IHAPSA\n         IEFJSCVT\n         IEFJESCT\n        IKJPSCB\n        IKJTCB\n        IEZJSCB\n        IEFJSSIB\n        IFGRPL AM=VTAM,                                                X\n               DSECT=YES\n$MAXDA   EQU   253                      REFERENCE MACRO - $HASPEQU\n        $BUFFER\n        $JCT\n         PRINT   GEN\n$ODANYWP EQU   1\n$TKNLEN  EQU   8\n        $SJB\n        $TQE\n*\n         DCBD  DEVD=DA,DSORG=QS\n*\n*    REGISTER EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   JOBNAME\n/*\n//LKED.SYSLMOD DD DSN=SYS9.IMSUTIL.LOAD,DISP=SHR\n//LKED.SYSIN DD *\n  SETCODE AC(0)\n  NAME JOBNAME(R)\n/*\n//*\n//*\n//COPYPGM EXEC PGM=PDSFAST,REGION=4096K,COND=(0,NE)\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=X,HOLD=YES\n//SYSUT3   DD UNIT=SYSDA,SPACE=(CYL,(50,10))\n//SYSUT4   DD UNIT=SYSDA,SPACE=(CYL,(50,10))\n//*\n//SYSLOUT      DD DSN=IMSVS.AUTHLIB1,DISP=SHR\n//SYSLIN       DD DSN=SYS9.IMSUTIL.LOAD,DISP=SHR\n//SYSIN    DD *\n COPY I=SYSLIN,O=SYSLOUT\n S M=((JOBNAME,,R))\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LINKDATE": {"ttr": 18433, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x14I\\x01\\xcf\\x01\\xcf\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T14:49:00", "lines": 463, "newlines": 463, "modlines": 0, "user": "RH87944"}, "text": "//LINKDATE JOB\n//*\n//*    DSN=CBT.SOURCE(LINKDATE)\n//*\n/*ROUTE PRINT R7\n//S EXEC HLASMCL,PARMC='NOALIGN,NORLD',CLASS='*',COND.LKED=(7,LT,ASM),\n//  PARML=REUS\n//ASM.SYSLIB DD DSN=SYS1.MACLIB\n//   DD DSN=SYS1.AMODGEN,DISP=SHR\n//ASM.SYSIN DD *\n*\n***********************************************************************\n*                                                                     *\n*             MODULE NAME = LINKDATE                                  *\n*                                                                     *\n*             DESCRIPTIVE NAME =  PROGRAM TO CREATE LIST OF MEMBER    *\n*                NAMES AND LINK DATES IN A PDS.                       *\n*                                                                     *\n*             STATUS = RELEASE 01.0                                   *\n*                                                                     *\n*   FUNCTION =                                                        *\n*        THIS PROGRAM READS THE DIRECTORY OF A PDS AND BUILDS AN      *\n*        INTERNAL TABLE OF MEMBER NAMES                               *\n*                                                                     *\n*        MEMBERS ARE READ TO DETERMINE THE DATE THAT IT WAS           *\n*        LINK EDITED.  IT WILL WRITE OUT A RECORD FOR EACH            *\n*        MEMBER WITH A LINK EDIT DATE.                                *\n*\n*        ENTRY POINTS:\n*           LINKDATE\n*\n*        PARAMETERS:\n*                   MBR= TO SPECIFY A SINGLE MEMBER TO ACCESS.\n*\n*                                                                     *\n*                OPERATION =                                          *\n*                   READ PDS DIRECTORY AND CREATE MEMBER TABLE.       *\n*                   READ EACH MEMBER LOOKING FOR TYPE 8011 RECORD.    *\n*                   LIST MEMBER NAME AND LINK DATE.                   *\n*                   AT END OF LIST CLOSE DATASETS AND FREE ANY        *\n*                      AQUIRED AREAS.                                 *\n*                                                                     *\n*              NOTES =                                                *\n*                                                                     *\n*                 DEPENDENCIES = CHARACTER SET IS EBCDIC.  REASSEMBLE *\n*                    IF A DIFFERENT CHARACTER SET IS NEEDED.          *\n*                                                                     *\n*                 RESTRICTIONS = DATASETS MUST HAVE LRECL LESS THAN   *\n*                    255 AND MUST BE EITHER FIXED OR VARIABLE FORMAT. *\n*                                                                     *\n*                 REGISTER CONVENTIONS = STANDARD CONVENTIONS.        *\n*                    REGISTERS 0 TO 10 = WORK REGISTERS               *\n*                    REGISTER  11      = SECOND BASE REGISTER         *\n*                    REGISTER  12      = ADDRESSABILITY TO LINKDATE   *\n*                                        CSECT                        *\n*                    REGISTER  13      = SAVE AREA REGISTER AND       *\n*                                        ADDRESSABILITY TO GETMAINED  *\n*                                        WORK AREA                    *\n*                    REGISTERS 14,15   = WORK REGISTERS               *\n*                                                                     *\n*                                                                     *\n*             MODULE TYPE = PROCEDURE                                 *\n*                                                                     *\n*                PROCESSOR = ASM                                      *\n*                                                                     *\n*                MODULE SIZE = 5K BYTES                               *\n*                                                                     *\n*                ATTRIBUTES = SCHEDULER KEY 8, NON-REENTRANT,         *\n*                   PROBLEM PROGRAM STATE                             *\n*                                                                     *\n*                LINKAGE =                                            *\n*                   FROM SYSTEM                                       *\n*                                                                     *\n*             OUTPUT = LIST OF MEMBERS AND LINK DATES                 *\n*                                                                     *\n*             EXIT - NORMAL = AT PROGRAM END VIA BRANCH REGISTER 14   *\n*                                                                     *\n*                RETURN CODE = ZERO                                   *\n*                                                                     *\n*             EXIT - ERROR = NONE - PROGRAM WILL DISPLAY DECIMAL      *\n*                RETURN CODE AND RETURN VIA BRANCH REGISTER 14        *\n*                                                                     *\n*                OUTPUT = NONE                                        *\n*                                                                     *\n*                RETURN CODE = ZERO                                   *\n*                                                                     *\n*             EXTERNAL REFERENCES =                                   *\n*                                                                     *\n*                ROUTINES = NONE?                                     *\n*                                                                     *\n*                DATA AREAS = NONE                                    *\n*                                                                     *\n*                CONTROL BLOCKS = DCB, RDJFCB, ETC.                   *\n*                                                                     *\n*             TABLES = DATA AREA TO BE GETMAINED.  MAPPED BY DSECT    *\n*                BEGINNING AT LABEL RDATD.                            *\n*                                                                     *\n*             MACROS = SAVE, GETMAIN, FREEMAIN,                       *\n*                   OPEN, PUT, GET, CLOSE, RDJFCB,                    *\n*                   DCB, DCBD                                         *\n*                                                                     *\n*             CHANGE ACTIVITY = NONE                                  *\n*                                                                     *\n*             ABEND CODES = 799                                       *\n*                           999                                       *\n*                                                                     *\n***********************************************************************\n*\n*        REGISTER EQUATES\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\n*        ENTRY POINT\n*\nLINKDATE CSECT\n*\n         USING *,15      GET TEMP ADDRESSABILITY\n         B     CONTINUE   BRANCH AROUND ID\n         DC    AL1(IDLTH)\nEYECATCH DC    CL8'LINKDATE'  IDENTIFIER\n         DC    CL9'VERSION 1' IDENTIFIER\n         DC    CL8'&SYSDATE'  IDENTIFIER\n         DC    CL8'&SYSTIME'  IDENTIFIER\nIDLTH    EQU   *-EYECATCH\n         SPACE 1\nCONTINUE DS    0H\n         STM   14,12,12(13)  SAVE REGISTERS\n         DROP  15\n         LR    12,15        SET BASE REG.\n         USING LINKDATE,12\n         LA    14,SAVEAREA\n         ST    13,4(14)      SAVE REGS 13 AND\n         ST    14,8(13)      BACK CHAIN\n         LR    13,14         GET SAVE AREA ADDRESS\n         ST    R1,SAVER1     SAVE REG 1\n         MVC   MBRNAME,=CL8' '    CLEAR MBR NAME FIELD\n         L     R2,0(0,R1)         R2 -> TO SYSTEM PARM\n*        OPEN  (REPORT,(OUTPUT))  OPEN SYSPRINT FILE\n         SPACE 1\n***********************************************************************\n*\n*              SEE IF THERE IS A  PARM\n*\n*        VALID PARMS ARE:\n*              MBR= ......MEMBER NAME TO GET LINK DATE FOR\n*\n*        ANY OTHER PARMS ARE INVALID\n*        IF NO PARMS ARE SPECIFIED, THE DEFAULTS WILL BE\n*              PARM='MBR=ALL'\n*\n***********************************************************************\n         SPACE 1\n*              GET PARM, IF ANY\n         SPACE 1\nPARM0    DS    0H\n         LA    R10,2(0,R2)        R10 -> TO PARM\n         LH    R2,0(0,R2)         R2 = PARM LTH\n         LTR   R2,R2              IS THERE A PARM ?\n         BZ    ENDPARM            NO\n         LR    R4,R10             YES, R4 -> TO PARM\n         SPACE 1\nPARM1    DS    0H\n         CLC   =C'MBR=',0(R4)     IS IT THE 'MBR=' PARM?\n         BNE   PARM2              NO, CHECK FOR NEXT PARM\n         SPACE 1\n         LA    R4,4(0,R4)         R4 -> PAST MBR=\n         SH    R2,=H'4'           R2 = LTH OF REST OF PARM\n         LR    R5,R4              R5 -> TO MBR NAME\n         SPACE 1\nPARM1B   DS    0H\n         CLI   0(R4),C','         AT END OF MBR ?\n         BE    PARM1C             YES, GO GET NEXT PARM\n         LA    R4,1(0,R4)         R4 -> TO NEXT KEY BYTE, IF ANY\n         BCT   R2,PARM1B          CHECK ALL CHARS LEFT\n         SPACE 1\nPARM1C   DS    0H\n         LR    R6,R4              R6 -> TO END OF MBR NAME\n         SR    R6,R5              R6 = LTH OF MBR NAME\n         BCTR  R6,0               R6 = HEX LTH\n         MVC   MBRNAME,=CL8' '    CLEAR MBR NAME FIELD\n         EX    R6,MVCMBR          SET UP MBR NAME\n         LA    R9,1               SET R9 TO SAY WE HAVE 1 MBR NAME\n         B     NEXTPARM           GO CHECK FOR ANOTHER PARM\n         SPACE 1\nMVCMBR   MVC   MBRNAME(0),0(R5)   MOVE MBR NAME\n         SPACE 1\nPARM2    DS    0H\n         SPACE 1\n         SPACE 1\nPARM99   DS    0H\n         B     BADPARM            PRINT BAD PARM MSG\n         SPACE 1\nNEXTPARM DS    0H\n         LTR   R2,R2              ANY PARM LEFT?\n         BNP   ENDPARM            NO\n         LA    R4,1(0,R4)         YES, R4 -> TO NEXT BYTE\n         BCTR  R2,0               TAKE 1 OFF PARM LTH\n         CLI   0(R4),C','         COMMA?\n         BNE   PARM1              NO, GO SEE WHAT IT IS\n         B     NEXTPARM           LOOK AT ALL CHARS IN PARM\n         SPACE 1\nENDPARM  DS    0H\n*\n*        OPEN OUTPUT DATASET\n*\n         OPEN  (OUTREC,(OUTPUT)) OPEN SCRATCH CARD DATASET\n         OPEN  (PRINT,(OUTPUT))  OPEN PRINT FILE\n         CLI   MBRNAME,C' '       IS MBR NAME FIELD BLANK?\n         BNE   LOADMBR1           NO, GO PROCESS MEMBER\n*\n*        OPEN LIBRARY DIRECTORY TO GET ALL MEMBERS OF THE PDS\n*\n         OPEN  (INPDS,(INPUT))\n*\n*        ISSUE GETMAIN FOR MEMBER AREA\n*\n         SR    R5,R5           ZERO REG 5\n         L     R5,=F'9000'     WANT ROOM FOR MAXIMUM MEMBERS\n         SLL   R5,3        TIMES 8 PER MEMBER NAME\n         GETMAIN R,LV=(R5),SP=10\n         ST    R1,MBRAREA  SAVE AREA ADDRESS\n         LR    R7,R1       AND LOAD INTO R7\n         SRL   R5,3        RESET TO NUMBER OF MEMBERS ALLOWED\n         SR    R9,R9       ZERO MEMBER COUNTER\n*\n*        GET DIRECTORY BLOCK\n*\nDIRREAD  EQU   *\n         LA    R6,DIRREC\n         READ  UT1DECB,SF,INPDS,(R6),,S\n         CHECK UT1DECB\n         CLC   0(2,R6),=H'0'  IF LENGTH IS ZERO END DIRECTORY SEARCH\n         BE    LOADMBR\n*\n         LR    R1,R6          SAVE BEGINNING OF BLOCK\n         AH    R1,0(R6)       POINT TO END OF BLOCK\n         LA    R6,2(0,R6)    POINT PAST LENGTH FIELD\n*\nTHISMBR  EQU   *\n         CR    R6,R1         IF AT END OF BLOCK\n         BNL   DIRREAD       GET ANOTHER ONE\n         CLI   0(R6),X'FF'   IF MEMBER HAS HIGH VALUES END DIR. SEARCH\n         BE    LOADMBR\n         CLI   0(R6),X'00'   IF MEMBER HAS LOW VALUES BYPASS SAVE\n         BE    NEXTMBR\n         MVC   0(8,R7),0(R6) SAVE MEMBER NAME IN MEMBER AREA\n         LA    R7,8(0,R7)      POINT TO NEXT ENTRY IN MEMBER AREA\n         LA    R9,1(0,R9)      INCREMENT MEMBER COUNT\n         CR    R9,R5         IS MEMBERS UP TO MAXIMUM?\n         BNL   LOADMBR       IF YES, END DIRECTORY SEARCH\n*\nNEXTMBR  EQU   *\n         NI    11(R6),31      LOOK AT ONLY THE \"C\" FIELD IN ENTRY\n         SR    R8,R8\n         IC    R8,11(R6)       MOVE \"C\" FIELD TO R8\n         SLL   R8,1           MULTIPLY BY 2\n         LA    R6,12(R8,R6)     POINT TO NEXT ENTRY IN DIRECTORY BLOCK\n         B     THISMBR        BRANCH TO PROCESS NEXT ENTRY\n*\n*        THIS ROUTINE LOADS EACH MEMBER OF THE PDS\n*\nLOADMBR  EQU   *\n         CLOSE INPDS            CLOSE DIRECTORY DCB\n*\n         LTR   R9,R9          IF NO MEMBERS THEN\n         BZ    NOMBRS         LEAVE ROUTINE WITH MESSAGE\n*\n*        ISSUE GETMAIN TO HOLD BLOCKS\n*\nLOADMBR1 EQU   *\n         SR    R5,R5           ZERO REG 5\n         L     R5,=F'32000'    WANT ROOM FOR MAXIMUM\n         GETMAIN R,LV=(R5),SP=10\n         ST    R1,BLKAREA  SAVE AREA ADDRESS\n*\n         OPEN  (INPDSA,(INPUT)) OPEN PDS DATASET\n*\nEOFREAD  DS    0H\nNOSYSIN  DS    0H\n         L     R6,MBRAREA    SET ADDRESS OF MEMBER AREA\n         SR    R7,R7             ZERO REGISTER 7\n         SPACE 1\n*\n*        FOR EACH MEMBER IN AREA WE WANT ISSUE FIND FOR IT IN PDS\n*\nFINDMBR  DS    0H\nFINDMBR2 DS    0H\n         MVC   MBRNAME,0(R6)     SAVE MEMBER NAME\n         FIND  INPDSA,(R6),D\n         LTR   15,15\n         BZ    READBLK            OKAY, ON WE GO\n*        BNZ   BADBAD          THIS REALLY SHOULDNT HAPPEN\n         MVC   BADMBR,MBRNAME     PUT MBR IN MSG\n         PUT   PRINT,BADFIND      PRINT MSG\n         B     GETNEXT          GET NEXT MEMBER\n*\n*        READ A BLOCK FROM PDS MEMBER\n*\nREADBLK  EQU   *\n         L     R8,BLKAREA        RESTORE BLOCK AREA ADDRESS\n         READ  UT1ADECB,SF,INPDSA,(R8),19069,S\n         CHECK UT1ADECB\n*\n*        DETERMINE IF CORRECT RECORD - LOOK FOR X'8011'\n*\n         CLC   0(2,R8),=X'8011'\n         BE    GOTREC            IF GOT THE RIGHT RECORD\n         CLC   0(2,R8),=X'8015'   PISS-ASS LE?\n         BE    GOTREC            IF GOT THE RIGHT RECORD\n         B     READBLK\n*\n*        SET UP TO READ NEXT MEMBER\n*\nGETNEXT  EQU   *\n         LA    R6,8(0,R6)\n         BCT   R9,FINDMBR     IF MORE MEMBERS\n         B     CLOSPDS\n*\n*        IF HAVE THE X'8011' RECORD THEN CHECK THE DATE\n*\nGOTREC   EQU   *\n*\n*        IF DATE LESS THAN SCRATCH DATE THEN WRITE OUT\n*        SCRATCH MEMBER CONTROL CARD\n*\n         UNPK  WORKD,15(3,R8)\n         MVC   PSDATE,WORKD+3\n         PUT   OUTREC,SCRCARD\n         LA    R7,1(R7)         INCREMENT COUNTER\n         B     GETNEXT          GET NEXT MEMBER\n*\n*        ERROR ROUTINES\n*\nBADPARM  EQU   *\n         MVC   MBRNAME,=C'BADPARM*'\n         MVC   PSDATE,SCRDATE\n         PUT   OUTREC,SCRCARD\n         LA    R15,16\n         B     BADEND           LEAVE\n*\nNOMBRS   EQU   *\n         MVC   MBRNAME,=C'NOMBRS**'\n         MVC   PSDATE,SCRDATE\n         PUT   OUTREC,SCRCARD\n         LA    R15,16\n         B     BADEND           LEAVE\n*\n*        CLOSE PDS\n*\nCLOSPDS  EQU   *\n         CLOSE (INPDSA,,OUTREC)\n*\n*        FREE STORAGE AREA\n*\n         FREEMAIN R,SP=10\n*\n*        AND RETURN\n*\nRETURN   EQU   *\n         CVD   R7,WORKD\n         MVC   OUTCNT,PATTERN\n         ED    OUTCNT,WORKD+4\n         PUT   PRINT,OUTPRT\n         LA    R15,0\n*\nBADEND   EQU   *\n         CLOSE PRINT\n         L     R13,4(R13)\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14                RETURN TO CALLING PROGRAM\n*\n*        ABEND\n*\nBADBAD   EQU   *\n         ABEND 799,DUMP,STEP\n*\n*        DEFINE VARIABLES\n*\n*\n***************************WORK AREAS *********************************\n*\n         SPACE 2\nMBRTYPE  DC    C' '\nSTARTMBR DC    CL8' '\nENDMBR   DC    CL8' '\nSYSDATA  DS    CL80\nSMBRLTH  DC    H'0'\nEMBRLTH  DC    H'0'\nSAVEALL  DC    18F'0'\n         CNOP  0,8\n*\nWORKD    DS   D\nWORKF    DS   F\nSAVEAREA DS   18F\n*\nSAVER1   DS    F\nBLKAREA  DS    F\nMBRCNT   DS    F\nMBRAREA  DC    A(MBRNAME)\nDIRREC   DC    XL256'00'\n*\nSCRCARD  DS    0CL80\nMBRNAME  DS    CL8\n         DC    CL2'  '\nPSDATE   DS    CL5\n         DC    CL65' '\n*\n***************************** CONSTANTS *******************************\n*\n         SPACE 2\nOUTPRT   DS    0CL133\nCCO      DC    CL1'0'\n         DC    CL29'NUMBER OF MEMBERS SELECTED : '\nOUTCNT   DS    CL8\n         DC    CL95' '\n*\nBADFIND  DS    0CL133\nCCB      DC    CL1'0'\n         DC    CL29'ERROR DOING FIND FOR MEMBER: '\nBADMBR   DS    CL8\n         DC    CL95' '\n*\nSCRATCHD DS    PL3\nTODAY    DS    PL3\nSCRDATE  DC    CL5'*****'\nPATTERN  DC    XL8'4020202020202020'\n*\n         LTORG\n*\nINPDS    DCB   DDNAME=INLIB,DSORG=PS,RECFM=F,BLKSIZE=256,MACRF=(R),    X\n               EODAD=LOADMBR\nINPDSA   DCB   DDNAME=INLIB,DSORG=PO,EODAD=GETNEXT,MACRF=(R),          X\n               RECFM=U,LRECL=256,BLKSIZE=19069\nOUTREC   DCB   DDNAME=OUTREC,DSORG=PS,RECFM=FB,BLKSIZE=3120,           X\n               MACRF=(PM),LRECL=80\nPRINT    DCB   DDNAME=SYSPRINT,DSORG=PS,RECFM=FBA,BLKSIZE=1330,        X\n               MACRF=(PM),LRECL=133\n*\n*\nBLANKS   DC    256CL1' '\n         END   LINKDATE\n//LKED.SYSLMOD DD DSN=SYS9.IMSUTIL.LOAD,DISP=SHR\n//SYSIN   DD *\n ENTRY   LINKDATE\n SETCODE AC(0)\n NAME    LINKDATE(R)\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LINKDATJ": {"ttr": 18441, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03?\\x00\\x99\\x03?\\x139\\x00\\x11\\x00\\x11\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-02T00:00:00", "modifydate": "1999-02-02T13:39:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "RH87944"}, "text": "//LINKDATJ JOB\n/*ROUTE  PRINT R7\n//*\n//*    DSN=CBT.SOURCE(LINKDATJ)\n//*\n//*  IF PARM IS SPECIFIED, ONLY THAT MEMBER IS PROCESSED\n//*\n//STEP1    EXEC PGM=LINKDATE,REGION=4000K    ,PARM='MBR=LINKDATE'\n//STEPLIB  DD DSN=SYS9.IMSUTIL.LOAD,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//SYSABEND DD SYSOUT=*\n//INLIB    DD DISP=SHR,DSN=IMSVS.TEST.PGMLIBB\n//*UTREC   DD UNIT=SYSDA,DISP=(,PASS),SPACE=(CYL,(1,1)),\n//*UTREC   DD DISP=SHR,DSN=HALL.LIST.MEMBERS\n//OUTREC   DD SYSOUT=*,\n//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MACROS": {"ttr": 18443, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x14\\x03\\x033\\x033\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T14:03:00", "lines": 819, "newlines": 819, "modlines": 0, "user": "RH87944"}, "text": "         SPACE    2\n*        MACRO     USED FOR...\n*        BEGIN     GENERATE ENTRY CODE WITH BASE REGS R13,&B,&C\n*        DEBUG     GENERATE CODE  TO PRINT A CSECT TRACE\n*        IBMMAC    GENERATE DCB AND JFCB DSECTS\n*        MSGRTN    GENERATE CODE TO PRINT MESSAGES\n*        OLCMSG    GENERATE CODE TO PRINT A MSG\n*        PERFORM   GENERATE CODE  TO BRANCH TO A CSECT\n*        REQUATE   GENERATE REGISTER EQUATES, AND A SAVEAREA DSECT\n*        SAVESET   GENERATE IMS STYLE SAVE AREAS\n*        SECEXIT   GENERATE CSECT EXIT CODE\n*        SECTION   GENERATE CSECT ENTRY CODE\n*\n*\n         SPACE 2\n         MACRO\n&NAME    BEGIN &A,&B,&C,&D,&AM=24,&RM=24\n         AIF   ('&NAME' NE '').GENLBL LABEL SPECIFIED?\n         MNOTE 8,'CSECT LABEL NAME MUST BE SPECIFIED'\n         MEXIT\n.GENLBL  ANOP\n*        PARMS ...\n*              &A = LABEL TO BRANCH TO FOR RETURN TO SYSTEM\n*                   LABEL &AX IS THE RETURN CODE HALFWORD\n*                   1ST BASE REGISTER IS R13\n*              &B = 2ND BASE REGISTER IF NEEDED\n*              &C = 3RD BASE REGISTER IF NEEDED\n*              &D = COMMENT.\n*             &AM = 24...DEFAULT AMODE\n*             &RM = 24...DEFAULT RMODE\n*\n*\n*        ENTRY POINT\n*\n&NAME    CSECT\n&NAME    AMODE &AM\n&NAME    RMODE &RM\n         USING *,R15      GET TEMP ADDRESSABILITY\n         B     *+5+EYELTH         BRANCH AROUND DUMP TITLE\n         DC    AL1(EYELTH)        LTH OF EYE CATCHER\nEYECATCH DS    0C\n         DC    CL08'&NAME'        PROGRAM NAME\n         AIF   (K'&NAME LT 8).NOBLANK\n         DC    C' '\n.NOBLANK ANOP\n         DC    CL8'&SYSDATE'      DATE WRITTEN\n         DC    CL1' '             BLANK\n         DC    CL6'&SYSTIME'      TIME WRITTEN\n         DC    CL1' '             BLANK\n         AIF   ('&D' EQ '').NOCOMM COMMENT SPECIFIED?\n         AIF   ('&D'(1,1) EQ '''').INQ COMMENT IN QUOTES?\n         DC    C'&D'          COMMENT...\n         AGO   .NOCOMM\n.INQ     ANOP\n         DC    C&D            COMMENT...\n.NOCOMM  ANOP\n         DS    0H\nEYELTH   EQU   *-EYECATCH         LTH OF EYE CATCHER\n         SPACE 1\n         LA    R1,0(0,R1)         CLEAR HI-ORDER BYTE FOR 31 BIT\n         LA    R13,0(0,R13)       CLEAR HI-ORDER BYTE FOR 31 BIT\n         BSM   R14,0              SAVE CURRENT AMODE\n         STM   R14,R12,12(R13)    SAVE CALLERS REGISTERS\n         CNOP  0,4                MAKE SURE R14 IS JUST BEFORE SAVE\n         BAL   14,*+76       BRANCH ROUND OUR SAVE AREA\n         DROP  R15\n         AIF   (T'&B NE 'O').NO1\n         USING *,13          GET ADDRESSABLITY\n         AGO   .NO3\n.NO1     AIF   (T'&C NE 'O').NO2\n         USING *,13,&B\n         AGO   .NO3\n.NO2     USING *,13,&B,&C\n.NO3     ANOP\n         SPACE 1\n         DC    18F'0'             SAVE AREA FOR REGISTERS\n         SPACE 1\n         LA    R14,0(0,R14)       CLEAR HI-ORDER BYTE SET BY BAL..\n         ST    R13,4(R14)      SAVE REGS 13 AND\n         ST    R14,8(R13)      BACK CHAIN\n         LR    R13,R14         GET SAVE AREA ADDRESS\n         AIF   (T'&B EQ 'O').NO4\n         LA    &B,2048(13)   GET SECOND BASE REGISTER\n         LA    &B,2048(&B)   GET SECOND BASE REGISTER\n         AIF   (T'&C EQ 'O').NO4\n         LA    &C,4095(0,&B)      SET UP THIRD BASE REGISTER        RH\n         LA    &C,1(0,&C)         *                                 RH\n.NO4     AIF   (T'&A NE 'O').B\n         MEXIT\n.B       XC    &A.X,&A.X     CLEAR RETURN CODE\n         B     A23K&SYSNDX   BRANCH ROUND RETURN\n         SPACE 1\n*\n*              CODE TO RETURN TO CALLER\n*\n&A       LA    15,0          GET RETURN CODE\n         ORG   *-2\n&A.X     DS    H             HALF WORD RETURN CODE, INITIALY ZERO\n         L     R13,4(0,R13)       POINT R13 BACK TO SYSTEM SAVEAREA\n         ST    R15,16(0,R13)      SET RETURN CODE\n         LM    R14,R12,12(R13)    RELOAD SYSTEMS REGS\n*              GET INTO PROPER MODE AND GO BACK TO CALLER\n         BSM   0,R14              RETURN TO CALLING PROGRAM\n         SPACE 3\nA23K&SYSNDX    DS    0H      START OF MAIN LINE CODE\n         MEND\n         SPACE    2\n         MACRO\n         IBMMAC\n.*\n.* IBM MACROS :\n.*\n.*       USED - TO GENERATE IBM MACROS\n.*\n         PRINT NOGEN\n*        DCBD  DSORG=(PS,PO),DEVD=DA\n         DCBD  DSORG=(PS,PO),DEVD=DA\nIHAJFCB  DSECT\n*        IEFJFCBN\n         IEFJFCBN\n         MEND\n         SPACE    2\n         MACRO\n         SAVESET &NBR\n.*\n.* SAVESET MACRO:\n.*\n.*       USED - TO DEFINE THE SAVE AREAS\n.*\n         PRINT GEN\n&N1      SETA  1\n&N2      SETA  2\n&N3      SETA  3\n         ENTRY SAVE     DEFINE ENTRY POINT USED OUTSIDE THIS CSECT\nSAVE     DS    0F\nSAVE&N1  DC    F'0'\n         DC    A(0)        PTR TO  PREV\n         DC    A(SAVE&N2)  PTR TO NEXT\n         DC    15F'0'      FOR R14 TO R12\n.LOOP    ANOP\nSAVE&N2  DC    F'0'\n         DC    A(SAVE&N1)  PTR TO  PREV\n         DC    A(SAVE&N3)  PTR TO NEXT\n         DC    15F'0'      FOR R14 TO R12\n&N1      SETA  &N1+1\n&N2      SETA  &N2+1\n&N3      SETA  &N3+1\n         AIF   (&N2 LT &NBR).LOOP\nSAVE&N2  DC    F'0'\n         DC    A(SAVE&N1)  PTR TO  PREV\n         DC    A(0)        PTR TO NEXT\n         DC    15F'0'      FOR R14 TO R12\n         MEND\n         SPACE    2\n         MACRO\n&LABEL   SECTION &CHAIN=NO,&GEN=NO,&BASE=1,&FIRST=NO,&CHKCHN=YES,      +\n               &DEBUG=NO,&TITLE=,&AMODE=24,&RMODE=24\n.*       SECTION MACRO:\n.*\n.*       USED - TO DEFINE THE VARIOUS SECTIONS OF CODE HEREIN\n.*              BASE REGISTER IS 12, AND IF REQUESTED, 11.\n.*\n.*       PARMS CHAIN=NO           GETMAINS SAVE AREAS\n.*             CHAIN=YES          USES PRE-DEFINED SAVE AREAS\n.*             GEN=NO             DOES NOT GENERATE MACRO CODE\n.*             GEN=YES            GENERATES MACRO CODE\n.*             BASE=1             ONLY 1 BASE REG (12)\n.*             BASE=2             USES 12 AND 11 AS BASE REGS\n.*             BASE=13            USES 13 AND 12 AS BASE REGS\n.*             FIRST=NO           THIS IS NOT THE FIRST CSECT\n.*             FIRST=YES          THIS IS THE FIRST CSECT\n.*             CHKCHN=NO          DON'T CHECK PRE-DEFINED SAVEAREAS\n.*             CHKCHN=YES         CHECK FOR NEXT PRE-DEFINED SAVEAREAS\n.*             DEBUG=NO           DON'T PRINT DEBUG INFO\n.*             DEBUG=YES          PRINT DEBUG INFO..NEEDS DEBUG MACRO\n.*             TITLE=             COMMENT ADDED AT START OF SECTION\n.*\n.*\n         AIF   ('&LABEL' NE '').GENLBL LABEL SPECIFIED?\n         MNOTE 8,'CSECT LABEL NAME MUST BE SPECIFIED'\n         MEXIT\n.GENLBL  ANOP\n&LABEL   CSECT\n&LABEL   AMODE &AMODE\n&LABEL   RMODE &RMODE\n         PRINT GEN\n         AIF   ('&GEN' NE 'NO').NOGEN   GEN ALL CODE?\n         PRINT NOGEN\n.*\n.NOGEN   ANOP\n         USING *,R15              SET TEMP BASE\n         B     CONT&SYSNDX        BRANCH AROUND EYECATCHER\n         DC    AL1(EYEL&SYSNDX)   LTH OF EYE CATCHER\nEYE&SYSNDX DS    0C\n         DC    CL8'&LABEL'          PROGRAM NAME\n         DC    CL8'&SYSDATE'      DATE ASSEMBLED\n         DC    C' '               BLANK\n         DC    CL8'&SYSTIME'      TIME ASSEMBLED\n         AIF   ('&TITLE' EQ '').NOCOMM TITLE SPECIFIED?\n         AIF   ('&TITLE'(1,1) EQ '''').INQ TITLE IN QOUTES?\n         DC    C'&TITLE'          COMMENT...\n         AGO   .NOCOMM\n.INQ     ANOP\n         DC    C&TITLE            COMMENT...\n.NOCOMM  ANOP\nEYEL&SYSNDX EQU   *-EYE&SYSNDX\n         AIF   ('&BASE' NE '13').NOBASE R13 AS BASE?\nSAVE&SYSNDX DS 18F                SECTION SAVE AREA\n.NOBASE  ANOP\nCONT&SYSNDX DS    0H\n         SPACE 1\n         LA    R1,0(0,R1)         CLEAR HI-ORDER BYTE FOR 31 BIT\n         LA    R13,0(0,R13)       CLEAR HI-ORDER BYTE FOR 31 BIT\n         BSM   R14,0              SAVE CURRENT AMODE\n         STM   R14,R12,12(R13)    SAVE CALLER'S REGISTERS\n         AIF   ('&BASE' NE '13').NOBASE2 R13 AS BASE?\n         LA    R12,SAVE&SYSNDX    R12 -> TO OUR SAVE REA\n         ST    R12,8(0,R13)       CHAIN OUR SAVE AREA TO HIS...\n         ST    R13,4(0,R12)       CHAIN HIS SAVE AREA TO OURS..\n         DROP  R15                DROP TEMP BASE\n.*\n         LR    R13,R12            SET 1ST BASE (R13)...\n         LA    R12,4095(0,R13)    SET 2ND BASE\n         LA    R12,1(0,R12)       ''\n         USING SAVE&SYSNDX,R13,R12  SET OUR BASE\n         AGO   .R13SET2           2 BASE REGS\n.NOBASE2 ANOP\n         LR    R12,R15            SET OUR BASE REG\n         DROP  R15                DROP TEMP BASE\n.*\n         AIF   ('&BASE' EQ '1').ONEBASE NEED 2 BASE REGS?\n         LA    R11,4095(0,R12)    SET 2ND BASE\n         LA    R11,1(0,R11)       ''\n         USING &LABEL,R12,R11     SET OUR BASE\n         AGO   .BASESET           2 BASE REGS\n.*\n.ONEBASE ANOP\n         USING &LABEL,R12         SET OUR BASE\n.*\n.BASESET ANOP\n         USING SAVEAREA,R13       SET SAVE AREA BASE\n         AIF   ('&FIRST' EQ 'NO').SAVESET  SET UP R13....\n         AIF   ('&CHAIN' EQ 'YES').CHAIN1   CHAINED (IMS) SAVEAREA\n         AGO   .GETSAVE\n         SR    R15,R15            R15 =0, TO FORCE 1ST GETMAIN\n         AGO   .CHAIN2\n.CHAIN1  ANOP\n         L     R15,=V(SAVE)       R15 -> TO OUR FIRST SAVE AREA\n.CHAIN2  ANOP\n         ST    R15,SAVENEXT       CHAIN OUR SAVE AREA TO HIS\n         AIF   ('&CHAIN' EQ 'NO').GETSAVE  NO CHAINED SAVEAREA\n         USING SAVEAREA,R15       SET SAVE AREA BASE TO OURS\n         ST    R13,SAVELAST       CHAIN HIS SAVE AREA TO OURS\n         DROP  R15                DROP OUR SAVE BASE\n.SAVESET ANOP\n.*       AIF   ('&CHAIN' EQ 'NO').CHK1      NOT CHAINED IMS SAVEAREA\n         AIF   ('&CHAIN' EQ 'NO').GETSAVE   NOT CHAINED IMS SAVEAREA\n         AIF   ('&CHKCHN' EQ 'NO').R13SET   DON'T CHECK NEXT SAVEAREA\n.*\n.CHK1    ANOP\n         ICM   R2,15,SAVENEXT     R2 -> TO NEXT SAVE AREA IN CHAIN\n         BP    A&SYSNDX           B IF THERE IS ONE\n.GETSAVE ANOP\n*        GETMAIN R,LV=72          GET THE NEXT SAVE AREA\n         GETMAIN R,LV=72          GET THE NEXT SAVE AREA\n         ST    R1,SAVENEXT        CHAIN NEW SAVE AREA TO PREV       RH\n         DROP  R13                DROP SAVE AREA BASE               RH\n         USING SAVEAREA,R1        SET NEW SAVE AREA BASE            RH\n         ST    R13,SAVELAST       CHAIN PREV SAVE AREA TO NEXT      RH\n         SR    R2,R2              R2 = 0\n         ST    R2,SAVENEXT        MAKE SURE SAVENEXT IS 0           RH\n         DROP  R1                 DROP NEW SAVE AREA BASE           RH\n         USING SAVEAREA,R13       SET SAVE AREA BASE                RH\n         L     R0,SAVER0          RELOAD R0\n         L     R1,SAVER1          RELOAD R1\n         L     R2,SAVER2          RELOAD R2\n.*\n.R13SET  ANOP\n         SPACE 1\nA&SYSNDX DS    0H                                                   RH\n         L     R13,SAVENEXT       POINT TO NEXT SAVE AREA IN CHAIN\n.*\n.R13SET2 ANOP\n         AIF   ('&DEBUG' EQ 'NO').NDB\n         AIF   ('&LABEL' EQ 'DEBUGRTN').NDB\n         LR    R2,R0              SAVE REGS OVER DEBUG\n         LR    R3,R1\n         LA    R1,5(0,R12)        R1 -> TO SECTION LABEL NAME\n         SR    R0,R0              R0=0 MEANS SECTION ENTRY\n*        PERFORM  DEBUGRTN\n         PERFORM  DEBUGRTN\n         LR    R0,R2\n         LR    R1,R3\n.*\n.NDB     ANOP\n         PRINT NOGEN\n*        AIF   ('&GEN' NE 'NO').NOGEN   GEN ALL CODE?\n*        PRINT NOGEN\n         MEND\n         SPACE    2\n         MACRO\n&LABEL   SECEXIT &GEN=NO,&DEBUG=NO,&BASE=1\n.*\n.*       SECEXIT END OF CSECT MACRO\n.*       PARM  GEN=NO             DON'T GENERATE MACRO CODE\n.*             GEN=YES            GENERATE MACRO CODE\n.*             DEBUG=NO           DON'T PRINT DEBUG INFO\n.*             DEBUG=YES          PRINT DEBUG INFO..NEEDS DEBUG MACRO\n.*             BASE=1             ONLY 1 BASE REG (12)\n.*             BASE=2             USES 12 AND 11 AS BASE REGS\n.*             BASE=13            USES 13 AND 12 AS BASE REGS\n.*\n.*\n         AIF   ('&LABEL' NE '').GENLBL LABEL SPECIFIED?\n         MNOTE 8,'CSECT EXIT NAME MUST BE SPECIFIED'\n         MEXIT\n.GENLBL  ANOP\n         PRINT GEN\n*\n*  PUT RET CODE IN R15 BEFORE CALLING SECEXIT\n*\n&LABEL   DS    0H\n         AIF   ('&GEN' NE 'NO').NOGEN2  GEN ALL CODE?\n         PRINT NOGEN\n.*\n.NOGEN2  ANOP\n         AIF ('&DEBUG' EQ 'NO').NDB\n         AIF ('&LABEL' EQ 'DEBUGRET').NDB\n         LR       R4,R15            SAVE RETURN CODE\n         LR       R2,R0             SAVE REGS OVER DEBUG\n         LR       R3,R1\n         LA    R1,5(0,R12)        R1 -> TO EXIT LABEL NAME\n         LA       R0,1              R0\u00ac=0 MEANS SECTION EXIT\n*        PERFORM  DEBUGRTN\n         PERFORM  DEBUGRTN\n         LR       R0,R2\n         LR       R1,R3\n         LR       R15,R4            RESTORE RETURN CODE\n.*\n.NDB     ANOP\n         USING SAVEAREA,R13       SET SAVEAREA BASE TOO...\n         L        R13,SAVELAST      POINT TO CALLER'S SAVEAREA\n         LM       R0,R12,SAVER0     RESTORE REGISTERS 0 TO 12\n         L        R14,SAVER14       RESTORE R14\n         NI    SAVER14+3,X'01'      MARK THAT WE'VE EXITED UP 1 LEVEL\n*              GET INTO PROPER MODE AND GO BACK TO CALLER           RH\n         BSM   0,R14                                                RH\n         LTORG\n         AIF   ('&BASE' NE '13').NOEBASE R13 AS BASE?\n         DROP  R13,R12            DROP R13 AND R12 BASE\n.NOEBASE ANOP\n         AIF   ('&BASE' EQ '1').ONEBAS2 NEED 2 BASE REGS?\n         DROP  R12,R11            DROP OUR BASE\n         AGO   .BASESE2           2 BASE REGS\n.*\n.ONEBAS2 ANOP\n         DROP  R12                DROP OUR BASE\n.*\n.BASESE2 ANOP\n         MEND\n         EJECT\n         MACRO\n&LABEL   PERFORM  &ROUTINE,&ERR=\n.**********************************************************************\n*\n&LABEL   ICM   R15,15,=V(&ROUTINE)  GET ADDRESS OF ROUTINE TO CALL\n         BNZ   *+4+4+4            B IF GOT ADDRESS\n         LA    R15,8              SET RC=8\n         B     *+6                B IF NO ADDRESS\n*              GET INTO PROPER MODE AND ...\n         BASSM R14,R15            GO EXECUTE IT\n         AIF ('&ERR' EQ '').PEXIT   ANY ERROR ROUTINE SPECIFIED?\n         LTR      R15,R15           CHECK THE RETURN CODE\n         BNZ      &ERR\n.PEXIT   ANOP\n***********************************************************************\n         MEND\n         SPACE    2\n         MACRO\n&LABEL   OLCMSG   &MSG                MACRO PARM MAPPED BY MSGDSECT\n.* OLCMSG MACRO:\n.*\n.*       USED - TO WRITE MSG TO MSGPRINT DDNAME,\n.*            - TO WRITE MSG TO THE JOB LOG\n.*            - TO WRITE MSG TO THE CONSOLE\n.*            - TO ABEND THIS PROGRAM IF NECESSARY AFTER MSG HAVE BEEN\n.*              WRITTEN.\n.*\n.*       MSG   - 81 BYTES LONG. 1ST BYTE IS A FLAG BYTE\n.*\n.*\n&LABEL   DS       0H\n         LA       R1,&MSG             POINT AT THE ERROR MSG\n         L        R15,=V(MSGRTN)      LOAD ADDRESS OF OLCMSG ROUTINE\n*              GET INTO PROPER MODE AND ...\n         BASSM R14,R15            GO EXECUTE IT\n         MEND\n*\n         MACRO\n&LABEL   REQUATE &SAVE=YES,&REGS=YES,&E=YES\n         AIF   ('&REGS'(1,1) NE 'Y').SAVETS\n***********************************************************************\n*                                                                     *\n*                 REGISTER EQUATES                                    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n*        GENERAL PURPOSE REGISTERS.\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\n*        FLOATING POINT\nFL0      EQU   0\nFL2      EQU   2\nFL4      EQU   4\nFL6      EQU   6\n         SPACE 2\n         AIF   ('&E'(1,1) EQ 'N').SAVETS\n         EJECT\n.SAVETS  AIF   ('&SAVE'(1,1) EQ 'Y').SAVEOK\n         MEXIT\n.SAVEOK  ANOP\n***********************************************************************\n*                                                                     *\n*                  SAVE AREA DESCRIPTOR SECTION                       *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nSAVEAREA DSECT ,\nSAVEWRD1 DS    F .            PL1 WORD\nSAVELAST DS    F .            CHAIN POINTER TO LAST SAVE AREA\nSAVENEXT DS    F .            CHAIN POINTER TO NEXT SAVE AREA\nSAVEREGS DS    0CL60 .        WORKING REGISTER STORAGE AREA\nSAVER14  DS    F .            R14 SLOT\nSAVER15  DS    F .            R15 SLOT\nSAVER0   DS    F .            R0 SLOT\nSAVER1   DS    F .            R1 SLOT\nSAVER2   DS    F .            R2 SLOT\nSAVER3   DS    F .            R3 SLOT\nSAVER4   DS    F .            R4 SLOT\nSAVER5   DS    F .            R5 SLOT\nSAVER6   DS    F .            R6 SLOT\nSAVER7   DS    F .            R7 SLOT\nSAVER8   DS    F .            R8 SLOT\nSAVER9   DS    F .            R9 SLOT\nSAVER10  DS    F .            R10 SLOT\nSAVER11  DS    F .            R11 SLOT\nSAVER12  DS    F .            R12  SLOT\nSAVESIZE EQU   *-SAVEAREA\n         CSECT\n        AIF   ('&E'(1,1) EQ 'N').ENDMAC\n         EJECT\n.ENDMAC  ANOP\n         MEND\n         SPACE    2\n         MACRO\n         MSGRTN &GEN=YES\n.*\n.* MSGRTN MACRO:\n.*\n.*       GENERATE CODE TO PRINT MESSAGES\n.*\n         SPACE 2\n**********************************************************************\n TITLE 'MSGRTN - MESSAGE PRINT ROUTINE'\n*\n* ERROR RTN, PUT OUT ALL SORTS OF ERROR MSGS. ABEND IF NECESSARY.\n*    WARNING - THIS CODE IS NOT REENTRANT. IN CASE OF MULTI-TCB IMPL.\n*\n         DS    0H\n         AIF   ('&GEN' EQ 'YES').GENLBL LABEL SPECIFIED\n         PRINT NOGEN\nMSGRTN   SECTION GEN=NO\n         AGO   .GENLBL2\n.GENLBL  ANOP\n         PRINT GEN\nMSGRTN   SECTION GEN=YES\n.GENLBL2 ANOP\n         LR    R2,R1              R2 -> MSG\n         LA    R3,MSGPRINT        R3 -> TO MSGPRINT DCB\n         USING IHADCB,R3\n         TM    DCBOFLGS,DCBOFOPN  IS IT OPEN ?\n         BO    MSC&SYSNDX         YES\n*        RDJFCB MSGPRINT          IS THE MSGPRINT DD CARD THERE?\n         RDJFCB MSGPRINT          IS THE MSGPRINT DD CARD THERE?\n         LTR   R15,R15\n         BZ    MS0&SYSNDX         YES\n         MVC   MSGRTN(2),=X'0B0E' NO, NO REPORT\n         B     MS7&SYSNDX         RETURN NOW\n         SPACE 1\nMS0&SYSNDX DS  0H\n*        OPEN  (MSGPRINT,(OUTPUT)),TYPE=J\n         OPEN  (MSGPRINT,(OUTPUT)),TYPE=J\n         TM    DCBOFLGS,DCBOFOPN            DID IT OPEN ?\n         BZ    MSA&SYSNDX                   NO, GO TO ERR RTN\n         DROP  R3                 DROP DCB BASE\n*        OLCMSG   OLC039\n         B     MSC&SYSNDX         ON WE GO\n         SPACE 1\nMSA&SYSNDX DS       0H\n*        OLCMSG   OLC040\n         B     MS7&SYSNDX         RETURN TO CALLER\n         SPACE 1\nMSB&SYSNDX DS       0H\n*        OLCMSG   OLC005\n         SPACE 1\nMSC&SYSNDX DS    0H\n         USING MSGDSECT,R2        R2 POINTS TO MSG\n         TM    MSGCODE,MSGWTL     REQUESTED TO WRITE TO LOG ?\n         BNO   MS1&SYSNDX         NO, JUMP OVER\n         MVC   WTLL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTLL\n         MVC   WTLL+8(L'MSGTEXT),MSGTEXT\n*        WTO   MF=(E,WTLL)        WRITE MSG TO THE JOB LOG\n         WTO   MF=(E,WTLL)        WRITE MSG TO THE JOB LOG\n         SPACE 1\nMS1&SYSNDX DS    0H\n         TM    MSGCODE,MSGPRT     REQUESTED TO WRITE TO MSGPRINT ?\n         BNO   MS2&SYSNDX         NO, JUMP OVER\n         ICM   R5,15,=V(MSGPRINT)  LOAD DCB ADDRESS\n         BZ    MS2&SYSNDX         NO DCB!\n         MVC   MSGLINE+1(L'MSGTEXT),MSGTEXT PUT DATA IN PRINT LINE\n*        PUT   (R5),MSGLINE       WRITE MSG ON MSGPRINT\n         PUT   (R5),MSGLINE       WRITE MSG ON MSGPRINT\n         MVI   MSGLINE,C' '       CLEAR PRINT LINE\n         MVC   MSGLINE+1(132),MSGLINE ''\n         SPACE 1\nMS2&SYSNDX DS    0H\n         TM    MSGCODE,MSGWTOLG   REQ TO WRITE CONSOLE EYECATCHER ?\n         BNO   MS3&SYSNDX         NO, JUMP OVER\n         MVC   WTOL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTOL\n         MVC   WTOL+8(L'WTOEYE1),WTOEYE1\n*        WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE\n         WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE\n         MVC   WTOL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTOL\n         MVC   WTOL+8(L'WTOEYE2),WTOEYE2\n*        WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE\n         WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE\n         MVC   WTOL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTOL\n         MVC   WTOL+8(L'WTOEYE3),WTOEYE3\n*        WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE\n         WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE\n         MVC   WTOL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTOL\n         MVC   WTOL+8(L'WTOEYE2),WTOEYE2\n*        WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE\n         WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE\n         SPACE 1\nMS3&SYSNDX DS    0H\n         TM    MSGCODE,MSGWTO     REQUESTED TO WRITE TO CONSOLE ?\n         BNO   MS4&SYSNDX         NO, JUMP OVER\n         MVC   WTOL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTOL\n         MVC   WTOL+8(L'MSGTEXT),MSGTEXT\n*        WTO   MF=(E,WTOL)        WRITE MSG TO CONSOLE\n         WTO   MF=(E,WTOL)        WRITE MSG TO CONSOLE\n         SPACE 1\nMS4&SYSNDX DS    0H\n         TM    MSGCODE,MSGWTOLG   REQ TO WRITE CONSOLE EYECATCHER ?\n         BNO   MS5&SYSNDX         NO, JUMP OVER\n         MVC   WTOL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTOL\n         MVC   WTOL+8(L'WTOEYE2),WTOEYE2\n*        WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE PART 2\n         WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE PART 2\n         MVC   WTOL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTOL\n         MVC   WTOL+8(L'WTOEYE1),WTOEYE1\n*        WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE PART 2\n         WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE PART 2\n         SPACE 1\nMS5&SYSNDX DS    0H\n         SPACE 1                                                    RH\nMS6&SYSNDX DS    0H\n         TM    MSGCODE,MSGABND    REQUESTED TO ABEND ?\n         BNO   MS7&SYSNDX         NO - THEN RETURN\n*        ABEND 1211,DUMP\n         ABEND 1211,DUMP\n         SPACE 1                                                    RH\nMS7&SYSNDX DS    0H\n         SR    R15,R15            RC = 0\n         SPACE 1                                                    RH\n         AIF   ('&GEN' EQ 'YES').GENLBL3 LABEL SPECIFIED\n         PRINT NOGEN\nMSGEXITE SECEXIT GEN=NO           RETURN TO CALLER\n         AGO   .GENLBL4\n.GENLBL3 ANOP\n         PRINT GEN\nMSGEXITE SECEXIT GEN=YES          RETURN TO CALLER\n.GENLBL4 ANOP\n         SPACE 1\n*                                                                   RH\n* WTLL BELOW MUST BE 88 LONG TO HANDLE 80 BYTE MSGS.\n*                                                                   RH\n*        WTO      '                                                    +\n               ROUTCDE=11\nWTLL     WTO      '                                                    +\n                                                    ',MF=L,  LEN=88    +\n               ROUTCDE=11\n*                                                                   RH\n* WTOL BELOW MUST BE 88 LONG TO HANDLE 80 BYTE MSGS.\n*        WTO      '                                                    +\n                                                    ',MF=L,  LEN=88    +\n               ROUTCDE=11         ROUTCDE=1 WHEN TO CONSOLE\nWTOL     WTO      '                                                    +\n                                                    ',MF=L,  LEN=88    +\n               ROUTCDE=11         ROUTCDE=1 WHEN TO CONSOLE\n*                                                                   RH\nWTOEYE1  DC       CL45'**********************************************'\nWTOEYE2  DC       CL45'***                                        ***'\nWTOEYE3  DC       CL45'***        ATTENTION - ATTENTION           ***'\n*\nMSGBLK   DC       CL80' '    TO BLANK OUT THE WTOL AND WTLL AREAS\n*                 CL80  ABOVE MUST BE LENGTH 80 IF WTOL AND WTLL LISTS\n*                       ARE 88 LONG. ALL MSG HAVE 1ST 4 CHARS AS BLANK\n*                       SO AS NOT TO CLOBBER STUPID WTL MACRO.\n*-----------------------------------------------------------------\n         SPACE 3\nMSGLINE  DC    CL133' '           PRINT LINE\n         SPACE 1\n         ENTRY MSGPRINT\n*MSGPRINT DCB  MACRF=(PM),DSORG=PS,RECFM=FBA,LRECL=133,BLKSIZE=13300,  +\n               DDNAME=SYSPRINT,EXLST=REPORTE\nMSGPRINT DCB   MACRF=(PM),DSORG=PS,RECFM=FBA,LRECL=133,BLKSIZE=13300,  +\n               DDNAME=SYSPRINT,EXLST=REPORTE\nREPORTE  DC    0F'0',X'87',AL3(*+3),XL176'00'\n         SPACE 2\n*\n*\nMSGDSECT DSECT\nMSGCODE  DS       X\nMSGPRT   EQU      X'01' PRINT THE MSG ON DDNAME=MSGPRINT\nMSGWTL   EQU      X'02' WRITE THE MSG TO THE JOB LOG\nMSGWTO   EQU      X'04' WRITE THE MSG TO THE OPERATOR CONSOLE/SYSLOG\nMSGWTOLG EQU      X'08' WRITE A LARGE EYE CATCHER ON THE CONSOLE/SYSLOG\nMSGSGNL  EQU      X'10' START THE \"SIGNAL\" MESSAGE REGION\nMSGABND  EQU      X'80' ABEND AFTER PUTTING OUT MSGS AND SIGNAL MPR\nMSGTEXT  DS       CL80  THE TEXT OF THE ERROR MSG\nMSGTEXT2 DS       CL53  THE TEXT OF THE ERROR MSG FOR LRECL UP TO 133\n         CSECT\n         MEND\n         SPACE    2\n         MACRO\n         DEBUG &GEN=YES\n.*\n.* DEBUG MACRO:\n.*\n.*       GENERATE CODE TO PRINT DEBUG MESSAGES\n.*\n         PRINT GEN\n         SPACE    2\n TITLE 'DEBUGRTN - PRODUCE A TRACE IN FILE ''DEBUG'' '\n*\n* PRODUCE A TRACE OF SECTION ENTRIES AND EXITS\n*\n*   NOTE - SINCE DEBUG DCB OPEN BY OPENSYSP, WE GET NO TRACE UNTIL\n*          AFTER THAT SECTION HAS RUN\n*\n         AIF   ('&GEN' EQ 'YES').GENLBL  LABEL SPECIFIED\nDEBUGRTN SECTION GEN=NO\n         PRINT NOGEN\n         AGO   .GENLBL2\n.GENLBL  ANOP\nDEBUGRTN SECTION GEN=YES\n         PRINT GEN\n.GENLBL2 ANOP\n         DS    0H\n*\n*              ON ENTRY, RC IS IN  R4\n*                        R0 IS 0  FOR SECTION\n*                              1  FOR SECEXIT\n*                        R1 IS A(SECTION NAME)\n*\n         ST    R4,SAVERCDB        SAVE RETURN CODE\n         LR    R5,R1              R5 -> TO CSECT NAME               RH\n         LR    R6,R0              R6 = 0 OR 1                       RH\n         LA    R2,DEBUG         IS DEBUG IN EFFECT\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN  IS IT OPEN ?\n         BO    DEBUGOPN           YES\n*        RDJFCB DEBUG             IS THE DEBUG DD CARD THERE?\n         RDJFCB DEBUG             IS THE DEBUG DD CARD THERE?\n         LTR   R15,R15\n         BZ    RETOPNP            YES\n         MVC   DEBUGRTN(2),=X'0B0E' NO, NO DEBUGGING\n         B     DEBUGRET           RETURN NOW\n         SPACE 1\nRETOPNP  DS    0H\n*        OPEN  (DEBUG,(OUTPUT)),TYPE=J\n         OPEN  (DEBUG,(OUTPUT)),TYPE=J\n*        LA    R1,DEBUG\n*        USING IHADCB,R1\n         TM    DCBOFLGS,DCBOFOPN            DID IT OPEN ?\n         BZ    ERROPEND                     NO, GO TO ERR RTN\n*        DROP  R1\n*        OLCMSG   OLC039\n         OLCMSG   OLC039\n         B     DEBUGOPN           ON WE GO\n         SPACE 1\nERROPEND DS       0H\n*        OLCMSG   OLC040\n         OLCMSG   OLC040\n         B     DEBUGRET           RETURN TO CALLER\n         SPACE 1\nERROPENP DS       0H\n*        OLCMSG   OLC005\n         OLCMSG   OLC005\n         SPACE 1\nDEBUGOPN DS    0H\n         SPACE 1\n         LTR   R6,R6            WAS IT A SECTION OR SECEXIT.\n         BNZ   DEBUGEX            SECEXIT\n         LA    R3,OLCBLNK         R3 -> TO BLANKS\n         MVC   DEBUGN1(69),1(R3)  CLEAR MODULE NAME AREA\n         L     R3,OFFSET        OFFSET MODULE NAME TO SHOW NESTING\n         LA    R3,4(R3)         ADD INCREMENT\n         ST    R3,OFFSET\n         CH    R3,=H'69'        MAX LINE LENGTH\n         BNH   *+8\n         LA    R3,61\n         LA    R3,DEBUGN1(R3)\n         MVC   0(8,R3),0(R5)    MOVE SECTION NAME TO TEXT           RH\n*        PUT   (R2),DEBUGN\n         PUT   (R2),DEBUGN\n         B     DEBUGRET\n         SPACE 1\nDEBUGEX  EQU   *\n         LA    R3,OLCBLNK         R3 -> TO BLANKS\n         MVC   DEBUGM1(69),1(R3)  CLEAR MODULE NAME AREA\n         L     R3,OFFSET        OFFSET MODULE NAME TO SHOW NESTING\n         LR    R4,R3\n         SH    R4,=H'4'         AND DECRMENT\n         BP    *+6\n         SR    R4,R4            DO NOT LET IT GO NEG.\n         ST    R4,OFFSET\n         CH    R3,=H'69'        MAX LINE LENGTH\n         BNH   *+8\n         LA    R3,61\n         LA    R3,DEBUGM1(R3)\n         MVC   0(8,R3),0(R5)    MOVE SECTION NAME TO TEXT           RH\n         L     R1,SAVERCDB        R1 = PREV SECTIONS RETURN CODE\n         LTR   R1,R1              WAS THERE A RETURN CODE?\n         BZ    NORC               NO\n         CVD   R1,DWORD2          CONVERT TO DECIMAL\n         UNPK  DWORD2(5),DWORD2+5(3) CONVERT TO DISPLAY\n         MVZ   DWORD2+4(1),DWORD2 FIX SIGN BITS\n         MVC   8(5,R3),=C', RC='  SET UP RC PART OF MSG             RH\n         MVC   13(3,R3),DWORD2+2  PUT RC IN MSG                     RH\n         SPACE 1\nNORC     DS    0H\n*        PUT   (R2),DEBUGM\n         PUT   (R2),DEBUGM\n         SPACE 1\n         AIF   ('&GEN' EQ 'YES').GENLBL3 LABEL SPECIFIED\n         PRINT NOGEN\nDEBUGRET SECEXIT GEN=NO           RETURN TO CALLER\n         AGO   .GENLBL4\n.GENLBL3 ANOP\n         PRINT GEN\nDEBUGRET SECEXIT GEN=YES          RETURN TO CALLER\n.GENLBL4 ANOP\n         DROP   R2\nDWORD2   DC    D'0'\nOFFSET   DC    F'0'\nSAVERCDB DC    F'0'\nDEBUGN   DC    CL11' ENTRY TO:'\nDEBUGN1  DC    CL69' '\nDEBUGM   DC    CL11'EXIT FROM:'\nDEBUGM1  DC    CL69' '\n         SPACE 1\nOLCBLNK  DC    AL1(MSGPRT)\n         DC    CL81' '\n         SPACE 1\nOLC039   DS    0CL81\n*        DC    AL1(MSGWTL+MSGPRT)\n         DC    AL1(MSGPRT)\n         DC    C'DBG039 - DEBUG OPTION IN EFFECT - '\n         DC    C'A TRACE WILL BE PRODUCED IN FILE ''DEBUG'' '\n         DC    CL(81-(*-OLC039))' '\n         SPACE 1\nOLC040   DS    0CL81\n*        DC    AL1(MSGWTL+MSGPRT)\n         DC    AL1(MSGPRT)\n         DC    C'DBG040 - DEBUG OPTION CANCELLED - '\n         DC    C'OPEN ERROR ON FILE ''DEBUG'' '\n         DC    CL(81-(*-OLC040))' '\n         SPACE 1\nOLC005   DS    0A\n*        DC    AL1(MSGWTL+MSGWTOLG+MSGWTO+MSGSGNL+MSGABND)\n         DC    AL1(MSGPRT+MSGSGNL+MSGABND)\n         DC    C'DBG005 - ABEND, CANNOT OPEN DEBUG DD'\n         DC    CL(81-(*-OLC005))'  '\n         SPACE 1\n         ENTRY DEBUG\n*DEBUG   DCB   MACRF=(PM),DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=6160,     +\n               DDNAME=DEBUG,EXLST=DEBUGE\nDEBUG    DCB   MACRF=(PM),DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=6160,     +\n               DDNAME=DEBUG,EXLST=DEBUGE\nDEBUGE   DC    0F'0',X'87',AL3(*+3),XL176'00'\n         SPACE 2\n         MEND\n*\n*              YOUR CODE STARTS HERE\n*              MAKE SURE YOU HAVE AN ENTRY STATEMENT IN THE LINKAGE\n*              EDITOR CONTROL STATEMENTS OR SPECIFY THE STARTING\n*              CSECT NAME ON THE  END STATEMENT\n*\n         ENTRY YOURCODE\n         CNOP  0,4\nYOURCODE DS    0H\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MEMLIST": {"ttr": 18948, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x14Q\\x01\\xac\\x01\\xac\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T14:51:00", "lines": 428, "newlines": 428, "modlines": 0, "user": "RH87944"}, "text": "//MEMLIST JOB\n//*\n//*    DSN=CBT.SOURCE(MEMLIST)\n//*\n/*ROUTE PRINT R7\n//S EXEC HLASMCL,PARMC='NOALIGN,NORLD',CLASS='*',COND.LKED=(7,LT,ASM),\n//  PARML=REUS\n//ASM.SYSLIB DD DSN=SYS1.MACLIB\n//   DD DSN=SYS1.AMODGEN,DISP=SHR\n//ASM.SYSIN DD *\n         TITLE 'PGMLIB MEMBER SCAN' T COX\n*\n***********************************************************************\n*                                                                     *\n*             MODULE NAME = MEMLIST                                   *\n*                                                                     *\n*             DESCRIPTIVE NAME =  PROGRAM TO CREATE LIST OF MEMBER    *\n*                NAMES IN A PDS.                                      *\n*                                                                     *\n*             STATUS = RELEASE 01.0                                   *\n*                                                                     *\n*   FUNCTION =                                                        *\n*        THIS PROGRAM READS THE DIRECTORY OF A PDS AND BUILDS AN      *\n*        INTERNAL TABLE OF MEMBER NAMES                               *\n*                                                                     *\n*        MEMBERS ARE READ TO DETERMINE THE DATE THAT IT WAS           *\n*        LINK EDITED.  IT WILL WRITE OUT A RECORD FOR EACH            *\n*        MEMBER WITH A LINK EDIT DATE.                                *\n*\n*        ENTRY POINTS:\n*           MEMLIST\n*\n*        PARAMETERS:\n*                   MBR= TO SPECIFY A SINGLE MEMBER TO ACCESS.\n*\n*                                                                     *\n*                OPERATION =                                          *\n*                   READ PDS DIRECTORY AND CREATE MEMBER TABLE.       *\n*                   READ EACH MEMBER LOOKING FOR TYPE 8011 RECORD.    *\n*                   LIST MEMBER NAME AND LINK DATE.                   *\n*                   AT END OF LIST CLOSE DATASETS AND FREE ANY        *\n*                      AQUIRED AREAS.                                 *\n*                                                                     *\n*              NOTES =                                                *\n*                                                                     *\n*                 DEPENDENCIES = CHARACTER SET IS EBCDIC.  REASSEMBLE *\n*                    IF A DIFFERENT CHARACTER SET IS NEEDED.          *\n*                                                                     *\n*                 RESTRICTIONS = DATASETS MUST HAVE LRECL LESS THAN   *\n*                    255 AND MUST BE EITHER FIXED OR VARIABLE FORMAT. *\n*                                                                     *\n*                 REGISTER CONVENTIONS = STANDARD CONVENTIONS.        *\n*                    REGISTERS 0 TO 10 = WORK REGISTERS               *\n*                    REGISTER  11      = SECOND BASE REGISTER         *\n*                    REGISTER  12      = ADDRESSABILITY TO MEMLIST    *\n*                                        CSECT                        *\n*                    REGISTER  13      = SAVE AREA REGISTER AND       *\n*                                        ADDRESSABILITY TO GETMAINED  *\n*                                        WORK AREA                    *\n*                    REGISTERS 14,15   = WORK REGISTERS               *\n*                                                                     *\n*                                                                     *\n*             MODULE TYPE = PROCEDURE                                 *\n*                                                                     *\n*                PROCESSOR = ASM                                      *\n*                                                                     *\n*                MODULE SIZE = 5K BYTES                               *\n*                                                                     *\n*                ATTRIBUTES = SCHEDULER KEY 8, NON-REENTRANT,         *\n*                   PROBLEM PROGRAM STATE                             *\n*                                                                     *\n*                LINKAGE =                                            *\n*                   FROM SYSTEM                                       *\n*                                                                     *\n*             OUTPUT = LIST OF MEMBERS AND LINK DATES                 *\n*                                                                     *\n*             EXIT - NORMAL = AT PROGRAM END VIA BRANCH REGISTER 14   *\n*                                                                     *\n*                RETURN CODE = ZERO                                   *\n*                                                                     *\n*             EXIT - ERROR = NONE - PROGRAM WILL DISPLAY DECIMAL      *\n*                RETURN CODE AND RETURN VIA BRANCH REGISTER 14        *\n*                                                                     *\n*                OUTPUT = NONE                                        *\n*                                                                     *\n*                RETURN CODE = ZERO                                   *\n*                                                                     *\n*             EXTERNAL REFERENCES =                                   *\n*                                                                     *\n*                ROUTINES = NONE?                                     *\n*                                                                     *\n*                DATA AREAS = NONE                                    *\n*                                                                     *\n*                CONTROL BLOCKS = DCB, RDJFCB, ETC.                   *\n*                                                                     *\n*             TABLES = DATA AREA TO BE GETMAINED.  MAPPED BY DSECT    *\n*                BEGINNING AT LABEL RDATD.                            *\n*                                                                     *\n*             MACROS = SAVE, GETMAIN, FREEMAIN,                       *\n*                   OPEN, PUT, GET, CLOSE, RDJFCB,                    *\n*                   DCB, DCBD                                         *\n*                                                                     *\n*             CHANGE ACTIVITY = NONE                                  *\n*                                                                     *\n*             ABEND CODES = 799                                       *\n*                           999                                       *\n*                                                                     *\n***********************************************************************\n*\n*        REGISTER EQUATES\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\n*        ENTRY POINT\n*\nMEMLIST CSECT\n*\n         USING *,15      GET TEMP ADDRESSABILITY\n         B     CONTINUE   BRANCH AROUND ID\n         DC    AL1(IDLTH)\nEYECATCH DC    CL8'MEMLIST'   IDENTIFIER\n         DC    CL9'VERSION 1' IDENTIFIER\n         DC    CL8'&SYSDATE'  IDENTIFIER\n         DC    CL8'&SYSTIME'  IDENTIFIER\nIDLTH    EQU   *-EYECATCH\n         SPACE 1\nCONTINUE DS    0H\n         STM   14,12,12(13)  SAVE REGISTERS\n         DROP  15\n         LR    12,15        SET BASE REG.\n         USING MEMLIST,12\n         LA    14,SAVEAREA\n         ST    13,4(14)      SAVE REGS 13 AND\n         ST    14,8(13)      BACK CHAIN\n         LR    13,14         GET SAVE AREA ADDRESS\n         ST    R1,SAVER1     SAVE REG 1\n         MVC   MBRNAME,=CL8' '    CLEAR MBR NAME FIELD\n         L     R2,0(0,R1)         R2 -> TO SYSTEM PARM\n*        OPEN  (REPORT,(OUTPUT))  OPEN SYSPRINT FILE\n         SPACE 1\n***********************************************************************\n*\n*              SEE IF THERE IS A  PARM\n*\n*        VALID PARMS ARE:\n*              MBR= ......MEMBER NAME TO GET LINK DATE FOR\n*\n*        ANY OTHER PARMS ARE INVALID\n*        IF NO PARMS ARE SPECIFIED, THE DEFAULTS WILL BE\n*              PARM='MBR=ALL'\n*\n***********************************************************************\n         SPACE 1\n*              GET PARM, IF ANY\n         SPACE 1\nPARM0    DS    0H\n         LA    R10,2(0,R2)        R10 -> TO PARM\n         LH    R2,0(0,R2)         R2 = PARM LTH\n         LTR   R2,R2              IS THERE A PARM ?\n         BZ    ENDPARM            NO\n         LR    R4,R10             YES, R4 -> TO PARM\n         SPACE 1\nPARM1    DS    0H\n         CLC   =C'MBR=',0(R4)     IS IT THE 'MBR=' PARM?\n         BNE   PARM2              NO, CHECK FOR NEXT PARM\n         SPACE 1\n         LA    R4,4(0,R4)         R4 -> PAST MBR=\n         SH    R2,=H'4'           R2 = LTH OF REST OF PARM\n         LR    R5,R4              R5 -> TO MBR NAME\n         SPACE 1\nPARM1B   DS    0H\n         CLI   0(R4),C','         AT END OF MBR ?\n         BE    PARM1C             YES, GO GET NEXT PARM\n         LA    R4,1(0,R4)         R4 -> TO NEXT KEY BYTE, IF ANY\n         BCT   R2,PARM1B          CHECK ALL CHARS LEFT\n         SPACE 1\nPARM1C   DS    0H\n         LR    R6,R4              R6 -> TO END OF MBR NAME\n         SR    R6,R5              R6 = LTH OF MBR NAME\n         BCTR  R6,0               R6 = HEX LTH\n         MVC   MBRNAME,=CL8' '    CLEAR MBR NAME FIELD\n         EX    R6,MVCMBR          SET UP MBR NAME\n         LA    R9,1               SET R9 TO SAY WE HAVE 1 MBR NAME\n         B     NEXTPARM           GO CHECK FOR ANOTHER PARM\n         SPACE 1\nMVCMBR   MVC   MBRNAME(0),0(R5)   MOVE MBR NAME\n         SPACE 1\nPARM2    DS    0H\n         SPACE 1\n         SPACE 1\nPARM99   DS    0H\n         B     BADPARM            PRINT BAD PARM MSG\n         SPACE 1\nNEXTPARM DS    0H\n         LTR   R2,R2              ANY PARM LEFT?\n         BNP   ENDPARM            NO\n         LA    R4,1(0,R4)         YES, R4 -> TO NEXT BYTE\n         BCTR  R2,0               TAKE 1 OFF PARM LTH\n         CLI   0(R4),C','         COMMA?\n         BNE   PARM1              NO, GO SEE WHAT IT IS\n         B     NEXTPARM           LOOK AT ALL CHARS IN PARM\n         SPACE 1\nENDPARM  DS    0H\n*\n*        OPEN OUTPUT DATASET\n*\n         OPEN  (OUTREC,(OUTPUT)) OPEN SCRATCH CARD DATASET\n         OPEN  (PRINT,(OUTPUT))  OPEN PRINT FILE\n*        CLI   MBRNAME,C' '       IS MBR NAME FIELD BLANK?\n*        BNE   LOADMBR1           NO, GO PROCESS MEMBER\n*\n*        OPEN LIBRARY DIRECTORY TO GET ALL MEMBERS OF THE PDS\n*\n         OPEN  (INPDS,(INPUT))\n*\n*        ISSUE GETMAIN FOR MEMBER AREA\n*\n         SR    R5,R5           ZERO REG 5\n         L     R5,=F'9000'     WANT ROOM FOR MAXIMUM MEMBERS\n         SLL   R5,3        TIMES 8 PER MEMBER NAME\n         GETMAIN R,LV=(R5),SP=10\n         ST    R1,MBRAREA  SAVE AREA ADDRESS\n         LR    R7,R1       AND LOAD INTO R7\n         SRL   R5,3        RESET TO NUMBER OF MEMBERS ALLOWED\n         SR    R9,R9       ZERO MEMBER COUNTER\n*\n*        GET DIRECTORY BLOCK\n*\nDIRREAD  EQU   *\n         LA    R6,DIRREC\n         READ  UT1DECB,SF,INPDS,(R6),,S\n         CHECK UT1DECB\n         CLC   0(2,R6),=H'0'  IF LENGTH IS ZERO END DIRECTORY SEARCH\n         BE    LOADMBR\n*\n         LR    R1,R6          SAVE BEGINNING OF BLOCK\n         AH    R1,0(R6)       POINT TO END OF BLOCK\n         LA    R6,2(0,R6)    POINT PAST LENGTH FIELD\n*\nTHISMBR  EQU   *\n         CR    R6,R1         IF AT END OF BLOCK\n         BNL   DIRREAD       GET ANOTHER ONE\n         CLI   0(R6),X'FF'   IF MEMBER HAS HIGH VALUES END DIR. SEARCH\n         BE    LOADMBR\n         CLI   0(R6),X'00'   IF MEMBER HAS LOW VALUES BYPASS SAVE\n         BE    NEXTMBR\n         MVC   0(8,R7),0(R6) SAVE MEMBER NAME IN MEMBER AREA\n         LA    R7,8(0,R7)      POINT TO NEXT ENTRY IN MEMBER AREA\n         LA    R9,1(0,R9)      INCREMENT MEMBER COUNT\n         CR    R9,R5         IS MEMBERS UP TO MAXIMUM?\n         BNL   LOADMBR       IF YES, END DIRECTORY SEARCH\n*\nNEXTMBR  EQU   *\n         NI    11(R6),31      LOOK AT ONLY THE \"C\" FIELD IN ENTRY\n         SR    R8,R8\n         IC    R8,11(R6)       MOVE \"C\" FIELD TO R8\n         SLL   R8,1           MULTIPLY BY 2\n         LA    R6,12(R8,R6)     POINT TO NEXT ENTRY IN DIRECTORY BLOCK\n         B     THISMBR        BRANCH TO PROCESS NEXT ENTRY\n*\n*        THIS ROUTINE LOADS EACH MEMBER OF THE PDS\n*\nLOADMBR  EQU   *\n         CLOSE INPDS            CLOSE DIRECTORY DCB\n*\n         LTR   R9,R9          IF NO MEMBERS THEN\n         BZ    NOMBRS         LEAVE ROUTINE WITH MESSAGE\n*\nEOFREAD  DS    0H\nNOSYSIN  DS    0H\n         L     R6,MBRAREA    SET ADDRESS OF MEMBER AREA\n         SR    R7,R7             ZERO REGISTER 7\n         SPACE 1\n*\n*\nFINDMBR  DS    0H\nFINDMBR2 DS    0H\n         MVC   MBRNAME,0(R6)     SAVE MEMBER NAME\n*        B     GOTREC            IF GOT THE RIGHT RECORD\n*        B     READBLK\n*\n*        IF HAVE THE X'8011' RECORD THEN CHECK THE DATE\n*\nGOTREC   EQU   *\n*\n         PUT   OUTREC,SCRCARD\n         LA    R7,1(R7)         INCREMENT COUNTER\n*        B     GETNEXT          GET NEXT MEMBER\n*\n*        SET UP TO READ NEXT MEMBER\n*\nGETNEXT  EQU   *\n         LA    R6,8(0,R6)\n         BCT   R9,FINDMBR     IF MORE MEMBERS\n         B     CLOSPDS\n*\n*        ERROR ROUTINES\n*\nBADPARM  EQU   *\n         MVC   MBRNAME,=C'BADPARM*'\n         MVC   PSDATE,SCRDATE\n         PUT   OUTREC,SCRCARD\n         LA    R15,16\n         B     BADEND           LEAVE\n*\nNOMBRS   EQU   *\n         MVC   MBRNAME,=C'NOMBRS**'\n         MVC   PSDATE,SCRDATE\n         PUT   OUTREC,SCRCARD\n         LA    R15,16\n         B     BADEND           LEAVE\n*\n*        CLOSE PDS\n*\nCLOSPDS  EQU   *\n         CLOSE (OUTREC)\n*\n*        FREE STORAGE AREA\n*\n         FREEMAIN R,SP=10\n*\n*        AND RETURN\n*\nRETURN   EQU   *\n         CVD   R7,WORKD\n         MVC   OUTCNT,PATTERN\n         ED    OUTCNT,WORKD+4\n         PUT   PRINT,OUTPRT\n         LA    R15,0\n*\nBADEND   EQU   *\n         CLOSE PRINT\n         L     R13,4(R13)\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14                RETURN TO CALLING PROGRAM\n*\n*        ABEND\n*\nBADBAD   EQU   *\n         ABEND 799,DUMP,STEP\n*\n*        DEFINE VARIABLES\n*\n*\n***************************WORK AREAS *********************************\n*\n         SPACE 2\nMBRTYPE  DC    C' '\nSTARTMBR DC    CL8' '\nENDMBR   DC    CL8' '\nSYSDATA  DS    CL80\nSMBRLTH  DC    H'0'\nEMBRLTH  DC    H'0'\nSAVEALL  DC    18F'0'\n         CNOP  0,8\n*\nWORKD    DS   D\nWORKF    DS   F\nSAVEAREA DS   18F\n*\nSAVER1   DS    F\nBLKAREA  DS    F\nMBRCNT   DS    F\nMBRAREA  DC    A(MBRNAME)\nDIRREC   DC    XL256'00'\n*\nSCRCARD  DS    0CL80\nMBRNAME  DS    CL8\n         DC    CL2'  '\nPSDATE   DC    CL5' '\n         DC    CL65' '\n*\n***************************** CONSTANTS *******************************\n*\n         SPACE 2\nOUTPRT   DS    0CL133\nCCO      DC    CL1'0'\n         DC    CL29'NUMBER OF MEMBERS SELECTED : '\nOUTCNT   DS    CL8\n         DC    CL95' '\n*\nBADFIND  DS    0CL133\nCCB      DC    CL1'0'\n         DC    CL29'ERROR DOING FIND FOR MEMBER: '\nBADMBR   DS    CL8\n         DC    CL95' '\n*\nSCRATCHD DS    PL3\nTODAY    DS    PL3\nSCRDATE  DC    CL5'*****'\nPATTERN  DC    XL8'4020202020202020'\n*\n         LTORG\n*\nINPDS    DCB   DDNAME=INLIB,DSORG=PS,RECFM=F,BLKSIZE=256,MACRF=(R),    X\n               EODAD=LOADMBR\nINPDSA   DCB   DDNAME=INLIB,DSORG=PO,EODAD=GETNEXT,MACRF=(R),          X\n               RECFM=U,LRECL=256,BLKSIZE=19069\nOUTREC   DCB   DDNAME=OUTREC,DSORG=PS,RECFM=FB,BLKSIZE=3120,           X\n               MACRF=(PM),LRECL=80\nPRINT    DCB   DDNAME=SYSPRINT,DSORG=PS,RECFM=FBA,BLKSIZE=1330,        X\n               MACRF=(PM),LRECL=133\n*\n*\nBLANKS   DC    256CL1' '\n         END   MEMLIST\n//LKED.SYSLMOD DD DSN=SYS9.IMSUTIL.LOAD,DISP=SHR\n//SYSIN   DD *\n ENTRY   MEMLIST\n SETCODE AC(0)\n NAME    MEMLIST(R)\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MEMLISTJ": {"ttr": 18956, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03?\\x00\\x99\\x03?\\x13@\\x00\\x13\\x00\\x13\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-02T00:00:00", "modifydate": "1999-02-02T13:40:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "RH87944"}, "text": "//MEMLIST JOB\n/*ROUTE  PRINT R7\n//*\n//*    DSN=CBT.SOURCE(MEMLISTJ)\n//*\n//*\n//STEP1    EXEC PGM=MEMLIST,REGION=4000K\n//STEPLIB  DD DSN=SYS9.IMSUTIL.LOAD,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//SYSABEND DD SYSOUT=*\n//INLIB    DD DISP=SHR,DSN=IMSVS.TEST.PGMLIBB\n//OUTREC   DD DSN=HALL.LIST.MEMBERS,\n//            DISP=SHR\n//*           DISP=(,CATLG),\n//*           UNIT=SYSDA,SPACE=(CYL,(1,1)),\n//*           DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)\n//*UTREC   DD SYSOUT=*,\n//*           DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MOD": {"ttr": 18958, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x14\\x06\\x00 \\x00 \\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T14:06:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "RH87944"}, "text": "         MACRO\n*\n*        THIS  MACRO SIMULATES THE PLI MOD FUNCTION\n*\n&NAME    MOD   &X,&Y,&ANS\n         AIF   ('&X(1,1)' NE '(').NOPAREN\n         LR    R14,&X             PUT NUMBER IN R14\n         AGO   .X1\n.NOPAREN ANOP\n         L     R14,&X             PUT NUMBER IN R14\n.X1      ANOP\n         SRDA  R14,32             SHIFT IT TO R15\n.*\n         AIF   ('&Y(1,1)' NE '(').NOPARN2\n         LR    R1,&Y              PUT DIVISOR IN R14\n         AGO   .Y1\n.NOPARN2 ANOP\n         L     R1,&Y              PUT DIVISOR IN R14\n.Y1      ANOP\n         DR    R14,R1             DIVIDE\n         LTR   R14,R14            IS REMAINDER POSITIVE?\n         BNM   *+4+4              YES\n         LPR   R1,R1              TWEEK DIVISOR\n         AR    R14,R1             ADD IT TO REMAINDER\n.*\n         AIF   ('&ANS(1,1)' NE '(').NOPARN3\n         LR    &ANS,R14           PUT ANSWER IN HIS REG\n         AGO   .ANS1\n.NOPARN3 ANOP\n         ST    R14,&ANS           PUT ANSWER IN HIS ANSWER FIELD\n.ANS1    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OLDDOC": {"ttr": 19202, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x01\\x1f\\x00\\x99\\x01\\x1f\\x12C\\x01\\xa3\\x01\\xa3\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-01-11T00:00:00", "modifydate": "1999-01-11T12:43:00", "lines": 419, "newlines": 419, "modlines": 0, "user": "RH87944"}, "text": "DISASM is a one-pass disassembler which produces an assembler language\nsource program from a CSECT within a load module. Control cards permit\nspecification of areas containing no instructions, allow base registers\nto be provided so that symbolic labels may be created during\ndisassembly, and definition of DSECTs to be used during disassembly.\nConditional branch instructions use the extended mnemonics, where\npossible, and explicit registers are denoted by R0, R1, ... R15.\nInformational comments are given on SVC's, and various BAL instructions\nto aid in creating a documented source program.\n\n1. JCL requirements:\n      a. EXEC card:        To execute PGM=DISASM. A parm field may\n                           be specified if floating point and/or\n                           privileged instructions are to be\n                           found in the module.\n      b. STEPLIB DD card:  Optional, specify the PDS containing\n                           the module DISASM.\n      c. LOADLIB DD card:  optional, specify PDS containing the\n                           modules DISASM1 and DISASM2, if other than\n                           a linklist library or STEPLIB.\n      d. SYSLIB DD card:   specify PDS containing the module to be\n                           disassembled.\n      e. SYSPRINT DD card: optional, specify the printed\n                           output dataset. BLKSIZE must be\n                           specified as a multiple of 121.\n                           RECFM=FBA,LRECL=121 is hard coded.\n      f. SYSPUNCH DD card: optional, specify printed output\n                           dataset. BLKSIZE must be specified\n                           as a multiple of 80.\n                           RECFM=FB,LRECL=80 is hard coded.\n      g. SYSIN DD card:    contains control cards. The MODULE-CSECT\n                           card is required. BLKSIZE must be a\n                           multiple of 80. RECFM=FB,LRECL=80 is\n                           hard-coded.\n\n  JCL example: Disassemble CSECT IECIOSCN in module IEANUC01,\n               which is in the PDS SYS1.NUCLEUS. The modules\n               DISASM, DISASM1, and DISASM2 are all in the PDS\n               SYS1.TECHLOAD. A printed listing is to be made,\n               and the source program output will be placed in\n               the sequential dataset USER02.IECIOSCN.ASM.\n\n      //DISASM EXEC PGM=DISASM\n      //STEPLIB DD DSN=SYS1.TECHLOAD,DISP=SHR\n      //SYSPRINT DD SYSOUT=*,DCB=BLKSIZE=121\n      //SYSLIB DD DSN=SYS1.NUCLEUS,DISP=SHR\n      //SYSPUNCH DD DSN=USER02.IECIOSCN.ASM,DISP=(,CATLG),\n      //            UNIT=SYSDA,DCB=23440,\n      //            SPACE=(TRK,(5,2),RLSE)\n      //SYSIN DD *\n      IEANUC01 IECIOSCN\n      /*\n\n\n2. PARM field on the EXEC card: Omit the parm field, unless floating\n        point and/or privileged instructions are to be found in the\n        CSECT being disassembled. When the parm field is not specified,\n        entries for the privileged and floating point instructions are\n        erased from the internal instruction tables used during\n        disassembly. Valid PARM fields are:\n\n            PARM=(SUPVR)     assemble privileged instructions\n            PARM=(FLTPT)     assemble floating point instructions\n            PARM=(SUPVR,FLTPT) assemble both privileged and\n                             floating point instructions.\n\n\n3. Control cards entered in the SYSIN dataset.\n        Data is contained only in columns 1-72. Columns 73-80 may be\n        used for any desired purpose. Comment cards may be entered with\n        an asterisk (*) in column 1. In addition, columns beyond the\n        last specified may be used for any purpose. Leading zeros must\n        be included in all fields giving hex or decimal data. Name\n        fields must be left justified with trailing blanks. Hex fields\n        may contain only the hex digits 0-9 and A-F, while decimal\n        fields may contain only digits 0-9.  The MODUKE-CSECT card must\n        be the first card in the input stream. DSECT definitions may not\n        include any other control cards. Using cards for DSECTs must be\n        entered at some point after the DSECT definition. Data-only\n        cards and program USING cards may be entered in any order except\n        within DSECT definitions.\n\n\n   a. MODULE-CSECT card (required), must be the first card in the SYSIN\n        stream. Specifies the module name and CSECT name. Module name\n        is required, and must name an entry in the directory of the PDS\n        specified by the SYSLIB DD card. CSECT name is optional. If\n        specified, the named CSECT must exist in the module. If omitted,\n        the CSECT with ESDid=0001 is disassembled.\n      format: free-form, with module name preceding CSECT name.\n              At least one blank must separate module name and\n              CSECT name. The names may be surrounded by any number\n              of blanks (see the JCL example).\n\n\n   b. Data-only card (optional). Used to describe areas of the CSECT\n                being disassembled which contain no instructions. Use of\n                this card eliminates creation of instructions from\n                constant data. Up to 256 data-only cards may be entered.\n                These cards may occur anywhere in the SYSIN stream after\n                the MODULE-CSECT card, but not within a DSECT definition\n                set.\n      format:\n              col  1-4  : literal 'data'\n              col   5   : blank\n              col  6-11 : offset to beginning of area in hex\n              col   12  : blank\n              col 13-18 : offset to end of area in hex\n\n\n\n   c. DSECT definitions (optional). A DSECT is defined by a header card\n              followed by a variable number of field definition cards\n              (up to 9999 of them). No other control card may be entered\n              within a DSECT definition. Up to 256 DSECT definitions may\n              be entered.\n\n      DSECT header card format:\n           col 1-8    : DSECT name\n           col 9      : blank\n           col 10-14  : literal 'DSECT'\n           col 15     : blank\n           col 16-19  : number of field cards to follow (decimal)\n\n      DSECT field card format:\n           col 1-8    : field name\n           col 9      : blank\n           col 10-13  : offset to left end of field (decimal)\n                        maximum offset is 4095\n           col 14     : blank\n           col 15-17  : length of field in bytes (decimal)\n                        maximum length is 256\n\n\n\n   d. Ulabl cards. These cards define user labels to be placed on\n                 statements within the program. If program base\n                 registers are set up with using cards, these will also\n                 be generated as symbolic operands on instructions.\n                 Format is:\n\n           col  1-5   : literal 'ulabl'\n           col   6    : blank\n           col  7-14  : label name\n           col  15    : blank\n           col 16-21  : offset to left end of field, in hex.\n           col  22    : blank\n           col 23-25  : length of field in dec. 256 is max.\n\n\n\n   e. Using cards. These cards define base register usage. Up to 256\n                 using cards may be entered. Use of these cards permits\n                 the disassembler to convert explicit base-displacement\n                 addresses to symbolic labels. Labels created within the\n                 program will be 7 characters long. The first character\n                 is 'A', followed by the 6-hex-digit offset to the\n                 label. A using card must be entered for each DSECT to\n                 be used.\n\n     format:\n\n          col 1-5   : literal 'USING'\n          col 6     : blank\n          col 7-12  : offset to begin loc for using range in hex\n                      (this is where the using statement will occur)\n          col 13    : blank\n          col 14-19 : offset to ending loc for using range in hex\n                      (this is where the drop statement will occur)\n          col 20    : blank\n          col 21    : base resister to be used (hex, 1-F)\n          col 22    : blank\n          col 23    : type, P=program base, D=DSECT base\n          col 24    : blank\n          col 25-30 : initial base register value if type P in hex\n          col 25-32 : DSECT name if type D\n\n\n4. Suggestions for use: On the first pass, do not use a SYSPUNCH DD\n          card, but print the SYSPRINT listing. Use the listing to\n          determine which registers are used as program base registers,\n          their initial values, and their ranges. Make up USING cards\n          for these. Find any places where no instructions should be\n          generated (only constants), and make up data-only cards for\n          these ranges. If you can determine any registers that are\n          bases for areas which can be used for DSECTs (CVT reference,\n          etc.), determine the range of valid use, and make up DSECT\n          definitions and using cards for these. Make a second run,\n          including the above cards, and creating a source program\n          output with the SYSPUNCH DD card.\n\n\n\n5. Output description:\n\n   a. SYSPUNCH: this output contains the disassembled source program.\n           Statement names begin in column 1, mnemonics begin in column\n           10, operands in col 16, and an occasional comment begins in\n           column 44. A sequence number (by tens) is in columns 73-80.\n           Comments are included to show the macro name associated with\n           SVC's, and other statements are flagged to aid in\n           identification of certain operations:\n\n                BALR 14,15              STD LINKAGE\n                BALR X,0                ADDRESS SET\n                other BALR'S            NON-STD LINKAGE\n                BAL 0,XXX and BAL 1,XXX PARM SET BRCH\n                BAL X,XXX               PERFORM\n                STM instructions        SAVE REGS\n                LM  instructions        RESTORE REGS\n                BR R14                  EXIT\n                Abs. location X'10'     CVT ADDRESS\n                Abs. location X'4C'     CVT ADDRESS\n                Other abs. locations    PSA REFERENCE\n\n           When used in explicitly in instructions, registers are\n           specified as R0, R1,... R15. An REQU macro is generated at\n           the end of the program to create the appropriate EQU\n           statements. If any DSECTs were defined in the SYSIN dataset,\n           they will be near the end of the source program. The extended\n           mnemonics are used for conditional branches wherever\n           possible.\n\n\n\n    b. SYSPRINT content:\n\n       directory information: contains data from the directory\n                              entry of the module containing\n                              the CSECT to be disassembled.\n       ESD table: a formatted list of all external symbol entries\n                              found in the module.\n       RLD table: a formatted listing of all relocation dictionary\n                              entries pertaining to this CSECT.\n       user entered cards: a list of the cards entered by the user,\n                              with diagnostics, if appropriate.\n       phase 1 label table: a list of all the labels to be used during\n                              disassembly including those developed from\n                              ESD entries, RLD entries, and generated\n                              names resulting from using card\n                              processing.\n       text: a storage-dump formatted listing of the text which\n                              comprises the CSECT being disassembled.\n       source listing: a printout of the generated source program\n                              statements, including the hex value which\n                              resulted in the instruction's creation.\n\n\n6. User Abends:\n\n        DISASM may end with one of two user abends:\n\n        U0777 - There is an invalid parm specified.\n        U0888 - Check in the SYSPRINT listing for an error message\n                describing the error causing the abend (e.g. table\n                overflow).\n\n\nProgram processing description.\n\n DISASM functions:\n\n . Process the parm field, if any: set indicators used by\n   DISASM1 and DISASM2 to set up their instruction tables.\n . Open all files.\n . Get storage for the symbol table, RLD table, and data-only\n   tables (109,544 bytes total).\n . Process the module-CSECT card to obtain the member\n   and CSECT names.\n . Issue BLDL against SYSLIB to obtain directory info for\n   the member specified. If the specified member is an\n   alias, re-issue a BLDL for the real member. Print\n   directory information.\n . Point to the member in the SYSLIB PDS, and process the\n   member. Load modules contain an external symbol dictionary\n   followed by text and relocation dictionary information.\n   all ESD info for the module precedes the first control\n   record. A control record precedes each block of text.\n   RLD info for the text follows each text block. Processing\n   of load module information is as follows:\n   a. Build an external symbol table, using the CESD blocks.\n   b. Search for the desired CSECT as the table is being built. This\n      CSECT must be found before the first control record.\n   c. Read blocks until a control record for the desired CSECT is found\n      (by ESD-id).\n   d. When found, issue GETMAIN for an area large enough to contain the\n      entire text.\n   e. Place text blocks in contiguous storage locations and maintain\n      during disassembly.\n   f. Use RLD information for the CSECT to build the RLD table.\n . Load and perform DISASM1.\n . If any errors found by DISASM1, terminate processing.\n . Print the final label table to be used during disassembly.\n . Load and execute DISASM2.\n . Generate the DSECT entries.\n . Generate the REQU macro and end statements\n . Terminate processing\n\n\n\n DISASM1 functions:\n\n DISASM1 is the second phase of disassembly, and is performed by\n DISASM. A common data area, defined in DISASM, is passed to this\n program on entry.\n\n The SYSIN file is read to exhaustion. Using cards are reformatted and\n stored in a table - up to 256 using statements may be entered. DSECT\n cards may follow the using statements. When used, DSECT statements are\n reformatted, and built into tables. A maximum of 256 DSECTs may be\n entered. Data only cards may be included before, between, or after\n DSECTs to show areas in the program where no instructions occur. Up to\n 256 data only areas may be specified.\n\n At eof on SYSIN, a pseudo dis-assembly pass is made using the text\n stored by disasm. Any resolvable address within the text is used to\n create a new entry in the label table, which will be used by DISASM2\n in the actual dis-assembly pass.\n\n Disassembly tables are set up similarly to those used by DISASM2 for\n the simulated disassembly performed in this module when any program\n base register using statements are entered.\n\n Storage is obtained for the DSECT table and using table, and addresses\n of these tables are stored in the common parameter area. Using and\n DSECT cards are edited, reformatted, and placed in the appropriate\n tables. If any errors are found, they are printed, and the disassembly\n will be terminated on return to disasm.\n\n Storage is obtained for the label table, and a simulated dis-assembly\n is performed to create label table entries for labels which will be\n generated for base-displacement addresses by DISASM2. On return to\n disasm, these labels will be sorted with external symbol and RLD\n labels to form the final label table to be used by DISASM2.\n\n\n\n DISASM2 functions:\n\n This sub-program is called by DISASM after completion of processing by\n DISASM1. The final label table and module text is in an area of\n storage. A common parameter area is defined in disasm, and passed to\n this program.\n\n Text bytes are used to create assembly language statements, and\n machine instruction statements. Output is written to the SYSPUNCH\n dataset for further processing by other modules.\n\n A text byte is considered to be an instruction if it occurs on a\n halfword boundary, is a valid op-code, and is followed by a valid\n op-code. Unconditional branches need not be followed by a valid\n op-code, however. The privileged and floating point instructions are\n not treated as instructions unless the user specified their inclusion\n at exec time.\n\n\n\nInstallation.\n\n a. Assemble and link the three csects, DISASM, DISASM1, and DISASM2.\n    The three csects will all be linked into a single module with entry\n    point DISASM.\n b. If storage utilization is found to be excessive, investigate the\n    possibility of reducing the size of the table GETMAINs in DISASM\n    lines 1360, 1380, 1440, 1500, 5460, and 9450, and in DISASM1 lines\n    1520, 1610, 4160. The programs were written for ease of use with an\n    MVS operating system, and may cause problems in a storage\n    constrained environment.\n c. The SVC table and instruction op code tables in DISASM3A and\n    DISASM3B (which are copied into DISASM1 and DISASM2) should be\n    checked for operating system validity, and currency with the\n    hardware from time to time.\n d. Macros used by the disassembler include SVLNK and REQU. SVLNK is\n    used to establish addressability and chain save areas during\n    initialization in each program, and set up register equates by use\n    of the REQU macro. The REQU macro is also placed in each\n    disassembled program if these macros are used, they should be\n    placed in a macro library or prefixed to the source before\n    assembly. If other macros are used in their place, make appropriate\n    source code changes in DISASM, DISASM1, and DISASM2 before\n    assembly.\n\n e. Direct technical inquiries, comments, suggestions for improvements,\n    etc, to:\n         Dick Thornton\n         Blue Cross of Virginia\n         2015 Staples Mill Road\n         Richmond, Va. 23279\n         Phone: (804) 359-7248\n f. Version updated and modified January 1991 by:\n         Alan C Field\n         Wetterau Inc.,\n         345 Dunn Road,\n         Florissant, Mo., 63031-7995\n         Phone: (314) 839-7040\n g. Version updated and modified March 1991 by:\n         Robert Styma\n         AG Communication Systems\n         P.O. Box 52179\n         Phoenix, Az 85702-2179\n         Phone: (602) 582-7323\n    Made the 3 module format into a 1 module format. Changed the work\n    area sizes to be symbolics and bumped buffer area to handle max\n    length records. This is in DISASM1. Fatal messages are written to\n    the screen using TPUT in addition to going to the print file.\n    DISASM1 and DISASM2 have code which deals with BAS, BASSM and\n    similar instructions. Minor fixes for handling weak externs and\n    label problems. Changes to some of the 2 byte opcodes to show\n    they are not proviledged.\n i. Version updated and modified May 1992 by:\n         Alan C Field\n         Wetterau Inc.,\n         345 Dunn Road,\n         Florissant, Mo., 63031-7995\n         Phone: (314) 839-7040\n    Extensions to opcode tables, change format of printed listing to\n    look more like ASSEMBLER output (easier to read on 80 col screen)\n    and bug fixes where some instructions didn't dis-assemble correctly,\n    increases to some table sizes to handle BIG modules.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PGMDATEJ": {"ttr": 19209, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03?\\x00\\x99\\x03?\\x13B\\x00\\x0f\\x00\\x0f\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-02T00:00:00", "modifydate": "1999-02-02T13:42:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "RH87944"}, "text": "//PGMDATE  JOB\n/*ROUTE  PRINT R7\n//*\n//*    DSN=CBT.SOURCE(PGMDATE)\n//*\n//*   NOTE...THE PARM MUST BE A JULIAN DATE.\n//*          IF NOT SPECIFIED, TODAYS JULIAN DATE IS USED....\n//*          THIS SAYS SHOW ME ANY MEMBER OLDER THAN THIS DATE...\n//*\n//PGMDATE  EXEC PGM=PGMDATE,PARM='95249',REGION=4000K\n//STEPLIB  DD DSN=HALL.LINKLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//SYSABEND DD SYSOUT=*\n//INLIB    DD DISP=SHR,DSN=IMSAT.DBMS.PGMLIB\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PRINTDOC": {"ttr": 19211, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x14\\x01\\x00W\\x00Y\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T14:01:00", "lines": 87, "newlines": 89, "modlines": 0, "user": "RH87944"}, "text": "//DCFPRINT JOB\n/*ROUTE PRINT R7\n/*JOBPARM      K=0,COPIES=1\n//*\n//*   DSN=CBT.SOURCE(HOWPRIN2)\n//*\n//*   FOR THE NEW LEXMARK PRINTER\n//*\n//*  /*OUTPUT F306 DUPLEX=YES,FLASH=NONE,COPIES=1\n//*  /*OUTPUT *    PMODE=P,CHARS=TS12,TWOUP=NO\n//*\n//*    THE FOLLOWING JCL IS USED TO PRINT ON THE 3816 OR THE NEW 3825\n//*\n//*    THE //JES DD INDICATES HOW TO PRINT THE JCL.\n//*    JESDS= CAN BE ALL, LOG, JCL, OR MSG\n//*\n//*    THE OUT1 AND OUT1 DD'S ARE USED TO PRINT ALL OR SOME, OF THE\n//*    INDIVIDUAL OUTPUT FILES.\n//*\n//*    THE //SYSPRINT DD SHOWS HOW TO USE THE  //OUT1/OUT2 INFO....\n//*\n//*JES    OUTPUT JESDS=ALL,PAGEDEF=P1E100,FORMDEF=P1E000\n//*UT1   OUTPUT DEFAULT=NO,COPIES=1,FORMS=X3NA,CLASS=1,\n//OUT1   OUTPUT DEFAULT=NO,COPIES=1,CLASS=A,          LANDSCAPE 67X138\n//             PAGEDEF=L1C100,FORMDEF=L1C000\n//OUT2   OUTPUT DEFAULT=NO,COPIES=1,CLASS=A,          PORTRAIT 88X96\n//             PAGEDEF=P1E100,FORMDEF=P1E000\n//OUT3   OUTPUT DEFAULT=NO,COPIES=1,CLASS=A,          PORTRAIT 64X80\n//             PAGEDEF=P1B000,FORMDEF=P1B000\n//OUT4   OUTPUT FORMDEF=DCF,LINECT=0          FOR LASER/DCF, SYSOUT=1\n//*\n//*\n//*         IF YOU WANT MORE THAN 1 COPY, CHANGE \"PRINT(1,A)\" IN LINE\n//*         43 TO THE NUMBER OF COPIES YOU WANT..EG..\"PRINT(5,A)\"\n//*         WOULD GIVE YOU 5 COPIES.\n//*\n//DCF     EXEC PGM=IKJEFT01,\n//             DYNAMNBR=25,\n//             REGION=2048K\n//STEPLIB   DD DISP=SHR,\n//             DSNAME=SYSPP.DCF.PROD.DCFLOAD\n//          DD DISP=SHR,\n//             DSNAME=SYS9.LOADLIB\n//SYSHELP   DD DISP=SHR,\n//             DSNAME=SYS9.HELP\n//          DD DISP=SHR,\n//             DSNAME=SYS1.HELP\n//SYSPROC   DD DISP=SHR,\n//             DSNAME=SYS9.SYSPROC\n//SCRPTLIB  DD DISP=SHR,DSNAME=SYSPP.DCF.PROD.MACLIB\n//SYSTSPRT  DD SYSOUT=*,COPIES=1\n//SYSPRINT  DD SYSOUT=*\n//*YSPRINT DD SYSOUT=(,),OUTPUT=*.OUT3,\n//*YSPRINT DD SYSOUT=(,),OUTPUT=*.OUT3,\n//* DCB=(RECFM=VBM,LRECL=00255,BLKSIZE=03156,OPTCD=J)\n//*\n//SYSTSIN   DD  *\n SCRIPT 'CBT.SOURCE(HOWBACK)' -\n         BIND(11 5) -\n         DEVICE(3800N6) -\n         FILE(DCFPRINT.LIST) -\n         INDEX -\n         M(D I T) -\n         QUIET -\n         SYSVAR(H YES) -\n         TWOPASS -\n         PROF('SYSPP.DCF.PROD.MACLIB(DSMPROF4)') -\n         CONTINUE;\n/*\n//*      SEARCH('SC57057.ACCUDCF.LIB') -\n//*      BIND(1I 1.1I) - ODD EVEN\n//*      BIND(1 5) -\n//*      PROF('SYS9.DCF.MACLIB(DSMPROF3)') -\n//*---------------------------------------------------------------------\n//*  HARDCOPY PRINT ON XEROX DRILLED, UNSTAPLED PAPER\n//*---------------------------------------------------------------------\n//STEP1 EXEC PGM=IEBGENER,COND=(8,LT)\n//SYSPRINT DD SYSOUT=*\n//*YSUT2   DD SYSOUT=(*,,F306),\n//* DCB=(RECFM=VBM,LRECL=00255,BLKSIZE=03156,OPTCD=J)\n//*YSUT2   DD SYSOUT=(,),OUTPUT=*.OUT3,\n//SYSUT2   DD SYSOUT=(F),OUTPUT=*.OUT3,DEST=PSFSC002, NEW LEXMARK...\n//  DCB=(RECFM=VBM,LRECL=00255,BLKSIZE=03156,OPTCD=J)\n//SYSIN  DD DUMMY\n//SYSUT1 DD DSN=HALL.DCFPRINT.LIST,DISP=(OLD,DELETE)\n//\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REQU": {"ttr": 19214, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x00\\x9f\\x00\\x99\\x00\\x9f\\x12X\\x00(\\x00(\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-01-09T00:00:00", "modifydate": "1999-01-09T12:58:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "RH87944"}, "text": "         MACRO\n&LABEL   REQU &RF,&RL\n.* MACRO TO GENERATE EQUATES FOR REGISTERS: 0(R0) TO 15(R15).\n.* IF NO OPERAND IS SPECIFIED 0-15 ASSUMED.\n.* TWO OPERANDS MAY BE CODED FOR A SERIES OF REGISTERS.\n.* ERROR CHECKING IS FOR LESS THAN 0 OR GREATER THAN 15.\n.* IN CASE OF ERROR CONDITION, 0-15 ARE GENERATED WITH MNOTE.\n         LCLA  &NUM,&MAX\n         AIF   (T'&RF EQ 'O').ALL\n         AIF   ('&RF' LT '0' OR '&RL' GT '15').OPERR\n         AIF   ('&RL' LT '&RF').OPERR\n         AIF   (N'&SYSLIST NE 2).OPERR\n&NUM     SETA &RF\n&MAX     SETA  &RL\n         AGO   .GEN\n.OPERR   ANOP\n         MNOTE 0,'IMPROPER REGISTER SPECIFICATION. R0-R15 GENERATED.'\n.ALL     ANOP\n&NUM     SETA  0\n&MAX     SETA  15\n.GEN     ANOP\n*****   EQUATES FOR REGISTERS   *****\n.LOOP    ANOP\nR&NUM    EQU   &NUM\n         AIF   ('&NUM' EQ '&MAX').END\n&NUM     SETA  &NUM+1\n         AGO   .LOOP\n.END     ANOP\n         SPACE 2\nMASK80   EQU   X'80'\nMASK40   EQU   X'40'\nMASK20   EQU   X'20'\nMASK10   EQU   X'10'\nMASK08   EQU   X'08'\nMASK04   EQU   X'04'\nMASK02   EQU   X'02'\nMASK01   EQU   X'01'\n         EJECT\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RUNDIS": {"ttr": 19457, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x99\\x00\\x8f\\x00\\x99\\x00\\x9f\\x12\\x03\\x00\\x19\\x00\\x19\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-01-08T00:00:00", "modifydate": "1999-01-09T12:03:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "RH87944"}, "text": "//RUNDIS JOB (87944,348496),HALL.S1BL,MSGCLASS=A,PRTY=1,\n//             USER=RH87944,PASSWORD=*\n/*ROUTE  PRINT R7\n//*\n//*      THIS  IS TEST JCL FOR DSECT OFFSETS IN DECIMAL\n//*\n//DISASM EXEC PGM=DISASMN2,PARM=(SUPVR,FLTPT,TEXT)\n//STEPLIB DD DSN=HALL.LOAD,DISP=SHR\n//SYSPRINT DD SYSOUT=*,DCB=BLKSIZE=133\n//SYSLIB DD DSN=SYS1.LPALIB,DISP=SHR\n//SYSPUNCH DD SYSOUT=Z,DCB=BLKSIZE=80\n//*YSPUNCH DD DSN=HALL.IECIOSCN.ASM,DISP=(,CATLG),\n//*           UNIT=SYSDA,DCB=BLKSIZE=18960,\n//*           SPACE=(TRK,(5,2),RLSE)\n//SYSIN DD *\nCSVEXFP CSVEXFP\nUSING 000000 000B28 C P 000000\n/*\n//SYSIN2 DD *\nIEFJRASP IEFJRASR\nUSING 000000 000E10 C P 000022\nIEFJRASP IEFJRASP\nUSING 000022 000980 C P 000022\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SETDATE": {"ttr": 19459, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x14\\x14\\x03B\\x03B\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T14:14:00", "lines": 834, "newlines": 834, "modlines": 0, "user": "RH87944"}, "text": "//SETDATE  JOB\n/*ROUTE  PRINT  R7\n//*\n//*            DSN=CBT.SOURCE(SETDATE)\n//*\n//S1        EXEC  HLASMCL,CLASS='*',\n//   COND.LKED=(7,LT,ASM)\n//ASM.SYSLIB DD DSN=SYS1.MACLIB\n//   DD DSN=SYS1.MACLIB,DISP=SHR    ,UNIT=DISK,VOL=SER=FOOBAR\n//   DD DSN=IMSVS.GENLIB,DISP=SHR\n//   DD DSN=IMSVS.GENLIBA,DISP=SHR\n//   DD DSN=IMSVS.GENLIBB,DISP=SHR\n//*  DD DSN=SYS1.HASPSRC,DISP=SHR\n//   DD DSN=SYS1.AMODGEN,DISP=SHR\n//ASM.SYSIN DD  *\n*\n*              PUT DATE INTO A CONTROL RECORD IN A DATASET, OR\n*              PASS IT BACK IN THE PARM.\n*              THE DATASET CONTAINS ONLY 1 RECORD!!!\n*\n***********************************************************************\n*\n*   TO CALL SETDATE FROM PL/I, USE THE FOLLOWING.. ..\n*\n*/*\n*        SINCE  SETDATE IS A NORMAL ASSEMBLER PROGRAM, IT MUST\n*        HAVE THE OPTIONS(ASSEMBLER) PARM.\n* */\n*   DCL  SETDATE        EXTERNAL ENTRY(CHAR(16))         /* */\n*                       OPTIONS(ASSEMBLER,INTER);\n*\n*      DECLARE\n*         I_PTR\n*                         POINTER ;\n*   DECLARE\n*      1 PARM,\n*          3   PARM_LTH           FIXED BIN INIT(14) ,\n*          3   PARM_DATA          CHARACTER(14)\n*                         INIT('FMT=MM/DD/YYYY'),\n*\n*        SETDATE_PARM             BASED (I_PTR)\n*                                 CHARACTER(32) ;\n*\n*              /* STEPLIB TO HALL.LINKLIB FOR SETDATE               */\n*         FETCH SETDATE ;         /* LOAD SETDATE                   */\n*\n*/*\n*              CALL SETDATE TO GET DATE\n**/\n*         I_PTR =  ADDR(PARM)     ;\n*         CALL SETDATE(SETDATE_PARM) ;\n*\n*  AT THIS POINT, THE  MM/DD/YYYY AFTER FMT= IS TODAYS  DATE\n*\n***********************************************************************\n*\n         TITLE '******* EXECUTE PROGRAM SETDATE ******'\n         SPACE 3\nSETDATE  CSECT\nSETDATE  AMODE 24\nSETDATE  RMODE 24\n         USING *,R15              SET TEMP BASE\n         B     AROUND             BRANCH AROUND DUMP TITLE\n         DC    AL1(EYELTH)\nEYECATCH DC    C'SETDATE '        PROGRAM NAME\n         DC    C'VERSION 1 '      VERSION\n         DC    C'&SYSDATE'        DATE WRITTEN\n         DC    C' '               BLANK\n         DC    C'&SYSTIME'        TIME WRITTEN\nEYELTH   EQU   *-EYECATCH         LTH OF EYE CATCHER\n         SPACE 1\nAROUND   DS    0H\n         LA    R1,0(0,R1)         CLEAR HI-ORDER BYTE FOR 31 BIT\n         LA    R13,0(0,R13)       CLEAR HI-ORDER BYTE FOR 31 BIT\n         BSM   R14,0              SAVE CURRENT AMODE\n         STM   R14,R12,12(R13)\n         LR    R12,R15            SET BASE REG 1\n         LA    R11,4095(0,R12)    SET BASE REG 2\n         LA    R11,1(0,R11)       ''\n         DROP  R15\n         USING SETDATE,R12,R11\n         ST    R13,SAVE+4\n         LA    R13,SAVE\n         L     R5,0(0,R1)         R5 -> TO SYSTEM PARM\n         OPEN  (REPORT,(OUTPUT))  OPEN SYSPRINT FILE\n         SPACE 1\n***********************************************************************\n*\n*              SEE IF THERE IS A  PARM\n*\n*        VALID PARMS ARE:\n*              POS=NNN   DECIMAL POSITION OF WHERE TO PUT MMDDYY(YY)\n*              VAR='VARIABLE'  FIND 'VARIABLE' AND THEN PUT\n*                              MMDDYY(YY) AFTER IT\n*              FMT=MMDDYY      FORMAT FOR DATE FIELD.\n*                  MMDDYYYY    IF NOT SPECIFIED, THE DEFAULT IS\n*                  DDMMYY      MMDDYY(YY).\n*                  DDMMYYYY\n*                  MM/DD/YY\n*                  MM/DD/YYYY\n*                  DD/MM/YY\n*                  DD/MM/YYYY\n*                  DD MTH YYYY\n*                  YYYY MTH DD  .....ETC....\n*\n*        ANY OTHER PARMS ARE INVALID\n*        IF NO PARMS ARE SPECIFIED, THE DEFAULTS WILL BE\n*              PARM='POS=1,FMT=MMDDYY'\n*\n*        IF THE //DATEREC FILE IS NOT SPECIFIED, I ASSUME SETDATE\n*        IS CALLED BY ANOTHER PROGRAM, AND THE DATE IS PASSED BACK\n*        IN THE PARM AT THE FMT= VARIABLE.\n*\n*\n***********************************************************************\n         SPACE 1\n*              GET PARM, IF ANY\n         SPACE 1\nPARM0    DS    0H\n         LA    R10,2(0,R5)        R10 -> TO PARM\n         LH    R2,0(0,R5)         R2 = PARM LTH\n         LTR   R2,R2              IS THERE A PARM ?\n         BZ    ENDPARM            NO\n         LR    R4,R10             YES, R4 -> TO PARM\n         SPACE 1\nPARM1    DS    0H\n         CLC   =C'POS=',0(R4)     IS IT THE 'POS=' PARM?\n         BNE   PARM2              NO, CHECK FOR NEXT PARM\n         SPACE 1\n         LA    R4,4(0,R4)         R4 -> PAST POS=\n         SH    R2,=H'4'           R2 = LTH OF REST OF PARM\n         BNP   PARM99             0 = BAD PARM\n         LR    R5,R4              R5 -> TO PGM NAME\n         SPACE 1\nPARM1B   DS    0H\n         CLI   0(R4),C','         AT END OF POSITION?\n         BE    PARM1C             YES, GO GET NEXT PARM\n         LA    R4,1(0,R4)         R4 -> TO NEXT KEY BYTE, IF ANY\n         BCT   R2,PARM1B          CHECK ALL CHARS LEFT\n         SPACE 1\nPARM1C   DS    0H\n         LR    R6,R4              R6 -> TO END OF POSITION\n         SR    R6,R5              R6 = LTH OF PGM NAME\n         BCTR  R6,0               R6 = HEX LTH\n*        MVC   PGMNAME,=CL8' '    CLEAR PGM NAME FIELD\n         EX    R6,MVCPGM          PACK POSITION\n         CVB   R6,DWORD           CONVERT TO HEX\n         BCTR  R6,0               R6 = HEX OFFSET\n         STH   R6,OFFSET          SAVE IT\n         OI    FLAG,X'80'         SAY WE HAVE AN OFFSET\n         B     NEXTPARM           GO CHECK FOR ANOTHER PARM\n         SPACE 1\nMVCPGM   PACK  DWORD(8),0(0,R5)   PACK POSITION\n*VCPGM   MVC   PGMNAME(0),0(R5)   MOVE PGM NAME\n         SPACE 1\nPARM2    DS    0H\n         CLC   =C'FMT=',0(R4)     IS IT THE 'FMT=' PARM?\n         BNE   PARM3              NO, CHECK FOR NEXT PARM\n         SPACE 1\n         LA    R4,4(0,R4)         R4 -> TO FMT= PARM, IF ANY\n         SH    R2,=H'4'           R2 = LTH OF REST OF PARM\n         BNP   PARM99             0 = BAD PARM\n         LR    R14,R2             R14 = PARM LTH LEFT\n         LR    R5,R4              R5 -> TO FMT= PARM\n         SPACE 1\nPARM2MM  DS    0H\n         CLC   =C'MM',0(R4)       PUT DECIMAL MONTH FIRST?\n         BE    PARM2M2            YES\n         CLC   =C'MTH',0(R4)      PUT CHARACTER MONTH FIRST?\n         BNE   PARM2DD            NO\n         LA    R4,1(0,R4)         R4 -> TO NEXT KEY BYTE, IF ANY\n         BCTR  R2,0               R2 = LTH OF REST OF PARM\n         OI    FMTFLAG,CHARMTH    SAY HE WANTS CHAR MONTH\n         SPACE 1\nPARM2M2  DS    0H\n         OI    FMTFLAG,MM1ST      SAY HE WANTS MONTH 1ST\n         LA    R4,2(0,R4)         R4 -> TO NEXT KEY BYTE, IF ANY\n         BCTR  R2,0               R2 = LTH OF REST OF PARM\n         BCTR  R2,0               R2 = LTH OF REST OF PARM\n         LTR   R2,R2              ANY MORE PARM?\n         BZ    BADPARM            NO, BAD PARM\n         B     PARM2SL            SEE IF HE WANTS /\n         SPACE 1\nPARM2DD  DS    0H\n         CLC   =C'DD',0(R4)       PUT DAY FIRST?\n         BNE   PARM2YY            NO\n         OI    FMTFLAG,DD1ST      SAY HE WANTS DAY 1ST\n         LA    R4,2(0,R4)         R4 -> TO NEXT KEY BYTE, IF ANY\n         BCTR  R2,0               R2 = LTH OF REST OF PARM\n         BCTR  R2,0               R2 = LTH OF REST OF PARM\n         LTR   R2,R2              ANY MORE PARM?\n         BZ    BADPARM            NO, BAD PARM\n         B     PARM2SL            SEE IF HE WANTS /\n         SPACE 1\nPARM2YY  DS    0H\n         CLC   =C'YY',0(R4)       PUT YEAR FIRST?\n         BNE   BADPARM            IT'S GOTTA BE ONE OF THEM...\n         OI    FMTFLAG,YY1ST      SAY HE WANTS YEAR 1ST\n         LA    R4,2(0,R4)         R4 -> TO NEXT KEY BYTE, IF ANY\n         BCTR  R2,0               R2 = LTH OF REST OF PARM\n         BCTR  R2,0               R2 = LTH OF REST OF PARM\n         LTR   R2,R2              ANY MORE PARM?\n         BZ    BADPARM            NO, BAD PARM\n         CLC   =C'YY',0(R4)       USE 4 DIGIT YEAR?\n         BNE   PARM2SL            NO\n         OI    FMTFLAG,YYYYFMT    SAY HE WANTS 4 DIGIT YEAR 1ST\n         LA    R4,2(0,R4)         R4 -> TO NEXT KEY BYTE, IF ANY\n         BCTR  R2,0               R2 = LTH OF REST OF PARM\n         BCTR  R2,0               R2 = LTH OF REST OF PARM\n         LTR   R2,R2              ANY MORE PARM?\n*        BZ    NEXTPARM           NO\n         BZ    BADPARM            NO, BAD PARM\n         SPACE 1\nPARM2SL  DS    0H\n*        CLI   0(R4),C'/'         PUT / BETWEEN MM DD YY ?\n*        BNE   PARM2MID           NO\n         CLI   0(R4),C'D'         FIND DAY?\n         BE    PARM2MID           YES, NOT A SEPARATOR\n         CLI   0(R4),C'M'         FIND MONTH?\n         BE    PARM2MID           YES, NOT A SEPARATOR\n         CLI   0(R4),C'Y'         FIND YEAR?\n         BE    PARM2MID           YES, NOT A SEPARATOR\n         OI    FMTFLAG,ADDSEP     SAY HE WANTS SEPARATOR\n         MVC   SEPCHAR,0(R4)      SAVE SEPARATOR CHAR\n         LA    R4,1(0,R4)         R4 -> TO NEXT KEY BYTE, IF ANY\n         BCTR  R2,0               R2 = LTH OF REST OF PARM\n         LTR   R2,R2              ANY MORE PARM?\n*        BZ    NEXTPARM           NO\n         BZ    BADPARM            NO, BAD PARM\n         SPACE 1\nPARM2MID DS    0H\n         OI    FMTFLAG,MM2ND      ASSUME MM IS IN THE MIDDLE\n         CLC   =C'MM',0(R4)       MIDDLE CHARS MM?\n         BE    PARM2END           YES\n         CLC   =C'MTH',0(R4)      MIDDLE CHARS MTH?\n         BNE   PARM2MI2           NO, MIDDLE IS DD\n         OI    FMTFLAG,CHARMTH    SAY HE WANTS CHAR MONTH\n         LA    R4,1(0,R4)         R4 -> TO NEXT PARM, IF ANY\n         BCTR  R2,0               R2 = LTH OF REST OF PARM\n         B     PARM2END\n         SPACE 1\nPARM2MI2 DS    0H\n         NI    FMTFLAG,255-MM2ND  SAY DD IS IN THE MIDDLE\n         CLC   =C'DD',0(R4)       MIDDLE CHARS DD?\n         BNE   BADPARM            NO, BAD PARM\n         SPACE 1\nPARM2END DS    0H\n         LA    R4,2(0,R4)         R4 -> TO NEXT PARM, IF ANY\n         SH    R2,=H'2'           R2 = LTH OF REST OF PARM\n         LTR   R2,R2              ANY MORE PARM?\n         BZ    BADPARM            NO, BAD PARM\n*        CLI   0(R4),C'/'         PUT / BETWEEN MM YY ?\n         CLC   0(1,R4),SEPCHAR    PUT SEPARATOR BETWEEN MM YY ?\n         BNE   PARM2C             NO\n         LA    R4,1(0,R4)         R4 -> TO NEXT KEY BYTE, IF ANY\n         BCTR  R2,0               R2 = LTH OF REST OF PARM\n         LTR   R2,R2              ANY MORE PARM?\n*        BZ    NEXTPARM           NO\n         BZ    BADPARM            NO, BAD PARM\n         SPACE 1\nPARM2C   DS    0H\n         CLC   =C'DD',0(R4)       END CHARS DD?\n         BE    PARM2C2            YES\n         CLC   =C'MM',0(R4)       END CHARS MM?\n         BE    PARM2C2            YES\n         CLC   =C'YY',0(R4)       WE BETTER HAVE YEAR CODE HERE\n         BNE   BADPARM            IT'S GOTTA BE ONE OF THEM...\n         SPACE 1\nPARM2C2  DS    0H\n         LA    R4,2(0,R4)         R4 -> TO NEXT KEY BYTE, IF ANY\n         BCTR  R2,0               R2 = LTH OF REST OF PARM\n         BCTR  R2,0               R2 = LTH OF REST OF PARM\n         LTR   R2,R2              ANY MORE PARM?\n         BZ    PARM2Z             NO, NOT YYYY\n         CLC   =C'YY',0(R4)       USE 4 DIGIT YEAR?\n         BNE   BADPARM            NO, MUST BE YYYY...\n         OI    FMTFLAG,YYYYFMT    SAY HE WANTS 4 DIGIT YEAR 1ST\n         LA    R4,2(0,R4)         R4 -> TO NEXT KEY BYTE, IF ANY\n         BCTR  R2,0               R2 = LTH OF REST OF PARM\n         BCTR  R2,0               R2 = LTH OF REST OF PARM\n*        LTR   R2,R2              ANY MORE PARM?\n*        BZ    NEXTPARM           NO\n*        BZ    BADPARM            NO, BAD PARM\n         SPACE 1\nPARM2Z   DS    0H\n         SR    R14,R2             R14 = LTH OF DATE FORMAT\n         ST    R14,SAVELTH        SAVE IT\n         ST    R5,SAVEHERE        SAVE ADDR IN CASE NO DATEREC DD\n         B     NEXTPARM           LOOK AT ALL CHARS IN PARM\n         SPACE 1\nPARM3    DS    0H\n         CLC   =C'VAR=',0(R4)     IS IT THE 'VAR=' PARM?\n         BNE   PARM4              NO, CHECK FOR NEXT PARM\n         SPACE 1\n         OI    FLAG,X'40'         SAY HE SPECIFIED VAR= PARM\n         LA    R4,4(0,R4)         R4 -> TO VAR= PARM, IF ANY\n         SH    R2,=H'4'           R2 = LTH OF REST OF PARM\n         BNP   PARM99             0 = BAD PARM\n         LR    R5,R4              R5 -> TO VAR= PARM\n         SPACE 1\nPARM3B   DS    0H\n         CLI   0(R4),C','         AT END OF VAR= PARM?\n         BE    PARM3Z             YES, GO SET UP FORMAT NAME\n         LA    R4,1(0,R4)         R4 -> TO NEXT KEY BYTE, IF ANY\n         BCTR  R2,0               R2 = LTH OF REST OF PARM\n         LTR   R2,R2              ANY MORE PARM?\n         BP    PARM3B             YES, GO CHECK IT\n         SPACE 1\nPARM3Z   DS    0H\n         MVI   VARNAME,C' '       CLEAR TPGMLIB DSN\n         MVC   VARNAME+1(43),VARNAME ''\n         LR    R15,R4             R15 -> TO END OF PARM\n         SR    R15,R5             R15 = LTH OF PARM\n         BCTR  R15,0              R15 = HEX LTH\n         EX    R15,MVCFMT         SET UP PART OF PGMLIB NAME\n         STH   R15,VARLTH         SAVE VARIABLE'S HEX LTH\n         B     NEXTPARM           LOOK AT ALL CHARS IN PARM\n         SPACE 1\nMVCFMT   MVC   VARNAME(0),0(R5)   SET UP FIRST PART OF PGMLIB NAME\n*\n*              SEE IF WE FIND HERE= AREA\n*\n         SPACE 1\nPARM4    DS    0H\n         AGO   .NO4\n         CLC   =C'HERE=',0(R4)    IS IT THE 'HERE=' PARM?\n         BNE   PARM99             NO, CHECK FOR NEXT PARM\n         SPACE 1\n         OI    FLAG,X'20'         SAY HE SPECIFIED HERE= PARM\n         LA    R4,5(0,R4)         R4 -> TO HERE= PARM, IF ANY\n         SH    R2,=H'5'           R2 = LTH OF REST OF PARM\n         BNP   PARM99             0 = BAD PARM\n         LR    R5,R4              R5 -> TO HERE= PARM\n         SPACE 1\nPARM4B   DS    0H\n         CLI   0(R4),C','         AT END OF HERE= PARM?\n         BE    PARM4Z             YES, GO SET UP FORMAT NAME\n         LA    R4,1(0,R4)         R4 -> TO NEXT KEY BYTE, IF ANY\n         BCTR  R2,0               R2 = LTH OF REST OF PARM\n         LTR   R2,R2              ANY MORE PARM?\n         BP    PARM4B             YES, GO CHECK IT\n         SPACE 1\nPARM4Z   DS    0H\n*        MVI   HERENAME,C' '      CLEAR TPGMLIB DSN\n*        MVC   HERENAME+1(43),HERENAME ''\n         LR    R15,R4             R15 -> TO END OF PARM\n         SR    R15,R5             R15 = LTH OF PARM\n         ST    R5,SAVEHERE        SAVE A(FORDATE)\n*        BCTR  R15,0              R15 = HEX LTH\n*        EX    R15,MVCFMT         SET UP PART OF PGMLIB NAME\n*        STH   R15,HERELTH        SAVE VARIABLE'S HEX LTH\n.NO4     ANOP\n         B     NEXTPARM           LOOK AT ALL CHARS IN PARM\n         SPACE 1\nPARM99   DS    0H\n         B     BADPARM            PRINT BAD PARM MSG\n         SPACE 1\nNEXTPARM DS    0H\n         LTR   R2,R2              ANY PARM LEFT?\n         BNP   ENDPARM            NO\n         CLI   0(R4),C','         COMMA?\n         BE    NEXTPAR2           YES, DROP IT\n         CLI   0(R4),C' '         BLANK?\n         BNE   PARM1              NO, GO SEE WHAT IT IS\n         SPACE 1\nNEXTPAR2 DS    0H\n         LA    R4,1(0,R4)         YES, R4 -> TO NEXT BYTE\n         BCTR  R2,0               TAKE 1 OFF PARM LTH\n         B     NEXTPARM           LOOK AT ALL CHARS IN PARM\n         SPACE 1\nENDPARM  DS    0H\n*\n*        GET TODAYS DATE AND TIME\n*\n         TIME  DEC,SAVETIME,            GET THE SYS TIME            Y2 +\n               LINKAGE=SYSTEM,DATETYPE=MMDDYYYY     IN THIS CASE    Y2\n         UNPK  SAVEDATE(9),SAVETIME+8(5) UNPACK DATE\n*\n*        OPEN DATE DATASET AND GET FIRST AND ONLY RECORD\n*\nGOTTIME  DS    0H\n         RDJFCB DATEREC           GET JFCB INFO\n         LTR   R15,R15            DID WE FIND A DATEREC DD?\n         BNZ   NODD               NO, NOTHING TO READ\n*\n         LA    R6,DATEREC         R6 -> TO DCB\n         USING IHADCB,R6\n         OPEN  (DATEREC,(INPUT))\n         TM    DCBOFLGS,DCBOFOPN  TEST IF OPEN\n         BO    OPENOK             IT OPENED...\n*\nNODD     DS    0H\n         ICM   R6,15,SAVEHERE     R6 -> AT PARM SAVE AREA\n         BZ    BADSYSOP           NO SAVE AREA, TOO BAD....\n         SR    R15,R15            DEFAULT OFFSET = 0\n         B     USEOFF4          IF CANNOT OPEN, ASSUME PUT IN PARM\n*        BZ    BADSYSOP         IF CANNOT OPEN\n         DROP  R6\n         SPACE 1\nOPENOK   DS    0H\n         SR    R6,R6              R6 = 0\n         SPACE 1\nSYSOPEN4 DS    0H\n         GET   DATEREC,CONTROL    GET DATE CHK RECORD. EOF=RETURN6\n*        MVC   CONTROL,0(R1)      SAVE LAST RECORD\n         LA    R6,CONTROL         R6 -> AT RECORD\n         SPACE 1\nRETURN6  DS    0H\n         CLOSE (DATEREC)          CLOSE DATE FILE\n         SPACE 1\n         LTR   R6,R6              WAS DATASET EMPTY?\n         BE    CANTRUN            YES, TOO BAD\n         LA    R5,70              R5 = MAX CHARS TO CHECK\n*\n         TM    FLAG,X'40'         LOOK FOR A VARIABLE?\n         BZ    USEOFF             NO, USE OFFSET\n         LH    R15,VARLTH         R15 = VARIABLE'S HEX LTH\n         B     FINDVAR            GO FIND VARIABLE\n*\n*              PUT DATE AT OFFSET\n*\nUSEOFF   DS    0H\n         SR    R15,R15            DEFAULT OFFSET = 0\n         TM    FLAG,X'80'         DO WE HAVE AN OFFSET?\n         BZ    USEOFF4            NO, USE DEFAULT OFFSET OF 0\n         LH    R15,OFFSET         R15 = HEX OFFSET FOR VARIABLE\n*\nUSEOFF4  DS    0H\n         LA    R6,0(R15,R6)       R6 -> DATE FIELD\n         B     A25                GO PUT DATE AT OFFSET\n*\n*              FIND VARIABLE\n*\nFINDVAR  DS    0H\n         EX    R15,CLCVAR         CHECK FOR VARIABLE\n         BE    A20                YES\n         LA    R6,1(0,R6)         NO, R6 -> AT NEXT BYTE\n         BCT   R5,FINDVAR         GO CHECK IT\n         B     CANTRUN            NOT FOUND, DON'T LET JOB RUN\n*\nCLCVAR   CLC   0(0,R6),VARNAME    IS IT OUR VARIABLE?\n*\nA20      DS    0H\n         LA    R6,1(R15,R6)       R6 -> DATE FIELD\n*\nA25      DS    0H\n         CLI   FMTFLAG,X'00'      WAS A FORMAT SPECIFIED?\n         BNE   FMTDATE            YES, GO SET IT UP\n*\nA27      DS    0H\n         CLC   6(1,R6),=C' '      WANT CENTURY IN YEAR?\n         BE    A40                NO, SET IT AS MMDDYY\n         CLC   6(1,R6),=C','      WANT CENTURY IN YEAR?\n         BE    A40                NO, SET IT AS MMDDYY\n*\nA30      DS    0H\n         MVC   0(8,R6),SAVEDATE   PUT MMDDYYYY IN RECORD\n         B     CHKOKAY            ON WE GO\n*\nA40      DS    0H\n         MVC   0(4,R6),SAVEDATE   PUT MMDD IN RECORD\n         MVC   4(2,R6),SAVEDATE+6 PUT YY IN RECORD\n         B     CHKOKAY            ON WE GO\n*        AGO   .NOB\n*\n*              PUT DATE AT R6 IN  FORMAT SPECIFIED\n*\nFMTDATE  DS    0H\n*        SR    R15,R15            DEFAULT OFFSET = 0\n         TM    FMTFLAG,MM1ST      PUT MONTH FIRST?\n         BZ    B20                NO, CHECK FOR DAY\n         MVC   0(2,R6),SAVEDATE   PUT MM IN RECORD\n         TM    FMTFLAG,CHARMTH    WANT MONTH IN CHAR?\n         BZ    B02                NO\n         PACK  DWORD,SAVEDATE(2)  PACK MONTH\n         CVB   R14,DWORD          CONVERT TO HEX\n         MH    R14,=H'3'          TIMES ENTRY LTH\n         LA    R14,MTHTAB(R14)    R14 -> AT CHAR MONTH\n         MVC   0(3,R6),0(R14)     PUT CHAR MONTH IN DATE\n         LA    R6,1(0,R6)         R6 -> NEXT DATE BYTE\n*\nB02      DS    0H\n         LA    R6,2(0,R6)         R6 -> NEXT DATE BYTE\n         TM    FMTFLAG,ADDSEP     PUT SEPARATOR BETWEEN MM AND DD?\n         BZ    B10                NO\n         MVC   0(1,R6),SEPCHAR    PUT SEPARATOR IN RECORD\n         LA    R6,1(0,R6)         R6 -> NEXT DATE BYTE\n*        LH    R15,OFFSET         R15 = HEX OFFSET FOR VARIABLE\n*\nB10      DS    0H\n         MVC   0(2,R6),SAVEDATE+2 PUT DD IN RECORD\n         LA    R6,2(0,R6)         R6 -> NEXT DATE BYTE\n*        TM    FMTFLAG,ADDSEP     PUT / BETWEEN DD AND YY?\n         TM    FMTFLAG,ADDSEP     PUT SEPARATOR BETWEEN DD AND YY?\n         BZ    B12                NO\n*        MVI   0(R6),C'/'         PUT / IN RECORD\n         MVC   0(1,R6),SEPCHAR    PUT SEPARATOR IN RECORD\n         LA    R6,1(0,R6)         R6 -> NEXT DATE BYTE\n*\nB12      DS    0H\n         MVC   0(2,R6),SAVEDATE+6 ASSUME WE WANT YY IN RECORD\n         TM    FMTFLAG,YYYYFMT    WANT YYYY?\n         BZ    CHKOKAY            NO, DATE IS SET UP\n         MVC   0(4,R6),SAVEDATE+4 PUT YYYY IN RECORD\n         B     CHKOKAY            DATE IS SET UP\n*\nB20      DS    0H\n         TM    FMTFLAG,DD1ST      PUT DAY FIRST?\n         BZ    B30                NO, CHECK FOR YEAR\n         MVC   0(2,R6),SAVEDATE+2 PUT DD IN RECORD\n         LA    R6,2(0,R6)         R6 -> NEXT DATE BYTE\n         TM    FMTFLAG,ADDSEP     PUT SEPARATOR BETWEEN DD AND MM?\n         BZ    B22                NO\n*        MVI   0(R6),C'/'         PUT / IN RECORD\n         MVC   0(1,R6),SEPCHAR    PUT SEPARATOR IN RECORD\n         LA    R6,1(0,R6)         R6 -> NEXT DATE BYTE\n*\nB22      DS    0H\n         MVC   0(2,R6),SAVEDATE   PUT MM IN RECORD\n         TM    FMTFLAG,CHARMTH    WANT MONTH IN CHAR?\n         BZ    B23                NO\n         PACK  DWORD,SAVEDATE(2)  PACK MONTH\n         CVB   R14,DWORD          CONVERT TO HEX\n         MH    R14,=H'3'          TIMES ENTRY LTH\n         LA    R14,MTHTAB(R14)    R14 -> AT CHAR MONTH\n         MVC   0(3,R6),0(R14)     PUT CHAR MONTH IN DATE\n         LA    R6,1(0,R6)         R6 -> NEXT DATE BYTE\n*\nB23      DS    0H\n         LA    R6,2(0,R6)         R6 -> NEXT DATE BYTE\n         TM    FMTFLAG,ADDSEP     PUT SEPARATOR BETWEEN MM AND YY?\n         BZ    B24                NO\n*        MVI   0(R6),C'/'         PUT / IN RECORD\n         MVC   0(1,R6),SEPCHAR    PUT SEPARATOR IN RECORD\n         LA    R6,1(0,R6)         R6 -> NEXT DATE BYTE\n*\nB24      DS    0H\n         MVC   0(2,R6),SAVEDATE+6 ASSUME WE WANT YY IN RECORD\n         TM    FMTFLAG,YYYYFMT    WANT YYYY?\n         BZ    CHKOKAY            NO, DATE IS SET UP\n         MVC   0(4,R6),SAVEDATE+4 PUT YYYY IN RECORD\n         B     CHKOKAY            DATE IS SET UP\n*\n*              SET UP DATE AS YY(YY)..ETC\n*\nB30      DS    0H\n*        MVC   0(8,R6),SAVEDATE   PUT MMDDYYYY IN RECORD\n*        B     CHKOKAY            ON WE GO\n         TM    FMTFLAG,YY1ST      PUT YEAR FIRST?\n         BZ    BADPARM            NO, WHAT'S GOING ON?\n         MVC   0(2,R6),SAVEDATE+6 ASSUME WE WANT YY IN RECORD\n         TM    FMTFLAG,YYYYFMT    WANT YYYY?\n         BZ    B31                NO, DATE IS SET UP\n         MVC   0(4,R6),SAVEDATE+4 PUT YYYY IN RECORD\n         LA    R6,2(0,R6)         R6 -> NEXT DATE BYTE\n*\nB31      DS    0H\n         LA    R6,2(0,R6)         R6 -> NEXT DATE BYTE\n         TM    FMTFLAG,ADDSEP     PUT SEPARATOR BETWEEN YY AND MM?\n         BZ    B31A               NO\n         MVC   0(1,R6),SEPCHAR    PUT SEPARATOR IN RECORD\n         LA    R6,1(0,R6)         R6 -> NEXT DATE BYTE\n*\nB31A     DS    0H\n         TM    FMTFLAG,MM2ND      PUT MM IN THE MIDDLE?\n         BO    B34                YES\n         MVC   0(2,R6),SAVEDATE+2 PUT DD IN RECORD\n         LA    R6,2(0,R6)         R6 -> NEXT DATE BYTE\n         TM    FMTFLAG,ADDSEP     PUT SEPARATOR BETWEEN DD AND MM?\n         BZ    B32                NO\n*        MVI   0(R6),C'/'         PUT / IN RECORD\n         MVC   0(1,R6),SEPCHAR    PUT SEPARATOR IN RECORD\n         LA    R6,1(0,R6)         R6 -> NEXT DATE BYTE\n*\nB32      DS    0H\n         MVC   0(2,R6),SAVEDATE   PUT MM IN RECORD\n         TM    FMTFLAG,CHARMTH    WANT MONTH IN CHAR?\n         BZ    B33                NO\n         PACK  DWORD,SAVEDATE(2)  PACK MONTH\n         CVB   R14,DWORD          CONVERT TO HEX\n         MH    R14,=H'3'          TIMES ENTRY LTH\n         LA    R14,MTHTAB(R14)    R14 -> AT CHAR MONTH\n         MVC   0(3,R6),0(R14)     PUT CHAR MONTH IN DATE\n         LA    R6,1(0,R6)         R6 -> NEXT DATE BYTE\n*\nB33      DS    0H\n         LA    R6,2(0,R6)         R6 -> NEXT DATE BYTE\n         B     B38                END OF DATE\n*\nB34      DS    0H\n         MVC   0(2,R6),SAVEDATE   PUT MM IN RECORD\n         TM    FMTFLAG,CHARMTH    WANT MONTH IN CHAR?\n         BZ    B35                NO\n         PACK  DWORD,SAVEDATE(2)  PACK MONTH\n         CVB   R14,DWORD          CONVERT TO HEX\n         MH    R14,=H'3'          TIMES ENTRY LTH\n         LA    R14,MTHTAB(R14)    R14 -> AT CHAR MONTH\n         MVC   0(3,R6),0(R14)     PUT CHAR MONTH IN DATE\n         LA    R6,1(0,R6)         R6 -> NEXT DATE BYTE\n*\nB35      DS    0H\n         LA    R6,2(0,R6)         R6 -> NEXT DATE BYTE\n         TM    FMTFLAG,ADDSEP     PUT SEPARATOR BETWEEN MM AND DD?\n         BZ    B36                NO\n*        MVI   0(R6),C'/'         PUT / IN RECORD\n         MVC   0(1,R6),SEPCHAR    PUT SEPARATOR IN RECORD\n         LA    R6,1(0,R6)         R6 -> NEXT DATE BYTE\n*\nB36      DS    0H\n         MVC   0(2,R6),SAVEDATE+2 PUT DD IN RECORD\n         LA    R6,2(0,R6)         R6 -> NEXT DATE BYTE\n         LA    R6,2(0,R6)         R6 -> NEXT DATE BYTE\n*        B     B38                END OF DATE\n*\nB38      DS    0H\n*\nB40      DS    0H\n         MVC   0(4,R6),SAVEDATE   PUT MMDD IN RECORD\n         MVC   4(2,R6),SAVEDATE+6 PUT YY IN RECORD\n         B     CHKOKAY            ON WE GO\n.NOB     ANOP\n*\nCHKOKAY  DS    0H\n*\n*        OPEN DATEREC DATASET FOR OUTPUT\n*\n         RDJFCB DATEREC           GET JFCB INFO\n         LTR   R15,R15            DID WE FIND A DATEREC DD?\n         BZ    PUTREC             YES, GO WRITE IT\n*\n         L     R6,SAVEHERE        R6 -> PARM SAVE AREA\n         L     R14,SAVELTH        LOAD DATE LTH\n         BCTR  R14,0              R14 = HEX LTH\n         EX    R14,MVCDATE        PUT DATE IN PRINT RECORD\n         B     PRINTDAT           GO PRINT IT\nMVCDATE  MVC   CONTROL(0),0(R6)   PUT IT IN PRINT AREA\n*\nPUTREC   DS    0H\n         LA    R6,DATEREC         R6 -> TO DCB\n         USING IHADCB,R6\n         OPEN  (DATEREC,(OUTPUT))\n         TM    DCBOFLGS,DCBOFOPN  TEST IF OPEN\n         BZ    NOCHKOUT         IF CANNOT OPEN\n*        BO    OPENOK2            IT OPENED...\n*        ICM   R6,15,SAVEHERE     R6 -> AT PARM SAVE AREA\n*        BZ    NOCHKOUT           NO SAVE AREA, TOO BAD....\n*        SR    R15,R15            DEFAULT OFFSET = 0\n*        B     PRINTDAT         IF CANNOT OPEN, ASSUME PUT IN PARM\n         SPACE 1\nOPENOK2  DS    0H\n         DROP  R6\n*\n*\n* WRITE OUT THE DATE RECORD\n*\n         PUT   DATEREC,CONTROL    WRITE RECORD\n         CLOSE (DATEREC)          CLOSE FILE\n*\n* ALSO  PRINT IT ON SYSPRINT\n*\nPRINTDAT DS    0H\n         MVC   HDR180,CONTROL     PUT RECORD IN PRINT LINE\n         SPACE 1\n         PUT   REPORT,HDR1        PRINT RECORD\n         MVI   HDR180,C' '        CLEAR PRINT LINE\n         MVC   HDR180+1(79),HDR180 ''\n         BAL   R5,PRINTLNE        PRINT RC MESSAGE\n         B     RETURN             WE ARE DONE\n         SPACE 1\n*\n*              ERROR ROUTINES/MESSAGES\n*\nBADPARM  DS    0H\n         MVC   HDR1(L'PARMMSG),PARMMSG  SET UP MSG\n         MVC   HDR1+L'PARMMSG+1(40),0(R5)  SET UP MSG\n         MVI   IMFLRC+3,36        RC= 36, AND RETURN\n         B     PRINTHEX           PRINT MSG AND ABEND\n         SPACE 1\nCANTRUN  DS    0H\n         MVC   HDR1(BADLLTH),BADLOCM  SET UP MSG\n         MVI   IMFLRC+3,16        SET RC=16\n         B     PRINTHEX           PRINT MSG AND ABEND\n         SPACE 1\nNOCHKOUT DS    0H\n         MVC   HDR1(L'NOSYSPM),NOSYSPM  SET UP MSG\n         MVI   IMFLRC+3,40        SET RC=40\n         B     PRINTHEX           PRINT MSG AND ABEND\n         SPACE 1\nBADSYSOP DS    0H\n         MVC   HDR1(L'BADSYSP),BADSYSP  SET UP MSG\n         MVI   IMFLRC+3,40        SET RC=40\n         B     PRINTHEX           PRINT MSG AND ABEND\n         SPACE 1\nPRINTHEX DS    0H\n         BAL   R5,PRINTLNE        PRINT RC MESSAGE\n         B     RETURN9            END FOR NOW....\n         SPACE 1\n         SPACE 1\nPRINTLNE DS    0H\n         PUT   REPORT,HDR1        PRINT RC MESSAGE\n         MVI   HDR1,C' '          CLEAR PRINT LINE\n         MVC   HDR1+1(120),HDR1      ''\n         BR    R5                 RETURN TO CALLER\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\nRETURN9  DS    0H\n         CLOSE (REPORT)           CLOSE SYSPRINT FILE\n         L     R13,SAVE+4\n         L     R15,IMFLRC         PUT RC IN R15\n*        RETURN (14,12),RC=(15)\n         ST    R15,16(0,R13)      PUT RC INTO CALLERS SAVE AREA     RH\n         LM    R14,R12,12(R13)    RELOAD CALLERS REGS\n*              GET INTO PROPER MODE AND GO BACK TO CALLER           RH\n         BSM   0,R14                                                RH\n         SPACE 3\n* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n*        WORK AREAS\n* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\nDUMPTITL DC    C'WORKING STORAGE SECTION'\nSAVE     DC    18F'-1'\nDWORD    DC    D'0'\nSAVEHERE DC    F'0'               ADDRESS AT WHICH TO SAVE DATE\nSAVELTH  DC    F'0'               ADDRESS AT WHICH TO SAVE DATE\nIMFLRC   DC    F'0'\nOFFSET   DC    H'0'\nVARLTH   DC    H'0'               LTH OF VARIABLE\nVARNAME  DC    CL44' '            UP TO 44 BYTE VARIABLE NAME\nSEPCHAR  DC    C' '               SEPARATOR CHARACTER\nFLAG     DC    X'00'\n*        EQU   X'80'              USE OFFSET\n*        EQU   X'40'              FIND VARIABLE\n*        EQU   X'20'              PUT DATE IN PARM\n*\nFMTFLAG  DC    X'00'\nMM1ST    EQU   X'80'              MONTH IS 1ST\nDD1ST    EQU   X'40'              DAY IS 1ST\nYY1ST    EQU   X'20'              YEAR IS FIRST\nYYYYFMT  EQU   X'10'              USE 4 DIGIT YEAR\nADDSEP   EQU   X'08'              PUT SEPARATOR BETWEEN FIELDS\nMM2ND    EQU   X'04'              MM IS IN THE MIDDLE\nCHARMTH  EQU   X'02'              MONTH IS CHARACTER\n*        EQU   X'01'\n*\n*           THE TIME OF DAY IS RETURNED TO THE FIRST TWO WORDS OF\n*           SAVETIME.  THE DATE IS RETURNED TO THE THIRD WORD IN\n*           DECIMAL FORMAT (NOT PACKED DECIMAL)\n*\nSAVETIME DC    XL16'00'           TIME AND DATE\nSAVEDATE DC    XL8'00'            DECIMAL DATE AS MMDDYYYY\n         DC    XL1'00'            JUNK BYTE\n*\nMTHTAB   DS    0C\n         DC    CL3'   '\n         DC    CL3'JAN'\n         DC    CL3'FEB'\n         DC    CL3'MAR'\n         DC    CL3'APR'\n         DC    CL3'MAY'\n         DC    CL3'JUN'\n         DC    CL3'JUL'\n         DC    CL3'AUG'\n         DC    CL3'SEP'\n         DC    CL3'OCT'\n         DC    CL3'NOV'\n         DC    CL3'DEC'\n*\n         SPACE 1\nHDR1     DS    0CL121\n         DC    C'0'\nHDR180   DS    0CL80\n         DC    CL(121-(*-HDR1))'  '\n         SPACE 1\nCONTROL  DC    CL80' '            DATE RECORD\n*\n         SPACE 1\nPARMMSG  DC    C'0 INVALID PARM'\nBADLOCM  DC    C'0 ERROR TRYING TO PUT DATE IN RECORD.'\nBADLLTH  EQU   *-BADLOCM\n*\nNOSYSPM  DC    CL121'0 CANNOT OPEN DATEREC FOR OUTPUT'\nBADSYSP  DC    C'0 DATEREC FILE OPEN FAILED.'\n*\n         LTORG\n*\n         SPACE 3\n* ------ DCB'S                    ------------------------------------\n         SPACE 3\nREPORT   DCB   DSORG=PS,DDNAME=SYSPRINT,MACRF=(PM),LRECL=121,       XXXX\n               EXLST=JFCBADD,RECFM=FBA,BLKSIZE=6292\n         SPACE 1\nDATEREC DCB    DSORG=PS,DDNAME=DATEREC,MACRF=(GM,PM),               XXXX\n               EXLST=JFCBADD,EODAD=RETURN6\n         SPACE 1\n         SPACE 1\nJFCBADD  DS    0F\n         DC    X'87'              JFCB ADDRESS\n         DC    AL3(JFCB)\n         DS    0H                 PUT JFCB ON HALFWORD BOUNDARY\nJFCB     DS    0CL176' '\n         IEFJFCBN  LIST=NO\n         SPACE 1\n         LTORG\n         SPACE 1\n         PRINT NOGEN\n         DCBD  DEVD=DA,DSORG=PS\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   SETDATE\n//LKED.SYSLMOD DD DSN=HALL.LINKLIB,DISP=SHR\n//*KED.SYSLMOD DD DSN=SYS9.IMSUTIL.LOAD,DISP=SHR\n//LKED.SYSIN DD *\n   ENTRY   SETDATE\n   SETCODE AC(0)\n   MODE    AMODE(24) RMODE(ANY)\n   NAME    SETDATE(R)\n\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SETDATEC": {"ttr": 19718, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x14\\x17\\x00\\xdf\\x00\\xdf\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T14:17:00", "lines": 223, "newlines": 223, "modlines": 0, "user": "RH87944"}, "text": "//CALLSETD JOB\n/*ROUTE  PRINT R7\n/*JOBPARM LINES=4\n//STEP2   EXEC IEL1CL, G, CAN ONLY CLG IF NO SYSLMOD OVERRIDE\n//             CLASS='*',\n//             PARML='LIST,LET,MAP',\n//             SLIB='IMSVS.ALE.SOURCE    ',\n//             LKLBDSN='IMSR114.UTIL.OBJECT',\n//             PARMC='MARGINS(2,72,1),GS,NOPT,AG,LIST'\n//*            PARMC='GS,NOPT,AG'\n//SYSIN    DD  *\n /**********************************************************************\n *                                                                     *\n *  AUTHOR:     V. R. HALL      -   HTS  HI-TECH SYSTEMS.              *\n *                                                                     *\n **********************************************************************/\n1/*        MAIN PROGRAM AND PROCESS CONTROL.                         */\n /* %INCLUDE DEBUGCDN;            /*                                */\n CALLSETD:\n      PROCEDURE(TITLE)\n      OPTIONS (MAIN)\n      REORDER;\n-/*         DECLARES ETC.                                            */\n /*      %INCLUDE DEBUG1;         /*                                */\n    DECLARE\n       TITLE\n                       CHARACTER(*) VARYING ;\n    DECLARE\n                               /* DETAILED REPORT FILE              */\n       DETAIL\n /*       BUFFERED                /*                                */\n /*       SEQUENTIAL              /*                                */\n          OUTPUT\n          STREAM\n /*       RECORD                  /*                                */\n          FILE\n          ENVIRONMENT (\n             TOTAL                /*                                */\n             CONSECUTIVE\n             RECSIZE (133)\n             ),\n\n       ON\n                       STATIC\n                       BIT(1)\n                       INITIAL ('1'B),\n       DATE\n                       BUILTIN,\n       ADDR\n                       BUILTIN,\n       UNSPEC\n                       BUILTIN,\n       STRING\n                       BUILTIN,\n       SYSPRINT\n                       FILE,\n\n       REC_PTR\n                       POINTER,\n       I_PTR\n                       POINTER ;\n    DECLARE\n       (\n         I,\n         I2,\n         J\n       )\n                       FIXED BINARY(15,0) ;\n\n    DECLARE\n\n       1 DEL_RECORD\n                       UNALIGNED\n                       CHARACTER(80),\n\n       1 DEL_RECORD2\n                       UNALIGNED  DEFINED DEL_RECORD,\n         3 DEL_KEY     CHARACTER(14),\n         3 DEL_FILL1   CHARACTER(66) ;\n\n\n\n /*\n         SINCE  SETDATE IS A NORMAL ASSEMBLER PROGRAM, IT MUST\n         HAVE THE OPTIONS(ASSEMBLER) PARM.\n  */\n    DCL  SETDATE        EXTERNAL ENTRY(CHAR(16))         /* */\n                        OPTIONS(ASSEMBLER,INTER);\n\n\n    DECLARE\n\n       1 TIMEDAT2,\n           3   FILL1              FIXED BIN INIT (14) ,\n           3   FILL2     CHARACTER(4) INIT('FMT='),\n           3   DATEOUT   CHARACTER(10) INIT('MM/DD/YYYY'),\n\n         TIMEDATE                 BASED (I_PTR)\n                                  CHARACTER(16) ;\n\n /*\n         SINCE  JOBNAME IS A NORMAL ASSEMBLER PROGRAM, IT MUST\n         HAVE THE OPTIONS(ASSEMBLER) PARM.\n */\n    DCL  JOBNAME        EXTERNAL ENTRY\n                        OPTIONS(ASSEMBLER,INTER);\n\n    DECLARE\n\n         1     JOBMSG,\n           3   FILL1              CHAR(5) INIT (' ') ,\n           3   JOBVNAM            CHAR(8) INIT ('JOBNAME'),\n           3   FILL3              CHAR(1) INIT (' '),\n           3   JOBVOL             CHAR(6) INIT ('VOLSER'),\n\n         AUDIT_MSG                DEFINED JOBMSG\n                                  CHARACTER(20) ;\n\n\n    DECLARE\n\n         1     JOBHEAD,\n           3   FILL1              CHAR(8) INIT (' ') ,\n           3   JOB_NUMBER         CHAR(8) INIT('JOBNUMBR') ,\n           3   FILL2              CHAR(10) INIT (', JOBNAME=') ,\n           3   JOB_NAME           CHAR(8) INIT ('JOBNAME');\n\n\n    DECLARE\n\n         1     JOBNBR1,\n           3   JOBNBRA            CHAR(1)  INIT('T'),\n           3   JOBNBRN            PIC '99' INIT(0) ,\n\n               JOBNBR             BASED (I_PTR)\n                                  CHAR(3) ;\n    DECLARE\n      ONCODE   BUILTIN ,\n      ONKEY    BUILTIN ,\n      PLIRETC  BUILTIN ,\n\n       RETCODE\n                       STATIC\n                       FIXED BIN(31,0)\n                       INITIAL (0) ;\n    DECLARE\n       DCL_END\n                       CHARACTER(15)\n                       INIT('END OF DECLARES') ;\n\n1/*    O N   E X E C U T I O N   C O D E .                          */\n\n\n1/*    E X E C U T I O N   C O D E .                                */\n\n\n /*\n  *            LOAD EXTERNAL MODULES\n  *\n  */\n          FETCH JOBNAME ;         /* LOAD JOBNAME                   */\n          FETCH SETDATE ;         /* LOAD SETDATE                   */\n\n\n /*\n               CALL JOBNAME TO GET OUR JOB NAME AND NUMBER\n */\n          CALL JOBNAME(JOB_NAME,JOB_NUMBER);\n\n\n /*\n               CALL SETDATE TO GET DATE\n */\n   /*     TIMEDATE = ' ';         /* SAY GIVE US THE TIME AND DATE  */\n          I_PTR =  ADDR(TIMEDAT2) ;\n          CALL SETDATE(TIMEDATE) ;\n\n\n /*\n               PRINT JOBNAME, DATE AND TIME\n */\n             PUT EDIT ('     ',JOB_NUMBER,', JOBNAME=',JOB_NAME)\n                 (SKIP(5), A(5),  A(8),    A(10),      A(8));\n             PUT         EDIT ('     TODAY''S DATE IS ',DATEOUT)\n                  (SKIP(2),     A,  A);\n\n /*\n               PRINT JOBNAME, DATE AND TIME  IN AUDIT FILE\n */\n                                    /* OPEN DETAIL FILE             */\n /*       OPEN FILE(DETAIL);\n  *\n  *          PUT FILE(DETAIL) EDIT\n  *                   ('     ',JOB_NUMBER,', JOBNAME=',JOB_NAME)\n  *              (SKIP(5), A(5),  A(8),    A(10),      A(8));\n  *          PUT FILE(DETAIL) EDIT\n  *                   ('     ',TIMEDATE)\n  *               (SKIP(2),     A(5),  A(40));\n  */\n\n ENDITALL:\n\n    CALL  PLIRETC(RETCODE);       /* SEND RETURN CODE TO SYSTEM     */\n\n END CALLSETD;\n/*\n//*KED.SYSLMOD DD DSN=SYS9.IMSUTIL.LOAD,DISP=SHR\n//LKED.SYSLMOD DD DSN=HALL.LINKLIB,DISP=SHR\n//LKED.SYSIN DD *\n  SETCODE AC(0)\n  NAME CALLSETD(R)\n/*\n//*\n//*\n//*    DSN=HALL.IMS.JCL(SETDATE)\n//*\n//*\n//STEP5    EXEC PGM=CALLSETD\n//STEPLIB  DD DSN=HALL.LINKLIB,DISP=SHR\n//SYSABEND DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*,DCB=(LRECL=133,RECFM=FB,BLKSIZE=133)\n//*ETAIL   DD SYSOUT=*,DCB=(LRECL=133,RECFM=FB,BLKSIZE=133)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SETDATEJ": {"ttr": 19723, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x14\\x19\\x00b\\x00b\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T14:19:00", "lines": 98, "newlines": 98, "modlines": 0, "user": "RH87944"}, "text": "//SETDATEJ JOB\n/*ROUTE  PRINT R7\n//*\n//*    DSN=CBT.SOURCE(SETDATEJ)\n//*\n//SET1  EXEC PGM=IEBGENER\n//SYSPRINT DD DUMMY\n//*YSPRINT DD SYSOUT=Z\n//SYSUT2 DD DISP=SHR,DSN=HALL.TEST.DATE\n//*       DCB=(RECFM=FB,LRECL=80,BLKSIZE=80,DSORG=PS)\n//SYSIN  DD DUMMY\n//SYSUT1 DD *\nMMDDYYYY DATE HERE IS MMDDYYYY AT POSITION 1\n//*\n//STEP1    EXEC PGM=SETDATE\n//STEPLIB  DD DSN=HALL.LINKLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//DATEREC DD DSN=HALL.TEST.DATE,DISP=SHR\n//*\n//SET2  EXEC PGM=IEBGENER\n//SYSPRINT DD DUMMY\n//SYSUT2 DD DISP=SHR,DSN=HALL.TEST.DATE\n//*       DCB=(RECFM=FB,LRECL=80,BLKSIZE=80,DSORG=PS)\n//SYSIN  DD DUMMY\n//SYSUT1 DD *\nMMDDYY DATE HERE IS AT POS 50                 -->\n//*\n//STEP2    EXEC PGM=SETDATE,PARM='POS=50'\n//STEPLIB  DD DSN=HALL.LINKLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//SYSABEND DD SYSOUT=*\n//DATEREC DD DSN=HALL.TEST.DATE,DISP=SHR\n//*\n//SET3  EXEC PGM=IEBGENER\n//SYSPRINT DD DUMMY\n//SYSUT2 DD DISP=SHR,DSN=HALL.TEST.DATE\n//*       DCB=(RECFM=FB,LRECL=80,BLKSIZE=80,DSORG=PS)\n//SYSIN  DD DUMMY\n//SYSUT1 DD *\nMMDDYY DATE HERE IS AFTER FD=\n//*\n//STEP3    EXEC PGM=SETDATE,PARM='VAR=FD='\n//STEPLIB  DD DSN=HALL.LINKLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//DATEREC DD DSN=HALL.TEST.DATE,DISP=SHR\n//*\n//SET4  EXEC PGM=IEBGENER\n//SYSPRINT DD DUMMY\n//SYSUT2 DD DISP=SHR,DSN=HALL.TEST.DATE\n//*       DCB=(RECFM=FB,LRECL=80,BLKSIZE=80,DSORG=PS)\n//SYSIN  DD DUMMY\n//SYSUT1 DD *\nDATE FORMAT IS MM/DD/YY AFTER FD=\n//*\n//STEP4    EXEC PGM=SETDATE,PARM='VAR=FD=,FMT=MM/DD/YY'\n//STEPLIB  DD DSN=HALL.LINKLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//DATEREC DD DSN=HALL.TEST.DATE,DISP=SHR\n//*\n//SET5  EXEC PGM=IEBGENER\n//SYSPRINT DD DUMMY\n//SYSUT2 DD DISP=SHR,DSN=HALL.TEST.DATE\n//*       DCB=(RECFM=FB,LRECL=80,BLKSIZE=80,DSORG=PS)\n//SYSIN  DD DUMMY\n//SYSUT1 DD *\nDATE FORMAT IS DD-MM-YYYY AFTER FD=\n//*\n//STEP5    EXEC PGM=SETDATE,PARM='VAR=FD=,FMT=DD-MM-YYYY'\n//STEPLIB  DD DSN=HALL.LINKLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//DATEREC DD DSN=HALL.TEST.DATE,DISP=SHR\n//*\n//SET6  EXEC PGM=IEBGENER\n//SYSPRINT DD DUMMY\n//SYSUT2 DD DISP=SHR,DSN=HALL.TEST.DATE\n//*       DCB=(RECFM=FB,LRECL=80,BLKSIZE=80,DSORG=PS)\n//SYSIN  DD DUMMY\n//SYSUT1 DD *\nDATE FORMAT IS DD MM YYYY AFTER FD=\n//*\n//STEP6    EXEC PGM=SETDATE,PARM='VAR=FD=,FMT=DD MM YYYY'\n//STEPLIB  DD DSN=HALL.LINKLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//DATEREC DD DSN=HALL.TEST.DATE,DISP=SHR\n//*\n//SET7  EXEC PGM=IEBGENER\n//SYSPRINT DD DUMMY\n//SYSUT2 DD DISP=SHR,DSN=HALL.TEST.DATE\n//*       DCB=(RECFM=FB,LRECL=80,BLKSIZE=80,DSORG=PS)\n//SYSIN  DD DUMMY\n//SYSUT1 DD *\nDATE FORMAT IS DD MTH YYYY AFTER FD=\n//*\n//STEP7    EXEC PGM=SETDATE,PARM='VAR=FD=,FMT=DD MTH YYYY'\n//STEPLIB  DD DSN=HALL.LINKLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//DATEREC DD DSN=HALL.TEST.DATE,DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SMFEXIT": {"ttr": 19969, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x14 \\x01 \\x01 \\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T14:20:00", "lines": 288, "newlines": 288, "modlines": 0, "user": "RH87944"}, "text": "//SMFEXIT  JOB\n/*ROUTE  PRINT  R115\n//S1        EXEC  HLASMCL,CLASS='*',\n//   COND.LKED=(7,LT,ASM)\n//ASM.SYSLIB DD DSN=SYS1.MACLIB,\n//   DISP=SHR  ,DCB=BLKSIZE=4080\n//   DD DSN=SYS1.HASPSRC,DISP=SHR\n//   DD DSN=SYS1.AMODGEN,DISP=SHR\n//ASM.SYSIN DD  *\n         TITLE '******* USER2 EXIT FOR IFASMFDP ******'\n*\n*        THIS  LITTLE PROGRAM IS  USED TO PRODUCE A READABLE\n*        REPORT BASED ON TYPE 14, 15, 17 AND 18 SMF RECORDS\n*\n         SPACE 3\nSMFEXIT  CSECT\n         USING *,R15              SET TEMP BASE\n         B     AROUND             BRANCH AROUND DUMP TITLE\n         DC    C'SMFEXIT '        PROGRAM NAME\n         DC    C'&SYSDATE'        DATE WRITTEN\n         DC    C'&SYSTIME'        TIME WRITTEN\nAROUND   DS    0H\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         DROP  R15\n         USING SMFEXIT,R12\n         ST    R13,SAVE+4\n         LA    R13,SAVE\n         LR    R3,R1              R3 -> TO PARMS\n         L     R4,0(0,R3)         R4 -> USER PARMS\n         L     R2,8(0,R4)         R2 = 3RD USER PARM\n         LTR   R2,R2              HAVE WE BEEN HERE BEFORE?\n         BNZ   PARMOK             YES, ON WE GO\n         LA    R2,1               R2 = 1\n         ST    R2,8(0,R4)         SET 3RD USER PARM\n         SPACE 1\n         L     R5,4(0,R4)         R5 = R1 AT ENTRY TO IFASMFDP\n         L     R5,0(0,R5)         R5 -> TO ENTRY PARM\n         LH    R2,0(0,R5)         R2 = PARM LTH\n         STH   R2,PARMLTH         SAVE PARM LTH\n         LA    R15,0              R15 = 0\n         LTR   R2,R2              IS THERE A PARM?\n         BZ    NOPARM             NO, GO OPEN REPORT FILE\n         SPACE 1\n         LA    R5,2(0,R5)         R5 -> TO PARM\n         BCTR  R2,0               R2 = HEX LTH\n         EX    R2,SETPARM         MOVE PARM TO PARM FIELD\n         SPACE 1\nNOPARM   DS    0H\n         OPEN  (REPORT,(OUTPUT))  OPEN SYSPRINT FILE\n         PUT   REPORT,HEADING     PRINT HEADING\n         PUT   REPORT,HEADING2    PRINT HEADING 2\n         LA    R15,0              R15 = 0\n         SPACE 1\nPARMOK   DS    0H\n         L     R5,4(0,R3)         R5 -> TO SMF RECORD\n         USING RECDFORM,R5        SET BASE\n*        LA    R6,SMFDSN          R6 -> DSNAME\n*        LA    R6,68(0,R5)        R6 -> DSNAME\n         LH    R2,PARMLTH         R2 = PARM LTH\n         LTR   R2,R2              IS THERE A PARM?\n         BZ    PRINTIT            NO, PRINT ALL OF THEM\n         LA    R6,SMF17DSN        R6 -> TYPE 17/18 DSNAME\n         CLI   RECDID,15          IS IT A 17/18 RECORD?\n         BH    R6SET              YES\n         LA    R6,SMFDSN          R6 -> TYPE 14/15 DSNAME\n         SPACE 1\nR6SET    DS    0H\n         BCTR  R2,0               R2 = HEX LTH\n         LA    R15,4              R15 = 4...DON'T PRINT RECORD\n         EX    R2,CHKNAME         CHECK DSNAME\n*HKNAME  CLC   SMFDSN(0),PARMDATA CHECK DSNAME\n*HKNAME  CLC   0(0,R6),PARMDATA   CHECK DSNAME\n         BNE   NOMORE4            NOT OURS, EXIT\n         SPACE 1\nPRINTIT  DS    0H\n         MVC   PACCESS,=C'READ '  DEFAULT ACCESS IS READ\n         CLI   RECDID,14          IS IT A READ RECORD?\n         BE    ACCESSOK           YES\n         MVC   PACCESS,=C'WRITE'  ACCESS IS WRITE\n         CLI   RECDID,15          IS IT A WRITE RECORD?\n         BE    ACCESSOK           YES\n         MVC   PACCESS,=C'DELET'  ACCESS IS DELETE\n         CLI   RECDID,17          IS IT A DELETE RECORD?\n         BE    ACCESSOK           YES\n         MVC   PACCESS,=C'RENAM'  ACCESS IS RENAME\n         CLI   RECDID,18          IS IT A RENAME RECORD?\n         BNE   NOMORE4            NO, END OF EXIT\n         SPACE 1\nACCESSOK DS    0H\n         ICM   R9,15,RSTPTIME     PUT TIME IN WORK REG\n         SR    R8,R8              CLEAR R8\n         LA    R7,100             PUT DIVISOR IN R7\n         DR    R8,R7              DIVIDE TIME BY 100 TO GET SECONDS\n         ST    R9,SECS            SAVE SECONDS\n         SR    R8,R8              CLEAR R8\n         LA    R7,60              R7 = 60\n         DR    R8,R7              DIVIDE SECS TO GET MINUTES\n         ST    R9,MINS            SAVE MINUTES\n         SR    R8,R8              CLEAR R8\n         DR    R8,R7              DIVIDE MINS BY 60 TO GET HOURS\n         ST    R9,HOURS           SAVE HOURS\n         MR    R8,R7              R9 = HOURS IN MINS\n         L     R8,MINS            R8 = MINUTES\n         SR    R8,R9              R8 = MINUTES LEFT\n         ST    R8,MINS            SAVE THEM\n         LR    R9,R8              R9 = MINUTES\n         SR    R8,R8              CLEAR R8\n         MR    R8,R7              R9 = MINUTES IN SECONDS\n         L     R8,SECS            R8 = SECONDS\n         SR    R8,R9              R8 = SECONDS LEFT\n         ST    R8,SECS            SAVE THEM\n         CVD   R8,DOUBLE          CONVERT SECONDS TO DECIMAL\n         MVC   DOUBLE(4),TIMEPTRN PUT IN EDIT MASK\n         ED    DOUBLE(4),DOUBLE+6 EDIT SECONDS\n         MVC   SS,DOUBLE+2        SAVE SECONDS\n         SPACE 1\n         L     R8,MINS            R8 = MINUTES\n         CVD   R8,DOUBLE          CONVERT MINUTES TO DECIMAL\n         MVC   DOUBLE(4),TIMEPTRN PUT IN EDIT MASK\n         ED    DOUBLE(4),DOUBLE+6 EDIT MINUTES\n         MVC   MM,DOUBLE+2        SAVE MINUTES\n         SPACE 1\n         L     R8,HOURS           R8 = HOURS\n         CVD   R8,DOUBLE          CONVERT HOURS TO DECIMAL\n         MVC   DOUBLE(4),TIMEPTRN PUT IN EDIT MASK\n         ED    DOUBLE(4),DOUBLE+6 EDIT HOURS\n         MVC   HH,DOUBLE+2        SAVE HOURS\n         SPACE 1\n         MVC   PTIME,HHMMSS       PUT TIME IN OUTPUT RECORD\n         SPACE 1\n         UNPK  PDATE(5),RSTPDATE+1(3) CONVERT DATE TO DISPLAY\n         MVZ   PDATE+4(1),PDATE+3 FIX ZONE ON LOW BYTE\n         SPACE 1\n         MVC   PSYSTEM,RCPUID     PUT SYSTEM ID IN RECORD\n         MVC   PJOBNAME,RJOBNAME  PUT JOBNAME IN RECORD\n*        MVC   PUSERID,SMF14UID   PUT USERID IN RECORD\n         CLI   RECDID,15          IS IT A READ/WRITE RECORD?\n         BH    TYPE17             NO\n         SPACE 1\nTYPE1415 DS    0H\n         MVC   PDDNAME,SMFDDN     PUT DDNAME IN RECORD\n         MVC   PDSNAME,SMFDSN     PUT DSNAME IN RECORD\n*        MVC   PRINTDAT,9(R5)     PUT PART OF SMF REC IN PRINT\n         B     WRITEIT            GO PRINT IT\n         SPACE 1\nTYPE17   DS    0H\n         CLI   RECDID,17          IS IT A SCRATCH RECORD?\n         BH    TYPE18             NO, MUST BE RENAME\n         MVC   PDSNAME,SMF17DSN   PUT DSNAME IN RECORD\n         B     WRITEIT            GO PRINT IT\n         SPACE 1\nTYPE18   DS    0H\n         MVC   PDSNAME,SMF18DSN   PUT NEW DSNAME IN RECORD\n*        B     WRITEIT            GO PRINT IT\n         SPACE 1\nWRITEIT  DS    0H\n         CLC   PDSNAME,SAVEDSN    SAME DSNAME ?\n         BE    WRITE2             YES, CLEAR PRINT DSNAME\n         MVC   SAVEDSN,PDSNAME    NO, SAVE NEW DSNAME\n         B     WRITE3             PRINT RECORD\n         SPACE 1\nWRITE2   DS    0H\n         MVI   PDSNAME,C' '       CLEAR PRINT DSNAME\n         MVC   PDSNAME+1(43),PDSNAME   ''\n         SPACE 1\nWRITE3   DS    0H\n         PUT   REPORT,PRINTREC    PRINT PART OF RECORD\n         MVI   PACCESS,C' '       CLEAR PRINT REC\n         MVC   PACCESS+1(131),PACCESS   ''\n         SLR   R15,R15            RC = 0\n         SPACE 1\nNOMORE4  DS    0H\n*        CLOSE (REPORT)\n         L     R13,SAVE+4         R13 -> IFASMFDP REGS\n         ST    R15,16(0,R13)      SAVE RC\n         LM    R14,R12,12(R13)    RELOAD REGS\n         BR    R14                RETURN\n         SPACE 1\n*HKNAME  CLC   SMFDSN(0),PARMDATA CHECK DSNAME\nCHKNAME  CLC   0(0,R6),PARMDATA   CHECK DSNAME\nSETPARM  MVC   PARMDATA(0),0(R5)  SET UP ATTACH PROGRAM PARM\n         SPACE 1\n         SPACE 3\n* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n*        WORK AREAS\n* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\nDUMPTITL DC    C'WORKING STORAGE SECTION'\nSAVE     DC    18F'-1'\nDOUBLE   DC    D'0'\nHOURS    DC    F'0'\nMINS     DC    F'0'\nSECS     DC    F'0'\nCPKECB   DC    F'0'\nATTTCB   DC    F'0'\nTIMEPTRN DC    X'402120204B20204B2020'\nHHMMSS   DS    0CL8\nHH       DS    CL2\nHHDOT    DC    C'.'\nMM       DS    CL2\nMMDOT    DC    C'.'\nSS       DS    CL2\n         DS    CL3\nATTANAME DC    CL8' '\nATTAPARM DS    0H\nPARMLTH  DC    H'0'\nPARMDATA DC    CL100' '\nSAVEDSN  DC    CL44' '\nHEADING  DS    0CL133\nHEADCTL  DC    C'0'               PRINT SPACE 2\n*EAD1    DC    C'ACCESS TIME     DATE  SYSTEM JOBNAME  USERID   '\nHEAD1    DC    C'ACCESS TIME     DATE  SYSTEM JOBNAME  '\n         DC    C'DDNAME   DSNAME'\n         DC    CL(132-(*-HEAD1))'  '\nHEADING2 DS    0CL133\nHEADCTL2 DC    C'+'               PRINT NO SPACE\nHEAD2    DC    C'______ ____     ____  ______ _______  '\n         DC    C'______   ______'\n         DC    CL(132-(*-HEAD2))'  '\nPRINTREC DS    0CL133\nPRINTCTL DC    C' '\nPACCESS  DC    CL5' '\n         DC    CL2' '\nPTIME    DC    CL8' '\n         DC    CL1' '\nPDATE    DC    CL5' '\n         DC    CL1' '\nPSYSTEM  DC    CL4' '\n         DC    CL3' '\nPJOBNAME DC    CL8' '\n         DC    CL1' '\n*USERID  DC    CL8' '\n*        DC    CL1' '\nPDDNAME  DC    CL8' '\n         DC    CL1' '\nPDSNAME  DC    CL44' '\n         DC    CL1' '\n         DC    CL(132-(*-PACCESS))' '\n         SPACE 1\n* ------ DCB'S                    ------------------------------------\n         SPACE 3\nREPORT   DCB   DSORG=PS,DDNAME=REPORT,LRECL=133,RECFM=FBA,          XXXX\n               MACRF=(PM),BLKSIZE=133\n         SPACE 1\n         LTORG\n         SPACE 1\nRECDFORM DSECT                          RECORD\nRLNGTH   DS    F                  0     LENGTH\nRCONT    DS    C                  4     CONT\nRECDID   DS    C                  5     ID\nRSTPTIME DS    CL4                6     STEP TIME\nRSTPDATE DS    CL4                10    STEP DATE\nRCPUID   DS    CL4                14    CPU ID\nRJOBNAME DS    CL8                18    JOB NAME\n         DS    CL8                26    SPACING\nSMF14UID DS    CL8                34    USER ID\n         DS    CL2                42    SPACING\nSMF17DSN EQU   *                  44    DSNAME FOR TYPE 17/18\n         DS    CL12               44    SPACING\nSMFDDN   DS    CL8                56    DDNAME\n         DS    CL4                64    SPACING\nSMFDSN   DS    CL44               68    DSNAME\nSMF18DSN EQU   *+24               88    NEW DSNAME FOR TYPE 18\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   SMFEXIT\n//*KED.SYSLMOD DD DSN=SYS9.IMSUTIL.LOAD,DISP=SHR\n//LKED.SYSLMOD DD DSN=HALL.LINKLIB,DISP=SHR\n//LKED.SYSIN DD *\n  SETCODE AC(0)\n  NAME SMFEXIT(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SUBEDIT": {"ttr": 19975, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x14V\\x00\\xe8\\x00\\xe8\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T14:56:00", "lines": 232, "newlines": 232, "modlines": 0, "user": "RH87944"}, "text": "//SUBEDIT  JOB\n/*ROUTE  PRINT  R7\n//*\n//JES    OUTPUT JESDS=ALL,PAGEDEF=P1E100,FORMDEF=P1E000\n//*UT1   OUTPUT DEFAULT=YES,COPIES=1,FORMS=X3NA,CLASS=1,\n//OUT1   OUTPUT DEFAULT=NO,COPIES=1,CLASS='*',       LANDSCAPE 67X138\n//             PAGEDEF=L1C100,FORMDEF=L1C000\n//OUT2   OUTPUT DEFAULT=NO,COPIES=1,CLASS='*',       PORTRAIT 88X96\n//             PAGEDEF=P1E100,FORMDEF=P1E000\n//*\n//*\n//*       DSN=CBT.SOURCE(SUBEDIT)\n//*       WILL  SUBMIT ANY 1-126 BYTE COMMAND FROM PARM= OR  //SYSIN\n//*\n//*      IF INPUT IS VIA //SYSIN, A WAIT=NNN COMMAND CAN BE\n//*      USED TO WAIT UP TO 999 (10 SECONDS) TIMER UNITS BETWEEN\n//*      EACH SYSTEM COMMAND. A WAIT COMMAND WILL BE IN EFFECT UNTIL\n//*      ANOTHER WAIT= COMMAND IS FOUND.\n//*\n//S1        EXEC  HLASMCL,CLASS='*',\n//   COND.LKED=(7,LT,ASM)\n//ASM.SYSPRINT  DD SYSOUT=(,),OUTPUT=*.OUT2\n//ASM.SYSIN DD  *\n         TITLE '*** PROGRAM TO SUBMIT SYSTEM COMMAND WITH SVC 34 ***'\n*\n*              THIS LITTLE PROGRAM IS USED TO RUN THE CMD PASSED\n*              TO IT AS A SYSTEM  COMMAND, USING SVC 34\n*\n         SPACE 3\nSUBEDIT  CSECT\n         USING *,R15              SET TEMP BASE\n         B     AROUND             BRANCH AROUND DUMP TITLE\n         DC    C'SUBEDIT '        PROGRAM NAME\n         DC    C'&SYSDATE'        DATE WRITTEN\n         DC    C'&SYSTIME'        TIME WRITTEN\nAROUND   DS    0H\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         DROP  R15\n         USING SUBEDIT,R12\n         ST    R13,SAVE+4\n         LA    R13,SAVE\n         L     R1,0(0,R1)         R1 -> TO PARMS\n         LH    R2,0(0,R1)         R2 = PARM LTH\n         LTR   R2,R2              IS THERE A PARM ?\n         BZ    NOPARM             NO, LOOK FOR SYSIN\n         CH    R2,MAXCMDL         IS PARM TOO LONG ?\n         BNH   PARMOK             NO, ON WE GO\n         ST    R2,RETCODE         SAVE LTH AS RC\n         B     NOMORE4            RETURN WITH RC>0\n         SPACE 1\nPARMOK   DS    0H\n         B     COMEND             GO SEND COMMAND\n         SPACE 1\nNOPARM   DS    0H\n         OPEN  (SYSIN,(INPUT))    OPEN INPUT DCB\n*\n         LA    R6,SYSIN           R6 -> TO DCB\n         USING IHADCB,R6\n         TM    DCBOFLGS,DCBOFOPN  TEST IF OPEN\n         BZ    NOSYSIN            NO\n         MVC   CMDLRECL,DCBLRECL  SAVE SYSIN LRECL\n         CLC   CMDLRECL,MAXCMDL   OVER MAX CMD LTH?\n         BNH   READSYS            NO, IT'S OKAY\n         MVC   CMDLRECL,MAXCMDL   YES, USE MAX LTH ONLY\n         DROP  R6\n*\nREADSYS  DS    0H\n         GET   SYSIN,MBRNAME           GET INPUT RECORD\n         LA    R4,MBRNAME         R4 -> AT INPUT\n         CLC   =C'WAIT=',0(R4)    IS IT THE 'WAIT=' PARM?\n         BNE   READSYS0           NO, GO SET UP COMMAND\n         SPACE 1\n         LA    R4,5(0,R4)         R4 -> TO WAIT= PARM, IF ANY\n         SPACE 1\n         LR    R15,R4             R15 -> WAIT PARM TOO\n         LA    R14,0              R14 = 0\n         SPACE 1\nPARM5B   DS    0H\n         CLI   0(R15),C'0'        IS BYTE NUMERIC?\n         BL    READSYS            NO, IGNORE PARM\n         LA    R15,1(0,R15)       R15 -> TO NEXT PARM BYTE\n         LA    R14,1(0,R14)       R14 = NBR OF CHARS\n         CLI   0(R15),C' '        AT END OF WAIT TIME?\n         BNE   PARM5B             NO, LOOK AGAIN\n         SPACE 1\nPARM5C   DS    0H\n         CH    R14,=H'4'          TOO MANY CHARS?\n         BL    PARM5D             NO, IT'S OKAY\n         LA    R14,3              YES, SET R14 TO 3\n         SPACE 1\nPARM5D   DS    0H\n         BCTR  R14,0              R14 = HEX LTH\n         EX    R14,PARM5EX        PACK WAIT TIME\n         CVB   R15,DWORD          R15 = SECONDS TO WAIT\n*        MH    R15,MULTSEC        CONVERT TO TIMER UNITS\n         ST    R15,WAITTIME       SAVE IT FOR STIMER\n         B     READSYS            GO GET NEXT COMMAND\n         SPACE 1\nPARM5EX  PACK  DWORD+6(2),0(0,R4) USE 1ST 2 BYTES ONLY\n         SPACE 1\nREADSYS0 DS    0H\n         CLI   MBRNAME,C'*'       A COMMENT?\n         BE    READSYS            YES, GET NEXT INPUT RECORD\n         LA    R1,MBRNAME-1       R1 -> TO INPUT DATA-1\n         SPACE 1\nREADSYS1 DS    0H\n         LR    R2,R1              R2 -> TO INPUT DATA-1\n         AH    R2,CMDLRECL        R2 -> TO END OF INPUT DATA\n         CLI   0(R2),C' '         LAST CHAR BLANK?\n         BE    READSYS2           YES, NO LINE NUMBER\n         SH    R2,=H'8'           NO, DROP LINE NBR FROM END...\n         SPACE 1\nREADSYS2 DS    0H\n         CR    R2,R1              R2 -> TO INPUT DATA-1 ?\n         BE    READSYS            YES, RECORD IS BLANK\n         CLI   0(R2),C' '         END OF MODULE NAME?\n         BNE   READSYS3           YES\n         BCT   R2,READSYS2        NO, R2 -> AT PREV CHAR\n         SPACE 1\nREADSYS3 DS    0H\n         SR    R2,R1              R2 = MODULE NAME LTH\n         CH    R2,MAXCMDL         IS PARM TOO LONG ?\n         BNH   READSYS4           NO, ON WE GO\n         ST    R2,RETCODE         SAVE LTH AS RC\n*        B     NOMORE4            RETURN WITH RC>0\n         B     BADINPUT           THEN ERROR\n*\nREADSYS4 DS    0H\n         BCTR  R1,0               SET UP R1 FOR EX SETMOVE LATER...\n         B     COMEND             GO DO COMMAND\n         SPACE 1\nBADINPUT DS    0H\n*        MVC   PSTYPE+9(L'INPMSG),INPMSG PUT ERROR MSG IN PRINT\n*        B     BADPARM2           THEN ERROR\n*INPMSG  DC    C'SYSIN DATA OVER 126 BYTES'\n         SPACE 1\nEOFREAD  DS    0H\n         CLOSE (SYSIN)            CLOSE INPUT DCB\n         B     NOMORE4            RETURN WITH RC>0\n         SPACE 1\n*\n*        COMMON EXIT  -  SHIP COMMAND AND RETURN\n*\nCOMEND   DS    0H\n         BCTR  R2,0               R2 = HEX LTH\n         EX    R2,SETPARM         SET UP COMMAND FOR SVC 34\n         LA    R2,5(0,R2)         R2 = LTH OF CMD + 4\n         STH   R2,CSWACMDL        INSERT COMMAND LENGTH\n         SPACE 2\n         MODESET KEY=ZERO          GET INTO PRIVILEGED STATE\n         SLR   R0,R0               INDICATE SYSTEM ROUTINE\n         SLR   R15,R15             INDICATE SYSTEM COMMAND\n         LA    R1,CSWACMD          LOAD COMMAND ADDRESS\n         SVC   34                  ISSUE COMMAND\n         MODESET KEY=NZERO         BACK INTO NORMAL STATE\n         SPACE 1\n         MVI   CSWACMDT,C' '      CLEAR COMMAND ARE\n         MVC   CSWACMDT+1(125),CSWACMDT\n         TM    SYSIN+48,X'10'     IS SYSIN OPEN ?\n         BZ    NOMORE4            NO, END OF SUBEDIT\n         ICM   R15,15,WAITTIME    R15 = WAIT TIME\n         BZ    NOWAIT             NONE, DON'T WAIT\n         STIMER WAIT,BINTVL=WAITTIME   WAIT A BIT\n         SPACE 1\nNOWAIT   DS    0H\n         B     READSYS            GO GET NEXT COMMAND\n*\nNOSYSIN  DS    0H\n         SPACE 1\nNOMORE4  DS    0H\n         L     R13,SAVE+4\n         L     R15,RETCODE        R15 = RETURN CODE\n         ST    R15,16(0,R13)      PASS IT TO CALLER\n         LM    R14,R12,12(R13)\n         BR    R14\n         SPACE 1\nSETPARM  MVC   CSWACMDT(0),2(R1)  SET UP COMMAND\n         SPACE 3\n* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n*        WORK AREAS\n* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\nDUMPTITL DC    C'WORKING STORAGE SECTION'\nDWORD    DC    D'0'\nSAVE     DC    18F'-1'\nRETCODE  DC    F'0'               RETURN CODE\nCMDLRECL DC    H'80'              ASSUME SYSIN IS LRECL 80\nMAXCMDL  DC    H'126'             MAX COMMAND LENGTH\nMBRNAME  DC    CL126' '           READ AREA FOR GET AT READSYS\n*\n*        COMMAND CONSTRUCTION AREA\n*\nCSWACMD  DS    0F                  BEGIN COMMAND\nCSWACMDL DC    H'126'              COMMAND LENGTH\n         DC    H'0'                NOT USED\nCSWACMDT DC    CL126' '            COMMAND TEXT AREA\n         SPACE 1\nWAITTIME DC    F'0000'            WAIT FOR 0 SECONDS\nMULTSEC  DC    H'100'             MULTIPLIER FACTOR TO GET TIMER UNITS\n         SPACE 1\n         LTORG\n*\nSYSIN    DCB   DSORG=PS,MACRF=(GM),EODAD=EOFREAD,   LRECL=126,         +\n               DDNAME=SYSIN\nSYSINL   EQU   *-SYSIN\n*\n         PRINT NOGEN\n         DCBD  DEVD=DA,DSORG=PS\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   SUBEDIT\n//LKED.SYSLMOD DD DSN=IMSVS.AUTHLIB1,DISP=SHR\n//LKED.SYSIN DD *\n  SETCODE AC(1)\n  NAME SUBEDIT(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SUBEDITJ": {"ttr": 19980, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03?\\x00\\x99\\x03?\\x14\"\\x00\\x16\\x00\\x16\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-02T00:00:00", "modifydate": "1999-02-02T14:22:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "RH87944"}, "text": "//SUBEDIT\n//*\n//*\n//STEP1     EXEC PGM=SUBEDIT,\n//    PARM=('$D''SUBEDIT''')\n//STEPLIB   DD   DSN=IMSVS.AUTHLIB1,DISP=SHR\n//*\n//STEP2     EXEC PGM=SUBEDIT\n//STEPLIB   DD   DSN=IMSVS.AUTHLIB1,DISP=SHR\n//SYSIN     DD *\n* THIS IS A COMMENT CARD\n$D'SUBEDIT'\n* THE NEXT CARD IS A BLANK CARD...\n\n$D'SUBEDIT'\n/*\n//*\n//STEP3     EXEC PGM=SUBEDIT\n//STEPLIB   DD   DSN=IMSVS.AUTHLIB1,DISP=SHR\n//SYSIN     DD DISP=SHR,DSN=HALL.TESTSUB\n//*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SVLNK": {"ttr": 20225, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x00\\x9f\\x00\\x99\\x00\\x9f\\x13\\x00\\x00e\\x00e\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-01-09T00:00:00", "modifydate": "1999-01-09T13:00:00", "lines": 101, "newlines": 101, "modlines": 0, "user": "RH87944"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "SYSIN": {"ttr": 20228, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x00\\x9f\\x00\\x99\\x00\\x9f\\x115\\x00\\x02\\x00\\x02\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-01-09T00:00:00", "modifydate": "1999-01-09T11:35:00", "lines": 2, "newlines": 2, "modlines": 0, "user": "RH87944"}, "text": "CSVEXFP CSVEXFP\nUSING 000000 000B28 C P 000022\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TAPECOPJ": {"ttr": 20230, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03?\\x00\\x99\\x03?\\x14\\x19\\x00<\\x00<\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-02T00:00:00", "modifydate": "1999-02-02T14:19:00", "lines": 60, "newlines": 60, "modlines": 0, "user": "RH87944"}, "text": "//TAPEDEBE JOB\n//*\n//*  USE IEBGENER TO CREATE A MULTI-FILE TAPE...\n//*\n//STEP1 EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=*\n//SYSUT1 DD *\nLINE 1\n/*\n//SYSUT2 DD DSN=HALL.TESTTAPE,UNIT=TAPE,DISP=(,KEEP),\n//   LABEL=(RETPD=0),\n//   VOL=(,RETAIN),\n//   DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)\n//SYSIN  DD DUMMY\n/*\n//STEP1 EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=*\n//SYSUT1 DD *\nLINE 1\nLINE 2\n/*\n//SYSUT2 DD DSN=HALL.TESTTPE2,UNIT=TAPE,DISP=(,KEEP),\n//   LABEL=(2,SL,RETPD=0),\n//   VOL=REF=*.STEP1.SYSUT2,\n//   DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)\n//SYSIN  DD DUMMY\n//*\n//*  COPY THE MULTI-FILE TAPE WITH TAPECOPY\n//*\n//STEP2 EXEC PGM=TAPECOPY,PARM='DUMP,TEST,HEX,PRINT=ALL'\n//STEPLIB DD DSN=HALL.LINKLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//SYSABEND DD SYSOUT=*\n//MASTER DD DISP=(OLD,PASS),UNIT=TAPE,\n//   DSN=HALL.TESTTAPE,VOL=REF=*.STEP1.SYSUT2\n//TAPE1  DD DSN=HALL.TAPE,UNIT=TAPE,DISP=(,KEEP),\n//   LABEL=(RETPD=0),\n//   VOL=(,RETAIN),\n//   DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)\n//*\n//STEP3 EXEC PGM=TAPECOPY,PARM='DUMP,TEST,HEX,PRINT=ALL'\n//STEPLIB DD DSN=HALL.LINKLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//SYSABEND DD SYSOUT=*\n//MASTER DD DISP=(OLD,PASS),UNIT=TAPE,\n//   DSN=HALL.TESTTAPE,VOL=REF=*.STEP1.SYSUT2\n//TAPE1  DD DSN=HALL.TAPE,UNIT=TAPE,DISP=(,KEEP),\n//   LABEL=(3,SL,RETPD=0),\n//   VOL=(,RETAIN,REF=*.STEP2.TAPE1),\n//   DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)\n//*\n//*  DUMP THE MULTI-FILE TAPE WITH TAPECOPY\n//*\n//STEP4 EXEC PGM=TAPECOP1,PARM='DEBE,TEST,HEX,PRINT=ALL' IGNOREOF'\n//STEPLIB DD DSN=HALL.LINKLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//SYSABEND DD SYSOUT=*\n//MASTER DD DISP=(OLD,PASS),UNIT=TAPE,\n//   DSN=HALL.TESTTAPE,VOL=REF=*.STEP2.TAPE1\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TAPECOPY": {"ttr": 20232, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03?\\x00\\x99\\x03?\\x13W\\x0b\\xbe\\x0b\\xbe\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-02T00:00:00", "modifydate": "1999-02-02T13:57:00", "lines": 3006, "newlines": 3006, "modlines": 0, "user": "RH87944"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "VSPLIT": {"ttr": 21507, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x14$\\x07\\xd2\\x07\\xd2\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T14:24:00", "lines": 2002, "newlines": 2002, "modlines": 0, "user": "RH87944"}, "text": "//VSPLIT   JOB\n/*ROUTE  PRINT R7\n//STEP1 EXEC PGM=IEBGENER,REGION=50K\n//SYSPRINT DD SYSOUT=A\n//SYSIN DD DUMMY\n//SYSUT2 DD DSN=&&T(SDP10),UNIT=SYSDA,DISP=(,PASS),SPACE=(TRK,(5,1,5)),\n//  DCB=(RECFM=FB,LRECL=80,BLKSIZE=9440),VOL=SER=WORK01\n//SYSUT1 DD *\nSTART1   DC    F'0'                     CONTROL FIELD 1\nLENGTH1  DC    F'0'                     *\nTYPE1    DC    C'A'                     *\nSTART2   DC    F'0'                     CONTROL FIELD 2\nLENGTH2  DC    F'0'                     *\nTYPE2    DC    C'A'                     *\nSTART3   DC    F'0'                     CONTROL FIELD 3\nLENGTH3  DC    F'0'                     *\nTYPE3    DC    C'A'                     *\nSTART4   DC    F'0'                     CONTROL FIELD 4\nLENGTH4  DC    F'0'                     *\nTYPE4    DC    C'A'                     *\nSTART5   DC    F'0'                     CONTROL FIELD 5\nLENGTH5  DC    F'0'                     *\nTYPE5    DC    C'A'                     *\n         SPACE\nOPENFLGS DC    BL1'0'                   OPEN FLAGS\nSTRTPOS  DC    C' '                START POSITION\n*        DC    C' '                START AT DATA, NOT RDW\n*        DC    C'R'                START AT RDW, POS 1 IN DECIMAL\n*        DC    C'H'                START AT RDW, POS 0 IN HEX\nOUT1CTR  DC    F'0'                     OUT1 COUNTER\nOUT2CTR  DC    F'0'                     OUT2 COUNTER\nOUT3CTR  DC    F'0'                     OUT3 COUNTER\nOUT4CTR  DC    F'0'                     OUT4 COUNTER\nOUT5CTR  DC    F'0'                     OUT5 COUNTER\nOUT6CTR  DC    F'0'                     OUT6 COUNTER\nOUT7CTR  DC    F'0'                     OUT7 COUNTER\nHEAD1    DC    CL74'RECORDS SPLIT TO OUT1'\nHEAD2    DC    CL74'RECORDS SPLIT TO OUT2'\nHEAD3    DC    CL74'RECORDS SPLIT TO OUT3'\n//STEP2 EXEC PGM=IEBGENER,REGION=50K\n//SYSPRINT DD SYSOUT=A\n//SYSIN DD DUMMY\n//SYSUT2 DD DSN=&&T(SDP20),UNIT=SYSDA,DISP=(SHR,PASS)\n//SYSUT1 DD *\n         DC    F'0'                     SELECT 1\n         DC    X'80'                    CF1\n         DC    111X'FF'                 *\n         DC    F'12'                    CF2 CONTROL TABLE DISPLACEMENT\n         DC    X'80'                    *   COMPARE CODE\n         DC    111X'FF'                 *   SEARCH VALUE\n         DC    F'24'                    CF3\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'36'                    CF4\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'48'                    CF5\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         SPACE\n         DC    F'0'                     SELECT 2\n         DC    X'80'                    CF1\n         DC    111X'FF'                 *\n         DC    F'12'                    CF2\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'24'                    CF3\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'36'                    CF4\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'48'                    CF5\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         SPACE\n         DC    F'0'                     SELECT 3\n         DC    X'80'                    CF1\n         DC    111X'FF'                 *\n         DC    F'12'                    CF2\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'24'                    CF3\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'36'                    CF4\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'48'                    CF5\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         SPACE\n*                                       SELECT 4\n         DC    F'0'                     CF1\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'12'                    CF2\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'24'                    CF3\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'36'                    CF4\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'48'                    CF5\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         SPACE\n*                                       SELECT 5\n         DC    F'0'                     CF1\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'12'                    CF2\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'24'                    CF3\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'36'                    CF4\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n         DC    F'48'                    CF5\n         DC    X'80'                    *\n         DC    111X'FF'                 *\n//STEP3 EXEC HLASMC,PARMC='XREF(FULL)'\n//ASM.SYSLIB DD\n//          DD\n//    DD DSN=&&T,DISP=(SHR,PASS)\n//SYSIN DD *\n**********************************************************************\n*\n*        MODIFICATIONS:\n*        JULY 03, 1996...ADDED COMMENT CHECK IN INPUT VERIFY\n*                        ROUTINE. COMMENTS CAN START WITH * OR /.\n*\n*        JUNE 24, 1996...ADDED START=HEX PARM THAT SAYS START AT\n*                        OFFSET 0 AND USE HEXADECIMAL START POSITION\n*                        NOTE...START=HEX MUST BE FIRST CONTROL CARD\n*\n**********************************************************************\n*\n*                    VSPLIT\n*\n*VSPLIT CAN BE USED TO SPLIT RECORDS FROM A VARIABLE LENGTH FILE\n*TO A SYSOUT FILE OR TO ANOTHER VARIABLE LENGTH FILE.\n*VSPLIT CAN ALSO BE USED TO CREATE A FIXED LENGTH FILE FROM A\n*VARIABLE LENGTH FILE.\n*\n*                    JCL\n*\n*TO EXECUTE VSPLIT THE FOLLOWING JCL IS REQUIRED:\n*\n*//   JOBCARD\n*//STEPNAME   EXEC PGM=VSPLIT,REGION=60K\n*//STEPLIB    DD   DSN=SYS1.USERLIB2,DISP=SHR\n*//SYSPRINT   DD   SYSOUT=A\n*//TAPEIN     DD   DSN=....ETC.\n*//OUT1\n*//OUT7\n*//SYSIN      DD  *\n*CONTROL CARDS\n*//\n*\n*THE OUT1 TO OUT7 DD CARDS ARE:\n*//OUT1       DD  SYSOUT=A\n*//OUT2       DD  SYSOUT=A\n*//OUT3       DD  SYSOUT=A\n*//OUT4       DD  DSN=, UNIT=, DISP=, SPACE=, DCB=\n*//OUT5       DD  ''\n*//OUT6       DD  ''\n*//OUT7       DD  ''\n*\n*FOR OUT4, OUT5, OUT6:\n*DSN= ANY NAME UP TO 44 CHARACTERS LONG CONSISTING OF\n*     1-8 CHARS.1-8 CHARS.ETC\n*UNIT= TAPE FOR TAPE\n*      USER  FOR PERMANENT DISK FILES\n*      SYSDA   FOR TEMPORARY FILES\n*DISP= (,CATLG) FOR PERMANENT FILES\n*      (,PASS)  FOR TEMPORARY FILES\n*SPACE= IS REQUIRED ONLY IF UNIT=SYSDA OR USER\n*      (TRK,(NBR OF TRKS,3),RLSE)\n*      NBR OF TRKS DEPENDS ON THE NUMBER OF RECORDS BEING SPLIT.\n*      IF BLKSIZE=3532, THERE WILL BE 5 BLOCKS PER TRACK ON A\n*      3350, SO 100 BLOCKS WOULD NEED 20 TRACKS.\n*DCB=  (LRECL=REC LEN+4,BLKSIZE=(REC LEN+4)*BLK FACTOR)+4)\n*      EG- IF REC LEN = 1760 AND BLK FACTOR = 2,\n*      LRECL=1764,BLKSIZE=3532\n*      IF RECFM IS LEFT OFF OUT4 - OUT6 DCB'S, IT WILL\n*      DEFAULT TO THE RECFM OF THE INPUT FILE.\n*\n*FOR OUT7:\n*DCB=  (RECFM=FB,LRECL=REC LEN,BLKSIZE=REC LEN*BLK FACTOR)\n*      THE VB FILE IS REBLOCKED TO THE REC LEN SPECIFIED IN\n*      THE LRECL=. IF THE FB LRECL IS LARGER THAN THE VB LRECL,\n*      THE FB RECORD IS PADDED WITH BLANKS.\n*\n*\n*                    CONTROL CARDS\n*\n*VSPLIT IS CONTROLLED BY THE FOLLOWING CONTROL CARDS:\n*INPUT=TAPEIN,CONTROL=(CF1 CONTROL DATA,....CF5 CONTROL DATA)\n*OUTPUT=OUT1,OUT2,.....OUT7\n*START=HEX\n*START=RDW\n*SELECT=OUT1,CF1=\n*HEAD1=\n*HEAD2=\n*HEAD3=\n*\n*THE INPUT= STATEMENT IS USED TO SET UP THE SELECTION CRITERIA\n*FOR THE 1 TO 5 CONTROL FIELDS.\n*\n*THE OUTPUT= STATEMENT DETERMINES WHICH OF THE 7 OUTPUT\n*FILES WILL BE USED.\n*\n*THE START=HEX STATEMENT INDICATES THAT THE SEARCH STARTS\n*              AT OFFSET 0(THE RECORD LENGTH FIELD) AND THAT\n*              THE START POSITION IS IN HEXADECIMAL.\n*\n*THE START=RDW STATEMENT INDICATES THAT THE SEARCH STARTS\n*              AT OFFSET 0(THE RECORD LENGTH FIELD) AND THAT\n*              THE START POSITION IS IN DECIMAL.\n*\n*IF  START=RDW OR START=HEX IS NOT SPECIFIED, THE SEARCH\n*              STARTS AT OFFSET 5(THE RECORD DATA) AND THE\n*              START POSITION IS IN DECIMAL.\n*\n*THE SELECT= STATEMENT IS USED TO DETERMINE WHICH OUTPUT\n*FILE WILL RECEIVE THE DATA SELECTED BY THE SPECIFIED 1\n*TO 5 CONTROL FIELDS.\n*\n*THE HEAD1= STATEMENT IS USED TO CHANGE THE DEFAULT HEADING\n*ON THE OUT1 LISTING.\n*\n*THE HEAD2= STATEMENT IS USED TO CHANGE THE DEFAULT HEADING\n*ON THE OUT2 LISTING.\n*\n*THE HEAD3= STATEMENT IS USED TO CHANGE THE DEFAULT HEADING\n*ON THE OUT3 LISTING.\n*\n*THE FOLLOWING RESTRICTIONS MUST BE OBSERVED:\n*\n*OUT1, OUT2, OUT3 CAN ONLY BE SYSOUT=A FILES.\n*\n*OUT4, OUT5, OUT6 CAN ONLY BE VB FILES ON TAPE OR DISK.\n*\n*OUT7 CAN ONLY BE AN FB FILE ON TAPE OR DISK.\n*\n*ON THE OUTPUT= CARD, THE OUT'S MUST BE IN SEQUENCE.\n*\n*\n*THERE CAN BE 1 TO 5 CONTROL FIELDS IN THE CONTROL=(START,LENGTH,TYPE)\n*PARAMETER.\n*\n*START\n*START IS THE STARTING POSITION WITHIN THE RECORD.\n*IF THE START POSITION IS OUTSIDE THE LENGTH OF THE VB RECORD,\n*IT IS TREATED THE SAME AS CONDITION NOT MET.\n*\n*LENGTH\n*LENGTH IS THE NUMBER OF CHARACTERS IN THE FIELD.\n*\n*THE MAXIMUM LENGTH ALLOWED FOR ALPHANUMERIC FIELDS IS 111.\n*\n*THE MAXIMUM LENGTH ALLOWED FOR PACKED OR HEXADECIMAL FIELDS IS 16.\n*\n*FOR PACKED FIELDS, THE LENGTH IS THE NUMBER OF DIGITS IN THE\n*FIELD, NOT THE NUMBER OF BYTES IN THE FIELD...EG...A 2 BYTE\n*PACKED FIELD WILL HOLD 3 DIGITS...123C, SO THE LENGTH IS 3, NOT 2.\n*TO SPECIFY A POSITIVE(+) OR A NEGATIVE(-) PACKED NUMBER, THE LAST\n*DIGIT MUST CONSIST OF THE NUMBER AND A 12 OR 11 PUNCH. THIS CAN\n*BE ACCOMPLISHED BY USING THE CHARACTER '{' AND THE LETTERS\n*'A - I' TO DESIGNATE +0 TO +9  OR THE CHARACTER '}' AND THE\n*letters 'J - R' TO DESIGNATE -0 TO -9. FOR EXAMPLE, TO SELECT +1230,\n*YOU WOULD CODE 123{, AND TO SELECT -1230 YOU WOULD CODE 123}. TO\n*SELECT +1234 YOU WOULD CODE 123D, AND TO SELECT -1879, YOU WOULD\n*CODE 187R.\n*THE CORRESPONDING LETTERS FOR THE POSITIVE AND NEGATIVE NUMBERS ARE:\n*     +0 = {            -0 = }\n*     +1 = A            -1 = J\n*     +2 = B            -2 = K\n*     +3 = C            -3 = L\n*     +4 = D            -4 = M\n*     +5 = E            -5 = N\n*     +6 = F            -6 = O\n*     +7 = G            -7 = P\n*     +8 = H            -8 = Q\n*     +9 = I            -9 = R\n*\n*FOR HEXADECIMAL FIELDS, THE LENGTH IS A MULTIPLE OF 2, AS IT TAKES\n*2 DIGITS TO REPRESENT 1 HEXADECIMAL DIGIT...EG...X'12' WOULD BE\n*12 IN YOUR CONTROL FIELD, SO THE LENGTH IS 2, NOT 1.\n*\n*TYPE\n*THE TYPE SPECIFIED CAN BE 1 OF THE FOLLOWING:\n*'A' TO INDICATE ALPHANUMERIC DATA,\n*'P' TO INDICATE PACKED DATA,\n*'H' TO INDICATE HEXADECIMAL DATA.\n*\n*THERE CAN BE 1 TO 5 SELECT STATEMENTS FOR EACH OUT FILE.\n*\n*RECORDS CAN BE SELECTED ON:\n*  1- ALL CONDITIONS           - CF1=ALL,...CF5=...\n*  2- EQUAL CONDITIONS         - CF1=(= ),...CF5=...\n*  3- GREATER THAN CONDITIONS  - CF1=(> ),...CF5=...\n*  4- LESS THAN CONDITIONS     - CF1=(< ),...CF5=...\n*  5- NOT EQUAL CONDITIONS     - CF1=(# ),...CF5=...\n*\n*THE ABILITY TO PUT A HEADING ON OUT1, OUT2, OUT3 HAS BEEN INCLUDED.\n*THE CONTROL CARDS ARE:\n*HEAD1=\n*HEAD2=\n*HEAD3=\n*THE HEADINGS CAN BE 1-74 CHARACTERS LONG. IF HEADING CARDS ARE NOT\n*INCLUDED, THE DEFAULTS ARE:\n*   HEAD1=RECORDS SPLIT TO OUT1\n*   HEAD2=RECORDS SPLIT TO OUT2\n*   HEAD3=RECORDS SPLIT TO OUT3\n*\n*\n*                         CONTROL CARDS EXAMPLE\n*\n*INPUT=TAPEIN,CONTROL=(1,1,A,59,6,A,72,5,P,32,2,H)\n*OUTPUT=OUT1,OUT2,OUT3,OUT4,OUT7\n*SELECT=OUT1,CF1=ALL\n*SELECT=OUT2,CF2=(>111100)\n*SELECT=OUT3,CF3=(<40406)\n*SELECT=OUT4,CF3=(=40405)\n*SELECT=OUT4,CF3=(=40405)\n*SELECT=OUT7,CF1=ALL\n*HEAD1=NEW HEADING FOR OUT1\n*\n*ADDITIONAL COPIES OF THIS DOCUMENTATION CAN BE OBTAINED BY LISTING\n*   HALL.SOURCE.CNTL(HOWVSPLT)\n*\n**********************************************************************\n         EJECT\nROOTSECT CSECT\n         SAVE  (14,12)\n         LR    R12,R15                  LOAD BASE REGISTER\n         USING ROOTSECT,R12             ESTABLISH ADDRESSABILITY\n         ST    R13,ROOTSAVE+4           CHAIN SAVE AREAS\n         LR    R11,R13                  *\n         LA    R13,ROOTSAVE             *\n         ST    R13,8(R11)               *\n         SPACE 2\n***********************************************************************\n*        CALL ROUTINE TO ANALYZE CONTROL CARDS AND TO SET UP          *\n*        THE TABLES USED TO PRINT THE REPORTS                         *\n***********************************************************************\n         SPACE\n         CALL  CTRLEDIT,(CONTROLS,SELECTS)\n         SPACE 2\n***********************************************************************\n*        CALL ROUTINE USED TO SELECT RECORDS AND PRODUCE ALL          *\n*        THE OUTPUTS                                                  *\n***********************************************************************\n         SPACE\n         CALL  VPRINT,(CONTROLS,SELECTS)\n         SPACE 2\n*                                       RETURN CONTROL TO SYSTEM\n         L     R13,ROOTSAVE+4           *\n         RETURN (14,12),RC=0            *\n         SPACE\nROOTSAVE DC    18F'0'                   REGISTER SAVE AREA\nR0       EQU   0                        REGISTER EQUATES\nR1       EQU   1                        *\nR2       EQU   2                        *\nR3       EQU   3                        *\nR4       EQU   4                        *\nR5       EQU   5                        *\nR6       EQU   6                        *\nR7       EQU   7                        *\nR8       EQU   8                        *\nR9       EQU   9                        *\nR10      EQU   10                       *\nR11      EQU   11                       *\nR12      EQU   12                       *\nR13      EQU   13                       *\nR14      EQU   14                       *\nR15      EQU   15                       *\n*\n*        THIS TABLE CONTAINS THE START POSITION WITHIN THE RECORD,\n*        THE LENGTH OF THE FIELD AND THE TYPE OF DATA FOR CF'S\n*        1 TO 5. WHEN FIRST CALLED, THE TABLE IS INITIALIZED AS\n*        FOLLOWS : START = 0, LENGTH = 0, TYPE = A\n*\nCONTROLS DS    0F\n         COPY  SDP10\n*\n*        THIS TABLE CONTAINS THE CF DISPLACEMENT, TYPE OF COMPARE\n*        (=,<,>), AND THE VALUE TO BE TESTED FOR IN THE CONTROL FIELD.\n*        THERE IS A SECTION FOR OUT1 - OUT6. EACH SECTION ALLOWS\n*        FOR 5 SETS OF CONTROL FIELDS. WHEN FIRST CALLED, EACH SECTION\n*        IS INITIALIZED AS FOLLOWS :\n*              CF DISPLACEMENT = 0 TO 36\n*              TYPE OF COMPARE = X'80'\n*              VALUE = 11X'FF'\n*\nSELECTS  DS    0F\n*                                       SELECT FOR OUT1\n         COPY  SDP20\n*                                       SELECT FOR OUT2\n         COPY  SDP20\n*                                       SELECT FOR OUT3\n         COPY  SDP20\n*                                       SELECT FOR OUT4\n         COPY  SDP20\n*                                       SELECT FOR OUT5\n         COPY  SDP20\n*                                       SELECT FOR OUT6\n         COPY  SDP20\n*                                       SELECT FOR OUT7\n         COPY  SDP20\n         END   ROOTSECT\n//STEP4 EXEC HLASMC,PARMC='XREF(FULL)'\n//ASM.SYSLIB DD\n//          DD\n//    DD DSN=&&T,DISP=(SHR,PASS)\n//ASM.SYSIN DD *\n         EJECT\n***********************************************************************\n*        E D I T   C O N T R O L   C A R D S                          *\n***********************************************************************\n         SPACE 2\nCTRLEDIT CSECT                          NAME CSECT\n         B     12+4(R0,R15)             BRANCH AROUND IDENTIFIER\n         DC    C'EDIT SECTION'\nA10SAVE  DS    0H\n         SAVE  (14,12)                  SAVE REGISTERS\n         BALR  R12,0                    LOAD BASE REGISTER\n         USING *,R12                    ESTABLISH ADDRESSABILITY\n         ST    R13,EDITSAVE+4           CHAIN SAVE AREAS\n         LR    R11,R13                  *\n         LA    R13,EDITSAVE             *\n         ST    R13,8(R11)               *\n         L     R5,0(0,R1)               LOAD TABLE BASE REG\n         USING TABLED,R5                ESTABLISH TABLE ADDRESSABILITY\n         SPACE 2\n         OPEN  (INFILE,,OUTFILE,(OUTPUT)) OPEN CONTROL FILES\n         SPACE\n         BAL   R11,Y10SKIP1             SKIP TO NEW PAGE\n         MVC   P(L'CTLHEAD),CTLHEAD     MOVE HEADING TO PRINT\n         BAL   R11,Y10WSP3              PRINT, SPACE 3\n         SPACE\nA20READ  DS    0H\n         GET   INFILE                   READ CONTROL CARD\n         LR    R2,R1                    MOVE RECORD ADDRESS TO REG 2\n         MVC   P(80),0(R1)              MOVE RECORD TO PRINT\n         BAL   R11,Y10WSP2              PRINT, SPACE 2\n         CLI   0(R2),C'*'         START WITH *?\n         BE    A20READ            YES, IT'S A COMMENT\n         CLI   0(R2),C'/'         START WITH /?\n         BE    A20READ            YES, IT'S A COMMENT\n         ST    R2,EDITSAVE        SAVE RECORD ADDRESS\n         SPACE\nA30      NOP   A60\nA40      NOP   A50\n         SPACE\n         CLC   0(6,R2),INPUT            IS CONTROL = INPUT= ?\n         BNE   A50                      NO, CHECK FOR OUTPUT=\n         SPACE\n         OI    A40+1,X'F0'              CHANGE A40 TO A BRANCH\n         BAL   R11,B10INPUT             EDIT INPUT CARD\n         B     A20READ                  READ NEXT CARD\n         SPACE\nA50      CLC   0(7,R2),OUTPUT           IS CONTROL = OUTPUT= ?\n         BNE   A60                      NO, CHECK FOR SELECT=\n         SPACE\n         OI    A30+1,X'F0'              CHANGE A30 TO A BRANCH\n         BAL   R11,C10OUT1              EDIT OUTPUT CARD\n         B     A20READ                  READ NEXT CARD\n         SPACE\nA60      DS    0H\n         CLC   0(7,R2),SELECT           IS CONTROL = SELECT=\n         BNE   A70HEAD1                 NO, CHECK FOR HEADING CARDS\n         SPACE\n         BAL   R11,D10SLECT             EDIT SELECT CARD\n         B     A20READ                  READ NEXT CARD\n         SPACE\nA70HEAD1 DS    0H\n         CLC   0(6,R2),HD1              CONTROL = HEAD1 ?\n         BNE   A70HEAD2                 NO, CHECK FOR HEAD2\n         MVC   HEAD1,6(R2)              STORE OUT1 HEADING\n         B     A20READ                  READ NEXT CONTROL CARD\n         SPACE\nA70HEAD2 DS    0H\n         CLC   0(6,R2),HD2              CONTROL = HEAD2 ?\n         BNE   A70HEAD3                 NO, CHECK FOR HEAD3\n         MVC   HEAD2,6(R2)              STORE OUT2 HEADING\n         B     A20READ                  READ NEXT CONTROL CARD\n         SPACE\nA70HEAD3 DS    0H\n         CLC   0(6,R2),HD3              CONTROL = HEAD3 ?\n         BNE   A75START                 NO, PRINT ERROR MESSAGE\n         MVC   HEAD3,6(R2)              STORE OUT3 HEADING\n         B     A20READ                  READ NEXT CONTROL CARD\n         SPACE\nA75START DS    0H\n         CLC   0(9,R2),STARTRDW         CONTROL = START=RDW ?\n         BNE   A76START                 NO, SEE IF START=HEX\n         MVI   STRTPOS,C'R'             YES, SAY START AT RDW\n         B     A20READ                  READ NEXT CONTROL CARD\n         SPACE 1\nA76START DS    0H\n         CLC   0(9,R2),STARTHEX         CONTROL = START=HEX ?\n         BNE   A80ERROR                 NO, PRINT ERROR MESSAGE\n         MVI   STRTPOS,C'H'             YES, SAY START AT RDW & HEX\n         B     A20READ                  READ NEXT CONTROL CARD\n         SPACE 1\nA80ERROR DS    0H\n         MVC   P(L'CTLMS1),CTLMS1       MOVE MESSAGE TO PRINT\n         BAL   R11,Y10WSP2              PRINT, SPACE 2\n         B     A20READ            GET NEXT CARD\n         SPACE 2\n***********************************************************************\n*        E N D   O F   C O N T R O L   C A R D S                      *\n***********************************************************************\n         SPACE 2\nA90END   DS    0H\n         MVC   P(L'CTLMS13),CTLMS13     MOVE MESSAGE TO PRINT\n         BAL   R11,Y10WSP3              PRINT, SPACE 3\n         SPACE\n         CLOSE (INFILE,,OUTFILE)        CLOSE FILES\n         L     R13,EDITSAVE+4           RETURN TO ROOT SEGMENT\n         RETURN (14,12),RC=0            *\n         EJECT\n***********************************************************************\n*        E D I T   I N P U T   C A R D                                *\n***********************************************************************\n         SPACE 2\nB10INPUT DS    0H\n         LA    R2,6(R2)                 ADD 6 TO RECORD ADDRESS\n         CLC   0(6,R2),TAPEIN           INPUT = TAPEIN\n         BE    B20CTL                   YES, CHECK FOR CONTROL=\n         SPACE\n         MVC   P(L'CTLMS2),CTLMS2       MVC MESSAGE TO PRINT\n         B     B90ABEND                 PRINT, SPACE 1, CANCEL JOB\n         SPACE\nB20CTL   DS    0H\n         LA    R2,7(R2)                 POINT TO CONTROL=\n         CLC   0(9,R2),CONTROL          IS CONTROL = CONTROL=( ?\n         BE    B30LA                    YES, STORE VALUES\n         SPACE\n         MVC   P(L'CTLMS3),CTLMS3       MOVE MESSAGE TO PRINT\n         B     B90ABEND                 PRINT, SPACE 1, CANCEL JOB\n         SPACE\nB30LA    DS    0H\n         LA    R10,CONTROLS             LOAD ADDRESS CONTROL TABLE\n         LA    R2,9(R2)                 POINT TO START LOCATION\nB40LOOP  DS    0H\n         LR    R3,R2                    STORE START ADDRESS\nB41      DS    0H\n         CLI   0(R2),C'0'               IS DIGIT LESS THAN 0 ?\n         BL    B42                      YES, CHECK FOR COMMA\n         SPACE\n         CLI   0(R2),C'9'               IS DIGIT GREATER THAN 9 ?\n         BH    B50ERROR                 YES, GO TO ERROR ROUTINE\n         SPACE\n         LA    R2,1(R2)                 POINT TO NEXT DIGIT\n         B     B41                      CHECK NEXT DIGIT\n*\nB42      DS    0H\n         CLI   STRTPOS,C'H'       START AT RDW & OFFSET IN HEX?\n         BNE   B43                NO, CAN JUST HAVE COMMA\n*        BNE   B50ERROR           NO, GO TO ERROR ROUTINE\n*\n         CLI   0(R2),C'A'               IS DIGIT LESS THAN A ?\n         BL    B43                      YES, CHECK FOR COMMA\n         SPACE\n         CLI   0(R2),C'F'               IS DIGIT GREATER THAN F ?\n         BH    B50ERROR                 YES, GO TO ERROR ROUTINE\n         SPACE\n         LA    R2,1(R2)                 POINT TO NEXT DIGIT\n         B     B42                      CHECK NEXT DIGIT\n*\nB43      DS    0H\n         CLI   0(R2),C','               IS DIGIT = , ?\n         BNE   B50ERROR                 NO, GO TO ERROR ROUTINE\n         SPACE\n         LR    R4,R2                    CALCULATE NUMBER OF DIGITS\n         SR    R4,R3                    IN START LOCATION PARAMETER\n         CLI   STRTPOS,C'H'       START AT RDW & OFFSET IN HEX?\n         BNE   B43A               NO, ON WE GO\n         XC    DWORD,DWORD        CLEAR DWORD\n         XC    TRANDATA,TRANDATA  CLEAR TRANDATA\n         SR    R15,R15            CLEAR R15\n         LA    R15,DWORD+4        R15 -> AT END OF DWORD\n         LA    R15,TRANDATA+4     R15 -> AT END OF DWORD\n*        SRL   R4,1               DIVIDE BY FOR (HEX DATA)\n         SR    R15,R4             R15 -> WHERE DATA GOES\n*        SLL   R4,1               PUT BACK\n         BCTR  R4,0               SUBTRACT 1 TO GET MACHINE LGTH\n         EX    R4,MVCDATA         PUT CHAR DATA IN DWORD\n*        EX    R4,LOADDATA        PUT CHAR DATA IN R15\n*        ST    R15,DWORD+4        PUT IT IN DWORD\n*        EX    R4,TRHEX2          TRANSLATE INPUT TO 00-0F\n*        TR    DWORD,TRTAB        TRANSLATE TO 00-0F\n         TR    TRANDATA(4),TRTAB2 TRANSLATE TO 00-0F\n         PACK  DWORD(5),TRANDATA(5) PACK FIELD\n         L     R4,DWORD           PUT IT IN R4\n*        L     R4,DWORD+4         PUT IT IN R4\n*        LA    R15,1(0,R7)        R15 = REAL LTH OF INPUT\n*        C     R15,MAXPACK        AT MAX LTH OF 16 ?\n*        BE    F50MAX             YES, TREAT DIFFERENTLY\n*        EX    R15,F50PACK        NO, PACK ALL OF FIELD\n*        BCTR  R4,0                     SUBTRACT 1 TO GET MACHINE LGTH\n*        EX    R4,B48PACK               PACK START LOC IN DOUBLE WORD\n*        CVB   R4,DWORD                 CONVERT TO BINARY\n*        SRL   R4,8               DROP GARBAGE BYTE\n         B     B43C               GO SAVE HEX OFFSET\nTRHEX2   TR    TRANDATA(0),TRTAB2 TRANSLATE TO 00-0F\nMVCDATA  MVC   0(0,R15),0(R3)     SET UP DATA FOR TRANSLATE\n*VCDATA  MVC   DWORD(0),0(R3)     SET UP DATA FOR TRANSLATE\nLOADDATA ICM   R15,0,0(R3)        PUT DATA IN R15\nB10PACK  PACK  DWORD,TRANDATA(4)        PACK FIELD\nTRANDATA DC    D'0'\n*RTAB2   EQU   *-193              SET START OF SHORT TRANS TABLE\nTRTAB2   DS    0XL256             SET START OF SHORT TRANS TABLE\n         DC    X'00'              CHANGE 00 TO 00\n         DC    XL192'00'          CHANGE 01-C0 TO 00\n         DC    X'FAFBFCFDFEFF'    CHANGE C1-C6 TO FA-FF\n         DC    41X'00'            CHANGE C7-EF TO 00\n         DC    X'F0F1F2F3F4F5F6F7F8F9'   CHANGE F0-F9 TO F0-F9\n         DC    XL(256-(*-TRTAB2))'00'    CHANGE FA-FF TO 00\n*\nB43A     DS    0H\n         BCTR  R4,0                     SUBTRACT 1 TO GET MACHINE LGTH\n         EX    R4,B48PACK               PACK START LOC IN DOUBLE WORD\n         CVB   R4,DWORD                 CONVERT TO BINARY\n         BCTR  R4,0                     SUBT 1 TO GIVE MACHINE LENGTH\n*\nB43C     DS    0H\n         ST    R4,0(R10)                STORE START LOCATION IN TABLE\n         SPACE\n         LA    R2,1(R2)                 POINT TO LENGTH PARAMETER\n         LR    R3,R2                    STORE START OF LENGTH PARM\nB44      DS    0H\n         CLI   0(R2),C'0'               DIGIT LESS THAN 0 ?\n         BL    B46                      YES, CHECK FOR COMMA\n         SPACE\n         CLI   0(R2),C'9'               DIGIT GREATER THAN 9 ?\n         BH    B60ERROR                 YES, GO TO ERROR ROUTINE\n         SPACE\n         LA    R2,1(R2)                 POINT TO NEXT DIGIT\n         B     B44                      CHECK NEXT DIGIT\nB46      DS    0H\n         CLI   0(R2),C','               DIGIT A COMMA ?\n         BNE   B60ERROR                 NO, GO TO ERROR ROUTINE\n         SPACE\n         LR    R4,R2                    CALCULATE NUMBER OF DIGITS\n         SR    R4,R3                    IN LENGTH PARAMETER\n         SPACE\n         BCTR  R4,0                     SUBTRACT 1 TO GET MACHINE LTH\n         EX    R4,B48PACK               PACK LENGTH PARM IN DOUBLE WORD\n         CVB   R4,DWORD                 CONVERT TO BINARY\n         CLI   1(R2),C'A'               IS TYPE = A ?\n         BNE   B47PACK                  NO, MAXLEN = 16\n         C     R4,MAXLEN                LENGTH OVER MAXIMUM LTH ?\n         BH    B70ERROR                YES, GO TO ERROR ROUTINE\n         SPACE 1\nB47      DS    0H\n         BCTR  R4,0                     SUBT 1 TO GIVE MACHINE LENGTH\n         ST    R4,4(R10)                STORE LENGTH IN TABLE\n         SPACE\n         LA    R2,1(R2)                 POINT TO TYPE PARAMETER\n         CLI   0(R2),C'P'               IS TYPE = P ?\n         BE    B80STORE                 YES, STORE TYPE\n         SPACE\n         CLI   0(R2),C'A'               IS TYPE = A ?\n         BE    B80STORE                 YES, STORE TYPE\n         SPACE\n         CLI   0(R2),C'H'         IS TYPE = H ?\n         BE    B80STORE           YES, STORE TYPE\n         BAL   R11,G10SET2        POINT R2 TO WHERE ERROR MSG GOES\n         MVC   0(L'CTLMS4,R2),CTLMS4     MOVE MESSAGE TO PRINT\n         B     B90ABEND                 PRINT, SPACE 1, CANCEL JOB\n         SPACE 1\nB47PACK  DS    0H\n         C     R4,MAXPACK         IS LTH OVER 16 ?\n         BH    B75ERROR           YES, TOO BAD\n         CLI   1(R2),C'P'         PACKED DATA ?\n         BE    B47PACK2           YES, FIX PACKED LENGTH\n         SRL   R4,1               HEX LTH = LTH/2\n         B     B47                LTH NOW OKAY\n         SPACE 1\nB47PACK2 DS    0H\n         LA    R4,1(0,R4)         MAKE LTH EVEN\n         SRL   R4,1               LTH/2 = PACKED LTH\n         B     B47                PACKED LTH OKAY NOW TOO\n         SPACE 2\nB48PACK  PACK  DWORD,0(0,R3)            PACK FIELD\n         SPACE 2\nB50ERROR DS    0H\n         BAL   R11,G10SET2        POINT R2 TO WHERE ERROR MSG GOES\n         MVC   0(L'CTLMS6,R2),CTLMS6    PUT MSG UNDER BAD CHAR\n         B     B90ABEND                 PRINT, SPACE 1, CANCEL JOB\n         SPACE\nB60ERROR DS    0H\n         BAL   R11,G10SET2        POINT R2 TO WHERE ERROR MSG GOES\n         MVC   0(L'CTLMS7,R2),CTLMS7    PUT MSG UNDER BAD CHAR\n         B     B90ABEND                 PRINT, SPACE 1, CANCEL JOB\n         SPACE\nB70ERROR DS    0H\n         BAL   R11,G10SET2        POINT R2 TO WHERE ERROR MSG GOES\n         MVC   0(L'CTLMS9,R2),CTLMS9    PUT MSG UNDER BAD CHAR\n         B     B90ABEND                 PRINT, SPACE 1, CANCELL JOB\n         SPACE\nB75ERROR DS    0H\n         BAL   R11,G10SET2        POINT R2 TO WHERE THE ERROR MSG GOES\n         MVC   0(L'CTLMS9),CTLMS9 MOVE MESSAGE TO PRINT LINE\n         MVI   23(R2),C'6'        CHANGE LTH IN MSG TO 16\n         MVI   24(R2),C' '        *\n         B     B90ABEND           PRINT MSG, CANCEL JOB\n         SPACE 1\nB80STORE DS    0H\n         MVC   8(1,R10),0(R2)           STORE TYPE IN TABLE\n         CLI   1(R2),C','               ANY MORE PARAMETERS ?\n         BCR   7,R11                    NO, RETURN TO CALLER\n         SPACE 2\n         LA    R10,12(R10)              POINT TO NEXT CONTROL FIELD\n         LA    R2,2(R2)                 POINT TO NEXT START PARM\n         AP    CFCTR,ONE                ADD 1 TO CONTROL FIELD CTR\n         CP    CFCTR,FIVE               OVER 5 PARAMETERS ?\n         BNH   B40LOOP                  NO, PROCESS NEXT FIELD\n         SPACE\n         MVC   P(L'CTLMS5),CTLMS5       MOVE MESSAGE TO PRINT\n         BAL   R11,Y10WSP1              PRINT, SPACE 1\n         SPACE\nB90ABEND BAL   R11,Y10WSP1              PRINT, SPACE 1\n         ABEND 16                       CANCEL JOB\n         EJECT\n***********************************************************************\n*        E D I T   O U T P U T   C O N T R O L   C A R D              *\n***********************************************************************\n         SPACE 2\nC10OUT1  DS    0H\n         MVI   OPENFLGS,X'00'           CLEAR OPEN FLAGS\n         LA    R2,7(R2)                 POINT TO OUTPUT FILES\n         CLC   0(4,R2),OUT1             USING FILE OUT1 ?\n         BNE   C20OUT2                  NO, CHECK FOR OUT2.\n         SPACE\n         OI    OPENFLGS,B'10000000'     TURN OPEN OUT1 FLAG ON\n         LA    R2,5(R2)                 POINT TO NEXT FILE NAME\n         SPACE\nC20OUT2  DS    0H\n         CLC   0(4,R2),OUT2             USING FILE OUT2 ?\n         BNE   C30OUT3                  NO, CHECK FOR OUT3\n         SPACE\n         OI    OPENFLGS,B'01000000'     TURN OPEN OUT2 FLAG ON\n         LA    R2,5(R2)                 POINT TO NEXT FILE NAME\nC30OUT3  DS    0H\n         CLC   00(4,R2),OUT3            USING FILE OUT3 ?\n         BNE   C40OUT4                  NO, CHECK FOR OUT4\n         SPACE\n         OI    OPENFLGS,B'00100000'     TURN OPEN OUT3 FLAG ON\n         LA    R2,5(R2)                 POINT TO NEXT FILE NAME\n         SPACE\nC40OUT4  DS    0H\n         CLC   00(4,R2),OUT4            USING FILE OUT4 ?\n         BNE   C50OUT5                  NO, CHECK FOR OUT5\n         SPACE\n         OI    OPENFLGS,B'00010000'     TURN OPEN OUT4 FLAG ON\n         LA    R2,5(R2)                 POINT TO NEXT FILE NAME\n         SPACE\nC50OUT5  DS    0H\n         CLC   00(4,R2),OUT5            USING FILE OUT5 ?\n         BNE   C60OUT6                  NO, CHECK FOR OUT6\n         SPACE\n         OI    OPENFLGS,B'00001000'    TURN OPEN OUT5 FLAG ON\n         LA    R2,5(R2)                 POINT TO NEXT FILE NAME\nC60OUT6  DS    0H\n         CLC   00(4,R2),OUT6            USING FILE OUT6 ?\n         BNE   C60OUT7                  NO, CHECK FOR OUT7\n         SPACE\n         OI    OPENFLGS,B'00000100'     TURN OPEN OUT6 FLAG ON\n         LA    R2,5(R2)                 POINT TO NEXT FILE NAME\n         SPACE\nC60OUT7  DS    0H\n         CLC   0(4,R2),OUT7             USING FILE OUT7 ?\n         BNE   C70END                   NO, CHECK FOR END OF INPUT\n         SPACE\n         OI    OPENFLGS,X'02'           TURN OPEN OUT7 FLAG ON\n         LA    R2,5(0,R2)         POINT TO NEXT FILE NAME\n         SPACE\nC70END   DS    0H\n         CLI   0(R2),C' '               AT END OF CONTROL CARD ?\n         BE    C90END                   YES, RETURN TO CALLER\n         SPACE\n         MVC   P(L'CTLMS8),CTLMS8       MOVE MESSAGE TO PRINT\n         BAL   R11,Y10WSP1              PRINT, SPACE 1\n         ABEND 16                       CANCEL JOB\nC90END   BR    R11                      RETURN TO CALLER\n         EJECT\n***********************************************************************\n*        E D I T   S E L E C T   C O N T R O L   C A R D              *\n***********************************************************************\n         SPACE 2\nD10SLECT DS    0H\n         LA    R3,SELECTS               LOAD ADDRESS SELECT TABLE\n         LA    R2,7(R2)                 POINT TO SELECTED FILE NAME\n         CLC   0(4,R2),OUT1             FILE = OUT1 ?\n         BNE   D20OUT2                  NO, CHECK FOR OUT2\n         SPACE\n         LA    R9,OUT1CTR               LOAD ADDRESS OUT1 COUNTER\nD10LOOP  DS    0H\n         LA    R2,5(R2)                 POINT TO CF\n         BAL   R10,F10EDIT              EDIT CONTROL FIELDS\n         L     R15,0(0,R9)              LOAD COUNTER IN REG 15\n         LA    R10,4                    R10 = 4\n         CR    R15,R10                  IF SELECT COUNTER > 4\n         BH    D85ERROR                 BOMB RUN\n         SPACE\n         M     R14,ENTLTH               MULTIPLY BY TABLE ENTRY LENGTH\n         AR    R3,R15                   ADD DISP TO SELECT BASE REG\n         CLI   CFWK1,X'FF'              IS CONTROL FIELD 1 USED\n         BE    D12CF2                   NO, CHECK CF2\n         SPACE\n         MVC   4(L'CFWK1,R3),CFWK1           STORE CF1\n         SPACE\nD12CF2   DS    0H\n         LA    R3,116(R3)                POINT TO CF2\n         CLI   CFWK2,X'FF'              CONTROL FIELD 2 USED ?\n         BE    D14CF3                   NO, CHECK FOR CF3\n         SPACE\n         MVC   4(L'CFWK2,R3),CFWK2           STORE CF2\n         SPACE\nD14CF3   DS    0H\n         LA    R3,116(R3)                POINT TO CF3\n         CLI   CFWK3,X'FF'              CONTROL FIELD 3 USED ?\n         BE    D16CF4                   NO, CHECK FOR CF4\n         SPACE\n         MVC   4(L'CFWK3,R3),CFWK3      STORE CF3\n         SPACE\nD16CF4   DS    0H\n         LA    R3,116(R3)                POINT TO CF4\n         CLI   CFWK4,X'FF'              CONTROL FIELD 4 USED ?\n         BE    D18CF5                   NO, CHECK FOR CF5\n         SPACE\n         MVC   4(L'CFWK4,R3),CFWK4      STORE CF4\n         SPACE\nD18CF5   DS    0H\n         LA    R3,116(R3)                POINT TO CF5\n         CLI   CFWK5,X'FF'              CONTROL FIELD 5 USED ?\n         BE    D19ADD                   NO, ADD 1 TO COUNTER\n         SPACE\n         MVC   4(L'CFWK5,R3),CFWK5      STORE CF5\n         SPACE\nD19ADD   DS    0H\n         L     R10,0(0,R9)              ADD 1 TO OUT  COUNTER\n         LA    R10,1(R10)               *\n         ST    R10,0(0,R9)              *\n         B     D80END                   RETURN TO CALLER\n         SPACE\nD20OUT2  DS    0H\n         LA    R3,2900(0,R3)         POINT TO OUT2 SELECT\n         CLC   0(4,R2),OUT2             FILE = OUT2 ?\n         BNE   D30OUT3                  NO, CHECK FOR OUT3\n         SPACE\n         LA    R9,OUT2CTR               LOAD ADDRESS OUT2 COUNTER\n         B     D10LOOP                  PROCESS CF'S\n         SPACE\nD30OUT3  DS    0H\n         LA    R3,2900(0,R3)         POINT TO OUT3 SELECT\n         CLC   0(4,R2),OUT3             FILE = OUT3 ?\n         BNE   D40OUT4                  NO, CHECK FOR OUT4\n         SPACE\n         LA    R9,OUT3CTR               LOAD ADDRESS OUT3 COUNTER\n         B     D10LOOP                  PROCESS\n         SPACE\nD40OUT4  DS    0H\n         LA    R3,2900(0,R3)         POINT TO OUT4 SELECT\n         CLC   0(4,R2),OUT4             FILE = OUT4 ?\n         BNE   D50OUT5                  NO, CHECK FOR OUT5\n         SPACE\n         LA    R9,OUT4CTR               LOAD ADDRESS OUT4 COUNTER\n         B     D10LOOP                  PROCESS OUT4\n         SPACE\nD50OUT5  DS    0H\n         LA    R3,2900(0,R3)         POINT TO OUT5 SELECT\n         CLC   0(4,R2),OUT5             FILE = OUT5 ?\n         BNE   D60OUT6                  NO, CHECK FOR OUT6\n         SPACE\n         LA    R9,OUT5CTR               LOAD ADDRESS OUT5 COUNTER\n         B     D10LOOP                  PROCESS OUT5\n         SPACE\nD60OUT6  DS    0H\n         LA    R3,2900(0,R3)         POINT TO OUT6 SELECT\n         CLC   0(4,R2),OUT6             FILE = OUT6 ?\n         BNE   D70OUT7                  NO, CHECK FOR OUT7\n         SPACE\n         LA    R9,OUT6CTR               LOAD ADDRESS OUT6 COUNTER\n         B     D10LOOP                  PROCESS OUT6\n         SPACE\nD70OUT7  DS    0H\n         LA    R3,2900(0,R3)         POINT TO OUT7 SELECT\n         CLC   0(4,R2),OUT7       FILE = OUT7 ?\n         BNE   D90ERROR           NO, PRINT ERROR MSG\n         SPACE 1\n         LA    R9,OUT7CTR               LOAD ADDR OUT7 COUNTER\n         B     D10LOOP                  PROCESS OUT7\n         SPACE\nD80END   DS    0H\n         BR    R11                      RETURN TO CALLER\n         SPACE\nD90ERROR DS    0H\n         MVC   P(L'CTLMS8),CTLMS8       MOVE MESSAGE TO PRINT\nD95      DS    0H\n         BAL   R11,Y10WSP1              PRINT, SPACE 1\n         ABEND 16                       CANCEL JOB\n         SPACE\nD85ERROR DS    0H\n         MVC   P(L'CTLMS14),CTLMS14     PRINT ERROR MESSAGE\n         B     D95                      *\n         EJECT\n***********************************************************************\n*        E D I T   C O N T R O L   F I E L D S                        *\n***********************************************************************\n         SPACE 2\nF10EDIT  DS    0H\n         MVC   CFWK1(112),WKFILL         INITIALIZE WORK AREAS\n         MVC   CFWK2(112),WKFILL         INITIALIZE WORK AREAS\n         MVC   CFWK3(112),WKFILL         INITIALIZE WORK AREAS\n         MVC   CFWK4(112),WKFILL         INITIALIZE WORK AREAS\n         MVC   CFWK5(112),WKFILL         INITIALIZE WORK AREAS\n         CLC   0(4,R2),CF1              CONTROL FIELD 1 ?\n         BNE   F20CF2                   NO, CHECK FOR CF2\n         LA    R8,CFWK1                 LOAD ADDRESS WORK 1\n         L     R7,LENGTH1               LOAD LENGTH\n         LA    R14,TYPE1          R14 -> TO TYPE FIELD\n         BAL   R6,F10LOOP               CHECK CF1\n         B     F20CF2\nF10LOOP  LA    R2,4(R2)                 POINT TO COMPARE OPERAND\n         CLC   0(3,R2),ALL              CF = ALL ?\n         BNE   F12                      NO, EDIT CF1\n         LA    R2,4(R2)                 POINT TO NEXT CF\n         MVI   0(R8),C'0'               ZERO WORK AREA\n         MVC   1(111,R8),0(R8)          *\n         BR    R6                       RETURN\nF12      DS    0H\n         CLI   0(R2),C'('               LEFT BRACKET ?\n         BNE   F60ERROR                 NO, PRINT MESSAGE\n         SPACE\n         LA    R2,1(R2)                 POINT TO COMPARE OPERAND\n         CLI   0(R2),C'='               EQUAL COMPARE ?\n         BNE   F14                      NO, CHECK FOR <\n         MVI   0(R8),X'80'              SET COMPARE CODE\n         B     F18\nF14      DS    0H\n         CLI   0(R2),C'<'               LESS THAN COMPARE ?\n         BNE   F16                      NO, CHECK FOR >\n         MVI   0(R8),X'40'              SET COMPARE CODE\n         B     F18\nF16      DS    0H\n         CLI   0(R2),C'>'               GREATER THAN COMPARE ?\n         BNE   F17                      NO, CHECK FOR \\\n         MVI   0(R8),X'20'              SET COMPARE CODE\n         B     F18\n         SPACE\nF17      DS    0H\n         CLI   0(R2),C'#'               NOT EQUAL COMPARE ?\n         BNE   F70ERROR                 NO, PRINT ERROR MESSAGE\n         MVI   0(R8),X'70'              SET COMPARE NOT EQUAL CODE\n         SPACE\nF18      LA    R2,1(R2)                 POINT TO COMPARE VALUE\n         LA    R8,1(R8)                 POINT TO VALUE WORK AREA\n         CLI   0(R14),C'A'        IS IT CHARACTER DATA?\n         BNE   F50HEX             NO, CHECK FOR HEX OR PACKED\n         EX    R7,F20                   MVC VALUE TO WORK AREA\nF19      DS    0H\n         AR    R2,R7                    POINT TO CLOSING BRACKET\n         LA    R2,1(R2)                 *\n         CLI   0(R2),C')'               CLOSING BRACKET ?\n         BNE   F60ERROR                 NO, PRINT MESSAGE\n         SPACE\nF19NEXT  DS    0H\n         LA    R2,2(R2)                 POINT TO NEXT CF\n         BR    R6                       RETURN TO CALLER\n         SPACE\nF20      MVC   0(0,R8),0(R2)            MOVE VALUE TO WORKAREA\n         SPACE\nF20CF2   DS    0H\n         CLC   0(4,R2),CF2              CF2 ?\n         BNE   F30CF3                   NO, CHECK FOR CF3\n         SPACE\n         LA    R8,CFWK2                 LOAD ADDRESS WORK 2\n         L     R7,LENGTH2               LOAD LENGTH 2\n         LA    R14,TYPE2          R14 -> TO TYPE FIELD\n         BAL   R6,F10LOOP               CHECK CF2\n         SPACE\nF30CF3   DS    0H\n         CLC   0(4,R2),CF3              CF3 ?\n         BNE   F40CF4                   NO, CHECK FOR CF4\n         LA    R8,CFWK3                 LOAD ADDRESS WORK 3\n         L     R7,LENGTH3               LOAD LENGTH 3\n         LA    R14,TYPE3          R14 -> TO TYPE FIELD\n         BAL   R6,F10LOOP               CHECK CF3\nF40CF4   DS    0H\n         CLC   0(4,R2),CF4              CF4 ?\n         BNE   F50CF5                   NO, CHECK FOR CF5\n         LA    R8,CFWK4                 LOAD ADDRESS WORK 4\n         L     R7,LENGTH4               LOAD LENGTH 4\n         LA    R14,TYPE4          R14 -> TO TYPE FIELD\n         BAL   R6,F10LOOP               CHECK CF4\n         SPACE\nF50CF5   DS    0H\n         CLC   0(4,R2),CF5              CF5 ?\n         BNE   F80ERROR                 NO, CHECK FOR END OF SELECT\n         LA    R8,CFWK5                 LOAD ADDRESS WORK 5\n         L     R7,LENGTH5               LOAD LENGTH 5\n         LA    R14,TYPE5          R14 -> TO TYPE FIELD\n         BAL   R6,F10LOOP               CHECK CF5\n         BR    R10                      RETURN TO CALLER\n         SPACE 2\nF50HEX   DS    0H\n         CLI   0(R14),C'P'        IS DATA PACKED ?\n         BE    F51PACK            YES, SET UP PACKED DATA\n         SPACE 1\n         LA    R7,1(0,R7)         ADD 1 TO R7\n         SLL   R7,1               R7*2 = REAL INPUT LTH\n         BCTR  R7,0               R7 = HEX LTH OF INPUT\n         SPACE 1\n         EX    R7,TRHEX           TRANSLATE INPUT TO 00-0F\n         LA    R15,1(0,R7)        R15 = REAL LTH OF INPUT\n         C     R15,MAXPACK        AT MAX LTH OF 16 ?\n         BE    F50MAX             YES, TREAT DIFFERENTLY\n         EX    R15,F50PACK        NO, PACK ALL OF FIELD\n         SPACE 1\nF50HEX2  DS    0H\n         SRL   R15,1              LTH/2 = LTH OF HEX FIELD\n         LA    R14,CTLHEAD+14     R14 -> TO LAST BYTE OF HEX DATA\n         SR    R14,R15            R14 -> TO FIRST BYTE OF HEX DATA\n         BCTR  R15,0              R15 = HEX LTH\n         EX    R15,F50MOVE        MOVE HEX VALUE TO WORK AREA\n         B     F19                DO REST OF EDIT\n         SPACE 1\nF50MAX   DS    0H\n         PACK  CTLHEAD(5),0(9,R2) PACK 1ST 8 DIGITS\n         PACK  CTLHEAD+4(5),8(9,R2) PACK 2ND 8 DIGITS\n         MVC   0(8,R8),CTLHEAD    MOVE HEX CHARS TO WORK AREA\n         B     F19                DO REST OF EDIT\n         SPACE 1\nF51PACK  DS    0H\n         SLL   R7,1               R7*2 = HEX LTH OF IN INPUT\n         EX    R7,F50PACK         PACK INPUT DATA\n         LR    R15,R7             R15 = LTH\n         SRL   R15,1              LTH /2 = PACKED LTH\n         LA    R14,CTLHEAD+14     R14 -> TO LAST PACKED BYTE\n         SR    R14,R15            R14 -> TO FIRST PACKED BYTE\n         EX    R15,F50MOVE        MOVE PACKED DATA TO WORK AREA\n         B     F19                DO REST OF EDIT\n         SPACE 2\nTRHEX    TR    0(0,R2),TRTAB      TRANSLATE TO 00-0F\nF50PACK  PACK  CTLHEAD(15),0(0,R2)  PACK INPUT\nF50MOVE  MVC   0(0,R8),0(R14)     MOVE TO TABLE AREA\n         SPACE 2\nF60ERROR DS    0H\n         BAL   R11,G10SET2        POINT R2 TO WHERE ERROR MSG GOES\n         MVC   0(L'CTLMS10,R2),CTLMS10  PUT ERROR MSG UNDER BAD CHAR\n         B     F90WRITE                 PRINT, CANCEL JOB\n         SPACE\nF70ERROR DS    0H\n         BAL   R11,G10SET2        POINT R2 TO WHERE ERROR MSG GOES\n         MVC   0(L'CTLMS11,R2),CTLMS11  PUT ERROR MSG UNDER BAD CHAR\n         B     F90WRITE                 PRINT, CANCEL JOB\n         SPACE\nF80ERROR DS    0H\n         CLI   0(R2),C' '               ANY MORE FIELDS ?\n         BCR   8,R10                    NO, RETURN TO CALLER\n         SPACE\n         BAL   R11,G10SET2        POINT R2 TO WHERE ERROR MSG GOES\n         MVC   0(L'CTLMS12,R2),CTLMS12  PUT ERROR MSG UNDER BAD CHAR\nF90WRITE DS    0H\n         BAL   R11,Y10WSP1              PRINT, SPACE 1\n         ABEND 16                       CANCEL JOB\n         EJECT\n***********************************************************************\n*        POINT R2 TO THE PRINT POSITION AT WHICH THE ERROR OCCURRED   *\n***********************************************************************\n         SPACE 2\nG10SET2  DS    0H\n         S     R2,EDITSAVE        R2 = DISP TO BAD CHARACTER\n         LA    R2,P(R2)           R2 -> TO WHERE ERROR MSG GOES\n         BR    R11                RETURN TO CALLER\n         EJECT\n***********************************************************************\n*        P R I N T   C O N T R O L   R O U T I N E                    *\n***********************************************************************\n         SPACE 2\nY10SKIP1 DS    0H\n         MVI   CTLCHR,X'8B'             SKIP TO CHANNEL 1\n         B     Y40\n         SPACE\nY10WSP1  DS    0H\n         MVI   CTLCHR,X'09'             PRINT, SPACE 1\n         B     Y40\n         SPACE\nY10WSP2  DS    0H\n         MVI   CTLCHR,X'11'             PRINT, SPACE 2\n         B     Y40\n         SPACE\nY10WSP3  DS    0H\n         MVI   CTLCHR,X'19'             PRINT, SPACE 3\n         SPACE\nY40      DS    0H\n         PUT   OUTFILE,PRINT            PRINT\n         MVI   P,C' '                   CLEAR PRINT BUFFER\n         MVC   P+1(L'P-1),P             *\n         SPACE\n         BR    R11                      RETURN TO CALLER\n         EJECT\n***********************************************************************\n*        F I L E   D E C L A R E S                                    *\n***********************************************************************\n         SPACE 2\n         PRINT NOGEN\nINFILE   DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GL,EODAD=A90END\nOUTFILE  DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,RECFM=FBM,LRECL=133,  +\n               BLKSIZE=9310\n         PRINT GEN\n         SPACE 2\n***********************************************************************\n*              D E C L A R A T I V E S                                *\n***********************************************************************\n         SPACE\nEDITSAVE DC    18F'0'\nELEVEN   DC    F'11'\nMAXLEN   DC    F'111'\nDWORD    DC    D'0'\nMAXPACK  DC    F'16'\nCTLHEAD  DC    C'*****  CONTROL STATEMENT LISTING  *****'\nPRINT    DS    0CL133\nCTLCHR   DC    X'09'\nP        DC    CL132' '\nINPUT    DC    C'INPUT='\nOUTPUT   DC    C'OUTPUT='\nSELECT   DC    C'SELECT='\nTAPEIN   DC    C'TAPEIN'\nCONTROL  DC    C'CONTROL=('\nHD1      DC    C'HEAD1='\nHD2      DC    C'HEAD2='\nHD3      DC    C'HEAD3='\nSTARTRDW DC    C'START=RDW'       START AT POS 1, OFFSET IN DECIMAL\nSTARTHEX DC    C'START=HEX'       START AT POS 0, OFFSET IN HEX\nCFCTR    DC    P'1'\nONE      DC    P'1'\nFIVE     DC    P'5'\nALL      DC    C'ALL'\nCTLMS1   DC    C'       INVALID CONTROL CARD IGNORED '\nCTLMS2   DC    C'       DDNAME MUST BE TAPEIN'\nCTLMS3   DC    C'       INVALID CONTROL'\nCTLMS4   DC    C'TYPE NOT P, H OR A'\nCTLMS5   DC    C'       ONLY 5 CONTROL FIELDS ALLOWED'\nCTLMS6   DC    C'START LOCATION NOT NUMERIC OR HEXADECIMAL'\nCTLMS7   DC    C'LENGTH NOT NUMERIC'\nCTLMS8   DC    C'       INVALID FILE NAME'\nCTLMS9   DC    C' LENGTH CANNOT EXCEED 111'\nCTLMS10  DC    C'CF VALUE NOT IN ( ) OR SIZE NOT = TO CONTROL SIZE'\nCTLMS11  DC    C'COMPARE OPERAND MUST BE = # > OR <'\nCTLMS12  DC    C'CF FIELD MUST BE CF1 - CF5'\nCTLMS13  DC    C'*****  END OF CONTROL CARD LISTING  *****'\nCTLMS14  DC    C'       ONLY 5 SELECTS PER FILE ALLOWED'\nOUT1     DC    C'OUT1'\nOUT2     DC    C'OUT2'\nOUT3     DC    C'OUT3'\nOUT4     DC    C'OUT4'\nOUT5     DC    C'OUT5'\nOUT6     DC    C'OUT6'\nOUT7     DC    C'OUT7'\nCFWK1    DS    CL112\nCFWK2    DS    CL112\nCFWK3    DS    CL112\nCFWK4    DS    CL112\nCFWK5    DS    CL112\nENTLTH   DC    F'580'\nWKFILL   DC    112X'FF'\nCF1      DC    C'CF1='\nCF2      DC    C'CF2='\nCF3      DC    C'CF3='\nCF4      DC    C'CF4='\nCF5      DC    C'CF5='\nZEROS    DC    12C'0'\nTRTAB    EQU   *-193              SET START OF SHORT TRANS TABLE\n         DC    X'0A0B0C0D0E0F'\n         DC    41X'00'\n         DC    X'00010203040506070809'\nR0       EQU   0                        REGISTER EQUATES\nR1       EQU   1                        *\nR2       EQU   2                        *\nR3       EQU   3                        *\nR4       EQU   4                        *\nR5       EQU   5                        *\nR6       EQU   6                        *\nR7       EQU   7                        *\nR8       EQU   8                        *\nR9       EQU   9                        *\nR10      EQU   10                       *\nR11      EQU   11                       *\nR12      EQU   12                       *\nR13      EQU   13                       *\nR14      EQU   14                       *\nR15      EQU   15                       *\n         SPACE\n*\n*              T A B L E S\n*\nTABLED   DSECT\nCONTROLS DS    0F\n         COPY  SDP10\nSELECTS  DS    0F\n         COPY  SDP20\nCTRLEDIT CSECT\n         LTORG\n         END   CTRLEDIT\n//STEP5 EXEC HLASMCL,PARMC='XREF(FULL)',\n//             PARM.LKED='OVLY,LIST,LET,MAP'\n//ASM.SYSLIB DD\n//          DD\n//    DD DSN=&&T,DISP=(SHR,PASS)\n//ASM.SYSIN DD *\n         EJECT\n***********************************************************************\n*        W R I T E   R E P O R T S   R E Q U I R E D                  *\n***********************************************************************\n         SPACE 2\nVPRINT   CSECT                          NAME CONTROL SECTION\n         USING *,R15\n         B     A10SAVE                  BRANCH AROUND IDENTIFIER\n         DC    AL1(14)\n         DC    C'VPRINT SECTION'        IDENTIFIER\nA10SAVE  DS    0H\n         DROP  R15\n         SAVE  (14,12)                  SAVE REGISTERS\n         BALR  R12,0                    LOAD BASE REGISTER\n         USING *,R12,R10,R4             ESTABLISH ADDRESSABILITY\n         LA    R11,1                    LOAD BASE REGISTER 2\n         LA    R10,4095(R11,R12)        *\n         LA    R4,4095(R11,R10)         LOAD BASE REGISTER 3\n         ST    R13,VSAVE+4              CHAIN SAVE AREAS\n         LR    R11,R13                  *\n         LA    R13,VSAVE                *\n         ST    R13,8(R11)               *\n         L     R6,0(0,R1)               LOAD DSECT BASE REG\n         USING CONTROLS,R6              ESTABLISH DSECT ADDRESSABILITY\n         SPACE 2\n         OPEN  (INFILE)                 OPEN INPUT FILE\n         SPACE 1\n         LH    R0,INFILE+82       R0 = LRECL\n         GETMAIN R,LV=(0)         GET RECORD WORK AREA\n         LTR   R15,R15            IS RC = 0 ?\n         BZ    A15OK              YES, CONTINUE\n         ABEND 4                  NO, ABEND WITH RC = 0\n         SPACE 1\nA15OK    DS    0H\n         ST    R1,RECADDR         SAVE A(RECORD AREA)\n         SPACE\nA20OPEN1 DS    0H\n         TM    OPENFLGS,B'10000000'     OPEN OUT1 ?\n         BNO   A20OPEN2                 NO, CHECK FOR OPEN OUT2\n         SPACE\n         OPEN  (OUT1DCB,(OUTPUT))       OPEN OUT1\n         NI    A50WRT1+1,X'0F'          SET SWITCH TO WRITE OUT1\n         NI    A30DATE+1,X'0F'          SET SWITCH TO GET DATE\n         NI    A70STAT1+1,X'0F'         SET STATS 1 SWITCH\n         SPACE\nA20OPEN2 DS    0H\n         TM    OPENFLGS,B'01000000'     OPEN OUT2 ?\n         BNO   A20OPEN3                 NO, OPEN OUT3?\n         SPACE\n         OPEN  (OUT2DCB,(OUTPUT))       OPEN OUT2\n         NI    A50WRT2+1,X'0F'          SET SWITCH TO WRITE OUT2\n         NI    A30DATE+1,X'0F'          SET SWITCH TO GET DATE\n         NI    A70STAT2+1,X'0F'         SET STATS 2 SWITCH\nA20OPEN3 DS    0H\n         TM    OPENFLGS,B'00100000'     OPEN OUT3 ?\n         BNO   A20OPEN4                 NO, OPEN OUT4?\n         SPACE\n         OPEN  (OUT3DCB,(OUTPUT))       OPEN OUT3\n         NI    A50WRT3+1,X'0F'          SET SWITCH TO WRITE OUT3\n         NI    A30DATE+1,X'0F'          SET SWITCH TO GET DATE\n         NI    A70STAT3+1,X'0F'         SET STATS 3 SWITCH\nA20OPEN4 DS    0H\n         TM    OPENFLGS,B'00010000'     OPEN OUT4 ?\n         BNO   A20OPEN5                 NO, OPEN OUT5 ?\n         SPACE\n         OPEN  (OUT4DCB,(OUTPUT))       OPEN OUT4\n         NI    A50WRT4+1,X'0F'          SET SWITCH TO WRITE OUT4\n         NI    A70STAT4+1,X'0F'         SET STATS 4 SWITCH ON\n         TM    OUT4DCB+36,X'58'   RECFM=V, VB, OR VBS ?\n         BNZ   *+10               YES, DON'T CHANGE IT\n         MVC   OUT4DCB+36(2),INFILE+36 NO, SET IT THE SAME AS THE INPUT\nA20OPEN5 DS    0H\n         TM    OPENFLGS,B'00001000'     OPEN OUT5 ?\n         BNO   A20OPEN6                 NO, OPEN OUT6 ?\n         SPACE\n         OPEN  (OUT5DCB,(OUTPUT))       OPEN OUT5\n         NI    A50WRT5+1,X'0F'          SET SWITCH TO WRITE OUT5\n         NI    A70STAT5+1,X'0F'         SET STATS 5 SWITCH ON\n         TM    OUT5DCB+36,X'58'   RECFM=V, VB, OR VBS ?\n         BNZ   *+10               YES, DON'T CHANGE IT\n         MVC   OUT5DCB+36(2),INFILE+36 NO, SET IT THE SAME AS THE INPUT\nA20OPEN6 DS    0H\n         TM    OPENFLGS,B'00000100'     OPEN OUT6 ?\n         BNO   A20OPEN7                 NO, OPEN OUT7 ?\n         SPACE\n         OPEN  (OUT6DCB,(OUTPUT))       OPEN OUT6\n         NI    A50WRT6+1,X'0F'          SET SWITCH TO WRITE OUT6\n         NI    A70STAT6+1,X'0F'         SET STATS 6 SWITCH ON\n         TM    OUT6DCB+36,X'58'   RECFM=V, VB, OR VBS ?\n         BNZ   *+10               YES, DON'T CHANGE IT\n         MVC   OUT6DCB+36(2),INFILE+36 NO, SET IT THE SAME AS THE INPUT\n         SPACE\nA20OPEN7 DS    0H\n         TM    OPENFLGS,X'02'           OPEN OUT7 ?\n         BNO   A25RDW             NO, START AT RDW ??\n         SPACE\n         OPEN  (OUT7DCB,(OUTPUT))       OPEN OUT7\n         NI    A50WRT7+1,X'0F'          SET SWITCH TO WRITE OUT7\n         NI    A70STAT7+1,X'0F'         SET SWITCH TO WRITE STATS7\n         SPACE\nA25RDW   CLI   STRTPOS,C'R'       START AT RDW ?\n         BNE   A26RDW             NO, START AT RDW IN HEX?\n         MVI   H4+1,X'00'         YES, START AT RDW (OFFSET 0)\n         SPACE 1\nA26RDW   CLI   STRTPOS,C'H'       START AT RDW WITH HEX OFFSET?\n         BNE   A30DATE            NO, START AT DATA (OFFSET 4)\n         MVI   H4+1,X'00'         YES, START AT RDW (OFFSET 0)\n         SPACE 1\nA30DATE  B     A40READ                  DATE SWITCH\n         BAL   R11,B10DATE              PERFORM DATE ROUTINE\n         SPACE\nA40READ  DS    0H\n         L     R0,RECADDR         R0 -> TO RECORD AREA\n         GET   INFILE,(0)               READ INPUT RECORD\n         L     R1,RECADDR         R1 -> TO INPUT RECORD\n         LH    R2,0(0,R1)               GET LTH OF RECORD+CW\n         SH    R2,H4                    DROP LTH OF CW\n         ST    R2,VRLTH                 SAVE LTH OF RECORD\n         LR    R2,R1                    POINT REG 2 TO INPUT RECORD\n         AH    R2,H4                 ADD OFFSET (0 IF RDW, 4 IF DATA)\n         AP    INCTR,ONE                ADD 1 TO RECORD COUNTER\n         SPACE\nA50WRT1  DS    0H\n         B     A50WRT2                  WRITE 1 SWITCH\n         LA    R3,A50WRT2               LOAD RETURN ADDRESS\n         LA    R5,SELECTS+0             LOAD ADDRESS OUT1 TABLE\n         L     R15,OUT1CTR              LOAD OUT1 COUNTER\n         BAL   R11,D10COMP              CHECK CONTROL FIELDS\n         SPACE\n         LA    R1,OUT1                  LOAD DCB ADDRESS\n         MVC   PHD,HEAD1                MOVE HEAD1 TO PRINT\n         BAL   R11,E10PRT               PRINT,REPORT 1\n         AP    OUTCTR1,ONE              ADD 1 TO OUT1 COUNTER\n         BAL   R3,D70BR                 RETURN TO D10COMP\n         SPACE\nA50WRT2  DS    0H\n         B     A50WRT3                  WRITE 2 SWITCH\n         LA    R3,A50WRT3               LOAD RETURN ADDRESS\n         L     R15,OUT2CTR              LOAD OUT2 COUNTER\n         LA    R5,SELECTS            LOAD ADDRESS OUT2 TABLE\n         A     R5,OFF2               *\n         BAL   R11,D10COMP              CHECK CONTROL FIELDS\n         SPACE\n         LA    R1,OUT2                  LOAD OUT2 DCB ADDRESS\n         MVC   PHD,HEAD2                MOVE HEAD2 TO PRINT\n         BAL   R11,E10PRT               PRINT REPORT 2\n         AP    OUTCTR2,ONE              ADD 1 TO OUT2 COUNTER\n         BAL   R3,D70BR                 RETURN TO D10COMP\n         SPACE\nA50WRT3  DS    0H\n         B     A50WRT4                  WRITE 3 SWITCH\n         LA    R3,A50WRT4               LOAD RETURN ADDRESS\n         L     R15,OUT3CTR              LOAD OUT3 COUNTER\n         LA    R5,SELECTS            LOAD ADDRESS OUT3 TABLE\n         A     R5,OFF3               *\n         BAL   R11,D10COMP              CHECK CONTROL FIELDS\n         SPACE\n         LA    R1,OUT3                  LOAD OUT3 DCB ADDRESS\n         MVC   PHD,HEAD3                MOVE HEAD3 TO PRINT\n         BAL   R11,E10PRT               PRINT REPORT 3\n         AP    OUTCTR3,ONE              ADD 1 TO OUT3 COUNTER\n         BAL   R3,D70BR                 RETURN TO D10COMP\n         SPACE\nA50WRT4  DS    0H\n         B     A50WRT5                  WRITE 4 SWITCH\n         LA    R3,A50WRT5               LOAD RETURN ADDRESS\n         L     R15,OUT4CTR              LOAD OUT4 COUNTER\n         LA    R5,SELECTS            LOAD ADDRESS OUT4 TABLE\n         A     R5,OFF4               *\n         BAL   R11,D10COMP              CHECK CONTROL FIELDS\n         SPACE\n         LA    R1,OUT4DCB               LOAD OUT4 DCB ADDRESS\n         BAL   R11,F10WRITE             WRITE OUT4\n         AP    OUTCTR4,ONE              ADD 1 TO OUT4 COUNTER\n         BAL   R3,D70BR                 RETURN TO D10COMP\n         SPACE\nA50WRT5  DS    0H\n         B     A50WRT6                  WRITE 5 SWITCH\n         LA    R3,A50WRT6               LOAD RETURN ADDRESS\n         L     R15,OUT5CTR              LOAD OUT5 COUNTER\n         LA    R5,SELECTS           LOAD ADDRESS OUT5 TABLE\n         A     R5,OFF5               *\n         BAL   R11,D10COMP              CHECK CONTROL FIELDS\n         SPACE\n         LA    R1,OUT5DCB               LOAD ADDRESS OUT5 DCB\n         BAL   R11,F10WRITE             WRITE OUT5\n         AP    OUTCTR5,ONE              ADD 1 TO OUT5 COUNTER\n         BAL   R3,D70BR                 RETURN TO D10COMP\n         SPACE\nA50WRT6  DS    0H\n         B     A50WRT7                  WRITE 6 SWITCH\n         LA    R3,A60LOOP               LOAD RETURN ADDRESS\n         L     R15,OUT6CTR              LOAD OUT6 COUNTER\n         LA    R5,SELECTS           LOAD OUT6 TABLE ADDRESS\n         A     R5,OFF6               *\n         BAL   R11,D10COMP              CHECK CONTROL FIELDS\n         SPACE\n         LA    R1,OUT6DCB               LOAD OUT6 DCB ADDRESS\n         BAL   R11,F10WRITE             WRITE OUT6\n         AP    OUTCTR6,ONE              ADD 1 TO OUT6 COUNTER\n         BAL   R3,D70BR                 RETURN TO D10COMP\n         SPACE\nA50WRT7  DS    0H\n         B     A60LOOP                  WRITE 7 SWITCH\n         LA    R3,A60LOOP               LOAD RETURN ADDRESS\n         L     R15,OUT7CTR              LOAD OUT7 COUNTER\n         LA    R5,SELECTS           LOAD OUT7 TABLE ADDRESS\n         A     R5,OFF7               *\n         BAL   R11,D10COMP              CHECK CONTROL FIELDS\n         SPACE\n         LA    R1,OUT7DCB               LOAD OUT7 DCB ADDRESS         1\n         BAL   R11,F50WRITE             WRITE OUT7                    2\n         AP    OUTCTR7,ONE              ADD 1 TO OUT7 COUNTER         3\n         BAL   R3,D70BR                 RETURN TO D10COMP             4\n         SPACE\nA60LOOP  DS    0H\n         B     A40READ\n         SPACE\nA70STATS DS    0H\n         OPEN  (SYSOUT,(OUTPUT))        OPEN SYSPRINT FILE\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         MVI   P,C' '                    CLEAR PRINT LINE\n         MVC   P+1(L'P-1),P             *\n         MVC   SEDWDUT1,PLEDWD1         EDIT INPUT RECORDS COUNTER\n         ED    SEDWDUT1,INCTR           *\n         MVC   P(L'SHDUT1),SHDUT1       MOVE STATS HEAD TO PRINT\n         BAL   R11,Y10WSP2              PRINT, SPACE 2\n         SPACE\nA70STAT1 DS    0H\n         B     A70STAT2                 STATS 1 SWITCH\n         MVC   SEDWD1,PLEDWD1           EDIT OUT1 COUNTER\n         ED    SEDWD1,OUTCTR1           *\n         MVC   P(L'SHD1),SHD1           MOVE STATS TO PRINT\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         BAL   R11,Y10WSP2              PRINT STATS 1\n         SPACE\nA70STAT2 DS    0H\n         B     A70STAT3                 STATS 2 SWITCH\n         MVC   SEDWD2,PLEDWD1           EDIT OUT2 COUNTER\n         ED    SEDWD2,OUTCTR2           *\n         MVC   P(L'SHD2),SHD2           MOVE STATS2 HEADING TO PRINT\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         BAL   R11,Y10WSP2              PRINT STATS 2\n         SPACE\nA70STAT3 DS    0H\n         B     A70STAT4                 STATS 3 SWITCH\n         MVC   SEDWD3,PLEDWD1           EDIT OUT3 COUNTER\n         ED    SEDWD3,OUTCTR3           *\n         MVC   P(L'SHD3),SHD3           MOVE STATS 3 HEAD TO PRINT\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         BAL   R11,Y10WSP2              PRINT STATS 3\n         SPACE\nA70STAT4 DS    0H\n         B     A70STAT5                 STATS 4 SWITCH\n         MVC   SEDWD4,PLEDWD1           EDIT OUT4 COUNTER\n         ED    SEDWD4,OUTCTR4           *\n         MVC   P(L'SHD4),SHD4           MOVE STATS 4 HEAD TO PRINT\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         BAL   R11,Y10WSP2              PRINT STATS 4\n         SPACE\nA70STAT5 DS    0H\n         B     A70STAT6                 STATS 5 SWITCH\n         MVC   SEDWD5,PLEDWD1           EDIT OUT5 COUNTER\n         ED    SEDWD5,OUTCTR5           *\n         MVC   P(L'SHD5),SHD5           MOVE STATS HEAD 5 TO PRINT\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         BAL   R11,Y10WSP2              PRINT STATS 5\n         SPACE\nA70STAT6 DS    0H\n         B     A70STAT7                 STATS 6 SWITCH\n         MVC   SEDWD6,PLEDWD1           EDIT OUT6 COUNTER\n         ED    SEDWD6,OUTCTR6           *\n         MVC   P(L'SHD6),SHD6           MOVE STATS 6 HEAD TO PRINT\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         BAL   R11,Y10WSP2              PRINT STATS 6\n         SPACE\nA70STAT7 DS    0H\n         B     A90END                   STATS 7 SWITCH\n         MVC   SEDWD7,PLEDWD1           EDIT OUT7 COUNTER\n         ED    SEDWD7,OUTCTR7           *\n         MVC   P(L'SHD7),SHD7           MOVE STATS 7 HEAD TO PRINT\n         LA    R1,OUT4            R1 -> TO SYSOUT PARMS\n         BAL   R11,Y10WSP2              PRINT STATS 7\n         SPACE\nA90END   DS    0H\n         L     R13,VSAVE+4              RETURN TO ROOT SECTION\n         RETURN (14,12),RC=0            *\n         SPACE 2\nOFF2     DC    F'2900'               OFFSET TO CF2\nOFF3     DC    F'5800'               OFFSET TO CF3\nOFF4     DC    F'8700'               OFFSET TO CF4\nOFF5     DC    F'11600'              OFFSET TO CF5\nOFF6     DC    F'14500'              OFFSET TO CF6\nOFF7     DC    F'17400'              OFFSET TO CF7\n         EJECT\n***********************************************************************\n*        R O U T I N E   T O   S E T   U P   D A T E                  *\n***********************************************************************\n         SPACE 2\nB10DATE  DS    0H\n         TIME  DEC                      GET DATE\n         ST    R1,DWRK1                 STORE DATE\n         MVO   DWRK2,DWRK1(2)           SAVE DAY\n         UNPK  HD1YR,DWRK2+1(2)         UNPACK YEAR\n         MVZ   HD1YR+1(1),HD1YR         CHANGE ZONE TO F\n         SPACE\n         DP    DWRK2,FOUR               DIVIDE YEAR BY 4\n         CP    DWRK2+2(1),ZERO          REMAINDER = 0 ?\n         BNE   B30NOLEP                 NO, GO TO PROCESS NO LEAP YEAR\n         SPACE\n         LA    R7,YTAB3+6               ADD 1 TO JULIAN DAY\n         LA    R8,10                    IN TABLE TO COMPENSATE\nB20LEAP  AP    0(2,R7),ONE              FOR LEAP YEAR TO\n         LA    R7,8(R7)                 MONTHS MARCH\n         BCT   R8,B20LEAP               TO DECEMBER\n         SPACE\nB30NOLEP DS    0H\n         ZAP   DWRK3,DWRK1+2(2)         MOVE JULIAN DAY TO WORK AREA\n         LA    R7,TABEND                LOAD ADDRESS TABLE END\n         LA    R8,8                     LOAD 8\nB40      DS    0H\n         CP    6(2,R7),DWRK3            COMPARE JUL DAY TO TABLE JUL\n         BL    B50                      BRANCH LOW\n         SR    R7,R8                    POINT TO NEXT ENTRY\n         B     B40                      LOOP BACK TO  40\n         SPACE\nB50      DS    0H\n         MVC   HD1MTH,4(R7)             MOVE MONTH TO REPORT DATE\n         SP    DWRK3,6(2,R7)            SUBTRACT JUL DAY IN TABLE\n         ED    HD1DAY,DWRK3             FROM CURRENT JUL DAY AND EDIT\n         SPACE\nB90END   DS    0H\n         BR    R11                      RETURN TO CALLER\n         SPACE 2\n         CNOP  0,4                      ALIGN ON FULLWORD BOUNDARY\nDWRK1    DC    PL4'0'\nDWRK2    DC    PL3'0'\nDWRK3    DC    PL2'0'\nFOUR     DC    P'4'\nZERO     DC    P'0'\n         SPACE\nYTAB     DC    C' JAN01'\n         DC    P'000'\n         DC    C' FEB02'\n         DC    P'031'\nYTAB3    DC    C' MAR03'\n         DC    P'059'\n         DC    C' APR04'\n         DC    P'090'\n         DC    C' MAY05'\n         DC    P'120'\n         DC    C'JUNE06'\n         DC    P'151'\n         DC    C'JULY07'\n         DC    P'181'\n         DC    C' AUG08'\n         DC    P'212'\n         DC    C'SEPT09'\n         DC    P'243'\n         DC    C' OCT10'\n         DC    P'273'\n         DC    C' NOV11'\n         DC    P'304'\nTABEND   DC    C' DEC12'\n         DC    P'334'\n         EJECT\n***********************************************************************\n*        C O M P A R E   C O N T R O L   F I E L D S   T O   T A B L E*\n***********************************************************************\n         SPACE 2\nD10COMP  DS    0H\n         ST    R11,STORED               SAVE RETURN ADDRESS\nD10STBCT LA    R7,5                     LOAD 5 IN REG 7\n         NI    OPENFLGS,X'FE'           TURN WRITE SWITCH OFF\n         ST    R15,STORED4              SAVE OUT COUNTER\n         SPACE\nD20LOOP  DS    0H\n         CLI   5(R5),X'FF'              SELECT CF USED ?\n         BE    D60PTCF                  NO, CHECK NEXT CF\n         SPACE\n         CLI   4(R5),C'0'               SELECT ALL VALUES ?\n         BE    D50SWON                  YES, TURN WRITE SWITCH ON\n         SPACE\n         LA    R8,CONTROLS              LOAD CONTROLS ADDRESS\n         A     R8,0(R0,R5)              ADD DISPLACEMENT FROM SELECTAB\n         SPACE\n         L     R11,VRLTH                GET LTH OF VARIABLE RECORD\n         C     R11,0(0,R8)              START LOC IN RECORD ?\n         BL    D40NO                    NO, CAN'T COMPARE THIS FIELD\n         LR    R1,R2                    POINT TO VARIABLE RECORD\n         SPACE\nD20OUT   DS    0H\n         A     R1,0(R0,R8)              ADD START TO RECORD ADDRESS\n         L     R9,4(R8)                 MOVE LENGTH TO REG 9\n         SPACE\nD40SETBR DS    0H\n         MVC   D40BR+1(1),4(R5)         SET BRANCH CONDITION\n         EX    R9,D40CLC                COMPARE\nD40BR    BC    0,D50SWON                BRANCH\n         SPACE\nD40NO    DS    0H\n         NI    OPENFLGS,X'FE'           TURN WRITE SWITCH OFF\n         LR    R11,R7                R11 = NBR OF CF'S LEFT\n         MH    R11,H116              R11 * 116 = LTH OF CF'S LEFT\n         AR    R5,R11                R5 -> TO NEXT CF SET FOR THIS OUT\n         B     D70BR                    CONDITION NOT MET, REJECT TEST\n         SPACE\nD40CLC   CLC   0(0,R1),5(R5)            COMPARE\n         SPACE\nD50SWON  DS    0H\n         OI    OPENFLGS,X'01'           TURN WRITE SWITCH ON\n         SPACE\nD60PTCF  DS    0H\n         LA    R5,116(R5)               POINT TO NEXT CF\nH116     EQU   *-2                   HALFWORD OF 116\n         BCT   R7,D20LOOP               5 CF'S PROCESSED ?\n         TM    OPENFLGS,X'01'           YES, WRITE RECORD ?\n         BNO   D70BR                    NO, GO TO D70BR\n         SPACE\n         L     R11,STORED               LOAD RETURN ADDRESS\n         BR    R11                      RETURN TO WRITE RECORD\n         SPACE\nD70BR    DS    0H\n         TM    OPENFLGS,X'01'           RECORD ALREADY WRITTEN ?\n         BO    D80BR                    YES, CHECK NEXT FILE\n         SPACE\n         L     R15,STORED4              LOAD OUT COUNTER\n         BCT   R15,D10STBCT             ANY MORE OUTS FOR THIS TEST ?\nD80BR    DS    0H\n         BR    R3                       NO, SET UP NEXT OUT TEST\n         SPACE\nSTORED   DS    F\nSTORED4  DS    F                        OUT COUNTER\n         EJECT\n***********************************************************************\n*        R O U T I N E   T O   P R I N T   R E P O R T S   1,2,3      *\n***********************************************************************\n         SPACE 2\nE10PRT   DS    0H\n         ST    R11,STORE1               SAVE RETURN ADDRESS\n         ST    R1,STORE2          SAVE A(OUT1) PARMS\n         L     R7,VRLTH           R7 = VARIABLE RECORD LTH\n         LR    R9,R2              R9 -> TO V RECORD\nE20LOOP  L     R3,8(0,R1)         R3 -> LINE COUNTER\n         CP    0(3,R3),FULLPAGE   IS PAGE FULL ?\n         BL    E30                NO\n         BAL   R11,Y10SKIP1       YES, SKIP TO NEW PAGE\n         L     R1,STORE2          R1 -> TO PARMS\n         BAL   R11,Y10SPCE3       SKIP DOWN 3 LINES\n         L     R1,STORE2          R1 -> TO PARMS\n         L     R3,4(0,R1)         R3 -> TO PAGE COUNTER\n         MVC   HD1PAGE,PLEDWD1    EDIT PAGE COUNTER\n         ED    HD1PAGE,0(R3)      *\n         MVC   P(L'PHD),PHD       MOVE HEADING TO PRINT\n         MVC   P+100(L'HD1),HD1   *\n         BAL   R11,Y10WSP2        PRINT HEADING, SPACE 2\n         SPACE\nE30      DS    0H\n         LA    R8,132             R8 = LTH OF OUTPUT LINE\nH132     EQU   *-2                HALFWORD 132\nE40      DS    0H\n         CR    R7,R8              REC LTH OVER 132?\n         BH    E50                YES, PRINT IN 132 BYTE CHUNKS\n         SPACE\n         SH    R7,H1              R7 = LRECL - 1\n         EX    R7,MOVETOP         MOVE DATA TO PRINT LINE\n         L     R1,STORE2          R1 -> TO PARMS\n         BAL   R11,Y10WSP2        PRINT LAST LINE, SPACE 2\n         L     R11,STORE1         LOAD RETURN ADDRESS\n         BR    R11                GO BACK TO CALLER\n         SPACE\nE50      DS    0H\n         SH    R8,H1              R8= 131\n         EX    R8,MOVETOP         MOVE 132 BYTES TO PRINT\n         L     R1,STORE2          R1 -> TO PARMS\n         BAL   R11,Y10WSP1        PRINT,SPACE 1\n         SPACE\n         SH    R7,H132            R7 = LRECL REMAINING\n         AH    R9,H132            R9 -> TO NEXT PART OF RECORD\n         L     R1,STORE2          R1 -> TO PARMS\n         B     E20LOOP            PRINT NEXT CHUNK OF RECORD\n         SPACE 2\nMOVETOP  MVC   P(1),0(R9)         MOVE DATA TO P\nFULLPAGE DC    PL3'50'\nH1       DC    H'1'\nH4       DC    H'4'\nOUT1     DC    A(OUT1DCB)\n         DC    A(PAGECTR1)\n         DC    A(LINECTR1)\n         SPACE\nOUT2     DC    A(OUT2DCB)\n         DC    A(PAGECTR2)\n         DC    A(LINECTR2)\n         SPACE\nOUT3     DC    A(OUT3DCB)\n         DC    A(PAGECTR3)\n         DC    A(LINECTR3)\n         SPACE\nOUT4     DC    A(SYSOUT)\n         DC    A(PAGECTR4)\n         DC    A(LINECTR4)\n         SPACE\nPAGECTR4 DC    PL3'0'\nLINECTR4 DC    PL3'75'\n         SPACE\n         SPACE\nSTORE1   DS    F                        RETURN ADDRESS\nSTORE2   DS    F\nSTORE5   DS    F\nSTOREDCB DS    F                        DCB ADDRESS\nNINES    DC    C' 999999999'\nSPACES   DC    CL10' '\nPHD      DS    CL74\n         EJECT\n***********************************************************************\n*        R O U T I N E   T O   P R I N T   R E P O R T S   4,5,6      *\n***********************************************************************\n         SPACE 2\nF10WRITE DS    0H\n         L     R0,RECADDR               R0 -> TO RECORD\n         PUT   (1),(0)                  PRINT\n         BR    R11                      RETURN\n         SPACE\nF50WRITE DS    0H\n         PUT   (1)                      GET OUTPUT AREA\n         LR    R15,R1                   R15 -> TO OUTPUT BUFFER\n         L     R7,VRLTH                 R7 = LTH OF INPUT RECORD\n         LH    R8,OUT7DCB+82            R8 = OUTPUT LRECL\n         SPACE\nF55COMP  DS    0H\n         CH    R8,H256            LRECL OVER 256 ?\n         BH    F60                YES, CLEAR IN CHUNKS\n         SPACE\n         SH    R8,=H'2'           R8 = LRECL - 2\n         MVI   0(R1),X'40'        CLEAR BUFFER\n         EX    R8,CLEAROUT        *\n         B     F65MOVE            MOVE INPUT TO OUTPUT\n         SPACE\nF60      DS    0H\n         MVI   0(R1),X'40'        CLEAR OUTPUT BUFFER\n         MVC   1(255,R1),0(R1)    *\n         LA    R1,256(R1,0)       ADD 256 TO R1\nH256     EQU   *-2                HALFWORD 256\n         SH    R8,H256            R8 = LRECL - 256\n         B     F55COMP            CLEAR NEXT CHUNK OF BUFFER\n         SPACE\nF65MOVE  DS    0H\n         LR    R3,R2              R3 -> TO INPUT RECORD\n         LH    R8,OUT7DCB+82      R8 = OUTPUT LRECL\n         CR    R7,R8              IS OUTPUT LONGER THAN INPUT ?\n         BL    F70COMP2           YES, MOVE ALL OF INPUT\n         LR    R7,R8              NO, MOVE OUTPUT LENGTH ONLY\n         SPACE\nF70COMP2 DS    0H\n         CH    R7,H256            INPUT LTH OVER 256 ?\n         BH    F80                YES, MOVE IN CHUNKS\n         SH    R7,H1              R7 = IBM LTH OF INPUT\n         EX    R7,MOVEDATA        MOVE INPUT TO OUTPUT\n         BR    R11                RETURN TO CALLER\n         SPACE\nCLEAROUT MVC   1(0,R1),0(R1)      CLEAR BUFFER\nMOVEDATA MVC   0(0,R15),0(R3)     MOVE INPUT TO OUTPUT\n         SPACE\nF80      DS    0H\n         MVC   0(256,R15),0(R3)   MOVE INPUT TO OUTPUT\n         SH    R7,H256            R7 = LTH LEFT\n         AH    R3,H256            R3 -> REST OF INPUT\n         AH    R15,H256           R15 -> TO REST OF OUTPUT\n         B     F70COMP2           MOVE REST OF DATA\n         EJECT\n***********************************************************************\n*        P R I N T E R   A N D   C A R R I A G E   C O N T R O L      *\n***********************************************************************\n         SPACE 2\nY10SKIP1 DS    0H\n         MVI   CTLCHR,X'8B'             SKIP1 TO CHANNEL 1\n         L     R3,4(0,R1)         R3 -> TO PAGE COUNTER\n         AP    0(3,R3),ONE        ADD 1 TO PAGE COUNT\n         L     R3,8(0,R1)         R3 -> TO LINE COUNTER\n         SP    0(3,R3),0(3,R3)    CLEAR LINE COUNTER\n         B     Y40\n         SPACE\nY10SPCE1 DS    0H\n         MVI   CTLCHR,X'0B'             SPACE 1 IMMEDIATE\n         L     R3,8(0,R1)         R3 -> TO LINE COUNTER\n         AP    0(3,R3),ONE        ADD 1 TO LINE COUNT\n         B     Y40\n         SPACE\nY10SPCE2 DS    0H\n         MVI   CTLCHR,X'13'             SPACE 2 IMMEDIATE\n         L     R3,8(0,R1)         R3 -> TO LINE COUNTER\n         AP    0(3,R3),TWO        ADD 2 TO LINE COUNTER\n         B     Y40\n         SPACE\nY10SPCE3 DS    0H\n         MVI   CTLCHR,X'1B'             SPACE 3 IMMEDIATE\n         L     R3,8(0,R1)         R3 -> TO LINE COUNTER\n         AP    0(3,R3),THREE      ADD 3 TO LINE COUNTER\n         B     Y40\n         SPACE\nY10WSP1  DS    0H\n         MVI   CTLCHR,X'09'             PRINT, SPACE 1\n         L     R3,8(0,R1)         R3 -> TO LINE COUNTER\n         AP    0(3,R3),ONE        ADD 1 TO LINE COUNTER\n         B     Y40\n         SPACE\nY10WSP2  DS    0H\n         MVI   CTLCHR,X'11'             PRINT, SPACE 2\n         L     R3,8(0,R1)         R3 -> TO LINE COUNTER\n         AP    0(3,R3),TWO        ADD 2 TO LINE COUNTER\n         B     Y40\n         SPACE\nY10WSP3  DS    0H\n         MVI   CTLCHR,X'19'             PRINT, SPACE 3\n         L     R3,8(0,R1)         R3 -> TO LINE COUNTER\n         AP    0(3,R3),THREE      ADD 3 TO LINE COUNTER\n         SPACE\nY40      DS    0H\n         L     R1,0(0,R1)               LOAD DCB ADDRESS\n         PUT   (1),PRINT                PRINT\n         MVI   P,C' '                   CLEAR PRINT BUFFER\n         MVC   P+1(L'P-1),P             *\n         SPACE\n         BR    R11                      RETURN\n         EJECT\n***********************************************************************\n*        IF THERE IS NO RECFM, LRECL OR BLKSIZE ON FILES              *\n*        OUT4, OUT5, OUT6 OR OUT7 AND THE OPEN BOMBS, WE              *\n*        WILL TRY TO RECOVER BY MAKING THEIR DCB INFORMATION          *\n*        THE SAME AS THE INPUT FILE.                                  *\n***********************************************************************\n         SPACE 2\nDCBEXIT  DS    0H\n         USING DCBEXIT,R15        SET BASE ADDRESSABLITY\n         CLI   36(R1),X'00'       RECFM SET ?\n         BNE   DCB10              YES, CHECK BLKSIZE\n         MVC   36(1,R1),INFILE+36 NO, SET SAME AS INPUT FILE\n         SPACE 1\nDCB10    DS    0H\n         CLC   62(2,R1),DWRK1     BLKSIZE SET ?\n         BNE   DCB20              YES, CHECK LRECL\n         MVC   62(2,R1),INFILE+62 NO, SET SAME AS INPUT FILE\n         SPACE 1\nDCB20    DS    0H\n         CLC   82(2,R1),DWRK1     LRECL SET ?\n         BNE   DCB30              YES, GO BACK TO OPEN\n         MVC   82(2,R1),INFILE+82 NO, SET SAME AS INPUT FILE\n         SPACE 1\nDCB30    DS    0H\n         BR    R14                GO BACK TO OPEN\n         DROP  R15                DROP R15 AS A BASE\n         EJECT\n***********************************************************************\n*        F I L E    D E C L A R E S   F O R   V P R I N T             *\n***********************************************************************\n         SPACE 2\n         PRINT NOGEN\nOUT1DCB  DCB   DDNAME=OUT1,DSORG=PS,MACRF=PM,RECFM=FBM,                +\n               LRECL=133,BLKSIZE=665\nOUT2DCB  DCB   DDNAME=OUT2,DSORG=PS,MACRF=PM,RECFM=FBM,                +\n               LRECL=133,BLKSIZE=665\nOUT3DCB  DCB   DDNAME=OUT3,DSORG=PS,MACRF=PM,RECFM=FBM,                +\n               LRECL=133,BLKSIZE=665\nOUT4DCB  DCB   DDNAME=OUT4,DSORG=PS,MACRF=PM,EXLST=BLKEXLST\nOUT5DCB  DCB   DDNAME=OUT5,DSORG=PS,MACRF=PM,EXLST=BLKEXLST\nOUT6DCB  DCB   DDNAME=OUT6,DSORG=PS,MACRF=PM,EXLST=BLKEXLST\nOUT7DCB  DCB   DDNAME=OUT7,DSORG=PS,MACRF=PL,RECFM=FB,EXLST=BLKEXLST\nBLKEXLST DC    X'85',AL3(DCBEXIT)\nINFILE   DCB   DDNAME=TAPEIN,DSORG=PS,MACRF=GM,EODAD=A70STATS\nSYSOUT   DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,RECFM=FBM,            +\n               LRECL=133,BLKSIZE=665\n         PRINT GEN\n         SPACE 2\n***********************************************************************\n*        D E C L A R A T I V E S   F O R   V P R I N T                *\n***********************************************************************\n         SPACE\nVSAVE    DC    18F'0'                   REGISTER SAVE AREA\nVRLTH    DC    F'0'\nRECADDR  DC    F'0'\nPAGECTR1 DC    PL3'0'                   OUT1 PAGE COUNTER\nPAGECTR2 DC    PL3'0'                   OUT2 PAGE COUNTER\nPAGECTR3 DC    PL3'0'                   OUT3 PAGE COUNTER\nLINECTR1 DC    PL3'75'            OUT1 LINE COUNTER\nLINECTR2 DC    PL3'75'            OUT2 LINE COUNTER\nLINECTR3 DC    PL3'75'            OUT3 LINE COUNTER\nINCTR    DC    PL4'0'                   INPUT RECORDS COUNTER\nOUTCTR1  DC    PL4'0'                   RECORDS ON OUT1 COUNTER\nOUTCTR2  DC    PL4'0'                   RECORDS ON OUT2 COUNTER\nOUTCTR3  DC    PL4'0'                   RECORDS ON OUT3 COUNTER\nOUTCTR4  DC    PL4'0'                   RECORDS ON OUT4 COUNTER\nOUTCTR5  DC    PL4'0'                   RECORDS ON OUT5 COUNTER\nOUTCTR6  DC    PL4'0'                   RECORDS ON OUT6 COUNTER\nOUTCTR7  DC    PL4'0'             RECORDS ON OUT7 COUNTER\nONE      DC    P'1'\nTWO      DC    P'2'\nTHREE    DC    P'3'\nHD1      DS    0CL30\n         DC    C'DATE'\nHD1DAY   DC    X'40202020'\n         DC    C'/'\nHD1MTH   DS    CL2\n         DC    C'/'\nHD1YR    DS    CL2\n         DC    CL10'     PAGE'\nHD1PAGE  DS    CL6\nPRINT    DS    0CL133\nCTLCHR   DC    X'09'\nP        DS    CL132\nPLEDWD1  DC    12X'4020202020202020212040'\n         SPACE\n*                                       END OF FILE MESSAGES\n         SPACE\nSHD1     DS    0CL58\n         DC    CL20' '\nSEDWD1   DS    CL8\n         DC    CL30'  RECORDS WRITTEN ON OUT1'\nSHD2     DS    0CL58\n         DC    CL20' '\nSEDWD2   DS    CL8\n         DC    CL30'  RECORDS WRITTEN ON OUT2'\nSHD3     DS    0CL58\n         DC    CL20' '\nSEDWD3   DS    CL8\n         DC    CL30'  RECORDS WRITTEN ON OUT3'\nSHD4     DS    0CL58\n         DC    CL20' '\nSEDWD4   DS    CL8\n         DC    CL30'  RECORDS WRITTEN ON OUT4'\nSHD5     DS    0CL58\n         DC    CL20' '\nSEDWD5   DS    CL8\n         DC    CL30'  RECORDS WRITTEN ON OUT5'\nSHD6     DS    0CL58\n         DC    CL20' '\nSEDWD6   DS    CL8\n         DC    CL30'  RECORDS WRITTEN ON OUT6'\nSHD7     DS    0CL58\n         DC    CL20' '\nSEDWD7   DS    CL8\n         DC    CL30'  RECORDS WRITTEN ON OUT7'\nSHDUT1   DS    0CL58\n         DC    CL20' '\nSEDWDUT1 DS    CL8\n         DC    CL30'  RECORDS READ ON TAPEIN'\n         SPACE\n         LTORG\nR0       EQU   0                       REGISTER EQUATES\nR1       EQU   1                       *\nR2       EQU   2                       *\nR3       EQU   3                       *\nR4       EQU   4                       *\nR5       EQU   5                       *\nR6       EQU   6                       *\nR7       EQU   7                       *\nR8       EQU   8                       *\nR9       EQU   9                       *\nR10      EQU   10                      *\nR11      EQU   11                      *\nR12      EQU   12                      *\nR13      EQU   13                      *\nR14      EQU   14                      *\nR15      EQU   15                      *\nCONTROLS DSECT\n         COPY  SDP10\nSELECTS  DS    0F\n         COPY  SDP20\nVPRINT   CSECT\n         END   VPRINT\n//LKED.SYSLMOD DD DSN=HALL.LINKLIB(VSPLITN),DISP=SHR\n//\n//*                 NO OVERLAY FOR TESTING...\n//*\n//LKED.OLDIN DD *\n         ENTRY ROOTSECT\n       OVERLAY ONE\n        INSERT CTRLEDIT\n       OVERLAY ONE\n        INSERT VPRINT\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VSPLITJ": {"ttr": 22277, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03?\\x00\\x99\\x03?\\x13E\\x00[\\x00[\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-02T00:00:00", "modifydate": "1999-02-02T13:45:00", "lines": 91, "newlines": 91, "modlines": 0, "user": "RH87944"}, "text": "//VSPLITJ  JOB\n/*ROUTE  PRINT R7\n//*\n//*            DSN=CBT.SOURCE(VSPLITJ)\n//*\n//IMSLOG PROC  MODE=TEST,V=\n//*********************************************************************\n//*\n//*      SPLIT OFF RECORDS FROM LOG FOR SPECIFIED TIME\n//*\n//*********************************************************************\n//TIME  EXEC PGM=VSPLIT\n//STEPLIB DD DSN=HALL.LINKLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//OUT1 DD SYSOUT=*\n//TAPEIN   DD  DSN=IMSVS.TRIME.ONLINE.&MODE..IMSLOG,\n//         DISP=SHR,\n//         DCB=EROPT=SKP,UNIT=CART,\n//         VOL=(,,,20,SER=(&V.))\n//*UT4 DD DSN=&&REPORT,DISP=(,PASS),UNIT=SYSDA,\n//OUT4 DD DSN=HALL.REPORT,DISP=(,CATLG),UNIT=SYSDA,\n//             SPACE=(CYL,(10,5),RLSE),\n//             DCB=(RECFM=VB,LRECL=22552,BLKSIZE=22556)\n//*\n//  PEND\n//*\n//*\n//OLDS     PROC  MODE=TEST,N=01\n//*********************************************************************\n//*\n//*      SPLIT OFF RECORDS FROM LOG FOR SPECIFIED TIME\n//*\n//*********************************************************************\n//TIME  EXEC PGM=VSPLIT\n//STEPLIB DD DSN=HALL.LINKLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//OUT1 DD SYSOUT=*\n//TAPEIN   DD  DSN=IMSVS.&MODE..OLP&N,\n//         DISP=SHR\n//*UT4 DD DSN=&&REPORT,DISP=(,PASS),UNIT=SYSDA,\n//OUT4 DD DSN=HALL.REPORT,DISP=(,CATLG),UNIT=SYSDA,\n//             SPACE=(CYL,(10,5),RLSE),\n//             DCB=(RECFM=VB,LRECL=22552,BLKSIZE=22556)\n//*\n//  PEND\n//*********************************************************************\n//*\n//*      END OF PROCS, START OF RUN JCL\n//*\n//*********************************************************************\n//*\n//DELETE EXEC  PGM=IEFBR14\n//DD1    DD    DSN=HALL.REPORT,DISP=(MOD,DELETE),UNIT=DISK,\n//             SPACE=(TRK,1)\n//*\n//*      USE THIS EXEC IF INPUT ON TAPE\n//*\n//STEP1  EXEC  IMSLOG,MODE=TEST,V=C08498\n//*\n//*\n//*      USE THIS EXEC IF INPUT IN OLDS\n//*\n//*TEP1  EXEC  OLDS,MODE=TEST,N=01\n//*\n//*\n//*\n//*      REST OF JCL FOR ABOVE EXEC STATEMENT\n//*\n//*      VSPLIT CONTROL CARDS\n//*\n//TIME.SAMPLE DD *\nINPUT=TAPEIN,CONTROL=(1,2,H,13,4,H,13,4,H,5,4,A)\nOUTPUT=OUT4\nSELECT=OUT4,CF1=(=67),CF2=(>1450),CF3=(<1520),CF4=(#IOPX)\n/*                |         |           |           |\n//*               |         |           |           |DROP SUPER-OPT\n//*               |         |           |END TIME\n//*               |         |START TIME\n//*               |RECORD TYPE\n//*\n//TIME.SYSIN DD *\nINPUT=TAPEIN,CONTROL=(1,2,H,13,4,H,13,4,H,5,4,A)\nOUTPUT=OUT4\nSELECT=OUT4,CF1=ALL,CF2=(>1300),CF3=(<1500)\n/*                |         |           |\n//*               |         |           |\n//*               |         |           |END TIME\n//*               |         |START TIME\n//*               |RECORD TYPE\n//*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WHOAMI": {"ttr": 22280, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03?\\x00\\x99\\x03?\\x129\\x00\\xb8\\x00\\xb8\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-02T00:00:00", "modifydate": "1999-02-02T12:39:00", "lines": 184, "newlines": 184, "modlines": 0, "user": "RH87944"}, "text": "//WHOAMI   JOB\n/*ROUTE  PRINT  R7\n//*\n//*  THIS MUST BE COMPILED AND PUT INTO YOUR IMS PGMLIB...\n//*  AND DO WHATEVER ELSE IS NEEDED TO CREATE A TRANSACTION\n//*\n1/**********  WHOAMI - ONLINE TRANSACTION - D. EHLE      **************/\n /*                                                                   */\n /* SOURCE MODULE : WHOAMI\n /*                                                                   */\n /* ENABLED FOR IP LISTENER SUPPORT                                  */\n /*                                                                   */\n /* POINTER PARAMETERS ARE USE AS FOLLOWS:                            */\n /*         IO_PCB_PTR..........POINTS TO IO PCB                      */\n /*         ALT_PCB_PTR.........POINTS TO ALT IO PCB                  */\n /*                                                                   */\n /*********************************************************************/\n0   DLITPLI:   PROC(IO_PCB_PTR,ALT_PCB_PTR) OPTIONS(MAIN);\n1/*********************************************************************/\n /*                                                                   */\n /* DEFINES PCB STRUCTURES                                            */\n /*                                                                   */\n /*********************************************************************/\n               DCL  PLIXOPT CHAR(32) VAR STATIC EXT\n                    INIT('ISA(20K),NOSTAE,NOSPIE');\n DCL SYSPRINT FILE STREAM OUTPUT PRINT ; /* DIAGNOSTICS FILE          */\n               DCL  ALT_PCB_PTR     POINTER,\n                    IO_PCB_PTR      POINTER;\n               DCL  1 IO_PCB        BASED(IO_PCB_PTR),\n                      2 TERMINAL    CHAR(8),\n                      2 RESERVE     CHAR(2),\n                      2 STAT_CODE   CHAR(2),\n                      2 PREFIX,\n                        3 DATE      FIXED DEC(7),\n                        3 TIME      FIXED DEC(7),\n                        3 MSG_CTR   FIXED BIN(31),\n                      2 MOD_NAME    CHAR(8),\n                      2 USER_ID     CHAR(8);\n               DCL  1 ALT_PCB       BASED(ALT_PCB_PTR),\n                      2 TERMINAL    CHAR(8),\n                      2 RESERVE     CHAR(2),\n                      2 STAT_CODE   CHAR(2),\n                      2 PREFIX,\n                        3 DATE      FIXED DEC(7),\n                        3 TIME      FIXED DEC(7),\n                        3 MSG_CTR   FIXED BIN(31),\n                      2 MOD_NAME    CHAR(8),\n                      2 USER_ID     CHAR(8);\n1/*********************************************************************/\n /*                                                                   */\n /* DEFINES VARIABLES REQUIRED FOR DLI CALLS                          */\n /*                                                                   */\n /*********************************************************************/\n0              DCL  PLITDLI   EXT  ENTRY;\n0              DCL  PLIADLI   EXT  ENTRY;\n0/*********************************************************************/\n /*                                                                   */\n /*                 PARAMETER COUNTS                                  */\n /*                                                                   */\n /*********************************************************************/\n0              DCL (PARM_CNT,/* FOR VARIABLE NUMBER */\n                    TWO       INIT(2),\n                    THREE     INIT(3),\n                    FOUR      INIT(4),\n                    FIVE      INIT(5))  FIXED BIN(31) STATIC;\n0/*********************************************************************/\n /*                                                                   */\n /*                    FUNCTION CODES                                 */\n /*                                                                   */\n /*********************************************************************/\n0              DCL (GU        INIT('GU  '),\n                    GN        INIT('GN  '),\n                    PURG      INIT('PURG'),\n                    CMD       INIT('CMD '),\n                    GCMD      INIT('GCMD'),\n                    CHNG      INIT('CHNG'),\n                    ISRT      INIT('ISRT')) CHAR(4) STATIC;\n0/*********************************************************************/\n /*                                                                   */\n /*                    RETURN CODES                                   */\n /*                                                                   */\n /*********************************************************************/\n0              DCL (BB        INIT('  '),     /* STATUS OK            */\n                    CC        INIT('CC'),     /* MORE CMD RESPONSES   */\n                    QC        INIT('QC'),     /* END OF INPUT MSG     */\n                    GE        INIT('GE'))     /* NO MORE DATA FOUND   */\n                                             CHAR(2) STATIC;\n1/*********************************************************************/\n /*                                                                   */\n /* DEFINES I/O MESSAGE AREAS                                         */\n /*                                                                   */\n /*********************************************************************/\n0              DCL  1 IN_MSG       STATIC,\n                      2 LL         FIXED BIN(31),\n                      2 ZZ         BIT(16),\n                      2 TRX_CODE   CHAR(6),\n                      2 SPACE1     CHAR(1),\n                      2 MODE       CHAR(1),\n                      2 TEXT       CHAR(50);\n0              DCL  1 OUT_MSG1     STATIC,\n                      2 LL         FIXED BIN(31) INIT(80),\n                      2 ZZ         BIT(16)       INIT((16)'0'B),\n                      2 TEXT1      CHAR(8)\n                        INIT('YOU ARE '),\n                      2 USER_ID    CHAR(8),\n                      2 TEXT2      CHAR(9)\n                        INIT('AT LTERM '),\n                      2 TERMINAL   CHAR(8),\n                      2 TEXT3      CHAR(5)\n                        INIT(' DATE'),\n                      2 DATE       CHAR(14),\n                      2 TIME       CHAR(14),\n                      2 FILL       CHAR(1) INIT(' '),\n                      2 PDATE      CHAR(6) INIT(' '),\n                      2 FILL2      CHAR(1) INIT(' ');\n0              DCL  1 OUT_MSG2     STATIC,\n                      2 LL         FIXED BIN(31) INIT(119),\n                      2 ZZ         BIT(16)       INIT((16)'0'B),\n                      2 TEXT4      CHAR(9)\n                        INIT('YOU HAVE '),\n                      2 MSGQ       CHAR(3),\n                      2 TEXT5      CHAR(19)\n                        INIT(' MSGS ON THE Q AND '),\n                      2 CONV       CHAR(3),\n                      2 TEXT6      CHAR(19)\n                        INIT(' CONVERSATIONS HELD'),\n                      2 FILL       CHAR(88) INIT(' ');\n0              DCL  1 CMD_STRUCTURE,\n                      2 LL         FIXED BIN(31) INIT(132),\n                      2 ZZ         BIT(16)       INIT((16)'0'B),\n                      2 CMD_AREA        CHAR(128);\n0              DCL  1 GCMD_STRUCTURE,\n                      2 LL         FIXED BIN(31) INIT(128),\n                      2 ZZ         BIT(16)       INIT((16)'0'B),\n                      2 GCMD_AREA        CHAR(128);\n0              DCL  1 ERR_MSG      STATIC,\n                      2 LL         FIXED BIN(31) INIT(58),\n                      2 ZZ         BIT(16)       INIT((16)'0'B),\n                      2 TEXT       CHAR(54);\n1/*********************************************************************/\n /*                                                                   */\n /* DEFINES BUILTIN FUNCTIONS                                         */\n /*                                                                   */\n /*********************************************************************/\n0              DCL (TRANSLATE,\n                    LOW,\n                    HIGH,\n                    INDEX,\n                    ADDR,\n                    MOD,\n                    DATE,\n                    SUBSTR)   BUILTIN;\n1/*********************************************************************/\n /*                                                                   */\n /* DEFINES MISCELLANEOUS VARIABLES                                   */\n /*                                                                   */\n /*********************************************************************/\n0              DCL  G_MOD     CHAR(8) INIT('DFSMO2') STATIC;\n0              DCL  ERR_SW    BIT(1);\n1/*********************************************************************/\n /*                                                                   */\n /* MAINLINE PROCEDURE                                                */\n /*                                                                   */\n /*********************************************************************/\n               CALL PLIADLI(THREE,GU,IO_PCB,IN_MSG);\n               DO WHILE (IO_PCB.STAT_CODE = BB);\n                 OUT_MSG1.PDATE = DATE;\n                 OUT_MSG1.TERMINAL = IO_PCB.TERMINAL;\n                 OUT_MSG1.USER_ID = IO_PCB.USER_ID;\n                 OUT_MSG1.DATE = IO_PCB.PREFIX.DATE;\n                 OUT_MSG1.TIME = IO_PCB.PREFIX.TIME;\n                 CALL PLIADLI(FOUR,ISRT,IO_PCB,OUT_MSG1,G_MOD);\n                 CALL PLIADLI(THREE,GU,IO_PCB,IN_MSG);\n                 END;\n               IF IO_PCB.STAT_CODE = QC THEN;\n                                        ELSE\n                 DO;\n                   ERR_MSG.TEXT = 'ERROR IN MSG CALL. '||\n                                  'STATUS='||\n                                  IO_PCB.STAT_CODE;\n                   CALL PLIADLI(FOUR,ISRT,IO_PCB,ERR_MSG,G_MOD);\n                   END;\n0EOJ:\n0              END DLITPLI;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "YRDOC": {"ttr": 22284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x147\\x01 \\x01 \\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T14:37:00", "lines": 288, "newlines": 288, "modlines": 0, "user": "RH87944"}, "text": "          Year 2000 Utility Program (YR2000) - Usage Documentation\n          ________________________________________________________\n\n                              November 5, 1996\n\n\n   AUTHOR:  Randy Hall\n            B.C. Systems Corporation, ...now ITSD...\n            Victoria, B.C.\n\n\n   MODIFICATION LOG\n\n  +-------+-------------+---------------------------------------------------+\n  |REV NO.|    DATE     |DESCRIPTION OF REVISION                            |\n  +-------+-------------+---------------------------------------------------+\n  |  01   | Jan    1996 |First issue, Jan 24.                               |\n  +-------+-------------+---------------------------------------------------+\n  |  02   | Sep    1996 |Second issue...multiple module names, and          |\n  |       |             |               hex data in //SYSIN                 |\n  +-------+-------------+---------------------------------------------------+\n  |  03   | Nov    1996 |Third  issue...Addition of PARM=OFFSET, and        |\n  |       |             |               enhanced checking for STCK's        |\n  +-------+-------------+---------------------------------------------------+\n\n\n  TABLE OF CONTENTS\n  _________________\n\n\n  1.0  COPYRIGHT\n\n  2.0  PREFACE\n\n  3.0  INTRODUCTION\n\n  4.0  PROGRAM DESCRIPTION\n\n  5.0  PROGRAM PARAMETERS\n\n  6.0  JCL\n  6.1  JCL COMMENTS\n\n  7.0  YR2000 RETURN CODES\n\n  8.0  YR2000 MESSAGES\n\n  9.0  SAMPLE OUTPUT\n\n\n  1.0  COPYRIGHT\n  ______________\n\n                             Copyright ....none...\n\n                                3rd edition\n                              November, 1996\n\n  2.0  PREFACE\n  ____________\n\n        This publication,   the YR2000 Reference Manual,    3rd\n        edition, November, 1996 describes how to use the YR2000\n        utility program.\n\n\n  3.0  INTRODUCTION\n  _________________\n\n\n  The program YR2000 is used to help determine if a program MAY be\n  accessing the system TIME/DATE facility, or if it calls a specific\n  module/program.\n\n  YR2000 is written using standard IBM code, and should run on any\n  IBM mainframe running MVS software in 24 bit mode.\n\n  YR2000 should be 100% accurate for the TIME/DATE macro, but is not\n  100% accurate for the STCK/STCKC instruction(s) because the code\n  generated for the STCK/STCKC instruction(s) MAY be part of another\n  instruction, or part of a hexadecimal field, such as a counter.\n  For version 3, additional code has been added to trap the STCK/STCKC |\n  code to ensure that it is not part of another instruction.           |\n  It should now be much more accurate.                                 |\n\n  BUT at least you are made aware that the named program COULD be\n  accessing the system TIME/DATE facility, or if it calls a specific\n  module/program.\n\n\n  4.0  PROGRAM DESCRIPTION\n  ________________________\n\n  YR2000 reads a dataset name from //INLIB to determine what programs\n  to check for access to the TIME/DATE facility, or the specified\n  module/program.\n\n  The dataset is read to get a list of the member names.\n  If the member name is an ALIAS, it is not used.\n\n  Each member is read to get the link-edit date.\n\n  Each member is then loaded and is scanned for the presence of the\n  TIME macro (SVC 11) which also gives you the DATE, the STCK\n  instruction, or the STCKC instruction.  If a PARM= is specified on\n  the EXEC PGM=YR2000 statement, each member is also scanned for the\n  program name specified.\n  A count is kept of how many times the variable is found.\n\n  Up to 40 program names, or other hex data, can be specified in\n  the //SYSIN dd statement.\n  The names start in column 1 and can be a maximum of 8 characters.\n  Hexadecimal data is entered as X'aabbcc'. The data can be a max of\n  8 characters, which is 4 hex bytes.\n  The number of characters must be a multiple of 2.\n\n\n\n  5.0  PROGRAM PARAMETERS\n  _______________________\n\n  Using the PARM= jcl parameter, YR2000 can be passed the name of a\n  TIME/DATE routine that could be called by the programs in the //INLIB\n  dataset.\n  If PARM=DEBUG  is specified, all member names will be shown.\n  If PARM=OFFSET is specified, an extra line is printed showing the\n                 offset into the module of any code/name found.\n\n  6.0  JCL\n  ________\n\n\n  The following JCL is required to run YR2000:\n  //*\n  //YR2000 EXEC PGM=YR2000,REGION=4000K   ,PARM=name\n  //STEPLIB  DD DISP=SHR,DSN=SYSPP.Y2K.PROD.LOADLIB\n  //SYSPRINT DD SYSOUT=*               for the membername list\n  //SYSABEND DD SYSOUT=*               for a dump, if needed\n  //INLIB    DD DSN=load.module.library,\n  //            DISP=SHR\n  //SYSIN    DD *\n  MOD2                      check for MOD2\n  MOD3                      check for MOD3\n  X'0A10'                   also find SVC 16...purge...\n  /*\n  //\n\n  Note...the PARM= and //SYSIN dd statement and data are optional.\n\n  6.1  JCL COMMENTS\n  _________________\n\n\n  The STEPLIB  DD statement is not required if the YR2000 program is\n                  in a system linklist library.\n\n  The SYSPRINT DD statement will contain a list of members that may be\n                  accessing the system TIME/DATE facility.\n\n  The INLIB    DD statement tells YR2000 which dataset to scan.\n\n  The SYSIN    DD statement is for additional modules/hex data.\n\n  If the PARM= is included, the \"name\" specified is the name of a\n  routine that is called by other programs.\n  This program could be called to get the TIME/DATE.\n\n  Note... the PARM= or //SYSIN could be used to find ANY module name\n          called by the programs in //INLIB.\n\n  7.0  YR2000 RETURN CODES\n  ________________________\n\n\n  The following return codes and abends can occur:\n\n        16 - An invalid PARM was found...the length is over 8.\n           - The dataset specified in //INLIB is empty.\n           - The hex data in //SYSIN is invalid.\n\n\n  8.0  YR2000 MESSAGES\n  ____________________\n\n\n  The messages produced by YR2000 are self-explanatory.\n  The messages and their meanings are:\n\n  BADPARM*   PARM TOO LONG.\n           - The parameter passed in the PARM= is over 8 bytes long.\n\n  NOMBRS**  //INLIB IS EMPTY.\n           - The dataset specified in //INLIB is empty.\n\n  X'hexdata'                 HEX DATA MUST BE A MULTIPLE OF 2\n           - The length of hex data in //SYSIN must be a multiple of\n             2 characters.\n\n  X'hexdata'                 HEX DATA MUST BE LESS THAN 9 BYTES LONG\n           - The maximum length of hex data in //SYSIN is 8.\n\n\n  mbrname       ERROR DOING FIND FOR MEMBER.\n           - Indicates that the FIND macro had a problem locating\n             the specified \"mbrname\".\n           - Execution of YR2000 continues.\n\n  mbrname date  ERROR DOING LOAD FOR MEMBER..PROBABLY NOT EXECUTABLE\n           - Indicates that the specified \"mbrname\" could not be\n             loaded and scanned. The module is probably a bad load\n             module that could not be executed.\n           - Execution of YR2000 continues.\n\n\n  9.0  SAMPLE OUTPUT\n  __________________\n\n\n  The output shown would be produced by this jcl...\n\n  //YR2000   JOB (pin,chargnbr),pgmr.name,\n  //          MSGCLASS=A,PRTY=1,USER=*,PASSWORD=*,GROUP=*\n  /*ROUTE  PRINT R7\n  //*\n  //*          GET A LIST OF MEMBERS IN //INLIB THAT MAY CONTAIN THE\n  //*          TIME MACRO, OR THE STCK INSTRUCTION,\n  //*          OR MAY CALL THE TIME ROUTINE SPECIFIED BY PARM=....\n  //*\n  //*\n  //YR2000   EXEC PGM=YR2000,REGION=4000K,PARM='OFFSET'\n  //STEPLIB  DD DSN=SYS9.IMSUTIL.LOAD,DISP=SHR\n  //SYSPRINT DD SYSOUT=*\n  //SYSABEND DD SYSOUT=*\n  //INLIB    DD DISP=SHR,DSN=load.module.library\n  //SYSIN    DD *\n  DAYDATE                   check for DAYDATE\n  MOD2                      check for MOD2\n  MOD3                      check for MOD3\n  X'0A10'                   also find SVC 16...purge...\n  /*\n  //\n\n  Sample output from the above jcl.......\n\n                    YR2000 UTILITY, VERSION 3.0\nTHIS UTILITY MAY NOT FUNCTION IN ALL ENVIRONMENTS, AND IS MADE\nAVAILABLE ASIS.\nNO GUARANTEES OF ANY KIND ARE WARRANTED OR IMPLIED.\nUSE OF THIS UTILITY DOES NOT GUARANTEE YEAR 2000 COMPLIANCE.\n\nTHE FOLLOWING LOAD MODULES MAY CONTAIN THE TIME OR STCK INSTRUCTION,\nOR CALLS A TIME ROUTINE SPECIFIED IN THE PARM...\n\nPROCESSING DATASET load.module.library\n NUMBER OF ALIAS MEMBERS NOT PROCESSED :        1\n\nMBRNAME   LINKED  INSTRUCTION          NBR FOUND\n--------  ------  -----------          ---------\nADMUSP7   90347   ERROR DOING LOAD FOR MEMBER..PROBABLY NOT EXECUTABLE\nAGNTEST   96310   TIME MACRO AT OFFSET 00000122\n                  STCK INST AT OFFSET  0000013C\n                  STCKC INST AT OFFSET 00000146\n                  ATT        AT OFFSET 00000E6A\n                  ATT        AT OFFSET 00000E76\n                  DAYDATE    AT OFFSET 00001525\n                  TIME MACRO AT OFFSET 000016DE\n                  TIME MACRO (SVC 11)        2\n                  STCK INSTRUCTION           1\n                  STCKC INSTRUCTION          1\n                  CALLS MODULE DAYDATE       1\n                  CALLS MODULE ATT           2\nAGNTEST1  94353   TIME MACRO AT OFFSET 00000122\n                  STCK INST AT OFFSET  0000013C\n                  TIME MACRO (SVC 11)        1\n                  STCK INSTRUCTION           1\nARCHMSUB  94287   0A04       AT OFFSET 0000156D\n                  FOUND DATA 0A10            1\nJDATE     91206   DAYDATE    AT OFFSET 00000215\n                  TIME MACRO AT OFFSET 000003CE\n                  TIME MACRO (SVC 11)        1\n                  CALLS MODULE DAYDATE       1\n  etc.......\n\nNUMBER OF MEMBERS CHECKED :        59\n\n          NUMBER OF TIME MACROS (SVC 11) FOUND :        3\n    NUMBER OF POSSIBLE STCK INSTRUCTIONS FOUND :        3\n  NUMBER OF TIMES PARM/SYSIN KEYWORD WAS FOUND :       40\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "YR2000": {"ttr": 22533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x149\\x07\\xae\\x07\\xae\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T14:39:00", "lines": 1966, "newlines": 1966, "modlines": 0, "user": "RH87944"}, "text": "//YR2000   JOB\n//*\n//*    DSN=CBT.SOURCE(YR2000)\n//*\n/*ROUTE PRINT R7\n//S EXEC HLASMCL,PARMC='NOALIGN,NORLD',CLASS='*',COND.LKED=(7,LT,ASM),\n//  PARML=REUS\n//ASM.SYSLIB DD DSN=SYS1.MACLIB\n//   DD DSN=SYS1.MODGEN,DISP=SHR\n//   DD DSN=SYS1.AMODGEN,DISP=SHR\n//ASM.SYSIN DD *\n*\n* JAN    26/99 FIX PROCESSING OF //SYSIN MODULE NAMES..\n*              ALSO CHECK FOR X'8015' RECORD IN LOAD MODULE.\n*\n* SEP    19/96 ADDED //SYSIN CODE TO READ UP TO 40 MODULE NAMES\n*              TO BE SCANNED FOR IN THE MODULE.\n*              HEX DATA (UP TO 4 BYTES) CAN BE SPECIFIED WITH X'..'\n*              HEX DATA IS IN MULTIPLES OF 2..\n*                ..EG.. X'0A10' IS THE CODE FOR SVC 10.\n*\n*\n*              I AM TRYING TO DETERMINE IF THE MODULES IN THE\n*              SPECIFIED LIBRARY CONTAIN THE 'TIME' SVC 11, OR USE\n*              THE 'STCK' INSTRUCTION TO GET THE DATE......\n*\n*              OR, IF A PARM IS PASSED, I TRY TO FIND THE PARM IN\n*              THE MODULES. THE PARM WOULD BE THE NAME OF A DATE\n*              ROUTINE THAT IS CALLED BY OTHER ROUTINES\n*\n*              IF PARM=OFFSET, THE OFFSET OF STCK AND STCKC IS SHOWN.\n*              IF PARM=DEBUG, ADDITIONAL INFO IS DISPLAYED.\n*              IF PARM='DEBUG=MODNAME', THE PROGRAM WILL ABEND WHEN\n*                 MODULE MODNAME IS FOUND.\n*              IF PARM=NAME, THE NAME WILL BE SEARCHED FOR IN\n*                 THE MODULE.\n*\n*              PARM ORDER MUST BE OFFSET,DEBUG,NAME\n*\n*\n*        REGISTER EQUATES\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4                  BASE REG 2\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12                 BASE REG 1\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\n*        ENTRY POINT\n*\nYR2000   CSECT\nYR2000   AMODE 31\nYR2000   RMODE 24\n         USING *,R15      GET TEMP ADDRESSABILITY\n         B     AROUND             BRANCH AROUND DUMP TITLE\n         DC    AL1(EYELTH)        LTH OF EYE CATCHER\nEYECATCH DS    0C\n         DC    C'YR2000 '         PROGRAM NAME\n         DC    C' VERSION 4.0 '   VERSION\n         DC    CL8'&SYSDATE'      DATE WRITTEN\n         DC    CL6'&SYSTIME'      TIME WRITTEN\n         DC    C'..ADD CHECK FOR CVTDATE ACCESS'    COMMENT\n*        DC    C'..ADD //SYSIN INPUT AND HEX DATA'    COMMENT\n*        DC    C'..HANDLE AMODE 31 MODULES'    COMMENT\nEYELTH   EQU   *-EYECATCH         LTH OF EYE CATCHER\n         SPACE 1\nAROUND   DS    0H\n         LA    R1,0(0,R1)         CLEAR HI-ORDER BYTE FOR 31 BIT\n         LA    R13,0(0,R13)       CLEAR HI-ORDER BYTE FOR 31 BIT\n         BSM   R14,0              SAVE CURRENT AMODE\n         STM   R14,R12,12(R13)  SAVE REGISTERS\n*        LR    R12,R15            LOAD 1ST BASE REG.\n*        LR    R14,R13            SAVE R13\n*        BAL   R13,AROUND2        SET R13 AS 1ST BASE ALSO...\n         BAL   R14,AROUND2        R14 -> AT OUR SAVE AREA...\n         SPACE 1\nSAVEAREA DC    18F'0'\n         SPACE 1\nAROUND2  DS    0H\n         ST    R13,4(R14)      SAVE REGS 13 AND\n         ST    R14,8(R13)      BACK CHAIN\n         LR    R13,R14         GET SAVE AREA ADDRESS\n         LA    R13,0(0,R13)       CLEAR HI-ORDER BYTE SET BY BAL..\n         DROP  R15\n*        USING YR2000,R13,R12,R4  SET ADDRESSABILITY\n         USING SAVEAREA,R13,R12,R4 SET ADDRESSABILITY\n         LA    R12,4095(0,R13)    LOAD 2ND BASE REG\n         LA    R12,1(0,R12)       ''\n         LA    R4,4095(0,R12)     LOAD 3RD BASE REG\n         LA    R4,1(0,R4)         ''\n*        ST    R14,4(R13)      SAVE REGS 13 AND\n*        LA    R14,SAVEAREA\n*        ST    R14,8(R13)      BACK CHAIN\n*\n****     LA    R14,SAVEAREA\n*        ST    R13,4(R14)      SAVE REGS 13 AND\n*        ST    R14,8(R13)      BACK CHAIN\n*        LR    R13,R14         GET SAVE AREA ADDRESS\n         ST    R1,SAVER1          SAVE REG 1\n*\n*        OPEN OUTPUT DATASET\n*\n         OPEN  (PRINT,(OUTPUT)),MODE=31  OPEN PRINT FILE\n         TM    PRINT+48,X'10'     DID IT OPEN?\n         BZ    BADBAD             NO, ABEND\n*\n*        PRINT DISCLAIMER....\n*\n         LA    R5,DISCLAIM        R5 -> AT DISCLAIMER\n         SPACE 1\nDISMSG   DS    0H\n         MVC   MBRNAME(LDIS),0(R5) PUT MSG IN PRINT LINE\n         PUT   PRINT,SCRCARD      PRINT IT\n         LA    R5,LDIS(0,R5)      R5 -> AT NEXT LINE\n         CLC   =C'END OF DISLAIM',0(R5) END OF DISCLAIMER?\n         BNE   DISMSG             NO, GO PRINT NEXT LINE\n         MVI   MBRNAME,C' '       CLEAR PRINT LINE\n         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''\n*\n*        PRINT HEADING 1\n*\n         LA    R5,HEADING         R5 -> AT HEADING\n         SPACE 1\nHEADMSG  DS    0H\n         MVC   MBRNAME(LHEAD),0(R5) PUT MSG IN PRINT LINE\n         PUT   PRINT,SCRCARD      PRINT IT\n         LA    R5,LHEAD(0,R5)     R5 -> AT NEXT LINE\n         CLC   =C'END OF HEADING',0(R5) END OF HEADING?\n         BNE   HEADMSG            NO, GO PRINT NEXT LINE\n         MVI   MBRNAME,C' '       CLEAR PRINT LINE\n         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''\n*\n*        GET DATASET NAME AND PRINT IT\n*\n*\n         RDJFCB INPDSA            GET JFCB INFO\n         LTR   R15,R15            WELL???\n         BNZ   NOMBRS             NO, NOTHING TO PROCESS\n*\n         MVC   PRTDSN,JFCBDSNM    YES, PUT DSNAME INTO MSG\n         MVC   MBRNAME(LDSNMSG),DSNMSG PUT MSG IN PRINT LINE\n         PUT   PRINT,SCRCARD      PRINT IT\n         MVI   MBRNAME,C' '       CLEAR PRINT LINE\n         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''\n*\n*        GET PARM, IF ANY\n*\nGETPARM  DS    0H\n         L     R1,SAVER1     RESTORE REG 1\n         L     R2,0(0,R1)    SET ADDRESS OF PARAMETER STRING\n         SR    R3,R3         ZERO R3 (LENGTH OF PARAMETER STRING)\n         ICM   R3,3,0(R2)    LOAD PARAMETER LENGTH IN R3\n         BZ    NOPARM             AIN'T NONE, ON WE GO\n         LA    R2,2(0,R2)         R2 -> AT PARMS\n*\n         CLC   =C'OFFSET',0(R2)   WANT OFFSET INFO?\n         BNE   NOFFSET            NO\n         OI    FLAG1,X'20'        YES, SAY SHOW OFFSET\n         LA    R2,7(0,R2)         R2 -> PAST \"OFFSET,\"\n         SH    R3,=H'7'           R3 = LTH LEFT\n*        LTR   R3,R3              ANY LTH LEFT ?\n         BNP   NOPARM             NONE LEFT...\n*\nNOFFSET  DS    0H\n         CLC   =C'DEBUG',0(R2)    WANT DEBUG INFO?\n         BNE   NOTDEBUG           NO\n         OI    FLAG1,X'80'        YES, SAY DEBUG\n*\n         CLC   =C'DEBUG=',0(R2)   WANT DEBUG INFO AND ABEND?\n         BNE   DEBUG1             NO\n         OI    FLAG1,X'40'        YES, SAY ABEND\n         LA    R2,1(0,R2)         R2 -> PAST = SIGN\n         SH    R3,=H'1'           R3 = LTH LEFT\n*\nDEBUG1   DS    0H\n         LA    R2,6(0,R2)         R2 -> PAST \"DEBUG,\"\n         SH    R3,=H'6'           R3 = LTH LEFT\n         BNP   NOPARM             NONE LEFT...\n*\nNOTDEBUG DS    0H\n         CH    R3,=H'8'   IF LENGTH OF PARAMETER IS TOO LONG,\n         BH    BADPARM    THEN ERROR\n*\n*        LA    R2,2(0,R2)         R2 -> TO START OF PARAMETER\n         MVC   SCRDATE,0(R2)      SAVE IT\n         STC   R3,PARMLTH         SAVE ITS LTH\n*\nNOPARM   DS    0H\n*\n*        OPEN LIBRARY DIRECTORY TO GET ALL MEMBERS OF THE PDS\n*\n         OPEN  (INPDS,(INPUT)),MODE=31\n*\n*        ISSUE GETMAIN FOR MEMBER AREA\n*\n         SR    R5,R5           ZERO REG 5\n         L     R5,=F'9000'     WANT ROOM FOR MAXIMUM MEMBERS\n         SLL   R5,3        TIMES 8 PER MEMBER NAME\n         GETMAIN R,LV=(R5),SP=10,LOC=BELOW\n         ST    R1,MBRAREA  SAVE AREA ADDRESS\n         LR    R7,R1       AND LOAD INTO R7\n         SRL   R5,3        RESET TO NUMBER OF MEMBERS ALLOWED\n         SR    R9,R9       ZERO MEMBER COUNTER\n         SR    R11,R11     ZERO MEMBER COUNTER\n*\n*        GET DIRECTORY BLOCK\n*\nDIRREAD  EQU   *\n*\n*            GO TO 24 BIT MODE ADDRESSING\n*\n*        LA    R1,*+4+2           GET INTO 24 BIT MODE\n*        BSM   0,R1               ''\n*\n         LA    R6,DIRREC\n         READ  UT1DECB,SF,INPDS,(R6),,S\n         CHECK UT1DECB\n*\n*        GET BACK TO 31 BIT MODE ADDRESSING\n*\n*        CNOP  0,4                ALIGN ON A FULLWORD BOUNDARY      RH\n*        L     R1,*+8             GET 31 BIT MODE ADDRESS           RH\n*        BSM   0,R1               GET INTO 31 BIT MODE              RH\n*        BSM   0,R1               TO FILL 4 BYTES                   RH\n**       DS    0F                 ALIGN ON A FULLWORD BOUNDARY      RH\n*        DC    X'80',AL3(*+3)     NEXT ADDRESS IS 31 BIT MODE       RH\n*\n         CLC   0(2,R6),=H'0'  IF LENGTH IS ZERO END DIRECTORY SEARCH\n         BE    LOADMBR\n*\n         LR    R1,R6          SAVE BEGINNING OF BLOCK\n         AH    R1,0(R6)       POINT TO END OF BLOCK\n         SH    R1,=H'2'           -2 FOR LTH FIELD....\n         ST    R1,ENDADDR         SAVE END ADDRESS\n         LA    R6,2(0,R6)    POINT PAST LENGTH FIELD\n*\nTHISMBR  EQU   *\n*        CR    R6,R1         IF AT END OF BLOCK\n         C     R6,ENDADDR    IF AT END OF BLOCK\n         BNL   DIRREAD       GET ANOTHER ONE\n         CLI   0(R6),X'FF'   IF MEMBER HAS HIGH VALUES END DIR. SEARCH\n         BE    LOADMBR\n         CLI   0(R6),X'00'   IF MEMBER HAS LOW VALUES BYPASS SAVE\n         BE    NEXTMBR\n         LA    R11,1(0,R11)       COUNT ALL MEMBERS\n         TM    11(R6),X'80'   IF MEMBER IS AN ALIAS, BYPASS SAVE\n         BO    ALIASMBR\n*\n         MVC   0(8,R7),0(R6) SAVE MEMBER NAME IN MEMBER AREA\n         LA    R7,8(0,R7)      POINT TO NEXT ENTRY IN MEMBER AREA\n         LA    R9,1(0,R9)      INCREMENT MEMBER COUNT\n         CR    R9,R5         IS MEMBERS UP TO MAXIMUM?\n         BL    NEXTMBR            NOT YET, ON WE GO...\n         MVC   MBRNAME(LMAXMBR),MAXMBR PUT MSG IN PRINT LINE\n         PUT   PRINT,SCRCARD      PRINT IT\n         MVI   MBRNAME,C' '       CLEAR PRINT LINE\n         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''\n         B     LOADMBR       END DIRECTORY SEARCH\n*        BNL   LOADMBR       IF YES, END DIRECTORY SEARCH\n*        B     NEXTMBR            ON WE GO...\n*\nALIASMBR DS    0H\n         TM    FLAG1,X'80'        DEBUGGING?\n         BZ    NEXTMBR            NO\n         MVC   MBRNAME,0(R6)     SAVE MEMBER NAME\n         MVC   ALIASNAM,36(R6)    SAVE ALIAS MEMBER NAME\n         MVC   PSDATE(LALIASMS),ALIASMSG PUT MSG IN PRINT\n         PUT   PRINT,SCRCARD      PRINT IT\n         MVI   MBRNAME,C' '       CLEAR PRINT LINE\n         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''\n*        MVC   PSTYPE(L'ALIASMSG),ALIASMSG PUT MSG IN PRINT\n*        PUT   PRINT,SCRCARD      PRINT IT\n*        MVI   PSTYPE,C' '        CLEAR PRINT LINE\n*        MVC   PSTYPE+1(CLRLTH2),PSTYPE ''\n*\nNEXTMBR  EQU   *\n         NI    11(R6),31      LOOK AT ONLY THE \"C\" FIELD IN ENTRY\n         SR    R8,R8\n         IC    R8,11(R6)       MOVE \"C\" FIELD TO R8\n         SLL   R8,1           MULTIPLY BY 2\n         LA    R6,12(R8,R6)     POINT TO NEXT ENTRY IN DIRECTORY BLOCK\n         B     THISMBR        BRANCH TO PROCESS NEXT ENTRY\n*\n*        THIS ROUTINE LOADS EACH MEMBER OF THE PDS\n*\nLOADMBR  EQU   *\n         CLOSE INPDS,MODE=31    CLOSE DIRECTORY DCB\n*\n         LTR   R9,R9          IF NO MEMBERS THEN\n         BZ    NOMBRS         LEAVE ROUTINE WITH MESSAGE\n*\n*        PRINT NUMBER OF ALIAS MEMBERS, IF ANY\n*\nPRTCOUNT DS    0H\n         CR    R11,R9             ANY ALIAS MEMBERS?\n         BE    PRTHEAD2           NO, NO MSG\n         SR    R11,R9             R11 = NBR ALIAS MEMBERS\n         CVD   R11,WORKD          PUT NBR MBRS IN MSG\n         MVC   PRTCNT,PATTERN\n         ED    PRTCNT,WORKD+4\n*\n         MVC   MBRNAME(LCNTMSG),CNTMSG PUT MSG IN PRINT LINE\n         PUT   PRINT,SCRCARD      PRINT IT\n         MVI   MBRNAME,C' '       CLEAR PRINT LINE\n         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''\n*\n*        PRINT HEADING 2\n*\nPRTHEAD2 DS    0H\n         LA    R5,HEADING2        R5 -> AT HEADING 2\n         SPACE 1\nHEADMSG2 DS    0H\n         MVC   MBRNAME(LHEAD),0(R5) PUT MSG IN PRINT LINE\n         PUT   PRINT,SCRCARD      PRINT IT\n         LA    R5,LHEAD(0,R5)     R5 -> AT NEXT LINE\n         CLC   =C'END OF HEADING',0(R5) END OF HEADING?\n         BNE   HEADMSG2           NO, GO PRINT NEXT LINE\n         MVI   MBRNAME,C' '       CLEAR PRINT LINE\n         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''\n*\n*\n*        ISSUE GETMAIN TO HOLD BLOCKS\n*\nLOADMBR1 EQU   *\n         SR    R5,R5           ZERO REG 5\n         L     R5,=F'32000'    WANT ROOM FOR MAXIMUM\n         GETMAIN R,LV=(R5),SP=10,LOC=BELOW\n         ST    R1,BLKAREA  SAVE AREA ADDRESS\n*\n         OPEN  (INPDSA,(INPUT)),MODE=31 OPEN PDS DATASET\n*                                                                     *\n*\n         OPEN  (SYSIN,(INPUT)),MODE=31   OPEN INPUT DCB\n         TM    SYSIN+48,X'10'     DID IT OPEN ?\n         BZ    NOSYSIN            NO\n         LA    R6,MODTABLE        R6 -> AT MOD NAME TABLE\n         USING MODENTRY,R6        SET TABLE BASE\n         CLI   MODLTH,X'00'       WAS THERE A PARM?\n         BE    READSYS            NO\n         LA    R6,MODTBLTH(0,R6)  R6 -> AT NEXT ENTRY\n         SPACE 1\nREADSYS  DS    0H\n         GET   SYSIN,MBRNAME           GET INPUT RECORD\n         LA    R1,MBRNAME         R1 -> TO INPUT DATA\n         SPACE 1\n         CLI   MODLTH,X'FF'       STILL ROOM IN TABLE?\n         BE    EOFREAD            NO\n         CLC   =C'X''',0(R1)      IS INPUT HEX?\n         BE    GETHEX             YES, GO SET IT UP\n         SPACE 1\nREADSYS1 DS    0H\n         LA    R2,MBRNAME         R2 -> TO INPUT DATA\n         SPACE 1\nREADSYS2 DS    0H\n         CLI   0(R2),C' '         END OF MODULE NAME?\n         BE    READSYS3           YES\n         LA    R2,1(0,R2)         NO, R2 -> AT NEXT CHAR\n         B     READSYS2           GO CHECK IT\n         SPACE 1\nREADSYS3 DS    0H\n         SR    R2,R1              R2 = MODULE NAME LTH\n         CH    R2,=H'8'   IF LENGTH OF INPUT IS TOO LONG,\n         BH    BADINPUT   THEN ERROR\n*\n         MVC   MODNAME,0(R1)      PUT NAME IN TABLE\n         MVC   MODCTR,=H'0'       SET COUNT TO ZERO\n         SPACE 1\nREADSYS4 DS    0H\n         STC   R2,MODLTH          SAVE IT\n         LA    R6,MODTBLTH(0,R6)  R6 -> AT NEXT ENTRY\n         B     READSYS            GET NEXT NAME\n         SPACE 1\nBADINPUT DS    0H\n*        MVC   MBRNAME,=CL8'BADINP*'\n*        MVC   PSDATE(8),0(R1)    PUT 1ST 8 BYTES IN MSG\n         MVC   PSTYPE+9(L'INPMSG),INPMSG PUT ERROR MSG IN PRINT\n         B     BADPARM2           THEN ERROR\nINPMSG   DC    C'SYSIN DATA OVER 8 BYTES'\n         SPACE 1\nGETHEX   DS    0H\n         LA    R1,MBRNAME+2       R1 -> TO INPUT DATA\n         LA    R2,MBRNAME+2       R2 -> TO INPUT DATA\n         SPACE 1\nGETHEX2  DS    0H\n         CLI   0(R2),C''''        END OF HEX DATA?\n         BE    GETHEX3            YES\n         LA    R2,1(0,R2)         NO, R2 -> AT NEXT CHAR\n         B     GETHEX2            GO CHECK IT\n         SPACE 1\nGETHEX3  DS    0H\n         SR    R2,R1              R2 = HEX DATA LTH\n*\n*        STC   R2,MODLTH          SAVE IT\n         LR    R7,R2              R7 = LTH\n         SRL   R7,1               DIVIDE BY 2\n         SLL   R7,1               MULTIPLY BY 2\n         CR    R7,R2              STILL THE SAME?\n*        BE    GETHEX4            YES, GO SAVE IT\n         BNE   BADHEX             NO, TOO BAD\n         SPACE 1\nGETHEX4  DS    0H\n         CH    R2,=H'8'           TOO MANY HEX DIGITS?\n         BH    BADHEX2            YES\n*\n         XC    DWORD,DWORD        CLEAR DOUBLE WORD....\n         SR    R14,R14            CLEAR R14\n*        LA    R15,DWORD          R15 -> AT DWORD\n         BCTR  R7,0               R7 = HEX LTH\n         EX    R7,HEXMVC          PUT DATA IN DWORD\n         EX    R7,HEXTR           TRANSLATE TO PACKABLE DATA\n         EX    R2,HEXPACK         PACK IT TO MAKE HEX...\n         SRL   R2,1               R2/2 = LTH OF PACKED DATA...\n         LA    R14,DWORD2+7       R14 -> AT DWORD2\n         SR    R14,R2             R14 S/B -> AT HEX DATA...\n         SRL   R7,1               DIVIDE BY 2\n*        BCTR  R7,0               R7 = HEX LTH OF HEX DATA\n         EX    R7,HEXMVC2         PUT DATA IN TABLE\n         MVI   MODTYPE,C'H'       SAY DATA IS HEX\n         B     READSYS4           GO SAVE IT\n         SPACE 1\nDWORD    DC    D'0'\nDWORD2   DC    D'0'\nHEXMVC   MVC   DWORD(0),0(R1)     SET UP DATA\nHEXMVC2  MVC   MODNAME(0),0(R14)  PUT NAME IN TABLE\nHEXTR    TR    DWORD(0),TRTAB-193 TRANSLATE\nHEXPACK  PACK  DWORD2,DWORD(0)    PACK IT\nHEXMSG   DC    C'HEX DATA MUST BE A MULTIPLE OF 2'\nHEXMSG2  DC    C'HEX DATA MUST BE LESS THAN 9 BYTES LONG'\n*RTAB    DC    C' 0123456789ABCDEF'\nTRTAB    DC    X'0A0B0C0D0E0F'    A - F\n         DC    41X'00'            G - 0-1\n         DC    X'00010203040506070809'    0 - 9\n         SPACE 1\nBADHEX   DS    0H\n*        MVC   MBRNAME,=C'BADHEX*'\n*        MVC   PSDATE(8),0(R1)    PUT 1ST 8 BYTES IN MSG\n         MVC   PSTYPE+9(L'HEXMSG),HEXMSG PUT ERROR MSG IN PRINT\n         B     BADPARM2           THEN ERROR\n*        PUT   PRINT,SCRCARD      PRINT IT\n*        MVI   MBRNAME,C' '       CLEAR PRINT LINE\n*        MVC   MBRNAME+1(CLRLTH1),MBRNAME ''\n*        B     BADPARM    THEN ERROR\n*        B     READSYS          GET NEXT MEMBER\n         SPACE 1\nBADHEX2  DS    0H\n*        MVC   MBRNAME,=C'BADHEX*'\n*        MVC   PSDATE(8),0(R1)    PUT 1ST 8 BYTES IN MSG\n         MVC   PSTYPE+9(L'HEXMSG2),HEXMSG2 PUT ERROR MSG IN PRINT\n         B     BADPARM2           THEN ERROR\n*        MVC   PSTYPE(L'HEXMSG2),HEXMSG2 PUT ERROR MSG IN PRINT\n*        PUT   PRINT,SCRCARD      PRINT IT\n*        MVI   MBRNAME,C' '       CLEAR PRINT LINE\n*        MVC   MBRNAME+1(CLRLTH1),MBRNAME ''\n*        B     BADPARM    THEN ERROR\n*        B     READSYS          GET NEXT MEMBER\n         SPACE 1\n         AGO   .HEX1\nGETHEX5  DS    0H\n         IC    R14,0(R1)          R14 = CHAR TO CONVERT\n         STC   R14,2(R15)         SAVE IT\n         SRL   R14,4              DROP HI ORDER HALF OF BYTE\n         STC   R14,1(R15)         SAVE IT\n         SH    R2,=H'2'           R2 = LTH LEFT\n         LTR   R2,R2              ANY LEFT?\n         BZ    GETHEX6            NO\n         LA    R1,1(0,R1)         R1 -> AT NEXT BYTE\n         LA    R15,2(0,R15)       R15 -> AT NEXT DWORD BYTE\n         B     GETHEX5            GO SET IT UP\n         SPACE 1\nGETHEX9  DS    0H\n         LA    R6,MODTBLTH(0,R6)  R6 -> AT NEXT ENTRY\n         B     READSYS1           GET NEXT NAME\n.HEX1    ANOP\n         SPACE 1\nEOFREAD  DS    0H\n         CLOSE (SYSIN),MODE=31    CLOSE INPUT DCB\n*\nNOSYSIN  DS    0H\n         L     R6,MBRAREA    SET ADDRESS OF MEMBER AREA\n         ST    R6,MBRADDR    SET ADDRESS OF MEMBER\n         SR    R7,R7             ZERO REGISTER 7\n         SPACE 1\n*\n*        FOR EACH MEMBER IN AREA WE WANT ISSUE FIND FOR IT IN PDS\n*\nFINDMBR2 DS    0H\n         MVC   MBRNAME,0(R6)     SAVE MEMBER NAME\n         MVC   DELNAME,0(R6)     SAVE MEMBER NAME FOR DELETE...\n         FIND  INPDSA,(R6),D\n         LTR   R15,R15\n         BZ    READBLK            OKAY, ON WE GO\n         MVC   PSTYPE(L'BADFIND),BADFIND PUT ERROR MSG IN PRINT\n         PUT   PRINT,SCRCARD      PRINT IT\n         MVI   MBRNAME,C' '       CLEAR PRINT LINE\n         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''\n         B     GETNEXT          GET NEXT MEMBER\n*\n*        READ A BLOCK FROM PDS MEMBER\n*        WE ARE TRYING TO GET THE LINK DATE...\n*\nREADBLK  EQU   *\n         L     R8,BLKAREA        RESTORE BLOCK AREA ADDRESS\n         READ  UT1ADECB,SF,INPDSA,(R8),19069,S\n         CHECK UT1ADECB\n*\n*        DETERMINE IF CORRECT RECORD - LOOK FOR X'8011'\n*\n         CLC   0(2,R8),=X'8011'\n         BE    GOT8011            IF GOT THE RIGHT RECORD\n         CLC   0(2,R8),=X'8015'   PISS-ASS L2?\n         BE    GOT8011            YES,  GOT THE RIGHT RECORD\n         CLC   0(2,R8),=X'0100'   GOT TO EXECUTABLE CODE?\n         BE    LOADMEM            YES, CAN'T GET LINK DATE\n         B     READBLK\n*\n*        IF HAVE THE X'8011' RECORD THEN SAVE THE DATE\n*\nGOT8011  EQU   *\n         UNPK  WORKD,15(3,R8)\n         MVC   PSDATE,WORKD+3\n*\n*        LOAD THE MODULE SO WE CAN SCAN IT\n*\nLOADMEM  EQU   *\n         TM    FLAG1,X'80'        DEBUGGING?\n         BZ    AAA                NO\n         MVC   PSTYPE(L'LOADMSG),LOADMSG PUT MSG IN PRINT\n         PUT   PRINT,SCRCARD      PRINT IT\n         MVI   PSTYPE,C' '        CLEAR PRINT LINE\n         MVC   PSTYPE+1(CLRLTH2),PSTYPE ''\n*\nAAA      DS    0H\n         LA    R0,MBRNAME         R0 -> AT MEMBER NAME\n*                                 LOAD THE MODULE\n         LOAD  EPLOC=(0),DCB=INPDSA,ERRET=XXX\n*\nXXX      DS    0H\n         LTR   R15,R15            WAS LOAD OKAY?\n         BZ    GOTREC             YES, ON WE GO\n*\nBBB      DS    0H\n         MVC   PSTYPE(L'BADLOAD),BADLOAD  PUT ERROR MSG IN PRINT\n         PUT   PRINT,SCRCARD      PRINT IT\n         MVI   MBRNAME,C' '       CLEAR PRINT LINE\n         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''\n         B     GETNEXT          GET NEXT MEMBER\n*\n*        SET UP TO LOAD NEXT MEMBER\n*\nGETNEXT  EQU   *\n         L     R6,MBRADDR    SET ADDRESS OF MEMBER\n         LA    R6,8(0,R6)\n         ST    R6,MBRADDR    SET ADDRESS OF MEMBER\n         BCT   R9,FINDMBR2    IF MORE MEMBERS\n         B     CLOSPDS\n*\n*        NOW  THE MODULE IS LOADED, GO FIND THE LOAD ADDRESS,\n*        AS R1 IS THE LTH IN DOUBLEWORDS, AND R0 IS THE ENTRY\n*        ADDRESS, NOT THE LOAD ADDRESS.\n*\n*\nGOTREC   EQU   *\n*\n*        CHAIN  THROUGH OUR CDE CHAIN TO GET THE LOAD ADDRESS....\n*\n         L     R10,PSATOLD-PSA    R10 -> TO OUR TCB\n*        ICM   R10,7,TCBJPQ-TCB(R10) R10 -> TO OUR LAST CDE\n*        BP    CHKNAME            THERE IS ONE, SO USE IT\n         ICM   R10,15,TCBLLS-TCB(R10) R10 -> TO OUR LAST LLE\n         BZ    BBB                NONE, TOO BAD\n*\nCHKNAME  DS    0H\n         USING LLE,R10            SET LLE BASE\n         ICM   R11,15,LLECDPT     R11 -> TO THIS LLE'S CDE\n*\n         USING CDENTRY,R11        SET CDE BASE\n         CLC   MBRNAME,CDNAME     IS IT THE MODULE WE LOADED?\n         BE    GOTCDE             YES, CONTINUE\n         ICM   R10,15,LLECHN      NO, R10 -> AT NEXT LLE\n*        ICM   R10,7,CDCHAIN      NO, R10 -> AT NEXT CDE\n         BNZ   CHKNAME            GO CHECK IT\n         B     BBB                NOT FOUND, WE BLEW IT....\n*\nGOTCDE   DS    0H\n         DROP  R10                DROP LLE BASE\n         ICM   R10,15,CDXLMJP     R10 -> TO THE MODULES EXTENT CB\n         BNZ   GOTXLMJP           GOT IT, GO CHECK IT\n*                                 NO XLMJP.....\n         TM    CDATTRB,CDELPDE    IS THIS A CDE OR AN LPDE?\n         BZ    NOTLPDE            CDE, USE THE LOAD ADDRESS & LTH\n         DROP  R11                DROP CDE BASE\n*\n*                                 IT'S AN LPDE...\n*\nGOTLPDE  DS    0H\n         USING LPDE,R11           SET LPDE BASE\n         L     R8,LPDEXTAD        R8 -> TO LOADED MEMBER\n         L     R5,LPDEXTLN        R5 = IT'S LTH IN BYTES\n         DROP  R11                DROP LPDE BASE\n         B     READBLK2           ON WE GO....\n*\n*                                 NOT FOUND, USE R0 AND R1 VALUES\n*\nNOTLPDE  DS    0H\n         LR    R8,R0              R8 -> TO LOADED MEMBER\n         LR    R5,R1              R5 = IT'S LTH IN DOUBLEWORDS\n         MH    R5,=H'8'           R5 = IT'S LTH IN BYTES\n         B     READBLK2           ON WE GO...\n*\nGOTXLMJP DS    0H\n         USING XTLST,R10          SET XTLST BASE\n         ICM   R5,7,XTLMSBLN      R5 = LTH OF LOADED MODULE\n         L     R8,XTLMSBAD        R8 -> TO LOADED MODULE\n         DROP  R10                DROP XTLST BASE\n*        MH    R1,=H'8'           CHANGE LTH FROM DOUBLEWORDS TO BYTES\n*\nREADBLK2 DS    0H\n         ST    R8,LOADADDR        SAVE ADDR OF LOADED MEMBER\n         LR    R10,R8             R10 -> TO LOADED MEMBER\n         AR    R10,R5             R10 -> TO END OF MEMBER\n         BCTR  R10,0              R10 -> TO LAST BYTE TO TEST\n         TM    FLAG1,X'40'        ABEND AT SPECIFIC MODULE?\n         BZ    TESTTYPE           NO\n         CLC   SCRDATE,MBRNAME    SCRDATE WILL ABEND BE MODULE NAME\n         BNE   TESTTYPE\n         DC    H'0'\n         SPACE 1\nTESTTYPE DS    0H\n*\n*            GO TO ADDRESSING MODE OF LOADED PROGRAM\n*\n*        ST    R8,LOADADDR        SAVE ADDR OF LOADED MEMBER\n*        ICM   R1,1,LOADADDR      GET MODE OF LOADED MODULE\n*        LA    R1,*+4+2           GET INTO 24 BIT MODE\n**             GET INTO PROPER MODE FOR TESTS                       RH\n*        BSM   0,R1               ''\n*\n*\n*        GET INTO 31 BIT MODE ADDRESSING\n*\n         BAS  R14,@AMODE31\n*\n*        CNOP  0,4                ALIGN ON A FULLWORD BOUNDARY      RH\n*        L     R1,*+8             GET 31 BIT MODE ADDRESS           RH\n*        BSM   0,R1               GET INTO 31 BIT MODE              RH\n*        BSM   0,R1               TO FILL 4 BYTES                   RH\n**       DS    0F                 ALIGN ON A FULLWORD BOUNDARY      RH\n*        DC    X'80',AL3(*+3)     NEXT ADDRESS IS 31 BIT MODE       RH\n*\n*              SEE IF PAST END OF MODULE\n*\n         LA    R1,2(0,R8)         R1 -> END OF INSTRUCTION...\n         CR    R1,R10             PAST END OF MODULE?\n*        BH    NEXTBYTE           YES, CAN'T TEST\n         BL    CHKALIGN           NO, CHECK ALIGNMENT\n         LA    R5,1               SET R5 SO BCT AT LABEL NEXTBYT2\n*                                 DOESN'T BRANCH...\n         B     NEXTBYTE           END OF MODULE...\n*\nCHKALIGN DS    0H\n*\n*              SEE IF ADDRESS IS DIVISIBLE BY 2\n*\n*        L     R11,LOADADDR       R11 = ADDR OF LOADED MEMBER\n*        SR    R11,R8             R11 = OFFSET TO INST\n         LR    R11,R8             R11 = ADDR OF INST\n         S     R11,LOADADDR       R11 = OFFSET TO INST\n         LR    R1,R11             R1 = OFFSET TO INST\n         SRL   R1,1               DIVIDE BY 2\n         SLL   R1,1               MULTIPLY BY 2\n         CR    R1,R11             STILL THE SAME?\n*                                 NO, NOT AN INSTRUCTION\n         BNE   TESTDATA           BUT GO SEE IF IT IS A NAME/DATA..\n*\n*\n*        SCAN THE MODULE TO SEE IF TIME IS INVOLVED...\n*\nTEST1    DS    0H\n         CLC   0(2,R8),=X'0A0B'   POSSIBLE CALL TO SVC 11?\n         BNE   TEST2              NO, DO NEXT TEST\n*\n*              OKAY, WE HAVE AN SVC 11. CHECK PREVIOUS\n*              INSTRUCTIONS FOR VALIDITY...\n*\n*                                 CHECK FOR SR OR LR INST\n*\n         LR    R11,R8             R11 -> AT SVC 11\n         SH    R11,=H'2'          R11 -> BACK 2 BYTES\n         CLC   0(2,R11),=X'1B11'  PREV INST SR 1,1 ?\n         BE    GOTSVC11           YES, PROBABLY A REAL SVC11\n         CLC   0(1,R11),=X'18'    PREV INST LR ?\n         BE    GOTSVC11           YES, PROBABLY A REAL SVC11\n*\n*                                 CHECK FOR LA R0 OR LA R1 INST\n*\n         SH    R11,=H'2'          R11 -> BACK 2 MORE BYTES\n         CLC   0(2,R11),=X'4100'  PREV INST LA R0,XX ?\n         BE    GOTSVC11           YES, PROBABLY A REAL SVC11\n         CLC   0(2,R11),=X'4110'  PREV INST LA R1,XX ?\n         BNE   TEST2              NO, DO NEXT TEST\n*        BE    GOTSVC11           YES, PROBABLY A REAL SVC11\n*\nGOTSVC11 DS    0H\n         LR    R11,R8             R11 = ADDR OF INST IN CASE DEBUG\n         LA    R8,2(0,R8)         R8 -> TO NEXT INST.\n         BCTR  R5,0               SET R5 FOR BCT LATER...\n*\n*        SEE IF NEXT BYTE COULD BE A VALID INSTRUCTION\n*\n         TRT   0(1,R8),INSTTAB    LOOK FOR VALID INSTRUCTION\n         BZ    NEXTBYT2           NOT VALID, CHECK NEXT BYTE...\n         LH    R1,SVCCTR          VALID, COUNT IT\n         LA    R1,1(0,R1)         ADD ONE\n         STH   R1,SVCCTR          SAVE NEW COUNT\n         L     R1,SVCCTR2         VALID, COUNT IT\n         LA    R1,1(0,R1)         ADD ONE\n         ST    R1,SVCCTR2         SAVE NEW COUNT\n         TM    FLAG1,X'20'        WANT OFFSET INFO?\n         BZ    NEXTBYT2           NO\n*        LR    R11,R8             R11 = ADDR OF INST IN CASE DEBUG\n         S     R11,LOADADDR       R11 = OFFSET TO INST\n         ST    R11,DWORD          SAVE OFFSET\n         MVC   SHOWMSG(20),=C'TIME MACRO AT OFFSET'\n         BAL   R11,SHOWOFF        GO PRINT IT\n         B     NEXTBYT2           CHECK FOR MORE\n*                                 SAY POSSIBLE TIME MACRO\n*        MVC   PSTYPE(19),=C'TIME MACRO (SVC 11)'\n*        B     CHKINST            YES, RECORD IS FINISHED\n*\nTEST2    DS    0H\n         CLC   =X'B205',0(R8)     POSSIBLE STCK INSTRUCTION?\n         BNE   TEST3              NO, DO NEXT TEST\n*\n*              SEE IF ADDRESS IS DIVISIBLE BY 2\n*\n****     L     R11,LOADADDR       R11 = ADDR OF LOADED MEMBER\n****     SR    R11,R8             R11 = OFFSET TO INST\n*        LR    R11,R8             R11 = ADDR OF INST\n*        S     R11,LOADADDR       R11 = OFFSET TO INST\n*        LR    R1,R11             R1 = OFFSET TO INST\n*        SRL   R1,1               DIVIDE BY 2\n*        SLL   R1,1               MULTIPLY BY 2\n*        CR    R1,R11             STILL THE SAME?\n*        BNE   NEXTBYTE           NO, NOT AN INSTRUCTION\n*\n*              OKAY, WE HAVE AN STCK. CHECK PREVIOUS\n*              INSTRUCTIONS FOR VALIDITY...\n*\n*              SEE IF WE ARE THE BACK END OF A 4 BYTE INSTRUCTION\n*\n         LR    R11,R8             R11 -> AT CODE\n         SH    R11,=H'2'          R11 -> BACK 2 BYTES\n         TRT   0(1,R11),INSTTAB4  LOOK FOR VALID INSTRUCTION\n         BNZ   TEST3              VALID, SO STCK IS NOT....\n*\n*              SEE IF WE ARE THE MIDDLE OF A 6 BYTE INSTRUCTION\n*\n         TRT   0(1,R11),INSTTAB6  LOOK FOR VALID INSTRUCTION\n         BNZ   TEST3              VALID, SO STCK IS NOT....\n*\n*              SEE IF WE ARE THE BACK END OF A 6 BYTE INSTRUCTION\n*\n         LR    R11,R8             R11 -> AT CODE\n         SH    R11,=H'4'          R11 -> BACK 4 BYTES\n         TRT   0(1,R11),INSTTAB6  LOOK FOR VALID INSTRUCTION\n         BNZ   TEST3              VALID, SO STCK IS NOT....\n*\n*                                 CHECK FOR 2 BYTE INST.\n*\n         LR    R11,R8             R11 -> AT CODE\n         SH    R11,=H'2'          R11 -> BACK 2 BYTES\n         TRT   0(1,R11),INSTTAB   LOOK FOR VALID INSTRUCTION\n         BNZ   GOTSTCK            VALID, CHECK NEXT BYTE...\n*\n*                                 CHECK FOR 4 BYTE INST.\n*\n         SH    R11,=H'2'          R11 -> BACK 2 MORE BYTES\n         TRT   0(1,R11),INSTTAB4  LOOK FOR VALID INSTRUCTION\n         BNZ   GOTSTCK            VALID, CHECK NEXT BYTE...\n*\n*                                 CHECK FOR 6 BYTE INST.\n*\n         SH    R11,=H'2'          R11 -> BACK 2 MORE BYTES\n         TRT   0(1,R11),INSTTAB6  LOOK FOR VALID INSTRUCTION\n         BZ    TEST3              NOT VALID, DO NEXT TEST\n*\nGOTSTCK  DS    0H\n         LR    R11,R8             R11 = ADDR OF INST IN CASE DEBUG\n         LA    R8,4(0,R8)         R8 -> TO NEXT INST.\n         BCTR  R5,0               SET R5 FOR BCT LATER...\n         BCTR  R5,0               SET R5 FOR BCT LATER...\n         BCTR  R5,0               SET R5 FOR BCT LATER...\n*\n*        SEE IF NEXT BYTE COULD BE A VALID INSTRUCTION\n*\n         TRT   0(1,R8),INSTTAB    LOOK FOR VALID INSTRUCTION\n         BZ    NEXTBYT2           NOT VALID, CHECK NEXT BYTE...\n*\n*        IT LOOKS REAL, SO COUNT IT\n*\n         LH    R1,STCKCTR         VALID, COUNT IT\n         LA    R1,1(0,R1)         ADD ONE\n         STH   R1,STCKCTR         SAVE NEW COUNT\n         L     R1,STCKCTR2        VALID, COUNT IT\n         LA    R1,1(0,R1)         ADD ONE\n         ST    R1,STCKCTR2        SAVE NEW COUNT\n         TM    FLAG1,X'20'        WANT OFFSET INFO?\n         BZ    NEXTBYT2           NO\n*        LR    R11,R8             R11 = ADDR OF INST\n         S     R11,LOADADDR       R11 = OFFSET TO INST\n         ST    R11,DWORD          SAVE OFFSET\n         MVC   SHOWMSG(20),=CL20'STCK INST AT OFFSET'\n         BAL   R11,SHOWOFF        GO PRINT IT\n         B     NEXTBYT2           CHECK FOR MORE\n*\nDECOFFST DC    CL9' '             OFFSET IN DECIMAL\nSHOWMSG  DC    CL20' '            OFFSET MSG\n*\n*                                 SAY POSSIBLE STCK INSTRUCTION\n*        MVC   PSTYPE(16),=C'STCK INSTRUCTION'\n*        B     CHKINST            YES, RECORD IS FINISHED\n*\nTEST3    DS    0H\n         CLC   =X'B207',0(R8)     POSSIBLE STCKC INSTRUCTION?\n         BNE   TEST4              NO, DO NEXT TEST\n*\n*              SEE IF ADDRESS IS DIVISIBLE BY 2\n*\n****     L     R11,LOADADDR       R11 = ADDR OF LOADED MEMBER\n****     SR    R11,R8             R11 = OFFSET TO INST\n*        LR    R11,R8             R11 = ADDR OF INST\n*        S     R11,LOADADDR       R11 = OFFSET TO INST\n*        LR    R1,R11             R1 = OFFSET TO INST\n*        SRL   R1,1               DIVIDE BY 2\n*        SLL   R1,1               MULTIPLY BY 2\n*        CR    R1,R11             STILL THE SAME?\n*        BNE   NEXTBYTE           NO, NOT AN INSTRUCTION\n*\n*              OKAY, WE HAVE AN STCKC. CHECK PREVIOUS\n*              INSTRUCTIONS FOR VALIDITY...\n*\n*              SEE IF WE ARE THE BACK END OF A 4 BYTE INSTRUCTION\n*\n         LR    R11,R8             R11 -> AT SVC 11\n         SH    R11,=H'2'          R11 -> BACK 2 BYTES\n         TRT   0(1,R11),INSTTAB4  LOOK FOR VALID INSTRUCTION\n         BNZ   TEST4              VALID, SO STCKC IS NOT....\n*\n*              SEE IF WE ARE THE MIDDLE OF A 6 BYTE INSTRUCTION\n*\n         TRT   0(1,R11),INSTTAB6  LOOK FOR VALID INSTRUCTION\n         BNZ   TEST4              VALID, SO STCKC IS NOT....\n*\n*              SEE IF WE ARE THE BACK END OF A 6 BYTE INSTRUCTION\n*\n         LR    R11,R8             R11 -> AT SVC 11\n         SH    R11,=H'4'          R11 -> BACK 4 BYTES\n         TRT   0(1,R11),INSTTAB6  LOOK FOR VALID INSTRUCTION\n         BNZ   TEST4              VALID, SO STCKC IS NOT....\n*\n*                                 CHECK FOR 2 BYTE INST.\n*\n         LR    R11,R8             R11 -> AT SVC 11\n         SH    R11,=H'2'          R11 -> BACK 2 BYTES\n         TRT   0(1,R11),INSTTAB   LOOK FOR VALID INSTRUCTION\n         BNZ   GOTSTCKC           VALID, CHECK NEXT BYTE...\n*\n*                                 CHECK FOR 4 BYTE INST.\n*\n         SH    R11,=H'2'          R11 -> BACK 2 MORE BYTES\n         TRT   0(1,R11),INSTTAB4  LOOK FOR VALID INSTRUCTION\n         BNZ   GOTSTCKC           VALID, CHECK NEXT BYTE...\n*\n*                                 CHECK FOR 6 BYTE INST.\n*\n         SH    R11,=H'2'          R11 -> BACK 2 MORE BYTES\n         TRT   0(1,R11),INSTTAB6  LOOK FOR VALID INSTRUCTION\n         BZ    TEST4              NOT VALID, DO NEXT TEST\n*\nGOTSTCKC DS    0H\n         LR    R11,R8             R11 = ADDR OF INST IN CASE DEBUG\n         LA    R8,4(0,R8)         R8 -> TO NEXT INST.\n         BCTR  R5,0               SET R5 FOR BCT LATER...\n         BCTR  R5,0               SET R5 FOR BCT LATER...\n         BCTR  R5,0               SET R5 FOR BCT LATER...\n*\n*        SEE IF NEXT BYTE COULD BE A VALID INSTRUCTION\n*\n         TRT   0(1,R8),INSTTAB    LOOK FOR VALID INSTRUCTION\n         BZ    NEXTBYT2           NOT VALID, CHECK NEXT BYTE...\n*\n*        IT LOOKS REAL, SO COUNT IT\n*\n         LH    R1,STCKCCTR        VALID, COUNT IT\n         LA    R1,1(0,R1)         ADD ONE\n         STH   R1,STCKCCTR        SAVE NEW COUNT\n         L     R1,STCKCCT2        VALID, COUNT IT\n         LA    R1,1(0,R1)         ADD ONE\n         ST    R1,STCKCCT2        SAVE NEW COUNT\n         TM    FLAG1,X'20'        WANT OFFSET INFO?\n         BZ    NEXTBYT2           NO\n*        LR    R11,R8             R11 = ADDR OF INST IN CASE DEBUG\n         S     R11,LOADADDR       R11 = OFFSET TO INST\n         ST    R11,DWORD          SAVE OFFSET\n         MVC   SHOWMSG(20),=CL20'STCKC INST AT OFFSET'\n         BAL   R11,SHOWOFF        GO PRINT IT\n         B     NEXTBYT2           CHECK FOR MORE\n*                                 SAY POSSIBLE STCKC INSTRUCTION\n*        MVC   PSTYPE(17),=C'STCKC INSTRUCTION'\n*        B     CHKINST            YES, RECORD IS FINISHED\n*                                 SAY POSSIBLE STCKC INSTRUCTION\n*\n*              SEE IF WE CAN FIND POSSIBLE CVTDATE ACCESS...\n*\nTEST4    DS    0H\n         CLI   0(R8),X'58'        LOAD INSTRUCTION?\n         BNE   TEST5              NO, DO NEXT TEST\n         CLC   =X'0010',2(R8)     ACCESSING CVT ?\n         BNE   TEST5              NO, DO NEXT TEST\n*\n*              OKAY, WE HAVE CVT ACCESS. CHECK PREVIOUS\n*              INSTRUCTIONS FOR VALIDITY...\n*\n*              SEE IF WE ARE THE BACK END OF A 4 BYTE INSTRUCTION\n*\n         LR    R11,R8             R11 -> AT CODE\n         SH    R11,=H'2'          R11 -> BACK 2 BYTES\n*        TRT   0(1,R11),INSTTAB4  LOOK FOR VALID INSTRUCTION\n*        BNZ   TEST5              VALID, SO STCK IS NOT....\n*\n*              SEE IF WE ARE THE MIDDLE OF A 6 BYTE INSTRUCTION\n*\n         TRT   0(1,R11),INSTTAB6  LOOK FOR VALID INSTRUCTION\n         BNZ   TEST5              VALID, SO CVT IS NOT....\n*\n*              SEE IF WE ARE THE BACK END OF A 6 BYTE INSTRUCTION\n*\n         LR    R11,R8             R11 -> AT CODE\n         SH    R11,=H'4'          R11 -> BACK 4 BYTES\n         TRT   0(1,R11),INSTTAB6  LOOK FOR VALID INSTRUCTION\n         BNZ   TEST5              VALID, SO CVT IS NOT....\n*\n*                                 CHECK FOR 2 BYTE INST.\n*\n         LR    R11,R8             R11 -> AT CODE\n         SH    R11,=H'2'          R11 -> BACK 2 BYTES\n         TRT   0(1,R11),INSTTAB   LOOK FOR VALID INSTRUCTION\n         BNZ   GOTCVT             VALID, CHECK NEXT BYTE...\n*\n*                                 CHECK FOR 4 BYTE INST.\n*\n         SH    R11,=H'2'          R11 -> BACK 2 MORE BYTES\n         TRT   0(1,R11),INSTTAB4  LOOK FOR VALID INSTRUCTION\n         BNZ   GOTCVT             VALID, CHECK NEXT BYTE...\n*\n*                                 CHECK FOR 6 BYTE INST.\n*\n         SH    R11,=H'2'          R11 -> BACK 2 MORE BYTES\n         TRT   0(1,R11),INSTTAB6  LOOK FOR VALID INSTRUCTION\n         BZ    TEST5              NOT VALID, DO NEXT TEST\n*\nGOTCVT   DS    0H\n         MVC   CVTDATET(1),1(R8)  SAVE REG AS BASE TO CVTDATE OFFSET\n         MVC   CVTDATE2(1),1(R8)  SAVE REG AS BASE TO CVTDATE OFFSET\n         LR    R11,R8             R11 = ADDR OF INST IN CASE DEBUG\n         LA    R8,4(0,R8)         R8 -> TO NEXT INST.\n         BCTR  R5,0               SET R5 FOR BCT LATER...\n         BCTR  R5,0               SET R5 FOR BCT LATER...\n         BCTR  R5,0               SET R5 FOR BCT LATER...\n*\n*        SEE IF NEXT BYTE COULD BE A VALID INSTRUCTION\n*\n         TRT   0(1,R8),INSTTAB    LOOK FOR VALID INSTRUCTION\n         BZ    NEXTBYT2           NOT VALID, CHECK NEXT BYTE...\n*\n*        SEE IF WE ARE ACCESSING CVTDATE....\n*\n         CLC   CVTDATET,2(R8)     LOADING CVTDATE?\n         BE    GOTCVT2            YES\n         CLC   CVTDATET,4(R8)     MOVING CVTDATE?\n         BE    GOTCVT2            YES\n         CLC   CVTDATE2,2(R8)     LOADING CVTDATE+1?\n         BE    GOTCVT2            YES\n         CLC   CVTDATE2,4(R8)     MOVING CVTDATE+1?\n         BNE   GOTCVT4            NO\n*\n*        IT LOOKS REAL, SO COUNT IT\n*\nGOTCVT2  DS    0H\n         LH    R1,CVTDCTR         VALID, COUNT IT\n         LA    R1,1(0,R1)         ADD ONE\n         STH   R1,CVTDCTR         SAVE NEW COUNT\n         L     R1,CVTDCTR2        VALID, COUNT IT\n         LA    R1,1(0,R1)         ADD ONE\n         ST    R1,CVTDCTR2        SAVE NEW COUNT\n         TM    FLAG1,X'20'        WANT OFFSET INFO?\n         BZ    NEXTBYT2           NO\n*        LR    R11,R8             R11 = ADDR OF INST\n         S     R11,LOADADDR       R11 = OFFSET TO INST\n         ST    R11,DWORD          SAVE OFFSET\n         MVC   SHOWMSG(20),=CL20'CVTDATE AT OFFSET'\n         BAL   R11,SHOWOFF        GO PRINT IT\n         B     NEXTBYT2           CHECK FOR MORE\n*\n*\n*        SAY WE ACCESSED THE CVT ANYWAY...\n*\nGOTCVT4  DS    0H\n         LH    R1,CVTCTR          VALID, COUNT IT\n         LA    R1,1(0,R1)         ADD ONE\n         STH   R1,CVTCTR          SAVE NEW COUNT\n         L     R1,CVTCTR2         VALID, COUNT IT\n         LA    R1,1(0,R1)         ADD ONE\n         ST    R1,CVTCTR2         SAVE NEW COUNT\n         TM    FLAG1,X'20'        WANT OFFSET INFO?\n         BZ    NEXTBYT2           NO\n*        LR    R11,R8             R11 = ADDR OF INST\n         S     R11,LOADADDR       R11 = OFFSET TO INST\n         ST    R11,DWORD          SAVE OFFSET\n         MVC   SHOWMSG(20),=CL20'CVT ACCESS AT OFFSET'\n         BAL   R11,SHOWOFF        GO PRINT IT\n         B     NEXTBYT2           CHECK FOR MORE\n*\nCVTDATET DC    X'0038'            OFFSET TO CVTDATE IN INST\nCVTDATE2 DC    X'0038'            OFFSET TO CVTDATE IN INST\n*ECOFFST DC    CL9' '             OFFSET IN DECIMAL\n*HOWMSG  DC    CL20' '            OFFSET MSG\n*\n*\nTEST5    DS    0H\n*\n*              SEE IF WE CAN FIND ANY NAMES/DATA WE WANT...\n*\n*\nTESTDATA DS    0H\n         TM    FLAG1,X'40'        ABEND AT SPECIFIC MODULE?\n         BO    NEXTBYTE           YES, DON'T DO PARM CHECK\n*\n         ST    R6,SAVE6           SAVE R6\n         LA    R6,MODTABLE        R6 -> AT MOD NAME TABLE\n         USING MODENTRY,R6        SET TABLE BASE\n         B     NEXTMOD2           ON WE GO...\n         SPACE 1\nNEXTMOD  DS    0H\n         LA    R6,MODTBLTH(0,R6)  R6 -> AT NEXT ENTRY\n         SPACE 1\nNEXTMOD2 DS    0H\n         CLI   MODLTH,X'FF'       END OF TABLE?\n         BE    NEXTBYTE           YES\n         SPACE 1\n*        ICM   R3,3,PARMLTH       R3 = LTH OF PARM\n         SR    R3,R3              R3 = 0\n         ICM   R3,1,MODLTH        R3 = LTH OF PARM/MODULE NAME\n         BZ    NEXTBYTE           NO PARM, CHECK NEXT BYTE\n*\n         LA    R1,0(R3,R8)        R1 -> END OF INSTRUCTION...\n         CR    R1,R10             PAST END OF MODULE?\n         BH    NEXTMOD            YES, CAN'T TEST. TRY NEXT TABLE ENT\n*\n         BCTR  R3,0               R3 = HEX LTH\n         EX    R3,TESTPARM        CHECK FOR PARM\n         BNE   NEXTMOD            NO, CHECK NEXT TABLE ENTRY\n         LR    R11,R8             R11 = ADDR OF INST IN CASE DEBUG\n         LA    R8,1(R3,R8)        R8 -> TO NEXT INST.\n*        BCTR  R5,0               SET R5 FOR BCT LATER...\n         SR    R5,R3              SET R5 FOR BCT LATER...\n*\n*        LH    R1,PGMCTR          VALID, COUNT IT\n         LH    R1,MODCTR          VALID, COUNT IT\n         LA    R1,1(0,R1)         ADD ONE\n         STH   R1,MODCTR          SAVE NEW COUNT\n*        STH   R1,PGMCTR          SAVE NEW COUNT\n         L     R1,PGMCTR2         VALID, COUNT IT\n         LA    R1,1(0,R1)         ADD ONE\n         ST    R1,PGMCTR2         SAVE NEW COUNT\n         TM    FLAG1,X'20'        WANT OFFSET INFO?\n         BZ    NEXTBYT2           NO\n*        LR    R11,R8             R11 = ADDR OF INST IN CASE DEBUG\n         MVC   SHOWMSG(20),=CL20'MODNAME    AT OFFSET'\n         MVC   SHOWMSG(08),MODNAME\n         CLI   MODTYPE,C'H'       IS DATA HEX?\n         BNE   NOTHEX             NO\n         ICM   R3,1,MODLTH        R3 = LTH OF PARM/MODULE NAME\n         BZ    NOTHEX             NO LTH, END OF MODULE\n         EX    R3,HEXUNPK         UNPACK HEX DATA\n         EX    R3,HEXTR2          TRANSLATE TO DISPLAY\n         SLL   R3,1               R3*2 = HEX LTH OF UNPACKED DATA..\n         LA    R14,DWORD+8        R14 -> AT DWORD\n         SR    R14,R3             R14 S/B -> AT HEX DATA...\n*        SRL   R7,1               DIVIDE BY 2\n         BCTR  R3,0               R3 = LTH TO MOVE\n         MVI   SHOWMSG,C' '       CLEAR SHOWMSG...\n         MVC   SHOWMSG+1(7),SHOWMSG\n         EX    R3,HEXMVC4         PUT DATA IN MESSAGE\n*\nNOTHEX   DS    0H\n         S     R11,LOADADDR       R11 = OFFSET TO INST\n         ST    R11,DWORD          SAVE OFFSET\n         BAL   R11,SHOWOFF        GO PRINT IT\n         B     NEXTBYT2           CHECK FOR MORE\n*        MVC   PSTYPE(13),=C'CALLS MODULE ' SET UP MESSAGE\n*        MVC   PSTYPE+13(8),SCRDATE         JUST IN CASE...\n*        B     WRITEREC           WE FOUND IT, GO TELL USER\n         SPACE 1\nHEXMVC4  MVC   SHOWMSG(0),0(R14)  SET UP DATA\n*\nTESTPARM CLC   0(0,R8),MODNAME    CHECK FOR PARM\n*ESTPARM CLC   0(0,R8),SCRDATE    CHECK FOR PARM\n*\nSHOWOFF  DS    0H\n*\n*              CONVERT OFFSET TO DECIMAL\n*\n*        MVC   LOCRC(3),DWORD+1   PUT IN HEX RC\n         UNPK  DECOFFST(9),DWORD(5) UNPACK OFFSET         DEBUG\n         MVI   DECOFFST+8,X'EF'   TRANSLATES TO BLANK     DEBUG\n         TR    DECOFFST(9),TRTAB2-239 TRANSLATE TO DISPLAY DEBUG\n         SPACE 1\n         MVC   PSTYPE(20),SHOWMSG\n         MVC   PSTYPE+21(8),DECOFFST\n         SPACE 1\n         ST    R5,SAVER5          SAVE R5\n         BAL   R5,PRINTLNE        GO PRINT IT\n         L     R5,SAVER5          LOAD R5\n         BR    R11                RETURN TO CALLER\n*\nNEXTBYTE DS    0H\n         LA    R8,1(0,R8)         R8 -> TO NEXT CHAR\n*\n*            GO TO 24 BIT MODE ADDRESSING\n*\n*        LA    R1,*+4+2           GET INTO 24 BIT MODE\n*        BSM   0,R1               ''\n         BAS  R14,@AMODE24\n*\n*\nNEXTBYT2 DS    0H\n         DROP  R6                 DROP MODTABLE BASE\n         L     R6,SAVE6           LOAD R6\n         BCT   R5,TESTTYPE        CHECK NEXT BYTE\n*\n*              FINISHED WITH THIS MODULE, SO RELEASE IT\n*\n         LA    R0,DELNAME         R0 -> AT MEMBER NAME\n         DELETE EPLOC=(0)         DELETE THE MEMBER\n*\n*        SEE IF WE FOUND ANY TIME INSTRUCTIONS\n*\n*\n*            GO TO 24 BIT MODE ADDRESSING\n*\n         LA    R1,*+4+2           GET INTO 24 BIT MODE\n         BSM   0,R1               ''\n*\nCHKSVC   DS    0H\n         SR    R7,R7              CLEAR R7\n         ICM   R7,3,SVCCTR        R7 = NBR OF TIMES SVC 11 FOUND\n         BZ    CHKSTCK            NONE, CHECK FOR STCK\n*        CLC   SVCCTR,=H'0'       ANY SVC 11'S FOUND?\n*        BE    CHKSTCK            NO, CHECK FOR STCK\n         MVC   PSTYPE(20),=CL20'TIME MACRO (SVC 11)'\n*        LH    R7,SVCCTR          R7 = COUNTER\n         CVD   R7,WORKD\n         MVC   PSCOUNT,PATTERN\n         ED    PSCOUNT,WORKD+4\n         PUT   PRINT,SCRCARD      PRINT IT\n         MVI   MBRNAME,C' '       CLEAR PRINT LINE\n         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''\n         MVC   SVCCTR,=H'0'       CLEAR COUNTER\n*\nCHKSTCK  DS    0H\n*        CLC   STCKCTR,=H'0'      ANY STCK'S FOUND?\n*        BE    CHKSTCKC           NO, CHECK FOR STCKC\n         ICM   R7,3,STCKCTR       R7 = NBR OF TIMES STCK FOUND\n         BZ    CHKSTCKC           NONE, CHECK FOR STCK\n         MVC   PSTYPE(20),=CL20'STCK INSTRUCTION'\n*        LH    R7,STCKCTR         R7 = COUNTER\n         CVD   R7,WORKD\n         MVC   PSCOUNT,PATTERN\n         ED    PSCOUNT,WORKD+4\n         PUT   PRINT,SCRCARD      PRINT IT\n         MVI   MBRNAME,C' '       CLEAR PRINT LINE\n         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''\n         MVC   STCKCTR,=H'0'      CLEAR COUNTER\n*\nCHKSTCKC DS    0H\n*        CLC   STCKCCTR,=H'0'     ANY STCKC'S FOUND?\n*        BE    CHKPGM             NO, CHECK FOR PROGRAM NAME\n         ICM   R7,3,STCKCCTR      R7 = NBR OF TIMES STCKC FOUND\n         BZ    CHKCVTD            NONE, CHECK FOR CVTDATE ACCESS\n         MVC   PSTYPE(20),=CL20'STCKC INSTRUCTION'\n*        LH    R7,STCKCCTR        R7 = COUNTER\n         CVD   R7,WORKD\n         MVC   PSCOUNT,PATTERN\n         ED    PSCOUNT,WORKD+4\n         PUT   PRINT,SCRCARD      PRINT IT\n         MVI   MBRNAME,C' '       CLEAR PRINT LINE\n         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''\n         MVC   STCKCCTR,=H'0'     CLEAR COUNTER\n*\nCHKCVTD  DS    0H\n         ICM   R7,3,CVTDCTR       R7 = NBR OF TIMES CVTDATE FOUND\n         BZ    CHKCVT2            NONE, CHECK FOR PGM'S\n         MVC   PSTYPE(20),=CL20'CVTDATE ACCESS'\n         CVD   R7,WORKD\n         MVC   PSCOUNT,PATTERN\n         ED    PSCOUNT,WORKD+4\n         PUT   PRINT,SCRCARD      PRINT IT\n         MVI   MBRNAME,C' '       CLEAR PRINT LINE\n         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''\n         MVC   CVTDCTR,=H'0'      CLEAR COUNTER\n*\nCHKCVT2  DS    0H\n         ICM   R7,3,CVTCTR        R7 = NBR OF TIMES CVTDATE FOUND\n         BZ    CHKPGM             NONE, CHECK FOR PGM'S\n         MVC   PSTYPE(20),=CL20'CVT ACCESS'\n         CVD   R7,WORKD\n         MVC   PSCOUNT,PATTERN\n         ED    PSCOUNT,WORKD+4\n         PUT   PRINT,SCRCARD      PRINT IT\n         MVI   MBRNAME,C' '       CLEAR PRINT LINE\n         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''\n         MVC   CVTCTR,=H'0'       CLEAR COUNTER\n*\nCHKPGM   DS    0H\n*\n         ST    R6,SAVE6A          SAVE R6\n         LA    R6,MODTABLE        R6 -> AT MOD NAME TABLE\n         USING MODENTRY,R6        SET TABLE BASE\n         SPACE 1\nNEXTPGM  DS    0H\n         CLI   MODLTH,X'FF'       END OF TABLE?\n         BE    NOTIME             YES, END OF MODULE\n         SPACE 1\n         ICM   R3,1,MODLTH        R3 = LTH OF PARM/MODULE NAME\n         BZ    NOTIME             NO LTH, END OF MODULE\n*\n*\n*        LH    R1,MODCTR          VALID, COUNT IT\n         SPACE 1\n*        CLC   PGMCTR,=H'0'       ANY PGM'S FOUND?\n*        CLC   MODCTR,=H'0'       ANY PGM'S FOUND?\n*        BE    NOCOUNT            NO, CHECK NEXT ENTRY\n         ICM   R7,3,MODCTR        R7 = NBR OF TIMES FOUND\n         BZ    NOCOUNT            NONE, CHECK NEXT ENTRY\n*\n         CLI   MODTYPE,C'H'       IS DATA HEX?\n         BE    HEXDATA            YES.\n*\nCHARDATA DS    0H\n         MVC   PSTYPE(13),=C'CALLS MODULE ' SET UP MESSAGE\n         MVC   PSTYPE+13(8),MODNAME         JUST IN CASE...\n         B     RESTDATA           SET UP REST OF DATA\n*\nHEXDATA  DS    0H\n*        MVC   PSTYPE+13(8),MODNAME         JUST IN CASE...\n         EX    R3,HEXUNPK         UNPACK HEX DATA\n         EX    R3,HEXTR2          TRANSLATE TO DISPLAY\n****\n         SLL   R3,1               R3*2 = HEX LTH OF UNPACKED DATA..\n         LA    R14,DWORD+8        R14 -> AT DWORD\n         SR    R14,R3             R14 S/B -> AT HEX DATA...\n*        SRL   R7,1               DIVIDE BY 2\n         BCTR  R3,0               R3 = LTH TO MOVE\n         MVC   PSTYPE(11),=C'FOUND DATA ' SET UP MESSAGE\n         EX    R3,HEXMVC3         PUT DATA IN MESSAGE\n         B     RESTDATA           SET UP REST OF DATA\n         SPACE 1\nHEXUNPK  UNPK  DWORD(9),MODNAME(0) UNPACK DATA\nHEXTR2   TR    DWORD(8),TRTAB2-239 TRANSLATE TO DISPLAY\nHEXMVC3  MVC   PSTYPE+11(0),0(R14) SET UP DATA\nTRTAB2   DC    C' 0123456789ABCDEF'\n         SPACE 2\n*\nRESTDATA DS    0H\n*        MVC   PSTYPE+13(8),SCRDATE         JUST IN CASE...\n*        LH    R7,PGMCTR          R7 = COUNTER\n*        LH    R7,MODCTR          R7 = COUNTER\n         CVD   R7,WORKD\n         MVC   PSCOUNT,PATTERN\n         ED    PSCOUNT,WORKD+4\n         PUT   PRINT,SCRCARD      PRINT IT\n         MVI   MBRNAME,C' '       CLEAR PRINT LINE\n         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''\n         MVC   MODCTR,=H'0'       CLEAR COUNTER\n*        MVC   PGMCTR,=H'0'       CLEAR COUNTER\n*\nNOCOUNT  DS    0H\n         LA    R6,MODTBLTH(0,R6)  R6 -> AT NEXT ENTRY\n         B     NEXTPGM            SEE IF ANOTHER MODULE NAME\n         DROP  R6                 DROP MODTABLE BASE\n*        B     NOTIME             END OF MODULE..\n*\n*\n*        SEE IF NEXT BYTE COULD BE A VALID INSTRUCTION\n*\nCHKINST  DS    0H\n         TRT   0(1,R8),INSTTAB         LOOK FOR VALID INSTRUCTION\n         BNZ   WRITEREC           VALID, GO PRINT NAME\n*\nCLEARREC DS    0H\n         MVI   PSTYPE,C' '        CLEAR PRINT LINE\n         MVC   PSTYPE+1(CLRLTH2),PSTYPE ''\n*        MVI   MBRNAME,C' '       CLEAR PRINT LINE\n*        MVC   MBRNAME+1(CLRLTH1),MBRNAME ''\n         B     NEXTBYT2\n*\n*\n*        WRITE OUT DEBUG INFORMATION\n*\nPRINTLNE DS    0H\n*\n*            GO TO 24 BIT MODE ADDRESSING\n*\n         LA    R1,*+4+2           GET INTO 24 BIT MODE\n         BSM   0,R1               ''\n*\n         PUT   PRINT,SCRCARD      PRINT IT\n*\n*        GET BACK TO 31 BIT MODE ADDRESSING\n*\n         CNOP  0,4                ALIGN ON A FULLWORD BOUNDARY      RH\n         L     R1,*+8             GET 31 BIT MODE ADDRESS           RH\n         BSM   0,R1               GET INTO 31 BIT MODE              RH\n         BSM   0,R1               TO FILL 4 BYTES                   RH\n**       DS    0F                 ALIGN ON A FULLWORD BOUNDARY      RH\n         DC    X'80',AL3(*+3)     NEXT ADDRESS IS 31 BIT MODE       RH\n*\n*        MVI   PSTYPE,C' '        CLEAR PRINT LINE\n*        MVC   PSTYPE+1(CLRLTH2),PSTYPE ''\n         MVI   MBRNAME,C' '       CLEAR PRINT LINE\n         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''\n         BR    R5                 RETURN TO CALLER\n*\n*\n*\n*        WRITE OUT MEMBER CONTROL STATEMENT\n*\nWRITEREC DS    0H\n*\n*            GO TO 24 BIT MODE ADDRESSING\n*\n         LA    R1,*+4+2           GET INTO 24 BIT MODE\n         BSM   0,R1               ''\n*\n         PUT   PRINT,SCRCARD      PRINT IT\n*\n*        GET BACK TO 31 BIT MODE ADDRESSING\n*\n*        CNOP  0,4                ALIGN ON A FULLWORD BOUNDARY      RH\n*        L     R1,*+8             GET 31 BIT MODE ADDRESS           RH\n*        BSM   0,R1               GET INTO 31 BIT MODE              RH\n*        BSM   0,R1               TO FILL 4 BYTES                   RH\n**       DS    0F                 ALIGN ON A FULLWORD BOUNDARY      RH\n*        DC    X'80',AL3(*+3)     NEXT ADDRESS IS 31 BIT MODE       RH\n*\n         MVI   MBRNAME,C' '       CLEAR PRINT LINE\n         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''\n*\nNOTIME   DS    0H\n         L     R6,SAVE6A          RELOAD R6\n         L     R7,MBRCNT\n         LA    R7,1(0,R7)         INCREMENT COUNTER\n         ST    R7,MBRCNT\n         B     GETNEXT          GET NEXT MEMBER\n*\n*        ERROR ROUTINES\n*\nBADPARM  EQU   *\n         MVC   MBRNAME,=CL8'BADPARM*'\n         MVC   PSDATE(15),=C' PARM TOO LONG.'\n*\nBADPARM2 EQU   *\n         PUT   PRINT,SCRCARD      PRINT IT\n         LA    R15,16\n         ST    R15,RETCODE        SAVE RC\n         B     BADEND           LEAVE\n*\nNOMBRS   EQU   *\n         MVC   MBRNAME,=CL8'NOMBRS**'\n         MVC   PSDATE(18),=C' //INLIB IS EMPTY.'\n*        MVC   PSDATE(8),SCRDATE\n         B     BADPARM2         LEAVE\n*        PUT   PRINT,SCRCARD      PRINT IT\n*        LA    R15,16\n*        ST    R15,RETCODE        SAVE RC\n*        B     BADEND           LEAVE\n*\n*        CLOSE PDS\n*\nCLOSPDS  EQU   *\n         CLOSE (INPDSA),MODE=31\n*\n*        FREE STORAGE AREA\n*\n         FREEMAIN R,SP=10\n*\n*        AND RETURN\n*\nRETURN   EQU   *\n         MVI   MBRNAME,C' '       CLEAR PRINT LINE\n         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''\n         PUT   PRINT,SCRCARD      PRINT A BLANK LINE\n*\n         L     R7,MBRCNT\n         CVD   R7,WORKD\n         MVC   OUTCNT,PATTERN\n         ED    OUTCNT,WORKD+4\n         PUT   PRINT,OUTPRT       PRINT IT\n         LA    R15,0\n*\n         MVI   MBRNAME,C' '       CLEAR PRINT LINE\n         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''\n         PUT   PRINT,SCRCARD      PRINT A BLANK LINE\n*\n         ICM   R7,15,SVCCTR2\n         BZ    NOSVC\n         CVD   R7,WORKD\n         MVC   TIMERCNT,PATTERN\n         ED    TIMERCNT,WORKD+4\n         PUT   PRINT,TIMERMSG     PRINT IT\n         LA    R15,0\n*\nNOSVC    DS    0H\n         ICM   R7,15,STCKCTR2\n         BZ    NOSTCK\n         CVD   R7,WORKD\n         MVC   STCKCNT,PATTERN\n         ED    STCKCNT,WORKD+4\n         PUT   PRINT,STCKMSG      PRINT IT\n         LA    R15,0\n*\nNOSTCK   DS    0H\n         ICM   R7,15,STCKCCT2\n         BZ    NOSTCK2\n         CVD   R7,WORKD\n         MVC   STCKCCNT,PATTERN\n         ED    STCKCCNT,WORKD+4\n         PUT   PRINT,STCKCMSG     PRINT IT\n         LA    R15,0\n*\nNOSTCK2  DS    0H\n         ICM   R7,15,CVTDCTR2\n         BZ    NOCVTD2\n         L     R7,CVTDCTR2\n         CVD   R7,WORKD\n         MVC   CVTDCNT,PATTERN\n         ED    CVTDCNT,WORKD+4\n         PUT   PRINT,CVTDMSG      PRINT IT\n         LA    R15,0\n*\nNOCVTD2  DS    0H\n         ICM   R7,15,CVTCTR2\n         BZ    NOCVT2\n         L     R7,CVTCTR2\n         CVD   R7,WORKD\n         MVC   CVTCNT,PATTERN\n         ED    CVTCNT,WORKD+4\n         PUT   PRINT,CVTMSG       PRINT IT\n         LA    R15,0\n*\nNOCVT2   DS    0H\n         ICM   R7,15,PGMCTR2\n         BZ    NOPGM2\n         L     R7,PGMCTR2\n         CVD   R7,WORKD\n         MVC   PGMCNT,PATTERN\n         ED    PGMCNT,WORKD+4\n         PUT   PRINT,PGMMSG       PRINT IT\n         LA    R15,0\n*\nNOPGM2   DS    0H\n*\nBADEND   EQU   *\n         CLOSE PRINT,MODE=31\n         L     R15,RETCODE        LOAD RC\n         L     R13,4(R13)         R13 -> TO CALLERS SAVE AREA\n         L     R14,12(R13)        SET R14 TO WHAT CALLER'S R14\n         LM    R0,R12,20(R13)     SET R0-R12 TO CALLERS REGS\n*        BR    R14                RETURN TO CALLING PROGRAM\n*              GET INTO PROPER MODE AND GO BACK TO CALLER\n         BSM   0,R14              RETURN TO CALLING PROGRAM\n*\n*        ABEND\n*\nBADBAD   EQU   *\n         ABEND 799,DUMP,STEP\n*\n*      THIS ROUTINE SWITCHES THE AMODE TO 24\n*      ENTRY TO THIS ROUTINE IS THROUGH A BAS  R14,@AMODE24\n*\n         DS    0F\n         DC    X'7FFFFFFF'\n@AMODE24 EQU   *\n         N     R14,*-4\n         BSM   0,R14\n*\n*      THIS ROUTINE SWITCHES THE AMODE TO 31\n*      ENTRY TO THIS ROUTINE IS THROUGH A BAS  R14,@AMODE31\n*\n         DS    0F\n         DC    X'80000000'\n@AMODE31 EQU   *\n         O     R14,*-4\n         BSM   0,R14\n*\n*\n*\n*        DEFINE VARIABLES\n*\n*\n***************************WORK AREAS *********************************\n*\nWORKD    DS   D\nRETCODE  DC    F'0'\nLOADADDR DC    F'0'\n*AVEAREA DS   18F\n*\nSAVER1   DS    F\nSAVER5   DS    F\nSAVE6    DC    F'0'\nSAVE6A   DC    F'0'\nSVCCTR   DC    H'0'\nSTCKCTR  DC    H'0'\nSTCKCCTR DC    H'0'\nCVTCTR   DC    H'0'\nCVTDCTR  DC    H'0'\n*\nSVCCTR2  DC    F'0'\nSTCKCTR2 DC    F'0'\nSTCKCCT2 DC    F'0'\nPGMCTR2  DC    F'0'\nCVTCTR2  DC    F'0'\nCVTDCTR2 DC    F'0'\n         SPACE 2\nMBRTYPE  DC    C' '\nSTARTMBR DC    CL8' '\nENDMBR   DC    CL8' '\nDELNAME  DC    CL8' '             READ AREA FOR GET AT READSYS\nSYSDATA  DS    CL80\nSMBRLTH  DC    H'0'\nEMBRLTH  DC    H'0'\nSAVEALL  DC    18F'0'\n         CNOP  0,8\n*\nBLKAREA  DS    F\nMBRCNT   DC    F'0'\nMBRAREA  DS    F\nMBRADDR  DS    F\nENDADDR  DS    F\nDIRREC   DC    XL256'00'\n*\nSCRCARD  DS    0CL81              81 LONG TO READ 80 INTO MBRNAME..\nCARRCTL  DC    CL1' '\nMBRNAME  DS    CL8                READ AREA FOR GET AT READSYS\n         DC    CL2'  '\nPSDATE   DS    CL6\n         DC    CL2'  '\nPSTYPE   DS    CL21\n*PSDASH  DC    CL2'  '\nPSCOUNT  DS    CL8\n         DC    CL(81-(*-SCRCARD))' '\nCLRLTH1  EQU   *-MBRNAME-1\nCLRLTH2  EQU   *-PSTYPE-1\n*        DC    CL55' '\n*\n************** ************** CONSTANTS *******************************\n*\nFLAG1    DC    X'00'\n*        EQU   X'80'              SHOW DEBUG INFO\n*        EQU   X'40'              ABEND AT SPECIFIC MODULE\n*        EQU   X'20'              SHOW OFFSET OF STCK AND STCKC\n         SPACE 2\nOUTPRT   DS    0CL80\nCCO      DC    CL1' '\n         DC    CL29'NUMBER OF MEMBERS CHECKED : '\nOUTCNT   DS    CL8\n         DC    CL(80-(*-OUTPRT))' '\n*        DC    CL95' '\n*\nCNTMSG   DS    0CL80\n         DC    CL1' '\n         DC    C'NUMBER OF ALIAS MEMBERS NOT PROCESSED : '\nPRTCNT   DS    CL8\n         DC    CL(80-(*-CNTMSG))' '\nLCNTMSG  EQU   *-CNTMSG\n*\nTIMERMSG DS    0CL80\n         DC    CL1' '\n         DC    C'          NUMBER OF TIME MACROS (SVC 11) FOUND : '\nTIMERCNT DS    CL8\n         DC    CL(80-(*-TIMERMSG))' '\nLTMRMSG  EQU   *-TIMERMSG\n*\nSTCKMSG  DS    0CL80\n         DC    CL1' '\n         DC    C'    NUMBER OF POSSIBLE STCK INSTRUCTIONS FOUND : '\nSTCKCNT  DS    CL8\n         DC    CL(80-(*-STCKMSG))' '\nLSTCKMSG EQU   *-STCKMSG\n*\nSTCKCMSG DS    0CL80\n         DC    CL1' '\n         DC    C'   NUMBER OF POSSIBLE STCKC INSTRUCTIONS FOUND : '\nSTCKCCNT DS    CL8\n         DC    CL(80-(*-STCKCMSG))' '\nLSTCKCMS EQU   *-STCKCMSG\n*\nPGMMSG   DS    0CL80\n         DC    CL1' '\n         DC    C'  NUMBER OF TIMES PARM/SYSIN KEYWORD WAS FOUND : '\nPGMCNT   DS    CL8\n         DC    CL(80-(*-PGMMSG))' '\nLPGMMSG  EQU   *-PGMMSG\n*\nCVTDMSG  DS    0CL80\n         DC    CL1' '\n         DC    C'     NUMBER OF POSSIBLE CVTDATE ACCESSES FOUND : '\nCVTDCNT  DS    CL8\n         DC    CL(80-(*-CVTDMSG))' '\nLCVTDMSG EQU   *-CVTDMSG\n*\nCVTMSG   DS    0CL80\n         DC    CL1' '\n         DC    C'                  NUMBER OF CVT ACCESSES FOUND : '\nCVTCNT   DS    CL8\n         DC    CL(80-(*-CVTMSG))' '\nLCVTMSG EQU    *-CVTMSG\n*\nBADFIND  DC    C'ERROR DOING FIND FOR MEMBER. '\n*\nBADLOAD  DC    C'ERROR DOING LOAD FOR MEMBER..PROBABLY NOT EXECUTABLE'\nLOADMSG  DC    C'BEING LOADED FOR CHECKING'\nMAXMBR   DC    C'MAX MBRS REACHED. FIRST 9000 WILL BE PROCESSED'\nLMAXMBR  EQU   *-MAXMBR\n*LIASMSG DC    C'IS AN ALIAS AND WILL NOT BE TESTED'\nALIASMSG DC    C'IS AN ALIAS OF '\nALIASNAM DC    CL8' '\n         DC    C' AND WILL NOT BE TESTED'\nLALIASMS EQU   *-ALIASMSG\n*\nSCRATCHD DS    PL3\nTODAY    DS    PL3\n*\nMODTABLE DS    0H                 MODULE NAMES\nPARMLTH  DC    X'0'               1ST IS FROM PARM\n         DC    C'A'               PARM MUST BE ALPHA\nPGMCTR   DC    H'0'\nSCRDATE  DC    CL8' '\nMODTBLTH EQU   *-MODTABLE         LTH OF EACH ENTRY\n*        DC    H'0',H'0',CL8' '   ROOM FOR 40 MODULE NAMES\n         DC    X'0',C'A',H'0',CL8' '   ROOM FOR 40 MODULE NAMES\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\n         DC    X'0',C'A',H'0',CL8' '\nMODEND   DC    12X'FF'\n*\n*\nPATTERN  DC    XL8'4020202020202020'\n*\n*              TRANSLATE TABLE OF  VALID INSTRUCTIONS\n*\nINSTTAB  DS    0CL256\n*                   0 1 2 3 4 5 6 7 8 9 A B C D E F\n         DC    XL16'00000000010101010000010101010101' 0\n         DC    XL16'01010101010101010101010101010101' 1\n         DC    XL16'01010101010101010101010101010101' 2\n         DC    XL16'01010101010101010101010101010101' 3\n         DC    XL16'01010101010101010101010101010101' 4\n         DC    XL16'01010000010101010101010101010101' 5\n         DC    XL16'01000000000000010101010101010101' 6\n         DC    XL16'01000000000000000101010101010101' 7\n         DC    XL16'01000101010101010101010101010101' 8\n         DC    XL16'01010101010101010101010101010101' 9\n         DC    XL16'00000000010101000000000001010101' A\n         DC    XL16'00010100000001010000010100010101' B\n         DC    XL16'00000000000000000000000000000000' C\n         DC    XL16'00010101010101010001010101010101' D\n         DC    XL16'00000000010100000100000000000000' E\n         DC    XL16'01010101000000000101010101010000' F\n*                   0 1 2 3 4 5 6 7 8 9 A B C D E F\n*\n*              TRANSLATE TABLE OF  VALID 6 BYTE INSTRUCTIONS\n*\nINSTTAB6 DS    0CL256\n*                   0 1 2 3 4 5 6 7 8 9 A B C D E F\n         DC    XL16'00000000000000000000000000000000' 0\n         DC    XL16'00000000000000000000000000000000' 1\n         DC    XL16'00000000000000000000000000000000' 2\n         DC    XL16'00000000000000000000000000000000' 3\n         DC    XL16'00000000000000000000000000000000' 4\n         DC    XL16'00000000000000000000000000000000' 5\n         DC    XL16'00000000000000000000000000000000' 6\n         DC    XL16'00000000000000000000000000000000' 7\n         DC    XL16'00000000000000000000000000000000' 8\n         DC    XL16'00000000000000000000000000000000' 9\n         DC    XL16'00000000000000000000000000000000' A\n         DC    XL16'00000000000000000000000000000000' B\n         DC    XL16'00000000000000000000000000000000' C\n         DC    XL16'00010101010101010000000001010101' D\n         DC    XL16'00000000000000000000000000000000' E\n         DC    XL16'01010101000000000101010101010000' F\n*                   0 1 2 3 4 5 6 7 8 9 A B C D E F\n*\n*              TRANSLATE TABLE OF  VALID 4 BYTE INSTRUCTIONS\n*\nINSTTAB4 DS    0CL256\n*                   0 1 2 3 4 5 6 7 8 9 A B C D E F\n         DC    XL16'00000000000000000000000000000000' 0\n         DC    XL16'00000000000000000000000000000000' 1\n         DC    XL16'00000000000000000000000000000000' 2\n         DC    XL16'00000000000000000000000000000000' 3\n         DC    XL16'01010101010101010101010101000101' 4\n         DC    XL16'01000000010101010101010101010101' 5\n         DC    XL16'01000000000000010101010101010101' 6\n         DC    XL16'01000000000000000101010101010101' 7\n         DC    XL16'01000100010101010101010101010101' 8\n         DC    XL16'01010101010101010100000001010101' 9\n         DC    XL16'00000000000000000000000001010101' A\n         DC    XL16'00010100000001010000010100010101' B\n         DC    XL16'00000000000000000000000000000000' C\n         DC    XL16'00000000000000000000000000000000' D\n         DC    XL16'00000000000000000000000000000000' E\n         DC    XL16'00000000000000000000000000000000' F\n*                   0 1 2 3 4 5 6 7 8 9 A B C D E F\n*\n*              TRANSLATE TABLE OF  VALID 2 BYTE INSTRUCTIONS\n*\nINSTTAB2 DS    0CL256\n*                   0 1 2 3 4 5 6 7 8 9 A B C D E F\n         DC    XL16'00000000010101010101010000000101' 0\n         DC    XL16'01010101010101010101010101010101' 1\n         DC    XL16'01010101010101010101010101010101' 2\n         DC    XL16'01010101010100010101010001010101' 3\n         DC    XL16'00000000000000000000000000000000' 4\n         DC    XL16'00000000000000000000000000000000' 5\n         DC    XL16'00000001000000000000000000000000' 6\n         DC    XL16'00000000000000000000000100000000' 7\n         DC    XL16'00000000000000000000000000000000' 8\n         DC    XL16'00000000000000000000000000000000' 9\n         DC    XL16'00000000000000000000000000000000' A\n         DC    XL16'00000000000000000000000000000000' B\n         DC    XL16'00000000000000000000000000000000' C\n         DC    XL16'00000000000000000000000000000000' D\n         DC    XL16'00000000000000000000000000000000' E\n         DC    XL16'00000000000000000000000000000000' F\n*                   0 1 2 3 4 5 6 7 8 9 A B C D E F\n*\n*              HEADING.....\n*\nHEADING  DS    0H\n         DC    CL80' '\nLHEAD    EQU   *-HEADING\n         ORG   *-80\n         DC    C'THE FOLLOWING LOAD MODULES MAY CONTAIN THE TIME'\n         DC    C' OR STCK INSTRUCTION,'\n         ORG\n*\n         DC    CL80' '\n         ORG   *-80\n         DC    C'OR CALLS A TIME ROUTINE SPECIFIED IN THE PARM...'\n         ORG\n*\n*        DC    CL80' '\n*        ORG   *-80\n*        DC    C'THE CHECK ENDS WITH THE FIRST SUCCESSFUL MATCH.'\n*        DC    C' '\n*        DC    C'THE WHOLE MODULE IS NOT SCANNED.'\n*        ORG\n*\n         DC    CL80' '            A BLANK LINE...\n*\n         DC    CL80'END OF HEADING'\n*\n         DC    CL80' '\n         ORG   *-80\n         DC    CL8'MBRNAME'\n         DC    CL2'  '\n         DC    CL6'LINKED'\n         DC    CL2'  '\n         DC    CL11'INSTRUCTION'\n         DC    CL10'   '\n         DC    CL9'NBR FOUND'\n         ORG\n*\n         DC    CL80' '\n         ORG   *-80\n         DC    CL8'--------'\n         DC    CL2'  '\n         DC    CL6'------'\n         DC    CL2'  '\n         DC    CL11'-----------'\n         DC    CL10'   '\n         DC    CL9'---------'\n         ORG\n*\n         DC    CL80'END OF HEADING'\n*\n*\n*              DATASET NAME MESSAGE...\n*\nDSNMSG   DS    0H\n         DC    C'PROCESSING DATASET '\nPRTDSN   DC    CL44' '\n         DC    CL(80-(*-DSNMSG))' '\nLDSNMSG  EQU   *-DSNMSG\n*\n*\n*              HEADING 2 .....\n*\nHEADING2 DS    0H\n         DC    CL80' '            A BLANK LINE...\nLHEAD2   EQU   *-HEADING2\n*\n*        DC    CL80' '            A BLANK LINE...\n*\n         DC    CL80' '\n         ORG   *-80\n         DC    CL8'MBRNAME'\n         DC    CL2'  '\n         DC    CL6'LINKED'\n         DC    CL2'  '\n         DC    CL11'INSTRUCTION'\n         DC    CL10'   '\n         DC    CL9'NBR FOUND'\n         ORG\n*\n         DC    CL80' '\n         ORG   *-80\n         DC    CL8'--------'\n         DC    CL2'  '\n         DC    CL6'------'\n         DC    CL2'  '\n         DC    CL11'-----------'\n         DC    CL10'   '\n         DC    CL9'---------'\n         ORG\n*\n         DC    CL80'END OF HEADING2'\n*\n*\n*\n*              DISCLAIMER..\n*\nDISCLAIM DS    0H\n         DC    CL80' '\nLDIS     EQU   *-DISCLAIM\n         ORG   *-80\n         DC    CL20' '\n         DC    C'YR2000 UTILITY, VERSION 2.0'\n         ORG\n*\n         DC    CL80' '\n         ORG   *-80\n         DC    C'THIS UTILITY MAY NOT FUNCTION IN ALL ENVIRONMENTS,'\n         DC    C' '\n         DC    C'AND IS MADE AVAILABLE ASIS.'\n         ORG\n*\n         DC    CL80' '\n         ORG   *-80\n         DC    C'NO GUARANTEES OF ANY KIND ARE WARRANTED OR IMPLIED.'\n         ORG\n*\n         DC    CL80' '\n         ORG   *-80\n         DC    C'USE OF THIS UTILITY DOES NOT GUARANTEE YEAR 2000'\n         DC    C' '\n         DC    C'COMPLIANCE.           '\n         ORG\n         DC    CL80' '            A BLANK LINE...\n*\n         DC    CL80'END OF DISLAIM'\n*\n         LTORG\n*\n*\nSYSIN    DCB   DSORG=PS,MACRF=(GM),EODAD=EOFREAD,                      +\n               DDNAME=SYSIN\nSYSINL   EQU   *-SYSIN\n*\nPRINT    DCB   DDNAME=SYSPRINT,DSORG=PS,RECFM=FBA,BLKSIZE=8880,        X\n               MACRF=(PM),LRECL=80\nINPDS    DCB   DDNAME=INLIB,DSORG=PS,RECFM=F,BLKSIZE=256,MACRF=(R),    X\n               EODAD=LOADMBR\nINPDSA   DCB   DDNAME=INLIB,DSORG=PO,EODAD=GETNEXT,MACRF=(R),          X\n               RECFM=U,LRECL=256,BLKSIZE=19069,                        X\n               EXLST=JFCBADD\n         SPACE 1\nJFCBADD  DS    0F\n         DC    X'87'              JFCB ADDRESS\n         DC    AL3(JFCB)\n         DS    0H                 PUT JFCB ON HALFWORD BOUNDARY\nJFCB     DS    0CL176' '\n         IEFJFCBN  LIST=NO\nMODENTRY DSECT\n*        DC    X'0',C'A',H'0',CL8' '   ROOM FOR 40 MODULE NAMES\nMODLTH   DC    X'0'\nMODTYPE  DC    C'A'\nMODCTR   DC    H'0'\nMODNAME  DC    CL8' '\n         SPACE 1\n*\n*BLANKS  DC    256CL1' '\n         IKJTCB\n         IHACDE\n         IHALPDE\n         IHAPSA DSECT=YES,LIST=YES\n         IHAXTLST\n         IHALLE\n         END   YR2000\n//LKED.SYSLMOD DD DISP=SHR,DSN=HALL.LINKLIB\n//SYSIN   DD *\n ENTRY   YR2000\n SETCODE AC(0)\n MODE AMODE(31) RMODE(24)\n NAME    YR2000(R)\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "YR2000J": {"ttr": 23303, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03?\\x00\\x99\\x03?\\x13H\\x00-\\x00-\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-02T00:00:00", "modifydate": "1999-02-02T13:48:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "RH87944"}, "text": "//YR2000J  JOB\n/*ROUTE  PRINT R7\n//*\n//OUT1   OUTPUT DEFAULT=NO,COPIES=1,CLASS=A,          LANDSCAPE 67X138\n//             PAGEDEF=L1C100,FORMDEF=L1C000\n//OUT2   OUTPUT DEFAULT=NO,COPIES=1,CLASS=A,          PORTRAIT 88X96\n//             PAGEDEF=P1E100,FORMDEF=P1E000\n//OUT3   OUTPUT DEFAULT=NO,COPIES=1,CLASS=A,          PORTRAIT 64X80\n//             PAGEDEF=P1B000,FORMDEF=P1B000\n//OUT4   OUTPUT FORMDEF=DCF,LINECT=0          FOR LASER/DCF, SYSOUT=1\n//*\n//*\n//*\n//*    DSN=CBT.SOURCE(YR2000J)\n//*\n//*          GET A LIST OF MEMBERS IN //INLIB THAT MAY CONTAIN THE\n//*          TIME MACRO, OR THE STCK INSTRUCTION,\n//*          OR MAY CALL THE TIME ROUTINE SPECIFIED BY PARM=....\n//*\n//*          IF PARM IS \"OFFSET\" EXTRA INFO WILL BE PRINTED SHOWING\n//*          THE OFFSET TO INSTRUCTIONS/DATA.\n//*\n//*          IF PARM IS \"DEBUG\" EXTRA INFO WILL BE PRINTED\n//*\n//*          IF PARM IS \"DEBUG=MODULENAME\" EXTRA INFO WILL BE PRINTED\n//*          AND THE PGM WILL ABEND WHEN \"MODULENAME\" IS LOADED\n//*\n//*R2000   EXEC PGM=YR2000,REGION=4000K,PARM='DEBUG=IGC0009D'\n//*R2000   EXEC PGM=YR2000,REGION=4000K,PARM='DEBUG=ICHRFR00'\n//*R2000   EXEC PGM=YR2000,REGION=4000K  ,PARM='DAYDATE'\n//*R2000   EXEC PGM=YR2000,REGION=4000K,PARM='DEBUG'\n//YR2000   EXEC PGM=YR2000,REGION=4000K,PARM='OFFSET,DEBUG'\n//STEPLIB  DD DISP=SHR,DSN=HALL.LINKLIB\n//*SYSPRINT DD SYSOUT=*\n//SYSPRINT DD SYSOUT=(,),OUTPUT=*.OUT2\n//*SYSUT2   DD SYSOUT=1,OUTPUT=*.OUT4         FOR LASER PRINTER\n//SYSABEND DD SYSOUT=*\n//INLIB    DD DISP=SHR,DSN=HALL.TESTLIB\n//SYSIN    DD *\nARCH00CV\nDAYDATE\nATT\nX'0A04'\n/*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZELLERS": {"ttr": 23305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x03/\\x00\\x99\\x03/\\x14&\\x00]\\x00]\\x00\\x00\\xd9\\xc8\\xf8\\xf7\\xf9\\xf4\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-02-01T00:00:00", "modifydate": "1999-02-01T14:26:00", "lines": 93, "newlines": 93, "modlines": 0, "user": "RH87944"}, "text": "*\n**********************************************************************\n*                                                                    *\n*        CALCULATE DAY OF WEEK USING T.F. WONG'S FORMULA             *\n*        SEE HTTP://WWW/ASIAONLIN.NET.HK/~TFWONG/MATHS.HTM\n*                                                                    *\n*        DAY OF WEEK\n*\n*                     Y - 1        Y - 1        Y - 1\n*   S = (Y - 1) + INT(-----) - INT(-----) + INT(-----) + D\n*                       4           100          400\n*\n*        WHERE: 1) ALL OPERATIONS ARE DONE USING INTEGER ARITH\n*               2) D = JULIAN DAY OF YEAR\n*               3) Y = YEAR\n*\n*   AFTER CALCULATING THE VALUE S, DIVIDE IT BY 7, AND GET THE\n*   REMAINDER. IF THE REMAINDER IS 0, THE DAY IS SUNDAY, IF IT IS 1,\n*   THE DAY IS MONDAY, ..., IF IT IS 6, THE DAY IS SATURDAY.\n*\n*        R1 : ACCUMULATOR\n*\n**********************************************************************\n*\n*              GET YEAR\n*\n         SR    R4,R4              CLEAR R4\n         L     R5,SAVEJUL         R5 = JULIAN DATE\n         SRL   R5,16              DROP DAY\n         SLL   R5,4               LEFT 4 BITS\n         LA    R5,15(0,R5)        ADD SIGN\n         XC    DOUBLE,DOUBLE      CLEAR DWORD\n         ST    R5,DOUBLE+4        SAVE IT\n         CVB   R5,DOUBLE          CONVERT TO BINARY\n         BCTR  R5,0               -1\n         LR    R1,R5              S STARTS WITH YEAR-1\n*\n*              GET (YEAR-1)/4\n*\n         SR    R6,R6              CLEAR R6\n         LR    R7,R5              R7 = Y-1\n         D     R6,=F'4'           CALC IF LEAP YEAR\n         AR    R1,R7              ADD IT TO S\n*\n*              GET (YEAR-1)/100\n*\n         SR    R6,R6              CLEAR R6\n         LR    R7,R5              R7 = Y-1\n         D     R6,=F'100'\n         SR    R1,R7              SUBTRACT IT FROM S\n*\n*              GET (YEAR-1)/400\n*\n         SR    R6,R6              CLEAR R6\n         LR    R7,R5              R7 = Y-1\n         D     R6,=F'400'\n         AR    R1,R7              ADD IT TO S\n*\n*              GET JULIAN DAY OF YEAR\n*\n         SR    R6,R6              CLEAR R6\n         L     R7,SAVEJUL         R7 = JULIAN DATE\n         SLL   R7,16              DROP YEAR\n         SRL   R7,16              ''\n         XC    DOUBLE,DOUBLE      CLEAR DWORD\n         ST    R7,DOUBLE+4        SAVE IT\n         CVB   R7,DOUBLE          CONVERT TO BINARY\n         AR    R1,R7              ADD IT TO S\n*\n*              DIVIDE S BY 7\n*\n         SR    R4,R4              CLEAR R4\n         LR    R5,R1              R5 = ??\n         D     R4,=F'7'           CALC WEEKS IN YEAR\n*\n*              GET DAY OF WEEK BASED ON REMAINDER IN R4\n*\n         MH    R4,=H'9'           R4 -> TO WEEK DAY\n         LA    R5,WEEKDAYS(R4)          GET DAY OF WEEK\nSETDAY   MVC   DAY,0(R5)                MOVE EBCDIC DAY TO FIELD\n*\n*\nSAVEJUL  DC    F'0'\n*\nWEEKDAYS EQU   *\n         DC    CL9'SUNDAY'\n         DC    CL9'MONDAY'\n         DC    CL9'TUESDAY'\n         DC    CL9'WEDNESDAY'\n         DC    CL9'THURSDAY'\n         DC    CL9'FRIDAY'\n         DC    CL9'SATURDAY'\n*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT354/FILE354.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT354", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}