Merging diagnostics and source

The first time a program source is assembled or compiled, there
will always be a lot of diagnostics, caused by small errors made
while typing in the statements. Then a time-consuming task
begins. Unpleasant, because we like to work on problems and
solutions, not on our own little mistakes. One by one the
diagnostic messages from the compiler must be read. Then the
associated source statement has to be found in the source listing,
using the line numbers generated by the compiler. Finally, the
statement in error has to be found in the source, for example by
using the line numbers generated by the ISPF editor in columns
73 to 80.

Of course we are all smart enough to speed up this process by
swapping between split screens, looking at the compiler output,
remembering as many errors as possible, swapping to the source
to correct these, swapping back to the compiler output, etc. Other
methods, such as routing the compiler output to a printer, cause
waiting and superfluous use of paper. If there are many errors it is
even customary to correct only some of the errors and then
recompile to get a fresh listing.

At our installation, we lightened this task by automating some
parts of it. Integrated in our program development environment we
have procedures that compile the source in the foreground, scan
the compiler diagnostic and the source-listing in the compiler
output, and find out which source line caused the diagnostic
message. Since this is all executed from the ISPF editor, the
diagnostics can be inserted in the edited source data as message
lines. The programmer now has the statement in error and the
diagnostic message together in view. He can scroll through the
source and correct all the errors. After that he can remove all the
messages by typing the ISPF RESET command. We use these
procedures for various languages such as COBOL, COBOL II,
C370, Fortran, and Assembler, including the messages generated
by the DB2 pre-compiler for programs that use SQL.

Of course, building a procedure takes some time, and has to be
repeated for every language, but in our experience it is well worth
doing.

To illustrate the possibilities of this method I extracted from our
development environment the parts needed for the compilation of
Assembler programs (without DB2 pre-compilation) and created
an ISPF edit macro in REXX, called EMASMC, that performs all
these tasks. To use the macro, enter an Assembler program with
the ISPF editor, then start the macro. The macro accepts two
parameters, separated by a slash. Anything before the slash causes
the display of a panel, where some Assembler parameters can be
entered. Behind the slash you can enter a REXX trace value,
useful to debug the macro.

The macro then takes care of the assembly and the processing of
the diagnostic messages and you get a screen that might look like
this:

EDIT ---- $A014.ASM.ASM(MYBR14) -- 01.00 --------------- COLUMNS 001 072
COMMAND ===> emasmc                                     SCROLL ===> CSR
****** ***************************** TOP OF DATA ***********************
000100 START    LA R15,0
==msg> iev044  *** error ***  undefined symbol
==msg> iev029  *** error ***  incorrect register or mask specification
000200          B  RETURN
==msg> iev044  *** error ***  undefined symbol
000300 *        NONSENS PROGRAM
000400 BACK     BR 14
==msg> iev140  ** warning **  end card missing
****** **************************** BOTTOM OF DATA *********************

EMASMC REXX EXEC

/*REXX edit macro to assemble and merge diagnostics into source     */
/*parameters: xx / yy                                               */
/*            xx = any character: display parameter panel           */
/*            yy = rexx trace option for debugging                  */
/*initialize, get parameter and trace option*/
  address "ISPEXEC" "CONTROL ERRORS RETURN"
  ok = 0                               /*maximum acceptable rc*/
  didsysin = ""; didprint = ""         /*init data id variables*/
  call   on error   name errors        /*activate condition traps*/
  signal on failure name failures
  signal on halt    name failures
  signal on syntax  name failures
  signal on novalue name failures
  address "ISREDIT"
  "MACRO (PARMS)"                      /*get parameters*/
  parse upper var parms panelsw "/" tropt .
  trace value tropt                    /*activate tracing*/
/*if requested, display assembler parameter panel*/
  if panelsw ¬= ""
   then do                             /*asm parameters via panel*/
    address "ISPEXEC"
    ok = 8
    "DISPLAY PANEL(EMASMC)"            /*display panel*/
    do while rc < 8 & eapsysl ¬= "" & sysdsn(eapsysl) ¬= "OK"
      zedsmsg = ""
      zedlmsg = "MACRO LIBRARY" eapsysl":" sysdsn(eapsysl)
      "DISPLAY PANEL(EMASMC) MSG(ISRZ001)"
      end /*do while*/                 /*loop until typed syslib ok*/
    if rc > 0 then exit                /*terminate if end key*/
    address "ISREDIT"
    end /*if panelsw then*/
   else do                             /*no panel: set defaults*/
    eapsysl = ""                       /*no extra syslibs*/
    eapdisp = ""                       /*don't browse sysprint*/
    eapsysp = ""                       /*no sysparms*/
    emasmcr = "NORENT"                 /*not reentrant*/
    emasmcx = "NOXREF"                 /*no xref*/
    end /*if panelsw*/
  call busy "initializing for assembly"
/*retrieve some values from the editor and correct the number mode*/
  ok = 0
  "(THISMEM)  = MEMBER"                /*membername*/
  "(THISDSN)  = DATASET"               /*datasetname*/
  "(EAUSERST) = USER_STATE"            /*user state*/
  "(CURLINE) = LINENUM .ZFIRST"        /*line number first line*/
  "(LASTLINE) = LINENUM .ZLAST"        /*line number last line*/
  "(EANUMM01 EANUMM02) = NUMBER"       /*number mode*/
  if eanumm01 = "off" then "NUMBER = ON STD"
  "RENUM"                              /*if not numbered set numbers*/
  "NUMBER = OFF"                       /*and make number data*/
  "RESET"                              /*remove old messages*/
/*allocate files for assembler*/
  address "TSO"
  "ALLOC F(SYSUT1) NEW DELETE UNIT(SYSDA) REUSE CYLINDERS SPACE(1 1)"
  "ALLOC F(SYSPUNCH) DUMMY REUSE"
  "ALLOC F(SYSIN) NEW UNIT(SYSDA)" ,
        "SPACE(10 10) RECFM(F B) BLK(6240) LRECL(80) REUSE DSORG(PS)"
  syslibconc = "'SYS1.MACLIB','SYS1.AMODGEN','"thisdsn"'"
  if eapsysl¬='' then syslibconc = eapsysl","syslibconc
  "ALLOC DD(SYSLIB) DA("syslibconc") SHR REUSE"
  "ALLOC F(SYSPRINT) UNIT(SYSDA)" ,
         "NEW SPACE(1 1) RECFM(F B A) BLK(3591) REUSE CYLINDERS"
/*copy source from editor to sysin*/
  address "ISPEXEC"
  "LMINIT DATAID(DIDSYSIN) DDNAME(SYSIN) ENQ(EXCLU)"
  "LMOPEN DATAID("didsysin") OPTION(OUTPUT)"
  do while curline <= lastline
    address "ISREDIT" "(DATA) = LINE" curline
    "LMPUT DATAID("didsysin") MODE(INVAR) DATALOC(DATA) DATALEN(80)"
    curline = curline+1
    end /*while curline <= lastline*/
  "LMCLOSE DATAID("didsysin")"
  "LMFREE  DATAID("didsysin")"
  didsysin = ""
/*assemble the program*/
  call busy "assembling" thismem
  asmparm = emasmcr","emasmcx",NODECK,SYSPARM("eapsysp")"
  ok = 20
  address "TSO" ,
     "CALL 'SYS1.LINKLIB(IEV90)' '"asmparm"'"
  asmrc = rc
  ok = 0
  if eapdisp = "YES" | asmrc > 12 then do
    "LMINIT DATAID(DIDPRINT) DDNAME(SYSPRINT)"
    "BROWSE DATAID("didprint")"        /*show assembler output*/
    "LMFREE DATAID("didprint")"
    didprint = ""
    end /*if browse sysprint*/
  if asmrc=0 then do                   /*ready if assembly ok*/
    zedlmsg = "assembly OK"
    "SETMSG MSG(ISRZ000)"
    call cleanup
    end /*if asmrc=0*/
/*insert diagnostics in the source*/
  call busy "inserting assembler messages in source"
  "LMINIT DATAID(DIDPRINT) DDNAME(SYSPRINT)"
  "LMOPEN DATAID("didprint") OPTION(INPUT)"
  inptel = 0                           /*initialize for lmget loop*/
  snum = ''
  ok = 8
  do forever                           /*loop thru sysprint records*/
    "LMGET DATAID("didprint")" ,
          "MODE(INVAR) DATALOC(REC) DATALEN(RECL) MAXLEN(140)"
    if rc > 0 then leave               /*eof?*/
    num  = substr(rec,114,8)           /*extract editor line number*/
    if substr(rec,41,1)¬= "+" & datatype(num,"NUM")
     then snum = num                   /*save last valid line number*/
    if substr(rec,5,3) = "IEV" then do /*if error or warning*/
      address "ISREDIT"
      "FIND '"snum"' 73 80 FIRST"      /*find saved line in source*/
      if rc = 0                        /*get relative line number*/
      then "(INPTEL UNUSED) = CURSOR"  /*or keep using previous*/
      ok = 0
      rec = translate(substr(rec,5,72),'"',"'")    /*remove quotes*/
      if inptel >= lastline then do    /*insert msg after this line*/
        inptel = lastline              /*of before last line*/
        "LINE_AFTER" inptel "= MSGLINE '"rec"'"
        end /*if inptel>las then*/
       else "LINE_BEFORE" inptel+1 "= MSGLINE '"rec"'"
      address "ISPEXEC"
      ok = 8
      end /*if IEV*/
    end /*forever*/
  ok = 0
  "LMCLOSE DATAID("didprint")"
  "LMFREE  DATAID("didprint")"
  didprint = ""
  zedlmsg = "Assembly rc="asmrc
  "SETMSG MSG(ISRZ001)"
/*clean up and return*/
cleanup:
    ok = 99
    address "ISREDIT"
    "NUMBER = ON" eanumm02             /*restore user's numbermode*/
    if eanumm01 = "OFF" then "UNNUM"
    "USER_STATE = (EAUSERST)"          /*restore user's state*/
    address "ISPEXEC"
    if didsysin ¬= "" then do          /*close sysin if still open*/
      "LMCLOSE DATAID("didsysin")"
      "LMFREE  DATAID("didsysin")"
      end /*if didsysin*/
    IF didprint ¬= "" then do          /*close sysprint if open*/
      "LMCLOSE DATAID("didprint")"
      "LMFREE  DATAID("didprint")"
      end /*if didprint*/
    address "TSO"
    x = msg("OFF")                     /*free all allocations*/
    "FREE F(SYSIN SYSPRINT SYSLIB SYSUT1 SYSPUNCH)"
    exit
/*routine to display a busy message*/
busy:
  parse arg zedlmsg
  address "ISPEXEC"
  "CONTROL DISPLAY LOCK"
  "ISPEXEC DISPLAY MSG(ISRZ000)"
  return
/*condition trap routines*/
errors:                                /*trap for returncodes > 0*/
  if rc<=ok then return                /*rc acceptable?*/
  say "returncode:" rc
  say "Linenr    :" sigl               /*show what went wrong*/
  say "Line      :" strip(sourceline(sigl))
  if symbol('ZERRLM')='VAR' & left(address(),2)="IS"
    then say "ISPF error:" zerrlm
  call cleanup                         /*clean up and terminate*/
failures:                              /*trap for all other conds*/
  say "Condition :" condition('C') condition('D')
  say "Linenr    :" sigl               /*show what went wrong*/
  say "Line      :" strip(sourceline(sigl))
  signal cleanup                       /*clean up and terminate*/

EMASMC PANEL

)ATTR
)BODY
+---------------- Edit macro%EMASMC+parameter entry panel ----------------------
%COMMAND ===>_ZCMD                                                             +
%
+
+ Assembler parameters:
+    Re-entrancy check  %===>_EAPRENT+ (Yes/No)
+    Cross-reference    %===>_EAPXREF+ (No/Full/Short)
+    Sysparm            %===>_EAPSYSP
                                                                              +
+ Extra syslibs:
+    Macro library      %===>_EAPSYSL
+
+ Listing:
+    Display            %===>_EAPDISP+(Yes/No)
)INIT
  if(&eaprent=&z)
     &eaprent=NO
  if(&eapxref=&z)
     &eapxref=NO
  if(&eapdisp=&z)
     &eapdisp=NO
)PROC
  &eaprent = trans(trunc(&eaprent,1) N,NO ' ',NO Y,YES *,*)
  &eapxref = trans(trunc(&eapxref,1) N,NO ' ',NO S,SHORT F,FULL *,*)
  &eapdisp = trans(trunc(&eapdisp,1) N,NO ' ',NO Y,YES *,*)
  ver(&eaprent,list,YES,NO)
  ver(&eapxref,list,NO,SHORT,FULL)
  ver(&eapsysl,dsname)
  ver(&eapdisp,list,YES,NO)
  vput (eaprent eapxref eapsysp eapsysl eapdisp) profile
  &emasmcr = trans(&eaprent NO,NORENT YES,RENT)
  &emasmcx = trans(&eapxref NO,NOXREF *,'XREF(&eapcref)')
)end


J van de Pieterman
Systems Programmer
Hoogovens (The Netherlands)                                               c Xeph

