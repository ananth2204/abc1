Handling dynamic exits under MVS/ESA Version 5


Source Code

The CVH macro
         MACRO
.* THIS MACRO CONVERTS THE VALUE FOUND IN A REG TO EBCDIC.
.* &REG - REG TO CONVERT TO EBCDIC
.* &TO  - THE ADDRESS OF AREA OF STORAGE TO CONTAIN RESULT
.* &LEN - LENGTH OF OUTPUT AREA, MAX = 8 (DEFAULT)
.*  EXAMPLE :  L    15,=X'002DF2C1'
.*             CVH  15,OUTPUT,8      OUTPUT = X'F0F0F2C4C6F2C3F1'
.*                                          =    0 0 2 D F 2 C 1
.* Original author Paul Lemmons (MVS Update September 1991)
.* This macro has been altered slightly to work in re-entrant
.* programs
&LABEL   CVH   &REG,&TO,&LEN
&LABEL   LR    1,&REG
         AIF   ('&LEN' EQ '').NOLEN
&L       SETC  '&LEN'
         AGO   .TOP
.NOLEN   ANOP
&L       SETC  '8'
.TOP     ANOP
         AIF   ('&L' EQ '8').START
&X       SETA  (8-&L)*4
         SLL    1,&X
.START   ANOP
         LA     15,&L
         LA     14,&TO
         B      L&SYSNDX
A&SYSNDX DC     H'10'
B&SYSNDX DC     H'183'
C&SYSNDX DC     H'240'
L&SYSNDX XR     0,0
         SLDL   0,4
         CH     0,A&SYSNDX
         BL     F&SYSNDX
         AH     0,B&SYSNDX
         B      S&SYSNDX
F&SYSNDX AH     0,C&SYSNDX
S&SYSNDX STC    0,0(14)
         LA     14,1(14)
         BCT    15,L&SYSNDX
         MEND


DYNXINFO

DYNXINFO TITLE 'REXX FUNCTION TO HANDLE DYNAMIC SMF EXITS '
*-------------------------------------------------------------------*
* THIS PROGRAM PROVIDES A REXX INTERFACE TO GATHER INFORMATION      *
* ABOUT THE DYNAMIC MVS EXITS UNDER MVS/ESA 5.1+.                   *
* IT PROCESSES THE OUTPUT FROM A LIST REQUEST TO THE SERVICE        *
* CSVDYNEX AND CREATES REXX VARIABLES TO DESCRIBE EACH EXIT ON      *
* THE SYSTEM.                                                       *
* THIS PROGRAM IS USED AS A STUB TO INVOKE THE DYNXAUTH PROGRAM     *
* (VIA IKJEFTSR) WHICH PERFORMS THE AUTHORIZED SERVICE OF ISSUING   *
* THE CSVDYNEX MACRO.                                               *
* SYNTAX:                                                           *
* X = DYNXINFO(OPT,EXIT,MOD,DSN,STATE,MASK,LIMIT,COUNT,POSN)        *
*     WHERE :                                                       *
*     OPT   -  OPTION (LIST,MODIFY,DELETE,ADD)                      *
*     EXIT  -  EXIT NAME                                            *
*     MOD   -  MODULE NAME                                          *
*     DSN   -  DATASET CONTAINING MODULE                            *
*     STATE -  REQUIRED STATE (ACTIVE,INACTIVE,NOCHANGE)            *
*     MASK  -  EXIT FILTERING JOBNAME MASK                          *
*     LIMIT -  ABEND LIMIT (NNN OR MAX)                             *
*     COUNT -  ABEND COUNT METHOD (TOTAL,CONSEQ)                    *
*     POSN  -  POSITION IN CALLING SEQUENCE (FIRST,LAST,SYSTEM)     *
* REXX VARIABLES CREATED                                            *
* EXIT_NAME.I             DYNAMIC EXIT NAME AS DEFINED TO MVS       *
* EXIT_AMODE.I            AMODE OF EXIT (31,24 OR DEFINED)          *
* EXIT_RENT.I             REENTRANT STATUS (REQUIRED/OPTIONAL)      *
* EXIT_ABENDS.I           NUMBER OF ABENDS BEFORE DEACTIVATING      *
* EXIT_ABEND_COUNT.I      ABEND COUNT METHOD (TOTAL/CONSECUTIVE)    *
* EXIT_MOD_LIMIT.I        LIMIT ON NUMBER OF MODULES (ONE/MULTIPLE) *
* EXIT_MODINFO.I          HAS EXIT GOT ANY MODULE INFORMATION       *
* EXIT_MODULE.I.J         MODULE NAME(S)                            *
* EXIT_EPADDR.I.J         MODULE ENTRY POINT                        *
* EXIT_LOADPT.I.J         MODULE LOAD POINT                         *
* EXIT_MODLEN.I.J         MODULE LENGTH                             *
* EXIT_STATUS.I.J         MODULE STATUS (ACTIVE/INACTIVE)           *
* EXIT_FILTER.I.J         MODULE FILTER (NONE/JOBNAME/STOKEN)       *
* EXIT_MASK.I.J           MODULE FILTER MASK                        *
* ATTRIBUTES AMODE (31) RMODE (ANY) RENT REUS REFR                  *
* REGS USED                                                         *
* R1  - PARAMETER PASSED :                                          *
* R2  - COPY OF PARMS PASSED / 2ND BRANCH AND LINK                  *
* R3  - REXX EVALUATION BLOCK                                       *
* R4  - EXAAE (LIST ENTRY)                                          *
* R5  - REXX PARAMETER TABLE                                        *
* R6  - WORK / BRANCH AND COUNT                                     *
* R7  - WORK REGISTER                                               *
* R8  - EXTRA PARMS                                                 *
* R9  - ANSWER AREA ADDRESS / EXAAM1                                *
* R10 - BRANCH AND LINK                                             *
* R11 - WORK AREA                                                   *
* R12 - BASE                                                        *
*-------------------------------------------------------------------*
DYNXINFO CSECT                      *
DYNXINFO AMODE 31                   *
DYNXINFO RMODE ANY                  *
         BAKR  R14,R0               * LINKAGE STACK
         LR    R12,R15              * COPY ENTRY ADDRESS TO BASE
         USING DYNXINFO,R12         * ADDRESS IT
         MODID ,                    * EYECATCHER
         LR    R2,R1                * COPY PARMS PASSED
GETSTOR  EQU   *
         STORAGE OBTAIN,            * GET THE WORKAREA STORAGE         X
               LENGTH=WORKLEN,      * THIS MUCH                        X
               ADDR=(R11),          * PUT ADDRESS IN R11               X
               SP=0,KEY=8,          * SUBPOOL 0 STORAGE KEY 8          X
               LOC=BELOW,           * ANY LOCATION                     X
               COND=NO,             * UNCONDITIONAL                    X
               RELATED='WORKAREA STORAGE'
         USING WORKAREA,R11         * ADDRESS WORKAREA
         LOAD  EP=IKJCT441          * GET ADDRESS OF IKJCT441
         ST    R0,TSOVARX           * STORE FOR LATER USE
         LA    R8,XTRADATA          * POINT TO EXTRA PARMS
         USING XTRAPARM,R8          * ADDRESS IT
         MVI   XTRADATA,C' '        * MOVE IN BLANK
         MVC   XTRADATA+1(XTRALEN-1),XTRADATA
         MVC   XTRARC,=F'0'         * ZERO RC
         MVC   XTRARSN,=F'0'        * ZERO REASON CODE
         MVC   OPTION(8),BLANKS     * BLANK OPTIONS
GETPARMS EQU   *
         USING EFPL,R2              * ADDR REXX FUNC PARMS
         L     R3,EFPLEVAL          * ADDR OF ADDR
         L     R3,0(R3)             * REXX EVAL BLOCK ADDR
         USING EVALBLOCK,R3         * ADDRESS IT
         L     R5,EFPLARG           * REXX ARG LIST
         USING ARGTABLE_ENTRY,R5    * ADDRESS ARG TABLE
         CLC   0(4,R5),HEXFF        * NO ARGS ?
         BNE   GETARGS              * GO AND GET THE ARGS
         B     RETURN12             * INDICATE ERROR
* PROCESS THE ARGS PASSED IN THE REXX COMMAND                       *
GETARGS  EQU   *
         L     R6,ARGTABLE_ARGSTRING_PTR    GET ADDRESS OF ARG
         L     R7,ARGTABLE_ARGSTRING_LENGTH GET LENGTH OF ARG
GETOPTN  EQU   *
* GET THE OPTION                                                    *
         LTR   R7,R7                * TEST FOR ZERO LENGTH
         BZ    RETURN12             * IF SO - ERROR
         C     R7,=F'8'             * IS IT GREATER THAN 8 ?
         BH    RETURN12             * YES - ERROR
         BCTR  R7,R0                * MINUS ONE FOR MOVE
         EX    R7,OPTMOVE           * MOVE IN THE OPTION
         OC    OPTION(8),BLANKS     * FORCE CAPS
         CLC   OPTION(4),=CL4'LIST' * IS IT LIST ?
         BE    GETANSRA             * YES - BYPASS REST OF ARGS
GETEXNME EQU   *
* GET THE EXIT NAME                                                 *
         LA    R5,8(R5)             * POINT TO NEXT ARG
         L     R6,ARGTABLE_ARGSTRING_PTR
         C     R6,HEXFF             * END OF ARGS ?
         BE    RETURN12             * YES - ERROR
         L     R7,ARGTABLE_ARGSTRING_LENGTH
         LTR   R7,R7                * TEST FOR ZERO LENGTH
         BZ    RETURN12             * IF SO - ERROR
         C     R7,=F'16'            * IS IT GREATER THAN 16 ?
         BH    RETURN12             * YES - ERROR
         BCTR  R7,R0                * MINUS ONE FOR MOVE
         EX    R7,NMEMOVE           * MOVE IN THE OPTION
         OC    XTRANAME(16),BLANKS  * FORCE CAPS
GETMOD   EQU   *
* GET THE MODULE NAME                                               *
         LA    R5,8(R5)             * POINT TO NEXT ARG
         L     R6,ARGTABLE_ARGSTRING_PTR
         C     R6,HEXFF             * END OF ARGS ?
         BE    RETURN12             * YES - ERROR
         L     R7,ARGTABLE_ARGSTRING_LENGTH
         LTR   R7,R7                * TEST FOR ZERO LENGTH
         BZ    RETURN12             * IF SO - ERROR
         C     R7,=F'8'             * IS IT GREATER THAN 16 ?
         BH    RETURN12             * YES - ERROR
         BCTR  R7,R0                * MINUS ONE FOR MOVE
         EX    R7,MODMOVE           * MOVE IN THE OPTION
         OC    XTRAMOD(8),BLANKS    * FORCE CAPS
GETDSN   EQU   *
* GET THE DATASET NAME                                              *
         LA    R5,8(R5)             * POINT TO NEXT ARG
         L     R6,ARGTABLE_ARGSTRING_PTR
         C     R6,HEXFF             * END OF ARGS ?
         BE    GETANSRA             * YES - GET ANSWER AREA
         L     R7,ARGTABLE_ARGSTRING_LENGTH
         LTR   R7,R7                * TEST FOR ZERO LENGTH
         BZ    GETSTATE             * IF SO - TEST FOR STATE
         C     R7,=F'44'            * IS IT GREATER THAN 44 ?
         BH    RETURN12             * YES - ERROR
         BCTR  R7,R0                * MINUS ONE FOR MOVE
         EX    R7,DSNMOVE           * MOVE IN THE OPTION
         OC    XTRADSN(44),BLANKS   * FORCE CAPS
GETSTATE EQU   *
* GET THE REQUIRED STATUS                                           *
         LA    R5,8(R5)             * POINT TO NEXT ARG
         L     R6,ARGTABLE_ARGSTRING_PTR
         C     R6,HEXFF             * END OF ARGS ?
         BE    GETANSRA             * YES - GET ANSWER AREA
         L     R7,ARGTABLE_ARGSTRING_LENGTH
         LTR   R7,R7                * TEST FOR ZERO LENGTH
         BZ    GETMASK              * IF SO - TEST FOR MASK
         C     R7,=F'8'             * IS IT GREATER THAN 8 ?
         BH    RETURN12             * YES - ERROR
         BCTR  R7,R0                * MINUS ONE FOR MOVE
         EX    R7,STAMOVE           * MOVE IN THE OPTION
         OC    XTRASTAT(8),BLANKS   * FORCE CAPS
         CLC   XTRASTAT(6),=C'ACTIVE' IS IT ACTIVE STATUS ?
         BE    GETMASK              * YES - OK
         CLC   XTRASTAT(8),=C'INACTIVE'
         BE    GETMASK              * YES - OK
         CLC   XTRASTAT(8),=C'NOCHANGE'
         BE    GETMASK              * YES - OK
         B     RETURN12             * OTHERWISE ERROR
GETMASK  EQU   *
* GET THE REQUIRED JOBNAME MASK                                     *
         LA    R5,8(R5)             * POINT TO NEXT ARG
         L     R6,ARGTABLE_ARGSTRING_PTR
         C     R6,HEXFF             * END OF ARGS ?
         BE    GETANSRA             * YES - GET ANSWER AREA
         L     R7,ARGTABLE_ARGSTRING_LENGTH
         LTR   R7,R7                * TEST FOR ZERO LENGTH
         BZ    GETABNO              * IF SO - CONTINUE
         C     R7,=F'8'             * IS IT GREATER THAN 8 ?
         BH    RETURN12             * YES - ERROR
         BCTR  R7,R0                * MINUS ONE FOR MOVE
         EX    R7,JOBMOVE           * MOVE IN THE OPTION
         OC    XTRAMASK(8),BLANKS   * FORCE CAPS
GETABNO  EQU   *
* GET THE REQUIRED ABEND NUMBER LIMIT                               *
         LA    R5,8(R5)             * POINT TO NEXT ARG
         L     R6,ARGTABLE_ARGSTRING_PTR
         C     R6,HEXFF             * END OF ARGS ?
         BE    GETANSRA             * YES - GET ANSWER AREA
         L     R7,ARGTABLE_ARGSTRING_LENGTH
         LTR   R7,R7                * TEST FOR ZERO LENGTH
         BZ    GETMETH              * GET THE POSITION
         C     R7,=F'8'             * IS IT > 8 ?
         BH    RETURN12             * YES - ERROR
         C     R7,=F'3'             * IS IT AT LEAST THREE ?
         BL    TRANSNUM             * NO - MUST BE NUMBER
         CLC   0(3,R6),=C'MAX'      * IS IT MAXIMUM ?
         BNE   TRANSNUM             * NO - MUST BE NUMBER
         MVC   XTRAABNO,=X'7FFFFFFF' * SET TO MAXIMUM NUMBER
         B     GETMETH              *
TRANSNUM EQU   *
         MVC   DWORK(8),ZEROC       * INIT TO ZEROS
         LA    R1,DWORK+7           * POINT TO END OF DWORK
         BCTR  R7,0                 * SUBTRACT ONE
         SR    R1,R7                * OFFSET = 8 - LENGTH
         EX    R7,NUMMOVE           * MOVE IN THE NUMBER
         PACK  PWORK,DWORK          * CONVERT TO DEC
         CVB   R1,PWORK             * NOW TO BINARY
         ST    R1,XTRAABNO          * STORE IT
GETMETH  EQU   *
* GET THE REQUIRED ABEND COUNT METHOD                               *
         LA    R5,8(R5)             * POINT TO NEXT ARG
         L     R6,ARGTABLE_ARGSTRING_PTR
         C     R6,HEXFF             * END OF ARGS ?
         BE    GETANSRA             * YES - GET ANSWER AREA
         L     R7,ARGTABLE_ARGSTRING_LENGTH
         LTR   R7,R7                * TEST FOR ZERO LENGTH
         BZ    GETPOSN              * GET POSITION
         C     R7,=F'6'             * IS IT > 6 ?
         BH    RETURN12             * YES - ERROR
         BCTR  R7,R0                * MINUS ONE FOR MOVE
         EX    R7,METHMOVE          * MOVE IN THE OPTION
         OC    XTRAMETH(8),BLANKS   * FORCE CAPS
         CLC   XTRAMETH(5),=C'TOTAL'  IS IT TOTAL ?
         BE    GETPOSN              * YES - OK
         CLC   XTRAMETH(6),=C'CONSEC'
         BE    GETPOSN              * YES - OK
         B     RETURN12             * OTHERWISE ERROR
GETPOSN  EQU   *
* GET THE REQUIRED MODULE POSITION                                  *
         LA    R5,8(R5)             * POINT TO NEXT ARG
         L     R6,ARGTABLE_ARGSTRING_PTR
         C     R6,HEXFF             * END OF ARGS ?
         BE    GETANSRA             * GET ANSWER AREA
         L     R7,ARGTABLE_ARGSTRING_LENGTH
         LTR   R7,R7                * TEST FOR ZERO LENGTH
         BZ    GETANSRA             * YES - GET ANSWER AREA
         C     R7,=F'6'             * IS IT > 6 ?
         BH    RETURN12             * YES - ERROR
         BCTR  R7,R0                * MINUS ONE FOR MOVE
         EX    R7,POSNMOVE          * MOVE IN THE OPTION
         OC    XTRAPOSN(8),BLANKS   * FORCE CAPS
         CLC   XTRAPOSN(4),=C'LAST'   IS IT LAST ?
         BE    GETANSRA             * YES - OK
         CLC   XTRAPOSN(5),=C'FIRST'  IS IT FIRST ?
         BE    GETANSRA             * YES - OK
         CLC   XTRAMETH(6),=C'SYSTEM' IS IT SYSTEM ?
         BE    GETANSRA             * YES - OK
         B     RETURN12             * OTHERWISE ERROR
GETANSRA EQU   *
         L     R7,=F'4096'          * SET UP LENGTH
         STORAGE OBTAIN,            * GET THE WORKAREA STORAGE         X
               LENGTH=(R7),         * THIS MUCH (4K)                   X
               ADDR=(R9),           * PUT ADDRESS IN R9                X
               SP=0,KEY=8,          * SUBPOOL 0 STORAGE KEY 8          X
               LOC=BELOW,           * BELOW THE LINE                   X
               COND=NO,             * UNCONDITIONAL                    X
               RELATED='ANSWER AREA STORAGE'
         ST    R9,ANSWER            * STORE ADDRESS FOR LATER
CHOOSE   EQU   *
         CLC   OPTION(8),=CL8'LIST' * IS IT LIST ?
         BE    LIST                 * YES - DO IT
         CLC   OPTION(8),=CL8'DELETE' IS IT DELETE ?
         BE    NOTLIST              * YES - DO IT
         CLC   OPTION(8),=CL8'MODIFY' IS IT MODIFY ?
         BE    NOTLIST              * YES - DO IT
         CLC   OPTION(8),=CL8'ADD'    IS IT ADD ?
         BE    NOTLIST              * YES - DO IT
         B     RETURN04             * INDICATE ERROR
NOTLIST  EQU   *
         MVC   PARMOPT(8),OPTION    * MOVE IN THE OPTION
         MVC   PARMANSR(4),ANSWER   * MOVE IN THE ANSWER AREA ADDRESS
         MVC   PARMANSL(4),=F'4096' * MOVE IN THE ADDRESS LENGTH
         ST    R8,PARMPARM          * STORE ADDRESS OF EXTRA PARMS
         MVC   PARMLEN(2),=H'20'    * SET LENGTH OF PGM PARMS
         BAL   R10,CALLTSR          * PREPARE AND CALL IKJEFTSR
         CLC   TSRRC,=F'0'          * CHECK THE RC
         BNE   RETURN04             * COULDN'T PERFORM FUNCTION
         B     RETURN00
LIST     EQU   *
         MVC   PARMOPT(8),OPTION    * MOVE IN THE OPTION
         MVC   PARMANSR(4),ANSWER   * MOVE IN THE ANSWER AREA ADDRESS
         MVC   PARMANSL(4),=F'4096' * MOVE IN THE ADDRESS LENGTH
         MVC   PARMPARM(4),=F'0'    * MOVE IN THE ADDRESS OF XTRA PARM
         MVC   PARMLEN(2),=H'20'    * SET LENGTH OF PGM PARMS
         BAL   R10,CALLTSR          * PREPARE AND CALL IKJEFTSR
         CLC   TSRRC,=F'0'          * CHECK THE RC
         BNE   RETURN04             * COULDN'T PERFORM FUNCTION
GETINFO  EQU   *
         MVC   IIII(3),=PL3'0'      * ZERO I COUNT
         USING EXAAHDR,R9           * ADDRESS THE ANSWER HEADER
         L     R6,EXAAH#REC         * GET NUMBER OF ENTRIES
         MVC   NAME(11),=C'EXIT_NAME.0'
         MVC   NAMELEN,=F'11'       * SET LENGTH
         LR    R15,R6               * COPY NUMBER OF ENTRIES
         CVD   R15,PWORK            * CONVERT TO DEC
         MVC   VALUE(8),MASK1       * STICK THE MASK IN
         ED    VALUE(8),PWORK+4     * UNPACK WITH MASK
         MVC   VALUELEN,=F'8'       * SET UP LENGTH
         BAL   R10,LINK441          * UPDATE TABLE
         L     R4,EXAAHFIRST@       * GET ADDRESS OF FIRST ENTRY
         USING EXAAE,R4             * ADDRESS IT
         DROP  R9                   * DROP R9 ADDRESSABILITY
DOEXAAE  EQU   *
         MVC   JJJJ(3),=PL3'0'      * ZERO J COUNT
         AP    IIII,=PL3'1'         * ADD ONE TO COUNT
         MVC   NAME(10),=C'EXIT_NAME.'
         MVC   NAMELEN,=F'10'       * SET LENGTH
         LA    R1,IIII              * POINT TO COUNT
         BAL   R10,STEMNAME         * CONSTRUCT STEM
         MVC   VALUE(16),EXAAENAME  * MOVE IN EXIT NAME
         MVC   VALUELEN,=F'16'      * SET LENGTH
         BAL   R10,LINK441          * CREATE VARIABLE
         MVC   NAME(12),=C'EXIT_ABENDS.'
         MVC   NAMELEN,=F'12'       * SET LENGTH
         LA    R1,IIII              * POINT TO COUNT
         BAL   R10,STEMNAME         * CONSTRUCT STEM
         MVC   VALUE(7),=C'MAXIMUM' * ASSUME MAXIMUM
         MVC   VALUELEN,=F'7'       * SET LENGTH
         CLC   EXAAEABENDNUM,=X'7FFFFFFF'
         BE    ABNDFIN              * NUMBER IS MAXIMUM
         L     R15,EXAAEABENDNUM    * LOAD UP NUMBER OF ABENDS
         CVD   R15,PWORK            * CONVERT TO DEC
         MVC   VALUE(8),MASK1       * STICK THE MASK IN
         ED    VALUE(8),PWORK+4     * UNPACK WITH MASK
         MVC   VALUELEN,=F'8'       * SET UP LENGTH
ABNDFIN  EQU   *
         BAL   R10,LINK441          * UPDATE TABLE
         MVC   NAME(11),=C'EXIT_AMODE.'
         MVC   NAMELEN,=F'11'       * SET LENGTH
         LA    R1,IIII              * POINT TO COUNT
         BAL   R10,STEMNAME         * CONSTRUCT STEM
         MVC   VALUE(7),=C'DEFINED' * ASSUME AMODE DEFINED
         MVC   VALUELEN,=F'7'       * SET LENGTH
AMOD31   EQU   *
         CLI   EXAAEAMODE,EXAAEAMODE_31
         BNE   AMOD24               * CHECK FOR AMODE 24
         MVC   VALUE(2),=C'31'      * SET VALUE
         MVC   VALUELEN,=F'2'       * SET LENGTH
         B     AMODFIN              * CREATE VAR
AMOD24   EQU   *
         CLI   EXAAEAMODE,EXAAEAMODE_24
         BNE   AMODFIN              * MUST BE 'DEFINED'
         MVC   VALUE(2),=C'24'      * SET VALUE
         MVC   VALUELEN,=F'2'       * SET LENGTH
AMODFIN  EQU   *
         BAL   R10,LINK441          * CREATE VARIABLE
         MVC   NAME(10),=C'EXIT_RENT.'
         MVC   NAMELEN,=F'10'       * SET LENGTH
         LA    R1,IIII              * POINT TO COUNT
         BAL   R10,STEMNAME         * CONSTRUCT STEM
         MVC   VALUE(8),=C'OPTIONAL'  ASSUME OPTIONAL
         MVC   VALUELEN,=F'8'       * SET LENGTH
         TM    EXAAEFLAGS,EXAAEREENTRANTREQUIRED
         BNO   RENTFIN              * RENT NOT REQUIRED
         MVC   VALUE(8),=C'REQUIRED'  SET REQUIRED
         MVC   VALUELEN,=F'8'       * SET LENGTH
RENTFIN  EQU   *
         BAL   R10,LINK441          * CREATE VARIABLE
         MVC   NAME(17),=C'EXIT_ABEND_COUNT.'
         MVC   NAMELEN,=F'17'       * SET LENGTH
         LA    R1,IIII              * POINT TO COUNT
         BAL   R10,STEMNAME         * CONSTRUCT STEM
         MVC   VALUE(5),=C'TOTAL'   * ASSUME TOTAL
         MVC   VALUELEN,=F'5'       * SET LENGTH
         TM    EXAAEFLAGS,EXAAEABENDCONSEC
         BNO   DEFNFIN              * ABENDS NOT CONSECUTIVE
         MVC   VALUE(11),=C'CONSECUTIVE'
         MVC   VALUELEN,=F'11'      * SET LENGTH
DEFNFIN  EQU   *
         BAL   R10,LINK441          * CREATE VARIABLE
         MVC   NAME(15),=C'EXIT_MOD_LIMIT.'
         MVC   NAMELEN,=F'15'       * SET LENGTH
         LA    R1,IIII              * POINT TO COUNT
         BAL   R10,STEMNAME         * CONSTRUCT STEM
         MVC   VALUE(8),=C'MULTIPLE'  ASSUME MULTIPLE
         MVC   VALUELEN,=F'8'       * SET LENGTH
         TM    EXAAEFLAGS,EXAAEONEMODULEONLY
         BNO   MODLFIN              * ALLOW MULTIPLE MODULES
         MVC   VALUE(10),=C'ONE MODULE'
         MVC   VALUELEN,=F'10'      * SET LENGTH
MODLFIN  EQU   *
         BAL   R10,LINK441          * CREATE VARIABLE
MODINFO  EQU   *
         MVC   NAME(13),=C'EXIT_MODINFO.'
         MVC   NAMELEN,=F'13'       * SET LENGTH
         LA    R1,IIII              * POINT TO COUNT
         BAL   R10,STEMNAME         * CONSTRUCT STEM
         MVC   VALUE(2),=C'NO'      * ASSUME NO
         MVC   VALUELEN,=F'2'       * SET LENGTH
         XR    R7,R7                * ZERO REG 7
         LH    R7,EXAAE#ENT         * LOAD UP NO OF EXAAM1S
         LTR   R7,R7                * ARE THERE ANY EXAAM1S ?
         BZ    NOEXAAM1             * NO - DON'T PROCESS
         MVC   VALUE(3),=C'YES'     * SET VALUE
         MVC   VALUELEN,=F'3'       * SET LENGTH
         BAL   R10,LINK441          * CREATE VARIABLE
         BAL   R2,DOEXAAM1          * PROCESS THE EXAAM1
         B     NXTEXAAE             * GET NEXT EXAAE
NOEXAAM1 EQU   *
         BAL   R10,LINK441          * CREATE VARIABLE
NXTEXAAE EQU   *
         L     R4,EXAAENEXT@        * POINT TO NEXT
         BCT   R6,DOEXAAE           * LOOP FOR ALL
         B     RETURN00
* RETURN ROUTINES                                                   *
RETURN00 EQU   *
         L     R15,XTRARSN          * GET REASON CODE
         CVH   R15,RESULT           * MAKE IT PRINTABLE
         MVC   EVALBLOCK_EVLEN(4),=F'4' * SET LENGTH OF RESULT
         MVC   EVALBLOCK_EVDATA(4),RESULT+4
         BAL   R10,FREEANSR         * FREE THE ANSWER AREA
         BAL   R10,FREEWORK         * FREE THE WORKAREA
         LA    R15,0                * SET RC TO ZERO
         PR                         * RETURN
RETURN04 EQU   *
         BAL   R10,FREEANSR         * FREE THE ANSWER AREA
         BAL   R10,FREEWORK         * FREE THE WORKAREA
         MVC   EVALBLOCK_EVLEN(4),=F'2' * SET LENGTH OF RESULT
         MVC   EVALBLOCK_EVDATA(2),=C'-1'  MOVE IN RESULT DATA
         LA    R15,0                * SET RC TO ZERO
         PR                         * RETURN
RETURN12 EQU   *
         BAL   R10,FREEWORK         * FREE THE WORKAREA
         MVC   EVALBLOCK_EVLEN(4),=F'2'    SET LENGTH OF RESULT
         MVC   EVALBLOCK_EVDATA(2),=C'-3'  MOVE IN RESULT DATA
         LA    R15,12               * SET RC TO ZERO
         PR                         * RETURN
* GENERAL ROUTINES                                                  *
DOEXAAM1 EQU *
* ROUTINE TO PROCESS AN EXIT MODULE ENTRY                           *
         L     R9,EXAAEFIRSTENT@    * GET ADDRESS OF FIRST EXAAM1
         USING EXAAM1,R9            * ADDRESS IT
         LR    R15,R7               * COPY NUM OF ENTRIES
         MVC   NAME(12),=C'EXIT_MODULE.'
         MVC   NAMELEN,=F'12'       * SET LENGTH
         LA    R1,IIII              * POINT TO COUNT
         BAL   R10,STEMNAME         * CONSTRUCT STEM (VAR.I)
         LA    R1,NAME              * POINT TO NAME
         A     R1,NAMELEN           * ADD NEW LENGTH OF NAME
         MVC   0(2,R1),=C'.0'       * MAKE ZERO ENTRY (VAR.I.0)
         L     R1,NAMELEN           * LOAD UP LENGTH AGAIN
         LA    R1,2(R1)             * INCR
         ST    R1,NAMELEN           * STORE AS NEW LENGTH
         LR    R15,R7               * COPY NUM OF ENTRIES
         CVD   R15,PWORK            * CONVERT TO DEC
         MVC   VALUE(8),MASK1       * STICK THE MASK IN
         ED    VALUE(8),PWORK+4     * UNPACK WITH MASK
         MVC   VALUELEN,=F'8'       * SET UP LENGTH
         BAL   R10,LINK441          * UPDATE TABLE
EXAAM1LP EQU   *
         AP    JJJJ,=PL3'1'         * ADD ONE TO J COUNT
         MVC   NAME(12),=C'EXIT_MODULE.'
         MVC   NAMELEN,=F'12'       * SET LENGTH
         LA    R1,IIII              * POINT TO COUNT
         BAL   R10,STEMNAME         * CONSTRUCT STEM (VAR.I)
         LA    R1,NAME              * POINT TO NAME
         A     R1,NAMELEN           * ADD NEW LENGTH OF NAME
         MVI   0(R1),C'.'           * ADD ANOTHER DOT
         L     R1,NAMELEN           * LOAD UP NAMELEN
         LA    R1,1(R1)             * ADD ONE TO IT
         ST    R1,NAMELEN           * STORE AS LENGTH
         LA    R1,JJJJ              * POINT TO J INDEX
         BAL   R10,STEMNAME         * CONSTRUCT STEM NAME (VAR.I.J)
         MVC   VALUE(8),EXAAM1NAME  * MOVE IN EXIT MODULE NAME
         MVC   VALUELEN,=F'8'       * SET LENGTH
         BAL   R10,LINK441          * CREATE VARIABLE
         MVC   NAME(12),=C'EXIT_EPADDR.'
         MVC   NAMELEN,=F'12'       * SET LENGTH
         LA    R1,IIII              * POINT TO COUNT
         BAL   R10,STEMNAME         * CONSTRUCT STEM (VAR.I)
         LA    R1,NAME              * POINT TO NAME
         A     R1,NAMELEN           * ADD NEW LENGTH OF NAME
         MVI   0(R1),C'.'           * ADD ANOTHER DOT
         L     R1,NAMELEN           * LOAD UP NAMELEN
         LA    R1,1(R1)             * ADD ONE TO IT
         ST    R1,NAMELEN           * STORE AS LENGTH
         LA    R1,JJJJ              * POINT TO J INDEX
         BAL   R10,STEMNAME         * CONSTRUCT STEM NAME (VAR.I.J)
         L     R15,EXAAM1EPADDR     * LOAD UP EP ADDRESS
         CVH   R15,VALUE            * MAKE PRINTABLE
         MVC   VALUELEN,=F'8'       * SET LENGTH
         BAL   R10,LINK441          * CREATE VARIABLE
         MVC   NAME(12),=C'EXIT_LOADPT.'
         MVC   NAMELEN,=F'12'       * SET LENGTH
         LA    R1,IIII              * POINT TO COUNT
         BAL   R10,STEMNAME         * CONSTRUCT STEM (VAR.I)
         LA    R1,NAME              * POINT TO NAME
         A     R1,NAMELEN           * ADD NEW LENGTH OF NAME
         MVI   0(R1),C'.'           * ADD ANOTHER DOT
         L     R1,NAMELEN           * LOAD UP NAMELEN
         LA    R1,1(R1)             * ADD ONE TO IT
         ST    R1,NAMELEN           * STORE AS LENGTH
         LA    R1,JJJJ              * POINT TO J INDEX
         BAL   R10,STEMNAME         * CONSTRUCT STEM NAME (VAR.I.J)
         L     R15,EXAAM1LOADPT     * LOAD UP MODULE LOAD POINT
         CVH   R15,VALUE            * MAKE PRINTABLE
         MVC   VALUELEN,=F'8'       * SET LENGTH
         BAL   R10,LINK441          * CREATE VARIABLE
         MVC   NAME(12),=C'EXIT_MODLEN.'
         MVC   NAMELEN,=F'12'       * SET LENGTH
         LA    R1,IIII              * POINT TO COUNT
         BAL   R10,STEMNAME         * CONSTRUCT STEM (VAR.I)
         LA    R1,NAME              * POINT TO NAME
         A     R1,NAMELEN           * ADD NEW LENGTH OF NAME
         MVI   0(R1),C'.'           * ADD ANOTHER DOT
         L     R1,NAMELEN           * LOAD UP NAMELEN
         LA    R1,1(R1)             * ADD ONE TO IT
         ST    R1,NAMELEN           * STORE AS LENGTH
         LA    R1,JJJJ              * POINT TO J INDEX
         BAL   R10,STEMNAME         * CONSTRUCT STEM NAME (VAR.I.J)
         L     R15,EXAAM1MODLEN     * LOAD UP MODULE LENGTH
         CVH   R15,VALUE            * MAKE PRINTABLE
         MVC   VALUELEN,=F'8'       * SET LENGTH
         BAL   R10,LINK441          * CREATE VARIABLE
         MVC   NAME(12),=C'EXIT_FILTER.'
         MVC   NAMELEN,=F'12'       * SET LENGTH
         LA    R1,IIII              * POINT TO COUNT
         BAL   R10,STEMNAME         * CONSTRUCT STEM (VAR.I)
         LA    R1,NAME              * POINT TO NAME
         A     R1,NAMELEN           * ADD NEW LENGTH OF NAME
         MVI   0(R1),C'.'           * ADD ANOTHER DOT
         L     R1,NAMELEN           * LOAD UP NAMELEN
         LA    R1,1(R1)             * ADD ONE TO IT
         ST    R1,NAMELEN           * STORE AS LENGTH
         LA    R1,JJJJ              * POINT TO J INDEX
         BAL   R10,STEMNAME         * CONSTRUCT STEM NAME (VAR.I.J)
         MVC   VALUE(4),=C'NONE'    * ASSUME NONE
         MVC   VALUELEN,=F'4'       * SET LENGTH
TSTJOBF  EQU   *
         TM    EXAAM1FLAGS,EXAAM1JOBNAMEPROVIDED
         BNO   TSTSTOK              * CHECK STOKEN
         MVC   VALUE(7),=C'JOBNAME' * SET FILTERING TO JOBNAME
         MVC   VALUELEN,=F'7'       * SET LENGTH
         B     FILTEND              * CREATE VARIABLE
TSTSTOK  EQU   *
         TM    EXAAM1FLAGS,EXAAM1STOKENPROVIDED
         BNO   FILTEND              * FILTERING OFF
         MVC   VALUE(6),=C'STOKEN'  * SET FILTERING TO STOKEN
         MVC   VALUELEN,=F'6'       * SET LENGTH
FILTEND  EQU   *
         BAL   R10,LINK441          * CREATE VARIABLE
         MVC   NAME(12),=C'EXIT_STATUS.'
         MVC   NAMELEN,=F'12'       * SET LENGTH
         LA    R1,IIII              * POINT TO COUNT
         BAL   R10,STEMNAME         * CONSTRUCT STEM (VAR.I)
         LA    R1,NAME              * POINT TO NAME
         A     R1,NAMELEN           * ADD NEW LENGTH OF NAME
         MVI   0(R1),C'.'           * ADD ANOTHER DOT
         L     R1,NAMELEN           * LOAD UP NAMELEN
         LA    R1,1(R1)             * ADD ONE TO IT
         ST    R1,NAMELEN           * STORE AS LENGTH
         LA    R1,JJJJ              * POINT TO J INDEX
         BAL   R10,STEMNAME         * CONSTRUCT STEM NAME (VAR.I.J)
         MVC   VALUE(8),=C'INACTIVE'  ASSUME INACTIVE
         MVC   VALUELEN,=F'8'       * SET LENGTH
TSTACTV  EQU   *
         TM    EXAAM1FLAGS,EXAAM1ACTIVE
         BNO   ACTVEND              * SET TO INACTIVE
         MVC   VALUE(6),=C'ACTIVE'  * SET TO ACTIVE
         MVC   VALUELEN,=F'6'       * SET LENGTH
ACTVEND  EQU   *
         BAL   R10,LINK441          * CREATE VARIABLE
         MVC   NAME(10),=C'EXIT_MASK.'
         MVC   NAMELEN,=F'10'       * SET LENGTH
         LA    R1,IIII              * POINT TO COUNT
         BAL   R10,STEMNAME         * CONSTRUCT STEM (VAR.I)
         LA    R1,NAME              * POINT TO NAME
         A     R1,NAMELEN           * ADD NEW LENGTH OF NAME
         MVI   0(R1),C'.'           * ADD ANOTHER DOT
         L     R1,NAMELEN           * LOAD UP NAMELEN
         LA    R1,1(R1)             * ADD ONE TO IT
         ST    R1,NAMELEN           * STORE AS LENGTH
         LA    R1,JJJJ              * POINT TO J INDEX
         BAL   R10,STEMNAME         * CONSTRUCT STEM NAME (VAR.I.J)
         MVC   VALUE(8),EXAAM1STOKEN  MOVE IN EXIT MASK
         MVC   VALUELEN,=F'8'       * SET LENGTH
         BAL   R10,LINK441          * CREATE VARIABLE
NEXTMOD  EQU   *
         L     R9,EXAAM1NEXT@       * POINT TO NEXT
         LTR   R9,R9                * IS IT ZERO ?
         BZ    ENEXAAM1             * YES - ALL DONE
         B     EXAAM1LP             * LOOP FOR ALL
ENEXAAM1 EQU *
         BR    R2                   * RETURN TO LOOP
CALLTSR  EQU   *
* PREPARE THE PARAMETER LISTS FOR IKJEFTSR                          *
         LA    R1,TSRFLAG           * POINT TO FLAGS
         ST    R1,@TSRFLAG          * STORE IN PLIST
         LA    R1,TSRPGM            * POINT TO FUNCTION NAME
         ST    R1,@TSRPGM           * STORE IN PLIST
         LA    R1,TSRPGML           * POINT TO FUNCTION NAME LENGTH
         ST    R1,@TSRPGML          * STORE IN PLIST
         LA    R1,TSRRC             * POINT TO FUNCTION RC FIELD
         ST    R1,@TSRRC            * STORE IN PLIST
         LA    R1,TSRRSN            * POINT TO FUNCTION RSN FIELD
         ST    R1,@TSRRSN           * STORE IN PLIST
         LA    R1,TSRABEND          * POINT TO FUNCTION ABEND FIELD
         ST    R1,@TSRABND          * STORE IN PLIST
         LA    R1,PGMPARM           * GET ADDRESS OF PGM PARMS
         O     R1,HIGHBIT           * TURN ON HIGH BIT
         ST    R1,@PGMPARM          * STORE ADDRESS
         LA    R1,@PGMPARM          * GET ADDRESS OF PGM PARM LIST
         O     R1,HIGHBIT           * TURN ON HIGH BIT
         ST    R1,@TSRPARM          * STORE ADDRESS IN PLIST
* NOW CALL IKJEFTSR TO INVOKE GETXSTOR                              *
         L     R15,CVTPTR           * LOAD POINTER TO CVT
         USING CVTMAP,R15           * ADDRESSABILITY
         L     R15,CVTTVT           * LOAD PTR TO TSO VECTOR TABLE
         USING TSVT,R15             * ADDRESSABILITY
         L     R15,TSVTASF          * TSO SERVICE FACILITY ADDRESS
         LA    R1,TSRPLIST          * POINT TO TSR PLIST
         BALR  R14,R15              * USE TSR TO CALL DYNXAUTH
         BR    R10                  *
LINK441  EQU   *
* ROUTINE TO CALL IKJCT441                                          *
         LA    R1,NAME              * POINT TO NAME
         ST    R1,@NAME             * STORE IT IN PARM VARIABLE
         LA    R1,VALUE             * POINT TO VALUE
         ST    R1,@VALUE            * STORE IT IN PARM VARIABLE
         LA    R1,@NAME             * POINT TO NAME POINTER
         ST    R1,@@NAME            * STORE IT IN PARM LIST
         LA    R1,ECODE             * POINT TO ENTRY CODE
         ST    R1,@ECODE            * STORE IT IN PARM LIST
         LA    R1,NAMELEN           * POINT TO NAME LENGTH
         ST    R1,@NAMELEN          * STORE IT IN PARM LIST
         LA    R1,@VALUE            * POINT TO VALUE POINTER
         ST    R1,@@VALUE           * STORE IT IN PARM LIST
         LA    R1,VALUELEN          * POINT TO VALUE LENGTH
         ST    R1,@VALUELN          * STORE IT IN PARM LIST
         LA    R1,TOKEN             * POINT TO TOKEN
         ST    R1,@TOKEN            * STORE IT IN PARM LIST
         OI    @TOKEN,X'80'         * INDICATE LAST PARM
         LA    R1,JCTPARML          * POINT TO PARM LIST
         L     R15,TSOVARX          * LOAD UP ADDRESS OF IKJCT441
         BALR  R14,R15              * LINK TO ROUTINE
         BR    R10                  * RETURN TO CALLER
STEMNAME EQU   *
* ROUTINE TO CONSTRUCT A REXX STEM NAME FROM THE CORE VARIABLE      *
* NAME PLUS A PACKED INDEX COUNT.                                   *
* R1 POINTS TO PACKED INDEX COUNT (IIII OR JJJJ)                    *
         LA    R15,NAME             * POINT TO THE NAME
         A     R15,NAMELEN          * ADD ON LENGTH OF NAME
         MVC   PCNT(3),0(R1)        * COPY INDEX COUNT
         UNPK  UCNT,PCNT            * UNPACK THE COUNT
         OI    UCNT+3,X'F0'         * GET RID OF SIGN
THOUSAND EQU   *
         CLI   UCNT,C'0'            * IS THERE A ZERO ?
         BE    HUNDRED              * YES - UCNT < 1000
         MVC   0(4,R15),UCNT        * ADD ON TO NAME
         L     R15,NAMELEN          * LOAD UP CURRENT LENGTH
         A     R15,=F'4'            * ADD ON FOUR
         ST    R15,NAMELEN          * STORE AS NEW LENGTH
         B     STEMDONE
HUNDRED  EQU   *
         CLI   UCNT+1,C'0'          * IS THERE A ZERO ?
         BE    TENS                 * YES - UCNT < 100
         MVC   0(3,R15),UCNT+1      * ADD ON TO NAME
         L     R15,NAMELEN          * LOAD UP CURRENT LENGTH
         A     R15,=F'3'            * ADD ON THREE
         ST    R15,NAMELEN          * STORE AS NEW LENGTH
         B     STEMDONE
TENS     EQU   *
         CLI   UCNT+2,C'0'          * IS THERE A ZERO ?
         BE    UNITS                * YES - UCNT < 10
         MVC   0(2,R15),UCNT+2      * ADD ON TO NAME
         L     R15,NAMELEN          * LOAD UP CURRENT LENGTH
         A     R15,=F'2'            * ADD ON TWO
         ST    R15,NAMELEN          * STORE AS NEW LENGTH
         B     STEMDONE
UNITS    EQU   *
         MVC   0(1,R15),UCNT+3      * ADD ON TO NAME
         L     R15,NAMELEN          * LOAD UP CURRENT LENGTH
         LA    R15,1(R15)           * ADD ON ONE
         ST    R15,NAMELEN          * STORE AS NEW LENGTH
STEMDONE EQU   *
         BR    R10
FREEANSR EQU   *
* ROUTINE TO FREE THE ANSWER AREA STORAGE                           *
         L     R7,=F'4096'          * LOAD UP LENGTH
         L     R9,ANSWER            * LOAD UP ADDRESS
         STORAGE RELEASE,           * RELEASE TABLE STORAGE            X
               LENGTH=(R7),         * THIS MUCH                        X
               ADDR=(R9),           * ADDRESS IN R9                    X
               SP=0,KEY=8,          * SUBPOOL 0 STORAGE KEY 8          X
               COND=NO,             * UNCONDITIONAL                    X
               RELATED='ANSWER AREA STORAGE'
         BR    R10
FREEWORK EQU   *
* ROUTINE TO FREE THE WORK AREA STORAGE                             *
         STORAGE RELEASE,           * RELEASE TABLE STORAGE            X
               LENGTH=WORKLEN,      * THIS MUCH                        X
               ADDR=(R11),          * ADDRESS IN R11                   X
               SP=0,KEY=8,          * SUBPOOL 0 STORAGE KEY 8          X
               COND=NO,             * UNCONDITIONAL                    X
               RELATED='WORKAREA STORAGE'
         BR    R10                  * RETURN
* CONSTANTS VARIABLES AND DSECTS                                    *
NUMMOVE  MVC   0(0,R1),0(R6)        * EXECUTED INSTRUCTIONS
OPTMOVE  MVC   OPTION(0),0(R6)      * EXECUTED INSTRUCTIONS
NMEMOVE  MVC   XTRANAME(0),0(R6)    * EXECUTED INSTRUCTIONS
MODMOVE  MVC   XTRAMOD(0),0(R6)     * EXECUTED INSTRUCTIONS
DSNMOVE  MVC   XTRADSN(0),0(R6)     * EXECUTED INSTRUCTIONS
STAMOVE  MVC   XTRASTAT(0),0(R6)    * EXECUTED INSTRUCTIONS
JOBMOVE  MVC   XTRAMASK(0),0(R6)    * EXECUTED INSTRUCTIONS
METHMOVE MVC   XTRAMETH(0),0(R6)    * EXECUTED INSTRUCTIONS
POSNMOVE MVC   XTRAPOSN(0),0(R6)    * EXECUTED INSTRUCTIONS
REXXANSR MVC   EVALBLOCK_EVDATA(0),0(R9)
         DS    0F
HEXFF    DC    X'FFFFFFFFFFFFFFFF'  * HEX 'FF' CONSTANT
ZEROC    DC    C'00000000'          * CHAR XEROS
         DS    0F
ECODE    DC    A(TSVEUPDT)          * UPDATE ENTRY CODE
HIGHBIT  DC    X'80000000'          * FIELD TO FLIP HIGH BIT
ZERO     DC    C'00000000'          * HEX '00' CONSTANT
MASK1    DC    XL8'F021202020202020'
BLANKS   DC    64C' '               * BLANKS
TSRFLAG  DC    X'00'                * RESERVED
         DC    X'00'                * INVOKE AUTHORIZED
         DC    X'01'                * TAKE A DUMP
         DC    X'02'                * FUNCTION IS PROGRAM
TSRPGM   DC    CL8'DYNXAUTH'        * PROGRAM NAME
TSRPGML  DC    F'8'                 * LENGTH OF PROGRAM NAME
XTRAPARM DSECT
XTRANAME DS    CL16                 * EXIT NAME
XTRAMOD  DS    CL8                  * MODULE NAME
XTRADSN  DS    CL44                 * DATASET NAME
XTRASTAT DS    CL8                  * STATUS
XTRAMASK DS    CL8                  * FILTER MASK
XTRAABNO DS    F                    * NUMBER OF ABENDS
XTRAMETH DS    CL8                  * ABEND COUNT METHOD
XTRAPOSN DS    CL8                  * MODULE POSITION
XTRARC   DS    F                    * RETURN CODE
XTRARSN  DS    F                    * RSNCODE
XTRALEN  EQU   *-XTRAPARM           * LENGTH OF XTRA PARMS
WORKAREA DSECT                      * PROGRAM PARMS
RESULT   DS    CL8                  * RESULT FIELD
UCNT     DS    F                    * UNPACK FIELD
PCNT     DS    PL3                  * PACKED COUNT (WORK)
IIII     DS    PL3                  * PACKED COUNT (I)
JJJJ     DS    PL3                  * PACKED COUNT (J)
         DS    0F                   *
UWORK    DS    CL4                  * UNPACK WORK
PWORK    DS    D                    * PACKED WORK
OPTION   DS    CL8                  * REQUESTED OPTION
ANSWER   DS    F                    * ADDRESS OF ANSWER AREA
         DS    0D
DWORK    DS    D                    * WORK AREA FOR PACKED STUFF
NAME     DS    CL32                 * REXX VARIABLE NAME
NAMELEN  DS    F                    * LENGTH OF VARIABLE NAME
VALUE    DS    CL64                 * VARIABLE VALUE
VALUELEN DS    F                    * LENGTH OF VALUE
TSOVARX  DS    F                    * ADDRESS OF IKJCT441
@NAME    DS    A                    * ADDRESS OF VARIABLE NAME
@VALUE   DS    A                    * ADDRESS OF VARIABLE VALUE
TOKEN    DS    F                    * TOKEN
JCTPARML DS    0F                   * PARMLIST FOR IKJCT441
@ECODE   DS    F                    * ---> ECODE
@@NAME   DS    F                    * ---> @NAME
@NAMELEN DS    F                    * ---> NAMELEN
@@VALUE  DS    F                    * ---> @VALUE
@VALUELN DS    F                    * ---> VALUELEN
@TOKEN   DS    F                    * ---> TOKEN
TSRPLIST DS    0F                   * PARMLIST FOR IKJEFTSR
@TSRFLAG DS    F                    * ---> IKJEFTSR FLAGS
@TSRPGM  DS    F                    * ---> PROGRAM NAME
@TSRPGML DS    F                    * ---> PROGRAM NAME LENGTH
@TSRRC   DS    F                    * ---> RETURN CODE
@TSRRSN  DS    F                    * ---> REASON CODE
@TSRABND DS    F                    * ---> ABEND CODE
@TSRPARM DS    F                    * ---> PROGRAM PARM LIST ADDRESS
TSRRC    DS    F                    * PROGRAM RETURN CODE
TSRRSN   DS    F                    * PROGRAM REASON CODE
TSRABEND DS    F                    * PROGRAM ABEND CODE
@PGMPARM DS    F                    * ---> PROGRAM PARM LIST
PGMPARM  DS    0F
PARMLEN  DS    H                    * LENGTH OF PARMS
PARMDATA DS    0CL20                * ACTUAL PARMS
PARMOPT  DS    CL8                  * OPTION
PARMANSL DS    F                    * LENGTH OF ANSWER AREA
PARMANSR DS    F                    * ANSWER AREA ADDRESS
PARMPARM DS    F                    * OPTION PARAMETERS
         DS    0D                   *
XTRADATA DS    CL(XTRALEN)          * DATA AREA FOR XTRAPARM
WORKLEN  EQU   *-WORKAREA
         IRXEFPL
         IKJTSVT
         IRXEVALB
         IRXARGTB DECLARE=YES
         CVT DSECT=YES,LIST=YES
         CSVEXAA DSECT=YES,                                            X
               EXAAHDR=YES,                                            X
               EXAAE=YES,                                              X
               EXAAM1=YES
         END


DYNXAUTH

DYNXAUTH TITLE 'ROUTINE TO ISSUE THE CSVDYNEX MACRO'
*-------------------------------------------------------------------*
* THIS PROGRAM IS INVOKED BY THE DYNXINFO COMMAND VIA IKJEFTSR.     *
* ATTRIBUTES AMODE (31) RMODE (ANY) RENT REUS REFR AC(1)            *
* (MUST BE SPECIFIED IN AUTHTSR IN IKJTSO00).                       *
* REGS USED                                                         *
* R1  - ADDRESS OF PARMS PASSED                                     *
* R2  - PARAMETER LIST FROM                                         *
* R3  - EXTRA PARM LIST FROM DYNXINFO                               *
* R7  - LENGTH OF ANSWER AREA                                       *
* R9  - ADDRESS OF ANSWER AREA                                      *
* R10 - BRANCH AND LINK                                             *
* R11 - WORKAREA                                                    *
* R12 - BASE                                                        *
* PARMS PASSED VIA R1 :                                             *
* R1 ---> +---------------+                                         *
*         + PTR PGM PARMS + ---> +----+----------------+            *
*         +---------------+      + LL + DATA           +            *
*                                +----+----------------+            *
*                                      +0   OPTION  (CL8)           *
*                                      +8   LENGTH OF ANSWER (F)    *
*                                      +C   ADDR ANSWER AREA (F)    *
*                                      +10  ADDR OPTION PARMS       *
*-------------------------------------------------------------------*
DYNXAUTH CSECT                      *
DYNXAUTH AMODE 31                   *
DYNXAUTH RMODE ANY                  *
         BAKR  R14,R0               * LINKAGE STACK
         LR    R12,R15              * COPY ENTRY ADDRESS TO BASE
         USING DYNXAUTH,R12         * ADDRESS IT
         MODID ,                    * EYECATCHER
         LR    R2,R1                * COPY PARMS PASSED
         L     R2,0(R2)             * GET PARMS
         USING PARMLIST,R2          * ADDRESS THEM
         L     R3,PARMPARM          * LOAD UP ADDRESS OF EXTRA PARMS
         USING XTRAPARM,R3          * ADDRESS IT
FASTCHK  EQU   *
         XR    R7,R7                * ZERO R7
         LH    R7,PARMLEN           * LOAD LENGTH
         CH    R7,=H'16'            * CHECK PARM LENGTH
         BL    RETURN08             * ERROR IN PARMS
         L     R7,PARMANSL          * LOAD ANSWER LENGTH
         C     R7,=F'4096'          * IS IT 4K ?
         BL    RETURN08             * NO - TOO SHORT
GETWORKA EQU   *
* OBTAIN AND SETUP THE WORKAREA STORAGE                             *
         STORAGE OBTAIN,            * GET THE WORKAREA STORAGE         X
               LENGTH=WORKLEN,      * THIS MUCH                        X
               ADDR=(R11),          * PUT ADDRESS IN R11               X
               SP=0,KEY=8,          * SUBPOOL 0 STORAGE KEY 8          X
               LOC=ANY,             * BELOW THE LINE                   X
               COND=NO,             * UNCONDITIONAL                    X
               RELATED='WORK AREA'  * LABEL IT
         USING WORKAREA,R11         * ADDRESS WORKAREA
* MOVE IN MODEL MACROS                                              *
         MVC   MODE0(MODESETL),MODEMOD0
         MVC   MODE8(MODESETL),MODEMOD8
CHKOPTS  EQU   *
         CLC   PARMOPT,=CL8'LIST'   * IS IT LIST REQUEST ?
         BE    LSTEXITS             * YES - BRANCH
         CLC   PARMOPT,=CL8'DELETE' * IS IT DELETE REQUEST ?
         BE    DELEXITS             * YES - BRANCH
         CLC   PARMOPT,=CL8'MODIFY' * IS IT MODIFY REQUEST ?
         BE    MODEXITS             * YES - BRANCH
         CLC   PARMOPT,=CL8'ADD'    * IS IT ADD REQUEST ?
         BE    ADDEXITS             * YES - BRANCH
         B     RETURN04             * INVALID PARM
LSTEXITS EQU   *
         MODESET MF=(E,MODE0)       * CHANGE TO SUPERVISOR
         L     R9,PARMANSR          * LOAD UP ADDR ANSWER AREA
         CSVDYNEX REQUEST=LIST,     * REQUEST LIST OF CURRENT EXITS    X
               EXITNAME=ALL_EXITS,  * GET ALL OF THEM                  X
               EXAAVER=1,           * EXPANDED INFO                    X
               ANSAREA=(R9),        * ANSWER AREA ADDRESS              X
               ANSLEN=PARMANSL,     * ANSWER AREA LENGTH               X
               MF=(E,EXITLST)       *
         MODESET MF=(E,MODE8)       * CHANGE TO PROBLEM
         B     RETURN00
DELEXITS EQU   *
         MODESET MF=(E,MODE0)       * CHANGE TO SUPERVISOR
         CSVDYNEX REQUEST=DELETE,   * REQUEST DELETE OF EXIT           X
               EXITNAME=XTRANAME,   * USE SPECIFIED EXIT               X
               MODNAME=XTRAMOD,     * DELETE THIS MODULE               X
               RETCODE=XTRARC,      * STORE RETURN CODE HERE           X
               RSNCODE=XTRARSN,     * STORE REASON CODE HERE           X
               FORCE=NO,            * DON'T USE FASTPATH FORCE         X
               MF=(E,EXITLST)       *
         MODESET MF=(E,MODE8)       * CHANGE TO PROBLEM
         B     RETURN00
MODEXITS EQU   *
         MODESET MF=(E,MODE0)       * CHANGE TO SUPERVISOR
         CSVDYNEX REQUEST=MODIFY,   * REQUEST MODIFY OF EXIT           X
               EXITNAME=XTRANAME,   * USE SPECIFIED EXIT               X
               MODNAME=XTRAMOD,     * AND THIS MODULE                  X
               STATE=UNCHANGED,     * DO NOT CHANGE STATUS             X
               JOBNAME=ANY,         * USE THIS FILTER MASK             X
               RETCODE=XTRARC,      * STORE RETURN CODE HERE           X
               RSNCODE=XTRARSN,     * STORE REASON CODE HERE           X
               MF=(M,EXITLST,COMPLETE)
         CLC   XTRASTAT(6),=C'ACTIVE' IS IT ACTIVE ?
         BNE   MODINACT             * YES - CHECK BYPASS PARM OVERRIDE
         CSVDYNEX REQUEST=MODIFY,   * USING MODIFY REQUEST             X
               STATE=ACTIVE,        * OVERRIDE STATE                   X
               MF=(M,EXITLST,NOCHECK) BYPASS COMPLETENESS CHECK
         B     MODMASK
MODINACT EQU   *
         CSVDYNEX REQUEST=MODIFY,   * USING MODIFY REQUEST             X
               STATE=INACTIVE,      * OVERRIDE STATE                   X
               MF=(M,EXITLST,NOCHECK) BYPASS COMPLETENESS CHECK
MODMASK  EQU   *
         CLI   XTRAMASK,C' '        * IS FILTER BLANK ?
         BE    MODSVC               * NO - NEED TO CHANGE FILTER
         CSVDYNEX REQUEST=MODIFY,   * USING MODIFY REQUEST             X
               JOBNAME=XTRAMASK,    * OVERRIDE FILTER MASK             X
               MF=(M,EXITLST,NOCHECK) BYPASS COMPLETENESS CHECK
MODSVC   EQU   *
         CSVDYNEX REQUEST=MODIFY,   * EXECUTE THE SVC                  X
               MF=(E,EXITLST,NOCHECK) USING THIS PARM LIST
         MODESET MF=(E,MODE8)       * CHANGE TO PROBLEM
         B     RETURN00
ADDEXITS EQU   *
         MODESET MF=(E,MODE0)       * CHANGE TO SUPERVISOR
         CSVDYNEX REQUEST=ADD,      * REQUEST ADD OF MODULE TO EXIT    X
               EXITNAME=XTRANAME,   * USE SPECIFIED EXIT               X
               MODNAME=XTRAMOD,     * AND THIS MODULE                  X
               STATE=ACTIVE,        * CHANGE STATUS TO ACTIVE          X
               POS=LAST,            * LAST IN SEQUENCE                 X
               DSNAME=SYSTEM,       * ASSUME IN LPA                    X
               JOBNAME=ANY,         * USE THIS FILTER MASK             X
               ADDABENDNUM=UNCHANGED, DO NOT CHANGE THE ABEND NUMBER   X
               ABENDCONSEC=NO,        USE TOTAL COUNT METHOD           X
               RETCODE=XTRARC,      * STORE RETURN CODE HERE           X
               RSNCODE=XTRARSN,     * STORE REASON CODE HERE           X
               MF=(M,EXITLST,COMPLETE)
         CLC   XTRASTAT(6),=C'ACTIVE' IS IT ACTIVE ?
         BE    ADDPOS               * YES - BYPASS PARM OVERRIDE
         CSVDYNEX REQUEST=ADD,      * USING ADD REQUEST                X
               STATE=INACTIVE,      * OVERRIDE STATE                   X
               MF=(M,EXITLST,NOCHECK) BYPASS COMPLETENESS CHECK
ADDPOS   EQU   *
         CLC   XTRAPOSN(4),=C'LAST' * IS IT LAST ?
         BE    ADDDSN               * YES - BYPASS PARM OVERRIDE
         CLC   XTRAPOSN(5),=C'FIRST'  IS IT FIRST ?
         BE    ADDPOSF              * YES - SET PARM TO FIRST
         CSVDYNEX REQUEST=ADD,      * USING ADD REQUEST                X
               POS=SYSTEM,          * OVERRIDE POSITION                X
               MF=(M,EXITLST,NOCHECK) BYPASS COMPLETENESS CHECK
         B     ADDDSN               * GO LOOK AT DSN
ADDPOSF  EQU   *
         CSVDYNEX REQUEST=ADD,      * USING ADD REQUEST                X
               POS=FIRST,           * OVERRIDE POSITION                X
               MF=(M,EXITLST,NOCHECK) BYPASS COMPLETENESS CHECK
ADDDSN   EQU   *
         CLI   XTRADSN,C' '         * IS THERE A DATASET ?
         BE    ADDMASK              * NO - BYPASS PARM OVERRIDE
         CSVDYNEX REQUEST=ADD,      * USING ADD REQUEST                X
               DSNAME=XTRADSN,      * OVERRIDE DATASET NAME            X
               MF=(M,EXITLST,NOCHECK) BYPASS COMPLETENESS CHECK
ADDMASK  EQU   *
         CLI   XTRAMASK,C'*'        * IS THERE A FILTER MASK
         BE    ADDABNO              * NO - BYPASS PARM OVERRIDE
         CSVDYNEX REQUEST=ADD,      * USING ADD REQUEST                X
               JOBNAME=XTRAMASK,    * OVERRIDE FILTER MASK             X
               MF=(M,EXITLST,NOCHECK) BYPASS COMPLETENESS CHECK
ADDABNO  EQU   *
         CLI   XTRAABNO,C' '        * IS THERE AN ABEND NUMBER ?
         BE    ADDMETH              * NO - BYPASS PARM OVERRIDE
         CSVDYNEX REQUEST=ADD,      * USING ADD REQUEST                X
               ADDABENDNUM=XTRAABNO,  OVERRIDE ABEND NUMBER            X
               MF=(M,EXITLST,NOCHECK) BYPASS COMPLETENESS CHECK
ADDMETH  EQU   *
         CLC   XTRAMETH(5),=C'TOTAL'  IS THERE AN ABEND METHOD ?
         BE    ADDSVC               * NO - GO DO SVC
         CSVDYNEX REQUEST=ADD,      * USING ADD REQUEST                X
               ABENDCONSEC=YES,       OVERRIDE ABEND METHOD            X
               MF=(M,EXITLST,NOCHECK) BYPASS COMPLETENESS CHECK
ADDSVC   EQU   *
         CSVDYNEX REQUEST=ADD,      * EXECUTE THE SVC                  X
               MF=(E,EXITLST,NOCHECK) USING THIS PARM LIST
         MODESET MF=(E,MODE8)       * CHANGE TO PROBLEM
         B     RETURN00
RETURN00 EQU   *
         BAL   R10,FREEWORK         * FREE THE WORKAREA
         LA    R15,0                * SET RC TO ZERO
         PR                         * RETURN
RETURN04 EQU   *
         BAL   R10,FREEWORK         * FREE THE WORKAREA
         LA    R15,4                * SET RC TO ZERO
         PR                         * RETURN
RETURN08 EQU   *
         LA    R15,8                * SET RC TO ZERO
         PR                         * RETURN
* GENERAL ROUTINES                                                  *
FREEWORK EQU   *
* THIS ROUTINE FREES THE WORKAREA STORAGE                           *
         STORAGE RELEASE,           * RELEASE WORKAREA STORAGE         X
               LENGTH=WORKLEN,      * THIS MUCH                        X
               ADDR=(R11),          * PUT ADDRESS IN R11               X
               SP=0,KEY=8,          * SUBPOOL 0 STORAGE KEY 8          X
               COND=NO              * UNCONDITIONAL
         BR    R10                  * RETURN
* CONSTANTS VARIABLES AND DSECTS                                    *
MODEMOD0 MODESET MODE=SUP,                                             X
               KEY=ZERO,MF=L
MODEMOD8 MODESET MODE=PROB,                                            X
               KEY=NZERO,MF=L
MODESETL EQU     *-MODEMOD8
PARMLIST DSECT                       * PASSED PARM LIST FROM XSTORAGE
PARMLEN  DS    H                     * LENGTH OF PARMS
PARMOPT  DS    CL8                   * OPTION
PARMANSL DS    F                     * LENGTH OF ANSWER AREA
PARMANSR DS    F                     * ANSWER AREA
PARMPARM DS    F                     * OPTION PARAMETERS
XTRAPARM DSECT
XTRANAME DS    CL16                  * EXIT NAME
XTRAMOD  DS    CL8                   * MODULE NAME
XTRADSN  DS    CL44                  * DATASET NAME
XTRASTAT DS    CL8                   * STATUS
XTRAMASK DS    CL8                   * FILTER MASK
XTRAABNO DS    F                     * NUMBER OF ABENDS
XTRAMETH DS    CL8                   * ABEND COUNT METHOD
XTRAPOSN DS    CL8                   * MODULE POSITION
XTRARC   DS    F                     * RETURN CODE
XTRARSN  DS    F                     * RSNCODE
WORKAREA DSECT                       * PROGRAM WORKAREA
*                                    * SPACE FOR MACRO EXPANSIONS
         CSVDYNEX PLISTVER=IMPLIED_VERSION,                            X
               MF=(L,EXITLST)
MODE0    MODESET MODE=SUP,                                             X
               KEY=ZERO,MF=L
MODE8    MODESET MODE=PROB,                                            X
               KEY=NZERO,MF=L
WORKLEN  EQU   *-WORKAREA
         CVT   DSECT=YES,LIST=NO
         CSVEXAA DSECT=YES,                                            X
               EXAAHDR=YES,                                            X
               EXAAE=YES,                                              X
               EXAAM1=YES
         END


DYNXREXX REXX EXEC

/* REXX - DYNXREXX - Dynamic Exit Facility                           */
/* This REXX EXEC provides the ISPF interface to the dynxinfo pgm.   */
/* It moves the REXX variables created by dynxinfo() and presents    */
/* an ISPF dialog that handles the various actions that can be       */
/* performed.                                                        */
address ISPEXEC "ADDPOP"                         /* init pop-ups     */
rownum = 1                                       /* init row number  */
DISPLAY_EXIT_INFO:                               /*                  */
  x = dynxinfo(LIST)                             /* get exit info    */
  if x <> 0 then call ERROR_MSG 'List' x
  tabname = 'EXITINFO'                           /* name ISPF table  */
  varlist = 'names(XTNME XTMOD XTEP XTLD XTLN XTA XTO XTM ',
    'XTSEQ XTR XTFL XTFM XTAB XTABO)'            /* declare variables*/
  call TABLE_CREATE tabname varlist              /* create it        */
  i = 1                                          /* set loop count   */
  do while i <= EXIT_NAME.0                      /* set limit        */
    XTNME = EXIT_NAME.i                          /* get exit name    */
    XTABO = EXIT_ABEND_COUNT.i                   /* get count method */
    XTAB  = EXIT_ABENDS.i                        /* get abend number */
    if XTAB <> 'MAXIMUM' then XTAB = format(XTAB,,0)
    XTR   = EXIT_RENT.i                          /* get rent status  */
    XTM   = EXIT_AMODE.i                         /* get module amode */
    XTO   = EXIT_MOD_LIMIT.i                     /* get module limit */
    if EXIT_MODINFO.i = 'YES' then do            /* more info ?      */
        j = 1                                    /* set module count */
        XTN = EXIT_MODULE.i.0                    /* get num of mods  */
        do while j <= EXIT_MODULE.i.0            /* repeat for all   */
            XTSEQ = '('j'/'format(XTN,,0)')'     /* get call order   */
            XTMOD = EXIT_MODULE.i.j              /* get module name  */
            XTEP  = EXIT_EPADDR.i.j              /* get entry point  */
            XTLD  = EXIT_LOADPT.i.j              /* get load point   */
            XTFL  = EXIT_FILTER.i.j              /* get filter option*/
            XTFM  = EXIT_MASK.i.j                /* get filter mask  */
            XTLN  = format(EXIT_MODLEN.i.j,,0)   /* get module length*/
            if XTLN = '0' then XTLN = 'n/a'      /* if zero then n/a */
            if XTLD = '0' then XTLD = 'n/a'      /* if zero then n/a */
            XTA   = EXIT_STATUS.i.j              /* get status       */
            address ISPEXEC "TBADD EXITINFO"     /* add table entry  */
            j = j + 1                            /* incr mod count   */
            end                                  /*                  */
    end                                          /*                  */
    else do                                      /* no module entry  */
        XTSEQ = ' '                              /* so blank         */
        XTMOD = ' '                              /* ..everything     */
        XTEP = ' '                               /*   ..out          */
        XTLD = ' '                               /*                  */
        XTLN = ' '                               /*                  */
        XTA  = ' '                               /*                  */
        address ISPEXEC "TBADD EXITINFO"         /* add table entry  */
    end
    i = i + 1                                    /* incr count       */
  end                                            /*                  */
  address ISPEXEC "TBTOP EXITINFO"               /* go to table top  */
DISPLAY_EXIT_PANEL:                              /* show panel...    */
  ztdmark = ' '                                  /* blank eod mark   */
  address ISPEXEC "TBTOP EXITINFO"               /* go to table top  */
  address ISPEXEC "TBSKIP EXITINFO NUMBER("rownum")"
                                                 /* and skip to row  */
  address ISPEXEC "TBDISPL EXITINFO PANEL(DYNXLIST) POSITION(ROWNUM)"
                                                 /* save select row  */
  if rc >= 8 then do                             /* PF3 ?            */
    call TABLE_ERASE tabname                     /* erase table      */
    address ISPEXEC "REMPOP"                     /* remove pop-ups   */
    exit                                         /* and exit         */
    end                                          /*                  */
  upper xsel                                     /* process selection*/
  if xsel = 'A' then do                          /* is it add ?      */
    call ADD_EXIT                                /* add mod to exit  */
    xsel = ' '                                   /* blank out        */
    end                                          /*                  */
  if xsel = 'S' then do                          /* is it display ?  */
    call DISPLAY_EXIT_DETAIL                     /* show more detail */
    xsel = ' '                                   /* blank out        */
    end                                          /*                  */
  if xsel = 'D' then do                          /* is it delete ?   */
    call DELETE_EXIT                             /* delete mod       */
    xsel = ' '                                   /* blank out        */
    end                                          /*                  */
  if xsel = 'U' then do                          /* is it update ?   */
    call MODIFY_EXIT                             /* update module    */
    xsel = ' '                                   /* blank out        */
    end                                          /*                  */
  call TABLE_ERASE tabname                       /* erase table      */
  call DISPLAY_EXIT_INFO                         /* get info again   */
exit                                             /*                  */
/*-------------------------------------------------------------------*/
/* General routines                                                  */
/*-------------------------------------------------------------------*/
DISPLAY_EXIT_DETAIL:                             /* show panel...    */
   address ISPEXEC "DISPLAY PANEL(DYNXSHOW)"     /* with detail info */
      if rc >= 8 then do                         /* PF3 ?            */
      return                                     /* then return      */
      end /**/                                   /*                  */
   call DISPLAY_EXIT_DETAIL                      /* show panel again */
   return
DELETE_EXIT:                                     /* show panel...    */
   address ISPEXEC "DISPLAY PANEL(DYNXDEL)"      /* confirmed ?      */
   if XTCONF = 'Y' then do                       /* if confirmed..   */
   /*----------------------------------------------------------------*/
   /* make the call to dynxinfo to delete the module                 */
   /*----------------------------------------------------------------*/
      x = dynxinfo(delete,XTNME,XTMOD)           /* delete the mod   */
      if x <> 0 then call ERROR_MSG 'Delete' x   /* display messages */
                else call OK_MSG 'Delete         /*                  */
      return                                     /*                  */
      end                                        /*                  */
   return                                        /*                  */
MODIFY_EXIT:                                     /* show panel...    */
   address ISPEXEC "DISPLAY PANEL(DYNXMOD)"      /* with modify info */
   if rc >= 8 then do                            /* PF3 ?            */
      return                                     /* yes - cancel     */
      end                                        /*                  */
   upper xtfl                                    /* force caps       */
   if XTFL = 'NONE' then do                      /* if no filter..   */
   /*----------------------------------------------------------------*/
   /* modify the exit without filtering                              */
   /*----------------------------------------------------------------*/
      x = dynxinfo(modify,xtnme,xtmod,,XTA)      /* update module    */
      if x <> 0 then call ERROR_MSG 'Modify' x   /* show messages    */
                else call OK_MSG 'Modify'        /*                  */
      end                                        /*                  */
   if XTFL = 'JOBNAME' then do                   /* if filter by job */
   /*----------------------------------------------------------------*/
   /* modify the exit with a specified filter                        */
   /*----------------------------------------------------------------*/
      x = dynxinfo(modify,xtnme,xtmod,,XTA,xtfm) /* update module    */
      if x <> 0 then call ERROR_MSG 'Modify' x   /* show messages    */
                else call OK_MSG 'Modify'        /*                  */
      end
   return
ADD_EXIT:                                        /* show panel...    */
   address ISPEXEC "DISPLAY PANEL(DYNXADD)"      /* with add info    */
   if rc >= 8 then do                            /* PF3 ?            */
      return                                     /* yes - cancel     */
      end                                        /*                  */
   xtdsn = strip(xtdsn,,"'")                     /* strip quotes     */
   if dataset_check(xtdsn,xtmod) = 'OK' then do  /* if module exists */
       upper xtfl XTAB XTABO                     /* force caps       */
       xtabo = substr(xtabo,1,6)                 /* 1st 6 chars      */
       if XTFL = 'NONE' then do                  /* if no filter...  */
   /*----------------------------------------------------------------*/
   /* add the exit without a filter                                  */
   /*----------------------------------------------------------------*/
          x = dynxinfo(add,xtnme,xtmod,xtdsn,xta,,xtab,xtabo)
          if x <> 0 then call ERROR_MSG 'Add' x  /* show messages    */
                else call OK_MSG 'Add'           /*                  */
          end                                    /*                  */
       else do                                   /* if jobname filter*/
   /*----------------------------------------------------------------*/
   /* add the exit with a specified filter                           */
   /*----------------------------------------------------------------*/
          x = dynxinfo(add,xtnme,xtmod,xtdsn,xta,xtfm,xtab,xtabo)
          if x <> 0 then call ERROR_MSG 'Add' x  /* show messages    */
                else call OK_MSG 'Add'           /*                  */
          end                                    /*                  */
   end                                           /*                  */
   return                                        /*                  */
TABLE_CREATE:                                    /* create ISPF tab  */
  arg table VARLIST                              /* accept args      */
  address ISPEXEC "CONTROL ERRORS RETURN"        /* return on error  */
  address ISPEXEC "TBOPEN "table                 /* try to open tab  */
  if rc = 8 then                                 /* if not found..   */
    do                                           /*                  */
    address ISPEXEC "TBCREATE "table varlist     /* create it..      */
    address ISPEXEC "TBCLOSE "table              /* and then close   */
    end                                          /*                  */
    else address ISPEXEC "TBCLOSE "table         /* force close      */
  address ISPEXEC "TBOPEN "table                 /* open table       */
  address ISPEXEC "CONTROL ERRORS CANCEL"        /* accept errors    */
  return                                         /*                  */
TABLE_ERASE:                                     /*                  */
  arg table                                      /* accepts arg      */
  address ISPEXEC "CONTROL ERRORS RETURN"        /* return on error  */
  address ISPEXEC "TBCLOSE "table                /* close table      */
  address ISPEXEC "TBERASE "table                /* erase table      */
  address ISPEXEC "CONTROL ERRORS CANCEL"        /* accept errors    */
  return                                         /*                  */
ERROR_MSG:                                       /*                  */
  arg action actrsn                              /* accepts arg      */
  ZEDSMSG = action 'Failed'                      /* short msg        */
  ZEDLMSG = 'Reason Code = 'actrsn               /* long msg         */
  address ISPEXEC "SETMSG MSG(ISRZ001)"          /* issue msg        */
  return                                         /*                  */
OK_MSG:                                          /*                  */
  arg action                                     /* accepts arg      */
  ZEDSMSG = action 'Successful'                  /* short msg        */
  ZEDLMSG = ' '                                  /* long msg         */
  address ISPEXEC "SETMSG MSG(ISRZ001)"          /* issue msg        */
  return                                         /*                  */
DATASET_CHECK: procedure                         /*                  */
  dsn = strip(arg(1))                            /* get dataset name */
  mem = strip(arg(2))                            /* get member name  */
  full = "'"||dsn||"("||mem||")'"                /* construct name   */
  data = sysdsn(full)                            /* get result       */
  return data                                    /* pass to caller   */
ISPF panels


Panel DYNXLIST

)ATTR
  % TYPE(INPUT) COLOR(RED) PAD(_)
  ! TYPE(OUTPUT) INTENS(LOW) COLOR(TURQ)
  $ TYPE(OUTPUT) INTENS(LOW) COLOR(GREEN)
  # TYPE(OUTPUT) INTENS(LOW) COLOR(RED)
  @ TYPE(OUTPUT) INTENS(LOW) COLOR(YELLOW)
  } TYPE(OUTPUT) INTENS(LOW) COLOR(BLUE)
)BODY WINDOW(76,20)
%Command ===>_ZCMD                                                   +
%
%  Line commands available:
%
% %a+Add Exit %d+Delete Exit %s+Show information %u+Update exit
%
%  Exit              Call     Module   Entry     Load
%  Name              Sequence Name     Point     Point    Length   Status
)MODEL
%z@XTNME            $XTSEQ   !XTMOD   !XTEP    +!XTLD    }XTLN    #XTA     +
)INIT
 &ZWINTTL = 'Dynamic Exits - Summary Information'
 .zvars = '(xsel)'
 &xsel = ' '
)PROC
ver (&xsel,list,a,A,d,D,u,U,s,S)
)END


Panel DYNXADD

)ATTR
  @ TYPE(OUTPUT) INTENS(LOW) COLOR(YELLOW)
)BODY WINDOW(64,16)
%COMMAND ===>_ZCMD                                   +
%
%  Exit Name    :@XTNME           +
%
%  Module Name  :_XTMOD   +
%  From dataset :_XTDSN                                       +
%
%  Status       :_XTA     +    (Active/Inactive)
%
%  Filtering    :_XTFL    +    (None/Jobname)
%  Filter Mask  :_XTFM    +
%
%  Abend Limit  :_XTAB    +    (nnnn or MAXIMUM)
%  Count Method :_XTABO      + (Total/Consecutive)
%
)INIT
 &ZWINTTL = 'Dynamic Exits - Add Module'
 &XTA = 'INACTIVE'
 &XTFL= 'NONE'
 &XMOD= ' '
 &XTAB= 'MAXIMUM'
 &XTABO= 'TOTAL'
)PROC
 VER (&XTMOD,NB)
 VER (&XTMOD,NAME)
 VER (&XTA,LIST,ACTIVE,INACTIVE)
 VER (&XTFL,LIST,NONE,JOBNAME)
 VER (&XTABO,LIST,TOTAL,CONSECUTIVE)
)END


Panel DYNXDEL

)ATTR
  [ TYPE(OUTPUT) INTENS(LOW) COLOR(TURQ)
  $ TYPE(OUTPUT) INTENS(LOW) COLOR(GREEN)
  @ TYPE(OUTPUT) INTENS(LOW) COLOR(YELLOW)
)BODY WINDOW(64,8)
%COMMAND ===>_ZCMD                                   +
%
%  Exit Name    :@XTNME           +
%
%  Module Name  :[XTMOD   +        %Status      :$XTA     +
%
%  Delete       :_z+ (Yes/No)
)INIT
 &ZWINTTL = 'Dynamic Exits - Confirm Delete'
 .zvars = '(xtconf)'
 &XTCONF = 'N'
)PROC
 VER (&XTCONF,LIST,Y,N,y,n)
)END


Panel DYNXSHOW

)ATTR
  [ TYPE(OUTPUT) INTENS(LOW) COLOR(TURQ)
  $ TYPE(OUTPUT) INTENS(LOW) COLOR(GREEN)
  @ TYPE(OUTPUT) INTENS(LOW) COLOR(YELLOW)
)BODY WINDOW(64,16)
%COMMAND ===>_ZCMD                                   +
%
%  Exit Name    :@XTNME           +%Sequence    :$XTSEQ   +
%
%  Module Name  :[XTMOD   +        %Length      :$XTLN    +
%  Entry Point  :[XTEP    +        %Load Point  :$XTLD    +
%  Amode        :$XTM     +        %Reentrant   :$XTR     +
%
%  Status       :$XTA     +        %Module Limit:$XTO       +
%
%  Filtering    :$XTFL    +
%  Filter Mask  :$XTFM    +
%
%  Abend Limit  :$XTAB    +        %Count Method:$XTABO      +
%
)INIT
 &ZWINTTL = 'Dynamic Exits - Detail Information'
)PROC
)END


Panel DYNXMOD

)ATTR
  [ TYPE(OUTPUT) INTENS(LOW) COLOR(TURQ)
  @ TYPE(OUTPUT) INTENS(LOW) COLOR(YELLOW)
)BODY WINDOW(64,12)
%COMMAND ===>_ZCMD                                   +
%
%  Exit Name    :@XTNME           +
%
%  Module Name  :[XTMOD   +
%
%  Status       :_XTA     + (Active/Inactive)
%
%  Filtering    :_XTFL    + (None/Jobname)
%
%  Filter Mask  :_XTFM    + Specify jobname mask
%
)INIT
 &ZWINTTL = 'Dynamic Exits - Modify'
)PROC
 VER (&XTA,LIST,ACTIVE,INACTIVE)
 VER (&XTFL,LIST,NONE,JOBNAME)
)END


Rob Scott
MVS Consultant (UK)                      c Xephon 1996

