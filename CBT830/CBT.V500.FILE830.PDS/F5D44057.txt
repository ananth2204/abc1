A batch MVS/370 virtual storage monitor (cont)

This month we conclude this article with the publication of the source
code for CLPASCAN, CSABMAP, PLPAMODS, and the SAS job VS370ANL.

CLPASCAN

*  THIS CODE SHOWS THE MODULES IN THE FLPA, MLPA AND CSA.
*  YOU NEED TO SELECT WHICH AREA(S) YOU WANT TO SCAN (SEE CODE)
*  ALIAS NAME FOR MODULES ARE NOT SHOWN
*  >>> THIS CODE DOES NOT REQUIRE SPECIAL AUTHORIZATION. <<<
LPACDE   CSECT
         USING LPACDE,R2          ADDRESSABILITY--NO ENTRY LINKAGE
         LR    R2,R15                WE WILL ABEND
         L     R3,16              GET CVT ADDRESS
         SR    R4,R4              START ADDRESS OF NUCLEUS (ZERO)
         L     R5,416(R3)         START ADDRESS OF COMMON
         L     R6,560(R3)         GET GDA ADDRESS
         L     R6,8(R6)           GET CSA PQE ADDRESS
         L     R6,20(R6)          GET SIZE OF CSA
         AR    R6,R5              GET END ADDRESS OF CSA
         L     R7,360(R3)         GET START ADDRESS OF PLPA DIRECTORY
         SLL   R7,8
         SRL   R7,8               ZERO BYTE # 0
         L     R8,188(R3)         GET POINTER TO POINTER TO LPA CDE Q
         L     R8,0(R8)           GET POINTER TO LPA CDE Q
         LA    R13,CDESAVE        SET POINTER TO CDE SAVE AREA
*  YOU MUST SELECT LOWER AND UPPER TEST BOUNDARIES
*  BOUNDARIES:       R4    START OF NUCLEUS
*                    R5    START OF COMMON (CSA)
*                    R6    END OF CSA (START OF BLDL/MLPA)
*                    R7    START OF PLPA (END OF MLPA)
*  CURRENTLY, THE BOUNDARIES ARE SET FOR FLPA, CSA AND MLPA
         LR    R14,R4             TEST FOR FLPA (ONLY)
*        LR    R15,R5
*        LR    R14,R5             TEST FOR CSA  (ONLY)
*        LR    R15,R6
*        LR    R14,R6             TEST FOR MLPA (ONLY)
         LR    R15,R7
*  CHECK CDE.  GET EXTENT LIST.  GET MODULE LENGTH AND ADDRESS.
*  DETERMINE IF IT LIES WITHIN THE USER-SELECTED BOUNDARIES.  IF IT
*  DOES, GET USE COUNT AND SAVE LENGTH, ADDRESS, USE COUNT, AND NAME.
*  THE USE COUNT COULD BE MONITORED IN A PROGRAM OF YOUR DESIGN.
CDELOOP  TM    28(R8),X'04'       MINOR CDE?
         BO    NEXTCDE            YES--GO GET ANOTHER CDE
         TM    28(R8),X'80'       HAS THIS MODULE BEEN LOADED BY NIP?
         BZ    NEXTCDE            NO---GET NEXT CDE
         L     R9,20(R8)          GET EXTENT LIST ADDRESS
         LTR   R9,R9              EXTENT LIST ADDRESS ZEROS?
         BZ    NEXTCDE            YES--THIS IS AN EMPTY CDE
         L     R10,8(R9)          MODULE LENGTH
         SLL   R10,1
         SRL   R10,1              ZERO BIT # 0
         L     R11,12(R9)         MODULE ADDRESS
         LR    R3,R14             GET LOWER BOUNDARY
         SR    R3,R11             MODULE ADDRESS BELOW THIS ADDR?
         BP    NEXTCDE            YES--GET NEXT CDE
         LR    R3,R15             GET UPPER BOUNDARY
         SR    R3,R11             MODULE ADDRESS ABOVE THIS ADDR?
         BM    NEXTCDE            YES--GET NEXT CDE
         LH    R12,24(R8)         GET MODULE USE COUNT
         STM   R10,R12,0(R13)     SAVE LENGTH,ADDR OF THIS MODULE
         MVC   12(8,R13),8(R8)    SAVE NAME
         LA    R13,20(R13)        INCREMENT SAVE AREA POINTER
NEXTCDE  L     R8,0(R8)           GET NEXT CDE IN LPAQ
         LTR   R8,R8              LAST CDE?
         BNZ   CDELOOP            NO---CONTINUE LOOPING
         ABEND 4,DUMP             YES-ABEND
         LTORG
FLAG     DC    CL4'FLAG'          FLAG FOR MODULE DESCRIPTOR AREA
CDESAVE  DC    8000F'0'
         END

CSABMAP

*  THIS CODE PRODUCES A BYTE MAP FOR THE CSA, EACH BYTE REPRESENTING
*  A PAGE OF CSA STORAGE.  THE BYTE WILL CONTAIN THE OWNING SUBPOOL
*  FOR THAT PAGE OR HEX '00' FOR FREE PAGES.  THE BYTE MAP WILL
*  START AFTER THE CHARACTERS "START OF BYTEMAP" AND WILL END
*  JUST BEFORE THE CHARACTERS "END OF BYTEMAP" IN THE DUMP.
*  >>> THIS CODE DOES NOT REQUIRE ANY SPECIAL AUTHORIZATION. <<<
CSABMAP  CSECT
         USING CSABMAP,R2         ADDRESSABILITY
         LR    R2,R15               NO LINKAGE--WE WILL ABEND
*  ZERO CSA SIZE ACCUMULATOR.  GET CSA PQE ADDRESS.
         LA    R8,0               ZERO CSA SIZE ACCUM
         L     R3,16              GET CVT ADDRESS
         L     R14,416(R3)        GET COMMON START ADDR
         L     R3,560(R3)         GET GDA ADDRESS
         L     R7,8(R3)           GET CSA PQE ADDRESS
*  GET LENGTH OF CSA.  SETUP FOR SUBPOOL ANALYSIS.
CSALEN   L     R5,20(R7)          GET LENGTH DESC BY THIS PQE
         AR    R8,R5              ADD TO CSA SIZE ACCUMULATOR
         L     R7,8(R7)           GET NEXT PQE
         LTR   R7,R7              IS THERE A "NEXT PQE"?
         BNZ   CSALEN             YES, LOOP
         L     R7,52(R3)          GET FIRST CSA SPQE ADDRESS
*  GET FIRST DQE FOR THIS SUBPOOL.  IF NONE, GOTO NEXT SPQE.
LOOPSPQE L     R5,4(R7)           GET FIRST DQE ADDRESS
         LTR   R5,R5              CHECK IF THERE ARE ANY DQE'S
         BZ    NODQE              NO--GET NEXT SPQE
*  GET LENGTH DESCRIBED BY EACH DQE.  CONVERT TO # OF PAGES.  INDEX
*  INTO THE BYTE MAP.  MOVE SUBPOOL NUMBER INTO BYTE(S).
LOOPDQE  L     R6,12(R5)          GET LENGTH DESC BY THIS DQE
         SRL   R6,12              CONVERT TO NUMBER OF PAGES
         L     R4,8(R5)           GET START ADDRESS
         SR    R4,R14             SUBTRACT CSA START ADDR
         SRL   R4,12              GET START PAGE NUMBER
         A     R4,=A(BYTEMAP)     INDEX INTO BYTE MAP
LOOPBM   MVC   0(1,R4),10(R7)     MOVE SP NUMBER INTO BYTEMAP
         LA    R4,1(R4)           POINT AT NEXT PAGE IN BYTEMAP
         BCT   R6,LOOPBM          DECREMENT PAGE COUNT
         L     R5,4(R5)           GET NEXT DQE ADDR FOR SPQE
         LTR   R5,R5              IS THERE A "NEXT DQE"?
         BNZ   LOOPDQE            YES, CONTINUE LOOP
*  CHECK IF THIS IS THE LAST SPQE.  CONTINUE LOOP IF NOT.
NODQE    TM    8(R7),X'40'        TEST FOR LAST SPQE
         BO    MOVECHAR           BRANCH IF THIS IS LAST SPQE
         L     R7,0(R7)           GET NEXT SPQE
         B     LOOPSPQE           LOOP
*  NO MORE SPQES.  MARK END OF BYTE MAP AND ABEND.
MOVECHAR LA    R7,BYTEMAP         GET START OF BYTEMAP
         SRL   R8,12              CONVERT CSA SIZE TO PAGES
         AR    R7,R8              GET END OF BYTEMAP
         MVC   0(14,R7),FLAG2     MARK END OF BYTEMAP
         MVC   FLAG2,FLAG3        BLANK OUT CONFUSING DUPLICATION
         ABEND 4,DUMP
         LTORG
DUMMY    DS    D
FLAG     DC    CL16'START OF BYTEMAP'
BYTEMAP  DS    200F
FLAG2    DC    CL14'END OF BYTEMAP'
FLAG3    DC    CL14'              '
         END

PLPAMODS

*  THIS PROGRAM GIVES: NUMBER OF SELECTED MODULES IN PLPA DIR (R8)
*                      TOTAL NUMBER OF ALIASES IN PLPA DIRECTORY (R9)
*                      TOTAL LENGTH OF ALL SELECTED MODULES (R10)
*                      LIST OF NAMES OF SELECTED MODULES (DATA AREA)
*   YOU SELECT THE SEARCH STRING IN THE FIELD "TEST"
*   NOTE: THE FIELD NAMED "NAMESAVE" MAY NEED TO BE LARGER
*         (IT CURRENTLY HOLDS ONLY 400 NAMES).
*  >>> THIS CODE DOES NOT REQUIRE ANY SPECIAL AUTHORIZATION. <<<
LPADIR   CSECT
         USING LPADIR,R2          ADDRESSABILITY--NO RETURN LINKAGE
         LR    R2,R15               NEEDED (WE WILL ABEND LATER)
*  GET CVT ADDR, PLPA DIRECTORY ADDR, ZERO ACCUMULATORS, AND
*  POINT AT START OF DATA AREA FOR VIEWING IN DUMP
         L     R3,16
         L     R8,552(R3)         PLPA DIRECTORY SIZE
         L     R3,360(R3)         START OF PLPA DIRECTORY
         SLL   R3,8
         SRL   R3,8               ZERO OUT BYTE # 0
         SR    R4,R4              ZERO "TOTAL LENGTH" ACCUMULATOR
         SR    R9,R9              ZERO "ALIAS COUNT" ACCUMULATOR
         LA    R6,NAMESAVE        POINT AT START OF DATA AREA
         SR    R7,R7              ZERO "# OF MODULES SELECTED" ACCUM
*  START OF DIRECTORY SEARCH LOOP.  CHECK FOR LPDE BEING MINOR LPDE--
*  IF SO, INCREMENT ALIAS COUNT AND CHECK NEXT LPDE.
LPDELOOP TM    28(R3),X'04'       MINOR LPDE?
         BZ    CONTINUE           NO---CONTINUE CHECKING LPDE
         LA    R9,1(R9)           INCREMENT ALIAS COUNT
         LA    R3,40(R3)          POINT AT NEXT LPDE
         B     LPDELOOP
*  CONTINUE CHECK OF LPDE--IF NOT LOADED BY NIP, GO CHECK NEXT LPDE.
*  COMPARE NAME WITH YOUR CHARACTER STRING--IF NO MATCH, CHECK NEXT
*  LPDE.
CONTINUE TM    28(R3),X'80'       WAS MODULE LOADED BY NIP/MLPA/FLPA
         BZ    NEXTLPDE           NO---GET NEXT LPDE
         CLC   TEST,8(R3)         SELECTED MODULE?
         BNE   NEXTLPDE           NO---GET NEXT LPDE
*  GET MODULE LENGTH AND ADD TO TOTAL ACCUMLATOR.  GET MODULE NAME.
*  INCREMENT COUNT OF PLPA MODULES SELECTED ON THE BASIS OF YOUR
*  SEARCH STRING.
         L     R5,32(R3)          GET LENGTH
         SLL   R5,8
         SRL   R5,8               ZERO BYTE # 0
         AR    R4,R5              ADD TO TOTAL
         MVC   0(8,R6),8(R3)      MOVE NAME TO SAVE AREA
         LA    R6,8(R6)           POINT TO NEXT NAME SAVE AREA
         LA    R7,1(R7)           INCREMENT LPDE COUNT (NON-ALIAS)
*  GET NEXT LPDE.  CONTINUE CHECKING LPDES.
NEXTLPDE LA    R3,40(R3)          GET NEXT LPDE IN LPAQ
         BCT   R8,LPDELOOP        CONTINUE LOOPING
*  COPY ACCUMULATOR VALUES INTO R8 AND R10 TO HAVE RELEVANT DATA
*  IN CONTIGUOUS REGISTERS.  ABEND.
         LR    R8,R7              R8 HAS NUMBER OF MODS IN LPA
         LR    R10,R4             R10 HAS LENGTH OF SELECTED MODS
         ABEND 4,DUMP             ABEND WITH DUMP
         LTORG
TEST     DC    CL3'DFH'           TEST STRING--YOU SUPPLY
NAMESAVE DC    400D'0'            DATA AREA--MAY BE TOO SMALL
         END

VS370ANL

This SAS job determines the minimum number of free pages left in the CSA and
SQA, and plots the data by date.
//Z03JDRST JOB
//STEP010  EXEC PROC=SAS
//DATA     DD   DISP=SHR,DSN=Z03AF.VS370MON.STATS
//SYSIN    DD *
DATA DOG; INFILE DATA;
INPUT @1 A_RECORD $CHAR16. @;
IF SUBSTR(A_RECORD,1,8) = 'IPLDATA ' THEN GOTO HEADREC;
DATAREC:
    INPUT
        @1   CSAFREE  PIB2.
        @3   CSAFREET PIB2.
        @5   SQATOTAL PIB2.
        @7   SQAFREE  PIB2.
        @13  JDAY     PD4.; JDAY = JDAY/1000;
    RETURN;
HEADREC:
    INPUT;
    INPUT @1 A_RECORD $CHAR16.;
    DROP A_RECORD;
    RETURN;
PROC SORT; BY JDAY;
DATA CAT; SET DOG; BY JDAY;
IF FIRST.JDAY THEN DO; MINCSA = 1000; MINSQA = 1000; END;
IF CSAFREE < MINCSA THEN MINCSA = CSAFREE;
IF SQAFREE < MINSQA THEN MINSQA = SQAFREE;
IF LAST.JDAY THEN OUTPUT; RETAIN MINCSA MINSQA;
PROC PRINT;
PROT PLOT;
     PLOT MINCSA*JDAY='C' MINSQA*JDAY='S' / OVERLAY;
     TITLE 'MINIMUM CSA AND SQA LEVELS (IN PAGES) OVER TIME';


David Saunders
Senior Systems Engineer
University of Virginia (USA)  € University of Virginia 1988






































