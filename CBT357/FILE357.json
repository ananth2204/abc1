{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011828000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 9640904, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 57, "INMDSNAM": "CBT.V500.FILE357.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 9640904, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 9640904, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE357.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x98\\r'", "DS1TRBAL": "b'?\\xe2'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\x98\\x00\\x0c\\x02\\xa2\\x00\\x0e\\x00\\x99'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04]\\x00D\\x01\\x162\\x8f\\x01\\x162\\x8f\\x08H\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf3@@@'", "ispf": {"version": "04.93", "flags": 0, "createdate": "2016-11-23T00:00:00", "modifydate": "2016-11-23T08:48:44", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-493"}, "text": "REGULAR CBT TAPE - VERSION 493    FILE:  357\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT493.FILE357\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 302 MEMBERS COUNTED; CUMULATIVE SIZE IS 89,865 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/23/16    08:48:43    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$NOTE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xf3\\x00\\xf3\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf5\\xf7@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 243, "newlines": 243, "modlines": 0, "user": "FILE357"}, "text": "                                                                        FILE 357\n  This is File 357 from the CBT Tape.  These are all freeware and       FILE 357\n  may be used, changed or included without restriction.                 FILE 357\n  Comments, problem reports or suggestions are always welcome.          FILE 357\n                                                                        FILE 357\n  Some changes have been made to facilitate installation.  The          FILE 357\n  @XALLMEM member is set to change the dummy file and job               FILE 357\n  information to whatever you desire via either ALLMEM or               FILE 357\n  XALLMEM.  The @LOADLIB member is an unload of the load module         FILE 357\n  PDS for ease of loading (and for those without PL/I compilers).       FILE 357\n                                                                        FILE 357\n  Programs with assembly/compile/link JCL are in their member           FILE 357\n  names, i.e. UNTOUCH is the code and compile JCL; a suffix of $        FILE 357\n  has sample run JCL, i.e. UNTOUCH$ is the execution JCL.  Each         FILE 357\n  program and its associated JCL has its name as the ISPF ID            FILE 357\n  statistic.  The REXX macros have an ID of REXX and CLIST macros       FILE 357\n  CLIST to allow easier separation.  Assembler macros specify an        FILE 357\n  ID of MACRO.                                                          FILE 357\n                                                                        FILE 357\n  All programs now have documentation in @PGMDOC# and almost all        FILE 357\n  executables have built in help as well as formal external             FILE 357\n  documentation in @MACDOC#.  The documentation files are ASCII         FILE 357\n  carriage controlled.  The documentation has been revised with         FILE 357\n  another clean up.  The original input to ADDCC for both the           FILE 357\n  macro and program documentation has been included as @MACDOCO         FILE 357\n  and @PGMDOCO as requested to allow anyone to easily change them       FILE 357\n  for local use.                                                        FILE 357\n                                                                        FILE 357\n  The available programs are written in Assembler, COBOL and            FILE 357\n  PL/I.  For those non PL/I shops, check with your System Support       FILE 357\n  folks; you may be surprised to find there's a \"free\" older            FILE 357\n  level out there.  PDSGAS has been eliminated since it                 FILE 357\n  apparently has some quirks and many folks are now going to            FILE 357\n  PDSE's.  Changed programs are shown below with a tilde (~); new       FILE 357\n  ones with a plus (+) The programs are:                                FILE 357\n                                                                        FILE 357\n    ~ ABENDX to force a user abend with a given code or system          FILE 357\n      generated abend, either callable or by itself - now               FILE 357\n      allows system abends such as 0C1 (Asembler)                       FILE 357\n                                                                        FILE 357\n    ~ ADDCC to add carriage control to a sequential file with           FILE 357\n      some text descriptors like a table of contents, useful            FILE 357\n      for keeping documentation reasonably easily maintained            FILE 357\n      and still producing neat output - changed to make first           FILE 357\n      carriage control always a ' ' and allow comments (PL/I)           FILE 357\n                                                                        FILE 357\n    - ALPHACNT to convert decimal to alphanumeric numbers, add or       FILE 357\n      subtract one from an alpha number, and validate it (COBOL         FILE 357\n      sub-programs within a test program)                               FILE 357\n                                                                        FILE 357\n    - CLRSCRN to provide a generic (as far as I know) capability        FILE 357\n      to clear the TSO screen based on code from Gilbert                FILE 357\n      Saint-flour (Assembler)                                           FILE 357\n                                                                        FILE 357\n    - COBBITS to set and test bits within any size COBOL array          FILE 357\n      (COBOL sub-programs within a test program)                        FILE 357\n                                                                        FILE 357\n    - COBHEXR to convert character strings into their hex               FILE 357\n      equivalent, e.g. 'A' to 'C1' (COBOL sub program within            FILE 357\n      a test program)                                                   FILE 357\n                                                                        FILE 357\n    - DETAB is a PL/I program that rebuilds a tab (or other             FILE 357\n      separator character) delimited file into a new restructured       FILE 357\n      file with each field the maximum length and generates both        FILE 357\n      COBOL and Easytrieve layouts (new PL/I) - it has undergone        FILE 357\n      major revisions to handle headers and trailers, process           FILE 357\n      numeric values with signs and decimal places and even roll        FILE 357\n      the signs onto the last digit, pad decimal places on the          FILE 357\n      right and eliminate the actual decimal point.                     FILE 357\n                                                                        FILE 357\n    - DIRSCNC and DIRSCNQ are COBOL and PL/I programs that read         FILE 357\n      a Partitioned Data Set directory and generate card images         FILE 357\n      using the member name as an insertable token                      FILE 357\n                                                                        FILE 357\n    - FOREVER is a COBOL program set to run daily, submit only on       FILE 357\n      Friday a job once which reads a file and does a read against      FILE 357\n      every file named in that file - intended to keep files from       FILE 357\n      migrating or being deleted for non-use                            FILE 357\n                                                                        FILE 357\n    - GETDSN is an assembler sub routine that returns the data          FILE 357\n      set name (and member if applicable) of a file in a COBOL          FILE 357\n      program (Assembler)                                               FILE 357\n                                                                        FILE 357\n    - PAGES to grab complete logical pages from the beginning, middle,  FILE 357\n      end or specific range of any ASCII carriage controlled file       FILE 357\n      (PL/I)                                                            FILE 357\n                                                                        FILE 357\n    - PDSGEN to generate control cards or member information from       FILE 357\n      any concatenated PDS's (Assembler)                                FILE 357\n                                                                        FILE 357\n    - PDSLIST to list concatenated PDS's of any record format           FILE 357\n      (Assembler)                                                       FILE 357\n                                                                        FILE 357\n    ~ PDSMATCH to match 2 PDS's in several ways; also a CBT Tape        FILE 357\n      entry but with added ability to match by data and now             FILE 357\n      has capability to generate SUPERC compares for those members      FILE 357\n      not found equal (Assembler)                                       FILE 357\n                                                                        FILE 357\n    - PDSPUNCH to turn any PDS(s) into a sequential file with           FILE 357\n      IEBUPDTE ADD or REPL header cards (Assembler)                     FILE 357\n                                                                        FILE 357\n    - PULL to select one or more sets of records from any seq file      FILE 357\n      to either save to a file or go directly to a printer (PL/I)       FILE 357\n                                                                        FILE 357\n    - SETRC to set any legitimate MVS return code (Assembler)           FILE 357\n                                                                        FILE 357\n    - SMARTGN to take a list of values, e.g. data set names, and        FILE 357\n      substitute those values into card images, e.g. JCL,               FILE 357\n      generating one set of card images for each value (PL/I)           FILE 357\n                                                                        FILE 357\n    - TOUCH to change any PDS statistics of one or more members -       FILE 357\n      use with PDSGEN above to clean up the stats in an entire          FILE 357\n      PDS or part thereof - this was changed to force a member          FILE 357\n      with no ISPF statistics to default to a directory length of       FILE 357\n      42 with whatever stats were specified plus defaults for the       FILE 357\n      rest (PL/I main calling Assembler subroutines)                    FILE 357\n                                                                        FILE 357\n    - UNTOUCH to remove statistics from a PDS's directory (PL/I         FILE 357\n      main calling Assembler)                                           FILE 357\n                                                                        FILE 357\n    ~ VALUES to show all the unique data content of one or more         FILE 357\n      sets of columns within any sequential file (PL/I) - now           FILE 357\n      will show statistics for each byte in a range                     FILE 357\n                                                                        FILE 357\n  There are also ISPF Edit and DSList REXX macros with both built       FILE 357\n  in documentation and formal documentation in @MACDOC#.  The           FILE 357\n  macros extend ISPF to allow:                                          FILE 357\n                                                                        FILE 357\n    - column copying, moves, deletion, fill, numbering,                 FILE 357\n      shifting, spliting/joining, summing of numeric data, and          FILE 357\n      packing/unpacking and conversion to/from binary                   FILE 357\n                                                                        FILE 357\n    - \"find\" of multiple and/or/nor conditions, of all duplicate        FILE 357\n      lines (via exclude/include), of the minimum/maximum               FILE 357\n      value in a column, of lines not equal to some value,              FILE 357\n      of pending commands, of excluded lines, of the                    FILE 357\n      longest/shortest lines and of all unique lines; also              FILE 357\n      show the logical structure of a program and show more             FILE 357\n      or less of excluded data; most have a pseudo repeat               FILE 357\n      assignable to a PF key                                            FILE 357\n                                                                        FILE 357\n    - delete blank lines, delete duplicates, sort and find              FILE 357\n      duplicates, gather all excluded lines, sort shown lines           FILE 357\n      keeping excluded lines attached, and sort and show all            FILE 357\n      unique lines                                                      FILE 357\n                                                                        FILE 357\n    - add flags to selected lines, center/justify, reverse lines,       FILE 357\n      format JCL and remove extra blanks                                FILE 357\n                                                                        FILE 357\n    - copy another PDS's member or another data set with one            FILE 357\n      command, cut/paste after one or more lines with one               FILE 357\n      command, and do mutliple pastes by PF key                         FILE 357\n                                                                        FILE 357\n    - in DS List, get the last reference date without setting           FILE 357\n      it, get a record count from one or more data sets,                FILE 357\n      duplicate a data set or PDS, do a SuperC find string, and         FILE 357\n      get the length of the longest/shortest record(s)                  FILE 357\n                                                                        FILE 357\n    - split/join lines via PF key, find out what a hex operation        FILE 357\n      code is, do basic calculations in TSO, add lines before/after     FILE 357\n      every member in a PDS, execute an edit macro against every        FILE 357\n      member, and concatenate a new file                                FILE 357\n                                                                        FILE 357\n  The following macros have been removed:                               FILE 357\n                                                                        FILE 357\n     - DS List (DSLIST) since little use was seen for it                FILE 357\n                                                                        FILE 357\n     - Easytrieve data structure generator from COBOL data              FILE 357\n       structure (CBL2EZ) since both FileAid and InSynch                FILE 357\n       offer this service and one of them would need to be              FILE 357\n       used in this macro                                               FILE 357\n                                                                        FILE 357\n  The following macros are new:                                         FILE 357\n                                                                        FILE 357\n     - Align text at multiple specific delimiter occurrences            FILE 357\n       (ALIGNALL and ALIGNAX)                                           FILE 357\n                                                                        FILE 357\n     - Convert character to hex (C2H)                                   FILE 357\n                                                                        FILE 357\n     - Describe file parameters and count (DESC)                        FILE 357\n                                                                        FILE 357\n     - Encrypt data (ENC2) improves on ENC                              FILE 357\n                                                                        FILE 357\n     - Submit a PDS scan for a string (FS)                              FILE 357\n                                                                        FILE 357\n     - Convert hex to characters (H2C)                                  FILE 357\n                                                                        FILE 357\n     - Create new sequential or partitioned file (NEW/NEWP)             FILE 357\n                                                                        FILE 357\n     - Paste equivalents for PASTEAFT and PASTY to work with            FILE 357\n       new IBM CUT and PASTE commands (PA and PY)                       FILE 357\n                                                                        FILE 357\n     - Keep only specified columns, invokable from both DS              FILE 357\n       List and from within Edit/View (KEEPCOLS)                        FILE 357\n                                                                        FILE 357\n     - Perform CLONE and CLONER in background (QCLONE and               FILE 357\n       QCLONER)                                                         FILE 357\n                                                                        FILE 357\n     - Pull portion of VSAM files into Viewable sequential              FILE 357\n       dataset using REPRO parameters (VWV)                             FILE 357\n                                                                        FILE 357\n  The following were changed:                                           FILE 357\n                                                                        FILE 357\n     - ALIGN now handles strings with included blanks correctly         FILE 357\n                                                                        FILE 357\n     - CHDEL uses IEFBR14 to force a zero return code                   FILE 357\n                                                                        FILE 357\n     - CLONE and CLONER handle PS-E's and will pad with                 FILE 357\n       blanks on the right when going to a larger fixed file            FILE 357\n       size.                                                            FILE 357\n                                                                        FILE 357\n     - COBCOLOF, COBCOLOI, COBCOLSF and COBCOLSI have been changed      FILE 357\n       to better handle OCCUIRS and REDEFINES (still not totally        FILE 357\n       OK since OCCURS within OCCURS are not handled).                  FILE 357\n                                                                        FILE 357\n     - CONBLANK built in doc corrected                                  FILE 357\n                                                                        FILE 357\n     - COUNTX handles PS-E and VSAM files                               FILE 357\n                                                                        FILE 357\n     - CVB correctly handles plus zoned values                          FILE 357\n                                                                        FILE 357\n     - DISPVAR fixed for multi-line constructs                          FILE 357\n                                                                        FILE 357\n     - HOWLONG counts blanks to determine longest and shortest          FILE 357\n       fixed length records                                             FILE 357\n                                                                        FILE 357\n     - IE, II, IP, IS, ISA and IST handle indentations better           FILE 357\n                                                                        FILE 357\n     - ISORT changed sort work definitions and cursor positioning       FILE 357\n                                                                        FILE 357\n     - JT now places the View of a copybook into the swap list          FILE 357\n                                                                        FILE 357\n     - LKDT will stop on not finding IDR information                    FILE 357\n                                                                        FILE 357\n     - SAVEINPL handles PDSE's                                          FILE 357\n                                                                        FILE 357\n     - VW now places the View of a copybook into the swap list          FILE 357\n                                                                        FILE 357\n  Any problem reports or sugestions are welcome and will be             FILE 357\n  implemented as quickly as time allows.  They may be sent to           FILE 357\n  C_Hafner@HotMail.Com - please place member name somewhere             FILE 357\n  in the Subject line.                                                  FILE 357\n                                                                        FILE 357\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$NOTE1": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00@\\x01\\x03\\x14?\\x01\\x03\\x14?\\tC\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-05-23T00:00:00", "modifydate": "2003-05-23T09:43:40", "lines": 20, "newlines": 20, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:    New File 357\n   Date:    Fri, 23 May 2003 09:35:22 -0400\n   From:    \"Carl Hafner\" <c_hafner@hotmail.com> (by way of Sam\n            Knutson <sam@knutson.org>)\n     To:    sbgolob@cbttape.org\n\nSam,\n\nThis version of File 357 has 30 new REXX EXEC's plus several\nfixes/updates.  It also has a new program plus a few changes.\nAs before, all the macros plus the programs have full formal\ndocumentation in @MACDOC# and @PGMDOC#.   I'd been asked to\nprovide the input to these documents in the pseudo scripted tag\nformat and have done so.\n\n$$$NOTE and @FILE357 have been completely revised.  There should\nbe 177 members in all.\n\nThanks again!\n                                                      Carl Hafner\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE357": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04]\\x003\\x01\\x162\\x8f\\x01\\x162\\x8f\\x08H\\x01O\\x01O\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf3@@@'", "ispf": {"version": "04.93", "flags": 0, "createdate": "2016-11-23T00:00:00", "modifydate": "2016-11-23T08:48:33", "lines": 335, "newlines": 335, "modlines": 0, "user": "CBT-493"}, "text": "//***FILE 357 This file contains several utilities to process       *   FILE 357\n//*           partitioned data sets, some COBOL and PL/I            *   FILE 357\n//*           utilities, and a number of ISPF EDIT and DS List      *   FILE 357\n//*           macros. All are freeware to be used as desired.       *   FILE 357\n//*           The utilities are now all in an unloaded member,      *   FILE 357\n//*           @LOADLIB.                                             *   FILE 357\n//*                                                                 *   FILE 357\n//*               C_Hafner@HotMail.Com                              *   FILE 357\n//*                                                                 *   FILE 357\n//*       File Contents:                                            *   FILE 357\n//*                                                                 *   FILE 357\n//*       $$$NOTE  -- Introductory release notes                    *   FILE 357\n//*       @FILE357 -- Simple description of file content  (this     *   FILE 357\n//*                   file)                                         *   FILE 357\n//*       @MACDOC# -- Documentation for all Edit & CLIST macros     *   FILE 357\n//*                   expamded with carriage control                *   FILE 357\n//*       @MACDOCO -- Documentation for all Edit & CLIST macros     *   FILE 357\n//*       @PGMDOC# -- Documentation for the included programs       *   FILE 357\n//*       @PGMDOCO -- Documentation for the included programs       *   FILE 357\n//*                   expanded with carriage control                *   FILE 357\n//*                                                                 *   FILE 357\n//*       ABENDX   -- Abend with supplied user or system code       *   FILE 357\n//*       ABENDX$  -- Sample JCL for ABENDX                         *   FILE 357\n//*       ADDCC    -- Revise sequential file into printable file    *   FILE 357\n//*                   using script tags                             *   FILE 357\n//*       ADDCC$   -- Sample JCL for ADDCC                          *   FILE 357\n//*       ADDCC@   -- Add carriage control to any sequential file   *   FILE 357\n//*       ADDCOLS  -- Add columns (from Mark Zelden) of different   *   FILE 357\n//*                   types                                         *   FILE 357\n//*       ADDFLAG  -- Add revision flags to selected lines          *   FILE 357\n//*       ADDLINEA -- Part of ADDLINES                              *   FILE 357\n//*       ADDLINEB -- Part of ADDLINES                              *   FILE 357\n//*       ADDLINES -- Add a member before or after every other      *   FILE 357\n//*                   member in a PDS                               *   FILE 357\n//*       ALIGN    -- Align code based on a string                  *   FILE 357\n//*       ALIGNALL -- Align data based on delimiters                *   FILE 357\n//*       ALIGNAX  -- Align data based on delimiters and removing   *   FILE 357\n//*                   them                                          *   FILE 357\n//*       ALIGNS   -- Align code based on a string with             *   FILE 357\n//*                   minimal spaces utilized                       *   FILE 357\n//*       ALLMEM   -- Execute a macro against every member of a     *   FILE 357\n//*                   PDS (see ALLMEMC and ALLMEMF)                 *   FILE 357\n//*       ALLMEMC  -- Sample change macro for ALLMEM                *   FILE 357\n//*       ALLMEMF  -- Sample find macro for ALLMEM                  *   FILE 357\n//*       ALLOC    -- Dynamic allocation macro                      *   FILE 357\n//*       ALLOCGDX -- Allocate a relative GDG as an absolute one    *   FILE 357\n//*       ALPHACNT -- COBOL alphanumeric count routines             *   FILE 357\n//*       ASAXWC   -- IBM wildcard macro                            *   FILE 357\n//*       ASAXWC$  -- Sample use of ASAXWC                          *   FILE 357\n//*       BASEASM  -- Basic assembler read and write program        *   FILE 357\n//*       BASECOB  -- Basic COBOL read and write program            *   FILE 357\n//*       BASEEZ   -- Basic Easytrieve read and write program       *   FILE 357\n//*       BASEPLI  -- Basic PL/I read and write program             *   FILE 357\n//*       BC       -- Blank selected columns                        *   FILE 357\n//*       BLDLR    -- Routine to get member directory data          *   FILE 357\n//*       BNCHMKA  -- Assembler benchmark skeleton                  *   FILE 357\n//*       BNCHMKC  -- COBOL benchmark skeleton                      *   FILE 357\n//*       BNCHMKP  -- PL/I benchmark skeleton                       *   FILE 357\n//*       BS       -- Optimal block size calculator                 *   FILE 357\n//*       CC       -- Simple calculator                             *   FILE 357\n//*       CENTER   -- Center text                                   *   FILE 357\n//*       CHDEL    -- Dynamically create HDELs for files to be      *   FILE 357\n//*                   deleted                                       *   FILE 357\n//*       CLONE    -- Create a copy of a data set under ISPF DSList *   FILE 357\n//*       CLONER   -- Create a copy of a data set under ISPF DSList *   FILE 357\n//*                   and replace an existing data set              *   FILE 357\n//*       CLRSCRN  -- Routine to clear TSO screen                   *   FILE 357\n//*       CLS      -- Macro to invoke CLRSCRN to clear TSO screen   *   FILE 357\n//*       CLS2REXX -- Macro to convert CLIST to REXX EXEC           *   FILE 357\n//*       COBBITS  -- COBOL bit manipulation sub-programs           *   FILE 357\n//*       COBCOLOF -- Put COBOL structure offsets into columns 73   *   FILE 357\n//*                   thru 80 using FileAid                         *   FILE 357\n//*       COBCOLOI -- Put COBOL structure offsets into columns 73   *   FILE 357\n//*                   thru 80 using InSync                          *   FILE 357\n//*       COBCOLSF -- Put COBOL structure offsets into columns 73   *   FILE 357\n//*                   thru 80 using FileAid                         *   FILE 357\n//*       COBCOLSI -- Put COBOL structure offsets into columns 73   *   FILE 357\n//*                   thru 80 using InSync                          *   FILE 357\n//*       COBCOLVF -- View FileAid layout of COBOL structure        *   FILE 357\n//*       COBCOLVI -- View InSync layout of COBOL structure         *   FILE 357\n//*       COBCPUTM -- Sample COBOL CPU calculation code from MVS    *   FILE 357\n//*                   Help site                                     *   FILE 357\n//*       COBHEXR  -- COBOL hex conversion sub-program              *   FILE 357\n//*       COBLKLST -- COBOL LE link list sample                     *   FILE 357\n//*       COL      -- Macro to insert column string                 *   FILE 357\n//*       COLS     -- Macro to insert column string                 *   FILE 357\n//*       COLSCC   -- Macro to insert column string over range      *   FILE 357\n//*                   from Jim Haire                                *   FILE 357\n//*       COMPRS   -- Macro to compress PDS from within Edit        *   FILE 357\n//*       CONBLANK -- Consolidate 2 or more blank lines to one      *   FILE 357\n//*       CONCATDD -- Concatenate a data set to a DD                *   FILE 357\n//*       COPYCOLS -- Copy column data                              *   FILE 357\n//*       COPYINS  -- Copy and insert column data                   *   FILE 357\n//*       COUNTX   -- Show record count from DS List (ISPF 3.4)     *   FILE 357\n//*                   for sequential or VSAM files                  *   FILE 357\n//*       COUNTXNX -- Count excluded and included lines             *   FILE 357\n//*       CU       -- Insert IEFBR14 data set clean up JCL          *   FILE 357\n//*       CUD      -- Dynamically insert data set clean up JCL      *   FILE 357\n//*       CUTX     -- Tweaked cut type macro                        *   FILE 357\n//*       CVB      -- Convert display numeric to binary             *   FILE 357\n//*       CVD      -- Convert binary to display numeric             *   FILE 357\n//*       C2H      -- Convert characters to hex equivalent          *   FILE 357\n//*       DELBLANK -- Delete blank lines                            *   FILE 357\n//*       DELCOLS  -- Delete column data                            *   FILE 357\n//*       DELDUPS  -- Sort file and delete duplicate lines          *   FILE 357\n//*       DELDUPX  -- Delete contiguous duplicate lines             *   FILE 357\n//*       DELPARA  -- Delete debug lines from DISPARA & DISPVAR     *   FILE 357\n//*       DESC     -- Macro to show LRECL, BLKSIZE and count        *   FILE 357\n//*       DETAB    -- Restructure tabbed file                       *   FILE 357\n//*       DETAB$   -- JCL for DETAB                                 *   FILE 357\n//*       DIRLIST  -- Hex list of a directory separating each member*   FILE 357\n//*       DIRLIST$ -- JCL for DIRLIST                               *   FILE 357\n//*       DIRSCNC  -- COBOL directory generator                     *   FILE 357\n//*       DIRSCNC$ -- JCL for DIRSCNC                               *   FILE 357\n//*       DIRSCNQ  -- PL/I directort generator                      *   FILE 357\n//*       DIRSCNQ$ -- JCL for DIRSCNQ                               *   FILE 357\n//*       DISPARA  -- Add DISPLAY at start of every paragraph       *   FILE 357\n//*       DISPDSN  -- Reverse DSN=...,DISP=SHR to DISP=SHR,DSN=...  *   FILE 357\n//*       DISPVAR  -- Add DISPLAY line for variable under cursor    *   FILE 357\n//*       DYNA     -- Sample dynamic allocator using MACSDYNA       *   FILE 357\n//*       DYNAMC   -- Sample COBOL dynamic allocation using BPXWDYN *   FILE 357\n//*       DYNAMP   -- Sample PL/I dynamic allocation using BPXWDYN  *   FILE 357\n//*       DYNCOB   -- Sample COBOL dynamic allocation using DYNA    *   FILE 357\n//*       DYNF     -- Sample dynamic free using MACSDYNA            *   FILE 357\n//*       DYNI     -- Sample dynamic internal reader using MACSDYNA *   FILE 357\n//*       DYNN     -- Sample dynamic allocation using MACSDYNA      *   FILE 357\n//*       DYNPLIA  -- Sample PL/I dynamic allocation using DYNA     *   FILE 357\n//*       DYNPLII  -- Sample PL/I dynamic internal reader using DYNA*   FILE 357\n//*       DYNPLIN  -- Sample PL/I dynamic allocation using DYNA     *   FILE 357\n//*       DYNPLIS  -- Sample PL/I dynamic SYSOUT using DYNA         *   FILE 357\n//*       DYNS     -- Sample dynamic SYSOUT using MACSDYNA          *   FILE 357\n//*       EMPTY    -- Remove data from DS List sequential or PDS    *   FILE 357\n//*       EMPTYCK$ -- Use IDCAMS to set return code indicating      *   FILE 357\n//*                   whether a dataset is really empty             *   FILE 357\n//*       ENC      -- Simple encryption macro                       *   FILE 357\n//*       ENC2     -- Improved ENC encryption macro                 *   FILE 357\n//*       EZCKGRDT -- Easytrieve Gregorian daet check               *   FILE 357\n//*       EZCKJUDT -- Easytrieve Julian date check                  *   FILE 357\n//*       EZCL     -- Easytrieve link sample                        *   FILE 357\n//*       EZCOPY   -- Easytrieve simple copy                        *   FILE 357\n//*       EZCOUNT  -- Easytrieve record count                       *   FILE 357\n//*       EZGENRPT -- Easytrieve sample most options                *   FILE 357\n//*       EZPARM   -- Easytrieve sample PARM usage                  *   FILE 357\n//*       EZSTRSK  -- Easytrieve string search using STRSRCH macro  *   FILE 357\n//*       EZUNPK   -- Easytrieve unpack sample                      *   FILE 357\n//*       FALT     -- Dummy macro to allow repeat of FN, FGE, etc   *   FILE 357\n//*       FAND     -- Show lines with all specified strings         *   FILE 357\n//*       FEXC     -- Find the next excluded line                   *   FILE 357\n//*       FGE      -- Find line with value greater then some value  *   FILE 357\n//*       FGT      -- Find line with value greater then or equal    *   FILE 357\n//*       FILLCOLS -- Overlay data columns with string              *   FILE 357\n//*       FILLINS  -- Insert string into data columns               *   FILE 357\n//*       FINDDUPS -- Sort and show duplicate lines                 *   FILE 357\n//*       FINDDUPX -- Show duplicate lines                          *   FILE 357\n//*       FINDNSTR -- Do SuperC in DS List for members w/o string   *   FILE 357\n//*       FINDSTRX -- Do SuperC in DS List for members w/ string    *   FILE 357\n//*       FLAGREVS -- Show which lines of a member changed in Edit  *   FILE 357\n//*                   before saving                                 *   FILE 357\n//*       FLE      -- Find line with value less then some value     *   FILE 357\n//*       FLT      -- Find line with value less then or equal       *   FILE 357\n//*       FMAX     -- Find largest value in some columns            *   FILE 357\n//*       FMDOUBLE -- COBOL convert float to display for Easytrieve *   FILE 357\n//*       FMIN     -- Find smallest value in some columns           *   FILE 357\n//*       FN       -- Repeatable find of line with value not        *   FILE 357\n//*       FNB      -- Find non blank values                         *   FILE 357\n//*       FNOT     -- Show lines with none of given strings         *   FILE 357\n//*       FOG      -- Random text generator                         *   FILE 357\n//*       FOR      -- Show lines with any of the given strings      *   FILE 357\n//*       FOREVER  -- Generate job to \"touch\" list of data sets     *   FILE 357\n//*       FOREVERX -- Sample EXEC to \"touch\" list of data sets      *   FILE 357\n//*       FORMCOLS -- Reformat arithmetic data using a format       *   FILE 357\n//*       FPEND    -- Find the lines with a pending prefix command  *   FILE 357\n//*       FREE     -- Dynamic allocation macro                      *   FILE 357\n//*       FS       -- Submit PDS scan for string macro              *   FILE 357\n//*       FX       -- Exclude all except lines with string          *   FILE 357\n//*       GATHERX  -- Pull all excluded lines together              *   FILE 357\n//*       GETDSN   -- Routine to get data set name from COBOL       *   FILE 357\n//*       GETDSNS  -- Paste wildcard list of data sets into file    *   FILE 357\n//*       GETGDGS  -- Generate GDG list or DD images                *   FILE 357\n//*       GETMEMS  -- Generate selected member list after cursor    *   FILE 357\n//*       GETRGNSZ -- Show TSO region size                          *   FILE 357\n//*       GMT      -- Show Greenwich offset to local time           *   FILE 357\n//*       HEXDUMP  -- Dump data in hex/character format as logical  *   FILE 357\n//*                   records                                       *   FILE 357\n//*       HEXDUMP$ -- JCL for HEXDUMP                               *   FILE 357\n//*       HEXUDUM  -- Dump data in hex/character format as          *   FILE 357\n//*                   unformatted records                           *   FILE 357\n//*       HEXUDUM$ -- JCL for HEXUDUMP                              *   FILE 357\n//*       HEXUIDC$ -- IDCAMS PRINT DUMP sample                      *   FILE 357\n//*       HOWLONG  -- Show the larget and smallest record size      *   FILE 357\n//*       HSMDOC   -- Quick reference to HSM commands               *   FILE 357\n//*       H2C      -- Hex to character equivalent macro converter   *   FILE 357\n//*       IE       -- Insert COBOL code for EVALUATE structure      *   FILE 357\n//*       IEZBITS  -- IBM bit equivalence assembler macro           *   FILE 357\n//*       II       -- Insert COBOL code for IF/ELSE/END-IF structure*   FILE 357\n//*       IP       -- Insert COBOL code for PERFORM structure       *   FILE 357\n//*       IPADDR   -- Get IP address                                *   FILE 357\n//*       IS       -- Insert COBOL code for SEARCH structure        *   FILE 357\n//*       ISA      -- Insert COBOL code for SEARCH ALL structure    *   FILE 357\n//*       ISORT    -- Insert COBOL code for Sort JCL                *   FILE 357\n//*       IST      -- Insert COBOL code for STRING structure        *   FILE 357\n//*       JB       -- Jump back to PERFORM statement                *   FILE 357\n//*       JC       -- Insert job card at front of file              *   FILE 357\n//*       JOBINFO  -- COBOL sample grabbing job information from    *   FILE 357\n//*                   control tables                                *   FILE 357\n//*       JOINCOLS -- Join columns with Edit macro                  *   FILE 357\n//*       JT       -- Jump to paragraph being PERFORMed             *   FILE 357\n//*       KEEPCOLS -- Keep specified columns, deleting others       *   FILE 357\n//*       LASTREF  -- Show the last reference date in DS List       *   FILE 357\n//*       LESS     -- Exclude additional lines                      *   FILE 357\n//*       LJUST    -- Left justify text                             *   FILE 357\n//*       LKDT     -- Show link date                                *   FILE 357\n//*       LMODWU   -- Load module where used                        *   FILE 357\n//*       LMODWU$  -- JCL for LMODWU                                *   FILE 357\n//*       LMODXRF  -- Load module cross reference                   *   FILE 357\n//*       LMODXRF$ -- JCL for LMODXRF                               *   FILE 357\n//*       LONGEST  -- Show the longest line                         *   FILE 357\n//*       MACSDYNA -- Dynamic allocation macros (many)              *   FILE 357\n//*       MORE     -- Unexclude additional lines                    *   FILE 357\n//*       MOVECOLD -- Move column data deleting original columns    *   FILE 357\n//*       MOVECOLS -- Move column data                              *   FILE 357\n//*       MOVEINS  -- Move and insert column data                   *   FILE 357\n//*       MOVEINSD -- Insert column data and delete original data   *   FILE 357\n//*       NEATJCL  -- Format JCL                                    *   FILE 357\n//*       NEW      -- Allocate a sequential file                    *   FILE 357\n//*       NEWP     -- Allocate a PDS                                *   FILE 357\n//*       NUMCOLS  -- Place numbers in specific columns             *   FILE 357\n//*       NUMCOLS0 -- Place zero padded numbers in specific         *   FILE 357\n//*       OPCODE   -- Describe instruction associated with          *   FILE 357\n//*       PA       -- PASTEAFT equivalent for IBM CUT/PASTE commands*   FILE 357\n//*       PACKDS   -- Compress file using IBM TRSMAIN               *   FILE 357\n//*       PAGES    -- Select pages from large sequential carriage   *   FILE 357\n//*       PAGES$   -- Sample JCL for PAGES                          *   FILE 357\n//*       PASTEAFT -- Copy CUTX lines after one or more lines       *   FILE 357\n//*       PASTEX   -- A paste variation                             *   FILE 357\n//*       PASTY    -- Do PASTEX with a PF Key                       *   FILE 357\n//*       PDSGEN   -- Generate data with member/data set tokens     *   FILE 357\n//*       PDSGEN$  -- JCL for PDSGEN                                *   FILE 357\n//*       PDSLIST  -- List concatenated PDS's of any record format  *   FILE 357\n//*       PDSLIST$ -- JCL for PDSLIST                               *   FILE 357\n//*       PDSMATC  -- Generate SUPERC compares for unequal PDSMATCH *   FILE 357\n//*                   members                                       *   FILE 357\n//*       PDSMATC$ -- JCL for PDSMATCH                              *   FILE 357\n//*       PDSMATC@ -- JCL for PDSMATCH and PDSMATC                  *   FILE 357\n//*       PDSMATCH -- Match 2 PDS's by name, statistics or data     *   FILE 357\n//*                   (Updated to fix a bug. False equal if more    *   FILE 357\n//*                    data was in the second file. - 12/2015)      *   FILE 357\n//*                   (Second bug. Null members compared not equal) *   FILE 357\n//*                   (Fix to do multiple GETMAINs that will        *   FILE 357\n//*                    accommodate a directory of any size.)        *   FILE 357\n//*                   (Fix to solve RECFM=VB problem.)              *   FILE 357\n//*       PDSPUNC$ -- JCL for PDSPUNCH                              *   FILE 357\n//*       PDSPUNCH -- Make an IEBUPDTE ADD/REPL file of             *   FILE 357\n//*       PDS2SEQ  -- Put PDS members into sequential file          *   FILE 357\n//*       PK       -- Pack numbers (into COMP-3 format)             *   FILE 357\n//*       PULL     -- Select 1 or more sets of records from any     *   FILE 357\n//*       PULL$    -- Sample JCL for PULL                           *   FILE 357\n//*       PY       -- Equivalent of PASTY for IBM CUT/PASTE         *   FILE 357\n//*       QCLONE   -- Submit of CLONE equivalent job                *   FILE 357\n//*       QCLONER  -- Submit of CLONER equivalent job               *   FILE 357\n//*       RANCOLS  -- Generate random numbers into specific         *   FILE 357\n//*       RANCOLS0 -- Generate zero padded random numbers into      *   FILE 357\n//*       REALUNIQ -- Find only really unique lines with sort       *   FILE 357\n//*       REALUNIX -- Find only really unique lines with out sort   *   FILE 357\n//*       REGS     -- Assembler register naming generator           *   FILE 357\n//*       RENTER   -- Assembler reenterable prologue macro          *   FILE 357\n//*       REVERSEX -- Reverse line order                            *   FILE 357\n//*       REXIT    -- Assembler reenterable exit macro              *   FILE 357\n//*       RJUST    -- Right justify text                            *   FILE 357\n//*       SAVEINPL -- Save edited member in place                   *   FILE 357\n//*       SCANPDS  -- Simple SuperC example                         *   FILE 357\n//*       SCANPDSX -- SuperC with options shown                     *   FILE 357\n//*       SETRC    -- Set return code for MVS COND checking         *   FILE 357\n//*       SETRC$   -- Sample JCL for SETRC                          *   FILE 357\n//*       SHIFT    -- Shift columns                                 *   FILE 357\n//*       SHORTEST -- Find shortest line                            *   FILE 357\n//*       SHUFFLE  -- Randomize line order                          *   FILE 357\n//*       SLEEP    -- Pause for # seconds                           *   FILE 357\n//*       SMARTGN  -- Generate control cards from list              *   FILE 357\n//*       SMARTGN$ -- Sample JCL for SMARTGN                        *   FILE 357\n//*       SNACK    -- Exclude all but lines w/ variable under       *   FILE 357\n//*                   cursor                                        *   FILE 357\n//*       SORTNX   -- Sort non excluded lines keeping the excluded  *   FILE 357\n//*       SORTX    -- Documented sample sort controls               *   FILE 357\n//*       SPLITAFT -- Split selected lines after given string       *   FILE 357\n//*       SPLITON  -- Split selected lines at given string          *   FILE 357\n//*       SPLTCOLS -- Split one line into several                   *   FILE 357\n//*       SQUSH    -- Eliminate multiple blanks                     *   FILE 357\n//*       STEMSRT1 -- REXX stem sort via quick sort w/ timings      *   FILE 357\n//*       STEMSRT2 -- REXX stem sort via shell sort w/ timings      *   FILE 357\n//*       STEMSRT3 -- REXX stem sort via call to sort w/ timings    *   FILE 357\n//*       STOWR    -- Save member directory information routine     *   FILE 357\n//*       STOWU    -- Null member directory information routine     *   FILE 357\n//*       STRING   -- Gilbert's assembler DISPLAY macro             *   FILE 357\n//*       STRING$  -- Sample JCL using STRING                       *   FILE 357\n//*       STRING#  -- Documentation for STRING                      *   FILE 357\n//*       STRSRCH  -- Easytrieve string search macro                *   FILE 357\n//*       STRSRCH# -- Documentation for STRSRCH                     *   FILE 357\n//*       STRUCT   -- Show program structure (COBOL, EZTrieve,      *   FILE 357\n//*       SUBCAN   -- Submit job and cancel edit session            *   FILE 357\n//*       SUBO     -- Submit job with substituted variables with    *   FILE 357\n//*                   ORIGIN as default                             *   FILE 357\n//*       SUBX     -- Submit job with substituted variables         *   FILE 357\n//*       SUFFLINE -- Add suffix to selected lines                  *   FILE 357\n//*       SUMCOLS  -- Sum columns                                   *   FILE 357\n//*       SYSI     -- Show some TSO parameters                      *   FILE 357\n//*       TD       -- Remove directory statistics                   *   FILE 357\n//*       TERSE$   -- IBM compression sample                        *   FILE 357\n//*       TODAY    -- Show variations of a given date               *   FILE 357\n//*       TOUCH    -- Change any ISPF statistics from batch         *   FILE 357\n//*       TOUCH$   -- JCL for TOUCH                                 *   FILE 357\n//*       TRAP     -- Macro to trap output of TSO command           *   FILE 357\n//*       TSJ      -- Do text split and join via PF Key             *   FILE 357\n//*       TU       -- Update directory statistics                   *   FILE 357\n//*       T1       -- Start macro timing                            *   FILE 357\n//*       T2       -- Stop and display macro timing                 *   FILE 357\n//*       UNIQUE   -- Sort and show unique lines                    *   FILE 357\n//*       UNIQUEX  -- Show unique lines                             *   FILE 357\n//*       UNPACKDS -- Decompress file using IBM TRSMAIN             *   FILE 357\n//*       UNPK     -- Turn packed data into displayable data        *   FILE 357\n//*       UNTOUCH  -- Eliminate any ISPF statistics from batch      *   FILE 357\n//*       UNTOUCH$ -- JCL for UNTOUCH                               *   FILE 357\n//*       VALUES   -- Summarize actual content of 1 or more sets of *   FILE 357\n//*       VALUES$  -- JCL for VALUES                                *   FILE 357\n//*       VERASE   -- Reset CUTX lines in Profile                   *   FILE 357\n//*       VSAVE    -- Save file under View                          *   FILE 357\n//*       VW       -- View file                                     *   FILE 357\n//*       VWV      -- Gather and View part of VSAM file             *   FILE 357\n//*       WAIT     -- Batch sleep routine                           *   FILE 357\n//*       WAIT$    -- Gather and View part of VSAM file             *   FILE 357\n//*       XALLMEM  -- Execute EXEC against another PDS              *   FILE 357\n//*       XCOPY    -- Copy outside data source from command line    *   FILE 357\n//*       XINDENT  -- Exclude to line with same indentation         *   FILE 357\n//*       ZVW      -- View file under cursor                        *   FILE 357\n//*                                                                 *   FILE 357\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@LOADLIB": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x1241:1:\\x00\\x00\\xd3\\xd6\\xc1\\xc4\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 12602, "newlines": 12602, "modlines": 0, "user": "LOADLIB"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "@MACDOC#": {"ttr": 5892, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x18i\\x18i\\x00\\x00\\xc4\\xd6\\xc3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 6249, "newlines": 6249, "modlines": 0, "user": "DOC"}, "text": "\n-\n-\n-\n-\n-\n-\n-\n                                       TSO\n                                  Productivity\n                                   Extensions\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n June 15, 2004                                          Freeware from Steli Inc.\n1                          TABLE OF CONTENTS                         Page      2\n\n\n Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     6\n\n\n Known Problems  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     7\n\n\n Gaining Execution Access  . . . . . . . . . . . . . . . . . . . . . . . .     8\n\n\n Column Manipulation Macros  . . . . . . . . . . . . . . . . . . . . . . .    10\n\n    COPYCOLS . Copy Columns Onto Other Columns . . . . . . . . . . . . . .    10\n    COPYINS  . Copy Columns Inserting Before Other Columns . . . . . . . .    10\n    CVB  . . . Convert Numeric Display Data to Binary. . . . . . . . . . .    11\n    CVD  . . . Convert Binary Data to Numeric Display Data . . . . . . . .    12\n    C2H  . . . Convert Hex Characters to Hex Equivalent. . . . . . . . . .    14\n    DELCOLS  . Delete Columns. . . . . . . . . . . . . . . . . . . . . . .    15\n    FILLCOLS . Overlay Columns with a Given String . . . . . . . . . . . .    15\n    FILLINS  . Insert a Given String Before a Column . . . . . . . . . . .    16\n    FORMCOLS . Format Numeric Display Data Using Picture Format. . . . . .    17\n    H2C  . . . Convert Characters to Their Hex Equivalent. . . . . . . . .    18\n    JOINCOLS . Concatenate Lines at Given Columns. . . . . . . . . . . . .    19\n    KEEPCOLS . Retain Columns Deleting All Other Columns . . . . . . . . .    19\n    MOVECOLD . Move Columns Overlaying Destination and Deleting Source . .    20\n    MOVECOLS . Move Columns Overlaying Other Columns . . . . . . . . . . .    21\n    MOVEINS  . Move Columns Inserting Before Other Columns . . . . . . . .    21\n    MOVEINSD . Move & Delete Columns Inserting Before Other Cols . . . . .    22\n    NUMCOLS  . Place Sequential Numbers in Columns . . . . . . . . . . . .    23\n    NUMCOLS0 . Place Zero Padded Numbers in Columns. . . . . . . . . . . .    23\n    PK . . . . Pack Numeric Display Data . . . . . . . . . . . . . . . . .    24\n    RANCOLS  . Generate Pseudo Random Numbers. . . . . . . . . . . . . . .    25\n    RANCOLS0 . Generate Zero Padded Pseudo Random Numbers. . . . . . . . .    26\n    SHIFT  . . Shift Data. . . . . . . . . . . . . . . . . . . . . . . . .    26\n    SPLTCOLS . Split Lines at Given Columns. . . . . . . . . . . . . . . .    27\n    SUMCOLS  . Add Data Arithmetically Within Given Columns. . . . . . . .    29\n    UNPK . . . Unpack Data into Numeric Display Form . . . . . . . . . . .    29\n\n Display Control Macros  . . . . . . . . . . . . . . . . . . . . . . . . .    31\n\n    COUNTXNX . Display Number of Unexcluded / Excluded Lines . . . . . . .    31\n    FALT . . . Pseudo Repeat Function for Certain Find's . . . . . . . . .    31\n    FAND . . . Display Lines With All Specified Values . . . . . . . . . .    32\n    FEXC . . . Find Next Excluded Line . . . . . . . . . . . . . . . . . .    32\n    FGE  . . . Find Value Greater Than or Equal. . . . . . . . . . . . . .    32\n    FGT  . . . Find Value Greater Than . . . . . . . . . . . . . . . . . .    32\n    FINDDUPX . Display Contiguous Duplicate Lines. . . . . . . . . . . . .    33\n    FLE  . . . Find Value Less Than or Equal . . . . . . . . . . . . . . .    34\n    FLT  . . . Find Value Less Than. . . . . . . . . . . . . . . . . . . .    34\n    FMAX . . . Find the Largest Value. . . . . . . . . . . . . . . . . . .    34\n    FMIN . . . Find the Smallest Value . . . . . . . . . . . . . . . . . .    35\n    FN . . . . Find a Value Not Equal. . . . . . . . . . . . . . . . . . .    35\n    FNB  . . . Find Non Blank Values . . . . . . . . . . . . . . . . . . .    36\n    FNOT . . . Display Lines With None of Specified Values . . . . . . . .    36\n1                    TABLE OF CONTENTS (Continued)                   Page      3\n\n    FOR  . . . Display Lines With Any of Specified Values. . . . . . . . .    37\n    FPEND  . . Find Line With Pending Prefix Command . . . . . . . . . . .    37\n    FX . . . . Exclude Everything and Show Only those Lines Found. . . . .    37\n    LESS . . . Exclude Additional Lines Around Excluded Lines. . . . . . .    38\n    LONGEST  . Find the Longest Line . . . . . . . . . . . . . . . . . . .    39\n    MORE . . . Unexclude Additional Lines Around Excluded Lines. . . . . .    39\n    REALUNIX . Show Contiguous Lines With No Duplicate Values. . . . . . .    40\n    SHORTEST . Find the Shortest Line. . . . . . . . . . . . . . . . . . .    41\n    SNACK  . . Display Only Lines Containing the Field the Cursor is On. .    41\n    UNIQUEX  . Show Contiguous Uniquely Valued Lines . . . . . . . . . . .    42\n\n Line Manipulation Macros  . . . . . . . . . . . . . . . . . . . . . . . .    43\n\n    CONBLANK . Consolidate Blank Lines . . . . . . . . . . . . . . . . . .    43\n    DELBLANK . Delete Blank Lines. . . . . . . . . . . . . . . . . . . . .    43\n    DELDUPS  . Sort and Delete All Duplicate Lines . . . . . . . . . . . .    43\n    DELDUPX  . Delete Contiguous Duplicate Lines . . . . . . . . . . . . .    44\n    FINDDUPS . Display All Duplicate Lines . . . . . . . . . . . . . . . .    45\n    GATHERX  . Collect All Excluded Lines. . . . . . . . . . . . . . . . .    46\n    REALUNIQ . Sort and Show Lines With No Duplicate Values. . . . . . . .    46\n    REVERSEX . Reverse Lines . . . . . . . . . . . . . . . . . . . . . . .    47\n    SHUFFLE  . Provide Random Line Re-arrangement. . . . . . . . . . . . .    48\n    SORTNX . . Sort Unexcluded Lines Keeping With Excluded Lines . . . . .    48\n    UNIQUE . . Show All Uniquely Valued Lines. . . . . . . . . . . . . . .    49\n\n Code/Data Manipulation Macros   . . . . . . . . . . . . . . . . . . . . .    51\n\n    ALIGN  . . Align Text at Character(s) Specified. . . . . . . . . . . .    51\n    ALIGNALL . Align All Text at Character(s) Specified. . . . . . . . . .    51\n    ALIGNAX  . Align All Text at Character(s) Specified Removing Delimit .    52\n    ALIGNS . . Align Text at Character(s) Specified Minimizing Blanks. . .    53\n    BC . . . . Blank Selected Columns. . . . . . . . . . . . . . . . . . .    54\n    COBCOLO  . Put COBOL Offsets in Columns 73 to 80 . . . . . . . . . . .    54\n    COBCOLS  . Put COBOL Offsets in Columns 73 to 80 . . . . . . . . . . .    55\n    COBCOLV  . View FileAid/InSync Layout of COBOL Data Structure. . . . .    55\n    DELPARA  . Deletes COBOL DISPLAY Statements from DISPARA & DISPVAR . .    57\n    DISPARA  . Insert COBOL DISPLAY at Each Paragraph. . . . . . . . . . .    57\n    DISPVAR  . Insert a DISPLAY for the Variable at the Cursor . . . . . .    57\n    IE . . . . Adds a COBOL EVALUATE Structure Following the Cursor. . . .    58\n    II . . . . Adds a COBOL IF Structure Following the Cursor. . . . . . .    59\n    IP . . . . Adds a COBOL PERFORM Structure Following the Cursor . . . .    59\n    IS . . . . Adds a COBOL SEARCH Structure Following the Cursor. . . . .    59\n    ISA  . . . Adds a COBOL SEARCH ALL Structure Following the Cursor. . .    60\n    IST  . . . Adds a COBOL STRING Structure Following the Cursor. . . . .    60\n    JB . . . . Jump Back to PERFORM Statement. . . . . . . . . . . . . . .    61\n    JT . . . . Jump to PERFORMed Paragraph or View Copybook. . . . . . . .    61\n    SPLITAFT . Split Lines After the String Specified. . . . . . . . . . .    61\n    SPLITAT  . Split Lines On a Specified String . . . . . . . . . . . . .    62\n    STRUCT . . Show Significant Structural Code Elements . . . . . . . . .    62\n    SUFFLINE . Append a String to the End of Selected Line(s). . . . . . .    65\n    XINDENT  . Exclude to Similarly Indented Line. . . . . . . . . . . . .    66\n\n JCL Manipulation Macros   . . . . . . . . . . . . . . . . . . . . . . . .    68\n\n1                    TABLE OF CONTENTS (Continued)                   Page      4\n\n    CU . . . . Add Clean Up IEFBR14 JCL after Cursor Position. . . . . . .    68\n    CUD  . . . Dynamically Add Clean Up IEFBR14 JCL after Cursor . . . . .    68\n    CHDEL  . . Dynamically Add HDELETE JCL after Cursor. . . . . . . . . .    69\n    DISPDSN  . Place DSN Value after DISP=SHR. . . . . . . . . . . . . . .    70\n    GETDSNS  . Paste a List of Cataloged Data Sets after Cursor. . . . . .    70\n    GETGDGS  . Paste a List of Cataloged GDG Names after Cursor. . . . . .    71\n    GETMEMS  . Retrieve List of Member Names after the Cursor. . . . . . .    72\n    ISORT  . . Insert a Sort Step Immediately After the Cursor Position. .    72\n    JC . . . . Insert a Job Card at the Top of the File Being Edited . . .    73\n    NEATJCL  . Neaten JCL. . . . . . . . . . . . . . . . . . . . . . . . .    74\n    SUBCAN . . Submit File and Cancel Edit Session . . . . . . . . . . . .    75\n    SUBO . . . Substitute Date/Time/User Variables and Submit Job. . . . .    75\n    SUBX . . . Substitute Date/Time/User Variables and Submit Job. . . . .    77\n\n Format Control Macros   . . . . . . . . . . . . . . . . . . . . . . . . .    80\n\n    ADDFLAG  . Place a Flag Value on Selected Lines. . . . . . . . . . . .    80\n    CENTER . . Justify Data to Center. . . . . . . . . . . . . . . . . . .    80\n    FLAGREVS . Flag Revisions. . . . . . . . . . . . . . . . . . . . . . .    80\n    LJUST  . . Justify Data to Left. . . . . . . . . . . . . . . . . . . .    81\n    RJUST  . . Justify data to Right . . . . . . . . . . . . . . . . . . .    81\n    SQUSH  . . Remove Extraneous Blanks From Data. . . . . . . . . . . . .    82\n\n Inter/Intra Dataset Macros  . . . . . . . . . . . . . . . . . . . . . . .    83\n\n    CUTX . . . Place Lines Into Profile for Pasting. . . . . . . . . . . .    83\n    PA . . . . Copy Lines From Default Clipcoard Into Multiple Places. . .    84\n    PASTEAFT . Copy Lines From Profile Into Multiple Places. . . . . . . .    85\n    PASTEX . . Copy Lines From Profile . . . . . . . . . . . . . . . . . .    86\n    PY . . . . Copy Lines From Default Clipboard by Cursor Position. . . .    86\n    PASTY  . . Copy Lines From Profile by Cursor Position. . . . . . . . .    86\n    VERASE . . Clear Profile Pool CUTX Entries & Zero CutCnt . . . . . . .    87\n    XCOPY  . . Retrieve Data Into File From Command Line . . . . . . . . .    87\n\n DSList Macros   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    88\n\n    CLONE  . . Duplicate Sequential or Partitioned Data Set. . . . . . . .    88\n    CLONER . . Copy/Replace Sequential or Partitioned Data Set . . . . . .    90\n    COUNTX . . Provide Count of Records in File. . . . . . . . . . . . . .    91\n    DELCOLS  . Delete Columns. . . . . . . . . . . . . . . . . . . . . . .    92\n    EMPTY  . . Null Sequential or Partitioned Data Set . . . . . . . . . .    92\n    FINDNSTR . Scan a PDS For Members Without a Given String . . . . . . .    93\n    FINDSTRX . Scan a PDS For a Given String . . . . . . . . . . . . . . .    94\n    HOWLONG  . Show Longest and Shortest Lengths . . . . . . . . . . . . .    94\n    KEEPCOLS . Retain Columns Deleting All Other Columns . . . . . . . . .    95\n    LASTREF  . Display Last Reference Date under DS List . . . . . . . . .    95\n    QCLONE . . Duplicate Sequential or Partitioned Data Set via Job. . . .    96\n    QCLONER  . Copy/Replace Sequential or Partitioned Data Set via Job . .    98\n\n Member List Macros  . . . . . . . . . . . . . . . . . . . . . . . . . . .   100\n\n    LKDT . . . Display When a Load Module Was Linked . . . . . . . . . . .   100\n    TD . . . . Display and Remove Member Statistics. . . . . . . . . . . .   100\n    TU . . . . Display and Update Member Statistics. . . . . . . . . . . .   101\n1                    TABLE OF CONTENTS (Continued)                   Page      5\n\n\n Miscellaneous Macros  . . . . . . . . . . . . . . . . . . . . . . . . . .   103\n\n    ADDLINES . Copy a Member Before/After All Other Members. . . . . . . .   103\n    ALLMEM . . Execute a Macro Against All Members . . . . . . . . . . . .   103\n    ALLOCGDX . Allocate a Relative GDG as an Absolute Data Set . . . . . .   104\n    BS . . . . Determine Optimal Block Size. . . . . . . . . . . . . . . .   104\n    CC . . . . Provide Simple Calculator Functions . . . . . . . . . . . .   105\n    CLS  . . . Clear the TSO Screen. . . . . . . . . . . . . . . . . . . .   105\n    COMPRS . . Compress a PDS Under Edit or From Outside . . . . . . . . .   105\n    CONCATDD . Add Files to an Allocation. . . . . . . . . . . . . . . . .   106\n    DESC . . . Briefly Describe File from Within Edit/View . . . . . . . .   106\n    ENC  . . . Provide Simple Password Protection for Data . . . . . . . .   106\n    ENC2 . . . Provide Improved Simple Password Protection for Data. . . .   107\n    FOG  . . . Produce Sentences of Meaningless Text . . . . . . . . . . .   107\n    FS . . . . Submit a Job to Scan a PDS(E) for a String. . . . . . . . .   108\n    NEW  . . . Allocate a New Sequential File. . . . . . . . . . . . . . .   108\n    NEWP . . . Allocate a New Partitioned Data Set . . . . . . . . . . . .   109\n    OPCODE . . Describe a Machine Operation Code . . . . . . . . . . . . .   110\n    PACKDS . . Compress a File using IBM's TRSMAIN . . . . . . . . . . . .   110\n    PDS2SEQ  . Unload a PDS to a Sequential File . . . . . . . . . . . . .   110\n    SAVEINPL . Save a Member in Place. . . . . . . . . . . . . . . . . . .   111\n    SLEEP  . . Pause for Given Number of Seconds . . . . . . . . . . . . .   111\n    TODAY  . . Provide Variations of Given Date. . . . . . . . . . . . . .   111\n    TSJ  . . . Split/Join Line at Cursor . . . . . . . . . . . . . . . . .   111\n    UNPACKDS . Decompress a File using IBM's TRSMAIN . . . . . . . . . . .   112\n    VSAVE  . . Save File or Member from within VIEW. . . . . . . . . . . .   112\n    VWV  . . . Extract and View All or Part of a VSAM File . . . . . . . .   112\n    XALLMEM  . Execute Macro Against Every PDS Member from Outside . . . .   113\n    ZVW  . . . View Data Set Under Cursor. . . . . . . . . . . . . . . . .   113\n\n Things You May Never Want to Do   . . . . . . . . . . . . . . . . . . . .   114\n\n1                            Introduction                            Page      6\n\n\n This document is intended to provide user information for the\n OS/390 and z/OS MVS freeware REXX and CLIST macros included in\n this package.  Some understanding of the operating system, TSO,\n and ISPF Edit, View and DS List is required.\n\n These are freeware macros which have been gathered together to\n provide consistent, proven and documented tools to:\n\n    - reduce key strokes\n\n    - improve visualization\n\n    - eliminate custom coding to accomplish a task\n\n    - automate a calculation\n\n In other words, they're intended to help improve mainframe user\n productivity.  These macros extend various ISPF capabilities to:\n\n    - Manipulate columns of data\n\n    - Convert data\n\n    - Manipulate code\n\n    - Manipulate JCL\n\n    - Display (include/exclude) data differently\n\n    - Consolidate data\n\n    - Format data\n\n    - Find data differently\n\n These tools were created by Steli or modified from source made\n available by others.  Names were chosen as seemed appropriate\n but nothing prevents changing them to other, hopefully more\n meaningful ones.  Steli has made its best effort to provide\n working, tested code.  However, nothing is perfect - there may\n be flaws due to oversights, system variations, or errors, and\n there certainly could be improvements.  All questions, concerns,\n problems and suggestions are welcome; e-mail may be sent to\n C_Hafner@HotMail.Com.\n\n Particular thanks for assistance, encouragement, (good) ideas\n and sample code go to Dave Alcock, Larry Dick, Hugh Mitchell,\n Jim Moore, Doug Nadel, Richard Rubin, Gilbert StFlour and Mark\n Zelden.\n\n\n1                           Known Problems                           Page      7\n\n\n The COBCOLO and COBCOLS macros using InSync and FileAid do not\n always complete correctly when REDEFINES or OCCURS are present.\n We have been working to eliminate these glitches but we may not\n have them all corrected. OCCURS within OCCURS definitely\n presents a challenge. COBCOLV, the direct call to InSync or\n FileAid obviously functions correctly.\n\n TSO apparently does not have a generic clear screen function\n that exists on every (or most) systems.  The function used\n throughout many macros herein is:\n\n    ADDRESS TSO \"CLEAR\"\n\n It is always written exactly as shown!  This may not work at\n your site depending on how/what the systems folks have set up.\n If need be, I'd suggest using ALLMEM (and ALLMEMC with the\n appropriate change command) to either comment the statement out\n or replace it with the call shown in the following paragraph.\n\n The same CBT Tape File 357 that contains this macro package also\n contains an assembler clear screen program that appears to be\n universal. The program is called CLRSCRN and would be invoked in\n place of the above as :\n\n       \"CALL 'YOUR.LOAD.MODULE.LIB(CLRSCRN)'\"\n\n We have also been told many of the macros run slowly as the\n edited data sizes grow. We can only suggest running them in\n batch to alleviate this. As time permits, we will review all of\n the macros again trying to improve their performance.\n\n\n1                      Gaining Execution Access                      Page      8\n\n\n To use these macros, you may add a library (a Partitioned Data\n Set or Partitioned Data Set Extended) with those macros to your\n SYSPROC DD under TSO or place the macros in an existing library\n already in the SYSPROC concatenation.  Use TSO ISRDDN to check\n the DD files associated with your TSO LOGON.  For the latter,\n simply copy the members you want into an existing library\n (please note these macros are in fixed record format of 80 bytes\n - they will not play nicely with VB/255 libraries).  The\n CONCATDD macro will help do the former.  Assuming that you've\n loaded them to your own library and they're in YOURID.CLIST,\n execute under the TSO command option:\n\n      EX 'YOURID.CLIST(CONCATDD)' 'SYSPROC YOURID.CLIST'\n\n There are a few CLISTs in this collection so I've always\n concatenated my library to the front of SYSPROC rather then to\n SYSEXEC.  I have also seen problems when trying to concatenate\n to SYSEXEC from within certain LOGON EXEC's (EXEC's specified in\n a sequential file executed when you logon, if it exists with a\n specific pattern, e.g. YourUserID.SIGNON).  Use TSO ISRDDN to\n check the allocation to make sure your file is there if you get\n macro not found messages.\n\n The above command will dynamically add YOURID.CLIST (note fully\n qualified with no quotes) to the front of the SYSPROC\n concatenation for this current LOGON.  Many sites have a sign-on\n process that will let you execute this line automatically each\n time you logon (please see comment above about using SYSEXEC).\n\n The following macros, with the exception of the DS List macros\n and member list macros, are executable under either EDIT or VIEW\n (some, such as BS or CC may be invoked anywhere, ala TSO BS\n 120).  The benefits of use are available in VIEW and the\n resulting data, even if changed, can use VSAVE or REPLACE to\n save existing data, or CREATE a new member.  Plus VIEW provides\n a safety factor in that an accidental F3 press will not overlay\n good data and you get a warning that data has changed.\n Whatever, when doing extensive changes, saving is always a good\n+          _____________________________________________________\n idea!\n+_____\n\n The following PF key assignments are suggested to maximize the\n+                                     _________\n effect of the provided tool set.  Note there is no DELETE key!\n Unless you are extremely precise, it's all too easy to\n accidently delete a line.\n\n       F1 . . . HELP           F13  . .  %TSJ\n       F2 . . . SPLIT NEW      F14  . .  SWAP LIST\n       F3 . . . EXIT           F15  . .  CUT\n       F4 . . . :I             F16  . .  %PY\n1                Gaining Execution Access (Continued)                Page      9\n\n       F5 . . . RFIND          F17  . .  %FALT\n       F6 . . . RCHANGE        F18  . .  :R\n       F7 . . . UP             F19  . .  %JB\n       F8 . . . DOWN           F20  . .  %JT\n       F9 . . . SWAP NEXT      F21  . .  %XINDENT\n       F10  . . LEFT           F22  . .  %DISPVAR\n       F11  . . RIGHT          F23  . .  %ZVW\n       F12  . . :COLS          F24  . .  CRETRIEV\n\n Most of the above key assignments are generic ISPF commands with\n the exception of DISPVAR, FALT, JB, JT, PY, TSJ, XINDENT and ZVW\n which come with this package.\n\n If you use KEYLIST OFF as I do, please be aware that every\n separate application has its own KEYS settings.\n\n\n1                     Column Manipulation Macros                     Page     10\n\n\n The following are column oriented macros. If you type the macro\n name on the command line without any parameters, you'll get a\n help screen describing it.\n\n They also will accept and use line labels like .A and .B as\n shown in their formats (but any legal labels may be used).  The\n ability to set and keep labels was deliberately done to allow for\n repeated changes to the same set of lines.  Optional parameters\n are shown in parentheses.\n\n\n COPYCOLS   FROM-LEFT-COL  FROM-RIGHT-COL  TO-LEFT-COL ( .A .B )\n+________\n\n       copies columns over other columns, e.g.\n\n          COPYCOLS  11 20  41\n\n       will leave the data in columns 11 thru 20 as it exists\n       and make a copy onto columns 41 thru 50. The columns are\n       mandatory but the label ranges are optional. Given the\n       following data:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       the results of 'COPYCOLS 11 20 41' would be:\n\n          ----+----1----+----2----+----3----+----4----+----5-\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddbbbbbbbbbb\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddbbbbbbbbbb\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddbbbbbbbbbb\n          ----+----1----+----2----+----3----+----4----+----5-\n\n\n COPYINS   FROM-LEFT-COL  FROM-RIGHT-COL  TO-LEFT-COL  ( .A .B )\n+_______\n\n       copies columns into the data, that is, the copied data\n       will be inserted at the TO-LEFT-COL column and the columns\n       from the TO-LEFT-COL to the right will be shifter\n       accorcingly.  The columns are required but the ranges are\n       optional. For example:\n\n          COPYINS  11  20  1  .XX .YY\n\n       will take a copy of columns 11 thru 20 in the range of .XX\n       through .YY and put them in column 1 through 10 shifting\n       what was in column 1 and following 9 columns to the right.\n       For example, given:\n\n1               Column Manipulation Macros (Continued)               Page     11\n\n          000001 AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n          =COLS> ----+----1----+----2----+----3----+----4----+----5\n          .XX    AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n          000003 AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n          .YY    AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n          =COLS> ----+----1----+----2----+----3----+----4----+----5\n          000005 AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n\n       the result of 'COPYINS  11  20  1  .XX .YY' would be:\n\n          000001 AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n          =COLS> ----+----1----+----2----+----3----+----4----+----5\n          .XX    bbbbbbbbbbAAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n          000003 bbbbbbbbbbAAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n          .YY    bbbbbbbbbbAAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n          =COLS> ----+----1----+----2----+----3----+----4----+----5\n          000005 AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n\n\n CVB  FROM-COL1 FROM-COL2 (TO-COL1 TO-COL2) (-MINUS-COL) (.A .B)\n+___\n\n       converts the numbers in the specified columns to binary.\n       The FROM- columns specify the numeric display data and are\n       mandatory.  The TO- columns are optional and will receive\n       the result; if left off, the result will be placed in the\n       FROM- columns.  The receiving field does not have to be a\n       multiple of 2, but probably should be 2, 4 or 8.\n\n       The -MINUS-COL value, of the form -17, indicates the\n       column from which to pick up the plus or minus sign.  If\n       no sign column is specified, the zone of the rightmost\n       numeric digit will be used as the sign.  For example,\n\n          CVB  1 7  11 14  -8  .AA .XX\n\n       will convert the numeric data in columns 1 through 7 into\n       binary in columns 11 through 14, causing the binary value\n       to take on the sign from column 8, in the range of label\n       .AA to .XX.\n\n       Note that CAPS will be turned off and a message will be\n+      _________________________________\n       displayed saying so.\n\n       A message showing the number of overflows and the total\n       valid numbers found will appear in the upper right corner.\n       F1 may be pressed to see a somewhat fuller explanation.\n\n       CVB may be used after FORMCOLS eliminates commas and\n       aligns the data. DELCOLS may be used to remove periods\n       after FORMCOLS is complete.\n\n       Given the following data:\n\n1               Column Manipulation Macros (Continued)               Page     12\n\n          000001 0000001\n                 FFFFFFF44444444444444\n                 000000100000000000000\n          =COLS> ----+----1----+----2-\n          .AA    0000002\n                 FFFFFFF44444444444444\n                 000000200000000000000\n          000003 0000003-\n                 FFFFFFF64444444444444\n                 000000300000000000000\n          .XX    0000004\n                 FFFFFFF44444444444444\n                 000000400000000000000\n          =COLS> ----+----1----+----2-\n          000005 0000005\n                 FFFFFFF44444444444444\n                 000000500000000000000\n\n       the results of 'CVB  1 7  11 14  -8  .AA .XX' would be:\n\n          000001 0000001\n                 FFFFFFF44444444444444\n                 000000100000000000000\n          =COLS> ----+----1----+----2-\n          .AA    0000002\n                 FFFFFFF44400004444444\n                 000000200000020000000\n          000003 0000003-     \u00d9\n                 FFFFFFF644FFFF4444444\n                 0000003000FFFD0000000\n          .XX    0000004\n                 FFFFFFF44400004444444\n                 000000400000040000000\n          =COLS> ----+----1----+----2-\n          000005 0000005\n                 FFFFFFF44444444444444\n                 000000500000000000000\n\n\n CVD  FROM-COL1 FROM-COL2 (TO-COL1 TO-COL2) (-MINUS-COL) (.A .B)\n+___\n\n       converts binary data to numeric display data.  The FROM-\n       columns specify the source binary value. The length of the\n       FROM- columns does not have to be a multiple of 2. The TO-\n       columns specify the destination and will default to the\n       FROM- columns if they are not specified.\n\n       The -MINUS-COL, specified as a column number with a minus\n       sign, will receive the sign of the result, otherwise the\n       sign will be placed as the zone value of the rightmost\n       result digit, e.g. 'J' for minus 1. For example,\n\n          CVD  11 18  21 29  -30  .A .B\n\n1               Column Manipulation Macros (Continued)               Page     13\n\n       will convert the binary data in columns 11 through 18 into\n       numeric displayable data in columns 21 through 29, placing\n       the appropriate plus/minus sign into column 30 in the line\n       range .A through .B.\n\n       A message showing the number of overflows and the number\n       of lines processed will appear in the upper right corner.\n       F1 may be pressed for an expanded explanation.\n\n       FORMCOLS may be used to neatly format the resultant data\n       and FILLINS to insert periods.\n\n       Given the following data:\n\n          000001\n                 4444444444000000004444444444444\n                 0000000000000000010000000000000\n          =COLS> ----+----1----+----2----+----3-\n          .A\n                 4444444444000000014444444444444\n                 0000000000000000000000000000000\n          000003\n                 4444444444000000004444444444444\n                 0000000000000000100000000000000\n          .B\n                 4444444444000000104444444444444\n                 0000000000000000000000000000000\n          =COLS> ----+----1----+----2----+----3-\n          000005\n                 4444444444000000004444444444444\n                 0000000000000001000000000000000\n\n       the results of 'CVD  11 18  21 29  -30  .A .B' would be:\n\n          000001\n                 4444444444000000004444444444444\n                 0000000000000000010000000000000\n          =COLS> ----+----1----+----2----+----3-\n          .A                         000000016+\n                 44444444440000000144FFFFFFFFF44\n                 00000000000000000000000000016E0\n          000003                     000000256+\n                 44444444440000000044FFFFFFFFF44\n                 00000000000000001000000000256E0\n          .B                         000004096+\n                 44444444440000001044FFFFFFFFF44\n                 00000000000000000000000004096E0\n          =COLS> ----+----1----+----2----+----3-\n          000005\n                 4444444444000000004444444444444\n                 0000000000000001000000000000000\n\n\n1               Column Manipulation Macros (Continued)               Page     14\n\n C2H  FROM-COL1 FROM-COL2  (TO-COL1 TO-COL2)  (.A .B)\n+___\n\n       converts hexidecimal characters, 'A'-'F' and '0'-'9', to\n       their hex value, e.g. turns '0123456789ABCDEF' into\n       X'0123456789ABCDEF'. The FROM- columns are required.  The\n       TO- columns specify the destination and will default to\n       the FROM- columns if unspecified.\n\n       Given the following data,\n\n          000000\n          FFFFFF444444444444444444444444\n          000000000000000000000000000000\n          ----+----1----+----2----+----3\n          999999\n          FFFFFF444444444444444444444444\n          999999000000000000000000000000\n          ----+----1----+----2----+----3\n          012AC3\n          FFFCCF444444444444444444444444\n          012133000000000000000000000000\n\n       the result of\n\n          C2H  1 6  11 13\n\n       would be:\n\n          000000\n          FFFFFF444400044444444444444444\n          000000000000000000000000000000\n          ----+----1----+----2----+----3\n          999999    rrr\n          FFFFFF444499944444444444444444\n          999999000099900000000000000000\n          ----+----1----+----2----+----3\n          012AC3      C\n          FFFCCF444402C44444444444444444\n          01213300001A300000000000000000\n\n       No conversion will take place on lines where the receiving\n       field is shorter then the converted data and the lost\n       columns would not be hex zeros. Hex zeros will be used to\n       left pad short receiving fields.\n\n       A message showing the number of lines processed, overflows\n       and the number of lines with bad data (that is, not 'A'\n       thru 'F' or '0' thru '9').  F1 may be pressed for an\n       expanded explanation. See H2C below for the converse.\n\n\n1               Column Manipulation Macros (Continued)               Page     15\n\n DELCOLS   LEFT-COL1 RIGHT-COL1 (...)  ( .A .B )\n+_______\n\n       will remove the specified columns, shifting the remaining\n       leftwards, as in\n\n          DELCOLS  11  20\n\n       deleting column 11 through 20 and shifting everything from\n       column 21 to the end of each record left 10 columns.\n       DELCOLS may be used as a large scale truncating left\n       shift, that is,\n\n          DELCOLS  1  20\n\n       will cause all data to be shifted 20 positions to the\n       left, but please also see SHIFT for other options.\n\n       DELCOLS is the reverse of KEEPCOLS, removing rather then\n       keeping data.  Given the following data:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       the results of 'DELCOLS  11 20  31 40' would be:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAACCCCCCCCCCEEEEEEEEEE\n          AAAAAAAAAACCCCCCCCCCEEEEEEEEEE\n          AAAAAAAAAACCCCCCCCCCEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       Please note the columns specified are always based on the\n       original record.  The process may be limited to ranges of\n       line via either labels or C/CC/C# prefix selection. This\n       macro may also be invoked against a file under DS List and\n       will be shown in that section. The latter is useful when\n       the file is too big to be edited.\n\n\n FILLCOLS   LEFT-COL  RIGHT-COL  STRING  ( .A .B )\n+________\n\n       overlays the specified columns with the given string, as\n\n          FILLCOLS  2  9  '-*'\n\n       will make columns 2 thru 9 contain -*-*-*-*.  The string\n       will overlay as many copies as necessary to fill the\n       columns, for example:\n\n          FILLCOLS  2  9  '-=-'\n1               Column Manipulation Macros (Continued)               Page     16\n\n\n       will only overlay -=--=--= onto columns 2 thru 9.  The\n       columns and string are mandatory and the label range\n       optional.\n\n       For example, given the following data:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       the results following 'FILLCOLS  21 30  123' would be:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbb1231231231ddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbb1231231231ddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbb1231231231ddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n\n FILLINS   LEFT-COL  STRING  ( .A .B )\n+_______\n\n       inserts the string before the specified column shifting\n       the current data to the right, e.g.\n\n          FILLINS  19  'XXX'\n\n       will insert 3 X's into columns 19, 20 and 21, and shift\n       everything in the original column 19 on 3 columns to the\n       right. FILLINS may be used as a right shift, namely\n\n          FILLINS  1  '     '\n\n       will shift everything to the right the number of blanks\n       between the quotes but please also see the SHIFT macro.\n       The columns and string are mandatory and the label range\n       optional.  The shifting may result in data loss on the far\n       right of the record.\n\n       Given the following data:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       the result of 'FILLINS  11  XXXXXXXXXX' would be\n\n          ----+----1----+----2----+----3----+----4----+----5----+----6\n          AAAAAAAAAAXXXXXXXXXXbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAXXXXXXXXXXbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n1               Column Manipulation Macros (Continued)               Page     17\n\n          AAAAAAAAAAXXXXXXXXXXbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5----+----6\n\n\n FORMCOLS FORMAT FROM-LEFT FROM-RIGHT (TO-LEFT TO-RIGHT)(.A .B)\n+________\n\n       will reformat the arithmetic display data in the\n       FROM- columns into the TO- columns, aligning and right\n       justifying the data, using the formatting characters to\n       define the output.  If omitted, the to-columns will\n       default to the from-columns.  It will eliminate commas in\n       the input, strip input of leading and trailing blanks and\n       extraneous leading zeros and pick a up sign from anywhere\n       in the input columns, including a zoned last character.\n\n       The format specified is filled from the data. The special\n       characters used are:\n\n             9   replace with a digit or a zero if no digit\n\n             Z   replace with a digit or a blank if leading\n                 digit zero - may be used on far left and/or far\n                 right of supplied format\n\n             ,   leave unless no significant digits to left then\n                 blank\n\n             .   leave and use to align data\n\n             +   replace with actual sign, either + or -\n\n             -   replace with blank if data not negative else\n                 leave\n\n       For example,\n\n          FORMCOLS  'ZZZ,ZZ9.99Z +'  1 10  21 35\n\n       will reformat\n\n             '   123    '              '      123.00  +'\n             '1234567890'              '  567,890.00  +'\n             '   11.M   '    into      '       11.40  -'\n             '2,468.00- '              '    2,468.00  -'\n             '  +0      '              '        0.00  +'\n\n       Note FORMCOLS will handle input commas as the 4th example\n       above shows and will check for the sign anywhere in the\n       input.\n\n       A message showing the total valid numbers found, the\n       number of overflows and the number of lines processed\n       will appear in the upper right corner. The above would\n       produce \"5/1/5 FORMATTED\" since the second set of data\n1               Column Manipulation Macros (Continued)               Page     18\n\n       would cause an overflow. An overflow is considered to\n       be any loss of a significant (non zero) digit. Pressing\n       PF1 immediately afterwards will describe the message.\n\n       FORMCOLS can be used with CVD or UNPK to gain access to\n       and neatly format originally binary or packed data.  It\n       may be used prior to CVB or PK to clean up data.  MOVEINSD\n       may be used to move the decimal point or FILLINS to insert\n       one, if desired.\n\n\n H2C  FROM-COL1 FROM-COL2  (TO-COL1 TO-COL2)  (.A .B)\n+___\n\n       converts characters, X'00'-X'FF', to their hex equivalent,\n       '00' thru 'FF'.  H2C would turn X'0123456789ABCDEF' into\n       '0123456789ABCDEF'. The FROM- columns are required.  The\n       TO- columns specify the destination and will default to\n       the FROM- columns if unspecified.\n\n       Given the following data,\n\n          02468ACE4444444444444444444444\n          13579BDF0000000000000000000000\n          ----+----1----+----2----+----3\n          000000004444444444444444444444\n          000000000000000000000000000000\n          ----+----1----+----2----+----3\n          000000FC4444444444444444444444\n          000000AE0000000000000000000000\n\n       the result of\n\n          H2C  1 8  11 26\n\n       would be:\n                    0123456789ABCDEF\n          02468ACE44FFFFFFFFFFCCCCCC4444\n          13579BDF0001234567891234560000\n          ----+----1----+----2----+----3\n                    0000000000000000\n          0000000044FFFFFFFFFFFFFFFF4444\n          000000000000000000000000000000\n          ----+----1----+----2----+----3\n                    000000000000FACE\n          000000FC44FFFFFFFFFFFFCCCC4444\n          000000AE0000000000000061350000\n\n       No conversion will take place on lines where the receiving\n       field is shorter then the converted data and the lost\n       columns would not be zeros. Zeros will be used to\n       left pad short receiving fields.\n\n       A message showing the number of lines processed and\n       overflows (there can not be bad data since all hex values\n1               Column Manipulation Macros (Continued)               Page     19\n\n       are processed).  F1 may be pressed for an expanded\n       explanation. See C2H above for the converse.\n\n\n JOINCOLS  COL-1 ( ... )  ( .A  .B )\n+________\n\n      this macro will concatenate subsequent lines to the\n      preceding line at the column or columns specified. One\n      column is required.  For example\n\n         JOINCOLS  21 41 61\n\n      will append the 2nd line to the 1st at position 21, the 3rd\n      to the combined 1st and 2nd at position 41, and the 4th to\n      the combined 1st, 2nd and 3rd at position 61.  Please note\n      SPLTCOLS with the same parameters produces the reverse,\n      i.e. it splits them back again given no data was lost when\n      the JOINCOLS was done\n\n      For example, given the following data:\n\n         AAAAAAAAAA\n         ----+----1----+----2----+----3----+----4----+----5\n         bbbbbbbbbb\n         CCCCCCCCCC\n         dddddddddd\n         EEEEEEEEEE\n         AAAAAAAAAA\n         bbbbbbbbbb\n         CCCCCCCCCC\n         dddddddddd\n         EEEEEEEEEE\n         AAAAAAAAAA\n         bbbbbbbbbb\n         CCCCCCCCCC\n         dddddddddd\n         ----+----1----+----2----+----3----+----4----+----5\n         EEEEEEEEEE\n\n      the results of 'JOINCOLS  11  21  31  41' would be:\n\n         AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n         ----+----1----+----2----+----3----+----4----+----5\n         AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n         AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n         ----+----1----+----2----+----3----+----4----+----5\n\n\n KEEPCOLS  LEFT-COL1 RIGHT-COL1 (...)  ( .A .B )\n+________\n\n       will keep the specified columns, shifting them to the\n       left, as running the following against a 200 file:\n\n          KEEPCOLS  11 20  101 103  141 142\n1               Column Manipulation Macros (Continued)               Page     20\n\n\n       effectively deletes columns 1 through 10, 21 through 100,\n       104 through 140 and 143 through 200.  The selected columns\n       will be in the left-most 15 columns and the other 185\n       columns will be blank.\n\n       KEEPCOLS is the reverse of DELCOLS, retaining rather then\n       removing data.  Given the following data:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       the results of 'KEEPCOLS  11 20' would be:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          bbbbbbbbbb\n          bbbbbbbbbb\n          bbbbbbbbbb\n          ----+----1----+----2----+----3----+----4----+----5\n\n       The process may be limited to a range of lines via either\n       labels or C/CC/C# prefix selection. This macro may also\n       be invoked against a file under DS List and will be\n       shown in that section.\n\n\n MOVECOLD   FROM-LEFT-COL  FROM-RIGHT-COL  TO-LEFT-COL ( .A .B )\n+________\n\n       will take the specified columns and overlay them onto the\n       receiving column, deleting the originating data.  For\n       example,\n\n          MOVECOLS  21 25  68\n\n       will replicate what's in columns 21 thru 25 onto columns\n       68 thru 72 and then delete columns 21 thru 25, shifting\n       the data from column 26 onwards 5 columns to the left.\n       (eliminating the original columns).  MOVECOLD is a variant\n       of MOVECOLS, MOVEINS and MOVEINSD.\n\n       For example, given:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       the results of 'MOVECOLD  31 40  11' would be:\n\n          ----+----1----+----2----+----3----+----4----+----5\n1               Column Manipulation Macros (Continued)               Page     21\n\n          AAAAAAAAAAddddddddddCCCCCCCCCCEEEEEEEEEE\n          AAAAAAAAAAddddddddddCCCCCCCCCCEEEEEEEEEE\n          AAAAAAAAAAddddddddddCCCCCCCCCCEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n\n MOVECOLS   FROM-LEFT-COL  FROM-RIGHT-COL  TO-LEFT-COL ( .A .B )\n+________\n\n       will take the specified columns and overlay them onto the\n       receiving column, blanking the originating data.  For\n       example,\n\n          MOVECOLS  21 25  68\n\n       will replicate what's in columns 21 thru 25 onto columns\n       68 thru 72 and then blank columns 21 thru 25. DELCOLS may\n       be used to eliminate the original columns.  MOVECOLS is\n       useful if consolidating columns as you can see progress as\n       source fields are blanked.\n\n       For example, given the following data:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       the result of 'MOVECOLS  31 40  11' would be:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAddddddddddCCCCCCCCCC          EEEEEEEEEE\n          AAAAAAAAAAddddddddddCCCCCCCCCC          EEEEEEEEEE\n          AAAAAAAAAAddddddddddCCCCCCCCCC          EEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n\n MOVEINS   FROM-LEFT-COL  FROM-RIGHT-COL  TO-LEFT-COL  ( .A .B )\n+_______\n\n       will take the specified columns and insert them into the\n       receiving column, shifting displaced data to the right,\n       and blanking the originating data.  For example,\n\n          MOVEINS  1 5  30  .S .E\n\n       will replicate what's in columns 1 thru 5 into columns 30\n       thru 34, shifting the data in columns 30 onward to the\n       right 5 columns, and then blank columns 1 thru 5, within\n       the .S thru .E range.  DELCOLS may be used to remove the\n       original blank columns or MOVEINSD may be used instead of\n       MOVECOLS to do the insert and then automatically delete\n       the originating columns.\n\n       Given the following:\n1               Column Manipulation Macros (Continued)               Page     22\n\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       the result of 'MOVEINS  11 20  31' would be:\n\n          ----+----1----+----2----+----3----+----4----+----5----+----6\n          AAAAAAAAAA          CCCCCCCCCCbbbbbbbbbbddddddddddEEEEEEEEEE\n          AAAAAAAAAA          CCCCCCCCCCbbbbbbbbbbddddddddddEEEEEEEEEE\n          AAAAAAAAAA          CCCCCCCCCCbbbbbbbbbbddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5----+----6\n\n\n MOVEINSD  FROM-LEFT-COL  FROM-RIGHT-COL  TO-LEFT-COL  ( .A .B )\n+________\n\n       will take the specified columns and insert them into the\n       receiving column, shifting displaced data to the right,\n       and deleting the originating data.  For example,\n\n          MOVEINSD  11 15  1  .BEG .END\n\n       will replicate what's in columns 11 thru 15 into column 1\n       thru 5, shifting the other data 5 columns to the right,\n       and deleting the original columns 11 thru 15, within the\n       .BEG thru .END range. This is a variation of MOVEINS which\n       essentially allows moving data around with records.\n\n       Note if the source is to the left of the receiving column,\n       the newly inserted data will take part in a shift to the\n       left when the source is removed.\n\n       With the following data:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       the result of 'MOVEINSD  41 50  1' is:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          EEEEEEEEEEAAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n          EEEEEEEEEEAAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n          EEEEEEEEEEAAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n          ----+----1----+----2----+----3----+----4----+----5\n\n\n1               Column Manipulation Macros (Continued)               Page     23\n\n NUMCOLS  START-COL END-COL (START-NUM INCREMENT SKIP) (.A .B)\n+_______\n\n       puts whole numbers in the specified columns, as in:\n\n          NUMCOLS  1 5   20 5\n\n       will put '   20' in the 1st line's columns 1 thru 5,\n       '   25' in the 2nd line's, '   30' etc.  The starting and\n       ending columns are mandatory.  The starting number,\n       increment and number of lines to skip will default to 1.\n       You must specify the starting number and increment if you\n       wish to specify the number of lines to skip after the\n       first line.\n\n\n NUMCOLS0   START-COL  END-COL START-NUM INCREMENT SKIP (.A .B)\n+________\n\n       puts 0 padded numbers in the specified columns, as in:\n\n          NUMCOLS0  1 5  111  .aa .xx\n\n       will put '00111' in the 1st line's columns 1 thru 5,\n       '00112' in the 2nd line's, '00113' etc in the range of\n       .AA through .XX.\n\n       The starting and ending columns are mandatory.  The\n       starting number, increment and number of lines to skip\n       will default to 1. You must specify the starting number\n       and increment if you wish to specify the number of lines\n       to skip after the first line.\n\n       A sample of its use would be in generating JCL to\n       reference a Generation Data Group (GDG) backwards (i.e.\n       we can't use the base or we only want part of them).\n       Suppose there are 7 entries in a GDG base as follows:\n\n          SYS4.TAMAST.REVISION.TRIAL7.G0029V00\n          SYS4.TAMAST.REVISION.TRIAL7.G0030V00\n          SYS4.TAMAST.REVISION.TRIAL7.G0031V00\n          SYS4.TAMAST.REVISION.TRIAL7.G0032V00\n          SYS4.TAMAST.REVISION.TRIAL7.G0033V00\n          SYS4.TAMAST.REVISION.TRIAL7.G0034V00\n          SYS4.TAMAST.REVISION.TRIAL7.G0035V00\n\n      and we wanted JCL to reference the middle 5 backwards.  We\n      could build:\n\n         000001 //             DD       DISP=SHR,DCB=BUFNO=32,\n         .A 002 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0000V00\n         =COLS> ----+----1----+----2----+----3----+----4----+----5----+\n         000003 //             DD       DISP=SHR,DCB=BUFNO=32,\n         000004 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0000V00\n         000005 //             DD       DISP=SHR,DCB=BUFNO=32,\n1               Column Manipulation Macros (Continued)               Page     24\n\n         000006 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0000V00\n         000007 //             DD       DISP=SHR,DCB=BUFNO=32,\n         000008 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0000V00\n         =COLS> ----+----1----+----2----+----3----+----4----+----5----+\n         000009 //             DD       DISP=SHR,DCB=BUFNO=32,\n         .B0010 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0000V00\n\n      Please note where we set the label range - on the first\n      line to get a number and on the last. Also we just\n      specified the G00V00 number as zeros intending to overlay\n      them.  The results of 'NUMCOLS0  50 52  34  -1  2  .A .B'\n      would be:\n\n         000001 //             DD       DISP=SHR,DCB=BUFNO=32,\n         .A     //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0034V00\n         =COLS> ----+----1----+----2----+----3----+----4----+----5----+\n         000003 //             DD       DISP=SHR,DCB=BUFNO=32,\n         000004 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0033V00\n         000005 //             DD       DISP=SHR,DCB=BUFNO=32,\n         000006 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0032V00\n         000007 //             DD       DISP=SHR,DCB=BUFNO=32,\n         000008 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0031V00\n         =COLS> ----+----1----+----2----+----3----+----4----+----5----+\n         000009 //             DD       DISP=SHR,DCB=BUFNO=32,\n         .B     //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0030V00\n\n\n PK FROM-COL1 FROM-COL2 (TO-COL1 TO-COL2) (-MINUS-COL) (.A .B)\n+__\n\n       packs the numbers in the specified columns, as in:\n\n          PK   1 7  -8  31 34  .AA .XX\n\n       will pack the data in columns 1 through 7 into columns 31\n       through 34, placing the equivalent plus/minus from column\n       8 in the sign portion of column 34.  The from columns are\n       mandatory.  The to columns will default to the from\n       columns, while the minus sign will default to the sign of\n       the last from digit.\n\n       Note that CAPS will be turned off and a message will be\n+      _________________________________\n       displayed saying so.\n\n       A message showing the total valid numbers found, the\n       number of overflows and the number of lines processed\n       will appear in the upper right corner. Pressing PF1\n       will describe the numbers shown\n\n       PK may be used after FORMCOLS eliminates commas and aligns\n       the data. DELCOLS may be used to remove periods after\n       FORMCOLS is complete and before PK.\n\n       Given the following data:\n1               Column Manipulation Macros (Continued)               Page     25\n\n\n          00001\n          FFFFF44444444\n          0000100000000\n          ----+----1---\n          0000A\n          FFFFC44444444\n          0000100000000\n          ----+----1---\n          0000J\n          FFFFD44444444\n          0000100000000\n          ----+----1---\n          99999\n          FFFFF44444444\n          9999900000000\n          ----+----1---\n          9999R\n          FFFFD44444444\n          9999900000000\n\n       the results of 'PK  1 5  11 13' would be:\n\n          00001\n          FFFFF44444001\n          000010000000F\n          ----+----1---\n          0000A\n          FFFFC44444001\n          000010000000C\n          ----+----1---\n          0000J\n          FFFFD44444001\n          000010000000D\n          ----+----1---\n          99999     rr\u20ac\n          FFFFF44444999\n          999990000099F\n          ----+----1---\n          9999R     rr\u00b8\n          FFFFD44444999\n          999990000099D\n\n\n RANCOLS   START-COL  END-COL  ( MIN-NUM  MAX-NUM )  ( .A .B )\n+_______\n\n       puts pseudo random numbers into the specified columns,\n       right justified and left padded with blanks, as in:\n\n          RANCOLS  1  5  0  99\n\n       may put '   21' in the 1st line's columns 1 thru 5, '\n       95' in the 2nd line's, '   87' etc.  The defaults are\n       minimum number of 1 and maximum number of all 9's.  The\n1               Column Manipulation Macros (Continued)               Page     26\n\n       REXX RANDOM() function is used to generate the numbers.\n\n\n RANCOLS0   START-COL  END-COL  ( MIN-NUM  MAX-NUM )  ( .A .B )\n+________\n\n       puts 0 padded pseudo random numbers into the specified\n       columns, right justified and left padded with zeros, as\n       in:\n\n          RANCOLS0  .AAA .BBB  1 5\n\n       may put '01584' in the 1st line's columns 1 thru 5,\n       '40089' in the 2nd line's, '24207' etc of the line\n       range .AAA through .BBB.  The defaults are minimum\n       number of 1 and maximum number of all 9's. The REXX\n       RANDOM() function is used to generate the numbers.\n\n       RANCOLS0 might be useful for generating random numeric\n       data for testing or for filling columns used to do a\n       repeatable random ordering.\n\n\n SHIFT  LEFT|RIGHT  (#COLUMNS)  (X|NX)  (.A .B)  (MAX|LEAVE)\n+_____\n\n       shifts the data left or right the number of columns\n       specified, within the BOUNDS in force.  The direction of\n       the shift is required and may be entered as LEFT or L, or\n       RIGHT or R.\n\n       The number of columns defaults to 1. The label range is\n       optional. X or NX may be specified to have the shift\n       impact only excluded or unexcluded lines, respectively.\n       The default is all lines.\n\n       MAX says to only cut off non blank columns; LEAVE says to\n       not shift the line in question at all if any non blank\n       data would be lost on that line.  The default is to\n       truncate the data.\n\n          SHIFT  LEFT  12  NX  .K .L\n\n       will shift all the unexcluded lines in the line range .K\n       through .L 12 columns to the left, within the current\n       bounds.\n\n       For example, given the following:\n\n          =COLS> ----+----1----+----2\n          .K       Length\n          000003           Forth\n          .L         Daily\n          =COLS> ----+----1----+----2\n\n       the result of 'SHIFT  LEFT  12  NX  .K .L' would be:\n1               Column Manipulation Macros (Continued)               Page     27\n\n\n          =COLS> ----+----1----+----2\n          .K\n          000003 rth\n          .L\n          =COLS> ----+----1----+----2\n\n       Note the above data (in the .K thru .L range) is truncated.\n       And, given the same start data shown above, the result of\n       'SHIFT  L  12  NX  .K .L MAX' would be:\n\n          =COLS> ----+----1----+----2\n          .K     Length\n          000003 Forth\n          .L     Daily\n          =COLS> ----+----1----+----2\n\n       Note the above data (in the .K thru .L range) is not\n       truncated but shifted as far left as possible without\n       losing any data.  And, finally, given the same start data\n       shown above, the result of 'SHIFT  L  12  NX  .K .L LEAVE'\n       would be:\n\n          =COLS> ----+----1----+----2\n          .K       Length\n          000003           Forth\n          .L         Daily\n          =COLS> ----+----1----+----2\n\n       Note nothing changed since a shift of 12 bytes leftwards\n       would cause truncation in every instance.\n\n\n SPLTCOLS  COL-1  ( ... )  ( .A  .B )\n+________\n\n      this macro will split a line at the given column intervals\n      creating multiple lines from one.  For example\n\n         SPLTCOLS  21  41  61\n\n      will split one line into 4,  the 1st having columns 1\n      through 20, the 2nd 21 through 40, the 3rd 41 through 60,\n      and the 4th 61 through the end of the data.  Useful for\n      breaking up columns into more editable data and in\n      conjunction with JOINCOLS.\n\n      Assuming the following data:\n\n         AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n         ----+----1----+----2----+----3----+----4----+----5----+----6\n         AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n         ----+----1----+----2----+----3----+----4----+----5----+----6\n         AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n\n1               Column Manipulation Macros (Continued)               Page     28\n\n      the result of 'SPLTCOLS  11  21  32  41' would be:\n\n         AAAAAAAAAA\n         bbbbbbbbbb\n         CCCCCCCCCC\n         dddddddddd\n         EEEEEEEEEE\n         ----+----1----+----2----+----3----+----4----+----5----+----6\n         AAAAAAAAAA\n         bbbbbbbbbb\n         CCCCCCCCCC\n         dddddddddd\n         EEEEEEEEEE\n         ----+----1----+----2----+----3----+----4----+----5----+----6\n         AAAAAAAAAA\n         bbbbbbbbbb\n         CCCCCCCCCC\n         dddddddddd\n         EEEEEEEEEE\n\n      Also, if faced with the need to break up unstructured data,\n      for example:\n\n         In theory, the product configuration baseline adds overriding\n         performance constraints to the philosophy of commonality and\n         standardization.   Similarly, the product assurance\n         architecture adds explicit performance limits to the total\n         system rationale.\n\n      use TF2 on the prefix area for that line. It resulted in:\n\n         In\n         theory,\n         the\n         product\n         configuration\n         baseline\n         adds\n         overriding\n         performance\n         constraints\n         to\n         the\n         philosophy\n         of\n         commonality\n         and\n         standardization.\n         Similarly,\n         the\n         product\n            ... etc ...\n\n\n1               Column Manipulation Macros (Continued)               Page     29\n\n SUMCOLS   1ST-COL 2ND-COL  ...  ( .A .B )\n+_______\n\n       will arithmetically add the numbers in the given columns.\n       At least one pair of columns must be specified.  They\n       don't have to be in the precise columns given.  For\n       example:\n\n          SUMCOLS  11 20\n\n       where 11 thru 20 might contain:\n\n          11       20\n          +--------+\n             1K\n              123\n           200.25\n             -1\n           2,345 +\n          +--------+\n          11       20\n\n       will produce\n\n          12:34:56 SUM of COLS  11-20, total is 2655.25\n          12:34:56 --------------- Total of SUMS is  2655.25\n\n       Note the lines with 1K and 2,345 (which are not pure\n       numerics) are counted.  The 1K value is accepted as -12.\n       Prefix or postfix signs are accepted.  Up to 9 pairs of\n       columns may be specified.\n\n       If no label range is specified, the macro will look for\n       C/CC/C# prefix commands. If none are found, the entire\n       file will be processed. Only unexcluded lines will be\n       processed (for historical reasons).\n\n\n UNPK FROM-COL1 FROM-COL2 (TO-COL1 TO-COL2) (-MINUS-COL) (.A .B)\n+____\n\n       unpacks the numbers in the specified columns, as in:\n\n          UNPK  11 19  31 47  -30  .A .B\n\n       will unpack the data in columns 11 through 19 into columns\n       31 through 47, placing the appropriate plus/minus sign\n       into column 30 in the line range .A through .B.  The from\n       columns are mandatory.  The to columns will default to the\n       from columns, while the minus sign location will default\n       to the the last TO digit (zoned, that is, -1 equal to J,\n       1 equal to A, -2 to K, 2 equal to B, etc).\n\n       A message showing the total valid numbers found, the\n       number of overflows and the number of lines processed\n1               Column Manipulation Macros (Continued)               Page     30\n\n       will appear in the upper right corner. Pressing PF1\n       will describe the values shown.\n\n       FORMCOLS may be used to neatly format the resultant data\n       and FILLINS to insert periods.\n\n       Given the following data as the starting point:\n\n                         \u00ee\"\n          4444444444000135744444444444444444444444\n          0000000000000246F00000000000000000000000\n          ----+----1----+----2----+----3----+----4\n                          @\n          4444444444000000744444444444444444444444\n          0000000000000004C00000000000000000000000\n          ----+----1----+----2----+----3----+----4\n\n          4444444444000111144444444444444444444444\n          0000000000000111D00000000000000000000000\n\n       the result of 'UNPK  11 17  21 30  -31', immediately\n       followed by 'UNPK  11 17  1 10' would be:\n\n          0001234567     \u00ee\"   0001234567+\n          FFFFFFFFFF0001357444FFFFFFFFFF4444444444\n          0001234567000246F0000001234567E000000000\n          ----+----1----+----2----+----3----+----4\n          0000000047      @   0000000047+\n          FFFFFFFFFF0000007444FFFFFFFFFF4444444444\n          0000000047000004C0000000000047E000000000\n          ----+----1----+----2----+----3----+----4\n          000111111J          0001111111-\n          FFFFFFFFFD0001111444FFFFFFFFFF6444444444\n          0001111111000111D00000011111110000000000\n\n\n1                       Display Control Macros                       Page     31\n\n\n The following macros will expand both FIND and EXCLUDE/INCLUDE\n capabilities.  None will change the order or the content of the\n+               ________________________________________________\n file.  Standard ISPF commands such as DEL ALL X or FLIP may be\n+____\n used subsequently to delete or see the opposite lines\n respectively.\n\n FALT is a pseudo repeat capability for many of the below macros.\n Please see the macro below for full details.\n\n Built in help is available by either typing the macro name\n without any parameters (if any parameter is mandatory) or with\n just a question mark (?) as the only operand as shown below.\n\n\n COUNTXNX  ( ? )  ( .A .B )\n+________\n\n       shows in the upper right hand corner of the screen the\n       number of lines unexcluded and excluded. The lines to be\n       processed may be selected via labels or C/CC/C# line\n       commands - the entire file is processed if no range is\n       specified. A single question mark causes the built in help\n       to be displayed. Pressing function key <F1> will show a\n       slightly more verbose explanation.\n\n       A sample of the display shown is:\n\n          ...           44 NX / 171 X LINES\n          ...              Scroll ===> CSR\n          ...         **********************\n\n       A sample of the more readable message shown after <F1>\n       is pressed for the preceding would be:\n\n          THERE ARE 44 DISPLAYED LINES & 171 EXCLUDED LINES\n\n\n FALT  ( ? )\n+____\n\n       is a dummy macro.  As assigned to a PF Key, it will repeat\n       the last FEXC, FGE, FGT, FLE, FLT, FMAX, FMIN, FN or FPEND\n       command.  Those macros store parameter information in the\n       shared pool. FALT passes a dummy parameter of -=PFK=- to\n       the last command executed and the command will pull the\n       necessary parameters from the shared pool. It always\n       repeats the last of the above find commands.\n\n       It will repeat the command starting from the line on which\n       the cursor is positioned.\n\n\n1                 Display Control Macros (Continued)                 Page     32\n\n FAND   STRING1  STRING2  ...  ( .A .B )\n+____\n\n       excludes all data within the line range or the file and\n       unexcludes every line that contains every specified string.\n       Up to 10 strings may be specified. For example:\n\n          FAND  UNIT  SPACE=  ' DD '\n\n       will show unexcluded only those lines which contain all\n       the strings UNIT, SPACE= and ' DD '. The upper right\n       hand side of the screen will show how many were found.\n\n\n FEXC  ( ? )\n+____\n\n       finds the next excluded line from the top line on the\n       screen, and will make that excluded line the second from\n       the top line.  FALT may be used to repeat the command.  A\n       question mark (?) as parameter will cause the built in\n       help to display.\n\n\n FGE    STRING   ( COL-1 ( COL-2 ) )   ( .A .B )\n+___\n\n       will find the next line following the top line on the\n       displayed page that has a value greater then or equal to\n       the specified string. For instance,\n\n          FGE  '231400'  16\n\n       will make the line with a value greater then or equal to\n       231400 in columns 16 through 21 the second line on the\n       screen. If the value is not found, a not found message\n       appeard in the upper right corner. To do a repeat, make\n       the \"found\" line the top line on the screen and retrieve\n       and re-execute the command or, if you set a PFKey to\n       \"FALT\", that key may be used as a repeat FGE. Obviously,\n       F17 might be a good choice since most PC's use Shift-F5\n       for that key and F5 is normally the repeat find key.\n\n       A FOUND or NOT FOUND message will be placed in the upper\n       right corner of the screen, as appropriate.\n\n\n FGT    STRING   ( COL-1 ( COL-2 ) )   ( .A .B )\n+___\n\n       will find the next line following the top line on the\n       displayed page that has a value greater then the specified\n       string. For instance,\n\n          FGT  'Johnson'  21\n\n       will make the line with a value greater then 'Johnson' in\n1                 Display Control Macros (Continued)                 Page     33\n\n       columns 21 through 27 the second line on the screen. If\n       the value is not found, a not found message appeard in the\n       upper right corner. To do a repeat, make the \"found\" line\n       the top line on the screen and retrieve and re-execute the\n       command or, if you set a PFKey to \"FALT\", that key may be\n       used as a repeat FGT. Obviously, F17 might be a good\n       choice since most PC's use Shift-F5 for that key and F5 is\n       normally the repeat find key.\n\n       A FOUND or NOT FOUND message will be placed in the upper\n       right corner of the screen, as appropriate.\n\n\n FINDDUPX   COL1 COL2  ...  ( .A .B )\n+________\n\n       will show only those lines with duplicate values in the\n       specified columns where the lines follow each other.  No\n+                                                            __\n       sorting is done.  One pair of columns is mandatory; the\n+      _______________\n       label range is optional.  A sample is:\n\n          FINDDUPX  1 8  11 12  .A .B\n\n       will show only adjoining lines with the same values in\n       columns 1 through 8  and 11 through 12 in line range .A\n       through .B. Up to 10 sets of columns may be specified.\n       See FINDDUPS for the version that will sort the data first\n       by the specified columns.\n\n       Given the following data:\n\n          AAA\n          AAA\n          BBB\n          CCC\n          DDD\n          DDD\n          DDD\n          EEE\n\n       the result of 'FINDDUPX  1 3' would be:\n\n          AAA\n          AAA\n          -  - ... -  2 Line(s) not Displayed\n          DDD\n          DDD\n          DDD\n          -  - ... -  1 Line(s) not Displayed\n\n       Note doing a FLIP shows the records that have no dups,\n       and no data or ordering is changed.\n\n1                 Display Control Macros (Continued)                 Page     34\n\n\n FLE    STRING   ( COL-1 ( COL-2 ) )   ( .A .B )\n+___\n\n       will find the next line following the top line on the\n       displayed page that has a value less then or equal to the\n       specified string. For instance,\n\n          FLE  '30,000'  31\n\n       will make the line with a value less then or equal to\n       '30,000' in column columns 31 through 36 the second line\n       on the screen. If the value is not found, a not found\n       message appeard in the upper right corner. To do a repeat,\n       make the \"found\" line the top line on the screen and\n       retrieve and re-execute the command or, if you set a PFKey\n       to \"FALT\", that key may be used as a repeat FLE.\n       Obviously, F17 might be a good choice since most PC's use\n       Shift-F5 for that key and F5 is normally the repeat find\n       key.\n\n       A FOUND or NOT FOUND message will be placed in the upper\n       right corner of the screen, as appropriate.\n\n\n FLT    STRING   ( COL-1 ( COL-2 ) )   ( .A .B )\n+___\n\n       will find the next line following the top line on the\n       displayed page that has a value less then the specified\n       string. For instance,\n\n          FLT  '  '  1\n\n       will make the line with a value less then '  ' (two\n       blanks) in columns 1 and 2 the second line on the screen.\n       If the value is not found, a not found message appeard in\n       the upper right corner. To do a repeat, make the \"found\"\n       line the top line on the screen and retrieve and\n       re-execute the command or, if you set a PFKey to \"FALT\",\n       that key may be used as a repeat FLT. Obviously, F17 might\n       be a good choice since most PC's use Shift-F5 for that key\n       and F5 is normally the repeat find key.\n\n       A FOUND or NOT FOUND message will be placed in the upper\n       right corner of the screen, as appropriate.\n\n\n FMAX  LEFT-COL RIGHT-COL  ( TYPE )  ( .A .B )\n+____\n\n       will find the first line in the range with the highest\n       value.  Columns are mandatory but data type and label\n       range are optional.\n\n       The data type (TYPE) defaults to 'C' for character, which\n       includes both any character string or signed character\n1                 Display Control Macros (Continued)                 Page     35\n\n       strings (e.g. +277, 012 or -935). Other types are 'Z' for\n       zoned data (e.g. 27G, 012 or 93N), 'P' for packed (COMP-3)\n       (recognizing hex D for negative and assuming everything\n       else is positive), and 'B' for binary (using the first bit\n       for the sign and the rest for 2's complement number if\n       negative).\n\n       FALT may be invoked to repeat the find if there are\n       multiple high values. The count of the largest value\n       found and the number of values scanned is shown in the\n       upper right corner as #found/#scanned. A not found message\n       will be shown there when all of the largest values are\n       exhausted.\n\n          FMAX  P  11 15\n\n       will find the largest packed value in columns 11 through\n       15.\n\n\n FMIN  LEFT-COL RIGHT-COL  ( TYPE )  ( .A .B )\n+____\n\n       will find the first line in the range with the lowest\n       value.  Columns are mandatory but data type and label\n       range are optional.\n\n       The data type (TYPE) defaults to 'C' for character, which\n       includes both any character string or signed character\n       strings (e.g. +277, 012 or -935). Other types are 'Z' for\n       zoned data (e.g. 27G, 012 or 93N), 'P' for packed (COMP-3)\n       (recognizing hex D for negative and assuming everything\n       else is positive), and 'B' for binary (using the first bit\n       for the sign and the rest for 2's complement number if\n       negative).\n\n       FALT may be invoked to repeat the find if there are\n       multiple low values. The count of the smallest value\n       found and the number of values scanned is shown in the\n       upper right corner as #found/#scanned. A not found message\n       will be shown there when all of the smallest values are\n       exhausted.\n\n          FMIN  .X .Y  1 23\n\n       will find the smallest value in columns 1 through 23\n       within the line range .X through .Y.\n\n\n FN    STRING   ( COL-1 ( COL-2 ) )   ( .A .B )\n+__\n\n       will find the next line that does not contain the\n       specified string anywhere in the specified columns.  For\n       example:\n\n1                 Display Control Macros (Continued)                 Page     36\n\n          FN  ' DD '  2 20  .XX .YY\n\n       will find the next line that does not contain ' DD '\n       between columns 2 through 20. Another example, probably\n       more realistic, is:\n\n          FN  '747'  16\n\n       which will find the next line that does not contain 747 in\n       column2 16 through 18.\n\n       If you set a PFKey to \"FALT\", that key may be used\n       as a repeat FN. Obviously, F17 might be a good choice\n       since most PC's use Shift-F5 for that key and F5 is\n       normally the repeat find key.\n\n       When at the end of the file, FN will \"wrap\" to the top of\n       the file. If no line is found to satisy the 'not equal'\n       condition, a 'NOT FOUND' appears in the upper right hand\n       corner of the screen.\n\n\n FNB  ( STARTING-COLUMN  ( ENDING-COLUMN ) )  ( ? )\n+___\n\n      finds the non blank character, if any, from column 73\n      through the last logical byte of data, by default. If the\n      STARTING-COLUMN is specified, it will use that value as the\n      beginning column through the last logical byte or through\n      the ENDING-COLUMN if specified. The standard repeat\n      function key (usually PF Key 5) may be used to continue the\n      function.\n\n      For example,\n\n         FNB  47\n\n      will find the first non blank character from column 47\n      through the logical record length (LRECL) if any.\n\n\n FNOT   STRING1  ...  ( .A .B )\n+____\n\n       excludes all data within the line range or the file and\n       unexcludes every line that does not contain any of the\n       specified strings.  Up to 10 strings may be specified. For\n       example:\n\n          FNOT  PROC  ' DD '  PEND\n\n       will show unexcluded only those lines which contain\n       neither PROC, ' DD ', nor PEND. This relates to both the\n       FAND and FOR macros.\n\n\n1                 Display Control Macros (Continued)                 Page     37\n\n FOR    STRING1  ...  ( .A .B )\n+___\n\n       excludes all data within the line range or the file and\n       unexcludes every line that contains any of the specified\n       strings.  Up to 10 strings may be specified. For example:\n\n          FOR  2314  3350  CART  TAPE\n\n       will show unexcluded only those lines which contain either\n       '2314', '3350', CART or TAPE.\n\n\n FPEND  ( Next | First | Previous | ? )\n+_____\n\n       will find a pending line command in the file, i.e.  the\n       line that has an unexecuted prefix command such as CC or\n       M9999. The direction may be abbreviated as only the first\n       character, e.g. F. The default is to find the next pending\n       line command.  Specifying a question mark (?) as the\n       parameter will cause the built in help to be displayed.\n\n       If you set a PFKey to \"FALT\", that key may be used as a\n       repeat FPEND. Obviously, F17 might be a good choice since\n       most PC's use Shift-F5 for that key and F5 is normally the\n       repeat find key. If the last direction was First, then the\n       Next pending command is found.\n\n\n FX     STRING1\n+__\n\n       excludes all lines and shows only lines with the string\n       and a few lines above and below those found.  This uses\n       the COMPARE EXCLUDE command to perform the line exclude\n       function (type COMPARE in Edit).\n\n       For example, given the following data:\n\n          DDD\n          BBB\n          AAA\n          EEE\n          CCC\n          FFF\n          DDD\n          DDD\n          ZZZ\n          AAA\n          CCC\n\n       the result of 'FX  CCC' would be:\n\n          -  -  ...  -  3 Line(s) not Displayed\n          EEE\n1                 Display Control Macros (Continued)                 Page     38\n\n          CCC\n          FFF\n          -  -  ...  -  3 Line(s) not Displayed\n          AAA\n          CCC\n\n       where the Display Options with Exclude (Compare command)\n       is set to 1.\n\n\n LESS    ( BEFORE(#) )   ( AFTER(#) )   ( .A .B )  ( ? )\n+____\n\n       excludes the number of lines specified by BEFORE(#) in\n       front of any currently excluded lines and the number of\n       lines specified by AFTER(#) following any currently\n       excluded lines in the selected range.  A range to be\n       processed may be specified via a label range as parameters\n       or a C/CC/C# range by data prefix.  The entire file will\n       be processed if no explicit range is selected.  The\n       defaults are BEFORE(1) and AFTER(1).  Given:\n\n          LESS\n\n       will cause one line before of each group of excluded lines\n       to be excluded and one line following each group to be\n       excluded.  This is equivalent to typing a prefix command\n       of 'X' on the unexcluded lines immediately before and\n       after each excluded group of lines.  Another example is:\n\n          LESS  BEFORE(0)  AFTER(2)  .KK .LL\n\n       which will exclude no lines before any group of excluded\n       lines and 2 lines following of each group in the line\n       range .KK through .LL.\n\n       A parameter of ? causes the built in help to be displayed.\n\n       Given data (from the FX example above):\n\n          -  -  ...  -  3 Line(s) not Displayed\n          EEE\n          CCC\n          FFF\n          -  -  ...  -  3 Line(s) not Displayed\n          AAA\n          CCC\n\n       The result of 'LESS' would be:\n\n          -  -  -  4 Line(s) not Displayed\n          CCC\n          -  -  -  5 Line(s) not Displayed\n          CCC\n\n1                 Display Control Macros (Continued)                 Page     39\n\n\n LONGEST   ( .A .B )  ( ? )\n+_______\n\n       makes the first line with the longest length the top line\n       on the display.  The actual length is shown in the upper\n       right message area as well as the number of such length\n       records in the range.\n\n       For fixed record format data, the longest record has the\n       smallest number of blanks on the right side of the line.\n\n       Either labels or C/CC/C# may be used to limit the length\n       check.  A ? as the only parameter will cause the built in\n       help to be displayed.\n\n\n MORE    ( BEFORE(#) )   ( AFTER(#) )   ( .A .B )  ( ? )\n+____\n\n       unexcludes the number of lines specified by BEFORE(#) at\n       the beginning of any currently excluded lines and the\n       number of lines specified by AFTER(#) at the end of any\n       currently excluded lines within the range selected.  The\n       range may be specified via a label range as parameters or\n       a C/CC/C# data prefix selection. The entire file will be\n       processed if no range is specifically selected.  The\n       defaults are BEFORE(1) and AFTER(1).  For example,\n\n          MORE\n\n       will cause one line at the beginning of each group of\n       excluded lines to be unexcluded and one line following\n       each group will be unexcluded.  Another example is:\n\n          MORE  BEFORE(2)  AFTER(2)\n\n       which will unexclude two lines at the beginning of any\n       group of excluded lines and 2 lines at the end of each\n       group.\n\n       A parameter of ? causes the built in help to be displayed.\n       Given data (from the FX example above):\n\n          -  -  ...  -  3 Line(s) not Displayed\n          EEE\n          CCC\n          FFF\n          -  -  ...  -  3 Line(s) not Displayed\n          AAA\n          CCC\n\n       The result of 'MORE' would be:\n\n          DDD\n          -  -  -  -  1 Line(s) not Displayed\n1                 Display Control Macros (Continued)                 Page     40\n\n          AAA\n          EEE\n          CCC\n          FFF\n          DDD\n          -  -  -  -  1 Line(s) not Displayed\n          ZZZ\n          AAA\n          CCC\n\n\n REALUNIX  COL1 COL2  ...  ( .A .B )\n+________\n\n       will exclude the specified range of lines or the entire\n       file and unexclude the records with no other contiguous\n       records with the same values in the specified columns.  No\n       sorting is performed before checking for unique values.\n       For example:\n\n          REALUNIX  1  8\n\n       will scan the file by columns 1 thru 8 and show only the\n       really unique records.  Up to 10 pairs of columns are\n       supported.  Please see REALUNIQ for a version that sorts\n       prior to processing.  For example, given data as follows:\n\n          111\n          222\n          222\n          333\n          444\n          444\n          444\n          555\n          555\n          555\n\n       doing a REALUNIQ 1 3 will result in:\n\n          111\n          -  -  -  -  -  -  -  -  -  -  -  2 Line(s) not Displayed\n          333\n          -  -  -  -  -  -  -  -  -  -  -  6 Line(s) not Displayed\n\n       Please note the data is assumed to be in proper order, And\n       see REALUNIQ for the equivalent function that performs a\n       sort before processing the data.  Using the standard FLIP\n       command will produce those lines that are duplicated, i.e.\n       on the above\n\n          -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed\n          222\n          222\n          -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed\n1                 Display Control Macros (Continued)                 Page     41\n\n          444\n          444\n          444\n          555\n          555\n          555\n\n\n SHORTEST   ( .A .B )  ( ? )\n+________\n\n       makes the first line with the smallest length the top line\n       on the display.  The actual length is shown in the upper\n       right message area as well as the number of records of\n       such size in the range.\n\n       For fixed record format data, the shortest record has the\n       largest number of blanks on the right side of the line.\n\n       Either labels or C/CC/C# may be used to limit the length\n       check; will process the entire file if neither is\n       specified.  Obviously most useful for variable length\n       files. A ? will cause the built in help to be displayed.\n\n\n SNACK   ( ? )\n+_____\n\n       does an X ALL and then a FIND ALL against the field the\n       cursor was on.  The field must be delimited by blanks or\n       at the start or end of a line with a blank toward the\n       inside of the data.  Ideally, this macro would be assigned\n       to a PF Key.\n\n       For  the following:\n\n           FD  O\n               RECORDING MODE IS F\n               BLOCK CONTAINS 0 RECORDS.\n           01  OUTPUT-REC   PIC X(00080).\n\n           WORKING-STORAGE SECTION.\n          *------------------------*\n\n           01  WS-INPUT-REC                 PIC X(00080).\n           01  WS-SAVE-REC                  PIC X(00080).\n\n       if the cursor were positioned on OUTPUT-REC, the resulting\n       screen might look like:\n\n          -  -  -  -  -  -  -  -  -  -  -  - 60 Line(s) not Displayed\n           01  OUTPUT-REC   PIC X(00080).\n          -  -  -  -  -  -  -  -  -  -  -  - 72 Line(s) not Displayed\n                   WRITE OUTPUT-REC FROM WS-INPUT-REC\n          -  -  -  -  -  -  -  -  -  -  -  - 11 Line(s) not Displayed\n                   WRITE OUTPUT-REC FROM WS-INPUT-REC\n1                 Display Control Macros (Continued)                 Page     42\n\n          -  -  -  -  -  -  -  -  -  -  -  - 60 Line(s) not Displayed\n\n       If the macro is specified on the command line with only a\n       question mark (?) as its parameter, built in help is\n       displayed.\n\n\n UNIQUEX   COL1 COL2  ...  ( .A .B )\n+_______\n\n       will exclude the specified range of lines or the entire\n       file and unexclude the first (or only) record with unique\n       values in the specified columns of contiguous records.  No\n       sorting is performed before checking for unique values.\n       For example:\n\n          UNIQUEX  1  8\n\n       will scan the file by columns 1 thru 8 and show only the\n       first occurrence of each value in those columns. Up to 10\n       pairs of columns are supported. Data should be in proper\n       order by the columns specified. Please also see UNIQUE\n       which sorts the data first.\n\n       For example, given the following data:\n\n          DDDDDD\n          BBBBBB\n          AAAAAA\n          EEEEEE\n          CCCCCC\n          DDDDDD\n          DDDDDD\n          DDDDDD\n          DDDDDD\n          AAAAAA\n          CCCCCC\n\n       invoking 'UNIQUE  1 10' will result in:\n\n          DDDDDD\n          BBBBBB\n          AAAAAA\n          EEEEEE\n          CCCCCC\n          DDDDDD\n          -  -  -  -      3 Line(s) not Displayed\n          AAAAAA\n          CCCCCC\n\n\n1                      Line Manipulation Macros                      Page     43\n\n\n The following macros will change the file being Viewed or\n Edited, removing blank lines, eliminating duplicate lines,\n showing only duplicate records, showing only unique records, and\n pulling all excluded lines to the top of the file.\n\n Data will be changed, as opposed to display format commands.\n+____________________\n\n Built in help is available by either typing the macro name\n without any parameters (for those with mandatory parameters) or\n with just a question mark (?) as the only operand.\n\n\n CONBLANK   ( ? )  ( .A .B )\n+________\n\n       will consolidate 2 or more blank lines to 1 within the\n       file or within the label range specified.  For example,\n\n          CONBLANK\n\n       will every occurrence of two or more blank lines in the\n       file to be consolidated to one.  If ? is specified as the\n       first or only parameter, then the inline help is displayed\n       without doing any deletions.\n\n\n DELBLANK   ( ? )  ( .A .B )\n+________\n\n       will delete all blank lines from the file or from the\n       label range specified.  For example,\n\n          DELBLANK\n\n       will cause every blank line in the file to be deleted.  If\n       ? is specified as the first or only parameter, then the\n       inline help is displayed without doing any deletions.\n\n\n DELDUPS   COL1 COL2  ...  ( .A .B )\n+_______\n\n       will sort the selected data, if range labels are\n       specified, or the entire file by the specified columns and\n       delete all lines with duplicate values in the specified\n       columns after the first occurrence.  For example,\n\n          DELDUPS  21 27  1 3\n\n       will sort the file by columns 21 thru 27 and 1 thru 3 and\n       delete any duplicate occurrences, i.e.  where the complete\n       set of keys is the same.  Up to 10 pairs of columns are\n       supported.\n\n1                Line Manipulation Macros (Continued)                Page     44\n\n       Given the following data:\n\n          DDDDDD    4444\n          ----+----1----+----2\n          DDDDDD    4444\n          EEEEEE    5555\n          CCCCCC    3333\n          BBBBBB    2222\n          DDDDDD    4444\n          AAAAAA    1111\n          DDDDDD    4444\n          AAAAAA    1111\n          DDDDDD    4444\n          ----+----1----+----2\n          CCCCCC    3333\n\n       the result of 'DELDUPS  11 14  1 6' would be:\n\n          AAAAAA    1111\n          ----+----1----+----2\n          BBBBBB    2222\n          CCCCCC    3333\n          DDDDDD    4444\n          ----+----1----+----2\n          EEEEEE    5555\n\n       Please note the data is now in order by the columns\n       specified and there are no duplicate entries left.\n\n\n DELDUPX    COL1 COL2  ...  ( .A .B )\n+_______\n\n       will scan, without sorting, the entire file using the\n       specified columns and delete all lines with duplicate\n       values in the specified columns after the first\n       occurrence.  For example,\n\n          DELDUPX  11 17  1 3\n\n       will scan the file by columns 11 thru 17 and 1 thru 3 and\n       delete any duplicate occurrences.  Up to 10 pairs of\n       columns are supported.\n\n       If the following data is the starting point:\n\n          =COLS> ----+----1\n          .AA    BBBBBB\n          000004 CCCCCC\n          000005 CCCCCC\n          000006 DDDDDD\n          000007 DDDDDD\n          000008 DDDDDD\n          .BB    DDDDDD\n          =COLS> ----+----1\n1                Line Manipulation Macros (Continued)                Page     45\n\n\n       the result of 'DELDUPX  1 6  .AA .BB' would be:\n\n          =COLS> ----+----1\n          .AA    BBBBBB\n          000004 CCCCCC\n          000005 DDDDDD\n          =COLS> ----+----1\n\n\n FINDDUPS   COL1 COL2  ...  ( .A .B )\n+________\n\n       will sort the entire file, or the range selected lines, by\n       the specified columns and exclude any lines that are not\n       duplicates. The shown data lines will only be dups. For\n       example:\n\n          FINDDUPS  11 17  1 3\n\n       will sort the file by columns 11 thru 17 and 1 thru\n       3 and show only the lines with dup values in those\n       columns. Up to 10 pairs of columns are supported.\n       The label range is optional.\n\n       Given the following data:\n\n          DDDDDD\n          BBBBBB\n          AAAAAA\n          EEEEEE\n          CCCCCC\n          DDDDDD\n          DDDDDD\n          DDDDDD\n          DDDDDD\n          AAAAAA\n          CCCCCC\n\n       a 'FINDDUPS  1 10' will have as its result:\n\n          AAAAAA\n          AAAAAA\n          -  -  -  - ... -  1 Line(s) not Displayed\n          CCCCCC\n          CCCCCC\n          DDDDDD\n          DDDDDD\n          DDDDDD\n          DDDDDD\n          DDDDDD\n          -  -  -  - ... -  1 Line(s) not Displayed\n\n       Please note the data is sorted, the \"unique\" BBBBBB and\n       EEEEEE lines are excluded while all the duplicate data is\n1                Line Manipulation Macros (Continued)                Page     46\n\n       shown.  FLIP would obviously return the unique values as\n       shown and the duplicates as excluded.\n\n\n GATHERX  ( ? )\n+_______\n\n       will cause all excluded lines to be brought to the top of\n       the file or to the top of the lines marked by C/CC/C#.  If\n       there are none, nothing is changed.  The excluded and\n       unexcluded lines are kept in the same order respectively.\n\n       So if the initial file contained:\n\n          AAA\n          -  -  -  -  -  -  -  -  -  -  -  -  2 Line(s) not Displayed\n          BBB\n          -  -  -  -  -  -  -  -  -  -  -  -  3 Line(s) not Displayed\n          CCC\n          -  -  -  -  -  -  -  -  -  -  -  -  4 Line(s) not Displayed\n\n       The file, after GATHERX is executed, would look like:\n\n          -  -  -  -  -  -  -  -  -  -  -  -  9 Line(s) not Displayed\n          AAA\n          BBB\n          CCC\n\n       The nine excluded lines would be in the same order as\n       originally seen, just all moved to the top of the file.\n\n       If a question mark (?) is specified as the parameter, the\n       inline help is displayed without moving any lines.\n\n\n REALUNIQ  COL1 COL2  ...  ( .A .B )\n+________\n\n       will sort and exclude the specified range of lines or the\n       entire file and unexclude the records which no other\n       records with the same values in the specified columns.\n       For example:\n\n          REALUNIQ  1  8\n\n       will sort the file by columns 1 thru 8 and show only the\n       really unique records.  Up to 10 pairs of columns are\n       supported.  Please see REALUNIX for a version that does\n       not sort prior prior to processing.  For example, given\n       data as follows (note these are NOT in sorted order):\n\n          444\n          555\n          555\n          333\n          111\n1                Line Manipulation Macros (Continued)                Page     47\n\n          555\n          444\n          222\n          222\n          444\n\n       doing a REALUNIQ 1 3 will result in:\n\n          111\n          -  -  -  -  -  -  -  -  -  -  -  2 Line(s) not Displayed\n          333\n          -  -  -  -  -  -  -  -  -  -  -  6 Line(s) not Displayed\n\n       Using the standard FLIP command will produce those lines\n       that are duplicated, i.e. on the above\n\n          -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed\n          222\n          222\n          -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed\n          444\n          444\n          444\n          555\n          555\n          555\n\n\n REVERSEX  ( ? )\n+________\n\n       will cause the marked (via C/CC/C##) range of lines to be\n       reversed.  If no range is specified, the entire file is\n       reversed.  This is essentially a \"flip\" command for the\n       lines involved. A question mark (?) as parameter will\n       cause the built in help to be displayed.\n\n       For example, using REVERSEX on\n\n           AAAAAA\n           BBBBBB\n           CCCCCC\n           DDDDDD\n           EEEEEE\n\n       would result in:\n\n           EEEEEE\n           DDDDDD\n           CCCCCC\n           BBBBBB\n           AAAAAA\n\n\n1                Line Manipulation Macros (Continued)                Page     48\n\n SHUFFLE  ( ? )\n+_______\n\n      pseudo randomly rearranges the sequence of an entire file\n      or of some subset specified by C, CC or C## prefix\n      commands. The only possible parameter is a question mark\n      which will cause the built in help to be displayed.\n\n      Uses the REXX random number generator to determine a new\n      position for each line selected. This is useful for\n      testing when the order of input might be of consequence.\n\n      If a question mark (?) is specified as the parameter, the\n      inline help is displayed without moving any lines.  Please\n      see RANCOLS0 which would allow repeatable sorting for\n      consistent testing.\n\n       For example, using SHUFFLE on\n\n           AAAAAA\n           BBBBBB\n           CCCCCC\n           DDDDDD\n           EEEEEE\n\n       could result in:\n\n           BBBBBB\n           CCCCCC\n           AAAAAA\n           DDDDDD\n           EEEEEE\n\n\n SORTNX   COL1 COL2  ...  ( .A .B )\n+______\n\n       will sort the selected data by the specified columns of\n       the non excluded records keeping the excluded records\n       following each sorted record with that record. That is:\n\n          SORTNX  1 12\n\n       will sort the following records\n\n          rec#5555\n          --- some excluded lines associated with rec#5555 ---\n          rec#9999\n          --- some excluded lines associated with rec#9999 ---\n          rec#4444\n          rec#0000\n          --- some excluded lines associated with rec#0000 ---\n\n       producing\n\n1                Line Manipulation Macros (Continued)                Page     49\n\n          rec#0000\n          --- some excluded lines associated with rec#0000 ---\n          rec#4444\n          rec#5555\n          --- some excluded lines associated with rec#5555 ---\n          rec#9999\n          --- some excluded lines associated with rec#9999 ---\n\n       So the excluded records \"stick to\" their immediately\n       preceding non excluded records.  Up to 10 pairs of columns\n       are supported. The label range is optional.\n\n\n UNIQUE   COL1 COL2  ...  ( .A .B )\n+______\n\n       will sort the selected data by the specified columns,\n       exclude the range selected or the entire file, and\n       unexclude the first (or only) record with unique values in\n       the specified columns.  The first pair of columns are\n       mandatory.\n\n       For example:\n\n          UNIQUE  1  8\n\n       will sort the file by columns 1 thru 8 and show only the\n       first occurrence of each value in those columns. Up to 10\n       pairs of columns are supported. Please see UNIQUEX if no\n       sort is needed.\n\n       For example, given the following data:\n\n          DDDDDD\n          BBBBBB\n          AAAAAA\n          EEEEEE\n          CCCCCC\n          DDDDDD\n          DDDDDD\n          DDDDDD\n          DDDDDD\n          AAAAAA\n          CCCCCC\n\n       invoking 'UNIQUE  1 10' would result in:\n\n          AAAAAA\n          -  -  -  - ... -  1 Line(s) not Displayed\n          BBBBBB\n          CCCCCC\n          -  -  -  - ... -  1 Line(s) not Displayed\n          DDDDDD\n          -  -  -  - ... -  4 Line(s) not Displayed\n          EEEEEE\n1                Line Manipulation Macros (Continued)                Page     50\n\n\n\n1                    Code/Data Manipulation Macros                   Page     51\n\n\n The following macros are primarily intended for use in coding.\n Some, such as ALIGN or SPLITAFT, may be useful elsewhere.\n\n\n ALIGN  ( CHARS | ? )\n+_____\n\n       aligns the text at the right most character(s) specified.\n       It will only process C/C#/CC selected lines or the whole\n       file if no range is specified.  For example:\n\n          ALIGN  'PIC 9(9)'\n\n       used on the following lines:\n\n          01  WORK-AREAS.\n              05  NUMBER-RECORDS-ADDED PIC 9(9)  VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-DELETED PIC 9(9)  VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-DUPS PIC 9(9)  VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-READ PIC 9(9)  VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-UPDATED PIC 9(9)  VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-WRITTEN PIC 9(9)  VALUE 0 COMP-3.\n              05  FINAL-RETURN-CODE PIC 9(4)  VALUE 0 COMP.\n\n       will result in:\n\n          01  WORK-AREAS.\n              05  NUMBER-RECORDS-ADDED   PIC 9(9) VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-DELETED PIC 9(9) VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-DUPS    PIC 9(9) VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-READ    PIC 9(9) VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-UPDATED PIC 9(9) VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-WRITTEN PIC 9(9) VALUE 0 COMP-3.\n              05  FINAL-RETURN-CODE PIC 9(4)  VALUE 0 COMP.\n\n       Note the first and last lines are not reformatted since\n       they do not contain the specified character(s).  Quotes,\n       either single or double, are only necessary if blanks or\n       oddball special characters are contained.  No arguments or\n       a single question mark will cause built in help to be\n       displayed.\n\n       COBOL comment and debug lines will not be re-aligned!\n+      _____________________________________________________\n       Please see ALIGNS below for a more compact alignment.\n\n\n ALIGNALL  CHARS\n+________\n\n       aligns the fields of the records selected at the\n       character(s) specified based on the maximum size of each\n       field in that range.  No argument specified will cause\n       built in help to be displayed.  It will only process\n1              Code/Data Manipulation Macros (Continued)             Page     52\n\n       C/C#/CC selected lines or the whole file if no range is\n       specified.  For example:\n\n          ALIGNALL  !\n\n       used on the following lines:\n\n          aaa!aaa!aaa!aaa\n          b!b!b!b\n          ccccc!cc!cccccccc!c\n          dddd!dddd!dddd!dddd\n\n       will result in:\n\n          aaa  !aaa !aaa     !aaa\n          b    !b   !b       !b\n          ccccc!cc  !cccccccc!c\n          dddd !dddd!dddd    !dddd\n\n       Note that every field has been expanded to the maximum\n       size needed to hold that field, e.g. the 3rd field now\n       is 8 characters to hold the 8 c's in the 3rd record and\n       the 2nd field is 4 bytes to hold the 4 d's in the last\n       record.\n\n       Please see ALIGN above, and ALIGNAX AND ALIGNS below for\n       variations on the alignment concept.\n\n\n ALIGNAX  CHARS\n+_______\n\n       aligns the fields of the records selected at the\n       character(s) specified based on the maximum size of each\n       field in that range, removing the delimiter.  No argument\n       specified will cause built in help to be displayed.  It\n       will only process C/C#/CC selected lines or the whole file\n       if no range is specified.  For example:\n\n          ALIGNAX  !\n\n       used on the following lines:\n\n          aaa!aaa!aaa!aaa\n          b!b!b!b\n          ccccc!cc!cccccccc!c\n          dddd!dddd!dddd!dddd\n\n       will result in:\n\n          aaa  aaa aaa     aaa\n          b    b   b       b\n          ccccccc  ccccccccc\n          dddd dddddddd    dddd\n\n1              Code/Data Manipulation Macros (Continued)             Page     53\n\n       Note that every field has been expanded to the maximum\n       size needed to hold that field, e.g. the 3rd field now\n       is 8 characters to hold the 8 c's in the 3rd record and\n       the 2nd field is 4 bytes to hold the 4 d's in the last\n       record.\n\n       Please see ALIGN and ALIGNALL above and ALIGNS below for\n       variations on the alignment concept.  This is basically\n       the same macro as ALIGNALL with the difference that the\n       delimiter is removed.\n\n\n ALIGNS  ( CHARS | ? )\n+______\n\n       aligns the text at the right most character(s) specified\n       with minimal spacing.  It will only process C/C#/CC\n       selected lines or the whole file if no range is specified.\n       For example:\n\n          ALIGNS  'PIC 9(9)'\n\n       used on the following lines:\n\n          01  WORK-AREAS.\n              05  NUMBER-RECORDS-ADDED PIC 9(9)  VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-DELETED PIC 9(9)  VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-DUPS       PIC 9(9)  VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-READ  PIC 9(9)  VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-UPDATED PIC 9(9)  VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-WRITTEN    PIC 9(9)  VALUE 0 COMP-3.\n              05  FINAL-RETURN-CODE PIC 9(4)  VALUE 0 COMP.\n\n       will result in:\n\n          01  WORK-AREAS.\n              05  NUMBER-RECORDS-ADDED   PIC 9(9) VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-DELETED PIC 9(9) VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-DUPS    PIC 9(9) VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-READ    PIC 9(9) VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-UPDATED PIC 9(9) VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-WRITTEN PIC 9(9) VALUE 0 COMP-3.\n              05  FINAL-RETURN-CODE PIC 9(4)  VALUE 0 COMP.\n\n       Note the first and last lines are not reformatted and only\n       one blank is used to separate the chosen characters from\n       the preceding text.  Quotes, either single or double, are\n       only necessary if blanks or oddball special characters are\n       contained.  No arguments or a single question mark will\n       cause built in help to be displayed.\n\n       COBOL comment and debug lines will not be re-aligned!\n+      _____________________________________________________\n       Please see ALIGN above for a slightly different variation\n       on separation.\n1              Code/Data Manipulation Macros (Continued)             Page     54\n\n\n\n BC   ( LEFT-COL  RIGHT-COL )  ( .A .B )\n+__\n\n       will place blanks in the selected columns. LEFT-COL and\n       RIGHT-COL default to 73 and 80. C/CC/C# or labels may be\n       used to select the lines impacted.  If no range is\n       specified, the entire file is processed.\n\n          BC\n\n       will cause columns 73 through 80 of every line to be\n       blanked. A question mark (?) as the first operand will\n       cause inline help to be displayed.\n\n\n COBCOLO  ( ? )\n+_______\n\n      invokes FileAid (COBCOLOF) or InSync (COBCOLOI) programs to\n      determine the offsets for COBOL data structures and places\n      them in columns 73 through 80 as ZZZ9-ZZ9. The starting\n      position goes from 1 to 9999 while the ending position will\n      only show the last 3 digits. The C/C#/CC prefix commands\n      may be used to limit the columns processed.\n\n      This is the old version of COBCOLS which uses all 8\n      positions to show the offsets. Please see its documentation\n      below.\n\n      The question mark will cause the built in help to be\n      displayed.\n\n      An example is:\n\n       01 REQ-FRM-REQUEST.                                   1- 48\n           05 REQ-CCS-KEY.                                   1- 48\n               10 REQ-CCS-CALLER          PIC X(01).         1-  1\n      *        10 REQ-CCS-CUST-NO         PIC X(18).\n               10 REQ-CCS-CUST-NO         PIC X(20).         2- 21\n               10 REQ-CCS-GROUP           PIC X(03).        22- 24\n               10 REQ-CCS-SUBGROUP        PIC X(15).        25- 39\n               10 REQ-CCS-TIME            PIC 9(13) COMP-3. 40- 46\n               10 REQ-CCS-TIME-X                            40- 46\n                  REDEFINES REQ-CCS-TIME  PIC X(07).\n               10 REQ-CCS-SEQ             PIC 9(02).        47- 48\n\n      Note that the commented statement is ignored.\n\n      A limitation on this command is that array sub-structures\n      are not processed. Please see COBCOLV below for a variant\n      which will show those offsets.\n\n\n1              Code/Data Manipulation Macros (Continued)             Page     55\n\n COBCOLS  ( ? )\n+_______\n\n      invokes FileAid (COBCOLSF) or InSync (COBCOLSI version) to\n      determine the offsets for COBOL data structures and places\n      them in columns 73 through 80 as ZZZ9ZZZ9. The starting and\n      ending positions run from 1 through 9999.  The C/C#/CC\n      prefix commands may be used to limit the columns processed.\n\n      This is the new version of COBCOLO which used less then 4\n      positions to show the offsets. Please see its documentation\n      above. Also see COBCOLV below.\n\n      The question mark will cause the built in help to be\n      displayed but will not invoke the code.\n\n      An example is:\n\n       01 REQ-FRM-REQUEST.                                    1  48\n           05 REQ-CCS-KEY.                                    1  48\n               10 REQ-CCS-CALLER          PIC X(01).          1   1\n      *        10 REQ-CCS-CUST-NO         PIC X(18).\n               10 REQ-CCS-CUST-NO         PIC X(20).          2  21\n               10 REQ-CCS-GROUP           PIC X(03).         22  24\n               10 REQ-CCS-SUBGROUP        PIC X(15).         25  39\n               10 REQ-CCS-TIME            PIC 9(13) COMP-3.  40  46\n               10 REQ-CCS-TIME-X                             40  46\n                  REDEFINES REQ-CCS-TIME  PIC X(07).\n               10 REQ-CCS-SEQ             PIC 9(02).         47  48\n\n      Note that the commented statement is ignored.\n\n      A limitation on this command is that array sub-structures\n      are not processed. Please see COBCOLV below for a variant\n      which will show those offsets.\n\n\n COBCOLV  ( ? )\n+_______\n\n      invokes FileAid (COBCOLVF) or InSync (COBCOLVI) to generate\n      a record layout and then View that output in a separate\n      session.  The C/C#/CC prefix commands may be used to limit\n      the columns processed.\n\n      This is a variant of the COBCOLO and COBCOLS macros above\n      without the array sub-structure limitation.\n\n      The question mark will cause the built in help to be\n      displayed but will not invoke the code.\n\n      A sample input for which COBCOLVF was invoked follows:\n\n       01 REQ-FRM-REQUEST.\n           05 REQ-CCS-KEY.\n1              Code/Data Manipulation Macros (Continued)             Page     56\n\n               10 REQ-CCS-CALLER          PIC X(01).\n      *        10 REQ-CCS-CUST-NO         PIC X(18).\n               10 REQ-CCS-CUST-NO         PIC X(20).\n               10 REQ-CCS-GROUP           PIC X(03).\n               10 REQ-CCS-SUBGROUP        PIC X(15).\n               10 REQ-CCS-TIME            PIC 9(13) COMP-3.\n               10 REQ-CCS-TIME-X\n                  REDEFINES REQ-CCS-TIME  PIC X(07).\n               10 REQ-CCS-SEQ             PIC 9(02).\n               10 REQ-ARRAY  OCCURS 5 TIMES.\n                   15 REQ-CCS-REP         PIC X(03).\n                   15 REQ-CCS-REP-STAT    PIC 9(01).\n               10                         PIC X(12).\n\n      And the resultant output, for the InSync version, slightly\n      truncated to fit here, looks like:\n\n         01  REQ-FRM-REQUEST                 G            1     80\n           05  REQ-CCS-KEY                   G            1     80\n             10  REQ-CCS-CALLER              C    1       1      1\n             10  REQ-CCS-CUST-NO             C   20       2     20\n             10  REQ-CCS-GROUP               C    3      22      3\n             10  REQ-CCS-SUBGROUP            C   15      25     15\n             10  REQ-CCS-TIME                P   13      40      7\n             10  REQ-CCS-TIME-X              C    7      40      7\n                     REDEFINES REQ-CCS-TIME\n             10  REQ-CCS-SEQ                 Z    2      47      2\n             10  REQ-ARRAY(1)                G           49      4\n                     OCCURS     5 TIMES\n               15  REQ-CCS-REP(1)            C    3      49      3\n               15  REQ-CCS-REP-STAT(1)       Z    1      52      1\n             10  REQ-ARRAY(2)                G           53      4\n               15  REQ-CCS-REP(2)            C    3      53      3\n               15  REQ-CCS-REP-STAT(2)       Z    1      56      1\n             10  REQ-ARRAY(3)                G           57      4\n               15  REQ-CCS-REP(3)            C    3      57      3\n               15  REQ-CCS-REP-STAT(3)       Z    1      60      1\n             10  REQ-ARRAY(4)                G           61      4\n               15  REQ-CCS-REP(4)            C    3      61      3\n               15  REQ-CCS-REP-STAT(4)       Z    1      64      1\n             10  REQ-ARRAY(5)                G           65      4\n               15  REQ-CCS-REP(5)            C    3      65      3\n               15  REQ-CCS-REP-STAT(5)       Z    1      68      1\n             10  FILLER                      C   12      69     12\n\n      Note the data types, starting position, ending position\n      and length shown for a non commented data items.\n\n      The above example shows the expanded array layout.\n\n\n1              Code/Data Manipulation Macros (Continued)             Page     57\n\n DELPARA\n+_______\n\n       will delete all DISPLAY statements inserted by DISPARA\n       and DISPVAR in COBOL code.  For example:\n\n          DELPARA\n\n       will delete DISPLAY '~DEBUG~ 0100-INITIALIZATION. ' which\n       had been inserted by DISPARA immediately after paragraph\n       0100-INITIALIZATION. Please see DISPARA and DISPVAR below.\n\n\n DISPARA\n+_______\n\n       will insert a DISPLAY statement after each paragraph in\n       COBOL code.  For example:\n\n          DISPARA\n\n       will insert DISPLAY '~DEBUG~ 0100-INITIALIZATION'\n       immediately after paragraph 0100-INITIALIZATION.  The\n       DELPARA command will remove all the inserted lines.\n       Please see DELPARA above.\n\n       If the code contains exit paragraphs of the form\n\n           0100-INITIALIZATION-EXIT.  EXIT.\n\n       DISPARA will split the line leaving the EXIT. on the\n       second line and then add the DISPLAY line after the\n       paragraph name line.  So the result from the above would\n       be:\n\n           0100-INITIALIZATION-EXIT.\n               DISPLAY '~DEBUG~ 0100-INITIALIZATION'\n                                      EXIT.\n\n\n DISPVAR\n+_______\n\n       inserts a DISPLAY statement for the variable with the\n       cursor on it.  For example if invoked with the cursor\n       anywhere on NUMBER-RECORDS-READ, the next two lines will\n       be inserted:\n\n               NOT AT END ADD 1 TO NUMBER-RECORDS-READ\n           DISPLAY '~DEBUG~ NUMBER-RECORDS-READ = >'\n             NUMBER-RECORDS-READ '< ~DEBUG~'\n\n       Note all lines generated contain ~DEBUG~ so DELPARA may be\n       used to delete them when no longer necessary.  Variables\n       named like WS-DATA (12) (2:5) will work just fine.  If there\n       are spaces within or outside the parentheses in the\n1              Code/Data Manipulation Macros (Continued)             Page     58\n\n       subscript and/or reference modification, DISPVAR will\n       handle it appropriately but the cursor MUST be positioned\n+                                             ____\n       on the name, i.e. WS-DATA in WS-DATA ( 12 ) ( 2 : 5 ).\n\n       IN or OF constructs are also handled even if on the line\n       below where the cursor is positioned. For example, if the\n       cursor is on WS-SECURITY-NUMBER in the following:\n\n           ADD WS-INCR TO WS-SEC-NUMBER\n               OF WS-INPUT-RECORD ( ITEM - 3 )\n\n       the resultant code would be:\n\n           ADD WS-INCR TO WS-SEC-NUMBER\n               OF WS-INPUT-RECORD ( ITEM - 3 )\n           DISPLAY '~DEBUG~ WS-SEC-NUMBER OF WS-INPUT-RECORD (* = >'\n             WS-SEC-NUMBER OF WS-INPUT-RECORD ( ITEM - 3 ) '< ~DEBUG~'\n\n       Note extra blanks are removed and the generated code\n       starts in column 12. This keeps the inserted number of\n       lines to a minimum. Please note the truncation of\n       extremely long names above.\n\n       DISPVAR is probably best utilized from a function key,\n       <F22> is suggested.\n\n\n IE  ( Indent )\n+__\n\n       inserts the following code immediately after the line on\n       which the cursor is positioned. It will line up with\n       the previous line, making that line the top line on\n       the screen and placing the cursor on the first leader\n       dots (...).\n\n          EVALUATE ...\n              WHEN ...\n                  ...\n              WHEN ...\n                  ...\n              WHEN OTHER\n                  ...\n          END-EVALUATE\n\n       The indentation may be specified but defaults to 4.  The\n       inserted statements are indented that value if the\n       preceding statement can be identified as an IF, ELSE or\n       PERFORM.\n\n\n1              Code/Data Manipulation Macros (Continued)             Page     59\n\n II  ( Indent )\n+__\n\n       inserts the following code immediately after the line on\n       which the cursor is positioned. It will line up with\n       the previous line, making that line the top line on\n       the screen and placing the cursor on the first leader\n       dots (...).\n\n          IF\n              ...\n          ELSE\n              ...\n          END-IF\n\n       The indentation may be specified but defaults to 4.  The\n       inserted statements are indented that value if the\n       preceding statement can be identified as an IF, ELSE or\n       PERFORM.\n\n\n IP  ( Indent )\n+__\n\n       inserts the following code immediately after the line on\n       which the cursor is positioned. It will line up with\n       the previous line, making that line the top line on\n       the screen and placing the cursor on the first leader\n       dots (...).\n\n          PERFORM\n              VARYING ... FROM 1 BY 1\n                  UNTIL ...\n              ...\n          END-PERFORM\n\n       The indentation may be specified but defaults to 4.  The\n       inserted statements are indented that value if the\n       preceding statement can be identified as an IF, ELSE or\n       PERFORM.\n\n\n IS  ( Indent )\n+__\n\n       inserts the following code immediately after the line on\n       which the cursor is positioned. It will line up with\n       the previous line, making that line the top line on\n       the screen and placing the cursor on the first leader\n       dots (...).\n\n          SET ... TO 1\n          SEARCH ...\n              AT END\n                  ...\n              WHEN ...\n1              Code/Data Manipulation Macros (Continued)             Page     60\n\n                  ...\n          END-SEARCH\n\n       The indentation may be specified but defaults to 4.  The\n       inserted statements are indented that value if the\n       preceding statement can be identified as an IF, ELSE or\n       PERFORM.\n\n\n ISA  ( Indent )\n+___\n\n       inserts the following code immediately after the line on\n       which the cursor is positioned. It will line up with\n       the previous line, making that line the top line on\n       the screen and placing the cursor on the first leader\n       dots (...).\n\n          SEARCH ALL ...\n              AT END\n                  ...\n              WHEN ...\n                  ...\n          END-SEARCH\n\n       The indentation may be specified but defaults to 4.  The\n       inserted statements are indented that value if the\n       preceding statement can be identified as an IF, ELSE or\n       PERFORM.\n\n\n IST  ( Indent )\n+___\n\n       inserts the following code immediately after the line on\n       which the cursor is positioned. It will line up with\n       the previous line, making that line the top line on\n       the screen and placing the cursor on the first leader\n       dots (...).\n\n          STRING\n              ...\n              ...\n              ...\n                  DELIMITED BY SIZE\n              INTO ...\n          END-STRING\n\n       The indentation may be specified but defaults to 4.  The\n       inserted statements are indented that value if the\n       preceding statement can be identified as an IF, ELSE or\n       PERFORM.\n\n\n1              Code/Data Manipulation Macros (Continued)             Page     61\n\n JB     ( ? )\n+__\n\n       will place the display back at the COBOL PERFORM statement\n       where the JT command was invoked. Please see the JT\n       command description below. A question mark (?) supplied as\n       the only parameter will cause built in help to be\n       displayed. JB uses labels to position itself.\n\n       It is strongly suggested that this macro be assigned\n       to a PF Key, e.g. assign %JB to PF 19 (pseudo back).\n\n\n JT     ( ? )\n+__\n\n       determines the paragraph specified in a COBOL PERFORM on\n       the line where the cursor is positioned and changes the\n       code displayed to the start of that paragraph.  The JB\n       command is used in conjunction to return to the previous\n       PERFORM statement. Please see the description of JB above.\n\n       If the cursor is on a line with a COPY, the macro will\n       View the copybook in a site's hard coded copybook library\n       (defaulted to -YOUR-COPYLIB-1- through -YOUR-COPYLIB-4-).\n\n       A question mark (?)  supplied as the only parameter will\n       cause built in help to be displayed.\n\n       It is strongly suggested that this macro be assigned to a\n       PF Key, e.g. assign %JT to PF 20 (pseudo forward).\n\n\n SPLITAFT  STRING  ( INDENT )\n+________\n\n      will split the specified lines after the string provided. A\n+                                    _____\n      range of lines may be specified by C/CC/C## or the entire\n      file will be processed.  Quotes may be used around the\n      string.  INDENT must be a whole number; otherwise it\n      defaults to 4. COBOL comments ('*' or '/' in column 7) or\n      COBOL debug lines ('D' in column 7) will be ignored\n\n      For example, if SPLITAFT THRU 7 is run against:\n\n               PERFORM 100-INIT-PARA    THRU   999-INIT-EXIT\n               PERFORM 200-PROC-PARA    THRU   999-PROC-EXIT\n               PERFORM 900-QUIT-PARA    THRU   999-QUIT-EXIT\n\n      the following will result:\n\n               PERFORM 100-INIT-PARA    THRU\n                      999-INIT-EXIT\n               PERFORM 200-PROC-PARA    THRU\n                      999-PROC-EXIT\n1              Code/Data Manipulation Macros (Continued)             Page     62\n\n               PERFORM 900-QUIT-PARA    THRU\n                      999-QUIT-EXIT\n\n      If no parameters are specified, built-in help will\n      be displayed. Please also see SPLITAT below.\n\n\n SPLITAT  STRING  ( INDENT )\n+_______\n\n      will split the specified lines at the string provided. A\n+                                    __\n      range of lines may be specified by C/CC/C## or the entire\n      file will be processed.  Quotes may be used around the\n      string.  INDENT must be a whole number; otherwise it\n      defaults to 4. COBOL comments ('*' or '/' in column 7) or\n      COBOL debug lines ('D' in column 7) will be ignored.\n\n      For example, if SPLITAT ' TO ' is run against:\n\n               MOVE  WS-LEADER-DOTS     TO     OUT-NAME0\n               MOVE  WS-FIRST-NAME      TO   OUT-NAME1\n               MOVE  WS-MIDDLE-INIT        TO   OUT-NAME2\n               MOVE  WS-LAST-NAME       TO   OUT-NAME3\n               MOVE  WS-TRAILER-DOTS      TO   OUT-NAME9\n\n      the following will result:\n\n               MOVE  WS-LEADER-DOTS\n                    TO     OUT-NAME0\n               MOVE  WS-FIRST-NAME\n                    TO   OUT-NAME1\n               MOVE  WS-MIDDLE-INIT\n                    TO   OUT-NAME2\n               MOVE  WS-LAST-NAME\n                    TO   OUT-NAME3\n               MOVE  WS-TRAILER-DOTS\n                    TO   OUT-NAME9\n\n      Note the indentation of 4 blanks is placed before the\n      string, ' TO ', resulting in 5 blanks.  If no parameters\n      are specified, built-in help will be displayed. Please\n      also see SPLITAFT above.\n\n\n STRUCT   Language  ( .A .B )\n+______\n\n       excludes everything and then unexcludes any lines that\n       have structural constructs for the specified language such\n       as IF, ELSE, or PROC.  The languages specified are COB or\n       COBOL for COBOL; EZ for Easytrieve; PL1, PLI, PL/1 or PL/I\n       for PL/I; or REX or REXX for REXX.  Comments in COBOL and\n       Easytrieve will be left excluded.  Similarly, all JCL (//\n       in column 1) will also be left excluded.  For example,\n\n1              Code/Data Manipulation Macros (Continued)             Page     63\n\n          STRUCT  COB\n\n       will show the logical structure of the edited COBOL\n       program. A label range may be specified.\n\n       For example, given the following:\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  BASE INITIAL.\n       CONFIGURATION SECTION.\n       SPECIAL-NAMES.\n           CLASS ALPHA-CHARS\n               IS 'A' THRU 'Z', '0' THRU '9', ' ', '.'.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT I\n               ASSIGN TO I.\n           SELECT O\n               ASSIGN TO O.\n       DATA DIVISION.\n       FILE SECTION.\n       FD  I\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  INPUT-REC    PIC X(00080).\n       FD  O\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  OUTPUT-REC   PIC X(00080).\n       WORKING-STORAGE SECTION.\n       01  WS-INPUT-REC                 PIC X(00080).\n       01  WS-SAVE-REC                  PIC X(00080).\n       01  WORK-AREAS.\n           05  NUMBER-RECORDS-ADDED     PIC 9(9)      VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-DELETED   PIC 9(9)      VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-DUPS      PIC 9(9)      VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-READ      PIC 9(9)      VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-UPDATED   PIC 9(9)      VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-WRITTEN   PIC 9(9)      VALUE 0 COMP-3.\n           05  FINAL-RETURN-CODE        PIC 9(4)      VALUE 0 COMP.\n           05  END-OF-FILE-STATUS       PIC X         VALUE 'N'.\n               88  AT-END-OF-FILE                     VALUE 'Y'.\n           05  REWRITE-REC              PIC X         VALUE 'Y'.\n       01  WEEK-DAY-NUMBER              PIC 9.\n       01  YYMMDD                       PIC 9(6).\n       01  HHMM                         PIC 9(8).\n       01  DAYS-OF-WEEK.\n           05  MONDAY    PIC X(9)       VALUE 'MONDAY'.\n           05  TUESDAY   PIC X(9)       VALUE 'TUESDAY'.\n           05  WEDNESDAY PIC X(9)       VALUE 'WEDNESDAY'.\n           05  THURSDAY  PIC X(9)       VALUE 'THURSDAY'.\n           05  FRIDAY    PIC X(9)       VALUE 'FRIDAY'.\n           05  SATURDAY  PIC X(9)       VALUE 'SATURDAY'.\n           05  SUNDAY    PIC X(9)       VALUE 'SUNDAY'.\n1              Code/Data Manipulation Macros (Continued)             Page     64\n\n       01  WEEK-DAYS                    REDEFINES DAYS-OF-WEEK.\n           05 WEEK-DAY   OCCURS 7 TIMES PIC X(9).\n       LINKAGE SECTION.\n       01  PARM-DATA.\n           05  PARM-LENGTH              PIC 9(4)              COMP.\n           05  PARM-PASSED              PIC X(100).\n       PROCEDURE DIVISION USING PARM-DATA.\n       0000-MAIN.\n           PERFORM 0100-INITIALIZATION\n           PERFORM 0200-READ-WRITE-LOOP\n               UNTIL AT-END-OF-FILE\n           PERFORM 0900-TERMINATION\n           MOVE FINAL-RETURN-CODE TO RETURN-CODE\n           GOBACK\n           .\n       0100-INITIALIZATION.\n           OPEN  INPUT  I\n                 OUTPUT O\n           READ  I INTO WS-INPUT-REC\n               AT END SET AT-END-OF-FILE TO TRUE\n               NOT AT END ADD 1 TO NUMBER-RECORDS-READ\n           END-READ\n           .\n       0200-READ-WRITE-LOOP.\n           MOVE 'Y' TO REWRITE-REC\n           PERFORM 0200-PROCESS\n           IF REWRITE-REC = 'Y'\n               WRITE OUTPUT-REC FROM WS-INPUT-REC\n               ADD 1 TO NUMBER-RECORDS-WRITTEN\n           ELSE\n               ADD 1 TO NUMBER-RECORDS-DELETED\n           END-IF\n           READ  I INTO WS-INPUT-REC\n               AT END SET AT-END-OF-FILE TO TRUE\n               NOT AT END ADD 1 TO NUMBER-RECORDS-READ\n           END-READ\n           .\n       0200-PROCESS.\n           CONTINUE\n           .\n       0900-TERMINATION.\n           CLOSE I\n                 O\n           ACCEPT WEEK-DAY-NUMBER FROM DAY-OF-WEEK\n           ACCEPT YYMMDD FROM DATE\n           ACCEPT HHMM FROM TIME\n           DISPLAY 'PROGRAM STATISTICS:  '\n               '                         '\n               WEEK-DAY(WEEK-DAY-NUMBER) ' '\n               YYMMDD '-' HHMM(1:2) ':' HHMM(3:2)\n           DISPLAY '    PARM LENGTH               = '\n               PARM-LENGTH\n           IF PARM-LENGTH NOT = 0\n               DISPLAY '    PARM PASSED TO PROGRAM    = '\n1              Code/Data Manipulation Macros (Continued)             Page     65\n\n                   PARM-PASSED(1:PARM-LENGTH)\n           END-IF\n           DISPLAY ' '\n           DISPLAY '    NUMBER OF RECORDS READ    = '\n               NUMBER-RECORDS-READ\n           DISPLAY '    NUMBER OF RECORDS WRITTEN = '\n               NUMBER-RECORDS-WRITTEN\n           DISPLAY '    NUMBER OF RECORDS UPDATED = '\n               NUMBER-RECORDS-UPDATED\n           DISPLAY '    NUMBER OF RECORDS DELETED = '\n               NUMBER-RECORDS-DELETED\n           DISPLAY '    NUMBER OF RECORDS ADDED   = '\n               NUMBER-RECORDS-ADDED\n           DISPLAY '    NUMBER OF DUPLICATE RECS  = '\n               NUMBER-RECORDS-DUPS\n           .\n\n       The following would be displayed:\n\n             PROCEDURE DIVISION USING PARM-DATA.\n               -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed\n                 PERFORM 0100-INITIALIZATION\n                 PERFORM 0200-READ-WRITE-LOOP\n                     UNTIL AT-END-OF-FILE\n                 PERFORM 0900-TERMINATION\n               -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed\n                 GOBACK\n               -  -  -  -  -  -  -  -  -  -  - 11 Line(s) not Displayed\n                 PERFORM 0200-PROCESS\n                 IF REWRITE-REC = 'Y'\n               -  -  -  -  -  -  -  -  -  -  -  2 Line(s) not Displayed\n                 ELSE\n               -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed\n                 END-IF\n               -  -  -  -  -  -  -  -  -  -  - 20 Line(s) not Displayed\n                 IF PARM-LENGTH NOT = 0\n               -  -  -  -  -  -  -  -  -  -  -  2 Line(s) not Displayed\n                 END-IF\n               -  -  -  -  -  -  -  -  -  -  1457 Line(s) not Displayed\n\n\n SUFFLINE  STRING  ( ? )\n+________\n\n       will append the specified string to the end of every line\n       selected via C/CC/C# range selection or to every line in\n       the file. Blank lines will be left unchanged.\n\n       The words COMMA, APOST and QUOTE may be used to append\n       , or ' or \" respectively. For example,\n\n          SUFFLINE  )\n\n       will cause the following lines\n\n1              Code/Data Manipulation Macros (Continued)             Page     66\n\n          MOVE 0      TO  FAR-TBL(SUB1\n          MOVE 0      TO  NEAR-TABLE(VAR11A\n          MOVE 0      TO  SOME-ARRAY-NAME(11 23\n          MOVE 0      TO  EASY(1\n\n       to become\n\n          MOVE 0      TO  FAR-TBL(SUB1)\n          MOVE 0      TO  NEAR-TABLE(VAR11A)\n          MOVE 0      TO  SOME-ARRAY-NAME(11 23)\n          MOVE 0      TO  EASY(1)\n\n       SUFFLINE could be used to suffix an odd character, say !,\n       on which a C '!' '...' ALL could be executed for\n       simplicity.\n\n       If a question mark (?) is specified as the parameter, the\n       inline help is displayed without moving any lines.\n\n\n XINDENT  ( ? )\n+_______\n\n      based on IBM freeware, has been revamped to specifically\n      handle COBOL code, ignoring comments and junk in columns 1\n      through 6.  Most useful when assigned to a PF Key.\n\n      The general concept is to place the cursor anywhere on a\n      line and have the code excluded to the corresponding start\n      or end line of that construct.\n\n      if the first non blank after column 7 is an 'IF', the lines\n      downward to the next similarly indented ELSE or END-IF will\n      be excluded.  If placed on an 'END-IF' line, it will\n      exclude upwards to a preceding 'ELSE' or 'IF'. If placed on\n      an 'ELSE' line, it will check to see if the preceding line\n      is excluded already and, if so, will exclude downwards to\n      the next similarly indented 'IF'. If not, it will exclude\n      downwards to an 'END-IF'.\n\n      If the cursor is positioned on a PERFORM, the scan proceeds\n      downwards to the similarly indented END-PERFORM. If on an\n      END-PERFORM, it scans upwards for a PERFORM.\n\n      If the cursor is positioned on a EVALUATE, the scan proceeds\n      downwards to the similarly indented END-EVALUATE. If on an\n      END-EVALUATE, it scans upwards for a EVALUATE.\n\n      A parameter of a question mark (?) will cause the built in\n      help to be displayed.\n\n      So if the cursor were placed anywhere on the line with the\n      'IF' in the following text, and XINDENT invoked,\n\n           IF REWRITE-REC = 'Y'\n1              Code/Data Manipulation Macros (Continued)             Page     67\n\n               WRITE OUTPUT-REC FROM WS-INPUT-REC\n               ADD 1 TO NUMBER-RECORDS-WRITTEN\n           ELSE\n               ADD 1 TO NUMBER-RECORDS-DELETED\n           END-IF\n\n      The following would be displayed:\n\n          IF REWRITE-REC = 'Y'\n           -  -  -  -  -  -  -  -  -  -  2 Line(s) not Displayed\n          ELSE\n              ADD 1 TO NUMBER-RECORDS-DELETED\n          END-IF\n\n      If the cursor were now to be placed on the 'END-IF' or\n      'ELSE' line:\n\n          IF REWRITE-REC = 'Y'\n           -  -  -  -  -  -  -  -  -  -  -  -  2 Line(s) not Displayed\n          ELSE\n           -  -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed\n          END-IF\n\n      would result. Obviously, the various constructs must line\n      up, i.e. the indentation must be the same.  While this\n      demands some precision, the benefits of using XINDENT as\n      well as having consistent code are well worth the cost.\n\n\n1                       JCL Manipulation Macros                      Page     68\n\n\n These macros are useful with JCL, either adding lines or\n reformatting them.\n\n\n CU  ( ###  |  ? )\n+__\n\n      will add an IEFBR14 step after the line on which the cursor\n      is positioned with ### MOD/DELETE DD cards with ###\n      defaulting to 1.  A solitary question mark will cause built\n      in help to display.  At the end, the cursor will be placed\n      on the first set of dots.\n\n      For example, CU 4 will insert the following immediately\n      after the cursor:\n\n      //***\n      //***\n      //CLEANUP    EXEC     PGM=IEFBR14\n      //DEL001       DD       DSN=...,\n      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n      //DEL002       DD       DSN=...,\n      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n      //DEL003       DD       DSN=...,\n      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n      //DEL004       DD       DSN=...,\n      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n\n      Please see CUD below for dynamically generated delete\n      images.\n\n\n CUD  ( ? )\n+___\n\n      will add IEFBR14 step after where the cursor is positioned\n      for every NEW CATLG data set in the file.  C/CC/C# may be\n      used to limit the search for new data sets to only those\n      lines.  A solitary question mark will cause built in help\n      to display.  At the end, the cursor will be placed where it\n      was initially positioned.\n\n      For example, given the following somewhere in the searched\n      area of the file:\n\n      //CREATION   EXEC     PGM=SOMEPGM\n      //FILE01       DD       DSN=SYS4.LIMITED.DATA,DISP=(NEW,CATLG),\n      //             UNIT=SYSDA,SPACE=(CYL,10)\n      //XX       DD       DISP=(,CATLG),\n      //          UNIT=TESTPK,\n      //          VOL=SER=TP0037,\n      //          DCB=(RECFM=VBS,BLKSIZE=27998),\n      //          DSNAME=YOURID.SOME.DATA.SET.NAME\n      //         DD       DISP=(,CATLG),DSN=YOURID.VBSFILE,\n1                 JCL Manipulation Macros (Continued)                Page     69\n\n      //          UNIT=SYSDA,SPACE=(TRK,(1000,1000),RLSE)\n         ... some other irrelevant lines ...\n      //             DD       DISP=(NEW,CATLG,DELETE),\n      //             UNIT=SYSDA,\n      //             SPACE=(CYL,5),\n      //             DSN=YOURID.RUBBER.DUCKY,\n      //             DCB=BLKSIZE=0\n\n      CUD will insert the following lines after the line where\n      the cursor is positioned:\n\n      //***\n      //***\n      //CLEANUP  EXEC  PGM=IEFBR14\n      //DEL001           DSN=SYS4.LIMITED.DATA,\n      //           DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n      //DEL002           DSN=YOURID.SOME.DATA.SET.NAME,\n      //           DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n      //DEL003           DSN=YOURID.VBSFILE,\n      //           DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n      //DEL004           DSN=YOURID.RUBBER.DUCKY,\n      //           DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n\n      CUD has a problem with JCL where certain parts were left as\n      comments, e.g. leaving DISP=SHR on the end of the\n      DISP=(,CATLG) line. Clean JCL is good JCL!\n\n\n CHDEL ( ? )\n+_____\n\n      will add an HDELETE command after where the cursor is\n      positioned for every NEW CATLG data set in the file.\n      C/CC/C# may be used to limit the search for new data sets\n      to only those lines.  A solitary question mark will cause\n      built in help to display.  At the end, the cursor will be\n      placed where it was initially positioned.\n\n      Including this in the JCL stream before clean up JCL\n      (IEFBR14 MOD DELETE's) will greatly reduce recall time.\n\n      For example, given the following somewhere in the searched\n      area of the file:\n\n      //CREATION   EXEC     PGM=SOMEPGM\n      //FILE01       DD       DSN=SYS4.LIMITED.DATA,DISP=(NEW,CATLG),\n      //             UNIT=SYSDA,SPACE=(CYL,10)\n      //XX       DD       DISP=(,CATLG),\n      //          UNIT=TESTPK,\n      //          VOL=SER=TP0037,\n      //          DCB=(RECFM=VBS,BLKSIZE=27998),\n      //          DSNAME=YOURID.SOME.DATA.SET.NAME\n      //         DD       DISP=(,CATLG),DSN=YOURID.VBSFILE,\n      //          UNIT=SYSDA,SPACE=(TRK,(1000,1000),RLSE)\n         ... some other irrelevant lines ...\n1                 JCL Manipulation Macros (Continued)                Page     70\n\n      //             DD       DISP=(NEW,CATLG,DELETE),\n      //             UNIT=SYSDA,\n      //             SPACE=(CYL,5),\n      //             DSN=YOURID.RUBBER.DUCKY,\n      //             DCB=BLKSIZE=0\n\n      CHDEL will insert the following lines after the line where\n      the cursor is positioned:\n\n      //***\n      //BATCHTSO   EXEC     PGM=IKJEFT01,REGION=4M,DYNAMNBR=32\n      //SYSTSIN      DD       *\n        HDEL  'SYS4.LIMITED.DATA'\n        HDEL  'YOURID.SOME.DATA.SET.NAME'\n        HDEL  'YOURID.VBSFILE'\n        HDEL  'YOURID.RUBBER.DUCKY'\n        CALL  *(IEFBR14)\n      //SYSTSPRT     DD       SYSOUT=*\n      //***\n\n      If the dataset does not exist, a NOT IN CATALOG message\n      is issued from HDELETE; if the dataset is not migrated,\n      a DATA SET NOT MIGRATED is issued; if the dataset does\n      exist and the request is queued, a message showing\n      DELETE REQUEST 00031371 SENT TO DFSMSHSM is shown.\n\n\n DISPDSN  ( ? )\n+_______\n\n       forces DSN=...,DISP=SHR into the reverse format, namely\n       DISP=SHR,DSN=...; this macro uses FAND to assure both DISP\n       and DSN are present. Useful for getting data set names to\n       the end of the line, making it easy to cut and paste. For\n       example, the following:\n\n          //XX  DD  DSN=SYS1.USERLIB,DISP=SHR\n          //    DD  DSN=SYS2.USERLIB,DISP=SHR\n          //YY  DD  DSN=SYS1.MACLIB,DISP=SHR\n\n       would be changed to:\n\n          //XX  DD  DISP=SHR,DSN=SYS1.USERLIB\n          //    DD  DISP=SHR,DSN=SYS2.USERLIB\n          //YY  DD  DISP=SHR,DSN=SYS1.MACLIB\n\n       Please see NEATJCL below for additional formatting.\n\n\n GETDSNS  ( Wild-Card-String | ? )  ( STATS | DD )\n+_______\n\n      pulls a list of the data sets matching the wildcard string\n      and pastes the list after the line after where the cursor\n      is positioned. For example,\n\n1                 JCL Manipulation Macros (Continued)                Page     71\n\n         GETDSNS  SYS2.SAS.**.TEMP\n\n      might show (starting each line in column 1):\n\n         SYS2.SAS.ELGREQ.V1R1.CLIDVSAM.TEST\n         SYS2.SAS.ELGREQ.V1R1.CUSTOMER.TEST\n         SYS2.SAS.ELGREQ.V1R1.DATA.TEST\n                   ...\n\n      The STATS option will append the volume serial and number\n      of tracks for non-migrated data sets with a total. The DD\n      option will cause DD card images to be generated, for\n      example:\n\n         GETDSNS  SYS1.AOC  DD\n\n      might cause:\n\n         //             DD       DISP=SHR,\n         //             DSN=SYS1.AOC.SEVEINST\n         //             DD       DISP=SHR,\n         //             DSN=SYS1.AOC.SEVEMOD1\n         //             DD       DISP=SHR,\n         //             DSN=SYS1.AOC.SEVEMOD2\n                   ...\n\n      Note the data set name is placed on a second line and no\n      DD name is on the very first DD card image.\n\n      A ? as the only argument or no arguments at all causes the\n      internal help to be displayed.\n\n\n GETGDGS  ( Base-GDG-String | ? )  ( STATS | DD )\n+_______\n\n      pulls a list of the data sets matching the base Generation\n      Data Group string and pastes the list on the line after\n      where the cursor is positioned.  For example,\n\n         GETGDGS  SOMEUSER.HIGH.LEVEL.GDG.ENTRY\n\n      might show (starting each line in column 1):\n\n         SOMEUSER.HIGH.LEVEL.GDG.ENTRY.G0007V00\n         SOMEUSER.HIGH.LEVEL.GDG.ENTRY.G0008V00\n         SOMEUSER.HIGH.LEVEL.GDG.ENTRY.G0009V00\n                   ...\n\n      The STATS option will append the volume serial and number\n      of tracks for non-migrated data sets with a total. The DD\n      option will cause DD card images to be generated, for\n      example:\n\n         GETGDGS  SOMEUSER.HIGH.LEVEL.GDG.ENTRY  DD\n1                 JCL Manipulation Macros (Continued)                Page     72\n\n\n      might cause:\n\n         //             DD       DISP=SHR,\n         //             DSN=SOMEUSER.HIGH.LEVEL.GDG.ENTRY.G0007V00\n         //             DD       DISP=SHR,\n         //             DSN=SOMEUSER.HIGH.LEVEL.GDG.ENTRY.G0008V00\n         //             DD       DISP=SHR,\n         //             DSN=SOMEUSER.HIGH.LEVEL.GDG.ENTRY.G0009V00\n                   ...\n\n      Note the data set name is placed on a second line and no\n      DD name is on the very first DD card image. Also, they are\n      generated in oldest first order.\n\n      A ? as the only argument or no arguments at all causes the\n      internal help to be displayed.\n\n\n GETMEMS  Data-Set-Name\n+_______\n\n      pulls a list of all or a selected set of member names from\n      a given Data-Set-Name and places them after where the cursor\n      is positioned. A wild card of * may be used to do selection,\n      for example, GETMEMS 'SYS1.MACLIB(GET*)' would retrieve\n      only those member names that started with GET.\n\n         GETMEMS  SOME.PDS.UNDER.YOUR.USERID\n\n      might show (starting each line in column 1):\n\n         ABENDX\n         ABENDX$\n         ADDCC\n         ADDCC$\n         ADDFLAG\n         ADDLINEA\n         ADDLINEB\n         ADDLINES\n                   ...\n\n      A ? as the only argument or no arguments at all causes the\n      internal help to be displayed.\n\n\n ISORT\n+_____\n\n      inserts a full sort step after where the cursor is\n      positioned in the file and places the cursor on the first\n      set of dots. If the following was the displayed screen of\n      file data and the cursor was anywhere on the second line,\n\n         //SYSOUT       DD       SYSOUT=*\n         //***                       <=== Cursor anywhere here ...\n1                 JCL Manipulation Macros (Continued)                Page     73\n\n         //***\n         //ADDHDTLR   EXEC     EZTPCG,REGION=2M\n         //INFILE       DD       DISP=SHR,DSN=USERID.INPUT.WOHDRTLR\n         //OUTFILE      DD       DSN=USERID.OUTPUT.WHDRTLR,\n         //             DISP=(NEW,CATLG,DELETE),UNIT=SYSDA,\n         //             SPACE=(CYL,(12,12),RLSE),\n         //             DCB=(RECFM=FB,LRECL=1234)\n         //STEPLIB      DD\n         //             DD       DISP=SHR,DSN=USERID.LOADLIB\n\n      the result of invoking ISORT would be:\n\n         //SYSOUT       DD       SYSOUT=*\n         //***                       <=== Cursor anywhere here ...\n         //***\n         //SORT        EXEC     PGM=SORT,REGION=256M\n         //SORTIN       DD       DISP=SHR,DSN=...<=== Cursor here now...\n         //SORTOUT      DD       DISP=(,CATLG),UNIT=SYSDA,\n         //             SPACE=(CYL,(0010,0010),RLSE),\n         //             DSN=...,\n         //             DCB=(...)\n         //SYSIN        DD       *\n            SORT    FIELDS=(0001,0001,CH,A)\n              INCLUDE  COND=(....,....,CH,EQ,C'...',OR,\n                             ....,....,CH,EQ,C'...')\n            SUM     FIELDS=NONE\n         //SYSPRINT     DD       SYSOUT=*\n         //SORTLIST     DD       SYSOUT=*\n         //SYSOUT       DD       SYSOUT=*\n         //SORTWK01     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))\n         //SORTWK02     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))\n         //SORTWK03     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))\n         //SORTWK04     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))\n         //SORTWK05     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))\n         //SORTWK06     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))\n         //***\n         //***\n         //ADDHDTLR   EXEC     EZTPCG,REGION=2M\n         //INFILE       DD       DISP=SHR,DSN=USERID.INPUT.WOHDRTLR\n         //OUTFILE      DD       DSN=USERID.OUTPUT.WHDRTLR,\n         //             DISP=(NEW,CATLG,DELETE),UNIT=SYSDA,\n         //             SPACE=(CYL,(12,12),RLSE),\n         //             DCB=(RECFM=FB,LRECL=1234)\n         //STEPLIB      DD\n         //             DD       DISP=SHR,DSN=USERID.LOADLIB\n\n\n JC  ( ? )\n+__\n\n      inserts a job card as shown below with a separator comment\n      line. The job name, the descriptive user information, and\n      the NOTIFY are set to the TSO user ID. The user ID is also\n      placed within the name information.\n\n1                 JCL Manipulation Macros (Continued)                Page     74\n\n         //User-ID    JOB      (ACCT-INFO),'User-ID',\n         //             CLASS=2,MSGCLASS=X,NOTIFY=User-ID\n         //***\n\n      No suffix character is generated but the cursor will be\n      positioned there on completion.  A question mark (?) as the\n      only argument causes the internal help to be displayed.\n\n\n NEATJCL  ( ? )\n+_______\n\n       will cause JCL within the marked (via C/CC/C##) range of\n       lines to be formatted.  If no range is specified, the\n       entire file is processed.  The block operations, like EXEC\n       or PROC, are placed in column 14, other operations like DD\n       in column 16.  Operands are shifted to column 25 unless\n       there's no operation present, when they're placed in\n       column 16.\n\n       Comments (//*), terminators (/*) and data are left as\n       found.  Where long names are formed of STEP.DDNAME, the\n       column formatting is as close as possible to the standards\n       above.\n\n       For the following file:\n\n          //***  BACKUP INPUT FILE...\n          //IDCAMS EXEC PGM=IDCAMS,REGION=0M\n          //SYSPRINT DD SYSOUT=*\n          //INFILE DD DSN=SOME.INPUT.FILE,DISP=SHR\n          //OUTFILE DD DSN=SOME.OUTPUT.FILE,\n          // DISP=(,CATLG),\n          // UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),\n          // DCB=(RECFM=FB,LRECL=120,BLKSIZE=0)\n          //SYSIN DD *\n          REPRO INFILE(INFILE ) OUTFILE(OUTFILE )\n          //***\n\n       the result of applying NEATJCL would be:\n\n          //*** BACKUP INPUT FILE...\n          //IDCAMS     EXEC     PGM=IDCAMS,REGION=0M\n          //SYSPRINT     DD       SYSOUT=*\n          //INFILE       DD       DSN=SOME.INPUT.FILE,DISP=SHR\n          //OUTFILE      DD       DSN=SOME.OUTPUT.FILE,\n          //             DISP=(,CATLG),\n          //             UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),\n          //             DCB=(RECFM=FB,LRECL=120,BLKSIZE=0)\n          //SYSIN        DD       *\n          REPRO INFILE(INFILE ) OUTFILE(OUTFILE )\n          //***\n\n       While not perfect, it generally provides an instant\n       readability improvement.\n1                 JCL Manipulation Macros (Continued)                Page     75\n\n\n\n SUBCAN  ( ? )\n+______\n\n      will submit the job being edited and cancel the edit.  It\n      saves the pain of an inadvertent save.  If a question mark\n      (?) is specified as the parameter, the built in help is\n      displayed.\n\n\n SUBO  ( ? )  ( ABEND(COND) )  ( CODE(#) )\n+____\n\n      will temporarily change date, time and/or user tokens as\n      specified below and submit the job. The changes are NOT\n+                                                         ___\n      made to the file - the changes are made dynamically as the\n      file is written to the internal reader.  It is the same as\n      SUBX but with ORIGIN always turned on - please see SUBX\n      below.  It may be used in Edit or View mode, or from DS\n      List or a member list.  The last, a member list in Browse,\n      Edit or View, will not allow any options.  This macro is\n      useful for keeping a master set of JCL that places today's\n      date/time as part of dataset names.  And, if ABEND is\n      specified, generate a step that will force an abnormal\n      termination with a specified user code.\n\n      The variables substituted are shown here with sample\n      examples using a date of 1999/12/31, a time of 12:34:56 and\n      a TSO user ID of YourID.\n\n         &CCYY/MM/DD    <turns into>    1999/12/31\n         &CCYY/DDD      <turns into>    1999/034\n         &CCYYDDD       <turns into>    1999034\n         &CCYYMMDD      <turns into>    19991231\n         &DAYOFWK       <turns into>    FRIDAY\n         &DD/MM/YY      <turns into>    31/12/99\n         &DOW           <turns into>    FRI\n         &HH:MM         <turns into>    12:34\n         &HH:MM:SS      <turns into>    12:34:56\n         &HHMM          <turns into>    1234\n         &HHMMSS        <turns into>    123456\n         &MM/DD/YY      <turns into>    12/31/99\n         &MMDDYY        <turns into>    123199\n         &MON           <turns into>    DEC\n         &MONTH         <turns into>    DECEMBER\n         &USERID        <turns into>    YourID\n         &YEAR          <turns into>    1999\n         &YY/MM/DD      <turns into>    99/12/31\n         &YYDDD         <turns into>    99365\n         &YYMMDD        <turns into>    991231\n\n      ORIGIN, which may be abbreviated as ORG or O, will cause\n      the following JCL to be inserted after the JOB statement\n      (even if the JOB statement extends to 2 or more lines):\n1                 JCL Manipulation Macros (Continued)                Page     76\n\n\n      //***\n      //***  SUBMITTED BY YourID ON FRIDAY DECEMBER 31ST, 1999 (DAY 365)\n      //***     AT 12:34:56 FROM SOME.PDS.JCL(MEMNAME)\n      //***\n\n      If ABEND is specified, with or without a parameter, the\n      following JCL is added to the end of the submitted job.\n      The parameter may be used to specify the COND for the step.\n      It defaults to '0,LT'. The specific code to be used in the\n      abend may be specified via CODE(#). The default is 666.\n      Assuming ABEND(8,LT) and CODE(37) were specified, the JCL\n      generated would be:\n\n      //***\n      //ABEND      EXEC     PGM=ABENDX,PARM=0037,COND=(8,LT)\n      //STEPLIB      DD       DISP=SHR,DSN=YOURID.LOADLIB\n      //***\n\n      The ABENDX code is found on the same CBT Tape file as this\n      macro.\n\n      If a question mark (?) is supplied as the only parameter,\n      the built in help is displayed.\n\n      Given the following tokenized JCL:\n\n         //&USERIDG   JOB      (AcctInfo),'&USERID -- BKUPS',\n         //             CLASS=A,MSGCLASS=Y,NOTIFY=&USERID\n         //***\n         //CLEANUP    EXEC     PGM=IEFBR14\n         //DEL01        DD       DSN=&USERID.YR&YEAR.&MON.BKUP\n         //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n         //***\n         //GENER      EXEC     PGM=IEBGENER,REGION=4M\n         //SYSPRINT     DD       SYSOUT=*\n         //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,\n         //             DSN=ARKV.TAMASTER.DATA\n         //SYSUT2       DD       DISP=(,CATLG),\n         //             UNIT=SYSDA,SPACE=(CYL,(05,02),RLSE),\n         //             DCB=(ARKV.TAMASTER.DATA)\n         //             DSN=&USERID.YR&YEAR.&MON.BKUP\n         //SYSIN        DD       DUMMY\n         //***\n\n      the following would be submitted by executing SUBO:\n\n         //USER077G   JOB      (AcctInfo),'USER077 -- BKUPS',\n         //             CLASS=A,MSGCLASS=Y,NOTIFY=USER077\n         //***\n         //CLEANUP    EXEC     PGM=IEFBR14\n         //DEL01        DD       DSN=USER077.YR2002.JUL.BKUP\n         //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n         //***\n1                 JCL Manipulation Macros (Continued)                Page     77\n\n         //GENER      EXEC     PGM=IEBGENER,REGION=4M\n         //SYSPRINT     DD       SYSOUT=*\n         //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,\n         //             DSN=ARKV.TAMASTER.DATA\n         //SYSUT2       DD       DISP=(,CATLG),\n         //             UNIT=SYSDA,SPACE=(CYL,(05,02),RLSE),\n         //             DCB=(ARKV.TAMASTER.DATA)\n         //             DSN=USER077.YR2002.JUL.BKUP\n         //SYSIN        DD       DUMMY\n         //***\n\n      Note the year and month portions filled within the new\n      dataset name as well as several user-id uses.\n\n\n SUBX  ( ? )  ( ABEND(COND) )  ( CODE(#) )  ( ORIGIN )\n+____\n\n      will temporarily change date, time and/or user tokens as\n      specified below and submit the job. The changes are NOT\n+                                                         ___\n      made to the file - the changes are made dynamically as the\n      file is written to the internal reader.  It may be used in\n      Edit or View mode, or from DS List or a member list.  The\n      last, a member list in Browse, Edit or View, will not allow\n      any options.  This macro is useful for keeping a master set\n      of JCL that places today's date/time as part of dataset\n      names.  It will also, if ORIGIN specified, place JCL\n      comment statements just after the job statement providing\n      date and time of submission as well as submitting user and\n      library/file from which the job was submitted.  And, if\n      ABEND is specified, generate a step that will force an\n      abnormal termination with a specified user code.\n\n      The variables substituted are shown here with sample\n      examples using a date of 1999/12/31, a time of 12:34:56 and\n      a TSO user ID of YourID.\n\n         &CCYY/MM/DD    <turns into>    1999/12/31\n         &CCYY/DDD      <turns into>    1999/034\n         &CCYYDDD       <turns into>    1999034\n         &CCYYMMDD      <turns into>    19991231\n         &DAYOFWK       <turns into>    FRIDAY\n         &DD/MM/YY      <turns into>    31/12/99\n         &DOW           <turns into>    FRI\n         &HH:MM         <turns into>    12:34\n         &HH:MM:SS      <turns into>    12:34:56\n         &HHMM          <turns into>    1234\n         &HHMMSS        <turns into>    123456\n         &MM/DD/YY      <turns into>    12/31/99\n         &MMDDYY        <turns into>    123199\n         &MON           <turns into>    DEC\n         &MONTH         <turns into>    DECEMBER\n         &USERID        <turns into>    YourID\n         &YEAR          <turns into>    1999\n1                 JCL Manipulation Macros (Continued)                Page     78\n\n         &YY/MM/DD      <turns into>    99/12/31\n         &YYDDD         <turns into>    99365\n         &YYMMDD        <turns into>    991231\n\n      ORIGIN, which may be abbreviated as ORG or O, will cause\n      the following JCL to be inserted after the JOB statement\n      (even if the JOB statement extends to 2 or more lines):\n\n      //***\n      //***  SUBMITTED BY YourID ON FRIDAY DECEMBER 31ST, 1999 (DAY 365)\n      //***     AT 12:34:56 FROM SOME.PDS.JCL(MEMNAME)\n      //***\n\n      If ABEND is specified, with or without a parameter, the\n      following JCL is added to the end of the submitted job.\n      The parameter may be used to specify the COND for the step.\n      It defaults to '0,LT'. The specific code to be used in the\n      abend may be specified via CODE(#). The default is 666.\n      Assuming ABEND(8,LT) and CODE(37) were specified, the JCL\n      generated would be:\n\n      //***\n      //ABEND      EXEC     PGM=ABENDX,PARM=0037,COND=(8,LT)\n      //STEPLIB      DD       DISP=SHR,DSN=YOURID.LOADLIB\n      //***\n\n      The ABENDX code is found on the same CBT Tape file as this\n      macro.\n\n      If a question mark (?) is supplied as the only parameter,\n      the built in help is displayed.\n\n      Given the following tokenized JCL:\n\n         //&USERIDG   JOB      (AcctInfo),'&USERID -- BKUPS',\n         //             CLASS=A,MSGCLASS=Y,NOTIFY=&USERID\n         //***\n         //CLEANUP    EXEC     PGM=IEFBR14\n         //DEL01        DD       DSN=&USERID.YR&YEAR.&MON.BKUP\n         //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n         //***\n         //GENER      EXEC     PGM=IEBGENER,REGION=4M\n         //SYSPRINT     DD       SYSOUT=*\n         //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,\n         //             DSN=ARKV.TAMASTER.DATA\n         //SYSUT2       DD       DISP=(,CATLG),\n         //             UNIT=SYSDA,SPACE=(CYL,(05,02),RLSE),\n         //             DCB=(ARKV.TAMASTER.DATA)\n         //             DSN=&USERID.YR&YEAR.&MON.BKUP\n         //SYSIN        DD       DUMMY\n         //***\n\n      the following would be submitted by executing SUBX:\n\n1                 JCL Manipulation Macros (Continued)                Page     79\n\n         //USER077G   JOB      (AcctInfo),'USER077 -- BKUPS',\n         //             CLASS=A,MSGCLASS=Y,NOTIFY=USER077\n         //***\n         //CLEANUP    EXEC     PGM=IEFBR14\n         //DEL01        DD       DSN=USER077.YR2002.JUL.BKUP\n         //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n         //***\n         //GENER      EXEC     PGM=IEBGENER,REGION=4M\n         //SYSPRINT     DD       SYSOUT=*\n         //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,\n         //             DSN=ARKV.TAMASTER.DATA\n         //SYSUT2       DD       DISP=(,CATLG),\n         //             UNIT=SYSDA,SPACE=(CYL,(05,02),RLSE),\n         //             DCB=(ARKV.TAMASTER.DATA)\n         //             DSN=USER077.YR2002.JUL.BKUP\n         //SYSIN        DD       DUMMY\n         //***\n\n      Note the year and month portions filled within the new\n      dataset name as well as several user-id uses.\n\n\n1                        Format Control Macros                       Page     80\n\n\n The following macros will justify, format and add data.  C/CC/C#\n range control is used to limit the changes since most usage will\n probably be a single instance.  FLAGREVS will only handle the\n entire file since it uses SuperC compare to determine changes.\n\n Built in help is available by either typing the macro name\n without any parameters or with just a question mark (?) as the\n only operand.\n\n\n ADDFLAG    FLAG  ( END-COL )\n+_______\n\n       will add a change flag on the lines marked with C/CC/C##\n       or the entire file if no range is specified.  The supplied\n       flag will be right justified to the specified end column.\n       The flag, within quotes if blanks are included, is\n       mandatory but the ending column defaults to 72.  The flag\n       will simply overlay what's in the columns, so doing a FIND\n       on non blanks should be done first (FIND P'\u00ac' ## END-COL)\n       if needed data may be in those columns.\n\n          ADDFLAG  '/*  99-12-31  */'\n\n       Will place /*  99-12-31  */ in columns 57 thru 72 of the\n       specified C range. Note the receiving location does not\n       have to be at the end of the line.\n\n\n CENTER   ( LEFT-COLUMN  RIGHT-COLUMN )  ( ? )\n+______\n\n       will cause the marked (via C/CC/C##) range of lines to be\n       centered within the BOUNDS then in force unless other\n       columns are specified as parameters.  If no range is\n       specified, the entire file is processed.  The first and\n       the last non-blank characters within the bounds determine\n       the size of the data to be centered. Specifying a left\n       column and right column will cause only the data in those\n       columns to be centered. For example:\n\n          CENTER  11 40\n\n       will cause the data in columns 11 through 40 to be\n       centered within those columns. A parameter of ? causes\n       the built in help to be displayed.\n\n\n FLAGREVS   REVISION-FLAG  ( REVISION-COL )\n+________\n\n       overlays changed records with the REVISION-FLAG.  The\n       revision flag is mandatory. The revision column defaults\n       to 65. All non changed lines will be excluded and one line\n       above and one below will be shown. Non blanks will not be\n1                  Format Control Macros (Continued)                 Page     81\n\n       overlaid by the flag.  Only the entire file may be flagged\n+                             ___________________________________\n       since they're generated by comparing the existing file to\n       the data being edited in storage. An example is:\n\n          FLAGREVS  |  2\n\n       will place a vertical bar in column 2 of every line in the\n       file being edited that's different from the original saved\n       file. The entire file will be excluded and the lines with\n       the revision flag added will be included with a line above\n       and below shown to establish context.\n\n       Deleted lines obviously can not be flagged.\n\n\n LJUST   ( LEFT-COLUMN  RIGHT-COLUMN )  ( ? )\n+_____\n\n       will cause the marked (via C/CC/C##) range of lines to be\n       left justified within the BOUNDS then in force or within\n       the columns specified.  If no range is specified, the\n       entire file is processed.  The first and the last non\n       blank characters within the bounds determine the size of\n       the data to be left justified.  Specifying a left column\n       and right column will cause only the data in those columns\n       to be justified. For example:\n\n          LJUST  11 20\n\n       will cause the data in columns 11 through 20 to be left\n       justified within those columns, that is, the first non\n       blank will be placed in column 11, padding on the right\n       with blanks.\n\n\n RJUST   ( LEFT-COLUMN  RIGHT-COLUMN )  ( ? )\n+_____\n\n       will cause the marked (via C/CC/C##) range of lines to be\n       right justified within the BOUNDS then in force.  If no\n       range is specified, the entire file is processed.  The\n       first and the last non blank characters within the bounds\n       determine the size of the data to be right justified.\n       This chunk of data is shifted as is.\n\n       Specifying a left column and right column will cause only\n       the data in those columns to be justified. For example:\n\n          RJUST   1 20\n\n       will cause the data in columns 1 through 20 to be right\n       justified within those columns, that is, the last non\n       blank will come to rest in column 20.\n\n\n1                  Format Control Macros (Continued)                 Page     82\n\n SQUSH   ( LEFT-COLUMN  RIGHT-COLUMN ) ( ? )\n+_____\n\n       will cause the marked (via C/CC/C##) range of lines to be\n       left justified within the BOUNDS then in force or within\n       the columns specified and multiple consective blanks\n       changed to one blank.  If no range is specified, the\n       entire file is processed. A question mark will cause the\n       built in help to be displayed.\n\n       For example, given the following somewhat implausable\n       heavily edited text:\n\n          It is further assumed\n          that any associated   supporting element\n          necessitates                  that urgent consideration be\n          applied\n          to the total\n          system rationale.   However, the fully integrated test\n          program\n          must utilize and be       functionally interwoven with the\n          overall\n          negative profitability.\n\n       the result of SQUSH's being issued would be:\n\n          It is further assumed\n          that any associated supporting element\n          necessitates that urgent consideration be applied\n          to the total\n          system rationale. However, the fully integrated test\n          program\n          must utilize and be functionally interwoven with the overall\n          negative profitability.\n\n       A better use would be compressing the blanks out of code\n       or JCL that requires substantial insertions during\n       editing, but, given the above, you could then use text\n       format (TF) on the result of the SQUSH and get decent\n       output.\n\n\n1                     Inter/Intra Dataset Macros                     Page     83\n\n\n The macros in this group will acquire one or more lines of data\n through use of the (now) standard system CUT command or the CUTX\n macro provided in this package.  The (now) standard system PASTE\n command and the PA and PY macros may be used to insert the CUT\n lines, or the PASTEX, PASTEAFT and PASTY macros in this pacakge\n may be used to insert the CUTX lines.\n\n The system provided CUT/PASTE commands (and the PA/PY macros)\n will allow use across ISPF applications such as going from\n standard View to SDSF SJ.  Unfortunately, the\n CUTX/PASTEX/PASTEAFT/PASTY macros, while working fine within an\n application such as View to Edit, can't handle the cross\n application connection since they use the PROFILE to store data.\n\n The reason both sets are still provided is that there are folks\n who use the older set and don't want to change.\n\n PASTEAFT and PA allows the pasting of CUTX and CUT data\n respectively after one or more lines in a range. PASTY and PY\n will allow pasting data after the line the cursor is on,\n optimally done with an assigned PFKey.\n\n The CUT and PASTE commands have built in ISPF help that may be\n accessed by pressing <F1> within an Edit session.  The macros in\n this package provide built in help by typing the macro followed\n by a '?', e.g. CUTX ?. XCOPY may simply be typed without any\n parameters to get help.\n\n Please note that the use of CUT and PASTE allows you to use\n+___________\n EDITSET (or EDSET) within Edit or View to set the default\n behaviors for these macros such as whether to replace or append\n data with CUT and to delete or keep data with PASTE. It is\n strongly suggested that they be used.\n\n\n CUTX   ( A | APPEND )  ( ? )\n+____\n\n       write lines from a file to the PROFILE pool for later\n       inclusion by the paste macros PASTEX, PASTEAFT and PASTY.\n       Enter CUTX on the COMMAND line and use the C or M line\n       commands (in any form) to select the lines to be cut.  If\n       the M line command is used, the lines will be deleted from\n       the originating file.\n\n       A parameter of A or APPEND can be specified to add to any\n       previously CUTX lines with the newly selected lines.\n       Otherwise, the selected lines will replace any previously\n       CUTX lines. A ? will cause the built in help to display.\n\n\n1               Inter/Intra Dataset Macros (Continued)               Page     84\n\n PA   ( #-LINES-TO-SKIP )  ( ? )\n+__\n\n       pull lines from the default ISPF clipboard into the\n       current file.  This macro is used in conjunction with the\n       CUT command.  Enter PA on the COMMAND line and use\n       C/CC/C## line commands to specify where the lines are to\n       be inserted.  The data will be copied after each line\n       within the range skipping #-LINES-TO-SKIP lines each copy.\n       #-LINES-TO-SKIP defaults to 1.\n\n       A parameter of a question mark will cause the built in\n       help to be displayed.\n\n       Given you've CUT the following line:\n\n          //            DD        DISP=SHR,DCB=BUFNO=32,\n\n       use 'PA' on the following lines (with the selected\n       range shown by the CC'd lines:\n\n          CC0001 //***\n          000002 //             DSN=SYS6.STKVTS2.BKUP.G0123V00\n          000003 //             DSN=SYS6.STKVTS2.BKUP.G0124V00\n          000004 //             DSN=SYS6.STKVTS2.BKUP.G0125V00\n          000005 //             DSN=SYS6.STKVTS2.BKUP.G0126V00\n          000006 //             DSN=SYS6.STKVTS2.BKUP.G0127V00\n          CC0007 //             DSN=SYS6.STKVTS2.BKUP.G0128V00\n          000008 //             DSN=SYS6.STKVTS2.BKUP.G0129V00\n          000009 //***\n\n       to get:\n\n          000001 //***\n          000002 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000003 //             DSN=SYS6.STKVTS2.BKUP.G0123V00\n          000004 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000005 //             DSN=SYS6.STKVTS2.BKUP.G0124V00\n          000006 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000007 //             DSN=SYS6.STKVTS2.BKUP.G0125V00\n          000008 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000009 //             DSN=SYS6.STKVTS2.BKUP.G0126V00\n          000010 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000011 //             DSN=SYS6.STKVTS2.BKUP.G0127V00\n          000012 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000013 //             DSN=SYS6.STKVTS2.BKUP.G0128V00\n          000014 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000015 //             DSN=SYS6.STKVTS2.BKUP.G0129V00\n          000016 //***\n\n       Note in the above how the CC's lines are chosen to add\n       lines and skip appropriately.\n\n\n1               Inter/Intra Dataset Macros (Continued)               Page     85\n\n PASTEAFT   ( D | DELETE )  ( #-LINES-TO-SKIP )  ( ? )\n+________\n\n       pull lines from the user PROFILE pool into the current\n       file.  This macro is used in conjunction with the CUTX\n       macro.  Enter PASTEAFT on the COMMAND line and use\n       C/CC/C## line commands to specify where the lines are to\n       be pasted.  The pasted data will be copied after each line\n       within the range skipping #-LINES-TO-SKIP lines each copy\n       with #-LINES-TO-SKIP defaulting to 1.\n\n       A parameter of D or DELETE can be specified to cause the\n       macro to set the profile variables to null after the lines\n       have been pasted into the file.  The order of the operands\n       or absence of either is not material.\n\n       A parameter of a question mark will cause the built in\n       help to be displayed.\n\n       Given you've CUTX'd the following line:\n\n          //            DD        DISP=SHR,DCB=BUFNO=32,\n\n       use 'PASTEAFT' on the following lines (with the selected\n       range shown by the CC'd lines:\n\n          CC0001 //***\n          000002 //             DSN=SYS6.STKVTS2.BKUP.G0123V00\n          000003 //             DSN=SYS6.STKVTS2.BKUP.G0124V00\n          000004 //             DSN=SYS6.STKVTS2.BKUP.G0125V00\n          000005 //             DSN=SYS6.STKVTS2.BKUP.G0126V00\n          000006 //             DSN=SYS6.STKVTS2.BKUP.G0127V00\n          CC0007 //             DSN=SYS6.STKVTS2.BKUP.G0128V00\n          000008 //             DSN=SYS6.STKVTS2.BKUP.G0129V00\n          000009 //***\n\n       to get:\n\n          000001 //***\n          000002 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000003 //             DSN=SYS6.STKVTS2.BKUP.G0123V00\n          000004 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000005 //             DSN=SYS6.STKVTS2.BKUP.G0124V00\n          000006 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000007 //             DSN=SYS6.STKVTS2.BKUP.G0125V00\n          000008 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000009 //             DSN=SYS6.STKVTS2.BKUP.G0126V00\n          000010 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000011 //             DSN=SYS6.STKVTS2.BKUP.G0127V00\n          000012 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000013 //             DSN=SYS6.STKVTS2.BKUP.G0128V00\n          000014 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000015 //             DSN=SYS6.STKVTS2.BKUP.G0129V00\n          000016 //***\n1               Inter/Intra Dataset Macros (Continued)               Page     86\n\n\n       Note in the above how the pasted lines follow the CC'd\n       lines and skip appropriately.\n\n\n PASTEX   ( D | DELETE )  ( ? )\n+______\n\n       pull lines from the user profile into the current file.\n       This macro is used in conjunction with the CUTX macro.\n       Enter PASTEX on the COMMAND line and use the A or B line\n       command to specify where the lines are to be pasted.\n\n       An option of D or DELETE can be specified to cause the\n       macro to erase the cut profile variables after the lines\n       have been pasted into the file.  A parameter of a question\n       mark will cause the built in help to be displayed.\n\n       See PASTY below for a PF Key driven paste at the cursor\n       position and PASTEAFT above for pasting after multiple\n       lines.\n\n\n PY  ( ? )\n+__\n\n       pull lines from the default ISPF clipboard into the\n       current file after where the cursor is positioned.  This\n       macro is used in conjunction with the CUT command.  Enter\n       PY on the command line and position the cursor on the line\n       after which the cut lines are to be inserted.  The command\n       is best used when assigned to a PF key (e.g.  use KEYS\n       under Edit to assign %PY to PF16 as shown in the sample\n       key set above).  It never removes the cut lines from the\n       clipboard, and is intended to allow easy, repeatable\n       insertions of the same data multiple times, and across\n       multiple files and applications.\n\n       If the cursor is above the top data line showing on the\n       screen, the data will be pasted after that data line.\n       This uses the ZScreenC and ZScreenI variables which may\n       not be available in all ISPF releases.\n\n\n PASTY  ( ? )\n+_____\n\n       pull lines from the user PROFILE pool into the current\n       file after where the cursor is positioned.  This macro is\n       used in conjunction with the CUTX macro.  Enter PASTY on\n       the COMMAND line and position the cursor on the line after\n       which the cut lines are to be inserted.  The command is\n       best used when assigned to a PF key (e.g.  use KEYS under\n       Edit to assign %PASTY to PF16 as shown in the sample key\n       set above).  It obviously never removes the cut lines from\n       the profile, and is intended to allow easy, repeatable\n       insertions of the same data multiple times and across\n1               Inter/Intra Dataset Macros (Continued)               Page     87\n\n       multiple files.\n\n       If the cursor is above the top data line showing on the\n       screen, the data will be pasted after that data line.\n       This uses the ZScreenC and ZScreenI variables which may\n       not be available in all ISPF releases.\n\n\n VERASE\n+______\n\n       clears the lines cut via CUTX and resets the counter\n       normally maintained. Useful when the system returns an\n       oddball message saying the profile is full.\n\n\n XCOPY   DATA-SOURCE  ( FROM-REC# ( TO-REC# ) )\n+_____\n\n       copy a dataset or member directly into the file being\n       edited without going through the COPY screens.  The data\n       source is mandatory. A destination (either an 'A' or 'B'\n       in the prefix area) may be specified; if neither is\n       specified, the data is copied to the front of the edited\n       file. For example,\n\n          XCOPY 'SYS1.MACLIB(GET)'\n\n       will retrieve the GET macro into the currently edited\n       file.\n\n       The starting record and the ending record of the input may\n       be specified. If not, they default to the first and last.\n       If only the starting number is specified, the copy will\n       proceed through the end of the input file.  For example,\n\n          XCOPY  DATAFILE  45\n\n       will copy the 45th record through the end of your user\n       ID's DATAFILE.\n\n       The number of lines inserted is shown in the upper right\n       corner of the screen.\n\n       The current ISPF COPY facility provides the same\n       functionality with the exception of\n       specifying specific records.\n\n1                            DSList Macros                           Page     88\n\n\n These macros are executed under option 3.4, the DataSet List,\n just like specifying a \"B\" to browse the file. They will count\n the number of records, show the longest and shortest lengths,\n perform a scan of a PDS to find a string, show the last\n referenced date without causing it to change, and create a copy\n of an existing sequential or partitioned data set copying the\n associated data or not.\n\n Built in help is available by either typing the macro name\n without any parameters or with just a question mark (?) as the\n only operand.\n\n\n CLONE  NEWDSN  ( # | +# | -# )  ( EMPTY )  ( RELEASE ) ( Q# )\n+_____\n\n       creates a new data set with the same attributes as the one\n       overtyped. Sequential, partitioned data sets extended\n       (PDSE's) or partitioned data sets (PDS's) may be\n       duplicated. NEWDSN may be fully qualified with quotes,\n       e.g.  'SYS4.MACLIB', or allowed to take on the user\n       prefix, e.g. TEST.DATA. Please note you must have\n       sufficient access authority to create a dataset under\n       whatever security system is in use.\n\n       The original name may be used as a prefix by typing an\n       equal sign (=) followed by the intended suffix in place of\n       NEWDSN.  Overtyping SYS4.MACLIB with =.BKUP will produce a\n       new data set named SYS4.MACLIB.BKUP; the new data set name\n       must not exist and should be a legitimate name for the\n       invoking user to create.\n\n       The original data set may be used as a suffix by typing\n       the intended prefix followed by an equal sign (=).\n+                          ___________\n       Overtyping SYS4.MACLIB with YOURUID.= will create a new\n       data set named YOURID.SYS4.MACLIB.\n\n       Using either the above mentioned prefixing or suffixing\n       options will always cause the resultant new data set name\n       to be fully qualified, i.e. as if it were input within\n       quotes. Use a blank following the new data set choice if\n       there is any doubt about how it will be \"seen\" by the\n       system.\n\n       An option of Q# will reduce the initial qualifiers of the\n       original data set by # for prefixed XXX= or the final\n       qualifiers for suffixed =XXX new data set names.  Given\n       the preceding example, a Q1 will cause YOURUID.MACLIB to\n       be created.\n\n       Optionally, EMPTY may be specified with the new name to\n       not cause data to be copied.\n1                      DSList Macros (Continued)                     Page     89\n\n\n       Optionally, RELEASE may be specified to release unused\n       space following copying data (useful for back up\n       versions).\n\n       You may also specify a change to directory blocks; for\n       partitioned data sets only, a new number or an\n       increment/decrement may be specified (no sign means\n       replace, a '+' causes that number to be added and a '-' to\n       be subtracted).  The new number may not be below the\n       currently used directory size when causing data to be\n       copied.\n\n       So, if SYS1.MACLIB is the data set shown in the data set\n       list, entering the command over ot of\n\n          CLONE  +17  RUBBER.DUCKY  EMPTY\n\n       will create a new PDS under your ID (assuming your prefix\n       is the default) with the name RUBBER.DUCKY with no members\n+                                                 _______________\n       and with 17 more directory blocks then the original.\n\n       For sequential data sets, specifying a number or a number\n+          __________\n       prefixed by a plus(+) or minus(-) will cause a change to\n       the logical record length. An unsigned number will cause\n       the resultant data set to have that number as its LRECL. A\n       plus value, +#, will cause # to be added to the LRECL; a\n       minus value, -#, will cause that # to be subtracted from\n       the LRECL. If the new record length is greater then the\n       old, blanks will be used to pad on the right. Variable\n       lengths are the LRECL, so for a maximum 1,000 bytes of\n       data, specify 1004.\n\n       If the following were overtyped on SYS1.MACLIB\n\n          CLONE  'SYS2.MACLIB'\n\n       a new PDS named SYS2.MACLIB would be created and all the\n       SYS1.MACLIB members copied to it.\n\n       Entering\n\n          CLONE  +90  =X\n\n       on SYS1.MACLIB, a new PDS named SYS1.MACLIBX would be\n       created with 90 more directory blocks then the current\n       allocation of SYS1.MACLIB and all the SYS1.MACLIB members\n       copied to it.\n\n       Entering an equal sign on subsequent data set lines under\n       DS List would cause the same command to be executed\n       against them. This is useful if you want to create back up\n1                      DSList Macros (Continued)                     Page     90\n\n       versions by date, e.g. CLONE =.D991231.\n\n\n CLONER  NEWDSN  ( # | +# | -# )  ( EMPTY )  ( RELEASE ) ( Q# )\n+______\n\n       creates a new data set with the same attributes as the one\n       overtyped, deleting the data set if it exists.\n       Sequential, partitioned data sets extended (PDSE's) or\n       partitioned data sets (PDS's) may be duplicated. NEWDSN\n       may be fully qualified with quotes, e.g.  'SYS4.MACLIB',\n       or allowed to take on the user prefix, e.g.  TEST.DATA.\n       Please note you must have sufficient access authority to\n       create a dataset under whatever security system is in use.\n\n       The original name may be used as a prefix by typing an\n       equal sign (=) followed by the intended suffix in place of\n       NEWDSN.  Overtyping SYS4.MACLIB with =.BKUP will produce a\n       new data set named SYS4.MACLIB.BKUP; the new data set name\n       may exist, but will be deleted if so, and should be a\n       legitimate name for the invoking user to create.\n\n       The original data set may be used as a suffix by typing\n       the intended prefix followed by an equal sign (=).\n+                          ___________\n       Overtyping SYS4.MACLIB with YOURUID.= will create a new\n       data set named YOURID.SYS4.MACLIB.\n\n       Using either the above mentioned prefixing or suffixing\n       options will always cause the resultant new data set name\n       to be fully qualified, i.e. as if it were input within\n       quotes. Use a blank following the new data set choice if\n       there is any doubt about how it will be \"seen\" by the\n       system.\n\n       An option of Q# will reduce the initial qualifiers of the\n       original data set by # for prefixed XXX= or the final\n       qualifiers for suffixed =XXX new data set names.  Given\n       the preceding example, a Q1 will cause YOURUID.MACLIB to\n       be created.\n\n       Optionally, EMPTY may be specified with the new name to\n       not cause data to be copied.\n\n       Optionally, RELEASE may be specified to release unused\n       space following copying data (useful for back up\n       versions).\n\n       You may also specify a change to directory blocks; for\n       partitioned data sets only, a new number or an\n       increment/decrement may be specified (no sign means\n       replace, a '+' causes that number to be added and a '-' to\n       be subtracted).  The new number may not be below the\n       currently used directory size when causing data to be\n       copied.\n1                      DSList Macros (Continued)                     Page     91\n\n\n       So, if SYS1.MACLIB is the data set shown in the data set\n       list, entering the command over ot of\n\n          CLONER  +17  RUBBER.DUCKY  EMPTY\n\n       will create a new PDS under your ID (assuming your prefix\n       is the default) with the name RUBBER.DUCKY with no members\n+                                                 _______________\n       and with 17 more directory blocks then the original,.\n       replacing RUBBER.DUCKY if it exists.\n\n       For sequential data sets, specifying a number or a number\n+          __________\n       prefixed by a plus(+) or minus(-) will cause a change to\n       the logical record length. An unsigned number will cause\n       the resultant data set to have that number as its LRECL. A\n       plus value, +#, will cause # to be added to the LRECL; a\n       minus value, -#, will cause that # to be subtracted from\n       the LRECL. If the new record length is greater then the\n       old, blanks will be used to pad on the right.\n\n       If the following were overtyped on SYS1.MACLIB\n\n          CLONER  'SYS2.MACLIB'\n\n       a new PDS named SYS2.MACLIB would be created and all the\n       SYS1.MACLIB members copied to it.\n\n       Entering\n\n          CLONER  +90  =X\n\n       on SYS1.MACLIB, a new PDS named SYS1.MACLIBX would be\n       created with 90 more directory blocks then the current\n       allocation of SYS1.MACLIB and all the SYS1.MACLIB members\n       copied to it.\n\n       Entering an equal sign on subsequent data set lines under\n       DS List would cause the same command to be executed\n       against them.  This is useful if you want to recreate back\n       up versions by date, e.g. CLONER =.D991231.\n\n\n COUNTX  ( ? )\n+______\n\n       will cause a message to be written as:\n\n          '-the-dataset-name-' (FBA /  133/27930)      3,225,818\n\n       with the record format, logical record length and block\n       size as well as the number of records for sequential\n       datasets. For VSAM ESDS's or KSDS's, it will only show:\n\n1                      DSList Macros (Continued)                     Page     92\n\n          '-the-dataset-name-'                           123,456\n\n       Subsequent files may be indicated using the equal sign as\n       in normal DS List usage. If a question mark immediately\n       follows the COUNTX, built in help will be displayed.\n\n\n DELCOLS   LEFT-COL1 RIGHT-COL1 (...)\n+_______\n\n       will remove the specified columns, shifting the remaining\n       leftwards, as in\n\n          DELCOLS  11  20\n\n       deleting column 11 through 20 and shifting everything from\n       column 21 to the end of each record left 10 columns.\n       DELCOLS may be used as a large scale truncating left\n       shift, that is,\n\n          DELCOLS  1  20\n\n       will cause all data to be shifted 20 positions to the\n       left.\n\n       DELCOLS is the reverse of KEEPCOLS, removing rather then\n       keeping data.  Given the following data:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       the results of 'DELCOLS  11 20  31 40' would be:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAACCCCCCCCCCEEEEEEEEEE\n          AAAAAAAAAACCCCCCCCCCEEEEEEEEEE\n          AAAAAAAAAACCCCCCCCCCEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       This macro is intended to be used from DS List when the\n       data set is too large to be edited.  Once the data set has\n       been \"reduced,\" CLONE may be used to recreate it with its\n       new size.\n\n\n EMPTY  ( ? )\n+_____\n\n       removes all data from sequential or partitioned data sets\n       (PDS's or PDSE's).  It will open and immediately close a\n       sequential file, thereby writing only an end of file\n       indicator. It will allocate a new PDS identical to the\n       original for partitioned data sets and then delete the\n1                      DSList Macros (Continued)                     Page     93\n\n       original and rename the new one to the original name.\n\n       It will display the name(s) of the data set(s) emptied.\n       If the question mark parameter is specified, the built in\n       help will be displayed but no data deleted.\n\n\n FINDNSTR   STRING   ( ? )\n+________\n\n       will cause a SuperC PDS scan to be invoked for the\n       specified string against the PDS(E) and the resultant scan\n       opened in Browse.  showing which members did not contain\n+                                                   ___\n       the string.  If it's not found at all, a simple message\n       indicates that.\n\n       The string may be specified by simply typing it without\n       quotes.  For example:\n\n          FINDNSTR  REXX\n\n       with 'REXX' overtyping the dataset name.  The results will\n       be placed in the default dataset from the Search-For\n       Utility option or SRCHFOR.LIST under the current user's ID\n       as well as opened in Browse mode.\n\n       If there's any doubt about how the string will be\n       recognized by DS List, simply place it in single quotes,\n       e.g.\n\n          FINDNSTR  'TRANSLATE('\n\n       An ampersand, &, must be doubled, i.e. && specified.\n\n       Both the string sought and the file name will be\n       displayed.  If a question mark (?) is specified or no\n       string at all, help will be shown. To search for a single\n       question mark, place it within quotes. For example,\n       'FINDNSTR  REXX' might generate (if looking for non REXX\n       executables):\n\n          MEMBER-SEARCHED         LINES-FOUND   LINES-PROC\n\n          FAND                            0          203\n          FNOT                            0          207\n          FOR                             0          203\n\n          ...\n\n          LINES-FOUND  LINES-PROC  MEMBERS-W/LNS  MEMBERS-WO/LNS\n                206        20476          136              3\n\n       The above shows that the 3 members listed did NOT contain\n       the string REXX.\n1                      DSList Macros (Continued)                     Page     94\n\n\n\n FINDSTRX   STRING   ( ? )\n+________\n\n       will cause a PDS(E) scan to be invoked for the specified\n       string and the resultant scan opened in browse if any\n       instances are found (a message will indicate none were\n       found if so).  The string may be specified by simply\n       typing it without quotes.  For example:\n\n          FINDSTRX SOME DUMB STRING\n\n       with 'SOME DUMB STRING' overtyping the dataset name.  The\n       results will be placed in the default dataset from the\n       Search-For Utility option or SRCHFOR.LIST under the\n       current user's ID as well as opened in Browse mode.\n\n       If there's any doubt about how the string will be\n       recognized by DS List, simply place it in single quotes,\n       e.g.\n\n          FINDSTRX  'TRANSLATE('\n\n       Both the string sought and the file name will be\n       displayed.  If a question mark (?) is specified\n       or no string at all, help will be shown. To\n       search for a single question mark, place it\n       within quotes.\n\n       The Browse will show the member name(s) where the string\n       was found as well as the individual lines where it was\n       found.\n\n       Please see the FS macro below which will submit the\n       equivalent scan of a PDS(E) as a regular job.\n\n\n HOWLONG  ( ? )\n+_______\n\n       for variable length data sets, HOWLONG will cause a\n       message to be written as:\n\n          '-the-dataset-name-' - LONGEST/SHORTEST IS 860/204\n\n       The lengths do not include the 4 byte length field nor the\n       4 byte block length field for variable (RECFM=V) files.\n       Note that the actual record length is often far larger\n       then the longest record on the file.\n\n       For a fixed record format file,a message such as:\n\n          '-the-dataset-name-' - LONGEST/SHORTEST IS 80/0\n            ----- BASED ON BLANKS AT END OF RECORDS (FIXED DATA SET)\n\n1                      DSList Macros (Continued)                     Page     95\n\n       will be produced. The macro counts the number of blanks\n       at the end of each line and considers the longest record\n       to be the one with the least number of blanks and the\n       shortest to be the one with the most number of blanks.\n       Assuming the '-the-dataset-name-' was an 80 byte file,\n       the 80/0 indicates that some record(s) had all 80 bytes\n       filled and some were all blank.\n\n       Subsequent files may be indicated using the equal sign as\n       in normal DS List usage.  A question mark as the only\n       parameter will cause the built in help to be displayed.\n\n\n KEEPCOLS  LEFT-COL1 RIGHT-COL1 (...)\n+________\n\n       will keep the specified columns, shifting them to the\n       left, as running the following against a 200 file:\n\n          KEEPCOLS  11 20  101 103  141 142\n\n       effectively deletes columns 1 through 10, 21 through 100,\n       104 through 140 and 143 through 200.  The selected columns\n       will be in the left-most 15 columns and the other 185\n       columns will be blank.\n\n       Given the following data:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       the results of 'KEEPCOLS  11 20' would be:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          bbbbbbbbbb\n          bbbbbbbbbb\n          bbbbbbbbbb\n          ----+----1----+----2----+----3----+----4----+----5\n\n       KEEPCOLS is also documented under Column Manipulation\n       macros since it can be invoked in Edit/View. Please see\n       CLONE to see how to copy a data set changed by KEEPCOLS to\n       a smaller version quickly.\n\n\n LASTREF\n+_______\n\n       will cause a message to be written as:\n\n          FILE -the-dataset-name- WAS LAST REFERENCED 1999/11/12\n\n       This will not cause the date to be updated.  Subsequent\n1                      DSList Macros (Continued)                     Page     96\n\n       files may be indicated using the equal sign as in normal\n       3.4 usage.\n\n\n QCLONE  NEWDSN  ( # | +# | -# )  ( EMPTY )  ( RELEASE ) ( Q# )\n+______\n\n       will submit a job to create a new data set with the same\n       attributes as the one overtyped.  If the EMPTY option is\n       specified, the allocation will be done immediately in the\n       EXEC.  Sequential, partitioned data sets extended (PDSE's)\n       or partitioned data sets (PDS's) may be duplicated. NEWDSN\n       may be fully qualified with quotes, e.g.  'SYS4.MACLIB',\n       or allowed to take on the user prefix, e.g.  TEST.DATA.\n       Please note you must have sufficient access authority to\n       create a dataset under whatever security system is in use.\n       This is essentially the same as CLONE except that the copy\n       is done in batch.\n\n       The original name may be used as a prefix by typing an\n       equal sign (=) followed by the intended suffix in place of\n       NEWDSN.  Overtyping SYS4.MACLIB with =.BKUP will produce a\n       new data set named SYS4.MACLIB.BKUP; the new data set name\n       must not exist and should be a legitimate name for the\n       invoking user to create.\n\n       The original data set may be used as a suffix by typing\n       the intended prefix followed by an equal sign (=).\n+                          ___________\n       Overtyping SYS4.MACLIB with YOURUID.= will create a new\n       data set named YOURID.SYS4.MACLIB.\n\n       Using either the above mentioned prefixing or suffixing\n       options will always cause the resultant new data set name\n       to be fully qualified, i.e. as if it were input within\n       quotes. Use a blank following the new data set choice if\n       there is any doubt about how it will be \"seen\" by the\n       system.\n\n       An option of Q# will reduce the initial qualifiers of the\n       original data set by # for prefixed XXX= or the final\n       qualifiers for suffixed =XXX new data set names.  Given\n       the preceding example, a Q1 will cause YOURUID.MACLIB to\n       be created.\n\n       Optionally, EMPTY may be specified with the new name to\n       not cause data to be copied (this is done in the TSO\n       session since it is only an allocate).\n\n       Optionally, RELEASE may be specified to release unused\n       space following copying data (useful for back up\n       versions).\n\n       You may also specify a change to directory blocks; for\n       partitioned data sets only, a new number or an\n1                      DSList Macros (Continued)                     Page     97\n\n       increment/decrement may be specified (no sign means\n       replace, a '+' causes that number to be added and a '-' to\n       be subtracted).  The new number may not be below the\n       currently used directory size when causing data to be\n       copied.\n\n       So, if SYS1.MACLIB is the data set shown in the data set\n       list, entering the command over ot of\n\n         QCLONE  +17  RUBBER.DUCKY  EMPTY\n\n       will create a new PDS under your ID (assuming your prefix\n       is the default) with the name RUBBER.DUCKY with no members\n+                                                 _______________\n       and with 17 more directory blocks then the original.\n\n       For sequential data sets, specifying a number or a number\n+          __________\n       prefixed by a plus(+) or minus(-) will cause a change to\n       the logical record length. An unsigned number will cause\n       the resultant data set to have that number as its LRECL. A\n       plus value, +#, will cause # to be added to the LRECL; a\n       minus value, -#, will cause that # to be subtracted from\n       the LRECL. If the new record length is greater then the\n       old, blanks will be used to pad on the right. Variable\n       lengths are the LRECL, so for a maximum 1,000 bytes of\n       data, specify 1004.\n\n       If the following were overtyped on SYS1.MACLIB\n\n         QCLONE  'SYS2.MACLIB'\n\n       a new PDS named SYS2.MACLIB would be created and all the\n       SYS1.MACLIB members copied to it.\n\n       Entering\n\n         QCLONE  +90  =X\n\n       on SYS1.MACLIB, a new PDS named SYS1.MACLIBX would be\n       created with 90 more directory blocks then the current\n       allocation of SYS1.MACLIB and all the SYS1.MACLIB members\n       copied to it.\n\n       Entering an equal sign on subsequent data set lines under\n       DS List would cause the same command to be executed\n       against them. This is useful if you want to create back up\n       versions by date, e.g. CLONE =.D991231.\n\n\n1                      DSList Macros (Continued)                     Page     98\n\n QCLONER  NEWDSN  ( # | +# | -# )  ( EMPTY )  ( RELEASE ) ( Q# )\n+_______\n\n       will submit a job to create a new data set with the same\n       attributes as the one overtyped, deleting the NEWDSN if it\n       exists.  If the EMPTY option is specified, the allocation\n       will be done immediately in the EXEC.  Sequential,\n       partitioned data sets extended (PDSE's) or partitioned\n       data sets (PDS's) may be duplicated. NEWDSN may be fully\n       qualified with quotes, e.g.  'SYS4.MACLIB', or allowed to\n       take on the user prefix, e.g.  TEST.DATA.  Please note you\n       must have sufficient access authority to create a dataset\n       under whatever security system is in use.  This is\n       essentially the same as CLONER except that the copy is done\n       in batch.\n\n       The original name may be used as a prefix by typing an\n       equal sign (=) followed by the intended suffix in place of\n       NEWDSN.  Overtyping SYS4.MACLIB with =.BKUP will produce a\n       new data set named SYS4.MACLIB.BKUP; the new data set name\n       must not exist and should be a legitimate name for the\n       invoking user to create.\n\n       The original data set may be used as a suffix by typing\n       the intended prefix followed by an equal sign (=).\n+                          ___________\n       Overtyping SYS4.MACLIB with YOURUID.= will create a new\n       data set named YOURID.SYS4.MACLIB.\n\n       Using either the above mentioned prefixing or suffixing\n       options will always cause the resultant new data set name\n       to be fully qualified, i.e. as if it were input within\n       quotes. Use a blank following the new data set choice if\n       there is any doubt about how it will be \"seen\" by the\n       system.\n\n       An option of Q# will reduce the initial qualifiers of the\n       original data set by # for prefixed XXX= or the final\n       qualifiers for suffixed =XXX new data set names.  Given\n       the preceding example, a Q1 will cause YOURUID.MACLIB to\n       be created.\n\n       Optionally, EMPTY may be specified with the new name to\n       not cause data to be copied (this is done in the TSO\n       session since it is only an allocate).\n\n       Optionally, RELEASE may be specified to release unused\n       space following copying data (useful for back up\n       versions).\n\n       You may also specify a change to directory blocks; for\n       partitioned data sets only, a new number or an\n       increment/decrement may be specified (no sign means\n       replace, a '+' causes that number to be added and a '-' to\n1                      DSList Macros (Continued)                     Page     99\n\n       be subtracted).  The new number may not be below the\n       currently used directory size when causing data to be\n       copied.\n\n       So, if SYS1.MACLIB is the data set shown in the data set\n       list, entering the command over ot of\n\n         QCLONER  +17  RUBBER.DUCKY  EMPTY\n\n       will create a new PDS under your ID (assuming your prefix\n       is the default) with the name RUBBER.DUCKY with no members\n+                                                 _______________\n       and with 17 more directory blocks then the original.\n\n       For sequential data sets, specifying a number or a number\n+          __________\n       prefixed by a plus(+) or minus(-) will cause a change to\n       the logical record length. An unsigned number will cause\n       the resultant data set to have that number as its LRECL. A\n       plus value, +#, will cause # to be added to the LRECL; a\n       minus value, -#, will cause that # to be subtracted from\n       the LRECL. If the new record length is greater then the\n       old, blanks will be used to pad on the right. Variable\n       lengths are the LRECL, so for a maximum 1,000 bytes of\n       data, specify 1004.\n\n       If the following were overtyped on SYS1.MACLIB\n\n         QCLONER  'SYS2.MACLIB'\n\n       a new PDS named SYS2.MACLIB would be created and all the\n       SYS1.MACLIB members copied to it.\n\n       Entering\n\n         QCLONER  +90  =X\n\n       on SYS1.MACLIB, a new PDS named SYS1.MACLIBX would be\n       created with 90 more directory blocks then the current\n       allocation of SYS1.MACLIB and all the SYS1.MACLIB members\n       copied to it.\n\n       Entering an equal sign on subsequent data set lines under\n       DS List would cause the same command to be executed\n       against them. This is useful if you want to create back up\n       versions by date, e.g. CLONE =.D991231.\n\n\n1                         Member List Macros                         Page    100\n\n\n The following macros may be entered on any Browse, Edit or\n View member list.\n\n\n LKDT LoadLib(Member)  ( ? )\n+____\n\n      displays the date and time a load module was link edited.\n      This depends on the AMBLIST LISTIDR function and will fail,\n      providing an error message, if the module's IDR is\n      corrupted or non-existent.  It may be invoked by direct\n      call, e.g.\n\n         TSO LKDT 'SYS1.LINKLIB(IEHPROGM)'\n\n      or by entering it on a member list under Browse, Edit or\n      View, e.g.\n\n         BROWSE            USERID.X.LOADLIB\n         Command ===>\n                    Name     Prompt        Alias-of     Size      TTR\n         _________ ABENDX                             00000278   001E23\n         lkdt_____ ADDCC                              008AF378   002109\n         _________ ALIAS                              00000498   00012E\n\n      which might result in the following being displayed:\n\n         ADDCC in 'USERID.X.LOADLIB' was linked\n             Friday May 23rd, 2003 (day 143)\n\n      A ? as the only argument causes the internal help to be\n      displayed. Obviously, this macro applies only to load\n      modules. As for other member commands, equal signs (=) may\n      be used to repeat the command against other members.\n\n      LKDT might fail if no IDR data is found; an appropriate\n      message is displayed.\n\n\n TD\n+__\n\n      displays the statistics associated with a member and, if\n      not cancelled, will remove the statistics from that member.\n      It is invoked by entering it on a member list under Browse,\n      Edit or View, e.g.\n\n         VIEW              USERX.CLIST\n         Command ===>\n                    Name     Prompt       Size   Created\n         td_______ ADDLINEB                  4  2002/09/14  2002/...\n         _________ ADDLINES                 90  2002/09/14  2002/...\n         _________ ALIGN                    68  2002/09/14  2002/...\n\n1                   Member List Macros (Continued)                   Page    101\n\n      which might result in the following being displayed:\n\n            -- PDS Statistics Display/Delete                   --\n\n          PDS:  USERX.CLIST\n          MEM:  ADDLINEB\n\n          Version:     12\n          Mod Count:   00\n          Create Dt:   02/09/14\n          Change Dt:   02/09/14\n          Change Tm:   07:56\n          Initial Sz:  4\n          Current Sz:  4\n          UserID:      USERX\n\n            -- Press <ENTER> to delete or <PF3> (END) to Quit  --\n\n      which, if <Enter> is pressed, will result in the member's\n      statistics being removed. Please see TU below to change or\n      update statistics.\n\n\n TU\n+__\n\n      displays the statistics associated with a member and, if\n      not cancelled, will update the statistics for that member.\n      It is invoked by entering it on a member list under Browse,\n      Edit or View, e.g.\n\n         VIEW              USERX.CLIST\n         Command ===>\n                    Name     Prompt       Size   Created\n         tu_______ ADDLINEB                  4  2002/09/14  2002/...\n         _________ ADDLINES                 90  2002/09/14  2002/...\n         _________ ALIGN                    68  2002/09/14  2002/...\n\n      which might result in the following being displayed:\n\n            -- PDS Statistics Display/Update                   --\n\n          PDS:  USERX.CLIST\n          MEM:  ADDLINEB\n\n          Version:     12\n          Mod Count:   00\n          Create Dt:   02/09/14\n          Change Dt:   02/09/14\n          Change Tm:   07:56\n          Initial Sz:  4\n          Current Sz:  4\n          UserID:      USERX\n\n            -- Press <ENTER> to update or <PF3> (END) to Quit  --\n1                   Member List Macros (Continued)                   Page    102\n\n\n      which, if any statistics are changed and <Enter> is\n      pressed, will result in the member's statistics being\n      updated. Please see TD above to remove statistics. If there\n      were no statistics and only some are entered, ISPF will\n      enter reasonable default values.\n\n\n1                        Miscellaneous Macros                        Page    103\n\n\n The following macros are not easily classifiable. Against that,\n they are often useful.\n\n Built in help is available by either typing the macro name\n without any parameters or with just a question mark (?) as the\n only operand.\n\n\n ADDLINES   MEMBER  ( LOCATION )  ( PREFIX )\n+________\n\n       will copy a member of a PDS being edited before or after\n       every other member in that PDS except the copied member.\n       MEMBER is the data member to be copied. LOCATION must be\n       either BEFORE or AFTER (BEFORE is the default). PREFIX may\n       be used to limit the members changed to only those that\n       begin with the specified prefix.  For example,\n\n          ADDLINES  JOBCARD  BEFORE  JCL\n\n       will copy the member named JOBCARD to the beginning of\n       every member with the prefix JCL.\n\n       Two associated macros are ADDLINEA and ADDLINEB, used\n       to do the copy after and copy before, respectively.\n\n\n ALLMEM   MACRO  ( PREFIX )\n+______\n\n       will execute a macro against every member of a PDS being\n       edited (edit any member and then invoke ALLMEM).  MACRO is\n       the macro code to be executed.  PREFIX is optional and may\n       be used to limit the members processed to only those that\n       begin with the specified prefix.  For example,\n\n          ALLMEM  ALLMEMC\n\n       will execute the macro ALLMEMC against every member of the\n       PDS.  The macro might look like:\n\n          /*** REXX  --  CHANGE STRINGS  --  USE WITH ALLMEM  ***/\n             \"ISREDIT MACRO\"\n             \"ISREDIT C  ALL 'OLD ACCOUNT INFO' 'NEW ACCOUNT INFO' \"\n             \"ISREDIT END\"\n\n       Note the END which forces the member to be saved and\n       allows processing to go on to the next member.  Two\n       associated macros in this package are ALLMEMC which\n       resembles the above code for changes and ALLMEMF which\n       does a find for a string and only brings up the members\n       that have the string, like:\n\n          /*** REXX  --  FIND SOME STRING  --  USE WITH ALLMEM  ***/\n1                  Miscellaneous Macros (Continued)                  Page    104\n\n             \"ISREDIT MACRO\"\n             \"ISREDIT SEEK  'DB2 ENVIRONMENT' \"\n             IF RC <> 0 THEN \"ISREDIT END\"\n\n       An example follows to scan members whose first character\n       is an 'A' and then delete all lines within those members\n       that contain 15 dots (...............).\n\n          /*** REXX  --  FIND AND DELETE LINES OF 'A' MEMBERS  ***/\n             \"ISREDIT MACRO\"\n             \"ISREDIT (PARMS) = MEMBER\"\n             \"ISREDIT SEEK  '...............'\"\n             DO WHILE RC = 0\n                \"ISREDIT (LINE,COL) = CURSOR\"\n                IF SUBSTR(PARMS,1,1) = 'A' THEN DO\n                   \"ISREDIT DELETE &LINE\"\n                END\n                \"ISREDIT SEEK  '...............'\"\n             END\n             \"ISREDIT END\"\n\n       Please also see XALLMEM below for a macro that does the\n       same function but may be executed from outside the PDS.\n\n\n ALLOCGDX  DSN | ? ( other Allocate parameters )\n+________\n\n       does equivalent of Allocate for a relative GDG entry\n       translating the relative numbered data set into a fully\n       qualified G....V00 name. For example:\n\n          AllocGDx 'rubber.ducky(-1)' dd(...) ...\n\n       would allocate the -1 file as the fully named\n       'rubber.ducky.g0011v00' (if appropriate).\n\n       Any additional normal Allocate parameters are passed as\n       is. The DSN may be quoted as shown or not, i.e. picking up\n       the prefix.  Use no parameters or a standalone ? to get\n       built-in help.\n\n\n BS   ( RECORD-LENGTH )  ( ? )\n+__\n\n       will ask for a record length, if not provided, and display\n       back the maximum normal (based on 32,760) block size, a\n       reasonably optimal block size based on 3390 half track\n       blocking (27,998 is half a track), and a large tape block\n       size based on 262,144 (256K appears to be the normal site\n       default). An example for \"TSO BS 333\" is:\n\n            LRECL 333, MAX BLKSZ= 32634,\n               OPT 3390 BLKSZ=27972 & LARGE BLKSZ=262071\n\n1                  Miscellaneous Macros (Continued)                  Page    105\n\n       Specifying a question mark as the parameter will cause the\n       built in help to be displayed.\n\n\n CC\n+__\n\n       will allow REXX arithmetic by direct input. It will\n       provide a quick intro line:\n\n          **  ENTER CALCUATIONS AND NULL ENTER TO QUIT...  **\n\n       All standard REXX arithmetic statements may then be\n       entered and the response immediately follows.  For\n       example,\n\n          (233+17)**2\n\n      returns 62500, effectively 250 squared.  Obviously,\n      parentheses may be used to force the order of operations\n      and/or make the logic of the operation more apparent.\n\n      In addition to + for addition, - for subtraction, * for\n      multiplication and / for division, // does a remainder\n      equivalent operation (16//5 is 1) and % does pure integer\n      division (16%5 is 3).  ** performs exponentiation.\n\n      The formula, courtesy of REXX, does not need to be\n      completely contiguous, so the following produce the same\n      result.\n\n         ( 233 + 17 ) ** 2\n\n      is equivalent to\n\n         (233+17)**2\n\n      As many calculations as desired may be entered and a simple\n      null (press of <ENTER> without any input) entry terminates.\n\n\n CLS\n+___\n\n      hopefully a generic TSO clear screen invocation. It uses\n      the CLRSCRN program also from File 357 on the CBT Tape,\n      simply invoking it as:\n\n            \"CALL 'your.loadlib(CLRSCRN)'\"\n\n\n COMPRS   ( PDS-NAME )  ( ? )\n+______\n\n      compresses either the PDS of the member being edited, the\n      default when no PDS-NAME is specified, or the specified\n      PDS-NAME.  IEBCOPY is invoked to do the actual compress.\n1                  Miscellaneous Macros (Continued)                  Page    106\n\n      The question mark will cause the built in help to be\n      displayed but will not invoke the compress.\n\n\n CONCATDD   DDNAME  DATASET-NAME  ( BOTTOM-OPTION )\n+________\n\n      concatenates a data set to the DDNAME provided, either at\n      the beginning or at the end of the concatenation.  If the\n      BOTTOM-OPTION is B, the file is concatenated at the bottom.\n      The default is to put it at the top. If the only parameter\n      passed is a question mark (?), then built in help will be\n      displayed. It will check whether the data set exists and\n      whether the dd name is actually allocated and issue\n      appropriate messages.\n\n      The DATASET-NAME should not be put in quotes and needs to\n      be fully qualified.  SYSEXEC and SYSPROC may have datasets\n      added to its concatenation wile in ISPF but CONCATDD must\n      be invoked outside of ISPF (or in a LOGON EXEC if your site\n      has such a thing) if DDNAME is ISPMLIB, ISPLLIB, ISPSLIB,\n      or ISPTLIB since they are in use while in ISPF.\n\n         \"EX 'YOURID.CLIST(CONCATDD)' 'SYSPROC YOURID.CLIST'\"\n\n      in a REXX macro will invoke CONCATDD from yout library and\n      add that library at the top of the SYSPROC concatenation.\n\n      If the data set is already in the concatenation, it is\n      effectively moved to the top or bottom, as specified.\n\n\n DESC\n+____\n\n      shows the logical record length (LRECL), block size BLKSIZE)\n      and number of records in upper right hand corner of display.\n\n      For example, on this file (at this moment), DESC would show\n      80/27920/5858.\n\n\n ENC  PASSWORD\n+___\n\n      encrypts a fixed format sequential file or member using\n      the specified password. Invoking it again with the same\n      password unencrypts the data.  It is not an extremely\n      secure method but does provide a fast way to hide\n      information. Passwords can be of any length.\n\n      The process uses some shifting to assure shallow testing\n      will not show the bit pattern used and to provide a\n      measure of protection even with one character passwords.\n      It may be invoked more then once, i.e. ENC XXX and then\n      ENC YYY. Invoking ENC in the reverse order, ENC YYY and\n      then ENC XXX will return the data to its original state.\n1                  Miscellaneous Macros (Continued)                  Page    107\n\n\n      Caution should be used to remember the password since it\n      may be difficult to recreate the file without the correct\n      password. Unencrypting before saving and then\n      re-encrypting would validate there was no error during\n      typing.\n\n      ENC2, described below, improves upon ENC in both hiding\n      data and protecting it. ENC has been left in the package\n      since it would be necessary for anyone who has data\n      encrypted using it.\n\n\n ENC2  PASSWORD\n+____\n\n      encrypts a file or member of any record format using the\n      specified password. Invoking it again with the same\n      password unencrypts the data.  It is not an extremely\n      secure method but does provide a fast way to hide\n      information. Passwords can be of any length.\n\n      The process uses the password to generate a series of\n      random overlays (exclusive or'ing) and to provide a\n      measure of protection even with one character passwords.\n      It may be invoked more then once, i.e. ENC2 XXX and then\n      ENC2 YYY. Invoking ENC2 in the reverse order, ENC2 YYY and\n      then ENC2 XXX will return the data to its original state.\n\n      ENC2 improves upon ENC above in that it is more sensitive\n      to the password and is not as repetitive, and uses\n      randomization more effectively.  ENC is still included\n      since someone may have encrypted data using it.\n\n      As an example, encrypting a simple file using \"A\" as the\n      password will protect all the data if \"a\" is tried. ENC\n      would show some data.\n\n      Caution should be used to remember the password since it\n      may be difficult to recreate the file without the correct\n      password. Unencrypting after saving and then\n      re-encrypting would validate there was no error during\n      typing.\n\n\n FOG  ( # )  ( ? )\n+___\n\n      generates pseudo random meaningless sentences useful for\n      testing with text or fleshing out meaningless documentation.\n      # is the number of sentences to be generated and defaults to\n      1. The generated text will be inserted either where the\n      cursor is positioned or immediately below the top line on\n      the displayed screen. For example, FOG 2 might produce:\n\n            In this regard, the independent functional\n1                  Miscellaneous Macros (Continued)                  Page    108\n\n            principle presents extremely interesting\n            challenges to the greater fight-worthiness\n            concept.   We can see, in retrospect, the\n            interrelation of system and/or subsystem\n            technologies is further compounded when taking\n            into account the management-by-contention\n            principle.\n\n      The CAPS ON|OFF setting will determine whether the text is\n      all upper or mixed case. If only the question mark is\n      entered, the built in help is displayed and no text is\n      generated. FOG may be useful for testing text applications\n      or padding required documentation, just to see if someone\n      actually reads it.\n\n\n FS  ( 'STRING TO BE FOUND' PDS-TO-BE-SEARCHED )  ( ? )\n+__\n\n      submits a job using the user ID of the TSO user to do\n      a SuperC scan of a PDS or PDSE for a given string.\n      For Example:\n\n        FS  'STRING TO BE FOUND'  PDS-TO-BE-SEARCHED\n\n      The user's ID will be used for the job name prefix, the\n      name field and the NOTIFY.\n\n      The string to be sought must be in quotes, either single or\n      double. The PDS(E) may be either unqualified, without\n      quotes where the user's ID will be prefixed, or within\n      quotes as a fully qualified name.\n\n      A question mark (?) as the only parameter or no parameters\n      at all will cause the built in help to be displayed.\n\n\n NEW  ( Data-Set Prime Secondary Format Rec-Length )  ( ? )\n+___\n\n       will allocate a file as NEW with the attributes specified.\n       If no parameters are provided or a question mark is given\n       as the first parameter, built in help will be displayed.\n\n       The Data-Set name may be provided without quotes whence it\n       will have the profile's prefix appended to its beginning\n       (note this is usually the user ID). If a single quote is\n       placed on both ends, that fully qualified name will be used.\n\n       The Prime and Secondary parameters indicate the primary\n       and secondary space parameters (in cylinders).\n\n       The Format provides th record format. FB, F, VB, V and U\n       are acceptable as well as FBA, FA, VBA, and VA. The\n       Rec-Length is the LRECL for all the formats except U where\n       it becomes the block size and the LRECL is set to 0. For\n1                  Miscellaneous Macros (Continued)                  Page    109\n\n       FB, the block size is set to a multiple of the LRECL less\n       then 27,998. For F, the block size is set to the LRECL.\n       For VB, the block size is set to 27,998. For V, the block\n       size is set to the LRECL + 4.\n\n       For example, specifying\n\n          NEW  $$$TEMP.DATA  5 2  FB 100\n\n       will create a new data set named userid.$$$TEMP.DATA\n       with a primary of 5 cylinders and a secondary of 2, and\n       its attributes will be fixed blocked, LRECL of 100, and\n       block size of 27,900.\n\n\n NEWP ( PDS-Name Prime Secondary Dir Format Rec-Length ) ( ? )\n+____\n\n       will allocate a PDS as NEW with the attributes specified.\n       If no parameters are provided or a question mark is given\n       as the first parameter, built in help will be displayed.\n\n       The Data-Set name may be provided without quotes whence it\n       will have the profile's prefix appended to its beginning\n       (note this is usually the user ID). If a single quote is\n       placed on both ends, that precise name will be used.\n\n       The Prime and Secondary parameters indicate the primary\n       and secondary space parameters (in cylinders). The Dir\n       parameter indicates the number of directory blocks to\n       be provided.\n\n       The Format provides the record format.  F, FB, FA, FBA, V,\n       VB, VA, VBA and U are acceptable.  And the Rec-Length is\n       the LRECL for all the formats except U where it becomes\n       the block size and the LRECL is set to 0. For FB, the\n       block size is set to a multiple of the LRECL less then\n       27,998. For F, the block size is set to the LRECL. For VB,\n       the block size is set to 27,998. For V, the block size is\n       set to the LRECL + 4.\n\n       For example, specifying\n\n          NEWP  'SYS4.MACLIB.BACKUP' 20 10 89  FB 80\n\n       will create a new PDS named SYS4.MACLIB.BACKUP with a\n       primary space allocation of 20 cylinders, a secondary of\n       10, and 89 directory blocks (45 fit on every 3390 track\n       except the last where the end of file marker reduces the\n       number to 44).  Its attributes will be fixed blocked,\n       LRECL of 80, and block size of 27,920.\n\n\n1                  Miscellaneous Macros (Continued)                  Page    110\n\n OPCODE  HEX-VALUE\n+______\n\n      will give a brief description of the assembler instruction\n      associated with the hex value. For example,\n\n         OPCODE  41\n\n      will show:\n\n         OP CODE '41' IS LOAD ADDRESS\n            WITH MNEMONIC LA        AND IS A(N)   RX   INSTRUCTION\n\n\n PACKDS  IN-DATA-SET  OUT-DATA-SET\n+______\n\n      will use IBM's free TRSMAIN utility to compress one\n      file into another new file created by the EXEC. So,\n\n         PACKDS  'QDSN.S020701.DATA' COMPRSED.S020701.DATA\n\n      will create the second file and compress the first into it.\n      This macro may be run from the Edit/View command line\n      or from a TSO command prompt.\n\n\n PDS2SEQ   PDS-name  Seq-Out-File  ( NOSEP )  ( ADD | REPLACE )\n+_______\n\n      unloads the specified partitioned data set (PDS) into a\n      sequential file with or without IEBUPDTE separator cards.\n      The RECFM, LRECL and BLKSIZE of the PDS are used for the\n      output file. A primary space parameter of 10 cylinders and\n      a secondary of 10 cylinders is used.  The unit parameter is\n      set to SYSDA.\n\n      The PDS-name supplies the partitioned data set name, either\n      fully qualified within quotes or without quotes where the\n      user prefix will be attached. Seq-Out-File names the\n      sequential file that will contain the unloaded records\n      and may be either fully or partially qualified.\n\n      NOSEP will cause no ./ separator cards to be output before\n      each member's data; the default is to generate them.  ADD\n      or REPLACE will change the option on the separator card\n      respectively to ADD or REPL, that is ./  ADD NAME=member.,\n      ADD is the default.\n\n         PDS2SEQ  'USER.MACLIB'  UNLOAD.USER.MACLIB  NOSEP\n\n      will cause the entire contents of 'USER.MACLIB' to be placed\n      in the sequential file 'user-prefix.UNLOAD.USER.MACLIB'\n      without any separator cards.\n\n\n1                  Miscellaneous Macros (Continued)                  Page    111\n\n SAVEINPL  ( ? )\n+________\n\n      will save the edited member in place, that is, it will\n      overlay the existing member.  The edited file must be a\n      member of a fixed length partitioned data set (record\n      format must be F or FB).  Also, the number of lines must\n      not have changed.  Note that it will not change the member\n      statistics (if any) and will issue a warning to that\n      effect.\n\n      Uses in core read and write, and so may be vulnerable to\n      out of memory conditions.Does not work with PDSE's.\n\n\n SLEEP  ( NUMBER-OF-SECONDS | ? )\n+_____\n\n      will delay responding the number of seconds specified,\n      defaulting to 5. If a question mark (?) or non numeric\n      value is specified, the built in help is displayed.  The\n      SYSCALLS environment must be available. This may be\n      useful for imbedding within another macro for usability or\n      simulation testing.\n\n\n TODAY  ( CCYYMMDD | CCYYDDD )  ( ? )\n+_____\n\n      will display a message of the form\n\n         Friday December 31st, 1999 (day 365) Lillian(152,384)\n\n      for either of the 2 date formats specified. If no date is\n      specified, today's date will be used.  The above message\n      would have come out if either\n\n         TSO  TODAY  1999365\n\n      or\n\n         TSO  TODAY  19991231\n\n      were invoked. A parameter of a question mark (?)  will\n      cause the built in help to be displayed. If the input date\n      is less then 15821015 (Lillian date 1), the resulting\n      Lillian date will be negative.\n\n\n TSJ  ( ? )\n+___\n\n      performs the equivalent of the TS (text split) prefix\n      command, optimumly assigned to a PFKey.  Simply place the\n      cursor under the column where the line is to be broken and\n      invoke TSJ.  The new line has the same indentation.\n\n1                  Miscellaneous Macros (Continued)                  Page    112\n\n      If the cursor is placed after all non-blank data on the\n      line, the next line is \"joined\" at the point where the\n      cursor is.  All blanks at the front of the next line are\n      removed before being joined at the cursor point.\n\n\n UNPACKDS  IN-DATA-SET  OUT-DATA-SET\n+________\n\n      will use IBM's free TRSMAIN utility to decompress one\n      file into another new file created by the EXEC. So,\n\n         UNPACKDS  COMPRSED.S020701.DATA  'QDSN.S020701.DATA'\n\n      will create the second file and decompress the first into\n      it. This macro may be run from the Edit/View command line\n      or from a TSO command prompt.\n\n\n VSAVE  ( ? )\n+_____\n\n      will allow the VIEWed file or member to be saved, including\n      any changes.  VSAVE works for sequential files, PDS's and\n      PDSE's.  It saves having to do a multi-screen replace but\n      remains in VIEW mode.  If a question mark (?) is specified\n      as the parameter, the built in help is displayed.\n\n      You still remain in View after the save is complete.\n\n\n VWV  ( ( limits )  VSAM-file-name ) ( ? )\n+___\n\n       pulls all or part of a specified VSAM file to a sequential\n       file under the user's ID of the form\n       $$$TEMP.VSAM.FLAT.FLhhmmss (where hhmmss is the time).\n       Limits as to the number of records to be pulled and other\n       constraints may be specified and must be before the VSAM\n       file name.\n\n       The limits may be COUNT(#), SKIP(#), FROMKEY(key),\n       TOKEY(key), FROMNUMBER(#), or TONUMBER(#), all IDCAMS\n       REPRO qualifiers.\n\n       The VSAM file name can be specified or defaulted from a DS\n       List entry.  It may be either unqualified, without quotes\n       where the user's ID will be prefixed, or within quotes as\n       a fully qualified name.\n\n       VWV puts you in View on the set specified and saves the\n       time-stamped file upon exit.\n\n       For example:\n\n          VWV  COUNT(500)  FROMKEY(XXX)  A-VSAM-FILE-UNDER-YOUR-ID\n\n1                  Miscellaneous Macros (Continued)                  Page    113\n\n       will View the first 500 records of that file starting at\n       key XXX and keep the file on exiting.\n\n       A question mark (?) as the only parameter or no parameters\n       at all will cause the built in help to be displayed.\n\n\n XALLMEM  ( ? )  PDS  MACRO\n+_______\n\n      will execute the macro specified against every member of\n      the partitioned data set named.  It may be invoked from\n      anywhere.  The macro must be accessible through SYSPROC or\n      SYSEXEC.  If a question mark (?) is specified as the first\n      parameter or no parameters are specified, the built in help\n      is displayed.\n\n      An example is:\n\n         TSO  XALLMEM  'SYS4.JOBLIB'  ALLMEMC\n\n      will execute ALLMEMC against every member of 'SYS4.JOBLIB'.\n      Quotes may be left off a data set under your user-ID, such\n      as:\n\n         TSO  XALLMEM  A.PDS.UNDER.YOUR.USERID  ALLMEMC\n\n      XALLMEM will not execute against a member with the same\n      name as the macro to be executed.Please see ALLMEM above\n      for sample EXEC's to be executed.\n\n\n ZVW  ( ? )\n+___\n\n      will attempt to View the dataset on which the cursor is\n      positioned. If there are & variables in the dataset name,\n      i.e. it's a PROC, the macro will attempt to fill in from\n      any PROC statement at the top of the file.  This works best\n      when assigned to a PF Key.\n\n      It opens the View within a new screen to allow swapping\n      back and forth.  Code to just do a View (within the same\n      screen session) is included but commented out.  A question\n      mark as the only parameter typed will cause built in help\n      to be displayed.\n\n\n1                   Things You May Never Want to Do                  Page    114\n\n\n The following issues were quickly resolved using the above\n macros.  As the header of this unit implies, you may never\n encounter these \"problems.\"  On the other hand, who knows...\n\n 1) Given a file of records and a list of account numbers,\n    identify those records that are on the account list.  Let's\n    suppose the records have a ten digit account number in\n    columns 21 through 30 (10 bytes) and the account list is in\n    columns 1 through 10.\n\n    Let's assume that all the account numbers in the record file\n    are unique and that each record file line has non blank\n    characters in columns 1 through 20. It's easy to check the\n    former condition via FINDDUPS and make the latter true by\n    doing a \"C P'=' '!' 1 ALL\" after the CLONE below and removing\n    that special character later.\n\n       CLONE the record file (for safety and to have the matched\n       records in one place)\n\n       Edit the record file and XCOPY the account file to the bottom\n\n       Shift the accounts 20 bytes to the right (do a \"))20\" on\n       the top account line and bottom account line)\n\n       FINDDUPS 21 30 (sort and show only those non-unique account\n       numbers\n\n       Any unexcluded lines are dups, that is, the record file\n       and the included account list have the same account\n       numbers, so do a \"DELETE ALL X\" which removes the\n       unmatched records\n\n       Exclude everything ( \"X 99999\" on the first prefix line)\n\n       Do a \"F '                    ' 1 ALL\" (finds the lines with\n       blanks in columns 1 through 20, i.e. the account numbers)\n\n       DELETE NX ALL (removes the account number, leaving the records)\n\n 2) Given a \"catastrophic\" error when doing an Easytrieve (yes,\n    that's the term the error message uses), you can check for\n    dups within a table load using FINDDUPS start-col1 end-col1.\n    There was no other elaborating text for the error.\n\n 3) To create a partial file of test data from a very large file\n    which will not be tolerated by Edit, simply CLONE the file\n    with the EMPTY option, Edit the empty new file and XCOPY in\n    some subset of the original file. You could copy the first\n    50, middle 100 and last 50 records, for example. You can then\n    free, via an 'F' command on ISPF 3.4 (DS List) the additional\n    space.\n1             Things You May Never Want to Do (Continued)            Page    115\n\n\n    If the file to be edited is variable with block size 27,998,\n    run HOWLONG against the file frist to get the longest record\n    size. Then CLONE the file to that record size plus 4 (for the\n    length). Quite often this will be sufficient to allow editing\n    since Edit apepars to allocate room for the maximum record\n    size.\n\n    See also VWV for a similar extract facility for VSAM.\n\n 4) To set a date as part of a data set name or even pass it as a\n    PARM value to a program, use the date tokens (&YYMMDD for\n    example) in SUBX. So the JCL stays the same but the submitted\n    JCL contains the date (or any of the other allowed tokens).\n    SUBX may be used in member lists too and the regular SUB\n    command causes a page enter (3 asterisks appear the bottom of\n    the page and you must press <Enter> to procede while SUBX\n    does the submit and returns control saving one whole\n    keystroke :)\n\n    For consistency and documentation reasons, you might want to\n    make ORIGIN the default parameter for your version of SUBX\n    (or use the new SUBO) and always use it in place of plain\n    SUB.\n\n 5) If your group has a file of data sets that are accessed on\n    a regular basis (a dumb 'read' to keep the data set from\n    being archived or deleted), use GETDSNS to retrieve a group\n    of data sets by wildcard. For example, GETDSNS SYS3.ARDX.*.\n    This is a lot faster (and more accurate) the typing them or\n    cutting and pasting.\n\n    If you need such a program, I'd suggest FOREVER on this same\n    CBT Tape file.  While this goes against what the DASD group\n    is trying to accomplish, it may be your only way to get your\n    job done.\n\n 6) To columnize data, i.e. put every word on a new line:\n       - do a SHIFT L 999 MAX to get data aligned against the\n         left hand margin\n       - do a DELBLANK\n       - do a TF2 on the first line\n\n 7) Suppose you have a very large data set and you want to\n    eliminate most of the data and consolidate it to a smaller\n    file but it's too big to edit.  CLONE the file to a back up\n    copy first (for safety both against finger-fumbles and lights\n    out). Then do a KEEPCOLS against the file in DS List\n    specifying the columns (one or more sets) to be kept. Then\n    finally CLONE that file specifying the new record length.\n\n    Let's consider a 500,000 record file named\n    USERID.REALLY.BIG.FILE of 300 bytes each, and suppose you\n    need the first 10 columns and the last 10.\n1             Things You May Never Want to Do (Continued)            Page    116\n\n\n    Back it up by doing a \"CLONE  =.BKUP\". Then do\n    \"KEEPCOLS  1 10  291 300\" and finally a \"CLONE  =.NEW  20\".\n    You will now have 3 data sets, the original in\n    USERID.REALLY.BIG.FILE.BKUP, the changed one in\n    USERID.REALLY.BIG.FILE, and the new small one in\n    USERID.REALLY.BIG.FILE.NEW.\n\n 8) If you want to reformat a file in Edit/View, I'd suggest:\n       - CLONE the file first (for safety)\n       - save periodically\n       - put a sample of what you want as a result at the top\n         of the file and use labels to limit the changes\n       - work consistently from right to left\n       - stack commands using the semi-colon, e.g.\n         DELCOLS 1 7; FILLINS 22 '-->';MOVEINSD 43 55 27\n\n 9) To add a number of header lines after every 50 lines of a\n    data file:\n       - given:\n            A1 ... first 50 lines ...\n            B2 ... second 50 lines ...\n            C3 ... third 50 lines ...\n            D4 ... last 50 lines ...\n       - CUTX just the header lines\n       - add a blank line before A1\n       - put a C9999 on the blank line just inserted\n       - enter 'PASTEAFT 50' on the command line and press enter\n       - delete the blank line\n       - you may have to delete the very last lines if there were\n         an even 50 multiple of data lines\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@MACDOCO": {"ttr": 8452, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x16\\xc1\\x16\\xc1\\x00\\x00\\xc4\\xd6\\xc3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 5825, "newlines": 5825, "modlines": 0, "user": "DOC"}, "text": ":*  Full formal documentation for CLISTs and EXECs\n:PAGESIZE  55\n:LINESIZE  80\n:TOC       YES\n:DOCTITLE  TSO\n:DOCTITLE2 Productivity\n:DOCTITLE3 Extensions\n:TLRDATE   June 15, 2004\n:TLRDESC   Freeware from Steli Inc.\n:HEADER1   Introduction\n\n This document is intended to provide user information for the\n OS/390 and z/OS MVS freeware REXX and CLIST macros included in\n this package.  Some understanding of the operating system, TSO,\n and ISPF Edit, View and DS List is required.\n\n These are freeware macros which have been gathered together to\n provide consistent, proven and documented tools to:\n\n    - reduce key strokes\n\n    - improve visualization\n\n    - eliminate custom coding to accomplish a task\n\n    - automate a calculation\n\n In other words, they're intended to help improve mainframe user\n productivity.  These macros extend various ISPF capabilities to:\n\n    - Manipulate columns of data\n\n    - Convert data\n\n    - Manipulate code\n\n    - Manipulate JCL\n\n    - Display (include/exclude) data differently\n\n    - Consolidate data\n\n    - Format data\n\n    - Find data differently\n\n These tools were created by Steli or modified from source made\n available by others.  Names were chosen as seemed appropriate\n but nothing prevents changing them to other, hopefully more\n meaningful ones.  Steli has made its best effort to provide\n working, tested code.  However, nothing is perfect - there may\n be flaws due to oversights, system variations, or errors, and\n there certainly could be improvements.  All questions, concerns,\n problems and suggestions are welcome; e-mail may be sent to\n C_Hafner@HotMail.Com.\n\n Particular thanks for assistance, encouragement, (good) ideas\n and sample code go to Dave Alcock, Larry Dick, Hugh Mitchell,\n Jim Moore, Doug Nadel, Richard Rubin, Gilbert StFlour and Mark\n Zelden.\n\n\n:HEADER1 Known Problems\n\n The COBCOLO and COBCOLS macros using InSync and FileAid do not\n always complete correctly when REDEFINES or OCCURS are present.\n We have been working to eliminate these glitches but we may not\n have them all corrected. OCCURS within OCCURS definitely\n presents a challenge. COBCOLV, the direct call to InSync or\n FileAid obviously functions correctly.\n\n TSO apparently does not have a generic clear screen function\n that exists on every (or most) systems.  The function used\n throughout many macros herein is:\n\n    ADDRESS TSO \"CLEAR\"\n\n It is always written exactly as shown!  This may not work at\n your site depending on how/what the systems folks have set up.\n If need be, I'd suggest using ALLMEM (and ALLMEMC with the\n appropriate change command) to either comment the statement out\n or replace it with the call shown in the following paragraph.\n\n The same CBT Tape File 357 that contains this macro package also\n contains an assembler clear screen program that appears to be\n universal. The program is called CLRSCRN and would be invoked in\n place of the above as :\n\n       \"CALL 'YOUR.LOAD.MODULE.LIB(CLRSCRN)'\"\n\n We have also been told many of the macros run slowly as the\n edited data sizes grow. We can only suggest running them in\n batch to alleviate this. As time permits, we will review all of\n the macros again trying to improve their performance.\n\n\n:HEADER1 Gaining Execution Access\n\n To use these macros, you may add a library (a Partitioned Data\n Set or Partitioned Data Set Extended) with those macros to your\n SYSPROC DD under TSO or place the macros in an existing library\n already in the SYSPROC concatenation.  Use TSO ISRDDN to check\n the DD files associated with your TSO LOGON.  For the latter,\n simply copy the members you want into an existing library\n (please note these macros are in fixed record format of 80 bytes\n - they will not play nicely with VB/255 libraries).  The\n CONCATDD macro will help do the former.  Assuming that you've\n loaded them to your own library and they're in YOURID.CLIST,\n execute under the TSO command option:\n\n      EX 'YOURID.CLIST(CONCATDD)' 'SYSPROC YOURID.CLIST'\n\n There are a few CLISTs in this collection so I've always\n concatenated my library to the front of SYSPROC rather then to\n SYSEXEC.  I have also seen problems when trying to concatenate\n to SYSEXEC from within certain LOGON EXEC's (EXEC's specified in\n a sequential file executed when you logon, if it exists with a\n specific pattern, e.g. YourUserID.SIGNON).  Use TSO ISRDDN to\n check the allocation to make sure your file is there if you get\n macro not found messages.\n\n The above command will dynamically add YOURID.CLIST (note fully\n qualified with no quotes) to the front of the SYSPROC\n concatenation for this current LOGON.  Many sites have a sign-on\n process that will let you execute this line automatically each\n time you logon (please see comment above about using SYSEXEC).\n\n The following macros, with the exception of the DS List macros\n and member list macros, are executable under either EDIT or VIEW\n (some, such as BS or CC may be invoked anywhere, ala TSO BS\n 120).  The benefits of use are available in VIEW and the\n resulting data, even if changed, can use VSAVE or REPLACE to\n save existing data, or CREATE a new member.  Plus VIEW provides\n a safety factor in that an accidental F3 press will not overlay\n good data and you get a warning that data has changed.\n Whatever, when doing extensive changes, saving is always a good\n+          _____________________________________________________\n idea!\n+_____\n\n The following PF key assignments are suggested to maximize the\n+                                     _________\n effect of the provided tool set.  Note there is no DELETE key!\n Unless you are extremely precise, it's all too easy to\n accidently delete a line.\n\n       F1 . . . HELP           F13  . .  %TSJ\n       F2 . . . SPLIT NEW      F14  . .  SWAP LIST\n       F3 . . . EXIT           F15  . .  CUT\n       F4 . . . :I             F16  . .  %PY\n       F5 . . . RFIND          F17  . .  %FALT\n       F6 . . . RCHANGE        F18  . .  :R\n       F7 . . . UP             F19  . .  %JB\n       F8 . . . DOWN           F20  . .  %JT\n       F9 . . . SWAP NEXT      F21  . .  %XINDENT\n       F10  . . LEFT           F22  . .  %DISPVAR\n       F11  . . RIGHT          F23  . .  %ZVW\n       F12  . . :COLS          F24  . .  CRETRIEV\n\n Most of the above key assignments are generic ISPF commands with\n the exception of DISPVAR, FALT, JB, JT, PY, TSJ, XINDENT and ZVW\n which come with this package.\n\n If you use KEYLIST OFF as I do, please be aware that every\n separate application has its own KEYS settings.\n\n\n:HEADER1 Column Manipulation Macros\n\n The following are column oriented macros. If you type the macro\n name on the command line without any parameters, you'll get a\n help screen describing it.\n\n They also will accept and use line labels like .A and .B as\n shown in their formats (but any legal labels may be used).  The\n ability to set and keep labels was deliberately done to allow for\n repeated changes to the same set of lines.  Optional parameters\n are shown in parentheses.\n\n\n:HEADER2 COPYCOLS   FROM-LEFT-COL  FROM-RIGHT-COL  TO-LEFT-COL ( .A .B )\n:HEADERT Copy Columns Onto Other Columns\n\n       copies columns over other columns, e.g.\n\n          COPYCOLS  11 20  41\n\n       will leave the data in columns 11 thru 20 as it exists\n       and make a copy onto columns 41 thru 50. The columns are\n       mandatory but the label ranges are optional. Given the\n       following data:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       the results of 'COPYCOLS 11 20 41' would be:\n\n          ----+----1----+----2----+----3----+----4----+----5-\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddbbbbbbbbbb\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddbbbbbbbbbb\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddbbbbbbbbbb\n          ----+----1----+----2----+----3----+----4----+----5-\n\n\n:HEADER2 COPYINS   FROM-LEFT-COL  FROM-RIGHT-COL  TO-LEFT-COL  ( .A .B )\n:HEADERT Copy Columns Inserting Before Other Columns\n\n       copies columns into the data, that is, the copied data\n       will be inserted at the TO-LEFT-COL column and the columns\n       from the TO-LEFT-COL to the right will be shifter\n       accorcingly.  The columns are required but the ranges are\n       optional. For example:\n\n          COPYINS  11  20  1  .XX .YY\n\n       will take a copy of columns 11 thru 20 in the range of .XX\n       through .YY and put them in column 1 through 10 shifting\n       what was in column 1 and following 9 columns to the right.\n       For example, given:\n\n          000001 AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n          =COLS> ----+----1----+----2----+----3----+----4----+----5\n          .XX    AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n          000003 AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n          .YY    AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n          =COLS> ----+----1----+----2----+----3----+----4----+----5\n          000005 AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n\n       the result of 'COPYINS  11  20  1  .XX .YY' would be:\n\n          000001 AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n          =COLS> ----+----1----+----2----+----3----+----4----+----5\n          .XX    bbbbbbbbbbAAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n          000003 bbbbbbbbbbAAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n          .YY    bbbbbbbbbbAAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n          =COLS> ----+----1----+----2----+----3----+----4----+----5\n          000005 AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n\n\n:HEADER2 CVB  FROM-COL1 FROM-COL2 (TO-COL1 TO-COL2) (-MINUS-COL) (.A .B)\n:HEADERT Convert Numeric Display Data to Binary\n\n       converts the numbers in the specified columns to binary.\n       The FROM- columns specify the numeric display data and are\n       mandatory.  The TO- columns are optional and will receive\n       the result; if left off, the result will be placed in the\n       FROM- columns.  The receiving field does not have to be a\n       multiple of 2, but probably should be 2, 4 or 8.\n\n       The -MINUS-COL value, of the form -17, indicates the\n       column from which to pick up the plus or minus sign.  If\n       no sign column is specified, the zone of the rightmost\n       numeric digit will be used as the sign.  For example,\n\n          CVB  1 7  11 14  -8  .AA .XX\n\n       will convert the numeric data in columns 1 through 7 into\n       binary in columns 11 through 14, causing the binary value\n       to take on the sign from column 8, in the range of label\n       .AA to .XX.\n\n       Note that CAPS will be turned off and a message will be\n+      _________________________________\n       displayed saying so.\n\n       A message showing the number of overflows and the total\n       valid numbers found will appear in the upper right corner.\n       F1 may be pressed to see a somewhat fuller explanation.\n\n       CVB may be used after FORMCOLS eliminates commas and\n       aligns the data. DELCOLS may be used to remove periods\n       after FORMCOLS is complete.\n\n       Given the following data:\n\n          000001 0000001\n                 FFFFFFF44444444444444\n                 000000100000000000000\n          =COLS> ----+----1----+----2-\n          .AA    0000002\n                 FFFFFFF44444444444444\n                 000000200000000000000\n          000003 0000003-\n                 FFFFFFF64444444444444\n                 000000300000000000000\n          .XX    0000004\n                 FFFFFFF44444444444444\n                 000000400000000000000\n          =COLS> ----+----1----+----2-\n          000005 0000005\n                 FFFFFFF44444444444444\n                 000000500000000000000\n\n       the results of 'CVB  1 7  11 14  -8  .AA .XX' would be:\n\n          000001 0000001\n                 FFFFFFF44444444444444\n                 000000100000000000000\n          =COLS> ----+----1----+----2-\n          .AA    0000002\n                 FFFFFFF44400004444444\n                 000000200000020000000\n          000003 0000003-     \u00d9\n                 FFFFFFF644FFFF4444444\n                 0000003000FFFD0000000\n          .XX    0000004\n                 FFFFFFF44400004444444\n                 000000400000040000000\n          =COLS> ----+----1----+----2-\n          000005 0000005\n                 FFFFFFF44444444444444\n                 000000500000000000000\n\n\n:HEADER2 CVD  FROM-COL1 FROM-COL2 (TO-COL1 TO-COL2) (-MINUS-COL) (.A .B)\n:HEADERT Convert Binary Data to Numeric Display Data\n\n       converts binary data to numeric display data.  The FROM-\n       columns specify the source binary value. The length of the\n       FROM- columns does not have to be a multiple of 2. The TO-\n       columns specify the destination and will default to the\n       FROM- columns if they are not specified.\n\n       The -MINUS-COL, specified as a column number with a minus\n       sign, will receive the sign of the result, otherwise the\n       sign will be placed as the zone value of the rightmost\n       result digit, e.g. 'J' for minus 1. For example,\n\n          CVD  11 18  21 29  -30  .A .B\n\n       will convert the binary data in columns 11 through 18 into\n       numeric displayable data in columns 21 through 29, placing\n       the appropriate plus/minus sign into column 30 in the line\n       range .A through .B.\n\n       A message showing the number of overflows and the number\n       of lines processed will appear in the upper right corner.\n       F1 may be pressed for an expanded explanation.\n\n       FORMCOLS may be used to neatly format the resultant data\n       and FILLINS to insert periods.\n\n       Given the following data:\n\n          000001\n                 4444444444000000004444444444444\n                 0000000000000000010000000000000\n          =COLS> ----+----1----+----2----+----3-\n          .A\n                 4444444444000000014444444444444\n                 0000000000000000000000000000000\n          000003\n                 4444444444000000004444444444444\n                 0000000000000000100000000000000\n          .B\n                 4444444444000000104444444444444\n                 0000000000000000000000000000000\n          =COLS> ----+----1----+----2----+----3-\n          000005\n                 4444444444000000004444444444444\n                 0000000000000001000000000000000\n\n       the results of 'CVD  11 18  21 29  -30  .A .B' would be:\n\n          000001\n                 4444444444000000004444444444444\n                 0000000000000000010000000000000\n          =COLS> ----+----1----+----2----+----3-\n          .A                         000000016+\n                 44444444440000000144FFFFFFFFF44\n                 00000000000000000000000000016E0\n          000003                     000000256+\n                 44444444440000000044FFFFFFFFF44\n                 00000000000000001000000000256E0\n          .B                         000004096+\n                 44444444440000001044FFFFFFFFF44\n                 00000000000000000000000004096E0\n          =COLS> ----+----1----+----2----+----3-\n          000005\n                 4444444444000000004444444444444\n                 0000000000000001000000000000000\n\n\n:HEADER2 C2H  FROM-COL1 FROM-COL2  (TO-COL1 TO-COL2)  (.A .B)\n:HEADERT Convert Hex Characters to Hex Equivalent\n\n       converts hexidecimal characters, 'A'-'F' and '0'-'9', to\n       their hex value, e.g. turns '0123456789ABCDEF' into\n       X'0123456789ABCDEF'. The FROM- columns are required.  The\n       TO- columns specify the destination and will default to\n       the FROM- columns if unspecified.\n\n       Given the following data,\n\n          000000\n          FFFFFF444444444444444444444444\n          000000000000000000000000000000\n          ----+----1----+----2----+----3\n          999999\n          FFFFFF444444444444444444444444\n          999999000000000000000000000000\n          ----+----1----+----2----+----3\n          012AC3\n          FFFCCF444444444444444444444444\n          012133000000000000000000000000\n\n       the result of\n\n          C2H  1 6  11 13\n\n       would be:\n\n          000000\n          FFFFFF444400044444444444444444\n          000000000000000000000000000000\n          ----+----1----+----2----+----3\n          999999    rrr\n          FFFFFF444499944444444444444444\n          999999000099900000000000000000\n          ----+----1----+----2----+----3\n          012AC3      C\n          FFFCCF444402C44444444444444444\n          01213300001A300000000000000000\n\n       No conversion will take place on lines where the receiving\n       field is shorter then the converted data and the lost\n       columns would not be hex zeros. Hex zeros will be used to\n       left pad short receiving fields.\n\n       A message showing the number of lines processed, overflows\n       and the number of lines with bad data (that is, not 'A'\n       thru 'F' or '0' thru '9').  F1 may be pressed for an\n       expanded explanation. See H2C below for the converse.\n\n\n:HEADER2 DELCOLS   LEFT-COL1 RIGHT-COL1 (...)  ( .A .B )\n:HEADERT Delete Columns\n\n       will remove the specified columns, shifting the remaining\n       leftwards, as in\n\n          DELCOLS  11  20\n\n       deleting column 11 through 20 and shifting everything from\n       column 21 to the end of each record left 10 columns.\n       DELCOLS may be used as a large scale truncating left\n       shift, that is,\n\n          DELCOLS  1  20\n\n       will cause all data to be shifted 20 positions to the\n       left, but please also see SHIFT for other options.\n\n       DELCOLS is the reverse of KEEPCOLS, removing rather then\n       keeping data.  Given the following data:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       the results of 'DELCOLS  11 20  31 40' would be:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAACCCCCCCCCCEEEEEEEEEE\n          AAAAAAAAAACCCCCCCCCCEEEEEEEEEE\n          AAAAAAAAAACCCCCCCCCCEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       Please note the columns specified are always based on the\n       original record.  The process may be limited to ranges of\n       line via either labels or C/CC/C# prefix selection. This\n       macro may also be invoked against a file under DS List and\n       will be shown in that section. The latter is useful when\n       the file is too big to be edited.\n\n\n:HEADER2 FILLCOLS   LEFT-COL  RIGHT-COL  STRING  ( .A .B )\n:HEADERT Overlay Columns with a Given String\n\n       overlays the specified columns with the given string, as\n\n          FILLCOLS  2  9  '-*'\n\n       will make columns 2 thru 9 contain -*-*-*-*.  The string\n       will overlay as many copies as necessary to fill the\n       columns, for example:\n\n          FILLCOLS  2  9  '-=-'\n\n       will only overlay -=--=--= onto columns 2 thru 9.  The\n       columns and string are mandatory and the label range\n       optional.\n\n       For example, given the following data:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       the results following 'FILLCOLS  21 30  123' would be:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbb1231231231ddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbb1231231231ddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbb1231231231ddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n\n:HEADER2 FILLINS   LEFT-COL  STRING  ( .A .B )\n:HEADERT Insert a Given String Before a Column\n\n       inserts the string before the specified column shifting\n       the current data to the right, e.g.\n\n          FILLINS  19  'XXX'\n\n       will insert 3 X's into columns 19, 20 and 21, and shift\n       everything in the original column 19 on 3 columns to the\n       right. FILLINS may be used as a right shift, namely\n\n          FILLINS  1  '     '\n\n       will shift everything to the right the number of blanks\n       between the quotes but please also see the SHIFT macro.\n       The columns and string are mandatory and the label range\n       optional.  The shifting may result in data loss on the far\n       right of the record.\n\n       Given the following data:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       the result of 'FILLINS  11  XXXXXXXXXX' would be\n\n          ----+----1----+----2----+----3----+----4----+----5----+----6\n          AAAAAAAAAAXXXXXXXXXXbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAXXXXXXXXXXbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAXXXXXXXXXXbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5----+----6\n\n\n:HEADER2 FORMCOLS FORMAT FROM-LEFT FROM-RIGHT (TO-LEFT TO-RIGHT)(.A .B)\n:HEADERT Format Numeric Display Data Using Picture Format\n\n       will reformat the arithmetic display data in the\n       FROM- columns into the TO- columns, aligning and right\n       justifying the data, using the formatting characters to\n       define the output.  If omitted, the to-columns will\n       default to the from-columns.  It will eliminate commas in\n       the input, strip input of leading and trailing blanks and\n       extraneous leading zeros and pick a up sign from anywhere\n       in the input columns, including a zoned last character.\n\n       The format specified is filled from the data. The special\n       characters used are:\n\n             9   replace with a digit or a zero if no digit\n\n             Z   replace with a digit or a blank if leading\n                 digit zero - may be used on far left and/or far\n                 right of supplied format\n\n             ,   leave unless no significant digits to left then\n                 blank\n\n             .   leave and use to align data\n\n             +   replace with actual sign, either + or -\n\n             -   replace with blank if data not negative else\n                 leave\n\n       For example,\n\n          FORMCOLS  'ZZZ,ZZ9.99Z +'  1 10  21 35\n\n       will reformat\n\n             '   123    '              '      123.00  +'\n             '1234567890'              '  567,890.00  +'\n             '   11.M   '    into      '       11.40  -'\n             '2,468.00- '              '    2,468.00  -'\n             '  +0      '              '        0.00  +'\n\n       Note FORMCOLS will handle input commas as the 4th example\n       above shows and will check for the sign anywhere in the\n       input.\n\n       A message showing the total valid numbers found, the\n       number of overflows and the number of lines processed\n       will appear in the upper right corner. The above would\n       produce \"5/1/5 FORMATTED\" since the second set of data\n       would cause an overflow. An overflow is considered to\n       be any loss of a significant (non zero) digit. Pressing\n       PF1 immediately afterwards will describe the message.\n\n       FORMCOLS can be used with CVD or UNPK to gain access to\n       and neatly format originally binary or packed data.  It\n       may be used prior to CVB or PK to clean up data.  MOVEINSD\n       may be used to move the decimal point or FILLINS to insert\n       one, if desired.\n\n\n:HEADER2 H2C  FROM-COL1 FROM-COL2  (TO-COL1 TO-COL2)  (.A .B)\n:HEADERT Convert Characters to Their Hex Equivalent\n\n       converts characters, X'00'-X'FF', to their hex equivalent,\n       '00' thru 'FF'.  H2C would turn X'0123456789ABCDEF' into\n       '0123456789ABCDEF'. The FROM- columns are required.  The\n       TO- columns specify the destination and will default to\n       the FROM- columns if unspecified.\n\n       Given the following data,\n\n          02468ACE4444444444444444444444\n          13579BDF0000000000000000000000\n          ----+----1----+----2----+----3\n          000000004444444444444444444444\n          000000000000000000000000000000\n          ----+----1----+----2----+----3\n          000000FC4444444444444444444444\n          000000AE0000000000000000000000\n\n       the result of\n\n          H2C  1 8  11 26\n\n       would be:\n                    0123456789ABCDEF\n          02468ACE44FFFFFFFFFFCCCCCC4444\n          13579BDF0001234567891234560000\n          ----+----1----+----2----+----3\n                    0000000000000000\n          0000000044FFFFFFFFFFFFFFFF4444\n          000000000000000000000000000000\n          ----+----1----+----2----+----3\n                    000000000000FACE\n          000000FC44FFFFFFFFFFFFCCCC4444\n          000000AE0000000000000061350000\n\n       No conversion will take place on lines where the receiving\n       field is shorter then the converted data and the lost\n       columns would not be zeros. Zeros will be used to\n       left pad short receiving fields.\n\n       A message showing the number of lines processed and\n       overflows (there can not be bad data since all hex values\n       are processed).  F1 may be pressed for an expanded\n       explanation. See C2H above for the converse.\n\n\n:HEADER2 JOINCOLS  COL-1 ( ... )  ( .A  .B )\n:HEADERT Concatenate Lines at Given Columns\n\n      this macro will concatenate subsequent lines to the\n      preceding line at the column or columns specified. One\n      column is required.  For example\n\n         JOINCOLS  21 41 61\n\n      will append the 2nd line to the 1st at position 21, the 3rd\n      to the combined 1st and 2nd at position 41, and the 4th to\n      the combined 1st, 2nd and 3rd at position 61.  Please note\n      SPLTCOLS with the same parameters produces the reverse,\n      i.e. it splits them back again given no data was lost when\n      the JOINCOLS was done\n\n      For example, given the following data:\n\n         AAAAAAAAAA\n         ----+----1----+----2----+----3----+----4----+----5\n         bbbbbbbbbb\n         CCCCCCCCCC\n         dddddddddd\n         EEEEEEEEEE\n         AAAAAAAAAA\n         bbbbbbbbbb\n         CCCCCCCCCC\n         dddddddddd\n         EEEEEEEEEE\n         AAAAAAAAAA\n         bbbbbbbbbb\n         CCCCCCCCCC\n         dddddddddd\n         ----+----1----+----2----+----3----+----4----+----5\n         EEEEEEEEEE\n\n      the results of 'JOINCOLS  11  21  31  41' would be:\n\n         AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n         ----+----1----+----2----+----3----+----4----+----5\n         AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n         AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n         ----+----1----+----2----+----3----+----4----+----5\n\n\n:HEADER2 KEEPCOLS  LEFT-COL1 RIGHT-COL1 (...)  ( .A .B )\n:HEADERT Retain Columns Deleting All Other Columns\n\n       will keep the specified columns, shifting them to the\n       left, as running the following against a 200 file:\n\n          KEEPCOLS  11 20  101 103  141 142\n\n       effectively deletes columns 1 through 10, 21 through 100,\n       104 through 140 and 143 through 200.  The selected columns\n       will be in the left-most 15 columns and the other 185\n       columns will be blank.\n\n       KEEPCOLS is the reverse of DELCOLS, retaining rather then\n       removing data.  Given the following data:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       the results of 'KEEPCOLS  11 20' would be:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          bbbbbbbbbb\n          bbbbbbbbbb\n          bbbbbbbbbb\n          ----+----1----+----2----+----3----+----4----+----5\n\n       The process may be limited to a range of lines via either\n       labels or C/CC/C# prefix selection. This macro may also\n       be invoked against a file under DS List and will be\n       shown in that section.\n\n\n:HEADER2 MOVECOLD   FROM-LEFT-COL  FROM-RIGHT-COL  TO-LEFT-COL ( .A .B )\n:HEADERT Move Columns Overlaying Destination and Deleting Source\n\n       will take the specified columns and overlay them onto the\n       receiving column, deleting the originating data.  For\n       example,\n\n          MOVECOLS  21 25  68\n\n       will replicate what's in columns 21 thru 25 onto columns\n       68 thru 72 and then delete columns 21 thru 25, shifting\n       the data from column 26 onwards 5 columns to the left.\n       (eliminating the original columns).  MOVECOLD is a variant\n       of MOVECOLS, MOVEINS and MOVEINSD.\n\n       For example, given:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       the results of 'MOVECOLD  31 40  11' would be:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAddddddddddCCCCCCCCCCEEEEEEEEEE\n          AAAAAAAAAAddddddddddCCCCCCCCCCEEEEEEEEEE\n          AAAAAAAAAAddddddddddCCCCCCCCCCEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n\n:HEADER2 MOVECOLS   FROM-LEFT-COL  FROM-RIGHT-COL  TO-LEFT-COL ( .A .B )\n:HEADERT Move Columns Overlaying Other Columns\n\n       will take the specified columns and overlay them onto the\n       receiving column, blanking the originating data.  For\n       example,\n\n          MOVECOLS  21 25  68\n\n       will replicate what's in columns 21 thru 25 onto columns\n       68 thru 72 and then blank columns 21 thru 25. DELCOLS may\n       be used to eliminate the original columns.  MOVECOLS is\n       useful if consolidating columns as you can see progress as\n       source fields are blanked.\n\n       For example, given the following data:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       the result of 'MOVECOLS  31 40  11' would be:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAddddddddddCCCCCCCCCC          EEEEEEEEEE\n          AAAAAAAAAAddddddddddCCCCCCCCCC          EEEEEEEEEE\n          AAAAAAAAAAddddddddddCCCCCCCCCC          EEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n\n:HEADER2 MOVEINS   FROM-LEFT-COL  FROM-RIGHT-COL  TO-LEFT-COL  ( .A .B )\n:HEADERT Move Columns Inserting Before Other Columns\n\n       will take the specified columns and insert them into the\n       receiving column, shifting displaced data to the right,\n       and blanking the originating data.  For example,\n\n          MOVEINS  1 5  30  .S .E\n\n       will replicate what's in columns 1 thru 5 into columns 30\n       thru 34, shifting the data in columns 30 onward to the\n       right 5 columns, and then blank columns 1 thru 5, within\n       the .S thru .E range.  DELCOLS may be used to remove the\n       original blank columns or MOVEINSD may be used instead of\n       MOVECOLS to do the insert and then automatically delete\n       the originating columns.\n\n       Given the following:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       the result of 'MOVEINS  11 20  31' would be:\n\n          ----+----1----+----2----+----3----+----4----+----5----+----6\n          AAAAAAAAAA          CCCCCCCCCCbbbbbbbbbbddddddddddEEEEEEEEEE\n          AAAAAAAAAA          CCCCCCCCCCbbbbbbbbbbddddddddddEEEEEEEEEE\n          AAAAAAAAAA          CCCCCCCCCCbbbbbbbbbbddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5----+----6\n\n\n:HEADER2 MOVEINSD  FROM-LEFT-COL  FROM-RIGHT-COL  TO-LEFT-COL  ( .A .B )\n:HEADERT Move & Delete Columns Inserting Before Other Cols\n\n       will take the specified columns and insert them into the\n       receiving column, shifting displaced data to the right,\n       and deleting the originating data.  For example,\n\n          MOVEINSD  11 15  1  .BEG .END\n\n       will replicate what's in columns 11 thru 15 into column 1\n       thru 5, shifting the other data 5 columns to the right,\n       and deleting the original columns 11 thru 15, within the\n       .BEG thru .END range. This is a variation of MOVEINS which\n       essentially allows moving data around with records.\n\n       Note if the source is to the left of the receiving column,\n       the newly inserted data will take part in a shift to the\n       left when the source is removed.\n\n       With the following data:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       the result of 'MOVEINSD  41 50  1' is:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          EEEEEEEEEEAAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n          EEEEEEEEEEAAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n          EEEEEEEEEEAAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd\n          ----+----1----+----2----+----3----+----4----+----5\n\n\n:HEADER2 NUMCOLS  START-COL END-COL (START-NUM INCREMENT SKIP) (.A .B)\n:HEADERT Place Sequential Numbers in Columns\n\n       puts whole numbers in the specified columns, as in:\n\n          NUMCOLS  1 5   20 5\n\n       will put '   20' in the 1st line's columns 1 thru 5,\n       '   25' in the 2nd line's, '   30' etc.  The starting and\n       ending columns are mandatory.  The starting number,\n       increment and number of lines to skip will default to 1.\n       You must specify the starting number and increment if you\n       wish to specify the number of lines to skip after the\n       first line.\n\n\n:HEADER2 NUMCOLS0   START-COL  END-COL START-NUM INCREMENT SKIP (.A .B)\n:HEADERT Place Zero Padded Numbers in Columns\n\n       puts 0 padded numbers in the specified columns, as in:\n\n          NUMCOLS0  1 5  111  .aa .xx\n\n       will put '00111' in the 1st line's columns 1 thru 5,\n       '00112' in the 2nd line's, '00113' etc in the range of\n       .AA through .XX.\n\n       The starting and ending columns are mandatory.  The\n       starting number, increment and number of lines to skip\n       will default to 1. You must specify the starting number\n       and increment if you wish to specify the number of lines\n       to skip after the first line.\n\n       A sample of its use would be in generating JCL to\n       reference a Generation Data Group (GDG) backwards (i.e.\n       we can't use the base or we only want part of them).\n       Suppose there are 7 entries in a GDG base as follows:\n\n          SYS4.TAMAST.REVISION.TRIAL7.G0029V00\n          SYS4.TAMAST.REVISION.TRIAL7.G0030V00\n          SYS4.TAMAST.REVISION.TRIAL7.G0031V00\n          SYS4.TAMAST.REVISION.TRIAL7.G0032V00\n          SYS4.TAMAST.REVISION.TRIAL7.G0033V00\n          SYS4.TAMAST.REVISION.TRIAL7.G0034V00\n          SYS4.TAMAST.REVISION.TRIAL7.G0035V00\n\n      and we wanted JCL to reference the middle 5 backwards.  We\n      could build:\n\n         000001 //             DD       DISP=SHR,DCB=BUFNO=32,\n         .A 002 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0000V00\n         =COLS> ----+----1----+----2----+----3----+----4----+----5----+\n         000003 //             DD       DISP=SHR,DCB=BUFNO=32,\n         000004 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0000V00\n         000005 //             DD       DISP=SHR,DCB=BUFNO=32,\n         000006 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0000V00\n         000007 //             DD       DISP=SHR,DCB=BUFNO=32,\n         000008 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0000V00\n         =COLS> ----+----1----+----2----+----3----+----4----+----5----+\n         000009 //             DD       DISP=SHR,DCB=BUFNO=32,\n         .B0010 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0000V00\n\n      Please note where we set the label range - on the first\n      line to get a number and on the last. Also we just\n      specified the G00V00 number as zeros intending to overlay\n      them.  The results of 'NUMCOLS0  50 52  34  -1  2  .A .B'\n      would be:\n\n         000001 //             DD       DISP=SHR,DCB=BUFNO=32,\n         .A     //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0034V00\n         =COLS> ----+----1----+----2----+----3----+----4----+----5----+\n         000003 //             DD       DISP=SHR,DCB=BUFNO=32,\n         000004 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0033V00\n         000005 //             DD       DISP=SHR,DCB=BUFNO=32,\n         000006 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0032V00\n         000007 //             DD       DISP=SHR,DCB=BUFNO=32,\n         000008 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0031V00\n         =COLS> ----+----1----+----2----+----3----+----4----+----5----+\n         000009 //             DD       DISP=SHR,DCB=BUFNO=32,\n         .B     //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0030V00\n\n\n:HEADER2 PK FROM-COL1 FROM-COL2 (TO-COL1 TO-COL2) (-MINUS-COL) (.A .B)\n:HEADERT Pack Numeric Display Data\n\n       packs the numbers in the specified columns, as in:\n\n          PK   1 7  -8  31 34  .AA .XX\n\n       will pack the data in columns 1 through 7 into columns 31\n       through 34, placing the equivalent plus/minus from column\n       8 in the sign portion of column 34.  The from columns are\n       mandatory.  The to columns will default to the from\n       columns, while the minus sign will default to the sign of\n       the last from digit.\n\n       Note that CAPS will be turned off and a message will be\n+      _________________________________\n       displayed saying so.\n\n       A message showing the total valid numbers found, the\n       number of overflows and the number of lines processed\n       will appear in the upper right corner. Pressing PF1\n       will describe the numbers shown\n\n       PK may be used after FORMCOLS eliminates commas and aligns\n       the data. DELCOLS may be used to remove periods after\n       FORMCOLS is complete and before PK.\n\n       Given the following data:\n\n          00001\n          FFFFF44444444\n          0000100000000\n          ----+----1---\n          0000A\n          FFFFC44444444\n          0000100000000\n          ----+----1---\n          0000J\n          FFFFD44444444\n          0000100000000\n          ----+----1---\n          99999\n          FFFFF44444444\n          9999900000000\n          ----+----1---\n          9999R\n          FFFFD44444444\n          9999900000000\n\n       the results of 'PK  1 5  11 13' would be:\n\n          00001\n          FFFFF44444001\n          000010000000F\n          ----+----1---\n          0000A\n          FFFFC44444001\n          000010000000C\n          ----+----1---\n          0000J\n          FFFFD44444001\n          000010000000D\n          ----+----1---\n          99999     rr\u20ac\n          FFFFF44444999\n          999990000099F\n          ----+----1---\n          9999R     rr\u00b8\n          FFFFD44444999\n          999990000099D\n\n\n:HEADER2 RANCOLS   START-COL  END-COL  ( MIN-NUM  MAX-NUM )  ( .A .B )\n:HEADERT Generate Pseudo Random Numbers\n\n       puts pseudo random numbers into the specified columns,\n       right justified and left padded with blanks, as in:\n\n          RANCOLS  1  5  0  99\n\n       may put '   21' in the 1st line's columns 1 thru 5, '\n       95' in the 2nd line's, '   87' etc.  The defaults are\n       minimum number of 1 and maximum number of all 9's.  The\n       REXX RANDOM() function is used to generate the numbers.\n\n\n:HEADER2 RANCOLS0   START-COL  END-COL  ( MIN-NUM  MAX-NUM )  ( .A .B )\n:HEADERT Generate Zero Padded Pseudo Random Numbers\n\n       puts 0 padded pseudo random numbers into the specified\n       columns, right justified and left padded with zeros, as\n       in:\n\n          RANCOLS0  .AAA .BBB  1 5\n\n       may put '01584' in the 1st line's columns 1 thru 5,\n       '40089' in the 2nd line's, '24207' etc of the line\n       range .AAA through .BBB.  The defaults are minimum\n       number of 1 and maximum number of all 9's. The REXX\n       RANDOM() function is used to generate the numbers.\n\n       RANCOLS0 might be useful for generating random numeric\n       data for testing or for filling columns used to do a\n       repeatable random ordering.\n\n\n:HEADER2 SHIFT  LEFT|RIGHT  (#COLUMNS)  (X|NX)  (.A .B)  (MAX|LEAVE)\n:HEADERT Shift Data\n\n       shifts the data left or right the number of columns\n       specified, within the BOUNDS in force.  The direction of\n       the shift is required and may be entered as LEFT or L, or\n       RIGHT or R.\n\n       The number of columns defaults to 1. The label range is\n       optional. X or NX may be specified to have the shift\n       impact only excluded or unexcluded lines, respectively.\n       The default is all lines.\n\n       MAX says to only cut off non blank columns; LEAVE says to\n       not shift the line in question at all if any non blank\n       data would be lost on that line.  The default is to\n       truncate the data.\n\n          SHIFT  LEFT  12  NX  .K .L\n\n       will shift all the unexcluded lines in the line range .K\n       through .L 12 columns to the left, within the current\n       bounds.\n\n       For example, given the following:\n\n          =COLS> ----+----1----+----2\n          .K       Length\n          000003           Forth\n          .L         Daily\n          =COLS> ----+----1----+----2\n\n       the result of 'SHIFT  LEFT  12  NX  .K .L' would be:\n\n          =COLS> ----+----1----+----2\n          .K\n          000003 rth\n          .L\n          =COLS> ----+----1----+----2\n\n       Note the above data (in the .K thru .L range) is truncated.\n       And, given the same start data shown above, the result of\n       'SHIFT  L  12  NX  .K .L MAX' would be:\n\n          =COLS> ----+----1----+----2\n          .K     Length\n          000003 Forth\n          .L     Daily\n          =COLS> ----+----1----+----2\n\n       Note the above data (in the .K thru .L range) is not\n       truncated but shifted as far left as possible without\n       losing any data.  And, finally, given the same start data\n       shown above, the result of 'SHIFT  L  12  NX  .K .L LEAVE'\n       would be:\n\n          =COLS> ----+----1----+----2\n          .K       Length\n          000003           Forth\n          .L         Daily\n          =COLS> ----+----1----+----2\n\n       Note nothing changed since a shift of 12 bytes leftwards\n       would cause truncation in every instance.\n\n\n:HEADER2 SPLTCOLS  COL-1  ( ... )  ( .A  .B )\n:HEADERT Split Lines at Given Columns\n\n      this macro will split a line at the given column intervals\n      creating multiple lines from one.  For example\n\n         SPLTCOLS  21  41  61\n\n      will split one line into 4,  the 1st having columns 1\n      through 20, the 2nd 21 through 40, the 3rd 41 through 60,\n      and the 4th 61 through the end of the data.  Useful for\n      breaking up columns into more editable data and in\n      conjunction with JOINCOLS.\n\n      Assuming the following data:\n\n         AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n         ----+----1----+----2----+----3----+----4----+----5----+----6\n         AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n         ----+----1----+----2----+----3----+----4----+----5----+----6\n         AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n\n      the result of 'SPLTCOLS  11  21  32  41' would be:\n\n         AAAAAAAAAA\n         bbbbbbbbbb\n         CCCCCCCCCC\n         dddddddddd\n         EEEEEEEEEE\n         ----+----1----+----2----+----3----+----4----+----5----+----6\n         AAAAAAAAAA\n         bbbbbbbbbb\n         CCCCCCCCCC\n         dddddddddd\n         EEEEEEEEEE\n         ----+----1----+----2----+----3----+----4----+----5----+----6\n         AAAAAAAAAA\n         bbbbbbbbbb\n         CCCCCCCCCC\n         dddddddddd\n         EEEEEEEEEE\n\n      Also, if faced with the need to break up unstructured data,\n      for example:\n\n         In theory, the product configuration baseline adds overriding\n         performance constraints to the philosophy of commonality and\n         standardization.   Similarly, the product assurance\n         architecture adds explicit performance limits to the total\n         system rationale.\n\n      use TF2 on the prefix area for that line. It resulted in:\n\n         In\n         theory,\n         the\n         product\n         configuration\n         baseline\n         adds\n         overriding\n         performance\n         constraints\n         to\n         the\n         philosophy\n         of\n         commonality\n         and\n         standardization.\n         Similarly,\n         the\n         product\n            ... etc ...\n\n\n:HEADER2 SUMCOLS   1ST-COL 2ND-COL  ...  ( .A .B )\n:HEADERT Add Data Arithmetically Within Given Columns\n\n       will arithmetically add the numbers in the given columns.\n       At least one pair of columns must be specified.  They\n       don't have to be in the precise columns given.  For\n       example:\n\n          SUMCOLS  11 20\n\n       where 11 thru 20 might contain:\n\n          11       20\n          +--------+\n             1K\n              123\n           200.25\n             -1\n           2,345 +\n          +--------+\n          11       20\n\n       will produce\n\n          12:34:56 SUM of COLS  11-20, total is 2655.25\n          12:34:56 --------------- Total of SUMS is  2655.25\n\n       Note the lines with 1K and 2,345 (which are not pure\n       numerics) are counted.  The 1K value is accepted as -12.\n       Prefix or postfix signs are accepted.  Up to 9 pairs of\n       columns may be specified.\n\n       If no label range is specified, the macro will look for\n       C/CC/C# prefix commands. If none are found, the entire\n       file will be processed. Only unexcluded lines will be\n       processed (for historical reasons).\n\n\n:HEADER2 UNPK FROM-COL1 FROM-COL2 (TO-COL1 TO-COL2) (-MINUS-COL) (.A .B)\n:HEADERT Unpack Data into Numeric Display Form\n\n       unpacks the numbers in the specified columns, as in:\n\n          UNPK  11 19  31 47  -30  .A .B\n\n       will unpack the data in columns 11 through 19 into columns\n       31 through 47, placing the appropriate plus/minus sign\n       into column 30 in the line range .A through .B.  The from\n       columns are mandatory.  The to columns will default to the\n       from columns, while the minus sign location will default\n       to the the last TO digit (zoned, that is, -1 equal to J,\n       1 equal to A, -2 to K, 2 equal to B, etc).\n\n       A message showing the total valid numbers found, the\n       number of overflows and the number of lines processed\n       will appear in the upper right corner. Pressing PF1\n       will describe the values shown.\n\n       FORMCOLS may be used to neatly format the resultant data\n       and FILLINS to insert periods.\n\n       Given the following data as the starting point:\n\n                         \u00ee\"\n          4444444444000135744444444444444444444444\n          0000000000000246F00000000000000000000000\n          ----+----1----+----2----+----3----+----4\n                          @\n          4444444444000000744444444444444444444444\n          0000000000000004C00000000000000000000000\n          ----+----1----+----2----+----3----+----4\n\n          4444444444000111144444444444444444444444\n          0000000000000111D00000000000000000000000\n\n       the result of 'UNPK  11 17  21 30  -31', immediately\n       followed by 'UNPK  11 17  1 10' would be:\n\n          0001234567     \u00ee\"   0001234567+\n          FFFFFFFFFF0001357444FFFFFFFFFF4444444444\n          0001234567000246F0000001234567E000000000\n          ----+----1----+----2----+----3----+----4\n          0000000047      @   0000000047+\n          FFFFFFFFFF0000007444FFFFFFFFFF4444444444\n          0000000047000004C0000000000047E000000000\n          ----+----1----+----2----+----3----+----4\n          000111111J          0001111111-\n          FFFFFFFFFD0001111444FFFFFFFFFF6444444444\n          0001111111000111D00000011111110000000000\n\n\n:HEADER1 Display Control Macros\n\n The following macros will expand both FIND and EXCLUDE/INCLUDE\n capabilities.  None will change the order or the content of the\n+               ________________________________________________\n file.  Standard ISPF commands such as DEL ALL X or FLIP may be\n+____\n used subsequently to delete or see the opposite lines\n respectively.\n\n FALT is a pseudo repeat capability for many of the below macros.\n Please see the macro below for full details.\n\n Built in help is available by either typing the macro name\n without any parameters (if any parameter is mandatory) or with\n just a question mark (?) as the only operand as shown below.\n\n\n:HEADER2 COUNTXNX  ( ? )  ( .A .B )\n:HEADERT Display Number of Unexcluded / Excluded Lines\n\n       shows in the upper right hand corner of the screen the\n       number of lines unexcluded and excluded. The lines to be\n       processed may be selected via labels or C/CC/C# line\n       commands - the entire file is processed if no range is\n       specified. A single question mark causes the built in help\n       to be displayed. Pressing function key <F1> will show a\n       slightly more verbose explanation.\n\n       A sample of the display shown is:\n\n          ...           44 NX / 171 X LINES\n          ...              Scroll ===> CSR\n          ...         **********************\n\n       A sample of the more readable message shown after <F1>\n       is pressed for the preceding would be:\n\n          THERE ARE 44 DISPLAYED LINES & 171 EXCLUDED LINES\n\n\n:HEADER2 FALT  ( ? )\n:HEADERT Pseudo Repeat Function for Certain Find's\n\n       is a dummy macro.  As assigned to a PF Key, it will repeat\n       the last FEXC, FGE, FGT, FLE, FLT, FMAX, FMIN, FN or FPEND\n       command.  Those macros store parameter information in the\n       shared pool. FALT passes a dummy parameter of -=PFK=- to\n       the last command executed and the command will pull the\n       necessary parameters from the shared pool. It always\n       repeats the last of the above find commands.\n\n       It will repeat the command starting from the line on which\n       the cursor is positioned.\n\n\n:HEADER2 FAND   STRING1  STRING2  ...  ( .A .B )\n:HEADERT Display Lines With All Specified Values\n\n       excludes all data within the line range or the file and\n       unexcludes every line that contains every specified string.\n       Up to 10 strings may be specified. For example:\n\n          FAND  UNIT  SPACE=  ' DD '\n\n       will show unexcluded only those lines which contain all\n       the strings UNIT, SPACE= and ' DD '. The upper right\n       hand side of the screen will show how many were found.\n\n\n:HEADER2 FEXC  ( ? )\n:HEADERT Find Next Excluded Line\n\n       finds the next excluded line from the top line on the\n       screen, and will make that excluded line the second from\n       the top line.  FALT may be used to repeat the command.  A\n       question mark (?) as parameter will cause the built in\n       help to display.\n\n\n:HEADER2 FGE    STRING   ( COL-1 ( COL-2 ) )   ( .A .B )\n:HEADERT Find Value Greater Than or Equal\n\n       will find the next line following the top line on the\n       displayed page that has a value greater then or equal to\n       the specified string. For instance,\n\n          FGE  '231400'  16\n\n       will make the line with a value greater then or equal to\n       231400 in columns 16 through 21 the second line on the\n       screen. If the value is not found, a not found message\n       appeard in the upper right corner. To do a repeat, make\n       the \"found\" line the top line on the screen and retrieve\n       and re-execute the command or, if you set a PFKey to\n       \"FALT\", that key may be used as a repeat FGE. Obviously,\n       F17 might be a good choice since most PC's use Shift-F5\n       for that key and F5 is normally the repeat find key.\n\n       A FOUND or NOT FOUND message will be placed in the upper\n       right corner of the screen, as appropriate.\n\n\n:HEADER2 FGT    STRING   ( COL-1 ( COL-2 ) )   ( .A .B )\n:HEADERT Find Value Greater Than\n\n       will find the next line following the top line on the\n       displayed page that has a value greater then the specified\n       string. For instance,\n\n          FGT  'Johnson'  21\n\n       will make the line with a value greater then 'Johnson' in\n       columns 21 through 27 the second line on the screen. If\n       the value is not found, a not found message appeard in the\n       upper right corner. To do a repeat, make the \"found\" line\n       the top line on the screen and retrieve and re-execute the\n       command or, if you set a PFKey to \"FALT\", that key may be\n       used as a repeat FGT. Obviously, F17 might be a good\n       choice since most PC's use Shift-F5 for that key and F5 is\n       normally the repeat find key.\n\n       A FOUND or NOT FOUND message will be placed in the upper\n       right corner of the screen, as appropriate.\n\n\n:HEADER2 FINDDUPX   COL1 COL2  ...  ( .A .B )\n:HEADERT Display Contiguous Duplicate Lines\n\n       will show only those lines with duplicate values in the\n       specified columns where the lines follow each other.  No\n+                                                            __\n       sorting is done.  One pair of columns is mandatory; the\n+      _______________\n       label range is optional.  A sample is:\n\n          FINDDUPX  1 8  11 12  .A .B\n\n       will show only adjoining lines with the same values in\n       columns 1 through 8  and 11 through 12 in line range .A\n       through .B. Up to 10 sets of columns may be specified.\n       See FINDDUPS for the version that will sort the data first\n       by the specified columns.\n\n       Given the following data:\n\n          AAA\n          AAA\n          BBB\n          CCC\n          DDD\n          DDD\n          DDD\n          EEE\n\n       the result of 'FINDDUPX  1 3' would be:\n\n          AAA\n          AAA\n          -  - ... -  2 Line(s) not Displayed\n          DDD\n          DDD\n          DDD\n          -  - ... -  1 Line(s) not Displayed\n\n       Note doing a FLIP shows the records that have no dups,\n       and no data or ordering is changed.\n\n\n:HEADER2 FLE    STRING   ( COL-1 ( COL-2 ) )   ( .A .B )\n:HEADERT Find Value Less Than or Equal\n\n       will find the next line following the top line on the\n       displayed page that has a value less then or equal to the\n       specified string. For instance,\n\n          FLE  '30,000'  31\n\n       will make the line with a value less then or equal to\n       '30,000' in column columns 31 through 36 the second line\n       on the screen. If the value is not found, a not found\n       message appeard in the upper right corner. To do a repeat,\n       make the \"found\" line the top line on the screen and\n       retrieve and re-execute the command or, if you set a PFKey\n       to \"FALT\", that key may be used as a repeat FLE.\n       Obviously, F17 might be a good choice since most PC's use\n       Shift-F5 for that key and F5 is normally the repeat find\n       key.\n\n       A FOUND or NOT FOUND message will be placed in the upper\n       right corner of the screen, as appropriate.\n\n\n:HEADER2 FLT    STRING   ( COL-1 ( COL-2 ) )   ( .A .B )\n:HEADERT Find Value Less Than\n\n       will find the next line following the top line on the\n       displayed page that has a value less then the specified\n       string. For instance,\n\n          FLT  '  '  1\n\n       will make the line with a value less then '  ' (two\n       blanks) in columns 1 and 2 the second line on the screen.\n       If the value is not found, a not found message appeard in\n       the upper right corner. To do a repeat, make the \"found\"\n       line the top line on the screen and retrieve and\n       re-execute the command or, if you set a PFKey to \"FALT\",\n       that key may be used as a repeat FLT. Obviously, F17 might\n       be a good choice since most PC's use Shift-F5 for that key\n       and F5 is normally the repeat find key.\n\n       A FOUND or NOT FOUND message will be placed in the upper\n       right corner of the screen, as appropriate.\n\n\n:HEADER2 FMAX  LEFT-COL RIGHT-COL  ( TYPE )  ( .A .B )\n:HEADERT Find the Largest Value\n\n       will find the first line in the range with the highest\n       value.  Columns are mandatory but data type and label\n       range are optional.\n\n       The data type (TYPE) defaults to 'C' for character, which\n       includes both any character string or signed character\n       strings (e.g. +277, 012 or -935). Other types are 'Z' for\n       zoned data (e.g. 27G, 012 or 93N), 'P' for packed (COMP-3)\n       (recognizing hex D for negative and assuming everything\n       else is positive), and 'B' for binary (using the first bit\n       for the sign and the rest for 2's complement number if\n       negative).\n\n       FALT may be invoked to repeat the find if there are\n       multiple high values. The count of the largest value\n       found and the number of values scanned is shown in the\n       upper right corner as #found/#scanned. A not found message\n       will be shown there when all of the largest values are\n       exhausted.\n\n          FMAX  P  11 15\n\n       will find the largest packed value in columns 11 through\n       15.\n\n\n:HEADER2 FMIN  LEFT-COL RIGHT-COL  ( TYPE )  ( .A .B )\n:HEADERT Find the Smallest Value\n\n       will find the first line in the range with the lowest\n       value.  Columns are mandatory but data type and label\n       range are optional.\n\n       The data type (TYPE) defaults to 'C' for character, which\n       includes both any character string or signed character\n       strings (e.g. +277, 012 or -935). Other types are 'Z' for\n       zoned data (e.g. 27G, 012 or 93N), 'P' for packed (COMP-3)\n       (recognizing hex D for negative and assuming everything\n       else is positive), and 'B' for binary (using the first bit\n       for the sign and the rest for 2's complement number if\n       negative).\n\n       FALT may be invoked to repeat the find if there are\n       multiple low values. The count of the smallest value\n       found and the number of values scanned is shown in the\n       upper right corner as #found/#scanned. A not found message\n       will be shown there when all of the smallest values are\n       exhausted.\n\n          FMIN  .X .Y  1 23\n\n       will find the smallest value in columns 1 through 23\n       within the line range .X through .Y.\n\n\n:HEADER2 FN    STRING   ( COL-1 ( COL-2 ) )   ( .A .B )\n:HEADERT Find a Value Not Equal\n\n       will find the next line that does not contain the\n       specified string anywhere in the specified columns.  For\n       example:\n\n          FN  ' DD '  2 20  .XX .YY\n\n       will find the next line that does not contain ' DD '\n       between columns 2 through 20. Another example, probably\n       more realistic, is:\n\n          FN  '747'  16\n\n       which will find the next line that does not contain 747 in\n       column2 16 through 18.\n\n       If you set a PFKey to \"FALT\", that key may be used\n       as a repeat FN. Obviously, F17 might be a good choice\n       since most PC's use Shift-F5 for that key and F5 is\n       normally the repeat find key.\n\n       When at the end of the file, FN will \"wrap\" to the top of\n       the file. If no line is found to satisy the 'not equal'\n       condition, a 'NOT FOUND' appears in the upper right hand\n       corner of the screen.\n\n\n:HEADER2 FNB  ( STARTING-COLUMN  ( ENDING-COLUMN ) )  ( ? )\n:HEADERT Find Non Blank Values\n\n      finds the non blank character, if any, from column 73\n      through the last logical byte of data, by default. If the\n      STARTING-COLUMN is specified, it will use that value as the\n      beginning column through the last logical byte or through\n      the ENDING-COLUMN if specified. The standard repeat\n      function key (usually PF Key 5) may be used to continue the\n      function.\n\n      For example,\n\n         FNB  47\n\n      will find the first non blank character from column 47\n      through the logical record length (LRECL) if any.\n\n\n:HEADER2 FNOT   STRING1  ...  ( .A .B )\n:HEADERT Display Lines With None of Specified Values\n\n       excludes all data within the line range or the file and\n       unexcludes every line that does not contain any of the\n       specified strings.  Up to 10 strings may be specified. For\n       example:\n\n          FNOT  PROC  ' DD '  PEND\n\n       will show unexcluded only those lines which contain\n       neither PROC, ' DD ', nor PEND. This relates to both the\n       FAND and FOR macros.\n\n\n:HEADER2 FOR    STRING1  ...  ( .A .B )\n:HEADERT Display Lines With Any of Specified Values\n\n       excludes all data within the line range or the file and\n       unexcludes every line that contains any of the specified\n       strings.  Up to 10 strings may be specified. For example:\n\n          FOR  2314  3350  CART  TAPE\n\n       will show unexcluded only those lines which contain either\n       '2314', '3350', CART or TAPE.\n\n\n:HEADER2 FPEND  ( Next | First | Previous | ? )\n:HEADERT Find Line With Pending Prefix Command\n\n       will find a pending line command in the file, i.e.  the\n       line that has an unexecuted prefix command such as CC or\n       M9999. The direction may be abbreviated as only the first\n       character, e.g. F. The default is to find the next pending\n       line command.  Specifying a question mark (?) as the\n       parameter will cause the built in help to be displayed.\n\n       If you set a PFKey to \"FALT\", that key may be used as a\n       repeat FPEND. Obviously, F17 might be a good choice since\n       most PC's use Shift-F5 for that key and F5 is normally the\n       repeat find key. If the last direction was First, then the\n       Next pending command is found.\n\n\n:HEADER2 FX     STRING1\n:HEADERT Exclude Everything and Show Only those Lines Found\n\n       excludes all lines and shows only lines with the string\n       and a few lines above and below those found.  This uses\n       the COMPARE EXCLUDE command to perform the line exclude\n       function (type COMPARE in Edit).\n\n       For example, given the following data:\n\n          DDD\n          BBB\n          AAA\n          EEE\n          CCC\n          FFF\n          DDD\n          DDD\n          ZZZ\n          AAA\n          CCC\n\n       the result of 'FX  CCC' would be:\n\n          -  -  ...  -  3 Line(s) not Displayed\n          EEE\n          CCC\n          FFF\n          -  -  ...  -  3 Line(s) not Displayed\n          AAA\n          CCC\n\n       where the Display Options with Exclude (Compare command)\n       is set to 1.\n\n\n:HEADER2 LESS    ( BEFORE(#) )   ( AFTER(#) )   ( .A .B )  ( ? )\n:HEADERT Exclude Additional Lines Around Excluded Lines\n\n       excludes the number of lines specified by BEFORE(#) in\n       front of any currently excluded lines and the number of\n       lines specified by AFTER(#) following any currently\n       excluded lines in the selected range.  A range to be\n       processed may be specified via a label range as parameters\n       or a C/CC/C# range by data prefix.  The entire file will\n       be processed if no explicit range is selected.  The\n       defaults are BEFORE(1) and AFTER(1).  Given:\n\n          LESS\n\n       will cause one line before of each group of excluded lines\n       to be excluded and one line following each group to be\n       excluded.  This is equivalent to typing a prefix command\n       of 'X' on the unexcluded lines immediately before and\n       after each excluded group of lines.  Another example is:\n\n          LESS  BEFORE(0)  AFTER(2)  .KK .LL\n\n       which will exclude no lines before any group of excluded\n       lines and 2 lines following of each group in the line\n       range .KK through .LL.\n\n       A parameter of ? causes the built in help to be displayed.\n\n       Given data (from the FX example above):\n\n          -  -  ...  -  3 Line(s) not Displayed\n          EEE\n          CCC\n          FFF\n          -  -  ...  -  3 Line(s) not Displayed\n          AAA\n          CCC\n\n       The result of 'LESS' would be:\n\n          -  -  -  4 Line(s) not Displayed\n          CCC\n          -  -  -  5 Line(s) not Displayed\n          CCC\n\n\n:HEADER2 LONGEST   ( .A .B )  ( ? )\n:HEADERT Find the Longest Line\n\n       makes the first line with the longest length the top line\n       on the display.  The actual length is shown in the upper\n       right message area as well as the number of such length\n       records in the range.\n\n       For fixed record format data, the longest record has the\n       smallest number of blanks on the right side of the line.\n\n       Either labels or C/CC/C# may be used to limit the length\n       check.  A ? as the only parameter will cause the built in\n       help to be displayed.\n\n\n:HEADER2 MORE    ( BEFORE(#) )   ( AFTER(#) )   ( .A .B )  ( ? )\n:HEADERT Unexclude Additional Lines Around Excluded Lines\n\n       unexcludes the number of lines specified by BEFORE(#) at\n       the beginning of any currently excluded lines and the\n       number of lines specified by AFTER(#) at the end of any\n       currently excluded lines within the range selected.  The\n       range may be specified via a label range as parameters or\n       a C/CC/C# data prefix selection. The entire file will be\n       processed if no range is specifically selected.  The\n       defaults are BEFORE(1) and AFTER(1).  For example,\n\n          MORE\n\n       will cause one line at the beginning of each group of\n       excluded lines to be unexcluded and one line following\n       each group will be unexcluded.  Another example is:\n\n          MORE  BEFORE(2)  AFTER(2)\n\n       which will unexclude two lines at the beginning of any\n       group of excluded lines and 2 lines at the end of each\n       group.\n\n       A parameter of ? causes the built in help to be displayed.\n       Given data (from the FX example above):\n\n          -  -  ...  -  3 Line(s) not Displayed\n          EEE\n          CCC\n          FFF\n          -  -  ...  -  3 Line(s) not Displayed\n          AAA\n          CCC\n\n       The result of 'MORE' would be:\n\n          DDD\n          -  -  -  -  1 Line(s) not Displayed\n          AAA\n          EEE\n          CCC\n          FFF\n          DDD\n          -  -  -  -  1 Line(s) not Displayed\n          ZZZ\n          AAA\n          CCC\n\n\n:HEADER2 REALUNIX  COL1 COL2  ...  ( .A .B )\n:HEADERT Show Contiguous Lines With No Duplicate Values\n\n       will exclude the specified range of lines or the entire\n       file and unexclude the records with no other contiguous\n       records with the same values in the specified columns.  No\n       sorting is performed before checking for unique values.\n       For example:\n\n          REALUNIX  1  8\n\n       will scan the file by columns 1 thru 8 and show only the\n       really unique records.  Up to 10 pairs of columns are\n       supported.  Please see REALUNIQ for a version that sorts\n       prior to processing.  For example, given data as follows:\n\n          111\n          222\n          222\n          333\n          444\n          444\n          444\n          555\n          555\n          555\n\n       doing a REALUNIQ 1 3 will result in:\n\n          111\n          -  -  -  -  -  -  -  -  -  -  -  2 Line(s) not Displayed\n          333\n          -  -  -  -  -  -  -  -  -  -  -  6 Line(s) not Displayed\n\n       Please note the data is assumed to be in proper order, And\n       see REALUNIQ for the equivalent function that performs a\n       sort before processing the data.  Using the standard FLIP\n       command will produce those lines that are duplicated, i.e.\n       on the above\n\n          -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed\n          222\n          222\n          -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed\n          444\n          444\n          444\n          555\n          555\n          555\n\n\n:HEADER2 SHORTEST   ( .A .B )  ( ? )\n:HEADERT Find the Shortest Line\n\n       makes the first line with the smallest length the top line\n       on the display.  The actual length is shown in the upper\n       right message area as well as the number of records of\n       such size in the range.\n\n       For fixed record format data, the shortest record has the\n       largest number of blanks on the right side of the line.\n\n       Either labels or C/CC/C# may be used to limit the length\n       check; will process the entire file if neither is\n       specified.  Obviously most useful for variable length\n       files. A ? will cause the built in help to be displayed.\n\n\n:HEADER2 SNACK   ( ? )\n:HEADERT Display Only Lines Containing the Field the Cursor is On\n\n       does an X ALL and then a FIND ALL against the field the\n       cursor was on.  The field must be delimited by blanks or\n       at the start or end of a line with a blank toward the\n       inside of the data.  Ideally, this macro would be assigned\n       to a PF Key.\n\n       For  the following:\n\n           FD  O\n               RECORDING MODE IS F\n               BLOCK CONTAINS 0 RECORDS.\n           01  OUTPUT-REC   PIC X(00080).\n\n           WORKING-STORAGE SECTION.\n          *------------------------*\n\n           01  WS-INPUT-REC                 PIC X(00080).\n           01  WS-SAVE-REC                  PIC X(00080).\n\n       if the cursor were positioned on OUTPUT-REC, the resulting\n       screen might look like:\n\n          -  -  -  -  -  -  -  -  -  -  -  - 60 Line(s) not Displayed\n           01  OUTPUT-REC   PIC X(00080).\n          -  -  -  -  -  -  -  -  -  -  -  - 72 Line(s) not Displayed\n                   WRITE OUTPUT-REC FROM WS-INPUT-REC\n          -  -  -  -  -  -  -  -  -  -  -  - 11 Line(s) not Displayed\n                   WRITE OUTPUT-REC FROM WS-INPUT-REC\n          -  -  -  -  -  -  -  -  -  -  -  - 60 Line(s) not Displayed\n\n       If the macro is specified on the command line with only a\n       question mark (?) as its parameter, built in help is\n       displayed.\n\n\n:HEADER2 UNIQUEX   COL1 COL2  ...  ( .A .B )\n:HEADERT Show Contiguous Uniquely Valued Lines\n\n       will exclude the specified range of lines or the entire\n       file and unexclude the first (or only) record with unique\n       values in the specified columns of contiguous records.  No\n       sorting is performed before checking for unique values.\n       For example:\n\n          UNIQUEX  1  8\n\n       will scan the file by columns 1 thru 8 and show only the\n       first occurrence of each value in those columns. Up to 10\n       pairs of columns are supported. Data should be in proper\n       order by the columns specified. Please also see UNIQUE\n       which sorts the data first.\n\n       For example, given the following data:\n\n          DDDDDD\n          BBBBBB\n          AAAAAA\n          EEEEEE\n          CCCCCC\n          DDDDDD\n          DDDDDD\n          DDDDDD\n          DDDDDD\n          AAAAAA\n          CCCCCC\n\n       invoking 'UNIQUE  1 10' will result in:\n\n          DDDDDD\n          BBBBBB\n          AAAAAA\n          EEEEEE\n          CCCCCC\n          DDDDDD\n          -  -  -  -      3 Line(s) not Displayed\n          AAAAAA\n          CCCCCC\n\n\n:HEADER1 Line Manipulation Macros\n\n The following macros will change the file being Viewed or\n Edited, removing blank lines, eliminating duplicate lines,\n showing only duplicate records, showing only unique records, and\n pulling all excluded lines to the top of the file.\n\n Data will be changed, as opposed to display format commands.\n+____________________\n\n Built in help is available by either typing the macro name\n without any parameters (for those with mandatory parameters) or\n with just a question mark (?) as the only operand.\n\n\n:HEADER2 CONBLANK   ( ? )  ( .A .B )\n:HEADERT Consolidate Blank Lines\n\n       will consolidate 2 or more blank lines to 1 within the\n       file or within the label range specified.  For example,\n\n          CONBLANK\n\n       will every occurrence of two or more blank lines in the\n       file to be consolidated to one.  If ? is specified as the\n       first or only parameter, then the inline help is displayed\n       without doing any deletions.\n\n\n:HEADER2 DELBLANK   ( ? )  ( .A .B )\n:HEADERT Delete Blank Lines\n\n       will delete all blank lines from the file or from the\n       label range specified.  For example,\n\n          DELBLANK\n\n       will cause every blank line in the file to be deleted.  If\n       ? is specified as the first or only parameter, then the\n       inline help is displayed without doing any deletions.\n\n\n:HEADER2 DELDUPS   COL1 COL2  ...  ( .A .B )\n:HEADERT Sort and Delete All Duplicate Lines\n\n       will sort the selected data, if range labels are\n       specified, or the entire file by the specified columns and\n       delete all lines with duplicate values in the specified\n       columns after the first occurrence.  For example,\n\n          DELDUPS  21 27  1 3\n\n       will sort the file by columns 21 thru 27 and 1 thru 3 and\n       delete any duplicate occurrences, i.e.  where the complete\n       set of keys is the same.  Up to 10 pairs of columns are\n       supported.\n\n       Given the following data:\n\n          DDDDDD    4444\n          ----+----1----+----2\n          DDDDDD    4444\n          EEEEEE    5555\n          CCCCCC    3333\n          BBBBBB    2222\n          DDDDDD    4444\n          AAAAAA    1111\n          DDDDDD    4444\n          AAAAAA    1111\n          DDDDDD    4444\n          ----+----1----+----2\n          CCCCCC    3333\n\n       the result of 'DELDUPS  11 14  1 6' would be:\n\n          AAAAAA    1111\n          ----+----1----+----2\n          BBBBBB    2222\n          CCCCCC    3333\n          DDDDDD    4444\n          ----+----1----+----2\n          EEEEEE    5555\n\n       Please note the data is now in order by the columns\n       specified and there are no duplicate entries left.\n\n\n:HEADER2 DELDUPX    COL1 COL2  ...  ( .A .B )\n:HEADERT Delete Contiguous Duplicate Lines\n\n       will scan, without sorting, the entire file using the\n       specified columns and delete all lines with duplicate\n       values in the specified columns after the first\n       occurrence.  For example,\n\n          DELDUPX  11 17  1 3\n\n       will scan the file by columns 11 thru 17 and 1 thru 3 and\n       delete any duplicate occurrences.  Up to 10 pairs of\n       columns are supported.\n\n       If the following data is the starting point:\n\n          =COLS> ----+----1\n          .AA    BBBBBB\n          000004 CCCCCC\n          000005 CCCCCC\n          000006 DDDDDD\n          000007 DDDDDD\n          000008 DDDDDD\n          .BB    DDDDDD\n          =COLS> ----+----1\n\n       the result of 'DELDUPX  1 6  .AA .BB' would be:\n\n          =COLS> ----+----1\n          .AA    BBBBBB\n          000004 CCCCCC\n          000005 DDDDDD\n          =COLS> ----+----1\n\n\n:HEADER2 FINDDUPS   COL1 COL2  ...  ( .A .B )\n:HEADERT Display All Duplicate Lines\n\n       will sort the entire file, or the range selected lines, by\n       the specified columns and exclude any lines that are not\n       duplicates. The shown data lines will only be dups. For\n       example:\n\n          FINDDUPS  11 17  1 3\n\n       will sort the file by columns 11 thru 17 and 1 thru\n       3 and show only the lines with dup values in those\n       columns. Up to 10 pairs of columns are supported.\n       The label range is optional.\n\n       Given the following data:\n\n          DDDDDD\n          BBBBBB\n          AAAAAA\n          EEEEEE\n          CCCCCC\n          DDDDDD\n          DDDDDD\n          DDDDDD\n          DDDDDD\n          AAAAAA\n          CCCCCC\n\n       a 'FINDDUPS  1 10' will have as its result:\n\n          AAAAAA\n          AAAAAA\n          -  -  -  - ... -  1 Line(s) not Displayed\n          CCCCCC\n          CCCCCC\n          DDDDDD\n          DDDDDD\n          DDDDDD\n          DDDDDD\n          DDDDDD\n          -  -  -  - ... -  1 Line(s) not Displayed\n\n       Please note the data is sorted, the \"unique\" BBBBBB and\n       EEEEEE lines are excluded while all the duplicate data is\n       shown.  FLIP would obviously return the unique values as\n       shown and the duplicates as excluded.\n\n\n:HEADER2 GATHERX  ( ? )\n:HEADERT Collect All Excluded Lines\n\n       will cause all excluded lines to be brought to the top of\n       the file or to the top of the lines marked by C/CC/C#.  If\n       there are none, nothing is changed.  The excluded and\n       unexcluded lines are kept in the same order respectively.\n\n       So if the initial file contained:\n\n          AAA\n          -  -  -  -  -  -  -  -  -  -  -  -  2 Line(s) not Displayed\n          BBB\n          -  -  -  -  -  -  -  -  -  -  -  -  3 Line(s) not Displayed\n          CCC\n          -  -  -  -  -  -  -  -  -  -  -  -  4 Line(s) not Displayed\n\n       The file, after GATHERX is executed, would look like:\n\n          -  -  -  -  -  -  -  -  -  -  -  -  9 Line(s) not Displayed\n          AAA\n          BBB\n          CCC\n\n       The nine excluded lines would be in the same order as\n       originally seen, just all moved to the top of the file.\n\n       If a question mark (?) is specified as the parameter, the\n       inline help is displayed without moving any lines.\n\n\n:HEADER2 REALUNIQ  COL1 COL2  ...  ( .A .B )\n:HEADERT Sort and Show Lines With No Duplicate Values\n\n       will sort and exclude the specified range of lines or the\n       entire file and unexclude the records which no other\n       records with the same values in the specified columns.\n       For example:\n\n          REALUNIQ  1  8\n\n       will sort the file by columns 1 thru 8 and show only the\n       really unique records.  Up to 10 pairs of columns are\n       supported.  Please see REALUNIX for a version that does\n       not sort prior prior to processing.  For example, given\n       data as follows (note these are NOT in sorted order):\n\n          444\n          555\n          555\n          333\n          111\n          555\n          444\n          222\n          222\n          444\n\n       doing a REALUNIQ 1 3 will result in:\n\n          111\n          -  -  -  -  -  -  -  -  -  -  -  2 Line(s) not Displayed\n          333\n          -  -  -  -  -  -  -  -  -  -  -  6 Line(s) not Displayed\n\n       Using the standard FLIP command will produce those lines\n       that are duplicated, i.e. on the above\n\n          -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed\n          222\n          222\n          -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed\n          444\n          444\n          444\n          555\n          555\n          555\n\n\n:HEADER2 REVERSEX  ( ? )\n:HEADERT Reverse Lines\n\n       will cause the marked (via C/CC/C##) range of lines to be\n       reversed.  If no range is specified, the entire file is\n       reversed.  This is essentially a \"flip\" command for the\n       lines involved. A question mark (?) as parameter will\n       cause the built in help to be displayed.\n\n       For example, using REVERSEX on\n\n           AAAAAA\n           BBBBBB\n           CCCCCC\n           DDDDDD\n           EEEEEE\n\n       would result in:\n\n           EEEEEE\n           DDDDDD\n           CCCCCC\n           BBBBBB\n           AAAAAA\n\n\n:HEADER2 SHUFFLE  ( ? )\n:HEADERT Provide Random Line Re-arrangement\n\n      pseudo randomly rearranges the sequence of an entire file\n      or of some subset specified by C, CC or C## prefix\n      commands. The only possible parameter is a question mark\n      which will cause the built in help to be displayed.\n\n      Uses the REXX random number generator to determine a new\n      position for each line selected. This is useful for\n      testing when the order of input might be of consequence.\n\n      If a question mark (?) is specified as the parameter, the\n      inline help is displayed without moving any lines.  Please\n      see RANCOLS0 which would allow repeatable sorting for\n      consistent testing.\n\n       For example, using SHUFFLE on\n\n           AAAAAA\n           BBBBBB\n           CCCCCC\n           DDDDDD\n           EEEEEE\n\n       could result in:\n\n           BBBBBB\n           CCCCCC\n           AAAAAA\n           DDDDDD\n           EEEEEE\n\n\n:HEADER2 SORTNX   COL1 COL2  ...  ( .A .B )\n:HEADERT Sort Unexcluded Lines Keeping With Excluded Lines\n\n       will sort the selected data by the specified columns of\n       the non excluded records keeping the excluded records\n       following each sorted record with that record. That is:\n\n          SORTNX  1 12\n\n       will sort the following records\n\n          rec#5555\n          --- some excluded lines associated with rec#5555 ---\n          rec#9999\n          --- some excluded lines associated with rec#9999 ---\n          rec#4444\n          rec#0000\n          --- some excluded lines associated with rec#0000 ---\n\n       producing\n\n          rec#0000\n          --- some excluded lines associated with rec#0000 ---\n          rec#4444\n          rec#5555\n          --- some excluded lines associated with rec#5555 ---\n          rec#9999\n          --- some excluded lines associated with rec#9999 ---\n\n       So the excluded records \"stick to\" their immediately\n       preceding non excluded records.  Up to 10 pairs of columns\n       are supported. The label range is optional.\n\n\n:HEADER2 UNIQUE   COL1 COL2  ...  ( .A .B )\n:HEADERT Show All Uniquely Valued Lines\n\n       will sort the selected data by the specified columns,\n       exclude the range selected or the entire file, and\n       unexclude the first (or only) record with unique values in\n       the specified columns.  The first pair of columns are\n       mandatory.\n\n       For example:\n\n          UNIQUE  1  8\n\n       will sort the file by columns 1 thru 8 and show only the\n       first occurrence of each value in those columns. Up to 10\n       pairs of columns are supported. Please see UNIQUEX if no\n       sort is needed.\n\n       For example, given the following data:\n\n          DDDDDD\n          BBBBBB\n          AAAAAA\n          EEEEEE\n          CCCCCC\n          DDDDDD\n          DDDDDD\n          DDDDDD\n          DDDDDD\n          AAAAAA\n          CCCCCC\n\n       invoking 'UNIQUE  1 10' would result in:\n\n          AAAAAA\n          -  -  -  - ... -  1 Line(s) not Displayed\n          BBBBBB\n          CCCCCC\n          -  -  -  - ... -  1 Line(s) not Displayed\n          DDDDDD\n          -  -  -  - ... -  4 Line(s) not Displayed\n          EEEEEE\n\n\n:HEADER1 Code/Data Manipulation Macros\n\n The following macros are primarily intended for use in coding.\n Some, such as ALIGN or SPLITAFT, may be useful elsewhere.\n\n\n:HEADER2 ALIGN  ( CHARS | ? )\n:HEADERT Align Text at Character(s) Specified\n\n       aligns the text at the right most character(s) specified.\n       It will only process C/C#/CC selected lines or the whole\n       file if no range is specified.  For example:\n\n          ALIGN  'PIC 9(9)'\n\n       used on the following lines:\n\n          01  WORK-AREAS.\n              05  NUMBER-RECORDS-ADDED PIC 9(9)  VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-DELETED PIC 9(9)  VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-DUPS PIC 9(9)  VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-READ PIC 9(9)  VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-UPDATED PIC 9(9)  VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-WRITTEN PIC 9(9)  VALUE 0 COMP-3.\n              05  FINAL-RETURN-CODE PIC 9(4)  VALUE 0 COMP.\n\n       will result in:\n\n          01  WORK-AREAS.\n              05  NUMBER-RECORDS-ADDED   PIC 9(9) VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-DELETED PIC 9(9) VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-DUPS    PIC 9(9) VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-READ    PIC 9(9) VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-UPDATED PIC 9(9) VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-WRITTEN PIC 9(9) VALUE 0 COMP-3.\n              05  FINAL-RETURN-CODE PIC 9(4)  VALUE 0 COMP.\n\n       Note the first and last lines are not reformatted since\n       they do not contain the specified character(s).  Quotes,\n       either single or double, are only necessary if blanks or\n       oddball special characters are contained.  No arguments or\n       a single question mark will cause built in help to be\n       displayed.\n\n       COBOL comment and debug lines will not be re-aligned!\n+      _____________________________________________________\n       Please see ALIGNS below for a more compact alignment.\n\n\n:HEADER2 ALIGNALL  CHARS\n:HEADERT Align All Text at Character(s) Specified\n\n       aligns the fields of the records selected at the\n       character(s) specified based on the maximum size of each\n       field in that range.  No argument specified will cause\n       built in help to be displayed.  It will only process\n       C/C#/CC selected lines or the whole file if no range is\n       specified.  For example:\n\n          ALIGNALL  !\n\n       used on the following lines:\n\n          aaa!aaa!aaa!aaa\n          b!b!b!b\n          ccccc!cc!cccccccc!c\n          dddd!dddd!dddd!dddd\n\n       will result in:\n\n          aaa  !aaa !aaa     !aaa\n          b    !b   !b       !b\n          ccccc!cc  !cccccccc!c\n          dddd !dddd!dddd    !dddd\n\n       Note that every field has been expanded to the maximum\n       size needed to hold that field, e.g. the 3rd field now\n       is 8 characters to hold the 8 c's in the 3rd record and\n       the 2nd field is 4 bytes to hold the 4 d's in the last\n       record.\n\n       Please see ALIGN above, and ALIGNAX AND ALIGNS below for\n       variations on the alignment concept.\n\n\n:HEADER2 ALIGNAX  CHARS\n:HEADERT Align All Text at Character(s) Specified Removing Delimiter\n\n       aligns the fields of the records selected at the\n       character(s) specified based on the maximum size of each\n       field in that range, removing the delimiter.  No argument\n       specified will cause built in help to be displayed.  It\n       will only process C/C#/CC selected lines or the whole file\n       if no range is specified.  For example:\n\n          ALIGNAX  !\n\n       used on the following lines:\n\n          aaa!aaa!aaa!aaa\n          b!b!b!b\n          ccccc!cc!cccccccc!c\n          dddd!dddd!dddd!dddd\n\n       will result in:\n\n          aaa  aaa aaa     aaa\n          b    b   b       b\n          ccccccc  ccccccccc\n          dddd dddddddd    dddd\n\n       Note that every field has been expanded to the maximum\n       size needed to hold that field, e.g. the 3rd field now\n       is 8 characters to hold the 8 c's in the 3rd record and\n       the 2nd field is 4 bytes to hold the 4 d's in the last\n       record.\n\n       Please see ALIGN and ALIGNALL above and ALIGNS below for\n       variations on the alignment concept.  This is basically\n       the same macro as ALIGNALL with the difference that the\n       delimiter is removed.\n\n\n:HEADER2 ALIGNS  ( CHARS | ? )\n:HEADERT Align Text at Character(s) Specified Minimizing Blanks\n\n       aligns the text at the right most character(s) specified\n       with minimal spacing.  It will only process C/C#/CC\n       selected lines or the whole file if no range is specified.\n       For example:\n\n          ALIGNS  'PIC 9(9)'\n\n       used on the following lines:\n\n          01  WORK-AREAS.\n              05  NUMBER-RECORDS-ADDED PIC 9(9)  VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-DELETED PIC 9(9)  VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-DUPS       PIC 9(9)  VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-READ  PIC 9(9)  VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-UPDATED PIC 9(9)  VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-WRITTEN    PIC 9(9)  VALUE 0 COMP-3.\n              05  FINAL-RETURN-CODE PIC 9(4)  VALUE 0 COMP.\n\n       will result in:\n\n          01  WORK-AREAS.\n              05  NUMBER-RECORDS-ADDED   PIC 9(9) VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-DELETED PIC 9(9) VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-DUPS    PIC 9(9) VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-READ    PIC 9(9) VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-UPDATED PIC 9(9) VALUE 0 COMP-3.\n              05  NUMBER-RECORDS-WRITTEN PIC 9(9) VALUE 0 COMP-3.\n              05  FINAL-RETURN-CODE PIC 9(4)  VALUE 0 COMP.\n\n       Note the first and last lines are not reformatted and only\n       one blank is used to separate the chosen characters from\n       the preceding text.  Quotes, either single or double, are\n       only necessary if blanks or oddball special characters are\n       contained.  No arguments or a single question mark will\n       cause built in help to be displayed.\n\n       COBOL comment and debug lines will not be re-aligned!\n+      _____________________________________________________\n       Please see ALIGN above for a slightly different variation\n       on separation.\n\n\n:HEADER2 BC   ( LEFT-COL  RIGHT-COL )  ( .A .B )\n:HEADERT Blank Selected Columns\n\n       will place blanks in the selected columns. LEFT-COL and\n       RIGHT-COL default to 73 and 80. C/CC/C# or labels may be\n       used to select the lines impacted.  If no range is\n       specified, the entire file is processed.\n\n          BC\n\n       will cause columns 73 through 80 of every line to be\n       blanked. A question mark (?) as the first operand will\n       cause inline help to be displayed.\n\n\n:HEADER2 COBCOLO  ( ? )\n:HEADERT Put COBOL Offsets in Columns 73 to 80\n\n      invokes FileAid (COBCOLOF) or InSync (COBCOLOI) programs to\n      determine the offsets for COBOL data structures and places\n      them in columns 73 through 80 as ZZZ9-ZZ9. The starting\n      position goes from 1 to 9999 while the ending position will\n      only show the last 3 digits. The C/C#/CC prefix commands\n      may be used to limit the columns processed.\n\n      This is the old version of COBCOLS which uses all 8\n      positions to show the offsets. Please see its documentation\n      below.\n\n      The question mark will cause the built in help to be\n      displayed.\n\n      An example is:\n\n       01 REQ-FRM-REQUEST.                                   1- 48\n           05 REQ-CCS-KEY.                                   1- 48\n               10 REQ-CCS-CALLER          PIC X(01).         1-  1\n      *        10 REQ-CCS-CUST-NO         PIC X(18).\n               10 REQ-CCS-CUST-NO         PIC X(20).         2- 21\n               10 REQ-CCS-GROUP           PIC X(03).        22- 24\n               10 REQ-CCS-SUBGROUP        PIC X(15).        25- 39\n               10 REQ-CCS-TIME            PIC 9(13) COMP-3. 40- 46\n               10 REQ-CCS-TIME-X                            40- 46\n                  REDEFINES REQ-CCS-TIME  PIC X(07).\n               10 REQ-CCS-SEQ             PIC 9(02).        47- 48\n\n      Note that the commented statement is ignored.\n\n      A limitation on this command is that array sub-structures\n      are not processed. Please see COBCOLV below for a variant\n      which will show those offsets.\n\n\n:HEADER2 COBCOLS  ( ? )\n:HEADERT Put COBOL Offsets in Columns 73 to 80\n\n      invokes FileAid (COBCOLSF) or InSync (COBCOLSI version) to\n      determine the offsets for COBOL data structures and places\n      them in columns 73 through 80 as ZZZ9ZZZ9. The starting and\n      ending positions run from 1 through 9999.  The C/C#/CC\n      prefix commands may be used to limit the columns processed.\n\n      This is the new version of COBCOLO which used less then 4\n      positions to show the offsets. Please see its documentation\n      above. Also see COBCOLV below.\n\n      The question mark will cause the built in help to be\n      displayed but will not invoke the code.\n\n      An example is:\n\n       01 REQ-FRM-REQUEST.                                    1  48\n           05 REQ-CCS-KEY.                                    1  48\n               10 REQ-CCS-CALLER          PIC X(01).          1   1\n      *        10 REQ-CCS-CUST-NO         PIC X(18).\n               10 REQ-CCS-CUST-NO         PIC X(20).          2  21\n               10 REQ-CCS-GROUP           PIC X(03).         22  24\n               10 REQ-CCS-SUBGROUP        PIC X(15).         25  39\n               10 REQ-CCS-TIME            PIC 9(13) COMP-3.  40  46\n               10 REQ-CCS-TIME-X                             40  46\n                  REDEFINES REQ-CCS-TIME  PIC X(07).\n               10 REQ-CCS-SEQ             PIC 9(02).         47  48\n\n      Note that the commented statement is ignored.\n\n      A limitation on this command is that array sub-structures\n      are not processed. Please see COBCOLV below for a variant\n      which will show those offsets.\n\n\n:HEADER2 COBCOLV  ( ? )\n:HEADERT View FileAid/InSync Layout of COBOL Data Structure\n\n      invokes FileAid (COBCOLVF) or InSync (COBCOLVI) to generate\n      a record layout and then View that output in a separate\n      session.  The C/C#/CC prefix commands may be used to limit\n      the columns processed.\n\n      This is a variant of the COBCOLO and COBCOLS macros above\n      without the array sub-structure limitation.\n\n      The question mark will cause the built in help to be\n      displayed but will not invoke the code.\n\n      A sample input for which COBCOLVF was invoked follows:\n\n       01 REQ-FRM-REQUEST.\n           05 REQ-CCS-KEY.\n               10 REQ-CCS-CALLER          PIC X(01).\n      *        10 REQ-CCS-CUST-NO         PIC X(18).\n               10 REQ-CCS-CUST-NO         PIC X(20).\n               10 REQ-CCS-GROUP           PIC X(03).\n               10 REQ-CCS-SUBGROUP        PIC X(15).\n               10 REQ-CCS-TIME            PIC 9(13) COMP-3.\n               10 REQ-CCS-TIME-X\n                  REDEFINES REQ-CCS-TIME  PIC X(07).\n               10 REQ-CCS-SEQ             PIC 9(02).\n               10 REQ-ARRAY  OCCURS 5 TIMES.\n                   15 REQ-CCS-REP         PIC X(03).\n                   15 REQ-CCS-REP-STAT    PIC 9(01).\n               10                         PIC X(12).\n\n      And the resultant output, for the InSync version, slightly\n      truncated to fit here, looks like:\n\n         01  REQ-FRM-REQUEST                 G            1     80\n           05  REQ-CCS-KEY                   G            1     80\n             10  REQ-CCS-CALLER              C    1       1      1\n             10  REQ-CCS-CUST-NO             C   20       2     20\n             10  REQ-CCS-GROUP               C    3      22      3\n             10  REQ-CCS-SUBGROUP            C   15      25     15\n             10  REQ-CCS-TIME                P   13      40      7\n             10  REQ-CCS-TIME-X              C    7      40      7\n                     REDEFINES REQ-CCS-TIME\n             10  REQ-CCS-SEQ                 Z    2      47      2\n             10  REQ-ARRAY(1)                G           49      4\n                     OCCURS     5 TIMES\n               15  REQ-CCS-REP(1)            C    3      49      3\n               15  REQ-CCS-REP-STAT(1)       Z    1      52      1\n             10  REQ-ARRAY(2)                G           53      4\n               15  REQ-CCS-REP(2)            C    3      53      3\n               15  REQ-CCS-REP-STAT(2)       Z    1      56      1\n             10  REQ-ARRAY(3)                G           57      4\n               15  REQ-CCS-REP(3)            C    3      57      3\n               15  REQ-CCS-REP-STAT(3)       Z    1      60      1\n             10  REQ-ARRAY(4)                G           61      4\n               15  REQ-CCS-REP(4)            C    3      61      3\n               15  REQ-CCS-REP-STAT(4)       Z    1      64      1\n             10  REQ-ARRAY(5)                G           65      4\n               15  REQ-CCS-REP(5)            C    3      65      3\n               15  REQ-CCS-REP-STAT(5)       Z    1      68      1\n             10  FILLER                      C   12      69     12\n\n      Note the data types, starting position, ending position\n      and length shown for a non commented data items.\n\n      The above example shows the expanded array layout.\n\n\n:HEADER2 DELPARA\n:HEADERT Deletes COBOL DISPLAY Statements from DISPARA & DISPVAR\n\n       will delete all DISPLAY statements inserted by DISPARA\n       and DISPVAR in COBOL code.  For example:\n\n          DELPARA\n\n       will delete DISPLAY '~DEBUG~ 0100-INITIALIZATION. ' which\n       had been inserted by DISPARA immediately after paragraph\n       0100-INITIALIZATION. Please see DISPARA and DISPVAR below.\n\n\n:HEADER2 DISPARA\n:HEADERT Insert COBOL DISPLAY at Each Paragraph\n\n       will insert a DISPLAY statement after each paragraph in\n       COBOL code.  For example:\n\n          DISPARA\n\n       will insert DISPLAY '~DEBUG~ 0100-INITIALIZATION'\n       immediately after paragraph 0100-INITIALIZATION.  The\n       DELPARA command will remove all the inserted lines.\n       Please see DELPARA above.\n\n       If the code contains exit paragraphs of the form\n\n           0100-INITIALIZATION-EXIT.  EXIT.\n\n       DISPARA will split the line leaving the EXIT. on the\n       second line and then add the DISPLAY line after the\n       paragraph name line.  So the result from the above would\n       be:\n\n           0100-INITIALIZATION-EXIT.\n               DISPLAY '~DEBUG~ 0100-INITIALIZATION'\n                                      EXIT.\n\n\n:HEADER2 DISPVAR\n:HEADERT Insert a DISPLAY for the Variable at the Cursor\n\n       inserts a DISPLAY statement for the variable with the\n       cursor on it.  For example if invoked with the cursor\n       anywhere on NUMBER-RECORDS-READ, the next two lines will\n       be inserted:\n\n               NOT AT END ADD 1 TO NUMBER-RECORDS-READ\n           DISPLAY '~DEBUG~ NUMBER-RECORDS-READ = >'\n             NUMBER-RECORDS-READ '< ~DEBUG~'\n\n       Note all lines generated contain ~DEBUG~ so DELPARA may be\n       used to delete them when no longer necessary.  Variables\n       named like WS-DATA (12) (2:5) will work just fine.  If there\n       are spaces within or outside the parentheses in the\n       subscript and/or reference modification, DISPVAR will\n       handle it appropriately but the cursor MUST be positioned\n+                                             ____\n       on the name, i.e. WS-DATA in WS-DATA ( 12 ) ( 2 : 5 ).\n\n       IN or OF constructs are also handled even if on the line\n       below where the cursor is positioned. For example, if the\n       cursor is on WS-SECURITY-NUMBER in the following:\n\n           ADD WS-INCR TO WS-SEC-NUMBER\n               OF WS-INPUT-RECORD ( ITEM - 3 )\n\n       the resultant code would be:\n\n           ADD WS-INCR TO WS-SEC-NUMBER\n               OF WS-INPUT-RECORD ( ITEM - 3 )\n           DISPLAY '~DEBUG~ WS-SEC-NUMBER OF WS-INPUT-RECORD (* = >'\n             WS-SEC-NUMBER OF WS-INPUT-RECORD ( ITEM - 3 ) '< ~DEBUG~'\n\n       Note extra blanks are removed and the generated code\n       starts in column 12. This keeps the inserted number of\n       lines to a minimum. Please note the truncation of\n       extremely long names above.\n\n       DISPVAR is probably best utilized from a function key,\n       <F22> is suggested.\n\n\n:HEADER2 IE  ( Indent )\n:HEADERT Adds a COBOL EVALUATE Structure Following the Cursor\n\n       inserts the following code immediately after the line on\n       which the cursor is positioned. It will line up with\n       the previous line, making that line the top line on\n       the screen and placing the cursor on the first leader\n       dots (...).\n\n          EVALUATE ...\n              WHEN ...\n                  ...\n              WHEN ...\n                  ...\n              WHEN OTHER\n                  ...\n          END-EVALUATE\n\n       The indentation may be specified but defaults to 4.  The\n       inserted statements are indented that value if the\n       preceding statement can be identified as an IF, ELSE or\n       PERFORM.\n\n\n:HEADER2 II  ( Indent )\n:HEADERT Adds a COBOL IF Structure Following the Cursor\n\n       inserts the following code immediately after the line on\n       which the cursor is positioned. It will line up with\n       the previous line, making that line the top line on\n       the screen and placing the cursor on the first leader\n       dots (...).\n\n          IF\n              ...\n          ELSE\n              ...\n          END-IF\n\n       The indentation may be specified but defaults to 4.  The\n       inserted statements are indented that value if the\n       preceding statement can be identified as an IF, ELSE or\n       PERFORM.\n\n\n:HEADER2 IP  ( Indent )\n:HEADERT Adds a COBOL PERFORM Structure Following the Cursor\n\n       inserts the following code immediately after the line on\n       which the cursor is positioned. It will line up with\n       the previous line, making that line the top line on\n       the screen and placing the cursor on the first leader\n       dots (...).\n\n          PERFORM\n              VARYING ... FROM 1 BY 1\n                  UNTIL ...\n              ...\n          END-PERFORM\n\n       The indentation may be specified but defaults to 4.  The\n       inserted statements are indented that value if the\n       preceding statement can be identified as an IF, ELSE or\n       PERFORM.\n\n\n:HEADER2 IS  ( Indent )\n:HEADERT Adds a COBOL SEARCH Structure Following the Cursor\n\n       inserts the following code immediately after the line on\n       which the cursor is positioned. It will line up with\n       the previous line, making that line the top line on\n       the screen and placing the cursor on the first leader\n       dots (...).\n\n          SET ... TO 1\n          SEARCH ...\n              AT END\n                  ...\n              WHEN ...\n                  ...\n          END-SEARCH\n\n       The indentation may be specified but defaults to 4.  The\n       inserted statements are indented that value if the\n       preceding statement can be identified as an IF, ELSE or\n       PERFORM.\n\n\n:HEADER2 ISA  ( Indent )\n:HEADERT Adds a COBOL SEARCH ALL Structure Following the Cursor\n\n       inserts the following code immediately after the line on\n       which the cursor is positioned. It will line up with\n       the previous line, making that line the top line on\n       the screen and placing the cursor on the first leader\n       dots (...).\n\n          SEARCH ALL ...\n              AT END\n                  ...\n              WHEN ...\n                  ...\n          END-SEARCH\n\n       The indentation may be specified but defaults to 4.  The\n       inserted statements are indented that value if the\n       preceding statement can be identified as an IF, ELSE or\n       PERFORM.\n\n\n:HEADER2 IST  ( Indent )\n:HEADERT Adds a COBOL STRING Structure Following the Cursor\n\n       inserts the following code immediately after the line on\n       which the cursor is positioned. It will line up with\n       the previous line, making that line the top line on\n       the screen and placing the cursor on the first leader\n       dots (...).\n\n          STRING\n              ...\n              ...\n              ...\n                  DELIMITED BY SIZE\n              INTO ...\n          END-STRING\n\n       The indentation may be specified but defaults to 4.  The\n       inserted statements are indented that value if the\n       preceding statement can be identified as an IF, ELSE or\n       PERFORM.\n\n\n:HEADER2 JB     ( ? )\n:HEADERT Jump Back to PERFORM Statement\n\n       will place the display back at the COBOL PERFORM statement\n       where the JT command was invoked. Please see the JT\n       command description below. A question mark (?) supplied as\n       the only parameter will cause built in help to be\n       displayed. JB uses labels to position itself.\n\n       It is strongly suggested that this macro be assigned\n       to a PF Key, e.g. assign %JB to PF 19 (pseudo back).\n\n\n:HEADER2 JT     ( ? )\n:HEADERT Jump to PERFORMed Paragraph or View Copybook\n\n       determines the paragraph specified in a COBOL PERFORM on\n       the line where the cursor is positioned and changes the\n       code displayed to the start of that paragraph.  The JB\n       command is used in conjunction to return to the previous\n       PERFORM statement. Please see the description of JB above.\n\n       If the cursor is on a line with a COPY, the macro will\n       View the copybook in a site's hard coded copybook library\n       (defaulted to -YOUR-COPYLIB-1- through -YOUR-COPYLIB-4-).\n\n       A question mark (?)  supplied as the only parameter will\n       cause built in help to be displayed.\n\n       It is strongly suggested that this macro be assigned to a\n       PF Key, e.g. assign %JT to PF 20 (pseudo forward).\n\n\n:HEADER2 SPLITAFT  STRING  ( INDENT )\n:HEADERT Split Lines After the String Specified\n\n      will split the specified lines after the string provided. A\n+                                    _____\n      range of lines may be specified by C/CC/C## or the entire\n      file will be processed.  Quotes may be used around the\n      string.  INDENT must be a whole number; otherwise it\n      defaults to 4. COBOL comments ('*' or '/' in column 7) or\n      COBOL debug lines ('D' in column 7) will be ignored\n\n      For example, if SPLITAFT THRU 7 is run against:\n\n               PERFORM 100-INIT-PARA    THRU   999-INIT-EXIT\n               PERFORM 200-PROC-PARA    THRU   999-PROC-EXIT\n               PERFORM 900-QUIT-PARA    THRU   999-QUIT-EXIT\n\n      the following will result:\n\n               PERFORM 100-INIT-PARA    THRU\n                      999-INIT-EXIT\n               PERFORM 200-PROC-PARA    THRU\n                      999-PROC-EXIT\n               PERFORM 900-QUIT-PARA    THRU\n                      999-QUIT-EXIT\n\n      If no parameters are specified, built-in help will\n      be displayed. Please also see SPLITAT below.\n\n\n:HEADER2 SPLITAT  STRING  ( INDENT )\n:HEADERT Split Lines On a Specified String\n\n      will split the specified lines at the string provided. A\n+                                    __\n      range of lines may be specified by C/CC/C## or the entire\n      file will be processed.  Quotes may be used around the\n      string.  INDENT must be a whole number; otherwise it\n      defaults to 4. COBOL comments ('*' or '/' in column 7) or\n      COBOL debug lines ('D' in column 7) will be ignored.\n\n      For example, if SPLITAT ' TO ' is run against:\n\n               MOVE  WS-LEADER-DOTS     TO     OUT-NAME0\n               MOVE  WS-FIRST-NAME      TO   OUT-NAME1\n               MOVE  WS-MIDDLE-INIT        TO   OUT-NAME2\n               MOVE  WS-LAST-NAME       TO   OUT-NAME3\n               MOVE  WS-TRAILER-DOTS      TO   OUT-NAME9\n\n      the following will result:\n\n               MOVE  WS-LEADER-DOTS\n                    TO     OUT-NAME0\n               MOVE  WS-FIRST-NAME\n                    TO   OUT-NAME1\n               MOVE  WS-MIDDLE-INIT\n                    TO   OUT-NAME2\n               MOVE  WS-LAST-NAME\n                    TO   OUT-NAME3\n               MOVE  WS-TRAILER-DOTS\n                    TO   OUT-NAME9\n\n      Note the indentation of 4 blanks is placed before the\n      string, ' TO ', resulting in 5 blanks.  If no parameters\n      are specified, built-in help will be displayed. Please\n      also see SPLITAFT above.\n\n\n:HEADER2 STRUCT   Language  ( .A .B )\n:HEADERT Show Significant Structural Code Elements\n\n       excludes everything and then unexcludes any lines that\n       have structural constructs for the specified language such\n       as IF, ELSE, or PROC.  The languages specified are COB or\n       COBOL for COBOL; EZ for Easytrieve; PL1, PLI, PL/1 or PL/I\n       for PL/I; or REX or REXX for REXX.  Comments in COBOL and\n       Easytrieve will be left excluded.  Similarly, all JCL (//\n       in column 1) will also be left excluded.  For example,\n\n          STRUCT  COB\n\n       will show the logical structure of the edited COBOL\n       program. A label range may be specified.\n\n       For example, given the following:\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  BASE INITIAL.\n       CONFIGURATION SECTION.\n       SPECIAL-NAMES.\n           CLASS ALPHA-CHARS\n               IS 'A' THRU 'Z', '0' THRU '9', ' ', '.'.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT I\n               ASSIGN TO I.\n           SELECT O\n               ASSIGN TO O.\n       DATA DIVISION.\n       FILE SECTION.\n       FD  I\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  INPUT-REC    PIC X(00080).\n       FD  O\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  OUTPUT-REC   PIC X(00080).\n       WORKING-STORAGE SECTION.\n       01  WS-INPUT-REC                 PIC X(00080).\n       01  WS-SAVE-REC                  PIC X(00080).\n       01  WORK-AREAS.\n           05  NUMBER-RECORDS-ADDED     PIC 9(9)      VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-DELETED   PIC 9(9)      VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-DUPS      PIC 9(9)      VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-READ      PIC 9(9)      VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-UPDATED   PIC 9(9)      VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-WRITTEN   PIC 9(9)      VALUE 0 COMP-3.\n           05  FINAL-RETURN-CODE        PIC 9(4)      VALUE 0 COMP.\n           05  END-OF-FILE-STATUS       PIC X         VALUE 'N'.\n               88  AT-END-OF-FILE                     VALUE 'Y'.\n           05  REWRITE-REC              PIC X         VALUE 'Y'.\n       01  WEEK-DAY-NUMBER              PIC 9.\n       01  YYMMDD                       PIC 9(6).\n       01  HHMM                         PIC 9(8).\n       01  DAYS-OF-WEEK.\n           05  MONDAY    PIC X(9)       VALUE 'MONDAY'.\n           05  TUESDAY   PIC X(9)       VALUE 'TUESDAY'.\n           05  WEDNESDAY PIC X(9)       VALUE 'WEDNESDAY'.\n           05  THURSDAY  PIC X(9)       VALUE 'THURSDAY'.\n           05  FRIDAY    PIC X(9)       VALUE 'FRIDAY'.\n           05  SATURDAY  PIC X(9)       VALUE 'SATURDAY'.\n           05  SUNDAY    PIC X(9)       VALUE 'SUNDAY'.\n       01  WEEK-DAYS                    REDEFINES DAYS-OF-WEEK.\n           05 WEEK-DAY   OCCURS 7 TIMES PIC X(9).\n       LINKAGE SECTION.\n       01  PARM-DATA.\n           05  PARM-LENGTH              PIC 9(4)              COMP.\n           05  PARM-PASSED              PIC X(100).\n       PROCEDURE DIVISION USING PARM-DATA.\n       0000-MAIN.\n           PERFORM 0100-INITIALIZATION\n           PERFORM 0200-READ-WRITE-LOOP\n               UNTIL AT-END-OF-FILE\n           PERFORM 0900-TERMINATION\n           MOVE FINAL-RETURN-CODE TO RETURN-CODE\n           GOBACK\n           .\n       0100-INITIALIZATION.\n           OPEN  INPUT  I\n                 OUTPUT O\n           READ  I INTO WS-INPUT-REC\n               AT END SET AT-END-OF-FILE TO TRUE\n               NOT AT END ADD 1 TO NUMBER-RECORDS-READ\n           END-READ\n           .\n       0200-READ-WRITE-LOOP.\n           MOVE 'Y' TO REWRITE-REC\n           PERFORM 0200-PROCESS\n           IF REWRITE-REC = 'Y'\n               WRITE OUTPUT-REC FROM WS-INPUT-REC\n               ADD 1 TO NUMBER-RECORDS-WRITTEN\n           ELSE\n               ADD 1 TO NUMBER-RECORDS-DELETED\n           END-IF\n           READ  I INTO WS-INPUT-REC\n               AT END SET AT-END-OF-FILE TO TRUE\n               NOT AT END ADD 1 TO NUMBER-RECORDS-READ\n           END-READ\n           .\n       0200-PROCESS.\n           CONTINUE\n           .\n       0900-TERMINATION.\n           CLOSE I\n                 O\n           ACCEPT WEEK-DAY-NUMBER FROM DAY-OF-WEEK\n           ACCEPT YYMMDD FROM DATE\n           ACCEPT HHMM FROM TIME\n           DISPLAY 'PROGRAM STATISTICS:  '\n               '                         '\n               WEEK-DAY(WEEK-DAY-NUMBER) ' '\n               YYMMDD '-' HHMM(1:2) ':' HHMM(3:2)\n           DISPLAY '    PARM LENGTH               = '\n               PARM-LENGTH\n           IF PARM-LENGTH NOT = 0\n               DISPLAY '    PARM PASSED TO PROGRAM    = '\n                   PARM-PASSED(1:PARM-LENGTH)\n           END-IF\n           DISPLAY ' '\n           DISPLAY '    NUMBER OF RECORDS READ    = '\n               NUMBER-RECORDS-READ\n           DISPLAY '    NUMBER OF RECORDS WRITTEN = '\n               NUMBER-RECORDS-WRITTEN\n           DISPLAY '    NUMBER OF RECORDS UPDATED = '\n               NUMBER-RECORDS-UPDATED\n           DISPLAY '    NUMBER OF RECORDS DELETED = '\n               NUMBER-RECORDS-DELETED\n           DISPLAY '    NUMBER OF RECORDS ADDED   = '\n               NUMBER-RECORDS-ADDED\n           DISPLAY '    NUMBER OF DUPLICATE RECS  = '\n               NUMBER-RECORDS-DUPS\n           .\n\n       The following would be displayed:\n\n             PROCEDURE DIVISION USING PARM-DATA.\n               -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed\n                 PERFORM 0100-INITIALIZATION\n                 PERFORM 0200-READ-WRITE-LOOP\n                     UNTIL AT-END-OF-FILE\n                 PERFORM 0900-TERMINATION\n               -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed\n                 GOBACK\n               -  -  -  -  -  -  -  -  -  -  - 11 Line(s) not Displayed\n                 PERFORM 0200-PROCESS\n                 IF REWRITE-REC = 'Y'\n               -  -  -  -  -  -  -  -  -  -  -  2 Line(s) not Displayed\n                 ELSE\n               -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed\n                 END-IF\n               -  -  -  -  -  -  -  -  -  -  - 20 Line(s) not Displayed\n                 IF PARM-LENGTH NOT = 0\n               -  -  -  -  -  -  -  -  -  -  -  2 Line(s) not Displayed\n                 END-IF\n               -  -  -  -  -  -  -  -  -  -  1457 Line(s) not Displayed\n\n\n:HEADER2 SUFFLINE  STRING  ( ? )\n:HEADERT Append a String to the End of Selected Line(s)\n\n       will append the specified string to the end of every line\n       selected via C/CC/C# range selection or to every line in\n       the file. Blank lines will be left unchanged.\n\n       The words COMMA, APOST and QUOTE may be used to append\n       , or ' or \" respectively. For example,\n\n          SUFFLINE  )\n\n       will cause the following lines\n\n          MOVE 0      TO  FAR-TBL(SUB1\n          MOVE 0      TO  NEAR-TABLE(VAR11A\n          MOVE 0      TO  SOME-ARRAY-NAME(11 23\n          MOVE 0      TO  EASY(1\n\n       to become\n\n          MOVE 0      TO  FAR-TBL(SUB1)\n          MOVE 0      TO  NEAR-TABLE(VAR11A)\n          MOVE 0      TO  SOME-ARRAY-NAME(11 23)\n          MOVE 0      TO  EASY(1)\n\n       SUFFLINE could be used to suffix an odd character, say !,\n       on which a C '!' '...' ALL could be executed for\n       simplicity.\n\n       If a question mark (?) is specified as the parameter, the\n       inline help is displayed without moving any lines.\n\n\n:HEADER2 XINDENT  ( ? )\n:HEADERT Exclude to Similarly Indented Line\n\n      based on IBM freeware, has been revamped to specifically\n      handle COBOL code, ignoring comments and junk in columns 1\n      through 6.  Most useful when assigned to a PF Key.\n\n      The general concept is to place the cursor anywhere on a\n      line and have the code excluded to the corresponding start\n      or end line of that construct.\n\n      if the first non blank after column 7 is an 'IF', the lines\n      downward to the next similarly indented ELSE or END-IF will\n      be excluded.  If placed on an 'END-IF' line, it will\n      exclude upwards to a preceding 'ELSE' or 'IF'. If placed on\n      an 'ELSE' line, it will check to see if the preceding line\n      is excluded already and, if so, will exclude downwards to\n      the next similarly indented 'IF'. If not, it will exclude\n      downwards to an 'END-IF'.\n\n      If the cursor is positioned on a PERFORM, the scan proceeds\n      downwards to the similarly indented END-PERFORM. If on an\n      END-PERFORM, it scans upwards for a PERFORM.\n\n      If the cursor is positioned on a EVALUATE, the scan proceeds\n      downwards to the similarly indented END-EVALUATE. If on an\n      END-EVALUATE, it scans upwards for a EVALUATE.\n\n      A parameter of a question mark (?) will cause the built in\n      help to be displayed.\n\n      So if the cursor were placed anywhere on the line with the\n      'IF' in the following text, and XINDENT invoked,\n\n           IF REWRITE-REC = 'Y'\n               WRITE OUTPUT-REC FROM WS-INPUT-REC\n               ADD 1 TO NUMBER-RECORDS-WRITTEN\n           ELSE\n               ADD 1 TO NUMBER-RECORDS-DELETED\n           END-IF\n\n      The following would be displayed:\n\n          IF REWRITE-REC = 'Y'\n           -  -  -  -  -  -  -  -  -  -  2 Line(s) not Displayed\n          ELSE\n              ADD 1 TO NUMBER-RECORDS-DELETED\n          END-IF\n\n      If the cursor were now to be placed on the 'END-IF' or\n      'ELSE' line:\n\n          IF REWRITE-REC = 'Y'\n           -  -  -  -  -  -  -  -  -  -  -  -  2 Line(s) not Displayed\n          ELSE\n           -  -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed\n          END-IF\n\n      would result. Obviously, the various constructs must line\n      up, i.e. the indentation must be the same.  While this\n      demands some precision, the benefits of using XINDENT as\n      well as having consistent code are well worth the cost.\n\n\n:HEADER1 JCL Manipulation Macros\n\n These macros are useful with JCL, either adding lines or\n reformatting them.\n\n\n:HEADER2 CU  ( ###  |  ? )\n:HEADERT Add Clean Up IEFBR14 JCL after Cursor Position\n\n      will add an IEFBR14 step after the line on which the cursor\n      is positioned with ### MOD/DELETE DD cards with ###\n      defaulting to 1.  A solitary question mark will cause built\n      in help to display.  At the end, the cursor will be placed\n      on the first set of dots.\n\n      For example, CU 4 will insert the following immediately\n      after the cursor:\n\n      //***\n      //***\n      //CLEANUP    EXEC     PGM=IEFBR14\n      //DEL001       DD       DSN=...,\n      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n      //DEL002       DD       DSN=...,\n      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n      //DEL003       DD       DSN=...,\n      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n      //DEL004       DD       DSN=...,\n      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n\n      Please see CUD below for dynamically generated delete\n      images.\n\n\n:HEADER2 CUD  ( ? )\n:HEADERT Dynamically Add Clean Up IEFBR14 JCL after Cursor\n\n      will add IEFBR14 step after where the cursor is positioned\n      for every NEW CATLG data set in the file.  C/CC/C# may be\n      used to limit the search for new data sets to only those\n      lines.  A solitary question mark will cause built in help\n      to display.  At the end, the cursor will be placed where it\n      was initially positioned.\n\n      For example, given the following somewhere in the searched\n      area of the file:\n\n      //CREATION   EXEC     PGM=SOMEPGM\n      //FILE01       DD       DSN=SYS4.LIMITED.DATA,DISP=(NEW,CATLG),\n      //             UNIT=SYSDA,SPACE=(CYL,10)\n      //XX       DD       DISP=(,CATLG),\n      //          UNIT=TESTPK,\n      //          VOL=SER=TP0037,\n      //          DCB=(RECFM=VBS,BLKSIZE=27998),\n      //          DSNAME=YOURID.SOME.DATA.SET.NAME\n      //         DD       DISP=(,CATLG),DSN=YOURID.VBSFILE,\n      //          UNIT=SYSDA,SPACE=(TRK,(1000,1000),RLSE)\n         ... some other irrelevant lines ...\n      //             DD       DISP=(NEW,CATLG,DELETE),\n      //             UNIT=SYSDA,\n      //             SPACE=(CYL,5),\n      //             DSN=YOURID.RUBBER.DUCKY,\n      //             DCB=BLKSIZE=0\n\n      CUD will insert the following lines after the line where\n      the cursor is positioned:\n\n      //***\n      //***\n      //CLEANUP  EXEC  PGM=IEFBR14\n      //DEL001           DSN=SYS4.LIMITED.DATA,\n      //           DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n      //DEL002           DSN=YOURID.SOME.DATA.SET.NAME,\n      //           DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n      //DEL003           DSN=YOURID.VBSFILE,\n      //           DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n      //DEL004           DSN=YOURID.RUBBER.DUCKY,\n      //           DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n\n      CUD has a problem with JCL where certain parts were left as\n      comments, e.g. leaving DISP=SHR on the end of the\n      DISP=(,CATLG) line. Clean JCL is good JCL!\n\n\n:HEADER2 CHDEL ( ? )\n:HEADERT Dynamically Add HDELETE JCL after Cursor\n\n      will add an HDELETE command after where the cursor is\n      positioned for every NEW CATLG data set in the file.\n      C/CC/C# may be used to limit the search for new data sets\n      to only those lines.  A solitary question mark will cause\n      built in help to display.  At the end, the cursor will be\n      placed where it was initially positioned.\n\n      Including this in the JCL stream before clean up JCL\n      (IEFBR14 MOD DELETE's) will greatly reduce recall time.\n\n      For example, given the following somewhere in the searched\n      area of the file:\n\n      //CREATION   EXEC     PGM=SOMEPGM\n      //FILE01       DD       DSN=SYS4.LIMITED.DATA,DISP=(NEW,CATLG),\n      //             UNIT=SYSDA,SPACE=(CYL,10)\n      //XX       DD       DISP=(,CATLG),\n      //          UNIT=TESTPK,\n      //          VOL=SER=TP0037,\n      //          DCB=(RECFM=VBS,BLKSIZE=27998),\n      //          DSNAME=YOURID.SOME.DATA.SET.NAME\n      //         DD       DISP=(,CATLG),DSN=YOURID.VBSFILE,\n      //          UNIT=SYSDA,SPACE=(TRK,(1000,1000),RLSE)\n         ... some other irrelevant lines ...\n      //             DD       DISP=(NEW,CATLG,DELETE),\n      //             UNIT=SYSDA,\n      //             SPACE=(CYL,5),\n      //             DSN=YOURID.RUBBER.DUCKY,\n      //             DCB=BLKSIZE=0\n\n      CHDEL will insert the following lines after the line where\n      the cursor is positioned:\n\n      //***\n      //BATCHTSO   EXEC     PGM=IKJEFT01,REGION=4M,DYNAMNBR=32\n      //SYSTSIN      DD       *\n        HDEL  'SYS4.LIMITED.DATA'\n        HDEL  'YOURID.SOME.DATA.SET.NAME'\n        HDEL  'YOURID.VBSFILE'\n        HDEL  'YOURID.RUBBER.DUCKY'\n        CALL  *(IEFBR14)\n      //SYSTSPRT     DD       SYSOUT=*\n      //***\n\n      If the dataset does not exist, a NOT IN CATALOG message\n      is issued from HDELETE; if the dataset is not migrated,\n      a DATA SET NOT MIGRATED is issued; if the dataset does\n      exist and the request is queued, a message showing\n      DELETE REQUEST 00031371 SENT TO DFSMSHSM is shown.\n\n\n:HEADER2 DISPDSN  ( ? )\n:HEADERT Place DSN Value after DISP=SHR\n\n       forces DSN=...,DISP=SHR into the reverse format, namely\n       DISP=SHR,DSN=...; this macro uses FAND to assure both DISP\n       and DSN are present. Useful for getting data set names to\n       the end of the line, making it easy to cut and paste. For\n       example, the following:\n\n          //XX  DD  DSN=SYS1.USERLIB,DISP=SHR\n          //    DD  DSN=SYS2.USERLIB,DISP=SHR\n          //YY  DD  DSN=SYS1.MACLIB,DISP=SHR\n\n       would be changed to:\n\n          //XX  DD  DISP=SHR,DSN=SYS1.USERLIB\n          //    DD  DISP=SHR,DSN=SYS2.USERLIB\n          //YY  DD  DISP=SHR,DSN=SYS1.MACLIB\n\n       Please see NEATJCL below for additional formatting.\n\n\n:HEADER2 GETDSNS  ( Wild-Card-String | ? )  ( STATS | DD )\n:HEADERT Paste a List of Cataloged Data Sets after Cursor\n\n      pulls a list of the data sets matching the wildcard string\n      and pastes the list after the line after where the cursor\n      is positioned. For example,\n\n         GETDSNS  SYS2.SAS.**.TEMP\n\n      might show (starting each line in column 1):\n\n         SYS2.SAS.ELGREQ.V1R1.CLIDVSAM.TEST\n         SYS2.SAS.ELGREQ.V1R1.CUSTOMER.TEST\n         SYS2.SAS.ELGREQ.V1R1.DATA.TEST\n                   ...\n\n      The STATS option will append the volume serial and number\n      of tracks for non-migrated data sets with a total. The DD\n      option will cause DD card images to be generated, for\n      example:\n\n         GETDSNS  SYS1.AOC  DD\n\n      might cause:\n\n         //             DD       DISP=SHR,\n         //             DSN=SYS1.AOC.SEVEINST\n         //             DD       DISP=SHR,\n         //             DSN=SYS1.AOC.SEVEMOD1\n         //             DD       DISP=SHR,\n         //             DSN=SYS1.AOC.SEVEMOD2\n                   ...\n\n      Note the data set name is placed on a second line and no\n      DD name is on the very first DD card image.\n\n      A ? as the only argument or no arguments at all causes the\n      internal help to be displayed.\n\n\n:HEADER2 GETGDGS  ( Base-GDG-String | ? )  ( STATS | DD )\n:HEADERT Paste a List of Cataloged GDG Names after Cursor\n\n      pulls a list of the data sets matching the base Generation\n      Data Group string and pastes the list on the line after\n      where the cursor is positioned.  For example,\n\n         GETGDGS  SOMEUSER.HIGH.LEVEL.GDG.ENTRY\n\n      might show (starting each line in column 1):\n\n         SOMEUSER.HIGH.LEVEL.GDG.ENTRY.G0007V00\n         SOMEUSER.HIGH.LEVEL.GDG.ENTRY.G0008V00\n         SOMEUSER.HIGH.LEVEL.GDG.ENTRY.G0009V00\n                   ...\n\n      The STATS option will append the volume serial and number\n      of tracks for non-migrated data sets with a total. The DD\n      option will cause DD card images to be generated, for\n      example:\n\n         GETGDGS  SOMEUSER.HIGH.LEVEL.GDG.ENTRY  DD\n\n      might cause:\n\n         //             DD       DISP=SHR,\n         //             DSN=SOMEUSER.HIGH.LEVEL.GDG.ENTRY.G0007V00\n         //             DD       DISP=SHR,\n         //             DSN=SOMEUSER.HIGH.LEVEL.GDG.ENTRY.G0008V00\n         //             DD       DISP=SHR,\n         //             DSN=SOMEUSER.HIGH.LEVEL.GDG.ENTRY.G0009V00\n                   ...\n\n      Note the data set name is placed on a second line and no\n      DD name is on the very first DD card image. Also, they are\n      generated in oldest first order.\n\n      A ? as the only argument or no arguments at all causes the\n      internal help to be displayed.\n\n\n:HEADER2 GETMEMS  Data-Set-Name\n:HEADERT Retrieve List of Member Names after the Cursor\n\n      pulls a list of all or a selected set of member names from\n      a given Data-Set-Name and places them after where the cursor\n      is positioned. A wild card of * may be used to do selection,\n      for example, GETMEMS 'SYS1.MACLIB(GET*)' would retrieve\n      only those member names that started with GET.\n\n         GETMEMS  SOME.PDS.UNDER.YOUR.USERID\n\n      might show (starting each line in column 1):\n\n         ABENDX\n         ABENDX$\n         ADDCC\n         ADDCC$\n         ADDFLAG\n         ADDLINEA\n         ADDLINEB\n         ADDLINES\n                   ...\n\n      A ? as the only argument or no arguments at all causes the\n      internal help to be displayed.\n\n\n:HEADER2 ISORT\n:HEADERT Insert a Sort Step Immediately After the Cursor Position\n\n      inserts a full sort step after where the cursor is\n      positioned in the file and places the cursor on the first\n      set of dots. If the following was the displayed screen of\n      file data and the cursor was anywhere on the second line,\n\n         //SYSOUT       DD       SYSOUT=*\n         //***                       <=== Cursor anywhere here ...\n         //***\n         //ADDHDTLR   EXEC     EZTPCG,REGION=2M\n         //INFILE       DD       DISP=SHR,DSN=USERID.INPUT.WOHDRTLR\n         //OUTFILE      DD       DSN=USERID.OUTPUT.WHDRTLR,\n         //             DISP=(NEW,CATLG,DELETE),UNIT=SYSDA,\n         //             SPACE=(CYL,(12,12),RLSE),\n         //             DCB=(RECFM=FB,LRECL=1234)\n         //STEPLIB      DD\n         //             DD       DISP=SHR,DSN=USERID.LOADLIB\n\n      the result of invoking ISORT would be:\n\n         //SYSOUT       DD       SYSOUT=*\n         //***                       <=== Cursor anywhere here ...\n         //***\n         //SORT        EXEC     PGM=SORT,REGION=256M\n         //SORTIN       DD       DISP=SHR,DSN=...<=== Cursor here now...\n         //SORTOUT      DD       DISP=(,CATLG),UNIT=SYSDA,\n         //             SPACE=(CYL,(0010,0010),RLSE),\n         //             DSN=...,\n         //             DCB=(...)\n         //SYSIN        DD       *\n            SORT    FIELDS=(0001,0001,CH,A)\n              INCLUDE  COND=(....,....,CH,EQ,C'...',OR,\n                             ....,....,CH,EQ,C'...')\n            SUM     FIELDS=NONE\n         //SYSPRINT     DD       SYSOUT=*\n         //SORTLIST     DD       SYSOUT=*\n         //SYSOUT       DD       SYSOUT=*\n         //SORTWK01     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))\n         //SORTWK02     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))\n         //SORTWK03     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))\n         //SORTWK04     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))\n         //SORTWK05     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))\n         //SORTWK06     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))\n         //***\n         //***\n         //ADDHDTLR   EXEC     EZTPCG,REGION=2M\n         //INFILE       DD       DISP=SHR,DSN=USERID.INPUT.WOHDRTLR\n         //OUTFILE      DD       DSN=USERID.OUTPUT.WHDRTLR,\n         //             DISP=(NEW,CATLG,DELETE),UNIT=SYSDA,\n         //             SPACE=(CYL,(12,12),RLSE),\n         //             DCB=(RECFM=FB,LRECL=1234)\n         //STEPLIB      DD\n         //             DD       DISP=SHR,DSN=USERID.LOADLIB\n\n\n:HEADER2 JC  ( ? )\n:HEADERT Insert a Job Card at the Top of the File Being Edited\n\n      inserts a job card as shown below with a separator comment\n      line. The job name, the descriptive user information, and\n      the NOTIFY are set to the TSO user ID. The user ID is also\n      placed within the name information.\n\n         //User-ID    JOB      (ACCT-INFO),'User-ID',\n         //             CLASS=2,MSGCLASS=X,NOTIFY=User-ID\n         //***\n\n      No suffix character is generated but the cursor will be\n      positioned there on completion.  A question mark (?) as the\n      only argument causes the internal help to be displayed.\n\n\n:HEADER2 NEATJCL  ( ? )\n:HEADERT Neaten JCL\n\n       will cause JCL within the marked (via C/CC/C##) range of\n       lines to be formatted.  If no range is specified, the\n       entire file is processed.  The block operations, like EXEC\n       or PROC, are placed in column 14, other operations like DD\n       in column 16.  Operands are shifted to column 25 unless\n       there's no operation present, when they're placed in\n       column 16.\n\n       Comments (//*), terminators (/*) and data are left as\n       found.  Where long names are formed of STEP.DDNAME, the\n       column formatting is as close as possible to the standards\n       above.\n\n       For the following file:\n\n          //***  BACKUP INPUT FILE...\n          //IDCAMS EXEC PGM=IDCAMS,REGION=0M\n          //SYSPRINT DD SYSOUT=*\n          //INFILE DD DSN=SOME.INPUT.FILE,DISP=SHR\n          //OUTFILE DD DSN=SOME.OUTPUT.FILE,\n          // DISP=(,CATLG),\n          // UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),\n          // DCB=(RECFM=FB,LRECL=120,BLKSIZE=0)\n          //SYSIN DD *\n          REPRO INFILE(INFILE ) OUTFILE(OUTFILE )\n          //***\n\n       the result of applying NEATJCL would be:\n\n          //*** BACKUP INPUT FILE...\n          //IDCAMS     EXEC     PGM=IDCAMS,REGION=0M\n          //SYSPRINT     DD       SYSOUT=*\n          //INFILE       DD       DSN=SOME.INPUT.FILE,DISP=SHR\n          //OUTFILE      DD       DSN=SOME.OUTPUT.FILE,\n          //             DISP=(,CATLG),\n          //             UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),\n          //             DCB=(RECFM=FB,LRECL=120,BLKSIZE=0)\n          //SYSIN        DD       *\n          REPRO INFILE(INFILE ) OUTFILE(OUTFILE )\n          //***\n\n       While not perfect, it generally provides an instant\n       readability improvement.\n\n\n:HEADER2 SUBCAN  ( ? )\n:HEADERT Submit File and Cancel Edit Session\n\n      will submit the job being edited and cancel the edit.  It\n      saves the pain of an inadvertent save.  If a question mark\n      (?) is specified as the parameter, the built in help is\n      displayed.\n\n\n:HEADER2 SUBO  ( ? )  ( ABEND(COND) )  ( CODE(#) )\n:HEADERT Substitute Date/Time/User Variables and Submit Job\n\n      will temporarily change date, time and/or user tokens as\n      specified below and submit the job. The changes are NOT\n+                                                         ___\n      made to the file - the changes are made dynamically as the\n      file is written to the internal reader.  It is the same as\n      SUBX but with ORIGIN always turned on - please see SUBX\n      below.  It may be used in Edit or View mode, or from DS\n      List or a member list.  The last, a member list in Browse,\n      Edit or View, will not allow any options.  This macro is\n      useful for keeping a master set of JCL that places today's\n      date/time as part of dataset names.  And, if ABEND is\n      specified, generate a step that will force an abnormal\n      termination with a specified user code.\n\n      The variables substituted are shown here with sample\n      examples using a date of 1999/12/31, a time of 12:34:56 and\n      a TSO user ID of YourID.\n\n         &CCYY/MM/DD    <turns into>    1999/12/31\n         &CCYY/DDD      <turns into>    1999/034\n         &CCYYDDD       <turns into>    1999034\n         &CCYYMMDD      <turns into>    19991231\n         &DAYOFWK       <turns into>    FRIDAY\n         &DD/MM/YY      <turns into>    31/12/99\n         &DOW           <turns into>    FRI\n         &HH:MM         <turns into>    12:34\n         &HH:MM:SS      <turns into>    12:34:56\n         &HHMM          <turns into>    1234\n         &HHMMSS        <turns into>    123456\n         &MM/DD/YY      <turns into>    12/31/99\n         &MMDDYY        <turns into>    123199\n         &MON           <turns into>    DEC\n         &MONTH         <turns into>    DECEMBER\n         &USERID        <turns into>    YourID\n         &YEAR          <turns into>    1999\n         &YY/MM/DD      <turns into>    99/12/31\n         &YYDDD         <turns into>    99365\n         &YYMMDD        <turns into>    991231\n\n      ORIGIN, which may be abbreviated as ORG or O, will cause\n      the following JCL to be inserted after the JOB statement\n      (even if the JOB statement extends to 2 or more lines):\n\n      //***\n      //***  SUBMITTED BY YourID ON FRIDAY DECEMBER 31ST, 1999 (DAY 365)\n      //***     AT 12:34:56 FROM SOME.PDS.JCL(MEMNAME)\n      //***\n\n      If ABEND is specified, with or without a parameter, the\n      following JCL is added to the end of the submitted job.\n      The parameter may be used to specify the COND for the step.\n      It defaults to '0,LT'. The specific code to be used in the\n      abend may be specified via CODE(#). The default is 666.\n      Assuming ABEND(8,LT) and CODE(37) were specified, the JCL\n      generated would be:\n\n      //***\n      //ABEND      EXEC     PGM=ABENDX,PARM=0037,COND=(8,LT)\n      //STEPLIB      DD       DISP=SHR,DSN=YOURID.LOADLIB\n      //***\n\n      The ABENDX code is found on the same CBT Tape file as this\n      macro.\n\n      If a question mark (?) is supplied as the only parameter,\n      the built in help is displayed.\n\n      Given the following tokenized JCL:\n\n         //&USERIDG   JOB      (AcctInfo),'&USERID -- BKUPS',\n         //             CLASS=A,MSGCLASS=Y,NOTIFY=&USERID\n         //***\n         //CLEANUP    EXEC     PGM=IEFBR14\n         //DEL01        DD       DSN=&USERID.YR&YEAR.&MON.BKUP\n         //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n         //***\n         //GENER      EXEC     PGM=IEBGENER,REGION=4M\n         //SYSPRINT     DD       SYSOUT=*\n         //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,\n         //             DSN=ARKV.TAMASTER.DATA\n         //SYSUT2       DD       DISP=(,CATLG),\n         //             UNIT=SYSDA,SPACE=(CYL,(05,02),RLSE),\n         //             DCB=(ARKV.TAMASTER.DATA)\n         //             DSN=&USERID.YR&YEAR.&MON.BKUP\n         //SYSIN        DD       DUMMY\n         //***\n\n      the following would be submitted by executing SUBO:\n\n         //USER077G   JOB      (AcctInfo),'USER077 -- BKUPS',\n         //             CLASS=A,MSGCLASS=Y,NOTIFY=USER077\n         //***\n         //CLEANUP    EXEC     PGM=IEFBR14\n         //DEL01        DD       DSN=USER077.YR2002.JUL.BKUP\n         //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n         //***\n         //GENER      EXEC     PGM=IEBGENER,REGION=4M\n         //SYSPRINT     DD       SYSOUT=*\n         //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,\n         //             DSN=ARKV.TAMASTER.DATA\n         //SYSUT2       DD       DISP=(,CATLG),\n         //             UNIT=SYSDA,SPACE=(CYL,(05,02),RLSE),\n         //             DCB=(ARKV.TAMASTER.DATA)\n         //             DSN=USER077.YR2002.JUL.BKUP\n         //SYSIN        DD       DUMMY\n         //***\n\n      Note the year and month portions filled within the new\n      dataset name as well as several user-id uses.\n\n\n:HEADER2 SUBX  ( ? )  ( ABEND(COND) )  ( CODE(#) )  ( ORIGIN )\n:HEADERT Substitute Date/Time/User Variables and Submit Job\n\n      will temporarily change date, time and/or user tokens as\n      specified below and submit the job. The changes are NOT\n+                                                         ___\n      made to the file - the changes are made dynamically as the\n      file is written to the internal reader.  It may be used in\n      Edit or View mode, or from DS List or a member list.  The\n      last, a member list in Browse, Edit or View, will not allow\n      any options.  This macro is useful for keeping a master set\n      of JCL that places today's date/time as part of dataset\n      names.  It will also, if ORIGIN specified, place JCL\n      comment statements just after the job statement providing\n      date and time of submission as well as submitting user and\n      library/file from which the job was submitted.  And, if\n      ABEND is specified, generate a step that will force an\n      abnormal termination with a specified user code.\n\n      The variables substituted are shown here with sample\n      examples using a date of 1999/12/31, a time of 12:34:56 and\n      a TSO user ID of YourID.\n\n         &CCYY/MM/DD    <turns into>    1999/12/31\n         &CCYY/DDD      <turns into>    1999/034\n         &CCYYDDD       <turns into>    1999034\n         &CCYYMMDD      <turns into>    19991231\n         &DAYOFWK       <turns into>    FRIDAY\n         &DD/MM/YY      <turns into>    31/12/99\n         &DOW           <turns into>    FRI\n         &HH:MM         <turns into>    12:34\n         &HH:MM:SS      <turns into>    12:34:56\n         &HHMM          <turns into>    1234\n         &HHMMSS        <turns into>    123456\n         &MM/DD/YY      <turns into>    12/31/99\n         &MMDDYY        <turns into>    123199\n         &MON           <turns into>    DEC\n         &MONTH         <turns into>    DECEMBER\n         &USERID        <turns into>    YourID\n         &YEAR          <turns into>    1999\n         &YY/MM/DD      <turns into>    99/12/31\n         &YYDDD         <turns into>    99365\n         &YYMMDD        <turns into>    991231\n\n      ORIGIN, which may be abbreviated as ORG or O, will cause\n      the following JCL to be inserted after the JOB statement\n      (even if the JOB statement extends to 2 or more lines):\n\n      //***\n      //***  SUBMITTED BY YourID ON FRIDAY DECEMBER 31ST, 1999 (DAY 365)\n      //***     AT 12:34:56 FROM SOME.PDS.JCL(MEMNAME)\n      //***\n\n      If ABEND is specified, with or without a parameter, the\n      following JCL is added to the end of the submitted job.\n      The parameter may be used to specify the COND for the step.\n      It defaults to '0,LT'. The specific code to be used in the\n      abend may be specified via CODE(#). The default is 666.\n      Assuming ABEND(8,LT) and CODE(37) were specified, the JCL\n      generated would be:\n\n      //***\n      //ABEND      EXEC     PGM=ABENDX,PARM=0037,COND=(8,LT)\n      //STEPLIB      DD       DISP=SHR,DSN=YOURID.LOADLIB\n      //***\n\n      The ABENDX code is found on the same CBT Tape file as this\n      macro.\n\n      If a question mark (?) is supplied as the only parameter,\n      the built in help is displayed.\n\n      Given the following tokenized JCL:\n\n         //&USERIDG   JOB      (AcctInfo),'&USERID -- BKUPS',\n         //             CLASS=A,MSGCLASS=Y,NOTIFY=&USERID\n         //***\n         //CLEANUP    EXEC     PGM=IEFBR14\n         //DEL01        DD       DSN=&USERID.YR&YEAR.&MON.BKUP\n         //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n         //***\n         //GENER      EXEC     PGM=IEBGENER,REGION=4M\n         //SYSPRINT     DD       SYSOUT=*\n         //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,\n         //             DSN=ARKV.TAMASTER.DATA\n         //SYSUT2       DD       DISP=(,CATLG),\n         //             UNIT=SYSDA,SPACE=(CYL,(05,02),RLSE),\n         //             DCB=(ARKV.TAMASTER.DATA)\n         //             DSN=&USERID.YR&YEAR.&MON.BKUP\n         //SYSIN        DD       DUMMY\n         //***\n\n      the following would be submitted by executing SUBX:\n\n         //USER077G   JOB      (AcctInfo),'USER077 -- BKUPS',\n         //             CLASS=A,MSGCLASS=Y,NOTIFY=USER077\n         //***\n         //CLEANUP    EXEC     PGM=IEFBR14\n         //DEL01        DD       DSN=USER077.YR2002.JUL.BKUP\n         //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n         //***\n         //GENER      EXEC     PGM=IEBGENER,REGION=4M\n         //SYSPRINT     DD       SYSOUT=*\n         //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,\n         //             DSN=ARKV.TAMASTER.DATA\n         //SYSUT2       DD       DISP=(,CATLG),\n         //             UNIT=SYSDA,SPACE=(CYL,(05,02),RLSE),\n         //             DCB=(ARKV.TAMASTER.DATA)\n         //             DSN=USER077.YR2002.JUL.BKUP\n         //SYSIN        DD       DUMMY\n         //***\n\n      Note the year and month portions filled within the new\n      dataset name as well as several user-id uses.\n\n\n:HEADER1 Format Control Macros\n\n The following macros will justify, format and add data.  C/CC/C#\n range control is used to limit the changes since most usage will\n probably be a single instance.  FLAGREVS will only handle the\n entire file since it uses SuperC compare to determine changes.\n\n Built in help is available by either typing the macro name\n without any parameters or with just a question mark (?) as the\n only operand.\n\n\n:HEADER2 ADDFLAG    FLAG  ( END-COL )\n:HEADERT Place a Flag Value on Selected Lines\n\n       will add a change flag on the lines marked with C/CC/C##\n       or the entire file if no range is specified.  The supplied\n       flag will be right justified to the specified end column.\n       The flag, within quotes if blanks are included, is\n       mandatory but the ending column defaults to 72.  The flag\n       will simply overlay what's in the columns, so doing a FIND\n       on non blanks should be done first (FIND P'\u00ac' ## END-COL)\n       if needed data may be in those columns.\n\n          ADDFLAG  '/*  99-12-31  */'\n\n       Will place /*  99-12-31  */ in columns 57 thru 72 of the\n       specified C range. Note the receiving location does not\n       have to be at the end of the line.\n\n\n:HEADER2 CENTER   ( LEFT-COLUMN  RIGHT-COLUMN )  ( ? )\n:HEADERT Justify Data to Center\n\n       will cause the marked (via C/CC/C##) range of lines to be\n       centered within the BOUNDS then in force unless other\n       columns are specified as parameters.  If no range is\n       specified, the entire file is processed.  The first and\n       the last non-blank characters within the bounds determine\n       the size of the data to be centered. Specifying a left\n       column and right column will cause only the data in those\n       columns to be centered. For example:\n\n          CENTER  11 40\n\n       will cause the data in columns 11 through 40 to be\n       centered within those columns. A parameter of ? causes\n       the built in help to be displayed.\n\n\n:HEADER2 FLAGREVS   REVISION-FLAG  ( REVISION-COL )\n:HEADERT Flag Revisions\n\n       overlays changed records with the REVISION-FLAG.  The\n       revision flag is mandatory. The revision column defaults\n       to 65. All non changed lines will be excluded and one line\n       above and one below will be shown. Non blanks will not be\n       overlaid by the flag.  Only the entire file may be flagged\n+                             ___________________________________\n       since they're generated by comparing the existing file to\n       the data being edited in storage. An example is:\n\n          FLAGREVS  |  2\n\n       will place a vertical bar in column 2 of every line in the\n       file being edited that's different from the original saved\n       file. The entire file will be excluded and the lines with\n       the revision flag added will be included with a line above\n       and below shown to establish context.\n\n       Deleted lines obviously can not be flagged.\n\n\n:HEADER2 LJUST   ( LEFT-COLUMN  RIGHT-COLUMN )  ( ? )\n:HEADERT Justify Data to Left\n\n       will cause the marked (via C/CC/C##) range of lines to be\n       left justified within the BOUNDS then in force or within\n       the columns specified.  If no range is specified, the\n       entire file is processed.  The first and the last non\n       blank characters within the bounds determine the size of\n       the data to be left justified.  Specifying a left column\n       and right column will cause only the data in those columns\n       to be justified. For example:\n\n          LJUST  11 20\n\n       will cause the data in columns 11 through 20 to be left\n       justified within those columns, that is, the first non\n       blank will be placed in column 11, padding on the right\n       with blanks.\n\n\n:HEADER2 RJUST   ( LEFT-COLUMN  RIGHT-COLUMN )  ( ? )\n:HEADERT Justify data to Right\n\n       will cause the marked (via C/CC/C##) range of lines to be\n       right justified within the BOUNDS then in force.  If no\n       range is specified, the entire file is processed.  The\n       first and the last non blank characters within the bounds\n       determine the size of the data to be right justified.\n       This chunk of data is shifted as is.\n\n       Specifying a left column and right column will cause only\n       the data in those columns to be justified. For example:\n\n          RJUST   1 20\n\n       will cause the data in columns 1 through 20 to be right\n       justified within those columns, that is, the last non\n       blank will come to rest in column 20.\n\n\n:HEADER2 SQUSH   ( LEFT-COLUMN  RIGHT-COLUMN ) ( ? )\n:HEADERT Remove Extraneous Blanks From Data\n\n       will cause the marked (via C/CC/C##) range of lines to be\n       left justified within the BOUNDS then in force or within\n       the columns specified and multiple consective blanks\n       changed to one blank.  If no range is specified, the\n       entire file is processed. A question mark will cause the\n       built in help to be displayed.\n\n       For example, given the following somewhat implausable\n       heavily edited text:\n\n          It is further assumed\n          that any associated   supporting element\n          necessitates                  that urgent consideration be\n          applied\n          to the total\n          system rationale.   However, the fully integrated test\n          program\n          must utilize and be       functionally interwoven with the\n          overall\n          negative profitability.\n\n       the result of SQUSH's being issued would be:\n\n          It is further assumed\n          that any associated supporting element\n          necessitates that urgent consideration be applied\n          to the total\n          system rationale. However, the fully integrated test\n          program\n          must utilize and be functionally interwoven with the overall\n          negative profitability.\n\n       A better use would be compressing the blanks out of code\n       or JCL that requires substantial insertions during\n       editing, but, given the above, you could then use text\n       format (TF) on the result of the SQUSH and get decent\n       output.\n\n\n:HEADER1 Inter/Intra Dataset Macros\n\n The macros in this group will acquire one or more lines of data\n through use of the (now) standard system CUT command or the CUTX\n macro provided in this package.  The (now) standard system PASTE\n command and the PA and PY macros may be used to insert the CUT\n lines, or the PASTEX, PASTEAFT and PASTY macros in this pacakge\n may be used to insert the CUTX lines.\n\n The system provided CUT/PASTE commands (and the PA/PY macros)\n will allow use across ISPF applications such as going from\n standard View to SDSF SJ.  Unfortunately, the\n CUTX/PASTEX/PASTEAFT/PASTY macros, while working fine within an\n application such as View to Edit, can't handle the cross\n application connection since they use the PROFILE to store data.\n\n The reason both sets are still provided is that there are folks\n who use the older set and don't want to change.\n\n PASTEAFT and PA allows the pasting of CUTX and CUT data\n respectively after one or more lines in a range. PASTY and PY\n will allow pasting data after the line the cursor is on,\n optimally done with an assigned PFKey.\n\n The CUT and PASTE commands have built in ISPF help that may be\n accessed by pressing <F1> within an Edit session.  The macros in\n this package provide built in help by typing the macro followed\n by a '?', e.g. CUTX ?. XCOPY may simply be typed without any\n parameters to get help.\n\n Please note that the use of CUT and PASTE allows you to use\n+___________\n EDITSET (or EDSET) within Edit or View to set the default\n behaviors for these macros such as whether to replace or append\n data with CUT and to delete or keep data with PASTE. It is\n strongly suggested that they be used.\n\n\n:HEADER2 CUTX   ( A | APPEND )  ( ? )\n:HEADERT Place Lines Into Profile for Pasting\n\n       write lines from a file to the PROFILE pool for later\n       inclusion by the paste macros PASTEX, PASTEAFT and PASTY.\n       Enter CUTX on the COMMAND line and use the C or M line\n       commands (in any form) to select the lines to be cut.  If\n       the M line command is used, the lines will be deleted from\n       the originating file.\n\n       A parameter of A or APPEND can be specified to add to any\n       previously CUTX lines with the newly selected lines.\n       Otherwise, the selected lines will replace any previously\n       CUTX lines. A ? will cause the built in help to display.\n\n\n:HEADER2 PA   ( #-LINES-TO-SKIP )  ( ? )\n:HEADERT Copy Lines From Default Clipcoard Into Multiple Places\n\n       pull lines from the default ISPF clipboard into the\n       current file.  This macro is used in conjunction with the\n       CUT command.  Enter PA on the COMMAND line and use\n       C/CC/C## line commands to specify where the lines are to\n       be inserted.  The data will be copied after each line\n       within the range skipping #-LINES-TO-SKIP lines each copy.\n       #-LINES-TO-SKIP defaults to 1.\n\n       A parameter of a question mark will cause the built in\n       help to be displayed.\n\n       Given you've CUT the following line:\n\n          //            DD        DISP=SHR,DCB=BUFNO=32,\n\n       use 'PA' on the following lines (with the selected\n       range shown by the CC'd lines:\n\n          CC0001 //***\n          000002 //             DSN=SYS6.STKVTS2.BKUP.G0123V00\n          000003 //             DSN=SYS6.STKVTS2.BKUP.G0124V00\n          000004 //             DSN=SYS6.STKVTS2.BKUP.G0125V00\n          000005 //             DSN=SYS6.STKVTS2.BKUP.G0126V00\n          000006 //             DSN=SYS6.STKVTS2.BKUP.G0127V00\n          CC0007 //             DSN=SYS6.STKVTS2.BKUP.G0128V00\n          000008 //             DSN=SYS6.STKVTS2.BKUP.G0129V00\n          000009 //***\n\n       to get:\n\n          000001 //***\n          000002 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000003 //             DSN=SYS6.STKVTS2.BKUP.G0123V00\n          000004 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000005 //             DSN=SYS6.STKVTS2.BKUP.G0124V00\n          000006 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000007 //             DSN=SYS6.STKVTS2.BKUP.G0125V00\n          000008 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000009 //             DSN=SYS6.STKVTS2.BKUP.G0126V00\n          000010 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000011 //             DSN=SYS6.STKVTS2.BKUP.G0127V00\n          000012 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000013 //             DSN=SYS6.STKVTS2.BKUP.G0128V00\n          000014 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000015 //             DSN=SYS6.STKVTS2.BKUP.G0129V00\n          000016 //***\n\n       Note in the above how the CC's lines are chosen to add\n       lines and skip appropriately.\n\n\n:HEADER2 PASTEAFT   ( D | DELETE )  ( #-LINES-TO-SKIP )  ( ? )\n:HEADERT Copy Lines From Profile Into Multiple Places\n\n       pull lines from the user PROFILE pool into the current\n       file.  This macro is used in conjunction with the CUTX\n       macro.  Enter PASTEAFT on the COMMAND line and use\n       C/CC/C## line commands to specify where the lines are to\n       be pasted.  The pasted data will be copied after each line\n       within the range skipping #-LINES-TO-SKIP lines each copy\n       with #-LINES-TO-SKIP defaulting to 1.\n\n       A parameter of D or DELETE can be specified to cause the\n       macro to set the profile variables to null after the lines\n       have been pasted into the file.  The order of the operands\n       or absence of either is not material.\n\n       A parameter of a question mark will cause the built in\n       help to be displayed.\n\n       Given you've CUTX'd the following line:\n\n          //            DD        DISP=SHR,DCB=BUFNO=32,\n\n       use 'PASTEAFT' on the following lines (with the selected\n       range shown by the CC'd lines:\n\n          CC0001 //***\n          000002 //             DSN=SYS6.STKVTS2.BKUP.G0123V00\n          000003 //             DSN=SYS6.STKVTS2.BKUP.G0124V00\n          000004 //             DSN=SYS6.STKVTS2.BKUP.G0125V00\n          000005 //             DSN=SYS6.STKVTS2.BKUP.G0126V00\n          000006 //             DSN=SYS6.STKVTS2.BKUP.G0127V00\n          CC0007 //             DSN=SYS6.STKVTS2.BKUP.G0128V00\n          000008 //             DSN=SYS6.STKVTS2.BKUP.G0129V00\n          000009 //***\n\n       to get:\n\n          000001 //***\n          000002 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000003 //             DSN=SYS6.STKVTS2.BKUP.G0123V00\n          000004 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000005 //             DSN=SYS6.STKVTS2.BKUP.G0124V00\n          000006 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000007 //             DSN=SYS6.STKVTS2.BKUP.G0125V00\n          000008 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000009 //             DSN=SYS6.STKVTS2.BKUP.G0126V00\n          000010 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000011 //             DSN=SYS6.STKVTS2.BKUP.G0127V00\n          000012 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000013 //             DSN=SYS6.STKVTS2.BKUP.G0128V00\n          000014 //            DD        DISP=SHR,DCB=BUFNO=32,\n          000015 //             DSN=SYS6.STKVTS2.BKUP.G0129V00\n          000016 //***\n\n       Note in the above how the pasted lines follow the CC'd\n       lines and skip appropriately.\n\n\n:HEADER2 PASTEX   ( D | DELETE )  ( ? )\n:HEADERT Copy Lines From Profile\n\n       pull lines from the user profile into the current file.\n       This macro is used in conjunction with the CUTX macro.\n       Enter PASTEX on the COMMAND line and use the A or B line\n       command to specify where the lines are to be pasted.\n\n       An option of D or DELETE can be specified to cause the\n       macro to erase the cut profile variables after the lines\n       have been pasted into the file.  A parameter of a question\n       mark will cause the built in help to be displayed.\n\n       See PASTY below for a PF Key driven paste at the cursor\n       position and PASTEAFT above for pasting after multiple\n       lines.\n\n\n:HEADER2 PY  ( ? )\n:HEADERT Copy Lines From Default Clipboard by Cursor Position\n\n       pull lines from the default ISPF clipboard into the\n       current file after where the cursor is positioned.  This\n       macro is used in conjunction with the CUT command.  Enter\n       PY on the command line and position the cursor on the line\n       after which the cut lines are to be inserted.  The command\n       is best used when assigned to a PF key (e.g.  use KEYS\n       under Edit to assign %PY to PF16 as shown in the sample\n       key set above).  It never removes the cut lines from the\n       clipboard, and is intended to allow easy, repeatable\n       insertions of the same data multiple times, and across\n       multiple files and applications.\n\n       If the cursor is above the top data line showing on the\n       screen, the data will be pasted after that data line.\n       This uses the ZScreenC and ZScreenI variables which may\n       not be available in all ISPF releases.\n\n\n:HEADER2 PASTY  ( ? )\n:HEADERT Copy Lines From Profile by Cursor Position\n\n       pull lines from the user PROFILE pool into the current\n       file after where the cursor is positioned.  This macro is\n       used in conjunction with the CUTX macro.  Enter PASTY on\n       the COMMAND line and position the cursor on the line after\n       which the cut lines are to be inserted.  The command is\n       best used when assigned to a PF key (e.g.  use KEYS under\n       Edit to assign %PASTY to PF16 as shown in the sample key\n       set above).  It obviously never removes the cut lines from\n       the profile, and is intended to allow easy, repeatable\n       insertions of the same data multiple times and across\n       multiple files.\n\n       If the cursor is above the top data line showing on the\n       screen, the data will be pasted after that data line.\n       This uses the ZScreenC and ZScreenI variables which may\n       not be available in all ISPF releases.\n\n\n:HEADER2 VERASE\n:HEADERT Clear Profile Pool CUTX Entries & Zero CutCnt\n\n       clears the lines cut via CUTX and resets the counter\n       normally maintained. Useful when the system returns an\n       oddball message saying the profile is full.\n\n\n:HEADER2 XCOPY   DATA-SOURCE  ( FROM-REC# ( TO-REC# ) )\n:HEADERT Retrieve Data Into File From Command Line\n\n       copy a dataset or member directly into the file being\n       edited without going through the COPY screens.  The data\n       source is mandatory. A destination (either an 'A' or 'B'\n       in the prefix area) may be specified; if neither is\n       specified, the data is copied to the front of the edited\n       file. For example,\n\n          XCOPY 'SYS1.MACLIB(GET)'\n\n       will retrieve the GET macro into the currently edited\n       file.\n\n       The starting record and the ending record of the input may\n       be specified. If not, they default to the first and last.\n       If only the starting number is specified, the copy will\n       proceed through the end of the input file.  For example,\n\n          XCOPY  DATAFILE  45\n\n       will copy the 45th record through the end of your user\n       ID's DATAFILE.\n\n       The number of lines inserted is shown in the upper right\n       corner of the screen.\n\n       The current ISPF COPY facility provides the same\n       functionality with the exception of\n       specifying specific records.\n\n:HEADER1 DSList Macros\n\n These macros are executed under option 3.4, the DataSet List,\n just like specifying a \"B\" to browse the file. They will count\n the number of records, show the longest and shortest lengths,\n perform a scan of a PDS to find a string, show the last\n referenced date without causing it to change, and create a copy\n of an existing sequential or partitioned data set copying the\n associated data or not.\n\n Built in help is available by either typing the macro name\n without any parameters or with just a question mark (?) as the\n only operand.\n\n\n:HEADER2 CLONE  NEWDSN  ( # | +# | -# )  ( EMPTY )  ( RELEASE ) ( Q# )\n:HEADERT Duplicate Sequential or Partitioned Data Set\n\n       creates a new data set with the same attributes as the one\n       overtyped. Sequential, partitioned data sets extended\n       (PDSE's) or partitioned data sets (PDS's) may be\n       duplicated. NEWDSN may be fully qualified with quotes,\n       e.g.  'SYS4.MACLIB', or allowed to take on the user\n       prefix, e.g. TEST.DATA. Please note you must have\n       sufficient access authority to create a dataset under\n       whatever security system is in use.\n\n       The original name may be used as a prefix by typing an\n       equal sign (=) followed by the intended suffix in place of\n       NEWDSN.  Overtyping SYS4.MACLIB with =.BKUP will produce a\n       new data set named SYS4.MACLIB.BKUP; the new data set name\n       must not exist and should be a legitimate name for the\n       invoking user to create.\n\n       The original data set may be used as a suffix by typing\n       the intended prefix followed by an equal sign (=).\n+                          ___________\n       Overtyping SYS4.MACLIB with YOURUID.= will create a new\n       data set named YOURID.SYS4.MACLIB.\n\n       Using either the above mentioned prefixing or suffixing\n       options will always cause the resultant new data set name\n       to be fully qualified, i.e. as if it were input within\n       quotes. Use a blank following the new data set choice if\n       there is any doubt about how it will be \"seen\" by the\n       system.\n\n       An option of Q# will reduce the initial qualifiers of the\n       original data set by # for prefixed XXX= or the final\n       qualifiers for suffixed =XXX new data set names.  Given\n       the preceding example, a Q1 will cause YOURUID.MACLIB to\n       be created.\n\n       Optionally, EMPTY may be specified with the new name to\n       not cause data to be copied.\n\n       Optionally, RELEASE may be specified to release unused\n       space following copying data (useful for back up\n       versions).\n\n       You may also specify a change to directory blocks; for\n       partitioned data sets only, a new number or an\n       increment/decrement may be specified (no sign means\n       replace, a '+' causes that number to be added and a '-' to\n       be subtracted).  The new number may not be below the\n       currently used directory size when causing data to be\n       copied.\n\n       So, if SYS1.MACLIB is the data set shown in the data set\n       list, entering the command over ot of\n\n          CLONE  +17  RUBBER.DUCKY  EMPTY\n\n       will create a new PDS under your ID (assuming your prefix\n       is the default) with the name RUBBER.DUCKY with no members\n+                                                 _______________\n       and with 17 more directory blocks then the original.\n\n       For sequential data sets, specifying a number or a number\n+          __________\n       prefixed by a plus(+) or minus(-) will cause a change to\n       the logical record length. An unsigned number will cause\n       the resultant data set to have that number as its LRECL. A\n       plus value, +#, will cause # to be added to the LRECL; a\n       minus value, -#, will cause that # to be subtracted from\n       the LRECL. If the new record length is greater then the\n       old, blanks will be used to pad on the right. Variable\n       lengths are the LRECL, so for a maximum 1,000 bytes of\n       data, specify 1004.\n\n       If the following were overtyped on SYS1.MACLIB\n\n          CLONE  'SYS2.MACLIB'\n\n       a new PDS named SYS2.MACLIB would be created and all the\n       SYS1.MACLIB members copied to it.\n\n       Entering\n\n          CLONE  +90  =X\n\n       on SYS1.MACLIB, a new PDS named SYS1.MACLIBX would be\n       created with 90 more directory blocks then the current\n       allocation of SYS1.MACLIB and all the SYS1.MACLIB members\n       copied to it.\n\n       Entering an equal sign on subsequent data set lines under\n       DS List would cause the same command to be executed\n       against them. This is useful if you want to create back up\n       versions by date, e.g. CLONE =.D991231.\n\n\n:HEADER2 CLONER  NEWDSN  ( # | +# | -# )  ( EMPTY )  ( RELEASE ) ( Q# )\n:HEADERT Copy/Replace Sequential or Partitioned Data Set\n\n       creates a new data set with the same attributes as the one\n       overtyped, deleting the data set if it exists.\n       Sequential, partitioned data sets extended (PDSE's) or\n       partitioned data sets (PDS's) may be duplicated. NEWDSN\n       may be fully qualified with quotes, e.g.  'SYS4.MACLIB',\n       or allowed to take on the user prefix, e.g.  TEST.DATA.\n       Please note you must have sufficient access authority to\n       create a dataset under whatever security system is in use.\n\n       The original name may be used as a prefix by typing an\n       equal sign (=) followed by the intended suffix in place of\n       NEWDSN.  Overtyping SYS4.MACLIB with =.BKUP will produce a\n       new data set named SYS4.MACLIB.BKUP; the new data set name\n       may exist, but will be deleted if so, and should be a\n       legitimate name for the invoking user to create.\n\n       The original data set may be used as a suffix by typing\n       the intended prefix followed by an equal sign (=).\n+                          ___________\n       Overtyping SYS4.MACLIB with YOURUID.= will create a new\n       data set named YOURID.SYS4.MACLIB.\n\n       Using either the above mentioned prefixing or suffixing\n       options will always cause the resultant new data set name\n       to be fully qualified, i.e. as if it were input within\n       quotes. Use a blank following the new data set choice if\n       there is any doubt about how it will be \"seen\" by the\n       system.\n\n       An option of Q# will reduce the initial qualifiers of the\n       original data set by # for prefixed XXX= or the final\n       qualifiers for suffixed =XXX new data set names.  Given\n       the preceding example, a Q1 will cause YOURUID.MACLIB to\n       be created.\n\n       Optionally, EMPTY may be specified with the new name to\n       not cause data to be copied.\n\n       Optionally, RELEASE may be specified to release unused\n       space following copying data (useful for back up\n       versions).\n\n       You may also specify a change to directory blocks; for\n       partitioned data sets only, a new number or an\n       increment/decrement may be specified (no sign means\n       replace, a '+' causes that number to be added and a '-' to\n       be subtracted).  The new number may not be below the\n       currently used directory size when causing data to be\n       copied.\n\n       So, if SYS1.MACLIB is the data set shown in the data set\n       list, entering the command over ot of\n\n          CLONER  +17  RUBBER.DUCKY  EMPTY\n\n       will create a new PDS under your ID (assuming your prefix\n       is the default) with the name RUBBER.DUCKY with no members\n+                                                 _______________\n       and with 17 more directory blocks then the original,.\n       replacing RUBBER.DUCKY if it exists.\n\n       For sequential data sets, specifying a number or a number\n+          __________\n       prefixed by a plus(+) or minus(-) will cause a change to\n       the logical record length. An unsigned number will cause\n       the resultant data set to have that number as its LRECL. A\n       plus value, +#, will cause # to be added to the LRECL; a\n       minus value, -#, will cause that # to be subtracted from\n       the LRECL. If the new record length is greater then the\n       old, blanks will be used to pad on the right.\n\n       If the following were overtyped on SYS1.MACLIB\n\n          CLONER  'SYS2.MACLIB'\n\n       a new PDS named SYS2.MACLIB would be created and all the\n       SYS1.MACLIB members copied to it.\n\n       Entering\n\n          CLONER  +90  =X\n\n       on SYS1.MACLIB, a new PDS named SYS1.MACLIBX would be\n       created with 90 more directory blocks then the current\n       allocation of SYS1.MACLIB and all the SYS1.MACLIB members\n       copied to it.\n\n       Entering an equal sign on subsequent data set lines under\n       DS List would cause the same command to be executed\n       against them.  This is useful if you want to recreate back\n       up versions by date, e.g. CLONER =.D991231.\n\n\n:HEADER2 COUNTX  ( ? )\n:HEADERT Provide Count of Records in File\n\n       will cause a message to be written as:\n\n          '-the-dataset-name-' (FBA /  133/27930)      3,225,818\n\n       with the record format, logical record length and block\n       size as well as the number of records for sequential\n       datasets. For VSAM ESDS's or KSDS's, it will only show:\n\n          '-the-dataset-name-'                           123,456\n\n       Subsequent files may be indicated using the equal sign as\n       in normal DS List usage. If a question mark immediately\n       follows the COUNTX, built in help will be displayed.\n\n\n:HEADER2 DELCOLS   LEFT-COL1 RIGHT-COL1 (...)\n:HEADERT Delete Columns\n\n       will remove the specified columns, shifting the remaining\n       leftwards, as in\n\n          DELCOLS  11  20\n\n       deleting column 11 through 20 and shifting everything from\n       column 21 to the end of each record left 10 columns.\n       DELCOLS may be used as a large scale truncating left\n       shift, that is,\n\n          DELCOLS  1  20\n\n       will cause all data to be shifted 20 positions to the\n       left.\n\n       DELCOLS is the reverse of KEEPCOLS, removing rather then\n       keeping data.  Given the following data:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       the results of 'DELCOLS  11 20  31 40' would be:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAACCCCCCCCCCEEEEEEEEEE\n          AAAAAAAAAACCCCCCCCCCEEEEEEEEEE\n          AAAAAAAAAACCCCCCCCCCEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       This macro is intended to be used from DS List when the\n       data set is too large to be edited.  Once the data set has\n       been \"reduced,\" CLONE may be used to recreate it with its\n       new size.\n\n\n:HEADER2 EMPTY  ( ? )\n:HEADERT Null Sequential or Partitioned Data Set\n\n       removes all data from sequential or partitioned data sets\n       (PDS's or PDSE's).  It will open and immediately close a\n       sequential file, thereby writing only an end of file\n       indicator. It will allocate a new PDS identical to the\n       original for partitioned data sets and then delete the\n       original and rename the new one to the original name.\n\n       It will display the name(s) of the data set(s) emptied.\n       If the question mark parameter is specified, the built in\n       help will be displayed but no data deleted.\n\n\n:HEADER2 FINDNSTR   STRING   ( ? )\n:HEADERT Scan a PDS For Members Without a Given String\n\n       will cause a SuperC PDS scan to be invoked for the\n       specified string against the PDS(E) and the resultant scan\n       opened in Browse.  showing which members did not contain\n+                                                   ___\n       the string.  If it's not found at all, a simple message\n       indicates that.\n\n       The string may be specified by simply typing it without\n       quotes.  For example:\n\n          FINDNSTR  REXX\n\n       with 'REXX' overtyping the dataset name.  The results will\n       be placed in the default dataset from the Search-For\n       Utility option or SRCHFOR.LIST under the current user's ID\n       as well as opened in Browse mode.\n\n       If there's any doubt about how the string will be\n       recognized by DS List, simply place it in single quotes,\n       e.g.\n\n          FINDNSTR  'TRANSLATE('\n\n       An ampersand, &, must be doubled, i.e. && specified.\n\n       Both the string sought and the file name will be\n       displayed.  If a question mark (?) is specified or no\n       string at all, help will be shown. To search for a single\n       question mark, place it within quotes. For example,\n       'FINDNSTR  REXX' might generate (if looking for non REXX\n       executables):\n\n          MEMBER-SEARCHED         LINES-FOUND   LINES-PROC\n\n          FAND                            0          203\n          FNOT                            0          207\n          FOR                             0          203\n\n          ...\n\n          LINES-FOUND  LINES-PROC  MEMBERS-W/LNS  MEMBERS-WO/LNS\n                206        20476          136              3\n\n       The above shows that the 3 members listed did NOT contain\n       the string REXX.\n\n\n:HEADER2 FINDSTRX   STRING   ( ? )\n:HEADERT Scan a PDS For a Given String\n\n       will cause a PDS(E) scan to be invoked for the specified\n       string and the resultant scan opened in browse if any\n       instances are found (a message will indicate none were\n       found if so).  The string may be specified by simply\n       typing it without quotes.  For example:\n\n          FINDSTRX SOME DUMB STRING\n\n       with 'SOME DUMB STRING' overtyping the dataset name.  The\n       results will be placed in the default dataset from the\n       Search-For Utility option or SRCHFOR.LIST under the\n       current user's ID as well as opened in Browse mode.\n\n       If there's any doubt about how the string will be\n       recognized by DS List, simply place it in single quotes,\n       e.g.\n\n          FINDSTRX  'TRANSLATE('\n\n       Both the string sought and the file name will be\n       displayed.  If a question mark (?) is specified\n       or no string at all, help will be shown. To\n       search for a single question mark, place it\n       within quotes.\n\n       The Browse will show the member name(s) where the string\n       was found as well as the individual lines where it was\n       found.\n\n       Please see the FS macro below which will submit the\n       equivalent scan of a PDS(E) as a regular job.\n\n\n:HEADER2 HOWLONG  ( ? )\n:HEADERT Show Longest and Shortest Lengths\n\n       for variable length data sets, HOWLONG will cause a\n       message to be written as:\n\n          '-the-dataset-name-' - LONGEST/SHORTEST IS 860/204\n\n       The lengths do not include the 4 byte length field nor the\n       4 byte block length field for variable (RECFM=V) files.\n       Note that the actual record length is often far larger\n       then the longest record on the file.\n\n       For a fixed record format file,a message such as:\n\n          '-the-dataset-name-' - LONGEST/SHORTEST IS 80/0\n            ----- BASED ON BLANKS AT END OF RECORDS (FIXED DATA SET)\n\n       will be produced. The macro counts the number of blanks\n       at the end of each line and considers the longest record\n       to be the one with the least number of blanks and the\n       shortest to be the one with the most number of blanks.\n       Assuming the '-the-dataset-name-' was an 80 byte file,\n       the 80/0 indicates that some record(s) had all 80 bytes\n       filled and some were all blank.\n\n       Subsequent files may be indicated using the equal sign as\n       in normal DS List usage.  A question mark as the only\n       parameter will cause the built in help to be displayed.\n\n\n:HEADER2 KEEPCOLS  LEFT-COL1 RIGHT-COL1 (...)\n:HEADERT Retain Columns Deleting All Other Columns\n\n       will keep the specified columns, shifting them to the\n       left, as running the following against a 200 file:\n\n          KEEPCOLS  11 20  101 103  141 142\n\n       effectively deletes columns 1 through 10, 21 through 100,\n       104 through 140 and 143 through 200.  The selected columns\n       will be in the left-most 15 columns and the other 185\n       columns will be blank.\n\n       Given the following data:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE\n          ----+----1----+----2----+----3----+----4----+----5\n\n       the results of 'KEEPCOLS  11 20' would be:\n\n          ----+----1----+----2----+----3----+----4----+----5\n          bbbbbbbbbb\n          bbbbbbbbbb\n          bbbbbbbbbb\n          ----+----1----+----2----+----3----+----4----+----5\n\n       KEEPCOLS is also documented under Column Manipulation\n       macros since it can be invoked in Edit/View. Please see\n       CLONE to see how to copy a data set changed by KEEPCOLS to\n       a smaller version quickly.\n\n\n:HEADER2 LASTREF\n:HEADERT Display Last Reference Date under DS List\n\n       will cause a message to be written as:\n\n          FILE -the-dataset-name- WAS LAST REFERENCED 1999/11/12\n\n       This will not cause the date to be updated.  Subsequent\n       files may be indicated using the equal sign as in normal\n       3.4 usage.\n\n\n:HEADER2 QCLONE  NEWDSN  ( # | +# | -# )  ( EMPTY )  ( RELEASE ) ( Q# )\n:HEADERT Duplicate Sequential or Partitioned Data Set via Job\n\n       will submit a job to create a new data set with the same\n       attributes as the one overtyped.  If the EMPTY option is\n       specified, the allocation will be done immediately in the\n       EXEC.  Sequential, partitioned data sets extended (PDSE's)\n       or partitioned data sets (PDS's) may be duplicated. NEWDSN\n       may be fully qualified with quotes, e.g.  'SYS4.MACLIB',\n       or allowed to take on the user prefix, e.g.  TEST.DATA.\n       Please note you must have sufficient access authority to\n       create a dataset under whatever security system is in use.\n       This is essentially the same as CLONE except that the copy\n       is done in batch.\n\n       The original name may be used as a prefix by typing an\n       equal sign (=) followed by the intended suffix in place of\n       NEWDSN.  Overtyping SYS4.MACLIB with =.BKUP will produce a\n       new data set named SYS4.MACLIB.BKUP; the new data set name\n       must not exist and should be a legitimate name for the\n       invoking user to create.\n\n       The original data set may be used as a suffix by typing\n       the intended prefix followed by an equal sign (=).\n+                          ___________\n       Overtyping SYS4.MACLIB with YOURUID.= will create a new\n       data set named YOURID.SYS4.MACLIB.\n\n       Using either the above mentioned prefixing or suffixing\n       options will always cause the resultant new data set name\n       to be fully qualified, i.e. as if it were input within\n       quotes. Use a blank following the new data set choice if\n       there is any doubt about how it will be \"seen\" by the\n       system.\n\n       An option of Q# will reduce the initial qualifiers of the\n       original data set by # for prefixed XXX= or the final\n       qualifiers for suffixed =XXX new data set names.  Given\n       the preceding example, a Q1 will cause YOURUID.MACLIB to\n       be created.\n\n       Optionally, EMPTY may be specified with the new name to\n       not cause data to be copied (this is done in the TSO\n       session since it is only an allocate).\n\n       Optionally, RELEASE may be specified to release unused\n       space following copying data (useful for back up\n       versions).\n\n       You may also specify a change to directory blocks; for\n       partitioned data sets only, a new number or an\n       increment/decrement may be specified (no sign means\n       replace, a '+' causes that number to be added and a '-' to\n       be subtracted).  The new number may not be below the\n       currently used directory size when causing data to be\n       copied.\n\n       So, if SYS1.MACLIB is the data set shown in the data set\n       list, entering the command over ot of\n\n         QCLONE  +17  RUBBER.DUCKY  EMPTY\n\n       will create a new PDS under your ID (assuming your prefix\n       is the default) with the name RUBBER.DUCKY with no members\n+                                                 _______________\n       and with 17 more directory blocks then the original.\n\n       For sequential data sets, specifying a number or a number\n+          __________\n       prefixed by a plus(+) or minus(-) will cause a change to\n       the logical record length. An unsigned number will cause\n       the resultant data set to have that number as its LRECL. A\n       plus value, +#, will cause # to be added to the LRECL; a\n       minus value, -#, will cause that # to be subtracted from\n       the LRECL. If the new record length is greater then the\n       old, blanks will be used to pad on the right. Variable\n       lengths are the LRECL, so for a maximum 1,000 bytes of\n       data, specify 1004.\n\n       If the following were overtyped on SYS1.MACLIB\n\n         QCLONE  'SYS2.MACLIB'\n\n       a new PDS named SYS2.MACLIB would be created and all the\n       SYS1.MACLIB members copied to it.\n\n       Entering\n\n         QCLONE  +90  =X\n\n       on SYS1.MACLIB, a new PDS named SYS1.MACLIBX would be\n       created with 90 more directory blocks then the current\n       allocation of SYS1.MACLIB and all the SYS1.MACLIB members\n       copied to it.\n\n       Entering an equal sign on subsequent data set lines under\n       DS List would cause the same command to be executed\n       against them. This is useful if you want to create back up\n       versions by date, e.g. CLONE =.D991231.\n\n\n:HEADER2 QCLONER  NEWDSN  ( # | +# | -# )  ( EMPTY )  ( RELEASE ) ( Q# )\n:HEADERT Copy/Replace Sequential or Partitioned Data Set via Job\n\n       will submit a job to create a new data set with the same\n       attributes as the one overtyped, deleting the NEWDSN if it\n       exists.  If the EMPTY option is specified, the allocation\n       will be done immediately in the EXEC.  Sequential,\n       partitioned data sets extended (PDSE's) or partitioned\n       data sets (PDS's) may be duplicated. NEWDSN may be fully\n       qualified with quotes, e.g.  'SYS4.MACLIB', or allowed to\n       take on the user prefix, e.g.  TEST.DATA.  Please note you\n       must have sufficient access authority to create a dataset\n       under whatever security system is in use.  This is\n       essentially the same as CLONER except that the copy is done\n       in batch.\n\n       The original name may be used as a prefix by typing an\n       equal sign (=) followed by the intended suffix in place of\n       NEWDSN.  Overtyping SYS4.MACLIB with =.BKUP will produce a\n       new data set named SYS4.MACLIB.BKUP; the new data set name\n       must not exist and should be a legitimate name for the\n       invoking user to create.\n\n       The original data set may be used as a suffix by typing\n       the intended prefix followed by an equal sign (=).\n+                          ___________\n       Overtyping SYS4.MACLIB with YOURUID.= will create a new\n       data set named YOURID.SYS4.MACLIB.\n\n       Using either the above mentioned prefixing or suffixing\n       options will always cause the resultant new data set name\n       to be fully qualified, i.e. as if it were input within\n       quotes. Use a blank following the new data set choice if\n       there is any doubt about how it will be \"seen\" by the\n       system.\n\n       An option of Q# will reduce the initial qualifiers of the\n       original data set by # for prefixed XXX= or the final\n       qualifiers for suffixed =XXX new data set names.  Given\n       the preceding example, a Q1 will cause YOURUID.MACLIB to\n       be created.\n\n       Optionally, EMPTY may be specified with the new name to\n       not cause data to be copied (this is done in the TSO\n       session since it is only an allocate).\n\n       Optionally, RELEASE may be specified to release unused\n       space following copying data (useful for back up\n       versions).\n\n       You may also specify a change to directory blocks; for\n       partitioned data sets only, a new number or an\n       increment/decrement may be specified (no sign means\n       replace, a '+' causes that number to be added and a '-' to\n       be subtracted).  The new number may not be below the\n       currently used directory size when causing data to be\n       copied.\n\n       So, if SYS1.MACLIB is the data set shown in the data set\n       list, entering the command over ot of\n\n         QCLONER  +17  RUBBER.DUCKY  EMPTY\n\n       will create a new PDS under your ID (assuming your prefix\n       is the default) with the name RUBBER.DUCKY with no members\n+                                                 _______________\n       and with 17 more directory blocks then the original.\n\n       For sequential data sets, specifying a number or a number\n+          __________\n       prefixed by a plus(+) or minus(-) will cause a change to\n       the logical record length. An unsigned number will cause\n       the resultant data set to have that number as its LRECL. A\n       plus value, +#, will cause # to be added to the LRECL; a\n       minus value, -#, will cause that # to be subtracted from\n       the LRECL. If the new record length is greater then the\n       old, blanks will be used to pad on the right. Variable\n       lengths are the LRECL, so for a maximum 1,000 bytes of\n       data, specify 1004.\n\n       If the following were overtyped on SYS1.MACLIB\n\n         QCLONER  'SYS2.MACLIB'\n\n       a new PDS named SYS2.MACLIB would be created and all the\n       SYS1.MACLIB members copied to it.\n\n       Entering\n\n         QCLONER  +90  =X\n\n       on SYS1.MACLIB, a new PDS named SYS1.MACLIBX would be\n       created with 90 more directory blocks then the current\n       allocation of SYS1.MACLIB and all the SYS1.MACLIB members\n       copied to it.\n\n       Entering an equal sign on subsequent data set lines under\n       DS List would cause the same command to be executed\n       against them. This is useful if you want to create back up\n       versions by date, e.g. CLONE =.D991231.\n\n\n:HEADER1 Member List Macros\n\n The following macros may be entered on any Browse, Edit or\n View member list.\n\n\n:HEADER2 LKDT LoadLib(Member)  ( ? )\n:HEADERT Display When a Load Module Was Linked\n\n      displays the date and time a load module was link edited.\n      This depends on the AMBLIST LISTIDR function and will fail,\n      providing an error message, if the module's IDR is\n      corrupted or non-existent.  It may be invoked by direct\n      call, e.g.\n\n         TSO LKDT 'SYS1.LINKLIB(IEHPROGM)'\n\n      or by entering it on a member list under Browse, Edit or\n      View, e.g.\n\n         BROWSE            USERID.X.LOADLIB\n         Command ===>\n                    Name     Prompt        Alias-of     Size      TTR\n         _________ ABENDX                             00000278   001E23\n         lkdt_____ ADDCC                              008AF378   002109\n         _________ ALIAS                              00000498   00012E\n\n      which might result in the following being displayed:\n\n         ADDCC in 'USERID.X.LOADLIB' was linked\n             Friday May 23rd, 2003 (day 143)\n\n      A ? as the only argument causes the internal help to be\n      displayed. Obviously, this macro applies only to load\n      modules. As for other member commands, equal signs (=) may\n      be used to repeat the command against other members.\n\n      LKDT might fail if no IDR data is found; an appropriate\n      message is displayed.\n\n\n:HEADER2 TD\n:HEADERT Display and Remove Member Statistics\n\n      displays the statistics associated with a member and, if\n      not cancelled, will remove the statistics from that member.\n      It is invoked by entering it on a member list under Browse,\n      Edit or View, e.g.\n\n         VIEW              USERX.CLIST\n         Command ===>\n                    Name     Prompt       Size   Created\n         td_______ ADDLINEB                  4  2002/09/14  2002/...\n         _________ ADDLINES                 90  2002/09/14  2002/...\n         _________ ALIGN                    68  2002/09/14  2002/...\n\n      which might result in the following being displayed:\n\n            -- PDS Statistics Display/Delete                   --\n\n          PDS:  USERX.CLIST\n          MEM:  ADDLINEB\n\n          Version:     12\n          Mod Count:   00\n          Create Dt:   02/09/14\n          Change Dt:   02/09/14\n          Change Tm:   07:56\n          Initial Sz:  4\n          Current Sz:  4\n          UserID:      USERX\n\n            -- Press <ENTER> to delete or <PF3> (END) to Quit  --\n\n      which, if <Enter> is pressed, will result in the member's\n      statistics being removed. Please see TU below to change or\n      update statistics.\n\n\n:HEADER2 TU\n:HEADERT Display and Update Member Statistics\n\n      displays the statistics associated with a member and, if\n      not cancelled, will update the statistics for that member.\n      It is invoked by entering it on a member list under Browse,\n      Edit or View, e.g.\n\n         VIEW              USERX.CLIST\n         Command ===>\n                    Name     Prompt       Size   Created\n         tu_______ ADDLINEB                  4  2002/09/14  2002/...\n         _________ ADDLINES                 90  2002/09/14  2002/...\n         _________ ALIGN                    68  2002/09/14  2002/...\n\n      which might result in the following being displayed:\n\n            -- PDS Statistics Display/Update                   --\n\n          PDS:  USERX.CLIST\n          MEM:  ADDLINEB\n\n          Version:     12\n          Mod Count:   00\n          Create Dt:   02/09/14\n          Change Dt:   02/09/14\n          Change Tm:   07:56\n          Initial Sz:  4\n          Current Sz:  4\n          UserID:      USERX\n\n            -- Press <ENTER> to update or <PF3> (END) to Quit  --\n\n      which, if any statistics are changed and <Enter> is\n      pressed, will result in the member's statistics being\n      updated. Please see TD above to remove statistics. If there\n      were no statistics and only some are entered, ISPF will\n      enter reasonable default values.\n\n\n:HEADER1 Miscellaneous Macros\n\n The following macros are not easily classifiable. Against that,\n they are often useful.\n\n Built in help is available by either typing the macro name\n without any parameters or with just a question mark (?) as the\n only operand.\n\n\n:HEADER2 ADDLINES   MEMBER  ( LOCATION )  ( PREFIX )\n:HEADERT Copy a Member Before/After All Other Members\n\n       will copy a member of a PDS being edited before or after\n       every other member in that PDS except the copied member.\n       MEMBER is the data member to be copied. LOCATION must be\n       either BEFORE or AFTER (BEFORE is the default). PREFIX may\n       be used to limit the members changed to only those that\n       begin with the specified prefix.  For example,\n\n          ADDLINES  JOBCARD  BEFORE  JCL\n\n       will copy the member named JOBCARD to the beginning of\n       every member with the prefix JCL.\n\n       Two associated macros are ADDLINEA and ADDLINEB, used\n       to do the copy after and copy before, respectively.\n\n\n:HEADER2 ALLMEM   MACRO  ( PREFIX )\n:HEADERT Execute a Macro Against All Members\n\n       will execute a macro against every member of a PDS being\n       edited (edit any member and then invoke ALLMEM).  MACRO is\n       the macro code to be executed.  PREFIX is optional and may\n       be used to limit the members processed to only those that\n       begin with the specified prefix.  For example,\n\n          ALLMEM  ALLMEMC\n\n       will execute the macro ALLMEMC against every member of the\n       PDS.  The macro might look like:\n\n          /*** REXX  --  CHANGE STRINGS  --  USE WITH ALLMEM  ***/\n             \"ISREDIT MACRO\"\n             \"ISREDIT C  ALL 'OLD ACCOUNT INFO' 'NEW ACCOUNT INFO' \"\n             \"ISREDIT END\"\n\n       Note the END which forces the member to be saved and\n       allows processing to go on to the next member.  Two\n       associated macros in this package are ALLMEMC which\n       resembles the above code for changes and ALLMEMF which\n       does a find for a string and only brings up the members\n       that have the string, like:\n\n          /*** REXX  --  FIND SOME STRING  --  USE WITH ALLMEM  ***/\n             \"ISREDIT MACRO\"\n             \"ISREDIT SEEK  'DB2 ENVIRONMENT' \"\n             IF RC <> 0 THEN \"ISREDIT END\"\n\n       An example follows to scan members whose first character\n       is an 'A' and then delete all lines within those members\n       that contain 15 dots (...............).\n\n          /*** REXX  --  FIND AND DELETE LINES OF 'A' MEMBERS  ***/\n             \"ISREDIT MACRO\"\n             \"ISREDIT (PARMS) = MEMBER\"\n             \"ISREDIT SEEK  '...............'\"\n             DO WHILE RC = 0\n                \"ISREDIT (LINE,COL) = CURSOR\"\n                IF SUBSTR(PARMS,1,1) = 'A' THEN DO\n                   \"ISREDIT DELETE &LINE\"\n                END\n                \"ISREDIT SEEK  '...............'\"\n             END\n             \"ISREDIT END\"\n\n       Please also see XALLMEM below for a macro that does the\n       same function but may be executed from outside the PDS.\n\n\n:HEADER2 ALLOCGDX  DSN | ? ( other Allocate parameters )\n:HEADERT Allocate a Relative GDG as an Absolute Data Set\n\n       does equivalent of Allocate for a relative GDG entry\n       translating the relative numbered data set into a fully\n       qualified G....V00 name. For example:\n\n          AllocGDx 'rubber.ducky(-1)' dd(...) ...\n\n       would allocate the -1 file as the fully named\n       'rubber.ducky.g0011v00' (if appropriate).\n\n       Any additional normal Allocate parameters are passed as\n       is. The DSN may be quoted as shown or not, i.e. picking up\n       the prefix.  Use no parameters or a standalone ? to get\n       built-in help.\n\n\n:HEADER2 BS   ( RECORD-LENGTH )  ( ? )\n:HEADERT Determine Optimal Block Size\n\n       will ask for a record length, if not provided, and display\n       back the maximum normal (based on 32,760) block size, a\n       reasonably optimal block size based on 3390 half track\n       blocking (27,998 is half a track), and a large tape block\n       size based on 262,144 (256K appears to be the normal site\n       default). An example for \"TSO BS 333\" is:\n\n            LRECL 333, MAX BLKSZ= 32634,\n               OPT 3390 BLKSZ=27972 & LARGE BLKSZ=262071\n\n       Specifying a question mark as the parameter will cause the\n       built in help to be displayed.\n\n\n:HEADER2 CC\n:HEADERT Provide Simple Calculator Functions\n\n       will allow REXX arithmetic by direct input. It will\n       provide a quick intro line:\n\n          **  ENTER CALCUATIONS AND NULL ENTER TO QUIT...  **\n\n       All standard REXX arithmetic statements may then be\n       entered and the response immediately follows.  For\n       example,\n\n          (233+17)**2\n\n      returns 62500, effectively 250 squared.  Obviously,\n      parentheses may be used to force the order of operations\n      and/or make the logic of the operation more apparent.\n\n      In addition to + for addition, - for subtraction, * for\n      multiplication and / for division, // does a remainder\n      equivalent operation (16//5 is 1) and % does pure integer\n      division (16%5 is 3).  ** performs exponentiation.\n\n      The formula, courtesy of REXX, does not need to be\n      completely contiguous, so the following produce the same\n      result.\n\n         ( 233 + 17 ) ** 2\n\n      is equivalent to\n\n         (233+17)**2\n\n      As many calculations as desired may be entered and a simple\n      null (press of <ENTER> without any input) entry terminates.\n\n\n:HEADER2 CLS\n:HEADERT Clear the TSO Screen\n\n      hopefully a generic TSO clear screen invocation. It uses\n      the CLRSCRN program also from File 357 on the CBT Tape,\n      simply invoking it as:\n\n            \"CALL 'your.loadlib(CLRSCRN)'\"\n\n\n:HEADER2 COMPRS   ( PDS-NAME )  ( ? )\n:HEADERT Compress a PDS Under Edit or From Outside\n\n      compresses either the PDS of the member being edited, the\n      default when no PDS-NAME is specified, or the specified\n      PDS-NAME.  IEBCOPY is invoked to do the actual compress.\n      The question mark will cause the built in help to be\n      displayed but will not invoke the compress.\n\n\n:HEADER2 CONCATDD   DDNAME  DATASET-NAME  ( BOTTOM-OPTION )\n:HEADERT Add Files to an Allocation\n\n      concatenates a data set to the DDNAME provided, either at\n      the beginning or at the end of the concatenation.  If the\n      BOTTOM-OPTION is B, the file is concatenated at the bottom.\n      The default is to put it at the top. If the only parameter\n      passed is a question mark (?), then built in help will be\n      displayed. It will check whether the data set exists and\n      whether the dd name is actually allocated and issue\n      appropriate messages.\n\n      The DATASET-NAME should not be put in quotes and needs to\n      be fully qualified.  SYSEXEC and SYSPROC may have datasets\n      added to its concatenation wile in ISPF but CONCATDD must\n      be invoked outside of ISPF (or in a LOGON EXEC if your site\n      has such a thing) if DDNAME is ISPMLIB, ISPLLIB, ISPSLIB,\n      or ISPTLIB since they are in use while in ISPF.\n\n         \"EX 'YOURID.CLIST(CONCATDD)' 'SYSPROC YOURID.CLIST'\"\n\n      in a REXX macro will invoke CONCATDD from yout library and\n      add that library at the top of the SYSPROC concatenation.\n\n      If the data set is already in the concatenation, it is\n      effectively moved to the top or bottom, as specified.\n\n\n:HEADER2 DESC\n:HEADERT Briefly Describe File from Within Edit/View\n\n      shows the logical record length (LRECL), block size BLKSIZE)\n      and number of records in upper right hand corner of display.\n\n      For example, on this file (at this moment), DESC would show\n      80/27920/5858.\n\n\n:HEADER2 ENC  PASSWORD\n:HEADERT Provide Simple Password Protection for Data\n\n      encrypts a fixed format sequential file or member using\n      the specified password. Invoking it again with the same\n      password unencrypts the data.  It is not an extremely\n      secure method but does provide a fast way to hide\n      information. Passwords can be of any length.\n\n      The process uses some shifting to assure shallow testing\n      will not show the bit pattern used and to provide a\n      measure of protection even with one character passwords.\n      It may be invoked more then once, i.e. ENC XXX and then\n      ENC YYY. Invoking ENC in the reverse order, ENC YYY and\n      then ENC XXX will return the data to its original state.\n\n      Caution should be used to remember the password since it\n      may be difficult to recreate the file without the correct\n      password. Unencrypting before saving and then\n      re-encrypting would validate there was no error during\n      typing.\n\n      ENC2, described below, improves upon ENC in both hiding\n      data and protecting it. ENC has been left in the package\n      since it would be necessary for anyone who has data\n      encrypted using it.\n\n\n:HEADER2 ENC2  PASSWORD\n:HEADERT Provide Improved Simple Password Protection for Data\n\n      encrypts a file or member of any record format using the\n      specified password. Invoking it again with the same\n      password unencrypts the data.  It is not an extremely\n      secure method but does provide a fast way to hide\n      information. Passwords can be of any length.\n\n      The process uses the password to generate a series of\n      random overlays (exclusive or'ing) and to provide a\n      measure of protection even with one character passwords.\n      It may be invoked more then once, i.e. ENC2 XXX and then\n      ENC2 YYY. Invoking ENC2 in the reverse order, ENC2 YYY and\n      then ENC2 XXX will return the data to its original state.\n\n      ENC2 improves upon ENC above in that it is more sensitive\n      to the password and is not as repetitive, and uses\n      randomization more effectively.  ENC is still included\n      since someone may have encrypted data using it.\n\n      As an example, encrypting a simple file using \"A\" as the\n      password will protect all the data if \"a\" is tried. ENC\n      would show some data.\n\n      Caution should be used to remember the password since it\n      may be difficult to recreate the file without the correct\n      password. Unencrypting after saving and then\n      re-encrypting would validate there was no error during\n      typing.\n\n\n:HEADER2 FOG  ( # )  ( ? )\n:HEADERT Produce Sentences of Meaningless Text\n\n      generates pseudo random meaningless sentences useful for\n      testing with text or fleshing out meaningless documentation.\n      # is the number of sentences to be generated and defaults to\n      1. The generated text will be inserted either where the\n      cursor is positioned or immediately below the top line on\n      the displayed screen. For example, FOG 2 might produce:\n\n            In this regard, the independent functional\n            principle presents extremely interesting\n            challenges to the greater fight-worthiness\n            concept.   We can see, in retrospect, the\n            interrelation of system and/or subsystem\n            technologies is further compounded when taking\n            into account the management-by-contention\n            principle.\n\n      The CAPS ON|OFF setting will determine whether the text is\n      all upper or mixed case. If only the question mark is\n      entered, the built in help is displayed and no text is\n      generated. FOG may be useful for testing text applications\n      or padding required documentation, just to see if someone\n      actually reads it.\n\n\n:HEADER2 FS  ( 'STRING TO BE FOUND' PDS-TO-BE-SEARCHED )  ( ? )\n:HEADERT Submit a Job to Scan a PDS(E) for a String\n\n      submits a job using the user ID of the TSO user to do\n      a SuperC scan of a PDS or PDSE for a given string.\n      For Example:\n\n        FS  'STRING TO BE FOUND'  PDS-TO-BE-SEARCHED\n\n      The user's ID will be used for the job name prefix, the\n      name field and the NOTIFY.\n\n      The string to be sought must be in quotes, either single or\n      double. The PDS(E) may be either unqualified, without\n      quotes where the user's ID will be prefixed, or within\n      quotes as a fully qualified name.\n\n      A question mark (?) as the only parameter or no parameters\n      at all will cause the built in help to be displayed.\n\n\n:HEADER2 NEW  ( Data-Set Prime Secondary Format Rec-Length )  ( ? )\n:HEADERT Allocate a New Sequential File\n\n       will allocate a file as NEW with the attributes specified.\n       If no parameters are provided or a question mark is given\n       as the first parameter, built in help will be displayed.\n\n       The Data-Set name may be provided without quotes whence it\n       will have the profile's prefix appended to its beginning\n       (note this is usually the user ID). If a single quote is\n       placed on both ends, that fully qualified name will be used.\n\n       The Prime and Secondary parameters indicate the primary\n       and secondary space parameters (in cylinders).\n\n       The Format provides th record format. FB, F, VB, V and U\n       are acceptable as well as FBA, FA, VBA, and VA. The\n       Rec-Length is the LRECL for all the formats except U where\n       it becomes the block size and the LRECL is set to 0. For\n       FB, the block size is set to a multiple of the LRECL less\n       then 27,998. For F, the block size is set to the LRECL.\n       For VB, the block size is set to 27,998. For V, the block\n       size is set to the LRECL + 4.\n\n       For example, specifying\n\n          NEW  $$$TEMP.DATA  5 2  FB 100\n\n       will create a new data set named userid.$$$TEMP.DATA\n       with a primary of 5 cylinders and a secondary of 2, and\n       its attributes will be fixed blocked, LRECL of 100, and\n       block size of 27,900.\n\n\n:HEADER2 NEWP ( PDS-Name Prime Secondary Dir Format Rec-Length ) ( ? )\n:HEADERT Allocate a New Partitioned Data Set\n\n       will allocate a PDS as NEW with the attributes specified.\n       If no parameters are provided or a question mark is given\n       as the first parameter, built in help will be displayed.\n\n       The Data-Set name may be provided without quotes whence it\n       will have the profile's prefix appended to its beginning\n       (note this is usually the user ID). If a single quote is\n       placed on both ends, that precise name will be used.\n\n       The Prime and Secondary parameters indicate the primary\n       and secondary space parameters (in cylinders). The Dir\n       parameter indicates the number of directory blocks to\n       be provided.\n\n       The Format provides the record format.  F, FB, FA, FBA, V,\n       VB, VA, VBA and U are acceptable.  And the Rec-Length is\n       the LRECL for all the formats except U where it becomes\n       the block size and the LRECL is set to 0. For FB, the\n       block size is set to a multiple of the LRECL less then\n       27,998. For F, the block size is set to the LRECL. For VB,\n       the block size is set to 27,998. For V, the block size is\n       set to the LRECL + 4.\n\n       For example, specifying\n\n          NEWP  'SYS4.MACLIB.BACKUP' 20 10 89  FB 80\n\n       will create a new PDS named SYS4.MACLIB.BACKUP with a\n       primary space allocation of 20 cylinders, a secondary of\n       10, and 89 directory blocks (45 fit on every 3390 track\n       except the last where the end of file marker reduces the\n       number to 44).  Its attributes will be fixed blocked,\n       LRECL of 80, and block size of 27,920.\n\n\n:HEADER2 OPCODE  HEX-VALUE\n:HEADERT Describe a Machine Operation Code\n\n      will give a brief description of the assembler instruction\n      associated with the hex value. For example,\n\n         OPCODE  41\n\n      will show:\n\n         OP CODE '41' IS LOAD ADDRESS\n            WITH MNEMONIC LA        AND IS A(N)   RX   INSTRUCTION\n\n\n:HEADER2 PACKDS  IN-DATA-SET  OUT-DATA-SET\n:HEADERT Compress a File using IBM's TRSMAIN\n\n      will use IBM's free TRSMAIN utility to compress one\n      file into another new file created by the EXEC. So,\n\n         PACKDS  'QDSN.S020701.DATA' COMPRSED.S020701.DATA\n\n      will create the second file and compress the first into it.\n      This macro may be run from the Edit/View command line\n      or from a TSO command prompt.\n\n\n:HEADER2 PDS2SEQ   PDS-name  Seq-Out-File  ( NOSEP )  ( ADD | REPLACE )\n:HEADERT Unload a PDS to a Sequential File\n\n      unloads the specified partitioned data set (PDS) into a\n      sequential file with or without IEBUPDTE separator cards.\n      The RECFM, LRECL and BLKSIZE of the PDS are used for the\n      output file. A primary space parameter of 10 cylinders and\n      a secondary of 10 cylinders is used.  The unit parameter is\n      set to SYSDA.\n\n      The PDS-name supplies the partitioned data set name, either\n      fully qualified within quotes or without quotes where the\n      user prefix will be attached. Seq-Out-File names the\n      sequential file that will contain the unloaded records\n      and may be either fully or partially qualified.\n\n      NOSEP will cause no ./ separator cards to be output before\n      each member's data; the default is to generate them.  ADD\n      or REPLACE will change the option on the separator card\n      respectively to ADD or REPL, that is ./  ADD NAME=member.,\n      ADD is the default.\n\n         PDS2SEQ  'USER.MACLIB'  UNLOAD.USER.MACLIB  NOSEP\n\n      will cause the entire contents of 'USER.MACLIB' to be placed\n      in the sequential file 'user-prefix.UNLOAD.USER.MACLIB'\n      without any separator cards.\n\n\n:HEADER2 SAVEINPL  ( ? )\n:HEADERT Save a Member in Place\n\n      will save the edited member in place, that is, it will\n      overlay the existing member.  The edited file must be a\n      member of a fixed length partitioned data set (record\n      format must be F or FB).  Also, the number of lines must\n      not have changed.  Note that it will not change the member\n      statistics (if any) and will issue a warning to that\n      effect.\n\n      Uses in core read and write, and so may be vulnerable to\n      out of memory conditions.Does not work with PDSE's.\n\n\n:HEADER2 SLEEP  ( NUMBER-OF-SECONDS | ? )\n:HEADERT Pause for Given Number of Seconds\n\n      will delay responding the number of seconds specified,\n      defaulting to 5. If a question mark (?) or non numeric\n      value is specified, the built in help is displayed.  The\n      SYSCALLS environment must be available. This may be\n      useful for imbedding within another macro for usability or\n      simulation testing.\n\n\n:HEADER2 TODAY  ( CCYYMMDD | CCYYDDD )  ( ? )\n:HEADERT Provide Variations of Given Date\n\n      will display a message of the form\n\n         Friday December 31st, 1999 (day 365) Lillian(152,384)\n\n      for either of the 2 date formats specified. If no date is\n      specified, today's date will be used.  The above message\n      would have come out if either\n\n         TSO  TODAY  1999365\n\n      or\n\n         TSO  TODAY  19991231\n\n      were invoked. A parameter of a question mark (?)  will\n      cause the built in help to be displayed. If the input date\n      is less then 15821015 (Lillian date 1), the resulting\n      Lillian date will be negative.\n\n\n:HEADER2 TSJ  ( ? )\n:HEADERT Split/Join Line at Cursor\n\n      performs the equivalent of the TS (text split) prefix\n      command, optimumly assigned to a PFKey.  Simply place the\n      cursor under the column where the line is to be broken and\n      invoke TSJ.  The new line has the same indentation.\n\n      If the cursor is placed after all non-blank data on the\n      line, the next line is \"joined\" at the point where the\n      cursor is.  All blanks at the front of the next line are\n      removed before being joined at the cursor point.\n\n\n:HEADER2 UNPACKDS  IN-DATA-SET  OUT-DATA-SET\n:HEADERT Decompress a File using IBM's TRSMAIN\n\n      will use IBM's free TRSMAIN utility to decompress one\n      file into another new file created by the EXEC. So,\n\n         UNPACKDS  COMPRSED.S020701.DATA  'QDSN.S020701.DATA'\n\n      will create the second file and decompress the first into\n      it. This macro may be run from the Edit/View command line\n      or from a TSO command prompt.\n\n\n:HEADER2 VSAVE  ( ? )\n:HEADERT Save File or Member from within VIEW\n\n      will allow the VIEWed file or member to be saved, including\n      any changes.  VSAVE works for sequential files, PDS's and\n      PDSE's.  It saves having to do a multi-screen replace but\n      remains in VIEW mode.  If a question mark (?) is specified\n      as the parameter, the built in help is displayed.\n\n      You still remain in View after the save is complete.\n\n\n:HEADER2 VWV  ( ( limits )  VSAM-file-name ) ( ? )\n:HEADERT Extract and View All or Part of a VSAM File\n\n       pulls all or part of a specified VSAM file to a sequential\n       file under the user's ID of the form\n       $$$TEMP.VSAM.FLAT.FLhhmmss (where hhmmss is the time).\n       Limits as to the number of records to be pulled and other\n       constraints may be specified and must be before the VSAM\n       file name.\n\n       The limits may be COUNT(#), SKIP(#), FROMKEY(key),\n       TOKEY(key), FROMNUMBER(#), or TONUMBER(#), all IDCAMS\n       REPRO qualifiers.\n\n       The VSAM file name can be specified or defaulted from a DS\n       List entry.  It may be either unqualified, without quotes\n       where the user's ID will be prefixed, or within quotes as\n       a fully qualified name.\n\n       VWV puts you in View on the set specified and saves the\n       time-stamped file upon exit.\n\n       For example:\n\n          VWV  COUNT(500)  FROMKEY(XXX)  A-VSAM-FILE-UNDER-YOUR-ID\n\n       will View the first 500 records of that file starting at\n       key XXX and keep the file on exiting.\n\n       A question mark (?) as the only parameter or no parameters\n       at all will cause the built in help to be displayed.\n\n\n:HEADER2 XALLMEM  ( ? )  PDS  MACRO\n:HEADERT Execute Macro Against Every PDS Member from Outside\n\n      will execute the macro specified against every member of\n      the partitioned data set named.  It may be invoked from\n      anywhere.  The macro must be accessible through SYSPROC or\n      SYSEXEC.  If a question mark (?) is specified as the first\n      parameter or no parameters are specified, the built in help\n      is displayed.\n\n      An example is:\n\n         TSO  XALLMEM  'SYS4.JOBLIB'  ALLMEMC\n\n      will execute ALLMEMC against every member of 'SYS4.JOBLIB'.\n      Quotes may be left off a data set under your user-ID, such\n      as:\n\n         TSO  XALLMEM  A.PDS.UNDER.YOUR.USERID  ALLMEMC\n\n      XALLMEM will not execute against a member with the same\n      name as the macro to be executed.Please see ALLMEM above\n      for sample EXEC's to be executed.\n\n\n:HEADER2 ZVW  ( ? )\n:HEADERT View Data Set Under Cursor\n\n      will attempt to View the dataset on which the cursor is\n      positioned. If there are & variables in the dataset name,\n      i.e. it's a PROC, the macro will attempt to fill in from\n      any PROC statement at the top of the file.  This works best\n      when assigned to a PF Key.\n\n      It opens the View within a new screen to allow swapping\n      back and forth.  Code to just do a View (within the same\n      screen session) is included but commented out.  A question\n      mark as the only parameter typed will cause built in help\n      to be displayed.\n\n\n:HEADER1 Things You May Never Want to Do\n\n The following issues were quickly resolved using the above\n macros.  As the header of this unit implies, you may never\n encounter these \"problems.\"  On the other hand, who knows...\n\n 1) Given a file of records and a list of account numbers,\n    identify those records that are on the account list.  Let's\n    suppose the records have a ten digit account number in\n    columns 21 through 30 (10 bytes) and the account list is in\n    columns 1 through 10.\n\n    Let's assume that all the account numbers in the record file\n    are unique and that each record file line has non blank\n    characters in columns 1 through 20. It's easy to check the\n    former condition via FINDDUPS and make the latter true by\n    doing a \"C P'=' '!' 1 ALL\" after the CLONE below and removing\n    that special character later.\n\n       CLONE the record file (for safety and to have the matched\n       records in one place)\n\n       Edit the record file and XCOPY the account file to the bottom\n\n       Shift the accounts 20 bytes to the right (do a \"))20\" on\n       the top account line and bottom account line)\n\n       FINDDUPS 21 30 (sort and show only those non-unique account\n       numbers\n\n       Any unexcluded lines are dups, that is, the record file\n       and the included account list have the same account\n       numbers, so do a \"DELETE ALL X\" which removes the\n       unmatched records\n\n       Exclude everything ( \"X 99999\" on the first prefix line)\n\n       Do a \"F '                    ' 1 ALL\" (finds the lines with\n       blanks in columns 1 through 20, i.e. the account numbers)\n\n       DELETE NX ALL (removes the account number, leaving the records)\n\n 2) Given a \"catastrophic\" error when doing an Easytrieve (yes,\n    that's the term the error message uses), you can check for\n    dups within a table load using FINDDUPS start-col1 end-col1.\n    There was no other elaborating text for the error.\n\n 3) To create a partial file of test data from a very large file\n    which will not be tolerated by Edit, simply CLONE the file\n    with the EMPTY option, Edit the empty new file and XCOPY in\n    some subset of the original file. You could copy the first\n    50, middle 100 and last 50 records, for example. You can then\n    free, via an 'F' command on ISPF 3.4 (DS List) the additional\n    space.\n\n    If the file to be edited is variable with block size 27,998,\n    run HOWLONG against the file frist to get the longest record\n    size. Then CLONE the file to that record size plus 4 (for the\n    length). Quite often this will be sufficient to allow editing\n    since Edit apepars to allocate room for the maximum record\n    size.\n\n    See also VWV for a similar extract facility for VSAM.\n\n 4) To set a date as part of a data set name or even pass it as a\n    PARM value to a program, use the date tokens (&YYMMDD for\n    example) in SUBX. So the JCL stays the same but the submitted\n    JCL contains the date (or any of the other allowed tokens).\n    SUBX may be used in member lists too and the regular SUB\n    command causes a page enter (3 asterisks appear the bottom of\n    the page and you must press <Enter> to procede while SUBX\n    does the submit and returns control saving one whole\n    keystroke :)\n\n    For consistency and documentation reasons, you might want to\n    make ORIGIN the default parameter for your version of SUBX\n    (or use the new SUBO) and always use it in place of plain\n    SUB.\n\n 5) If your group has a file of data sets that are accessed on\n    a regular basis (a dumb 'read' to keep the data set from\n    being archived or deleted), use GETDSNS to retrieve a group\n    of data sets by wildcard. For example, GETDSNS SYS3.ARDX.*.\n    This is a lot faster (and more accurate) the typing them or\n    cutting and pasting.\n\n    If you need such a program, I'd suggest FOREVER on this same\n    CBT Tape file.  While this goes against what the DASD group\n    is trying to accomplish, it may be your only way to get your\n    job done.\n\n 6) To columnize data, i.e. put every word on a new line:\n       - do a SHIFT L 999 MAX to get data aligned against the\n         left hand margin\n       - do a DELBLANK\n       - do a TF2 on the first line\n\n 7) Suppose you have a very large data set and you want to\n    eliminate most of the data and consolidate it to a smaller\n    file but it's too big to edit.  CLONE the file to a back up\n    copy first (for safety both against finger-fumbles and lights\n    out). Then do a KEEPCOLS against the file in DS List\n    specifying the columns (one or more sets) to be kept. Then\n    finally CLONE that file specifying the new record length.\n\n    Let's consider a 500,000 record file named\n    USERID.REALLY.BIG.FILE of 300 bytes each, and suppose you\n    need the first 10 columns and the last 10.\n\n    Back it up by doing a \"CLONE  =.BKUP\". Then do\n    \"KEEPCOLS  1 10  291 300\" and finally a \"CLONE  =.NEW  20\".\n    You will now have 3 data sets, the original in\n    USERID.REALLY.BIG.FILE.BKUP, the changed one in\n    USERID.REALLY.BIG.FILE, and the new small one in\n    USERID.REALLY.BIG.FILE.NEW.\n\n 8) If you want to reformat a file in Edit/View, I'd suggest:\n       - CLONE the file first (for safety)\n       - save periodically\n       - put a sample of what you want as a result at the top\n         of the file and use labels to limit the changes\n       - work consistently from right to left\n       - stack commands using the semi-colon, e.g.\n         DELCOLS 1 7; FILLINS 22 '-->';MOVEINSD 43 55 27\n\n 9) To add a number of header lines after every 50 lines of a\n    data file:\n       - given:\n            A1 ... first 50 lines ...\n            B2 ... second 50 lines ...\n            C3 ... third 50 lines ...\n            D4 ... last 50 lines ...\n       - CUTX just the header lines\n       - add a blank line before A1\n       - put a C9999 on the blank line just inserted\n       - enter 'PASTEAFT 50' on the command line and press enter\n       - delete the blank line\n       - you may have to delete the very last lines if there were\n         an even 50 multiple of data lines\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@PGMDOC#": {"ttr": 10759, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x10\\x8c\\x10\\x8c\\x00\\x00\\xc4\\xd6\\xc3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 4236, "newlines": 4236, "modlines": 0, "user": "DOC"}, "text": "\n-\n-\n-\n-\n-\n-\n-\n                                     ABENDX\n                                Force User ABEND\n\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n September 14, 2002                                     Freeware from Steli Inc.\n1                          TABLE OF CONTENTS                         Page      2\n\n\n INTRODUCTION  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     3\n\n\n EXECUTION JCL   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     4\n\n\n SAMPLE JCL AND OUTPUT   . . . . . . . . . . . . . . . . . . . . . . . . .     5\n\n\n PACKAGE CONTENTS  . . . . . . . . . . . . . . . . . . . . . . . . . . . .     6\n\n1                            INTRODUCTION                            Page      3\n\n\n This document is intended to provide user information for the\n utility to force user abnormal terminations (ABENDX). Some\n understanding of Job Control Language (JCL) is required as well\n as knowledge of how programs are executed.\n\n ABENDX is mainframe freeware. It's available for any use you\n wish to make of it.\n\n ABENDX is intended for MVS compatible systems to call the system\n ABEND routine with a parameter specified user code or to force\n specific system abends such as 0C1, allowing testing of JCL and\n restart conditions without having to do program changes. It may\n even be called from REXX or CLIST.\n\n ABENDX is an Assembler program that accepts a PARM parameter of\n a number between 0 and 4095, the legitimate user ABEND codes\n acceptable to MVS.  ABENDX will also accept PARM values of 0C1,\n 0C2, 0C3, 0C4, 0C6, 0C7, 0C8, 0C9 and 0CB and will force that\n specific ABEND.  IF no value or a bad value is passed, the\n return code is set to 4095 and the ABEND occurs.\n\n Steli Inc. has made its best effort to provide working, tested\n code.  However, nothing is perfect - there may be flaws and\n there certainly could be improvements.  All questions, concerns,\n problems and suggestions are welcome.  Please e-mail them to\n C_Hafner@HotMail.Com.\n\n\n1                            EXECUTION JCL                           Page      4\n\n\n The job control language (JCL) for ABENDX is:\n\n           //DIE        EXEC     PGM=ABENDX,PARM=#\n\n           //STEPLIB      DD       DISP=SHR,DSN=...\n\n The name of the program may be changed as desired providing\n that the actual program is linked with the appropriate name\n or alias.\n\n REGION is optional.  STEPLIB may be optional if ABENDX is\n placed in the system's link list but otherwise simply points to\n where ABENDX is stored.\n\n The only real input is provided by the PARM statement. The\n number provided will be used to set the user ABEND code or the\n system abend code will be used to force the program's\n termination.  Since ABENDX operates like IEFBR14, file\n allocation or deletion may be performed within its JCL.\n\n\n1                        SAMPLE JCL AND OUTPUT                       Page      5\n\n\n An example of JCL that may be used is:\n\n      //TEST412   EXEC  PGM=ABENDX,PARM=412\n\n      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB\n\n The above step will cause the following JES message to be\n generated:\n\n       12.34.56 JOB00123  IEF450I USERNMA ABEND ...\n             - ABEND=S000 U0412  REASON=00000000\n\n An example of how ABENDX might be used to force an ABEND within a\n REXX EXEC is:\n\n      /**  REXX  **/\n\n         ADDRESS TSO\n\n         \"CALL 'your-user-ID.LOADLIB(ABENDX)' '0412'\"\n\n\n\n1                          PACKAGE CONTENTS                          Page      6\n\n\n The files involved specifically with ABENDX are:\n\n     - ABENDX     the Assembler code wrapped in JCL to\n                  assemble and link edit it\n\n     - ABENDX$    a JCL skeleton for its execution\n\n\n-\n-\n-\n-\n-\n-\n-\n-\n                                      ADDCC\n                              Add Carriage Control\n                              to a Sequential File\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n September 7, 2002                                      Freeware from Steli Inc.\n1                          TABLE OF CONTENTS                         Page      2\n\n\n INTRODUCTION  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     3\n\n\n EXECUTION JCL   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     4\n\n\n SAMPLE JCL AND OUTPUT   . . . . . . . . . . . . . . . . . . . . . . . . .     6\n\n\n PACKAGE CONTENTS  . . . . . . . . . . . . . . . . . . . . . . . . . . . .     9\n\n\n1                            INTRODUCTION                            Page      3\n\n\n This document is intended to provide user information for adding\n carriage control data and minimal word processing structures to\n a sequential file (ADDCC).  Some understanding of Job Control\n Language (JCL) is required as well as knowledge of how programs\n are executed.\n\n ADDCC is mainframe freeware. Use it, change it, or rip it\n apart.\n\n ADDCC is a PL/I program intended for MVS compatible systems to\n add ASCII carriage control to a sequential data set. It allows\n the use of a pseudo text descriptor language to generate a title\n page, to provide a table of contents, to set page and line size,\n and to separate sections.\n\n ADDCC is intended to simplify documentation maintenance.  It's a\n small, cheap text scripting tool that does page generation so\n you don't have to do all sorts of editing when you add or remove\n a few lines.  And, if asked, it will generate a table of\n contents based on section naming.\n\n Steli Inc. has made its best effort to provide working,\n tested code.  However, nothing is perfect - there may be\n flaws and there certainly could be improvements.  All\n questions, concerns, problems and suggestions are welcome.\n E-mail may be sent to C_Hafner@HotMail.Com for the preceding.\n\n\n1                            EXECUTION JCL                           Page      4\n\n\n The job control language (JCL) for ADDCC is:\n\n           //ADDCC      EXEC     PGM=ADDCC,    ( ,REGION=64M, )\n\n           //             PARM='HEAP(01M,01M,ANYWHERE)'\n\n           //I            DD       DISP=SHR,DSN=...\n\n           //O            DD       SYSOUT=*,\n\n           //             DCB=(RECFM=FA,LRECL=...,BLKSIZE=.....)\n\n           //STEPLIB      DD       DISP=SHR,DSN=...\n\n Optional control language elements are shown in parentheses.\n The name of the program  may be changed as desired providing\n that the actual program is linked with the appropriate name\n or alias.\n\n REGION is optional but ADDCC does all its processing in core, so\n REGION=64M can't hurt.  STEPLIB may be optional if ADDCC is\n placed in the system's link list but otherwise simply points to\n where ADDCC is stored.\n\n The I file points to the input file to be processed.  All normal\n text should begin in column 2 or beyond (which allows you to put\n your own carriage control, if desired, in column 1).  The\n descriptor language should be prefixed by a colon (:) and begin\n in column 1 (that colon vanishes when the descriptor is\n resolved).  These are generally described here and samples shown\n below.\n\n Page size, that is, the number of lines placed on each page, is\n specified as :PAGESIZE ##, where ## defaults to 58.  The first\n page will always have a '1' (new page) as the carriage control -\n this will allow concatenating several runs of ADDCC together.\n The logical record length, AKA line size, is specified as\n :LINESIZE ##, where ## defaults to 72. These may be changed\n within the code.\n\n :DOCTITLE, :DOCTITLE2 and :DOCTITLE3 may be used to have title\n lines centered and generated on a first page. :TLRDATE may\n specify a date/time to be placed on the left side of the last\n line on the title page, left justified.  Similarly, :TLRDESC\n will place a descriptive entry on the right side of the lowest\n line, right justified.  Obviously, any text may be specified.\n\n :HEADER1 xxx will signal a chapter heading; :HEADER2 yyy a\n section heading. The chapter name, xxx, will be on the top of\n every page in that chapter with \"(Continued)\" suffixed on the\n 2nd and following pages of that chapter. The section data will\n have its first word underlined and use that word in the table of\n contents, if requested.  :HEADERT zzz are simply expanded 50\n character section descriptions which will be used in the table\n of contents. :HEADERT should immediately follow :HEADER2\n1                      EXECUTION JCL (Continued)                     Page      5\n\n entries.\n\n :TOC YES (the default) will cause a table of contents to be\n generated after the title page using the chapter and section\n headings and the generated page numbers.\n\n :RESET allows multiple sets of documentation to be included in\n one run. It will reset the page count to 1 and start the\n carriage control with a new page character ( a 1).\n\n :* with any following text on that line is treated as a\n comment. It is simply read and ignored.\n\n The O output file may be directed to any output class or may be\n sent to a new or existing file.  The DCB attributes may be\n whatever's desired, e.g. F, FB, FA or FBA of any length and\n appropriate block size.\n\n Note that by specifying only the following, ADDCC may be used\n to simply add carriage control to a file with paged breaks\n every PAGESIZE:\n\n      :PAGESIZE  55\n\n      :LINESIZE  80\n\n      :TOC       NO\n\n\n1                        SAMPLE JCL AND OUTPUT                       Page      6\n\n\n An example of JCL that may be used is:\n\n      //PRINT      EXEC     PGM=ADDCC,REGION=464M,\n\n      //             PARM='HEAP(01M,01M,ANYWHERE)'\n\n      //O            DD       SYSOUT=V,DEST=PRT60,\n\n      //             DCB=(RECFM=FA,LRECL=080,BLKSIZE=00080)\n\n      //STEPLIB      DD       DISP=SHR,DSN=USER213.K12D.LOADLIB\n\n      //I            DD       *\n\n      :PAGESIZE  50\n\n      :LINESIZE  80\n\n      :TOC       YES\n\n      :DOCTITLE  ADDCC SAMPLE\n\n      :DOCTITLE2 Add Carriage Control Sample Input\n\n      :TLRDESC   Freeware from Steli Inc.\n\n\n      :HEADER1   INTRODUCTION\n\n       This is an introductory paragraph. Note the text begins in\n       (logical) column 2 and the next line will cause the word\n      + _______\n       logical to be underscored!\n\n      :HEADER1 A Mixed Case Chapter heading\n\n       There will be 2 sections following, cleverly named\n       FIRST and SECOND. Note this paragraph is in a chapter\n       but not in a section. Blank lines and all caps may be\n       used to make things more readable...\n\n      :HEADER2 FIRST Section\n\n         This is the first section. Note how I can indent here\n         manually to make a point!\n             SOME DUMB POINT\n\n      :HEADER2 SECOND Section\n      :HEADERT The Second Section Description\n\n         This is the second and last section.\n\n      //******** INPUT ENDS WITH PREVIOUS RECORD... ***********\n\n The above step has the input instream only for the virtue of the\n1                  SAMPLE JCL AND OUTPUT (Continued)                 Page      7\n\n example.  Note the Second Section only has a :HEADERT control\n following its :HEADER2.  The actual out, shifted right 6 columns\n and having some odd non meaningful data removed, would be as\n follows:\n\n      1\n      -\n      -\n      -\n      -\n      -\n      -\n                                        ADDCC SAMPLE\n                              Add Carriage Control Sample Input\n\n      -\n      -\n      -\n      -\n      -\n      -\n      -\n      -\n                                                Freeware from Steli Inc.\n      1                          TABLE OF CONTENTS           Page      2\n\n\n       INTRODUCTION  . . . . . . . . . . . . . . . . . . . . . . .     3\n\n\n       A Mixed Case Chapter heading  . . . . . . . . . . . . . . .     4\n\n          FIRST  . . . . . . . . . . . . . . . . . . . . . . . . .     4\n          SECOND . . The Second Section Description  . . . . . . .     4\n\n      1                            INTRODUCTION              Page      3\n\n\n       This is an introductory paragraph. Note the text begins in\n       (logical) column 2 and the next line will cause the word\n      + _______\n       logical to be underscored!\n\n      1                    A Mixed Case Chapter heading      Page      4\n\n\n       There will be 2 sections following, cleverly named\n       FIRST and SECOND. Note this paragraph is in a chapter\n       but not in a section. Blank lines and all caps may be\n       used to make things more readable...\n\n       FIRST Section\n      +_____\n\n         This is the first section. Note how I can indent here\n         manually to make a point!\n             SOME DUMB POINT\n1                  SAMPLE JCL AND OUTPUT (Continued)                 Page      8\n\n\n       SECOND Section\n      +______\n\n         This is the second and last section.\n\n\n1                          PACKAGE CONTENTS                          Page      9\n\n\n The files involved specifically with ADDCC are:\n\n     - ADDCC      the PL/I code wrapped in JCL to compile\n                  and link edit it\n\n     - ADDCC$     a JCL skeleton for its execution\n\n\n-\n-\n-\n-\n-\n-\n-\n-\n                                    ALPHACNT\n                             Alphanumeric \"Counting\"\n                              to a Sequential File\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n January 3, 1999                                        Freeware from Steli Inc.\n1                          TABLE OF CONTENTS                         Page      2\n\n\n INTRODUCTION  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     3\n\n\n SAMPLE TEST PROGRAM   . . . . . . . . . . . . . . . . . . . . . . . . . .     4\n\n\n PACKAGE CONTENTS  . . . . . . . . . . . . . . . . . . . . . . . . . . . .     5\n\n\n1                            INTRODUCTION                            Page      3\n\n\n This document is intended to provide user information for\n counting alphanumerically (ALPHACNT). Some understanding of\n Job Control Language (JCL) is required as well as knowledge of\n how programs are executed.\n\n ALPHACNT is mainframe freeware. It's your toy to do with as you\n desire.\n\n ALPHACNT is a COBOL test program with 3 sub-programs intended\n for MVS compatible systems to provide a counting facility for\n alphanumeric values. The sub-programs are the working parts of\n this facility.  The collating sequence is 'A' through '9'\n keeping the numbers in EBCDIC sequence for sorting purposes.\n Separate sub-programs provide the next and previous value and\n there's another one to verify a value.\n\n ALPHACNT provides a counting scheme for visible, that is,\n displayable characters. Each byte can represent 36 values,\n 'A'...'Z''0'...'9'.  The sequence is meant to be sortable as\n EBCDIC. Its implementation is as sub-programs allowing them to\n be set up as one or more copy books.\n\n Steli Inc. has made its best effort to provide working,\n tested code.  However, nothing is perfect - there may be\n flaws and there certainly could be improvements.  All\n questions, concerns, problems and suggestions may be sent\n to C_Hafner@HotMail.Com.\n\n\n1                         SAMPLE TEST PROGRAM                        Page      4\n\n\n The job control language (JCL) provided for ALPHACNT has a main\n COBOL program calling the NXTALPHA, PRVALPHA and VERALPHA\n sub-programs.  It's a standalone, dynamically loaded program\n (uses LOADER rather then linking and executing) that reads a\n test set of 10 digit numbers, their expected next and previous\n values, and calls the sub-programs accordingly.  The verified\n results are then DISPLAYed.\n\n The test input is a small but varied set including a bad value,\n all periods.  Additionally, once it runs out of test data, it\n counts off and displays the first 100 values and the last 100\n values.\n\n Obviously, the counting sequence is all encompassing but\n arbitrary.  The counting is performed via translates, INSPECT\n CONVERTING, and the up and down lists may be changed. Some sites\n have chosen to not use I, L, O, and S, and these were simply\n removed.\n\n\n1                          PACKAGE CONTENTS                          Page      5\n\n\n The file involved specifically with ALPHACNT is:\n\n     - ALPHACNT   the COBOL main wrapped in JCL to compile and\n                  execute it\n\n\n-\n-\n-\n-\n-\n-\n-\n-\n                                     COBBITS\n                             COBOL Bit Manipulation\n                              to a Sequential File\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n February 22, 2001                                      Freeware from Steli Inc.\n1                          TABLE OF CONTENTS                         Page      2\n\n\n INTRODUCTION  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     3\n\n\n SAMPLE TEST PROGRAM   . . . . . . . . . . . . . . . . . . . . . . . . . .     4\n\n\n PACKAGE CONTENTS  . . . . . . . . . . . . . . . . . . . . . . . . . . . .     5\n\n\n1                            INTRODUCTION                            Page      3\n\n\n This document is intended to provide user information for\n manipulating bits of any length within COBOL (COBBITS). Some\n understanding of Job Control Language (JCL) is required as well\n as knowledge of how programs are executed.\n\n COBBITS is mainframe freeware. Feel free to do with it as you will.\n\n COBBITS is a COBOL test program with 4 sub-programs intended for\n MVS compatible systems to provide a bit handling facility for\n COBOL.  The sub-programs allow you to set bits on or off, test\n them to \"see\" what's set and flip (reverse) a bit setting.  The\n bits are accessed as if they were in an array, but any structure\n or variable of any size may be passed as input.\n\n The calling program passes the structure containing the bits,\n which bit to process, and a two byte return code field.  The\n receiving program pretends it's processing a 1,000,000 byte\n array which is used to access the passed structure. That would\n allow 8,000,000 million bits. It can be raised if more are\n needed as the largest single COBOL variable can be 16,000,000 or\n so in size.\n\n Steli Inc. has made its best effort to provide working,\n tested code.  However, nothing is perfect - there may be\n flaws and there certainly could be improvements.  All\n questions, concerns, problems and suggestions are welcome\n and may be sent to C_Hafner@HotMail.Com.\n\n\n1                         SAMPLE TEST PROGRAM                        Page      4\n\n\n The job control language (JCL) provided for COBBITS has a main\n COBOL program calling the SETON, SETOFF, TESTBIT and FLIPBIT\n sub-programs.  It's a standalone, dynamically loaded program\n (uses LOADER rather then linking and executing) that reads a\n test set of commands and their expected result. The passed\n structure is an 80 byte array which is written to the O file\n each time a command is processed (set hex on within SDSF or\n whatever you're using to view the output).  The verified results\n are then DISPLAYed.\n\n The test input is a small but representative set, turning bits\n on and off and checking the results.\n\n\n1                          PACKAGE CONTENTS                          Page      5\n\n\n The files involved specifically with COBBITS are:\n\n     - COBBITS    the COBOL main wrapped in JCL to compile and\n                  execute it\n\n\n-\n-\n-\n-\n-\n-\n-\n-\n                                     COBHEXR\n                          COBOL Hexidecimal Conversion\n                              to a Sequential File\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n March 17, 2001                                         Freeware from Steli Inc.\n1                          TABLE OF CONTENTS                         Page      2\n\n\n INTRODUCTION  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     3\n\n\n SAMPLE TEST PROGRAM   . . . . . . . . . . . . . . . . . . . . . . . . . .     4\n\n\n PACKAGE CONTENTS  . . . . . . . . . . . . . . . . . . . . . . . . . . . .     5\n\n\n1                            INTRODUCTION                            Page      3\n\n\n This document is intended to provide user information for\n converting character strings to their hexidecimal equivalent,\n that is, 'ABC' to 'C1C2C3' etc. Some understanding of Job\n Control Language (JCL) is required as well as knowledge of how\n programs are executed.\n\n COBHEXR is mainframe freeware. Feel free to do with it as you will.\n It's a test program with the built in sub-program.\n\n The calling program passes the input and its length, an output\n field (twice the size of the input), and a two byte return code\n field.  The receiving program checks the length which must be\n greater then zero and less then 5,000.  It then converts the\n string and passes it and a zero return code back.\n\n Steli Inc. has made its best effort to provide working, tested\n code.  However, nothing is perfect - there may be flaws and\n there certainly could be improvements.  All questions, concerns,\n problems and suggestions are welcome at C_Hafner@HotMail.Com.\n\n\n1                         SAMPLE TEST PROGRAM                        Page      4\n\n\n The job control language (JCL) provided for COBHEXR has a main\n COBOL program calling the COBHEXR sub-program.  It's a\n standalone, dynamically loaded program (uses LOADER rather then\n linking and executing) that reads a test set of commands and\n their expected result. The input structure is:\n\n      Columns  1 -  2    Length of input\n\n      Columns  5 - 26    Input\n\n      Columns 29 - 72    Expected return value\n\n For each line of input, COBHEXR is called passing the input\n value. The returned value is checked against the expected value\n and a message is displayed if they're nor equal\n\n The test input is:\n\n    12  ABCDEFGHIJKL            C1C2C3C4C5C6C7C8C9D1D2D3\n\n    01  .                       4B\n\n    12  LKJIHGFEDCBA            D3D2D1C9C8C7C6C5C4C3C2C1\n\n    20  12345678901234567890    F1F2F3F4F5F6F7F8F9F0F1F2F3F4F5F6F7F8F9F0\n\n    04  ~!@#                    A15A7C7B\n\n    10                          40404040404040404040\n\n showing that varying lengths may be passed for the same input area.\n\n\n1                          PACKAGE CONTENTS                          Page      5\n\n\n The files involved specifically with COBHEXR are:\n\n     - COBHEXR    the COBOL main wrapped in JCL to compile and\n                  execute it\n\n\n-\n-\n-\n-\n-\n-\n-\n-\n                                      DETAB\n                           Expand Separator Character\n                                 Delimited File\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n March 12, 2003                                         Freeware from Steli Inc.\n1                          TABLE OF CONTENTS                         Page      2\n\n\n INTRODUCTION  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     3\n\n\n EXECUTION JCL   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     5\n\n\n SAMPLE JCL AND OUTPUT   . . . . . . . . . . . . . . . . . . . . . . . . .     7\n\n\n PACKAGE CONTENTS  . . . . . . . . . . . . . . . . . . . . . . . . . . . .    10\n\n\n1                            INTRODUCTION                            Page      3\n\n\n This document is intended to provide user information for the\n utility to expand separator character delimited data files\n (DETAB).  Some understanding of Job Control Language (JCL) is\n required as well as knowledge of how programs are executed.\n\n DETAB is mainframe freeware. It's available for any use you\n wish to make of it.\n\n DETAB is intended for MVS compatible systems to restructure a\n file containing some special character as a separator.  It can\n examine the file and determine the maximum length of every field\n and then rebuild the file into a new file making every field the\n maximum size, right justifying and zero padding numeric fields\n (keeping the sign, if any, left justified) and left justifying\n alphanumeric fields.\n DETAB will allow the input of a master format that will allow\n overriding the sizes and data types found. When selected, this\n option also checks that numeric fields are in fact always\n numeric and will flag fields that are bigger then specified in\n the format.\n\n It also generates dummy COBOL and Eastrieve copybooks/file\n layouts matching the new file and it generates a data layout\n that may be changed and input into DETAB again as a master\n format.\n\n When in non-master format mode, it will not generate elementary\n variable entries if no data at all was specified within the\n input for a given field.  That is, if the field was of zero\n length every time, delimiters back to back, a note is made of\n zero entry for that field and no COBOL or Easytrieve variable is\n generated.  A field will be generated in the layout output for\n an alphabetic field of zero length.\n\n Up to 1,000 fields may be handled (or the program may be changed\n to allow more).  Any size records of any record format may be\n passed as input and the output file is always a variable file of\n logical record length 27,994 and block size 27,998.  Obviously,\n the actual record sizes are that of the calculated fixed size\n and the resulting file may be copied via sort to a fixed file if\n so desired. But, for reasonableness of programming, the variable\n maximum size was used.\n\n The separator character is passed as a parameter to the program\n and may be any character.  The separator character is printed as\n input plus as its two hex character equivalent and the size of\n the restructured record is also shown.\n\n Once the file has been analyzed and the second phase starts\n generating expanded records, DETAB will check to see that every\n record length is the same. If not, it will generate error\n messages to SYSOUT. Some causes have been having separator\n characters within the data thereby confusing the program and\n forgetting that there was a header or trailer.\n\n1                      INTRODUCTION (Continued)                      Page      4\n\n Steli Inc. has made its best effort to provide working, tested\n code.  However, nothing is perfect - there may be flaws and\n there certainly could be improvements.  All questions, concerns,\n problems and suggestions are welcome.  Please e-mail them to\n C_Hafner@HotMail.Com.\n\n\n1                            EXECUTION JCL                           Page      5\n\n\n The job control language (JCL) for DETAB is:\n\n     //DETAB      EXEC     PGM=DETAB,PARM='%NNNNN',REGION=24M\n     //*                                   ||||||\n     //*  SEPARATOR CHARACTER  ------------+|||||\n     //*  PROCESS HEADER  ------------------+||||\n     //*  PROCESS TRAILER  ------------------+|||\n     //*  MASTER FORMAT AVAILABLE  -----------+||\n     //*  REMOVE NUMERIC DECIMAL POINTS  ------+|\n     //*  PUT SIGN ON LAST DIGIT  --------------+\n\n     //*\n\n     //STEPLIB      DD       DISP=SHR,DSN=Your.Load.Library\n\n     //I            DD       DISP=SHR,DSN=Your.Delimited.File,\n     //             DCB=BUFNO=64\n\n     //MASTER       DD       *\n     FIELD00001                      00001  A  00\n        . . .\n     FIELD00012                      00005  N  03\n\n     //O            DD       DISP=(,CATLG),\n     //             DSN=Your.$$$TEMP.DETAB,\n     //             UNIT=SYSDA,SPACE=(CYL,(0010,0010),RLSE),\n     //             DCB=(RECFM=VB,LRECL=27994,BLKSIZE=27998,BUFNO=64)\n\n     //OCOB         DD       DISP=(,CATLG),\n     //             DSN=Your.$$$TEMP.DETAB.COBOUT,\n     //             UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),\n     //             DCB=(RECFM=FB,LRECL=80)\n\n     //OEZ          DD       DISP=(,CATLG),\n     //             DSN=Your.$$$TEMP.DETAB.EZOUT,\n     //             UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),\n     //             DCB=(RECFM=FB,LRECL=80)\n\n     //LAYOUT       DD       SYSOUT=*,DCB=(RECFM=FB,BLKSIZE=80)\n\n     //SYSOUT       DD       SYSOUT=*,DCB=BLKSIZE=121\n\n     //SYSPRINT     DD       SYSOUT=*\n\n The name of the program may be changed as desired providing\n that the actual program is linked with the appropriate name\n or alias.\n\n REGION is optional.  STEPLIB may be optional if DETAB is\n placed in the system's link list but otherwise simply points to\n where DETAB is stored.\n\n The separator character is provided by the first character of\n the PARM statement. The sample shown above is a percent sign for\n easy visualization.  The next character specifies whether a\n1                      EXECUTION JCL (Continued)                     Page      6\n\n header is in the file and needs to be ignored. The 3rd character\n does the same for a trailer record.\n\n The 4th character of the PARM indicates whether a MASTER format\n is provided which is to override the field sizes found and\n possibly the field types. The MASTER DD card may be left in the\n JCL since it will not be opened if this option is an 'N'.\n\n The 5th PARM character specifies whether numeric fields with\n decimal points should have the decimal point removed. Whether\n they are removed or not, DETAB will always try to align the\n explicit or implicit decimal place.\n\n The 6th PARM position indicates that a field with signs, plus or\n minus found in ANY record within that field, will be rolled onto\n the last character. That is, the last character gets the\n appropriate zone value, { for plus zero, } for minus zero A for\n plus one, J for minus one, etc. If only some of the fields have\n signs, the unsigned foelds will be taken as positive.\n\n The input separator character delimited file is specified to I;\n the O file will contain the expanded data; OCOB and OEZ will\n contain the COBOL and Easytrieve structures.  Note the COBOL and\n Easytrieve layouts should be LRECL 80. The restructured file\n (file O) will be VB/27994/27998 but can be changed as desired.\n\n Note that if some columns are obviously not what you desire, the\n various macros such as DELCOLS, FILLINS and FILLCOLS of File 357\n of the CBTTape will easily insert or remove columns and data.\n\n The SYSOUT file will contain any error or warning messages - if\n there are any, the return code for the job will not be zero.\n SYSPRINT contains the summary counts for the job and LAYOUT will\n contain the structure in a format suitable for changing and\n re-entry as the master format. Using the SE option within SDSF\n will allow you to gather the LAYOUT data and insrt in into a PDS\n as a member.\n\n\n1                        SAMPLE JCL AND OUTPUT                       Page      7\n\n\n An example of the input that may be processed is:\n\n     AAAAA%BBBBBBBBBB%%666666%ZZZ\n\n     AAA%BB%%999999999%ZZZ\n\n     AAAAA%BB%%22%ZZZ\n\n     AAAA%BB%%4444%ZZZ\n\n     A%BB%%1%ZZZ\n\n Given similar JCL to the sample JCL above, the restructured\n output would be:\n\n     AAAAABBBBBBBBBB000666666ZZZ\n\n     AAA  BB        999999999ZZZ\n\n     AAAAABB        000000022ZZZ\n\n     AAAA BB        000004444ZZZ\n\n     A    BB        000000001ZZZ\n\n The print out from the job would be:\n\n     **************************************\n\n     ***  030802 DETAB STATS 095411092  ***\n\n     **************************************\n\n     ***  NUMBER RECORDS READ:            5\n\n     ***  NUMBER RECORDS WRITTEN:         5\n\n     ***  NUMBER ZERO LEN FIELDS:         1\n\n       *  FIELD      3 IS ALWAYS ZERO LENGTH\n\n     ***  SEP_CHAR VALUE RECEIVED:     X'6C' (%)\n\n     ***  OUTPUT RECORD SIZE:            27\n\n The COBOL copybook would be:\n\n     10  POS-00001                        PIC  X(00005).\n\n     10  POS-00006                        PIC  X(00010).\n\n     10  POS-00016                        PIC  9(00009).\n\n     10  POS-00025                        PIC  X(00003).\n\n1                  SAMPLE JCL AND OUTPUT (Continued)                 Page      8\n\n and the Easytrieve layout would be:\n\n     POS-00001                            1       5   A\n\n     POS-00006                            6      10   A\n\n     POS-00016                           16       9   N  00\n\n     POS-00025                           25       3   A\n\n and generated LAYOUT file is:\n\n     FIELD00001                      00005  A  00\n\n     FIELD00002                      00010  A  00\n\n     FIELD00003                      00000  A  00\n\n     FIELD00004                      00009  N  00\n\n     FIELD00005                      00003  A  00\n\n Another example of the input that may be processed is:\n\n     AAAAA%123.4%123%666666%Z\n\n     AAA%2.3%456%999999999%ZZ\n\n     AAAAA%345.6789%789012%22%ZZZ\n\n     AAAA%-45.67% %4444%ZZZZ\n\n     A%0.0%999%1%ZZZZZ\n\n Given similar JCL to the sample JCL above, but with a Y for\n eliminating the decimal point and for rolling signs, the\n restructured output would be:\n\n     AAAAA0123400{123   000666666Z\n\n     AAA  0002300{456   999999999ZZ\n\n     AAAAA0345678I789012000000022ZZZ\n\n     AAAA 0045670}      000004444ZZZZ\n\n     A    0000000{999   000000001ZZZZZ\n\n The print out from the job would be:\n\n     **************************************\n\n     ***  030809 DETAB STATS 140914240  ***\n\n     **************************************\n\n     ***  NUMBER RECORDS READ:            5\n1                  SAMPLE JCL AND OUTPUT (Continued)                 Page      9\n\n\n     ***  NUMBER RECORDS WRITTEN:         5\n\n     ***  NUMBER ZERO LEN FIELDS:         0\n\n     ***  SEP_CHAR VALUE RECEIVED:     X'6C' (%)\n\n     ***  OUTPUT RECORD SIZE:            33\n\n The COBOL copybook would be:\n\n     10  POS-00001                        PIC  X(00005).\n\n     10  POS-00006                        PIC S9(00008)V9(04).\n\n     10  POS-00014                        PIC  X(00006).\n\n     10  POS-00020                        PIC  9(00009).\n\n     10  POS-00029                        PIC  X(00005).\n\n and the Easytrieve layout would be:\n\n     POS-00001                            1       5   A\n\n     POS-00006                            6       8   N  04\n\n     POS-00014                           14       6   A\n\n     POS-00020                           20       9   N  00\n\n     POS-00029                           29       5   A\n\n and generated LAYOUT file is:\n\n     FIELD00001                      00005  A  00\n\n     FIELD00002                      00008  N  04\n\n     FIELD00003                      00006  A  00\n\n     FIELD00004                      00009  N  00\n\n     FIELD00005                      00005  A  00\n\n Please note in the immediately previous example, the second\n field is padded on the right with 0's and gets the sign imposed\n on the last digit, the third field appears to be numeric but the\n 4th record has a blank in that field causing it to be alphabetic\n and left justified, the forth field is numeric but has no signs\n and no decimal places and thus just gets left padded, and the\n last field is 5 bytes padded on the right with blanks.\n\n\n1                          PACKAGE CONTENTS                          Page     10\n\n\n The files involved specifically with DETAB are:\n\n     - DETAB      the PL/I code wrapped in JCL to\n                  compile and link edit it\n\n     - DETAB$     a JCL skeleton for its execution\n\n\n-\n-\n-\n-\n-\n-\n-\n-\n                                 DIRSCNC/DIRSCNQ\n                   and Generate Cards Images Replacing Tokens\n                                 Delimited File\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n September 9, 2003                                      Freeware from Steli Inc.\n1                          TABLE OF CONTENTS                         Page      2\n\n\n INTRODUCTION  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     3\n\n\n EXECUTION JCL   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     4\n\n\n SAMPLE JCL AND OUTPUT   . . . . . . . . . . . . . . . . . . . . . . . . .     6\n\n\n PACKAGE CONTENTS  . . . . . . . . . . . . . . . . . . . . . . . . . . . .     8\n\n\n1                            INTRODUCTION                            Page      3\n\n\n This document is intended to provide user information for the\n paired COBOL and PL/I utilities to read any Partitioned Data Set\n (PDS) directory and replace tokens in a card image input stream\n with member names.  Some knowledge of Job Control Language (JCL)\n is required as well as knowledge of how programs are executed.\n\n DIRSCNC and DIRSCNQ are mainframe freeware, available for any\n use you wish to make of them. They are intended for MVS\n compatible systems to provide the capability to generate a\n stream of card images for each member in a given PDS. Suggested\n uses are generating compile and link jobs, compare (ala SuperC\n or CompareX) steps, or list steps.\n\n The reason behind having both a COBOL and a PL/I version is\n partially to show it could be done and partly to eliminate\n complaints from users of one language who just can't do both :)\n\n Steli Inc. has made its best effort to provide working, tested\n code.  However, nothing is perfect - there may be flaws and\n there certainly could be improvements.  All questions, concerns,\n problems and suggestions are welcome.  Please e-mail them to\n C_Hafner@HotMail.Com.\n\n\n1                            EXECUTION JCL                           Page      4\n\n\n The job control language (JCL) for DIRSCNC and DIRSCNQ is:\n\n    //DIRSCNx    EXEC     PGM=DIRSCNx,REGION=4M\n\n    //STEPLIB      DD       DISP=SHR,DSN=WHATEVER.LOADLIB\n\n    //I            DD       DISP=SHR,DCB=(RECFM=F,LRECL=256,BLKSIZE=256),\n\n    //             DSN=SOME.PDS\n\n    //SYSIN        DD       DATA,DLM=XX\n\n      ########   FIXED 8 BYTE MEMBER NAME\n\n      ????????   VARIABLE MEMBER NAME\n\n    XX\n\n    //SELMEM       DD       *\n\n    FIRST=000001, LAST=999999, FIRSTMEM='        ', LASTMEM='99999999';\n\n    //O            DD         DISP=(,CATLG),\n\n    //             DSN=USERID.OUTPUT.CARD.IMAGES,\n\n    //             UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),\n\n    //             DCB=(RECFM=FB,LRECL=80)\n\n The same JCL works for both DIRSCNC and DIRSCNQ.  The name of\n either program may be changed as desired providing that the\n actual program is linked with the appropriate name or alias.\n\n REGION is optional.  STEPLIB may be optional if the given load\n module is placed in the system's link list but otherwise simply\n points to where the module is stored.\n\n The input PDS is specified by the I DD card.  It may be a load\n library, a JCL library or any PDS. The DCB information is there\n because COBOL had a record size disagreement when processing a\n PDS with LRECL not equal to 0.\n\n The SYSIN file contains the images to be generated for each\n member. Any string of 8 question marks (????????) will be\n replaced by the member name, deleting blanks from the end of the\n name.  Any string of 8 pound sugns (########) will also be\n replaced by the member name but without removing blanks.  The\n samples below show SYSIN having a DLM option. This is only there\n to show JCL could easily be input.\n\n SELMEM allows ranges of members to be specified, either by\n number (e.g. the first 100) or by name (e.g. FRED through GROK).\n The last named options may both be specified as shown, but it\n would make sense to use 1 through 999999 and then a name range,\n1                      EXECUTION JCL (Continued)                     Page      5\n\n or 1 through 100 with blank through 99999999 as the name range.\n\n The O DD is the file where the output will be sent. Since we're\n duplicating card images from SYSIN, this is an 80 byte file.\n\n\n1                        SAMPLE JCL AND OUTPUT                       Page      6\n\n\n An example of JCL that may be used is:\n\n    //***\n\n    //***  CREATE BACKUP IEBCOPY SELECT STATEMENTS\n\n    //***\n\n    //DELETE     EXEC       PGM=IEFBR14\n\n    //SCRATCH      DD         DISP=(MOD,DELETE,DELETE),\n\n    //             DSN=USERID.$$$TEMP.DIRSCNC,\n\n    //             UNIT=SYSDA,SPACE=(TRK,0)\n\n    //***\n\n    //DIRSCNC    EXEC     PGM=DIRSCNC,PARM=NR,REGION=4M\n\n    //STEPLIB      DD       DISP=SHR,DSN=YOUR.LOADLIB\n\n    //I            DD       DISP=SHR,DCB=(RECFM=F,LRECL=256,BLKSIZE=256),\n\n    //             DSN=SOME.PDS.WHERE.YOU.WANT.BKUP.COPIES\n\n    //SYSIN        DD       DATA,DLM=XX\n\n      S  M=((????????,????????O,R))\n\n    XX\n\n    //SELMEM       DD       *\n\n    FIRST=000001, LAST=999999, FIRSTMEM='        ', LASTMEM='99999999';\n\n    //O            DD         DISP=(,CATLG),\n\n    //             DSN=Your.$$$TEMP.DIRSCNC,\n\n    //             UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),\n\n    //             DCB=(RECFM=FB,LRECL=80)\n\n    //***\n\n\n Given that SOME.PDS.WHERE.YOU.WANT.BKUP.COPIES contains members\n AAA, MODGEN2, AKA666 and X, the above step would generate:\n\n      S  M=((AAA,AAAO,R))\n\n      S  M=((MODGEN2,MODGEN2O,R))\n\n      S  M=((AKA666,AKA666O,R))\n1                  SAMPLE JCL AND OUTPUT (Continued)                 Page      7\n\n\n      S  M=((X,XO,R))\n\n Given that none of the original PDS member names were over 7\n characters, these IEBCOPY statements could be used to make back\n up copies of each member.\n\n\n1                          PACKAGE CONTENTS                          Page      8\n\n\n The files involved specifically with ABENDX are:\n\n     - DIRSCNC    the COBOL compile and link JCL for DIRSCNC\n\n     - DIRSCNC$   a JCL skeleton for executing DIRSCNC\n\n     - DIRSCNQ    the PL/I compile and link JCL for DIRSCNQ\n\n     - DIRSCNQ$   a JCL skeleton for executing DIRSCNQ\n\n\n-\n-\n-\n-\n-\n-\n-\n-\n                                     FOREVER\n                    Generate Job Periodically To Update Last\n                      Referenced Date for List of Data Sets\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n April 14, 2000                                         Freeware from Steli Inc.\n1                          TABLE OF CONTENTS                         Page      2\n\n\n INTRODUCTION  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     3\n\n\n FOREVER STRATEGY  . . . . . . . . . . . . . . . . . . . . . . . . . . . .     4\n\n\n EXECUTION REXX EXEC   . . . . . . . . . . . . . . . . . . . . . . . . . .     5\n\n\n FOREVER FILE LAYOUT   . . . . . . . . . . . . . . . . . . . . . . . . . .     6\n\n\n PACKAGE CONTENTS  . . . . . . . . . . . . . . . . . . . . . . . . . . . .     7\n\n\n1                            INTRODUCTION                            Page      3\n\n\n This document is intended to provide user information for the\n utility to update the last referenced date for a list of data\n sets. It's a COBOL program (FOREVER).  Some knowledge of Job\n Control Language (JCL) is required as well as knowledge of how\n programs are executed.\n\n FOREVER is mainframe freeware. It's available for any use you\n wish to make of it. FOREVER is intended for MVS compatible\n systems to provide the capability to identify a file's name from\n within a COBOL program.\n\n Steli Inc. has made its best effort to provide working, tested\n code.  However, nothing is perfect - there may be flaws and\n there certainly could be improvements.  All questions, concerns,\n problems and suggestions are welcome.  Please e-mail them to\n C_Hafner@HotMail.Com.\n\n\n1                          FOREVER STRATEGY                          Page      4\n\n\n Many sites have drop dead dates for files that have not been\n accessed in some time frame, say 3 months. Many organizations\n have data sets which are only accessed on a mid year or even\n yearly basis.\n\n FOREVER is intended to provide some protection by updating the\n last referenced date of a list of files on some periodic time\n frame, say weekly. The program is invoked via REXX code in a\n logon Exec executed daily. It checks for Friday (easily changed\n to any desired day of the week). It then checks to see if it has\n already been run on that day, and either submits the job with\n the executing user's information for job name and notify, or it\n quits. The FOREVER file's disposition is OLD to prevent multiple\n submissions. The job uses IDCAMS PRINT of one record to cause\n the read access. This works against sequential and pertitioned\n data sets as well as VSAM files. It does give an I/O error when\n doing the read against a PDS since it's reading the directory\n trying to use the LRECL of the data set. It makes no never mind\n since the data set is still accessed as desired.\n\n When the job runs, it updates the date in the FOREVER file to the\n current date. Obviously, you may or may not want this run weekly,\n semi-monthly or even monthly may be adequate. That would require\n a code change.\n\n\n1                         EXECUTION REXX EXEC                        Page      5\n\n\n The following REXX Exec code should be placed in an Exec that\n runs every time concerned users logon. It will check for a\n Friday and then check to see if it has already run the job, only\n submitting the job once. Note it passes the executing user ID to\n the program. The actual FOREVER file name and the load module\n library for the program must be changed appropriately.\n\n      /**  FOREVER FILE PROCESSING  **/\n\n         ADDRESS TSO\n\n         \"FREE DD(I O SYSOUT)\"\n\n         \"ALLOC DSN(*) DD(SYSOUT)\"\n\n         \"ALLOC DSN('SomeHLQ.Forever.File') DD(I) OLD\"\n\n         \"ALLOC DD(O) SYSOUT(A) WRITER(INTRDR)\"\n\n         \"CALL 'SomeHLQ.Loadlib(FOREVER)' '\"USERID()\"'\"\n\n         \"FREE DD(I O SYSOUT)\"\n\n\n1                         FOREVER FILE LAYOUT                        Page      6\n\n\n The format is straightforward, the first line has the last run\n date in column 1. Each subsequent card has a data set name in\n column 1. The latter do not have to be in any order.\n\n      20000331 --  ENTER DATA SETS BELOW STARTING EACH IN COLUMN 1\n\n      SYS4.BACKUP.SYSTEM.CLISTS\n\n      SOMEUSER.REALLY.NEEDED.DATA\n\n      ...\n\n\n1                          PACKAGE CONTENTS                          Page      7\n\n\n The file involved specifically with FOREVER is:\n\n     - FOREVER    the COBOL code in JCL to\n                  assemble and link edit it\n\n     - FOREVERX   the REXX Ecec code to be\n                  executed as part of each\n                  user's logon\n\n\n-\n-\n-\n-\n-\n-\n-\n-\n                                     GETDSN\n                       Get Data Set Name from within COBOL\n                      Referenced Date for List of Data Sets\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n March 23, 2000                                         Freeware from Steli Inc.\n1                          TABLE OF CONTENTS                         Page      2\n\n\n INTRODUCTION  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     3\n\n\n SAMPLE PROGRAM CALLING GETDSN   . . . . . . . . . . . . . . . . . . . . .     4\n\n\n PACKAGE CONTENTS  . . . . . . . . . . . . . . . . . . . . . . . . . . . .     5\n\n\n1                            INTRODUCTION                            Page      3\n\n\n This document is intended to provide user information for the\n utility to retrieve the data set name for a given file from\n within a COBOL program (GETDSN).  Some knowledge of Job Control\n Language (JCL) is required as well as knowledge of how programs\n are executed.\n\n GETDSN is mainframe freeware. It's available for any use you\n wish to make of it. GETDSN is intended for MVS compatible\n systems to provide the capability to identify a file's name from\n within a COBOL program.\n\n Steli Inc. has made its best effort to provide working, tested\n code.  However, nothing is perfect - there may be flaws and\n there certainly could be improvements.  All questions, concerns,\n problems and suggestions are welcome.  Please e-mail them to\n C_Hafner@HotMail.Com.\n\n\n1                    SAMPLE PROGRAM CALLING GETDSN                   Page      4\n\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  TRYGET.\n      *COBOL SAMPLE CODE INVOKING GETDSN\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT I ASSIGN TO I.\n           SELECT J ASSIGN TO J.\n       DATA DIVISION.\n       FILE SECTION.\n       FD  I\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  INPUT-REC    PIC X(00080).\n       FD  J\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  INPUT-REC2   PIC X(00080).\n       WORKING-STORAGE SECTION.\n       01  WS-DSNS.\n           05  I-NAME          PIC X(44).\n           05  I-MEMBER        PIC X(08).\n           05  J-NAME          PIC X(44).\n           05  J-MEMBER        PIC X(08).\n       PROCEDURE DIVISION.\n       0000-MAIN.\n              DISPLAY '***  TOP OF PROGRAM  ***'\n\n              OPEN INPUT I, J\n\n              CALL 'GETDSN' USING I, I-NAME, I-MEMBER\n              DISPLAY 'THE DATA SET ASSOCIATED WITH FILE I IS ' I-NAME\n              DISPLAY 'THE MEMBER ASSOCIATED WITH FILE I IS   ' I-MEMBER\n\n              CALL 'GETDSN' USING J, J-NAME, J-MEMBER\n              DISPLAY 'THE DATA SET ASSOCIATED WITH FILE J IS ' J-NAME\n              DISPLAY 'THE MEMBER ASSOCIATED WITH FILE J IS   ' J-MEMBER\n\n              CLOSE I, J\n\n              DISPLAY '***  END OF PROGRAM  ***'\n              GOBACK\n              .\n\n\n1                          PACKAGE CONTENTS                          Page      5\n\n\n The file involved specifically with GETDSN is:\n\n     - GETDSN     the assembler code in JCL to\n                  assemble and link edit it\n\n\n-\n-\n-\n-\n-\n-\n-\n-\n                                      PAGES\n                               Pull Selected Pages\n                      Referenced Date for List of Data Sets\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n March 17, 2000                                         Freeware from Steli Inc.\n1                          TABLE OF CONTENTS                         Page      2\n\n\n INTRODUCTION  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     3\n\n\n EXECUTION JCL   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     4\n\n\n SAMPLE JCL AND OUTPUT   . . . . . . . . . . . . . . . . . . . . . . . . .     6\n\n\n PACKAGE CONTENTS  . . . . . . . . . . . . . . . . . . . . . . . . . . . .     7\n\n\n1                            INTRODUCTION                            Page      3\n\n\n This document is intended to provide user information for\n retrieving logical pages from a carriage controlled sequential\n file (PAGES).  Given a sequential file containing 5,000 pages,\n that has ASCII carriage controlled lines, PAGES will allow you\n to pull specific pages from the front, middle, end or a specific\n range.  PAGES will do this easily in one run saving paper and/or\n having to customize code.  Some understanding of Job Control\n Language (JCL) is required as well as knowledge of how programs\n are executed.\n\n PAGES is mainframe freeware.  You may use, change or ignore\n it, as you want.\n\n Steli Inc. has made its best effort to provide working,\n tested code.  However, nothing is perfect - there may be\n flaws and there certainly could be improvements.  All\n questions, concerns, problems and suggestions are welcome\n and may be sent to C_Hafner@HotMail.Com.\n\n\n1                            EXECUTION JCL                           Page      4\n\n\n The job control language (JCL) for PAGES is:\n\n      //SELPAGES   EXEC     PGM=PAGES   ( ,REGION=4M )\n\n      //INFILE       DD       DISP=SHR, ( DCB=BUFNO=32, )\n\n      //             DSN=...\n\n        FIRST=50,     LAST=50,      MIDDLE=-1,     FROM=-1,      TO=-1;\n\n      //SYSPRINT     DD       SYSOUT=*\n\n      //OUTFILE      DD       DSN=...,\n\n      //             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(05,02),RLSE),\n\n      //             DCB=(RECFM=FBA,LRECL=...,BLKSIZE=0,BUFNO=32)\n\n      //STEPLIB      DD       DISP=SHR,DSN=...\n\n Optional control language elements are shown in parentheses.\n The name of the program  may be changed as desired providing\n that the actual program is linked with the appropriate name or\n alias.  REGION is optional - the default region size may be more\n then adequate depending on your local standards.\n\n INFILE contains the original ASCII carriage controlled data.\n That is, there's a '1' in column one to indicate the start of a\n new page. The very first line in the file will be recognized as\n the starting page, page 1, whether there is a '1' there or not.\n The BUFNO parameter is useful to speed processing but not\n necessary.\n\n The SYSIN file contains the specification of the page numbers to\n be selected from INFILE. The \"null\" indicator, -1, is only shown\n to provide a place holder for subsequent runs - leaving those\n parameters off will not hurt. They are free form but do need to\n be terminated with a semicolon (;).\n\n FIRST indicates the number of pages to be selected from the\n front of INFILE, MIDDLE from the center section, and LAST from\n the end. FROM and TO determine specific pages to be pulled.  All\n may be specified at one time as shown in the example below.\n\n SYSPRINT will contain a display of the total number of pages in\n INFILE, the total number of lines and which and how many pages\n were selected.\n\n OUTFILE receives the selected pages. DCB information may be hard\n coded as shown or may refer back to the cataloged input file.\n Again, BUFNO may help performance if the output is still rather\n large.\n\n STEPLIB may be optional if PAGES is placed in the system's link\n list but otherwise simply points to where PAGES is stored.\n1                      EXECUTION JCL (Continued)                     Page      5\n\n\n\n1                        SAMPLE JCL AND OUTPUT                       Page      6\n\n\n A sample of what might be submitted is:\n\n      //CULL       EXEC     PGM=PAGES,REGION=4M\n\n      //INFILE       DD       DISP=SHR,DCB=BUFNO=32,\n\n      //             DSN=USERID.SOME.LARGE.PRINT.FILE\n\n        FIRST=11,     LAST=04,      MIDDLE=20,     FROM=42,      TO=43;\n\n      //SYSPRINT     DD       SYSOUT=*\n\n      //OUTFILE      DD       DSN=USERID.THE.CULLED.FILE,\n\n      //             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(05,02),RLSE),\n\n      //             DCB=(USERID.SOME.LARGE.PRINT.FILE,BUFNO=32)\n\n      //STEPLIB      DD       DISP=SHR,DSN=SYS4.USERLIB\n\n Assuming there were 500 6 line pages on the input file, the\n SYSPRINT would look like:\n\n      **************************************\n      ***  YYMMDD STATISTICS HHMMSSTTT  ****\n      **************************************\n\n      ** TOTAL PAGES ON FILE:            500\n\n      ** TOTAL RECORDS ON FILE:        3,000\n\n      ** FIRST PAGES SELECTED:            11\n\n      ** MIDDLE PAGES SELECTED:           20\n\n      ** LAST PAGES SELECTED:              4\n\n      ** PAGE RANGE SELECTED FROM:        42\n\n      **                      TO:         43\n\n      ** TOTAL PAGES SELECTED:            37\n\n      ** TOTAL LINES SELECTED:           222\n\n where YYMMDD would contain the run date and HHMMSSTTT the run\n time. Note the DCB information for the output file was acquired\n from the input file and BUFNO was also specified.\n\n\n1                          PACKAGE CONTENTS                          Page      7\n\n\n The files involved specifically with PAGES are:\n\n     - PAGES      the PL/I code wrapped in JCL to compile\n                  and link edit it\n\n     - PAGES$     a JCL skeleton for its execution\n\n\n-\n-\n-\n-\n-\n-\n-\n-\n                                     PDSLIST\n                              Partitioned Data Set\n                                  List Utility\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n September 14, 2000                                     Freeware from Steli Inc.\n1                          TABLE OF CONTENTS                         Page      2\n\n\n INTRODUCTION  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     3\n\n\n VERSION UPDATE  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     5\n\n\n EXECUTION JCL   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     6\n\n\n CONTROL CARDS   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     7\n\n\n CHANGING DEFAULTS   . . . . . . . . . . . . . . . . . . . . . . . . . . .     9\n\n\n PRINTABLE CHARACTER TRANSLATION   . . . . . . . . . . . . . . . . . . . .    10\n\n\n SAMPLE JCL  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    11\n\n\n SAMPLE OUTPUT   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    12\n\n\n PACKAGE CONTENTS  . . . . . . . . . . . . . . . . . . . . . . . . . . . .    14\n\n\n1                            INTRODUCTION                            Page      3\n\n\n This document is intended to provide user information for\n the Partitioned Data Set List utility (PDSLIST). Some\n understanding of Job Control Language (JCL) is required as\n well as knowledge of how programs are executed.\n\n PDSLIST is mainframe freeware.  You may do anything you want\n with it.\n\n PDSLIST is intended for MVS compatible systems to print the\n members of one or more partitioned data sets (PDS's) in\n alphabetical order.  It will process concatenated PDS's up\n to the number currently allowed by the operating system and\n data of any size or type, fixed, variable or unformatted.\n Options may be specified through free form control cards.\n\n The member data is displayed in the middle 100 characters of\n a 120 byte print line and lengths are printed in the first 5\n bytes of the starting  line for fixed data over 100 bytes\n long and for all variable or unformatted data.  An ASCII\n control character prefixes the 120 characters to minimize\n output.\n\n PDSLIST through its options will also:\n\n    - Provide an index indicating where each member resides\n      and the page number on which the member begins printing\n      (INDEX)\n\n    - Provide only the index, not printing any member data\n      (INDEX(ONLY))\n\n    - Show only a portion of each member (FIRST(.))\n\n    - Display duplicate members, i.e. show members with the\n      same name that are in one or more PDS's in the concatenation\n      (DUPS)\n\n    - Show only members that have duplicates within the\n      concatenation (DUPS(ONLY)\n\n    - Allow a range of members to be selected  (>MEMBER(.)\n      and <MEMBER(.))\n\n    - Display member data as both characters and their hex\n      equivalent (HEX)\n\n    - Display a footing on each page (FOOTING(.))\n\n    - Print each member on a new page or separated by a few\n      blank lines (EJECT)\n\n    - Indicate whether a member is an alias of another member\n      (ALIAS)\n\n    - List the options specified as well as the defaulted\n1                      INTRODUCTION (Continued)                      Page      4\n\n      ones (OPTIONS)\n\n    - Change the block size of the printed file (BLKSIZE(.))\n\n    - Cause characters sent to the print file to be only\n      printable ones (TRANSLATE)\n\n\n1                           VERSION UPDATE                           Page      5\n\n\n PDSLIST Version 2 contains a number of changes, mostly internal.\n It is backward compatible with minor output differences.  The\n updates are:\n\n    - The program is now reentrant and will run above the 16\n      meg line (AMODE 31 and RMODE ANY)\n\n    - The code and the documentation have been heavily\n      revised for clarity and maintainability.  The ability to\n      change option defaults and DD names has been enhanced by\n      placing them all in one area and automating their\n      implementation throughout the code (via SETC and SETA\n      statements)\n\n    - Display the options used\n\n    - Show whether a member is an alias\n\n    - Allow SYSIN DD card to be omitted\n\n    - Make HEX and TRANSLATE compatible in same run\n\n    - Display footing on every page\n\n    - Use specified page size for all printed output\n\n    - Show only duplicate members in index for DUPS(ONLY)\n\n These changes reflect all the comments made so far to Steli Inc.\n for PDSLIST.  Thanks go to several people who actually read the\n documentation and suggested clarifications as well as to the\n folks who suggested the changes and to those who pointed out the\n problems.  There's a fix to the reentrant code, thanks to Tom\n Esela, that corectly initilaized the dynamic work area\n preventing problems when running from an APF (linklist) library.\n\n Steli Inc. has made its best effort to provide working, tested\n code.  However, nothing is perfect - there may be flaws and\n there certainly could be improvements.  All questions, concerns,\n problems and suggestions are welcome and may be sent to\n C_Hafner@HotMail.Com.\n\n\n1                            EXECUTION JCL                           Page      6\n\n\n The job control language (JCL) for PDSLIST is:\n\n           //   EXEC   PGM=PDSLIST ( ,REGION=4M )\n\n           //STEPLIB     DD   DISP=SHR,DSN=...\n\n           //SYSPRINT    DD   SYSOUT=*\n\n           //SYSUT1      DD   DISP=SHR,DSN=PDS1\n\n         ( //            DD   DISP=SHR,DSN=PDS2 )\n\n         (    ...   optionally, as many         )\n\n         (    ...      concatenated PDS's       )\n\n         (    ...         as allowed in MVS/ESA )\n\n         ( //SYSIN       DD   *                 )\n\n         (        control cards . . .           )\n\n Optional control language elements are shown in parentheses.\n The name of the program  may be changed as desired providing\n that the actual program is linked with the appropriate name or\n alias.\n\n REGION is optional but PDSLIST requires approximately 192,000\n bytes as well as 20 bytes for each member (system required\n resources may increase this amount).  In most cases the default\n region size is adequate to meet these requirements.  STEPLIB may\n be optional if PDSLIST is placed in the system's link list but\n otherwise simply points to where PDSLIST is stored.\n\n The SYSPRINT file may be directed to any output class or may be\n sent to a new or existing file.  The DCB attributes of SYSPRINT\n will be record format FBA and LRECL 121.  The BLKSIZE may be set\n through the BLKSIZE control card option within PDSLIST but will\n default to 121.\n\n SYSUT1 points to the one or more PDS's to be processed.  SYSIN\n contains control information and may be omitted, set to //SYSIN\n DD DUMMY or simply be empty.  Full control card descriptions are\n shown below.\n\n The DD names and SYSPRINT block size may be changed as desired\n in the defaults section of the source code.  If an incorrect\n name is specified, the program will terminate returning the code\n received from opening the data set (the system will generally\n indicate the missing DD name).\n\n\n1                            CONTROL CARDS                           Page      7\n\n\n The control card values may be specified free form in the first\n 72 columns of the records in the SYSIN file in any order and may\n be separated by commas, blanks or simply concatenated together.\n Each option must be contained on one input line, however, as\n continuation is not supported. Blank lines may be interspersed\n as desired for readability.\n\n The specific keywords are sought and anything else is ignored.\n Keywords must be in upper case but any FOOTING data may be any\n case.  Also, options which require parentheses but where no\n closing parenthesis is supplied will be ignored, as will values\n which require numeric values but are not supplied as such.  The\n last specified value is the one used if the same option is\n repeated.  To change the defaults, please see the section below\n called CHANGING DEFAULTS.\n\n Control card parameters are:\n\n      ALIAS     Show whether the member is an alias in the\n                header line and in the index entry.  The\n                default is NOALIAS\n\n      BLKSIZE(#)  Specify the block size to be used for\n                the SYSPRINT file output.  It must be a\n                multiple of 121.  The default is\n                BLKSIZE(121).\n\n      DUPS      Indicate that members with duplicate\n                names in concatenated PDS's are to be printed\n                and shown in the index.  The alternative,\n                NODUPS, is the default.  DUPS(ONLY) may be\n                specified to have only the members that exist\n                as duplicates within the concatenation listed\n                and/or shown in the index.\n\n      EJECT     Causes the printing of each member to\n                start at the top of a new page. NOEJECT will\n                cause two lines to be skipped before printing\n                the next member and is the default.\n\n      FIRST(#)  Only the first # of lines of each member\n                will be printed.  The default is to print\n                every line of a member.  Note this is NOT\n                record count, but literally prints the\n                indicated number of lines.\n\n      FOOTING(x)  Indicates that the string x should be\n                placed two lines from the end of each page.\n                The open parenthesis starts the string and\n                the close parenthesis terminates the string.\n                The default is no footing.\n\n      HEX       Causes the member data to be printed as usual\n                and then followed by 2 additional lines, the\n                first showing the first character of the hex\n1                      CONTROL CARDS (Continued)                     Page      8\n\n                representation of the character above and the\n                second line showing the next hex character.\n                NOHEX is the default.\n\n      INDEX     Specifies an index of member names is to\n                be printed at the end of the listing.  This\n                list will show all members in the selected\n                range including those not printed (e.g. if\n                NODUPS is chosen).  NOINDEX is the default.\n                INDEX(ONLY) indicates that only the index is\n                to be printed and the actual member data is\n                not to be.\n\n      LINECNT(#)  Indicates the SYSPRINT page size.\n                LINECNT(58) is the default.  This value must\n                be numeric and greater then 4.\n\n      OPTIONS   Causes the specified and default options to\n                be displayed.  NOOPTIONS is the default.\n\n      TRANSLATE Causes all printed lines to be converted on\n                a character by character basis to printable\n                characters or blanks.   The default is to\n                send the characters as they are to the\n                printer, namely NOTRANSLATE.  Please see the\n                section below titled PRINTABLE CHARACTER\n                TRANSLATION to see the default translation.\n\n      VARSEQ    Specifies that the first 8 characters of\n                variable data, if numeric, are to be treated\n                as sequence numbers and  printed in columns\n                113 through 120 of the print line.  Only the\n                data following the eight bytes is then\n                printed. The default is VARSEQ.  NOVARSEQ\n                would cause all of the record to be printed\n                as data.\n\n      >MEMBER(member) Indicates the 1 to 8 byte member name,\n                to be used as an lower bound - no member\n                alphabetically lower then this member will be\n                printed.  The default is to print the first\n                member and all following members.\n\n      <MEMBER(member) Indicates the 1 to 8 byte member name,\n                to be used as an upper bound - no member\n                alphabetically higher then this member will\n                be printed.  The default is to print all\n                members from the starting member onward.\n\n\n1                          CHANGING DEFAULTS                         Page      9\n\n\n To change the default behavior of PDSLIST, simple changes may be\n made to the assembler source code and the program will need to\n be re-assembled and re-linked.\n\n To change the default, simply find the variable in the PDSLIST\n source as shown below and change it from `N' to `Y' or vice\n versa.  BLKSIZE, FIRST and LINECNT require a numeric value.  The\n same concept applies to the DD names shown.\n\n ************************************************************\n *    DEFAULT OPTION VALUES                                 *\n ************************************************************\n\n &DDOPTS       SETC  'SYSIN'      DDNAME FOR OPTIONS FILE\n &DDPDS        SETC  'SYSUT1'     DDNAME FOR PARTITIONED d/s\n &DDPRINT      SETC  'SYSPRINT'   DDNAME FOR LISTING FILE\n\n &DEFPGSZ      SETA  58           DATA PAGE SIZE DEFAULT\n &DEF1ST       SETA  999999999    FIRST OPTION CHOSEN DEFAULT\n\n &DEFALIAS     SETC  'N'          ALIAS DEFAULT\n &DEFBLKSI     SETA  121          SYSPRINT BLOCK SIZE DEFAULT\n &DEFDUPS      SETC  'N'          DUPS DEFAULT\n &DEFDUPSO     SETC  'N'          DUPS ONLY DEFAULT\n &DEFEJECT     SETC  'N'          EJECT DEFAULT\n &DEFFOOT      SETC  'N'          FOOTER USED\n &DEFHEX       SETC  'N'          HEX DEFAULT\n &DEFINDX      SETC  'N'          INDEX DEFAULT\n &DEFINDXO     SETC  'N'          INDEX ONLY DEFAULT\n &DEFOPTNS     SETC  'N'          LIST OPTIONS DEFAULT\n &DEFTRANS     SETC  'N'          TRANSLATE DEFAULT\n &DEFVAR       SETC  'Y'          VARIABLE SEQUENCE DEFAULT\n                       00000000\n &DEFMEMGT     SETC   '00000000'  FIRST MEMBER SELECTED (HEX 0'S)\n                       FFFFFFFF\n &DEFMEMLT     SETC   'FFFFFFFF'  LAST MEMBER SELECTED (HEX F'S)\n\n\n1                   PRINTABLE CHARACTER TRANSLATION                  Page     10\n\n\n The table below is used to translate member data sent to\n SYSPRINT when the TRANSLATE option is selected.  Numbers,\n upper and lower case characters and the primary punctuation\n characters print as expected.  Other characters are changed\n to blanks.\n\n PRTABLE   DC    XL16'40404040404040404040404040404040' 00 - 0F\n\n           DC    XL16'40404040404040404040404040404040' 10 - 1F\n\n           DC    XL16'40404040404040404040404040404040' 20 - 2F\n\n           DC    XL16'40404040404040404040404040404040' 30 - 3F\n\n           DC    XL16'40404040404040404040404B4C4D4E4F' 40 - 4F\n\n           DC    XL16'504040404040404040405A5B5C5D5E5F' 50 - 5F\n\n           DC    XL16'606140404040404040406A6B6C6D6E6F' 60 - 6F\n\n           DC    XL16'404040404040404040407A7B7C7D7E7F' 70 - 7F\n\n           DC    XL16'40818283848586878889404040404040' 80 - 8F\n\n           DC    XL16'40919293949596979899404040404040' 90 - 9F\n\n           DC    XL16'4040A2A3A4A5A6A7A8A9404040404040' A0 - AF\n\n           DC    XL16'B0404040404040404040BABB40404040' B0 - BF\n\n           DC    XL16'C0C1C2C3C4C5C6C7C8C9404040404040' C0 - CF\n\n           DC    XL16'D0D1D2D3D4D5D6D7D8D9404040404040' D0 - DF\n\n           DC    XL16'E040E2E3E4E5E6E7E8E9404040404040' E0 - EF\n\n           DC    XL16'F0F1F2F3F4F5F6F7F8F9404040404040' F0 - FF\n\n The table above may  be changed by finding the relative position\n of the character and replacing it with whatever character is\n desired or a blank.\n\n\n1                             SAMPLE JCL                             Page     11\n\n\n An example of JCL that may be used is:\n\n      //LISTPRCS  EXEC  PGM=PDSLIST,REGION=4M\n\n      //SYSIN       DD    *\n\n            DUPS          EJECT          INDEX\n\n            FOOTING(- Top Secret & Confidential & Highly Unlikely -)\n\n      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB\n\n      //SYSPRINT     DD        SYSOUT=C\n\n      //SYSUT1       DD        DISP=SHR,DSN=SYS1.PROCLIB\n\n      //             DD        DISP=SHR,DSN=PLI.V2R3M0.PROCLIB\n\n      //             DD        DISP=SHR,DSN=SYS4.USER.PROCLIB\n\n The above step will print all the members of the 3 PROCLIB's\n including duplicates, a data set list, and an index of all the\n members with the footing shown.  Note the control card data is\n free form and does not need to be aligned in any way.\n\n Another example is:\n\n      //LISTPDSS  EXEC  PGM=PDSLIST\n\n           INDEX(ONLY)    DUPS\n\n      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB\n\n      //SYSPRINT     DD        SYSOUT=*\n\n      //SYSUT1       DD        DISP=SHR,DSN=APPLIC.LOADLIB1\n\n      //             DD        DISP=SHR,DSN=APPLIC.LOADLIB2\n\n      //             DD        DISP=SHR,DSN=APPLIC.LOADLIB3\n\n      //             DD        DISP=SHR,DSN=APPLIC.LOADLIB4\n\n This step will provide an index of the members of the four load\n module libraries input.  In this case it is supposed that the\n data itself is not of interest (load modules don't normally list\n nicely).\n\n\n1                            SAMPLE OUTPUT                           Page     12\n\n\n Given the following 2 partitioned data sets, PDS.A and PDS.B,\n which contain:\n\n      PDS.A\n           Member A -- 10 lines of 10 A's\n           Member B -- 10 lines of 10 B's\n           Member C -- 10 lines of 10 C's\n      PDS.B\n           Member B --10 lines 0f 10 2's\n           Member D --10 lines of 10 D's\n\n The JCL immediately following will produce the results below:\n\n      //PDSLIST    EXEC     PGM=PDSLIST,REGION=4M\n\n      //SYSIN        DD       *\n\n           DUPS           EJECT               INDEX\n\n           FIRST(03)\n\n           FOOTING( - - -  Sample output from PDSLIST  - - - )\n\n      /STEPLIB       DD       DISP=SHR,DSN=USER.LOADLIB\n\n      //SYSPRINT     DD       SYSOUT=*\n\n      //SYSUT1       DD       DISP=SHR,DSN=PDS.A\n\n      //             DD       DISP=SHR,DSN=PDS.B\n\n The header lines on each page are underlined - we left NOEJECT\n on to minimize paper usage and the output shown reflects the\n request to only print the first 3 lines of each member.\n\n      DATE=98/318   VOL=TEST27   DSN=PDS.A   MEMBER=A   PAGE 1\n      --------------------------------------------------------\n      AAAAAAAAAA\n      AAAAAAAAAA\n      AAAAAAAAAA\n                     - - -  Sample output from PDSLIST  - - -\n\n      DATE=98/318   VOL=TEST27   DSN=PDS.A   MEMBER=B   PAGE 2\n      --------------------------------------------------------\n      BBBBBBBBBB\n      BBBBBBBBBB\n      BBBBBBBBBB\n                     - - -  Sample output from PDSLIST  - - -\n\n      DATE=98/318   VOL=TEST29   DSN=PDS.B   MEMBER=B   PAGE 3\n      --------------------------------------------------------\n      2222222222\n      2222222222\n      2222222222\n\n1                      SAMPLE OUTPUT (Continued)                     Page     13\n\n                     - - -  Sample output from PDSLIST  - - -\n\n      DATE=98/318   VOL=TEST27   DSN=PDS.A   MEMBER=C   PAGE 4\n      --------------------------------------------------------\n      CCCCCCCCCC\n      CCCCCCCCCC\n      CCCCCCCCCC\n\n                     - - -  Sample output from PDSLIST  - - -\n\n      DATE=98/318   VOL=TEST29   DSN=PDS.B   MEMBER=D   PAGE 5\n      --------------------------------------------------------\n      DDDDDDDDDD\n      DDDDDDDDDD\n      DDDDDDDDDD\n\n                     - - -  Sample output from PDSLIST  - - -\n\n\n\n      PDS#      DATA SET NAME                 VOLUME\n      -----------------------------------------------------\n      1              PDS.A                           TEST27\n      2              PDS.B                           TEST29\n\n                     - - -  Sample output from PDSLIST  - - -\n\n\n      MEMBER   PAGE#   PDS     MEMBER   PAGE#   PDS . . .\n      -----------------------------------------------------\n      A          1      1\n      B          2      1\n      B          3      2\n      C          4      1\n      D          5      2\n\n                     - - -  Sample output from PDSLIST  - - -\n\n\n1                          PACKAGE CONTENTS                          Page     14\n\n\n The PDSLIST package consists of:\n\n     - PDSLIST    the assembler source code wrapped in JCL\n                  to assemble and link it\n\n     - PDSLIST$   sample execution JCL\n\n PDSLIST was assembled using IBM's High Level Assembler.\n Assembler H may be used although any blank lines in the source\n will have to be removed.  The JCL supplied in PDSLIST does not\n use procedures since many have local changes precluding use of\n specific step names for DD name over-rides.  To change from High\n Level Assembler to Assembler H, simply change the program name\n from ASMA90 to IEV90.  The JCL will accommodate either.\n\n\n-\n-\n-\n-\n-\n-\n-\n-\n                                    PDSMATCH\n                              Partitioned Data Set\n                                  Match Utility\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n November 04, 1999                                      Freeware from Steli Inc.\n1                          TABLE OF CONTENTS                         Page      2\n\n\n INTRODUCTION  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     3\n\n\n EXECUTION JCL   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     4\n\n\n SAMPLE JCL  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     5\n\n\n SAMPLE OUTPUT   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     6\n\n\n PACKAGE CONTENTS  . . . . . . . . . . . . . . . . . . . . . . . . . . . .     7\n\n\n1                            INTRODUCTION                            Page      3\n\n\n This document is intended to provide user information for the\n Partitioned Data Set Match utility (PDSMATCH).  Some\n understanding of Job Control Language (JCL) is required as well\n as knowledge of how programs are executed.\n\n PDSMATCH is mainframe software obtained from the CBTTAPE online\n internet site.  This version of PDSMATCH has been modified from\n the CBTTAPE version to compare member data in addition to\n directory statistics and member names.  This version has been\n sent to the original provider.\n\n This program compares the directories of two partitioned data\n sets and prints a report showing which members match and which\n members do not match or are not present in both directories.\n Members are said to match if their names are the same.  If\n PARM=USER, members match if they have the same name and all the\n statistics in their directory entries are equal (except fields\n containing TTR track addresses). If PARM=DATA, they must have\n the same name and their data must be the same.\n\n PDSMATCH through its PARM specified option specifies which\n compare option will be used.  If PARM=EQO, only members that\n match will be listed.  If PARM=NEO, only members that dont match\n will be listed.  If the default is taken, all members will be\n listed for both libraries.\n\n If PARM=USER, members that are present in both libraries will be\n compared for matching statistics.  Statistics of up to 62 bytes\n of data in the directory entry which is put there by the linkage\n editor, SPF edit, and others.  Note, with PARM=USER, if two\n members have the same name and neither has any userdata, they\n are treated as unequal, with a unique message for this case.\n\n If PARM=DATA members that are present in both libraries will be\n compared for matching data.  if two members have the same name\n and both are empty, they are treated as unequal, with a unique\n message for this case.\n\n Steli Inc. has made its best effort to provide working, tested\n code.  However, nothing is perfect - there may be flaws and\n there certainly could be improvements.  All questions, concerns,\n problems and suggestions are welcome and may be sent to\n C_Hafner@HotMail.Com.\n\n\n1                            EXECUTION JCL                           Page      4\n\n\nThe job control language (JCL) for PDSMATCH is:\n\n           //   EXEC   PGM=PDSMATCH ( ,REGION=4M )\n\n           //*                PARM=EQO  TO SHOW EQUALS ONLY\n\n           //*                PARM=NEO  TO SHOW UNMATCHED ONLY\n\n           //*                PARM=USER TO SHOW STAT DIFFERENCES\n\n           //*                PARM=DATA TO SHOW DATA DIFFERENCES\n\n           //STEPLIB     DD   DISP=SHR,DSN=...\n\n           //SYSPRINT    DD   SYSOUT=*\n\n           //SYSLIB1     DD   DISP=SHR,DSN=PDS1\n\n           //SYSLIB2     DD   DISP=SHR,DSN=PDS2\n\n Optional control language elements are shown in parentheses.\n The name of the program  may be changed as desired providing\n that the actual program is linked with the appropriate name or\n alias.\n\n REGION is optional but PDSMATCH requires approximately 280,000\n bytes.  In most cases the default region size is adequate to\n meet these requirements.  STEPLIB may be optional if PDSMATCH is\n placed in the system's link list but otherwise simply points to\n where PDSMATCH is stored.\n\n The SYSPRINT file may be directed to any output class or may be\n sent to a new or existing file.  The DCB attributes of SYSPRINT\n will be record format FBA and LRECL 121.  SYSLIB points to the\n PDS to be processed.\n\n1                             SAMPLE JCL                             Page      5\n\n\n An example of JCL that may be used is:\n\n      //COMPARE   EXEC  PGM=PDSMATCH,REGION=4M,PARM=DATA\n\n      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB\n\n      //SYSPRINT     DD        SYSOUT=C\n\n      //SYSLIB1      DD        DISP=SHR,DSN=A.PROCLIB\n\n      //SYSLIB2      DD        DISP=SHR,DSN=A.PROCLIB.BACKUP\n\n The above step will compare the members and the data of members\n with the same name.\n\n Another example is:\n\n      //COMPARE   EXEC  PGM=PDSMATCH,REGION=4M,PARM=NEO\n\n      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB\n\n      //SYSPRINT     DD        SYSOUT=C\n\n      //SYSLIB1      DD        DISP=SHR,DSN=A.PROCLIB\n\n      //SYSLIB2      DD        DISP=SHR,DSN=A.PROCLIB.BACKUP\n\n This step will provide a list of the members not in both\n libraries.\n\n\n1                            SAMPLE OUTPUT                           Page      6\n\n\n The following shows the results of a PDSMATCH run against a REXX\n CLIST library and its backup library with option DATA.\n\n    --- PDSMATCH --- PDS DIRECTORY COMPARE UTILITY ---\n\n    CRITERIA FOR MATCHING IS MEMBER NAME AND THE ACTUAL MEMBER DATA\n    (SPF STATISTICS ARE NOT COMPARED).\n\n    LIBRARY1 - SUCAHAF.CURR.CLIST ON KLPSF8\n    LIBRARY2 - SUCAHAF.CURR.CBKUP ON KK2SF9\n\n                         @@BOFA01  MEMBER IN LIBRARY2 ONLY\n\n                         @TIME     MEMBER IN LIBRARY2 ONLY\n\n                         @TODO     MEMBER IN LIBRARY2 ONLYONLY\n\n    ADDDOTSL             ADDDOTSL\n\n    ADDFLAGS             ADDFLAGS\n\n                         ADD0D0A   MEMBER IN LIBRARY2 ONLY\n\n                         ADP2CLT   MEMBER IN LIBRARY2 ONLY\n\n    ALLMEM               ALLMEM\n\n    ALLMEMC              ALLMEMC\n\n    ALLMEMF              ALLMEMF\n\n                         ALLOC     MEMBER IN LIBRARY2 ONLY\n\n                     . . . . .\n\n\n1                          PACKAGE CONTENTS                          Page      7\n\n\n PDSMATCH files in this library are:\n\n     - PDSMATCH   the assembler source code wrapped in JCL\n                  to assemble and link it and the PDSCOMP\n                  program\n\n     - PDSMATC$   sample execution JCL\n\n PDSMATCH was assembled using IBM's High Level Assembler.\n Assembler H may be used although any blank lines in the source\n will have to be removed.  The JCL supplied in LISTASM does not\n use procedures since many have local changes precluding use of\n specific step names for DD name over-rides.  To change from High\n Level Assembler to Assembler H, simply change the program name\n from ASMA90 to IEV90.  The JCL will accommodate either.\n\n\n-\n-\n-\n-\n-\n-\n-\n-\n                                    PDSPUNCH\n                              Partitioned Data Set\n                                  Punch Utility\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n March 20, 2000                                         Freeware from Steli Inc.\n1                          TABLE OF CONTENTS                         Page      2\n\n\n INTRODUCTION  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     3\n\n\n EXECUTION JCL   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     4\n\n\n CONTROL CARDS   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     5\n\n\n CHANGING DEFAULTS   . . . . . . . . . . . . . . . . . . . . . . . . . . .     6\n\n\n SAMPLE JCL  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     7\n\n\n SAMPLE OUTPUT   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     8\n\n\n PACKAGE CONTENTS  . . . . . . . . . . . . . . . . . . . . . . . . . . . .     9\n\n\n1                            INTRODUCTION                            Page      3\n\n\n This document is intended to provide user information for\n the Partitioned Data Set Punch utility (PDSPUNCH). Some\n understanding of Job Control Language (JCL) is required as\n well as knowledge of how programs are executed.\n\n PDSPUNCH is mainframe freeware. You do not need to register\n to use PDSPUNCH. It may be placed on any archive, web site\n or bulletin board without restraint.  It may be distributed\n by any means, provided that no charge is made other than for\n reasonable distribution costs.\n\n PDSPUNCH is intended for MVS compatible systems to turn the\n members of one or more partitioned data sets (PDS's) into a\n sequential stream of 80 byte records with IEBUPDTE ./ ADD cards\n preceding each member in alphabetical order.  It will process\n concatenated PDS's up to the number currently allowed by the\n operating system and data of any size or type, fixed, variable\n or unformatted.  Options may be specified through free form\n control cards.\n\n PDSPUNCH through its options will also:\n\n    - Punch duplicate members, i.e. process members with the\n      same name that are in one or more PDS's in the concatenation\n      (DUPS)\n\n    - Punch only members that have duplicates within the\n      concatenation (DUPS(ONLY))\n\n    - Punch only a portion of each member (FIRST(.))\n\n    - Allow a range of members to be selected  (>MEMBER(.)\n      and <MEMBER(.))\n\n    - Specify whether to use ./ ADD or ./ REPL header cards\n\n Steli Inc. has made its best effort to provide working,\n tested code.  However, nothing is perfect - there may be\n flaws and there certainly could be improvements.  All\n questions, concerns, problems and suggestions are welcome\n and may be sent to C_Hafner@HotMail.Com.\n\n\n1                            EXECUTION JCL                           Page      4\n\n\nThe job control language (JCL) for PDSPUNCH is:\n\n           //   EXEC   PGM=PDSPUNCH ( ,REGION=4M )\n\n           //STEPLIB     DD   DISP=SHR,DSN=...\n\n           //SYSPUNCH    DD   ...\n\n           //SYSUT1      DD   DISP=SHR,DSN=PDS1\n\n         ( //            DD   DISP=SHR,DSN=PDS2 )\n\n         (    ...   optionally, as many         )\n\n         (    ...      concatenated PDS's       )\n\n         (    ...         as allowed in MVS/ESA )\n\n         ( //SYSIN       DD   *                 )\n\n         (        control cards . . .           )\n\n Optional control language elements are shown in parentheses.\n The name of the program  may be changed as desired providing\n that the actual program is linked with the appropriate name\n or alias.\n\n REGION is optional but PDSPUNCH requires approximately 216,000\n bytes (system required resources may increase this amount).  In\n most cases the default region size is adequate to meet these\n requirements.  STEPLIB may be optional if PDSPUNCH is placed in\n the system's link list but otherwise simply points to where\n PDSPUNCH is stored.\n\n The SYSPUNCH file may be directed to any output class or may\n be sent to a new or existing file.  The DCB attributes of\n SYSPUNCH will be record format FB and LRECL 80.  The BLKSIZE\n parameter may be specified on the JCL for it.\n\n SYSUT1 points to the one or more concatenated PDS's to be\n processed.  SYSIN contains control information and may be\n omitted, set to //SYSIN DD DUMMY or simply be empty.  Full\n control card descriptions are shown below.\n\n The DD names may be changed as desired in the defaults section\n of the source code.  If an incorrect name is specified, the\n program will terminate returning the code received from opening\n the data set (the system will generally indicate the missing DD\n name).\n\n\n1                            CONTROL CARDS                           Page      5\n\n\n The control card values may be specified free form in the first\n 72 columns of the records in the SYSIN file in any order and may\n be separated by commas, blanks or simply concatenated together.\n Each option must be contained on one input line, however, as\n continuation is not supported. Blank lines may be interspersed\n as desired for readability.\n\n The specific keywords are sought and anything else is ignored.\n Keywords must be in upper case but any FOOTING data may be any\n case.  Also, options which require parentheses but where no\n closing parenthesis is supplied will be ignored, as will values\n which require numeric values but are not supplied as such.  The\n last specified value is the one used if the same option is\n repeated.  To change the defaults, please see the section below\n called CHANGING DEFAULTS.\n\n Control card parameters are:\n\n      ACTION(x) Indicate that the IEBUPDTE header card should\n                specify REPL or ADD.  ACTION(ADD) is the\n                default.\n\n      DUPS      Indicate that members with duplicate\n                names in concatenated PDS's are to be punched\n                and shown in the index.  The alternative,\n                NODUPS, is the default.  DUPS(ONLY) may be\n                specified to have only the members that exist\n                as duplicates within the concatenation.\n\n      FIRST(#)  Only the first # of lines of each member\n                will be punched.  The default is to punch\n                every line of a member.  Note this is NOT\n                record count, but literally punches the\n                indicated number of lines.\n\n      >MEMBER(member) Indicates the 1 to 8 byte member name,\n                to be used as an lower bound - no member\n                alphabetically lower then this member will be\n                punched.  The default is to punch the first\n                member and all following members.\n\n      <MEMBER(member) Indicates the 1 to 8 byte member name,\n                to be used as an upper bound - no member\n                alphabetically higher then this member will\n                be punched.  The default is to punch all\n                members from the starting member onward.\n\n\n1                          CHANGING DEFAULTS                         Page      6\n\n\n To change the default behavior of PDSPUNCH, simple changes\n may be made to the assembler source code and the program\n will need to be re-assembled and re-linked.\n\n To change the default, simply find the variable in the\n PDSPUNCH source as shown below and change it from `N' to `Y'\n or vice versa.  BLKSIZE, FIRST and LINECNT require a numeric\n value.  The same concept applies to the DD names shown.\n\n ************************************************************\n *    DEFAULT OPTION VALUES                                 *\n ************************************************************\n\n &DDOPTS       SETC  'SYSIN'      DDNAME FOR OPTIONS FILE\n &DDPDS        SETC  'SYSUT1'     DDNAME FOR PARTITIONED d/s\n &DDPUNCH      SETC  'SYSPUNCH'   DDNAME FOR PUNCHED FILE\n\n &DEF1ST       SETA  999999999    FIRST OPTION CHOSEN DEFAULT\n\n &DEFDUPS      SETC  'N'          DUPS DEFAULT\n &DEFDUPSO     SETC  'N'          DUPS ONLY DEFAULT\n                       00000000\n &DEFMEMGT     SETC   '00000000'  FIRST MEMBER SELECTED (HEX 0'S)\n                       FFFFFFFF\n &DEFMEMLT     SETC   'FFFFFFFF'  LAST MEMBER SELECTED (HEX F'S)\n\n1                             SAMPLE JCL                             Page      7\n\n\n An example of JCL that may be used is:\n\n      //PUNCHGAS  EXEC  PGM=PDSPUNCH,REGION=4M\n\n      //SYSIN       DD    *\n\n            >MEMBER($GAS0000)   <MEMBER($GAS9999)\n\n      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB\n\n      //SYSPUNCH     DD        DISP=(,CATLG),DSN=RECOVERED.MEMBERS,\n\n      //             UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),\n\n      //             DCB=(BLKSIZE=27920,BUFNO=24)\n\n      //SYSUT1       DD        DISP=SHR,DSN=SYS4.USER.PROCLIB\n\n The above step will punch all the restored members (see PDSGAS)\n of the user PROCLIB.  This would allow removal of the \"gas\"\n members while still retaining them in a sequential file.  Note\n the control data is free form and does not need to be aligned in\n any way.\n\n Another example is:\n      //PNCHPDSS  EXEC  PGM=PDSPUNCH\n          DUPS(ONLY)\n      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB\n      //SYSPUNCH    DD         SYSOUT=*\n      //SYSUT1       DD        DISP=SHR,DSN=APPLIC.COPYLIB1\n      //             DD        DISP=SHR,DSN=APPLIC.COPYLIB2\n      //             DD        DISP=SHR,DSN=APPLIC.COPYLIB3\n      //             DD        DISP=SHR,DSN=APPLIC.COPYLIB4\n\n This step will provide a sequential file with all the duplicate\n members within the 4 COPYLIBs.\n\n1                            SAMPLE OUTPUT                           Page      8\n\n\n Given the following 2 partitioned data sets, PDS.A and\n PDS.B, which contain:\n\n      PDS.A\n           Member A -- 10 lines of 10 A's\n           Member B -- 10 lines of 10 B's\n           Member C -- 10 lines of 10 C's\n      PDS.B\n           Member B --10 lines 0f 10 2's\n           Member D --10 lines of 10 D's\n\n The JCL immediately following will produce the results\n below:\n      //PDSPUNCH   EXEC     PGM=PDSPUNCH,REGION=4M\n      //SYSIN   DD   *\n           DUPS\n           FIRST(03)\n      /STEPLIB       DD       DISP=SHR,DSN=USER.LOADLIB\n      //SYSPUNCH   DD       SYSOUT=*\n      //SYSUT1            DD       DISP=SHR,DSN=PDS.A\n      //                  DD       DISP=SHR,DSN=PDS.B\n\n ./  ADD  NAME=A\n AAAAAAAAAA\n AAAAAAAAAA\n AAAAAAAAAA\n ./  ADD  NAME=B\n BBBBBBBBBB\n BBBBBBBBBB\n BBBBBBBBBB\n ./  ADD  NAME=B\n 2222222222\n 2222222222\n 2222222222\n ./  ADD  NAME=C\n CCCCCCCCCC\n CCCCCCCCCC\n CCCCCCCCCC\n ./  ADD  NAME=D\n DDDDDDDDDD\n DDDDDDDDDD\n DDDDDDDDDD\n\n\n1                          PACKAGE CONTENTS                          Page      9\n\n\n PDSPUNCH is generally distributed as a ZIP file, but the\n files distributed easily fit on a 1.4 meg floppy.  The files\n are:\n\n     - PDSPUNCH   the assembler source code wrapped in JCL\n                  to assemble and link it\n\n     - PDSPUNC$   sample execution JCL\n\n PDSPUNCH was assembled using IBM's High Level Assembler.\n Assembler H may be used although any blank lines in the\n source will have to be removed.  The JCL supplied in\n PUNCHASM does not use procedures since many have local\n changes precluding use of specific step names for DD name\n over-rides.  To change from High Level Assembler to\n Assembler H, simply change the program name from ASMA90 to\n IEV90.  The JCL will accommodate either.\n\n\n-\n-\n-\n-\n-\n-\n-\n-\n                                      PULL\n                       Select Records from Sequential File\n                                  Punch Utility\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n December 15, 1999                                      Freeware from Steli Inc.\n1                          TABLE OF CONTENTS                         Page      2\n\n\n INTRODUCTION  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     3\n\n\n EXECUTION JCL   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     4\n\n\n SAMPLE JCL AND OUTPUT   . . . . . . . . . . . . . . . . . . . . . . . . .     5\n\n\n PACKAGE CONTENTS  . . . . . . . . . . . . . . . . . . . . . . . . . . . .     6\n\n\n1                            INTRODUCTION                            Page      3\n\n\n This document is intended to provide user information for\n selecting one or more sets of records from a sequential file\n (PULL).   Given a large sequential file, PULL will allow\n retrieving groups of records in one run without customizing\n code.  Some understanding of Job Control Language (JCL) is\n required as well as knowledge of how programs are executed.\n\n PULL is mainframe freeware.  Feel free to use it as you will.\n\n Steli Inc. has made its best effort to provide working,\n tested code.  However, nothing is perfect - there may be\n flaws and there certainly could be improvements.  All\n questions, concerns, problems and suggestions are welcome\n and may be sent to C_Hafner@HotMail.Com.\n\n\n1                            EXECUTION JCL                           Page      4\n\n\n The job control language (JCL) for PULL is:\n\n      //SELRECS    EXEC     PGM=PULL,  ( REGION=4M )\n\n      //SYSIN        DD       *\n\n      00000001  00000030  STARTING RECORD NUMBER IN 1 - 8\n\n      00000444  00000050  & NUMBER OF RECORDS IN 11 - 18\n\n      //I            DD       DISP=SHR,DCB=BUFNO=32,\n\n      //             DSN=...\n\n      //O            DD       DSN=...,\n\n      //             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(010,010),RLSE\n\n      //             DCB=(...,BUFNO=32)\n\n      //STEPLIB      DD       DISP=SHR,DSN=...\n\n Optional control language elements are shown in parentheses.\n The name of the program  may be changed as desired providing\n that the actual program is linked with the appropriate name or\n alias.  REGION is optional - the default region size may be more\n then adequate depending on your local standards.\n\n File I contains the original data.  File O will contain the\n selected output; the DCB information may be hard coded or\n patterned (specify the old data set name) and the BUFNO\n parameter is useful to speed processing but not necessary.\n\n The SYSIN file contains the specification of the records to be\n selected from INFILE. The first 8 columns specify the offset,\n that is, the starting record number of each group.  The second\n parameter specifies the number of records. These MUST be in\n order by starting record number.\n\n STEPLIB may be optional if PULL is placed in the system's link\n list but otherwise simply points to where PULL is stored.\n\n\n1                        SAMPLE JCL AND OUTPUT                       Page      5\n\n\n A sample of what might be submitted is:\n\n      //GRABRECS   EXEC     PGM=PULL,REGION=4M\n\n      00000001  00000100\n\n      00004001  00000100\n\n      00160001  00000100\n\n      02000001  00000100\n\n      //I            DD       DISP=SHR,DCB=BUFNO=32,\n\n      //             DSN=USERID.USER.DATA01\n\n      //O            DD       DSN=USERID.SELECTED.DATA01,\n\n      //             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(010,010),RLSE\n\n      //             DCB=(USERID.USER.DATA01,BUFNO=32)\n\n      //STEPLIB      DD       DISP=SHR,DSN=SYS4.USER.LINKLIB\n\n Assuming there were 5,000,000 records in the input file I, the\n above step would create a subset file of 400 records.\n\n\n1                          PACKAGE CONTENTS                          Page      6\n\n\n The files involved specifically with PULL are:\n\n     - PULL       the PL/I code wrapped in JCL to compile\n                  and link edit it\n\n     - PULL$      a JCL skeleton for its execution\n\n\n-\n-\n-\n-\n-\n-\n-\n-\n                                      SETRC\n                               Set MVS Return Code\n                                  Punch Utility\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n September 14, 1999                                     Freeware from Steli Inc.\n1                          TABLE OF CONTENTS                         Page      2\n\n\n INTRODUCTION  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     3\n\n\n EXECUTION JCL   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     4\n\n\n SAMPLE JCL AND OUTPUT   . . . . . . . . . . . . . . . . . . . . . . . . .     5\n\n\n PACKAGE CONTENTS  . . . . . . . . . . . . . . . . . . . . . . . . . . . .     6\n\n\n1                            INTRODUCTION                            Page      3\n\n\n This document is intended to provide user information for the\n utility to set MVS return codes (SETRC).  Some understanding of\n Job Control Language (JCL) is required as well as knowledge of\n how programs are executed.\n\n SETRC is mainframe freeware.  It's available for any use you\n wish to make of it.\n\n SETRC is intended for MVS compatible systems to set a step\n return code.  It allows testing of JCL and restart conditions\n without having to do program changes.  Other then setting the\n return code, it does no processing.\n\n SETRC is an Assembler program that accepts a PARM parameter of a\n number between 0 and 4095, the legitimate condition codes\n acceptable to MVS. IF no value or a bad value is passed, the\n return code is set to 0.\n\n Steli Inc. has made its best effort to provide working,\n tested code.  However, nothing is perfect - there may be\n flaws and there certainly could be improvements.  All\n questions, concerns, problems and suggestions are welcome\n and may be sent to C_Hafner@HotMail.Com.\n\n\n1                            EXECUTION JCL                           Page      4\n\n\n The job control language (JCL) for SETRC is:\n\n           //SETCOND    EXEC     PGM=SETRC,PARM=#\n\n           //STEPLIB      DD       DISP=SHR,DSN=...\n\n The name of the program may be changed as desired providing\n that the actual program is linked with the appropriate name\n or alias.\n\n REGION is optional.  STEPLIB may be optional if SETRC is\n placed in the system's link list but otherwise simply points to\n where SETRC is stored.\n\n The only real input is provided by the PARM statement. The\n number provided will be used to set the return code, that is,\n placed in register 15 prior to the program's termination.  Since\n SETRC operates like IEFBR14, file allocation or deletion may be\n performed within its JCL.\n\n\n1                        SAMPLE JCL AND OUTPUT                       Page      5\n\n\n An example of JCL that may be used is:\n\n      //TEST412   EXEC  PGM=SETRC,PARM=412\n\n      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB\n\n The above step will cause the following JES message to be\n generated:\n\n       JOBNAME TEST412 - STEP WAS EXECUTED - COND CODE 0412\n\n An example of how SETRC might be used to test COND code checking\n outcomes is:\n\n      //PROCX2     PROC\n\n      //PS21       EXEC     PGM=IEFBR14\n\n      //PS22       EXEC     PGM=IEFBR14\n\n      //             PEND\n\n      //***\n\n      //PROCX1     PROC\n\n      //PS11       EXEC     PGM=SETRC,PARM=08\n\n      //STEPLIB      DD       DISP=SHR,DSN=SYS4.LINKLIB\n\n      //*\n\n      //PS12       EXEC     PGM=SETRC,PARM=00\n\n      //STEPLIB      DD       DISP=SHR,DSN=SYS4.LINKLIB\n\n      //*\n\n      //PS13       EXEC     PROCX2,COND=(8,LE,EXPRC.PS11)\n\n      //             PEND\n\n      //***\n\n      //EXPRC      EXEC     PROCX1\n\n showing exactly what will happen if PROCX1's step PS11\n returns a code of 8.\n\n\n1                          PACKAGE CONTENTS                          Page      6\n\n\n The files involved specifically with SETRC are:\n\n     - SETRC      the Assembler code wrapped in JCL to\n                  assemble and link edit it\n\n     - SETRC$     a JCL skeleton for its execution\n\n\n-\n-\n-\n-\n-\n-\n-\n-\n                                     SMARTGN\n                         Generate Card Images from List\n                                  Punch Utility\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n November 14, 1999                                      Freeware from Steli Inc.\n1                          TABLE OF CONTENTS                         Page      2\n\n\n INTRODUCTION  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     3\n\n\n EXECUTION JCL   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     4\n\n\n SAMPLE JCL AND OUTPUT   . . . . . . . . . . . . . . . . . . . . . . . . .     6\n\n\n PACKAGE CONTENTS  . . . . . . . . . . . . . . . . . . . . . . . . . . . .    10\n\n\n1                            INTRODUCTION                            Page      3\n\n\n This document is intended to provide user information for\n generating card images using an input list to replace tokens in\n a skeleton set of those images (SMARTGN).\n\n For example, if you have a list of 1,000 data set names and wish\n to generate delete cards for an IEFBR14, SMARTGN would do so\n with a minimal set of JCL delete cards. Please see the GETDSNS\n Edit macro for a tool to provide data set names by wildcard\n input.\n\n SMARTGN also allows substitution of the run date in various\n formats, run time, and the sequence number of the list input\n item.  Some understanding of Job Control Language (JCL) is\n required as well as knowledge of how programs are executed.\n\n SMARTGN is mainframe freeware.  You do not need to register to\n use SMARTGN. It may be placed on any archive, web site or\n bulletin board without restraint.  It may be distributed by any\n means, provided that no charge is made other than for reasonable\n distribution costs.\n\n Steli Inc. has made its best effort to provide working,\n tested code.  However, nothing is perfect - there may be\n flaws and there certainly could be improvements.  All\n questions, concerns, problems and suggestions are welcome\n and may be sent to C_Hafner@HotMail.Com.\n\n\n1                            EXECUTION JCL                           Page      4\n\n\n The job control language (JCL) for SMARTGN is:\n\n      //GENCNTL    EXEC     PGM=SMARTGN  ( ,REGION=4M )\n\n      //SYSCTL       DD       DATA,DLM=XX\n\n      skeleton-item...\n\n      skeleton-item...\n\n      skeleton-item...\n\n            ...\n\n      XX\n\n      //SYSOUT       DD       DSN=USERID.SMARTGN.OUTPUT,\n\n      //             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(010,010),RLSE\n\n      //             DCB=(RECFM=FB,LRECL=00080,BLKSIZE=00000)\n\n      //SYSIN        DD       *\n\n      LIST-ITEM.1.\n\n      LIST-ITEM.2.\n\n      LIST-ITEM.3.\n\n          ...\n\n      //STEPLIB      DD       DISP=SHR,DSN=...\n\n Optional control language elements are shown in parentheses.\n The name of the program  may be changed as desired providing\n that the actual program is linked with the appropriate name or\n alias.  REGION is optional - the default region size may be more\n then adequate depending on your local standards.\n\n SYSCTL contains the skeleton images to be populated with the\n SYSIN items, that is, the SYSCTL file is generated once for each\n item in the SYSIN file replacing tokens as shown below.  The\n rationale for using DD DATA with a delimiter is that SYSCTL\n could contain JCL with embedded /* cards.\n\n Any question mark (?) character found in the skeleton is\n replaced by the current list element. An exclamation point (!)\n is replaced by the run date in YYMMDD form, a percent sign (%)\n by the run date in CCYYMMDD form, and an at sign (@) by the run\n time in HHMMSS form.\n\n One or more contigious pound signs (up to 8) are replaced by the\n number of the current list item, right justified and zero\n padded. For example, if processing the 3rd item in SYSIN,\n1                      EXECUTION JCL (Continued)                     Page      5\n\n finding a ### would cause 003 to replace the ###.\n\n SYSOUT will contain the generated images.\n\n SYSIN contains the list of items to be substituted into the\n SYSCTL images one at a time.\n\n STEPLIB may be optional if SMARTGN is placed in the system's link\n list but otherwise simply points to where SMARTGN is stored.\n\n\n1                        SAMPLE JCL AND OUTPUT                       Page      6\n\n\n A sample of what might be submitted is:\n\n      //           EXEC     PGM=SMARTGN,REGION=4M\n\n      //SYSCTL       DD       DATA,DLM=XX\n\n      //DEL####  DD  DSN=?,\n\n      //  DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n\n      XX\n\n      //SYSOUT       DD       DSN=USERID.SMARTGN.OUTPUT,\n\n      //             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(010,010),RLSE\n\n      //             DCB=(RECFM=FB,LRECL=00080,BLKSIZE=00000)\n\n      //SYSIN        DD       *\n\n      SYS1.DSN610.SDSNLINK.MAINT1\n\n      SYS1.DSN610.SDSNLINK\n\n      SYS1.DSN610.SDSNLOAD\n\n      SYS1.DSN610.SDSNLOAD.MAINT2\n\n      //STEPLIB      DD       DISP=SHR,DSN=SYS4.USER.LOADLIB\n\n Would cause the following to be written to the SYSOUT file:\n\n      //DEL0001  DD  DSN=SYS1.DSN610.SDSNLINK.MAINT1,\n\n      //  DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n\n      //DEL0002  DD  DSN=SYS1.DSN610.SDSNLINK,\n\n      //  DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n\n      //DEL0003  DD  DSN=SYS1.DSN610.SDSNLOAD,\n\n      //  DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n\n      //DEL0004  DD  DSN=SYS1.DSN610.SDSNLOAD.MAINT2,\n\n      //  DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n\n Another sample is:\n\n      //BKUPGEN    EXEC     PGM=SMARTGN,REGION=4M\n\n      //SYSCTL       DD       DATA,DLM=XX\n\n      //***\n1                  SAMPLE JCL AND OUTPUT (Continued)                 Page      7\n\n\n      //DEL#####   EXEC     PGM=IEFBR14\n\n      //DEL          DD       DSN=?.BK!,\n\n      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n\n      //***\n\n      //GEN#####   EXEC     PGM=IEBGENER,REGION=4M\n\n      //SYSPRINT     DD       SYSOUT=*\n\n      //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,\n\n      //             DSN=?\n\n      //SYSUT2       DD       DISP=(,CATLG),\n\n      //             UNIT=SYSDA,SPACE=(CYL,(50,20),RLSE),\n\n      //             DCB=(?,BUFNO=32),\n\n      //             DSN=?.BK!\n\n      //SYSIN        DD       DUMMY\n\n      //***\n\n      XX\n\n      //SYSOUT       DD       DSN=USERID.SMARTGN.OUTPUT,\n\n      //             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(010,010),RLSE\n\n      //             DCB=(RECFM=FB,LRECL=00080,BLKSIZE=00000)\n\n      //SYSIN        DD       *\n\n      USERID.MASTER.DATA01\n\n      USERID.MASTER.LINK01\n\n      USERID.MASTER.INDEX\n\n      //STEPLIB      DD       DISP=SHR,DSN=SYS4.USER.LOADLIB\n\n Would cause the following to be written to the SYSOUT file, assuming\n the run date was February 29, 2000:\n\n      //***\n\n      //DEL00001   EXEC     PGM=IEFBR14\n\n      //DEL          DD       DSN=USERID.MASTER.DATA01.BK000229,\n\n      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n1                  SAMPLE JCL AND OUTPUT (Continued)                 Page      8\n\n\n      //***\n\n      //GEN00001   EXEC     PGM=IEBGENER,REGION=4M\n\n      //SYSPRINT     DD       SYSOUT=*\n\n      //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,\n\n      //             DSN=USERID.MASTER.DATA01\n\n      //SYSUT2       DD       DISP=(,CATLG),\n\n      //             UNIT=SYSDA,SPACE=(CYL,(50,20),RLSE),\n\n      //             DCB=(USERID.MASTER.DATA01,BUFNO=32),\n\n      //             DSN=USERID.MASTER.DATA01.BK000229\n\n      //SYSIN        DD       DUMMY\n\n      //***\n\n      //***\n\n      //DEL00002   EXEC     PGM=IEFBR14\n\n      //DEL          DD       DSN=USERID.MASTER.LINK01.BK000229,\n\n      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n\n      //***\n\n      //GEN00002   EXEC     PGM=IEBGENER,REGION=4M\n\n      //SYSPRINT     DD       SYSOUT=*\n\n      //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,\n\n      //             DSN=USERID.MASTER.LINK01\n\n      //SYSUT2       DD       DISP=(,CATLG),\n\n      //             UNIT=SYSDA,SPACE=(CYL,(50,20),RLSE),\n\n      //             DCB=(USERID.MASTER.LINK01,BUFNO=32),\n\n      //             DSN=USERID.MASTER.LINK01.BK000229\n\n      //SYSIN        DD       DUMMY\n\n      //***\n\n      //***\n\n      //DEL00003   EXEC     PGM=IEFBR14\n\n1                  SAMPLE JCL AND OUTPUT (Continued)                 Page      9\n\n      //DEL          DD       DSN=USERID.MASTER.INDEX.BK000229,\n\n      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n\n      //***\n\n      //GEN00003   EXEC     PGM=IEBGENER,REGION=4M\n\n      //SYSPRINT     DD       SYSOUT=*\n\n      //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,\n\n      //             DSN=USERID.MASTER.INDEX\n\n      //SYSUT2       DD       DISP=(,CATLG),\n\n      //             UNIT=SYSDA,SPACE=(CYL,(50,20),RLSE),\n\n      //             DCB=(USERID.MASTER.INDEX,BUFNO=32),\n\n      //             DSN=USERID.MASTER.INDEX.BK000229\n\n      //SYSIN        DD       DUMMY\n\n      //***\n\n Note the use of the date within the back up data set name as\n well as the use of the old data set name within the DCB\n parameter.\n\n\n1                          PACKAGE CONTENTS                          Page     10\n\n\n The files involved specifically with SMARTGN are:\n\n     - SMARTGN    the PL/I code wrapped in JCL to compile\n                  and link edit it\n\n     - SMARTGN$   a JCL skeleton for its execution\n\n\n-\n-\n-\n-\n-\n-\n-\n-\n                                      TOUCH\n                               Set ISPF Statistics\n                                 For PDS Members\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n October 26, 1999                                       Freeware from Steli Inc.\n1                          TABLE OF CONTENTS                         Page      2\n\n\n INTRODUCTION  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     3\n\n\n EXECUTION JCL   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     4\n\n\n SAMPLE JCL AND OUTPUT   . . . . . . . . . . . . . . . . . . . . . . . . .     6\n\n\n PACKAGE CONTENTS  . . . . . . . . . . . . . . . . . . . . . . . . . . . .     7\n\n\n1                            INTRODUCTION                            Page      3\n\n\n This document is intended to provide user information for\n setting ISPF PDS member statistics (TOUCH).  Some understanding\n of Job Control Language (JCL) is required as well as knowledge\n of how programs are executed.\n\n TOUCH is mainframe freeware.  You do not need to register to\n use TOUCH.  It may be placed on any archive, web site or\n bulletin board without restraint.  It may be distributed by any\n means, provided that no charge is made other than for reasonable\n distribution costs.\n\n TOUCH is a PL/I program intended for MVS compatible systems to\n set any ISPF statistics for one or more members of one or more\n different partitioned data sets from a batch job.  All the\n statistics currently available, including Y2K compatible dates,\n may be set. TOUCH was written to allow clean up of old user ID's,\n provide an easy mechanism for turnover of identifiable members,\n and check out Y2K handling of various dates.\n\n Please see the TU and TD macros on File 357 of the CBT Tape\n (WWW.CBTTAPE.ORG) for panel driven capabilities of this same\n type for single members.\n\n Load module libraries, while they have statistics of a kind, are\n NOT supported. Messing with them usually causes nasty and\n painful after-effects. TOUCH will allow you to change editable\n PDS member statistics.\n\n Steli Inc. has made its best effort to provide working,\n tested code.  However, nothing is perfect - there may be\n flaws and there certainly could be improvements.  All\n questions, concerns, problems and suggestions are welcome\n and may be sent to C_Hafner@HotMail.COM.\n\n\n1                            EXECUTION JCL                           Page      4\n\n\n The job control language (JCL) for TOUCH is:\n\n      //           EXEC     PGM=TOUCH, ( ,REGION=4M )\n\n      //STEPLIB      DD       DISP=SHR,DSN=...\n\n      //SYSPRINT     DD       SYSOUT=*\n\n      //SYSIN        DD       *\n\n        DSNAME = 'SYS2.CLIST',\n\n          MEMBER = 'MEMNAME',\n\n            ALIAS         = 'N',\n\n            VERSIONNUMBER = 01,\n\n            MAINTNUMBER   = 01,\n\n            CREATEDATE    = 20010101,\n\n            CHANGEDATE    = 20010101,\n\n            CHANGETIME    = 1234,\n\n            INITIALSIZE   = 12345,\n\n            CURRENTSIZE   = 12345,\n\n            MODCOUNT      = 0,\n\n            USERID        = 'SOMEONE';\n\n Optional control language elements are shown in parentheses.\n The name of the program  may be changed as desired providing\n that the actual program is linked with the appropriate name or\n alias.  REGION is optional - the default region size may be more\n then adequate, but REGION=4M can't hurt.\n\n STEPLIB may be optional if TOUCH is placed in the system's link\n list but otherwise simply points to where TOUCH is stored.\n\n The SYSPRINT file mirrors the input and contains any error\n messages; it may be directed to any output class or may be sent\n to a new or existing file.  The DCB attributes of SYSPRINT may\n be either Fixed or Variable, blocked or unblocked, and any\n record length over 60 bytes.  That is, it can be FBA/80/6160 or\n VBA/125/32760, or just leave DCB off and have it default.\n\n Note there is no DD card pointing to the PDS to be updated.  The\n internal assembler routines dynamically allocate and free the\n PDS for processing.\n\n SYSIN control cards determine the member to be updated and also\n1                      EXECUTION JCL (Continued)                     Page      5\n\n what values are used. The file is being accessed via PL/I's\n stream I/O facility, is basically free form but does require a\n semi-colon at the end of each member set.\n\n The DSNAME and MEMBER keywords specify the name of the\n partitioned data set and the member to have its statistics\n updated. If the member has no statistics as it is, dummy\n statistics will be set up for everything except the ones\n specified.\n\n ALIAS may be used to set the alias switch on or off. If set on,\n ALIAS = 'Y', then the statistics may not be viewable under View\n or Edit.\n\n VERSIONNUMBER and MAINTNUMBER are self describing numeric\n values, as is MODCOUNT (the modification count).  CREATEDATE and\n CHANGEDATE may be of the form CCYYMMDD (century, year, month and\n day) or of the form CCYYDDD (century, year and Julian # of\n days).  CHANGETIME is of the form HHMM (24 hour HH value\n followed by minutes) but seconds defaults to 0.\n\n INITIALSIZE and CURRENTSIZE reflect the number of records in the\n original creation and current status. Changing these may not\n make any sense. The maximum value is 65,535 which is shown even\n if there are 100,000 records in the member in question.\n\n USERID is the creator or last updater. It may only be 7\n characters long.\n\n\n1                        SAMPLE JCL AND OUTPUT                       Page      6\n\n\n A sample of what might be submitted is:\n\n      //UPDATE     EXEC     PGM=TOUCH,REGION=4M\n\n        DSNAME = 'SYS1.MACLIB',  MEMBER = 'GET',\n           CHANGEDATE    = 19940101,\n           CHANGETIME    = 1234,\n           USERID        = 'COOLGUY';\n\n        DSNAME = 'SYS1.MACLIB',  MEMBER = 'PUT',\n           CHANGEDATE    = 20061231,\n           USERID        = 'COOLGUY';\n\n        DSNAME = 'SYS4.CLIST',   MEMBER = 'FLOW',\n           CHANGEDATE    = 20000101,\n           MODCOUNT      = 0,\n           USERID        = 'BASEVER';\n\n      //STEPLIB      DD       DISP=SHR,DSN=SYS4.USER.LOADLIB\n\n      //SYSPRINT     DD       SYSOUT=*\n\n The blank lines shown above are accepted and ignored; they are\n there only for readability.  Assume the original values as seen\n under ISPF View were:\n\n    Name   Prompt   Size    Created           Changed         ID\n   ------  ------  -----  ----------  -------------------  -------\n   GET                 9  2001/02/18  2001/02/23 10:03:08 KLUTZ\n   PUT\n ...................................................................\n   FLOW              184  2001/02/23  2001/02/23 10:03:29 SYSTEM\n\n Note the above have GET/PUT separated from FLOW since they are\n in different data sets and PUT has no statistics.  The results\n would be:\n\n    Name   Prompt   Size    Created           Changed         ID\n   ------  ------  -----  ----------  -------------------  -------\n   GET                 9  2001/02/18  1994/01/01 12:34:00  COOLGUY\n   PUT             65535  2001/02/23  2006/12/31 14:13:00  COOLGUY\n ...................................................................\n   FLOW              184  2001/02/23  2000/01/01 10:03:29  BASEVER\n\n The stats for PUT picked up the date and time of the executuion\n for Create Date and for Change Time. It set the Current Size to\n the maximum value. Note too you can select dates not only in the\n past but also in the future.\n\n PDSGEN, which generates control cards from directory information,\n might well be used in conjunction with TOUCH by generating the\n skeleton control cards for existing PDS's. It's available from the\n same source as TOUCH.\n\n\n1                          PACKAGE CONTENTS                          Page      7\n\n\n The files involved specifically with TOUCH are:\n\n     - TOUCH      the PL/I code wrapped in JCL to compile\n                  and link edit it\n\n     - BLDR       the Assembler code wrapped in JCL to\n                  assemble and link edit it\n\n     - STOWR      the Assembler code wrapped in JCL to\n                  assemble and link edit it\n\n     - TOUCH$     a JCL skeleton for its execution\n\n\n-\n-\n-\n-\n-\n-\n-\n-\n                                     UNTOUCH\n                     Remove Extraneous Directory Information\n                           From Partitioned Data Sets\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n February 14, 2001                                      Freeware from Steli Inc.\n1                          TABLE OF CONTENTS                         Page      2\n\n\n INTRODUCTION  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     3\n\n\n EXECUTION JCL   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     4\n\n\n SAMPLE JCL AND OUTPUT   . . . . . . . . . . . . . . . . . . . . . . . . .     6\n\n\n PACKAGE CONTENTS  . . . . . . . . . . . . . . . . . . . . . . . . . . . .     7\n\n\n1                            INTRODUCTION                            Page      3\n\n\n This document is intended to provide user information for the\n utility to remove extraneous directory statistics (UNTOUCH).\n Some understanding of Job Control Language (JCL) is required as\n well as knowledge of how programs are executed.\n\n UNTOUCH is mainframe freeware.  You do not need to register\n to use UNTOUCH.  It may be placed on any archive, web site\n or bulletin board without restraint.  It may be distributed\n by any means, provided that no charge is made other than for\n reasonable distribution costs.\n\n UNTOUCH is intended for MVS compatible systems to remove any\n unneeded directory information from partitioned data sets\n (PDS's). If a member has no such information, it is left alone.\n This would be done to enhance access performance to a CLIST,\n PROC library or macro library as well as freeing up directory\n space.  The name, UNTOUCH, refers in a contrary way to the\n ability to \"touch\" a member, that is, set statistical\n information.  This simply removes everything except the bare\n bones name, TTR and attribute byte.\n\n UNTOUCH is a PL/I program with an assembler subroutine that can\n process a name range or a specific number of members. It is\n intended to be used on libraries where there's some advantage to\n removing the statistical data.  It should never be used on a\n load module library since the directory information stored\n within is critical to executing those members.\n\n Steli Inc. has made its best effort to provide working,\n tested code.  However, nothing is perfect - there may be\n flaws and there certainly could be improvements.  All\n questions, concerns, problems and suggestions are welcome\n and may be sent to C_Hafner@HotMail.Com.\n\n\n1                            EXECUTION JCL                           Page      4\n\n\n The job control language (JCL) for UNTOUCH is:\n\n           //UNTOUCH    EXEC     PGM=UNTOUCH  ( ,REGION=4M )\n\n           //SYSUT1       DD       DISP=SHR,DSN=...\n\n           //SYSIN        DD       *\n\n               FIRST=000001,        LAST=999999,\n\n               FIRSTMEM='        ', LASTMEM='99999999';\n\n           //SYSPRINT     DD       SYSOUT=*\n\n           //STEPLIB      DD       DISP=SHR,DSN=...\n\n Optional control language elements are shown in parentheses.\n The name of the program  may be changed as desired providing\n that the actual program is linked with the appropriate name\n or alias.\n\n REGION is optional.  STEPLIB may be optional if UNTOUCH is\n placed in the system's link list but otherwise simply points to\n where UNTOUCH is stored.\n\n The SYSPRINT file may be directed to any output class or may\n be sent to a new or existing file.  The DCB attributes of\n SYSPRINT will be record format FBA and LRECL 121.  This file\n will show the number of members processed.\n\n SYSUT1 points to the partitioned data set to be processed.\n\n SYSIN contains control information on the range or number of\n members to be processed. The default shown will basically\n process the entire PDS, unless there are more then 999,999\n members or the actual member names are outside the range of\n blanks through all 9's.  FIRST and LAST refer to the number of\n the members in the PDS, that is, the very first member is 1.\n FIRSTMEM and LASTMEM refer to the actual names of the members,\n e.g. COPYTO or ASMA90.\n\n To remove the statistics from the name range of GET through PUT\n inclusive, you'd have:\n\n               FIRST=000001,        LAST=999999,\n               FIRSTMEM='GET     ', LASTMEM='PUT     ';\n\n Note the control card data is free form and does not need to be\n aligned in any way. The sample shown here was aligned for\n readability only.  So the following is equivalent to the\n previous set:\n\n    FIRST=000001, LAST=999999, FIRSTMEM='GET     ', LASTMEM='PUT     ';\n\n The commas and final semicolon are necessary for PL/I stream\n1                      EXECUTION JCL (Continued)                     Page      5\n\n input.  If an error occurs, the program will terminate returning\n the code received from attempting to replace the member\n information.\n\n\n1                        SAMPLE JCL AND OUTPUT                       Page      6\n\n\n An example of JCL that may be used is:\n\n      //CLEANUP   EXEC  PGM=UNTOUCH,REGION=4M\n\n      //SYSIN       DD    *\n\n               FIRST=000001,        LAST=999999,\n\n               FIRSTMEM='ELIG001 ', LASTMEM='ELIG999 ';\n\n      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB\n\n      //SYSPRINT     DD        SYSOUT=C\n\n      //SYSUT1       DD        DISP=SHR,DSN=SYS1.PROCLIB\n\n The above step will remove the extra directory information, if\n any, from members in SYS1.PROCLIB from member ELIG001 through\n ELIG999.\n\n So, if the PDS looked like the following in ISPF Edit:\n\n       Name      Prompt  Size    Created           Changed           ID\n      @README@\n      ADDDOTSL             42  2001/02/09  2001/02/09 07:35:40  USER002\n      ADDFLAG              56  2001/02/09  2001/02/09 07:35:40  USER002\n      ADDLINEA              4  2001/02/09  2001/02/09 07:35:40  USER002\n      ADDLINEB              4  2001/02/09  2001/02/09 07:35:40  USER002\n      ADDLINES             84  2001/02/09  2001/02/09 07:35:40  USER002\n      ALLMEM\n      ALLMEMC               5  2001/02/09  2001/02/09 07:35:40  USER002\n      ALLMEMF\n\n resulting in the following after UNTOUCH runs:\n\n       Name      Prompt  Size    Created           Changed           ID\n      @README@\n      ADDDOTSL\n      ADDFLAG\n      ADDLINEA\n      ADDLINEB\n      ADDLINES\n      ALLMEM\n      ALLMEMC\n      ALLMEMF\n\n\n1                          PACKAGE CONTENTS                          Page      7\n\n\n The files involved specifically with UNTOUCH are:\n\n     - STOWU      the assembler source code wrapped in JCL\n                  to assemble and link it\n\n     - UNTOUCH    the PL/I code wrapped in JCL to compile\n                  and link edit it\n\n     - UNTOUCH$   a JCL skeleton for its execution\n\n\n-\n-\n-\n-\n-\n-\n-\n-\n                                     VALUES\n                            Summarize All Data Values\n                             From a Sequential File\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n February 29, 2004                                      Freeware from Steli Inc.\n1                          TABLE OF CONTENTS                         Page      2\n\n\n INTRODUCTION  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     3\n\n\n EXECUTION JCL   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     4\n\n\n SAMPLE JCL AND OUTPUT   . . . . . . . . . . . . . . . . . . . . . . . . .     5\n\n\n PACKAGE CONTENTS  . . . . . . . . . . . . . . . . . . . . . . . . . . . .     7\n\n\n1                            INTRODUCTION                            Page      3\n\n\n This document is intended to provide user information for\n summarizing data values from a sequential file (VALUES).  Some\n understanding of Job Control Language (JCL) is required as well\n as knowledge of how programs are executed.\n\n VALUES is mainframe freeware.   You do not need to register to\n use VALUES.  It may be placed on any archive, web site or\n bulletin board without restraint.  It may be distributed by any\n means, provided that no charge is made other than for reasonable\n distribution costs.\n\n VALUES is a PL/I program intended for MVS compatible systems to\n list all the distinct values present in specific columns of a\n sequential file.  It processes totally in memory and shows the\n values for one or more sets of columns in the order that the\n values occur, in the order of their EBCDIC collating sequence,\n or in descending order of the number of occurrences for each\n value.  The intention is to provide fast and concise analysis of\n the data.\n\n Steli Inc. has made its best effort to provide working,\n tested code.  However, nothing is perfect - there may be\n flaws and there certainly could be improvements.  All\n questions, concerns, problems and suggestions are welcome\n and may be sent to C_Hafner@HotMail.Com.\n\n\n1                            EXECUTION JCL                           Page      4\n\n\n The job control language (JCL) for VALUES is:\n\n      //VALUES     EXEC     PGM=VALUES,REGION=464M,\n\n      //             PARM='HEAP(01M,01M,ANYWHERE)/      '\n\n      //*               -- SORT BY ACTUAL VALUES /VALUES'\n\n      //*               -- SORT BY # OCCURRENCES /OCCURS'\n\n      //I            DD       DCB=BUFNO=32,\n\n      //             DISP=SHR,DSN=...\n\n      00001-00005      * FROM/TO COLUMNS IN 1 THRU 11\n\n      00051-00060      * COMMENTS IN COLUMNS 12 ONWARD\n\n      00021*00023      * ANY NON DASH IN COL 6 SUMS EACH COL & TOTAL\n\n      //STEPLIB      DD       DISP=SHR,DSN=...\n\n      //SYSPRINT     DD       SYSOUT=*\n\n Optional control language elements are shown in parentheses.\n The name of the program  may be changed as desired providing\n that the actual program is linked with the appropriate name\n or alias.\n\n REGION is optional but needs to allow for keeping the entire\n linked list of values in memory at one time.\n\n The PARM reflects getting heap memory in chunks of 1 megabyte -\n this is sent to the language environment.  The slash separates\n the language parameter from the program paramter. A blank\n program parameter causes the values to be listed as they occur.\n VALUES causes them to be sorted by the actual values and OCCURS\n causes the listed items to be sorted descending by their number\n of occurences.\n\n STEPLIB may be optional if VALUES is placed in the system's link\n list but otherwise simply points to where VALUES is stored.\n\n The SYSPRINT file may be directed to any output class or may be\n sent to a new or existing file.  The DCB attributes of SYSPRINT\n may be either Fixed or Variable, blocked or unblocked, and any\n record length over 60 bytes.  That is, it can be FBA/80/6160 or\n VBA/125/32760, or just leave DCB off and have it default.\n\n The SYSIN control cards consist simply of the 5 digit starting\n column of the data, a dash and the 5 digit ending column.  Any\n data beyond column 11 is considered a comment and will only be\n shown in the output listing.\n\n\n1                        SAMPLE JCL AND OUTPUT                       Page      5\n\n\n An example of JCL that may be used is:\n\n      //SUMMARY    EXEC     PGM=VALUES,REGION=464M,\n\n      //             PARM='HEAP(01M,01M,ANYWHERE)/VALUES'\n\n      //I            DD       *\n\n                02-01-99\n\n                02-11-99\n\n                02-08-00\n\n                02-06-04\n\n                02-03-99\n\n                02-11-01\n\n                02-06-99\n\n                02-11-99\n\n                02-11-99\n\n                02-11-99\n\n      //SYSIN        DD       *\n\n      00011-00012  SUMMARIZE MONTHS IN INPUT\n\n      00014-00015  SUMMARIZE DAY VALUES IN INPUT\n\n      00011-00018  SUMMARIZE THE ENTIRE DATE VALUE\n\n      00011X00018  SUMMARIZE THE CHARACTERS IN 11 TO 18\n\n      //STEPLIB      DD       DISP=SHR,DSN=SYS1.RUBBER.DUCKY\n\n      //SYSPRINT     DD       SYSOUT=*\n\n The above step will produce the following output:\n\n   RECORD COUNT =           10\n\n   COLUMN(S)    11-   12 CONTAIN             1 UNIQUE VALUE(S) --\n   SUMMARIZE MONTHS IN INPUT\n                 10 >>02<<\n\n   COLUMN(S)    14-   15 CONTAIN             5 UNIQUE VALUE(S) --\n   SUMMARIZE DAY VALUES IN INPUT\n                  1 >>01<<\n                  1 >>03<<\n                  2 >>06<<\n1                  SAMPLE JCL AND OUTPUT (Continued)                 Page      6\n\n                  1 >>08<<\n                  5 >>11<<\n\n   COLUMN(S)    11-   18 CONTAIN             7 UNIQUE VALUE(S) --\n   SUMMARIZE THE ENTIRE DATE VALUE\n                  1 >>02-01-99<<\n                  1 >>02-03-99<<\n                  1 >>02-06-04<<\n                  1 >>02-06-99<<\n                  1 >>02-08-00<<\n                  1 >>02-11-01<<\n                  4 >>02-11-99<<\n\n   COLUMN(S)    11 THRU    18 HAVE             9 UNIQUE VALUE(S) --\n   SUMMARIZE THE CHARACTERS IN 11 TO 18\n              20 >>-<<\n              19 >>0<<\n              12 >>1<<\n              10 >>2<<\n               1 >>3<<\n               1 >>4<<\n               2 >>6<<\n               1 >>8<<\n              14 >>9<<\n\n Note the record count is shown, 10, and the control cards do not\n have to be in any order. Also, the fields may, as in this case,\n overlap. The COLUMN(S) line also shows the number of unique values.\n\n The first 3 sets of data may be verified against the input to\n see that there are 10 occurrences in each set and that the\n values shown match against the input too. We'd asked that the\n output be sorted by value and that also can be seen easily.\n\n The 4th control card requests that the individual columns be\n summarized and those summaries combined. This is useful when\n you want to see what characters comprise certain fields or\n even the entire record. You can easily see that the date field\n contained only dashes and the 10 numeric digits.\n\n1                          PACKAGE CONTENTS                          Page      7\n\n\n The files involved specifically with VALUES are:\n\n     - VALUES     the PL/I code wrapped in JCL to compile\n                  and link edit it\n\n     - VALUES$    a JCL skeleton for its execution\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@PGMDOCO": {"ttr": 12549, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\r\\xd2\\r\\xd2\\x00\\x00\\xc4\\xd6\\xc3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 3538, "newlines": 3538, "modlines": 0, "user": "DOC"}, "text": ":*  Full formal documentation for all programs included\n:PAGESIZE  55\n:LINESIZE  80\n:TOC       YES\n:DOCTITLE  ABENDX\n:DOCTITLE2 Force User ABEND\n:TLRDATE   September 14, 2002\n:TLRDESC   Freeware from Steli Inc.\n:HEADER1   INTRODUCTION\n\n This document is intended to provide user information for the\n utility to force user abnormal terminations (ABENDX). Some\n understanding of Job Control Language (JCL) is required as well\n as knowledge of how programs are executed.\n\n ABENDX is mainframe freeware. It's available for any use you\n wish to make of it.\n\n ABENDX is intended for MVS compatible systems to call the system\n ABEND routine with a parameter specified user code or to force\n specific system abends such as 0C1, allowing testing of JCL and\n restart conditions without having to do program changes. It may\n even be called from REXX or CLIST.\n\n ABENDX is an Assembler program that accepts a PARM parameter of\n a number between 0 and 4095, the legitimate user ABEND codes\n acceptable to MVS.  ABENDX will also accept PARM values of 0C1,\n 0C2, 0C3, 0C4, 0C6, 0C7, 0C8, 0C9 and 0CB and will force that\n specific ABEND.  IF no value or a bad value is passed, the\n return code is set to 4095 and the ABEND occurs.\n\n Steli Inc. has made its best effort to provide working, tested\n code.  However, nothing is perfect - there may be flaws and\n there certainly could be improvements.  All questions, concerns,\n problems and suggestions are welcome.  Please e-mail them to\n C_Hafner@HotMail.Com.\n\n\n:HEADER1   EXECUTION JCL\n\n The job control language (JCL) for ABENDX is:\n\n           //DIE        EXEC     PGM=ABENDX,PARM=#\n\n           //STEPLIB      DD       DISP=SHR,DSN=...\n\n The name of the program may be changed as desired providing\n that the actual program is linked with the appropriate name\n or alias.\n\n REGION is optional.  STEPLIB may be optional if ABENDX is\n placed in the system's link list but otherwise simply points to\n where ABENDX is stored.\n\n The only real input is provided by the PARM statement. The\n number provided will be used to set the user ABEND code or the\n system abend code will be used to force the program's\n termination.  Since ABENDX operates like IEFBR14, file\n allocation or deletion may be performed within its JCL.\n\n\n:HEADER1   SAMPLE JCL AND OUTPUT\n\n An example of JCL that may be used is:\n\n      //TEST412   EXEC  PGM=ABENDX,PARM=412\n\n      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB\n\n The above step will cause the following JES message to be\n generated:\n\n       12.34.56 JOB00123  IEF450I USERNMA ABEND ...\n             - ABEND=S000 U0412  REASON=00000000\n\n An example of how ABENDX might be used to force an ABEND within a\n REXX EXEC is:\n\n      /**  REXX  **/\n\n         ADDRESS TSO\n\n         \"CALL 'your-user-ID.LOADLIB(ABENDX)' '0412'\"\n\n\n\n:HEADER1   PACKAGE CONTENTS\n\n The files involved specifically with ABENDX are:\n\n     - ABENDX     the Assembler code wrapped in JCL to\n                  assemble and link edit it\n\n     - ABENDX$    a JCL skeleton for its execution\n\n:RESET\n:PAGESIZE  58\n:LINESIZE  80\n:TOC       YES\n:DOCTITLE  ADDCC\n:DOCTITLE2 Add Carriage Control\n:DOCTITLE3 to a Sequential File\n:TLRDATE   September 7, 2002\n:TLRDESC   Freeware from Steli Inc.\n:HEADER1   INTRODUCTION\n\n This document is intended to provide user information for adding\n carriage control data and minimal word processing structures to\n a sequential file (ADDCC).  Some understanding of Job Control\n Language (JCL) is required as well as knowledge of how programs\n are executed.\n\n ADDCC is mainframe freeware. Use it, change it, or rip it\n apart.\n\n ADDCC is a PL/I program intended for MVS compatible systems to\n add ASCII carriage control to a sequential data set. It allows\n the use of a pseudo text descriptor language to generate a title\n page, to provide a table of contents, to set page and line size,\n and to separate sections.\n\n ADDCC is intended to simplify documentation maintenance.  It's a\n small, cheap text scripting tool that does page generation so\n you don't have to do all sorts of editing when you add or remove\n a few lines.  And, if asked, it will generate a table of\n contents based on section naming.\n\n Steli Inc. has made its best effort to provide working,\n tested code.  However, nothing is perfect - there may be\n flaws and there certainly could be improvements.  All\n questions, concerns, problems and suggestions are welcome.\n E-mail may be sent to C_Hafner@HotMail.Com for the preceding.\n\n\n:HEADER1   EXECUTION JCL\n\n The job control language (JCL) for ADDCC is:\n\n           //ADDCC      EXEC     PGM=ADDCC,    ( ,REGION=64M, )\n\n           //             PARM='HEAP(01M,01M,ANYWHERE)'\n\n           //I            DD       DISP=SHR,DSN=...\n\n           //O            DD       SYSOUT=*,\n\n           //             DCB=(RECFM=FA,LRECL=...,BLKSIZE=.....)\n\n           //STEPLIB      DD       DISP=SHR,DSN=...\n\n Optional control language elements are shown in parentheses.\n The name of the program  may be changed as desired providing\n that the actual program is linked with the appropriate name\n or alias.\n\n REGION is optional but ADDCC does all its processing in core, so\n REGION=64M can't hurt.  STEPLIB may be optional if ADDCC is\n placed in the system's link list but otherwise simply points to\n where ADDCC is stored.\n\n The I file points to the input file to be processed.  All normal\n text should begin in column 2 or beyond (which allows you to put\n your own carriage control, if desired, in column 1).  The\n descriptor language should be prefixed by a colon (:) and begin\n in column 1 (that colon vanishes when the descriptor is\n resolved).  These are generally described here and samples shown\n below.\n\n Page size, that is, the number of lines placed on each page, is\n specified as :PAGESIZE ##, where ## defaults to 58.  The first\n page will always have a '1' (new page) as the carriage control -\n this will allow concatenating several runs of ADDCC together.\n The logical record length, AKA line size, is specified as\n :LINESIZE ##, where ## defaults to 72. These may be changed\n within the code.\n\n :DOCTITLE, :DOCTITLE2 and :DOCTITLE3 may be used to have title\n lines centered and generated on a first page. :TLRDATE may\n specify a date/time to be placed on the left side of the last\n line on the title page, left justified.  Similarly, :TLRDESC\n will place a descriptive entry on the right side of the lowest\n line, right justified.  Obviously, any text may be specified.\n\n :HEADER1 xxx will signal a chapter heading; :HEADER2 yyy a\n section heading. The chapter name, xxx, will be on the top of\n every page in that chapter with \"(Continued)\" suffixed on the\n 2nd and following pages of that chapter. The section data will\n have its first word underlined and use that word in the table of\n contents, if requested.  :HEADERT zzz are simply expanded 50\n character section descriptions which will be used in the table\n of contents. :HEADERT should immediately follow :HEADER2\n entries.\n\n :TOC YES (the default) will cause a table of contents to be\n generated after the title page using the chapter and section\n headings and the generated page numbers.\n\n :RESET allows multiple sets of documentation to be included in\n one run. It will reset the page count to 1 and start the\n carriage control with a new page character ( a 1).\n\n :* with any following text on that line is treated as a\n comment. It is simply read and ignored.\n\n The O output file may be directed to any output class or may be\n sent to a new or existing file.  The DCB attributes may be\n whatever's desired, e.g. F, FB, FA or FBA of any length and\n appropriate block size.\n\n Note that by specifying only the following, ADDCC may be used\n to simply add carriage control to a file with paged breaks\n every PAGESIZE:\n\n      :PAGESIZE  55\n\n      :LINESIZE  80\n\n      :TOC       NO\n\n\n:HEADER1   SAMPLE JCL AND OUTPUT\n\n An example of JCL that may be used is:\n\n      //PRINT      EXEC     PGM=ADDCC,REGION=464M,\n\n      //             PARM='HEAP(01M,01M,ANYWHERE)'\n\n      //O            DD       SYSOUT=V,DEST=PRT60,\n\n      //             DCB=(RECFM=FA,LRECL=080,BLKSIZE=00080)\n\n      //STEPLIB      DD       DISP=SHR,DSN=USER213.K12D.LOADLIB\n\n      //I            DD       *\n\n      :PAGESIZE  50\n\n      :LINESIZE  80\n\n      :TOC       YES\n\n      :DOCTITLE  ADDCC SAMPLE\n\n      :DOCTITLE2 Add Carriage Control Sample Input\n\n      :TLRDESC   Freeware from Steli Inc.\n\n\n      :HEADER1   INTRODUCTION\n\n       This is an introductory paragraph. Note the text begins in\n       (logical) column 2 and the next line will cause the word\n      + _______\n       logical to be underscored!\n\n      :HEADER1 A Mixed Case Chapter heading\n\n       There will be 2 sections following, cleverly named\n       FIRST and SECOND. Note this paragraph is in a chapter\n       but not in a section. Blank lines and all caps may be\n       used to make things more readable...\n\n      :HEADER2 FIRST Section\n\n         This is the first section. Note how I can indent here\n         manually to make a point!\n             SOME DUMB POINT\n\n      :HEADER2 SECOND Section\n      :HEADERT The Second Section Description\n\n         This is the second and last section.\n\n      //******** INPUT ENDS WITH PREVIOUS RECORD... ***********\n\n The above step has the input instream only for the virtue of the\n example.  Note the Second Section only has a :HEADERT control\n following its :HEADER2.  The actual out, shifted right 6 columns\n and having some odd non meaningful data removed, would be as\n follows:\n\n      1\n      -\n      -\n      -\n      -\n      -\n      -\n                                        ADDCC SAMPLE\n                              Add Carriage Control Sample Input\n\n      -\n      -\n      -\n      -\n      -\n      -\n      -\n      -\n                                                Freeware from Steli Inc.\n      1                          TABLE OF CONTENTS           Page      2\n\n\n       INTRODUCTION  . . . . . . . . . . . . . . . . . . . . . . .     3\n\n\n       A Mixed Case Chapter heading  . . . . . . . . . . . . . . .     4\n\n          FIRST  . . . . . . . . . . . . . . . . . . . . . . . . .     4\n          SECOND . . The Second Section Description  . . . . . . .     4\n\n      1                            INTRODUCTION              Page      3\n\n\n       This is an introductory paragraph. Note the text begins in\n       (logical) column 2 and the next line will cause the word\n      + _______\n       logical to be underscored!\n\n      1                    A Mixed Case Chapter heading      Page      4\n\n\n       There will be 2 sections following, cleverly named\n       FIRST and SECOND. Note this paragraph is in a chapter\n       but not in a section. Blank lines and all caps may be\n       used to make things more readable...\n\n       FIRST Section\n      +_____\n\n         This is the first section. Note how I can indent here\n         manually to make a point!\n             SOME DUMB POINT\n\n       SECOND Section\n      +______\n\n         This is the second and last section.\n\n\n:HEADER1   PACKAGE CONTENTS\n\n The files involved specifically with ADDCC are:\n\n     - ADDCC      the PL/I code wrapped in JCL to compile\n                  and link edit it\n\n     - ADDCC$     a JCL skeleton for its execution\n\n:RESET\n:PAGESIZE  58\n:LINESIZE  80\n:TOC       YES\n:DOCTITLE  ALPHACNT\n:DOCTITLE2 Alphanumeric \"Counting\"\n:TLRDATE   January 3, 1999\n:TLRDESC   Freeware from Steli Inc.\n:HEADER1   INTRODUCTION\n\n This document is intended to provide user information for\n counting alphanumerically (ALPHACNT). Some understanding of\n Job Control Language (JCL) is required as well as knowledge of\n how programs are executed.\n\n ALPHACNT is mainframe freeware. It's your toy to do with as you\n desire.\n\n ALPHACNT is a COBOL test program with 3 sub-programs intended\n for MVS compatible systems to provide a counting facility for\n alphanumeric values. The sub-programs are the working parts of\n this facility.  The collating sequence is 'A' through '9'\n keeping the numbers in EBCDIC sequence for sorting purposes.\n Separate sub-programs provide the next and previous value and\n there's another one to verify a value.\n\n ALPHACNT provides a counting scheme for visible, that is,\n displayable characters. Each byte can represent 36 values,\n 'A'...'Z''0'...'9'.  The sequence is meant to be sortable as\n EBCDIC. Its implementation is as sub-programs allowing them to\n be set up as one or more copy books.\n\n Steli Inc. has made its best effort to provide working,\n tested code.  However, nothing is perfect - there may be\n flaws and there certainly could be improvements.  All\n questions, concerns, problems and suggestions may be sent\n to C_Hafner@HotMail.Com.\n\n\n:HEADER1   SAMPLE TEST PROGRAM\n\n The job control language (JCL) provided for ALPHACNT has a main\n COBOL program calling the NXTALPHA, PRVALPHA and VERALPHA\n sub-programs.  It's a standalone, dynamically loaded program\n (uses LOADER rather then linking and executing) that reads a\n test set of 10 digit numbers, their expected next and previous\n values, and calls the sub-programs accordingly.  The verified\n results are then DISPLAYed.\n\n The test input is a small but varied set including a bad value,\n all periods.  Additionally, once it runs out of test data, it\n counts off and displays the first 100 values and the last 100\n values.\n\n Obviously, the counting sequence is all encompassing but\n arbitrary.  The counting is performed via translates, INSPECT\n CONVERTING, and the up and down lists may be changed. Some sites\n have chosen to not use I, L, O, and S, and these were simply\n removed.\n\n\n:HEADER1   PACKAGE CONTENTS\n\n The file involved specifically with ALPHACNT is:\n\n     - ALPHACNT   the COBOL main wrapped in JCL to compile and\n                  execute it\n\n:RESET\n:PAGESIZE  58\n:LINESIZE  80\n:TOC       YES\n:DOCTITLE  COBBITS\n:DOCTITLE2 COBOL Bit Manipulation\n:TLRDATE   February 22, 2001\n:TLRDESC   Freeware from Steli Inc.\n:HEADER1   INTRODUCTION\n\n This document is intended to provide user information for\n manipulating bits of any length within COBOL (COBBITS). Some\n understanding of Job Control Language (JCL) is required as well\n as knowledge of how programs are executed.\n\n COBBITS is mainframe freeware. Feel free to do with it as you will.\n\n COBBITS is a COBOL test program with 4 sub-programs intended for\n MVS compatible systems to provide a bit handling facility for\n COBOL.  The sub-programs allow you to set bits on or off, test\n them to \"see\" what's set and flip (reverse) a bit setting.  The\n bits are accessed as if they were in an array, but any structure\n or variable of any size may be passed as input.\n\n The calling program passes the structure containing the bits,\n which bit to process, and a two byte return code field.  The\n receiving program pretends it's processing a 1,000,000 byte\n array which is used to access the passed structure. That would\n allow 8,000,000 million bits. It can be raised if more are\n needed as the largest single COBOL variable can be 16,000,000 or\n so in size.\n\n Steli Inc. has made its best effort to provide working,\n tested code.  However, nothing is perfect - there may be\n flaws and there certainly could be improvements.  All\n questions, concerns, problems and suggestions are welcome\n and may be sent to C_Hafner@HotMail.Com.\n\n\n:HEADER1   SAMPLE TEST PROGRAM\n\n The job control language (JCL) provided for COBBITS has a main\n COBOL program calling the SETON, SETOFF, TESTBIT and FLIPBIT\n sub-programs.  It's a standalone, dynamically loaded program\n (uses LOADER rather then linking and executing) that reads a\n test set of commands and their expected result. The passed\n structure is an 80 byte array which is written to the O file\n each time a command is processed (set hex on within SDSF or\n whatever you're using to view the output).  The verified results\n are then DISPLAYed.\n\n The test input is a small but representative set, turning bits\n on and off and checking the results.\n\n\n:HEADER1   PACKAGE CONTENTS\n\n The files involved specifically with COBBITS are:\n\n     - COBBITS    the COBOL main wrapped in JCL to compile and\n                  execute it\n\n:RESET\n:PAGESIZE  58\n:LINESIZE  80\n:TOC       YES\n:DOCTITLE  COBHEXR\n:DOCTITLE2 COBOL Hexidecimal Conversion\n:TLRDATE   March 17, 2001\n:TLRDESC   Freeware from Steli Inc.\n:HEADER1   INTRODUCTION\n\n This document is intended to provide user information for\n converting character strings to their hexidecimal equivalent,\n that is, 'ABC' to 'C1C2C3' etc. Some understanding of Job\n Control Language (JCL) is required as well as knowledge of how\n programs are executed.\n\n COBHEXR is mainframe freeware. Feel free to do with it as you will.\n It's a test program with the built in sub-program.\n\n The calling program passes the input and its length, an output\n field (twice the size of the input), and a two byte return code\n field.  The receiving program checks the length which must be\n greater then zero and less then 5,000.  It then converts the\n string and passes it and a zero return code back.\n\n Steli Inc. has made its best effort to provide working, tested\n code.  However, nothing is perfect - there may be flaws and\n there certainly could be improvements.  All questions, concerns,\n problems and suggestions are welcome at C_Hafner@HotMail.Com.\n\n\n:HEADER1   SAMPLE TEST PROGRAM\n\n The job control language (JCL) provided for COBHEXR has a main\n COBOL program calling the COBHEXR sub-program.  It's a\n standalone, dynamically loaded program (uses LOADER rather then\n linking and executing) that reads a test set of commands and\n their expected result. The input structure is:\n\n      Columns  1 -  2    Length of input\n\n      Columns  5 - 26    Input\n\n      Columns 29 - 72    Expected return value\n\n For each line of input, COBHEXR is called passing the input\n value. The returned value is checked against the expected value\n and a message is displayed if they're nor equal\n\n The test input is:\n\n    12  ABCDEFGHIJKL            C1C2C3C4C5C6C7C8C9D1D2D3\n\n    01  .                       4B\n\n    12  LKJIHGFEDCBA            D3D2D1C9C8C7C6C5C4C3C2C1\n\n    20  12345678901234567890    F1F2F3F4F5F6F7F8F9F0F1F2F3F4F5F6F7F8F9F0\n\n    04  ~!@#                    A15A7C7B\n\n    10                          40404040404040404040\n\n showing that varying lengths may be passed for the same input area.\n\n\n:HEADER1   PACKAGE CONTENTS\n\n The files involved specifically with COBHEXR are:\n\n     - COBHEXR    the COBOL main wrapped in JCL to compile and\n                  execute it\n\n:RESET\n:PAGESIZE  58\n:LINESIZE  80\n:TOC       YES\n:DOCTITLE  DETAB\n:DOCTITLE2 Expand Separator Character\n:DOCTITLE3 Delimited File\n:TLRDATE   March 12, 2003\n:TLRDESC   Freeware from Steli Inc.\n:HEADER1   INTRODUCTION\n\n This document is intended to provide user information for the\n utility to expand separator character delimited data files\n (DETAB).  Some understanding of Job Control Language (JCL) is\n required as well as knowledge of how programs are executed.\n\n DETAB is mainframe freeware. It's available for any use you\n wish to make of it.\n\n DETAB is intended for MVS compatible systems to restructure a\n file containing some special character as a separator.  It can\n examine the file and determine the maximum length of every field\n and then rebuild the file into a new file making every field the\n maximum size, right justifying and zero padding numeric fields\n (keeping the sign, if any, left justified) and left justifying\n alphanumeric fields.\n DETAB will allow the input of a master format that will allow\n overriding the sizes and data types found. When selected, this\n option also checks that numeric fields are in fact always\n numeric and will flag fields that are bigger then specified in\n the format.\n\n It also generates dummy COBOL and Eastrieve copybooks/file\n layouts matching the new file and it generates a data layout\n that may be changed and input into DETAB again as a master\n format.\n\n When in non-master format mode, it will not generate elementary\n variable entries if no data at all was specified within the\n input for a given field.  That is, if the field was of zero\n length every time, delimiters back to back, a note is made of\n zero entry for that field and no COBOL or Easytrieve variable is\n generated.  A field will be generated in the layout output for\n an alphabetic field of zero length.\n\n Up to 1,000 fields may be handled (or the program may be changed\n to allow more).  Any size records of any record format may be\n passed as input and the output file is always a variable file of\n logical record length 27,994 and block size 27,998.  Obviously,\n the actual record sizes are that of the calculated fixed size\n and the resulting file may be copied via sort to a fixed file if\n so desired. But, for reasonableness of programming, the variable\n maximum size was used.\n\n The separator character is passed as a parameter to the program\n and may be any character.  The separator character is printed as\n input plus as its two hex character equivalent and the size of\n the restructured record is also shown.\n\n Once the file has been analyzed and the second phase starts\n generating expanded records, DETAB will check to see that every\n record length is the same. If not, it will generate error\n messages to SYSOUT. Some causes have been having separator\n characters within the data thereby confusing the program and\n forgetting that there was a header or trailer.\n\n Steli Inc. has made its best effort to provide working, tested\n code.  However, nothing is perfect - there may be flaws and\n there certainly could be improvements.  All questions, concerns,\n problems and suggestions are welcome.  Please e-mail them to\n C_Hafner@HotMail.Com.\n\n\n:HEADER1   EXECUTION JCL\n\n The job control language (JCL) for DETAB is:\n\n     //DETAB      EXEC     PGM=DETAB,PARM='%NNNNN',REGION=24M\n     //*                                   ||||||\n     //*  SEPARATOR CHARACTER  ------------+|||||\n     //*  PROCESS HEADER  ------------------+||||\n     //*  PROCESS TRAILER  ------------------+|||\n     //*  MASTER FORMAT AVAILABLE  -----------+||\n     //*  REMOVE NUMERIC DECIMAL POINTS  ------+|\n     //*  PUT SIGN ON LAST DIGIT  --------------+\n\n     //*\n\n     //STEPLIB      DD       DISP=SHR,DSN=Your.Load.Library\n\n     //I            DD       DISP=SHR,DSN=Your.Delimited.File,\n     //             DCB=BUFNO=64\n\n     //MASTER       DD       *\n     FIELD00001                      00001  A  00\n        . . .\n     FIELD00012                      00005  N  03\n\n     //O            DD       DISP=(,CATLG),\n     //             DSN=Your.$$$TEMP.DETAB,\n     //             UNIT=SYSDA,SPACE=(CYL,(0010,0010),RLSE),\n     //             DCB=(RECFM=VB,LRECL=27994,BLKSIZE=27998,BUFNO=64)\n\n     //OCOB         DD       DISP=(,CATLG),\n     //             DSN=Your.$$$TEMP.DETAB.COBOUT,\n     //             UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),\n     //             DCB=(RECFM=FB,LRECL=80)\n\n     //OEZ          DD       DISP=(,CATLG),\n     //             DSN=Your.$$$TEMP.DETAB.EZOUT,\n     //             UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),\n     //             DCB=(RECFM=FB,LRECL=80)\n\n     //LAYOUT       DD       SYSOUT=*,DCB=(RECFM=FB,BLKSIZE=80)\n\n     //SYSOUT       DD       SYSOUT=*,DCB=BLKSIZE=121\n\n     //SYSPRINT     DD       SYSOUT=*\n\n The name of the program may be changed as desired providing\n that the actual program is linked with the appropriate name\n or alias.\n\n REGION is optional.  STEPLIB may be optional if DETAB is\n placed in the system's link list but otherwise simply points to\n where DETAB is stored.\n\n The separator character is provided by the first character of\n the PARM statement. The sample shown above is a percent sign for\n easy visualization.  The next character specifies whether a\n header is in the file and needs to be ignored. The 3rd character\n does the same for a trailer record.\n\n The 4th character of the PARM indicates whether a MASTER format\n is provided which is to override the field sizes found and\n possibly the field types. The MASTER DD card may be left in the\n JCL since it will not be opened if this option is an 'N'.\n\n The 5th PARM character specifies whether numeric fields with\n decimal points should have the decimal point removed. Whether\n they are removed or not, DETAB will always try to align the\n explicit or implicit decimal place.\n\n The 6th PARM position indicates that a field with signs, plus or\n minus found in ANY record within that field, will be rolled onto\n the last character. That is, the last character gets the\n appropriate zone value, { for plus zero, } for minus zero A for\n plus one, J for minus one, etc. If only some of the fields have\n signs, the unsigned foelds will be taken as positive.\n\n The input separator character delimited file is specified to I;\n the O file will contain the expanded data; OCOB and OEZ will\n contain the COBOL and Easytrieve structures.  Note the COBOL and\n Easytrieve layouts should be LRECL 80. The restructured file\n (file O) will be VB/27994/27998 but can be changed as desired.\n\n Note that if some columns are obviously not what you desire, the\n various macros such as DELCOLS, FILLINS and FILLCOLS of File 357\n of the CBTTape will easily insert or remove columns and data.\n\n The SYSOUT file will contain any error or warning messages - if\n there are any, the return code for the job will not be zero.\n SYSPRINT contains the summary counts for the job and LAYOUT will\n contain the structure in a format suitable for changing and\n re-entry as the master format. Using the SE option within SDSF\n will allow you to gather the LAYOUT data and insrt in into a PDS\n as a member.\n\n\n:HEADER1   SAMPLE JCL AND OUTPUT\n\n An example of the input that may be processed is:\n\n     AAAAA%BBBBBBBBBB%%666666%ZZZ\n\n     AAA%BB%%999999999%ZZZ\n\n     AAAAA%BB%%22%ZZZ\n\n     AAAA%BB%%4444%ZZZ\n\n     A%BB%%1%ZZZ\n\n Given similar JCL to the sample JCL above, the restructured\n output would be:\n\n     AAAAABBBBBBBBBB000666666ZZZ\n\n     AAA  BB        999999999ZZZ\n\n     AAAAABB        000000022ZZZ\n\n     AAAA BB        000004444ZZZ\n\n     A    BB        000000001ZZZ\n\n The print out from the job would be:\n\n     **************************************\n\n     ***  030802 DETAB STATS 095411092  ***\n\n     **************************************\n\n     ***  NUMBER RECORDS READ:            5\n\n     ***  NUMBER RECORDS WRITTEN:         5\n\n     ***  NUMBER ZERO LEN FIELDS:         1\n\n       *  FIELD      3 IS ALWAYS ZERO LENGTH\n\n     ***  SEP_CHAR VALUE RECEIVED:     X'6C' (%)\n\n     ***  OUTPUT RECORD SIZE:            27\n\n The COBOL copybook would be:\n\n     10  POS-00001                        PIC  X(00005).\n\n     10  POS-00006                        PIC  X(00010).\n\n     10  POS-00016                        PIC  9(00009).\n\n     10  POS-00025                        PIC  X(00003).\n\n and the Easytrieve layout would be:\n\n     POS-00001                            1       5   A\n\n     POS-00006                            6      10   A\n\n     POS-00016                           16       9   N  00\n\n     POS-00025                           25       3   A\n\n and generated LAYOUT file is:\n\n     FIELD00001                      00005  A  00\n\n     FIELD00002                      00010  A  00\n\n     FIELD00003                      00000  A  00\n\n     FIELD00004                      00009  N  00\n\n     FIELD00005                      00003  A  00\n\n Another example of the input that may be processed is:\n\n     AAAAA%123.4%123%666666%Z\n\n     AAA%2.3%456%999999999%ZZ\n\n     AAAAA%345.6789%789012%22%ZZZ\n\n     AAAA%-45.67% %4444%ZZZZ\n\n     A%0.0%999%1%ZZZZZ\n\n Given similar JCL to the sample JCL above, but with a Y for\n eliminating the decimal point and for rolling signs, the\n restructured output would be:\n\n     AAAAA0123400{123   000666666Z\n\n     AAA  0002300{456   999999999ZZ\n\n     AAAAA0345678I789012000000022ZZZ\n\n     AAAA 0045670}      000004444ZZZZ\n\n     A    0000000{999   000000001ZZZZZ\n\n The print out from the job would be:\n\n     **************************************\n\n     ***  030809 DETAB STATS 140914240  ***\n\n     **************************************\n\n     ***  NUMBER RECORDS READ:            5\n\n     ***  NUMBER RECORDS WRITTEN:         5\n\n     ***  NUMBER ZERO LEN FIELDS:         0\n\n     ***  SEP_CHAR VALUE RECEIVED:     X'6C' (%)\n\n     ***  OUTPUT RECORD SIZE:            33\n\n The COBOL copybook would be:\n\n     10  POS-00001                        PIC  X(00005).\n\n     10  POS-00006                        PIC S9(00008)V9(04).\n\n     10  POS-00014                        PIC  X(00006).\n\n     10  POS-00020                        PIC  9(00009).\n\n     10  POS-00029                        PIC  X(00005).\n\n and the Easytrieve layout would be:\n\n     POS-00001                            1       5   A\n\n     POS-00006                            6       8   N  04\n\n     POS-00014                           14       6   A\n\n     POS-00020                           20       9   N  00\n\n     POS-00029                           29       5   A\n\n and generated LAYOUT file is:\n\n     FIELD00001                      00005  A  00\n\n     FIELD00002                      00008  N  04\n\n     FIELD00003                      00006  A  00\n\n     FIELD00004                      00009  N  00\n\n     FIELD00005                      00005  A  00\n\n Please note in the immediately previous example, the second\n field is padded on the right with 0's and gets the sign imposed\n on the last digit, the third field appears to be numeric but the\n 4th record has a blank in that field causing it to be alphabetic\n and left justified, the forth field is numeric but has no signs\n and no decimal places and thus just gets left padded, and the\n last field is 5 bytes padded on the right with blanks.\n\n\n:HEADER1   PACKAGE CONTENTS\n\n The files involved specifically with DETAB are:\n\n     - DETAB      the PL/I code wrapped in JCL to\n                  compile and link edit it\n\n     - DETAB$     a JCL skeleton for its execution\n\n:RESET\n:PAGESIZE  58\n:LINESIZE  80\n:TOC       YES\n:DOCTITLE  DIRSCNC/DIRSCNQ\n:DOCTITLE2 Read Partitioned Data Set Directory\n:DOCTITLE2 and Generate Cards Images Replacing Tokens\n:TLRDATE   September 9, 2003\n:TLRDESC   Freeware from Steli Inc.\n:HEADER1   INTRODUCTION\n\n This document is intended to provide user information for the\n paired COBOL and PL/I utilities to read any Partitioned Data Set\n (PDS) directory and replace tokens in a card image input stream\n with member names.  Some knowledge of Job Control Language (JCL)\n is required as well as knowledge of how programs are executed.\n\n DIRSCNC and DIRSCNQ are mainframe freeware, available for any\n use you wish to make of them. They are intended for MVS\n compatible systems to provide the capability to generate a\n stream of card images for each member in a given PDS. Suggested\n uses are generating compile and link jobs, compare (ala SuperC\n or CompareX) steps, or list steps.\n\n The reason behind having both a COBOL and a PL/I version is\n partially to show it could be done and partly to eliminate\n complaints from users of one language who just can't do both :)\n\n Steli Inc. has made its best effort to provide working, tested\n code.  However, nothing is perfect - there may be flaws and\n there certainly could be improvements.  All questions, concerns,\n problems and suggestions are welcome.  Please e-mail them to\n C_Hafner@HotMail.Com.\n\n\n:HEADER1   EXECUTION JCL\n\n The job control language (JCL) for DIRSCNC and DIRSCNQ is:\n\n    //DIRSCNx    EXEC     PGM=DIRSCNx,REGION=4M\n\n    //STEPLIB      DD       DISP=SHR,DSN=WHATEVER.LOADLIB\n\n    //I            DD       DISP=SHR,DCB=(RECFM=F,LRECL=256,BLKSIZE=256),\n\n    //             DSN=SOME.PDS\n\n    //SYSIN        DD       DATA,DLM=XX\n\n      ########   FIXED 8 BYTE MEMBER NAME\n\n      ????????   VARIABLE MEMBER NAME\n\n    XX\n\n    //SELMEM       DD       *\n\n    FIRST=000001, LAST=999999, FIRSTMEM='        ', LASTMEM='99999999';\n\n    //O            DD         DISP=(,CATLG),\n\n    //             DSN=USERID.OUTPUT.CARD.IMAGES,\n\n    //             UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),\n\n    //             DCB=(RECFM=FB,LRECL=80)\n\n The same JCL works for both DIRSCNC and DIRSCNQ.  The name of\n either program may be changed as desired providing that the\n actual program is linked with the appropriate name or alias.\n\n REGION is optional.  STEPLIB may be optional if the given load\n module is placed in the system's link list but otherwise simply\n points to where the module is stored.\n\n The input PDS is specified by the I DD card.  It may be a load\n library, a JCL library or any PDS. The DCB information is there\n because COBOL had a record size disagreement when processing a\n PDS with LRECL not equal to 0.\n\n The SYSIN file contains the images to be generated for each\n member. Any string of 8 question marks (????????) will be\n replaced by the member name, deleting blanks from the end of the\n name.  Any string of 8 pound sugns (########) will also be\n replaced by the member name but without removing blanks.  The\n samples below show SYSIN having a DLM option. This is only there\n to show JCL could easily be input.\n\n SELMEM allows ranges of members to be specified, either by\n number (e.g. the first 100) or by name (e.g. FRED through GROK).\n The last named options may both be specified as shown, but it\n would make sense to use 1 through 999999 and then a name range,\n or 1 through 100 with blank through 99999999 as the name range.\n\n The O DD is the file where the output will be sent. Since we're\n duplicating card images from SYSIN, this is an 80 byte file.\n\n\n:HEADER1   SAMPLE JCL AND OUTPUT\n\n An example of JCL that may be used is:\n\n    //***\n\n    //***  CREATE BACKUP IEBCOPY SELECT STATEMENTS\n\n    //***\n\n    //DELETE     EXEC       PGM=IEFBR14\n\n    //SCRATCH      DD         DISP=(MOD,DELETE,DELETE),\n\n    //             DSN=USERID.$$$TEMP.DIRSCNC,\n\n    //             UNIT=SYSDA,SPACE=(TRK,0)\n\n    //***\n\n    //DIRSCNC    EXEC     PGM=DIRSCNC,PARM=NR,REGION=4M\n\n    //STEPLIB      DD       DISP=SHR,DSN=YOUR.LOADLIB\n\n    //I            DD       DISP=SHR,DCB=(RECFM=F,LRECL=256,BLKSIZE=256),\n\n    //             DSN=SOME.PDS.WHERE.YOU.WANT.BKUP.COPIES\n\n    //SYSIN        DD       DATA,DLM=XX\n\n      S  M=((????????,????????O,R))\n\n    XX\n\n    //SELMEM       DD       *\n\n    FIRST=000001, LAST=999999, FIRSTMEM='        ', LASTMEM='99999999';\n\n    //O            DD         DISP=(,CATLG),\n\n    //             DSN=Your.$$$TEMP.DIRSCNC,\n\n    //             UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),\n\n    //             DCB=(RECFM=FB,LRECL=80)\n\n    //***\n\n\n Given that SOME.PDS.WHERE.YOU.WANT.BKUP.COPIES contains members\n AAA, MODGEN2, AKA666 and X, the above step would generate:\n\n      S  M=((AAA,AAAO,R))\n\n      S  M=((MODGEN2,MODGEN2O,R))\n\n      S  M=((AKA666,AKA666O,R))\n\n      S  M=((X,XO,R))\n\n Given that none of the original PDS member names were over 7\n characters, these IEBCOPY statements could be used to make back\n up copies of each member.\n\n\n:HEADER1   PACKAGE CONTENTS\n\n The files involved specifically with ABENDX are:\n\n     - DIRSCNC    the COBOL compile and link JCL for DIRSCNC\n\n     - DIRSCNC$   a JCL skeleton for executing DIRSCNC\n\n     - DIRSCNQ    the PL/I compile and link JCL for DIRSCNQ\n\n     - DIRSCNQ$   a JCL skeleton for executing DIRSCNQ\n\n:RESET\n:PAGESIZE  58\n:LINESIZE  80\n:TOC       YES\n:DOCTITLE  FOREVER\n:DOCTITLE2 Generate Job Periodically To Update Last\n:DOCTITLE3 Referenced Date for List of Data Sets\n:TLRDATE   April 14, 2000\n:TLRDESC   Freeware from Steli Inc.\n:HEADER1   INTRODUCTION\n\n This document is intended to provide user information for the\n utility to update the last referenced date for a list of data\n sets. It's a COBOL program (FOREVER).  Some knowledge of Job\n Control Language (JCL) is required as well as knowledge of how\n programs are executed.\n\n FOREVER is mainframe freeware. It's available for any use you\n wish to make of it. FOREVER is intended for MVS compatible\n systems to provide the capability to identify a file's name from\n within a COBOL program.\n\n Steli Inc. has made its best effort to provide working, tested\n code.  However, nothing is perfect - there may be flaws and\n there certainly could be improvements.  All questions, concerns,\n problems and suggestions are welcome.  Please e-mail them to\n C_Hafner@HotMail.Com.\n\n\n:HEADER1   FOREVER STRATEGY\n\n Many sites have drop dead dates for files that have not been\n accessed in some time frame, say 3 months. Many organizations\n have data sets which are only accessed on a mid year or even\n yearly basis.\n\n FOREVER is intended to provide some protection by updating the\n last referenced date of a list of files on some periodic time\n frame, say weekly. The program is invoked via REXX code in a\n logon Exec executed daily. It checks for Friday (easily changed\n to any desired day of the week). It then checks to see if it has\n already been run on that day, and either submits the job with\n the executing user's information for job name and notify, or it\n quits. The FOREVER file's disposition is OLD to prevent multiple\n submissions. The job uses IDCAMS PRINT of one record to cause\n the read access. This works against sequential and pertitioned\n data sets as well as VSAM files. It does give an I/O error when\n doing the read against a PDS since it's reading the directory\n trying to use the LRECL of the data set. It makes no never mind\n since the data set is still accessed as desired.\n\n When the job runs, it updates the date in the FOREVER file to the\n current date. Obviously, you may or may not want this run weekly,\n semi-monthly or even monthly may be adequate. That would require\n a code change.\n\n\n:HEADER1   EXECUTION REXX EXEC\n\n The following REXX Exec code should be placed in an Exec that\n runs every time concerned users logon. It will check for a\n Friday and then check to see if it has already run the job, only\n submitting the job once. Note it passes the executing user ID to\n the program. The actual FOREVER file name and the load module\n library for the program must be changed appropriately.\n\n      /**  FOREVER FILE PROCESSING  **/\n\n         ADDRESS TSO\n\n         \"FREE DD(I O SYSOUT)\"\n\n         \"ALLOC DSN(*) DD(SYSOUT)\"\n\n         \"ALLOC DSN('SomeHLQ.Forever.File') DD(I) OLD\"\n\n         \"ALLOC DD(O) SYSOUT(A) WRITER(INTRDR)\"\n\n         \"CALL 'SomeHLQ.Loadlib(FOREVER)' '\"USERID()\"'\"\n\n         \"FREE DD(I O SYSOUT)\"\n\n\n:HEADER1   FOREVER FILE LAYOUT\n\n The format is straightforward, the first line has the last run\n date in column 1. Each subsequent card has a data set name in\n column 1. The latter do not have to be in any order.\n\n      20000331 --  ENTER DATA SETS BELOW STARTING EACH IN COLUMN 1\n\n      SYS4.BACKUP.SYSTEM.CLISTS\n\n      SOMEUSER.REALLY.NEEDED.DATA\n\n      ...\n\n\n:HEADER1   PACKAGE CONTENTS\n\n The file involved specifically with FOREVER is:\n\n     - FOREVER    the COBOL code in JCL to\n                  assemble and link edit it\n\n     - FOREVERX   the REXX Ecec code to be\n                  executed as part of each\n                  user's logon\n\n:RESET\n:PAGESIZE  58\n:LINESIZE  80\n:TOC       YES\n:DOCTITLE  GETDSN\n:DOCTITLE2 Get Data Set Name from within COBOL\n:TLRDATE   March 23, 2000\n:TLRDESC   Freeware from Steli Inc.\n:HEADER1   INTRODUCTION\n\n This document is intended to provide user information for the\n utility to retrieve the data set name for a given file from\n within a COBOL program (GETDSN).  Some knowledge of Job Control\n Language (JCL) is required as well as knowledge of how programs\n are executed.\n\n GETDSN is mainframe freeware. It's available for any use you\n wish to make of it. GETDSN is intended for MVS compatible\n systems to provide the capability to identify a file's name from\n within a COBOL program.\n\n Steli Inc. has made its best effort to provide working, tested\n code.  However, nothing is perfect - there may be flaws and\n there certainly could be improvements.  All questions, concerns,\n problems and suggestions are welcome.  Please e-mail them to\n C_Hafner@HotMail.Com.\n\n\n:HEADER1   SAMPLE PROGRAM CALLING GETDSN\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  TRYGET.\n      *COBOL SAMPLE CODE INVOKING GETDSN\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT I ASSIGN TO I.\n           SELECT J ASSIGN TO J.\n       DATA DIVISION.\n       FILE SECTION.\n       FD  I\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  INPUT-REC    PIC X(00080).\n       FD  J\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  INPUT-REC2   PIC X(00080).\n       WORKING-STORAGE SECTION.\n       01  WS-DSNS.\n           05  I-NAME          PIC X(44).\n           05  I-MEMBER        PIC X(08).\n           05  J-NAME          PIC X(44).\n           05  J-MEMBER        PIC X(08).\n       PROCEDURE DIVISION.\n       0000-MAIN.\n              DISPLAY '***  TOP OF PROGRAM  ***'\n\n              OPEN INPUT I, J\n\n              CALL 'GETDSN' USING I, I-NAME, I-MEMBER\n              DISPLAY 'THE DATA SET ASSOCIATED WITH FILE I IS ' I-NAME\n              DISPLAY 'THE MEMBER ASSOCIATED WITH FILE I IS   ' I-MEMBER\n\n              CALL 'GETDSN' USING J, J-NAME, J-MEMBER\n              DISPLAY 'THE DATA SET ASSOCIATED WITH FILE J IS ' J-NAME\n              DISPLAY 'THE MEMBER ASSOCIATED WITH FILE J IS   ' J-MEMBER\n\n              CLOSE I, J\n\n              DISPLAY '***  END OF PROGRAM  ***'\n              GOBACK\n              .\n\n\n:HEADER1   PACKAGE CONTENTS\n\n The file involved specifically with GETDSN is:\n\n     - GETDSN     the assembler code in JCL to\n                  assemble and link edit it\n\n:RESET\n:PAGESIZE  58\n:LINESIZE  80\n:TOC       YES\n:DOCTITLE  PAGES\n:DOCTITLE2 Pull Selected Pages\n:TLRDATE   March 17, 2000\n:TLRDESC   Freeware from Steli Inc.\n:HEADER1   INTRODUCTION\n\n This document is intended to provide user information for\n retrieving logical pages from a carriage controlled sequential\n file (PAGES).  Given a sequential file containing 5,000 pages,\n that has ASCII carriage controlled lines, PAGES will allow you\n to pull specific pages from the front, middle, end or a specific\n range.  PAGES will do this easily in one run saving paper and/or\n having to customize code.  Some understanding of Job Control\n Language (JCL) is required as well as knowledge of how programs\n are executed.\n\n PAGES is mainframe freeware.  You may use, change or ignore\n it, as you want.\n\n Steli Inc. has made its best effort to provide working,\n tested code.  However, nothing is perfect - there may be\n flaws and there certainly could be improvements.  All\n questions, concerns, problems and suggestions are welcome\n and may be sent to C_Hafner@HotMail.Com.\n\n\n:HEADER1   EXECUTION JCL\n\n The job control language (JCL) for PAGES is:\n\n      //SELPAGES   EXEC     PGM=PAGES   ( ,REGION=4M )\n\n      //INFILE       DD       DISP=SHR, ( DCB=BUFNO=32, )\n\n      //             DSN=...\n\n        FIRST=50,     LAST=50,      MIDDLE=-1,     FROM=-1,      TO=-1;\n\n      //SYSPRINT     DD       SYSOUT=*\n\n      //OUTFILE      DD       DSN=...,\n\n      //             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(05,02),RLSE),\n\n      //             DCB=(RECFM=FBA,LRECL=...,BLKSIZE=0,BUFNO=32)\n\n      //STEPLIB      DD       DISP=SHR,DSN=...\n\n Optional control language elements are shown in parentheses.\n The name of the program  may be changed as desired providing\n that the actual program is linked with the appropriate name or\n alias.  REGION is optional - the default region size may be more\n then adequate depending on your local standards.\n\n INFILE contains the original ASCII carriage controlled data.\n That is, there's a '1' in column one to indicate the start of a\n new page. The very first line in the file will be recognized as\n the starting page, page 1, whether there is a '1' there or not.\n The BUFNO parameter is useful to speed processing but not\n necessary.\n\n The SYSIN file contains the specification of the page numbers to\n be selected from INFILE. The \"null\" indicator, -1, is only shown\n to provide a place holder for subsequent runs - leaving those\n parameters off will not hurt. They are free form but do need to\n be terminated with a semicolon (;).\n\n FIRST indicates the number of pages to be selected from the\n front of INFILE, MIDDLE from the center section, and LAST from\n the end. FROM and TO determine specific pages to be pulled.  All\n may be specified at one time as shown in the example below.\n\n SYSPRINT will contain a display of the total number of pages in\n INFILE, the total number of lines and which and how many pages\n were selected.\n\n OUTFILE receives the selected pages. DCB information may be hard\n coded as shown or may refer back to the cataloged input file.\n Again, BUFNO may help performance if the output is still rather\n large.\n\n STEPLIB may be optional if PAGES is placed in the system's link\n list but otherwise simply points to where PAGES is stored.\n\n\n:HEADER1   SAMPLE JCL AND OUTPUT\n\n A sample of what might be submitted is:\n\n      //CULL       EXEC     PGM=PAGES,REGION=4M\n\n      //INFILE       DD       DISP=SHR,DCB=BUFNO=32,\n\n      //             DSN=USERID.SOME.LARGE.PRINT.FILE\n\n        FIRST=11,     LAST=04,      MIDDLE=20,     FROM=42,      TO=43;\n\n      //SYSPRINT     DD       SYSOUT=*\n\n      //OUTFILE      DD       DSN=USERID.THE.CULLED.FILE,\n\n      //             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(05,02),RLSE),\n\n      //             DCB=(USERID.SOME.LARGE.PRINT.FILE,BUFNO=32)\n\n      //STEPLIB      DD       DISP=SHR,DSN=SYS4.USERLIB\n\n Assuming there were 500 6 line pages on the input file, the\n SYSPRINT would look like:\n\n      **************************************\n      ***  YYMMDD STATISTICS HHMMSSTTT  ****\n      **************************************\n\n      ** TOTAL PAGES ON FILE:            500\n\n      ** TOTAL RECORDS ON FILE:        3,000\n\n      ** FIRST PAGES SELECTED:            11\n\n      ** MIDDLE PAGES SELECTED:           20\n\n      ** LAST PAGES SELECTED:              4\n\n      ** PAGE RANGE SELECTED FROM:        42\n\n      **                      TO:         43\n\n      ** TOTAL PAGES SELECTED:            37\n\n      ** TOTAL LINES SELECTED:           222\n\n where YYMMDD would contain the run date and HHMMSSTTT the run\n time. Note the DCB information for the output file was acquired\n from the input file and BUFNO was also specified.\n\n\n:HEADER1   PACKAGE CONTENTS\n\n The files involved specifically with PAGES are:\n\n     - PAGES      the PL/I code wrapped in JCL to compile\n                  and link edit it\n\n     - PAGES$     a JCL skeleton for its execution\n\n:RESET\n:PAGESIZE  58\n:LINESIZE  80\n:TOC       YES\n:DOCTITLE  PDSLIST\n:DOCTITLE2 Partitioned Data Set\n:DOCTITLE3 List Utility\n:TLRDATE   September 14, 2000\n:TLRDESC   Freeware from Steli Inc.\n:HEADER1   INTRODUCTION\n\n This document is intended to provide user information for\n the Partitioned Data Set List utility (PDSLIST). Some\n understanding of Job Control Language (JCL) is required as\n well as knowledge of how programs are executed.\n\n PDSLIST is mainframe freeware.  You may do anything you want\n with it.\n\n PDSLIST is intended for MVS compatible systems to print the\n members of one or more partitioned data sets (PDS's) in\n alphabetical order.  It will process concatenated PDS's up\n to the number currently allowed by the operating system and\n data of any size or type, fixed, variable or unformatted.\n Options may be specified through free form control cards.\n\n The member data is displayed in the middle 100 characters of\n a 120 byte print line and lengths are printed in the first 5\n bytes of the starting  line for fixed data over 100 bytes\n long and for all variable or unformatted data.  An ASCII\n control character prefixes the 120 characters to minimize\n output.\n\n PDSLIST through its options will also:\n\n    - Provide an index indicating where each member resides\n      and the page number on which the member begins printing\n      (INDEX)\n\n    - Provide only the index, not printing any member data\n      (INDEX(ONLY))\n\n    - Show only a portion of each member (FIRST(.))\n\n    - Display duplicate members, i.e. show members with the\n      same name that are in one or more PDS's in the concatenation\n      (DUPS)\n\n    - Show only members that have duplicates within the\n      concatenation (DUPS(ONLY)\n\n    - Allow a range of members to be selected  (>MEMBER(.)\n      and <MEMBER(.))\n\n    - Display member data as both characters and their hex\n      equivalent (HEX)\n\n    - Display a footing on each page (FOOTING(.))\n\n    - Print each member on a new page or separated by a few\n      blank lines (EJECT)\n\n    - Indicate whether a member is an alias of another member\n      (ALIAS)\n\n    - List the options specified as well as the defaulted\n      ones (OPTIONS)\n\n    - Change the block size of the printed file (BLKSIZE(.))\n\n    - Cause characters sent to the print file to be only\n      printable ones (TRANSLATE)\n\n\n:HEADER1   VERSION UPDATE\n\n PDSLIST Version 2 contains a number of changes, mostly internal.\n It is backward compatible with minor output differences.  The\n updates are:\n\n    - The program is now reentrant and will run above the 16\n      meg line (AMODE 31 and RMODE ANY)\n\n    - The code and the documentation have been heavily\n      revised for clarity and maintainability.  The ability to\n      change option defaults and DD names has been enhanced by\n      placing them all in one area and automating their\n      implementation throughout the code (via SETC and SETA\n      statements)\n\n    - Display the options used\n\n    - Show whether a member is an alias\n\n    - Allow SYSIN DD card to be omitted\n\n    - Make HEX and TRANSLATE compatible in same run\n\n    - Display footing on every page\n\n    - Use specified page size for all printed output\n\n    - Show only duplicate members in index for DUPS(ONLY)\n\n These changes reflect all the comments made so far to Steli Inc.\n for PDSLIST.  Thanks go to several people who actually read the\n documentation and suggested clarifications as well as to the\n folks who suggested the changes and to those who pointed out the\n problems.  There's a fix to the reentrant code, thanks to Tom\n Esela, that corectly initilaized the dynamic work area\n preventing problems when running from an APF (linklist) library.\n\n Steli Inc. has made its best effort to provide working, tested\n code.  However, nothing is perfect - there may be flaws and\n there certainly could be improvements.  All questions, concerns,\n problems and suggestions are welcome and may be sent to\n C_Hafner@HotMail.Com.\n\n\n:HEADER1   EXECUTION JCL\n\n The job control language (JCL) for PDSLIST is:\n\n           //   EXEC   PGM=PDSLIST ( ,REGION=4M )\n\n           //STEPLIB     DD   DISP=SHR,DSN=...\n\n           //SYSPRINT    DD   SYSOUT=*\n\n           //SYSUT1      DD   DISP=SHR,DSN=PDS1\n\n         ( //            DD   DISP=SHR,DSN=PDS2 )\n\n         (    ...   optionally, as many         )\n\n         (    ...      concatenated PDS's       )\n\n         (    ...         as allowed in MVS/ESA )\n\n         ( //SYSIN       DD   *                 )\n\n         (        control cards . . .           )\n\n Optional control language elements are shown in parentheses.\n The name of the program  may be changed as desired providing\n that the actual program is linked with the appropriate name or\n alias.\n\n REGION is optional but PDSLIST requires approximately 192,000\n bytes as well as 20 bytes for each member (system required\n resources may increase this amount).  In most cases the default\n region size is adequate to meet these requirements.  STEPLIB may\n be optional if PDSLIST is placed in the system's link list but\n otherwise simply points to where PDSLIST is stored.\n\n The SYSPRINT file may be directed to any output class or may be\n sent to a new or existing file.  The DCB attributes of SYSPRINT\n will be record format FBA and LRECL 121.  The BLKSIZE may be set\n through the BLKSIZE control card option within PDSLIST but will\n default to 121.\n\n SYSUT1 points to the one or more PDS's to be processed.  SYSIN\n contains control information and may be omitted, set to //SYSIN\n DD DUMMY or simply be empty.  Full control card descriptions are\n shown below.\n\n The DD names and SYSPRINT block size may be changed as desired\n in the defaults section of the source code.  If an incorrect\n name is specified, the program will terminate returning the code\n received from opening the data set (the system will generally\n indicate the missing DD name).\n\n\n:HEADER1   CONTROL CARDS\n\n The control card values may be specified free form in the first\n 72 columns of the records in the SYSIN file in any order and may\n be separated by commas, blanks or simply concatenated together.\n Each option must be contained on one input line, however, as\n continuation is not supported. Blank lines may be interspersed\n as desired for readability.\n\n The specific keywords are sought and anything else is ignored.\n Keywords must be in upper case but any FOOTING data may be any\n case.  Also, options which require parentheses but where no\n closing parenthesis is supplied will be ignored, as will values\n which require numeric values but are not supplied as such.  The\n last specified value is the one used if the same option is\n repeated.  To change the defaults, please see the section below\n called CHANGING DEFAULTS.\n\n Control card parameters are:\n\n      ALIAS     Show whether the member is an alias in the\n                header line and in the index entry.  The\n                default is NOALIAS\n\n      BLKSIZE(#)  Specify the block size to be used for\n                the SYSPRINT file output.  It must be a\n                multiple of 121.  The default is\n                BLKSIZE(121).\n\n      DUPS      Indicate that members with duplicate\n                names in concatenated PDS's are to be printed\n                and shown in the index.  The alternative,\n                NODUPS, is the default.  DUPS(ONLY) may be\n                specified to have only the members that exist\n                as duplicates within the concatenation listed\n                and/or shown in the index.\n\n      EJECT     Causes the printing of each member to\n                start at the top of a new page. NOEJECT will\n                cause two lines to be skipped before printing\n                the next member and is the default.\n\n      FIRST(#)  Only the first # of lines of each member\n                will be printed.  The default is to print\n                every line of a member.  Note this is NOT\n                record count, but literally prints the\n                indicated number of lines.\n\n      FOOTING(x)  Indicates that the string x should be\n                placed two lines from the end of each page.\n                The open parenthesis starts the string and\n                the close parenthesis terminates the string.\n                The default is no footing.\n\n      HEX       Causes the member data to be printed as usual\n                and then followed by 2 additional lines, the\n                first showing the first character of the hex\n                representation of the character above and the\n                second line showing the next hex character.\n                NOHEX is the default.\n\n      INDEX     Specifies an index of member names is to\n                be printed at the end of the listing.  This\n                list will show all members in the selected\n                range including those not printed (e.g. if\n                NODUPS is chosen).  NOINDEX is the default.\n                INDEX(ONLY) indicates that only the index is\n                to be printed and the actual member data is\n                not to be.\n\n      LINECNT(#)  Indicates the SYSPRINT page size.\n                LINECNT(58) is the default.  This value must\n                be numeric and greater then 4.\n\n      OPTIONS   Causes the specified and default options to\n                be displayed.  NOOPTIONS is the default.\n\n      TRANSLATE Causes all printed lines to be converted on\n                a character by character basis to printable\n                characters or blanks.   The default is to\n                send the characters as they are to the\n                printer, namely NOTRANSLATE.  Please see the\n                section below titled PRINTABLE CHARACTER\n                TRANSLATION to see the default translation.\n\n      VARSEQ    Specifies that the first 8 characters of\n                variable data, if numeric, are to be treated\n                as sequence numbers and  printed in columns\n                113 through 120 of the print line.  Only the\n                data following the eight bytes is then\n                printed. The default is VARSEQ.  NOVARSEQ\n                would cause all of the record to be printed\n                as data.\n\n      >MEMBER(member) Indicates the 1 to 8 byte member name,\n                to be used as an lower bound - no member\n                alphabetically lower then this member will be\n                printed.  The default is to print the first\n                member and all following members.\n\n      <MEMBER(member) Indicates the 1 to 8 byte member name,\n                to be used as an upper bound - no member\n                alphabetically higher then this member will\n                be printed.  The default is to print all\n                members from the starting member onward.\n\n\n:HEADER1   CHANGING DEFAULTS\n\n To change the default behavior of PDSLIST, simple changes may be\n made to the assembler source code and the program will need to\n be re-assembled and re-linked.\n\n To change the default, simply find the variable in the PDSLIST\n source as shown below and change it from `N' to `Y' or vice\n versa.  BLKSIZE, FIRST and LINECNT require a numeric value.  The\n same concept applies to the DD names shown.\n\n ************************************************************\n *    DEFAULT OPTION VALUES                                 *\n ************************************************************\n\n &DDOPTS       SETC  'SYSIN'      DDNAME FOR OPTIONS FILE\n &DDPDS        SETC  'SYSUT1'     DDNAME FOR PARTITIONED d/s\n &DDPRINT      SETC  'SYSPRINT'   DDNAME FOR LISTING FILE\n\n &DEFPGSZ      SETA  58           DATA PAGE SIZE DEFAULT\n &DEF1ST       SETA  999999999    FIRST OPTION CHOSEN DEFAULT\n\n &DEFALIAS     SETC  'N'          ALIAS DEFAULT\n &DEFBLKSI     SETA  121          SYSPRINT BLOCK SIZE DEFAULT\n &DEFDUPS      SETC  'N'          DUPS DEFAULT\n &DEFDUPSO     SETC  'N'          DUPS ONLY DEFAULT\n &DEFEJECT     SETC  'N'          EJECT DEFAULT\n &DEFFOOT      SETC  'N'          FOOTER USED\n &DEFHEX       SETC  'N'          HEX DEFAULT\n &DEFINDX      SETC  'N'          INDEX DEFAULT\n &DEFINDXO     SETC  'N'          INDEX ONLY DEFAULT\n &DEFOPTNS     SETC  'N'          LIST OPTIONS DEFAULT\n &DEFTRANS     SETC  'N'          TRANSLATE DEFAULT\n &DEFVAR       SETC  'Y'          VARIABLE SEQUENCE DEFAULT\n                       00000000\n &DEFMEMGT     SETC   '00000000'  FIRST MEMBER SELECTED (HEX 0'S)\n                       FFFFFFFF\n &DEFMEMLT     SETC   'FFFFFFFF'  LAST MEMBER SELECTED (HEX F'S)\n\n\n:HEADER1   PRINTABLE CHARACTER TRANSLATION\n\n The table below is used to translate member data sent to\n SYSPRINT when the TRANSLATE option is selected.  Numbers,\n upper and lower case characters and the primary punctuation\n characters print as expected.  Other characters are changed\n to blanks.\n\n PRTABLE   DC    XL16'40404040404040404040404040404040' 00 - 0F\n\n           DC    XL16'40404040404040404040404040404040' 10 - 1F\n\n           DC    XL16'40404040404040404040404040404040' 20 - 2F\n\n           DC    XL16'40404040404040404040404040404040' 30 - 3F\n\n           DC    XL16'40404040404040404040404B4C4D4E4F' 40 - 4F\n\n           DC    XL16'504040404040404040405A5B5C5D5E5F' 50 - 5F\n\n           DC    XL16'606140404040404040406A6B6C6D6E6F' 60 - 6F\n\n           DC    XL16'404040404040404040407A7B7C7D7E7F' 70 - 7F\n\n           DC    XL16'40818283848586878889404040404040' 80 - 8F\n\n           DC    XL16'40919293949596979899404040404040' 90 - 9F\n\n           DC    XL16'4040A2A3A4A5A6A7A8A9404040404040' A0 - AF\n\n           DC    XL16'B0404040404040404040BABB40404040' B0 - BF\n\n           DC    XL16'C0C1C2C3C4C5C6C7C8C9404040404040' C0 - CF\n\n           DC    XL16'D0D1D2D3D4D5D6D7D8D9404040404040' D0 - DF\n\n           DC    XL16'E040E2E3E4E5E6E7E8E9404040404040' E0 - EF\n\n           DC    XL16'F0F1F2F3F4F5F6F7F8F9404040404040' F0 - FF\n\n The table above may  be changed by finding the relative position\n of the character and replacing it with whatever character is\n desired or a blank.\n\n\n:HEADER1   SAMPLE JCL\n\n An example of JCL that may be used is:\n\n      //LISTPRCS  EXEC  PGM=PDSLIST,REGION=4M\n\n      //SYSIN       DD    *\n\n            DUPS          EJECT          INDEX\n\n            FOOTING(- Top Secret & Confidential & Highly Unlikely -)\n\n      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB\n\n      //SYSPRINT     DD        SYSOUT=C\n\n      //SYSUT1       DD        DISP=SHR,DSN=SYS1.PROCLIB\n\n      //             DD        DISP=SHR,DSN=PLI.V2R3M0.PROCLIB\n\n      //             DD        DISP=SHR,DSN=SYS4.USER.PROCLIB\n\n The above step will print all the members of the 3 PROCLIB's\n including duplicates, a data set list, and an index of all the\n members with the footing shown.  Note the control card data is\n free form and does not need to be aligned in any way.\n\n Another example is:\n\n      //LISTPDSS  EXEC  PGM=PDSLIST\n\n           INDEX(ONLY)    DUPS\n\n      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB\n\n      //SYSPRINT     DD        SYSOUT=*\n\n      //SYSUT1       DD        DISP=SHR,DSN=APPLIC.LOADLIB1\n\n      //             DD        DISP=SHR,DSN=APPLIC.LOADLIB2\n\n      //             DD        DISP=SHR,DSN=APPLIC.LOADLIB3\n\n      //             DD        DISP=SHR,DSN=APPLIC.LOADLIB4\n\n This step will provide an index of the members of the four load\n module libraries input.  In this case it is supposed that the\n data itself is not of interest (load modules don't normally list\n nicely).\n\n\n:HEADER1   SAMPLE OUTPUT\n\n Given the following 2 partitioned data sets, PDS.A and PDS.B,\n which contain:\n\n      PDS.A\n           Member A -- 10 lines of 10 A's\n           Member B -- 10 lines of 10 B's\n           Member C -- 10 lines of 10 C's\n      PDS.B\n           Member B --10 lines 0f 10 2's\n           Member D --10 lines of 10 D's\n\n The JCL immediately following will produce the results below:\n\n      //PDSLIST    EXEC     PGM=PDSLIST,REGION=4M\n\n      //SYSIN        DD       *\n\n           DUPS           EJECT               INDEX\n\n           FIRST(03)\n\n           FOOTING( - - -  Sample output from PDSLIST  - - - )\n\n      /STEPLIB       DD       DISP=SHR,DSN=USER.LOADLIB\n\n      //SYSPRINT     DD       SYSOUT=*\n\n      //SYSUT1       DD       DISP=SHR,DSN=PDS.A\n\n      //             DD       DISP=SHR,DSN=PDS.B\n\n The header lines on each page are underlined - we left NOEJECT\n on to minimize paper usage and the output shown reflects the\n request to only print the first 3 lines of each member.\n\n      DATE=98/318   VOL=TEST27   DSN=PDS.A   MEMBER=A   PAGE 1\n      --------------------------------------------------------\n      AAAAAAAAAA\n      AAAAAAAAAA\n      AAAAAAAAAA\n                     - - -  Sample output from PDSLIST  - - -\n\n      DATE=98/318   VOL=TEST27   DSN=PDS.A   MEMBER=B   PAGE 2\n      --------------------------------------------------------\n      BBBBBBBBBB\n      BBBBBBBBBB\n      BBBBBBBBBB\n                     - - -  Sample output from PDSLIST  - - -\n\n      DATE=98/318   VOL=TEST29   DSN=PDS.B   MEMBER=B   PAGE 3\n      --------------------------------------------------------\n      2222222222\n      2222222222\n      2222222222\n\n                     - - -  Sample output from PDSLIST  - - -\n\n      DATE=98/318   VOL=TEST27   DSN=PDS.A   MEMBER=C   PAGE 4\n      --------------------------------------------------------\n      CCCCCCCCCC\n      CCCCCCCCCC\n      CCCCCCCCCC\n\n                     - - -  Sample output from PDSLIST  - - -\n\n      DATE=98/318   VOL=TEST29   DSN=PDS.B   MEMBER=D   PAGE 5\n      --------------------------------------------------------\n      DDDDDDDDDD\n      DDDDDDDDDD\n      DDDDDDDDDD\n\n                     - - -  Sample output from PDSLIST  - - -\n\n\n\n      PDS#      DATA SET NAME                 VOLUME\n      -----------------------------------------------------\n      1              PDS.A                           TEST27\n      2              PDS.B                           TEST29\n\n                     - - -  Sample output from PDSLIST  - - -\n\n\n      MEMBER   PAGE#   PDS     MEMBER   PAGE#   PDS . . .\n      -----------------------------------------------------\n      A          1      1\n      B          2      1\n      B          3      2\n      C          4      1\n      D          5      2\n\n                     - - -  Sample output from PDSLIST  - - -\n\n\n:HEADER1   PACKAGE CONTENTS\n\n The PDSLIST package consists of:\n\n     - PDSLIST    the assembler source code wrapped in JCL\n                  to assemble and link it\n\n     - PDSLIST$   sample execution JCL\n\n PDSLIST was assembled using IBM's High Level Assembler.\n Assembler H may be used although any blank lines in the source\n will have to be removed.  The JCL supplied in PDSLIST does not\n use procedures since many have local changes precluding use of\n specific step names for DD name over-rides.  To change from High\n Level Assembler to Assembler H, simply change the program name\n from ASMA90 to IEV90.  The JCL will accommodate either.\n\n:RESET\n:PAGESIZE  58\n:LINESIZE  80\n:TOC       YES\n:DOCTITLE  PDSMATCH\n:DOCTITLE2 Partitioned Data Set\n:DOCTITLE3 Match Utility\n:TLRDATE   November 04, 1999\n:TLRDESC   Freeware from Steli Inc.\n:HEADER1   INTRODUCTION\n\n This document is intended to provide user information for the\n Partitioned Data Set Match utility (PDSMATCH).  Some\n understanding of Job Control Language (JCL) is required as well\n as knowledge of how programs are executed.\n\n PDSMATCH is mainframe software obtained from the CBTTAPE online\n internet site.  This version of PDSMATCH has been modified from\n the CBTTAPE version to compare member data in addition to\n directory statistics and member names.  This version has been\n sent to the original provider.\n\n This program compares the directories of two partitioned data\n sets and prints a report showing which members match and which\n members do not match or are not present in both directories.\n Members are said to match if their names are the same.  If\n PARM=USER, members match if they have the same name and all the\n statistics in their directory entries are equal (except fields\n containing TTR track addresses). If PARM=DATA, they must have\n the same name and their data must be the same.\n\n PDSMATCH through its PARM specified option specifies which\n compare option will be used.  If PARM=EQO, only members that\n match will be listed.  If PARM=NEO, only members that dont match\n will be listed.  If the default is taken, all members will be\n listed for both libraries.\n\n If PARM=USER, members that are present in both libraries will be\n compared for matching statistics.  Statistics of up to 62 bytes\n of data in the directory entry which is put there by the linkage\n editor, SPF edit, and others.  Note, with PARM=USER, if two\n members have the same name and neither has any userdata, they\n are treated as unequal, with a unique message for this case.\n\n If PARM=DATA members that are present in both libraries will be\n compared for matching data.  if two members have the same name\n and both are empty, they are treated as unequal, with a unique\n message for this case.\n\n Steli Inc. has made its best effort to provide working, tested\n code.  However, nothing is perfect - there may be flaws and\n there certainly could be improvements.  All questions, concerns,\n problems and suggestions are welcome and may be sent to\n C_Hafner@HotMail.Com.\n\n\n:HEADER1   EXECUTION JCL\n\nThe job control language (JCL) for PDSMATCH is:\n\n           //   EXEC   PGM=PDSMATCH ( ,REGION=4M )\n\n           //*                PARM=EQO  TO SHOW EQUALS ONLY\n\n           //*                PARM=NEO  TO SHOW UNMATCHED ONLY\n\n           //*                PARM=USER TO SHOW STAT DIFFERENCES\n\n           //*                PARM=DATA TO SHOW DATA DIFFERENCES\n\n           //STEPLIB     DD   DISP=SHR,DSN=...\n\n           //SYSPRINT    DD   SYSOUT=*\n\n           //SYSLIB1     DD   DISP=SHR,DSN=PDS1\n\n           //SYSLIB2     DD   DISP=SHR,DSN=PDS2\n\n Optional control language elements are shown in parentheses.\n The name of the program  may be changed as desired providing\n that the actual program is linked with the appropriate name or\n alias.\n\n REGION is optional but PDSMATCH requires approximately 280,000\n bytes.  In most cases the default region size is adequate to\n meet these requirements.  STEPLIB may be optional if PDSMATCH is\n placed in the system's link list but otherwise simply points to\n where PDSMATCH is stored.\n\n The SYSPRINT file may be directed to any output class or may be\n sent to a new or existing file.  The DCB attributes of SYSPRINT\n will be record format FBA and LRECL 121.  SYSLIB points to the\n PDS to be processed.\n\n:HEADER1   SAMPLE JCL\n\n An example of JCL that may be used is:\n\n      //COMPARE   EXEC  PGM=PDSMATCH,REGION=4M,PARM=DATA\n\n      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB\n\n      //SYSPRINT     DD        SYSOUT=C\n\n      //SYSLIB1      DD        DISP=SHR,DSN=A.PROCLIB\n\n      //SYSLIB2      DD        DISP=SHR,DSN=A.PROCLIB.BACKUP\n\n The above step will compare the members and the data of members\n with the same name.\n\n Another example is:\n\n      //COMPARE   EXEC  PGM=PDSMATCH,REGION=4M,PARM=NEO\n\n      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB\n\n      //SYSPRINT     DD        SYSOUT=C\n\n      //SYSLIB1      DD        DISP=SHR,DSN=A.PROCLIB\n\n      //SYSLIB2      DD        DISP=SHR,DSN=A.PROCLIB.BACKUP\n\n This step will provide a list of the members not in both\n libraries.\n\n\n:HEADER1   SAMPLE OUTPUT\n\n The following shows the results of a PDSMATCH run against a REXX\n CLIST library and its backup library with option DATA.\n\n    --- PDSMATCH --- PDS DIRECTORY COMPARE UTILITY ---\n\n    CRITERIA FOR MATCHING IS MEMBER NAME AND THE ACTUAL MEMBER DATA\n    (SPF STATISTICS ARE NOT COMPARED).\n\n    LIBRARY1 - SUCAHAF.CURR.CLIST ON KLPSF8\n    LIBRARY2 - SUCAHAF.CURR.CBKUP ON KK2SF9\n\n                         @@BOFA01  MEMBER IN LIBRARY2 ONLY\n\n                         @TIME     MEMBER IN LIBRARY2 ONLY\n\n                         @TODO     MEMBER IN LIBRARY2 ONLYONLY\n\n    ADDDOTSL             ADDDOTSL\n\n    ADDFLAGS             ADDFLAGS\n\n                         ADD0D0A   MEMBER IN LIBRARY2 ONLY\n\n                         ADP2CLT   MEMBER IN LIBRARY2 ONLY\n\n    ALLMEM               ALLMEM\n\n    ALLMEMC              ALLMEMC\n\n    ALLMEMF              ALLMEMF\n\n                         ALLOC     MEMBER IN LIBRARY2 ONLY\n\n                     . . . . .\n\n\n:HEADER1   PACKAGE CONTENTS\n\n PDSMATCH files in this library are:\n\n     - PDSMATCH   the assembler source code wrapped in JCL\n                  to assemble and link it and the PDSCOMP\n                  program\n\n     - PDSMATC$   sample execution JCL\n\n PDSMATCH was assembled using IBM's High Level Assembler.\n Assembler H may be used although any blank lines in the source\n will have to be removed.  The JCL supplied in LISTASM does not\n use procedures since many have local changes precluding use of\n specific step names for DD name over-rides.  To change from High\n Level Assembler to Assembler H, simply change the program name\n from ASMA90 to IEV90.  The JCL will accommodate either.\n\n:RESET\n:PAGESIZE  58\n:LINESIZE  80\n:TOC       YES\n:DOCTITLE  PDSPUNCH\n:DOCTITLE2 Partitioned Data Set\n:DOCTITLE3 Punch Utility\n:TLRDATE   March 20, 2000\n:TLRDESC   Freeware from Steli Inc.\n:HEADER1   INTRODUCTION\n\n This document is intended to provide user information for\n the Partitioned Data Set Punch utility (PDSPUNCH). Some\n understanding of Job Control Language (JCL) is required as\n well as knowledge of how programs are executed.\n\n PDSPUNCH is mainframe freeware. You do not need to register\n to use PDSPUNCH. It may be placed on any archive, web site\n or bulletin board without restraint.  It may be distributed\n by any means, provided that no charge is made other than for\n reasonable distribution costs.\n\n PDSPUNCH is intended for MVS compatible systems to turn the\n members of one or more partitioned data sets (PDS's) into a\n sequential stream of 80 byte records with IEBUPDTE ./ ADD cards\n preceding each member in alphabetical order.  It will process\n concatenated PDS's up to the number currently allowed by the\n operating system and data of any size or type, fixed, variable\n or unformatted.  Options may be specified through free form\n control cards.\n\n PDSPUNCH through its options will also:\n\n    - Punch duplicate members, i.e. process members with the\n      same name that are in one or more PDS's in the concatenation\n      (DUPS)\n\n    - Punch only members that have duplicates within the\n      concatenation (DUPS(ONLY))\n\n    - Punch only a portion of each member (FIRST(.))\n\n    - Allow a range of members to be selected  (>MEMBER(.)\n      and <MEMBER(.))\n\n    - Specify whether to use ./ ADD or ./ REPL header cards\n\n Steli Inc. has made its best effort to provide working,\n tested code.  However, nothing is perfect - there may be\n flaws and there certainly could be improvements.  All\n questions, concerns, problems and suggestions are welcome\n and may be sent to C_Hafner@HotMail.Com.\n\n\n:HEADER1   EXECUTION JCL\n\nThe job control language (JCL) for PDSPUNCH is:\n\n           //   EXEC   PGM=PDSPUNCH ( ,REGION=4M )\n\n           //STEPLIB     DD   DISP=SHR,DSN=...\n\n           //SYSPUNCH    DD   ...\n\n           //SYSUT1      DD   DISP=SHR,DSN=PDS1\n\n         ( //            DD   DISP=SHR,DSN=PDS2 )\n\n         (    ...   optionally, as many         )\n\n         (    ...      concatenated PDS's       )\n\n         (    ...         as allowed in MVS/ESA )\n\n         ( //SYSIN       DD   *                 )\n\n         (        control cards . . .           )\n\n Optional control language elements are shown in parentheses.\n The name of the program  may be changed as desired providing\n that the actual program is linked with the appropriate name\n or alias.\n\n REGION is optional but PDSPUNCH requires approximately 216,000\n bytes (system required resources may increase this amount).  In\n most cases the default region size is adequate to meet these\n requirements.  STEPLIB may be optional if PDSPUNCH is placed in\n the system's link list but otherwise simply points to where\n PDSPUNCH is stored.\n\n The SYSPUNCH file may be directed to any output class or may\n be sent to a new or existing file.  The DCB attributes of\n SYSPUNCH will be record format FB and LRECL 80.  The BLKSIZE\n parameter may be specified on the JCL for it.\n\n SYSUT1 points to the one or more concatenated PDS's to be\n processed.  SYSIN contains control information and may be\n omitted, set to //SYSIN DD DUMMY or simply be empty.  Full\n control card descriptions are shown below.\n\n The DD names may be changed as desired in the defaults section\n of the source code.  If an incorrect name is specified, the\n program will terminate returning the code received from opening\n the data set (the system will generally indicate the missing DD\n name).\n\n\n:HEADER1   CONTROL CARDS\n\n The control card values may be specified free form in the first\n 72 columns of the records in the SYSIN file in any order and may\n be separated by commas, blanks or simply concatenated together.\n Each option must be contained on one input line, however, as\n continuation is not supported. Blank lines may be interspersed\n as desired for readability.\n\n The specific keywords are sought and anything else is ignored.\n Keywords must be in upper case but any FOOTING data may be any\n case.  Also, options which require parentheses but where no\n closing parenthesis is supplied will be ignored, as will values\n which require numeric values but are not supplied as such.  The\n last specified value is the one used if the same option is\n repeated.  To change the defaults, please see the section below\n called CHANGING DEFAULTS.\n\n Control card parameters are:\n\n      ACTION(x) Indicate that the IEBUPDTE header card should\n                specify REPL or ADD.  ACTION(ADD) is the\n                default.\n\n      DUPS      Indicate that members with duplicate\n                names in concatenated PDS's are to be punched\n                and shown in the index.  The alternative,\n                NODUPS, is the default.  DUPS(ONLY) may be\n                specified to have only the members that exist\n                as duplicates within the concatenation.\n\n      FIRST(#)  Only the first # of lines of each member\n                will be punched.  The default is to punch\n                every line of a member.  Note this is NOT\n                record count, but literally punches the\n                indicated number of lines.\n\n      >MEMBER(member) Indicates the 1 to 8 byte member name,\n                to be used as an lower bound - no member\n                alphabetically lower then this member will be\n                punched.  The default is to punch the first\n                member and all following members.\n\n      <MEMBER(member) Indicates the 1 to 8 byte member name,\n                to be used as an upper bound - no member\n                alphabetically higher then this member will\n                be punched.  The default is to punch all\n                members from the starting member onward.\n\n\n:HEADER1   CHANGING DEFAULTS\n\n To change the default behavior of PDSPUNCH, simple changes\n may be made to the assembler source code and the program\n will need to be re-assembled and re-linked.\n\n To change the default, simply find the variable in the\n PDSPUNCH source as shown below and change it from `N' to `Y'\n or vice versa.  BLKSIZE, FIRST and LINECNT require a numeric\n value.  The same concept applies to the DD names shown.\n\n ************************************************************\n *    DEFAULT OPTION VALUES                                 *\n ************************************************************\n\n &DDOPTS       SETC  'SYSIN'      DDNAME FOR OPTIONS FILE\n &DDPDS        SETC  'SYSUT1'     DDNAME FOR PARTITIONED d/s\n &DDPUNCH      SETC  'SYSPUNCH'   DDNAME FOR PUNCHED FILE\n\n &DEF1ST       SETA  999999999    FIRST OPTION CHOSEN DEFAULT\n\n &DEFDUPS      SETC  'N'          DUPS DEFAULT\n &DEFDUPSO     SETC  'N'          DUPS ONLY DEFAULT\n                       00000000\n &DEFMEMGT     SETC   '00000000'  FIRST MEMBER SELECTED (HEX 0'S)\n                       FFFFFFFF\n &DEFMEMLT     SETC   'FFFFFFFF'  LAST MEMBER SELECTED (HEX F'S)\n\n:HEADER1   SAMPLE JCL\n\n An example of JCL that may be used is:\n\n      //PUNCHGAS  EXEC  PGM=PDSPUNCH,REGION=4M\n\n      //SYSIN       DD    *\n\n            >MEMBER($GAS0000)   <MEMBER($GAS9999)\n\n      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB\n\n      //SYSPUNCH     DD        DISP=(,CATLG),DSN=RECOVERED.MEMBERS,\n\n      //             UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),\n\n      //             DCB=(BLKSIZE=27920,BUFNO=24)\n\n      //SYSUT1       DD        DISP=SHR,DSN=SYS4.USER.PROCLIB\n\n The above step will punch all the restored members (see PDSGAS)\n of the user PROCLIB.  This would allow removal of the \"gas\"\n members while still retaining them in a sequential file.  Note\n the control data is free form and does not need to be aligned in\n any way.\n\n Another example is:\n      //PNCHPDSS  EXEC  PGM=PDSPUNCH\n          DUPS(ONLY)\n      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB\n      //SYSPUNCH    DD         SYSOUT=*\n      //SYSUT1       DD        DISP=SHR,DSN=APPLIC.COPYLIB1\n      //             DD        DISP=SHR,DSN=APPLIC.COPYLIB2\n      //             DD        DISP=SHR,DSN=APPLIC.COPYLIB3\n      //             DD        DISP=SHR,DSN=APPLIC.COPYLIB4\n\n This step will provide a sequential file with all the duplicate\n members within the 4 COPYLIBs.\n\n:HEADER1   SAMPLE OUTPUT\n\n Given the following 2 partitioned data sets, PDS.A and\n PDS.B, which contain:\n\n      PDS.A\n           Member A -- 10 lines of 10 A's\n           Member B -- 10 lines of 10 B's\n           Member C -- 10 lines of 10 C's\n      PDS.B\n           Member B --10 lines 0f 10 2's\n           Member D --10 lines of 10 D's\n\n The JCL immediately following will produce the results\n below:\n      //PDSPUNCH   EXEC     PGM=PDSPUNCH,REGION=4M\n      //SYSIN   DD   *\n           DUPS\n           FIRST(03)\n      /STEPLIB       DD       DISP=SHR,DSN=USER.LOADLIB\n      //SYSPUNCH   DD       SYSOUT=*\n      //SYSUT1            DD       DISP=SHR,DSN=PDS.A\n      //                  DD       DISP=SHR,DSN=PDS.B\n\n ./  ADD  NAME=A\n AAAAAAAAAA\n AAAAAAAAAA\n AAAAAAAAAA\n ./  ADD  NAME=B\n BBBBBBBBBB\n BBBBBBBBBB\n BBBBBBBBBB\n ./  ADD  NAME=B\n 2222222222\n 2222222222\n 2222222222\n ./  ADD  NAME=C\n CCCCCCCCCC\n CCCCCCCCCC\n CCCCCCCCCC\n ./  ADD  NAME=D\n DDDDDDDDDD\n DDDDDDDDDD\n DDDDDDDDDD\n\n\n:HEADER1   PACKAGE CONTENTS\n\n PDSPUNCH is generally distributed as a ZIP file, but the\n files distributed easily fit on a 1.4 meg floppy.  The files\n are:\n\n     - PDSPUNCH   the assembler source code wrapped in JCL\n                  to assemble and link it\n\n     - PDSPUNC$   sample execution JCL\n\n PDSPUNCH was assembled using IBM's High Level Assembler.\n Assembler H may be used although any blank lines in the\n source will have to be removed.  The JCL supplied in\n PUNCHASM does not use procedures since many have local\n changes precluding use of specific step names for DD name\n over-rides.  To change from High Level Assembler to\n Assembler H, simply change the program name from ASMA90 to\n IEV90.  The JCL will accommodate either.\n\n:RESET\n:PAGESIZE  58\n:LINESIZE  80\n:TOC       YES\n:DOCTITLE  PULL\n:DOCTITLE2 Select Records from Sequential File\n:TLRDATE   December 15, 1999\n:TLRDESC   Freeware from Steli Inc.\n:HEADER1   INTRODUCTION\n\n This document is intended to provide user information for\n selecting one or more sets of records from a sequential file\n (PULL).   Given a large sequential file, PULL will allow\n retrieving groups of records in one run without customizing\n code.  Some understanding of Job Control Language (JCL) is\n required as well as knowledge of how programs are executed.\n\n PULL is mainframe freeware.  Feel free to use it as you will.\n\n Steli Inc. has made its best effort to provide working,\n tested code.  However, nothing is perfect - there may be\n flaws and there certainly could be improvements.  All\n questions, concerns, problems and suggestions are welcome\n and may be sent to C_Hafner@HotMail.Com.\n\n\n:HEADER1   EXECUTION JCL\n\n The job control language (JCL) for PULL is:\n\n      //SELRECS    EXEC     PGM=PULL,  ( REGION=4M )\n\n      //SYSIN        DD       *\n\n      00000001  00000030  STARTING RECORD NUMBER IN 1 - 8\n\n      00000444  00000050  & NUMBER OF RECORDS IN 11 - 18\n\n      //I            DD       DISP=SHR,DCB=BUFNO=32,\n\n      //             DSN=...\n\n      //O            DD       DSN=...,\n\n      //             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(010,010),RLSE\n\n      //             DCB=(...,BUFNO=32)\n\n      //STEPLIB      DD       DISP=SHR,DSN=...\n\n Optional control language elements are shown in parentheses.\n The name of the program  may be changed as desired providing\n that the actual program is linked with the appropriate name or\n alias.  REGION is optional - the default region size may be more\n then adequate depending on your local standards.\n\n File I contains the original data.  File O will contain the\n selected output; the DCB information may be hard coded or\n patterned (specify the old data set name) and the BUFNO\n parameter is useful to speed processing but not necessary.\n\n The SYSIN file contains the specification of the records to be\n selected from INFILE. The first 8 columns specify the offset,\n that is, the starting record number of each group.  The second\n parameter specifies the number of records. These MUST be in\n order by starting record number.\n\n STEPLIB may be optional if PULL is placed in the system's link\n list but otherwise simply points to where PULL is stored.\n\n\n:HEADER1   SAMPLE JCL AND OUTPUT\n\n A sample of what might be submitted is:\n\n      //GRABRECS   EXEC     PGM=PULL,REGION=4M\n\n      00000001  00000100\n\n      00004001  00000100\n\n      00160001  00000100\n\n      02000001  00000100\n\n      //I            DD       DISP=SHR,DCB=BUFNO=32,\n\n      //             DSN=USERID.USER.DATA01\n\n      //O            DD       DSN=USERID.SELECTED.DATA01,\n\n      //             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(010,010),RLSE\n\n      //             DCB=(USERID.USER.DATA01,BUFNO=32)\n\n      //STEPLIB      DD       DISP=SHR,DSN=SYS4.USER.LINKLIB\n\n Assuming there were 5,000,000 records in the input file I, the\n above step would create a subset file of 400 records.\n\n\n:HEADER1   PACKAGE CONTENTS\n\n The files involved specifically with PULL are:\n\n     - PULL       the PL/I code wrapped in JCL to compile\n                  and link edit it\n\n     - PULL$      a JCL skeleton for its execution\n\n:RESET\n:PAGESIZE  58\n:LINESIZE  80\n:TOC       YES\n:DOCTITLE  SETRC\n:DOCTITLE2 Set MVS Return Code\n:TLRDATE   September 14, 1999\n:TLRDESC   Freeware from Steli Inc.\n:HEADER1   INTRODUCTION\n\n This document is intended to provide user information for the\n utility to set MVS return codes (SETRC).  Some understanding of\n Job Control Language (JCL) is required as well as knowledge of\n how programs are executed.\n\n SETRC is mainframe freeware.  It's available for any use you\n wish to make of it.\n\n SETRC is intended for MVS compatible systems to set a step\n return code.  It allows testing of JCL and restart conditions\n without having to do program changes.  Other then setting the\n return code, it does no processing.\n\n SETRC is an Assembler program that accepts a PARM parameter of a\n number between 0 and 4095, the legitimate condition codes\n acceptable to MVS. IF no value or a bad value is passed, the\n return code is set to 0.\n\n Steli Inc. has made its best effort to provide working,\n tested code.  However, nothing is perfect - there may be\n flaws and there certainly could be improvements.  All\n questions, concerns, problems and suggestions are welcome\n and may be sent to C_Hafner@HotMail.Com.\n\n\n:HEADER1   EXECUTION JCL\n\n The job control language (JCL) for SETRC is:\n\n           //SETCOND    EXEC     PGM=SETRC,PARM=#\n\n           //STEPLIB      DD       DISP=SHR,DSN=...\n\n The name of the program may be changed as desired providing\n that the actual program is linked with the appropriate name\n or alias.\n\n REGION is optional.  STEPLIB may be optional if SETRC is\n placed in the system's link list but otherwise simply points to\n where SETRC is stored.\n\n The only real input is provided by the PARM statement. The\n number provided will be used to set the return code, that is,\n placed in register 15 prior to the program's termination.  Since\n SETRC operates like IEFBR14, file allocation or deletion may be\n performed within its JCL.\n\n\n:HEADER1   SAMPLE JCL AND OUTPUT\n\n An example of JCL that may be used is:\n\n      //TEST412   EXEC  PGM=SETRC,PARM=412\n\n      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB\n\n The above step will cause the following JES message to be\n generated:\n\n       JOBNAME TEST412 - STEP WAS EXECUTED - COND CODE 0412\n\n An example of how SETRC might be used to test COND code checking\n outcomes is:\n\n      //PROCX2     PROC\n\n      //PS21       EXEC     PGM=IEFBR14\n\n      //PS22       EXEC     PGM=IEFBR14\n\n      //             PEND\n\n      //***\n\n      //PROCX1     PROC\n\n      //PS11       EXEC     PGM=SETRC,PARM=08\n\n      //STEPLIB      DD       DISP=SHR,DSN=SYS4.LINKLIB\n\n      //*\n\n      //PS12       EXEC     PGM=SETRC,PARM=00\n\n      //STEPLIB      DD       DISP=SHR,DSN=SYS4.LINKLIB\n\n      //*\n\n      //PS13       EXEC     PROCX2,COND=(8,LE,EXPRC.PS11)\n\n      //             PEND\n\n      //***\n\n      //EXPRC      EXEC     PROCX1\n\n showing exactly what will happen if PROCX1's step PS11\n returns a code of 8.\n\n\n:HEADER1   PACKAGE CONTENTS\n\n The files involved specifically with SETRC are:\n\n     - SETRC      the Assembler code wrapped in JCL to\n                  assemble and link edit it\n\n     - SETRC$     a JCL skeleton for its execution\n\n:RESET\n:PAGESIZE  58\n:LINESIZE  80\n:TOC       YES\n:DOCTITLE  SMARTGN\n:DOCTITLE2 Generate Card Images from List\n:TLRDATE   November 14, 1999\n:TLRDESC   Freeware from Steli Inc.\n:HEADER1   INTRODUCTION\n\n This document is intended to provide user information for\n generating card images using an input list to replace tokens in\n a skeleton set of those images (SMARTGN).\n\n For example, if you have a list of 1,000 data set names and wish\n to generate delete cards for an IEFBR14, SMARTGN would do so\n with a minimal set of JCL delete cards. Please see the GETDSNS\n Edit macro for a tool to provide data set names by wildcard\n input.\n\n SMARTGN also allows substitution of the run date in various\n formats, run time, and the sequence number of the list input\n item.  Some understanding of Job Control Language (JCL) is\n required as well as knowledge of how programs are executed.\n\n SMARTGN is mainframe freeware.  You do not need to register to\n use SMARTGN. It may be placed on any archive, web site or\n bulletin board without restraint.  It may be distributed by any\n means, provided that no charge is made other than for reasonable\n distribution costs.\n\n Steli Inc. has made its best effort to provide working,\n tested code.  However, nothing is perfect - there may be\n flaws and there certainly could be improvements.  All\n questions, concerns, problems and suggestions are welcome\n and may be sent to C_Hafner@HotMail.Com.\n\n\n:HEADER1   EXECUTION JCL\n\n The job control language (JCL) for SMARTGN is:\n\n      //GENCNTL    EXEC     PGM=SMARTGN  ( ,REGION=4M )\n\n      //SYSCTL       DD       DATA,DLM=XX\n\n      skeleton-item...\n\n      skeleton-item...\n\n      skeleton-item...\n\n            ...\n\n      XX\n\n      //SYSOUT       DD       DSN=USERID.SMARTGN.OUTPUT,\n\n      //             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(010,010),RLSE\n\n      //             DCB=(RECFM=FB,LRECL=00080,BLKSIZE=00000)\n\n      //SYSIN        DD       *\n\n      LIST-ITEM.1.\n\n      LIST-ITEM.2.\n\n      LIST-ITEM.3.\n\n          ...\n\n      //STEPLIB      DD       DISP=SHR,DSN=...\n\n Optional control language elements are shown in parentheses.\n The name of the program  may be changed as desired providing\n that the actual program is linked with the appropriate name or\n alias.  REGION is optional - the default region size may be more\n then adequate depending on your local standards.\n\n SYSCTL contains the skeleton images to be populated with the\n SYSIN items, that is, the SYSCTL file is generated once for each\n item in the SYSIN file replacing tokens as shown below.  The\n rationale for using DD DATA with a delimiter is that SYSCTL\n could contain JCL with embedded /* cards.\n\n Any question mark (?) character found in the skeleton is\n replaced by the current list element. An exclamation point (!)\n is replaced by the run date in YYMMDD form, a percent sign (%)\n by the run date in CCYYMMDD form, and an at sign (@) by the run\n time in HHMMSS form.\n\n One or more contigious pound signs (up to 8) are replaced by the\n number of the current list item, right justified and zero\n padded. For example, if processing the 3rd item in SYSIN,\n finding a ### would cause 003 to replace the ###.\n\n SYSOUT will contain the generated images.\n\n SYSIN contains the list of items to be substituted into the\n SYSCTL images one at a time.\n\n STEPLIB may be optional if SMARTGN is placed in the system's link\n list but otherwise simply points to where SMARTGN is stored.\n\n\n:HEADER1   SAMPLE JCL AND OUTPUT\n\n A sample of what might be submitted is:\n\n      //           EXEC     PGM=SMARTGN,REGION=4M\n\n      //SYSCTL       DD       DATA,DLM=XX\n\n      //DEL####  DD  DSN=?,\n\n      //  DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n\n      XX\n\n      //SYSOUT       DD       DSN=USERID.SMARTGN.OUTPUT,\n\n      //             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(010,010),RLSE\n\n      //             DCB=(RECFM=FB,LRECL=00080,BLKSIZE=00000)\n\n      //SYSIN        DD       *\n\n      SYS1.DSN610.SDSNLINK.MAINT1\n\n      SYS1.DSN610.SDSNLINK\n\n      SYS1.DSN610.SDSNLOAD\n\n      SYS1.DSN610.SDSNLOAD.MAINT2\n\n      //STEPLIB      DD       DISP=SHR,DSN=SYS4.USER.LOADLIB\n\n Would cause the following to be written to the SYSOUT file:\n\n      //DEL0001  DD  DSN=SYS1.DSN610.SDSNLINK.MAINT1,\n\n      //  DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n\n      //DEL0002  DD  DSN=SYS1.DSN610.SDSNLINK,\n\n      //  DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n\n      //DEL0003  DD  DSN=SYS1.DSN610.SDSNLOAD,\n\n      //  DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n\n      //DEL0004  DD  DSN=SYS1.DSN610.SDSNLOAD.MAINT2,\n\n      //  DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n\n Another sample is:\n\n      //BKUPGEN    EXEC     PGM=SMARTGN,REGION=4M\n\n      //SYSCTL       DD       DATA,DLM=XX\n\n      //***\n\n      //DEL#####   EXEC     PGM=IEFBR14\n\n      //DEL          DD       DSN=?.BK!,\n\n      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n\n      //***\n\n      //GEN#####   EXEC     PGM=IEBGENER,REGION=4M\n\n      //SYSPRINT     DD       SYSOUT=*\n\n      //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,\n\n      //             DSN=?\n\n      //SYSUT2       DD       DISP=(,CATLG),\n\n      //             UNIT=SYSDA,SPACE=(CYL,(50,20),RLSE),\n\n      //             DCB=(?,BUFNO=32),\n\n      //             DSN=?.BK!\n\n      //SYSIN        DD       DUMMY\n\n      //***\n\n      XX\n\n      //SYSOUT       DD       DSN=USERID.SMARTGN.OUTPUT,\n\n      //             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(010,010),RLSE\n\n      //             DCB=(RECFM=FB,LRECL=00080,BLKSIZE=00000)\n\n      //SYSIN        DD       *\n\n      USERID.MASTER.DATA01\n\n      USERID.MASTER.LINK01\n\n      USERID.MASTER.INDEX\n\n      //STEPLIB      DD       DISP=SHR,DSN=SYS4.USER.LOADLIB\n\n Would cause the following to be written to the SYSOUT file, assuming\n the run date was February 29, 2000:\n\n      //***\n\n      //DEL00001   EXEC     PGM=IEFBR14\n\n      //DEL          DD       DSN=USERID.MASTER.DATA01.BK000229,\n\n      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n\n      //***\n\n      //GEN00001   EXEC     PGM=IEBGENER,REGION=4M\n\n      //SYSPRINT     DD       SYSOUT=*\n\n      //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,\n\n      //             DSN=USERID.MASTER.DATA01\n\n      //SYSUT2       DD       DISP=(,CATLG),\n\n      //             UNIT=SYSDA,SPACE=(CYL,(50,20),RLSE),\n\n      //             DCB=(USERID.MASTER.DATA01,BUFNO=32),\n\n      //             DSN=USERID.MASTER.DATA01.BK000229\n\n      //SYSIN        DD       DUMMY\n\n      //***\n\n      //***\n\n      //DEL00002   EXEC     PGM=IEFBR14\n\n      //DEL          DD       DSN=USERID.MASTER.LINK01.BK000229,\n\n      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n\n      //***\n\n      //GEN00002   EXEC     PGM=IEBGENER,REGION=4M\n\n      //SYSPRINT     DD       SYSOUT=*\n\n      //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,\n\n      //             DSN=USERID.MASTER.LINK01\n\n      //SYSUT2       DD       DISP=(,CATLG),\n\n      //             UNIT=SYSDA,SPACE=(CYL,(50,20),RLSE),\n\n      //             DCB=(USERID.MASTER.LINK01,BUFNO=32),\n\n      //             DSN=USERID.MASTER.LINK01.BK000229\n\n      //SYSIN        DD       DUMMY\n\n      //***\n\n      //***\n\n      //DEL00003   EXEC     PGM=IEFBR14\n\n      //DEL          DD       DSN=USERID.MASTER.INDEX.BK000229,\n\n      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n\n      //***\n\n      //GEN00003   EXEC     PGM=IEBGENER,REGION=4M\n\n      //SYSPRINT     DD       SYSOUT=*\n\n      //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,\n\n      //             DSN=USERID.MASTER.INDEX\n\n      //SYSUT2       DD       DISP=(,CATLG),\n\n      //             UNIT=SYSDA,SPACE=(CYL,(50,20),RLSE),\n\n      //             DCB=(USERID.MASTER.INDEX,BUFNO=32),\n\n      //             DSN=USERID.MASTER.INDEX.BK000229\n\n      //SYSIN        DD       DUMMY\n\n      //***\n\n Note the use of the date within the back up data set name as\n well as the use of the old data set name within the DCB\n parameter.\n\n\n:HEADER1   PACKAGE CONTENTS\n\n The files involved specifically with SMARTGN are:\n\n     - SMARTGN    the PL/I code wrapped in JCL to compile\n                  and link edit it\n\n     - SMARTGN$   a JCL skeleton for its execution\n\n:RESET\n:PAGESIZE  58\n:LINESIZE  80\n:TOC       YES\n:DOCTITLE  TOUCH\n:DOCTITLE2 Set ISPF Statistics\n:DOCTITLE3 For PDS Members\n:TLRDATE   October 26, 1999\n:TLRDESC   Freeware from Steli Inc.\n:HEADER1   INTRODUCTION\n\n This document is intended to provide user information for\n setting ISPF PDS member statistics (TOUCH).  Some understanding\n of Job Control Language (JCL) is required as well as knowledge\n of how programs are executed.\n\n TOUCH is mainframe freeware.  You do not need to register to\n use TOUCH.  It may be placed on any archive, web site or\n bulletin board without restraint.  It may be distributed by any\n means, provided that no charge is made other than for reasonable\n distribution costs.\n\n TOUCH is a PL/I program intended for MVS compatible systems to\n set any ISPF statistics for one or more members of one or more\n different partitioned data sets from a batch job.  All the\n statistics currently available, including Y2K compatible dates,\n may be set. TOUCH was written to allow clean up of old user ID's,\n provide an easy mechanism for turnover of identifiable members,\n and check out Y2K handling of various dates.\n\n Please see the TU and TD macros on File 357 of the CBT Tape\n (WWW.CBTTAPE.ORG) for panel driven capabilities of this same\n type for single members.\n\n Load module libraries, while they have statistics of a kind, are\n NOT supported. Messing with them usually causes nasty and\n painful after-effects. TOUCH will allow you to change editable\n PDS member statistics.\n\n Steli Inc. has made its best effort to provide working,\n tested code.  However, nothing is perfect - there may be\n flaws and there certainly could be improvements.  All\n questions, concerns, problems and suggestions are welcome\n and may be sent to C_Hafner@HotMail.COM.\n\n\n:HEADER1   EXECUTION JCL\n\n The job control language (JCL) for TOUCH is:\n\n      //           EXEC     PGM=TOUCH, ( ,REGION=4M )\n\n      //STEPLIB      DD       DISP=SHR,DSN=...\n\n      //SYSPRINT     DD       SYSOUT=*\n\n      //SYSIN        DD       *\n\n        DSNAME = 'SYS2.CLIST',\n\n          MEMBER = 'MEMNAME',\n\n            ALIAS         = 'N',\n\n            VERSIONNUMBER = 01,\n\n            MAINTNUMBER   = 01,\n\n            CREATEDATE    = 20010101,\n\n            CHANGEDATE    = 20010101,\n\n            CHANGETIME    = 1234,\n\n            INITIALSIZE   = 12345,\n\n            CURRENTSIZE   = 12345,\n\n            MODCOUNT      = 0,\n\n            USERID        = 'SOMEONE';\n\n Optional control language elements are shown in parentheses.\n The name of the program  may be changed as desired providing\n that the actual program is linked with the appropriate name or\n alias.  REGION is optional - the default region size may be more\n then adequate, but REGION=4M can't hurt.\n\n STEPLIB may be optional if TOUCH is placed in the system's link\n list but otherwise simply points to where TOUCH is stored.\n\n The SYSPRINT file mirrors the input and contains any error\n messages; it may be directed to any output class or may be sent\n to a new or existing file.  The DCB attributes of SYSPRINT may\n be either Fixed or Variable, blocked or unblocked, and any\n record length over 60 bytes.  That is, it can be FBA/80/6160 or\n VBA/125/32760, or just leave DCB off and have it default.\n\n Note there is no DD card pointing to the PDS to be updated.  The\n internal assembler routines dynamically allocate and free the\n PDS for processing.\n\n SYSIN control cards determine the member to be updated and also\n what values are used. The file is being accessed via PL/I's\n stream I/O facility, is basically free form but does require a\n semi-colon at the end of each member set.\n\n The DSNAME and MEMBER keywords specify the name of the\n partitioned data set and the member to have its statistics\n updated. If the member has no statistics as it is, dummy\n statistics will be set up for everything except the ones\n specified.\n\n ALIAS may be used to set the alias switch on or off. If set on,\n ALIAS = 'Y', then the statistics may not be viewable under View\n or Edit.\n\n VERSIONNUMBER and MAINTNUMBER are self describing numeric\n values, as is MODCOUNT (the modification count).  CREATEDATE and\n CHANGEDATE may be of the form CCYYMMDD (century, year, month and\n day) or of the form CCYYDDD (century, year and Julian # of\n days).  CHANGETIME is of the form HHMM (24 hour HH value\n followed by minutes) but seconds defaults to 0.\n\n INITIALSIZE and CURRENTSIZE reflect the number of records in the\n original creation and current status. Changing these may not\n make any sense. The maximum value is 65,535 which is shown even\n if there are 100,000 records in the member in question.\n\n USERID is the creator or last updater. It may only be 7\n characters long.\n\n\n:HEADER1   SAMPLE JCL AND OUTPUT\n\n A sample of what might be submitted is:\n\n      //UPDATE     EXEC     PGM=TOUCH,REGION=4M\n\n        DSNAME = 'SYS1.MACLIB',  MEMBER = 'GET',\n           CHANGEDATE    = 19940101,\n           CHANGETIME    = 1234,\n           USERID        = 'COOLGUY';\n\n        DSNAME = 'SYS1.MACLIB',  MEMBER = 'PUT',\n           CHANGEDATE    = 20061231,\n           USERID        = 'COOLGUY';\n\n        DSNAME = 'SYS4.CLIST',   MEMBER = 'FLOW',\n           CHANGEDATE    = 20000101,\n           MODCOUNT      = 0,\n           USERID        = 'BASEVER';\n\n      //STEPLIB      DD       DISP=SHR,DSN=SYS4.USER.LOADLIB\n\n      //SYSPRINT     DD       SYSOUT=*\n\n The blank lines shown above are accepted and ignored; they are\n there only for readability.  Assume the original values as seen\n under ISPF View were:\n\n    Name   Prompt   Size    Created           Changed         ID\n   ------  ------  -----  ----------  -------------------  -------\n   GET                 9  2001/02/18  2001/02/23 10:03:08 KLUTZ\n   PUT\n ...................................................................\n   FLOW              184  2001/02/23  2001/02/23 10:03:29 SYSTEM\n\n Note the above have GET/PUT separated from FLOW since they are\n in different data sets and PUT has no statistics.  The results\n would be:\n\n    Name   Prompt   Size    Created           Changed         ID\n   ------  ------  -----  ----------  -------------------  -------\n   GET                 9  2001/02/18  1994/01/01 12:34:00  COOLGUY\n   PUT             65535  2001/02/23  2006/12/31 14:13:00  COOLGUY\n ...................................................................\n   FLOW              184  2001/02/23  2000/01/01 10:03:29  BASEVER\n\n The stats for PUT picked up the date and time of the executuion\n for Create Date and for Change Time. It set the Current Size to\n the maximum value. Note too you can select dates not only in the\n past but also in the future.\n\n PDSGEN, which generates control cards from directory information,\n might well be used in conjunction with TOUCH by generating the\n skeleton control cards for existing PDS's. It's available from the\n same source as TOUCH.\n\n\n:HEADER1   PACKAGE CONTENTS\n\n The files involved specifically with TOUCH are:\n\n     - TOUCH      the PL/I code wrapped in JCL to compile\n                  and link edit it\n\n     - BLDR       the Assembler code wrapped in JCL to\n                  assemble and link edit it\n\n     - STOWR      the Assembler code wrapped in JCL to\n                  assemble and link edit it\n\n     - TOUCH$     a JCL skeleton for its execution\n\n:RESET\n:PAGESIZE  58\n:LINESIZE  80\n:TOC       YES\n:DOCTITLE  UNTOUCH\n:DOCTITLE2 Remove Extraneous Directory Information\n:DOCTITLE3 From Partitioned Data Sets\n:TLRDATE   February 14, 2001\n:TLRDESC   Freeware from Steli Inc.\n:HEADER1   INTRODUCTION\n\n This document is intended to provide user information for the\n utility to remove extraneous directory statistics (UNTOUCH).\n Some understanding of Job Control Language (JCL) is required as\n well as knowledge of how programs are executed.\n\n UNTOUCH is mainframe freeware.  You do not need to register\n to use UNTOUCH.  It may be placed on any archive, web site\n or bulletin board without restraint.  It may be distributed\n by any means, provided that no charge is made other than for\n reasonable distribution costs.\n\n UNTOUCH is intended for MVS compatible systems to remove any\n unneeded directory information from partitioned data sets\n (PDS's). If a member has no such information, it is left alone.\n This would be done to enhance access performance to a CLIST,\n PROC library or macro library as well as freeing up directory\n space.  The name, UNTOUCH, refers in a contrary way to the\n ability to \"touch\" a member, that is, set statistical\n information.  This simply removes everything except the bare\n bones name, TTR and attribute byte.\n\n UNTOUCH is a PL/I program with an assembler subroutine that can\n process a name range or a specific number of members. It is\n intended to be used on libraries where there's some advantage to\n removing the statistical data.  It should never be used on a\n load module library since the directory information stored\n within is critical to executing those members.\n\n Steli Inc. has made its best effort to provide working,\n tested code.  However, nothing is perfect - there may be\n flaws and there certainly could be improvements.  All\n questions, concerns, problems and suggestions are welcome\n and may be sent to C_Hafner@HotMail.Com.\n\n\n:HEADER1   EXECUTION JCL\n\n The job control language (JCL) for UNTOUCH is:\n\n           //UNTOUCH    EXEC     PGM=UNTOUCH  ( ,REGION=4M )\n\n           //SYSUT1       DD       DISP=SHR,DSN=...\n\n           //SYSIN        DD       *\n\n               FIRST=000001,        LAST=999999,\n\n               FIRSTMEM='        ', LASTMEM='99999999';\n\n           //SYSPRINT     DD       SYSOUT=*\n\n           //STEPLIB      DD       DISP=SHR,DSN=...\n\n Optional control language elements are shown in parentheses.\n The name of the program  may be changed as desired providing\n that the actual program is linked with the appropriate name\n or alias.\n\n REGION is optional.  STEPLIB may be optional if UNTOUCH is\n placed in the system's link list but otherwise simply points to\n where UNTOUCH is stored.\n\n The SYSPRINT file may be directed to any output class or may\n be sent to a new or existing file.  The DCB attributes of\n SYSPRINT will be record format FBA and LRECL 121.  This file\n will show the number of members processed.\n\n SYSUT1 points to the partitioned data set to be processed.\n\n SYSIN contains control information on the range or number of\n members to be processed. The default shown will basically\n process the entire PDS, unless there are more then 999,999\n members or the actual member names are outside the range of\n blanks through all 9's.  FIRST and LAST refer to the number of\n the members in the PDS, that is, the very first member is 1.\n FIRSTMEM and LASTMEM refer to the actual names of the members,\n e.g. COPYTO or ASMA90.\n\n To remove the statistics from the name range of GET through PUT\n inclusive, you'd have:\n\n               FIRST=000001,        LAST=999999,\n               FIRSTMEM='GET     ', LASTMEM='PUT     ';\n\n Note the control card data is free form and does not need to be\n aligned in any way. The sample shown here was aligned for\n readability only.  So the following is equivalent to the\n previous set:\n\n    FIRST=000001, LAST=999999, FIRSTMEM='GET     ', LASTMEM='PUT     ';\n\n The commas and final semicolon are necessary for PL/I stream\n input.  If an error occurs, the program will terminate returning\n the code received from attempting to replace the member\n information.\n\n\n:HEADER1   SAMPLE JCL AND OUTPUT\n\n An example of JCL that may be used is:\n\n      //CLEANUP   EXEC  PGM=UNTOUCH,REGION=4M\n\n      //SYSIN       DD    *\n\n               FIRST=000001,        LAST=999999,\n\n               FIRSTMEM='ELIG001 ', LASTMEM='ELIG999 ';\n\n      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB\n\n      //SYSPRINT     DD        SYSOUT=C\n\n      //SYSUT1       DD        DISP=SHR,DSN=SYS1.PROCLIB\n\n The above step will remove the extra directory information, if\n any, from members in SYS1.PROCLIB from member ELIG001 through\n ELIG999.\n\n So, if the PDS looked like the following in ISPF Edit:\n\n       Name      Prompt  Size    Created           Changed           ID\n      @README@\n      ADDDOTSL             42  2001/02/09  2001/02/09 07:35:40  USER002\n      ADDFLAG              56  2001/02/09  2001/02/09 07:35:40  USER002\n      ADDLINEA              4  2001/02/09  2001/02/09 07:35:40  USER002\n      ADDLINEB              4  2001/02/09  2001/02/09 07:35:40  USER002\n      ADDLINES             84  2001/02/09  2001/02/09 07:35:40  USER002\n      ALLMEM\n      ALLMEMC               5  2001/02/09  2001/02/09 07:35:40  USER002\n      ALLMEMF\n\n resulting in the following after UNTOUCH runs:\n\n       Name      Prompt  Size    Created           Changed           ID\n      @README@\n      ADDDOTSL\n      ADDFLAG\n      ADDLINEA\n      ADDLINEB\n      ADDLINES\n      ALLMEM\n      ALLMEMC\n      ALLMEMF\n\n\n:HEADER1   PACKAGE CONTENTS\n\n The files involved specifically with UNTOUCH are:\n\n     - STOWU      the assembler source code wrapped in JCL\n                  to assemble and link it\n\n     - UNTOUCH    the PL/I code wrapped in JCL to compile\n                  and link edit it\n\n     - UNTOUCH$   a JCL skeleton for its execution\n\n:RESET\n:PAGESIZE  58\n:LINESIZE  80\n:TOC       YES\n:DOCTITLE  VALUES\n:DOCTITLE2 Summarize All Data Values\n:DOCTITLE3 From a Sequential File\n:TLRDATE   February 29, 2004\n:TLRDESC   Freeware from Steli Inc.\n:HEADER1   INTRODUCTION\n\n This document is intended to provide user information for\n summarizing data values from a sequential file (VALUES).  Some\n understanding of Job Control Language (JCL) is required as well\n as knowledge of how programs are executed.\n\n VALUES is mainframe freeware.   You do not need to register to\n use VALUES.  It may be placed on any archive, web site or\n bulletin board without restraint.  It may be distributed by any\n means, provided that no charge is made other than for reasonable\n distribution costs.\n\n VALUES is a PL/I program intended for MVS compatible systems to\n list all the distinct values present in specific columns of a\n sequential file.  It processes totally in memory and shows the\n values for one or more sets of columns in the order that the\n values occur, in the order of their EBCDIC collating sequence,\n or in descending order of the number of occurrences for each\n value.  The intention is to provide fast and concise analysis of\n the data.\n\n Steli Inc. has made its best effort to provide working,\n tested code.  However, nothing is perfect - there may be\n flaws and there certainly could be improvements.  All\n questions, concerns, problems and suggestions are welcome\n and may be sent to C_Hafner@HotMail.Com.\n\n\n:HEADER1   EXECUTION JCL\n\n The job control language (JCL) for VALUES is:\n\n      //VALUES     EXEC     PGM=VALUES,REGION=464M,\n\n      //             PARM='HEAP(01M,01M,ANYWHERE)/      '\n\n      //*               -- SORT BY ACTUAL VALUES /VALUES'\n\n      //*               -- SORT BY # OCCURRENCES /OCCURS'\n\n      //I            DD       DCB=BUFNO=32,\n\n      //             DISP=SHR,DSN=...\n\n      00001-00005      * FROM/TO COLUMNS IN 1 THRU 11\n\n      00051-00060      * COMMENTS IN COLUMNS 12 ONWARD\n\n      00021*00023      * ANY NON DASH IN COL 6 SUMS EACH COL & TOTAL\n\n      //STEPLIB      DD       DISP=SHR,DSN=...\n\n      //SYSPRINT     DD       SYSOUT=*\n\n Optional control language elements are shown in parentheses.\n The name of the program  may be changed as desired providing\n that the actual program is linked with the appropriate name\n or alias.\n\n REGION is optional but needs to allow for keeping the entire\n linked list of values in memory at one time.\n\n The PARM reflects getting heap memory in chunks of 1 megabyte -\n this is sent to the language environment.  The slash separates\n the language parameter from the program paramter. A blank\n program parameter causes the values to be listed as they occur.\n VALUES causes them to be sorted by the actual values and OCCURS\n causes the listed items to be sorted descending by their number\n of occurences.\n\n STEPLIB may be optional if VALUES is placed in the system's link\n list but otherwise simply points to where VALUES is stored.\n\n The SYSPRINT file may be directed to any output class or may be\n sent to a new or existing file.  The DCB attributes of SYSPRINT\n may be either Fixed or Variable, blocked or unblocked, and any\n record length over 60 bytes.  That is, it can be FBA/80/6160 or\n VBA/125/32760, or just leave DCB off and have it default.\n\n The SYSIN control cards consist simply of the 5 digit starting\n column of the data, a dash and the 5 digit ending column.  Any\n data beyond column 11 is considered a comment and will only be\n shown in the output listing.\n\n\n:HEADER1   SAMPLE JCL AND OUTPUT\n\n An example of JCL that may be used is:\n\n      //SUMMARY    EXEC     PGM=VALUES,REGION=464M,\n\n      //             PARM='HEAP(01M,01M,ANYWHERE)/VALUES'\n\n      //I            DD       *\n\n                02-01-99\n\n                02-11-99\n\n                02-08-00\n\n                02-06-04\n\n                02-03-99\n\n                02-11-01\n\n                02-06-99\n\n                02-11-99\n\n                02-11-99\n\n                02-11-99\n\n      //SYSIN        DD       *\n\n      00011-00012  SUMMARIZE MONTHS IN INPUT\n\n      00014-00015  SUMMARIZE DAY VALUES IN INPUT\n\n      00011-00018  SUMMARIZE THE ENTIRE DATE VALUE\n\n      00011X00018  SUMMARIZE THE CHARACTERS IN 11 TO 18\n\n      //STEPLIB      DD       DISP=SHR,DSN=SYS1.RUBBER.DUCKY\n\n      //SYSPRINT     DD       SYSOUT=*\n\n The above step will produce the following output:\n\n   RECORD COUNT =           10\n\n   COLUMN(S)    11-   12 CONTAIN             1 UNIQUE VALUE(S) --\n   SUMMARIZE MONTHS IN INPUT\n                 10 >>02<<\n\n   COLUMN(S)    14-   15 CONTAIN             5 UNIQUE VALUE(S) --\n   SUMMARIZE DAY VALUES IN INPUT\n                  1 >>01<<\n                  1 >>03<<\n                  2 >>06<<\n                  1 >>08<<\n                  5 >>11<<\n\n   COLUMN(S)    11-   18 CONTAIN             7 UNIQUE VALUE(S) --\n   SUMMARIZE THE ENTIRE DATE VALUE\n                  1 >>02-01-99<<\n                  1 >>02-03-99<<\n                  1 >>02-06-04<<\n                  1 >>02-06-99<<\n                  1 >>02-08-00<<\n                  1 >>02-11-01<<\n                  4 >>02-11-99<<\n\n   COLUMN(S)    11 THRU    18 HAVE             9 UNIQUE VALUE(S) --\n   SUMMARIZE THE CHARACTERS IN 11 TO 18\n              20 >>-<<\n              19 >>0<<\n              12 >>1<<\n              10 >>2<<\n               1 >>3<<\n               1 >>4<<\n               2 >>6<<\n               1 >>8<<\n              14 >>9<<\n\n Note the record count is shown, 10, and the control cards do not\n have to be in any order. Also, the fields may, as in this case,\n overlap. The COLUMN(S) line also shows the number of unique values.\n\n The first 3 sets of data may be verified against the input to\n see that there are 10 occurrences in each set and that the\n values shown match against the input too. We'd asked that the\n output be sorted by value and that also can be seen easily.\n\n The 4th control card requests that the individual columns be\n summarized and those summaries combined. This is useful when\n you want to see what characters comprise certain fields or\n even the entire record. You can easily see that the date field\n contained only dashes and the 10 numeric digits.\n\n:HEADER1   PACKAGE CONTENTS\n\n The files involved specifically with VALUES are:\n\n     - VALUES     the PL/I code wrapped in JCL to compile\n                  and link edit it\n\n     - VALUES$    a JCL skeleton for its execution\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@XALLMEM": {"ttr": 13835, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x10\\x00\\x10\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "REXX"}, "text": "/*** REXX  --  MAKE CODE WORK LOCALLY ***/\n   \"ISREDIT MACRO\"\n   \"ISREDIT C  '-YOUR-LOADLIB-'        '-YOUR-LOADLIB-'    ALL\"\n   \"ISREDIT C  '-YOUR-SYSLIB-'         '-YOUR-SYSLIB-'     ALL\"\n   \"ISREDIT C  '-YOUR-ACCT-INFO-'      '-YOUR-ACCT-INFO-'  ALL\"\n   \"ISREDIT C  '-YOUR-USERID-'         '-YOUR-USERID-'     ALL\"\n   \"ISREDIT C  '-YOUR-NAME-'           '-YOUR-NAME-'       ALL\"\n   \"ISREDIT C  '-YOUR-SCEELLED-'       '-YOUR-SCEELLED-'   ALL\"\n   \"ISREDIT C  'CLASS=2'               'CLASS=2'           ALL\"\n   \"ISREDIT C  'MSGCLASS=X'            'MSGCLASS=X'        ALL\"\n   \"ISREDIT C  '-YOUR-PLI-LIB-'        '-YOUR-PLI-LIB-'    ALL\"\n   \"ISREDIT C  '-YOUR-COPYLIB-1-'      '-YOUR-COPYLIB-1-'  ALL\"\n   \"ISREDIT C  '-YOUR-COPYLIB-2-'      '-YOUR-COPYLIB-2-'  ALL\"\n   \"ISREDIT C  '-YOUR-COPYLIB-3-'      '-YOUR-COPYLIB-3-'  ALL\"\n   \"ISREDIT C  '-YOUR-COPYLIB-4-'      '-YOUR-COPYLIB-4-'  ALL\"\n   \"ISREDIT END\"\n", "mimetype": "text/x-diff", "datatype": "ebcdic", "extension": ".diff"}, "ABENDX": {"ttr": 14081, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00q\\x00q\\x00\\x00\\xc1\\xc2\\xc5\\xd5\\xc4\\xe7@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 113, "newlines": 113, "modlines": 0, "user": "ABENDX"}, "text": "//-YOUR-USERID-A JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//*** PROGRAM TO ABEND WITH A PARM DRIVEN RETURN CODE 0 TO 4095\n//*** OR 0C1, 0C2, 0C3, 0C4, 0C6, 0C7, 0C8, 0C9, 0CB OR 806\n//***    IF NO OR BAD PARM, ABEND WITH 4095\n//***\n//A          EXEC     PGM=ASMA90,REGION=4M,\n//             PARM='OBJECT'\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//SYSLIB       DD       DISP=SHR,DSN=SYS1.MACLIB\n         USING *,11\nABENDX   STM   14,12,12(13)\n         LR    11,15\n         LA    14,SAVEAREA\n         ST    14,8(13)\n         ST    13,4(14)\n         LR    13,14\n         L     3,0(1)           * GET PTR TO PARM\n         LH    4,0(3)           * GET LENGTH OF PARM\n         LTR   4,4\n         BNZ   REALPARM\nDEFAULT  LA    5,4095           * IF ZERO LEN, DEFAULT TO 4095 CODE\n         B     DIE\nREALPARM C     4,THREE          * CHECK IF S0C ABEND DESIRED\n         BNE   NOTS0C\n         CLC   2(3,3),STR0C1\n         BE    S0C1\n         CLC   2(3,3),STR0C2\n         BE    S0C2\n         CLC   2(3,3),STR0C3\n         BE    S0C3\n         CLC   2(3,3),STR0C4\n         BE    S0C4\n         CLC   2(3,3),STR0C6\n         BE    S0C6\n         CLC   2(3,3),STR0C7\n         BE    S0C7\n         CLC   2(3,3),STR0C8\n         BE    S0C8\n         CLC   2(3,3),STR0C9\n         BE    S0C9\n         CLC   2(3,3),STR0CB\n         BE    S0CB\n         CLC   2(3,3),STR806\n         BE    S806\nNOTS0C   BCTR  4,0\n         STC   4,TRTINST+1      * CHECK FOR NUMERIC\nTRTINST  TRT   2(1,3),NUMTBL\n         BC    7,DEFAULT\n         LA    5,112(4)\n         STC   5,PACKINST+1\nPACKINST PACK  DW,2(1,3)\n         CVB   5,DW\n         C     5,MAX            * CHECK FOR MAX (4095)\n         BH    DEFAULT\nDIE      ABEND (5)\nS0C1     DC    H'0'\nS0C2     DC    X'B20A0000'\nS0C3     EX    0,*\nS0C4     SR    15,15\n         MVI   0(15),X'FF'\nS0C6     LA    15,*\n         LA    15,1(15)\n         BR    15\nS0C7     ZAP   *+6(3),BIGNUM\nS0C8     L     15,MAXNUM\n         A     15,MAXNUM\nS0C9     SR    14,14\n         LA    15,1\n         SR    2,2\n         DR    14,2\nS0CB     DP    TO,BY\nS806     LINK  EP=QWERTYUIO\nDW       DS    D\nSAVEAREA DS    9D\nNUMTBL   DC    240X'FF',10X'00',6X'FF'\nMAX      DC    F'4095'\nTHREE    DC    F'3'\nBIGNUM   DC    F'1357902468'\nMAXNUM   DC    X'7FFFFFFF'\nSTR0C1   DC    CL3'0C1'\nSTR0C2   DC    CL3'0C2'\nSTR0C3   DC    CL3'0C3'\nSTR0C4   DC    CL3'0C4'\nSTR0C6   DC    CL3'0C6'\nSTR0C7   DC    CL3'0C7'\nSTR0C8   DC    CL3'0C8'\nSTR0C9   DC    CL3'0C9'\nSTR0CB   DC    CL3'0CB'\nSTR806   DC    CL3'806'\nTO       DC    PL3'99999'\nBY       DC    PL1'0'\n         END   ABENDX\n//***\n//L          EXEC     PGM=IEWL,\n//             PARM='XREF,LIST,LET,DCBS',\n//             REGION=4M\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,\n//             DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   04031200\n  NAME     ABENDX(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ABENDX$": {"ttr": 14084, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x06\\x00\\x06\\x00\\x00\\xc1\\xc2\\xc5\\xd5\\xc4\\xe7@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 6, "newlines": 6, "modlines": 0, "user": "ABENDX"}, "text": "//-YOUR-USERID-A JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//ABEND      EXEC     PGM=ABENDX,PARM=0037\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ADDCC": {"ttr": 14086, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x01\\xad\\x01\\xad\\x00\\x00\\xc1\\xc4\\xc4\\xc3\\xc3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 429, "newlines": 429, "modlines": 0, "user": "ADDCC"}, "text": "//-YOUR-USERID-A JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  CHANGE TAGGED DOC I/P INTO ASCII CARRIAGE CONTROLLED O/P\n//***\n//C          EXEC     PGM=IEL0AA,REGION=4M,\n//             PARM=('AG,A,NCT,ESD,F(I),NOFLOW,NIS,NOLIST,M,NMI,NEST',\n//             'MAP,OF,OPT(TIME),OP,SZ(MAX),S,STMT,STG,X(F)')\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-PLI-LIB-\n\n ADDCC: PROC OPTIONS(MAIN) REORDER;\n\n    DCL  REC           CHAR(00255) STATIC VARYING;\n    DCL  I_EOF_IND     CHAR(01) STATIC INIT('N');\n    DCL  SYSIN_EOF_IND CHAR(01) STATIC INIT('N');\n\n    DCL  LINESIZE      FIXED BIN(31) STATIC INIT(072);\n    DCL  PAGESIZE      FIXED BIN(31) STATIC INIT(058);\n    DCL  TOC           CHAR(001)     STATIC INIT('Y');\n    DCL  RESET         CHAR(001)     STATIC INIT('N');\n    DCL  DOCTITLE      CHAR(255)     STATIC VARYING INIT('');\n    DCL  DOCTITLE2     CHAR(255)     STATIC VARYING INIT('');\n    DCL  DOCTITLE3     CHAR(255)     STATIC VARYING INIT('');\n    DCL  TLRDATE       CHAR(255)     STATIC VARYING INIT('');\n    DCL  TLRDESC       CHAR(255)     STATIC VARYING INIT('');\n\n    DCL  LINE_TBL(32760)  CHAR(255)  STATIC VARYING;\n    DCL  LINE_TBL#     FIXED BIN(15) STATIC INIT(0);\n    DCL  1  TOC_TBL(2048) STATIC,\n          10  HDR      CHAR(255)     VARYING,\n          10  HDRTYPE  CHAR(001),\n          10  HDRDESC  CHAR(057),\n          10  PAGE     FIXED BIN(31);\n    DCL  TOC#          FIXED BIN(15) STATIC INIT(0);\n\n    DCL  (II,JJ,KK)    FIXED BIN(31) STATIC INIT(0);\n    DCL  CURRHDR1      CHAR(255)     STATIC VARYING INIT('');\n    DCL  CURRHDR2      CHAR(255)     STATIC VARYING INIT('');\n    DCL  CURRPAGE      FIXED BIN(15) STATIC INIT(0);\n    DCL  FORMATTED_PAGE  PIC'ZZ,ZZ9' STATIC;\n    DCL  CURRLINE      FIXED BIN(15) STATIC INIT(0);\n    DCL  BLANKS        CHAR(255)     STATIC INIT(' ');\n    DCL  UNDERSCORES   CHAR(255)     STATIC INIT((255)'_');\n    DCL  DOTS          CHAR(254)     STATIC INIT((127)' .');\n    DCL  VV            CHAR(255)     STATIC VARYING INIT('');\n\n    DCL  SUBSTR        BUILTIN;\n    DCL  LENGTH        BUILTIN;\n\n\n    ON ENDFILE(I) I_EOF_IND = 'Y';\n    READ FILE(I) INTO(REC);\n\n START_OVER:\n    DO WHILE ( I_EOF_IND  = 'N' );\n       IF SUBSTR(REC,1,1) = ':'\n          THEN CALL PROCESS_CONTROL;\n          ELSE CALL PROCESS_LINE;\n       READ FILE(I) INTO(REC);\n    END;\n\n FINISH_SET:\n    CALL PROCESS_TITLE_PAGE;\n    IF TOC = 'Y' THEN CALL PROCESS_TOC;\n                 ELSE CURRPAGE = 1;\n    CALL PROCESS_ACTUAL_LINES;\n    IF RESET = 'Y'\n       THEN DO;\n          RESET     = 'N';\n          CURRPAGE  = 0;\n          CURRLINE  = 0;\n          LINE_TBL# = 0;\n          TOC#      = 0;\n       END;\n    IF I_EOF_IND  = 'N' THEN GOTO START_OVER;\n\n\n PROCESS_LINE:  PROC;\n    CURRLINE  = CURRLINE + 1;\n    IF CURRLINE > PAGESIZE\n       THEN DO;\n          CURRPAGE = CURRPAGE + 1;\n          LINE_TBL#     = LINE_TBL# + 1;\n          FORMATTED_PAGE = CURRPAGE;\n          LINE_TBL(LINE_TBL#) = '1'\n             || SUBSTR(BLANKS,1,\n                   (LINESIZE-LENGTH(CURRHDR1)-1)/2-11)\n             || CURRHDR1\n             || SUBSTR('             (Continued)',\n                   12*(LENGTH(CURRHDR1) > 0)+1,12)\n             || SUBSTR(BLANKS,1,\n                    (LINESIZE-LENGTH(CURRHDR1))/2-12)\n             || 'Page '\n             || FORMATTED_PAGE;\n          LINE_TBL#     = LINE_TBL# + 1;\n          LINE_TBL(LINE_TBL#) = SUBSTR(BLANKS,1,LINESIZE);\n          CURRLINE = 2;\n       END;\n    LINE_TBL# = LINE_TBL# + 1;\n    LINE_TBL(LINE_TBL#) = REC\n       || SUBSTR(BLANKS,1,LINESIZE-LENGTH(REC));\n    END PROCESS_LINE;\n\n\n PROCESS_CONTROL:  PROC;\n    IF SUBSTR(REC,02,01) = '*'\n       THEN;\n    else IF SUBSTR(REC,02,05) = 'RESET'\n       THEN DO;\n          RESET = 'Y';\n          GOTO FINISH_SET;\n       END;\n    ELSE IF SUBSTR(REC,02,07) = 'HEADER2'\n       THEN DO;\n          DO II = LINESIZE TO 1 BY -1\n                WHILE ( SUBSTR(REC,II,1) = ' ' );\n          END;\n          DO JJ = 9 TO LINESIZE\n                WHILE ( SUBSTR(REC,JJ,1) = ' ' );\n          END;\n          DO KK = JJ TO LINESIZE\n                WHILE ( SUBSTR(REC,KK,1) \u00ac= ' ' );\n          END;\n          TOC# = TOC# + 1;\n          HDR(TOC#) = SUBSTR(REC,JJ,KK-JJ);\n          HDRTYPE(TOC#)   = '2';\n          HDRDESC(TOC#)   = ' ';\n          PAGE(TOC#) = CURRPAGE;\n          CURRHDR2  = SUBSTR(REC,JJ,KK-JJ);\n          IF PAGESIZE < CURRLINE + 5\n             THEN DO;\n                CURRPAGE      = CURRPAGE + 1;\n                CURRLINE      = 2;\n                PAGE(TOC#)    = CURRPAGE;\n                LINE_TBL#     = LINE_TBL# + 1;\n                FORMATTED_PAGE = CURRPAGE;\n                LINE_TBL(LINE_TBL#) = '1'\n                   || SUBSTR(BLANKS,1,\n                         (LINESIZE-LENGTH(CURRHDR1)-1)/2-11)\n                   || CURRHDR1\n                   || ' (Continued)'\n                   || SUBSTR(BLANKS,1,\n                         (LINESIZE-LENGTH(CURRHDR1))/2-12)\n                   || 'Page '\n                   || FORMATTED_PAGE;\n                LINE_TBL#     = LINE_TBL# + 1;\n                LINE_TBL(LINE_TBL#) = SUBSTR(BLANKS,1,LINESIZE);\n             END;\n          CURRLINE  = CURRLINE + 1;\n          LINE_TBL# = LINE_TBL# + 1;\n          LINE_TBL(LINE_TBL#) = ' ' || SUBSTR(REC,JJ,II-JJ+1)\n             || SUBSTR(BLANKS,1,LINESIZE-II+JJ-2);\n          LINE_TBL# = LINE_TBL# + 1;\n          LINE_TBL(LINE_TBL#) = '+'\n             || SUBSTR(UNDERSCORES,1,LENGTH(CURRHDR2))\n             || SUBSTR(BLANKS,1,LINESIZE-LENGTH(CURRHDR2)-1);\n       END;\n    ELSE IF SUBSTR(REC,02,07) = 'HEADERT'\n       THEN DO;\n          DO II = LINESIZE TO 1 BY -1\n                WHILE ( SUBSTR(REC,II,1) = ' ' );\n          END;\n          DO JJ = 9 TO LINESIZE\n                WHILE ( SUBSTR(REC,JJ,1) = ' ' );\n          END;\n          HDRDESC(TOC#) = SUBSTR(REC,JJ,II-JJ+1)\n             || SUBSTR(' ',1,MOD(II-JJ+1,2))\n             || REPEAT('. ',24);\n       END;\n    ELSE IF SUBSTR(REC,02,07) = 'HEADER1'\n       THEN DO;\n          DO II = LINESIZE TO 1 BY -1\n                WHILE ( SUBSTR(REC,II,1) = ' ' );\n          END;\n          DO JJ = 9 TO LINESIZE\n                WHILE ( SUBSTR(REC,JJ,1) = ' ' );\n          END;\n          TOC#          = TOC# + 1;\n          HDR(TOC#)     = SUBSTR(REC,JJ,II-JJ+1);\n          HDRTYPE(TOC#) = '1';\n          CURRHDR1      = SUBSTR(REC,JJ,II-JJ+1);\n          CURRPAGE      = CURRPAGE + 1;\n          PAGE(TOC#)    = CURRPAGE;\n          CURRLINE      = 2;\n          LINE_TBL#     = LINE_TBL# + 1;\n          FORMATTED_PAGE = CURRPAGE;\n          LINE_TBL(LINE_TBL#) = '1'\n             || SUBSTR(BLANKS,1,(LINESIZE-LENGTH(CURRHDR1)-1)/2-5)\n             || CURRHDR1\n             || SUBSTR(BLANKS,1,(LINESIZE-LENGTH(CURRHDR1))/2-6)\n             || 'Page '\n             || FORMATTED_PAGE;\n          LINE_TBL#     = LINE_TBL# + 1;\n          LINE_TBL(LINE_TBL#) = SUBSTR(BLANKS,1,LINESIZE);\n       END;\n    ELSE IF SUBSTR(REC,02,08) = 'PAGESIZE'\n       THEN DO;\n          DO II = LINESIZE TO 1 BY -1\n                WHILE ( SUBSTR(REC,II,1) = ' ' );\n          END;\n          DO JJ = 10 TO LINESIZE\n                WHILE ( SUBSTR(REC,JJ,1) = ' ' );\n          END;\n          PAGESIZE  = SUBSTR(REC,JJ,II-JJ+1);\n       END;\n    ELSE IF SUBSTR(REC,02,03) = 'TOC'\n       THEN DO;\n          DO JJ = 5 TO LINESIZE\n                WHILE ( SUBSTR(REC,JJ,1) = ' ' );\n          END;\n          IF SUBSTR(REC,JJ,03) = 'YES'\n             THEN TOC = 'Y';\n             ELSE TOC = 'N';\n       END;\n    ELSE IF SUBSTR(REC,02,09) = 'DOCTITLE '\n       THEN DO;\n          DO II = LINESIZE TO 1 BY -1\n                WHILE ( SUBSTR(REC,II,1) = ' ' );\n          END;\n          DO JJ = 10 TO LINESIZE\n                WHILE ( SUBSTR(REC,JJ,1) = ' ' );\n          END;\n          DOCTITLE = SUBSTR(REC,JJ,II-JJ+1);\n       END;\n    ELSE IF SUBSTR(REC,02,09) = 'DOCTITLE2'\n       THEN DO;\n          DO II = LINESIZE TO 1 BY -1\n                WHILE ( SUBSTR(REC,II,1) = ' ' );\n          END;\n          DO JJ = 11 TO LINESIZE\n                WHILE ( SUBSTR(REC,JJ,1) = ' ' );\n          END;\n          DOCTITLE2 = SUBSTR(REC,JJ,II-JJ+1);\n       END;\n    ELSE IF SUBSTR(REC,02,09) = 'DOCTITLE3'\n       THEN DO;\n          DO II = LINESIZE TO 1 BY -1\n                WHILE ( SUBSTR(REC,II,1) = ' ' );\n          END;\n          DO JJ = 11 TO LINESIZE\n                WHILE ( SUBSTR(REC,JJ,1) = ' ' );\n          END;\n          DOCTITLE3 = SUBSTR(REC,JJ,II-JJ+1);\n       END;\n    ELSE IF SUBSTR(REC,02,07) = 'TLRDATE'\n       THEN DO;\n          DO II = LINESIZE TO 1 BY -1\n                WHILE ( SUBSTR(REC,II,1) = ' ' );\n          END;\n          DO JJ = 9 TO LINESIZE\n                WHILE ( SUBSTR(REC,JJ,1) = ' ' );\n          END;\n          TLRDATE = SUBSTR(REC,JJ,II-JJ+1);\n       END;\n    ELSE IF SUBSTR(REC,02,07) = 'TLRDESC'\n       THEN DO;\n          DO II = LINESIZE TO 1 BY -1\n                WHILE ( SUBSTR(REC,II,1) = ' ' );\n          END;\n          DO JJ = 9 TO LINESIZE\n                WHILE ( SUBSTR(REC,JJ,1) = ' ' );\n          END;\n          TLRDESC = SUBSTR(REC,JJ,II-JJ+1);\n       END;\n    ELSE IF SUBSTR(REC,02,08) = 'LINESIZE'\n       THEN DO;\n          DO II = LINESIZE TO 1 BY -1\n                WHILE ( SUBSTR(REC,II,1) = ' ' );\n          END;\n          DO JJ = 10 TO LINESIZE\n                WHILE ( SUBSTR(REC,JJ,1) = ' ' );\n          END;\n          LINESIZE  = SUBSTR(REC,JJ,II-JJ+1);\n       END;\n    ELSE CALL PROCESS_LINE;\n END PROCESS_CONTROL;\n\n\n PROCESS_TITLE_PAGE: PROC;\n    REC = ' ' || SUBSTR(BLANKS,1,LINESIZE-1);\n    WRITE FILE(O) FROM(REC);\n    IF DOCTITLE \u00ac= ''\n       THEN DO;\n          JJ = 3;\n          DO II = 1 TO (((PAGESIZE/2)-4)/3);\n             REC = '-' || SUBSTR(BLANKS,1,LINESIZE-1);\n             WRITE FILE(O) FROM(REC);\n             JJ = JJ + 3;\n          END;\n          REC = ' '\n             || SUBSTR(BLANKS,1,(LINESIZE-LENGTH(DOCTITLE)-1)/2)\n             || DOCTITLE\n             || SUBSTR(BLANKS,1,(LINESIZE-LENGTH(DOCTITLE))/2);\n          WRITE FILE(O) FROM(REC);\n          REC = ' '\n             || SUBSTR(BLANKS,1,(LINESIZE-LENGTH(DOCTITLE2)-1)/2)\n             || DOCTITLE2\n             || SUBSTR(BLANKS,1,(LINESIZE-LENGTH(DOCTITLE2))/2);\n          WRITE FILE(O) FROM(REC);\n          REC = ' '\n             || SUBSTR(BLANKS,1,(LINESIZE-LENGTH(DOCTITLE3)-1)/2)\n             || DOCTITLE3\n             || SUBSTR(BLANKS,1,(LINESIZE-LENGTH(DOCTITLE3))/2);\n          WRITE FILE(O) FROM(REC);\n          IF TLRDATE \u00ac= '' | TLRDESC \u00ac= ''\n             THEN DO;\n                DO II = 1 TO ((PAGESIZE-JJ)/3);\n                   REC = '-' || SUBSTR(BLANKS,1,LINESIZE-1);\n                   WRITE FILE(O) FROM(REC);\n                END;\n                REC = ' ' || TLRDATE\n                   || SUBSTR(BLANKS,1,\n                      LINESIZE-LENGTH(TLRDATE)-LENGTH(TLRDESC)-1)\n                   || TLRDESC;\n                WRITE FILE(O) FROM(REC);\n             END;\n       END;\n END PROCESS_TITLE_PAGE;\n\n\n PROCESS_TOC:   PROC;\n    IF TOC# > 0\n       THEN DO;\n          KK       = LINE_TBL# + 1;\n          CURRLINE = 2;\n          CURRPAGE = 2;\n          FORMATTED_PAGE = CURRPAGE;\n          LINE_TBL(KK) = '1' || SUBSTR(BLANKS,1,(LINESIZE-16)/2-6)\n             || 'TABLE OF CONTENTS'\n             || SUBSTR(BLANKS,1,(LINESIZE-17)/2-6)\n             || 'Page '\n             || FORMATTED_PAGE;\n          LINE_TBL(KK+1) = SUBSTR(BLANKS,1,LINESIZE);\n          KK = KK + 1;\n          DO II = 1 TO TOC#;\n             IF CURRLINE > PAGESIZE\n                THEN DO;\n                   CURRLINE = 2;\n                   CURRPAGE = CURRPAGE + 1;\n                   FORMATTED_PAGE = CURRPAGE;\n                   KK = KK + 1;\n                   LINE_TBL(KK) = '1'\n                      || SUBSTR(BLANKS,1,(LINESIZE-28)/2-6)\n                      || 'TABLE OF CONTENTS (Continued)'\n                      || SUBSTR(BLANKS,1,(LINESIZE-29)/2-6)\n                      || 'Page '\n                      || FORMATTED_PAGE;\n                   KK = KK + 1;\n                   LINE_TBL(KK) = SUBSTR(BLANKS,1,LINESIZE);\n                END;\n             IF HDRTYPE(II) = '1'\n                THEN DO;\n                   FORMATTED_PAGE = PAGE(II);\n                   KK = KK + 1;\n                   LINE_TBL(KK) = SUBSTR(BLANKS,1,LINESIZE);\n                   KK = KK + 1;\n                   LINE_TBL(KK) = ' ' || HDR(II)\n                      || SUBSTR(BLANKS,1,MOD(LENGTH(HDR(II)),2)+1)\n                      || SUBSTR(DOTS,1,LINESIZE\n                         -LENGTH(HDR(II))-8-MOD(LENGTH(HDR(II)),2))\n                      || FORMATTED_PAGE;\n                   KK = KK + 1;\n                   LINE_TBL(KK) = SUBSTR(BLANKS,1,LINESIZE);\n                   CURRLINE = CURRLINE + 3;\n                END;\n                ELSE DO;\n                   FORMATTED_PAGE = PAGE(II);\n                   KK = KK + 1;\n                   LINE_TBL(KK) = '    ' || HDR(II)\n                      || SUBSTR(BLANKS,1,MOD(LENGTH(HDR(II)),2))\n                      || SUBSTR(DOTS,1,LINESIZE\n                         -LENGTH(HDR(II))-10-MOD(LENGTH(HDR(II)),2))\n                      || FORMATTED_PAGE;\n                   IF HDRDESC(II) \u00ac= ' '\n                      THEN SUBSTR(LINE_TBL(KK),16,57) = HDRDESC(II);\n                   CURRLINE = CURRLINE + 1;\n                END;\n          END;\n          DO II = (LINE_TBL# + 1) TO KK;\n             REC = LINE_TBL(II);\n             IF SUBSTR(REC,LINESIZE-6,1) = '.'\n                   & VERIFY(SUBSTR(REC,LINESIZE,1),'0123456789') = 0\n                THEN DO;\n                   FORMATTED_PAGE = SUBSTR(REC,LINESIZE-5,6);\n                   FORMATTED_PAGE = FORMATTED_PAGE + CURRPAGE;\n                   SUBSTR(REC,LINESIZE-5,6) = FORMATTED_PAGE;\n                END;\n             WRITE FILE(O) FROM(REC);\n          END;\n       END;\n END PROCESS_TOC;\n\n\n PROCESS_ACTUAL_LINES: PROC;\n    DO II = 1 TO LINE_TBL#;\n       REC = LINE_TBL(II);\n       IF SUBSTR(REC,LINESIZE-10,5) = 'Page '\n          THEN DO;\n             CURRPAGE                 = CURRPAGE + 1;\n             FORMATTED_PAGE           = CURRPAGE;\n             SUBSTR(REC,LINESIZE-5,6) = FORMATTED_PAGE;\n          END;\n       WRITE FILE(O) FROM(REC);\n    END;\n END PROCESS_ACTUAL_LINES;\n\n\n END ADDCC;\n\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(CYL,(05,02))\n//***\n//L          EXEC     PGM=HEWLKED,\n//             PARM='XREF,LIST,LET,DCBS,AMODE=31,RMODE=ANY',\n//             REGION=4M\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE)\n//             DD       *\n  SETSSI   03011400\n  ENTRY    PLISTART\n  NAME     ADDCC(R)\n//***\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ADDCC$": {"ttr": 14094, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc1\\xc4\\xc4\\xc3\\xc3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "ADDCC"}, "text": "//-YOUR-USERID-A JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  ADD CARRIAGE CONTROL USING CONTROL TAGS AND CREATE AS FULLY\n//***  FLUSHED OUT ASCII CONTROL CARD FILE AND SEND TO PRINTER.\n//***\n//CREATE     EXEC     PGM=ADDCC,REGION=464M,\n//             PARM='HEAP(01M,01M,ANYWHERE)'\n//I            DD       DISP=SHR,DSN=...\n//O            DD       DISP=SHR,DSN=...\n//OUTDD1       OUTPUT   PRMODE=PAGE,PAGEDEF=ROTIPL\n//O            DD       SYSOUT=1,DEST=R201,\n//             DCB=(BLKSIZE=80,RECFM=FB),COPIES=01\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ADDCC@": {"ttr": 14337, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x16\\x00\\x16\\x00\\x00\\xc1\\xc4\\xc4\\xc3\\xc3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "ADDCC"}, "text": "//-YOUR-USERID-A JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  ADD CARRIAGE CONTROL USING CONTROL TAGS AND CREATE AS FULLY\n//***  FLUSHED OUT ASCII CONTROL CARD FILE AND SAVE\n//***\n//CLEANUP    EXEC     PGM=IEFBR14\n//DEL001       DD       DSN=...,\n//             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n//***\n//CREATE     EXEC     PGM=ADDCC,REGION=464M,\n//             PARM='HEAP(01M,01M,ANYWHERE)'\n//I            DD       *\n:PAGESIZE  55\n:LINESIZE  80\n:TOC       NO\n//             DD       DISP=SHR,DSN=...\n//O            DD       DSN=...,\n//             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),\n//             DCB=(BLKSIZE=80,RECFM=FBA)\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ADDCOLS": {"ttr": 14339, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x01>\\x01>\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 318, "newlines": 318, "modlines": 0, "user": "REXX"}, "text": "/**  REXX  --  Mark Zelden *******************************************/\n/*                                                                   */\n/* This EDIT macro totals numbers in a specified column range.       */\n/* An optional parameter of \"HEX\", \"ZONE\", \"PACK\", or \"BIN\" is       */\n/* needed to add hexadecimal, zoned decimal, packed decimal, or      */\n/* binary data. \"DEC\" is the default addition type.                  */\n/*                                                                   */\n/* Hexadecimal numbers to be added may be represented with or        */\n/* without an \"X\". In other words, x'1E' and 1E can both be          */\n/* processed and are treated the same.                               */\n/*                                                                   */\n/* The result is displayed as an ISPF short message in the top       */\n/* right hand corner in the same format as the addition type         */\n/* (decimal or hexadecimal). If extended help is chosen after        */\n/* the result is displayed (normally PF1), then the result is        */\n/* displayed in both decimal and hexadecimal and the average         */\n/* is also displayed.                                                */\n/*                                                                   */\n/* Line range labels can be used, and excluded lines are always      */\n/* omitted.                                                          */\n/*                                                                   */\n/*********************************************************************/\n/* COMMAND SYNTAX:                                                   */\n/*                                                                   */\n/* ADDCOLS begcol endcol <DEC | HEX | ZONE | PACK | BIN> (.L1) (.L2) */\n/*                    ** DEC is the default                          */\n/*                                                                   */\n/*  ** NOTE 1: If using line range labels then DEC, HEX, ZONE,       */\n/*             PACK, or BIN must be specified as the 3rd positional  */\n/*             parameter.                                            */\n/*                                                                   */\n/*  ** NOTE 2: Excluded lines are ALWAYS omitted.                    */\n/*                                                                   */\n/*  ** NOTE 3: DEC, HEX, ZONE, PACK, and BIN may be abbreviated by   */\n/*             using one or more of their characters. HEX may also   */\n/*             be abbreviated as \"X\".                                */\n/*                                                                   */\n/*********************************************************************/\n/*  EXAMPLES:                                                        */\n/*         ADDCOLS 10 25                                             */\n/*         ADDCOLS 33 40 HEX                                         */\n/*         ADDCOLS 25 30 DEC .A .B                                   */\n/*         ADDCOLS 10 29 ZONE                                        */\n/*         ADDCOLS 10 16 PACK                                        */\n/*         ADDCOLS 40 44 BIN                                         */\n/*         ADDCOLS 44 57 X .FROM .TO                                 */\n/*********************************************************************/\n   Address ISREDIT\n   \"MACRO (begcol endcol type label1 label2)\"\n/***********************************************/\n/*   VERIFY INPUT PARAMETERS                   */\n/***********************************************/\n   begcol = Translate(begcol) /* chage to upper case if alpha */\n   \"(width) = DATA_WIDTH \"    /* length of line               */\n   width = Format(width)      /* remove leading zeros         */\n   If begcol = '' then do\n     zedsmsg = 'MISSING PARAMETER'\n     zedlmsg = 'A BEGINNING COLUMN NUMBER',\n               'MUST BE SPECIFIED.'\n     Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n     Exit 12\n   End\n   Select\n      When Datatype(begcol,Number) = 1 & endcol = '' then do\n        zedsmsg = 'NO ENDING COLUMN'\n        zedlmsg = 'AN ENDING COLUMN NUMBER',\n                  'MUST BE SPECIFIED.'\n        Address ISPEXEC \"SETMSG MSG(ISRZ001)\"     /* msg - with alarm */\n        Exit 12\n      End\n      When Datatype(begcol,Number) <> 1 | ,\n           Datatype(endcol,Number) <> 1 then do\n        zedsmsg = 'COL NUMBER NOT NUMERIC'\n        zedlmsg = 'THE BEGINNING AND ENDING COLUMN NUMBERS',\n                  'MUST BE NUMERIC.'\n        Address ISPEXEC \"SETMSG MSG(ISRZ001)\"     /* msg - with alarm */\n        Exit 12\n      End\n      When Datatype(begcol,Number)=1 & Datatype(endcol,Number)=1 then do\n        If endcol < begcol then do\n          zedsmsg = 'END COL < START COL'\n          zedlmsg = 'THE ENDING COLUMN MUST BE GREATER THAN OR',\n                    'EQUAL TO THE STARTING COLUMN.'\n          Address ISPEXEC \"SETMSG MSG(ISRZ001)\"   /* msg - with alarm */\n          Exit 12\n        End\n        If type = '' then type = 'DEC'     /* default add type is DEC */\n        else do\n          type = Translate(type)           /* change to upper case    */\n          If Abbrev('DECIMAL',type,1) = 0 & ,\n             Abbrev('HEXADECIMAL',type,1) = 0 & ,\n             Abbrev('ZONE',type,1) = 0 & ,\n             Abbrev('PACK',type,1) = 0 & ,\n             Abbrev('BIN',type,1) = 0 & ,\n             type <> 'X' then do\n            zedsmsg = 'INVALID ADDITION TYPE'\n            zedlmsg = 'ADDITION TYPE MUST BE \"DEC\", \"HEX\",' ,\n                      '\"ZONE\", \"PACK\", or \"BIN\".'\n            Address ISPEXEC \"SETMSG MSG(ISRZ001)\" /* msg - with alarm */\n            Exit 12\n          End\n        End /* else do */\n        If begcol < 1 | endcol < 1 then do\n          zedsmsg = 'INVALID COLUMN NUMBER'\n          zedlmsg = 'ALL COLUMN SPECIFICATIONS MUST BE' ,\n                    'BETWEEN 1 AND' width\n          Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n          Exit 12\n        End\n        If begcol > width | endcol > width then do\n          zedsmsg = 'INVALID COLUMN NUMBER'\n          zedlmsg = 'ALL COLUMN SPECIFICATIONS MUST BE' ,\n                    'BETWEEN 1 AND' width\n          Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n          Exit 12\n        End\n      End\n   End /* select */\n   Call FIND_LABELS /* FIND OUT IF LABELS ARE BEING USED */\n/***************************************************/\n/* INITIALIZE VARIABLES NEEDED IN PROCESSING LOOP  */\n/***************************************************/\n   Numeric digits 31                 /* default of 9 not enough      */\n   count        = 0                  /* count of added lines         */\n   not_counted  = 0                  /* count of \"not counted\" lines */\n   total        = 0                  /* total of numbers added       */\n   tgtlen       = endcol-begcol+1    /* length of mumbers to add     */\n/*********************************************************************/\n/*   Begin column addition loop                                      */\n/*********************************************************************/\n   Do until lastln = firstln-1\n     /* copy the data in the current line to variable 'data1' */\n     \"(data1) = LINE \"firstln\n     \"ISREDIT (chkexcl) = XSTATUS\" firstln\n     If chkexcl = \"NX\" then do    /* only process non-excluded lines */\n       add_data = Substr(data1,begcol,tgtlen) /* find data           */\n       If add_data = '' then do    /* no data within cols specified  */\n         warnmsg = \"'*** WARNING - NEXT LINE WAS NOT COUNTED ***'\"\n         \"ISREDIT LINE_BEFORE\" firstln \"= NOTELINE \" warnmsg\n         not_counted = not_counted + 1 /* bump up \"not counted\" ctr  */\n         firstln = firstln + 1     /* bump up line counter           */\n         iterate                   /* get next record                */\n       End   /* if add_data = '' */\n       count = count + 1           /* add one to line count          */\n   Signal on SYNTAX /* trap errors */\n/*****************************************************************/\n/*   Binary data                                                 */\n/*****************************************************************/\n   If Abbrev('BIN',type,1) <> 0 then do\n      add_data = C2d(add_data)\n      col_len = endcol - begcol + 1\n      max_sz = 256 ** col_len\n      if add_data > max_sz / 2 then add_data = 0 - ( max_sz - add_data )\n   End\n/*****************************************************************/\n/*   Packed decimal data                                         */\n/*****************************************************************/\n   If Abbrev('PACK',type,1) <> 0 then do\n      add_data = Strip(add_data)                   /* remove blanks  */\n      add_data = C2x(add_data)                     /* convert to hex */\n      len_add_data = Length(add_data)              /* length of data */\n      sign     = Substr(add_data,len_add_data,1)   /* sign portion   */\n      If Verify(sign,'CFD') <> 0 then do           /* valid sign?    */\n        warnmsg = \"'*** ERROR - NEXT LINE HAS BAD SIGN ***'\"\n        \"ISREDIT LINE_BEFORE\" firstln \"= NOTELINE \" warnmsg\n        zedsmsg = 'CAN''T ADD LINE' firstln\n        zedlmsg = 'ERROR - THE DATA TO ADD ON LINE' firstln 'IS NOT',\n                  'VALID PACKED DECIMAL - BAD SIGN.'\n        Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm   */\n        Exit 12\n      End  /* If Verify(sign */\n      add_data = Left(add_data,len_add_data-1)     /* remove sign    */\n      If sign = 'D' then add_data = '-' || add_data /* negative num  */\n   End /* If Abbrev('PACK' */\n /*****************************************************************/\n /*   Zoned decimal data                                          */\n /*****************************************************************/\n   If Abbrev('ZONE',type,1) <> 0 then do /* add zone dec. numbers   */\n      add_data = Strip(add_data)                   /* remove blanks  */\n      len_add_data = Length(add_data)              /* length of data */\n      zone     = Substr(add_data,len_add_data,1)   /* zone portion   */\n      add_data = Substr(add_data,1,len_add_data-1) /* non-zone part  */\n      If Datatype(add_data,N) <> 1 then ,          /* valid number?  */\n        call SYNTAX                        /* no, call error routine */\n      zonedtab = '0123456789ABCDEFGHIJKLMNOPQR{}'\n      If Verify(zone,zonedtab) <> 0 then do      /* valid zone?      */\n        warnmsg = \"'*** ERROR - NEXT LINE HAS BAD ZONE ***'\"\n        \"ISREDIT LINE_BEFORE\" firstln \"= NOTELINE \" warnmsg\n        zedsmsg = 'CAN''T ADD LINE' firstln\n        zedlmsg = 'ERROR - THE DATA TO ADD ON LINE' firstln 'IS NOT',\n                  'VALID ZONED DECIMAL - BAD ZONE.'\n        Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm   */\n        Exit 12\n      End  /* If Verify(zone */\n      outxtab   = '012345678912345678912345678900'\n      add_xzone = Translate(zone,outxtab,zonedtab)\n      If Verify(zone,'JKLMNOPQR}') <> 0 then ,\n        add_data  = add_data ||  add_xzone       /* concat zone      */\n      Else\n        add_data  = '-' || add_data || add_xzone /* concat zone (neg)*/\n   End  /* If Abbrev('ZONE' */\n/*****************************************************************/\n/*   Hexadecimal data                                            */\n/*****************************************************************/\n   If Abbrev('HEXADECIMAL',type,1) <> 0 | ,\n       type = 'X' then do\n      add_data = Translate(add_data,\"\",\"xX'\") /* remove hex notation */\n      add_data = Strip(add_data)              /* remove blanks       */\n      add_data = X2d(add_data)                /* translate to dec.   */\n   End\n /*****************************************************************/\n /*   Display data                                                */\n /*****************************************************************/\n   total = total + add_data             /* add to prev. total    */\n   End /* of chkexcl */\n   firstln = firstln + 1                /* bump up line counter  */\nEnd /* do until   */\n/*********************************************************************/\n/*   End column addition loop                                        */\n/*********************************************************************/\n   If not_counted = 0 then do /* all lines counted */\n     endmsg = 'ISRZ000'  /* message - no alarm     */\n     endrc  = 0          /* RC=0                   */\n   End\n   Else do               /* some lines not counted */\n     endmsg = 'ISRZ001'  /* message - with alarm   */\n     endrc  = 4          /* RC=4                   */\n   End\n   If Abbrev('HEXADECIMAL',type,1) <> 0 | type = 'X' then do\n      zedsmsg = \"Total = x'\"D2x(total)\"'\"\n      zedlmsg = \"Total = x'\"D2x(total)\"' (\"total\" decimal,\" ,\n                   \"Avg =\"  Format(total / count,,5) / 1 || \").\" ,\n                count \"lines were counted (\" || ,\n                not_counted \"not counted).\"\n      Address ISPEXEC \"SETMSG MSG(\"|| endmsg ||\")\"\n      Exit endrc\n   End /* If abbrev */\n   Else do\n      total   = total / 1   /* remove trailing zeros  */\n      zedsmsg = \"Total =\" total\n      If total >= 0 & total <  999999999999999 & ,\n         total=Trunc(total,0) then ,\n        zedlmsg = \"Total =\" total \"(x'\"D2x(total)\"' hex),\" ,\n                   \"Avg =\" Format(total / count,,5) / 1 || \".\" ,\n                   count \"lines were counted (\" || ,\n                   not_counted \"not counted).\"\n      Else ,\n        zedlmsg = \"Total =\" total \"(hex not available),\" ,\n                   \"Avg =\" Format(total / count,,5) / 1 || \".\" ,\n                   count \"lines were counted (\" || ,\n                   not_counted \"not counted).\"\n      Address ISPEXEC \"SETMSG MSG(\"|| endmsg ||\")\"\n      Exit endrc\n   End /* else do */\n/*********************************/\n/*  Sub-routine to find labels   */\n/*********************************/\nFIND_LABELS:\n   If label1 = '' then do\n     firstln  = 1\n     \"(lastln) = LINENUM .ZLAST\"\n   End\n   Else do\n      If label2 = '' then label2 = label1\n      firstsv = 'NOTFOUND'\n      lastsv  = 'NOTFOUND'\n      label1 = Translate(label1)\n      label2 = Translate(label2)\n      \"(saveln) = DISPLAY_LINES\"\n      \"UP MAX\"\n      Do forever\n        \"LOCATE LAB NEXT\"\n        if rc <> 0 then leave\n        \"(labline,junk) = DISPLAY_LINES\"\n        \"(lab,junk) = LABEL\" labline\n        if lab = label1 then firstsv = labline\n        if lab = label2 then lastsv  = labline\n      End  /* do forever */\n  /*                                             */\n  /* return display lines to original position   */\n  /*                                             */\n      \"UP MAX\"\n      If saveln <> 1 then \"DOWN \" saveln  /* don't scroll if at top */\n      If firstsv = 'NOTFOUND'  then do\n         zedsmsg = 'RANGE LABEL ERROR'\n         zedlmsg = 'THE SPECIFIED RANGE LABEL \"' || label1 '\" WAS',\n                   'NOT FOUND'\n         Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n         Exit 12\n      End\n      If lastsv  = 'NOTFOUND'  then do\n         zedsmsg = 'RANGE LABEL ERROR'\n         zedlmsg = 'THE SPECIFIED RANGE LABEL \"' || label2 '\" WAS',\n                   'NOT FOUND'\n         Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n         Exit 12\n      End\n      If firstsv > lastsv then do\n         firstln = lastsv\n         lastln  = firstsv\n      End\n      Else do\n         firstln = firstsv\n         lastln  = lastsv\n      End\n   End\n   Return\n/*********************************/\n/*  error sub-routine            */\n/*********************************/\nSYNTAX:\n   warnmsg = \"'*** ERROR - NEXT LINE HAS BAD DATA ***'\"\n   \"ISREDIT LINE_BEFORE\" firstln \"= NOTELINE \" warnmsg\n   zedsmsg = 'CAN''T ADD LINE' firstln\n   zedlmsg = 'ERROR - THE DATA TO ADD ON LINE' firstln 'IS NOT',\n             'VALID FOR THE ADDITION TYPE.'\n   Address ISPEXEC \"SETMSG MSG(ISRZ001)\"    /* msg - with alarm */\n   Exit 12\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ADDFLAG": {"ttr": 14345, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x003\\x003\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- ADD A STRING A COLUMN, RIGHT JUSTIFIED                 **/\n\n   ADDRESS ISREDIT\n   \"MACRO (FLAG ENDCOL) NOPROCESS\"\n   IF FLAG = \"\" THEN SIGNAL DISPDOC\n   \"PROCESS RANGE C\"\n   IF RC > 0 THEN DO\n         TOP = 1\n         \"(BOT) = LINENUM .ZLAST\"\n   END\n   ELSE DO\n         \"(TOP) = LINENUM .ZFRANGE\"\n         \"(BOT) = LINENUM .ZLRANGE\"\n   END\n   IF SUBSTR(FLAG,1,1) = \"'\" & SUBSTR(FLAG,LENGTH(FLAG),1) = \"'\",\n         | SUBSTR(FLAG,1,1) = '\"' & SUBSTR(FLAG,LENGTH(FLAG),1) = '\"',\n      THEN FLAG = SUBSTR(FLAG,2,LENGTH(FLAG)-2)\n   IF ENDCOL = \"\" THEN ENDCOL = 72\n   DO N = TOP TO BOT\n      \"(REC) = LINE\" N\n      REC = SUBSTR(REC,1,ENDCOL-LENGTH(FLAG)) || FLAG,\n         || SUBSTR(REC,ENDCOL+1)\n      \"LINE \" N \" = (REC)\"\n   END\n   \"LOCATE\" TOP\n   RETURN(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"ADDFLAG - ADD A FLAG TO CC'D LINES\"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    ADDFLAG  FLAG  ENDING-COLUMN\"\n   SAY\n   SAY \"       THE FLAG IS MANDATORY BUT THE ENDING COLUMN WILL   \"\n   SAY \"       DEFAULT TO 72.  A RANGE OF LINES MAY BE SPECIFIED  \"\n   SAY \"       BY C/CC/C## OR THE FLAG WILL BE APPLIED TO THE     \"\n   SAY \"       FILE. THE FLAG WILL BE RIGHT JUSTIFIED TO THE      \"\n   SAY \"       ENDING COLUMN, OVERLAYING ANY DATA THERE.          \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    ADDFLAG  '/* 990711 */'  61 \"\n   SAY\n   SAY \"       WILL PLACE /* 990711 */ IN COLUMNS 50 THROUGH 61   \"\n   SAY \"       OF EVERY COLUMN IN THE C/CC/C## RANGE OR THE ENTIRE\"\n   SAY \"       FILE IF NO RANGE IS SPECIFIED.                     \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ADDLINEA": {"ttr": 14347, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\x04\\x00\\x04\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- COPY DUMMY MEMBER FOR ADDLINES MACRO  **/\n   \"ISREDIT MACRO\"\n   \"ISREDIT COPY\" @#$@#$@# \"AFTER \" .ZLAST\n   \"ISREDIT END\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ADDLINEB": {"ttr": 14349, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\x04\\x00\\x04\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- COPY DUMMY MEMBER FOR ADDLINES MACRO  **/\n   \"ISREDIT MACRO\"\n   \"ISREDIT COPY\" @#$@#$@# \"BEFORE\" .ZFIRST\n   \"ISREDIT END\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ADDLINES": {"ttr": 14351, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00Z\\x00Z\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 90, "newlines": 90, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- COPY A PDS MEMBER BEFORE OR AFTER EVERY OTHER MEMBER  **/\n/*------------------------------------------------------------------*/\n   SAVEMSG=MSG()\n   X=MSG(\"OFF\")\n   ADDRESS 'ISPEXEC'\n   'ISREDIT MACRO (MEMBER,LOCATION,PREFIX)'\n   IF MEMBER = '' THEN SIGNAL DISPDOC\n   'ISREDIT (DATA1)   = DATAID '\n   'ISREDIT (THISONE) = MEMBER '\n   PARSE UPPER VAR LOCATION LOCATION .\n   PARSE UPPER VAR MEMBER   MEMBER   .\n   IF LOCATION = '' | (LOCATION <> 'BEFORE' & LOCATION <> 'AFTER'),\n      THEN DO\n         PREFIX   = LOCATION\n         LOCATION = 'BEFORE'\n      END\n   PARSE UPPER VAR PREFIX PREFIX .\n   IF LOCATION = 'BEFORE',\n      THEN DO\n         ADDRESS 'ISREDIT' '(LINECNT) = LINENUM' .ZLAST\n         ADDRESS 'ISREDIT' 'COPY' MEMBER 'BEFORE' .ZFIRST\n         ADDRESS 'ISREDIT' '(LINENEW) = LINENUM' .ZLAST\n         LINENEW = LINENEW - LINECNT\n         ADDRESS 'ISREDIT' 'CREATE @#$@#$@# 1' LINENEW\n         IF PREFIX = '' | SUBSTR(THISONE,1,LENGTH(PREFIX)) = PREFIX\n            THEN NOP\n            ELSE ADDRESS 'ISREDIT' 'DELETE 1' LINENEW\n      END\n      ELSE DO\n         ADDRESS 'ISREDIT' '(LINECNT) = LINENUM' .ZLAST\n         ADDRESS 'ISREDIT' 'COPY' MEMBER 'AFTER' .ZLAST\n         ADDRESS 'ISREDIT' '(LINENEW) = LINENUM' .ZLAST\n         LINECNT = LINECNT + 1\n         ADDRESS 'ISREDIT' ' CREATE @#$@#$@#' LINECNT LINENEW\n         IF PREFIX = '' | SUBSTR(THISONE,1,LENGTH(PREFIX)) = PREFIX\n            THEN NOP\n            ELSE ADDRESS 'ISREDIT' 'DELETE' LINECNT LINENEW\n      END\n   ADDRESS 'ISPEXEC' 'LMOPEN DATAID('DATA1') OPTION(INPUT)'\n   MEMBER1 = ''\n      DO UNTIL LMRC <> 0\n        ADDRESS 'ISPEXEC' 'LMMLIST DATAID('DATA1') OPTION(LIST)',\n                          'MEMBER(MEMBER1) STATS(YES)'\n        LMRC = RC\n     IF LMRC = 0              ,/* IF MEMBER NAME RETURNED           */\n       & MEMBER1 <> THISONE   ,/*    AND IT ISN'T THIS MEMBER       */\n       & MEMBER1 <> MEMBER    ,/*    AND IT ISN'T THE COPIED MEMBER */\n       & MEMBER1 <> '@#$@#$@#',/*    AND IT ISN'T THE DUMMY MEMBER  */\n       & (                    ,/*    AND PREFIX CHECK IS OK...      */\n           PREFIX = ''        ,/*       AND NO PREFIX SPECIFIED     */\n            | SUBSTR(MEMBER1,1,LENGTH(PREFIX))=PREFIX,/* | PREF MTCH*/\n         ) THEN DO            /*  INVOKE EDIT WITH LOCATION MACRO   */\n         ADDRESS 'ISPEXEC' 'CONTROL ERRORS CANCEL'\n         IF LOCATION = 'BEFORE',\n            THEN DO\n               ADDRESS 'ISPEXEC' 'EDIT DATAID('DATA1')',\n                       'MEMBER('MEMBER1') MACRO(ADDLINEB)'\n            END\n            ELSE DO\n               ADDRESS 'ISPEXEC' 'EDIT DATAID('DATA1')',\n                       'MEMBER('MEMBER1') MACRO(ADDLINEA)'\n            END\n         ADDRESS 'ISPEXEC' 'CONTROL ERRORS CANCEL'\n       END\n   END\n   ADDRESS 'ISPEXEC' 'LMMLIST DATAID('DATA1') OPTION(FREE)'\n   ADDRESS 'ISPEXEC' 'LMCLOSE DATAID('DATA1')'\n   ADDRESS 'ISREDIT' '(DATASET) = DATASET'\n   ADDRESS \"TSO\"     \"DELETE '\"DATASET\"(@#$@#$@#)'\"\n   EXIT\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"ADDLINES - ADD A MEMBER TO ALL OTHER MEMBERS                \"\n   SAY\n   SAY \"    ADDLINES  MEMBER  ( LOCATION )  ( PREFIX )              \"\n   SAY\n   SAY \"       MEMBER IS THE NAME OF THE MEMBER TO BE COPIED INTO   \"\n   SAY \"              THE OTHER MEMBERS.                            \"\n   SAY\n   SAY \"       LOCATION IS EITHER 'BEFORE' OR 'AFTER', INDICATING   \"\n   SAY \"              WHETHER THE COPIED DATA WILL BE INSERTED      \"\n   SAY \"              BEFORE THE MEMBER DATA OR APPENDED AT THE     \"\n   SAY \"              END. 'BEFORE' IS THE DEFAULT.                 \"\n   SAY\n   SAY \"       PREFIX IS AN OPTIONAL PREFIX TO USE WHEN SELECTING   \"\n   SAY \"              MEMBERS TO PROCESS.  FOR EXAMPLE, XX1 WILL    \"\n   SAY \"              PROCESS ONLY THOSE MEMBERS BEGINNING W/ XX1.  \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ALIGN": {"ttr": 14354, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x03'\\x1f\\x01\\x03'\\x1f\\x12\\x00\\x00C\\x00C\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-09-28T00:00:00", "modifydate": "2003-09-28T12:00:00", "lines": 67, "newlines": 67, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- ALIGN COLUMNS BASED ON ONE OR MORE CHARACTERS          **/\n\n   ADDRESS ISREDIT\n   \"MACRO (PARM) NOPROCESS\"\n   IF PARM = \"\" | PARM = \"?\" THEN SIGNAL DISPDOC\n   \"PROCESS RANGE C\"\n   IF RC > 0 THEN DO\n      TOP = 1\n      \"(BOT) = LINENUM .ZLAST\"\n   END\n   ELSE DO\n      \"(TOP) = LINENUM .ZFRANGE\"\n      \"(BOT) = LINENUM .ZLRANGE\"\n   END\n   IF SUBSTR(PARM,1,1) = '\"' | SUBSTR(PARM,1,1) = \"'\",\n      THEN PARM = TRANSLATE(SUBSTR(PARM,2,LENGTH(PARM)-2))\n      ELSE PARM = TRANSLATE(PARM)\n\n   OFFSET = 0\n   DO NN = TOP TO BOT\n      \"(REC) = LINE\" NN\n      II = POS(PARM,REC)\n      IF II > OFFSET & SUBSTR(REC,7,1) <> \"*\",\n            & SUBSTR(REC,7,1) <> \"/\",\n            & SUBSTR(REC,7,1) <> \"D\",\n         THEN OFFSET = II\n   END NN\n\n   DO NN = TOP TO BOT\n      \"(REC) = LINE\" NN\n      II = POS(PARM,REC)\n      IF II > 0 & SUBSTR(REC,7,1) <> \"*\",\n            & SUBSTR(REC,7,1) <> \"/\",\n            & SUBSTR(REC,7,1) <> \"D\" THEN DO\n         REC = SUBSTR(REC,1,II-1) || COPIES(\" \",OFFSET-II),\n            || PARM || SUBSTR(REC,II+LENGTH(PARM))\n         \"LINE \" NN \" = (REC)\"\n      END\n   END NN\n\n   \"LOCATE\" TOP\n   RETURN(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"ALIGN - ALIGN COLUMNS                                     \"\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    ALIGN  CHAR                                           \"\n   SAY \"       WILL ALIGN THE SPECIFIED LINES AT THE CHARACTER    \"\n   SAY \"       OR CHARACTERS PROVIDED.  A RANGE OF LINES MAY BE   \"\n   SAY \"       SPECIFIED BY C/CC/C## OR THE ENTIRE FILE WILL BE   \"\n   SAY \"       PROCESSED.  NO CHAR SPECIFIED OR ONLY A ? WILL     \"\n   SAY \"       CAUSE THIS HELP TO BE SHOWN. QUOTES MAY BE USED.   \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY \"    ALIGN  ' TO '                                         \"\n   SAY \"       ON THE FOLLOWING:                                  \"\n   SAY \"          MOVE 7 TO WS-SHORT-FIELD                        \"\n   SAY \"          MOVE     16    TO WS-MIDDLE-FIELD               \"\n   SAY \"          MOVE     427 TO WS-REAL-BIG-FIELD               \"\n   SAY \"       WILL ALIGN AS:                                     \"\n   SAY \"          MOVE 7         TO  WS-SHORT-FIELD               \"\n   SAY \"          MOVE     16    TO  WS-MIDDLE-FIELD              \"\n   SAY \"          MOVE     427   TO  WS-REAL-BIG-FIELD            \"\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ALIGNALL": {"ttr": 14593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00S\\x00S\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 83, "newlines": 83, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- ALIGN ALL COLUMNS BASED ON SPECIFIED DELIMITER         **/\n\n   ADDRESS ISREDIT\n   \"MACRO (PARM) NOPROCESS\"\n   IF PARM = \"\" THEN SIGNAL DISPDOC\n   \"PROCESS RANGE C\"\n   IF RC > 0 THEN DO\n      TOP = 1\n      \"(BOT) = LINENUM .ZLAST\"\n   END\n   ELSE DO\n      \"(TOP) = LINENUM .ZFRANGE\"\n      \"(BOT) = LINENUM .ZLRANGE\"\n   END\n   IF SUBSTR(PARM,1,1) = '\"' | SUBSTR(PARM,1,1) = \"'\",\n      THEN PARM = TRANSLATE(SUBSTR(PARM,2,LENGTH(PARM)-2))\n      ELSE PARM = TRANSLATE(PARM)\n\n   OFFSET. = 0\n   DO NN = TOP TO BOT\n      \"(REC) = LINE\" NN\n      FF = 1\n      OO = 0\n      OX = 1\n      DO WHILE(OX < LENGTH(REC))\n         DO OX = (OO+1) TO LENGTH(REC) BY 1,\n            WHILE( ( OX < LENGTH(REC) ),\n               & ( SUBSTR(REC,OX,LENGTH(PARM)) <> PARM ) )\n         END OX\n         IF OX <= LENGTH(REC) THEN DO\n            IF (OX-OO-1) > OFFSET.FF THEN OFFSET.FF = (OX-OO-1)\n            OO = OX\n            FF = FF + 1\n         END\n      END\n   END NN\n\n   DO NN = TOP TO BOT\n      \"(REC) = LINE\" NN\n      FF = 1\n      OO = 0\n      OX = 1\n      DO WHILE ( OX < LENGTH(REC) & OFFSET.FF <> 0 )\n         DO OX = (OO+1) TO LENGTH(REC),\n            WHILE( (OX < LENGTH(REC) ),\n               & ( SUBSTR(REC,OX,LENGTH(PARM)) <> PARM ) )\n         END OX\n         LL = OFFSET.FF\n         REC = SUBSTR(REC,1,OX-1) || COPIES(\" \",LL-(OX-OO-1)),\n            || PARM || SUBSTR(REC,OX+1)\n         OO = OX + LL - ( OX - OO - 1 )\n         FF = FF + 1\n      END\n      \"LINE \" NN \" = (REC)\"\n   END NN\n\n   \"LOCATE\" TOP\n   RETURN(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"ALIGNALL -- ALIGN ALL COLUMNS BASED ON DELIMITER          \"\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    ALIGNALL  CHAR                                        \"\n   SAY \"       WILL ALIGN THE SPECIFIED LINES AT THE CHARACTER    \"\n   SAY \"       OR CHARACTERS PROVIDED.  A RANGE OF LINES MAY BE   \"\n   SAY \"       SPECIFIED BY C/CC/C## OR THE ENTIRE FILE WILL BE   \"\n   SAY \"       PROCESSED.  NO CHAR SPECIFIED WILL CAUSE THIS      \"\n   SAY \"       HELP TO BE SHOWN. QUOTES MAY BE USED.              \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY \"    ALIGNALL  !                                           \"\n   SAY \"       ON THE FOLLOWING:                                  \"\n   SAY \"          111!111111111!1                                 \"\n   SAY \"          2!2!                                            \"\n   SAY \"          33333!33333!55555                               \"\n   SAY \"       WILL ALIGN AS:                                     \"\n   SAY \"          111  !111111111!1                               \"\n   SAY \"          2    !2        !2                               \"\n   SAY \"          33333!33333    !33333                           \"\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ALIGNAX": {"ttr": 14596, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00[\\x00[\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 91, "newlines": 91, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- ALIGN ALL COLUMNS BASED ON DELIMITER & REMOVE SAME     **/\n\n   ADDRESS ISREDIT\n   \"MACRO (PARM) NOPROCESS\"\n   IF PARM = \"\" THEN SIGNAL DISPDOC\n   \"PROCESS RANGE C\"\n   IF RC > 0 THEN DO\n      TOP = 1\n      \"(BOT) = LINENUM .ZLAST\"\n   END\n   ELSE DO\n      \"(TOP) = LINENUM .ZFRANGE\"\n      \"(BOT) = LINENUM .ZLRANGE\"\n   END\n   IF SUBSTR(PARM,1,1) = '\"' | SUBSTR(PARM,1,1) = \"'\",\n      THEN PARM = TRANSLATE(SUBSTR(PARM,2,LENGTH(PARM)-2))\n      ELSE PARM = TRANSLATE(PARM)\n\n   OFFSET. = -1\n   DO NN = TOP TO BOT\n      \"(REC) = LINE\" NN\n      FF = 1\n      OO = 0\n      OX = 1\n      DO WHILE(OX < LENGTH(REC))\n         DO OX = (OO+1) TO LENGTH(REC) BY 1,\n            WHILE( ( OX < LENGTH(REC) ),\n               & ( SUBSTR(REC,OX,LENGTH(PARM)) <> PARM ) )\n         END OX\n         IF OX <= LENGTH(REC) THEN DO\n            IF (OX-OO-1) > OFFSET.FF THEN OFFSET.FF = (OX-OO-1)\n            OO = OX\n            FF = FF + 1\n         END\n      END\n   END NN\n\n   DO NN = TOP TO BOT\n      \"(REC) = LINE\" NN\n      FF = 1\n      OO = 0\n      OX = 1\n      DO WHILE ( OX < LENGTH(REC) & OFFSET.FF <> -1 )\n         DO OX = (OO+1) TO LENGTH(REC),\n            WHILE( (OX < LENGTH(REC) ),\n               & ( SUBSTR(REC,OX,LENGTH(PARM)) <> PARM ) )\n         END OX\n         LL = OFFSET.FF\n         REC = SUBSTR(REC,1,OX-1) || COPIES(\" \",LL-(OX-OO-1)),\n            || PARM || SUBSTR(REC,OX+1)\n         OO = OX + LL - ( OX - OO - 1 )\n         FF = FF + 1\n      END\n      LL = 1\n      RECX = \"\"\n      DO XX = 1 TO 32760 WHILE ( OFFSET.XX <> -1 )\n         MM   = OFFSET.XX\n         RECX = RECX || SUBSTR(REC,LL,MM)\n         LL   = LL + 1 + OFFSET.XX\n      END XX\n      \"LINE \" NN \" = (RECX)\"\n   END NN\n\n   \"LOCATE\" TOP\n   RETURN(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"ALIGNAX -- ALIGN ALL COLUMNS BASED ON DELIMITER           \"\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    ALIGNAX   CHAR                                        \"\n   SAY \"       WILL ALIGN THE SPECIFIED LINES AT THE CHARACTER    \"\n   SAY \"       OR CHARACTERS PROVIDED.  A RANGE OF LINES MAY BE   \"\n   SAY \"       SPECIFIED BY C/CC/C## OR THE ENTIRE FILE WILL BE   \"\n   SAY \"       PROCESSED.  NO CHAR SPECIFIED WILL CAUSE THIS      \"\n   SAY \"       HELP TO BE SHOWN. QUOTES MAY BE USED. THE DELIMITER\"\n   SAY \"       WILL BE REMOVED.                                   \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY \"    ALIGNAX  !                                            \"\n   SAY \"       ON THE FOLLOWING:                                  \"\n   SAY \"          111!111111111!1                                 \"\n   SAY \"          2!2!                                            \"\n   SAY \"          33333!33333!55555                               \"\n   SAY \"       WILL ALIGN AS:                                     \"\n   SAY \"          111  !111111111!1                               \"\n   SAY \"          2    !2        !2                               \"\n   SAY \"          33333!33333    !33333                           \"\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ALIGNS": {"ttr": 14599, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x03'\\x1f\\x01\\x03'\\x1f\\x12\\x00\\x00X\\x00X\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-09-28T00:00:00", "modifydate": "2003-09-28T12:00:00", "lines": 88, "newlines": 88, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- ALIGN COLUMNS BASED ON ONE OR MORE CHARACTERS          **/\n\n   ADDRESS ISREDIT\n   \"MACRO (PARM) NOPROCESS\"\n   IF PARM = \"\" | PARM = \"?\" THEN SIGNAL DISPDOC\n   \"PROCESS RANGE C\"\n   IF RC > 0 THEN DO\n      TOP = 1\n      \"(BOT) = LINENUM .ZLAST\"\n   END\n   ELSE DO\n      \"(TOP) = LINENUM .ZFRANGE\"\n      \"(BOT) = LINENUM .ZLRANGE\"\n   END\n   IF SUBSTR(PARM,1,1) = '\"' | SUBSTR(PARM,1,1) = \"'\",\n      THEN PARM = TRANSLATE(SUBSTR(PARM,2,LENGTH(PARM)-2))\n      ELSE PARM = TRANSLATE(PARM)\n\n   OFFSET     = 0\n   DO NN = TOP TO BOT\n      \"(REC) = LINE\" NN\n      II = POS(PARM,REC)\n      IF II > OFFSET & SUBSTR(REC,7,1) <> \"*\",\n            & SUBSTR(REC,7,1) <> \"/\",\n            & SUBSTR(REC,7,1) <> \"D\",\n         THEN OFFSET = II\n   END NN\n\n   NEG_OFFSET = 99999\n   DO NN = TOP TO BOT\n      \"(REC) = LINE\" NN\n      II = POS(PARM,REC)\n      IF II > 0 & SUBSTR(REC,7,1) <> \"*\",\n            & SUBSTR(REC,7,1) <> \"/\",\n            & SUBSTR(REC,7,1) <> \"D\" THEN DO\n         REC = SUBSTR(REC,1,II-1) || COPIES(\" \",OFFSET-II),\n            || PARM || SUBSTR(REC,II+LENGTH(PARM))\n         \"LINE \" NN \" = (REC)\"\n         II = POS(PARM,REC)\n         DO JJ = (II-1) TO 1 BY -1 WHILE(SUBSTR(REC,JJ,1) = \" \")\n         END JJ\n         IF NEG_OFFSET > (II-JJ-1) THEN NEG_OFFSET = (II-JJ-1)\n      END\n   END NN\n\n   DO II = 1 TO LENGTH(PARM) WHILE(SUBSTR(PARM,II,1) = \" \")\n   END II\n   IF II > 1 THEN NEG_OFFSET = NEG_OFFSET + II - 1\n\n   IF NEG_OFFSET > 0 THEN NEG_OFFSET = NEG_OFFSET - 1\n   DO NN = TOP TO BOT\n      \"(REC) = LINE\" NN\n      II = POS(PARM,REC)\n      IF II > 0 & SUBSTR(REC,7,1) <> \"*\",\n            & SUBSTR(REC,7,1) <> \"/\",\n            & SUBSTR(REC,7,1) <> \"D\" THEN DO\n         REC = SUBSTR(REC,1,II-1-NEG_OFFSET) || SUBSTR(REC,II)\n         \"LINE \" NN \" = (REC)\"\n      END\n   END NN\n\n   \"LOCATE\" TOP\n   RETURN(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"ALIGNS - ALIGN COLUMNS                                    \"\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    ALIGNS  CHAR                                          \"\n   SAY \"       WILL ALIGN THE SPECIFIED LINES AT THE CHARACTER    \"\n   SAY \"       OR CHARACTERS PROVIDED.  A RANGE OF LINES MAY BE   \"\n   SAY \"       SPECIFIED BY C/CC/C## OR THE ENTIRE FILE WILL BE   \"\n   SAY \"       PROCESSED.  NO CHAR SPECIFIED OR ONLY A ? WILL     \"\n   SAY \"       CAUSE THIS HELP TO BE SHOWN. QUOTES MAY BE USED.   \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY \"    ALIGNS  ' TO '                                        \"\n   SAY \"       ON THE FOLLOWING:                                  \"\n   SAY \"          MOVE 7 TO WS-SHORT-FIELD                        \"\n   SAY \"          MOVE     16    TO WS-MIDDLE-FIELD               \"\n   SAY \"          MOVE     427 TO WS-REAL-BIG-FIELD               \"\n   SAY \"       WILL ALIGN AS:                                     \"\n   SAY \"          MOVE 7       TO  WS-SHORT-FIELD                 \"\n   SAY \"          MOVE     16  TO  WS-MIDDLE-FIELD                \"\n   SAY \"          MOVE     427 TO  WS-REAL-BIG-FIELD              \"\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ALLMEM": {"ttr": 14602, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x007\\x007\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- Invoke a macro against all members in the PDS being   **/\n/*       edited; Edit the first member, then invoke ALLMEM          */\n/*------------------------------------------------------------------*/\n   Address 'ISPEXEC'\n   'ISREDIT MACRO (WORKMAC,PREFIX)'\n   If WORKMAC = '' then signal DispDoc\n   'ISREDIT (DATA1)   = DATAID'\n   'ISREDIT (THISONE) = MEMBER '\n   Address 'ISPEXEC' 'LMOPEN DATAID('data1') OPTION(INPUT)'\n   parse upper var prefix prefix .\n   member1 = ''\n   Do Until lmrc \\= 0\n      Address 'ISPEXEC' 'LMMLIST DATAID('data1') OPTION(LIST)',\n                        'MEMBER(MEMBER1) STATS(YES)'\n      lmrc = rc\n      If lmrc = 0              ,/* If member name returned          */\n        & member1 \\= thisone   ,/* and it isn't this member         */\n        & (                    ,/* and prefix check is ok...        */\n            prefix = ''        ,/*    No prefix specified           */\n            | substr(member1,1,length(prefix))=prefix,/* | pref mtch*/\n          ) Then Do      /* Invoke edit with specified initial macro*/\n           Address 'ISPEXEC' 'CONTROL ERRORS CANCEL'\n           Address 'ISPEXEC' 'EDIT DATAID('data1')',\n                   'MEMBER('member1') MACRO('workmac')'\n           Address 'ISPEXEC' 'CONTROL ERRORS CANCEL'\n        End\n   End\n   Address 'ISPEXEC' 'LMMLIST DATAID('data1') OPTION(FREE)'\n   Address 'ISPEXEC' 'LMCLOSE DATAID('data1')'\n   'ISREDIT DEFINE 'workmac' MACRO CMD'\n   If prefix=''                              ,/* No prefix specified */\n      | substr(thisone,1,length(prefix))=prefix ,/* or prefix match  */\n     then 'ISREDIT 'workmac        /* perform macro for this member  */\n   Exit(0)\n\nDispDoc:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"ALLMEM -- Execute macro against all members of a PDS        \"\n   SAY\n   SAY \"    ALLMEM Macro Prefix                                     \"\n   SAY\n   SAY \"       Macro is the name of a macro to execute.  If it      \"\n   SAY \"             is a program macro, remember to specify the    \"\n   SAY \"             exclamation point before the name.             \"\n   SAY\n   SAY \"       Prefix is an optional prefix to use when selecting   \"\n   SAY \"              members to process.  for example, Y2K will    \"\n   SAY \"              process all members starting with Y2K.        \"\n   SAY\n   SAY \" Edit any member of the PDS and invoke this macro. Note     \"\n   SAY \" that the macro which this calls can have an ISREDIT END or \"\n   SAY \" ISREDIT CANCEL in it to avoid the display. See the sample  \"\n   SAY \" ALLMEMC and ALLMEMF macros.                                \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ALLMEMC": {"ttr": 14604, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x0c\\x00\\x0c\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "REXX"}, "text": "/*** REXX  --  MAKE CODE ANONYMOUS  ***/\n   \"ISREDIT MACRO\"\n   \"ISREDIT C '-YOUR-LOADLIB-'         '-YOUR-LOADLIB-'    ALL\"\n   \"ISREDIT C '-YOUR-SYSLIB-'          '-YOUR-SYSLIB-'     ALL\"\n   \"ISREDIT C '-YOUR-ACCT-INFO-'       '-YOUR-ACCT-INFO-'  ALL\"\n   \"ISREDIT C '-YOUR-USERID-'          '-YOUR-USERID-'     ALL\"\n   \"ISREDIT C '-YOUR-NAME-'            '-YOUR-NAME-'       ALL\"\n   \"ISREDIT C '-YOUR-SCEELLED-'        '-YOUR-SCEELLED-'   ALL\"\n   \"ISREDIT C 'CLASS=2'                'CLASS=2'           ALL\"\n   \"ISREDIT C 'MSGCLASS=X'             'MSGCLASS=X'        ALL\"\n   \"ISREDIT C '-YOUR-PLI-LIB-'         '-YOUR-PLI-LIB-'    ALL\"\n   \"ISREDIT END\"\n", "mimetype": "text/x-diff", "datatype": "ebcdic", "extension": ".diff"}, "ALLMEMF": {"ttr": 14606, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x04\\x00\\x04\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "REXX"}, "text": "/*** REXX  --  FIND SOME STRING  --  USE WITH ALLMEM  ***/\n   \"ISREDIT MACRO\"\n   \"ISREDIT SEEK  'SYS1.REXX.'    \"\n   IF RC <> 0 THEN \"ISREDIT END\"\n", "mimetype": "text/x-diff", "datatype": "ebcdic", "extension": ".diff"}, "ALLOC": {"ttr": 14608, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x01$\\x01$\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 292, "newlines": 292, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&NAME    ALLOC &DUMMY,&PERM,&DSN=,&DDN=,&DDNRET=,&MEMBER=,&DISP=,      X\n               &VOL=,&UNIT=,&SYSOUT=,&FREE=,&COPIES=,&LABEL=,&FCB=,    X\n               &BLKSIZE=,&DEN=,&DSORG=,&KEYLEN=,&LRECL=,&RECFM=,       X\n               &PASWORD=,&DSNRET=,&MF=AUTO,&PREFIX=,&ERROR=,&CHARS=,   X\n               &SPACE=,&F=,&FILE=,&DA=,&QNAME=,&DSORGRT=,&UCS=,        X\n               &BUFNO=,&VOLRET=,&DCBDSN=,&DCBDDN=,&SPECIAL=,&DDNTO=,   X\n               &FLASH=,&FORMS=,&DEST=,&FORUSER=,&TU=,&DSNPDE=,&BURST=, X\n               &SUBSYS=,&SUBDDN=,&BUFND=,&BUFNI=,&HBUFND=,&HBUFNI=,    X\n               &DEFERW=,&SHRPOOL=,&BUFSD=,&BUFSI=,&MSG=,&OUTPUT=,      X\n               &PAGEDEF=,&FORMDEF=,&PRMODE=,&TRC=,&OUTDEL=,            X\n               &DEFAULT=YES,&STCL=\n.*********************************************************************\n.*\n.*    THIS MACRO PROVIDES A DYNAMIC ALLOCATION FUNCTION BY BUILDING\n.*    A DYNAMIC ALLOCATION PARAMETER LIST AND INVOKING SVC 99.\n.*    IT FIRST SETS UP A WORKAREA ENVIRONMENT FOR THE PARAMETER LIST\n.*    AND THEN TESTS THE KEYWORDS SUPPLIED AND INVOKES INNER MACROS\n.*    TO BUILD THE TEXT UNITS. THE INNER MACROS THEMSELVES USE INNER\n.*    MACROS TO UPDATE GLOBAL VARIABLES, STORE TEXT UNIT POINTERS ETC\n.*\n.*    DYNAMIC ALLOCATION FUNCTIONS ARE SIMILAR TO THOSE AVAILABLE\n.*    WITH JCL, USING THE SAME KEYWORDS. HOWEVER, CERTAIN FORMATS\n.*    ARE SLIGHTLY DIFFERENT. FOR INSTANCE, CERTAIN KEYWORDS CAN\n.*    HAVE VARYING PARAMETERS, EG DATASET NAME, DDNAME, VOLSER ETC.\n.*    PROVISION IS MADE FOR BOTH VARIABLE SPECIFICATION.\n.*    IN THE ABSOLUTE FORM, THE PARAMETER IS ENTERED IN QUOTES, E.G.\n.*           ALLOC DSN='SYS1.LINKLIB',DISP=SHR\n.*    HOWEVER, THIS NAME REMAINS FIXED FOR THE ASSEMBLY.  WHILE\n.*    IN THE VARIABLE FORMAT, THE ADDRESS OF A LOCATOR IS SPECIFIED,\n.*    WHERE THE LOCATOR CONSISTS OF A SIX BYTE FIELD, THE FIRST 4\n.*    BYTES OF WHICH POINT TO THE PARAMETER, WHILE THE NEXT TWO\n.*    CONTAIN THE LENGTH, E.G.\n.*                ALLOC DSN=LOCATOR\n.*       LOCATOR  DC    A(DSN),Y(12)\n.*       DSN      DC    C'SYS1.LINKLIB'\n.*\n.*    NUMERIC QUANTITIES E.G. COPIES= FOR SYSOUT, SHOULD EITHER\n.*    SPECIFY A NUMERIC VALUE, COPIES=3, A VALUE IN A REGISTER,\n.*    COPIES=(R2), OR THE NAME OF A FULLWORD CONTAINING THE\n.*    VALUE, EG COPIES=NUMCOPYS, WHERE NUMCOPYS IS THE NAME OF A\n.*    FULLWORD FIELD.\n.*\n.*    OTHER KEYWORDS SUCH AS DISP= CAN ONLY HAVE THE ABSOLUTE\n.*    FORM, AND VALUES SHOULD NOT BE ENTERED WITHIN QUOTES.\n.*    ADDITIONAL FACILITIES NOT AVAILABLE WITH JCL ARE THE\n.*    RETURN BY THE SYSTEM OF INFORMATION ON THE DATASET, EG\n.*    DSORG. THIS IS DONE BY SPECIFYING DSORGRT=SYMBOL, WHERE\n.*    SYMBOL IS A SYMBOL WHICH WILL BE EQUATED TO A TWO BYTE\n.*    FIELD CONTAINING THE DSORG TYPE.\n.*\n.*    THE SYSTEM CAN ALSO GENERATE AND RETURN A DDNAME. THIS IS\n.*    CARRIED OUT BY ENTERING DDNTO=(ADDR1,ADDR2,,...) WHERE\n.*    ADR1,ADDR2 ETC ARE THE NAMES OF 8 BYTE FIELDS WHICH ARE TO\n.*    RECEIVE THE DDNAME.\n.*\n.********************************************************************\n         GBLA  &RCPDYN            COUNTER FOR NO ENTRIES TO MACRO\n         GBLA  &DTUO              OFFSET TO TEXT UNITS\n         GBLA  &DTUPO             OFFSET TO TEXT UNIT POINTERS\n         GBLA  &ODTUO             OFFSET TO OUTPUT TEXT UNITS\n         GBLA  &ODTUPO            OFFSET TO OUTPUT TEXT UNIT POINTERS\n         GBLB  &RCPS99(2)         TELL RCPDSECT NEED DSECTS\n         GBLC  &DYNP              PREFIX FOR LABELS FOR THIS CALL\n         GBLC  &DYNSP             NAME FOR AUTOMATIC STORAGE ALLOC\n         LCLA  &DDNRTO,&DSNRTO         FOR EQUATES FOR RETURNED FLDS\n         LCLA  &VOLRTO,&DSRGRTO        FOR EQUATES FOR RETURNED FIELDS\n         LCLA  &I                 COUNTER\n         LCLB  &DSECT             DSECT NEEDED FOR STORAGE, MF=E\n         LCLC  &C,&T,&PAR\n.*\n&RCPS99(1)     SETB           1\n&RCPDYN  SETA  &RCPDYN+1          INCEREMENT COUNTER\n&DYNP    SETC  'DYN&RCPDYN' SET DEFAULT PREFIX\n&NAME    DS    0H\n         AIF   ('&PREFIX' EQ '').TMF\n         AIF   (K'&PREFIX LT 4).POK\n         MNOTE 4,'PREFIX TOO LONG, 1ST 4 CHARS USED'\n&DYNP    SETC  '&PREFIX'(1,4)\n         AGO   .TMF\n.POK     ANOP\n&DYNP    SETC  '&PREFIX'\n.TMF     AIF   ('&MF' NE 'AUTO').TMFE\nNAME     DYNSPACE             GET NAME FOR SPACE\n         LA    R1,&DYNSP      LOAD ADDRESS OF PARAM LIST\n         USING &DYNP.DS,R1    USE GENERATED DSECT\n         LA    R3,O&DYNSP     LOAD ADDRESS OF OUTPUT TU AREA\n&T       SETC  'A'\n&PAR     SETC  '&DYNSP+4'\n&OPAR    SETC  'O&DYNSP+4'\n&DSECT   SETB  1\n         AGO   .START\n.TMFE    AIF   ('&MF' EQ 'E').E2OK\n         MNOTE 8,'INVALID MF= PARM'\n         AGO   .GEN\n.E2OK    ANOP\n&DSECT   SETB  1\n         AIF   ('&MF(2)' EQ '(').RMFE\n         LA    R1,&MF(2)               LOAD PARAM LIST ADDRESS\n         USING &DYNP.DS,R1             USE GENERATED DSECT\n         AGO   .START\n.RMFE    AIF   ('&MF(2)' EQ '(R1)' OR '&MF(2)' EQ '(1)').START\n         LR    R1,&PAR                 LOAD S99 PARAM LIST ADDRESS\n         AGO   .START\n.GEN     LA    R1,&DYNP.RBP            LOAD ADDRESS OF S99 RBP\n.START   LA    R15,&DYNP.RB            LOAD ADDRESS OF S99 RB\n         USING S99RB,R15\n         ST    R15,0(R1)               AND STORE IN RB POINTER\n         XC    &DYNP.RB(20),&DYNP.RB   ZERO REQUEST BLOCK\n         XC    &DYNP.TUP,&DYNP.TUP     ZERO TEXT UNIT POINTERS\n         XC    &DYNP.TU,&DYNP.TU       ZERO TEXT UNITS\n         MVI   S99RBLN,20              MOVE IN LIST LENGTH\n         MVI   S99VERB,S99VRBAL        MOVE IN VERB CODE\n         LA    R14,&DYNP.TUP           LOAD ADDRESS OF TU POINTERS\n         ST    R14,S99TXTPP            STORE ADDRESS IN S99 RB\n         LA    R15,&DYNP.TU            POINT TO SPACE FOR TEXT UNITS\n         USING S99TUNIT,R15\n&DTUO    SETA  0\n&DTUPO   SETA  0\n&ODTUO   SETA  0\n&ODTUPO  SETA  0\n.TDSN    AIF   ('&DSN&DA' NE '').DSN\n         AIF   ('&DSNPDE' NE '').DSNPDE\n         AIF   ('&DSNRET' NE '').DSNRT\n         AIF   ('&SYSOUT' NE '').SYSOUT\n         AIF   ('&DUMMY' NE '').DUMMY\n         AIF   ('&QNAME' NE '').QNAME\n.TDDN    AIF   ('&DDN&FILE&F' NE '').DDN\n         AIF   ('&DDNRET&DDNTO' NE '').DDNRT\n.TUNIT   AIF   ('&UNIT&VOL' NE '').UNIT\n.TVOLRET AIF   ('&VOLRET' NE '').VOLRET\n.TDSRGO  AIF   ('&DSORGRT' NE '').DSORGRT\n.TLABEL  AIF   ('&LABEL' NE '').LABEL1\n.TPSWD   AIF   ('&PASWORD' NE '').PASWORD\n.TFORUSE AIF   ('&FORUSER' NE '').FORUSER\n.TTU     AIF   ('&TU' NE '').TU\n.TDISP   AIF   ('&DISP' NE '').DISP\n.TSPACE  AIF   ('&SPACE' NE '').SPACE\n.TSTCL   AIF   ('&STCL' NE '').STCL\n.TLRECL  AIF   ('&LRECL' NE '').DCB\n         AIF   ('&DEN' NE '').DCB\n         AIF   ('&RECFM' NE '').DCB\n         AIF   ('&BUFNO' NE '').DCB\n         AIF   ('&BLKSIZE' NE '').DCB\n         AIF   ('&DSORG' NE '').DCB\n         AIF   ('&KEYLEN' NE '').DCB\n.TDCBDSN AIF   ('&DCBDSN' NE '').DCBDSN\n.TDCBDDN AIF   ('&DCBDDN' NE '').DCBDDN\n.TFREE   AIF   ('&FREE' EQ 'CLOSE').FREE\n.TPERM   AIF   ('&PERM' EQ 'PERM' OR '&PERM' EQ 'PERMANENT').PERM\n         AIF   ('&DUMMY' EQ 'PERM' OR '&DUMMY' EQ 'PERMANENT').PERM\n.TSPECI  AIF   ('&SPECIAL' NE '').SPECIAL\n.TOUTA   AIF   ('&OUTPUT' NE '').OUTA\n         AGO   .SVC99\n.DSN     RCPDSN &DSN&DA,&MEMBER\n         AIF   ('&SUBSYS' NE '').SUBSYS\n         AGO   .TDDN\n.DSNPDE  RCPDSNPD &DSNPDE\n         AGO   .TDDN\n.DSNRT   RCPDSNRT &DSNRET\n&DSNRTO  SETA  &DTUO-46\n         AGO   .TDDN\n.SUBSYS  RCPSUBSY SUBSYS=&SUBSYS,SUBDDN=&SUBDDN,BUFND=&BUFND,          X\n               BUFNI=&BUFNI,HBUFND=&HBUFND,HBUFNI=&HBUFNI,             X\n               DEFERW=&DEFERW,SHRPOOL=&SHRPOOL,BUFSD=&BUFSD,           X\n               BUFSI=&BUFSI,MSG=&MSG\n         AGO   .TDDN\n.SYSOUT  RCPSYSOU &SYSOUT,COPIES=&COPIES,FREE=&FREE,DEST=&DEST,        X\n               FORMS=&FORMS,UCS=&UCS,FCB=&FCB,CHARS=&CHARS,            X\n               BURST=&BURST,FLASH=&FLASH,OUTPUT=&OUTPUT\n         AGO   .TDDN\n.DUMMY   RCPDUMMY &DUMMY\n         AGO   .TDDN\n.QNAME   RCPQNAME &QNAME\n         AGO   .TDDN\n.DDN     RCPDDN &DDN&F&FILE\n         AGO   .TUNIT\n.DDNRT   RCPDDNRT &DDNRET\n&DDNRTO  SETA  &DTUO-10\n         AGO   .TUNIT\n.UNIT   RCPUNIT &UNIT,&VOL,99\n         AGO   .TVOLRET\n.VOLRET  RCPVOLRT &VOLRET\n&VOLRTO  SETA  &DTUO-8\n         AGO   .TDSRGO\n.DSORGRT RCPDSRGR\n&DSRGRTO SETA  &DTUO-2\n         AGO   .TLABEL\n.LABEL1  RCPLABEL &LABEL\n         AGO   .TPSWD\n.PASWORD RCPPSWD &PASWORD\n         AGO   .TFORUSE\n.FORUSER RCPFORUS &FORUSER\n         AGO   .TTU\n.TU      RCPTU &TU\n         AGO   .TDISP\n.DISP    RCPDISP &DISP\n         AGO   .TSPACE\n.SPACE   RCPSPACE &SPACE\n         AGO   .TSTCL\n.STCL    RCPSTCL &STCL\n         AGO   .TLRECL\n.DCB     RCPDDCB LRECL=&LRECL,DEN=&DEN,RECFM=&RECFM,BLKSIZE=&BLKSIZE,  X\n               DSORG=&DSORG,KEYLEN=&KEYLEN,BUFNO=&BUFNO\n         AGO .TDCBDSN\n.DCBDSN  RCPDCBDS &DCBDSN\n         AGO .TDCBDDN\n.DCBDDN  RCPDCBDD &DCBDDN\n         AGO .TFREE\n.FREE    RCPFREE  &FREE\n         AGO   .TPERM\n.PERM    RCPPERM\n         AGO   .TSPECI\n.SPECIAL RCPSPEC &SPECIAL\n         AGO   .TOUTP\n.OUTA    ANOP\n         AIF   ('&OUTDEL' EQ 'YES').OUTD\n         RCPOUTA OUTPUT=&OUTPUT,PAGEDEF=&PAGEDEF,FORMDEF=&FORMDEF,     X\n               PRMODE=&PRMODE,TRC=&TRC,DEFAULT=&DEFAULT\n         AGO   .SVC99\n.OUTD    ANOP\n         RCPOUTD OUTPUT=&OUTPUT\n.SVC99   ANOP\n&DTUPO   SETA  &DTUPO-4\n         SPACE\n         MVI   &DYNP.TUP+&DTUPO,X'80'  SET HIGH ORDER BIT ON TEXT PTRS\n         MVI   &DYNP.RBP,X'80'         SET HIGH ORDER BIT ON RB PTR\n         RCPSR2 UNSAVE\n&DTUPO   SETA  &DTUPO+4\n         AIF   (NOT &DSECT).DYNA\n         DROP  R1,R15                  DEACTIVATE ADDRESSABILITY\n         LA    R14,4(R1)               POINT TO REQUEST BLOCK\n.DYNA    DYNALLOC\n         AIF   (NOT &DSECT).LTR\n         USING &DYNP.RB,R14            SET UP ADDRESSABILITY\n**       NOTE  R14 HAS RB ADDRESS, R15 HAS SVC 99 RETURN CODE        **\n.LTR     AIF   ('&ERROR' EQ '').TDDTO\n         LTR   R15,R15                 TEST RETURN CODE\n         BNZ   &ERROR                  BRANCH IF NON ZERO\n.TDDTO   AIF   ('&DDNTO' EQ '').RESERVE\n&I       SETA  0\n.DDNTOL  ANOP\n&I       SETA  &I+1\n         AIF   ('&DDNTO(&I)' EQ '').RESERVE\n         AIF   ('&DDNTO(&I)'(1,1) EQ '(').DDNTOR\n         MVC   &DDNTO(&I).(8),&DYNP.TU+&DDNRTO+2\n         AGO   .DDNTOL\n.DDNTOR  ANOP\n&C       SETC  '&DDNTO(&I)'(2,K'&DDNTO(&I)-2)\n         MVC   0(8,&C),&DYNP.TU+&DDNRTO+2\n         AGO   .DDNTOL\n.RESERVE AIF   (&DSECT).RESDS\n         SPACE 1\n*********************************************************************\n**       RESERVE SPACE FOR DYNALLOC PARAMETER LIST                 **\n*********************************************************************\n         RCPDS\n.SSP     ANOP\n&DYNP.RBP DS   F                       SVC 99 REQ BLOCK POINTER\n&DYNP.RB  DS   5F                      SVC 99 REQUEST BLOCK\n&DYNP.TUP DS   CL&DTUPO                SPACE FOR TEXT POINTERS\n         AIF   (&DTUO EQ 0).DTU21\n&DYNP.TU  DS   CL&DTUO                 SPACE FOR TEXT UNITS\n         AIF   (&DSNRTO EQ 0).TDDNRTO\n&DSNRET  EQU   &DYNP.TU+&DSNRTO        OFFSET TO RETURNED DSN\n.TDDNRTO AIF   ('&DDNRET' EQ '').DTU11\n&DDNRET  EQU   &DYNP.TU+&DDNRTO        OFFSET TO RETURNED DDNAME\n.DTU11   AIF   (&VOLRTO EQ 0).DTU12\n&VOLRET  EQU   &DYNP.TU+&VOLRTO        OFFSET TO RETURNED VOLSER\n.DTU12   AIF   (&DSRGRTO EQ 0).DTU10\n&DSORGRT EQU   &DYNP.TU+&DSRGRTO       OFFSET TO RETURNED DSORG\n         AGO   .DTU10\n.DTU21   ANOP\n&DYNP.TU  DS   0C                      NO SPACE NEEDED FOR TEXT UNITS\n.DTU10   ANOP\n&DYNP.LEN EQU  *-&DYNP.RBP             LENGTH OF SPACE USED\n         AIF   (&DSECT).DSP\n         RCPDS\n         SPACE 3\n         AGO   .EXIT\n.RESDS   ANOP\n         AIF   ('&DYNSP' EQ '').SP3\n         DYNSPACE ADD\n.SP3     SPACE\n&DYNP.DS DSECT                         DSECT TO MAP SVC 99 DATA\n         AGO   .SSP\n.DSP     AIF   ('&MF(3)' EQ '').END1\n&MF(3)   EQU   &DYNP.LEN               LENGTH OF AREA\n.END1    ANOP\n&SYSECT  CSECT\n         SPACE 3\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALLOCGDX": {"ttr": 14852, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00N\\x00N\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 78, "newlines": 78, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- ALLOCATE GDG BY RELATIVE NUMBER  **/\n\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT \"ISREDIT MACRO (\"PARMS\")\"\n      IF RC = 0 THEN\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n   END\n   IF DSN = 'DSN' THEN ARG PARMS\n\n   IF PARMS = \"\" | PARMS = \"?\" THEN SIGNAL DISPDOC\n   DO II = 1 TO LENGTH(PARMS) BY 1 WHILE( SUBSTR(PARMS,II,1) <> '(' )\n   END II\n   DO JJ = II+1 TO LENGTH(PARMS) BY 1 WHILE( SUBSTR(PARMS,JJ,1) <> ')' )\n   END JJ\n   IF SUBSTR(PARMS,1,1) = \"'\",\n      THEN DO\n         QUOTED = \"YES\"\n         RELGDG = SUBSTR(PARMS,2,II-2) || \".G*V*\"\n         ALLOCPARMS = SUBSTR(PARMS,JJ+3)\n      END\n      ELSE DO\n         QUOTED = \"NO\"\n         RELGDG = SUBSTR(PARMS,1,II-1) || \".G*V*\"\n         ALLOCPARMS = SUBSTR(PARMS,JJ+2)\n      END\n   RELOFF = SUBSTR(PARMS,II+1,JJ-II-1)\n\n/* \"READ\" LOOP */\n   \"ISPEXEC LMDINIT LISTID(DSLIST) LEVEL(&RELGDG)\"\n   NN = 0\n   DO WHILE RC = 0\n      \"ISPEXEC LMDLIST LISTID(&DSLIST) DATASET(DSNVAR) OPTION(LIST)\"\n      DSNVAR  = STRIP(LEFT(DSNVAR,44),\"T\")\n      IF RC > 0 THEN LEAVE\n      NN = NN + 1\n      ABSDSN.NN = DSNVAR\n   END\n   \"ISPEXEC LMDLIST LISTID(&DSLIST)\" \"OPTION(FREE)\"\n\n/* GENERATE ALLOCATE */\n   QQ = 0\n   DO XX = NN TO 1 BY -1\n      IF RELOFF = QQ THEN DO\n         IF QUOTED = 'YES' THEN\n            ADDRESS TSO \"ALLOC DSN('\"ABSDSN.XX\"')\" ALLOCPARMS\n         ELSE\n            ADDRESS TSO \"ALLOC DSN(\"ABSDSN.XX\")\" ALLOCPARMS\n         LEAVE\n      END\n      QQ = QQ - 1\n   END XX\n   EXIT(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"ALLOCGDG - ALLOCATE A RELATIVE GDG AS ABSOLUTE GDG        \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    ALLOCGDG  DSN-QUALIFIER | ?  ( OTHER ALLOC PARMS )    \"\n   SAY\n   SAY \"       DO EQUIVALENT OF ALLOCATE FOR A RELATIVE GDG ENTRY \"\n   SAY \"       TRANSLATING THE RELATIVE NUMBERED DATA SET INTO A  \"\n   SAY \"       FULLY QUALIFIED G....V00 NAME. FOR EXAMPLE:        \"\n   SAY \"          ALLOCGDG 'RUBBER.DUCKY(-1)' DD(...) ...         \"\n   SAY \"       WOULD ALLOCATE THE -1 FILE AS THE FULLY NAMED      \"\n   SAY \"       'RUBBER.DUCKY.G0011V00' (IF APPROPRIATE).          \"\n   SAY\n   SAY \"       ANY ADDITIONAL NORMAL ALLOCATE PARAMETERS ARE      \"\n   SAY \"       PASSED AS IS. THE DSN-QUALIFIER MAY BE QUOTED AS   \"\n   SAY \"       SHOWN OR NOT.                                      \"\n   SAY\n   SAY \"       USE NO PARAMETERS OR A STANDALONE ? TO GET THIS    \"\n   SAY \"       HELP.                                              \"\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ALPHACNT": {"ttr": 14855, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x01l\\x01l\\x00\\x00\\xc1\\xd3\\xd7\\xc8\\xc1\\xc3\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 364, "newlines": 364, "modlines": 0, "user": "ALPHACN"}, "text": "//-YOUR-USERID-A JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  ALPHANUMERIC CONVERSION, COUNTING AND VERIFICATION\n//***  SUB-PROGRAMS. ORDER OF COUNTING IS 'A' THROUGH\n//***  THROUGH 'Z' THEN '0' THROUGH '9'.\n//***\n//C          EXEC     PGM=IGYCRCTL,REGION=4M,\n//             PARM=('LIB,MAP,NUMPROC(PFD),OFF,OPTIMIZE',\n//            'APOST,NOSEQ,TRUNC(OPT),XREF')\n//SYSIN        DD       *\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  TSTALPHA.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       SPECIAL-NAMES.\n           CLASS ALPHA-CHARS\n               IS 'A' THRU 'Z', '0' THRU '9'.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT I\n               ASSIGN TO I.\n       DATA DIVISION.\n       FILE SECTION.\n       FD  I\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  INPUT-REC    PIC X(00080).\n       WORKING-STORAGE SECTION.\n       01  WS-INPUT-REC.\n           05  INPUT-VALUE              PIC X(00010).\n           05                           PIC X(00010).\n           05  EXPECTED-PLUS-1-VALUE    PIC X(00010).\n           05                           PIC X(00010).\n           05  EXPECTED-MINUS-1-VALUE   PIC X(00010).\n           05                           PIC X(00030).\n       01   WS-RC                       PIC 99.\n       01   WS-L                        PIC 99.\n       01   WS-DATA1                    PIC X(10).\n       01   WS-DATA2                    PIC X(10).\n       01   WS-RETURN-CODE              PIC 9(4) VALUE 0.\n       01  END-OF-FILE-STATUS           PIC X    VALUE 'N'.\n           88  AT-END-OF-FILE                    VALUE 'Y'.\n\n       PROCEDURE DIVISION.\n       0000-MAIN.\n           PERFORM 0100-INITIALIZATION\n           PERFORM 0200-READ-WRITE-LOOP\n               UNTIL AT-END-OF-FILE\n           PERFORM 0900-TERMINATION\n           MOVE WS-RETURN-CODE TO RETURN-CODE\n           GOBACK\n           .\n\n       0100-INITIALIZATION.\n           OPEN  INPUT  I\n           READ  I INTO WS-INPUT-REC\n               AT END SET AT-END-OF-FILE TO TRUE\n               END-READ\n           .\n\n       0200-READ-WRITE-LOOP.\n\n           MOVE 10 TO WS-L\n\n           MOVE INPUT-VALUE TO WS-DATA1\n           DISPLAY ' '\n\n           CALL 'NXTALPHA' USING WS-RC, WS-L, WS-DATA1, WS-DATA2\n           IF WS-DATA2 = EXPECTED-PLUS-1-VALUE\n              DISPLAY '*OK* INPUT >' INPUT-VALUE '< '\n                 'PLUS  1 >' WS-DATA2 '< '\n                 'EXPECT  >' EXPECTED-PLUS-1-VALUE '< '\n                 'RC=' WS-RC\n           ELSE\n              DISPLAY '*NG* INPUT >' INPUT-VALUE '< '\n                 'PLUS  1 >' WS-DATA2 '< '\n                 'EXPECT  >' EXPECTED-PLUS-1-VALUE '< '\n                 'RC=' WS-RC\n              MOVE 16 TO WS-RETURN-CODE\n           END-IF\n\n           CALL 'PRVALPHA' USING WS-RC, WS-L, WS-DATA1, WS-DATA2\n           IF WS-DATA2 = EXPECTED-MINUS-1-VALUE\n              DISPLAY '*OK* INPUT >' INPUT-VALUE '< '\n                 'MINUS 1 >' WS-DATA2 '< '\n                 'EXPECT  >' EXPECTED-MINUS-1-VALUE '< '\n                 'RC=' WS-RC\n           ELSE\n              DISPLAY '*NG* INPUT >' INPUT-VALUE '< '\n                 'MINUS 1 >' WS-DATA2 '< '\n                 'EXPECT  >' EXPECTED-MINUS-1-VALUE '< '\n                 'RC=' WS-RC\n              MOVE 16 TO WS-RETURN-CODE\n           END-IF\n\n           CALL 'VERALPHA' USING WS-RC, WS-L, WS-DATA1\n           IF WS-RC = 0\n              AND  EXPECTED-PLUS-1-VALUE NOT = ' '\n                 OR ( EXPECTED-PLUS-1-VALUE = ' '\n                    AND  WS-DATA1 = '9999999999' )\n              DISPLAY '*OK* GOOD  >' INPUT-VALUE '< '\n                 'RC=' WS-RC\n           ELSE\n              IF WS-RC NOT = 0  AND  EXPECTED-PLUS-1-VALUE = ' '\n                 DISPLAY '*OK* BAD   >' INPUT-VALUE '< '\n                    'RC=' WS-RC\n              ELSE\n                 DISPLAY '*NG* HUH   >' INPUT-VALUE '< '\n                    'RC=' WS-RC\n                 MOVE 16 TO WS-RETURN-CODE\n                 END-IF\n           END-IF\n           READ  I INTO WS-INPUT-REC\n               AT END SET AT-END-OF-FILE TO TRUE\n               END-READ\n           .\n\n       0900-TERMINATION.\n           DISPLAY ' '\n           DISPLAY '**********************************************'\n           DISPLAY '*  COUNTING OFF FIRST 100 \"NUMBERS\"          *'\n           DISPLAY '**********************************************'\n           MOVE 'AAAAAAAAAA' TO WS-DATA1\n           MOVE 10           TO WS-L\n           MOVE  0           TO WS-RC\n           DISPLAY '   ' WS-DATA1 '  RC=' WS-RC\n           PERFORM  99 TIMES\n              CALL 'NXTALPHA' USING WS-RC, WS-L, WS-DATA1, WS-DATA2\n              DISPLAY '   ' WS-DATA2 '  RC=' WS-RC\n              MOVE WS-DATA2  TO WS-DATA1\n           END-PERFORM\n           DISPLAY ' '\n           DISPLAY '**********************************************'\n           DISPLAY '*  COUNTING OFF LAST 100 \"NUMBERS\"           *'\n           DISPLAY '**********************************************'\n           MOVE '9999999999' TO WS-DATA1\n           MOVE 10           TO WS-L\n           MOVE  0           TO WS-RC\n           DISPLAY '   ' WS-DATA1 '  RC=' WS-RC\n           PERFORM  99 TIMES\n              CALL 'PRVALPHA' USING WS-RC, WS-L, WS-DATA1, WS-DATA2\n              DISPLAY '   ' WS-DATA2 '  RC=' WS-RC\n              MOVE WS-DATA2  TO WS-DATA1\n           END-PERFORM\n           CLOSE I\n           .\n\n\n      *  NXTALPHA: DO ALPHABETIC ADDITION OF 1 TO FIELD UP TO 99\n      *            BYTES LONG.  COLLATING SEQUENCE IS A TO Z THEN\n      *            FOLLOWED BY 0 TO 9.\n\n      *            PARAMETERS FOR \"USING\":\n      *                RET-CODE      PIC 99\n      *                INPUT-LENGTH  PIC 99\n      *                INPUT-DATA    PIC X(##)\n      *                OUTPUT-DATA   PIC X(##)\n\n      *            LENGTH AND INPUT-DATA MUST BE SUPPLIED.  NON\n      *            ALPHANUMERIC INPUT AND ALL 9'S AS INPUT ARE BOTH\n      *            REJECTED.\n\n      *            RETURN CODES:\n      *               0 - ADDITION COMPLETED SUCCESSFULLY\n      *               1 - NON ALPHANUMERIC VALUE FOUND\n      *               2 - VALUE ALL 9'S; CAN'T GO HIGHER\n      *\n      *            THE RETURNED VALUE IS BLANKS IF AN INPUT ERROR IS\n      *            FOUND.\n\n       ID DIVISION.\n       PROGRAM-ID.    NXTALPHA  COMMON.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01 ARRAY-ENTRIES.\n          05 ARRAY-CHARS OCCURS 99.\n             10 ARRAY-CHAR         PIC X.\n\n       01 WS-TEMP-VARIABLES.\n          05 ARRAY-CHAR-SUB           PIC S9(4) COMP.\n\n       LINKAGE SECTION.\n         01 LS-RC                     PIC 99.\n         01 LS-L                      PIC 99.\n         01 LS-DATA1                  PIC X(99).\n         01 LS-DATA2                  PIC X(99).\n\n       PROCEDURE DIVISION USING LS-RC, LS-L, LS-DATA1, LS-DATA2.\n\n       0000-MAINLINE-ROUTINE.\n\n           MOVE LS-DATA1(1:LS-L) TO ARRAY-ENTRIES\n           MOVE SPACES TO LS-DATA2(1:LS-L)\n           MOVE 0      TO LS-RC\n\n           IF ARRAY-ENTRIES(1:LS-L) IS NOT ALPHA-CHARS\n               MOVE 1        TO LS-RC\n           ELSE\n               IF ARRAY-ENTRIES(1:LS-L) = ALL '9'\n                   MOVE 2        TO LS-RC\n               ELSE\n                   PERFORM VARYING ARRAY-CHAR-SUB FROM LS-L BY -1\n                           UNTIL ARRAY-CHAR-SUB < 1\n                     INSPECT ARRAY-CHAR (ARRAY-CHAR-SUB)\n                       CONVERTING 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\n                               TO 'BCDEFGHIJKLMNOPQRSTUVWXYZ0123456789A'\n                     IF ARRAY-CHAR (ARRAY-CHAR-SUB) NOT = 'A'\n                         MOVE 0 TO ARRAY-CHAR-SUB\n                     END-IF\n                   END-PERFORM\n                   MOVE ARRAY-ENTRIES(1:LS-L) TO LS-DATA2(1:LS-L)\n               END-IF\n           END-IF\n           EXIT PROGRAM.\n       END PROGRAM NXTALPHA.\n\n      *  PRVALPHA: DO ALPHABETIC ADDITION OF 1 TO FIELD UP TO 99\n      *            BYTES LONG.  COLLATING SEQUENCE IS A TO Z THEN\n      *            FOLLOWED BY 0 TO 9.\n\n      *            PARAMETERS FOR \"USING\":\n      *                RET-CODE      PIC 99\n      *                INPUT-LENGTH  PIC 99\n      *                INPUT-DATA    PIC X(##)\n      *                OUTPUT-DATA   PIC X(##)\n\n      *            LENGTH AND INPUT-DATA MUST BE SUPPLIED.  NON\n      *            ALPHANUMERIC INPUT AND ALL 9'S AS INPUT ARE BOTH\n      *            REJECTED.\n\n      *            RETURN CODES:\n      *               0 - SUBTRACTION COMPLETED SUCCESSFULLY\n      *               1 - NON ALPHANUMERIC VALUE FOUND\n      *               2 - VALUE ALL A'S; CAN'T GO LOWER\n      *\n      *            THE RETURNED VALUE IS BLANKS IF AN INPUT ERROR IS\n      *            FOUND.\n\n       ID DIVISION.\n       PROGRAM-ID.    PRVALPHA  COMMON.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01 ARRAY-ENTRIES.\n          05 ARRAY-CHARS OCCURS 99.\n             10 ARRAY-CHAR         PIC X.\n\n       01 WS-TEMP-VARIABLES.\n          05 ARRAY-CHAR-SUB           PIC S9(4) COMP.\n\n       LINKAGE SECTION.\n         01 LS-RC                     PIC 99.\n         01 LS-L                      PIC 99.\n         01 LS-DATA1                  PIC X(99).\n         01 LS-DATA2                  PIC X(99).\n\n       PROCEDURE DIVISION USING LS-RC, LS-L, LS-DATA1, LS-DATA2.\n\n       0000-MAINLINE-ROUTINE.\n\n           MOVE LS-DATA1(1:LS-L) TO ARRAY-ENTRIES\n           MOVE SPACES TO LS-DATA2(1:LS-L)\n           MOVE 0      TO LS-RC\n\n           IF ARRAY-ENTRIES(1:LS-L) IS NOT ALPHA-CHARS\n               MOVE 1        TO LS-RC\n           ELSE\n               IF ARRAY-ENTRIES(1:LS-L) = ALL 'A'\n                   MOVE 2        TO LS-RC\n               ELSE\n                   PERFORM VARYING ARRAY-CHAR-SUB FROM LS-L BY -1\n                           UNTIL ARRAY-CHAR-SUB < 1\n                     INSPECT ARRAY-CHAR (ARRAY-CHAR-SUB)\n                       CONVERTING 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\n                               TO '9ABCDEFGHIJKLMNOPQRSTUVWXYZ012345678'\n                     IF ARRAY-CHAR (ARRAY-CHAR-SUB) NOT = '9'\n                         MOVE 0 TO ARRAY-CHAR-SUB\n                     END-IF\n                   END-PERFORM\n                   MOVE ARRAY-ENTRIES(1:LS-L) TO LS-DATA2(1:LS-L)\n               END-IF\n           END-IF\n           EXIT PROGRAM.\n       END PROGRAM PRVALPHA.\n\n      *  VERALPHA: VERIFY ALPHANUMERIC  FIELD UP TO 99 BYTES LONG.\n      *            COLLATING SEQUENCE IS A TO Z THEN FOLLOWED\n      *            BY 0 TO 9.\n\n      *            PARAMETERS FOR \"USING\":\n      *                RET-CODE      PIC 99\n      *                INPUT-LENGTH  PIC 99\n      *                INPUT-DATA    PIC X(##)\n\n      *            LENGTH AND INPUT-DATA MUST BE SUPPLIED.\n      *\n      *            RETURN CODES:\n      *               0 - VALIDATION COMPLETED SUCCESSFULLY\n      *               1 - NON ALPHANUMERIC VALUE FOUND\n\n       ID DIVISION.\n       PROGRAM-ID.    VERALPHA  COMMON.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01 ARRAY-ENTRIES.\n          05 ARRAY-CHARS OCCURS 99.\n             10 ARRAY-CHAR         PIC X.\n\n       01 WS-TEMP-VARIABLES.\n          05 ARRAY-CHAR-SUB           PIC S9(4) COMP.\n\n       LINKAGE SECTION.\n         01 LS-RC                     PIC 99.\n         01 LS-L                      PIC 99.\n         01 LS-DATA1                  PIC X(99).\n\n       PROCEDURE DIVISION USING LS-RC, LS-L, LS-DATA1.\n\n       0000-MAINLINE-ROUTINE.\n\n           MOVE 0      TO LS-RC\n           IF LS-DATA1(1:LS-L) IS NOT ALPHA-CHARS\n               MOVE 1        TO LS-RC\n           END-IF\n           EXIT PROGRAM.\n       END PROGRAM VERALPHA.\n\n       END PROGRAM TSTALPHA.\n\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=SYSDA,SPACE=(CYL,(3,3)),\n//             DCB=(BLKSIZE=0,LRECL=80,RECFM=FB)\n//SYSUT1       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT2       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT3       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT4       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT5       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT6       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT7       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//***\n//GO         EXEC     PGM=LOADER,PARM='MAP,PRINT,AMODE(31),RMODE(ANY)',\n//             REGION=4M,COND=(5,LT)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//SYSLOUT      DD       SYSOUT=*\n//SYSPRINT     DD       SYSOUT=*\n//** COL 1 IS START VALUE; 21 IS \"+1\" AND 41 \"-1\" EXPECTED VALUE\n//I            DD       *\nAAAAAAAAAA          AAAAAAAAAB\nAAAAAAA1A9          AAAAAAA1BA          AAAAAAA1A8\nABABABABAB          ABABABABAC          ABABABABAA\nKKKKKKKKKK          KKKKKKKKKL          KKKKKKKKKJ\nZZZZZZZZZZ          ZZZZZZZZZ0          ZZZZZZZZZY\n..........\n0000000000          0000000001          000000000Z\n243ACQJ9E5          243ACQJ9E6          243ACQJ9E4\n9999999999                              9999999998\n//SYSOUT       DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASAXWC": {"ttr": 14862, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\rs\\rs\\x00\\x00\\xc1\\xe2\\xc1\\xe7\\xe6\\xc3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 3443, "newlines": 3443, "modlines": 0, "user": "ASAXWC"}, "text": "*%ASAXWC: MACRO KEYS(PLISTVER,PATTERNSTR,PATTERNSTRLEN,STRING,\n*                 STRINGLEN,ZEROORMORE,ONECHAR,DELIMITER,WORKAREA,\n*                 RETCODE,MF);\n*/**** START OF SPECIFICATIONS ****************************************\n*01* DESCRIPTIVE NAME:  Wildcard service                              *\n*                                                                     *\n*01* FUNCTION:                                                        *\n*      ASAXWC is an executable macro that does wildcard match         *\n*      checking, comparing an input pattern string (which can contain *\n*      wildcard characters) to an input string.                       *\n*      AMODE:            31-bit.                                      *\n*      ASC mode:         Primary.                                     *\n*                                                                     *\n*01* MACRO USAGE NOTES:                                               *\n*                                                                     *\n*    1.  Printing of the macro expansion is controlled by the ZPRINT  *\n*        global macro variable.  Any value other than 'NO' will       *\n*        result in the macro expansion being printed.  The default is *\n*        'YES'.  The following examples illustrate how the ZPRINT     *\n*        variable should be set.                                      *\n*                                                                     *\n*                    GBLC &ZPRINT                                     *\n*            &ZPRINT SETC 'YES'          &ZPRINT SETC 'NO'            *\n*                                                                     *\n*    2.  All  keys currently contained in the ASAXWC macro correspond *\n*        to  version 0.  If you specify PLISTVER, use a value of 0 or *\n*        MAX.                                                         *\n*                                                                     *\n*    3.  The  use  of  * to match 0 or more characters and ? to match *\n*        exactly 1 character are SAA standards.                       *\n*                                                                     *\n*\u00ddxlabel\u00a8  ASAXWC   \u00dd PLISTVER=\u00bbxplistver|IMPLIED_VERSION\u00ba\u00a8           *\n*                    ,PATTERNSTR=xpatternstr                          *\n*                    ,PATTERNSTRLEN=xpatternstrlen                    *\n*                    ,STRING=xstring                                  *\n*                    ,STRINGLEN=xstringlen                            *\n*                    ,ZEROORMORE=xzeroormore                          *\n*                    ,ONECHAR=xonechar                                *\n*                   \u00dd,DELIMITER=\u00bbxdelimiter|LENGTHS_WERE_SET\u00ba\u00a8        *\n*                   \u00dd,WORKAREA=\u00bbxworkarea|NO_WORKAREA\u00ba\u00a8               *\n*                   \u00dd,RETCODE=xretcode\u00a8                               *\n*                  \u00d0\u00dd,MF=S\u00a8                                           *\n*                  \u00d4\u00dd,MF=(L,xmfctrl\u00bb,xmfattr|0D\u00ba)\u00a8                    *\n*                  \u00d4\u00dd,MF=(M,xmfctrl\u00bb,COMPLETE|NOCHECK\u00ba)\u00a8              *\n*                  \u00bf\u00dd,MF=(E,xmfctrl\u00bb,COMPLETE|NOCHECK\u00ba)\u00a8              *\n*                                                                     *\n*      Where:                                                         *\n*                                                                     *\n*      \u00ddxlabel\u00a8                                                       *\n*          is an optional symbol, starting in column 1, that is the   *\n*          name on the ASAXWC macro invocation.  The name must        *\n*          conform to the rules for an ordinary assembler language    *\n*          symbol.                                                    *\n*          DEFAULT: No name.                                          *\n*                                                                     *\n*      \u00ddPLISTVER(\u00bbxplistver|IMPLIED_VERSION\u00ba)\u00a8                        *\n*          is an optional byte input decimal value in the \"0-0\" range *\n*          that specifies the macro version.  PLISTVER is the only    *\n*          key allowed on the list form of MF and determines which    *\n*          parameter list is generated (see Macro USAGE NOTE 2).      *\n*          Note that MAX may be specified instead of a number, and    *\n*          the parameter list will be of the largest size currently   *\n*          supported. This size may grow from release to release      *\n*          (thus possibly affecting the amount of storage needed by   *\n*          your program).  If your program can tolerate this, IBM     *\n*          recommends that you always specify MAX when creating the   *\n*          list form parameter list as that will ensure that the list *\n*          form parameter list is always long enough to hold whatever *\n*          parameters might be specified on the execute form.         *\n*          DEFAULT: IMPLIED_VERSION.  When PLISTVER is omitted, the   *\n*          default is the lowest version which allows all of the      *\n*          parameters specified on the invocation to be processed.    *\n*                                                                     *\n*      PATTERNSTR(xpatternstr)                                        *\n*          is the name (RS-type) (or address in register (2)-(12) ASM *\n*          only) of a required variable character input field         *\n*          containing the wildcard pattern string.                    *\n*                                                                     *\n*      PATTERNSTRLEN(xpatternstrlen)                                  *\n*          is the name (RS-type) (or address in register (2)-(12) ASM *\n*          only) of a required fullword input field containing the    *\n*          length of the wildcard pattern string.  The length         *\n*          actually used is the length up to the first occurrence of  *\n*          the delimiter character or this length if the delimiter    *\n*          character is not present.                                  *\n*                                                                     *\n*      STRING(xstring)                                                *\n*          is the name (RS-type) (or address in register (2)-(12) ASM *\n*          only) of a required variable character input field         *\n*          containing the string to match against.                    *\n*                                                                     *\n*      STRINGLEN(xstringlen)                                          *\n*          is the name (RS-type) (or address in register (2)-(12) ASM *\n*          only) of a required fullword input field containing the    *\n*          length of the string to match against.  The length         *\n*          actually used is the length up to the first occurrence of  *\n*          the delimiter character or this length if the delimiter    *\n*          character is not present.                                  *\n*                                                                     *\n*      ZEROORMORE(xzeroormore)                                        *\n*          is the name (RS-type) (or address in register (2)-(12) ASM *\n*          only) of a required 1 character input field that specifies *\n*          the wildcard character that represents zero or more        *\n*          characters. The normal character is \"*\".                   *\n*                                                                     *\n*      ONECHAR(xonechar)                                              *\n*          is the name (RS-type) (or address in register (2)-(12) ASM *\n*          only) of a required 1 character input field that specifies *\n*          the wildcard character that represents exactly one         *\n*          character. The normal character is \"?\".                    *\n*                                                                     *\n*      \u00ddDELIMITER(\u00bbxdelimiter|LENGTHS_WERE_SET\u00ba)\u00a8                     *\n*          is the name (RS-type) (or address in register (2)-(12) ASM *\n*          only) of an optional 1 character input field that          *\n*          specifies the character that indicates the end of the      *\n*          input (either PatternStr or String).  The normal character *\n*          is a blank.  If the specified lengths are already correct, *\n*          do not specify this keyword.                               *\n*          DEFAULT: LENGTHS_WERE_SET                                  *\n*                                                                     *\n*      \u00ddWORKAREA(\u00bbxworkarea|NO_WORKAREA\u00ba)\u00a8                            *\n*          is the name (RS-type) (or address in register (2)-(12) ASM *\n*          only) of an optional 256 character input field that        *\n*          specifies an area that the wildcard service can use as a   *\n*          dynamic area. This will result in a call to the wildcard   *\n*          service entry that does no getmains or freemains.  While   *\n*          you cannot specify WORKAREA=(0), you can place the address *\n*          of the workarea into register 0 and specify register 0 by  *\n*          a symbolic name (e.g., WORKAREA=(symbol) where symbol is   *\n*          equated to 0).  Using WORKAREA=(R0) will result in the     *\n*          most efficient code being generated.  Do not specify       *\n*          WORKAREA on the modify form.                               *\n*          DEFAULT: NO_WORKAREA                                       *\n*                                                                     *\n*      \u00ddRETCODE(xretcode)\u00a8                                            *\n*          is the name (RS-type) of an optional fullword output       *\n*          variable (or register (2)-(12) ASM only) into which the    *\n*          return code is to be copied from GPR 15.                   *\n*                                                                     *\n*      \u00ddMF(\u00bbS|L|M|E\u00ba)\u00a8                                                *\n*          is an optional keyword input which specifies the macro     *\n*          form.                                                      *\n*          DEFAULT: S                                                 *\n*                                                                     *\n*          \u00ddMF(S)\u00a8                                                    *\n*              specifies the standard form of the macro.  The \"S\"     *\n*              form generates code to put the parameters into the     *\n*              parameter list and invoke the desired service.  Full   *\n*              checking for required macro keys is done along with    *\n*              supplying defaults for omitted optional parameters.    *\n*              The ?EPILOG macro must be invoked at the end of the    *\n*              module.                                                *\n*                                                                     *\n*              For assembly language code modules, the \"S\" form       *\n*              generates code to put the parameters into an in-line   *\n*              parameter list and invoke the desired service.  Full   *\n*              checking for required macro keys is done along with    *\n*              supplying defaults for omitted optional parameters.    *\n*                                                                     *\n*          \u00ddMF(L,xmfctrl\u00bb,xmfattr|BDY(DWORD)\u00ba)\u00a8                       *\n*              specifies the list form of the macro.  The \"L\" form    *\n*              defines an area to be used for the parameter list.     *\n*              Only the PLISTVER key may be specified on the          *\n*              invocation.  All other macro parameters are flagged as *\n*              errors.  If PLISTVER is not specified, the original    *\n*              parameter list definition is used.                     *\n*                                                                     *\n*            ,xmfctrl                                                 *\n*              is a required input.  It is the name of a storage area *\n*              for the parameter list.                                *\n*                                                                     *\n*            \u00bb,xmfattr|BDY(DWORD)\u00ba                                    *\n*              is an optional 60 character input string that varies   *\n*              from 1 to 60 characters. It can contain any value that *\n*              is valid on an assembler DS pseudo-op                  *\n*              (assembler-only). You can use this parameter to force  *\n*              boundary alignment of the parameter list.              *\n*              DEFAULT: 0D for Assembler, BDY(DWORD) for PL/AS, which *\n*              forces the parameter list to a doubleword boundary.    *\n*                                                                     *\n*          \u00ddMF(M,xmfctrl\u00bb,COMPLETE|NOCHECK\u00ba)\u00a8                         *\n*              specifies the modify form of the macro.  The \"M\" form  *\n*              generates code to put the parameters into the          *\n*              parameter list specified by xmfctrl.                   *\n*                                                                     *\n*            ,xmfctrl                                                 *\n*              is a required input.  It is the name (RS-type) (or     *\n*              address in register (1)-(12) ASM only) of a storage    *\n*              area for the parameter list.                           *\n*                                                                     *\n*            \u00bb,COMPLETE|NOCHECK\u00ba\u00a8                                     *\n*              is an optional keyword input which specifies the       *\n*              degree of macro parameter syntax checking.             *\n*              DEFAULT: COMPLETE                                      *\n*                                                                     *\n*                                                                     *\n*              COMPLETE   Checking for required macro keys is done    *\n*                        and defaults are supplied for omitted        *\n*                        optional parameters.  (See Macro Usage Note  *\n*                        2).                                          *\n*                                                                     *\n*              NOCHECK   Checking for required macro keys is not done *\n*                        nor are defaults supplied for omitted        *\n*                        optional parameters.                         *\n*                                                                     *\n*          \u00ddMF(E,xmfctrl\u00bb,COMPLETE|NOCHECK\u00ba)\u00a8                         *\n*              specifies the execute form of the macro.  The \"E\" form *\n*              generates code to put the parameters into the          *\n*              parameter list specified by xmfctrl and invoke the     *\n*              desired service.                                       *\n*                                                                     *\n*            ,xmfctrl                                                 *\n*              is a required input.  It is the name (RS-type) (or     *\n*              address in register (1)-(12) ASM only) of a storage    *\n*              area for the parameter list.                           *\n*                                                                     *\n*            \u00bb,COMPLETE|NOCHECK\u00ba                                      *\n*              is an optional keyword input which specifies the       *\n*              degree of macro parameter syntax checking.             *\n*              DEFAULT: COMPLETE                                      *\n*                                                                     *\n*                                                                     *\n*              COMPLETE   Checking for required macro keys is done    *\n*                        and defaults are supplied for omitted        *\n*                        optional parameters.  (See Macro Usage Note  *\n*                        2).                                          *\n*                                                                     *\n*              NOCHECK   Checking for required macro keys is not done *\n*                        nor are defaults supplied for omitted        *\n*                        optional parameters.                         *\n*                                                                     *\n*01* RETURN CODES:                                                    *\n*            0    Match.                                              *\n*            8    No match.                                           *\n*                                                                     *\n*01* EXAMPLES:                                                        *\n*           ASAXWC    PATTERNSTR=PS,      *                           *\n*                     PATTERNSTRLEN=PSL,  *                           *\n*                     STRING=S,           *                           *\n*                     STRINGLEN=SL,       *                           *\n*                     ZEROORMORE=Z,       *                           *\n*                     ONECHAR=O,          *                           *\n*                     DELIMITER=D,        *                           *\n*                     RETCODE=R,          *                           *\n*                     MF=(E,MYLIST)                                   *\n*      PS      DC     C'HE?L*'                                        *\n*      PSL     DC     A(L'PS)                                         *\n*      S       DC     C'HELLO'                                        *\n*      SL      DC     A(L'S)                                          *\n*      Z       DC     CL1'*'                                          *\n*      O       DC     CL1'?'                                          *\n*      D       DC     CL1' '                                          *\n*      DYNAREA DSECT                                                  *\n*      R       DS     F                                               *\n*           ASAXWC    MF=(L,MYLIST)                                   *\n*/*********************************************************************\n         MACRO\n&XLABEL  ASAXWC &PLISTVER=,&PATTERNSTR=,&PATTERNSTRLEN=,&STRING=,      *\n               &STRINGLEN=,&ZEROORMORE=,&ONECHAR=,&DELIMITER=,         *\n               &WORKAREA=,&RETCODE=,&MF=\n.*\n*                   MACDATE -07/19/94-<0>\n.*\n.*******************************************************************\n.***AB.02  GLOBAL VARIABLES TO CONTROL PRINT AND CODE GENERATION\n.*******************************************************************\n                   GBLC  &ZPRINT     YES=PRINT NO=NO PRINT\n                   GBLC  &ZTEST      YES=TEST NO=NO TEST\n                   GBLC  &ZSYSTEM    PCCODE10, MVS, SAK, VM, XAX\n.*\n                   GBLC  &ZASAXWC    YES=MACRO USED AT LEAST ONCE\n.*******************************************************************\n.***AB.03  COMMONLY USED LOCAL MACRO VARIABLES\n.*******************************************************************\n                   LCLC  &ZMS        ERROR MESSAGE WORK AREA\n                   LCLC  &ZCNDX      LAST THREE SYSNDX CHARACTERS\n                   LCLC  &ZCLNG      USED WHEN LENGTH IS NEEDED\n                   LCLC  &ZCGPR      USED WHEN VALUE IS IN A GPR\n                   LCLC  &ZCVAL      USED TO CONTAIN FIXED VALUE\n                   LCLA  &ZAWRK      USED AS A WORK AREA\n                   LCLA  &ZASIZ      USED FOR SIZE OF VALUE\n                   LCLA  &ZN         NUMERIC WORK VARIABLE\n                   LCLC  &ZC         CHARACTER WORK VARIABLE\n                   LCLC  &ZTLC       CHARACTER TOO LONG VARIABLE\n                   LCLA  &ZTLA       VALUE TOO LONG VARIABLE\n                   LCLA  &ZMACRET    MACRO RETURN CODE\n&ZMACRET           SETA  0           ASSUME NO ERRORS\n.*\n                   LCLC  &ZCSYSLIST(255)        NONXKEY, POS ARRAY\n                   LCLA  &ZASYSLNDX  WORK INDEX FOR ZCSYSLIST()\n                   LCLA  &ZPLLEN     PARAMETER LIST LENGTH\n                   LCLA  &ZPLWORKA   PARAMETER LIST LENGTH\n.*******************************************************************\n.***AB.04  MACRO VARIABLES FOR RANGES AND SETS OF ARGUMENTS\n.*******************************************************************\n                   LCLA  &ZI         INDEX FOR ARRAY\n                   LCLA  &ZJ         INDEX FOR PARMS\n                   LCLA  &ZK         INDEX FOR PARSE\n                   LCLA  &ZLO        LOW RANGE VALUE\n                   LCLA  &ZHI        HIGH RANGE VALUE\n                   LCLC  &ZW         WORK AREA FOR PARM\n.********************************************************************\n.***AB.05  INVOKE MVS MACROS TO CONTROL CODE GENERATION\n.********************************************************************\n                   GBLC  &SYSSPLV    SP LEVEL 1,2,3 -SPLEVEL\n                   GBLC  &SYSASCE    SYSTEM STATE P ANY AR-SYSSTATE\n.*\n                   AIF   (K'&SYSASCE GT 0).ZSYS4  SYS STATE DEFINED\n                   AIF   (K'&SYSSPLV GT 0).ZSYS2  SP LEVEL DEFINED\n                   SPLEVEL  TEST\n.ZSYS2             ANOP  ,\n                   AIF   ('&SYSSPLV' EQ '1').ZSYS3  PRE SP 3.1\n                   AIF   ('&SYSSPLV' EQ '2').ZSYS3  PRE SP 3.1\n                   SYSSTATE TEST\n                   AGO   .ZSYS4\n.ZSYS3             ANOP  ,\n&SYSASCE           SETC  'P'         ASSUME SYSSTATE PRIMARY\n.ZSYS4             ANOP  ,\n.*******************************************************************\n.***AB.07  DEFINE ALL MACRO VARIABLES\n.*******************************************************************\n                   LCLA  &XPLISTVER  ++ VALUE\n                   LCLC  &XPATTERNSTR           ++ NAME\n                   LCLC  &XPATTERNSTRLEN        ++ NAME\n                   LCLC  &XSTRING    ++ NAME\n                   LCLC  &XSTRINGLEN            ++ NAME\n                   LCLC  &XZEROORMORE           ++ NAME\n                   LCLC  &XONECHAR   ++ NAME\n                   LCLC  &XDELIMITER            ++ NAME\n                   LCLC  &XWORKAREA  ++ NAME\n                   LCLC  &XRETCODE   ++ NAME\n                   LCLC  &XMF        ++ VALUE\n                   LCLC  &XMFCTRL    ++ NAME\n                   LCLC  &XMFATTR    ++ VALUE\n                   LCLC  &XMFSCK     ++ VALUE\n.*******************************************************************\n.***AB.13  DEFINE MACRO VARIABLES FOR INPUT/OUTPUT PROCESSING\n.*******************************************************************\n                   LCLC  &ZXPLISTVER            ++ INPUT VALUE\n                   LCLC  &ZXPATTERNSTR          ++ INPUT NAME\n                   LCLC  &ZXPATTERNSTRLEN       ++ INPUT NAME\n                   LCLC  &ZXSTRING   ++ INPUT NAME\n                   LCLC  &ZXSTRINGLEN           ++ INPUT NAME\n                   LCLC  &ZXZEROORMORE          ++ INPUT NAME\n                   LCLC  &ZXONECHAR  ++ INPUT NAME\n                   LCLC  &ZXDELIMITER           ++ INPUT NAME\n                   LCLC  &ZXWORKAREA            ++ INPUT NAME\n                   LCLC  &ZXRETCODE  ++ OUTPUT NAME\n                   LCLC  &ZXMF       ++ INPUT VALUE\n                   LCLC  &ZXMFCTRL   ++ INPUT NAME\n                   LCLC  &ZXMFATTR   ++ INPUT VALUE\n                   LCLC  &ZXMFSCK    ++ INPUT VALUE\n.********************************************************************\n.***AC.PLV01  PROCESS PLISTVER                                      *\n.********************************************************************\n&XPLISTVER      SETA  0\n                AIF   (K'&PLISTVER(1) LE 0).ZPLV0\n                AIF   ('&PLISTVER(1)' NE 'MAX').ZPLV0\n&XPLISTVER      SETA  0\n.ZPLV0          ANOP  ,\n.*\n                AIF   (K'&PLISTVER(1) LE 0).ZPVCKE\n                AIF   ('&PLISTVER(1)' EQ 'IMPLIED_VERSION').ZPVCKE\n                AIF   ('&PLISTVER(1)' EQ 'MAX').ZPVCKE\n.*-------------------------------------------------------------------\n                AIF   (N'&PLISTVER LE 1).ZPVCK3  CK NUM\n&ZMS            SETC  '\"PLISTVER='         *KPOSA* MNOTE\n&ZMS            SETC  '&ZMS.&PLISTVER\"'\n&ZMS            SETC  '&ZMS \"PLISTVER\"'\n                MNOTE 8,' &ZMS CAN HAVE ONLY 1 ARGUMENT.'\n&ZMACRET        SETA  8      SET MACRO ERROR RETURN CODE\n                AGO   .ZPVCK2\n.ZPVCK3         ANOP  ,\n.*-------------------------------------------------------------------\n                AIF   ('&PLISTVER'(1,1) NE '(').ZPVCK2\n&ZMS            SETC  '\"PLISTVER='         *KGPRA* MNOTE\n&ZMS            SETC  '&ZMS.&PLISTVER\"'\n&ZMS            SETC  '&ZMS CONTAINS GPR NOTATION WHICH IS NOT'\n                MNOTE 8,' &ZMS ALLOWED FOR ARGUMENT 1.'\n&ZMACRET        SETA  8      SET MACRO ERROR RETURN CODE\n                AGO   .ZPVCKE\n.ZPVCK2         ANOP  ,\n.*-------------------------------------------------------------------\n&ZN             SETA   &PLISTVER(1)        CONVERT TO ARITHMETIC\n                AIF   (&ZN GE &XPLISTVER).ZPVCK4\n&ZMS            SETC  'PLISTVER='          *KVALA* MNOTE\n&ZMS            SETC  '&ZMS.&PLISTVER(1)'\n&ZMS            SETC  '&ZMS., BUT PLISTVER OF'\n&ZMS            SETC  '&ZMS &XPLISTVER'\n                MNOTE 8,' &ZMS IS REQUIRED.'\n&ZMACRET        SETA  8      SET MACRO ERROR RETURN CODE\n                AGO   .ZPVCK5\n.ZPVCK4         ANOP  ,\n&XPLISTVER      SETA  &PLISTVER(1)\n.ZPVCK5         ANOP  ,\n.*-------------------------------------------------------------------\n&ZCVAL          SETC  '&PLISTVER(1)'\n                AIF   ('&ZCVAL'(1,1) EQ '(').ZPVCKE  IN GPR\n                AIF   (T'&ZCVAL NE 'N').ZPVCK6  NUMERIC ERR\n                AIF   (&XPLISTVER LT 0).ZPVCK6  TOO LOW\n                AIF   (&XPLISTVER LE 0).ZPVCKE  NOT HIGH\n.ZPVCK6         ANOP   ,\n&ZMS            SETC  '\"PLISTVER='         *KRNGA* MNOTE\n&ZMS            SETC  '&ZMS.&PLISTVER\"'\n&ZMS            SETC  '&ZMS THE RANGE IS \"0-0\"'\n                MNOTE 8,' &ZMS FOR ARGUMENT 1.'\n&ZMACRET        SETA  8      SET MACRO ERROR RETURN CODE\n.ZPVCKE         ANOP   ,\n.********************************************************************\n.***AG.MF01 PROCESS MF MACRO FORMS\n.********************************************************************\n                   ACTR  10000\n.*------------------------------------------------------------------\n.***AG.KKCTL01 VALUE, OPT INPUT, ME KYWRDCTL -KEYWORD CONTROL\n&XMF               SETC  ''          INITIALIZE XVARIABLE\n.*-------------------------------------------------------------------\n.***AG.KKCTL02 VALUE, OPT INPUT, ME KYWRDCTL -KEYWORD CONTROL\n.ZG33              ANOP  ,\n&ZTLC              SETC 'S'\n                   AIF   ('&MF(1)' NE '&ZTLC').ZG34\n&XMF               SETC  'S'         SET KEYWORD\n&XMFSCK            SETC  'COMPLETE'  SET XMFSCK\n                   AIF   (N'&MF LE 1).ZG33A     CK NUM\n&ZMS               SETC  '\"MF='      *KPOSA* MNOTE\n&ZMS               SETC  '&ZMS.&MF\"'\n&ZMS               SETC  '&ZMS \"MF\"'\n                   MNOTE 8,' &ZMS CAN HAVE ONLY 1 ARGUMENT.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG33A             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KKCTL02 VALUE, OPT INPUT, ME KYWRDCTL -KEYWORD CONTROL\n.ZG34              ANOP  ,\n&ZTLC              SETC 'L'\n                   AIF   ('&MF(1)' NE '&ZTLC').ZG41\n&XMF               SETC  'L'         SET KEYWORD\n                   AIF   (N'&MF LE 3).ZG34A     CK NUM\n&ZMS               SETC  '\"MF='      *KPOSA* MNOTE\n&ZMS               SETC  '&ZMS.&MF\"'\n&ZMS               SETC  '&ZMS \"MF\"'\n                   MNOTE 8,' &ZMS CAN HAVE ONLY 3 ARGUMENTS.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG34A             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KKCTL08 -MF(L) SPECIAL CHECK\n                   AIF   (N'&SYSLIST NE 0).ZG34B  POSITIONALS?\n                   AIF   ('&PATTERNSTR' NE '').ZG34B  KEYS?\n                   AIF   ('&PATTERNSTRLEN' NE '').ZG34B  KEYS?\n                   AIF   ('&STRING' NE '').ZG34B  KEYS?\n                   AIF   ('&STRINGLEN' NE '').ZG34B  KEYS?\n                   AIF   ('&ZEROORMORE' NE '').ZG34B  KEYS?\n                   AIF   ('&ONECHAR' NE '').ZG34B  KEYS?\n                   AIF   ('&DELIMITER' NE '').ZG34B  KEYS?\n                   AIF   ('&WORKAREA' NE '').ZG34B  KEYS?\n                   AIF   ('&RETCODE' NE '').ZG34B  KEYS?\n                   AGO    .ZG34C     INVOCATION OKAY\n.ZG34B             ANOP  ,\n&ZMS               SETC  'THE \"L\" FORM OF \"MF\"'  *MFLA* MNOTE\n&ZMS               SETC  '&ZMS CAN ONLY HAVE'\n&ZMS               SETC  '&ZMS THE \"PLISTVER\" KEY'\n                   MNOTE 8,' &ZMS SPECIFIED ON THE INVOCATION.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG34C             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KXVAR06 NAME, OPT RQD INPUT, POS(2) -XVARIABLE\n&ZXMFCTRL          SETC  'INPUT'     SET IN/OUTPUT\n&XMFCTRL           SETC  '&MF(2,1)'  SET XVARIABLE\n                   AIF   (N'&MF(2) GT 1).ZG36B  MULTI PARMS\n&XMFCTRL           SETC  '&MF(2)'    SET XVARIABLE\n.ZG36B             AIF   (K'&MF(2) GT 0).ZG36C\n&ZXMFCTRL          SETC  ''          RESET IN/OUTPUT\n&ZMS               SETC  'WHEN \"L\" IS SPECIFIED'  *KRQDA*\n&ZMS               SETC  '&ZMS FOR THE \"MF\" KEY, POSITIONAL'\n                   MNOTE 8,' &ZMS ARG 2 IS REQUIRED.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG36C             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KCK01 NAME, OPT RQD INPUT, POS(2) -GPR NOT ALLOWED\n                   AIF   (K'&ZXMFCTRL LE 0).ZG36P  NOT I/O\n                   AIF   ('&XMFCTRL'(1,1) NE '(').ZG36P\n&ZXMFCTRL          SETC  ''          RESET IN/OUTPUT\n&ZMS               SETC  '\"MF='      *KGPRA* MNOTE\n&ZMS               SETC  '&ZMS.&MF\"'\n&ZMS               SETC  '&ZMS CONTAINS GPR NOTATION WHICH IS NOT'\n                   MNOTE 8,' &ZMS ALLOWED FOR ARGUMENT 2.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG36P             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KXVAR13 VALUE, OPT INPUT, POS(3) -XVARIABLE\n&ZXMFATTR          SETC  'INPUT'     SET IN/OUTPUT\n&XMFATTR           SETC  '0D'\n                   AIF   (K'&MF(3) LE 0).ZG39B  PARM\n&XMFATTR           SETC  '&MF(3,1)'  SET XVARIABLE\n                   AIF   (N'&MF(3) GT 1).ZG39B  MULTI PARMS\n&XMFATTR           SETC  '&MF(3)'    SET XVARIABLE\n.ZG39B             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KCK01 VALUE, OPT INPUT, POS(3) -GPR NOT ALLOWED\n                   AIF   (K'&ZXMFATTR LE 0).ZG39P  NOT I/O\n                   AIF   ('&XMFATTR'(1,1) NE '(').ZG39P\n&ZXMFATTR          SETC  ''          RESET IN/OUTPUT\n&ZMS               SETC  '\"MF='      *KGPRA* MNOTE\n&ZMS               SETC  '&ZMS.&MF\"'\n&ZMS               SETC  '&ZMS CONTAINS GPR NOTATION WHICH IS NOT'\n                   MNOTE 8,' &ZMS ALLOWED FOR ARGUMENT 3.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG39P             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KCK03 VALUE, OPT INPUT, POS(3) -CHARACTER LENGTH\n                   AIF   (K'&ZXMFATTR LE 0).ZG39S  NOT I/O\n                   AIF   (K'&XMFATTR LE 60).ZG39S  LNG OK\n&ZXMFATTR          SETC  ''          RESET IN/OUTPUT\n&ZMS               SETC  '\"MF='      *KLNGA* MNOTE\n&ZMS               SETC  '&ZMS.&MF\"'\n&ZMS               SETC  '&ZMS ARGUMENT 3 EXCEEDS THE MAXIMUM'\n                   MNOTE 8,' &ZMS LENGTH OF 60 CHARACTERS.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG39S             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KKCTL02 VALUE, OPT INPUT, ME KYWRDCTL -KEYWORD CONTROL\n.ZG41              ANOP  ,\n&ZTLC              SETC 'M'\n                   AIF   ('&MF(1)' NE '&ZTLC').ZG50\n&XMF               SETC  'M'         SET KEYWORD\n                   AIF   (N'&MF LE 3).ZG41A     CK NUM\n&ZMS               SETC  '\"MF='      *KPOSA* MNOTE\n&ZMS               SETC  '&ZMS.&MF\"'\n&ZMS               SETC  '&ZMS \"MF\"'\n                   MNOTE 8,' &ZMS CAN HAVE ONLY 3 ARGUMENTS.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG41A             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KXVAR06 NAME, OPT RQD INPUT, POS(2) -XVARIABLE\n&ZXMFCTRL          SETC  'INPUT'     SET IN/OUTPUT\n&XMFCTRL           SETC  '&MF(2,1)'  SET XVARIABLE\n                   AIF   (N'&MF(2) GT 1).ZG43B  MULTI PARMS\n&XMFCTRL           SETC  '&MF(2)'    SET XVARIABLE\n.ZG43B             AIF   (K'&MF(2) GT 0).ZG43C\n&ZXMFCTRL          SETC  ''          RESET IN/OUTPUT\n&ZMS               SETC  'WHEN \"M\" IS SPECIFIED'  *KRQDA*\n&ZMS               SETC  '&ZMS FOR THE \"MF\" KEY, POSITIONAL'\n                   MNOTE 8,' &ZMS ARG 2 IS REQUIRED.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG43C             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KCK02 NAME, OPT RQD INPUT, POS(2) -GPR OUT OF RANGE\n                   AIF   (K'&ZXMFCTRL LE 0).ZG43R  NOT I/O\n                   AIF   ('&XMFCTRL'(1,1) NE '(').ZG43R\n&ZCGPR             SETC  '&XMFCTRL'(2,K'&XMFCTRL-2)\n                   AIF   ('&ZCGPR'(1,1) NE '0').ZG43P\n                   AIF   (K'&ZCGPR GT 2).ZG43Q\n                   AIF   ('&ZCGPR' EQ '0').ZG43Q\n&ZCGPR             SETC  '&ZCGPR'(2,1)\n                   AIF   (T'&ZCGPR NE 'N').ZG43Q  INVALID REG NAME\n.ZG43P             ANOP  ,\n                   AIF   (T'&ZCGPR NE 'N').ZG43R  NON NUMERIC\n                   AIF   ('&ZCGPR' LT '1').ZG43Q\n                   AIF   ('&ZCGPR' LE '12').ZG43R\n.ZG43Q             ANOP  ,\n&ZMS               SETC  '\"MF='      *KGPRA* MNOTE\n&ZMS               SETC  '&ZMS.&MF\"'\n&ZMS               SETC  '&ZMS ARGUMENT 2 MUST SPECIFY A REGISTER'\n                   MNOTE 8,' &ZMS IN THE RANGE (1)-(12).'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG43R             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KKWRD02 VALUE, OPT INPUT, ME KEYWORD -SINGLE KEYWORD\n&XMFSCK            SETC  ''          INITIALIZE XVARIABLE\n.ZG47A   AIF   ('&MF(3)' NE 'COMPLETE').ZG48A\n&XMFSCK            SETC  'COMPLETE'  SET KEYWORD\n.*-------------------------------------------------------------------\n.***AG.KKWRD02 VALUE, OPT INPUT, ME KEYWORD -SINGLE KEYWORD\n.ZG48A   AIF   ('&MF(3)' NE 'NOCHECK').ZG49A\n&XMFSCK            SETC  'NOCHECK'   SET KEYWORD\n.*-------------------------------------------------------------------\n.***AG.KKWRD03 VALUE, OPT INPUT, ME KEYWORD -SINGLE KEYWORD\n.ZG49A             AIF   (K'&XMFSCK GT 0).ZG49C  KEYWORD\n                   AIF   (K'&MF(3) LE 0).ZG49B\n&ZMS               SETC  '\"MF='      *KUKWA* MNOTE\n&ZMS               SETC  '&ZMS.&MF\"'\n&ZMS               SETC  '&ZMS ARGUMENT 3 IS AN UNKNOWN KEYWORD. '\n&ZMS               SETC  '&ZMS VALID KEYWORD CHOICE(S) ARE:'\n&ZMS               SETC  '&ZMS \"COMPLETE\"'      VALID KEYWORD\n&ZMS               SETC  '&ZMS OR \"NOCHECK\".'   VALID KEYWORD\n                   MNOTE 8,' &ZMS '\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG49B             ANOP  ,\n&XMFSCK            SETC  'COMPLETE'  SET DEFAULT KEYWORD\n.ZG49C             ANOP  ,\n&ZXMFSCK           SETC  'INPUT'     SET IN/OUTPUT\n.*-------------------------------------------------------------------\n.***AG.KKCTL02 VALUE, OPT INPUT, ME KYWRDCTL -KEYWORD CONTROL\n.ZG50              ANOP  ,\n&ZTLC              SETC 'E'\n                   AIF   ('&MF(1)' NE '&ZTLC').ZG59\n&XMF               SETC  'E'         SET KEYWORD\n                   AIF   (N'&MF LE 3).ZG50A     CK NUM\n&ZMS               SETC  '\"MF='      *KPOSA* MNOTE\n&ZMS               SETC  '&ZMS.&MF\"'\n&ZMS               SETC  '&ZMS \"MF\"'\n                   MNOTE 8,' &ZMS CAN HAVE ONLY 3 ARGUMENTS.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG50A             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KXVAR06 NAME, OPT RQD INPUT, POS(2) -XVARIABLE\n&ZXMFCTRL          SETC  'INPUT'     SET IN/OUTPUT\n&XMFCTRL           SETC  '&MF(2,1)'  SET XVARIABLE\n                   AIF   (N'&MF(2) GT 1).ZG52B  MULTI PARMS\n&XMFCTRL           SETC  '&MF(2)'    SET XVARIABLE\n.ZG52B             AIF   (K'&MF(2) GT 0).ZG52C\n&ZXMFCTRL          SETC  ''          RESET IN/OUTPUT\n&ZMS               SETC  'WHEN \"E\" IS SPECIFIED'  *KRQDA*\n&ZMS               SETC  '&ZMS FOR THE \"MF\" KEY, POSITIONAL'\n                   MNOTE 8,' &ZMS ARG 2 IS REQUIRED.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG52C             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KCK02 NAME, OPT RQD INPUT, POS(2) -GPR OUT OF RANGE\n                   AIF   (K'&ZXMFCTRL LE 0).ZG52R  NOT I/O\n                   AIF   ('&XMFCTRL'(1,1) NE '(').ZG52R\n&ZCGPR             SETC  '&XMFCTRL'(2,K'&XMFCTRL-2)\n                   AIF   ('&ZCGPR'(1,1) NE '0').ZG52P\n                   AIF   (K'&ZCGPR GT 2).ZG52Q\n                   AIF   ('&ZCGPR' EQ '0').ZG52Q\n&ZCGPR             SETC  '&ZCGPR'(2,1)\n                   AIF   (T'&ZCGPR NE 'N').ZG52Q  INVALID REG NAME\n.ZG52P             ANOP  ,\n                   AIF   (T'&ZCGPR NE 'N').ZG52R  NON NUMERIC\n                   AIF   ('&ZCGPR' LT '1').ZG52Q\n                   AIF   ('&ZCGPR' LE '12').ZG52R\n.ZG52Q             ANOP  ,\n&ZMS               SETC  '\"MF='      *KGPRA* MNOTE\n&ZMS               SETC  '&ZMS.&MF\"'\n&ZMS               SETC  '&ZMS ARGUMENT 2 MUST SPECIFY A REGISTER'\n                   MNOTE 8,' &ZMS IN THE RANGE (1)-(12).'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG52R             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KKWRD02 VALUE, OPT INPUT, ME KEYWORD -SINGLE KEYWORD\n&XMFSCK            SETC  ''          INITIALIZE XVARIABLE\n.ZG56A   AIF   ('&MF(3)' NE 'COMPLETE').ZG57A\n&XMFSCK            SETC  'COMPLETE'  SET KEYWORD\n.*-------------------------------------------------------------------\n.***AG.KKWRD02 VALUE, OPT INPUT, ME KEYWORD -SINGLE KEYWORD\n.ZG57A   AIF   ('&MF(3)' NE 'NOCHECK').ZG58A\n&XMFSCK            SETC  'NOCHECK'   SET KEYWORD\n.*-------------------------------------------------------------------\n.***AG.KKWRD03 VALUE, OPT INPUT, ME KEYWORD -SINGLE KEYWORD\n.ZG58A             AIF   (K'&XMFSCK GT 0).ZG58C  KEYWORD\n                   AIF   (K'&MF(3) LE 0).ZG58B\n&ZMS               SETC  '\"MF='      *KUKWA* MNOTE\n&ZMS               SETC  '&ZMS.&MF\"'\n&ZMS               SETC  '&ZMS ARGUMENT 3 IS AN UNKNOWN KEYWORD. '\n&ZMS               SETC  '&ZMS VALID KEYWORD CHOICE(S) ARE:'\n&ZMS               SETC  '&ZMS \"COMPLETE\"'      VALID KEYWORD\n&ZMS               SETC  '&ZMS OR \"NOCHECK\".'   VALID KEYWORD\n                   MNOTE 8,' &ZMS '\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG58B             ANOP  ,\n&XMFSCK            SETC  'COMPLETE'  SET DEFAULT KEYWORD\n.ZG58C             ANOP  ,\n&ZXMFSCK           SETC  'INPUT'     SET IN/OUTPUT\n.*------------------------------------------------------------------\n.***AG.KKCTL04 VALUE, OPT INPUT, ME KYWRDCTL -KEYWORD CONTROL\n.ZG59              ANOP  ,\n&ZXMF              SETC  'INPUT'     SET IN/OUTPUT\n                   AIF   (K'&XMF GT 0).ZG59E    VALID ARG\n                   AIF   (T'&MF EQ 'O').ZG59D   OMITTED\n&ZASYSLNDX         SETA  0\n.ZG59A             ANOP  ,           POSITIONAL MACRO KEY\n&ZASYSLNDX         SETA  &ZASYSLNDX+1\n                   AIF   (&ZASYSLNDX GT N'&SYSLIST).ZG59C\n&ZTLC              SETC 'MF'\n                   AIF   ('&SYSLIST(&ZASYSLNDX)' NE '&ZTLC').ZG59A\n.ZG59B             ANOP  ,\n&ZXMF              SETC  ''          RESET IN/OUTPUT\n&ZMS               SETC  'THE \"MF\" KEY'         *KOPTA* MNOTE\n&ZMS               SETC  '&ZMS MUST CONTAIN ONE'\n                   MNOTE 8,' &ZMS (OR MORE) ARGUMENT(S).'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n                   AGO   .ZG59E\n.ZG59C             ANOP  ,\n&ZXMF              SETC  ''          RESET IN/OUTPUT\n&ZMS               SETC  '\"MF='      *KUKWA* MNOTE\n&ZMS               SETC  '&ZMS.&MF\"'\n&ZMS               SETC  '&ZMS ARGUMENT 1 IS AN UNKNOWN KEYWORD. '\n&ZMS               SETC  '&ZMS VALID KEYWORD CHOICE(S) ARE:'\n&ZMS               SETC  '&ZMS \"S\",'            VALID KEYWORD\n&ZMS               SETC  '&ZMS \"L\",'            VALID KEYWORD\n&ZMS               SETC  '&ZMS \"M\",'            VALID KEYWORD\n&ZMS               SETC  '&ZMS OR \"E\".'         VALID KEYWORD\n                   MNOTE 8,' &ZMS '\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n                   AGO   .ZG59E\n.ZG59D             ANOP  ,\n&XMF               SETC  'S'         SET DEFAULT KEYWORD\n&XMFSCK            SETC  'COMPLETE'  COMPLETE CHECKING\n.ZG59E             ANOP  ,\n.********************************************************************\n.***AG.MF02  FULL MACRO SYNTAX CHECKING\n.********************************************************************\n                   ACTR  10000\n.*-------------------------------------------------------------------\n.***AG.MF03 MF=(SLME)\n                   AIF   ('&XMF' EQ 'L').ZGMFX\n                   AIF   ('&XMFSCK' NE 'COMPLETE').ZGMFX\n.*----------------------------------------------------------------***\n.***AG.KXVAR05 NAME, RQD INPUT, KEYS -XVARIABLE KEY\n                   AIF   (N'&PATTERNSTR LE 1).ZG5A  CK NUM\n&ZMS               SETC  '\"PATTERNSTR='         *KPOSA* MNOTE\n&ZMS               SETC  '&ZMS.&PATTERNSTR\"'\n&ZMS               SETC  '&ZMS \"PATTERNSTR\"'\n                   MNOTE 8,' &ZMS CAN HAVE ONLY 1 ARGUMENT.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG5A              ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KXVAR06 NAME, RQD INPUT, KEYS -XVARIABLE\n&ZXPATTERNSTR      SETC  'INPUT'     SET IN/OUTPUT\n&XPATTERNSTR       SETC  '&PATTERNSTR(1)'       SET XVARIABLE\n                   AIF   (N'&PATTERNSTR GT 1).ZG5B  MULTI PARMS\n&XPATTERNSTR       SETC  '&PATTERNSTR'          SET XVARIABLE\n.ZG5B              AIF   (K'&PATTERNSTR(1) GT 0).ZG5C\n&ZXPATTERNSTR      SETC  ''          RESET IN/OUTPUT\n&ZMS               SETC  ' '         *KRQDA*\n&ZMS               SETC  '&ZMS \"PATTERNSTR\" KEY AND ITS ARGUMENT'\n                   MNOTE 8,' &ZMS ARE REQUIRED.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG5C              ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KCK02 NAME, RQD INPUT, KEYS -GPR OUT OF RANGE\n                   AIF   (K'&ZXPATTERNSTR LE 0).ZG5R  NOT I/O\n                   AIF   ('&XPATTERNSTR'(1,1) NE '(').ZG5R\n&ZCGPR             SETC  '&XPATTERNSTR'(2,K'&XPATTERNSTR-2)\n                   AIF   ('&ZCGPR'(1,1) NE '0').ZG5P\n                   AIF   (K'&ZCGPR GT 2).ZG5Q\n                   AIF   ('&ZCGPR' EQ '0').ZG5Q\n&ZCGPR             SETC  '&ZCGPR'(2,1)\n                   AIF   (T'&ZCGPR NE 'N').ZG5Q  INVALID REG NAME\n.ZG5P              ANOP  ,\n                   AIF   (T'&ZCGPR NE 'N').ZG5R  NON NUMERIC\n                   AIF   ('&ZCGPR' LT '2').ZG5Q\n                   AIF   ('&ZCGPR' LE '12').ZG5R\n.ZG5Q              ANOP  ,\n&ZMS               SETC  '\"PATTERNSTR='         *KGPRA* MNOTE\n&ZMS               SETC  '&ZMS.&PATTERNSTR\"'\n&ZMS               SETC  '&ZMS ARGUMENT 1 MUST SPECIFY A REGISTER'\n                   MNOTE 8,' &ZMS IN THE RANGE (2)-(12).'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG5R              ANOP  ,\n.*----------------------------------------------------------------***\n.***AG.KXVAR05 NAME, RQD INPUT, KEYS -XVARIABLE KEY\n                   AIF   (N'&PATTERNSTRLEN LE 1).ZG8A  CK NUM\n&ZMS               SETC  '\"PATTERNSTRLEN='      *KPOSA* MNOTE\n&ZMS               SETC  '&ZMS.&PATTERNSTRLEN\"'\n&ZMS               SETC  '&ZMS \"PATTERNSTRLEN\"'\n                   MNOTE 8,' &ZMS CAN HAVE ONLY 1 ARGUMENT.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG8A              ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KXVAR06 NAME, RQD INPUT, KEYS -XVARIABLE\n&ZXPATTERNSTRLEN   SETC  'INPUT'     SET IN/OUTPUT\n&XPATTERNSTRLEN    SETC  '&PATTERNSTRLEN(1)'    SET XVARIABLE\n                   AIF   (N'&PATTERNSTRLEN GT 1).ZG8B  MULTI PARMS\n&XPATTERNSTRLEN    SETC  '&PATTERNSTRLEN'       SET XVARIABLE\n.ZG8B              AIF   (K'&PATTERNSTRLEN(1) GT 0).ZG8C\n&ZXPATTERNSTRLEN   SETC  ''          RESET IN/OUTPUT\n&ZMS               SETC  ' '         *KRQDA*\n&ZMS               SETC  '&ZMS \"PATTERNSTRLEN\" KEY AND ITS ARGUMENT'\n                   MNOTE 8,' &ZMS ARE REQUIRED.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG8C              ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KCK02 NAME, RQD INPUT, KEYS -GPR OUT OF RANGE\n                   AIF   (K'&ZXPATTERNSTRLEN LE 0).ZG8R  NOT I/O\n                   AIF   ('&XPATTERNSTRLEN'(1,1) NE '(').ZG8R\n&ZCGPR             SETC  '&XPATTERNSTRLEN'(2,K'&XPATTERNSTRLEN-2)\n                   AIF   ('&ZCGPR'(1,1) NE '0').ZG8P\n                   AIF   (K'&ZCGPR GT 2).ZG8Q\n                   AIF   ('&ZCGPR' EQ '0').ZG8Q\n&ZCGPR             SETC  '&ZCGPR'(2,1)\n                   AIF   (T'&ZCGPR NE 'N').ZG8Q  INVALID REG NAME\n.ZG8P              ANOP  ,\n                   AIF   (T'&ZCGPR NE 'N').ZG8R  NON NUMERIC\n                   AIF   ('&ZCGPR' LT '2').ZG8Q\n                   AIF   ('&ZCGPR' LE '12').ZG8R\n.ZG8Q              ANOP  ,\n&ZMS               SETC  '\"PATTERNSTRLEN='      *KGPRA* MNOTE\n&ZMS               SETC  '&ZMS.&PATTERNSTRLEN\"'\n&ZMS               SETC  '&ZMS ARGUMENT 1 MUST SPECIFY A REGISTER'\n                   MNOTE 8,' &ZMS IN THE RANGE (2)-(12).'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG8R              ANOP  ,\n.*----------------------------------------------------------------***\n.***AG.KXVAR05 NAME, RQD INPUT, KEYS -XVARIABLE KEY\n                   AIF   (N'&STRING LE 1).ZG11A  CK NUM\n&ZMS               SETC  '\"STRING='  *KPOSA* MNOTE\n&ZMS               SETC  '&ZMS.&STRING\"'\n&ZMS               SETC  '&ZMS \"STRING\"'\n                   MNOTE 8,' &ZMS CAN HAVE ONLY 1 ARGUMENT.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG11A             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KXVAR06 NAME, RQD INPUT, KEYS -XVARIABLE\n&ZXSTRING          SETC  'INPUT'     SET IN/OUTPUT\n&XSTRING           SETC  '&STRING(1)'           SET XVARIABLE\n                   AIF   (N'&STRING GT 1).ZG11B  MULTI PARMS\n&XSTRING           SETC  '&STRING'   SET XVARIABLE\n.ZG11B             AIF   (K'&STRING(1) GT 0).ZG11C\n&ZXSTRING          SETC  ''          RESET IN/OUTPUT\n&ZMS               SETC  ' '         *KRQDA*\n&ZMS               SETC  '&ZMS \"STRING\" KEY AND ITS ARGUMENT'\n                   MNOTE 8,' &ZMS ARE REQUIRED.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG11C             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KCK02 NAME, RQD INPUT, KEYS -GPR OUT OF RANGE\n                   AIF   (K'&ZXSTRING LE 0).ZG11R  NOT I/O\n                   AIF   ('&XSTRING'(1,1) NE '(').ZG11R\n&ZCGPR             SETC  '&XSTRING'(2,K'&XSTRING-2)\n                   AIF   ('&ZCGPR'(1,1) NE '0').ZG11P\n                   AIF   (K'&ZCGPR GT 2).ZG11Q\n                   AIF   ('&ZCGPR' EQ '0').ZG11Q\n&ZCGPR             SETC  '&ZCGPR'(2,1)\n                   AIF   (T'&ZCGPR NE 'N').ZG11Q  INVALID REG NAME\n.ZG11P             ANOP  ,\n                   AIF   (T'&ZCGPR NE 'N').ZG11R  NON NUMERIC\n                   AIF   ('&ZCGPR' LT '2').ZG11Q\n                   AIF   ('&ZCGPR' LE '12').ZG11R\n.ZG11Q             ANOP  ,\n&ZMS               SETC  '\"STRING='  *KGPRA* MNOTE\n&ZMS               SETC  '&ZMS.&STRING\"'\n&ZMS               SETC  '&ZMS ARGUMENT 1 MUST SPECIFY A REGISTER'\n                   MNOTE 8,' &ZMS IN THE RANGE (2)-(12).'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG11R             ANOP  ,\n.*----------------------------------------------------------------***\n.***AG.KXVAR05 NAME, RQD INPUT, KEYS -XVARIABLE KEY\n                   AIF   (N'&STRINGLEN LE 1).ZG14A  CK NUM\n&ZMS               SETC  '\"STRINGLEN='          *KPOSA* MNOTE\n&ZMS               SETC  '&ZMS.&STRINGLEN\"'\n&ZMS               SETC  '&ZMS \"STRINGLEN\"'\n                   MNOTE 8,' &ZMS CAN HAVE ONLY 1 ARGUMENT.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG14A             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KXVAR06 NAME, RQD INPUT, KEYS -XVARIABLE\n&ZXSTRINGLEN       SETC  'INPUT'     SET IN/OUTPUT\n&XSTRINGLEN        SETC  '&STRINGLEN(1)'        SET XVARIABLE\n                   AIF   (N'&STRINGLEN GT 1).ZG14B  MULTI PARMS\n&XSTRINGLEN        SETC  '&STRINGLEN'           SET XVARIABLE\n.ZG14B             AIF   (K'&STRINGLEN(1) GT 0).ZG14C\n&ZXSTRINGLEN       SETC  ''          RESET IN/OUTPUT\n&ZMS               SETC  ' '         *KRQDA*\n&ZMS               SETC  '&ZMS \"STRINGLEN\" KEY AND ITS ARGUMENT'\n                   MNOTE 8,' &ZMS ARE REQUIRED.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG14C             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KCK02 NAME, RQD INPUT, KEYS -GPR OUT OF RANGE\n                   AIF   (K'&ZXSTRINGLEN LE 0).ZG14R  NOT I/O\n                   AIF   ('&XSTRINGLEN'(1,1) NE '(').ZG14R\n&ZCGPR             SETC  '&XSTRINGLEN'(2,K'&XSTRINGLEN-2)\n                   AIF   ('&ZCGPR'(1,1) NE '0').ZG14P\n                   AIF   (K'&ZCGPR GT 2).ZG14Q\n                   AIF   ('&ZCGPR' EQ '0').ZG14Q\n&ZCGPR             SETC  '&ZCGPR'(2,1)\n                   AIF   (T'&ZCGPR NE 'N').ZG14Q  INVALID REG NAME\n.ZG14P             ANOP  ,\n                   AIF   (T'&ZCGPR NE 'N').ZG14R  NON NUMERIC\n                   AIF   ('&ZCGPR' LT '2').ZG14Q\n                   AIF   ('&ZCGPR' LE '12').ZG14R\n.ZG14Q             ANOP  ,\n&ZMS               SETC  '\"STRINGLEN='          *KGPRA* MNOTE\n&ZMS               SETC  '&ZMS.&STRINGLEN\"'\n&ZMS               SETC  '&ZMS ARGUMENT 1 MUST SPECIFY A REGISTER'\n                   MNOTE 8,' &ZMS IN THE RANGE (2)-(12).'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG14R             ANOP  ,\n.*----------------------------------------------------------------***\n.***AG.KXVAR05 NAME, RQD INPUT, KEYS -XVARIABLE KEY\n                   AIF   (N'&ZEROORMORE LE 1).ZG17A  CK NUM\n&ZMS               SETC  '\"ZEROORMORE='         *KPOSA* MNOTE\n&ZMS               SETC  '&ZMS.&ZEROORMORE\"'\n&ZMS               SETC  '&ZMS \"ZEROORMORE\"'\n                   MNOTE 8,' &ZMS CAN HAVE ONLY 1 ARGUMENT.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG17A             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KXVAR06 NAME, RQD INPUT, KEYS -XVARIABLE\n&ZXZEROORMORE      SETC  'INPUT'     SET IN/OUTPUT\n&XZEROORMORE       SETC  '&ZEROORMORE(1)'       SET XVARIABLE\n                   AIF   (N'&ZEROORMORE GT 1).ZG17B  MULTI PARMS\n&XZEROORMORE       SETC  '&ZEROORMORE'          SET XVARIABLE\n.ZG17B             AIF   (K'&ZEROORMORE(1) GT 0).ZG17C\n&ZXZEROORMORE      SETC  ''          RESET IN/OUTPUT\n&ZMS               SETC  ' '         *KRQDA*\n&ZMS               SETC  '&ZMS \"ZEROORMORE\" KEY AND ITS ARGUMENT'\n                   MNOTE 8,' &ZMS ARE REQUIRED.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG17C             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KCK02 NAME, RQD INPUT, KEYS -GPR OUT OF RANGE\n                   AIF   (K'&ZXZEROORMORE LE 0).ZG17R  NOT I/O\n                   AIF   ('&XZEROORMORE'(1,1) NE '(').ZG17R\n&ZCGPR             SETC  '&XZEROORMORE'(2,K'&XZEROORMORE-2)\n                   AIF   ('&ZCGPR'(1,1) NE '0').ZG17P\n                   AIF   (K'&ZCGPR GT 2).ZG17Q\n                   AIF   ('&ZCGPR' EQ '0').ZG17Q\n&ZCGPR             SETC  '&ZCGPR'(2,1)\n                   AIF   (T'&ZCGPR NE 'N').ZG17Q  INVALID REG NAME\n.ZG17P             ANOP  ,\n                   AIF   (T'&ZCGPR NE 'N').ZG17R  NON NUMERIC\n                   AIF   ('&ZCGPR' LT '2').ZG17Q\n                   AIF   ('&ZCGPR' LE '12').ZG17R\n.ZG17Q             ANOP  ,\n&ZMS               SETC  '\"ZEROORMORE='         *KGPRA* MNOTE\n&ZMS               SETC  '&ZMS.&ZEROORMORE\"'\n&ZMS               SETC  '&ZMS ARGUMENT 1 MUST SPECIFY A REGISTER'\n                   MNOTE 8,' &ZMS IN THE RANGE (2)-(12).'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG17R             ANOP  ,\n.*----------------------------------------------------------------***\n.***AG.KXVAR05 NAME, RQD INPUT, KEYS -XVARIABLE KEY\n                   AIF   (N'&ONECHAR LE 1).ZG20A  CK NUM\n&ZMS               SETC  '\"ONECHAR='            *KPOSA* MNOTE\n&ZMS               SETC  '&ZMS.&ONECHAR\"'\n&ZMS               SETC  '&ZMS \"ONECHAR\"'\n                   MNOTE 8,' &ZMS CAN HAVE ONLY 1 ARGUMENT.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG20A             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KXVAR06 NAME, RQD INPUT, KEYS -XVARIABLE\n&ZXONECHAR         SETC  'INPUT'     SET IN/OUTPUT\n&XONECHAR          SETC  '&ONECHAR(1)'          SET XVARIABLE\n                   AIF   (N'&ONECHAR GT 1).ZG20B  MULTI PARMS\n&XONECHAR          SETC  '&ONECHAR'  SET XVARIABLE\n.ZG20B             AIF   (K'&ONECHAR(1) GT 0).ZG20C\n&ZXONECHAR         SETC  ''          RESET IN/OUTPUT\n&ZMS               SETC  ' '         *KRQDA*\n&ZMS               SETC  '&ZMS \"ONECHAR\" KEY AND ITS ARGUMENT'\n                   MNOTE 8,' &ZMS ARE REQUIRED.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG20C             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KCK02 NAME, RQD INPUT, KEYS -GPR OUT OF RANGE\n                   AIF   (K'&ZXONECHAR LE 0).ZG20R  NOT I/O\n                   AIF   ('&XONECHAR'(1,1) NE '(').ZG20R\n&ZCGPR             SETC  '&XONECHAR'(2,K'&XONECHAR-2)\n                   AIF   ('&ZCGPR'(1,1) NE '0').ZG20P\n                   AIF   (K'&ZCGPR GT 2).ZG20Q\n                   AIF   ('&ZCGPR' EQ '0').ZG20Q\n&ZCGPR             SETC  '&ZCGPR'(2,1)\n                   AIF   (T'&ZCGPR NE 'N').ZG20Q  INVALID REG NAME\n.ZG20P             ANOP  ,\n                   AIF   (T'&ZCGPR NE 'N').ZG20R  NON NUMERIC\n                   AIF   ('&ZCGPR' LT '2').ZG20Q\n                   AIF   ('&ZCGPR' LE '12').ZG20R\n.ZG20Q             ANOP  ,\n&ZMS               SETC  '\"ONECHAR='            *KGPRA* MNOTE\n&ZMS               SETC  '&ZMS.&ONECHAR\"'\n&ZMS               SETC  '&ZMS ARGUMENT 1 MUST SPECIFY A REGISTER'\n                   MNOTE 8,' &ZMS IN THE RANGE (2)-(12).'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG20R             ANOP  ,\n.*----------------------------------------------------------------***\n.***AG.KXVAR05 NAME, OPT INPUT, KEYS -XVARIABLE KEY\n                   AIF   (N'&DELIMITER LE 1).ZG23A  CK NUM\n&ZMS               SETC  '\"DELIMITER='          *KPOSA* MNOTE\n&ZMS               SETC  '&ZMS.&DELIMITER\"'\n&ZMS               SETC  '&ZMS \"DELIMITER\"'\n                   MNOTE 8,' &ZMS CAN HAVE ONLY 1 ARGUMENT.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG23A             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KXVAR13 NAME, OPT INPUT, KEYS -XVARIABLE\n&ZXDELIMITER       SETC  'INPUT'     SET IN/OUTPUT\n&XDELIMITER        SETC  'LENGTHS_WERE_SET'\n                   AIF   (K'&DELIMITER(1) LE 0).ZG23B  PARM\n&XDELIMITER        SETC  '&DELIMITER(1)'        SET XVARIABLE\n                   AIF   (N'&DELIMITER GT 1).ZG23B  MULTI PARMS\n&XDELIMITER        SETC  '&DELIMITER'           SET XVARIABLE\n.ZG23B             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KCK02 NAME, OPT INPUT, KEYS -GPR OUT OF RANGE\n                   AIF   (K'&ZXDELIMITER LE 0).ZG23R  NOT I/O\n                   AIF   ('&XDELIMITER' EQ 'LENGTHS_WERE_SET').ZG23R\n                   AIF   ('&XDELIMITER'(1,1) NE '(').ZG23R\n&ZCGPR             SETC  '&XDELIMITER'(2,K'&XDELIMITER-2)\n                   AIF   ('&ZCGPR'(1,1) NE '0').ZG23P\n                   AIF   (K'&ZCGPR GT 2).ZG23Q\n                   AIF   ('&ZCGPR' EQ '0').ZG23Q\n&ZCGPR             SETC  '&ZCGPR'(2,1)\n                   AIF   (T'&ZCGPR NE 'N').ZG23Q  INVALID REG NAME\n.ZG23P             ANOP  ,\n                   AIF   (T'&ZCGPR NE 'N').ZG23R  NON NUMERIC\n                   AIF   ('&ZCGPR' LT '2').ZG23Q\n                   AIF   ('&ZCGPR' LE '12').ZG23R\n.ZG23Q             ANOP  ,\n&ZMS               SETC  '\"DELIMITER='          *KGPRA* MNOTE\n&ZMS               SETC  '&ZMS.&DELIMITER\"'\n&ZMS               SETC  '&ZMS ARGUMENT 1 MUST SPECIFY A REGISTER'\n                   MNOTE 8,' &ZMS IN THE RANGE (2)-(12).'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG23R             ANOP  ,\n.*----------------------------------------------------------------***\n.***AG.KXVAR05 NAME, OPT INPUT, KEYS -XVARIABLE KEY\n                   AIF   (N'&WORKAREA LE 1).ZG26A  CK NUM\n&ZMS               SETC  '\"WORKAREA='           *KPOSA* MNOTE\n&ZMS               SETC  '&ZMS.&WORKAREA\"'\n&ZMS               SETC  '&ZMS \"WORKAREA\"'\n                   MNOTE 8,' &ZMS CAN HAVE ONLY 1 ARGUMENT.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG26A             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KXVAR13 NAME, OPT INPUT, KEYS -XVARIABLE\n&ZXWORKAREA        SETC  'INPUT'     SET IN/OUTPUT\n&XWORKAREA         SETC  'NO_WORKAREA'\n                   AIF   (K'&WORKAREA(1) LE 0).ZG26B  PARM\n&XWORKAREA         SETC  '&WORKAREA(1)'         SET XVARIABLE\n                   AIF   (N'&WORKAREA GT 1).ZG26B  MULTI PARMS\n&XWORKAREA         SETC  '&WORKAREA'            SET XVARIABLE\n.ZG26B             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KCK02 NAME, OPT INPUT, KEYS -GPR OUT OF RANGE\n                   AIF   (K'&ZXWORKAREA LE 0).ZG26R  NOT I/O\n                   AIF   ('&XWORKAREA' EQ 'NO_WORKAREA').ZG26R\n                   AIF   ('&XWORKAREA'(1,1) NE '(').ZG26R\n&ZCGPR             SETC  '&XWORKAREA'(2,K'&XWORKAREA-2)\n                   AIF   ('&ZCGPR'(1,1) NE '0').ZG26P\n                   AIF   (K'&ZCGPR GT 2).ZG26Q\n                   AIF   ('&ZCGPR' EQ '0').ZG26Q\n&ZCGPR             SETC  '&ZCGPR'(2,1)\n                   AIF   (T'&ZCGPR NE 'N').ZG26Q  INVALID REG NAME\n.ZG26P             ANOP  ,\n                   AIF   (T'&ZCGPR NE 'N').ZG26R  NON NUMERIC\n                   AIF   ('&ZCGPR' LT '2').ZG26Q\n                   AIF   ('&ZCGPR' LE '12').ZG26R\n.ZG26Q             ANOP  ,\n&ZMS               SETC  '\"WORKAREA='           *KGPRA* MNOTE\n&ZMS               SETC  '&ZMS.&WORKAREA\"'\n&ZMS               SETC  '&ZMS ARGUMENT 1 MUST SPECIFY A REGISTER'\n                   MNOTE 8,' &ZMS IN THE RANGE (2)-(12).'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG26R             ANOP  ,\n.*----------------------------------------------------------------***\n.***AG.KXVAR05 NAME, OPT OUTPUT, KEYS -XVARIABLE KEY\n                   AIF   (N'&RETCODE LE 1).ZG29A  CK NUM\n&ZMS               SETC  '\"RETCODE='            *KPOSA* MNOTE\n&ZMS               SETC  '&ZMS.&RETCODE\"'\n&ZMS               SETC  '&ZMS \"RETCODE\"'\n                   MNOTE 8,' &ZMS CAN HAVE ONLY 1 ARGUMENT.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG29A             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KXVAR14 NAME, OPT OUTPUT, KEYS -XVARIABLE\n                   AIF   (K'&RETCODE(1) LE 0).ZG29C  NO PARM\n&ZXRETCODE         SETC  'OUTPUT'    SET OUTPUT\n&XRETCODE          SETC  '&RETCODE(1)'          SET XVARIABLE\n                   AIF   (N'&RETCODE GT 1).ZG29C\n&XRETCODE          SETC  '&RETCODE'  SET XVARIABLE\n.ZG29C             ANOP  ,\n.*-------------------------------------------------------------------\n.***AG.KCK02 NAME, OPT OUTPUT, KEYS -GPR OUT OF RANGE\n                   AIF   (K'&ZXRETCODE LE 0).ZG29R  NOT I/O\n                   AIF   ('&XRETCODE'(1,1) NE '(').ZG29R\n&ZCGPR             SETC  '&XRETCODE'(2,K'&XRETCODE-2)\n                   AIF   ('&ZCGPR'(1,1) NE '0').ZG29P\n                   AIF   (K'&ZCGPR GT 2).ZG29Q\n                   AIF   ('&ZCGPR' EQ '0').ZG29Q\n&ZCGPR             SETC  '&ZCGPR'(2,1)\n                   AIF   (T'&ZCGPR NE 'N').ZG29Q  INVALID REG NAME\n.ZG29P             ANOP  ,\n                   AIF   (T'&ZCGPR NE 'N').ZG29R  NON NUMERIC\n                   AIF   ('&ZCGPR' LT '2').ZG29Q\n                   AIF   ('&ZCGPR' LE '12').ZG29R\n.ZG29Q             ANOP  ,\n&ZMS               SETC  '\"RETCODE='            *KGPRA* MNOTE\n&ZMS               SETC  '&ZMS.&RETCODE\"'\n&ZMS               SETC  '&ZMS ARGUMENT 1 MUST SPECIFY A REGISTER'\n                   MNOTE 8,' &ZMS IN THE RANGE (2)-(12).'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZG29R             ANOP  ,\n.******************************************************************\n.***AH.P00 CHECK STANDALONE POSITIONAL VARIABLES\n.******************************************************************\n                   ACTR  10000\n.*----------------------------------------------------------------***\n.***AH.P02 EXTRA POSITIONALS\n                   AIF   (N'&SYSLIST LE 0).ZGLISTX  NO EXTRAS\n&ZCVAL             SETC  ''          ERROR FIELD\n&ZAWRK             SETA  0           POSITIONAL NUMBER\n.ZGLIST2           ANOP  ,\n&ZAWRK             SETA  &ZAWRK+1    NEXT POSITIONAL\n                   AIF   (&ZAWRK GT N'&SYSLIST).ZGLIST3  DONE\n&ZCVAL             SETC '&ZCVAL,&SYSLIST(&ZAWRK)'  EXTRA\n                   AGO   .ZGLIST2\n.*\n.ZGLIST3           ANOP  ,\n&ZCVAL             SETC '&ZCVAL'(2,K'&ZCVAL-1)  STRIP COMMA\n&ZMS               SETC  'POSITIONAL ARGUMENT(S),'  *PPOSA* MNOTE\n&ZMS               SETC  '&ZMS \"&ZCVAL\"'\n&ZMS               SETC  '&ZMS CANNOT BE USED.'\n&ZMS               SETC  '&ZMS NO POSITIONAL ARGUMENTS'\n                   MNOTE 8,' &ZMS ARE ALLOWED.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZGLISTX           ANOP  ,\n&ZASYSLNDX         SETA  0\n.*-------------------------------------------------------------------\n.***AG.MF04 MF=(SLME)\n.ZGMFX             ANOP  ,           END OF FULL SYNTAX CHECK\n.********************************************************************\n.***AE.MF01   PARTIAL MACRO SYNTAX CHECKING\n.********************************************************************\n                   ACTR  10000\n.*-------------------------------------------------------------------\n.***AE.MF01 MF=(SLME)\n                   AIF   ('&XMF' EQ 'L').ZEMFX\n                   AIF   ('&XMFSCK' NE 'NOCHECK').ZEMFX\n.********************************************************************\n.***AE.KC00 INITIALIZE KEYWORD CONTROL VARIABLES\n.********************************************************************\n.*----------------------------------------------------------------***\n.***AE.KXVAR03 NAME, RQD INPUT, KEYS -XVAR KEY\n                   AIF   (N'&PATTERNSTR LE 1).ZE5A  CK NUM\n&ZMS               SETC  '\"PATTERNSTR='         *KPOSA* MNOTE\n&ZMS               SETC  '&ZMS.&PATTERNSTR\"'\n&ZMS               SETC  '&ZMS \"PATTERNSTR\"'\n                   MNOTE 8,' &ZMS CAN HAVE ONLY 1 ARGUMENT.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZE5A              ANOP  ,\n.*-------------------------------------------------------------------\n.***AE.KXVAR04 NAME, RQD INPUT, KEYS -XVAR ARGUMENT\n                   AIF   (K'&PATTERNSTR(1) LE 0).ZE5B NO PRM\n&ZXPATTERNSTR      SETC  'INPUT'     SET IN/OUTPUT\n&XPATTERNSTR       SETC  '&PATTERNSTR(1)'       SET XVARIABLE\n                   AIF   (N'&PATTERNSTR GT 1).ZE5B\n.*                 ANOP              MULTIPLE PARMS\n&XPATTERNSTR       SETC  '&PATTERNSTR'          SET XVARIABLE\n.ZE5B              ANOP  ,\n.*-------------------------------------------------------------------\n.***AE.KCK02 NAME, RQD INPUT, KEYS -GPR OUT OF RANGE\n                   AIF   (K'&ZXPATTERNSTR LE 0).ZE5R  NOT I/O\n                   AIF   ('&XPATTERNSTR'(1,1) NE '(').ZE5R\n&ZCGPR             SETC  '&XPATTERNSTR'(2,K'&XPATTERNSTR-2)\n                   AIF   ('&ZCGPR'(1,1) NE '0').ZE5P\n                   AIF   (K'&ZCGPR GT 2).ZE5Q\n                   AIF   ('&ZCGPR' EQ '0').ZE5Q\n&ZCGPR             SETC  '&ZCGPR'(2,1)\n                   AIF   (T'&ZCGPR NE 'N').ZE5Q  INVALID REG NAME\n.ZE5P              ANOP  ,\n                   AIF   (T'&ZCGPR NE 'N').ZE5R  NON NUMERIC\n                   AIF   ('&ZCGPR' LT '2').ZE5Q\n                   AIF   ('&ZCGPR' LE '12').ZE5R\n.ZE5Q              ANOP  ,\n&ZMS               SETC  '\"PATTERNSTR='         *KGPRA* MNOTE\n&ZMS               SETC  '&ZMS.&PATTERNSTR\"'\n&ZMS               SETC  '&ZMS ARGUMENT 1 MUST SPECIFY A REGISTER'\n                   MNOTE 8,' &ZMS IN THE RANGE (2)-(12).'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZE5R              ANOP  ,\n.*----------------------------------------------------------------***\n.***AE.KXVAR03 NAME, RQD INPUT, KEYS -XVAR KEY\n                   AIF   (N'&PATTERNSTRLEN LE 1).ZE8A  CK NUM\n&ZMS               SETC  '\"PATTERNSTRLEN='      *KPOSA* MNOTE\n&ZMS               SETC  '&ZMS.&PATTERNSTRLEN\"'\n&ZMS               SETC  '&ZMS \"PATTERNSTRLEN\"'\n                   MNOTE 8,' &ZMS CAN HAVE ONLY 1 ARGUMENT.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZE8A              ANOP  ,\n.*-------------------------------------------------------------------\n.***AE.KXVAR04 NAME, RQD INPUT, KEYS -XVAR ARGUMENT\n                   AIF   (K'&PATTERNSTRLEN(1) LE 0).ZE8B NO PRM\n&ZXPATTERNSTRLEN   SETC  'INPUT'     SET IN/OUTPUT\n&XPATTERNSTRLEN    SETC  '&PATTERNSTRLEN(1)'    SET XVARIABLE\n                   AIF   (N'&PATTERNSTRLEN GT 1).ZE8B\n.*                 ANOP              MULTIPLE PARMS\n&XPATTERNSTRLEN    SETC  '&PATTERNSTRLEN'       SET XVARIABLE\n.ZE8B              ANOP  ,\n.*-------------------------------------------------------------------\n.***AE.KCK02 NAME, RQD INPUT, KEYS -GPR OUT OF RANGE\n                   AIF   (K'&ZXPATTERNSTRLEN LE 0).ZE8R  NOT I/O\n                   AIF   ('&XPATTERNSTRLEN'(1,1) NE '(').ZE8R\n&ZCGPR             SETC  '&XPATTERNSTRLEN'(2,K'&XPATTERNSTRLEN-2)\n                   AIF   ('&ZCGPR'(1,1) NE '0').ZE8P\n                   AIF   (K'&ZCGPR GT 2).ZE8Q\n                   AIF   ('&ZCGPR' EQ '0').ZE8Q\n&ZCGPR             SETC  '&ZCGPR'(2,1)\n                   AIF   (T'&ZCGPR NE 'N').ZE8Q  INVALID REG NAME\n.ZE8P              ANOP  ,\n                   AIF   (T'&ZCGPR NE 'N').ZE8R  NON NUMERIC\n                   AIF   ('&ZCGPR' LT '2').ZE8Q\n                   AIF   ('&ZCGPR' LE '12').ZE8R\n.ZE8Q              ANOP  ,\n&ZMS               SETC  '\"PATTERNSTRLEN='      *KGPRA* MNOTE\n&ZMS               SETC  '&ZMS.&PATTERNSTRLEN\"'\n&ZMS               SETC  '&ZMS ARGUMENT 1 MUST SPECIFY A REGISTER'\n                   MNOTE 8,' &ZMS IN THE RANGE (2)-(12).'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZE8R              ANOP  ,\n.*----------------------------------------------------------------***\n.***AE.KXVAR03 NAME, RQD INPUT, KEYS -XVAR KEY\n                   AIF   (N'&STRING LE 1).ZE11A  CK NUM\n&ZMS               SETC  '\"STRING='  *KPOSA* MNOTE\n&ZMS               SETC  '&ZMS.&STRING\"'\n&ZMS               SETC  '&ZMS \"STRING\"'\n                   MNOTE 8,' &ZMS CAN HAVE ONLY 1 ARGUMENT.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZE11A             ANOP  ,\n.*-------------------------------------------------------------------\n.***AE.KXVAR04 NAME, RQD INPUT, KEYS -XVAR ARGUMENT\n                   AIF   (K'&STRING(1) LE 0).ZE11B NO PRM\n&ZXSTRING          SETC  'INPUT'     SET IN/OUTPUT\n&XSTRING           SETC  '&STRING(1)'           SET XVARIABLE\n                   AIF   (N'&STRING GT 1).ZE11B\n.*                 ANOP              MULTIPLE PARMS\n&XSTRING           SETC  '&STRING'   SET XVARIABLE\n.ZE11B             ANOP  ,\n.*-------------------------------------------------------------------\n.***AE.KCK02 NAME, RQD INPUT, KEYS -GPR OUT OF RANGE\n                   AIF   (K'&ZXSTRING LE 0).ZE11R  NOT I/O\n                   AIF   ('&XSTRING'(1,1) NE '(').ZE11R\n&ZCGPR             SETC  '&XSTRING'(2,K'&XSTRING-2)\n                   AIF   ('&ZCGPR'(1,1) NE '0').ZE11P\n                   AIF   (K'&ZCGPR GT 2).ZE11Q\n                   AIF   ('&ZCGPR' EQ '0').ZE11Q\n&ZCGPR             SETC  '&ZCGPR'(2,1)\n                   AIF   (T'&ZCGPR NE 'N').ZE11Q  INVALID REG NAME\n.ZE11P             ANOP  ,\n                   AIF   (T'&ZCGPR NE 'N').ZE11R  NON NUMERIC\n                   AIF   ('&ZCGPR' LT '2').ZE11Q\n                   AIF   ('&ZCGPR' LE '12').ZE11R\n.ZE11Q             ANOP  ,\n&ZMS               SETC  '\"STRING='  *KGPRA* MNOTE\n&ZMS               SETC  '&ZMS.&STRING\"'\n&ZMS               SETC  '&ZMS ARGUMENT 1 MUST SPECIFY A REGISTER'\n                   MNOTE 8,' &ZMS IN THE RANGE (2)-(12).'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZE11R             ANOP  ,\n.*----------------------------------------------------------------***\n.***AE.KXVAR03 NAME, RQD INPUT, KEYS -XVAR KEY\n                   AIF   (N'&STRINGLEN LE 1).ZE14A  CK NUM\n&ZMS               SETC  '\"STRINGLEN='          *KPOSA* MNOTE\n&ZMS               SETC  '&ZMS.&STRINGLEN\"'\n&ZMS               SETC  '&ZMS \"STRINGLEN\"'\n                   MNOTE 8,' &ZMS CAN HAVE ONLY 1 ARGUMENT.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZE14A             ANOP  ,\n.*-------------------------------------------------------------------\n.***AE.KXVAR04 NAME, RQD INPUT, KEYS -XVAR ARGUMENT\n                   AIF   (K'&STRINGLEN(1) LE 0).ZE14B NO PRM\n&ZXSTRINGLEN       SETC  'INPUT'     SET IN/OUTPUT\n&XSTRINGLEN        SETC  '&STRINGLEN(1)'        SET XVARIABLE\n                   AIF   (N'&STRINGLEN GT 1).ZE14B\n.*                 ANOP              MULTIPLE PARMS\n&XSTRINGLEN        SETC  '&STRINGLEN'           SET XVARIABLE\n.ZE14B             ANOP  ,\n.*-------------------------------------------------------------------\n.***AE.KCK02 NAME, RQD INPUT, KEYS -GPR OUT OF RANGE\n                   AIF   (K'&ZXSTRINGLEN LE 0).ZE14R  NOT I/O\n                   AIF   ('&XSTRINGLEN'(1,1) NE '(').ZE14R\n&ZCGPR             SETC  '&XSTRINGLEN'(2,K'&XSTRINGLEN-2)\n                   AIF   ('&ZCGPR'(1,1) NE '0').ZE14P\n                   AIF   (K'&ZCGPR GT 2).ZE14Q\n                   AIF   ('&ZCGPR' EQ '0').ZE14Q\n&ZCGPR             SETC  '&ZCGPR'(2,1)\n                   AIF   (T'&ZCGPR NE 'N').ZE14Q  INVALID REG NAME\n.ZE14P             ANOP  ,\n                   AIF   (T'&ZCGPR NE 'N').ZE14R  NON NUMERIC\n                   AIF   ('&ZCGPR' LT '2').ZE14Q\n                   AIF   ('&ZCGPR' LE '12').ZE14R\n.ZE14Q             ANOP  ,\n&ZMS               SETC  '\"STRINGLEN='          *KGPRA* MNOTE\n&ZMS               SETC  '&ZMS.&STRINGLEN\"'\n&ZMS               SETC  '&ZMS ARGUMENT 1 MUST SPECIFY A REGISTER'\n                   MNOTE 8,' &ZMS IN THE RANGE (2)-(12).'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZE14R             ANOP  ,\n.*----------------------------------------------------------------***\n.***AE.KXVAR03 NAME, RQD INPUT, KEYS -XVAR KEY\n                   AIF   (N'&ZEROORMORE LE 1).ZE17A  CK NUM\n&ZMS               SETC  '\"ZEROORMORE='         *KPOSA* MNOTE\n&ZMS               SETC  '&ZMS.&ZEROORMORE\"'\n&ZMS               SETC  '&ZMS \"ZEROORMORE\"'\n                   MNOTE 8,' &ZMS CAN HAVE ONLY 1 ARGUMENT.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZE17A             ANOP  ,\n.*-------------------------------------------------------------------\n.***AE.KXVAR04 NAME, RQD INPUT, KEYS -XVAR ARGUMENT\n                   AIF   (K'&ZEROORMORE(1) LE 0).ZE17B NO PRM\n&ZXZEROORMORE      SETC  'INPUT'     SET IN/OUTPUT\n&XZEROORMORE       SETC  '&ZEROORMORE(1)'       SET XVARIABLE\n                   AIF   (N'&ZEROORMORE GT 1).ZE17B\n.*                 ANOP              MULTIPLE PARMS\n&XZEROORMORE       SETC  '&ZEROORMORE'          SET XVARIABLE\n.ZE17B             ANOP  ,\n.*-------------------------------------------------------------------\n.***AE.KCK02 NAME, RQD INPUT, KEYS -GPR OUT OF RANGE\n                   AIF   (K'&ZXZEROORMORE LE 0).ZE17R  NOT I/O\n                   AIF   ('&XZEROORMORE'(1,1) NE '(').ZE17R\n&ZCGPR             SETC  '&XZEROORMORE'(2,K'&XZEROORMORE-2)\n                   AIF   ('&ZCGPR'(1,1) NE '0').ZE17P\n                   AIF   (K'&ZCGPR GT 2).ZE17Q\n                   AIF   ('&ZCGPR' EQ '0').ZE17Q\n&ZCGPR             SETC  '&ZCGPR'(2,1)\n                   AIF   (T'&ZCGPR NE 'N').ZE17Q  INVALID REG NAME\n.ZE17P             ANOP  ,\n                   AIF   (T'&ZCGPR NE 'N').ZE17R  NON NUMERIC\n                   AIF   ('&ZCGPR' LT '2').ZE17Q\n                   AIF   ('&ZCGPR' LE '12').ZE17R\n.ZE17Q             ANOP  ,\n&ZMS               SETC  '\"ZEROORMORE='         *KGPRA* MNOTE\n&ZMS               SETC  '&ZMS.&ZEROORMORE\"'\n&ZMS               SETC  '&ZMS ARGUMENT 1 MUST SPECIFY A REGISTER'\n                   MNOTE 8,' &ZMS IN THE RANGE (2)-(12).'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZE17R             ANOP  ,\n.*----------------------------------------------------------------***\n.***AE.KXVAR03 NAME, RQD INPUT, KEYS -XVAR KEY\n                   AIF   (N'&ONECHAR LE 1).ZE20A  CK NUM\n&ZMS               SETC  '\"ONECHAR='            *KPOSA* MNOTE\n&ZMS               SETC  '&ZMS.&ONECHAR\"'\n&ZMS               SETC  '&ZMS \"ONECHAR\"'\n                   MNOTE 8,' &ZMS CAN HAVE ONLY 1 ARGUMENT.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZE20A             ANOP  ,\n.*-------------------------------------------------------------------\n.***AE.KXVAR04 NAME, RQD INPUT, KEYS -XVAR ARGUMENT\n                   AIF   (K'&ONECHAR(1) LE 0).ZE20B NO PRM\n&ZXONECHAR         SETC  'INPUT'     SET IN/OUTPUT\n&XONECHAR          SETC  '&ONECHAR(1)'          SET XVARIABLE\n                   AIF   (N'&ONECHAR GT 1).ZE20B\n.*                 ANOP              MULTIPLE PARMS\n&XONECHAR          SETC  '&ONECHAR'  SET XVARIABLE\n.ZE20B             ANOP  ,\n.*-------------------------------------------------------------------\n.***AE.KCK02 NAME, RQD INPUT, KEYS -GPR OUT OF RANGE\n                   AIF   (K'&ZXONECHAR LE 0).ZE20R  NOT I/O\n                   AIF   ('&XONECHAR'(1,1) NE '(').ZE20R\n&ZCGPR             SETC  '&XONECHAR'(2,K'&XONECHAR-2)\n                   AIF   ('&ZCGPR'(1,1) NE '0').ZE20P\n                   AIF   (K'&ZCGPR GT 2).ZE20Q\n                   AIF   ('&ZCGPR' EQ '0').ZE20Q\n&ZCGPR             SETC  '&ZCGPR'(2,1)\n                   AIF   (T'&ZCGPR NE 'N').ZE20Q  INVALID REG NAME\n.ZE20P             ANOP  ,\n                   AIF   (T'&ZCGPR NE 'N').ZE20R  NON NUMERIC\n                   AIF   ('&ZCGPR' LT '2').ZE20Q\n                   AIF   ('&ZCGPR' LE '12').ZE20R\n.ZE20Q             ANOP  ,\n&ZMS               SETC  '\"ONECHAR='            *KGPRA* MNOTE\n&ZMS               SETC  '&ZMS.&ONECHAR\"'\n&ZMS               SETC  '&ZMS ARGUMENT 1 MUST SPECIFY A REGISTER'\n                   MNOTE 8,' &ZMS IN THE RANGE (2)-(12).'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZE20R             ANOP  ,\n.*----------------------------------------------------------------***\n.***AE.KXVAR03 NAME, OPT INPUT, KEYS -XVAR KEY\n                   AIF   (N'&DELIMITER LE 1).ZE23A  CK NUM\n&ZMS               SETC  '\"DELIMITER='          *KPOSA* MNOTE\n&ZMS               SETC  '&ZMS.&DELIMITER\"'\n&ZMS               SETC  '&ZMS \"DELIMITER\"'\n                   MNOTE 8,' &ZMS CAN HAVE ONLY 1 ARGUMENT.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZE23A             ANOP  ,\n.*-------------------------------------------------------------------\n.***AE.KXVAR04 NAME, OPT INPUT, KEYS -XVAR ARGUMENT\n                   AIF   (K'&DELIMITER(1) LE 0).ZE23B NO PRM\n&ZXDELIMITER       SETC  'INPUT'     SET IN/OUTPUT\n&XDELIMITER        SETC  '&DELIMITER(1)'        SET XVARIABLE\n                   AIF   (N'&DELIMITER GT 1).ZE23B\n.*                 ANOP              MULTIPLE PARMS\n&XDELIMITER        SETC  '&DELIMITER'           SET XVARIABLE\n.ZE23B             ANOP  ,\n.*-------------------------------------------------------------------\n.***AE.KCK02 NAME, OPT INPUT, KEYS -GPR OUT OF RANGE\n                   AIF   (K'&ZXDELIMITER LE 0).ZE23R  NOT I/O\n                   AIF   ('&XDELIMITER'(1,1) NE '(').ZE23R\n&ZCGPR             SETC  '&XDELIMITER'(2,K'&XDELIMITER-2)\n                   AIF   ('&ZCGPR'(1,1) NE '0').ZE23P\n                   AIF   (K'&ZCGPR GT 2).ZE23Q\n                   AIF   ('&ZCGPR' EQ '0').ZE23Q\n&ZCGPR             SETC  '&ZCGPR'(2,1)\n                   AIF   (T'&ZCGPR NE 'N').ZE23Q  INVALID REG NAME\n.ZE23P             ANOP  ,\n                   AIF   (T'&ZCGPR NE 'N').ZE23R  NON NUMERIC\n                   AIF   ('&ZCGPR' LT '2').ZE23Q\n                   AIF   ('&ZCGPR' LE '12').ZE23R\n.ZE23Q             ANOP  ,\n&ZMS               SETC  '\"DELIMITER='          *KGPRA* MNOTE\n&ZMS               SETC  '&ZMS.&DELIMITER\"'\n&ZMS               SETC  '&ZMS ARGUMENT 1 MUST SPECIFY A REGISTER'\n                   MNOTE 8,' &ZMS IN THE RANGE (2)-(12).'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZE23R             ANOP  ,\n.*----------------------------------------------------------------***\n.***AE.KXVAR03 NAME, OPT INPUT, KEYS -XVAR KEY\n                   AIF   (N'&WORKAREA LE 1).ZE26A  CK NUM\n&ZMS               SETC  '\"WORKAREA='           *KPOSA* MNOTE\n&ZMS               SETC  '&ZMS.&WORKAREA\"'\n&ZMS               SETC  '&ZMS \"WORKAREA\"'\n                   MNOTE 8,' &ZMS CAN HAVE ONLY 1 ARGUMENT.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZE26A             ANOP  ,\n.*-------------------------------------------------------------------\n.***AE.KXVAR04 NAME, OPT INPUT, KEYS -XVAR ARGUMENT\n                   AIF   (K'&WORKAREA(1) LE 0).ZE26B NO PRM\n&ZXWORKAREA        SETC  'INPUT'     SET IN/OUTPUT\n&XWORKAREA         SETC  '&WORKAREA(1)'         SET XVARIABLE\n                   AIF   (N'&WORKAREA GT 1).ZE26B\n.*                 ANOP              MULTIPLE PARMS\n&XWORKAREA         SETC  '&WORKAREA'            SET XVARIABLE\n.ZE26B             ANOP  ,\n.*-------------------------------------------------------------------\n.***AE.KCK02 NAME, OPT INPUT, KEYS -GPR OUT OF RANGE\n                   AIF   (K'&ZXWORKAREA LE 0).ZE26R  NOT I/O\n                   AIF   ('&XWORKAREA'(1,1) NE '(').ZE26R\n&ZCGPR             SETC  '&XWORKAREA'(2,K'&XWORKAREA-2)\n                   AIF   ('&ZCGPR'(1,1) NE '0').ZE26P\n                   AIF   (K'&ZCGPR GT 2).ZE26Q\n                   AIF   ('&ZCGPR' EQ '0').ZE26Q\n&ZCGPR             SETC  '&ZCGPR'(2,1)\n                   AIF   (T'&ZCGPR NE 'N').ZE26Q  INVALID REG NAME\n.ZE26P             ANOP  ,\n                   AIF   (T'&ZCGPR NE 'N').ZE26R  NON NUMERIC\n                   AIF   ('&ZCGPR' LT '2').ZE26Q\n                   AIF   ('&ZCGPR' LE '12').ZE26R\n.ZE26Q             ANOP  ,\n&ZMS               SETC  '\"WORKAREA='           *KGPRA* MNOTE\n&ZMS               SETC  '&ZMS.&WORKAREA\"'\n&ZMS               SETC  '&ZMS ARGUMENT 1 MUST SPECIFY A REGISTER'\n                   MNOTE 8,' &ZMS IN THE RANGE (2)-(12).'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZE26R             ANOP  ,\n.*----------------------------------------------------------------***\n.***AE.KXVAR03 NAME, OPT OUTPUT, KEYS -XVAR KEY\n                   AIF   (N'&RETCODE LE 1).ZE29A  CK NUM\n&ZMS               SETC  '\"RETCODE='            *KPOSA* MNOTE\n&ZMS               SETC  '&ZMS.&RETCODE\"'\n&ZMS               SETC  '&ZMS \"RETCODE\"'\n                   MNOTE 8,' &ZMS CAN HAVE ONLY 1 ARGUMENT.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZE29A             ANOP  ,\n.*-------------------------------------------------------------------\n.***AE.KXVAR04 NAME, OPT OUTPUT, KEYS -XVAR ARGUMENT\n                   AIF   (K'&RETCODE(1) LE 0).ZE29B NO PRM\n&ZXRETCODE         SETC  'OUTPUT'    SET IN/OUTPUT\n&XRETCODE          SETC  '&RETCODE(1)'          SET XVARIABLE\n                   AIF   (N'&RETCODE GT 1).ZE29B\n.*                 ANOP              MULTIPLE PARMS\n&XRETCODE          SETC  '&RETCODE'  SET XVARIABLE\n.ZE29B             ANOP  ,\n.*-------------------------------------------------------------------\n.***AE.KCK02 NAME, OPT OUTPUT, KEYS -GPR OUT OF RANGE\n                   AIF   (K'&ZXRETCODE LE 0).ZE29R  NOT I/O\n                   AIF   ('&XRETCODE'(1,1) NE '(').ZE29R\n&ZCGPR             SETC  '&XRETCODE'(2,K'&XRETCODE-2)\n                   AIF   ('&ZCGPR'(1,1) NE '0').ZE29P\n                   AIF   (K'&ZCGPR GT 2).ZE29Q\n                   AIF   ('&ZCGPR' EQ '0').ZE29Q\n&ZCGPR             SETC  '&ZCGPR'(2,1)\n                   AIF   (T'&ZCGPR NE 'N').ZE29Q  INVALID REG NAME\n.ZE29P             ANOP  ,\n                   AIF   (T'&ZCGPR NE 'N').ZE29R  NON NUMERIC\n                   AIF   ('&ZCGPR' LT '2').ZE29Q\n                   AIF   ('&ZCGPR' LE '12').ZE29R\n.ZE29Q             ANOP  ,\n&ZMS               SETC  '\"RETCODE='            *KGPRA* MNOTE\n&ZMS               SETC  '&ZMS.&RETCODE\"'\n&ZMS               SETC  '&ZMS ARGUMENT 1 MUST SPECIFY A REGISTER'\n                   MNOTE 8,' &ZMS IN THE RANGE (2)-(12).'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZE29R             ANOP  ,\n.******************************************************************\n.***AF.P00 CHECK STANDALONE POSITIONAL VARIABLES\n.******************************************************************\n                   ACTR  10000\n.*----------------------------------------------------------------***\n.***AF.P02 EXTRA POSITIONALS\n                   AIF   (N'&SYSLIST LE 0).ZELISTX  NO EXTRAS\n&ZCVAL             SETC  ''          ERROR FIELD\n&ZAWRK             SETA  0           POSITIONAL NUMBER\n.ZELIST2           ANOP  ,\n&ZAWRK             SETA  &ZAWRK+1    NEXT POSITIONAL\n                   AIF   (&ZAWRK GT N'&SYSLIST).ZELIST3  DONE\n&ZCVAL             SETC '&ZCVAL,&SYSLIST(&ZAWRK)'  EXTRA\n                   AGO   .ZELIST2\n.*\n.ZELIST3           ANOP  ,\n&ZCVAL             SETC '&ZCVAL'(2,K'&ZCVAL-1)  STRIP COMMA\n&ZMS               SETC  'POSITIONAL ARGUMENT(S),'  *PPOSA* MNOTE\n&ZMS               SETC  '&ZMS \"&ZCVAL\"'\n&ZMS               SETC  '&ZMS CANNOT BE USED.'\n&ZMS               SETC  '&ZMS NO POSITIONAL ARGUMENTS'\n                   MNOTE 8,' &ZMS ARE ALLOWED.'\n&ZMACRET           SETA  8           SET MACRO ERROR RETURN CODE\n.ZELISTX           ANOP  ,\n&ZASYSLNDX         SETA  0\n.*-------------------------------------------------------------------\n.***AE.MF02 MF=(SLME)\n.ZEMFX             ANOP  ,           END OF PARTIAL SYNTAX CHECK\n.*******************************************************************\n.***AE.ZMR01 NO CODE GENERATED IF ERRORS DETECTED\n.*******************************************************************\n                   AIF   (&ZMACRET NE 0).ZLX2   ERROR DETECTED\n.*******************************************************************\n.***AE.01  START OF ASAXWC MACRO CODE\n.*******************************************************************\n                   LCLC  &M0M0001                 NAME\n&M0M0001           SETC  '&XLABEL'                SET NAME\n                   AIF   (K'&XLABEL NE 0).XLAB2\n&M0M0001           SETC  'M00M&SYSNDX'            DEFAULT NAME\n.*\n.XLAB2             ANOP  ,\n&M0M0001 DS    0H                             ASAXWC-0\n.*******************************************************************\n.***AE.PR01 PRINT CONTROLS, DEFAULT IS YES\n.*******************************************************************\n              PUSH  PRINT\n                   AIF   ('&ZPRINT' NE 'NO').ZPRINTX  TURN PRINT ON\n                   PRINT OFF         ++ PR01\n                   AGO   .ZPRNTXX\n.ZPRINTX           PRINT ON\n.ZPRNTXX           ANOP  ,\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n         AIF   ('&XMF' NE 'M' OR '&WORKAREA' EQ '').WORKOK       @L1A\n         MNOTE 8,' WORKAREA IS NOT ALLOWED WITH MF=M'\n&ZMACRET SETA  8      SET MACRO ERROR RETURN CODE\n.WORKOK  ANOP                                                    @L1A\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n.********************************************************************\n.***AL.L01 INTERNAL ARRAY TO PRODUCE FORMATTED CODE\n.********************************************************************\n                      LCLA  &ZOPN          LIST INSTRUCTION INDEX\n                      LCLA  &ZOPN1         INVOCATION INDEX\n                      LCLC  &ZOPL(4095)    LABEL\n                      LCLC  &ZOPO(4095)    OPERATION\n                      LCLC  &ZOPV(4095)    VALUE\n                      LCLC  &ZOPD(4095)    DESCRIPTION\n.*\n&ZOPN                 SETA  0              INITIAL INST INDEX VALUE\n.******************************************************************\n.***AL.L10 ASAXWC FMT=LIST MF=S|L PARAMETERS\n.******************************************************************\n                      AIF   ('&XMF' EQ 'L').ZLMFSL2\n                      AIF   ('&XMF' NE 'S').ZLMFSLX\n&XMFCTRL              SETC  '#Z'.'&SYSNDX'(1,4).'A'\n&XMFATTR              SETC  '0D'\n.*\n&ZOPN                 SETA  &ZOPN+1\n&ZOPL(&ZOPN)          SETC  ' '\n&ZOPO(&ZOPN)          SETC  'B'\n&ZOPV(&ZOPN)          SETC  '&XMFCTRL.S'\n&ZOPD(&ZOPN)          SETC  '++ ASAXWC ARG PARMS'\n.*\n&ZOPN                 SETA  &ZOPN+1\n&ZOPL(&ZOPN)          SETC  ' '\n&ZOPO(&ZOPN)          SETC  'SPACE'\n&ZOPV(&ZOPN)          SETC  '1'\n&ZOPD(&ZOPN)          SETC  ' '\n.*\n.ZLMFSL2              ANOP  ,\n.*-------------------------------------------------------------------\n.***AM.L01  ASAXWC FMT=LIST PARAMETERS\n&ZOPN                 SETA &ZOPN+1\n&ZOPL(&ZOPN)          SETC '&XMFCTRL'\n&ZOPO(&ZOPN)          SETC 'DS'\n&ZOPV(&ZOPN)          SETC '&XMFATTR'\n&ZOPD(&ZOPN)          SETC '++ ASAXWC PARM LIST'\n.*-------------------------------------------------------------------\n.***AM.L09 ADDR XPATTERNSTR A\n&ZOPN                 SETA &ZOPN+1\n&ZOPL(&ZOPN)          SETC '&XMFCTRL._XPATTERNSTR_ADDR'\n&ZOPO(&ZOPN)          SETC 'DS'\n&ZOPV(&ZOPN)          SETC 'A'\n&ZOPD(&ZOPN)          SETC '++ &ZXPATTERNSTR ADDR XPATTERNSTR'\n.*-------------------------------------------------------------------\n.***AM.L09  XPATTERNSTRLEN F\n&ZOPN                 SETA &ZOPN+1\n&ZOPL(&ZOPN)          SETC '&XMFCTRL._XPATTERNSTRLEN'\n&ZOPO(&ZOPN)          SETC 'DS'\n&ZOPV(&ZOPN)          SETC 'F'\n&ZOPD(&ZOPN)          SETC '++ &ZXPATTERNSTRLEN  XPATTERNSTRLEN'\n.*-------------------------------------------------------------------\n.***AM.L09 ADDR XSTRING A\n&ZOPN                 SETA &ZOPN+1\n&ZOPL(&ZOPN)          SETC '&XMFCTRL._XSTRING_ADDR'\n&ZOPO(&ZOPN)          SETC 'DS'\n&ZOPV(&ZOPN)          SETC 'A'\n&ZOPD(&ZOPN)          SETC '++ &ZXSTRING ADDR XSTRING'\n.*-------------------------------------------------------------------\n.***AM.L09  XSTRINGLEN F\n&ZOPN                 SETA &ZOPN+1\n&ZOPL(&ZOPN)          SETC '&XMFCTRL._XSTRINGLEN'\n&ZOPO(&ZOPN)          SETC 'DS'\n&ZOPV(&ZOPN)          SETC 'F'\n&ZOPD(&ZOPN)          SETC '++ &ZXSTRINGLEN  XSTRINGLEN'\n.*-------------------------------------------------------------------\n.***AM.L09 ADDR XZEROORMORE A\n&ZOPN                 SETA &ZOPN+1\n&ZOPL(&ZOPN)          SETC '&XMFCTRL._XZEROORMORE_ADDR'\n&ZOPO(&ZOPN)          SETC 'DS'\n&ZOPV(&ZOPN)          SETC 'A'\n&ZOPD(&ZOPN)          SETC '++ &ZXZEROORMORE ADDR XZEROORMORE'\n.*-------------------------------------------------------------------\n.***AM.L09 ADDR XONECHAR A\n&ZOPN                 SETA &ZOPN+1\n&ZOPL(&ZOPN)          SETC '&XMFCTRL._XONECHAR_ADDR'\n&ZOPO(&ZOPN)          SETC 'DS'\n&ZOPV(&ZOPN)          SETC 'A'\n&ZOPD(&ZOPN)          SETC '++ &ZXONECHAR ADDR XONECHAR'\n.*-------------------------------------------------------------------\n.***AM.L09 ADDR XDELIMITER A\n&ZOPN                 SETA &ZOPN+1\n&ZOPL(&ZOPN)          SETC '&XMFCTRL._XDELIMITER_ADDR'\n&ZOPO(&ZOPN)          SETC 'DS'\n&ZOPV(&ZOPN)          SETC 'A'\n&ZOPD(&ZOPN)          SETC '++ &ZXDELIMITER ADDR XDELIMITER'\n.*-------------------------------------------------------------------\n.***AM.L10 END OF ASAXWC LIST PARAMETERS\n&ZOPN                 SETA &ZOPN+1\n&ZOPL(&ZOPN)          SETC '&XMFCTRL.L'\n&ZOPO(&ZOPN)          SETC 'EQU'\n&ZOPV(&ZOPN)          SETC '*-&XMFCTRL'\n&ZOPD(&ZOPN)          SETC '++ LENGTH OF PLIST'\n.*\n&ZOPN                 SETA &ZOPN+1\n&ZOPL(&ZOPN)          SETC ' '\n&ZOPO(&ZOPN)          SETC 'SPACE'\n&ZOPV(&ZOPN)          SETC '1'\n&ZOPD(&ZOPN)          SETC ' '\n.*-------------------------------------------------------------------\n.***AL.L12 ASAXWC FMT=LIST MF=S|L PARAMETERS\n                      AIF   ('&XMF' EQ 'L').ZMFLX  DONE IF MF=L\n.*\n&ZOPN                 SETA  &ZOPN+1\n&ZOPL(&ZOPN)          SETC  '&XMFCTRL.S'\n&ZOPO(&ZOPN)          SETC  'DC'\n&ZOPV(&ZOPN)          SETC  '0H''0'''\n&ZOPD(&ZOPN)          SETC  '++ ASAXWC ARG PARMS'\n.*\n.ZLMFSLX              ANOP  ,\n.*-------------------------------------------------------------------\n.***AL.L13 SET ZPLLEN TO ITS APPROPRIATE VALUE\n&ZPLLEN               SETA 28\n.*\n.******************************************************************\n.***AI.L01 ASAXWC FMT=LIST FILL IN PARAMETER AREA\n.******************************************************************\n                      ACTR  10000\n&ZCVAL                SETC  'LA'           ASSUME XA MODE\n                      AIF   ('&SYSASCE' EQ 'P').ZIMFXA  SYSSTATE PRI\n&ZCVAL                SETC  'LAE'          XAX MODE\n.ZIMFXA               ANOP ,\n.*\n                      AIF   ('&XMFCTRL'(1,1) NE '(').ZIMFN2  NOT GPR\n&ZCGPR                SETC  '&XMFCTRL'(2,K'&XMFCTRL-2)  GET GPR\n                      AIF   ('&ZCGPR' EQ 'GPR1').ZIMFNX\n                      AIF   ('&ZCGPR' EQ 'GPR01').ZIMFNX\n                      AIF   ('&ZCGPR' EQ 'REG1').ZIMFNX\n                      AIF   ('&ZCGPR' EQ 'REG01').ZIMFNX\n                      AIF   ('&ZCGPR' EQ 'R1').ZIMFNX\n                      AIF   ('&ZCGPR' EQ '1').ZIMFNX\n                      AIF   ('&ZCGPR' EQ '01').ZIMFNX\n&ZOPN                 SETA  &ZOPN+1\n&ZOPL(&ZOPN)          SETC  ' '\n&ZOPO(&ZOPN)          SETC  '&ZCVAL'\n&ZOPV(&ZOPN)          SETC  '1,0(,&ZCGPR)'\n&ZOPD(&ZOPN)          SETC  '++ LOCATE ARG PARMS'\n                      AGO   .ZIMFNX\n.*\n.ZIMFN2               ANOP ,\n&ZOPN                 SETA  &ZOPN+1\n&ZOPL(&ZOPN)          SETC  ' '\n&ZOPO(&ZOPN)          SETC  '&ZCVAL'\n&ZOPV(&ZOPN)          SETC  '1,&XMFCTRL'\n&ZOPD(&ZOPN)          SETC  '++ LOCATE ARG PARMS'\n.ZIMFNX               ANOP ,\n.********************************************************************\n.***AI.L02 ASAXWC FMT=LIST INITIALIZE PARAMETER AREA\n.********************************************************************\n.***AI.L03 MF=(SLME)\n                      AIF   ('&XMF' EQ 'L').ZIMFLX\n                      AIF   ('&XMFSCK' NE 'COMPLETE').ZIMFLX\n.*\n&ZOPN                 SETA  &ZOPN+1\n&ZOPL(&ZOPN)          SETC  ' '\n&ZOPO(&ZOPN)          SETC  'XC'\n&ZOPV(&ZOPN)          SETC  '0(&ZPLLEN,1),0(1)'\n&ZOPD(&ZOPN)          SETC  '++ INITIALIZE'\n.ZIMFLX               ANOP  ,\n.*-------------------------------------------------------------------\n.***AI.L19 ADDR XPATTERNSTR A\n                      AIF   ('&ZXPATTERNSTR' EQ '').ZI2H  NOT USED\n&ZCLNG                SETC  '&XPATTERNSTR'\n&ZCGPR                SETC  '14'\n         AIF   ('&XPATTERNSTR'(1,1) EQ '(').ZI2F  IN GPR\n.*\n&ZOPN                 SETA  &ZOPN+1\n&ZOPL(&ZOPN)          SETC  ' '\n&ZOPO(&ZOPN)          SETC  'LA'\n&ZOPV(&ZOPN)          SETC  '&ZCGPR,&ZCLNG'\n&ZOPD(&ZOPN)          SETC  '++ &ZXPATTERNSTR XPATTERNSTR A'\n.*\n                      AGO   .ZI2G\n.*\n.ZI2F                 ANOP  ,\n&ZCGPR   SETC  '&XPATTERNSTR'(2,K'&XPATTERNSTR-2)\n.*\n.ZI2G                 ANOP  ,\n.*\n&ZOPN                 SETA  &ZOPN+1\n&ZOPL(&ZOPN)          SETC  ' '\n&ZOPO(&ZOPN)          SETC  'ST'\n&ZOPV(&ZOPN)          SETC  '&ZCGPR,0(,1)'\n&ZOPD(&ZOPN)          SETC  '++ &ZXPATTERNSTR XPATTERNSTR A'\n.*\n.ZI2H                 ANOP  ,\n.*-------------------------------------------------------------------\n.***AI.L25  XPATTERNSTRLEN F\n                      AIF   ('&ZXPATTERNSTRLEN' EQ '').ZI3E  NOT USED\n                      AIF   ('&ZXPATTERNSTRLEN' EQ 'OUTPUT').ZI3E\n&ZCGPR                SETC  '&XPATTERNSTRLEN'\n.*\n                      AIF   ('&XPATTERNSTRLEN'(1,1) NE '(').ZI3B\n&ZCGPR   SETC  '0('.'&XPATTERNSTRLEN'(2,K'&XPATTERNSTRLEN-2).')'\n                      AGO   .ZI3D\n.ZI3B                 ANOP  ,\n.*\n&ZC                   SETC  '&XPATTERNSTRLEN'(1,1)\n                      AIF   (T'&ZC NE 'N').ZI3D\n&ZC                   SETC  '&XPATTERNSTRLEN'\n                      AIF   ('&ZC'(K'&ZC,1) EQ ')').ZI3D\n&ZCGPR                SETC  '=FL4''&XPATTERNSTRLEN'''\n.*\n.ZI3D                 ANOP  ,\n.*\n&ZOPN                 SETA  &ZOPN+1\n&ZOPL(&ZOPN)          SETC  ' '\n&ZOPO(&ZOPN)          SETC  'MVC'\n&ZOPV(&ZOPN)          SETC  '4(4,1),&ZCGPR'\n&ZOPD(&ZOPN)          SETC  '++ &ZXPATTERNSTRLEN XPATTERNSTRLEN F'\n.*\n.ZI3E                 ANOP  ,\n.*-------------------------------------------------------------------\n.***AI.L19 ADDR XSTRING A\n                      AIF   ('&ZXSTRING' EQ '').ZI4H  NOT USED\n&ZCLNG                SETC  '&XSTRING'\n&ZCGPR                SETC  '14'\n         AIF   ('&XSTRING'(1,1) EQ '(').ZI4F  IN GPR\n.*\n&ZOPN                 SETA  &ZOPN+1\n&ZOPL(&ZOPN)          SETC  ' '\n&ZOPO(&ZOPN)          SETC  'LA'\n&ZOPV(&ZOPN)          SETC  '&ZCGPR,&ZCLNG'\n&ZOPD(&ZOPN)          SETC  '++ &ZXSTRING XSTRING A'\n.*\n                      AGO   .ZI4G\n.*\n.ZI4F                 ANOP  ,\n&ZCGPR   SETC  '&XSTRING'(2,K'&XSTRING-2)\n.*\n.ZI4G                 ANOP  ,\n.*\n&ZOPN                 SETA  &ZOPN+1\n&ZOPL(&ZOPN)          SETC  ' '\n&ZOPO(&ZOPN)          SETC  'ST'\n&ZOPV(&ZOPN)          SETC  '&ZCGPR,8(,1)'\n&ZOPD(&ZOPN)          SETC  '++ &ZXSTRING XSTRING A'\n.*\n.ZI4H                 ANOP  ,\n.*-------------------------------------------------------------------\n.***AI.L25  XSTRINGLEN F\n                      AIF   ('&ZXSTRINGLEN' EQ '').ZI5E  NOT USED\n                      AIF   ('&ZXSTRINGLEN' EQ 'OUTPUT').ZI5E\n&ZCGPR                SETC  '&XSTRINGLEN'\n.*\n                      AIF   ('&XSTRINGLEN'(1,1) NE '(').ZI5B\n&ZCGPR   SETC  '0('.'&XSTRINGLEN'(2,K'&XSTRINGLEN-2).')'\n                      AGO   .ZI5D\n.ZI5B                 ANOP  ,\n.*\n&ZC                   SETC  '&XSTRINGLEN'(1,1)\n                      AIF   (T'&ZC NE 'N').ZI5D\n&ZC                   SETC  '&XSTRINGLEN'\n                      AIF   ('&ZC'(K'&ZC,1) EQ ')').ZI5D\n&ZCGPR                SETC  '=FL4''&XSTRINGLEN'''\n.*\n.ZI5D                 ANOP  ,\n.*\n&ZOPN                 SETA  &ZOPN+1\n&ZOPL(&ZOPN)          SETC  ' '\n&ZOPO(&ZOPN)          SETC  'MVC'\n&ZOPV(&ZOPN)          SETC  '12(4,1),&ZCGPR'\n&ZOPD(&ZOPN)          SETC  '++ &ZXSTRINGLEN XSTRINGLEN F'\n.*\n.ZI5E                 ANOP  ,\n.*-------------------------------------------------------------------\n.***AI.L19 ADDR XZEROORMORE A\n                      AIF   ('&ZXZEROORMORE' EQ '').ZI6H  NOT USED\n&ZCLNG                SETC  '&XZEROORMORE'\n&ZCGPR                SETC  '14'\n         AIF   ('&XZEROORMORE'(1,1) EQ '(').ZI6F  IN GPR\n.*\n&ZOPN                 SETA  &ZOPN+1\n&ZOPL(&ZOPN)          SETC  ' '\n&ZOPO(&ZOPN)          SETC  'LA'\n&ZOPV(&ZOPN)          SETC  '&ZCGPR,&ZCLNG'\n&ZOPD(&ZOPN)          SETC  '++ &ZXZEROORMORE XZEROORMORE A'\n.*\n                      AGO   .ZI6G\n.*\n.ZI6F                 ANOP  ,\n&ZCGPR   SETC  '&XZEROORMORE'(2,K'&XZEROORMORE-2)\n.*\n.ZI6G                 ANOP  ,\n.*\n&ZOPN                 SETA  &ZOPN+1\n&ZOPL(&ZOPN)          SETC  ' '\n&ZOPO(&ZOPN)          SETC  'ST'\n&ZOPV(&ZOPN)          SETC  '&ZCGPR,16(,1)'\n&ZOPD(&ZOPN)          SETC  '++ &ZXZEROORMORE XZEROORMORE A'\n.*\n.ZI6H                 ANOP  ,\n.*-------------------------------------------------------------------\n.***AI.L19 ADDR XONECHAR A\n                      AIF   ('&ZXONECHAR' EQ '').ZI7H  NOT USED\n&ZCLNG                SETC  '&XONECHAR'\n&ZCGPR                SETC  '14'\n         AIF   ('&XONECHAR'(1,1) EQ '(').ZI7F  IN GPR\n.*\n&ZOPN                 SETA  &ZOPN+1\n&ZOPL(&ZOPN)          SETC  ' '\n&ZOPO(&ZOPN)          SETC  'LA'\n&ZOPV(&ZOPN)          SETC  '&ZCGPR,&ZCLNG'\n&ZOPD(&ZOPN)          SETC  '++ &ZXONECHAR XONECHAR A'\n.*\n                      AGO   .ZI7G\n.*\n.ZI7F                 ANOP  ,\n&ZCGPR   SETC  '&XONECHAR'(2,K'&XONECHAR-2)\n.*\n.ZI7G                 ANOP  ,\n.*\n&ZOPN                 SETA  &ZOPN+1\n&ZOPL(&ZOPN)          SETC  ' '\n&ZOPO(&ZOPN)          SETC  'ST'\n&ZOPV(&ZOPN)          SETC  '&ZCGPR,20(,1)'\n&ZOPD(&ZOPN)          SETC  '++ &ZXONECHAR XONECHAR A'\n.*\n.ZI7H                 ANOP  ,\n.*-------------------------------------------------------------------\n.***AI.L18 ADDR XDELIMITER A\n                      AIF   ('&XDELIMITER' NE 'LENGTHS_WERE_SET').ZI8\n                      AIF   ('&XMFSCK' NE 'COMPLETE').ZI8  CK *\n&ZXDELIMITER          SETC  ''             RESET INPUT/OUTPUT\n.ZI8                  ANOP  ,\n.*-------------------------------------------------------------------\n.***AI.L19 ADDR XDELIMITER A\n                      AIF   ('&ZXDELIMITER' EQ '').ZI8H  NOT USED\n&ZCLNG                SETC  '&XDELIMITER'\n&ZCGPR                SETC  '14'\n         AIF   ('&XDELIMITER'(1,1) EQ '(').ZI8F  IN GPR\n                      AIF   ('&XDELIMITER' NE 'LENGTHS_WERE_SET').ZI8A\n                      AIF   ('&XMFSCK' EQ 'COMPLETE').ZI8H\n.*\n&ZCLNG                SETC  '=XL4''00'''\n.ZI8A                 ANOP  ,\n.*\n&ZOPN                 SETA  &ZOPN+1\n&ZOPL(&ZOPN)          SETC  ' '\n&ZOPO(&ZOPN)          SETC  '&ZCVAL'\n&ZOPV(&ZOPN)          SETC  '&ZCGPR,&ZCLNG'\n&ZOPD(&ZOPN)          SETC  '++ &ZXDELIMITER XDELIMITER A'\n.*\n                      AGO   .ZI8G\n.*\n.ZI8F                 ANOP  ,\n&ZCGPR   SETC  '&XDELIMITER'(2,K'&XDELIMITER-2)\n.*\n.ZI8G                 ANOP  ,\n.*\n&ZOPN                 SETA  &ZOPN+1\n&ZOPL(&ZOPN)          SETC  ' '\n&ZOPO(&ZOPN)          SETC  'ST'\n&ZOPV(&ZOPN)          SETC  '&ZCGPR,24(,1)'\n&ZOPD(&ZOPN)          SETC  '++ &ZXDELIMITER XDELIMITER A'\n.*\n.ZI8H                 ANOP  ,\n.*-------------------------------------------------------------------\n&ZOPN1                SETA &ZOPN\n.*-------------------------------------------------------------------\n.***AI.C00 MF=M CHECK TO BYPASS INVOCATION\n                      AIF   ('&XMF' EQ 'M').ZMFLX  DONE IF MF=M\n.*******************************************************************\n.***  PROCESS ASAXWC OUTPUT PARAMETERS\n.*******************************************************************\n                      ACTR  10000\n.*******************************************************************\n.***AO.X02  RETURN CODE PROCESSING\n.*******************************************************************\n                      AIF   (N'&RETCODE LE 0).ZMRETX\n                      AIF   ('&XRETCODE'(1,1) EQ '(').ZMRET2\n                      AIF   ('&XRETCODE' EQ 'GPR15').ZMRETX\n                      AIF   ('&XRETCODE' EQ 'REG15').ZMRETX\n                      AIF   ('&XRETCODE' EQ 'R15').ZMRETX\n                      AIF   ('&XRETCODE' EQ '15').ZMRETX\n&ZOPN                 SETA  &ZOPN+1\n&ZOPL(&ZOPN)          SETC  ' '\n&ZOPO(&ZOPN)          SETC  'ST'\n&ZOPV(&ZOPN)          SETC  '15,&XRETCODE'\n&ZOPD(&ZOPN)          SETC  '++ SET RETURN CODE'\n                      AGO   .ZMRETX\n.*\n.ZMRET2               ANOP  ,\n&ZCGPR                SETC  '&XRETCODE'(2,K'&XRETCODE-2)\n                      AIF   ('&ZCGPR' EQ 'GPR15').ZMRETX\n                      AIF   ('&ZCGPR' EQ 'REG15').ZMRETX\n                      AIF   ('&ZCGPR' EQ 'R15').ZMRETX\n                      AIF   ('&ZCGPR' EQ '15').ZMRETX\n&ZOPN                 SETA  &ZOPN+1\n&ZOPL(&ZOPN)          SETC  ' '\n&ZOPO(&ZOPN)          SETC  'LR'\n&ZOPV(&ZOPN)          SETC  '&ZCGPR,15'\n&ZOPD(&ZOPN)          SETC  '++ SET RETURN CODE'\n.ZMRETX               ANOP  ,\n.*******************************************************************\n.***AO.X04  LABEL FOR MF=L PROCESSING\n.*******************************************************************\n.ZMFLX                ANOP  ,              MF=L PROCESSING\n.*******************************************************************\n.***AO.X05  FORMAT GENERATED INSTRUCTIONS\n.*******************************************************************\n                      ACTR  10000\n.*\n                      LCLA  &ZLC           COLUMN POSITION\n                      LCLA  &ZOPX          LIST TABLE INDEX\n                      LCLC  &ZLL           LABEL\n                      LCLC  &ZLOP          OPERATION\n                      LCLC  &ZLV           VALUE\n                      LCLC  &ZLD           DESCRIPTION\n.*\n&ZOPX                 SETA  1\n.ZL2                  AIF   (&ZOPX GT &ZOPN1).ZLX  B IF DONE\n&ZLL                  SETC  '&ZOPL(&ZOPX)'\n&ZLOP                 SETC  '&ZOPO(&ZOPX)'\n&ZLV                  SETC  '&ZOPV(&ZOPX)'\n&ZLD                  SETC  '&ZOPD(&ZOPX)'\n                      AIF   (K'&ZLD LE 0).ZL5\n&ZLC                  SETA  35             COMMENT COLUMN\n                      AIF   ('&ZLD'(1,1) NE '*').ZL3\n&ZLC                  SETA  33             COMMMENT COLUMN\n.ZL3                  AIF   (K'&ZLV GE &ZLC-16-1).ZL4\n&ZLV                  SETC  '&ZLV'.' '\n                      AGO   .ZL3\n.*\n.ZL4                  ANOP  ,\n&ZLV                  SETC  '&ZLV'.' '\n.ZL5                  ANOP  ,\n&ZLV                  SETC  '&ZLV'.'&ZLD'\n.*\n&ZLL     &ZLOP &ZLV\n.*\n&ZOPX                 SETA  &ZOPX+1        NEXT STRUCTURE\n                      AGO   .ZL2           CONTINUE LOOPING\n.*\n.ZLX                  ANOP  ,\n                      AIF   ('&XMF' EQ 'L').ZLINKX  MF=L\n                      AIF   ('&XMF' EQ 'M').ZLINKX  MF=M\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n         L     15,16              Get CVT address                @L1A\n         L     15,140(15,0)       Get ECVT address               @L1A\n         L     15,232(15,0)       Get REUCB address              @L1A\n         AIF   ('&WORKAREA' EQ '').NOTWILDB                      @L1A\n         AIF   ('&XWORKAREA' NE 'NO_WORKAREA').WILDB             @L1A\n.NOTWILDB ANOP                                                   @L1A\n         L     15,28(15,0)        Get ASAWILDC address           @L1A\n         BASR  14,15              Call ASAWILDC                  @L1A\n         AGO   .ENDMAC                                           @L1A\n.WILDB   ANOP                                                    @L1A\n         AIF   ('&WORKAREA'(1,1) EQ '(').INREG                   @L1A\n         LA    0,&WORKAREA(1)     Get workarea address           @L1A\n         AGO   .DOCALL                                           @L1A\n.INREG   ANOP                                                    @L1A\n         AIF   ('&WORKAREA(1)' EQ 'GPR0').DOCALL                 @L1A\n         AIF   ('&WORKAREA(1)' EQ 'GPR00').DOCALL                @L1A\n         AIF   ('&WORKAREA(1)' EQ 'REG0').DOCALL                 @L1A\n         AIF   ('&WORKAREA(1)' EQ 'REG00').DOCALL                @L1A\n         AIF   ('&WORKAREA(1)' EQ 'R0').DOCALL                   @L1A\n         AIF   ('&WORKAREA(1)' EQ '0').DOCALL                    @L1A\n         AIF   ('&WORKAREA(1)' EQ '00').DOCALL                   @L1A\n         LR    0,&WORKAREA(1)     Get workarea address           @L1A\n.DOCALL  ANOP                                                    @L1A\n         L     15,32(15,0)        Get ASAWILDB address           @L1A\n         BASR  14,15              Call ASAWILDB                  @L1A\n.ENDMAC  ANOP                                                    @L1A\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n.ZLINKX               ANOP  ,\n.*******************************************************************\n.***AP.X01  FORMAT GENERATED CODE\n.ZL21                 AIF   (&ZOPX GT &ZOPN).ZLX1  B IF DONE\n&ZLL                  SETC  '&ZOPL(&ZOPX)'\n&ZLOP                 SETC  '&ZOPO(&ZOPX)'\n&ZLV                  SETC  '&ZOPV(&ZOPX)'\n&ZLD                  SETC  '&ZOPD(&ZOPX)'\n                      AIF   (K'&ZLD LE 0).ZL51\n&ZLC                  SETA  35             COMMENT COLUMN\n                      AIF   ('&ZLD'(1,1) NE '*').ZL31\n&ZLC                  SETA  33             COMMENT COLUMN\n.ZL31                 AIF   (K'&ZLV GE &ZLC-16-1).ZL41\n&ZLV                  SETC  '&ZLV'.' '\n                      AGO   .ZL31\n.*\n.ZL41                 ANOP  ,\n&ZLV                  SETC  '&ZLV'.' '\n.ZL51                 ANOP  ,\n&ZLV                  SETC  '&ZLV'.'&ZLD'\n.*\n&ZLL     &ZLOP &ZLV\n.*\n&ZOPX                 SETA  &ZOPX+1        NEXT STRUCTURE\n                      AGO   .ZL21          CONTINUE LOOPING\n.*\n.ZLX1                 ANOP  ,\n.*******************************************************************\n.***AP.X02  END OF ASAXWC MACRO\n&ZASAXWC              SETC  'YES'          SET ASAXWC USED\n         POP   PRINT\n*                                            ASAXWC-0\n         SPACE 1\n.ZLX2                 ANOP  ,\n         MEND\n**********************************************************************/\n*/**** START OF SPECIFICATIONS ****************************************\n*                                                                     *\n*                                                                     *\n*01* MACRO NAME:  ASAXWC                                -07/19/94-<0> *\n*                                                                     *\n*                                                                     *\n*01* DESCRIPTIVE NAME:  Wildcard service                              *\n*                                                                     *\n*01* PROPRIETARY STATEMENT:                                           *\n*                                                                     *\n*     LICENSED MATERIALS - PROPERTY OF IBM                            *\n*     THIS MACRO IS \"RESTRICTED MATERIALS OF IBM\"                     *\n*     5655-068 (C) COPYRIGHT IBM CORP. 1994                           *\n*     SEE COPYRIGHT INSTRUCTIONS                                      *\n*                                                                     *\n* STATUS= HBB5520                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*01* FUNCTION:                                                        *\n*       See the ASAXWC macro prologue for details.                    *\n*                                                                     *\n*01* INPUT:                                                           *\n*                                                                     *\n*            ?ASAXWC    \u00ddPLISTVER                                     *\n*                                 (\u00bbxplistver|IMPLIED_VERSION\u00ba)\u00a8      *\n*                        PATTERNSTR(xpatternstr)                      *\n*                        PATTERNSTRLEN(xpatternstrlen)                *\n*                        STRING(xstring)                              *\n*                        STRINGLEN(xstringlen)                        *\n*                        ZEROORMORE(xzeroormore)                      *\n*                        ONECHAR(xonechar)                            *\n*                       \u00ddDELIMITER(\u00bbxdelimiter|LENGTHS_WERE_SET\u00ba)\u00a8    *\n*                       \u00ddWORKAREA(\u00bbxworkarea|NO_WORKAREA\u00ba)\u00a8           *\n*                       \u00ddRETCODE(xretcode)\u00a8                           *\n*                      \u00d0\u00ddMF(S)\u00a8                                       *\n*                      \u00d4\u00ddMF(L,xmfctrl\u00bb,xmfattr|BDY(DWORD)\u00ba)\u00a8          *\n*                      \u00d4\u00ddMF(M,xmfctrl\u00bb,COMPLETE|NOCHECK\u00ba)\u00a8            *\n*                      \u00bf\u00ddMF(E,xmfctrl\u00bb,COMPLETE|NOCHECK\u00ba)\u00a8            *\n*                                                                     *\n****** END OF SPECIFICATIONS *****************************************/\n*/*PB.ECHO01 MACRO INVOCATION ECHO-----------------------------------*/\n*  ANS('@SPACE;') NORESCAN COL(MACLMAR);\n*  ANS('/* ? ASAXWC '||MACLIST||' ')\n*      NORESCAN COL(MACLMAR+5);    /* START ECHO */\n*\n*  DCL ZELO  FIXED;\n*  DCL ZECOL FIXED;\n*\n*  ZELO=1;     /* STARTING COLUMN */\n*  DO WHILE ZELO<=LENGTH(MACKEYS);  /* PARENTHSIS SCAN */\n*    ZECOL=INDEX(MACKEYS(ZELO:LENGTH(MACKEYS)),')');\n*    IF ZECOL>0\n*      THEN\n*        DO;   /* PARENTHESIS FOUND */\n*          ANS(MACKEYS(ZELO:ZELO+ZECOL-1)||' ')\n*             NORESCAN COL(MACLMAR+5);\n*          ZELO=ZELO+ZECOL;        /* NEXT PORTION */\n*        END;\n*      ELSE\n*        DO;   /* REMAINING KEYS */\n*          ANS(MACKEYS(ZELO:LENGTH(MACKEYS)))\n*             NORESCAN COL(MACLMAR+5);\n*          ZELO=LENGTH(MACKEYS)+1;\n*        END;\n*  END;\n*  ANS(' -07/19/94-0- */')\n*      NORESCAN COL(MACLMAR+5);    /* END ECHO */\n*/********************************************************************/\n*/*PV.DCL01 MACRO DECLARES AND CODE GENERATION CONTROLS              */\n*/********************************************************************/\n*  DCL ZPRINT  EXTERNAL; DEACT ZPRINT; /* YES=PRINT, NO=NO PRINT     */\n*  DCL ZTEST   EXTERNAL; DEACT ZTEST;  /* YES=TEST, NO=NO TEST       */\n*  DCL ZSYSTEM EXTERNAL; DEACT ZSYSTEM;/* PCCODE10, MVS, SAK, VM     */\n*\n*  DCL   ZASAXWC CHAR EXTERNAL; /* YES=USED AT LEAST ONCE          */\n*  DEACT ZASAXWC;\n*\n*  DCL ZMACRET FIXED; DEACT ZMACRET;\n*  ZMACRET=0;                   /* MACRO COMPILE RETURN CODE         */\n*\n*  DCL ZMS CHAR;   DEACT ZMS;   /* ERROR MESSAGE                     */\n*  DCL ZCVAL CHAR; DEACT ZCVAL; /* ERROR MESSAGE WORK AREA           */\n*\n*  DCL ZI FIXED;  DEACT ZI;     /* INDEX FOR VARIABLE NUM OF PARMS   */\n*  DCL ZJ FIXED;  DEACT ZJ;     /* INDEX FOR VARIABLE NUM OF PARMS   */\n*  DCL ZK FIXED;  DEACT ZK;     /* INDEX FOR RANGE COLON (:)         */\n*  DCL ZL FIXED;  DEACT ZL;     /* INDEX FOR RANGE VALUE CHECKING    */\n*  DCL ZLO FIXED; DEACT ZLO;    /* LOW RANGE VALUE                   */\n*  DCL ZHI FIXED; DEACT ZHI;    /* HIGH RANGE VALUE                  */\n*  DCL ZW CHAR;   DEACT ZW;     /* WORK AREA FOR RANGE VALUE SUBLIST */\n*  DCL ZN FIXED;  DEACT ZN;     /* NUMERIC WORK VARIABLE             */\n*  DCL ZC CHAR;   DEACT ZC;     /* CHARACTER WORK VARIABLE           */\n*  DCL ZMAXINVOCLEN FIXED; DEACT ZMAXINVOCLEN;  /* INVOCATION LENGTH */\n*  DCL ZPLLEN FIXED; DEACT ZPLLEN;        /* PARAMETER LIST LENGTH   */\n*\n*  DCL ZPRMMAX FIXED;           /* MAXIMUM PARM LIST SIZE            */\n*  DCL ZPRMNUM FIXED;           /* PARAMETER ARRAY INDEX             */\n*  DCL ZPRM(100);               /* PARAMETER ENTRY                   */\n*  DCL EHAMAXLEN FIXED EXTERNAL;   /* MAX ILIST SIZE FOR PARM LISTS  */\n*  DCL EHAREGS CHARACTER EXTERNAL; /* REG DCLS                       */\n*  DCL EHALIST CHARACTER EXTERNAL; /* STANDARD PARM LIST GENERATION  */\n*/*******************************************************************/\n*/*PV.XVAR01 DECLARE ALL MACRO PARAMETER VARIABLES                  */\n*/*******************************************************************/\n*  DCL XPLISTVER FIXED;  DEACT XPLISTVER;  /***PV.XVAR02 INPUT VALUE */\n*  DCL ZXPLISTVER; DEACT ZXPLISTVER;  /***INPUT/OUTPUT CONTROL */\n*  DCL   XPATTERNSTR;              /***PV.XVAR03 INPUT NAME */\n*  DEACT XPATTERNSTR;              /***PV.XVAR03 INPUT NAME */\n*  DCL   ZXPATTERNSTR;             /***INPUT/OUTPUT CONTROL */\n*  DEACT ZXPATTERNSTR;             /***INPUT/OUTPUT CONTROL */\n*  DCL   XPATTERNSTRLEN;           /***PV.XVAR03 INPUT NAME */\n*  DEACT XPATTERNSTRLEN;           /***PV.XVAR03 INPUT NAME */\n*  DCL   ZXPATTERNSTRLEN;          /***INPUT/OUTPUT CONTROL */\n*  DEACT ZXPATTERNSTRLEN;          /***INPUT/OUTPUT CONTROL */\n*  DCL XSTRING;  DEACT XSTRING;    /***PV.XVAR02 INPUT NAME */\n*  DCL ZXSTRING; DEACT ZXSTRING;   /***INPUT/OUTPUT CONTROL */\n*  DCL   XSTRINGLEN;               /***PV.XVAR03 INPUT NAME */\n*  DEACT XSTRINGLEN;               /***PV.XVAR03 INPUT NAME */\n*  DCL   ZXSTRINGLEN;              /***INPUT/OUTPUT CONTROL */\n*  DEACT ZXSTRINGLEN;              /***INPUT/OUTPUT CONTROL */\n*  DCL   XZEROORMORE;              /***PV.XVAR03 INPUT NAME */\n*  DEACT XZEROORMORE;              /***PV.XVAR03 INPUT NAME */\n*  DCL   ZXZEROORMORE;             /***INPUT/OUTPUT CONTROL */\n*  DEACT ZXZEROORMORE;             /***INPUT/OUTPUT CONTROL */\n*  DCL XONECHAR;  DEACT XONECHAR;  /***PV.XVAR02 INPUT NAME */\n*  DCL ZXONECHAR; DEACT ZXONECHAR;  /***INPUT/OUTPUT CONTROL */\n*  DCL   XDELIMITER;               /***PV.XVAR03 INPUT NAME */\n*  DEACT XDELIMITER;               /***PV.XVAR03 INPUT NAME */\n*  DCL   ZXDELIMITER;              /***INPUT/OUTPUT CONTROL */\n*  DEACT ZXDELIMITER;              /***INPUT/OUTPUT CONTROL */\n*  DCL XWORKAREA;  DEACT XWORKAREA;  /***PV.XVAR02 INPUT NAME */\n*  DCL ZXWORKAREA; DEACT ZXWORKAREA;  /***INPUT/OUTPUT CONTROL */\n*  DCL XRETCODE;  DEACT XRETCODE;  /***PV.XVAR02 OUTPUT NAME */\n*  DCL ZXRETCODE; DEACT ZXRETCODE;  /***INPUT/OUTPUT CONTROL */\n*  DCL XMF;  DEACT XMF;            /***PV.XVAR02 INPUT VALUE */\n*  DCL ZXMF; DEACT ZXMF;           /***INPUT/OUTPUT CONTROL */\n*  DCL XMFCTRL;  DEACT XMFCTRL;    /***PV.XVAR02 INPUT NAME */\n*  DCL ZXMFCTRL; DEACT ZXMFCTRL;   /***INPUT/OUTPUT CONTROL */\n*  DCL XMFATTR;  DEACT XMFATTR;    /***PV.XVAR02 INPUT VALUE */\n*  DCL ZXMFATTR; DEACT ZXMFATTR;   /***INPUT/OUTPUT CONTROL */\n*  DCL XMFSCK;  DEACT XMFSCK;      /***PV.XVAR02 INPUT VALUE */\n*  DCL ZXMFSCK; DEACT ZXMFSCK;     /***INPUT/OUTPUT CONTROL */\n*/********************************************************************/\n*/***PC.PLV01  PROCESS PLISTVER                                      */\n*/********************************************************************/\n*  IF TRANSLATE(PLISTVER(1)) = 'MAX' THEN\n*    XPLISTVER=0;\n*  ELSE\n*    XPLISTVER=0;\n*  IF PLISTVER\u00ac=''\n*     & TRANSLATE(PLISTVER(1))\u00ac='IMPLIED_VERSION'\n*     & TRANSLATE(PLISTVER(1))\u00ac='MAX'\n*    THEN\n*      DO;\n*        IF FIXED(PLISTVER(1))>=XPLISTVER\n*          THEN\n*              XPLISTVER=FIXED(PLISTVER(1));\n*          ELSE\n*            DO;\n*              ZMS=' 8, PLISTVER='||         /**KVALP* MSG*/\n*                    PLISTVER(1)||\n*                  ', BUT PLISTVER OF '||\n*                    CHAR(XPLISTVER)||\n*                  ' IS REQUIRED.';\n*              ANS MSG('?ASAXWC ---> '||ZMS);\n*              ANS(COMMENT(ZMS)) COL(MACLMAR);\n*              ZMACRET=8;                    /* MACRO ERROR */\n*            END;\n*\n*        IF PLISTVER='PLISTVER' | PLISTVER='()'  /*CHCK ENTRY*/\n*          THEN\n*            DO;\n*              ZMS=' 8, THE \"PLISTVER\" KEY'|| /**KOPTP* MSG*/\n*                  ' MUST CONTAIN ONE'||\n*                  ' (OR MORE) ARGUMENT(S).';\n*              ANS MSG('?ASAXWC ---> '||ZMS);\n*              ANS(COMMENT(ZMS)) COL(MACLMAR);\n*              ZMACRET=8;                    /* MACRO ERROR */\n*            END;\n*        IF NUMBER(PLISTVER)>1               /* CHECK POSITIONALS */\n*          THEN\n*            DO;\n*              ZMS=' 8, \"PLISTVER'||         /**KPOSP* MSG*/\n*                  PLISTVER||\n*                  '\" \"PLISTVER\"'||\n*                  ' CAN HAVE ONLY 1 ARGUMENT.';\n*              ANS MSG('?ASAXWC ---> '||ZMS);\n*              ANS(COMMENT(ZMS)) COL(MACLMAR);\n*              ZMACRET=8;                    /* MACRO ERROR */\n*            END;\n*\n*        ZCVAL='';                           /* ERROR FLAG */\n*        ZC=PLISTVER(1);\n*        DO ZL=1 TO LENGTH(ZC);              /* MUST BE NUMBER */\n*          IF ZC(ZL:ZL)<'0' |                /* MUST BE NUMERIC */\n*             ZC(ZL:ZL)>'9'                  /* MUST BE NUMERIC */\n*            THEN\n*              ZCVAL='NUMERIC';              /* NUMERIC ERROR */\n*        END;\n*        IF ZCVAL=''\n*          THEN\n*            DO;                             /* CHECK RANGE LIMITS */\n*              IF XPLISTVER<0 |              /* LOW LIMIT */\n*                 XPLISTVER>0                /* HIGH LIMIT */\n*                THEN\n*                  ZCVAL='RANGE';            /* RANGE ERROR */\n*            END;\n*        IF ZCVAL\u00ac=''\n*          THEN\n*            DO;                             /* RANGE ERROR */\n*              ZXPLISTVER='';                /* RESET IN/OUTPUT */\n*              ZMS=' 8, \"PLISTVER '||        /**KRNGP* MSG*/\n*                  PLISTVER||\n*                  '\" THE RANGE IS \"0-0\"'||\n*                  ' FOR ARGUMENT 1.';\n*              ANS MSG('?ASAXWC ---> '||ZMS);\n*              ANS(COMMENT(ZMS)) COL(MACLMAR);\n*              ZMACRET=8;                    /* MACRO ERROR */\n*            END;\n*      END;\n*\n*/********************************************************************/\n*/***PG.MF01  PROCESS MF MACRO FORMS                                 */\n*/********************************************************************/\n*/*PG.KKCTL01 VALUE, OPT INPUT, ME KYWRDCTL -KEYWORD CONTROL---------*/\n*  XMF='';\n*/*PG.KKCTL03 VALUE, OPT INPUT, ME KYWRDCTL -KEYWORD CONTROL---------*/\n*  IF TRANSLATE(MF(1))\n*              = 'S'                         /* CHECK FOR KEYWORD */\n*    THEN\n*      DO;\n*        XMFSCK='COMPLETE';\n*        XMF='S';                            /* SET XVARIABLE */\n*        IF NUMBER(MF)>1                     /* CHECK POSITIONALS */\n*          THEN\n*            DO;\n*              ZMS=' 8, \"MF'||               /**KPOSP* MSG*/\n*                  MF||\n*                  '\" \"MF\"'||\n*                  ' CAN HAVE ONLY 1 ARGUMENT.';\n*              ANS MSG('?ASAXWC ---> '||ZMS);\n*              ANS(COMMENT(ZMS)) COL(MACLMAR);\n*              ZMACRET=8;                    /* MACRO ERROR */\n*            END;\n*/*PG.KKCTL02 VALUE, OPT INPUT, ME KYWRDCTL -KEYWORD CONTROL---------*/\n*      END;  /**** END OF A MUTUALLY EXCLUSIVE KYWRDCTL DO GROUP */\n*/*PG.KKCTL03 VALUE, OPT INPUT, ME KYWRDCTL -KEYWORD CONTROL---------*/\n*  IF TRANSLATE(MF(1))\n*              = 'L'                         /* CHECK FOR KEYWORD */\n*    THEN\n*      DO;\n*        XMF='L';                            /* SET XVARIABLE */\n*        IF NUMBER(MF)>3                     /* CHECK POSITIONALS */\n*          THEN\n*            DO;\n*              ZMS=' 8, \"MF'||               /**KPOSP* MSG*/\n*                  MF||\n*                  '\" \"MF\"'||\n*                  ' CAN HAVE ONLY 3 ARGUMENTS.';\n*              ANS MSG('?ASAXWC ---> '||ZMS);\n*              ANS(COMMENT(ZMS)) COL(MACLMAR);\n*              ZMACRET=8;                    /* MACRO ERROR */\n*            END;\n*/*PG.KKCTL10 -MF(L) SPECIAL CHECK-----------------------------------*/\n*        ZMAXINVOCLEN = LENGTH(MF) + 2;\n*        IF PLISTVER \u00ac= ''\n*          THEN\n*            ZMAXINVOCLEN=ZMAXINVOCLEN + LENGTH(PLISTVER) + 8;\n*        IF LENGTH(MACKEYS) > ZMAXINVOCLEN |\n*           MACLIST \u00ac= ''                    /* CHECK FOR OTHER PARMS*/\n*          THEN\n*            DO;\n*              ZMS=' 8, THE \"L\" FORM OF \"MF\"'|| /**MFLP* MSG*/\n*                  ' CAN ONLY HAVE'||\n*                  ' THE \"PLISTVER\" KEY'||\n*                  ' SPECIFIED ON THE INVOCATION.';\n*              ANS MSG('?ASAXWC ---> '||ZMS);\n*              ANS(COMMENT(ZMS)) COL(MACLMAR);\n*              ZMACRET=8;                    /* MACRO ERROR */\n*            END;\n*/*PG.KXVAR03 NAME, OPT RQD INPUT, POS(2) -XVARIABLE-----------------*/\n*  XMFCTRL=MF(2);                            /* SET XVARIABLE */\n*  IF MF(2)=''                               /* CHECK FOR NULL */\n*   THEN\n*    DO;                                     /* KEY IS REQUIRED */\n*        ZXMFCTRL='';                        /* RESET IN/OUTPUT */\n*        ZMS=' 8, WHEN \"L\" IS SPECIFIED'||\n*            ' FOR THE \"MF\" KEY, POSITIONAL'||\n*            ' ARG 2 IS REQUIRED.';          /**KRQDP* MSG*/\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*    END;\n*  ELSE\n*    ZXMFCTRL='INPUT';                       /* SET IN/OUTPUT */\n*/*PG.KXVAR13 VALUE, OPT INPUT, POS(3) -XVARIABLE--------------------*/\n*  ZXMFATTR='INPUT';                         /* SET IN/OUTPUT */\n*  XMFATTR='BDY(DWORD)';                     /* SET DEFAULT */\n*  IF MF(3)\u00ac=''                              /* CHECK FOR NULL */\n*    THEN\n*      XMFATTR=MF(3);                        /* SET XVARIABLE */\n*/*PG.KCK01 VALUE, OPT INPUT, POS(3) -CHARACTER LENGTH---------------*/\n*  IF ZXMFATTR\u00ac='' &                         /* NOT IN/OUTPUT */\n*     LENGTH(XMFATTR)>60\n*    THEN\n*      DO;\n*        ZXMFATTR='';                        /* RESET IN/OUTPUT */\n*        ZMS=' 8, \"MF'||                     /**KLNGP* MSG*/\n*            MF||\n*            '\" ARGUMENT 3 EXCEEDS THE MAXIMUM'||\n*            ' LENGTH OF 60 CHARACTERS. ';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*/*PG.KKCTL02 VALUE, OPT INPUT, ME KYWRDCTL -KEYWORD CONTROL---------*/\n*      END;  /**** END OF A MUTUALLY EXCLUSIVE KYWRDCTL DO GROUP */\n*/*PG.KKCTL03 VALUE, OPT INPUT, ME KYWRDCTL -KEYWORD CONTROL---------*/\n*  IF TRANSLATE(MF(1))\n*              = 'M'                         /* CHECK FOR KEYWORD */\n*    THEN\n*      DO;\n*        XMF='M';                            /* SET XVARIABLE */\n*        IF NUMBER(MF)>3                     /* CHECK POSITIONALS */\n*          THEN\n*            DO;\n*              ZMS=' 8, \"MF'||               /**KPOSP* MSG*/\n*                  MF||\n*                  '\" \"MF\"'||\n*                  ' CAN HAVE ONLY 3 ARGUMENTS.';\n*              ANS MSG('?ASAXWC ---> '||ZMS);\n*              ANS(COMMENT(ZMS)) COL(MACLMAR);\n*              ZMACRET=8;                    /* MACRO ERROR */\n*            END;\n*/*PG.KXVAR03 NAME, OPT RQD INPUT, POS(2) -XVARIABLE-----------------*/\n*  XMFCTRL=MF(2);                            /* SET XVARIABLE */\n*  IF MF(2)=''                               /* CHECK FOR NULL */\n*   THEN\n*    DO;                                     /* KEY IS REQUIRED */\n*        ZXMFCTRL='';                        /* RESET IN/OUTPUT */\n*        ZMS=' 8, WHEN \"M\" IS SPECIFIED'||\n*            ' FOR THE \"MF\" KEY, POSITIONAL'||\n*            ' ARG 2 IS REQUIRED.';          /**KRQDP* MSG*/\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*    END;\n*  ELSE\n*    ZXMFCTRL='INPUT';                       /* SET IN/OUTPUT */\n*/*PG.KKWRD02 VALUE, OPT INPUT, ME KEYWORD -SINGLE KEYWORD-----------*/\n*  XMFSCK='';                                /* RESET XVARIABLE */\n*  IF TRANSLATE(MF(3))\n*              = 'COMPLETE'                  /* CHECK FOR KEYWORD */\n*    THEN\n*      XMFSCK = 'COMPLETE';                  /* SET XVARIABLE */\n*/*PG.KKWRD02 VALUE, OPT INPUT, ME KEYWORD -SINGLE KEYWORD-----------*/\n*  IF TRANSLATE(MF(3))\n*              = 'NOCHECK'                   /* CHECK FOR KEYWORD */\n*    THEN\n*      XMFSCK = 'NOCHECK';                   /* SET XVARIABLE */\n*/*PG.KKWRD03 VALUE, OPT INPUT, ME KEYWORD -SINGLE KEYWORD-----------*/\n*  ZXMFSCK='INPUT';                          /* SET IN/OUTPUT */\n*  IF XMFSCK=''                              /* CHECK FOR KEYWORD */\n*    THEN\n*      DO;                                   /* KEYWORD NOT ENTERED */\n*        XMFSCK='COMPLETE';                  /* SET DEFAULT */\n*        IF MF(3)\u00ac=''\n*          THEN\n*            DO;\n*              ZXMFSCK='';                   /* RESET IN/OUTPUT */\n*              ZMS=' 8, \"MF'||               /**KUKWP* MSG*/\n*                  MF||'\"'||\n*                  ' ARGUMENT 3 IS AN UNKNOWN KEYWORD. '||\n*                  ' VALID KEYWORD CHOICE(S) ARE:'||\n*                  ' \"COMPLETE\"'||           /* VALID KEYWORD */\n*                  ' OR \"NOCHECK\".';         /* VALID KEYWORD */\n*              ANS MSG('?ASAXWC ---> '||ZMS);\n*              ANS(COMMENT(ZMS)) COL(MACLMAR);\n*              ZMACRET=8;                    /* MACRO ERROR */\n*            END;\n*      END;\n*/*PG.KKCTL02 VALUE, OPT INPUT, ME KYWRDCTL -KEYWORD CONTROL---------*/\n*      END;  /**** END OF A MUTUALLY EXCLUSIVE KYWRDCTL DO GROUP */\n*/*PG.KKCTL03 VALUE, OPT INPUT, ME KYWRDCTL -KEYWORD CONTROL---------*/\n*  IF TRANSLATE(MF(1))\n*              = 'E'                         /* CHECK FOR KEYWORD */\n*    THEN\n*      DO;\n*        XMF='E';                            /* SET XVARIABLE */\n*        IF NUMBER(MF)>3                     /* CHECK POSITIONALS */\n*          THEN\n*            DO;\n*              ZMS=' 8, \"MF'||               /**KPOSP* MSG*/\n*                  MF||\n*                  '\" \"MF\"'||\n*                  ' CAN HAVE ONLY 3 ARGUMENTS.';\n*              ANS MSG('?ASAXWC ---> '||ZMS);\n*              ANS(COMMENT(ZMS)) COL(MACLMAR);\n*              ZMACRET=8;                    /* MACRO ERROR */\n*            END;\n*/*PG.KXVAR03 NAME, OPT RQD INPUT, POS(2) -XVARIABLE-----------------*/\n*  XMFCTRL=MF(2);                            /* SET XVARIABLE */\n*  IF MF(2)=''                               /* CHECK FOR NULL */\n*   THEN\n*    DO;                                     /* KEY IS REQUIRED */\n*        ZXMFCTRL='';                        /* RESET IN/OUTPUT */\n*        ZMS=' 8, WHEN \"E\" IS SPECIFIED'||\n*            ' FOR THE \"MF\" KEY, POSITIONAL'||\n*            ' ARG 2 IS REQUIRED.';          /**KRQDP* MSG*/\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*    END;\n*  ELSE\n*    ZXMFCTRL='INPUT';                       /* SET IN/OUTPUT */\n*/*PG.KKWRD02 VALUE, OPT INPUT, ME KEYWORD -SINGLE KEYWORD-----------*/\n*  XMFSCK='';                                /* RESET XVARIABLE */\n*  IF TRANSLATE(MF(3))\n*              = 'COMPLETE'                  /* CHECK FOR KEYWORD */\n*    THEN\n*      XMFSCK = 'COMPLETE';                  /* SET XVARIABLE */\n*/*PG.KKWRD02 VALUE, OPT INPUT, ME KEYWORD -SINGLE KEYWORD-----------*/\n*  IF TRANSLATE(MF(3))\n*              = 'NOCHECK'                   /* CHECK FOR KEYWORD */\n*    THEN\n*      XMFSCK = 'NOCHECK';                   /* SET XVARIABLE */\n*/*PG.KKWRD03 VALUE, OPT INPUT, ME KEYWORD -SINGLE KEYWORD-----------*/\n*  ZXMFSCK='INPUT';                          /* SET IN/OUTPUT */\n*  IF XMFSCK=''                              /* CHECK FOR KEYWORD */\n*    THEN\n*      DO;                                   /* KEYWORD NOT ENTERED */\n*        XMFSCK='COMPLETE';                  /* SET DEFAULT */\n*        IF MF(3)\u00ac=''\n*          THEN\n*            DO;\n*              ZXMFSCK='';                   /* RESET IN/OUTPUT */\n*              ZMS=' 8, \"MF'||               /**KUKWP* MSG*/\n*                  MF||'\"'||\n*                  ' ARGUMENT 3 IS AN UNKNOWN KEYWORD. '||\n*                  ' VALID KEYWORD CHOICE(S) ARE:'||\n*                  ' \"COMPLETE\"'||           /* VALID KEYWORD */\n*                  ' OR \"NOCHECK\".';         /* VALID KEYWORD */\n*              ANS MSG('?ASAXWC ---> '||ZMS);\n*              ANS(COMMENT(ZMS)) COL(MACLMAR);\n*              ZMACRET=8;                    /* MACRO ERROR */\n*            END;\n*      END;\n*/*PG.KKCTL05 VALUE, OPT INPUT, ME KYWRDCTL -KEYWORD CONTROL---------*/\n*      END;  /**** END OF A MUTUALLY EXCLUSIVE KYWRDCTL DO GROUP */\n*/*PG.KKCTL06 VALUE, OPT INPUT, ME KYWRDCTL -KEYWORD CONTROL---------*/\n*  IF MF='MF'\n*    | MF='()'                               /*CHECK ENTRY*/\n*     THEN\n*       DO;\n*              ZMS=' 8, THE \"MF\" KEY'||      /**KOPTP* MSG*/\n*                  ' MUST CONTAIN ONE'||\n*                  ' (OR MORE) ARGUMENT(S).';\n*              ANS MSG('?ASAXWC ---> '||ZMS);\n*              ANS(COMMENT(ZMS)) COL(MACLMAR);\n*              ZMACRET=8;                    /* MACRO ERROR */\n*       END;\n*  ELSE\n*    DO;\n*      ZXMF='INPUT';                         /* SET IN/OUTPUT */\n*      IF XMF=''                             /* CHECK FOR KEYWORD */\n*        THEN\n*          DO;                               /* KEYWORD NOT ENTERED */\n*            XMF='S';                        /* SET DEFAULT */\n*            XMFSCK='COMPLETE';              /* COMPLETE CHECKING */\n*            IF MF(1)\u00ac=''                    /* CHECK FOR KEYWORD */\n*              THEN\n*                DO;\n*                  ZXMF='';                  /* RESET IN/OUTPUT */\n*              ZMS=' 8, \"MF'||               /**KUKWP* MSG*/\n*                  MF||'\"'||\n*                  ' ARGUMENT 1 IS AN UNKNOWN KEYWORD. '||\n*                  ' VALID KEYWORD CHOICE(S) ARE:'||\n*                  ' \"S\",'||                 /* VALID KEYWORD */\n*                  ' \"L\",'||                 /* VALID KEYWORD */\n*                  ' \"M\",'||                 /* VALID KEYWORD */\n*                  ' OR \"E\".';               /* VALID KEYWORD */\n*              ANS MSG('?ASAXWC ---> '||ZMS);\n*              ANS(COMMENT(ZMS)) COL(MACLMAR);\n*              ZMACRET=8;                    /* MACRO ERROR */\n*                END;\n*          END;\n*    END;\n*/********************************************************************/\n*/***PD.P01 FULL DEFAULT CHECKING                                    */\n*/********************************************************************/\n*  IF PLISTVER=''\n*     | PLISTVER(1)='IMPLIED_VERSION'\n*    THEN\n*      ZC='ON';                              /* DEFAULT FLAG ON */\n*    ELSE\n*      ZC='OFF';                             /* DEFAULT FLAG OFF */\n*/********************************************************************/\n*/***PD.P02 DEFAULT ECHO                                             */\n*/********************************************************************/\n*/*PD.P02 XMF\u00ac='L' & XMFSCK='COMPLETE' ------------------------------*/\n*  IF XMF\u00ac='L'\n*     & XMFSCK='COMPLETE'\n*    THEN\n*      DO;                                   /* FULL SYNTAX CHECK */\n*        ANS('/*DEFAULT(S): */')\n*           NORESCAN COL(MACLMAR+5);\n*/*PD.DFLT02 PRINT DEFAULT(S) IF APPROPRIATE ------------------------*/\n*  IF PLISTVER=''\n*    THEN\n*      ANS('/* PLISTVER('||\n*          CHAR(XPLISTVER)||\n*          ')*/')\n*          NORESCAN COL(MACLMAR+5);\n*/*PD.KXVAR01 NAME, OPT INPUT, KEYS -XVARIABLE-----------------------*/\n*  XDELIMITER='';\n*  IF DELIMITER(1)=''\n*    THEN\n*      DO;\n*        XDELIMITER='LENGTHS_WERE_SET';      /* SET DEFAULT */\n*        ZC='ON';                            /* DEFAULT FLAG ON */\n*      END;\n*/*PD.DFLT02 PRINT DEFAULT(S) IF APPROPRIATE ------------------------*/\n*  IF XDELIMITER\u00ac=''\n*    THEN\n*      ANS('/* DELIMITER('||\n*          XDELIMITER||\n*          ')*/')\n*          NORESCAN COL(MACLMAR+5);\n*/*PD.KXVAR01 NAME, OPT INPUT, KEYS -XVARIABLE-----------------------*/\n*  XWORKAREA='';\n*  IF WORKAREA(1)=''\n*    THEN\n*      DO;\n*        XWORKAREA='NO_WORKAREA';            /* SET DEFAULT */\n*        ZC='ON';                            /* DEFAULT FLAG ON */\n*      END;\n*/*PD.DFLT02 PRINT DEFAULT(S) IF APPROPRIATE ------------------------*/\n*  IF XWORKAREA\u00ac=''\n*    THEN\n*      ANS('/* WORKAREA('||\n*          XWORKAREA||\n*          ')*/')\n*          NORESCAN COL(MACLMAR+5);\n*  IF ZC='OFF'                               /*NO DEFAULTS TAKEN */\n*    THEN\n*      ANS('/* NONE. */')\n*         NORESCAN COL(MACLMAR+5);\n*/*PD.P04 END DEFAULT ECHO ------------------------------------------*/\n*      END;\n*/********************************************************************/\n*/*PB.SYSL01 INVOKE SP LEVEL AND SYSTEM STATE MACROS                 */\n*/********************************************************************/\n*  DCL SYSSPLV CHAR EXTERNAL; DEACT SYSSPLV;/* SPLEVEL 1,2,3         */\n*  DCL SYSASCE CHAR EXTERNAL; DEACT SYSASCE;/* STATE ANY P AR */\n*\n*  IF SYSASCE=''\n*    THEN\n*      DO;\n*        IF SYSSPLV=''\n*          THEN\n*            ANS('?SPLEVEL  (TEST);') COL(MACLMAR);\n*        IF SYSSPLV\u00ac='1' & SYSSPLV\u00ac='2'\n*          THEN\n*            ANS('?SYSSTATE (TEST);') COL(MACLMAR);\n*          ELSE\n*            SYSASCE='P';                    /* SYSSTATE DEFAULT*/\n*      END;\n*/********************************************************************/\n*/***PG.P01 FULL MACRO SYNTAX CHECKING                               */\n*/********************************************************************/\n*/*PG.P02 XMF\u00ac='L' & XMFSCK='COMPLETE' ------------------------------*/\n*  IF XMF\u00ac='L'\n*     & XMFSCK='COMPLETE'\n*    THEN\n*      DO;                                   /* FULL SYNTAX CHECK */\n*/*PG.P03 EXCESSIVE POSITIONAL ARGUMENTS-----------------------------*/\n*  IF NUMBER(MACLIST)>0                      /* CHECK POSITIONALS */\n*    THEN\n*      DO;\n*        ZMS=' 8, POSITIONAL ARGUMENT(S),'|| /**PPOSP* MSG*/\n*            ' \"'||MACLIST||'\"'||\n*            ' CANNOT BE USED.'||\n*            ' NO POSITIONAL ARGUMENTS'||\n*            ' ARE ALLOWED.';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*/*PG.KXVAR01 NAME, RQD INPUT, KEYS -EXCESSIVE ARGUMENTS-------------*/\n*  IF NUMBER(PATTERNSTR)>1                   /* CHECK POSITIONALS */\n*    THEN\n*      DO;\n*        ZMS=' 8, \"PATTERNSTR'||             /**KPOSP* MSG*/\n*            PATTERNSTR||\n*            '\" \"PATTERNSTR\"'||\n*            ' CAN HAVE ONLY 1 ARGUMENT.';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*/*PG.KXVAR03 NAME, RQD INPUT, KEYS -XVARIABLE-----------------------*/\n*  XPATTERNSTR=PATTERNSTR(1);                /* SET XVARIABLE */\n*  IF PATTERNSTR(1)=''                       /* CHECK FOR NULL */\n*   THEN\n*    DO;                                     /* KEY IS REQUIRED */\n*        ZXPATTERNSTR='';                    /* RESET IN/OUTPUT */\n*        ZMS=' 8,  '||\n*            ' \"PATTERNSTR\" KEY AND ITS ARGUMENT'||\n*            ' ARE REQUIRED.';               /**KRQDP* MSG*/\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*    END;\n*  ELSE\n*    ZXPATTERNSTR='INPUT';                   /* SET IN/OUTPUT */\n*/*PG.KXVAR01 NAME, RQD INPUT, KEYS -EXCESSIVE ARGUMENTS-------------*/\n*  IF NUMBER(PATTERNSTRLEN)>1                /* CHECK POSITIONALS */\n*    THEN\n*      DO;\n*        ZMS=' 8, \"PATTERNSTRLEN'||          /**KPOSP* MSG*/\n*            PATTERNSTRLEN||\n*            '\" \"PATTERNSTRLEN\"'||\n*            ' CAN HAVE ONLY 1 ARGUMENT.';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*/*PG.KXVAR03 NAME, RQD INPUT, KEYS -XVARIABLE-----------------------*/\n*  XPATTERNSTRLEN=PATTERNSTRLEN(1);          /* SET XVARIABLE */\n*  IF PATTERNSTRLEN(1)=''                    /* CHECK FOR NULL */\n*   THEN\n*    DO;                                     /* KEY IS REQUIRED */\n*        ZXPATTERNSTRLEN='';                 /* RESET IN/OUTPUT */\n*        ZMS=' 8,  '||\n*            ' \"PATTERNSTRLEN\" KEY AND ITS ARGUMENT'||\n*            ' ARE REQUIRED.';               /**KRQDP* MSG*/\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*    END;\n*  ELSE\n*    ZXPATTERNSTRLEN='INPUT';                /* SET IN/OUTPUT */\n*/*PG.KXVAR01 NAME, RQD INPUT, KEYS -EXCESSIVE ARGUMENTS-------------*/\n*  IF NUMBER(STRING)>1                       /* CHECK POSITIONALS */\n*    THEN\n*      DO;\n*        ZMS=' 8, \"STRING'||                 /**KPOSP* MSG*/\n*            STRING||\n*            '\" \"STRING\"'||\n*            ' CAN HAVE ONLY 1 ARGUMENT.';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*/*PG.KXVAR03 NAME, RQD INPUT, KEYS -XVARIABLE-----------------------*/\n*  XSTRING=STRING(1);                        /* SET XVARIABLE */\n*  IF STRING(1)=''                           /* CHECK FOR NULL */\n*   THEN\n*    DO;                                     /* KEY IS REQUIRED */\n*        ZXSTRING='';                        /* RESET IN/OUTPUT */\n*        ZMS=' 8,  '||\n*            ' \"STRING\" KEY AND ITS ARGUMENT'||\n*            ' ARE REQUIRED.';               /**KRQDP* MSG*/\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*    END;\n*  ELSE\n*    ZXSTRING='INPUT';                       /* SET IN/OUTPUT */\n*/*PG.KXVAR01 NAME, RQD INPUT, KEYS -EXCESSIVE ARGUMENTS-------------*/\n*  IF NUMBER(STRINGLEN)>1                    /* CHECK POSITIONALS */\n*    THEN\n*      DO;\n*        ZMS=' 8, \"STRINGLEN'||              /**KPOSP* MSG*/\n*            STRINGLEN||\n*            '\" \"STRINGLEN\"'||\n*            ' CAN HAVE ONLY 1 ARGUMENT.';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*/*PG.KXVAR03 NAME, RQD INPUT, KEYS -XVARIABLE-----------------------*/\n*  XSTRINGLEN=STRINGLEN(1);                  /* SET XVARIABLE */\n*  IF STRINGLEN(1)=''                        /* CHECK FOR NULL */\n*   THEN\n*    DO;                                     /* KEY IS REQUIRED */\n*        ZXSTRINGLEN='';                     /* RESET IN/OUTPUT */\n*        ZMS=' 8,  '||\n*            ' \"STRINGLEN\" KEY AND ITS ARGUMENT'||\n*            ' ARE REQUIRED.';               /**KRQDP* MSG*/\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*    END;\n*  ELSE\n*    ZXSTRINGLEN='INPUT';                    /* SET IN/OUTPUT */\n*/*PG.KXVAR01 NAME, RQD INPUT, KEYS -EXCESSIVE ARGUMENTS-------------*/\n*  IF NUMBER(ZEROORMORE)>1                   /* CHECK POSITIONALS */\n*    THEN\n*      DO;\n*        ZMS=' 8, \"ZEROORMORE'||             /**KPOSP* MSG*/\n*            ZEROORMORE||\n*            '\" \"ZEROORMORE\"'||\n*            ' CAN HAVE ONLY 1 ARGUMENT.';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*/*PG.KXVAR03 NAME, RQD INPUT, KEYS -XVARIABLE-----------------------*/\n*  XZEROORMORE=ZEROORMORE(1);                /* SET XVARIABLE */\n*  IF ZEROORMORE(1)=''                       /* CHECK FOR NULL */\n*   THEN\n*    DO;                                     /* KEY IS REQUIRED */\n*        ZXZEROORMORE='';                    /* RESET IN/OUTPUT */\n*        ZMS=' 8,  '||\n*            ' \"ZEROORMORE\" KEY AND ITS ARGUMENT'||\n*            ' ARE REQUIRED.';               /**KRQDP* MSG*/\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*    END;\n*  ELSE\n*    ZXZEROORMORE='INPUT';                   /* SET IN/OUTPUT */\n*/*PG.KXVAR01 NAME, RQD INPUT, KEYS -EXCESSIVE ARGUMENTS-------------*/\n*  IF NUMBER(ONECHAR)>1                      /* CHECK POSITIONALS */\n*    THEN\n*      DO;\n*        ZMS=' 8, \"ONECHAR'||                /**KPOSP* MSG*/\n*            ONECHAR||\n*            '\" \"ONECHAR\"'||\n*            ' CAN HAVE ONLY 1 ARGUMENT.';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*/*PG.KXVAR03 NAME, RQD INPUT, KEYS -XVARIABLE-----------------------*/\n*  XONECHAR=ONECHAR(1);                      /* SET XVARIABLE */\n*  IF ONECHAR(1)=''                          /* CHECK FOR NULL */\n*   THEN\n*    DO;                                     /* KEY IS REQUIRED */\n*        ZXONECHAR='';                       /* RESET IN/OUTPUT */\n*        ZMS=' 8,  '||\n*            ' \"ONECHAR\" KEY AND ITS ARGUMENT'||\n*            ' ARE REQUIRED.';               /**KRQDP* MSG*/\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*    END;\n*  ELSE\n*    ZXONECHAR='INPUT';                      /* SET IN/OUTPUT */\n*/*PG.KXVAR01 NAME, OPT INPUT, KEYS -EXCESSIVE ARGUMENTS-------------*/\n*  IF DELIMITER='DELIMITER' | DELIMITER='()'  /*CHECK ENTRY*/\n*    THEN\n*      DO;\n*        ZMS=' 8, THE \"DELIMITER\" KEY'||     /**KOPTP* MSG*/\n*            ' MUST CONTAIN ONE'||\n*            ' (OR MORE) ARGUMENT(S).';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*  IF NUMBER(DELIMITER)>1                    /* CHECK POSITIONALS */\n*    THEN\n*      DO;\n*        ZMS=' 8, \"DELIMITER'||              /**KPOSP* MSG*/\n*            DELIMITER||\n*            '\" \"DELIMITER\"'||\n*            ' CAN HAVE ONLY 1 ARGUMENT.';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*/*PG.KXVAR13 NAME, OPT INPUT, KEYS -XVARIABLE-----------------------*/\n*  ZXDELIMITER='INPUT';                      /* SET IN/OUTPUT */\n*  XDELIMITER='LENGTHS_WERE_SET';            /* SET DEFAULT */\n*  IF DELIMITER(1)\u00ac=''                       /* CHECK FOR NULL */\n*    THEN\n*      XDELIMITER=DELIMITER(1);              /* SET XVARIABLE */\n*/*PG.KXVAR01 NAME, OPT INPUT, KEYS -EXCESSIVE ARGUMENTS-------------*/\n*  IF WORKAREA='WORKAREA' | WORKAREA='()'    /*CHECK ENTRY*/\n*    THEN\n*      DO;\n*        ZMS=' 8, THE \"WORKAREA\" KEY'||      /**KOPTP* MSG*/\n*            ' MUST CONTAIN ONE'||\n*            ' (OR MORE) ARGUMENT(S).';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*  IF NUMBER(WORKAREA)>1                     /* CHECK POSITIONALS */\n*    THEN\n*      DO;\n*        ZMS=' 8, \"WORKAREA'||               /**KPOSP* MSG*/\n*            WORKAREA||\n*            '\" \"WORKAREA\"'||\n*            ' CAN HAVE ONLY 1 ARGUMENT.';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*/*PG.KXVAR13 NAME, OPT INPUT, KEYS -XVARIABLE-----------------------*/\n*  ZXWORKAREA='INPUT';                       /* SET IN/OUTPUT */\n*  XWORKAREA='NO_WORKAREA';                  /* SET DEFAULT */\n*  IF WORKAREA(1)\u00ac=''                        /* CHECK FOR NULL */\n*    THEN\n*      XWORKAREA=WORKAREA(1);                /* SET XVARIABLE */\n*/*PG.KXVAR01 NAME, OPT OUTPUT, KEYS -EXCESSIVE ARGUMENTS------------*/\n*  IF RETCODE='RETCODE' | RETCODE='()'       /*CHECK ENTRY*/\n*    THEN\n*      DO;\n*        ZMS=' 8, THE \"RETCODE\" KEY'||       /**KOPTP* MSG*/\n*            ' MUST CONTAIN ONE'||\n*            ' (OR MORE) ARGUMENT(S).';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*  IF NUMBER(RETCODE)>1                      /* CHECK POSITIONALS */\n*    THEN\n*      DO;\n*        ZMS=' 8, \"RETCODE'||                /**KPOSP* MSG*/\n*            RETCODE||\n*            '\" \"RETCODE\"'||\n*            ' CAN HAVE ONLY 1 ARGUMENT.';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*/*PG.KXVAR15 NAME, OPT OUTPUT, KEYS -XVARIABLE----------------------*/\n*  IF RETCODE(1)\u00ac=''                         /* CHECK FOR NULL */\n*    THEN\n*      DO;\n*        XRETCODE=RETCODE(1);                /* SET XVARIABLE */\n*        ZXRETCODE='OUTPUT';                 /* SET OUTPUT */\n*      END;\n*  ELSE\n*    IF ZXRETCODE\u00ac=''\n*      THEN\n*        ZXRETCODE='';                       /* RESET OUTPUT */\n*/*PG.P04 XMF\u00ac='L' & XMFSCK='COMPLETE' ------------------------------*/\n*      END;                                  /* END COMPLETE CHECKING*/\n*/********************************************************************/\n*/***PE.MF00 PARTIAL MACRO SYNTAX CHECKING                           */\n*/********************************************************************/\n*/*PE.MF01 XMF\u00ac='L' & XMFSCK='NOCHECK' ------------------------------*/\n*  IF XMF\u00ac='L' & XMFSCK='NOCHECK'\n*    THEN\n*      DO;                                   /* PARTIAL SYNTAX CHECK */\n*/*PE.KC00 INITIALIZE KEYWORD CONTROL VARIABLES----------------------*/\n*/*PE.P01 EXCESSIVE POSITIONALS--------------------------------------*/\n*  IF NUMBER(MACLIST)>0                      /* CHECK POSITIONALS */\n*    THEN\n*      DO;\n*        ZMS=' 8, POSITIONAL ARGUMENT(S),'|| /**PPOSP* MSG*/\n*            ' \"'||MACLIST||'\"'||\n*            ' CANNOT BE USED.'||\n*            ' NO POSITIONAL ARGUMENTS'||\n*            ' ARE ALLOWED.';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*/*PE.KXVAR01 NAME, RQD INPUT, KEYS -EXCESSIVE ARGUMENTS-------------*/\n*  IF NUMBER(PATTERNSTR)>1                   /* CHECK POSITIONALS */\n*    THEN\n*      DO;\n*        ZMS=' 8, \"PATTERNSTR'||             /**KPOSP* MSG*/\n*            PATTERNSTR||\n*            '\" \"PATTERNSTR\"'||\n*            ' CAN HAVE ONLY 1 ARGUMENT.';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*/*PE.KXVAR03 NAME, RQD INPUT, KEYS -XVARIABLE-----------------------*/\n*  IF PATTERNSTR(1)\u00ac=''                      /* CHECK FOR NULL */\n*    THEN\n*      DO;\n*        XPATTERNSTR=PATTERNSTR(1);          /* SET XVARIABLE */\n*        ZXPATTERNSTR='INPUT';               /* SET IN/OUTPUT */\n*      END;\n*/*PE.KXVAR01 NAME, RQD INPUT, KEYS -EXCESSIVE ARGUMENTS-------------*/\n*  IF NUMBER(PATTERNSTRLEN)>1                /* CHECK POSITIONALS */\n*    THEN\n*      DO;\n*        ZMS=' 8, \"PATTERNSTRLEN'||          /**KPOSP* MSG*/\n*            PATTERNSTRLEN||\n*            '\" \"PATTERNSTRLEN\"'||\n*            ' CAN HAVE ONLY 1 ARGUMENT.';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*/*PE.KXVAR03 NAME, RQD INPUT, KEYS -XVARIABLE-----------------------*/\n*  IF PATTERNSTRLEN(1)\u00ac=''                   /* CHECK FOR NULL */\n*    THEN\n*      DO;\n*        XPATTERNSTRLEN=PATTERNSTRLEN(1);    /* SET XVARIABLE */\n*        ZXPATTERNSTRLEN='INPUT';            /* SET IN/OUTPUT */\n*      END;\n*/*PE.KXVAR01 NAME, RQD INPUT, KEYS -EXCESSIVE ARGUMENTS-------------*/\n*  IF NUMBER(STRING)>1                       /* CHECK POSITIONALS */\n*    THEN\n*      DO;\n*        ZMS=' 8, \"STRING'||                 /**KPOSP* MSG*/\n*            STRING||\n*            '\" \"STRING\"'||\n*            ' CAN HAVE ONLY 1 ARGUMENT.';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*/*PE.KXVAR03 NAME, RQD INPUT, KEYS -XVARIABLE-----------------------*/\n*  IF STRING(1)\u00ac=''                          /* CHECK FOR NULL */\n*    THEN\n*      DO;\n*        XSTRING=STRING(1);                  /* SET XVARIABLE */\n*        ZXSTRING='INPUT';                   /* SET IN/OUTPUT */\n*      END;\n*/*PE.KXVAR01 NAME, RQD INPUT, KEYS -EXCESSIVE ARGUMENTS-------------*/\n*  IF NUMBER(STRINGLEN)>1                    /* CHECK POSITIONALS */\n*    THEN\n*      DO;\n*        ZMS=' 8, \"STRINGLEN'||              /**KPOSP* MSG*/\n*            STRINGLEN||\n*            '\" \"STRINGLEN\"'||\n*            ' CAN HAVE ONLY 1 ARGUMENT.';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*/*PE.KXVAR03 NAME, RQD INPUT, KEYS -XVARIABLE-----------------------*/\n*  IF STRINGLEN(1)\u00ac=''                       /* CHECK FOR NULL */\n*    THEN\n*      DO;\n*        XSTRINGLEN=STRINGLEN(1);            /* SET XVARIABLE */\n*        ZXSTRINGLEN='INPUT';                /* SET IN/OUTPUT */\n*      END;\n*/*PE.KXVAR01 NAME, RQD INPUT, KEYS -EXCESSIVE ARGUMENTS-------------*/\n*  IF NUMBER(ZEROORMORE)>1                   /* CHECK POSITIONALS */\n*    THEN\n*      DO;\n*        ZMS=' 8, \"ZEROORMORE'||             /**KPOSP* MSG*/\n*            ZEROORMORE||\n*            '\" \"ZEROORMORE\"'||\n*            ' CAN HAVE ONLY 1 ARGUMENT.';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*/*PE.KXVAR03 NAME, RQD INPUT, KEYS -XVARIABLE-----------------------*/\n*  IF ZEROORMORE(1)\u00ac=''                      /* CHECK FOR NULL */\n*    THEN\n*      DO;\n*        XZEROORMORE=ZEROORMORE(1);          /* SET XVARIABLE */\n*        ZXZEROORMORE='INPUT';               /* SET IN/OUTPUT */\n*      END;\n*/*PE.KXVAR01 NAME, RQD INPUT, KEYS -EXCESSIVE ARGUMENTS-------------*/\n*  IF NUMBER(ONECHAR)>1                      /* CHECK POSITIONALS */\n*    THEN\n*      DO;\n*        ZMS=' 8, \"ONECHAR'||                /**KPOSP* MSG*/\n*            ONECHAR||\n*            '\" \"ONECHAR\"'||\n*            ' CAN HAVE ONLY 1 ARGUMENT.';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*/*PE.KXVAR03 NAME, RQD INPUT, KEYS -XVARIABLE-----------------------*/\n*  IF ONECHAR(1)\u00ac=''                         /* CHECK FOR NULL */\n*    THEN\n*      DO;\n*        XONECHAR=ONECHAR(1);                /* SET XVARIABLE */\n*        ZXONECHAR='INPUT';                  /* SET IN/OUTPUT */\n*      END;\n*/*PE.KXVAR01 NAME, OPT INPUT, KEYS -EXCESSIVE ARGUMENTS-------------*/\n*  IF DELIMITER='DELIMITER'                  /* CHECK ENTRY */\n*    THEN\n*      DO;\n*        ZMS=' 8, THE \"DELIMITER\" KEY'||     /**KOPTP* MSG*/\n*            ' MUST CONTAIN ONE'||\n*            ' (OR MORE) ARGUMENT(S).';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*  IF NUMBER(DELIMITER)>1                    /* CHECK POSITIONALS */\n*    THEN\n*      DO;\n*        ZMS=' 8, \"DELIMITER'||              /**KPOSP* MSG*/\n*            DELIMITER||\n*            '\" \"DELIMITER\"'||\n*            ' CAN HAVE ONLY 1 ARGUMENT.';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*/*PE.KXVAR03 NAME, OPT INPUT, KEYS -XVARIABLE-----------------------*/\n*  IF DELIMITER(1)\u00ac=''                       /* CHECK FOR NULL */\n*    THEN\n*      DO;\n*        XDELIMITER=DELIMITER(1);            /* SET XVARIABLE */\n*        ZXDELIMITER='INPUT';                /* SET IN/OUTPUT */\n*      END;\n*/*PE.KXVAR01 NAME, OPT INPUT, KEYS -EXCESSIVE ARGUMENTS-------------*/\n*  IF WORKAREA='WORKAREA'                    /* CHECK ENTRY */\n*    THEN\n*      DO;\n*        ZMS=' 8, THE \"WORKAREA\" KEY'||      /**KOPTP* MSG*/\n*            ' MUST CONTAIN ONE'||\n*            ' (OR MORE) ARGUMENT(S).';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*  IF NUMBER(WORKAREA)>1                     /* CHECK POSITIONALS */\n*    THEN\n*      DO;\n*        ZMS=' 8, \"WORKAREA'||               /**KPOSP* MSG*/\n*            WORKAREA||\n*            '\" \"WORKAREA\"'||\n*            ' CAN HAVE ONLY 1 ARGUMENT.';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*/*PE.KXVAR03 NAME, OPT INPUT, KEYS -XVARIABLE-----------------------*/\n*  IF WORKAREA(1)\u00ac=''                        /* CHECK FOR NULL */\n*    THEN\n*      DO;\n*        XWORKAREA=WORKAREA(1);              /* SET XVARIABLE */\n*        ZXWORKAREA='INPUT';                 /* SET IN/OUTPUT */\n*      END;\n*/*PE.KXVAR01 NAME, OPT OUTPUT, KEYS -EXCESSIVE ARGUMENTS------------*/\n*  IF RETCODE='RETCODE'                      /* CHECK ENTRY */\n*    THEN\n*      DO;\n*        ZMS=' 8, THE \"RETCODE\" KEY'||       /**KOPTP* MSG*/\n*            ' MUST CONTAIN ONE'||\n*            ' (OR MORE) ARGUMENT(S).';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*  IF NUMBER(RETCODE)>1                      /* CHECK POSITIONALS */\n*    THEN\n*      DO;\n*        ZMS=' 8, \"RETCODE'||                /**KPOSP* MSG*/\n*            RETCODE||\n*            '\" \"RETCODE\"'||\n*            ' CAN HAVE ONLY 1 ARGUMENT.';\n*        ANS MSG('?ASAXWC ---> '||ZMS);\n*        ANS(COMMENT(ZMS)) COL(MACLMAR);\n*        ZMACRET=8;                          /* MACRO ERROR */\n*      END;\n*/*PE.KXVAR03 NAME, OPT OUTPUT, KEYS -XVARIABLE----------------------*/\n*  IF RETCODE(1)\u00ac=''                         /* CHECK FOR NULL */\n*    THEN\n*      DO;\n*        XRETCODE=RETCODE(1);                /* SET XVARIABLE */\n*        ZXRETCODE='OUTPUT';                 /* SET IN/OUTPUT */\n*      END;\n*/*PE.MF02 XMF\u00ac='L' & XMFSCK='NOCHECK' ------------------------------*/\n*      END;                                  /* END PARTIAL CHECK */\n*/********************************************************************/\n*/***PE.MR01 GENERATE CODE IF ZMACRET=0                              */\n*/********************************************************************/\n*  IF ZMACRET = 0\n*    THEN\n*      DO;\n*/********************************************************************/\n*/***PE.PR01 PRINT CONTROLS, DEFAULT IS YES                          */\n*/********************************************************************/\n*  ANS(MACCONC||'LIST PUSH NOECHO;') NORESCAN COL(MACLMAR);\n*  IF ZPRINT='NO'                            /* PRINT IS OFF */\n*    THEN\n*      ANS(MACCONC||'LIST OFF NOECHO;') NORESCAN COL(MACLMAR);\n*    ELSE\n*      ANS(MACCONC||'LIST ON NOECHO;')  NORESCAN COL(MACLMAR);\n*/********************************************************************/\n*/*PE.DO02 OUTER MACRO DO STATEMENT----------------------------------*/\n*  IF XMF\u00ac='L'\n*    THEN\n*      ANS('DO; /* ASAXWC-PLISTVER */')\n*          NORESCAN COL(MACLMAR);\n*/*MCMPLS01 RFY 15*/\n*  IF XMF\u00ac='L' & ZMACRET = 0\n*    THEN\n*      ANS('RFY GPR15F RSTD;') NORESCAN COL(MACLMAR);\n*/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n*DCL EHAMAPS CHAR EXTERNAL;\n*IF INDEX(EHAMAPS,'XM@')=0 THEN\n*  EHAMAPS=EHAMAPS||'XM@,';\n*DCL EHAREGS CHAR EXTERNAL;\n*IF INDEX(EHAREGS,'00P')=0 THEN\n*  EHAREGS=EHAREGS||'00P';\n*IF XMF = 'M' & WorkArea \u00ac= '' THEN\n*DO;\n*   ZMS = 'WORKAREA IS NOT ALLOWED WITH MF(M)';\n*   ANS MSG('?ASAXWC ---> '||ZMS);\n*   ANS(COMMENT(ZMS)) COL(MACLMAR);\n*   ZMACRET=8;                          /* MACRO ERROR */\n*END;\n*/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n*/*PL.LL01 ?ASAXWC MF=L PARAMETER LIST-------------------------------*/\n*  IF XMF='L'\n*    THEN\n*      DO;\n*        ANS('DCL 1 '||XMFCTRL||' '||XMFATTR||', '||\n*            '/* ?ASAXWC PARM LIST*/')\n*            NORESCAN COL(MACLMAR);\n*/*PL.LL13 ADDR XPATTERNSTR PTR(31) INPUT ADDR-----------------------*/\n*        ANS('2 '||XMFCTRL||\n*            '_XPATTERNSTR_ADDR PTR(31), '||\n*            '/* '||ZXPATTERNSTR_ADDR||' XPATTERNSTR_ADDR */')\n*            NORESCAN COL(MACLMAR+2);\n*/*PL.LL13  XPATTERNSTRLEN FIXED(31) INPUT---------------------------*/\n*        ANS('2 '||XMFCTRL||\n*            '_XPATTERNSTRLEN FIXED(31), '||\n*            '/* '||ZXPATTERNSTRLEN||' XPATTERNSTRLEN */')\n*            NORESCAN COL(MACLMAR+2);\n*/*PL.LL13 ADDR XSTRING PTR(31) INPUT ADDR---------------------------*/\n*        ANS('2 '||XMFCTRL||\n*            '_XSTRING_ADDR PTR(31), '||\n*            '/* '||ZXSTRING_ADDR||' XSTRING_ADDR */')\n*            NORESCAN COL(MACLMAR+2);\n*/*PL.LL13  XSTRINGLEN FIXED(31) INPUT-------------------------------*/\n*        ANS('2 '||XMFCTRL||\n*            '_XSTRINGLEN FIXED(31), '||\n*            '/* '||ZXSTRINGLEN||' XSTRINGLEN */')\n*            NORESCAN COL(MACLMAR+2);\n*/*PL.LL13 ADDR XZEROORMORE PTR(31) INPUT ADDR-----------------------*/\n*        ANS('2 '||XMFCTRL||\n*            '_XZEROORMORE_ADDR PTR(31), '||\n*            '/* '||ZXZEROORMORE_ADDR||' XZEROORMORE_ADDR */')\n*            NORESCAN COL(MACLMAR+2);\n*/*PL.LL13 ADDR XONECHAR PTR(31) INPUT ADDR--------------------------*/\n*        ANS('2 '||XMFCTRL||\n*            '_XONECHAR_ADDR PTR(31), '||\n*            '/* '||ZXONECHAR_ADDR||' XONECHAR_ADDR */')\n*            NORESCAN COL(MACLMAR+2);\n*/*PL.LL13 ADDR XDELIMITER PTR(31) INPUT ADDR------------------------*/\n*        ANS('2 '||XMFCTRL||\n*            '_XDELIMITER_ADDR PTR(31), '||\n*            '/* '||ZXDELIMITER_ADDR||' XDELIMITER_ADDR */')\n*            NORESCAN COL(MACLMAR+2);\n*/*PL.LL18 ----------------------------------------------------------*/\n*        ANS('2 * CHAR(0);')\n*            NORESCAN COL(MACLMAR+2);\n*/*PL.LL17 END OF MF=L PARAMETER LIST--------------------------------*/\n*      END;\n*/*PL.L01 MACRO WORK VARIABLES---------------------------------------*/\n*  DCL ZPRMLINE CHAR;          /* ZPRM ARRAY ENTRY ACCUMULATOR      */\n*  DEACT ZPRMLINE;\n*  DCL ZNDX CHAR;              /* UNIQUE LIST STRUCTURE NAME        */\n*  DEACT ZNDX;\n*  ZNDX=MACINDEX(1:4);         /* MACINDEX LAST THREE DIGITS        */\n*/*PL.L02 ?ASAXWC PARAMETER LIST-------------------------------------*/\n*  IF XMF\u00ac='L'\n*    THEN\n*      DO;\n*/*PL.L03 ?ASAXWC PARAMETER LIST-------------------------------------*/\n*        IF XMF='S'\n*          THEN\n*            XMFCTRL='#ZPLIST';\n*/*PL.L04 ?ASAXWC PARAMETER LIST-------------------------------------*/\n*        ZPRMLINE='DCL 1 #Z'||ZNDX||' DEF('||XMFCTRL||'),'||\n*                 ' /* ?ASAXWC PARM LIST*/';\n*/*PL.L08 ADDR XPATTERNSTR PTR(31) INPUT ADDR------------------------*/\n*        ZPRMLINE=ZPRMLINE||' 2 #Z'||ZNDX||\n*                 '_XPATTERNSTR_ADDR PTR(31), '||\n*                 '/* '||ZXPATTERNSTR_ADDR||' XPATTERNSTR_ADDR */';\n*/*PL.L08  XPATTERNSTRLEN FIXED(31) INPUT----------------------------*/\n*        ZPRMLINE=ZPRMLINE||' 2 #Z'||ZNDX||\n*                 '_XPATTERNSTRLEN FIXED(31), '||\n*                 '/* '||ZXPATTERNSTRLEN||' XPATTERNSTRLEN */';\n*/*PL.L08 ADDR XSTRING PTR(31) INPUT ADDR----------------------------*/\n*        ZPRMLINE=ZPRMLINE||' 2 #Z'||ZNDX||\n*                 '_XSTRING_ADDR PTR(31), '||\n*                 '/* '||ZXSTRING_ADDR||' XSTRING_ADDR */';\n*/*PL.L08  XSTRINGLEN FIXED(31) INPUT--------------------------------*/\n*        ZPRMLINE=ZPRMLINE||' 2 #Z'||ZNDX||\n*                 '_XSTRINGLEN FIXED(31), '||\n*                 '/* '||ZXSTRINGLEN||' XSTRINGLEN */';\n*/*PL.L08 ADDR XZEROORMORE PTR(31) INPUT ADDR------------------------*/\n*        ZPRMLINE=ZPRMLINE||' 2 #Z'||ZNDX||\n*                 '_XZEROORMORE_ADDR PTR(31), '||\n*                 '/* '||ZXZEROORMORE_ADDR||' XZEROORMORE_ADDR */';\n*/*PL.L08 ADDR XONECHAR PTR(31) INPUT ADDR---------------------------*/\n*        ZPRMLINE=ZPRMLINE||' 2 #Z'||ZNDX||\n*                 '_XONECHAR_ADDR PTR(31), '||\n*                 '/* '||ZXONECHAR_ADDR||' XONECHAR_ADDR */';\n*/*PL.L08 ADDR XDELIMITER PTR(31) INPUT ADDR-------------------------*/\n*        ZPRMLINE=ZPRMLINE||' 2 #Z'||ZNDX||\n*                 '_XDELIMITER_ADDR PTR(31), '||\n*                 '/* '||ZXDELIMITER_ADDR||' XDELIMITER_ADDR */';\n*/*PL.L11 CONSTANT TO ENSURE THAT LIST FORM IS LONG ENOUGH ----------*/\n*        ZPRMNUM=ZPRMNUM+1;\n*        ZPRM(ZPRMNUM)=ZPRMLINE||' 2 * CHAR(0);';\n*        IF XPLISTVER\u00ac=0\n*           & XMF\u00ac='S'\n*          THEN\n*            DO;\n*              ZPRMNUM=ZPRMNUM+1;\n*              ZPRM(ZPRMNUM)=\n*               'DCL #Z'||ZNDX||'_LENCHECK FIXED(32) CONSTANT('||\n*               'LENGTH('||XMFCTRL||')-LENGTH(#Z'||ZNDX||'));'||\n*               '/* CONSTANT TO ENSURE THAT THE LIST FORM'||\n*               ' IS LONG ENOUGH */';\n*            END;\n*/*PL.L12 PARAMETER LIST SIZE----------------------------------------*/\n*        ZPLLEN=28;\n*        IF ZPRMMAX<ZPLLEN\n*           & XMF\u00ac='E'\n*           & XMF\u00ac='M'\n*          THEN\n*            ZPRMMAX=ZPLLEN;\n*/*PL.L13 -----------------------------------------------------------*/\n*      END;\n*/*PI.L01 XMF\u00ac='L' & XMFSCK='COMPLETE' ------------------------------*/\n*  IF XMF\u00ac='L'\n*    THEN\n*      DO;\n*        ANS('RFY GPR15F UNRSTD;') NORESCAN COL(MACLMAR);\n*/*PI.L03 CLEAR PARAMETER LIST --------------------------------------*/\n*  IF XMFSCK='COMPLETE'\n*    THEN\n*            ANS('#Z'||ZNDX||'=''''B;'||\n*                '/* CLEAR PARAMETER AREA */')\n*                NORESCAN COL(MACLMAR);\n*/*PI.L15 ADDR(XPATTERNSTR) CHAR(*)----------------------------------*/\n*        IF ZXPATTERNSTR\u00ac=''\n*          THEN\n*            ANS('#Z'||ZNDX||'_XPATTERNSTR_ADDR='||\n*                'ADDR('||XPATTERNSTR||');'||\n*                '/* ADDR XPATTERNSTR CHAR(*) */')\n*                NORESCAN COL(MACLMAR);\n*/*PI.L17 XPATTERNSTRLEN FIXED(31)-----------------------------------*/\n*        IF ZXPATTERNSTRLEN='INPUT' |\n*           ZXPATTERNSTRLEN='INOUT'\n*          THEN\n*            ANS('#Z'||ZNDX||'_XPATTERNSTRLEN='||\n*                XPATTERNSTRLEN||';'||\n*                '/* XPATTERNSTRLEN FIXED(31) */')\n*                NORESCAN COL(MACLMAR);\n*/*PI.L15 ADDR(XSTRING) CHAR(*)--------------------------------------*/\n*        IF ZXSTRING\u00ac=''\n*          THEN\n*            ANS('#Z'||ZNDX||'_XSTRING_ADDR='||\n*                'ADDR('||XSTRING||');'||\n*                '/* ADDR XSTRING CHAR(*) */')\n*                NORESCAN COL(MACLMAR);\n*/*PI.L17 XSTRINGLEN FIXED(31)---------------------------------------*/\n*        IF ZXSTRINGLEN='INPUT' |\n*           ZXSTRINGLEN='INOUT'\n*          THEN\n*            ANS('#Z'||ZNDX||'_XSTRINGLEN='||\n*                XSTRINGLEN||';'||\n*                '/* XSTRINGLEN FIXED(31) */')\n*                NORESCAN COL(MACLMAR);\n*/*PI.L15 ADDR(XZEROORMORE) CHAR(1)----------------------------------*/\n*        IF ZXZEROORMORE\u00ac=''\n*          THEN\n*            ANS('#Z'||ZNDX||'_XZEROORMORE_ADDR='||\n*                'ADDR('||XZEROORMORE||');'||\n*                '/* ADDR XZEROORMORE CHAR(1) */')\n*                NORESCAN COL(MACLMAR);\n*/*PI.L15 ADDR(XONECHAR) CHAR(1)-------------------------------------*/\n*        IF ZXONECHAR\u00ac=''\n*          THEN\n*            ANS('#Z'||ZNDX||'_XONECHAR_ADDR='||\n*                'ADDR('||XONECHAR||');'||\n*                '/* ADDR XONECHAR CHAR(1) */')\n*                NORESCAN COL(MACLMAR);\n*/*PI.L14 CHECK FOR * AS THE CHAR(1) ARGUMENT------------------------*/\n*        IF TRANSLATE(XDELIMITER)\n*                    = 'LENGTHS_WERE_SET'\n*           & XMFSCK='COMPLETE'\n*          THEN\n*            ZXDELIMITER='';                 /* RESET INPUT/INOUT */\n*/*PI.L15 ADDR(XDELIMITER) CHAR(1)-----------------------------------*/\n*        IF ZXDELIMITER\u00ac=''\n*          THEN\n*            DO;\n*            IF (XDELIMITER='LENGTHS_WERE_SET' & XMFSCK\u00ac='COMPLETE')\n*              THEN\n*                ANS('#Z'||ZNDX||'_XDELIMITER_ADDR=0;'||\n*                    '/* ADDR XDELIMITER CHAR(1) */')\n*                    NORESCAN COL(MACLMAR);\n*            IF XDELIMITER\u00ac='LENGTHS_WERE_SET'\n*              THEN\n*                ANS('#Z'||ZNDX||'_XDELIMITER_ADDR='||\n*                    'ADDR('||XDELIMITER||');'||\n*                    '/* ADDR XDELIMITER CHAR(1) */')\n*                    NORESCAN COL(MACLMAR);\n*            END;\n*/*PI.L29 NOT MF=M MACRO FORM----------------------------------------*/\n*        IF XMF\u00ac='M'\n*          THEN\n*            DO;\n*/*PI.L31 INVOKE FUNCTION--------------------------------------------*/\n*              ANS('RFY GPR01P RSTD;') NORESCAN COL(MACLMAR);\n*              ANS('GPR01P=ADDR(#Z'||ZNDX||');'||\n*                  '/* PARAMETER LIST */')\n*                  NORESCAN COL(MACLMAR);\n*              IF SYSASCE\u00ac='P'\n*                THEN\n*                  ANS('SAR(GPR01P,ALET(#Z'||ZNDX||'));'||\n*                      '/* PARAMETER LIST AR */')\n*                      NORESCAN COL(MACLMAR);\n*/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n* IF WorkArea = '' |                                   /*        @L1A*/\n*    Translate(Xworkarea) = 'NO_WORKAREA' THEN         /*        @L1A*/\n*    ANS('CALL ((((XM@CVT+140)->I031P+232) -> I031P+28) -> I031P)'\n*            || '-> I31ANY;')\n*         SKIP COL(5);                                 /*        @L1A*/\n* ELSE DO;             /* Workarea, use ASAWILDB                 @L1A*/\n*    BANS SKIP COL(5);                                 /*        @L1A*/\n*      'RFY GPR00P RSTD;'\n*      'GPR00P = ADDR(' || XWorkArea || ');'\n*      'CALL ((((XM@CVT+140)->I031P+232) -> I031P+32) -> I031P)' ||\n*            '-> I31ANY;'\n*      'RFY GPR00P UNRSTD;'\n*    EANS;                                             /*        @L1A*/\n* END;                                                 /*        @L1A*/\n*/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/\n*              ANS('RFY GPR01P UNRSTD;') NORESCAN COL(MACLMAR);\n*              IF NUMBER(RETCODE)>0\n*                THEN\n*                  ANS('RFY GPR15F RSTD;') NORESCAN COL(MACLMAR);\n*/*PO.L08 XRETCODE FIXED(31) RETURN CODE-----------------------------*/\n*              IF NUMBER(RETCODE)>0\n*                THEN\n*                    ANS(XRETCODE||\n*                     '=GPR15F; /* SET RETURN CODE */')\n*                      NORESCAN COL(MACLMAR);\n*/*PO.L10 REMOVE REGISTER RESTRICTIONS-------------------------------*/\n*              IF NUMBER(RETCODE)>0\n*                THEN\n*              ANS('RFY GPR15F UNRSTD;') NORESCAN COL(MACLMAR);\n*/*PO.L11 END OF FUNCTION INVOCATION---------------------------------*/\n*            END;\n*/*PO.L12 END OF PARAMETER LIST PROCESSING---------------------------*/\n*      END;\n*/*PO.L13 ASAXWC USAGE INDICATOR-------------------------------------*/\n*  ZASAXWC='YES';                            /* SET ASAXWC USED */\n*/*PO.L15 END OF EXECUTABLE ASAXWC-PLISTVER MACRO--------------------*/\n*  IF XMF\u00ac='L'\n*    THEN\n*      ANS('END; /* ASAXWC-PLISTVER */')\n*          NORESCAN COL(MACLMAR);\n*/*PO.L16 RESTORE PRINT CONTROLS-------------------------------------*/\n*  ANS(MACCONC||'LIST POP NOECHO;') NORESCAN COL(MACLMAR);\n*/*PO.L17 END OF ASAXWC MACRO----------------------------------------*/\n*  ANS(MACCONC||'SPACE;') NORESCAN COL(MACLMAR);\n*  ANS(' ') NORESCAN COL(MACLMAR);\n*/*******************************************************************/\n*/*  PO.L18 END OF CODE TO BE BYPASSED WHEN ZMACRET \u00ac= 0            */\n*/*******************************************************************/\n*      END;\n*/*******************************************************************/\n*/*  MVS ONLY     -CHECK IF AMG PARM LISTS ARE PRESENT              */\n*/*               -ROUND MAX AMG PARM LIST TO DOUBLEWORD MULTIPLES  */\n*/*******************************************************************/\n*  IF ZPRMNUM>0                   /* NUMBER OF AMG PARM LIST ENTRIES*/\n*    THEN\n*      DO;\n*        ZPRMMAX=((ZPRMMAX+7)/8)*8; /* ROUND PARM LIST SIZE UP TO\n*                                      DOUBLEWORD MULTIPLES        */\n*/*******************************************************************/\n*/*  MVS -GENERATE PARM LIST DCL TO OVERLAY ?EPILOG'S ILIST AREA    */\n*/*******************************************************************/\n*        IF XMF \u00ac= 'M' & XMF \u00ac= 'E'\n*          THEN\n*            DO;\n*              IF INDEX(EHALIST,',AMG,')=0 /* HAS DECLARE BEEN DONE?*/\n*                THEN\n*                  DO;\n*                    ANS('?EPILOG\n*                        STRING(''DCL #ZPLIST DEF(ILIST);'');');\n*                    EHALIST=EHALIST||',AMG,';\n*                  END;\n*            END;\n*/*******************************************************************/\n*/*  MVS  -EXTRACT PARM LISTS FROM AMG GLOBAL MACRO ARRAYS          */\n*/*******************************************************************/\n*        IF XMF \u00ac= 'M' & XMF \u00ac= 'E'\n*          THEN\n*            DO;\n*              IF ZPRMMAX>EHAMAXLEN\n*                THEN\n*                  EHAMAXLEN=ZPRMMAX; /* SET MAX PARM LIST SIZE     */\n*            END;\n*        DO ZI=1 TO ZPRMNUM; /* EXTRACT AMG PARM LISTS               */\n*          ANS('?EPILOG STRING('''||ZPRM(ZI)||''');')\n*              COL(MACLMAR);\n*        END;\n*      END;\n*/*-----------------------------------------------------------------*/\n*/*  MVS  -ENSURE THAT GPRS NEEDED BY AMG MACROS WILL BE PROVIDED   */\n*/*        BY ?EPILOG                                               */\n*/*-----------------------------------------------------------------*/\n*        IF INDEX(EHAREGS,'01P')=0\n*          THEN\n*            EHAREGS=EHAREGS||'01P'; /* GPR01P                      */\n*        IF INDEX(EHAREGS,'15F')=0\n*          THEN\n*            EHAREGS=EHAREGS||'15F'; /* GPR15F                      */\n*  RETURN CODE(ZMACRET);\n*%END ASAXWC;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASAXWC$": {"ttr": 16390, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00.\\x00.\\x00\\x00\\xc1\\xe2\\xc1\\xe7\\xe6\\xc3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "ASAXWC"}, "text": "//-YOUR-USERID-A JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//A          EXEC     PGM=ASMA90,REGION=4M,\n//             PARM='OBJECT'\n//SYSLIB       DD       DISP=SHR,DSN=SYS1.MACLIB\n//             DD       DISP=SHR,DSN=-YOUR-SYSLIB-\nBASE     RENTER\n         L     R3,BIGNUM\n         LA    R4,FW\nLOOP     EQU   *\n         ASAXWC PATTERNSTR=PAT1,PATTERNSTRLEN=PAT1LEN,                 X\n                STRING=STR1,STRINGLEN=STR1LEN,                         X\n                ZEROORMORE=*,ONECHAR=?\n         LTR   R15,R15\n         BZ    OK1\n         DC    H'0'\nOK1      ASAXWC PATTERNSTR=PAT1,PATTERNSTRLEN=PAT1LEN,                 X\n                STRING=STR2,STRINGLEN=STR2LEN,                         X\n                ZEROORMORE=*,ONECHAR=?\n         LTR   R15,R15\n         BZ    NG1\n         REXIT\nNG1      EX    0,*\nFW       DC    F'0'\nPAT1LEN  DC    F'5'\nSTR1LEN  DC    F'12'\nSTR2LEN  DC    F'12'\nPAT1     DC    C'AD*P?'\nSTR1     DC    C'ADLARKXXXXP.'\nSTR2     DC    C'ADCARLXXXXXP'\n         END   BASE\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//***\n//GO         EXEC     PGM=LOADER,\n//             REGION=4M,COND=(5,LT)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//SYSLOUT      DD       SYSOUT=*\n//SYSPRINT     DD       SYSOUT=*\n//SYSUDUMP     DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BASEASM": {"ttr": 16392, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x01?\\x01?\\x00\\x00\\xc2\\xc1\\xe2\\xc5\\xc1\\xe2\\xd4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 319, "newlines": 319, "modlines": 0, "user": "BASEASM"}, "text": "//-YOUR-USERID-B JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  BASIC SEQUENTIAL READ AND WRITE ASSEMBLER PROGRAM W/ COUNTS\n//***  BUT IS NOW REENTRANT AND AMODE=31 WITH RMODE=ANY AND WILL\n//***  COPY THE DCB ATTRIBUTES OF THE INPUT FILE FOR FIXED OR VARIABLE\n//***\n//ASM        EXEC     PGM=ASMA90,REGION=4M,\n//             PARM='RENT'\n//SYSLIB       DD       DISP=SHR,DSN=SYS1.MACLIB\n//             DD       DISP=SHR,DSN=-YOUR-SYSLIB-\n\nBASE     AMODE 31\nBASE     RMODE ANY\n\nR0       EQU    0                  SHORT TERM WORK REGISTER\nR1       EQU    1                  SHORT TERM WORK REGISTER\nR2       EQU    2                  .\nR3       EQU    3                  # RECORDS READ\nR4       EQU    4                  # RECORDS WRITTEN\nR5       EQU    5                  DCB POINTER FOR INPUT FILE\nR6       EQU    6                  DCB POINTER FOR OUTPUT FILE\nR7       EQU    7                  DCB POINTER FOR SYSPRINT\nR8       EQU    8                  INPUT AREA (FROM R1 ON GET)\nR9       EQU    9                  OUTPUT AREA POINTER\nR10      EQU   10                  SHORT TERM WORK REGISTER\nR11      EQU   11                  BASE REGISTER\nR12      EQU   12                  SUBROUTINE RETURN REGISTER\nR13      EQU   13                  SAVEAREA AND WORKAREA POINTER\nR14      EQU   14                  SHORT TERM WORK REGISTER\nR15      EQU   15                  SHORT TERM WORK REGISTER\n\nBASE     RENTER SALEN=DYNAMLEN+1024,REGS=NO\n         USING WORKAREA,R13\n         USING IREC,R8\n         USING OREC,R9\n\n***********************************************************************\n*    MAIN LINE\n***********************************************************************\n\n         BAL   R12,GETSTORE        ALLOCATE MEMORY FOR WORK AREAS ETC\n         BAL   R12,OPENRTN         OPEN FILES\n\nLOOP     EQU   *\n         BAL   R12,GETREC          READ A RECORD\n         BAL   R12,PROCESS         BUILD OUTPUT RECORD\n         BAL   R12,PUTREC          WRITE A RECORD\n         B     LOOP                PROCESS NEXT RECORD\n\nIEOF     EQU   *\n         BAL   R12,CLOSERTN        PRINT COUNTS AND CLOSE ALL FILES\n         L     R15,FINALRC         SET LAST RETURN CODE\n         REXIT\n\n***********************************************************************\n*    USE STORAGE OBTAINED WITH THE SAVEAREA TO INITIALIZE THE\n*    WORK AREAS AND I/O MACROS AND GET OUTPUT AREA\n***********************************************************************\n\nGETSTORE EQU   *\n\n         SR    R3,R3               INITIALIZE # READ\n         SR    R4,R4               INITIALIZE # WRITTEN\n         XC    FINALRC,FINALRC     INITIALIZE FINAL RETURN CODE TO 0\n\n         LA    R0,WKINGSTG         INITIALIZE I/O MACS & MSG FIELDS\n         LA    R1,DYNAMLEN\n         LA    R14,DYNAM\n         LA    R15,DYNAMLEN\n         MVCL  R0,R14\n\n         LA    R5,IDCB             SET UP DCBE'S IN WORKING STORAGE\n         LA    R14,IDCBE\n         ST    R14,0(R5)\n         LA    R6,ODCB\n         LA    R14,ODCBE\n         ST    R14,0(R6)\n         LA    R7,SDCB\n         LA    R14,SDCBE\n         ST    R14,0(R7)\n\n         L     R0,MAXRECSZ         GET MAX AREA FOR O/P\n         STORAGE  OBTAIN,LENGTH=(0),LOC=BELOW\n         LR    R9,R1               SET USING ADDRESS OF OUTPUT AREA\n\n         BR    R12\n\n***********************************************************************\n*    OPEN THE DCBS FROM THE GETMAINED AREAS\n***********************************************************************\n\nOPENRTN  EQU   *\n         LA    R1,OPEN\n         OPEN  ((R5),,(R7),OUTPUT),MF=(E,(R1)),MODE=31\n\n         USING IHADCB,R5           MAKE O/P DCB LINE I/P'S\n         IC    R10,DCBRECFM\n         LH    R14,DCBLRECL\n         LH    R15,DCBBLKSI\n         DROP  R5\n         USING IHADCB,R6\n         STC   R10,DCBRECFM\n         STC   R10,RECFM\n         STH   R14,DCBLRECL\n         STH   R14,RECSIZE\n         STH   R15,DCBBLKSI\n         DROP  R6\n         LA    R1,OPENO\n         OPEN  ((R6),OUTPUT),MF=(E,(R1)),MODE=31\n\n         BR    R12\n\n***********************************************************************\n*    READ A RECORD FROM THE INPUT FILE\n***********************************************************************\n\nGETREC   EQU   *\n         GET   (R5)\n         LR    R8,R1\n         LA    R3,1(R3)            INCREMENT INPUT COUNTER\n\n         BR    R12\n\n***********************************************************************\n*    WRITE THE OUTPUT FILE\n***********************************************************************\n\nPROCESS  EQU   *\n         LA    R4,1(R4)            INCREMENT OUTPUT COUNTER\n\n         LR    R0,R9\n***                                SIMPLY COPY THE I/P TO THE O/P\n         TM    RECFM,X'80'\n         BNO   VARRECFM\n         LH    R1,RECSIZE\n         LR    R14,R8\n         LH    R15,RECSIZE\n         ICM   R15,B'1000',BLANK\n         B     COPYREC\n\nVARRECFM EQU   *\n         LH    R1,0(R8)\n         LR    R14,R8\n         LH    R15,0(R8)\n         ICM   R15,B'1000',BLANK\n\nCOPYREC  EQU   *\n         MVCL  R0,R14\n\n         BR    R12\n\n***********************************************************************\n*    WRITE OUTPUT FILE\n***********************************************************************\n\nPUTREC   EQU   *\n         PUT   (R6),(R9)\n\n         BR    R12\n\n***********************************************************************\n*    CLOSE THE DCBS FROM THE GETMAINED AREAS\n***********************************************************************\n\nCLOSERTN EQU   *\n         TIME                      , PRINT STATISTICS\n         XC    DW,DW\n         ST    R0,DW+4\n         ED    TIME#,DW+4\n         ST    R1,DW+4\n         AP    DW,CENTURY\n         ED    DATE#,DW+4\n         PUT   (R7),STATMSG\n         CVD   R3,DW\n         ED    READ#,DW+4\n         PUT   (R7),READMSG\n         CVD   R4,DW\n         ED    WRITTEN#,DW+4\n         PUT   (R7),WRITEMSG\n\n         LA    R1,CLOSE            CLOSE FILES\n         CLOSE ((R5),,(R6),,(R7)),MF=(E,(R1)),MODE=31\n\n         BR    R12\n\n***********************************************************************\n*    LIST FORM OF I/O MACRO INSTRUCTIONS AND OTHER STATIC DATA\n***********************************************************************\n\nDYNAM    DS    0D\n\nXOPEN    OPEN  (XIDCB,(INPUT),XSDCB,(OUTPUT)),                         X\n               MF=L,MODE=31\n\nXOPENO   OPEN  (XODCB,(OUTPUT)),MF=L,MODE=31\n\nXCLOSE   CLOSE (XIDCB,,XODCB,,XSDCB),MF=L,MODE=31\n\nXIDCB    DCB   DSORG=PS,MACRF=GL,                                      X\n               BUFNO=32,DDNAME=I,DCBE=XIDCBE\nXIDCBE   DCBE  RMODE31=BUFF,EODAD=IEOF\n\nXODCB    DCB   DSORG=PS,MACRF=PM,DDNAME=O,                             X\n               BUFNO=32,DCBE=XODCBE\nXODCBE   DCBE  RMODE31=BUFF\n\nXSDCB    DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,                      X\n               RECFM=FA,LRECL=121,BLKSIZE=121,DCBE=XSDCBE\nXSDCBE   DCBE  RMODE31=BUFF\n\nMESSAGES EQU   *\n         DC    CL32'-***  BASE STATISTICS --- DATE: '\n         DC    XL09'402020202061202020'\n         DC    CL10'   TIME:  '\n         DC    XL12'4020207A20207A20204B2020'\n         DC    CL58' '\n         DC    CL31'-***  NUMBER RECORDS READ     :'\n         DC    XL10'40206B2020206B202021'\n         DC    CL80' '\n         DC    CL31'-***  NUMBER RECORDS WRITTEN  :'\n         DC    XL10'40206B2020206B202021'\n         DC    CL80' '\nXRECSIZE DS    H\nXRECFM   DS    C\n\nDYNAMLEN EQU   (*-DYNAM)\n\nBLANK    DC    CL1' '\nCENTURY  DC    PL5'1900000'\nMAXRECSZ DC    F'32760'\n\n***********************************************************************\n*    DSECTS USED BY PROGRAM\n***********************************************************************\n\nWORKAREA DSECT\n\nSAVEAREA DS    9D                  SAVE AREA\nDW       DS    D                   DOUBLEWORD WORK AREA\nFINALRC  DS    F                   FINAL RETURN CODE\nFILLER   DS    F\n\nWKINGSTG DS    0D\n\nOPEN     OPEN  (IDCB,(INPUT),SDCB,(OUTPUT)),MF=L,MODE=31\n\nOPENO    OPEN  (ODCB,(OUTPUT)),MF=L,MODE=31\n\nCLOSE    CLOSE (IDCB,,ODCB,,SDCB),MF=L,MODE=31\n\nIDCB     DCB   DSORG=PS,MACRF=GL,                                      X\n               BUFNO=32,DDNAME=I,DCBE=IDCBE\nIDCBE    DCBE  RMODE31=BUFF,EODAD=IEOF\n\nODCB     DCB   DSORG=PS,MACRF=PM,DDNAME=O,                             X\n               BUFNO=32,DCBE=ODCBE\nODCBE    DCBE  RMODE31=BUFF\n\nSDCB     DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,                      X\n               RECFM=FA,LRECL=121,BLKSIZE=121,DCBE=SDCBE\nSDCBE    DCBE  RMODE31=BUFF\n\nSTATMSG  DS    0CL121\n         DS    CL32\nDATE#    DS    XL09\n         DS    CL10\nTIME#    DS    XL12\n         DS    CL58\nREADMSG  DS    0CL121\n         DS    CL31\nREAD#    DS    XL10\n         DS    CL80\nWRITEMSG DS    0CL121\n         DS    CL31\nWRITTEN# DS    XL10\n         DS    CL80\nRECSIZE  DS    H\nRECFM    DS    C\nWKARLEN  EQU   (*-WORKAREA)\n\n\nIREC     DSECT\n         DS    CL80\nIRECLEN  EQU   (*-IREC)\n\nOREC     DSECT\n         DS    CL80\nORECLEN  EQU   (*-OREC)\n\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n\n         DCBD  DSORG=(PS,PO),DEVD=DA\n\n         END   BASE\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//***\n//CLEANUP    EXEC     PGM=IEFBR14\n//DEL01        DD       DSN=...,\n//             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n//***\n//GO         EXEC     PGM=LOADER,\n//             PARM='RENT,AMODE(31),RMODE(ANY)',\n//             REGION=4M,COND=(5,LT)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//SYSLOUT      DD       SYSOUT=*\n//I            DD       DISP=SHR,DSN=...\n//O            DD       DISP=(,CATLG),DSN=...,\n//             UNIT=SYSDA,SPACE=(CYL,(010,010),RLSE)\n//SYSPRINT     DD       SYSOUT=*\n//SYSUDUMP     DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BASECOB": {"ttr": 16641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xcd\\x00\\xcd\\x00\\x00\\xc2\\xc1\\xe2\\xc5\\xc3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 205, "newlines": 205, "modlines": 0, "user": "BASECOB"}, "text": "//-YOUR-USERID-B JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  BASIC PROGRAM TO READ AND WRITE A SEQUENTIAL FILE WITH\n//***  THE OPTION OF DOING PROCESSING INBETWEEN READS AND WRITES\n//***\n//C          EXEC     PGM=IGYCRCTL,REGION=4M,\n//             PARM=('LIB,MAP,NUMPROC(PFD),OFF,OPTIMIZE',\n//            'APOST,NOSEQ,TRUNC(OPT),XREF')\n//SYSIN        DD       *\n\n      **************************\n       IDENTIFICATION DIVISION.\n      **************************\n       PROGRAM-ID.  BASE INITIAL.\n      *\n      * GENERAL PURPOSE PROGRAM TO READ AND WRITE BACK SEQUENTIAL\n      * FILE WITH OPTION TO CHANGE DATA BETWEEN INPUT AND OUTPUT.\n      *\n\n\n      ***********************\n       ENVIRONMENT DIVISION.\n      ***********************\n\n       CONFIGURATION SECTION.\n      *----------------------*\n\n       SPECIAL-NAMES.\n\n           CLASS ALPHA-NUM-CHARS\n               IS 'A' THRU 'Z', '0' THRU '9'.\n\n       INPUT-OUTPUT SECTION.\n      *---------------------*\n\n       FILE-CONTROL.\n\n           SELECT I\n               ASSIGN TO I.\n\n           SELECT O\n               ASSIGN TO O.\n\n\n      ****************\n       DATA DIVISION.\n      ****************\n\n       FILE SECTION.\n      *-------------*\n\n       FD  I\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  INPUT-REC    PIC X(00080).\n\n       FD  O\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  OUTPUT-REC   PIC X(00080).\n\n       WORKING-STORAGE SECTION.\n      *------------------------*\n\n       01  WS-INPUT-REC               PIC X(00080).\n       01  WS-SAVE-REC                PIC X(00080).\n       01  WORK-AREAS.\n           05  NUMBER-RECORDS-ADDED   PIC 9(9)   VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-DELETED PIC 9(9)   VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-DUPS    PIC 9(9)   VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-READ    PIC 9(9)   VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-UPDATED PIC 9(9)   VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-WRITTEN PIC 9(9)   VALUE 0 COMP-3.\n           05  FINAL-RETURN-CODE      PIC 9(4)   VALUE 0 COMP.\n           05  END-OF-FILE-STATUS     PIC X      VALUE 'N'.\n               88  AT-END-OF-FILE                VALUE 'Y'.\n           05  REWRITE-REC            PIC X      VALUE 'Y'.\n       01  WEEK-DAY-NUMBER            PIC 9.\n       01  YYMMDD                     PIC 9(6).\n       01  HHMM                       PIC 9(8).\n       01  DAYS-OF-WEEK.\n           05  MONDAY    PIC X(9)       VALUE 'MONDAY'.\n           05  TUESDAY   PIC X(9)       VALUE 'TUESDAY'.\n           05  WEDNESDAY PIC X(9)       VALUE 'WEDNESDAY'.\n           05  THURSDAY  PIC X(9)       VALUE 'THURSDAY'.\n           05  FRIDAY    PIC X(9)       VALUE 'FRIDAY'.\n           05  SATURDAY  PIC X(9)       VALUE 'SATURDAY'.\n           05  SUNDAY    PIC X(9)       VALUE 'SUNDAY'.\n       01  WEEK-DAYS                    REDEFINES DAYS-OF-WEEK.\n           05 WEEK-DAY   OCCURS 7 TIMES PIC X(9).\n\n       LINKAGE SECTION.\n      *----------------*\n       01  PARM-DATA.\n           05  PARM-LENGTH              PIC 9(4)              COMP.\n           05  PARM-PASSED              PIC X(100).\n\n\n      *************************************\n       PROCEDURE DIVISION USING PARM-DATA.\n      *************************************\n\n       0000-MAIN.\n      ************\n\n           PERFORM 0100-INITIALIZATION\n\n           PERFORM 0200-READ-WRITE-LOOP\n               UNTIL AT-END-OF-FILE\n\n           PERFORM 0900-TERMINATION\n\n           MOVE FINAL-RETURN-CODE TO RETURN-CODE\n\n           GOBACK\n           .\n\n       0100-INITIALIZATION.\n      **********************\n           OPEN  INPUT  I\n                 OUTPUT O\n           READ  I INTO WS-INPUT-REC\n               AT END SET AT-END-OF-FILE TO TRUE\n               NOT AT END ADD 1 TO NUMBER-RECORDS-READ\n           END-READ\n           .\n\n       0200-READ-WRITE-LOOP.\n      ***********************\n           MOVE 'Y' TO REWRITE-REC\n           PERFORM 0200-PROCESS\n           IF REWRITE-REC = 'Y'\n               WRITE OUTPUT-REC FROM WS-INPUT-REC\n               ADD 1 TO NUMBER-RECORDS-WRITTEN\n           ELSE\n               ADD 1 TO NUMBER-RECORDS-DELETED\n           END-IF\n           READ  I INTO WS-INPUT-REC\n               AT END SET AT-END-OF-FILE TO TRUE\n               NOT AT END ADD 1 TO NUMBER-RECORDS-READ\n           END-READ\n           .\n\n       0200-PROCESS.\n      ***************\n           CONTINUE\n           .\n\n       0900-TERMINATION.\n      *******************\n           CLOSE I\n                 O\n           ACCEPT WEEK-DAY-NUMBER FROM DAY-OF-WEEK\n           ACCEPT YYMMDD FROM DATE\n           ACCEPT HHMM FROM TIME\n           DISPLAY 'PROGRAM STATISTICS:  '\n               '                         '\n               WEEK-DAY(WEEK-DAY-NUMBER) ' '\n               YYMMDD(3:2) '/' YYMMDD(5:2) '/' YYMMDD(1:2)\n               ' - ' HHMM(1:2) ':' HHMM(3:2)\n           DISPLAY '    PARM LENGTH               = '\n               PARM-LENGTH\n           IF PARM-LENGTH NOT = 0\n               DISPLAY '    PARM PASSED TO PROGRAM    = '\n                   PARM-PASSED(1:PARM-LENGTH)\n           END-IF\n           DISPLAY ' '\n           DISPLAY '    NUMBER OF RECORDS READ    = '\n               NUMBER-RECORDS-READ\n           DISPLAY '    NUMBER OF RECORDS WRITTEN = '\n               NUMBER-RECORDS-WRITTEN\n           DISPLAY '    NUMBER OF RECORDS UPDATED = '\n               NUMBER-RECORDS-UPDATED\n           DISPLAY '    NUMBER OF RECORDS DELETED = '\n               NUMBER-RECORDS-DELETED\n           DISPLAY '    NUMBER OF RECORDS ADDED   = '\n               NUMBER-RECORDS-ADDED\n           DISPLAY '    NUMBER OF DUPLICATE RECS  = '\n               NUMBER-RECORDS-DUPS\n           .\n\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=SYSDA,SPACE=(CYL,(3,3)),\n//             DCB=(BLKSIZE=0,LRECL=80,RECFM=FB)\n//SYSUT1       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT2       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT3       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT4       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT5       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT6       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT7       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//***\n//GO         EXEC     PGM=LOADER,\n//             PARM='MAP,PRINT//CBLQDA(OFF)',\n//             REGION=4M,COND=(5,LT)\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//SYSLOUT      DD       SYSOUT=*\n//SYSPRINT     DD       SYSOUT=*\n//I            DD       DISP=SHR,DSN=-YOUR-SYSLIB-(BASECOB)\n//O            DD       SYSOUT=*\n//SYSOUT       DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BASEEZ": {"ttr": 16645, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00&\\x00&\\x00\\x00\\xc2\\xc1\\xe2\\xc5\\xc5\\xe9@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "BASEEZ"}, "text": "//-YOUR-USERID-B JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//*** VERY BASIC E/Z PROGRAM JUST EXERCISING ONE REPORT\n//***\n//EZ         EXEC     PGM=EZTPA00,REGION=8M\n//EZTVFM       DD       UNIT=SYSDA,SPACE=(CYL,(20,20))\n//SYSOUT       DD       SYSOUT=*\n//SYSPRINT     DD       SYSOUT=*\n//SORTWK01     DD       UNIT=SYSDA,SPACE=(CYL,050,,CONTIG)\n//SORTWK02     DD       UNIT=SYSDA,SPACE=(CYL,050,,CONTIG)\n//SORTWK03     DD       UNIT=SYSDA,SPACE=(CYL,050,,CONTIG)\n//SORTWK04     DD       UNIT=SYSDA,SPACE=(CYL,050,,CONTIG)\n//SORTWK05     DD       UNIT=SYSDA,SPACE=(CYL,050,,CONTIG)\n//SORTWK06     DD       UNIT=SYSDA,SPACE=(CYL,050,,CONTIG)\n//FILENAME     DD       DISP=SHR,DSN=-YOUR-SYSLIB-(JOB)\n//SYSIN        DD       *\nFILE FILENAME F(00080)\n     TYPE        1  10  A\n     NAME       11  60  A\n*\nFILE REPT01   PRINTER\n*\n*\nJOB  INPUT  FILENAME\n     PRINT  GEN-RPT\n*\nREPORT  GEN-RPT                              +\n        LINESIZE 120                         +\n        PAGESIZE 050                         +\n        SKIP       0                         +\n        SPACE      4                         +\n        TITLESKIP  2                         +\n        PRINTER    REPT01                    +\n        NOADJUST\n     LINE  01  NAME    SYSDATE\n//REPT01       DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BASEPLI": {"ttr": 16647, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00z\\x00z\\x00\\x00\\xc2\\xc1\\xe2\\xc5\\xd7\\xd3\\xc9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 122, "newlines": 122, "modlines": 0, "user": "BASEPLI"}, "text": "//-YOUR-USERID-B JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  BASIC PROGRAM TO READ AND WRITE A SEQUENTIAL FILE -\n//***  ADDITIONAL PROCESSING MAY BE INSERTED AS NEEDED\n//***\n//C          EXEC     PGM=IEL0AA,REGION=4M,\n//             PARM=('AG,A,NCT,ESD,F(I),NOFLOW,NIS,NOLIST,M,NMI,NEST',\n//             'MAP,OF,OPT(TIME),OP,SZ(MAX),S,STMT,STG,X(F)')\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-PLI-LIB-\n\n BASE:  PROC(PARM) OPTIONS(MAIN) REORDER;\n\n        DCL  PARM      CHAR(00100) VARYING;\n        DCL  REC       CHAR(05120) STATIC VARYING;\n        DCL  OLDREC    CHAR(05120) STATIC VARYING;\n        DCL  I_EOF_IND CHAR(01) STATIC INIT('N');\n        DCL  REWRITE_REC  CHAR(01) STATIC INIT('N');\n\n        DCL  ADDED#    FIXED BIN(31) STATIC INIT(0);\n        DCL  DELETED#  FIXED BIN(31) STATIC INIT(0);\n        DCL  DUPS#     FIXED BIN(31) STATIC INIT(0);\n        DCL  READ#     FIXED BIN(31) STATIC INIT(0);\n        DCL  UPDATED#  FIXED BIN(31) STATIC INIT(0);\n        DCL  WRITTEN#  FIXED BIN(31) STATIC INIT(0);\n        DCL  DATE      BUILTIN;\n        DCL  TIME      BUILTIN;\n\n\n        ON ENDFILE(I) I_EOF_IND = 'Y';\n\n        CALL INITIALIZATION;\n\n        DO WHILE ( I_EOF_IND  = 'N' );\n           CALL READ_WRITE_LOOP;\n        END;\n\n        CALL TERMINATION;\n\n\n PROCESS: PROC;\n        /***   ...   ***/\n        END PROCESS;\n\n INITIALIZATION: PROC;\n        READ FILE(I) INTO(REC);\n        END INITIALIZATION;\n\n READ_WRITE_LOOP: PROC;\n        REWRITE_REC = 'Y';\n        READ# = READ# + 1;\n        CALL PROCESS;\n        IF REWRITE_REC = 'Y'\n           THEN DO;\n              WRITE FILE(O) FROM(REC);\n              WRITTEN# = WRITTEN# + 1;\n           END;\n           ELSE DO;\n              DELETED# = DELETED# + 1;\n           END;\n        READ FILE(I) INTO(REC);\n        END READ_WRITE_LOOP;\n\n TERMINATION: PROC;\n        PUT EDIT ( '**************************************' )\n                 ( SKIP(1), A );\n        PUT EDIT ( '***  ', DATE, ' STATISTICS ', TIME, '  ****' )\n                 ( SKIP(1), A, A, A, A, A );\n        PUT EDIT ( '**************************************' )\n                 ( SKIP(1), A );\n        PUT EDIT ( '***  NUMBER RECORDS READ:    ', READ#    )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        PUT EDIT ( '***  NUMBER RECORDS WRITTEN: ', WRITTEN# )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        PUT EDIT ( '***  NUMBER RECORDS UPDATED: ', UPDATED# )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        PUT EDIT ( '***  NUMBER RECORDS ADDED:   ', ADDED#   )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        PUT EDIT ( '***  NUMBER RECORDS DELETED: ', DELETED# )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        PUT EDIT ( '***  NUMBER RECORDS DUPS:    ', DUPS#    )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        IF LENGTH(PARM) > 0\n           THEN DO;\n              PUT EDIT ( '***  PARM LENGTH/PARM ARE:  ',\n                         LENGTH(PARM), '/', PARM )\n                       ( SKIP(2), A, P'ZZ9', A, A  );\n           END;\n        END TERMINATION;\n\n        END BASE;\n\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(CYL,(05,02))\n//***\n//L          EXEC     PGM=HEWLKED,COND=(5,LT),\n//             PARM='XREF,LIST,LET,DCBS,AMODE=31,RMODE=ANY', <******\n//             REGION=4M\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=&&TEMPPGM,DISP=(MOD,PASS),\n//             UNIT=SYSDA,SPACE=(CYL,(5,2,44)),\n//             DCB=(RECFM=U,BLKSIZE=06144)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE)\n//             DD       *\n  SETSSI   99080300\n  ENTRY    PLISTART\n  NAME     BASE(R)\n//***\n//G          EXEC     PGM=BASE,REGION=32M,COND=(5,LT),   <******\n//             PARM='HEAP(1M,1M,ANYWHERE)'               <******\n//STEPLIB      DD       DSN=&&TEMPPGM,DISP=(OLD,PASS)\n//I            DD       DISP=SHR,DSN=-YOUR-SYSLIB-(JOB)\n//O            DD       SYSOUT=*,\n//             DCB=(RECFM=F,LRECL=80,BLKSIZE=80)\n//SYSPRINT     DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BC": {"ttr": 16650, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x93\\x00\\x93\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 147, "newlines": 147, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- BLANK SPECIFIC COLUMN LOCATIONS  **/\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n             \"ISREDIT MACRO (TOLEFT,TORIGHT,LBL1,LBL2) NOPROCESS\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n\n   IF SUBSTR(TOLEFT,1,1) = '.' & SUBSTR(TORIGHT,1,1) = '.',\n         & LBL1 = '' & LBL2 = '' THEN DO\n      LBL1    = TOLEFT\n      LBL2    = TORIGHT\n      TOLEFT  = 73\n      TORIGHT = 80\n   END\n   IF TOLEFT = '' & TORIGHT = '' THEN DO\n      TOLEFT  = 73\n      TORIGHT = 80\n   END\n   ERRORMSG   = ''\n   MESG       = ''\n   IF \u00acDATATYPE(TOLEFT,'W')  |  TOLEFT = 0  THEN DO\n      MESG = \"'\"TOLEFT\"' VALUE OF TO-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(TORIGHT,'W') |  TORIGHT = 0 THEN DO\n      MESG = \"'\"TORIGHT\"' VALUE OF TO-RIGHT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF TOLEFT > TORIGHT THEN DO\n      MESG = \"TO-LEFT COLUMN IS GREATER THAN TO-RIGHT!\"\n      SIGNAL ERROR\n   END\n   IF TOLEFT > LRECL THEN DO\n      MESG = \"TO-LEFT COLUMN IS GREATER THAN RECORD SIZE (\"LRECL\")\"\n      SIGNAL ERROR\n   END\n   IF TORIGHT > LRECL THEN DO\n      MESG = \"TO-RIGHT COLUMN IS GREATER THAN RECORD SIZE (\"LRECL\")\"\n      SIGNAL ERROR\n   END\n   LEN = TORIGHT - TOLEFT + 1\n\n   ADDRESS ISREDIT\n   \"PROCESS RANGE C\"\n   IF RC = 0 THEN DO\n      \"(START) = LINENUM .ZFRANGE\"\n      \"(END)   = LINENUM .ZLRANGE\"\n   END\n   ELSE DO\n      IF LBL1 <> '' THEN DO\n         \"ISREDIT L &LBL1\"\n          IF RC <> 0 THEN DO\n             MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n             SIGNAL ERROR\n          END\n      END\n      IF LBL2 <> '' THEN DO\n         \"ISREDIT L &LBL2\"\n          IF RC <> 0 THEN DO\n             MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n             SIGNAL ERROR\n          END\n      END\n      \"ISREDIT (END) = LINENUM .ZLAST\"\n      IF LBL1 <> '' THEN \"ISREDIT (START) = LINENUM &LBL1\"\n         ELSE START = 1\n      IF LBL2 <> '' THEN \"ISREDIT (END) = LINENUM &LBL2\"\n         ELSE LBL2 = LBL1\n      IF START > END THEN DO\n         FLIP  = START\n         START = END\n         END   = FLIP\n      END\n   END\n\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR   \"\n   ADDRESS ISPEXEC\n   IF SAVLINE = 1 THEN DO\n       'VGET (ZSCREENC,ZSCREENI) SHARED'\n       II = INDEX(ZSCREENI,'* Top of Data *')\n       IF ( ZSCREENC % 80 )  <=  ( II % 80 )  THEN SAVLINE = 0\n   END\n   \"ISREDIT (\"ANUM\") = AUTONUM              \"\n\n   CONTENTX = COPIES(' ',LEN)\n\n   DO PNTR =  START  TO  END  BY 1\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      RECORD = SUBSTR(RECORD,1,TOLEFT-1),\n         || CONTENTX,\n         || SUBSTR(RECORD,TORIGHT+1)\n      \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n   END\n\n   IF LBL1 = '' THEN \"ISREDIT LOCATE 1\"\n      ELSE \"ISREDIT LOCATE\" LBL1\n  \"ISREDIT AUTONUM = \"ANUM\n  SIGNAL EOJ\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   SIGNAL DISPDOC\n\nEOJ:\n   IF SAVLINE <> 0 THEN SAVLINE = SAVLINE + 1\n   IF SAVCOL = 0 THEN SAVCOL = 1\n   \"ISREDIT CURSOR =\" SAVLINE SAVCOL\n   X = MSG(SAVEMSG)\n   EXIT\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \" BC - BLANK SPECIFIED COLUMNS                          \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    BC        LEFT-COL  RIGHT-COL  ( .A .B )           \"\n   SAY\n   SAY \"       COLUMNS ARE OPTIONAL.  THEY DEFAULT TO 73       \"\n   SAY \"       THROUGH 80. LABEL RANGE IS ALSO OPTIONAL AND    \"\n   SAY \"       MAY BE SET VIA C/CC/C#.                         \"\n   SAY\n   SAY \" EXAMPLES \"\n   SAY \"    BC        17 19                                    \"\n   SAY \"       WILL OVERLAY '   ' ONTO COLUMNS 17-19           \"\n   SAY\n   SAY \"    BC        73 80  .A .B                             \"\n   SAY \"       WILL PLACE '        ' IN COLUMNS 73 THRU 80     \"\n   SAY \"       IN LABEL RANGE .A THRU .B                       \"\n   SAY\n   RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BLDLR": {"ttr": 16654, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xa6\\x00\\xa6\\x00\\x00\\xc2\\xd3\\xc4\\xd3\\xd9@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 166, "newlines": 166, "modlines": 0, "user": "BLDLR"}, "text": "//-YOUR-USERID-B JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  GET DIRECTORY ENTRY FOR A SPECIFIC MEMBER\n//***\n//A          EXEC     PGM=ASMA90,REGION=4M\n//SYSLIB       DD       DISP=SHR,DSN=SYS1.MACLIB\n//             DD       DISP=SHR,DSN=-YOUR-SYSLIB-\nBLDLR    TITLE 'DYNAMIC BLDL FOR DSN(MEMBER)'\n**********************************************************************\n*  INPUT PARAMETERS ARE:\n*    DATA SET NAME       44 BYTES - ALPHANUMERIC  POINTED TO IN R2\n*    MEMBER               8 BYTES - ALPHANUMERIC                R3\n*    DDNAME               8 BYTES - ALPHANUMERIC                R4\n*    DYNALLOC R15 R/C     2 BYTES - BINARY                      R5\n*    DYNALLOC RETURN CODE 2 BYTES - BINARY                      R6\n*    DYNALLOC REASON CODE 2 BYTES - BINARY                      R7\n*    RETURNED BLDL DATA  80 BYTES - ALPHANUMERIC                R8\n**********************************************************************\n         COPY  MACSDYNA\nBLDLR    RENTER\n\n         LM    R2,R8,0(R1)\n         USING BLDLDATA,R8\n\n         ST    R2,DSADDR          DSNAME ADDR FOR ALLOC MACRO\n         MVC   MEMNAME,0(R3)      SET UP BLDL MEMBER NAME\n         MVC   USERDATA,BLANKS\n         CLC   MEMNAME,BLANKS\n         BE    NOMEMBER\n\n         LA    R9,PDS\n         USING IHADCB,R9\n\n         CLC   0(8,R4),BLANKS     CHECK IF DDNAME PROVIDED\n         BE    DEFAULT\n         ST    R4,DDADDR          DDNAME ADDR\n         MVC   DCBDDNAM,0(R4)\n         B     POSTDEF\nDEFAULT  LA    R15,DCBDDNAM\n         ST    R15,DDADDR\n\nPOSTDEF  MVC   IUDATA,BLANKS\n         MVC   0(2,R5),HEX00S     DEFAULT RETURN CODES TO 0\n         MVC   0(2,R6),HEX00S\n         MVC   0(2,R7),HEX00S\n\n         ALLOC DISP=SHR,DSN=DSADDR,DDN=DDADDR\n         LTR   R15,R15            CHECK ALLOC RETURN CODE\n         BNZ   CHECKOUT\n\n         OPEN  ((9),INPUT)\n         LTR   R15,R15            CHECK BLDL RETURN CODE\n         BNZ   OPENPROB\n\n         MVI   ICONCAT,X'00'\n         MVI   ILIBTYPE,X'00'\n         MVI   IALIASCT,X'00'\n         BLDL  PDS,BLDLPARM\n         LTR   R15,R15            CHECK BLDL RETURN CODE\n         BNZ   BLDLPROB\n\n         MVC   MEM,MEMNAME        FILL IN OUTPUT FIELDS\n         MVC   TTR,ITTR\n         MVC   C,IALIASCT\n         MVC   USERDATA,IUDATA\n\n         CLOSE ((9),DISP)\n         LTR   R15,R15            CHECK BLDL RETURN CODE\n         BNZ   CLOSPROB\n\n         FREE  UNALC,DDN=DDADDR\n         REXIT\n\nBLDLPROB STH   R15,0(R5)          SEND BACK BLDL R15 VALUE\n         STH   R0,0(R6)           SEND ERROR REASON CODE BACK\n         MVC   0(2,R7),HEXFFS     SET DUMMY INFO CODE\n         REXIT\n\nCHECKOUT STH   R15,0(R5)          SEND BACK DYNALLOC R15 VALUE\n         DROP  R14\n         USING S99RB,R14\n         MVC   0(2,R6),S99ERROR   SEND ERROR REASON CODE BACK\n         MVC   0(2,R7),S99INFO    SEND INFO  REASON CODE BACK\n         REXIT\n\nCLOSPROB STH   R15,0(R5)          SEND BACK OPEN R15 VALUE\n         MVC   0(2,R6),HEXFES     SET DUMMY REASON CODE\n         MVC   0(2,R7),HEXFES     SET DUMMY INFO CODE\n         REXIT\n\nNOMEMBER LA    R15,32             SEND BACK NO MEMBER SUPPLIED\n         STH   R15,0(R5)\n         STH   R15,0(R6)          SEND ERROR REASON CODE BACK\n         STH   R15,0(R7)          SEND ERROR REASON CODE BACK\n         REXIT\n\nOPENPROB STH   R15,0(R5)          SEND BACK OPEN R15 VALUE\n         MVC   0(2,R6),HEXFFS     SET DUMMY REASON CODE\n         MVC   0(2,R7),HEXFFS     SET DUMMY INFO CODE\n         REXIT\n\n**       ALLOC MACRO PARAMETERS\n\nDSADDR   DS    A\nDSLEN    DC    H'44'              LENGTH  OF DSNAME (44)\nDDADDR   DS    A\nDDLEN    DC    H'08'              LENGTH  OF DDNAME (08)\n\n**       BLDL PARAMETER LIST\n\nBLDLPARM DS    0D\nNUMENTRY DC    H'01'\nLENENTRY DC    H'76'\nMEMNAME  DS    CL8\nITTR     DS    CL3\nICONCAT  DC    X'00'\nILIBTYPE DC    X'00'\nIALIASCT DC    X'00'\nIUDATA   DS    CL62\n\nBLANKS   DC    CL62' '\nHEX00S   DC    X'0000'\nHEXFFS   DC    X'FFFF'\nHEXFES   DC    X'FFFE'\n\nPDS      DCB   DSORG=PO,MACRF=R,DDNAME=$$DUMMY\n\n         LTORG\n\n         DYNSPACE\n         IEFZB4D0\n         IEFZB4D2\n\n         DCBD  DSORG=(PO),DEVD=DA\n\n**       OUTPUT OVERLAY\n\nBLDLDATA DSECT\nMEM      DS    CL8\nTTR      DS    CL3\nC        DS    CL1\nUSERDATA DS    CL62\n\n         END\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//***\n//L          EXEC     PGM=IEWL,COND=(5,LT),\n//             PARM='XREF,LIST,LET,DCBS',\n//             REGION=4M\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,\n//             DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   99070900\n  ENTRY    BLDLR\n  NAME     BLDLR(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BNCHMKA": {"ttr": 16900, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00!\\x00!\\x00\\x00\\xc2\\xd5\\xc3\\xc8\\xd4\\xd2\\xc1@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "BNCHMKA"}, "text": "//-YOUR-USERID-A JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  ASSEMBLER BENCHMARK CODE - SET FOR 10,000,000 LOOP\n//***    RUN ONCE WITH NO CODE TO ELIMINATE FRAMEWORK COST\n//***\n//A          EXEC     PGM=ASMA90,REGION=4M,\n//             PARM='OBJECT'\n//SYSLIB       DD       DISP=SHR,DSN=SYS1.MACLIB\n//             DD       DISP=SHR,DSN=-YOUR-SYSLIB-\nBASE     RENTER\n         L     R3,LOOPCNT\nLOOP     EQU   *\n*  CODE TO BE BENCHMARKED GOES HERE...\n         BCT   R3,LOOP\n         REXIT\nFW       DC    F'0'\nLOOPCNT  DC    F'010000000'\n         END   BASE\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//***\n//GO         EXEC     PGM=LOADER,\n//             REGION=4M,COND=(5,LT)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//SYSLOUT      DD       SYSOUT=*\n//SYSPRINT     DD       SYSOUT=*\n//SYSUDUMP     DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BNCHMKC": {"ttr": 16902, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x003\\x003\\x00\\x00\\xc2\\xd5\\xc3\\xc8\\xd4\\xd2\\xc3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "BNCHMKC"}, "text": "//-YOUR-USERID-B JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  COBOL BENCHMARK CODE - SET FOR 10,000,000 LOOP\n//***    RUN ONCE WITH NO CODE TO ELIMINATE FRAMEWORK COST\n//***\n//C          EXEC     PGM=IGYCRCTL,REGION=4M,\n//             PARM=('LIB,MAP,LIST,NUMPROC(PFD),OPTIMIZE',\n//            'APOST,NOSEQ,TRUNC(OPT),XREF')\n//SYSIN        DD       *\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  BNCHMK INITIAL.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  WS-MISC.\n           05  WS-TIMES         PIC 9(09) COMP VALUE 10000000.\n           05  WS-COUNT         PIC 9(09) COMP.\n       PROCEDURE DIVISION.\n              DISPLAY '***  TOP OF PROGRAM  ***'\n\n              PERFORM VARYING WS-COUNT FROM 1 BY 1\n                    UNTIL WS-COUNT > WS-TIMES\n                 CONTINUE\n              END-PERFORM\n\n              DISPLAY '***  END OF PROGRAM  ***'\n              GOBACK\n              .\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SYSLIB-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=SYSDA,SPACE=(TRK,(3,3)),\n//             DCB=(BLKSIZE=80,LRECL=80,RECFM=FB)\n//SYSUT1       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT2       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT3       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT4       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT5       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT6       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT7       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//***\n//GO         EXEC     PGM=LOADER,PARM='MAP,PRINT,AMODE(31),RMODE(ANY)',\n//             REGION=4M,COND=(5,LT,C)\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//SYSLOUT      DD       SYSOUT=*\n//SYSPRINT     DD       SYSOUT=*\n//SYSABOUT     DD       SYSOUT=*\n//SYSUDUMP     DD       SYSOUT=*\n//SYSOUT       DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BNCHMKP": {"ttr": 16904, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00'\\x00'\\x00\\x00\\xc2\\xd5\\xc3\\xc8\\xd4\\xd2\\xd7@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "BNCHMKP"}, "text": "//-YOUR-USERID-B JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  PL/I BENCHMARK CODE - SET FOR 10,000,000 LOOP\n//***    RUN ONCE WITH NO CODE TO ELIMINATE FRAMEWORK COST\n//***\n//C          EXEC     PGM=IEL0AA,REGION=4M,\n//             PARM=('AG,A,NCT,ESD,F(I),NOFLOW,NIS,NOLIST,M,NMI,NEST',\n//             'MAP,OF,OPT(TIME),OP,SZ(MAX),S,STMT,STG,X(F)')\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-PLI-LIB-\n\n BASE:  PROC OPTIONS(MAIN) REORDER;\n\n        DCL  LOOPCNT   FIXED BIN(31) STATIC INIT(10000000);\n        DCL  II        FIXED BIN(31) STATIC;\n\n        DO  II = 1 TO LOOPCNT BY 1;\n /*** CODE TO BE BENCHMARKED GOES HERE... ***/\n           END;\n\n        END BASE;\n\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(CYL,(05,02))\n//***\n//GO         EXEC     PGM=LOADER,\n//             PARM='MAP,PRINT,AMODE(31),RMODE(ANY)',\n//             REGION=4M,COND=(5,LT)\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//SYSLOUT      DD       SYSOUT=*\n//I            DD       DISP=SHR,DSN=-YOUR-SYSLIB-(TESTIP)\n//O            DD       SYSOUT=*,\n//             DCB=(RECFM=F,LRECL=80,BLKSIZE=80)\n//SYSPRINT     DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BS": {"ttr": 16906, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00B\\x00B\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 66, "newlines": 66, "modlines": 0, "user": "REXX"}, "text": "/**  REXX - DISPLAY MAX & HALF TRACK BLOCK SIZE FOR A GIVEN LRECL  **/\n   NUMERIC DIGITS 20\n   SAVEMSG = MSG(\"OFF\")\n   CALLED = SYSVAR(SYSNEST)\n   X = ADDRESS()\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT \"ISREDIT MACRO (\"LRECL\")\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      UMODE = 'ISPEXEC'\n      ARG LRECL\n   END\n   ELSE DO\n      ADDRESS ISREDIT \"ISREDIT (\"LIN\",\"COL\") = CURSOR\"\n   END\n   IF LRECL = '?' THEN SIGNAL DISPDOC\n\n CHECK:\n   DO WHILE LRECL = ''\n      SAY \"PLEASE ENTER LRECL:\"\n      PULL LRECL\n      SAVMSG = ''\n   END\n   IF DATATYPE(LRECL)<>'NUM' | LRECL < 1 | LRECL > 32760 THEN DO\n      SAY \"'\"LRECL\"' IS INVALID \"\n      LRECL = ''\n      SIGNAL CHECK\n   END\n   NUMRECS = 32760%LRECL\n   MAXSZ   = NUMRECS*LRECL\n   NUMRECS = 27998%LRECL\n   OPTSZ   = NUMRECS*LRECL\n   NUMRECS = 262144%LRECL\n   SUPERSZ = NUMRECS*LRECL\n   ANSW    = \"LRECL \"LRECL\", MAX BLKSZ=\",\n             MAXSZ\", OPT 3390 BLKSZ=\"OPTSZ,\n             \"& LARGE BLKSZ=\"SUPERSZ\n   IF UMODE = 'ISREDIT' THEN\n      ADDRESS ISREDIT \"ISREDIT LINE_AFTER \"LIN\" = MSGLINE '\"ANSW\"'\"\n   ELSE\n      SAY ANSW\n   EXIT  0\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"BS -- CALCULATE OPTIMAL BLOCK SIZE FOR A GIVEN LRECL   \"\n   SAY\n   SAY \"  BS  ( RECORD-LENGTH )                                \"\n   SAY\n   SAY \"  IF NOT PROVIED ON THE INITIAL CALL, THE RECORD       \"\n   SAY \"  LENGTH WILL BE REQUESTED FROM THE USER.              \"\n   SAY\n   SAY \"  THE OPTIMAL 3390 BLOCK IS BASED ON 27,998 HALF       \"\n   SAY \"  TRACK BLOCKING.                                      \"\n   SAY\n   SAY \"  THE CALCULATED BLOCK SIZES ARE BASED ON 32,760 AS    \"\n   SAY \"  THE NORMAL MAX SIZE AND 262,144 FOR THE NEW LARGE    \"\n   SAY \"  BLOCK SIZE (256K IS THE NORM DEFAULT).               \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CC": {"ttr": 16908, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\x1f\\x00\\x1f\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- INTERACTIVE CALCULATIONS USING REXX INTERPRET COMMAND  **/\n    NUMERIC DIGITS 30\n    SAY \"**  ENTER CALCUATIONS, ? FOR HELP, NULL ENTER TO QUIT...  **\"\n    DO FOREVER\n        PARSE PULL X\n        IF X = \"\" THEN LEAVE\n        IF X = \"?\" THEN SIGNAL DISPDOC\n                   ELSE INTERPRET \"SAY\" X\n    END\n    EXIT(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"CC -- SIMPLE TSO CALCULATOR                            \"\n   SAY\n   SAY \"  CC                                                   \"\n   SAY\n   SAY \"    ALL STANDARD REXX ARITHMETIC STATEMENTS MAY BE     \"\n   SAY \"    ENTERED AND THE RESPONSE IMMEDIATELY FOLLOWS.      \"\n   SAY \"    FOR EXAMPLE, 27998//80 RETURNS 78. PARENTHESES     \"\n   SAY \"    ARE ALLOWED, E.G. (212-32)*5/9.                    \"\n   SAY\n   SAY \"    A PRESS OF <ENTER> WITHOUT ANY INPUT TERMINATES    \"\n   SAY \"    THE MACRO.                                         \"\n   SAY\n   SAY \"    IN ADDITION TO + FOR ADDITION, - FOR SUBTRACTION,  \"\n   SAY \"    * FOR MULTIPLICATION AND / FOR DIVISION, // GIVES  \"\n   SAY \"    THE REMAINDER, % DOES PURE INTEGER DIVISION AND    \"\n   SAY \"    ** PERFORMS EXPONENTIATION.                        \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CENTER": {"ttr": 16910, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00J\\x00J\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 74, "newlines": 74, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- CENTER DATA USING CC/C## RANGE OR DEFAULT TO ENTIRE  **/\n/*           FILE; WILL TAKE COLS AS PARMS OR USE ISPF BOUNDS      */\n\n   SAVEMSG = MSG()\n   X = MSG(\"OFF\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY \"CENTER MUST BE RUN UNDER ISPF EDIT!\"\n      SIGNAL QUIT\n      END\n   SUBCOM ISREDIT\n   UMODE = \"ISREDIT\"\n   ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n   ADDRESS ISREDIT\n   \"MACRO (LEFT,RIGHT) NOPROCESS\"\n   IF LEFT = '?' THEN SIGNAL DISPDOC\n\n   IF LEFT <> \"\" AND RIGHT = \"\" THEN DO\n      \"ISREDIT (L2,RIGHT) = BOUNDS\"\n      END\n\n   \"PROCESS RANGE C\"\n   IF RC > 0 THEN DO\n      \"(TOP) = LINENUM .ZFIRST\"\n      \"(BOT) = LINENUM .ZLAST\"\n   END\n   ELSE DO\n      \"(TOP) = LINENUM .ZFRANGE\"\n      \"(BOT) = LINENUM .ZLRANGE\"\n   END\n\n   \"ISREDIT(\"LB\",\"RB\") = BOUNDS\"\n   IF LEFT  <> \"\" THEN LB = LEFT\n   IF RIGHT <> \"\" THEN RB = RIGHT\n\n   DO II = TOP TO BOT BY 1\n      \"ISREDIT (RECORD) = LINE &II\"\n      DO JJ = RB TO LB BY -1 WHILE(SUBSTR(RECORD,JJ,1) = ' ')\n         END\n      DO KK = LB TO RB BY  1 WHILE(SUBSTR(RECORD,KK,1) = ' ')\n         END\n      IF KK <= JJ THEN DO\n         NN = ( RB - JJ + KK - LB )\n         LL = NN % 2\n         MM = NN - LL\n         RECORD = SUBSTR(RECORD,1,LB-1)  || COPIES(' ',LL),\n            || SUBSTR(RECORD,KK,JJ-KK+1) || COPIES(' ',MM),\n            || SUBSTR(RECORD,RB+1)\n         \"ISREDIT LINE &II = &STR(RECORD)\"\n         END\n      END\n\nQUIT:\n   ADDRESS ISPEXEC\n   X = MSG(SAVEMSG)\n   ADDRESS ISREDIT \"LOCATE\" TOP\n   EXIT(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"CENTER - SHIFT TEXT TO AS CLOSE TO CENTER AS POSSIBLE     \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    CENTER  ( LEFT-COLUMN RIGHT-COLUMN )                  \"\n   SAY\n   SAY \"       CENTERS TEXT WITHIN A MARKED RANGE OF LINES (C, C# \"\n   SAY \"       OR CC MARKED) OR WITHIN THE ENTIRE FILE. THE TEXT  \"\n   SAY \"       IS CENTERED WITHIN THE CURRENT BOUNDS OR THE LEFT  \"\n   SAY \"       AND RIGHT COLUMNS IF SPECIFIED.                    \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHDEL": {"ttr": 16913, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x97\\x00\\x97\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 151, "newlines": 151, "modlines": 0, "user": "REXX"}, "text": "/** REXX -- DYNAMICALLY CREATE HDEL UP JCL AFTER CURSOR POSITION **/\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'CHDEL EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      EXIT(12)\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      ADDRESS ISREDIT \"ISREDIT MACRO (PARMS) NOPROCESS\"\n      PARMS = TRANSLATE(PARMS)\n      IF PARMS = \"?\" THEN SIGNAL DISPDOC\n   END\n   ELSE DO\n      SAY 'CHDEL EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      EXIT(12)\n   END\n\n   ADDRESS ISREDIT\n   \"(LINE,COL) = CURSOR\"\n   IF LINE = 1  THEN DO\n       ADDRESS ISPEXEC \"VGET (ZSCREENC,ZSCREENI) SHARED\"\n       II = INDEX(ZSCREENI,'* Top of Data *')\n       IF ( ZSCREENC % 80 )  <=  ( II % 80 )  THEN LINE = 0\n       ELSE LINE = 1\n   END\n   \"PROCESS RANGE C\"\n   IF RC > 0 THEN DO\n      \"(TOP) = LINENUM .ZFIRST\"\n      \"(BOT) = LINENUM .ZLAST\"\n   END\n   ELSE DO\n      \"(TOP) = LINENUM .ZFRANGE\"\n      \"(BOT) = LINENUM .ZLRANGE\"\n   END\n\n   CARD5 = \"  CALL  *(IEFBR14)\"\n   CARD4 = \"//SYSTSPRT     DD       SYSOUT=*\"\n   CARD3 = \"//SYSTSIN      DD       *\"\n   CARD2 = \"//BATCHTSO   EXEC     PGM=IKJEFT01,REGION=4M,DYNAMNBR=32\"\n   CARD1 = \"//***\"\n\n   ARRAY.0 = 0\n   DO II = TOP TO BOT\n      \"ISREDIT (REC) = LINE &II\"\n      IF (POS('DISP=(,CAT',REC) <> 0 | POS('DISP=(NEW,CAT',REC) <> 0),\n            & SUBSTR(REC,1,3) <> '//*' THEN DO\n         JJ = POS('DSN=',REC)\n         IF JJ = 0 THEN DO\n            JJ = POS('DSNAME=',REC)\n            IF JJ <> 0 THEN JJ = JJ + 3\n         END\n         IF JJ = 0 THEN DO\n            XX = II - 1\n            \"ISREDIT (REC) = LINE &XX\"\n            DO WHILE(SUBSTR(REC,1,3) = '//*' | SUBSTR(REC,1,2) = '/*')\n               XX = XX - 1\n               \"ISREDIT (REC) = LINE &XX\"\n            END\n            DO KK = 71 TO 1 BY -1 WHILE(SUBSTR(REC,KK,1) = ' ')\n            END KK\n            DO WHILE(SUBSTR(REC,KK,1) = ',')\n               JJ = POS('DSN=',REC)\n               IF JJ = 0 THEN DO\n                  JJ = POS('DSNAME=',REC)\n                  IF JJ <> 0 THEN JJ = JJ + 3\n               END\n               IF JJ <> 0 THEN LEAVE\n               XX = XX - 1\n               \"ISREDIT (REC) = LINE &XX\"\n               DO WHILE(SUBSTR(REC,1,3) = '//*')\n                  XX = XX - 1\n                  \"ISREDIT (REC) = LINE &XX\"\n               END\n               DO KK = 71 TO 1 BY -1 WHILE(SUBSTR(REC,KK,1) = ' ')\n               END KK\n            END\n            IF JJ = 0 THEN DO\n               XX = II\n               \"ISREDIT (REC) = LINE &XX\"\n               DO KK = 71 TO 1 BY -1 WHILE(SUBSTR(REC,KK,1) = ' ')\n               END KK\n               DO WHILE(SUBSTR(REC,KK,1) = ',')\n                  XX = XX + 1\n                  \"ISREDIT (REC) = LINE &XX\"\n                  DO WHILE(SUBSTR(REC,1,3) = '//*')\n                     XX = XX + 1\n                     \"ISREDIT (REC) = LINE &XX\"\n                  END\n                  JJ = POS('DSN=',REC)\n                  IF JJ = 0 THEN DO\n                     JJ = POS('DSNAME=',REC)\n                     IF JJ <> 0 THEN JJ = JJ + 3\n                  END\n                  IF JJ <> 0 THEN LEAVE\n                  DO KK = 71 TO 1 BY -1 WHILE(SUBSTR(REC,KK,1) = ' ')\n                  END KK\n               END\n            END\n         END\n         IF JJ <> 0 THEN DO\n            JJ = JJ + 4\n            DO KK = (JJ+1) TO 71,\n               WHILE(SUBSTR(REC,KK,1) <> ' ' & SUBSTR(REC,KK,1) <> ',')\n            END KK\n            ARRAY.0 = ARRAY.0 + 1\n            NN      = ARRAY.0\n            ARRAY.NN = SUBSTR(REC,JJ,KK-JJ)\n         END\n      END\n   END II\n\n   IF ARRAY.0 > 0 THEN DO\n      \"LINE_AFTER (LINE) = (CARD1)\"\n      \"LINE_AFTER (LINE) = (CARD4)\"\n      \"LINE_AFTER (LINE) = (CARD5)\"\n   END\n   DO II = ARRAY.0 TO 1 BY -1\n      CARD  = \"  HDEL  '\" || ARRAY.II || \"'\"\n      \"LINE_AFTER (LINE) = (CARD)\"\n   END II\n\n   IF ARRAY.0 > 0 THEN DO\n      \"LINE_AFTER (LINE) = (CARD3)\"\n      \"LINE_AFTER (LINE) = (CARD2)\"\n      \"LINE_AFTER (LINE) = (CARD1)\"\n   END\n   ELSE SAY \"No 'NEW,CATLG' dispositions found; no JCL generated!\"\n\n   IF LINE = 0 AND COL = 0 THEN EXIT(1)\n   ELSE DO\n      'ISREDIT CURSOR = ' LINE COL\n      EXIT(0)\n   END\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"CHDEL - DYNAMICALLY GENERATE CLEAN UP JCL AFTER CURSOR    \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    CHDEL  ( ? )                                          \"\n   SAY\n   SAY \"       CREATE HDELETE JCL FOR EVERY NEW CATALOGED DATA    \"\n   SAY \"       SET IN THE FILE AND PLACE THEM IMMEDIATELY AFTER   \"\n   SAY \"       WHERE THE CURSOR IS POSITIONED.  C/CC/C# MAY BE    \"\n   SAY \"       USED TO LIMIT THE SEARCH.                          \"\n   SAY\n   SAY \"       A QUESTION MARK ALONE CAUSES THIS HELP TO DISPLAY. \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLONE": {"ttr": 17153, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x01!\\x01!\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 289, "newlines": 289, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- CREATE ANOTHER VERSION OF A D/S UNDER ISPF 3.4  **/\n\n   PARSE ARG PARMS\n   MSG = MSG(OFF)\n   PARMS = TRANSLATE(PARMS)\n\n   ZINPDSN = \"\"\n   ZNEWDSN = \"\"\n   OPTION  = \"\"\n   NUMOPT  = \"\"\n   NUMCHG  = \"\"\n   RELOPT  = \"\"\n   Q       = 0\n\n   IF WORD(PARMS,2) = \"\" | WORD(PARMS,1) = \"?\"\n      THEN SIGNAL DISPDOC\n\n   DO II = 1 TO 9\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF TOKEN = \"EMPTY\" THEN OPTION = TOKEN\n      ELSE IF TOKEN = \"RELEASE\" THEN RELOPT = \"RELEASE\"\n      ELSE IF SUBSTR(TOKEN,1,1) = \"+\" | SUBSTR(TOKEN,1,1) = \"-\"\n         THEN DO\n            NUMOPT = \"CHG\"\n            NUMCHG = TOKEN\n         END\n      ELSE IF DATATYPE(TOKEN,'W')\n         THEN DO\n            NUMOPT = \"NEW\"\n            NUMCHG = TOKEN\n         END\n      ELSE IF SUBSTR(TOKEN,1,1) = \"=\",\n            | SUBSTR(TOKEN,LENGTH(TOKEN),1) = \"=\"\n         THEN ZNEWDSN = TOKEN\n      ELSE IF SUBSTR(TOKEN,1,1) = \"Q\" & DATATYPE(SUBSTR(TOKEN,2),'W')\n         THEN Q = SUBSTR(TOKEN,2)\n      ELSE DO\n         IF ZNEWDSN = \"\" THEN ZNEWDSN = TOKEN\n                         ELSE ZINPDSN = TOKEN\n      END\n   END II\n\n   IF SUBSTR(ZNEWDSN,1,1) = \"=\" THEN DO\n      IF Q = 0 THEN ZNEWDSN = SUBSTR(ZINPDSN,1,LENGTH(ZINPDSN)-1),\n         || SUBSTR(ZNEWDSN,2) || \"'\"\n      ELSE DO\n         NN = LENGTH(ZINPDSN) - 1\n         DO PP = 1 TO Q\n            DO II = NN TO 1 BY -1 WHILE(SUBSTR(ZINPDSN,II,1) <> \".\")\n            END II\n            NN = II - 1\n         END PP\n         ZNEWDSN = SUBSTR(ZINPDSN,1,NN) || SUBSTR(ZNEWDSN,2) || \"'\"\n      END\n   END\n   ELSE IF SUBSTR(ZNEWDSN,LENGTH(ZNEWDSN),1) = \"=\" THEN DO\n      IF Q = 0 THEN ZNEWDSN = \"'\",\n         || SUBSTR(ZNEWDSN,1,LENGTH(ZNEWDSN)-1) || SUBSTR(ZINPDSN,2)\n      ELSE DO\n         NN = 2\n         DO PP = 1 TO Q\n            DO II = NN TO LENGTH(ZINPDSN)-1,\n                  WHILE(SUBSTR(ZINPDSN,II,1) <> \".\")\n            END II\n            NN = II + 1\n         END PP\n         ZNEWDSN = \"'\" || SUBSTR(ZNEWDSN,1,LENGTH(ZNEWDSN)-1),\n            || SUBSTR(ZINPDSN,NN,LENGTH(ZINPDSN)-NN+1)\n      END\n   END\n\n   IF LENGTH(ZNEWDSN) > 46 THEN DO\n      SAY \"***> NEW DATA SET NAME TOO LONG (\"ZNEWDSN\")\"\n      EXIT(1)\n   END\n   IF SYSDSN(ZNEWDSN) = \"OK\" THEN DO\n      SAY \"***> NEW DATA SET ALREADY EXISTS\"\n      EXIT(1)\n   END\n\n   IF OPTION <> \"EMPTY\" THEN DO\n      ADDRESS TSO\n      \"FREE  DD(SORTIN SORTOUT SYSPRINT SYSIN SORTLIST)\"\n      LDSI = LISTDSI(ZINPDSN DIRECTORY)\n      \"ALLOC DD(SORTIN) DSN(\"ZINPDSN\") SHR\"\n      \"ALLOC DD(SYSPRINT) DUMMY\"\n\n      IF SYSDSORG = PO THEN DO\n         IF SYSADIRBLK = \"NO_LIM\" THEN DO\n            \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n               \"DSNTYPE(LIBRARY) DD(SORTOUT) UNIT(SYSDA)\"\n            IF RC <> 0 THEN DO\n               SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n               SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n               EXIT(1)\n            END\n         END\n         ELSE DO\n            IF NUMOPT = \"\" THEN DO\n               \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n                  \"DIR(\"SYSADIRBLK\") DD(SORTOUT) UNIT(SYSDA)\"\n               IF RC <> 0 THEN DO\n                  SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n                  SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n                  EXIT(1)\n               END\n            END\n            ELSE DO\n               IF NUMOPT = \"NEW\" THEN DIRCNT = NUMCHG\n               ELSE DIRCNT = SYSADIRBLK + NUMCHG\n               IF DIRCNT < SYSUDIRBLK THEN DO\n                  SAY \"***> NEW NUMBER OF DIRECTORY BLOCKS (\"DIRCNT\")\",\n                     \"MAY NOT\"\n                  SAY \"***> BE LESS THEN THE NUMBER CURRENTLY IN USE\",\n                     \"(\"SYSUDIRBLK\")\"\n                  EXIT(1)\n               END\n               \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n                  \"DIR(\"DIRCNT\") DD(SORTOUT) UNIT(SYSDA)\"\n               IF RC <> 0 THEN DO\n                  SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n                  SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n                  EXIT(1)\n               END\n            END\n         END\n         \"ALLOC DD(SYSIN) NEW TRACKS SPACE(1) UNIT(SYSDA)\",\n              \" LRECL(80) BLKSIZE(800) RECFM(F B)\"\n         QUEUE \" COPY INDD=SORTIN,OUTDD=SORTOUT\"\n         \"EXECIO\" QUEUED() \"DISKW SYSIN (FINIS\"\n         \"CALL *(IEBCOPY)\"\n      END\n      ELSE IF SYSDSORG = \"PS\" | SYSDSORG = \"PS-E\" THEN DO\n         \"ALLOC DD(SORTLIST) DUMMY\"\n         IF NUMOPT = \"\" THEN DO\n            \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\") DD(SORTOUT)\",\n               \"UNIT(SYSDA)\" RELOPT\n            IF RC <> 0 THEN DO\n               SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n               SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n               EXIT(1)\n            END\n            \"ALLOC DD(SYSIN) NEW TRACKS SPACE(1) UNIT(SYSDA)\",\n                 \"LRECL(80) BLKSIZE(800) RECFM(F B)\"\n            QUEUE \" SORT FIELDS=COPY\"\n            \"EXECIO\" QUEUED() \"DISKW SYSIN (FINIS\"\n            \"CALL *(SORT)\"\n            IF RC <> 0 THEN DO\n               SAY \"***> COPY OF DATA FAILED W/ RC =\" RC\n               SAY \"***> \" ZNEWDSN \" BUT EMPTY...\"\n               EXIT(1)\n            END\n         END\n         ELSE DO\n            LDSI = LISTDSI(ZINPDSN)\n            IF NUMOPT = \"NEW\" THEN NEWLRECL = NUMCHG\n            ELSE NEWLRECL = SYSLRECL + NUMCHG\n            IF SYSRECFM = \"VB\"\n               THEN NEWBLKSIZE = SYSBLKSIZE\n               ELSE NEWBLKSIZE = NEWLRECL * (27998%NEWLRECL)\n            \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\") DD(SORTOUT)\",\n               \"UNIT(SYSDA)\" RELOPT,\n               \"LRECL(\"NEWLRECL\") BLKSIZE(\"NEWBLKSIZE\")\"\n            IF RC <> 0 THEN DO\n               SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n               SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n               EXIT(1)\n            END\n            \"ALLOC DD(SYSIN) NEW TRACKS SPACE(1) UNIT(SYSDA)\",\n                 \"LRECL(80) BLKSIZE(800) RECFM(F B)\"\n            QUEUE \" SORT FIELDS=COPY \"\n            IF NEWLRECL > SYSLRECL & INDEX(SYSRECFM,'F') <> 0 THEN DO\n               PAD = NEWLRECL - SYSLRECL\n               OUTREC_STR = \" OUTREC FIELDS=(1,\" || SYSLRECL,\n                  || \",\" || PAD || \"X)\"\n               QUEUE OUTREC_STR\n            END\n            \"EXECIO\" QUEUED() \"DISKW SYSIN (FINIS\"\n            \"CALL *(SORT)\"\n            IF RC <> 0 THEN DO\n               SAY \"***> COPY OF DATA FAILED W/ RC =\" RC\n               SAY \"***> \" ZNEWDSN \" BUT EMPTY...\"\n               EXIT(1)\n            END\n         END\n      END\n      \"FREE  DD(SORTIN SORTOUT SYSPRINT SYSIN SORTLIST)\"\n      \"ALLOC DD(SYSPRINT) DSN(*)\"\n      \"ALLOC DD(SYSIN) DSN(*)\"\n   END\n   ELSE DO\n      ADDRESS TSO\n      LDSI = LISTDSI(ZINPDSN DIRECTORY)\n      IF SYSDSORG = PO THEN DO\n         IF SYSADIRBLK = \"NO_LIM\" THEN DO\n            \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n               \"DSNTYPE(LIBRARY) DD(SORTOUT) UNIT(SYSDA)\"\n            IF RC <> 0 THEN DO\n               SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n               SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n               EXIT(1)\n            END\n         END\n         ELSE DO\n            IF NUMOPT = \"\" THEN DO\n               \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n                  \"DIR(\"SYSADIRBLK\") UNIT(SYSDA)\"\n               IF RC <> 0 THEN DO\n                  SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n                  SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n                  EXIT(1)\n               END\n            END\n            ELSE DO\n               IF NUMOPT = \"NEW\" THEN DIRCNT = NUMCHG\n               ELSE DIRCNT = SYSADIRBLK + NUMCHG\n               \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n                  \"DIR(\"DIRCNT\") DD(SORTOUT) UNIT(SYSDA)\"\n               IF RC <> 0 THEN DO\n                  SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n                  SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n                  EXIT(1)\n               END\n            END\n         END\n      END\n      ELSE IF SYSDSORG = \"PS\" | SYSDSORG = \"PS-E\" THEN DO\n         \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\") UNIT(SYSDA)\"\n         IF RC <> 0 THEN DO\n            SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n            SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n            EXIT(1)\n         END\n      END\n   \"FREE  DSN(\"ZNEWDSN\")\"\n   END\n\n   IF OPTION = \"EMPTY\"\n      THEN SAY ZINPDSN \"CLONED TO\" ZNEWDSN \"WITHOUT COPYING DATA\"\n      ELSE SAY ZINPDSN \"COPIED TO\" ZNEWDSN\n   EXIT(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"                                                             \"\n   SAY \"  CLONE         MAKES A COPY OF A DATA SET UNDER ISPF 3.4    \"\n   SAY \"                SIMILAR TO THE ONE POINTED TO EITHER         \"\n   SAY \"                COPYING THE DATA OR NOT. SIMPLY TYPE 'CLONE' \"\n   SAY \"                FOLLOWED BY THE NEW NAME AND, OPTIONALLY,    \"\n   SAY \"                THE KEYWORD 'EMPTY' AND/OR DIRECTORY COUNT   \"\n   SAY \"                AND/OR THE 'RELEASE' KEYWORD. EXITS IF NEW   \"\n   SAY \"                DATA SET EXISTS (SEE CLONER).                \"\n   SAY \"                                                             \"\n   SAY \"  SYNTAX:  CLONE  NEW-DATASET-NAME                           \"\n   SAY \"                      <EMPTY>  <#>  <RELEASE>  <Q#>          \"\n   SAY\n   SAY \"             NEW-DATASET-NAME   IS THE NAME OF THE DATA SET  \"\n   SAY \"                TO BE CREATED. IT MAY BE QUALIFIED (WITH     \"\n   SAY \"                QUOTES) OR UNQUALIFIED (ASSUMES YOUR USER-   \"\n   SAY \"                ID AT THE FRONT). IT MAY ALSO BE OF THE FORM \"\n   SAY \"                =XXX WHERE XXX IS SUFFIXED TO THE ORIGINAL   \"\n   SAY \"                NAME OR OF THE FORM XXX= WHERE XXX IS        \"\n   SAY \"                PREFIXED TO THE ORIGINAL NAME. THE Q# OPTION \"\n   SAY \"                MAY BE USED TO REMOVE # LEVELS OF QUALIFIERS \"\n   SAY \"                AT THE BACK OR FRONT OF THE ORIGINAL NAME.   \"\n   SAY\n   SAY \"            <EMPTY>  IS AN OPTIONAL PARAMETER TO INDICATE    \"\n   SAY \"                NO DATA IS TO BE COPIED FROM THE ORIGINAL    \"\n   SAY \"                FILE.                                        \"\n   SAY\n   SAY \"            <#> IS AN OPTIONAL CHANGE TO THE NUMBER OF       \"\n   SAY \"                DIRECTORY BLOCKS IF THE DATA SET IS A PDS.   \"\n   SAY \"                A WHOLE NUMBER IS USED AS IS; PREFIXED BY A +\"\n   SAY \"                IS ADDED; BY A - IS SUBTRACTED. NEVER ALLOWS \"\n   SAY \"                BELOW USED BLOCKS. IF THE DATA SET IS        \"\n   SAY \"                SEQUENTIAL, THE NUMBER BECOMES THE LRECL; A +\"\n   SAY \"                PREFIX ADDS BYTES; A - PREFIX SUBTRACTS.     \"\n   SAY\n   SAY \"            <RELEASE> IS AN OPTION THAT WILL RELEASE ANY     \"\n   SAY \"                UNUSED SPACE IN THE RESULTANT FILE           \"\n   SAY\n   SAY \"            <Q#> IS AN OPTION TO REMOVE THAT MANY (#) LEVEL  \"\n   SAY \"                QUALIFIERS OF THE ORIGINAL DATA SET EITHER   \"\n   SAY \"                PREFIXING IT WITH THE XXX FROM THE XXX= INPUT\"\n   SAY \"                OR SUFFIXING IT WITH THE XXX FROM THE =XXX.  \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLONER": {"ttr": 17159, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x01\\x1e\\x01\\x1e\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 286, "newlines": 286, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- CREATE ANOTHER VERSION OF A D/S UNDER ISPF 3.4  **/\n\n   PARSE ARG PARMS\n   MSG = MSG(OFF)\n   PARMS = TRANSLATE(PARMS)\n\n   ZINPDSN = \"\"\n   ZNEWDSN = \"\"\n   OPTION  = \"\"\n   NUMOPT  = \"\"\n   NUMCHG  = \"\"\n   RELOPT  = \"\"\n   Q       = 0\n\n   IF WORD(PARMS,2) = \"\" | WORD(PARMS,1) = \"?\"\n      THEN SIGNAL DISPDOC\n\n   DO II = 1 TO 9\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF TOKEN = \"EMPTY\" THEN OPTION = TOKEN\n      ELSE IF TOKEN = \"RELEASE\" THEN RELOPT = \"RELEASE\"\n      ELSE IF SUBSTR(TOKEN,1,1) = \"+\" | SUBSTR(TOKEN,1,1) = \"-\"\n         THEN DO\n            NUMOPT = \"CHG\"\n            NUMCHG = TOKEN\n         END\n      ELSE IF DATATYPE(TOKEN,'W')\n         THEN DO\n            NUMOPT = \"NEW\"\n            NUMCHG = TOKEN\n         END\n      ELSE IF SUBSTR(TOKEN,1,1) = \"=\",\n            | SUBSTR(TOKEN,LENGTH(TOKEN),1) = \"=\"\n         THEN ZNEWDSN = TOKEN\n      ELSE IF SUBSTR(TOKEN,1,1) = \"Q\" & DATATYPE(SUBSTR(TOKEN,2),'W')\n         THEN Q = SUBSTR(TOKEN,2)\n      ELSE DO\n         IF ZNEWDSN = \"\" THEN ZNEWDSN = TOKEN\n                         ELSE ZINPDSN = TOKEN\n      END\n   END II\n\n   IF SUBSTR(ZNEWDSN,1,1) = \"=\" THEN DO\n      IF Q = 0 THEN ZNEWDSN = SUBSTR(ZINPDSN,1,LENGTH(ZINPDSN)-1),\n         || SUBSTR(ZNEWDSN,2) || \"'\"\n      ELSE DO\n         NN = LENGTH(ZINPDSN) - 1\n         DO PP = 1 TO Q\n            DO II = NN TO 1 BY -1 WHILE(SUBSTR(ZINPDSN,II,1) <> \".\")\n            END II\n            NN = II - 1\n         END PP\n         ZNEWDSN = SUBSTR(ZINPDSN,1,NN) || SUBSTR(ZNEWDSN,2) || \"'\"\n      END\n   END\n   ELSE IF SUBSTR(ZNEWDSN,LENGTH(ZNEWDSN),1) = \"=\" THEN DO\n      IF Q = 0 THEN ZNEWDSN = \"'\",\n         || SUBSTR(ZNEWDSN,1,LENGTH(ZNEWDSN)-1) || SUBSTR(ZINPDSN,2)\n      ELSE DO\n         NN = 2\n         DO PP = 1 TO Q\n            DO II = NN TO LENGTH(ZINPDSN)-1,\n                  WHILE(SUBSTR(ZINPDSN,II,1) <> \".\")\n            END II\n            NN = II + 1\n         END PP\n         ZNEWDSN = \"'\" || SUBSTR(ZNEWDSN,1,LENGTH(ZNEWDSN)-1),\n            || SUBSTR(ZINPDSN,NN,LENGTH(ZINPDSN)-NN+1)\n      END\n   END\n\n   IF LENGTH(ZNEWDSN) > 46 THEN DO\n      SAY \"***> NEW DATA SET NAME TOO LONG (\"ZNEWDSN\")\"\n      EXIT(1)\n   END\n   IF SYSDSN(ZNEWDSN) = \"OK\" THEN ADDRESS TSO DELETE ZNEWDSN\n\n   IF OPTION <> \"EMPTY\" THEN DO\n      ADDRESS TSO\n      \"FREE  DD(SORTIN SORTOUT SYSPRINT SYSIN SORTLIST)\"\n      LDSI = LISTDSI(ZINPDSN DIRECTORY)\n      \"ALLOC DD(SORTIN) DSN(\"ZINPDSN\") SHR\"\n      \"ALLOC DD(SYSPRINT) DUMMY\"\n\n      IF SYSDSORG = PO THEN DO\n         IF SYSADIRBLK = \"NO_LIM\" THEN DO\n            \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n               \"DSNTYPE(LIBRARY) DD(SORTOUT) UNIT(SYSDA)\"\n            IF RC <> 0 THEN DO\n               SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n               SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n               EXIT(1)\n            END\n         END\n         ELSE DO\n            IF NUMOPT = \"\" THEN DO\n               \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n                  \"DIR(\"SYSADIRBLK\") DD(SORTOUT) UNIT(SYSDA)\"\n               IF RC <> 0 THEN DO\n                  SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n                  SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n                  EXIT(1)\n               END\n            END\n            ELSE DO\n               IF NUMOPT = \"NEW\" THEN DIRCNT = NUMCHG\n               ELSE DIRCNT = SYSADIRBLK + NUMCHG\n               IF DIRCNT < SYSUDIRBLK THEN DO\n                  SAY \"***> NEW NUMBER OF DIRECTORY BLOCKS (\"DIRCNT\")\",\n                     \"MAY NOT\"\n                  SAY \"***> BE LESS THEN THE NUMBER CURRENTLY IN USE\",\n                     \"(\"SYSUDIRBLK\")\"\n                  EXIT(1)\n               END\n               \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n                  \"DIR(\"DIRCNT\") DD(SORTOUT) UNIT(SYSDA)\"\n               IF RC <> 0 THEN DO\n                  SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n                  SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n                  EXIT(1)\n               END\n            END\n         END\n         \"ALLOC DD(SYSIN) NEW TRACKS SPACE(1) UNIT(SYSDA)\",\n              \" LRECL(80) BLKSIZE(800) RECFM(F B)\"\n         QUEUE \" COPY INDD=SORTIN,OUTDD=SORTOUT\"\n         \"EXECIO\" QUEUED() \"DISKW SYSIN (FINIS\"\n         \"CALL *(IEBCOPY)\"\n      END\n      ELSE IF SYSDSORG = \"PS\" | SYSDSORG = \"PS-E\" THEN DO\n         \"ALLOC DD(SORTLIST) DUMMY\"\n         IF NUMOPT = \"\" THEN DO\n            \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\") DD(SORTOUT)\",\n               \"UNIT(SYSDA)\" RELOPT\n            IF RC <> 0 THEN DO\n               SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n               SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n               EXIT(1)\n            END\n            \"ALLOC DD(SYSIN) NEW TRACKS SPACE(1) UNIT(SYSDA)\",\n                 \"LRECL(80) BLKSIZE(800) RECFM(F B)\"\n            QUEUE \" SORT FIELDS=COPY\"\n            \"EXECIO\" QUEUED() \"DISKW SYSIN (FINIS\"\n            \"CALL *(SORT)\"\n            IF RC <> 0 THEN DO\n               SAY \"***> COPY OF DATA FAILED W/ RC =\" RC\n               SAY \"***> \" ZNEWDSN \" BUT EMPTY...\"\n               EXIT(1)\n            END\n         END\n         ELSE DO\n            LDSI = LISTDSI(ZINPDSN)\n            IF NUMOPT = \"NEW\" THEN NEWLRECL = NUMCHG\n            ELSE NEWLRECL = SYSLRECL + NUMCHG\n            IF SYSRECFM = \"VB\"\n               THEN NEWBLKSIZE = SYSBLKSIZE\n               ELSE NEWBLKSIZE = NEWLRECL * (27998%NEWLRECL)\n            \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\") DD(SORTOUT)\",\n               \"UNIT(SYSDA)\" RELOPT,\n               \"LRECL(\"NEWLRECL\") BLKSIZE(\"NEWBLKSIZE\")\"\n            IF RC <> 0 THEN DO\n               SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n               SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n               EXIT(1)\n            END\n            \"ALLOC DD(SYSIN) NEW TRACKS SPACE(1) UNIT(SYSDA)\",\n                 \"LRECL(80) BLKSIZE(800) RECFM(F B)\"\n            QUEUE \" SORT FIELDS=COPY \"\n            IF NEWLRECL > SYSLRECL & INDEX(SYSRECFM,'F') <> 0 THEN DO\n               PAD = NEWLRECL - SYSLRECL\n               OUTREC_STR = \" OUTREC FIELDS=(1,\" || SYSLRECL,\n                  || \",\" || PAD || \"X)\"\n               QUEUE OUTREC_STR\n            END\n            \"EXECIO\" QUEUED() \"DISKW SYSIN (FINIS\"\n            \"CALL *(SORT)\"\n            IF RC <> 0 THEN DO\n               SAY \"***> COPY OF DATA FAILED W/ RC =\" RC\n               SAY \"***> \" ZNEWDSN \" BUT EMPTY...\"\n               EXIT(1)\n            END\n         END\n      END\n      \"FREE  DD(SORTIN SORTOUT SYSPRINT SYSIN SORTLIST)\"\n      \"ALLOC DD(SYSPRINT) DSN(*)\"\n      \"ALLOC DD(SYSIN) DSN(*)\"\n   END\n   ELSE DO\n      ADDRESS TSO\n      LDSI = LISTDSI(ZINPDSN DIRECTORY)\n      IF SYSDSORG = PO THEN DO\n         IF SYSADIRBLK = \"NO_LIM\" THEN DO\n            \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n               \"DSNTYPE(LIBRARY) DD(SORTOUT) UNIT(SYSDA)\"\n            IF RC <> 0 THEN DO\n               SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n               SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n               EXIT(1)\n            END\n         END\n         ELSE DO\n            IF NUMOPT = \"\" THEN DO\n               \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n                  \"DIR(\"SYSADIRBLK\") UNIT(SYSDA)\"\n               IF RC <> 0 THEN DO\n                  SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n                  SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n                  EXIT(1)\n               END\n            END\n            ELSE DO\n               IF NUMOPT = \"NEW\" THEN DIRCNT = NUMCHG\n               ELSE DIRCNT = SYSADIRBLK + NUMCHG\n               \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n                  \"DIR(\"DIRCNT\") DD(SORTOUT) UNIT(SYSDA)\"\n               IF RC <> 0 THEN DO\n                  SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n                  SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n                  EXIT(1)\n               END\n            END\n         END\n      END\n      ELSE IF SYSDSORG = \"PS\" | SYSDSORG = \"PS-E\" THEN DO\n         \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\") UNIT(SYSDA)\"\n         IF RC <> 0 THEN DO\n            SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n            SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n            EXIT(1)\n         END\n      END\n   \"FREE  DSN(\"ZNEWDSN\")\"\n   END\n\n   IF OPTION = \"EMPTY\"\n      THEN SAY ZINPDSN \"CLONED TO\" ZNEWDSN \"WITHOUT COPYING DATA\"\n      ELSE SAY ZINPDSN \"COPIED TO\" ZNEWDSN\n   EXIT(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"                                                             \"\n   SAY \"  CLONER        MAKES A COPY OF A DATA SET UNDER ISPF 3.4    \"\n   SAY \"                SIMILAR TO THE ONE POINTED TO EITHER         \"\n   SAY \"                COPYING THE DATA OR NOT. SIMPLY TYPE 'CLONE' \"\n   SAY \"                FOLLOWED BY THE NEW NAME AND, OPTIONALLY,    \"\n   SAY \"                THE KEYWORD 'EMPTY' AND/OR DIRECTORY COUNT   \"\n   SAY \"                AND/OR THE 'RELEASE' KEYWORD. DELETES ANY    \"\n   SAY \"                EXISTING DATA SET IF IT EXISTS.              \"\n   SAY \"                                                             \"\n   SAY \"  SYNTAX:  CLONER NEW-DATASET-NAME                           \"\n   SAY \"                      <EMPTY>  <#>  <RELEASE>  <Q#>          \"\n   SAY\n   SAY \"             NEW-DATASET-NAME   IS THE NAME OF THE DATA SET  \"\n   SAY \"                TO BE CREATED. IT MAY BE QUALIFIED (WITH     \"\n   SAY \"                QUOTES) OR UNQUALIFIED (ASSUMES YOUR USER-   \"\n   SAY \"                ID AT THE FRONT). IT MAY ALSO BE OF THE FORM \"\n   SAY \"                =XXX WHERE XXX IS SUFFIXED TO THE ORIGINAL   \"\n   SAY \"                NAME OR OF THE FORM XXX= WHERE XXX IS        \"\n   SAY \"                PREFIXED TO THE ORIGINAL NAME. THE Q# OPTION \"\n   SAY \"                MAY BE USED TO REMOVE # LEVELS OF QUALIFIERS \"\n   SAY \"                AT THE BACK OR FRONT OF THE ORIGINAL NAME.   \"\n   SAY\n   SAY \"            <EMPTY>  IS AN OPTIONAL PARAMETER TO INDICATE    \"\n   SAY \"                NO DATA IS TO BE COPIED FROM THE ORIGINAL    \"\n   SAY \"                FILE.                                        \"\n   SAY\n   SAY \"            <#> IS AN OPTIONAL CHANGE TO THE NUMBER OF       \"\n   SAY \"                DIRECTORY BLOCKS IF THE DATA SET IS A PDS.   \"\n   SAY \"                A WHOLE NUMBER IS USED AS IS; PREFIXED BY A +\"\n   SAY \"                IS ADDED; BY A - IS SUBTRACTED. NEVER ALLOWS \"\n   SAY \"                BELOW USED BLOCKS. IF THE DATA SET IS        \"\n   SAY \"                SEQUENTIAL, THE NUMBER BECOMES THE LRECL; A +\"\n   SAY \"                PREFIX ADDS BYTES; A - PREFIX SUBTRACTS.     \"\n   SAY\n   SAY \"            <RELEASE> IS AN OPTION THAT WILL RELEASE ANY     \"\n   SAY \"                UNUSED SPACE IN THE RESULTANT FILE           \"\n   SAY\n   SAY \"            <Q#> IS AN OPTION TO REMOVE THAT MANY (#) LEVEL  \"\n   SAY \"                QUALIFIERS OF THE ORIGINAL DATA SET EITHER   \"\n   SAY \"                PREFIXING IT WITH THE XXX FROM THE XXX= INPUT\"\n   SAY \"                OR SUFFIXING IT WITH THE XXX FROM THE =XXX.  \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLRSCRN": {"ttr": 17165, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00!\\x00!\\x00\\x00\\xc3\\xd3\\xd9\\xe2\\xc3\\xd9\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "CLRSCRN"}, "text": "//-YOUR-USERID-C JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//ASM        EXEC     PGM=ASMA90,REGION=4M\n//SYSLIB       DD       DISP=SHR,DSN=SYS1.MACLIB\n//             DD       DISP=SHR,DSN=-YOUR-SYSLIB-\nCLRSCRN   AMODE     31\nCLRSCRN   RMODE     ANY\nCLRSCRN   RENTER\n          STLINENO  LINE=1,CLEAR=YES\n          REXIT\n          END       CLRSCRN\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//***\n//L          EXEC     PGM=IEWL,\n//             PARM='AMODE(31),RMODE(ANY),XREF,LIST,LET,DCBS',\n//             REGION=4M,COND=(5,LE)\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,\n//             DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   01040100\n  ENTRY    CLRSCRN\n  NAME     CLRSCRN(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CLS": {"ttr": 17410, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x02\\x00\\x02\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 2, "newlines": 2, "modlines": 0, "user": "REXX"}, "text": "/**  REXX  --  CLEAR THE TSO SCREEN  **/\n   \"CALL '-YOUR-LOADLIB-(CLRSCRN)'\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLS2REXX": {"ttr": 17412, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\t\\xde\\t\\xde\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 2526, "newlines": 2526, "modlines": 0, "user": "REXX"}, "text": "/* REXX - CONVERT CLIST TO REXX EXEC WITHIN EDIT **********************/\nSignal On NoValue\nParse source opsys . cmd_name .\nIf opsys = \"TSO\"\n  Then\n    Do\n    ADDRESS ISREDIT\n    ISREDIT = \"\"\n    End\n  Else\n    ISREDIT = \"ISREDIT\"\nISREDIT \"MACRO (PARM)\"\nparm = strip(translate(parm))\nIf parm = \"?\"\n  Then\n    Do\n    Call Help\n    Exit 0\n    End\ntest_mode = 0\nSelect\n  When parm = \"TEST\"\n    Then\n      test_mode = 1\n  When parm = \"TRACE\"\n    Then\n      test_mode = 2\n  When parm = \"\"\n    Then\n      Nop\n  Otherwise\n      Do\n      zedsmsg = \"Invalid parm\"\n      zedlmsg = '\"'parm'\" is an invalid parameter.'\n      ADDRESS  ISPEXEC \"SETMSG MSG(ISRZ001)\"\n      Exit 8\n      End\n  End\nif test_mode \u00ac= 0\n  then\n    Say 'Test_mode =' Test_mode\nIf opsys = \"TSO\" & userid() = \"TRIBLET\"\n  Then\n    Do\n    ISREDIT \"(DSNAME) = DATASET\"\n    If dsname = \"TRIBLET.CLS2REXX.TESTCASE.CLIST\",\n      |dsname = \"TRIBLET.CLS2REXX.TESTCASE.CLISTFB\"\n      Then\n        Do\n        ISREDIT \"DEFINE CLS2FILE CMD MACRO\"\n        ISREDIT \"DEFINE SAVE DISABLED\"\n        ISREDIT \"DEFINE END ALIAS CLS2FILE\"\n        End\n    End\nISREDIT \"(FIRSTLIN) = LINE 1\"\nIf left(word(firstlin,1),2) = \"/*\",\n  & pos(\"REXX\",firstlin) \u00ac= 0\n  Then\n    Do\n    zedsmsg = \"Already REXXified\"\n    zedlmsg = \"The current file is already a REXX exec.\"\n    ADDRESS  ISPEXEC \"SETMSG MSG(ISRZ001)\"\n    Exit 4\n    End\nISREDIT \"(NUMLINES) = LINENUM .ZLAST\"\nISREDIT \"(LRECL) = LRECL\"\nISREDIT \"(RECFM) = RECFM\"\nIf recfm = \"F\",\n  & lrecl = 80,\n  Then\n    lrecl = lrecl - 8\ntoken_offset = 0\ncurr_token = \"\"\nnext_token = \"\"\ncurr_char  = \"\"\nnext_char  = \"\"\ncurr_stmt = \"\"\nnew_exp   = \"\"\nlabel_list = \"\"\nverb = \"\"\noutput_line.1 = \"\"\noutput_line_type.1 = \"\"\noutput_recd = \"\"\npdf_edit_macro_found = 0\ncontrol_stmt_used = 0\ncontrol_list_stmt_used = 0\nfirst_proc_stmt_found = 0\ninput_line_number = 0\noutput_line_number = 0\n\nmust_define.sysdval = 0\nmust_define.sysprompt = 0\nmust_define.syssymlist = 0\nmust_define.sysconlist = 0\nmust_define.syslist = 0\nmust_define.sysasis = 0\nmust_define.sysmsg = 0\nmust_define.sysflush = 0\nmust_define.eval = 0\nmust_define.syslc = 0\nmust_define.substrc = 0\nmust_define.sysnsub = 0\nmust_define.sysouttrap = 0\nmust_define.sysoutline = 0\nindent = 0\nCall Get_Stmt\nDo while input_line_number <= numlines\n  Call Parse_Stmt\n  End\nindent = 0\nCall Put_Stmt \"Exit 0\"\nIf control_list_stmt_used\n  Then\n    Do\n    Call Put_Stmt \" \"\n    Call Put_Stmt \"check_control_options:\"\n    Call Put_Stmt \"Select\"\n    Call Put_Stmt \"  When syssymlist = 'ON' & sysconlist= 'OFF'\"\n    Call Put_Stmt \"    Then\"\n    Call Put_Stmt \"      control_options_value = 'a'\"\n    Call Put_Stmt \"  When sysconlist = 'ON'\"\n    Call Put_Stmt \"    Then\"\n    Call Put_Stmt \"      control_options_value = 'r'\"\n    Call Put_Stmt \"  When syslist = 'ON'\"\n    Call Put_Stmt \"    Then\"\n    Call Put_Stmt \"      control_options_value = 'c'\"\n    Call Put_Stmt \"  Otherwise\"\n    Call Put_Stmt \"      control_options_value = 'o'\"\n    Call Put_Stmt \"  End\"\n    Call Put_Stmt \"  Return 0\"\n    End\nISREDIT \"CAPS OFF\"\nISREDIT \"NUMBER OFF\"\nISREDIT \"DELETE .ZFIRST .ZLAST\"\nISREDIT 'LINE_AFTER 0 = \"/* REXX */\"'\nIf opsys = 'TSO'\n  Then\n    Address TSO \"NEWSTACK\"\n  Else\n    Address CMS \"MAKEBUF\"\nalready_queued = queued()\nQueue \"/* \"cmd_name\"ed by\" userid() \"on\" date() \"at\" time() \" */\"\nQueue \"Signal On NoValue\"\nQueue \"Parse source opsys . exec_name .\"\nIf pdf_edit_macro_found\n  Then\n    Do\n    Queue \"If opsys = 'TSO'\"\n    Queue \"  Then\"\n    Queue \"    Do\"\n    Queue \"    Address ISREDIT\"\n    Queue \"    ISREDIT = ''\"\n    Queue \"    End\"\n    Queue \"  Else\"\n    Queue \"    ISREDIT = 'ISREDIT'\"\n    End\nIf must_define.sysdval\n  Then\n    Queue \"sysdval = ''\"\nIf must_define.sysprompt\n  Then\n    Queue \"sysprompt = 'OFF'\"\nIf must_define.syssymlist,\n  | control_list_stmt_used\n  Then\n    Queue \"syssymlist = 'OFF'\"\nIf must_define.sysconlist,\n  | control_list_stmt_used\n  Then\n    Queue \"sysconlist = 'OFF'\"\nIf must_define.syslist,\n  | control_list_stmt_used\n  Then\n    Queue \"syslist = 'OFF'\"\nIf must_define.sysasis\n  Then\n    Queue \"sysasis = 'OFF'\"\nIf must_define.sysmsg\n  Then\n    Queue \"sysmsg = 'ON'\"\nIf must_define.sysflush\n  Then\n    Queue \"sysflush = 'ON'\"\nIf control_stmt_used\n  Then\n    Queue \"control_options_value = 'o'\"\nQueue \" \"\nQueue \" \"\nCall Append_Stack\nIf opsys = 'TSO'\n  Then\n    Address TSO \"DELSTACK\"\n  Else\n    Address CMS \"DROPBUF\"\nDo i = 1 to output_line_number\n  thisline = strip(output_line.i,\"t\")\n  If length(thisline) = 0\n    Then\n      ThisLine = \" \"\n  ISREDIT \"(LAST) = LINENUM .ZLAST\"\n  If test_mode >= 1\n    Then\n      Say \"LineBefor\" last output_line_type.i '\"'ThisLine'\"'\n  ISREDIT \"LINE_BEFORE .ZLAST =\" output_line_type.i \"(THISLINE)\"\n  End\nIf opsys = 'TSO'\n  Then\n    Address TSO \"NEWSTACK\"\n  Else\n    Address CMS \"MAKEBUF\"\nalready_queued = queued()\nIf must_define.eval\n  Then\n    Do\n    Queue \" \"\n    Queue \"eval: Procedure\"\n    Queue \"  Return arg(1)\"\n    End\nIf must_define.syslc\n  Then\n    Do\n    Queue \" \"\n    Queue \"syslc: Procedure\"\n    Queue \"  Return translate(arg(1),,\"\n    Queue \"       'abcdefghijklmnopqrstuvwxyz',,\"\n    Queue \"       'ABCDEFGHIJKLMNOPQRSTUVWXYZ')\"\n    End\nIf must_define.substrc\n  Then\n    Do\n    Queue \" \"\n    Queue \"substrc: Procedure\"\n    Queue \" If arg(3) = ''\"\n    Queue \"   Then\"\n    Queue \"     Do\"\n    Queue \"     s = Arg(1)\"\n    Queue \"     l = 1\"\n    Queue \"     v = arg(2)\"\n    Queue \"     End\"\n    Queue \"   Else\"\n    Queue \"     Do\"\n    Queue \"     s = arg(1)\"\n    Queue \"     l = arg(2)-arg(1)+1\"\n    Queue \"     v = arg(3)\"\n    Queue \"     End\"\n    Queue \"  Return substr(v,s,l)\"\n    End\nIf must_define.sysnsub\n  Then\n    Do\n    Queue \" \"\n    Queue \"sysnsub: Procedure\"\n    Queue \" return arg(1)\"\n    End\nIf must_define.sysouttrap\n  Then\n    Do\n    Queue \" \"\n    Queue \"sysouttrap: /*Procedure*/\"\n    Queue \"  Interpret 'sysouttrap_Result = 'OutTrap()'MAX'\"\n    Queue \"  Return sysouttrap_Result\"\n    End\nIf must_define.sysoutline\n  Then\n    Do\n    Queue \" \"\n    Queue \"sysoutline: /*Procedure*/\"\n    Queue \"  sysouttrap_Index = arg(1)\"\n    Queue \"  Interpret 'sysouttrap_Result = 'OutTrap()sysouttrap_Index\"\n    Queue \"  Return sysouttrap_Result\"\n    End\nQueue \" \"\nCall Append_Stack\nIf opsys = 'TSO'\n  Then\n    Address TSO \"DELSTACK\"\n  Else\n    Address CMS \"DROPBUF\"\nISREDIT \"LEFT MAX\"\nISREDIT \"UP MAX\"\nExit 0\n/*1*/\n/**********************************************************************/\n/*** Parse_Stmt:                                                    ***/\n/***   Subroutine to parse a single CLIST statement, and translate  ***/\n/***   it to REXX.                                                  ***/\n/**********************************************************************/\n\nParse_Stmt: Procedure expose curr_token,\n                             curr_token_type,\n                             next_token,\n                             next_token_type,\n                             token_offset,\n                             first_token,\n                             curr_stmt,\n                             curr_char,\n                             next_char,\n                             test_mode,\n                             expr_depth,\n                             numlines,\n                             input_line_number,\n                             cmd_name,\n                             output_recd,\n                             output_line_type.,\n                             output_line.,\n                             output_line_number,\n                             quote_mode,\n                             must_define.,\n                             new_exp,\n                             verb,\n                             lrecl,\n                             label_list,\n                             pdf_edit_macro_found,\n                             control_stmt_used,\n                             control_list_stmt_used,\n                             first_proc_stmt_found,\n                             indent,\n                             isredit\n  expr_depth = 0\n  If input_line_number > numlines\n    Then\n      Leave\n  If test_mode >= 2\n    Then\n      Say 'Parse_Stmt' verb\n  Select\n\n    When verb = \"PROC\"\n      Then\n        Do\n        If first_proc_stmt_found\n          Then\n            Do\n            indent = indent + 2\n            Call Put_Stmt \"Procedure\"\n            End\n        tsoproc_parms = \"PROC\"\n        Do while curr_token_type \u00ac= \"<eos>\"\n          Call Get_Token\n          Select\n            When curr_token_type = \"<comment>\"\n              Then\n                Call Put_Stmt curr_token\n            When curr_token_type = \"<eos>\"\n              Then\n                Nop\n            Otherwise\n                tsoproc_parms = tsoproc_parms||curr_token\n            End\n          End\n        Select\n          When words(tsoproc_parms) <= 2\n            Then\n              Nop\n          When datatype(word(tsoproc_parms,2)) \u00ac= \"NUM\"\n            Then\n              Do\n              Call Put_Msg \"Warning:\" verb \"at input line\",\n                   input_line_number \"has non-numeric count.\"\n              End\n          When word(tsoproc_parms,2) = words(tsoproc_parms)-2\n            Then\n              Do\n              Call Put_Stmt \"Parse upper arg argument_list\"\n              Call Put_Stmt \"If words(argument_list) >\",\n                            word(tsoproc_parms,2)\n              Call Put_Stmt \"  Then\"\n              Call Put_Stmt \"    Do\"\n              Call Put_Stmt \"    Say 'Extraneous parm value\",\n                                   \"\"\"'subword(argument_list,\",\n                                   word(tsoproc_parms,2)+1\")'\"\"\",\n                                   \"ignored.'\"\n              Call Put_Stmt \"    End\"\n              Call Put_Stmt \"If words(argument_list) <\",\n                            word(tsoproc_parms,2)\n              Call Put_Stmt \"  Then\"\n              Call Put_Stmt \"    Do\"\n              Call Put_Stmt \"    Say 'Positional Parms'\",\n                                   \"subword('\"tsoproc_parms\"',\",\n                                   \"words(argument_list)+3) 'omitted.'\"\n              Call Put_Stmt \"    Exit\"\n              Call Put_Stmt \"    End\"\n              Call Put_Stmt \"Parse Var argument_list\",\n                            subword(tsoproc_parms,3) \".\"\n              End\n          Otherwise\n              Do\n              Call Put_Stmt \"Parse upper arg argument_list\"\n              Call Put_Stmt \"Call TSOPROC argument_list,,\n                            '\"tsoproc_parms\"'\"\n              Call Put_Stmt \"Interpret Result\"\n              Call Put_Stmt \"If RC \u00ac= 0\"\n              Call Put_Stmt \"  Then\"\n              Call Put_Stmt \"    Do\"\n              Call Put_Stmt \"    Say tsoproc_msg\"\n              Call Put_Stmt \"    Exit RC\"\n              Call Put_Stmt \"    End\"\n              End\n          End\n        Call Get_Stmt\n        If first_proc_stmt_found\n          Then\n            Do\n            Do while verb \u00ac= \"END\",\n              & input_line_number <= numlines\n              Call Parse_Stmt\n              End\n            Call Put_indent                 /* CHG-0001 */\n            Call Put_Token \"Return\"\n            Call Get_Token\n            Call Parse_Expression\n            Call Put_Line\n            Call Get_Stmt\n            indent = indent - 2\n            End\n        first_proc_stmt_found = 1\n        End\n\n    When verb = \"ATTN\"\n      Then\n        Do\n        Call Put_Msg \"Warning:\" verb \"at input line\",\n             input_line_number \"not translateable by\" cmd_name\".\"\n        Call Put_Token \"/*!\"\n        Call Put_Indent\n        Call Put_Token verb||\" \"\n        Call Get_Token\n        Call Parse_Expression\n        Call Put_Token \"*/\"\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"CLOSFILE\"\n      Then\n        Do\n        Call Get_Token\n        Call Get_Token\n        Call Put_Indent\n        Call Put_Token 'Address TSO \"EXECIO * DISKR '\n        If curr_token_type = \"<variable>\"\n          Then\n            Call Put_Token '\"'substr(curr_token,2)'\"'\n          Else\n            Call Put_Token curr_token\n        Call Put_Token ' (FINIS\"'\n        Call Put_Line\n        Call Get_Token\n        Call Get_Stmt\n        End\n\n    When verb = \"CONTROL\"\n      Then\n        Do\n        control_stmt_used = 1\n        Call Get_NonBlank_Token\n        list_option_set = 0\n        Call Put_Stmt \"Do\"\n        Do while curr_token_type \u00ac= \"<eos>\"\n          Select\n            When curr_token = \"LIST\"\n              Then\n                Do\n                Call Put_Stmt \"Syslist = 'ON'\"\n                list_option_set = 1\n                End\n            When curr_token = \"NOLIST\"\n              Then\n                Do\n                Call Put_Stmt \"Syslist = 'OFF'\"\n                list_option_set = 1\n                End\n            When curr_token = \"CONLIST\"\n              Then\n                Do\n                Call Put_Stmt \"sysconlist = 'ON'\"\n                list_option_set = 1\n                End\n            When curr_token = \"NOCONLIST\"\n              Then\n                Do\n                Call Put_Stmt \"sysconlist = 'OFF'\"\n                list_option_set = 1\n                End\n            When curr_token = \"SYMLIST\"\n              Then\n                Do\n                Call Put_Stmt \"syssymlist = 'ON'\"\n                list_option_set = 1\n                End\n            When curr_token = \"NOSYMLIST\"\n              Then\n                Do\n                Call Put_Stmt \"syssymlist = 'OFF'\"\n                list_option_set = 1\n                End\n            When curr_token = \"PROMPT\"\n              Then\n                Do\n                Call Put_Stmt \"Call Prompt 'ON'\"\n                Call Put_Stmt \"sysprompt = 'ON'\"\n                must_define.sysprompt = 1\n                End\n            When curr_token = \"NOPROMPT\"\n              Then\n                Do\n                Call Put_Stmt \"Call Prompt 'OFF'\"\n                Call Put_Stmt \"sysprompt = 'OFF'\"\n                must_define.sysprompt = 1\n                End\n            When curr_token = \"MSG\"\n              Then\n                Do\n                Call Put_Stmt \"Call OutTrap 'OFF'\"\n                Call Put_Stmt \"sysmsg = 'ON'\"\n                must_define.sysmsg = 1\n                End\n            When curr_token = \"NOMSG\"\n              Then\n                Do\n                Call Put_Stmt \"Call OutTrap 'outtrap.'\"\n                Call Put_Stmt \"sysmsg = 'OFF'\"\n                must_define.sysmsg = 1\n                End\n            When curr_token = \"FLUSH\"\n              Then\n                Do\n                Call Put_Msg \"Warning: CONTROL\" curr_token,\n                    \"at input line\" input_line_number,\n                    \"not translateable by\" cmd_name\".\"\n                Call Put_Stmt \"sysflush = 'ON' /*!*/\"\n                must_define.sysflush = 1\n                End\n            When curr_token = \"NOFLUSH\"\n              Then\n                Do\n                Call Put_Msg \"Warning: CONTROL\" curr_token,\n                     \"at input line\" input_line_number,\n                     \"not translateable by\" cmd_name\".\"\n                Call Put_Stmt \"sysflush = 'OFF' /*!*/\"\n                must_define.sysflush = 1\n                End\n            When curr_token = \"CAPS\"\n              Then\n                Do\n                Call Put_Msg \"Warning: CONTROL\" curr_token,\n                     \"at input line\" input_line_number,\n                     \"not translateable by\" cmd_name\".\"\n                Call Put_Stmt \"sysasis = 'OFF' /*!*/\"\n                must_define.sysasis = 1\n                End\n            When curr_token = \"NOCAPS\"\n              Then\n                Do\n                Call Put_Stmt \"sysasis = 'ON'\"\n                must_define.sysasis = 1\n                End\n            When curr_token = \"ASIS\"\n              Then\n                Do\n                Call Put_Stmt \"sysasis = 'ON'\"\n                must_define.sysasis = 1\n                End\n            When curr_token = \"MAIN\"\n              Then\n                Do\n                Call Put_Msg \"Warning: CONTROL\" curr_token,\n                    \"at input line\" input_line_number,\n                    \"not translateable by\" cmd_name\".\"\n                Call Put_Stmt \"/*!CONTROL MAIN*/\"\n                End\n            When curr_token = \"END\"\n              Then\n                Do\n                Call Put_Msg \"Warning: CONTROL\" curr_token,\n                    \"at input line\" input_line_number,\n                    \"not translateable by\" cmd_name\".\"\n                Call Put_Stmt \"/*!CONTROL END*/\"\n                End\n            Otherwise\n                Call Put_Msg \"Warning: CONTROL\" curr_token,\n                             \"at input line\",\n                     input_line_number \"not recognized by\" cmd_name\".\"\n            End\n          Call Get_NonBlank_Token\n          End\n        If list_option_set\n          Then\n            Do\n            control_list_stmt_used = 1\n            Call Put_Stmt \"Call check_control_options\"\n            Call Put_Stmt \"trace value control_options_value\"\n            End\n        Call Put_Stmt \"End\"\n        Call Get_Stmt\n        End\n\n    When verb = \"DATA\"\n      Then\n        Do\n        Call Get_NonBlank_Token\n        save_token = curr_token\n        Call Put_Stmt \"Do \"\n        Call Get_Stmt\n        Do while verb \u00ac= \"ENDDATA\",\n          & input_line_number <= numlines\n          Call Put_Indent\n          If save_token = \"PROMPT\"\n            Then\n              Call Put_Token \"Queue '\"verb\" \"\n            Else\n              Call Put_Token \"Address TSO \"\n          Call Get_Token\n          Call Parse_Expression \"q\"\n          Call Put_Line\n          Call Get_Stmt\n          End\n        Call Put_Indent\n        Call Put_Token \"End \"\n        Call Get_Token\n        Call Parse_Expression\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"DO\"\n      Then\n        Do\n        Call Put_Indent\n        Call Put_Token \"Do\"\n        Call Get_Token\n        Do while curr_token_type = \"<comment>\",\n          | curr_token_type = \"<blanks>\"\n          Call Put_Token curr_token\n          Call Get_Token\n          End\n        If next_token_type = \"<eos>\"\n          Then\n            Do\n            Call Get_Token\n            Call Parse_Expression\n            Call Put_Line\n            Call Get_Stmt\n            Do while verb \u00ac= \"END\",\n              & input_line_number <= numlines\n              Call Parse_Stmt\n              End\n            Call Put_Indent\n            Call Put_Token \"End \"\n            Call Get_Token\n            Call Parse_Expression\n            Call Put_Line\n            Call Get_Stmt\n            End\n          Else\n            Do\n            If  curr_token \u00ac= \"WHILE\",\n              & curr_token \u00ac= \"UNTIL\",\n              Then\n                Do\n                Call Put_Indent\n                If left(curr_token,1) = \"&\"\n                  Then\n                    curr_token = substr(curr_token,2)\n                Call Put_Token curr_token\" \"\n                Call Get_Token\n                Call Parse_Expression \"\",\"Do_i\"\n                If curr_token = \"TO\"\n                  Then\n                    Do\n                    Call Put_Token \"to \"\n                    Call Get_Token\n                    Call Parse_Expression \"\",\"Do_to\"\n                    End\n                If curr_token = \"BY\"\n                  Then\n                    Do\n                    Call Put_Token \"by \"\n                    Call Get_Token\n                    Call Parse_Expression \"\",\"Do_by\"\n                    End\n                End\n            Do 2\n              If  curr_token = \"WHILE\",\n                | curr_token = \"UNTIL\",\n                Then\n                  Do\n                  If curr_token = \"WHILE\"\n                    Then\n                      Call Put_Token \"while \"\n                    Else\n                      Call Put_Token \"until \"\n                  Call Get_Token\n                  Call Parse_Expression \"\",\"Do_while\"\n                  End\n              End\n            Call Put_Line\n            indent = indent + 2\n            Call Get_Stmt\n            Do while verb \u00ac= \"END\",\n              & input_line_number <= numlines\n              Call Parse_Stmt\n              End\n            Call Put_Indent\n            Call Put_Token \"End \"\n            Call Get_Token\n            Call Parse_Expression\n            Call Put_Line\n            Call Get_Stmt\n            indent = indent - 2\n            End\n        End\n\n    When verb = \"END\"\n      Then\n        Do\n        if test_mode >= 2\n          then\n            say 'Verb=END'\n        Call Put_Indent\n        Call Put_Token \"Exit \"\n        Call Get_Token\n        Call Parse_Expression\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"ERROR\"\n      Then\n        Do\n        Call Put_Msg \"Warning:\" verb \"at input line\",\n             input_line_number \"not translateable by\" cmd_name\".\"\n        Call Put_Token \"/*!\"\n        Call Put_Indent\n        Call Put_Token verb||\" \"\n        Call Get_Token\n        Call Parse_Expression\n        Call Put_Token \"*/\"\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"EXIT\"\n      Then\n        Do\n        Call Put_Indent\n        Call Put_Token \"Exit \"\n        Call Get_NonBlank_Token\n        If curr_token = \"CODE\"\n          Then\n            Do\n            Call Get_Token\n            Call Parse_Expression\n            End\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"GETFILE\"\n      Then\n        Do\n        Call Get_Token\n        Call Get_Token\n        Call Put_Indent\n        Call Put_Token 'Address TSO \"EXECIO * DISKR '\n        If curr_token_type = \"<variable>\"\n          Then\n            Call Put_Token '\"'substr(curr_token,2)'\"'\n          Else\n            Call Put_Token curr_token\n        Call Put_Token ' (CASE M\"'\n        Call Put_Line\n        Call Put_Indent\n        If curr_token_type = \"<variable>\"\n          Then\n            Do\n            Call Put_Token 'Interpret \"Parse pull\" '\n            Call Put_Token substr(curr_token,2)\n            End\n          Else\n            Do\n            Call Put_Token \"Parse pull \"\n            Call Put_Token curr_token\n            End\n        Call Put_Line\n        Call Get_Token\n        Call Get_Stmt\n        End\n\n    When verb = \"GLOBAL\"\n      Then\n        Do\n        Call Put_Msg \"Warning:\" verb \"at input line\",\n             input_line_number \"not translateable by\" cmd_name\".\"\n        Call Put_Token \"/*!\"\n        Call Put_Indent\n        Call Put_Token verb||\" \"\n        Call Get_Token\n        Call Parse_Expression\n        Call Put_Token \"*/\"\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"NGLOBAL\"\n      Then\n        Do\n        Call Put_Msg \"Warning:\" verb \"at input line\",\n             input_line_number \"not translateable by\" cmd_name\".\"\n        Call Put_Token \"/*!\"\n        Call Put_Indent\n        Call Put_Token verb||\" \"\n        Call Get_Token\n        Call Parse_Expression\n        Call Put_Token \"*/\"\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"GOTO\"\n      Then\n        Do\n        Call Put_Msg \"Warning:\" verb \"at input line\",\n             input_line_number \"translated to SIGNAL.\"\n        Call Put_Token \"/*!*/\"\n        Call Put_Indent\n        Call Put_Token \"SIGNAL \"\n        Call Get_Token\n        Do while curr_token_type \u00ac= \"<eos>\"\n          If curr_token_type = \"<keyword>\",\n            & find(label_list,curr_token) \u00ac= 0,\n            Then\n              Call Put_Msg \"Warning: label\" curr_token,\n                           \"is already defined.  SIGNAL will fail.\"\n          Call Put_Token curr_token\n          Call Get_Token\n          End\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"IF\"\n      Then\n        Do\n        Call Put_Indent\n        Call Put_Token \"If \"\n        Call Get_Token\n        Call Parse_Expression \"\",\"If\"\n        Call Put_Line\n        indent = indent + 2\n        Call Put_Stmt \"Then \"\n        indent = indent + 2\n        Call Get_NonBlank_Token\n        verb = translate(curr_token)\n        Call Parse_Stmt\n        indent = indent - 2\n        If verb = \"ELSE\"\n          Then\n            Do\n            Call Put_Stmt \"Else \"\n            indent = indent + 2\n            Call Get_NonBlank_Token\n            verb = translate(curr_token)\n            Call Parse_Stmt\n            indent = indent - 2\n            End\n        indent = indent - 2\n        End\n\n    When verb = \"ISPEXEC\"\n      Then\n        Do\n        Call Put_Indent\n        Call Put_Token \"Address ISPEXEC \"\n        Call Get_Token\n        Call Parse_Expression \"q\"\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"ISREDIT\"\n      Then\n        Do\n        pdf_edit_macro_found = 1\n        Call Put_Indent\n        Call Put_Token \"ISREDIT \"\n        Call Get_Token\n        Call Parse_Expression \"q\"\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"LISTDSI\"\n      Then\n        Do\n        Call Put_Indent\n        Call Put_Token \"Call ListDSI \"\n        Call Get_Token\n        Call Parse_Expression \"q\"\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"OPENFILE\"\n      Then\n        Do\n        Call Put_Indent\n        Call Put_Token \"Nop\"\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"PUTFILE\"\n      Then\n        Do\n        Call Get_Token\n        Call Get_Token\n        Call Put_Indent\n        If curr_token_type = \"<variable>\"\n          Then\n            Do\n            Call Put_Token 'Interpret \"queue\" '\n            Call Put_Token substr(curr_token,2)\n            End\n          Else\n            Do\n            Call Put_Token \"queue \"\n            Call Put_Token curr_token\n            End\n        Call Put_Line\n        Call Put_Indent\n        Call Put_Token 'Address TSO \"EXECIO * DISKW '\n        If curr_token_type = \"<variable>\"\n          Then\n            Call Put_Token '\"'substr(curr_token,2)'\"'\n          Else\n            Call Put_Token curr_token\n        Call Put_Token ' (CASE M\"'\n        Call Put_Line\n        Call Get_Token\n        Call Get_Stmt\n        End\n\n    When verb = \"READ\"\n      Then\n        Do\n        parse_string = \"\"\n        Do while next_token_type \u00ac= \"<eos>\"\n          Call Get_NonBlank_Token\n          If curr_token = \",\"\n            Then\n              parse_string = parse_string \".\"\n            Else\n              parse_string = parse_string curr_token\n          End\n        If parse_string \u00ac= \"\"\n          Then\n            Do\n            Call Put_Stmt \"Parse upper pull sysdval_temp\"\n            Call Put_Stmt \"Parse var sysdval_temp\"parse_string \".\"\n            End\n          Else\n            Call Put_Stmt \"Parse upper pull sysdval\"\n        must_define.sysdval = 1\n        Call Get_Stmt\n        End\n\n    When verb = \"READDVAL\"\n      Then\n        Do\n        parse_string = \"\"\n        Do while next_token_type \u00ac= \"<eos>\"\n          Call Get_NonBlank_Token\n          If curr_token = \",\"\n            Then\n              parse_string = parse_string \".\"\n            Else\n              parse_string = parse_string curr_token\n          End\n        If parse_string \u00ac= \"\"\n          Then\n            Do\n            Call Put_Stmt \"Parse var sysdval\"parse_string \".\"\n            End\n        must_define.sysdval = 1\n        Call Get_Stmt\n        End\n\n    When verb = \"RETURN\"\n      Then\n        Do\n        Call Put_Indent\n        Call Put_Token \"Return \"\n        Call Get_NonBlank_Token\n        If curr_token = \"CODE\"\n          Then\n            Do\n            Call Get_Token\n            Call Parse_Expression\n            End\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"SELECT\"\n      Then\n        Do\n        Call Put_Indent\n        Call Put_Token \"Select \"\n        Call Get_Token\n        Do while curr_token_type = \"<comment>\",\n          | curr_token_type = \"<blanks>\"\n          Call Put_Token curr_token\n          Call Get_Token\n          End\n        Call Get_Token\n        Call Parse_Expression\n        Call Put_Line\n        indent = indent + 2\n        Call Get_Stmt\n        Do while verb \u00ac= \"END\",\n          & input_line_number <= numlines\n          Call Parse_Stmt\n          End\n        Call Put_Indent\n        Call Put_Token \"End \"\n        Call Get_Token\n        Call Parse_Expression\n        Call Put_Line\n        Call Get_Stmt\n        indent = indent - 2\n        End\n\n    When verb = \"SET\"\n      Then\n        Do\n        Call Get_NonBlank_Token\n        If left(curr_token,1) = \"&\"\n          Then\n            curr_token = substr(curr_token,2)\n        Call Put_Indent\n        curr_token = translate(curr_token,,\n                               \"abcdefghijklmnopqrstuvwxyz\",,\n                               \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n        Call Put_Token curr_token||\" \"\n        Call Get_NonBlank_Token\n        Call Put_Token curr_token||\" \"\n        If next_token_type = \"<eos>\"\n          Then\n            Do\n            Call Get_NonBlank_Token\n            Call Put_Token '\"\"'\n            End\n          Else\n            Do\n            Call Get_Token\n            Call Parse_Expression\n            End\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"SYSCALL\"\n      Then\n        Do\n        Call Get_NonBlank_Token\n        Call Put_Indent\n        curr_token = translate(curr_token,,\n                               \"abcdefghijklmnopqrstuvwxyz\",,\n                               \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n        Call Put_Token \"Call\" curr_token||\" \"\n        Call Get_Token\n        Call Parse_Expression\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"SYSREF\"\n      Then\n        Do\n        Call Put_Msg \"Warning:\" verb \"at input line\",\n             input_line_number \"not translateable by\" cmd_name\".\"\n        Call Put_Token \"/*!\"\n        Call Put_Indent\n        Call Put_Token verb||\" \"\n        Call Get_Token\n        Call Parse_Expression\n        Call Put_Token \"*/\"\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"TERMIN\"\n      Then\n        Do\n        parse_string = \"\"\n        Do while next_token_type \u00ac= \"<eos>\"\n          Call Get_NonBlank_Token\n          If curr_token = \",\"\n            Then\n              parse_string = parse_string \".\"\n            Else\n              parse_string = parse_string curr_token\n          End\n        Call Put_Stmt \"Parse upper pull sysdval\"\n        Call Put_Stmt \"Parse var sysdval sysdlm sysdval\"\n        Call Put_Stmt 'If sysdlm = \"\"'\n        Call Put_Stmt \"  Then\"\n        Call Put_Stmt '     sysdlm = \",\"'\n        Call Put_Stmt 'sysdlm = find(\"'parse_string'\",sysdlm)'\n        Call Get_Stmt\n        must_define.sysdval = 1\n        End\n\n    When verb = \"WHEN\"\n      Then\n        Do\n        Call Put_Indent\n        Call Put_Token \"When \"\n        Call Get_Token\n        Call Parse_Expression \"\",\"When\"\n        Call Put_Line\n        indent = indent + 2\n        Call Put_Stmt \"Then \"\n        indent = indent + 2\n        Call Get_NonBlank_Token\n        verb = translate(curr_token)\n        Call Parse_Stmt\n        indent = indent - 2\n        indent = indent - 2\n        End\n\n    When verb = \"WRITE\" | verb = \"WRITENR\"\n      Then\n        Do\n        Call Put_Indent\n        Call Put_Token \"Say \"\n        Call Get_Token\n        Call Parse_Expression\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When curr_token_type = \"<comment>\"\n      Then\n        Do\n        Call Put_Stmt curr_token\n        Call Get_NonBlank_Token\n        verb = translate(curr_token)\n        Call Parse_Stmt\n        End\n\n    When curr_token_type = \"<eos>\"\n      Then\n        Do\n        Call Get_Stmt\n        End\n\n    When verb = \"\"\n      Then\n        Do\n        Call Get_Stmt\n        End\n\n    Otherwise\n        Call Put_Indent\n        Call Put_Token \"Address TSO \"\n        Call Parse_Expression\n        Call Put_Line\n        Call Get_Stmt\n    End\n  Return 0\n/**********************************************************************/\n/*** Parse_Expression:                                              ***/\n/***   Subroutine to parse a single CLIST expression, and translate ***/\n/***   it to REXX.                                                  ***/\n/***                                                                ***/\n/***   Parameters:                                                  ***/\n/***     1. \"q\" = the expression is a character expression, and     ***/\n/***              its REXX equivalent should be in quotes.          ***/\n/***        \"nq\" = the expression is not a character expression.    ***/\n/***              This is the default.                              ***/\n/***                                                                ***/\n/***     2. \"\"  = the expression is the right side of an assignment ***/\n/***              statement.                                        ***/\n/***        \"If\" = the epression is part of an If statement and     ***/\n/***               may be terminated by a THEN clause.              ***/\n/***        \"Do_i\" = the expression is the starting point of a      ***/\n/***               repetetive DO (DO I = <expr> TO 5) and may       ***/\n/***               be terminated by a TO clause.                    ***/\n/***        \"Do_to\" = the expression is the ending point of a       ***/\n/***               repetetive DO (DO I = 1 TO <expr>) and may       ***/\n/***               be terminated by a BY, WHILE, or UNTIL clause.   ***/\n/***        \"Do_by\" = the expression is the increment of a          ***/\n/***               repetetive DO (DO I = 1 TO 9 BY <expr>) and may  ***/\n/***               be terminated by a WHILE or UNTIL clause.        ***/\n/***        \"Do_while\" = the expression is the terminator (WHILE    ***/\n/***               or UNTIL clause) of a repetetive DO.             ***/\n/***        \"When\" = the expression is part of a When statement.    ***/\n/***        \"parm\" = the expression is a function paramater and     ***/\n/***               may be terminated by a comma or right            ***/\n/***               parenthesis.  If this parameter is specified,    ***/\n/***               a third parameter, the name of the function,     ***/\n/***               is also specified.                               ***/\n/***                                                                ***/\n/**********************************************************************/\nParse_Expression: Procedure expose curr_token,\n                             curr_token_type,\n                             next_token,\n                             next_token_type,\n                             token_offset,\n                             first_token,\n                             curr_stmt,\n                             curr_char,\n                             next_char,\n                             test_mode,\n                             expr_depth,\n                             numlines,\n                             input_line_number,\n                             cmd_name,\n                             output_recd,\n                             output_line_type.,\n                             output_line.,\n                             output_line_number,\n                             quote_mode,\n                             must_define.,\n                             new_exp,\n                             verb,\n                             lrecl,\n                             label_list,\n                             pdf_edit_macro_found,\n                             control_stmt_used,\n                             control_list_stmt_used,\n                             first_proc_stmt_found,\n                             indent,\n                             isredit\n  expr_depth = expr_depth + 1\n  If test_mode >= 2\n    Then\n      Do\n      Say\n      Say \"Parse_Exp\" copies(\"--\",expr_depth) arg(1)\",\" arg(2)\",\",\n           arg(3)\",\" curr_token_type\", \"curr_token\n      End\n  quote_mode = \"nq\"\n  If arg(1) = \"q\"\n    Then\n      numeric_expression = 0\n    Else\n      numeric_expression = 1\n  If_mode = 0\n  Do_i_mode = 0\n  Do_to_mode = 0\n  Do_by_mode = 0\n  Do_while_mode = 0\n  When_mode = 0\n  parm_mode = 0\n  assignment_mode = 0\n  Select\n    When arg(2) = \"If\"\n      Then\n        If_mode = 1\n    When arg(2) = \"Do_i\"\n      Then\n        Do_i_mode = 1\n    When arg(2) = \"Do_to\"\n      Then\n        Do_to_mode = 1\n    When arg(2) = \"Do_by\"\n      Then\n        Do_by_mode = 1\n    When arg(2) = \"Do_while\"\n      Then\n        Do_while_mode = 1\n    When arg(2) = \"When\"\n      Then\n        When_mode = 1\n    When arg(2) = \"parm\"\n      Then\n        parm_mode = 1\n    Otherwise\n        assignment_mode = 1\n    End\n  paren_depth = 0\n  If \u00acparm_mode\n    Then\n      new_exp = \"\"\n  token_num = 0\n  Do while \u00ac((curr_token_type = \"<eos>\"),\n    | (next_token_type = \"<eos>\" & token_num \u00ac= 0))\n    If token_num \u00ac= 0\n      Then\n        Call Get_Token\n    token_num = token_num + 1\n    If \u00acparm_mode\n      Then\n        Do while token_num = 1 & curr_token_type = \"<blanks>\"\n          If test_mode >= 2\n            Then\n              Say \"Skip_Term\" copies(\"--\",expr_depth),\n                  format(token_num,6),\n                  left(curr_token_type,16) curr_token\n          Call Get_Token\n          End\n    If test_mode >= 2\n      Then\n        Say \"Get_Term \" copies(\"--\",expr_depth) format(token_num,6),\n            left(curr_token_type,16) curr_token\n    Select\n      When curr_token_type = \"<comment>\"\n        Then\n          Do\n          Call End_Quote_Mode\n          new_exp = new_exp||curr_token\n          End\n      When curr_token_type = \"<integer>\",\n        |  curr_token_type = \"<number>\",\n        Then\n          Do\n          Call Check_Concat_Needed\n          new_exp = new_exp||curr_token\n          End\n      When curr_token_type = \"<variable>\"\n        Then\n          Do\n          Call Check_Concat_Needed\n          curr_token = substr(curr_token,2)\n          Call End_Quote_Mode\n          Select\n            When curr_token = \"sysdate\"\n              Then\n                curr_token = 'date(\"u\")'\n            When curr_token = \"syssdate\"\n              Then\n                curr_token = 'date(\"o\")'\n            When curr_token = \"sysjdate\"\n              Then\n                curr_token = 'left(date(\"o\"),2)\".\"date(\"d\")'\n            When curr_token = \"systime\"\n              Then\n                curr_token = \"time()\"\n            When curr_token = \"sysstime\"\n              Then\n                curr_token = \"left(time(),5)\"\n            When curr_token = \"syslterm\"\n              Then\n                curr_token = \"SysVar('SysLTerm')\"\n            When curr_token = \"syswterm\"\n              Then\n                curr_token = \"SysVar('SysWTerm')\"\n            When curr_token = \"sysuid\"\n              Then\n                curr_token = \"userid()\"\n            When curr_token = \"syspref\"\n              Then\n                curr_token = \"SysVar('SysPref')\"\n            When curr_token = \"sysproc\"\n              Then\n                curr_token = \"SysVar('SysProc')\"\n            When curr_token = \"syscpu\"\n              Then\n                curr_token = \"SysVar('SysCPU')\"\n            When curr_token = \"syssrv\"\n              Then\n                curr_token = \"SysVar('SysSrv')\"\n            When curr_token = \"sysispf\"\n              Then\n                curr_token = \"SysVar('SysISPF')\"\n            When curr_token = \"sysracf\"\n              Then\n                curr_token = \"SysVar('SysRACF')\"\n            When curr_token = \"syslracf\"\n              Then\n                curr_token = \"SysVar('SysLRACF')\"\n            When curr_token = \"syshsm\"\n              Then\n                curr_token = \"SysVar('SysHSM')\"\n            When curr_token = \"systsoe\"\n              Then\n                curr_token = \"SysVar('SysTSOE')\"\n            When curr_token = \"sysenv\"\n              Then\n                curr_token = \"SysVar('SysEnv')\"\n            When curr_token = \"sysscan\"\n              Then\n                curr_token = \"1\"\n            When curr_token = \"sysicmd\"\n              Then\n                curr_token = \"SysVar('SysICmd')\"\n            When curr_token = \"syspcmd\"\n              Then\n                curr_token = \"SysVar('SysPCmd')\"\n            When curr_token = \"sysscmd\"\n              Then\n                curr_token = \"SysVar('SysSCmd')\"\n            When curr_token = \"sysnest\"\n              Then\n                curr_token = \"SysVar('SysNest')\"\n            When curr_token = \"sysprompt\"\n              Then\n                Do\n                curr_token = curr_token\n                must_define.sysprompt = 1\n                End\n            When curr_token = \"syssymlist\"\n              Then\n                Do\n                curr_token = curr_token\n                must_define.syssymlist = 1\n                End\n            When curr_token = \"sysconlist\"\n              Then\n                Do\n                curr_token = curr_token\n                must_define.sysconlist = 1\n                End\n            When curr_token = \"syslist\"\n              Then\n                Do\n                curr_token = curr_token\n                must_define.syslist = 1\n                End\n            When curr_token = \"sysasis\"\n              Then\n                Do\n                curr_token = curr_token\n                must_define.sysasis = 1\n                End\n            When curr_token = \"sysmsg\"\n              Then\n                Do\n                curr_token = curr_token\n                must_define.sysmsg = 1\n                End\n            When curr_token = \"sysflush\"\n              Then\n                Do\n                curr_token = curr_token\n                must_define.sysflush = 1\n                End\n            When curr_token = \"sysdlm\"\n              Then\n                curr_token = curr_token\n            When curr_token = \"sysdval\"\n              Then\n                Do\n                curr_token = curr_token\n                must_define.sysdval = 1\n                End\n            When curr_token = \"sysouttrap\"\n              Then\n                Do\n                curr_token = \"sysouttrap()\"\n                must_define.sysouttrap = 1\n                End\n            When left(curr_token,10) = \"sysoutline\"\n              Then\n                Do\n                curr_token = \"sysoutline()\"\n                must_define.sysoutline = 1\n                End\n            When curr_token = \"lastcc\"\n              Then\n                curr_token = \"rc\"\n            When curr_token = \"maxcc\"\n              Then\n                Do\n                Call Put_Msg \"Warning: &\"curr_token \"at input line\",\n                     input_line_number \"not translateable by\",\n                     cmd_name\".\"\n                curr_token = \"/*!*/\"curr_token\n                End\n            When curr_token = \"sysabncd\"\n              Then\n                curr_token = curr_token\n            When curr_token = \"sysabnrc\"\n              Then\n                curr_token = curr_token\n            When curr_token = \"syscmdrc\"\n              Then\n                curr_token = curr_token\n            /* begin parseing functions */\n            When curr_token = \"datatype\"\n              Then\n                Call Parse_Function\n            When curr_token = \"eval\"\n              Then\n                Do\n                Call Parse_Function\n                must_define.eval = 1\n                End\n            When curr_token = \"length\"\n              Then\n                Call Parse_Function\n            When curr_token = \"nrstr\"\n              Then\n                Do\n                Call Put_Msg \"Warning: &\"curr_token \"at input line\",\n                     input_line_number \"not translateable by\",\n                     cmd_name\".\"\n                Call Parse_NOP_Function\n                End\n            When curr_token = \"str\"\n              Then\n                Call Parse_NOP_Function\n            When curr_token = \"substr\"\n              Then\n                Do\n                curr_token = \"substrc\"\n                Call Parse_Function\n                must_define.substrc = 1\n                End\n            When curr_token = \"syscaps\"\n              Then\n                Do\n                curr_token = \"translate\"\n                Call Parse_Function\n                End\n            When curr_token = \"syslc\"\n              Then\n                Do\n                Call Parse_Function\n                must_define.syslc = 1\n                End\n            When curr_token = \"sysdsn\"\n              Then\n                Call Parse_Function\n            When curr_token = \"sysindex\"\n              Then\n                Do\n                curr_token = \"pos\"\n                Call Parse_Function\n                End\n            When curr_token = \"sysnsub\"\n              Then\n                Do\n                Call Put_Msg \"Warning: &\"curr_token \"at input line\",\n                     input_line_number \"not translateable by\",\n                     cmd_name\".\"\n                Call Parse_Function\n                must_define.sysnsub = 1\n                End\n            When curr_token = \"sysonebyte\"\n              Then\n                Do\n                curr_token = \"dbtosbcs\"\n                Call Parse_Function\n                End\n            When curr_token = \"systwobyte\"\n              Then\n                Do\n                curr_token = \"dbtodbcs\"\n                Call Parse_Function\n                End\n            When curr_token = \"sysclength\"\n              Then\n                Do\n                curr_token = \"length\"\n                Call Parse_Function\n                End\n            When curr_token = \"syscsubstr\"\n              Then\n                Do\n                curr_token = \"substrc\"\n                Call Parse_Function\n                must_define.substrc = 1\n                End\n            Otherwise\n                curr_token = curr_token\n            End\n          new_exp = new_exp||curr_token\n          End\n      When curr_token_type = \"<keyword>\"\n        Then\n          Do\n          Select\n            When (If_mode | Do_while_mode),\n              & (curr_token = \"OR\",\n               | curr_token = \"AND\",\n               | curr_token = \"EQ\",\n               | curr_token = \"NE\",\n               | curr_token = \"LT\",\n               | curr_token = \"GT\",\n               | curr_token = \"LE\",\n               | curr_token = \"GE\",\n               | curr_token = \"NG\",\n               | curr_token = \"NL\"),\n              Then\n                Do\n                Call End_Quote_Mode\n                Select\n                  When curr_token = \"OR\",\n                    Then\n                      curr_token = \"|\"\n                  When curr_token = \"AND\",\n                    Then\n                      curr_token = \"&\"\n                  When curr_token = \"EQ\",\n                    Then\n                      curr_token = \"=\"\n                  When curr_token = \"NE\",\n                    Then\n                      curr_token = \"\u00ac=\"\n                  When curr_token = \"LT\",\n                    Then\n                      curr_token = \"<\"\n                  When curr_token = \"GT\",\n                    Then\n                      curr_token = \">\"\n                  When curr_token = \"LE\",\n                    Then\n                      curr_token = \"<=\"\n                  When curr_token = \"GE\",\n                    Then\n                      curr_token = \">=\"\n                  When curr_token = \"NG\",\n                    Then\n                      curr_token = \"<=\"\n                  When curr_token = \"NL\",\n                    Then\n                      curr_token = \">=\"\n                  Otherwise\n                      Nop\n                  End\n                End\n            When If_mode & curr_token = \"THEN\"\n              Then\n                Leave\n            When Do_i_mode & curr_token = \"TO\"\n              Then\n                Leave\n            When Do_to_mode & find(\"BY WHILE UNTIL\",curr_token) \u00ac= 0\n              Then\n                Leave\n            When Do_by_mode & find(\"WHILE UNTIL\",curr_token) \u00ac= 0\n              Then\n                Leave\n            When Do_while_mode & find(\"WHILE UNTIL\",curr_token) \u00ac= 0\n              Then\n                Leave\n            Otherwise\n                Call Start_Quote_Mode\n                numeric_expression = 0\n            End\n          new_exp = new_exp||curr_token\n          End\n      When curr_token_type = \"<blanks>\"\n        Then\n          Do\n          If parm_mode\n            Then\n              Do\n              Call Start_Quote_Mode\n              numeric_expression = 0\n              End\n          new_exp = new_exp||curr_token\n          End\n      When curr_token = \":\",\n        & parm_mode,\n        & paren_depth = 0,\n        & arg(3) = \"substrc\",\n        Then\n          Do\n          Call end_quote_mode\n          curr_token = \",\"\n          curr_token_type = \"<special_char>\"\n          Leave\n          End\n      When curr_token = \",\",\n        & parm_mode,\n        & paren_depth = 0,\n        Then\n          Do\n          Call end_quote_mode\n          Leave\n          End\n      When curr_token = \")\",\n        & parm_mode,\n    /*  & paren_depth <= 0, */\n        Then\n          Do\n          Call end_quote_mode\n          Leave\n          End\n      Otherwise\n        Select\n          When curr_token = \"(\"\n            Then\n              Do\n              If parm_mode | When_mode\n                Then\n                  paren_depth = paren_depth+1\n              If \u00acnumeric_expression\n                Then\n                  Call Start_Quote_Mode\n              End\n          When curr_token = \")\"\n            Then\n              Do\n              If parm_mode\n                Then\n                  paren_depth = paren_depth-1\n              If \u00acnumeric_expression\n                Then\n                  Call Start_Quote_Mode\n              If When_mode\n                Then\n                  Do\n                  new_exp = new_exp||curr_token\n                  paren_depth = paren_depth-1\n                  If paren_depth <= 0\n                    Then\n                      Leave\n                  End\n              End\n          When curr_token_type = \"<operator>\"\n            Then\n              Do\n              Select\n                When curr_token = \"/\" & numeric_expression\n                  Then\n                    curr_token = \"%\"\n                When Do_while_mode,\n                  |If_mode,\n                  |(assignment_mode,\n                    & (find(\"= < > <= >= \u00ac=\",curr_token) = 0)),\n                  & numeric_expression\n                  Then\n                    Call End_Quote_Mode\n                When \u00acnumeric_expression\n                  Then\n                    Call Start_Quote_mode\n                Otherwise\n                    Nop\n                End\n              End\n          When curr_token_type = \"<special_char>\"\n            Then\n              Do\n              Call Start_Quote_Mode\n              numeric_expression = 0\n              If curr_token = '\"',\n                Then\n                  curr_token = curr_token||curr_token\n              End\n          Otherwise\n              Do\n              Call Put_Msg \"Error:   \"curr_token_type,\n                           \"at input line\" input_line_number,\n                           \"not expected.\"\n              Call Start_Quote_Mode\n              numeric_expression = 0\n              End\n          End\n        new_exp = new_exp||curr_token\n      End\n    End\n  Call End_Quote_Mode\n  If \u00acparm_mode\n    Then\n      Call Put_Token new_exp\n  If test_mode >= 2\n    Then\n      Do\n      Say \"End_Exp  \" copies(\"--\",expr_depth) arg(1)\",\" arg(2)\",\" arg(3)\n      Say\n      End\n  expr_depth = expr_depth - 1\n  Return 0\n\n/**********************************************************************/\n/*** Parse_Function:                                                ***/\n/***   Subroutine to parse a single CLIST function, and translate   ***/\n/***   it to REXX.                                                  ***/\n/**********************************************************************/\nParse_Function: Procedure expose curr_token,\n                             curr_token_type,\n                             next_token,\n                             next_token_type,\n                             token_offset,\n                             first_token,\n                             curr_stmt,\n                             curr_char,\n                             next_char,\n                             test_mode,\n                             expr_depth,\n                             numlines,\n                             input_line_number,\n                             cmd_name,\n                             output_recd,\n                             output_line_type.,\n                             output_line.,\n                             output_line_number,\n                             quote_mode,\n                             must_define.,\n                             new_exp,\n                             verb,\n                             lrecl,\n                             label_list,\n                             pdf_edit_macro_found,\n                             control_stmt_used,\n                             control_list_stmt_used,\n                             first_proc_stmt_found,\n                             indent,\n                             isredit\n  function_name = curr_token\n  new_exp = new_exp||curr_token\n  Call Get_Token\n  new_exp = new_exp||curr_token\n  Do forever\n    Call Get_Token\n    Call Parse_Expression \"\",\"parm\",function_name\n    new_exp = new_exp||curr_token\n    If curr_token = \")\"\n      Then\n        Do\n        curr_token = \"\"\n        curr_token_type = \"<blanks>\"\n        Leave\n        End\n    End\n  Return 0\n\n/**********************************************************************/\n/*** Parse_NOP_Function:                                            ***/\n/***   Subroutine to parse a CLIST functions that don't Do anything ***/\n/***   in the REXX world (like &STR), and ignore it.                ***/\n/**********************************************************************/\nParse_NOP_Function: Procedure expose curr_token,\n                             curr_token_type,\n                             next_token,\n                             next_token_type,\n                             token_offset,\n                             first_token,\n                             curr_stmt,\n                             curr_char,\n                             next_char,\n                             test_mode,\n                             expr_depth,\n                             numlines,\n                             input_line_number,\n                             cmd_name,\n                             output_recd,\n                             output_line_type.,\n                             output_line.,\n                             output_line_number,\n                             quote_mode,\n                             must_define.,\n                             new_exp,\n                             verb,\n                             lrecl,\n                             label_list,\n                             pdf_edit_macro_found,\n                             control_stmt_used,\n                             control_list_stmt_used,\n                             first_proc_stmt_found,\n                             indent,\n                             isredit\n  function_name = curr_token\n  Call Get_Token\n  If curr_char \u00ac= \")\"\n    Then\n      Do\n      Call Get_Token\n      Call Parse_Expression \"q\",\"parm\",function_name\n      End\n    Else\n      Do\n      Call Get_Token\n      Call Start_Quote_Mode\n      End\n  curr_token = \"\"\n  curr_token_type = \"<blanks>\"\n  Return 0\n\n/**********************************************************************/\n/*** Get_Char:                                                      ***/\n/***   Subroutine to get one character from the input stream.       ***/\n/**********************************************************************/\nGet_Char:\n  token_offset = token_offset + 1\n  If token_offset > length(curr_stmt)\n    Then\n      curr_char = \";\"\n    Else\n      curr_char = substr(curr_stmt,token_offset,1)\n  Return 0\n\n/**********************************************************************/\n/*** Get_NonBlank_Token:                                            ***/\n/***   Subroutine to get one non-blank token from the input stream. ***/\n/**********************************************************************/\nGet_NonBlank_Token:\n  Call Get_Token\n  Do while curr_token_type = \"<blanks>\"\n    Call Get_Token\n    End\n  Return 0\n\n/**********************************************************************/\n/*** Get_Token:                                                     ***/\n/***   Subroutine to get one token from the input stream.           ***/\n/***   The token may be blank.                                      ***/\n/**********************************************************************/\nGet_Token:\n  If token_offset = 0\n    Then\n      Do\n      Call Get_Char\n      End\n  If token_offset > length(curr_stmt)\n    Then\n      Do\n      curr_token_type = \"<eos>\"\n      next_token_type = \"<eos>\"\n      curr_token = \";\"\n      next_token = \";\"\n      Return 0\n      End\n  curr_token = \"\"\n  curr_token_type = \"<?>\"\n  Select\n    When (\"0\" <= curr_char & curr_char <= \"9\"),\n      Then\n        Do\n        curr_token_type = \"<integer>\"\n        Do while (\"0\" <= curr_char & curr_char <= \"9\")\n          curr_token = curr_token||curr_char\n          Call Get_Char\n          End\n        If curr_char = \".\"\n          Then\n            Do\n            curr_token_type = \"<number>\"\n            curr_token = curr_token||curr_char\n            Call Get_Char\n            Do while (\"0\" <= curr_char & curr_char <= \"9\")\n              curr_token = curr_token||curr_char\n              Call Get_Char\n              End\n            End\n        End\n    When (\"A\" <= curr_char & curr_char <= \"I\"),\n      |  (\"J\" <= curr_char & curr_char <= \"R\"),\n      |  (\"S\" <= curr_char & curr_char <= \"Z\"),\n      |  (\"a\" <= curr_char & curr_char <= \"i\"),\n      |  (\"j\" <= curr_char & curr_char <= \"r\"),\n      |  (\"s\" <= curr_char & curr_char <= \"z\"),\n      |  curr_char = \"%\",\n      |  curr_char = \"$\",\n      |  curr_char = \"#\",\n      Then\n        Do\n        curr_token_type = \"<keyword>\"\n        Do while (\"A\" <= curr_char & curr_char <= \"I\"),\n               | (\"J\" <= curr_char & curr_char <= \"R\"),\n               | (\"S\" <= curr_char & curr_char <= \"Z\"),\n               | (\"a\" <= curr_char & curr_char <= \"i\"),\n               | (\"j\" <= curr_char & curr_char <= \"r\"),\n               | (\"s\" <= curr_char & curr_char <= \"z\"),\n               | (\"0\" <= curr_char & curr_char <= \"9\"),\n               | curr_char = \"_\",\n               | curr_char = \"%\",\n               | curr_char = \"$\",\n               | curr_char = \"#\"\n          curr_token = curr_token||curr_char\n          Call Get_Char\n          End\n        If curr_char = \":\" & first_token\n          Then\n            Do\n            curr_token_type = \"<label>\"\n            curr_token = curr_token||curr_char\n            Call Get_Char\n            End\n        End\n    When curr_char = \"&\"\n      Then\n        Do\n        curr_token_type = \"<variable>\"\n        curr_token = curr_token||curr_char\n        Call Get_Char\n        If curr_char = \"&\"\n          Then\n            Do\n            curr_token_type = \"<operator>\"\n            Call Get_Char\n            End\n          Else\n            Do\n            Do while (\"A\" <= curr_char & curr_char <= \"I\"),\n                   | (\"J\" <= curr_char & curr_char <= \"R\"),\n                   | (\"S\" <= curr_char & curr_char <= \"Z\"),\n                   | (\"a\" <= curr_char & curr_char <= \"i\"),\n                   | (\"j\" <= curr_char & curr_char <= \"r\"),\n                   | (\"s\" <= curr_char & curr_char <= \"z\"),\n                   | (\"0\" <= curr_char & curr_char <= \"9\"),\n                   | curr_char = \"_\",\n                   | curr_char = \"%\",\n                   | curr_char = \"$\",\n                   | curr_char = \"#\"\n              curr_token = curr_token||curr_char\n              Call Get_Char\n              End\n            If curr_char = \".\"\n              Then\n                Call Get_Char\n            curr_token = translate(curr_token,,\n                                   \"abcdefghijklmnopqrstuvwxyz\",,\n                                   \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n            End\n        End\n    When curr_char = \" \"\n      Then\n        Do\n        curr_token_type = \"<blanks>\"\n        Do while (curr_char = \" \")\n          curr_token = curr_token||curr_char\n          Call Get_Char\n          End\n        End\n    When curr_char = \"'\"\n      Then\n        Do\n        curr_token_type = \"<special_char>\"\n        curr_token = curr_token||curr_char\n        Call Get_Char\n        End\n    When curr_char = \"/\"\n      Then\n        Do\n        curr_token_type = \"<operator>\"\n        curr_token = curr_token||curr_char\n        Call Get_Char\n        If curr_char = \"*\"\n          Then\n            Do\n            curr_token_type = \"<comment>\"\n            curr_token = curr_token||curr_char\n            Call Get_Char\n            Do forever\n              curr_token = curr_token||curr_char\n              If curr_char \u00ac= \"*\"\n                Then\n                  Call Get_Char\n                Else\n                  Do\n                  Call Get_Char\n                  If curr_char = \"/\"\n                    Then\n                      Do\n                      curr_token = curr_token||curr_char\n                      Call Get_Char\n                      Leave\n                      End\n                  End\n              If token_offset > length(curr_stmt)\n                Then\n                  Do\n                  curr_token = curr_token||\"*/\"\n                  Leave\n                  End\n              End\n            End\n        End\n    When pos(\"\u00ac<>=&+-/*()\",curr_char) \u00ac= 0\n      Then\n        Do\n        curr_token_type = \"<operator>\"\n        curr_token = curr_token||curr_char\n        save_char = curr_char\n        Call Get_Char\n        double_operators = \"\u00ac<>&/*\u00ac\u00ac\"\n        double_oprsmates = \"===&/*<>\"\n        If pos(double_operators,save_char) \u00ac= 0\n          Then\n            Do i = 1 to length(double_operators)\n              If  substr(double_operators,i,1) = save_char,\n                & substr(double_oprsmates,i,1) = curr_char,\n                Then\n                  Do\n                  curr_token = curr_token||curr_char\n                  Select\n                    When curr_token = \"\u00ac>\"\n                      Then\n                        curr_token = \"<=\"\n                    When curr_token = \"\u00ac<\"\n                      Then\n                        curr_token = \">=\"\n                    When curr_token = \"&&\"\n                      Then\n                        curr_token = \"&\"\n                    Otherwise\n                        nop\n                    End\n                  Call Get_Char\n                  Leave i\n                  End\n              End\n        If pos(\"()\",save_char) = 0\n          Then\n            If       \u00ac(datatype(curr_char,\"a\"),\n              | pos(\"() &\",curr_char) \u00ac= 0,\n              | token_offset > length(curr_stmt))\n              Then\n                curr_token_type = \"<special_char>\"\n        End\n    Otherwise\n        Do\n        curr_token_type = \"<special_char>\"\n        curr_token = curr_token||curr_char\n        save_char = curr_char\n        Call Get_Char\n        End\n    End\n  If token_offset > length(curr_stmt)\n    Then\n      Do\n      next_token_type = \"<eos>\"\n      next_token = \";\"\n      End\n    Else\n      Do\n      next_token_type = \"<?>\"\n      next_token = \"?????\"\n      End\n\n  If test_mode >= 2 & 0\n    Then\n      Say \"Get_Token      \" left(curr_token_type,16) curr_token\n  Return 0\n\n/**********************************************************************/\n/*** Get_Stmt:                                                      ***/\n/***   Subroutine to get one statement from the input stream,       ***/\n/***   including handling continuation.                             ***/\n/**********************************************************************/\nGet_Stmt:\n  curr_stmt = \"\"\n  k = 0\n  strip_next_line = 0\n  Do forever\n    input_line_number = input_line_number + 1\n    k = k + 1\n    If input_line_number > numlines\n      Then\n        Leave\n    ISREDIT \"(THISLINE) = LINE\" input_line_number\n    If test_mode >= 1\n      Then\n        Do\n        If test_mode >= 2\n          Then\n            Say copies(\"-\",78)\n        Say \"Get_Stmt \" format(input_line_number,6) strip(thisline,\"t\")\n        End\n    Call Put_Line \"NOTELINE\",thisline\n    If strip_next_line\n      Then\n        thisline = strip(thisline)\n      Else\n        thisline = strip(thisline,\"t\")\n    strip_next_line = 0\n    Select\n      When right(thisline,1) = \"+\"\n        Then\n          Do\n          curr_stmt = curr_stmt||substr(thisline,1,length(thisline)-1)\n          strip_next_line = 1\n          End\n      When right(thisline,1) = \"-\"\n        Then\n          curr_stmt = curr_stmt||substr(thisline,1,length(thisline)-1)\n      Otherwise\n          Do\n          curr_stmt = curr_stmt||thisline\n          Leave\n          End\n      End\n    End\n  first_token = 1\n  token_offset = 0\n  Call Get_NonBlank_Token\n  If curr_token_type = \"<label>\"\n    Then\n      Do\n      label_list = label_list substr(curr_token,1,length(curr_token)-1)\n      Call Put_Token curr_token\n      Call Put_Line\n      first_token = 0\n      Call Get_NonBlank_Token\n      End\n  first_token = 0\n  verb = translate(curr_token)\n  Return 0\n\n/**********************************************************************/\n/*** Put_Indent:                                                    ***/\n/***   Subroutine to put out leading blanks on the current output   ***/\n/***   record, so that it indents nicely.                           ***/\n/**********************************************************************/\nPut_Indent:\n  output_recd = output_recd||copies(\" \",,\n                                max(0,indent-length(output_recd)))\n  Return 0\n\n/**********************************************************************/\n/*** Put_Token:                                                     ***/\n/***   Subroutine to put out a token or tokens to the current       ***/\n/***   output record.                                               ***/\n/**********************************************************************/\nPut_Token:\n  output_recd = output_recd||arg(1)\n  Return 0\n\n/**********************************************************************/\n/*** Put_Line:                                                      ***/\n/***   Subroutine to output a record to the output stream.          ***/\n/***                                                                ***/\n/***   Parameters:                                                  ***/\n/***     1. The type of output line.  Values are \"\", \"DATALINE\",    ***/\n/***        \"NOTELINE\", and \"MSGLINE\".  This parameter will be      ***/\n/***        used on an PDF edit LINE_BEFORE command.                ***/\n/***     2. The line itself.                                        ***/\n/***                                                                ***/\n/**********************************************************************/\nPut_Line:\n  If test_mode >= 2\n    Then\n      Say \"Put_Line \" format(output_line_number,6) arg(1),\n           strip(arg(2),\"t\")\n  If arg(1) \u00ac= \"\"\n    Then\n      Do\n      output_line_number = output_line_number + 1\n      output_line.output_line_number = arg(2)\n      output_line_type.output_line_number = arg(1)\n      End\n    Else\n      Do\n      If test_mode >= 2\n        Then\n          Say \"Put_Line \" format(output_line_number,6) \"**REXX**\",\n               strip(output_recd,\"t\")\n      If length(output_recd) <= lrecl\n        Then\n          Do\n          output_line_number = output_line_number + 1\n          output_line.output_line_number = output_recd\n          output_line_type.output_line_number = \"\"\n          output_recd = \"\"\n          End\n        Else\n          Do\n          const_map = \"\"\n          cc = 1\n          output_mode = \"NORMAL\"\n          Do while cc <= length(output_recd)\n            Select\n              When output_mode = \"NORMAL\"\n                Then\n                  Do\n                  Select\n                    When substr(output_recd,cc,1) = \"\"\"\"\n                      Then\n                        Do\n                        output_mode = \"QSTRING2\"\n                        const_map = const_map\"1\"\n                        cc = cc + 1\n                        End\n                    When substr(output_recd,cc,1) = \"'\"\n                      Then\n                        Do\n                        output_mode = \"QSTRING1\"\n                        const_map = const_map\"1\"\n                        cc = cc + 1\n                        End\n                    Otherwise\n                        Do\n                        const_map = const_map\" \"\n                        cc = cc + 1\n                        End\n                    End\n                  End\n              When output_mode = \"QSTRING1\"\n                Then\n                  Do\n                  Select\n                    When substr(output_recd,cc,1) = \"'\",\n                      &  substr(output_recd,cc+1,1) = \"'\"\n                      Then\n                        Do\n                        const_map = const_map\"SS\"\n                        cc = cc + 2\n                        End\n                    When substr(output_recd,cc,1) = \"'\",\n                      Then\n                        Do\n                        output_mode = \"NORMAL\"\n                        const_map = const_map\"2\"\n                        cc = cc + 1\n                        End\n                    Otherwise\n                        Do\n                        const_map = const_map\"S\"\n                        cc = cc + 1\n                        End\n                    End\n                End\n              When output_mode = \"QSTRING2\"\n                Then\n                  Do\n                  Select\n                    When substr(output_recd,cc,1) = '\"',\n                      &  substr(output_recd,cc+1,1) = '\"'\n                      Then\n                        Do\n                        const_map = const_map\"SS\"\n                        cc = cc + 2\n                        End\n                    When substr(output_recd,cc,1) = '\"',\n                      Then\n                        Do\n                        output_mode = \"NORMAL\"\n                        const_map = const_map\"2\"\n                        cc = cc + 1\n                        End\n                    Otherwise\n                        Do\n                        const_map = const_map\"S\"\n                        cc = cc + 1\n                        End\n                    End\n                  End\n              End\n            End\n          Do while length(output_recd) > 0\n            If length(output_recd) > lrecl\n              Then\n                Do\n                If substr(const_map,lrecl) = \" \"\n                  Then\n                    Do\n                    output_line_number = output_line_number + 1\n                    output_line.output_line_number,\n                          = substr(output_recd,1,71)\",\"\n                    output_line_type.output_line_number = \"\"\n                    output_recd = substr(output_recd,72)\n                    End\n                  Else\n                    Do\n                    output_line_number = output_line_number + 1\n                    output_line.output_line_number,\n                          = substr(output_recd,1,72)\n                    output_line_type.output_line_number = \"\"\n                    output_recd = substr(output_recd,73)\n                    End\n                End\n              Else\n                Do\n                output_line_number = output_line_number + 1\n                output_line.output_line_number = output_recd\n                output_line_type.output_line_number = \"\"\n                output_recd = \"\"\n                End\n            End\n          End\n      End\n  Return 0\n\n/**********************************************************************/\n/*** Put_Stmt:                                                      ***/\n/***   Subroutine to put an entire statement to the output stream.  ***/\n/***                                                                ***/\n/***   Parameters:                                                  ***/\n/***     1. The statement to be output.                             ***/\n/***                                                                ***/\n/**********************************************************************/\nPut_Stmt:\n  Call Put_Indent\n  Call Put_Token arg(1)\n  Call Put_Line\n  Return 0\n\n/**********************************************************************/\n/*** Put_Msg:                                                       ***/\n/***   Subroutine to put a message to the output stream.            ***/\n/***                                                                ***/\n/***   Parameters:                                                  ***/\n/***     1. The message to be output.                               ***/\n/***                                                                ***/\n/**********************************************************************/\nPut_Msg:\n  Say arg(1)\n  Call Put_Line \"MSGLINE\",arg(1)\n  Return 0\n\n/**********************************************************************/\n/*** Check_Concat_Needed:                                           ***/\n/***   Subroutine to check to see If REXX needs a concat operator   ***/\n/***   where the CLIST did not.                                     ***/\n/**********************************************************************/\nCheck_Concat_Needed:\n  If datatype(right(new_exp,1),\"a\")\n    Then\n      new_exp = new_exp||\"||\"\n  Return 0\n\n/**********************************************************************/\n/*** Start_Quote_Mode:                                              ***/\n/***   Subroutine to start a REXX quoted string if we have not      ***/\n/***   already started one.                                         ***/\n/**********************************************************************/\nStart_Quote_Mode:\n  If quote_mode \u00ac= \"q\"\n    Then\n      Do\n      new_exp = new_exp'\"'\n      quote_mode = \"q\"\n      End\n  Return\n\n/**********************************************************************/\n/*** End_Quote_Mode:                                                ***/\n/***   Subroutine to terminate a REXX quoted string.                ***/\n/**********************************************************************/\nEnd_Quote_Mode:\n  If quote_mode \u00ac= \"nq\"\n    Then\n      Do\n      blank_count = 0\n      Do while length(new_exp) > 0,\n        & right(new_exp,1) = \" \"\n        blank_count = blank_count + 1\n        new_exp = substr(new_exp,1,length(new_exp)-1)\n        End\n      If right(new_exp,1) = '\"',\n        & right(new_exp,2) \u00ac= '\"\"',\n        Then\n          new_exp = new_exp||copies(\" \",blank_count)'\"'\n        Else\n          new_exp = new_exp'\"'copies(\" \",blank_count)\n      quote_mode = \"nq\"\n      End\n  Return\n\n/**********************************************************************/\n/*** Help:                                                          ***/\n/***   Subroutine to display help text.                             ***/\n/**********************************************************************/\nHelp:\n  Say cmd_name \"ISREDIT\"\n  Say \"\"\n  Say \"An ISPF/PDF edit macro to assist with conversion of\"\n  Say \"CLISTs to REXX.  It does not do everything, but is designed\"\n  Say \"to do 90% of the work.  It won't handle, but I hope to\"\n  Say \"add support for in the future:\"\n  Say \"\"\n  Say \"  - abutal (&A&B is translated to ab)\"\n  Say \"\"\n  Say \"You will still have to do some manual touch-up, but I\"\n  Say \"think conversion is now feasable.  You should also\"\n  Say \"review your code to identify those areas where you\"\n  Say \"used several lines of code to implement something REXX\"\n  Say \"provides as a function.\"\n  Say \"\"\n  Say \"It won't handle, and I'm not sure how to do the following\"\n  Say \"I wouldn't mind suggestions on how to do these:\"\n  Say \"\"\n  Say \"  - CONTROL END/CAPS/FLUSH/NOFLUSH/MAIN\"\n  Say \"  - ATTN\"\n  Say \"  - ERROR\"\n  Say \"  - GLOBAL\"\n  Say \"  - IF &FOO = THEN +  (nothing on the right of the =)\"\n  Say \"  - Some of the builtin functions and control variables:\"\n  Say \"      &sysscan (always returns 1, setting has no effect)\"\n  Say \"      &maxcc\"\n  Say \"      &sysabncd\"\n  Say \"      &sysabnrc\"\n  Say \"      &syscmdrc\"\n  Say \"\"\n  Say \"It DOES handle CONTROL PROMPT/LIST/CONLIST/SYMLIST/MSG\"\n  Say \"and their inverses.  It will also handle CONTROL\"\n  Say \"ASIS/NOCAPS by ignoring it.  It will not hand CONTROL\"\n  Say \"CAPS.\"\n  Say \"\"\n  Say \"GOTO's are translated to SIGNALS, which won't work if\"\n  Say \"the label preceeds the SIGNAL.  You will probably\"\n  Say \"want to manually translate them to LEAVE/ITERATE/SELECT\"\n  Say \"or whatever it was you had in mind.\"\n  Say \"\"\n  Say \"REXX statements which are longer than the lrecl are\"\n  Say \"hacked into pieces rather ruthlessly and without warning.\"\n  Say \"\"\n  Say \"Untranslateable commands are commented out and prefixed\"\n  Say \"with an !\"\n  Say \"\"\n  Say \"Untranslateable functions and control variables are left\"\n  Say \"alone and prefixed with /*!\"\n  Say \"\"\n  Say \"\"\n  Say \"Syntax:\"\n  Say \"\"\n  Say \"  \"cmd_name\n  Say \"\"\n  Say \"\"\n  Say \"This macro will run under both TSO and CMS.\"\n  Say \"                                                                \"\n  Say \"Author:        Chuck Tribolet, TRIBLET at STLMVS1               \"\n  Return 0\n\n/**********************************************************************/\n/*** Append_Stack:                                                  ***/\n/***   Subroutine to copy the REXX stack to the PDF editor's        ***/\n/***   working copy of the file.                                    ***/\n/**********************************************************************/\nAppend_Stack: Procedure Expose ISREDIT already_queued,\n                             test_mode\n  Do while Queued() > already_queued\n    Parse Pull Line\n    If test_mode >= 1\n      Then\n        Say \"LineAfter\" strip(line,\"t\")\n    ISREDIT 'LINE_AFTER .ZLAST = \"'line'\"'\n    End\n  Return 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBBITS": {"ttr": 18436, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x01S\\x01S\\x00\\x00\\xc3\\xd6\\xc2\\xc2\\xc9\\xe3\\xe2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 339, "newlines": 339, "modlines": 0, "user": "COBBITS"}, "text": "//-YOUR-USERID-C JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//*** COBOL CODE TO SET, TEST OR FLIP BITS WITHIN ANY ARRAY -\n//*** CONTAINED IN A TEST PROGRAM\n//***\n//C          EXEC     PGM=IGYCRCTL,REGION=4M,\n//             PARM=('LIB,MAP,NUMPROC(PFD),OFF,OPTIMIZE',\n//            'APOST,NOSEQ,TRUNC(OPT),XREF')\n//SYSIN        DD       *\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  TESTER.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT I\n               ASSIGN TO I.\n           SELECT O\n               ASSIGN TO O.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  I\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  INPUT-REC    PIC X(00080).\n       FD  O\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  OUTPUT-REC   PIC X(00080).\n       WORKING-STORAGE SECTION.\n       01  WS-INPUT-REC.\n           05  WS-FUNCTION            PIC X(00010).\n           05  WS-BIT-NUMBER          PIC 9(00009).\n           05                         PIC X(00001).\n           05  WS-EXPECTED-RC         PIC 9(00002).\n           05                         PIC X(00058).\n       01  WORK-AREAS.\n          05  WS-ARRAY                PIC  X(00080)\n                                      VALUE ALL LOW-VALUES.\n          05  WS-RC                   PIC  99       VALUE 00.\n          05  END-OF-FILE-STATUS      PIC X         VALUE 'N'.\n              88  AT-END-OF-FILE                    VALUE 'Y'.\n\n       PROCEDURE DIVISION.\n\n       0000-MAIN.\n           PERFORM 0100-INITIALIZATION\n           PERFORM 0200-READ-WRITE-LOOP\n               UNTIL AT-END-OF-FILE\n           PERFORM 0900-TERMINATION\n           GOBACK\n           .\n\n       0100-INITIALIZATION.\n           OPEN  INPUT  I\n                 OUTPUT O\n           READ  I INTO WS-INPUT-REC\n               AT END SET AT-END-OF-FILE TO TRUE\n               END-READ\n           .\n\n       0200-READ-WRITE-LOOP.\n           PERFORM 0400-PERFORM-FUNCTION\n           DISPLAY 'FUNCTION ' WS-FUNCTION ' -- BIT ' WS-BIT-NUMBER\n           IF WS-RC = WS-EXPECTED-RC\n               DISPLAY '   *OK*  RC OK  = ' WS-RC\n           ELSE\n               DISPLAY '   *NG*  BAD RC = ' WS-RC\n                       ' EXPECTED ' WS-EXPECTED-RC\n               MOVE 4 TO RETURN-CODE\n           END-IF\n           WRITE OUTPUT-REC FROM WS-ARRAY\n           READ  I INTO WS-INPUT-REC\n               AT END SET AT-END-OF-FILE TO TRUE\n               END-READ\n           .\n\n       0400-PERFORM-FUNCTION.\n           EVALUATE WS-FUNCTION\n               WHEN 'SETON'\n                   CALL  'SETON'   USING  WS-ARRAY  WS-BIT-NUMBER  WS-RC\n               WHEN 'SETOFF'\n                   CALL  'SETOFF'  USING  WS-ARRAY  WS-BIT-NUMBER  WS-RC\n               WHEN 'TESTBIT'\n                   CALL  'TESTBIT' USING  WS-ARRAY  WS-BIT-NUMBER  WS-RC\n               WHEN 'FLIPBIT'\n                   CALL  'FLIPBIT' USING  WS-ARRAY  WS-BIT-NUMBER  WS-RC\n           END-EVALUATE\n           .\n\n       0900-TERMINATION.\n           CLOSE I\n                 O\n           .\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  TESTBIT COMMON.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  WORK-FIELDS.\n           05  COMP-9-4        PIC     9999   COMP.\n           05                  REDEFINES  COMP-9-4.\n               10  COMP-9-4-1  PIC     X.\n               10  COMP-9-4-2  PIC     X.\n           05  WS-BYTE         PIC     9(8)   COMP.\n           05  WS-RMNDR        PIC     9(4)   COMP.\n           05  WS-OFFSET       PIC     9(4)   COMP.\n       LINKAGE SECTION.\n       01  LS-BIT-ARRAY            PIC  X(1000000).\n       01                          REDEFINES LS-BIT-ARRAY.\n           05  LS-ARRAY            OCCURS 1000000\n                                   PIC  X.\n       01  LS-BIT-NUMBER           PIC  9(9).\n       01  LS-RC                   PIC  99.\n       PROCEDURE DIVISION   USING  LS-BIT-ARRAY\n                                   LS-BIT-NUMBER\n                                   LS-RC\n                                   .\n      **  DETERMINE WHICH BYTE AND OFFSET TO USE\n           DIVIDE LS-BIT-NUMBER BY 8\n               GIVING WS-BYTE\n               REMAINDER WS-RMNDR\n           IF WS-RMNDR > 0\n              ADD 1 TO WS-BYTE\n           END-IF\n      **  RETRIEVE BYTE TO COMPUTATIONAL AREA\n           MOVE X'00'                TO COMP-9-4-1\n           MOVE LS-ARRAY(WS-BYTE)    TO COMP-9-4-2\n      **  USING OFFSET, GET BIT VALUE\n           IF WS-RMNDR > 0\n               COMPUTE WS-OFFSET = 2 ** (8 - WS-RMNDR)\n               DIVIDE COMP-9-4 BY WS-OFFSET GIVING COMP-9-4\n           END-IF\n           DIVIDE COMP-9-4 BY 2 GIVING WS-OFFSET REMAINDER LS-RC\n           EXIT PROGRAM.\n       END PROGRAM TESTBIT.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  SETON COMMON.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  WORK-FIELDS.\n           05  COMP-9-4        PIC     9999   COMP.\n           05                  REDEFINES  COMP-9-4.\n               10  COMP-9-4-1  PIC     X.\n               10  COMP-9-4-2  PIC     X.\n           05  WS-BYTE         PIC     9(8)   COMP.\n           05  WS-RMNDR        PIC     9(4)   COMP.\n           05  WS-OFFSET       PIC     9(4)   COMP.\n       LINKAGE SECTION.\n       01  LS-BIT-ARRAY            PIC  X(1000000).\n       01                          REDEFINES LS-BIT-ARRAY.\n           05  LS-ARRAY            OCCURS 1000000\n                                   PIC  X.\n       01  LS-BIT-NUMBER           PIC  9(9).\n       01  LS-RC                   PIC  99.\n       PROCEDURE DIVISION   USING  LS-BIT-ARRAY\n                                   LS-BIT-NUMBER\n                                   LS-RC\n                                   .\n      **  DETERMINE WHICH BYTE AND OFFSET TO USE\n           DIVIDE LS-BIT-NUMBER BY 8\n               GIVING WS-BYTE\n               REMAINDER WS-RMNDR\n           IF WS-RMNDR > 0\n              ADD 1 TO WS-BYTE\n           END-IF\n      **  CHECK IF ALREADY ON\n           CALL  'TESTBIT' USING  LS-BIT-ARRAY  LS-BIT-NUMBER  LS-RC\n           IF LS-RC = 0\n      **  RETRIEVE BYTE TO COMPUTATIONAL AREA\n               MOVE X'00'             TO COMP-9-4-1\n               MOVE LS-ARRAY(WS-BYTE) TO COMP-9-4-2\n      **  USING OFFSET, SET BIT VALUE\n               IF WS-RMNDR = 0\n                   MOVE 1 TO WS-OFFSET\n               ELSE\n                   COMPUTE WS-OFFSET = 2 ** (8 - WS-RMNDR)\n               END-IF\n               ADD WS-OFFSET TO COMP-9-4\n               MOVE COMP-9-4-2 TO LS-ARRAY(WS-BYTE)\n               MOVE 1 TO LS-RC\n           END-IF\n           EXIT PROGRAM.\n       END PROGRAM SETON.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  SETOFF COMMON.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  WORK-FIELDS.\n           05  COMP-9-4        PIC     9999   COMP.\n           05                  REDEFINES  COMP-9-4.\n               10  COMP-9-4-1  PIC     X.\n               10  COMP-9-4-2  PIC     X.\n           05  WS-BYTE         PIC     9(8)   COMP.\n           05  WS-RMNDR        PIC     9(4)   COMP.\n           05  WS-OFFSET       PIC     9(4)   COMP.\n       LINKAGE SECTION.\n       01  LS-BIT-ARRAY            PIC  X(1000000).\n       01                          REDEFINES LS-BIT-ARRAY.\n           05  LS-ARRAY            OCCURS 1000000\n                                   PIC  X.\n       01  LS-BIT-NUMBER           PIC  9(9).\n       01  LS-RC                   PIC  99.\n       PROCEDURE DIVISION   USING  LS-BIT-ARRAY\n                                   LS-BIT-NUMBER\n                                   LS-RC\n                                   .\n      **  DETERMINE WHICH BYTE AND OFFSET TO USE\n           DIVIDE LS-BIT-NUMBER BY 8\n               GIVING WS-BYTE\n               REMAINDER WS-RMNDR\n           IF WS-RMNDR > 0\n              ADD 1 TO WS-BYTE\n           END-IF\n      **  CHECK IF ALREADY OFF\n           CALL  'TESTBIT' USING  LS-BIT-ARRAY  LS-BIT-NUMBER  LS-RC\n           IF LS-RC NOT = 0\n      **  RETRIEVE BYTE TO COMPUTATIONAL AREA\n               MOVE X'00'             TO COMP-9-4-1\n               MOVE LS-ARRAY(WS-BYTE) TO COMP-9-4-2\n      **  USING OFFSET, DROP BIT VALUE\n               IF WS-RMNDR = 0\n                   MOVE 1 TO WS-OFFSET\n               ELSE\n                   COMPUTE WS-OFFSET = 2 ** (8 - WS-RMNDR)\n               END-IF\n               SUBTRACT WS-OFFSET FROM COMP-9-4\n               MOVE COMP-9-4-2 TO LS-ARRAY(WS-BYTE)\n               MOVE 0 TO LS-RC\n           END-IF\n           EXIT PROGRAM.\n       END PROGRAM SETOFF.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  FLIPBIT COMMON.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  WORK-FIELDS.\n           05  COMP-9-4        PIC     9999   COMP.\n           05                  REDEFINES  COMP-9-4.\n               10  COMP-9-4-1  PIC     X.\n               10  COMP-9-4-2  PIC     X.\n           05  WS-BYTE         PIC     9(8)   COMP.\n           05  WS-RMNDR        PIC     9(4)   COMP.\n           05  WS-OFFSET       PIC     9(4)   COMP.\n       LINKAGE SECTION.\n       01  LS-BIT-ARRAY            PIC  X(1000000).\n       01                          REDEFINES LS-BIT-ARRAY.\n           05  LS-ARRAY            OCCURS 1000000\n                                   PIC  X.\n       01  LS-BIT-NUMBER           PIC  9(9).\n       01  LS-RC                   PIC  99.\n       PROCEDURE DIVISION   USING  LS-BIT-ARRAY\n                                   LS-BIT-NUMBER\n                                   LS-RC\n                                   .\n      **  DETERMINE WHICH BYTE AND OFFSET TO USE\n           DIVIDE LS-BIT-NUMBER BY 8\n               GIVING WS-BYTE\n               REMAINDER WS-RMNDR\n           IF WS-RMNDR > 0\n              ADD 1 TO WS-BYTE\n           END-IF\n           MOVE X'00'             TO COMP-9-4-1\n           MOVE LS-ARRAY(WS-BYTE) TO COMP-9-4-2\n      **  COMPUTE OFFSET VALUE\n           IF WS-RMNDR = 0\n               MOVE 1 TO WS-OFFSET\n           ELSE\n               COMPUTE WS-OFFSET = 2 ** (8 - WS-RMNDR)\n           END-IF\n      **  CHECK FOR CURRENT VALUE\n           CALL  'TESTBIT' USING  LS-BIT-ARRAY  LS-BIT-NUMBER  LS-RC\n      **  USING OFFSET, FLIP BIT VALUE\n           IF LS-RC = 0\n               ADD WS-OFFSET TO COMP-9-4\n               MOVE 1 TO LS-RC\n           ELSE\n               SUBTRACT WS-OFFSET FROM COMP-9-4\n               MOVE 0 TO LS-RC\n           END-IF\n           MOVE COMP-9-4-2 TO LS-ARRAY(WS-BYTE)\n           EXIT PROGRAM.\n       END PROGRAM FLIPBIT.\n\n       END PROGRAM TESTER.\n\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=SYSDA,SPACE=(CYL,(3,3)),\n//             DCB=(BLKSIZE=0,LRECL=80,RECFM=FB)\n//SYSUT1       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT2       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT3       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT4       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT5       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT6       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT7       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//***\n//GO         EXEC     PGM=LOADER,\n//             PARM='AMODE(31),RMODE(ANY),MAP,PRINT',\n//             REGION=4M,COND=(5,LT)\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//SYSLOUT      DD       SYSOUT=*\n//SYSPRINT     DD       SYSOUT=*\n//I            DD       *\nTESTBIT   000000001 00\nSETON     000000011 01\nTESTBIT   000000011 01\nFLIPBIT   000000011 00\nTESTBIT   000000011 00\nFLIPBIT   000000011 01\nTESTBIT   000000011 01\nSETON     000000024 01\nTESTBIT   000000024 01\nSETOFF    000000024 00\nTESTBIT   000000024 00\nSETON     000000025 01\nSETON     000000026 01\nSETON     000000027 01\nSETON     000000028 01\nSETON     000000029 01\nSETON     000000030 01\nSETON     000000031 01\nSETON     000000032 01\nSETON     000000025 01\nSETON     000000640 01\nTESTBIT   000000640 01\nSETOFF    000000640 00\nTESTBIT   000000640 00\n//O            DD       SYSOUT=*\n//SYSOUT       DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COBCOLOF": {"ttr": 18442, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x01\\x13\\x01\\x13\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 275, "newlines": 275, "modlines": 0, "user": "REXX"}, "text": "/**  REXX  -- GEN COBOL OFFSETS IN COLUMNS 73 THRU 80             **/\n\n/**  COBCOLO USES A PROGRAM TO DETERMINE COBOL STRUCTURE OFFSETS  **/\n/**  AND PLACE THEM IN COLUMNS 73 THRU 80.  IT WILL WORK WITHIN   **/\n/**  A RANGE SPECIFIED BY C/CC/C## OR OVER THE ENTIRE FILE. THE   **/\n/**  PROGRAM USED WILL IGNORE NON DATA ITEMS.                     **/\n\n/**  THE OFFSETS ARE SHOWN AS Z999-999 WHERE Z IS THE THOUSANDS   **/\n/**  POSITION.                                                    **/\n\n/*  SET UP ISPF ENVIRONMENT AND DETERMINE STARTING/ENDING LINES    */\n   SAVEMSG=MSG()\n   X=MSG(\"OFF\")\n   X=ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n         SAY \"COBCOLO MUST BE RUN UNDER ISPF EDIT!\"\n         SIGNAL QUIT\n       END\n   SUBCOM ISREDIT\n   UMODE = \"ISREDIT\"\n   ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n   ADDRESS ISREDIT\n   \"MACRO (HUH) NOPROCESS\"\n   IF HUH = \"?\" THEN SIGNAL DISPDOC\n   \"PROCESS RANGE C\"\n   IF RC > 0 THEN\n      DO\n         \"(TOP) = LINENUM .ZFIRST\"\n         \"(BOT) = LINENUM .ZLAST\"\n      END\n   ELSE\n      DO\n         \"(TOP) = LINENUM .ZFRANGE\"\n         \"(BOT) = LINENUM .ZLRANGE\"\n      END\n\n/*  DELETE OLD TEMP PDS FILE, IF ANY, AND ALLOCATE NEW ONE         */\n   ADDRESS TSO\n   \"FREE DD(DDXX DD01)\"\n   \"DELETE $$$TEMP.COPYBOOK.PDS\"\n   \"ALLOCATE DD(DD01) DSN($$$TEMP.COPYBOOK.PDS) NEW\",\n      \"CYL SPACE(01 01) RECFM(F B) LRECL(80) BLKSIZE(27920) DIR(12)\"\n   \"ALLOCATE DD(DDXX) DSN($$$TEMP.COPYBOOK.PDS(DUMMYMEM)) SHR\"\n\n/*  WRITE LINES IN SPECIFIED RANGE TO TEMP PDS FILE AS MEMBER      */\n   ADDRESS ISREDIT\n   ADDRESS TSO \"EXECIO 0 DISKW\" DDXX \"(OPEN\"\n   GOT_FIRST = 'NO'\n   DO II = TOP TO BOT BY 1\n      \"ISREDIT (RECORD) = LINE &II\"\n      IF SUBSTR(RECORD,7,1) <> '*',\n               & SUBSTR(RECORD,7,1) <> '/',\n               & SUBSTR(RECORD,8,65) <> ' ' THEN DO\n         IF GOT_FIRST = 'NO' THEN DO\n            IF INDEX(SUBSTR(RECORD,8,4),'1') = 0 THEN DO\n               DUMMY_REC = '       01  DUMMY-01-LEVEL.'\n               PUSH DUMMY_REC\n               ADDRESS TSO \"EXECIO 1 DISKW\" DDXX\n            END\n            GOT_FIRST = 'YES'\n         END\n         BB = INDEX(RECORD,'( ');\n         DO WHILE ( BB <> 0 );\n            RECORD = SUBSTR(RECORD,1,BB) || SUBSTR(RECORD,BB+2)\n            BB = INDEX(RECORD,'( ');\n         END\n         PUSH RECORD\n         ADDRESS TSO \"EXECIO 1 DISKW\" DDXX\n      END\n   END\n   ADDRESS TSO \"EXECIO 0 DISKW\" DDXX \"(FINIS\"\n   ADDRESS TSO\n   \"FREE DD(DDXX DD01)\"\n\n/*  FREE & ALLOCATE DD01, SYSIN, SYSLIST AND SYSPRINT FILES        */\n/*  FOR INITIAL CALL TO FILEAID                                    */\n   ADDRESS TSO\n   \"FREE DD(DD01 SYSIN SYSLIST SYSPRINT)\"\n   \"ALLOCATE DD(DD01) DSN($$$TEMP.COPYBOOK.PDS) SHR\"\n   \"DELETE $$$TEMP.SYSIN.FILE1\"\n   \"ALLOC DD(SYSIN) DSN($$$TEMP.SYSIN.FILE1) NEW TRACKS SPACE(1)\",\n      \"LRECL(80) BLKSIZE(800) RECFM(F B)\"\n   QUEUE \"$$DD01 RLPRINT MEMBER=(DUMMYMEM)\"\n   \"EXECIO\" QUEUED() \"DISKW SYSIN (FINIS\"\n   \"DELETE $$$TEMP.SYSLIST.FILE\"\n   \"ALLOCATE DD(SYSLIST) DSN($$$TEMP.SYSLIST.FILE) NEW\",\n      \"CYL SPACE(01,01) RECFM(F,B) LRECL(80) BLKSIZE(27920)\"\n   \"ALLOCATE DD(SYSPRINT) DUMMY\",\n      \"RECFM(F,B) LRECL(133) BLKSIZE(6118)\"\n   \"CALL *(FILEAID)\"\n\n/*  READ SYSLIST FILE AND STRIP OFF OFFSETS INTO LAST 8 BYTES OF   */\n/*  APPROPRIATE RECORDS                                            */\n   ADDRESS ISREDIT\n   ADDRESS TSO \"FREE DD(LAYOUT)\"\n   ADDRESS TSO \"ALLOC DD(LAYOUT) DSN($$$TEMP.SYSLIST.FILE) SHR\"\n   ADDRESS TSO \"EXECIO 0 DISKR\" LAYOUT \"(OPEN\"\n\n   CALL GET_LAYOUT\n   DO II = TOP TO BOT BY 1\n      \"ISREDIT (RECORD) = LINE &II\"\n      IF INDEX(LAYLINE,' FILLER ') <> 0,\n            & INDEX(RECORD, ' FILLER ') = 0 THEN DO\n         SCANSTR = ' PIC '\n      END\n      IF SUBSTR(RECORD,7,1) <> \"*\",\n            & SUBSTR(RECORD,7,1) <> \"/\",\n            & INDEX(RECORD,SCANSTR) <> 0 THEN DO\n         RECORD = SUBSTR(RECORD,1,72) || START_COL || \"-\" || END_COL\n         \"ISREDIT LINE &II = &STR(RECORD)\"\n         CALL GET_LAYOUT\n      END\n   END II\n\nSHORT:\n   ADDRESS TSO \"EXECIO 0 DISKR\" LAYOUT \"(FINIS\"\n   ADDRESS TSO \"FREE DD(LAYOUT)\"\n   ADDRESS TSO\n   \"DELETE $$$TEMP.COPYBOOK.PDS\"\n   \"DELETE $$$TEMP.SYSIN.FILE1\"\n   \"DELETE $$$TEMP.SYSLIST.FILE\"\n   ADDRESS ISPEXEC\n   X=MSG(SAVEMSG)\n   ADDRESS ISREDIT \"LOCATE\" TOP\n   ADDRESS ISREDIT \"RESET\"\n   EXIT(1)\n\nGET_LAYOUT:\n   CALL DO_DISKR\nGOT_LAYOUT:\n   IF SUBSTR(LAYLINE,1,1) = '8B'X THEN DO\n      DO WHILE ( INDEX(LAYLINE,'FIELD LEVEL/NAME') = 0 )\n         CALL DO_DISKR\n      END\n      CALL DO_DISKR\n   END\n   IF INDEX(LAYLINE,'DUMMY-01-LEVEL') <> 0 THEN SIGNAL GET_LAYOUT\n   IF INDEX(LAYLINE,'END OF LAYOUT REPORT') <> 0 THEN SIGNAL SHORT\n   IF INDEX(LAYLINE,' REDEFINES ') <> 0 THEN DO\n      RR = INDEX(LAYLINE,' REDEFINES ')\n      RR = RR + 10\n      IF SUBSTR(LAYLINE,RR) = ' ' THEN CALL DO_DISKR\n      SIGNAL GET_LAYOUT\n   END\n   IF SUBSTR(LAYLINE,2) = ' '           THEN SIGNAL GET_LAYOUT\n   LAYLINE = ' ' || SUBSTR(LAYLINE,2)\n   DO  MM = 1 TO 80  WHILE ( SUBSTR(LAYLINE,MM,1) = ' ' )\n   END MM\n   DO  NN = MM TO 80 WHILE ( SUBSTR(LAYLINE,NN,1) <> ' ' )\n   END NN\n   IF DATATYPE(SUBSTR(LAYLINE,MM,NN-MM)) = \"NUM\" THEN DO\n      DO  MM = NN TO 80 WHILE ( SUBSTR(LAYLINE,MM,1) = ' ' )\n      END MM\n      DO  NN = MM TO 80 WHILE ( SUBSTR(LAYLINE,NN,1) <> ' ' )\n      END NN\n   END\n   SCANSTR = SUBSTR(LAYLINE,MM-1,NN-MM+1)\n   IF INDEX(LAYLINE,' OCCURS ') <> 0 THEN DO\n      OO = INDEX(LAYLINE,' OCCURS ')\n      DO  PP = OO+7 TO 80 WHILE (SUBSTR(LAYLINE,PP,1) =  ' ' )\n      END PP\n      DO  QQ = PP+1 TO 80 WHILE (SUBSTR(LAYLINE,QQ,1) <> ' ' )\n      END QQ\n      UBOUND = '(' || SUBSTR(LAYLINE,PP,QQ-PP) || ')'\n      CALL GET_OCCURS\n   END\n   ELSE DO\n      IF UBOUND <> 'UBOUND' THEN DO\n         IF INDEX(SCANSTR,UBOUND) <> 0,\n            THEN CALL CLEAR_OCCURS\n            ELSE CALL GET_COLS\n      END\n      ELSE CALL GET_COLS\n   END\n   RETURN\n\nCLEAR_OCCURS:\n   DO WHILE(INDEX(LAYLINE,UBOUND) <> 0)\n      IF SUBSTR(LAYLINE,78,1) = ' ' THEN DO\n         CALL DO_DISKR\n         IF SUBSTR(LAYLINE,1,1) = '8B'X THEN DO\n            DO WHILE ( INDEX(LAYLINE,'FIELD LEVEL/NAME') = 0 )\n               CALL DO_DISKR\n            END\n            CALL DO_DISKR\n         END\n         CALL DO_DISKR\n      END\n      ELSE DO\n         CALL DO_DISKR\n         IF SUBSTR(LAYLINE,1,1) = '8B'X THEN DO\n            DO WHILE ( INDEX(LAYLINE,'FIELD LEVEL/NAME') = 0 )\n               CALL DO_DISKR\n            END\n            CALL DO_DISKR\n         END\n      END\n   END\n   SIGNAL GOT_LAYOUT\n\nDO_DISKR:\n   ADDRESS TSO \"EXECIO 1 DISKR\" LAYOUT\n   RETCODE = RC\n   IF RETCODE <> 0 THEN SIGNAL SHORT\n   PULL LAYLINE\n   RETURN\n\nFINISH_OCCURS:\n   CALL DO_DISKR\n   DO WHILE ( INDEX(LAYLINE,UBOUND) = 0 )\n      CALL DO_DISKR\n   END\n   IF SUBSTR(LAYLINE,78,1) = ' ' THEN DO\n      CALL DO_DISKR\n      IF SUBSTR(LAYLINE,1,1) = '8B'X THEN DO\n         DO WHILE ( INDEX(LAYLINE,'FIELD LEVEL/NAME') = 0 )\n            CALL DO_DISKR\n         END\n         CALL DO_DISKR\n      END\n   END\n   END_COL = SUBSTR(LAYLINE,68,03)\n   RETURN\n\nGET_COLS:\n   IF SUBSTR(LAYLINE,78,1) = ' ' THEN DO\n      CALL DO_DISKR\n      IF SUBSTR(LAYLINE,1,1) = '8B'X THEN DO\n         DO WHILE ( INDEX(LAYLINE,'FIELD LEVEL/NAME') = 0 )\n            CALL DO_DISKR\n         END\n         CALL DO_DISKR\n      END\n   END\n   START_COL = SUBSTR(LAYLINE,59,04)\n   END_COL   = SUBSTR(LAYLINE,68,03)\n   RETURN\n\nGET_OCCURS:\n   SCANSTR = SUBSTR(SCANSTR,1,LENGTH(SCANSTR)-3)\n   IF SUBSTR(LAYLINE,78,1) = ' ' THEN DO\n      CALL DO_DISKR\n      IF SUBSTR(LAYLINE,1,1) = '8B'X THEN DO\n         DO WHILE ( INDEX(LAYLINE,'FIELD LEVEL/NAME') = 0 )\n            CALL DO_DISKR\n         END\n         CALL DO_DISKR\n      END\n   END\n   START_COL = SUBSTR(LAYLINE,59,04)\n   CALL FINISH_OCCURS\n   RETURN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"COBCOLO - PLACE DATA OFFSETS IN COLUMN 73 THRU 80         \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    COBCOLO  ( ? )                                        \"\n   SAY\n   SAY \"       INVOKES FILEAID AND OTHER PROGRAMS TO DETERMINE    \"\n   SAY \"       COBOL DATA STRUCTURE OFFSETS AND PLACE THEM IN     \"\n   SAY \"       COLUMNS 73 THROUGH 80 AS ZZZ9-ZZ9.                 \"\n   SAY\n   SAY \"       THE RANGE OF OFFSETS IS 1 TO 9999, WHERE THE       \"\n   SAY \"       THOUSANDS PART OF THE 'TO' VALUE IS REMOVED.       \"\n   SAY\n   SAY \"       A QUESTION MARK WILL CAUSE THIS HELP TO BE SHOWN.  \"\n   SAY \"       C/C#/CC PREFIX COMMANDS MAY BE USED TO LIMIT THE   \"\n   SAY \"       LINES PROCESSED.                                   \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBCOLOI": {"ttr": 18692, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xe8\\x00\\xe8\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 232, "newlines": 232, "modlines": 0, "user": "REXX"}, "text": "/**  REXX  -- GEN COBOL OFFSETS IN COLUMNS 73 THRU 80             **/\n\n/**  COBCOLO USES INSYNC TO DETERMINE COBOL STRUCTURE OFFSETS     **/\n/**  AND PLACE THEM IN COLUMNS 73 THRU 80.  IT WILL WORK WITHIN   **/\n/**  A RANGE SPECIFIED BY C/CC/C## OR OVER THE ENTIRE FILE.       **/\n\n/**  THE OFFSETS ARE SHOWN AS Z999-999 WHERE Z IS THE THOUSANDS   **/\n/**  POSITION OR BLANK.                                           **/\n\n/*  SET UP ISPF ENVIRONMENT AND DETERMINE STARTING/ENDING LINES    */\n   SAVEMSG=MSG()\n   X=MSG(\"OFF\")\n   X=ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n         SAY \"COBCOLO MUST BE RUN UNDER ISPF EDIT!\"\n         SIGNAL QUIT\n       END\n   SUBCOM ISREDIT\n   UMODE = \"ISREDIT\"\n   ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n   ADDRESS ISREDIT\n   \"MACRO (PARM) NOPROCESS\"\n   IF PARM = \"?\" THEN SIGNAL DISPDOC\n   \"PROCESS RANGE C\"\n   IF RC > 0 THEN DO\n      \"(TOP) = LINENUM .ZFIRST\"\n      \"(BOT) = LINENUM .ZLAST\"\n   END\n   ELSE DO\n      \"(TOP) = LINENUM .ZFRANGE\"\n      \"(BOT) = LINENUM .ZLRANGE\"\n   END\n\n/*  DELETE OLD TEMP PDS FILE, IF ANY, AND ALLOCATE NEW ONE         */\n   ADDRESS TSO\n   \"FREE DD(DDXX #INDD)\"\n   \"DELETE $$$TEMP.COPYBOOK.PDS\"\n   \"ALLOCATE DD(#INDD) DSN($$$TEMP.COPYBOOK.PDS) NEW UNIT(SYSDA)\",\n      \"CYL SPACE(01 01) RECFM(F B) LRECL(80) BLKSIZE(27920) DIR(12)\"\n   \"ALLOCATE DD(DDXX) DSN($$$TEMP.COPYBOOK.PDS(DUMMYMEM)) SHR\"\n\n/*  WRITE LINES IN SPECIFIED RANGE TO TEMP PDS FILE AS MEMBER      */\n   \"EXECIO 0 DISKW\" DDXX \"(OPEN\"\n   GOT_FIRST = 'NO'\n   DO II = TOP TO BOT BY 1\n      \"ISREDIT (RECORD) = LINE &II\"\n      IF SUBSTR(RECORD,7,1) <> '*',\n               & SUBSTR(RECORD,7,1) <> '/',\n               & SUBSTR(RECORD,8,65) <> ' ' THEN DO\n         IF GOT_FIRST = 'NO' THEN DO\n            IF INDEX(SUBSTR(RECORD,8,4),'1') = 0 THEN DO\n               DUMMY_REC = '       01  DUMMY-01-LEVEL.'\n               PUSH DUMMY_REC\n               ADDRESS TSO \"EXECIO 1 DISKW\" DDXX\n            END\n            GOT_FIRST = 'YES'\n         END\n         BB = INDEX(RECORD,'( ');\n         DO WHILE ( BB <> 0 );\n            RECORD = SUBSTR(RECORD,1,BB) || SUBSTR(RECORD,BB+2)\n            BB = INDEX(RECORD,'( ');\n         END\n         PUSH RECORD\n         ADDRESS TSO \"EXECIO 1 DISKW\" DDXX\n      END\n   END\n   ADDRESS TSO\n   \"EXECIO 0 DISKW\" DDXX \"(FINIS\"\n   \"FREE DD(DDXX)\"\n\n/*  FREE & ALLOCATE FILES FOR CALL TO INSYNC                       */\n   \"FREE DD(#PARM #PRINT #LOG SYSTSPRT #ELIBDD)\"\n   \"DELETE $$$TEMP.PARM.FILE\"\n   \"ALLOC DD(#PARM) DSN($$$TEMP.PARM.FILE) NEW TRACKS SPACE(1)\",\n      \"UNIT(SYSDA) LRECL(80) BLKSIZE(800) RECFM(F B)\"\n   QUEUE \"FUNCTION=LAYOUT\"\n   QUEUE \"INDD=#INDD\"\n   QUEUE \"MEMBER=DUMMYMEM\"\n   QUEUE \"LINESPERPAGE=999\"\n   \"EXECIO\" QUEUED() \"DISKW #PARM (FINIS\"\n   \"DELETE $$$TEMP.PRINT.FILE\"\n   \"ALLOCATE DD(#PRINT) DSN($$$TEMP.PRINT.FILE) NEW UNIT(SYSDA)\",\n      \"CYL SPACE(10,10) RECFM(F B A) LRECL(133) BLKSIZE(27930)\",\n      \"RELEASE\"\n   \"DELETE $$$TEMP.LOG.FILE\"\n   \"ALLOCATE DD(#LOG) DSN($$$TEMP.LOG.FILE) NEW UNIT(SYSDA)\",\n      \"CYL SPACE(01,01) RECFM(F B A) LRECL(133) BLKSIZE(27930)\"\n   \"ALLOCATE DD(SYSTSPRT) DUMMY\"\n   \"ALLOCATE DD(#ELIBDD) DSN('TCH.PROD.INSYNC.ELIB') SHR\"\n   \"CALL 'TCH.PROD.INSYNC.LOADLIB(INSYNC)' 'MVS'\"\n\n/*  READ PRINT FILE AND STRIP OFF OFFSETS INTO LAST 8 BYTES OF   */\n/*  APPROPRIATE RECORDS                                          */\n   ADDRESS ISREDIT\n   ADDRESS TSO \"EXECIO 0 DISKR\" #PRINT \"(OPEN\"\n\n   CALL GET_LAYOUT\n   DO II = TOP TO BOT BY 1\n      IF INDEX(SCANSTR,'(1)') <> 0 THEN DO\n         CALL GET_OCCURS\n         \"ISREDIT (RECORD) = LINE &II\"\n         IF SCANSTR = \"FILLER\" THEN SCANSTR = END_COL - START_COL + 1\n         IF SUBSTR(RECORD,7,1) <> \"*\",\n               & SUBSTR(RECORD,7,1) <> \"/\",\n               & SUBSTR(RECORD,8,65) <> \" \",\n               & INDEX(RECORD,SCANSTR) <> 0 THEN DO\n            RECORD = SUBSTR(RECORD,1,72),\n               || START_COL || \"-\" || END_COL\n            \"ISREDIT LINE &II = &STR(RECORD)\"\n            CALL GET_LAYOUT\n         END\n      END\n      ELSE DO\n         IF INDEX(SCANSTR,'(') = 0 THEN DO\n            CALL GET_COLS\n            \"ISREDIT (RECORD) = LINE &II\"\n            IF SCANSTR = \"FILLER\" THEN SCANSTR = END_COL - START_COL + 1\n            IF SUBSTR(RECORD,7,1) <> \"*\",\n                  & SUBSTR(RECORD,7,1) <> \"/\",\n                  & SUBSTR(RECORD,8,65) <> \" \",\n                  & INDEX(RECORD,SCANSTR) <> 0 THEN DO\n               RECORD = SUBSTR(RECORD,1,72),\n                  || START_COL || \"-\" || END_COL\n               \"ISREDIT LINE &II = &STR(RECORD)\"\n               CALL GET_LAYOUT\n            END\n         END\n         ELSE CALL GET_LAYOUT\n      END\n   END II\n\nSHORT:\n   ADDRESS TSO \"EXECIO 0 DISKR\" #PRINT \"(FINIS\"\n   ADDRESS TSO\n   \"FREE DD(#PARM #INDD #PRINT #LOG SYSTSPRT #ELIBDD)\"\n   \"DELETE $$$TEMP.PARM.FILE\"\n   \"DELETE $$$TEMP.PRINT.FILE\"\n   \"DELETE $$$TEMP.COPYBOOK.PDS\"\n   \"DELETE $$$TEMP.LOG.FILE\"\n   ADDRESS ISPEXEC\n   X=MSG(SAVEMSG)\n   EXIT(0)\n\nGET_LAYOUT:\n   CALL DO_DISKR\n   IF RET_CD <> 0 THEN SIGNAL SHORT\n   IF INDEX(LAYLINE,'DUMMY-01-LEVEL') <> 0 THEN SIGNAL GET_LAYOUT\n   IF DATATYPE(SUBSTR(LAYLINE,8,1)) <> \"NUM\" THEN SIGNAL GET_LAYOUT\n   DO  NN = 61 TO 1 BY -1 WHILE ( SUBSTR(LAYLINE,NN,1) = ' ' )\n   END NN\n   DO  MM = NN TO 1 BY -1 WHILE ( SUBSTR(LAYLINE,MM,1) <> ' ' )\n   END MM\n   MM = MM + 1\n   SCANSTR = SUBSTR(LAYLINE,MM,NN-MM+1)\n   IF SCANSTR = 'DUMMY-01-LEVEL' THEN SIGNAL GET_LAYOUT\n   RETURN\n\nDO_DISKR:\n   ADDRESS TSO \"EXECIO 1 DISKR\" #PRINT\n   RET_CD = RC\n   IF RET_CD <> 0 THEN SIGNAL SHORT\n   PULL LAYLINE\n   IF SUBSTR(LAYLINE,1,1) = '1' THEN DO\n      DO WHILE ( INDEX(LAYLINE,'FIELD NAME') = 0 )\n         CALL DO_DISKR\n      END\n      CALL DO_DISKR\n      RET_CD = RC\n   END\n   RETURN\n\nGET_COLS:\n   START_COL = SUBSTR(LAYLINE,77,4)\n   DO SS = 80 TO 75 BY -1 WHILE ( SUBSTR(LAYLINE,SS,1) <> ' ' )\n   END SS\n   SS = SUBSTR(LAYLINE,SS+1,80-SS)\n   DO TT = 87 TO 82 BY -1 WHILE ( SUBSTR(LAYLINE,TT,1) <> ' ' )\n   END TT\n   TT = SUBSTR(LAYLINE,TT+1,87-TT)\n   UU = SS + TT - 1\n   END_COL = RIGHT(UU,3,' ')\n   RETURN\n\nGET_OCCURS:\n   SCANSTR = SUBSTR(SCANSTR,1,LENGTH(SCANSTR)-3)\n   START_COL = SUBSTR(LAYLINE,77,4)\n   CALL DO_DISKR\n   OO = INDEX(LAYLINE,'OCCURS')\n   IF OO <> 0 THEN DO\n      OO = OO + 6\n      DO PP = OO TO 61 BY 1 WHILE ( SUBSTR(LAYLINE,PP,1) = ' ')\n      END PP\n      DO QQ = PP+1 TO 61 BY 1 WHILE ( SUBSTR(LAYLINE,QQ,1) <> ' ')\n      END QQ\n      RR = SCANSTR || '(' || SUBSTR(LAYLINE,PP,QQ-PP) || ')'\n   END\n   CALL DO_DISKR\n   DO WHILE ( INDEX(LAYLINE,RR) = 0 )\n      CALL DO_DISKR\n   END\n   DO SS = 80 TO 75 BY -1 WHILE ( SUBSTR(LAYLINE,SS,1) <> ' ' )\n   END SS\n   SS = SUBSTR(LAYLINE,SS+1,80-SS)\n   DO TT = 87 TO 82 BY -1 WHILE ( SUBSTR(LAYLINE,TT,1) <> ' ' )\n   END TT\n   TT = SUBSTR(LAYLINE,TT+1,87-TT)\n   UU = SS + TT - 1\n   END_COL = RIGHT(UU,3,' ')\n   RETURN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"COBCOLO - PLACE DATA OFFSETS IN COLUMN 73 THRU 80         \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    COBCOLO  ( ? )                                        \"\n   SAY\n   SAY \"       INVOKES INSYNC AND OTHER PROGRAMS TO DETERMINE     \"\n   SAY \"       COBOL DATA STRUCTURE OFFSETS AND PLACE THEM IN     \"\n   SAY \"       COLUMNS 73 THROUGH 80 AS ZZZ9-ZZ9.                 \"\n   SAY\n   SAY \"       THE RANGE OF OFFSETS IS 1 TO 9999, WHERE THE       \"\n   SAY \"       THOUSANDS PART OF THE 'TO' VALUE IS REMOVED.       \"\n   SAY\n   SAY \"       A QUESTION MARK WILL CAUSE THIS HELP TO BE SHOWN.  \"\n   SAY \"       C/C#/CC PREFIX COMMANDS MAY BE USED TO LIMIT THE   \"\n   SAY \"       LINES PROCESSED.                                   \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBCOLSF": {"ttr": 18697, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x01\\x11\\x01\\x11\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 273, "newlines": 273, "modlines": 0, "user": "REXX"}, "text": "/**  REXX  -- GEN COBOL OFFSETS IN COLUMNS 73 THRU 80             **/\n\n/**  COBCOLS USES A PROGRAM TO DETERMINE COBOL STRUCTURE OFFSETS  **/\n/**  AND PLACE THEM IN COLUMNS 73 THRU 80.  IT WILL WORK WITHIN   **/\n/**  A RANGE SPECIFIED BY C/CC/C## OR OVER THE ENTIRE FILE. THE   **/\n/**  PROGRAM USED WILL IGNORE NON DATA ITEMS.                     **/\n\n/**  THE OFFSETS ARE SHOWN AS ZZZ9ZZZ9 WHERE Z REPRESENTS A       **/\n/**  BLANK OR A SIGNIFICANT DIGIT (I.E. NON ZERO).                **/\n\n/*  SET UP ISPF ENVIRONMENT AND DETERMINE STARTING/ENDING LINES    */\n   SAVEMSG=MSG()\n   X=MSG(\"OFF\")\n   X=ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n         SAY \"COBCOLS MUST BE RUN UNDER ISPF EDIT!\"\n         SIGNAL QUIT\n       END\n   SUBCOM ISREDIT\n   UMODE = \"ISREDIT\"\n   ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n   ADDRESS ISREDIT\n   \"MACRO (HUH) NOPROCESS\"\n   IF HUH = \"?\" THEN SIGNAL DISPDOC\n   \"PROCESS RANGE C\"\n   IF RC > 0 THEN\n      DO\n         \"(TOP) = LINENUM .ZFIRST\"\n         \"(BOT) = LINENUM .ZLAST\"\n      END\n   ELSE\n      DO\n         \"(TOP) = LINENUM .ZFRANGE\"\n         \"(BOT) = LINENUM .ZLRANGE\"\n      END\n\n/*  DELETE OLD TEMP PDS FILE, IF ANY, AND ALLOCATE NEW ONE         */\n   ADDRESS TSO\n   \"FREE DD(DDXX DD01)\"\n   \"DELETE $$$TEMP.COPYBOOK.PDS\"\n   \"ALLOCATE DD(DD01) DSN($$$TEMP.COPYBOOK.PDS) NEW\",\n      \"CYL SPACE(01 01) RECFM(F B) LRECL(80) BLKSIZE(27920) DIR(12)\"\n   \"ALLOCATE DD(DDXX) DSN($$$TEMP.COPYBOOK.PDS(DUMMYMEM)) SHR\"\n\n/*  WRITE LINES IN SPECIFIED RANGE TO TEMP PDS FILE AS MEMBER      */\n   ADDRESS ISREDIT\n   ADDRESS TSO \"EXECIO 0 DISKW\" DDXX \"(OPEN\"\n   GOT_FIRST = 'NO'\n   DO II = TOP TO BOT BY 1\n      \"ISREDIT (RECORD) = LINE &II\"\n      IF SUBSTR(RECORD,7,1) <> '*',\n               & SUBSTR(RECORD,7,1) <> '/',\n               & SUBSTR(RECORD,8,65) <> ' ' THEN DO\n         IF GOT_FIRST = 'NO' THEN DO\n            IF INDEX(SUBSTR(RECORD,8,4),'1') = 0 THEN DO\n               DUMMY_REC = '       01  DUMMY-01-LEVEL.'\n               PUSH DUMMY_REC\n               ADDRESS TSO \"EXECIO 1 DISKW\" DDXX\n            END\n            GOT_FIRST = 'YES'\n         END\n         BB = INDEX(RECORD,'( ');\n         DO WHILE ( BB <> 0 );\n            RECORD = SUBSTR(RECORD,1,BB) || SUBSTR(RECORD,BB+2)\n            BB = INDEX(RECORD,'( ');\n         END\n         PUSH RECORD\n         ADDRESS TSO \"EXECIO 1 DISKW\" DDXX\n      END\n   END\n   ADDRESS TSO \"EXECIO 0 DISKW\" DDXX \"(FINIS\"\n   ADDRESS TSO\n   \"FREE DD(DDXX DD01)\"\n\n/*  FREE & ALLOCATE DD01, SYSIN, SYSLIST AND SYSPRINT FILES        */\n/*  FOR INITIAL CALL TO FILEAID                                    */\n   ADDRESS TSO\n   \"FREE DD(DD01 SYSIN SYSLIST SYSPRINT)\"\n   \"ALLOCATE DD(DD01) DSN($$$TEMP.COPYBOOK.PDS) SHR\"\n   \"DELETE $$$TEMP.SYSIN.FILE1\"\n   \"ALLOC DD(SYSIN) DSN($$$TEMP.SYSIN.FILE1) NEW TRACKS SPACE(1)\",\n      \"LRECL(80) BLKSIZE(800) RECFM(F B)\"\n   QUEUE \"$$DD01 RLPRINT MEMBER=(DUMMYMEM)\"\n   \"EXECIO\" QUEUED() \"DISKW SYSIN (FINIS\"\n   \"DELETE $$$TEMP.SYSLIST.FILE\"\n   \"ALLOCATE DD(SYSLIST) DSN($$$TEMP.SYSLIST.FILE) NEW\",\n      \"CYL SPACE(01,01) RECFM(F,B) LRECL(80) BLKSIZE(27920)\"\n   \"ALLOCATE DD(SYSPRINT) DUMMY\",\n      \"RECFM(F,B) LRECL(133) BLKSIZE(6118)\"\n   \"CALL *(FILEAID)\"\n\n/*  READ SYSLIST FILE AND STRIP OFF OFFSETS INTO LAST 8 BYTES OF   */\n/*  APPROPRIATE RECORDS                                            */\n   ADDRESS ISREDIT\n   ADDRESS TSO \"FREE DD(LAYOUT)\"\n   ADDRESS TSO \"ALLOC DD(LAYOUT) DSN($$$TEMP.SYSLIST.FILE) SHR\"\n   ADDRESS TSO \"EXECIO 0 DISKR\" LAYOUT \"(OPEN\"\n\n   CALL GET_LAYOUT\n   DO II = TOP TO BOT BY 1\n      \"ISREDIT (RECORD) = LINE &II\"\n      IF INDEX(LAYLINE,' FILLER ') <> 0,\n            & INDEX(RECORD, ' FILLER ') = 0 THEN DO\n         SCANSTR = ' PIC '\n      END\n      IF SUBSTR(RECORD,7,1) <> \"*\",\n            & SUBSTR(RECORD,7,1) <> \"/\",\n            & INDEX(RECORD,SCANSTR) <> 0 THEN DO\n         RECORD = SUBSTR(RECORD,1,72) || START_COL || END_COL\n         \"ISREDIT LINE &II = &STR(RECORD)\"\n         CALL GET_LAYOUT\n      END\n   END II\n\nSHORT:\n   ADDRESS TSO \"EXECIO 0 DISKR\" LAYOUT \"(FINIS\"\n   ADDRESS TSO \"FREE DD(LAYOUT)\"\n   ADDRESS TSO\n   \"DELETE $$$TEMP.COPYBOOK.PDS\"\n   \"DELETE $$$TEMP.SYSIN.FILE1\"\n   \"DELETE $$$TEMP.SYSLIST.FILE\"\n   ADDRESS ISPEXEC\n   X=MSG(SAVEMSG)\n   ADDRESS ISREDIT \"LOCATE\" TOP\n   ADDRESS ISREDIT \"RESET\"\n   EXIT(1)\n\nGET_LAYOUT:\n   CALL DO_DISKR\nGOT_LAYOUT:\n   IF SUBSTR(LAYLINE,1,1) = '8B'X THEN DO\n      DO WHILE ( INDEX(LAYLINE,'FIELD LEVEL/NAME') = 0 )\n         CALL DO_DISKR\n      END\n      CALL DO_DISKR\n   END\n   IF INDEX(LAYLINE,'DUMMY-01-LEVEL') <> 0 THEN SIGNAL GET_LAYOUT\n   IF INDEX(LAYLINE,'END OF LAYOUT REPORT') <> 0 THEN SIGNAL SHORT\n   IF INDEX(LAYLINE,' REDEFINES ') <> 0 THEN DO\n      RR = INDEX(LAYLINE,' REDEFINES ')\n      RR = RR + 10\n      IF SUBSTR(LAYLINE,RR) = ' ' THEN CALL DO_DISKR\n      SIGNAL GET_LAYOUT\n   END\n   IF SUBSTR(LAYLINE,2) = ' '           THEN SIGNAL GET_LAYOUT\n   LAYLINE = ' ' || SUBSTR(LAYLINE,2)\n   DO  MM = 1 TO 80  WHILE ( SUBSTR(LAYLINE,MM,1) = ' ' )\n   END MM\n   DO  NN = MM TO 80 WHILE ( SUBSTR(LAYLINE,NN,1) <> ' ' )\n   END NN\n   IF DATATYPE(SUBSTR(LAYLINE,MM,NN-MM)) = \"NUM\" THEN DO\n      DO  MM = NN TO 80 WHILE ( SUBSTR(LAYLINE,MM,1) = ' ' )\n      END MM\n      DO  NN = MM TO 80 WHILE ( SUBSTR(LAYLINE,NN,1) <> ' ' )\n      END NN\n   END\n   SCANSTR = SUBSTR(LAYLINE,MM-1,NN-MM+1)\n   IF INDEX(LAYLINE,' OCCURS ') <> 0 THEN DO\n      OO = INDEX(LAYLINE,' OCCURS ')\n      DO  PP = OO+7 TO 80 WHILE (SUBSTR(LAYLINE,PP,1) =  ' ' )\n      END PP\n      DO  QQ = PP+1 TO 80 WHILE (SUBSTR(LAYLINE,QQ,1) <> ' ' )\n      END QQ\n      UBOUND = '(' || SUBSTR(LAYLINE,PP,QQ-PP) || ')'\n      CALL GET_OCCURS\n   END\n   ELSE DO\n      IF UBOUND <> 'UBOUND' THEN DO\n         IF INDEX(SCANSTR,UBOUND) <> 0,\n            THEN CALL CLEAR_OCCURS\n            ELSE CALL GET_COLS\n      END\n      ELSE CALL GET_COLS\n   END\n   RETURN\n\nCLEAR_OCCURS:\n   DO WHILE(INDEX(LAYLINE,UBOUND) <> 0)\n      IF SUBSTR(LAYLINE,78,1) = ' ' THEN DO\n         CALL DO_DISKR\n         IF SUBSTR(LAYLINE,1,1) = '8B'X THEN DO\n            DO WHILE ( INDEX(LAYLINE,'FIELD LEVEL/NAME') = 0 )\n               CALL DO_DISKR\n            END\n            CALL DO_DISKR\n         END\n         CALL DO_DISKR\n      END\n      ELSE DO\n         CALL DO_DISKR\n         IF SUBSTR(LAYLINE,1,1) = '8B'X THEN DO\n            DO WHILE ( INDEX(LAYLINE,'FIELD LEVEL/NAME') = 0 )\n               CALL DO_DISKR\n            END\n            CALL DO_DISKR\n         END\n      END\n   END\n   SIGNAL GOT_LAYOUT\n\nDO_DISKR:\n   ADDRESS TSO \"EXECIO 1 DISKR\" LAYOUT\n   RETCODE = RC\n   IF RETCODE <> 0 THEN SIGNAL SHORT\n   PULL LAYLINE\n   RETURN\n\nFINISH_OCCURS:\n   CALL DO_DISKR\n   DO WHILE ( INDEX(LAYLINE,UBOUND) = 0 )\n      CALL DO_DISKR\n   END\n   IF SUBSTR(LAYLINE,78,1) = ' ' THEN DO\n      CALL DO_DISKR\n      IF SUBSTR(LAYLINE,1,1) = '8B'X THEN DO\n         DO WHILE ( INDEX(LAYLINE,'FIELD LEVEL/NAME') = 0 )\n            CALL DO_DISKR\n         END\n         CALL DO_DISKR\n      END\n   END\n   END_COL = SUBSTR(LAYLINE,67,04)\n   RETURN\n\nGET_COLS:\n   IF SUBSTR(LAYLINE,78,1) = ' ' THEN DO\n      CALL DO_DISKR\n      IF SUBSTR(LAYLINE,1,1) = '8B'X THEN DO\n         DO WHILE ( INDEX(LAYLINE,'FIELD LEVEL/NAME') = 0 )\n            CALL DO_DISKR\n         END\n         CALL DO_DISKR\n      END\n   END\n   START_COL = SUBSTR(LAYLINE,59,04)\n   END_COL   = SUBSTR(LAYLINE,67,04)\n   RETURN\n\nGET_OCCURS:\n   SCANSTR = SUBSTR(SCANSTR,1,LENGTH(SCANSTR)-3)\n   IF SUBSTR(LAYLINE,78,1) = ' ' THEN DO\n      CALL DO_DISKR\n      IF SUBSTR(LAYLINE,1,1) = '8B'X THEN DO\n         DO WHILE ( INDEX(LAYLINE,'FIELD LEVEL/NAME') = 0 )\n            CALL DO_DISKR\n         END\n         CALL DO_DISKR\n      END\n   END\n   START_COL = SUBSTR(LAYLINE,59,04)\n   CALL FINISH_OCCURS\n   RETURN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"COBCOLS - PLACE DATA OFFSETS IN COLUMN 73 THRU 80         \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    COBCOLS  ( ? )                                        \"\n   SAY\n   SAY \"       INVOKES FILEAID AND OTHER PROGRAMS TO DETERMINE    \"\n   SAY \"       COBOL DATA STRUCTURE OFFSETS AND PLACE THEM IN     \"\n   SAY \"       COLUMNS 73 THROUGH 80 AS ZZZ9ZZZ9. THE RANGE IS    \"\n   SAY \"       1 TO 9999.                                         \"\n   SAY\n   SAY \"       A QUESTION MARK WILL CAUSE THIS HELP TO BE SHOWN.  \"\n   SAY \"       C/C#/CC PREFIX COMMANDS MAY BE USED TO LIMIT THE   \"\n   SAY \"       LINES PROCESSED.                                   \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBCOLSI": {"ttr": 18947, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xe6\\x00\\xe6\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 230, "newlines": 230, "modlines": 0, "user": "REXX"}, "text": "/**  REXX  -- GEN COBOL OFFSETS IN COLUMNS 73 THRU 80             **/\n\n/**  COBCOLS USES INSYNC TO DETERMINE COBOL STRUCTURE OFFSETS     **/\n/**  AND PLACE THEM IN COLUMNS 73 THRU 80.  IT WILL WORK WITHIN   **/\n/**  A RANGE SPECIFIED BY C/CC/C## OR OVER THE ENTIRE FILE.       **/\n\n/**  THE OFFSETS ARE SHOWN AS ZZZ9ZZZ9.                           **/\n\n/*  SET UP ISPF ENVIRONMENT AND DETERMINE STARTING/ENDING LINES    */\n   SAVEMSG=MSG()\n   X=MSG(\"OFF\")\n   X=ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n         SAY \"COBCOLS MUST BE RUN UNDER ISPF EDIT!\"\n         SIGNAL QUIT\n       END\n   SUBCOM ISREDIT\n   UMODE = \"ISREDIT\"\n   ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n   ADDRESS ISREDIT\n   \"MACRO (PARM) NOPROCESS\"\n   IF PARM = \"?\" THEN SIGNAL DISPDOC\n   \"PROCESS RANGE C\"\n   IF RC > 0 THEN DO\n      \"(TOP) = LINENUM .ZFIRST\"\n      \"(BOT) = LINENUM .ZLAST\"\n   END\n   ELSE DO\n      \"(TOP) = LINENUM .ZFRANGE\"\n      \"(BOT) = LINENUM .ZLRANGE\"\n   END\n\n/*  DELETE OLD TEMP PDS FILE, IF ANY, AND ALLOCATE NEW ONE         */\n   ADDRESS TSO\n   \"FREE DD(DDXX #INDD)\"\n   \"DELETE $$$TEMP.COPYBOOK.PDS\"\n   \"ALLOCATE DD(#INDD) DSN($$$TEMP.COPYBOOK.PDS) NEW UNIT(SYSDA)\",\n      \"CYL SPACE(01 01) RECFM(F B) LRECL(80) BLKSIZE(27920) DIR(12)\"\n   \"ALLOCATE DD(DDXX) DSN($$$TEMP.COPYBOOK.PDS(DUMMYMEM)) SHR\"\n\n/*  WRITE LINES IN SPECIFIED RANGE TO TEMP PDS FILE AS MEMBER      */\n   \"EXECIO 0 DISKW\" DDXX \"(OPEN\"\n   GOT_FIRST = 'NO'\n   DO II = TOP TO BOT BY 1\n      \"ISREDIT (RECORD) = LINE &II\"\n      IF SUBSTR(RECORD,7,1) <> '*',\n               & SUBSTR(RECORD,7,1) <> '/',\n               & SUBSTR(RECORD,8,65) <> ' ' THEN DO\n         IF GOT_FIRST = 'NO' THEN DO\n            IF INDEX(SUBSTR(RECORD,8,4),'1') = 0 THEN DO\n               DUMMY_REC = '       01  DUMMY-01-LEVEL.'\n               PUSH DUMMY_REC\n               ADDRESS TSO \"EXECIO 1 DISKW\" DDXX\n            END\n            GOT_FIRST = 'YES'\n         END\n         BB = INDEX(RECORD,'( ');\n         DO WHILE ( BB <> 0 );\n            RECORD = SUBSTR(RECORD,1,BB) || SUBSTR(RECORD,BB+2)\n            BB = INDEX(RECORD,'( ');\n         END\n         PUSH RECORD\n         ADDRESS TSO \"EXECIO 1 DISKW\" DDXX\n      END\n   END\n   ADDRESS TSO\n   \"EXECIO 0 DISKW\" DDXX \"(FINIS\"\n   \"FREE DD(DDXX)\"\n\n/*  FREE & ALLOCATE FILES FOR CALL TO INSYNC                       */\n   \"FREE DD(#PARM #PRINT #LOG SYSTSPRT #ELIBDD)\"\n   \"DELETE $$$TEMP.PARM.FILE\"\n   \"ALLOC DD(#PARM) DSN($$$TEMP.PARM.FILE) NEW TRACKS SPACE(1)\",\n      \"UNIT(SYSDA) LRECL(80) BLKSIZE(800) RECFM(F B)\"\n   QUEUE \"FUNCTION=LAYOUT\"\n   QUEUE \"INDD=#INDD\"\n   QUEUE \"MEMBER=DUMMYMEM\"\n   QUEUE \"LINESPERPAGE=999\"\n   \"EXECIO\" QUEUED() \"DISKW #PARM (FINIS\"\n   \"DELETE $$$TEMP.PRINT.FILE\"\n   \"ALLOCATE DD(#PRINT) DSN($$$TEMP.PRINT.FILE) NEW UNIT(SYSDA)\",\n      \"CYL SPACE(10,10) RECFM(F B A) LRECL(133) BLKSIZE(27930)\",\n      \"RELEASE\"\n   \"DELETE $$$TEMP.LOG.FILE\"\n   \"ALLOCATE DD(#LOG) DSN($$$TEMP.LOG.FILE) NEW UNIT(SYSDA)\",\n      \"CYL SPACE(01,01) RECFM(F B A) LRECL(133) BLKSIZE(27930)\"\n   \"ALLOCATE DD(SYSTSPRT) DUMMY\"\n   \"ALLOCATE DD(#ELIBDD) DSN('TCH.PROD.INSYNC.ELIB') SHR\"\n   \"CALL 'TCH.PROD.INSYNC.LOADLIB(INSYNC)' 'MVS'\"\n\n/*  READ PRINT FILE AND STRIP OFF OFFSETS INTO LAST 8 BYTES OF   */\n/*  APPROPRIATE RECORDS                                          */\n   ADDRESS ISREDIT\n   ADDRESS TSO \"EXECIO 0 DISKR\" #PRINT \"(OPEN\"\n\n   CALL GET_LAYOUT\n   DO II = TOP TO BOT BY 1\n      IF INDEX(SCANSTR,'(1)') <> 0 THEN DO\n         CALL GET_OCCURS\n         \"ISREDIT (RECORD) = LINE &II\"\n         IF SCANSTR = \"FILLER\" THEN SCANSTR = END_COL - START_COL + 1\n         IF SUBSTR(RECORD,7,1) <> \"*\",\n               & SUBSTR(RECORD,7,1) <> \"/\",\n               & SUBSTR(RECORD,8,65) <> \" \",\n               & INDEX(RECORD,SCANSTR) <> 0 THEN DO\n            RECORD = SUBSTR(RECORD,1,72),\n               || START_COL || END_COL\n            \"ISREDIT LINE &II = &STR(RECORD)\"\n            CALL GET_LAYOUT\n         END\n      END\n      ELSE DO\n         IF INDEX(SCANSTR,'(') = 0 THEN DO\n            CALL GET_COLS\n            \"ISREDIT (RECORD) = LINE &II\"\n            IF SCANSTR = \"FILLER\" THEN SCANSTR = END_COL - START_COL + 1\n            IF SUBSTR(RECORD,7,1) <> \"*\",\n                  & SUBSTR(RECORD,7,1) <> \"/\",\n                  & SUBSTR(RECORD,8,65) <> \" \",\n                  & INDEX(RECORD,SCANSTR) <> 0 THEN DO\n               RECORD = SUBSTR(RECORD,1,72),\n                  || START_COL || END_COL\n               \"ISREDIT LINE &II = &STR(RECORD)\"\n               CALL GET_LAYOUT\n            END\n         END\n         ELSE CALL GET_LAYOUT\n      END\n   END II\n\nSHORT:\n   ADDRESS TSO \"EXECIO 0 DISKR\" #PRINT \"(FINIS\"\n   ADDRESS TSO\n   \"FREE DD(#PARM #INDD #PRINT #LOG SYSTSPRT #ELIBDD)\"\n   \"DELETE $$$TEMP.PARM.FILE\"\n   \"DELETE $$$TEMP.PRINT.FILE\"\n   \"DELETE $$$TEMP.COPYBOOK.PDS\"\n   \"DELETE $$$TEMP.LOG.FILE\"\n   ADDRESS ISPEXEC\n   X=MSG(SAVEMSG)\n   EXIT(0)\n\nGET_LAYOUT:\n   CALL DO_DISKR\n   IF RET_CD <> 0 THEN SIGNAL SHORT\n   IF INDEX(LAYLINE,'DUMMY-01-LEVEL') <> 0 THEN SIGNAL GET_LAYOUT\n   IF DATATYPE(SUBSTR(LAYLINE,8,1)) <> \"NUM\" THEN SIGNAL GET_LAYOUT\n   DO  NN = 61 TO 1 BY -1 WHILE ( SUBSTR(LAYLINE,NN,1) = ' ' )\n   END NN\n   DO  MM = NN TO 1 BY -1 WHILE ( SUBSTR(LAYLINE,MM,1) <> ' ' )\n   END MM\n   MM = MM + 1\n   SCANSTR = SUBSTR(LAYLINE,MM,NN-MM+1)\n   IF SCANSTR = 'DUMMY-01-LEVEL' THEN SIGNAL GET_LAYOUT\n   RETURN\n\nDO_DISKR:\n   ADDRESS TSO \"EXECIO 1 DISKR\" #PRINT\n   RET_CD = RC\n   IF RET_CD <> 0 THEN SIGNAL SHORT\n   PULL LAYLINE\n   IF SUBSTR(LAYLINE,1,1) = '1' THEN DO\n      DO WHILE ( INDEX(LAYLINE,'FIELD NAME') = 0 )\n         CALL DO_DISKR\n      END\n      CALL DO_DISKR\n      RET_CD = RC\n   END\n   RETURN\n\nGET_COLS:\n   START_COL = SUBSTR(LAYLINE,77,4)\n   DO SS = 80 TO 75 BY -1 WHILE ( SUBSTR(LAYLINE,SS,1) <> ' ' )\n   END SS\n   SS = SUBSTR(LAYLINE,SS+1,80-SS)\n   DO TT = 87 TO 82 BY -1 WHILE ( SUBSTR(LAYLINE,TT,1) <> ' ' )\n   END TT\n   TT = SUBSTR(LAYLINE,TT+1,87-TT)\n   UU = SS + TT - 1\n   END_COL = RIGHT(UU,4,' ')\n   RETURN\n\nGET_OCCURS:\n   SCANSTR = SUBSTR(SCANSTR,1,LENGTH(SCANSTR)-3)\n   START_COL = SUBSTR(LAYLINE,77,4)\n   CALL DO_DISKR\n   OO = INDEX(LAYLINE,'OCCURS')\n   IF OO <> 0 THEN DO\n      OO = OO + 6\n      DO PP = OO TO 61 BY 1 WHILE ( SUBSTR(LAYLINE,PP,1) = ' ')\n      END PP\n      DO QQ = PP+1 TO 61 BY 1 WHILE ( SUBSTR(LAYLINE,QQ,1) <> ' ')\n      END QQ\n      RR = SCANSTR || '(' || SUBSTR(LAYLINE,PP,QQ-PP) || ')'\n   END\n   CALL DO_DISKR\n   DO WHILE ( INDEX(LAYLINE,RR) = 0 )\n      CALL DO_DISKR\n   END\n   DO SS = 80 TO 75 BY -1 WHILE ( SUBSTR(LAYLINE,SS,1) <> ' ' )\n   END SS\n   SS = SUBSTR(LAYLINE,SS+1,80-SS)\n   DO TT = 87 TO 82 BY -1 WHILE ( SUBSTR(LAYLINE,TT,1) <> ' ' )\n   END TT\n   TT = SUBSTR(LAYLINE,TT+1,87-TT)\n   UU = SS + TT - 1\n   END_COL = RIGHT(UU,4,' ')\n   RETURN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"COBCOLS - PLACE DATA OFFSETS IN COLUMN 73 THRU 80         \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    COBCOLS  ( ? )                                        \"\n   SAY\n   SAY \"       INVOKES INSYNC AND OTHER PROGRAMS TO DETERMINE     \"\n   SAY \"       COBOL DATA STRUCTURE OFFSETS AND PLACE THEM IN     \"\n   SAY \"       COLUMNS 73 THROUGH 80 AS ZZZ9ZZZ9.                 \"\n   SAY\n   SAY \"       THE RANGE OF OFFSETS IS 1 TO 9999.                 \"\n   SAY\n   SAY \"       A QUESTION MARK WILL CAUSE THIS HELP TO BE SHOWN.  \"\n   SAY \"       C/C#/CC PREFIX COMMANDS MAY BE USED TO LIMIT THE   \"\n   SAY \"       LINES PROCESSED.                                   \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBCOLVF": {"ttr": 18952, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00s\\x00s\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 115, "newlines": 115, "modlines": 0, "user": "REXX"}, "text": "/**  REXX  -- VIEW COBOL COLUMN OFFSETS FROM FILEAID              **/\n\n/*  SET UP ISPF ENVIRONMENT AND DETERMINE STARTING/ENDING LINES    */\n   SAVEMSG=MSG()\n   X=MSG(\"OFF\")\n   X=ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n         SAY \"COBCOLS MUST BE RUN UNDER ISPF EDIT!\"\n         SIGNAL QUIT\n       END\n   SUBCOM ISREDIT\n   UMODE = \"ISREDIT\"\n   ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n   ADDRESS ISREDIT\n   \"MACRO (HUH) NOPROCESS\"\n   IF HUH = \"?\" THEN SIGNAL DISPDOC\n   \"PROCESS RANGE C\"\n   IF RC > 0 THEN\n      DO\n         \"(TOP) = LINENUM .ZFIRST\"\n         \"(BOT) = LINENUM .ZLAST\"\n      END\n   ELSE\n      DO\n         \"(TOP) = LINENUM .ZFRANGE\"\n         \"(BOT) = LINENUM .ZLRANGE\"\n      END\n\n/*  DELETE OLD TEMP PDS FILE, IF ANY, AND ALLOCATE NEW ONE         */\n   ADDRESS TSO\n   \"FREE DD(DDXX DD01)\"\n   \"DELETE $$$TEMP.COPYBOOK.PDS\"\n   \"ALLOCATE DD(DD01) DSN($$$TEMP.COPYBOOK.PDS) NEW\",\n      \"CYL SPACE(01 01) RECFM(F B) LRECL(80) BLKSIZE(27920) DIR(12)\"\n   \"ALLOCATE DD(DDXX) DSN($$$TEMP.COPYBOOK.PDS(DUMMYMEM)) SHR\"\n\n/*  WRITE LINES IN SPECIFIED RANGE TO TEMP PDS FILE AS MEMBER      */\n   ADDRESS ISREDIT\n   ADDRESS TSO \"EXECIO 0 DISKW\" DDXX \"(OPEN\"\n   GOT_FIRST = 'NO'\n   DO II = TOP TO BOT BY 1\n      \"ISREDIT (RECORD) = LINE &II\"\n      IF SUBSTR(RECORD,7,1) <> '*',\n               & SUBSTR(RECORD,7,1) <> '/',\n               & SUBSTR(RECORD,8,65) <> ' ' THEN DO\n         IF GOT_FIRST = 'NO' THEN DO\n            IF INDEX(SUBSTR(RECORD,8,4),'1') = 0 THEN DO\n               DUMMY_REC = '       01  DUMMY-01-LEVEL.'\n               PUSH DUMMY_REC\n               ADDRESS TSO \"EXECIO 1 DISKW\" DDXX\n            END\n            GOT_FIRST = 'YES'\n         END\n         BB = INDEX(RECORD,'( ');\n         DO WHILE ( BB <> 0 );\n            RECORD = SUBSTR(RECORD,1,BB) || SUBSTR(RECORD,BB+2)\n            BB = INDEX(RECORD,'( ');\n         END\n         PUSH RECORD\n         ADDRESS TSO \"EXECIO 1 DISKW\" DDXX\n      END\n   END\n   ADDRESS TSO \"EXECIO 0 DISKW\" DDXX \"(FINIS\"\n   ADDRESS TSO\n   \"FREE DD(DDXX DD01)\"\n\n/*  FREE & ALLOCATE DD01, SYSIN, SYSLIST AND SYSPRINT FILES        */\n/*  FOR INITIAL CALL TO FILEAID                                    */\n   ADDRESS TSO\n   \"FREE DD(DD01 SYSIN SYSLIST SYSPRINT)\"\n   \"ALLOCATE DD(DD01) DSN($$$TEMP.COPYBOOK.PDS) SHR\"\n   \"DELETE $$$TEMP.SYSIN.FILE1\"\n   \"ALLOC DD(SYSIN) DSN($$$TEMP.SYSIN.FILE1) NEW TRACKS SPACE(1)\",\n      \"LRECL(80) BLKSIZE(800) RECFM(F B)\"\n   QUEUE \"$$DD01 RLPRINT MEMBER=(DUMMYMEM)\"\n   \"EXECIO\" QUEUED() \"DISKW SYSIN (FINIS\"\n   \"DELETE $$$TEMP.SYSLIST.FILE\"\n   \"ALLOCATE DD(SYSLIST) DSN($$$TEMP.SYSLIST.FILE) NEW\",\n      \"CYL SPACE(01,01) RECFM(F,B) LRECL(80) BLKSIZE(27920)\"\n   \"ALLOCATE DD(SYSPRINT) DUMMY\",\n      \"RECFM(F,B) LRECL(133) BLKSIZE(6118)\"\n   \"CALL *(FILEAID)\"\n   \"FREE DD(DD01 SYSIN SYSLIST SYSPRINT)\"\n\n/*  VIEW SYSLIST FILE AND THEN QUIT                                */\n   ADDRESS ISPEXEC 'VIEW DATASET('$$$TEMP.SYSLIST.FILE')'\n   ADDRESS TSO\n   \"DELETE $$$TEMP.COPYBOOK.PDS\"\n   \"DELETE $$$TEMP.SYSIN.FILE1\"\n   \"DELETE $$$TEMP.SYSLIST.FILE\"\n   ADDRESS ISPEXEC\n   X=MSG(SAVEMSG)\n   ADDRESS ISREDIT \"LOCATE\" TOP\n   ADDRESS ISREDIT \"RESET\"\n   EXIT(1)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"COBCOLV - SHOW FILEAID COBOL STRUCTURE OFFSETS            \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    COBCOLV  ( ? )                                        \"\n   SAY\n   SAY \"       INVOKES FILEAID AGAINST A COBOL STRUCTURE AND      \"\n   SAY \"       VIEWS THE RESULTING OUTPUT WHICH HAS STARTING AND  \"\n   SAY \"       ENDING POSITIONS OF EACH VARIABLE.                 \"\n   SAY\n   SAY \"       A QUESTION MARK WILL CAUSE THIS HELP TO BE SHOWN.  \"\n   SAY \"       C/C#/CC PREFIX COMMANDS MAY BE USED TO LIMIT THE   \"\n   SAY \"       LINES PROCESSED.                                   \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBCOLVI": {"ttr": 18955, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x9c\\x00\\x9c\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 156, "newlines": 156, "modlines": 0, "user": "REXX"}, "text": "/**  REXX  -- VIEW COBOL COLUMN OFFSETS FROM INSYNC               **/\n\n/*  SET UP ISPF ENVIRONMENT AND DETERMINE STARTING/ENDING LINES    */\n   SAVEMSG=MSG()\n   X=MSG(\"OFF\")\n   X=ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY \"COBCOLV MUST BE RUN UNDER ISPF EDIT!\"\n      SIGNAL QUIT\n   END\n   SUBCOM ISREDIT\n   UMODE = \"ISREDIT\"\n   ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n   ADDRESS ISREDIT\n   \"MACRO (PARM) NOPROCESS\"\n   IF PARM = \"?\" THEN SIGNAL DISPDOC\n   \"PROCESS RANGE C\"\n   IF RC > 0 THEN DO\n      \"(TOP) = LINENUM .ZFIRST\"\n      \"(BOT) = LINENUM .ZLAST\"\n   END\n   ELSE DO\n      \"(TOP) = LINENUM .ZFRANGE\"\n      \"(BOT) = LINENUM .ZLRANGE\"\n   END\n\n/*  DELETE OLD TEMP PDS FILE, IF ANY, AND ALLOCATE NEW ONE         */\n   ADDRESS TSO\n   \"FREE DD(DDXX #INDD)\"\n   \"DELETE $$$TEMP.COPYBOOK.PDS\"\n   \"ALLOCATE DD(#INDD) DSN($$$TEMP.COPYBOOK.PDS) NEW UNIT(SYSDA)\",\n      \"CYL SPACE(01 01) RECFM(F B) LRECL(80) BLKSIZE(27920) DIR(12)\"\n   \"ALLOCATE DD(DDXX) DSN($$$TEMP.COPYBOOK.PDS(DUMMYMEM)) SHR\"\n\n/*  WRITE LINES IN SPECIFIED RANGE TO TEMP PDS FILE AS MEMBER      */\n   \"EXECIO 0 DISKW\" DDXX \"(OPEN\"\n   GOT_FIRST = 'NO'\n   DO II = TOP TO BOT BY 1\n      \"ISREDIT (RECORD) = LINE &II\"\n      IF SUBSTR(RECORD,7,1) <> '*',\n               & SUBSTR(RECORD,7,1) <> '/',\n               & SUBSTR(RECORD,8,65) <> ' ' THEN DO\n         IF GOT_FIRST = 'NO' THEN DO\n            IF INDEX(SUBSTR(RECORD,8,4),'1') = 0 THEN DO\n               DUMMY_REC = '       01  DUMMY-01-LEVEL.'\n               PUSH DUMMY_REC\n               ADDRESS TSO \"EXECIO 1 DISKW\" DDXX\n            END\n            GOT_FIRST = 'YES'\n         END\n         BB = INDEX(RECORD,'( ');\n         DO WHILE ( BB <> 0 );\n            RECORD = SUBSTR(RECORD,1,BB) || SUBSTR(RECORD,BB+2)\n            BB = INDEX(RECORD,'( ');\n         END\n         PUSH RECORD\n         ADDRESS TSO \"EXECIO 1 DISKW\" DDXX\n      END\n   END\n   ADDRESS TSO\n   \"EXECIO 0 DISKW\" DDXX \"(FINIS\"\n   \"FREE DD(DDXX)\"\n\n/*  FREE & ALLOCATE FILES FOR CALL TO INSYNC                       */\n   \"FREE DD(#PARM #PRINT XPRINT #LOG SYSTSPRT #ELIBDD)\"\n   \"DELETE $$$TEMP.PARM.FILE\"\n   \"ALLOC DD(#PARM) DSN($$$TEMP.PARM.FILE) NEW TRACKS SPACE(1)\",\n      \"UNIT(SYSDA) LRECL(80) BLKSIZE(800) RECFM(F B)\"\n   QUEUE \"FUNCTION=LAYOUT\"\n   QUEUE \"INDD=#INDD\"\n   QUEUE \"MEMBER=DUMMYMEM\"\n   QUEUE \"LINESPERPAGE=999\"\n   \"EXECIO\" QUEUED() \"DISKW #PARM (FINIS\"\n   \"DELETE $$$TEMP.PRINT.FILE\"\n   \"ALLOCATE DD(#PRINT) DSN($$$TEMP.PRINT.FILE) NEW UNIT(SYSDA)\",\n      \"CYL SPACE(10,10) RECFM(F B A) LRECL(133) BLKSIZE(27930)\",\n      \"RELEASE\"\n   \"DELETE $$$TEMP.LOG.FILE\"\n   \"ALLOCATE DD(#LOG) DSN($$$TEMP.LOG.FILE) NEW UNIT(SYSDA)\",\n      \"CYL SPACE(01,01) RECFM(F B A) LRECL(133) BLKSIZE(27930)\"\n   \"ALLOCATE DD(SYSTSPRT) DUMMY\"\n   \"ALLOCATE DD(#ELIBDD) DSN('TCH.PROD.INSYNC.ELIB') SHR\"\n   \"CALL 'TCH.PROD.INSYNC.LOADLIB(INSYNC)' 'MVS'\"\n\n/*  SHRINK PRINTED OUTPUT TO FIT WITHIN 72 COLUMNS               */\n   \"DELETE $$$TEMP.PRINTX.FILE\"\n   \"ALLOCATE DD(XPRINT) DSN($$$TEMP.PRINTX.FILE) NEW UNIT(SYSDA)\",\n      \"CYL SPACE(01,01) RECFM(F B) LRECL(72) BLKSIZE(27936)\"\n   \"EXECIO 0 DISKR\" #PRINT \"(OPEN\"\n   \"EXECIO 0 DISKW\" XPRINT \"(OPEN\"\n   \"EXECIO 1 DISKR\" #PRINT\n   RETCODE = RC\n\n   DO WHILE ( RETCODE = 0 )\n      PULL PRTLINE\n      IF SUBSTR(PRTLINE,1,1) = \"1\" THEN DO\n         \"EXECIO 1 DISKR\" #PRINT\n         PULL PRTLINE\n         \"EXECIO 1 DISKR\" #PRINT\n         PULL PRTLINE\n         \"EXECIO 1 DISKR\" #PRINT\n         PULL PRTLINE\n         \"EXECIO 1 DISKR\" #PRINT\n         PULL PRTLINE\n         \"EXECIO 1 DISKR\" #PRINT\n         RETCODE = RC\n      END\n      ELSE DO\n         IF SUBSTR(PRTLINE,63,05) <> \"VALUE\" THEN DO\n            SHRUNK = SUBSTR(PRTLINE,11,51),\n               || SUBSTR(PRTLINE,63,09),\n               || SUBSTR(PRTLINE,76,12)\n         END\n         ELSE DO\n            SHRUNK = SUBSTR(PRTLINE,11,51),\n               || SUBSTR(PRTLINE,63,21)\n         END\n         PUSH SHRUNK\n         \"EXECIO 1 DISKW\" XPRINT\n         \"EXECIO 1 DISKR\" #PRINT\n         RETCODE = RC\n      END\n   END\n   \"EXECIO 0 DISKR\" #PRINT \"(FINIS\"\n   \"EXECIO 0 DISKW\" XPRINT \"(FINIS\"\n\n/*  VIEW SHRUNKEN PRINT FILE  */\n   ADDRESS ISPEXEC \"SELECT PGM(ISPSTRT)\",\n      \"PARM(CMD(ISREPDF \"$$$TEMP.PRINTX.FILE\" V))\"\n   IF RC <> 0 THEN ADDRESS ISPEXEC \"SETMSG MSG(\"ZERRMSG\")\"\n   \"FREE DD(#PARM #INDD #PRINT XPRINT #LOG SYSTSPRT #ELIBDD)\"\n   \"DELETE $$$TEMP.PARM.FILE\"\n   \"DELETE $$$TEMP.PRINT.FILE\"\n   \"DELETE $$$TEMP.PRINTX.FILE\"\n   \"DELETE $$$TEMP.LOG.FILE\"\n   \"DELETE $$$TEMP.COPYBOOK.PDS\"\n   EXIT 0\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"COBCOLV - VIEW INSYNC COBOL STRUCTURE OFFSETS             \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    COBCOLV  ( ? )                                        \"\n   SAY\n   SAY \"       INVOKES INSYNC AGAINST A COBOL STRUCTURE AND VIEWS \"\n   SAY \"       THE RESULTING OUTPUT IN A SEPARATE SCREEN.         \"\n   SAY\n   SAY \"       A QUESTION MARK WILL CAUSE THIS HELP TO BE SHOWN.  \"\n   SAY \"       C/C#/CC PREFIX COMMANDS MAY BE USED TO LIMIT THE   \"\n   SAY \"       LINES PROCESSED.                                   \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBCPUTM": {"ttr": 19201, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00I\\x00I\\x00\\x00\\xc3\\xd6\\xc2\\xc3\\xd7\\xe4\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 73, "newlines": 73, "modlines": 0, "user": "COBCPUT"}, "text": "//-YOUR-USERID-B JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  COBOL BENCHMARK CODE - SET FOR 100,000 LOOP\n//***    RUN ONCE WITH NO CODE TO ELIMINATE FRAMEWORK COST\n//***    SHOWS CPU TIME USED FROM WITHIN PROGRAM\n//***\n//C          EXEC     PGM=IGYCRCTL,REGION=4M,\n//             PARM=('LIB,MAP,LIST,NUMPROC(PFD),OPTIMIZE',\n//            'APOST,NOSEQ,TRUNC(OPT),XREF')\n//SYSIN        DD       *\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  BNCHMK INITIAL.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  WS-MISC.\n           05  WS-TIMES         PIC 9(09) COMP VALUE 100000.\n           05  WS-COUNT         PIC 9(09) COMP.\n           05  WS-TOTAL-TIME    PIC 9(18) COMP.\n           05  WS-DUMMY         PIC 9(18) COMP.\n       LINKAGE SECTION.\n       01 PSA-BLOCK.\n          05                PIC X(548).\n          05  ASCB-POINTER  POINTER.\n       01 ASCB-BLOCK.\n          05            PIC X(64).\n          05  CPU-TIME  PIC 9(18) COMP.\n          05            PIC X(128).\n          05  SRB-TIME  PIC 9(18) COMP.\n       PROCEDURE DIVISION.\n              DISPLAY '***  TOP OF PROGRAM  ***'\n\n              PERFORM VARYING WS-COUNT FROM 1 BY 1\n                    UNTIL WS-COUNT > WS-TIMES\n                 MOVE 17 TO WS-DUMMY\n                 COMPUTE WS-DUMMY = WS-DUMMY ** 5\n                 COMPUTE WS-DUMMY = WS-DUMMY ** .5\n                 COMPUTE WS-DUMMY = WS-DUMMY / WS-DUMMY\n              END-PERFORM\n\n              DISPLAY ' '\n              SET ADDRESS OF PSA-BLOCK TO NULL\n              SET ADDRESS OF ASCB-BLOCK TO ASCB-POINTER\n              COMPUTE WS-TOTAL-TIME = (CPU-TIME + SRB-TIME) / 4096000000\n              DISPLAY '    TOTAL SECONDS CPU TIME: ' WS-TOTAL-TIME\n              DISPLAY ' '\n\n              DISPLAY '***  END OF PROGRAM  ***'\n              GOBACK\n              .\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SYSLIB-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=SYSDA,SPACE=(TRK,(3,3)),\n//             DCB=(BLKSIZE=80,LRECL=80,RECFM=FB)\n//SYSUT1       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT2       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT3       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT4       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT5       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT6       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT7       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//***\n//GO         EXEC     PGM=LOADER,PARM='MAP,PRINT,AMODE(31),RMODE(ANY)',\n//             REGION=4M,COND=(5,LT,C)\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//SYSLOUT      DD       SYSOUT=*\n//SYSPRINT     DD       SYSOUT=*\n//SYSABOUT     DD       SYSOUT=*\n//SYSUDUMP     DD       SYSOUT=*\n//SYSOUT       DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COBHEXR": {"ttr": 19204, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x9d\\x00\\x9d\\x00\\x00\\xc3\\xd6\\xc2\\xc8\\xc5\\xe7\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 157, "newlines": 157, "modlines": 0, "user": "COBHEXR"}, "text": "//-YOUR-USERID-C JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//*** COBOL SUB-PROGRAM TO TRANSLATE CHARACTERS INTO HEX\n//***   I.E. 'ABC123' INTO 'C1C2C3F1F2F3'\n//***   FOR INPUT UP TO 4,999 BYTES IN LENGTH\n//***\n//C          EXEC     PGM=IGYCRCTL,REGION=4M,\n//             PARM=('LIB,MAP,NUMPROC(PFD),OFF,OPTIMIZE',\n//            'APOST,NOSEQ,TRUNC(OPT),XREF')\n//SYSIN        DD       *\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  TESTER.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT I\n               ASSIGN TO I.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  I\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  INPUT-REC    PIC X(00080).\n       WORKING-STORAGE SECTION.\n       01  WS-INPUT-REC.\n           05  WS-LENGTH              PIC 9(02).\n           05                         PIC X(02).\n           05  WS-INPUT               PIC X(22).\n           05                         PIC X(02).\n           05  WS-EXPECTED            PIC X(44).\n           05                         PIC X(08).\n       01  WORK-AREAS.\n          05  WS-RC                   PIC  99       VALUE 00.\n          05  WS-LEN                  PIC  9999     COMP.\n          05  WS-OUTPUT               PIC  X(44)    VALUE SPACES.\n          05  END-OF-FILE-STATUS      PIC  X        VALUE 'N'.\n              88  AT-END-OF-FILE                    VALUE 'Y'.\n\n       PROCEDURE DIVISION.\n\n       0000-MAIN.\n           DISPLAY '***  TOP OF TEST PROGRAM  ***'\n           OPEN  INPUT  I\n           READ  I INTO WS-INPUT-REC\n               AT END SET AT-END-OF-FILE TO TRUE\n               END-READ\n           PERFORM 0500-READ-WRITE-LOOP\n               UNTIL AT-END-OF-FILE\n           IF WS-RC NOT = 0\n               MOVE WS-RC TO RETURN-CODE\n           END-IF\n           CLOSE I\n           DISPLAY '***  END OF TEST PROGRAM  ***'\n           GOBACK\n           .\n\n       0500-READ-WRITE-LOOP.\n           MOVE SPACES TO WS-OUTPUT\n           MOVE WS-LENGTH TO WS-LEN\n           CALL 'COBHEXR' USING WS-INPUT WS-LEN WS-OUTPUT WS-RC\n           IF WS-OUTPUT NOT = WS-EXPECTED\n               DISPLAY '* PROBLEM - INPUT  = ' WS-INPUT\n               DISPLAY '          - OUTPUT = ' WS-OUTPUT\n               DISPLAY '          - EXPECT = ' WS-EXPECTED\n           END-IF\n           READ  I INTO WS-INPUT-REC\n               AT END SET AT-END-OF-FILE TO TRUE\n           END-READ\n           .\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  COBHEXR COMMON.\n\n       DATA DIVISION.\n\n       WORKING-STORAGE SECTION.\n       01  WORK-FIELDS.\n           05  TO-PTR           PIC     9999   COMP.\n           05  FROM-PTR         PIC     9999   COMP.\n           05  WS-LEN           PIC     9999   COMP.\n           05  WS-PACKEDC       PIC     X(9).\n           05                   REDEFINES  WS-PACKEDC.\n               10  WS-PACKED    PIC     9(17)   COMP-3.\n           05  WS-UNPACKED      PIC     9(17).\n           05                   REDEFINES  WS-UNPACKED.\n               10  WS-UNPACKEDC PIC     X(17).\n\n       LINKAGE SECTION.\n       01  LS-INPUT            PIC  X(4999).\n       01  LS-LEN              PIC  9999 COMP.\n       01  LS-OUTPUT           PIC  X(9999).\n       01  LS-RC               PIC  99.\n\n       PROCEDURE DIVISION   USING  LS-INPUT LS-LEN LS-OUTPUT LS-RC.\n\n           IF LS-LEN <= 0 OR LS-LEN > 4999\n               MOVE 1      TO LS-RC\n           ELSE\n               MOVE LS-LEN TO WS-LEN\n               MOVE 1      TO TO-PTR\n               MOVE 1      TO FROM-PTR\n               PERFORM UNTIL WS-LEN <= 8\n                   MOVE LS-INPUT(FROM-PTR:8)  TO WS-PACKEDC\n                   MOVE WS-PACKED             TO WS-UNPACKED\n                   INSPECT WS-UNPACKEDC\n                       CONVERTING X'FAFBFCFDFEFF' TO 'ABCDEF'\n                   MOVE WS-UNPACKEDC(1:16)    TO LS-OUTPUT(TO-PTR:16)\n                   ADD 8  TO FROM-PTR\n                   ADD 16 TO TO-PTR\n                   SUBTRACT 8 FROM WS-LEN\n               END-PERFORM\n               IF WS-LEN > 0\n                   MOVE LS-INPUT(FROM-PTR:WS-LEN) TO WS-PACKEDC\n                   MOVE WS-PACKED                 TO WS-UNPACKED\n                   INSPECT WS-UNPACKEDC\n                       CONVERTING X'FAFBFCFDFEFF' TO 'ABCDEF'\n                   MOVE WS-UNPACKEDC(1:2 * WS-LEN)\n                                   TO LS-OUTPUT(TO-PTR:2 * WS-LEN)\n               END-IF\n               MOVE 0 TO LS-RC\n           END-IF\n           EXIT PROGRAM.\n       END PROGRAM COBHEXR.\n\n       END PROGRAM TESTER.\n\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=SYSDA,SPACE=(CYL,(3,3)),\n//             DCB=(BLKSIZE=0,LRECL=80,RECFM=FB)\n//SYSUT1       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT2       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT3       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT4       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT5       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT6       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT7       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//***\n//GO         EXEC     PGM=LOADER,PARM='MAP,PRINT,AMODE(31),RMODE(ANY)',\n//             REGION=4M,COND=(5,LT)\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//SYSLOUT      DD       SYSOUT=*\n//SYSPRINT     DD       SYSOUT=*\n//I            DD       *\n12  ABCDEFGHIJKL            C1C2C3C4C5C6C7C8C9D1D2D3\n01  .                       4B\n12  LKJIHGFEDCBA            D3D2D1C9C8C7C6C5C4C3C2C1\n22  1234567890123456789012  F1F2F3F4F5F6F7F8F9F0F1F2F3F4F5F6F7F8F9F0F1F2\n04  ~!@#                    A15A7C7B\n10                          40404040404040404040\n//SYSOUT       DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COBLKLST": {"ttr": 19208, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x9f\\x00\\x9f\\x00\\x00\\xc3\\xd6\\xc2\\xd3\\xd2\\xd3\\xe2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 159, "newlines": 159, "modlines": 0, "user": "COBLKLS"}, "text": "//-YOUR-USERID-C JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  COBOL LINKED LIST CODE\n//***\n//C          EXEC     PGM=IGYCRCTL,REGION=4M,\n//             PARM=('LIB,MAP,NUMPROC(PFD),OFF,OPTIMIZE',\n//            'APOST,NOSEQ,TRUNC(OPT),XREF')\n//SYSIN        DD       *\n      ****************************************************************\n      **                                                             *\n      **   This code illustrates the construction of a linked        *\n      **   list using the LE storage management services, CEEGTST    *\n      **   to obtain storage and CEEFRST to free it.                 *\n      **                                                             *\n      **    -  Storage for each list element is allocated from the   *\n      **       user heap                                             *\n      **                                                             *\n      **    -  The list element is initialized and appended to the   *\n      **       list                                                  *\n      **                                                             *\n      **    -  After three members are appended, the list traversed  *\n      **       and the data saved in each element is displayed       *\n      **                                                             *\n      **    -  The link list storage is freed                        *\n      **                                                             *\n      ****************************************************************\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. CBLKLST.\n       DATA DIVISION.\n      *******************************************************\n      ** Storage management parameters, including pointers **\n      ** for the returned storage addresses.               **\n      *******************************************************\n       WORKING-STORAGE SECTION.\n       01  LCOUNT                  PIC 9            VALUE 0.\n       01  HEAPID                  PIC S9(9) BINARY VALUE 0.\n       01  NBYTES                  PIC S9(9) BINARY.\n       01  FC.\n           05                      PIC X(8).\n               88  CEE000       VALUE X'0000000000000000'.\n           05                      PIC X(4).\n       01  ADDRSS                  POINTER VALUE NULL.\n       01  ANCHOR                  POINTER VALUE NULL.\n\n      *******************************************************\n      ** Define variables in linkage section in order to   **\n      ** reference storage returned as addresses in        **\n      ** pointer variables by Language Environment.        **\n      *******************************************************\n       LINKAGE SECTION.\n       01  LIST-ITEM.\n           05  CHARDATA            PIC X(80).\n           05  NEXT-ITEM           POINTER.\n\n       PROCEDURE DIVISION.\n\n           DISPLAY '***************************************'.\n           DISPLAY 'CBLKLST is now in motion.              '.\n           DISPLAY '***************************************'.\n\n      *******************************************************\n      **  Call CEEGTST to get storage from user heap       **\n      *******************************************************\n      ** If successfully obtained, LE returns the address  **\n      ** in ADDRSS. The address of variable LIST-ITEM in   **\n      ** the linkage section can now be SET to address the **\n      ** acquired storage.  The list origin is pointed to  **\n      ** by ANCHOR and each item points to the next item.  **\n      *******************************************************\n           MOVE LENGTH OF LIST-ITEM TO NBYTES\n           PERFORM 3 TIMES\n               ADD 1 TO LCOUNT\n               CALL  'CEEGTST'  USING  HEAPID, NBYTES, ADDRSS, FC\n               IF CEE000\n                   IF ANCHOR = NULL\n                       SET ANCHOR TO ADDRSS\n                   ELSE\n                       SET NEXT-ITEM TO ADDRSS\n                   END-IF\n                   SET ADDRESS OF LIST-ITEM TO ADDRSS\n                   SET NEXT-ITEM TO NULL\n                   MOVE ' ' TO CHARDATA\n                   STRING 'This is list item number ' LCOUNT\n                       DELIMITED BY SIZE INTO CHARDATA\n               ELSE\n                   DISPLAY 'Error in obtaining storage from heap'\n                   GOBACK\n               END-IF\n           END-PERFORM\n\n      *********************************************************\n      ** On completion of the above loop, we have the        **\n      ** following layout:                                   **\n      **                                                     **\n      ** ANCHOR --> LIST-ITEM1 --> LIST-ITEM2 --> LIST-ITEM3 **\n      *********************************************************\n      ** Loop thru list items 1 thru 3 and print out the     **\n      ** identifying text written in the CHARDATA fields,    **\n      ** freeing the storage after printing.                 **\n      *********************************************************\n           MOVE 0 TO LCOUNT\n           PERFORM WITH TEST AFTER UNTIL (ANCHOR = NULL)\n               SET ADDRESS OF LIST-ITEM TO ANCHOR\n               DISPLAY CHARDATA\n               SET ADDRSS TO ANCHOR\n               SET ANCHOR TO NEXT-ITEM\n               PERFORM 1000-FREE-STORAGE\n               ADD 1 TO LCOUNT\n           END-PERFORM\n\n      *********************************************************\n      ** Test a counter variable to verify that three items  **\n      ** were indeed in the linked list and terminate.       **\n      *********************************************************\n           IF (LCOUNT = 3)\n               DISPLAY '**************************************'\n               DISPLAY 'CBLKLST has completed!                '\n               DISPLAY '**************************************'\n           ELSE\n               DISPLAY 'Error in List contruction :('\n           END-IF\n\n           GOBACK\n           .\n\n       1000-FREE-STORAGE.\n      *********************************************************\n      *     Call CEEFRST to free this storage from user heap **\n      *********************************************************\n           CALL  'CEEFRST'  USING ADDRSS, FC\n           IF CEE000\n               CONTINUE\n           ELSE\n               DISPLAY 'Error freeing storage from heap :('\n           END-IF\n           .\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=SYSDA,SPACE=(TRK,(3,3)),\n//             DCB=(BLKSIZE=0,LRECL=80,RECFM=FB)\n//SYSUT1       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT2       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT3       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT4       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT5       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT6       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT7       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//***\n//GO         EXEC     PGM=LOADER,PARM='MAP,PRINT,AMODE(31),RMODE(ANY)',\n//             REGION=4M,COND=(5,LT,C)\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//SYSLOUT      DD       SYSOUT=*\n//SYSPRINT     DD       SYSOUT=*\n//SYSABOUT     DD       SYSOUT=*\n//SYSUDUMP     DD       SYSOUT=*\n//SYSOUT       DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COL": {"ttr": 19212, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x007\\x007\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "REXX"}, "text": "/************************* REXX ***********************************\n *\n * THIS REXX WAS WRITTEN SO THAT YOU CAN TYPE COLS ON THE COMMAND\n * LINE IN AN EDIT SESSION JUST LIKE YOU DO IN A BROWSE SESSION,\n * INSTEAD OF HAVING TO PUT COLS ON A LINE NUMBER.\n * WRITTEN 02/1993 BY JEFFREY A. RICE...\n *\n ******************************************************************/\nTRACE O\nDEFINE = MSG(\"OFF\")\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\nADDRESS ISREDIT\n\"MACRO\"\n\"(MACLVL) = MACRO_LEVEL\"\nIF MACLVL  =  001  THEN DO\n   COUNTER = 1\n   \"(WIDTH) = DATA_WIDTH\"\n/*\n * CHECK FOR NUMBER ON COB MODE  -  IF SO THEN NUMBERS ARE TO BE\n * REDUCED BY 6 BECAUSE THE EDITOR IGNORES COLUMNS 1-6\n */\n   \"(NUM1,NUM2) = NUMBER\"\n   IF NUM1  =  \"ON\"  &  POS(\" COBOL \",NUM2)  >  0  THEN DO\n      COUNTER = COUNTER + 6\n      WIDTH = WIDTH + 6\n   END\n/*\n * BUILD A COLUMNS LINE FOR THE WIDTH OF THE CURRENT EDIT SESSION.\n */\n   COLUMNS = \"\"\n   DO WHILE COUNTER <= WIDTH\n      IF RIGHT(COUNTER,1) = \"0\" THEN DO\n         COLUMNS = COLUMNS\"\"LEFT(RIGHT(COUNTER,2),1)\n      END\n      ELSE DO\n         IF RIGHT(COUNTER,1) = \"5\" THEN\n            COLUMNS = COLUMNS\"+\"\n         ELSE\n            COLUMNS = COLUMNS\"-\"\n      END\n      COUNTER = COUNTER + 1\n   END\n/*\n * DISPLAY COLUMNS LINE BUILT\n */\n   \"LINE_BEFORE .ZCSR = INFOLINE '\"COLUMNS\"'\"\n   \"UP 1\"\nEND\nELSE DO\n   ZEDLMSG = \"%COLS CAN ONLY BE EXECUTED AS AN EDIT MACRO FROM\",\n             \"AN EDIT SESSION.\"\n   ADDRESS ISPEXEC \"SETMSG MSG(ISRZ000)\"\nEND\nEXIT\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COLS": {"ttr": 19214, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x007\\x007\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "REXX"}, "text": "/************************* REXX ***********************************\n *\n * THIS REXX WAS WRITTEN SO THAT YOU CAN TYPE COLS ON THE COMMAND\n * LINE IN AN EDIT SESSION JUST LIKE YOU DO IN A BROWSE SESSION,\n * INSTEAD OF HAVING TO PUT COLS ON A LINE NUMBER.\n * WRITTEN 02/1993 BY JEFFREY A. RICE...\n *\n ******************************************************************/\nTRACE O\nDEFINE = MSG(\"OFF\")\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\nADDRESS ISREDIT\n\"MACRO\"\n\"(MACLVL) = MACRO_LEVEL\"\nIF MACLVL  =  001  THEN DO\n   COUNTER = 1\n   \"(WIDTH) = DATA_WIDTH\"\n/*\n * CHECK FOR NUMBER ON COB MODE  -  IF SO THEN NUMBERS ARE TO BE\n * REDUCED BY 6 BECAUSE THE EDITOR IGNORES COLUMNS 1-6\n */\n   \"(NUM1,NUM2) = NUMBER\"\n   IF NUM1  =  \"ON\"  &  POS(\" COBOL \",NUM2)  >  0  THEN DO\n      COUNTER = COUNTER + 6\n      WIDTH = WIDTH + 6\n   END\n/*\n * BUILD A COLUMNS LINE FOR THE WIDTH OF THE CURRENT EDIT SESSION.\n */\n   COLUMNS = \"\"\n   DO WHILE COUNTER <= WIDTH\n      IF RIGHT(COUNTER,1) = \"0\" THEN DO\n         COLUMNS = COLUMNS\"\"LEFT(RIGHT(COUNTER,2),1)\n      END\n      ELSE DO\n         IF RIGHT(COUNTER,1) = \"5\" THEN\n            COLUMNS = COLUMNS\"+\"\n         ELSE\n            COLUMNS = COLUMNS\"-\"\n      END\n      COUNTER = COUNTER + 1\n   END\n/*\n * DISPLAY COLUMNS LINE BUILT\n */\n   \"LINE_BEFORE .ZCSR = INFOLINE '\"COLUMNS\"'\"\n   \"UP 1\"\nEND\nELSE DO\n   ZEDLMSG = \"%COLS CAN ONLY BE EXECUTED AS AN EDIT MACRO FROM\",\n             \"AN EDIT SESSION.\"\n   ADDRESS ISPEXEC \"SETMSG MSG(ISRZ000)\"\nEND\nEXIT\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COLSCC": {"ttr": 19216, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x89\\x00\\x89\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 137, "newlines": 137, "modlines": 0, "user": "REXX"}, "text": "/************************** REXX   ************************************/\n/*                                                                    */\n/*   COMMAND NAME: COLSCC (AS RENAMED)                                */\n/*   WRITTEN BY:   JIM HAIRE                                          */\n/*                                                                    */\n/*   FORMAT:                                                          */\n/*       TYPE \"COLSCC\" ON THE COMMAND LINE AND PUT A C, C##, OR       */\n/*       CC/CC PAIR ON THE LINES WHERE THE COLUMN NUMBERS SHOULD      */\n/*       APPEAR (WORKS IN BOTH EDIT AND VIEW).                        */\n/*                                                                    */\n/**********************************************************************/\n   ADDRESS ISPEXEC\n   \"ISREDIT MACRO NOPROCESS\"\n   \"ISPEXEC CONTROL ERRORS CANCEL\"\n   \"ISREDIT PROCESS RANGE C\"\n   IF RC >= 16 THEN CALL 90000_DISPLAY_CMD_ERROR\n   \"ISREDIT (LINECMD) = RANGE_CMD\"\n\n   CALL 00000_CHECK_VALID_LINE_COMMAND\n   CALL 10000_GET_DATASET_INFO\n   CALL 20000_BUILD_COLUMNS_LINE\n   DO WHILE FIRSTLIN <= LASTLIN\n       CALL 30000_DISPLAY_COLUMNS_LINE\n   END\n\nSTOPIT:\n   EXIT\n\n00000_CHECK_VALID_LINE_COMMAND:\n/*--------------------------------------------------------------------*/\n/*    THIS PARAGRAPH WILL VERIFY THAT THE USER ENTERED THE \"CC\"       */\n/*    COMMAND TO INDICATE THE BLOCK OF LINES THEY WANT TO PROCESS.    */\n/*--------------------------------------------------------------------*/\n   SELECT\n     WHEN LINECMD = 'C' THEN\n         DO\n           /*---------------------------------------------------------*/\n           /*-  THIS PARAGRAPH WILL DETERMINE THE RANGE OF LINES     -*/\n           /*-  BEING PROCESSED.                                     -*/\n           /*---------------------------------------------------------*/\n           \"ISREDIT (FIRSTLIN) = LINENUM .ZFRANGE\"\n           \"ISREDIT (LASTLIN) = LINENUM .ZLRANGE\"\n         END\n     WHEN LINECMD = ' ' THEN\n         DO\n           /*---------------------------------------------------------*/\n           /*-  IF NO LINE COMMAND PROVIDED, ONLY PUT THE COLUMNS    -*/\n           /*-  INDICATOR LINE BEFORE THE FIRST LINE.                -*/\n           /*---------------------------------------------------------*/\n           \"ISREDIT (FIRSTLIN) = LINENUM .ZFIRST\"\n           \"ISREDIT (LASTLIN) = LINENUM .ZFIRST\"\n         END\n     OTHERWISE\n         /*-----------------------------------------------------------*/\n         /*-  DISPLAY A WINDOW IF THE WRONG LINE COMMAND IS USED.    -*/\n         /*-----------------------------------------------------------*/\n         CALL 90000_DISPLAY_CMD_ERROR\n   END\n\n   RETURN\n\n10000_GET_DATASET_INFO:\n/*--------------------------------------------------------------------*/\n/*-     THIS PARAGRAPH WILL DETERMINE THE RECORD LENGTH OF THE       -*/\n/*-     CURRENT DATASET SO THAT A PROPER COLUMNS INDICATOR LINE      -*/\n/*-     CAN BE BUILT.                                                -*/\n/*--------------------------------------------------------------------*/\n   ADDRESS ISPEXEC\n   \"ISREDIT (CURRDSET) = DATASET\"\n\n   ADDRESS TSO\n   X = LISTDSI(\"'\"CURRDSET\"'\")\n   RECORD_LENGTH = SYSLRECL\n\n   RETURN\n\n20000_BUILD_COLUMNS_LINE:\n/*--------------------------------------------------------------------*/\n/*-     THIS PARAGRAPH WILL BUILD THE COLUMNS INDICATOR LINE         -*/\n/*-     BASED ON THE LENGTH OF THE FILE.                             -*/\n/*--------------------------------------------------------------------*/\n   COLSLINE = ''\n   DO I = 1 TO RECORD_LENGTH\n       REMAINDER = I // 10\n       SELECT\n         WHEN REMAINDER = 0 THEN\n             DO\n               QUOTIENT = I / 10\n               IF QUOTIENT < 10 THEN\n                   COLS_CHAR = QUOTIENT\n               ELSE\n                   DO\n                     CURRPOS_LENGTH = LENGTH(I)\n                     CHAR_WANTED = CURRPOS_LENGTH - 1\n                     COLS_CHAR = SUBSTR(I,CHAR_WANTED,1)\n                   END\n             END\n         WHEN REMAINDER = 5 THEN\n             COLS_CHAR = '+'\n         OTHERWISE\n             COLS_CHAR = '-'\n       END\n       COLSLINE = COLSLINE | | COLS_CHAR\n   END\n\n   RETURN\n\n30000_DISPLAY_COLUMNS_LINE:\n/*--------------------------------------------------------------------*/\n/*-     THIS PARAGRAPH WILL DISPLAY A COLUMNS INDICATOR LINE ABOVE   -*/\n/*-     EVERY LINE THAT YOU HAVE INDICATED YOU WANT THE \"COLS\"       -*/\n/*-     COMMAND TO AFFECT.                                           -*/\n/*--------------------------------------------------------------------*/\n   'ISREDIT LINE_BEFORE &FIRSTLIN = INFOLINE \"&COLSLINE\"'\n\n   /*--------------------------------*/\n   /*  ADVANCES POINTER TO NEXT LINE.*/\n   /*--------------------------------*/\n   ADVANCE_TO_NEXT_LINE:\n   FIRSTLIN = FIRSTLIN + 1\n\n   RETURN\n\n90000_DISPLAY_CMD_ERROR:\n/*--------------------------------------------------------------------*/\n/*-     THIS PARAGRAPH WILL DISPLAY AN ERROR MESSAGE THAT STATES     -*/\n/*-     THAT YOU MUST PLACE A \"CC\" AROUND THE BLOCK OF LINES YOU     -*/\n/*-     WISH THE LAYOUT COMMAND TO AFFECT.                           -*/\n/*--------------------------------------------------------------------*/\n    ADDRESS ISPEXEC\n    ZEDSMSG = 'PF1 FOR ERROR'\n    ZEDLMSG = 'YOU MUST PLACE \"CC\" AROUND THE BLOCK OF LINES'\n    ZEDLMSG = ZEDLMSG | | ' YOU WANT THE LAYOUT COMMAND TO AFFECT.'\n    'SETMSG MSG(ISRZ001)'\n\n    SIGNAL STOPIT\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMPRS": {"ttr": 19459, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00>\\x00>\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 62, "newlines": 62, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- COMPRESS THE PDS EDITED OR ONE SPECIFIED  **/\n\n   ADDRESS 'ISPEXEC'\n   \"ISREDIT MACRO (DSN)\"\n   IF RC > 0 THEN EXIT(RC)\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR \"\n   SAVEMSG = MSG(\"OFF\")\n\n   UPPER DSN\n   IF DSN = '?' THEN SIGNAL DISPDOC\n   IF DSN = '' THEN DO\n      \"ISREDIT (DSN) = DATASET\"\n      DSN = \"'\" || DSN || \"'\"\n   END\n\n   ADDRESS TSO\n   \"FREE  DD(SYSUT1 SYSPRINT SYSIN)\"\n   \"ALLOC DD(SYSUT1) DSN(\"DSN\") SHR\"\n   \"ALLOC DD(SYSPRINT) DUMMY\"\n   \"ALLOC DD(SYSIN) NEW TRACKS SPACE(1) UNIT(SYSDA)\",\n        \" LRECL(80) BLKSIZE(800) RECFM(F B)\"\n   QUEUE \" COPY INDD=SYSUT1,OUTDD=SYSUT1\"\n   \"EXECIO\" QUEUED() \"DISKW SYSIN (FINIS\"\n   \"CALL *(IEBCOPY)\"\n   RETCODE = RC\n   \"FREE  DD(SYSUT1 SYSPRINT SYSIN)\"\n   \"ALLOC DD(SYSPRINT) DSN(*)\"\n\n   STR = 'COMPRESSED RC='RETCODE\n   CALL SETMSG '* NO ' STR ' DONE $PDS' DSN 'COMPRESSED...'\n   \"ISREDIT LOCATE\" SAVLINE\n   \"ISREDIT CURSOR = \"SAVLINE SAVCOL\n   IF SAVEMSG = 'ON' THEN\n      X = MSG(\"ON\")\n   RETURN RETCODE\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"COMPRESS - CURRENT PDS OR SPECIFIED ONE                   \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    COMPRESS  ( PDS-NAME )                                \"\n   SAY\n   SAY \"       INVOKE IEBCOPY COMPRESS AGAINST EITHER THE CURRENT \"\n   SAY \"       (DEFAULTED WHEN NO PDS-NAME SPECIFIED) OR THE      \"\n   SAY \"       DATA SET SPECIFIED.                                \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    COMPRESS  'USERID.TEST.MACLIB'                        \"\n   SAY\n   SAY \"       WILL COMPRESS 'USERID.TEST.MACLIB'                 \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CONBLANK": {"ttr": 19461, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00j\\x00j\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 106, "newlines": 106, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- CONSOLIDATE BLANK LINES; USE LABEL RANGE IF SPECIFIED  **/\n\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'CONBLANK MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n             \"ISREDIT MACRO (LBL1,LBL2)\"\n      IF RC = 0 THEN DO\n         IF LBL1 = '?' THEN SIGNAL DISPDOC\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY 'CONBLANK EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT',\n          'WITH NO PENDING EDIT COMMANDS!'\n      SIGNAL EOJ\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n       \"ISREDIT (START) = LINENUM &LBL1\"\n   END\n   ELSE START = 1\n\n   IF LBL2 <> '' THEN DO\n       \"ISREDIT L &LBL2\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n       \"ISREDIT (END) = LINENUM &LBL2\"\n   END\n   ELSE \"ISREDIT (END) = LINENUM .ZLAST \"\n\n   IF START > END THEN DO\n      FLIP  = START\n      START = END\n      END   = FLIP\n   END\n\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR \"\n   \"ISREDIT (\"ANUM\") = AUTONUM \"\n\n   ONE  = 'NO'\n   DO PNTR = END TO START BY -1\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      IF RECORD = ' ' THEN DO\n         IF ONE = 'NO' THEN ONE = 'YES'\n         ELSE DO\n            \"ISREDIT DELETE &PNTR\"\n         END\n      END\n      ELSE ONE = 'NO'\n   END\n\n  \"ISREDIT LOCATE\" 1\n  \"ISREDIT AUTONUM = \"ANUM\n   SIGNAL EOJ\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '*** ERROR *** ' MESG\n   END\n\nEOJ:\n   X = MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"CONBLANK - CONSOLIDATE MULTIPLE BLANK LINES TO ONE     \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    CONBLANK  ( .A .B )\"\n   SAY \"       THE LABEL RANGE IS OPTIONAL. \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY \"    CONBLANK \"\n   SAY \"       WILL REDUCE MULTIPLE BLANK LINES TO ONE        \"\n   SAY\n   SAY \"    CONBLANK  .AA .BB \"\n   SAY \"       WILL REDUCE ANY BLANK LINES IN THE LABEL RANGE \"\n   SAY \"       .AA THRU .BB \"\n   SAY\n   SIGNAL EOJ\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CONCATDD": {"ttr": 19464, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00G\\x00G\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 71, "newlines": 71, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- CONCATENATE A DATA SET TO A DDNAME                    **/\n/*                                                                  */\n/* SYNTAX FOR INVOKING THIS CLIST IS:                               */\n/*    CONCATDD DDNAME DATA.SET.NAME   (TO PUT IT AT THE BEGINNING)  */\n/*    CONCATDD DDNAME DATA.SET.NAME B (TO PUT IT AT THE END)        */\n/*       NOTE NO QUOTES ON THE DATA SET NAME!                       */\n/********************************************************************/\n   PARSE  UPPER  ARG  DDNAME  DSNAME  B\n   X = MSG(\"OFF\")\n   IF SUBSTR(DDNAME,1,1) = '?' THEN SIGNAL DISPDOC\n   IF SYSDSN(\"'\"DSNAME\"'\") \u00ac= 'OK' THEN DO\n       SAY  DSNAME 'DOES NOT EXIST OR ISN''T CATALOGED'\n       EXIT\n    END\n   X = OUTTRAP(\"TRAP.\",\"*\")\n   \"LISTALC STATUS\"\n   X= OUTTRAP(\"OFF\")\n\n   FOUND = 'NO'\n   DO  II  =  1  TO  TRAP.0  WHILE  FOUND <> 'YES'\n      DSN = TRAP.II\n      IF SUBSTR(DSN,1,10) = '  ' || DDNAME THEN DO\n         FOUND   = 'YES'\n         JJ  = II - 1\n         DSN = TRAP.JJ\n         IF DSN <> DSNAME THEN CONCAT = \"'\" || DSN || \"'\"\n      END\n   END\n\n   IF  FOUND = 'YES' THEN DO\n      DO JJ = (II+1) TO (TRAP.0) BY 2\n         DSN = TRAP.JJ\n         IF SUBSTR(DSN,3,8) = ' ' THEN DO\n            KK = JJ - 1\n            DSN = TRAP.KK\n            IF DSN <> DSNAME THEN CONCAT = CONCAT || \" '\" || DSN || \"'\"\n         END\n         ELSE JJ = TRAP.0 +100\n      END\n   END\n   ELSE DO\n      SAY 'DDNAME' DDNAME 'NOT CURRENTLY ALLOCATED'\n      EXIT\n   END\n\n   DSNBOT = ''\n   DSNTOP = ''\n   IF B = 'B' THEN DSNBOT = \"'\" || DSNAME || \"'\"\n              ELSE DSNTOP = \"'\" || DSNAME || \"'\"\n   \"ALLOC DD(\"DDNAME\") DSN(\"DSNTOP CONCAT DSNBOT\") SHR REU\"\n   EXIT(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"CONCATDD - CONCATENATE A DATA SET TO A DD NAME            \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    CONCATDD  DDNAME  DSNAME  ( B | T )                   \"\n   SAY\n   SAY \"       WILL ADD THE DATA SET TO THE TOP OR BOTTOM OF THE  \"\n   SAY \"       DD NAME'S CONCATENATION. THE DATA SET NAME MUST BE \"\n   SAY \"       IN SINGLES QUOTES. 'T' FOR TOP IS THE DEFAULT      \"\n   SAY\n   SAY \"       WILL CHECK IF THE DATA SET EXISTS AND WHETHER THE  \"\n   SAY \"       DD NAME IS ALLOCATED. WILL MOVE THE DATA SET TO    \"\n   SAY \"       THE TOP OR BOTTOM, AS SPECIFIED, IF ALREADY IN THE \"\n   SAY \"       CONCATENATION.                                     \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COPYCOLS": {"ttr": 19467, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x8c\\x00\\x8c\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 140, "newlines": 140, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- COPY COLUMNS OVERLAYING OTHER COLUMNS  **/\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'COPYCOLS MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (FRMLEFT,FRMRIGHT,TOLEFT,LBL1,LBL2)\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY COPYCOLS 'EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT',\n         'WITH NO PENDING EDIT COMMANDS!'\n      SIGNAL EOJ\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n   IF FRMLEFT = ''  |  FRMRIGHT = ''  |  TOLEFT = ''  THEN DO\n      MESG = 'PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMLEFT,'W')  |  FRMLEFT = 0  THEN DO\n      MESG = \"'\"FRMLEFT\"' VALUE OF FROM-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMRIGHT,'W')  |  FRMRIGHT = 0  THEN DO\n      MESG = \"'\"FRMRIGHT\"' VALUE OF FROM-RIGHT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF FRMLEFT > FRMRIGHT THEN DO\n      MESG = \"FROM-LEFT-COL \"FRMLEFT\" IS > THAN FROM-RIGHT-COL \"FRMRIGHT\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(TOLEFT,'W')  |  TOLEFT=0  THEN DO\n      MESG = \"'\"TOLEFT\"' VALUE OF TO-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   LEN = FRMRIGHT - FRMLEFT + 1\n   TORIGHT = TOLEFT + LEN - 1\n   IF TOLEFT > TORIGHT THEN DO\n      MESG = \"TO-LEFT-COL \"TOLEFT\" IS GREATER THAN TO-RIGHT-COL \"TORIGHT\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF TORIGHT > LRECL THEN DO\n      MESG = \"TO-RIGHT COLUMN IS GREATER THAN RECORD SIZE (\"LRECL\")\"\n      SIGNAL ERROR\n   END\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR \"\n   \"ISREDIT (\"ANUM\") = AUTONUM \"\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n\n   START = 1\n   IF LBL1 <> '' THEN\n       \"ISREDIT (START) = LINENUM &LBL1\"\n\n   IF LBL2 <> '' THEN\n        \"ISREDIT (END) = LINENUM &LBL2\"\n   ELSE\n        LBL2 = LBL1\n\n   IF START > END THEN DO\n      WST = START\n      START = END\n      END = WST\n   END\n\n   DO PNTR =  START  TO  END  BY 1\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      FRMFLD = SUBSTR(RECORD,FRMLEFT,LEN)\n      RECORD = OVERLAY(FRMFLD,RECORD,TOLEFT,LEN)\n      \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n   END\n\n   \"ISREDIT LOCATE\" START\n   \"ISREDIT AUTONUM =\" ANUM\n    SIGNAL EOJ\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   CALL DISPDOC\n\nEOJ:\n   X = MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"COPYCOLS - COPY COLUMNS OVERLAYING RECEIVING AREA\"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    COPYCOLS  FROM-LEFT-COL FROM-RIGHT-COL TO-LEFT-COL (.A .B)\"\n   SAY\n   SAY \"       COLUMN PARAMETERS ARE REQUIRED. LABEL RANGE IS OPTIONAL\"\n   SAY\n   SAY \" EXAMPLES \"\n   SAY\n   SAY \"    COPYCOLS  1 8  21 \"\n   SAY \"       WILL COPY THE CONTENTS OF COLUMNS 1 THRU 8 ONTO \"\n   SAY \"       COLUMNS 21 THRU 28.                             \"\n   SAY\n   SAY \"    COPYCOLS  15 18  2  .A .B \"\n   SAY \"       WILL COPY THE CONTENTS OF COLS 15 THRU 18 ONTO  \"\n   SAY \"       COLUMNS 2 THRU 5 IN THE LINE RANGE .A THRU .B.  \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COPYINS": {"ttr": 19470, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x92\\x00\\x92\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 146, "newlines": 146, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- COPY COLUMNS INSERTING THEM INTO THE RECEIVING DATA  **/\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'COPYINS MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (FRMLEFT,FRMRIGHT,TOLEFT,LBL1,LBL2)\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY 'COPYINS EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT',\n          'WITH NO PENDING EDIT COMMANDS!'\n      SIGNAL EOJ\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n   IF FRMLEFT = '' THEN DO\n      SIGNAL ERROR\n   END\n   IF FRMLEFT = ''  |  FRMRIGHT = ''  |  TOLEFT = ''  THEN DO\n      MESG = 'PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMLEFT,'W')  |  FRMLEFT = 0  THEN DO\n      MESG = \"'\"FRMLEFT\"' VALUE OF FROM-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMRIGHT,'W')  |  FRMRIGHT=0  THEN DO\n      MESG = \"'\"FRMRIGHT\"' VALUE OF FROM-RIGHT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF FRMLEFT > FRMRIGHT THEN DO\n      MESG = \"FROM-LEFT-COL \"FRMLEFT\" IS > THAN FROM-RIGHT-COL \"FRMRIGHT\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(TOLEFT,'W')  |  TOLEFT=0  THEN DO\n      MESG = \"'\"TOLEFT\"' VALUE OF TO-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   LEN = FRMRIGHT - FRMLEFT + 1\n   TORIGHT = TOLEFT + LEN - 1\n   IF TOLEFT > TORIGHT THEN DO\n      MESG = \"TO-LEFT-COL \"TOLEFT\" IS GREATER THAN TO-RIGHT-COL \"TORIGHT\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF TORIGHT > LRECL THEN DO\n      MESG = \"TO-RIGHT COLUMN IS GREATER THAN RECORD SIZE (\"LRECL\")\"\n      SIGNAL ERROR\n   END\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR \"\n   \"ISREDIT (\"ANUM\") = AUTONUM \"\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n\n   START = 1\n   IF LBL1 <> '' THEN\n       \"ISREDIT (START) = LINENUM &LBL1\"\n\n   IF LBL2 <> '' THEN\n        \"ISREDIT (END) = LINENUM &LBL2\"\n   ELSE\n        LBL2 = LBL1\n\n   IF START > END THEN DO\n      WST   = START\n      START = END\n      END   = WST\n   END\n\n   DO PNTR =  START  TO  END  BY 1\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      RECORD = SUBSTR(RECORD,1,TOLEFT-1),\n         || SUBSTR(RECORD,FRMLEFT,LEN),\n         || SUBSTR(RECORD,TOLEFT,LRECL-LEN-1)\n      \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n   END\n\n   \"ISREDIT LOCATE\" START\n   \"ISREDIT AUTONUM = \"ANUM\n    SIGNAL EOJ\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   SIGNAL DISPDOC\n\nEOJ:\n   X = MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"COPYINS - COPY COLUMNS INSERTING DATA\"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    COPYINS  FROM-LEFT-COL FROM-RIGHT-COL TO-LEFT-COL (.A .B) \"\n   SAY\n   SAY \"       COLUMN PARAMETERS ARE REQUIRED. LABEL RANGE IS OPTIONAL\"\n   SAY\n   SAY \" EXAMPLES \"\n   SAY\n   SAY \"    COPYCOLS  1 8  21 \"\n   SAY \"       WILL COPY THE CONTENTS OF COLUMNS 1 THRU 8 AFTER \"\n   SAY \"       COLUMN  20 SHIFTING COLUMNS 21 ON TO THE RIGHT.  \"\n   SAY\n   SAY \"    COPYCOLS  15 18  1  .A .B \"\n   SAY \"       WILL COPY THE CONTENTS OF COLS 15 THRU 18 TO     \"\n   SAY \"       COLUMN 1 SHIFTING THE DATA IN COLUMN 1 FOUR      \"\n   SAY \"       COLUMNS TO THE RIGHT RIGHT IN THE LABEL RANGE    \"\n   SAY \"       .A TO .B.                                        \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COUNTX": {"ttr": 19715, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x008\\x008\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 56, "newlines": 56, "modlines": 0, "user": "REXX"}, "text": "/***  REXX -- SHOW # RECORDS IN FILE (UNDER ISPF OPTION 3.4)  ***/\n   PARSE ARG ZINPDSN\n   IF SUBSTR(ZINPDSN,1,1) = '?' THEN SIGNAL DISPDOC\n   ISPEXEC VGET (ZDLRECFM) SHARED\n   ISPEXEC VGET (ZDLLRECL) SHARED\n   ISPEXEC VGET (ZDLBLKSZ) SHARED\n   ISPEXEC VGET (ZDLDSORG) SHARED\n   IF ZDLDSORG = \"PS\" | ZDLDSORG = \"VS\" | ZDLDSORG = \"PS-E\"\n      THEN DO\n         \"ALLOC DD(INFILE)   DSN(\"ZINPDSN\") SHR REUSE BUFNO(30)\"\n         \"ALLOC DD(OUTFILE)  DUMMY BLKSIZE(32000) REUSE\"\n         \"ALLOC DD(SYSPRINT) DSN(*) REUSE\"\n         CALL OUTTRAP \"SYSPRINT.\" , \"*\"\n         \"REPRO INFILE(INFILE) OUTFILE(OUTFILE) \"\n         CALL OUTTRAP \"OFF\"\n         DO II = 1 TO SYSPRINT.0\n            PARSE VAR SYSPRINT.II \" WAS \" #RECS\n            IF DATATYPE(#RECS) = \"NUM\" THEN LEAVE\n         END II\n         \"FREE DD(INFILE OUTFILE)\"\n         \"ALLOC DD(SYSPRINT) DSN(*) REUSE\"\n         $RECS = \"\"\n         DO JJ = 3 TO 21 BY 3 WHILE JJ < LENGTH(#RECS)\n            $RECS = \",\" || SUBSTR(#RECS,LENGTH(#RECS)-JJ+1,3) || $RECS\n         END\n         $RECS = SUBSTR(#RECS,1,LENGTH(#RECS)+3-JJ) || $RECS\n         FINPDSN = LEFT(SUBSTR(ZINPDSN,2,LENGTH(ZINPDSN)-2),44)\n         IF ZDLDSORG = \"PS\" THEN DO\n            SAY FINPDSN\"(\"LEFT(ZDLRECFM,4,' ')\"/\"ZDLLRECL\"/\"ZDLBLKSZ\")\",\n               RIGHT($RECS,14)\n         END\n         ELSE DO\n            SAY FINPDSN RIGHT($RECS,14)\n         END\n      END\n      ELSE DO\n         SAY \"DSORG\" ZDLDSORG \"IS NOT SUPPORTED...\"\n      END\n   EXIT\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"COUNTX - SHOW # OF RECORDS IN SEQ FILE UNDER DS LIST      \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    COUNTX  ( ? )                                         \"\n   SAY\n   SAY \"       OVERTYPED ON A DS LIST SEQUENTIAL OR VSAM DATA SET,\"\n   SAY \"       COUNTX WILL DISPLAY THE DATA SET NAME (SINCE IT    \"\n   SAY \"       CAN BE INVOKED ON MULTIPLE LINES) AND THE NUMBER   \"\n   SAY \"       OF RECORDS IN THE FILE. IT WILL ALSO SUPPLY THE    \"\n   SAY \"       RECORD FORMAT, LOGICAL RECORD LENGTH AND BLOCK     \"\n   SAY \"       FOR SEQUENTIAL DATASETS.                           \"\n   EXIT(1)\n\n", "mimetype": "text/x-diff", "datatype": "ebcdic", "extension": ".diff"}, "COUNTXNX": {"ttr": 19717, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x03'\\x1f\\x01\\x03'\\x1f\\x12\\x00\\x00M\\x00M\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-09-28T00:00:00", "modifydate": "2003-09-28T12:00:00", "lines": 77, "newlines": 77, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- SHOW NUMBER OF UNEXCLUDED AND EXCLUDED LINES  **/\n   ADDRESS \"ISREDIT\"\n   \"MACRO (PARMS) NOPROCESS\"\n\n   EXCLUDED   = 0\n   UNEXCLUDED = 0\n   LABF       = \"\"\n   LABL       = \"\"\n\n   PARMS = TRANSLATE(PARMS)\n   IF PARMS = '?' THEN SIGNAL DISPDOC\n   DO II = 1 TO 10;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LABF = \"\" THEN LABF = TOKEN\n         ELSE IF LABL = \"\" THEN LABL = TOKEN\n         ELSE DO\n            ZEDSMSG = \".LABEL RC=8\"\n            ZEDLMSG = \"TOO MANY LABELS --\" LABF LABL TOKEN\n            ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n            EXIT 8\n         END\n      END\n   END II\n   IF LABF <> \"\"  &  LABL = \"\"  THEN LABL = LABF\n\n   IF LABL = \"\" THEN DO\n      \"PROCESS RANGE C\"\n      IF RC = 0 THEN DO\n         LABF = \".ZFRANGE\"\n         LABL = \".ZLRANGE\"\n      END\n      ELSE DO\n         LABF = \".ZFIRST\"\n         LABL = \".ZLAST\"\n      END\n   END\n\n   \"(LABFNO) = LINENUM\" LABF\n   \"(LABLNO) = LINENUM\" LABL\n\n   DO II = LABFNO TO LABLNO\n      \"(LINESTAT) = XSTATUS\" II\n      IF LINESTAT = \"NX\" THEN UNEXCLUDED = UNEXCLUDED + 1\n                         ELSE   EXCLUDED = EXCLUDED   + 1\n   END\n\n   ZEDSMSG = UNEXCLUDED \"NX /\" EXCLUDED \"X LINES\"\n   ZEDLMSG = \"THERE ARE\" UNEXCLUDED \"DISPLAYED LINES & \",\n      || EXCLUDED \"EXCLUDED LINES\"\n   ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   EXIT(1)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"COUNTXNX - SHOW NUMBERS OF DISPLAYED/EXCLUDED LINES         \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    COUNTXNX  ( ? )  ( .A .B )                              \"\n   SAY\n   SAY \"       SHOWS THE COUNT OF UNEXCLUDED AND EXCLUDED LINES IN  \"\n   SAY \"       UPPER RIGHT HAND CORNER OF SCREEN IN VIEW OR EDIT.   \"\n   SAY \"       THE RANGE TO BE PROCESSED MAY BE SPECIFIED VIA       \"\n   SAY \"       LABELS OR C/CC/C# PREFIX COMMANDS. A SINGLE QUESTION \"\n   SAY \"       MARK CAUSES THIS HELP TO BE DISPLAYED.               \"\n   SAY\n   SAY \" EXAMPLE                                                    \"\n   SAY\n   SAY \"    COUNTXNX                                                \"\n   SAY\n   SAY \"       SHOWS THE NUMBER OF DISPLAYED AND EXCLUDED LINES     \"\n   SAY \"       WITHIN THE ENTIRE FILE.                              \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CU": {"ttr": 19720, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00@\\x00@\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- CREATE CLEAN UP JCL AFTER CURSOR POSITION  **/\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'CU EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      EXIT(12)\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      ADDRESS ISREDIT \"ISREDIT MACRO (PARMS) NOPROCESS\"\n      PARMS = TRANSLATE(PARMS)\n      IF PARMS = \"?\" THEN SIGNAL DISPDOC\n   END\n   ELSE DO\n      SAY 'CU EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      EXIT(12)\n   END\n   IF DATATYPE(PARMS,'W') THEN NUMDELS = PARMS\n                          ELSE NUMDELS = 1\n\n   ADDRESS ISREDIT\n   \"(LINE,COL) = CURSOR\"\n   IF LINE = 1  THEN DO\n       ADDRESS ISPEXEC \"VGET (ZSCREENC,ZSCREENI) SHARED\"\n       II = INDEX(ZSCREENI,'* Top of Data *')\n       IF ( ZSCREENC % 80 )  <=  ( II % 80 )  THEN LINE = 0\n       ELSE LINE = 1\n   END\n   DDNUM = NUMDELS\n   CARD1 = \"//***\"\n   \"LINE_AFTER (LINE) = (CARD1)\"\n   CARD2 = \"//             DISP=(MOD,DELETE,DELETE),\",\n      || \"UNIT=SYSDA,SPACE=(TRK,0)\"\n   CARD1 = \"//DEL001       DD       DSN=...,\"\n   DO II = 1 TO NUMDELS\n      \"LINE_AFTER (LINE) = (CARD2)\"\n      PATCH = RIGHT(DDNUM,3,'0')\n      DDNUM = DDNUM - 1\n      CARD1 = OVERLAY(PATCH,CARD1,6,3)\n      \"LINE_AFTER (LINE) = (CARD1)\"\n   END II\n   CARD1 = \"//CLEANUP    EXEC     PGM=IEFBR14\"\n   \"LINE_AFTER (LINE) = (CARD1)\"\n   CARD1 = \"//***\"\n   \"LINE_AFTER (LINE) = (CARD1)\"\n   LINE = LINE + 3\n   COL  = 29\n   \"CURSOR = \" LINE COL\n   EXIT(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"CU  -  COPY CLEAN UP JCL AFTER CURSOR POSITION            \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    CU  ( ### ) ( ? )                                     \"\n   SAY\n   SAY \"       CREATE AN IEFBR14 WITH ### MOD/DELETE CARDS AFTER  \"\n   SAY \"       THE CURSOR POSITION. ### DEFAULTS TO 1.            \"\n   SAY\n   SAY \"       A QUESTION MARK ALONE CAUSES THIS HELP TO DISPLAY. \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CUD": {"ttr": 19722, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x97\\x00\\x97\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 151, "newlines": 151, "modlines": 0, "user": "REXX"}, "text": "/** REXX -- DYNAMICALLY CREATE CLEAN UP JCL AFTER CURSOR POSITION **/\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'CUD EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      EXIT(12)\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      ADDRESS ISREDIT \"ISREDIT MACRO (PARMS) NOPROCESS\"\n      PARMS = TRANSLATE(PARMS)\n      IF PARMS = \"?\" THEN SIGNAL DISPDOC\n   END\n   ELSE DO\n      SAY 'CUD EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      EXIT(12)\n   END\n\n   ADDRESS ISREDIT\n   \"(LINE,COL) = CURSOR\"\n   IF LINE = 1  THEN DO\n       ADDRESS ISPEXEC \"VGET (ZSCREENC,ZSCREENI) SHARED\"\n       II = INDEX(ZSCREENI,'* Top of Data *')\n       IF ( ZSCREENC % 80 )  <=  ( II % 80 )  THEN LINE = 0\n       ELSE LINE = 1\n   END\n   \"PROCESS RANGE C\"\n   IF RC > 0 THEN DO\n      \"(TOP) = LINENUM .ZFIRST\"\n      \"(BOT) = LINENUM .ZLAST\"\n   END\n   ELSE DO\n      \"(TOP) = LINENUM .ZFRANGE\"\n      \"(BOT) = LINENUM .ZLRANGE\"\n   END\n\n   CARD4 = \"//           DISP=(MOD,DELETE,DELETE),\",\n      || \"UNIT=SYSDA,SPACE=(TRK,0)\"\n   CARD3 = \"//DEL...     DD    DSN=\"\n   CARD2 = \"//CLEANUP  EXEC  PGM=IEFBR14\"\n   CARD1 = \"//***\"\n\n   ARRAY.0 = 0\n   DO II = TOP TO BOT\n      \"ISREDIT (REC) = LINE &II\"\n      IF (POS('DISP=(,CAT',REC) <> 0 | POS('DISP=(NEW,CAT',REC) <> 0),\n            & SUBSTR(REC,1,3) <> '//*' THEN DO\n         JJ = POS('DSN=',REC)\n         IF JJ = 0 THEN DO\n            JJ = POS('DSNAME=',REC)\n            IF JJ <> 0 THEN JJ = JJ + 3\n         END\n         IF JJ = 0 THEN DO\n            XX = II - 1\n            \"ISREDIT (REC) = LINE &XX\"\n            DO WHILE(SUBSTR(REC,1,3) = '//*' | SUBSTR(REC,1,2) = '/*')\n               XX = XX - 1\n               \"ISREDIT (REC) = LINE &XX\"\n            END\n            DO KK = 71 TO 1 BY -1 WHILE(SUBSTR(REC,KK,1) = ' ')\n            END KK\n            DO WHILE(SUBSTR(REC,KK,1) = ',')\n               JJ = POS('DSN=',REC)\n               IF JJ = 0 THEN DO\n                  JJ = POS('DSNAME=',REC)\n                  IF JJ <> 0 THEN JJ = JJ + 3\n               END\n               IF JJ <> 0 THEN LEAVE\n               XX = XX - 1\n               \"ISREDIT (REC) = LINE &XX\"\n               DO WHILE(SUBSTR(REC,1,3) = '//*')\n                  XX = XX - 1\n                  \"ISREDIT (REC) = LINE &XX\"\n               END\n               DO KK = 71 TO 1 BY -1 WHILE(SUBSTR(REC,KK,1) = ' ')\n               END KK\n            END\n            IF JJ = 0 THEN DO\n               XX = II\n               \"ISREDIT (REC) = LINE &XX\"\n               DO KK = 71 TO 1 BY -1 WHILE(SUBSTR(REC,KK,1) = ' ')\n               END KK\n               DO WHILE(SUBSTR(REC,KK,1) = ',')\n                  XX = XX + 1\n                  \"ISREDIT (REC) = LINE &XX\"\n                  DO WHILE(SUBSTR(REC,1,3) = '//*')\n                     XX = XX + 1\n                     \"ISREDIT (REC) = LINE &XX\"\n                  END\n                  JJ = POS('DSN=',REC)\n                  IF JJ = 0 THEN DO\n                     JJ = POS('DSNAME=',REC)\n                     IF JJ <> 0 THEN JJ = JJ + 3\n                  END\n                  IF JJ <> 0 THEN LEAVE\n                  DO KK = 71 TO 1 BY -1 WHILE(SUBSTR(REC,KK,1) = ' ')\n                  END KK\n               END\n            END\n         END\n         IF JJ <> 0 THEN DO\n            JJ = JJ + 4\n            DO KK = (JJ+1) TO 71,\n               WHILE(SUBSTR(REC,KK,1) <> ' ' & SUBSTR(REC,KK,1) <> ',')\n            END KK\n            IF SUBSTR(REC,kk-1,1) <> ')' THEN DO\n               ARRAY.0 = ARRAY.0 + 1\n               NN      = ARRAY.0\n               ARRAY.NN = SUBSTR(REC,JJ,KK-JJ)\n            END\n         END\n      END\n   END II\n\n   IF ARRAY.0 > 0 THEN \"LINE_AFTER (LINE) = (CARD1)\"\n   DO II = ARRAY.0 TO 1 BY -1\n      \"LINE_AFTER (LINE) = (CARD4)\"\n      CARD  = CARD3 || ARRAY.II || ','\n      PATCH = RIGHT(II,3,'0')\n      CARD  = OVERLAY(PATCH,CARD,6,3)\n      \"LINE_AFTER (LINE) = (CARD)\"\n   END II\n\n   IF ARRAY.0 > 0 THEN DO\n      \"LINE_AFTER (LINE) = (CARD2)\"\n      \"LINE_AFTER (LINE) = (CARD1)\"\n   END\n   ELSE SAY \"No 'NEW,CATLG' dispositions found; no JCL generated!\"\n\n   IF LINE = 0 AND COL = 0 THEN EXIT(1)\n   ELSE DO\n      'ISREDIT CURSOR = ' LINE COL\n      EXIT(0)\n   END\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"CUD  -  DYNAMICALLY GENERATE CLEAN UP JCL AFTER CURSOR    \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    CUD  ( ? )                                            \"\n   SAY\n   SAY \"       CREATE AN IEFBR14 WITH MOD/DELETE CARDS FOR EVERY  \"\n   SAY \"       NEW CATALOGED DATA SET IN THE FILE AND PLACE THEM  \"\n   SAY \"       IMMEDIATELY AFTER WHERE THE CURSOR IS POSITIONED.  \"\n   SAY \"       C/CC/C# MAY BE USED TO LIMIT THE SEARCH.           \"\n   SAY\n   SAY \"       A QUESTION MARK ALONE CAUSES THIS HELP TO DISPLAY. \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CUTX": {"ttr": 19726, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00T\\x00T\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 84, "newlines": 84, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- Write lines from a file to the profile  **/\n\n   Address ISPEXEC\n   'ISREDIT MACRO (Parm1) NOPROCESS'\n   Parm1 = translate(Parm1)\n   If Parm1 = '?' then signal DispDoc\n\n   'ISREDIT PROCESS RANGE C M'\n   Select\n       When rc = 0 then do\n           'ISREDIT (CMD)   = RANGE_CMD'\n           'ISREDIT (LINE1) = LINENUM .ZFRANGE'\n           'ISREDIT (LINE2) = LINENUM .ZLRANGE'\n           LinesToCut = Line2 - Line1 + 1\n       End\n       When rc <= 4 then do\n           zedsmsg = 'Enter \"C\"/\"M\" line cmd'\n           zedlmsg = 'CUT requires a \"C\" or \"M\" line command'\n           'SETMSG MSG(ISRZ001)'\n           Exit 12\n       End\n       Otherwise  exit(12)\n   End\n\n   'VGET (CUTCNT) PROFILE'\n   If RC <> 0 then CutCnt = 0\n   If Parm1 <> 'A' & Parm1 <> 'APPEND' then do\n       If CutCnt <> 0 then do\n           Do i = 1 to CutCnt by 1\n             'VERASE (CL'i') PROFILE'\n           End\n       End\n       CutCnt = 0\n   End\n\n   Control Errors Return\n   Do i = Line1 to Line2\n       CutCnt = CutCnt + 1\n       'ISREDIT (CL'CutCnt') = LINE' i\n       Interpret \"CL\"CutCnt\"= Strip(CL\"CutCnt\",'T')\"\n       'VPUT (CL'CutCnt') PROFILE'\n       If RC <> 0 then do\n           RetCode = RC\n           Say '** An error occurred when placing the data',\n               'into the Profile Pool'\n           Say '** You may be trying to CUTX too much data',\n               '- please try a smaller amount'\n           Say '** The code passed back was' RetCode\n           Exit(RetCode)\n       End\n   End\n   'VPUT (CUTCNT) PROFILE'\n\n   If Cmd = 'M' then do\n       'ISREDIT DELETE' Line1 Line2\n        zedsmsg = LinesToCut 'lines cut and deleted'\n        msg = 'lines were cut and deleted from the current file'\n        zedlmsg = LinesToCut msg\n       'SETMSG MSG(ISRZ000)'\n   End\n   Else do\n        zedsmsg = LinesToCut 'lines cut'\n        zedlmsg = LinesToCut 'lines were cut from the current file'\n       'SETMSG MSG(ISRZ000)'\n   End\n   Exit(0)\n\nDispDoc:\n   ADDRESS TSO \"CLEAR\"\n   Say 'CUTX will place or append lines to the PROFILE pool for later'\n   Say 'inclusion by the various paste macros.                       '\n   Say\n   Say '     CUTX  ( A | APPEND )                                    '\n   Say\n   Say 'Enter CUTX on the COMMAND line and use the C or M line       '\n   Say '(in any form) to select the lines to be cut. If the M line   '\n   Say 'command is used, the lines will be deleted.                  '\n   Say\n   Say 'A parameter of A or APPEND can be specified to add to any    '\n   Say 'previously cut lines (that have not yet been pasted) with the'\n   Say 'newly selected lines.  Otherwise, the selected lines will    '\n   Say 'replace any previously cut lines.                            '\n   Say\n   Exit(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CVB": {"ttr": 19729, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xdb\\x00\\xdb\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 219, "newlines": 219, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- CONVERT NUMERIC DISPLAY DATA TO BINARY  **/\n   NUMERIC DIGITS 30\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'CVB MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (FRMLEFT,FRMRIGHT,PARMS)\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY CVB 'EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT',\n         'WITH NO PENDING EDIT COMMANDS!'\n      SIGNAL EOJ\n   END\n   ADDRESS ISREDIT \"CAPS OFF\"\n\n   ERRORMSG = ''\n   MESG = ''\n   IF FRMLEFT = '' THEN DO\n     SIGNAL ERROR\n   END\n   IF FRMLEFT = ''  |  FRMRIGHT = ''  THEN DO\n      MESG = 'PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMLEFT,'W')  |  FRMLEFT = 0  THEN DO\n      MESG = \"'\"FRMLEFT\"' VALUE OF FROM-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMRIGHT,'W')  |  FRMRIGHT = 0  THEN DO\n      MESG = \"'\"FRMRIGHT\"' VALUE OF FROM-RIGHT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF FRMLEFT > FRMRIGHT THEN DO\n      MESG = \"FROM-LEFT-COL \"FRMLEFT\" IS > THAN FROM-RIGHT-COL \"FRMRIGHT\n      SIGNAL ERROR\n   END\n\n   PARMS   = TRANSLATE(PARMS)\n   LBL1    = \"\"\n   LBL2    = \"\"\n   TOLEFT  = \"\"\n   TORIGHT = \"\"\n   MINUS   = 0\n   DO II = 1 TO 5;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n      END\n      ELSE IF SUBSTR(TOKEN,1,1) = \"-\" THEN DO\n         MINUS = SUBSTR(TOKEN,2)\n      END\n      ELSE DO\n         IF DATATYPE(TOKEN,'W')  THEN DO\n            IF TOLEFT = \"\" THEN TOLEFT = TOKEN\n            ELSE IF TORIGHT = \"\" THEN TORIGHT = TOKEN\n               ELSE DO\n                  ZEDSMSG = \".LABEL RC=8\"\n                  ZEDLMSG = \"TOO MANY COLUMNS --\" TOLEFT TORIGHT TOKEN\n                  ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n                  EXIT 8\n               END\n         END\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n   IF TOLEFT <> \"\" AND TORIGHT = \"\" THEN TORIGHT = TOLEFT\n   IF TOLEFT = \"\" THEN DO\n      TOLEFT  = FRMLEFT\n      TORIGHT = FRMRIGHT\n   END\n\n   IF \u00acDATATYPE(TOLEFT,'W')  |  TOLEFT=0  THEN DO\n      MESG = \"'\"TOLEFT\"' VALUE OF TO-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(TORIGHT,'W')  |  TORIGHT=0  THEN DO\n      MESG = \"'\"TORIGHT\"' VALUE OF TO-RIGHT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   LEN = FRMRIGHT - FRMLEFT + 1\n   IF TOLEFT > TORIGHT THEN DO\n      MESG = \"TO-LEFT-COL \"TOLEFT\" IS GREATER THAN TO-RIGHT-COL \"TORIGHT\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF TORIGHT > LRECL THEN DO\n      MESG = \"TO-RIGHT COLUMN IS GREATER THAN RECORD SIZE (\"LRECL\")\"\n      SIGNAL ERROR\n   END\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR \"\n   \"ISREDIT (\"ANUM\") = AUTONUM \"\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n\n   START = 1\n   IF LBL1 <> '' THEN\n       \"ISREDIT (START) = LINENUM &LBL1\"\n\n   IF LBL2 <> '' THEN\n        \"ISREDIT (END) = LINENUM &LBL2\"\n   ELSE\n        LBL2 = LBL1\n\n   IF START > END THEN DO\n      WST = START\n      START = END\n      END = WST\n   END\n\n   TOT  = 0\n   OVFL = 0\n   DO PNTR =  START  TO  END  BY 1\n      TOT = TOT + 1\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      IF MINUS = 0,\n         THEN DO\n           IF VERIFY(SUBSTR(RECORD,FRMRIGHT,1),'}JKLMNOPQR') = 0\n             THEN ISTR = '-',\n                  || SUBSTR(RECORD,FRMLEFT,FRMRIGHT-FRMLEFT),\n                  || TRANSLATE(SUBSTR(RECORD,FRMRIGHT,1),\n                     ,'0123456789', '}JKLMNOPQR')\n             ELSE IF VERIFY(SUBSTR(RECORD,FRMRIGHT,1),'{ABCDEFGHI') = 0\n               THEN ISTR = '+',\n                     || SUBSTR(RECORD,FRMLEFT,FRMRIGHT-FRMLEFT),\n                     || TRANSLATE(SUBSTR(RECORD,FRMRIGHT,1),\n                        ,'0123456789', '{ABCDEFGHI')\n               ELSE ISTR = SUBSTR(RECORD,FRMLEFT,FRMRIGHT-FRMLEFT+1)\n         END\n         ELSE ISTR = SUBSTR(RECORD,MINUS,1),\n                     || SUBSTR(RECORD,FRMLEFT,FRMRIGHT-FRMLEFT+1)\n      USTR = X2C(D2X(ISTR,2*(TORIGHT - TOLEFT + 1)))\n      RECORD = SUBSTR(RECORD,1,TOLEFT-1),\n               || USTR,\n               || SUBSTR(RECORD,TORIGHT+1)\n      \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n   END\n\n   STR = OVFL || '/' || TOT\n   CALL SETMSG '* NO ' STR 'CVB $OVERFLOW OVER TOTAL'\n   \"ISREDIT LOCATE\" START\n   \"ISREDIT AUTONUM =\" ANUM\n    SIGNAL EOJ\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   CALL DISPDOC\n\nEOJ:\n   SAY \"PLEASE NOTE, CAPS IS NOW OFF...\"\n   X = MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"CVB - DECIMAL TO BINARY CONVERSION BY COLUMNS             \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    CVB     FROM-COL1 FROM-COL2 (TO-COL1 TO-COL2)         \"\n   SAY \"              (-MINUS-COL)  (.A .B)                       \"\n   SAY\n   SAY \"       FROM-COLUMNS ARE REQUIRED. TO-COLUMNS WILL DEFAULT \"\n   SAY \"       TO FROM-COLUMNS.  THE MINUS COLUMN AND THE LABEL   \"\n   SAY \"       RANGES ARE OPTIONAL.                               \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY \"    CVB        2 18  73 80  -1 .A .B                      \"\n   SAY \"       WILL CONVERT THE NUMERIC DATA IN COLUMNS 2 THROUGH \"\n   SAY \"       18 INTO A 8 BYTE BINARY NUMBER IN COLUMNS 73 TO    \"\n   SAY \"       80 IN THE RANGE .A THROUGH .B, PICKING UP THE SIGN \"\n   SAY \"       FROM COLUMN 1.                                     \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CVD": {"ttr": 19973, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xe9\\x00\\xe9\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 233, "newlines": 233, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- CONVERT BINARY TO NUMERIC DISPLAY  **/\n   NUMERIC DIGITS 30\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'CVD MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (FRMLEFT,FRMRIGHT,PARMS)\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY CVD 'EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT',\n         'WITH NO PENDING EDIT COMMANDS!'\n      SIGNAL EOJ\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n   IF FRMLEFT = '' THEN DO\n     SIGNAL ERROR\n   END\n   IF FRMLEFT = ''  |  FRMRIGHT = ''  THEN DO\n      MESG = 'PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMLEFT,'W')  |  FRMLEFT = 0  THEN DO\n      MESG = \"'\"FRMLEFT\"' VALUE OF FROM-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMRIGHT,'W')  |  FRMRIGHT = 0  THEN DO\n      MESG = \"'\"FRMRIGHT\"' VALUE OF FROM-RIGHT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF FRMLEFT > FRMRIGHT THEN DO\n      MESG = \"FROM-LEFT-COL \"FRMLEFT\" IS > THAN FROM-RIGHT-COL \"FRMRIGHT\n      SIGNAL ERROR\n   END\n\n   PARMS   = TRANSLATE(PARMS)\n   LBL1    = \"\"\n   LBL2    = \"\"\n   TOLEFT  = \"\"\n   TORIGHT = \"\"\n   MINUS   = 0\n   DO II = 1 TO 5;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n      END\n      ELSE IF SUBSTR(TOKEN,1,1) = \"-\" THEN DO\n         MINUS = SUBSTR(TOKEN,2)\n      END\n      ELSE DO\n         IF DATATYPE(TOKEN,'W')  THEN DO\n            IF TOLEFT = \"\" THEN TOLEFT = TOKEN\n            ELSE IF TORIGHT = \"\" THEN TORIGHT = TOKEN\n               ELSE DO\n                  ZEDSMSG = \".LABEL RC=8\"\n                  ZEDLMSG = \"TOO MANY COLUMNS --\" TOLEFT TORIGHT TOKEN\n                  ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n                  EXIT 8\n               END\n         END\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n   IF TOLEFT <> \"\" AND TORIGHT = \"\" THEN TORIGHT = TOLEFT\n   IF TOLEFT = \"\" THEN DO\n      TOLEFT  = FRMLEFT\n      TORIGHT = FRMRIGHT\n   END\n\n   IF \u00acDATATYPE(TOLEFT,'W')  |  TOLEFT=0  THEN DO\n      MESG = \"'\"TOLEFT\"' VALUE OF TO-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(TORIGHT,'W')  |  TORIGHT=0  THEN DO\n      MESG = \"'\"TORIGHT\"' VALUE OF TO-RIGHT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   LEN = FRMRIGHT - FRMLEFT + 1\n   IF TOLEFT > TORIGHT THEN DO\n      MESG = \"TO-LEFT-COL \"TOLEFT\" IS GREATER THAN TO-RIGHT-COL \"TORIGHT\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF TORIGHT > LRECL THEN DO\n      MESG = \"TO-RIGHT COLUMN IS GREATER THAN RECORD SIZE (\"LRECL\")\"\n      SIGNAL ERROR\n   END\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR \"\n   \"ISREDIT (\"ANUM\") = AUTONUM \"\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n\n   START = 1\n   IF LBL1 <> '' THEN\n       \"ISREDIT (START) = LINENUM &LBL1\"\n\n   IF LBL2 <> '' THEN\n        \"ISREDIT (END) = LINENUM &LBL2\"\n   ELSE\n        LBL2 = LBL1\n\n   IF START > END THEN DO\n      WST = START\n      START = END\n      END = WST\n   END\n\n   TOT  = 0\n   OVFL = 0\n   DO PNTR =  START  TO  END  BY 1\n      TOT = TOT + 1\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      N  = FRMRIGHT-FRMLEFT+1\n      USTR = X2D(C2X(SUBSTR(RECORD,FRMLEFT,N)),(2*N))\n      IF MINUS = 0,\n         THEN DO\n            IF SUBSTR(USTR,1,1) = '-'\n               THEN USTR = SUBSTR(USTR,2,LENGTH(USTR)-2),\n                     || TRANSLATE(SUBSTR(USTR,LENGTH(USTR),1),\n                           ,'}JKLMNOPQR','0123456789')\n         END\n         ELSE DO\n            IF SUBSTR(USTR,1,1) = '-'\n               THEN DO\n                  RECORD = SUBSTR(RECORD,1,MINUS-1),\n                     || '-',\n                     || SUBSTR(RECORD,MINUS+1)\n                  USTR = SUBSTR(USTR,2)\n               END\n               ELSE RECORD = SUBSTR(RECORD,1,MINUS-1),\n                     || '+',\n                     || SUBSTR(RECORD,MINUS+1)\n         END\n      IF LENGTH(USTR) > TORIGHT - TOLEFT + 1,\n         THEN DO\n            RECORD = SUBSTR(RECORD,1,TOLEFT-1),\n               || SUBSTR(USTR,LENGTH(USTR)-TORIGHT+TOLEFT),\n               || SUBSTR(RECORD,TORIGHT+1)\n            USTRO = LENGTH(USTR) - TORIGHT + TOLEFT - 1\n            ZEROS  = COPIES('0',USTRO)\n            IF SUBSTR(USTR,1,USTRO) <> ZEROS THEN OVFL = OVFL + 1\n         END\n         ELSE DO\n            ZEROS  = COPIES('0',TORIGHT-TOLEFT+1-LENGTH(USTR))\n            ZEROS  = ZEROS || USTR\n            RECORD = SUBSTR(RECORD,1,TOLEFT-1),\n               || ZEROS || SUBSTR(RECORD,TORIGHT+1)\n         END\n      \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n   END\n\n   STR = OVFL || '/' || TOT\n   CALL SETMSG '* NO ' STR 'CVD $OVERFLOW OVER TOTAL'\n   \"ISREDIT LOCATE\" START\n   \"ISREDIT AUTONUM =\" ANUM\n    SIGNAL EOJ\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   CALL DISPDOC\n\nEOJ:\n   X = MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"CVD - BINARY CONVERSION TO DECIMAL BY COLUMNS\"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    CVD     FROM-COL1 FROM-COL2 (TO-COL1 TO-COL2)         \"\n   SAY \"              (-MINUS-COL)  (.A .B)                       \"\n   SAY\n   SAY \"       FROM-COLUMNS ARE REQUIRED. TO-COLUMNS WILL DEFAULT \"\n   SAY \"       TO FROM-COLUMNS.  THE MINUS COLUMN AND THE LABEL   \"\n   SAY \"       RANGES ARE OPTIONAL.                               \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY \"    CVD       15 18  73 80  .A .B  -72                    \"\n   SAY \"       WILL CONVERT THE BINARY VALUE IN COLS THRU 18 TO   \"\n   SAY \"       DISPLAY NUMERICS IN COLUMNS 73 THROUGH 80 WITHIN   \"\n   SAY \"       LINE RANGE .A THRU .B AND PLACE THE SIGN IN COLUMN \"\n   SAY \"       72.                                                \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "C2H": {"ttr": 19978, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xe0\\x00\\xe0\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 224, "newlines": 224, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- CONVERT NUMERIC DISPLAY DATA TO HEXIDECIMAL DISPLAY  **/\n   NUMERIC DIGITS 30\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'C2H MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (FRMLEFT,FRMRIGHT,PARMS)\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY C2H 'EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT',\n         'WITH NO PENDING EDIT COMMANDS!'\n      SIGNAL EOJ\n   END\n   ADDRESS ISREDIT \"CAPS OFF\"\n\n   ERRORMSG = ''\n   MESG = ''\n   IF FRMLEFT = '' THEN DO\n     SIGNAL ERROR\n   END\n   IF FRMLEFT = ''  |  FRMRIGHT = ''  THEN DO\n      MESG = 'PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMLEFT,'W')  |  FRMLEFT = 0  THEN DO\n      MESG = \"'\"FRMLEFT\"' VALUE OF FROM-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMRIGHT,'W')  |  FRMRIGHT = 0  THEN DO\n      MESG = \"'\"FRMRIGHT\"' VALUE OF FROM-RIGHT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF FRMLEFT > FRMRIGHT THEN DO\n      MESG = \"FROM-LEFT-COL \"FRMLEFT\" IS > THAN FROM-RIGHT-COL \"FRMRIGHT\n      SIGNAL ERROR\n   END\n\n   PARMS   = TRANSLATE(PARMS)\n   LBL1    = \"\"\n   LBL2    = \"\"\n   TOLEFT  = \"\"\n   TORIGHT = \"\"\n   DO II = 1 TO 5;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n      END\n      ELSE IF SUBSTR(TOKEN,1,1) = \"-\" THEN DO\n         MINUS = SUBSTR(TOKEN,2)\n      END\n      ELSE DO\n         IF DATATYPE(TOKEN,'W')  THEN DO\n            IF TOLEFT = \"\" THEN TOLEFT = TOKEN\n            ELSE IF TORIGHT = \"\" THEN TORIGHT = TOKEN\n               ELSE DO\n                  ZEDSMSG = \".LABEL RC=8\"\n                  ZEDLMSG = \"TOO MANY COLUMNS --\" TOLEFT TORIGHT TOKEN\n                  ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n                  EXIT 8\n               END\n         END\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n   IF TOLEFT <> \"\" AND TORIGHT = \"\" THEN TORIGHT = TOLEFT\n   IF TOLEFT = \"\" THEN DO\n      TOLEFT  = FRMLEFT\n      TORIGHT = FRMRIGHT\n   END\n\n   IF \u00acDATATYPE(TOLEFT,'W')  |  TOLEFT=0  THEN DO\n      MESG = \"'\"TOLEFT\"' VALUE OF TO-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(TORIGHT,'W')  |  TORIGHT=0  THEN DO\n      MESG = \"'\"TORIGHT\"' VALUE OF TO-RIGHT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   LEN = FRMRIGHT - FRMLEFT + 1\n   IF TOLEFT > TORIGHT THEN DO\n      MESG = \"TO-LEFT-COL \"TOLEFT\" IS GREATER THAN TO-RIGHT-COL \"TORIGHT\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF TORIGHT > LRECL THEN DO\n      MESG = \"TO-RIGHT COLUMN IS GREATER THAN RECORD SIZE (\"LRECL\")\"\n      SIGNAL ERROR\n   END\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR \"\n   \"ISREDIT (\"ANUM\") = AUTONUM \"\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n\n   START = 1\n   IF LBL1 <> '' THEN\n       \"ISREDIT (START) = LINENUM &LBL1\"\n\n   IF LBL2 <> '' THEN\n        \"ISREDIT (END) = LINENUM &LBL2\"\n   ELSE\n        LBL2 = LBL1\n\n   IF START > END THEN DO\n      WST = START\n      START = END\n      END = WST\n   END\n\n   TOT  = 0\n   OVFL = 0\n   NG   = 0\n   FLEN = FRMRIGHT - FRMLEFT + 1\n   TLEN = TORIGHT  - TOLEFT  + 1\n\n   DO PNTR =  START  TO  END  BY 1\n      TOT = TOT + 1\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      IF VERIFY(SUBSTR(RECORD,FRMLEFT,FLEN),\n            ,'ABCDEF0123456789') = 0 THEN DO\n         OSTR = X2C(SUBSTR(RECORD,FRMLEFT,FLEN))\n         IF LENGTH(OSTR) > TLEN THEN DO\n            IF VERIFY(SUBSTR(OSTR,1,LENGTH(OSTR)-TLEN),'00'X)=0 THEN DO\n               RECORD = SUBSTR(RECORD,1,TOLEFT-1),\n                        || SUBSTR(X2C(SUBSTR(RECORD,FRMLEFT,FLEN)),\n                           ,LENGTH(OSTR)-TLEN+1),\n                        || SUBSTR(RECORD,TORIGHT+1)\n               \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n            END\n            ELSE OVFL = OVFL + 1\n         END\n         ELSE DO\n            RECORD = SUBSTR(RECORD,1,TOLEFT-1),\n                     || COPIES('00'X,TLEN-LENGTH(OSTR)),\n                     || X2C(SUBSTR(RECORD,FRMLEFT,FLEN)),\n                     || SUBSTR(RECORD,TORIGHT+1)\n            \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n         END\n      END\n      ELSE NG = NG + 1\n   END\n\n   STR = TOT '/' OVFL '/' NG\n   CALL SETMSG '* NO ' STR 'C2H $TOTAL IN RANGE/OVERFLOWS/BAD DATA'\n   \"ISREDIT LOCATE\" START\n   \"ISREDIT AUTONUM =\" ANUM\n    SIGNAL EOJ\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   CALL DISPDOC\n\nEOJ:\n   SAY \"PLEASE NOTE, CAPS IS NOW OFF...\"\n   X = MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"C2H - DECIMAL TO HEXIDECIMAL BY COLUMNS                   \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    C2H     FROM-COL1 FROM-COL2 (TO-COL1 TO-COL2)         \"\n   SAY \"                            (.A .B)                       \"\n   SAY\n   SAY \"       FROM-COLUMNS ARE REQUIRED. TO-COLUMNS WILL DEFAULT \"\n   SAY \"       TO FROM-COLUMNS.  LABEL RANGE IS OPTIONAL.         \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY \"    C2H        1 6  11 13  .A .B                          \"\n   SAY \"       WILL CONVERT THE NUMERIC DATA IN COLUMNS 1 THROUGH \"\n   SAY \"       6 INTO ITS 3 BYTE HEXIDECIMAL EQUIVALENT IN        \"\n   SAY \"       COLUMNS 11 TO 13 IN RANGE .A THRU .B. SO IF        \"\n   SAY \"       '012AC3' WERE IN 1 THRU 6, 11 THRU 13 WOULD CONTAIN\"\n   SAY \"       X'012AC3' ON COMPLETION. INPUT MUST BE A-F OR 0-9  \"\n   SAY \"       AND RESULT MUST FIT UNLESS HIGH ORDER 0'S ARE LOST.\"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELBLANK": {"ttr": 20226, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00e\\x00e\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 101, "newlines": 101, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- DELETE BLANK LINES; USE LABEL RANGE IF SPECIFIED  **/\n\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'DELBLANK MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n             \"ISREDIT MACRO (LBL1,LBL2)\"\n      IF RC = 0 THEN DO\n         IF LBL1 = '?' THEN SIGNAL DISPDOC\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY 'DELBLANK EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT',\n          'WITH NO PENDING EDIT COMMANDS!'\n      SIGNAL EOJ\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n       \"ISREDIT (START) = LINENUM &LBL1\"\n   END\n   ELSE START = 1\n\n   IF LBL2 <> '' THEN DO\n       \"ISREDIT L &LBL2\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n       \"ISREDIT (END) = LINENUM &LBL2\"\n   END\n   ELSE \"ISREDIT (END) = LINENUM .ZLAST \"\n\n   IF START > END THEN DO\n      FLIP  = START\n      START = END\n      END   = FLIP\n   END\n\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR \"\n   \"ISREDIT (\"ANUM\") = AUTONUM \"\n\n   PNTR = END\n   DO WHILE PNTR >= START\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      IF RECORD = ' ' THEN \"ISREDIT DELETE &PNTR\"\n      PNTR = PNTR - 1\n   END\n\n  \"ISREDIT LOCATE\" 1\n  \"ISREDIT AUTONUM = \"ANUM\n   SIGNAL EOJ\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '*** ERROR *** ' MESG\n   END\n\nEOJ:\n   X = MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"DELBLANK - DELETE ALL BLANK LINES WITHIN OPTIONAL RANGE\"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    DELBLANK  ( .A .B )\"\n   SAY \"       THE LABEL RANGE IS OPTIONAL. \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY \"    DELBLANK \"\n   SAY \"       WILL DELETE ANY BLANK LINES IN THE EDITED FILE \"\n   SAY\n   SAY \"    DELBLANK  .AA .BB \"\n   SAY \"       WILL DELETE ANY BLANK LINES IN THE LABEL RANGE \"\n   SAY \"       .AA THRU .BB \"\n   SAY\n   SIGNAL EOJ\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELCOLS": {"ttr": 20229, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x03'\\x1f\\x01\\x03'\\x1f\\x12\\x00\\x01\\x00\\x01\\x00\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-09-28T00:00:00", "modifydate": "2003-09-28T12:00:00", "lines": 256, "newlines": 256, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- DELETE SPECIFIED COLUMNS, SHIFTING LEFT REMAINS  **/\n   RTN = 0\n   SAVEMSG = MSG(\"OFF\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'DELCOLS MUST BE RUN UNDER ISPF!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (PARMS) NOPROCESS\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      ARG PARMS\n      SIGNAL DSLIST\n   END\n\n   ERRORMSG = \"\"\n   MESG     = \"\"\n   COL.     = \"\"\n   PARMCNT  = 0\n   LBL1     = \"\"\n   LBL2     = \"\"\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR \"\n   DO II = 1 TO 22;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n      END\n      ELSE DO\n         IF  \u00acDATATYPE(TOKEN,'W') | TOKEN = 0 THEN DO\n            MESG = \"'\"TOKEN\"' COLUMN VALUE IS INVALID!\"\n            SIGNAL ERROR\n         END\n         IF TOKENT > LRECL THEN DO\n            MESG = \"COLUMN\" TOKEN \"IS BIGGER THAN RECORD SIZE (\"LRECL\")\"\n            SIGNAL ERROR\n         END\n         PARMCNT     = PARMCNT + 1\n         COL.PARMCNT = TOKEN\n      END\n   END II\n\n   IF (PARMCNT // 2) <> 0 THEN DO\n      MESG = \"THERE ARE AN ODD NUMBER OF COLUMNS (\"PARMCNT\")\"\n      SIGNAL ERROR\n   END\n\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n   IF LBL1 <> \"\" THEN DO\n      \"ISREDIT L &LBL1\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n      \"ISREDIT (START) = LINENUM &LBL1\"\n      \"ISREDIT L &LBL2\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n      \"ISREDIT (END) = LINENUM &LBL2\"\n   END\n   ELSE DO\n      \"ISREDIT PROCESS RANGE C\"\n      IF RC > 0 THEN DO\n         START  = 1\n         \"ISREDIT (END) = LINENUM .ZLAST\"\n      END\n      ELSE DO\n         \"ISREDIT (START) = LINENUM .ZFRANGE\"\n         \"ISREDIT (END)   = LINENUM .ZLRANGE\"\n      END\n   END\n\n   IF START > END THEN DO\n      FLIP  = START\n      START = END\n      END   = FLIP\n   END\n\n   KEEPON = \"YES\"\n   IF PARMCNT > 2 THEN DO II = 1 TO PARMCNT-3 BY 2,\n         WHILE (KEEPON = \"YES\")\n      KEEPON = \"NO\"\n      DO JJ = II+2 TO PARMCNT-1 BY 2\n         IF COL.II > COL.JJ THEN DO\n            TEMP1  = COL.II\n            XX     = II + 1\n            TEMP2  = COL.XX\n            COL.II = COL.JJ\n            YY     = JJ + 1\n            COL.XX = COL.YY\n            COL.JJ = TEMP1\n            COL.YY = TEMP2\n            KEEPON = \"YES\"\n         END\n      END JJ\n   END II\n\n   DO II = 1 TO PARMCNT-1 BY 2\n      XX = II + 1\n      IF COL.XX < COL.II THEN DO\n         MESG = \"COLUMNS\" COL.II \"AND\" COL.XX \"NOT IN ORDER\"\n         SIGNAL ERROR\n      END\n   END II\n\n   DO PNTR =  START  TO  END  BY 1\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      REC  = \"\"\n      GOOD = LRECL\n      DO II = PARMCNT-1 TO 1 BY -2\n         XX   = II + 1\n         REC  = SUBSTR(RECORD,COL.XX+1,GOOD-COL.XX) || REC\n         GOOD = COL.II - 1\n      END II\n      REC  = SUBSTR(RECORD,1,GOOD) || REC\n      \"ISREDIT LINE &PNTR = &STR(REC)\"\n   END\n\n   \"ISREDIT LOCATE\" START\n   \"ISREDIT AUTONUM = \"ANUM\n    SIGNAL EOJ\n\nDSLIST:\n   ERRORMSG = \"\"\n   MESG     = \"\"\n   COL.     = \"\"\n   PARMCNT  = 0\n   LBL1     = \"\"\n   LBL2     = \"\"\n   DO II = LENGTH(PARMS)-1 TO 1 BY -1 WHILE(SUBSTR(PARMS,II,1) <> \"'\")\n   END II\n   ZINPDSN = SUBSTR(PARMS,II)\n   PARMS   = SUBSTR(PARMS,1,II-1)\n   LDSI    = LISTDSI(ZINPDSN)\n   LRECL   = SYSLRECL\n   DO II = 1 TO 22;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF  \u00acDATATYPE(TOKEN,'W') | TOKEN = 0 THEN DO\n         ERRORMSG = \"'\"TOKEN\"' COLUMN VALUE IS INVALID!\"\n         SIGNAL DISPDOC\n      END\n      IF TOKENT > LRECL THEN DO\n         ERRORMSG = \"COLUMN\" TOKEN \"IS BIGGER THAN RECORD SIZE (\"LRECL\")\"\n         SIGNAL DISPDOC\n      END\n      PARMCNT     = PARMCNT + 1\n      COL.PARMCNT = TOKEN\n   END II\n\n   IF (PARMCNT // 2) <> 0 THEN DO\n      ERRORMSG = \"THERE ARE AN ODD NUMBER OF COLUMNS (\"PARMCNT\")\"\n      SIGNAL DISPDOC\n   END\n\n   KEEPON = \"YES\"\n   IF PARMCNT > 2 THEN DO II = 1 TO PARMCNT-3 BY 2,\n         WHILE (KEEPON = \"YES\")\n      KEEPON = \"NO\"\n      DO JJ = II+2 TO PARMCNT-1 BY 2\n         IF COL.II > COL.JJ THEN DO\n            TEMP1  = COL.II\n            XX     = II + 1\n            TEMP2  = COL.XX\n            COL.II = COL.JJ\n            YY     = JJ + 1\n            COL.XX = COL.YY\n            COL.JJ = TEMP1\n            COL.YY = TEMP2\n            KEEPON = \"YES\"\n         END\n      END JJ\n   END II\n\n   DO II = 1 TO PARMCNT-1 BY 2\n      XX = II + 1\n      IF COL.XX < COL.II THEN DO\n         ERRORMSG = \"COLUMNS\" COL.II \"AND\" COL.XX \"NOT IN ORDER\"\n         SIGNAL DISPDOC\n      END\n   END II\n\n   ADDRESS TSO\n   \"FREE DD(DDXX)\"\n   \"ALLOC DSN(\"ZINPDSN\") DD(DDXX) SHR\"\n   \"EXECIO 0 DISKRU\" DDXX \"(OPEN\"\n   \"EXECIO 1 DISKRU\" DDXX\n   RET_CD = RC\n   DO WHILE ( RET_CD = 0 )\n      PARSE PULL RECORD\n      REC  = \"\"\n      GOOD = LRECL\n      DO II = PARMCNT-1 TO 1 BY -2\n         XX   = II + 1\n         REC  = SUBSTR(RECORD,COL.XX+1,GOOD-COL.XX) || REC\n         GOOD = COL.II - 1\n      END II\n      REC  = SUBSTR(RECORD,1,GOOD) || REC\n      QUEUE REC\n      \"EXECIO 1 DISKW\" DDXX\n      \"EXECIO 1 DISKRU\" DDXX\n      RET_CD = RC\n   END\n   \"EXECIO 0 DISKW\" DDXX \"(FINIS\"\n   \"FREE DD(DDXX)\"\n    SIGNAL EOJ\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   SIGNAL DISPDOC\n\nEOJ:\n   X = MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"DELCOLS - DELETE SPECIFIC COLUMNS, RETAINING ALL OTHERS \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    DELCOLS   COL-1 COL-2 (...)  ( .A .B  )   \"\n   SAY\n   SAY \"       AT LEAST 1 COLUMN SET REQUIRED.  LABEL \"\n   SAY \"       RANGE OR C/CC/C# RANGE OPTIONAL.       \"\n   SAY\n   SAY \" EXAMPLES \"\n   SAY \"    DELCOLS   5 15   1 2   73 80              \"\n   SAY \"       WILL DELETE COLUMNS 1 THROUGH 2,       \"\n   SAY \"       5 THROUGH 15, AND 73 THROUGH 80,       \"\n   SAY \"       SHIFTING REMAINING COLUMNS TO THE LEFT.\"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELDUPS": {"ttr": 20234, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xa3\\x00\\xa3\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 163, "newlines": 163, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- SORT AND GET RID OF ALL DUPS WITHIN A FILE  **/\n\n   SUBCOM ISREDIT\n   IF  RC = 0  THEN DO\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT \"ISREDIT MACRO (PARMS)\"\n      IF  RC = 0  THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF  DSN = 'DSN'  THEN DO\n      SAY 'DELDUPS MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n\n   PARMS   = TRANSLATE(PARMS)\n   PARMCNT = 0\n   COL.    = \"\"\n   LBL1 = \"\"\n   LBL2 = \"\"\n   DO II = 1 TO 16;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n      END\n      ELSE DO\n         PARMCNT = PARMCNT + 1\n         COL.PARMCNT = TOKEN\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n   IF (PARMCNT // 2) <> 0 THEN DO\n      SAVER = COL.PARMCNT\n      PARMCNT = PARMCNT + 1\n      COL.PARMCNT = SAVER\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n   IF  PARMCNT = 0 THEN DO\n      MESG = 'PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   SORTPARMS = \"\"\n   DO II = 1 TO PARMCNT\n      IF  \u00acDATATYPE(COL.II,'W') | COL.II = 0 THEN DO\n         MESG = \"'\"COL.II\"' COLUMN VALUE IS INVALID!\"\n         SIGNAL ERROR\n      END\n      IF  COL.II > LRECL  THEN DO\n         MESG = \"'\"COL.II\"' IS GREATER THAN RECORD SIZE(\"LRECL\")\"\n         SIGNAL ERROR\n      END\n      SORTPARMS = SORTPARMS || \" \" || COL.II\n   END II\n   DO II = 1 TO PARMCNT BY 2\n      JJ = II + 1\n      SAVER = COL.JJ\n      IF  COL.II > SAVER THEN DO\n         MESG = \"LEFT-COL \"COL.II\" IS GREATER THAN RIGHT-COL \"SAVER\n         SIGNAL ERROR\n      END\n   END II\n\n   IF  LBL1 <> ''  THEN DO\n      \"ISREDIT L &LBL1\"\n       IF  RC <>  0 THEN DO\n          MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   IF  LBL2 <> ''  THEN DO\n      \"ISREDIT L &LBL2\"\n       IF  RC <>  0 THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   IF  LBL1 <> ''  THEN  \"ISREDIT (START) = LINENUM &LBL1\"\n                   ELSE  START = 1\n   IF  LBL2 <> ''  THEN  \"ISREDIT (END) = LINENUM &LBL2\"\n                   ELSE  \"ISREDIT (END) = LINENUM .ZLAST\"\n   \"ISREDIT (LASTLINE) = LINENUM .ZLAST\"\n\n   \"ISREDIT (\"ANUM\") = AUTONUM\"\n   \"ISREDIT NUMBER OFF \"\n\n   \"ISREDIT SORT\" SORTPARMS LBL1 LBL2\n   DELCNT = 0\n\n   PREVKEY = \"\"\n   DO  PNTR  =  START TO END  BY 1\n      \"ISREDIT (RECORD) = LINE \"PNTR\n      NEXTKEY = \"\"\n      DO II = 1 TO PARMCNT BY 2\n         JJ = II + 1\n         SAVER = COL.JJ\n         NEXTKEY = NEXTKEY || SUBSTR(RECORD,COL.II,SAVER-COL.II+1)\n      END II\n      IF NEXTKEY == PREVKEY THEN DO\n         \"ISREDIT LABEL \"PNTR\" = .TMP\"\n         \"ISREDIT X ALL .TMP .TMP\"\n         DELCNT = DELCNT + 1\n      END\n      PREVKEY = NEXTKEY\n   END\n\n   \"ISREDIT DEL ALL X\"\n   CALL SETMSG '* NO ' DELCNT 'RECS DELETED$RECS WITH DUP KEYS DELETED'\n   IF START = 1 THEN \"ISREDIT LOCATE\" 0\n                ELSE DO\n                   START = START - 1\n                   \"ISREDIT LOCATE\" START\n                   END\n   \"ISREDIT AUTONUM = \"ANUM\n   \"ISREDIT CURSOR = \"SAVLINE SAVCOL\n   SIGNAL EOJ\n\nERROR:\n   IF MESG <> '' THEN DO\n      ERRORMSG = '===>' MESG\n   END\n   SIGNAL DISPDOC\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nEOJ:\n   RETURN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"DELDUPS - SORT AND DELETE ANY DUP LINES WITHIN A FILE \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    DELDUPS  COL1 COL2 ...  ( .A .B )                  \"\n   SAY \"       ONE PAIR OF COLUMNS IS MANDATORY. THE LABEL     \"\n   SAY \"       RANGE IS OPTIONAL.                              \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    DELDUPS  17 19  4 11                               \"\n   SAY \"       WILL SORT FILE BY COLUMNS 17 THRU 19 AND 4 THRU \"\n   SAY \"       11 AND DELETE ANY RECORDS, AFTER THE FIRST      \"\n   SAY \"       OCCURRENCE, WITH DUPLICATE KEYS.                \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELDUPX": {"ttr": 20238, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xa1\\x00\\xa1\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 161, "newlines": 161, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- DELETE CONSECUTIVE DUPS BY COLUMNS  **/\n\n   SUBCOM ISREDIT\n   IF  RC = 0  THEN DO\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT \"ISREDIT MACRO (PARMS)\"\n      IF  RC = 0  THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF  DSN = 'DSN'  THEN DO\n      SAY 'DELDUPX MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n\n   PARMS   = TRANSLATE(PARMS)\n   PARMCNT = 0\n   COL.    = \"\"\n   LBL1 = \"\"\n   LBL2 = \"\"\n   DO II = 1 TO 16;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n      END\n      ELSE DO\n         PARMCNT = PARMCNT + 1\n         COL.PARMCNT = TOKEN\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n   IF (PARMCNT // 2) <> 0 THEN DO\n      SAVER = COL.PARMCNT\n      PARMCNT = PARMCNT + 1\n      COL.PARMCNT = SAVER\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n   IF  PARMCNT = 0 THEN DO\n      MESG = 'PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   DO II = 1 TO PARMCNT\n      IF  \u00acDATATYPE(COL.II,'W') | COL.II = 0 THEN DO\n         MESG = \"'\"COL.II\"' COLUMN VALUE IS INVALID!\"\n         SIGNAL ERROR\n      END\n      IF  COL.II > LRECL  THEN DO\n         MESG = \"'\"COL.II\"' IS GREATER THAN RECORD SIZE(\"LRECL\")\"\n         SIGNAL ERROR\n      END\n   END II\n   DO II = 1 TO PARMCNT BY 2\n      JJ = II + 1\n      SAVER = COL.JJ\n      IF  COL.II > SAVER THEN DO\n         MESG = \"LEFT-COL \"COL.II\" IS GREATER THAN RIGHT-COL \"SAVER\n         SIGNAL ERROR\n      END\n   END II\n\n   IF  LBL1 <> ''  THEN DO\n      \"ISREDIT L &LBL1\"\n       IF  RC <>  0 THEN DO\n          MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   IF  LBL2 <> ''  THEN DO\n      \"ISREDIT L &LBL2\"\n       IF  RC <>  0 THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   IF  LBL1 <> ''  THEN  \"ISREDIT (START) = LINENUM &LBL1\"\n                   ELSE  START = 1\n   IF  LBL2 <> ''  THEN  \"ISREDIT (END) = LINENUM &LBL2\"\n                   ELSE  \"ISREDIT (END) = LINENUM .ZLAST\"\n   \"ISREDIT (LASTLINE) = LINENUM .ZLAST\"\n\n   \"ISREDIT (\"ANUM\") = AUTONUM\"\n   \"ISREDIT NUMBER OFF \"\n   DELCNT = 0\n\n   PREVKEY = \"\"\n   DO  PNTR  =  START TO END  BY 1\n      \"ISREDIT (RECORD) = LINE \"PNTR\n      NEXTKEY = \"\"\n      DO II = 1 TO PARMCNT BY 2\n         JJ = II + 1\n         SAVER = COL.JJ\n         NEXTKEY = NEXTKEY || SUBSTR(RECORD,COL.II,SAVER-COL.II+1)\n      END II\n      IF NEXTKEY == PREVKEY THEN DO\n         DELCNT = DELCNT + 1\n         \"ISREDIT LABEL \"PNTR\" = .TMP\"\n         \"ISREDIT X ALL .TMP .TMP\"\n      END\n      PREVKEY = NEXTKEY\n   END\n\n   \"ISREDIT DEL ALL X\"\n   CALL SETMSG '* NO ' DELCNT 'RECS DELETED$RECS WITH DUP KEYS DELETED'\n   IF START = 1 THEN \"ISREDIT LOCATE\" 0\n                ELSE DO\n                   START = START - 1\n                   \"ISREDIT LOCATE\" START\n                   END\n   \"ISREDIT AUTONUM = \"ANUM\n   \"ISREDIT CURSOR = \"SAVLINE SAVCOL\n    SIGNAL EOJ\n\nERROR:\n   IF MESG <> '' THEN DO\n      ERRORMSG = '===>' MESG\n   END\n   SIGNAL DISPDOC\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nEOJ:\n   RETURN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"DELDUPX - DELETE CONSECUTIVE DUPS WITHIN A FILE W/O SORTING \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    DELDUPX  COL1 COL2 ...  ( .A .B )                   \"\n   SAY \"       ONE PAIR OF COLUMNS IS MANDATORY. THE LABEL      \"\n   SAY \"       RANGE IS OPTIONAL.                               \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    DELDUPX  21 25  4 11  .F .L                         \"\n   SAY \"       WILL SCAN FILE WITHIN LABELS .F THRU .L COMPARING\"\n   SAY \"       COLUMNS 21 THRU 25 AND 4 THRU 11. DUPLICATES OF  \"\n   SAY \"       THE PREVIOUS RECORD WILL BE DELETED. NO SORTING  \"\n   SAY \"       IS DONE; THE CURRENT POSITION DETERMINES WHETHER \"\n   SAY \"       A KEY IS A DUPLICATE.                            \"\n   SAY\n   RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELPARA": {"ttr": 20484, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\x15\\x00\\x15\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- DELETE DEBUGGING PARAGRAPH DISPLAY'S  **/\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'DELPARA EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      RETURN\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      ADDRESS ISREDIT \"ISREDIT MACRO (PARMS) NOPROCESS\"\n      PARMS = TRANSLATE(PARMS)\n   END\n   ELSE DO\n      SAY 'DELPARA EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      RETURN\n   END\n\n   \"ISREDIT X ALL\"\n   \"ISREDIT FIND ALL '~DEBUG~'\"\n   \"ISREDIT DEL ALL NX\"\n   \"ISREDIT RESET\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DESC": {"ttr": 20486, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x0e\\x00\\x0e\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "REXX"}, "text": "/* REXX -- GET AND DISPLAY LRECL, BLKSIZE AND NUMBER OF RECORDS       */\n   ADDRESS ISPEXEC\n   \"ISREDIT MACRO\"\n   IF RC = 20 THEN DO\n       ZEDSMSG = \"NOT A TSO COMMAND\"\n      \"SETMSG MSG(ISRZ000)\";EXIT\n   END\n   ADDRESS ISREDIT \"(LREC) = LRECL\"\n   ADDRESS ISREDIT \"(BLKS) = BLKSIZE\"\n   ADDRESS ISREDIT \"(NUM)  = LINENUM .ZLAST\"\n   LREC=LREC+0;BLKS=BLKS+0;NUM=NUM+0\n   ZEDSMSG = LREC\"/\"BLKS\"/\"NUM\n   \"SETMSG MSG(ISRZ000)\"\n   EXIT(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DETAB": {"ttr": 20488, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x02\\x08\\x02\\x08\\x00\\x00\\xc4\\xc5\\xe3\\xc1\\xc2@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 520, "newlines": 520, "modlines": 0, "user": "DETAB"}, "text": "//-YOUR-USERID-D JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//C          EXEC     PGM=IEL0AA,REGION=4M,\n//             PARM=('AG,A,NCT,ESD,F(I),NOFLOW,NIS,NOLIST,M,NMI,NEST',\n//             'MAP,OF,OPT(TIME),OP,SZ(MAX),S,STMT,STG,X(F)')\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-PLI-LIB-\n\n BASE:  PROC(PARM) OPTIONS(MAIN) REORDER;\n\n   /**  EXPAND A FILE INTO ITS MAX FIELD SIZE REMOVING SEPARATOR    **/\n   /**  CHARACTERS, POSSIBLY REMOVING HEADERS & TRAILERS, PROVIDING **/\n   /**  A MASTER FORMAT TO BE USED, ELIMINATING DECIMAL POINTS BUT  **/\n   /**  ALIGNING THE DATA, AND ROLLING ACTUAL SIGNS INTO THE DATA   **/\n\n    DCL  PARM           CHAR(00006) VARYING;\n    DCL  SEP_CHAR       CHAR(00001) STATIC;\n    DCL  REMOVE_HDR     CHAR(00001) STATIC;\n    DCL  REMOVE_TLR     CHAR(00001) STATIC;\n    DCL  IS_MASTER      CHAR(00001) STATIC;\n    DCL  DEL_DEC_PT     CHAR(00001) STATIC;\n    DCL  ROLL_SIGN      CHAR(00001) STATIC;\n    DCL  HEXDIG1        CHAR(00001) STATIC;\n    DCL  HEXDIG2        CHAR(00001) STATIC;\n    DCL  REC            CHAR(32760) STATIC VARYING;\n    DCL  PRE_REC        CHAR(32760) STATIC VARYING;\n    DCL  NEW_REC        CHAR(32760) STATIC VARYING;\n    DCL  NEW_FIELD      CHAR(32760) STATIC VARYING;\n    DCL  S              CHAR(00001) STATIC;\n    DCL  NAME           CHAR(00030) STATIC;\n    DCL  COB_CARD       CHAR(00080) STATIC;\n    DCL  EZ_CARD        CHAR(00080) STATIC;\n    DCL  1  MASTER_REC,\n        10  MASTER_CBL_NAME    CHAR(00030),\n        10  MASTER_FILLER_10   CHAR(00002) INIT(' '),\n        10  MASTER_FIELD_LEN   PIC '99999',\n        10  MASTER_FILLER_20   CHAR(00002) INIT(' '),\n        10  MASTER_TYPE        CHAR(00001),\n        10  MASTER_FILLER_30   CHAR(00002) INIT(' '),\n        10  MASTER_DEC_PLACES  PIC '99',\n        10  MASTER_FILLER_90   CHAR(00036) INIT(' ');\n    DCL  PADDING        CHAR(32760) STATIC VARYING;\n    DCL  RIGHT_PADDING  CHAR(32760) STATIC VARYING;\n    DCL  1  ARRAY(01000) STATIC,\n        10  FIELD_LEN   FIXED BIN(31) INIT((01000)(-1)),\n        10  NUMERIC     CHAR          INIT((01000)('Y')),\n        10  DEC_PLACES  FIXED BIN(31) INIT((01000)(0)),\n        10  CBL_NAME    CHAR(00030)   INIT((01000)(' ')),\n        10  GOT_SIGN    CHAR(00001)   INIT((01000)('N'));\n    DCL  REC_LEN        FIXED BIN(31) STATIC INIT(0);\n    DCL  FINAL_RC       FIXED BIN(31) STATIC INIT(0);\n    DCL  (II,JJ,KK)     FIXED BIN(31) STATIC INIT(0);\n    DCL  (HH,TT)        FIXED BIN(31) STATIC INIT(0);\n    DCL  (LL,MM,NN)     FIXED BIN(31) STATIC INIT(0);\n    DCL  (PP,RR,SS)     FIXED BIN(31) STATIC INIT(0);\n    DCL  FL_PIC         PIC 'ZZZZ9' STATIC;\n    DCL  FFL_PIC        PIC '99999' STATIC;\n    DCL  LL_PIC         PIC 'ZZZZ9' STATIC;\n    DCL  LLL_PIC        PIC '99999' STATIC;\n    DCL  FF#_PIC        PIC '99999' STATIC;\n    DCL  DPL_PIC        PIC '99' STATIC;\n    DCL  HDR_DATE       CHAR(10) STATIC INIT('CCYY/MM/DD');\n    DCL  TLR_DATE       CHAR(10) STATIC INIT('CCYY/MM/DD');\n    DCL  TLR_TOT_CNT    PIC 'ZZ,ZZZ,ZZ9' STATIC;\n    DCL  TLR_DATA_CNT   PIC 'ZZ,ZZZ,ZZ9' STATIC;\n    DCL  ZEROLEN#       FIXED BIN(31) STATIC INIT(0);\n    DCL  READ#          FIXED BIN(31) STATIC INIT(0);\n    DCL  WRITTEN#       FIXED BIN(31) STATIC INIT(0);\n    DCL  I_EOF_IND      CHAR(01) STATIC INIT('N');\n    DCL  MASTER_EOF_IND CHAR(01) STATIC INIT('N');\n    DCL  I              FILE INPUT  RECORD SEQL;\n    DCL  MASTER         FILE INPUT  RECORD SEQL;\n    DCL  O              FILE OUTPUT RECORD SEQL;\n    DCL  OCOB           FILE OUTPUT RECORD SEQL;\n    DCL  OEZ            FILE OUTPUT RECORD SEQL;\n    DCL  LAYOUT         FILE OUTPUT RECORD SEQL;\n    DCL  ( DATE, INDEX, LENGTH, PLIRETC, REPEAT, SUBSTR,\n           TIME, TRANSLATE, VERIFY)\n                        BUILTIN;\n    DCL  SIGN           CHAR(001) STATIC;\n    DCL  SIGN_LOC       CHAR(005) STATIC;\n    DCL  SIGN_TRANS     CHAR(010) STATIC;\n    DCL  HIGH_HEX       CHAR(256) STATIC\n         INIT(('000000000000000011111111111111112222222222222222'\n           ||  '333333333333333344444444444444445555555555555555'\n           ||  '666666666666666677777777777777778888888888888888'\n           ||  '9999999999999999AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBB'\n           ||  'CCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEE'\n           ||  'FFFFFFFFFFFFFFFF'));\n    DCL  LOW_HEX        CHAR(256) STATIC\n         INIT(('0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF'\n           ||  '0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF'\n           ||  '0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF'\n           ||  '0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF'\n           ||  '0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF'\n           ||  '0123456789ABCDEF'));\n\n /** PICK UP PARM OPTIONS **/\n    SEP_CHAR   = SUBSTR(PARM,1,1);\n    REMOVE_HDR = SUBSTR(PARM,2,1);\n    REMOVE_TLR = SUBSTR(PARM,3,1);\n    IS_MASTER  = SUBSTR(PARM,4,1);\n    DEL_DEC_PT = SUBSTR(PARM,5,1);\n    ROLL_SIGN  = SUBSTR(PARM,6,1);\n\n /** IF MASTER OPTION CHOSEN, PUT THAT FORMAT INTO ARRAY **/\n    OPEN FILE(I), FILE(O), FILE(OCOB), FILE(OEZ), FILE(LAYOUT);\n    IF IS_MASTER = 'Y'\n       THEN CALL GET_MASTER_FORMAT;\n\n /** FIRST READ OF DATA TO ANALYZE FIELDS **/\n    ON ENDFILE(I) I_EOF_IND = 'Y';\n    IF REMOVE_HDR = 'Y'\n       THEN DO;\n          READ FILE(I) INTO(REC);\n          READ# = 1;\n       END;\n       ELSE READ# = 0;\n\n    READ FILE(I) INTO(REC);\n    READ# = READ# + 1;\n    READ FILE(I) INTO(PRE_REC);\n    DO WHILE ( I_EOF_IND  = 'N' );\n       CALL ANAL_FIELD_LENGTHS;\n       REC = PRE_REC;\n       READ# = READ# + 1;\n       READ FILE(I) INTO(PRE_REC);\n       IF I_EOF_IND  = 'Y'\n          THEN DO;\n             IF REMOVE_TLR = 'N'\n                THEN CALL ANAL_FIELD_LENGTHS;\n          END;\n    END;\n    CLOSE FILE(I);\n\n /** CREATE COBOL AND EASYTRIEVE STRUCTURES PLUS GENERATE LAYOUT **/\n    LL = 1;\n    DO JJ = 1 TO 01000 WHILE ( FIELD_LEN(JJ) \u00ac= -1 );\n       REC_LEN = REC_LEN + FIELD_LEN(JJ);\n       CALL WRITE_COB_EZ_STRUCTURES;\n    END;\n\n /** SECOND READ OF DATA TO GENERATE EXPANDED FILE **/\n    I_EOF_IND = 'N';\n    OPEN FILE(I);\n    ON ENDFILE(I) I_EOF_IND = 'Y';\n    IF REMOVE_HDR = 'Y'\n       THEN DO;\n          READ FILE(I) INTO(REC);\n          NN = 1;\n       END;\n       ELSE NN = 0;\n\n    READ FILE(I) INTO(REC);\n    NN = NN + 1;\n    READ FILE(I) INTO(PRE_REC);\n    DO WHILE ( I_EOF_IND  = 'N' );\n       CALL NORM_FIELD_LENGTHS;\n       REC = PRE_REC;\n       NN = NN + 1;\n       READ FILE(I) INTO(PRE_REC);\n       IF I_EOF_IND  = 'Y'\n          THEN DO;\n             IF REMOVE_TLR = 'N'\n                THEN CALL NORM_FIELD_LENGTHS;\n          END;\n    END;\n\n    CLOSE FILE(I), FILE(O), FILE(OCOB), FILE(OEZ), FILE(LAYOUT);\n\n    CALL TERMINATION;\n    CALL PLIRETC(FINAL_RC);\n\n\n ANAL_FIELD_LENGTHS:  PROC;\n    II = 1;\n    JJ = 1;\n    DO WHILE ( II <= LENGTH(REC) );\n       DO KK = II TO LENGTH(REC) BY 1\n          WHILE ( SUBSTR(REC,KK,1) \u00ac= SEP_CHAR );\n       END;\n       IF VERIFY(SUBSTR(REC,II,KK-II),'+-.0123456789') \u00ac= 0\n          THEN DO;\n             IF IS_MASTER = 'Y' & NUMERIC(JJ) = 'Y'\n                THEN DO;\n                   PUT FILE(SYSOUT) EDIT ( '*E*  REC # ', READ#,\n                                     ' FIELD ', JJ,\n                                     ' >', SUBSTR(REC,II,KK-II), '<',\n                                     ' SHOULD BE NUMERIC' )\n                                   ( SKIP(1), A, P'ZZ,ZZZ,ZZ9',\n                                     A, P'Z,ZZ9', A, A, A, A );\n                   IF FINAL_RC < 08 THEN FINAL_RC = 08;\n                END;\n             NUMERIC(JJ)    = 'N';\n             DEC_PLACES(JJ) = 0;\n          END;\n          ELSE DO;\n             IF NUMERIC(JJ) = 'Y'\n                THEN DO;\n                   IF INDEX(SUBSTR(REC,II,KK-II),'+') \u00ac= 0\n                         | INDEX(SUBSTR(REC,II,KK-II),'-') \u00ac= 0\n                      THEN GOT_SIGN(JJ) = 'Y';\n                   PP = INDEX(SUBSTR(REC,II,KK-II),'.');\n                   IF PP \u00ac= 0  &  DEC_PLACES(JJ) < (KK-II-PP)\n                      THEN DEC_PLACES(JJ) = (KK-II-PP);\n                END;\n          END;\n       IF FIELD_LEN(JJ) < ( KK - II )\n          THEN DO;\n             IF IS_MASTER = 'Y'\n                THEN DO;\n                   PUT FILE(SYSOUT) EDIT ( '*S*  REC # ', READ#,\n                                     ' FIELD ', JJ,\n                                     ' >', SUBSTR(REC,II,KK-II), '<',\n                                     ' SHOULD BE ONLY ',\n                                     FIELD_LEN(JJ), ' BYTES' )\n                                   ( SKIP(1), A, P'Z,ZZ9',\n                                     A, P'Z,ZZ9', A, A, A, A,\n                                     P'ZZ,ZZ9', A );\n                   IF FINAL_RC < 12 THEN FINAL_RC = 12;\n                END;\n             FIELD_LEN(JJ) = KK - II;\n          END;\n       II = KK + 1;\n       JJ = JJ + 1;\n    END;\n END ANAL_FIELD_LENGTHS;\n\n\n GET_MASTER_FORMAT:  PROC;\n    OPEN FILE(MASTER);\n    ON ENDFILE(MASTER) MASTER_EOF_IND = 'Y';\n    READ FILE(MASTER) INTO(MASTER_REC);\n    II = 0;\n    DO WHILE ( MASTER_EOF_IND  = 'N' );\n       IF SUBSTR(MASTER_CBL_NAME,1,1) \u00ac= '*'\n          THEN DO;\n             II = II + 1;\n             FIELD_LEN(II)     = MASTER_FIELD_LEN;\n             IF MASTER_TYPE = 'N'\n                THEN NUMERIC(II) = 'Y';\n                ELSE NUMERIC(II) = 'N';\n             DEC_PLACES(II)    = MASTER_DEC_PLACES;\n             CBL_NAME(II)      = MASTER_CBL_NAME;\n          END;\n       READ FILE(MASTER) INTO(MASTER_REC);\n    END;\n    CLOSE FILE(MASTER);\n END GET_MASTER_FORMAT;\n\n\n NORM_FIELD_LENGTHS:  PROC;\n    II = 1;\n    JJ = 1;\n    NEW_REC = '';\n    DO WHILE ( II <= LENGTH(REC) );\n       DO KK = II TO LENGTH(REC) BY 1\n          WHILE ( SUBSTR(REC,KK,1) \u00ac= SEP_CHAR );\n       END;\n       IF NUMERIC(JJ) = 'N' | FIELD_LEN(JJ) = 0\n          THEN DO;\n             IF FIELD_LEN(JJ) = (KK-II)\n                THEN PADDING = '';\n                ELSE PADDING\n                   = REPEAT(' ',(FIELD_LEN(JJ) - KK + II - 1 ));\n             NEW_REC = NEW_REC || SUBSTR(REC,II,KK-II) || PADDING;\n          END;\n          ELSE DO;\n             IF GOT_SIGN(JJ) = 'Y'\n                THEN DO;\n                   SIGN = '+';\n                   SS = INDEX(SUBSTR(REC,II,KK-II),'+');\n                   IF SS \u00ac= 0\n                      THEN SIGN = '+';\n                      ELSE DO;\n                         SS = INDEX(SUBSTR(REC,II,KK-II),'-');\n                         IF SS \u00ac= 0 THEN SIGN = '-';\n                      END;\n                END;\n             RIGHT_PADDING = '';\n             IF DEC_PLACES(JJ) \u00ac= 0\n                THEN DO;\n                   PP = INDEX(SUBSTR(REC,II,KK-II),'.');\n                   RR = (KK-II-PP);\n                   IF DEC_PLACES(JJ) = RR\n                      THEN RIGHT_PADDING = '';\n                      ELSE RIGHT_PADDING\n                         = REPEAT('0',DEC_PLACES(JJ)-RR-1);\n                END;\n             IF FIELD_LEN(JJ) = (KK-II+LENGTH(RIGHT_PADDING))\n                THEN PADDING = '';\n                ELSE DO;\n                   IF (KK-II) \u00ac= 0\n                      THEN PADDING = REPEAT('0',\n                         (FIELD_LEN(JJ)\n                            - KK + II - LENGTH(RIGHT_PADDING) - 1 ));\n                END;\n             IF ROLL_SIGN = 'Y' & (KK-II) \u00ac= 0\n                   & INDEX(SUBSTR(REC,II,KK-II),SIGN) \u00ac= 0\n                THEN PADDING = '0' || PADDING;\n             IF DEL_DEC_PT = 'Y' & (KK-II) \u00ac= 0\n                   & INDEX(SUBSTR(REC,II,KK-II),'.') \u00ac= 0\n                THEN PADDING = '0' || PADDING;\n             IF (KK-II) = 0\n                THEN DO;\n                   IF FIELD_LEN(JJ) \u00ac= 0\n                      THEN DO;\n                         IF DEL_DEC_PT = 'Y'\n                            THEN DO;\n                               IF DEC_PLACES(JJ) \u00ac= 0\n                                  THEN NEW_FIELD = REPEAT('0',\n                                        FIELD_LEN(JJ)-DEC_PLACES(JJ)-1)\n                                     || '.'\n                                     || REPEAT('0',DEC_PLACES(JJ)-1);\n                                  ELSE NEW_FIELD = REPEAT('0',\n                                     FIELD_LEN(JJ)-1);\n                            END;\n                            ELSE DO;\n                               IF DEC_PLACES(JJ) \u00ac= 0\n                                  THEN NEW_FIELD = REPEAT('0',\n                                        FIELD_LEN(JJ)-DEC_PLACES(JJ)-2)\n                                     || '.'\n                                     || REPEAT('0',DEC_PLACES(JJ)-1);\n                                  ELSE NEW_FIELD = REPEAT('0',\n                                     FIELD_LEN(JJ)-1);\n                            END;\n                      END;\n                      ELSE\n                         NEW_FIELD = PADDING || SUBSTR(REC,II,KK-II)\n                            || RIGHT_PADDING;\n                END;\n                ELSE NEW_FIELD = PADDING || SUBSTR(REC,II,KK-II)\n                   || RIGHT_PADDING;\n             IF GOT_SIGN(JJ) = 'Y'\n                THEN DO;\n                   IF ROLL_SIGN = 'Y'\n                      THEN DO;\n                         IF INDEX(NEW_FIELD,SIGN) \u00ac= 0\n                            THEN DO;\n                               NEW_FIELD\n                                  = SUBSTR(NEW_FIELD,1,\n                                        INDEX(NEW_FIELD,SIGN)-1)\n                                     || SUBSTR(NEW_FIELD,\n                                        INDEX(NEW_FIELD,SIGN)+1);\n                            END;\n                         IF SIGN = '+'\n                            THEN SIGN_TRANS = '{ABCDEFGHI';\n                            ELSE SIGN_TRANS = '}JKLMNOPQR';\n                         SUBSTR(NEW_FIELD,\n                            LENGTH(NEW_FIELD),1)\n                               = TRANSLATE(SUBSTR(NEW_FIELD,\n                                  LENGTH(NEW_FIELD),1),\n                                  SIGN_TRANS,'0123456789');\n                      END;\n                      ELSE DO;\n                         IF INDEX(NEW_FIELD,SIGN) \u00ac= 0\n                            THEN NEW_FIELD\n                               = SIGN || SUBSTR(NEW_FIELD,1,\n                                        INDEX(NEW_FIELD,SIGN)-1)\n                                  || SUBSTR(NEW_FIELD,\n                                        INDEX(NEW_FIELD,SIGN)+1);\n                            ELSE NEW_FIELD\n                               = SIGN || SUBSTR(NEW_FIELD,2);\n                      END;\n                END;\n             IF DEL_DEC_PT = 'Y'\n                   & INDEX(NEW_FIELD,'.') \u00ac= 0\n                THEN\n                   NEW_FIELD\n                      = SUBSTR(NEW_FIELD,1,INDEX(NEW_FIELD,'.')-1)\n                         || SUBSTR(NEW_FIELD,\n                            INDEX(NEW_FIELD,'.')+1);\n             NEW_REC = NEW_REC || NEW_FIELD;\n             IF LENGTH(NEW_FIELD) \u00ac= FIELD_LEN(JJ)\n                THEN DO;\n                   PUT FILE(SYSOUT) EDIT ( '*E*  REC # ', NN,\n                                     ' FIELD ', JJ,\n                                     ' IS ', LENGTH(NEW_FIELD),\n                                     ' BYTES AND NOT ', FIELD_LEN(JJ) )\n                                   ( SKIP(1), A, P'ZZ,ZZZ,ZZ9',\n                                     A, P'Z,ZZ9', A,\n                                     P'ZZ,ZZ9', A , P'ZZ,ZZ9' );\n                   IF FINAL_RC < 12 THEN FINAL_RC = 12;\n                END;\n          END;\n       II = KK + 1;\n       JJ = JJ + 1;\n    END;\n    WRITE FILE(O) FROM(NEW_REC);\n    WRITTEN# = WRITTEN# + 1;\n    IF LENGTH(NEW_REC) \u00ac= REC_LEN\n       THEN DO;\n          PUT FILE(SYSOUT) EDIT ( '*E*  REC # ', NN,\n                            ' IS NOT CORRECT LENGTH, ',\n                            LENGTH(NEW_REC),\n                            ' RATHER THEN ', REC_LEN, ' BYTES' )\n                          ( SKIP(1), A, P'ZZ,ZZZ,ZZ9',\n                            A, P'ZZ,ZZ9', A,\n                            P'ZZ,ZZ9', A );\n          IF FINAL_RC < 12 THEN FINAL_RC = 12;\n       END;\n END NORM_FIELD_LENGTHS;\n\n\n WRITE_COB_EZ_STRUCTURES:  PROC;\n    IF FIELD_LEN(JJ) = 0 THEN ZEROLEN# = ZEROLEN# + 1;\n    ELSE DO;\n       LL_PIC   = LL;\n       LLL_PIC  = LL;\n       DPL_PIC  = DEC_PLACES(JJ);\n       FL_PIC   = FIELD_LEN(JJ);\n       FFL_PIC  = FIELD_LEN(JJ);\n       IF IS_MASTER = 'Y'\n          THEN NAME = CBL_NAME(JJ);\n          ELSE NAME = 'POS-' || LLL_PIC;\n       IF NUMERIC(JJ) = 'Y'\n          THEN DO;\n             IF GOT_SIGN(JJ) = 'Y'\n                THEN S = 'S';\n                ELSE S = ' ';\n             EZ_CARD = '     ' || NAME    || '   '       || LL_PIC\n                || '   '       || FL_PIC  || '   N  '    || DPL_PIC;\n             IF DPL_PIC = 0\n                THEN COB_CARD = '           10  ' || NAME\n                      || '   PIC ' || S || '9('\n                      || FFL_PIC   || ').';\n                ELSE COB_CARD = '           10  ' || NAME\n                      || '   PIC ' || S || '9('\n                      || FFL_PIC   || ')V9(' || DPL_PIC ||  ').';\n          END;\n          ELSE DO;\n             EZ_CARD = '     ' || NAME || '   ' || LL_PIC\n                || '   ' || FL_PIC || '   ' || 'A';\n             COB_CARD = '           10  ' || NAME\n                || '   PIC  X(' || FFL_PIC || ').';\n          END;\n       WRITE FILE(OEZ)  FROM(EZ_CARD);\n       WRITE FILE(OCOB) FROM(COB_CARD);\n    END;\n    FF#_PIC = JJ;\n    IF IS_MASTER = 'Y'\n       THEN MASTER_CBL_NAME   = CBL_NAME(JJ);\n       ELSE MASTER_CBL_NAME   = 'FIELD' || FF#_PIC;\n    MASTER_FIELD_LEN          = FIELD_LEN(JJ);\n    IF NUMERIC(JJ) = 'Y'\n       THEN MASTER_TYPE       = 'N';\n       ELSE MASTER_TYPE       = 'A';\n    IF FIELD_LEN(JJ) = 0 & IS_MASTER = 'N'\n       THEN MASTER_TYPE       = 'A';\n    MASTER_DEC_PLACES         = DEC_PLACES(JJ);\n    WRITE FILE(LAYOUT) FROM(MASTER_REC);\n    LL = LL + FIELD_LEN(JJ);\n END WRITE_COB_EZ_STRUCTURES;\n\n\n TERMINATION: PROC;\n    PUT EDIT ( '**************************************' )\n             ( SKIP(1), A );\n    PUT EDIT ( '***  ', DATE, ' DETAB STATS ', TIME, '  ***' )\n             ( SKIP(1), A, A, A, A, A );\n    PUT EDIT ( '**************************************' )\n             ( SKIP(1), A );\n    IF HDR_DATE \u00ac= 'CCYY/MM/DD'\n       THEN PUT EDIT ( '***  HEADER DATE VALUE:       ', HDR_DATE )\n                     ( SKIP(2), A, A );\n    IF TLR_DATE \u00ac= 'CCYY/MM/DD'\n       THEN PUT EDIT ( '***  TRAILER DATE VALUE:      ', TLR_DATE )\n                     ( SKIP(2), A, A );\n    PUT EDIT ( '***  NUMBER RECORDS READ:    ', READ#    )\n             ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n    IF TLR_DATE \u00ac= 'CCYY/MM/DD'\n       THEN PUT EDIT ( '***  TRAILER TOTAL NUMBER:  ', TLR_TOT_CNT )\n                     ( SKIP(2), A, A );\n    PUT EDIT ( '***  NUMBER RECORDS WRITTEN: ', WRITTEN# )\n             ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n    IF TLR_DATE \u00ac= 'CCYY/MM/DD'\n       THEN PUT EDIT ( '***  TRAILER DATA COUNT:    ', TLR_DATA_CNT )\n                     ( SKIP(2), A, A );\n    PUT EDIT ( '***  NUMBER ZERO LEN FIELDS: ', ZEROLEN# )\n             ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n    DO KK = 1 TO 01000 WHILE ( FIELD_LEN(KK) \u00ac= -1 );\n       IF FIELD_LEN(KK) = 0 THEN DO;\n       PUT EDIT ( '  *  FIELD ', KK, ' IS ALWAYS ZERO LENGTH')\n               ( SKIP(2), A, P'ZZ,ZZ9', A );\n       END;\n    END;\n\n    HEXDIG1 = TRANSLATE(SEP_CHAR,HIGH_HEX);\n    HEXDIG2 = TRANSLATE(SEP_CHAR,LOW_HEX);\n    PUT EDIT ( '***  SEP_CHAR VALUE RECEIVED:     ',\n               'X''', HEXDIG1, HEXDIG2, ''' (', SEP_CHAR, ')')\n             ( SKIP(2), A, A, A, A, A, A, A );\n\n    PUT EDIT ( '***  OUTPUT RECORD SIZE:        ', REC_LEN )\n             ( SKIP(2), A, P'ZZ,ZZ9' );\n END TERMINATION;\n\n\n END BASE;\n\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(CYL,(05,02))\n//***\n//L          EXEC     PGM=HEWLKED,COND=(5,LT),\n//             PARM='XREF,LIST,LET,DCBS,AMODE=31,RMODE=ANY',\n//             REGION=4M\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE)\n//             DD       *\n  SETSSI   03021200\n  ENTRY    PLISTART\n  NAME     DETAB(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DETAB$": {"ttr": 20740, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00.\\x00.\\x00\\x00\\xc4\\xc5\\xe3\\xc1\\xc2@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "DETAB"}, "text": "//-YOUR-USERID-D JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=X,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n/*JOBPARM    LINES=999\n//***\n//***  EXPAND A FILE INTO ITS MAX FIELD SIZE REMOVING SEPARATOR\n//***  CHARACTERS, POSSIBLY REMOVING HEADERS & TRAILERS, PROVIDING\n//***  A MASTER FORMAT TO BE USED, ELIMINATING DECIMAL POINTS BUT\n//***  ALIGNING THE DATA, AND ROLLING ACTUAL SIGNS INTO THE DATA\n//***\n//CLEANUP    EXEC     PGM=IEFBR14\n//DEL001       DD       DSN=-YOUR-USERID-.$$$TEMP.DETAB,\n//             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n//DEL002       DD       DSN=-YOUR-USERID-.$$$TEMP.DETAB.COBOUT,\n//             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n//DEL003       DD       DSN=-YOUR-USERID-.$$$TEMP.DETAB.EZOUT,\n//             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n//***\n//DETAB      EXEC     PGM=DETAB,PARM='%NNNNN',REGION=24M\n//*                                   ||||||\n//*  SEPARATOR CHARACTER  ------------+|||||\n//*  REMOVE HEADER   ------------------+||||\n//*  REMOVE TRAILER   ------------------+|||\n//*  MASTER FORMAT AVAILABLE  -----------+||\n//*  REMOVE NUMERIC DECIMAL POINTS  ------+|\n//*  PUT SIGN ON LAST DIGIT  --------------+\n//*\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//I            DD       DISP=SHR,DCB=BUFNO=64,\n//             DSN=...                                     <***\n//MASTER       DD       *\n//O            DD       DISP=(,CATLG),\n//             DSN=-YOUR-USERID-.$$$TEMP.DETAB,\n//             UNIT=SYSDA,SPACE=(CYL,(0010,0010),RLSE),\n//             DCB=(RECFM=VB,LRECL=27994,BLKSIZE=27998,BUFNO=64)\n//OCOB         DD       DISP=(,CATLG),\n//             DSN=-YOUR-USERID-.$$$TEMP.DETAB.COBOUT,\n//             UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),\n//             DCB=(RECFM=FB,LRECL=80)\n//OEZ          DD       DISP=(,CATLG),\n//             DSN=-YOUR-USERID-.$$$TEMP.DETAB.EZOUT,\n//             UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),\n//             DCB=(RECFM=FB,LRECL=80)\n//LAYOUT       DD       SYSOUT=*,DCB=(RECFM=FB,BLKSIZE=80)\n//SYSOUT       DD       SYSOUT=*,DCB=BLKSIZE=121\n//SYSPRINT     DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DIRLIST": {"ttr": 20742, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00_\\x00_\\x00\\x00\\xc4\\xc9\\xd9\\xd3\\xc9\\xe2\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 95, "newlines": 95, "modlines": 0, "user": "DIRLIST"}, "text": "//-YOUR-USERID-D JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//*** HEX LIST OF A DIRECTORY SEPARATING EACH MEMBER\n//***\n//C          EXEC     PGM=IEL0AA,REGION=4M,\n//             PARM=('AG,A,NCT,ESD,F(I),NOFLOW,NIS,NOLIST,M,NMI,NEST',\n//             'MAP,OF,OPT(TIME),OP,SZ(MAX),S,STMT,STG,X(F)')\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-PLI-LIB-\n\n DIRLIST:\n      PROC OPTIONS(MAIN) REORDER;\n\n      DCL  SELMEM       FILE INPUT STREAM\n                        ENV(FB, RECSIZE(080), TOTAL);\n      DCL  I            FILE INPUT RECORD SEQL\n                        ENV(F, RECSIZE(256), BLKSIZE(256), TOTAL);\n      DCL  O            FILE OUTPUT RECORD SEQL\n                        ENV(VB, RECSIZE(076), TOTAL);\n\n      DCL  1  DIR_BLK           BASED(DIR_BLK_PTR),\n              2  LL             FIXED BIN(15,0),\n              2  DATA           CHAR(254);\n      DCL  1  MEM_OVLY          BASED(MEM_OVLY_PTR),\n              2  MEMBER         CHAR(8),\n              2  TTR            CHAR(3),\n              2  C,\n                 3  ALIAS       BIT(1),\n                 3  TTR_CNT     BIT(2),\n                 3  DATA_CNT    BIT(5),\n              2  ORG_HWDS(39)   CHAR(2);\n      DCL  DIR_DATA             CHAR(072) STATIC VARYING;\n      DCL  DIR_DATA_OVLY        CHAR(100) BASED(MEM_OVLY_PTR);\n\n      DCL  FIRST                FIXED BIN(31) STATIC INIT(00000001);\n      DCL  LAST                 FIXED BIN(31) STATIC INIT(99999999);\n      DCL  FIRSTMEM             CHAR(8) STATIC INIT(' ');\n      DCL  LASTMEM              CHAR(8) STATIC INIT('99999999');\n\n      DCL  ( MEM_OVLY_PTR, DIR_BLK_PTR )\n                                PTR STATIC;\n      DCL  ( MEMBER, MASK_CTR, LEN, ICTR, JCTR, I_ORG_CNT )\n                                FIXED BIN(31) STATIC INIT(0);\n      DCL  ( HBOUND, SUBSTR, HIGH, LENGTH, ADDR, INDEX )\n                                BUILTIN;\n\n      OPEN FILE(SELMEM), FILE(I), FILE(O);\n      GET DATA FILE(SELMEM);\n      ON ENDFILE(I) GOTO I_EOF;\n\n I_READ_LOOP:\n      READ FILE(I) SET(DIR_BLK_PTR);\n      LEN = 2;\n      MEM_OVLY_PTR = ADDR(DIR_BLK.DATA);\n I_MEM_ROUTINE:\n      IF MEM_OVLY.MEMBER = HIGH(8)\n         THEN GOTO I_EOF;\n      MEMBER = MEMBER + 1;\n      IF MEMBER < FIRST | MEM_OVLY.MEMBER < FIRSTMEM\n         THEN GOTO I_NEXT_MEM;\n      IF MEMBER > LAST | MEM_OVLY.MEMBER > LASTMEM\n         THEN GOTO I_EOF;\n      DIR_DATA\n         = SUBSTR(DIR_DATA_OVLY, 1, 12 + ( MEM_OVLY.C.DATA_CNT * 2 ));\n      WRITE FILE(O) FROM(DIR_DATA);\n I_NEXT_MEM:\n      I_ORG_CNT = MEM_OVLY.C.DATA_CNT + 1;\n      MEM_OVLY_PTR = ADDR(MEM_OVLY.ORG_HWDS(I_ORG_CNT));\n      LEN = LEN + (2 * I_ORG_CNT) + 10;\n      IF DIR_BLK.LL > LEN\n            THEN GOTO I_MEM_ROUTINE;\n            ELSE GOTO I_READ_LOOP;\n\n I_EOF:\n      CLOSE FILE(SELMEM), FILE(I), FILE(O);\n      END DIRLIST;\n\n//SYSUT1       DD       UNIT=VIO,SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(CYL,(5,3))\n//***\n//L          EXEC     PGM=HEWLKED,COND=(5,LT),\n//             PARM='XREF,LIST,LET,AMODE(31),RMODE(ANY)',\n//             REGION=4M\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//SYSUT1       DD       UNIT=VIO,SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   99042100\n  ENTRY    PLISTART\n  NAME     DIRLIST(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DIRLIST$": {"ttr": 20745, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x14\\x00\\x14\\x00\\x00\\xc4\\xc9\\xd9\\xd3\\xe2\\xc9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "DIRLSIT"}, "text": "//-YOUR-USERID-D JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  HEX LIST OF A DIRECTORY SEPARATING EACH MEMBER\n//***\n//DIRLIST    EXEC     PGM=DIRLIST,REGION=4M\n//I            DD       DISP=SHR,DSN=...                          <***\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SELMEM       DD       *,DCB=BLKSIZE=00080\nFIRST=000001, LAST=999999,FIRSTMEM='        ',LASTMEM='99999999';\n//O            DD       DSN=&&DIRLIST,DISP=(,PASS),\n//             UNIT=SYSDA,SPACE=(CYL,(20,20),RLSE),\n//             DCB=(RECFM=VB,LRECL=00076,BLKSIZE=0)\n//***\n//HEXDUMP    EXEC     PGM=HEXDUMP,REGION=4M\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSUT1       DD       DISP=(OLD,DELETE,DELETE),DSN=&&DIRLIST\n//SYSUT2       DD       SYSOUT=*,DCB=(RECFM=F,LRECL=72,BLKSIZE=72)\n//SYSPRINT     DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DIRSCNC": {"ttr": 20747, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xfc\\x00\\xfc\\x00\\x00\\xc4\\xc9\\xd9\\xe2\\xc3\\xd5\\xc3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 252, "newlines": 252, "modlines": 0, "user": "DIRSCNC"}, "text": "//-YOUR-USERID-D JOB  (-YOUR-ACCT-INFO-),'-YOUR-USERID-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  READ A PDS DIRECTORY AND GENERATE CARD IMAGES WITH MEMBER\n//***  NAME IN PLACE OF ???????? AND ######## (VARIABLE VS FIXED)\n//***\n//C          EXEC     PGM=IGYCRCTL,REGION=4M,\n//             PARM=('ARITH(EXTEND),LIB,MAP,NUMPROC(PFD),OFF,OPTIMIZE',\n//            'AWO,INTDATE(LILIAN),APOST,NOSEQ,TRUNC(OPT),XREF')\n//SYSIN        DD       *\n\n      **************************\n       IDENTIFICATION DIVISION.\n      **************************\n       PROGRAM-ID.  DIRSCNC.\n\n      ***********************\n       ENVIRONMENT DIVISION.\n      ***********************\n\n       INPUT-OUTPUT SECTION.\n      *---------------------*\n\n       FILE-CONTROL.\n\n           SELECT I ASSIGN TO I.\n\n           SELECT SYSIN ASSIGN TO SYSIN.\n\n           SELECT SELMEM ASSIGN TO SELMEM.\n\n           SELECT O ASSIGN TO O.\n\n      ****************\n       DATA DIVISION.\n      ****************\n\n       FILE SECTION.\n      *-------------*\n\n       FD  I\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  I-REC        PIC X(00256).\n\n       FD  SYSIN\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  SYSIN-REC    PIC X(00080).\n\n       FD  SELMEM\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  SELMEM-REC   PIC X(00080).\n\n       FD  O\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  O-REC        PIC X(00080).\n\n       WORKING-STORAGE SECTION.\n      *------------------------*\n\n       01  WS-MISC-DATA.\n           05  END-OF-FILE-STATUS     PIC X      VALUE 'N'.\n               88  AT-END-OF-FILE                VALUE 'Y'.\n               88  NOT-AT-END-OF-FILE            VALUE 'N'.\n           05  II                     PIC 9(00004) COMP.\n           05  JJ                     PIC 9(00004) COMP.\n           05  KK                     PIC 9(00004) COMP.\n           05  LL                     PIC 9(00004) COMP.\n           05  WS-BIT                 PIC 9(00009).\n           05  WS-BLANKS              PIC X(00008) VALUE SPACES.\n           05  WS-FIRST               PIC 9(00006) COMP VALUE 1.\n           05  WS-FIRST-MEM           PIC X(00008) VALUE SPACES.\n           05  WS-FW-CNT              PIC 9(00009) COMP VALUE 0.\n           05  WS-FW-CNT-OVLY         REDEFINES WS-FW-CNT.\n               10                     PIC 9(00004) COMP.\n               10  WS-HW-CNT          PIC 9(00004) COMP.\n               10  WS-HW-CNT-OVLY     REDEFINES WS-HW-CNT.\n                   15                 PIC X(00001).\n                   15  WS-HW-BYTE     PIC X(00001).\n           05  WS-IMAGE               PIC X(00080).\n           05  WS-LAST                PIC 9(00006) COMP VALUE 999999.\n           05  WS-LAST-MEM            PIC X(00008) VALUE ALL '9'.\n           05  WS-MEM-CNT             PIC 9(00004) COMP VALUE 0.\n           05  WS-RC                  PIC 9(00002).\n           05  WS-SUB                 PIC 9(00004) COMP.\n           05  WS-SYSIN-ARRAY-CNT     PIC 9(00004) COMP VALUE 0.\n           05  WS-SYSIN-ARRAY         OCCURS 1000.\n               10  WS-SYSIN-CARD      PIC X(00080).\n               10  WS-SYSIN-OFFSET-ARRAY  OCCURS 8.\n                   15 WS-SYSIN-OFFSET PIC 9(00004) COMP VALUE 0.\n\n       01  WS-I-REC.\n           05  WS-I-LEN               PIC 9(00004) COMP.\n           05  WS-I-DATA              PIC X(00254).\n       01  WS-O-REC                   PIC X(00080).\n       01  WS-SELMEM-REC              PIC X(00080).\n       01  WS-SYSIN-REC               PIC X(00080).\n\n      *********************\n       PROCEDURE DIVISION.\n      *********************\n\n           OPEN  INPUT  I\n                        SYSIN\n                        SELMEM\n                 OUTPUT O\n\n           SET NOT-AT-END-OF-FILE TO TRUE\n           READ  SYSIN INTO WS-SYSIN-REC\n               AT END SET AT-END-OF-FILE TO TRUE\n           END-READ\n           PERFORM 0200-READ-SYSIN-LOOP\n               UNTIL AT-END-OF-FILE\n\n           SET NOT-AT-END-OF-FILE TO TRUE\n           READ  SELMEM INTO WS-SELMEM-REC\n               AT END SET AT-END-OF-FILE TO TRUE\n           END-READ\n           PERFORM 0400-READ-SELMEM-LOOP\n               UNTIL AT-END-OF-FILE\n\n           SET NOT-AT-END-OF-FILE TO TRUE\n           READ  I INTO WS-I-REC\n               AT END SET AT-END-OF-FILE TO TRUE\n           END-READ\n           PERFORM 0600-READ-I-LOOP\n               UNTIL AT-END-OF-FILE\n\n           CLOSE I\n                 SYSIN\n                 SELMEM\n                 O\n           GOBACK\n           .\n\n       0200-READ-SYSIN-LOOP.\n      ***********************\n           ADD 1 TO WS-SYSIN-ARRAY-CNT\n           MOVE WS-SYSIN-REC TO WS-SYSIN-CARD(WS-SYSIN-ARRAY-CNT)\n           MOVE 0 TO JJ\n           PERFORM VARYING II FROM 1 BY 1\n                       UNTIL II > 72\n               IF WS-SYSIN-REC(II:8) = '????????'\n                       OR WS-SYSIN-REC(II:8) = '########'\n                   ADD 1 TO JJ\n                   MOVE II TO WS-SYSIN-OFFSET(WS-SYSIN-ARRAY-CNT JJ)\n                   ADD 7 TO II\n               END-IF\n           END-PERFORM\n           READ  SYSIN INTO WS-SYSIN-REC\n               AT END SET AT-END-OF-FILE TO TRUE\n           END-READ\n           .\n\n       0400-READ-SELMEM-LOOP.\n      ************************\n           SET AT-END-OF-FILE TO TRUE\n           MOVE WS-SELMEM-REC(07:06) TO WS-FIRST\n           MOVE WS-SELMEM-REC(20:06) TO WS-LAST\n           MOVE WS-SELMEM-REC(38:08) TO WS-FIRST-MEM\n           MOVE WS-SELMEM-REC(58:08) TO WS-LAST-MEM\n           .\n\n       0600-READ-I-LOOP.\n      *******************\n           MOVE 3 TO JJ\n           PERFORM UNTIL JJ > WS-I-LEN OR AT-END-OF-FILE\n               IF WS-I-REC(JJ:8) = HIGH-VALUES\n                   SET AT-END-OF-FILE TO TRUE\n               ELSE\n                   ADD 1 TO WS-MEM-CNT\n                   IF WS-I-REC(JJ:8) > WS-LAST-MEM\n                           OR WS-I-REC(JJ:8) < WS-FIRST-MEM\n                           OR WS-MEM-CNT     < WS-FIRST\n                           OR WS-MEM-CNT     > WS-LAST\n                       CONTINUE\n                   ELSE\n                       PERFORM 0800-GEN-IMAGES\n                   END-IF\n                   MOVE 0 TO WS-FW-CNT\n                   MOVE WS-I-REC(JJ + 11:1) TO WS-HW-BYTE\n                   MULTIPLY 2048 BY WS-FW-CNT\n                   DIVIDE   WS-HW-CNT BY 2048 GIVING WS-HW-CNT\n                   COMPUTE JJ = JJ + 12 + (WS-HW-CNT * 2)\n               END-IF\n           END-PERFORM\n           IF NOT-AT-END-OF-FILE\n               READ  I INTO WS-I-REC\n                   AT END SET AT-END-OF-FILE TO TRUE\n               END-READ\n           END-IF\n           .\n\n       0800-GEN-IMAGES.\n      ******************\n           PERFORM VARYING LL FROM 1 BY 1\n                   UNTIL ( LL > 7 OR WS-I-REC(JJ + LL:1) = ' ' )\n           END-PERFORM\n           PERFORM VARYING II FROM 1 BY 1\n                       UNTIL II > WS-SYSIN-ARRAY-CNT\n               MOVE WS-SYSIN-CARD(II) TO WS-IMAGE\n               PERFORM VARYING KK FROM 8 BY -1\n                       UNTIL KK < 1\n                   IF WS-SYSIN-OFFSET(II KK) > 0\n                       MOVE WS-SYSIN-OFFSET(II KK) TO WS-SUB\n                       IF WS-IMAGE(WS-SUB:8) = '########'\n                           MOVE WS-I-REC(JJ:8) TO WS-IMAGE(WS-SUB:8)\n                       ELSE\n                           STRING\n                               WS-IMAGE(1:WS-SUB - 1)\n                               WS-I-REC(JJ:LL)\n                               WS-IMAGE(WS-SUB + 8:)\n                               WS-BLANKS(1:8 - LL)\n                                   DELIMITED BY SIZE\n                               INTO WS-IMAGE\n                           END-STRING\n                       END-IF\n                   END-IF\n               END-PERFORM\n               WRITE O-REC FROM WS-IMAGE\n           END-PERFORM\n           .\n\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSNAME=&&LOADSET,UNIT=SYSDA,\n//             DISP=(MOD,PASS),SPACE=(CYL,(1,1)),\n//             DCB=(BLKSIZE=3200)\n//SYSUT1       DD       UNIT=SYSDA,SPACE=(CYL,(5,2))\n//SYSUT2       DD       UNIT=SYSDA,SPACE=(CYL,(5,2))\n//SYSUT3       DD       UNIT=SYSDA,SPACE=(CYL,(5,2))\n//SYSUT4       DD       UNIT=SYSDA,SPACE=(CYL,(5,2))\n//SYSUT5       DD       UNIT=SYSDA,SPACE=(CYL,(5,2))\n//SYSUT6       DD       UNIT=SYSDA,SPACE=(CYL,(5,2))\n//SYSUT7       DD       UNIT=SYSDA,SPACE=(CYL,(5,2))\n//***\n//L          EXEC     PGM=HEWL,COND=(4,LT),REGION=4M,\n//             PARM='RENT,AMODE(31),RMODE(ANY),XREF,LIST,LET,DCBS'\n//SYSLIB       DD       DSNAME=-YOUR-SCEELLED-,DISP=SHR\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,\n//             DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   03091200\n  ENTRY    DIRSCNC\n  NAME     DIRSCNC(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DIRSCNC$": {"ttr": 20752, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x19\\x00\\x19\\x00\\x00\\xc4\\xc9\\xd9\\xe2\\xc3\\xd5\\xc3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "DIRSCNC"}, "text": "//-YOUR-USERID-D JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  READ A PDS DIRECTORY AND GENERATE VARIOUS CARD IMAGES\n//***\n//DELETE     EXEC       PGM=IEFBR14\n//SCRATCH      DD         DISP=(MOD,DELETE,DELETE),\n//             DSN=-YOUR-USERID-.$$$TEMP.DIRSCNC,                  <***\n//             UNIT=SYSDA,SPACE=(TRK,0)\n//***\n//DIRSCNC    EXEC     PGM=DIRSCNC,PARM=NR,REGION=4M\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//I            DD       DISP=SHR,DCB=(RECFM=F,LRECL=256,BLKSIZE=256),\n//             DSN=...                                             <***\n//SYSIN        DD       DATA,DLM=XX\n  ########  FIXED 8 BYTE MEMBER NAME\n  ????????  VARIABLE MEMBER NAME\nXX\n//SELMEM       DD       *\nFIRST=000001, LAST=999999, FIRSTMEM='        ', LASTMEM='99999999';\n//O            DD         DISP=(,CATLG),\n//             DSN=-YOUR-USERID-.$$$TEMP.DIRSCNC,                  <***\n//             UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),\n//             DCB=(RECFM=FB,LRECL=80)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DIRSCNQ": {"ttr": 20993, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x99\\x00\\x99\\x00\\x00\\xc4\\xc9\\xd9\\xe2\\xc3\\xd5\\xd8@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 153, "newlines": 153, "modlines": 0, "user": "DIRSCNQ"}, "text": "//-YOUR-USERID-D JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//C          EXEC     PGM=IEL0AA,REGION=4M,\n//             PARM=('AG,A,NCT,ESD,F(I),NOFLOW,NIS,NOLIST,M,NMI,NEST',\n//             'MAP,OF,OPT(TIME),OP,SZ(MAX),S,STMT,STG,X(F)')\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-PLI-LIB-\n /***                                                              ***/\n /*** DIRSCNQ WILL GENERATE THE SET OF CARD IMAGES IN THE SYSIN    ***/\n /*** FILE FOR EACH MEMBER IN THE PDS SPECIFIED BY THE I FILE.     ***/\n /*** NO, YOU CAN NOT CONCATENATE MULTIPLE PDS'S TO I.             ***/\n /***                                                              ***/\n /*** FOR EACH MEMBER IN I, DIRSCNQ WILL GENERATE THE IMAGES IN    ***/\n /*** SYSIN REPLACING EIGHT QUESTION MARKS (????????) WITH THE     ***/\n /*** MEMBER NAME AND COMPRESSING THE CARD IMAGE FOR MEMBER NAMES  ***/\n /*** LESS THEN EIGHT CHARACTERS LONG.  IT WILL ALSO REPLACE       ***/\n /*** EIGHT POUND SIGNS (########) WITH THE MEMBER NAME, NOT       ***/\n /*** COMPRESSING THE CARD (I.E. LEAVING THE LAST BYTES BLANK IF   ***/\n /*** LESS THEN EIGHT BYTES LONG).                                 ***/\n /***                                                              ***/\n /*** THE SELMEM FILE INPUT SPECIFIES THE NUMBERS OF THE MEMBER    ***/\n /*** RANGE TO BE GENERATED, FIRST AND LAST, OR THE ACTUAL MEMBER  ***/\n /*** NAME RANGE, FIRSTMEM AND LASTMEM.  DEFAULTS ARE SET TO GEN   ***/\n /*** FOR EVERY MEMBER.                                            ***/\n /***                                                              ***/\n\n DIRSCNQ:\n      PROC OPTIONS(MAIN) REORDER;\n\n      DCL  SELMEM       FILE INPUT STREAM\n                        ENV(FB, RECSIZE(080), TOTAL);\n      DCL  SYSIN        FILE INPUT RECORD SEQL\n                        ENV(FB, RECSIZE(080), TOTAL);\n      DCL  I            FILE INPUT RECORD SEQL\n                        ENV(F, RECSIZE(256), BLKSIZE(256), TOTAL);\n      DCL  O            FILE OUTPUT RECORD SEQL\n                        ENV(FB, RECSIZE(80), TOTAL);\n\n      DCL  1  DIR_BLK           BASED(DIR_BLK_PTR),\n              2  LL             FIXED BIN(15,0),\n              2  DATA           CHAR(254);\n\n      DCL  1  MEM_OVLY          BASED(MEM_OVLY_PTR),\n              2  MEMBER         CHAR(8),\n              2  TTR            CHAR(3),\n              2  C,\n                 3  ALIAS       BIT(1),\n                 3  TTR_CNT     BIT(2),\n                 3  DATA_CNT    BIT(5),\n              2  ORG_HWDS(39)   CHAR(2);\n\n      DCL  MASK_ARRAY(1000)     CHAR(80) STATIC;\n      DCL  MASK_CARD            CHAR(80) STATIC;\n\n      DCL  CHARVAR              CHAR(8) VAR STATIC;\n      DCL  FIRST                FIXED BIN(31) STATIC INIT(00000001);\n      DCL  LAST                 FIXED BIN(31) STATIC INIT(99999999);\n      DCL  FIRSTMEM             CHAR(8) STATIC INIT(' ');\n      DCL  LASTMEM              CHAR(8) STATIC INIT('99999999');\n\n      DCL  ( MEM_OVLY_PTR, DIR_BLK_PTR )\n                                PTR STATIC;\n      DCL  ( MEMBER, MASK_CTR, LEN, ICTR, JCTR, I_ORG_CNT )\n                                FIXED BIN(31) STATIC INIT(0);\n      DCL  ( HBOUND, SUBSTR, HIGH, LENGTH, ADDR, INDEX )\n                                BUILTIN;\n\n      OPEN FILE(SELMEM),\n           FILE(SYSIN),\n           FILE(I),\n           FILE(O);\n      GET DATA FILE(SELMEM);\n\n      ON ENDFILE(SYSIN) GOTO SYSIN_EOF;\n\n      DO MASK_CTR = 1 TO HBOUND(MASK_ARRAY,1);\n            READ FILE(SYSIN) INTO(MASK_ARRAY(MASK_CTR));\n            END;\n\n SYSIN_EOF:\n      MASK_CTR = MASK_CTR - 1;\n      ON ENDFILE(I) GOTO I_EOF;\n\n I_READ_LOOP:\n      READ FILE(I) SET(DIR_BLK_PTR);\n      LEN = 2;\n      MEM_OVLY_PTR = ADDR(DIR_BLK.DATA);\n\n I_MEM_ROUTINE:\n      IF MEM_OVLY.MEMBER = HIGH(8)\n            THEN GOTO I_EOF;\n      MEMBER = MEMBER + 1;\n      IF MEMBER < FIRST\n         | MEM_OVLY.MEMBER < FIRSTMEM\n            THEN GOTO I_NEXT_MEM;\n      IF MEMBER > LAST\n         | MEM_OVLY.MEMBER > LASTMEM\n            THEN GOTO I_EOF;\n      ICTR = INDEX ( MEM_OVLY.MEMBER, ' ' );\n      IF ICTR = 0\n         THEN ICTR = 9;\n      CHARVAR = SUBSTR(MEM_OVLY.MEMBER,1,ICTR-1);\n      DO ICTR = 1 TO MASK_CTR;\n         MASK_CARD = MASK_ARRAY(ICTR);\n         JCTR = INDEX ( MASK_CARD, '????????' );\n         DO WHILE ( JCTR > 0 );\n            SUBSTR(MASK_CARD, JCTR, 73-JCTR)\n               = CHARVAR\n                  || SUBSTR(MASK_CARD, JCTR+8, 65-JCTR);\n            JCTR = INDEX ( MASK_CARD, '????????' );\n            END;\n         JCTR = INDEX ( MASK_CARD, '########' );\n         DO WHILE ( JCTR > 0 );\n            SUBSTR(MASK_CARD, JCTR, 8)\n               = CHARVAR;\n            JCTR = INDEX ( MASK_CARD, '########' );\n            END;\n         WRITE FILE(O) FROM(MASK_CARD);\n         END;\n I_NEXT_MEM:\n      I_ORG_CNT = MEM_OVLY.C.DATA_CNT + 1;\n      MEM_OVLY_PTR = ADDR(MEM_OVLY.ORG_HWDS(I_ORG_CNT));\n      LEN = LEN + (2 * I_ORG_CNT) + 10;\n      IF DIR_BLK.LL > LEN\n            THEN GOTO I_MEM_ROUTINE;\n            ELSE GOTO I_READ_LOOP;\n\n I_EOF:\n      CLOSE FILE(SELMEM),\n            FILE(SYSIN),\n            FILE(I),\n            FILE(O);\n      END DIRSCNQ;\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(5,2),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(CYL,(05,02))\n//***\n//L          EXEC     PGM=HEWLKED,\n//             PARM='XREF,LIST,LET,DCBS,AMODE(31),RMODE(ANY)',\n//             REGION=4M\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE)\n//             DD       *\n  SETSSI   97111402\n  ENTRY    PLISTART\n  NAME     DIRSCNQ(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DIRSCNQ$": {"ttr": 20997, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x18\\x00\\x18\\x00\\x00\\xc4\\xc9\\xd9\\xe2\\xc3\\xd5\\xd8@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "DIRSCNQ"}, "text": "//-YOUR-USERID-D JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  READ A PDS DIRECTORY AND GENERATE VARIOUS CARD IMAGES\n//***\n//DELETE     EXEC       PGM=IEFBR14\n//SCRATCH      DD         DISP=(MOD,DELETE,DELETE),\n//             DSN=-YOUR-USERID-.$$$TEMP.DIRSCNQ,                  <***\n//             UNIT=SYSDA,SPACE=(TRK,0)\n//***\n//DIRSCNQ    EXEC     PGM=DIRSCNQ,PARM=NR,REGION=4M\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//I            DD       DISP=SHR,DSN=...                           <***\n//SYSIN        DD       DATA,DLM=XX\n  ########  FIXED 8 BYTE MEMBER NAME\n  ????????  VARIABLE MEMBER NAME\nXX\n//SELMEM       DD       *\nFIRST=000001, LAST=999999, FIRSTMEM='        ', LASTMEM='99999999';\n//O            DD         DISP=(,CATLG),\n//             DSN=-YOUR-USERID-.$$$TEMP.DIRSCNQ,                  <***\n//             UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),\n//             DCB=(RECFM=FB,LRECL=80)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DISPARA": {"ttr": 20999, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00G\\x00G\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 71, "newlines": 71, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- CREATE DISPLAYS AFTER EACH PARAGRAPH  **/\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'DISPARA EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      EXIT(12)\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      ADDRESS ISREDIT \"ISREDIT MACRO (PARMS) NOPROCESS\"\n      PARMS = TRANSLATE(PARMS)\n      IF PARMS = \"?\" THEN SIGNAL DISPDOC\n   END\n   ELSE DO\n      SAY 'DISPARA EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      EXIT(12)\n   END\n\n   ADDRESS ISREDIT\n   OVLAY = \"           DISPLAY '~DEBUG~ \"\n   SEEK \"' PROC'\" FIRST 7\n   \"(CURLINE) = LINENUM .ZCSR\"\n   CURLINE = CURLINE + 1\n   \"LABEL (CURLINE) = .A\"\n   EXCLUDE ALL\n   \"FIND FIRST P' \u00ac' 7 .A .ZL\"\n   \"(CURLINE) = LINENUM .ZCSR\"\n   RET_CODE = 0\n   DO WHILE RET_CODE = 0\n      \"(DISPLINE) = LINE (CURLINE)\"\n      DO II = 8 TO 11 BY 1 WHILE (SUBSTR(DISPLINE,II,1) = \" \")\n      END II\n      XX = POS(\" EXIT.\",DISPLINE)\n      IF XX = 0 THEN DO\n         DO JJ = 43 TO II BY -1 WHILE (SUBSTR(DISPLINE,JJ,1) = \" \")\n         END JJ\n         DISPLINE = OVLAY || SUBSTR(DISPLINE,II,JJ-II) || \"'\"\n         \"LINE_AFTER (CURLINE) = (DISPLINE)\"\n      END\n      ELSE DO\n         EXITLINE = SUBSTR(DISPLINE,1,XX-1)\n         \"LINE (CURLINE) = (EXITLINE)\"\n         EXITLINE = COPIES(\" \",XX-1) || SUBSTR(DISPLINE,XX)\n         \"LINE_AFTER (CURLINE)= (EXITLINE)\"\n         DO JJ = XX TO II BY -1 WHILE (SUBSTR(DISPLINE,JJ,1) = \" \")\n         END JJ\n         DISPLINE = OVLAY || SUBSTR(DISPLINE,II,JJ-II) || \"'\"\n         \"LINE_AFTER (CURLINE) = (DISPLINE)\"\n      END\n      \"FIND NEXT P' \u00ac' 7\"\n      RET_CODE = RC\n      IF RET_CODE = 0 THEN \"(CURLINE) = LINENUM .ZCSR\"\n   END\n   RESET\n   SEEK \"' PROC'\" FIRST 7\n   EXIT(1)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"DISPARA - CREATE DISPLAYS OF PARAGRAPH NAMES AFTER EACH   \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    DISPARA  ( ? )                                        \"\n   SAY\n   SAY \"       CREATES A DISPLAY OF THE NAME OF EACH PARAGRAPH    \"\n   SAY \"       AFTER EACH PARAGRAPH NAME.                         \"\n   SAY\n   SAY \"       USE DELPARA TO REMOVE THESE DISPLAYS IF NEEDED.    \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DISPDSN": {"ttr": 21002, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\x19\\x00\\x19\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- PUT DISP=SHR IN FRONT OF DSN=  **/\n   ADDRESS ISREDIT\n      \"MACRO (PARMS)\"\n      IF PARMS = \"?\" THEN SIGNAL DISPDOC\n      \"X ALL\"\n      \"%FAND ',DISP=SHR' 'DSN='\"\n      \"C     ',DISP=SHR' ''              ALL NX\"\n      \"C     'DSN='      'DISP=SHR,DSN=' ALL NX\"\n      \"RESET\"\n   EXIT 1\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"DISPDSN - PLACE ALL DSN AND DISP JCL VALUES IN THAT ORDER \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    DISPDSN \"\n   SAY\n   SAY \"       FORCES DSN=...,DISP=SHR INTO THE REVERSE FORMAT, NAMELY\"\n   SAY \"       DISP=SHR,DSN=...; THIS MACRO USES FAND TO ASSURE BOTH  \"\n   SAY \"       DISP AND DSN ARE PRESENT.                              \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DISPVAR": {"ttr": 21004, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x88\\x00\\x88\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 136, "newlines": 136, "modlines": 0, "user": "REXX"}, "text": "/* REXX - GEN A DISPLAY STATEMENT FOR THE VARIABLE AT THE CURSOR */\n\nADDRESS ISPEXEC\n\"ISPEXEC CONTROL ERRORS RETURN\"\n\"ISREDIT MACRO (PARMS) NOPROCESS\"\nIF  RC > 0 THEN DO\n   \"ISPEXEC SETMSG MSG(CBL000A)\"\n   EXIT\nEND\nIF PARMS = '?' THEN CALL DISPDOC\n\nCOL7     = 7\nCOL8     = 8\nCOL11    = 11\nCOL20    = 20\nLEN72    = 72\nSPACES11 = '           '\n\n\"ISREDIT (QLINE,QCOL) = CURSOR\"\nIF  QLINE = 0 | QCOL = 0 THEN DO\n   \"ISPEXEC SETMSG MSG(CBL000C)\"\n   EXIT\nEND\n\n   /* GET THE DATA LINE WITH THE FIELD NAME TO BE PROCESSED */\n\"ISREDIT (QLDATA) = LINE\" QLINE\nQLDATA = SUBSTR(QLDATA,1,LEN72)\n\"ISREDIT (XLDATA) = LINE\" QLINE+1\nIF SUBSTR(XLDATA,7,1) <> '*',\n      & SUBSTR(XLDATA,7,1) <> '/',\n      & SUBSTR(XLDATA,7,1) <> 'D',\n   THEN XLDATA = SUBSTR(XLDATA,8,LEN72)\n   ELSE XLDATA = \" \"\n\n   /* IF 'IN' OR 'OF' ON NEXT LINE, APPEND IT TO CURSOR LINE */\nIF  (  POS(' IN ',TRANSLATE(QLDATA)) > 0,\n     | POS(' IN ',TRANSLATE(XLDATA)) > 0,\n     | POS(' OF ',TRANSLATE(QLDATA)) > 0,\n     | POS(' OF ',TRANSLATE(XLDATA)) > 0  ),\n   THEN QLDATA = QLDATA || XLDATA\n\n   /* FIGURE END OF VARIABLE */\nQLEN = LENGTH(QLDATA)\nSPC_CHARS = \" ,.='\"\nDO OK = (QCOL+1) TO QLEN BY 1,\n   WHILE ( VERIFY(SUBSTR(QLDATA,OK,1),SPC_CHARS) <> 0 )\nEND OK\nQEND = OK - 1\n\n   /* FIGURE IF 'OF' OR 'IN' AFTER VARIABLE AND INCLUDE AS VARIABLE */\nDO QQ = (QEND+1) TO QLEN BY 1 WHILE ( SUBSTR(QLDATA,QQ,1) = ' ' )\nEND QQ\nIF TRANSLATE(SUBSTR(QLDATA,QQ,3)) = 'IN ',\n      | TRANSLATE(SUBSTR(QLDATA,QQ,3)) = 'OF ' THEN DO\n   DO RR = QQ+2 TO QLEN BY 1 WHILE ( SUBSTR(QLDATA,RR,1) = ' ' )\n   END RR\n   DO SS = RR TO QLEN BY 1  WHILE ( SUBSTR(QLDATA,SS,1) <> ' ' )\n   END SS\n   QEND = SS - 1\nEND\n\n   /* FIGURE IF SUBSCRIPT OR REF MOD AND INCLUDE AS VARIABLE */\nDO 2\n   DO QQ = (QEND+1) TO QLEN BY 1 WHILE ( SUBSTR(QLDATA,QQ,1) = ' ' )\n   END QQ\n   IF (QQ < QLEN) & (SUBSTR(QLDATA,QQ,1) = '(')  THEN DO\n      DO RR = (QQ+1) TO QLEN WHILE ( SUBSTR(QLDATA,RR,1) <> ')')\n      END RR\n      QEND = RR\n   END\nEND\n\nIF QEND > 72 THEN QLINE = QLINE + 1\n\n   /* FIGURE START OF VARIABLE */\nDO OK = QCOL TO 1 BY -1,\n   WHILE ( VERIFY(SUBSTR(QLDATA,OK,1),SPC_CHARS) <> 0 )\nEND OK\nIF OK < 1 THEN QSTART = 1\nELSE QSTART = OK + 1\n\nQLEN = (QEND - QSTART) + 1\nQWORD = SUBSTR(QLDATA,QSTART,QLEN)\n\n   /* ELIMINATE DOUBLE BLANKS */\nQQ = POS('  ',QWORD)\nDO WHILE ( QQ <> 0 )\n   QWORD = SUBSTR(QWORD,1,QQ) || SUBSTR(QWORD,QQ+2)\n   QQ = POS('  ',QWORD)\nEND\n\nQWORD = STRIP(QWORD,'B','(')\nW_LEN = LENGTH(QWORD)\n\nIF  W_LEN > 16 THEN DO\n   IF  W_LEN > 39 THEN QWORD_X = SUBSTR(QWORD,1,34)||'*'\n   ELSE QWORD_X = QWORD\n   DLINE1 = SPACES11\"DISPLAY '~DEBUG~ \"QWORD_X\" = >'\"\n   DLINE2 = SPACES11\"  \"QWORD\" '< ~DEBUG~'\"\nEND\nELSE DLINE1 = SPACES11\"DISPLAY '~DEBUG~ \"QWORD\" = >' \",\n   || QWORD\" '<'\"\n\nIF  W_LEN > 16 THEN \"ISREDIT LINE_AFTER\" QLINE\" = (DLINE2)\"\n\"ISREDIT LINE_AFTER\" QLINE\" = (DLINE1)\"\n'ISREDIT CURSOR = 'QLINE','QCOL\nEXIT\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"DISPVAR - ADD DISPLAY DEBUG FOR VARIABLE UNDER CURSOR     \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    DISPVAR                                               \"\n   SAY\n   SAY \"       ADDS ONE OR TWO LINES THAT DISPLAY THE VARIABLE ON \"\n   SAY \"       WHICH THE CURSOR WAS POSITIONED. WILL HANDLE BOTH  \"\n   SAY \"       IN AND ON EVEN IF THEY ARE ON THE NEXT LINE, AND   \"\n   SAY \"       BOTH SUBSCRIPT AND REFERENCE MODIFICATION IF ON    \"\n   SAY \"       THE SAME LINE. THE CURSOR MUST BE POSITIONED ON    \"\n   SAY \"       THE VARIABLE NAME. FOR EXAMPLE, IF THE CURSOR IS   \"\n   SAY \"       ON NUMB-RECS-WRITTEN:                              \"\n   SAY\n   SAY \"           ADD 1 TO NUMB-RECS-WRITTEN                     \"\n   SAY \"               OF WS-MISC ( 12 )                          \"\n   SAY\n   SAY \"       THE FOLLOWING LINES WILL BE INSERTED:              \"\n   SAY\n   SAY \"DISPLAY '~DEBUG~ NUMB-RECS-WRITTEN OF WS-MISC ( 12 ) = >' \"\n   SAY \"          NUMB-RECS-WRITTEN OF WS-MISC ( 12 ) '< ~DEBUG~' \"\n   SAY\n   SAY \"       USE DELPARA TO REMOVE ALL THE INSERTED LINES.      \"\n   SAY\n   EXIT(0)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSLIST": {"ttr": 21007, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\x94\\x00\\x94\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 148, "newlines": 148, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- CURSOR-DRIVEN ENTRY INTO PDF 3.4 PANEL                  **/\n\n   ADDRESS ISPEXEC\n   \"CONTROL ERRORS RETURN\"\n   ZERRMSG = ''\n   DSNAME  = ''\n   \"ISREDIT MACRO (PARMS)\"\n   PARMS = TRANSLATE(PARMS)\n   IF PARMS = \"?\" THEN SIGNAL DISPDOC\n   IF RC = 0 THEN DO\n      \"ISREDIT (LINE,CSRP) = CURSOR\"\n      \"ISREDIT (LINE)      = LINE .ZCSR\"\n      IF CSRP > 0 THEN CALL EXTRACT_DSNAME\n   END\n   ELSE DO\n      \"VGET ZAPPLID\"\n      IF ZAPPLID <> 'ISR' THEN DO\n         \"SELECT CMD(%\"SYSVAR(SYSICMD) \") NEWAPPL(ISR)\"\n         EXIT RC\n      END\n      CALL FIND_CURSOR_POSITION\n      CALL EXTRACT_DSNAME\n   END\n   \"VGET ZENVIR\"\n   CALL INVOKE_ISRUDL\n   IF ZERRMSG\\='' THEN \"SETMSG MSG(\"ZERRMSG\")\"\n   EXIT(0)\n\nFIND_CURSOR_POSITION:\n   TCB    = PTR(540)\n   TCB    = PTR(TCB+132)\n   FSA    = PTR(TCB+112)\n   R1     = PTR(FSA+24)\n   TLD    = PTR(R1)\n   TLS    = PTR(TLD+096)\n   CSR    = PTR(TLD+164)\n   SCRW   = PTR(TLD+192)\n   IF SCRW > 0 THEN CSRP = CSR//SCRW+1\n               ELSE CSRP = 1\n   LINEAD = D2X(TLS+CSR-CSRP+1)\n   LINE   = STORAGE(LINEAD,SCRW)\n   RETURN\n\nPTR:\n   RETURN C2D(BITAND(STORAGE(D2X(ARG(1)),4),'7FFFFFFF'X))\n\nEXTRACT_DSNAME:\n   VALID = COPIES(' ',64) || XRANGE('40'X,'FF'X)\n   IF SUBSTR(LINE,CSRP,1) = ' ' THEN RETURN\n   P = SUBSTR(LINE,MAX(CSRP-3,1),MIN(CSRP+3,LENGTH(LINE))+1)\n   IF POS('DSN=',P) > 0 THEN CSRP = CSRP + 4\n   P = SUBSTR(LINE,MAX(CSRP-6,1),MIN(CSRP+6,LENGTH(LINE))+1)\n   IF POS('DSNAME=',P) > 0 THEN CSRP = CSRP + 7\n   LINE = COPIES(' ',10) || TRANSLATE(LINE,VALID) || COPIES(' ',10)\n   CSRP = CSRP + 10\n   UPPER LINE\n\n   DO WHILE SUBSTR(LINE,CSRP,1) = '('; CSRP = CSRP + 1; END\n   DO WHILE SUBSTR(LINE,CSRP,1) = ')'; CSRP = CSRP - 1; END\n\n   VALID = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$-{.'\n   LD    = 0\n   LP    = 0\n\n   C = SUBSTR(LINE,CSRP,1)\n   IF VERIFY(C,VALID) = 1  THEN DO\n      IF C <> \"'\" THEN RETURN\n      IF VERIFY(SUBSTR(LINE,CSRP+1,1),VALID) = 0  THEN LD = CSRP\n      ELSE DO\n         P = CSRP - 1\n         IF SUBSTR(LINE,P,1) = ')',\n               | VERIFY(SUBSTR(LINE,P,1),VALID) = 0,\n            THEN CSRP = CSRP - 2\n            ELSE RETURN\n      END\n   END\n\n   IF LD = 0 THEN DO\n      DO CSRP = CSRP TO 1 BY -1\n         C = SUBSTR(LINE,CSRP,1)\n         IF VERIFY(C,VALID) > 0  THEN\n            IF C = '(' THEN DO\n               IF LP > 0 THEN LEAVE\n               DO I = 1 TO 9\n                  IF SUBSTR(LINE,CSRP+I,1) = '.' THEN LEAVE\n               END\n               IF I > 8 THEN LP = CSRP\n                        ELSE LEAVE\n            END\n         ELSE LEAVE\n      END\n      LD = CSRP\n      IF LP = LD + 1  THEN DO\n         LP = 0\n         LD = LD + 1\n      END\n   END\n\n   IF LP = 0  THEN DO\n      CSRP = LD + 1\n      P = VERIFY(LINE,VALID,,CSRP)\n      IF SUBSTR(LINE,P,1) = '(' THEN DO\n         LP   = P\n         CSRP = P + 1\n      END\n   END\n   ELSE CSRP = LP + 1\n\n   RD = VERIFY(LINE,VALID,,CSRP)\n   IF LP > 0 & SUBSTR(LINE,RD,1) = ')'  THEN RD = RD + 1\n   IF SUBSTR(LINE,LD,1) = \"'\" & SUBSTR(LINE,RD,1) <> \"'\"  THEN RETURN\n\n   DSNAME = SUBSTR(LINE,LD+1,RD-LD-1)\n   IF LEFT(DSNAME,9) = 'CLUSTER--',\n         | LEFT(DSNAME,9) = 'DATA-----',\n         | LEFT(DSNAME,9) = 'INDEX----',\n         | LEFT(DSNAME,9) = 'NONVSAM--',\n      THEN DSNAME = RIGHT(DSNAME,LENGTH(DSNAME)-9)\n   IF LENGTH(DSNAME) < 5 | LENGTH(DSNAME) > 44 THEN DSNAME = ''\n   RETURN\n\nINVOKE_ISRUDL:\n   IF DSNAME <> '' THEN DO\n      I = POS('(',DSNAME)\n      IF I > 0 THEN ZDLDSNLV=LEFT(DSNAME,I-1)\n      ELSE ZDLDSNLV = DSNAME\n      ZDLPVL = ''\n      \"VPUT (ZDLDSNLV ZDLPVL) PROFILE\"\n   END\n   \"SELECT PGM(ISRUDL) PARM(ISRUDLP)\"\n   RETURN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"DSLIST - USE DATA SET NAME UNDER CURSOR TO INVOKE DS LIST \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    %DSLIST \"\n   SAY\n   SAY \"       THIS REXX MACRO ALLOWS YOU TO INVOKE THE DATA-SET LIST  \"\n   SAY \"       FUNCTION OF ISPF/PDF (OPTION 3.4) WITH THE DSNAME LEVEL \"\n   SAY \"       FIELD SET TO THE DSNAME UNDER WHICH THE CURSOR IS PLACED\"\n   SAY \"       WHEN YOU ENTER THE COMMAND.  DSLIST MAY BE INVOKED AS A \"\n   SAY \"       COMMAND OR AS AN EDIT MACRO.                            \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DYNA": {"ttr": 21249, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00H\\x00H\\x00\\x00\\xc4\\xe8\\xd5\\xc1@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 72, "newlines": 72, "modlines": 0, "user": "DYNA"}, "text": "//-YOUR-USERID-D JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//A          EXEC     PGM=ASMA90,REGION=4M\n//SYSLIB       DD       DISP=SHR,DSN=SYS1.MACLIB\n//             DD       DISP=SHR,DSN=-YOUR-SYSLIB-\nDYNA     TITLE 'DYNAMICALLY ALLOCATE A DSN USING DDNAME AND SHR'\n**********************************************************************\n*  INPUT PARAMETERS ARE:\n*    DATA SET NAME       44 BYTES - ALPHANUMERIC  POINTED TO IN R2\n*    MEMBER               8 BYTES - ALPHANUMERIC                R3\n*    DDNAME               8 BYTES - ALPHANUMERIC                R4\n*    DYNALLOC R15 R/C     2 BYTES - BINARY                      R5\n*    DYNALLOC RETURN CODE 2 BYTES - BINARY                      R6\n*    DYNALLOC REASON CODE 2 BYTES - BINARY                      R7\n**********************************************************************\n         COPY  MACSDYNA\nDYNA     RENTER\n         LM    R2,R7,0(R1)\n         ST    R2,DSADDR          DSNAME ADDR FOR ALLOC MACRO\n         ST    R3,MNADDR          MEMBER ADDR\n         ST    R4,DDADDR          DDNAME ADDR\n\n         CLC   0(8,R3),BLANKS\n         BE    NONMEM\n         ALLOC DISP=SHR,DSN=DSADDR,MEMBER=MNADDR,DDN=DDADDR\n         B     CHECKOUT\nNONMEM   ALLOC DISP=SHR,DSN=DSADDR,DDN=DDADDR\n\n         DROP  R14\n         USING S99RB,R14\nCHECKOUT STH   R15,0(R5)          SEND BACK DYNALLOC R15 VALUE\n         MVC   0(2,R6),S99ERROR   SEND ERROR REASON CODE BACK\n         MVC   0(2,R7),S99INFO    SEND INFO  REASON CODE BACK\n         REXIT\n\n**       ALLOC MACRO PARAMETERS\n\nDSADDR   DS    A\nDSLEN    DC    H'44'              LENGTH  OF DSNAME (44)\nMNADDR   DS    A\nMNLEN    DC    H'8'               LENGTH  OF MEMBER (08)\nDDADDR   DS    A\nDDLEN    DC    H'8'               LENGTH  OF DDNAME (08)\n\nBLANKS   DC    CL08'        '\n         LTORG\n         DYNSPACE\n         IEFZB4D0\n         IEFZB4D2\n         END\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//***\n//L          EXEC     PGM=IEWL,\n//             PARM='XREF,LIST,LET,DCBS',\n//             REGION=4M\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,\n//             DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   99070900\n  ENTRY    DYNA\n  NAME     DYNA(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DYNAMC": {"ttr": 21252, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xd4\\x00\\xd4\\x00\\x00\\xc2\\xd7\\xe7\\xe6\\xc4\\xe8\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 212, "newlines": 212, "modlines": 0, "user": "BPXWDYN"}, "text": "//-YOUR-USERID-D JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  READ AND WRITE RECORDS FROM DYNAMICALLY ALLOCATED FILES\n//***\n//C          EXEC     PGM=IGYCRCTL,REGION=4M,\n//             PARM=('DYNAM,LIB,MAP,NUMPROC(PFD),OFF,OPTIMIZE',\n//            'APOST,NOSEQ,TRUNC(OPT),XREF')\n//SYSIN        DD       *\n\n      **************************\n       IDENTIFICATION DIVISION.\n      **************************\n       PROGRAM-ID.  DYNAMC.\n\n\n      ***********************\n       ENVIRONMENT DIVISION.\n      ***********************\n\n       INPUT-OUTPUT SECTION.\n      *---------------------*\n\n       FILE-CONTROL.\n\n           SELECT I\n               ASSIGN TO I.\n\n           SELECT O\n               ASSIGN TO O.\n\n\n      ****************\n       DATA DIVISION.\n      ****************\n\n       FILE SECTION.\n      *-------------*\n\n       FD  I\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  INPUT-REC    PIC X(00080).\n\n       FD  O\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  OUTPUT-REC   PIC X(00080).\n\n       WORKING-STORAGE SECTION.\n      *------------------------*\n\n       01  WS-ALLOC-STRING              PIC X(00100).\n       01  WS-INPUT-REC                 PIC X(00080).\n       01  WS-SAVE-REC                  PIC X(00080).\n       01  WORK-AREAS.\n           05  NUMBER-RECORDS-ADDED     PIC 9(9)      VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-DELETED   PIC 9(9)      VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-DUPS      PIC 9(9)      VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-READ      PIC 9(9)      VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-UPDATED   PIC 9(9)      VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-WRITTEN   PIC 9(9)      VALUE 0 COMP-3.\n           05  FINAL-RETURN-CODE        PIC 9(4)      VALUE 0 COMP.\n           05  END-OF-FILE-STATUS       PIC X         VALUE 'N'.\n               88  AT-END-OF-FILE                     VALUE 'Y'.\n           05  REWRITE-REC              PIC X         VALUE 'Y'.\n       01  WEEK-DAY-NUMBER              PIC 9.\n       01  YYMMDD                       PIC 9(6).\n       01  HHMM                         PIC 9(8).\n       01  DAYS-OF-WEEK.\n           05  MONDAY    PIC X(9)       VALUE 'MONDAY'.\n           05  TUESDAY   PIC X(9)       VALUE 'TUESDAY'.\n           05  WEDNESDAY PIC X(9)       VALUE 'WEDNESDAY'.\n           05  THURSDAY  PIC X(9)       VALUE 'THURSDAY'.\n           05  FRIDAY    PIC X(9)       VALUE 'FRIDAY'.\n           05  SATURDAY  PIC X(9)       VALUE 'SATURDAY'.\n           05  SUNDAY    PIC X(9)       VALUE 'SUNDAY'.\n       01  WEEK-DAYS                    REDEFINES DAYS-OF-WEEK.\n           05 WEEK-DAY   OCCURS 7 TIMES PIC X(9).\n\n       LINKAGE SECTION.\n      *----------------*\n       01  PARM-DATA.\n           05  PARM-LENGTH              PIC 9(4)              COMP.\n           05  PARM-PASSED              PIC X(100).\n\n\n      *************************************\n       PROCEDURE DIVISION USING PARM-DATA.\n      *************************************\n\n       0000-MAIN.\n      ************\n\n           PERFORM 0100-INITIALIZATION\n\n           PERFORM 0200-READ-WRITE-LOOP\n               UNTIL AT-END-OF-FILE\n\n           PERFORM 0900-TERMINATION\n\n           MOVE FINAL-RETURN-CODE TO RETURN-CODE\n\n           GOBACK\n           .\n\n       0100-INITIALIZATION.\n      **********************\n           MOVE ' ' TO WS-ALLOC-STRING\n           STRING 'ALLOC DD(I) DSN(''-YOUR-SYSLIB-(JOB)'') SHR'\n               DELIMITED BY SIZE\n               INTO WS-ALLOC-STRING\n           END-STRING\n           CALL 'BPXWDYN' USING WS-ALLOC-STRING\n           IF RETURN-CODE NOT = 0\n               DISPLAY '* ERROR *  DYNAMIC FILE I ALLOCATION'\n               DISPLAY '* ERROR *  RETURN CODE WAS ' RETURN-CODE\n               GOBACK\n           END-IF\n           MOVE ' ' TO WS-ALLOC-STRING\n           STRING 'ALLOC DD(O) DSN(''-YOUR-USERID-.$$$TEMP.O'') NEW '\n                  'UNIT(SYSDA) CYL SPACE(01,01) CATALOG'\n               DELIMITED BY SIZE\n               INTO WS-ALLOC-STRING\n           END-STRING\n           CALL 'BPXWDYN' USING WS-ALLOC-STRING\n           IF RETURN-CODE NOT = 0\n               DISPLAY '* ERROR *  DYNAMIC FILE O ALLOCATION'\n               DISPLAY '* ERROR *  RETURN CODE WAS ' RETURN-CODE\n               GOBACK\n           END-IF\n           OPEN  INPUT  I\n                 OUTPUT O\n           READ  I INTO WS-INPUT-REC\n               AT END SET AT-END-OF-FILE TO TRUE\n               NOT AT END ADD 1 TO NUMBER-RECORDS-READ\n           END-READ\n           .\n\n       0200-READ-WRITE-LOOP.\n      ***********************\n           MOVE 'Y' TO REWRITE-REC\n           PERFORM 0200-PROCESS\n           IF REWRITE-REC = 'Y'\n               WRITE OUTPUT-REC FROM WS-INPUT-REC\n               ADD 1 TO NUMBER-RECORDS-WRITTEN\n           ELSE\n               ADD 1 TO NUMBER-RECORDS-DELETED\n           END-IF\n           READ  I INTO WS-INPUT-REC\n               AT END SET AT-END-OF-FILE TO TRUE\n               NOT AT END ADD 1 TO NUMBER-RECORDS-READ\n           END-READ\n           .\n\n       0200-PROCESS.\n      ***************\n           CONTINUE\n           .\n\n       0900-TERMINATION.\n      *******************\n           CLOSE I\n                 O\n           ACCEPT WEEK-DAY-NUMBER FROM DAY-OF-WEEK\n           ACCEPT YYMMDD FROM DATE\n           ACCEPT HHMM FROM TIME\n           DISPLAY 'PROGRAM STATISTICS:  '\n               '                         '\n               WEEK-DAY(WEEK-DAY-NUMBER) ' '\n               YYMMDD '-' HHMM(1:2) ':' HHMM(3:2)\n           DISPLAY '    PARM LENGTH               = '\n               PARM-LENGTH\n           IF PARM-LENGTH NOT = 0\n               DISPLAY '    PARM PASSED TO PROGRAM    = '\n                   PARM-PASSED(1:PARM-LENGTH)\n           END-IF\n           DISPLAY ' '\n           DISPLAY '    NUMBER OF RECORDS READ    = '\n               NUMBER-RECORDS-READ\n           DISPLAY '    NUMBER OF RECORDS WRITTEN = '\n               NUMBER-RECORDS-WRITTEN\n           DISPLAY '    NUMBER OF RECORDS UPDATED = '\n               NUMBER-RECORDS-UPDATED\n           DISPLAY '    NUMBER OF RECORDS DELETED = '\n               NUMBER-RECORDS-DELETED\n           DISPLAY '    NUMBER OF RECORDS ADDED   = '\n               NUMBER-RECORDS-ADDED\n           DISPLAY '    NUMBER OF DUPLICATE RECS  = '\n               NUMBER-RECORDS-DUPS\n           .\n\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=SYSDA,SPACE=(CYL,(3,3)),\n//             DCB=(BLKSIZE=0,LRECL=80,RECFM=FB)\n//SYSUT1       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT2       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT3       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT4       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT5       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT6       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT7       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//***\n//GO         EXEC     PGM=LOADER,\n//             REGION=4M,COND=(5,LT)\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//SYSLOUT      DD       SYSOUT=*\n//SYSPRINT     DD       SYSOUT=*\n//SYSOUT       DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DYNAMP": {"ttr": 21257, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x004\\x004\\x00\\x00\\xc2\\xd7\\xe7\\xe6\\xc4\\xe8\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "BPXWDYN"}, "text": "//-YOUR-USERID-D JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  DYNAMIC ALLOCATION THROUGH IBM MODULE\n//***\n//C          EXEC     PGM=IEL0AA,REGION=4M,\n//             PARM=('AG,A,NCT,ESD,F(I),NOFLOW,NIS,NOLIST,M,NMI,NEST',\n//             'MAP,OF,OPT(TIME),OP,SZ(MAX),S,STMT,STG,X(F)')\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-PLI-LIB-\n\n DYNALLOC: PROC OPTIONS(MAIN) REORDER;\n\n    DCL  INFILE    FILE RECORD SEQUENTIAL INPUT;\n    DCL  SYSPRINT  FILE;\n    DCL  INREC     CHAR(32760) STATIC VARYING INIT('');\n    DCL  ALLOC_STR CHAR(00100) STATIC VARYING INIT('');\n    DCL  EOF       CHAR(00001) STATIC         INIT('N');\n    DCL  PLIRETV   BUILTIN;\n    DCL  BPXWDYN   EXTERNAL ENTRY OPTIONS(ASM INTER RETCODE);\n\n    ON ENDFILE(INFILE) EOF = 'Y';\n\n    ALLOC_STR = 'ALLOC DD(INFILE) SHR DSN(''-YOUR-SYSLIB-(JOB)'')';\n    FETCH BPXWDYN;\n    CALL BPXWDYN(ALLOC_STR);\n    IF PLIRETV() = 0\n       THEN DO;\n          OPEN FILE(INFILE);\n          READ FILE(INFILE) INTO(INREC);\n          DO WHILE (EOF='N');\n             PUT SKIP LIST(INREC);\n             READ FILE(INFILE) INTO(INREC);\n          END;\n       END;\n       ELSE DO;\n          PUT SKIP LIST('DYNALLOC FAILED, RC WAS ', PLIRETV());\n       END;\n END DYNALLOC;\n\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(CYL,(05,02))\n//***\n//GO         EXEC     PGM=LOADER,PARM='MAP,PRINT//...',\n//             REGION=4M,COND=(5,LT)\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//SYSLOUT      DD       SYSOUT=*\n//SYSPRINT     DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DYNCOB": {"ttr": 21259, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x01\\x00\\x01\\x00\\x00\\x00\\xc4\\xe8\\xd5\\xc1@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 256, "newlines": 256, "modlines": 0, "user": "DYNA"}, "text": "//-YOUR-USERID-D JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  BASIC COBOL TO READ AND WRITE A SEQUENTIAL FILE WITH\n//***  THE OPTION OF DOING PROCESSING INBETWEEN, DYNAMICALLY\n//***  ALLOCATING THE INPUT FILE BASED ON THE PARM PASSED\n//***\n//C          EXEC     PGM=IGYCRCTL,REGION=4M,\n//             PARM=('LIB,MAP,NUMPROC(PFD),OFF,OPTIMIZE',\n//            'APOST,NOSEQ,TRUNC(OPT),XREF')\n//SYSIN        DD       *\n\n      **************************\n       IDENTIFICATION DIVISION.\n      **************************\n       PROGRAM-ID.  BASE INITIAL.\n\n\n      ***********************\n       ENVIRONMENT DIVISION.\n      ***********************\n\n       INPUT-OUTPUT SECTION.\n      *---------------------*\n\n       FILE-CONTROL.\n\n           SELECT I\n               ASSIGN TO I.\n\n           SELECT O\n               ASSIGN TO O.\n\n\n      ****************\n       DATA DIVISION.\n      ****************\n\n       FILE SECTION.\n      *-------------*\n\n       FD  I\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  INPUT-REC    PIC X(00080).\n\n       FD  O\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  OUTPUT-REC   PIC X(00080).\n\n       WORKING-STORAGE SECTION.\n      *------------------------*\n\n       01  WS-INPUT-REC                 PIC X(00080).\n       01  WS-SAVE-REC                  PIC X(00080).\n       01  WORK-AREAS.\n           05  WS-DSNAME                PIC X(44)     VALUE ' '.\n           05  WS-MEMBER                PIC X(8)      VALUE ' '.\n           05  WS-DDNAME                PIC X(8)      VALUE 'I'.\n           05  WS-DYNA-R15              PIC 9(4)      VALUE 0 COMP.\n           05  WS-DYNA-RC               PIC 9(4)      VALUE 0 COMP.\n           05  WS-DYNA-WHY              PIC 9(4)      VALUE 0 COMP.\n           05  NUMBER-RECORDS-ADDED     PIC 9(9)      VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-DELETED   PIC 9(9)      VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-DUPS      PIC 9(9)      VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-READ      PIC 9(9)      VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-UPDATED   PIC 9(9)      VALUE 0 COMP-3.\n           05  NUMBER-RECORDS-WRITTEN   PIC 9(9)      VALUE 0 COMP-3.\n           05  FINAL-RETURN-CODE        PIC 9(4)      VALUE 0 COMP.\n           05  END-OF-FILE-STATUS       PIC X         VALUE 'N'.\n               88  AT-END-OF-FILE                     VALUE 'Y'.\n           05  REWRITE-REC              PIC X         VALUE 'Y'.\n           05  II                       PIC 9(4)              COMP.\n           05  JJ                       PIC 9(4)              COMP.\n           05  KK                       PIC 9(4)              COMP.\n       01  WEEK-DAY-NUMBER              PIC 9.\n       01  YYMMDD                       PIC 9(6).\n       01  HHMM                         PIC 9(8).\n       01  DAYS-OF-WEEK.\n           05  MONDAY    PIC X(9)       VALUE 'MONDAY'.\n           05  TUESDAY   PIC X(9)       VALUE 'TUESDAY'.\n           05  WEDNESDAY PIC X(9)       VALUE 'WEDNESDAY'.\n           05  THURSDAY  PIC X(9)       VALUE 'THURSDAY'.\n           05  FRIDAY    PIC X(9)       VALUE 'FRIDAY'.\n           05  SATURDAY  PIC X(9)       VALUE 'SATURDAY'.\n           05  SUNDAY    PIC X(9)       VALUE 'SUNDAY'.\n       01  WEEK-DAYS                    REDEFINES DAYS-OF-WEEK.\n           05 WEEK-DAY   OCCURS 7 TIMES PIC X(9).\n\n       LINKAGE SECTION.\n      *----------------*\n       01  PARM-DATA.\n           05  PARM-LENGTH              PIC 9(4)              COMP.\n           05  PARM-PASSED              PIC X(100).\n\n\n      *************************************\n       PROCEDURE DIVISION USING PARM-DATA.\n      *************************************\n\n       0000-MAIN.\n      ************\n\n           PERFORM 0100-INITIALIZATION\n\n           IF WS-DYNA-R15 = 0\n\n               PERFORM 0200-READ-WRITE-LOOP\n                   UNTIL AT-END-OF-FILE\n\n               PERFORM 0900-TERMINATION\n\n           END-IF\n\n           MOVE FINAL-RETURN-CODE TO RETURN-CODE\n\n           GOBACK\n           .\n\n       0100-INITIALIZATION.\n      **********************\n           PERFORM VARYING KK FROM 1 BY 1\n                   UNTIL KK > PARM-LENGTH\n               IF PARM-PASSED(KK:1) = '('\n                   MOVE KK TO II\n                   MOVE 999 TO KK\n               END-IF\n           END-PERFORM\n           IF KK < 999\n               MOVE PARM-PASSED(1:PARM-LENGTH) TO WS-DSNAME\n               MOVE ' ' TO WS-MEMBER\n           ELSE\n               PERFORM VARYING JJ FROM II BY 1\n                   UNTIL PARM-PASSED(JJ:1) = ')'\n               END-PERFORM\n               MOVE PARM-PASSED(1:II - 1) TO WS-DSNAME\n               MOVE PARM-PASSED(II + 1:JJ - II - 1) TO WS-MEMBER\n           END-IF\n           CALL 'DYNA' USING WS-DSNAME, WS-MEMBER, WS-DDNAME,\n                             WS-DYNA-R15, WS-DYNA-RC, WS-DYNA-WHY\n           IF WS-DYNA-R15 = 0\n               OPEN  INPUT  I\n                     OUTPUT O\n               READ  I INTO WS-INPUT-REC\n                   AT END SET AT-END-OF-FILE TO TRUE\n                   NOT AT END ADD 1 TO NUMBER-RECORDS-READ\n                   END-READ\n           ELSE\n               MOVE WS-DYNA-R15 TO FINAL-RETURN-CODE\n               ACCEPT WEEK-DAY-NUMBER FROM DAY-OF-WEEK\n               ACCEPT YYMMDD FROM DATE\n               ACCEPT HHMM FROM TIME\n               DISPLAY 'PROGRAM STATISTICS:  '\n                   '                         '\n                   WEEK-DAY(WEEK-DAY-NUMBER) ' '\n                   YYMMDD '-' HHMM(1:2) ':' HHMM(3:2)\n               DISPLAY '    PARM LENGTH               = '\n                   PARM-LENGTH\n               IF PARM-LENGTH NOT = 0\n                   DISPLAY '    PARM PASSED TO PROGRAM    = '\n                       PARM-PASSED(1:PARM-LENGTH)\n                   END-IF\n               DISPLAY ' '\n               DISPLAY '    DSNAME                    = '\n                   WS-DSNAME\n               DISPLAY '    MEMBER                    = '\n                   WS-MEMBER\n               DISPLAY '    DDNAME                    = '\n                   WS-DDNAME\n               DISPLAY '    DYNALLOC R15 RETURN VALUE = '\n                   WS-DYNA-R15\n               DISPLAY '    DYNALLOC ERROR CODE       = '\n                   WS-DYNA-RC\n               DISPLAY '    DYNALLOC ERROR REASON     = '\n                   WS-DYNA-WHY\n           END-IF\n           .\n\n       0200-READ-WRITE-LOOP.\n      ***********************\n           MOVE 'Y' TO REWRITE-REC\n           PERFORM 0200-PROCESS\n           IF REWRITE-REC = 'Y'\n               WRITE OUTPUT-REC FROM WS-INPUT-REC\n               ADD 1 TO NUMBER-RECORDS-WRITTEN\n           ELSE\n               ADD 1 TO NUMBER-RECORDS-DELETED\n           END-IF\n           READ  I INTO WS-INPUT-REC\n               AT END SET AT-END-OF-FILE TO TRUE\n               NOT AT END ADD 1 TO NUMBER-RECORDS-READ\n               END-READ\n           .\n\n       0200-PROCESS.\n      ***************\n           CONTINUE\n           .\n\n       0900-TERMINATION.\n      *******************\n           CLOSE I\n                 O\n           ACCEPT WEEK-DAY-NUMBER FROM DAY-OF-WEEK\n           ACCEPT YYMMDD FROM DATE\n           ACCEPT HHMM FROM TIME\n           DISPLAY 'PROGRAM STATISTICS:  '\n               '                         '\n               WEEK-DAY(WEEK-DAY-NUMBER) ' '\n               YYMMDD '-' HHMM(1:2) ':' HHMM(3:2)\n           DISPLAY '    PARM LENGTH               = '\n               PARM-LENGTH\n           IF PARM-LENGTH NOT = 0\n               DISPLAY '    PARM PASSED TO PROGRAM    = '\n                   PARM-PASSED(1:PARM-LENGTH)\n               END-IF\n           DISPLAY ' '\n           DISPLAY '    NUMBER OF RECORDS READ    = '\n               NUMBER-RECORDS-READ\n           DISPLAY '    NUMBER OF RECORDS WRITTEN = '\n               NUMBER-RECORDS-WRITTEN\n           DISPLAY '    NUMBER OF RECORDS UPDATED = '\n               NUMBER-RECORDS-UPDATED\n           DISPLAY '    NUMBER OF RECORDS DELETED = '\n               NUMBER-RECORDS-DELETED\n           DISPLAY '    NUMBER OF RECORDS ADDED   = '\n               NUMBER-RECORDS-ADDED\n           DISPLAY '    NUMBER OF DUPLICATE RECS  = '\n               NUMBER-RECORDS-DUPS\n           CALL 'DYNF' USING WS-DDNAME\n           .\n\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=SYSDA,SPACE=(CYL,(3,3)),\n//             DCB=(BLKSIZE=0,LRECL=80,RECFM=FB)\n//SYSUT1       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT2       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT3       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT4       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT5       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT6       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT7       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//***\n//GO         EXEC     PGM=LOADER,\n//             PARM='MAP,PRINT/-YOUR-SYSLIB-(JOB)',             <***\n//             REGION=4M,COND=(5,LT,C)\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//             DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//SYSLOUT      DD       SYSOUT=*\n//SYSPRINT     DD       SYSOUT=*\n//O            DD       SYSOUT=*\n//SYSOUT       DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DYNF": {"ttr": 21505, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x003\\x003\\x00\\x00\\xc4\\xe8\\xd5\\xc1@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "DYNA"}, "text": "//-YOUR-USERID-D JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//A          EXEC     PGM=ASMA90,REGION=4M\n//SYSLIB       DD       DISP=SHR,DSN=SYS1.MACLIB\n//             DD       DISP=SHR,DSN=-YOUR-SYSLIB-\nDYNF     TITLE 'DYNAMICALLY FREE A DDNAME'\n**********************************************************************\n*   PARAMETERS:\n*      DDNAME             8 BYTES\n**********************************************************************\n         COPY  MACSDYNA\nDYNF     RENTER\n         L     R2,0(R1)\n         ST    R2,DDADDR          DDNAME ADDR\n         SR    R15,R15\n\n         FREE  UNALC,DDN=DDADDR\n\n         REXIT\n\n**       ALLOC MACRO PARAMETERS\n\nDDADDR   DS    A\nDDLEN    DC    H'8'               LENGTH  OF DDNAME (08)\n         LTORG\n         DYNSPACE\n         IEFZB4D0\n         IEFZB4D2\n         END\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//***\n//L          EXEC     PGM=IEWL,COND=(5,LT),\n//             PARM='XREF,LIST,LET,DCBS',\n//             REGION=4M\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,\n//             DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   99070900\n  ENTRY    DYNF\n  NAME     DYNF(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DYNI": {"ttr": 21507, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x008\\x008\\x00\\x00\\xc4\\xe8\\xd5\\xc1@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 56, "newlines": 56, "modlines": 0, "user": "DYNA"}, "text": "//-YOUR-USERID-D JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//A          EXEC     PGM=ASMA90,REGION=4M\n//SYSLIB       DD       DISP=SHR,DSN=SYS1.MACLIB\n//             DD       DISP=SHR,DSN=-YOUR-SYSLIB-\nDYNI     TITLE 'DYNAMICALLY ALLOC INTRDR '\n**********************************************************************\n*  INPUT PARAMETERS ARE:\n*    DDNAME               8 BYTES - ALPHANUMERIC                R2\n*    DYNALLOC R15 R/C     2 BYTES - BINARY                      R3\n*    DYNALLOC RETURN CODE 2 BYTES - BINARY                      R4\n*    DYNALLOC REASON CODE 2 BYTES - BINARY                      R5\n**********************************************************************\n         COPY  MACSDYNA\nDYNI     RENTER\n         LM    R2,R5,0(R1)\n         ST    R2,DDADDR          DDNAME ADDR\n         ALLOC SYSOUT=('A','INTRDR'),DDN=DDADDR\n         DROP  R14\n         USING S99RB,R14\n         STH   R15,0(R3)          SEND BACK DYNALLOC R15 VALUE\n         MVC   0(2,R4),S99ERROR   SEND ERROR REASON CODE BACK\n         MVC   0(2,R5),S99INFO    SEND INFO  REASON CODE BACK\n         REXIT\n\n**       ALLOC MACRO PARAMETERS\n\nDDADDR   DS    A\nDDLEN    DC    H'8'               LENGTH  OF DDNAME (08)\n         LTORG\n         DYNSPACE\n         IEFZB4D0\n         IEFZB4D2\n         END\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//***\n//L          EXEC     PGM=IEWL,\n//             PARM='XREF,LIST,LET,DCBS',\n//             REGION=4M\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,\n//             DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   99071200\n  ENTRY    DYNI\n  NAME     DYNI(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DYNN": {"ttr": 21509, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00x\\x00x\\x00\\x00\\xc4\\xe8\\xd5\\xc1@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 120, "newlines": 120, "modlines": 0, "user": "DYNA"}, "text": "//-YOUR-USERID-D JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//A          EXEC     PGM=ASMA90,REGION=4M\n//SYSLIB       DD       DISP=SHR,DSN=SYS1.MACLIB\n//             DD       DISP=SHR,DSN=-YOUR-SYSLIB-\nDYNN     TITLE 'DYNAMICALLY CREATE A NEW DSN W/ ALL SPECS'\n**********************************************************************\n*  INPUT PARAMETERS ARE:\n*    DATA SET NAME       44 BYTES - ALPHANUMERIC  POINTED TO IN R2\n*    DDNAME               8 BYTES - ALPHANUMERIC                R3\n*    RECFM                2 BYTES - ALPHANUMERIC                R4\n*    LRECL                2 BYTES - BINARY                      R5\n*    BLKSI                2 BYTES - BINARY                      R6\n*    UNIT                 8 BYTES - ALPHANUMERIC                R7\n*    DYNALLOC R15 R/C     2 BYTES - BINARY                      R8\n*    DYNALLOC RETURN CODE 2 BYTES - BINARY                      R9\n*    DYNALLOC REASON CODE 2 BYTES - BINARY                      R10\n**********************************************************************\n         COPY  MACSDYNA\nDYNN     RENTER  BASEREG=R12\n         LM    R2,R10,0(R1)       LOAD REGS FOR ALL PARAMETERS\n\n         ST    R2,DSADDR          DSNAME ADDR FOR ALLOC MACRO\n         ST    R3,DDADDR          DDNAME ADDR\n\n         MVC   RECFM,0(R4)\n         LA    R4,RFLEN           RECFM SET UP\n         CLI   RECFM+1,C' '\n         BNE   RFNOTL1\n         MVC   RFLEN,HW1\n         B     RFOK\nRFNOTL1  EQU   *\n         CLI   RECFM+2,C' '\n         BNE   RFNOTL2\n         MVC   RFLEN,HW2\n         B     RFOK\nRFNOTL2  EQU   *\n         MVC   RFLEN,HW3\nRFOK     EQU   *\n\n         LH    R5,0(R5)           LRECL\n         ST    R5,LRECL\n\n         LH    R6,0(R6)           BLKSI\n         ST    R6,BLKSI\n\n         MVC   UNIT,0(R7)         UNIT SET UP\n         CLC   UNIT,BLANKS\n         BE    UNITDEF\n         LA    R7,8\n         LA    R14,UNIT+7\nUNITLNCK EQU   *\n         CLI   0(R14),C' '\n         BE    UNITDONE\n         BCTR  R14,0\n         BCT   R7,UNITLNCK\nUNITDONE EQU   *\n         STH   R7,UNLEN\nUNITDEF  EQU   *\n\n         ALLOC DSN=DSADDR,DDN=DDADDR,DISP=(NEW,CATLG),                 X\n               UNIT=UNADDR,SPACE=(CYL,(10,10),RLSE),                   X\n               RECFM=(R4),LRECL=LRECL,BLKSIZE=BLKSI\n\n         DROP  R14\n         USING S99RB,R14\n         STH   R15,0(R8)          SEND BACK DYNALLOC R15 VALUE\n         MVC   0(2,R9),S99ERROR   SEND ERROR REASON CODE BACK\n         MVC   0(2,R10),S99INFO   SEND INFO  REASON CODE BACK\n         REXIT\n\n**       ALLOC MACRO PARAMETERS\n\nDSADDR   DS    A\nDSLEN    DC    H'44'              LENGTH  OF DSNAME (44)\n\nDDADDR   DS    A\nDDLEN    DC    H'8'               LENGTH  OF DDNAME (08)\n\nUNADDR   DC    A(UNIT)\nUNLEN    DC    H'5'               LENGTH  OF UNIT\nUNIT     DC    CL8'TEST'\n\nRFLEN    DC    H'0'               LENGTH  OF RECFM  (1,2 OR 3)\nRECFM    DS    CL3\nLRECL    DC    F'80'\nBLKSI    DC    F'0'\n\nHW1      DC    H'1'\nHW2      DC    H'2'\nHW3      DC    H'3'\nBLANKS   DC    CL44' '\n\n         LTORG\n         DYNSPACE\n         IEFZB4D0\n         IEFZB4D2\n         END\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//***\n//L          EXEC     PGM=IEWL,COND=(5,LT),\n//             PARM='XREF,LIST,LET,DCBS',\n//             REGION=4M\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,\n//             DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   99120100\n  ENTRY    DYNN\n  NAME     DYNN(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DYNPLIA": {"ttr": 21512, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xa9\\x00\\xa9\\x00\\x00\\xc4\\xe8\\xd5\\xc1@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 169, "newlines": 169, "modlines": 0, "user": "DYNA"}, "text": "//-YOUR-USERID-D JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  BASIC PL/I TO DYNAMICALLY ALLOCATE A SEQUENTIAL FILE,\n//***  READ AND WRITE IT\n//***\n//C          EXEC     PGM=IEL0AA,REGION=4M,\n//             PARM=('AG,A,NCT,ESD,F(I),NOFLOW,NIS,NOLIST,M,NMI,NEST',\n//             'MAP,OF,OPT(TIME),OP,SZ(MAX),S,STMT,STG,X(F)')\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-PLI-LIB-\n\n BASE:  PROC(PARM) OPTIONS(MAIN) REORDER;\n\n        DECLARE DYNA   ENTRY(CHAR(44),      /* DSNAME            */\n                             CHAR(8),       /* MEMBER            */\n                             CHAR(8),       /* DDNAME            */\n                             FIXED BIN(15), /* DYNALLOC R15 R/C  */\n                             FIXED BIN(15), /* INFO  ERROR  CODE */\n                             FIXED BIN(15)) /* INFO  REASON CODE */\n                       OPTIONS(ASM);\n\n        DECLARE DYNF   ENTRY(CHAR(08) )     /* DDNAME            */\n                       OPTIONS(ASM);\n\n        DCL  PARM      CHAR(00100) VARYING;\n        DCL  REC       CHAR(05120) STATIC VARYING;\n        DCL  OLDREC    CHAR(05120) STATIC VARYING;\n        DCL  I_EOF_IND CHAR(01) STATIC INIT('N');\n        DCL  REWRITE_REC  CHAR(01) STATIC INIT('N');\n\n        DCL  (II,JJ)   FIXED BIN(31) STATIC INIT(0);\n\n        DCL  ADDED#    FIXED BIN(31) STATIC INIT(0);\n        DCL  DELETED#  FIXED BIN(31) STATIC INIT(0);\n        DCL  DUPS#     FIXED BIN(31) STATIC INIT(0);\n        DCL  READ#     FIXED BIN(31) STATIC INIT(0);\n        DCL  UPDATED#  FIXED BIN(31) STATIC INIT(0);\n        DCL  WRITTEN#  FIXED BIN(31) STATIC INIT(0);\n        DCL  DATE      BUILTIN;\n        DCL  TIME      BUILTIN;\n\n        DCL  DSNAME    CHAR(44) STATIC\n                       INIT(' ');\n        DCL  MEMBER    CHAR(08) STATIC INIT(' ');\n        DCL  DDNAME    CHAR(08) STATIC INIT('I');\n        DCL  DYNA_R15  FIXED BIN(15) STATIC INIT(0);\n        DCL  DYNA_RC   FIXED BIN(15) STATIC INIT(0);\n        DCL  DYNA_WHY  FIXED BIN(15) STATIC INIT(0);\n\n\n        IF INDEX(PARM,'(') = 0\n           THEN DO;\n              DSNAME = PARM;\n              MEMBER = ' ';\n              END;\n           ELSE DO;\n              II     = INDEX(PARM,'(');\n              DSNAME = SUBSTR(PARM,1,II-1);\n              JJ     = INDEX(PARM,')');\n              MEMBER = SUBSTR(PARM,II+1,JJ-II-1);\n              END;\n        CALL DYNA(DSNAME,MEMBER,DDNAME,DYNA_R15,DYNA_RC,DYNA_WHY);\n\n        IF DYNA_R15 = 0\n           THEN DO;\n              OPEN FILE(I) INPUT SEQL RECORD TITLE(DDNAME);\n              ON ENDFILE(I) I_EOF_IND = 'Y';\n\n              CALL INITIALIZATION;\n\n              DO WHILE ( I_EOF_IND  = 'N' );\n                 CALL READ_WRITE_LOOP;\n                 END;\n\n              CALL TERMINATION;\n              CALL DYNF(DDNAME);\n              CALL PLIRETC(DYNA_R15);\n              END;\n           ELSE DO;\n              PUT EDIT ( '***  DSNAME:                 ', DSNAME   )\n                       ( SKIP(2), A, A );\n              PUT EDIT ( '***  MEMBER:                 ', MEMBER   )\n                       ( SKIP(2), A, A );\n              PUT EDIT ( '***  DDNAME:                 ', DDNAME   )\n                       ( SKIP(2), A, A );\n              PUT EDIT ( '**************************************' )\n                       ( SKIP(1), A );\n              PUT EDIT ( '***  DYNALLOC R15 RET VALUE: ', DYNA_R15 )\n                       ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n              PUT EDIT ( '***  DYNA ERROR:             ', DYNA_RC  )\n                       ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n              PUT EDIT ( '***  DYNA REASON:            ', DYNA_WHY )\n                       ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n              PUT EDIT ( '**************************************' )\n                       ( SKIP(1), A );\n              CALL PLIRETC(DYNA_R15);\n              END;\n\n\n PROCESS: PROC;\n        /***   ...   ***/\n        END PROCESS;\n\n INITIALIZATION: PROC;\n        READ FILE(I) INTO(REC);\n        END INITIALIZATION;\n\n READ_WRITE_LOOP: PROC;\n        REWRITE_REC = 'Y';\n        READ# = READ# + 1;\n        CALL PROCESS;\n        IF REWRITE_REC = 'Y'\n           THEN DO;\n              WRITE FILE(O) FROM(REC);\n              WRITTEN# = WRITTEN# + 1;\n              END;\n           ELSE DO;\n              DELETED# = DELETED# + 1;\n              END;\n        READ FILE(I) INTO(REC);\n        END READ_WRITE_LOOP;\n\n TERMINATION: PROC;\n        PUT EDIT ( '**************************************' )\n                 ( SKIP(1), A );\n        PUT EDIT ( '***  ', DATE, ' STATISTICS ', TIME, '  ****' )\n                 ( SKIP(1), A, A, A, A, A );\n        PUT EDIT ( '**************************************' )\n                 ( SKIP(1), A );\n        PUT EDIT ( '***  NUMBER RECORDS READ:    ', READ#    )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        PUT EDIT ( '***  NUMBER RECORDS WRITTEN: ', WRITTEN# )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        PUT EDIT ( '***  NUMBER RECORDS UPDATED: ', UPDATED# )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        PUT EDIT ( '***  NUMBER RECORDS ADDED:   ', ADDED#   )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        PUT EDIT ( '***  NUMBER RECORDS DELETED: ', DELETED# )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        PUT EDIT ( '***  NUMBER RECORDS DUPS:    ', DUPS#    )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        IF LENGTH(PARM) > 0\n           THEN DO;\n              PUT EDIT ( '***  PARM LENGTH/PARM ARE:  ',\n                         LENGTH(PARM), '/', PARM )\n                       ( SKIP(2), A, P'ZZ9', A, A  );\n              END;\n        END TERMINATION;\n\n        END BASE;\n\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(CYL,(05,02))\n//***\n//GO         EXEC     PGM=LOADER,\n//             PARM='MAP,PRINT/NOSPIE,NOSTAE/-YOUR-SYSLIB-(TESTIP)',\n//             REGION=4M,COND=(5,LT)\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//             DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//SYSLOUT      DD       SYSOUT=*\n//O            DD       SYSOUT=*,\n//             DCB=(RECFM=F,LRECL=80,BLKSIZE=80)\n//SYSPRINT     DD       SYSOUT=*\n//SYSUDUMP     DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DYNPLII": {"ttr": 21516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00}\\x00}\\x00\\x00\\xd5\\xe8\\xd5\\xc1@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 125, "newlines": 125, "modlines": 0, "user": "NYNA"}, "text": "//-YOUR-USERID-D JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  BASIC PL/I TO DYNAMICALLY ALLOCATE AN INTERNAL READER AND\n//***  SUBMIT A JOB TO IT\n//***\n//C          EXEC     PGM=IEL0AA,REGION=4M,\n//             PARM=('AG,A,NCT,ESD,F(I),NOFLOW,NIS,NOLIST,M,NMI,NEST',\n//             'MAP,OF,OPT(TIME),OP,SZ(MAX),S,STMT,STG,X(F)')\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-PLI-LIB-\n\n BASE:  PROC OPTIONS(MAIN) REORDER;\n\n        DECLARE DYNI   ENTRY(CHAR(8),       /* DDNAME               */\n                             FIXED BIN(15), /* DYNALLOC R15 R/C     */\n                             FIXED BIN(15), /* DYNALLOC ERROR CODE  */\n                             FIXED BIN(15)) /* DYNALLOC REASON CODE */\n                       OPTIONS(ASM);\n\n        DECLARE DYNF   ENTRY(CHAR(08) )     /* DDNAME            */\n                       OPTIONS(ASM);\n\n        DCL  INTRDR    FILE OUTPUT RECORD SEQL\n                       ENV(F,RECSIZE(80),BLKSIZE(80),TOTAL);\n        DCL  REC       CHAR(00080) STATIC;\n        DCL  I_EOF_IND CHAR(01) STATIC INIT('N');\n\n        DCL  READ#     FIXED BIN(31) STATIC INIT(0);\n        DCL  WRITTEN#  FIXED BIN(31) STATIC INIT(0);\n        DCL  DATE      BUILTIN;\n        DCL  TIME      BUILTIN;\n\n        DCL  DDNAME    CHAR(08) STATIC INIT('INTRDR');\n        DCL  DYNA_R15  FIXED BIN(15) STATIC INIT(0);\n        DCL  DYNA_RC   FIXED BIN(15) STATIC INIT(0);\n        DCL  DYNA_WHY  FIXED BIN(15) STATIC INIT(0);\n\n\n        CALL DYNI(DDNAME,DYNA_R15,DYNA_RC,DYNA_WHY);\n\n        IF DYNA_R15 = 0\n           THEN DO;\n\n              ON ENDFILE(I) I_EOF_IND = 'Y';\n\n              READ FILE(I) INTO(REC);\n\n              DO WHILE ( I_EOF_IND  = 'N' );\n                 CALL READ_WRITE_LOOP;\n                 END;\n\n              CALL TERMINATION;\n              CALL DYNF(DDNAME);\n              CALL PLIRETC(DYNA_R15);\n\n              END;\n           ELSE DO;\n              PUT EDIT ( '**************************************' )\n                       ( SKIP(1), A );\n              PUT EDIT ( '***  ', DATE, ' STATISTICS ', TIME, '  ****' )\n                       ( SKIP(1), A, A, A, A, A );\n              PUT EDIT ( '**************************************' )\n                       ( SKIP(1), A );\n              PUT EDIT ( '***  DYNALLOC ERROR  ***'                )\n                       ( SKIP(2), A );\n              PUT EDIT ( '***  DDNAME:                 ', DDNAME   )\n                       ( SKIP(2), A, A );\n              PUT EDIT ( '**************************************' )\n                       ( SKIP(1), A );\n              PUT EDIT ( '***  DYNALLOC R15 RET VALUE: ', DYNA_R15 )\n                       ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n              PUT EDIT ( '***  DYNA ERROR:             ', DYNA_RC  )\n                       ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n              PUT EDIT ( '***  DYNA REASON:            ', DYNA_WHY )\n                       ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n              PUT EDIT ( '**************************************' )\n                       ( SKIP(1), A );\n              CALL PLIRETC(DYNA_R15);\n              END;\n\n\n READ_WRITE_LOOP: PROC;\n        READ# = READ# + 1;\n        WRITE FILE(INTRDR) FROM(REC);\n        WRITTEN# = WRITTEN# + 1;\n        READ FILE(I) INTO(REC);\n        END READ_WRITE_LOOP;\n\n TERMINATION: PROC;\n        PUT EDIT ( '**************************************' )\n                 ( SKIP(1), A );\n        PUT EDIT ( '***  ', DATE, ' STATISTICS ', TIME, '  ****' )\n                 ( SKIP(1), A, A, A, A, A );\n        PUT EDIT ( '**************************************' )\n                 ( SKIP(1), A );\n        PUT EDIT ( '***  NUMBER RECORDS READ:    ', READ#    )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        PUT EDIT ( '***  NUMBER RECORDS WRITTEN: ', WRITTEN# )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        END TERMINATION;\n\n        END BASE;\n\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(CYL,(05,02))\n//***\n//GO         EXEC     PGM=LOADER,\n//             PARM='MAP,PRINT//',\n//             REGION=4M,COND=(5,LT)\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//             DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//SYSLOUT      DD       SYSOUT=*\n//SYSPRINT     DD       SYSOUT=*\n//I            DD       DATA,DLM=XX\n//-YOUR-USERID-D JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//DUMMYPGM   EXEC       PGM=IEFBR14\n//***\nXX\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DYNPLIN": {"ttr": 21519, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xa8\\x00\\xa8\\x00\\x00\\xc4\\xe8\\xd5\\xc1@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 168, "newlines": 168, "modlines": 0, "user": "DYNA"}, "text": "//-YOUR-USERID-D JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  BASIC PL/I TO ALLOCATE A NEW FILE AND WRITE ANOTHER FILE'S\n//***  CONTENT TO IT (AND TO SYSOUT)\n//***\n//CLEANUP    EXEC     PGM=IEFBR14\n//DEL01        DD       DSN=-YOUR-USERID-.$$$TEMP.DYNNTEST,\n//             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n//***\n//C          EXEC     PGM=IEL0AA,REGION=4M,\n//             PARM=('AG,A,NCT,ESD,F(I),NOFLOW,NIS,NOLIST,M,NMI,NEST',\n//             'MAP,OF,OPT(TIME),OP,SZ(MAX),S,STMT,STG,X(F)')\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-PLI-LIB-\n\n BASE:  PROC(PARM) OPTIONS(MAIN) REORDER;\n\n        DECLARE DYNN   ENTRY(CHAR(44),      /* DSNAME            */\n                             CHAR(8),       /* DDNAME            */\n                             CHAR(3),       /* RECORD FORMAT     */\n                             FIXED BIN(15), /* RECORD SIZE       */\n                             FIXED BIN(15), /* BLOCK SIZE        */\n                             CHAR(8),       /* DASD UNIT NAME    */\n                             FIXED BIN(15), /* DYNALLOC R15 R/C  */\n                             FIXED BIN(15), /* INFO  ERROR  CODE */\n                             FIXED BIN(15)) /* INFO  REASON CODE */\n                       OPTIONS(ASM);\n\n        DECLARE DYNF   ENTRY(CHAR(08) )     /* DDNAME            */\n                       OPTIONS(ASM);\n\n        DCL  PARM      CHAR(00100) VARYING;\n        DCL  REC       CHAR(05120) STATIC VARYING;\n        DCL  OLDREC    CHAR(05120) STATIC VARYING;\n        DCL  I_EOF_IND CHAR(01) STATIC INIT('N');\n        DCL  REWRITE_REC  CHAR(01) STATIC INIT('N');\n\n        DCL  ADDED#    FIXED BIN(31) STATIC INIT(0);\n        DCL  DELETED#  FIXED BIN(31) STATIC INIT(0);\n        DCL  DUPS#     FIXED BIN(31) STATIC INIT(0);\n        DCL  READ#     FIXED BIN(31) STATIC INIT(0);\n        DCL  UPDATED#  FIXED BIN(31) STATIC INIT(0);\n        DCL  WRITTEN#  FIXED BIN(31) STATIC INIT(0);\n        DCL  DATE      BUILTIN;\n        DCL  TIME      BUILTIN;\n\n        DCL  DSNAME    CHAR(44) STATIC\n                       INIT(' ');\n        DCL  DDNAME    CHAR(08) STATIC INIT('OO');\n        DCL  RECFM     CHAR(03) STATIC INIT('FB ');\n        DCL  LRECL     FIXED BIN(15) STATIC INIT(00080);\n        DCL  BLKSI     FIXED BIN(15) STATIC INIT(00000);\n        DCL  UNIT      CHAR(08) STATIC INIT('TEST');\n        DCL  DYNN_R15  FIXED BIN(15) STATIC INIT(0);\n        DCL  DYNN_RC   FIXED BIN(15) STATIC INIT(0);\n        DCL  DYNN_WHY  FIXED BIN(15) STATIC INIT(0);\n\n\n        DSNAME = PARM;\n        CALL DYNN( DSNAME, DDNAME, RECFM, LRECL, BLKSI, UNIT,\n           DYNN_R15, DYNN_RC, DYNN_WHY);\n\n        IF DYNN_R15 = 0\n           THEN DO;\n              OPEN FILE(OO) OUTPUT SEQL RECORD TITLE(DDNAME);\n              ON ENDFILE(I) I_EOF_IND = 'Y';\n\n              CALL INITIALIZATION;\n\n              DO WHILE ( I_EOF_IND  = 'N' );\n                 CALL READ_WRITE_LOOP;\n                 END;\n\n              CALL TERMINATION;\n              CALL DYNF(DDNAME);\n              CALL PLIRETC(DYNN_R15);\n\n              END;\n           ELSE DO;\n              PUT EDIT ( '***  DSNAME:                 ', DSNAME   )\n                       ( SKIP(2), A, A );\n              PUT EDIT ( '***  DDNAME:                 ', DDNAME   )\n                       ( SKIP(2), A, A );\n              PUT EDIT ( '**************************************' )\n                       ( SKIP(1), A );\n              PUT EDIT ( '***  DYNALLOC R15 RET VALUE: ', DYNN_R15 )\n                       ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n              PUT EDIT ( '***  DYNA ERROR:             ', DYNN_RC  )\n                       ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n              PUT EDIT ( '***  DYNA REASON:            ', DYNN_WHY )\n                       ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n              PUT EDIT ( '**************************************' )\n                       ( SKIP(1), A );\n              CALL PLIRETC(DYNN_R15);\n              END;\n\n\n PROCESS: PROC;\n        WRITE FILE(OO) FROM(REC);\n        END PROCESS;\n\n INITIALIZATION: PROC;\n        READ FILE(I) INTO(REC);\n        END INITIALIZATION;\n\n READ_WRITE_LOOP: PROC;\n        REWRITE_REC = 'Y';\n        READ# = READ# + 1;\n        CALL PROCESS;\n        IF REWRITE_REC = 'Y'\n           THEN DO;\n              WRITE FILE(O) FROM(REC);\n              WRITTEN# = WRITTEN# + 1;\n              END;\n           ELSE DO;\n              DELETED# = DELETED# + 1;\n              END;\n        READ FILE(I) INTO(REC);\n        END READ_WRITE_LOOP;\n\n TERMINATION: PROC;\n        PUT EDIT ( '**************************************' )\n                 ( SKIP(1), A );\n        PUT EDIT ( '***  ', DATE, ' STATISTICS ', TIME, '  ****' )\n                 ( SKIP(1), A, A, A, A, A );\n        PUT EDIT ( '**************************************' )\n                 ( SKIP(1), A );\n        PUT EDIT ( '***  NUMBER RECORDS READ:    ', READ#    )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        PUT EDIT ( '***  NUMBER RECORDS WRITTEN: ', WRITTEN# )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        PUT EDIT ( '***  NUMBER RECORDS UPDATED: ', UPDATED# )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        PUT EDIT ( '***  NUMBER RECORDS ADDED:   ', ADDED#   )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        PUT EDIT ( '***  NUMBER RECORDS DELETED: ', DELETED# )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        PUT EDIT ( '***  NUMBER RECORDS DUPS:    ', DUPS#    )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        IF LENGTH(PARM) > 0\n           THEN DO;\n              PUT EDIT ( '***  PARM LENGTH/PARM ARE:  ',\n                         LENGTH(PARM), '/', PARM )\n                       ( SKIP(2), A, P'ZZ9', A, A  );\n              END;\n        END TERMINATION;\n\n        END BASE;\n\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(CYL,(05,02))\n//***\n//GO         EXEC     PGM=LOADER,\n//             PARM='MAP,PRINT//-YOUR-USERID-.$$$TEMP.DYNNTEST',\n//             REGION=4M,COND=(5,LT)\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//             DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//SYSLOUT      DD       SYSOUT=*\n//I            DD       DISP=SHR,DSN=-YOUR-SYSLIB-(JOB)\n//O            DD       SYSOUT=*,\n//             DCB=(RECFM=F,LRECL=80,BLKSIZE=80)\n//SYSPRINT     DD       SYSOUT=*\n//SYSUDUMP     DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DYNPLIS": {"ttr": 21764, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00{\\x00{\\x00\\x00\\xc4\\xe8\\xd5\\xc1@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 123, "newlines": 123, "modlines": 0, "user": "DYNA"}, "text": "//-YOUR-USERID-D JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  BASIC PL/I TO DYNAMICALLY ALLOCATE A SYSOUT AND WRITE A\n//***  FILE'S CONTENT TO IT\n//***\n//C          EXEC     PGM=IEL0AA,REGION=4M,\n//             PARM=('AG,A,NCT,ESD,F(I),NOFLOW,NIS,NOLIST,M,NMI,NEST',\n//             'MAP,OF,OPT(TIME),OP,SZ(MAX),S,STMT,STG,X(F)')\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-PLI-LIB-\n\n BASE:  PROC OPTIONS(MAIN) REORDER;\n\n        DECLARE DYNS   ENTRY(CHAR(8),       /* DDNAME               */\n                             CHAR(1),       /* SYSOUT CLASS         */\n                             FIXED BIN(15), /* DYNALLOC R15 R/C     */\n                             FIXED BIN(15), /* DYNALLOC ERROR CODE  */\n                             FIXED BIN(15)) /* DYNALLOC REASON CODE */\n                       OPTIONS(ASM);\n\n        DECLARE DYNF   ENTRY(CHAR(08) )     /* DDNAME            */\n                       OPTIONS(ASM);\n\n        DCL  SYSOUT    FILE OUTPUT RECORD SEQL\n                       ENV(F,RECSIZE(121),BLKSIZE(121),TOTAL);\n        DCL  REC       CHAR(00080) STATIC;\n        DCL  OREC      CHAR(00121) STATIC;\n        DCL  I_EOF_IND CHAR(01) STATIC INIT('N');\n\n        DCL  READ#     FIXED BIN(31) STATIC INIT(0);\n        DCL  WRITTEN#  FIXED BIN(31) STATIC INIT(0);\n        DCL  DATE      BUILTIN;\n        DCL  TIME      BUILTIN;\n\n        DCL  DDNAME    CHAR(08) STATIC INIT('SYSOUT');\n        DCL  SYSCLS    CHAR(01) STATIC INIT('X');\n        DCL  DYNA_R15  FIXED BIN(15) STATIC INIT(0);\n        DCL  DYNA_RC   FIXED BIN(15) STATIC INIT(0);\n        DCL  DYNA_WHY  FIXED BIN(15) STATIC INIT(0);\n\n\n        CALL DYNS(DDNAME,SYSCLS,DYNA_R15,DYNA_RC,DYNA_WHY);\n\n        IF DYNA_R15 = 0\n           THEN DO;\n              ON ENDFILE(I) I_EOF_IND = 'Y';\n\n              READ FILE(I) INTO(REC);\n              DO WHILE ( I_EOF_IND  = 'N' );\n                 CALL READ_WRITE_LOOP;\n                 END;\n\n              CALL TERMINATION;\n              CALL DYNF(DDNAME);\n              CALL PLIRETC(DYNA_R15);\n\n              END;\n           ELSE DO;\n              PUT EDIT ( '**************************************' )\n                       ( SKIP(1), A );\n              PUT EDIT ( '***  ', DATE, ' STATISTICS ', TIME, '  ****' )\n                       ( SKIP(1), A, A, A, A, A );\n              PUT EDIT ( '**************************************' )\n                       ( SKIP(1), A );\n              PUT EDIT ( '***  DYNALLOC ERROR  ***'                )\n                       ( SKIP(2), A );\n              PUT EDIT ( '***  DDNAME:                 ', DDNAME   )\n                       ( SKIP(2), A, A );\n              PUT EDIT ( '***  SYSOUT CLASS:           ', SYSCLS   )\n                       ( SKIP(2), A, A );\n              PUT EDIT ( '**************************************' )\n                       ( SKIP(1), A );\n              PUT EDIT ( '***  DYNALLOC R15 RET VALUE: ', DYNA_R15 )\n                       ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n              PUT EDIT ( '***  DYNA ERROR:             ', DYNA_RC  )\n                       ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n              PUT EDIT ( '***  DYNA REASON:            ', DYNA_WHY )\n                       ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n              PUT EDIT ( '**************************************' )\n                       ( SKIP(1), A );\n              CALL PLIRETC(DYNA_R15);\n              END;\n\n\n READ_WRITE_LOOP: PROC;\n        READ# = READ# + 1;\n        OREC = ' ' || REC;\n        WRITE FILE(SYSOUT) FROM(OREC);\n        WRITTEN# = WRITTEN# + 1;\n        READ FILE(I) INTO(REC);\n        END READ_WRITE_LOOP;\n\n TERMINATION: PROC;\n        PUT EDIT ( '**************************************' )\n                 ( SKIP(1), A );\n        PUT EDIT ( '***  ', DATE, ' STATISTICS ', TIME, '  ****' )\n                 ( SKIP(1), A, A, A, A, A );\n        PUT EDIT ( '**************************************' )\n                 ( SKIP(1), A );\n        PUT EDIT ( '***  NUMBER RECORDS READ:    ', READ#    )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        PUT EDIT ( '***  NUMBER RECORDS WRITTEN: ', WRITTEN# )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        END TERMINATION;\n\n        END BASE;\n\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(CYL,(05,02))\n//***\n//GO         EXEC     PGM=LOADER,\n//             PARM='MAP,PRINT//',\n//             REGION=4M,COND=(5,LT)\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//             DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//SYSLOUT      DD       SYSOUT=*\n//SYSPRINT     DD       SYSOUT=*\n//I            DD       DISP=SHR,DSN=-YOUR-SYSLIB-(TESTIP)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DYNS": {"ttr": 21767, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00=\\x00=\\x00\\x00\\xc4\\xe8\\xd5\\xc1@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 61, "newlines": 61, "modlines": 0, "user": "DYNA"}, "text": "//-YOUR-USERID-D JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//A          EXEC     PGM=ASMA90,REGION=4M\n//SYSLIB       DD       DISP=SHR,DSN=SYS1.MACLIB\n//             DD       DISP=SHR,DSN=-YOUR-SYSLIB-\nDYNS     TITLE 'DYNAMIC ALLOCATION FOR SYSOUT'\n**********************************************************************\n*  INPUT PARAMETERS ARE:\n*    DDNAME               8 BYTES - ALPHANUMERIC                R2\n*    SYSOUT CLASS         1 BYTE  - ALPHANUMERIC                R3\n*    DYNALLOC R15 R/C     2 BYTES - BINARY                      R4\n*    DYNALLOC RETURN CODE 2 BYTES - BINARY                      R5\n*    DYNALLOC REASON CODE 2 BYTES - BINARY                      R6\n**********************************************************************\n         COPY  MACSDYNA\nDYNS     RENTER\n         LM    R2,R6,0(R1)\n         ST    R2,DDADDR           DDNAME\n         ST    R3,SADDR            SYSOUT CLASS\n         ALLOC SYSOUT=SADDR,DDN=DDADDR\n\n         DROP  R14\n         USING S99RB,R14\nCHECKOUT STH   R15,0(R4)          SEND BACK DYNALLOC R15 VALUE\n         MVC   0(2,R5),S99ERROR   SEND ERROR REASON CODE BACK\n         MVC   0(2,R6),S99INFO    SEND INFO  REASON CODE BACK\n         REXIT\n\n**       ALLOC MACRO PARAMETERS\n\nDDADDR   DS    A\nDDLEN    DC    H'8'\nSADDR    DS    A\nSLEN     DC    H'1'\n         LTORG\n         DYNSPACE\n         IEFZB4D0\n         IEFZB4D2\n         END\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//***\n//L          EXEC     PGM=IEWL,\n//             PARM='XREF,LIST,LET,DCBS',\n//             REGION=4M\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,\n//             DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   99070900\n  ENTRY    DYNS\n  NAME     DYNS(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EMPTY": {"ttr": 21769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00-\\x00-\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- EMPTY FILE OR PDS (UNDER ISPF OPTION 3.4)  **/\n   SAVEMSG = MSG(\"OFF\")\n   PARSE ARG ZINPDSN\n   IF SUBSTR(ZINPDSN,1,1) = '?' THEN SIGNAL DISPDOC\n   LDSI = LISTDSI(ZINPDSN DIRECTORY)\n   IF SYSDSORG = \"PS\"\n      THEN DO\n         \"ALLOC DD(ZAPFILE)  DSN(\"ZINPDSN\") SHR REUSE\"\n         \"EXECIO 0 DISKW\" ZAPFILE \"(OPEN\"\n         \"EXECIO 0 DISKW\" ZAPFILE \"(FINIS\"\n         FINPDSN = LEFT(SUBSTR(ZINPDSN,2,LENGTH(ZINPDSN)-2),44)\n         SAY FINPDSN \"EMPTIED...\"\n      END\n   ELSE IF SYSDSORG = \"PO\" THEN DO\n      ZNEWDSN = \"'\"USERID()\".$$$TEMP.NEWDSN.S\"TIME('S')\"'\"\n      \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\"\n      \"DELETE\" ZINPDSN\n      \"RENAME\" ZNEWDSN ZINPDSN\n      FINPDSN = LEFT(SUBSTR(ZINPDSN,2,LENGTH(ZINPDSN)-2),44)\n      SAY FINPDSN \"EMPTIED...\"\n   END\n   ELSE DO\n      SAY FINPDSN \"CAN'T HANDLE DATA SET ORG\" SYSDSORG\n   END\n   EXIT(1)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"EMPTY -- DELETE ALL DATA OR MEMBERS FROM DS LIST FILE     \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    EMPTY                                                 \"\n   SAY\n   SAY \"       DELETE ALL DATA FROM SEQUENTIAL FILE SPECIFIED IN  \"\n   SAY \"       ISPF DS LIST (SIMPLY OPENS AND CLOSES THE FILE).   \"\n   SAY\n   SAY \"       CREATES A TEMPORARY PDS WITH SAME ATTRIBUTES AS    \"\n   SAY \"       SPECIFIED PDS (OBVIOUSLY WITH NO MEMBERS), DELETES \"\n   SAY \"       ORIGINAL PDS AND RENAMES TEMPORARY PDS TO OLD NAME.\"\n   SAY\n   SAY \"       CAUSES DS LIST SCREEN TO BE REFRESHED.             \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EMPTYCK$": {"ttr": 21771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\t\\x00\\t\\x00\\x00\\xc9\\xc4\\xc3\\xc1\\xd4\\xe2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "IDCAMS"}, "text": "//*********************************************************************\n//*  SETS RC=0000 IF DATASET HAS RECORDS                              *\n//*  SETS RC=0004 IF DATASET IS EMPTY                                 *\n//*********************************************************************\n//STEP0200   EXEC     PGM=IDCAMS\n//SYSPRINT     DD       SYSOUT=*\n//MYFILE       DD       DISP=SHR,DSN=...\n  PRINT  INFILE(MYFILE)  CHARACTER  COUNT(1)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENC": {"ttr": 21773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x006\\x006\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- REXX EDIT MACRO TO ENCRYPT/DECRYPT FILES **/\n    address ISREDIT\n    \"MACRO (pswd)\"\n    if pswd = \"\" then signal DispDoc\n    else do\n       brkr = 0\n       do i = 1 to length(pswd)\n          brkr = brkr + index(xrange('00'x,'ff'x),substr(pswd,i,1))\n       end i\n       ovly = 'a5o1fBv>uq2Mwyc09eX|(,t8GK.3pQD_L:4ZESg.P{87Jm\"s0=',\n           || 'GTF+Wb9*q!@AtSbnO0%r;M},4jx&C0s)8>`-Y7k#|Z^a\u00acvnxe=',\n           || 'y\u00aci`uB/I0w#r{(zH~.C6?TP_l+8AUz/*NhW^>0R/Hf0-:dhD4~',\n           || '0Q3oJKV4l;V%$7?XR\"NcO}5m1FY)I~i96gEp&d@80Ljk8U72!$'\n       pswd = reverse(pswd || reverse(pswd)) || pswd || reverse(pswd)\n    end\n    \"(STATUS) = USER_STATE\"\n    \"(lrecl) = LRECL\"\n    \"(recfm) = RECFM\"\n    if index(recfm,'F') = 0 then signal dispdoc\n    \"AUTOSAVE OFF\"\n    \"CAPS OFF\"\n    pswd    = substr(copies(pswd,length(pswd) % lrecl + 1),1,lrecl)\n    ovly    = substr(copies(ovly,length(ovly) % lrecl + 1),1,lrecl)\n    \"(n) = LINENUM .ZLAST\"\n    do i = 1 to n\n       \"(x) = LINE\" i\n       lbrk = brkr\n       brkr = (brkr*(n+13)+i) // lrecl\n       if brkr = 0    then brkr = ((i*19)+29+i) // lrecl\n       if brkr = lbrk then brkr = (brkr*43*i+i) // lrecl\n       ovly = substr(ovly,brkr,length(ovly)-brkr+1),\n          || substr(ovly,1,brkr-1)\n       x    = bitxor(bitxor(bitxor(x,ovly),pswd,'a5'x),,'5a'x)\n       \"LINE \"i\" = (x)\"\n    end i\n    \"USER_STATE = (STATUS)\"\n    exit 0\n\nDispDoc:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"ENC  -  Encrypt & Decrypt entire file of fixed RECFM   \"\n   SAY\n   SAY \"  ENC   password                                       \"\n   SAY\n   SAY \"  Passwords can be any length. When first invoked,     \"\n   SAY \"  the password encrypts the file. When re-invoked      \"\n   SAY \"  using the same password, the file is decrypted.      \"\n   SAY \"  The file must be fixed record format.                \"\n   SAY\n   SAY \"  Caution should be used to remember the password      \"\n   SAY \"  since it may be difficult to recreate the file       \"\n   SAY \"  without the correct password.                        \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ENC2": {"ttr": 21775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00:\\x00:\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 58, "newlines": 58, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- REXX EDIT MACRO TO ENCRYPT/DECRYPT FILES **/\n    address ISREDIT\n    \"MACRO (pswd)\"\n    if pswd = \"\" then signal DispDoc\n    \"(STATUS) = USER_STATE\"\n    \"(lrecl) = LRECL\"\n    \"AUTOSAVE OFF\"\n    \"CAPS OFF\"\n    brkr = 0\n    do i = 1 to length(pswd)\n       brkr = brkr + index(xrange('00'x,'ff'x),substr(pswd,i,1))\n    end i\n    ovly = 'AAABACADAEAFA0A1A2A3A4A5A6A7A8A9'x,\n        || 'BABBBCBDBEBFB0B1B2B3B4B5B6B7B8B9'x,\n        || 'CACBCCCDCECFC0C1C2C3C4C5C6C7C8C9'x,\n        || 'DADBDCDDDEDFD0D1D2D3D4D5D6D7D8D9'x,\n        || 'EAEBECEDEEEFE0E1E2E3E4E5E6E7E8E9'x,\n        || 'FAFBFCFDFEFFF0F1F2F3F4F5F6F7F8F9'x,\n        || '0A0B0C0D0E0F00010203040506070809'x,\n        || '1A1B1C1D1E1F10111213141516171819'x,\n        || '2A2B2C2D2E2F20212223242526272829'x,\n        || '3A3B3C3D3E3F30313233343536373839'x,\n        || '4A4B4C4D4E4F40414243444546474849'x,\n        || '5A5B5C5D5E5F50515253545556575859'x,\n        || '6A6B6C6D6E6F60616263646566676869'x,\n        || '7A7B7C7D7E7F70717273747576777879'x,\n        || '8A8B8C8D8E8F80818283848586878889'x,\n        || '9A9B9C9D9E9F90919293949596979899'x\n    \"(n) = LINENUM .ZLAST\"\n    offs = random(1,256,brkr)\n    do i = 1 to n\n       \"(x) = LINE\" i\n       linesz = length(x)\n       ovly = substr(ovly,offs) || substr(ovly,1,offs-1)\n       tpswd  = substr(copies(pswd,length(pswd) % linesz + 1),1,linesz)\n       tovly  = substr(copies(ovly,length(ovly) % linesz + 1),1,linesz)\n       x      = bitxor(bitxor(x,tovly),tpswd)\n       \"LINE \"i\" = (x)\"\n       offs = random(1,256)\n    end i\n    \"USER_STATE = (STATUS)\"\n    exit 0\n\nDispDoc:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"ENC  -  Encrypt & Decrypt entire file of any RECFM     \"\n   SAY\n   SAY \"  ENC   password                                       \"\n   SAY\n   SAY \"  Passwords can be any length. When first invoked,     \"\n   SAY \"  the password encrypts the file. When re-invoked      \"\n   SAY \"  using the same password, the file is decrypted.      \"\n   SAY\n   SAY \"  Caution should be used to remember the password      \"\n   SAY \"  since it may be difficult to recreate the file       \"\n   SAY \"  without the correct password.                        \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EZCKGRDT": {"ttr": 21777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00>\\x00>\\x00\\x00\\xc5\\xe9@@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 62, "newlines": 62, "modlines": 0, "user": "EZ"}, "text": "//-YOUR-USERID-G JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  GREGORIAN DATE CHECK\n//***\n//EZ         EXEC     PGM=EZTPA00,REGION=8M\n//EZTVFM       DD       UNIT=SYSDA,SPACE=(CYL,(20,20))\n//SYSOUT       DD       SYSOUT=*\n//SYSPRINT     DD       SYSOUT=*\n//SYSIN        DD       *\nFILE INFILE\n     DT         13  10  A\n         CCYY   13   4  N\n         YY     15   2  N\n         MM     18   2  N\n         DD     21   2  N\n*\nFILE BADDATES PRINTER\n*\n     YYYY-4      W   4  N\n     YYYY-400    W   4  N\n*\nJOB  INPUT  INFILE\n     IF CCYY NUMERIC\n         YYYY-4           = CCYY / 4\n         YYYY-400         = CCYY / 400\n     END-IF\n     IF CCYY NOT NUMERIC                                  +\n             OR MM NOT NUMERIC                            +\n             OR DD NOT NUMERIC                            +\n             OR MM < 00 OR MM > 12                        +\n             OR ( MM = 01 03 05 07 08 10 12               +\n                 AND ( DD < 01 OR DD > 31 ) )             +\n             OR ( MM = 04 06 09 11                        +\n                 AND ( DD < 01 OR DD > 30 ) )             +\n             OR ( MM = 02                                 +\n                 AND ( DD < 01 OR DD > 29 ) )             +\n             OR ( MM = 02                                 +\n                 AND YY NE 00                             +\n                 AND ( CCYY NE ( YYYY-4 * 4 ) )           +\n                 AND DD = 29 )                            +\n             OR ( MM = 02                                 +\n                 AND YY EQ 00                             +\n                 AND ( CCYY NE ( YYYY-400 * 400 ) )       +\n                 AND DD = 29 )\n         DISPLAY  BADDATES 'BAD DATE IN RECORD'           +\n                  RECORD-COUNT '-->' DT '<--'\n     END-IF\n*\n//INFILE       DD       *\n            0001-01-01\n            1941-12-07\n            1996-02-29\n>           1999-02-29\n            1999-12-31\n>           1999-12-32\n            2000-01-01\n            2000-02-29\n>           2001-02-29\n            9999-12-31\n//BADDATES     DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EZCKJUDT": {"ttr": 22017, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x006\\x006\\x00\\x00\\xc5\\xe9@@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "EZ"}, "text": "//-YOUR-USERID-H JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  JULIAN DATE CHECK\n//***\n//EZ         EXEC     PGM=EZTPA00,REGION=8M\n//EZTVFM       DD       UNIT=SYSDA,SPACE=(CYL,(20,20))\n//SYSOUT       DD       SYSOUT=*\n//SYSPRINT     DD       SYSOUT=*\n//SYSIN        DD       *\nFILE INFILE\n     DT         13   7  A\n         CCYY   13   4  N\n         YY     15   2  N\n         DDD    17   3  N\n*\nFILE BADDATES PRINTER\n*\n     YYYY-4      W   4  N\n     YYYY-400    W   4  N\n*\nJOB  INPUT  INFILE\n     IF CCYY NUMERIC\n         YYYY-4           = CCYY / 4\n         YYYY-400         = CCYY / 400\n     END-IF\n     IF CCYY NOT NUMERIC                                  +\n             OR DDD NOT NUMERIC                           +\n             OR DDD < 001                                 +\n             OR DDD > 366                                 +\n             OR ( DDD = 366                               +\n                 AND YY NE 00                             +\n                 AND ( CCYY NE ( YYYY-4 * 4 ) ) )         +\n             OR ( DDD = 366                               +\n                 AND YY EQ 00                             +\n                 AND ( CCYY NE ( YYYY-400 * 400 ) ) )\n         DISPLAY  BADDATES 'BAD DATE IN RECORD'           +\n                  RECORD-COUNT '-->' DT '<--'\n     END-IF\n*\n//INFILE       DD       *\n            0001001\n            1813000\n            1941341\n            1996366\n>           1999366\n            1999365\n>           1999377\n            2000001\n            2000366\n>           2001366\n            9999365\n//BADDATES     DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EZCL": {"ttr": 22019, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x16\\x00\\x16\\x00\\x00\\xc5\\xe9@@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "EZ"}, "text": "//-YOUR-USERID-B JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  LINK AN EASYTRIEVE PROGRAM\n//***\n//EZ         EXEC     PGM=EZTPA00,REGION=8M\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//EZTVFM       DD       UNIT=SYSDA,SPACE=(CYL,(020,020))\n//SYSOUT       DD       SYSOUT=*\n//SYSPRINT     DD       SYSOUT=*\n//SYSIN        DD       *\nPARM LINK (EZ?????  R)\n*\n   EASYTRIEVE CODE GOES HERE...\n*\n//***\n//LINKEDIT   EXEC     LKED,\n//      PARM.LKED='MAP,XREF,LIST,XREF'\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//SYSLMOD      DD       DISP=SHR,DSN=-YOUR-LOADLIB-(EXPKDCK)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EZCOPY": {"ttr": 22021, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\"\\x00\"\\x00\\x00\\xc5\\xe9@@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "EZ"}, "text": "//-YOUR-USERID-C JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  SIMPLE COPY\n//***\n//CLEANUP    EXEC     PGM=IEFBR14\n//DEL01        DD       DSN=...,\n//             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n//***\n//EZ         EXEC     PGM=EZTPA00,REGION=8M\n//I            DD       DISP=SHR,DCB=BUFNO=64,\n//             DSN=...\n//O            DD       DISP=(,CATLG),\n//             DSN=...,\n//             UNIT=SYSDA,SPACE=(CYL,(154,010),RLSE),\n//             DCB=(...)\n//EZTVFM       DD       UNIT=SYSDA,SPACE=(CYL,(20,20))\n//SYSOUT       DD       SYSOUT=*\n//SYSPRINT     DD       SYSOUT=*\n//SYSIN        DD       *\n*\nFILE I\n     FL1        61   1  A\n     FL2        61   3  A\n*\nFILE O\n*\nJOB  INPUT  I\n     IF FL1 = '\\'\n        MOVE 'WT1' TO FL2\n     END-IF\n     PUT O FROM I\n*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EZCOUNT": {"ttr": 22023, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc5\\xe9@@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "EZ"}, "text": "//-YOUR-USERID-C JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  SIMPLE COUNT\n//***\n//EZ         EXEC     PGM=EZTPA00,REGION=8M\n//I            DD       DISP=SHR,DCB=BUFNO=60,\n//             DSN=...\n//SYSPRINT     DD       SYSOUT=*\n//SYSIN        DD       *\n*\nFILE SYSOUT    PRINTER\n*\nFILE I\n     FIELD       1   1  A\n*\n     REC-CNT     W   6  P  VALUE 0  MASK 'ZZ,ZZZ,ZZZ,ZZ9'\n*\nJOB  INPUT  I         FINISH ENDITALL\n     REC-CNT = REC-CNT + 1\n*\nENDITALL.  PROC\n     DISPLAY SYSOUT    '***  NUMBER OF RECORDS IN FILE IS ' REC-CNT\nEND-PROC\n*\n//SYSOUT       DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EZGENRPT": {"ttr": 22025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00{\\x00{\\x00\\x00\\xc5\\xe9@@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 123, "newlines": 123, "modlines": 0, "user": "EZ"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "EZPARM": {"ttr": 22028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x19\\x00\\x19\\x00\\x00\\xc5\\xe9@@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "EZ"}, "text": "//-YOUR-USERID-P JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  PASS PARM TO EASYTRIEVE PROGRAM\n//***\n//EZ         EXEC     PGM=EZTPA00,REGION=8M,PARM='--- PARM DATA ---'\n//EZTVFM       DD       UNIT=SYSDA,SPACE=(CYL,(20,20))\n//SYSPRINT     DD       SYSOUT=*\n//SYSIN        DD       *\n*\nFILE SYSOUT   PRINTER\n*\n*\n     JCL-PARM         W             102  A\n        JCL-PARM-LEN  JCL-PARM        2  B\n        JCL-PARM-DATA JCL-PARM  +2  100  A\n*\nJOB  INPUT  NULL\n     CALL EZTPX01 USING ( PARM-REGISTER JCL-PARM )\n     DISPLAY SYSOUT '***  PARM PASSED WAS ' JCL-PARM-LEN +\n                    '/' JCL-PARM-DATA\n     STOP\n*\n//***\n//SYSOUT       DD       SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EZSTRSK": {"ttr": 22030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00-\\x00-\\x00\\x00\\xc5\\xe9@@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "EZ"}, "text": "//-YOUR-USERID-ES JOB (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//EZ         EXEC     PGM=EZTPA00,REGION=8M\n//EZTVFM       DD       UNIT=SYSDA,SPACE=(CYL,(20,20))\n//SYSOUT       DD       SYSOUT=*\n//SYSPRINT     DD       SYSOUT=*\n//PANDD        DD       DISP=SHR,DSN=-YOUR-SYSLIB-\n//I            DD       DISP=SHR,DSN=...\nFILE I\n     IDATA      1  .....  A HEADING('INPUT DATA')\n*\nFILE STRFND   PRINTER\n*\nSTR2BFND W  ....  A VALUE ' DISPLAY '\nPOSNO    W     5  N 0 VALUE 0         HEADING('COLUMN' 'FOUND')\nFND-CNT  W     5  N 0 VALUE 0\n*\nJOB  INPUT  I  FINISH END-IT-ALL\n     %STRSRCH  STR2BFND  ....  IDATA  .....  POSNO\n     IF POSNO > 0\n          PRINT  GEN-RPT\n          FND-CNT = FND-CNT + 1\n     END-IF\n*\nEND-IT-ALL. PROC\n      DISPLAY STRFND '*******************************************'\n      DISPLAY STRFND '***  # LINES W/ STRING FOUND = ' FND-CNT '  ***'\n      DISPLAY STRFND '*******************************************'\nEND-PROC\n*\nREPORT  GEN-RPT                              +\n        LINESIZE 120                         +\n        PAGESIZE 050                         +\n        SKIP       0                         +\n        SPACE      4                         +\n        TITLESKIP  2                         +\n        PRINTER    STRFND                    +\n        NOADJUST\n     TITLE 01  COL 25  '   S T R I N G   S E A R C H   '\n     TITLE 02  COL 25  '==============================='\n     LINE  01  POSNO  IDATA\n*\n//STRFND       DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EZUNPK": {"ttr": 22032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00'\\x00'\\x00\\x00\\xc5\\xe9@@@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "EZ"}, "text": "//-YOUR-USERID-C JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  UNPACK DATA INTO SAME COLUMNS CHECKING FOR OVERFLOW\n//***\n//CLEANUP    EXEC     PGM=IEFBR14\n//DEL01        DD       DSN=...,\n//             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n//***\n//EZ         EXEC     PGM=EZTPA00,REGION=8M\n//EZTVFM       DD       UNIT=SYSDA,SPACE=(CYL,(20,20))\n//SYSOUT       DD       SYSOUT=*\n//SYSPRINT     DD       SYSOUT=*\n//INFILE       DD       DISP=SHR,DSN=...\n//OUTFILE      DD       DSN=...,\n//             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(05,02),RLSE)\n*\nFILE I\n     DATA        1 120  A\n     PKED       43  10  P\n*\nFILE O        FB(00120 27960)\n     DATA        1 120  A\n     UNPKED     43  10  N\n*\nFILE OVFLOW   PRINTER\n*\nJOB  INPUT  I\n     O:DATA = I:DATA\n     UNPKED = PKED\n     IF PKED > 9999999999\n        DISPLAY OVFLOW '**  PROBLEM - RECORD ' RECORD-COUNT +\n           ' IS BIGGER THAN THE RECEIVING FIELD (' +\n           PKED ')'\n     END-IF\n     PUT O\n*\n//OVFLOW       DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FALT": {"ttr": 22034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00'\\x00'\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- REPEAT COMMAND FOR ALTERNATE \"FIND\"S         **/\n/**          INVOKE VGET'D FALTNM WITH PARAMETER -=PFK=-  **/\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'FALT MUST BE RUN UNDER ISPF EDIT!'\n      EXIT\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT \"ISREDIT MACRO (PARMS) NOPROCESS\"\n      IF PARMS = \"?\" THEN SIGNAL DISPDOC\n      ADDRESS ISPEXEC \"VGET (FALTNM) SHARED\"\n      ADDRESS ISREDIT \"%\"FALTNM \"-=PFK=-\"\n   END\n   RETURN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"FALT - MACRO TO DO PSEUDO REPEAT FINDS                    \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    FALT                                                  \"\n   SAY\n   SAY \"       FALT IS A DUMMY MACRO. ASSIGNED TO A PF KEY IT WILL\"\n   SAY \"       REPEAT THE LAST FEXC, FGE, FGT, FLE, FLT, FMAX,    \"\n   SAY \"       FMIN, FN OR FPEND COMMAND.  IT PASSES A DUMMY      \"\n   SAY \"       PARAMETER OF -=PFK=- TO THE LAST COMMAND EXECUTED  \"\n   SAY \"       AND THE COMMAND WILL PULL THE NECESSARY PARAMETERS \"\n   SAY \"       FROM THE SHARED POOL. IT ALWAYS REPEATS THE LAST   \"\n   SAY \"       OF THE ABOVE EXECUTED FIND COMMANDS.               \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FAND": {"ttr": 22036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\xcb\\x00\\xcb\\x00\\x00\\xc3\\xd3\\xc9\\xe2\\xe3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 203, "newlines": 203, "modlines": 0, "user": "CLIST"}, "text": "            CONTROL ASIS\n /*  TITLE:       FAND    -- EXCLUDE EVERYTHING AND THEN     */\n /*                          FIND AND DISPLAY EVERY LINE     */\n /*                          WITH EVERY SPECIFIED STRING     */\n /*  ENTRY:       USED AS AN EDIT CLIST WITHIN ISPF EDIT     */\n /*  EXAMPLE:    ===> FAND     'A' B 'C'                     */\n /*  OPTIONS:                                                */\n /*      LBL-RANGE  (OPTIONAL)  LABEL  RANGE                 */\n /*      NX | X     (OPTIONAL)  LIMIT TO EXCLUDED OR NOT     */\n /*      <LIST>     (REQUIRED)  STRINGS SUITABLE FOR A FIND  */\n   ISREDIT  MACRO (TOK1,TOK2,TOK3,TOK4,TOK5,TOK6,TOK7,TOK8,TOK9,TOK10,+\n          TOK11,TOK12,TOK13,+\n          TOK14,TOK15,TOK16,TOK17,TOK18,TOK19,TOK20,TOK21,TOK22,TOK23,+\n          TOK24,TOK25,TOK26,+\n          TOK27,TOK28,TOK29,TOK30,TOK31,TOK32,TOK33,TOK34,TOK35,TOK36,+\n          TOK37,TOK38,TOK39,+\n          TOK40,TOK41,TOK42,TOK43,TOK44,TOK45,TOK46,TOK47,TOK48)\n   ISREDIT (IMAC) = IMACRO\n   SET R  = 0\n   SET SETX  = 0\n   SET SETNX  = 0\n   SET I = 1\n   DO WHILE &I <= 48\n      SET TOKEN = &&TOK&I\n      SET TOKEN = &STR(&SYSCAPS(&TOKEN))\n      IF &STR(&TOKEN) = &STR() THEN GOTO END_TOK\n      IF ALL = &STR(&TOKEN)  |  NEXT = &STR(&TOKEN)  |  FIRST =       +\n         &STR(&TOKEN)  |  LAST = &STR(&TOKEN)  |  PREV = &STR(&TOKEN) +\n            THEN DO\n               SET &ZEDSMSG = &STR(&TOKEN INVALID)\n               SET &ZEDLMSG = &STR(\"&TOKEN\" NOT PROVIDED FOR +\n                  NOR ARE NEXT, ALL, FIRST, LAST OR PREV)\n               ISPEXEC   SETMSG MSG(ISRZ000)\n               EXIT CODE(12)\n            END\n      IF &SUBSTR(1:6,&STR(&TOKEN)       ) = &STR(BEGIN&STR(&LP))  +\n         THEN DO\n            SET BEGIN = &SUBSTR(7:&EVAL(&LENGTH(&STR(&TOKEN))-1), +\n               &STR(&TOKEN)         )\n             GOTO NXT_TOK\n         END\n      IF &STR(&TOKEN) = NX THEN DO\n         SET NX = NX\n         GOTO NXT_TOK\n      END\n      IF &STR(&TOKEN) = X THEN DO\n         SET X = X\n         GOTO NXT_TOK\n      END\n      IF &STR(&TOKEN) = WORD | &STR(&TOKEN) = CHAR | &STR(&TOKEN) = +\n            CHARS | &STR(&TOKEN) = PREFIX | &STR(&TOKEN) = SUFFIX +\n         THEN DO\n            IF &STR(&WORD) \u00ac= &STR() THEN DO\n               SET &ZEDSMSG = &STR(INCONSISTENT PARAMETERS)\n               SET &ZEDLMSG = &STR('&WORD' AND '&TOKEN' CANNOT BOTH BE +\n                  SPECIFIED FOR XEVERY CMD.)\n               ISPEXEC     SETMSG MSG(ISRZ000)\n            END\n            SET WORD = &STR( &TOKEN.)\n            GOTO NXT_TOK\n      END\n      IF &STR(&TOKEN) = LEFT THEN DO        /* LEFT | RIGHT */\n         SET LEFT = LEFT\n         GOTO NXT_TOK\n      END\n      IF &STR(&TOKEN) = RIGHT THEN DO\n         SET RIGHT = RIGHT\n         GOTO NXT_TOK\n      END\n      IF &SUBSTR(1,&TOKEN) = &STR(.) THEN DO\n         IF &LABF = &STR() THEN DO\n            SET LABF = &STR(&TOKEN)\n            GOTO NXT_TOK\n         END\n         IF &STR(&LABL) = &STR() THEN DO\n            SET LABL = &STR(&TOKEN)\n            GOTO NXT_TOK\n         END\n         SET &ZEDSMSG = &STR(LABEL &STR(&TOKEN))\n         SET &ZEDLMSG = &STR(EXACTLY TWO LABELS ARE REQUIRED FOUND +\n            \"&LABF\", \"&LABL\" AND  \"&STR(&TOKEN)\")\n         ISPEXEC   SETMSG MSG(ISRZ000)\n         EXIT CODE(12)\n      END\n      IF &STR(&TOKEN) = &STR()) THEN DO\n         SET &ZEDSMSG = &STR(LOST PARENTHESIS)\n         SET &ZEDLMSG = BLANKS SEPARATE ALL OPERANDS; THEREFORE +\n            INVALID IN FROM() TO() COL() BEGIN()\n         ISPEXEC SETMSG MSG(ISRZ000)\n         EXIT CODE(12)\n      END\n      SET REMAIN = &STR(&REMAIN &STR(&TOKEN))\n      SET R = &R + 1\n      SET FIND&R = &STR(&TOKEN)\n NXT_TOK: -\n      SET I = &I + 1\n   END\n\n END_TOK: SET I = &I\n   SET RMAX = &R\n   IF &STR(&FIND1) = &STR() THEN DO\n      SET &ZEDSMSG = &STR(FIND STRINGS)\n      SET &ZEDLMSG = &STR(&ZEDSMSG ARE MISSING)\n      ISPEXEC     SETMSG MSG(ISRZ000)\n      EXIT CODE(12)\n   END\n   IF &LABL = &STR() AND &LABF \u00ac= &STR() THEN DO\n      SET &ZEDSMSG = &STR(LABEL MISSING)\n      SET &ZEDLMSG = &STR(TWO LABELS MUST BE INDICATED FOR A RANGE)\n      ISPEXEC     SETMSG MSG(ISRZ000)\n   END\n   IF &LABF = &STR() THEN SET LABF = &STR(.ZFIRST)\n   IF &LABL = &STR() THEN SET LABL = &STR(.ZLAST)\n   ISREDIT (#LABF) = LINENUM &LABF\n   IF &LASTCC \u00ac= 0 THEN DO\n      SET &ZEDSMSG = &STR(&LABF. LABEL)\n      SET &ZEDLMSG = &STR(&ZEDSMSG DOES NOT EXIST)\n      ISPEXEC     SETMSG MSG(ISRZ000)\n      EXIT CODE(12)\n   END\n   ISREDIT (#LABL) = LINENUM &LABL\n   IF &LASTCC \u00ac= 0 THEN DO\n      SET &ZEDSMSG = &STR(&LABL. LABEL)\n      SET &ZEDLMSG = &STR(&ZEDSMSG DOES NOT EXIST)\n      ISPEXEC     SETMSG MSG(ISRZ000)\n      EXIT CODE(12)\n   END\n                                   /**  END OF LABEL REQUIREMENTS  **/\n   ISREDIT (DWIDTH) = DATA_WIDTH\n   SET DWIDTH2 = &DWIDTH + &DWIDTH\n                               /**  CAN BE USED TO FORCE AN ERROR  **/\n   ISREDIT (LBOUND,RBOUND) = BOUNDS\n   ISREDIT (VAR057) = RECFM\n   ISREDIT (VAR049,VAR050) = NUMBER\n   SET LLBOUND = &LBOUND\n   SET LLADJ = 0\n   IF &VAR057 = V AND &VAR049 = ON THEN DO\n      SET LLADJ = 8\n      SET LLBOUND = &LBOUND + 8\n   END\n                   /**  BEGIN OF INTERFACE TO COMMON PATTERN CLIST  **/\n   IF &X = X AND &NX = NX THEN DO\n      SET X =\n      SET NX =\n   END\n                   /**  END OF INTERFACE TO COMMON PATTERN CLIST  **/\n   IF &EVAL(&#LABL.) < &EVAL(&#LABF.) THEN DO\n      SET &ZEDSMSG = &STR(LABEL ERR .LABF/L)\n      SET &ZEDLMSG = &STR(&LABF MUST APPEAR EARLIER THAN +\n          &LABL)\n      ISPEXEC     SETMSG MSG(ISRZ000)\n      EXIT CODE(12)\n   END\n   SET I = &#LABF\n   SET CNT = 0\n   DO WHILE &I <= &#LABL\n      ISREDIT (VAR075) = XSTATUS &I\n      IF &VAR075 = &NX OR &VAR075 = &X OR  &STR(&X&NX) = &STR() +\n         THEN DO\n            SET R = 1\n            DO WHILE &R <= &RMAX\n               ISREDIT LABEL &I = .POINT\n               SET TOKEN = &STR(&&FIND&R)\n               SET TOKEN = &STR(&TOKEN)\n               ISREDIT SEEK .POINT .POINT &TOKEN. &WORD. ALL\n               IF &LASTCC > 0 THEN GOTO NFOUND\n               SET R = &R + 1\n            END\n            SET CNT = &CNT + 1\n            IF &VAR075 = X THEN DO\n               SET SETNX = 0&SETNX + 1\n               ISREDIT XSTATUS .POINT = NX\n            END\n            GOTO NXTT_I\nNFOUND: -\n            ISREDIT EXCLUDE .POINT .POINT ALL\n            IF &VAR075 = NX THEN SET SETX = 0&SETX + 1\n         END\nNXTT_I: -\n      SET I = &I. + 1\n   END\n\nNONE: -\n   SET &ZEDSMSG = &STR(FOUND )&CNT\n   SET XXX = &STR()\n   IF &EVAL(&SETX)  \u00ac= &EVAL(0) THEN SET XXX = &STR(&SETX. +\n      NX->X, )\n   IF &EVAL(&SETNX) \u00ac= &EVAL(0) THEN SET XXX = +\n      &STR(&XXX.&SETNX. X->NX, )\n   IF &EVAL(&SETX) = &EVAL(0) AND &EVAL(&SETNX) = &EVAL(0) +\n      THEN DO\n         SET XXX = &STR(DISPLAY NOT CHANGED BY )\n         SET &ZEDSMSG = &STR(NO CHANGE)\n      END\n   ELSE DO\n      ISREDIT F FIRST NX &LABF &LABL ' '\n      IF &STR(&IMAC) = NONE THEN ISREDIT UP 1\n   END\n   ISREDIT RESET FIND\n   SET &ZEDLMSG = &STR(&XXX.                            +\n      ===> FAND &LABF &LABL &X.&NX.&WORD. &FIND1 &FIND2 +\n      &FIND3 &FIND4 &FIND5 &FIND6 &FIND7.)\n   ISPEXEC     SETMSG MSG(ISRZ000)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FEXC": {"ttr": 22276, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00J\\x00J\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 74, "newlines": 74, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- FIND NEXT EXCLUDED LINE  **/\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'FEXC EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      RETURN\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      ADDRESS ISREDIT \"ISREDIT MACRO (PARMS) NOPROCESS\"\n      PARMS = TRANSLATE(PARMS)\n   END\n   ELSE DO\n      SAY 'FEXC EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      RETURN\n   END\n\n   PARMS     = TRANSLATE(PARMS)\n   IF PARMS = '?' THEN SIGNAL DISPDOC\n   IF PARMS = '-=PFK=-' THEN DO\n      ADDRESS ISPEXEC \"VGET (FNSTART) SHARED\"\n      START = FNSTART\n      SIGNAL REPEAT\n   END\n\n   \"ISREDIT (SAVELINE,SAVECOL) = CURSOR\"\n   START = SAVELINE\n\nREPEAT:\n\n   ADDRESS ISREDIT \"(END)   = LINENUM .ZLAST\"\n\n   DO PNTR = START TO END\n      \"ISREDIT (LINESTAT) = XSTATUS\" PNTR\n      IF LINESTAT = \"X\" THEN DO\n         STR = 'FOUND!'\n         CALL SETMSG '* NO ' STR '$FOUND EXCLUDED LINES!'\n         IF PNTR = 1 THEN DO\n            \"ISREDIT UP MAX\"\n         END\n         ELSE DO\n            WHERE = PNTR - 1\n            \"ISREDIT LOCATE\" WHERE\n         END\n         DO II  =  (PNTR+1)  TO  END  WHILE  LINESTAT = 'X'\n            \"ISREDIT (LINESTAT) = XSTATUS\" II\n         END\n         FNSTART = II\n         ADDRESS ISPEXEC \"VPUT (FNSTART) SHARED\"\n         FALTNM = 'FEXC'\n         ADDRESS ISPEXEC \"VPUT (FALTNM)  SHARED\"\n         EXIT 1\n      END\n   END PNTR\n\n   STR = 'NO X FOUND!'\n   CALL SETMSG '* NO ' STR '$NO EXCLUDED LINES FOUND!'\n   EXIT 1\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"FEXC - FIND EXCLUDED LINE\"\n   SAY\n   SAY \" FORMAT \"\n   SAY \"   FEXC                                              \"\n   SAY\n   SAY \"       WILL FIND THE NEXT EXCLUDED LINE, IF ANY,     \"\n   SAY \"       FROM THE TOP OF THE CURRENT SCREEN DISPLAY.   \"\n   SAY\n   RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FGE": {"ttr": 22279, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xf7\\x00\\xf7\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 247, "newlines": 247, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- FIND NEXT LINE W/ VALUE >= GIVEN STRING  **/\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'FGE MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (PARMS)\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY 'FGE EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT'\n      SIGNAL EOJ\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n\n   PARMS   = TRANSLATE(PARMS)\n   LBL1    = \"\"\n   LBL2    = \"\"\n   SCOL1   = \"\"\n   SCOL2   = \"\"\n   IF SUBSTR(PARMS,1,1) = \"'\"\n      THEN DO\n         PARMS = SUBSTR(PARMS,2)\n         QLOC  = INDEX(PARMS,\"'\")\n         SSTR  = SUBSTR(PARMS,1,QLOC-1)\n         PARMS = SUBSTR(PARMS,QLOC+1)\n      END\n      ELSE DO\n         IF SUBSTR(PARMS,1,1) = '\"'\n            THEN DO\n               PARMS = SUBSTR(PARMS,2)\n               QLOC  = INDEX(PARMS,'\"')\n               SSTR  = SUBSTR(PARMS,1,QLOC-1)\n               PARMS = SUBSTR(PARMS,QLOC+1)\n            END\n            ELSE DO\n               SSTR  = WORD(PARMS,1)\n               PARMS = SUBSTR(PARMS,LENGTH(SSTR)+1)\n            END\n      END\n   IF SSTR == \"\" THEN DO\n      ZEDSMSG = \"NO STRING RC=8\"\n      ZEDLMSG = \"MUST SPECIFY STRING\"\n      ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      SIGNAL DISPDOC\n   END\n   IF SSTR = '-=PFK=-' THEN DO;\n      ADDRESS ISPEXEC \"VGET (FNSSTR)  SHARED\"\n      ADDRESS ISPEXEC \"VGET (FNSCOL1) SHARED\"\n      ADDRESS ISPEXEC \"VGET (FNSCOL2) SHARED\"\n      ADDRESS ISPEXEC \"VGET (FNSTART) SHARED\"\n      ADDRESS ISPEXEC \"VGET (FNEND)   SHARED\"\n      RIND  = 'YES'\n      SSTR  = FNSSTR\n      SCOL1 = FNSCOL1\n      SCOL2 = FNSCOL2\n      START = FNSTART\n      END   = FNEND\n      SIGNAL REPEAT\n   END\n   ELSE RIND = 'NO'\n   DO II = 1 TO 4;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               SIGNAL DISPDOC\n            END\n      END\n      ELSE DO\n         IF DATATYPE(TOKEN,'W')  THEN DO\n            IF SCOL1 = \"\" THEN SCOL1 = TOKEN\n            ELSE IF SCOL2 = \"\" THEN SCOL2 = TOKEN\n               ELSE DO\n                  ZEDSMSG = \".LABEL RC=8\"\n                  ZEDLMSG = \"TOO MANY COLUMNS --\" SCOL1 SCOL2 TOKEN\n                  ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n                  SIGNAL DISPDOC\n               END\n         END\n         ELSE DO\n            ZEDSMSG = \"BAD PARM\"\n            ZEDLMSG = \"UNRECOGNIZED PARM --\" TOKEN\n            ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n            SIGNAL DISPDOC\n         END\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF SCOL1 = \"\" THEN DO\n      SCOL1 = 1\n      SCOL2 = LRECL\n   END\n   ELSE DO\n      IF SCOL2 = \"\" THEN SCOL2 = SCOL1 + LENGTH(SSTR) - 1\n   END\n   IF SCOL1 > LRECL THEN DO\n      MESG = \"COLUMN\" SCOL1 \"IS GREATER THAN LRECL OF FILE!\"\n      SIGNAL ERROR\n   END\n   IF SCOL2 > LRECL THEN DO\n      MESG = \"COLUMN\" SCOL2 \"IS GREATER THAN LRECL OF FILE!\"\n      SIGNAL ERROR\n   END\n   IF SCOL1 > SCOL2 THEN DO\n      TEMP  = SCOL1\n      SCOL1 = SCOL2\n      SCOL2 = TEMP\n   END\n\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n   START = 1\n   IF LBL1 <> '' THEN \"ISREDIT (START) = LINENUM &LBL1\"\n   IF LBL2 <> '' THEN \"ISREDIT (END)   = LINENUM &LBL2\"\n\n   IF START > END THEN DO\n      TEMP  = START\n      START = END\n      END   = TEMP\n   END\n\n   FALTNM  = 'FGE'\n   FNSSTR  = SSTR\n   FNSCOL1 = SCOL1\n   FNSCOL2 = SCOL2\n   FNSTART = START\n   FNEND   = END\n   ADDRESS ISPEXEC \"VPUT (FALTNM)  SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNSSTR)  SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNSCOL1) SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNSCOL2) SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNSTART) SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNEND)   SHARED\"\n\nREPEAT:\n\n   \"ISREDIT (LINE,COL) = CURSOR\"\n   SLEN  = LENGTH(SSTR)\n   SCOLS = SCOL2 - SCOL1 + 1\n   IF  ( LINE > START & LINE < END ),\n      |  ( RIND = 'YES' & LINE = START ) THEN START = LINE + 1\n\n   DO PNTR = START TO END\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      IF SCOLS > SLEN,\n         THEN DO\n            DO II = SCOL1 TO (SCOL1+SCOLS-SLEN)\n               IF SUBSTR(RECORD,II,SLEN) >= SSTR,\n                  THEN DO\n                     STR = 'FOUND!'\n                     CALL SETMSG '* NO ' STR '$FOUND LINE W/ >= STRING'\n                     WHERE = PNTR - 1\n                     \"ISREDIT LOCATE\" WHERE\n                     \"ISREDIT CURSOR = \" PNTR II\n                     SIGNAL EOJ\n                  END\n            END\n         END\n         ELSE DO\n            IF SUBSTR(RECORD,SCOL1,SLEN) >= SSTR,\n               THEN DO\n                  STR = 'FOUND!'\n                  CALL SETMSG '* NO ' STR '$FOUND LINE W/ >= STRING'\n                  WHERE = PNTR - 1\n                  \"ISREDIT LOCATE\" WHERE\n                  \"ISREDIT CURSOR = \" PNTR  SCOL1\n                  SIGNAL EOJ\n               END\n         END\n   END\n   STR = 'NOT FOUND!'\n   CALL SETMSG '* NO ' STR '$LINE W/ >= STRING NOT FOUND'\n   \"ISREDIT CURSOR = \" LINE COL\n   SIGNAL EOJ\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   CALL DISPDOC\n\nEOJ:\n   X = MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"FGE - FIND NEXT LINE W/ VALUE >= GIVEN STRING \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"   FGE   STRING   ( COL-1 ( COL-2 ) )   ( .A .B )         \"\n   SAY\n   SAY \"       THE STRING MUST BE SPECIFIED.  THE COLUMNS AND THE \"\n   SAY \"       RANGES ARE OPTIONAL AND MAY BE INTERMIXED.         \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    FGE  'AK'  11 12                                 \"\n   SAY \"       WILL FIND THE NEXT LINE WHERE A VALUE GREATER \"\n   SAY \"       THAN OR EQUAL TO 'AK' IS IN COLUMNS 11/12.    \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FGT": {"ttr": 22284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xf8\\x00\\xf8\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 248, "newlines": 248, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- FIND NEXT LINE W/ VALUE GREATER THAN GIVEN STRING  **/\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'FGT MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (PARMS)\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY 'FGT EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT'\n      SIGNAL EOJ\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n\n   PARMS   = TRANSLATE(PARMS)\n   LBL1    = \"\"\n   LBL2    = \"\"\n   SCOL1   = \"\"\n   SCOL2   = \"\"\n   IF SUBSTR(PARMS,1,1) = \"'\"\n      THEN DO\n         PARMS = SUBSTR(PARMS,2)\n         QLOC  = INDEX(PARMS,\"'\")\n         SSTR  = SUBSTR(PARMS,1,QLOC-1)\n         PARMS = SUBSTR(PARMS,QLOC+1)\n      END\n      ELSE DO\n         IF SUBSTR(PARMS,1,1) = '\"'\n            THEN DO\n               PARMS = SUBSTR(PARMS,2)\n               QLOC  = INDEX(PARMS,'\"')\n               SSTR  = SUBSTR(PARMS,1,QLOC-1)\n               PARMS = SUBSTR(PARMS,QLOC+1)\n            END\n            ELSE DO\n               SSTR  = WORD(PARMS,1)\n               PARMS = SUBSTR(PARMS,LENGTH(SSTR)+1)\n            END\n      END\n   IF SSTR == \"\" THEN DO\n      ZEDSMSG = \"NO STRING RC=8\"\n      ZEDLMSG = \"MUST SPECIFY STRING\"\n      ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      SIGNAL DISPDOC\n   END\n   IF SSTR = '-=PFK=-' THEN DO;\n      ADDRESS ISPEXEC \"VGET (FNSSTR)  SHARED\"\n      ADDRESS ISPEXEC \"VGET (FNSCOL1) SHARED\"\n      ADDRESS ISPEXEC \"VGET (FNSCOL2) SHARED\"\n      ADDRESS ISPEXEC \"VGET (FNSTART) SHARED\"\n      ADDRESS ISPEXEC \"VGET (FNEND)   SHARED\"\n      RIND  = 'YES'\n      SSTR  = FNSSTR\n      SCOL1 = FNSCOL1\n      SCOL2 = FNSCOL2\n      START = FNSTART\n      END   = FNEND\n      SIGNAL REPEAT\n   END\n   ELSE RIND = 'NO'\n   DO II = 1 TO 4;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               SIGNAL DISPDOC\n            END\n      END\n      ELSE DO\n         IF DATATYPE(TOKEN,'W')  THEN DO\n            IF SCOL1 = \"\" THEN SCOL1 = TOKEN\n            ELSE IF SCOL2 = \"\" THEN SCOL2 = TOKEN\n               ELSE DO\n                  ZEDSMSG = \".LABEL RC=8\"\n                  ZEDLMSG = \"TOO MANY COLUMNS --\" SCOL1 SCOL2 TOKEN\n                  ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n                  SIGNAL DISPDOC\n               END\n         END\n         ELSE DO\n            ZEDSMSG = \"BAD PARM\"\n            ZEDLMSG = \"UNRECOGNIZED PARM --\" TOKEN\n            ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n            SIGNAL DISPDOC\n         END\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF SCOL1 = \"\" THEN DO\n      SCOL1 = 1\n      SCOL2 = LRECL\n   END\n   ELSE DO\n      IF SCOL2 = \"\" THEN SCOL2 = SCOL1 + LENGTH(SSTR) - 1\n   END\n   IF SCOL1 > LRECL THEN DO\n      MESG = \"COLUMN\" SCOL1 \"IS GREATER THAN LRECL OF FILE!\"\n      SIGNAL ERROR\n   END\n   IF SCOL2 > LRECL THEN DO\n      MESG = \"COLUMN\" SCOL2 \"IS GREATER THAN LRECL OF FILE!\"\n      SIGNAL ERROR\n   END\n   IF SCOL1 > SCOL2 THEN DO\n      TEMP  = SCOL1\n      SCOL1 = SCOL2\n      SCOL2 = TEMP\n   END\n\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n   START = 1\n   IF LBL1 <> '' THEN \"ISREDIT (START) = LINENUM &LBL1\"\n   IF LBL2 <> '' THEN \"ISREDIT (END)   = LINENUM &LBL2\"\n\n   IF START > END THEN DO\n      TEMP  = START\n      START = END\n      END   = TEMP\n   END\n\n   FALTNM  = 'FGT'\n   FNSSTR  = SSTR\n   FNSCOL1 = SCOL1\n   FNSCOL2 = SCOL2\n   FNSTART = START\n   FNEND   = END\n   ADDRESS ISPEXEC \"VPUT (FALTNM)  SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNSSTR)  SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNSCOL1) SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNSCOL2) SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNSTART) SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNEND)   SHARED\"\n\nREPEAT:\n\n   \"ISREDIT (LINE,COL) = CURSOR\"\n   SLEN  = LENGTH(SSTR)\n   SCOLS = SCOL2 - SCOL1 + 1\n   IF  ( LINE > START & LINE < END ),\n      |  ( RIND = 'YES' & LINE = START ) THEN START = LINE + 1\n\n   DO PNTR = START TO END\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      IF SCOLS > SLEN,\n         THEN DO\n            DO II = SCOL1 TO (SCOL1+SCOLS-SLEN)\n               IF SUBSTR(RECORD,II,SLEN) > SSTR,\n                  THEN DO\n                     STR = 'FOUND!'\n                     CALL SETMSG '* NO ' STR '$FOUND LINE W/ > STRING'\n                     WHERE = PNTR - 1\n                     \"ISREDIT LOCATE\" WHERE\n                     \"ISREDIT CURSOR = \" PNTR II\n                     SIGNAL EOJ\n                  END\n            END\n         END\n         ELSE DO\n            IF SUBSTR(RECORD,SCOL1,SLEN) > SSTR,\n               THEN DO\n                  STR = 'FOUND!'\n                  CALL SETMSG '* NO ' STR '$FOUND LINE W/ > STRING'\n                  WHERE = PNTR - 1\n                  \"ISREDIT LOCATE\" WHERE\n                  \"ISREDIT CURSOR = \" PNTR  SCOL1\n                  SIGNAL EOJ\n               END\n         END\n   END\n   STR = 'NOT FOUND!'\n   CALL SETMSG '* NO ' STR '$LINE W/ > STRING NOT FOUND'\n   \"ISREDIT CURSOR = \" LINE COL\n   SIGNAL EOJ\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   CALL DISPDOC\n\nEOJ:\n   X = MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"FGT - FIND NEXT LINE W/ VALUE GREATER THAN GIVEN STRING   \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"   FGT   STRING   ( COL-1 ( COL-2 ) )   ( .A .B )         \"\n   SAY\n   SAY \"       THE STRING MUST BE SPECIFIED.  THE COLUMNS AND THE \"\n   SAY \"       RANGES ARE OPTIONAL AND MAY BE INTERMIXED.         \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    FGT  Q    18   .A .B                             \"\n   SAY \"       WILL FIND THE NEXT LINE WHERE COLUMN 18 HAS   \"\n   SAY \"       A CHARACTER GREATER THAN 'Q' IN THE LINE RANGE\"\n   SAY \"       OF LABELS .A THROUGH .B.                      \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FILLCOLS": {"ttr": 22532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x8b\\x00\\x8b\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 139, "newlines": 139, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- OVERLAY FILL DATA ONTO SPECIFIC COLUMN LOCATIONS  **/\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'FILLCOLS MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n             \"ISREDIT MACRO (TOLEFT,TORIGHT,CONTENT,LBL1,LBL2)\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY 'FILLCOLS EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT'\n      SIGNAL EOJ\n   END\n\n   ERRORMSG = ''\n   MESG     = ''\n   IF CONTENT = ''  |  TOLEFT = ''  |  TORIGHT = ''  THEN DO\n      MESG = 'PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(TOLEFT,'W')  |  TOLEFT = 0  THEN DO\n      MESG = \"'\"TOLEFT\"' VALUE OF TO-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(TORIGHT,'W') |  TORIGHT = 0 THEN DO\n      MESG = \"'\"TORIGHT\"' VALUE OF TO-RIGHT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF SUBSTR(CONTENT,1,1) = \"'\",\n         & SUBSTR(CONTENT,LENGTH(CONTENT),1) = \"'\" THEN DO\n      CONTENT = SUBSTR(CONTENT,2,LENGTH(CONTENT)-2)\n   END\n   LEN = LENGTH(CONTENT)\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF TOLEFT > TORIGHT THEN DO\n      MESG = \"TO-LEFT COLUMN IS GREATER THAN TO-RIGHT!\"\n      SIGNAL ERROR\n   END\n   IF TOLEFT > LRECL THEN DO\n      MESG = \"TO-LEFT COLUMN IS GREATER THAN RECORD SIZE (\"LRECL\")\"\n      SIGNAL ERROR\n   END\n   IF TORIGHT > LRECL THEN DO\n      MESG = \"TO-RIGHT COLUMN IS GREATER THAN RECORD SIZE (\"LRECL\")\"\n      SIGNAL ERROR\n   END\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR   \"\n   \"ISREDIT (\"ANUM\") = AUTONUM              \"\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n\n   IF LBL1 <> '' THEN \"ISREDIT (START) = LINENUM &LBL1\"\n      ELSE START = 1\n\n   IF LBL2 <> '' THEN \"ISREDIT (END) = LINENUM &LBL2\"\n      ELSE LBL2 = LBL1\n\n   IF START > END THEN DO\n      FLIP  = START\n      START = END\n      END   = FLIP\n   END\n\n   CONTENTX = SUBSTR(COPIES(CONTENT,(TORIGHT-TOLEFT+1)%LEN+1),\n                     ,1,TORIGHT-TOLEFT+1)\n\n   DO PNTR =  START  TO  END  BY 1\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      RECORD = SUBSTR(RECORD,1,TOLEFT-1),\n         || CONTENTX,\n         || SUBSTR(RECORD,TORIGHT+1)\n      \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n   END\n\n   IF LBL1 = '' THEN \"ISREDIT LOCATE 1\"\n      ELSE \"ISREDIT LOCATE\" LBL1\n  \"ISREDIT AUTONUM = \"ANUM\n  SIGNAL EOJ\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   SIGNAL DISPDOC\n\nEOJ:\n   X = MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \" FILLCOLS - PLACE A STRING ONTO SPECIFIED COLUMNS      \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    FILLCOLS  LEFT-COL  RIGHT-COL  STRING  ( .A .B )   \"\n   SAY\n   SAY \"       COLUMNS AND STRING ARE MANDATORY. STRING MAY BE \"\n   SAY \"       IN QUOTES OR NOT.  LABEL RANGE IS OPTIONAL.     \"\n   SAY\n   SAY \" EXAMPLES \"\n   SAY \"    FILLCOLS  17 19  ABC                               \"\n   SAY \"       WILL OVERLAY 'ABC' ONTO COLUMNS 17-19           \"\n   SAY\n   SAY \"    FILLCOLS  73 80  '-=-=-'  .A .B                    \"\n   SAY \"       WILL PLACE '-=-=--=-' IN COLUMNS 73 THRU 80     \"\n   SAY \"       IN LABEL RANGE .A THRU .B                       \"\n   SAY\n   RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FILLINS": {"ttr": 22535, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x85\\x00\\x85\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 133, "newlines": 133, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- INSERT FILL DATA INTO SPECIFIC COLUMN LOCATION  **/\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'FILLINS MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n             \"ISREDIT MACRO (TOLEFT,CONTENT,LBL1,LBL2)\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY 'FILLINS EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT',\n          'WITH NO PENDING EDIT COMMANDS!'\n      SIGNAL EOJ\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n   IF FRMLEFT = '' THEN DO\n     SIGNAL ERROR\n   END\n   IF CONTENT = ''  |  TOLEFT = ''  THEN DO\n      MESG = 'PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(TOLEFT,'W')  |  TOLEFT = 0  THEN DO\n      MESG = \"'\"TOLEFT\"' VALUE OF TO-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF SUBSTR(CONTENT,1,1) = \"'\",\n         & SUBSTR(CONTENT,LENGTH(CONTENT),1) = \"'\" THEN DO\n      CONTENT = SUBSTR(CONTENT,2,LENGTH(CONTENT)-2)\n   END\n   LEN = LENGTH(CONTENT)\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF TOLEFT > LRECL THEN DO\n      MESG = \"TO-LEFT COLUMN IS GREATER THAN RECORD SIZE (\"LRECL\")\"\n      SIGNAL ERROR\n   END\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR     \"\n   \"ISREDIT (\"ANUM\") = AUTONUM              \"\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n\n   IF LBL1 <> '' THEN \"ISREDIT (START) = LINENUM &LBL1\"\n      ELSE START = 1\n\n   IF LBL2 <> '' THEN \"ISREDIT (END) = LINENUM &LBL2\"\n      ELSE LBL2 = LBL1\n\n   IF START > END THEN DO\n      FLIP  = START\n      START = END\n      END   = FLIP\n   END\n\n   DO PNTR =  START  TO  END  BY 1\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      RECORD = SUBSTR(RECORD,1,TOLEFT-1),\n         || CONTENT,\n         || SUBSTR(RECORD,TOLEFT,LRECL-TOLEFT-1)\n      \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n   END\n\n   IF LBL1 = '' THEN \"ISREDIT LOCATE 1\"\n      ELSE \"ISREDIT LOCATE\" LBL1\n  \"ISREDIT AUTONUM = \"ANUM\n  SIGNAL EOJ\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   SIGNAL DISPDOC\n\nEOJ:\n   X = MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \" FILLINS : INSERT A STRING BEFORE A SPECIFIED COLUMN\"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    FILLINS   LEFT-COL  STRING  .LAB1 .LAB2            \"\n   SAY\n   SAY \"       COLUMNS AND STRING ARE MANDATORY. STRING MAY BE \"\n   SAY \"       IN QUOTES OR NOT.  LABEL RANGE IS OPTIONAL.     \"\n   SAY\n   SAY \" EXAMPLES \"\n   SAY\n   SAY \"    FILLINS  1  '...'                                  \"\n   SAY \"       WILL INSERT ... BEFORE COLUMN 1                 \"\n   SAY \"       SHIFTING EVERYTHING RIGHT 3 COLUMNS             \"\n   SAY\n   SAY \"    FILLINS  21  00  .A .B                             \"\n   SAY \"       WILL INSERT 00 AFTER COLUMN 20                  \"\n   SAY \"       SHIFTING COLUMNS 21 ON TO THE                   \"\n   SAY \"       RIGHT IN LABEL RANGE .A THRU .B                 \"\n   SAY\n   RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FINDDUPS": {"ttr": 22538, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xb0\\x00\\xb0\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 176, "newlines": 176, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- SORT & SHOW ALL RECORDS THAT ARE DUPS WITHIN A FILE  **/\n\n   SUBCOM ISREDIT\n   IF  RC = 0  THEN DO\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT \"ISREDIT MACRO (PARMS)\"\n      IF  RC = 0  THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF  DSN = 'DSN'  THEN DO\n      SAY 'FINDDUPS MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n\n   PARMS   = TRANSLATE(PARMS)\n   PARMCNT = 0\n   COL.    = \"\"\n   LBL1 = \"\"\n   LBL2 = \"\"\n   DO II = 1 TO 12\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n      END\n      ELSE DO\n         PARMCNT = PARMCNT + 1\n         COL.PARMCNT = TOKEN\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n   IF (PARMCNT // 2) <> 0 THEN DO\n      SAVER = COL.PARMCNT\n      PARMCNT = PARMCNT + 1\n      COL.PARMCNT = SAVER\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n   IF  PARMCNT = 0 THEN DO\n      MESG = 'PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   SORTPARMS = \"\"\n   DO II = 1 TO PARMCNT\n      IF  \u00acDATATYPE(COL.II,'W') | COL.II = 0 THEN DO\n         MESG = \"'\"COL.II\"' COLUMN VALUE IS INVALID!\"\n         SIGNAL ERROR\n      END\n      IF  COL.II > LRECL  THEN DO\n         MESG = \"'\"COL.II\"' IS GREATER THAN RECORD SIZE(\"LRECL\")\"\n         SIGNAL ERROR\n      END\n      SORTPARMS = SORTPARMS || \" \" || COL.II\n   END II\n   DO II = 1 TO PARMCNT BY 2\n      JJ = II + 1\n      IF  COL.II > COL.JJ THEN DO\n         MESG = \"LEFT-COL \"COL.II\" IS GREATER THAN RIGHT-COL \"COL.JJ\n         SIGNAL ERROR\n      END\n   END II\n\n   IF  LBL1 <> ''  THEN DO\n      \"ISREDIT L &LBL1\"\n       IF  RC <>  0 THEN DO\n          MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   IF  LBL2 <> ''  THEN DO\n      \"ISREDIT L &LBL2\"\n       IF  RC <>  0 THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   IF  LBL1 <> ''  THEN  \"ISREDIT (START) = LINENUM &LBL1\"\n                   ELSE  START = 1\n   IF  LBL2 <> ''  THEN  \"ISREDIT (END) = LINENUM &LBL2\"\n                   ELSE  \"ISREDIT (END) = LINENUM .ZLAST\"\n\n   \"ISREDIT (\"ANUM\") = AUTONUM\"\n   \"ISREDIT NUMBER OFF \"\n\n   \"ISREDIT SORT \" SORTPARMS LBL1 LBL2\n\n   \"ISREDIT (RECORD)  = LINE \" START\n   PREVKEY = SUBSTR(RECORD,COL.1,COL.2-COL.1+1)\n   DO II = 3 TO PARMCNT BY 2\n      JJ = II + 1\n      PREVKEY = PREVKEY || SUBSTR(RECORD,COL.II,COL.JJ-COL.II+1)\n   END II\n   \"ISREDIT RESET\"\n   \"ISREDIT LABEL \"START\" = .TMP\"\n   LASTEQ = \"NO\"\n   SET    = 0\n\n   DO  PNTR  =  (START+1) TO END  BY 1\n      \"ISREDIT (RECORD) = LINE\" PNTR\n      NEXTKEY = SUBSTR(RECORD,COL.1,COL.2-COL.1+1)\n      DO II = 3 TO PARMCNT BY 2\n         JJ      = II + 1\n         NEXTKEY = NEXTKEY || SUBSTR(RECORD,COL.II,COL.JJ-COL.II+1)\n      END II\n      IF PREVKEY == NEXTKEY THEN DO\n         IF LASTEQ = \"NO\" THEN DO\n            SET    = SET + 1\n            LASTEQ = \"YES\"\n         END\n      END\n      ELSE DO\n         IF LASTEQ = \"NO\" THEN \"ISREDIT X ALL .TMP .TMP\"\n         ELSE LASTEQ = \"NO\"\n         \"ISREDIT LABEL \"PNTR\" = .TMP\"\n         IF  PNTR = END  THEN \"ISREDIT X ALL .TMP .TMP\"\n         PREVKEY = NEXTKEY\n      END\n   END PNTR\n\n   CALL SETMSG '* NO ' SET 'DUP KEY SETS $SETS OF DUPLICATE KEYS FOUND'\n   IF START = 1 THEN \"ISREDIT LOCATE\" 0\n                ELSE DO\n                   START = START - 1\n                   \"ISREDIT LOCATE\" START\n                END\n   \"ISREDIT AUTONUM = \"ANUM\n    SIGNAL EOJ\n\nERROR:\n   IF MESG <> '' THEN DO\n      ERRORMSG = '===>' MESG\n   END\n   SIGNAL DISPDOC\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nEOJ:\n   RETURN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"FINDDUPS - SORT AND SHOW ANY DUPS WITHIN A FILE\"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    FINDDUPS  COL1 COL2  ...  .LABEL1 .LABEL2\"\n   SAY\n   SAY \"    ONE PAIR OF COLUMNS IS MANDATORY. UP TO 10 PAIRS \"\n   SAY \"    MAY BE SPECIFIED. \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    FINDDUPS  17 19  4 11 \"\n   SAY\n   SAY \"       WILL SORT FILE BY COLUMNS 17 THRU 19 AND 4 \"\n   SAY \"       THRU 11 SHOWING (UNEXCLUDING) ONLY THOSE \"\n   SAY \"       RECORDS WITH DUPLICATE KEYS.\"\n   SAY\n   RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FINDDUPX": {"ttr": 22785, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xab\\x00\\xab\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 171, "newlines": 171, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- SHOW ALL RECORDS THAT ARE CONSECUTIVE DUPS  **/\n\n   SUBCOM ISREDIT\n   IF  RC = 0  THEN DO\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT \"ISREDIT MACRO (PARMS)\"\n      IF  RC = 0  THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF  DSN = 'DSN'  THEN DO\n      SAY 'FINDDUPX MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n\n   PARMS   = TRANSLATE(PARMS)\n   PARMCNT = 0\n   COL.    = \"\"\n   LBL1 = \"\"\n   LBL2 = \"\"\n   DO II = 1 TO 22;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n      END\n      ELSE DO\n         PARMCNT = PARMCNT + 1\n         COL.PARMCNT = TOKEN\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n   IF (PARMCNT // 2) <> 0 THEN DO\n      SAVER       = COL.PARMCNT\n      PARMCNT     = PARMCNT + 1\n      COL.PARMCNT = SAVER\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n   IF  PARMCNT = 0 THEN DO\n      MESG = 'PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   DO II = 1 TO PARMCNT\n      IF  \u00acDATATYPE(COL.II,'W') | COL.II = 0 THEN DO\n         MESG = \"'\"COL.II\"' COLUMN VALUE IS INVALID!\"\n         SIGNAL ERROR\n      END\n      IF  COL.II > LRECL  THEN DO\n         MESG = \"'\"COL.II\"' IS GREATER THAN RECORD SIZE(\"LRECL\")\"\n         SIGNAL ERROR\n      END\n   END II\n   DO II = 1 TO PARMCNT BY 2\n      JJ = II + 1\n      IF  COL.II > COL.JJ THEN DO\n         MESG = \"LEFT-COL \"COL.II\" IS GREATER THAN RIGHT-COL \"COL.JJ\n         SIGNAL ERROR\n      END\n   END II\n\n   IF  LBL1 <> ''  THEN DO\n      \"ISREDIT L &LBL1\"\n       IF  RC <>  0 THEN DO\n          MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   IF  LBL2 <> ''  THEN DO\n      \"ISREDIT L &LBL2\"\n       IF  RC <>  0 THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   IF  LBL1 <> ''  THEN  \"ISREDIT (START) = LINENUM &LBL1\"\n                   ELSE  START = 1\n   IF  LBL2 <> ''  THEN  \"ISREDIT (END) = LINENUM &LBL2\"\n                   ELSE  \"ISREDIT (END) = LINENUM .ZLAST\"\n\n   \"ISREDIT (\"ANUM\") = AUTONUM\"\n   \"ISREDIT NUMBER OFF \"\n\n   \"ISREDIT (RECORD)  = LINE \" START\n   PREVKEY = SUBSTR(RECORD,COL.1,COL.2-COL.1+1)\n   DO II = 3 TO PARMCNT BY 2\n      JJ = II + 1\n      PREVKEY = PREVKEY || SUBSTR(RECORD,COL.II,COL.JJ-COL.II+1)\n   END II\n   \"ISREDIT RESET\"\n   \"ISREDIT LABEL \"START\" = .TMP\"\n   LASTEQ = \"NO\"\n   SET    = 0\n\n   DO  PNTR  =  (START+1) TO END  BY 1\n      \"ISREDIT (RECORD) = LINE\" PNTR\n      NEXTKEY = SUBSTR(RECORD,COL.1,COL.2-COL.1+1)\n      DO II = 3 TO PARMCNT BY 2\n         JJ = II + 1\n         NEXTKEY = NEXTKEY || SUBSTR(RECORD,COL.II,COL.JJ-COL.II+1)\n      END II\n      IF PREVKEY == NEXTKEY THEN DO\n         IF LASTEQ = \"NO\" THEN DO\n            SET = SET + 1\n            LASTEQ = \"YES\"\n         END\n      END\n      ELSE DO\n         IF LASTEQ = \"NO\" THEN \"ISREDIT X ALL .TMP .TMP\"\n         ELSE LASTEQ = \"NO\"\n         \"ISREDIT LABEL \"PNTR\" = .TMP\"\n         IF  PNTR = END  THEN \"ISREDIT X ALL .TMP .TMP\"\n         PREVKEY = NEXTKEY\n      END\n   END PNTR\n\n   CALL SETMSG '* NO ' SET 'DUP KEY SETS $SETS OF DUPLICATE KEYS FOUND'\n   IF START = 1 THEN \"ISREDIT LOCATE\" 0\n                ELSE DO\n                   START = START - 1\n                   \"ISREDIT LOCATE\" START\n                END\n   \"ISREDIT AUTONUM = \"ANUM\n    SIGNAL EOJ\n\nERROR:\n   IF MESG <> '' THEN DO\n      ERRORMSG = '===>' MESG\n   END\n   SIGNAL DISPDOC\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nEOJ:\n   RETURN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"FINDDUPX - SHOW DUPLICATE RECORDS WITHOUT SORTING    \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    FINDDUPX  COL1 COL2  ...  (.A .B) \"\n   SAY\n   SAY \"    ONE PAIR OF COLUMNS IS MANDATORY. UP TO 10 PAIRS \"\n   SAY \"    MAY BE SPECIFIED. LABEL RANGE IS OPTIONAL.       \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY \"    FINDDUPX  11 17  4 11  .K .L \"\n   SAY\n   SAY \"       WILL SCAN FILE BY COLUMNS 17 THRU 19 AND 4 \"\n   SAY \"       THRU 11 SHOWING (UNEXCLUDING) ONLY THOSE   \"\n   SAY \"       RECORDS WITH DUPLICATE KEYS IN LABEL RANGE \"\n   SAY \"       .K THROUGH .L.                             \"\n   SAY\n   RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FINDNSTR": {"ttr": 22789, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00?\\x00?\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "REXX"}, "text": "/**  REXX - INVOKE SUPERC TO SHOW WHICH MEMBERS DON'T HAVE A STRING  **/\n\n   MSG = MSG(OFF)\n   PARSE ARG PARMS\n\n   STRING = ''\n   DSN    = ''\n\n   DO II = (LENGTH(PARMS)-1) TO 1 BY -1,\n      WHILE (SUBSTR(PARMS,II,1) <> \"'\")\n   END\n   DSN = SUBSTR(PARMS,II)\n   PARMS = STRIP(SUBSTR(PARMS,1,LENGTH(PARMS)-LENGTH(DSN)),'B')\n   IF PARMS = \"\" | PARMS = \"?\" THEN SIGNAL DISPDOC\n   IF SUBSTR(PARMS,1,1) = \"'\",\n         & SUBSTR(PARMS,LENGTH(PARMS),1) = \"'\"\n      THEN STRING = PARMS\n      ELSE STRING = \"'\" || PARMS || \"'\"\n\n   \"FREE  FILE(NEWDD OUTDD SYSIN)\"\n   \"ALLOC FILE(NEWDD) DA(\"DSN\") SHR REUSE\"\n   ADDRESS ISPEXEC \"VGET (\"ZSSFLDS\") ASIS\"\n   IF RC <> 0 | ZSSFLDS = 'ZSSFLDS' THEN ZSSFLDS = 'SRCHFOR.LIST'\n   \"ALLOC FILE(OUTDD) DA(\"ZSSFLDS\") SHR REUSE\"\n   IF RC <> 0 THEN DO\n     \"ALLOC FILE(OUTDD) DA(\"ZSSFLDS\")\" ,\n           \" NEW CATALOG TRACKS SPACE(30,30)\",\n           \" REUSE LRECL(133) RECFM(F B) \"\n   END\n   \"ALLOC FILE(SYSIN) NEW TRACKS SPACE(1,1) DELETE\",\n         \" REUSE LRECL(80) RECFM(F B) BLKSIZE(3120) UNIT(SYSDA)\"\n   QUEUE \"SRCHFOR\" STRING\n   \"EXECIO 1 DISKW SYSIN  (FINIS\"\n\n   SAY \"SEARCHING FOR W/O \"STRING\" IN\" DSN\n   ADDRESS ISPEXEC \"SELECT PGM(ISRSUPC)\" ,\n         \"PARM(SRCHCMP,ANYC,LNFMTO)\"\n\n   IF RC <> 0 THEN ADDRESS ISPEXEC ,\n     \"BROWSE DATASET(\"ZSSFLDS\")\"\n   ELSE SAY 'STRING' STRING 'WAS NOT FOUND IN' DSN\n\n   \"FREE FILE(NEWDD OUTDD SYSIN)\"\n   EXIT(1)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY\n   SAY \"  FINDSTR   INVOKES SUPERC AGAINST THE SPECIFIED PDS         \"\n   SAY \"            SEARCHING FOR THE STRING TYPED.  THE STRING IS   \"\n   SAY \"            MANDATORY AND MAY BE WITHIN SINGLE QUOTES (').   \"\n   SAY \"            THE OUTPUT WILL BE BROWSED IF ANY FOUND.         \"\n   SAY\n   SAY \"  SYNTAX:   FINDSTR  SOME-STRING                             \"\n   SAY\n   SAY \"            SOME-STRING IS THE CHARACTER SEQUENCE FOR WHICH  \"\n   SAY \"            THE PDS WILL BE SCANNED. SOME ODD CHARACTERS     \"\n   SAY \"            SUCH AS CLOSE PARENTHESIS MAY CAUSE PROBLEMS     \"\n   SAY \"            AND SHOULD BE IN SINGLE QUOTES, E.G.             \"\n   SAY \"               FINDSTR 'TRANSLATE('                          \"\n   SAY \"            BLANKS SHOULD BE WITHIN QUOTES.                  \"\n   SAY\n   RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FINDSTRX": {"ttr": 22791, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00@\\x00@\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "REXX"}, "text": "/**  REXX - INVOKE SUPERC TO SCAN FOR A STRING  **/\n\n   MSG = MSG(OFF)\n   PARSE ARG PARMS\n\n   STRING = ''\n   DSN    = ''\n\n   DO II = (LENGTH(PARMS)-1) TO 1 BY -1,\n      WHILE (SUBSTR(PARMS,II,1) <> \"'\")\n   END\n   DSN = SUBSTR(PARMS,II)\n   PARMS = STRIP(SUBSTR(PARMS,1,LENGTH(PARMS)-LENGTH(DSN)),'B')\n   IF PARMS = \"\" | PARMS = \"?\" THEN SIGNAL DISPDOC\n   IF SUBSTR(PARMS,1,1) = \"'\",\n         & SUBSTR(PARMS,LENGTH(PARMS),1) = \"'\"\n      THEN STRING = PARMS\n      ELSE STRING = \"'\" || PARMS || \"'\"\n\n   \"FREE  FILE(NEWDD OUTDD SYSIN)\"\n   \"ALLOC FILE(NEWDD) DA(\"DSN\") SHR REUSE\"\n   ADDRESS ISPEXEC \"VGET (\"ZSSFLDS\") ASIS\"\n   IF RC <> 0 | ZSSFLDS = 'ZSSFLDS' THEN ZSSFLDS = 'SRCHFOR.LIST'\n   \"ALLOC FILE(OUTDD) DA(\"ZSSFLDS\") SHR REUSE\"\n   IF RC <> 0 THEN DO\n     \"ALLOC FILE(OUTDD) DA(\"ZSSFLDS\")\" ,\n           \" NEW CATALOG TRACKS SPACE(30,30)\",\n           \" REUSE LRECL(133) RECFM(F B) UNIT(SYSDA)\"\n   END\n   \"ALLOC FILE(SYSIN) NEW TRACKS SPACE(1,1) DELETE\",\n         \" REUSE LRECL(80) RECFM(F B) BLKSIZE(3120) UNIT(SYSDA)\"\n   QUEUE \"SRCHFOR\" STRING\n   \"EXECIO 1 DISKW SYSIN  (FINIS\"\n\n   SAY \"SEARCHING FOR \"STRING\" IN\" DSN\n   ADDRESS ISPEXEC \"SELECT PGM(ISRSUPC)\" ,\n         \"PARM(SRCHCMP,ANYC)\"\n\n   IF RC <> 0 THEN ADDRESS ISPEXEC ,\n     \"VIEW DATASET(\"ZSSFLDS\")\"\n         /*** \"BROWSE DATASET(\"ZSSFLDS\")\" ***/\n   ELSE SAY 'STRING' STRING 'WAS NOT FOUND IN' DSN\n\n   \"FREE FILE(NEWDD OUTDD SYSIN)\"\n   EXIT(1)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY\n   SAY \"  FINDSTR   INVOKES SUPERC AGAINST THE SPECIFIED PDS         \"\n   SAY \"            SEARCHING FOR THE STRING TYPED.  THE STRING IS   \"\n   SAY \"            MANDATORY AND MAY BE WITHIN SINGLE QUOTES (').   \"\n   SAY \"            THE OUTPUT WILL BE VIEWED IF ANY FOUND.          \"\n   SAY\n   SAY \"  SYNTAX:   FINDSTR  SOME-STRING                             \"\n   SAY\n   SAY \"            SOME-STRING IS THE CHARACTER SEQUENCE FOR WHICH  \"\n   SAY \"            THE PDS WILL BE SCANNED. SOME ODD CHARACTERS     \"\n   SAY \"            SUCH AS CLOSE PARENTHESIS MAY CAUSE PROBLEMS     \"\n   SAY \"            AND SHOULD BE IN SINGLE QUOTES, E.G.             \"\n   SAY \"               FINDSTR 'TRANSLATE('                          \"\n   SAY \"            BLANKS SHOULD BE WITHIN QUOTES.                  \"\n   SAY\n   RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FLAGREVS": {"ttr": 22793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xcf\\x00\\xcf\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 207, "newlines": 207, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- ADD A TAG TO CHANGED LINES; INVOKES SUPERC  **/\n   SHOW_CONTEXT = 1 /* NUM OF LINES ABOVE AND BELOW CHANGES TO SHOW  */\n                    /* SET_SHOW CONTEXT TO 0 TO SHOW ALL LINES AFTER */\n                    /* TAGGING IS COMPLETE                           */\n   SAVEMSG=MSG()\n   X=MSG(\"OFF\")\n   X=ADDRESS()\n   ADDRESS 'ISPEXEC'\n   NUMERIC DIGITS 12\n   'ISREDIT MACRO (PARMS)'\n   SIGNAL ON NOVALUE\n   SIGNAL ON SYNTAX\n\n   PARSE SOURCE SYSTEM . CMDNAME .\n   'ISREDIT (DW) = DATA_WIDTH'\n   SUPERCRC = -1\n   IF PARMS = '' THEN SIGNAL DISPDOC\n   IF SUBSTR(PARMS,1,1) = \"'\" | SUBSTR(PARMS,1,1) = '\"'\n      THEN DO\n         QUOTE = SUBSTR(PARMS,1,1)\n         DO II = 2 TO LENGTH(PARMS) WHILE (SUBSTR(PARMS,II,1) <> QUOTE)\n         END\n         IF II > LENGTH(PARMS)\n            THEN TAG = PARMS\n            ELSE DO\n               TAG     = SUBSTR(PARMS,2,II)\n               PARMS   = STRIP(SUBSTR(PARMS,II+1),'B')\n               FLAGCOL = PARMS\n            END\n      END\n      ELSE DO\n         TAG     = WORD(PARMS,1)\n         FLAGCOL = WORD(PARMS,2)\n      END\n   IF FLAGCOL = '' THEN FLAGCOL = 65\n   IF 0=DATATYPE(FLAGCOL,'N') THEN DO\n      CALL SETMSG '* YES INVALID START COL $ SYNTAX: ',\n         CMDNAME' FLAG <COL>'\n      EXIT 12\n   END\n   IF  FLAGCOL + LENGTH(TAG) - 1 > DW THEN  DO\n      CALL SETMSG '* YES INVALID START COL $ SYNTAX: ',\n         CMDNAME' FLAG <COL>'\n      EXIT 12\n   END\n\n   CALL ALLOCATES                 /* ALLOCATE DATASETS FOR SUPERC */\n   'SELECT PGM(ISRSUPC) PARM(LINECMP,NOLISTL,UPDLDEL)' /* COMPARE */\n   SUPERCRC = RC\n   IF  SUPERCRC < 5  &  SUPERCRC > 0  THEN CALL ADD_TAGS\n   ELSE IF SUPERCRC > 4\n      THEN CALL SETMSG 'ISR313B0 YES SUPERC ERROR$'||,\n                       'SUPERC ENDED WITH A RETURN CODE OF ' SUPERCRC\n   IF SUPERCRC = 1 THEN\n      CALL SETMSG '* NO FLAGREVS OK $FLAG' TAG 'IN COL' FLAGCOL\n   ELSE IF SUPERCRC = 0 THEN\n      CALL SETMSG '* NO NO FLAGS ADDED$NO CHANGED LINES FOUND'\n\n   ADDRESS TSO 'FREE F(NEWDD,OLDDD,DELDD)'\n   ADDRESS TSO 'DEL $$$TEMP.NEWDD'\n   EXIT 0\n\nSYNTAX:\n   SAY 'SYNTAX SIGNALLED AT LINE 'SIGL' OF 'CMDNAME\n   SAY SOURCELINE(SIGL)\n   SAY COPIES('-',78)\n   EXIT 4\n\nNOVALUE:\n    SAY 'NOVALUE SIGNALLED AT LINE 'SIGL\n    SAY SOURCELINE(SIGL)\n    PARSE SOURCE . . CMDNAME .\n    EXIT 12\n\nADD_TAGS:\n   'ISREDIT RESET'\n   'ISREDIT RESET LAB'\n   'ISREDIT X ALL .ZF .ZL'\n   DO QUEUED(); PULL; END\n   COMPLINE.  = ''\n   COMPLINE.0 = 0\n   ADDRESS TSO 'EXECIO * DISKR DELDD (FINIS STEM COMPLINE.'\n\n   ADDRESS ISREDIT\n   DO A = 1 TO COMPLINE.0  /* UNEXCLUDE CHANGED LINES */\n      LINE = COMPLINE.A\n      PARSE VAR LINE 1 TYPE 3 . 13 REC_COUNT 19 . 29 LINE_NUMBER 35 .\n      SELECT\n         WHEN (TYPE = '*H') THEN /* HEADER */\n            NOP\n         WHEN (TYPE = '*M') THEN /* MATCH  */\n            A = A + REC_COUNT     /* SKIP MATCHES*/\n         WHEN (TYPE = '*I') THEN\n            DO\n               DO LINENO = LINE_NUMBER TO (LINE_NUMBER+REC_COUNT-1)\n                 'XSTATUS 'LINENO' = NX'\n               END\n               A = A + REC_COUNT     /* SKIP INSERTS*/\n            END\n         WHEN (TYPE = '*D') THEN\n            A = A + REC_COUNT     /* SKIP DELETES*/\n         OTHERWISE\n            DO\n               SAY 'UNRECOGNIZED CONTROL TYPE \"'TYPE'\"',\n                  'IN UPD FILE AT LINE' A\n               EXIT 4\n            END\n      END        /* END OF SELECT */\n   END\n/* NOW ADD TAGS TO UNEXCLUDED LINES AND PROCESS FAILURES */\n   \"CHANGE '\"COPIES(' ',LENGTH(TAG))\"' '\"TAG\"' \"FLAGCOL \"ALL NX\"\n   IF RC > 0 THEN\n      DO\n         CALL SETMSG '* NO TAGGING ERROR$',\n            || 'TAGS COULD NOT BE ADDED TO ONE OR MORE LINES.'\n      END\n   IF SHOW_CONTEXT > 0 THEN\n      DO\n         ADDRESS ISPEXEC 'CONTROL ERRORS RETURN'\n         'ISREDIT (LAST) = LINENUM .ZLAST'\n         NXLIST = ''\n         DO A = 1 TO LAST\n            '(XT) = XSTATUS 'A\n            IF XT = 'NX' THEN NXLIST=NXLIST A\n         END\n         DO WHILE NXLIST \\= ''\n            PARSE VAR NXLIST CURRENTLINE NXLIST\n            DO A = CURRENTLINE-SHOW_CONTEXT TO CURRENTLINE+SHOW_CONTEXT\n               'XSTATUS 'A' = NX'\n            END\n         END\n         ADDRESS ISPEXEC 'CONTROL ERRORS CANCEL'\n      END\n   ELSE 'RESET'\n   \"FIND ALL NX '\"TAG\"' \"FLAGCOL /* FIND AND HIGHLIGHT CHANGES */\n   RETURN\n\nALLOCATES:  PROCEDURE EXPOSE CURDSN\n   ADDRESS TSO 'FREE F(NEWDD,OLDDD,DELDD)'\n   ADDRESS TSO 'DEL $$$TEMP.NEWDD'\n   'ISREDIT (LRECL) = LRECL'\n   'ISREDIT (RECFM) = RECFM'\n   IF RECFM = 'V' THEN LRECL = LRECL + 4\n   'ISREDIT (CURRDSN) = DATASET'\n   'ISREDIT (CURRMEM)  = MEMBER'\n   CURDSN = '''' || CURRDSN || '(' || CURRMEM || ')'''\n   ADDRESS TSO 'ALLOC F(OLDDD) SHR DSNAME('CURDSN')'\n   IF RC = 0 THEN\n      ADDRESS TSO 'ALLOC F(NEWDD) NEW DSN($$$TEMP.NEWDD)',\n               'LRECL('LRECL') RECFM('RECFM' B) BLKSIZE(0)',\n               'UNIT(SYSDA) SP(10,10) TRACKS'\n   IF RC > 0 THEN /* TEMP ALLOCATION NOT OK? */\n      DO;\n         CALL SETMSG '* YES ALLOCATION FAILED$'||,\n                     'TEMPORARY DATA SET COULD NOT BE ALLOCATED.'\n         EXIT 1\n      END;\n   ELSE /* TEMP FILE EXISTS - COPY CURRENT CONTENTS TO TEMP FILE*/\n      DO\n         ADDRESS ISREDIT\n         ADDRESS TSO \"EXECIO 0 DISKW NEWDD (OPEN\"\n         'ISREDIT (THEEND) = LINENUM .ZLAST'\n         DO II = 1 TO THEEND\n            \"ISREDIT (RECORD) = LINE &II\"\n            PUSH RECORD\n            ADDRESS TSO \"EXECIO 1 DISKW NEWDD\"\n         END\n         ADDRESS TSO \"EXECIO 0 DISKW NEWDD (FINIS\"\n      END\n   ADDRESS TSO\n   'ALLOC FILE(SYSIN) DUMMY REUSE'\n   'ALLOC NEW FILE(DELDD) LRECL(255) BLKSIZE(27795) RECFM(F B),\n       TRACK UNIT(SYSDA) SPACE(5,10) REUSE DSORG(PS)'\n   RETURN\n\nPTR: RETURN C2D(BITAND(STORAGE(D2X(ARG(1)),4),'7FFFFFFF'X))\n\nSETMSG: /* PROCESS ALL SETMSG REQUESTS AS CONDITIONAL SETMSGS */\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"FLAGREVS - ADD REVISION CODE(S) TO CHANGED LINES UNDER EDIT\"\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    FLAGREVS TAG-CODE  TAG-COLUMN \"\n   SAY\n   SAY \"       THE REVISION CODE (TAG-CODE) IS MANDATORY;    \"\n   SAY \"       THE REVISION COLUMN DEFAULTS TO 65. ALL NON   \"\n   SAY \"       CHANGED LINES WILL BE EXCLUDED AND ONE LINE   \"\n   SAY \"       ABOVE AND ONE BELOW WILL BE SHOWN. NON BLANKS \"\n   SAY \"       WILL NOT BE OVERLAID BY THE TAG.              \"\n   SAY\n   SAY \"       DOES NOT FLAG DELETED LINES.                  \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY \"    FLAGREVS  |  1 \"\n   SAY \"       WILL PLACE A '|' IN COLUMN 1 OF EVERY CHANGED LINE.\"\n   SAY\n   SAY \"    FLAGREVS  ## \"\n   SAY \"       WILL PLACE '##' IN COLUMN 65 (BY DEFAULT) OF EVERY\"\n   SAY \"       CHANGED LINE.\"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FLE": {"ttr": 22797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xf7\\x00\\xf7\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 247, "newlines": 247, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- FIND NEXT LINE W/ VALUE <= GIVEN STRING  **/\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'FLE MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (PARMS)\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY 'FLE EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT'\n      SIGNAL EOJ\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n\n   PARMS   = TRANSLATE(PARMS)\n   LBL1    = \"\"\n   LBL2    = \"\"\n   SCOL1   = \"\"\n   SCOL2   = \"\"\n   IF SUBSTR(PARMS,1,1) = \"'\"\n      THEN DO\n         PARMS = SUBSTR(PARMS,2)\n         QLOC  = INDEX(PARMS,\"'\")\n         SSTR  = SUBSTR(PARMS,1,QLOC-1)\n         PARMS = SUBSTR(PARMS,QLOC+1)\n      END\n      ELSE DO\n         IF SUBSTR(PARMS,1,1) = '\"'\n            THEN DO\n               PARMS = SUBSTR(PARMS,2)\n               QLOC  = INDEX(PARMS,'\"')\n               SSTR  = SUBSTR(PARMS,1,QLOC-1)\n               PARMS = SUBSTR(PARMS,QLOC+1)\n            END\n            ELSE DO\n               SSTR  = WORD(PARMS,1)\n               PARMS = SUBSTR(PARMS,LENGTH(SSTR)+1)\n            END\n      END\n   IF SSTR == \"\" THEN DO\n      ZEDSMSG = \"NO STRING RC=8\"\n      ZEDLMSG = \"MUST SPECIFY STRING\"\n      ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      SIGNAL DISPDOC\n   END\n   IF SSTR = '-=PFK=-' THEN DO;\n      ADDRESS ISPEXEC \"VGET (FNSSTR)  SHARED\"\n      ADDRESS ISPEXEC \"VGET (FNSCOL1) SHARED\"\n      ADDRESS ISPEXEC \"VGET (FNSCOL2) SHARED\"\n      ADDRESS ISPEXEC \"VGET (FNSTART) SHARED\"\n      ADDRESS ISPEXEC \"VGET (FNEND)   SHARED\"\n      RIND  = 'YES'\n      SSTR  = FNSSTR\n      SCOL1 = FNSCOL1\n      SCOL2 = FNSCOL2\n      START = FNSTART\n      END   = FNEND\n      SIGNAL REPEAT\n   END\n   ELSE RIND = 'NO'\n   DO II = 1 TO 4;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               SIGNAL DISPDOC\n            END\n      END\n      ELSE DO\n         IF DATATYPE(TOKEN,'W')  THEN DO\n            IF SCOL1 = \"\" THEN SCOL1 = TOKEN\n            ELSE IF SCOL2 = \"\" THEN SCOL2 = TOKEN\n               ELSE DO\n                  ZEDSMSG = \".LABEL RC=8\"\n                  ZEDLMSG = \"TOO MANY COLUMNS --\" SCOL1 SCOL2 TOKEN\n                  ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n                  SIGNAL DISPDOC\n               END\n         END\n         ELSE DO\n            ZEDSMSG = \"BAD PARM\"\n            ZEDLMSG = \"UNRECOGNIZED PARM --\" TOKEN\n            ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n            SIGNAL DISPDOC\n         END\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF SCOL1 = \"\" THEN DO\n      SCOL1 = 1\n      SCOL2 = LRECL\n   END\n   ELSE DO\n      IF SCOL2 = \"\" THEN SCOL2 = SCOL1 + LENGTH(SSTR) - 1\n   END\n   IF SCOL1 > LRECL THEN DO\n      MESG = \"COLUMN\" SCOL1 \"IS GREATER THAN LRECL OF FILE!\"\n      SIGNAL ERROR\n   END\n   IF SCOL2 > LRECL THEN DO\n      MESG = \"COLUMN\" SCOL2 \"IS GREATER THAN LRECL OF FILE!\"\n      SIGNAL ERROR\n   END\n   IF SCOL1 > SCOL2 THEN DO\n      TEMP  = SCOL1\n      SCOL1 = SCOL2\n      SCOL2 = TEMP\n   END\n\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n   START = 1\n   IF LBL1 <> '' THEN \"ISREDIT (START) = LINENUM &LBL1\"\n   IF LBL2 <> '' THEN \"ISREDIT (END)   = LINENUM &LBL2\"\n\n   IF START > END THEN DO\n      TEMP  = START\n      START = END\n      END   = TEMP\n   END\n\n   FALTNM  = 'FLE'\n   FNSSTR  = SSTR\n   FNSCOL1 = SCOL1\n   FNSCOL2 = SCOL2\n   FNSTART = START\n   FNEND   = END\n   ADDRESS ISPEXEC \"VPUT (FALTNM)  SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNSSTR)  SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNSCOL1) SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNSCOL2) SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNSTART) SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNEND)   SHARED\"\n\nREPEAT:\n\n   \"ISREDIT (LINE,COL) = CURSOR\"\n   SLEN  = LENGTH(SSTR)\n   SCOLS = SCOL2 - SCOL1 + 1\n   IF  ( LINE > START & LINE < END ),\n      |  ( RIND = 'YES' & LINE = START ) THEN START = LINE + 1\n\n   DO PNTR = START TO END\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      IF SCOLS > SLEN,\n         THEN DO\n            DO II = SCOL1 TO (SCOL1+SCOLS-SLEN)\n               IF SUBSTR(RECORD,II,SLEN) <= SSTR,\n                  THEN DO\n                     STR = 'FOUND!'\n                     CALL SETMSG '* NO ' STR '$FOUND LINE W/ <= STRING'\n                     WHERE = PNTR - 1\n                     \"ISREDIT LOCATE\" WHERE\n                     \"ISREDIT CURSOR = \" PNTR II\n                     SIGNAL EOJ\n                  END\n            END\n         END\n         ELSE DO\n            IF SUBSTR(RECORD,SCOL1,SLEN) <= SSTR,\n               THEN DO\n                  STR = 'FOUND!'\n                  CALL SETMSG '* NO ' STR '$FOUND LINE W/ <= STRING'\n                  WHERE = PNTR - 1\n                  \"ISREDIT LOCATE\" WHERE\n                  \"ISREDIT CURSOR = \" PNTR  SCOL1\n                  SIGNAL EOJ\n               END\n         END\n   END\n   STR = 'NOT FOUND!'\n   CALL SETMSG '* NO ' STR '$LINE W/ <= STRING NOT FOUND'\n   \"ISREDIT CURSOR = \" LINE COL\n   SIGNAL EOJ\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   CALL DISPDOC\n\nEOJ:\n   X = MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"FLE - FIND NEXT LINE W/ VALUE <= GIVEN STRING\"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"   FLE   STRING   ( COL-1 ( COL-2 ) )   ( .A .B )         \"\n   SAY\n   SAY \"       THE STRING MUST BE SPECIFIED.  THE COLUMNS AND THE \"\n   SAY \"       RANGES ARE OPTIONAL AND MAY BE INTERMIXED.         \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    FLE  'JOHNS' 11 15                               \"\n   SAY \"       WILL FIND THE NEXT LINE WHERE A VALUE LESS    \"\n   SAY \"       THAN OR EQUAL TO 'JOHNS' IS IN COLUMNS 11/15. \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FLT": {"ttr": 23045, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xf7\\x00\\xf7\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 247, "newlines": 247, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- FIND NEXT LINE W/ VALUE LESS THAN GIVEN STRING  **/\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'FLT MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (PARMS)\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY 'FLT EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT'\n      SIGNAL EOJ\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n\n   PARMS   = TRANSLATE(PARMS)\n   LBL1    = \"\"\n   LBL2    = \"\"\n   SCOL1   = \"\"\n   SCOL2   = \"\"\n   IF SUBSTR(PARMS,1,1) = \"'\"\n      THEN DO\n         PARMS = SUBSTR(PARMS,2)\n         QLOC  = INDEX(PARMS,\"'\")\n         SSTR  = SUBSTR(PARMS,1,QLOC-1)\n         PARMS = SUBSTR(PARMS,QLOC+1)\n      END\n      ELSE DO\n         IF SUBSTR(PARMS,1,1) = '\"'\n            THEN DO\n               PARMS = SUBSTR(PARMS,2)\n               QLOC  = INDEX(PARMS,'\"')\n               SSTR  = SUBSTR(PARMS,1,QLOC-1)\n               PARMS = SUBSTR(PARMS,QLOC+1)\n            END\n            ELSE DO\n               SSTR  = WORD(PARMS,1)\n               PARMS = SUBSTR(PARMS,LENGTH(SSTR)+1)\n            END\n      END\n   IF SSTR == \"\" THEN DO\n      ZEDSMSG = \"NO STRING RC=8\"\n      ZEDLMSG = \"MUST SPECIFY STRING\"\n      ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      SIGNAL DISPDOC\n   END\n   IF SSTR = '-=PFK=-' THEN DO;\n      ADDRESS ISPEXEC \"VGET (FNSSTR)  SHARED\"\n      ADDRESS ISPEXEC \"VGET (FNSCOL1) SHARED\"\n      ADDRESS ISPEXEC \"VGET (FNSCOL2) SHARED\"\n      ADDRESS ISPEXEC \"VGET (FNSTART) SHARED\"\n      ADDRESS ISPEXEC \"VGET (FNEND)   SHARED\"\n      RIND  = 'YES'\n      SSTR  = FNSSTR\n      SCOL1 = FNSCOL1\n      SCOL2 = FNSCOL2\n      START = FNSTART\n      END   = FNEND\n      SIGNAL REPEAT\n   END\n   ELSE RIND = 'NO'\n   DO II = 1 TO 4;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               SIGNAL DISPDOC\n            END\n      END\n      ELSE DO\n         IF DATATYPE(TOKEN,'W')  THEN DO\n            IF SCOL1 = \"\" THEN SCOL1 = TOKEN\n            ELSE IF SCOL2 = \"\" THEN SCOL2 = TOKEN\n               ELSE DO\n                  ZEDSMSG = \".LABEL RC=8\"\n                  ZEDLMSG = \"TOO MANY COLUMNS --\" SCOL1 SCOL2 TOKEN\n                  ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n                  SIGNAL DISPDOC\n               END\n         END\n         ELSE DO\n            ZEDSMSG = \"BAD PARM\"\n            ZEDLMSG = \"UNRECOGNIZED PARM --\" TOKEN\n            ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n            SIGNAL DISPDOC\n         END\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF SCOL1 = \"\" THEN DO\n      SCOL1 = 1\n      SCOL2 = LRECL\n   END\n   ELSE DO\n      IF SCOL2 = \"\" THEN SCOL2 = SCOL1 + LENGTH(SSTR) - 1\n   END\n   IF SCOL1 > LRECL THEN DO\n      MESG = \"COLUMN\" SCOL1 \"IS GREATER THAN LRECL OF FILE!\"\n      SIGNAL ERROR\n   END\n   IF SCOL2 > LRECL THEN DO\n      MESG = \"COLUMN\" SCOL2 \"IS GREATER THAN LRECL OF FILE!\"\n      SIGNAL ERROR\n   END\n   IF SCOL1 > SCOL2 THEN DO\n      TEMP  = SCOL1\n      SCOL1 = SCOL2\n      SCOL2 = TEMP\n   END\n\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n   START = 1\n   IF LBL1 <> '' THEN \"ISREDIT (START) = LINENUM &LBL1\"\n   IF LBL2 <> '' THEN \"ISREDIT (END)   = LINENUM &LBL2\"\n\n   IF START > END THEN DO\n      TEMP  = START\n      START = END\n      END   = TEMP\n   END\n\n   FALTNM  = 'FLT'\n   FNSSTR  = SSTR\n   FNSCOL1 = SCOL1\n   FNSCOL2 = SCOL2\n   FNSTART = START\n   FNEND   = END\n   ADDRESS ISPEXEC \"VPUT (FALTNM)  SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNSSTR)  SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNSCOL1) SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNSCOL2) SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNSTART) SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNEND)   SHARED\"\n\nREPEAT:\n\n   \"ISREDIT (LINE,COL) = CURSOR\"\n   SLEN  = LENGTH(SSTR)\n   SCOLS = SCOL2 - SCOL1 + 1\n   IF  ( LINE > START & LINE < END ),\n      |  ( RIND = 'YES' & LINE = START ) THEN START = LINE + 1\n\n   DO PNTR = START TO END\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      IF SCOLS > SLEN,\n         THEN DO\n            DO II = SCOL1 TO (SCOL1+SCOLS-SLEN)\n               IF SUBSTR(RECORD,II,SLEN) < SSTR,\n                  THEN DO\n                     STR = 'FOUND!'\n                     CALL SETMSG '* NO ' STR '$FOUND LINE W/ < STRING'\n                     WHERE = PNTR - 1\n                     \"ISREDIT LOCATE\" WHERE\n                     \"ISREDIT CURSOR = \" PNTR II\n                     SIGNAL EOJ\n                  END\n            END\n         END\n         ELSE DO\n            IF SUBSTR(RECORD,SCOL1,SLEN) < SSTR,\n               THEN DO\n                  STR = 'FOUND!'\n                  CALL SETMSG '* NO ' STR '$FOUND LINE W/ < STRING'\n                  WHERE = PNTR - 1\n                  \"ISREDIT LOCATE\" WHERE\n                  \"ISREDIT CURSOR = \" PNTR  SCOL1\n                  SIGNAL EOJ\n               END\n         END\n   END\n   STR = 'NOT FOUND!'\n   CALL SETMSG '* NO ' STR '$LINE W/ < STRING NOT FOUND'\n   \"ISREDIT CURSOR = \" LINE COL\n   SIGNAL EOJ\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   CALL DISPDOC\n\nEOJ:\n   X = MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"FLT - FIND NEXT LINE W/ VALUE LESS THAN GIVEN STRING       \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"   FLT   STRING   ( COL-1 ( COL-2 ) )   ( .A .B )         \"\n   SAY\n   SAY \"       THE STRING MUST BE SPECIFIED.  THE COLUMNS AND THE \"\n   SAY \"       RANGES ARE OPTIONAL AND MAY BE INTERMIXED.         \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    FLT  '2976' 11 14                                \"\n   SAY \"       WILL FIND THE NEXT LINE WHERE A VALUE LESS    \"\n   SAY \"       THAN '2976' IS IN COLUMNS 11/14.              \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FMAX": {"ttr": 23050, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x01D\\x01D\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 324, "newlines": 324, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- FIND LARGEST VALUE IN SPECIFIC COLUMN LOCATION(S)  **/\n   NUMERIC DIGITS 32\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'FMAX EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      RETURN\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      ADDRESS ISREDIT \"ISREDIT MACRO (PARMS)\"\n      PARMS = TRANSLATE(PARMS)\n   END\n   ELSE DO\n      SAY 'FMAX EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      RETURN\n   END\n\n   IF PARMS = '-=PFK=-' THEN DO;\n      ADDRESS ISPEXEC \"VGET (FBIGONE) SHARED\"\n      BIGGEST = FBIGONE\n      ADDRESS ISPEXEC \"VGET (FBIGCNT) SHARED\"\n      #BIGGEST = FBIGCNT\n      ADDRESS ISPEXEC \"VGET (FNSCOL1) SHARED\"\n      COL1    = FNSCOL1\n      ADDRESS ISPEXEC \"VGET (FNSCOL2) SHARED\"\n      COL2    = FNSCOL2\n      ADDRESS ISPEXEC \"VGET (FNSTART) SHARED\"\n      START   = FNSTART\n      ADDRESS ISPEXEC \"VGET (FNEND)   SHARED\"\n      END     = FNEND\n      ADDRESS ISPEXEC \"VGET (FPDIR)   SHARED\"\n      TYPE    = FPDIR\n\n      RECORD = \"\"\n      LEN = COL2 - COL1 + 1\n      DO II = START TO END,\n               WHILE SUBSTR(RECORD,COL1,LEN) <> BIGGEST\n         \"ISREDIT (RECORD) = LINE &II\"\n      END\n\n      IF II <= END,\n               | ( (II=(END+1)) & (SUBSTR(RECORD,COL1,LEN)=BIGGEST) )\n            THEN DO\n         FNSTART = II\n         II      = II - 1\n         ADDRESS ISPEXEC \"VPUT (FNSTART) SHARED\"\n         STR = 'FOUND!' || '/' || #BIGGEST\n         CALL SETMSG '* NO ' STR '$ANOTHER BIGGEST FOUND OVER TOTAL #'\n         \"ISREDIT LOCATE\" II\n         \"ISREDIT CURSOR = \" II COL1\n      END\n      ELSE DO\n         STR = 'NOT FOUND!' || '/' || #BIGGEST\n         CALL SETMSG '* NO ' STR '$NO MORE FOUND OVER TOTAL #'\n         II = FNSTART - 1\n         \"ISREDIT LOCATE\" II\n         \"ISREDIT CURSOR = \" II COL1\n      END\n      RETURN\n   END\n\n   COL1    = -1\n   COL2    = -1\n   LBL1    = \"\"\n   LBL2    = \"\"\n   TYPE    = \"CHAR\"\n   DO II = 1 TO 5;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n      END\n      ELSE DO\n         IF  DATATYPE(TOKEN,'W') THEN DO\n            IF COL1 = -1 THEN COL1 = TOKEN\n            ELSE IF COL2 = -1 THEN COL2 = TOKEN\n               ELSE DO\n                  ZEDSMSG = \".COLS RC=8\"\n                  ZEDLMSG = \"TOO MANY COLUMNS --\" COL1 COL2 TOKEN\n                  ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n                  EXIT 8\n               END\n         END\n         ELSE DO\n            IF TOKEN = 'C' THEN TYPE = 'CHAR'\n            ELSE IF TOKEN = 'Z' THEN TYPE = 'ZONED'\n            ELSE IF TOKEN = 'P' THEN TYPE = 'PACKED'\n            ELSE IF TOKEN = 'B' THEN TYPE = 'BINARY'\n               ELSE DO\n                  ZEDSMSG = \".UNKWN RC=8\"\n                  ZEDLMSG = \"UNKNOWN PARAMETER -\" TOKEN\n                  ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n                  EXIT 8\n               END\n         END\n      END\n   END II\n\n   ERRORMSG = ''\n   MESG     = ''\n   IF  COL1 = -1  |  COL2 = -1  THEN DO\n      MESG = 'PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF COL1 > COL2  THEN DO\n      TEMP = COL1\n      COL1 = COL2\n      COL2 = TEMP\n   END\n   IF COL1 > LRECL  THEN DO\n      MESG = \"'\"COL1\"' IS GREATER THAN RECORD SIZE(\"LRECL\")\"\n      SIGNAL ERROR\n   END\n   IF COL.2 > LRECL  THEN DO\n      MESG = \"'\"COL2\"' IS GREATER THAN RECORD SIZE(\"LRECL\")\"\n      SIGNAL ERROR\n   END\n\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n   IF LBL1 <> \"\" THEN DO\n      \"ISREDIT L &LBL1\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n   IF LBL2 <> \"\" THEN DO\n      \"ISREDIT L &LBL2\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   IF LBL1 <> \"\" THEN \"ISREDIT (START) = LINENUM &LBL1\"\n      ELSE START = 1\n   IF LBL2 <> \"\" THEN \"ISREDIT (END)   = LINENUM &LBL2\"\n      ELSE \"ISREDIT (END) = LINENUM .ZLAST\"\n   IF START > END THEN DO\n      FLIP  = START\n      START = END\n      END   = FLIP\n   END\n\n   IF TYPE = 'CHAR'\n      THEN BIGGEST = COPIES('00'X,COL2-COL1+1)\n      ELSE IF TYPE = 'ZONED'\n         THEN DO\n            BIGGEST  = COPIES('9',COL2-COL1) || 'R'\n            BIGGESTS = '-' || COPIES('9',COL2-COL1+1)\n         END\n         ELSE IF TYPE = 'PACKED'\n            THEN DO\n               BIGGEST  = COPIES('99'X,COL2-COL1) || '9D'X\n               BIGGESTS = '-' || COPIES('9',2*(COL2-COL1+1)-1)\n            END\n            ELSE DO\n               BIGGEST  = '80'X || COPIES('00'X,COL2-COL1)\n               BIGGESTS = '-' || COPIES('9',2*(COL2-COL1+1)+1)\n            END\n\n   FALTNM   = 'FMAX'\n   ADDRESS ISPEXEC \"VPUT (FALTNM)  SHARED\"\n   FBIGONE = BIGGEST\n   ADDRESS ISPEXEC \"VPUT (FBIGONE) SHARED\"\n   FBIGCNT = #BIGGEST\n   ADDRESS ISPEXEC \"VPUT (FBIGCNT) SHARED\"\n   FNSCOL1 = COL1\n   ADDRESS ISPEXEC \"VPUT (FNSCOL1) SHARED\"\n   FNSCOL2 = COL2\n   ADDRESS ISPEXEC \"VPUT (FNSCOL2) SHARED\"\n   FNSTART = START\n   ADDRESS ISPEXEC \"VPUT (FNSTART) SHARED\"\n   FNEND   = END\n   ADDRESS ISPEXEC \"VPUT (FNEND)   SHARED\"\n   FPDIR   = TYPE\n   ADDRESS ISPEXEC \"VPUT (FPDIR) SHARED\"\n\n   #BIGGEST = 0\n   @BIGGEST = 0\n   #TOTAL   = 0\n   LEN      = COL2 - COL1 + 1\n\n   DO PNTR =  START  TO  END  BY 1\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      #TOTAL = #TOTAL + 1\n      IF TYPE = 'CHAR'\n         THEN DO\n            IF SUBSTR(RECORD,COL1,LEN) > BIGGEST\n               THEN DO\n                  BIGGEST  = SUBSTR(RECORD,COL1,LEN)\n                  @BIGGEST = PNTR\n                  #BIGGEST = 1\n               END\n               ELSE IF SUBSTR(RECORD,COL1,LEN) = BIGGEST\n                  THEN #BIGGEST = #BIGGEST + 1\n         END\n         ELSE IF TYPE = 'ZONED'\n            THEN DO\n               IF VERIFY(SUBSTR(RECORD,COL2,1),'}JKLMNOPQR') = 0\n                  THEN DO;\n                     RECSLICE = '-' || SUBSTR(RECORD,COL1,LEN-1),\n                        || TRANSLATE(SUBSTR(RECORD,COL2,1),\n                              ,'0123456789','}JKLMNOPQR')\n                  END\n                  ELSE DO;\n                     RECSLICE = '+' || SUBSTR(RECORD,COL1,LEN-1),\n                        || TRANSLATE(SUBSTR(RECORD,COL2,1),\n                              ,'0123456789','{ABCDEFGHI')\n                  END\n               IF RECSLICE > BIGGESTS\n                  THEN DO\n                     BIGGEST  = SUBSTR(RECORD,COL1,LEN)\n                     BIGGESTS = RECSLICE\n                     @BIGGEST = PNTR\n                     #BIGGEST = 1\n                  END\n                  ELSE IF RECSLICE = BIGGESTS\n                     THEN #BIGGEST = #BIGGEST + 1\n            END\n         ELSE IF TYPE = 'PACKED'\n            THEN DO\n               IF VERIFY(SUBSTR(RECORD,COL2,1),\n                     ,'0D1D2D3D4D5D6D7D8D9D'X) = 0\n                  THEN DO;\n                     RECSLICE = '-',\n                        || C2X(SUBSTR(RECORD,COL1,COL2-COL1)),\n                        || TRANSLATE(SUBSTR(RECORD,COL2,1),\n                              ,'0123456789','0D1D2D3D4D5D6D7D8D9D'X)\n                  END\n                  ELSE DO;\n                     RECSLICE = '+',\n                        || C2X(SUBSTR(RECORD,COL1,COL2-COL1)),\n                        || TRANSLATE(SUBSTR(RECORD,COL2,1),\n                              ,'0123456789','0C1C2C3C4C5C6C7C8C9C'X)\n                  END\n               IF RECSLICE > BIGGESTS\n                  THEN DO\n                     BIGGEST  = SUBSTR(RECORD,COL1,LEN)\n                     BIGGESTS = RECSLICE\n                     @BIGGEST = PNTR\n                     #BIGGEST = 1\n                  END\n                  ELSE IF RECSLICE = BIGGESTS\n                     THEN #BIGGEST = #BIGGEST + 1\n            END\n         ELSE IF TYPE = 'BINARY'\n            THEN DO\n               RECSLICE = X2D(C2X(SUBSTR(RECORD,COL1,LEN)),(2*LEN))\n               IF RECSLICE > BIGGESTS\n                  THEN DO\n                     BIGGEST  = SUBSTR(RECORD,COL1,LEN)\n                     BIGGESTS = RECSLICE\n                     @BIGGEST = PNTR\n                     #BIGGEST = 1\n                  END\n                  ELSE IF RECSLICE = BIGGESTS\n                     THEN #BIGGEST = #BIGGEST + 1\n            END\n   END\n\n   FALTNM   = 'FMAX'\n   ADDRESS ISPEXEC \"VPUT (FALTNM)  SHARED\"\n   FBIGONE = BIGGEST\n   ADDRESS ISPEXEC \"VPUT (FBIGONE) SHARED\"\n   FBIGCNT = #BIGGEST\n   ADDRESS ISPEXEC \"VPUT (FBIGCNT) SHARED\"\n   FNSCOL1 = COL1\n   ADDRESS ISPEXEC \"VPUT (FNSCOL1) SHARED\"\n   FNSCOL2 = COL2\n   ADDRESS ISPEXEC \"VPUT (FNSCOL2) SHARED\"\n   FNSTART = @BIGGEST + 1\n   ADDRESS ISPEXEC \"VPUT (FNSTART) SHARED\"\n   FNEND   = END\n   ADDRESS ISPEXEC \"VPUT (FNEND)   SHARED\"\n   FPDIR   = TYPE\n   ADDRESS ISPEXEC \"VPUT (FPDIR)   SHARED\"\n\n   STR = #BIGGEST || '/' || #TOTAL\n   CALL SETMSG '* NO ' STR '$# BIGGEST FOUND OVER TOTAL #'\n   \"ISREDIT LOCATE\" @BIGGEST\n   \"ISREDIT CURSOR = \" @BIGGEST COL1\n   RETURN\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nERROR:\n   IF MESG <> '' THEN ERRORMSG = '===>' MESG\n   SIGNAL DISPDOC\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \" FMAX - FIND THE LARGEST VALUE \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    FMAX  LEFT-COL RIGHT-COL  ( TYPE )  ( .LAB1 .LAB2 ) \"\n   SAY\n   SAY \"       COLUMNS ARE MANDATORY. TYPE AND LABELS ARE OPTIONAL  \"\n   SAY \"       AND MAY BE INTERMIXED WITH THE COLUMN VALUES.  TYPE  \"\n   SAY \"       DEFAULTS TO 'C' FOR CHARACTER OR SIGNED CHARACTER;   \"\n   SAY \"       OTHER VALUES ARE 'P' FOR PACKED, 'B' FOR BINARY AND  \"\n   SAY \"       'Z' FOR ZONED.                                       \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    FMAX  P  41 45                         \"\n   SAY \"       WILL FIND LARGEST PACKED VALUE IN   \"\n   SAY \"       COLUMNS 41 THROUGH 45.              \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FMDOUBLE": {"ttr": 23301, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x000\\x000\\x00\\x00\\xc5\\xe9\\xc3\\xc1\\xd3\\xd3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "EZCALL"}, "text": "//-YOUR-USERID-F JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//*** SUB PROGRAM TO GET COMP-2 # AND RETURN DISPLAY\n//***\n//C          EXEC     PGM=IGYCRCTL,REGION=4M,\n//             PARM=('LIB,MAP,NUMPROC(PFD),OFF,OPTIMIZE',\n//            'APOST,NOSEQ,TRUNC(OPT),XREF')\n//SYSIN        DD       *\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  FRMFLOAT.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  LINK-STORE.\n           05  FROM-NUMBER      COMP-2.\n           05  TO-NUMBER        PIC 9(13)V99.\n       PROCEDURE DIVISION USING LINK-STORE.\n       0000-MAIN.\n              COMPUTE TO-NUMBER = FROM-NUMBER\n              GOBACK\n              .\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SYSLIB-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=SYSDA,SPACE=(TRK,(3,3)),\n//             DCB=(BLKSIZE=80,LRECL=80,RECFM=FB)\n//SYSUT1       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT2       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT3       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT4       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT5       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT6       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT7       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//***\n//L          EXEC     PGM=HEWL,COND=(4,LT),REGION=4M,\n//             PARM='RENT,AMODE(31),RMODE(ANY),XREF,LIST,LET,DCBS'\n//SYSLIB       DD       DSNAME=-YOUR-SCEELLED-,DISP=SHR\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,\n//             DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   03081100\n  ENTRY    FRMFLOAT\n  NAME     FRMFLOAT(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FMIN": {"ttr": 23303, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x01D\\x01D\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 324, "newlines": 324, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- FIND SMALLEST VALUE IN SPECIFIC COLUMN LOCATION(S)  **/\n   NUMERIC DIGITS 32\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'FMIN EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      RETURN\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      ADDRESS ISREDIT \"ISREDIT MACRO (PARMS)\"\n      PARMS = TRANSLATE(PARMS)\n   END\n   ELSE DO\n      SAY 'FMIN EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      RETURN\n   END\n\n   IF PARMS = '-=PFK=-' THEN DO;\n      ADDRESS ISPEXEC \"VGET (FBIGONE) SHARED\"\n      SMALLEST = FBIGONE\n      ADDRESS ISPEXEC \"VGET (FBIGCNT) SHARED\"\n      #SMALLEST = FBIGCNT\n      ADDRESS ISPEXEC \"VGET (FNSCOL1) SHARED\"\n      COL1    = FNSCOL1\n      ADDRESS ISPEXEC \"VGET (FNSCOL2) SHARED\"\n      COL2    = FNSCOL2\n      ADDRESS ISPEXEC \"VGET (FNSTART) SHARED\"\n      START   = FNSTART\n      ADDRESS ISPEXEC \"VGET (FNEND)   SHARED\"\n      END     = FNEND\n      ADDRESS ISPEXEC \"VGET (FPDIR)   SHARED\"\n      TYPE    = FPDIR\n\n      RECORD = \"\"\n      LEN = COL2 - COL1 + 1\n      DO II = START TO END,\n               WHILE SUBSTR(RECORD,COL1,LEN) <> SMALLEST\n         \"ISREDIT (RECORD) = LINE &II\"\n      END\n\n      IF II <= END,\n               | ( (II=(END+1)) & (SUBSTR(RECORD,COL1,LEN)=SMALLEST) )\n            THEN DO\n         FNSTART = II\n         II      = II - 1\n         ADDRESS ISPEXEC \"VPUT (FNSTART) SHARED\"\n         STR = 'FOUND!' || '/' || #SMALLEST\n         CALL SETMSG '* NO ' STR '$ANOTHER SMALLEST FOUND OVER TOTAL #'\n         \"ISREDIT LOCATE\" II\n         \"ISREDIT CURSOR = \" II COL1\n      END\n      ELSE DO\n         STR = 'NOT FOUND!' || '/' || #SMALLEST\n         CALL SETMSG '* NO ' STR '$NO MORE FOUND OVER TOTAL #'\n         II = FNSTART - 1\n         \"ISREDIT LOCATE\" II\n         \"ISREDIT CURSOR = \" II COL1\n      END\n      RETURN\n   END\n\n   COL1    = -1\n   COL2    = -1\n   LBL1    = \"\"\n   LBL2    = \"\"\n   TYPE    = \"CHAR\"\n   DO II = 1 TO 5;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n      END\n      ELSE DO\n         IF  DATATYPE(TOKEN,'W') THEN DO\n            IF COL1 = -1 THEN COL1 = TOKEN\n            ELSE IF COL2 = -1 THEN COL2 = TOKEN\n               ELSE DO\n                  ZEDSMSG = \".COLS RC=8\"\n                  ZEDLMSG = \"TOO MANY COLUMNS --\" COL1 COL2 TOKEN\n                  ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n                  EXIT 8\n               END\n         END\n         ELSE DO\n            IF TOKEN = 'C' THEN TYPE = 'CHAR'\n            ELSE IF TOKEN = 'Z' THEN TYPE = 'ZONED'\n            ELSE IF TOKEN = 'P' THEN TYPE = 'PACKED'\n            ELSE IF TOKEN = 'B' THEN TYPE = 'BINARY'\n               ELSE DO\n                  ZEDSMSG = \".UNKWN RC=8\"\n                  ZEDLMSG = \"UNKNOWN PARAMETER -\" TOKEN\n                  ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n                  EXIT 8\n               END\n         END\n      END\n   END II\n\n   ERRORMSG = ''\n   MESG     = ''\n   IF  COL1 = -1  |  COL2 = -1  THEN DO\n      MESG = 'PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF COL1 > COL2  THEN DO\n      TEMP = COL1\n      COL1 = COL2\n      COL2 = TEMP\n   END\n   IF COL1 > LRECL  THEN DO\n      MESG = \"'\"COL1\"' IS GREATER THAN RECORD SIZE(\"LRECL\")\"\n      SIGNAL ERROR\n   END\n   IF COL.2 > LRECL  THEN DO\n      MESG = \"'\"COL2\"' IS GREATER THAN RECORD SIZE(\"LRECL\")\"\n      SIGNAL ERROR\n   END\n\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n   IF LBL1 <> \"\" THEN DO\n      \"ISREDIT L &LBL1\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n   IF LBL2 <> \"\" THEN DO\n      \"ISREDIT L &LBL2\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   IF LBL1 <> \"\" THEN \"ISREDIT (START) = LINENUM &LBL1\"\n      ELSE START = 1\n   IF LBL2 <> \"\" THEN \"ISREDIT (END)   = LINENUM &LBL2\"\n      ELSE \"ISREDIT (END) = LINENUM .ZLAST\"\n   IF START > END THEN DO\n      FLIP  = START\n      START = END\n      END   = FLIP\n   END\n\n   IF TYPE = 'CHAR'\n      THEN SMALLEST = COPIES('FF'X,COL2-COL1+1)\n      ELSE IF TYPE = 'ZONED'\n         THEN DO\n            SMALLEST = COPIES('9',COL2-COL1) || 'I'\n            SMALLESTS = '+' || COPIES('9',COL2-COL1+1)\n         END\n         ELSE IF TYPE = 'PACKED'\n            THEN DO\n               SMALLEST = COPIES('99'X,COL2-COL1) || '9C'X\n               SMALLESTS = '+' || COPIES('9',2*(COL2-COL1+1)-1)\n            END\n            ELSE DO\n               SMALLEST = '7F'X || COPIES('FF'X,COL2-COL1)\n               SMALLESTS = '+' || COPIES('9',2*(COL2-COL1+1)+1)\n            END\n\n   FALTNM   = 'FMIN'\n   ADDRESS ISPEXEC \"VPUT (FALTNM)  SHARED\"\n   FBIGONE = SMALLEST\n   ADDRESS ISPEXEC \"VPUT (FBIGONE) SHARED\"\n   FBIGCNT = #SMALLEST\n   ADDRESS ISPEXEC \"VPUT (FBIGCNT) SHARED\"\n   FNSCOL1 = COL1\n   ADDRESS ISPEXEC \"VPUT (FNSCOL1) SHARED\"\n   FNSCOL2 = COL2\n   ADDRESS ISPEXEC \"VPUT (FNSCOL2) SHARED\"\n   FNSTART = START\n   ADDRESS ISPEXEC \"VPUT (FNSTART) SHARED\"\n   FNEND   = END\n   ADDRESS ISPEXEC \"VPUT (FNEND)   SHARED\"\n   FPDIR   = TYPE\n   ADDRESS ISPEXEC \"VPUT (FPDIR) SHARED\"\n\n   #SMALLEST = 0\n   @SMALLEST = 0\n   #TOTAL   = 0\n   LEN      = COL2 - COL1 + 1\n\n   DO PNTR =  START  TO  END  BY 1\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      #TOTAL = #TOTAL + 1\n      IF TYPE = 'CHAR'\n         THEN DO\n            IF SUBSTR(RECORD,COL1,LEN) < SMALLEST\n               THEN DO\n                  SMALLEST = SUBSTR(RECORD,COL1,LEN)\n                  @SMALLEST = PNTR\n                  #SMALLEST = 1\n               END\n               ELSE IF SUBSTR(RECORD,COL1,LEN) = SMALLEST\n                  THEN #SMALLEST = #SMALLEST + 1\n         END\n         ELSE IF TYPE = 'ZONED'\n            THEN DO\n               IF VERIFY(SUBSTR(RECORD,COL2,1),'}JKLMNOPQR') = 0\n                  THEN DO;\n                     RECSLICE = '-' || SUBSTR(RECORD,COL1,LEN-1),\n                        || TRANSLATE(SUBSTR(RECORD,COL2,1),\n                              ,'0123456789','}JKLMNOPQR')\n                  END\n                  ELSE DO;\n                     RECSLICE = '+' || SUBSTR(RECORD,COL1,LEN-1),\n                        || TRANSLATE(SUBSTR(RECORD,COL2,1),\n                              ,'0123456789','{ABCDEFGHI')\n                  END\n               IF RECSLICE < SMALLESTS\n                  THEN DO\n                     SMALLEST  = SUBSTR(RECORD,COL1,LEN)\n                     SMALLESTS = RECSLICE\n                     @SMALLEST = PNTR\n                     #SMALLEST = 1\n                  END\n                  ELSE IF RECSLICE = SMALLESTS\n                     THEN #SMALLEST = #SMALLEST + 1\n            END\n         ELSE IF TYPE = 'PACKED'\n            THEN DO\n               IF VERIFY(SUBSTR(RECORD,COL2,1),\n                     ,'0D1D2D3D4D5D6D7D8D9D'X) = 0\n                  THEN DO;\n                     RECSLICE = '-',\n                        || C2X(SUBSTR(RECORD,COL1,COL2-COL1)),\n                        || TRANSLATE(SUBSTR(RECORD,COL2,1),\n                              ,'0123456789','0D1D2D3D4D5D6D7D8D9D'X)\n                  END\n                  ELSE DO;\n                     RECSLICE = '+',\n                        || C2X(SUBSTR(RECORD,COL1,COL2-COL1)),\n                        || TRANSLATE(SUBSTR(RECORD,COL2,1),\n                              ,'0123456789','0C1C2C3C4C5C6C7C8C9C'X)\n                  END\n               IF RECSLICE < SMALLESTS\n                  THEN DO\n                     SMALLEST  = SUBSTR(RECORD,COL1,LEN)\n                     SMALLESTS = RECSLICE\n                     @SMALLEST = PNTR\n                     #SMALLEST = 1\n                  END\n                  ELSE IF RECSLICE = SMALLESTS\n                     THEN #SMALLEST = #SMALLEST + 1\n            END\n         ELSE IF TYPE = 'BINARY'\n            THEN DO\n               RECSLICE = X2D(C2X(SUBSTR(RECORD,COL1,LEN)),(2*LEN))\n               IF RECSLICE < SMALLESTS\n                  THEN DO\n                     SMALLEST  = SUBSTR(RECORD,COL1,LEN)\n                     SMALLESTS = RECSLICE\n                     @SMALLEST = PNTR\n                     #SMALLEST = 1\n                  END\n                  ELSE IF RECSLICE = SMALLESTS\n                     THEN #SMALLEST = #SMALLEST + 1\n            END\n   END\n\n   FALTNM   = 'FMIN'\n   ADDRESS ISPEXEC \"VPUT (FALTNM)  SHARED\"\n   FBIGONE = SMALLEST\n   ADDRESS ISPEXEC \"VPUT (FBIGONE) SHARED\"\n   FBIGCNT = #SMALLEST\n   ADDRESS ISPEXEC \"VPUT (FBIGCNT) SHARED\"\n   FNSCOL1 = COL1\n   ADDRESS ISPEXEC \"VPUT (FNSCOL1) SHARED\"\n   FNSCOL2 = COL2\n   ADDRESS ISPEXEC \"VPUT (FNSCOL2) SHARED\"\n   FNSTART = @SMALLEST + 1\n   ADDRESS ISPEXEC \"VPUT (FNSTART) SHARED\"\n   FNEND   = END\n   ADDRESS ISPEXEC \"VPUT (FNEND)   SHARED\"\n   FPDIR   = TYPE\n   ADDRESS ISPEXEC \"VPUT (FPDIR)   SHARED\"\n\n   STR = #SMALLEST || '/' || #TOTAL\n   CALL SETMSG '* NO ' STR '$# SMALLEST FOUND OVER TOTAL #'\n   \"ISREDIT LOCATE\" @SMALLEST\n   \"ISREDIT CURSOR = \" @SMALLEST COL1\n   RETURN\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nERROR:\n   IF MESG <> '' THEN ERRORMSG = '===>' MESG\n   SIGNAL DISPDOC\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \" FMIN - FIND THE SMALLEST VALUE \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    FMIN  LEFT-COL RIGHT-COL  ( TYPE )  ( .LAB1 .LAB2 )     \"\n   SAY\n   SAY \"       COLUMNS ARE MANDATORY. TYPE AND LABELS ARE OPTIONAL  \"\n   SAY \"       AND MAY BE INTERMIXED WITH THE COLUMN VALUES.  TYPE  \"\n   SAY \"       DEFAULTS TO 'C' FOR CHARACTER OR SIGNED CHARACTER;   \"\n   SAY \"       OTHER VALUES ARE 'P' FOR PACKED, 'B' FOR BINARY AND  \"\n   SAY \"       'Z' FOR ZONED.                                       \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    FMIN  P  41 45                         \"\n   SAY \"       WILL FIND SMALLEST PACKED VALUE IN  \"\n   SAY \"       COLUMNS 41 THROUGH 45.              \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FN": {"ttr": 23553, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xf7\\x00\\xf7\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 247, "newlines": 247, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- FIND NEXT LINE W/O GIVEN STRING  **/\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'FN MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (PARMS)\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY FN 'EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT'\n      SIGNAL EOJ\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n\n   PARMS   = TRANSLATE(PARMS)\n   LBL1    = \"\"\n   LBL2    = \"\"\n   SCOL1   = \"\"\n   SCOL2   = \"\"\n   IF SUBSTR(PARMS,1,1) = \"'\"\n      THEN DO\n         PARMS = SUBSTR(PARMS,2)\n         QLOC  = INDEX(PARMS,\"'\")\n         SSTR  = SUBSTR(PARMS,1,QLOC-1)\n         PARMS = SUBSTR(PARMS,QLOC+1)\n      END\n      ELSE DO\n         IF SUBSTR(PARMS,1,1) = '\"'\n            THEN DO\n               PARMS = SUBSTR(PARMS,2)\n               QLOC  = INDEX(PARMS,'\"')\n               SSTR  = SUBSTR(PARMS,1,QLOC-1)\n               PARMS = SUBSTR(PARMS,QLOC+1)\n            END\n            ELSE DO\n               SSTR  = WORD(PARMS,1)\n               PARMS = SUBSTR(PARMS,LENGTH(SSTR)+1)\n            END\n      END\n   IF SSTR == \"\" THEN DO\n      ZEDSMSG = \"NO STRING RC=8\"\n      ZEDLMSG = \"MUST SPECIFY STRING\"\n      ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      SIGNAL DISPDOC\n   END\n   IF SSTR = '-=PFK=-' THEN DO;\n      ADDRESS ISPEXEC \"VGET (FNSSTR)  SHARED\"\n      ADDRESS ISPEXEC \"VGET (FNSCOL1) SHARED\"\n      ADDRESS ISPEXEC \"VGET (FNSCOL2) SHARED\"\n      ADDRESS ISPEXEC \"VGET (FNSTART) SHARED\"\n      ADDRESS ISPEXEC \"VGET (FNEND)   SHARED\"\n      RIND  = 'YES'\n      SSTR  = FNSSTR\n      SCOL1 = FNSCOL1\n      SCOL2 = FNSCOL2\n      START = FNSTART\n      END   = FNEND\n      SIGNAL REPEAT\n   END\n   ELSE RIND = 'NO'\n\n   DO II = 1 TO 4;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               SIGNAL DISPDOC\n            END\n      END\n      ELSE DO\n         IF DATATYPE(TOKEN,'W')  THEN DO\n            IF SCOL1 = \"\" THEN SCOL1 = TOKEN\n            ELSE IF SCOL2 = \"\" THEN SCOL2 = TOKEN\n               ELSE DO\n                  ZEDSMSG = \".LABEL RC=8\"\n                  ZEDLMSG = \"TOO MANY COLUMNS --\" SCOL1 SCOL2 TOKEN\n                  ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n                  SIGNAL DISPDOC\n               END\n         END\n         ELSE DO\n            ZEDSMSG = \"BAD PARM\"\n            ZEDLMSG = \"UNRECOGNIZED PARM --\" TOKEN\n            ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n            SIGNAL DISPDOC\n         END\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF SCOL1 = \"\" THEN DO\n      SCOL1 = 1\n      SCOL2 = LRECL\n   END\n   ELSE DO\n      IF SCOL2 = \"\" THEN SCOL2 = SCOL1 + LENGTH(SSTR) - 1\n   END\n   IF SCOL1 > LRECL THEN DO\n      MESG = \"COLUMN\" SCOL1 \"IS GREATER THAN LRECL OF FILE!\"\n      SIGNAL ERROR\n   END\n   IF SCOL2 > LRECL THEN DO\n      MESG = \"COLUMN\" SCOL2 \"IS GREATER THAN LRECL OF FILE!\"\n      SIGNAL ERROR\n   END\n   IF SCOL1 > SCOL2 THEN DO\n      TEMP  = SCOL1\n      SCOL1 = SCOL2\n      SCOL2 = TEMP\n   END\n\n   START = 1\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n   IF LBL1 <> '' THEN \"ISREDIT (START) = LINENUM &LBL1\"\n   IF LBL2 <> '' THEN \"ISREDIT (END)   = LINENUM &LBL2\"\n\n   IF START > END THEN DO\n      TEMP  = START\n      START = END\n      END   = TEMP\n   END\n\n   FALTNM  = 'FN'\n   FNSSTR  = SSTR\n   FNSCOL1 = SCOL1\n   FNSCOL2 = SCOL2\n   FNSTART = START\n   FNEND   = END\n   ADDRESS ISPEXEC \"VPUT (FALTNM)  SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNSSTR)  SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNSCOL1) SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNSCOL2) SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNSTART) SHARED\"\n   ADDRESS ISPEXEC \"VPUT (FNEND)   SHARED\"\n\nREPEAT:\n\n   \"ISREDIT (LINE,COL) = CURSOR\"\n   SLEN  = LENGTH(SSTR)\n   SCOLS = SCOL2 - SCOL1 + 1\n   IF  ( LINE > START & LINE < END ),\n      |  ( RIND = 'YES' & LINE = START ) THEN START = LINE + 1\n\n   DO PNTR = START TO END\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      IF SCOLS > SLEN,\n         THEN DO\n            IF INDEX(SUBSTR(RECORD,SCOL1,SCOLS),SSTR) = 0,\n               THEN DO\n                  STR = 'FOUND!'\n                  CALL SETMSG '* NO ' STR '$FOUND LINE W/O STRING'\n                  WHERE = PNTR - 1\n                  \"ISREDIT LOCATE\" WHERE\n                  \"ISREDIT CURSOR = \" PNTR SCOL1\n                  SIGNAL EOJ\n               END\n         END\n         ELSE DO\n            IF SUBSTR(RECORD,SCOL1,SLEN) <> SSTR,\n               THEN DO\n                  STR = 'FOUND!'\n                  CALL SETMSG '* NO ' STR '$FOUND LINE W/O STRING'\n                  WHERE = PNTR - 1\n                  \"ISREDIT LOCATE\" WHERE\n                  \"ISREDIT CURSOR = \" PNTR  SCOL1\n                  SIGNAL EOJ\n               END\n         END\n   END\n   STR = 'NOT FOUND!'\n   CALL SETMSG '* NO ' STR '$LINE W/O STRING NOT FOUND'\n   \"ISREDIT CURSOR = \" LINE COL\n   SIGNAL EOJ\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   CALL DISPDOC\n\nEOJ:\n   X = MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"FN - FIND NEXT LINE W/O GIVEN STRING (FIND NOT EQUAL)     \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    FN   STRING   ( COL-1 ( COL-2 ) )   ( .A .B )         \"\n   SAY\n   SAY \"       THE STRING MUST BE SPECIFIED.  THE COLUMNS AND THE \"\n   SAY \"       RANGES ARE OPTIONAL AND MAY BE INTERMIXED.         \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    FN   'CLIST'  11 15                              \"\n   SAY \"       WILL FIND THE NEXT LINE WHERE NO 'CLIST' IS   \"\n   SAY \"       IN COLUMN 11. IF FALT IS ASSIGNED TO A PF KEY,\"\n   SAY \"       YOU CAN REPEAT THE 'FIND NOT.'                \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FNB": {"ttr": 23558, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00'\\x00'\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- FIND NON BLANKS  **/\n\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'FNB EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      RETURN\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      ADDRESS ISREDIT \"ISREDIT MACRO (COL1 COL2) NOPROCESS\"\n   END\n   ELSE DO\n      SAY 'FNB EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      RETURN\n   END\n\n   IF SUBSTR(COL1,1,1) = '?' THEN SIGNAL DISPDOC\n   IF COL1 = '' THEN COL1 = 73\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF COL2 = '' THEN COL2 = LRECL\n   \"ISREDIT  F  P'\u00ac'\"   COL1  COL2\n   IF RC = 0 THEN EXIT 0\n             ELSE EXIT 1\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"FNB  -  FIND NON BLANK \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"   FNB  ( STARTING-COLUMN  ( ENDING-COLUMN ) )  ( ? )\"\n   SAY\n   SAY \"       WILL FIND THE NON BLANK CHARACTER, IF ANY, IN \"\n   SAY \"       COLUMNS 73 ONWARDS (THE DEFAULT) OR FROM THE  \"\n   SAY \"       STARTING-COLUMN THROUGH THE ENDING-COLUMN OR  \"\n   SAY \"       THE FAR MOST RIGHT HAND BYTE. USE THE REPEAT  \"\n   SAY \"       KEY (PF KEY 5 USUALLY) TO CONTINUE.           \"\n   SAY\n   RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FNOT": {"ttr": 23560, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\xcf\\x00\\xcf\\x00\\x00\\xc3\\xd3\\xc9\\xe2\\xe3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 207, "newlines": 207, "modlines": 0, "user": "CLIST"}, "text": "            CONTROL ASIS\n /*  TITLE:       FNOT    -- EXCLUDE EVERYTHING AND THEN     */\n /*                          FIND AND DISPLAY EVERY LINE     */\n /*                          WITH NONE OF THE SPECIFIED      */\n /*                          STRING                          */\n /*  EXAMPLE:    ===> FNOT     'A' B 'C'                     */\n /*  OPTIONS:                                                */\n /*      <LIST>     (REQUIRED)  STRINGS SUITABLE FOR A FIND  */\n /*      LBL-RANGE  (OPTIONAL)  LABEL  RANGE                 */\n /*      NX | X     (OPTIONAL)  LIMIT TO EXCLUDED OR NOT     */\n   ISREDIT  MACRO (TOK1,TOK2,TOK3,TOK4,TOK5,TOK6,TOK7,TOK8,TOK9,TOK10,+\n          TOK11,TOK12,TOK13,+\n          TOK14,TOK15,TOK16,TOK17,TOK18,TOK19,TOK20,TOK21,TOK22,TOK23,+\n          TOK24,TOK25,TOK26,+\n          TOK27,TOK28,TOK29,TOK30,TOK31,TOK32,TOK33,TOK34,TOK35,TOK36,+\n          TOK37,TOK38,TOK39,+\n          TOK40,TOK41,TOK42,TOK43,TOK44,TOK45,TOK46,TOK47,TOK48)\n   ISREDIT (IMAC) = IMACRO\n   SET R  = 0\n   SET SETX  = 0\n   SET SETNX  = 0\n   SET I = 1\n   DO WHILE &I <= 48\n      SET TOKEN = &&TOK&I\n      SET TOKEN = &STR(&SYSCAPS(&TOKEN))\n      IF &STR(&TOKEN) = &STR() THEN GOTO END_TOK\n      IF ALL = &STR(&TOKEN) | NEXT = &STR(&TOKEN) | FIRST = +\n         &STR(&TOKEN) | LAST = &STR(&TOKEN) | PREV = &STR(&TOKEN) +\n            THEN DO\n               SET &ZEDSMSG = &STR(&TOKEN INVALID)\n               SET &ZEDLMSG = &STR(\"&TOKEN\" NOT PROVIDED FOR +\n                  NOR ARE NEXT ALL FIRST LAST PREV)\n               ISPEXEC   SETMSG MSG(ISRZ000)\n               EXIT CODE(12)\n            END\n      IF &SUBSTR(1:6,&STR(&TOKEN)       ) = &STR(BEGIN&STR(&LP))  +\n         THEN DO\n            SET BEGIN = &SUBSTR(7:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n               &STR(&TOKEN)         )\n            GOTO NXT_TOK\n         END\n      IF &STR(&TOKEN) = NX THEN DO\n         SET NX = NX\n         GOTO NXT_TOK\n      END\n      IF &STR(&TOKEN) = X THEN DO\n         SET X = X\n         GOTO NXT_TOK\n      END\n      IF &STR(&TOKEN) = WORD | &STR(&TOKEN) = CHAR | &STR(&TOKEN) = +\n            CHARS | &STR(&TOKEN) = PREFIX | &STR(&TOKEN) = SUFFIX +\n         THEN DO\n            IF &STR(&WORD) \u00ac= &STR() THEN DO\n               SET &ZEDSMSG = &STR(INCONSISTENT PARAMETERS)\n               SET &ZEDLMSG = &STR('&WORD' AND '&TOKEN' CANNOT BOTH BE +\n                  SPECIFIED FOR XEVERY CMD.)\n               ISPEXEC     SETMSG MSG(ISRZ000)\n            END\n            SET WORD = &STR( &TOKEN.)\n            GOTO NXT_TOK\n         END\n      IF &STR(&TOKEN) = LEFT THEN DO        /* LEFT | RIGHT */\n         SET LEFT = LEFT\n         GOTO NXT_TOK\n      END\n      IF &STR(&TOKEN) = RIGHT THEN DO\n         SET RIGHT = RIGHT\n         GOTO NXT_TOK\n      END\n      IF &SUBSTR(1,&TOKEN) = &STR(.) THEN DO\n         IF &LABF = &STR() THEN DO\n            SET LABF = &STR(&TOKEN)\n            GOTO NXT_TOK\n         END\n         IF &STR(&LABL) = &STR() THEN DO\n            SET LABL = &STR(&TOKEN)\n            GOTO NXT_TOK\n         END\n         SET &ZEDSMSG = &STR(LABEL &STR(&TOKEN))\n         SET &ZEDLMSG = &STR(EXACTLY TWO LABELS ARE REQUIRED FOUND +\n            \"&LABF\", \"&LABL\" AND  \"&STR(&TOKEN)\")\n         ISPEXEC   SETMSG MSG(ISRZ000)\n         EXIT CODE(12)\n      END\n      IF &STR(&TOKEN) = &STR()) THEN DO\n         SET &ZEDSMSG = &STR(LOST PARENTHESIS)\n         SET &ZEDLMSG = BLANKS SEPARATE ALL OPERANDS; THEREFORE +\n            INVALID IN FROM() TO() COL() BEGIN()\n         ISPEXEC SETMSG MSG(ISRZ000)\n         EXIT CODE(12)\n      END\n      SET REMAIN = &STR(&REMAIN &STR(&TOKEN))\n      SET R = &R + 1\n      SET FIND&R = &STR(&TOKEN)\n NXT_TOK: -\n      SET I = &I + 1\n      END\n END_TOK: SET I = &I\n      SET RMAX = &R\n      IF &STR(&FIND1) = &STR() THEN DO\n         SET &ZEDSMSG = &STR(FIND STRINGS)\n         SET &ZEDLMSG = &STR(&ZEDSMSG ARE MISSING)\n         ISPEXEC     SETMSG MSG(ISRZ000)\n         EXIT CODE(12)\n      END\n      IF &LABL = &STR() AND &LABF \u00ac= &STR() THEN DO\n         SET &ZEDSMSG = &STR(LABEL MISSING)\n         SET &ZEDLMSG = &STR(TWO LABELS MUST BE INDICATED FOR A RANGE)\n         ISPEXEC     SETMSG MSG(ISRZ000)\n      END\n      IF &LABF = &STR() THEN SET LABF = &STR(.ZFIRST)\n      IF &LABL = &STR() THEN SET LABL = &STR(.ZLAST)\n      ISREDIT (#LABF) = LINENUM &LABF\n      IF &LASTCC \u00ac= 0 THEN DO\n         SET &ZEDSMSG = &STR(&LABF. LABEL)\n         SET &ZEDLMSG = &STR(&ZEDSMSG DOES NOT EXIST)\n         ISPEXEC     SETMSG MSG(ISRZ000)\n         EXIT CODE(12)\n      END\n      ISREDIT (#LABL) = LINENUM &LABL\n      IF &LASTCC \u00ac= 0 THEN DO\n         SET &ZEDSMSG = &STR(&LABL. LABEL)\n         SET &ZEDLMSG = &STR(&ZEDSMSG DOES NOT EXIST)\n         ISPEXEC     SETMSG MSG(ISRZ000)\n         EXIT CODE(12)\n      END\n                                   /**  END OF LABEL REQUIREMENTS  **/\n      ISREDIT (DWIDTH) = DATA_WIDTH\n      SET DWIDTH2 = &DWIDTH + &DWIDTH\n                               /**  CAN BE USED TO FORCE AN ERROR  **/\n      ISREDIT (LBOUND,RBOUND) = BOUNDS\n      ISREDIT (VAR057) = RECFM\n      ISREDIT (VAR049,VAR050) = NUMBER\n      SET LLBOUND = &LBOUND\n      SET LLADJ = 0\n      IF &VAR057 = V AND &VAR049 = ON THEN DO\n         SET LLADJ = 8\n         SET LLBOUND = &LBOUND + 8\n      END\n                   /**  BEGIN OF INTERFACE TO COMMON PATTERN CLIST  **/\n      IF &X = X AND &NX = NX THEN DO\n         SET X =\n         SET NX =\n      END\n                   /**  END OF INTERFACE TO COMMON PATTERN CLIST  **/\n      IF &EVAL(&#LABL.) < &EVAL(&#LABF.) THEN DO\n         SET &ZEDSMSG = &STR(LABEL ERR .LABF/L)\n         SET &ZEDLMSG = &STR(&LABF MUST APPEAR EARLIER THAN +\n             &LABL)\n         ISPEXEC     SETMSG MSG(ISRZ000)\n         EXIT CODE(12)\n      END\n      SET I = &#LABF\n      SET CNT = 0\n      DO WHILE &I <= &#LABL\n         ISREDIT (VAR075) = XSTATUS &I\n         IF &VAR075 = &NX OR &VAR075 = &X OR  &STR(&X&NX) = +\n            &STR() THEN DO\n               SET R = 1\n               DO WHILE &R <= &RMAX\n                  ISREDIT LABEL &I = .POINT\n                  SET TOKEN = &STR(&&FIND&R)\n                  SET TOKEN = &STR(&TOKEN)\n                  ISREDIT SEEK .POINT .POINT &TOKEN. &WORD. ALL\n                  IF &LASTCC = 0 THEN SET R = &RMAX + 99\n                  SET R = &R + 1\n               END\n               SET RR = &RMAX + 50\n               IF &R < &RR THEN GOTO NFOUND\n               ISREDIT EXCLUDE .POINT .POINT ALL\n               IF &VAR075 = NX THEN SET SETX = 0&SETX + 1\n               IF &VAR075 = X THEN DO\n                  SET SETNX = 0&SETNX + 1\n                  ISREDIT XSTATUS .POINT = NX\n               END\n               GOTO NXTT_I\nNFOUND: -\n               SET CNT = &CNT + 1\n               IF &VAR075 = X THEN DO\n                  SET SETNX = 0&SETNX + 1\n                  ISREDIT XSTATUS .POINT = NX\n               END\n            END\nNXTT_I: -\n         SET I = &I. + 1\n      END\nNONE: -\n      SET &ZEDSMSG = &STR(FOUND )&CNT\n      SET XXX = &STR()\n      IF &EVAL(&SETX)  \u00ac= &EVAL(0) THEN SET XXX = &STR(&SETX. +\n          NX->X, )\n      IF &EVAL(&SETNX) \u00ac= &EVAL(0) THEN SET XXX = +\n          &STR(&XXX.&SETNX. X->NX, )\n      IF &EVAL(&SETX) = &EVAL(0) AND &EVAL(&SETNX) = &EVAL(0) +\n         THEN DO\n            SET XXX = &STR(DISPLAY NOT CHANGED BY )\n            SET &ZEDSMSG = &STR(NO CHANGE)\n      END\n      ELSE DO\n         ISREDIT F FIRST NX &LABF &LABL ' '\n         IF &STR(&IMAC) = NONE THEN ISREDIT UP 1\n      END\n      ISREDIT RESET FIND\n      SET &ZEDLMSG = &STR(&XXX.                           +\n         ===> FNOT &LABF &LABL &X.&NX.&WORD. &FIND1 &FIND2 +\n         &FIND3 &FIND4 &FIND5 &FIND6 &FIND7.)\n      ISPEXEC     SETMSG MSG(ISRZ000)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FOG": {"ttr": 23564, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\xaa\\x00\\xaa\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 170, "newlines": 170, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- Generate pseudo random text  **/\n\n\"ISREDIT MACRO (\"times\")   PROCESS\"\n'ISREDIT (Line,Col) = CURSOR'\nIf times = '?' then Signal DispDoc\n\n/* List of LEADINS, all of which mean nothing but buy time */\nleadin.1  = \"In particular,\"\nleadin.2  = \"On the other hand,\"\nleadin.3  = \"However,\"\nleadin.4  = \"Similarly,\"\nleadin.5  = \"As a resultant implication,\"\nleadin.6  = \"In this regard,\"\nleadin.7  = \"Based on integral subsystem considerations,\"\nleadin.8  = \"For example,\"\nleadin.9  = \"Thus,\"\nleadin.10 = \"In respect to specific goals,\"\nleadin.11 = \"Interestingly enough,\"\nleadin.12 = \"Without going into the technical details,\"\nleadin.13 = \"Of course,\"\nleadin.14 = \"To approach true user-friendliness,\"\nleadin.15 = \"In theory,\"\nleadin.16 = \"It is assumed that\"\nleadin.17 = \"Conversely,\"\nleadin.18 = \"We can see, in retrospect,\"\nleadin.19 = \"It is further assumed that\"\nleadin.20 = \"Further,\"\nleadin.21 = \"In summary,\"\nleadin.22 = \"It should be noted that\"\nleadin.23 = \"To further describe and annotate,\"\nleadin.24 = \"Specifically,\"\nleadin.0  = 24\n\n/* List of SUBJECT clauses chosen for no redeeming value whatsoever */\nsubject.1  = \"a large portion of interface coordination communication\"\nsubject.2  = \"a constant flow of effective communication\"\nsubject.3  = \"the characterization of specific criteria\"\nsubject.4  = \"initiation of critical subsystem development\"\nsubject.5  = \"the fully integrated test program\"\nsubject.6  = \"the product configuration baseline\"\nsubject.7  = \"any associated supporting element\"\nsubject.8  = \"the incorporation of additional mission constraints\"\nsubject.9  = \"the independent functional principle\"\nsubject.10 = \"the interrelation of system and/or subsystem technologies\"\nsubject.11 = \"the product assurance architecture\"\nsubject.0  = 11\n\n/* List of VERB clauses chosen for auto-recursive obfuscation */\nverb.1  = \"must utilize and be functionally interwoven with\"\nverb.2  = \"maximizes the probability of project success,\",\n   || \" yet minimizes cost and time required for\"\nverb.3  = \"adds explicit performance limits to\"\nverb.4  = \"necessitates that urgent consideration be applied to\"\nverb.5  = \"requires considerable systems analysis and\",\n   || \" trade-off studies to arrive at\"\nverb.6  = \"is further compounded when taking into account\"\nverb.7  = \"presents extremely interesting challenges to\"\nverb.8  = \"recognizes other systems' importance and the necessity for\"\nverb.9  = \"affects a significant implementation of\"\nverb.10 = \"adds overriding performance constraints to\"\nverb.11 = \"mandates staff-meeting-level attention to\"\nverb.12 = \"is functionally equivalent and parallel to\"\nverb.0  = 12\n\n/* List of OBJECT clauses selected for profound meaninglessness */\nobject.1  = \"the most recent level of hardware.  \"\nobject.2  = \"the anticipated fourth-generation equipment.  \"\nobject.3  = \"the subsystem compatibility testing.  \"\nobject.4  = \"the structural design, based on system\",\n   || \" engineering concepts.  \"\nobject.5  = \"the preliminary qualification limit.  \"\nobject.6  = \"the evolution of specifications over a given\",\n   || \" time period.  \"\nobject.7  = \"the philosophy of commonality and standardization.  \"\nobject.8  = \"the greater fight-worthiness concept.  \"\nobject.9  = \"any discrete configuration mode.  \"\nobject.10 = \"the management-by-contention principle.  \"\nobject.11 = \"the total system rationale.  \"\nobject.12 = \"possible bidirectional logical relationship approaches.  \"\nobject.13 = \"the postulated use of dialog management technology.  \"\nobject.14 = \"the overall negative profitability.  \"\nobject.0  = 14\n\nIf times = '?' Then Do\n    Say \"FOG is an interactive productivity tool designed to\"\n    Say \"assist in the composition of monthly reports, project\"\n    Say \"plans, memos to management and so forth.   If entered\"\n    Say \"without parameters, FOG generates as output a\"\n    Say \"high-fog-index sentence suitable for befuddling even\"\n    Say \"the most determined seeker-after-content.   If you need\"\n    Say \"vast amounts of FOG for really serious tush-covering,\"\n    Say \"enter the number of sentences needed as a parameter.\"\n    Say \"For example, entering 'FOG 5' outputs half a screen\"\n    Say \"of heat-treated, battle-hard, industrial-strength\"\n    Say \"slop, well suited to choking hogs and assurance\"\n    Say \"planners, after the line your cursor is on.\"\n    Say \" \"\n    Say \"REMEMBER:\"\n    Say \"   FOG can be a terrible weapon -- never abuse it!\"\n    Exit\n  End\n\nIf times = '' then times = 1\n\nleadnum  = 0\nsubnum   = 0\nverbnum  = 0\nobjnum   = 0\nlastlead = leadnum\nlastsub  = subnum\nlastverb = verbnum\nlastobj  = objnum\noutstuff = \"\"\nlinesize = 64\n\n/* And, last but not least, here's the program */\nDo i = 1 To times\n  Do While leadnum = lastlead\n    leadnum = RANDOM(1, leadin.0)\n  End\n\n  Do While subnum = lastsub\n    subnum = RANDOM(1, subject.0)\n  End\n\n  Do While verbnum = lastverb\n    verbnum = RANDOM(1, verb.0)\n  End\n\n  Do While objnum = lastobj\n    objnum = RANDOM(1, object.0)\n  End\n\n  outstuff = outstuff leadin.leadnum subject.subnum,\n     verb.verbnum object.objnum\n\n  lastlead = leadnum;\n  lastsub  = subnum;\n  lastverb = verbnum;\n  lastobj  = objnum;\nEnd i\n\n/* OK, now lets put that data out NICELY */\nDo Until outstuff = ''\n  k = LASTPOS(' ',outstuff,MIN(linesize,LENGTH(outstuff)))\n  record = strip(LEFT(outstuff,k))\n  \"ISREDIT Line_After &line = (record)\"\n  Line = Line + 1\n  outstuff=STRIP(SUBSTR(outstuff,k+1),'L')\nEnd\nExit(0)\n\nDispDoc:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"FOG -- Generate Pseudo Randow Text                        \"\n   SAY\n   SAY \" Format \"\n   SAY\n   SAY \"    FOG  ( # )                                            \"\n   SAY\n   SAY \"       Generates meaningless random sentences after the   \"\n   SAY \"       line the cursor is on or after the top line on the \"\n   SAY \"       displeyed screen.                                  \"\n   SAY\n   SAY \"       # is the number of sentences to be generated. The  \"\n   SAY \"       CAPS ON|OFF setting determines whether the         \"\n   SAY \"       sentences are all upper or normal mixed case.      \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FOR": {"ttr": 23812, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\xcb\\x00\\xcb\\x00\\x00\\xc3\\xd3\\xc9\\xe2\\xe3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 203, "newlines": 203, "modlines": 0, "user": "CLIST"}, "text": "            CONTROL ASIS\n /*  TITLE:       FOR     -- EXCLUDE EVERYTHING AND THEN     */\n /*                          FIND AND DISPLAY EVERY LINE     */\n /*                          WITH ANY SPECIFIED STRING       */\n /*  ENTRY:       USED AS AN EDIT CLIST WITHIN ISPF EDIT     */\n /*  EXAMPLE:    ===> FOR      'A' B 'C'                     */\n /*  OPTIONS:                                                */\n /*      LBL-RANGE  (OPTIONAL)  LABEL  RANGE                 */\n /*      NX | X     (OPTIONAL)  LIMIT TO EXCLUDED OR NOT     */\n /*      <LIST>     (REQUIRED)  STRINGS SUITABLE FOR A FIND  */\n   ISREDIT  MACRO (TOK1,TOK2,TOK3,TOK4,TOK5,TOK6,TOK7,TOK8,TOK9,TOK10,+\n          TOK11,TOK12,TOK13,+\n          TOK14,TOK15,TOK16,TOK17,TOK18,TOK19,TOK20,TOK21,TOK22,TOK23,+\n          TOK24,TOK25,TOK26,+\n          TOK27,TOK28,TOK29,TOK30,TOK31,TOK32,TOK33,TOK34,TOK35,TOK36,+\n          TOK37,TOK38,TOK39,+\n          TOK40,TOK41,TOK42,TOK43,TOK44,TOK45,TOK46,TOK47,TOK48)\n   ISREDIT (IMAC) = IMACRO\n   SET R  = 0\n   SET SETX  = 0\n   SET SETNX  = 0\n   SET I = 1\n   DO WHILE &I <= 48\n      SET TOKEN = &&TOK&I\n      SET TOKEN = &STR(&SYSCAPS(&TOKEN))\n      IF &STR(&TOKEN) = &STR() THEN GOTO END_TOK\n      IF ALL = &STR(&TOKEN) | NEXT = &STR(&TOKEN) | FIRST = +\n         &STR(&TOKEN) | LAST = &STR(&TOKEN) | PREV = &STR(&TOKEN) +\n            THEN DO\n               SET &ZEDSMSG = &STR(&TOKEN INVALID)\n               SET &ZEDLMSG = &STR(\"&TOKEN\" NOT PROVIDED FOR +\n                  NOR ARE NEXT ALL FIRST LAST PREV)\n               ISPEXEC   SETMSG MSG(ISRZ000)\n               EXIT CODE(12)\n            END\n      IF &SUBSTR(1:6,&STR(&TOKEN)       ) = &STR(BEGIN&STR(&LP))  +\n         THEN DO\n            SET BEGIN = &SUBSTR(7:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n               &STR(&TOKEN)         )\n            GOTO NXT_TOK\n         END\n      IF &STR(&TOKEN) = NX THEN DO\n         SET NX = NX\n         GOTO NXT_TOK\n      END\n      IF &STR(&TOKEN) = X THEN DO\n         SET X = X\n         GOTO NXT_TOK\n      END\n      IF &STR(&TOKEN) = WORD | &STR(&TOKEN) = CHAR | &STR(&TOKEN) = +\n            CHARS | &STR(&TOKEN) = PREFIX | &STR(&TOKEN) = SUFFIX +\n         THEN DO\n            IF &STR(&WORD) \u00ac= &STR() THEN DO\n               SET &ZEDSMSG = &STR(INCONSISTENT PARAMETERS)\n               SET &ZEDLMSG = &STR('&WORD' AND '&TOKEN' CANNOT BOTH BE +\n                  SPECIFIED FOR XEVERY CMD.)\n               ISPEXEC     SETMSG MSG(ISRZ000)\n            END\n            SET WORD = &STR( &TOKEN.)\n            GOTO NXT_TOK\n         END\n      IF &STR(&TOKEN) = LEFT THEN DO        /* LEFT | RIGHT */\n         SET LEFT = LEFT\n         GOTO NXT_TOK\n      END\n      IF &STR(&TOKEN) = RIGHT THEN DO\n         SET RIGHT = RIGHT\n         GOTO NXT_TOK\n      END\n      IF &SUBSTR(1,&TOKEN) = &STR(.) THEN DO\n         IF &LABF = &STR() THEN DO\n            SET LABF = &STR(&TOKEN)\n            GOTO NXT_TOK\n         END\n         IF &STR(&LABL) = &STR() THEN DO\n            SET LABL = &STR(&TOKEN)\n            GOTO NXT_TOK\n         END\n         SET &ZEDSMSG = &STR(LABEL &STR(&TOKEN))\n         SET &ZEDLMSG = &STR(EXACTLY TWO LABELS ARE REQUIRED FOUND +\n            \"&LABF\", \"&LABL\" AND  \"&STR(&TOKEN)\")\n         ISPEXEC   SETMSG MSG(ISRZ000)\n         EXIT CODE(12)\n      END\n      IF &STR(&TOKEN) = &STR()) THEN DO\n         SET &ZEDSMSG = &STR(LOST PARENTHESIS)\n         SET &ZEDLMSG = BLANKS SEPARATE ALL OPERANDS; THEREFORE +\n            INVALID IN FROM() TO() COL() BEGIN()\n         ISPEXEC SETMSG MSG(ISRZ000)\n         EXIT CODE(12)\n      END\n      SET REMAIN = &STR(&REMAIN &STR(&TOKEN))\n      SET R = &R + 1\n      SET FIND&R = &STR(&TOKEN)\n NXT_TOK: -\n      SET I = &I + 1\n      END\n END_TOK: SET I = &I\n      SET RMAX = &R\n      IF &STR(&FIND1) = &STR() THEN DO\n         SET &ZEDSMSG = &STR(FIND STRINGS)\n         SET &ZEDLMSG = &STR(&ZEDSMSG ARE MISSING)\n         ISPEXEC     SETMSG MSG(ISRZ000)\n         EXIT CODE(12)\n      END\n      IF &LABL = &STR() AND &LABF \u00ac= &STR() THEN DO\n         SET &ZEDSMSG = &STR(LABEL MISSING)\n         SET &ZEDLMSG = &STR(TWO LABELS MUST BE INDICATED FOR A RANGE)\n         ISPEXEC     SETMSG MSG(ISRZ000)\n      END\n      IF &LABF = &STR() THEN SET LABF = &STR(.ZFIRST)\n      IF &LABL = &STR() THEN SET LABL = &STR(.ZLAST)\n      ISREDIT (#LABF) = LINENUM &LABF\n      IF &LASTCC \u00ac= 0 THEN DO\n         SET &ZEDSMSG = &STR(&LABF. LABEL)\n         SET &ZEDLMSG = &STR(&ZEDSMSG DOES NOT EXIST)\n         ISPEXEC     SETMSG MSG(ISRZ000)\n         EXIT CODE(12)\n      END\n      ISREDIT (#LABL) = LINENUM &LABL\n      IF &LASTCC \u00ac= 0 THEN DO\n         SET &ZEDSMSG = &STR(&LABL. LABEL)\n         SET &ZEDLMSG = &STR(&ZEDSMSG DOES NOT EXIST)\n         ISPEXEC     SETMSG MSG(ISRZ000)\n         EXIT CODE(12)\n      END\n                                   /**  END OF LABEL REQUIREMENTS  **/\n      ISREDIT (DWIDTH) = DATA_WIDTH\n      SET DWIDTH2 = &DWIDTH + &DWIDTH\n                               /**  CAN BE USED TO FORCE AN ERROR  **/\n      ISREDIT (LBOUND,RBOUND) = BOUNDS\n      ISREDIT (VAR057) = RECFM\n      ISREDIT (VAR049,VAR050) = NUMBER\n      SET LLBOUND = &LBOUND\n      SET LLADJ = 0\n      IF &VAR057 = V AND &VAR049 = ON THEN DO\n         SET LLADJ = 8\n         SET LLBOUND = &LBOUND + 8\n      END\n                   /**  BEGIN OF INTERFACE TO COMMON PATTERN CLIST  **/\n      IF &X = X AND &NX = NX THEN DO\n         SET X =\n         SET NX =\n      END\n                   /**  END OF INTERFACE TO COMMON PATTERN CLIST  **/\n      IF &EVAL(&#LABL.) < &EVAL(&#LABF.) THEN DO\n         SET &ZEDSMSG = &STR(LABEL ERR .LABF/L)\n         SET &ZEDLMSG = &STR(&LABF MUST APPEAR EARLIER THAN +\n             &LABL)\n         ISPEXEC     SETMSG MSG(ISRZ000)\n         EXIT CODE(12)\n      END\n      SET I = &#LABF\n      SET CNT = 0\n      DO WHILE &I <= &#LABL\n         ISREDIT (VAR075) = XSTATUS &I\n         IF &VAR075 = &NX OR &VAR075 = &X OR  &STR(&X&NX) = +\n            &STR() THEN DO\n               SET R = 1\n               DO WHILE &R <= &RMAX\n                  ISREDIT LABEL &I = .POINT\n                  SET TOKEN = &STR(&&FIND&R)\n                  SET TOKEN = &STR(&TOKEN)\n                  ISREDIT SEEK .POINT .POINT &TOKEN. &WORD. ALL\n                  IF &LASTCC = 0 THEN SET R = &RMAX + 99\n                  SET R = &R + 1\n               END\n               SET RR = &RMAX + 50\n               IF &R < &RR THEN GOTO NFOUND\n               SET CNT = &CNT + 1\n               IF &VAR075 = X THEN DO\n                  SET SETNX = 0&SETNX + 1\n                  ISREDIT XSTATUS .POINT = NX\n               END\n               GOTO NXTT_I\nNFOUND: -\n               ISREDIT EXCLUDE .POINT .POINT ALL\n               IF &VAR075 = NX THEN SET SETX = 0&SETX + 1\n            END\nNXTT_I: -\n         SET I = &I. + 1\n      END\nNONE: -\n      SET &ZEDSMSG = &STR(FOUND )&CNT\n      SET XXX = &STR()\n      IF &EVAL(&SETX)  \u00ac= &EVAL(0) THEN SET XXX = &STR(&SETX. +\n          NX->X, )\n      IF &EVAL(&SETNX) \u00ac= &EVAL(0) THEN SET XXX = +\n          &STR(&XXX.&SETNX. X->NX, )\n      IF &EVAL(&SETX) = &EVAL(0) AND &EVAL(&SETNX) = &EVAL(0) +\n         THEN DO\n            SET XXX = &STR(DISPLAY NOT CHANGED BY )\n            SET &ZEDSMSG = &STR(NO CHANGE)\n      END\n      ELSE DO\n         ISREDIT F FIRST NX &LABF &LABL ' '\n         IF &STR(&IMAC) = NONE THEN ISREDIT UP 1\n      END\n      ISREDIT RESET FIND\n      SET &ZEDLMSG = &STR(&XXX.                           +\n         ===> FOR &LABF &LABL &X.&NX.&WORD. &FIND1 &FIND2 +\n         &FIND3 &FIND4 &FIND5 &FIND6 &FIND7.)\n      ISPEXEC     SETMSG MSG(ISRZ000)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FOREVER": {"ttr": 23816, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xea\\x00\\xea\\x00\\x00\\xc6\\xd6\\xd9\\xc5\\xe5\\xc5\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 234, "newlines": 234, "modlines": 0, "user": "FOREVER"}, "text": "//-YOUR-USERID-F JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//*** COBOL CODE FOR FOREVER PROGRAM\n//***\n//C          EXEC     PGM=IGYCRCTL,REGION=4M,\n//             PARM=('LIB,MAP,NUMPROC(PFD),OFF,OPTIMIZE',\n//            'APOST,NOSEQ,TRUNC(OPT),XREF')\n//SYSIN        DD       *\n\n      **************************\n       IDENTIFICATION DIVISION.\n      **************************\n       PROGRAM-ID.  FOREVER.\n      *\n      * RUN ONLY ON FRIDAYS. IF TODAY'S DATE GREATER THAN DATE\n      * IN FOREVER FILE, THEN GENERATE JOB TO INTERNAL READER\n      * FOR EVERY FILE IN THERE TO 'TOUCH' THEM, UPDATING LAST\n      * REFERENCED DATE.\n      *\n\n      ***********************\n       ENVIRONMENT DIVISION.\n      ***********************\n\n       INPUT-OUTPUT SECTION.\n      *---------------------*\n\n       FILE-CONTROL.\n\n           SELECT I\n               ASSIGN TO I.\n\n           SELECT O\n               ASSIGN TO O.\n\n      ****************\n       DATA DIVISION.\n      ****************\n\n       FILE SECTION.\n      *-------------*\n\n       FD  I\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  INPUT-REC    PIC X(00080).\n\n       FD  O\n           RECORDING MODE IS F\n           BLOCK CONTAINS 0 RECORDS.\n       01  OUTPUT-REC   PIC X(00080).\n\n       WORKING-STORAGE SECTION.\n      *------------------------*\n\n       01  WS-INPUT-REC               PIC X(080).\n       01  WS-OUTPUT-REC              PIC X(080).\n       01  WORK-AREAS.\n           05  END-OF-FILE-STATUS     PIC X      VALUE 'N'.\n               88  AT-END-OF-FILE                VALUE 'Y'.\n           05  WEEK-DAY-NUMBER        PIC 9.\n           05  YYMMDD                 PIC 9(006).\n           05  CCYYMMDD               PIC 9(008).\n           05  II                     PIC 9(008) COMP.\n           05  JJ                     PIC 9(008) COMP.\n           05  WS-JOB-CARD1.\n               10                       PIC X(002) VALUE '//'.\n               10  WS-CARD1-USERID1     PIC X(008).\n               10                       PIC X(024)\n                   VALUE '  JOB      (ACCT INFO),'''.\n               10  WS-CARD1-USERID2     PIC X(008).\n               10                       PIC X(038)\n                   VALUE ''','.\n           05  WS-JOB-CARD2.\n               10                       PIC X(015) VALUE '//'.\n               10                       PIC X(026)\n                   VALUE 'CLASS=2,MSGCLASS=X,NOTIFY='.\n               10  WS-CARD2-USERID1     PIC X(039)\n                   VALUE ''','.\n           05  WS-FINAL-CARD1.\n               10                       PIC X(080)\n                   VALUE '//***'.\n           05  WS-IDCAMS-CARD1.\n               10                       PIC X(080)\n                   VALUE '//IDCAMS     EXEC     PGM=IDCAMS,REGION=4M'.\n           05  WS-SYSPRINT-CARD1.\n               10                       PIC X(080)\n                   VALUE '//SYSPRINT     DD       SYSOUT=*'.\n           05  WS-SYSIN-CARD1.\n               10                       PIC X(080)\n                   VALUE '//SYSIN        DD       *'.\n           05  WS-IDCAMS-CARD2.\n               10                       PIC X(020)\n                   VALUE '  PRINT   INFILE(INF'.\n               10  WS-IDCAMS-CARD2-NO   PIC 9(004).\n               10                       PIC X(056)\n                   VALUE ') COUNT(1)'.\n           05  WS-MAXCC-CARD1.\n               10                       PIC X(080)\n                   VALUE '  SET     MAXCC=0'.\n           05  WS-INFILE-CARD1.\n               10                       PIC X(005)\n                   VALUE '//INF'.\n               10  WS-INFILE-CARD1-NO   PIC 9(004).\n               10                       PIC X(028)\n                   VALUE '      DD       DISP=SHR,DSN='.\n               10  WS-INFILE-CARD1-DSN  PIC X(043).\n\n       LINKAGE SECTION.\n      *----------------*\n       01  PARM-DATA.\n           05  PARM-LENGTH              PIC 9(4)              COMP.\n           05  PARM-USERID              PIC X(8).\n\n      *************************************\n       PROCEDURE DIVISION USING PARM-DATA.\n      *************************************\n\n       0000-MAIN.\n      ************\n\n      ** CHECK IF FRIDAY\n\n           ACCEPT WEEK-DAY-NUMBER FROM DAY-OF-WEEK\n           IF WEEK-DAY-NUMBER = 5\n\n               ACCEPT YYMMDD FROM DATE\n               STRING\n                   '20'\n                   YYMMDD\n                       DELIMITED BY SIZE\n                   INTO CCYYMMDD\n               END-STRING\n               OPEN  I-O    I\n                     OUTPUT O\n\n      ** READ HEADER DATE RECORD\n\n               READ  I INTO WS-INPUT-REC\n                   AT END SET AT-END-OF-FILE TO TRUE\n               END-READ\n\n      ** GENERATE JOB TO 'TOUCH' FILES IF NOT YET SUBMITTED TODAY\n\n               IF WS-INPUT-REC(1:8) < CCYYMMDD\n\n      ** REWRITE HEADER DATE BACK TO FILE\n\n                   MOVE CCYYMMDD TO WS-INPUT-REC(1:8)\n                   REWRITE INPUT-REC FROM WS-INPUT-REC\n\n      ** WRITE JOB CARD AND ANY CONSTANT CARDS TO INTRDR\n                                                                        END-PERF\n                   MOVE PARM-USERID(1:PARM-LENGTH)\n                       TO WS-CARD1-USERID1\n                   MOVE 'F'\n                       TO WS-CARD1-USERID1(PARM-LENGTH + 1:1)\n                   MOVE PARM-USERID(1:PARM-LENGTH)\n                       TO WS-CARD1-USERID2\n                   WRITE OUTPUT-REC FROM WS-JOB-CARD1\n                   MOVE PARM-USERID(1:PARM-LENGTH)\n                       TO WS-CARD2-USERID1\n                   WRITE OUTPUT-REC FROM WS-JOB-CARD2\n\n                   WRITE OUTPUT-REC FROM WS-IDCAMS-CARD1\n                   WRITE OUTPUT-REC FROM WS-SYSPRINT-CARD1\n\n      ** READ FIRST DATA SET RECORD AND THEN LOOP THRU REST\n\n                   READ  I INTO WS-INPUT-REC\n                       AT END SET AT-END-OF-FILE TO TRUE\n                   END-READ\n                   MOVE 0 TO II\n                   PERFORM 0200-READ-WRITE-LOOP\n                       UNTIL AT-END-OF-FILE\n\n      ** PROCESS MAXCC CARD AND THEN DD CARDS FOR FILES\n\n                   WRITE OUTPUT-REC FROM WS-SYSIN-CARD1\n\n                   PERFORM\n                       VARYING JJ FROM 1 BY 1\n                           UNTIL JJ > II\n                       MOVE JJ TO WS-IDCAMS-CARD2-NO\n                       WRITE OUTPUT-REC FROM WS-IDCAMS-CARD2\n                   END-PERFORM\n                   WRITE OUTPUT-REC FROM WS-MAXCC-CARD1\n                   WRITE OUTPUT-REC FROM WS-FINAL-CARD1\n               END-IF\n\n               CLOSE I\n                     O\n           END-IF\n           GOBACK\n           .\n\n       0200-READ-WRITE-LOOP.\n      ***********************\n           ADD 1                   TO  II\n           MOVE II                 TO  WS-INFILE-CARD1-NO\n           MOVE WS-INPUT-REC(1:44) TO  WS-INFILE-CARD1-DSN\n           WRITE OUTPUT-REC FROM WS-INFILE-CARD1\n           READ  I INTO WS-INPUT-REC\n               AT END SET AT-END-OF-FILE TO TRUE\n           END-READ\n           .\n\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=SYSDA,SPACE=(CYL,(3,3)),\n//             DCB=(BLKSIZE=0,LRECL=80,RECFM=FB)\n//SYSUT1       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT2       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT3       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT4       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT5       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT6       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//SYSUT7       DD       UNIT=SYSDA,SPACE=(CYL,(05,02))\n//***\n//L          EXEC     PGM=HEWL,COND=(4,LT),REGION=4M,\n//             PARM='RENT,AMODE(31),RMODE(ANY),XREF,LIST,LET,DCBS'\n//SYSLIB       DD       DSNAME=-YOUR-SCEELLED-,DISP=SHR\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,\n//             DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   00032800\n  ENTRY    FOREVER\n  NAME     FOREVER(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FOREVERX": {"ttr": 23821, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x03'\\x1f\\x01\\x03'\\x1f\\x12\\x00\\x00\\x08\\x00\\x08\\x00\\x00\\xc6\\xd6\\xd9\\xc5\\xe5\\xc5\\xd9@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-09-28T00:00:00", "modifydate": "2003-09-28T12:00:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "FOREVER"}, "text": "      /**  FOREVER FILE PROCESSING  **/\n         ADDRESS TSO\n         \"FREE DD(I O SYSOUT)\"\n         \"ALLOC DSN(*) DD(SYSOUT)\"\n         \"ALLOC DSN('SomeHLQ.Forever.File') DD(I) OLD\"\n         \"ALLOC DD(O) SYSOUT(A) WRITER(INTRDR)\"\n         \"CALL 'SomeHLQ.Loadlib(FOREVER)' '\"USERID()\"'\"\n         \"FREE DD(I O SYSOUT)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FORMCOLS": {"ttr": 24065, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x01\\xde\\x01\\xde\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 478, "newlines": 478, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- FORMAT COLUMNS ONTO SAME OR OTHER COLUMNS  **/\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'FORMCOLS MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT \"ISREDIT MACRO (PARMS)\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY FORMCOLS 'EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT',\n         'WITH NO PENDING EDIT COMMANDS!'\n      SIGNAL EOJ\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n   IF SUBSTR(PARMS,1,1) = \"'\"\n      THEN DO\n         PARMS  = SUBSTR(PARMS,2)\n         QLOC   = INDEX(PARMS,\"'\")\n         FORMAT = SUBSTR(PARMS,1,QLOC-1)\n         PARMS  = SUBSTR(PARMS,QLOC+1)\n      END\n      ELSE DO\n         IF SUBSTR(PARMS,1,1) = '\"'\n            THEN DO\n               PARMS  = SUBSTR(PARMS,2)\n               QLOC   = INDEX(PARMS,'\"')\n               FORMAT = SUBSTR(PARMS,1,QLOC-1)\n               PARMS  = SUBSTR(PARMS,QLOC+1)\n            END\n            ELSE DO\n               FORMAT = WORD(PARMS,1)\n               PARMS = SUBSTR(PARMS,LENGTH(FORMAT)+1)\n            END\n      END\n   FRMLEFT  = WORD(PARMS,1)\n   FRMRIGHT = WORD(PARMS,2)\n   IF FORMAT = '' | FRMLEFT = ''  |  FRMRIGHT = ''  THEN DO\n      MESG = 'MANDATORY PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   FORMAT = TRANSLATE(FORMAT)\n   IF \u00acDATATYPE(FRMLEFT,'W')  |  FRMLEFT = 0  THEN DO\n      MESG = \"'\"FRMLEFT\"' VALUE OF FROM-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMRIGHT,'W')  |  FRMRIGHT = 0  THEN DO\n      MESG = \"'\"FRMRIGHT\"' VALUE OF FROM-RIGHT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF FRMLEFT > FRMRIGHT THEN DO\n      MESG = \"FROM-LEFT-COL \"FRMLEFT\" IS > THAN FROM-RIGHT-COL \"FRMRIGHT\n      SIGNAL ERROR\n   END\n\n   PARMS   = TRANSLATE(PARMS)\n   LBL1    = \"\"\n   LBL2    = \"\"\n   TOLEFT  = \"\"\n   TORIGHT = \"\"\n   DO II = 3 TO 6;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n      END\n      ELSE DO\n         IF DATATYPE(TOKEN,'W')  THEN DO\n            IF TOLEFT = \"\" THEN TOLEFT = TOKEN\n            ELSE IF TORIGHT = \"\" THEN TORIGHT = TOKEN\n               ELSE DO\n                  ZEDSMSG = \".LABEL RC=8\"\n                  ZEDLMSG = \"TOO MANY COLUMNS --\" TOLEFT TORIGHT TOKEN\n                  ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n                  EXIT 8\n               END\n         END\n      END\n   END II\n\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n   IF TOLEFT <> \"\" AND TORIGHT = \"\" THEN TORIGHT = TOLEFT\n   IF TOLEFT = \"\" THEN DO\n      TOLEFT  = FRMLEFT\n      TORIGHT = FRMRIGHT\n   END\n\n   IF \u00acDATATYPE(TOLEFT,'W')  |  TOLEFT=0  THEN DO\n      MESG = \"'\"TOLEFT\"' VALUE OF TO-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(TORIGHT,'W')  |  TORIGHT=0  THEN DO\n      MESG = \"'\"TORIGHT\"' VALUE OF TO-RIGHT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF TOLEFT > TORIGHT THEN DO\n      MESG = \"TO-LEFT-COL \"TOLEFT\" IS GREATER THAN TO-RIGHT-COL \"TORIGHT\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF TORIGHT > LRECL THEN DO\n      MESG = \"TO-RIGHT COLUMN IS GREATER THAN RECORD SIZE (\"LRECL\")\"\n      SIGNAL ERROR\n   END\n   FLEN = FRMRIGHT - FRMLEFT + 1\n   TLEN = TORIGHT - TOLEFT + 1\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR \"\n   \"ISREDIT (\"ANUM\") = AUTONUM \"\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n\n   START = 1\n   IF LBL1 <> '' THEN \"ISREDIT (START) = LINENUM &LBL1\"\n   IF LBL2 <> '' THEN \"ISREDIT (END) = LINENUM &LBL2\"\n   ELSE LBL2 = LBL1\n\n   IF START > END THEN DO\n      WST = START\n      START = END\n      END = WST\n   END\n\n   TOT  = 0\n   OK   = 0\n   OVFL = 0\n   DO PNTR =  START  TO  END  BY 1\n      TOT = TOT + 1\n      OVERFLOW = 'NO'\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      INPUT = SUBSTR(RECORD,FRMLEFT,FLEN)\n                                     /* DETERMINE SIGN IF ANY      */\n      II = INDEX(INPUT,'+')\n      IF II > 0\n         THEN DO\n            INPUT = SUBSTR(INPUT,1,II-1) || SUBSTR(INPUT,II+1)\n            SIGN = '+'\n         END\n         ELSE DO\n            II = INDEX(INPUT,'-')\n            IF II > 0\n               THEN DO\n                  INPUT = SUBSTR(INPUT,1,II-1) || SUBSTR(INPUT,II+1)\n                  SIGN = '-'\n               END\n               ELSE DO\n                  DO II =  LENGTH(INPUT)  TO  1  BY  -1,\n                        WHILE ( SUBSTR(INPUT,II,1) = ' ' )\n                  END\n                  IF SUBSTR(INPUT,II,1) = '.' THEN II = II - 1\n                  IF VERIFY(SUBSTR(INPUT,II,1),'{0A1B2C3D4E5F6G7H8I9')=0\n                     THEN SIGN = '+'\n                     ELSE DO\n                        IF VERIFY(SUBSTR(INPUT,II,1),'}JKLMNOPQR')=0\n                           THEN SIGN = '-'\n                           ELSE SIGN = '+'\n                     END\n                  XX = TRANSLATE(SUBSTR(INPUT,II,1),\n                      ,'000111222333444555666777888999',\n                      ,'{0}A1JB2KC3LD4ME5NF6OG7PH8QI9R')\n                  INPUT = OVERLAY(XX,INPUT,II,1)\n               END\n         END\n                                     /* ELIMINATE INPUT COMMAS,    */\n                                     /* STRIP BLANKS AND ZEROS     */\n      INPUT = STRIP(INPUT,,' ')\n      INPUT = STRIP(INPUT,L,'0')\n      II = INDEX(INPUT,',')\n      DO WHILE II > 0\n         INPUT = SUBSTR(INPUT,1,II-1) || SUBSTR(INPUT,II+1)\n         II = INDEX(INPUT,',')\n      END\n                                     /* SYNCH DECIMAL POINTS       */\n      II = INDEX(INPUT,'.')\n      OUTPUT = FORMAT\n      JJ = INDEX(OUTPUT,'.')\n      IF II > 0 THEN INPUT = STRIP(INPUT,T,'0')\n                                     /* PROCESS VALID INPUT DATA   */\n      IF VERIFY(INPUT,'.0123456789') = 0\n         THEN DO\n            OK = OK + 1\n            IF II = 0 & JJ = 0\n                                     /* NEITHER HAS A DECIMAL PT   */\n               THEN CALL NEITHER\n               ELSE IF II > 0 & JJ > 0\n                                     /* BOTH HAVE DECIMAL POINTS   */\n                  THEN CALL BOTH\n                                     /* FORMAT HAS A DECIMAL PT    */\n                  ELSE IF II = 0 & JJ > 0\n                     THEN CALL ONLYOUT\n                                     /* DATA ONLY HAS A DECIMAL PT */\n                     ELSE CALL ONLYIN\n            IF LENGTH(OUTPUT) > TLEN THEN OVERFLOW = 'YES'\n            OUTPUT = RIGHT(OUTPUT,TLEN)\n            RECORD = OVERLAY(OUTPUT,RECORD,TOLEFT,TLEN)\n            \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n            IF OVERFLOW = 'YES' THEN OVFL = OVFL + 1\n         END\n   END\n\n   STR = OK || '/' || OVFL || '/' || TOT\n   CALL SETMSG '* NO ' STR 'FORMATTED $VALID OVER OVERFLOW OVER TOTAL'\n   \"ISREDIT LOCATE\" START\n   \"ISREDIT AUTONUM =\" ANUM\n   SIGNAL EOJ\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nNEITHER:\n   KK = LENGTH(INPUT)\n   DO LL = LENGTH(OUTPUT) TO 1 BY -1\n      IF SUBSTR(OUTPUT,LL,1) = '9'\n         THEN DO\n            IF KK > 0 THEN DO\n               OUTPUT=OVERLAY(SUBSTR(INPUT,KK,1),OUTPUT,LL,1)\n               KK = KK - 1\n            END\n            ELSE OUTPUT=OVERLAY('0',OUTPUT,LL,1)\n         END\n      ELSE IF SUBSTR(OUTPUT,LL,1) = 'Z'\n         THEN DO\n            IF KK > 0 THEN DO\n               OUTPUT=OVERLAY(SUBSTR(INPUT,KK,1),OUTPUT,LL,1)\n               KK = KK - 1\n            END\n            ELSE OUTPUT=OVERLAY(' ',OUTPUT,LL,1)\n         END\n      ELSE IF SUBSTR(OUTPUT,LL,1) = ','\n         THEN DO\n            IF KK <= 0 THEN DO\n               IF ( LL > 1 & INDEX(SUBSTR(OUTPUT,1,LL-1),'9') = 0 ),\n                     | LL = 1 THEN OUTPUT=OVERLAY(' ',OUTPUT,LL,1)\n            END\n         END\n      ELSE IF SUBSTR(OUTPUT,LL,1) = '+'\n         THEN DO\n            OUTPUT = OVERLAY(SIGN,OUTPUT,LL,1)\n         END\n      ELSE IF SUBSTR(OUTPUT,LL,1) = '-'\n         THEN DO\n            IF SIGN = '-' THEN OUTPUT = OVERLAY(SIGN,OUTPUT,LL,1)\n            ELSE OUTPUT = OVERLAY(' ',OUTPUT,LL,1)\n         END\n   END\n   IF KK > 0 THEN OVERFLOW = 'YES'\n   RETURN\n\nBOTH:\n   MM = II + 1\n   DO LL = (JJ+1) TO LENGTH(OUTPUT)\n      IF SUBSTR(OUTPUT,LL,1) = '9'\n         THEN DO\n            IF MM <= LENGTH(INPUT) THEN DO\n               OUTPUT=OVERLAY(SUBSTR(INPUT,MM,1),OUTPUT,LL,1)\n               MM = MM + 1\n            END\n            ELSE OUTPUT=OVERLAY('0',OUTPUT,LL,1)\n         END\n      ELSE IF SUBSTR(OUTPUT,LL,1) = 'Z'\n         THEN DO\n            IF MM <= LENGTH(INPUT) THEN DO\n               OUTPUT=OVERLAY(SUBSTR(INPUT,MM,1),OUTPUT,LL,1)\n               MM = MM + 1\n            END\n            ELSE OUTPUT=OVERLAY(' ',OUTPUT,LL,1)\n         END\n      ELSE IF SUBSTR(OUTPUT,LL,1) = '+'\n         THEN DO\n            OUTPUT = OVERLAY(SIGN,OUTPUT,LL,1)\n         END\n      ELSE IF SUBSTR(OUTPUT,LL,1) = '-'\n         THEN DO\n            IF SIGN = '-' THEN OUTPUT = OVERLAY(SIGN,OUTPUT,LL,1)\n            ELSE OUTPUT = OVERLAY(' ',OUTPUT,LL,1)\n         END\n   END\n\n   KK = II - 1\n   DO LL = (JJ-1) TO 1 BY -1\n      IF SUBSTR(OUTPUT,LL,1) = '9'\n         THEN DO\n            IF KK > 0 THEN DO\n               OUTPUT=OVERLAY(SUBSTR(INPUT,KK,1),OUTPUT,LL,1)\n               KK = KK - 1\n            END\n            ELSE OUTPUT=OVERLAY('0',OUTPUT,LL,1)\n         END\n      ELSE IF SUBSTR(OUTPUT,LL,1) = 'Z'\n         THEN DO\n            IF KK > 0 THEN DO\n               OUTPUT=OVERLAY(SUBSTR(INPUT,KK,1),OUTPUT,LL,1)\n               KK = KK - 1\n            END\n            ELSE OUTPUT=OVERLAY(' ',OUTPUT,LL,1)\n         END\n      ELSE IF SUBSTR(OUTPUT,LL,1) = ','\n         THEN DO\n            IF KK <= 0 THEN DO\n               IF ( LL > 1 & INDEX(SUBSTR(OUTPUT,1,LL-1),'9') = 0 ),\n                     | LL = 1 THEN OUTPUT=OVERLAY(' ',OUTPUT,LL,1)\n            END\n         END\n      ELSE IF SUBSTR(OUTPUT,LL,1) = '+'\n         THEN DO\n            OUTPUT = OVERLAY(SIGN,OUTPUT,LL,1)\n         END\n      ELSE IF SUBSTR(OUTPUT,LL,1) = '-'\n         THEN DO\n            IF SIGN = '-' THEN OUTPUT = OVERLAY(SIGN,OUTPUT,LL,1)\n            ELSE OUTPUT = OVERLAY(' ',OUTPUT,LL,1)\n         END\n   END\n   IF KK > 0 | MM <= LENGTH(INPUT) THEN OVERFLOW = 'YES'\n   RETURN\n\nONLYIN:\n   KK = II - 1\n   DO LL = LENGTH(OUTPUT) TO 1 BY -1\n      IF SUBSTR(OUTPUT,LL,1) = '9'\n         THEN DO\n            IF KK > 0 THEN DO\n               OUTPUT=OVERLAY(SUBSTR(INPUT,KK,1),OUTPUT,LL,1)\n               KK = KK - 1\n            END\n            ELSE OUTPUT=OVERLAY('0',OUTPUT,LL,1)\n         END\n      ELSE IF SUBSTR(OUTPUT,LL,1) = 'Z'\n         THEN DO\n            IF KK > 0 THEN DO\n               OUTPUT=OVERLAY(SUBSTR(INPUT,KK,1),OUTPUT,LL,1)\n               KK = KK - 1\n            END\n            ELSE OUTPUT=OVERLAY(' ',OUTPUT,LL,1)\n         END\n      ELSE IF SUBSTR(OUTPUT,LL,1) = ','\n         THEN DO\n            IF KK <= 0 THEN DO\n               IF ( LL > 1 & INDEX(SUBSTR(OUTPUT,1,LL-1),'9') = 0 ),\n                     | LL = 1 THEN OUTPUT=OVERLAY(' ',OUTPUT,LL,1)\n            END\n         END\n      ELSE IF SUBSTR(OUTPUT,LL,1) = '+'\n         THEN DO\n            OUTPUT = OVERLAY(SIGN,OUTPUT,LL,1)\n         END\n      ELSE IF SUBSTR(OUTPUT,LL,1) = '-'\n         THEN DO\n            IF SIGN = '-' THEN OUTPUT = OVERLAY(SIGN,OUTPUT,LL,1)\n            ELSE OUTPUT = OVERLAY(' ',OUTPUT,LL,1)\n         END\n   END\n   IF KK > 0 | SUBSTR(INPUT,II+1) \\= '' THEN OVERFLOW = 'YES'\n   RETURN\n\nONLYOUT:\n   DO LL = (JJ+1) TO LENGTH(OUTPUT)\n      IF SUBSTR(OUTPUT,LL,1) = '9'\n         THEN OUTPUT=OVERLAY('0',OUTPUT,LL,1)\n      ELSE IF SUBSTR(OUTPUT,LL,1) = 'Z'\n         THEN OUTPUT=OVERLAY(' ',OUTPUT,LL,1)\n      ELSE IF SUBSTR(OUTPUT,LL,1) = '+'\n         THEN OUTPUT = OVERLAY(SIGN,OUTPUT,LL,1)\n      ELSE IF SUBSTR(OUTPUT,LL,1) = '-'\n         THEN DO\n            IF SIGN = '-' THEN OUTPUT = OVERLAY(SIGN,OUTPUT,LL,1)\n            ELSE OUTPUT = OVERLAY(' ',OUTPUT,LL,1)\n         END\n   END\n\n   KK = LENGTH(INPUT)\n   DO LL = LENGTH(OUTPUT) TO 1 BY -1\n      IF SUBSTR(OUTPUT,LL,1) = '9'\n         THEN DO\n            IF KK > 0 THEN DO\n               OUTPUT=OVERLAY(SUBSTR(INPUT,KK,1),OUTPUT,LL,1)\n               KK = KK - 1\n            END\n            ELSE OUTPUT=OVERLAY('0',OUTPUT,LL,1)\n         END\n      ELSE IF SUBSTR(OUTPUT,LL,1) = 'Z'\n         THEN DO\n            IF KK > 0 THEN DO\n               OUTPUT=OVERLAY(SUBSTR(INPUT,KK,1),OUTPUT,LL,1)\n               KK = KK - 1\n            END\n            ELSE OUTPUT=OVERLAY(' ',OUTPUT,LL,1)\n         END\n      ELSE IF SUBSTR(OUTPUT,LL,1) = ','\n         THEN DO\n            IF KK <= 0 THEN DO\n               IF ( LL > 1 & INDEX(SUBSTR(OUTPUT,1,LL-1),'9') = 0 ),\n                     | LL = 1 THEN OUTPUT=OVERLAY(' ',OUTPUT,LL,1)\n            END\n         END\n      ELSE IF SUBSTR(OUTPUT,LL,1) = '+'\n         THEN DO\n            OUTPUT = OVERLAY(SIGN,OUTPUT,LL,1)\n         END\n      ELSE IF SUBSTR(OUTPUT,LL,1) = '-'\n         THEN DO\n            IF SIGN = '-' THEN OUTPUT = OVERLAY(SIGN,OUTPUT,LL,1)\n            ELSE OUTPUT = OVERLAY(' ',OUTPUT,LL,1)\n         END\n   END\n   IF KK > 0 THEN OVERFLOW = 'YES'\n   RETURN\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   CALL DISPDOC\n   SIGNAL EOJ\n\nEOJ:\n   X = MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"FORMCOLS - FORMAT ARITHMETIC VALUES \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    FORMCOLS  FORMAT  FROM-COL1 FROM-COL2          \"\n   SAY \"              (TO-COL1 TO-COL2)  (.A .B)           \"\n   SAY\n   SAY \"       FROM-COLUMN'S AND FORMAT ARE REQUIRED. THE TO-     \"\n   SAY \"       COLUMNS WILL DEFAULT TO THE FROM-COLUMNS.  LABEL   \"\n   SAY \"       RANGES ARE OPTIONAL. FORMAT MAY USE +, -, PERIOD,  \"\n   SAY \"       Z, 9 OR COMMA. ZONED INPUT IS RECOGNIZED.          \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY \"    FORMCOLS  ZZ,ZZZ,ZZ9-  1 8  41 53                \"\n   SAY \"       WILL FORMAT THE ARITHMETIC DATA IN COLUMNS 1  \"\n   SAY \"       THRU 8 INTO 41 THRU 53, RIGHT JUSTIFYING THE  \"\n   SAY \"       RESULT. E.G. 00001234 IN 1 THRU 8 WILL BECOME \"\n   SAY \"       '       1,234 ' IN 41 THRU 53.                \"\n   SAY\n   RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FPEND": {"ttr": 24073, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00*\\x00*\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- FPEND  --  FIND PENDING LINE COMMAND                  **/\n/**                 --  OPTION P WILL CAUSE A BACKWARD SEARCH      **/\n/**                 --  OPTION F WILL FIND THE FIRST PENDING CMD   **/\n   \"ISREDIT MACRO (PARMS) NOPROCESS\"\n   IF PARMS = '?' THEN SIGNAL DISPDOC\n   DIRECTION = 'NEXT'\n   IF PARMS <> '' THEN DO\n      PARMS = TRANSLATE(PARMS)\n      IF PARMS = '-=PFK=-' THEN DO;\n         ADDRESS ISPEXEC \"VGET (FPDIR) SHARED\"\n         DIRECTION = FPDIR\n      END\n      ELSE DO\n         IF SUBSTR(WORD(PARMS,1),1,1) = 'P' THEN DIRECTION = 'PREV'\n         IF SUBSTR(WORD(PARMS,1),1,1) = 'F' THEN DIRECTION = 'FIRST'\n      END\n   END\n   \"ISREDIT LOCATE COM\" DIRECTION\n   FALTNM  = 'FPEND'\n   ADDRESS ISPEXEC \"VPUT (FALTNM) SHARED\"\n   IF DIRECTION = 'FIRST' THEN FPDIR = 'NEXT'\n                          ELSE FPDIR = DIRECTION\n   ADDRESS ISPEXEC \"VPUT (FPDIR)  SHARED\"\n   EXIT(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"FPEND -  DELETE ALL DATA OR MEMBERS FROM DS LIST FILE     \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    FPEND  ( NEXT | PREVIOUS | FIRST )                    \"\n   SAY\n   SAY \"       FIND A PENDING PREFIX COMMAND SUCH AS CC IN THE    \"\n   SAY \"       DIRECTION SPECIFIED. ONLY THE FIRST CHARACTER      \"\n   SAY \"       NEEDS TO BE SPECIFIED AND 'N' FOR NEXT IS THE      \"\n   SAY \"       DEFAULT. THE FALT MACRO MAY BE ASSIGNED TO A PF    \"\n   SAY \"       KEY TO ALLOW REPEAT FINDS.                         \"\n   SAY\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FREE": {"ttr": 24075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\x88\\x00\\x88\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 136, "newlines": 136, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&NAME    FREE  &UNALC,&DSN=,&DDN=,&MEMBER=,&DISP=,&SYSOUT=,            X\n               &ERROR=,&MF=AUTO,&PREFIX=,&FILE=,&F=,&DA=,&HOLD=\n         GBLA  &RCPDYN            COUNTER FOR NO ENTRIES TO MACRO\n         GBLA  &DTUO              OFFSET TO TEXT UNITS\n         GBLA  &DTUPO             OFFSET TO TEXT UNIT POINTERS\n         GBLB  &RCPS99(2)         TELL RCPDSECT NEED DSECTS\n         GBLC  &DYNP              PREFIX FOR LABELS FOR THIS CALL\n         GBLC  &DYNSP         NAME FOR AUTOMATIC STORAGE ALLOC\n         LCLB  &DSECT             DSECT NEEDED FOR STORAGE, MF=E\n         LCLC  &C,&T,&PAR\n&RCPS99(1)     SETB           1\n&RCPDYN  SETA  &RCPDYN+1          INCEREMENT COUNTER\n&DYNP    SETC  'DYN&RCPDYN' SET DEFAULT PREFIX\n&NAME    DS    0H\n         AIF   ('&PREFIX' EQ '').TMF\n         AIF   (K'&PREFIX LT 4).POK\n         MNOTE 4,'PREFIX TOO LONG, 1ST 4 CHARS USED'\n&DYNP    SETC  '&PREFIX'(1,4)\n         AGO   .TMF\n.POK     ANOP\n&DYNP    SETC  '&PREFIX'\n.TMF     AIF   ('&MF(1)' EQ 'G').GEN\n         AIF   ('&MF' NE 'AUTO').TMFE\nNAME     DYNSPACE             GET NAME FOR SPACE\n         LA    R1,&DYNSP               LOAD ADDRESS OF PARAM LIST\n         USING &DYNP.DS,R1             USE GENERATED DSECT\n&T       SETC  'A'\n&PAR     SETC  '&DYNSP+4'\n&DSECT   SETB  1\n         AGO   .START\n.TMFE    AIF   ('&MF(2)' NE '').E2OK\n         MNOTE 4,'PLIST ADDRESS OMITTED, MF=G USED'\n         AGO   .GEN\n.E2OK    ANOP\n&DSECT   SETB  1\n         AIF   ('&MF(2)' EQ '(').RMFE\n         LA    R1,&MF(2)               LOAD PARAM LIST ADDRESS\n&T       SETC  'A'\n&PAR     SETC  '&MF(2)+4'\n         USING &DYNP.DS,R1             USE GENERATED DSECT\n         AGO   .START\n.RMFE    AIF   ('&MF(2)' EQ '(R1)' OR '&MF(2)' EQ '(1)').START\n&PAR     SETC  '&MF(2)'(2,K'&MF(2)-2)\n&T       SETC  'R'\n         LR    R1,&PAR                 LOAD S99 PARAM LIST ADDRESS\n&PAR     SETC  '4&MF(2)'\n         USING &DYNP.DS,R1             USE GENERATED DSECT\n         AGO   .START\n.GEN     LA    R1,&DYNP.RBP            LOAD ADDRESS OF S99 RBP\n&T       SETC  'A'\n&PAR     SETC  '&DYNP.RB'\n.START   LA    R15,&DYNP.RB            LOAD ADDRESS OF S99 RB\n         USING S99RB,R15\n         ST    R15,0(R1)               AND STORE IN RB POINTER\n.*       XC    4(&DYNP.LEN-4,R1),4(R1) ZERO PARAMETER LIST\n         XC    &DYNP.RB(20),&DYNP.RB   ZERO REQUEST BLOCK\n         XC    &DYNP.TUP,&DYNP.TUP     ZERO TEXT UNIT PTRS\n         XC    &DYNP.TU,&DYNP.TU       ZERO TEXT UNITS\n         MVI   S99RBLN,20              MOVE IN LIST LENGTH\n         MVI   S99VERB,S99VRBUN        MOVE IN VERB CODE\n         LA    R14,&DYNP.TUP           LOAD ADDRESS OF TU POINTERS\n         ST    R14,S99TXTPP            STORE ADDRESS IN S99 RB\n         LA    R15,&DYNP.TU            POINT TO SPACE FOR TEXT UNITS\n         USING S99TUNIT,R15\n&DTUO    SETA  0\n&DTUPO   SETA  0\n         AIF   ('&DSN&DA' NE '').DSN\n         AIF   ('&SYSOUT' NE '').SYSOUT\n.TDDN    AIF   ('&DDN&FILE&F' NE '').DDN\n.TDISP   AIF   ('&DISP' NE '').DISP\n.TUNALC  AIF   ('&UNALC' NE '').PERM\n.THOLD   AIF   ('&HOLD' NE '').HOLD\n         AGO   .SVC99\n.DSN     RCPFDSN &DSN&DA,&MEMBER\n         AGO   .TDDN\n.SYSOUT  RCPFSYS &SYSOUT\n         AGO   .TDDN\n.DDN     RCPFDDN &DDN&F&FILE\n         AGO   .TDISP\n.DISP RCPFDISP &DISP\n         AGO   .TUNALC\n.PERM    RCPUNALC\n         AGO   .THOLD\n.HOLD    RCPFHOLD &HOLD\n.SVC99   ANOP\n&DTUPO   SETA  &DTUPO-4\n         SPACE\n         MVI   &DYNP.TUP+&DTUPO,X'80'  SET HIGH ORDER BIT ON TEXT PTRS\n         MVI   &DYNP.RBP,X'80'         SET HIGH ORDER BIT ON RB PTR\n         RCPSR2 UNSAVE\n&DTUPO   SETA  &DTUPO+4\n         AIF   (NOT &DSECT).DYNA\n         DROP  R1,R15                  DEACTIVATE ADDRESSABILITY\n.DYNA    DYNALLOC\n         AIF   ('&ERROR' EQ '').RESERVE\n         AIF   ('&PAR' EQ '').LTR\n         L&T   R14,&PAR                 LOAD REG 14 WITH ADDRESS OF RB\n         AIF   (NOT &DSECT).LTR\n         USING &DYNP.RB,R14            SET UP ADDRESSABILITY\n.LTR     LTR   R15,R15                 TEST RETURN CODE\n         BNZ   &ERROR                  BRANCH IF NON ZERO\n**       NOTE.  R14 POINTS TO REQUEST BLOCK, R15 HAS RETURN CODE     **\n.RESERVE AIF   (&DSECT).RESDS\n         SPACE\n***********************************************************************\n**       RESERVE SPACE FOR DYNALLOC DATA                             **\n***********************************************************************\n         RCPDS\n.SSP     ANOP\n&DYNP.RBP DS   F                       SVC 99 REQ BLOCK POINTER\n&DYNP.RB  DS   5F                      SVC 99 REQUEST BLOCK\n&DYNP.TUP DS   CL&DTUPO                SPACE FOR TEXT POINTERS\n         AIF   (&DTUO EQ 0).DTU11\n&DYNP.TU  DS   CL&DTUO                 SPACE FOR TEXT UNITS\n         AGO   .DTU10\n.DTU11   ANOP\n&DYNP.TU  DS   0C                      NO SPACE NEEDED FOR TEXT UNITS\n.DTU10   ANOP\n&DYNP.LEN EQU  *-&DYNP.RBP             LENGTH OF SPACE USED\n         AIF   (&DSECT).DSP\n         RCPDS\n         SPACE 3\n         AGO   .EXIT\n.RESDS   ANOP\n         AIF   ('&DYNSP' EQ '').SP3\n         DYNSPACE ADD\n.SP3     SPACE\n&DYNP.DS DSECT                         DSECT TO MAP SVC 99 DATA\n         AGO   .SSP\n.DSP     AIF   ('&MF(3)' EQ '').END1\n&MF(3)   EQU   &DYNP.LEN               LENGTH OF AREA\n.END1    ANOP\n&SYSECT  CSECT\n         SPACE 3\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FS": {"ttr": 24323, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00V\\x00V\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 86, "newlines": 86, "modlines": 0, "user": "REXX"}, "text": "/**  REXX  --  SUBMIT A SUPERC SCAN OF A PDS FOR A STRING  **/\n   SAVEMSG = MSG(\"OFF\")\n   CALLED = SYSVAR(SYSNEST)\n   X = ADDRESS()\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT \"ISREDIT MACRO (\"PARMS\")\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      UMODE = 'ISPEXEC'\n      ARG PARMS\n   END\n   IF PARMS = \"?\" | PARMS = \"\" THEN SIGNAL DISPDOC\n   IF SUBSTR(PARMS,1,1) = \"'\" THEN DO\n      DO II = 2 TO LENGTH(PARMS),\n            WHILE(SUBSTR(PARMS,II,1) <> \"'\")\n      END II\n   END\n   ELSE IF SUBSTR(PARMS,1,1) = '\"' THEN DO\n      DO II = 2 TO LENGTH(PARMS),\n            WHILE(SUBSTR(PARMS,II,1) <> '\"')\n      END II\n   END\n   ELSE DO\n      SIGNAL DISPDOC\n   END\n   FINDSTR = SUBSTR(PARMS,2,II-2)\n\n   USER_ID = USERID()\n   PARMS   = TRANSLATE(SUBSTR(PARMS,II+1))\n   DO II = 1 TO LENGTH(PARMS) WHILE(SUBSTR(PARMS,II,1) = ' ')\n   END II\n   IF II > 0 THEN PARMS = SUBSTR(PARMS,II)\n   IF SUBSTR(PARMS,1,1) = \"'\" | SUBSTR(PARMS,1,1) = '\"',\n      THEN PARMS = SUBSTR(PARMS,2,LENGTH(PARMS)-2)\n      ELSE PARMS = USER_ID || \".\" || PARMS\n\n\n   ADDRESS TSO\n   \"FREE DD(SUBXDD)\"\n   \"ALLOC DD(SUBXDD) SYSOUT(A) WRITER(INTRDR)\",\n      \"LRECL(80) BLKSIZE(800) RECFM(F B)\"\n\n   QUEUE \"//\" || USER_ID || \"S    JOB      (ACCT-INFO),'\",\n      || USER_ID || \"',\"\n   QUEUE \"//             CLASS=2,MSGCLASS=X,NOTIFY=\",\n      || USER_ID\n   QUEUE \"//***\"\n   QUEUE \"//SEARCH     EXEC     PGM=ISRSUPC,REGION=4M,\"\n   QUEUE \"//             PARM=(SRCHCMP,\",\n      || \"'ANYC,IDPFX,NOPRTCC,SDUPM,XREF')\"\n   QUEUE \"//OUTDD        DD       SYSOUT=*\"\n   QUEUE \"SRCHFOR  '\" || FINDSTR || \"'\"\n   QUEUE \"//NEWDD        DD       DISP=SHR,DSN=\",\n      || PARMS\n   QUEUE \"//***\"\n\n   \"EXECIO\" QUEUED() \"DISKW SUBXDD (FINIS\"\n   \"FREE DD(SUBXDD)\"\n   CALL SETMSG \"* NO JOB SUBMITTED$JOB SUBMITTED SUCCESSFULLY!\"\n   EXIT(0)\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"FS -- SUBMIT A SUPERC PDS SEARCH FOR A STRING         \"\n   SAY\n   SAY \"   FS  'STRING TO BE FOUND' PDS-TO-BE-SEARCHED        \"\n   SAY\n   SAY \"     STRING MUST BE IN EITHER SINGLE OR DOUBLE QUOTES.\"\n   SAY \"     THE PDS NAME MAY BE FULLY QUALIFIED, I.E. IN     \"\n   SAY \"     QUOTES, OR THE USER-ID WILL BE PREFIXED.         \"\n   SAY\n   SAY \"     A SINGLE QUESTION MARK (?) AS THE ONLY PARAMETER \"\n   SAY \"     WILL CAUSE THIS HELP TO BE DISPLAYED.            \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FX": {"ttr": 24326, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\x1f\\x00\\x1f\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- Edit macro to find a string & show only lines with   */\n/*        the string and a few lines above and below those found. */\n/*        This uses the COMPARE EXCLUDE command to perform the    */\n/*        line exclude function (type COMPARE in Edit).           */\n/* -------------------------------------------------------------- */\nAddress isredit                  /*                               */\n'MACRO (PARM)'                   /* Accept input string           */\nIf parm \u00ac= '' Then               /* Do nothing if no parameters   */\n  Do                             /*                               */\n    'RESET LABEL'                /* Remove all existing labels    */\n    'F FIRST 'parm               /* Find first string occurrence  */\n    Do While(rc=0)               /*   For each occurrence         */\n      'LABEL .ZCSR = 'label()' 0'/*      Assign a label to line   */\n      'RFIND'                    /*      Find next occurrence     */\n    End                          /*                               */\n    'COMPARE X'                  /* Exclude everything except     */\n                                 /*  Labels and above/Below lines */\n    'RESET LABEL'                /* Remove all labels             */\n    '(XSTAT) = XSTATUS .ZFIRST'  /* Save exclude status of line 1 */\n    'LOCATE .ZFIRST'             /* Move display to line 1        */\n    'XSTATUS .ZFIRST = 'xstat    /* Restore line 1 exclude status */\n    'RESET FIND'                 /* Remove hilights from found    */\n  End                            /*                               */\nExit 0                           /* Always return a zero          */\n/* -------------------------------------------------------------- */\nlabel:Procedure Expose labelnum  /* Routine to generate a unique  */\nIf datatype(labelnum,'N')=0 Then /*   Edit line label             */\n  labelnum=0                     /*                               */\nElse                             /*                               */\n  labelnum=labelnum+1            /*                               */\nReturn '.'translate(right(labelnum,4,'0'),'ABCDEFGHIJ','0123456789')\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GATHERX": {"ttr": 24328, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00A\\x00A\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 65, "newlines": 65, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- GATHER ALL THE EXCLUDED LINES AT THE TOP  **/\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'GATHERX MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   UMODE = \"ISREDIT\"\n   ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n   ADDRESS ISREDIT\n   \"MACRO (PARMS) NOPROCESS\"\n   IF PARMS = '?' THEN SIGNAL DISPDOC\n   \"PROCESS RANGE C\"\n   IF RC > 0 THEN\n      DO\n         \"(TOP) = LINENUM .ZFIRST\"\n         \"(BOT) = LINENUM .ZLAST\"\n      END\n   ELSE\n      DO\n         \"(TOP) = LINENUM .ZFRANGE\"\n         \"(BOT) = LINENUM .ZLRANGE\"\n      END\n\n   NUMTIMES = BOT - TOP + 1\n   NUMHANDLED = 0\n\n   DO II = TOP TO BOT\n      \"(LINESTAT) = XSTATUS\" II\n      IF LINESTAT = \"NX\" THEN DO\n         \"ISREDIT (RECORD) = LINE\" II\n         \"ISREDIT LINE_AFTER &BOT = (RECORD)\"\n         \"ISREDIT DELETE\" II\n         II = II - 1\n      END\n      NUMHANDLED = NUMHANDLED + 1\n      IF NUMHANDLED >= NUMTIMES THEN II = BOT + 1\n   END\n\nQUIT:\n   ADDRESS ISPEXEC\n   X=MSG(SAVEMSG)\n   IF TOP = 1 THEN ADDRESS ISREDIT \"LOCATE 0\"\n              ELSE DO\n                 TOP = TOP - 1\n                 ADDRESS ISREDIT \"LOCATE\" TOP\n              END\n   EXIT(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"GATHERX -- PULL ALL EXCLUDED LINES TO THE TOP OF THE FILE \"\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    GATHERX                                               \"\n   SAY \"       ALL EXCLUDED LINES WILL BE MOVED TO THE TOP OF THE \"\n   SAY \"       FILE, KEEPING BOTH THEM AND THE NON-EXCLUDED LINES \"\n   SAY \"       IN THE SAME ORDER.                                 \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETDSN": {"ttr": 24330, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00Z\\x00Z\\x00\\x00\\xc7\\xc5\\xe3\\xc4\\xe2\\xd5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 90, "newlines": 90, "modlines": 0, "user": "GETDSN"}, "text": "//-YOUR-USERID-G JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  RETRIEVE DATA SET NAME AND MEMBER (IF ANY) FOR PASSED COBOL\n//***  FILE NAME; RETURNS BLANKS IF CAN'T RETRIEVE\n//***\n//***  SIMPLY \"CALL 'GETDSN' USING FILE-NAME, RET-DSN, RET-MEM\"\n//***\n//A          EXEC     PGM=ASMA90,REGION=4M,\n//             PARM='RENT'\n//SYSLIB       DD       DISP=SHR,DSN=SYS1.MACLIB\n//             DD       DISP=SHR,DSN=-YOUR-SYSLIB-\n\n*  R3 - INPUT POINTER TO DCB AREA\n*  R4 - RETURNED DATA SET NAME\n*  R5 - RETURNED MEMBER NAME (IF THE DATA SET IS A PDS)\n\n         PRINT NOGEN\n\nGETDSN   AMODE 31\nGETDSN   RMODE ANY\n\n         USING WKAREA,R13\nGETDSN   RENTER  SALEN=WKAREAL\n\n         LM    R3,R5,0(R1)        LOAD PARAMETER ADDRESSES\n\n         MVI   0(R4),C' '         BLANK OUTPUT FIELDS\n         MVC   1(43,R4),0(R4)\n         MVC   0(8,R5),0(R4)\n         MVC   RDJFCB(RDJFCBL),XRDJFCB\n         LA    R14,JFCB           GET READY FOR READ JFCB\n         ST    R14,EXLST\n         MVI   EXLST,X'87'\n         LA    R14,EXLST\n         ST    R14,EXADDR\n         MVC   DUMMYDCB(256),0(R3)  GET DCB OF FILE\n         LA    R10,DUMMYDCB\n         USING IHADCB,R10\n         MVC   DCBEXLSA,EXADDR+1\n\n         RDJFCB  DUMMYDCB,MF=(E,RDJFCB)  GET DSN & VOLSER\n\n         LTR   R15,R15\n         BNZ   RETURN\n         MVC   0(44,R4),JFCBDSNM\n         TM    JFCBIND1,JFCPDS    CHECK IF PICK UP MEMBER NAME\n         BZ    RETURN\n         MVC   0(8,R5),JFCBELNM\n\nRETURN   EQU   *\n         REXIT\n\nXRDJFCB  RDJFCB  (0),MF=L\n\nWKAREA   DSECT\nSAVEAREA DS    9D\nDUMMYDCB DS    CL512\nEXADDR   DS    A\nEXLST    DS    A\nJFCB     DS   0CL176\n         IEFJFCBN  ,  LIST=YES\nRDJFCB   RDJFCB  (DUMMYDCB),MF=L\nRDJFCBL  EQU   *-RDJFCB\nWKAREAL  EQU   *-WKAREA\n\n         DCBD  DSORG=(PS,PO),DEVD=DA\n\n         END   GETDSN\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//***\n//L          EXEC     PGM=IEWL,\n//             PARM='RENT,AMODE(31),RMODE(ANY)',\n//             REGION=4M,COND=(5,LE)\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,\n//             DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   99092400\n  ENTRY    GETDSN\n  NAME     GETDSN(R)\n//***\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETDSNS": {"ttr": 24333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00s\\x00s\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 115, "newlines": 115, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- FILE LIST INSERTION MACRO  **/\n\n   \"ISREDIT MACRO (QUAL,OPTION)\"\n   IF QUAL = '' | QUAL = '?' THEN SIGNAL DISPDOC\n   QUAL  = TRANSLATE(QUAL)\n   OPTION = TRANSLATE(OPTION)\n   IF OPTION = '' | OPTION <> 'STATS' THEN SIGNAL NOSTATS\n\n/* HEADER */\n   DSNVAR  = 'DATA.SET.NAME................................'\n   ZDLVOL  = 'VOLUME'\n   ZDLSIZE = '.TRACKS.'\n   \"ISREDIT (LINE) = CURSOR\"\n   IF LINE = 1  THEN DO\n       ADDRESS ISPEXEC 'VGET (ZSCREENC,ZSCREENI) SHARED'\n       II = INDEX(ZSCREENI,'* Top of Data *')\n       IF ( ZSCREENC % 80 )  <=  ( II % 80 )  THEN LINE = 0\n   END\n   \"ISREDIT LINE_AFTER &LINE = < 1 '&DSNVAR &ZDLVOL &ZDLSIZE' >\"\n   DSNVAR  = '$$ NONE FOUND $$'\n   TOTTRKS = 0\n\n/* PRIMING \"READ\" */\n   \"ISPEXEC LMDINIT LISTID(DSLIST) LEVEL(&QUAL)\"\n   \"ISPEXEC LMDLIST LISTID(&DSLIST)\",\n          \"DATASET(DSNVAR) OPTION(LIST) STATS(YES)\"\n   IF ZDLMIGR = 'YES' THEN ZDLVOL = 'MIGRAT'\n   DSNVAR  = LEFT(DSNVAR,44)\n   DSNVAR  = DSNVAR || '='\n   ZDLSIZE = RIGHT(ZDLSIZE,8)\n   LINE    = LINE + 1\n   \"ISREDIT LINE_AFTER &LINE = < 1 '&DSNVAR &ZDLVOL &ZDLSIZE' >\"\n   IF DATATYPE(ZDLSIZE,N) THEN TOTTRKS = TOTTRKS + ZDLSIZE\n\n/* \"READ\" LOOP */\n   DO WHILE RC = 0\n      \"ISPEXEC LMDLIST LISTID(&DSLIST)\",\n               \"DATASET(DSNVAR) OPTION(LIST) STATS(YES)\"\n      IF RC > 0 THEN LEAVE\n      IF ZDLMIGR = 'YES' THEN ZDLVOL = 'MIGRAT'\n      DSNVAR  = LEFT(DSNVAR,44)\n      DSNVAR  = DSNVAR || '='\n      ZDLSIZE = RIGHT(ZDLSIZE,8)\n      LINE    = LINE + 1\n      \"ISREDIT LINE_AFTER &LINE = < 1 '&DSNVAR &ZDLVOL &ZDLSIZE' >\"\n      IF DATATYPE(ZDLSIZE,N) THEN TOTTRKS = TOTTRKS + ZDLSIZE\n   END\n   LINE = LINE + 1\n   \"ISREDIT LINE_AFTER &LINE = \",\n   \"< 1 '..................................TOTAL TRACKS = &TOTTRKS' >\"\n   \"ISPEXEC LMDLIST LISTID(&DSLIST)\" \"OPTION(FREE)\"\n   EXIT(0)\n\nNOSTATS:                /* NO STATISTICS JUST NAMES */\n   DSNVAR = '$$ NONE FOUND $$'\n   IF OPTION = 'DD' THEN LINE_UP = 2\n                    ELSE LINE_UP = 1\n   \"ISREDIT (LINE) = CURSOR\"\n   IF LINE = 1  THEN DO\n       ADDRESS ISPEXEC 'VGET (ZSCREENC,ZSCREENI) SHARED'\n       II = INDEX(ZSCREENI,'* Top of Data *')\n       IF ( ZSCREENC % 80 )  <=  ( II % 80 )  THEN LINE = 0\n   END\n\n/* PRIMING \"READ\" */\n   \"ISPEXEC LMDINIT LISTID(DSLIST) LEVEL(&QUAL)\"\n   \"ISPEXEC LMDLIST LISTID(&DSLIST)\",\n          \"DATASET(DSNVAR) OPTION(LIST)\"\n   IF OPTION = 'DD' THEN DO\n      DSNVAR = '//             DSN=' || DSNVAR\n      \"ISREDIT LINE_AFTER &LINE = < 1 '&DSNVAR' >\"\n      DDVAR  = '//             DD       DISP=SHR,'\n      \"ISREDIT LINE_AFTER &LINE = < 1 '&DDVAR' >\"\n   END\n   ELSE \"ISREDIT LINE_AFTER &LINE = < 1 '&DSNVAR' >\"\n\n/* \"READ\" LOOP */\n   DO WHILE RC = 0\n      \"ISPEXEC LMDLIST LISTID(&DSLIST)\",\n               \"DATASET(DSNVAR) OPTION(LIST)\"\n      IF RC > 0 THEN LEAVE\n      LINE = LINE + LINE_UP\n      IF OPTION = 'DD' THEN DO\n         DSNVAR = '//             DSN=' || DSNVAR\n         \"ISREDIT LINE_AFTER &LINE = < 1 '&DSNVAR' >\"\n         DDVAR  = '//             DD       DISP=SHR,'\n         \"ISREDIT LINE_AFTER &LINE = < 1 '&DDVAR' >\"\n      END\n      ELSE \"ISREDIT LINE_AFTER &LINE = < 1 '&DSNVAR' >\"\n   END\n   \"ISPEXEC LMDLIST LISTID(&DSLIST)\" \"OPTION(FREE)\"\n   EXIT(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"GETDSNS - PLACE LIST OF DATA SETS AFTER CURSOR            \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    GETDSNS  ( WILDCARD-LIST | ? )  ( STATS | DD )        \"\n   SAY\n   SAY \"       DO EQUIVALENT OF DS LIST SCAN FOR DATA SETS AND    \"\n   SAY \"       PLACE LIST AFTER CURSOR POSITION. FOR EXAMPLE:     \"\n   SAY\n   SAY \"          GETDSNS  SYS2.CA*.V1R1.**                       \"\n   SAY\n   SAY \"       WOULD GATHER THE CATALOGED DATA SETS MATCHING      \"\n   SAY \"       THE WILDCARDS AND PASTE THEM INTO THE EDITED FILE  \"\n   SAY \"       AFTER WHERE THE CURSOR IS POSITIONED. SPECIFYING   \"\n   SAY \"       'STATS' CAUSES VOLSER AND SIZE DATA TO BE ADDED,   \"\n   SAY \"       WHILE 'DD' CAUSES THE DATA SET(S) TO BE WITHIN     \"\n   SAY \"       A //..DD..DISP=SHR,DSN= CARD IMAGE.                \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETGDGS": {"ttr": 24336, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00h\\x00h\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 104, "newlines": 104, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- GDG FILES INSERTION MACRO - IN REVERSE ORDER  **/\n\n   \"ISREDIT MACRO (QUAL,OPTION)\"\n   IF QUAL = '' | QUAL = '?' THEN SIGNAL DISPDOC\n   QUAL   = TRANSLATE(QUAL)\n   OPTION = TRANSLATE(OPTION)\n   IF OPTION = '' | OPTION <> 'STATS' THEN SIGNAL NOSTATS\n\n/* HEADER ET AL FOR STATISTICS */\n   DSNVAR  = 'DATA.SET.NAME................................'\n   ZDLVOL  = 'VOLUME'\n   ZDLSIZE = '.TRACKS.'\n   \"ISREDIT (LINE) = CURSOR\"\n   IF LINE = 1  THEN DO\n       ADDRESS ISPEXEC 'VGET (ZSCREENC,ZSCREENI) SHARED'\n       II = INDEX(ZSCREENI,'* Top of Data *')\n       IF ( ZSCREENC % 80 )  <=  ( II % 80 )  THEN LINE = 0\n   END\n   \"ISREDIT LINE_AFTER &LINE = < 1 '&DSNVAR &ZDLVOL &ZDLSIZE' >\"\n   DSNVAR  = '$$ NONE FOUND $$'\n   TOTTRKS = 0\n\n/* PRIMING \"READ\" */\n   \"ISPEXEC LMDINIT LISTID(DSLIST) LEVEL(&QUAL)\"\n   \"ISPEXEC LMDLIST LISTID(&DSLIST)\",\n          \"DATASET(DSNVAR) OPTION(LIST) STATS(YES)\"\n\n/* \"READ\" LOOP */\n   DO WHILE RC = 0\n      \"ISPEXEC LMDLIST LISTID(&DSLIST)\",\n               \"DATASET(DSNVAR) OPTION(LIST) STATS(YES)\"\n      IF RC > 0 THEN LEAVE\n      IF ZDLMIGR = 'YES' THEN ZDLVOL = 'MIGRAT'\n      DSNVAR  = STRIP(LEFT(DSNVAR,44),\"T\")\n      DSNVAR  = DSNVAR || '='\n      ZDLSIZE = RIGHT(ZDLSIZE,8)\n      LINE    = LINE + 1\n      \"ISREDIT LINE_AFTER &LINE = < 1 '&DSNVAR &ZDLVOL &ZDLSIZE' >\"\n      IF DATATYPE(ZDLSIZE,N) THEN TOTTRKS = TOTTRKS + ZDLSIZE\n   END\n   LINE = LINE + 1\n   \"ISREDIT LINE_AFTER &LINE = \",\n   \"< 1 '..................................TOTAL TRACKS = &TOTTRKS' >\"\n   \"ISPEXEC LMDLIST LISTID(&DSLIST)\" \"OPTION(FREE)\"\n   EXIT(0)\n\nNOSTATS:                /* NO STATISTICS JUST NAMES */\n   DSNVAR = '$$ NONE FOUND $$'\n   IF OPTION = 'DD' THEN LINE_UP = 2\n                    ELSE LINE_UP = 1\n   \"ISREDIT (LINE) = CURSOR\"\n   IF LINE = 1  THEN DO\n       ADDRESS ISPEXEC 'VGET (ZSCREENC,ZSCREENI) SHARED'\n       II = INDEX(ZSCREENI,'* Top of Data *')\n       IF ( ZSCREENC % 80 )  <=  ( II % 80 )  THEN LINE = 0\n   END\n\n/* PRIMING \"READ\" */\n   \"ISPEXEC LMDINIT LISTID(DSLIST) LEVEL(&QUAL)\"\n   \"ISPEXEC LMDLIST LISTID(&DSLIST)\",\n          \"DATASET(DSNVAR) OPTION(LIST)\"\n\n/* \"READ\" LOOP */\n   DO WHILE RC = 0\n      \"ISPEXEC LMDLIST LISTID(&DSLIST)\",\n               \"DATASET(DSNVAR) OPTION(LIST)\"\n      DSNVAR  = STRIP(LEFT(DSNVAR,44),\"T\")\n      IF RC > 0 THEN LEAVE\n      IF OPTION = 'DD' THEN DO\n         DSNVAR = '//             DSN=' || DSNVAR\n         \"ISREDIT LINE_AFTER &LINE = < 1 '&DSNVAR' >\"\n         DDVAR  = '//             DD       DISP=SHR,'\n         \"ISREDIT LINE_AFTER &LINE = < 1 '&DDVAR' >\"\n      END\n      ELSE \"ISREDIT LINE_AFTER &LINE = < 1 '&DSNVAR' >\"\n      LINE = LINE + LINE_UP\n   END\n   \"ISPEXEC LMDLIST LISTID(&DSLIST)\" \"OPTION(FREE)\"\n   EXIT(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"GETGDGS - PLACE LIST OF GDG DATA SETS AFTER CURSOR        \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    GETGDGS  ( WILDCARD-LIST | ? )  ( STATS | DD )        \"\n   SAY\n   SAY \"       DO EQUIVALENT OF DS LIST SCAN FOR DATA SETS WITHIN \"\n   SAY \"       THE SUPPLIED GENERATION DATA GROUP AND PLACE THEM  \"\n   SAY \"       AFTER WHERE THE CURSOR IS POSITIONED. FOR EXAMPLE: \"\n   SAY \"          GETGDGS  SYS4.CATOOL.BACKUP                     \"\n   SAY \"       WOULD GATHER THE CATALOGED DATA SET(S) MATCHING    \"\n   SAY \"       THE WILDCARD AND PASTE THEM INTO THE EDITED FILE   \"\n   SAY \"       AFTER WHERE THE CURSOR IS POSITIONED. THESE WILL   \"\n   SAY \"       ALWAYS BE IN REVERSE ORDER, E.G. GENERATION 3, THEN\"\n   SAY \"       2, THEN 1 TO FACILITATE OLDEST FIRST USE. SPECIFY  \"\n   SAY \"       'STATS' TO GET DATA SET STATISTICS, 'DD' TO CAUSE  \"\n   SAY \"       JCL DD CARD IMAGES TO BE GENERATED AND '?' TO GET  \"\n   SAY \"       THIS HELP.                                         \"\n   EXIT(1)\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETMEMS": {"ttr": 24577, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x004\\x004\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- MEMBER LIST INSERTION MACRO  **/\n\n   \"ISREDIT MACRO (PARMS)\"\n   PARMS = TRANSLATE(PARMS)\n   IF PARMS = \"\" | PARMS = \"?\" THEN SIGNAL DISPDOC\n   IF INDEX(PARMS,\"(\") <> 0 THEN DO\n      II = INDEX(PARMS,\"(\")\n      IF SUBSTR(PARMS,1,1) = \"'\" THEN DS = SUBSTR(PARMS,1,II-1) || \"'\"\n                                 ELSE DS = SUBSTR(PARMS,1,II-1)\n      JJ = INDEX(PARMS,\")\")\n      MWC = SUBSTR(PARMS,II+1,JJ-II-1)\n      II = INDEX(MWC,\"*\")\n      IF II > 0 THEN MWC = SUBSTR(MWC,1,II-1)\n   END\n   ELSE DO\n      DS = PARMS\n      MWC = \"*\"\n   END\n\n   \"ISREDIT (LINE) = CURSOR\"\n   X=OUTTRAP(MEMBER.)\n   \"LISTDS\" DS \"HIST MEMBER\"\n   X=OUTTRAP('OFF')\n   DO II = MEMBER.0 TO 1 BY -1\n      IF MEMBER.II = \"--MEMBERS--\" THEN LEAVE\n      MEMBER.II = STRIP(MEMBER.II,'L')\n      MEMNAME = MEMBER.II\n      IF MWC = \"*\" | SUBSTR(MEMNAME,1,LENGTH(MWC)) = MWC,\n         THEN \"ISREDIT LINE_AFTER &LINE = '&MEMNAME'\"\n   END\n   EXIT(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"GETMEMS - PLACE LIST OF MEMBER NAMES AFTER CURSOR         \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    GETMEMS  PDS | ?                                      \"\n   SAY\n   SAY \"       RETRIEVE MEMBER LIST FROM DATA SET PROVIDED AND    \"\n   SAY \"       PLACE LIST AFTER CURSOR. A WILDCARD MAY BE USED AS \"\n   SAY\n   SAY \"          GETMEMS  'SYS4.REXX.EXEC(HI*)'                  \"\n   SAY\n   SAY \"       WOULD ONLY LIST THOSE MEMBERS OF THE PDS WITH      \"\n   SAY \"       'HI' AS THE FIRST CHARACTERS OF EACH MEMBER.  IF   \"\n   SAY \"       NO PARAMETERS ARE PASSED OR A SINGLE QUESTION MARK \"\n   SAY \"       (?), THIS HELP WILL BE DISPLAYED.                  \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETRGNSZ": {"ttr": 24579, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\"\\x00\"\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "REXX"}, "text": "/* REXX                                  */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/* Last Updated 02/28/2001               */\n/*********************************************************************/\n/* This exec will show the virtual storage usage of the task that    */\n/* invokes the REXX exec.  This could be an interactive TSO user, a  */\n/* batch TSO step, or even a Unix System Services user / Web server. */\n/*********************************************************************/\nNumeric digits 10\nASCB     = C2d(Storage(224,4))               /* current ASCB         */\nLDA      = C2d(Storage(D2x(ASCB + 48),4))    /* local data area      */\nLDALIMIT = C2d(storage(D2x(LDA + 208),4))    /* <16m v=v             */\nLDALIMIT = Right(LDALIMIT/1024,9)            /* convert to kbytes    */\nLDALOAL  = C2d(storage(D2x(LDA + 232),4))    /* <16m v=v alloc       */\nLDALOAL  = Right(LDALOAL/1024,9)             /* convert to kbytes    */\nLDAELIM  = C2d(storage(D2x(LDA + 216),4))    /* >16m v=v             */\nLDAELIM  = Right(LDAELIM/1024,9)             /* convert to kbytes    */\nLDAELOAL = C2d(storage(D2x(LDA + 240),4))    /* >16m v=v alloc       */\nLDAELOAL = Right(LDAELOAL/1024,9)            /* convert to kbytes    */\nLDAREGRQ = C2d(storage(D2x(LDA + 204),4))    /* region requested     */\nLDAREGRQ = LDAREGRQ/1024                     /* convert to kbytes    */\nAVAIL    = Right(LDALIMIT-LDALOAL,9)         /* available <16M       */\nEAVAIL   = Right(LDAELIM-LDAELOAL,9)         /* available >16M       */\nSay ''\nSay 'V I R T U A L    S T O R A G E    U S A G E'\nSay '-------------------------------------------'\nSay ' '\nSay '        Region requested:' LDAREGRQ'K'\nSay ' '\nSay '                Limit     In-Use      Avail'\nSay 'Below 16M:' LDALIMIT'K' LDALOAL'K' AVAIL'K'\nSay 'Above 16M:' LDAELIM'K' LDAELOAL'K' EAVAIL'K'\nExit 0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GMT": {"ttr": 24581, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\t\\x00\\t\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "REXX"}, "text": "/* REXX - GET AND DISPLAY THE GMT OFFSET */\nCVT   = STORAGE(10,4)                      /*GET THE CVT ADDRESS*/\nCVTTZ = STORAGE(D2X(C2D(CVT)+X2D(130)),4)  /*GET CVTTZ VALUE*/\nGMT_OFFSET = TRUNC(C2D(CVTTZ,4) * 1.048576 / 3600) /*CONVERT TO OFFSET*/\nIF SIGN(GMT_OFFSET) < 0 THEN GMT_SIGN = '-'\n                        ELSE GMT_SIGN = '+'\nGMT_OFFSET_HHMM = GMT_SIGN||RIGHT(ABS(GMT_OFFSET)*100,4,'0') /*FORMAT*/\nSAY GMT_OFFSET_HHMM\nEXIT(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HEXDUMP": {"ttr": 24583, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00r\\x00r\\x00\\x00\\xc8\\xc5\\xe7\\xc4\\xe4\\xd4\\xd7@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 114, "newlines": 114, "modlines": 0, "user": "HEXDUMP"}, "text": "//-YOUR-USERID-H JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//C          EXEC     PGM=IEL0AA,REGION=4M,\n//             PARM=('AG,A,NCT,ESD,F(I),NOFLOW,NIS,NOLIST,M,NMI,NEST',\n//             'MAP,OF,OPT(TIME),OP,SZ(MAX),S,STMT,STG,X(F)')\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-PLI-LIB-\n\n /***  BASIC INPUT & PRINT W/ HEX PL/I PROGRAM  ***/\n\n HEXDUMP: PROC OPTIONS(MAIN) REORDER;\n\n        DCL  REC       CHAR(32700)   STATIC VARYING;\n        DCL  I_EOF_IND CHAR(01)      STATIC INIT('N');\n        DCL  II        FIXED BIN(31) STATIC INIT(0);\n        DCL  READ#     FIXED BIN(31) STATIC INIT(0);\n        DCL  PRINTED#  FIXED BIN(31) STATIC INIT(0);\n        DCL  DATE      BUILTIN;\n        DCL  TIME      BUILTIN;\n        DCL  TO_HEX1   CHAR(256)     STATIC;\n        DCL  TO_HEX2   CHAR(256)     STATIC;\n        DCL  MASK      CHAR(41)      STATIC INIT(' ');\n        DCL  FROM      CHAR(44)      STATIC INIT(' ');\n        DCL  REC#      PIC'ZZZZ9'    STATIC INIT(0);\n        DCL  1  DATAOUT STATIC,\n            10  RECNO  CHAR(05)      INIT(' '),\n            10  HEX_OP CHAR(44)      INIT(' '),\n            10  FILL10 CHAR(02)      INIT(' *'),\n            10  CHR_OP CHAR(20)      INIT(' '),\n            10  FILL20 CHAR(01)      INIT('*');\n        DCL  1  NULLOUT STATIC,\n            10  REC##  CHAR(05)      INIT(' '),\n            10  NULMSG CHAR(44)\n                INIT('       --- NULL (0 LENGTH) RECORD ---       '),\n            10  NULFIL CHAR(02)      INIT(' *'),\n            10  NULCHR CHAR(20)      INIT(' '),\n            10  NULTRM CHAR(01)      INIT('*');\n\n        ON ENDFILE(SYSUT1) I_EOF_IND = 'Y';\n        TO_HEX1 = (16)'0' || (16)'1' || (16)'2' || (16)'3'\n               || (16)'4' || (16)'5' || (16)'6' || (16)'7'\n               || (16)'8' || (16)'9' || (16)'A' || (16)'B'\n               || (16)'C' || (16)'D' || (16)'E' || (16)'F';\n        TO_HEX2 = (16)'0123456789ABCDEF';\n\n        READ FILE(SYSUT1) INTO(REC);\n\n        DO WHILE ( I_EOF_IND  = 'N' );\n           READ# = READ# + 1;\n           IF LENGTH(REC) > 0\n              THEN DO;\n                 II    = LENGTH(REC);\n                 REC#  = READ#;\n                 RECNO = REC#;\n                 DO WHILE ( II > 0 );\n                    CHR_OP = SUBSTR(REC,1);\n                    MASK = TRANSLATE(CHR_OP,TO_HEX1)\n                       ||  TRANSLATE(CHR_OP,TO_HEX2);\n                    FROM\n                       = '&0K1L2M3N4O&5P6Q7R8S9T&AUBVCWDXEY&FZG@H#I$J%';\n                    IF II < 20\n                       THEN SUBSTR(FROM,(II*2)+(((II*2)/10)+2))\n                          = (44)'&';\n                    HEX_OP = TRANSLATE(\n                       FROM,\n                       MASK,\n                       '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$%&');\n                    WRITE FILE(SYSUT2) FROM(DATAOUT);\n                    RECNO = ' ';\n                    REC = SUBSTR(REC,21);\n                    II = II - 20;\n                    END;        /**  DO WHILE ( II > 0 )  **/\n                 END;           /**  IF LENGTH(REC) > 0  THEN...  **/\n              ELSE DO;\n                 REC#  = READ#;\n                 REC## = REC#;\n                 WRITE FILE(SYSUT2) FROM(NULLOUT);\n                 END;           /**  IF LENGTH(REC) > 0  ELSE...  **/\n           PRINTED# = PRINTED# + 1;\n           READ FILE(SYSUT1) INTO(REC);\n           END;                 /**  DO WHILE ( I_EOF_IND  = 'N' )  **/\n\n        PUT EDIT ( '**************************************' )\n                 ( SKIP(1), A );\n        PUT EDIT ( '***  ', DATE, ' STATISTICS ', TIME, '  ****' )\n                 ( SKIP(1), A, A, A, A, A );\n        PUT EDIT ( '**************************************' )\n                 ( SKIP(1), A );\n        PUT EDIT ( '***  NUMBER RECORDS READ:    ', READ# )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        PUT EDIT ( '***  NUMBER RECORDS PRINTED: ', PRINTED# )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        END HEXDUMP;\n\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//***\n//L          EXEC     PGM=HEWLKED,\n//             PARM='XREF,LIST,LET,DCBS',\n//             REGION=4M\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE)\n//             DD       *\n  SETSSI   98121300\n  ENTRY    PLISTART\n  NAME     HEXDUMP(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HEXDUMP$": {"ttr": 24586, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\r\\x00\\r\\x00\\x00\\xc8\\xc5\\xe7\\xc4\\xe4\\xd4\\xd7@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "HEXDUMP"}, "text": "//-YOUR-USERID-H JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n/*JOBPARM    LINES=999\n//***\n//***  HEX LIST A SEQUENTIAL FILE\n//***\n//HEXDUMP    EXEC     PGM=HEXDUMP,REGION=4M\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSUT2       DD       SYSOUT=*,DCB=(RECFM=F,LRECL=72,BLKSIZE=72)\n//SYSPRINT     DD       SYSOUT=*\n//SYSUT1       DD       DCB=BUFNO=32,\n//             DISP=SHR,DSN=...\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HEXUDUM$": {"ttr": 24588, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc8\\xc5\\xe7\\xe4\\xc4\\xe4\\xd4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "HEXUDUM"}, "text": "//-YOUR-USERID-H JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n/*JOBPARM    LINES=999\n//***\n//***  HEX LIST A SEQUENTIAL FILE AS RECFM = U\n//***\n//HEXUDUMP   EXEC     PGM=HEXUDUMP,REGION=128M\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSUT2       DD       SYSOUT=*,DCB=(RECFM=F,LRECL=72,BLKSIZE=72)\n//SYSPRINT     DD       SYSOUT=*\n//SYSUT1       DD       DISP=SHR,DSN=...\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HEXUDUMP": {"ttr": 24590, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00v\\x00v\\x00\\x00\\xc8\\xc5\\xe7\\xe4\\xc4\\xe4\\xd4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 118, "newlines": 118, "modlines": 0, "user": "HEXUDUM"}, "text": "//-YOUR-USERID-H JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//C          EXEC     PGM=IEL0AA,REGION=4M,\n//             PARM=('AG,A,NCT,ESD,F(I),NOFLOW,NIS,NOLIST,M,NMI,NEST',\n//             'MAP,OF,OPT(TIME),OP,SZ(MAX),S,STMT,STG,X(F)')\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-PLI-LIB-\n\n /***  BASIC INPUT & PRINT AS RECFM=U IN HEX PL/I PROGRAM  ***/\n\n HEXUDUM: PROC OPTIONS(MAIN) REORDER;\n\n        DCL  REC       CHAR(32760)   STATIC VARYING;\n        DCL  SYSUT1    FILE INPUT RECORD SEQL\n                       ENV( U, RECSIZE(0), BLKSIZE(32760),\n                           BUFFERS(32), TOTAL );\n        DCL  SYSUT1_EOF_IND  CHAR(01) STATIC INIT('N');\n        DCL  II        FIXED BIN(31)  STATIC INIT(0);\n        DCL  READ#     FIXED BIN(31)  STATIC INIT(0);\n        DCL  PRINTED#  FIXED BIN(31)  STATIC INIT(0);\n        DCL  DATE      BUILTIN;\n        DCL  TIME      BUILTIN;\n        DCL  TO_HEX1   CHAR(256)     STATIC;\n        DCL  TO_HEX2   CHAR(256)     STATIC;\n        DCL  MASK      CHAR(41)      STATIC INIT(' ');\n        DCL  FROM      CHAR(44)      STATIC INIT(' ');\n        DCL  REC#      PIC'ZZZZ9'    STATIC INIT(0);\n        DCL  1  DATAOUT STATIC,\n            10  RECNO  CHAR(05)      INIT(' '),\n            10  HEX_OP CHAR(44)      INIT(' '),\n            10  FILL10 CHAR(02)      INIT(' *'),\n            10  CHR_OP CHAR(20)      INIT(' '),\n            10  FILL20 CHAR(01)      INIT('*');\n        DCL  1  NULLOUT STATIC,\n            10  REC##  CHAR(05)      INIT(' '),\n            10  NULMSG CHAR(44)\n                INIT('       --- NULL (0 LENGTH) RECORD ---       '),\n            10  NULFIL CHAR(02)      INIT(' *'),\n            10  NULCHR CHAR(20)      INIT(' '),\n            10  NULTRM CHAR(01)      INIT('*');\n\n        TO_HEX1 = (16)'0' || (16)'1' || (16)'2' || (16)'3'\n               || (16)'4' || (16)'5' || (16)'6' || (16)'7'\n               || (16)'8' || (16)'9' || (16)'A' || (16)'B'\n               || (16)'C' || (16)'D' || (16)'E' || (16)'F';\n        TO_HEX2 = (16)'0123456789ABCDEF';\n\n        OPEN FILE(SYSUT1);\n        ON ENDFILE(SYSUT1) SYSUT1_EOF_IND = 'Y';\n        READ FILE(SYSUT1) INTO(REC);\n\n        DO WHILE ( SYSUT1_EOF_IND = 'N' );\n           READ# = READ# + 1;\n           IF LENGTH(REC) > 0\n              THEN DO;\n                 II    = LENGTH(REC);\n                 REC#  = READ#;\n                 RECNO = REC#;\n                 DO WHILE ( II > 0 );\n                    CHR_OP = SUBSTR(REC,1);\n                    MASK = TRANSLATE(CHR_OP,TO_HEX1)\n                       ||  TRANSLATE(CHR_OP,TO_HEX2);\n                    FROM\n                       = '&0K1L2M3N4O&5P6Q7R8S9T&AUBVCWDXEY&FZG@H#I$J%';\n                    IF II < 20\n                       THEN SUBSTR(FROM,(II*2)+(((II*2)/10)+2))\n                          = (44)'&';\n                    HEX_OP = TRANSLATE(\n                       FROM,\n                       MASK,\n                       '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$%&');\n                    WRITE FILE(SYSUT2) FROM(DATAOUT);\n                    RECNO = ' ';\n                    REC = SUBSTR(REC,21);\n                    II = II - 20;\n                    END;        /**  DO WHILE ( II > 0 )  **/\n                 END;           /**  IF LENGTH(REC) > 0  THEN...  **/\n              ELSE DO;\n                 REC#  = READ#;\n                 REC## = REC#;\n                 WRITE FILE(SYSUT2) FROM(NULLOUT);\n                 END;           /**  IF LENGTH(REC) > 0  ELSE...  **/\n           PRINTED# = PRINTED# + 1;\n           READ FILE(SYSUT1) INTO(REC);\n           END;  /**  DO WHILE ( SYSUT1_EOF_IND = 'N' ) **/\n\n        PUT EDIT ( '**************************************' )\n                 ( SKIP(1), A );\n        PUT EDIT ( '***  ', DATE, ' STATISTICS ', TIME, '  ****' )\n                 ( SKIP(1), A, A, A, A, A );\n        PUT EDIT ( '**************************************' )\n                 ( SKIP(1), A );\n        PUT EDIT ( '***  NUMBER RECORDS READ:    ', READ# )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        PUT EDIT ( '***  NUMBER RECORDS PRINTED: ', PRINTED# )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        END HEXUDUM;\n\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//***\n//L          EXEC     PGM=HEWLKED,\n//             PARM='XREF,LIST,LET,DCBS',\n//             REGION=4M\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE)\n//             DD       *\n  SETSSI   99082801\n  ENTRY    PLISTART\n  NAME     HEXUDUMP(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HEXUIDC$": {"ttr": 24593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\n\\x00\\n\\x00\\x00\\xc9\\xc4\\xc3\\xc1\\xd4\\xe2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "IDCAMS"}, "text": "//-YOUR-USERID-H JOB  (ACCT-INFO),'-YOUR-USERID-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//A          EXEC     PGM=IDCAMS\n//SYSPRINT     DD       SYSOUT=*\n//I            DD       DISP=SHR,DCB=(RECFM=U,BLKSIZE=32760),\n//             DSN=...\n//SYSIN        DD       *\n  PRINT INFILE(I) DUMP\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HOWLONG": {"ttr": 24595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00_\\x00_\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 95, "newlines": 95, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- SHOW SHOW SHORTEST & LONGEST REC SIZE UNDER ISPF 3.4)  **/\n/**          FOR FIXED, LONGEST HAS THE LEAST NUMBER OF BLANKS ON   **/\n/**          THE RIGHT; SHORTEST HAS THE GREATEST                   **/\n   PARSE ARG ZINPDSN\n   MSG = MSG(OFF)\n   IF SUBSTR(ZINPDSN,1,1) = '?' THEN SIGNAL DISPDOC\n   \"FREE  F(INFILE)\"\n   \"ALLOC DSN(\"ZINPDSN\") F(INFILE) SHR BUFNO(30)\"\n   \"EXECIO 0 DISKR\" INFILE \"(OPEN\"\n   LONGEST_SIZE  = 0\n   SHORTEST_SIZE = 32767\n   \"EXECIO 100 DISKR INFILE(STEM RECS.\"\n   RETCODE = RC\n\n   LDSI = LISTDSI(ZINPDSN)\n   IF INDEX(SYSRECFM,'F') <> 0 THEN DO\n                   /* FOR FIXED, COUNT # BLANKS AT END */\n                   /* RATHER THEN ACTUAL RECORD LENGTH */\n      LL = SYSLRECL\n      DO WHILE(RETCODE = 0)\n         DO II = 1 TO RECS.0\n            DO JJ = LL TO 1 BY -1 WHILE(SUBSTR(RECS.II,JJ,1) = ' ')\n            END\n            IF JJ > LONGEST_SIZE,\n               THEN LONGEST_SIZE = JJ\n            IF JJ < SHORTEST_SIZE,\n               THEN SHORTEST_SIZE = JJ\n         END\n         \"EXECIO 100 DISKR INFILE(STEM RECS.\"\n         RETCODE = RC\n      END\n\n      DO II = 1 TO RECS.0\n         DO JJ = LL TO 1 BY -1 WHILE(SUBSTR(RECS.II,JJ,1) = ' ')\n         END\n         IF JJ > LONGEST_SIZE\n            THEN LONGEST_SIZE = JJ\n         IF JJ < SHORTEST_SIZE\n            THEN SHORTEST_SIZE = JJ\n      END\n\n      \"EXECIO 0 DISKR\" INFILE \"(FINIS\"\n      SAY ZINPDSN \"- LONGEST/SHORTEST IS\" LONGEST_SIZE\"/\"SHORTEST_SIZE\n      SAY \"  ----- BASED ON BLANKS AT END OF RECORDS (FIXED DATA SET)\"\n      \"FREE  F(INFILE)\"\n      IF RETCODE = 2 THEN EXIT(0)\n                     ELSE EXIT(RETCODE)\n   END\n   ELSE DO\n      DO WHILE(RETCODE = 0)\n         DO II = 1 TO RECS.0\n            IF LENGTH(RECS.II) > LONGEST_SIZE,\n               THEN LONGEST_SIZE = LENGTH(RECS.II)\n            IF LENGTH(RECS.II) < SHORTEST_SIZE,\n               THEN SHORTEST_SIZE = LENGTH(RECS.II)\n         END\n         \"EXECIO 100 DISKR INFILE(STEM RECS.\"\n         RETCODE = RC\n      END\n\n      DO II = 1 TO RECS.0\n         IF LENGTH(RECS.II) > LONGEST_SIZE\n            THEN LONGEST_SIZE = LENGTH(RECS.II)\n         IF LENGTH(RECS.II) < SHORTEST_SIZE\n            THEN SHORTEST_SIZE = LENGTH(RECS.II)\n      END\n\n      \"EXECIO 0 DISKR\" INFILE \"(FINIS\"\n      SAY ZINPDSN \"- LONGEST/SHORTEST IS\" LONGEST_SIZE\"/\"SHORTEST_SIZE\n      \"FREE  F(INFILE)\"\n      IF RETCODE = 2 THEN EXIT(0)\n                     ELSE EXIT(RETCODE)\n   END\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"HOWLONG - DISPLAY MAX AND MIN RECORD LENGTHS UNDER DS LIST\"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    HOWLONG                                                  \"\n   SAY\n   SAY \"       WILL CAUSE A MESSAGE TO BE WRITTEN AS:                \"\n   SAY\n   SAY \"          '-THE-DATASET-NAME-' - LONGEST/SHORTEST IS 860/204 \"\n   SAY\n   SAY \"       THE LENGTHS DO NOT INCLUDE THE 4 BYTE LENGTH FIELD    \"\n   SAY \"       NOR THE 4 BYTE BLOCK LENGTH FIELD FOR VARIABLE        \"\n   SAY \"       FILES.  SUBSEQUENT FILES MAY BE INDICATED USING       \"\n   SAY \"       THE EQUAL SIGN AS IN NORMAL DS LIST USAGE. NOTE THAT  \"\n   SAY \"       THE ACTUAL RECORD LENGTH IS OFTEN FAR LARGER THEN     \"\n   SAY \"       THE LONGEST RECORD ON THE FILE.                       \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HSMDOC": {"ttr": 24598, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\r\\x00\\r\\x00\\x00\\xc4\\xd6\\xc3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "DOC"}, "text": "\n                       DFHSM  COMMANDS\n\n  HBACKDS  -  CREATE A BACKUP VERSION FOR A SPECIFIC DATASET\n  HBDELETE -  DELETE ONE OR MORE BACKUP VERSIONS OF A SPECIFIC DATASET\n  HCANCEL  -  CANCEL QUEUED DFHSM DATA MOVEMENT REQUEST\n  HDELETE  -  DELETE ONE OR MORE MIGRATED DATASETS\n  HLIST    -  LIST BACKUP AND MIGRATION INFORMATION\n  HMIGRATE -  MIGRATE ONE OR MORE DATASETS TO MIGRATE VOLUME\n  HQUERY   -  DISPLAY PENDING DFHSM REQUEST\n  HRECALL  -  RECALL ONE OR MORE MIGRATED DATASETS\n  HRECOVER -  RECOVER A DATASET FROM A BACKUP VERSION\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "H2C": {"ttr": 24833, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xdc\\x00\\xdc\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 220, "newlines": 220, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- CONVERT CHARACTERS TO HEXIDECIMAL DISPLAY  **/\n   NUMERIC DIGITS 30\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'H2C MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (FRMLEFT,FRMRIGHT,PARMS)\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY H2C 'EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT',\n         'WITH NO PENDING EDIT COMMANDS!'\n      SIGNAL EOJ\n   END\n   ADDRESS ISREDIT \"CAPS OFF\"\n\n   ERRORMSG = ''\n   MESG = ''\n   IF FRMLEFT = '' THEN DO\n     SIGNAL ERROR\n   END\n   IF FRMLEFT = ''  |  FRMRIGHT = ''  THEN DO\n      MESG = 'PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMLEFT,'W')  |  FRMLEFT = 0  THEN DO\n      MESG = \"'\"FRMLEFT\"' VALUE OF FROM-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMRIGHT,'W')  |  FRMRIGHT = 0  THEN DO\n      MESG = \"'\"FRMRIGHT\"' VALUE OF FROM-RIGHT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF FRMLEFT > FRMRIGHT THEN DO\n      MESG = \"FROM-LEFT-COL \"FRMLEFT\" IS > THAN FROM-RIGHT-COL \"FRMRIGHT\n      SIGNAL ERROR\n   END\n\n   PARMS   = TRANSLATE(PARMS)\n   LBL1    = \"\"\n   LBL2    = \"\"\n   TOLEFT  = \"\"\n   TORIGHT = \"\"\n   DO II = 1 TO 5;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n      END\n      ELSE IF SUBSTR(TOKEN,1,1) = \"-\" THEN DO\n         MINUS = SUBSTR(TOKEN,2)\n      END\n      ELSE DO\n         IF DATATYPE(TOKEN,'W')  THEN DO\n            IF TOLEFT = \"\" THEN TOLEFT = TOKEN\n            ELSE IF TORIGHT = \"\" THEN TORIGHT = TOKEN\n               ELSE DO\n                  ZEDSMSG = \".LABEL RC=8\"\n                  ZEDLMSG = \"TOO MANY COLUMNS --\" TOLEFT TORIGHT TOKEN\n                  ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n                  EXIT 8\n               END\n         END\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n   IF TOLEFT <> \"\" AND TORIGHT = \"\" THEN TORIGHT = TOLEFT\n   IF TOLEFT = \"\" THEN DO\n      TOLEFT  = FRMLEFT\n      TORIGHT = FRMRIGHT\n   END\n\n   IF \u00acDATATYPE(TOLEFT,'W')  |  TOLEFT=0  THEN DO\n      MESG = \"'\"TOLEFT\"' VALUE OF TO-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(TORIGHT,'W')  |  TORIGHT=0  THEN DO\n      MESG = \"'\"TORIGHT\"' VALUE OF TO-RIGHT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   LEN = FRMRIGHT - FRMLEFT + 1\n   IF TOLEFT > TORIGHT THEN DO\n      MESG = \"TO-LEFT-COL \"TOLEFT\" IS GREATER THAN TO-RIGHT-COL \"TORIGHT\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF TORIGHT > LRECL THEN DO\n      MESG = \"TO-RIGHT COLUMN IS GREATER THAN RECORD SIZE (\"LRECL\")\"\n      SIGNAL ERROR\n   END\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR \"\n   \"ISREDIT (\"ANUM\") = AUTONUM \"\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n\n   START = 1\n   IF LBL1 <> '' THEN\n       \"ISREDIT (START) = LINENUM &LBL1\"\n\n   IF LBL2 <> '' THEN\n        \"ISREDIT (END) = LINENUM &LBL2\"\n   ELSE\n        LBL2 = LBL1\n\n   IF START > END THEN DO\n      WST = START\n      START = END\n      END = WST\n   END\n\n   TOT  = 0\n   OVFL = 0\n   NG   = 0\n   FLEN = FRMRIGHT - FRMLEFT + 1\n   TLEN = TORIGHT  - TOLEFT  + 1\n\n   DO PNTR =  START  TO  END  BY 1\n      TOT = TOT + 1\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      OSTR = C2X(SUBSTR(RECORD,FRMLEFT,FLEN))\n      IF LENGTH(OSTR) > TLEN THEN DO\n         IF VERIFY(SUBSTR(OSTR,1,LENGTH(OSTR)-TLEN),'0') = 0 THEN DO\n            RECORD = SUBSTR(RECORD,1,TOLEFT-1),\n                     || SUBSTR(C2X(SUBSTR(RECORD,FRMLEFT,FLEN)),\n                        ,LENGTH(OSTR)-TLEN+1),\n                     || SUBSTR(RECORD,TORIGHT+1)\n            \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n         END\n         ELSE OVFL = OVFL + 1\n      END\n      ELSE DO\n         RECORD = SUBSTR(RECORD,1,TOLEFT-1),\n                  || COPIES('0',TLEN-LENGTH(OSTR)),\n                  || C2X(SUBSTR(RECORD,FRMLEFT,FLEN)),\n                  || SUBSTR(RECORD,TORIGHT+1)\n         \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n      END\n   END\n\n   STR = TOT '/' OVFL\n   CALL SETMSG '* NO ' STR 'H2C $TOTAL IN RANGE/OVERFLOWS'\n   \"ISREDIT LOCATE\" START\n   \"ISREDIT AUTONUM =\" ANUM\n    SIGNAL EOJ\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   CALL DISPDOC\n\nEOJ:\n   SAY \"PLEASE NOTE, CAPS IS NOW OFF...\"\n   X = MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"H2C - CHARACTER TO HEXIDECIMAL DISPLAY BY COLUMNS         \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    H2C     FROM-COL1 FROM-COL2 (TO-COL1 TO-COL2)         \"\n   SAY \"                            (.A .B)                       \"\n   SAY\n   SAY \"       FROM-COLUMNS ARE REQUIRED. TO-COLUMNS WILL DEFAULT \"\n   SAY \"       TO FROM-COLUMNS.  LABEL RANGE IS OPTIONAL.         \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY \"    H2C        1 3  11 16  .A .B                          \"\n   SAY \"       WILL CONVERT THE CHARACTERS IN COLUMNS 1 TO 3 INTO \"\n   SAY \"       ITS HEX EQUIVALENT, I.E. X'012AC3' BECOMES '012AC3'\"\n   SAY \"       INTO COLUMNS 11 THRU 16 IN RANGE .A TO .B. LONG    \"\n   SAY \"       DESTINATION FIELDS ARE LEFT PADDED WITH 0'S WHILE  \"\n   SAY \"       SHORT DESTINATION FIELDS ARE CHECKED TO SEE THAT   \"\n   SAY \"       NON 0 CHARACTERS ARE NOT LOST.                     \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IE": {"ttr": 24838, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x004\\x004\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "REXX"}, "text": "/** REXX - INSERT EVALUATE STRUCTURE **/\n\n   SAVEMSG = MSG()\n   X = MSG(\"OFF\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY \"IE MUST BE RUN UNDER ISPF EDIT!\"\n      SIGNAL QUIT\n      END\n   SUBCOM ISREDIT\n   UMODE = \"ISREDIT\"\n   ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n   ADDRESS ISREDIT\n   \"MACRO (INDENT) NOPROCESS\"\n\n   IF INDENT = \"\" THEN INDENT = 4\n   ADDRESS ISREDIT\n   \"(LINE,COL) = CURSOR\"\n   \"(REC) = LINE\" LINE\n   DO II = 8 TO 72 WHILE(SUBSTR(REC,II,1) = ' ')\n   END II\n   IF SUBSTR(REC,II,5) = 'ELSE ',\n         | SUBSTR(REC,II,3) = 'IF ',\n         | SUBSTR(REC,II,8) = 'PERFORM ',\n         | SUBSTR(REC,II,5) = 'WHEN ',\n      THEN OFFSET = II + INDENT - 1\n      ELSE OFFSET = II - 1\n   IF OFFSET < 11 | OFFSET > 58 THEN OFFSET = 11\n   INDENT2 = OFFSET + INDENT + INDENT\n   INDENT  = OFFSET + INDENT\n   REC = COPIES(' ',OFFSET)  || \"END-EVALUATE\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',INDENT2) || \"...\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',INDENT)  || \"WHEN OTHER\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',INDENT2) || \"...\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',INDENT)  || \"WHEN ...\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',INDENT2) || \"...\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',INDENT)  || \"WHEN ...\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',OFFSET)  || \"EVALUATE ...\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   \"LOCATE\" LINE\n   LINE_X  = LINE + 1\n   COL_X   = INDENT2 + 2\n   \"CURSOR =\" LINE_X COL_X\n   RETURN(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IEZBITS": {"ttr": 24840, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x12\\x00\\x12\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         IEZBITS\n         GBLA  &IEZBITS\n         AIF   (&IEZBITS EQ 0).SETSW\n         MEXIT\n.SETSW   ANOP\n&IEZBITS SETA  1\n         SPACE 2\nBIT0     EQU   128\nBIT1     EQU   64\nBIT2     EQU   32\nBIT3     EQU   16\nBIT4     EQU   8\nBIT5     EQU   4\nBIT6     EQU   2\nBIT7     EQU   1\n         SPACE 2\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "II": {"ttr": 24842, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00.\\x00.\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "REXX"}, "text": "/** REXX - INSERT IF/ELSE STRUCTURE **/\n\n   SAVEMSG = MSG()\n   X = MSG(\"OFF\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY \"IE MUST BE RUN UNDER ISPF EDIT!\"\n      SIGNAL QUIT\n      END\n   SUBCOM ISREDIT\n   UMODE = \"ISREDIT\"\n   ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n   ADDRESS ISREDIT\n   \"MACRO (INDENT) NOPROCESS\"\n\n   IF INDENT = \"\" THEN INDENT = 4\n   ADDRESS ISREDIT\n   \"(LINE,COL) = CURSOR\"\n   \"(REC) = LINE\" LINE\n   DO II = 8 TO 72 WHILE(SUBSTR(REC,II,1) = ' ')\n   END II\n   IF SUBSTR(REC,II,5) = 'ELSE ',\n         | SUBSTR(REC,II,3) = 'IF ',\n         | SUBSTR(REC,II,8) = 'PERFORM ',\n         | SUBSTR(REC,II,5) = 'WHEN ',\n      THEN OFFSET = II + INDENT - 1\n      ELSE OFFSET = II - 1\n   IF OFFSET < 11 | OFFSET > 58 THEN OFFSET = 11\n   INDENT2 = OFFSET + INDENT + INDENT\n   INDENT = OFFSET + INDENT\n   REC = COPIES(' ',OFFSET)    || \"END-IF\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',INDENT)    || \"...\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',OFFSET)    || \"ELSE\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',INDENT)    || \"...\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',OFFSET)    || \"IF\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   \"LOCATE\" LINE\n   LINE_X  = LINE + 2\n   COL_X   = INDENT2 - 3\n   \"CURSOR =\" LINE_X COL_X\n   RETURN(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IP": {"ttr": 24844, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00-\\x00-\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "REXX"}, "text": "/** REXX - INSERT PERFORM STRUCTURE **/\n\n   SAVEMSG = MSG()\n   X = MSG(\"OFF\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY \"IE MUST BE RUN UNDER ISPF EDIT!\"\n      SIGNAL QUIT\n      END\n   SUBCOM ISREDIT\n   UMODE = \"ISREDIT\"\n   ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n   ADDRESS ISREDIT\n   \"MACRO (INDENT) NOPROCESS\"\n\n   IF INDENT = \"\" THEN INDENT = 4\n   ADDRESS ISREDIT\n   \"(LINE,COL) = CURSOR\"\n   \"(REC) = LINE\" LINE\n   DO II = 8 TO 72 WHILE(SUBSTR(REC,II,1) = ' ')\n   END II\n   IF SUBSTR(REC,II,5) = 'ELSE ',\n         | SUBSTR(REC,II,3) = 'IF ',\n         | SUBSTR(REC,II,8) = 'PERFORM ',\n         | SUBSTR(REC,II,5) = 'WHEN ',\n      THEN OFFSET = II + INDENT - 1\n      ELSE OFFSET = II - 1\n   IF OFFSET < 11 | OFFSET > 58 THEN OFFSET = 11\n   REC = COPIES(' ',OFFSET)          || \"END-PERFORM\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',OFFSET+INDENT)   || \"...\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',OFFSET+INDENT*2) || \"UNTIL ...\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',OFFSET+INDENT)   || \"VARYING ...\",\n      || \" FROM  1 BY  1\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',OFFSET)          || \"PERFORM\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   \"LOCATE\" LINE\n   LINE_X  = LINE + 2\n   COL_X   = INDENT * 2 + 16\n   \"CURSOR =\" LINE_X COL_X\n   RETURN(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IPADDR": {"ttr": 24846, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00 \\x00 \\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "REXX"}, "text": "/* REXX */\nCLEAR\nSYSENV   = SYSVAR('SYSENV')\nVERS      = SOCKET('VERSION')\nINIT      = SOCKET('INITIALISE','TCPINFO')\n/* SAVE INIT RESULTS */\nPARSE VAR INIT INIT_RC SUBTASKID MAXDESC SERVICE\n\nHOSTID    = SOCKET('GETHOSTID')\nHOSTNAME  = SOCKET('GETHOSTNAME')\nDOMAIN    = SOCKET('GETDOMAINNAME')\nTERM      = SOCKET('TERMINATE')\n/* PARSE  ======>  ==========> ======>  */\nPARSE VAR HOSTID   RETURN_CODE TCPADDR\nPARSE VAR HOSTNAME RETURN_CODE TCPNAME\nPARSE VAR DOMAIN   RETURN_CODE TCPDOMAIN\n\nFULLNAME = TCPNAME'.'TCPDOMAIN\nSAY SYSENV\n\n/* IF SYSENV = 'FORE' THEN 'CS'*/\n\nSAY 'HOST ADDR   =' TCPADDR\nSAY 'HOST NAME   =' TCPNAME\nSAY 'DOMAIN      =' TCPDOMAIN\nSAY 'FULL NAME   =' FULLNAME\n\nIF SYSENV = 'BACK' THEN DO\n  SAY 'RETURN CODE =' INIT_RC\nEND\n\nEXIT INIT_RC\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IS": {"ttr": 24848, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x002\\x002\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "REXX"}, "text": "/** REXX - INSERT SEARCH STRUCTURE **/\n\n   SAVEMSG = MSG()\n   X = MSG(\"OFF\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY \"IE MUST BE RUN UNDER ISPF EDIT!\"\n      SIGNAL QUIT\n      END\n   SUBCOM ISREDIT\n   UMODE = \"ISREDIT\"\n   ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n   ADDRESS ISREDIT\n   \"MACRO (INDENT) NOPROCESS\"\n\n   IF INDENT = \"\" THEN INDENT = 4\n   ADDRESS ISREDIT\n   \"(LINE,COL) = CURSOR\"\n   \"(REC) = LINE\" LINE\n   DO II = 8 TO 72 WHILE(SUBSTR(REC,II,1) = ' ')\n   END II\n   IF SUBSTR(REC,II,5) = 'ELSE ',\n         | SUBSTR(REC,II,3) = 'IF ',\n         | SUBSTR(REC,II,8) = 'PERFORM ',\n         | SUBSTR(REC,II,5) = 'WHEN ',\n      THEN OFFSET = II + INDENT - 1\n      ELSE OFFSET = II - 1\n   IF OFFSET < 11 | OFFSET > 58 THEN OFFSET = 11\n   INDENT2 = OFFSET + INDENT + INDENT\n   INDENT  = OFFSET + INDENT\n   REC = COPIES(' ',OFFSET)     || \"END-SEARCH\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',INDENT2)    || \"...\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',INDENT)     || \"WHEN ...\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',INDENT2)    || \"...\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',INDENT)     || \"AT END\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',OFFSET)     || \"SEARCH ...\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',OFFSET)     || \"SET ... TO 1\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   \"LOCATE\" LINE\n   LINE_X  = LINE + 1\n   COL_X   = INDENT2 - 3\n   \"CURSOR =\" LINE_X COL_X\n   RETURN(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISA": {"ttr": 24850, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x000\\x000\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "REXX"}, "text": "/** REXX - INSERT SEARCH ALL STRUCTURE **/\n\n   SAVEMSG = MSG()\n   X = MSG(\"OFF\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY \"IE MUST BE RUN UNDER ISPF EDIT!\"\n      SIGNAL QUIT\n      END\n   SUBCOM ISREDIT\n   UMODE = \"ISREDIT\"\n   ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n   ADDRESS ISREDIT\n   \"MACRO (INDENT) NOPROCESS\"\n\n   IF INDENT = \"\" THEN INDENT = 4\n   ADDRESS ISREDIT\n   \"(LINE,COL) = CURSOR\"\n   \"(REC) = LINE\" LINE\n   DO II = 8 TO 72 WHILE(SUBSTR(REC,II,1) = ' ')\n   END II\n   IF SUBSTR(REC,II,5) = 'ELSE ',\n         | SUBSTR(REC,II,3) = 'IF ',\n         | SUBSTR(REC,II,8) = 'PERFORM ',\n         | SUBSTR(REC,II,5) = 'WHEN ',\n      THEN OFFSET = II + INDENT - 1\n      ELSE OFFSET = II - 1\n   IF OFFSET < 11 | OFFSET > 58 THEN OFFSET = 11\n   INDENT2 = OFFSET + INDENT + INDENT\n   INDENT  = OFFSET + INDENT\n   REC = COPIES(' ',OFFSET)    || \"END-SEARCH\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',INDENT2)   || \"...\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',INDENT)    || \"WHEN ...\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',INDENT2)   || \"...\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',INDENT)    || \"AT END\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',OFFSET)    || \"SEARCH ALL ...\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   \"LOCATE\" LINE\n   LINE_X  = LINE + 1\n   COL_X   = INDENT2 + 4\n   \"CURSOR =\" LINE_X COL_X\n   RETURN(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISORT": {"ttr": 25089, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00C\\x00C\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 67, "newlines": 67, "modlines": 0, "user": "REXX"}, "text": "/** REXX - INSERT SORT STEP JCL **/\n\n   SAVEMSG = MSG()\n   X = MSG(\"OFF\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY \"IE MUST BE RUN UNDER ISPF EDIT!\"\n      SIGNAL QUIT\n      END\n   SUBCOM ISREDIT\n   UMODE = \"ISREDIT\"\n   ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n   ADDRESS ISREDIT\n   \"MACRO (PARM) NOPROCESS\"\n\n   ADDRESS ISREDIT\n   \"(LINE,COL) = CURSOR\"\n   REC = \"//***\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = \"//SORTWK06     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = \"//SORTWK05     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = \"//SORTWK04     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = \"//SORTWK03     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = \"//SORTWK02     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = \"//SORTWK01     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = \"//SYSOUT       DD       SYSOUT=*\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = \"//SORTLIST     DD       SYSOUT=*\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = \"//SYSPRINT     DD       SYSOUT=*\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = \"   SUM     FIELDS=NONE\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = \"                    ....,....,CH,EQ,C'...')\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = \"     INCLUDE  COND=(....,....,CH,EQ,C'...',OR,\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = \"   SORT    FIELDS=(0001,0001,CH,A)\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = \"//SYSIN        DD       *\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = \"//             DCB=(...)\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = \"//             DSN=...,\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = \"//             SPACE=(CYL,(0010,0010),RLSE),\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = \"//SORTOUT      DD       DISP=(,CATLG),UNIT=SYSDA,\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = \"//SORTIN       DD       DISP=SHR,DSN=...\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = \"//SORT       EXEC     PGM=SORT,REGION=256M\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = \"//***\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   \"LOCATE\" LINE\n   LINE_X  = LINE + 3\n   COL_X   = 38\n   \"CURSOR =\" LINE_X COL_X\n   RETURN(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IST": {"ttr": 25091, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x002\\x002\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "REXX"}, "text": "/** REXX - INSERT STRING STRUCTURE **/\n\n   SAVEMSG = MSG()\n   X = MSG(\"OFF\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY \"IE MUST BE RUN UNDER ISPF EDIT!\"\n      SIGNAL QUIT\n      END\n   SUBCOM ISREDIT\n   UMODE = \"ISREDIT\"\n   ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n   ADDRESS ISREDIT\n   \"MACRO (INDENT) NOPROCESS\"\n\n   IF INDENT = \"\" THEN INDENT = 4\n   ADDRESS ISREDIT\n   \"(LINE,COL) = CURSOR\"\n   \"(REC) = LINE\" LINE\n   DO II = 8 TO 72 WHILE(SUBSTR(REC,II,1) = ' ')\n   END II\n   IF SUBSTR(REC,II,5) = 'ELSE ',\n         | SUBSTR(REC,II,3) = 'IF ',\n         | SUBSTR(REC,II,8) = 'PERFORM ',\n         | SUBSTR(REC,II,5) = 'WHEN ',\n      THEN OFFSET = II + INDENT - 1\n      ELSE OFFSET = II - 1\n   IF OFFSET < 11 | OFFSET > 58 THEN OFFSET = 11\n   INDENT2 = OFFSET + INDENT + INDENT\n   INDENT  = OFFSET + INDENT\n   REC = COPIES(' ',OFFSET)    || \"END-STRING\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',INDENT)    || \"INTO ...\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',INDENT2)   || \"DELIMITED BY SIZE\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',INDENT)    || \"...\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',INDENT)    || \"...\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',INDENT)    || \"...\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   REC = COPIES(' ',OFFSET)    || \"STRING\"\n   \"LINE_AFTER (LINE) = (REC)\"\n   \"LOCATE\" LINE\n   LINE_X  = LINE + 2\n   COL_X   = INDENT2 - 3\n   \"CURSOR =\" LINE_X COL_X\n   RETURN(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JB": {"ttr": 25093, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00e\\x00e\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 101, "newlines": 101, "modlines": 0, "user": "REXX"}, "text": "/** REXX - Jump-Back to Perform Statement (from JT macro) **/\nParse Source opsys . cmdname .\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\nAddress ISREDIT\n'MACRO (PARM) NOPROCESS'\n'(MEMBER) = MEMBER'\nalpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nCall ISPFVGET\nif jbnum = '' | jbnum = 0  then jbnum = 1\n\nif parm = '?' then call DispDoc\n\nsuff = SUBSTR(alpha,jbnum,1)\njb = '.JB' || suff\n'(LINENO) = LINENUM' jb\nlrc =rc\nIf lrc=0 Then Do\n  'LOCATE' jb\n  jbnum = jbnum - 1\n  'RESET FIND'\n  Call ISPFVPUT\nend\nif parm <> '' then do\n  if ABBREV('ERASE',parm,1) then do\n    Call ISPFVERASE\n    Call RESET\n  end\n  if ABBREV('RESET',parm,1) then do\n    jbnum = 1\n    Call RESET\n  end\nend\nif parm = '' &  lrc  = 0 then 'RESET LABEL' jb jb\nExit\n/**********************************************************************/\n/* Reset .JBx ALL labels                                              */\n/**********************************************************************/\nRESET: Procedure Expose alpha\n do i=1 to LENGTH(alpha)\n   suff = SUBSTR(alpha,i,1)\n   jb   = '.JB' || suff\n   '(LINENO) = LINENUM' jb\n   if rc=0 then 'RESET LABEL' jb jb\n end i\nReturn\n/**********************************************************************/\n/* Get the highest jb number for this edit member                     */\n/**********************************************************************/\nISPFVGET: Procedure Expose JBNUM member\n  Address ISPEXEC\n  'VGET (FINCL) SHARED'\n  If rc> 8 Then Say 'ISPFVGET: error rc='  rc\n  where = POS(member,fincl)\n  if where>0 Then\n  do\n    jbnum = SUBSTR(fincl,(where+LENGTH(member)+1),2)\n    jbnum = STRIP(jbnum)\n  end\n  else jbnum = 0\nReturn\n/*----------------------------------------------------------------------\n! Save information in SHARED profile for this member                   !\n----------------------------------------------------------------------*/\nISPFVPUT: Procedure Expose JBNUM member\n  Address ISPEXEC\n  'VGET (FINCL) SHARED'\n  where = POS(member,fincl)\n  if where>0 Then\n  do\n    fincl = OVERLAY(jbnum,fincl,(where+LENGTH(member)+1),2)\n  end\n  else\n  do\n    fincl = fincl member || '_' || STRIP(jbnum)\n    fincl = SPACE(fincl,1)\n  end\n  'VPUT (FINCL) SHARED'\n  If rc> 8 Then Say 'ISPFVPUT: error rc='  rc\nReturn\n/**********************************************************************/\n/* Delete the SHARED profile information for this edit member         */\n/**********************************************************************/\nISPFVERASE: Procedure Expose JBNUM member\n  Address ISPEXEC\n  'VERASE (FINCL) SHARED'\n  If rc> 8 Then Say 'ISPFVERASE: error rc='  rc\nReturn\n\nDispDoc:\n   ADDRESS TSO \"CLEAR\"\n   SAY \" JB - Jump Back to Perform Statement set by JT         \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    JB    ( ? )                                        \"\n   SAY\n   SAY \"       positions display with Perform statement set by \"\n   SAY \"       JT macro.                                       \"\n   SAY\n   Return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JC": {"ttr": 25096, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00.\\x00.\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- JC -- CREATE A JOB CARD AT THE TOP OF THE FILE EDITED  **/\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'JC EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      EXIT(12)\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      ADDRESS ISREDIT \"ISREDIT MACRO (PARMS) NOPROCESS\"\n      PARMS = TRANSLATE(PARMS)\n      IF PARMS = \"?\" THEN SIGNAL DISPDOC\n   END\n   ELSE DO\n      SAY 'JC EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      EXIT(12)\n   END\n\n   ADDRESS ISREDIT\n   CARD3 = \"//***\"\n   CARD2 = \"//             CLASS=2,MSGCLASS=X,NOTIFY=\"USERID()\n   CARD1 = \"//\"USERID()\"   JOB      (ACCT-INFO),'\"USERID()\"',\"\n   LINE  = 0\n   \"LINE_AFTER (LINE) = (CARD3)\"\n   \"LINE_AFTER (LINE) = (CARD2)\"\n   \"LINE_AFTER (LINE) = (CARD1)\"\n   COL_X = 3 + LENGTH(USERID())\n   \"CURSOR =\"  1  COL_X\n   EXIT(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"JC  -  INSERT JOB CARD AT TOP OF EDITED FILE              \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    JC  ( ? )                                             \"\n   SAY\n   SAY \"       INSERT A JOB CARD AT THE TOP OF THE FILE BEING     \"\n   SAY \"       EDITED, USING THE TSO USER-ID AS THE PREFIX OF     \"\n   SAY \"       THE JOBNAME, THE NOTIFIED PARTY, AND THE USER     \"\n   SAY \"       NAME WITHIN THE NAME FIELD.                       \"\n   SAY\n   SAY \"       A QUESTION MARK ALONE CAUSES THIS HELP TO DISPLAY. \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JOBINFO": {"ttr": 25098, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x81\\x00\\x81\\x00\\x00\\xd1\\xd6\\xc2\\xc9\\xd5\\xc6\\xd6@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "JOBINFO"}, "text": "//-YOUR-USERID-J JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  COBOL JOB INFORMATION RETRIEVAL\n//***\n//C          EXEC     PGM=IGYCRCTL,REGION=4M,\n//             PARM=('LIB,MAP,NUMPROC(PFD),OFF,OPTIMIZE',\n//            'APOST,NOSEQ,TRUNC(OPT),XREF')\n//SYSIN        DD       *\n       Identification Division.\n         Program-ID. JobInfo.\n      *----------------------------------------------------------------*\n      *                                                                *\n      *    This program retrieves specific job-related data from MVS   *\n      *    control blocks and moves it to Working-storage.             *\n      *                                                                *\n      *    The name of the control-block is indicated in pos 1-6 of    *\n      *    the Procedure Division lines.                               *\n      *    The layout of the MVS control blocks is described in the    *\n      *    MVS Data Areas manuals, which can be found on any MVS or    *\n      *    OS/390 CD collection or viewed on-line by going to:         *\n      *        http://www.s390.ibm.com/bookmgr-cgi/bookmgr.cmd/library *\n      *    and searching for:                                          *\n      *        MVS DATA AREAS                                          *\n      *----------------------------------------------------------------*\n       Data Division.\n        Working-Storage Section.\n         01 Results.\n           05 job-name Pic x(8).\n           05 proc-step Pic x(8).\n           05 step-name Pic x(8).\n           05 program-name Pic x(8).\n           05 program-name2 Pic x(8).\n           05 job-number Pic x(8).\n           05 job-class Pic x.\n           05 msg-class Pic x.\n           05 programmer-name Pic x(20).\n           05 user-id Pic x(8).\n           05 group-name Pic x(8).\n           05 user-name Pic x(20).\n           05 batch-or-cics Pic x(5).\n              88 Batch Value 'BATCH'.\n              88 CICS  Value 'CICS '.\n           05 micro-seconds Pic S9(15) COMP-3.\n         01 four-bytes.\n           05 full-word Pic s9(8) Comp.\n           05 ptr4      Redefines full-word Pointer.\n        Linkage Section.\n         01 cb1.  05 ptr1 Pointer Occurs 256.\n         01 cb2.  05 ptr2 Pointer Occurs 256.\n       Procedure Division.\n PSA       SET Address of cb1 to NULL\n TCB       SET Address of cb1 to ptr1(136)\n           SET ptr4 to ptr1(83)\n           COMPUTE micro-seconds = full-word * 1048576\n           SET ptr4 to ptr1(84)\n           COMPUTE micro-seconds = micro-seconds + (full-word / 1024)\n TIOT      SET Address of cb2 to ptr1(4)\n           MOVE cb2(1:8) to job-name\n           MOVE cb2(9:8) to proc-step\n           MOVE cb2(17:8) to step-name\n JSCB      SET Address of cb2 to ptr1(46)\n           MOVE cb2(361:8) to program-name\n SSIB      SET Address of cb2 to ptr2(80)\n           MOVE cb2(13:8) to job-number\n PRB       SET Address of cb2 to ptr1(1)\n           MOVE cb2(97:8) to program-name2\n JSCB      SET Address of cb2 to ptr1(46)\n JCT       SET Address of cb2 to ptr2(66)\n           MOVE cb2(48:1) to job-class\n           MOVE cb2(23:1) to msg-class\n ACT       MOVE zero to full-word\n           MOVE cb2(57:3) to four-bytes(2:3)\n           SET Address of cb2 to ptr4\n           MOVE cb2(25:20) to programmer-name\n EXT2      SET Address of cb2 to ptr1(53)\n CAUF      IF cb2(21:4) = low-values THEN\n             SET Batch to TRUE\n           ELSE\n             SET CICS to TRUE\n           END-IF\n PSA       SET Address of cb1 to NULL\n ASCB      SET Address of cb1 to ptr1(138)\n ASXB      SET Address of cb2 to ptr1(28)\n           MOVE cb2(193:8) to user-id\n ACEE      SET Address of cb2 to ptr2(51)\n           MOVE cb2(31:8) to group-name\n UNAM      SET Address of cb1 to ptr2(26)\n           MOVE zero to full-word\n           MOVE cb1(1:1) to four-bytes(4:1)\n           MOVE cb1(2:full-word) to user-name\n           DISPLAY job-name ' '\n                   proc-step ' '\n                   step-name ' '\n                   program-name ' '\n                   program-name2 ' '\n                   job-number ' '\n                   job-class ' '\n                   msg-class ' '\n                   micro-seconds ' '\n           DISPLAY quote programmer-name  quote ' '\n                   batch-or-cics ' '\n                   user-id ' '\n                   group-name  ' '\n                   quote user-name  quote ' '\n           GOBACK.\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SYSLIB-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=SYSDA,SPACE=(TRK,(3,3)),\n//             DCB=(BLKSIZE=80,LRECL=80,RECFM=FB)\n//SYSUT1       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT2       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT3       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT4       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT5       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT6       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT7       DD       UNIT=SYSDA,SPACE=(CYL,(1,1))\n//***\n//GO         EXEC     PGM=LOADER,PARM='MAP,PRINT',\n//             REGION=4M,COND=(5,LT,C)\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//SYSLOUT      DD       SYSOUT=*\n//SYSPRINT     DD       SYSOUT=*\n//SYSABOUT     DD       SYSOUT=*\n//SYSUDUMP     DD       SYSOUT=*\n//SYSOUT       DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JOINCOLS": {"ttr": 25101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xa1\\x00\\xa1\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 161, "newlines": 161, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- JOIN LINES AT SELECTED COLUMNS  **/\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'JOINCOLS MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (PARMS)\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY JOINCOLS 'EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT'\n      SIGNAL EOJ\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n\n   PARMS   = TRANSLATE(PARMS)\n   LBL1    = \"\"\n   LBL2    = \"\"\n   SCOL.   = \"\"\n   SCNT    = 0\n   DO II = 1 TO 50;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n      END\n      ELSE DO\n         IF DATATYPE(TOKEN,'W')  THEN DO\n            SCNT = SCNT + 1\n            SCOL.SCNT = TOKEN\n         END\n         ELSE DO\n            ZEDSMSG = \"BAD PARM\"\n            ZEDLMSG = \"UNRECOGNIZED PARM --\" TOKEN\n            ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n            EXIT 8\n         END\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n\n   IF SCNT = 0 THEN DO\n      MESG = \"NO COLUMNS SPECIFIED!\"\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   DO II = 1 TO SCNT\n      IF SCOL.II > LRECL THEN DO\n      MESG = \"COLUMN\" SCOL.II \"IS GREATER THAN LRECL OF FILE!\"\n         SIGNAL ERROR\n      END\n   END\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n   START = 1\n   IF LBL1 <> '' THEN \"ISREDIT (START) = LINENUM &LBL1\"\n   IF LBL2 <> '' THEN \"ISREDIT (END)   = LINENUM &LBL2\"\n\n   IF START > END THEN DO\n      TEMP  = START\n      START = END\n      END   = TEMP\n   END\n\n   TOT  = 0\n   LAST = END\n   PNTR = START\n   DO WHILE PNTR <= LAST\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      NXTPNTR = PNTR + 1\n      DO II = 1 TO SCNT\n         TOT  = TOT + 1\n         LAST = LAST - 1\n         \"ISREDIT (NXTREC) = LINE &NXTPNTR\"\n         RECORD = SUBSTR(RECORD,1,SCOL.II-1) || NXTREC\n         \"ISREDIT DELETE &NXTPNTR\"\n      END\n      \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n      PNTR = PNTR + 1\n   END\n\n   STR = TOT 'LINES DELETED'\n   CALL SETMSG '* NO ' STR '$DELETED LINES'\n   \"ISREDIT LOCATE\" START\n   \"ISREDIT AUTONUM =\" ANUM\n    SIGNAL EOJ\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   CALL DISPDOC\n\nEOJ:\n   X = MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"JOINCOLS - JOIN LINES AT SPECIFIED COLUMNS            \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    JOINCOLS COL-1  ( COL-2 ... )  ( .A .B )          \"\n   SAY\n   SAY \"       AT LEAST ONE JOIN COLUMN IS REQUIRED. THE LABEL\"\n   SAY \"       RANGES ARE OPTIONAL AND MAY BE INTERMIXED.     \"\n   SAY\n   SAY \" EXAMPLES \"\n   SAY \"    JOINCOLS  11  21  31                             \"\n   SAY \"       WILL JOIN FOUR LINES INTO ONE AT COLUMNS 11,  \"\n   SAY \"       21 AND 31.                                    \"\n   SAY\n   SAY \"    JOINCOLS  18   .A .B                             \"\n   SAY \"       WILL JOIN LINES IN THE RANGE .A THRU .B AT    \"\n   SAY \"       COLUMN 18.                                    \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JT": {"ttr": 25345, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x03\\x1f\\x03\\x1f\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 799, "newlines": 799, "modlines": 0, "user": "REXX"}, "text": "/* REXX - if placed on a PERFORM stmt - jump to it and make a label   */\n/*        (.JBx) which can be jumped back to via the JB command;      */\n/*        if on a copy statement, it does a view on the copybook      */\n/**********************************************************************/\nparse Source opsys . cmdname .\nCall INIT\nAddress ISREDIT\n'MACRO (PARMS) NOPROCESS'\nupper parms\nIf parms = '?' then call DispDoc\n\n'(number1,number2) = number'\n'(V1,V2) = CURSOR'                       /* Where is the cursor?      */\ncall check_leading_numbers\n'CURSOR ='V1 V2\ncall get_current_line\n'(DS)    = DATASET'                      /* Which dataset             */\nParse Var ds hlq '.' lv2 '.' cob '.'     /* Check if this is COB pgm  */\ni_list='COBOL COPY'                      /* Include list              */\nif cob = 'COBOL' then\n  nop\nelse\n  i_list=cob||' COBOL COPY'              /* Include list              */\nqual_2='COPY PR2'                        /* 2nd qualifier list        */\ncall define_copy\ncall define_call\n/* Define possible first level qualifiers so that if we don't\n   find the file under (say) the user's hlq, we will still look\n   for it under the other defined HLQ's                         */\nqual_1 = strip(hlq,'B')\n/*\n If the first qualifier of the file being edited is NOT the userid,\n hen ONLY catenate SHB as other optional HLQ's. If the first IS the\n userid, then create qual_1 as the userid, the value in the 2nd\n qualifier as the 2nd one and finally SHB as the third one\n*/\nif qual_1 <> zuser then\n qual_1=strip(hlq) || lv2 ' SHB'         /* 1st qualifier list        */\nelse\n qual_1=strip(hlq) || ' SHB'             /* 1st qualifier list        */\n\ntline = TRANSLATE(line)                  /* Uppercase line            */\ntline = TRANSLATE(tline,'','().%')       /* Remove unwanted chars     */\nSelect                                   /* select action             */\n  When POS('CALL ',tline)>0 &,         /* CALL AND COPY on same line  */\n       POS('COPY ',tline)>0     then\n    call determine_which_call\n  When POS('PERFORM ',tline)>0  Then     /* Is it PERFORM stmt ?      */\n    Call perform_stmt\n  When POS('COPY ',tline)>0 &,           /* On a COPY line? and       */\n       WORDPOS(cob,i_list)  >0  then     /* member of COB2 library?   */\n    Call COPY_INCLUDE 'COPY '            /* Handle the COPY    member */\n  When POS('INCLUDE ',tline)>0 &,        /* On an include line? and   */\n       WORDPOS(cob,i_list)  >0  then     /* member of COPY library?   */\n    Call COPY_INCLUDE 'INCLUDE '         /* Handle the INCLUDE member */\n  When POS('CALL ',tline)>0  Then        /* Is it CALL stmt?          */\n    Call call_stmt\n  Otherwise                              /* Nop stmt                  */\n    Call invalid_call\nEnd\nIf keepcsr = 1 Then\n do\n  Address ISREDIT\n  'CURSOR =' v1 v2     /* Return the CURSOR         */\n end\n\nExit xrc\n/*----------------------------------------------------------------------\n! Check which version of ISPF/PDF we're on                             !\n----------------------------------------------------------------------*/\nINIT:\n  keepcsr = 1                           /* Keep cursor in file        */\n  xrc     = 0                           /* Don't place cursor on cmd  */\n  Address ISPEXEC\n  'VGET (ZENVIR) ASIS'\n  vers = SUBSTR(zenvir,1,8)\n  Parse Var vers . ver .\n  If ver> 4.0 Then\n   view = 'VIEW'\n  Else\n   view = 'EDIT'\n  'VGET (ZUSER)'\nReturn\n/*----------------------------------------------------------------------\n! Handle EXTERNAL entry. eg VIEW the source code of the DCL EXT.       !\n----------------------------------------------------------------------*/\nEXTERNAL:\n  If POS('DCL ',tline) > 0 Then          /* How do we parse DCL?      */\n    Parse Var tline 'DCL ' member .      /* Take member name          */\n  Else                                   /*                           */\n    Parse Var tline 'DECLARE ' member .  /* Take member name          */\n                                         /*                           */\n  If LENGTH(member)>7 Then               /* Too long for external     */\n  Do\n    zedsmsg = 'PROC name too long'\n    zedlmsg = \"Could not find '\"member\"' anywhere and it's\",\n              \"too long to be an external program.\"\n    Call ISPFMSG\n    member    = ''\n  End\n  If member<>'' Then Do                  /* If not blank              */\n    If view <> 'BROWSE' Then do          /* Use \"VIEW\" if not BROWSE  */\n      view member\n      Call ISPFREMOVE\n    End                                  /*                           */\n    Else Do                              /* If \"BROWSE\" we have to do */\n      Address ISPEXEC                    /* we must do it in the old  */\n      'CONTROL ERRORS RETURN'            /* way.                      */\n      ds    = ds'('member')'             /*                           */\n   /**view \"DATASET('\"ds\"')\"**/\n      Address ISPEXEC \"SELECT PGM(ISPSTRT)\",\n         \"PARM(CMD(ISREPDF '\"tempds\"' V))\"\n      Call ISPFREMOVE\n    End                                  /*                           */\n  End                                    /*                           */\nReturn\n/*----------------------------------------------------------------------\n! Handle PERFORM stmts. Also add a \"JUMP-BACK\" label .JB               !\n----------------------------------------------------------------------*/\nperform_stmt:\n  alpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'   /* Used to create the label  */\n  keepcsr = 0                            /* don't keep cursor pos     */\n  Call ISPFVGET\n  if jbnum = '' then jbnum = 0\n  jbnum = jbnum + 1\n  suff = substr(alpha,jbnum,1)\n\n  'LABEL .ZCSR = .JB' || suff '0'        /* make jump-back label      */\n  If POS('PERFORM ',tline)>0 Then Do\n    Parse Var tline 'PERFORM ' tproc .  /* Take proc name            */\n    proc = STRIP(TRANSLATE(tproc,' ','.;)('),'B')\n    /* If we added the blanks specifically, we would miss calls\n       to a perform where the \"section\" was in fact nothing other than\n       a label (in which case it would have a full stop after the\n       name)                                                    */\n    stop = LENGTH(proc) + 16             /* 16 is for the fact that we*/\n                                         /* START in pos 8 AND we add */\n                                         /* 8 chars for the word      */\n                                         /* ' section'                */\n  End\n  Else\n   Do\n    temp = STRIP(TRANSLATE(tline,' ',';)('),'B')\n    Parse Var temp tproc .\n    stop = LENGTH(tproc) + 4\n   End\n\n /* This new code allows the word SECTION to be anywhere on the line\n    and separated by any number of blanks after the actual name of\n    the section being searched for                                */\n  'CURSOR = 1'\n  FIND ''''proc'''' next\n  /* Loop round as long as we still find the occurrence of the\n     procedure string we're looking for */\n  do while rc <> 4\n   call get_current_line\n   '(LNR) = LINENUM .zcsr'\n   upper line\n\n   /* Must have proc with parens so that REXX knows it's a variable\n      we're looking for (otherwise, it could easily parse proc as\n      containing a trailing full stop)                         */\n   parse var line leader (proc) rest trailing_nums\n   /* Does the line contain the word SECTION.  OR is the first\n      character on the line AFTER the procedure name a full stop */\n   /* If the value in words(leader) is NOT 1, then this means\n      we've found a section where the perform statement contains\n      part of the string in the current section. For example,\n      we called FINCL on a line containing 'perform A-MA' and\n      there is a section called A-MAin as well                 */\n\n   select\n\n    /* do we have 'SECTION.' on the line, nothing before the\n       actual procedure name we're looking for and only the\n       one word ('SECTION.') after the procedure name          */\n    /* The last control ensures we don't find a section\n       name that contains what we are looking for, but ALSO\n       has a suffix. For example, we've pressed F13 on\n             PERFORM FRED\n       and the current line is in fact\n             FRED-NEW SECTION.\n    */\n    when POS('SECTION.',line) <> 0     &,\n         words(leader) = 0             &,\n         words(rest)   = 1             &,\n         substr(rest,1,7) = 'SECTION'  then\n           leave                         /* Yes - leave the loop */\n\n    /* do we have 'SECTION.' on the line, and the text after the\n       possible word 'SECTION.' only contains the usual trailing\n       numbers                                                 */\n    when POS('SECTION.',line) <> 0        &,\n         datatype(trailing_nums) = 'NUM'  &,\n         words(rest)   = 2                then\n           leave                         /* Yes - leave the loop */\n\n    /* do we have 'SECTION.' on the line, and the text after the\n       possible word 'SECTION.' is blank                */\n    when POS('SECTION.',line) <> 0    &,\n         length(trailing_nums) = 0    &,\n         words(rest)   = 1            then\n           leave                         /* Yes - leave the loop */\n\n    /* I think (?) you can code a section as only containing\n       the name of the section followed by a fullstop, WITHOUT\n       the actual word SECTION. The next when tests for that    */\n    when words(leader) = 0         &,\n         substr(rest,1,1) = '.'       then\n          leave\n\n    otherwise\n         FIND ''''proc'''' next       /* No - look again            */\n    end\n  end\n  If rc = 0 Then\n   do\n    locate lnr    /* Make sure found line is \"top of screen\" */\n    Call ISPFVPUT\n   end\n\n  If rc<>0 Then Do\n    keepcsr = 1                          /* return cursor if not found*/\n    If rc=4 Then Do\n      If POS('=',line) > 0 Then Do\n        v2 = v2 + 0\n        Parse Upper Var line =(v2) tproc '(' .\n      End\n      tline = 'DCL' tproc\n      Call EXTERNAL\n    End\n    Else Do\n      zedsmsg = 'FIND PROC error'\n      zedlmsg = \"FIND returned\" rc \"when trying to find\",\n                \"the PROC named '\"proc\"' in this program.\"\n      Call ISPFMSG\n    End\n\n    'RESET LABEL .JB' || suff '.JB' || suff\n  /*  'HILITE FIND'  IBM special        */\n  End\n  Else xrc = 1                           /* Leave cursor on ZCMD      */\nReturn\n/*----------------------------------------------------------------------\n! Handle INCLUDEs, even EXEC SQL includes are handled                  !\n----------------------------------------------------------------------*/\nINCLUDE:\n  Address ISPEXEC\n  Parse Var tline 'INCLUDE ' member .   /* Take member name          */\n  /* GLCD is DCLG backwards, ie, are we ALREADY in the DCLG PDS ?? */\n  If SUBSTR(REVERSE(ds),1,4) <> 'GLCD' then\n   do\n    temp = reverse(ds)\n    lastqual = pos('.',temp) - 1     /* Remove the last qualifier */\n    temp = substr(ds,1,length(ds) - lastqual)\n    tempds = temp'DCLG('member')'\n   end\n  else\n   tempds = ds || '('member')'          /* Concat member             */\n\n  'CONTROL ERRORS RETURN'                /* Ignore ISPF errors        */\n  /* Check first whether the member exists       */\n  call check_qual\n  call view_member 'INCLUDE',koll\n\nReturn\n/*----------------------------------------------------------------------\n! Handle CALLs to external programs\n! The code will through the DSN defined in the generic variables\n! CALLDSNx trying to find the specific program name\n----------------------------------------------------------------------*/\nCALL_STMT:\n  Address ISPEXEC\n  Parse Var tline 'CALL ' member .       /* Get program name          */\n  member = strip(member,'B')\n  /* Check if surrounded by single quotes - double ones\n     are not checked                                      */\n  if pos('''',member) <> 0 then\n   do\n    /* Ensure the actual quotes don't follow along in the name */\n    member = substr(member,2,length(member) - 2)\n   end\n  tempds = ds || '('member')'          /* Concat member             */\n\n  'CONTROL ERRORS RETURN'                /* Ignore ISPF errors        */\n  /* Check first whether the member exists       */\n  /*\n  call check_qual\n  call view_member 'CALL',koll\n  */\n  call find_dsn 'CALLDSN'\n  if file_found = 1 then\n    koll = 'OK'\n  else\n    koll = 'NOT THERE'\n\n  call view_member 'CALL',koll\n  /* RC = 20 means the program couldn't be found - we'll try again\n     but this time, we'll look for the name in the working storage\n     section                                     */\n  if rc = 20 then\n   do\n    Address ISREDIT\n    /* Try and find the definition for the variable used instead */\n    'FIND ''WORKING-STORAGE'' FIRST'\n    /* Loop round as long as we still find the occurrence of the\n       procedure string we're looking for */\n    do while rc <> 4\n     call get_current_line\n     upper line\n     if pos('SECTION.',line) <> 0 then   /* Does the line contain\n                                            the word SECTION.  ??    */\n     leave                              /* Yes - leave the loop */\n    else\n     'FIND ''WORKING-STORAGE'''\n    end\n    /* Be surprised if this doesn't work |||| */\n    if rc = 0 then\n     do\n      /* Find the first reference to the VARIABLE used in the call */\n      'FIND' member 'FIRST'\n      if rc = 0 then\n       do\n        /* we found it - analyze the definition picking out the\n           the value defined */\n        '(TLINE) = LINE .zcsr'\n        tline = STRIP(tline,'B')\n        upper tline\n        if 'CALL' <> word(tline,1) then\n         do\n          /* \"'\" on next line ensures no quotes picked up */\n          Parse Var tline . 'X(' . 'VALUE' \"'\"member\"'\" .\n          member = STRIP(member,'B')\n          tempds = ds || '('member')'\n          Address ISPEXEC\n          'CONTROL ERRORS RETURN'\n       /** view \"DATASET('\"tempds\"')\" **/\n          Address ISPEXEC \"SELECT PGM(ISPSTRT)\",\n             \"PARM(CMD(ISREPDF '\"tempds\"' V))\"\n         end\n        else\n         call nothing_found 'PROGRAM'\n       end\n     end\n   end\nReturn\n/*----------------------------------------------------------------------\n! Handle COPYs or INCLUDEs\n! The code will through the DSN defined in the generic variables\n! COPYDSNx trying to find the specific program name\n----------------------------------------------------------------------*/\nCOPY_INCLUDE:\n  full_qual = 0\n  arg type               /* Should be COPY or INCLUDE   */\n  Address ISPEXEC\n  Parse Var tline (type) member .  /* Take member name */\n  Parse var line (type) full_name\n  full_name = strip(full_name)\n  select\n    when substr(full_name,1,1) = \"'\" & ,\n         substr(reverse(full_name),1,1) = \"'\"   then\n      do\n         member = full_name\n         full_qual = 1\n      end\n    when length(member) > 8    then\n      do\n        zedsmsg = 'Invalid 'type'name'\n        zedlmsg = type'name cannot be more than 8 characters'\n        Call ISPFMSG\n        return\n      end\n    otherwise\n      nop\n  end\n  select\n    when full_qual = 1  then\n      tempds = member\n    when SUBSTR(REVERSE(ds),1,4) <> 'YPOC' then\n      /* YPOC is COPY backwards, ie, are we ALREADY */\n      /* in the COPY PDS ?? (we'll know this by */\n      /* looking at the dataset name)              */\n      do\n        temp = reverse(ds)\n        lastqual = pos('.',temp) - 1 /* Remove the last qualifier */\n        temp = substr(ds,1,length(ds) - lastqual)\n        tempds = temp'COPY('member')'\n      end\n    otherwise\n      tempds = ds || '('member')'     /* Concat member     */\n  end\n\n  'CONTROL ERRORS RETURN'                /* Ignore ISPF errors        */\n  hlq_wordnr = 1\n  call find_dsn 'COPYDSN'\n  if file_found = 1 then\n    koll = 'OK'\n  else\n    koll = 'NOT THERE'\n\n  call view_member 'COPY',koll\n\nReturn\n/************************************************************\n Check if the member can be found in the various HLQ libraries\n (the generic name of the variable should be passed to this\n  procedure)\n************************************************************/\nfind_dsn:\n/* varname will contain the variable name that in turn\n   contains the possible HLQ that we want to look through */\n   arg varname\n   save_name = file\n   file_found = 0\n   interpret 'i2 = 'varname'_nr'\n   do i = 1 to i2\n    /* Ensure that temp is given the value in varnamex\n       (where x will be 1 to varname_nr)              */\n    interpret 'temp = 'varname||i\n    upper temp\n    /* If the first character in the string is a '?', then\n       change it for the HLQ                            */\n    if substr(temp,1,1) = \"?\" then\n        temp = hlq||substr(temp,2)\n\n    /* Check that the current copydsnx variable ACTUALLY contains\n       something AND that we don't end up looking in the SAME PDS\n       we are already editting                                 */\n    select\n      when pos(\"'\",member) <> 0 then\n        do\n          x = MSG(\"OFF\")\n          koll = sysdsn(member)\n          a = MSG(x)        /* reset message value */\n          if koll = 'OK' then\n            do\n              file_found = 1\n              tempds = member\n              tempds = translate(tempds,\"\",\"'\") /* remove blips */\n              tempds = strip(tempds)\n              return\n            end\n        end\n      when temp <> '' & zdsn <> temp then\n        do\n          x = MSG(\"OFF\")\n          koll = sysdsn(\"'\"temp\"(\"member\")'\")\n          a = MSG(x)        /* reset message value */\n          if koll = 'OK' then\n            do\n              file_found = 1\n              tempds = temp'('member')'\n              return\n            end\n        end\n    end\n   end   /* end do i = 1 to 9 */\n   zedsmsg = 'File missing'\n   zedlmsg = 'Cannot find program/file 'file\n   address ispexec\n\n   address\n   Return\n/*----------------------------------------------------------------------\n! See if we can find the member if we change the 2nd qualifier         !\n----------------------------------------------------------------------*/\ncheck_qual:\n /* Does the member exist ? */\n x = MSG(\"OFF\")\n koll = sysdsn(\"'\"tempds\"'\")\n a = MSG(x)        /* reset message value */\n if koll = 'MEMBER NOT FOUND' ! koll = 'DATASET NOT FOUND' then\n  do\n    save_tempds = tempds\n    /* Parse the filename into its constituent parts */\n    parse var tempds hlq '.' andra '.' rest\n    /* Find where the current qualifier is in the search chain */\n    start = wordpos(andra,qual_2)\n    /* Now point at the next DSN in the search chain and see if\n       we can find the member in THAT group instead            */\n    call check_qual_2\n    /*\n    if koll <> \"OK\" & word(qual_1,1) <> hlq then\n    */\n    if koll <> \"OK\" & words(qual_1) <> hlq_wordnr then\n     do\n       hlq_wordnr = hlq_wordnr + 1\n       do i2 = hlq_wordnr to words(qual_1)\n        start = 0\n        hlq = word(qual_1,i2)\n        call check_qual_2\n       end\n     end\n    /* We either come here via the leave or because we found the\n       member somewhere in the chain. IF we lookoed all through the\n       chain and never found anything, then koll will contain\n       something other than OK, in which case restore the dsn\n       name to the starting point                        */\n    if koll <> 'OK' then\n     tempds = save_tempds\n  end\nReturn\n/*----------------------------------------------------------------------\n! Change the second qualifier\n----------------------------------------------------------------------*/\ncheck_qual_2:\n   /* We only look for qualifiers \"later\" in the chain\" */\n   start = start + 1\n   do i = start to words(qual_2)\n   /* Create the relevant dsn                          */\n   tempds = hlq\".\"word(qual_2,i)\".\"rest\n   x = MSG(\"OFF\")\n   koll = sysdsn(\"'\"tempds\"'\")\n   a = MSG(x)        /* reset message value */\n   if koll = 'OK' then\n    leave\n   End\n   Return\n/*----------------------------------------------------------------------\n! Invalid call\n----------------------------------------------------------------------*/\nINVALID_CALL:\n zedsmsg = 'Invalid call'\n zedlmsg = \"Cannot determine call method. Try again\"\n Call ISPFMSG\nreturn\n/*----------------------------------------------------------------------\n! Common message routine for no file                                   !\n----------------------------------------------------------------------*/\nnothing_found:\n arg member\n zedsmsg = 'No 'member' found'\n zedlmsg = 'Cannot find ANY 'member' anywhere to show'\n Call ISPFMSG\nreturn\n/*----------------------------------------------------------------------\n! Common message routine for no file                                   !\n----------------------------------------------------------------------*/\nview_member:\n arg type,koll\n if koll = 'OK' then\n  do\n   Address ISPEXEC \"SELECT PGM(ISPSTRT)\",\n      \"PARM(CMD(ISREPDF '\"tempds\"' V))\"\n    /**  view \"DATASET('\"tempds\"')\"  **/\n   if rc = 14 then                 /* Being editted by someone ??? */\n    do\n     Address ISPEXEC \"SELECT PGM(ISPSTRT)\",\n        \"PARM(CMD(ISREPDF '\"tempds\"' V))\"\n      /**  view = 'BROWSE'                Yes -browse instead    **/\n      /**  view \"DATASET('\"tempds\"')\"          BROWSE the member **/\n    end\n  end\n else\n  do\n   /* If we are NOT looking for an external routine, issue the\n      error message                                      */\n   if type =  'CALL' then\n    rc = 20\n   else\n    call nothing_found 'member'\n  end\n\nreturn\n/*----------------------------------------------------------------------\n! Show info/error messages to user                                     !\n----------------------------------------------------------------------*/\nISPFMSG:\n  IF zedsmsg <> '' THEN DO /* ERROR IN MACRO STATEMENT */\n    zcmd = ''\n    Address ISPEXEC\n    'VPUT (ZCMD,ZEDSMSG,ZEDLMSG)'\n    'SETMSG MSG(ISRZ001)'\n  End\n/*\nIf keepcsr = 1 Then\n do\n  Address ISREDIT\n  'CURSOR =' v1 v2\n end\n*/\nReturn\n/*----------------------------------------------------------------------\n! Show info/error messages to user                                     !\n----------------------------------------------------------------------*/\nISPFREMOVE: Procedure Expose JBNUM member\n  Address ISPEXEC\n  'VGET (FINCL) SHARED'\n  If rc> 8 Then Say 'ISPFVGET: error rc='  rc\n  member = STRIP(member)\n  where  = POS(member,fincl)\n  if where>0 Then\n  do\n    fincl = DELSTR(fincl,where,LENGTH(member)+2)\n    fincl = SPACE(fincl,1)\n    'VPUT (FINCL) SHARED'\n    If rc> 8 Then Say 'ISPFVPUT: error rc=' rc\n  end\nReturn\n/*----------------------------------------------------------------------\n! Show info/error messages to user                                     !\n----------------------------------------------------------------------*/\nISPFVGET: Procedure Expose JBNUM\n  '(member) = member'\n  Address ISPEXEC\n  'VGET (FINCL) SHARED'\n  If rc> 8 Then Say 'ISPFVGET: error rc='  rc\n  temp = member'_'\n  /* Need to do it this way, otherwise the member we are editting\n     could be MIKE and the value in FINCL could be MIKE2_2. As a\n     result, the POS(...) would return a 1, and the resulting\n     jbnum would be _2 which causes problems later on           */\n  /* where = POS(member,fincl)*/\n  where = POS(temp,fincl)\n  if where>0 Then\n  do\n    jbnum = SUBSTR(fincl,(where+LENGTH(member)+1),2)\n  end\n  else jbnum = 0\nReturn\n/*----------------------------------------------------------------------\n! Show info/error messages to user                                     !\n----------------------------------------------------------------------*/\nISPFVPUT: Procedure Expose JBNUM member\n  '(MEMBER) = MEMBER'\n  Address ISPEXEC\n  'VGET (FINCL) SHARED'\n  where = POS(member,fincl)\n  if where>0 Then\n  do\n    fincl = OVERLAY(jbnum,fincl,(where+LENGTH(member)+1),2)\n  end\n  else\n  do\n    fincl = fincl member || '_' || jbnum\n  end\n  fincl = SPACE(fincl,1)\n  'VPUT (FINCL) SHARED'\n  If rc> 8 Then Say 'ISPFVPUT: error rc='  rc\nReturn\n/********************************************************************\n These are the default copybook filenames that will be searched for\n if the users points to a COPY book rather than a fully\n qualified DSN. Assuming the file being edited is\n               'MISI01.BMAT.COBOL'\n then the variables below will be resolved in the following manner\n ?    = MISI01\n lvl2 = BMAT\n hlq  = MISI01\n ********************************************************************/\ndefine_copy:\n      copydsn1  = '-YOUR-COPYLIB-1-'\n      copydsn2  = '-YOUR-COPYLIB-2-'\n      copydsn3  = '-YOUR-COPYLIB-3-'\n      copydsn4  = '-YOUR-COPYLIB-4-'\n            /* Pick up production copy books */\n      copydsn_nr = 4   /* Number of entries in the variable above */\nreturn\n/********************************************************************/\n/* Check if the code contains numbers or similar in the first       */\n/* 6 characters. If so, set the variable LEADING to 7 which means   */\n/* we'll always strip the first 7 characters from the line read in  */\n/********************************************************************/\ncheck_leading_numbers:\n'FIND \"PROGRAM-ID\" FIRST'\n'(V3,V4) = CURSOR'                       /* Where is the cursor?      */\n'(LINE)  = LINE' V3              /* Take data from that line  */\nif substr(line,2,10) = 'PROGRAM-ID' then\n  leading = 1\nelse\n  leading = 7\nAddress 'ISREDIT'\n/*\n'reset find'     /* Remove any highlighting of found strings */\n*/\nreturn\n/********************************************************************\n These are the default filenames that will be searched for\n if the users points to a CALL line.\n Assuming the file being edited is\n               'MISI01.BMAT.COBOLXXX'\n then the variables below will be resolved in the following manner\n ?    = MISI01\n lvl2 = BMAT\n hlq  = MISI01\n cob  = COBOLXXX\n ********************************************************************/\ndefine_call:\nselect\n  when hlq = zuser & cob <> 'COBOL' then\n    do\n      /* Last qualifier is not the standard .COBOL */\n      calldsn1  = '?.'||lv2'.'||cob\n      calldsn2  = '?.'||lv2'.COBOL'\n      calldsn3  = lv2||'.FT.COBOL'\n      calldsn_nr = 3      /* Number of entries in the variable above */\n    end\n  when hlq = zuser then\n    do\n      /* Last qualifier IS .COBOL, and HLQ is userid */\n      calldsn1  = '?.'||lv2'.COBOL'\n      calldsn2  = lv2||'.FT.COBOL'\n      calldsn_nr = 2      /* Number of entries in the variable above */\n    end\n  when lv2 = 'FT' then\n    do\n      /* File of type system.FT.COBOL       */\n      calldsn1  = hlq||'.'||lv2||'.COBOL'\n      calldsn_nr = 1    /* Number of entries in the variable above */\n    end\n  otherwise\n    do\n      /* Anything else                      */\n      calldsn1  = '?.'||lv2'.COBOL'\n      calldsn2  = lv2||'.FT.COBOL'\n      calldsn_nr = 2      /* Number of entries in the variable above */\n    end\nend\nreturn\n/*----------------------------------------------------------------------\n! Restore cursor\n----------------------------------------------------------------------*/\nRESTORE_CURSOR:\nAddress 'ISREDIT'\n'locate' v1   /*       Return the CURSOR         */\n'reset find'         /* Remove any highlighting of found strings */\nreturn\n/********************************************************************/\n/* Get the COBOL word where the cursor is placed.  We need this for */\n/* a line such as                                                   */\n/*          CALL 'E2064020' USING COPY BMATE001.                    */\n/* where we need to know if the cursor is under the CALL or the     */\n/* COPY statement                                                   */\n/********************************************************************/\nget_line_word:\ntemp_line = substr(line,v2)     /* Get from cursor to end of line */\ntemp_word = word(temp_line,1)   /* Get only the actual word */\ntemp_line = substr(line,1,v2 - 1) /* Get from cursor to end of line */\ntemp_line = reverse(temp_line)\nif substr(temp_line,1,1) <> ' ' then\n temp_line = word(temp_line,1)   /* Get only the actual word */\nelse\n temp_line = ''\n/* Reverse it and glue the start and end words together        */\ntemp_word = reverse(temp_line)||temp_word\ntemp_word = strip(temp_word)     /* and remove all blanks */\nreturn\n/**********************************************************************/\n/* We've discovered that the user has called FINCL with 2 possible    */\n/* combinations on the same line - check wkich one the cursor is under*/\n/**********************************************************************/\ndetermine_which_call:\ncall get_line_word\nSelect                                   /* select action             */\n  When temp_word = 'COPY'       then     /* On a COPY line?           */\n    Call COPY_INCLUDE 'COPY '            /* Handle the COPY    member */\n  When temp_word = 'CALL'    Then        /* Is it CALL stmt?          */\n    Call call_stmt                       /* Yes                       */\n  Otherwise                              /* Nop stmt                  */\n    Call invalid_cursor 'CALL COPY'\nEnd\n\nreturn\n/**********************************************************************/\n/* Return the current line where the cursor is MINUS a possible      */\n/* leading 7 characters if there are the extra characters i pos 1-7  */\n/*********************************************************************/\nget_current_line:\n'(LINE)  = LINE .zcsr'           /* Take data from that line  */\nline = substr(line,leading)\nreturn\n/**********************************************************************/\n/*                                                                    */\n/**********************************************************************/\ninvalid_cursor:\n\n arg type1 type2\n zedsmsg = type1'/'type2' on same line'\n zedlmsg = 'Place cursor under either 'type1' or 'type2\n Call ISPFMSG\n return\n\nDispDoc:\n   ADDRESS TSO \"CLEAR\"\n   SAY \" JT - Jump to Paragraph on Line with Cursor / CopyBook \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    JT    ( ? )                                    )   \"\n   SAY\n   SAY \"    Places display at Paragraph on line where cursor   \"\n   SAY \"    was positioned. Nests invocation and returns via   \"\n   SAY \"    JB macro.                                          \"\n   SAY\n   SAY \"    If placed on COPY statement line, will attempt to  \"\n   SAY \"    View that CopyBook.                                \"\n   SAY\n   RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "KEEPCOLS": {"ttr": 25605, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x03'\\x1f\\x01\\x03'\\x1f\\x12\\x00\\x00\\xfa\\x00\\xfa\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-09-28T00:00:00", "modifydate": "2003-09-28T12:00:00", "lines": 250, "newlines": 250, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- RETAIN ONLY SPECIFIED COLUMNS, SHIFTING LEFT REMAINS  **/\n   RTN = 0\n   SAVEMSG = MSG(\"OFF\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'KEEPCOLS MUST BE RUN UNDER ISPF!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (PARMS) NOPROCESS\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      ARG PARMS\n      SIGNAL DSLIST\n   END\n\n   ERRORMSG = \"\"\n   MESG     = \"\"\n   COL.     = \"\"\n   PARMCNT  = 0\n   LBL1     = \"\"\n   LBL2     = \"\"\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR \"\n   DO II = 1 TO 22;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n      END\n      ELSE DO\n         IF  \u00acDATATYPE(TOKEN,'W') | TOKEN = 0 THEN DO\n            MESG = \"'\"TOKEN\"' COLUMN VALUE IS INVALID!\"\n            SIGNAL ERROR\n         END\n         IF TOKENT > LRECL THEN DO\n            MESG = \"COLUMN\" TOKEN \"IS BIGGER THAN RECORD SIZE (\"LRECL\")\"\n            SIGNAL ERROR\n         END\n         PARMCNT     = PARMCNT + 1\n         COL.PARMCNT = TOKEN\n      END\n   END II\n\n   IF (PARMCNT // 2) <> 0 THEN DO\n      MESG = \"THERE ARE AN ODD NUMBER OF COLUMNS (\"PARMCNT\")\"\n      SIGNAL ERROR\n   END\n\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n   IF LBL1 <> \"\" THEN DO\n      \"ISREDIT L &LBL1\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n      \"ISREDIT (START) = LINENUM &LBL1\"\n      \"ISREDIT L &LBL2\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n      \"ISREDIT (END) = LINENUM &LBL2\"\n   END\n   ELSE DO\n      \"ISREDIT PROCESS RANGE C\"\n      IF RC > 0 THEN DO\n         START  = 1\n         \"ISREDIT (END) = LINENUM .ZLAST\"\n      END\n      ELSE DO\n         \"ISREDIT (START) = LINENUM .ZFRANGE\"\n         \"ISREDIT (END)   = LINENUM .ZLRANGE\"\n      END\n   END\n\n   IF START > END THEN DO\n      FLIP  = START\n      START = END\n      END   = FLIP\n   END\n\n   KEEPON = \"YES\"\n   IF PARMCNT > 2 THEN DO II = 1 TO PARMCNT-3 BY 2,\n         WHILE (KEEPON = \"YES\")\n      KEEPON = \"NO\"\n      DO JJ = II+2 TO PARMCNT-1 BY 2\n         IF COL.II > COL.JJ THEN DO\n            TEMP1  = COL.II\n            XX     = II + 1\n            TEMP2  = COL.XX\n            COL.II = COL.JJ\n            YY     = JJ + 1\n            COL.XX = COL.YY\n            COL.JJ = TEMP1\n            COL.YY = TEMP2\n            KEEPON = \"YES\"\n         END\n      END JJ\n   END II\n\n   DO II = 1 TO PARMCNT-1 BY 2\n      XX = II + 1\n      IF COL.XX < COL.II THEN DO\n         MESG = \"COLUMNS\" COL.II \"AND\" COL.XX \"NOT IN ORDER\"\n         SIGNAL ERROR\n      END\n   END II\n\n   DO PNTR =  START  TO  END  BY 1\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      REC = \"\"\n      DO II = 1 TO PARMCNT-1 BY 2\n         XX = II + 1\n         REC = REC || SUBSTR(RECORD,COL.II,COL.XX-COL.II+1)\n      END II\n      \"ISREDIT LINE &PNTR = &STR(REC)\"\n   END\n\n   \"ISREDIT LOCATE\" START\n   \"ISREDIT AUTONUM = \"ANUM\n    SIGNAL EOJ\n\nDSLIST:\n   ERRORMSG = \"\"\n   MESG     = \"\"\n   COL.     = \"\"\n   PARMCNT  = 0\n   LBL1     = \"\"\n   LBL2     = \"\"\n   DO II = LENGTH(PARMS)-1 TO 1 BY -1 WHILE(SUBSTR(PARMS,II,1) <> \"'\")\n   END II\n   ZINPDSN = SUBSTR(PARMS,II)\n   PARMS   = SUBSTR(PARMS,1,II-1)\n   LDSI    = LISTDSI(ZINPDSN)\n   LRECL   = SYSLRECL\n   DO II = 1 TO 22;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF  \u00acDATATYPE(TOKEN,'W') | TOKEN = 0 THEN DO\n         ERRORMSG = \"'\"TOKEN\"' COLUMN VALUE IS INVALID!\"\n         SIGNAL DISPDOC\n      END\n      IF TOKENT > LRECL THEN DO\n         ERRORMSG = \"COLUMN\" TOKEN \"IS BIGGER THAN RECORD SIZE (\"LRECL\")\"\n         SIGNAL DISPDOC\n      END\n      PARMCNT     = PARMCNT + 1\n      COL.PARMCNT = TOKEN\n   END II\n\n   IF (PARMCNT // 2) <> 0 THEN DO\n      ERRORMSG = \"THERE ARE AN ODD NUMBER OF COLUMNS (\"PARMCNT\")\"\n      SIGNAL DISPDOC\n   END\n\n   KEEPON = \"YES\"\n   IF PARMCNT > 2 THEN DO II = 1 TO PARMCNT-3 BY 2,\n         WHILE (KEEPON = \"YES\")\n      KEEPON = \"NO\"\n      DO JJ = II+2 TO PARMCNT-1 BY 2\n         IF COL.II > COL.JJ THEN DO\n            TEMP1  = COL.II\n            XX     = II + 1\n            TEMP2  = COL.XX\n            COL.II = COL.JJ\n            YY     = JJ + 1\n            COL.XX = COL.YY\n            COL.JJ = TEMP1\n            COL.YY = TEMP2\n            KEEPON = \"YES\"\n         END\n      END JJ\n   END II\n\n   DO II = 1 TO PARMCNT-1 BY 2\n      XX = II + 1\n      IF COL.XX < COL.II THEN DO\n         ERRORMSG = \"COLUMNS\" COL.II \"AND\" COL.XX \"NOT IN ORDER\"\n         SIGNAL DISPDOC\n      END\n   END II\n\n   ADDRESS TSO\n   \"FREE DD(DDXX)\"\n   \"ALLOC DSN(\"ZINPDSN\") DD(DDXX) SHR\"\n   \"EXECIO 0 DISKRU\" DDXX \"(OPEN\"\n   \"EXECIO 1 DISKRU\" DDXX\n   RET_CD = RC\n   DO WHILE ( RET_CD = 0 )\n      PARSE PULL RECORD\n      REC = \"\"\n      DO II = 1 TO PARMCNT-1 BY 2\n         XX = II + 1\n         REC = REC || SUBSTR(RECORD,COL.II,COL.XX-COL.II+1)\n      END II\n      QUEUE REC\n      \"EXECIO 1 DISKW\" DDXX\n      \"EXECIO 1 DISKRU\" DDXX\n      RET_CD = RC\n   END\n   \"EXECIO 0 DISKW\" DDXX \"(FINIS\"\n   \"FREE DD(DDXX)\"\n    SIGNAL EOJ\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   SIGNAL DISPDOC\n\nEOJ:\n   X = MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"KEEPCOLS - RETAIN SPECIFIC COLUMNS, DELETING ALL OTHERS \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    KEEPCOLS  COL-1 COL-2 (...)  ( .A .B  ) \"\n   SAY\n   SAY \"       AT LEAST 1 COLUMN SET REQUIRED.  LABEL \"\n   SAY \"       RANGE OR C/CC/C# RANGE OPTIONAL.       \"\n   SAY\n   SAY \" EXAMPLES \"\n   SAY \"    KEEPCOLS  5 15   1 2   73 80           \"\n   SAY \"       WILL DELETE ALL COLUMNS EXCEPT      \"\n   SAY \"       COLUMNS 1 THRU 2, 5 THRU 15 AND     \"\n   SAY \"       73 THRU 80, SHIFTING ALL TO THE LEFT\"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LASTREF": {"ttr": 25610, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\x05\\x00\\x05\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- RETRIEVE AND DISPLAY LAST REFERENCED DATE (DS LIST)  **/\n   ISPEXEC VGET (ZDLDSN) SHARED\n   ISPEXEC VGET (ZDLRDATE) SHARED\n   SAY \"FILE\" ZDLDSN \"WAS LAST REFERENCED\" ZDLRDATE\n   EXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LESS": {"ttr": 25612, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\x89\\x00\\x89\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 137, "newlines": 137, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- EXCLUDE LINES BEFORE/AFTER SHOWN LINES  **/\n   ADDRESS \"ISREDIT\"\n   \"MACRO (PARMS) NOPROCESS\"\n\n   AFTER  = 1\n   BEFORE = 1\n   LABF   = \"\"\n   LABL   = \"\"\n   FIRST  = -1\n\n   PARMS = TRANSLATE(PARMS)\n   IF PARMS = '?' THEN SIGNAL DISPDOC\n   DO II = 1 TO 10;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,6) = \"AFTER(\" THEN DO;\n         PARSE VAR TOKEN  \"AFTER(\" AFTER \")\" RIGHT\n         ITERATE II;\n      END\n      IF \"BEFORE(\" = SUBSTR(TOKEN,1,7)  THEN DO;\n         PARSE VAR TOKEN  \"BEFORE(\" BEFORE \")\" RIGHT\n         ITERATE II;\n      END\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LABF = \"\" THEN LABF = TOKEN\n         ELSE IF LABL = \"\" THEN LABL = TOKEN\n         ELSE DO\n            ZEDSMSG = \".LABEL RC=8\"\n            ZEDLMSG = \"TOO MANY LABELS --\" LABF LABL TOKEN\n            ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n            EXIT 8\n         END\n      END\n   END II\n   IF LABF <> \"\"  &  LABL = \"\"  THEN LABL = LABF\n\n   IF LABL = \"\" THEN DO\n      \"PROCESS RANGE C\"\n      IF RC = 0 THEN DO\n         LABF = \".ZFRANGE\"\n         LABL = \".ZLRANGE\"\n      END\n      ELSE DO\n         LABF = \".ZFIRST\"\n         LABL = \".ZLAST\"\n      END\n   END\n\n   \"(LABFNO) = LINENUM\" LABF\n   \"(LABLNO) = LINENUM\" LABL\n\n   DO II = LABFNO TO LABLNO\n      \"(LINESTAT) = XSTATUS\" II\n      IF LINESTAT = \"NX\" THEN DO\n         RR = -1\n         DO JJ = (II+1) TO LABLNO\n            \"(LINESTAT) = XSTATUS\" JJ\n            IF LINESTAT = \"X\" THEN DO\n               RR = JJ\n               IF (JJ-II) >= BEFORE THEN DO\n                  DO KK = (JJ-1) TO (JJ-BEFORE) BY -1\n                     \"XSTATUS\" KK \"= X\";\n                     IF FIRST = -1 THEN FIRST = KK\n                  END\n                  JJ = LABLNO + 1\n               END\n            END\n         END\n         IF RR = -1 THEN II = LABLNO + 1\n                    ELSE II = RR + 1\n      END\n   END\n\n   DO II = LABFNO TO LABLNO\n      \"(LINESTAT) = XSTATUS\" II\n      IF LINESTAT = \"X\" THEN DO\n         RR = -1\n         DO JJ = (II+1) TO LABLNO\n            \"(LINESTAT) = XSTATUS\" JJ\n            IF LINESTAT = \"NX\" THEN DO\n               DO KK = JJ TO LABLNO\n                  \"(LINESTAT) = XSTATUS\" KK\n                  IF (KK-JJ) >= AFTER  |  LINESTAT = \"X\"  THEN DO\n                     RR = KK\n                     JJ = LABLNO + 1\n                     KK = LABLNO + 1\n                  END\n                  ELSE DO\n                     \"XSTATUS\" KK \"= X\"\n                  END\n               END\n            END\n         END\n         IF RR = -1 THEN II = LABLNO + 1\n                    ELSE II = RR\n      END\n   END\n\n   IF FIRST = -1 THEN DO\n       \"LOCATE\" 0\n   END\n   ELSE DO\n      IF FIRST > 1 THEN FIRST = FIRST - 1\n      \"(LINESTAT) = XSTATUS\" FIRST\n      \"LOCATE\" FIRST\n      \"XSTATUS\" FIRST \"=\" LINESTAT\n   END\n\n   ZEDSMSG = \"LESS\" BEFORE\"/\"AFTER\n   ZEDLMSG = \"LESS COMPLETED BEFORE=\"BEFORE \"AND AFTER=\"AFTER\n   ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   EXIT(1)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"LESS - EXCLUDE LINE(S) BEFORE/AFTER CURRENTLY EXCLUDED LINES\"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    LESS    ( BEFORE(#) )   ( AFTER(#) )   ( .A .B )        \"\n   SAY\n   SAY \"       EXCLUDES THE NUMBER OF LINES SPECIFIED IN BEFORE OR  \"\n   SAY \"       AFTER AROUND EACH GROUP OF CURRENTLY EXCLUDED LINES, \"\n   SAY \"       DEFAULTING TO 1 BEFORE AND AFTER. THE RANGE TO BE    \"\n   SAY \"       PROCESSED MAY BE SPECIFIED VIA LABELS OR C/CC/C#     \"\n   SAY \"       PREFIX COMMANDS.                                     \"\n   SAY\n   SAY \" EXAMPLE                                                    \"\n   SAY\n   SAY \"    LESS  AFTER(0)                                          \"\n   SAY\n   SAY \"       WILL CAUSE 1 LINE TO BE EXCLUDED BEFORE EACH EXCLUDED\"\n   SAY \"       GROUP, THE DEFAULT FOR BEFORE, AND NO LINES AFTER    \"\n   SAY \"       WITHIN THE ENTIRE FILE.                              \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LJUST": {"ttr": 25857, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00P\\x00P\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 80, "newlines": 80, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- LEFT JUSTIFIES DATA USING CC/C## RANGE OR DEFAULTS  **/\n/*           TO ENTIRE FILE; ACCEPTS COLUMNS OR USES ISPF BOUNDS */\n\n   SAVEMSG = MSG()\n   X = MSG(\"OFF\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY \"LJUST MUST BE RUN UNDER ISPF EDIT!\"\n      SIGNAL QUIT\n      END\n   SUBCOM ISREDIT\n   UMODE = \"ISREDIT\"\n   ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n   ADDRESS ISREDIT\n   \"MACRO (LEFT,RIGHT) NOPROCESS\"\n   IF LEFT = '?' THEN SIGNAL DISPDOC\n\n   IF LEFT <> \"\" AND RIGHT = \"\" THEN DO\n      \"ISREDIT (L2,RIGHT) = BOUNDS\"\n      END\n\n   \"PROCESS RANGE C\"\n   IF RC > 0 THEN DO\n      \"(TOP) = LINENUM .ZFIRST\"\n      \"(BOT) = LINENUM .ZLAST\"\n   END\n   ELSE DO\n      \"(TOP) = LINENUM .ZFRANGE\"\n      \"(BOT) = LINENUM .ZLRANGE\"\n   END\n\n   \"ISREDIT(\"LB\",\"RB\") = BOUNDS\"\n   IF LEFT  <> \"\" THEN LB = LEFT\n   IF RIGHT <> \"\" THEN RB = RIGHT\n\n   DO II = TOP TO BOT BY 1\n      \"ISREDIT (RECORD) = LINE &II\"\n      DO JJ = LB TO RB BY 1 WHILE(SUBSTR(RECORD,JJ,1) = ' ')\n         END\n      IF LB < JJ THEN DO\n         RECORD = SUBSTR(RECORD,1,LB-1) || SUBSTR(RECORD,JJ,RB-JJ+1),\n            || SUBSTR(RECORD,LB,JJ-LB)  || SUBSTR(RECORD,RB+1)\n         \"ISREDIT LINE &II = &STR(RECORD)\"\n         END\n      END\n\nQUIT:\n   ADDRESS ISPEXEC\n   X = MSG(SAVEMSG)\n   ADDRESS ISREDIT \"LOCATE\" TOP\n   EXIT(1)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"LJUST - LEFT JUSTIFY TEXT W/IN BOUNDS                    \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    LJUST   ( LEFT-COLUMN  RIGHT-COLUMN )                \"\n   SAY\n   SAY \"       WILL CAUSE THE MARKED (VIA C/CC/C##) RANGE OF     \"\n   SAY \"       LINES TO BE LEFT JUSTIFIED WITHIN THE BOUNDS THEN \"\n   SAY \"       IN FORCE.  IF NO RANGE IS SPECIFIED, THE ENTIRE   \"\n   SAY \"       FILE IS PROCESSED.  THE FIRST AND THE LAST        \"\n   SAY \"       NON-BLANK CHARACTERS WITHIN THE BOUNDS DETERMINE  \"\n   SAY \"       THE SIZE OF THE DATA TO BE LEFT JUSTIFIED.        \"\n   SAY \"       SPECIFYING A LEFT COLUMN AND LEFT COLUMN WILL     \"\n   SAY \"       CAUSE ONLY THE DATA IN THOSE COLUMNS TO BE        \"\n   SAY \"       JUSTIFIED.                                        \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    LJUST  1 50                                          \"\n   SAY \"       WILL CAUSE THE TEST IN COLUMNS 1 THRU 50 TO BE    \"\n   SAY \"       SHIFTED LEFT SO THAT THE FIRST NON BLANK IN THOSE \"\n   SAY \"       COLUMNS WILL BE IN POSITION 1.                    \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LKDT": {"ttr": 25860, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00Y\\x00Y\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 89, "newlines": 89, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- DISPLAY LINK EDIT DATE OF SPECIFIC LOAD MODULE  **/\n\n   PARSE ARG PARMS\n   MSG = MSG(OFF)\n   PARMS = TRANSLATE(PARMS)\n\n   IF WORD(PARMS,1) = \"\" | WORD(PARMS,1) = \"?\"\n      THEN SIGNAL DISPDOC\n\n   TOKEN    = WORD(PARMS,1)\n   XX       = INDEX(TOKEN,\"(\")\n   YY       = INDEX(TOKEN,\")\")\n   SEL_LMOD = SUBSTR(TOKEN,XX+1,YY-XX-1)\n   IF SUBSTR(TOKEN,1,1) = \"'\" | SUBSTR(TOKEN,1,1) = '\"',\n      THEN FULL_DSN = SUBSTR(TOKEN,1,XX-1) || \"'\"\n      ELSE FULL_DSN = \"'\" || USERID() || \".\",\n         || SUBSTR(TOKEN,1,XX-1) || \"'\"\n\n   ADDRESS TSO\n   \"FREE  DD(SYSLML SYSPRINT SYSIN)\"\n   \"ALLOC DD(SYSLML) DSN(\"FULL_DSN\") SHR\"\n   \"ALLOC DD(SYSPRINT) NEW TRACKS SPACE(1) UNIT(SYSDA)\",\n        \" LRECL(121) BLKSIZE(27951) RECFM(F B M)\"\n   \"ALLOC DD(SYSIN) NEW TRACKS SPACE(1) UNIT(SYSDA)\",\n        \" LRECL(80) BLKSIZE(800) RECFM(F B)\"\n   QUEUE \" LISTIDR  DDN=SYSLML,MEMBER=\" || SEL_LMOD\n   \"EXECIO\" QUEUED() \"DISKW SYSIN (FINIS\"\n\n   \"CALL *(AMBLIST)\"\n   IF RC <> 0 THEN DO\n      SAY \"*** AMBLIST RETURNED CODE\" RC \"- PROBABLY NO IDR DATA FOUND\"\n      EXIT(1)\n   END\n   ELSE DO\n      \"EXECIO 0 DISKR\" SYSPRINT \"(OPEN\"\n      \"EXECIO 1 DISKR\" SYSPRINT\n      RETCODE = RC\n      DO WHILE RETCODE = 0\n         PULL PRTLINE\n         IF INDEX(PRTLINE,\"WAS PRODUCED BY\") <> 0 THEN DO\n            XX   = INDEX(PRTLINE,\"ON DAY \")\n            DDD  = SUBSTR(PRTLINE,XX+7,3)\n            XX   = INDEX(PRTLINE,\"OF YEAR \")\n            YYYY = SUBSTR(PRTLINE,XX+8,4)\n            TIMP = SUBSTR(PRTLINE,XX+16,8)\n            RETCODE = 666\n         END\n         ELSE \"EXECIO 1 DISKR\" SYSPRINT\n      END\n      \"EXECIO 0 DISKR\" SYSPRINT \"(FINIS\"\n      \"FREE  DD(SYSLML SYSPRINT SYSIN)\"\n      YYYYDDD = YYYY || DDD\n      SPARMS = DATE(S,SUBSTR(YYYYDDD,3),J)\n      IF SUBSTR(SPARMS,8,1) = '1'         THEN XX = 'st'\n         ELSE IF SUBSTR(SPARMS,8,1) = '2' THEN XX = 'nd'\n         ELSE IF SUBSTR(SPARMS,8,1) = '3' THEN XX = 'rd'\n         ELSE XX = 'th'\n      DD = SUBSTR(SPARMS,7,2)\n      IF SUBSTR(DD,1,1) = '0'             THEN DD = SUBSTR(DD,2)\n      SAY SEL_LMOD \"in\" FULL_DSN \"was linked\"\n      IF TIMP <> \" \",\n         THEN SAY \"   \" DATE(W,SPARMS,S) DATE(M,SPARMS,S) DD||XX',',\n            YYYY \"(day\" DDD\") at\" TIMP\n         ELSE SAY \"   \" DATE(W,SPARMS,S) DATE(M,SPARMS,S) DD||XX',',\n            YYYY \"(day\" DDD\")\"\n      EXIT(0)\n   end\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"                                                             \"\n   SAY \"  LKDT          DISPLAYS THE DATE THE SPECIFIED LOAD MODULE  \"\n   SAY \"                WAS LINK EDITED.                             \"\n   SAY \"                                                             \"\n   SAY \"  SYNTAX:   LKDT      LOAD-LIBRARY-NAME(MEMBER)              \"\n   SAY\n   SAY \"             LOAD-LIBRARY-NAME IS THE LOAD MODULE LIBRARY    \"\n   SAY \"             WHICH CONTAINS THE MODULE TO BE DATED.          \"\n   SAY\n   SAY \"             MEMBER IS THE SPECIFIC LOAD MODULE TO BE DATED. \"\n   SAY \"             IT MAY ALSO BE ENTERED ON ANY MEMBER LIST OF A  \"\n   SAY \"             LOAD MODULE LIBRARY (BROWSE, EDIT OR VIEW).     \"\n   SAY\n   SAY \"  EXAMPLE:   LKDT 'SYS1.LINKLIB(IEHPROGM)'                   \"\n   SAY\n   SAY \"             LKDT MY.LOADLIB(TESTMOD)                        \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LMODWU": {"ttr": 25863, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x02h\\x02h\\x00\\x00\\xd3\\xd4\\xd6\\xc4\\xe6\\xe4@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 616, "newlines": 616, "modlines": 0, "user": "LMODWU"}, "text": "//-YOUR-USERID-L JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  ASSEMBLY & LINK JCL FOR SPECIFIC LOAD MODULE WHERE USED\n//***\n//A          EXEC     PGM=ASMA90,REGION=4M,\n//             PARM='NODECK,OBJECT'\n//SYSLIB       DD       DISP=SHR,DSN=SYS1.MACLIB\n//             DD       DISP=SHR,DSN=-YOUR-SYSLIB-\n         TITLE 'LMODWU  -  FIND WHERE LOAD MODULE USED'\nLMODWU   START 0\n         REGS\n\n***********************************************************************\n*        LMODWU                                                       *\n*                                                                     *\n*        SEARCH A PDS FOR A GIVEN  CSECT NAME                         *\n*        ( MUST CONTAIN MEMBERS CREATED BY THE LINKAGE EDITOR )       *\n*                                                                     *\n*        FOR EACH MEMBER, THE FOLLOWING IS LISTED  -                  *\n*              1. THE MEMBER NAME                                     *\n*              2. THE TTRC         ( FROM THE DIRECTORY )             *\n*              3. THE LINK-EDIT ATTRIBUTES                            *\n*              4. THE LENGTH OF THE MODULE                            *\n*              5. THE ENTRY POINT                                     *\n*                                                                     *\n***********************************************************************\n\nLMODWU   CSECT\n         SAVE  (14,12),T,*\n         LR    R10,R15             ESTABLISH A BASE REGISTER\n         USING LMODWU,R10          -\n         LA    R12,SAVE            CHAIN SAVE AREAS\n         ST    R12,8(,R13)         -\n         ST    R13,4(,R12)         -\n         LR    R13,R12             -\n\n*\n*        SAVE THE CSECT NAME TO LOOK FOR, GIVEN IN THE PARM FIELD  -\n*\n         L     R2,0(,R1)           GET POINTER TO THE PARMS\n         LA    R2,0(,R2)           -\n         LH    R3,0(,R2)           GET LENGTH OF THE PARMS\n         LTR   R3,R3               WERE ANY PARMS PASSED  ?\n         BNP   ERROR1              NO - BRANCH\n         C     R3,=F'8'            WAS THE PARM LENGTH GT 8\n         BH    ERROR1              YES - BRANCH\n\n         BCTR  R3,0                PREPARE TO EXECUTE\n         EX    R3,MOVEPARM         MOVE THE PARM TO AN AREA\n\n*        READ THE JFCB TO PREPARE FOR AN OBTAIN  -\n         RDJFCB (MEMDCB)           READ THE JFCB FOR THE PDS\n         LTR   R15,R15             DID IT DO THAT O.K.  ?\n         BNZ   ERROR2              NO - BRANCH\n\n*        ISSUE  AN OBTAIN, TO SEE IF THE PDS EXISTS -\n         OBTAIN CAMLIST            ISSUE OBTAIN\n         LTR   R15,R15             DID THE OBTAIN OBTAIN ANYTHING ?\n         BNZ   ERROR3              NO - BRANCH\n\n*        TEST TO ENSURE THAT THIS DATASET IS A PDS  -\n         TM    AREA+38,X'02'       TEST FOR 'DSORG=PO' IN FORMAT 1\n         BZ    ERROR4              NOT A PDS - BRANCH\n\n*        OPEN THE DCBS FOR THE DIRECTORY AND THE MEMBERS  -\n         OPEN  (DIRDCB,,MEMDCB)    ISSUE THE OPEN\n         TM    DIRDCB+48,X'10'     DID THE DIRECTORY DCB OPEN O.K. ?\n         BZ    ERROR5              NO - BRANCH\n         TM    MEMDCB+48,X'10'     DID THE MEMBER DCB OPEN O.K. ?\n         BZ    ERROR5              NO - BRANCH\n\n*        GET A BUFFER TO READ THE MEMBERS INTO  -\n         MVC   BUFFLEN,MEMDCB+62   GET BLOCKSIZE FROM THE DCB\n         L     R0,BUFFER           LENGTH + SP I.D. FOR GETMAIN\n         GETMAIN R,LV=(0)          ISSUE GETMAIN\n         ST    R1,DECB+12          PUT POINTER TO BUFFER IN DECB\n\n*        INITIALISE  THE BUFFER TO ZEROS (EASIER DEBUGGING)  -\n         LH    R2,BUFFLEN          GET LENGTH OF THE BUFFER\nZEROLOOP MVI   0(R1),0             MOVE A ZERO INTO THE BUFFER\n         LA    R1,1(,R1)           INDEX THROUGH THE BUFFER\n         BCT   R2,ZEROLOOP         ZERO THE ENTIRE BUFFER\n\n         OPEN  (SYSPRINT,(OUTPUT)) OPEN SYSPRINT\n         TM    SYSPRINT+48,X'10'   DID IT OPEN O.K.  ?\n         BZ    ERROR6              NO - BRANCH\n\n*        GET TIME AND DATE  -\n         TIME  DEC\n         ST    R0,TIME             SAVE TIME\n         ST    R1,DATE             SAVE DATE\n         MVO   TIM,TIME(2)         SAVE TIME\n\n*        GET JOBNAME OF JOB, AND SAVE IT  -\n         EXTRACT FIELD1,FIELDS=(TIOT)\n         L     R1,FIELD1           POINT TO TIOT\n         MVC   JNAME,0(R1)         SAVE JOBNAME\n         B     GET                 GET THE FIRST PDS DIRECTORY BLOCK\n\n*\n*        GET NEXT MEMBER IN THE PDS  -\n*\n*        FIRST  LOOK FOR A MEMBER IN THE CURRENT DIRECTORY BLOCK -\nEODAD    EQU   *\nLOOPDS1  L     R2,DIRPOINT         POINT TO THE NEXT MEMBER\n         IC    R3,11(,R2)          GET LENGTH OF USER DATA\n         N     R3,MASK2            LENGTH IS 5 BITS\n         SLL   R3,1                X 2 BECAUSE LENGTH IN HALF-WORDS\n         LA    R3,12(,R3)          ADD LENGTH OF MEMBER NAME + TTRC\n         AR    R3,R2               POINT TO NEXT MEMBER\n\n*        FIND  THE END OF THE DIRECTORY BLOCK  -\n         LA    R4,DIRBLOCK         POINT TO THE CURRENT DIRECTORY BLK\n         LH    R5,0(,R4)           GET LENGTH USED\n         AR    R5,R4               POINT TO END OF THE BLOCK\n         CR    R5,R3               HAS THIS BLOCK BEEN EXAUSTED ?\n         BH    GOTNEXT             NO - BRANCH\n\n*        READ THE NEXT DIRECTORY BLOCK  -\nGET      GET   DIRDCB,DIRBLOCK     READ THE NEXT DIRECTORY BLOCK\n         LA    R3,DIRBLOCK+2       POINT TO THE FIRST MEMBER IN BLOCK\nGOTNEXT  ST    R3,DIRPOINT         SAVE POINTER TO NEXT MEMBER\n\n         XC    CMREC,CMREC         # OF RECORDS READ FOR THIS MEMBER\n\n*        TEST TO SEE IF WE HAVE GOT TO THE END OF THE PDS  -\n         CLC   0(8,R3),LASTMEM     LOOK FOR A MEMBER NAME OF FOXES\n         BE    ENDPDS              GOT TO END - BRANCH\n\n*        COUNT # OF MEMBERS READ  -\n         L     R1,CPMEM            GET # OF MEMBERS READ\n         AL    R1,=F'1'            INCREMENT BY 1\n         ST    R1,CPMEM            AND SAVE IT\n\n         L     R2,DIRPOINT         POINT TO DIRECTORY ENTRY\n         MVC   TTRZ(3),8(R2)       SAVE TTR OF MEMBER\n         POINT MEMDCB,TTRZ         POINT TO THIS MEMBER\n\n*\n*        TEST FOR ALIAS  -\n*\n         L     R2,DIRPOINT         POINT TO DIRECTORY ENTRY\n         TM    11(R2),X'80'        IS THIS ENTRY AN ALIAS  ?\n*        PROCESS ALIAS THE SAME AS OTHER MEMBERS  -\n\n*        DETERMINE IF THE MEMBER WAS CREATED BY THE LINKAGE-EDITOR  -\n         IC    R3,11(,R2)          GET LENGTH OF USER DATA\n         N     R3,MASK2            -\n         C     R3,=F'11'           MUST BE AT LEAST 11 HALF-WORDS\n         BL    LOOPDS1             IT WAS NOT LINKED - BRANCH\n\n***********************************************************************\n*                                                                     *\n*        READ THE MEMBER SEQUENTIALLY, EXTRACTING INFORMATION         *\n*        AND WRITING IT TO THE OUTPUT FILE.                           *\n*                                                                     *\n***********************************************************************\n\nGETLOOP  EQU   *\n         L     R6,DECB+12          POINT TO INPUT AREA\n         READ  DECB,SF,MF=E        READ THE NEXT RECORD\n         CHECK DECB\n\n*        INCREMENT COUNT OF # OF RECORDS READ BY 1  -\n         L     R1,CMREC            COUNTS # OF INPUT RECORDS\n         AL    R1,=F'1'            INCREMENT\n         ST    R1,CMREC            AND SAVE\n\n         L     R1,CPREC            COUNTS # OF READS FOR THIS PDS\n         AL    R1,=F'1'            BUMP BY 1\n         ST    R1,CPREC            AND SAVE\n\n*\n*        LOOK AT RECORD TYPE, PROCES ACORDINGLY  -\n*\n         TM    0(R6),1             DOES THIS RECORD PRECEED A TEXT REC.\n         BO    EODAD               YES - BRANCH ( WE ARE DONE )\n\n         CLI   0(R6),X'20'         IS IT A CESD RECORD  ?\n         BE    CESD                YES - BRANCH\n         B     GETLOOP             GO GET ANOTHER RECORD\n\n***********************************************************************\n*                                                                     *\n*        PROCESS THE CESD TYPE INPUT RECORD                           *\n*                                                                     *\n***********************************************************************\n\nCESD     LA    R3,8(,R6)           POINT TO 1ST ESD ENTRY\n         LH    R4,6(,R6)           GET LENGTH OF ESD DATA\n         AR    R4,R3               POINT TO END OF RECORD\n         LH    R5,4(,R6)           GET # OF FIRST ESD ENTRY IN THIS REC\n\nLOOPESD  CR    R4,R3               HAVE WE GOT TO THE END YET ?\n         BNH   GETLOOP             YES - GO GET ANOTHER INPUT RECORD\n\n         L     R1,CCSCAN           # OF CSECTS SCANNED\n         AL    R1,=F'1'            INCREMENT BY 1\n         ST    R1,CCSCAN           AND SAVE IT\n\n         CLC   0(8,R3),CNAME       IS THIS CSECT THE NAME WE WANT ?\n         BE    BUILD               YES - BRANCH\n\nLOOPESD2 LA    R3,16(,R3)          BUMP TO NEXT ESD ENTRY\n         AL    R5,=F'1'            KEEP COUNT OF ESD ENTRY #\n         B     LOOPESD             AND LOOK AT IT\n\n\n*\n*        BUILD A PRINT LINE  -\n*\nBUILD    LA    R7,LINE             R7 WILL POINT TO DETAIL PRINT LINE\n         USING DETLINE,R7          -\n         MVI   LINE,C' '           BLANK THE PRINT LINE\n         MVC   LINE+1(131),LINE    -\n\n         L     R2,DIRPOINT         POINT TO DIRECTORY ENTRY\n\n*        COUNT # OF HITS FOUND  -\n         L     R1,CCHIT            GET # OF HITS\n         AL    R1,=F'1'            INCREMEMNT BY 1\n         ST    R1,CCHIT            AND SAVE IT\n\n*        ID/LENGTH  -\n         UNPK  DWA(7),13(4,R3)\n         MVC   DETIDL,DWA\n         TR    DETIDL,TABLE1\n\n*        SEGMENT #  -\n         UNPK  DWA(3),12(2,R3)\n         MVC   DETSEGN,DWA\n         TR    DETSEGN,TABLE1\n\n*        ADDRESS  -\n         UNPK  DWA(7),9(4,R3)\n         MVC   DETADDR,DWA\n         TR    DETADDR,TABLE1\n\n*        TYPE  IN HEX  -\n         UNPK  DWA(3),8(2,R3)\n         MVC   DETTYPC,DWA\n         TR    DETTYPC,TABLE1\n*        TYPE   -\n         LA    R15,TYPTABL         POINT TO TABLE END\n         LA    R1,TYPTAB           POINT TO TABLE\n         MVC   DWA(1),8(R3)        GET SEGMENT TYPE\n         NI    DWA,X'0F'\nNEXTYPE  CLC   0(1,R1),DWA         TRY TO MATCH WITH A TABLE ENTRY\n         BE    GOTYPE              GOT A HIT - BRANCH\n         CR    R1,R15              IS THIS THE  END OF THE TABLE  ?\n         BNL   NOTYPE              YES - BRANCH\n         LA    R1,3(,R1)           INDEX ALONG THE TABLE\n         B     NEXTYPE             AND TRY NEXT ENTRY\nGOTYPE   MVC   DETTYP,1(R1)        MOVE TYPE TO PRINT LINE\n\n*        NAME   -\nNOTYPE   MVC   DETNAME,0(R3)       MODULE NAME\n\n*        MODULE ENTRY POINT  -\n         UNPK  DWA(7),27(4,R2)\n         MVC   DETEP,DWA\n         TR    DETEP,TABLE1\n\n*        MODULE SIZE  -\n         UNPK  DWA(7),22(4,R2)\n         MVC   DETSIZE,DWA\n         TR    DETSIZE,TABLE1\n\n*        MODULE ATTRIBUTES  -\n         UNPK  DWA(5),20(3,R2)\n         MVC   DETATTR,DWA\n         TR    DETATTR,TABLE1\n\n*        TTRC  -\n         UNPK  DWA(9),8(5,R2)\n         MVC   DETTTRC,DWA\n         TR    DETTTRC,TABLE1\n\n*        MEMBER NAME  -\n         MVC   DETMEM,0(R2)\n\n         BAL   R9,WRITE            PUT A LINE TO THE PRINTER\n         B     LOOPESD2\n\n***********************************************************************\n*                                                                     *\n*        WRITE A LINE TO THE PRINTER                                  *\n*                                                                     *\n***********************************************************************\n\nWRITE    ST    R9,SAVE9\n*\n*        TEST  FOR HEADINGS REQUIRED  -\n*\n         CP    LINENO,MAXLINE      IS IT BOTTOM OF PAGE YET  ?\n         BL    NOHEAD              NO - BRANCH\n\n         ZAP   LINENO,=P'0'        RESET LINE COUNTER\n         AP    PAGE,=P'1'          INCREMENT PAGE #\n\n         MVI   HCNTL,X'8B'         SKIP TO 01\n         MVI   HLINE,C' '          BLANK HEADING PRINT LINE\n         MVC   HLINE+1(131),HLINE  -\n         LA    R2,HCNTL            POINT TO PRINT LINE\n         BAL   R9,PRINT            GO PRINT\n\n         MVC   HLINE+110(6),PAT02\n         ED    HLINE+110(6),PAGE   EDIT PAGE #\n         MVC   HLINE+106(4),=C'PAGE'\n         MVC   HLINE+90(7),PAT01\n         ED    HLINE+90(7),DATE+1  EDIT DATE  YY.DDD\n         MVC   HLINE+83(5),=C'DATE:'\n         MVC   HLINE+30(L'HEAD01),HEAD01\n         MVC   HLINE(8),JNAME\n         MVI   HCNTL,X'09'\n         LA    R2,HCNTL\n         BAL   R9,PRINT\n\n         MVC   HLINE+90(7),PAT03\n         ED    HLINE+90(7),TIM     EDIT TIME  HH.MM\n         MVC   HLINE+83(5),=C'TIME:'\n         MVI   HCNTL,X'19'\n         LA    R2,HCNTL\n         BAL   R9,PRINT\n\n*        PUT DSNAME = AND VOLSER =  -\n         LA    R1,JFCB             POINT TO JFCB\n         MVC   HLINE+25(44),0(R1)  MOVE DSNAME\n         MVC   HLINE+16(8),=C'DSNAME ='\n         MVI   HCNTL,X'09'\n         LA    R2,HCNTL\n         BAL   R9,PRINT\n\n         LA    R1,JFCB             POINT TO JFCB\n         MVC   HLINE+25(6),118(R1) MOVE VOLSER\n         MVC   HLINE+16(8),=C'VOLUME ='\n         MVI   HCNTL,X'19'\n         LA    R2,HCNTL\n         BAL   R9,PRINT\n\n         MVC   HLINE(132),HEAD02\n         MVI   HCNTL,X'09'\n         LA    R2,HCNTL\n         BAL   R9,PRINT\n\n         MVC   HLINE(132),HEAD03\n         MVI   HCNTL,X'09'\n         LA    R2,HCNTL\n         BAL   R9,PRINT\n\n         MVC   HLINE(132),HEAD04\n         MVI   HCNTL,X'19'\n         LA    R2,HCNTL\n         BAL   R9,PRINT\n\nNOHEAD   AP    LINENO,=P'1'        INCREMENT LINE #\n         LA    R2,CNTL             POINT TO DETAIL PRINT LINE\n         MVI   CNTL,X'09'\n         BAL   R9,PRINT            PRINT IT\n         L     R9,SAVE9            RESTORE RETUTN REGISTER\n         BR    R9                  RETURN\n\n***********************************************************************\n*                                                                     *\n*        END OF THE PDS - CLEAN UP AND EOJ                            *\n*                                                                     *\n***********************************************************************\n\n*        CLOSE DCBS FOR THE PDS  -\nENDPDS   CLOSE (MEMDCB,,DIRDCB)    ISSUE CLOSE\n\n*        FREE THE BUFFER USED TO READ THE MEMBERS  -\n         L     R0,BUFFER           GET LENGTH AND S.P.\n         L     R1,DECB+12          POINT TO BUFFER\n         FREEMAIN R,LV=(0),A=(1)   ISSUE FREEMAIN\n\n*        FREE  THE BUFFERS USED BY THE DIRECTORY DCB  -\n         FREEPOOL DIRDCB\n\n*        ISSUE THE END MSG. INDICATING # OF HITS  -\n         MVC   ENDMSGN,CNAME       PUT NAME OF SEARCH FIELD IN MSG\n         L     R1,CCHIT            GET # OF HITS\n         CVD   R1,DWA              CVD\n         ED    ENDMSGP,DWA+4\n         MVI   CNTL,X'1B'          SPACE 3 IMMED.\n         BAL   R9,WRITE\n         MVI   CNTL,X'1B'          SPACE 3 IMMED.\n         BAL   R9,WRITE\n         MVI   CNTL,X'09'\n         MVC   LINE+10(ENDMSGL),ENDMSG\n         BAL   R9,WRITE\n\n         LA    R1,ENDMSGW\n         WTO   MF=(E,(1))\n\n         CLOSE (SYSPRINT)          CLOSE SYSPRINT\n\n         FREEPOOL SYSPRINT         FREE THE SYSPRINT BUFFER POOL\n\nGOBACK   L     R13,4(,R13)\n         RETURN (14,12),T,RC=(15)\n\n***********************************************************************\n*                                                                     *\n*        PRINT A LINE SUBROUTINE                                      *\n*                                                                     *\n***********************************************************************\nPRINT    LR    R0,R2               POINT TO LINE TO PRINT\n         PUT   SYSPRINT            PUT IT\n         MVI   0(R2),C' '          BLANK OUT THE LINE WE PRINTED\n         MVC   1(131,R2),0(R2)     -\n         BR    R9                  RETURN\n\n***********************************************************************\n*                                                                     *\n*        ERROR CONDITIONS                                             *\n*                                                                     *\n***********************************************************************\n\n*        NO PARMS PASSED ON ENTRY  -\nERROR1   EQU   *\n         LA    R1,WTOMSG1          POINT TO ERROR MESSAGE\n         WTO   MF=(E,(1))          WTO\n         ABEND 1,DUMP              ERROR IN SORT\n\n*        ERROR IN RDJFCB  -\nERROR2   LA    R2,MEMDCB           POINT TO DCB\n         ABEND 2,DUMP\n\n*        ERROR IN OBTAIN  -\nERROR3   LA    R2,CAMLIST          POINT TO CAMLST\n         ABEND 3,DUMP\n\n*        DATASET TO BE PROCESSED IS NOT A PDS  -\nERROR4   LA    R2,AREA             POINT TO FORMAT 1 LABEL\n         ABEND 4,DUMP\n\n*        CANNOT OPEN PDS DCBS  -\nERROR5   LA    R2,DIRDCB           POINT TO DIRECTORY DCB\n         LA    R3,MEMDCB           POINT TO MEMBER DCB\n         ABEND 5,DUMP\n\n*        UNABLE TO OPEN SYSPRINT  -\nERROR6   LA    R2,SYSPRINT         POINT TO SYSPRINT DCB\n         ABEND 6,DUMP              ABEND\n\n*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n*                                                                     *\n*        C O N S T A N T S                                            *\n*                                                                     *\n*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\nSAVE     DC    9D'0'               REGISTER SAVE AREA\nWORK     DC    D'0'                WORK AREA\nSAVE9    DC    F'0'                REG. 9 SAVE AREA\n\n*        ERROR MESSAGE ISSUED IF NO PARMS PASSED ON INPUT  -\nWTOMSG1  DC    0F'0',Y(WTOMSG1E-*),H'0'\n         DC    C'INPUT PARMS MISSING OR INVALID'\nWTOMSG1E EQU   *\n\nMASK     DC    F'63'               MASK FOR 6 BITS   2 - 7\nMASK2    DC    F'31'               MASK FOR 5 BITS   3 - 7\n         DC    0H'0'\nMOVEPARM MVC   CNAME(0),2(R2)      MOVE PARM FIELD\nCNAME    DC    CL8' '              NAME PASSED IN PARM FIELD\n\n*        FIELDS RELATING TO THE PDS  -\nTTRZ     DC    F'0'                TTR OF MEMBER I AM PROCESSING\n         READ  DECB,SF,MEMDCB,0,'S',MF=L                       DECB\n\nBUFFER   DC    0F'0',X'0200'       LENGTH + SP FOR GETMAIN\nBUFFLEN  DC    H'0'                -\n\nCPMEM    DC    F'0'                # OF MEMBERS PROCESSED FROM PDS\nCMREC    DC    F'0'                # OF RECORDS READ FOR THIS MEMBER\nCPREC    DC    F'0'                # OF READS FOR THE PDS\nCCSCAN   DC    F'0'                # OF CSECTS SCANNED\nCCHIT    DC    F'0'                # OF CSECTS WE GOT A HIT ON\n\nDIRPOINT DC    F'0'                POINTER TO CURRENT MEMBER\nLASTMEM  DC    8X'FF'              NAME OF LAST MEMBER IN PDS\nEXLST    DC    0F'0',X'87',AL3(JFCB)\n\n*        TABLE  USED TO CONVERT ESD TYPE TO PRINTABLE TYPE FORMAT  -\nTYPTAB   DC    X'00',C'SD'         SECTION DEFINITION\n         DC    X'02',C'ER'         EXTERNAL REFERENCE\n         DC    X'03',C'LR'         LABEL REFERENCE\n         DC    X'04',C'PC'         PRIVATE CODE\n         DC    X'05',C'CM'         COMMON AREA\n         DC    X'06',C'PR'         PSEUDO REGISTER\n         DC    X'07',C'NL'         NULL\nTYPTABL  DC    X'0A',C'WX'         WEAK EXTERNAL REFERENCE\n\n*        TRANSLATE TABLE TO CONVERT TO PRINTABLE HEX  -\n         ORG   *-240\nTABLE1   EQU   *\n         ORG\n         DC    C'0123456789ABCDEF'\n\n         DC    0D'0'\n         LTORG\n         DC    0D'0'\n\nCAMLIST  CAMLST SEARCH,JFCB,JFCB+118,AREA\n\nJFCB     DC    0D'0',176X'00'      AREA TO READ THE JFCB INTO\nAREA     DC    0D'0',148X'00'      AREA TO CONTAIN THE FORMAT 1 LABEL\nDIRBLOCK DC    32D'0'              CURRENT DIRECTORY BLOCK\n\nSAVE35   DC    9D'0'               REGISTER SAVE AREA\nJNAME    DC    CL8' '              JOBNAME OF THIS JOB\nFIELD1   DC    F'0'                POINTER TO TIOT\n\n*        DETAIL PRINT LINE  _\nCNTL     DC    X'09'\nLINE     DC    132C' '\n\n*        HEADING PRINT LINE  -\nHCNTL    DC    X'8B'\nHLINE    DC    132C' '\n\nPAT01    DC    XL7'4021204B202020'\nPAT02    DC    XL6'402020202120'\nPAT03    DC    XL7'402120204B2020'\n\nPAGE     DC    PL3'0'              CURRENT PAGE #\nLINENO   DC    PL2'99'             CURRENT LINE #\nMAXLINE  DC    PL2'45'             MAX # OF LINES/PAGE\n\nDWA      DC    2D'0'               WORK SPACE\nTIME     DC    F'0'\nTIM      DC    X'00000F'\nDATE     DC    F'0'\n\nHEAD01   DC    C'C S E C T   S E A R C H   R E P O R T'\nHEAD02   DC    CL132'         MODULE            LINK           ENTRY   X\n                      CSECT                      SG   I.D./'\nHEAD03   DC    CL132'          NAME      TTRC   ATTR  LENGTH   POINT   X\n                      FOUND     TYPE      ADDR.  NO  LENGTH'\nHEAD04   DC    CL132'       --------  --------  ----  ------  ------   X\n                    --------  -------    ------  --  ------'\n\n*        END MESSAGE - SHOWS NUMBER OF HITS  -\nENDMSGW  DC    0F'0',Y(ENDMSGE-ENDMSGW),H'0'\nENDMSG   DC    C'TOTAL OCCURANCES OF CSECT NAME '\nENDMSGN  DC    CL8'XXXXXXXX'\n         DC    C' IS'\nENDMSGP  DC    X'4020202020202120'\nENDMSGE  EQU   *\nENDMSGL  EQU   ENDMSGE-ENDMSG\n\n*        D C B S  -\n         PRINT NOGEN\n*        MEMBER DCB - USED TO READ EACH MEMBER OF THE PDS  -\nMEMDCB   DCB   DDNAME=SYSUT1,DSORG=PO,MACRF=R,RECFM=U,EXLST=EXLST,     X\n               EODAD=EODAD\n\n*        DIRECTORY DCB - USED TO READ THE DIRECTORY OF THE PDS  -\nDIRDCB   DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=GM,RECFM=F,BLKSIZE=256,    X\n               LRECL=256,BUFNO=100\n\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBM,  X\n               BLKSIZE=1995\n         PRINT GEN\n         DC    4D'0'\n***********************************************************************\n*                                                                     *\n*        FORMAT OF THE DETAIL PRINT LINE                              *\n*                                                                     *\n***********************************************************************\nDETLINE  DSECT\n         DS    CL7 -\nDETMEM   DS    CL8 -               MEMBER NAME\n         DS    CL2 -\nDETTTRC  DS    XL8 -               TTRC\n         DS    CL2 -\nDETATTR  DS    XL4 -               MODULE ATTRIBUTES\n         DS    CL2 -\nDETSIZE  DS    CL6 -               MODULE SIZE\n         DS    CL2 -\nDETEP    DS    CL6 -               MODULE ENTRY POINT\n         DS    CL8 -\nDETNAME  DS    CL8 -               NAME OF SEARCH CSECT\n         DS    CL2 -\nDETTYP   DS    CL2 -               TYPE OF ESD ENTRY\n         DS    CL3 -\nDETTYPC  DS    XL2 -               TYPE OF ESD ENTRY - IN HEX\n         DS    CL4 -\nDETADDR  DS    XL6 -               ADDRESS FIELD\n         DS    CL2 -\nDETSEGN  DS    XL2 -               SEGMENT #\n         DS    CL2 -\nDETIDL   DS    XL6 -               ID/LENGTH FIELD\n         END   LMODWU\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//***\n//L          EXEC     PGM=IEWL,COND=(5,LT),\n//             PARM='XREF,LIST,LET,DCBS',\n//             REGION=4M\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,\n//             DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   99110500\n  ENTRY    LMODWU\n  NAME     LMODWU(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LMODWU$": {"ttr": 26117, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\n\\x00\\n\\x00\\x00\\xd3\\xd4\\xd6\\xc4\\xe6\\xe4@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "LMODWU"}, "text": "//-YOUR-USERID-L JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  LOAD MODULE WHERE USED\n//***\n//LMODWU     EXEC     PGM=LMODWU,REGION=4M,PARM=BLDLR\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSPRINT     DD       SYSOUT=*\n//SYSUT1       DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LMODXRF": {"ttr": 26119, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x15*\\x15*\\x00\\x00\\xd3\\xd4\\xd6\\xc4\\xe7\\xd9\\xc6@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 5418, "newlines": 5418, "modlines": 0, "user": "LMODXRF"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "LMODXRF$": {"ttr": 28419, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x16\\x00\\x16\\x00\\x00\\xd3\\xd4\\xd6\\xc4\\xe7\\xd9\\xc6@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "LMODXRF"}, "text": "//-YOUR-USERID-L JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  CROSS REFERENCE A LINK LIBRARY BY MODULE AND CSECT\n//***\n//PDSXREF    EXEC     PGM=LMODXREF,REGION=4M\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//PDSLIB       DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//PDSMEM       DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSOUT       DD       SYSOUT=*\n//LSTMEMBR     DD       SYSOUT=*\n//LSTCSECT     DD       SYSOUT=*\n//NAMEIN       DD       UNIT=SYSDA,SPACE=(CYL,(10,1)),DCB=BLKSIZE=1600\n//NAMEOUT      DD       UNIT=SYSDA,SPACE=(CYL,(10,1)),DCB=BLKSIZE=1600\n//NAMEWK01     DD       UNIT=SYSDA,SPACE=(CYL,(10,10))\n//NAMEWK01     DD       UNIT=SYSDA,SPACE=(CYL,(10,10))\n//NAMEWK02     DD       UNIT=SYSDA,SPACE=(CYL,(10,10))\n//NAMEWK03     DD       UNIT=SYSDA,SPACE=(CYL,(10,10))\n//NAMEWK04     DD       UNIT=SYSDA,SPACE=(CYL,(10,10))\n//NAMEWK05     DD       UNIT=SYSDA,SPACE=(CYL,(10,10))\n//NAMEWK06     DD       UNIT=SYSDA,SPACE=(CYL,(10,10))\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LONGEST": {"ttr": 28421, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x03'\\x1f\\x01\\x03'\\x1f\\x12\\x00\\x00f\\x00f\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-09-28T00:00:00", "modifydate": "2003-09-28T12:00:00", "lines": 102, "newlines": 102, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- DETERMINE LONGEST LINE & SHOW 1ST ONE   **/\n   ADDRESS \"ISREDIT\"\n   \"MACRO (PARMS) NOPROCESS\"\n\n   LABF   = \"\"\n   LABL   = \"\"\n   FIRST  = -1\n\n   PARMS = TRANSLATE(PARMS)\n   IF PARMS = '?' THEN SIGNAL DISPDOC\n   DO II = 1 TO 10;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LABF = \"\" THEN LABF = TOKEN\n         ELSE IF LABL = \"\" THEN LABL = TOKEN\n         ELSE DO\n            ZEDSMSG = \".LABEL RC=8\"\n            ZEDLMSG = \"TOO MANY LABELS --\" LABF LABL TOKEN\n            ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n            EXIT 8\n         END\n      END\n   END II\n   IF LABF <> \"\"  &  LABL = \"\"  THEN LABL = LABF\n\n   IF LABL = \"\" THEN DO\n      \"PROCESS RANGE C\"\n      IF RC = 0 THEN DO\n         LABF = \".ZFRANGE\"\n         LABL = \".ZLRANGE\"\n      END\n      ELSE DO\n         LABF = \".ZFIRST\"\n         LABL = \".ZLAST\"\n      END\n   END\n\n   \"(LABFNO) = LINENUM\" LABF\n   \"(LABLNO) = LINENUM\" LABL\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   \"ISREDIT (\"RECFM\") = RECFM \"\n\n   LONGEST_SIZE = 0\n   IF SUBSTR(RECFM,1,1) <> \"F\" THEN DO\n      DO II = LABFNO TO LABLNO\n         \"ISREDIT (CURRSIZE) = SAVE_LENGTH\" II\n         IF CURRSIZE > LONGEST_SIZE THEN DO\n            LONGEST_SIZE   = CURRSIZE\n            NUMBER_LONGEST = 1\n            FIRST          = II\n         END\n         ELSE IF CURRSIZE = LONGEST_SIZE,\n            THEN NUMBER_LONGEST = NUMBER_LONGEST + 1\n      END\n   END\n   ELSE DO\n      DO II = LABFNO TO LABLNO\n         \"(REC) = LINE\" II\n         DO JJ = LRECL TO 1 BY -1 WHILE(SUBSTR(REC,JJ,1) = \" \")\n         END JJ\n         IF JJ > LONGEST_SIZE THEN DO\n            LONGEST_SIZE   = JJ\n            NUMBER_LONGEST = 1\n            FIRST          = II\n         END\n         ELSE IF JJ = LONGEST_SIZE,\n            THEN NUMBER_LONGEST = NUMBER_LONGEST + 1\n      END\n   END\n\n   \"LOCATE\" FIRST\n   LONGEST_SIZE = LONGEST_SIZE + 0\n   ZEDSMSG = \"LONGEST\" LONGEST_SIZE\"(\"NUMBER_LONGEST\")\"\n   ZEDLMSG = NUMBER_LONGEST \"RECORDS OF\" LONGEST_SIZE \"LENGTH\"\n   ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   EXIT(1)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"LONGEST - FIND THE FIRST LONGEST RECORD IN THE RANGE      \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    LONGEST   ( .A .B )                                   \"\n   SAY\n   SAY \"       MAKES THE FIRST LINE WITH THE LONGEST LENGTH THE   \"\n   SAY \"       TOP LINE ON THE DISPLAY.  THE ACTUAL LENGTH IS     \"\n   SAY \"       SHOWN IN THE UPPER RIGHT MESSAGE AREA AS WELL AS   \"\n   SAY \"       THE NUMBER OF SUCH LENGTH RECORDS IN THE RANGE.    \"\n   SAY\n   SAY \"       FOR FIXED DATA, THE LONGEST LINE HAS THE SMALLEST  \"\n   SAY \"       NUMBER OF BLANKS ON THE RIGHT.                     \"\n   SAY\n   SAY \"       EITHER LABELS OR C/CC/C# MAY BE USED TO LIMIT THE  \"\n   SAY \"       LENGTH CHECK.  OBVIOUSLY MORE USEFUL FOR VARIABLE  \"\n   SAY \"       LENGTH FILES. A ? AS THE ONLY PARAMETER WILL CAUSE \"\n   SAY \"       THE BUILT IN HELP TO BE DISPLAYED.                 \"\n   SAY\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MACSDYNA": {"ttr": 28424, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x04x\\x04x\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 1144, "newlines": 1144, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&NAME    DYNSPACE &TYPE\n.*\n.*    THIS IS AN INNER MACRO TO ALLOC/FREE.\n.*    IT IS CALLED TO   A) NAME AN AREA FOR THE PARMLIST\n.*                      B) LOG THE VARIOUS AMOUNTS NEEDED BY\n.*                         EACH, REMEMBERING THE LARGEST.\n.*                      C) GENERATING A DS FOR THE LARGEST AMOUNT.\n.*    THE FIRST TWO FUNCTIONS ARE INVOKED BY ALLOC/FREE MACROS ONLY,\n.*    AND THE THIRD IS USED BY THE PROGRAMMER, EITHER EXPLICITLY,\n.*    OR BY BEGINWKA, IF THE LATTER IS USED.\n.*\n.*     TO INVOKE THE NAMING FUNCTION, ALLOC/FREE GENERATE\n.*     NAME DYNSPACE\n.*     NOTE. THE NAMING OPERATION ONLY GENERATES A NAME ON THE\n.*     FIRST CALL IN THE ASSEMBLY. THE NAME REMAINS THE SAME UNTIL\n.*     DYNSPACE IS CALLED TO EXPAND INTO A DS.\n.*\n.*     THE SECOND FUNCTION IS INVOKED BY THE MACRO CALL\n.*          DYNSPACE ADD\n.*     (NO NAME FIELD AND ONE OPERAND)\n.*     IT USES THE GLOBAL VARIABLES &DTUO AND &DTUPO TO CALCULATE\n.*     THE SPACE FOR THIS REQUEST, AND UPDATES &DYNSPQ ONLY IF THE\n.*     CURRENT REQUEST IS FOR A GREATER AMOUNT\n.*\n.*     THE THIRD FUNCTION IS INVOKED BY CALLING DYNSPACE WITH NO\n.*     NAME OR OPERAND FIELD.\n.*     THIS EXPANDS INTO A DEFINE STORAGE, CLEARS THE DYNSPACE NAME\n.*     GLOBAL SETC, AND THE &DYNSPQ GLOBAL SETA.\n.*     THUS, THE MACRO IS SERIALLY REUSABLE IN ALL FUNCTIONS.\n.*\n         GBLA  &DYNSPQ,&DTUO,&DTUPO,&RCPDYN\n         GBLC  &DYNP,&DYNSP\n         LCLA  &I\n         AIF   ('&NAME' NE '').NAME\n         AIF   ('&TYPE' EQ '').ALLOC\n.*   THE ACCUMULATE FUNCTION IS REQUIRED\n&I       SETA  24+&DTUO+&DTUPO         GET AMOUNT FOR THIS REQUEST\n         AIF   (&I LE &DYNSPQ).EXIT    IF CURRENT < MAX, EXIT\n&DYNSPQ  SETA  &I                      ELSE UPDATE CURRENT MAXIMUM\n         MEXIT\n.NAME    AIF   ('&DYNSP' NE '').EXIT   IF NAME ALREADY EXISTS, EXIT\n&DYNSP   SETC  'DYNSP&RCPDYN'           ELSE GENERATE A NAME\n.EXIT    MEXIT\n.ALLOC   AIF   ('&DYNSP' EQ '').EXIT\n*\n**     RESERVE SPACE FOR ALLOC/FREE MACRO WORK AREA\n*\n&DYNSP   DS    0F,CL&DYNSPQ            RESERVE SPACE\nO&DYNSP  DS    0F,CL&DYNSPQ            RESERVE SPACE\nO&DYNSP.O OUTADD MF=L\n&DYNSP   SETC  ''                      SET MAX QUANTITY TO 0\n&DYNSPQ  SETA 0\n         MEND\n         MACRO\n         RCPBTU &KEY,&NUM,&PAR\n         LCLA  &L\n.*\n.*  INNER MACRO FOR ALLOC, TO GENERATE TEXT UNITS ENTERED\n.*  IN QUOTES\n.*\n&L       SETA  K'&PAR-2                GET LENGTH OF TEXT UNIT\n         MVI   S99TUKEY+1,&KEY         SET TEXT UNIT KEY\n         MVI   S99TUNUM+1,&NUM         SET NUMBER FIELD\n         MVI   S99TULNG+1,&L           MOVE IN LENGTH\n         MVC   S99TUPAR(&L.),=C&PAR    MOVE IN TEXT UNIT\n&L       SETA  &L+6\n         AIF   (&L/2 EQ (&L+1)/2).LOK\n&L       SETA  &L+1\n.LOK     RCPDINC &L\n         MEND\n         MACRO\n         RCPDCBR &LRECL=,&BLKSIZE=,&RECFM=,&DEN=,&DSORG=,&KEYLEN=\n.*\n.*       INNER MACRO FOR ALLOC/FREE WRITTEN BY J. SAVIT, 12/12/80\n.*\n         GBLC  &DYNP,&RCPTYPE\n         LCLA  &DENVAL            ENCODED DENSITY BYTE\n         LCLA  &DSOVAL            ENCODED DSORG\n         LCLA  &SCAN              FOR SCANNING RECORD FORMAT CHARS\n         LCLA  &FORMAT            ENCODED RECORD FORMAT BYTE\n         AIF   ('&KEYLEN' EQ '').TLRECL\n         SPACE 1\n***********************************************************************\n**       KEYLEN TEXT UNIT         (J. SAVIT, 12/80)                  **\n***********************************************************************\n         RCPNTU DALKYLEN,1,&KEYLEN\n.TLRECL  AIF   ('&LRECL' EQ '').TBLKSIZ\n         SPACE 1\n***********************************************************************\n**       LRECL TEXT UNIT          (J. SAVIT, 12/80)                  **\n***********************************************************************\n         RCPNTU DALLRECL,2,&LRECL\n.TBLKSIZ AIF   ('&BLKSIZE' EQ '').TRECFM\n         SPACE 1\n***********************************************************************\n**       BLKSIZE TEXT UNIT        (J. SAVIT, 12/80)                  **\n***********************************************************************\n         RCPNTU DALBLKSZ,2,&BLKSIZE\n.TRECFM  AIF   ('&RECFM' EQ '').TDEN\n         SPACE 1\n***********************************************************************\n**       RECFM TEXT UNIT          (J. SAVIT, 12/80)                  **\n***********************************************************************\n&SCAN    SETA  K'&RECFM           LENGTH OF RECORD FORMAT SPEC\n&FORMAT  SETA  0                  RECORD FORMAT BYTE\n.RECFMA  AIF   (&SCAN EQ 0).RECFMX LOOP OVER CHARACTERS IN RECFM\n&C       SETC  '&RECFM'(&SCAN,1)  ISOLATE ELEMENT\n         AIF   ('&C' NE 'F').RECFMB IF NOT FIXED LENGTH\n&FORMAT  SETA  &FORMAT+8*16       SET FIXED LENGTH BIT\n         AGO   .RECFMK            LOOP OVER RECFM\n.RECFMB  AIF   ('&C' NE 'V').RECFMC IF NOT VARIABLE LENGTH\n&FORMAT  SETA  &FORMAT+4*16       SET VARIABLE LENGTH BIT\n         AGO   .RECFMK            LOOP OVER RECFM\n.RECFMC  AIF   ('&C' NE 'U').RECFMD IF NOT UNDEFINED LENGTH\n&FORMAT  SETA  &FORMAT+12*16      SET UNDEFINED BITS\n         AGO   .RECFMK            LOOP OVER RECFM\n.RECFMD  AIF   ('&C' NE 'B').RECFME IF NOT BLOCKED\n&FORMAT  SETA  &FORMAT+16         SET BLOCKED FILE BIT\n         AGO   .RECFMK\n.RECFME  AIF   ('&C' NE 'S').RECFMF IF NOT STANDARD LENGTH\n&FORMAT  SETA  &FORMAT+8          SET STANDARD BIT\n         AGO   .RECFMK\n.RECFMF  AIF   ('&C' NE 'A').RECFMZ IF NOT ASA CONTROL CHAR\n&FORMAT  SETA  &FORMAT+4\n         AGO   .RECFMK\n.RECFMZ  MNOTE 4,'*** UNRECOGNISED OR UNSUPPORTED RECORD FORMAT &C ***'\n.RECFMK  ANOP  ,\n&SCAN    SETA  &SCAN-1\n         AGO   .RECFMA\n.RECFMX  RCPNTU DALRECFM,1,&FORMAT\n.TDEN    AIF   ('&DEN' EQ '').TDSORG\n         SPACE 1\n***********************************************************************\n**       TAPE DENSITY TEXT UNIT   (J. SAVIT, 12/12/80)               **\n***********************************************************************\n         RCPTYPE &DEN             ANALYZE PARAMETER\n         AIF   ('&RCPTYPE' EQ 'N').DENB NUMERIC DCB\n         MNOTE 4,'*** DENSITY MUST BE 0,1,2,3 OR 4, LIKE IN JCL ***'\n         MNOTE *,'*** DEN IGNORED ***'\n         AGO   .TDSORG\n.DENB    ANOP  ,\n&DENVAL  SETA  0                  CLEAR DENSITY BYTE COUNTER\n         AIF   ('&DEN' EQ '0').DEN0 DENSITY 0?\n         AIF   ('&DEN' EQ '1').DEN1 DENSITY 1?\n         AIF   ('&DEN' EQ '2').DEN2 DENSITY 2?\n         AIF   ('&DEN' EQ '3').DEN3 DENSITY 3?\n         AIF   ('&DEN' EQ '4').DEN3 DENSITY 4?\n         MNOTE 4,'*** INVALID DENSITY-PARAMETER IGNORED ***'\n         AGO   .TDSORG            TRY NEXT PARAMETER INSTEAD\n.DEN4    ANOP  ,\n&DENVAL  SETA  16\n.DEN3    ANOP  ,\n&DENVAL  SETA  &DENVAL+64\n.DEN2    ANOP  ,\n&DENVAL  SETA  &DENVAL+64\n.DEN1    ANOP  ,\n&DENVAL  SETA  &DENVAL+64\n.DEN0    ANOP  ,\n&DENVAL  SETA  &DENVAL+03\n         RCPNTU DALDEN,1,&DENVAL\n.TDSORG  AIF   ('&DSORG' EQ '').EXIT\n         SPACE 1\n***********************************************************************\n**       DSORG TEXT UNIT          (J. SAVIT, 12/12/80)               **\n***********************************************************************\n         AIF   ('&DSORG' EQ 'PO').DSORGPO\n         AIF   ('&DSORG' EQ 'PS').DSORGPS\n         AIF   ('&DSORG' EQ 'DA').DSORGDA\n         MNOTE 8,'*** UNSUPPORTED DSORG &DSORG ***'\n         MEXIT\n.DSORGPO ANOP  ,\n&DSOVAL  SETA  2*16*16\n         AGO   .DSORGX\n.DSORGPS ANOP  ,\n&DSOVAL  SETA  4*16*16*16\n         AGO   .DSORGX\n.DSORGDA ANOP  ,\n&DSOVAL  SETA  2*16*16*16\n.DSORGX  RCPNTU DALDSORG,2,&DSOVAL\n.EXIT    MEND\n         MACRO\n         RCPDDCB &LRECL=,&BLKSIZE=,&RECFM=,&DEN=,&DSORG=,&KEYLEN=,     C\n               &BUFNO=\n.*\n.*\n         GBLC  &DYNP,&RCPTYPE\n         LCLA  &DENVAL            ENCODED DENSITY BYTE\n         LCLA  &DSOVAL            ENCODED DSORG\n         LCLA  &SCAN              FOR SCANNING RECORD FORMAT CHARS\n         LCLA  &FORMAT            ENCODED RECORD FORMAT BYTE\n         LCLC  &C                 RECFM\n         AIF   ('&KEYLEN' EQ '').TLRECL\n         SPACE 1\n***********************************************************************\n**       KEYLEN TEXT UNIT\n***********************************************************************\n         RCPNTU DALKYLEN,1,&KEYLEN\n.TLRECL  AIF   ('&LRECL' EQ '').TBLKSIZ\n         SPACE 1\n***********************************************************************\n**       LRECL TEXT UNIT\n***********************************************************************\n         RCPNTU DALLRECL,2,&LRECL\n.TBLKSIZ AIF   ('&BLKSIZE' EQ '').TBUFNO\n         SPACE 1\n***********************************************************************\n**       BLKSIZE TEXT UNIT\n***********************************************************************\n         RCPNTU DALBLKSZ,2,&BLKSIZE\n.TBUFNO  AIF   ('&BUFNO' EQ '').TRECFM\n         SPACE 1\n***********************************************************************\n**       BUFNO   TEXT UNIT\n***********************************************************************\n         RCPNTU DALBUFNO,1,&BUFNO\n.TRECFM  AIF   ('&RECFM' EQ '').TDEN\n         SPACE 1\n***********************************************************************\n**       RECFM TEXT UNIT\n***********************************************************************\n         AIF   ('&RECFM'(1,1) NE '(').NOREG\n         RCPRECFM RECFM=&RECFM\n         AGO   .TDEN\n.NOREG   ANOP\n&SCAN    SETA  K'&RECFM           LENGTH OF RECORD FORMAT SPEC\n&FORMAT  SETA  0                  RECORD FORMAT BYTE\n.RECFMA  AIF   (&SCAN EQ 0).RECFMX LOOP OVER CHARACTERS IN RECFM\n&C       SETC  '&RECFM'(&SCAN,1)  ISOLATE ELEMENT\n         AIF   ('&C' NE 'F').RECFMB IF NOT FIXED LENGTH\n&FORMAT  SETA  &FORMAT+8*16       SET FIXED LENGTH BIT\n         AGO   .RECFMK            LOOP OVER RECFM\n.RECFMB  AIF   ('&C' NE 'V').RECFMC IF NOT VARIABLE LENGTH\n&FORMAT  SETA  &FORMAT+4*16       SET VARIABLE LENGTH BIT\n         AGO   .RECFMK            LOOP OVER RECFM\n.RECFMC  AIF   ('&C' NE 'U').RECFMD IF NOT UNDEFINED LENGTH\n&FORMAT  SETA  &FORMAT+12*16      SET UNDEFINED BITS\n         AGO   .RECFMK            LOOP OVER RECFM\n.RECFMD  AIF   ('&C' NE 'B').RECFME IF NOT BLOCKED\n&FORMAT  SETA  &FORMAT+16         SET BLOCKED FILE BIT\n         AGO   .RECFMK\n.RECFME  AIF   ('&C' NE 'S').RECFMF IF NOT STANDARD LENGTH\n&FORMAT  SETA  &FORMAT+8          SET STANDARD BIT\n         AGO   .RECFMK\n.RECFMF  AIF   ('&C' NE 'A').RECFMM IF NOT ASA CONTROL CHAR\n&FORMAT  SETA  &FORMAT+4\n         AGO   .RECFMK\n.RECFMM  AIF   ('&C' NE 'M').RECFMZ IF NOT MACHINE CODE\n&FORMAT  SETA  &FORMAT+2\n         AGO   .RECFMK\n.RECFMZ  MNOTE 4,'*** UNRECOGNISED OR UNSUPPORTED RECORD FORMAT &C ***'\n.RECFMK  ANOP  ,\n&SCAN    SETA  &SCAN-1\n         AGO   .RECFMA\n.RECFMX  RCPNTU DALRECFM,1,&FORMAT\n.TDEN    AIF   ('&DEN' EQ '').TDSORG\n         SPACE 1\n***********************************************************************\n**       TAPE DENSITY TEXT UNIT   (J. SAVIT, 12/12/80)               **\n***********************************************************************\n         RCPTYPE &DEN             ANALYZE PARAMETER\n         AIF   ('&RCPTYPE' EQ 'N').DENB NUMERIC DCB\n         MNOTE 4,'*** DENSITY MUST BE 0,1,2,3 OR 4, LIKE IN JCL ***'\n         MNOTE *,'*** DEN IGNORED ***'\n         AGO   .TDSORG\n.DENB    ANOP  ,\n&DENVAL  SETA  0                  CLEAR DENSITY BYTE COUNTER\n         AIF   ('&DEN' EQ '0').DEN0 DENSITY 0?\n         AIF   ('&DEN' EQ '1').DEN1 DENSITY 1?\n         AIF   ('&DEN' EQ '2').DEN2 DENSITY 2?\n         AIF   ('&DEN' EQ '3').DEN3 DENSITY 3?\n         AIF   ('&DEN' EQ '4').DEN3 DENSITY 4?\n         MNOTE 4,'*** INVALID DENSITY-PARAMETER IGNORED ***'\n         AGO   .TDSORG            TRY NEXT PARAMETER INSTEAD\n.DEN4    ANOP  ,\n&DENVAL  SETA  16\n.DEN3    ANOP  ,\n&DENVAL  SETA  &DENVAL+64\n.DEN2    ANOP  ,\n&DENVAL  SETA  &DENVAL+64\n.DEN1    ANOP  ,\n&DENVAL  SETA  &DENVAL+64\n.DEN0    ANOP  ,\n&DENVAL  SETA  &DENVAL+03\n         RCPNTU DALDEN,1,&DENVAL\n.TDSORG  AIF   ('&DSORG' EQ '').EXIT\n         SPACE 1\n***********************************************************************\n**       DSORG TEXT UNIT          (J. SAVIT, 12/12/80)               **\n***********************************************************************\n         AIF   ('&DSORG' EQ 'PO').DSORGPO\n         AIF   ('&DSORG' EQ 'PS').DSORGPS\n         AIF   ('&DSORG' EQ 'DA').DSORGDA\n         MNOTE 8,'*** UNSUPPORTED DSORG &DSORG ***'\n         MEXIT\n.DSORGPO ANOP  ,\n&DSOVAL  SETA  2*16*16\n         AGO   .DSORGX\n.DSORGPS ANOP  ,\n&DSOVAL  SETA  4*16*16*16\n         AGO   .DSORGX\n.DSORGDA ANOP  ,\n&DSOVAL  SETA  2*16*16*16\n.DSORGX  RCPNTU DALDSORG,2,&DSOVAL\n.EXIT    MEND\n         MACRO\n         RCPDDN &DDN\n         GBLC  &DYNP\n         SPACE 1\n***********************************************************************\n**   BUILD THE DDNAME TEXT UNIT                                      **\n***********************************************************************\n         AIF   ('&DDN'(K'&DDN,1) EQ '/').BTU\n         AIF   ('&DDN'(1,1) EQ '''').Q\n         RCPSR2\n         AIF   ('&DDN'(1,1) EQ '(').R\n         L     R14,&DDN                LOAD ADDRESS OF DDNAME\n         LH    R2,&DDN+4               LOAD LENGTH OF DDNAME\n         AGO   .STH\n.R       L     R14,0&DDN               LOAD ADDRESS OF DDNAME\n         LH    R2,4&DDN                LOAD LENGTH OF DDNAME\n.STH     STH   R2,S99TULNG             STORE DDNAME LENGTH\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE DDNAME\n         MVI   S99TUKEY+1,DALDDNAM     MOVE IN DDNAME KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         RCPDINC 14\n         MEXIT\n.Q       RCPBTU DALDDNAM,1,&DDN\n         MEXIT\n.BTU     RCPTUBFR DALDDNAM,14,&DDN\n         MEND\n         MACRO\n         RCPDDNRT\n         SPACE 1\n***********************************************************************\n**    DDNAME RETURN TEXT UNIT                                        **\n***********************************************************************\n         MVI   S99TUKEY+1,DALRTDDN     SET RETURN DDNAME KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         MVI   S99TULNG+1,8            SET LENGTH FIELD\n         MVC   S99TUPAR(8),=CL8' '     INITIALIZE FIELD TO BLANKS\n         RCPDINC 14\n         MEND\n         MACRO\n         RCPDINC &L1\n         GBLA  &DTUO,&DTUPO\n         GBLC  &DYNP\n         AIF   ('&L1' EQ '').T2\n         ST    R15,&DYNP.TUP+&DTUPO    STORE TEXT UNIT ADDRESS\n         LA    R15,&L1.(R15)           BUMP TEXT UNIT PTR TO NEXT SLOT\n&DTUPO   SETA  &DTUPO+4\n&DTUO    SETA  &DTUO+&L1\n         MEXIT\n.T2      ST    R14,&DYNP.TUP+&DTUPO    STORE TEXT UNIT ADDRESS\n&DTUPO   SETA  &DTUPO+4\n         MEND\n         MACRO\n         RCPDISP &DISP\n         LCLA  &I\n         LCLB  &B(4)\n         AIF   ('&DISP(1)' EQ '').TD2\n         SPACE\n***********************************************************************\n**     DATA SET INITIAL STATUS                                       **\n***********************************************************************\n&B(1)    SETB  ('&DISP(1)' EQ 'SHR')\n&B(2)    SETB  ('&DISP(1)' EQ 'NEW')\n&B(3)    SETB  ('&DISP(1)' EQ 'MOD')\n&B(4)    SETB  ('&DISP(1)' EQ 'OLD')\n         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK1\n         MNOTE 8,'&DISP(1) IS INVALID, DISP=SHR USED'\n&B(1)    SETB  1\n.OK1     ANOP\n&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)\n         MVC   S99TUKEY(8),=Y(DALSTATS,1,1,X'0&I.00')\n         RCPDINC 8\n.TD2     AIF   ('&DISP(2)' EQ '').TD3\n         SPACE\n***********************************************************************\n**    DATA SET NORMAL DISPOSITION                                    **\n***********************************************************************\n&B(1)    SETB  ('&DISP(2)' EQ 'KEEP')\n&B(2)    SETB  ('&DISP(2)' EQ 'DELETE')\n&B(3)    SETB  ('&DISP(2)' EQ 'CATLG')\n&B(4)    SETB  ('&DISP(2)' EQ 'UNCATLG')\n         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK2\n         MNOTE 8,'&DISP(2) IS INVALID, DISP=(,KEEP) USED'\n&B(1)    SETB  1\n.OK2     ANOP\n&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)\n         MVC   S99TUKEY(8),=Y(DALNDISP,1,1,X'0&I.00')\n         RCPDINC 8\n.TD3     AIF   ('&DISP(3)' EQ '').EXIT\n         SPACE\n***********************************************************************\n**   DATASET CONDITIONAL DISPOSITION                                 **\n***********************************************************************\n&B(1)    SETB  ('&DISP(3)' EQ 'KEEP')\n&B(2)    SETB  ('&DISP(3)' EQ 'DELETE')\n&B(3)    SETB  ('&DISP(3)' EQ 'CATLG')\n&B(4)    SETB  ('&DISP(3)' EQ 'UNCATLG')\n         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK3\n         MNOTE 8,'&DISP(3) IS INVALID, DISP=(,,KEEP) USED'\n&B(1)    SETB  1\n.OK3     ANOP\n&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)\n         MVC   S99TUKEY(8),=Y(DALCDISP,1,1,X'0&I.00')\n         RCPDINC 8\n.EXIT    MEND\n         MACRO\n         RCPDSN &DSN,&MEM\n         LCLC  &MEMBER\n         GBLC  &DYNP\n         SPACE\n***********************************************************************\n**   BUILD THE DSNAME TEXT UNIT                                      **\n***********************************************************************\n         AIF   ('&DSN'(1,1) EQ '''').Q\n         AIF   ('&DSN'(K'&DSN,1) EQ '/').BD\n         AIF   ('&DSN'(1,1) EQ '(').REG\n         AIF   ('&DSN'  EQ '*').TERM\n         RCPSR2\n         L     R14,&DSN                LOAD ADDRESS OF DSNAME\n         LH    R2,&DSN+4               LOAD LENGTH OF DSNAME\n.STH     STH   R2,S99TULNG             STORE DSNAME LENGTH\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE DSNAME\n         MVI   S99TUKEY+1,DALDSNAM     MOVE IN DSNAME KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         RCPDINC 50\n         AGO   .TMEMBER\n.REG     L     R14,0&DSN               LOAD ADDRESS OF DSNAME\n         RCPSR2\n         LH    R2,4&DSN                LOAD LENGTH OF DSNAME\n         AGO   .STH\n.TERM    MVI   S99TUKEY+1,DALTERM\n         RCPDINC 4\n         MEXIT\n.BD      RCPTUBFR DALDSNAM,50,&DSN\n         AGO   .TMEMBER\n.Q       RCPBTU DALDSNAM,1,&DSN\n.TMEMBER AIF   ('&MEM' EQ '').EXIT\n         SPACE\n***********************************************************************\n**   BUILD THE MEMBER NAME TEXT UNIT                                 **\n***********************************************************************\n&MEMBER  SETC  '&MEM'\n         AIF   ('&MEM' NE '*').MOK\n         AIF   ('&DSN'(1,1) NE '''').MAST\n         MNOTE 8,'MEMBER=* INVALID WITH QUOTED DSNAME'\n         MEXIT\n.MAST    ANOP\n&MEMBER  SETC  '8+&DSN'\n.MOK     ANOP\n         AIF   ('&MEMBER'(K'&MEMBER,1) EQ '/').BM\n         RCPSR2\n         AIF   ('&MEMBER'(1,1) EQ '(').RM\n         LH    R2,4+&MEMBER            LOAD LENGTH OF MEMBER NAME\n         LTR   R2,R2                   TEST FOR ZERO\n         BZ    *+30                    IF NO MEMBER, SKIP\n         L     R14,&MEMBER             LOAD ADDRESS OF MEMBER\n         AGO   .STHM\n.RM      LH    R2,4&MEMBER             LOAD LENGTH OF MEMBER\n         LTR   R2,R2                   AND TEST FOR ZERO\n         BZ    *+30                    IF NO MEMBER, SKIP\n         L     R14,0&MEMBER            LOAD ADDRESS OF MEMBER\n.STHM    STH   R2,S99TULNG             STORE LENGTH OF MEMBER\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE IN MEMBER NAME\n         MVI   S99TUKEY+1,DALMEMBR     MOVE IN MEMBER KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         RCPDINC 14\n         MEXIT\n.BM      RCPTUBFR DALMEMBR,14,&MEMBER\n         MEXIT\n.QM      RCPBTU DALMEMBR,1,&MEMBER\n.EXIT    MEND\n         MACRO\n         RCPFDDN &DDN\n         GBLC &DYNP\n         SPACE\n***********************************************************************\n**        FREE DDNAME TEXT UNIT                                      **\n***********************************************************************\n         AIF   ('&DDN'(1,1) EQ '''').Q\n         AIF   ('&DDN'(K'&DDN,1) EQ '/').B\n         RCPSR2\n         AIF   ('&DDN'(1,1) EQ '(').R\n         L     R14,&DDN                LOAD ADDRESS OF DDNAME\n         LH    R2,&DDN+4               LOAD LENGTH OF DDNAME\n         AGO   .STH\n.R       L     R14,0&DDN               LOAD ADDRESS OF DDNAME\n         LH    R2,4&DDN                LOAD LENGTH OF DDNAME\n.STH     STH   R2,S99TULNG             STORE DDNAME LENGTH\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE DDNAME\n         MVI   S99TUKEY+1,DUNDDNAM     MOVE IN DDNAME KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         RCPDINC 14\n         MEXIT\n.Q       RCPBTU DUNDDNAM,1,&DDN\n         MEXIT\n.B       RCPTUBFR DUNDDNAM,14,&DDN\n         MEND\n         MACRO\n         RCPFDSN &DSN,&MEM\n         LCLC  &MEMBER\n         GBLC  &DYNP\n         SPACE\n***********************************************************************\n**      FREE DATA SET TEXT UNIT                                      **\n***********************************************************************\n         AIF   ('&DSN'(1,1) EQ '''').Q\n         AIF   ('&DSN'(K'&DSN,1) EQ '/').BD\n         AIF   ('&DSN'(1,1) EQ '(').REG\n         RCPSR2\n         L     R14,&DSN                LOAD ADDRESS OF DSNAME\n         LH    R2,&DSN+4               LOAD LENGTH OF DSNAME\n.STH     STH   R2,S99TULNG             STORE DSNAME LENGTH\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE DSNAME\n         MVI   S99TUKEY+1,DUNDSNAM     MOVE IN DSNAME KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         RCPDINC 50\n         AGO   .TMEMBER\n.REG     L     R14,0&DSN               LOAD ADDRESS OF DSNAME\n         RCPSR2\n         LH    R2,4&DSN                LOAD LENGTH OF DSNAME\n         AGO   .STH\n.BD      RCPTUBFR DUNDSNAM,50,&DSN\n         AGO   .TMEMBER\n.Q       RCPBTU DUNDSNAM,1,&DSN\n.TMEMBER AIF   ('&MEM' EQ '').EXIT\n         SPACE\n***********************************************************************\n**       FREE MEMBER NAME TEXT UNIT                                  **\n***********************************************************************\n&MEMBER  SETC  '&MEM'\n         AIF   ('&MEM' NE '*').MOK\n         AIF   ('&DSN'(1,1) NE '''').MAST\n         MNOTE 8,'MEMBER=* INVALID WITH QUOTED DSNAME'\n         MEXIT\n.MAST    ANOP\n&MEMBER  SETC  '8+&DSN'\n.MOK     ANOP\n         AIF   ('&MEMBER'(K'&MEMBER,1) EQ '/').BM\n         RCPSR2\n         AIF   ('&MEMBER'(1,1) EQ '(').RM\n         LH    R2,4+&MEMBER            LOAD LENGTH OF MEMBER NAME\n         LTR   R2,R2                   TEST FOR ZERO\n         BZ    *+30                    IF NO MEMBER, SKIP\n         L     R14,&MEMBER             LOAD ADDRESS OF MEMBER\n         AGO   .STHM\n.RM      LH    R2,4&MEMBER             LOAD LENGTH OF MEMBER\n         LTR   R2,R2                   AND TEST FOR ZERO\n         BZ    *+30                    IF NO MEMBER, SKIP\n         L     R14,0&MEMBER            LOAD ADDRESS OF MEMBER\n.STHM    STH   R2,S99TULNG             STORE LENGTH OF MEMBER\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE IN MEMBER NAME\n         MVI   S99TUKEY+1,DUNMEMBR     MOVE IN MEMBER KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         RCPDINC 14\n         MEXIT\n.BM      RCPTUBFR DUNMEMBR,14,&MEMBER\n         MEXIT\n.QM      RCPBTU DUNMEMBR,1,&MEMBER\n.EXIT    MEND\n         MACRO\n         RCPFREE &FREE\n         SPACE\n***********************************************************************\n**      UNALLOC AT CLOSE TEXT UNIT                                   **\n***********************************************************************\n         MVI   S99TUKEY+1,DALCLOSE     MOVE IN CLOSE TEXT UNIT KEY\n         RCPDINC 4\n         MEND\n         MACRO\n         RCPNTU &KEY,&LEN,&PAR\n.*\n.*     THIS IS AN ALLOC/FREE MACRO TEXT UNIT PROCESSOR SUBROUTINE\n.*     MACRO. IT BUILDS NUMERIC TYPE TEXT UNITS.\n.*\n         LCLA  &L,&R\n         LCLC  &C\n         GBLC  &RCPTYPE\n.*  ALLOC/FREE INNER MACRO TO SET UP NUMERIC TEXT UNITS\n&L       SETA  1                       DEFAULT LENGTH\n         AIF   ('&LEN' EQ '').NL\n&L       SETA  &LEN\n.NL      MVI   S99TUKEY+1,&KEY         SET KEY FIELD\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         MVI   S99TULNG+1,&L           SET LENGTH FIELD\n         AIF   ('&PAR'(1,1) EQ '(').REG\n         RCPTYPE &PAR                  ANALYSE PARAMETER\n         AIF   ('&RCPTYPE' EQ 'N').NUMERIC\n&R       SETA  4-&L\n         MVC   S99TUPAR(&L),&R+&PAR    MOVE IN QUANTITY\n         RCPDINC 10\n         MEXIT\n.NUMERIC AIF   (&L EQ 1).NL1\n         MVC   S99TUPAR(&L.),=AL&L.(&PAR) MOVE IN QUANTITY\n&R       SETA  &L+6\n         AIF   (&R/2 EQ (&R+1)/2).LOK ENSURE LENGTH EVEN\n&R       SETA  &R+1\n.LOK     RCPDINC &R\n         MEXIT\n.NL1     MVI   S99TUPAR,&PAR           MOVE IN QUANTITY\n         RCPDINC 8\n         MEXIT\n.REG     ANOP\n&R       SETA  &L+6\n         AIF   (&R/2 EQ (&R+1)/2).LOK ENSURE LENGTH EVEN\n&R       SETA  &R+1\n&C       SETC  '&PAR'(2,K'&PAR-2)\n         AIF   (&L EQ 3).STCM\n         AIF   (&L EQ 2).STH\n         AIF   (&L EQ 1).STC\n         ST    &C,S99TUPAR             STORE TEXT UNIT QUANTITY\n         AGO   .RCPDINC\n.STH     STH   &C,S99TUPAR             STORE TEXT UNIT QUANTITY\n         AGO   .RCPDINC\n.STC     STC   &C,S99TUPAR             STORE TEXT UNIT QUANTITY\n         AGO   .RCPDINC\n.STCM    STCM  &C,7,S99TUPAR           STORE TEXT UNIT QUANTITY\n.RCPDINC RCPDINC &R\n         MEND\n         MACRO\n         RCPOINC &L1\n         GBLA  &ODTUO,&ODTUPO\n         GBLC  &ODYNP\n         AIF   ('&L1' EQ '').T2\n         ST    R15,&ODYNP.TUP+&ODTUPO    STORE TEXT UNIT ADDRESS\n         LA    R15,&L1.(R15)           BUMP TEXT UNIT PTR TO NEXT SLOT\n&ODTUPO  SETA  &ODTUPO+4\n&ODTUO   SETA  &ODTUO+&L1\n         MEXIT\n.T2      ST    R14,&ODYNP.TUP+&ODTUPO    STORE TEXT UNIT ADDRESS\n&ODTUPO  SETA  &ODTUPO+4\n         MEND\n         MACRO\n         RCPOUTA &OUTPUT=\n         GBLC  &DYNSP\n         GBLA  &DYNSPQ,&DTUO,&DTUPO\n         LCLC  &C\n         AIF   ('&OUTPUT' NE '').OUTDD\n         AGO   .EXIT\n.OUTDD   ANOP\n***********************************************************************\n**       OUTPUT DDNAME TEXT UNIT                                     **\n***********************************************************************\n         L     R4,&OUTPUT\n         LA    R4,2(R4)\n         OUTADD NAME=(R4),TEXTPTR=(R3),MF=(E,O&DYNSP.O)\n.EXIT    MEND\n         MACRO\n         RCPOUTD &OUTPUT\n         AIF   ('&OUTPUT' NE '').OUTDD\n         MNOTE 8,' **** OUTPUT=&OUTPUT INVALID, MUST BE DDNAME'\n         AGO   .EXIT\n.OUTDD   ANOP\n         LA     R4,=C'&OUTPUT'\n         OUTDEL NAME=(R4)\n.EXIT    MEND\n         MACRO\n         RCPRECFM &RECFM=\n.*\n         LCLC  &R                 REG NOTATION\n         LCLA  &SCAN              FOR SCANNING RECORD FORMAT CHARS\n         LCLC  &FORMAT            ENCODED RECORD FORMAT BYTE\n         LCLC  &A,&A1,&A2,&A3,&A4,&S\n         LCLC  &B\n&R       SETC  '&RECFM'\n&S       SETC  'S0&SYSNDX'\n&A       SETC  'A0&SYSNDX'\n&A1      SETC  'A1&SYSNDX'\n&A2      SETC  'A2&SYSNDX'\n&A3      SETC  'A3&SYSNDX'\n&A4      SETC  'A4&SYSNDX'\n&A5      SETC  'A5&SYSNDX'\n&A6      SETC  'A6&SYSNDX'\n&B       SETC  'B0&SYSNDX'\n&FORMAT  SETC  'RF&SYSNDX'\n         B     &S\n         DS    0F\n&FORMAT  DC    X'00'\n&S       DS    0H\n         XC    &FORMAT,&FORMAT\n         LH    R14,0&R\n         LA    R2,2&R\n&A       DS    0H\n         CLI   0(R2),C'F'\n         BNE   &A1                CHECK FOR NEXT ATTR\n         OI    &FORMAT,X'80'      SET FIXED LENGTH BIT\n         B     &B                 SET FOR NEXT ATTR\n&A1      DS    0H\n         CLI   0(R2),C'V'\n         BNE   &A2\n         OI    &FORMAT,X'40'      SET VARIABLE LENGTH BIT\n         B     &B                 SET FOR NEXT ATTR\n&A2      DS    0H\n         CLI   0(R2),C'U'\n         BNE   &A3\n         OI    &FORMAT,X'C0'      SET UNDEFINED BITS\n         B     &B                 SET FOR NEXT ATTR\n&A3      DS    0H\n         CLI   0(R2),C'B'\n         BNE   &A4\n         OI    &FORMAT,X'10'      SET BLOCKED   BITS\n         B     &B                 SET FOR NEXT ATTR\n&A4      DS    0H\n         CLI   0(R2),C'A'\n         BNE   &A5\n         OI    &FORMAT,X'04'      SET ASA       BITS\n         B     &B                 SET FOR NEXT ATTR\n&A5      DS    0H\n         CLI   0(R2),C'M'\n         BNE   &A6\n         OI    &FORMAT,X'02'      SET MACHINE CODE  BITS\n         B     &B                 SET FOR NEXT ATTR\n&A6      DS    0H\n         CLI   0(R2),C'S'\n         BNE   &B\n         OI    &FORMAT,X'08'      SET SPANNED       BITS\n&B       DS    0H\n         LA    R2,1(R2)           INCREMENT TO NEXT ATTR\n         BCT   R14,&A             NEXT RECFM ATTR\n         SR    R2,R2\n         IC    R2,&FORMAT\n         RCPNTU DALRECFM,1,(R2)\n         MEND\n         MACRO\n         RCPSPACE &SPACE\n         GBLA  &RCPSUB#                NO OF SUBLIST ELEMENTS\n         GBLC  &RCPSUBL(100)           SUBLIST ELEMENTS\n.**********************************************************************\n.*    THIS IS AN ALLOC INNER MACRO TO BUILD THE ALLOCATION SPACE\n.*    QUANTITY TEXT UNIT. IT SHOULD BE SPECIFIED AS:-\n.*     SPACE=(TYPE,(PRIMARY,SECONDARY,DIRECTORY),RLSE,CONTIG,ROUND)\n.*   WHERE TYPE IS 'TRK', 'CYL', 'ABSTR' OR A BLOCK QUANTITY\n.*     'CYL' OR 'TRK' SHOULD NOT BE ENTERED IN QUOTES. THE BLOCK\n.*     QUANTITY CAN BE A NUMBER, A REGISTER (IN BRACKETS), OR THE\n.*     NAME OF A FULLWORD CONTAINING THE BLOCK SIZE.\n.**********************************************************************\n         AIF   ('&SPACE(1)' EQ '' OR '&SPACE(1)' EQ 'TRK').TRK\n         AIF   ('&SPACE(1)' EQ 'CYL').CYL\n***********************************************************************\n**        SPACE UNIT IN BLOCKS                                       **\n***********************************************************************\n         RCPNTU DALBLKLN,3,&SPACE(1)  GENERATE BLOCK UNIT TU\n         AGO   .TPRIME        GO TEST PRIME QUANTITY\n.TRK     ANOP  TRACK SPEC REQ OR DEFAULTED\n         SPACE\n***********************************************************************\n**       SPACE QUANTITY IN TRACKS                                    **\n***********************************************************************\n         MVI   S99TUKEY+1,DALTRK       SET TEXT UNIT KEY\n         RCPDINC 4\n         AGO   .TPRIME\n.CYL     ANOP  CYL QUANTITY\n         SPACE 1\n***********************************************************************\n**      SPACE UNIT IN CYLINDERS                                      **\n***********************************************************************\n         MVI   S99TUKEY+1,DALCYL       SET TEXT UNIT KEY\n         RCPDINC 4                     STORE TEXT UNIT ADDR\n.TPRIME  RCPSUBL &SPACE(2)             BREAK UP SUBLIST\n         AIF   (&RCPSUB# EQ 0).TCONTIG\n         AIF   ('&RCPSUBL(1)' EQ '').TSP2\n         SPACE\n***********************************************************************\n**       PRIMARY SPACE QUANTITY                                      **\n***********************************************************************\n         RCPNTU DALPRIME,3,&RCPSUBL(1)\n.TSP2    AIF   (&RCPSUB# LT 2).TCONTIG\n         AIF   ('&RCPSUBL(2)' EQ '').TSP3\n         SPACE\n***********************************************************************\n**       SECONDARY SPACE QUANTITY                                    **\n***********************************************************************\n         RCPNTU DALSECND,3,&RCPSUBL(2)\n.TSP3    AIF   (&RCPSUB# LT 3).TCONTIG\n         AIF   ('&RCPSUBL(3)' EQ '').TCONTIG\n         SPACE\n***********************************************************************\n**       DIRECTORY BLOCK QUANTITY                                    **\n***********************************************************************\n         RCPNTU DALDIR,3,&RCPSUBL(3)\n.TCONTIG AIF  ('&SPACE(3)' EQ 'CONTIG' OR '&SPACE(4)' EQ 'CONTIG').CON\n         AIF   ('&SPACE(3)' EQ 'MXIG' OR '&SPACE(4)' EQ 'MXIG').MXIG\n         AIF   ('&SPACE(3)' EQ 'ALX' OR '&SPACE(4)' EQ 'ALX').ALX\n.TRLSE   AIF   ('&SPACE(3)' EQ 'RLSE' OR '&SPACE(4)' EQ 'RLSE').RLSE\n.TROUND  AIF   ('&SPACE(4)'EQ'ROUND'OR'&SPACE(5)'EQ'ROUND').ROUND\n         MEXIT\n.CON     ANOP\n***********************************************************************\n**      CONTIGUOUS SPACE TEXT UNIT                                   **\n***********************************************************************\n         RCPNTU DALSPFRM,1,8\n         AGO   .TRLSE\n.MXIG    ANOP\n***********************************************************************\n**       MAXIMUM CONTIGUOUS SPACE TEXT UNIT                          **\n***********************************************************************\n         RCPNTU DALSPFRM,1,4\n         AGO   .TRLSE\n.ALX     ANOP\n***********************************************************************\n**       'ALX' SPACE TEXT UNIT                                       **\n***********************************************************************\n         RCPNTU DALSPFRM,1,2\n         AGO   .TRLSE\n.RLSE    ANOP\n***********************************************************************\n**      RELEASE UNUSED SPACE TEXT UNIT                               **\n***********************************************************************\n         MVI   S99TUKEY+1,DALRLSE      SET TEXT UNIT KEY\n         RCPDINC 4\n         AGO   .TROUND\n.ROUND   ANOP\n***********************************************************************\n**      RELEASE UNUSED SPACE TEXT UNIT                               **\n***********************************************************************\n         MVI   S99TUKEY+1,DALROUND     MOVE IN TEXT UNIT KEY\n         RCPDINC 4\n         MEND\n         MACRO\n         RCPSR2 &A\n         GBLB  &RCPSR2\n         GBLC  &DYNP\n         LCLC  &C\n.*   TO SAVE REG 2 IN REG 0 FOR ALLOC INNER MACROS FIRST TIME ONLY\n.*    IF OPERAND SUPPLIED AND SAVE DONE, RESTORES REG 2 AND\n.*    GENERATES MOVE INSTRUCTION FOR EXECUTE\n         AIF   ('&A' NE '').UNSAVE\n         AIF   (&RCPSR2).EXIT\n&RCPSR2  SETB  1\n         LR    R0,R2                   SAVE CONTENTS OF REGISTER 2\n         MEXIT\n.UNSAVE  AIF   (NOT &RCPSR2).EXIT\n         B     *+10                    SKIP NEXT INSTRUCTION\n&C       SETC  '&DYNP.MVC'\n&C       MVC   S99TUPAR(0),0(R14)      EXECUTED MOVE\n         LR    R2,R0                   RESTORE CONTENTS OF REGISTER 2\n&RCPSR2  SETB  0\n.EXIT    MEND\n         MACRO\n         RCPSTCL &U\n         GBLC  &DYNP\n***********************************************************************\n**       STORCLAS  TEXT UNIT                                         **\n***********************************************************************\n         RCPVCHAR DALSTCL,14,&U\n.EXIT    MEND\n         MACRO - BREAK DOWN A SUBLIST\n         RCPSUBL &L\n         GBLA  &RCPSUB#                NO OF ELEMENTS FOUND\n         GBLC  &RCPSUBL(100)           ELEMENTS\n         LCLA  &I,&J,&K\n&RCPSUB# SETA  0                       INITIALIZE\n         AIF   ('&L' EQ '').EXIT       EXIT IF NULL STRING\n         AIF   ('&L'(1,1) NE '(').NOSUB\n&K       SETA  K'&L-1\n&I       SETA  2\n&J       SETA  1\n.LOOP    ANOP\n&J       SETA  &J+1\n         AIF   (&J  GT &K).LAST\n         AIF   ('&L'(&J,1) NE ',').LOOP\n&RCPSUB# SETA &RCPSUB#+1\n         AIF   (&J EQ &I).NULL\n&RCPSUBL(&RCPSUB#) SETC '&L'(&I,&J-&I)\n&I       SETA  &J+1\n         AGO   .LOOP\n.NULL    ANOP\n&RCPSUBL(&RCPSUB#) SETC ''\n&I       SETA  &J+1\n         AGO   .LOOP\n.LAST    AIF   (&J EQ &I).LASTNUL\n&RCPSUB# SETA  &RCPSUB#+1\n&RCPSUBL(&RCPSUB#) SETC '&L'(&I,&J-&I)\n         AGO   .EXIT\n.LASTNUL ANOP\n&RCPSUB# SETA  &RCPSUB#+1\n&RCPSUBL(&RCPSUB#) SETC ''\n         AGO   .EXIT\n.NOSUB   ANOP\n&RCPSUBL(1) SETC '&L'\n&RCPSUB# SETA 1\n.EXIT    MEND\n         MACRO\n         RCPSUBSY &SUBSYS=,&SUBDDN=,&BUFND=,&BUFNI=,&HBUFND=,          X\n               &HBUFNI=,&DEFERW=,&SHRPOOL=,&BUFSD=,&BUFSI=,&MSG=\n         GBLC  &DYNP\n         LCLC  &C\n         LCLA  &NUM\n         AIF   ('&SUBSYS' NE '').SSNAME\n         MNOTE 8,'SUBSYS NAME FOR LSR NOT SPECIFIED.'\n.SSNAME  ANOP  ,\n***********************************************************************\n**   SUBSYS NAME  TEXT UNIT                                          **\n***********************************************************************\n&NUM     SETA  L'&SUBSYS+6\n         RCPVCHAR SSNM,&NUM,&SUBSYS\n***********************************************************************\n**   SUBSYS DDNAME  TEXT UNIT                                        **\n***********************************************************************\n.TDDN    AIF   ('&SUBDDN' EQ '').TBUFND\n&NUM     SETA  L'&SUBDDN+6\n         RCPVCHAR SSPRM,&NUM,&SUBDDN\n.TBUFND  AIF   ('&BUFND' EQ '').TBUFNI\n***********************************************************************\n**   SUBSYS BUFND   TEXT UNIT                                        **\n***********************************************************************\n&NUM     SETA  L'&BUFND+6\n         RCPVCHAR SSPRM,&NUM,&BUFND\n.TBUFNI  AIF   ('&BUFNI' EQ '').THBUFND\n***********************************************************************\n**   SUBSYS BUFNI   TEXT UNIT                                        **\n***********************************************************************\n&NUM     SETA  L'&BUFNI+6\n         RCPVCHAR SSPRM,&NUM,&BUFNI\n.THBUFND AIF   ('&HBUFND' EQ '').THBUFNI\n***********************************************************************\n**   SUBSYS HBUFND  TEXT UNIT                                        **\n***********************************************************************\n&NUM     SETA  L'&HBUFND+6\n         RCPVCHAR SSPRM,&NUM,&HBUFND\n.THBUFNI AIF   ('&HBUFNI' EQ '').TDEFERW\n***********************************************************************\n**   SUBSYS HBUFNI  TEXT UNIT                                        **\n***********************************************************************\n&NUM     SETA  L'&HBUFNI+6\n         RCPVCHAR SSPRM,&NUM,&HBUFNI\n.TDEFERW AIF   ('&DEFERW' EQ '').TSHRP\n***********************************************************************\n**   SUBSYS DEFERW  TEXT UNIT                                        **\n***********************************************************************\n&NUM     SETA  L'&DEFERW+6\n         RCPVCHAR SSPRM,&NUM,&DEFERW\n.TSHRP   AIF   ('&SHRPOOL' EQ '').TBUFSD\n***********************************************************************\n**   SUBSYS SHRPOOL TEXT UNIT                                        **\n***********************************************************************\n&NUM     SETA  L'&SHRPOOL+6\n         RCPVCHAR SSPRM,&NUM,&SHRPOOL\n.TBUFSD  AIF   ('&BUFSD' EQ '').TBUFSI\n***********************************************************************\n**   SUBSYS BUFSD   TEXT UNIT                                        **\n***********************************************************************\n&NUM     SETA  L'&BUFSD+6\n         RCPVCHAR SSPRM,&NUM,&BUFSD\n.TBUFSI  AIF   ('&BUFSI' EQ '').TMSG\n***********************************************************************\n**   SUBSYS BUFSI   TEXT UNIT                                        **\n***********************************************************************\n&NUM     SETA  L'&BUFSI+6\n         RCPVCHAR SSPRM,&NUM,&BUFSI\n.TMSG    AIF   ('&MSG' EQ '').EXIT\n***********************************************************************\n**   SUBSYS MSG     TEXT UNIT                                        **\n***********************************************************************\n         RCPVCHAR SSPRM,7,&MSG\n.EXIT    MEND\n         MACRO\n         RCPSYSOU &CLASS,&COPIES=,&FREE=,&DEST=,&FORMS=,&UCS=,&FCB=,   C\n               &CHARS=,&FLASH=,&BURST=,&OUTPUT=\n         GBLC  &DYNP\n         LCLC  &C\n         AIF   ('&CLASS(1)' EQ '').TPGN\n&C       SETC  '&CLASS(1)'\n         SPACE\n***********************************************************************\n**       SYSOUT CLASS TEXT UNIT                                      **\n***********************************************************************\n         AIF   ('&C'(1,1) EQ '''').Q\n         AIF   ('&C'(K'&C,1) EQ '/').BS\n         AIF   ('&C'(1,1) EQ '(').REG\n         L     R14,&C                  LOAD ADDRESS OF SYSOUT CLASS\n         MVC   S99TUPAR(1),0(R14)       AND MOVE IT TO TEXT UNIT\n         AGO   .SKEY\n.REG     MVC   S99TUPAR(1),0&C         MOVE SYSOUT CLASS TO TEXT UNIT\n.SKEY    MVI   S99TUKEY+1,DALSYSOU     SET SYSOUT KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         MVI   S99TULNG+1,1            SET LENGTH FIELD\n         RCPDINC 8\n         AGO   .TPGN\n.BS      RCPTUBFR DALSYSOU,14,&C\n         AGO   .TPGN\n.Q       RCPBTU DALSYSOU,1,&C\n.TPGN    AIF   ('&CLASS(2)' EQ '').TCOP\n         SPACE\n***********************************************************************\n**   SYSOUT PROGRAM NAME TEXT UNIT                                   **\n***********************************************************************\n&C       SETC  '&CLASS(2)'\n         RCPVCHAR DALSPGNM,14,&C\n.TCOP    AIF   ('&COPIES' EQ '').TFREE\n         SPACE\n***********************************************************************\n**    SYSOUT COPIES TEXT UNIT                                        **\n***********************************************************************\n         RCPNTU DALCOPYS,1,&COPIES\n.TFREE   AIF   ('&FREE' EQ '').TDEST\n         SPACE\n***********************************************************************\n**     FREE = CLOSE TEXT UNIT                                        **\n***********************************************************************\n         AIF   ('&FREE' EQ 'CLOSE').CLOSEOK\n         MNOTE 4,' **** FREE=&FREE INVALID, FREE=CLOSE USED'\n.CLOSEOK MVI   S99TUKEY+1,DALCLOSE   MOVE IN TEXT UNIT KEY\n         RCPDINC 4\n.TDEST   AIF   ('&DEST' EQ '').TFCB\n         SPACE\n***********************************************************************\n**       SYSOUT DESTINATION TEXT UNIT                                **\n***********************************************************************\n&NUM     SETA L'&DEST+6\n         RCPVCHAR SUSER,&NUM,&DEST\n.TFCB    AIF   ('&FCB' EQ '').TCHARS\n         SPACE\n***********************************************************************\n**       SYSOUT FCB IMAGE   TEXT UNIT                                **\n***********************************************************************\n         RCPVCHAR FCBIM,10,&FCB\n.TCHARS  AIF   ('&CHARS' EQ '').TFORMS\n         SPACE\n***********************************************************************\n**       SYSOUT CHAR SET    TEXT UNIT                                **\n***********************************************************************\n         RCPVCHAR CHARS,10,&CHARS\n.TFORMS  AIF   ('&FORMS' EQ '').TUCS\n         SPACE\n***********************************************************************\n**     SYSOUT FORMS NUMBER TEXT UNIT                                 **\n***********************************************************************\n         RCPVCHAR SFMNO,10,&FORMS\n.TUCS    AIF   ('&UCS' EQ '').TFLASH\n         SPACE\n***********************************************************************\n**     SYSOUT UCS NAME TEXT UNIT                                     **\n***********************************************************************\n         RCPVCHAR UCS,9,&UCS\n.TFLASH  AIF   ('&FLASH' EQ '').TBURST\n         SPACE\n***********************************************************************\n**     SYSOUT FLASH FORM TEXT UNIT                                   **\n***********************************************************************\n&NUM     SETA L'&FLASH+6\n         RCPVCHAR FFORM,&NUM,&FLASH\n.TBURST  AIF   ('&BURST' EQ '').TOUTP\n         SPACE\n***********************************************************************\n**     SYSOUT BURSTER/STACKER TEXT UNIT                              **\n***********************************************************************\n&NUM     SETA L'&BURST+6\n         RCPVCHAR BURST,&NUM,&BURST\n.TOUTP   AIF   ('&OUTPUT' EQ '').EXIT\n         SPACE\n***********************************************************************\n**     SYSOUT OUTPUT STMT TEXT UNIT                                  **\n***********************************************************************\n&NUM     SETA L'&OUTPUT+6\n         RCPVCHAR OUTPT,&NUM,&OUTPUT\n.EXIT    MEND\n         MACRO\n         RCPTYPE &T\n         GBLC  &RCPTYPE\n         LCLA  &I,&K\n&K       SETA  K'&T\n&RCPTYPE SETC  ''\n         AIF   (&K EQ 0).EXIT\n&RCPTYPE SETC  'C'\n.LOOP    ANOP\n&I       SETA  &I+1\n         AIF   ('&T'(&I,1) LT '0' OR '&T'(&I,1) GT '9').EXIT\n         AIF   (&I LT &K).LOOP\n&RCPTYPE SETC  'N'\n.EXIT    MEND\n         MACRO\n         RCPUNALC\n         SPACE 1\n***********************************************************************\n**     FREE EVEN IF PERMANENTLY ALLOCATED                            **\n***********************************************************************\n         MVI   S99TUKEY+1,DUNUNALC     SET TEXT UNIT KEY\n         RCPDINC  4\n         MEND\n         MACRO\n         RCPUNIT &U,&V,&VC\n         GBLC  &DYNP\n         AIF   ('&U' EQ '').TVOL\n         SPACE 1\n***********************************************************************\n**       UNIT NAME TEXT UNIT                                         **\n***********************************************************************\n         RCPVCHAR DALUNIT,14,&U\n.TVOL    AIF   ('&V' EQ '').TVC\n         SPACE 1\n***********************************************************************\n**       VOLUME SERIAL TEXT UNIT                                     **\n***********************************************************************\n         RCPVCHAR DALVLSER,14,&V\n.TVC     AIF   ('&VC' EQ '').EXIT\n***********************************************************************\n**       VOLUME COUNT  TEXT UNIT                                     **\n***********************************************************************\n         RCPNTU DALVLCNT,1,&VC\n.EXIT    MEND\n         MACRO\n         RCPVCHAR &KEY,&LEN,&C,&N=1\n         GBLC  &DYNP\n         AIF   ('&C'(K'&C,1) EQ '/').BM\n         AIF   ('&C'(1,1) EQ '''').QM\n         RCPSR2\n         AIF   ('&C'(1,1) EQ '(').RM\n         LH    R2,&C+4                 LOAD LENGTH OF TEXT UNIT\n         LTR   R2,R2                   TEST FOR ZERO\n         BZ    *+30                    IF NO TEXT UNIT, SKIP\n         L     R14,&C                  LOAD ADDRESS OF TEXT UNIT\n         AGO   .STHM\n.RM      LH    R2,4&C                  LOAD LENGTH OF TEXT UNIT\n         LTR   R2,R2                   AND TEST FOR ZERO\n         BZ    *+30                    IF NO TEXT UNIT, SKIP\n         L     R14,0&C                 LOAD ADDRESS OF TEXT UNIT\n.STHM    STH   R2,S99TULNG             STORE LENGTH OF TEXT UNIT\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE IN TEXT UNIT\n         AIF   ('&KEY'(4,4) EQ 'STCL').STCL\n         MVI   S99TUKEY+1,&KEY         MOVE IN TEXT UNIT KEY\n         AGO   .UN\n.STCL    MVC   S99TUKEY,DALSTCL        MOVE IN STORCLAS TEXT UNIT KEY\n.UN      AIF   ('&N' EQ '1' OR '&N' EQ '').N1\n         LA    R14,&N                  LOAD TEXT UNIT NUMBER\n         STH   R14,S99TUNUM             AND STORE IT IN TEXT UNIT\n         AGO   .ENDN\n.N1      MVI   S99TUNUM+1,1            SET NUMBER FIELD\n.ENDN    RCPDINC &LEN\n         MEXIT\n.BM      RCPTUBFR &KEY,&LEN,&C\n         MEXIT\n.QM      RCPBTU &KEY,&N,&C\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MORE": {"ttr": 28932, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\x97\\x00\\x97\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 151, "newlines": 151, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- UNEXCLUDE LINES BEFORE/AFTER SHOWN LINE  **/\n   ADDRESS \"ISREDIT\"\n   \"MACRO (PARMS) NOPROCESS\"\n\n   AFTER  = 1\n   BEFORE = 1\n   LABF   = \"\"\n   LABL   = \"\"\n   FIRST  = -1\n\n   PARMS = TRANSLATE(PARMS)\n   IF PARMS = '?' THEN SIGNAL DISPDOC\n   DO II = 1 TO 10;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,6) = \"AFTER(\" THEN DO;\n         PARSE VAR TOKEN  \"AFTER(\" AFTER \")\" RIGHT\n         ITERATE II;\n      END\n      IF \"BEFORE(\" = SUBSTR(TOKEN,1,7)  THEN DO;\n         PARSE VAR TOKEN  \"BEFORE(\" BEFORE \")\" RIGHT\n         ITERATE II;\n      END\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LABF = \"\" THEN LABF = TOKEN\n         ELSE IF LABL = \"\" THEN LABL = TOKEN\n         ELSE DO\n            ZEDSMSG = \".LABEL RC=8\"\n            ZEDLMSG = \"TOO MANY LABELS --\" LABF LABL TOKEN\n            ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n            EXIT 8\n         END\n      END\n   END II\n   IF LABF <> \"\"  &  LABL = \"\"  THEN LABL = LABF\n\n   IF LABL = \"\" THEN DO\n      \"PROCESS RANGE C\"\n      IF RC = 0 THEN DO\n         LABF = \".ZFRANGE\"\n         LABL = \".ZLRANGE\"\n      END\n      ELSE DO\n         LABF = \".ZFIRST\"\n         LABL = \".ZLAST\"\n      END\n   END\n\n   \"(LABFNO) = LINENUM\" LABF\n   \"(LABLNO) = LINENUM\" LABL\n\n   DO II = LABFNO TO LABLNO\n      \"(LINESTAT) = XSTATUS\" II\n      IF LINESTAT = \"X\" THEN DO\n         RR = -1\n         DO JJ = (II) TO (II+BEFORE-1)\n            \"(LINESTAT) = XSTATUS\" JJ\n            IF LINESTAT = \"X\" THEN DO\n               \"XSTATUS\" JJ \"= NX\";\n               IF FIRST = -1 THEN FIRST = JJ\n            END\n            ELSE DO\n               RR = JJ\n               JJ = II + BEFORE\n            END\n         END\n         IF RR <> -1 THEN DO\n            II = RR\n         END\n         ELSE DO\n            RR = -1\n            DO KK = JJ TO LABLNO\n               \"(LINESTAT) = XSTATUS\" KK\n               IF LINESTAT = \"NX\" THEN DO\n                  RR = KK\n                  KK = LABLNO + 1\n               END\n            END\n            IF RR <> -1 THEN II = RR\n                        ELSE II = LABLNO + 1\n         END\n      END\n   END\n\n   DO II = LABFNO TO LABLNO\n      \"(LINESTAT) = XSTATUS\" II\n      IF LINESTAT = \"X\" THEN DO\n         RR = -1\n         DO JJ = (II+1) TO LABLNO\n            \"(LINESTAT) = XSTATUS\" JJ\n            IF LINESTAT = \"NX\" THEN DO\n               RR = JJ\n               IF (JJ-II) >= AFTER THEN DO\n                  DO KK = (JJ-1) TO (JJ-AFTER) BY -1\n                     \"XSTATUS\" KK \"= NX\";\n                  END\n                  JJ = LABLNO + 1\n               END\n            END\n         END\n         IF RR = -1 THEN DO\n            IF (JJ-II) >= AFTER THEN DO\n               DO KK = (JJ-1) TO (JJ-AFTER) BY -1\n                  \"XSTATUS\" KK \"= NX\";\n               END\n               II = LABLNO + 1\n            END\n         END\n         ELSE DO\n            II = RR\n         END\n      END\n   END\n\n   IF FIRST = -1 THEN DO\n       \"LOCATE\" 0\n   END\n   ELSE DO\n      IF FIRST > 1 THEN FIRST = FIRST - 1\n      \"(LINESTAT) = XSTATUS\" FIRST\n      \"LOCATE\" FIRST\n      \"XSTATUS\" FIRST \"=\" LINESTAT\n   END\n\n   ZEDSMSG = \"MORE\" BEFORE\"/\"AFTER\n   ZEDLMSG = \"MORE COMPLETED BEFORE=\"BEFORE \"AFTER=\"AFTER\n   ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   EXIT(1)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"MORE - UNEXCLUDE LINES BEFORE/AFTER CURRENTLY EXCLUDED LINES\"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    MORE    ( BEFORE(#) )   ( AFTER(#) )   ( .A .B )        \"\n   SAY\n   SAY \"       UNEXCLUDES (SHOWS) THE BEFORE AND AFTER NUMBER(S) OF \"\n   SAY \"       LINES AROND CURRENTLY EXCLUDED LINES. LINE RANGE MAY \"\n   SAY \"       BE SPECIFIED BY LABELS OR C/CC/C# PREFIX COMMENDS.   \"\n   SAY \"       THE DEFAULT FOR BEFORE AND AFTER IS 1.               \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    MORE    BEFORE(2)  AFTER(0)                             \"\n   SAY\n   SAY \"       UNEXCLUDES 2 LINES BEFORE EACH EXCLUDED GROUP AND 0  \"\n   SAY \"       LINES AFTER IN THE ENTIRE FILE.                      \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MOVECOLD": {"ttr": 28936, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x03'\\x1f\\x01\\x03'\\x1f\\x12\\x00\\x00\\x94\\x00\\x94\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-09-28T00:00:00", "modifydate": "2003-09-28T12:00:00", "lines": 148, "newlines": 148, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- MOVE COLUMNS ONTO OTHER COLUMNS DELETING OLD COLUMNS  **/\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY MOVECOLD 'MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC=0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (FRMLEFT,FRMRIGHT,TOLEFT,LBL1,LBL2)\"\n      IF RC=0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY 'MOVECOLD EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT',\n          'WITH NO PENDING EDIT COMMANDS!'\n      SIGNAL EOJ\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n   IF FRMLEFT = ''  |  FRMRIGHT = ''  |  TOLEFT = ''  THEN DO\n      MESG = 'PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMLEFT,'W')  |  FRMLEFT = 0  THEN DO\n      MESG = \"'\"FRMLEFT\"' VALUE OF FROM-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMRIGHT,'W')  |  FRMRIGHT = 0  THEN DO\n      MESG = \"'\"FRMRIGHT\"' VALUE OF FROM-RIGHT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF FRMLEFT > FRMRIGHT THEN DO\n      MESG = \"FROM-LEFT-COL \"FRMLEFT\" IS GREATER THAN FROM-RIGHT-COL \" +\n         FRMRIGHT\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(TOLEFT,'W')  |  TOLEFT = 0  THEN DO\n      MESG = \"'\"TOLEFT\"' VALUE OF TO-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   LEN = FRMRIGHT - FRMLEFT + 1\n   TORIGHT = TOLEFT + LEN - 1\n   IF TOLEFT > TORIGHT THEN DO\n      MESG = \"TO-LEFT-COL \"TOLEFT\" IS GREATER THAN TO-RIGHT-COL \"TORIGHT\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF TORIGHT > LRECL THEN DO\n      MESG=\"TO-RIGHT COLUMN IS GREATER THAN RECORD SIZE (\"LRECL\")\"\n      SIGNAL ERROR\n   END\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR     \"\n   \"ISREDIT (\"ANUM\") = AUTONUM              \"\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n   START = 1\n   IF LBL1 <> '' THEN\n       \"ISREDIT (START) = LINENUM &LBL1\"\n\n   IF LBL2 <> '' THEN\n        \"ISREDIT (END) = LINENUM &LBL2\"\n   ELSE\n        LBL2 = LBL1\n\n    IF LBL1 > LBL2 THEN DO\n       WST   = START\n       START = END\n       END   = WST\n    END\n\n   DO PNTR =  START  TO  END  BY 1\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      IF TOLEFT > FRMRIGHT THEN DO\n         RECORD = SUBSTR(RECORD,1,FRMLEFT-1),\n            || SUBSTR(RECORD,FRMRIGHT+1,TOLEFT-FRMRIGHT-1),\n            || SUBSTR(RECORD,FRMLEFT,LEN),\n            || SUBSTR(RECORD,TOLEFT+LEN)\n      END\n      ELSE DO\n         RECORD = SUBSTR(RECORD,1,TOLEFT-1),\n            || SUBSTR(RECORD,FRMLEFT,LEN),\n            || SUBSTR(RECORD,TOLEFT+LEN,FRMLEFT-TOLEFT-LEN),\n            || SUBSTR(RECORD,FRMRIGHT+1)\n      END\n      \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n   END\n   \"ISREDIT LOCATE\" START\n   \"ISREDIT AUTONUM =\" ANUM\n    SIGNAL EOJ\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   SIGNAL DISPDOC\n\nEOJ:\n   X=MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"MOVECOLD - MOVE COLUMNS ONTO OTHER DATA DELETING FROM COLUMNS\"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    MOVECOLD FROM-LEFT-COL FROM-RIGHT-COL TO-LEFT-COL (.A .B)\"\n   SAY\n   SAY \"       COLUMN PARAMETERS ARE REQUIRED. LABEL RANGE IS OPTIONAL\"\n   SAY\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    MOVECOLD  1 3  11  .A .B                   \"\n   SAY\n   SAY \"       WILL MOVE THE CONTENTS OF COLUMNS 1     \"\n   SAY \"       THRU 3 TO COLUMNS 11 THRU 13 DELETING   \"\n   SAY \"       1 THRU 3 IN THE LABEL RANGE .A THRU .B  \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MOVECOLS": {"ttr": 28940, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x8c\\x00\\x8c\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 140, "newlines": 140, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- MOVE COLUMNS ONTO OTHER COLUMNS  **/\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY MOVECOLS 'MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC=0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (FRMLEFT,FRMRIGHT,TOLEFT,LBL1,LBL2)\"\n      IF RC=0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY 'MOVECOLS EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT',\n          'WITH NO PENDING EDIT COMMANDS!'\n      SIGNAL EOJ\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n   IF FRMLEFT = ''  |  FRMRIGHT = ''  |  TOLEFT = ''  THEN DO\n      MESG = 'PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMLEFT,'W')  |  FRMLEFT = 0  THEN DO\n      MESG = \"'\"FRMLEFT\"' VALUE OF FROM-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMRIGHT,'W')  |  FRMRIGHT = 0  THEN DO\n      MESG = \"'\"FRMRIGHT\"' VALUE OF FROM-RIGHT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF FRMLEFT > FRMRIGHT THEN DO\n      MESG = \"FROM-LEFT-COL \"FRMLEFT\" IS GREATER THAN FROM-RIGHT-COL \" +\n         FRMRIGHT\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(TOLEFT,'W')  |  TOLEFT = 0  THEN DO\n      MESG = \"'\"TOLEFT\"' VALUE OF TO-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   LEN = FRMRIGHT - FRMLEFT + 1\n   TORIGHT = TOLEFT + LEN - 1\n   IF TOLEFT > TORIGHT THEN DO\n      MESG = \"TO-LEFT-COL \"TOLEFT\" IS GREATER THAN TO-RIGHT-COL \"TORIGHT\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF TORIGHT > LRECL THEN DO\n      MESG=\"TO-RIGHT COLUMN IS GREATER THAN RECORD SIZE (\"LRECL\")\"\n      SIGNAL ERROR\n   END\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR     \"\n   \"ISREDIT (\"ANUM\") = AUTONUM              \"\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n   START = 1\n   IF LBL1 <> '' THEN\n       \"ISREDIT (START) = LINENUM &LBL1\"\n\n   IF LBL2 <> '' THEN\n        \"ISREDIT (END) = LINENUM &LBL2\"\n   ELSE\n        LBL2 = LBL1\n\n    IF LBL1 > LBL2 THEN DO\n       WST   = START\n       START = END\n       END   = WST\n    END\n\n   DO PNTR =  START  TO  END  BY 1\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      FRMFLD = SUBSTR(RECORD,FRMLEFT,LEN)\n      TOFLD  = LEFT(' ',LEN)\n      RECORD = OVERLAY(TOFLD,RECORD,FRMLEFT,LEN)\n      RECORD = OVERLAY(FRMFLD,RECORD,TOLEFT,LEN)\n      \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n   END\n   \"ISREDIT LOCATE\" START\n   \"ISREDIT AUTONUM = \"ANUM\n    SIGNAL EOJ\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   SIGNAL DISPDOC\n\nEOJ:\n   X=MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"MOVECOLS - MOVE COLUMNS ONTO OTHER DATA \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    MOVECOLS FROM-LEFT-COL FROM-RIGHT-COL TO-LEFT-COL (.A .B)\"\n   SAY\n   SAY \"       COLUMN PARAMETERS ARE REQUIRED. LABEL RANGE IS OPTIONAL\"\n   SAY\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    MOVECOLS  1 3  11  .A .B                   \"\n   SAY\n   SAY \"       WILL MOVE THE CONTENTS OF COLUMNS 1     \"\n   SAY \"       THRU 3 TO COLUMNS 11 THRU 13 BLANKING   \"\n   SAY \"       1 THRU 3 IN THE LABEL RANGE .A THRU .B  \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MOVEINS": {"ttr": 29185, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x8f\\x00\\x8f\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 143, "newlines": 143, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- INSERT COLUMNS INTO SPECIFIC COLUMN  **/\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'MOVEINS MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (FRMLEFT,FRMRIGHT,TOLEFT,LBL1,LBL2)\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY 'MOVEINS EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT',\n          'WITH NO PENDING EDIT COMMANDS!'\n      SIGNAL EOJ\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n   IF FRMLEFT = ''  |  FRMRIGHT = ''  |  TOLEFT = ''  THEN DO\n      MESG='PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMLEFT,'W')  |  FRMLEFT = 0  THEN DO\n      MESG=\"'\"FRMLEFT\"' VALUE OF FROM-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMRIGHT,'W')  |  FRMRIGHT = 0  THEN DO\n      MESG=\"'\"FRMRIGHT\"' VALUE OF FROM-RIGHT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF FRMLEFT>FRMRIGHT THEN DO\n      MESG = \"FROM-LEFT-COL \"FRMLEFT\" IS GREATER THAN FROM-RIGHT-COL \" +\n         FRMRIGHT\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(TOLEFT,'W')  |  TOLEFT = 0  THEN DO\n      MESG=\"'\"TOLEFT\"' VALUE OF TO-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   LEN = FRMRIGHT - FRMLEFT + 1\n   TORIGHT = TOLEFT + LEN - 1\n   IF TOLEFT > TORIGHT THEN DO\n      MESG=\"TO-LEFT-COL \"TOLEFT\" IS GREATER THAN TO-RIGHT-COL \"TORIGHT\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF TORIGHT > LRECL THEN DO\n      MESG = \"TO-RIGHT COLUMN IS GREATER THAN RECORD SIZE (\"LRECL\")\"\n      SIGNAL ERROR\n   END\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n        END\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR     \"\n   \"ISREDIT (\"ANUM\") = AUTONUM              \"\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n   START = 1\n   IF LBL1 <> '' THEN\n      \"ISREDIT (START) = LINENUM &LBL1\"\n\n   IF LBL2 <> '' THEN\n       \"ISREDIT (END) = LINENUM &LBL2\"\n   ELSE\n       LBL2 = LBL1\n\n   IF LBL1 > LBL2 THEN DO\n      WST   = START\n      START = END\n      END   = WST\n   END\n\n   DO PNTR =  START  TO  END  BY 1\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      FRMFLD = SUBSTR(RECORD,FRMLEFT,LEN)\n      TOFLD  = LEFT(' ',LEN)\n      RECORD = OVERLAY(TOFLD,RECORD,FRMLEFT,LEN)\n      RECORD = SUBSTR(RECORD,1,TOLEFT-1),\n         || FRMFLD,\n         || SUBSTR(RECORD,TOLEFT,LRECL-LEN-1)\n      RECORD = OVERLAY(FRMFLD,RECORD,TOLEFT,LEN)\n      \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n   END\n   \"ISREDIT LOCATE\" START\n   \"ISREDIT AUTONUM = \"ANUM\n    SIGNAL EOJ\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   SIGNAL DISPDOC\n\nEOJ:\n   X=MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"MOVEINS - INSERT COLUMNS BEFORE A SPECIFIC COLUMN\"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    MOVEINS  FROM-LEFT-COL  FROM-RIGHT-COL  TO-LEFT-COL (.A .B)\"\n   SAY\n   SAY \"       COLUMN PARAMETERS ARE REQUIRED. LABEL RANGE IS OPTIONAL.\"\n   SAY \"       MOVES AND INSERTS DATA, THEN BLANKS ORIGINAL COLUMNS.   \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    MOVEINS  21 28  1 \"\n   SAY \"       WILL MOVE THE CONTENTS OF COLS 21      \"\n   SAY \"       THRU 28 TO COLUMNS 1 THRU 8 SHIFTING   \"\n   SAY \"       COLUMNS 1 ONWARD TO THE RIGHT 8 PLACES \"\n   SAY \"       AND BLANKING THE ORIGINAL SOURCE       \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MOVEINSD": {"ttr": 29189, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x95\\x00\\x95\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 149, "newlines": 149, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- INSERT COLUMNS DELETING ORIGINAL COLUMNS  **/\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'MOVEINSD MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (FRMLEFT,FRMRIGHT,TOLEFT,LBL1,LBL2)\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY 'MOVEINSD EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT',\n          'WITH NO PENDING EDIT COMMANDS!'\n      SIGNAL EOJ\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n   IF FRMLEFT = ''  |  FRMRIGHT = ''  |  TOLEFT = ''  THEN DO\n      MESG='PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMLEFT,'W')  |  FRMLEFT = 0  THEN DO\n      MESG=\"'\"FRMLEFT\"' VALUE OF FROM-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMRIGHT,'W')  |  FRMRIGHT = 0  THEN DO\n      MESG=\"'\"FRMRIGHT\"' VALUE OF FROM-RIGHT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF FRMLEFT>FRMRIGHT THEN DO\n      MESG = \"FROM-LEFT-COL \"FRMLEFT\" IS GREATER THAN FROM-RIGHT-COL \" +\n         FRMRIGHT\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(TOLEFT,'W')  |  TOLEFT = 0  THEN DO\n      MESG=\"'\"TOLEFT\"' VALUE OF TO-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF TOLEFT >= FRMLEFT & TOLEFT <= FRMRIGHT THEN DO\n      MESG=\"'\"TOLEFT\"' IS BETWEEN FROM COLUMNS!\"\n      SIGNAL ERROR\n   END\n   LEN = FRMRIGHT - FRMLEFT + 1\n   TORIGHT = TOLEFT + LEN - 1\n   IF TOLEFT > TORIGHT THEN DO\n      MESG=\"TO-LEFT-COL \"TOLEFT\" IS GREATER THAN TO-RIGHT-COL \"TORIGHT\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF TORIGHT > LRECL THEN DO\n      MESG = \"TO-RIGHT COLUMN IS GREATER THAN RECORD SIZE (\"LRECL\")\"\n      SIGNAL ERROR\n   END\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n        END\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR     \"\n   \"ISREDIT (\"ANUM\") = AUTONUM              \"\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n   START = 1\n   IF LBL1 <> '' THEN\n      \"ISREDIT (START) = LINENUM &LBL1\"\n\n   IF LBL2 <> '' THEN\n       \"ISREDIT (END) = LINENUM &LBL2\"\n   ELSE\n       LBL2 = LBL1\n\n   IF LBL1 > LBL2 THEN DO\n      WST   = START\n      START = END\n      END   = WST\n   END\n\n   DO PNTR =  START  TO  END  BY 1\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      IF FRMLEFT > TOLEFT\n         THEN RECORD = SUBSTR(RECORD,1,TOLEFT-1),\n               || SUBSTR(RECORD,FRMLEFT,LEN),\n               || SUBSTR(RECORD,TOLEFT,FRMLEFT-TOLEFT),\n               || SUBSTR(RECORD,FRMRIGHT+1)\n         ELSE RECORD = SUBSTR(RECORD,1,FRMLEFT-1),\n               || SUBSTR(RECORD,FRMRIGHT+1,TOLEFT-FRMRIGHT-1),\n               || SUBSTR(RECORD,FRMLEFT,LEN),\n               || SUBSTR(RECORD,TOLEFT)\n      \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n   END\n   \"ISREDIT LOCATE\" START\n   \"ISREDIT AUTONUM = \"ANUM\n    SIGNAL EOJ\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   SIGNAL DISPDOC\n\nEOJ:\n   X=MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"MOVEINSD - INSERT COLUMNS BEFORE A SPECIFIC COLUMN\"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    MOVEINSD FROM-LEFT-COL  FROM-RIGHT-COL  TO-LEFT-COL  .A .B \"\n   SAY\n   SAY \"       COLUMN PARAMETERS ARE REQUIRED. LABEL RANGE IS OPTIONAL.\"\n   SAY \"       MOVES AND INSERTS DATA, DELETING ORIGINAL COLUMNS.      \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    MOVEINSD  21 28  1 \"\n   SAY \"       WILL MOVE THE CONTENTS OF COLS 21      \"\n   SAY \"       THRU 28 TO COLUMNS 1 THRU 8 SHIFTING   \"\n   SAY \"       COLUMNS 1 ONWARD TO THE RIGHT 8 PLACES \"\n   SAY \"       DELETING THE ORIGINAL SOURCE COLUMNS.  \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NEATJCL": {"ttr": 29193, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00{\\x00{\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 123, "newlines": 123, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- ALIGN JCL STATEMENTS ON \"STANDARD\" BOUNDARIES  **/\n   \"ISREDIT MACRO (PARMS) NOPROCESS\"\n   IF PARMS = '?' THEN SIGNAL DISPDOC\n\n   ADDRESS ISREDIT\n   \"PROCESS RANGE C\"\n   IF RC > 0 THEN DO\n      TOP = .ZFIRST\n      BOT = .ZLAST\n   END\n   ELSE DO\n      TOP = .ZFRANGE\n      BOT = .ZLRANGE\n   END\n\n   \"(LB,RB) = BOUNDS\"\n   \"BOUNDS  = 1 71\"\n   \"X ALL\"\n   \"F '//'  1 ALL\" TOP BOT\n   \"X '//*' 1 ALL\" TOP BOT\n\n   /*   REMOVE EXTRA SPACES   */\n   \"C ' '      '{' 3 71 ALL NX  \" TOP BOT\n   \"C '{{{{{'  '{' 3 71 ALL NX  \" TOP BOT\n   \"C '{{{{'   '{' 3 71 ALL NX  \" TOP BOT\n   \"C '{{{'    '{' 3 71 ALL NX  \" TOP BOT\n   \"C '{{'     '{' 3 71 ALL NX  \" TOP BOT\n   \"C '{'      ' ' 3 71 ALL NX  \" TOP BOT\n\n   /*   JOB, JCLLIB, INCLUDE, PROC, EXEC, DD AND PEND CONVERSION  */\n   KEYWD = 'JOB'\n   FLDA  = 12\n   FLDB  = 22\n\n   DO  WHILE  KEYWD <> ''\n      \"X ALL\"\n      KEYWDB = ' 'KEYWD' '\n      KEYWDU = '_'KEYWD'_'\n      KEYWDX = '{'KEYWD'}'\n      \"F '\"KEYWDB\"' 3 25 ALL\" TOP BOT\n      IF RC <> 4 THEN DO\n         \"X '//*' 1 ALL\" TOP BOT\n         \"C '\"KEYWDB\"' '\"KEYWDX\"' ALL NX\" TOP BOT\n         \"C '{' '{{'         3 25 ALL NX\" TOP BOT\n         \"C '}' '}}'         3 40 ALL NX\" TOP BOT\n         \"C '{' '{{'         3 25 ALL NX\" TOP BOT\n         \"C '}' '}}'         3 40 ALL NX\" TOP BOT\n         \"C '{' '{{'         3 25 ALL NX\" TOP BOT\n         \"C '}' '}}'         3 40 ALL NX\" TOP BOT\n         \"C '{' '{{'         3 25 ALL NX\" TOP BOT\n         \"C '\"KEYWDX\"' '\"KEYWDU\"' ALL NX\" TOP BOT\n         \"C ' ' '\u00ac'               ALL NX\" TOP BOT\n         \"C '{' ' '          3 \"FLDA\" ALL NX\" TOP BOT\n         \"C '{' ''                ALL NX\" TOP BOT\n         \"C '}\u00ac' '}'              ALL NX\" TOP BOT\n         \"C '}' ' '         10 \"FLDB\" ALL NX\" TOP BOT\n         \"C '}' ''                ALL NX\" TOP BOT\n         \"C '\"KEYWDU\"' '\"KEYWDB\"' ALL   \" TOP BOT\n         \"C '\u00ac' ' '               ALL NX\" TOP BOT\n      END  /** IF RC <> 4 **/\n\n      IF      KEYWD = 'DD'      THEN KEYWD = ''\n      ELSE IF KEYWD = 'JCLLIB'  THEN KEYWD = 'DD'\n      ELSE IF KEYWD = 'INCLUDE' THEN KEYWD = 'JCLLIB'\n      ELSE IF KEYWD = 'PEND'    THEN KEYWD = 'INCLUDE'\n      ELSE IF KEYWD = 'EXEC'    THEN DO\n           KEYWD = 'PEND'\n           FLDA  = 14\n           FLDB  = 24\n      END\n      ELSE IF KEYWD = 'PROC'    THEN KEYWD = 'EXEC'\n      ELSE IF KEYWD = 'JOB'     THEN KEYWD = 'PROC'\n   END  /** DO WHILE **/\n\n   /*  CONTINUATION CARD CONVERSION  */\n   \"X ALL\"\n   \"F '// ' 1 ALL\" TOP BOT\n   \"X '//           EXEC'       1 ALL\" TOP BOT\n   \"X '//             INCLUDE'  1 ALL\" TOP BOT\n   \"X '//             JCLLIB'   1 ALL\" TOP BOT\n   \"X '//             DD'       1 ALL\" TOP BOT\n   \"X '//             PEND'     1 ALL\" TOP BOT\n   \"C ' ' '}'  3    ALL NX\" TOP BOT\n   \"C '}' '}}' 3 25 ALL NX\" TOP BOT\n   \"C '}' '}}' 3 25 ALL NX\" TOP BOT\n   \"C '}' '}}' 3 25 ALL NX\" TOP BOT\n   \"C '}' '}}' 3 25 ALL NX\" TOP BOT\n   \"C '}' '}}' 3 25 ALL NX\" TOP BOT\n   \"C ' ' '\u00ac'  3 70 ALL NX\" TOP BOT\n   \"C '}\u00ac' '}' 3 70 ALL NX\" TOP BOT\n   \"C '}' ' '  3 15 ALL NX\" TOP BOT\n   \"C '}' ''        ALL NX\" TOP BOT\n   \"C '\u00ac' ' '       ALL NX\" TOP BOT\n   \"X ALL\"\n   \"BOUNDS =\" LB RB\n   \"LEFT MAX\"\n   \"RESET\"\n   EXIT(1)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"NEATJCL - FORMAT JCL CONSISTENTLY                         \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    NEATJCL                                               \"\n   SAY\n   SAY \"       WILL CAUSE JCL WITHIN THE MARKED (VIA C/CC/C##)    \"\n   SAY \"       RANGE OF LINES TO BE FORMATTED.  IF NO RANGE IS    \"\n   SAY \"       SPECIFIED, THE ENTIRE FILE IS PROCESSED.  THE      \"\n   SAY \"       BLOCK OPERATIONS, LIKE EXEC OR PROC, ARE PLACED IN \"\n   SAY \"       COLUMN 14, OTHER OPERATIONS LIKE DD IN COLUMN 16.  \"\n   SAY \"       OPERANDS ARE SHIFTED TO COLUMN 25 UNLESS THERE'S   \"\n   SAY \"       NO OPERATION PRESENT, WHEN THEY'RE PLACED IN       \"\n   SAY \"       COLUMN 16.                                         \"\n   SAY \"                                                          \"\n   SAY \"       COMMENTS (//*), TERMINATORS (/*) AND DATA ARE LEFT \"\n   SAY \"       AS FOUND.  WHERE LONG NAMES ARE FORMED OF          \"\n   SAY \"       STEP.DDNAME, THE COLUMN FORMATTING IS AS CLOSE AS  \"\n   SAY \"       POSSIBLE TO THE STANDARDS ABOVE.                   \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NEW": {"ttr": 29196, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00g\\x00g\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 103, "newlines": 103, "modlines": 0, "user": "REXX"}, "text": "/**  REXX - ALLOCATE NEW SEQUENTIAL DATA SET  **/\n   SAVEMSG = MSG(\"OFF\")\n   CALLED = SYSVAR(SYSNEST)\n   X = ADDRESS()\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT \"ISREDIT MACRO (\"DSN SP1 SP2 RF LR\")\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      UMODE = 'ISPEXEC'\n      ARG DSN SP1 SP2 RF LR\n   END\n   ELSE DO\n      ADDRESS ISREDIT \"ISREDIT (\"LIN\",\"COL\") = CURSOR\"\n   END\n   IF DSN = '?' | DSN = '' THEN SIGNAL DISPDOC\n\n   DSN = TRANSLATE(DSN)\n   RF  = TRANSLATE(RF)\n   SELECT\n      WHEN RF = 'FB' THEN DO\n         EXPRF = 'F B'\n         BS = ( 27998 % LR ) * LR\n         END\n      WHEN RF = 'FBA' THEN DO\n         EXPRF = 'F B A'\n         BS = ( 27998 % LR ) * LR\n         END\n      WHEN RF = 'VB' THEN DO\n         EXPRF = 'V B'\n         BS = 27998\n         END\n      WHEN RF = 'VBA' THEN DO\n         EXPRF = 'V B A'\n         BS = 27998\n         END\n      WHEN RF = 'F'  THEN DO\n         EXPRF = 'F'\n         BS = LR\n         END\n      WHEN RF = 'FA'  THEN DO\n         EXPRF = 'F A'\n         BS = LR\n         END\n      WHEN RF = 'V'  THEN DO\n         EXPRF = 'V'\n         BS = LR + 4\n         END\n      WHEN RF = 'VA'  THEN DO\n         EXPRF = 'V A'\n         BS = LR + 4\n         END\n      WHEN RF = 'U'  THEN DO\n         EXPRF = 'U'\n         BS = LR\n         LR = 0\n         END\n      OTHERWISE DO\n         SAY 'UNEXPECTED RECORD FORMAT FOUND: ' RF\n         EXIT(12)\n         END\n   END  /* END SELECT */\n\n   ADDRESS TSO \"ALLOCATE DSN(\"DSN\") NEW CYL SP(\"SP1\" \"SP2\")\",\n               \"RECFM(\"EXPRF\") LRECL(\"LR\") BLKSIZE(\"BS\")\"\n   RETCODE = RC\n   IF RETCODE = 0 THEN DO\n      ANSW = \"NEW DATA SET\" DSN \"SUCCESSFULLY ALLOCATED\"\n      ADDRESS TSO \"FREE DSN(\"DSN\")\"\n   END\n   ELSE DO\n      ANSW = DSN \"NOT ALLOCATED - RETURN CODE =\" RETCODE\n   END\n\n   SAY ANSW\n   EXIT  0\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"NEW - ALLOCATE NEW SEQUENTIAL DATA SET                 \"\n   SAY\n   SAY \" NEW  DSN SPACE1 SPACE2 RECFM LRECL                    \"\n   SAY\n   SAY \"    DSN     - NEW DATA SET NAME                        \"\n   SAY\n   SAY \"    SPACE1  - PRIMARY SPACE (IN CYLINDERS)             \"\n   SAY\n   SAY \"    SPACE2  - SECONDARY SPACE (IN CYLINDERS)           \"\n   SAY\n   SAY \"    RECFM   - RECORD FORMAT, E.G. FB                   \"\n   SAY\n   SAY \"    LRECL   - LOGICAL RECORD LENGTH                    \"\n   SAY\n   SAY \"  THE BLOCK SIZE WILL BE SET AS CLOSE AS POSSIBLE      \"\n   SAY \"  TO HALF TRACK BLOCKING, I.E. <= 27,998, UNLESS       \"\n   SAY \"  IT'S SET TO 27,998 FOR VB FORMAT.                    \"\n   SAY\n   EXIT(255)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NEWP": {"ttr": 29199, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00j\\x00j\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 106, "newlines": 106, "modlines": 0, "user": "REXX"}, "text": "/**  REXX - ALLOCATE NEW PARTITIONED DATA SET **/\n   SAVEMSG = MSG(\"OFF\")\n   CALLED = SYSVAR(SYSNEST)\n   X = ADDRESS()\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT \"ISREDIT MACRO (\"DSN SP1 SP2 DIR RF LR\")\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      UMODE = 'ISPEXEC'\n      ARG DSN SP1 SP2 DIR RF LR\n   END\n   ELSE DO\n      ADDRESS ISREDIT \"ISREDIT (\"LIN\",\"COL\") = CURSOR\"\n   END\n   IF DSN = '?' | DSN = '' THEN SIGNAL DISPDOC\n\n\n   DSN = TRANSLATE(DSN)\n   RF  = TRANSLATE(RF)\n   SELECT\n      WHEN RF = 'FB' THEN DO\n         EXPRF = 'F B'\n         BS = ( 27998 % LR ) * LR\n         END\n      WHEN RF = 'FBA' THEN DO\n         EXPRF = 'F B A'\n         BS = ( 27998 % LR ) * LR\n         END\n      WHEN RF = 'VB' THEN DO\n         EXPRF = 'V B'\n         BS = 27998\n         END\n      WHEN RF = 'VBA' THEN DO\n         EXPRF = 'V B A'\n         BS = 27998\n         END\n      WHEN RF = 'F'  THEN DO\n         EXPRF = 'F'\n         BS = LR\n         END\n      WHEN RF = 'FA'  THEN DO\n         EXPRF = 'F A'\n         BS = LR\n         END\n      WHEN RF = 'V'  THEN DO\n         EXPRF = 'V'\n         BS = LR + 4\n         END\n      WHEN RF = 'VA'  THEN DO\n         EXPRF = 'V A'\n         BS = LR + 4\n         END\n      WHEN RF = 'U'  THEN DO\n         EXPRF = 'U'\n         BS = LR\n         LR = 0\n         END\n      OTHERWISE DO\n         SAY 'UNEXPECTED RECORD FORMAT FOUND: ' RF\n         EXIT(12)\n         END\n   END  /* END SELECT */\n\n   ADDRESS TSO \"ALLOCATE DSN(\"DSN\") NEW CYL SP(\"SP1\" \"SP2\")\",\n                \"DIR(\"DIR\")\" \"RECFM(\"EXPRF\") LRECL(\"LR\") BLKSIZE(\"BS\")\"\n   RETCODE = RC\n   IF RETCODE = 0 THEN DO\n      ANSW = \"NEW DATA SET\" DSN \"SUCCESSFULLY ALLOCATED\"\n      ADDRESS TSO \"FREE DSN(\"DSN\")\"\n   END\n   ELSE DO\n      ANSW = DSN \"NOT ALLOCATED - RETURN CODE =\" RETCODE\n   END\n\n   SAY ANSW\n   EXIT  0\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"NEW - ALLOCATE NEW PARTITIONED DATA SET                \"\n   SAY\n   SAY \" NEWP DSN SPACE1 SPACE2 DIRCNT RECFM LRECL             \"\n   SAY\n   SAY \"    DSN     - NEW DATA SET NAME                        \"\n   SAY\n   SAY \"    SPACE1  - PRIMARY SPACE (IN CYLINDERS)             \"\n   SAY\n   SAY \"    SPACE2  - SECONDARY SPACE (IN CYLINDERS)           \"\n   SAY\n   SAY \"    DIRCNT  - NUMBER OF DIRECTORY BLOCKS               \"\n   SAY\n   SAY \"    RECFM   - RECORD FORMAT, E.G. FB                   \"\n   SAY\n   SAY \"    LRECL   - LOGICAL RECORD LENGTH                    \"\n   SAY\n   SAY \"  THE BLOCK SIZE WILL BE SET AS CLOSE AS POSSIBLE      \"\n   SAY \"  TO HALF TRACK BLOCKING, I.E. <= 27,998, UNLESS       \"\n   SAY \"  IT'S SET TO 27,998 FOR VB FORMAT.                    \"\n   SAY\n   EXIT(255)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NUMCOLS": {"ttr": 29443, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xc1\\x00\\xc1\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 193, "newlines": 193, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- NUMBER SPECIFIC COLUMNS  **/\n   RETURN_CODE = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'NUMCOLS MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (PARMS)\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY 'NUMCOLS EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT',\n          'WITH NO PENDING EDIT COMMANDS!'\n      SIGNAL EOJ\n   END\n\n   PARMS    = TRANSLATE(PARMS)\n   STARTCOL = \"\"\n   ENDCOL   = \"\"\n   STARTNUM = \"\"\n   INCR     = \"\"\n   SKIP     = \"\"\n   LBL1     = \"\"\n   LBL2     = \"\"\n   DO II = 1 TO 7;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               SIGNAL DISPDOC\n            END\n      END\n      ELSE DO\n         IF DATATYPE(TOKEN,'W')  THEN DO\n            IF STARTCOL = \"\" THEN STARTCOL = TOKEN\n               ELSE IF ENDCOL   = \"\" THEN ENDCOL   = TOKEN\n               ELSE IF STARTNUM = \"\" THEN STARTNUM = TOKEN\n               ELSE IF INCR     = \"\" THEN INCR     = TOKEN\n               ELSE IF SKIP     = \"\" THEN SKIP     = TOKEN\n                  ELSE DO\n                     ZEDSMSG = \".LABEL RC=8\"\n                     ZEDLMSG = \"TOO MANY NUMBERS --\" TOKEN\n                     ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n                     SIGNAL DISPDOC\n                  END\n         END\n         ELSE DO\n            ZEDSMSG = \"BAD PARM\"\n            ZEDLMSG = \"UNRECOGNIZED PARM --\" TOKEN\n            ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n            SIGNAL DISPDOC\n         END\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n\n   ERRORMSG = ''\n   MESG = ''\n   IF STARTCOL = ''  |  ENDCOL = '' THEN DO\n      MESG = 'REQUIRED PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(STARTCOL,'W')  |  STARTCOL = 0  THEN DO\n      MESG = \"'\"STARTCOL\"' VALUE OF STARTING COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(ENDCOL,'W') |  ENDCOL = 0 THEN DO\n      MESG = \"'\"ENDCOL\"' VALUE OF NUMBER SIZE IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF STARTNUM = '' THEN STARTNUM = 1\n   ELSE IF STARTNUM <> '' THEN DO\n      IF \u00acDATATYPE(STARTNUM,'W') THEN DO\n         MESG = \"'\"STARTNUM\"' VALUE OF STARTING NUMBER IS INVALID!\"\n         SIGNAL ERROR\n      END\n   END\n   IF INCR = '' THEN INCR = 1\n   ELSE IF INCR <> '' THEN DO\n      IF \u00acDATATYPE(INCR,'W') THEN DO\n         MESG = \"'\"INCR\"' VALUE OF INCREMENT IS INVALID!\"\n         SIGNAL ERROR\n      END\n      IF INCR = 0 THEN DO\n         MESG = \"'\"INCR\"' INCREMENT VALUE OF 0 IS INVALID!\"\n         SIGNAL ERROR\n      END\n   END\n   IF SKIP = '' THEN SKIP = 1\n   ELSE IF SKIP <> '' THEN DO\n      IF \u00acDATATYPE(SKIP,'W') THEN DO\n         MESG = \"'\"SKIP\"' VALUE OF SKIP IS INVALID!\"\n         SIGNAL ERROR\n      END\n      IF SKIP = 0 THEN DO\n         MESG = \"'\"SKIP\"' SKIP VALUE OF 0 IS INVALID!\"\n         SIGNAL ERROR\n      END\n   END\n   LEN = ENDCOL - STARTCOL + 1\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF LEN > LRECL THEN DO\n      MESG=\"CALCULATED SIZE IS GREATER THAN RECORD SIZE (\"LRECL\")\"\n      SIGNAL ERROR\n   END\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n    END\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR     \"\n   \"ISREDIT (\"ANUM\") = AUTONUM              \"\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n   START = 1\n   IF LBL1 <> '' THEN \"ISREDIT (START) = LINENUM &LBL1\"\n   IF LBL2 <> '' THEN \"ISREDIT (END) = LINENUM &LBL2\"\n      ELSE LBL2 = LBL1\n   IF START > END THEN DO\n      WST   = START\n      START = END\n      END   = WST\n   END\n\n   DO PNTR =  START  TO  END  BY SKIP\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      PATCH = RIGHT(STARTNUM,LEN)\n      RECORD = OVERLAY(PATCH,RECORD,STARTCOL,LEN)\n      \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n      STARTNUM = STARTNUM + INCR\n   END\n   \"ISREDIT LOCATE\" START\n   \"ISREDIT AUTONUM = \"ANUM\n    SIGNAL EOJ\n\nERROR:\n   IF MESG<>'' THEN DO\n      RETURN_CODE = 20\n      ERRORMSG='===>' MESG\n   END\n   SIGNAL DISPDOC\n\nEOJ:\n   X = MSG(SAVEMSG)\n   RETURN RETURN_CODE\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"NUMCOLS - PUT SEQUENTIAL NUMBERS IN SPECIFIC COLUMNS \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"   NUMCOLS START-COL END-COL (START-NUM INCREMENT SKIP) (.A .B)\"\n   SAY\n   SAY \"       STARTING AND ENDING COLUMNS ARE MANDATORY.  THE  \"\n   SAY \"       STARTING NUMBER, INCREMENT AND NUMBER OF LINES   \"\n   SAY \"       TO SKIP DEFAULT TO 1.  ALL MUST BE NUMERIC.  THE \"\n   SAY \"       LABEL RANGE IS OPTIONAL AND MAY BE INTERMIXED.   \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    NUMCOLS  73  80  .AA .BB  100  100  2 \"\n   SAY \"       WILL PUT '     100' IN COLUMNS 73 THRU 80 ON THE     \"\n   SAY \"       1ST LINE OF RANGE .AA THROUGH .BB, '     200' ON     \"\n   SAY \"       THE 3RD LINE, '     300' ON THE 5TH LINE, ETC.       \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NUMCOLS0": {"ttr": 29447, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xc1\\x00\\xc1\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 193, "newlines": 193, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- NUMBER SPECIFIC COLUMNS WITH ZERO FILL  **/\n   RETURN_CODE = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'NUMCOLS0 MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (PARMS)\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY 'NUMCOLS0 EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT',\n          'WITH NO PENDING EDIT COMMANDS!'\n      SIGNAL EOJ\n   END\n\n   PARMS    = TRANSLATE(PARMS)\n   STARTCOL = \"\"\n   ENDCOL   = \"\"\n   STARTNUM = \"\"\n   INCR     = \"\"\n   SKIP     = \"\"\n   LBL1     = \"\"\n   LBL2     = \"\"\n   DO II = 1 TO 7;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               SIGNAL DISPDOC\n            END\n      END\n      ELSE DO\n         IF DATATYPE(TOKEN,'W')  THEN DO\n            IF STARTCOL = \"\" THEN STARTCOL = TOKEN\n               ELSE IF ENDCOL   = \"\" THEN ENDCOL   = TOKEN\n               ELSE IF STARTNUM = \"\" THEN STARTNUM = TOKEN\n               ELSE IF INCR     = \"\" THEN INCR     = TOKEN\n               ELSE IF SKIP     = \"\" THEN SKIP     = TOKEN\n                  ELSE DO\n                     ZEDSMSG = \".LABEL RC=8\"\n                     ZEDLMSG = \"TOO MANY NUMBERS --\" TOKEN\n                     ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n                     SIGNAL DISPDOC\n                  END\n         END\n         ELSE DO\n            ZEDSMSG = \"BAD PARM\"\n            ZEDLMSG = \"UNRECOGNIZED PARM --\" TOKEN\n            ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n            SIGNAL DISPDOC\n         END\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n\n   ERRORMSG = ''\n   MESG = ''\n   IF STARTCOL = ''  |  ENDCOL = '' THEN DO\n      MESG = 'REQUIRED PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(STARTCOL,'W')  |  STARTCOL = 0  THEN DO\n      MESG = \"'\"STARTCOL\"' VALUE OF STARTING COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(ENDCOL,'W') |  ENDCOL = 0 THEN DO\n      MESG = \"'\"ENDCOL\"' VALUE OF NUMBER SIZE IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF STARTNUM = '' THEN STARTNUM = 1\n   ELSE IF STARTNUM <> '' THEN DO\n      IF \u00acDATATYPE(STARTNUM,'W') THEN DO\n         MESG = \"'\"STARTNUM\"' VALUE OF STARTING NUMBER IS INVALID!\"\n         SIGNAL ERROR\n      END\n   END\n   IF INCR = '' THEN INCR = 1\n   ELSE IF INCR <> '' THEN DO\n      IF \u00acDATATYPE(INCR,'W') THEN DO\n         MESG = \"'\"INCR\"' VALUE OF INCREMENT IS INVALID!\"\n         SIGNAL ERROR\n      END\n      IF INCR = 0 THEN DO\n         MESG = \"'\"INCR\"' INCREMENT VALUE OF 0 IS INVALID!\"\n         SIGNAL ERROR\n      END\n   END\n   IF SKIP = '' THEN SKIP = 1\n   ELSE IF SKIP <> '' THEN DO\n      IF \u00acDATATYPE(SKIP,'W') THEN DO\n         MESG = \"'\"SKIP\"' VALUE OF SKIP IS INVALID!\"\n         SIGNAL ERROR\n      END\n      IF SKIP = 0 THEN DO\n         MESG = \"'\"SKIP\"' SKIP VALUE OF 0 IS INVALID!\"\n         SIGNAL ERROR\n      END\n   END\n   LEN = ENDCOL - STARTCOL + 1\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF LEN > LRECL THEN DO\n      MESG=\"CALCULATED SIZE IS GREATER THAN RECORD SIZE (\"LRECL\")\"\n      SIGNAL ERROR\n   END\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n       IF RC <> 0 THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n    END\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR     \"\n   \"ISREDIT (\"ANUM\") = AUTONUM              \"\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n   START = 1\n   IF LBL1 <> '' THEN \"ISREDIT (START) = LINENUM &LBL1\"\n   IF LBL2 <> '' THEN \"ISREDIT (END) = LINENUM &LBL2\"\n      ELSE LBL2 = LBL1\n   IF START > END THEN DO\n      WST   = START\n      START = END\n      END   = WST\n   END\n\n   DO PNTR =  START  TO  END  BY SKIP\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      PATCH = RIGHT(STARTNUM,LEN,'0')\n      RECORD = OVERLAY(PATCH,RECORD,STARTCOL,LEN)\n      \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n      STARTNUM = STARTNUM + INCR\n   END\n   \"ISREDIT LOCATE\" START\n   \"ISREDIT AUTONUM = \"ANUM\n    SIGNAL EOJ\n\nERROR:\n   IF MESG<>'' THEN DO\n      RETURN_CODE = 20\n      ERRORMSG='===>' MESG\n   END\n   SIGNAL DISPDOC\n\nEOJ:\n   X = MSG(SAVEMSG)\n   RETURN RETURN_CODE\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"NUMCOLS0 - SEQUENCE COLUMNS WITH ZERO PADDED NUMBERS \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"  NUMCOLS0 START-COL END-COL (START-NUM INCREMENT SKIP) (.A .B)\"\n   SAY\n   SAY \"       STARTING AND ENDING COLUMNS ARE MANDATORY.  THE \"\n   SAY \"       STARTING NUMBER, INCREMENT AND NUMBER OF LINES  \"\n   SAY \"       TO SKIP DEFAULT TO 1.  ALL MUST BE NUMERIC. THE \"\n   SAY \"       LABEL RANGE IS OPTIONAL AND MAY BE INTERMIXED.  \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    NUMCOLS0  21 24  100 100 3  .A .B                       \"\n   SAY \"       WILL PUT '0100' IN COLUMNS 21 THRU 24 ON THE 1ST LINE\"\n   SAY \"       OF RANGE .A THRU .B, '0200' ON THE 4TH LINE, '0300'  \"\n   SAY \"       ON THE 7TH LINE, ETC.                                \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OPCODE": {"ttr": 29451, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x01@\\x01@\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 320, "newlines": 320, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- OPCODE IDENTIFIER  **/\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'ON'  THEN  X = MSG(\"OFF\")\n   CALLED = SYSVAR(SYSNEST)\n   X = ADDRESS()\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT \"ISREDIT MACRO (\"CODE\")\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      UMODE = 'ISPEXEC'\n      ARG CODE\n   END\n   ELSE DO\n      ADDRESS ISREDIT \"ISREDIT (\"LIN\",\"COL\") = CURSOR\"\n   END\n   CODE = TRANSLATE(CODE)\n   IF CODE = '' THEN SIGNAL DISPDOC\n\n   OPCODE.     = ''\n   OPCODE.AC   = 'AC   STORE THEN AND SYSTEM MASK    STNSM SI    '\n   OPCODE.AD   = 'AD   STORE THEN OR SYSTEM MASK     STOSM SI    '\n   OPCODE.AE   = 'AE   SIGNAL PROCESSOR              SIGP  RS   C'\n   OPCODE.AF   = 'AF   MONITOR CALL                  MC    SI    '\n   OPCODE.A70  = 'A70  TEST UNDER MASK HIGH          TMH   RI   C'\n   OPCODE.A71  = 'A71  TEST UNDER MASK LOW           TML   RI   C'\n   OPCODE.A74  = 'A74  BRANCH RELATIVE ON CONDITION  BRC   RI    '\n   OPCODE.A75  = 'A75  BRANCH RELATIVE AND SAVE      BRAS  RI    '\n   OPCODE.A76  = 'A76  BRANCH RELATIVE ON COUNT      BRCT  RI    '\n   OPCODE.A78  = 'A78  LOAD HALFWORD IMMEDIATE       LHI   RI    '\n   OPCODE.A7A  = 'A7A  ADD HALFWORD IMMEDIATE        AHI   RI   C'\n   OPCODE.A7C  = 'A7C  MULTIPLY HALFWORD IMMEDIATE   MHI   RI    '\n   OPCODE.A7E  = 'A7E  COMPARE HALFWORD IMMEDIATE    CHI   RI   C'\n   OPCODE.A8   = 'A8   MOVE LONG EXTENDED            MVCLE RS   C'\n   OPCODE.A9   = 'A9   COMPARE LOGICAL LONG EXTENDED CLCLE RS   C'\n   OPCODE.BA   = 'BA   COMPARE AND SWAP              CS    RS   C'\n   OPCODE.BB   = 'BB   COMPARE DOUBLE AND SWAP       CDS   RS   C'\n   OPCODE.BD   = 'BD   COMPARE LOGICAL C. UNDER MASK CLM   RS   C'\n   OPCODE.BE   = 'BE   STORE CHARACTERS UNDER MASK   STCM  RS    '\n   OPCODE.BF   = 'BF   INSERT CHARACTERS UNDER MASK  ICM   RS   C'\n   OPCODE.B1   = 'B1   LOAD REAL ADDRESS             LRA   RX   C'\n   OPCODE.B202 = 'B202 STORE CPU ID                  STIDP S     '\n   OPCODE.B204 = 'B204 SET CLOCK                     SCK   S    C'\n   OPCODE.B205 = 'B205 STORE CLOCK                   STCK  S    C'\n   OPCODE.B206 = 'B206 SET CLOCK COMPARATOR          SCKC  S     '\n   OPCODE.B207 = 'B207 STORE CLOCK COMPARATOR        STCKC S     '\n   OPCODE.B208 = 'B208 SET CPU TIMER                 SPT   S     '\n   OPCODE.B209 = 'B209 STORE CPU TIMER               STPT  S     '\n   OPCODE.B20A = 'B20A SET PSW KEY FROM ADDRESS      SPKA  S     '\n   OPCODE.B20B = 'B20B INSERT PSW KEY                IPK   S     '\n   OPCODE.B20D = 'B20D PURGE TLB                     PTLB  S     '\n   OPCODE.B210 = 'B210 SET PREFIX                    SPX   S     '\n   OPCODE.B211 = 'B211 STORE PREFIX                  STPX  S     '\n   OPCODE.B212 = 'B212 STORE CPU ADDRESS             STAP  S     '\n   OPCODE.B218 = 'B218 PROGRAM CALL                  PC    S     '\n   OPCODE.B219 = 'B219 SET ADDRESS SPACE CONTROL     SAC   S     '\n   OPCODE.B21A = 'B21A COMPARE AND FORM CODEWORD     CFC   S    C'\n   OPCODE.B221 = 'B221 INVALIDATE PAGE TABLE ENTRY   IPTE  RRE   '\n   OPCODE.B222 = 'B222 INSERT PROGRAM MASK           IPM   RRE   '\n   OPCODE.B223 = 'B223 INSERT VIRTUAL STORAGE KEY    IVSK  RRE   '\n   OPCODE.B224 = 'B224 INSERT ADDRESS SPACE CONTROL  IAC   RRE  C'\n   OPCODE.B225 = 'B225 SET SECONDARY ASN             SSAR  RRE   '\n   OPCODE.B226 = 'B226 EXTRACT PRIMARY ASN           EPAR  RRE   '\n   OPCODE.B227 = 'B227 EXTRACT SECONDARY ASN         ESAR  RRE   '\n   OPCODE.B228 = 'B228 PROGRAM TRANSFER              PT    RRE   '\n   OPCODE.B229 = 'B229 INSERT STORAGE KEY EXTENDED   ISKE  RRE   '\n   OPCODE.B22A = 'B22A RESET REFERENCE BIT EXTENDED  RRBE  RRE  C'\n   OPCODE.B22B = 'B22B SET STORAGE KEY EXTENDED      SSKE  RRE   '\n   OPCODE.B22C = 'B22C TEST BLOCK                    TB    RRE  C'\n   OPCODE.B22D = 'B22D DIVIDE (EXTENDED)             DXR   RRE   '\n   OPCODE.B230 = 'B230 CLEAR SUBCHANNEL              CSCH  S    C'\n   OPCODE.B231 = 'B231 HALT SUBCHANNEL               HSCH  S    C'\n   OPCODE.B232 = 'B232 MODIFY SUBCHANNEL             MSCH  S    C'\n   OPCODE.B233 = 'B233 START SUBCHANNEL              SSCH  S    C'\n   OPCODE.B234 = 'B234 STORE SUBCHANNEL              STSCH S    C'\n   OPCODE.B235 = 'B235 TEST SUBCHANNEL               TSCH  S    C'\n   OPCODE.B236 = 'B236 TEST PENDING INTERRUPTION     TPI   S    C'\n   OPCODE.B237 = 'B237 SET ADDRESS LIMIT             SAL   S     '\n   OPCODE.B238 = 'B238 RESUME SUBCHANNEL             RSCH  S    C'\n   OPCODE.B239 = 'B239 STORE CHANNEL REPORT WORD     STCRW S    C'\n   OPCODE.B23A = 'B23A STORE CHANNEL PATH STATUS     STCPS S     '\n   OPCODE.B23B = 'B23B RESET CHANNEL PATH            RCHP  S    C'\n   OPCODE.B23C = 'B23C SET CHANNEL MONITOR           SCHM  S     '\n   OPCODE.B240 = 'B240 BRANCH AND STACK              BAKR  RRE   '\n   OPCODE.B241 = 'B241 CHECKSUM                      CKSM  RRE  C'\n   OPCODE.B244 = 'B244 SQUARE ROOT (LONG)            SQDR  RRE   '\n   OPCODE.B245 = 'B245 SQUARE ROOT (SHORT)           SQER  RRE   '\n   OPCODE.B246 = 'B246 STORE USING REAL ADDRESS      STURA RRE   '\n   OPCODE.B247 = 'B247 MODIFY STACKED STATE          MSTA  RRE   '\n   OPCODE.B248 = 'B248 PURGE ALB                     PALB  RRE   '\n   OPCODE.B249 = 'B249 EXTRACT STACKED REGISTERS     EREG  RRE   '\n   OPCODE.B24A = 'B24A EXTRACT STACKED STATE         ESTA  RRE  C'\n   OPCODE.B24B = 'B24B LOAD USING REAL ADDRESS       LURA  RRE   '\n   OPCODE.B24C = 'B24C TEST ACCESS                   TAR   RRE  C'\n   OPCODE.B24D = 'B24D COPY ACCESS                   CPYA  RRE   '\n   OPCODE.B24E = 'B24E SET ACCESS                    SAR   RRE   '\n   OPCODE.B24F = 'B24F EXTRACT ACCESS                EAR   RRE   '\n   OPCODE.B252 = 'B252 MULTIPLY SINGLE               MSR   RRE   '\n   OPCODE.B254 = 'B254 MOVE PAGE (FACILITY 1)        MVPG  RRE  C'\n   OPCODE.B254 = 'B254 MOVE PAGE (FACILITY 2)        MVPG  RRE  C'\n   OPCODE.B255 = 'B255 MOVE STRING                   MVST  RRE  C'\n   OPCODE.B257 = 'B257 COMPARE UNTIL SUBSTRING EQUAL CUSE  RRE  C'\n   OPCODE.B258 = 'B258 BRANCH IN SUBSPACE GROUP      BSG   RRE   '\n   OPCODE.B25A = 'B25A BRANCH AND SET AUTHORITY      BSA   RRE   '\n   OPCODE.B25D = 'B25D COMPARE LOGICAL STRING        CLST  RRE  C'\n   OPCODE.B25E = 'B25E SEARCH STRING                 SRST  RRE  C'\n   OPCODE.B279 = 'B279 SET ADDR. SPACE CONTROL FAST  SACF  S     '\n   OPCODE.B6   = 'B6   STORE CONTROL                 STCTL RS    '\n   OPCODE.B7   = 'B7   LOAD CONTROL                  LCTL  RS    '\n   OPCODE.DA   = 'DA   MOVE TO PRIMARY               MVCP  SS   C'\n   OPCODE.DB   = 'DB   MOVE TO SECONDARY             MVCS  SS   C'\n   OPCODE.DC   = 'DC   TRANSLATE                     TR    SS    '\n   OPCODE.DD   = 'DD   TRANSLATE AND TEST            TRT   SS   C'\n   OPCODE.DE   = 'DE   EDIT                          ED    SS   C'\n   OPCODE.DF   = 'DF   EDIT AND MARK                 EDMK  SS   C'\n   OPCODE.D1   = 'D1   MOVE NUMERICS                 MVN   SS    '\n   OPCODE.D2   = 'D2   MOVE (CHARACTER)              MVC   SS    '\n   OPCODE.D3   = 'D3   MOVE ZONES                    MVZ   SS    '\n   OPCODE.D4   = 'D4   AND (CHARACTER)               NC    SS   C'\n   OPCODE.D5   = 'D5   COMPARE LOGICAL (CHARACTER)   CLC   SS   C'\n   OPCODE.D6   = 'D6   OR (CHARACTER)                OC    SS   C'\n   OPCODE.D7   = 'D7   EXCLUSIVE OR (CHARACTER)      XC    SS   C'\n   OPCODE.D9   = 'D9   MOVE WITH KEY                 MVCK  SS   C'\n   OPCODE.EE   = 'EE   PERFORM LOCKED OPERATION      PLO   SS   C'\n   OPCODE.E500 = 'E500 LOAD ADDRESS SPACE PARAMETERS LASP  SSE  C'\n   OPCODE.E501 = 'E501 TEST PROTECTION               TPROT SSE  C'\n   OPCODE.E50E = 'E50E MOVE WITH SOURCE KEY          MVCSK SSE   '\n   OPCODE.E50F = 'E50F MOVE WITH DESTINATION KEY     MVCDK SSE   '\n   OPCODE.E8   = 'E8   MOVE INVERSE                  MVCIN SS    '\n   OPCODE.FA   = 'FA   ADD DECIMAL                   AP    SS   C'\n   OPCODE.FB   = 'FB   SUBTRACT DECIMAL              SP    SS   C'\n   OPCODE.FC   = 'FC   MULTIPLY DECIMAL              MP    SS    '\n   OPCODE.FD   = 'FD   DIVIDE DECIMAL                DP    SS    '\n   OPCODE.F0   = 'F0   SHIFT AND ROUND DECIMAL       SRP   SS   C'\n   OPCODE.F1   = 'F1   MOVE WITH OFFSET              MVO   SS    '\n   OPCODE.F2   = 'F2   PACK                          PACK  SS    '\n   OPCODE.F3   = 'F3   UNPACK                        UNPK  SS    '\n   OPCODE.F8   = 'F8   ZERO AND ADD                  ZAP   SS   C'\n   OPCODE.F9   = 'F9   COMPARE DECIMAL               CP    SS   C'\n   OPCODE.0A   = '0A   SUPERVISOR CALL               SVC   RR    '\n   OPCODE.0B   = '0B   BRANCH AND SET MODE           BSM   RR    '\n   OPCODE.0C   = '0C   BRANCH AND SAVE AND SET MODE  BASSM RR    '\n   OPCODE.0D   = '0D   BRANCH AND SAVE               BASR  RR    '\n   OPCODE.0E   = '0E   MOVE LONG                     MVCL  RR   C'\n   OPCODE.0F   = '0F   COMPARE LOGICAL LONG          CLCL  RR   C'\n   OPCODE.0101 = '0101 PROGRAM RETURN                PR    E     '\n   OPCODE.0102 = '0102 UPDATE TREE                   UPT   E    C'\n   OPCODE.04   = '04   SET PROGRAM MASK              SPM   RR    '\n   OPCODE.05   = '05   BRANCH AND LINK               BALR  RR    '\n   OPCODE.06   = '06   BRANCH ON COUNT               BCTR  RR    '\n   OPCODE.07   = '07   BRANCH ON CONDITION           BCR   RR    '\n   OPCODE.1A   = '1A   ADD                           AR    RR   C'\n   OPCODE.1B   = '1B   SUBTRACT                      SR    RR   C'\n   OPCODE.1C   = '1C   MULTIPLY                      MR    RR    '\n   OPCODE.1D   = '1D   DIVIDE                        DR    RR    '\n   OPCODE.1E   = '1E   ADD LOGICAL                   ALR   RR   C'\n   OPCODE.1F   = '1F   SUBTRACT LOGICAL              SLR   RR   C'\n   OPCODE.10   = '10   LOAD POSITIVE                 LPR   RR   C'\n   OPCODE.11   = '11   LOAD NEGATIVE                 LNR   RR   C'\n   OPCODE.12   = '12   LOAD AND TEST                 LTR   RR   C'\n   OPCODE.13   = '13   LOAD COMPLEMENT               LCR   RR   C'\n   OPCODE.14   = '14   AND                           NR    RR   C'\n   OPCODE.15   = '15   COMPARE LOGICAL               CLR   RR   C'\n   OPCODE.16   = '16   OR                            OR    RR   C'\n   OPCODE.17   = '17   EXCLUSIVE OR                  XR    RR   C'\n   OPCODE.18   = '18   LOAD                          LR    RR    '\n   OPCODE.19   = '19   COMPARE                       CR    RR   C'\n   OPCODE.2A   = '2A   ADD NORMALIZED (LONG)         ADR   RR   C'\n   OPCODE.2B   = '2B   SUBTRACT NORMALIZED (LONG)    SDR   RR   C'\n   OPCODE.2C   = '2C   MULTIPLY (LONG)               MDR   RR    '\n   OPCODE.2D   = '2D   DIVIDE (LONG)                 DDR   RR    '\n   OPCODE.2E   = '2E   ADD UNNORMALIZED (LONG)       AWR   RR   C'\n   OPCODE.2F   = '2F   SUBTRACT UNNORMALIZED (LONG)  SWR   RR   C'\n   OPCODE.20   = '20   LOAD POSITIVE (LONG)          LPDR  RR   C'\n   OPCODE.21   = '21   LOAD NEGATIVE (LONG)          LNDR  RR   C'\n   OPCODE.22   = '22   LOAD AND TEST (LONG)          LTDR  RR   C'\n   OPCODE.23   = '23   LOAD COMPLEMENT (LONG)        LCDR  RR   C'\n   OPCODE.24   = '24   HALVE (LONG)                  HDR   RR    '\n   OPCODE.25   = '25   LOAD ROUNDED (EXT. TO LONG)   LRDR  RR    '\n   OPCODE.26   = '26   MULTIPLY (EXTENDED)           MXR   RR    '\n   OPCODE.27   = '27   MULTIPLY (LONG TO EXTENDED)   MXDR  RR    '\n   OPCODE.28   = '28   LOAD (LONG)                   LDR   RR    '\n   OPCODE.29   = '29   COMPARE (LONG)                CDR   RR   C'\n   OPCODE.3A   = '3A   ADD NORMALIZED (SHORT)        AER   RR   C'\n   OPCODE.3B   = '3B   SUBTRACT NORMALIZED (SHORT)   SER   RR   C'\n   OPCODE.3C   = '3C   MULTIPLY (SHORT TO LONG)      MER   RR    '\n   OPCODE.3D   = '3D   DIVIDE (SHORT)                DER   RR    '\n   OPCODE.3E   = '3E   ADD UNNORMALIZED (SHORT)      AUR   RR   C'\n   OPCODE.3F   = '3F   SUBTRACT UNNORMALIZED (SHORT) SUR   RR   C'\n   OPCODE.30   = '30   LOAD POSITIVE (SHORT)         LPER  RR   C'\n   OPCODE.31   = '31   LOAD NEGATIVE (SHORT)         LNER  RR   C'\n   OPCODE.32   = '32   LOAD AND TEST (SHORT)         LTER  RR   C'\n   OPCODE.33   = '33   LOAD COMPLEMENT (SHORT)       LCER  RR   C'\n   OPCODE.34   = '34   HALVE (SHORT)                 HER   RR    '\n   OPCODE.35   = '35   LOAD ROUNDED (LONG TO SHORT)  LRER  RR    '\n   OPCODE.36   = '36   ADD NORMALIZED (EXTENDED)     AXR   RR   C'\n   OPCODE.37   = '37   SUBTRACT NORMALIZED (EXT.)    SXR   RR   C'\n   OPCODE.38   = '38   LOAD (SHORT)                  LER   RR    '\n   OPCODE.39   = '39   COMPARE (SHORT)               CER   RR   C'\n   OPCODE.4A   = '4A   ADD HALFWORD                  AH    RX   C'\n   OPCODE.4B   = '4B   SUBTRACT HALFWORD             SH    RX   C'\n   OPCODE.4C   = '4C   MULTIPLY HALFWORD             MH    RX    '\n   OPCODE.4D   = '4D   BRANCH AND SAVE               BAS   RX    '\n   OPCODE.4E   = '4E   CONVERT TO DECIMAL            CVD   RX    '\n   OPCODE.4F   = '4F   CONVERT TO BINARY             CVB   RX    '\n   OPCODE.40   = '40   STORE HALFWORD                STH   RX    '\n   OPCODE.41   = '41   LOAD ADDRESS                  LA    RX    '\n   OPCODE.42   = '42   STORE CHARACTER               STC   RX    '\n   OPCODE.43   = '43   INSERT CHARACTER              IC    RX    '\n   OPCODE.44   = '44   EXECUTE                       EX    RX    '\n   OPCODE.45   = '45   BRANCH AND LINK               BAL   RX    '\n   OPCODE.46   = '46   BRANCH ON COUNT               BCT   RX    '\n   OPCODE.47   = '47   BRANCH ON CONDITION           BC    RX    '\n   OPCODE.48   = '48   LOAD HALFWORD                 LH    RX    '\n   OPCODE.49   = '49   COMPARE HALFWORD              CH    RX   C'\n   OPCODE.5A   = '5A   ADD                           A     RX   C'\n   OPCODE.5B   = '5B   SUBTRACT                      S     RX   C'\n   OPCODE.5C   = '5C   MULTIPLY                      M     RX    '\n   OPCODE.5D   = '5D   DIVIDE                        D     RX    '\n   OPCODE.5E   = '5E   ADD LOGICAL                   AL    RX   C'\n   OPCODE.5F   = '5F   SUBTRACT LOGICAL              SL    RX   C'\n   OPCODE.50   = '50   STORE                         ST    RX    '\n   OPCODE.51   = '51   LOAD ADDRESS EXTENDED         LAE   RX    '\n   OPCODE.54   = '54   AND                           N     RX   C'\n   OPCODE.55   = '55   COMPARE LOGICAL               CL    RX   C'\n   OPCODE.56   = '56   OR                            O     RX   C'\n   OPCODE.57   = '57   EXCLUSIVE OR                  X     RX   C'\n   OPCODE.58   = '58   LOAD                          L     RX    '\n   OPCODE.59   = '59   COMPARE                       C     RX   C'\n   OPCODE.6A   = '6A   ADD NORMALIZED (LONG)         AD    RX   C'\n   OPCODE.6B   = '6B   SUBTRACT NORMALIZED (LONG)    SD    RX   C'\n   OPCODE.6C   = '6C   MULTIPLY (LONG)               MD    RX    '\n   OPCODE.6D   = '6D   DIVIDE (LONG)                 DD    RX    '\n   OPCODE.6E   = '6E   ADD UNNORMALIZED (LONG)       AW    RX   C'\n   OPCODE.6F   = '6F   SUBTRACT UNNORMALIZED (LONG)  SW    RX   C'\n   OPCODE.60   = '60   STORE (LONG)                  STD   RX    '\n   OPCODE.67   = '67   MULTIPLY (LONG TO EXTENDED)   MXD   RX    '\n   OPCODE.68   = '68   LOAD (LONG)                   LD    RX    '\n   OPCODE.69   = '69   COMPARE (LONG)                CD    RX   C'\n   OPCODE.7A   = '7A   ADD NORMALIZED (SHORT)        AE    RX   C'\n   OPCODE.7B   = '7B   SUBTRACT NORMALIZED (SHORT)   SE    RX   C'\n   OPCODE.7C   = '7C   MULTIPLY (SHORT TO LONG)      ME    RX    '\n   OPCODE.7D   = '7D   DIVIDE (SHORT)                DE    RX    '\n   OPCODE.7E   = '7E   ADD UNNORMALIZED (SHORT)      AU    RX   C'\n   OPCODE.7F   = '7F   SUBTRACT UNNORMALIZED (SHORT) SU    RX   C'\n   OPCODE.70   = '70   STORE (SHORT)                 STE   RX    '\n   OPCODE.71   = '71   MULTIPLY SINGLE               MS    RX    '\n   OPCODE.78   = '78   LOAD (SHORT)                  LE    RX    '\n   OPCODE.79   = '79   COMPARE (SHORT)               CE    RX   C'\n   OPCODE.8A   = '8A   SHIFT RIGHT SINGLE            SRA   RS   C'\n   OPCODE.8B   = '8B   SHIFT LEFT SINGLE             SLA   RS   C'\n   OPCODE.8C   = '8C   SHIFT RIGHT DOUBLE LOGICAL    SRDL  RS    '\n   OPCODE.8D   = '8D   SHIFT LEFT DOUBLE LOGICAL     SLDL  RS    '\n   OPCODE.8E   = '8E   SHIFT RIGHT DOUBLE            SRDA  RS   C'\n   OPCODE.8F   = '8F   SHIFT LEFT DOUBLE             SLDA  RS   C'\n   OPCODE.80   = '80   SET SYSTEM MASK               SSM   S     '\n   OPCODE.82   = '82   LOAD PSW                      LPSW  S     '\n   OPCODE.83   = '83   DIAGNOSE                                  '\n   OPCODE.84   = '84   BRANCH RELATIVE ON INDEX HIGH BRXH  RSI   '\n   OPCODE.85   = '85   BRANCH RELATIVE ON INDEX L.E. BRXLE RSI   '\n   OPCODE.86   = '86   BRANCH ON INDEX HIGH          BXH   RS    '\n   OPCODE.87   = '87   BRANCH ON INDEX LOW OR EQUAL  BXLE  RS    '\n   OPCODE.88   = '88   SHIFT RIGHT SINGLE LOGICAL    SRL   RS    '\n   OPCODE.89   = '89   SHIFT LEFT SINGLE LOGICAL     SLL   RS    '\n   OPCODE.9A   = '9A   LOAD ACCESS MULTIPLE          LAM   RS    '\n   OPCODE.9B   = '9B   STORE ACCESS MULTIPLE         STAM  RS    '\n   OPCODE.90   = '90   STORE MULTIPLE                STM   RS    '\n   OPCODE.91   = '91   TEST UNDER MASK               TM    SI   C'\n   OPCODE.92   = '92   MOVE (IMMEDIATE)              MVI   SI    '\n   OPCODE.93   = '93   TEST AND SET                  TS    S    C'\n   OPCODE.94   = '94   AND (IMMEDIATE)               NI    SI   C'\n   OPCODE.95   = '95   COMPARE LOGICAL (IMMEDIATE)   CLI   SI   C'\n   OPCODE.96   = '96   OR (IMMEDIATE)                OI    SI   C'\n   OPCODE.97   = '97   EXCLUSIVE OR (IMMEDIATE)      XI    SI   C'\n   OPCODE.98   = '98   LOAD MULTIPLE                 LM    RS    '\n   OPCODE.99   = '99   TRACE                         TRACE RS    '\n   DO WHILE CODE = ''\n       SAY \"PLEASE ENTER OP CODE (EG 41):\"\n       PULL CODE\n       SAVMSG = ''\n   END\n   IF OPCODE.CODE <> ''\n       THEN DO\n           SAY 'OP CODE '''CODE''' IS' SUBSTR(OPCODE.CODE,06,29)\n           SAY '    WITH MNEMONIC' SUBSTR(OPCODE.CODE,36,05),\n               '    AND IS A(N)  ' SUBSTR(OPCODE.CODE,42,04),\n               'INSTRUCTION'\n           IF SUBSTR(OPCODE.CODE,47,1) = 'C'\n              THEN SAY '    AND SETS A CONDITION CODE'\n       END\n       ELSE DO\n           SAY 'OP CODE '''CODE''' NOT FOUND IN CURRENT TABLE...'\n       END\n   EXIT(1)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"OPCODE - DESCRIBE HEX ASSEMBLER INSTRUCTION              \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    OPCODE  ##                                           \"\n   SAY\n   SAY \"       WILL PROVIDE A SHORT DESCRIPTION OF THE OPERATION \"\n   SAY \"       CODE INPUT AS A HEX VALUE.                        \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    OPCODE  90                                           \"\n   SAY\n   SAY \"       OP CODE '90' IS STORE MULTIPLE                    \"\n   SAY \"           WITH MNEMONIC STM AND IS A(N) RS INSTRUCTION  \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PA": {"ttr": 29701, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00R\\x00R\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 82, "newlines": 82, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- Place lines from the default clipboard after multiple   **/\n/***         lines in the current file                                */\n\n   Address ISPEXEC\n   'ISREDIT MACRO (PARM1) NOPROCESS'\n   Parm1 = translate(Parm1)\n   If Parm1 = '?' then signal DispDoc\n\n   If  datatype(Parm1,'W')  then  Skip_Value = Parm1\n                            else  Skip_Value = 1\n\n   'ISREDIT PROCESS RANGE C'\n   Select\n       When rc = 0 then do\n            'ISREDIT (ZDEST1) = LINENUM .ZFRANGE'\n            'ISREDIT (ZDEST2) = LINENUM .ZLRANGE'\n       End\n       When rc <= 8 then do\n            zedsmsg = 'Enter \"C/CC\" line cmds'\n            zedlmsg = 'PA requires a \"C\" or \"CC\" line command'\n            'SETMSG MSG(ISRZ001)'\n            Exit(12)\n       End\n       When rc < 20 then\n           Exit 12\n       When rc = 20 then\n           zdest = 0\n       Otherwise Exit 12\n   End\n\n   if  ( ZDest2 - ZDest1 ) // Skip_Value <> 0\n      then ZDest2 = ZDest2 - ( ( ZDest2 - ZDest1 ) // Skip_Value )\n   DATA        = \"...\"\n   CutCount    = -1\n   TimesPasted = 0\n   Do ZDest = ZDest2 to ZDest1 by -Skip_Value\n      \"ISREDIT LINE_AFTER &ZDEST = (DATA)\"\n      ii = ZDest + 1\n      \"ISREDIT LABEL\" ii \"= .HERE\"\n      If CutCount = -1 then do\n         \"ISREDIT LINE_AFTER\" ii \"= (DATA)\"\n         jj = ii + 1\n         \"ISREDIT LABEL\" jj \"= .THERE\"\n      End\n      Address ISREDIT \"PASTE AFTER .HERE KEEP\"\n      If RC = 12 then do\n         zedsmsg = 'No \"CUT\" data'\n         zedlmsg = 'There is no data to \"PASTE\" from the ISPF' ,\n                   'Default Clipboard.'\n         Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n         Exit 12\n      End\n      TimesPasted = TimesPasted + 1\n      If CutCount = -1 then do\n         \"ISREDIT (ii) = LINENUM .HERE\"\n         \"ISREDIT (jj) = LINENUM .THERE\"\n         CutCount = jj - ii - 1\n         \"ISREDIT DELETE .THERE .THERE\"\n      End\n      \"ISREDIT DELETE .HERE .HERE\"\n   End\n\n   zedsmsg = CutCount 'lines pasted' TimesPasted 'times'\n   zedlmsg = CutCount 'lines were pasted into the current file',\n      TimesPasted 'times'\n   'SETMSG MSG(ISRZ000)'\n   'ISREDIT CURSOR =' ZDest1 0\n   Exit(0)\n\nDispDoc:\n   ADDRESS TSO \"CLEAR\"\n   Say\n   Say ' PA will place cut lines from the PROFILE pool after           '\n   Say ' one or more lines in the current file.                        '\n   Say\n   Say '     PA  ( Skip#Lines )                                        '\n   Say\n   Say ' Enter PA on the COMMAND line and use C or CC range line       '\n   Say ' command to specify where the lines are to be pasted. A number '\n   Say ' of lines to skip may also be specified, 1 is the default.     '\n   Say\n   Exit(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PACKDS": {"ttr": 29704, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\xd6\\x00\\xd6\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 214, "newlines": 214, "modlines": 0, "user": "REXX"}, "text": "  /*-REXX----------------------- PACKDS -----------------------REXX-*/\n  /*                                                                */\n  /* Call TRSMAIN to Pack or Terse a dataset so that it is smaller  */\n  /* and of fixed attributes prior to FTP'ing offsite or whatever.  */\n  /*                                                                */\n  /* Syntax:  %PACKDS input-DSN output-DSN          (Both optional) */\n  /*                                                                */\n  /*----------------------------------------------------------------*/\n\naddress TSO\n\"subcom ISPEXEC\"; if RC=0 then SPF=1; else SPF=0\ncall   on error   name RXERROR         /* Activate command ERROR trap */\nsignal on syntax  name RXERROR                /* Activate SYNTAX trap */\nsignal on novalue name RXERROR               /* Activate NOVALUE trap */\n\narg INDS OUTDS                                 /* Retrieve input args */\n\nif length(INDS) = 0 | length(OUTDS) = 0 then do\n   if length(INDS) = 0 then CURPOS = 'INDS'; else CURPOS = 'OUTDS'\n   OK = '8'\n   address ISPEXEC \"display panel(PACKDS)\"   /* Display PACKDS panels */\n   drop OK\n   if RC <> 0 then exit 0\nend\n\nTP = sysvar('SYSPREF')                                  /* TSO Prefix */\nif left(INDS,1) = \"'\" then do\n   if right(INDS,1) = \"'\" then nop\n   else INDS = INDS\"'\"\nend\nelse if left(INDS,length(TP)+1) = TP||'.' then INDS = \"'\"INDS\"'\"\n\nif left(OUTDS,1) = \"'\" then do\n   if right(OUTDS,1) = \"'\" then nop\n   else OUTDS = OUTDS\"'\"\nend\nelse if left(OUTDS,length(TP)+1) = TP||'.' then OUTDS = \"'\"OUTDS\"'\"\n\nX = msg(\"OFF\")\nOK = 'ALL'\n\"free dd(INFILE OUTFILE SYSPRINT)\"              /* Free required DD's */\n\"DEL\" OUTDS                                  /* Delete output dataset */\ndrop OK\nX = msg(\"ON\")\n\ncall LISTDSI INDS                /* Retrieve input dataset alloc info */\n\nif SYSDSSMS = 'PDSE' | pos('LIBRARY',SYSDSSMS) > 0 then do\n   say '-----------------------------------------------------'\n   say 'PDSE datasets are not supported.'\n   say\n   say 'Please convert the dataset to a PDS and then pack it.'\n   say '-----------------------------------------------------'\n   ZISPFRC = 8\n   if SPF then address ISPEXEC \"vput (ZISPFRC) shared\"\n   exit ZISPFRC\nend\nSA = SYSALLOC                                      /* Space allocated */\nSS = SYSSECONDS                             /* Secondary alloc amount */\n\nif left(SYSUNITS,1) = \"C\" then do        /* If CYL, convert to tracks */\n   SA = SYSALLOC * 15\n   SS = SYSSECONDS * 15\n   SU = \"TR\"\nend\nelse SU = \"TR\"\n\n\"alloc dd(INFILE) shr reuse ds(\"INDS\")\" /* Allocate input/output dsets*/\n\"alloc dd(OUTFILE) ds(\"OUTDS\") new catalog release reuse \"||,\n       \"space(\"SA\",\"SS\")\" SU \"dsorg(PS) lrecl(1024) recfm(F B) \"||,\n       \"blksize(0)\"\n\"alloc dd(SYSPRINT) ds(*) reuse\"     /* Allocate SYSPRINT to terminal */\n\n                       /* Modify call stmt if TRSMAIN not in LINKLIST */\n\"call *(TRSMAIN) 'SPACK'\"                             /* Call TRSMAIN */\n\n\"free dd(INFILE OUTFILE SYSPRINT)\"                       /* Free DD's */\n\nZISPFRC = 0\nif SPF then address ISPEXEC \"vput (ZISPFRC) shared\"\nexit ZISPFRC                                            /* All Done ! */\n\n/*====================================================================*/\n/*                       SUBROUTINES/FUNCTIONS                        */\n/*====================================================================*/\n\n  /*---------------------------- RXERROR ---------------------------*/\n  /*                                                                */\n  /* REXX error condition handler. The routine gets control when a  */\n  /* error condition is raised, and:                                */\n  /*                                                                */\n  /* A. Validates the error condition is OK and if so, returns      */\n  /*    quietly, or                                                 */\n  /*                                                                */\n  /* B. Issues diagnostics messages about the error and where it    */\n  /*    occurred, then exits passing the failed RC to the original  */\n  /*    caller.                                                     */\n  /*                                                                */\n  /* To use this routine, code the following near the top of the    */\n  /* exec:                                                          */\n  /*                                                                */\n  /*   call   on error   name RXERROR                               */\n  /*   signal on syntax  name RXERROR                               */\n  /*   signal on novalue name RXERROR                               */\n  /*                                                                */\n  /* For those Host commands where a failure is possible set the    */\n  /* variable 'OK' to any Return Codes that are acceptable for the  */\n  /* Host command.  For example:                                    */\n  /*                                                                */\n  /*   OK='8';   \"host cmd\"; drop OK <- RC 8 is acceptable.         */\n  /*   OK='4 8'; \"host cmd\"; drop OK <- RC's 4 or 8 are acceptable. */\n  /*   OK='ALL'; \"host cmd\"; drop OK <- ALL RC's are acceptable.    */\n  /*                                                                */\n  /*----------------------------------------------------------------*/\n  /* NOTE: This subroutine does NOT use the PROCEDURE instruction,  */\n  /*       so all variables created within it must be *hidden*, ie. */\n  /*       unique.                                                  */\n  /*----------------------------------------------------------------*/\n\nRXERROR: trace N\naddress TSO\ncall   off error\nsignal off syntax\nsignal off novalue\n_SIGL=SIGL\nif symbol('RC') = 'VAR' then _RC = RC; else _RC = 'N/A'\n\"subcom ISPEXEC\"; if RC=0 then _SPF=1; else _SPF=0\nparse source . . _EXNAME .\n_ERRORTXT = ''\n\nif condition('I') = 'CALL' then ,\n   if symbol('OK') = 'VAR' then ,\n      if wordpos(_RC,OK)>0 | translate(OK)='ALL' then do\n         call   on error   name RXERROR\n         signal on syntax  name RXERROR\n         signal on novalue name RXERROR\n         drop ZERRLM ZERRMSG ZERRSM\n         RC = _RC\n         return\n      end\n      else nop\n\nselect\n   when pos(condition('C'),'ERROR FAILURE') > 0 then do\n      _CMD = strip(strip(word(condition('D'),1),'B','\"'),'B',\"'\")\n      _ERRORTXT = '(Host command: '_CMD')'\n      say 'RXERROR-> RC: '_RC' '_ERRORTXT' at line: '_SIGL ||,\n          ' in EXEC: '_EXNAME\n      if _SIGL <= sourceline() then do\n         say ' '\n         say 'RXERROR-> Line '_SIGL': 'strip(sourceline(_SIGL))\n      end\n      if datatype(_RC,'N') then ,\n         if abs(_RC) > 7 then ZISPFRC = abs(_RC)\n         else ZISPFRC = 8\n      else ZISPFRC = 8\n      if _SPF then address ISPEXEC \"vput (ZISPFRC) shared\"\n      exit ZISPFRC\n   end\n\n   when condition('C') = 'SYNTAX' then do\n      if datatype(_RC,'N') = 1 then ,\n         if (_RC >= 0 & _RC < 100) then _ERRORTXT = '('errortext(_RC)')'\n         else nop\n      say 'RXERROR-> RC: '_RC' '_ERRORTXT' at line: '_SIGL ||,\n          ' in EXEC: '_EXNAME\n      if _SIGL <= sourceline() then do\n         say ' '\n         say 'RXERROR-> Line '_SIGL': 'strip(sourceline(_SIGL))\n      end\n      if datatype(_RC,'N') then ,\n         if abs(_RC) > 7 then ZISPFRC = abs(_RC)\n         else ZISPFRC = 8\n      else ZISPFRC = 8\n      if _SPF then address ISPEXEC \"vput (ZISPFRC) shared\"\n      exit ZISPFRC\n   end\n\n   when condition('C') = 'NOVALUE' then do\n      _ERRORTXT = '(No value for variable: 'condition('D')')'\n      say 'RXERROR-> RC: '_RC' '_ERRORTXT' at line: '_SIGL ||,\n          ' in EXEC: '_EXNAME\n      if _SIGL <= sourceline() then do\n         say ' '\n         say \"RXERROR-> Line \"_SIGL\": \"strip(sourceline(_SIGL))\n      end\n      if datatype(_RC,'N') then ,\n         if abs(_RC) > 7 then ZISPFRC = abs(_RC)\n         else ZISPFRC = 8\n      else ZISPFRC = 8\n      if _SPF then address ISPEXEC \"vput (ZISPFRC) shared\"\n      exit ZISPFRC\n   end\n\n   otherwise condition('C') <> '' then do\n      _ERRORTXT = '(Condition='condition('C')', Description=' ||,\n                  condition('D')')'\n      say 'RXERROR-> RC: '_RC' '_ERRORTXT' at line: '_SIGL ||,\n          ' in EXEC: '_EXNAME\n      if _SIGL <= sourceline() then do\n         say ' '\n         say \"RXERROR-> Line \"_SIGL\": \"strip(sourceline(_SIGL))\n      end\n      if datatype(_RC,'N') then ,\n         if abs(_RC) > 7 then ZISPFRC = abs(_RC)\n         else ZISPFRC = 8\n      else ZISPFRC = 8\n      if _SPF then address ISPEXEC \"vput (ZISPFRC) shared\"\n      exit ZISPFRC\n   end\nend\nZISPFRC = 8                                  /* Should NEVER get here */\nif _SPF then address ISPEXEC \"vput (ZISPFRC) shared\"\nexit ZISPFRC                                      /* but just case... */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAGES": {"ttr": 29709, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xdc\\x00\\xdc\\x00\\x00\\xd7\\xc1\\xc7\\xc5\\xe2@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 220, "newlines": 220, "modlines": 0, "user": "PAGES"}, "text": "//-YOUR-USERID-P JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  ALLOW STRIPPING OF FIRST, MIDDLE, LAST OR FROM/TO # OF ASCII\n//***  CONTROL DELIMITED PAGES FROM A SEQUENTIAL FILE\n//***\n//C          EXEC     PGM=IEL0AA,REGION=4M,\n//             PARM=('AG,A,NCT,ESD,F(I),NOFLOW,NIS,NOLIST,M,NMI,NEST',\n//             'MAP,OF,OPT(TIME),OP,SZ(MAX),S,STMT,STG,X(F)')\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-PLI-LIB-\n\n PAGES: PROC OPTIONS(MAIN) REORDER;\n\n        DCL  INFILE    FILE INPUT RECORD SEQL;\n        DCL  REC       CHAR(32760) STATIC VARYING;\n        DCL  INFILE_EOF_IND CHAR(01) STATIC INIT('N');\n        DCL  OK_SO_FAR     CHAR(01) STATIC INIT('Y');\n        DCL  ONLY_1ST      CHAR(01) STATIC INIT('N');\n        DCL  REC#1         CHAR(01) STATIC INIT('N');\n\n        DCL  FIRST         FIXED BIN(31) STATIC INIT(-1);\n        DCL  MIDDLE        FIXED BIN(31) STATIC INIT(-1);\n        DCL  MIDDLE#1      FIXED BIN(31) STATIC INIT(0);\n        DCL  MIDDLE#2      FIXED BIN(31) STATIC INIT(0);\n        DCL  LAST          FIXED BIN(31) STATIC INIT(-1);\n        DCL  LAST#         FIXED BIN(31) STATIC INIT(0);\n        DCL  FROM          FIXED BIN(31) STATIC INIT(-1);\n        DCL  TO            FIXED BIN(31) STATIC INIT(-1);\n\n        DCL  RECORDS#      FIXED BIN(31) STATIC INIT(0);\n        DCL  RECORDS_OUT#  FIXED BIN(31) STATIC INIT(0);\n        DCL  PAGES#        FIXED BIN(31) STATIC INIT(0);\n        DCL  PAGES_OUT#    FIXED BIN(31) STATIC INIT(0);\n        DCL  PG            FIXED BIN(31) STATIC INIT(0);\n\n        DCL  DATE      BUILTIN;\n        DCL  TIME      BUILTIN;\n\n\n        CALL FIGURE_REQUEST;\n\n        IF OK_SO_FAR = 'Y' THEN CALL REVIEW_INPUT;\n\n        IF OK_SO_FAR = 'Y' THEN CALL PULL_OFF_REQUEST;\n\n        CALL TERMINATION;\n\n\n FIGURE_REQUEST: PROC;\n        GET DATA;\n        IF FIRST = -1 & MIDDLE = -1 & LAST = -1 & FROM = -1 & TO = -1\n           THEN DO;\n              OK_SO_FAR = 'N';\n              CALL PLIRETC(08);\n              PUT EDIT ( '**  ERROR  **   NO RANGE SELECTED' )\n                       ( SKIP(2), A );\n              PUT EDIT ( '**    IN SYSIN FILE, SPECIFY:    ' )\n                       ( SKIP(1), A );\n              PUT EDIT ( '**      FIRST=###                ' )\n                       ( SKIP(1), A );\n              PUT EDIT ( '**      MIDDLE=###               ' )\n                       ( SKIP(1), A );\n              PUT EDIT ( '**      LAST=###                 ' )\n                       ( SKIP(1), A );\n              PUT EDIT ( '**      FROM=###,TO=###          ' )\n                       ( SKIP(1), A );\n              PUT EDIT ( '**        OR SOME COMBINATION... ' )\n                       ( SKIP(1), A );\n              END;\n           ELSE DO;\n              IF ( FROM \u00ac= -1 & TO = -1 ) | ( FROM = -1 & TO \u00ac= -1 )\n                 THEN DO;\n                    OK_SO_FAR = 'N';\n                    CALL PLIRETC(08);\n                    PUT EDIT ( '**  ERROR  **   FROM/TO RANGE NOT',\n                               ' CONSISTENT' )\n                             ( SKIP(2), A, A );\n                    PUT EDIT ( '**    SPECIFY BOTH OR NEITHER... ' )\n                             ( SKIP(1), A );\n                    END;\n              END;\n        IF FIRST \u00ac= -1 & MIDDLE = -1 & LAST = -1 & FROM = -1 & TO = -1\n           THEN ONLY_1ST = 'Y';\n        END FIGURE_REQUEST;\n\n REVIEW_INPUT: PROC;\n        IF ONLY_1ST = 'N'\n           THEN DO;\n              OPEN FILE(INFILE);\n              INFILE_EOF_IND = 'N';\n              ON ENDFILE(INFILE) INFILE_EOF_IND = 'Y';\n              REC#1 = 'Y';\n              READ FILE(INFILE) INTO(REC);\n              DO WHILE ( INFILE_EOF_IND = 'N' );\n                 RECORDS# = RECORDS# + 1;\n                 IF SUBSTR(REC,1,1) = '1' | REC#1 = 'Y'\n                    THEN PAGES# = PAGES# + 1;\n                 READ FILE(INFILE) INTO(REC);\n                 REC#1 = 'N';\n                 END;\n              CLOSE FILE(INFILE);\n              IF PAGES# = 0\n                 THEN DO;\n                    OK_SO_FAR = 'N';\n                    CALL PLIRETC(04);\n                    PUT EDIT ( '**  ERROR  **   NO PAGES IN INPUT',\n                               ' FILE' )\n                             ( SKIP(2), A, A );\n                    PUT EDIT ( '**    PLEASE CHECK INPUT... ' )\n                             ( SKIP(1), A );\n                    END;\n              END;\n        IF MIDDLE \u00ac= -1\n           THEN DO;\n              IF MIDDLE < ( PAGES# - 2 )\n                 THEN DO;\n                    MIDDLE#1 = ( ( PAGES# - MIDDLE ) / 2 ) + 1;\n                    MIDDLE#2 = MIDDLE#1 + MIDDLE - 1;\n                    END;\n                 ELSE DO;\n                    MIDDLE#1 = MIDDLE;\n                    MIDDLE#2 = MIDDLE#1;\n                    END;\n              END;\n        IF LAST \u00ac= -1\n           THEN DO;\n              LAST# = PAGES# - LAST + 1;\n              END;\n        END REVIEW_INPUT;\n\n PULL_OFF_REQUEST: PROC;\n        INFILE_EOF_IND = 'N';\n        ON ENDFILE(INFILE) INFILE_EOF_IND = 'Y';\n        REC#1 = 'Y';\n        PG = 1;\n        OPEN FILE(INFILE);\n        READ FILE(INFILE) INTO(REC);\n        DO WHILE ( INFILE_EOF_IND = 'N' );\n           IF FIRST \u00ac= -1 & PG <= FIRST\n              THEN CALL WRITE_IT;\n              ELSE IF MIDDLE \u00ac= -1 & PG >= MIDDLE#1 & PG <= MIDDLE#2\n                 THEN CALL WRITE_IT;\n                 ELSE IF LAST \u00ac= -1 & PG >= LAST#\n                    THEN CALL WRITE_IT;\n                    ELSE IF FROM \u00ac= -1 & PG >= FROM & PG <= TO\n                       THEN CALL WRITE_IT;\n           READ FILE(INFILE) INTO(REC);\n           REC#1 = 'N';\n           IF SUBSTR(REC,1,1) = '1'\n              THEN PG = PG + 1;\n           END;\n        END PULL_OFF_REQUEST;\n\n WRITE_IT: PROC;\n        RECORDS_OUT# = RECORDS_OUT# + 1;\n        WRITE FILE(OUTFILE) FROM(REC);\n        IF REC#1 = 'Y' | SUBSTR(REC,1,1) = '1'\n           THEN PAGES_OUT# = PAGES_OUT# + 1;\n        END WRITE_IT;\n\n TERMINATION: PROC;\n        PUT EDIT ( '**************************************' )\n                 ( SKIP(1), A );\n        PUT EDIT ( '***  ', DATE, ' STATISTICS ', TIME, '  ****' )\n                 ( SKIP(1), A, A, A, A, A );\n        PUT EDIT ( '**************************************' )\n                 ( SKIP(1), A );\n        IF PAGES# > 0\n           THEN PUT EDIT ( '** TOTAL PAGES ON FILE:      ', PAGES#   )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        IF RECORDS# > 0\n           THEN PUT EDIT ( '** TOTAL RECORDS ON FILE:    ', RECORDS# )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        IF FIRST > 0\n           THEN PUT EDIT ( '** FIRST PAGES SELECTED:     ', FIRST    )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        IF MIDDLE > 0\n           THEN PUT EDIT ( '** MIDDLE PAGES SELECTED:    ', MIDDLE   )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        IF LAST > 0\n           THEN PUT EDIT ( '** LAST PAGES SELECTED:      ', LAST     )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        IF FROM > 0\n           THEN DO;\n              PUT EDIT ( '** PAGE RANGE SELECTED FROM: ', FROM     )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n              PUT EDIT ( '**                      TO:  ', TO       )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n              END;\n        IF PAGES_OUT# > 0\n           THEN PUT EDIT ( '** TOTAL PAGES SELECTED:     ', PAGES_OUT# )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        IF RECORDS_OUT# > 0\n           THEN PUT EDIT ( '** TOTAL LINES SELECTED:     ',\n                           RECORDS_OUT# )\n                 ( SKIP(2), A, P'Z,ZZZ,ZZ9' );\n        END TERMINATION;\n\n        END PAGES;\n\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(CYL,(05,02))\n//***\n//L          EXEC     PGM=HEWLKED,COND=(5,LT),\n//             PARM='XREF,LIST,LET,DCBS,AMODE=31,RMODE=ANY',\n//             REGION=4M\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE)\n//             DD       *\n  SETSSI   00031700\n  ENTRY    PLISTART\n  NAME     PAGES(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAGES$": {"ttr": 29957, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x14\\x00\\x14\\x00\\x00\\xd7\\xc1\\xc7\\xc5\\xe2@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "PAGES"}, "text": "//-YOUR-USERID-P JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  STRIP FIRST, MIDDLE, LAST OR FROM/TO # OF ASCII\n//***  CONTROL DELIMITED PAGES FROM A SEQUENTIAL FILE\n//***\n//CLEANUP    EXEC       PGM=IEFBR14\n//DEL01        DD         DSN=...,\n//             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n//***\n//SELPAGES   EXEC     PGM=PAGES,REGION=4M\n//INFILE       DD       DISP=SHR,DCB=BUFNO=24,\n//             DSN=...\n  FIRST=50,     LAST=-1,      MIDDLE=-1,     FROM=-1,      TO=-1;\n//OUTFILE      DD       DSN=...,\n//             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(05,02),RLSE),\n//             DCB=(BUFNO=24,RECFM=FBA,LRECL=00143)\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSPRINT     DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PASTEAFT": {"ttr": 29959, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00k\\x00k\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 107, "newlines": 107, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- Place lines from the user profile pool after multiple   **/\n/***         lines in the current file                                */\n\n   Address ISPEXEC\n   'ISREDIT MACRO (PARM1 PARM2) NOPROCESS'\n   Parm1 = translate(Parm1)\n   Parm2 = translate(Parm2)\n   If Parm1 = '?' | Parm2 = '?' then signal DispDoc\n\n   skip_value = 1\n   If  datatype(Parm1,'W')  |  datatype(Parm2,'W') then do\n       If datatype(Parm1,'W') then do\n           Skip_Value = Parm1\n           If  Parm2 = 'D'  |  Parm2 = 'DELETE'  then Parm1 = Parm2\n                                                 Else Parm1 = ''\n       End\n       Else Skip_Value = Parm2\n   End\n\n   If  parm1 <> ''  &  parm1 <> 'D'  &  parm1 <> 'DELETE'  then do\n       zedsmsg = 'Invalid parameter'\n       zedlmsg = 'Use ? for help, D or DELETE to cause line(s) deletion'\n       'SETMSG MSG(ISRZ001)'\n       Exit(12)\n   End\n\n   'CONTROL ERRORS RETURN'\n   'ISREDIT PROCESS RANGE C'\n   Select\n       When rc = 0 then do\n            'ISREDIT (ZDEST1) = LINENUM .ZFRANGE'\n            'ISREDIT (ZDEST2) = LINENUM .ZLRANGE'\n       End\n       When rc <= 8 then do\n            zedsmsg = 'Enter \"C/CC\" line cmds'\n            zedlmsg = 'PASTEAFT requires a \"C\" or \"CC\" line command'\n            'SETMSG MSG(ISRZ001)'\n            Exit(12)\n       End\n       When rc < 20 then\n           Exit 12\n       When rc = 20 then\n           zdest = 0\n       Otherwise Exit 12\n   End\n   'CONTROL ERRORS CANCEL'\n\n   'VGET (CUTCNT) PROFILE'\n   If rc <> 0 | CutCnt <= 0 then do\n       zedsmsg = 'Use CUTX before PASTEAFT'\n       zedlmsg = 'Use CUTX first before attempting to use PASTEAFT'\n       'SETMSG MSG(ISRZ001)'\n       Exit(12)\n   End\n\n   TruncCnt = 0\n   CutCount = CutCnt\n   if  ( ZDest2 - ZDest1 ) // Skip_Value <> 0\n      then ZDest2 = ZDest2 - ( ( ZDest2 - ZDest1 ) // Skip_Value )\n   Do ZDest = ZDest2 to ZDest1 by -Skip_Value\n      Do i = CutCnt to 1 by -1\n        'VGET (CL'i') PROFILE'\n        'ISREDIT LINE_AFTER' ZDest '= DATALINE (CL'i')'\n        If rc = 4 then TruncCnt = TruncCnt + 1\n      End\n   End\n\n   If Parm1 = 'D' | Parm1 = 'DELETE' then do\n       Do i = 1 to CutCnt by 1\n         'VERASE (CL'i') PROFILE'\n       End\n       CutCnt   = 0\n       'VPUT (CUTCNT) PROFILE'\n   End\n\n   If TruncCnt > 0 then do\n       zedsmsg = TruncCnt 'lines truncated'\n       msg     = 'Current record length shorter than origin'\n       zedlmsg = msg '-' TruncCnt 'of' CutCount 'records truncated'\n       'SETMSG MSG(ISRZ001)'\n   End\n   Else do\n       zedsmsg = CutCount 'lines pasted'\n       zedlmsg = CutCount 'lines were pasted into the current file'\n       'SETMSG MSG(ISRZ000)'\n   End\n\n   'ISREDIT CURSOR =' ZDest1 0\n   Exit(0)\n\nDispDoc:\n   ADDRESS TSO \"CLEAR\"\n   Say\n   Say ' PASTEAFT will place cut lines from the PROFILE pool after     '\n   Say ' one or more lines in the current file.                        '\n   Say\n   Say '     PASTEAFT  ( D | DELETE )  ( #-lines-to-skip )             '\n   Say\n   Say ' Enter PASTEAFT on the COMMAND line and use C or CC range line '\n   Say ' command to specify where the lines are to be pasted. A number '\n   Say ' of lines to skip may also be specified, 1 is the default.     '\n   Say\n   Say ' A parameter of D or DELETE can be specified to cause the macro'\n   Say ' to erase the PROFILE variables after the lines have been      '\n   Say ' pasted into the file.                                         '\n   Say\n   Exit(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PASTEX": {"ttr": 29962, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00Z\\x00Z\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 90, "newlines": 90, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- Place lines from the user PROFILE pool into the file    **/\n\n   Address ISPEXEC\n   'ISREDIT MACRO (PARM1) NOPROCESS'\n   Parm1 = translate(Parm1)\n   If Parm1 = '?' then signal DispDoc\n\n   If Parm1 <> ' ' & Parm1 <> 'D' & Parm1 <> 'DELETE' then do\n       zedsmsg = 'Invalid parameter'\n       zedlmsg = 'Use ? for help, D or DELETE to cause lines to delete'\n       'SETMSG MSG(ISRZ001)'\n       Exit(12)\n   End\n\n   'CONTROL ERRORS RETURN'\n   'ISREDIT PROCESS DEST'\n   Select\n       When rc = 0 then\n           'ISREDIT (ZDEST) = LINENUM .ZDEST'\n       When rc <= 8 then do\n            zedsmsg = 'Enter \"A\"/\"B\" line cmd'\n            zedlmsg = 'PASTEX requires an \"A\" or \"B\" line command'\n            'SETMSG MSG(ISRZ001)'\n            Exit(12)\n       End\n       When rc < 20 then\n            Exit(12)\n       When rc = 20 then\n            ZDest = 0\n       Otherwise Exit(12)\n   End\n   'CONTROL ERRORS CANCEL'\n\n   'VGET (CUTCNT) PROFILE'\n   If rc \u00ac= 0 | CutCnt <= 0 then do\n       zedsmsg = 'Use CUTX before PASTEX'\n       zedlmsg = 'Use CUTX first before attempting PASTEX'\n       'SETMSG MSG(ISRZ001)'\n       Exit(12)\n   End\n\n   TruncCnt = 0\n   CutCount = CutCnt\n   Do i = CutCnt to 1 by -1\n     'VGET (CL'i') PROFILE'\n     'ISREDIT LINE_AFTER' ZDest '= DATALINE (CL'i')'\n     If rc = 4 then TruncCnt = TruncCnt + 1\n   End\n\n   If Parm1 = 'D' | Parm1 = 'DELETE' then do\n       Do i = 1 to CutCnt by 1\n         'VERASE (CL'i') PROFILE'\n       End\n       CutCnt = 0\n       'VPUT (CUTCNT) PROFILE'\n     End\n\n   If TruncCnt > 0 then do\n       zedsmsg = TruncCnt 'lines truncated'\n       msg     = 'Current record length shorter than origin'\n       zedlmsg = msg '-' TruncCnt 'of' CutCount 'records truncated'\n       'SETMSG MSG(ISRZ001)'\n   End\n   Else do\n       zedsmsg = CutCount 'lines pasted'\n       zedlmsg = CutCount 'lines were pasted into the current file'\n       'SETMSG MSG(ISRZ000)'\n   End\n\n   Line1 = ZDest + 1\n   'ISREDIT CURSOR =' Line1 0\n   Exit(0)\n\nDispDoc:\n   ADDRESS TSO \"CLEAR\"\nSay\nSay ' PASTEX will pull previously cut lines from the PROFILE pool   '\nSay ' into the current file.                                        '\nSay\nSay '     PASTEX  ( D | DELETE )                                    '\nSay\nSay ' Enter PASTEX on the COMMAND line and use the A or B line      '\nSay ' command to specify where the lines are to be pasted.          '\nSay\nSay ' A parameter of D or DELETE can be specified to cause the macro'\nSay ' to set the profile variables to null after the lines have been'\nSay ' pasted into the file. If line truncation occurs, the profile  '\nSay ' will be erased and a message issued in the upper right corner.'\nSay\nExit(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PASTY": {"ttr": 29965, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00A\\x00A\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 65, "newlines": 65, "modlines": 0, "user": "REXX"}, "text": "/** REXX - Put lines from the user profile after the cursor **/\n\n   Address ISPEXEC\n   'ISREDIT MACRO (PARM1)   PROCESS'\n   Parm1 = translate(Parm1)\n   If Parm1 = '?' then signal DispDoc\n\n   'ISREDIT (Line,Col) = CURSOR'\n   'ISREDIT (ZDest)    = CURSOR'\n   If ZDest = 1  then do\n       'VGET (ZSCREENC,ZSCREENI) SHARED'\n       ii = INDEX(ZScreenI,'* Top of Data *')\n       If ( ZScreenC % 80 )  <=  ( ii % 80 )  then ZDest = 0\n       Else ZDest = 1\n   End\n\n   'VGET (CUTCNT) PROFILE'\n   If rc \u00ac= 0 | CutCnt <= 0 then do\n       zedsmsg = 'Use CUTX before PASTY'\n       zedlmsg = 'Use CUTX before attempting to use PASTY'\n       'SETMSG MSG(ISRZ001)'\n       Exit(12)\n   End\n\n   TruncCnt = 0\n   CutCount = CutCnt\n   Do i = CutCnt to 1 by -1\n       'VGET (CL'i') PROFILE'\n       'ISREDIT LINE_AFTER' ZDest '= DATALINE (CL'i')'\n       If rc = 4 then TruncCnt = TruncCnt + 1\n   End\n\n   If TruncCnt > 0 then do\n       zedsmsg = TruncCnt 'lines truncated'\n       msg     = 'Current record length shorter than origin'\n       zedlmsg = msg '-' TruncCnt 'of' CutCount 'records truncated'\n       'SETMSG MSG(ISRZ001)'\n   End\n   Else do\n       zedsmsg = CutCount 'lines pasted'\n       zedlmsg = CutCount 'lines were pasted into the current file'\n       'SETMSG MSG(ISRZ000)'\n   End\n\n   If Line = 0 & Col = 0 then Exit(1)\n   Else do\n      'ISREDIT CURSOR = ' Line Col\n      Exit\n   End\n\nDispDoc:\n   ADDRESS TSO \"CLEAR\"\n   Say\n   Say ' PASTY will insert previously cut lines from the PROFILE pool '\n   Say ' into the current file after the cursor position.             '\n   Say ' would have been cut with the CUTX macro.                     '\n   Say\n   Say '     PASTY                                                    '\n   Say\n   Say ' Enter PASTY on the COMMAND line and position the cursor on   '\n   Say ' the line after which the cut data is to be inserted. Assign  '\n   Say ' PASTY to a PF Key and you can just position the cursor and   '\n   Say ' press the PF Key, as often as desired and across files.      '\n   Say\n   Exit(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSDEGAS": {"ttr": 29967, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\x17\\x00\\x17\\x00\\x00\\xd7\\xc4\\xe2\\xc7\\xc1\\xe2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "PDSGAS"}, "text": "//-YOUR-USER-ID-G JOB (BT00,0000),'CARL HAFNER - 2S',\n//             CLASS=E,MSGCLASS=X,NOTIFY=-YOUR-USER-ID-\n//***\n//***  DELETE ALL $GAS#### MEMBERS FROM ...\n//***\n//PDSGEN     EXEC     PGM=PDSGEN,REGION=4M\n//SYSUT1       DD       DISP=SHR,\n//             DSN=...\n//SYSIN        DD       *\n  NODUPS  >MEMBER($GAS0000) <MEMBER($GAS9999)\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOAD-MOD-LIB-\n//SYSPRINT     DD       DUMMY\n//SYSGEN       DD       *\nDELETE '...(%MEMBER%)'\n//SYSOUT       DD       DSN=&&GASDEL,DISP=(,PASS),\n//             UNIT=VIO,SPACE=(CYL,(05,02),RLSE),\n//             DCB=BLKSIZE=27920\n//***\n//***\n//BATCHTSO   EXEC     PGM=IKJEFT01,REGION=4M,DYNAMNBR=32\n//SYSTSIN      DD       DSN=&&GASDEL,DISP=(OLD,DELETE,DELETE)\n//SYSTSPRT     DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDSGAS": {"ttr": 29969, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x03\\x91\\x03\\x91\\x00\\x00\\xd7\\xc4\\xe2\\xc7\\xc1\\xe2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 913, "newlines": 913, "modlines": 0, "user": "PDSGAS"}, "text": "//-YOUR-USER-ID-G JOB (BT00,0000),'CARL HAFNER - 2S',\n//             CLASS=E,MSGCLASS=X,NOTIFY=-YOUR-USER-ID-\n//***\n//***  ASSEMBLY & LINK JCL FOR PDS DELETED MEMBER RESTORE PROGRAM\n//***\n//A          EXEC     PGM=ASMA90,REGION=4M,\n//             PARM='NODECK,OBJECT'\n//SYSLIB       DD       DSN=SYS1.MACLIB,DISP=SHR\n\n         TITLE '**  PDSGAS  **    FREEWARE  **'\n\n*          THIS PROGRAM READS A PDS AND FINDS \"GAS\" MEMBERS, I.E.\n*          MEMBERS THAT HAVE BEEN DELETED BUT HAVE NOT BEEN\n*          COMPRESSED OUT YET.  THE PROGRAM WILL ADD A MEMBER\n*          NAME TO THE DIRECTORY FOR EACH \"GAS\" MEMBER.  THE\n*          ADDED MEMBER NAMES ALL BEGIN WITH '$GAS', FOLLOWED BY\n*          A 4 DIGIT SEQUENCE NUMBER.\n*\n*          DDNAMES REQUIRED:\n*             SYSLIB    -  INPUT PDS\n*             SYSPRINT  -  OUTPUT MESSAGES\n*\n*          ANY USER DATA THAT WAS IN THE DIRECTORY ENTRY OF\n*          A DELETED OR REPLACED MEMBER CANNOT BE RECOVERED.\n*\n*          A NOTE ABOUT LOAD MODULES.  THIS PROGRAM CANNOT RECOVER\n*          A \"GAS\" LOAD MODULE.  IT WILL GIVE IT A MEMBER NAME SO\n*          IT WONT BE COMPRESSED OUT, BUT THE DIRECTORY ENTRY WILL\n*          NOT BE A LOAD MODULE TYPE.  TO RECONSTRUCT THE PROPER\n*          LOAD MODULE DIRECTORY WOULD REQUIRE INFORMATION THAT\n*          IS NO LONGER IN THE PDS.\n\n         MACRO\n         REGS  &PP=R\n         LCLA  &II\n&II      SETA  0\n.LOOP    ANOP\n&PP&II   EQU   &II\n&II      SETA  &II+1\n         AIF   (&II LT 16).LOOP\n         MEND\n\n         MACRO\n&NAME    OBTAIN &LIST,&DUMMY=\n         AIF   (T'&LIST EQ 'O').E1\n&NAME    IHBINNRA &LIST                 LOAD REG 1\n         SVC   27                       ISSUE OBTAIN SVC\n         MEXIT\n.E1      IHBERMAC 34                    LIST ADDR MISSING\n         MEND\n\n         MACRO\n&NAME    RENTER  &BASEREG=R11,&SALEN=108,&REGS=YES\n         GBLC  &SASIZE\n&SASIZE  SETC  '&SALEN'\n.* THIS MACRO PROVIDES ENTRY CODE FOR A REENTRANT PROGRAM.\n.* THE DEFAULT BASE REGISTER IS 11 BUT MAY BE CHANGED VIA\n.* THE BASEREG PARAMETER.  THE SAVE AREA SIZE MAY BE SET\n.* THROUGH THE SALEN PARAMETER AND DEFAULTS TO 108.\n         AIF   ('&REGS' NE 'YES').NOREGS\n         REGS\n.NOREGS  ANOP\n&NAME    CSECT\n         STM   R14,R12,12(R13)     SAVE INCOMING REGS\n         LR    &BASEREG(1),R15     ESTABLISH ADDRESSABILITY\n&#BR     SETA  N'&BASEREG\n         AIF   (&#BR GT 1).MULTIRG\n         USING &NAME,&BASEREG\n         AGO   .OUTBASE\n.MULTIRG ANOP\n&#BRX    SETA  1\n&#BRY    SETA  2\n         LA    &BASEREG(&#BR),4095\n.LOADNXT LA    &BASEREG(&#BRY),1(&BASEREG(&#BRX),&BASEREG(&#BR))\n&#BRX    SETA  &#BRX+1\n&#BRY    SETA  &#BRY+1\n         AIF   (&#BRY LE &#BR).LOADNXT\n&BASELEN SETA  K'&BASEREG-2\n&BASES   SETC  '&BASEREG'(2,&BASELEN)\n         USING &NAME,&BASES\n.OUTBASE ANOP\n         LA    R0,&SASIZE          LOAD SAVE AREA SIZE FOR GETMAIN\n         STORAGE  OBTAIN,LENGTH=(0),LOC=BELOW\n         ST    R1,8(R13)           STORE ADDRESS OF NEW SAVE AREA\n         ST    R13,4(R1)           SAVE CALLERS SAVE AREA ADDRESS\n         LM    R0,R1,20(R13)       RELOAD R0 & R1\n         L     R13,8(R13)          LOAD NEW SAVE AREA ADDRESS INTO R13\n         MEND\n\n         MACRO\n&NAME    REXIT &RC15=YES\n         GBLC  &SASIZE\n&NAME    DS    0H\n         LA    R0,&SASIZE          LOAD SAVE AREA LENGTH FOR RELEASE\n         LR    R1,R13              LOAD SAVE AREA ADDRESS FOR RELEASE\n         L     R13,4(R13)          RESTORE CALLING SAVE AREA ADDRESS\n         AIF   ('&RC15' NE 'YES').NORETC\n         ST    R15,16(R13)         SAVE RETURN CODE\n.NORETC  ANOP\n         STORAGE  RELEASE,LENGTH=(0),ADDR=(1)\n         LM    R14,R12,12(R13)     RESTORE CALLING REGS R14 - R12\n         BR    R14\n         MEND\n\n         MACRO\n&LBL     OUTPT   &R0,&R1,&LN=50     OUTPUT MACRO\n&LBL     LA      R15,&LN       LENGTH OF STRING\n         AIF     ('&R0' EQ 'R0').NOR0\n         L       R0,&R0        NUMBER TO BE OUTPUT\n.NOR0    LA      R1,&R1        STRING TO FOLLOW\n         BAL     R14,OUTRTN    OUTPUT ROUTINE\n         AIF     ('&R1' NE 'WORK').MEND\n         MVC     WORK(80),BLANKS\n.MEND    MEND\n\n         MACRO\n&LBL     MBBTTR  &MBB,&TTR=TEMP    MBBCCHHR TO TTR CONVERSION MACRO\n&LBL     L       R0,TRACKNUM       CURRENT TRACK NUMBER (RELATIVE 1)\n         CLI     CURMBB+7,X'01'    SWITCHED TRACKS?\n         BE      *+6               NO, BRANCH\n         BCTR    R0,0              CURRENT TRACK NUMBER (RELATIVE 0)\n         STH     R0,&TTR           SAVE RELATIVE TRACK NUMBER\n         MVC     &TTR+2(1),IOBSEEK+7  SAVE RECORD NUMBER\n         MEND\n\n         MACRO\n&LBL     TTRMBB  &TTR,&MBB=DOUBLE  TTR TO MBBCCHHR CONVERSION MACRO\n&LBL     STM     R14,R12,12(R13)\n         L       R1,&TTR           TTRN ACTUALLY\n         SLDL    R0,24             SHIFT TTR INTO R0\n         SLL     R0,8              ADJUST\n         L       R1,DCBDEBAD       DEB ADDRESS\n         LA      R2,&MBB           RESULT ADDRESS\n         LR      R3,R13            SAVE SAVEAREA REGISTER\n         L       R15,16            CVT POINTER\n         L       R15,28(,R15)      TTRN->MBBCCHHR ROUTINE ADDRESS\n         BALR    R14,R15\n         LR      R13,R3\n         LM      R14,R12,12(R13)\n         MEND\n\n         MACRO\n&LBL     HEXES   &SRC,&NUM,&OUT     OUTPUT LOOKS LIKE C1.C2.C3 . . .\n         LCLC    &ONE                    FOR NUM SOURCE CHARACTERS\n&ONE     SETC    'HX'.'&SYSNDX'\n&LBL     SR      R15,R15\n         LA      R14,&NUM\n         LR      R1,R14\n         BCTR    R1,0\n         LA      R1,&NUM.(R1,R1)    LAST PERIOD AT (N-1)*3+1\n         LA      R1,&OUT.(R1)\n         S       R1,=F'3'           OUTPUT START LOCATION\n&ONE     LA      R15,&SRC           SOURCE BASE ADDRESS\n         SR      R0,R0\n         BCTR    R15,0\n         IC      R0,0(R14,R15)      INPUT CHARACTER\n         LR      R15,R0\n         N       R15,=F'15'\n         IC      R15,HEXTBL(R15)\n         STC     R15,2(,R1)         LOW NIBBLE\n         LR      R15,R0\n         SRL     R15,4\n         IC      R15,HEXTBL(R15)\n         STC     R15,1(,R1)         HIGH NIBBLE\n         MVI     0(R1),C'.'         SEPARATOR\n         S       R1,=F'3'           BACK UP 3 IN OUTPUT ADDRESS\n         BCT     R14,&ONE           DO PREVIOUS INPUT CHARACTER\n         MVI     3(R1),X'40'        BLANK THE LEADING PERIOD\n         MEND\n\nPDSGAS   RENTER  BASEREG=(R10,R11,R12)\n         OI    FLAGS,GASADD         ALWAYS ADD ALL DELETED MEMBERS BACK\n\n         L     R15,0(R1)\n         N     R15,LAST#\n         LH    R1,0(R15)\n         C     R1,PARMLEN\n         BNE   NOPARM\n         MVC   PARMDATA,2(R15)\n         CLI   DASHER,C'-'\n         BNE   NOPARM\n         PACK  DW,STARTNUM\n         CVB   R15,DW\n         ST    R15,START#\n         PACK  DW,LASTNUM\n         CVB   R15,DW\n         ST    R15,LAST#\n\nNOPARM   EQU   *\n         GETMAIN  R,LV=@SPACEL\n         LR    R7,R1\n         USING @SPACE,R7\n         LA    R0,BUFFER\n         O     R0,CCW3\n         ST    R0,CCW3\n         LR    R8,R7\n         A     R8,=A(SAVETBP-SAVEAREA)\n         USING SAVETBP,R8\n\n         LR    R14,R8\n         L     R15,=A(SAVEEND-SAVETBP)\n         LR    R0,R14\n         L     R1,=AL1(C' ',0,0,0)\n         MVCL  R14,R0\n\n         OPEN  (PRT,OUTPUT)\n         TM    DCBOFLGS-IHADCB+PRT,X'10'  OPEN SUCCESSFUL\n         BNO   OUTERR                     NO, BRANCH\n         PUT   PRT,OUTHEAD\n         PUT   PRT,BLANKS\n\n         LA    R9,LIB\n         USING IHADCB,R9\n         BAL   R14,OPENIN           OPEN THE INPUT FILE\n\n         MVC   TEMP(4),DS1LSTAR\n         TTRMBB TEMP,MBB=LASTMBB  SAVE THE LAST USED MBBCCHHR\n         TM    DS1DSORG,X'02'     PARTITIONED DATA SET ORGANIZATION?\n         BO    PO                 YES, BRANCH\n         OUTPT MINUS1,NOTPDS\n         ABEND 4\nPO       SR    R5,R5                CLEAR R5 FOR LATER\n         OI    FLAGS,DIRECTOR       TURN ON THE \"IN DIRECTORY\" FLAG\n\nNEXTMBR  BAL   R14,MEMBERS          GET THE NEXT MEMBER\n         B     *+4(R15)             BRANCH TABLE\n         B     GOODMBR              SUCCESSFUL\n         B     MBREOF               EOF IN DIRECTORY\n         B     LASTUSED             LAST USED ENTRY FOUND\n         B     NOTDIREC             NOT A DIRECTORY RECORD\n\nGOODMBR  LA    R2,ALIASES\n         TM    11(R1),X'80'          ALIAS ENTRY?\n         BO    GOODALS               YES, BRANCH\n         LA    R2,REALMBR            NO, A REAL ENTRY\n         NI    0(R1),X'7F'           TURN OFF THE TOP BIT IN THE NAME\nGOODALS  L     R14,0(,R2)            LOAD COUNTER\n         LA    R14,1(,R14)           INCREMENT ALIASES OR REALMBR\n         ST    R14,0(,R2)            STORE COUNTER\n         LR    R2,R1\n         TTRMBB 8(R1),MBB=DOUBLE     CONVERT TTR TO MBBCCHHR\n         LA    R1,SAVETBP\nTBLINC   LA    R1,16(,R1)\n         CLI   0(R1),X'40'           EMPTY TABLE ENTRY?\n         BE    INSERT                YES, BRANCH\n         CLC   8(8,R1),DOUBLE        IS IT THIS ENTRY?\n         BNE   TBLINC                NO, CHECK NEXT ENTRY\n         TM    11(R2),X'80'          ALIAS?\n         BO    NEXTMBR               YES, BRANCH\n         MVC   0(8,R1),0(R2)         NO, USE THE REAL MEMBER NAME\n         B     NEXTMBR\nINSERT   MVC   0(8,R1),0(R2)        INSERT THE NAME\n         MVC   8(8,R1),DOUBLE       INSERT THE MBBCCHHR\n         LR    R5,R1                SAVE THE \"HIGH-WATER\" MARK\n         L     R1,REALENT\n         LA    R1,1(,R1)            COUNT THE NUMBER OF TABLE ENTRIES\n         ST    R1,REALENT\n         C     R1,=F'3000'\n         BL    NEXTMBR\n         OUTPT MINUS1,MANYENT\n         ABEND 99              ** TOO MANY MEMBER ENTRIES IN THE TABLE\nNOTDIREC SR    R15,R15               SIMULATED END OF FILE (GOOD READ)\n         B     MBREOF                END OF FILE IN DIRECTORY\n\nLASTUSED EQU   *                     END OF USED ENTRIES IN DIRECTORY\nRPTEXCP  BAL   R14,EXCPSTAT          READ AND COLLECT STATISTICS\n         LTR   R15,R15\n         BZ    RPTEXCP               LOOP IF NOT EOF\nMBREOF   EQU   *\nPRESORT  SR    R0,R0\n         XI    FLAGS,DIRECTOR        TURN OFF THE \"IN DIRECTORY\" FLAG\n         ST    R15,TEMP              SAVE FOR LATER\n         ST    R0,READTOT            REINITIALIZE READTOT\n         ST    R0,MAXBLK                                 MAXBLK\n         ST    R0,BYTECNT                                      BYTECNT\n         MVC   MINBLK(4),=F'33000'   REINITIALIZE MINBLK\n*\n*     SORT THE MEMBER ARRAY BY MBBCCHHR  (USES A SHELLSORT)\n*\n         L     R2,REALENT           NUMBER OF ELEMENTS TO SORT\n         SLA   R2,4                 GAP IS  16 * ELEMENTS\n         LA    R3,SAVETBP\n         LR    R0,R2                N=GAP\nSHELLG   SRL   R2,5                 GAP=GAP/2  (DROP FRACTION BITS)\n         SLA   R2,4                 GAP LESS THAN ONE?\n         BZ    SORTED               YES, DONE\n         LR    R4,R2                I=GAP\nSHELLI   LA    R4,16(,R4)           I=I+1   (TABLE WIDTH IS 16)\n         CR    R4,R0                I<=N?\n         BH    SHELLG               NO, HALVE THE GAP\n         LR    R1,R4                YES, J=I\nSHELLJ   SR    R1,R2                J=J-GAP\n         BNP   SHELLI               IF J<=0, INCREMENT I\n         LA    R15,0(R3,R1)         ADDRESS OF SAVETBL(J)\n         LA    R14,0(R2,R1)         JG=J+GAP\n         LA    R14,0(R3,R14)        ADDRESS OF SAVETBL(JG)\n         CLC   8(8,R15),8(R14)      MBBCCHHR(J) <= MBBCCHHR(JG)\n         BNH   SHELLI               YES, INCREMENT I\n         XC    0(16,R14),0(R15)     INTERCHANGE\n         XC    0(16,R15),0(R14)                SAVETBL ENTRIES\n         XC    0(16,R14),0(R15)                               J AND JG\n         B     SHELLJ               INCREMENT J\n\nSORTED   EQU   *\n         LA    R2,SAVETBP\nNULLPDS  L     R15,TEMP             RESTORE THE RETURN CODE\n*\nNXTREAL  LA    R2,16(,R2)           LAST MEMBER WAS REAL\nNXTONE   L     R0,BYTECNT            LAST MEMBER WAS GAS\n         ST    R0,SAVETOT            SAVE FOR LATER\n         C     R15,=F'8'             END OF DATA SET?\n         BE    LASTMTCH              YES, BRANCH\n         OI    FLAGS,REALONE         SET FLAG FOR ACTUAL MEMBER\n         MVC   CURRMBR(8),0(R2)      SAVE THE CURRENT MEMBER NAME\n         CLC   8(8,R2),IOBSEEK       NEXT MBBCCHHR IN THE TABLE?\n         BE    REAL                  YES, BRANCH TO READ LOOP\n         BH    GAS                   NO, HIGHER -- A \"GAS\" MEMBER\n         OUTPT MINUS1,TTRTOLOW\n         ABEND 13            **  TABLED TTR < CURRENT TTR  **\n\nGAS      XI    FLAGS,REALONE         TURN OFF THE ACTUAL MEMBER FLAG\n         MBBTTR IOBSEEK,TEMP         CONVERT MBBCCHHR TO TTRN\n         L     R1,GASCNT             NO, HIGHER -- A \"GAS\" MEMBER\n         LA    R1,1(,R1)\n         ST    R1,GASCNT             ADD ONE TO THE GAS MEMBER COUNT\n         HEXES TEMP,3,GASMEM+21\nGASSAVE  LA    R1,1                  COUNT\n         A     R1,ADDCNT              SAVED\n         ST    R1,ADDCNT               GAS TTR'S\n         BCTR  R1,0                  OFFSET = (NUMBER-1)*3\n         MH    R1,=H'3'              GET OFFSET INTO TTR TABLE\n         LA    R1,SAVEGAS(R1)        POINT TO NEXT SLOT IN TTR TABLE\n         MVC   0(3,R1),TEMP          SAVE TTR FOR STOW\nGASSAVEX EQU   *\n         TM    DS1RECFM,X'C0'        RECFM=U?\n         BNO   GASDATA               NO, BRANCH\n         OUTPT MINUS1,GASMEM,LN=28   YES, DO NOT DO A DATA LINE\n         B     GASRD\n*\nGASDATA  EQU   *\n         OUTPT MINUS1,GASMEM\n         BAL   R14,EXCPSTAT          INPUT THE NEXT REAL BLOCK\n         ST    R15,TEMP              SAVE THE RETURN CODE\n         L     R15,LS\n         C     R15,=F'72'\n         BNH   *+8\n         L     R15,=F'72'            LIMIT OUTPUT LENGTH TO 72 BYTES\n         LTR   R15,R15\n         BNZ   *+12\n         LA    R15,1                 IF NULL LENGTH, USE ONE BYTE AND\n         MVI   BUFFER,X'40'             BLANK THE FIRST BYTE OF BUFFER\n         OUTPT MINUS1,BUFFER,LN=0(R15)\n         L     R15,TEMP              RESTORE THE RETURN CODE\n         B     GASRDF                SKIP THE FIRST READ (ALREADY DONE)\n\nGASRD    BAL   R14,EXCPSTAT          \"GAS\" MEMBER\n         L     R1,GASRDS\n         LA    R1,1(,R1)             ADD ONE TO THE GAS RECORD COUNT\n         ST    R1,GASRDS\nGASRDF   LTR   R15,R15               (DON'T COUNT THE FIRST ONE)\n         BZ    GASRD                 BRANCH IF NOT EOF\n         L     R0,BYTECNT\n         S     R0,SAVETOT            GAS BYTES THIS MEMBER\n         B     NXTONE\n\nREAL     EQU   *\nREALRD   BAL   R14,EXCPSTAT          \"REAL\" MEMBER\nREALRDF  LTR   R15,R15               END OF FILE?\n         BZ    REALRD                NO, CONTINUE LOOPING\n         B     NXTREAL\n\nLASTMTCH CLI   0(R2),X'40'\n         BE    ENDPSPO\n         OUTPT MINUS1,NOTFOUND\n         ABEND 19            **  ALL MEMBERS IN THE TABLE NOT FOUND  **\nENDPSPO  L     R1,GASCNT\n         LTR   R1,R1\n         BNZ   GASCOUNT\n         OUTPT MINUS1,NOGAS\n         B     GASCOUNX\nGASCOUNT OUTPT GASCNT,GASMBR\nGASCOUNX EQU   *\n         CLOSE LIB\n         TM    FLAGS,GASADD\n         BZ    *+8\n         BAL   R14,STOW\n         CLOSE PRT\n         SR    R15,R15\n         REXIT\n\nSTOW     L     R1,ADDCNT           GET NUMBER OF TTR'S TO STOW\n         LTR   R1,R1               ARE THERE ANY\n         BZ    0(,R14)             NO, RETURN\n         ST    R14,STOWR\n         BCTR  R1,0                OFFSET = (NUMBER-1)*3\n         MH    R1,=H'3'            GET OFFSET TO LAST TTR\n         LA    R3,SAVEGAS(R1)      POINT TO LAST GAS TTR\n         LA    R2,SAVEGAS          POINT TO FIRST GAS TTR\n         LA    R4,1                MEMBER NAME SEQUENCE NUMBER\n         OPEN  (PDS,UPDAT)\nSTOWLOOP CR    R2,R3               ARE WE PAST THE LAST GAS TTR\n         BH    STOWEXIT            YES, STOP\n         C     R4,START#\n         BL    STOWNXT1\n         C     R4,LAST#\n         BH    STOWEXIT\n         CVD   R4,STOWCVD\n         OI    STOWCVD+7,X'0F'\n         UNPK  STOWMEM+4(4),STOWCVD+5(3)\n         MVC   TTRZ(3),0(R2)       MOVE TTR FROM TABLE FOR FIND\n         FIND  PDS,TTRZ,C\n         MVC   STOWTTR(3),0(R2)    MOVE TTR FROM TABLE\n         STOW  PDS,STOWMEM,A\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(6),=C'MEMBER'\n         MVC   OUTLINE+8(8),STOWMEM\n         MVC   OUTLINE+17(L'STOWMSGA),STOWMSGA\n         LTR   R15,R15\n         BNZ   STOWERR\n         MVC   TEMP(3),STOWTTR\n         HEXES TEMP,3,OUTLINE+17+L'STOWMSGA+1\nSTOWMSG  PUT   PRT,OUTLINE\nSTOWNXT1 EQU   *\n         LA    R4,1(,R4)           NEXT SEQUENCE NUMBER\n         LA    R2,3(,R2)           NEXT TTR\n         B     STOWLOOP\nSTOWERR  CH    R15,=H'4'           NAME ALREADY IN DIRECTORY\n         BNE   STOWER12\n         MVC   OUTLINE+17(L'STOWMSGB),STOWMSGB\n         SH    R2,=H'3'            TRY SAME TTR AGAIN\n         B     STOWMSG\nSTOWER12 CH    R15,=H'12'          DIRECTORY FULL\n         BNE   STOWER16\n         MVC   OUTLINE+17(L'STOWMSGC),STOWMSGC\n         B     STOWERRX\nSTOWER16 MVC   OUTLINE+17(L'STOWMSGD),STOWMSGD\nSTOWERRX PUT   PRT,OUTLINE\nSTOWEXIT CLOSE (PDS)\n         L     R14,STOWR\n         BR    R14\nSTOWR    DC    F'0'\nSTOWCVD  DC    D'0'\nSTOWMEM  DC    CL8'$GAS0000'\nSTOWTTR  DC    XL3'00',X'00'       TTR, ALIAS FLAG\nTTRZ     DC    F'0'\nSTOWMSGA DC    C'ADDED TO DIRECTORY FOR TTR '\nSTOWMSGB DC    C'NOT ADDED TO DIRECTORY - ALREADY EXISTS'\nSTOWMSGC DC    C'NOT ADDED TO DIRECTORY - DIRECTORY FULL'\nSTOWMSGD DC    C'NOT ADDED TO DIRECTORY - UNKNOWN ERROR'\n         PRINT NOGEN\nPDS      DCB   DDNAME=SYSLIB,DSORG=PO,MACRF=(R)\n         PRINT GEN\n\nEXCPSTAT ST    R14,STATR14    ISSUES EXCP'S AND GATHERS STATISTICS\n         BAL   R14,EXCP\n         B     *+4(R15)\n         B     R15IS0             GOOD READ\n         B     R15IS4             END OF FILE OR END OF MEMBER\n         B     R15IS8             END OF DATA SET\nR15IS12  OUTPT MINUS1,BLANKS      I/O OR OTHER DISK ERROR\n         L     R14,INAROW\n         LA    R14,1(,R14)        UPDATE NUMBER OF CONSECUTIVE ERRORS\n         ST    R14,INAROW\n         C     R14,=F'10'         ALLOW ONLY 10 CONSECUTIVE ERRORS\n         BL    CONTINUE\n         OUTPT MINUS1,TOOMANY     TOO MANY CONSECUTIVE ERRORS\n         ABEND 999\nCONTINUE HEXES SAVECB,1,IOERROR+17    ECB ERROR CODE\n         HEXES CURMBB+3,5,IOERROR+27  CURRENT DISK CCHHR\n         OUTPT MINUS1,IOERROR\n         TM    DS1DSORG,X'02'     PDS?\n         BNO   BLKNUM             NO, BRANCH\n         TM    FLAGS,DIRECTOR     ERROR IN THE DIRECTORY?\n         BO    DIRERR             YES, BRANCH\n         TM    FLAGS,REALONE      ACTUAL MEMBER?\n         BNO   GASERR             NO, BRANCH\n         OI    CURRMBR,X'80'      MAKE PRINTABLE\n         OUTPT MINUS1,CURRMBR     OUTPUT THE CURRENT MEMBER NAME\n         B     R15IS4$\nGASERR   OUTPT MINUS1,GASERRS     ERROR IN READING GAS DATA\n         B     R15IS4$\nDIRERR   OUTPT MINUS1,DIRERRS     DIRECTORY I/O ERROR (IGNORE BLOCK)\nBLKNUM   OUTPT READTOT,BLKNUMS    READ ERROR MESSAGE\n         B     EXCPSTAT+4         CONTINUE--USING THE NEXT BLOCK\n\nR15IS8   DS    0H                 END OF DATA SET\n         B     TRKNOINC           FINISH UP PROCESSING\n\nR15IS4   MVC   INAROW,=F'0'       END OF MEMBER\nR15IS4$  LA    R15,4              TREAT AS AN END OF MEMBER CONDITION\n         L     R1,EOFS\n         LA    R1,1(,R1)          END OF MEMBER COUNTER\n         ST    R1,EOFS\n         CLC   MBBCCHH(7),CURMBB  NEW TRACK\n         BNE   RETURNS\n         L     R1,LASTR\n         LA    R1,1(,R1)\n         ST    R1,LASTR           UPDATE THE RECORD COUNT\n         B     RETURNS\n\nR15IS0   MVC   INAROW,=F'0'       GOOD READ\nR15IS0$  L     R1,READTOT\n         LA    R1,1(,R1)\n         ST    R1,READTOT         COUNT OF BLOCKS READ\n         L     R1,LS              CURRENT BLKSIZE\n         LR    R0,R1              SAVE FOR LATER\n         A     R1,BYTECNT\n         ST    R1,BYTECNT         TOTAL NUMBER OF BYTES READ\nNOFILSUM CLC   MBBCCHH(7),CURMBB  SAME MBBCCHH?\n         BNE   NEWTRACK           NO, BRANCH\n         A     R0,CURBYTE\n         ST    R0,CURBYTE         ACCUMULATE TRACK BYTE COUNT\n         L     R1,LASTR\n         LA    R1,1(,R1)\n         ST    R1,LASTR           ACCUMULATE RECORD COUNT/TRACK\n         B     RETURNS\n\nNEWTRACK L     R1,TRACKNUM        SWITCH TRACKS --\n         LA    R1,1(,R1)\n         ST    R1,TRACKNUM        ACTUAL TRACKS USED\nTRKNOINC MVC   MBBCCHH(7),CURMBB  SAVE CURRENT TRACK NUMBER\n         L     R0,CURBYTE\n         L     R1,LS\n         ST    R1,CURBYTE\n         L     R1,LASTR\n         LA    R14,1\n         ST    R14,LASTR\n\nRETURNS  L     R14,STATR14\n         BR    R14\n\n*   MEMBER INPUT ROUTINE\n\nMEMBERS  ST    R14,MEMBR14\n         LM    R15,R1,DIRPTRS     PICK UP ADDR, INCR, LIMIT\n         LTR   R1,R1              INITIALIZED?\n         BNZ   DEBLOCK            YES, BRANCH\n         BAL   R14,REREAD         OPEN IN FOR INPUT OF THE DIRECTORY\nGETBLK   BAL   R14,EXCPSTAT       GET A DIRECTORY BLOCK\n         LTR   R15,R15            END OF FILE?\n         BP    MBRDONE            YES, END OF FILE INDICATION\n         CLC   LS+2(2),=H'256'    GOOD DIRECTORY BLOCK?\n         BNE   NODIRBLK           NO, BRANCH\n         LA    R0,2               INCREMENT IS 2 FIRST\n         LH    R1,BUFFER          LENGTH HALFWORD\n         LA    R1,BUFFER-1(R1)    LIMIT\n         LA    R15,BUFFER         START\nDEBLOCK  BXH   R15,R0,GETBLK\n         IC    R0,11(,R15)\n         N     R0,=F'31'          GET LENGTH BITS\n         AR    R0,R0              LENGTH * 2\n         A     R0,=F'12'          LENGTH * 2  +  12\n         STM   R15,R1,DIRPTRS     SAVE FOR LATER\n         CLI   0(R15),X'FF'       LAST MEMBER\n         BNE   *+12               NO, BRANCH\n         LA    R15,8              LAST MEMBER USED INDICATION\n         B     MBRDONE\n         LR    R1,R15             ADDRESS OF MEMBER NAME (RETURNED)\n         SR    R15,R15            GOOD READ INDICATION\n         B     MBRDONE\nNODIRBLK OUTPT MINUS1,EOFSIMS     RECORD LENGTH IS NOT 256\n         OUTPT LS,BLOCKLEN        OUTPUT CURRENT LRECL\n         LA    R15,12             ERROR INDICATION\nMBRDONE  L     R14,MEMBR14        RETURN ADDRESS\n         BR    R14\nDIRPTRS  DC    3A(0)              SAVEAREA FOR R15, R0 AND R1\nMEMBR14  DC    A(0)               SAVEAREA FOR RETURN ADDRESS\n\n*   EXCP SUBROUTINES  (OPENIN, REREAD AND EXCP)\n*   OPENS THE FILE WITH DDNAME IN\n\nOPENIN   ST    R14,EXCPR14                  ENTRY TO OPEN THE IN FILE\n         RDJFCB (LIB)                       GET DSN AND VOLUME SERIAL\n         LTR   R15,R15                      SUCCESSFUL?\n         BZ    NOABE40                      YES, BRANCH\nABE40    OUTPT MINUS1,NOTOPEN\n         ABEND 40                  ** RDJFCB, OBTAIN OR OPEN FAILED **\nNOABE40  EQU   *\n         OBTAIN MYLABEL                     READ IN THE FORMAT 1 DSCB\n         LTR   R15,R15                      SUCCESSFUL?\n         BNZ   ABE40                        NO, STOP THE PROGRAM\n         OPEN  (LIB,INPUT)\n         TM    DCBOFLGS,X'10'               IN OPEN?\n         BZ    ABE40                        NO, STOP THE PROGRAM\n         B     REREAD+4\n\n*   ENTRY TO REREAD THE OPEN DATA SET (DDNAME IS IN)\n\nREREAD   ST    R14,EXCPR14\n         L     R1,DCBDEBAD\n         SR    R14,R14\n         IC    R14,16(R1)                   NUMBER OF EXTENTS\n         ST    R14,NUMEXT                   SAVE FOR LATER\n         LA    R14,16(R1)                   CURRENT EXTENT POINTER - 16\n         ST    R14,CUREXT                   SAVE FOR LATER\n         MVI   IOBSEEK,X'00'                RESET THE EXTENT NUMBER\n         LA    R15,4                        EARLY EXIT FLAG\n         B     FIRSTONE                     DO THE INITIAL EXTENT\n\n*    FOR EACH EXTENT, INITIALIZE CCHHR, SECTOR NUMBER AND READ IN THE\n*        LENGTH OF THE FIRST RECORD.\n\nEACHXTNT SR    R1,R1              AFTER THE FIRST EXTENT --\n         IC    R1,IOBSEEK\n         LA    R1,1(,R1)\n         STC   R1,IOBSEEK         INCREMENT THE EXTENT NUMBER\n         C     R1,NUMEXT          PAST LAST EXTENT?\n         BNL   EOF$DS             YES, NO END OF DATA SET RECORDED\n\nFIRSTONE ST    R15,EXCPR15                  SAVE ENTRY CODE FOR LATER\n         L     R1,CUREXT\n         LA    R1,16(R1)                    CURRENT EXTENT ENTRY\n         MVC   IOBSEEK+3(4),6(R1)           INITIAL CCHH\n         ST    R1,CUREXT                    UPDATE FOR LATER\n         MVI   IOBSEEK+7,0\n         MVI   SNO,0                        SET SECTOR NUMBER=ZERO\n         LA    1,CCW1A\n         ST    1,CPADDR\n         EXCP  IOB\n         WAIT  ECB=ECB\n         CLI   ECB,X'7F'                    GOOD READ?\n         BE    NOABE30                      YES, BRANCH\n         OUTPT MINUS1,FIRSTRD\n         ABEND 30          **  FIRST READ OF EXTENT DID NOT WORK  **\nNOABE30  LA    R1,CCW1\n         ST    R1,CPADDR\n         MVC   CCW3+6(2),DATALN             GET LENGTH FOR NEXT READ\n         MVI   IOBSEEK+7,1                  SET R=1\n         L     R15,EXCPR15\n         LTR   R15,R15                      EARLY EXIT DESIRED?\n         BZ    EXCP+4                       NO, ISSUE THE EXCP AGAIN\n         L     R14,EXCPR14          RETURN FROM OPENIN, REREAD OR\n         BR    R14                      AFTER EOF AND EXTENT VIOLATION\n*\n*   ENTRY FOR EACH EXCP TO BE PERFORMED\n*\nEXCP     ST    R14,EXCPR14\n         CLI   ECB,X'42'                    EXTENT VIOLATION LAST TIME?\n         BE    EACHXTNT                     YES, DO THE NEXT EXTENT\n         MVC   CURMBB(8),IOBSEEK  SAVE THE DISK ADDRESS OF THIS RECORD\n         MVC   LS+2(2),DATALN     SAVE THE BLOCK LENGTH FOR THIS READ\n         EXCP  IOB\n         WAIT  ECB=ECB\n         SR    R15,R15            GOOD READ FLAG\n         CLI   ECB,X'42'          EXTENT VIOLATION (NEXT TIME)?\n         BE    ENDEXCP            YES, QUIT\n         TM    DS1DSORG,X'80'     ISAM DATA SET?\n         BO    *+14               YES, IGNORE DS1LSTAR CHECK FOR ISAM\n         CLC   LASTMBB(8),CURMBB  PAST THE DS1LSTAR MARKER?\n         BNH   EOF$DS             YES, END OF FILE AND DATA SET\n         CLI   ECB,X'7F'          GOOD READ?\n         BE    ENDEXCP            YES, QUIT\n\n         CLI   ECB,X'41'          PERMANENT ERROR?\n         BE    NOABE10            YES, BRANCH\n         OUTPT MINUS1,BADERROR\n         B     SOMERR         **  BAD ERROR; ECB NOT HEX 41, 42 OR 7F\nNOABE10  TM    CSW+4,X'01'        ACTUALLY EOF?\n         BO    EOF\n         CLC   CSW+4(2),=X'0020'      NULL MEMBER OR DATA SET?\n         BE    EOF                    YES, BRANCH\n         OUTPT MINUS1,PERMERR\nSOMERR   LA    R15,12         **  PERMANENT ERROR--NOT END OF FILE  **\n         MVC   SAVECB(1),ECB      SAVE ECB CODE FOR LATER\n         B     REISSUE\n\nEOF      TM    DS1DSORG,X'60'     DSORG=PS OR DA?\n         BNZ   EOF$DS             YES, END OF FILE AND DATA SET\n         LA    R15,4              END OF MEMBER FLAG\n         CLC   =H'0',DATALN       NEXT BLOCK LENGTH = 0?\n         BNE   ENDEXCP            NO, BRANCH\nREISSUE  ST    R15,EXCPR15\n         LA    R1,CCW1A           NEED TO REISSUE THE INITIALIZATION\n         ST    R1,CPADDR                EXCP TO GET LENGTH AND ADDRESS\n         EXCP  IOB                      OF THE NEXT DATA BLOCK\n         WAIT  ECB=ECB\n         L     R15,EXCPR15        READ ERROR (12) OR END OF MEMBER (4)\n         LA    R1,CCW1\n         ST    R1,CPADDR\n         MVC   CCW3+6(2),DATALN   DATALENGTH FOR NEXT EXCP\n         CLI   ECB,X'42'          EXTENT VIOLATION?\n         BE    EACHXTNT           YES, DO THE NEXT EXTENT -- EARLY EXIT\n         CLI   ECB,X'7F'          GOOD READ?\n         BE    ENDEXCP            YES, QUIT\n         CLI   ECB,X'41'          PERMANENT ERROR?\n         BE    NOABE70            YES, CHECK EOF\nABE70    OUTPT MINUS1,BADERROR\n         ABEND 70             **  SOME OTHER BAD ERROR  **\nNOABE70  TM    CSW+4,X'01'        NULL MEMBER (ANOTHER EOF)?\n         BO    ENDEXCP\nABE80    OUTPT MINUS1,PERMERR\n         ABEND 80             **  PERMANENT ERROR AFTER EOF  **\nEOF$DS   LA    R15,8              END OF FILE AND DATA SET FLAG\nENDEXCP  L     R14,EXCPR14        RETURN ADDRESS\n         BR    R14\n\n*   OUTPUT ROUTINE\n*      NOTE: R0 NEGATIVE IF NO NUMERIC OUTPUT; OTHERWISE OUTPUT NUMERIC\n*            R1 CONTAINS THE ADDRESS OF THE STRING TO OUTPUT\n*            R14 CONTAINS THE RETURN ADDRESS\n*            R15 CONTAINS THE LENGTH OF THE STRING\n\nOUTRTN   ST    R14,RETOUT\n         BCTR  R15,0                  MACHINE LENGTH\n         MVC   OUTLINE+10(*-*),0(R1)   <<EXECUTED>>\n         EX    R15,*-6                MOVE IN THE STRING\n         LTR   R0,R0                  ANY LEADING NUMERICS?\n         LA    R1,OUTLINE+10\n         BM    OUTSTMT                NO, BRANCH\n         CVD   R0,DOUBLE\n         OI    DOUBLE+7,X'0F'\n         UNPK  OUTLINE(9),DOUBLE+3(5) ASSUME NO MORE THAN 9 DIGITS\n         LA    R1,OUTLINE-1\nOUTSUP   LA    R1,1(,R1)              SCAN FOR\n         CLI   0(R1),C'0'                     FIRST\n         BE    OUTSUP                              NON-ZERO\nOUTSTMT  BCTR  R1,0\n         MVI   0(R1),C' '             CARRIAGE CONTROL\n         LR    R0,R1\n         PUT   PRT,(0)                OUTPUT THE LINE\n         MVC   OUTLINE,OUTLINE-1      BLANK IT\n         L     R14,RETOUT             RETURN\n         BR    R14\nOUTERR   WTO   MF=(E,OUTERRW)\n         ABEND 69            ** OUTPUT FILE DID NOT OPEN  **\nRETOUT   DC    A(0)                   SAVEAREA FOR RETURN ADDRESS\n         DC    C' '\nOUTLINE  DC    CL121' '\n         DC    CL10' '\nOUTHEAD  DC    CL121'1--- PDSGAS --- LOST MEMBER FINDER ---'\nOUTERRW  WTO   'DDNAME SYSPRINT COULD NOT BE OPENED',ROUTCDE=(11),MF=L\n\nBUFFRE   EQU   0\nCCW1A    CCW   X'31',IOBSEEK+3,X'60',5      SEARCH ID EQUAL (CCHHR)\nCCW2A    CCW   X'08',*-8,X'60',1            TIC\nCCW3A    CCW   X'92',IOBSEEK+3,X'20',8      MT READ NEXT COUNT\n\nCCW0     CCW   X'23',SNO,X'60',1            SET SECTOR\nCCW1     CCW   X'31',IOBSEEK+3,X'60',5      SEARCH ID EQUAL (CCHHR)\nCCW2     CCW   X'08',*-8,X'60',1            TIC\nCCW3     CCW   X'06',BUFFRE,X'60',47476     READ DATA\nCCW4     CCW   X'92',IOBSEEK+3,X'60',8      MT READ NEXT COUNT\nCCW5     CCW   X'22',SNO,X'20',1            READ SECTOR NUMBER\n\n         DS    0F\nIOB      DC    X'C2000000'\n         DC    A(ECB)\nCSW      DC    2A(0)\nCPADDR   DC    A(CCW1)\n         DC    A(LIB)\n         DC    2A(0)\nIOBSEEK  DC    2A(0)          NEXT MBBCCHHR ADDRESS\nKEYLN    DS    X              NEXT KEYLENGTH\nDATALN   DS    2X             NEXT RECORD LENGTH\nSNO      DC    X'00'          NEXT SECTOR NUMBER\n\nCURMBB   DC    CL8' '         CURRENT MBBCCHHR ADDRESS\nMBBCCHH  DC    CL7' '         SAVE AREA FOR MBBCCHH\n\nPARMLEN  DC    F'11'          PARM MUST BE ELEVEN\nPARMDATA DS    0CL11\nSTARTNUM DS    CL05           STARTING GAS #### (IN PARM)\nDASHER   DS    CL01\nLASTNUM  DS    CL05           ENDING GAS #### (IN PARM)\n\nDW       DS    D\nSTART#   DC    F'1'           STARTING GAS #### (FOR CHECKING)\nLAST#    DC    XL4'7FFFFFFF'  ENDING GAS #### (FOR CHECKING\n\nECB      DC    F'0'           ECB\nLS       DC    F'0'           LENGTH OF THE CURRENT RECORD\nGASTTR   DC    XL8'00'\nFLAGS    DC    X'00'                      FLAG BYTE\nGASADD   EQU   X'01'                      GAS RECORDS TO BE RECOVERED\nREALONE  EQU   X'40'                      ERROR IN ACTUAL MEMBER FLAG\nDIRECTOR EQU   X'80'                      ERROR IN DIRECTORY RECORDS\nSAVECB   DC    X'00'                      SAVE AREA FOR ECB\nLASTR    DC    F'0'                       CURRENT NUMBER OF RECORDS/TRK\nEXCPR14  DC    F'0'                       RETURN REGISTER FOR EXCP\nEXCPR15  DC    F'0'                       EXIT FLAG REGISTER SAVEAREA\nSTATR14  DC    F'0'                       RETURN REGISTER FOR EXCPSTAT\nCUREXT   DC    F'0'                       ADDRESS OF THE CURRENT EXTENT\nNUMEXT   DC    F'0'                       TOTAL EXTENTS IN THE DATA SET\nREADTOT  DC    F'0'                       TOTAL RECORDS READ\nMINBLK   DC    F'33000'                   MINIMUM LENGTH BLOCK\nMAXBLK   DC    F'0'                       MAXIMUM LENGTH BLOCK\nBYTECNT  DC    F'0'                       TOTAL BYTES READ\nTEMP     DC    F'0'                       WORK STORAGE\nGASBYTE  DC    F'0'                       TOTAL BYTES IN GAS MEMBERS\nRELBYTE  DC    F'0'                       TOTAL BYTES IN REAL MEMBERS\nSAVETOT  DC    F'0'                       STARTING BYTE COUNT HOLD\nTRKBYTE  DC    F'0'                       SUM OF ALL BLOCKSIZES\nINAROW   DC    F'0'                       NUMBER OF CONSECUTIVE ERRORS\nCURBYTE  DC    F'0'                       CURRENT TRACK BYTE COUNT\nTRACKNUM DC    F'0'                       ACTUAL COUNT OF TRACKS USED\nMINUS1   DC    F'-1'                      NO NUMERIC OUTPUT FLAG\nEOFS     DC    F'0'                       COUNT OF END OF FILES\nGASCNT   DC    F'0'                       NUMBER OF \"GAS\" MEMBERS\nADDCNT   DC    F'0'                       NUMBER OF \"GAS\" TTR'S SAVED\nGASRDS   DC    F'0'                       NUMBER OF \"GAS\" RECORDS\nALIASES  DC    F'0'                       ALIASES IN THE DIRECTORY\nREALMBR  DC    F'0'                       REAL ENTRIES (DIRECTORY)\nREALENT  DC    F'0'                       MEMBER TABLE ENTRIES\n\nENDMBR   DC    CL50'END OF MEMBER (FILE MARKS) ARE RECORDED           '\nGASMBR   DC    CL50'\"GAS\" MEMBERS FOUND                               '\nNOGAS    DC    CL50'NO \"GAS\" MEMBERS FOUND                            '\nIOERROR  DC    CL50'READ ERROR--ECB=12; CCHHR=12.45.78.01.34          '\nTOOMANY  DC    CL50'TOO MANY CONSECUTIVE I/O ERRORS (10)              '\nMANYENT  DC    CL50'MORE THAN 3000 ENTRIES IN THE MEMBER TABLE        '\nNOTOPEN  DC    CL50'RDJFCB, OBTAIN OR OPEN FOR DDNAME SYSLIB FAILED   '\nFIRSTRD  DC    CL50'FIRST READ OF AN EXTENT WAS NOT SUCCESSFUL        '\nTTRTOLOW DC    CL50'TTR IN MEMBER TABLE IS LESS THAN THE CURRENT TTR  '\nNOTFOUND DC    CL50'SOME MEMBERS IN THE MEMBER TABLE WERE NOT FOUND   '\nBADERROR DC    CL50'UNDEFINED READ ERROR                              '\nPERMERR  DC    CL50'UNDEFINED PERMANENT ERROR                         '\nEOFSIMS  DC    CL50'BAD DIRECTORY RECORD -- RECORD LENGTH IS NOT 256  '\nBLOCKLEN DC    CL50'IS THE BLOCK LENGTH  (END OF DIRECTORY SIMULATED) '\nDIRERRS  DC    CL50'READ ERROR IN THE DIRECTORY                       '\nBLKNUMS  DC    CL50'IS THE BLOCK NUMBER  (BLOCK IGNORED)              '\nGASERRS  DC    CL50'ERROR IN A GAS MEMBER  (END OF MEMBER SIMULATED)  '\nCURRMBR  DC    CL50'12345678 IS THE MEMBER  (END OF MEMBER SIMULATED) '\nGASMEM   DC    CL50'\"GAS\" MEMBER AT TTR TT.TT.RR, DATA:               '\nNOTPDS   DC    CL50'SYSLIB DATA SET IS NOT PARTITIONED                '\nBLANKS   DC    CL256' '                                               '\nHEXTBL   DC    CL16'0123456789ABCDEF'\n\nWORK     DC    CL80' '\nDOUBLE   DS    D\nLASTMBB  DS    D\nJFCBXIT  DC    X'87',AL3(JFCB)            JFCB BLOCK\nJFCB     DS    0D\n*        IEFJFCBN                         JFCB MAPPING MACRO\nJFCBDSNM DS    CL44,CL8\nJFCBTSDM DS    B,CL65\nJFCBVOLS DS    CL30,CL28                  TOTAL LENGTH 176\n\n         PRINT NOGEN\n\nPRT      DCB   DDNAME=SYSPRINT,MACRF=PM,DSORG=PS,                      *\n               RECFM=FBA,LRECL=121,BLKSIZE=121\n\nLIB      DCB   DDNAME=SYSLIB,DSORG=PS,MACRF=E,EXLST=JFCBXIT\n\n         PRINT GEN\n\nMYLABEL  CAMLST SEARCH,JFCBDSNM,JFCBVOLS,WORKAREA\nWORKAREA DS    0D,148C\nDS1NOBDB EQU   WORKAREA+16    BYTES USED IN LAST DIRECTORY BLOCK\nDS1DSORG EQU   WORKAREA+38    DSORG\nDS1RECFM EQU   WORKAREA+40    RECFM\nDS1BLKSI EQU   WORKAREA+42    BLKSIZE\nDS1LRECL EQU   WORKAREA+44    LRECL\nDS1KEYL  EQU   WORKAREA+46    KEYLEN\nDS1RKP   EQU   WORKAREA+47    RELATIVE KEY POSITION\nDS1SCALO EQU   WORKAREA+50    ALLOCATION TYPE\nDS1SAQU  EQU   WORKAREA+51    SECONDARY ALLOCATION QUANTITY\nDS1LSTAR EQU   WORKAREA+54    LAST USED TTR\nDS1TRBAL EQU   WORKAREA+57    BYTES REMAINING IN LAST USED TRACK\n\n         LTORG\n\n         DS    0D\nSAVEGAS  DS    1000XL3               ROOM FOR 1000 ENTRIES\n\n@SPACE   DSECT\nSAVEAREA DS    9D                 SAVE AREA\nBUFFERP  DS    D                  ALLOW REFERENCE TO BUFFER-1\nBUFFER   DS    32768X\nDS2NOLEV EQU   BUFFER+1  (1)      INDEX LEVELS\nDS2DVIND EQU   BUFFER+2  (1)      TRACKS FOR MASTER LEVEL\nDS2CYLOV EQU   BUFFER+8  (1)      TRACKS OF CYLINDER OVERFLOW/CYLINDER\nDS2TAGDT EQU   BUFFER+15 (2)      RECORDS TAGGED FOR DELETION\nDS2RORG3 EQU   BUFFER+17 (3)      OVERFLOW ACCESSES\nDS2NOBYT EQU   BUFFER+20 (2)      BYTES TO HOLD THE HIGHEST INDEX\nDS2NOTRK EQU   BUFFER+22 (1)      TRACKS OCCUPPIED BY THE HIGHEST INDEX\nDS2PRCTR EQU   BUFFER+23 (4)      RECORDS IN THE PRIME AREA\nDS2BYOVL EQU   BUFFER+80 (2)      BYTES LEFT ON THE CURR. IND. OVR. TRK\nDS2RORG2 EQU   BUFFER+82 (2)      TRACKS LEFT IN THE IND. OVERFLOW AREA\nDS2OVRCT EQU   BUFFER+84 (2)      RECORDS IN THE OVERFLOW AREA\nDS2RORG1 EQU   BUFFER+86 (2)      CYLINDER AREAS THAT ARE FULL\n*\nSAVETBP  DS    2D                   ALLOW REFERENCE TO SAVETBL-16\nSAVETBL  DS    48048X\nSAVEEND  DS    0D\n@SPACEL  EQU   *-@SPACE\n\n         PRINT NOGEN\n         DCBD  DSORG=PS,DEVD=DA\n\n         END\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//***\n//***\n//L          EXEC     PGM=IEWL,\n//             PARM='XREF,LIST,LET,DCBS',\n//             REGION=4M\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOAD-MOD-LIB-,\n//             DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   99102900\n  ENTRY    PDSGAS\n  NAME     PDSGAS(R)\n//***\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSGAS$": {"ttr": 30470, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\x0e\\x00\\x0e\\x00\\x00\\xd7\\xc4\\xe2\\xc7\\xc1\\xe2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "PDSGAS"}, "text": "//-YOUR-USER-ID-G JOB (BT00,0000),'CARL HAFNER - 2S',\n//             CLASS=E,MSGCLASS=X,NOTIFY=-YOUR-USER-ID-\n//***\n//***  RESTORE DELETED PDS MEMBERS (IF NOT YET COMPRESSED).  NOTE IT\n//***  DOESN'T WORK ON LOAD LIB'S (CAN'T GEN ATTRIBUTES).  ADJUST THE\n//***  PARM IF ONLY SELECTED GAS MEMBERS TO BE GENERATED - RUN WITH\n//***  PARM=99999-99999 FIRST TO SEE AVAILABLE GAS MEMBERS.  KEEP\n//***  THE EXACT FORMAT OF THE PARM!\n//***\n//PDSGAS     EXEC     PGM=PDSGAS,REGION=4M,PARM=00001-99999\n//SYSLIB       DD       DISP=SHR,DSN=-SOME-PDS-LIB\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOAD-MOD-LIB-\n//SYSPRINT     DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDSGEN": {"ttr": 30472, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x03'\\x1f\\x01\\x03'\\x1f\\x12\\x00\\x07\\x89\\x07\\x89\\x00\\x00\\xd7\\xc4\\xe2\\xc7\\xc5\\xd5@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-09-28T00:00:00", "modifydate": "2003-09-28T12:00:00", "lines": 1929, "newlines": 1929, "modlines": 0, "user": "PDSGEN"}, "text": "//-YOUR-USER-ID-P JOB (BT00,0000),'-YOUR-NAME-',\n//             CLASS=E,MSGCLASS=X,NOTIFY=-YOUR-USER-ID-\n//***\n//***  PARTITIONED DATA SET IMAGE GENERATION UTILITY ASSEMBLY AND LINK\n//***\n//A          EXEC     PGM=ASMA90,REGION=4M,\n//             PARM='RENT'\n//SYSLIB       DD       DISP=SHR,DSN=SYS1.MACLIB\n\n         TITLE '***  PDSGEN  --  FREEWARE  --  STELI INC. 2001  ***'\n\n*  PDSGEN IS MAINFRAME FREEWARE. SUGGESTIONS, QUESTION OR PROBLEM\n*  REPORTS ARE WELCOME TO C_HAFNER@HOTMAIL.COM\n\n***********************************************************************\n*    DEFAULT OPTION VALUES\n***********************************************************************\n\n&DDOPTS  SETC  'SYSIN'            DDNAME FOR OPTIONS FILE\n&DDPDS   SETC  'SYSUT1'           DDNAME FOR PARTITIONED DATA SET\n&DDGEN   SETC  'SYSGEN'           DDNAME FOR INPUT IMAGE SKELETON FILE\n&DDOUT   SETC  'SYSOUT'           DDNAME FOR OUTPUT IMAGES FILE\n&DDPRINT SETC  'SYSPRINT'         DDNAME FOR LISTING FILE\n\n&DEFBLKSI SETA 121                SYSPRINT BLOCK SIZE DEFAULT\n&DEFCDCNT SETA 1000               DEFAULT SKELETON IMAGE COUNT\n&DEFCDSZ  SETA 72                 DEFAULT FOR IMAGE SIZE\n&DEFDUPS  SETC 'N'                DUPS DEFAULT\n&DEFDUPSO SETC 'N'                DUPS ONLY DEFAULT\n&DEFINDX  SETC 'N'                INDEX DEFAULT\n&DEFPERC  SETC '%'                DEFAULT VARIABLE INDICATOR\n&DEFPOUND SETC '#'                DEFAULT FIXED INDICATOR\n\n***********************************************************************\n*    PROGRAM ENTRY\n***********************************************************************\n\nPDSGEN   AMODE 31\nPDSGEN   RMODE ANY\n\nR0       EQU    0                 VARIED USAGE - ROUTINE DEPENDENT\nR1       EQU    1                   \"      \"        \"        \"\nR2       EQU    2                   \"      \"        \"        \"\nR3       EQU    3                   \"      \"        \"        \"\nR4       EQU    4                   \"      \"        \"        \"\nR5       EQU    5                   \"      \"        \"        \"\nR6       EQU    6                   \"      \"        \"        \"\nR7       EQU    7                   \"      \"        \"        \"\nR8       EQU    8                   \"      \"        \"        \"\nR9       EQU    9                   \"      \"        \"        \"\nR10      EQU   10                 BASE REGISTER\nR11      EQU   11                 BASE REGISTER\nR12      EQU   12                 RETURN REGISTER FOR SUBROUTINES\nR13      EQU   13                 SAVE AREA & MISCELLANEOUS STORAGE\nR14      EQU   14                 SHORT TERM WORK REGISTER\nR15      EQU   15                 SHORT TERM WORK REGISTER\n\nPDSGEN   CSECT                    ENTRY POINT\n         STM   R14,R12,12(R13)\n         LR    R10,R15\n         LA    R11,4095\n         LA    R11,1(R10,R11)\n         USING PDSGEN,R10,R11\n         LA    R0,WORKL\n         STORAGE  OBTAIN,LENGTH=(0),LOC=BELOW\n         ST    R1,8(R13)\n         ST    R13,4(R1)\n         LM    R0,R1,20(R13)\n         L     R13,8(R13)\n         USING WORKAREA,R13       R13 -> SAVEAREA + DYNAMIC STORAGE\n         USING IHADCB,R7          PERIODIC USE - REQUIRES LOCAL LOAD\n\n***********************************************************************\n*    MAIN LINE\n***********************************************************************\n\n         BAS   R12,INITSTOR       INITIALIZE OBTAINED MEMORY\n         BAS   R12,OPENDSS        OPEN FILES\n         BAS   R12,GETOPTNS       READ AND SET UP PARMS\n         BAS   R12,READDIR        BUILD THE DIRECTORY LIST\n         BAS   R12,DETDUPS        DETERMINE WHICH ARE DUPS\n         BAS   R12,GENIMAGE       WRITE THE GENERATED IMAGES\n         BAS   R12,PRTDSNS        PRINT THE CONCATENATED DSN'S\n         BAS   R12,PRTINDEX       PRINT THE INDEX\n         BAS   R12,CLOSERTN       CLOSE ALL FILES\nEXITALL  EQU   *\n         L     R15,FINALRC        SET LAST RETURN CODE\n         L     R13,4(R13)         TERMINATE PROGRAM LEAVING REG 15\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n\n***********************************************************************\n*    INITIALIZE THE OBTAINED STORAGE WITH STARTING VALUES OR WITH\n*    I/O MACRO EXPANSIONS\n***********************************************************************\n\nINITSTOR EQU   *\n\n         XC    FINALRC,FINALRC    INITIALIZE FINAL RETURN CODE TO 0\n\n         LA    R0,WKINGSTG        INITIALIZE DYNAMIC STORAGE AREA\n         LA    R1,DYNAML\n         LA    R14,DYNAMA\n         LR    R15,R1\n         MVCL  R0,R14\n\n         LA    R14,JFCBAREA       SET UP READ JFCB CONNECTIONS\n         ST    R14,EXLST\n         MVI   EXLST,X'87'\n         LA    R14,EXLST\n         LA    R7,DIR\n         ST    R14,EXLSTPTR\n         MVC   DCBEXLSA(3),EXLSTPTR+1\n         LA    R14,DIRE           SET UP DCBE'S IN WORKING STORAGE\n         ST    R14,DCBDCBE\n         LA    R7,SYSGEN\n         LA    R14,SYSGENE\n         ST    R14,DCBDCBE\n         LA    R7,SYSIN\n         LA    R14,SYSINE\n         ST    R14,DCBDCBE\n\n         L     R0,DSNASIZE        GET STORAGE FOR DATA SET NAMES\n         STORAGE  OBTAIN,LENGTH=(0),LOC=ANY\n         ST    R1,DSNAREA\n\n         BR    R12\n\n***********************************************************************\n*    OPEN THE DCBS FROM THE GETMAINED AREAS\n***********************************************************************\n\n*  R1 -> OPEN MACRO\n*  R5 THRU R8 -> DCB'S\n\nOPENDSS  EQU   *\n         LA    R1,OPEN\n         LA    R5,DIR\n         LA    R6,SYSGEN\n         LA    R7,SYSOUT\n         LA    R8,SYSPRINT\n         OPEN  ((R5),,(R6),,(R7),OUTPUT,(R8),OUTPUT),MF=(E,(1)),MODE=31\n         LTR   R15,R15\n         BZ    OPENOK01\n         ST    R15,FINALRC\n         B     EXITALL\n\nOPENOK01 EQU   *\n         LA    R1,OPENSYSI\n         LA    R5,SYSIN\n         OPEN  ((R5)),MF=(E,(1)),MODE=31\n         LTR   R15,R15\n         BZ    OPENOK02\n         MVI   SYSINOK,C'N'\n\nOPENOK02 EQU   *\n         BR    R12\n\n***********************************************************************\n*    GET ANY SYSIN PARAMETERS\n***********************************************************************\n      ???\n*  R0 -> REMAINDER AFTER DIVIDE; STORAGE LENGTH\n*  R1 -> QUOTIENT AFTER DIVIDE; RETURNED STORAGE ADDRESS\n*  R2 -> TRT CLOBBERS IT UNDER SOME CIRCUMSTANCES\n*  R5 -> END OF OPTION CARD (COL 72)\n*  R6 -> LENGTH REMAINING\n*  R7 -> IHADCB; TRT REGISTER (OPTNUMCK)\n*  R8 -> MOVING POINTER TO OPTION CARD\n\nGETOPTNS EQU   *\n         CLI   SYSINOK,C'Y'       SYSIN PROVIDED?\n         BNE   OPTNEXIT\n\nGETSYSIN EQU   *\n         GET   SYSIN\n         LA    R5,71(R1)          POINT TO END OF CARD\n         LR    R8,R1\nOPTNSCAN EQU   *\n         LR    R6,R5              CALCULATE LENGTH REMAINING\n         SR    R6,R8\n         LA    R6,1(R6)\n         C     R6,FW2             CHECK IF ANY POSSIBLE DATA\n         BL    GETSYSIN\n         CLC   OPTNO,0(R8)        CHECK FOR 'NO'\n         BE    OPTNNO\n         C     R6,FW3             CHECK FOR APPROPRIATE LENGTHS\n         BL    GETSYSIN\n         BE    OPTL3\n         C     R6,FW4\n         BNH   OPTL4\n         C     R6,FW5\n         BNH   OPTL5\n         C     R6,FW6\n         BNH   OPTL6\n         C     R6,FW7\n         BNH   OPTL7\n         C     R6,FW8\n         BNH   OPTL8\n         C     R6,FW9\n         BNH   OPTL9\n         C     R6,FW10\n         BNH   OPTL10\n         CLC   OPTINDXO,0(R8)     CHECK FOR INDEX(ONLY)\n         BNE   OPTL10\n         MVI   DEFIO,C'Y'\n         MVI   DEFI,C'Y'\n         LA    R8,L'OPTINDXO(R8)\n         B     OPTNSCAN\n\nOPTL10   EQU   *\n         CLC   OPTBLKSI,0(R8)     CHECK FOR BLKSIZE(...)\n         BNE   OPTL1D\n         LA    R8,L'OPTBLKSI(R8)\n         LR    R14,R8\nOPTL1BA  EQU   *\n         CLI   0(R14),C')'\n         BE    OPTL1BB\n         LA    R14,1(R14)\n         CR    R14,R5\n         BH    OPTNEXT\n         B     OPTL1BA\nOPTL1BB  EQU   *\n         CR    R8,R14\n         BE    OPTNEXT\n         SR    R14,R8\n         C     R14,FW5\n         BH    OPTNEXT\n         BCTR  R14,0\n         LR    R7,R8\n         EX    R14,OPTNUMCK\n         BNZ   OPTNEXT\n         EX    R14,OPTPACK\n         CVB   R15,DW\n         C     R15,FW32670\n         BH    OPTNEXT\n         SR    R0,R0\n         LR    R1,R15\n         D     R0,FW121\n         LTR   R0,R0\n         BNZ   OPTNEXT\n         LA    R7,SYSPRINT\n         STH   R15,DCBBLKSI\n         OI    DCBRECFM,X'10'\n         LA    R8,0(R14,R8)\n         B     OPTNSCAN\n\nOPTL1D   EQU   *\n         CLC   OPTDUPO,0(R8)      CHECK FOR DUPS(ONLY)\n         BNE   OPTL1F\n         MVI   DEFDO,C'Y'\n         MVI   DEFD,C'Y'\n         LA    R8,L'OPTDUPO(R8)\n         B     OPTNSCAN\n\nOPTL1F   EQU   *\n         CLC   OPTFOOT,0(R8)      CHECK FOR FOOTING(...)\n         BNE   OPTL1L\n         LA    R8,L'OPTFOOT(R8)\n         LR    R14,R8\nOPTL1FA  EQU   *\n         CLI   0(R14),C')'\n         BE    OPTL1FB\n         LA    R14,1(R14)\n         CR    R14,R5\n         BH    OPTNEXT\n         B     OPTL1FA\nOPTL1FB  EQU   *\n         CR    R8,R14\n         BE    OPTNEXT\n         SR    R14,R8\n         MVI   DEFF,C'Y'\n         MVI   FOOTLINE,C'0'\n         MVC   FOOTLINE+1(120),BLANKS\n         LA    R15,120\n         SR    R15,R14\n         SRL   R15,1\n         ST    R15,FOOTOFFS\n         LA    R15,FOOTLINE+1(R15)\n         BCTR  R14,0\n         EX    R14,MVCFOOT\n         LA    R8,2(R14,R8)\n         B     OPTNSCAN\n\nOPTL1L   EQU   *\n         CLC   OPTLC,0(R8)        CHECK FOR LINECNT(...)\n         BNE   OPTL1X\n         LA    R8,L'OPTLC(R8)\n         LR    R14,R8\nOPTL1LA  EQU   *\n         CLI   0(R14),C')'\n         BE    OPTL1LB\n         LA    R14,1(R14)\n         CR    R14,R5\n         BH    OPTNEXT\n         B     OPTL1LA\nOPTL1LB  EQU   *\n         CR    R8,R14\n         BE    OPTNEXT\n         SR    R14,R8\n         C     R14,FW7\n         BH    OPTNEXT\n         BCTR  R14,0\n         LR    R7,R8\n         EX    R14,OPTNUMCK\n         BNZ   OPTNEXT\n         EX    R14,OPTPACK\n         CVB   R15,DW\n         C     R15,FW4\n         BH    OPTL1LC\n         L     R15,FW4\nOPTL1LC  EQU   *\n         ST    R15,DEFP\n         LA    R8,0(R14,R8)\n         B     OPTNSCAN\n\nOPTL1X   EQU   *\n         CLC   OPTGTMEM,0(R8)     CHECK FOR >MEMBER(...)\n         BNE   OPTL1Z\n         LA    R8,L'OPTGTMEM(R8)\n         LR    R14,R8\nOPTL1XA  EQU   *\n         CLI   0(R14),C')'\n         BE    OPTL1XB\n         LA    R14,1(R14)\n         CR    R14,R5\n         BH    OPTNEXT\n         B     OPTL1XA\nOPTL1XB  EQU   *\n         CR    R8,R14\n         BE    OPTNEXT\n         SR    R14,R8\n         BCTR  R14,0\n         MVC   DEFMEMG,BLANKS\n         EX    R14,MVCMEMGT\n         LA    R8,0(R14,R8)\n         B     OPTNSCAN\n\nOPTL1Z   EQU   *\n         CLC   OPTLTMEM,0(R8)     CHECK FOR <MEMBER(...)\n         BNE   OPTL9\n         LA    R8,L'OPTLTMEM(R8)\n         LR    R14,R8\nOPTL1YA  EQU   *\n         CLI   0(R14),C')'\n         BE    OPTL1YB\n         LA    R14,1(R14)\n         CR    R14,R5\n         BH    OPTNEXT\n         B     OPTL1YA\nOPTL1YB  EQU   *\n         CR    R8,R14\n         BE    OPTNEXT\n         SR    R14,R8\n         BCTR  R14,0\n         MVC   DEFMEML,BLANKS\n         EX    R14,MVCMEMLT\n         LA    R8,0(R14,R8)\n         B     OPTNSCAN\n\nOPTL9    EQU   *\n         CLC   OPTTRANS,0(R8)     CHECK FOR TRANSLATE\n         BNE   OPTL8\n         MVI   DEFT,C'Y'\n         LA    R8,L'OPTTRANS(R8)\n         B     OPTNSCAN\n\nOPTL8    EQU   *\n         CLC   OPTFIRST,0(R8)     CHECK FOR FIRST(...)\n         BNE   OPTL7\n         LA    R8,L'OPTFIRST(R8)\n         LR    R14,R8\nOPTL1FJ  EQU   *\n         CLI   0(R14),C')'\n         BE    OPTL1FK\n         LA    R14,1(R14)\n         CR    R14,R5\n         BH    OPTNEXT\n         B     OPTL1FJ\nOPTL1FK  EQU   *\n         CR    R8,R14\n         BE    OPTNEXT\n         SR    R14,R8\n         BCTR  R14,0\n         LR    R7,R8\n         EX    R14,OPTNUMCK\n         BNZ   OPTNEXT\n         EX    R14,OPTPACK\n         CVB   R15,DW\n         ST    R15,DEF1\n         LA    R8,1(R14,R8)\n         B     OPTNSCAN\n\nOPTL7    EQU   *\n         CLC   OPTOPTNS,0(R8)     CHECK FOR OPTIONS\n         BNE   OPTL6\n         MVI   DEFO,C'Y'\n         LA    R8,L'OPTOPTNS(R8)\n         B     OPTNSCAN\n\nOPTL6    EQU   *\n         CLC   OPTVARS,0(R8)      CHECK FOR VARSEQ\n         BNE   OPTL5\n         MVI   DEFV,C'Y'\n         LA    R8,L'OPTVARS(R8)\n         B     OPTNSCAN\n\nOPTL5    EQU   *\n         CLC   OPTEJECT,0(R8)     CHECK FOR EJECT\n         BNE   OPTL5A\n         MVI   DEFE,C'Y'\n         LA    R8,L'OPTEJECT(R8)\n         B     OPTNSCAN\n\nOPTL5A   EQU   *\n         CLC   OPTINDEX,0(R8)     CHECK FOR INDEX\n         BNE   OPTL5B\n         MVI   DEFI,C'Y'\n         LA    R8,L'OPTINDEX(R8)\n         B     OPTNSCAN\n\nOPTL5B   EQU   *\n         CLC   OPTALIAS,0(R8)     CHECK FOR ALIAS\n         BNE   OPTL4\n         MVI   DEFA,C'Y'\n         LA    R8,L'OPTALIAS(R8)\n         B     OPTNSCAN\n\nOPTL4    EQU   *\n         CLC   OPTDUPS,0(R8)      CHECK FOR DUPS\n         BNE   OPTL3\n         MVI   DEFD,C'Y'\n         LA    R8,L'OPTDUPS(R8)\n         B     OPTNSCAN\n\nOPTL3    EQU   *\n         CLC   OPTHEX,0(R8)       CHECK FOR HEX\n         BNE   OPTNEXT\n         MVI   DEFH,C'Y'\n         LA    R8,L'OPTHEX(R8)\n         B     OPTNSCAN\n\nOPTNEXT  LA    R8,1(R8)\n         B     OPTNSCAN\n\nOPTNNO   EQU   *                  CHECK FOR \"NO\" OPTIONS\n         LA    R8,2(R8)\n         BCTR  R6,0\n         BCTR  R6,0\n         C     R6,FW3             CHECK FOR APPROPRIATE LENGTHS\n         BNH   OPTN3\n         C     R6,FW4\n         BNH   OPTN4\n         C     R6,FW5\n         BNH   OPTN5\n         C     R6,FW6\n         BNH   OPTN6\n         C     R6,FW7\n         BNH   OPTN7\n         C     R6,FW9\n         BNH   OPTN9\n\nOPTN9    EQU   *\n         CLC   OPTTRANS,0(R8)     CHECK FOR NEGATIVE TRANSLATE\n         BNE   OPTN7\n         MVI   DEFT,C'N'\n         LA    R8,L'OPTTRANS(R8)\n         B     OPTNSCAN\n\nOPTN7    EQU   *\n         CLC   OPTOPTNS,0(R8)     CHECK FOR NEGATIVE OPTIONS\n         BNE   OPTN6\n         MVI   DEFO,C'N'\n         LA    R8,L'OPTOPTNS(R8)\n         B     OPTNSCAN\n\nOPTN6    EQU   *\n         CLC   OPTVARS,0(R8)      CHECK FOR NEGATIVE VARSEQ\n         BNE   OPTN5\n         MVI   DEFV,C'N'\n         LA    R8,L'OPTVARS(R8)\n         B     OPTNSCAN\n\nOPTN5    EQU   *\n         CLC   OPTEJECT,0(R8)     CHECK FOR NEGATIVE EJECT\n         BNE   OPTN5A\n         MVI   DEFE,C'N'\n         LA    R8,L'OPTEJECT(R8)\n         B     OPTNSCAN\n\nOPTN5A   EQU   *\n         CLC   OPTINDEX,0(R8)     CHECK FOR NEGATIVE INDEX\n         BNE   OPTN5B\n         MVI   DEFI,C'N'\n         LA    R8,L'OPTINDEX(R8)\n         B     OPTNSCAN\n\nOPTN5B   EQU   *\n         CLC   OPTALIAS,0(R8)     CHECK FOR NEGATIVE ALIAS\n         BNE   OPTN4\n         MVI   DEFA,C'N'\n         LA    R8,L'OPTALIAS(R8)\n         B     OPTNSCAN\n\nOPTN4    EQU   *\n         CLC   OPTDUPS,0(R8)      CHECK FOR NEGATIVE DUPS\n         BNE   OPTN3\n         MVI   DEFD,C'N'\n         LA    R8,L'OPTDUPS(R8)\n         B     OPTNSCAN\n\nOPTN3    EQU   *\n         CLC   OPTHEX,0(R8)       CHECK FOR NEGATIVE HEX\n         BNE   OPTNEXT\n         MVI   DEFH,C'N'\n         LA    R8,L'OPTHEX(R8)\n         B     OPTNSCAN\n\nOPTNEXIT EQU   *\n         L     R14,DEFP\n         BCTR  R14,0\n         ST    R14,DEFP\n         CLI   DEFF,C'Y'\n         BNE   OPTNEX99\n         L     R14,DEFP\n         S     R14,FW2\n         ST    R14,DEFP\nOPTNEX99 EQU   *\n         BR    R12\n\n***********************************************************************\n*    DISPLAY THE OPTIONS CHOSEN AND THOSE DEFAULTED\n***********************************************************************\n\n*  R3 -> PAGE SIZE\n*  R4 -> DESCRIPTION ARRAY POINTER\n*  R5 -> VALUE ARRAY POINTER\n\nLSTOPTNS EQU   *\n         CLI   DEFO,C'Y'\n         BNE   LSTOPTEX\n\n         MVC   OPTNVALS,BLANKS\n         LA    R5,OPTNVALS        ALIAS VALUE\n         MVC   0(3,R5),YES\n         CLI   DEFA,C'Y'\n         BE    LSTOPTAY\n         MVC   0(3,R5),NO\nLSTOPTAY EQU   *\n\n         LA    R5,8(R5)           DUPS OR DUPS(ONLY) VALUE\n         MVC   0(3,R5),YES\n         CLI   DEFD,C'Y'\n         BE    LSTOPTDY\n         MVC   0(3,R5),NO\nLSTOPTDY EQU   *\n         CLI   DEFDO,C'Y'\n         BNE   LSTOPTDX\n         MVC   0(4,R5),ONLY\nLSTOPTDX EQU   *\n\n         LA    R5,8(R5)           EJECT VALUE\n         MVC   0(3,R5),YES\n         CLI   DEFE,C'Y'\n         BE    LSTOPTEY\n         MVC   0(3,R5),NO\nLSTOPTEY EQU   *\n\n         LA    R5,8(R5)           FIRST VALUE\n         L     R14,DEF1\n         CVD   R14,DW\n         UNPK  0(8,R5),DW+3(5)\n         OI    7(R5),X'F0'\n\n         LA    R5,8(R5)           FOOTING VALUE\n         MVC   0(3,R5),NO\n         CLI   DEFF,C'Y'\n         BNE   LSTOPTFN\n         MVC   0(8,R5),OPTFOOT    SET PRELIMINARY VALUE\nLSTOPTFN EQU   *\n\n         LA    R5,8(R5)           HEX VALUE\n         MVC   0(3,R5),YES\n         CLI   DEFH,C'Y'\n         BE    LSTOPTHY\n         MVC   0(3,R5),NO\nLSTOPTHY EQU   *\n\n         LA    R5,8(R5)           INDEX OR INDEX(ONLY) VALUE\n         MVC   0(3,R5),YES\n         CLI   DEFI,C'Y'\n         BE    LSTOPTIY\n         MVC   0(3,R5),NO\nLSTOPTIY EQU   *\n         CLI   DEFIO,C'Y'\n         BNE   LSTOPTIX\n         MVC   0(4,R5),ONLY\nLSTOPTIX EQU   *\n\n         LA    R5,8(R5)           LINECNT VALUE\n         L     R14,DEFP\n         LA    R14,1(R14)\n         CLI   DEFF,C'Y'\n         BNE   LSTOPTLX\n         LA    R14,2(R14)\nLSTOPTLX EQU   *\n         CVD   R14,DW\n         UNPK  0(8,R5),DW+3(5)\n         OI    7(R5),X'F0'\n\n         LA    R5,8(R5)           TRANSLATE VALUE\n         MVC   0(3,R5),YES\n         CLI   DEFT,C'Y'\n         BE    LSTOPTTY\n         MVC   0(3,R5),NO\nLSTOPTTY EQU   *\n\n         LA    R5,8(R5)           VARSEQ VALUE\n         MVC   0(3,R5),YES\n         CLI   DEFV,C'Y'\n         BE    LSTOPTVY\n         MVC   0(3,R5),NO\nLSTOPTVY EQU   *\n\n         LA    R5,8(R5)           >MEMBER VALUE\n         MVC   0(8,R5),LOVALUES\n         CLC   DEFMEMG,EIGHTX00\n         BE    LSTOPTGN\n         MVC   0(8,R5),DEFMEMG\nLSTOPTGN EQU   *\n\n         LA    R5,8(R5)           <MEMBER VALUE\n         MVC   0(8,R5),HIVALUES\n         CLC   DEFMEML,EIGHTXFF\n         BE    LSTOPTLN\n         MVC   0(8,R5),DEFMEML\nLSTOPTLN EQU   *\n\n         LA    R4,OPTNDESC        POINT TO DESCRIPTIONS ARRAY\n         LA    R5,OPTNVALS        POINT TO VALUE ARRAY\n         MVC   OPTNHDR,BLANKS     SET UP HEADER AND DISPLAY VALUES\n         MVC   OPTNHDR+1(11),HDR+1\n         MVC   OPTNHDR+53(15),OPTNTIT\n         MVC   PRTLINE,BLANKS\n\nLSTOPT10 EQU   *\n         L     R3,DEFP            PAGE SIZE\n         PUT   SYSPRINT,OPTNHDR\n         PUT   SYSPRINT,UNDER\nLSTOPT20 EQU   *\n         MVC   PRTLINE+4(9),0(R4)\n         MVC   PRTLINE+14(8),0(R5)\n         CLC   0(8,R5),OPTFOOT\n         BNE   LSTOPT30\n         L     R14,FOOTOFFS\n         LA    R14,FOOTLINE(R14)\n         MVC   PRTLINE+13(63),0(R14)\nLSTOPT30 EQU   *\n         PUT   SYSPRINT,PRTLINE\n         CLC   0(7,R4),OPTLTMEM\n         BE    LSTOPT99\n         LA    R4,9(R4)\n         LA    R5,8(R5)\n         MVC   PRTLINE,BLANKS\n         BCT   R3,LSTOPT20\n         CLI   DEFF,C'Y'\n         BNE   LSTOPT10\n         PUT   SYSPRINT,FOOTLINE\n         B     LSTOPT10\n\nLSTOPT99 EQU   *\n         CLI   DEFF,C'Y'\n         BNE   LSTOPTEX\n         PUT   SYSPRINT,FOOTLINE\n\nLSTOPTEX EQU   *\n         BR    R12\n\n***********************************************************************\n*    READ THE DIRECTORY(S)\n***********************************************************************\n\n*  R2 -> NUMBER OF SLOTS LEFT\n*  R3 -> END OF DIR ENTRY\n*  R4 -> MEMBER IN DIR ENTRY\n*  R5 -> DSN AREA (FROM DSNAREA)\n*  R6 -> NEW SLOT POINTER\n*  R7 -> IHADCB\n*  R8 -> CURRENT MEMBER IN SLOT LIST\n*  R9 -> NEXT MEMBER IN SLOT LIST\n\nREADDIR  EQU   *\n         LA    R2,1\n         L     R5,DSNAREA\n         LA    R7,DIR\n         LA    R8,EIGHTXFF\n         LR    R9,R8\n\nRDDIR010 EQU   *\n         RDJFCB  DIR,MF=(E,RDJFCB)  GET DSN & VOLSER\n         MVC   0(44,R5),JFCBAREA\n         MVC   44(6,R5),JFCBAREA+118\n         LA    R5,50(R5)\n\nRDDIR020 EQU   *\n         GET   (R7)               GET A DIRECTORY BLOCK\n         LH    R3,0(R1)\n         LA    R4,2(R1)\n         LA    R3,0(R1,R3)\n\nRDDIR030 EQU   *\n         CR    R4,R3              END OF BLOCK?\n         BNL   RDDIR020\n         CLC   EIGHTXFF,0(R4)     TERMINATING ENTRY FOR A PDS?\n         BNE   RDDIR040\n         L     R14,CATCNT         GET READY FOR NEXT PDS (IF ANY)\n         LA    R14,1(R14)\n         ST    R14,CATCNT\n         FEOV  DIR\n         B     RDDIR010\n\nRDDIR040 EQU   *\n         CLC   DEFMEMG,0(R4)      SHOULD THIS MEMBER BE SELECTED?\n         BH    RDDIR110\n         CLC   DEFMEML,0(R4)\n         BL    RDDIR110\n         BCT   R2,RDDIR050\n         L     R0,FW12288         LOAD SLOT AREA SIZE FOR GETMAIN\n         STORAGE  OBTAIN,LENGTH=(0),LOC=ANY\n         LR    R6,R1              SAVE POINTER TO MEMBER SLOT AREA\n         LA    R2,614\n\nRDDIR050 EQU   *\n         MVC   SLOTOFFM(11,R6),0(R4)  SAVE DIRECTORY DATA INTO LIST\n         MVC   SLOTOFFC(1,R6),CATCNT+3\n         MVC   SLOTOFFX(L'DEFSLOT,R6),DEFSLOT\n         TM    11(R4),X'80'       CHECK IF ALIAS\n         BNO   RDDIR055\n         MVI   SLOTOFFA(R6),C'Y'\n\nRDDIR055 EQU   *\n         SR    R14,R14\n         IC    R14,11(R4)\n         SLL   R14,27             POINT TO NEXT DIRECTORY ENTRY\n         SRL   R14,26\n         LA    R4,12(R14,R4)\n\nRDDIR070 EQU   *\n         CLC   SLOTOFFM(8,R6),SLOTOFFM(R8)  PUT NEW MEMBER INTO CHAIN\n         BNL   RDDIR090\n         L     R8,FIRSTMEM\n         CLC   SLOTOFFM(8,R6),SLOTOFFM(R8)\n         BL    RDDIR080\n         L     R8,12(R8)\n         L     R9,12(R8)\n         CLC   SLOTOFFM(8,R6),SLOTOFFM(R8)  CHECK IF HIGHER THAN 2ND\n         BNL   RDDIR090\n         LR    R9,R8\n         L     R8,FIRSTMEM\n         B     RDDIR090\n\nRDDIR080 EQU   *\n         ST    R8,SLOTOFFN(R6)    NEW FIRST MEMBER\n         LR    R9,R8\n         ST    R6,FIRSTMEM\n         LR    R8,R6\n         LA    R6,SLOTSIZE(R6)\n         B     RDDIR030\n\nRDDIR090 EQU   *\n         CLC   SLOTOFFM(8,R6),SLOTOFFM(R9)  BETWEEN CURRENT AND NEXT?\n         BL    RDDIR100\n         LR    R8,R9\n         L     R9,12(R8)\n         B     RDDIR090\n\nRDDIR100 EQU   *\n         ST    R6,SLOTOFFN(R8)    STORE AS NEW BETWEEN\n         LR    R8,R6\n         ST    R9,SLOTOFFN(R6)\n         LA    R6,SLOTSIZE(R6)\n         B     RDDIR030\n\nRDDIR110 EQU   *\n         SR    R14,R14\n         IC    R14,11(R4)\n         SLL   R14,27             POINT TO NEXT DIRECTORY ENTRY\n         SRL   R14,26                WHEN MEMBER NOT SELECTED\n         LA    R4,12(R14,R4)\n         B     RDDIR030\n\nRDDIREOF EQU   *\n         BR    R12\n\n***********************************************************************\n*    DETERMINE WHICH ARE DUPS (FOR DUPS/DUPS(ONLY) USAGE\n***********************************************************************\n\n*  R8 -> CURRENT MEMBER IN SLOT LIST\n*  R9 -> NEXT MEMBER IN SLOT LIST\n\nDETDUPS  EQU   *\n         CLI   DEFD,C'Y'\n         BNE   DETDEXIT\n         L     R8,FIRSTMEM\n         L     R9,12(R8)\n\nDEFD010  EQU   *\n         CLC   SLOTOFFM(8,R8),EIGHTXFF\n         BE    DETDEXIT\n         CLC   SLOTOFFM(8,R8),SLOTOFFM(R9)\n         BNE   DEFD040\n         MVI   SLOTOFFD(R8),C'Y'\n         MVI   SLOTOFFD(R9),C'Y'\n\nDEFD040  EQU   *\n         LR    R8,R9\n         L     R9,SLOTOFFN(R8)\n         B     DEFD010\n\nDETDEXIT EQU   *\n         BR    R12\n\n***********************************************************************\n*    PRINT MEMBER DATA\n***********************************************************************\n\n*  R2 -> LRECL SIZE\n*  R3 -> INPUT PDS MEMBER BUFFER\n*  R4 -> LINES OUTPUT\n*  R5 -> PAGE SIZE\n*  R6 -> FIND MEMBER POINTER, END OF DATA\n*  R7 -> IHADCB\n*  R8 -> CURRENT MEMBER IN SLOT LIST\n*  R9 -> DATA POINTER\n*  R14-> SHORT TERM RETURN POINTER (SAVED IN PRINTRET)\n\nPRINTMEM EQU   *\n         CLI   DEFIO,C'Y'         INDEX ONLY?\n         BE    PRINT990\n         MVC   PRTLINE,BLANKS\n         LA    R7,PDS\n         LH    R0,DCBBLKSI\n         STORAGE  OBTAIN,LENGTH=(0),LOC=ANY\n         LR    R3,R1\n         MVI   HDR,C'-'\n         CLI   DEFE,C'Y'\n         BNE   PRINT010\n         MVI   HDR,C'1'\n\nPRINT010 EQU   *\n         L     R8,FIRSTMEM\n         MVC   LASTMEMP,EIGHTX00\n\nPRINT020 EQU   *\n         CLC   SLOTOFFM(8,R8),EIGHTXFF  LAST MEMBER PROCESSED?\n         BE    PRINT990\n         CLI   DEFDO,C'Y'         CHECK FOR DUP ONLY STATUS\n         BNE   PRINT030\n         CLI   SLOTOFFD(R8),C'Y'\n         BNE   PRINT025\n         B     PRINT040\n\nPRINT025 EQU   *\n         MVC   SLOTOFFP(3,R8),EIGHTXFF\n         B     PRINTE70\n\nPRINT030 EQU   *\n         CLI   DEFD,C'Y'          CHECK FOR DUP STATUS\n         BE    PRINT040\n         CLC   SLOTOFFM(8,R8),LASTMEMP  FOR NODUPS, ELIM DUP MEMBERS\n         BE    PRINT025\n\nPRINT040 EQU   *\n         LA    R6,SLOTOFFT(R8)\n         FIND  PDS,(R6),C\n         LA    R5,1               DO INITIAL SET OF LINES LEFT\n         SR    R4,R4              SET LINES PRINTED SO FAR TO 0\n         MVC   SLOTOFFP(3,R8),PAGECNT+1\n\nPRINT060 EQU   *\n         READ  PDSDECB,SF,(R7),(R3),'S',MF=E\n         CHECK PDSDECB\n         LR    R9,R3\n         L     R14,PDSDECB+16     FIGURE DATA LENGTH ACTUALLY READ\n         LH    R6,DCBBLKSI\n         SH    R6,14(R14)\n         TM    DCBRECFM,DCBRECU\n         BO    PRINTU\n         TM    DCBRECFM,DCBRECV\n         BO    PRINTV\n\nPRINTF   EQU   *                  FIXED RECFM\n         LA    R6,0(R6,R9)\n         MVI   PRTEDLEN,C'N'\n\nPRINTF10 EQU   *\n         LH    R2,DCBLRECL\n         C     R2,FW100\n         BH    PRINTF40\n         BCTR  R2,0\n         ST    R2,PRTLEN\n         EX    R2,MVCDATA\n         BAS   R14,PRINTRTN\n         LA    R9,1(R2,R9)\n         CR    R9,R6\n         BL    PRINTF10\n         B     PRINT060\n\nPRINTF40 EQU   *\n         MVC   PRTLINE+10(100),0(R9)\n\n         CLI   PRTEDLEN,C'Y'\n         BE    PRINTF70\n         MVI   PRTEDLEN,C'Y'\n         CVD   R2,DW\n         UNPK  PRTLINE+1(5),DW+5(3)\n         OI    PRTLINE+5,X'F0'\n\nPRINTF70 EQU   *\n         MVC   PRTLEN,FW99\n         BAS   R14,PRINTRTN\n         S     R2,FW100\n         LA    R9,100(R9)\n         B     PRINTF10\n\nPRINTU   EQU   *                  UNFORMATTED RECFM\n         LR    R2,R6\n         LA    R6,0(R6,R9)\n         CVD   R2,DW\n         UNPK  PRTLINE+1(5),DW+5(3)\n         OI    PRTLINE+5,X'F0'\n\nPRINTU10 EQU   *\n         C     R2,FW100\n         BH    PRINTU40\n         BCTR  R2,0\n         ST    R2,PRTLEN\n         EX    R2,MVCDATA\n         BAS   R14,PRINTRTN\n         B     PRINT060\n\nPRINTU40 EQU   *\n         MVC   PRTLINE+10(100),0(R9)\n\n         MVC   PRTLEN,FW99\n         BAS   R14,PRINTRTN\n         S     R2,FW100\n         LA    R9,100(R9)\n         B     PRINTU10\n\nPRINTV   EQU   *                  VARIABLE RECFM\n         LH    R6,0(R9)\n         LA    R6,0(R6,R9)\n         LA    R9,4(R9)\n\nPRINTV05 EQU   *\n         LH    R2,0(R9)\n         C     R2,FW12\n         BL    PRINTV10\n         CLI   DEFV,C'Y'\n         BNE   PRINTV10\n         LR    R14,R2\n         TRT   4(8,R9),NUMTABLE\n         BNZ   PRINTV07\n         MVC   PRTLINE+113(8),4(R9)\n         LR    R2,R14\n         LA    R9,8(R9)\n         S     R2,FW8\n         B     PRINTV10\n\nPRINTV07 EQU   *\n         LR    R2,R14\n\nPRINTV10 EQU   *\n         LA    R9,4(R9)\n         S     R2,FW4\n         CVD   R2,DW\n         UNPK  PRTLINE+1(5),DW+5(3)\n         OI    PRTLINE+5,X'F0'\n\nPRINTV20 EQU   *\n         C     R2,FW100\n         BH    PRINTV60\n         BCTR  R2,0\n         ST    R2,PRTLEN\n         EX    R2,MVCDATA\n         BAS   R14,PRINTRTN\n         LA    R9,1(R2,R9)\n         CR    R9,R6\n         BL    PRINTV05\n         B     PRINT060\n\nPRINTV60 EQU   *\n         MVC   PRTLINE+10(100),0(R9)\n\n         MVC   PRTLEN,FW99\n         BAS   R14,PRINTRTN\n         S     R2,FW100\n         LA    R9,100(R9)\n         B     PRINTV20\n\nPRINTEOF EQU   *                  END OF INDIVIDUAL MEMBER DATA\n         LTR   R4,R4\n         BNZ   PRINTE50\n         MVC   HDRMEM,SLOTOFFM(R8)\n         SR    R14,R14\n         IC    R14,SLOTOFFC(R8)\n         MH    R14,HW50\n         L     R15,DSNAREA\n         LA    R14,0(R14,R15)\n         MVC   HDRDSN,0(R14)\n         MVC   HDRVOL,44(R14)\n         L     R14,PAGECNT\n         MVC   HDRPAGE#,PAGEFMT\n         CVD   R14,DW\n         ED    HDRPAGE#,DW+3\n         LA    R14,1(R14)\n         ST    R14,PAGECNT\n         MVC   HDRALIAS,BLANKS\n         CLI   SLOTOFFA(R8),C'Y'\n         BNE   PRINTE30\n         MVC   HDRALIAS,OPTALIAS\n\nPRINTE30 EQU   *\n         PUT   SYSPRINT,HDR\n         PUT   SYSPRINT,UNDER\n\nPRINTE50 EQU   *\n         CLI   DEFF,C'Y'\n         BNE   PRINTE70\n         PUT   SYSPRINT,FOOTLINE\n\nPRINTE70 EQU   *\n         MVC   LASTMEMP,SLOTOFFM(R8)\n         L     R8,SLOTOFFN(R8)\n         B     PRINT020\n\nPRINT990 EQU   *                  EXIT FROM PRINT MEMBER ROUTINE\n         BR    R12\n\n***********************************************************************\n*   GENERAL PRINT ROUTINE FOR MEMBER DATA - REGISTERS ARE THE\n*   SAME AS FOR PRINTMEM PLUS R14 IS USED TO RETURN TO PRINTMEM\n***********************************************************************\n\nPRINTRTN EQU   *\n         ST    R14,PRINTRET\n         BCT   R5,PRINTR60\n\n         L     R5,DEFP            HEADING GENERATION\n         CLI   DEFF,C'Y'\n         BNE   PRINTR20\n         LTR   R4,R4              PUT FOOTING IF PREVIOUS LINES\n         BZ    PRINTR20\n         PUT   SYSPRINT,FOOTLINE\n\nPRINTR20 EQU   *\n         MVC   HDRMEM,SLOTOFFM(R8)\n         SR    R14,R14\n         IC    R14,SLOTOFFC(R8)\n         MH    R14,HW50\n         L     R15,DSNAREA\n         LA    R14,0(R14,R15)\n         MVC   HDRDSN,0(R14)\n         MVC   HDRVOL,44(R14)\n         L     R14,PAGECNT\n         MVC   HDRPAGE#,PAGEFMT\n         CVD   R14,DW\n         ED    HDRPAGE#,DW+3\n         LA    R14,1(R14)\n         ST    R14,PAGECNT\n         MVC   HDRALIAS,BLANKS\n         CLI   SLOTOFFA(R8),C'Y'\n         BNE   PRINTR40\n         MVC   HDRALIAS,OPTALIAS\n\nPRINTR40 EQU   *\n         PUT   SYSPRINT,HDR\n         PUT   SYSPRINT,UNDER\n\nPRINTR60 EQU   *\n         MVC   SAVEPRT,PRTLINE+10\n         CLI   DEFT,C'Y'\n         BNE   PRINTR61\n         L     R14,PRTLEN\n         EX    R14,TRDATA\n\nPRINTR61 EQU   *\n         PUT   SYSPRINT,PRTLINE\n         MVC   PRTLINE+10(100),SAVEPRT\n         LA    R4,1(R4)\n         C     R4,DEF1          CHECK IF REACHED LINES TO BE PUT OUT\n         BNL   PRINTEOF\n         CLI   DEFH,C'Y'\n         BNE   PRINTR99\n         MVC   PRTLINE+1(9),BLANKS\n         MVC   PRTLINE+110(10),BLANKS\n         BCT   R5,PRINTR75\n         L     R5,DEFP\n         CLI   DEFF,C'Y'\n         BNE   PRINTR65\n         LTR   R4,R4\n         BZ    PRINTR65\n         PUT   SYSPRINT,FOOTLINE\n\nPRINTR65 EQU   *\n         MVC   HDRMEM,SLOTOFFM(R8)\n         SR    R14,R14\n         IC    R14,SLOTOFFC(R8)\n         MH    R14,HW50\n         L     R15,DSNAREA\n         LA    R14,0(R14,R15)\n         MVC   HDRDSN,0(R14)\n         MVC   HDRVOL,44(R14)\n         L     R14,PAGECNT\n         MVC   HDRPAGE#,PAGEFMT\n         CVD   R14,DW\n         ED    HDRPAGE#,DW+3\n         LA    R14,1(R14)\n         ST    R14,PAGECNT\n         MVC   HDRALIAS,BLANKS\n         CLI   SLOTOFFA(R8),C'Y'\n         BNE   PRINTR70\n         MVC   HDRALIAS,OPTALIAS\n\nPRINTR70 EQU   *\n         PUT   SYSPRINT,HDR\n         PUT   SYSPRINT,UNDER\n\nPRINTR75 EQU   *\n         MVC   SAVEPRT,PRTLINE+10\n         L     R14,PRTLEN\n         EX    R14,TRHEX1                PRINT 1ST HEX LINE\n         PUT   SYSPRINT,PRTLINE\n         LA    R4,1(R4)\n         C     R4,DEF1\n         BNL   PRINTEOF\n         MVC   PRTLINE+10(100),SAVEPRT\n         BCT   R5,PRINTR90\n         L     R5,DEFP\n         CLI   DEFF,C'Y'\n         BNE   PRINTR80\n         LTR   R4,R4\n         BZ    PRINTR80\n         PUT   SYSPRINT,FOOTLINE\n\nPRINTR80 EQU   *\n         MVC   HDRMEM,SLOTOFFM(R8)\n         SR    R14,R14\n         IC    R14,SLOTOFFC(R8)\n         MH    R14,HW50\n         L     R15,DSNAREA\n         LA    R14,0(R14,R15)\n         MVC   HDRDSN,0(R14)\n         MVC   HDRVOL,44(R14)\n         L     R14,PAGECNT\n         MVC   HDRPAGE#,PAGEFMT\n         CVD   R14,DW\n         ED    HDRPAGE#,DW+3\n         LA    R14,1(R14)\n         ST    R14,PAGECNT\n         MVC   HDRALIAS,BLANKS\n         CLI   SLOTOFFA(R8),C'Y'\n         BNE   PRINTR85\n         MVC   HDRALIAS,OPTALIAS\n\nPRINTR85 EQU   *\n         PUT   SYSPRINT,HDR\n         PUT   SYSPRINT,UNDER\n\nPRINTR90 EQU   *\n         L     R14,PRTLEN\n         EX    R14,TRHEX2                PRINT 2ND HEX LINE\n         PUT   SYSPRINT,PRTLINE\n         LA    R4,1(R4)\n         C     R4,DEF1\n         BNL   PRINTEOF\n\nPRINTR99 EQU   *\n         MVC   PRTLINE,BLANKS\n         L     R14,PRINTRET\n         BR    R14\n\n***********************************************************************\n*    PRINT LIST OF CONCATENATED DATA SET INPUT NAMES\n***********************************************************************\n\n*  R5 -> PAGE SIZE\n*  R8 -> DSN TO BE PROCESSED\n*  R9 -> CONCAT COUNT\n\nPRTDSNS  EQU   *\n         CLI   DEFI,C'Y'\n         BNE   PRTDSNSX\n\n         MVC   PRTLINE,BLANKS     PRINT DATASET NAME CONCATENATION LIST\n         L     R5,DEFP\n         L     R8,DSNAREA\n         L     R9,CATCNT\n         ZAP   DW,P1\n         B     PRTCAT30\n\nPRTCAT20 EQU   *\n         BCT   R5,PRTCAT40\n         L     R5,DEFP\n         CLI   DEFF,C'Y'\n         BNE   PRTCAT30\n         PUT   SYSPRINT,FOOTLINE\n\nPRTCAT30 EQU   *\n         PUT   SYSPRINT,DSCATHDR\n         PUT   SYSPRINT,UNDER\n\nPRTCAT40 EQU   *\n         MVC   PRTLINE+10(44),0(R8)\n         MVC   PRTLINE+61(6),44(R8)\n         MVC   PRTLINE+1(4),CATFMT\n         ED    PRTLINE+1(4),DW+6\n         PUT   SYSPRINT,PRTLINE\n         LA    R8,50(R8)\n         AP    DW+6(2),P1\n         BCT   R9,PRTCAT20\n\n         CLI   DEFF,C'Y'\n         BNE   PRTCAT90\n         PUT   SYSPRINT,FOOTLINE\nPRTCAT90 EQU   *\n\nPRTDSNSX EQU   *\n         BR    R12\n\n***********************************************************************\n*    PRINT INDEX LIST\n***********************************************************************\n\n*  R2 -> TOP 1ST COLUMN\n*  R3 -> TOP 2ND COLUMN\n*  R4 -> TOP 3RD COLUMN\n*  R5 -> TOP 4TH COLUMN\n*  R8 -> NEXT MEMBER IN LIST\n*  R9 -> COLUMN SIZE\n\nPRTINDEX EQU   *\n         CLI   DEFI,C'Y'\n         BNE   PRTEXIT\n\n         L     R8,FIRSTMEM        GET MEMBERS FOR EACH OF 4 COLUMNS\nPRTCOL00 EQU   *\n         LA    R2,EIGHTXFF\n         LA    R3,EIGHTXFF\n         LA    R4,EIGHTXFF\n         LA    R5,EIGHTXFF\n         CLC   EIGHTXFF,0(R8)\n         BE    PRTEXIT\n         L     R9,DEFP            FIGURE COLUMN SIZE (LENGTH)\n         CLI   DEFDO,C'Y'\n         BNE   PRTCOL10\nPRTCOL05 EQU   *\n         CLC   EIGHTXFF,0(R8)\n         BE    PRTEXIT\n         CLI   SLOTOFFD(R8),C'Y'\n         BE    PRTCOL10\n         L     R8,SLOTOFFN(R8)\n         B     PRTCOL05\nPRTCOL10 EQU   *\n         LR    R2,R8              SET HEAD OF COLUMN 1\n         L     R8,SLOTOFFN(R8)\n         BCTR  R9,0\nPRTCOL15 EQU   *\n         CLC   EIGHTXFF,0(R8)     CHECK FOR REST OF COLUMN 1\n         BE    PRTIDX00\n         CLI   DEFDO,C'Y'\n         BNE   PRTCOL20\n         CLI   SLOTOFFD(R8),C'Y'\n         BE    PRTCOL20\n         L     R8,SLOTOFFN(R8)\n         B     PRTCOL15\nPRTCOL20 EQU   *\n         L     R8,SLOTOFFN(R8)\n         BCT   R9,PRTCOL15\n\n         CLC   EIGHTXFF,0(R8)\n         BE    PRTIDX00\n         L     R9,DEFP            FIGURE COLUMN SIZE (LENGTH)\n         CLI   DEFDO,C'Y'\n         BNE   PRTCOL35\nPRTCOL30 EQU   *\n         CLC   EIGHTXFF,0(R8)\n         BE    PRTIDX00\n         CLI   SLOTOFFD(R8),C'Y'\n         BE    PRTCOL35\n         L     R8,SLOTOFFN(R8)\n         B     PRTCOL30\nPRTCOL35 EQU   *\n         LR    R3,R8              SET HEAD OF COLUMN 2\n         L     R8,SLOTOFFN(R8)\n         BCTR  R9,0\nPRTCOL40 EQU   *\n         CLC   EIGHTXFF,0(R8)     CHECK FOR REST OF COLUMN 2\n         BE    PRTIDX00\n         CLI   DEFDO,C'Y'\n         BNE   PRTCOL45\n         CLI   SLOTOFFD(R8),C'Y'\n         BE    PRTCOL45\n         L     R8,SLOTOFFN(R8)\n         B     PRTCOL40\nPRTCOL45 EQU   *\n         L     R8,SLOTOFFN(R8)\n         BCT   R9,PRTCOL40\n\n         CLC   EIGHTXFF,0(R8)\n         BE    PRTIDX00\n         L     R9,DEFP            FIGURE COLUMN SIZE (LENGTH)\n         CLI   DEFDO,C'Y'\n         BNE   PRTCOL60\nPRTCOL55 EQU   *\n         CLC   EIGHTXFF,0(R8)\n         BE    PRTIDX00\n         CLI   SLOTOFFD(R8),C'Y'\n         BE    PRTCOL60\n         L     R8,SLOTOFFN(R8)\n         B     PRTCOL55\nPRTCOL60 EQU   *\n         LR    R4,R8              SET HEAD OF COLUMN 3\n         L     R8,SLOTOFFN(R8)\n         BCTR  R9,0\nPRTCOL65 EQU   *\n         CLC   EIGHTXFF,0(R8)     CHECK FOR REST OF COLUMN 3\n         BE    PRTIDX00\n         CLI   DEFDO,C'Y'\n         BNE   PRTCOL70\n         CLI   SLOTOFFD(R8),C'Y'\n         BE    PRTCOL70\n         L     R8,SLOTOFFN(R8)\n         B     PRTCOL65\nPRTCOL70 EQU   *\n         L     R8,SLOTOFFN(R8)\n         BCT   R9,PRTCOL65\n\n         CLC   EIGHTXFF,0(R8)\n         BE    PRTIDX00\n         L     R9,DEFP            FIGURE COLUMN SIZE (LENGTH)\n         CLI   DEFDO,C'Y'\n         BNE   PRTCOL85\nPRTCOL80 EQU   *\n         CLC   EIGHTXFF,0(R8)\n         BE    PRTIDX00\n         CLI   SLOTOFFD(R8),C'Y'\n         BE    PRTCOL85\n         L     R8,SLOTOFFN(R8)\n         B     PRTCOL80\nPRTCOL85 EQU   *\n         LR    R5,R8              SET HEAD OF COLUMN 4\n         L     R8,SLOTOFFN(R8)\n         BCTR  R9,0\nPRTCOL90 EQU   *\n         CLC   EIGHTXFF,0(R8)     CHECK FOR REST OF COLUMN 4\n         BE    PRTIDX00\n         CLI   DEFDO,C'Y'\n         BNE   PRTCOL95\n         CLI   SLOTOFFD(R8),C'Y'\n         BE    PRTCOL95\n         L     R8,SLOTOFFN(R8)\n         B     PRTCOL90\nPRTCOL95 EQU   *\n         L     R8,SLOTOFFN(R8)\n         BCT   R9,PRTCOL90\n\nPRTIDX00 EQU   *\n         L     R9,DEFP\n         PUT   SYSPRINT,INDEXHDR\n         PUT   SYSPRINT,UNDER\nPRTIDX10 EQU   *\n         MVC   PRTLINE,BLANKS\n         CLC   EIGHTXFF,SLOTOFFM(R2)  FILL FIRST COLUMN\n         BE    PRTEXIT\n         CLI   DEFDO,C'Y'\n         BNE   PRTIDX20\n         CLI   SLOTOFFD(R2),C'Y'\n         BE    PRTIDX20\n         L     R2,SLOTOFFN(R2)\n         B     PRTIDX10\nPRTIDX20 EQU   *\n         SR    R14,R14\n         MVC   PRTLINE+PRTOFFM1(8),SLOTOFFM(R2)\n         CLI   DEFA,C'Y'\n         BNE   PRTIDX22\n         CLI   SLOTOFFA(R2),C'Y'\n         BNE   PRTIDX22\n         MVI   PRTLINE+PRTOFFA1,C'A'\nPRTIDX22 EQU   *\n         IC    R14,SLOTOFFC(R2)\n         LA    R14,1(R14)\n         CVD   R14,DW\n         MVC   PRTLINE+PRTOFFC1(4),CATFMT\n         ED    PRTLINE+PRTOFFC1(4),DW+6\n         CLI   DEFIO,C'Y'\n         BE    PRTIDX23\n         CLC   SLOTOFFP(3,R2),EIGHTXFF\n         BE    PRTIDX23\n         MVC   PAGECNT+1(3),SLOTOFFP(R2)\n         L     R14,PAGECNT\n         MVC   PRTLINE+PRTOFFP1(12),PAGEFMT\n         CVD   R14,DW\n         ED    PRTLINE+PRTOFFP1(12),DW+3\nPRTIDX23 EQU   *\n         L     R2,SLOTOFFN(R2)\n\nPRTIDX25 EQU   *\n         CLC   EIGHTXFF,SLOTOFFM(R3)  FILL SECOND COLUMN\n         BE    PRTIDX60\n         CLI   DEFDO,C'Y'\n         BNE   PRTIDX30\n         CLI   SLOTOFFD(R3),C'Y'\n         BE    PRTIDX30\n         L     R3,SLOTOFFN(R3)\n         B     PRTIDX25\nPRTIDX30 EQU   *\n         SR    R14,R14\n         MVC   PRTLINE+PRTOFFM2(8),SLOTOFFM(R3)\n         CLI   DEFA,C'Y'\n         BNE   PRTIDX32\n         CLI   SLOTOFFA(R3),C'Y'\n         BNE   PRTIDX32\n         MVI   PRTLINE+PRTOFFA2,C'A'\nPRTIDX32 EQU   *\n         IC    R14,SLOTOFFC(R3)\n         LA    R14,1(R14)\n         CVD   R14,DW\n         MVC   PRTLINE+PRTOFFC2(4),CATFMT\n         ED    PRTLINE+PRTOFFC2(4),DW+6\n         CLI   DEFIO,C'Y'\n         BE    PRTIDX33\n         CLC   SLOTOFFP(3,R3),EIGHTXFF\n         BE    PRTIDX33\n         MVC   PAGECNT+1(3),SLOTOFFP(R3)\n         L     R14,PAGECNT\n         MVC   PRTLINE+PRTOFFP2(12),PAGEFMT\n         CVD   R14,DW\n         ED    PRTLINE+PRTOFFP2(12),DW+3\nPRTIDX33 EQU   *\n         L     R3,SLOTOFFN(R3)\n\nPRTIDX35 EQU   *\n         CLC   EIGHTXFF,SLOTOFFM(R4)  FILL THIRD COLUMN\n         BE    PRTIDX60\n         CLI   DEFDO,C'Y'\n         BNE   PRTIDX40\n         CLI   SLOTOFFD(R4),C'Y'\n         BE    PRTIDX40\n         L     R4,SLOTOFFN(R4)\n         B     PRTIDX35\nPRTIDX40 EQU   *\n         SR    R14,R14\n         MVC   PRTLINE+PRTOFFM3(8),SLOTOFFM(R4)\n         CLI   DEFA,C'Y'\n         BNE   PRTIDX42\n         CLI   SLOTOFFA(R4),C'Y'\n         BNE   PRTIDX42\n         MVI   PRTLINE+PRTOFFA3,C'A'\nPRTIDX42 EQU   *\n         IC    R14,SLOTOFFC(R4)\n         LA    R14,1(R14)\n         CVD   R14,DW\n         MVC   PRTLINE+PRTOFFC3(4),CATFMT\n         ED    PRTLINE+PRTOFFC3(4),DW+6\n         CLI   DEFIO,C'Y'\n         BE    PRTIDX43\n         CLC   SLOTOFFP(3,R4),EIGHTXFF\n         BE    PRTIDX43\n         MVC   PAGECNT+1(3),SLOTOFFP(R4)\n         L     R14,PAGECNT\n         MVC   PRTLINE+PRTOFFP3(12),PAGEFMT\n         CVD   R14,DW\n         ED    PRTLINE+PRTOFFP3(12),DW+3\nPRTIDX43 EQU   *\n         L     R4,SLOTOFFN(R4)\n\nPRTIDX45 EQU   *\n         CLC   EIGHTXFF,SLOTOFFM(R5)  FILL FOURTH COLUMN\n         BE    PRTIDX60\n         CLI   DEFDO,C'Y'\n         BNE   PRTIDX50\n         CLI   SLOTOFFD(R5),C'Y'\n         BE    PRTIDX50\n         L     R5,SLOTOFFN(R5)\n         B     PRTIDX45\nPRTIDX50 EQU   *\n         SR    R14,R14\n         MVC   PRTLINE+PRTOFFM4(8),SLOTOFFM(R5)\n         CLI   DEFA,C'Y'\n         BNE   PRTIDX52\n         CLI   SLOTOFFA(R5),C'Y'\n         BNE   PRTIDX52\n         MVI   PRTLINE+PRTOFFA4,C'A'\nPRTIDX52 EQU   *\n         IC    R14,SLOTOFFC(R5)\n         LA    R14,1(R14)\n         CVD   R14,DW\n         MVC   PRTLINE+PRTOFFC4(4),CATFMT\n         ED    PRTLINE+PRTOFFC4(4),DW+6\n         CLI   DEFIO,C'Y'\n         BE    PRTIDX53\n         CLC   SLOTOFFP(3,R5),EIGHTXFF\n         BE    PRTIDX53\n         MVC   PAGECNT+1(3),SLOTOFFP(R5)\n         L     R14,PAGECNT\n         MVC   PRTLINE+PRTOFFP4(12),PAGEFMT\n         CVD   R14,DW\n         ED    PRTLINE+PRTOFFP4(12),DW+3\nPRTIDX53 EQU   *\n         L     R5,SLOTOFFN(R5)\n\nPRTIDX60 EQU   *\n         PUT   SYSPRINT,PRTLINE\n         BCT   R9,PRTIDX10\n         CLI   DEFF,C'Y'\n         BNE   PRTIDX70\n         PUT   SYSPRINT,FOOTLINE\nPRTIDX70 EQU   *\n         B     PRTCOL00\n\nPRTEXIT  EQU   *\n         BR    R12\n\n***********************************************************************\n*    CLOSE ALL DCBS AND FREE ANY OBTAINED STORAGE\n***********************************************************************\n\n*  R1 -> CLOSE MACRO\n*  R5 -> DCB\n*  R6 -> DCB\n*  R7 -> DCB\n\nCLOSERTN EQU   *\n         LA    R1,CLOSE           CLOSE FILES\n         LA    R5,DIR\n         LA    R6,PDS\n         LA    R7,SYSPRINT\n         CLOSE ((R5),,(R6),,(R7)),MF=(E,(R1)),MODE=31\n         CLI   SYSINOK,C'Y'\n         BNE   CLOSEOUT\n         LA    R1,CLOSSYSI\n         LA    R5,SYSIN\n         CLOSE ((R5)),MF=(E,(R1)),MODE=31\n\nCLOSEOUT EQU   *\n         BR    R12\n\n***********************************************************************\n*    OFFSETS FOR SLOT LIST\n***********************************************************************\n\nSLOTSIZE EQU   20                 SLOT SIZE\n\nSLOTOFFM EQU    0                 MEMBER NAME\nSLOTOFFT EQU    8                 PDS TTR (INITIALLY)\nSLOTOFFP EQU    8                 STARTING PAGE IN LISTING (FOR PRINT)\nSLOTOFFC EQU   11                 PDS CONCATENATION COUNT\nSLOTOFFN EQU   12                 NEXT SLOT LIST MEMBER\nSLOTOFFX EQU   16                 ATTRIBUTES OF MEMBER\nSLOTOFFA EQU   16                 ALIAS\nSLOTOFFD EQU   17                 DUPLICATE\n\n***********************************************************************\n*    OFFSETS FOR INDEX PRINT LINE\n***********************************************************************\n\nPRTOFFM1 EQU    1                 COLUMN 1 MEMBER NAME\nPRTOFFP1 EQU    9                 COLUMN 1 MEMBER PAGE NUMBER\nPRTOFFC1 EQU   21                 COLUMN 1 DATA SET CONCATENATION #\nPRTOFFA1 EQU   27                 COLUMN 1 ALIAS INDICATOR\n\nPRTOFFM2 EQU   32                 COLUMN 2 MEMBER NAME\nPRTOFFP2 EQU   40                 COLUMN 2 MEMBER PAGE NUMBER\nPRTOFFC2 EQU   52                 COLUMN 2 DATA SET CONCATENATION #\nPRTOFFA2 EQU   58                 COLUMN 2 ALIAS INDICATOR\n\nPRTOFFM3 EQU   63                 COLUMN 3 MEMBER NAME\nPRTOFFP3 EQU   71                 COLUMN 3 MEMBER PAGE NUMBER\nPRTOFFC3 EQU   83                 COLUMN 3 DATA SET CONCATENATION #\nPRTOFFA3 EQU   89                 COLUMN 3 ALIAS INDICATOR\n\nPRTOFFM4 EQU   94                 COLUMN 4 MEMBER NAME\nPRTOFFP4 EQU  102                 COLUMN 4 MEMBER PAGE NUMBER\nPRTOFFC4 EQU  114                 COLUMN 4 DATA SET CONCATENATION #\nPRTOFFA4 EQU  120                 COLUMN 4 ALIAS INDICATOR\n\n***********************************************************************\n*    STATIC DATA\n***********************************************************************\n\nOPTALIAS DC    CL5'ALIAS'\nOPTBLKSI DC    CL8'BLKSIZE('\nOPTDUPO  DS   0CL10\nOPTDUPS  DC    CL4'DUPS'\n         DC    CL1'('\nONLY     DC    CL4'ONLY'\n         DC    CL1')'\nOPTEJECT DC    CL5'EJECT'\nOPTFIRST DC    CL6'FIRST('\nOPTFOOT  DC    CL8'FOOTING('\nOPTHEX   DC    CL3'HEX'\nOPTINDXO DS   0CL11\nOPTINDEX DC    CL5'INDEX'\n         DC    CL6'(ONLY)'\nOPTLC    DC    CL8'LINECNT('\nOPTOPTNS DC    CL7'OPTIONS'\nOPTTRANS DC    CL9'TRANSLATE'\nOPTVARS  DC    CL6'VARSEQ'\nOPTLTMEM DC    CL8'<MEMBER('\nOPTGTMEM DC    CL8'>MEMBER('\n\nEIGHTX00 DS    CL08'0000000000000000'\nEIGHTXFF DS   0D   *****  LEAVE BEFORE NUMTABLE  *****\nNUMTABLE DC    240X'FF',010X'00',006X'FF'\nPRTTABLE DC    XL16'40404040404040404040404040404040'  00 - 0F\n         DC    XL16'40404040404040404040404040404040'  10 - 1F\n         DC    XL16'40404040404040404040404040404040'  20 - 2F\n         DC    XL16'40404040404040404040404040404040'  30 - 3F\n         DC    XL16'40404040404040404040404B4C4D4E4F'  40 - 4F\n         DC    XL16'504040404040404040405A5B5C5D5E5F'  50 - 5F\n         DC    XL16'606140404040404040406A6B6C6D6E6F'  60 - 6F\n         DC    XL16'404040404040404040407A7B7C7D7E7F'  70 - 7F\n         DC    XL16'40818283848586878889404040404040'  80 - 8F\n         DC    XL16'40919293949596979899404040404040'  90 - 9F\n         DC    XL16'4040A2A3A4A5A6A7A8A9404040404040'  A0 - AF\n         DC    XL16'B0404040404040404040BABB40404040'  B0 - BF\n         DC    XL16'C0C1C2C3C4C5C6C7C8C9404040404040'  C0 - CF\n         DC    XL16'D0D1D2D3D4D5D6D7D8D9404040404040'  D0 - DF\n         DC    XL16'E040E2E3E4E5E6E7E8E9404040404040'  E0 - EF\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9404040404040'  F0 - FF\nTR1TABLE DC    XL16'F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0'  00 - 0F\n         DC    XL16'F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1'  10 - 1F\n         DC    XL16'F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2'  20 - 2F\n         DC    XL16'F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3'  30 - 3F\n         DC    XL16'F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4'  40 - 4F\n         DC    XL16'F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5'  50 - 5F\n         DC    XL16'F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6'  60 - 6F\n         DC    XL16'F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7'  70 - 7F\n         DC    XL16'F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8'  80 - 8F\n         DC    XL16'F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9'  90 - 9F\n         DC    XL16'C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1'  A0 - AF\n         DC    XL16'C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2'  B0 - BF\n         DC    XL16'C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3'  C0 - CF\n         DC    XL16'C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4'  D0 - DF\n         DC    XL16'C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5'  E0 - EF\n         DC    XL16'C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6'  F0 - FF\nTR2TABLE DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  00 - 0F\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  10 - 1F\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  20 - 2F\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  30 - 3F\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  40 - 4F\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  50 - 5F\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  60 - 6F\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  70 - 7F\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  80 - 8F\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  90 - 9F\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  A0 - AF\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  B0 - BF\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  C0 - CF\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  D0 - DF\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  E0 - EF\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  F0 - FF\n\nDSNASIZE DC    F'11264'\nFW10     DC    F'10'\nFW100    DC    F'100'\nFW12     DC    F'12'\nFW121    DC    F'121'\nFW12288  DC    F'12288'\nFW2      DC    F'2'\nFW3      DC    F'3'\nFW32670  DC    F'32670'\nFW4      DC    F'4'\nFW5      DC    F'5'\nFW6      DC    F'6'\nFW7      DC    F'7'\nFW8      DC    F'8'\nFW9      DC    F'9'\nFW99     DC    F'99'\n\nHW50     DC    H'50'\nMVCDATA  MVC   PRTLINE+10(1),0(R9)\nMVCFOOT  MVC   0(1,R15),0(R8)\nMVCMEMGT MVC   DEFMEMG(1),0(R8)\nMVCMEMLT MVC   DEFMEML(1),0(R8)\nOPTPACK  PACK  DW,0(1,R7)\nOPTNUMCK TRT   0(1,R7),NUMTABLE\nTRDATA   TR    PRTLINE+10(1),PRTTABLE\nTRHEX1   TR    PRTLINE+10(1),TR1TABLE    PREP 1ST HEX LINE\nTRHEX2   TR    PRTLINE+10(1),TR2TABLE    PREP 2ND HEX LINE\n\nCATFMT   DC    XL4'40202021'\nDATEFMT  DC    XL6'212061202020'\nDEFSLOT  DC    CL4'NNNN'\nDSCATHDR DC    CL61'1PDS#     DATA SET NAME'\n         DC    CL60'VOLUME'\nINDEXHDR DC    CL1'1',3CL31' MEMBER      PAGE#   PDS AL    '\n         DC    CL27' MEMBER      PAGE#   PDS AL'\nHIVALUES DC    CL8'HEX F''S '\nLOVALUES DC    CL8'HEX 0''S '\nOPTNTIT  DC    CL15'PDSGEN OPTIONS'\nPAGEFMT  DC    XL12'402020206B2020206B202021'\nBLANKS   DC    CL121' '\nUNDER    DC    CL1'+',120C'_'\n\nOPTNDESC EQU   *\n         DC    CL09'ALIAS    '\n         DC    CL09'DUPS     '\n         DC    CL09'EJECT    '\n         DC    CL09'FIRST    '\n         DC    CL09'FOOTING  '\n         DC    CL09'HEX      '\n         DC    CL09'INDEX    '\n         DC    CL09'LINECNT  '\n         DC    CL09'TRANSLATE'\n         DC    CL09'VARSEQ   '\n         DC    CL09'>MEMBER  '\n         DC    CL09'<MEMBER  '\n\nYES      DC    CL3'YES'\nOPTNO    DS   0CL2\nNO       DC    CL3'NO '\n\nP1       DC    PL1'1'\n\n***********************************************************************\n*    LIST FORM OF I/O MACRO INSTRUCTIONS AND OTHER DYNAMIC DATA\n*    TO BE COPIED TO OBTAINED STORAGE\n***********************************************************************\n\nDYNAMA   DS    0D\n\nXPEN     OPEN  (XIR,(INPUT),XDS,(INPUT),XYSPRINT,(OUTPUT)),MF=L,MODE=31\n\nXPENSYSI OPEN  (XYSIN,(INPUT)),MF=L,MODE=31\n\nXRDJFCB  RDJFCB  (XIR),MF=L\n\nXLOSE    CLOSE (XIR,,XDS,,XYSPRINT),MF=L,MODE=31\n\nXLOSSYSI CLOSE (XYSIN),MF=L,MODE=31\n\nXEADPDS  READ  XDSDECB,SF,XDS,0,'S',MF=L\n\nXIR      DCB   DSORG=PS,MACRF=GL,DDNAME=&DDPDS,                        *\n               RECFM=F,LRECL=256,BLKSIZE=256,BUFNO=89,                 *\n               DCBE=XIRE\nXIRE     DCBE  RMODE31=BUFF,EODAD=RDDIREOF\n\nXYSIN    DCB   DSORG=PS,MACRF=GL,DDNAME=&DDOPTS,                       *\n               RECFM=FB,LRECL=80,DCBE=XYSINE\nXYSINE   DCBE  RMODE31=BUFF,EODAD=OPTNEXIT\n\nXYSGEN   DCB   DSORG=PS,MACRF=GL,DDNAME=&DDGEN,                        *\n               RECFM=FB,LRECL=80,DCBE=XYSGENE\nXYSGENE  DCBE  RMODE31=BUFF,EODAD=GENEOF\n\nXYSOUT   DCB   DSORG=PS,MACRF=PM,DDNAME=&DDOUT,                        *\n               BUFNO=12,RECFM=FB,LRECL=80,BLKSIZE=&DEFBLKSI\n\nXYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=&DDPRINT,                      *\n               RECFM=FBA,LRECL=121,BLKSIZE=&DEFBLKSI\n\n         DS    0D\nXIRSTMEM DC    A(EIGHTXFF)\nXATCNT   DC    F'0'\nXAGECNT  DC    F'1'\n\n*  OPTIONS CHOSEN OR DEFAULTED\n\nXDEFP    DC    F'&DEFPGSZ'        LISTING PAGE SIZE\nXDEF1    DC    F'&DEF1ST'         FIRST # OF LINES\nXDEFA    DC    CL1'&DEFALIAS'     ALIAS\nXDEFD    DC    CL1'&DEFDUPS'      DUPS\nXDEFDO   DC    CL1'&DEFDUPSO'     DUPS ONLY\nXDEFE    DC    CL1'&DEFEJECT'     EJECT\nXDEFF    DC    CL1'&DEFFOOT'      FOOTER USED\nXDEFH    DC    CL1'&DEFHEX'       HEX\nXDEFI    DC    CL1'&DEFINDX'      INDEX\nXDEFIO   DC    CL1'&DEFINDXO'     INDEX ONLY\nXDEFO    DC    CL1'&DEFOPTNS'     LIST OPTIONS\nXDEFT    DC    CL1'&DEFTRANS'     TRANSLATE\nXDEFV    DC    CL1'&DEFVAR'       VARIABLE SEQUENCE\nXDEFMEMG DC    XL8'0000000000000000' FIRST MEMBER SELECTED\nXDEFMEML DC    XL8'FFFFFFFFFFFFFFFF'  LAST MEMBER SELECTED\n\nXDR      DC    CL32'-DATE=YY/DDD   VOL=VVVVVV   DSN=',CL55' '\n         DC    CL34'MEMBER=MMMMMMMM   PAGE ###,###,###'\n\nXYSINOK  DC    CL1'Y'             SYSIN OPENED OK\n\nDYNAML   EQU   *-DYNAMA\n\n***********************************************************************\n*    DSECTS\n***********************************************************************\n\nWORKAREA DSECT\n\nSAVEAREA DS    9D\n\nDW       DS    D\nFINALRC  DS    F                  FINAL RETURN CODE\nDSNAREA  DS    F                  DSN AREA POINTER\nEXLST    DS    F                  EXIT LIST FOR READ JFCB\nEXLSTPTR DS    F                  NEED TO MOVE 3 BYTE ADDR TO DCBEXLSA\nFOOTOFFS DS    F                  OFFSET INTO PRTLINE FOR FOOTING\nPRINTRET DS    A                  RETURN ADDRESS FOR PRINT SUBROUTINE\nPRTLEN   DS    F                  ACTUAL DATA LENGTH FOR HEX TRANSLATE\n*                                    AND CHARACTER TRANSLATE\nJFCBAREA DS    CL176\nLASTMEMP DS    CL008              LAST MEMBER NAME PRINTED\nOPTNVALS DS    CL096              OPTION VALUES FOR OPTIONS DISPLAY\n\nFOOTLINE DS    CL121\nOPTNHDR  DS    CL121\nPRTEDLEN DS    CL1                CHECK FIELD FOR LENGTH PRINT OUT\nPRTLINE  DS    CL121\nSAVEPRT  DS    CL100\n\nWKINGSTG DS    0D  --- BEGIN DYNAMIC AREA REQUIRING INITIALIZATION ---\n\nOPEN     OPEN  (DIR,(INPUT),PDS,(INPUT),SYSPRINT,(OUTPUT)),MF=L,MODE=31\n\nOPENSYSI OPEN  (SYSIN,(INPUT)),MF=L,MODE=31\n\nRDJFCB   RDJFCB  (DIR),MF=L\n\nCLOSE    CLOSE (DIR,,PDS,,SYSPRINT),MF=L,MODE=31\n\nCLOSSYSI CLOSE (SYSIN),MF=L,MODE=31\n\nREADPDS  READ  PDSDECB,SF,0,0,'S',MF=L\n\nDIR      DCB   DSORG=PS,MACRF=GL,DDNAME=&DDPDS,                        *\n               RECFM=F,LRECL=256,BLKSIZE=256,BUFNO=89,                 *\n               DCBE=DIRE\nDIRE     DCBE  RMODE31=BUFF,EODAD=RDDIREOF\n\nSYSIN    DCB   DSORG=PS,MACRF=GL,DDNAME=&DDOPTS,                       *\n               RECFM=FB,LRECL=80,DCBE=SYSINE\nSYSINE   DCBE  RMODE31=BUFF,EODAD=OPTNEXIT\n\nSYSGEN   DCB   DSORG=PS,MACRF=GL,DDNAME=&DDGEN,                        *\n               RECFM=FB,LRECL=80,DCBE=SYSGENE\nSYSGENE  DCBE  RMODE31=BUFF,EODAD=GENEOF\n\nSYSOUT   DCB   DSORG=PS,MACRF=PM,DDNAME=&DDOUT,                        *\n               BUFNO=12,RECFM=FB,LRECL=80,BLKSIZE=&DEFBLKSI\n\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=&DDPRINT,                      *\n               BUFNO=12,RECFM=FBA,LRECL=121,BLKSIZE=&DEFBLKSI\n\n         DS    0D\nFIRSTMEM DS    A\nCATCNT   DS    A\nPAGECNT  DS    F\n\n*  OPTIONS CHOSEN OR DEFAULTED\n\nDEFP     DS    F                  PAGE SIZE (LESS 2 IF DEFF = 'Y' &\n*                                    ALWAYS LESS 1 FOR THE HEADER)\nDEF1     DS    F                  FIRST # OF LINES\nDEFA     DS    CL1                ALIAS\nDEFD     DS    CL1                DUPS\nDEFDO    DS    CL1                DUPS ONLY\nDEFE     DS    CL1                EJECT\nDEFF     DS    CL1                FOOTER USED\nDEFH     DS    CL1                HEX\nDEFI     DS    CL1                INDEX\nDEFIO    DS    CL1                INDEX ONLY\nDEFO     DS    CL1                LIST OPTIONS\nDEFT     DS    CL1                TRANSLATE\nDEFV     DS    CL1                VARIABLE SEQUENCE\nDEFMEMG  DS    CL8                FIRST MEMBER SELECTED\nDEFMEML  DS    CL8                LAST MEMBER SELECTED\n\nHDR      DS    0CL121\n         DS    CL06\nHDRDATE  DS    CL06\n         DS    CL07\nHDRVOL   DS    CL06\n         DS    CL07\nHDRDSN   DS    CL44\n         DS    CL03\nHDRALIAS DS    CL05\n         DS    CL10\nHDRMEM   DS    CL08\n         DS    CL07\nHDRPAGE# DS    CL12\n\nSYSINOK  DS    CL1\n\n*  END OF DYNAMIC AREA ------------------------------------------------\n\nWORKL    EQU   (*-WORKAREA)\n*  END OF WORK AREA    ------------------------------------------------\n\n***********************************************************************\n\n         DCBD  DSORG=(PS,PO),DEVD=DA\n\n         END   PDSGEN\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//***\n//***\n//L          EXEC     PGM=IEWL,\n//             PARM='RENT,AMODE(31),RMODE(ANY),XREF,LIST,LET,DCBS',\n//             REGION=4M,COND=(5,LE)\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOAD-MOD-LIB-,\n//             DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   01022800\n  ENTRY    PDSGEN\n  NAME     PDSGEN(R)\n//***\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSGEN$": {"ttr": 31239, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x14\\x00\\x14\\x00\\x00\\xd7\\xc4\\xe2\\xc7\\xc5\\xd5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "PDSGEN"}, "text": "//-YOUR-USERID-X JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//CLEANUP    EXEC     PGM=IEFBR14\n//DEL01        DD       DSN=-YOUR-USERID-.$$$TEMP.SYSOUT,\n//             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n//***\n//PDSGEN     EXEC     PGM=PDSGEN,REGION=4M\n//SYSIN        DD       *\n     DUPS\n     INDEX\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSPRINT     DD       SYSOUT=*\n//SYSUT1       DD       DISP=SHR,DSN=...\n//SYSGEN       DD       *\n#MEMBER#\n//SYSOUT       DD       DSN=-YOUR-USERID-.$$$TEMP.SYSOUT,DISP=(,CATLG),\n//             UNIT=SYSDA,SPACE=(CYL,(1,1)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDSLIST": {"ttr": 31241, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x07\\x94\\x07\\x94\\x00\\x00\\xd7\\xc4\\xe2\\xd3\\xc9\\xe2\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 1940, "newlines": 1940, "modlines": 0, "user": "PDSLIST"}, "text": "//-YOUR-USERID-P JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  PARTITIONED DATA SET LIST UTILITY ASSEMBLY AND LINK\n//***\n//A          EXEC     PGM=ASMA90,REGION=4M,\n//             PARM='RENT'\n//SYSLIB       DD       DISP=SHR,DSN=SYS1.MACLIB\n\n         TITLE '***  PDSLIST  --  FREEWARE  --  STELI INC. 2000  ***'\n\n*  PDSLIST IS FREEWARE AND MAY BE USED AT NO COST.  NEITHER A LICENCE\n*  NOR REGISTRATION IS REQUIRED.  YOU MAY INDICATE TO STELI THAT YOU'RE\n*  A PDSLIST USER VIA WWW.STELI.COM OR BY MAIL.  SUGGESTIONS, QUESTIONS\n*  OR PROBLEMS ARE WELCOME.\n*      STELI INC.\n*      PDSLIST TEAM\n*      27 HALF HOLLOW TURN\n*      MONROE, NY  10950-4118\n\n***********************************************************************\n*    DEFAULT OPTION VALUES\n***********************************************************************\n\n&DDOPTS  SETC  'SYSIN'            DDNAME FOR OPTIONS FILE\n&DDPDS   SETC  'SYSUT1'           DDNAME FOR PARTITIONED DATA SET\n&DDPRINT SETC  'SYSPRINT'         DDNAME FOR LISTING FILE\n\n&DEFALIAS SETC 'N'                ALIAS DEFAULT\n&DEFBLKSI SETA 121                SYSPRINT BLOCK SIZE DEFAULT\n&DEFDUPS  SETC 'N'                DUPS DEFAULT\n&DEFDUPSO SETC 'N'                DUPS ONLY DEFAULT\n&DEFEJECT SETC 'N'                EJECT DEFAULT\n&DEFFOOT  SETC 'N'                FOOTER USED\n&DEFHEX   SETC 'N'                HEX DEFAULT\n&DEFINDX  SETC 'N'                INDEX DEFAULT\n&DEFINDXO SETC 'N'                INDEX ONLY DEFAULT\n&DEFOPTNS SETC 'N'                LIST OPTIONS DEFAULT\n&DEFPGSZ  SETA 58                 DATA PAGE SIZE DEFAULT\n&DEFTRANS SETC 'N'                TRANSLATE DEFAULT\n&DEFVAR   SETC 'Y'                VARIABLE SEQUENCE DEFAULT\n&DEF1ST   SETA 99999999           FIRST OPTION CHOSEN DEFAULT\n\n***********************************************************************\n*    PROGRAM ENTRY\n***********************************************************************\n\nPDSLIST  AMODE 31\nPDSLIST  RMODE ANY\n\nR0       EQU    0                 VARIED USAGE - ROUTINE DEPENDENT\nR1       EQU    1                   \"      \"        \"        \"\nR2       EQU    2                   \"      \"        \"        \"\nR3       EQU    3                   \"      \"        \"        \"\nR4       EQU    4                   \"      \"        \"        \"\nR5       EQU    5                   \"      \"        \"        \"\nR6       EQU    6                   \"      \"        \"        \"\nR7       EQU    7                   \"      \"        \"        \"\nR8       EQU    8                   \"      \"        \"        \"\nR9       EQU    9                   \"      \"        \"        \"\nR10      EQU   10                 BASE REGISTER\nR11      EQU   11                 BASE REGISTER\nR12      EQU   12                 RETURN REGISTER FOR SUBROUTINES\nR13      EQU   13                 SAVE AREA & MISCELLANEOUS STORAGE\nR14      EQU   14                 OCCASIONAL RETURN REGISTER (PRINTRET)\nR15      EQU   15                 SHORT TERM WORK REGISTER\n\nPDSLIST  CSECT                    ENTRY POINT\n         STM   R14,R12,12(R13)\n         LR    R10,R15\n         LA    R11,4095\n         LA    R11,1(R10,R11)\n         USING PDSLIST,R10,R11\n         LA    R0,WORKL\n         STORAGE  OBTAIN,LENGTH=(0),LOC=BELOW\n         ST    R1,8(R13)\n         ST    R13,4(R1)\n         LM    R0,R1,20(R13)\n         L     R13,8(R13)\n         USING WORKAREA,R13       R13 -> SAVEAREA + DYNAMIC STORAGE\n         USING IHADCB,R7          PERIODIC USE - REQUIRES LOCAL LOAD\n\n***********************************************************************\n*    MAIN LINE\n***********************************************************************\n\n         BAS   R12,INITSTOR       INITIALIZE OBTAINED MEMORY\n         BAS   R12,OPENDSS        OPEN FILES\n         BAS   R12,GETOPTNS       READ AND SET UP PARMS\n         BAS   R12,LSTOPTNS       DISPLAY THE OPTIONS USED\n         BAS   R12,READDIR        BUILD THE DIRECTORY LIST\n         BAS   R12,DETDUPS        DETERMINE WHICH ARE DUPS\n         BAS   R12,PRINTMEM       PRINT THE MEMBER DATA\n         BAS   R12,PRTDSNS        PRINT THE CONCATENATED DSN'S\n         BAS   R12,PRTINDEX       PRINT THE INDEX\n         BAS   R12,CLOSERTN       CLOSE ALL FILES\nEXITALL  EQU   *\n         L     R15,FINALRC        SET LAST RETURN CODE\n         L     R13,4(R13)         TERMINATE PROGRAM LEAVING REG 15\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n\n***********************************************************************\n*    INITIALIZE THE OBTAINED STORAGE WITH STARTING VALUES OR WITH\n*    I/O MACRO EXPANSIONS\n***********************************************************************\n\nINITSTOR EQU   *\n\n         XC    FINALRC,FINALRC    INITIALIZE FINAL RETURN CODE TO 0\n\n         LA    R0,WKINGSTG        INITIALIZE DYNAMIC STORAGE AREA\n         LA    R1,DYNAML\n         LA    R14,DYNAMA\n         LR    R15,R1\n         MVCL  R0,R14\n\n         LA    R14,JFCBAREA       SET UP READ JFCB CONNECTIONS\n         ST    R14,EXLST\n         MVI   EXLST,X'87'\n         LA    R14,EXLST\n         LA    R7,DIR\n         ST    R14,EXLSTPTR\n         MVC   DCBEXLSA(3),EXLSTPTR+1\n         LA    R14,DIRE           SET UP DCBE'S IN WORKING STORAGE\n         ST    R14,DCBDCBE\n         LA    R7,PDS\n         LA    R14,PDSE\n         ST    R14,DCBDCBE\n         LA    R7,SYSIN\n         LA    R14,SYSINE\n         ST    R14,DCBDCBE\n\n         TIME  DEC                GET DATE FOR HEADER(S)\n         ST    1,DW\n         MVC   HDRDATE,DATEFMT\n         ED    HDRDATE,DW+1\n         MVC   PRTLINE,BLANKS\n\n         L     R0,DSNASIZE        GET STORAGE FOR DATA SET NAMES\n         STORAGE  OBTAIN,LENGTH=(0),LOC=ANY\n         ST    R1,DSNAREA\n\n         BR    R12\n\n***********************************************************************\n*    OPEN THE DCBS FROM THE GETMAINED AREAS\n***********************************************************************\n\n*  R1 -> OPEN MACRO\n*  R5 -> DCB\n*  R6 -> DCB\n*  R7 -> DCB\n\nOPENDSS  EQU   *\n         LA    R1,OPEN\n         LA    R5,DIR\n         LA    R6,PDS\n         LA    R7,SYSPRINT\n         OPEN  ((R5),,(R6),,(R7),OUTPUT),MF=(E,(1)),MODE=31\n         LTR   R15,R15\n         BZ    OPENOK01\n         ST    R15,FINALRC\n         B     EXITALL\n\nOPENOK01 EQU   *\n         LA    R1,OPENSYSI\n         LA    R5,SYSIN\n         OPEN  ((R5)),MF=(E,(1)),MODE=31\n         LTR   R15,R15\n         BZ    OPENOK02\n         MVI   SYSINOK,C'N'\n\nOPENOK02 EQU   *\n         BR    R12\n\n***********************************************************************\n*    GET ANY SYSIN PARAMETERS\n***********************************************************************\n\n*  R0 -> REMAINDER AFTER DIVIDE; STORAGE LENGTH\n*  R1 -> QUOTIENT AFTER DIVIDE; RETURNED STORAGE ADDRESS\n*  R2 -> TRT CLOBBERS IT UNDER SOME CIRCUMSTANCES\n*  R5 -> END OF OPTION CARD (COL 72)\n*  R6 -> LENGTH REMAINING\n*  R7 -> IHADCB; TRT REGISTER (OPTNUMCK)\n*  R8 -> MOVING POINTER TO OPTION CARD\n\nGETOPTNS EQU   *\n         CLI   SYSINOK,C'Y'       SYSIN PROVIDED?\n         BNE   OPTNEXIT\n\nGETSYSIN EQU   *\n         GET   SYSIN\n         LA    R5,71(R1)          POINT TO END OF CARD\n         LR    R8,R1\nOPTNSCAN EQU   *\n         LR    R6,R5              CALCULATE LENGTH REMAINING\n         SR    R6,R8\n         LA    R6,1(R6)\n         C     R6,FW2             CHECK IF ANY POSSIBLE DATA\n         BL    GETSYSIN\n         CLC   OPTNO,0(R8)        CHECK FOR 'NO'\n         BE    OPTNNO\n         C     R6,FW3             CHECK FOR APPROPRIATE LENGTHS\n         BL    GETSYSIN\n         BE    OPTL3\n         C     R6,FW4\n         BNH   OPTL4\n         C     R6,FW5\n         BNH   OPTL5\n         C     R6,FW6\n         BNH   OPTL6\n         C     R6,FW7\n         BNH   OPTL7\n         C     R6,FW8\n         BNH   OPTL8\n         C     R6,FW9\n         BNH   OPTL9\n         C     R6,FW10\n         BNH   OPTL10\n         CLC   OPTINDXO,0(R8)     CHECK FOR INDEX(ONLY)\n         BNE   OPTL10\n         MVI   DEFIO,C'Y'\n         MVI   DEFI,C'Y'\n         LA    R8,L'OPTINDXO(R8)\n         B     OPTNSCAN\n\nOPTL10   EQU   *\n         CLC   OPTBLKSI,0(R8)     CHECK FOR BLKSIZE(...)\n         BNE   OPTL1D\n         LA    R8,L'OPTBLKSI(R8)\n         LR    R14,R8\nOPTL1BA  EQU   *\n         CLI   0(R14),C')'\n         BE    OPTL1BB\n         LA    R14,1(R14)\n         CR    R14,R5\n         BH    OPTNEXT\n         B     OPTL1BA\nOPTL1BB  EQU   *\n         CR    R8,R14\n         BE    OPTNEXT\n         SR    R14,R8\n         C     R14,FW5\n         BH    OPTNEXT\n         BCTR  R14,0\n         LR    R7,R8\n         EX    R14,OPTNUMCK\n         BNZ   OPTNEXT\n         EX    R14,OPTPACK\n         CVB   R15,DW\n         C     R15,FW32670\n         BH    OPTNEXT\n         SR    R0,R0\n         LR    R1,R15\n         D     R0,FW121\n         LTR   R0,R0\n         BNZ   OPTNEXT\n         LA    R7,SYSPRINT\n         STH   R15,DCBBLKSI\n         OI    DCBRECFM,X'10'\n         LA    R8,0(R14,R8)\n         B     OPTNSCAN\n\nOPTL1D   EQU   *\n         CLC   OPTDUPO,0(R8)      CHECK FOR DUPS(ONLY)\n         BNE   OPTL1F\n         MVI   DEFDO,C'Y'\n         MVI   DEFD,C'Y'\n         LA    R8,L'OPTDUPO(R8)\n         B     OPTNSCAN\n\nOPTL1F   EQU   *\n         CLC   OPTFOOT,0(R8)      CHECK FOR FOOTING(...)\n         BNE   OPTL1L\n         LA    R8,L'OPTFOOT(R8)\n         LR    R14,R8\nOPTL1FA  EQU   *\n         CLI   0(R14),C')'\n         BE    OPTL1FB\n         LA    R14,1(R14)\n         CR    R14,R5\n         BH    OPTNEXT\n         B     OPTL1FA\nOPTL1FB  EQU   *\n         CR    R8,R14\n         BE    OPTNEXT\n         SR    R14,R8\n         MVI   DEFF,C'Y'\n         MVI   FOOTLINE,C'0'\n         MVC   FOOTLINE+1(120),BLANKS\n         LA    R15,120\n         SR    R15,R14\n         SRL   R15,1\n         ST    R15,FOOTOFFS\n         LA    R15,FOOTLINE+1(R15)\n         BCTR  R14,0\n         EX    R14,MVCFOOT\n         LA    R8,2(R14,R8)\n         B     OPTNSCAN\n\nOPTL1L   EQU   *\n         CLC   OPTLC,0(R8)        CHECK FOR LINECNT(...)\n         BNE   OPTL1X\n         LA    R8,L'OPTLC(R8)\n         LR    R14,R8\nOPTL1LA  EQU   *\n         CLI   0(R14),C')'\n         BE    OPTL1LB\n         LA    R14,1(R14)\n         CR    R14,R5\n         BH    OPTNEXT\n         B     OPTL1LA\nOPTL1LB  EQU   *\n         CR    R8,R14\n         BE    OPTNEXT\n         SR    R14,R8\n         C     R14,FW7\n         BH    OPTNEXT\n         BCTR  R14,0\n         LR    R7,R8\n         EX    R14,OPTNUMCK\n         BNZ   OPTNEXT\n         EX    R14,OPTPACK\n         CVB   R15,DW\n         C     R15,FW4\n         BH    OPTL1LC\n         L     R15,FW4\nOPTL1LC  EQU   *\n         ST    R15,DEFP\n         LA    R8,0(R14,R8)\n         B     OPTNSCAN\n\nOPTL1X   EQU   *\n         CLC   OPTGTMEM,0(R8)     CHECK FOR >MEMBER(...)\n         BNE   OPTL1Z\n         LA    R8,L'OPTGTMEM(R8)\n         LR    R14,R8\nOPTL1XA  EQU   *\n         CLI   0(R14),C')'\n         BE    OPTL1XB\n         LA    R14,1(R14)\n         CR    R14,R5\n         BH    OPTNEXT\n         B     OPTL1XA\nOPTL1XB  EQU   *\n         CR    R8,R14\n         BE    OPTNEXT\n         SR    R14,R8\n         BCTR  R14,0\n         MVC   DEFMEMG,BLANKS\n         EX    R14,MVCMEMGT\n         LA    R8,0(R14,R8)\n         B     OPTNSCAN\n\nOPTL1Z   EQU   *\n         CLC   OPTLTMEM,0(R8)     CHECK FOR <MEMBER(...)\n         BNE   OPTL9\n         LA    R8,L'OPTLTMEM(R8)\n         LR    R14,R8\nOPTL1YA  EQU   *\n         CLI   0(R14),C')'\n         BE    OPTL1YB\n         LA    R14,1(R14)\n         CR    R14,R5\n         BH    OPTNEXT\n         B     OPTL1YA\nOPTL1YB  EQU   *\n         CR    R8,R14\n         BE    OPTNEXT\n         SR    R14,R8\n         BCTR  R14,0\n         MVC   DEFMEML,BLANKS\n         EX    R14,MVCMEMLT\n         LA    R8,0(R14,R8)\n         B     OPTNSCAN\n\nOPTL9    EQU   *\n         CLC   OPTTRANS,0(R8)     CHECK FOR TRANSLATE\n         BNE   OPTL8\n         MVI   DEFT,C'Y'\n         LA    R8,L'OPTTRANS(R8)\n         B     OPTNSCAN\n\nOPTL8    EQU   *\n         CLC   OPTFIRST,0(R8)     CHECK FOR FIRST(...)\n         BNE   OPTL7\n         LA    R8,L'OPTFIRST(R8)\n         LR    R14,R8\nOPTL1FJ  EQU   *\n         CLI   0(R14),C')'\n         BE    OPTL1FK\n         LA    R14,1(R14)\n         CR    R14,R5\n         BH    OPTNEXT\n         B     OPTL1FJ\nOPTL1FK  EQU   *\n         CR    R8,R14\n         BE    OPTNEXT\n         SR    R14,R8\n         BCTR  R14,0\n         LR    R7,R8\n         EX    R14,OPTNUMCK\n         BNZ   OPTNEXT\n         EX    R14,OPTPACK\n         CVB   R15,DW\n         ST    R15,DEF1\n         LA    R8,1(R14,R8)\n         B     OPTNSCAN\n\nOPTL7    EQU   *\n         CLC   OPTOPTNS,0(R8)     CHECK FOR OPTIONS\n         BNE   OPTL6\n         MVI   DEFO,C'Y'\n         LA    R8,L'OPTOPTNS(R8)\n         B     OPTNSCAN\n\nOPTL6    EQU   *\n         CLC   OPTVARS,0(R8)      CHECK FOR VARSEQ\n         BNE   OPTL5\n         MVI   DEFV,C'Y'\n         LA    R8,L'OPTVARS(R8)\n         B     OPTNSCAN\n\nOPTL5    EQU   *\n         CLC   OPTEJECT,0(R8)     CHECK FOR EJECT\n         BNE   OPTL5A\n         MVI   DEFE,C'Y'\n         LA    R8,L'OPTEJECT(R8)\n         B     OPTNSCAN\n\nOPTL5A   EQU   *\n         CLC   OPTINDEX,0(R8)     CHECK FOR INDEX\n         BNE   OPTL5B\n         MVI   DEFI,C'Y'\n         LA    R8,L'OPTINDEX(R8)\n         B     OPTNSCAN\n\nOPTL5B   EQU   *\n         CLC   OPTALIAS,0(R8)     CHECK FOR ALIAS\n         BNE   OPTL4\n         MVI   DEFA,C'Y'\n         LA    R8,L'OPTALIAS(R8)\n         B     OPTNSCAN\n\nOPTL4    EQU   *\n         CLC   OPTDUPS,0(R8)      CHECK FOR DUPS\n         BNE   OPTL3\n         MVI   DEFD,C'Y'\n         LA    R8,L'OPTDUPS(R8)\n         B     OPTNSCAN\n\nOPTL3    EQU   *\n         CLC   OPTHEX,0(R8)       CHECK FOR HEX\n         BNE   OPTNEXT\n         MVI   DEFH,C'Y'\n         LA    R8,L'OPTHEX(R8)\n         B     OPTNSCAN\n\nOPTNEXT  LA    R8,1(R8)\n         B     OPTNSCAN\n\nOPTNNO   EQU   *                  CHECK FOR \"NO\" OPTIONS\n         LA    R8,2(R8)\n         BCTR  R6,0\n         BCTR  R6,0\n         C     R6,FW3             CHECK FOR APPROPRIATE LENGTHS\n         BNH   OPTN3\n         C     R6,FW4\n         BNH   OPTN4\n         C     R6,FW5\n         BNH   OPTN5\n         C     R6,FW6\n         BNH   OPTN6\n         C     R6,FW7\n         BNH   OPTN7\n         C     R6,FW9\n         BNH   OPTN9\n\nOPTN9    EQU   *\n         CLC   OPTTRANS,0(R8)     CHECK FOR NEGATIVE TRANSLATE\n         BNE   OPTN7\n         MVI   DEFT,C'N'\n         LA    R8,L'OPTTRANS(R8)\n         B     OPTNSCAN\n\nOPTN7    EQU   *\n         CLC   OPTOPTNS,0(R8)     CHECK FOR NEGATIVE OPTIONS\n         BNE   OPTN6\n         MVI   DEFO,C'N'\n         LA    R8,L'OPTOPTNS(R8)\n         B     OPTNSCAN\n\nOPTN6    EQU   *\n         CLC   OPTVARS,0(R8)      CHECK FOR NEGATIVE VARSEQ\n         BNE   OPTN5\n         MVI   DEFV,C'N'\n         LA    R8,L'OPTVARS(R8)\n         B     OPTNSCAN\n\nOPTN5    EQU   *\n         CLC   OPTEJECT,0(R8)     CHECK FOR NEGATIVE EJECT\n         BNE   OPTN5A\n         MVI   DEFE,C'N'\n         LA    R8,L'OPTEJECT(R8)\n         B     OPTNSCAN\n\nOPTN5A   EQU   *\n         CLC   OPTINDEX,0(R8)     CHECK FOR NEGATIVE INDEX\n         BNE   OPTN5B\n         MVI   DEFI,C'N'\n         LA    R8,L'OPTINDEX(R8)\n         B     OPTNSCAN\n\nOPTN5B   EQU   *\n         CLC   OPTALIAS,0(R8)     CHECK FOR NEGATIVE ALIAS\n         BNE   OPTN4\n         MVI   DEFA,C'N'\n         LA    R8,L'OPTALIAS(R8)\n         B     OPTNSCAN\n\nOPTN4    EQU   *\n         CLC   OPTDUPS,0(R8)      CHECK FOR NEGATIVE DUPS\n         BNE   OPTN3\n         MVI   DEFD,C'N'\n         LA    R8,L'OPTDUPS(R8)\n         B     OPTNSCAN\n\nOPTN3    EQU   *\n         CLC   OPTHEX,0(R8)       CHECK FOR NEGATIVE HEX\n         BNE   OPTNEXT\n         MVI   DEFH,C'N'\n         LA    R8,L'OPTHEX(R8)\n         B     OPTNSCAN\n\nOPTNEXIT EQU   *\n         L     R14,DEFP\n         BCTR  R14,0\n         ST    R14,DEFP\n         CLI   DEFF,C'Y'\n         BNE   OPTNEX99\n         L     R14,DEFP\n         S     R14,FW2\n         ST    R14,DEFP\nOPTNEX99 EQU   *\n         BR    R12\n\n***********************************************************************\n*    DISPLAY THE OPTIONS CHOSEN AND THOSE DEFAULTED\n***********************************************************************\n\n*  R3 -> PAGE SIZE\n*  R4 -> DESCRIPTION ARRAY POINTER\n*  R5 -> VALUE ARRAY POINTER\n\nLSTOPTNS EQU   *\n         CLI   DEFO,C'Y'\n         BNE   LSTOPTEX\n\n         MVC   OPTNVALS,BLANKS\n         LA    R5,OPTNVALS        ALIAS VALUE\n         MVC   0(3,R5),YES\n         CLI   DEFA,C'Y'\n         BE    LSTOPTAY\n         MVC   0(3,R5),NO\nLSTOPTAY EQU   *\n\n         LA    R5,8(R5)           DUPS OR DUPS(ONLY) VALUE\n         MVC   0(3,R5),YES\n         CLI   DEFD,C'Y'\n         BE    LSTOPTDY\n         MVC   0(3,R5),NO\nLSTOPTDY EQU   *\n         CLI   DEFDO,C'Y'\n         BNE   LSTOPTDX\n         MVC   0(4,R5),ONLY\nLSTOPTDX EQU   *\n\n         LA    R5,8(R5)           EJECT VALUE\n         MVC   0(3,R5),YES\n         CLI   DEFE,C'Y'\n         BE    LSTOPTEY\n         MVC   0(3,R5),NO\nLSTOPTEY EQU   *\n\n         LA    R5,8(R5)           FIRST VALUE\n         L     R14,DEF1\n         CVD   R14,DW\n         UNPK  0(8,R5),DW+3(5)\n         OI    7(R5),X'F0'\n\n         LA    R5,8(R5)           FOOTING VALUE\n         MVC   0(3,R5),NO\n         CLI   DEFF,C'Y'\n         BNE   LSTOPTFN\n         MVC   0(8,R5),OPTFOOT    SET PRELIMINARY VALUE\nLSTOPTFN EQU   *\n\n         LA    R5,8(R5)           HEX VALUE\n         MVC   0(3,R5),YES\n         CLI   DEFH,C'Y'\n         BE    LSTOPTHY\n         MVC   0(3,R5),NO\nLSTOPTHY EQU   *\n\n         LA    R5,8(R5)           INDEX OR INDEX(ONLY) VALUE\n         MVC   0(3,R5),YES\n         CLI   DEFI,C'Y'\n         BE    LSTOPTIY\n         MVC   0(3,R5),NO\nLSTOPTIY EQU   *\n         CLI   DEFIO,C'Y'\n         BNE   LSTOPTIX\n         MVC   0(4,R5),ONLY\nLSTOPTIX EQU   *\n\n         LA    R5,8(R5)           LINECNT VALUE\n         L     R14,DEFP\n         LA    R14,1(R14)\n         CLI   DEFF,C'Y'\n         BNE   LSTOPTLX\n         LA    R14,2(R14)\nLSTOPTLX EQU   *\n         CVD   R14,DW\n         UNPK  0(8,R5),DW+3(5)\n         OI    7(R5),X'F0'\n\n         LA    R5,8(R5)           TRANSLATE VALUE\n         MVC   0(3,R5),YES\n         CLI   DEFT,C'Y'\n         BE    LSTOPTTY\n         MVC   0(3,R5),NO\nLSTOPTTY EQU   *\n\n         LA    R5,8(R5)           VARSEQ VALUE\n         MVC   0(3,R5),YES\n         CLI   DEFV,C'Y'\n         BE    LSTOPTVY\n         MVC   0(3,R5),NO\nLSTOPTVY EQU   *\n\n         LA    R5,8(R5)           >MEMBER VALUE\n         MVC   0(8,R5),LOVALUES\n         CLC   DEFMEMG,EIGHTX00\n         BE    LSTOPTGN\n         MVC   0(8,R5),DEFMEMG\nLSTOPTGN EQU   *\n\n         LA    R5,8(R5)           <MEMBER VALUE\n         MVC   0(8,R5),HIVALUES\n         CLC   DEFMEML,EIGHTXFF\n         BE    LSTOPTLN\n         MVC   0(8,R5),DEFMEML\nLSTOPTLN EQU   *\n\n         LA    R4,OPTNDESC        POINT TO DESCRIPTIONS ARRAY\n         LA    R5,OPTNVALS        POINT TO VALUE ARRAY\n         MVC   OPTNHDR,BLANKS     SET UP HEADER AND DISPLAY VALUES\n         MVC   OPTNHDR+1(11),HDR+1\n         MVC   OPTNHDR+53(15),OPTNTIT\n         MVC   PRTLINE,BLANKS\n\nLSTOPT10 EQU   *\n         L     R3,DEFP            PAGE SIZE\n         PUT   SYSPRINT,OPTNHDR\n         PUT   SYSPRINT,UNDER\nLSTOPT20 EQU   *\n         MVC   PRTLINE+4(9),0(R4)\n         MVC   PRTLINE+14(8),0(R5)\n         CLC   0(8,R5),OPTFOOT\n         BNE   LSTOPT30\n         L     R14,FOOTOFFS\n         LA    R14,FOOTLINE(R14)\n         MVC   PRTLINE+13(63),0(R14)\nLSTOPT30 EQU   *\n         PUT   SYSPRINT,PRTLINE\n         CLC   0(7,R4),OPTLTMEM\n         BE    LSTOPT99\n         LA    R4,9(R4)\n         LA    R5,8(R5)\n         MVC   PRTLINE,BLANKS\n         BCT   R3,LSTOPT20\n         CLI   DEFF,C'Y'\n         BNE   LSTOPT10\n         PUT   SYSPRINT,FOOTLINE\n         B     LSTOPT10\n\nLSTOPT99 EQU   *\n         CLI   DEFF,C'Y'\n         BNE   LSTOPTEX\n         PUT   SYSPRINT,FOOTLINE\n\nLSTOPTEX EQU   *\n         BR    R12\n\n***********************************************************************\n*    READ THE DIRECTORY(S)\n***********************************************************************\n\n*  R2 -> NUMBER OF SLOTS LEFT\n*  R3 -> END OF DIR ENTRY\n*  R4 -> MEMBER IN DIR ENTRY\n*  R5 -> DSN AREA (FROM DSNAREA)\n*  R6 -> NEW SLOT POINTER\n*  R7 -> IHADCB\n*  R8 -> CURRENT MEMBER IN SLOT LIST\n*  R9 -> NEXT MEMBER IN SLOT LIST\n\nREADDIR  EQU   *\n         LA    R2,1\n         L     R5,DSNAREA\n         LA    R7,DIR\n         LA    R8,EIGHTXFF\n         LR    R9,R8\n\nRDDIR010 EQU   *\n         RDJFCB  DIR,MF=(E,RDJFCB)  GET DSN & VOLSER\n         MVC   0(44,R5),JFCBAREA\n         MVC   44(6,R5),JFCBAREA+118\n         LA    R5,50(R5)\n\nRDDIR020 EQU   *\n         GET   (R7)               GET A DIRECTORY BLOCK\n         LH    R3,0(R1)\n         LA    R4,2(R1)\n         LA    R3,0(R1,R3)\n\nRDDIR030 EQU   *\n         CR    R4,R3              END OF BLOCK?\n         BNL   RDDIR020\n         CLC   EIGHTXFF,0(R4)     TERMINATING ENTRY FOR A PDS?\n         BNE   RDDIR040\n         L     R14,CATCNT         GET READY FOR NEXT PDS (IF ANY)\n         LA    R14,1(R14)\n         ST    R14,CATCNT\n         FEOV  DIR\n         B     RDDIR010\n\nRDDIR040 EQU   *\n         CLC   DEFMEMG,0(R4)      SHOULD THIS MEMBER BE SELECTED?\n         BH    RDDIR110\n         CLC   DEFMEML,0(R4)\n         BL    RDDIR110\n         BCT   R2,RDDIR050\n         L     R0,FW12288         LOAD SLOT AREA SIZE FOR GETMAIN\n         STORAGE  OBTAIN,LENGTH=(0),LOC=ANY\n         LR    R6,R1              SAVE POINTER TO MEMBER SLOT AREA\n         LA    R2,614\n\nRDDIR050 EQU   *\n         MVC   SLOTOFFM(11,R6),0(R4)  SAVE DIRECTORY DATA INTO LIST\n         MVC   SLOTOFFC(1,R6),CATCNT+3\n         MVC   SLOTOFFX(L'DEFSLOT,R6),DEFSLOT\n         TM    11(R4),X'80'       CHECK IF ALIAS\n         BNO   RDDIR055\n         MVI   SLOTOFFA(R6),C'Y'\n\nRDDIR055 EQU   *\n         SR    R14,R14\n         IC    R14,11(R4)\n         SLL   R14,27             POINT TO NEXT DIRECTORY ENTRY\n         SRL   R14,26\n         LA    R4,12(R14,R4)\n\nRDDIR070 EQU   *\n         CLC   SLOTOFFM(8,R6),SLOTOFFM(R8)  PUT NEW MEMBER INTO CHAIN\n         BNL   RDDIR090\n         L     R8,FIRSTMEM\n         CLC   SLOTOFFM(8,R6),SLOTOFFM(R8)\n         BL    RDDIR080\n         L     R8,12(R8)\n         L     R9,12(R8)\n         CLC   SLOTOFFM(8,R6),SLOTOFFM(R8)  CHECK IF HIGHER THAN 2ND\n         BNL   RDDIR090\n         LR    R9,R8\n         L     R8,FIRSTMEM\n         B     RDDIR090\n\nRDDIR080 EQU   *\n         ST    R8,SLOTOFFN(R6)    NEW FIRST MEMBER\n         LR    R9,R8\n         ST    R6,FIRSTMEM\n         LR    R8,R6\n         LA    R6,SLOTSIZE(R6)\n         B     RDDIR030\n\nRDDIR090 EQU   *\n         CLC   SLOTOFFM(8,R6),SLOTOFFM(R9)  BETWEEN CURRENT AND NEXT?\n         BL    RDDIR100\n         LR    R8,R9\n         L     R9,12(R8)\n         B     RDDIR090\n\nRDDIR100 EQU   *\n         ST    R6,SLOTOFFN(R8)    STORE AS NEW BETWEEN\n         LR    R8,R6\n         ST    R9,SLOTOFFN(R6)\n         LA    R6,SLOTSIZE(R6)\n         B     RDDIR030\n\nRDDIR110 EQU   *\n         SR    R14,R14\n         IC    R14,11(R4)\n         SLL   R14,27             POINT TO NEXT DIRECTORY ENTRY\n         SRL   R14,26                WHEN MEMBER NOT SELECTED\n         LA    R4,12(R14,R4)\n         B     RDDIR030\n\nRDDIREOF EQU   *\n         BR    R12\n\n***********************************************************************\n*    DETERMINE WHICH ARE DUPS (FOR DUPS/DUPS(ONLY) USAGE\n***********************************************************************\n\n*  R8 -> CURRENT MEMBER IN SLOT LIST\n*  R9 -> NEXT MEMBER IN SLOT LIST\n\nDETDUPS  EQU   *\n         CLI   DEFD,C'Y'\n         BNE   DETDEXIT\n         L     R8,FIRSTMEM\n         L     R9,12(R8)\n\nDEFD010  EQU   *\n         CLC   SLOTOFFM(8,R8),EIGHTXFF\n         BE    DETDEXIT\n         CLC   SLOTOFFM(8,R8),SLOTOFFM(R9)\n         BNE   DEFD040\n         MVI   SLOTOFFD(R8),C'Y'\n         MVI   SLOTOFFD(R9),C'Y'\n\nDEFD040  EQU   *\n         LR    R8,R9\n         L     R9,SLOTOFFN(R8)\n         B     DEFD010\n\nDETDEXIT EQU   *\n         BR    R12\n\n***********************************************************************\n*    PRINT MEMBER DATA\n***********************************************************************\n\n*  R2 -> LRECL SIZE\n*  R3 -> INPUT PDS MEMBER BUFFER\n*  R4 -> LINES OUTPUT\n*  R5 -> PAGE SIZE\n*  R6 -> FIND MEMBER POINTER, END OF DATA\n*  R7 -> IHADCB\n*  R8 -> CURRENT MEMBER IN SLOT LIST\n*  R9 -> DATA POINTER\n*  R14-> SHORT TERM RETURN POINTER (SAVED IN PRINTRET)\n\nPRINTMEM EQU   *\n         CLI   DEFIO,C'Y'         INDEX ONLY?\n         BE    PRINT990\n         MVC   PRTLINE,BLANKS\n         LA    R7,PDS\n         LH    R0,DCBBLKSI\n         STORAGE  OBTAIN,LENGTH=(0),LOC=ANY\n         LR    R3,R1\n         MVI   HDR,C'-'\n         CLI   DEFE,C'Y'\n         BNE   PRINT010\n         MVI   HDR,C'1'\n\nPRINT010 EQU   *\n         L     R8,FIRSTMEM\n         MVC   LASTMEMP,EIGHTX00\n\nPRINT020 EQU   *\n         CLC   SLOTOFFM(8,R8),EIGHTXFF  LAST MEMBER PROCESSED?\n         BE    PRINT990\n         CLI   DEFDO,C'Y'         CHECK FOR DUP ONLY STATUS\n         BNE   PRINT030\n         CLI   SLOTOFFD(R8),C'Y'\n         BNE   PRINT025\n         B     PRINT040\n\nPRINT025 EQU   *\n         MVC   SLOTOFFP(3,R8),EIGHTXFF\n         B     PRINTE70\n\nPRINT030 EQU   *\n         CLI   DEFD,C'Y'          CHECK FOR DUP STATUS\n         BE    PRINT040\n         CLC   SLOTOFFM(8,R8),LASTMEMP  FOR NODUPS, ELIM DUP MEMBERS\n         BE    PRINT025\n\nPRINT040 EQU   *\n         LA    R6,SLOTOFFT(R8)\n         FIND  PDS,(R6),C\n         LA    R5,1               DO INITIAL SET OF LINES LEFT\n         SR    R4,R4              SET LINES PRINTED SO FAR TO 0\n         MVC   SLOTOFFP(3,R8),PAGECNT+1\n\nPRINT060 EQU   *\n         READ  PDSDECB,SF,(R7),(R3),'S',MF=E\n         CHECK PDSDECB\n         LR    R9,R3\n         L     R14,PDSDECB+16     FIGURE DATA LENGTH ACTUALLY READ\n         LH    R6,DCBBLKSI\n         SH    R6,14(R14)\n         TM    DCBRECFM,DCBRECU\n         BO    PRINTU\n         TM    DCBRECFM,DCBRECV\n         BO    PRINTV\n\nPRINTF   EQU   *                  FIXED RECFM\n         LA    R6,0(R6,R9)\n         MVI   PRTEDLEN,C'N'\n\nPRINTF10 EQU   *\n         LH    R2,DCBLRECL\n         C     R2,FW100\n         BH    PRINTF40\n         BCTR  R2,0\n         ST    R2,PRTLEN\n         EX    R2,MVCDATA\n         BAS   R14,PRINTRTN\n         LA    R9,1(R2,R9)\n         CR    R9,R6\n         BL    PRINTF10\n         B     PRINT060\n\nPRINTF40 EQU   *\n         MVC   PRTLINE+10(100),0(R9)\n\n         CLI   PRTEDLEN,C'Y'\n         BE    PRINTF70\n         MVI   PRTEDLEN,C'Y'\n         CVD   R2,DW\n         UNPK  PRTLINE+1(5),DW+5(3)\n         OI    PRTLINE+5,X'F0'\n\nPRINTF70 EQU   *\n         MVC   PRTLEN,FW99\n         BAS   R14,PRINTRTN\n         S     R2,FW100\n         LA    R9,100(R9)\n         B     PRINTF10\n\nPRINTU   EQU   *                  UNFORMATTED RECFM\n         LR    R2,R6\n         LA    R6,0(R6,R9)\n         CVD   R2,DW\n         UNPK  PRTLINE+1(5),DW+5(3)\n         OI    PRTLINE+5,X'F0'\n\nPRINTU10 EQU   *\n         C     R2,FW100\n         BH    PRINTU40\n         BCTR  R2,0\n         ST    R2,PRTLEN\n         EX    R2,MVCDATA\n         BAS   R14,PRINTRTN\n         B     PRINT060\n\nPRINTU40 EQU   *\n         MVC   PRTLINE+10(100),0(R9)\n\n         MVC   PRTLEN,FW99\n         BAS   R14,PRINTRTN\n         S     R2,FW100\n         LA    R9,100(R9)\n         B     PRINTU10\n\nPRINTV   EQU   *                  VARIABLE RECFM\n         LH    R6,0(R9)\n         LA    R6,0(R6,R9)\n         LA    R9,4(R9)\n\nPRINTV05 EQU   *\n         LH    R2,0(R9)\n         C     R2,FW12\n         BL    PRINTV10\n         CLI   DEFV,C'Y'\n         BNE   PRINTV10\n         LR    R14,R2\n         TRT   4(8,R9),NUMTABLE\n         BNZ   PRINTV07\n         MVC   PRTLINE+113(8),4(R9)\n         LR    R2,R14\n         LA    R9,8(R9)\n         S     R2,FW8\n         B     PRINTV10\n\nPRINTV07 EQU   *\n         LR    R2,R14\n\nPRINTV10 EQU   *\n         LA    R9,4(R9)\n         S     R2,FW4\n         CVD   R2,DW\n         UNPK  PRTLINE+1(5),DW+5(3)\n         OI    PRTLINE+5,X'F0'\n\nPRINTV20 EQU   *\n         C     R2,FW100\n         BH    PRINTV60\n         BCTR  R2,0\n         ST    R2,PRTLEN\n         EX    R2,MVCDATA\n         BAS   R14,PRINTRTN\n         LA    R9,1(R2,R9)\n         CR    R9,R6\n         BL    PRINTV05\n         B     PRINT060\n\nPRINTV60 EQU   *\n         MVC   PRTLINE+10(100),0(R9)\n\n         MVC   PRTLEN,FW99\n         BAS   R14,PRINTRTN\n         S     R2,FW100\n         LA    R9,100(R9)\n         B     PRINTV20\n\nPRINTEOF EQU   *                  END OF INDIVIDUAL MEMBER DATA\n         LTR   R4,R4\n         BNZ   PRINTE50\n         MVC   HDRMEM,SLOTOFFM(R8)\n         SR    R14,R14\n         IC    R14,SLOTOFFC(R8)\n         MH    R14,HW50\n         L     R15,DSNAREA\n         LA    R14,0(R14,R15)\n         MVC   HDRDSN,0(R14)\n         MVC   HDRVOL,44(R14)\n         L     R14,PAGECNT\n         MVC   HDRPAGE#,PAGEFMT\n         CVD   R14,DW\n         ED    HDRPAGE#,DW+3\n         LA    R14,1(R14)\n         ST    R14,PAGECNT\n         MVC   HDRALIAS,BLANKS\n         CLI   SLOTOFFA(R8),C'Y'\n         BNE   PRINTE30\n         MVC   HDRALIAS,OPTALIAS\n\nPRINTE30 EQU   *\n         PUT   SYSPRINT,HDR\n         PUT   SYSPRINT,UNDER\n\nPRINTE50 EQU   *\n         CLI   DEFF,C'Y'\n         BNE   PRINTE70\n         PUT   SYSPRINT,FOOTLINE\n\nPRINTE70 EQU   *\n         MVC   LASTMEMP,SLOTOFFM(R8)\n         L     R8,SLOTOFFN(R8)\n         B     PRINT020\n\nPRINT990 EQU   *                  EXIT FROM PRINT MEMBER ROUTINE\n         BR    R12\n\n***********************************************************************\n*   GENERAL PRINT ROUTINE FOR MEMBER DATA - REGISTERS ARE THE\n*   SAME AS FOR PRINTMEM PLUS R14 IS USED TO RETURN TO PRINTMEM\n***********************************************************************\n\nPRINTRTN EQU   *\n         ST    R14,PRINTRET\n         BCT   R5,PRINTR60\n\n         L     R5,DEFP            HEADING GENERATION\n         CLI   DEFF,C'Y'\n         BNE   PRINTR20\n         LTR   R4,R4              PUT FOOTING IF PREVIOUS LINES\n         BZ    PRINTR20\n         PUT   SYSPRINT,FOOTLINE\n\nPRINTR20 EQU   *\n         MVC   HDRMEM,SLOTOFFM(R8)\n         SR    R14,R14\n         IC    R14,SLOTOFFC(R8)\n         MH    R14,HW50\n         L     R15,DSNAREA\n         LA    R14,0(R14,R15)\n         MVC   HDRDSN,0(R14)\n         MVC   HDRVOL,44(R14)\n         L     R14,PAGECNT\n         MVC   HDRPAGE#,PAGEFMT\n         CVD   R14,DW\n         ED    HDRPAGE#,DW+3\n         LA    R14,1(R14)\n         ST    R14,PAGECNT\n         MVC   HDRALIAS,BLANKS\n         CLI   SLOTOFFA(R8),C'Y'\n         BNE   PRINTR40\n         MVC   HDRALIAS,OPTALIAS\n\nPRINTR40 EQU   *\n         PUT   SYSPRINT,HDR\n         PUT   SYSPRINT,UNDER\n\nPRINTR60 EQU   *\n         MVC   SAVEPRT,PRTLINE+10\n         CLI   DEFT,C'Y'\n         BNE   PRINTR61\n         L     R14,PRTLEN\n         EX    R14,TRDATA\n\nPRINTR61 EQU   *\n         PUT   SYSPRINT,PRTLINE\n         MVC   PRTLINE+10(100),SAVEPRT\n         LA    R4,1(R4)\n         C     R4,DEF1          CHECK IF REACHED LINES TO BE PUT OUT\n         BNL   PRINTEOF\n         CLI   DEFH,C'Y'\n         BNE   PRINTR99\n         MVC   PRTLINE+1(9),BLANKS\n         MVC   PRTLINE+110(10),BLANKS\n         BCT   R5,PRINTR75\n         L     R5,DEFP\n         CLI   DEFF,C'Y'\n         BNE   PRINTR65\n         LTR   R4,R4\n         BZ    PRINTR65\n         PUT   SYSPRINT,FOOTLINE\n\nPRINTR65 EQU   *\n         MVC   HDRMEM,SLOTOFFM(R8)\n         SR    R14,R14\n         IC    R14,SLOTOFFC(R8)\n         MH    R14,HW50\n         L     R15,DSNAREA\n         LA    R14,0(R14,R15)\n         MVC   HDRDSN,0(R14)\n         MVC   HDRVOL,44(R14)\n         L     R14,PAGECNT\n         MVC   HDRPAGE#,PAGEFMT\n         CVD   R14,DW\n         ED    HDRPAGE#,DW+3\n         LA    R14,1(R14)\n         ST    R14,PAGECNT\n         MVC   HDRALIAS,BLANKS\n         CLI   SLOTOFFA(R8),C'Y'\n         BNE   PRINTR70\n         MVC   HDRALIAS,OPTALIAS\n\nPRINTR70 EQU   *\n         PUT   SYSPRINT,HDR\n         PUT   SYSPRINT,UNDER\n\nPRINTR75 EQU   *\n         MVC   SAVEPRT,PRTLINE+10\n         L     R14,PRTLEN\n         EX    R14,TRHEX1                PRINT 1ST HEX LINE\n         PUT   SYSPRINT,PRTLINE\n         LA    R4,1(R4)\n         C     R4,DEF1\n         BNL   PRINTEOF\n         MVC   PRTLINE+10(100),SAVEPRT\n         BCT   R5,PRINTR90\n         L     R5,DEFP\n         CLI   DEFF,C'Y'\n         BNE   PRINTR80\n         LTR   R4,R4\n         BZ    PRINTR80\n         PUT   SYSPRINT,FOOTLINE\n\nPRINTR80 EQU   *\n         MVC   HDRMEM,SLOTOFFM(R8)\n         SR    R14,R14\n         IC    R14,SLOTOFFC(R8)\n         MH    R14,HW50\n         L     R15,DSNAREA\n         LA    R14,0(R14,R15)\n         MVC   HDRDSN,0(R14)\n         MVC   HDRVOL,44(R14)\n         L     R14,PAGECNT\n         MVC   HDRPAGE#,PAGEFMT\n         CVD   R14,DW\n         ED    HDRPAGE#,DW+3\n         LA    R14,1(R14)\n         ST    R14,PAGECNT\n         MVC   HDRALIAS,BLANKS\n         CLI   SLOTOFFA(R8),C'Y'\n         BNE   PRINTR85\n         MVC   HDRALIAS,OPTALIAS\n\nPRINTR85 EQU   *\n         PUT   SYSPRINT,HDR\n         PUT   SYSPRINT,UNDER\n\nPRINTR90 EQU   *\n         L     R14,PRTLEN\n         EX    R14,TRHEX2                PRINT 2ND HEX LINE\n         PUT   SYSPRINT,PRTLINE\n         LA    R4,1(R4)\n         C     R4,DEF1\n         BNL   PRINTEOF\n\nPRINTR99 EQU   *\n         MVC   PRTLINE,BLANKS\n         L     R14,PRINTRET\n         BR    R14\n\n***********************************************************************\n*    PRINT LIST OF CONCATENATED DATA SET INPUT NAMES\n***********************************************************************\n\n*  R5 -> PAGE SIZE\n*  R8 -> DSN TO BE PROCESSED\n*  R9 -> CONCAT COUNT\n\nPRTDSNS  EQU   *\n         CLI   DEFI,C'Y'\n         BNE   PRTDSNSX\n\n         MVC   PRTLINE,BLANKS     PRINT DATASET NAME CONCATENATION LIST\n         L     R5,DEFP\n         L     R8,DSNAREA\n         L     R9,CATCNT\n         ZAP   DW,P1\n         B     PRTCAT30\n\nPRTCAT20 EQU   *\n         BCT   R5,PRTCAT40\n         L     R5,DEFP\n         CLI   DEFF,C'Y'\n         BNE   PRTCAT30\n         PUT   SYSPRINT,FOOTLINE\n\nPRTCAT30 EQU   *\n         PUT   SYSPRINT,DSCATHDR\n         PUT   SYSPRINT,UNDER\n\nPRTCAT40 EQU   *\n         MVC   PRTLINE+10(44),0(R8)\n         MVC   PRTLINE+61(6),44(R8)\n         MVC   PRTLINE+1(4),CATFMT\n         ED    PRTLINE+1(4),DW+6\n         PUT   SYSPRINT,PRTLINE\n         LA    R8,50(R8)\n         AP    DW+6(2),P1\n         BCT   R9,PRTCAT20\n\n         CLI   DEFF,C'Y'\n         BNE   PRTCAT90\n         PUT   SYSPRINT,FOOTLINE\nPRTCAT90 EQU   *\n\nPRTDSNSX EQU   *\n         BR    R12\n\n***********************************************************************\n*    PRINT INDEX LIST\n***********************************************************************\n\n*  R2 -> TOP 1ST COLUMN\n*  R3 -> TOP 2ND COLUMN\n*  R4 -> TOP 3RD COLUMN\n*  R5 -> TOP 4TH COLUMN\n*  R8 -> NEXT MEMBER IN LIST\n*  R9 -> COLUMN SIZE\n\nPRTINDEX EQU   *\n         CLI   DEFI,C'Y'\n         BNE   PRTEXIT\n\n         L     R8,FIRSTMEM        GET MEMBERS FOR EACH OF 4 COLUMNS\nPRTCOL00 EQU   *\n         LA    R2,EIGHTXFF\n         LA    R3,EIGHTXFF\n         LA    R4,EIGHTXFF\n         LA    R5,EIGHTXFF\n         CLC   EIGHTXFF,0(R8)\n         BE    PRTEXIT\n         L     R9,DEFP            FIGURE COLUMN SIZE (LENGTH)\n         CLI   DEFDO,C'Y'\n         BNE   PRTCOL10\nPRTCOL05 EQU   *\n         CLC   EIGHTXFF,0(R8)\n         BE    PRTEXIT\n         CLI   SLOTOFFD(R8),C'Y'\n         BE    PRTCOL10\n         L     R8,SLOTOFFN(R8)\n         B     PRTCOL05\nPRTCOL10 EQU   *\n         LR    R2,R8              SET HEAD OF COLUMN 1\n         L     R8,SLOTOFFN(R8)\n         BCTR  R9,0\nPRTCOL15 EQU   *\n         CLC   EIGHTXFF,0(R8)     CHECK FOR REST OF COLUMN 1\n         BE    PRTIDX00\n         CLI   DEFDO,C'Y'\n         BNE   PRTCOL20\n         CLI   SLOTOFFD(R8),C'Y'\n         BE    PRTCOL20\n         L     R8,SLOTOFFN(R8)\n         B     PRTCOL15\nPRTCOL20 EQU   *\n         L     R8,SLOTOFFN(R8)\n         BCT   R9,PRTCOL15\n\n         CLC   EIGHTXFF,0(R8)\n         BE    PRTIDX00\n         L     R9,DEFP            FIGURE COLUMN SIZE (LENGTH)\n         CLI   DEFDO,C'Y'\n         BNE   PRTCOL35\nPRTCOL30 EQU   *\n         CLC   EIGHTXFF,0(R8)\n         BE    PRTIDX00\n         CLI   SLOTOFFD(R8),C'Y'\n         BE    PRTCOL35\n         L     R8,SLOTOFFN(R8)\n         B     PRTCOL30\nPRTCOL35 EQU   *\n         LR    R3,R8              SET HEAD OF COLUMN 2\n         L     R8,SLOTOFFN(R8)\n         BCTR  R9,0\nPRTCOL40 EQU   *\n         CLC   EIGHTXFF,0(R8)     CHECK FOR REST OF COLUMN 2\n         BE    PRTIDX00\n         CLI   DEFDO,C'Y'\n         BNE   PRTCOL45\n         CLI   SLOTOFFD(R8),C'Y'\n         BE    PRTCOL45\n         L     R8,SLOTOFFN(R8)\n         B     PRTCOL40\nPRTCOL45 EQU   *\n         L     R8,SLOTOFFN(R8)\n         BCT   R9,PRTCOL40\n\n         CLC   EIGHTXFF,0(R8)\n         BE    PRTIDX00\n         L     R9,DEFP            FIGURE COLUMN SIZE (LENGTH)\n         CLI   DEFDO,C'Y'\n         BNE   PRTCOL60\nPRTCOL55 EQU   *\n         CLC   EIGHTXFF,0(R8)\n         BE    PRTIDX00\n         CLI   SLOTOFFD(R8),C'Y'\n         BE    PRTCOL60\n         L     R8,SLOTOFFN(R8)\n         B     PRTCOL55\nPRTCOL60 EQU   *\n         LR    R4,R8              SET HEAD OF COLUMN 3\n         L     R8,SLOTOFFN(R8)\n         BCTR  R9,0\nPRTCOL65 EQU   *\n         CLC   EIGHTXFF,0(R8)     CHECK FOR REST OF COLUMN 3\n         BE    PRTIDX00\n         CLI   DEFDO,C'Y'\n         BNE   PRTCOL70\n         CLI   SLOTOFFD(R8),C'Y'\n         BE    PRTCOL70\n         L     R8,SLOTOFFN(R8)\n         B     PRTCOL65\nPRTCOL70 EQU   *\n         L     R8,SLOTOFFN(R8)\n         BCT   R9,PRTCOL65\n\n         CLC   EIGHTXFF,0(R8)\n         BE    PRTIDX00\n         L     R9,DEFP            FIGURE COLUMN SIZE (LENGTH)\n         CLI   DEFDO,C'Y'\n         BNE   PRTCOL85\nPRTCOL80 EQU   *\n         CLC   EIGHTXFF,0(R8)\n         BE    PRTIDX00\n         CLI   SLOTOFFD(R8),C'Y'\n         BE    PRTCOL85\n         L     R8,SLOTOFFN(R8)\n         B     PRTCOL80\nPRTCOL85 EQU   *\n         LR    R5,R8              SET HEAD OF COLUMN 4\n         L     R8,SLOTOFFN(R8)\n         BCTR  R9,0\nPRTCOL90 EQU   *\n         CLC   EIGHTXFF,0(R8)     CHECK FOR REST OF COLUMN 4\n         BE    PRTIDX00\n         CLI   DEFDO,C'Y'\n         BNE   PRTCOL95\n         CLI   SLOTOFFD(R8),C'Y'\n         BE    PRTCOL95\n         L     R8,SLOTOFFN(R8)\n         B     PRTCOL90\nPRTCOL95 EQU   *\n         L     R8,SLOTOFFN(R8)\n         BCT   R9,PRTCOL90\n\nPRTIDX00 EQU   *\n         L     R9,DEFP\n         PUT   SYSPRINT,INDEXHDR\n         PUT   SYSPRINT,UNDER\nPRTIDX10 EQU   *\n         MVC   PRTLINE,BLANKS\n         CLC   EIGHTXFF,SLOTOFFM(R2)  FILL FIRST COLUMN\n         BE    PRTEXIT\n         CLI   DEFDO,C'Y'\n         BNE   PRTIDX20\n         CLI   SLOTOFFD(R2),C'Y'\n         BE    PRTIDX20\n         L     R2,SLOTOFFN(R2)\n         B     PRTIDX10\nPRTIDX20 EQU   *\n         SR    R14,R14\n         MVC   PRTLINE+PRTOFFM1(8),SLOTOFFM(R2)\n         CLI   DEFA,C'Y'\n         BNE   PRTIDX22\n         CLI   SLOTOFFA(R2),C'Y'\n         BNE   PRTIDX22\n         MVI   PRTLINE+PRTOFFA1,C'A'\nPRTIDX22 EQU   *\n         IC    R14,SLOTOFFC(R2)\n         LA    R14,1(R14)\n         CVD   R14,DW\n         MVC   PRTLINE+PRTOFFC1(4),CATFMT\n         ED    PRTLINE+PRTOFFC1(4),DW+6\n         CLI   DEFIO,C'Y'\n         BE    PRTIDX23\n         CLC   SLOTOFFP(3,R2),EIGHTXFF\n         BE    PRTIDX23\n         MVC   PAGECNT+1(3),SLOTOFFP(R2)\n         L     R14,PAGECNT\n         MVC   PRTLINE+PRTOFFP1(12),PAGEFMT\n         CVD   R14,DW\n         ED    PRTLINE+PRTOFFP1(12),DW+3\nPRTIDX23 EQU   *\n         L     R2,SLOTOFFN(R2)\n\nPRTIDX25 EQU   *\n         CLC   EIGHTXFF,SLOTOFFM(R3)  FILL SECOND COLUMN\n         BE    PRTIDX60\n         CLI   DEFDO,C'Y'\n         BNE   PRTIDX30\n         CLI   SLOTOFFD(R3),C'Y'\n         BE    PRTIDX30\n         L     R3,SLOTOFFN(R3)\n         B     PRTIDX25\nPRTIDX30 EQU   *\n         SR    R14,R14\n         MVC   PRTLINE+PRTOFFM2(8),SLOTOFFM(R3)\n         CLI   DEFA,C'Y'\n         BNE   PRTIDX32\n         CLI   SLOTOFFA(R3),C'Y'\n         BNE   PRTIDX32\n         MVI   PRTLINE+PRTOFFA2,C'A'\nPRTIDX32 EQU   *\n         IC    R14,SLOTOFFC(R3)\n         LA    R14,1(R14)\n         CVD   R14,DW\n         MVC   PRTLINE+PRTOFFC2(4),CATFMT\n         ED    PRTLINE+PRTOFFC2(4),DW+6\n         CLI   DEFIO,C'Y'\n         BE    PRTIDX33\n         CLC   SLOTOFFP(3,R3),EIGHTXFF\n         BE    PRTIDX33\n         MVC   PAGECNT+1(3),SLOTOFFP(R3)\n         L     R14,PAGECNT\n         MVC   PRTLINE+PRTOFFP2(12),PAGEFMT\n         CVD   R14,DW\n         ED    PRTLINE+PRTOFFP2(12),DW+3\nPRTIDX33 EQU   *\n         L     R3,SLOTOFFN(R3)\n\nPRTIDX35 EQU   *\n         CLC   EIGHTXFF,SLOTOFFM(R4)  FILL THIRD COLUMN\n         BE    PRTIDX60\n         CLI   DEFDO,C'Y'\n         BNE   PRTIDX40\n         CLI   SLOTOFFD(R4),C'Y'\n         BE    PRTIDX40\n         L     R4,SLOTOFFN(R4)\n         B     PRTIDX35\nPRTIDX40 EQU   *\n         SR    R14,R14\n         MVC   PRTLINE+PRTOFFM3(8),SLOTOFFM(R4)\n         CLI   DEFA,C'Y'\n         BNE   PRTIDX42\n         CLI   SLOTOFFA(R4),C'Y'\n         BNE   PRTIDX42\n         MVI   PRTLINE+PRTOFFA3,C'A'\nPRTIDX42 EQU   *\n         IC    R14,SLOTOFFC(R4)\n         LA    R14,1(R14)\n         CVD   R14,DW\n         MVC   PRTLINE+PRTOFFC3(4),CATFMT\n         ED    PRTLINE+PRTOFFC3(4),DW+6\n         CLI   DEFIO,C'Y'\n         BE    PRTIDX43\n         CLC   SLOTOFFP(3,R4),EIGHTXFF\n         BE    PRTIDX43\n         MVC   PAGECNT+1(3),SLOTOFFP(R4)\n         L     R14,PAGECNT\n         MVC   PRTLINE+PRTOFFP3(12),PAGEFMT\n         CVD   R14,DW\n         ED    PRTLINE+PRTOFFP3(12),DW+3\nPRTIDX43 EQU   *\n         L     R4,SLOTOFFN(R4)\n\nPRTIDX45 EQU   *\n         CLC   EIGHTXFF,SLOTOFFM(R5)  FILL FOURTH COLUMN\n         BE    PRTIDX60\n         CLI   DEFDO,C'Y'\n         BNE   PRTIDX50\n         CLI   SLOTOFFD(R5),C'Y'\n         BE    PRTIDX50\n         L     R5,SLOTOFFN(R5)\n         B     PRTIDX45\nPRTIDX50 EQU   *\n         SR    R14,R14\n         MVC   PRTLINE+PRTOFFM4(8),SLOTOFFM(R5)\n         CLI   DEFA,C'Y'\n         BNE   PRTIDX52\n         CLI   SLOTOFFA(R5),C'Y'\n         BNE   PRTIDX52\n         MVI   PRTLINE+PRTOFFA4,C'A'\nPRTIDX52 EQU   *\n         IC    R14,SLOTOFFC(R5)\n         LA    R14,1(R14)\n         CVD   R14,DW\n         MVC   PRTLINE+PRTOFFC4(4),CATFMT\n         ED    PRTLINE+PRTOFFC4(4),DW+6\n         CLI   DEFIO,C'Y'\n         BE    PRTIDX53\n         CLC   SLOTOFFP(3,R5),EIGHTXFF\n         BE    PRTIDX53\n         MVC   PAGECNT+1(3),SLOTOFFP(R5)\n         L     R14,PAGECNT\n         MVC   PRTLINE+PRTOFFP4(12),PAGEFMT\n         CVD   R14,DW\n         ED    PRTLINE+PRTOFFP4(12),DW+3\nPRTIDX53 EQU   *\n         L     R5,SLOTOFFN(R5)\n\nPRTIDX60 EQU   *\n         PUT   SYSPRINT,PRTLINE\n         BCT   R9,PRTIDX10\n         CLI   DEFF,C'Y'\n         BNE   PRTIDX70\n         PUT   SYSPRINT,FOOTLINE\nPRTIDX70 EQU   *\n         B     PRTCOL00\n\nPRTEXIT  EQU   *\n         BR    R12\n\n***********************************************************************\n*    CLOSE ALL DCBS AND FREE ANY OBTAINED STORAGE\n***********************************************************************\n\n*  R1 -> CLOSE MACRO\n*  R5 -> DCB\n*  R6 -> DCB\n*  R7 -> DCB\n\nCLOSERTN EQU   *\n         LA    R1,CLOSE           CLOSE FILES\n         LA    R5,DIR\n         LA    R6,PDS\n         LA    R7,SYSPRINT\n         CLOSE ((R5),,(R6),,(R7)),MF=(E,(R1)),MODE=31\n         CLI   SYSINOK,C'Y'\n         BNE   CLOSEOUT\n         LA    R1,CLOSSYSI\n         LA    R5,SYSIN\n         CLOSE ((R5)),MF=(E,(R1)),MODE=31\n\nCLOSEOUT EQU   *\n         BR    R12\n\n***********************************************************************\n*    OFFSETS FOR SLOT LIST\n***********************************************************************\n\nSLOTSIZE EQU   20                 SLOT SIZE\n\nSLOTOFFM EQU    0                 MEMBER NAME\nSLOTOFFT EQU    8                 PDS TTR (INITIALLY)\nSLOTOFFP EQU    8                 STARTING PAGE IN LISTING (FOR PRINT)\nSLOTOFFC EQU   11                 PDS CONCATENATION COUNT\nSLOTOFFN EQU   12                 NEXT SLOT LIST MEMBER\nSLOTOFFX EQU   16                 ATTRIBUTES OF MEMBER\nSLOTOFFA EQU   16                 ALIAS\nSLOTOFFD EQU   17                 DUPLICATE\n\n***********************************************************************\n*    OFFSETS FOR INDEX PRINT LINE\n***********************************************************************\n\nPRTOFFM1 EQU    1                 COLUMN 1 MEMBER NAME\nPRTOFFP1 EQU    9                 COLUMN 1 MEMBER PAGE NUMBER\nPRTOFFC1 EQU   21                 COLUMN 1 DATA SET CONCATENATION #\nPRTOFFA1 EQU   27                 COLUMN 1 ALIAS INDICATOR\n\nPRTOFFM2 EQU   32                 COLUMN 2 MEMBER NAME\nPRTOFFP2 EQU   40                 COLUMN 2 MEMBER PAGE NUMBER\nPRTOFFC2 EQU   52                 COLUMN 2 DATA SET CONCATENATION #\nPRTOFFA2 EQU   58                 COLUMN 2 ALIAS INDICATOR\n\nPRTOFFM3 EQU   63                 COLUMN 3 MEMBER NAME\nPRTOFFP3 EQU   71                 COLUMN 3 MEMBER PAGE NUMBER\nPRTOFFC3 EQU   83                 COLUMN 3 DATA SET CONCATENATION #\nPRTOFFA3 EQU   89                 COLUMN 3 ALIAS INDICATOR\n\nPRTOFFM4 EQU   94                 COLUMN 4 MEMBER NAME\nPRTOFFP4 EQU  102                 COLUMN 4 MEMBER PAGE NUMBER\nPRTOFFC4 EQU  114                 COLUMN 4 DATA SET CONCATENATION #\nPRTOFFA4 EQU  120                 COLUMN 4 ALIAS INDICATOR\n\n***********************************************************************\n*    STATIC DATA\n***********************************************************************\n\nOPTALIAS DC    CL5'ALIAS'\nOPTBLKSI DC    CL8'BLKSIZE('\nOPTDUPO  DS   0CL10\nOPTDUPS  DC    CL4'DUPS'\n         DC    CL1'('\nONLY     DC    CL4'ONLY'\n         DC    CL1')'\nOPTEJECT DC    CL5'EJECT'\nOPTFIRST DC    CL6'FIRST('\nOPTFOOT  DC    CL8'FOOTING('\nOPTHEX   DC    CL3'HEX'\nOPTINDXO DS   0CL11\nOPTINDEX DC    CL5'INDEX'\n         DC    CL6'(ONLY)'\nOPTLC    DC    CL8'LINECNT('\nOPTOPTNS DC    CL7'OPTIONS'\nOPTTRANS DC    CL9'TRANSLATE'\nOPTVARS  DC    CL6'VARSEQ'\nOPTLTMEM DC    CL8'<MEMBER('\nOPTGTMEM DC    CL8'>MEMBER('\n\nEIGHTX00 DS    CL08'0000000000000000'\nEIGHTXFF DS   0D   *****  LEAVE BEFORE NUMTABLE  *****\nNUMTABLE DC    240X'FF',010X'00',006X'FF'\nPRTTABLE DC    XL16'40404040404040404040404040404040'  00 - 0F\n         DC    XL16'40404040404040404040404040404040'  10 - 1F\n         DC    XL16'40404040404040404040404040404040'  20 - 2F\n         DC    XL16'40404040404040404040404040404040'  30 - 3F\n         DC    XL16'40404040404040404040404B4C4D4E4F'  40 - 4F\n         DC    XL16'504040404040404040405A5B5C5D5E5F'  50 - 5F\n         DC    XL16'606140404040404040406A6B6C6D6E6F'  60 - 6F\n         DC    XL16'404040404040404040407A7B7C7D7E7F'  70 - 7F\n         DC    XL16'40818283848586878889404040404040'  80 - 8F\n         DC    XL16'40919293949596979899404040404040'  90 - 9F\n         DC    XL16'4040A2A3A4A5A6A7A8A9404040404040'  A0 - AF\n         DC    XL16'B0404040404040404040BABB40404040'  B0 - BF\n         DC    XL16'C0C1C2C3C4C5C6C7C8C9404040404040'  C0 - CF\n         DC    XL16'D0D1D2D3D4D5D6D7D8D9404040404040'  D0 - DF\n         DC    XL16'E040E2E3E4E5E6E7E8E9404040404040'  E0 - EF\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9404040404040'  F0 - FF\nTR1TABLE DC    XL16'F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0'  00 - 0F\n         DC    XL16'F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1'  10 - 1F\n         DC    XL16'F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2'  20 - 2F\n         DC    XL16'F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3'  30 - 3F\n         DC    XL16'F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4'  40 - 4F\n         DC    XL16'F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5'  50 - 5F\n         DC    XL16'F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6'  60 - 6F\n         DC    XL16'F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7'  70 - 7F\n         DC    XL16'F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8'  80 - 8F\n         DC    XL16'F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9'  90 - 9F\n         DC    XL16'C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1'  A0 - AF\n         DC    XL16'C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2'  B0 - BF\n         DC    XL16'C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3'  C0 - CF\n         DC    XL16'C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4'  D0 - DF\n         DC    XL16'C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5'  E0 - EF\n         DC    XL16'C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6'  F0 - FF\nTR2TABLE DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  00 - 0F\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  10 - 1F\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  20 - 2F\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  30 - 3F\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  40 - 4F\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  50 - 5F\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  60 - 6F\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  70 - 7F\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  80 - 8F\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  90 - 9F\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  A0 - AF\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  B0 - BF\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  C0 - CF\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  D0 - DF\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  E0 - EF\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'  F0 - FF\n\nDSNASIZE DC    F'11264'\nFW10     DC    F'10'\nFW100    DC    F'100'\nFW12     DC    F'12'\nFW121    DC    F'121'\nFW12288  DC    F'12288'\nFW2      DC    F'2'\nFW3      DC    F'3'\nFW32670  DC    F'32670'\nFW4      DC    F'4'\nFW5      DC    F'5'\nFW6      DC    F'6'\nFW7      DC    F'7'\nFW8      DC    F'8'\nFW9      DC    F'9'\nFW99     DC    F'99'\n\nHW50     DC    H'50'\nMVCDATA  MVC   PRTLINE+10(1),0(R9)\nMVCFOOT  MVC   0(1,R15),0(R8)\nMVCMEMGT MVC   DEFMEMG(1),0(R8)\nMVCMEMLT MVC   DEFMEML(1),0(R8)\nOPTPACK  PACK  DW,0(1,R7)\nOPTNUMCK TRT   0(1,R7),NUMTABLE\nTRDATA   TR    PRTLINE+10(1),PRTTABLE\nTRHEX1   TR    PRTLINE+10(1),TR1TABLE    PREP 1ST HEX LINE\nTRHEX2   TR    PRTLINE+10(1),TR2TABLE    PREP 2ND HEX LINE\n\nCATFMT   DC    XL4'40202021'\nDATEFMT  DC    XL6'212061202020'\nDEFSLOT  DC    CL4'NNNN'\nDSCATHDR DC    CL61'1PDS#     DATA SET NAME'\n         DC    CL60'VOLUME'\nINDEXHDR DC    CL1'1',3CL31' MEMBER      PAGE#   PDS       '\n         DC    CL27' MEMBER      PAGE#   PDS   '\nHIVALUES DC    CL8'HEX F''S '\nLOVALUES DC    CL8'HEX 0''S '\nOPTNTIT  DC    CL15'PDSLIST OPTIONS'\nPAGEFMT  DC    XL12'402020206B2020206B202021'\nBLANKS   DC    CL121' '\nUNDER    DC    CL1'+',120C'_'\n\nOPTNDESC EQU   *\n         DC    CL09'ALIAS    '\n         DC    CL09'DUPS     '\n         DC    CL09'EJECT    '\n         DC    CL09'FIRST    '\n         DC    CL09'FOOTING  '\n         DC    CL09'HEX      '\n         DC    CL09'INDEX    '\n         DC    CL09'LINECNT  '\n         DC    CL09'TRANSLATE'\n         DC    CL09'VARSEQ   '\n         DC    CL09'>MEMBER  '\n         DC    CL09'<MEMBER  '\n\nYES      DC    CL3'YES'\nOPTNO    DS   0CL2\nNO       DC    CL3'NO '\n\nP1       DC    PL1'1'\n\n***********************************************************************\n*    LIST FORM OF I/O MACRO INSTRUCTIONS AND OTHER DYNAMIC DATA\n*    TO BE COPIED TO OBTAINED STORAGE\n***********************************************************************\n\nDYNAMA   DS    0D\n\nXPEN     OPEN  (XIR,(INPUT),XDS,(INPUT),XYSPRINT,(OUTPUT)),MF=L,MODE=31\n\nXPENSYSI OPEN  (XYSIN,(INPUT)),MF=L,MODE=31\n\nXRDJFCB  RDJFCB  (XIR),MF=L\n\nXLOSE    CLOSE (XIR,,XDS,,XYSPRINT),MF=L,MODE=31\n\nXLOSSYSI CLOSE (XYSIN),MF=L,MODE=31\n\nXEADPDS  READ  XDSDECB,SF,XDS,0,'S',MF=L\n\nXIR      DCB   DSORG=PS,MACRF=GL,DDNAME=&DDPDS,                        *\n               RECFM=F,LRECL=256,BLKSIZE=256,BUFNO=32,                 *\n               DCBE=XIRE\nXIRE     DCBE  RMODE31=BUFF,EODAD=RDDIREOF\n\nXDS      DCB   DSORG=PO,MACRF=R,DDNAME=&DDPDS,                         *\n               DCBE=XDSE\nXDSE     DCBE  RMODE31=BUFF,EODAD=PRINTEOF\n\nXYSIN    DCB   DSORG=PS,MACRF=GL,DDNAME=&DDOPTS,                       *\n               RECFM=FB,LRECL=80,DCBE=XYSINE\nXYSINE   DCBE  RMODE31=BUFF,EODAD=OPTNEXIT\n\nXYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=&DDPRINT,                      *\n               BUFNO=32,RECFM=FBA,LRECL=121,BLKSIZE=&DEFBLKSI\n\n         DS    0D\nXIRSTMEM DC    A(EIGHTXFF)\nXATCNT   DC    F'0'\nXAGECNT  DC    F'1'\n\n*  OPTIONS CHOSEN OR DEFAULTED\n\nXDEFP    DC    F'&DEFPGSZ'        LISTING PAGE SIZE\nXDEF1    DC    F'&DEF1ST'         FIRST # OF LINES\nXDEFA    DC    CL1'&DEFALIAS'     ALIAS\nXDEFD    DC    CL1'&DEFDUPS'      DUPS\nXDEFDO   DC    CL1'&DEFDUPSO'     DUPS ONLY\nXDEFE    DC    CL1'&DEFEJECT'     EJECT\nXDEFF    DC    CL1'&DEFFOOT'      FOOTER USED\nXDEFH    DC    CL1'&DEFHEX'       HEX\nXDEFI    DC    CL1'&DEFINDX'      INDEX\nXDEFIO   DC    CL1'&DEFINDXO'     INDEX ONLY\nXDEFO    DC    CL1'&DEFOPTNS'     LIST OPTIONS\nXDEFT    DC    CL1'&DEFTRANS'     TRANSLATE\nXDEFV    DC    CL1'&DEFVAR'       VARIABLE SEQUENCE\nXDEFMEMG DC    XL8'0000000000000000' FIRST MEMBER SELECTED\nXDEFMEML DC    XL8'FFFFFFFFFFFFFFFF'  LAST MEMBER SELECTED\n\nXDR      DC    CL32'-DATE=YY/DDD   VOL=VVVVVV   DSN=',CL55' '\n         DC    CL34'MEMBER=MMMMMMMM   PAGE ###,###,###'\n\nXYSINOK  DC    CL1'Y'             SYSIN OPENED OK\n\nDYNAML   EQU   *-DYNAMA\n\n***********************************************************************\n*    DSECTS\n***********************************************************************\n\nWORKAREA DSECT\n\nSAVEAREA DS    9D\n\nDW       DS    D\nFINALRC  DS    F                  FINAL RETURN CODE\nDSNAREA  DS    F                  DSN AREA POINTER\nEXLST    DS    F                  EXIT LIST FOR READ JFCB\nEXLSTPTR DS    F                  NEED TO MOVE 3 BYTE ADDR TO DCBEXLSA\nFOOTOFFS DS    F                  OFFSET INTO PRTLINE FOR FOOTING\nPRINTRET DS    A                  RETURN ADDRESS FOR PRINT SUBROUTINE\nPRTLEN   DS    F                  ACTUAL DATA LENGTH FOR HEX TRANSLATE\n*                                    AND CHARACTER TRANSLATE\nJFCBAREA DS    CL176\nLASTMEMP DS    CL008              LAST MEMBER NAME PRINTED\nOPTNVALS DS    CL096              OPTION VALUES FOR OPTIONS DISPLAY\n\nFOOTLINE DS    CL121\nOPTNHDR  DS    CL121\nPRTEDLEN DS    CL1                CHECK FIELD FOR LENGTH PRINT OUT\nPRTLINE  DS    CL121\nSAVEPRT  DS    CL100\n\nWKINGSTG DS    0D  --- BEGIN DYNAMIC AREA REQUIRING INITIALIZATION ---\n\nOPEN     OPEN  (DIR,(INPUT),PDS,(INPUT),SYSPRINT,(OUTPUT)),MF=L,MODE=31\n\nOPENSYSI OPEN  (SYSIN,(INPUT)),MF=L,MODE=31\n\nRDJFCB   RDJFCB  (DIR),MF=L\n\nCLOSE    CLOSE (DIR,,PDS,,SYSPRINT),MF=L,MODE=31\n\nCLOSSYSI CLOSE (SYSIN),MF=L,MODE=31\n\nREADPDS  READ  PDSDECB,SF,0,0,'S',MF=L\n\nDIR      DCB   DSORG=PS,MACRF=GL,DDNAME=&DDPDS,                        *\n               RECFM=F,LRECL=256,BLKSIZE=256,BUFNO=32,                 *\n               DCBE=DIRE\nDIRE     DCBE  RMODE31=BUFF,EODAD=RDDIREOF\n\nPDS      DCB   DSORG=PO,MACRF=R,DDNAME=&DDPDS,                         *\n               DCBE=PDSE\nPDSE     DCBE  RMODE31=BUFF,EODAD=PRINTEOF\n\nSYSIN    DCB   DSORG=PS,MACRF=GL,DDNAME=&DDOPTS,                       *\n               RECFM=FB,LRECL=80,DCBE=SYSINE\nSYSINE   DCBE  RMODE31=BUFF,EODAD=OPTNEXIT\n\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=&DDPRINT,                      *\n               BUFNO=32,RECFM=FBA,LRECL=121,BLKSIZE=&DEFBLKSI\n\n         DS    0D\nFIRSTMEM DS    A\nCATCNT   DS    A\nPAGECNT  DS    F\n\n*  OPTIONS CHOSEN OR DEFAULTED\n\nDEFP     DS    F                  PAGE SIZE (LESS 2 IF DEFF = 'Y' &\n*                                    ALWAYS LESS 1 FOR THE HEADER)\nDEF1     DS    F                  FIRST # OF LINES\nDEFA     DS    CL1                ALIAS\nDEFD     DS    CL1                DUPS\nDEFDO    DS    CL1                DUPS ONLY\nDEFE     DS    CL1                EJECT\nDEFF     DS    CL1                FOOTER USED\nDEFH     DS    CL1                HEX\nDEFI     DS    CL1                INDEX\nDEFIO    DS    CL1                INDEX ONLY\nDEFO     DS    CL1                LIST OPTIONS\nDEFT     DS    CL1                TRANSLATE\nDEFV     DS    CL1                VARIABLE SEQUENCE\nDEFMEMG  DS    CL8                FIRST MEMBER SELECTED\nDEFMEML  DS    CL8                LAST MEMBER SELECTED\n\nHDR      DS    0CL121\n         DS    CL06\nHDRDATE  DS    CL06\n         DS    CL07\nHDRVOL   DS    CL06\n         DS    CL07\nHDRDSN   DS    CL44\n         DS    CL03\nHDRALIAS DS    CL05\n         DS    CL10\nHDRMEM   DS    CL08\n         DS    CL07\nHDRPAGE# DS    CL12\n\nSYSINOK  DS    CL1\n\n*  END OF DYNAMIC AREA ------------------------------------------------\n\nWORKL    EQU   (*-WORKAREA)\n*  END OF WORK AREA    ------------------------------------------------\n\n***********************************************************************\n\n         DCBD  DSORG=(PS,PO),DEVD=DA\n\n         END   PDSLIST\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//***\n//L          EXEC     PGM=IEWL,\n//             PARM='RENT,AMODE(31),RMODE(ANY),XREF,LIST,LET,DCBS',\n//             REGION=4M,COND=(5,LE)\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,\n//             DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   00091400\n  ENTRY    PDSLIST\n  NAME     PDSLIST(R)\n//***\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSLIST$": {"ttr": 32009, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x19\\x00\\x19\\x00\\x00\\xd7\\xc4\\xe2\\xd3\\xc9\\xe2\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "PDSLIST"}, "text": "//-YOUR-USERID-P JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  LIST ONE OR MORE CONCATENATED PDS'S\n//***\n//PDSLIST    EXEC     PGM=PDSLIST,REGION=4M\n//SYSUT1       DD       DISP=SHR,\n//             DSN=...\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSIN        DD       *\n     NOALIAS\n       DUPS\n     NOEJECT\n       FIRST(99999999)\n     NOFOOTING\n     NOHEX\n       INDEX\n       LINECNT(00000058)\n       OPTIONS\n     NOTRANSLATE\n     NOVARSEQ\n       >MEMBER(        )\n       <MEMBER(99999999)\n//SYSPRINT     DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDSMATC": {"ttr": 32011, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00d\\x00d\\x00\\x00\\xd7\\xc4\\xe2\\xd4\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 100, "newlines": 100, "modlines": 0, "user": "PDSMTCH"}, "text": "//-YOUR-USERID-M2 JOB (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  GEN SUPERC COMPARES FOR PDSMATCH <UNEQUAL> MEMBERS\n//***\n//C          EXEC     PGM=IEL0AA,REGION=4M,\n//             PARM=('AG,A,NCT,ESD,F(I),NOFLOW,NIS,NOLIST,M,NMI,NEST',\n//             'MAP,OF,OPT(TIME),OP,SZ(MAX),S,STMT,STG,X(F)')\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-PLI-LIB-\n\n PDSMATC:  PROC OPTIONS(MAIN) REORDER;\n\n        DCL  REC        CHAR(32760) STATIC VARYING;\n        DCL  (II,JJ,KK) FIXED BIN(31) STATIC;\n        DCL  CARD       CHAR(00080) STATIC;\n        DCL  DSN1       CHAR(00044) STATIC VARYING;\n        DCL  DSN2       CHAR(00044) STATIC VARYING;\n        DCL  MEM        CHAR(00008) STATIC VARYING;\n        DCL  I_EOF_IND  CHAR(01) STATIC INIT('N');\n        DCL  UNEQU_IND  CHAR(01) STATIC INIT('N');\n\n        ON ENDFILE(I) I_EOF_IND = 'Y';\n        READ FILE(I) INTO(REC);\n\n        DO WHILE ( I_EOF_IND  = 'N' );\n           IF SUBSTR(REC,2,11) = 'LIBRARY1 - '\n              THEN DO;\n                 DO JJ = 14 TO 80 WHILE(SUBSTR(REC,JJ,1) \u00ac= ' ');\n                 END;\n                 DSN1 = SUBSTR(REC,13,JJ-13);\n              END;\n           ELSE IF SUBSTR(REC,2,11) = 'LIBRARY2 - '\n              THEN DO;\n                 DO JJ = 14 TO 80 WHILE(SUBSTR(REC,JJ,1) \u00ac= ' ');\n                 END;\n                 DSN2 = SUBSTR(REC,13,JJ-13);\n              END;\n           ELSE IF SUBSTR(REC,12,9) = '<UNEQUAL>'\n              THEN DO;\n                 IF UNEQU_IND = 'N'\n                    THEN DO;\n                       UNEQU_IND = 'Y';\n                       CARD = '//-YOUR-USERID-S    JOB      (-YOUR-ACCT-INFO-),'\n                          || '''-YOUR-NAME-'',';\n                       WRITE FILE(O) FROM(CARD);\n                       CARD = '//             CLASS=2,MSGCLASS=X,'\n                          || 'NOTIFY=-YOUR-USERID-';\n                       WRITE FILE(O) FROM(CARD);\n                       CARD = '//***';\n                       WRITE FILE(O) FROM(CARD);\n                    END;\n                 CARD = '//' || SUBSTR(REC,2,8)\n                    || '   EXEC     PGM=ISRSUPC,REGION=8M,';\n                 WRITE FILE(O) FROM(CARD);\n                 CARD = '//             PARM=(DELTAL,LINECMP,'\n                   || ''' SEQ'','''')';\n                 WRITE FILE(O) FROM(CARD);\n                 CARD = '//NEWDD        DD       DISP=SHR,';\n                 WRITE FILE(O) FROM(CARD);\n                 DO JJ = 2 TO 9 WHILE(SUBSTR(REC,JJ,1) \u00ac= ' ');\n                 END;\n                 MEM = SUBSTR(REC,2,JJ-2);\n                 CARD = '//             DSN=' || DSN1\n                    || '(' || MEM || ')';\n                 WRITE FILE(O) FROM(CARD);\n                 CARD = '//OLDDD        DD       DISP=SHR,';\n                 WRITE FILE(O) FROM(CARD);\n                 CARD = '//             DSN=' || DSN2\n                    || '(' || MEM || ')';\n                 WRITE FILE(O) FROM(CARD);\n                 CARD = '//OUTDD        DD       SYSOUT=*';\n                 WRITE FILE(O) FROM(CARD);\n                 CARD = '//***';\n                 WRITE FILE(O) FROM(CARD);\n              END;\n           READ FILE(I) INTO(REC);\n           END;\n\n        END PDSMATC;\n\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(CYL,(05,02))\n//***\n//L          EXEC     PGM=HEWLKED,COND=(5,LT),\n//             PARM='XREF,LIST,LET,DCBS,AMODE=31,RMODE=ANY',\n//             REGION=4M\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE)\n//             DD       *\n  SETSSI   04022400\n  ENTRY    PLISTART\n  NAME     PDSMATC(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDSMATC$": {"ttr": 32257, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xc1\\xd4\\xd7\\xd1\\xc3\\xd3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "SAMPJCL"}, "text": "//-YOUR-USERID-M JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//PDSMATCH   EXEC     PGM=PDSMATCH,REGION=4M,PARM=DATA\n//*                                  PARM=EQO  TO SHOW EQUALS ONLY\n//*                                  PARM=NEO  TO SHOW UNMATCHED ONLY\n//*                                  PARM=USER TO SHOW STAT DIFFERENCES\n//*                                  PARM=DATA TO SHOW DATA DIFFERENCES\n//SYSLIB1      DD       DISP=SHR,DSN=...\n//SYSLIB2      DD       DISP=SHR,DSN=...\n//*\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSPRINT     DD       SYSOUT=*\n//SYSUDUMP     DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDSMATC#": {"ttr": 32259, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x14\\x01\\x01\\x04O\\x01\\x16!o\\x176\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2001-02-13T00:00:00", "modifydate": "2016-08-03T17:36:14", "lines": 30, "newlines": 30, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBM JOB (CCMVS),'HI FOLKS',\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.CBT492.FILE357\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT492.FILE357(PDSMATCH)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ORDER   PDSMATCH,PDSCOMP\n SETSSI  CB492357\n SETCODE AC(0)\n NAME    PDSMATCH(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDSMATC@": {"ttr": 32261, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x13\\x00\\x13\\x00\\x00\\xe2\\xc1\\xd4\\xd7\\xd1\\xc3\\xd3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "SAMPJCL"}, "text": "//-YOUR-USERID-M JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//*** FIGURE OUT WHICH MEMBERS DIFFER & SUBMIT SUPERC'S FOR THEM\n//***\n//PDSMATCH   EXEC     PGM=PDSMATCH,REGION=4M,PARM=DATA\n//SYSLIB1      DD       DISP=SHR,DSN=...\n//SYSLIB2      DD       DISP=SHR,DSN=...\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSPRINT     DD       DISP=(,PASS),DSN=&&SYSPRINT,\n//             UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),\n//             DCB=(RECFM=FBA,LRECL=121,BLKSIZE=27951)\n//***\n//PDSMATC    EXEC     PGM=PDSMATC,REGION=4M\n//I            DD       DISP=(OLD,DELETE,DELETE),DSN=&&SYSPRINT\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//O            DD       SYSOUT=(,INTRDR),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDSMATCH": {"ttr": 32263, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x162\\x7f\\x01\\x162\\x7f\\x10\\x18\\x04\\xe6\\x04\\xe6\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-11-22T00:00:00", "modifydate": "2016-11-22T10:18:06", "lines": 1254, "newlines": 1254, "modlines": 0, "user": "UPDATED"}, "text": "         TITLE '   P D S M A T C H   '\n***********************************************************************\n*          THIS PROGRAM COMPARES THE DIRECTORIES OF TWO PARTITIONED\n*          DATA SETS AND PRINTS A REPORT SHOWING WHICH MEMBERS\n*          MATCH AND WHICH MEMBERS DO NOT MATCH OR ARE NOT PRESENT\n*          IN BOTH DIRECTORIES.\n*\n*          MEMBERS ARE SAID TO MATCH IF THEIR NAMES ARE THE SAME.\n*          IF PARM=USER, IF ALL THE STATISTICS IN THEIR DIRECTORY\n*          ENTRIES ARE EQUAL (EXCEPT FIELDS CONTAINING TTR TRACK\n*          ADDRESSES). IF PARM=DATA, IF THEIR DATA ARE THE SAME.\n*\n*          DDNAMES.\n*             SYSPRINT - REPORT OUTPUT\n*             SYSLIB1  - PDS 1 INPUT\n*             SYSLIB2  - PDS 2 INPUT\n*\n*          IF PARM=EQO\n*             ONLY MEMBERS THAT MATCH WILL BE LISTED.\n*          IF PARM=NEO\n*             ONLY MEMBERS THAT DONT MATCH WILL BE LISTED.\n*          IF DEFAULTED\n*             ALL MEMBERS WILL BE LISTED FOR BOTH LIBRARIES.\n*          IF PARM=USER\n*             MEMBERS THAT ARE PRESENT IN BOTH LIBRARIES\n*             WILL BE COMPARED FOR MATCHING USERDATA.\n*             USERDATA CONSISTS OF UP TO 64 BYTES OF DATA\n*             IN THE DIRECTORY ENTRY WHICH IS PUT THERE BY\n*             THE LINKAGE EDITOR, SPF EDIT, AND OTHERS.\n*             NOTE. WITH PARM=USER,\n*             IF TWO MEMBERS HAVE THE SAME NAME AND NEITHER\n*             HAS ANY USERDATA, THEY ARE TREATED AS UNEQUAL,\n*             WITH A UNIQUE MESSAGE FOR THIS CASE.\n*          IF PARM=DATA\n*             MEMBERS THAT ARE PRESENT IN BOTH LIBRARIES\n*             WILL BE COMPARED FOR MATCHING DATA.\n*             IF TWO MEMBERS HAVE THE SAME NAME AND BOTH ARE\n*             EMPTY, THEY ARE TREATED AS UNEQUAL,\n*             WITH A UNIQUE MESSAGE FOR THIS CASE.\n*          IF PARM=SUMS\n*             COUNTS ARE PRINTED AT THE END FOR:\n*             NUMBER OF MEMBERS IN LIBRARY 1 ONLY\n*             NUMBER OF MEMBERS IN LIBRARY 2 ONLY\n*             NUMBER OF MEMBERS IN BOTH BUT DIFFERENT\n*             NUMBER OF MEMBERS IN BOTH AND EQUAL\n*\n*          LOG OF CHANGES.\n*           2015 DEC 13 - CHANGES TO GET IT TO ASSEMBLE ON MVS 3.8.\n*             CHANGED 'STORAGE' TO 'GETMAIN' AND 'FREEMAIN'\n*             IN RENTER AND REXIT SO IT ASSEMBLES ON MVS 3.8.\n*             ADDED 'LCLA' AND 'LCLB' TO RENTER AND REXIT FOR IFOX00.\n*           2015 DEC 13 - FIXES AND MINOR IMPROVEMENTS.\n*             REMOVED RENTER AND REXIT MACRO DEFS PRECEDING PDSMATCH,\n*             AS THEY ARE NOT USED BY PDSMATCH.\n*             AT CHECKF ADD CODE TO CORRECTLY HANDLE UNBLOCKED RECORDS.\n*             ADD A 'CLOSE' FUNCTION TO PDSCOMP.\n*             CALL PDSCOMP ONE LAST TIME WITH CLOSE REQUESTED.\n*             CHANGE 'END PDSCOMP' TO JUST 'END'\n*             FIX A PROBLEM AT PDS1EOF THAT CAUSED FALSE 'EQUAL'\n*             WHEN SYSLIB1 HIT EOF AND SYSLIB2 STILL HAD MORE IN\n*             ITS LAST BLOCK.\n*           2016 FEB 4 - WHEN COMPARING PDS'ES WITH A VERY LARGE NUMBER\n*             OF MEMBERS, PDSMATCH REQUIRED A BIGGER GETMAIN AT LABEL\n*             DIRSIZE.  FOR NOW, INCREASED TO 1000K.  ADEQUATE SO FAR.\n*           2016 AUG 2 - FIX BUG SHOWING 2 EMPTY MEMBERS NOT EQUAL.\n*             ADDED PARM OPTION 'SUMS' TO SHOW COUNTS AT END.\n*           2016 AUG 5 - IF THE VALUE OF DIRSIZE IS TOO SMALL TO\n*             CONTAIN THE COMBINED DIRECTORIES, ADDITIONAL MEMORY\n*             IS OBTAINED IN DIRSIZE CHUNKS AS NEEDED. DIRSIZE IS\n*             REDUCED FROM 2000*512 (~1 MB) TO 8+260*100 (~26 KB).\n*             DIRSIZE SHOULD ALWAYS BE 8 + A MULTIPLE OF 260.\n*             EACH 256-BYTE DIRECTORY BLOCK IN MEMORY WILL BE\n*             FOLLOWED BY A POINTER TO THE NEXT BLOCK, SO 260.\n*             THE OTHER 8 ARE TO KEEP TRACK OF CHUNKS FOR FREEMAIN.\n*           2016 NOV 22 - FIX RECFM V BUG, CHANGES MARKED \"FIX4\".\n*             IN THE PDSCOMP SUBPROGRAM, IF PDS1 AND PDS2 HAVE\n*             DIFFERENT BLOCK SIZES, FOR MEMBERS THAT HAVE MORE THAN\n*             ONE BLOCK, THE SECOND AND SUBSEQUENT BLOCKS WERE\n*             COMPARED AS A BLOCK USING BDW INSTEAD OF RECORD BY RECORD\n*             RESULTING IN IDENTICAL MEMBERS BEING MARKED AS UNEQUAL.\n*\n***********************************************************************\n\n         MACRO\n         REGS  &PP=R\n         LCLA  &II\n&II      SETA  0\n.LOOP    ANOP\n&PP&II   EQU   &II\n&II      SETA  &II+1\n         AIF   (&II LT 16).LOOP\n         MEND\nPDSMATCH START\n         REGS\n         USING *,R10,R11\n         B     @PROLOG-*(,15)\n         DC    AL1(11),CL11'PDSMATCH'\n         DC    CL16' &SYSDATE &SYSTIME '\n@SIZE    DC    0F'0',AL1(1),AL3(@DATAL)\n@PROLOG  STM   14,12,12(R13)\n         LR    R10,15\n         LA    R15,1\n         LA    R11,4095(R15,R10)\n         LR    R4,R1               SAVE PARM POINTER\n         L     R0,@SIZE\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING @DATA,R13\n         SR    R15,R15\n         STH   R15,RC\n         STC   R15,STATUS\n         STC   R15,OPTIONS\n         MVC   DDNAMEP,=CL8'SYSPRINT'\n         MVC   DDNAME1,=CL8'SYSLIB1'\n         MVC   DDNAME2,=CL8'SYSLIB2'\n         MVI   LINE-1,C' '\n         MVC   LINE,LINE-1\n         MVI   MESG-1,C' '\n         ZAP   REPORTPG,=P'0'\n         ZAP   REPORTLN,=P'0'\n         ZAP   REPORTMX,=P'60'\n         MVI   REPORTO-1,C' '\n         MVI   JFCB1,C' '\n         MVC   JFCB1+1(175),JFCB1\n         MVC   JFCB2(176),JFCB1\n         XC    COUNTEQ(16),COUNTEQ  ZERO 4 COUNTERS\n\n************************************************************\n*         OPEN THE PRINT FILE                              *\n************************************************************\n\n         MVC   PRTDCBW(PRTDCBL),PRTDCB\n         LA    R2,PRTDCBW\n         MVC   DDNAM(8,R2),DDNAMEP\n         MVI   OPEN,X'80'\n         OPEN  ((R2),OUTPUT),MF=(E,OPEN)\n         TM    OFLGS(R2),X'10'\n         BNO   EXIT12\n         OI    STATUS,PRTOPEN\n         B     PRTX\nPRTEXITO CLC   62(2,R1),=H'0'      IS BLKSIZE ZERO\n         BNE   0(R14)              NO\n         MVC   62(2,R1),82(R1)     YES - MAKE IT SAME AS LRECL\n         BR    R14\nPRTX     EQU   *\n\n************************************************************\n*         SCAN THE PARM FIELD                              *\n************************************************************\n\n*\n*               REGISTERS USED\n*                R14 - RETURN FROM PARSE\n*                R15 - ADDRESS OF REMAINING PARM DATA\n*                R0  - WORK\n*                R1  - USED BY TRT INSTRUCTION\n*                R2  - USED BY TRT INSTRUCTION\n*                R3  - LENGTH OF REMAINING PARM DATA MINUS 1\n*\n*               PARSE MUST NOT ALTER R0, R1, OR R3\n*\n         L     R15,0(,R4)          POINT TO PARM\n         LH    R3,0(,R15)          GET LENGTH OF PARM\n         LTR   R3,R3               IS THERE A PARM\n         BZ    PARMX               NO, BRANCH\n         LA    R15,2(,R15)         POINT TO PARM DATA\n\n         SR    R1,R1               INSURE HI ORDER BYTE ZERO\n         BCTR  R3,0                LENGTH CODE OF PARM DATA\n         B     *+16                SKIP EXECUTED INSTRUCTIONS\nTRTNONBL TRT   0(0,R15),TABNONBL   (EXECUTED)\nTRTBLANK TRT   0(0,R15),TABBLANK   (EXECUTED)\n*              NOTE: TRT CAN CHANGE 8 BITS OF R2 AND 24 BITS OF R1\nPARMLOOP EX    R3,TRTNONBL         FIND A NONBLANK\n         BZ    PARMX               BRANCH IF ALL BLANKS\n         LR    R0,R1               GET ADDRESS OF STRING\n         SR    R0,R15              GET LENGTH OF PRECEDING BLANKS\n         SR    R3,R0               GET LENGTH OF REMAINING TEXT\n         LR    R15,R1              GET ADDRESS OF NONBLANK\n         EX    R3,TRTBLANK         FIND A BLANK\n         BZ    PARMLAST            BRANCH IF NOT FOUND\n         LR    R0,R1               GET ADDRESS OF BLANK\n         SR    R0,R15              GET LENGTH OF FIELD\n         BAL   R14,PARSE\n         SR    R3,R0               GET LENGTH CODE OF REMAINING TEXT\n         BZ    PARMX               BRANCH IF ONE TRAILING BLANK\n         LR    R15,R1              POINT TO BLANK\n         B     PARMLOOP\nPARMLAST LA    R0,1(,R3)           GET LENGTH\n         BAL   R14,PARSE\n         B     PARMX\n\n************************************************************\n*         PROCESS EACH PARM KEYWORD                        *\n************************************************************\n\nPARSE    STM   R14,R1,PARSES       SAVE REGS\n         CH    R0,=H'4'            IS KEYWORD LENGTH 4\n         BNE   PARSL4X             NO, BRANCH\n         CLC   0(4,R15),=C'USER'\n         BNE   *+12\n         OI    OPTIONS,OPTUSER\n         B     PARSX\n         CLC   0(4,R15),=C'DATA'\n         BNE   *+12\n         OI    OPTIONS,OPTDATA\n         B     PARSX\n         CLC   0(4,R15),=C'SUMS'\n         BNE   PARSL4X\n         OI    OPTIONS,OPTSUMS\n         B     PARSX\nPARSL4X  EQU   *\n         CH    R0,=H'3'            IS KEYWORD LENGTH 3\n         BNE   PARSL3X             NO, BRANCH\n         CLC   0(3,R15),=C'EQO'    EQONLY\n         BNE   *+8\n         OI    OPTIONS,OPTEQO\n         CLC   0(3,R15),=C'NEO'    NEONLY\n         BNE   *+8\n         OI    OPTIONS,OPTNEO\n         B     PARSX\nPARSL3X  EQU   *\nPARSX    LM    R14,R1,PARSES\n         BR    R14\n\nPARMX    EQU   *\n\n************************************************************\n*         SHOW CRITERIA                                    *\n************************************************************\n\n         TM    OPTIONS,OPTUSER\n         BO    PRTCRI2\n         TM    OPTIONS,OPTDATA\n         BO    PRTCRI3\n         LA    R1,MSGCRI1A\n         LA    R0,L'MSGCRI1A\n         BAL   R14,PRTMSG\n         LA    R1,MSGCRI1B\n         LA    R0,L'MSGCRI1B\n         BAL   R14,PRTMSG\n         B     PRTCRIX\nPRTCRI2  LA    R1,MSGCRI2A\n         LA    R0,L'MSGCRI2A\n         BAL   R14,PRTMSG\n         LA    R1,MSGCRI2B\n         LA    R0,L'MSGCRI2B\n         BAL   R14,PRTMSG\n         B     PRTCRIX\nPRTCRI3  LA    R1,MSGCRI3A\n         LA    R0,L'MSGCRI3A\n         BAL   R14,PRTMSG\n         LA    R1,MSGCRI3B\n         LA    R0,L'MSGCRI3B\n         BAL   R14,PRTMSG\nPRTCRIX  LA    R1,=C' '\n         LA    R0,1\n         BAL   R14,PRTMSG\n\n************************************************************\n*         OPEN THE FIRST PDS                               *\n************************************************************\n\n         MVC   DIRDCBW(DIRDCBL),DIRDCB\n         LA    R2,DIRDCBW          ADDRESS OF DCB\n         MVC   DDNAM(8,R2),DDNAME1 CHANGE THE DDNAME\n         LA    R3,DDNAM(,R2)       POINT TO DDNAME FOR DEVTYPE\n         DEVTYPE (R3),DEVAREA\n         LTR   R15,R15             IS DDNAME ALLOCATED\n         BNZ   EXIT12              NO, BRANCH\n\n         LA    R1,DIREXLST         PUT EXLST\n         IC    R0,EXLST(,R2)        ADDRESS\n         ST    R1,EXLST(,R2)         IN\n         STC   R0,EXLST(,R2)          DCB\n         LA    R0,JFCB1            PUT JFCB ADDRESS\n         ST    R0,0(,R1)            IN EXLST\n         MVI   0(R1),X'87'           AND INDICATE EXLST ENTRY TYPE\n         MVI   RDJFCB,X'80'\n         RDJFCB ((R2)),MF=(E,RDJFCB)\n\n         MVI   OPEN,X'80'\n         OPEN  ((R2),INPUT),MF=(E,OPEN)\n         TM    OFLGS(R2),X'10'\n         BNO   EXIT12\n         OI    STATUS,DIROPEN\n\n         MVC   LINE,LINE-1         BLANK LINE\n         MVC   LINE+1(10),=C'LIBRARY1 -'\n         LA    R15,LINE+12\n         MVC   0(44,R15),JFCB1\n         LA    R15,44(,R15)\nAPPENDV1 CLI   0(R15),C' '\n         BNE   *+8\n         BCT   R15,APPENDV1\n         MVC   2(2,R15),=C'ON'\n         MVC   5(6,R15),JFCB1+118  VOLUME SERIAL\n         BAL   R14,REPORTL         PUT HEADING LIBRARY1 DSN\n\n         L     R0,DIRSIZE          8 + (260 * 100)\n         GETMAIN R,LV=(0)\n         XC    0(8,R1),0(R1)       MARK THIS AS FIRST GETMAIN\n         L     R0,DIRSIZE\n         STM   R0,R1,LASTGM        SAVE MOST RECENT GETMAIN\n         LA    R3,8(,R1)           1ST DIR BLOCK AT OFFSET 8\n         ST    R3,DIRPTR1          SAVE FOR WALKING THRU DIR 1\n         LR    R15,R0              GET LENGTH\n         LA    R15,0(,R15)         CLEAR SUBPOOL\n         SR    R14,R14\n         SH    R15,=H'8'           LENGTH MINUS 8\n         D     R14,=F'260'         # DIR BLOCKS PER GETMAIN\n         LR    R1,R3               POINT TO 1ST 260-BYTE AREA\nGMDIR1   LA    R0,260(,R1)         POINT TO NEXT 260-BYTE AREA\n         ST    R0,256(,R1)         STORE THAT ADDRESS AFTER CURR\n         LR    R1,R0               POINT TO NEXT 260-BYTE AREA\n         BCT   R15,GMDIR1\n         S     R1,=F'4'            BACK UP TO LAST WORD OF PREV\n         SR    R0,R0\n         ST    R0,0(,R1)           ZERO IT TO FORCE A GETMAIN\n         ST    R1,LASTNEXT         REMEMBER IT FOR NEXT GETMAIN\n         OI    STATUS,GOTMAIN\n         MVC   DIRDECBW(DIRDECBL),DIRDECB\n         MVI   DIRSW,0\n         BAL   R8,DIRIN\n         CLOSE ((R2)),MF=(E,OPEN)\n         NI    STATUS,255-DIROPEN\n         TM    DIRSW,1             WAS DIRECTORY VALID\n         BZ    EXIT12              NO, QUIT\n*        LA    R3,256(,R3)         SET START OF SECOND DIRECTORY\n         BAL   R14,NEXTDIR         SET START OF SECOND DIRECTORY\n         ST    R3,DIRPTR2          SAVE FOR WALKING THRU DIR 2\n\n************************************************************\n*         OPEN THE SECOND PDS                              *\n************************************************************\n\n         MVC   DIRDCBW(DIRDCBL),DIRDCB\n         LA    R2,DIRDCBW          ADDRESS OF DCB\n         MVC   DDNAM(8,R2),DDNAME2 CHANGE THE DDNAME\n         LA    R3,DDNAM(,R2)       POINT TO DDNAME FOR DEVTYPE\n         DEVTYPE (R3),DEVAREA\n         LTR   R15,R15             IS DDNAME ALLOCATED\n         BNZ   EXIT12              NO, BRANCH\n\n         LA    R1,DIREXLST         PUT EXLST\n         IC    R0,EXLST(,R2)        ADDRESS\n         ST    R1,EXLST(,R2)         IN\n         STC   R0,EXLST(,R2)          DCB\n         LA    R0,JFCB2            PUT JFCB ADDRESS\n         ST    R0,0(,R1)            IN EXLST\n         MVI   0(R1),X'87'           AND INDICATE EXLST ENTRY TYPE\n         MVI   RDJFCB,X'80'\n         RDJFCB ((R2)),MF=(E,RDJFCB)\n\n         MVI   OPEN,X'80'\n         OPEN  ((R2),INPUT),MF=(E,OPEN)\n         TM    OFLGS(R2),X'10'\n         BNO   EXIT12\n         OI    STATUS,DIROPEN\n\n         MVC   LINE,LINE-1         BLANK LINE\n         MVC   LINE+1(10),=C'LIBRARY2 -'\n         LA    R15,LINE+12\n         MVC   0(44,R15),JFCB2\n         LA    R15,44(,R15)\nAPPENDV2 CLI   0(R15),C' '\n         BNE   *+8\n         BCT   R15,APPENDV2\n         MVC   2(2,R15),=C'ON'\n         MVC   5(6,R15),JFCB2+118  VOLUME SERIAL\n         BAL   R14,REPORTL         PUT HEADING LIBRARY2 DSN\n         MVC   LINE,LINE-1         BLANK LINE\n         BAL   R14,REPORTL         PUT HEADING BLANK LINE\n\n         L     R3,DIRPTR2\n         MVC   DIRDECBW(DIRDECBL),DIRDECB\n         MVI   DIRSW,0\n         BAL   R8,DIRIN\n         CLOSE ((R2)),MF=(E,OPEN)\n         NI    STATUS,255-DIROPEN\n         TM    DIRSW,1             WAS DIRECTORY VALID\n         BZ    EXIT12              NO, QUIT\n         B     COMPARE\n\n************************************************************\n*         READ THE DIRECTORY INTO STORAGE                  *\n************************************************************\n\nDIRIN    XC    DIRBLKS,DIRBLKS\n         XC    DIRBLKSU,DIRBLKSU\n         XC    MEMBERS,MEMBERS\n         XC    ALIASES,ALIASES\n\n         B     *+8\n*IRREAD  LA    R3,256(,R3)\nDIRREAD  BAL   R14,NEXTDIR\n         READ  DIRDECBW,SF,(R2),(R3),256,MF=E\n         CHECK DIRDECBW\n         TM    DIRSW,2             I/O ERROR\n         BO    DIRERR              YES, BRANCH\n         LA    R1,1\n         A     R1,DIRBLKS\n         ST    R1,DIRBLKS\n*        TM    DIRSW,1             ARE WE PAST USED BLOCKS\n*        BO    DIRREAD             YES, BRANCH\n         LR    R1,R3               POINT TO DATA JUST READ\n         LH    R0,0(,R1)           GET NUMBER OF BYTES IN USE\n         LTR   R0,R0               IS THIS NEGATIVE\n         BM    DIRINV              YES, NOT A DIRECTORY BLOCK\n         CH    R0,=H'256'          IS THIS TOO LARGE\n         BH    DIRINV              YES, NOT A DIRECTORY BLOCK\n         AR    R0,R1               POINT PAST LAST BYTE\n         LA    R1,2(,R1)           POINT TO FIRST MEMBER\nDIRENTRY CLC   0(8,R1),=8X'FF'     END OF MEMBERS\n         BE    DIRUSED\n         TM    11(R1),X'80'        ALIAS\n         BO    DIRALIAS\n         LA    R15,1               COUNT NON-ALIAS MEMBERS\n         A     R15,MEMBERS\n         ST    R15,MEMBERS\n         B     DIRNEXT\nDIRALIAS LA    R15,1               COUNT ALIAS MEMBERS\n         A     R15,ALIASES\n         ST    R15,ALIASES\nDIRNEXT  SLR   R15,R15\n         IC    R15,11(,R1)\n         N     R15,=F'31'          SET OFF ALL BUT LAST 5 BITS\n         SLL   R15,1               CHANGE HALFWORDS TO BYTES\n         LA    R1,12(R15,R1)       POINT PAST USER DATA\n         CR    R1,R0               END OF BLOCK\n         BL    DIRENTRY            NO, BRANCH\n         B     DIRREAD             YES, READ NEXT BLOCK\nDIRUSED  EQU   *\n         OI    DIRSW,1             STOP COUNTING MEMBERS\n         MVC   DIRBLKSU,DIRBLKS    SAVE NUMBER OF USED BLOCKS\n*        B     DIRREAD             GO COUNT UNUSED BLOCKS\n         B     DIREND\n\nNEXTDIR  L     R3,256(,R3)         POINT TO WHERE NEXT BLOCK WILL GO\n         LTR   R3,R3               IF NOT ZERO\n         BNZR  R14                  RETURN\n         ST    R14,NEXTD14         IF ZERO, PREPARE TO GET MORE MEM\n         L     R0,DIRSIZE          8 + (260 * 100)\n         GETMAIN R,LV=(0)\n         MVC   0(8,R1),LASTGM      SAVE PREVIOUS GETMAIN INFO\n         L     R0,DIRSIZE\n         STM   R0,R1,LASTGM        UPDATE MOST RECENT GETMAIN\n         LA    R3,8(,R1)           1ST 260-BYTE BLOCK AT OFFSET 8\n         L     R14,LASTNEXT        LAST BLOCK OF PREV GETMAIN\n         ST    R3,0(,R14)          POINTS TO 1ST BLOCK OF NEW GETMAIN\n         LR    R15,R0              GET LENGTH\n         LA    R15,0(,R15)         CLEAR SUBPOOL\n         SR    R14,R14\n         SH    R15,=H'8'           LENGTH MINUS 8\n         D     R14,=F'260'         COMPUTE # DIR BLOCKS THAT WILL FIT\n         LR    R1,R3               POINT TO 1ST 260-BYTE AREA\nGMDIR2   LA    R0,260(,R1)         POINT TO NEXT 260-BYTE AREA\n         ST    R0,256(,R1)         STORE THAT ADDRESS AT END OF CURRENT\n         LR    R1,R0               POINT TO NEXT 260-BYTE AREA\n         BCT   R15,GMDIR2\n         S     R1,=F'4'            BACK UP TO LAST WORD OF LAST 260\n         SR    R0,R0\n         ST    R0,0(,R1)           ZERO IT\n         ST    R1,LASTNEXT         REMEMBER IT FOR NEXT GETMAIN\n         L     R14,NEXTD14\n         BR    R14\n\nDIRSYN   EQU   *\n         SYNADAF ACSMETH=BSAM\n         MVC   MESSAGE(72),50(R1)\n         OI    DIRSW,2\n         SYNADRLS\n         BR    R14\nDIRINV   LA    R1,MSGINV\n         LA    R0,L'MSGINV\n         BAL   R14,PRTMSG\n         OI    DIRSW,4\n         B     DIREND\nDIRERR   LA    R1,MESSAGE\n         LA    R0,72\n         BAL   R14,PRTMSG\n         OI    DIRSW,4\n         B     DIREND\nDIREOF   LA    R1,MSGEOF\n         LA    R0,L'MSGEOF\n         BAL   R14,PRTMSG\n         OI    DIRSW,4\nDIREND   EQU   *\n         BR    R8\n\n************************************************************\n*         COMPARE ROUTINE                                  *\n************************************************************\n\nCOMPARE  EQU   *\n         L     R1,DIRPTR1          POINT TO FIRST BLOCK OF PDS1\n         ST    R1,PDSWORK1+8\n         LH    R0,0(,R1)           GET NUMBER OF BYTES IN USE\n         AR    R0,R1               POINT PAST LAST BYTE\n         LA    R1,2(,R1)           POINT TO FIRST MEMBER\n         LA    R2,PDSWORK1\n         BAL   R8,GETMEM1          GET FIRST MEMBER\n\n         L     R1,DIRPTR2          POINT TO FIRST BLOCK OF PDS2\n         ST    R1,PDSWORK2+8\n         LH    R0,0(,R1)           GET NUMBER OF BYTES IN USE\n         AR    R0,R1               POINT PAST LAST BYTE\n         LA    R1,2(,R1)           POINT TO FIRST MEMBER\n         LA    R2,PDSWORK2\n         BAL   R8,GETMEM1          GET FIRST MEMBER\n\n************************************************************\n*         READY TO COMPARE                                 *\n************************************************************\n\n         LA    R3,PDSWORK1\n         LA    R4,PDSWORK2\nREADY    CLC   20(8,R3),20(R4)\n         BL    SHOW1\n         BH    SHOW2\n         CLC   20(8,R3),=8X'FF'\n         BE    DONE\n\n************************************************************\n*         MEMBER EXISTS IN BOTH LIBRARIES                  *\n************************************************************\n\n         MVC   LINE,LINE-1\n         MVC   LINE+01(8),20(R3)\n         MVC   COMPMEM,20(R3)\n         MVC   LINE+22(8),20(R4)\n         TM    OPTIONS,OPTUSER    ARE WE COMPARING USERDATA\n         BZ    DATAOPTN           NO, CHECK FOR DATA OPTION\n         CLC   19(73,R3),19(R4)   IS USERDATA THE SAME\n         BE    SAME               YES, BRANCH\n         MVC   LINE+10(11),=C' ********* '\n         MVC   LINE+32(25),=C'NON-SPF USER DATA UNEQUAL'\n*              SEE IF BOTH ARE SPF STATS.\n*              IF BOTH ARE SPF STATS, SHOW WHICH IS MORE RECENT\n         TM    12(R3),SPFFLAG      IS USERDATA SPF\n         BNO   DIFF1               NO, BRANCH\n         TM    12(R4),SPFFLAG      IS USERDATA SPF\n         BNO   DIFF2               NO, BRANCH\n         CLC   28+8(6,R3),28+8(R4) COMPARE YY.DDD HH.MM LAST UPDATED\n         BH    RECENT1\n         BL    RECENT2\n         MVC   LINE+10(11),=C' ********* '\n         MVC   LINE+32(32),=C'SPF STATS DIFFER BUT NOT IN DATE'\n         B     MATCHP\nDIFF1    TM    12(R4),SPFFLAG      IS USERDATA SPF\n         BNO   MATCHP              NO - NEITHER MEMBER IS SPF\n         MVC   LINE+32(27),=C'ONLY LIBRARY2 HAS SPF STATS'\n         B     MATCHP\nDIFF2    MVC   LINE+32(27),=C'ONLY LIBRARY1 HAS SPF STATS'\n         B     MATCHP\nRECENT1  MVC   LINE+10(11),=C' <-- NEWER '\n         MVC   LINE+32(25),=C'LIBRARY1 IS MORE RECENT  '\n         B     MATCHP\nRECENT2  MVC   LINE+10(11),=C' NEWER --> '\n         MVC   LINE+32(25),=C'LIBRARY2 IS MORE RECENT  '\n         B     MATCHP\nDATAOPTN TM    OPTIONS,OPTDATA    ARE WE COMPARING REAL DATA\n         BZ    MATCHP             NO, GO ON WITH OTHER MEMBERS\n         CALL  PDSCOMP,COMPMEM,VL\n         LTR   R15,R15\n         BZ    MATCHP\nUNEQUAL  MVC   LINE+10(11),=C' <UNEQUAL> '\n         MVC   LINE+32(25),=C'LIBRARY DATA IS NOT SAME '\n         B     MATCHP             GO ON WITH OTHER MEMBERS\n\n************************************************************\n*         DIRECTORY DATA MATCHES                           *\n************************************************************\n\nSAME     CLI   15(R3),0           ZERO USERDATA IN BOTH\n         BNE   SAME2              NO, BRANCH\n         MVC   LINE+10(11),=C' ********* '\n         MVC   LINE+32(27),=C'NEITHER MEMBER HAS USERDATA'\n         B     MATCHP\nSAME2    TM    12(R3),SPFFLAG     SPF STATS IN BOTH\n         BO    MATCHP             YES - OMIT MESSAGE\n         MVC   LINE+10(11),=C' ********* '\n         MVC   LINE+32(23),=C'NON-SPF USER DATA EQUAL'\nMATCHP   CLI   LINE+32,C' '        IS THIS A MATCH\n         BNE   MATCHNE             NO, BRANCH\n         LA    R0,1\n         A     R0,COUNTEQ\n         ST    R0,COUNTEQ\n         TM    OPTIONS,OPTNEO     ARE WE PRINTING .NE. ONLY\n         BO    MATCHX             YES, DONT PRINT THESE\n         B     MATCHPR\nMATCHNE  LA    R0,1\n         A     R0,COUNTNE\n         ST    R0,COUNTNE\n         TM    OPTIONS,OPTEQO     ARE WE PRINTING .EQ. ONLY\n         BO    MATCHX             YES, DONT PRINT THESE\nMATCHPR  BAL   R14,REPORTL\nMATCHX   LR    R2,R3\n         BAL   R8,GETMEM\n         LR    R2,R4\n         BAL   R8,GETMEM\n         B     READY\n\n************************************************************\n*         MEMBER EXISTS ONLY IN LIBRARY 1                  *\n************************************************************\n\nSHOW1    LA    R0,1\n         A     R0,COUNTL1\n         ST    R0,COUNTL1\n         TM    OPTIONS,OPTEQO     ARE WE PRINTING .EQ. ONLY\n         BO    SHOW1X             YES, DONT PRINT THESE\n         MVC   LINE,LINE-1\n         MVC   LINE+01(8),20(R3)\n         MVC   LINE+32(23),=C'MEMBER IN LIBRARY1 ONLY'\n         BAL   R14,REPORTL\nSHOW1X   LR    R2,R3\n         BAL   R8,GETMEM\n         B     READY\n\n************************************************************\n*         MEMBER EXISTS ONLY IN LIBRARY 2                  *\n************************************************************\n\nSHOW2    LA    R0,1\n         A     R0,COUNTL2\n         ST    R0,COUNTL2\n         TM    OPTIONS,OPTEQO     ARE WE PRINTING .EQ. ONLY\n         BO    SHOW2X             YES, DONT PRINT THESE\n         MVC   LINE,LINE-1\n         MVC   LINE+22(8),20(R4)\n         MVC   LINE+32(23),=C'MEMBER IN LIBRARY2 ONLY'\n         BAL   R14,REPORTL\nSHOW2X   LR    R2,R4\n         BAL   R8,GETMEM\n         B     READY\n\n************************************************************\n*         END OF BOTH DIRECTORIES                          *\n************************************************************\n\nDONE     TM    OPTIONS,OPTSUMS\n         BZ    EXIT\n         MVC   LINE,LINE-1\n         L     R0,COUNTL1\n         CVD   R0,DOUBLE\n         MVC   LINE(6),=X'402020202020' EDIT MASK\n         ED    LINE(6),DOUBLE+5\n         MVC   LINE+7(24),=C'MEMBERS IN LIBRARY1 ONLY'\n         BAL   R14,REPORTL\n         L     R0,COUNTL2\n         CVD   R0,DOUBLE\n         MVC   LINE(6),=X'402020202020' EDIT MASK\n         ED    LINE(6),DOUBLE+5\n         MVC   LINE+7(24),=C'MEMBERS IN LIBRARY2 ONLY'\n         BAL   R14,REPORTL\n         L     R0,COUNTNE\n         CVD   R0,DOUBLE\n         MVC   LINE(6),=X'402020202020' EDIT MASK\n         ED    LINE(6),DOUBLE+5\n         MVC   LINE+7(29),=C'MEMBERS IN BOTH BUT DIFFERENT'\n         BAL   R14,REPORTL\n         MVC   LINE,LINE-1\n         L     R0,COUNTEQ\n         CVD   R0,DOUBLE\n         MVC   LINE(6),=X'402020202020' EDIT MASK\n         ED    LINE(6),DOUBLE+5\n         MVC   LINE+7(25),=C'MEMBERS IN BOTH AND EQUAL'\n         BAL   R14,REPORTL\n         B     EXIT\n\n************************************************************\n*         SUBROUTINE TO GET NEXT MEMBER FROM DIRECTORY     *\n************************************************************\n\nGETMEM   LM    R0,R1,0(R2)\n         CLC   0(8,R1),=8X'FF'     END OF MEMBERS\n         BE    GETEOF\nGET1R    SLR   R15,R15\n         IC    R15,11(,R1)\n         N     R15,=F'31'          SET OFF ALL BUT LAST 5 BITS\n         SLL   R15,1               CHANGE HALFWORDS TO BYTES\n         LA    R1,12(R15,R1)       POINT PAST USER DATA\n         CR    R1,R0               END OF BLOCK\n         BL    GETMEM1             NO, BRANCH\n*        LA    R1,256              YES, READ NEXT BLOCK\n*        A     R1,8(,R2)           YES, READ NEXT BLOCK\n*        ST    R1,8(,R2)           YES, READ NEXT BLOCK\n         L     R1,8(,R2)           NEW WAY TO GET NEXT BLOCK\n         L     R1,256(,R1)         NEW WAY TO GET NEXT BLOCK\n         ST    R1,8(,R2)           NEW WAY TO GET NEXT BLOCK\n         LH    R0,0(,R1)           GET NUMBER OF BYTES IN USE\n         AR    R0,R1               POINT PAST LAST BYTE\n         LA    R1,2(,R1)           POINT TO FIRST MEMBER\n*        B     GET1R\nGETMEM1  STM   R0,R1,0(R2)\n         MVC   20(8,R2),0(R1)      SAVE MEMBER NAME\n         CLC   0(8,R1),=8X'FF'     END OF MEMBERS\n         BE    GETEOF\n         MVC   16(4,R2),8(R1)      SAVE TTR, ALIAS BIT, ETC\n         XC    28(64,R2),28(R2)    ZERO USER DATA AREA\n*              COPY USER DATA\n         SLR   R15,R15\n         IC    R15,11(,R1)\n         N     R15,=F'31'          SET OFF ALL BUT LAST 5 BITS\n         SLL   R15,1               CHANGE HALFWORDS TO BYTES\n         ST    R15,12(,R2)         SAVE LENGTH OF USER DATA\n         LTR   R15,R15\n         BZ    GETZERO\n         TM    OPTIONS,OPTUSER     IS USERDATA TO BE COMPARED\n         BZ    GETZERO             NO, BRANCH\n         CLI   15(R2),30           IS LENGTH 30\n         BNE   *+8                 NO\n         OI    12(R2),SPFFLAG      YES, INDICATE IT MAY BE SPF STATS\n         BCTR  R15,0               LENGTH MINUS 1 FOR EX\n         B     *+10\n         MVC   28(0,R2),12(R1)     EXECUTED\n         EX    R15,*-6             MOVE THE USER DATA\n         TM    11(R1),B'01100000'  ANY TTR'S IN THE USER DATA\n         BZ    GETZERO             NO, BRANCH\n         NI    12(R2),255-SPFFLAG  YES, CAN'T BE SPF\n         IC    R15,11(,R1)         YES, PREPARE TO ZERO THEM\n         N     R15,=A(X'0000007F') SET OFF ALIAS BIT\n         SRL   R15,5               SHIFT OUT RIGHT 5 BITS\n         LA    R14,28(,R2)         POINT TO FIRST TTR IN USER DATA\nGETUTTR  XC    0(3,R14),0(R14)     ZERO THE TTR IN THE USER DATA\n         LA    R14,4(,R14)         POINT TO NEXT TTR IN THE USER DATA\n         BCT   R15,GETUTTR         REPEAT UNTIL R15 ZERO\nGETZERO  EQU   *\nGETEOF   BR    R8\n\n************************************************************\n*         MESSAGE ROUTINE                                  *\n************************************************************\n\nPRTMSG   STM   R14,R1,PRTMSGS\n         MVC   MESG,MESG-1\n         LR    R15,R0\n         BCTR  R15,0\n         B     *+10\n         MVC   MESG+1(0),0(R1)\n         EX    R15,*-6\n         LA    R1,MESG\n         LA    R0,L'MESG\n         BAL   R14,REPORT\n         LM    R14,R1,PRTMSGS\n         BR    R14\n\n************************************************************\n*         REPORT WRITER                                    *\n************************************************************\n\nREPORTL  LA    R1,LINE\n         LA    R0,121\nREPORT   STM   R14,R3,REPORTS\n         LA    R3,PRTDCBW          POINT R3 TO DCB\n         CP    REPORTLN,REPORTMX   IS LINECOUNT LIMIT REACHED\n         BL    *+10                NO\n         ZAP   REPORTLN,=P'0'      YES, FORCE NEW PAGE\n         CP    REPORTLN,=P'0'      IS NEW PAGE REQUESTED?\n         BE    REPORTH             YES, GO PRINT HEADING\nREPORTD  CH    R0,=H'121'          IS OUTPUT LINE LENGTH OK?\n         BNL   REPORTP             YES, BRANCH\n         MVC   REPORTO,REPORTO-1   BLANK THE WORK AREA\n         LTR   R14,R0              COPY LENGTH\n         BNP   REPORTB             BLANK LINE IF < 1\n         BCTR  R14,0               LENGTH MINUS 1\n         B     *+10\n         MVC   REPORTO(0),0(R1)    COPY OUTPUT LINE\n         EX    R14,*-6             EXECUTE MVC\nREPORTB  LA    R1,REPORTO          POINT TO NEW OUTPUT LINE\nREPORTP  LR    R2,R1               POINT R2 TO OUTPUT LINE\n         PUT   (R3),(R2)           WRITE OUTPUT LINE\n         AP    REPORTLN,=P'1'      INCREMENT LINE COUNTER\nREPORTX  LM    R14,R3,REPORTS      RESTORE REGS\n         BR    R14                 RETURN\nREPORTH  AP    REPORTPG,=P'1'      INCREMENT PAGE COUNTER\n         MVC   REPORTO,REPORTO-1   BLANK HEADING\n         MVI   REPORTO,C'1'        CC = NEW PAGE\n         MVC   REPORTO+1(L'HEAD1),HEAD1\n         LA    R1,REPORTO+79-9     RIGHT EDGE PAGE NO\n         MVC   3(6,R1),=X'402020202020' EDIT MASK\n         ED    3(6,R1),REPORTPG    UNPACK PAGE NO\n         MVC   0(4,R1),=C'PAGE'    INSERT 'PAGE'\n         PUT   (R3),REPORTO        PUT HEADING LINE 1\n         MVC   REPORTO,REPORTO-1   BLANK LINE\n         PUT   (R3),REPORTO        PUT HEADING BLANK LINE\n         AP    REPORTLN,=P'2'      COUNT HEADING LINES\nREPORTHX LM    R0,R1,REPORTS+8     RESTORE R0 AND R1\n         B     REPORTD             GO PRINT DETAIL LINE\n         EJECT\n************************************************************\n*         TERMINATION                                      *\n************************************************************\n\nEXIT12   MVI   RC+1,12\nEXIT     EQU   *\n         MVC   COMPMEM,=8X'FF'     INDICATE CLOSE\n         CALL  PDSCOMP,COMPMEM,VL\n         TM    STATUS,GOTMAIN      IS DIRECTORY AREA GOTTEN\n         BZ    EXITGOTX            NO, BYPASS FREEMAIN\nEXITGOTL LM    R0,R1,LASTGM\n         LTR   R0,R0\n         BZ    EXITGOTX\n         LM    R14,R15,0(R1)       POINT TO PREVIOUS GETMAIN INFO\n         STM   R14,R15,LASTGM\n*        L     R0,DIRSIZE\n*        L     R1,DIRFREE\n         FREEMAIN R,LV=(0),A=(1)\n         B     EXITGOTL\nEXITGOTX EQU   *\n         TM    STATUS,PRTOPEN      IS SYSPRINT OPEN\n         BZ    EXITPRTX            NO - BYPASS CLOSE\n         LA    R2,PRTDCBW\n         MVI   CLOSE,X'80'\n         CLOSE ((R2)),MF=(E,CLOSE)\n         FREEPOOL (R2)\nEXITPRTX EQU   *\n         LH    R15,RC\n         LR    R1,R13\n         L     R0,@SIZE\n         L     R13,4(,R13)\n         LR    R2,R15\n         FREEMAIN R,A=(1),LV=(0)\n         LR    R15,R2\n         LM    0,12,20(R13)\n         L     R14,12(,R13)\n         BR    R14\n\n************************************************************\n*        CONSTANTS                                         *\n************************************************************\n\n         LTORG\nHEAD1    DC    C'--- PDSMATCH --- PDS DIRECTORY COMPARE UTILITY ---'\n*IRSIZE  DC    0F'0',AL1(1),AL3(128*1024)  128K FOR 2 DIRECTORIES\n*IRSIZE  DC    0F'0',AL1(1),AL3(2000*512)  1000K FOR 2 DIRECTORIES\nDIRSIZE  DC    0F'0',AL1(1),AL3(8+260*100) 100 DIR BLOCKS PER GETMAIN\n*              DIRSIZE SHOULD BE 8 + A MULTIPLE OF 260\nYMDNY    DC    AL2(334,304,273,243)\n         DC    AL2(212,181,151,120)\n         DC    AL2(90,59,31,0)\nYMDLY    DC    AL2(335,305,274,244)\n         DC    AL2(213,182,152,121)\n         DC    AL2(91,60,31,0)\n         PRINT NOGEN\nPRTDCB   DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,                      +\n               RECFM=FBA,LRECL=121,EXLST=PRTEXLST\nPRTDCBL  EQU   *-PRTDCB\n\nDIRDCB   DCB   DDNAME=DYNAM,DSORG=PO,MACRF=R,EODAD=DIREOF,SYNAD=DIRSYN,X\n               RECFM=U,BLKSIZE=256\nDIRDCBL  EQU   *-DIRDCB\n\n         PRINT GEN\nPRTEXLST DC    0F'0',X'85',AL3(PRTEXITO)\nDIRREADM READ  DIRDECB,SF,MF=L\nDIRDECBL EQU   *-DIRDECB\n         PRINT GEN\nHEXTAB   DC    C'0123456789ABCDEF'\nMSGINV   DC    C'INVALID DIRECTORY BLOCK'\nMSGEOF   DC    C'NO END-OF-DIRECTORY INDICATOR FOUND'\nMSGCRI1A DC    C'CRITERIA FOR MATCHING IS MEMBER NAME ONLY.  USERDATA I+\n               N THE DIRECTORY'\nMSGCRI1B DC    C'(SUCH AS SPF STATISTICS, LOAD ATTRIBUTES) IS NOT COMPA+\n               RED.'\nMSGCRI2A DC    C'CRITERIA FOR MATCHING IS MEMBER NAME AND ALL USERDATA +\n               IN THE DIRECTORY'\nMSGCRI2B DC    C'(SUCH AS SPF STATISTICS, LOAD ATTRIBUTES) EXCEPT TTR F+\n               IELDS.'\nMSGCRI3A DC    C'CRITERIA FOR MATCHING IS MEMBER NAME AND THE ACTUAL ME+\n               MBER DATA'\nMSGCRI3B DC    C'(SPF STATISTICS ARE NOT COMPARED).'\n         DC    0D'0'\nTABNONBL DC    64X'FF'\n         DC    X'00'               BLANK\n         DC    42X'FF'\n         DC    X'00'               COMMA\n         DC    148X'FF'\nTABBLANK DC    64X'00'\n         DC    X'40'               BLANK\n         DC    42X'00'\n         DC    X'6B'               COMMA\n         DC    148X'00'\n         DC    0D'0'\nEODAD    EQU   32\nRECFM    EQU   36\nEXLST    EQU   36\nDDNAM    EQU   40\nOFLGS    EQU   48\nSYNAD    EQU   56\nBLKSI    EQU   62\nLRECL    EQU   82\n         DC    0D'0'\nCOMPMEM  DS    CL08\n\n************************************************************\n*        DSECTS                                            *\n************************************************************\n\n@DATA    DSECT\n         DS    18F                 REGISTER SAVEAREA\nDOUBLE   DS    D\nHALF     EQU   DOUBLE,2\nFULL     EQU   DOUBLE,4\nDDNAMEP  DS    CL8\nDDNAME1  DS    CL8\nDDNAME2  DS    CL8\nRC       DS    H\nSTATUS   DS    X\nPRTOPEN  EQU   X'80'\nDIROPEN  EQU   X'40'\nGOTMAIN  EQU   X'20'\nOPTIONS  DS    X\nOPTUSER  EQU   X'80'\nOPTEQO   EQU   X'40'\nOPTNEO   EQU   X'20'\nOPTDATA  EQU   X'10'\nOPTSUMS  EQU   X'08'\nLASTGM   DS    2F\nLASTNEXT DS    F\nNEXTD14  DS    F\nDIRPTR1  DS    F\nDIRPTR2  DS    F\nDIRSW    DS    F\nDIRBLKS  DS    F\nDIRBLKSU DS    F\nMEMBERS  DS    F\nALIASES  DS    F\nPRTDCBW  DS    0F,(PRTDCBL)X\nDIRDCBW  DS    0F,(DIRDCBL)X\nDIRDECBW DS    0F,(DIRDECBL)X\nDIREXLST DS    F\nDEVAREA  DS    2F\nCLOSE    DS    0F\nOPEN     DS    F\nRDJFCB   DS    F\nCOUNTEQ  DS    F\nCOUNTNE  DS    F\nCOUNTL1  DS    F\nCOUNTL2  DS    F\nPARSES   DS    6F\nREPORTS  DS    6F\nREPORTPG DS    PL3\nREPORTLN DS    PL2\nREPORTMX DS    PL2\nPRTMSGS  DS    4F\nPDSWORK1 DS    3F\n         DS    F                   USER DATA LENGTH\nSPFFLAG  EQU   X'80'               USER DATA CONTAINS SPF STATISTICS\n         DS    XL3                 TTR\n         DS    X                   ALIAS BIT AND USER DATA LENGTH\n         DS    CL8                 MEMBER NAME\n         DS    CL64                USER DATA\nPDSWORK2 DS    3F\n         DS    F                   USER DATA LENGTH\n         DS    XL3                 TTR\n         DS    X                   ALIAS BIT AND USER DATA LENGTH\n         DS    CL8                 MEMBER NAME\n         DS    CL64                USER DATA\nLINEB    DS    C  (LINE-1)\nLINE     DS    CL133\nMESGB    DS    C  (MESG-1)\nMESG     DS    CL133\nMESSAGE  DS    CL72\nREPORTOB DS    C (REPORTO-1)\nREPORTO  DS    CL133\nJFCB1    DS    0D,CL176\nJFCB2    DS    0D,CL176\n         DS    0D\n@DATAL   EQU   *-@DATA\n\n         END\n         MACRO\n&NAME    RENTER  &BASEREG=R11,&SALEN=108,&REGS=YES\n         GBLC  &SASIZE\n         LCLA  &#BR,&#BRX,&#BRY,&BASELEN   NEEDED BY IFOX00\n         LCLC  &BASES                      NEEDED BY IFOX00\n&SASIZE  SETC  '&SALEN'\n.* THIS MACRO PROVIDES ENTRY CODE FOR A REENTRANT PROGRAM.\n.* THE DEFAULT BASE REGISTER IS 11 BUT MAY BE CHANGED VIA\n.* THE BASEREG PARAMETER.  THE SAVE AREA SIZE MAY BE SET\n.* THROUGH THE SALEN PARAMETER AND DEFAULTS TO 108.\n         AIF   ('&REGS' NE 'YES').NOREGS\n         REGS\n.NOREGS  ANOP\n&NAME    CSECT\n         STM   R14,R12,12(R13)     SAVE INCOMING REGS\n         LR    &BASEREG(1),R15     ESTABLISH ADDRESSABILITY\n&#BR     SETA  N'&BASEREG\n         AIF   (&#BR GT 1).MULTIRG\n         USING &NAME,&BASEREG\n         AGO   .OUTBASE\n.MULTIRG ANOP\n&#BRX    SETA  1\n&#BRY    SETA  2\n         LA    &BASEREG(&#BR),4095\n.LOADNXT LA    &BASEREG(&#BRY),1(&BASEREG(&#BRX),&BASEREG(&#BR))\n&#BRX    SETA  &#BRX+1\n&#BRY    SETA  &#BRY+1\n         AIF   (&#BRY LE &#BR).LOADNXT\n&BASELEN SETA  K'&BASEREG-2\n&BASES   SETC  '&BASEREG'(2,&BASELEN)\n         USING &NAME,&BASES\n.OUTBASE ANOP\n         LA    R0,&SASIZE          LOAD SAVE AREA SIZE FOR GETMAIN\n         GETMAIN R,LV=(0)\n         ST    R1,8(R13)           STORE ADDRESS OF NEW SAVE AREA\n         ST    R13,4(R1)           SAVE CALLERS SAVE AREA ADDRESS\n         LM    R0,R1,20(R13)       RELOAD R0 & R1\n         L     R13,8(R13)          LOAD NEW SAVE AREA ADDRESS INTO R13\n         MEND\n         MACRO\n         REGS  &PP=R\n         LCLA  &II\n&II      SETA  0\n.LOOP    ANOP\n&PP&II   EQU   &II\n&II      SETA  &II+1\n         AIF   (&II LT 16).LOOP\n         MEND\n         MACRO\n&NAME    REXIT &RC15=YES\n         GBLC  &SASIZE\n         LCLA  &#BR,&#BRX,&#BRY,&BASELEN   NEEDED BY IFOX00\n         LCLC  &BASES                      NEEDED BY IFOX00\n&NAME    DS    0H\n         LA    R0,&SASIZE          LOAD SAVE AREA LENGTH FOR RELEASE\n         LR    R1,R13              LOAD SAVE AREA ADDRESS FOR RELEASE\n         L     R13,4(R13)          RESTORE CALLING SAVE AREA ADDRESS\n         AIF   ('&RC15' NE 'YES').NORETC\n         ST    R15,16(R13)         SAVE RETURN CODE\n.NORETC  ANOP\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)     RESTORE CALLING REGS R14 - R12\n         BR    R14\n         MEND\nPDSCOMP  RENTER\n\n*  R0\n*  R1    SHORT TERM WORK REG\n*  R2\n*  R3    PDS 1 DCB\n*  R4    PDS 1 DATA READ/1 PAST\n*  R5    PDS 1 DATA POINTER\n*  R6    PDS 2 DCB\n*  R7    PDS 2 DATA READ/1 PAST\n*  R8    PDS 2 DATA POINTER\n*  R9\n*  R10\n*  R11   BASE\n*  R12   SUBROUTINE RETURN\n*  R13   SAVEAREA\n*  R14   SHORT TERM WORK REG\n*  R15   SHORT TERM WORK REG\n\n         L     R14,0(R1)           GET MEMBER NAME\n         CLC   0(8,R14),=8X'FF'       IF MEMBER IS ALL HEX FF\n         BE    CLOSEM                 GO CLOSE THE DCB'S\n         MVC   MEMBER,0(R14)\n\n         CLI   INITIAL,C'Y'        FIRST TIME THROUGH?\n         BNE   NOTFIRST            IF NOT, DON'T DO BASIC STUFF AGAIN\n\n         MVI   INITIAL,C'N'        FIRST TIME THROUGH ONLY\n         OPEN  (PDS1,,PDS2)\n         L     R0,PDSDATAL\n         GETMAIN R,LV=(0)\n         ST    R1,PDS1DATA\n         A     R1,PDSDATAH\n         ST    R1,PDS2DATA\n\nNOTFIRST EQU   *\n         MVI   PDS1DONE,C'N'\n         MVI   PDS2READ,C'N'\n         LA    R3,PDS1             POINT TO PDS' DCB'S & DATA AREAS\n         LA    R6,PDS2\n\n         FIND  PDS1,MEMBER,D\n*        MVC   MBUF(7),=C'FIND 1 '\n*        MVC   MBUF+7(8),MEMBER\n*        LA    R1,MBUF\n*        LA    R0,15\n*        SVC   93 TPUT\n         BAL   R12,READ1\n\n         FIND  PDS2,MEMBER,D\n         BAL   R12,READ2\n\n         USING IHADCB,R3\n         TM    DCBRECFM,DCBRECU    WHAT RECORD FORMAT?\n         BO    CHECKU\n         TM    DCBRECFM,DCBRECV\n         BO    CHECKV\n         B     CHECKF\n\nCHECKF   EQU   *\n         LH    R14,DCBLRECL\n         TM    DCBRECFM,DCBRECBR   IF RECFM NOT BLOCKED          .FIX1.\n         BO    CHECKF05              THEN                        .FIX1.\n         LH    R14,DCBBLKSI          USE BLKSI AS RECORD LENGTH  .FIX1.\nCHECKF05 EQU   *                                                 .FIX1.\n         ST    R14,LRECL\nCHECKF10 EQU   *\n         LR    R14,R5              R5 --> SYSLIB1 DATA\n         L     R15,LRECL\n         LR    R0,R8               R8 --> SYSLIB2 DATA\n         LR    R1,R15\n         CLCL  R14,R0\n         BNE   NOTEQUAL\n         A     R5,LRECL\n         CR    R5,R4               R4 --> END OF SYSLIB1 BLOCK\n         BL    CHECKF20\n         BAL   R12,READ1\nCHECKF20 EQU   *\n         A     R8,LRECL\n         CR    R8,R7               R7--> END OF SYSLIB2 BLOCK\n         BL    CHECKF10\n         BAL   R12,READ2\n         B     CHECKF10\n\nCHECKV   EQU   *\n         LA    R5,4(R5)            POINT PAST BDW TO 1ST RDW\n         LA    R8,4(R8)            POINT PAST BDW TO 1ST RDW\nCHECKV10 EQU   *\n         LH    R15,0(R5)           GET RECORD LENGTH 1\n         LH    R1,0(R8)            GET RECORD LENGTH 2\n         S     R15,FW4             MINUS 4\n         S     R1,FW4              MINUS 4\n         ST    R15,LRECL           SAVE RECORD LENGTH EXCLUDING RDW\n         CR    R15,R1              IF RECORD LENGTHS DON'T MATCH\n         BNE   NOTEQUAL              NOT EQUAL\n         LA    R5,4(R5)            POINT PAST RDW 1\n         LA    R8,4(R8)            POINT PAST RDW 2\n         LR    R14,R5\n         LR    R0,R8\n         CLCL  R14,R0              COMPARE RECORDS\n         BNE   NOTEQUAL              NOT EQUAL\n         L     R15,LRECL\n         LA    R5,0(R15,R5)        POINT TO NEXT RDW 1 OR EOB\n         CR    R5,R4               IF END OF BLOCK\n         BL    CHECKV20              THEN\n         BAL   R12,READ1             READ NEXT BLOCK\n         LA    R5,4(,R5)             POINT PAST BDW TO 1ST RDW   .FIX4.\nCHECKV20 EQU   *\n         L     R15,LRECL\n         LA    R8,0(R15,R8)        POINT TO NEXT RDW 2 OR EOB\n         CR    R8,R7               IF END OF BLOCK\n         BL    CHECKV10              THEN\n         BAL   R12,READ2             READ NEXT BLOCK\n         LA    R8,4(,R8)             POINT PAST BDW TO 1ST RDW   .FIX4.\n         B     CHECKV10\n\nCHECKU   EQU   *\n         SR    R4,R5\n         SR    R7,R8\n         CR    R4,R7\n         BNE   NOTEQUAL\n         LR    R14,R5\n         LR    R15,R4\n         LR    R0,R8\n         LR    R1,R7\n         CLCL  R14,R0\n         BNE   NOTEQUAL\n         BAL   R12,READ1\n         BAL   R12,READ2\n         B     CHECKU\n\nPDS1EOF  EQU   *\n         MVI   PDS1DONE,C'Y'\n*              NEXT 4 LINES ADDED AUG 2 2016                     .FIX3.\n         CLI   PDS2READ,C'N'       IF READ2 HAS NOT BEEN CALLED  .FIX3.\n         BNE   PDS1EO1                THEN                       .FIX3.\n         FIND  PDS2,MEMBER,D          FIND BEFORE 1ST READ2      .FIX3.\n         B     PDS1EO2                SKIP DEC 13 2015 LOGIC.    .FIX3.\n*              POSSIBLE PROBLEM DISCOVERED DEC 13 2015.\n*              THERE MIGHT BE MORE DATA IN THE CURRENT READ2 BLOCK\n*              BETWEEN R8 AND R7. DOING A READ2 IS PREMATURE.\n*              THE READ2 COULD HIT EOF AND FALSELY INDICATE EQUAL.\n*              IF R8 < R7 THEN GO TO NOTEQUAL. ADDED CR AND BL.\n*              BUT THIS ONLY FIXES RECFM F. NEEDS MORE LOGIC.\nPDS1EO1  A     R8,LRECL            IF ANOTHER RECORD IN PDS2 BLK .FIX2.\n         CR    R8,R7                 THEN                        .FIX2.\n         BL    NOTEQUAL              NOT EQUAL                   .FIX2.\nPDS1EO2  EQU   *                                                 .FIX3.\n         BAL   R12,READ2           IF READ PDS2 HITS EOF TOO, EQUAL\n         B     NOTEQUAL\n\nPDS2EOF  EQU   *\n         CLI   PDS1DONE,C'Y'\n         BE    EQUAL\n         B     NOTEQUAL\n\nEQUAL    EQU   *\n         SR    R15,R15\n         B     EXIT\nNOTEQUAL EQU   *\n         LA    R15,4\nEXIT     REXIT\n\nREAD1    EQU   *\n         L     R5,PDS1DATA\n         READ  PDS1DECB,SF,PDS1,(R5),'S'\n         CHECK PDS1DECB\n         L     R14,PDS1DECB+16     FIGURE DATA LENGTH ACTUALLY READ\n         USING IHADCB,R3\n         LH    R4,DCBBLKSI\n         SH    R4,14(R14)\n         LA    R4,0(R4,R5)\n         BR    R12\n\nREAD2    EQU   *\n         MVI   PDS2READ,C'Y'       READ2 HAS BEEN CALLED AT LEAST ONCE\n         L     R8,PDS2DATA\n         READ  PDS2DECB,SF,PDS2,(R8),'S'\n         CHECK PDS2DECB\n         L     R14,PDS2DECB+16     FIGURE DATA LENGTH ACTUALLY READ\n         DROP  R3\n         USING IHADCB,R6\n         LH    R7,DCBBLKSI\n         SH    R7,14(R14)\n         LA    R7,0(R7,R8)\n         BR    R12\n\nCLOSEM   CLI   INITIAL,C'Y'\n         BE    EQUAL\n         MVI   INITIAL,C'Y'\n         L     R1,PDS1DATA\n         L     R0,PDSDATAL\n         FREEMAIN R,LV=(0),A=(1)\n         CLOSE (PDS1,,PDS2)\n         B     EQUAL\n\nFW4      DC    F'4'\nLRECL    DS    F\nMEMBER   DS    CL8\nINITIAL  DC    C'Y'\nPDS1DONE DC    C'N'\nPDS2READ DC    C'N'\nPDSDATAL DC    F'65536'\nPDSDATAH DC    F'32768'\nPDS1DATA DS    A\nPDS2DATA DS    A\nMBUF     DS    CL32\nRECFM1   DS    C\nRECFM2   DS    C\n         LTORG\n         PRINT NOGEN\nPDS1     DCB   DSORG=PO,MACRF=R,DDNAME=SYSLIB1,EODAD=PDS1EOF\nPDS2     DCB   DSORG=PO,MACRF=R,DDNAME=SYSLIB2,EODAD=PDS2EOF\n         DCBD  DSORG=(PO),DEVD=DA\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSMATCO": {"ttr": 32772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x04x\\x04x\\x00\\x00\\xd6\\xd3\\xc4\\xe5\\xc5\\xd9\\xe2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 1144, "newlines": 1144, "modlines": 0, "user": "OLDVERS"}, "text": "//-YOUR-USERID-M JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  ASSEMBLIES & LINK JCL FOR PDS MATCH / COMPARE PROGRAMS\n//***\n//A1         EXEC     PGM=ASMA90,REGION=4M,\n//             PARM='NODECK,OBJECT'\n//SYSLIB       DD       DISP=SHR,DSN=SYS1.MACLIB\n\n         TITLE '   P D S M A T C H   '\n***********************************************************************\n*          THIS PROGRAM COMPARES THE DIRECTORIES OF TWO PARTITIONED\n*          DATA SETS AND PRINTS A REPORT SHOWING WHICH MEMBERS\n*          MATCH AND WHICH MEMBERS DO NOT MATCH OR ARE NOT PRESENT\n*          IN BOTH DIRECTORIES.\n*\n*          MEMBERS ARE SAID TO MATCH IF THEIR NAMES ARE THE SAME.\n*          IF PARM=USER, IF ALL THE STATISTICS IN THEIR DIRECTORY\n*          ENTRIES ARE EQUAL (EXCEPT FIELDS CONTAINING TTR TRACK\n*          ADDRESSES). IF PARM=DATA, IF THEIR DATA ARE THE SAME.\n*\n*          DDNAMES.\n*             SYSPRINT - REPORT OUTPUT\n*             SYSLIB1  - PDS 1 INPUT\n*             SYSLIB2  - PDS 2 INPUT\n*\n*          IF PARM=EQO\n*             ONLY MEMBERS THAT MATCH WILL BE LISTED.\n*          IF PARM=NEO\n*             ONLY MEMBERS THAT DONT MATCH WILL BE LISTED.\n*          IF DEFAULTED\n*             ALL MEMBERS WILL BE LISTED FOR BOTH LIBRARIES.\n*          IF PARM=USER\n*             MEMBERS THAT ARE PRESENT IN BOTH LIBRARIES\n*             WILL BE COMPARED FOR MATCHING USERDATA.\n*             USERDATA CONSISTS OF UP TO 64 BYTES OF DATA\n*             IN THE DIRECTORY ENTRY WHICH IS PUT THERE BY\n*             THE LINKAGE EDITOR, SPF EDIT, AND OTHERS.\n*             NOTE. WITH PARM=USER,\n*             IF TWO MEMBERS HAVE THE SAME NAME AND NEITHER\n*             HAS ANY USERDATA, THEY ARE TREATED AS UNEQUAL,\n*             WITH A UNIQUE MESSAGE FOR THIS CASE.\n*          IF PARM=DATA\n*             MEMBERS THAT ARE PRESENT IN BOTH LIBRARIES\n*             WILL BE COMPARED FOR MATCHING DATA.\n*             IF TWO MEMBERS HAVE THE SAME NAME AND BOTH ARE\n*             EMPTY, THEY ARE TREATED AS UNEQUAL,\n*             WITH A UNIQUE MESSAGE FOR THIS CASE.\n***********************************************************************\n\n         MACRO\n         REGS  &PP=R\n         LCLA  &II\n&II      SETA  0\n.LOOP    ANOP\n&PP&II   EQU   &II\n&II      SETA  &II+1\n         AIF   (&II LT 16).LOOP\n         MEND\n\n         MACRO\n&NAME    RENTER  &BASEREG=R11,&SALEN=108,&REGS=YES\n         GBLC  &SASIZE\n&SASIZE  SETC  '&SALEN'\n.* THIS MACRO PROVIDES ENTRY CODE FOR A REENTRANT PROGRAM.\n.* THE DEFAULT BASE REGISTER IS 11 BUT MAY BE CHANGED VIA\n.* THE BASEREG PARAMETER.  THE SAVE AREA SIZE MAY BE SET\n.* THROUGH THE SALEN PARAMETER AND DEFAULTS TO 108.\n         AIF   ('&REGS' NE 'YES').NOREGS\n         REGS\n.NOREGS  ANOP\n&NAME    CSECT\n         STM   R14,R12,12(R13)     SAVE INCOMING REGS\n         LR    &BASEREG(1),R15     ESTABLISH ADDRESSABILITY\n&#BR     SETA  N'&BASEREG\n         AIF   (&#BR GT 1).MULTIRG\n         USING &NAME,&BASEREG\n         AGO   .OUTBASE\n.MULTIRG ANOP\n&#BRX    SETA  1\n&#BRY    SETA  2\n         LA    &BASEREG(&#BR),4095\n.LOADNXT LA    &BASEREG(&#BRY),1(&BASEREG(&#BRX),&BASEREG(&#BR))\n&#BRX    SETA  &#BRX+1\n&#BRY    SETA  &#BRY+1\n         AIF   (&#BRY LE &#BR).LOADNXT\n&BASELEN SETA  K'&BASEREG-2\n&BASES   SETC  '&BASEREG'(2,&BASELEN)\n         USING &NAME,&BASES\n.OUTBASE ANOP\n         LA    R0,&SASIZE          LOAD SAVE AREA SIZE FOR GETMAIN\n         STORAGE  OBTAIN,LENGTH=(0),LOC=BELOW\n         ST    R1,8(R13)           STORE ADDRESS OF NEW SAVE AREA\n         ST    R13,4(R1)           SAVE CALLERS SAVE AREA ADDRESS\n         LM    R0,R1,20(R13)       RELOAD R0 & R1\n         L     R13,8(R13)          LOAD NEW SAVE AREA ADDRESS INTO R13\n         MEND\n\n         MACRO\n&NAME    REXIT &RC15=YES\n         GBLC  &SASIZE\n&NAME    DS    0H\n         LA    R0,&SASIZE          LOAD SAVE AREA LENGTH FOR RELEASE\n         LR    R1,R13              LOAD SAVE AREA ADDRESS FOR RELEASE\n         L     R13,4(R13)          RESTORE CALLING SAVE AREA ADDRESS\n         AIF   ('&RC15' NE 'YES').NORETC\n         ST    R15,16(R13)         SAVE RETURN CODE\n.NORETC  ANOP\n         STORAGE  RELEASE,LENGTH=(0),ADDR=(1)\n         LM    R14,R12,12(R13)     RESTORE CALLING REGS R14 - R12\n         BR    R14\n         MEND\n\nPDSMATCH START\n         REGS\n         USING *,R10,R11\n         B     @PROLOG-*(,15)\n         DC    AL1(11),CL11'PDSMATCH'\n         DC    CL16' &SYSDATE &SYSTIME '\n@SIZE    DC    0F'0',AL1(1),AL3(@DATAL)\n@PROLOG  STM   14,12,12(R13)\n         LR    R10,15\n         LA    R15,1\n         LA    R11,4095(R15,R10)\n         LR    R4,R1               SAVE PARM POINTER\n         L     R0,@SIZE\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING @DATA,R13\n         SR    R15,R15\n         STH   R15,RC\n         STC   R15,STATUS\n         STC   R15,OPTIONS\n         MVC   DDNAMEP,=CL8'SYSPRINT'\n         MVC   DDNAME1,=CL8'SYSLIB1'\n         MVC   DDNAME2,=CL8'SYSLIB2'\n         MVI   LINE-1,C' '\n         MVC   LINE,LINE-1\n         MVI   MESG-1,C' '\n         ZAP   REPORTPG,=P'0'\n         ZAP   REPORTLN,=P'0'\n         ZAP   REPORTMX,=P'60'\n         MVI   REPORTO-1,C' '\n         MVI   JFCB1,C' '\n         MVC   JFCB1+1(175),JFCB1\n         MVC   JFCB2(176),JFCB1\n\n************************************************************\n*         OPEN THE PRINT FILE                              *\n************************************************************\n\n         MVC   PRTDCBW(PRTDCBL),PRTDCB\n         LA    R2,PRTDCBW\n         MVC   DDNAM(8,R2),DDNAMEP\n         MVI   OPEN,X'80'\n         OPEN  ((R2),OUTPUT),MF=(E,OPEN)\n         TM    OFLGS(R2),X'10'\n         BNO   EXIT12\n         OI    STATUS,PRTOPEN\n         B     PRTX\nPRTEXITO CLC   62(2,R1),=H'0'      IS BLKSIZE ZERO\n         BNE   0(R14)              NO\n         MVC   62(2,R1),82(R1)     YES - MAKE IT SAME AS LRECL\n         BR    R14\nPRTX     EQU   *\n\n************************************************************\n*         SCAN THE PARM FIELD                              *\n************************************************************\n\n*\n*               REGISTERS USED\n*                R14 - RETURN FROM PARSE\n*                R15 - ADDRESS OF REMAINING PARM DATA\n*                R0  - WORK\n*                R1  - USED BY TRT INSTRUCTION\n*                R2  - USED BY TRT INSTRUCTION\n*                R3  - LENGTH OF REMAINING PARM DATA MINUS 1\n*\n*               PARSE MUST NOT ALTER R0, R1, OR R3\n*\n         L     R15,0(,R4)          POINT TO PARM\n         LH    R3,0(,R15)          GET LENGTH OF PARM\n         LTR   R3,R3               IS THERE A PARM\n         BZ    PARMX               NO, BRANCH\n         LA    R15,2(,R15)         POINT TO PARM DATA\n\n         SR    R1,R1               INSURE HI ORDER BYTE ZERO\n         BCTR  R3,0                LENGTH CODE OF PARM DATA\n         B     *+16                SKIP EXECUTED INSTRUCTIONS\nTRTNONBL TRT   0(0,R15),TABNONBL   (EXECUTED)\nTRTBLANK TRT   0(0,R15),TABBLANK   (EXECUTED)\n*              NOTE: TRT CAN CHANGE 8 BITS OF R2 AND 24 BITS OF R1\nPARMLOOP EX    R3,TRTNONBL         FIND A NONBLANK\n         BZ    PARMX               BRANCH IF ALL BLANKS\n         LR    R0,R1               GET ADDRESS OF STRING\n         SR    R0,R15              GET LENGTH OF PRECEDING BLANKS\n         SR    R3,R0               GET LENGTH OF REMAINING TEXT\n         LR    R15,R1              GET ADDRESS OF NONBLANK\n         EX    R3,TRTBLANK         FIND A BLANK\n         BZ    PARMLAST            BRANCH IF NOT FOUND\n         LR    R0,R1               GET ADDRESS OF BLANK\n         SR    R0,R15              GET LENGTH OF FIELD\n         BAL   R14,PARSE\n         SR    R3,R0               GET LENGTH CODE OF REMAINING TEXT\n         BZ    PARMX               BRANCH IF ONE TRAILING BLANK\n         LR    R15,R1              POINT TO BLANK\n         B     PARMLOOP\nPARMLAST LA    R0,1(,R3)           GET LENGTH\n         BAL   R14,PARSE\n         B     PARMX\n\n************************************************************\n*         PROCESS EACH PARM KEYWORD                        *\n************************************************************\n\nPARSE    STM   R14,R1,PARSES       SAVE REGS\n         CH    R0,=H'4'            IS KEYWORD LENGTH 4\n         BNE   PARSL4X             NO, BRANCH\n         CLC   0(4,R15),=C'USER'\n         BNE   *+12\n         OI    OPTIONS,OPTUSER\n         B     PARSX\n         CLC   0(4,R15),=C'DATA'\n         BNE   PARSL4X\n         OI    OPTIONS,OPTDATA\n         B     PARSX\nPARSL4X  EQU   *\n         CH    R0,=H'3'            IS KEYWORD LENGTH 3\n         BNE   PARSL3X             NO, BRANCH\n         CLC   0(3,R15),=C'EQO'    EQONLY\n         BNE   *+8\n         OI    OPTIONS,OPTEQO\n         CLC   0(3,R15),=C'NEO'    NEONLY\n         BNE   *+8\n         OI    OPTIONS,OPTNEO\n         B     PARSX\nPARSL3X  EQU   *\nPARSX    LM    R14,R1,PARSES\n         BR    R14\n\nPARMX    EQU   *\n\n************************************************************\n*         SHOW CRITERIA                                    *\n************************************************************\n\n         TM    OPTIONS,OPTUSER\n         BO    PRTCRI2\n         TM    OPTIONS,OPTDATA\n         BO    PRTCRI3\n         LA    R1,MSGCRI1A\n         LA    R0,L'MSGCRI1A\n         BAL   R14,PRTMSG\n         LA    R1,MSGCRI1B\n         LA    R0,L'MSGCRI1B\n         BAL   R14,PRTMSG\n         B     PRTCRIX\nPRTCRI2  LA    R1,MSGCRI2A\n         LA    R0,L'MSGCRI2A\n         BAL   R14,PRTMSG\n         LA    R1,MSGCRI2B\n         LA    R0,L'MSGCRI2B\n         BAL   R14,PRTMSG\n         B     PRTCRIX\nPRTCRI3  LA    R1,MSGCRI3A\n         LA    R0,L'MSGCRI3A\n         BAL   R14,PRTMSG\n         LA    R1,MSGCRI3B\n         LA    R0,L'MSGCRI3B\n         BAL   R14,PRTMSG\nPRTCRIX  LA    R1,=C' '\n         LA    R0,1\n         BAL   R14,PRTMSG\n\n************************************************************\n*         OPEN THE FIRST PDS                               *\n************************************************************\n\n         MVC   DIRDCBW(DIRDCBL),DIRDCB\n         LA    R2,DIRDCBW          ADDRESS OF DCB\n         MVC   DDNAM(8,R2),DDNAME1 CHANGE THE DDNAME\n         LA    R3,DDNAM(,R2)       POINT TO DDNAME FOR DEVTYPE\n         DEVTYPE (R3),DEVAREA\n         LTR   R15,R15             IS DDNAME ALLOCATED\n         BNZ   EXIT12              NO, BRANCH\n\n         LA    R1,DIREXLST         PUT EXLST\n         IC    R0,EXLST(,R2)        ADDRESS\n         ST    R1,EXLST(,R2)         IN\n         STC   R0,EXLST(,R2)          DCB\n         LA    R0,JFCB1            PUT JFCB ADDRESS\n         ST    R0,0(,R1)            IN EXLST\n         MVI   0(R1),X'87'           AND INDICATE EXLST ENTRY TYPE\n         MVI   RDJFCB,X'80'\n         RDJFCB ((R2)),MF=(E,RDJFCB)\n\n         MVI   OPEN,X'80'\n         OPEN  ((R2),INPUT),MF=(E,OPEN)\n         TM    OFLGS(R2),X'10'\n         BNO   EXIT12\n         OI    STATUS,DIROPEN\n\n         MVC   LINE,LINE-1         BLANK LINE\n         MVC   LINE+1(10),=C'LIBRARY1 -'\n         LA    R15,LINE+12\n         MVC   0(44,R15),JFCB1\n         LA    R15,44(,R15)\nAPPENDV1 CLI   0(R15),C' '\n         BNE   *+8\n         BCT   R15,APPENDV1\n         MVC   2(2,R15),=C'ON'\n         MVC   5(6,R15),JFCB1+118  VOLUME SERIAL\n         BAL   R14,REPORTL         PUT HEADING LIBRARY1 DSN\n\n         L     R0,DIRSIZE\n         GETMAIN R,LV=(0)\n         ST    R1,DIRFREE          SAVE FOR FREEMAIN\n         LR    R3,R1\n         ST    R3,DIRPTR1          SAVE FOR WALKING THRU DIR 1\n         OI    STATUS,GOTMAIN\n         MVC   DIRDECBW(DIRDECBL),DIRDECB\n         MVI   DIRSW,0\n         BAL   R8,DIRIN\n         CLOSE ((R2)),MF=(E,OPEN)\n         NI    STATUS,255-DIROPEN\n         TM    DIRSW,1             WAS DIRECTORY VALID\n         BZ    EXIT12              NO, QUIT\n         LA    R3,256(,R3)         SET START OF SECOND DIRECTORY\n         ST    R3,DIRPTR2          SAVE FOR WALKING THRU DIR 2\n\n************************************************************\n*         OPEN THE SECOND PDS                              *\n************************************************************\n\n         MVC   DIRDCBW(DIRDCBL),DIRDCB\n         LA    R2,DIRDCBW          ADDRESS OF DCB\n         MVC   DDNAM(8,R2),DDNAME2 CHANGE THE DDNAME\n         LA    R3,DDNAM(,R2)       POINT TO DDNAME FOR DEVTYPE\n         DEVTYPE (R3),DEVAREA\n         LTR   R15,R15             IS DDNAME ALLOCATED\n         BNZ   EXIT12              NO, BRANCH\n\n         LA    R1,DIREXLST         PUT EXLST\n         IC    R0,EXLST(,R2)        ADDRESS\n         ST    R1,EXLST(,R2)         IN\n         STC   R0,EXLST(,R2)          DCB\n         LA    R0,JFCB2            PUT JFCB ADDRESS\n         ST    R0,0(,R1)            IN EXLST\n         MVI   0(R1),X'87'           AND INDICATE EXLST ENTRY TYPE\n         MVI   RDJFCB,X'80'\n         RDJFCB ((R2)),MF=(E,RDJFCB)\n\n         MVI   OPEN,X'80'\n         OPEN  ((R2),INPUT),MF=(E,OPEN)\n         TM    OFLGS(R2),X'10'\n         BNO   EXIT12\n         OI    STATUS,DIROPEN\n\n         MVC   LINE,LINE-1         BLANK LINE\n         MVC   LINE+1(10),=C'LIBRARY2 -'\n         LA    R15,LINE+12\n         MVC   0(44,R15),JFCB2\n         LA    R15,44(,R15)\nAPPENDV2 CLI   0(R15),C' '\n         BNE   *+8\n         BCT   R15,APPENDV2\n         MVC   2(2,R15),=C'ON'\n         MVC   5(6,R15),JFCB2+118  VOLUME SERIAL\n         BAL   R14,REPORTL         PUT HEADING LIBRARY2 DSN\n         MVC   LINE,LINE-1         BLANK LINE\n         BAL   R14,REPORTL         PUT HEADING BLANK LINE\n\n         L     R3,DIRPTR2\n         MVC   DIRDECBW(DIRDECBL),DIRDECB\n         MVI   DIRSW,0\n         BAL   R8,DIRIN\n         CLOSE ((R2)),MF=(E,OPEN)\n         NI    STATUS,255-DIROPEN\n         TM    DIRSW,1             WAS DIRECTORY VALID\n         BZ    EXIT12              NO, QUIT\n         B     COMPARE\n\n************************************************************\n*         READ THE DIRECTORY INTO STORAGE                  *\n************************************************************\n\nDIRIN    XC    DIRBLKS,DIRBLKS\n         XC    DIRBLKSU,DIRBLKSU\n         XC    MEMBERS,MEMBERS\n         XC    ALIASES,ALIASES\n\n         B     *+8\nDIRREAD  LA    R3,256(,R3)\n         READ  DIRDECBW,SF,(R2),(R3),256,MF=E\n         CHECK DIRDECBW\n         TM    DIRSW,2             I/O ERROR\n         BO    DIRERR              YES, BRANCH\n         LA    R1,1\n         A     R1,DIRBLKS\n         ST    R1,DIRBLKS\n*        TM    DIRSW,1             ARE WE PAST USED BLOCKS\n*        BO    DIRREAD             YES, BRANCH\n         LR    R1,R3               POINT TO DATA JUST READ\n         LH    R0,0(,R1)           GET NUMBER OF BYTES IN USE\n         LTR   R0,R0               IS THIS NEGATIVE\n         BM    DIRINV              YES, NOT A DIRECTORY BLOCK\n         CH    R0,=H'256'          IS THIS TOO LARGE\n         BH    DIRINV              YES, NOT A DIRECTORY BLOCK\n         AR    R0,R1               POINT PAST LAST BYTE\n         LA    R1,2(,R1)           POINT TO FIRST MEMBER\nDIRENTRY CLC   0(8,R1),=8X'FF'     END OF MEMBERS\n         BE    DIRUSED\n         TM    11(R1),X'80'        ALIAS\n         BO    DIRALIAS\n         LA    R15,1               COUNT NON-ALIAS MEMBERS\n         A     R15,MEMBERS\n         ST    R15,MEMBERS\n         B     DIRNEXT\nDIRALIAS LA    R15,1               COUNT ALIAS MEMBERS\n         A     R15,ALIASES\n         ST    R15,ALIASES\nDIRNEXT  SLR   R15,R15\n         IC    R15,11(,R1)\n         N     R15,=F'31'          SET OFF ALL BUT LAST 5 BITS\n         SLL   R15,1               CHANGE HALFWORDS TO BYTES\n         LA    R1,12(R15,R1)       POINT PAST USER DATA\n         CR    R1,R0               END OF BLOCK\n         BL    DIRENTRY            NO, BRANCH\n         B     DIRREAD             YES, READ NEXT BLOCK\nDIRUSED  EQU   *\n         OI    DIRSW,1             STOP COUNTING MEMBERS\n         MVC   DIRBLKSU,DIRBLKS    SAVE NUMBER OF USED BLOCKS\n*        B     DIRREAD             GO COUNT UNUSED BLOCKS\n         B     DIREND\n\nDIRSYN   EQU   *\n         SYNADAF ACSMETH=BSAM\n         MVC   MESSAGE(72),50(R1)\n         OI    DIRSW,2\n         SYNADRLS\n         BR    R14\nDIRINV   LA    R1,MSGINV\n         LA    R0,L'MSGINV\n         BAL   R14,PRTMSG\n         OI    DIRSW,4\n         B     DIREND\nDIRERR   LA    R1,MESSAGE\n         LA    R0,72\n         BAL   R14,PRTMSG\n         OI    DIRSW,4\n         B     DIREND\nDIREOF   LA    R1,MSGEOF\n         LA    R0,L'MSGEOF\n         BAL   R14,PRTMSG\n         OI    DIRSW,4\nDIREND   EQU   *\n         BR    R8\n\n************************************************************\n*         COMPARE ROUTINE                                  *\n************************************************************\n\nCOMPARE  EQU   *\n         L     R1,DIRPTR1          POINT TO FIRST BLOCK OF PDS1\n         ST    R1,PDSWORK1+8\n         LH    R0,0(,R1)           GET NUMBER OF BYTES IN USE\n         AR    R0,R1               POINT PAST LAST BYTE\n         LA    R1,2(,R1)           POINT TO FIRST MEMBER\n         LA    R2,PDSWORK1\n         BAL   R8,GETMEM1          GET FIRST MEMBER\n\n         L     R1,DIRPTR2          POINT TO FIRST BLOCK OF PDS2\n         ST    R1,PDSWORK2+8\n         LH    R0,0(,R1)           GET NUMBER OF BYTES IN USE\n         AR    R0,R1               POINT PAST LAST BYTE\n         LA    R1,2(,R1)           POINT TO FIRST MEMBER\n         LA    R2,PDSWORK2\n         BAL   R8,GETMEM1          GET FIRST MEMBER\n\n************************************************************\n*         READY TO COMPARE                                 *\n************************************************************\n\n         LA    R3,PDSWORK1\n         LA    R4,PDSWORK2\nREADY    CLC   20(8,R3),20(R4)\n         BL    SHOW1\n         BH    SHOW2\n         CLC   20(8,R3),=8X'FF'\n         BE    DONE\n\n************************************************************\n*         MEMBER EXISTS IN BOTH LIBRARIES                  *\n************************************************************\n\n         MVC   LINE,LINE-1\n         MVC   LINE+01(8),20(R3)\n         MVC   COMPMEM,20(R3)\n         MVC   LINE+22(8),20(R4)\n         TM    OPTIONS,OPTUSER    ARE WE COMPARING USERDATA\n         BZ    DATAOPTN           NO, CHECK FOR DATA OPTION\n         CLC   19(73,R3),19(R4)   IS USERDATA THE SAME\n         BE    SAME               YES, BRANCH\n         MVC   LINE+10(11),=C' ********* '\n         MVC   LINE+32(25),=C'NON-SPF USER DATA UNEQUAL'\n*              SEE IF BOTH ARE SPF STATS.\n*              IF BOTH ARE SPF STATS, SHOW WHICH IS MORE RECENT\n         TM    12(R3),SPFFLAG      IS USERDATA SPF\n         BNO   DIFF1               NO, BRANCH\n         TM    12(R4),SPFFLAG      IS USERDATA SPF\n         BNO   DIFF2               NO, BRANCH\n         CLC   28+8(6,R3),28+8(R4) COMPARE YY.DDD HH.MM LAST UPDATED\n         BH    RECENT1\n         BL    RECENT2\n         MVC   LINE+10(11),=C' ********* '\n         MVC   LINE+32(32),=C'SPF STATS DIFFER BUT NOT IN DATE'\n         B     MATCHP\nDIFF1    TM    12(R4),SPFFLAG      IS USERDATA SPF\n         BNO   MATCHP              NO - NEITHER MEMBER IS SPF\n         MVC   LINE+32(27),=C'ONLY LIBRARY2 HAS SPF STATS'\n         B     MATCHP\nDIFF2    MVC   LINE+32(27),=C'ONLY LIBRARY1 HAS SPF STATS'\n         B     MATCHP\nRECENT1  MVC   LINE+10(11),=C' <-- NEWER '\n         MVC   LINE+32(25),=C'LIBRARY1 IS MORE RECENT  '\n         B     MATCHP\nRECENT2  MVC   LINE+10(11),=C' NEWER --> '\n         MVC   LINE+32(25),=C'LIBRARY2 IS MORE RECENT  '\n         B     MATCHP\nDATAOPTN TM    OPTIONS,OPTDATA    ARE WE COMPARING REAL DATA\n         BZ    MATCHP             NO, GO ON WITH OTHER MEMBERS\n         CALL  PDSCOMP,COMPMEM,VL\n         LTR   R15,R15\n         BZ    MATCHP\nUNEQUAL  MVC   LINE+10(11),=C' <UNEQUAL> '\n         MVC   LINE+32(25),=C'LIBRARY DATA IS NOT SAME '\n         B     MATCHP             GO ON WITH OTHER MEMBERS\n\n************************************************************\n*         DIRECTORY DATA MATCHES                           *\n************************************************************\n\nSAME     CLI   15(R3),0           ZERO USERDATA IN BOTH\n         BNE   SAME2              NO, BRANCH\n         MVC   LINE+10(11),=C' ********* '\n         MVC   LINE+32(27),=C'NEITHER MEMBER HAS USERDATA'\n         B     MATCHP\nSAME2    TM    12(R3),SPFFLAG     SPF STATS IN BOTH\n         BO    MATCHP             YES - OMIT MESSAGE\n         MVC   LINE+10(11),=C' ********* '\n         MVC   LINE+32(23),=C'NON-SPF USER DATA EQUAL'\nMATCHP   CLI   LINE+32,C' '        IS THIS A MATCH\n         BNE   MATCHNE             NO, BRANCH\n         TM    OPTIONS,OPTNEO     ARE WE PRINTING .NE. ONLY\n         BO    MATCHX             YES, DONT PRINT THESE\n         B     MATCHPR\nMATCHNE  TM    OPTIONS,OPTEQO     ARE WE PRINTING .EQ. ONLY\n         BO    MATCHX             YES, DONT PRINT THESE\nMATCHPR  BAL   R14,REPORTL\nMATCHX   LR    R2,R3\n         BAL   R8,GETMEM\n         LR    R2,R4\n         BAL   R8,GETMEM\n         B     READY\n\n************************************************************\n*         MEMBER EXISTS ONLY IN LIBRARY 1                  *\n************************************************************\n\nSHOW1    TM    OPTIONS,OPTEQO     ARE WE PRINTING .EQ. ONLY\n         BO    SHOW1X             YES, DONT PRINT THESE\n         MVC   LINE,LINE-1\n         MVC   LINE+01(8),20(R3)\n         MVC   LINE+32(23),=C'MEMBER IN LIBRARY1 ONLY'\n         BAL   R14,REPORTL\nSHOW1X   LR    R2,R3\n         BAL   R8,GETMEM\n         B     READY\n\n************************************************************\n*         MEMBER EXISTS ONLY IN LIBRARY 2                  *\n************************************************************\n\nSHOW2    TM    OPTIONS,OPTEQO     ARE WE PRINTING .EQ. ONLY\n         BO    SHOW2X             YES, DONT PRINT THESE\n         MVC   LINE,LINE-1\n         MVC   LINE+22(8),20(R4)\n         MVC   LINE+32(23),=C'MEMBER IN LIBRARY2 ONLY'\n         BAL   R14,REPORTL\nSHOW2X   LR    R2,R4\n         BAL   R8,GETMEM\n         B     READY\n\n************************************************************\n*         END OF BOTH DIRECTORIES                          *\n************************************************************\n\nDONE     B     EXIT\n\n************************************************************\n*         SUBROUTINE TO GET NEXT MEMBER FROM DIRECTORY     *\n************************************************************\n\nGETMEM   LM    R0,R1,0(R2)\n         CLC   0(8,R1),=8X'FF'     END OF MEMBERS\n         BE    GETEOF\nGET1R    SLR   R15,R15\n         IC    R15,11(,R1)\n         N     R15,=F'31'          SET OFF ALL BUT LAST 5 BITS\n         SLL   R15,1               CHANGE HALFWORDS TO BYTES\n         LA    R1,12(R15,R1)       POINT PAST USER DATA\n         CR    R1,R0               END OF BLOCK\n         BL    GETMEM1             NO, BRANCH\n         LA    R1,256              YES, READ NEXT BLOCK\n         A     R1,8(,R2)           YES, READ NEXT BLOCK\n         ST    R1,8(,R2)           YES, READ NEXT BLOCK\n         LH    R0,0(,R1)           GET NUMBER OF BYTES IN USE\n         AR    R0,R1               POINT PAST LAST BYTE\n         LA    R1,2(,R1)           POINT TO FIRST MEMBER\n*        B     GET1R\nGETMEM1  STM   R0,R1,0(R2)\n         MVC   20(8,R2),0(R1)      SAVE MEMBER NAME\n         CLC   0(8,R1),=8X'FF'     END OF MEMBERS\n         BE    GETEOF\n         MVC   16(4,R2),8(R1)      SAVE TTR, ALIAS BIT, ETC\n         XC    28(64,R2),28(R2)    ZERO USER DATA AREA\n*              COPY USER DATA\n         SLR   R15,R15\n         IC    R15,11(,R1)\n         N     R15,=F'31'          SET OFF ALL BUT LAST 5 BITS\n         SLL   R15,1               CHANGE HALFWORDS TO BYTES\n         ST    R15,12(,R2)         SAVE LENGTH OF USER DATA\n         LTR   R15,R15\n         BZ    GETZERO\n         TM    OPTIONS,OPTUSER     IS USERDATA TO BE COMPARED\n         BZ    GETZERO             NO, BRANCH\n         CLI   15(R2),30           IS LENGTH 30\n         BNE   *+8                 NO\n         OI    12(R2),SPFFLAG      YES, INDICATE IT MAY BE SPF STATS\n         BCTR  R15,0               LENGTH MINUS 1 FOR EX\n         B     *+10\n         MVC   28(0,R2),12(R1)     EXECUTED\n         EX    R15,*-6             MOVE THE USER DATA\n         TM    11(R1),B'01100000'  ANY TTR'S IN THE USER DATA\n         BZ    GETZERO             NO, BRANCH\n         NI    12(R2),255-SPFFLAG  YES, CAN'T BE SPF\n         IC    R15,11(,R1)         YES, PREPARE TO ZERO THEM\n         N     R15,=A(X'0000007F') SET OFF ALIAS BIT\n         SRL   R15,5               SHIFT OUT RIGHT 5 BITS\n         LA    R14,28(,R2)         POINT TO FIRST TTR IN USER DATA\nGETUTTR  XC    0(3,R14),0(R14)     ZERO THE TTR IN THE USER DATA\n         LA    R14,4(,R14)         POINT TO NEXT TTR IN THE USER DATA\n         BCT   R15,GETUTTR         REPEAT UNTIL R15 ZERO\nGETZERO  EQU   *\nGETEOF   BR    R8\n\n************************************************************\n*         MESSAGE ROUTINE                                  *\n************************************************************\n\nPRTMSG   STM   R14,R1,PRTMSGS\n         MVC   MESG,MESG-1\n         LR    R15,R0\n         BCTR  R15,0\n         B     *+10\n         MVC   MESG+1(0),0(R1)\n         EX    R15,*-6\n         LA    R1,MESG\n         LA    R0,L'MESG\n         BAL   R14,REPORT\n         LM    R14,R1,PRTMSGS\n         BR    R14\n\n************************************************************\n*         REPORT WRITER                                    *\n************************************************************\n\nREPORTL  LA    R1,LINE\n         LA    R0,121\nREPORT   STM   R14,R3,REPORTS\n         LA    R3,PRTDCBW          POINT R3 TO DCB\n         CP    REPORTLN,REPORTMX   IS LINECOUNT LIMIT REACHED\n         BL    *+10                NO\n         ZAP   REPORTLN,=P'0'      YES, FORCE NEW PAGE\n         CP    REPORTLN,=P'0'      IS NEW PAGE REQUESTED?\n         BE    REPORTH             YES, GO PRINT HEADING\nREPORTD  CH    R0,=H'121'          IS OUTPUT LINE LENGTH OK?\n         BNL   REPORTP             YES, BRANCH\n         MVC   REPORTO,REPORTO-1   BLANK THE WORK AREA\n         LTR   R14,R0              COPY LENGTH\n         BNP   REPORTB             BLANK LINE IF < 1\n         BCTR  R14,0               LENGTH MINUS 1\n         B     *+10\n         MVC   REPORTO(0),0(R1)    COPY OUTPUT LINE\n         EX    R14,*-6             EXECUTE MVC\nREPORTB  LA    R1,REPORTO          POINT TO NEW OUTPUT LINE\nREPORTP  LR    R2,R1               POINT R2 TO OUTPUT LINE\n         PUT   (R3),(R2)           WRITE OUTPUT LINE\n         AP    REPORTLN,=P'1'      INCREMENT LINE COUNTER\nREPORTX  LM    R14,R3,REPORTS      RESTORE REGS\n         BR    R14                 RETURN\nREPORTH  AP    REPORTPG,=P'1'      INCREMENT PAGE COUNTER\n         MVC   REPORTO,REPORTO-1   BLANK HEADING\n         MVI   REPORTO,C'1'        CC = NEW PAGE\n         MVC   REPORTO+1(L'HEAD1),HEAD1\n         LA    R1,REPORTO+79-9     RIGHT EDGE PAGE NO\n         MVC   3(6,R1),=X'402020202020' EDIT MASK\n         ED    3(6,R1),REPORTPG    UNPACK PAGE NO\n         MVC   0(4,R1),=C'PAGE'    INSERT 'PAGE'\n         PUT   (R3),REPORTO        PUT HEADING LINE 1\n         MVC   REPORTO,REPORTO-1   BLANK LINE\n         PUT   (R3),REPORTO        PUT HEADING BLANK LINE\n         AP    REPORTLN,=P'2'      COUNT HEADING LINES\nREPORTHX LM    R0,R1,REPORTS+8     RESTORE R0 AND R1\n         B     REPORTD             GO PRINT DETAIL LINE\n         EJECT\n************************************************************\n*         TERMINATION                                      *\n************************************************************\n\nEXIT12   MVI   RC+1,12\nEXIT     EQU   *\n         TM    STATUS,GOTMAIN      IS DIRECTORY AREA GOTTEN\n         BZ    EXITGOTX            NO, BYPASS FREEMAIN\n         L     R0,DIRSIZE\n         L     R1,DIRFREE\n         FREEMAIN R,LV=(0),A=(1)\nEXITGOTX EQU   *\n         TM    STATUS,PRTOPEN      IS SYSPRINT OPEN\n         BZ    EXITPRTX            NO - BYPASS CLOSE\n         LA    R2,PRTDCBW\n         MVI   CLOSE,X'80'\n         CLOSE ((R2)),MF=(E,CLOSE)\n         FREEPOOL (R2)\nEXITPRTX EQU   *\n         LH    R15,RC\n         LR    R1,R13\n         L     R0,@SIZE\n         L     R13,4(,R13)\n         LR    R2,R15\n         FREEMAIN R,A=(1),LV=(0)\n         LR    R15,R2\n         LM    0,12,20(R13)\n         L     R14,12(,R13)\n         BR    R14\n\n************************************************************\n*        CONSTANTS                                         *\n************************************************************\n\n         LTORG\nHEAD1    DC    C'--- PDSMATCH --- PDS DIRECTORY COMPARE UTILITY ---'\nDIRSIZE  DC    0F'0',AL1(1),AL3(128*1024)  128K FOR 2 DIRECTORIES\nYMDNY    DC    AL2(334,304,273,243)\n         DC    AL2(212,181,151,120)\n         DC    AL2(90,59,31,0)\nYMDLY    DC    AL2(335,305,274,244)\n         DC    AL2(213,182,152,121)\n         DC    AL2(91,60,31,0)\n         PRINT NOGEN\nPRTDCB   DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,                      +\n               RECFM=FBA,LRECL=121,EXLST=PRTEXLST\nPRTDCBL  EQU   *-PRTDCB\n\nDIRDCB   DCB   DDNAME=DYNAM,DSORG=PO,MACRF=R,EODAD=DIREOF,SYNAD=DIRSYN,X\n               RECFM=U,BLKSIZE=256\nDIRDCBL  EQU   *-DIRDCB\n\n         PRINT GEN\nPRTEXLST DC    0F'0',X'85',AL3(PRTEXITO)\nDIRREADM READ  DIRDECB,SF,MF=L\nDIRDECBL EQU   *-DIRDECB\n         PRINT GEN\nHEXTAB   DC    C'0123456789ABCDEF'\nMSGINV   DC    C'INVALID DIRECTORY BLOCK'\nMSGEOF   DC    C'NO END-OF-DIRECTORY INDICATOR FOUND'\nMSGCRI1A DC    C'CRITERIA FOR MATCHING IS MEMBER NAME ONLY.  USERDATA I+\n               N THE DIRECTORY'\nMSGCRI1B DC    C'(SUCH AS SPF STATISTICS, LOAD ATTRIBUTES) IS NOT COMPA+\n               RED.'\nMSGCRI2A DC    C'CRITERIA FOR MATCHING IS MEMBER NAME AND ALL USERDATA +\n               IN THE DIRECTORY'\nMSGCRI2B DC    C'(SUCH AS SPF STATISTICS, LOAD ATTRIBUTES) EXCEPT TTR F+\n               IELDS.'\nMSGCRI3A DC    C'CRITERIA FOR MATCHING IS MEMBER NAME AND THE ACTUAL ME+\n               MBER DATA'\nMSGCRI3B DC    C'(SPF STATISTICS ARE NOT COMPARED).'\n         DC    0D'0'\nTABNONBL DC    64X'FF'\n         DC    X'00'               BLANK\n         DC    42X'FF'\n         DC    X'00'               COMMA\n         DC    148X'FF'\nTABBLANK DC    64X'00'\n         DC    X'40'               BLANK\n         DC    42X'00'\n         DC    X'6B'               COMMA\n         DC    148X'00'\n         DC    0D'0'\nEODAD    EQU   32\nRECFM    EQU   36\nEXLST    EQU   36\nDDNAM    EQU   40\nOFLGS    EQU   48\nSYNAD    EQU   56\nBLKSI    EQU   62\nLRECL    EQU   82\n         DC    0D'0'\nCOMPMEM  DS    CL08\n\n************************************************************\n*        DSECTS                                            *\n************************************************************\n\n@DATA    DSECT\n         DS    18F                 REGISTER SAVEAREA\nDOUBLE   DS    D\nHALF     EQU   DOUBLE,2\nFULL     EQU   DOUBLE,4\nDDNAMEP  DS    CL8\nDDNAME1  DS    CL8\nDDNAME2  DS    CL8\nRC       DS    H\nSTATUS   DS    X\nPRTOPEN  EQU   X'80'\nDIROPEN  EQU   X'40'\nGOTMAIN  EQU   X'20'\nOPTIONS  DS    X\nOPTUSER  EQU   X'80'\nOPTEQO   EQU   X'40'\nOPTNEO   EQU   X'20'\nOPTDATA  EQU   X'10'\nDIRFREE  DS    F\nDIRPTR1  DS    F\nDIRPTR2  DS    F\nDIRSW    DS    F\nDIRBLKS  DS    F\nDIRBLKSU DS    F\nMEMBERS  DS    F\nALIASES  DS    F\nPRTDCBW  DS    0F,(PRTDCBL)X\nDIRDCBW  DS    0F,(DIRDCBL)X\nDIRDECBW DS    0F,(DIRDECBL)X\nDIREXLST DS    F\nDEVAREA  DS    2F\nCLOSE    DS    0F\nOPEN     DS    F\nRDJFCB   DS    F\nPARSES   DS    6F\nREPORTS  DS    6F\nREPORTPG DS    PL3\nREPORTLN DS    PL2\nREPORTMX DS    PL2\nPRTMSGS  DS    4F\nPDSWORK1 DS    3F\n         DS    F                   USER DATA LENGTH\nSPFFLAG  EQU   X'80'               USER DATA CONTAINS SPF STATISTICS\n         DS    XL3                 TTR\n         DS    X                   ALIAS BIT AND USER DATA LENGTH\n         DS    CL8                 MEMBER NAME\n         DS    CL64                USER DATA\nPDSWORK2 DS    3F\n         DS    F                   USER DATA LENGTH\n         DS    XL3                 TTR\n         DS    X                   ALIAS BIT AND USER DATA LENGTH\n         DS    CL8                 MEMBER NAME\n         DS    CL64                USER DATA\nLINEB    DS    C  (LINE-1)\nLINE     DS    CL133\nMESGB    DS    C  (MESG-1)\nMESG     DS    CL133\nMESSAGE  DS    CL72\nREPORTOB DS    C (REPORTO-1)\nREPORTO  DS    CL133\nJFCB1    DS    0D,CL176\nJFCB2    DS    0D,CL176\n         DS    0D\n@DATAL   EQU   *-@DATA\n\n         END\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//***\n//A2         EXEC     PGM=ASMA90,REGION=4M,COND=(5,LT),\n//             PARM='NODECK,OBJECT'\n//SYSLIB       DD       DISP=SHR,DSN=SYS1.MACLIB\n         MACRO\n&NAME    RENTER  &BASEREG=R11,&SALEN=108,&REGS=YES\n         GBLC  &SASIZE\n&SASIZE  SETC  '&SALEN'\n.* THIS MACRO PROVIDES ENTRY CODE FOR A REENTRANT PROGRAM.\n.* THE DEFAULT BASE REGISTER IS 11 BUT MAY BE CHANGED VIA\n.* THE BASEREG PARAMETER.  THE SAVE AREA SIZE MAY BE SET\n.* THROUGH THE SALEN PARAMETER AND DEFAULTS TO 108.\n         AIF   ('&REGS' NE 'YES').NOREGS\n         REGS\n.NOREGS  ANOP\n&NAME    CSECT\n         STM   R14,R12,12(R13)     SAVE INCOMING REGS\n         LR    &BASEREG(1),R15     ESTABLISH ADDRESSABILITY\n&#BR     SETA  N'&BASEREG\n         AIF   (&#BR GT 1).MULTIRG\n         USING &NAME,&BASEREG\n         AGO   .OUTBASE\n.MULTIRG ANOP\n&#BRX    SETA  1\n&#BRY    SETA  2\n         LA    &BASEREG(&#BR),4095\n.LOADNXT LA    &BASEREG(&#BRY),1(&BASEREG(&#BRX),&BASEREG(&#BR))\n&#BRX    SETA  &#BRX+1\n&#BRY    SETA  &#BRY+1\n         AIF   (&#BRY LE &#BR).LOADNXT\n&BASELEN SETA  K'&BASEREG-2\n&BASES   SETC  '&BASEREG'(2,&BASELEN)\n         USING &NAME,&BASES\n.OUTBASE ANOP\n         LA    R0,&SASIZE          LOAD SAVE AREA SIZE FOR GETMAIN\n         STORAGE  OBTAIN,LENGTH=(0),LOC=BELOW\n         ST    R1,8(R13)           STORE ADDRESS OF NEW SAVE AREA\n         ST    R13,4(R1)           SAVE CALLERS SAVE AREA ADDRESS\n         LM    R0,R1,20(R13)       RELOAD R0 & R1\n         L     R13,8(R13)          LOAD NEW SAVE AREA ADDRESS INTO R13\n         MEND\n         MACRO\n         REGS  &PP=R\n         LCLA  &II\n&II      SETA  0\n.LOOP    ANOP\n&PP&II   EQU   &II\n&II      SETA  &II+1\n         AIF   (&II LT 16).LOOP\n         MEND\n         MACRO\n&NAME    REXIT &RC15=YES\n         GBLC  &SASIZE\n&NAME    DS    0H\n         LA    R0,&SASIZE          LOAD SAVE AREA LENGTH FOR RELEASE\n         LR    R1,R13              LOAD SAVE AREA ADDRESS FOR RELEASE\n         L     R13,4(R13)          RESTORE CALLING SAVE AREA ADDRESS\n         AIF   ('&RC15' NE 'YES').NORETC\n         ST    R15,16(R13)         SAVE RETURN CODE\n.NORETC  ANOP\n         STORAGE  RELEASE,LENGTH=(0),ADDR=(1)\n         LM    R14,R12,12(R13)     RESTORE CALLING REGS R14 - R12\n         BR    R14\n         MEND\nPDSCOMP  RENTER\n\n*  R0\n*  R1    SHORT TERM WORK REG\n*  R2\n*  R3    PDS 1 DCB\n*  R4    PDS 1 DATA READ/1 PAST\n*  R5    PDS 1 DATA POINTER\n*  R6    PDS 2 DCB\n*  R7    PDS 2 DATA READ/1 PAST\n*  R8    PDS 2 DATA POINTER\n*  R9\n*  R10\n*  R11   BASE\n*  R12   SUBROUTINE RETURN\n*  R13   SAVEAREA\n*  R14   SHORT TERM WORK REG\n*  R15   SHORT TERM WORK REG\n\n         L     R14,0(R1)           GET MEMBER NAME\n         MVC   MEMBER,0(R14)\n\n         CLI   INITIAL,C'Y'        FIRST TIME THROUGH?\n         BNE   NOTFIRST            IF NOT, DON'T DO BASIC STUFF AGAIN\n\n         MVI   INITIAL,C'N'        FIRST TIME THROUGH ONLY\n         OPEN  (PDS1,,PDS2)\n         L     R0,PDSDATAL\n         STORAGE  OBTAIN,LENGTH=(0),LOC=BELOW\n         ST    R1,PDS1DATA\n         A     R1,PDSDATAH\n         ST    R1,PDS2DATA\n\nNOTFIRST EQU   *\n         MVI   PDS1DONE,C'N'\n         LA    R3,PDS1             POINT TO PDS' DCB'S & DATA AREAS\n         LA    R6,PDS2\n\n         FIND  PDS1,MEMBER,D\n         BAL   R12,READ1\n\n         FIND  PDS2,MEMBER,D\n         BAL   R12,READ2\n\n         USING IHADCB,R3\n         TM    DCBRECFM,DCBRECU    WHAT RECORD FORMAT?\n         BO    CHECKU\n         TM    DCBRECFM,DCBRECV\n         BO    CHECKV\n         B     CHECKF\n\nCHECKF   EQU   *\n         LH    R14,DCBLRECL\n         ST    R14,LRECL\nCHECKF10 EQU   *\n         LR    R14,R5\n         L     R15,LRECL\n         LR    R0,R8\n         LR    R1,R15\n         CLCL  R14,R0\n         BNE   NOTEQUAL\n         A     R5,LRECL\n         CR    R5,R4\n         BL    CHECKF20\n         BAL   R12,READ1\nCHECKF20 EQU   *\n         A     R8,LRECL\n         CR    R8,R7\n         BL    CHECKF10\n         BAL   R12,READ2\n         B     CHECKF10\n\nCHECKV   EQU   *\n         LA    R5,4(R5)\n         LA    R8,4(R8)\nCHECKV10 EQU   *\n         LH    R15,0(R5)\n         LH    R1,0(R8)\n         S     R15,FW4\n         S     R1,FW4\n         ST    R15,LRECL\n         CR    R15,R1\n         BNE   NOTEQUAL\n         LA    R5,4(R5)\n         LA    R8,4(R8)\n         LR    R14,R5\n         LR    R0,R8\n         CLCL  R14,R0\n         BNE   NOTEQUAL\n         L     R15,LRECL\n         LA    R5,0(R15,R5)\n         CR    R5,R4\n         BL    CHECKV20\n         BAL   R12,READ1\nCHECKV20 EQU   *\n         L     R15,LRECL\n         LA    R8,0(R15,R8)\n         CR    R8,R7\n         BL    CHECKV10\n         BAL   R12,READ2\n         B     CHECKV10\n\nCHECKU   EQU   *\n         SR    R4,R5\n         SR    R7,R8\n         CR    R4,R7\n         BNE   NOTEQUAL\n         LR    R14,R5\n         LR    R15,R4\n         LR    R0,R8\n         LR    R1,R7\n         CLCL  R14,R0\n         BNE   NOTEQUAL\n         BAL   R12,READ1\n         BAL   R12,READ2\n         B     CHECKU\n\nPDS1EOF  EQU   *\n         MVI   PDS1DONE,C'Y'\n         BAL   R12,READ2\n         B     NOTEQUAL\n\nPDS2EOF  EQU   *\n         CLI   PDS1DONE,C'Y'\n         BE    EQUAL\n         B     NOTEQUAL\n\nEQUAL    EQU   *\n         SR    R15,R15\n         B     EXIT\nNOTEQUAL EQU   *\n         LA    R15,4\nEXIT     REXIT\n\nREAD1    EQU   *\n         L     R5,PDS1DATA\n         READ  PDS1DECB,SF,PDS1,(R5),'S'\n         CHECK PDS1DECB\n         L     R14,PDS1DECB+16     FIGURE DATA LENGTH ACTUALLY READ\n         USING IHADCB,R3\n         LH    R4,DCBBLKSI\n         SH    R4,14(R14)\n         LA    R4,0(R4,R5)\n         BR    R12\n\nREAD2    EQU   *\n         L     R8,PDS2DATA\n         READ  PDS2DECB,SF,PDS2,(R8),'S'\n         CHECK PDS2DECB\n         L     R14,PDS2DECB+16     FIGURE DATA LENGTH ACTUALLY READ\n         DROP  R3\n         USING IHADCB,R6\n         LH    R7,DCBBLKSI\n         SH    R7,14(R14)\n         LA    R7,0(R7,R8)\n         BR    R12\n\nFW4      DC    F'4'\nLRECL    DS    F\nMEMBER   DS    CL8\nINITIAL  DC    C'Y'\nPDS1DONE DC    C'N'\nPDSDATAL DC    F'65536'\nPDSDATAH DC    F'32768'\nPDS1DATA DS    A\nPDS2DATA DS    A\nPDS1     DCB   DSORG=PO,MACRF=R,DDNAME=SYSLIB1,EODAD=PDS1EOF\nPDS2     DCB   DSORG=PO,MACRF=R,DDNAME=SYSLIB2,EODAD=PDS2EOF\n         DCBD  DSORG=(PO),DEVD=DA\n         END   PDSCOMP\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//***\n//L          EXEC     PGM=IEWL,COND=(5,LT),\n//             PARM='XREF,LIST,LET,DCBS',\n//             REGION=4M\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,\n//             DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   99110400\n  ENTRY    PDSMATCH\n  NAME     PDSMATCH(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDSMATCP": {"ttr": 33283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x02\\x01\\x16\\x15\\x1f\\x01\\x16!_\"\\t\\x04\\x98\\x04U\\x00\\x00\\xd7\\xd9\\xc5\\xe5\\xc9\\xd6\\xe2@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2016-05-30T00:00:00", "modifydate": "2016-08-02T22:09:02", "lines": 1176, "newlines": 1109, "modlines": 0, "user": "PREVIOS"}, "text": "         TITLE '   P D S M A T C H   '\n***********************************************************************\n*          THIS PROGRAM COMPARES THE DIRECTORIES OF TWO PARTITIONED\n*          DATA SETS AND PRINTS A REPORT SHOWING WHICH MEMBERS\n*          MATCH AND WHICH MEMBERS DO NOT MATCH OR ARE NOT PRESENT\n*          IN BOTH DIRECTORIES.\n*\n*          MEMBERS ARE SAID TO MATCH IF THEIR NAMES ARE THE SAME.\n*          IF PARM=USER, IF ALL THE STATISTICS IN THEIR DIRECTORY\n*          ENTRIES ARE EQUAL (EXCEPT FIELDS CONTAINING TTR TRACK\n*          ADDRESSES). IF PARM=DATA, IF THEIR DATA ARE THE SAME.\n*\n*          DDNAMES.\n*             SYSPRINT - REPORT OUTPUT\n*             SYSLIB1  - PDS 1 INPUT\n*             SYSLIB2  - PDS 2 INPUT\n*\n*          IF PARM=EQO\n*             ONLY MEMBERS THAT MATCH WILL BE LISTED.\n*          IF PARM=NEO\n*             ONLY MEMBERS THAT DONT MATCH WILL BE LISTED.\n*          IF DEFAULTED\n*             ALL MEMBERS WILL BE LISTED FOR BOTH LIBRARIES.\n*          IF PARM=USER\n*             MEMBERS THAT ARE PRESENT IN BOTH LIBRARIES\n*             WILL BE COMPARED FOR MATCHING USERDATA.\n*             USERDATA CONSISTS OF UP TO 64 BYTES OF DATA\n*             IN THE DIRECTORY ENTRY WHICH IS PUT THERE BY\n*             THE LINKAGE EDITOR, SPF EDIT, AND OTHERS.\n*             NOTE. WITH PARM=USER,\n*             IF TWO MEMBERS HAVE THE SAME NAME AND NEITHER\n*             HAS ANY USERDATA, THEY ARE TREATED AS UNEQUAL,\n*             WITH A UNIQUE MESSAGE FOR THIS CASE.\n*          IF PARM=DATA\n*             MEMBERS THAT ARE PRESENT IN BOTH LIBRARIES\n*             WILL BE COMPARED FOR MATCHING DATA.\n*             IF TWO MEMBERS HAVE THE SAME NAME AND BOTH ARE\n*             EMPTY, THEY ARE TREATED AS UNEQUAL,\n*             WITH A UNIQUE MESSAGE FOR THIS CASE.\n*          IF PARM=SUMS\n*             COUNTS ARE PRINTED AT THE END FOR:\n*             NUMBER OF MEMBERS IN LIBRARY 1 ONLY\n*             NUMBER OF MEMBERS IN LIBRARY 2 ONLY\n*             NUMBER OF MEMBERS IN BOTH BUT DIFFERENT\n*             NUMBER OF MEMBERS IN BOTH AND EQUAL\n*\n*          LOG OF CHANGES.\n*           2015 DEC 13 - CHANGES TO GET IT TO ASSEMBLE ON MVS 3.8.\n*             CHANGED 'STORAGE' TO 'GETMAIN' AND 'FREEMAIN'\n*             IN RENTER AND REXIT SO IT ASSEMBLES ON MVS 3.8.\n*             ADDED 'LCLA' AND 'LCLB' TO RENTER AND REXIT FOR IFOX00.\n*           2015 DEC 13 - FIXES AND MINOR IMPROVEMENTS.\n*             REMOVED RENTER AND REXIT MACRO DEFS PRECEDING PDSMATCH,\n*             AS THEY ARE NOT USED BY PDSMATCH.\n*             AT CHECKF ADD CODE TO CORRECTLY HANDLE UNBLOCKED RECORDS.\n*             ADD A 'CLOSE' FUNCTION TO PDSCOMP.\n*             CALL PDSCOMP ONE LAST TIME WITH CLOSE REQUESTED.\n*             CHANGE 'END PDSCOMP' TO JUST 'END'\n*             FIX A PROBLEM AT PDS1EOF THAT CAUSED FALSE 'EQUAL'\n*             WHEN SYSLIB1 HIT EOF AND SYSLIB2 STILL HAD MORE IN\n*             ITS LAST BLOCK.\n*           2016 FEB 4 - WHEN COMPARING PDS'ES WITH A VERY LARGE NUMBER\n*             OF MEMBERS, PDSMATCH REQUIRED A BIGGER GETMAIN AT LABEL\n*             DIRSIZE.  FOR NOW, INCREASED TO 1000K.  ADEQUATE SO FAR.\n*           2016 AUG 2 - FIX BUG SHOWING 2 EMPTY MEMBERS NOT EQUAL.\n*             ADDED PARM OPTION 'SUMS' TO SHOW COUNTS AT END.\n*\n***********************************************************************\n\n         MACRO\n         REGS  &PP=R\n         LCLA  &II\n&II      SETA  0\n.LOOP    ANOP\n&PP&II   EQU   &II\n&II      SETA  &II+1\n         AIF   (&II LT 16).LOOP\n         MEND\nPDSMATCH START\n         REGS\n         USING *,R10,R11\n         B     @PROLOG-*(,15)\n         DC    AL1(11),CL11'PDSMATCH'\n         DC    CL16' &SYSDATE &SYSTIME '\n@SIZE    DC    0F'0',AL1(1),AL3(@DATAL)\n@PROLOG  STM   14,12,12(R13)\n         LR    R10,15\n         LA    R15,1\n         LA    R11,4095(R15,R10)\n         LR    R4,R1               SAVE PARM POINTER\n         L     R0,@SIZE\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING @DATA,R13\n         SR    R15,R15\n         STH   R15,RC\n         STC   R15,STATUS\n         STC   R15,OPTIONS\n         MVC   DDNAMEP,=CL8'SYSPRINT'\n         MVC   DDNAME1,=CL8'SYSLIB1'\n         MVC   DDNAME2,=CL8'SYSLIB2'\n         MVI   LINE-1,C' '\n         MVC   LINE,LINE-1\n         MVI   MESG-1,C' '\n         ZAP   REPORTPG,=P'0'\n         ZAP   REPORTLN,=P'0'\n         ZAP   REPORTMX,=P'60'\n         MVI   REPORTO-1,C' '\n         MVI   JFCB1,C' '\n         MVC   JFCB1+1(175),JFCB1\n         MVC   JFCB2(176),JFCB1\n         XC    COUNTEQ(16),COUNTEQ  ZERO 4 COUNTERS\n\n************************************************************\n*         OPEN THE PRINT FILE                              *\n************************************************************\n\n         MVC   PRTDCBW(PRTDCBL),PRTDCB\n         LA    R2,PRTDCBW\n         MVC   DDNAM(8,R2),DDNAMEP\n         MVI   OPEN,X'80'\n         OPEN  ((R2),OUTPUT),MF=(E,OPEN)\n         TM    OFLGS(R2),X'10'\n         BNO   EXIT12\n         OI    STATUS,PRTOPEN\n         B     PRTX\nPRTEXITO CLC   62(2,R1),=H'0'      IS BLKSIZE ZERO\n         BNE   0(R14)              NO\n         MVC   62(2,R1),82(R1)     YES - MAKE IT SAME AS LRECL\n         BR    R14\nPRTX     EQU   *\n\n************************************************************\n*         SCAN THE PARM FIELD                              *\n************************************************************\n\n*\n*               REGISTERS USED\n*                R14 - RETURN FROM PARSE\n*                R15 - ADDRESS OF REMAINING PARM DATA\n*                R0  - WORK\n*                R1  - USED BY TRT INSTRUCTION\n*                R2  - USED BY TRT INSTRUCTION\n*                R3  - LENGTH OF REMAINING PARM DATA MINUS 1\n*\n*               PARSE MUST NOT ALTER R0, R1, OR R3\n*\n         L     R15,0(,R4)          POINT TO PARM\n         LH    R3,0(,R15)          GET LENGTH OF PARM\n         LTR   R3,R3               IS THERE A PARM\n         BZ    PARMX               NO, BRANCH\n         LA    R15,2(,R15)         POINT TO PARM DATA\n\n         SR    R1,R1               INSURE HI ORDER BYTE ZERO\n         BCTR  R3,0                LENGTH CODE OF PARM DATA\n         B     *+16                SKIP EXECUTED INSTRUCTIONS\nTRTNONBL TRT   0(0,R15),TABNONBL   (EXECUTED)\nTRTBLANK TRT   0(0,R15),TABBLANK   (EXECUTED)\n*              NOTE: TRT CAN CHANGE 8 BITS OF R2 AND 24 BITS OF R1\nPARMLOOP EX    R3,TRTNONBL         FIND A NONBLANK\n         BZ    PARMX               BRANCH IF ALL BLANKS\n         LR    R0,R1               GET ADDRESS OF STRING\n         SR    R0,R15              GET LENGTH OF PRECEDING BLANKS\n         SR    R3,R0               GET LENGTH OF REMAINING TEXT\n         LR    R15,R1              GET ADDRESS OF NONBLANK\n         EX    R3,TRTBLANK         FIND A BLANK\n         BZ    PARMLAST            BRANCH IF NOT FOUND\n         LR    R0,R1               GET ADDRESS OF BLANK\n         SR    R0,R15              GET LENGTH OF FIELD\n         BAL   R14,PARSE\n         SR    R3,R0               GET LENGTH CODE OF REMAINING TEXT\n         BZ    PARMX               BRANCH IF ONE TRAILING BLANK\n         LR    R15,R1              POINT TO BLANK\n         B     PARMLOOP\nPARMLAST LA    R0,1(,R3)           GET LENGTH\n         BAL   R14,PARSE\n         B     PARMX\n\n************************************************************\n*         PROCESS EACH PARM KEYWORD                        *\n************************************************************\n\nPARSE    STM   R14,R1,PARSES       SAVE REGS\n         CH    R0,=H'4'            IS KEYWORD LENGTH 4\n         BNE   PARSL4X             NO, BRANCH\n         CLC   0(4,R15),=C'USER'\n         BNE   *+12\n         OI    OPTIONS,OPTUSER\n         B     PARSX\n         CLC   0(4,R15),=C'DATA'\n         BNE   *+12\n         OI    OPTIONS,OPTDATA\n         B     PARSX\n         CLC   0(4,R15),=C'SUMS'\n         BNE   PARSL4X\n         OI    OPTIONS,OPTSUMS\n         B     PARSX\nPARSL4X  EQU   *\n         CH    R0,=H'3'            IS KEYWORD LENGTH 3\n         BNE   PARSL3X             NO, BRANCH\n         CLC   0(3,R15),=C'EQO'    EQONLY\n         BNE   *+8\n         OI    OPTIONS,OPTEQO\n         CLC   0(3,R15),=C'NEO'    NEONLY\n         BNE   *+8\n         OI    OPTIONS,OPTNEO\n         B     PARSX\nPARSL3X  EQU   *\nPARSX    LM    R14,R1,PARSES\n         BR    R14\n\nPARMX    EQU   *\n\n************************************************************\n*         SHOW CRITERIA                                    *\n************************************************************\n\n         TM    OPTIONS,OPTUSER\n         BO    PRTCRI2\n         TM    OPTIONS,OPTDATA\n         BO    PRTCRI3\n         LA    R1,MSGCRI1A\n         LA    R0,L'MSGCRI1A\n         BAL   R14,PRTMSG\n         LA    R1,MSGCRI1B\n         LA    R0,L'MSGCRI1B\n         BAL   R14,PRTMSG\n         B     PRTCRIX\nPRTCRI2  LA    R1,MSGCRI2A\n         LA    R0,L'MSGCRI2A\n         BAL   R14,PRTMSG\n         LA    R1,MSGCRI2B\n         LA    R0,L'MSGCRI2B\n         BAL   R14,PRTMSG\n         B     PRTCRIX\nPRTCRI3  LA    R1,MSGCRI3A\n         LA    R0,L'MSGCRI3A\n         BAL   R14,PRTMSG\n         LA    R1,MSGCRI3B\n         LA    R0,L'MSGCRI3B\n         BAL   R14,PRTMSG\nPRTCRIX  LA    R1,=C' '\n         LA    R0,1\n         BAL   R14,PRTMSG\n\n************************************************************\n*         OPEN THE FIRST PDS                               *\n************************************************************\n\n         MVC   DIRDCBW(DIRDCBL),DIRDCB\n         LA    R2,DIRDCBW          ADDRESS OF DCB\n         MVC   DDNAM(8,R2),DDNAME1 CHANGE THE DDNAME\n         LA    R3,DDNAM(,R2)       POINT TO DDNAME FOR DEVTYPE\n         DEVTYPE (R3),DEVAREA\n         LTR   R15,R15             IS DDNAME ALLOCATED\n         BNZ   EXIT12              NO, BRANCH\n\n         LA    R1,DIREXLST         PUT EXLST\n         IC    R0,EXLST(,R2)        ADDRESS\n         ST    R1,EXLST(,R2)         IN\n         STC   R0,EXLST(,R2)          DCB\n         LA    R0,JFCB1            PUT JFCB ADDRESS\n         ST    R0,0(,R1)            IN EXLST\n         MVI   0(R1),X'87'           AND INDICATE EXLST ENTRY TYPE\n         MVI   RDJFCB,X'80'\n         RDJFCB ((R2)),MF=(E,RDJFCB)\n\n         MVI   OPEN,X'80'\n         OPEN  ((R2),INPUT),MF=(E,OPEN)\n         TM    OFLGS(R2),X'10'\n         BNO   EXIT12\n         OI    STATUS,DIROPEN\n\n         MVC   LINE,LINE-1         BLANK LINE\n         MVC   LINE+1(10),=C'LIBRARY1 -'\n         LA    R15,LINE+12\n         MVC   0(44,R15),JFCB1\n         LA    R15,44(,R15)\nAPPENDV1 CLI   0(R15),C' '\n         BNE   *+8\n         BCT   R15,APPENDV1\n         MVC   2(2,R15),=C'ON'\n         MVC   5(6,R15),JFCB1+118  VOLUME SERIAL\n         BAL   R14,REPORTL         PUT HEADING LIBRARY1 DSN\n\n         L     R0,DIRSIZE\n         GETMAIN R,LV=(0)\n         ST    R1,DIRFREE          SAVE FOR FREEMAIN\n         LR    R3,R1\n         ST    R3,DIRPTR1          SAVE FOR WALKING THRU DIR 1\n         OI    STATUS,GOTMAIN\n         MVC   DIRDECBW(DIRDECBL),DIRDECB\n         MVI   DIRSW,0\n         BAL   R8,DIRIN\n         CLOSE ((R2)),MF=(E,OPEN)\n         NI    STATUS,255-DIROPEN\n         TM    DIRSW,1             WAS DIRECTORY VALID\n         BZ    EXIT12              NO, QUIT\n         LA    R3,256(,R3)         SET START OF SECOND DIRECTORY\n         ST    R3,DIRPTR2          SAVE FOR WALKING THRU DIR 2\n\n************************************************************\n*         OPEN THE SECOND PDS                              *\n************************************************************\n\n         MVC   DIRDCBW(DIRDCBL),DIRDCB\n         LA    R2,DIRDCBW          ADDRESS OF DCB\n         MVC   DDNAM(8,R2),DDNAME2 CHANGE THE DDNAME\n         LA    R3,DDNAM(,R2)       POINT TO DDNAME FOR DEVTYPE\n         DEVTYPE (R3),DEVAREA\n         LTR   R15,R15             IS DDNAME ALLOCATED\n         BNZ   EXIT12              NO, BRANCH\n\n         LA    R1,DIREXLST         PUT EXLST\n         IC    R0,EXLST(,R2)        ADDRESS\n         ST    R1,EXLST(,R2)         IN\n         STC   R0,EXLST(,R2)          DCB\n         LA    R0,JFCB2            PUT JFCB ADDRESS\n         ST    R0,0(,R1)            IN EXLST\n         MVI   0(R1),X'87'           AND INDICATE EXLST ENTRY TYPE\n         MVI   RDJFCB,X'80'\n         RDJFCB ((R2)),MF=(E,RDJFCB)\n\n         MVI   OPEN,X'80'\n         OPEN  ((R2),INPUT),MF=(E,OPEN)\n         TM    OFLGS(R2),X'10'\n         BNO   EXIT12\n         OI    STATUS,DIROPEN\n\n         MVC   LINE,LINE-1         BLANK LINE\n         MVC   LINE+1(10),=C'LIBRARY2 -'\n         LA    R15,LINE+12\n         MVC   0(44,R15),JFCB2\n         LA    R15,44(,R15)\nAPPENDV2 CLI   0(R15),C' '\n         BNE   *+8\n         BCT   R15,APPENDV2\n         MVC   2(2,R15),=C'ON'\n         MVC   5(6,R15),JFCB2+118  VOLUME SERIAL\n         BAL   R14,REPORTL         PUT HEADING LIBRARY2 DSN\n         MVC   LINE,LINE-1         BLANK LINE\n         BAL   R14,REPORTL         PUT HEADING BLANK LINE\n\n         L     R3,DIRPTR2\n         MVC   DIRDECBW(DIRDECBL),DIRDECB\n         MVI   DIRSW,0\n         BAL   R8,DIRIN\n         CLOSE ((R2)),MF=(E,OPEN)\n         NI    STATUS,255-DIROPEN\n         TM    DIRSW,1             WAS DIRECTORY VALID\n         BZ    EXIT12              NO, QUIT\n         B     COMPARE\n\n************************************************************\n*         READ THE DIRECTORY INTO STORAGE                  *\n************************************************************\n\nDIRIN    XC    DIRBLKS,DIRBLKS\n         XC    DIRBLKSU,DIRBLKSU\n         XC    MEMBERS,MEMBERS\n         XC    ALIASES,ALIASES\n\n         B     *+8\nDIRREAD  LA    R3,256(,R3)\n         READ  DIRDECBW,SF,(R2),(R3),256,MF=E\n         CHECK DIRDECBW\n         TM    DIRSW,2             I/O ERROR\n         BO    DIRERR              YES, BRANCH\n         LA    R1,1\n         A     R1,DIRBLKS\n         ST    R1,DIRBLKS\n*        TM    DIRSW,1             ARE WE PAST USED BLOCKS\n*        BO    DIRREAD             YES, BRANCH\n         LR    R1,R3               POINT TO DATA JUST READ\n         LH    R0,0(,R1)           GET NUMBER OF BYTES IN USE\n         LTR   R0,R0               IS THIS NEGATIVE\n         BM    DIRINV              YES, NOT A DIRECTORY BLOCK\n         CH    R0,=H'256'          IS THIS TOO LARGE\n         BH    DIRINV              YES, NOT A DIRECTORY BLOCK\n         AR    R0,R1               POINT PAST LAST BYTE\n         LA    R1,2(,R1)           POINT TO FIRST MEMBER\nDIRENTRY CLC   0(8,R1),=8X'FF'     END OF MEMBERS\n         BE    DIRUSED\n         TM    11(R1),X'80'        ALIAS\n         BO    DIRALIAS\n         LA    R15,1               COUNT NON-ALIAS MEMBERS\n         A     R15,MEMBERS\n         ST    R15,MEMBERS\n         B     DIRNEXT\nDIRALIAS LA    R15,1               COUNT ALIAS MEMBERS\n         A     R15,ALIASES\n         ST    R15,ALIASES\nDIRNEXT  SLR   R15,R15\n         IC    R15,11(,R1)\n         N     R15,=F'31'          SET OFF ALL BUT LAST 5 BITS\n         SLL   R15,1               CHANGE HALFWORDS TO BYTES\n         LA    R1,12(R15,R1)       POINT PAST USER DATA\n         CR    R1,R0               END OF BLOCK\n         BL    DIRENTRY            NO, BRANCH\n         B     DIRREAD             YES, READ NEXT BLOCK\nDIRUSED  EQU   *\n         OI    DIRSW,1             STOP COUNTING MEMBERS\n         MVC   DIRBLKSU,DIRBLKS    SAVE NUMBER OF USED BLOCKS\n*        B     DIRREAD             GO COUNT UNUSED BLOCKS\n         B     DIREND\n\nDIRSYN   EQU   *\n         SYNADAF ACSMETH=BSAM\n         MVC   MESSAGE(72),50(R1)\n         OI    DIRSW,2\n         SYNADRLS\n         BR    R14\nDIRINV   LA    R1,MSGINV\n         LA    R0,L'MSGINV\n         BAL   R14,PRTMSG\n         OI    DIRSW,4\n         B     DIREND\nDIRERR   LA    R1,MESSAGE\n         LA    R0,72\n         BAL   R14,PRTMSG\n         OI    DIRSW,4\n         B     DIREND\nDIREOF   LA    R1,MSGEOF\n         LA    R0,L'MSGEOF\n         BAL   R14,PRTMSG\n         OI    DIRSW,4\nDIREND   EQU   *\n         BR    R8\n\n************************************************************\n*         COMPARE ROUTINE                                  *\n************************************************************\n\nCOMPARE  EQU   *\n         L     R1,DIRPTR1          POINT TO FIRST BLOCK OF PDS1\n         ST    R1,PDSWORK1+8\n         LH    R0,0(,R1)           GET NUMBER OF BYTES IN USE\n         AR    R0,R1               POINT PAST LAST BYTE\n         LA    R1,2(,R1)           POINT TO FIRST MEMBER\n         LA    R2,PDSWORK1\n         BAL   R8,GETMEM1          GET FIRST MEMBER\n\n         L     R1,DIRPTR2          POINT TO FIRST BLOCK OF PDS2\n         ST    R1,PDSWORK2+8\n         LH    R0,0(,R1)           GET NUMBER OF BYTES IN USE\n         AR    R0,R1               POINT PAST LAST BYTE\n         LA    R1,2(,R1)           POINT TO FIRST MEMBER\n         LA    R2,PDSWORK2\n         BAL   R8,GETMEM1          GET FIRST MEMBER\n\n************************************************************\n*         READY TO COMPARE                                 *\n************************************************************\n\n         LA    R3,PDSWORK1\n         LA    R4,PDSWORK2\nREADY    CLC   20(8,R3),20(R4)\n         BL    SHOW1\n         BH    SHOW2\n         CLC   20(8,R3),=8X'FF'\n         BE    DONE\n\n************************************************************\n*         MEMBER EXISTS IN BOTH LIBRARIES                  *\n************************************************************\n\n         MVC   LINE,LINE-1\n         MVC   LINE+01(8),20(R3)\n         MVC   COMPMEM,20(R3)\n         MVC   LINE+22(8),20(R4)\n         TM    OPTIONS,OPTUSER    ARE WE COMPARING USERDATA\n         BZ    DATAOPTN           NO, CHECK FOR DATA OPTION\n         CLC   19(73,R3),19(R4)   IS USERDATA THE SAME\n         BE    SAME               YES, BRANCH\n         MVC   LINE+10(11),=C' ********* '\n         MVC   LINE+32(25),=C'NON-SPF USER DATA UNEQUAL'\n*              SEE IF BOTH ARE SPF STATS.\n*              IF BOTH ARE SPF STATS, SHOW WHICH IS MORE RECENT\n         TM    12(R3),SPFFLAG      IS USERDATA SPF\n         BNO   DIFF1               NO, BRANCH\n         TM    12(R4),SPFFLAG      IS USERDATA SPF\n         BNO   DIFF2               NO, BRANCH\n         CLC   28+8(6,R3),28+8(R4) COMPARE YY.DDD HH.MM LAST UPDATED\n         BH    RECENT1\n         BL    RECENT2\n         MVC   LINE+10(11),=C' ********* '\n         MVC   LINE+32(32),=C'SPF STATS DIFFER BUT NOT IN DATE'\n         B     MATCHP\nDIFF1    TM    12(R4),SPFFLAG      IS USERDATA SPF\n         BNO   MATCHP              NO - NEITHER MEMBER IS SPF\n         MVC   LINE+32(27),=C'ONLY LIBRARY2 HAS SPF STATS'\n         B     MATCHP\nDIFF2    MVC   LINE+32(27),=C'ONLY LIBRARY1 HAS SPF STATS'\n         B     MATCHP\nRECENT1  MVC   LINE+10(11),=C' <-- NEWER '\n         MVC   LINE+32(25),=C'LIBRARY1 IS MORE RECENT  '\n         B     MATCHP\nRECENT2  MVC   LINE+10(11),=C' NEWER --> '\n         MVC   LINE+32(25),=C'LIBRARY2 IS MORE RECENT  '\n         B     MATCHP\nDATAOPTN TM    OPTIONS,OPTDATA    ARE WE COMPARING REAL DATA\n         BZ    MATCHP             NO, GO ON WITH OTHER MEMBERS\n         CALL  PDSCOMP,COMPMEM,VL\n         LTR   R15,R15\n         BZ    MATCHP\nUNEQUAL  MVC   LINE+10(11),=C' <UNEQUAL> '\n         MVC   LINE+32(25),=C'LIBRARY DATA IS NOT SAME '\n         B     MATCHP             GO ON WITH OTHER MEMBERS\n\n************************************************************\n*         DIRECTORY DATA MATCHES                           *\n************************************************************\n\nSAME     CLI   15(R3),0           ZERO USERDATA IN BOTH\n         BNE   SAME2              NO, BRANCH\n         MVC   LINE+10(11),=C' ********* '\n         MVC   LINE+32(27),=C'NEITHER MEMBER HAS USERDATA'\n         B     MATCHP\nSAME2    TM    12(R3),SPFFLAG     SPF STATS IN BOTH\n         BO    MATCHP             YES - OMIT MESSAGE\n         MVC   LINE+10(11),=C' ********* '\n         MVC   LINE+32(23),=C'NON-SPF USER DATA EQUAL'\nMATCHP   CLI   LINE+32,C' '        IS THIS A MATCH\n         BNE   MATCHNE             NO, BRANCH\n         LA    R0,1\n         A     R0,COUNTEQ\n         ST    R0,COUNTEQ\n         TM    OPTIONS,OPTNEO     ARE WE PRINTING .NE. ONLY\n         BO    MATCHX             YES, DONT PRINT THESE\n         B     MATCHPR\nMATCHNE  LA    R0,1\n         A     R0,COUNTNE\n         ST    R0,COUNTNE\n         TM    OPTIONS,OPTEQO     ARE WE PRINTING .EQ. ONLY\n         BO    MATCHX             YES, DONT PRINT THESE\nMATCHPR  BAL   R14,REPORTL\nMATCHX   LR    R2,R3\n         BAL   R8,GETMEM\n         LR    R2,R4\n         BAL   R8,GETMEM\n         B     READY\n\n************************************************************\n*         MEMBER EXISTS ONLY IN LIBRARY 1                  *\n************************************************************\n\nSHOW1    LA    R0,1\n         A     R0,COUNTL1\n         ST    R0,COUNTL1\n         TM    OPTIONS,OPTEQO     ARE WE PRINTING .EQ. ONLY\n         BO    SHOW1X             YES, DONT PRINT THESE\n         MVC   LINE,LINE-1\n         MVC   LINE+01(8),20(R3)\n         MVC   LINE+32(23),=C'MEMBER IN LIBRARY1 ONLY'\n         BAL   R14,REPORTL\nSHOW1X   LR    R2,R3\n         BAL   R8,GETMEM\n         B     READY\n\n************************************************************\n*         MEMBER EXISTS ONLY IN LIBRARY 2                  *\n************************************************************\n\nSHOW2    LA    R0,1\n         A     R0,COUNTL2\n         ST    R0,COUNTL2\n         TM    OPTIONS,OPTEQO     ARE WE PRINTING .EQ. ONLY\n         BO    SHOW2X             YES, DONT PRINT THESE\n         MVC   LINE,LINE-1\n         MVC   LINE+22(8),20(R4)\n         MVC   LINE+32(23),=C'MEMBER IN LIBRARY2 ONLY'\n         BAL   R14,REPORTL\nSHOW2X   LR    R2,R4\n         BAL   R8,GETMEM\n         B     READY\n\n************************************************************\n*         END OF BOTH DIRECTORIES                          *\n************************************************************\n\nDONE     TM    OPTIONS,OPTSUMS\n         BZ    EXIT\n         MVC   LINE,LINE-1\n         L     R0,COUNTL1\n         CVD   R0,DOUBLE\n         MVC   LINE(6),=X'402020202020' EDIT MASK\n         ED    LINE(6),DOUBLE+5\n         MVC   LINE+7(24),=C'MEMBERS IN LIBRARY1 ONLY'\n         BAL   R14,REPORTL\n         L     R0,COUNTL2\n         CVD   R0,DOUBLE\n         MVC   LINE(6),=X'402020202020' EDIT MASK\n         ED    LINE(6),DOUBLE+5\n         MVC   LINE+7(24),=C'MEMBERS IN LIBRARY2 ONLY'\n         BAL   R14,REPORTL\n         L     R0,COUNTNE\n         CVD   R0,DOUBLE\n         MVC   LINE(6),=X'402020202020' EDIT MASK\n         ED    LINE(6),DOUBLE+5\n         MVC   LINE+7(29),=C'MEMBERS IN BOTH BUT DIFFERENT'\n         BAL   R14,REPORTL\n         MVC   LINE,LINE-1\n         L     R0,COUNTEQ\n         CVD   R0,DOUBLE\n         MVC   LINE(6),=X'402020202020' EDIT MASK\n         ED    LINE(6),DOUBLE+5\n         MVC   LINE+7(25),=C'MEMBERS IN BOTH AND EQUAL'\n         BAL   R14,REPORTL\n         B     EXIT\n\n************************************************************\n*         SUBROUTINE TO GET NEXT MEMBER FROM DIRECTORY     *\n************************************************************\n\nGETMEM   LM    R0,R1,0(R2)\n         CLC   0(8,R1),=8X'FF'     END OF MEMBERS\n         BE    GETEOF\nGET1R    SLR   R15,R15\n         IC    R15,11(,R1)\n         N     R15,=F'31'          SET OFF ALL BUT LAST 5 BITS\n         SLL   R15,1               CHANGE HALFWORDS TO BYTES\n         LA    R1,12(R15,R1)       POINT PAST USER DATA\n         CR    R1,R0               END OF BLOCK\n         BL    GETMEM1             NO, BRANCH\n         LA    R1,256              YES, READ NEXT BLOCK\n         A     R1,8(,R2)           YES, READ NEXT BLOCK\n         ST    R1,8(,R2)           YES, READ NEXT BLOCK\n         LH    R0,0(,R1)           GET NUMBER OF BYTES IN USE\n         AR    R0,R1               POINT PAST LAST BYTE\n         LA    R1,2(,R1)           POINT TO FIRST MEMBER\n*        B     GET1R\nGETMEM1  STM   R0,R1,0(R2)\n         MVC   20(8,R2),0(R1)      SAVE MEMBER NAME\n         CLC   0(8,R1),=8X'FF'     END OF MEMBERS\n         BE    GETEOF\n         MVC   16(4,R2),8(R1)      SAVE TTR, ALIAS BIT, ETC\n         XC    28(64,R2),28(R2)    ZERO USER DATA AREA\n*              COPY USER DATA\n         SLR   R15,R15\n         IC    R15,11(,R1)\n         N     R15,=F'31'          SET OFF ALL BUT LAST 5 BITS\n         SLL   R15,1               CHANGE HALFWORDS TO BYTES\n         ST    R15,12(,R2)         SAVE LENGTH OF USER DATA\n         LTR   R15,R15\n         BZ    GETZERO\n         TM    OPTIONS,OPTUSER     IS USERDATA TO BE COMPARED\n         BZ    GETZERO             NO, BRANCH\n         CLI   15(R2),30           IS LENGTH 30\n         BNE   *+8                 NO\n         OI    12(R2),SPFFLAG      YES, INDICATE IT MAY BE SPF STATS\n         BCTR  R15,0               LENGTH MINUS 1 FOR EX\n         B     *+10\n         MVC   28(0,R2),12(R1)     EXECUTED\n         EX    R15,*-6             MOVE THE USER DATA\n         TM    11(R1),B'01100000'  ANY TTR'S IN THE USER DATA\n         BZ    GETZERO             NO, BRANCH\n         NI    12(R2),255-SPFFLAG  YES, CAN'T BE SPF\n         IC    R15,11(,R1)         YES, PREPARE TO ZERO THEM\n         N     R15,=A(X'0000007F') SET OFF ALIAS BIT\n         SRL   R15,5               SHIFT OUT RIGHT 5 BITS\n         LA    R14,28(,R2)         POINT TO FIRST TTR IN USER DATA\nGETUTTR  XC    0(3,R14),0(R14)     ZERO THE TTR IN THE USER DATA\n         LA    R14,4(,R14)         POINT TO NEXT TTR IN THE USER DATA\n         BCT   R15,GETUTTR         REPEAT UNTIL R15 ZERO\nGETZERO  EQU   *\nGETEOF   BR    R8\n\n************************************************************\n*         MESSAGE ROUTINE                                  *\n************************************************************\n\nPRTMSG   STM   R14,R1,PRTMSGS\n         MVC   MESG,MESG-1\n         LR    R15,R0\n         BCTR  R15,0\n         B     *+10\n         MVC   MESG+1(0),0(R1)\n         EX    R15,*-6\n         LA    R1,MESG\n         LA    R0,L'MESG\n         BAL   R14,REPORT\n         LM    R14,R1,PRTMSGS\n         BR    R14\n\n************************************************************\n*         REPORT WRITER                                    *\n************************************************************\n\nREPORTL  LA    R1,LINE\n         LA    R0,121\nREPORT   STM   R14,R3,REPORTS\n         LA    R3,PRTDCBW          POINT R3 TO DCB\n         CP    REPORTLN,REPORTMX   IS LINECOUNT LIMIT REACHED\n         BL    *+10                NO\n         ZAP   REPORTLN,=P'0'      YES, FORCE NEW PAGE\n         CP    REPORTLN,=P'0'      IS NEW PAGE REQUESTED?\n         BE    REPORTH             YES, GO PRINT HEADING\nREPORTD  CH    R0,=H'121'          IS OUTPUT LINE LENGTH OK?\n         BNL   REPORTP             YES, BRANCH\n         MVC   REPORTO,REPORTO-1   BLANK THE WORK AREA\n         LTR   R14,R0              COPY LENGTH\n         BNP   REPORTB             BLANK LINE IF < 1\n         BCTR  R14,0               LENGTH MINUS 1\n         B     *+10\n         MVC   REPORTO(0),0(R1)    COPY OUTPUT LINE\n         EX    R14,*-6             EXECUTE MVC\nREPORTB  LA    R1,REPORTO          POINT TO NEW OUTPUT LINE\nREPORTP  LR    R2,R1               POINT R2 TO OUTPUT LINE\n         PUT   (R3),(R2)           WRITE OUTPUT LINE\n         AP    REPORTLN,=P'1'      INCREMENT LINE COUNTER\nREPORTX  LM    R14,R3,REPORTS      RESTORE REGS\n         BR    R14                 RETURN\nREPORTH  AP    REPORTPG,=P'1'      INCREMENT PAGE COUNTER\n         MVC   REPORTO,REPORTO-1   BLANK HEADING\n         MVI   REPORTO,C'1'        CC = NEW PAGE\n         MVC   REPORTO+1(L'HEAD1),HEAD1\n         LA    R1,REPORTO+79-9     RIGHT EDGE PAGE NO\n         MVC   3(6,R1),=X'402020202020' EDIT MASK\n         ED    3(6,R1),REPORTPG    UNPACK PAGE NO\n         MVC   0(4,R1),=C'PAGE'    INSERT 'PAGE'\n         PUT   (R3),REPORTO        PUT HEADING LINE 1\n         MVC   REPORTO,REPORTO-1   BLANK LINE\n         PUT   (R3),REPORTO        PUT HEADING BLANK LINE\n         AP    REPORTLN,=P'2'      COUNT HEADING LINES\nREPORTHX LM    R0,R1,REPORTS+8     RESTORE R0 AND R1\n         B     REPORTD             GO PRINT DETAIL LINE\n         EJECT\n************************************************************\n*         TERMINATION                                      *\n************************************************************\n\nEXIT12   MVI   RC+1,12\nEXIT     EQU   *\n         MVC   COMPMEM,=8X'FF'     INDICATE CLOSE\n         CALL  PDSCOMP,COMPMEM,VL\n         TM    STATUS,GOTMAIN      IS DIRECTORY AREA GOTTEN\n         BZ    EXITGOTX            NO, BYPASS FREEMAIN\n         L     R0,DIRSIZE\n         L     R1,DIRFREE\n         FREEMAIN R,LV=(0),A=(1)\nEXITGOTX EQU   *\n         TM    STATUS,PRTOPEN      IS SYSPRINT OPEN\n         BZ    EXITPRTX            NO - BYPASS CLOSE\n         LA    R2,PRTDCBW\n         MVI   CLOSE,X'80'\n         CLOSE ((R2)),MF=(E,CLOSE)\n         FREEPOOL (R2)\nEXITPRTX EQU   *\n         LH    R15,RC\n         LR    R1,R13\n         L     R0,@SIZE\n         L     R13,4(,R13)\n         LR    R2,R15\n         FREEMAIN R,A=(1),LV=(0)\n         LR    R15,R2\n         LM    0,12,20(R13)\n         L     R14,12(,R13)\n         BR    R14\n\n************************************************************\n*        CONSTANTS                                         *\n************************************************************\n\n         LTORG\nHEAD1    DC    C'--- PDSMATCH --- PDS DIRECTORY COMPARE UTILITY ---'\n*IRSIZE  DC    0F'0',AL1(1),AL3(128*1024)  128K FOR 2 DIRECTORIES\nDIRSIZE  DC    0F'0',AL1(1),AL3(2000*512)  1000K FOR 2 DIRECTORIES\nYMDNY    DC    AL2(334,304,273,243)\n         DC    AL2(212,181,151,120)\n         DC    AL2(90,59,31,0)\nYMDLY    DC    AL2(335,305,274,244)\n         DC    AL2(213,182,152,121)\n         DC    AL2(91,60,31,0)\n         PRINT NOGEN\nPRTDCB   DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,                      +\n               RECFM=FBA,LRECL=121,EXLST=PRTEXLST\nPRTDCBL  EQU   *-PRTDCB\n\nDIRDCB   DCB   DDNAME=DYNAM,DSORG=PO,MACRF=R,EODAD=DIREOF,SYNAD=DIRSYN,X\n               RECFM=U,BLKSIZE=256\nDIRDCBL  EQU   *-DIRDCB\n\n         PRINT GEN\nPRTEXLST DC    0F'0',X'85',AL3(PRTEXITO)\nDIRREADM READ  DIRDECB,SF,MF=L\nDIRDECBL EQU   *-DIRDECB\n         PRINT GEN\nHEXTAB   DC    C'0123456789ABCDEF'\nMSGINV   DC    C'INVALID DIRECTORY BLOCK'\nMSGEOF   DC    C'NO END-OF-DIRECTORY INDICATOR FOUND'\nMSGCRI1A DC    C'CRITERIA FOR MATCHING IS MEMBER NAME ONLY.  USERDATA I+\n               N THE DIRECTORY'\nMSGCRI1B DC    C'(SUCH AS SPF STATISTICS, LOAD ATTRIBUTES) IS NOT COMPA+\n               RED.'\nMSGCRI2A DC    C'CRITERIA FOR MATCHING IS MEMBER NAME AND ALL USERDATA +\n               IN THE DIRECTORY'\nMSGCRI2B DC    C'(SUCH AS SPF STATISTICS, LOAD ATTRIBUTES) EXCEPT TTR F+\n               IELDS.'\nMSGCRI3A DC    C'CRITERIA FOR MATCHING IS MEMBER NAME AND THE ACTUAL ME+\n               MBER DATA'\nMSGCRI3B DC    C'(SPF STATISTICS ARE NOT COMPARED).'\n         DC    0D'0'\nTABNONBL DC    64X'FF'\n         DC    X'00'               BLANK\n         DC    42X'FF'\n         DC    X'00'               COMMA\n         DC    148X'FF'\nTABBLANK DC    64X'00'\n         DC    X'40'               BLANK\n         DC    42X'00'\n         DC    X'6B'               COMMA\n         DC    148X'00'\n         DC    0D'0'\nEODAD    EQU   32\nRECFM    EQU   36\nEXLST    EQU   36\nDDNAM    EQU   40\nOFLGS    EQU   48\nSYNAD    EQU   56\nBLKSI    EQU   62\nLRECL    EQU   82\n         DC    0D'0'\nCOMPMEM  DS    CL08\n\n************************************************************\n*        DSECTS                                            *\n************************************************************\n\n@DATA    DSECT\n         DS    18F                 REGISTER SAVEAREA\nDOUBLE   DS    D\nHALF     EQU   DOUBLE,2\nFULL     EQU   DOUBLE,4\nDDNAMEP  DS    CL8\nDDNAME1  DS    CL8\nDDNAME2  DS    CL8\nRC       DS    H\nSTATUS   DS    X\nPRTOPEN  EQU   X'80'\nDIROPEN  EQU   X'40'\nGOTMAIN  EQU   X'20'\nOPTIONS  DS    X\nOPTUSER  EQU   X'80'\nOPTEQO   EQU   X'40'\nOPTNEO   EQU   X'20'\nOPTDATA  EQU   X'10'\nOPTSUMS  EQU   X'08'\nDIRFREE  DS    F\nDIRPTR1  DS    F\nDIRPTR2  DS    F\nDIRSW    DS    F\nDIRBLKS  DS    F\nDIRBLKSU DS    F\nMEMBERS  DS    F\nALIASES  DS    F\nPRTDCBW  DS    0F,(PRTDCBL)X\nDIRDCBW  DS    0F,(DIRDCBL)X\nDIRDECBW DS    0F,(DIRDECBL)X\nDIREXLST DS    F\nDEVAREA  DS    2F\nCLOSE    DS    0F\nOPEN     DS    F\nRDJFCB   DS    F\nCOUNTEQ  DS    F\nCOUNTNE  DS    F\nCOUNTL1  DS    F\nCOUNTL2  DS    F\nPARSES   DS    6F\nREPORTS  DS    6F\nREPORTPG DS    PL3\nREPORTLN DS    PL2\nREPORTMX DS    PL2\nPRTMSGS  DS    4F\nPDSWORK1 DS    3F\n         DS    F                   USER DATA LENGTH\nSPFFLAG  EQU   X'80'               USER DATA CONTAINS SPF STATISTICS\n         DS    XL3                 TTR\n         DS    X                   ALIAS BIT AND USER DATA LENGTH\n         DS    CL8                 MEMBER NAME\n         DS    CL64                USER DATA\nPDSWORK2 DS    3F\n         DS    F                   USER DATA LENGTH\n         DS    XL3                 TTR\n         DS    X                   ALIAS BIT AND USER DATA LENGTH\n         DS    CL8                 MEMBER NAME\n         DS    CL64                USER DATA\nLINEB    DS    C  (LINE-1)\nLINE     DS    CL133\nMESGB    DS    C  (MESG-1)\nMESG     DS    CL133\nMESSAGE  DS    CL72\nREPORTOB DS    C (REPORTO-1)\nREPORTO  DS    CL133\nJFCB1    DS    0D,CL176\nJFCB2    DS    0D,CL176\n         DS    0D\n@DATAL   EQU   *-@DATA\n\n         END\n         MACRO\n&NAME    RENTER  &BASEREG=R11,&SALEN=108,&REGS=YES\n         GBLC  &SASIZE\n         LCLA  &#BR,&#BRX,&#BRY,&BASELEN   NEEDED BY IFOX00\n         LCLC  &BASES                      NEEDED BY IFOX00\n&SASIZE  SETC  '&SALEN'\n.* THIS MACRO PROVIDES ENTRY CODE FOR A REENTRANT PROGRAM.\n.* THE DEFAULT BASE REGISTER IS 11 BUT MAY BE CHANGED VIA\n.* THE BASEREG PARAMETER.  THE SAVE AREA SIZE MAY BE SET\n.* THROUGH THE SALEN PARAMETER AND DEFAULTS TO 108.\n         AIF   ('&REGS' NE 'YES').NOREGS\n         REGS\n.NOREGS  ANOP\n&NAME    CSECT\n         STM   R14,R12,12(R13)     SAVE INCOMING REGS\n         LR    &BASEREG(1),R15     ESTABLISH ADDRESSABILITY\n&#BR     SETA  N'&BASEREG\n         AIF   (&#BR GT 1).MULTIRG\n         USING &NAME,&BASEREG\n         AGO   .OUTBASE\n.MULTIRG ANOP\n&#BRX    SETA  1\n&#BRY    SETA  2\n         LA    &BASEREG(&#BR),4095\n.LOADNXT LA    &BASEREG(&#BRY),1(&BASEREG(&#BRX),&BASEREG(&#BR))\n&#BRX    SETA  &#BRX+1\n&#BRY    SETA  &#BRY+1\n         AIF   (&#BRY LE &#BR).LOADNXT\n&BASELEN SETA  K'&BASEREG-2\n&BASES   SETC  '&BASEREG'(2,&BASELEN)\n         USING &NAME,&BASES\n.OUTBASE ANOP\n         LA    R0,&SASIZE          LOAD SAVE AREA SIZE FOR GETMAIN\n         GETMAIN R,LV=(0)\n         ST    R1,8(R13)           STORE ADDRESS OF NEW SAVE AREA\n         ST    R13,4(R1)           SAVE CALLERS SAVE AREA ADDRESS\n         LM    R0,R1,20(R13)       RELOAD R0 & R1\n         L     R13,8(R13)          LOAD NEW SAVE AREA ADDRESS INTO R13\n         MEND\n         MACRO\n         REGS  &PP=R\n         LCLA  &II\n&II      SETA  0\n.LOOP    ANOP\n&PP&II   EQU   &II\n&II      SETA  &II+1\n         AIF   (&II LT 16).LOOP\n         MEND\n         MACRO\n&NAME    REXIT &RC15=YES\n         GBLC  &SASIZE\n         LCLA  &#BR,&#BRX,&#BRY,&BASELEN   NEEDED BY IFOX00\n         LCLC  &BASES                      NEEDED BY IFOX00\n&NAME    DS    0H\n         LA    R0,&SASIZE          LOAD SAVE AREA LENGTH FOR RELEASE\n         LR    R1,R13              LOAD SAVE AREA ADDRESS FOR RELEASE\n         L     R13,4(R13)          RESTORE CALLING SAVE AREA ADDRESS\n         AIF   ('&RC15' NE 'YES').NORETC\n         ST    R15,16(R13)         SAVE RETURN CODE\n.NORETC  ANOP\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)     RESTORE CALLING REGS R14 - R12\n         BR    R14\n         MEND\nPDSCOMP  RENTER\n\n*  R0\n*  R1    SHORT TERM WORK REG\n*  R2\n*  R3    PDS 1 DCB\n*  R4    PDS 1 DATA READ/1 PAST\n*  R5    PDS 1 DATA POINTER\n*  R6    PDS 2 DCB\n*  R7    PDS 2 DATA READ/1 PAST\n*  R8    PDS 2 DATA POINTER\n*  R9\n*  R10\n*  R11   BASE\n*  R12   SUBROUTINE RETURN\n*  R13   SAVEAREA\n*  R14   SHORT TERM WORK REG\n*  R15   SHORT TERM WORK REG\n\n         L     R14,0(R1)           GET MEMBER NAME\n         CLC   0(8,R14),=8X'FF'       IF MEMBER IS ALL HEX FF\n         BE    CLOSEM                 GO CLOSE THE DCB'S\n         MVC   MEMBER,0(R14)\n\n         CLI   INITIAL,C'Y'        FIRST TIME THROUGH?\n         BNE   NOTFIRST            IF NOT, DON'T DO BASIC STUFF AGAIN\n\n         MVI   INITIAL,C'N'        FIRST TIME THROUGH ONLY\n         OPEN  (PDS1,,PDS2)\n         L     R0,PDSDATAL\n         GETMAIN R,LV=(0)\n         ST    R1,PDS1DATA\n         A     R1,PDSDATAH\n         ST    R1,PDS2DATA\n\nNOTFIRST EQU   *\n         MVI   PDS1DONE,C'N'\n         MVI   PDS2READ,C'N'\n         LA    R3,PDS1             POINT TO PDS' DCB'S & DATA AREAS\n         LA    R6,PDS2\n\n         FIND  PDS1,MEMBER,D\n*        MVC   MBUF(7),=C'FIND 1 '\n*        MVC   MBUF+7(8),MEMBER\n*        LA    R1,MBUF\n*        LA    R0,15\n*        SVC   93 TPUT\n         BAL   R12,READ1\n\n         FIND  PDS2,MEMBER,D\n         BAL   R12,READ2\n\n         USING IHADCB,R3\n         TM    DCBRECFM,DCBRECU    WHAT RECORD FORMAT?\n         BO    CHECKU\n         TM    DCBRECFM,DCBRECV\n         BO    CHECKV\n         B     CHECKF\n\nCHECKF   EQU   *\n         LH    R14,DCBLRECL\n         TM    DCBRECFM,DCBRECBR   IF RECFM NOT BLOCKED          .FIX1.\n         BO    CHECKF05              THEN                        .FIX1.\n         LH    R14,DCBBLKSI          USE BLKSI AS RECORD LENGTH  .FIX1.\nCHECKF05 EQU   *                                                 .FIX1.\n         ST    R14,LRECL\nCHECKF10 EQU   *\n         LR    R14,R5              R5 --> SYSLIB1 DATA\n         L     R15,LRECL\n         LR    R0,R8               R8 --> SYSLIB2 DATA\n         LR    R1,R15\n         CLCL  R14,R0\n         BNE   NOTEQUAL\n         A     R5,LRECL\n         CR    R5,R4               R4 --> END OF SYSLIB1 BLOCK\n         BL    CHECKF20\n         BAL   R12,READ1\nCHECKF20 EQU   *\n         A     R8,LRECL\n         CR    R8,R7               R7--> END OF SYSLIB2 BLOCK\n         BL    CHECKF10\n         BAL   R12,READ2\n         B     CHECKF10\n\nCHECKV   EQU   *\n         LA    R5,4(R5)\n         LA    R8,4(R8)\nCHECKV10 EQU   *\n         LH    R15,0(R5)\n         LH    R1,0(R8)\n         S     R15,FW4\n         S     R1,FW4\n         ST    R15,LRECL\n         CR    R15,R1\n         BNE   NOTEQUAL\n         LA    R5,4(R5)\n         LA    R8,4(R8)\n         LR    R14,R5\n         LR    R0,R8\n         CLCL  R14,R0\n         BNE   NOTEQUAL\n         L     R15,LRECL\n         LA    R5,0(R15,R5)\n         CR    R5,R4\n         BL    CHECKV20\n         BAL   R12,READ1\nCHECKV20 EQU   *\n         L     R15,LRECL\n         LA    R8,0(R15,R8)\n         CR    R8,R7\n         BL    CHECKV10\n         BAL   R12,READ2\n         B     CHECKV10\n\nCHECKU   EQU   *\n         SR    R4,R5\n         SR    R7,R8\n         CR    R4,R7\n         BNE   NOTEQUAL\n         LR    R14,R5\n         LR    R15,R4\n         LR    R0,R8\n         LR    R1,R7\n         CLCL  R14,R0\n         BNE   NOTEQUAL\n         BAL   R12,READ1\n         BAL   R12,READ2\n         B     CHECKU\n\nPDS1EOF  EQU   *\n         MVI   PDS1DONE,C'Y'\n*              NEXT 4 LINES ADDED AUG 2 2016                     .FIX3.\n         CLI   PDS2READ,C'N'       IF READ2 HAS NOT BEEN CALLED  .FIX3.\n         BNE   PDS1EO1                THEN                       .FIX3.\n         FIND  PDS2,MEMBER,D          FIND BEFORE 1ST READ2      .FIX3.\n         B     PDS1EO2                SKIP DEC 13 2015 LOGIC.    .FIX3.\n*              POSSIBLE PROBLEM DISCOVERED DEC 13 2015.\n*              THERE MIGHT BE MORE DATA IN THE CURRENT READ2 BLOCK\n*              BETWEEN R8 AND R7. DOING A READ2 IS PREMATURE.\n*              THE READ2 COULD HIT EOF AND FALSELY INDICATE EQUAL.\n*              IF R8 < R7 THEN GO TO NOTEQUAL. ADDED CR AND BL.\n*              BUT THIS ONLY FIXES RECFM F. NEEDS MORE LOGIC.\nPDS1EO1  A     R8,LRECL                                          .FIX2.\n         CR    R8,R7                                             .FIX2.\n         BL    NOTEQUAL                                          .FIX2.\nPDS1EO2  EQU   *                                                 .FIX3.\n         BAL   R12,READ2\n         B     NOTEQUAL\n\nPDS2EOF  EQU   *\n         CLI   PDS1DONE,C'Y'\n         BE    EQUAL\n         B     NOTEQUAL\n\nEQUAL    EQU   *\n         SR    R15,R15\n         B     EXIT\nNOTEQUAL EQU   *\n         LA    R15,4\nEXIT     REXIT\n\nREAD1    EQU   *\n         L     R5,PDS1DATA\n         READ  PDS1DECB,SF,PDS1,(R5),'S'\n         CHECK PDS1DECB\n         L     R14,PDS1DECB+16     FIGURE DATA LENGTH ACTUALLY READ\n         USING IHADCB,R3\n         LH    R4,DCBBLKSI\n         SH    R4,14(R14)\n         LA    R4,0(R4,R5)\n         BR    R12\n\nREAD2    EQU   *\n         MVI   PDS2READ,C'Y'       READ2 HAS BEEN CALLED AT LEAST ONCE\n         L     R8,PDS2DATA\n         READ  PDS2DECB,SF,PDS2,(R8),'S'\n         CHECK PDS2DECB\n         L     R14,PDS2DECB+16     FIGURE DATA LENGTH ACTUALLY READ\n         DROP  R3\n         USING IHADCB,R6\n         LH    R7,DCBBLKSI\n         SH    R7,14(R14)\n         LA    R7,0(R7,R8)\n         BR    R12\n\nCLOSEM   CLI   INITIAL,C'Y'\n         BE    EQUAL\n         MVI   INITIAL,C'Y'\n         L     R1,PDS1DATA\n         L     R0,PDSDATAL\n         FREEMAIN R,LV=(0),A=(1)\n         CLOSE (PDS1,,PDS2)\n         B     EQUAL\n\nFW4      DC    F'4'\nLRECL    DS    F\nMEMBER   DS    CL8\nINITIAL  DC    C'Y'\nPDS1DONE DC    C'N'\nPDS2READ DC    C'N'\nPDSDATAL DC    F'65536'\nPDSDATAH DC    F'32768'\nPDS1DATA DS    A\nPDS2DATA DS    A\nMBUF     DS    CL32\n         LTORG\n         PRINT NOGEN\nPDS1     DCB   DSORG=PO,MACRF=R,DDNAME=SYSLIB1,EODAD=PDS1EOF\nPDS2     DCB   DSORG=PO,MACRF=R,DDNAME=SYSLIB2,EODAD=PDS2EOF\n         DCBD  DSORG=(PO),DEVD=DA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDSPUNC$": {"ttr": 33793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x0f\\x00\\x0f\\x00\\x00\\xd7\\xc4\\xe2\\xd7\\xd5\\xc3\\xc8@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "PDSPNCH"}, "text": "//-YOUR-USERID-P JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//CLEANUP    EXEC     PGM=IEFBR14\n//DEL01        DD       DSN=-YOUR-USERID-.$$$TEMP.BACKUP,\n//             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n//***\n//PDSPUNCH   EXEC     PGM=PDSPUNCH,REGION=4M\n  DUPS  ACTION(REPL)\n//SYSPUNCH     DD       DSN=-YOUR-USERID-.$$$TEMP.BACKUP,\n//             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(020,010),RLSE),\n//             DCB=BUFNO=32\n//SYSUT1       DD       DISP=SHR,DSN=...\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDSPUNCH": {"ttr": 33795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x03Q\\x03Q\\x00\\x00\\xd7\\xc4\\xe2\\xd7\\xd5\\xc3\\xc8@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 849, "newlines": 849, "modlines": 0, "user": "PDSPNCH"}, "text": "//-YOUR-USERID-P JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  PARTITIONED DATA SET PUNCH UTILITY ASSEMBLY AND LINK\n//***\n//A          EXEC     PGM=ASMA90,REGION=4M,\n//             PARM='RENT'\n//SYSLIB       DD       DISP=SHR,DSN=SYS1.MACLIB\n\n         TITLE '***  PDSPUNCH  --  FREEWARE  --  STELI INC. 2000  ***'\n\n*  PDSPUNCH IS FREEWARE AND MAY BE USED AT NO COST. NEITHER A LICENCE\n*  NOR REGISTRATION IS REQUIRED.  YOU MAY INDICATE TO STELI THAT YOU'RE\n*  A PDSPUNCH USER VIA WWW.STELI.COM OR BY MAIL. SUGGESTIONS, QUESTIONS\n*  OR PROBLEMS ARE WELCOME.\n*      STELI INC.\n*      PDSPUNCH TEAM\n*      27 HALF HOLLOW TURN\n*      MONROE, NY  10950-4118\n\n***********************************************************************\n*    DEFAULT OPTION VALUES\n***********************************************************************\n\n&DDOPTS  SETC  'SYSIN'            DDNAME FOR OPTIONS FILE\n&DDPDS   SETC  'SYSUT1'           DDNAME FOR PARTITIONED DATA SET\n&DDPUNCH SETC  'SYSPUNCH'         DDNAME FOR PUNCH FILE\n\n&DEFDUPS  SETC 'N'                DUPS DEFAULT\n&DEFDUPSO SETC 'N'                DUPS ONLY DEFAULT\n&DEF1ST   SETA 99999999           FIRST OPTION CHOSEN DEFAULT\n\n***********************************************************************\n*    PROGRAM ENTRY\n***********************************************************************\n\nPDSPUNCH AMODE 31\nPDSPUNCH RMODE ANY\n\nR0       EQU    0                 VARIED USAGE - ROUTINE DEPENDENT\nR1       EQU    1                   \"      \"        \"        \"\nR2       EQU    2                   \"      \"        \"        \"\nR3       EQU    3                   \"      \"        \"        \"\nR4       EQU    4                   \"      \"        \"        \"\nR5       EQU    5                   \"      \"        \"        \"\nR6       EQU    6                   \"      \"        \"        \"\nR7       EQU    7                   \"      \"        \"        \"\nR8       EQU    8                   \"      \"        \"        \"\nR9       EQU    9                   \"      \"        \"        \"\nR10      EQU   10                 BASE REGISTER\nR11      EQU   11                 BASE REGISTER\nR12      EQU   12                 RETURN REGISTER FOR SUBROUTINES\nR13      EQU   13                 SAVE AREA & MISCELLANEOUS STORAGE\nR14      EQU   14                 OCCASIONAL RETURN REGISTER (PUNCHRET)\nR15      EQU   15                 SHORT TERM WORK REGISTER\n\nPDSPUNCH CSECT                    ENTRY POINT\n         STM   R14,R12,12(R13)\n         LR    R10,R15\n         LA    R11,4095\n         LA    R11,1(R10,R11)\n         USING PDSPUNCH,R10,R11\n         LA    R0,DYNAML+WORKL\n         STORAGE  OBTAIN,LENGTH=(0),LOC=BELOW\n         ST    R1,8(R13)\n         ST    R13,4(R1)\n         LM    R0,R1,20(R13)\n         L     R13,8(R13)\n         USING WORKAREA,R13       R13 -> SAVEAREA + DYNAMIC STORAGE\n         USING IHADCB,R7          PERIODIC USE - REQUIRES LOCAL LOAD\n\n***********************************************************************\n*    MAIN LINE\n***********************************************************************\n\n         BAS   R12,INITSTOR       INITIALIZE OBTAINED MEMORY\n         BAS   R12,OPENDSS        OPEN FILES\n         BAS   R12,GETOPTNS       READ AND SET UP PARMS\n         BAS   R12,READDIR        BUILD THE DIRECTORY LIST\n         BAS   R12,DETDUPS        DETERMINE WHICH ARE DUPS\n         BAS   R12,PUNCHMEM       PUNCH THE MEMBER DATA\n         BAS   R12,CLOSERTN       CLOSE ALL FILES\nEXITALL  EQU   *\n         L     R15,FINALRC        SET LAST RETURN CODE\n         LR    R1,R13             TERMINATE PROGRAM\n         L     R13,4(R13)\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n\n***********************************************************************\n*    INITIALIZE THE OBTAINED STORAGE WITH STARTING VALUES OR WITH\n*    I/O MACRO EXPANSIONS\n***********************************************************************\n\nINITSTOR EQU   *\n\n         XC    FINALRC,FINALRC    INITIALIZE FINAL RETURN CODE TO 0\n\n         LA    R0,WKINGSTG        INITIALIZE DYNAMIC STORAGE AREA\n         LA    R1,DYNAML\n         LA    R14,DYNAMA\n         LA    R15,DYNAML\n         MVCL  R0,R14\n\n         LA    R7,DIR SET UP DCBE'S IN WORKING STORAGE\n         LA    R14,DIRE\n         ST    R14,DCBDCBE\n         LA    R7,PDS\n         LA    R14,PDSE\n         ST    R14,DCBDCBE\n         LA    R7,SYSIN\n         LA    R14,SYSINE\n         ST    R14,DCBDCBE\n\n         BR    R12\n\n***********************************************************************\n*    OPEN THE DCBS FROM THE GETMAINED AREAS\n***********************************************************************\n\n*  R1 -> OPEN MACRO\n*  R5 -> DCB\n*  R6 -> DCB\n*  R7 -> DCB\n\nOPENDSS  EQU   *\n         LA    R1,OPEN\n         LA    R5,DIR\n         LA    R6,PDS\n         LA    R7,SYSPUNCH\n         OPEN  ((R5),,(R6),,(R7),OUTPUT),MF=(E,(R1)),MODE=31\n         LTR   R15,R15\n         BZ    OPENOK01\n         ST    R15,FINALRC\n         B     EXITALL\n\nOPENOK01 EQU   *\n         LA    R1,OPENSYSI\n         LA    R5,SYSIN\n         OPEN  ((R5)),MF=(E,(R1)),MODE=31\n         LTR   R15,R15\n         BZ    OPENOK02\n         MVI   SYSINOK,C'N'\n\nOPENOK02 EQU   *\n         BR    R12\n\n***********************************************************************\n*    GET ANY SYSIN PARAMETERS\n***********************************************************************\n\n*  R0 -> REMAINDER AFTER DIVIDE; STORAGE LENGTH\n*  R1 -> QUOTIENT AFTER DIVIDE; RETURNED STORAGE ADDRESS\n*  R2 -> TRT CLOBBERS IT UNDER SOME CIRCUMSTANCES\n*  R5 -> END OF OPTION CARD (COL 72)\n*  R6 -> LENGTH REMAINING\n*  R7 -> IHADCB; TRT REGISTER (OPTNUMCK)\n*  R8 -> MOVING POINTER TO OPTION CARD\n\nGETOPTNS EQU   *\n         CLI   SYSINOK,C'Y'       SYSIN PROVIDED?\n         BNE   OPTNEXIT\n\n         GET   SYSIN\n         LA    R5,71(R1)          POINT TO END OF CARD\n         LR    R8,R1\nOPTNSCAN EQU   *\n         LR    R6,R5              CALCULATE LENGTH REMAINING\n         SR    R6,R8\n         LA    R6,1(R6)\n         C     R6,FW2             CHECK IF ANY POSSIBLE DATA\n         BL    GETOPTNS\n         CLC   OPTNO,0(R8)        CHECK FOR 'NO'\n         BE    OPTNNO\n         C     R6,FW3             CHECK FOR APPROPRIATE LENGTHS\n         BL    GETOPTNS\n         C     R6,FW4\n         BNH   OPTL4\n         C     R6,FW6\n         BNH   OPTL6\n         C     R6,FW7\n         BNH   OPTL7\n         C     R6,FW8\n         BNH   OPTL8\n         C     R6,FW10\n         BNH   OPTL10\n\nOPTL10   EQU   *\n         CLC   OPTACT,0(R8)       CHECK FOR ACTION(...)\n         BNE   OPTL100\n         CLC   7(4,R8),OPTADDP\n         BNE   OPTL10A\n         MVC   DOTSLASH+4(4),OPTADD\n         LA    R14,L'OPTADDP\n         LA    R8,L'OPTACT(R8,R14)\n         B     OPTNSCAN\nOPTL10A  EQU   *\n         CLC   7(5,R8),OPTREPLP\n         BNE   OPTL100\n         MVC   DOTSLASH+4(4),OPTREPL\n         LA    R14,L'OPTREPLP\n         LA    R8,L'OPTACT(R8,R14)\n         B     OPTNSCAN\n\nOPTL100  EQU   *\n         CLC   OPTDUPO,0(R8)      CHECK FOR DUPS(ONLY)\n         BNE   OPTL1X\n         MVI   DEFDO,C'Y'\n         MVI   DEFD,C'Y'\n         LA    R8,L'OPTDUPO(R8)\n         B     OPTNSCAN\n\nOPTL1X   EQU   *\n         CLC   OPTGTMEM,0(R8)     CHECK FOR >MEMBER(...)\n         BNE   OPTL1Z\n         LA    R8,L'OPTGTMEM(R8)\n         LR    R14,R8\nOPTL1XA  EQU   *\n         CLI   0(R14),C')'\n         BE    OPTL1XB\n         LA    R14,1(R14)\n         CR    R14,R5\n         BH    OPTNEXT\n         B     OPTL1XA\nOPTL1XB  EQU   *\n         CR    R8,R14\n         BE    OPTNEXT\n         SR    R14,R8\n         BCTR  R14,0\n         MVC   DEFMEMG,BLANKS\n         EX    R14,MVCMEMGT\n         LA    R8,0(R14,R8)\n         B     OPTNSCAN\n\nOPTL1Z   EQU   *\n         CLC   OPTLTMEM,0(R8)     CHECK FOR <MEMBER(...)\n         BNE   OPTL8\n         LA    R8,L'OPTLTMEM(R8)\n         LR    R14,R8\nOPTL1YA  EQU   *\n         CLI   0(R14),C')'\n         BE    OPTL1YB\n         LA    R14,1(R14)\n         CR    R14,R5\n         BH    OPTNEXT\n         B     OPTL1YA\nOPTL1YB  EQU   *\n         CR    R8,R14\n         BE    OPTNEXT\n         SR    R14,R8\n         BCTR  R14,0\n         MVC   DEFMEML,BLANKS\n         EX    R14,MVCMEMLT\n         LA    R8,0(R14,R8)\n         B     OPTNSCAN\n\nOPTL8    EQU   *\n         CLC   OPTFIRST,0(R8)     CHECK FOR FIRST(...)\n         BNE   OPTL7\n         LA    R8,L'OPTFIRST(R8)\n         LR    R14,R8\nOPTL1FJ  EQU   *\n         CLI   0(R14),C')'\n         BE    OPTL1FK\n         LA    R14,1(R14)\n         CR    R14,R5\n         BH    OPTNEXT\n         B     OPTL1FJ\nOPTL1FK  EQU   *\n         CR    R8,R14\n         BE    OPTNEXT\n         SR    R14,R8\n         BCTR  R14,0\n         LR    R7,R8\n         EX    R14,OPTNUMCK\n         BNZ   OPTNEXT\n         EX    R14,OPTPACK\n         CVB   R15,DW\n         ST    R15,DEF1\n         LA    R8,1(R14,R8)\n         B     OPTNSCAN\n\nOPTL7    EQU   *\nOPTL6    EQU   *\nOPTL4    EQU   *\n         CLC   OPTDUPS,0(R8)      CHECK FOR DUPS\n         BNE   OPTNEXT\n         MVI   DEFD,C'Y'\n         LA    R8,L'OPTDUPS(R8)\n         B     OPTNSCAN\n\nOPTNEXT  LA    R8,1(R8)\n         B     OPTNSCAN\n\nOPTNNO   EQU   *                  CHECK FOR \"NO\" OPTIONS\n         LA    R8,2(R8)\n         BCTR  R6,0\n         BCTR  R6,0\n         C     R6,FW4             CHECK FOR APPROPRIATE LENGTHS\n         BNH   OPTN4\n         C     R6,FW6\n         BNH   OPTN6\n         C     R6,FW7\n         BNH   OPTN7\n\nOPTN7    EQU   *\nOPTN6    EQU   *\nOPTN4    EQU   *\n         CLC   OPTDUPS,0(R8)      CHECK FOR NEGATIVE DUPS\n         BNE   OPTNEXT\n         MVI   DEFD,C'N'\n         LA    R8,L'OPTDUPS(R8)\n         B     OPTNSCAN\n\nOPTNEXIT EQU   *\n         BR    R12\n\n***********************************************************************\n*    READ THE DIRECTORY(S)\n***********************************************************************\n\n*  R2 -> NUMBER OF SLOTS LEFT\n*  R3 -> END OF DIR ENTRY\n*  R4 -> MEMBER IN DIR ENTRY\n*  R6 -> NEW SLOT POINTER\n*  R7 -> IHADCB\n*  R8 -> CURRENT MEMBER IN SLOT LIST\n*  R9 -> NEXT MEMBER IN SLOT LIST\n\nREADDIR  EQU   *\n         LA    R2,1\n         LA    R7,DIR\n         LA    R8,EIGHTXFF\n         LR    R9,R8\n\nRDDIR010 EQU   *\n         GET   (R7)               GET A DIRECTORY BLOCK\n         LH    R3,0(R1)\n         LA    R4,2(R1)\n         LA    R3,0(R1,R3)\n\nRDDIR030 EQU   *\n         CR    R4,R3              END OF BLOCK?\n         BNL   RDDIR010\n         CLC   EIGHTXFF,0(R4)     TERMINATING ENTRY FOR A PDS?\n         BNE   RDDIR040\n         L     R14,CATCNT         GET READY FOR NEXT PDS (IF ANY)\n         LA    R14,1(R14)\n         ST    R14,CATCNT\n         FEOV  DIR\n         B     RDDIR010\n\nRDDIR040 EQU   *\n         CLC   DEFMEMG,0(R4)      SHOULD THIS MEMBER BE SELECTED?\n         BH    RDDIR110\n         CLC   DEFMEML,0(R4)\n         BL    RDDIR110\n         BCT   R2,RDDIR050\n         L     R0,FW12288         LOAD SLOT AREA SIZE FOR GETMAIN\n         STORAGE  OBTAIN,LENGTH=(0),LOC=ANY\n         LR    R6,R1              SAVE POINTER TO MEMBER SLOT AREA\n         LA    R2,614\n\nRDDIR050 EQU   *\n         MVC   SLOTOFFM(11,R6),0(R4)  SAVE DIRECTORY DATA INTO LIST\n         MVC   SLOTOFFC(1,R6),CATCNT+3\n         MVC   SLOTOFFX(L'DEFSLOT,R6),DEFSLOT\n         TM    11(R4),X'80'       CHECK IF ALIAS\n         BNO   RDDIR055\n         MVI   SLOTOFFA(R6),C'Y'\n\nRDDIR055 EQU   *\n         SR    R14,R14\n         IC    R14,11(R4)\n         SLL   R14,27             POINT TO NEXT DIRECTORY ENTRY\n         SRL   R14,26\n         LA    R4,12(R14,R4)\n         CLC   SLOTOFFM(8,R6),SLOTOFFM(R8)  PUT NEW MEMBER INTO CHAIN\n         BNL   RDDIR090\n         L     R8,FIRSTMEM\n         CLC   SLOTOFFM(8,R6),SLOTOFFM(R8)\n         BL    RDDIR080\n         L     R8,12(R8)\n         L     R9,12(R8)\n         CLC   SLOTOFFM(8,R6),SLOTOFFM(R8)  CHECK IF HIGHER THAN 2ND\n         BNL   RDDIR090\n         LR    R9,R8\n         L     R8,FIRSTMEM\n         B     RDDIR090\n\nRDDIR080 EQU   *\n         ST    R8,SLOTOFFN(R6)    NEW FIRST MEMBER\n         LR    R9,R8\n         ST    R6,FIRSTMEM\n         LR    R8,R6\n         LA    R6,SLOTSIZE(R6)\n         B     RDDIR030\n\nRDDIR090 EQU   *\n         CLC   SLOTOFFM(8,R6),SLOTOFFM(R9)  BETWEEN CURRENT AND NEXT?\n         BL    RDDIR100\n         LR    R8,R9\n         L     R9,12(R8)\n         B     RDDIR090\n\nRDDIR100 EQU   *\n         ST    R6,SLOTOFFN(R8)    STORE AS NEW BETWEEN\n         LR    R8,R6\n         ST    R9,SLOTOFFN(R6)\n         LA    R6,SLOTSIZE(R6)\n         B     RDDIR030\n\nRDDIR110 EQU   *\n         SR    R14,R14\n         IC    R14,11(R4)\n         SLL   R14,27             POINT TO NEXT DIRECTORY ENTRY\n         SRL   R14,26                WHEN MEMBER NOT SELECTED\n         LA    R4,12(R14,R4)\n         B     RDDIR030\n\nRDDIREOF EQU   *\n         BR    R12\n\n***********************************************************************\n*    DETERMINE WHICH ARE DUPS (FOR DUPS/DUPS(ONLY) USAGE\n***********************************************************************\n\n*  R8 -> CURRENT MEMBER IN SLOT LIST\n*  R9 -> NEXT MEMBER IN SLOT LIST\n\nDETDUPS  EQU   *\n         CLI   DEFD,C'Y'\n         BNE   DETDEXIT\n         L     R8,FIRSTMEM\n         L     R9,12(R8)\n\nDEFD010  EQU   *\n         CLC   SLOTOFFM(8,R8),EIGHTXFF\n         BE    DETDEXIT\n         CLC   SLOTOFFM(8,R8),SLOTOFFM(R9)\n         BNE   DEFD040\n         MVI   SLOTOFFD(R8),C'Y'\n         MVI   SLOTOFFD(R9),C'Y'\n\nDEFD040  EQU   *\n         LR    R8,R9\n         L     R9,SLOTOFFN(R8)\n         B     DEFD010\n\nDETDEXIT EQU   *\n         BR    R12\n\n***********************************************************************\n*    PUNCH MEMBER DATA\n***********************************************************************\n\n*  R2 -> LRECL SIZE\n*  R3 -> INPUT PDS MEMBER BUFFER\n*  R4 -> LINES OUTPUT\n*  R5 -> PAGE SIZE\n*  R6 -> FIND MEMBER POINTER, END OF DATA\n*  R7 -> IHADCB\n*  R8 -> CURRENT MEMBER IN SLOT LIST\n*  R9 -> DATA POINTER\n*  R14-> SHORT TERM RETURN POINTER (SAVED IN PUNCHRET)\n\nPUNCHMEM EQU   *\n         LA    R7,PDS\n         LH    R0,DCBBLKSI\n         STORAGE  OBTAIN,LENGTH=(0),LOC=ANY\n         LR    R3,R1\n         L     R8,FIRSTMEM\n         MVC   LASTMEMP,EIGHTX00\n\nPUNCH020 EQU   *\n         CLC   SLOTOFFM(8,R8),EIGHTXFF  LAST MEMBER PROCESSED?\n         BE    PUNCH990\n         CLI   DEFDO,C'Y'         CHECK FOR DUP ONLY STATUS\n         BNE   PUNCH030\n         CLI   SLOTOFFD(R8),C'Y'\n         BNE   PUNCH025\n         B     PUNCH040\n\nPUNCH025 EQU   *\n         MVC   SLOTOFFT(3,R8),EIGHTXFF\n         B     PUNCHEOF\n\nPUNCH030 EQU   *\n         CLI   DEFD,C'Y'          CHECK FOR DUP STATUS\n         BE    PUNCH040\n         CLC   SLOTOFFM(8,R8),LASTMEMP  FOR NODUPS, ELIM DUP MEMBERS\n         BE    PUNCH025\n\nPUNCH040 EQU   *\n         LA    R6,SLOTOFFT(R8)\n         FIND  PDS,(R6),C\n         SR    R4,R4              SET LINES PUNCHED SO FAR TO 0\n         MVC   DOTSLASH+15(8),SLOTOFFM(R8)\n         MVC   PNCHLINE,BLANKS\n         PUT   SYSPUNCH,DOTSLASH\n\nPUNCH060 EQU   *\n         READ  PDSDECB,SF,(R7),(R3),'S',MF=E\n         CHECK PDSDECB\n         LR    R9,R3\n         L     R14,PDSDECB+16     FIGURE DATA LENGTH ACTUALLY READ\n         LH    R6,DCBBLKSI\n         SH    R6,14(R14)\n         TM    DCBRECFM,DCBRECU\n         BO    PUNCHU\n         TM    DCBRECFM,DCBRECV\n         BO    PUNCHV\n\nPUNCHF   EQU   *                  FIXED RECFM\n         LA    R6,0(R6,R9)\n\nPUNCHF10 EQU   *\n         LH    R2,DCBLRECL\n         C     R2,FW80\n         BH    PUNCHF40\n         BCTR  R2,0\n         ST    R2,PUNLEN\n         EX    R2,MVCDATA\n         BAS   R14,PUNCHRTN\n         LA    R9,1(R2,R9)\n         CR    R9,R6\n         BL    PUNCHF10\n         B     PUNCH060\n\nPUNCHF40 EQU   *\n         MVC   PNCHLINE,0(R9)\n         MVC   PUNLEN,FW79\n         BAS   R14,PUNCHRTN\n         S     R2,FW80\n         LA    R9,80(R9)\n         B     PUNCHF10\n\nPUNCHU   EQU   *                  UNFORMATTED RECFM\n         LR    R2,R6\n         LA    R6,0(R6,R9)\n\nPUNCHU10 EQU   *\n         C     R2,FW80\n         BH    PUNCHU40\n         BCTR  R2,0\n         ST    R2,PUNLEN\n         EX    R2,MVCDATA\n         BAS   R14,PUNCHRTN\n         B     PUNCH060\n\nPUNCHU40 EQU   *\n         MVC   PNCHLINE,0(R9)\n\n         MVC   PUNLEN,FW79\n         BAS   R14,PUNCHRTN\n         S     R2,FW80\n         LA    R9,80(R9)\n         B     PUNCHU10\n\nPUNCHV   EQU   *                  VARIABLE RECFM\n         LH    R6,0(R9)\n         LA    R6,0(R6,R9)\n         LA    R9,4(R9)\n\nPUNCHV05 EQU   *\n         LH    R2,0(R9)\n         LA    R9,4(R9)\n         S     R2,FW4\n\nPUNCHV20 EQU   *\n         C     R2,FW80\n         BH    PUNCHV60\n         BCTR  R2,0\n         ST    R2,PUNLEN\n         EX    R2,MVCDATA\n         BAS   R14,PUNCHRTN\n         LA    R9,1(R2,R9)\n         CR    R9,R6\n         BL    PUNCHV05\n         B     PUNCH060\n\nPUNCHV60 EQU   *\n         MVC   PNCHLINE,0(R9)\n         MVC   PUNLEN,FW79\n         BAS   R14,PUNCHRTN\n         S     R2,FW80\n         LA    R9,80(R9)\n         B     PUNCHV20\n\nPUNCHEOF EQU   *                  END OF INDIVIDUAL MEMBER DATA\n         MVC   LASTMEMP,SLOTOFFM(R8)\n         L     R8,SLOTOFFN(R8)\n         B     PUNCH020\n\nPUNCH990 EQU   *                  EXIT FROM PUNCH MEMBER ROUTINE\n         BR    R12\n\n***********************************************************************\n*   GENERAL PUNCH ROUTINE FOR MEMBER DATA - REGISTERS ARE THE\n*   SAME AS FOR PUNCHMEM PLUS R14 IS USED TO RETURN TO PUNCHMEM\n***********************************************************************\n\nPUNCHRTN EQU   *\n         ST    R14,PUNCHRET\n         PUT   SYSPUNCH,PNCHLINE\n         MVC   PNCHLINE,BLANKS\n         LA    R4,1(R4)\n         C     R4,DEF1          CHECK IF REACHED LINES TO BE PUT OUT\n         BNL   PUNCHEOF\n         L     R14,PUNCHRET\n         BR    R14\n\n***********************************************************************\n*    CLOSE ALL DCBS AND FREE ANY OBTAINED STORAGE\n***********************************************************************\n\n*  R1 -> CLOSE MACRO\n*  R5 -> DCB\n*  R6 -> DCB\n*  R7 -> DCB\n\nCLOSERTN EQU   *\n         LA    R1,CLOSE           CLOSE FILES\n         LA    R5,DIR\n         LA    R6,PDS\n         LA    R7,SYSPUNCH\n         CLOSE ((R5),,(R6),,(R7)),MF=(E,(R1)),MODE=31\n         CLI   SYSINOK,C'Y'\n         BNE   CLOSEOUT\n         LA    R1,CLOSSYSI\n         LA    R5,SYSIN\n         CLOSE ((R5)),MF=(E,(R1)),MODE=31\n\nCLOSEOUT EQU   *\n         BR    R12\n\n***********************************************************************\n*    OFFSETS FOR SLOT LIST\n***********************************************************************\n\nSLOTSIZE EQU   20                 SLOT SIZE\n\nSLOTOFFM EQU    0                 MEMBER NAME\nSLOTOFFT EQU    8                 PDS TTR (INITIALLY)\nSLOTOFFC EQU   11                 PDS CONCATENATION COUNT\nSLOTOFFN EQU   12                 NEXT SLOT LIST MEMBER\nSLOTOFFX EQU   16                 ATTRIBUTES OF MEMBER\nSLOTOFFA EQU   16                 ALIAS\nSLOTOFFD EQU   17                 DUPLICATE\n\n***********************************************************************\n*    STATIC DATA\n***********************************************************************\n\nOPTACT   DC    CL7'ACTION('\nOPTADD   DC    CL4'ADD '\nOPTADDP  DC    CL7'ADD)'\nOPTREPL  DC    CL4'REPL'\nOPTREPLP DC    CL7'REPL)'\nOPTDUPO  DS   0CL10\nOPTDUPS  DC    CL4'DUPS'\n         DC    CL1'('\nONLY     DC    CL4'ONLY'\n         DC    CL1')'\nOPTFIRST DC    CL6'FIRST('\nOPTVARS  DC    CL6'VARSEQ'\nOPTLTMEM DC    CL8'<MEMBER('\nOPTGTMEM DC    CL8'>MEMBER('\n\nEIGHTX00 DS    CL08'0000000000000000'\nEIGHTXFF DS   0D   *****  LEAVE BEFORE NUMTABLE  *****\nNUMTABLE DC    240X'FF',010X'00',006X'FF'\n\nFW10     DC    F'10'\nFW12     DC    F'12'\nFW12288  DC    F'12288'\nFW2      DC    F'2'\nFW3      DC    F'3'\nFW4      DC    F'4'\nFW6      DC    F'6'\nFW7      DC    F'7'\nFW79     DC    F'79'\nFW8      DC    F'8'\nFW80     DC    F'80'\n\nMVCDATA  MVC   PNCHLINE(1),0(R9)\nMVCMEMGT MVC   DEFMEMG(1),0(R8)\nMVCMEMLT MVC   DEFMEML(1),0(R8)\nOPTPACK  PACK  DW,0(1,R7)\nOPTNUMCK TRT   0(1,R7),NUMTABLE\n\nDEFSLOT  DC    CL4'NNNN'\nBLANKS   DC    CL80' '\n\nYES      DC    CL3'YES'\nOPTNO    DS   0CL2\nNO       DC    CL3'NO '\n\n***********************************************************************\n*    LIST FORM OF I/O MACRO INSTRUCTIONS AND OTHER DYNAMIC DATA\n*    TO BE COPIED TO OBTAINED STORAGE\n***********************************************************************\n\nDYNAMA   DS    0D\n\n         PRINT NOGEN\nXPEN     OPEN  (XIR,(INPUT),XDS,(INPUT),XYSPUNCH,(OUTPUT)),MF=L,MODE=31\n\nXPENSYSI OPEN  (XYSIN,(INPUT)),MF=L,MODE=31\n\nXRDJFCB  RDJFCB  (XIR),MF=L\n\nXLOSE    CLOSE (XIR,,XDS,,XYSPUNCH),MF=L,MODE=31\n\nXLOSSYSI CLOSE (XYSIN),MF=L,MODE=31\n\nXEADPDS  READ  XDSDECB,SF,XDS,0,'S',MF=L\n\nXIR      DCB   DSORG=PS,MACRF=GL,DDNAME=&DDPDS,                        *\n               RECFM=F,LRECL=256,BLKSIZE=256,                          *\n               DCBE=XIRE\nXIRE     DCBE  RMODE31=BUFF,EODAD=RDDIREOF\n\nXDS      DCB   DSORG=PO,MACRF=R,DDNAME=&DDPDS,                         *\n               DCBE=XDSE\nXDSE     DCBE  RMODE31=BUFF,EODAD=PUNCHEOF\n\nXYSIN    DCB   DSORG=PS,MACRF=GL,DDNAME=&DDOPTS,                       *\n               RECFM=FB,LRECL=80,DCBE=XYSINE\nXYSINE   DCBE  RMODE31=BUFF,EODAD=OPTNEXIT\n\nXYSPUNCH DCB   DSORG=PS,MACRF=PM,DDNAME=&DDPUNCH,                      *\n               RECFM=FB,LRECL=80,BUFNO=32\n         PRINT   GEN\n\n         DS    0D\nXIRSTMEM DC    A(EIGHTXFF)\nXATCNT   DC    F'0'\n\n*  OPTIONS CHOSEN OR DEFAULTED\n\nXDEF1    DC    F'&DEF1ST'         FIRST # OF LINES\nXDEFD    DC    CL1'&DEFDUPS'      DUPS\nXDEFDO   DC    CL1'&DEFDUPSO'     DUPS ONLY\nXDEFMEMG DC    XL8'0000000000000000' FIRST MEMBER SELECTED\nXDEFMEML DC    XL8'FFFFFFFFFFFFFFFF' LAST MEMBER SELECTED\n\nXYSINOK  DC    CL1'Y'             SYSIN OPENED OK\nXOTSLASH DC    CL80'./  ADD   NAME='\n\nDYNAML   EQU   *-DYNAMA\n\n***********************************************************************\n*    DSECTS\n***********************************************************************\n\nWORKAREA DSECT\n\nSAVEAREA DS    9D\n\nDW       DS    D\nFINALRC  DS    F                  FINAL RETURN CODE\nEXLST    DS    F                  EXIT LIST FOR READ JFCB\nPUNCHRET DS    A                  RETURN ADDRESS FOR PUNCH SUBROUTINE\nPUNLEN   DS    F                  ACTUAL DATA LENGTH FOR HEX TRANSLATE\n*                                    AND CHARACTER TRANSLATE\nLASTMEMP DS    CL008              LAST MEMBER NAME PUNCHED\n\nPNCHLINE DS    CL80\n\nWORKL    EQU   (*-WORKAREA)\n\nWKINGSTG DS    0D  *  BEGIN DYNAMIC AREA REQUIRING INITIALIZATION -----\n\n         PRINT NOGEN\nOPEN     OPEN  (DIR,(INPUT),PDS,(INPUT),SYSPUNCH,(OUTPUT)),MF=L,MODE=31\n\nOPENSYSI OPEN  (SYSIN,(INPUT)),MF=L,MODE=31\n\nRDJFCB   RDJFCB  (DIR),MF=L\n\nCLOSE    CLOSE (DIR,,PDS,,SYSPUNCH),MF=L,MODE=31\n\nCLOSSYSI CLOSE (SYSIN),MF=L,MODE=31\n\nREADPDS  READ  PDSDECB,SF,0,0,'S',MF=L\n\nDIR      DCB   DSORG=PS,MACRF=GL,DDNAME=&DDPDS,                        *\n               RECFM=F,LRECL=256,BLKSIZE=256,                          *\n               DCBE=DIRE\nDIRE     DCBE  RMODE31=BUFF,EODAD=RDDIREOF\n\nPDS      DCB   DSORG=PO,MACRF=R,DDNAME=&DDPDS,                         *\n               DCBE=PDSE\nPDSE     DCBE  RMODE31=BUFF,EODAD=PUNCHEOF\n\nSYSIN    DCB   DSORG=PS,MACRF=GL,DDNAME=&DDOPTS,                       *\n               RECFM=FB,LRECL=80,DCBE=SYSINE\nSYSINE   DCBE  RMODE31=BUFF,EODAD=OPTNEXIT\n\nSYSPUNCH DCB   DSORG=PS,MACRF=PM,DDNAME=&DDPUNCH,                      *\n               RECFM=FB,LRECL=80,BUFNO=32\n         PRINT   GEN\n\n         DS    0D\nFIRSTMEM DS    A\nCATCNT   DS    F\n\n*  OPTIONS CHOSEN OR DEFAULTED\n\nDEF1     DS    F                  FIRST # OF LINES\nDEFD     DS    CL1                DUPS\nDEFDO    DS    CL1                DUPS ONLY\nDEFMEMG  DS    CL8                FIRST MEMBER SELECTED\nDEFMEML  DS    CL8                LAST MEMBER SELECTED\n\nSYSINOK  DS    CL1\nDOTSLASH DS    CL80\n\n*  END OF DYNAMIC AREA ------------------------------------------------\n\n***********************************************************************\n\n         PRINT NOGEN\n         DCBD  DSORG=(PS,PO),DEVD=DA\n\n         END   PDSPUNCH\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//***\n//L          EXEC     PGM=IEWL,\n//             PARM='RENT,AMODE(31),RMODE(ANY),XREF,LIST,LET,DCBS',\n//             REGION=4M,COND=(5,LE)\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,\n//             DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   00091400\n  ENTRY    PDSPUNCH\n  NAME     PDSPUNCH(R)\n//***\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDS2SEQ": {"ttr": 34055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\xa0\\x00\\xa0\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 160, "newlines": 160, "modlines": 0, "user": "REXX"}, "text": "/*  REXX -- Unload PDS members to a readable sequential file         */\n/*-------------------------------------------------------------------*/\n\n   arg inpds outseq optn1 optn2 .\n   If inpds = '' | inpds = '?' then signal DispDoc\n   optn1 = translate(optn1)\n   optn2 = translate(optn2)\n   nosep = 'NO'\n   addrepl = 'ADD'\n   If optn1 = 'ADD' then addrepl = 'ADD'\n   If optn2 = 'ADD' then addrepl = 'ADD'\n   If optn1 = 'REPLACE' then addrepl = 'REPLACE'\n   If optn2 = 'REPLACE' then addrepl = 'REPLACE'\n   If optn1 = 'NOSEP' then nosep = 'YES'\n   If optn2 = 'NOSEP' then nosep = 'YES'\n\n   DSNStatus = SYSDSN(inpds)\n   IF DSNStatus <> \"OK\" then do\n      Say inpds DSNStatus \":(\"\n      Exit(1)\n   End\n   DSNStatus = SYSDSN(outseq)\n   IF DSNStatus = \"OK\" then do\n      Say outseq \"already exists :(\"\n      Exit(1)\n   End\n\n   Say 'Unloading PDS' inpds 'to' outseq\n   LDSI = LISTDSI(inpds)\n   Address TSO\n\n   If length(SYSRECFM) > 1 then do\n      recfm = \"\"\n      DO II = 1 TO (LENGTH(SYSRECFM) - 1)\n         recfm = recfm || substr(SYSRECFM,II,1) || ' '\n      end\n      recfm = recfm || SUBSTR(SYSRECFM,LENGTH(SYSRECFM),1)\n   end\n   Else recfm = sysrecfm\n   \"ALLOC DD(OUTSEQ) DSN(\"outseq\")\",\n      \"LRECL(\"syslrecl\") BLKSIZE(\"sysblksize\") RECFM(\"recfm\")\",\n      \"SPACE(10,10) UNIT(SYSDA) CYL\"\n   RetCode = RC\n   If RetCode <> 0 then do\n      Say 'Allocation error on' outseq 'Return Code =' RetCode\n      Exit(1)\n   End\n\n   \"EXECIO 0 DISKW OUTSEQ (OPEN\"\n   RetCode = RC\n   If RetCode <> 0 then do\n      Say 'Open error on' outseq 'Return Code =' RetCode\n      Exit(1)\n   End\n\n   x = outtrap(mem.)\n   \"LISTDS\" inpds \"MEMBERS\"\n   RetCode = RC\n   If RetCode <> 0 then do\n      Say 'ListDS error on' outseq 'Return Code =' RetCode\n      Exit(1)\n   End\n   x = outtrap('off')\n   do II = 1 to mem.0\n       if mem.II = \"--MEMBERS--\" then leave\n   end\n\n   count = 0\n   Do JJ = II+1 to mem.0\n      count = count + 1\n      member = strip(mem.JJ)\n      sepcard = './ ' addrepl 'NAME='member\n      If substr(inpds,1,1) = \"'\" then do\n         dsn = substr(inpds,1,length(inpds)-1) || '(' || member,\n            || ')' || substr(inpds,length(inpds),1)\n      End\n      Else dsn = inpds || '(' || member || ')'\n      \"ALLOC DD(\"member\") DSN(\"dsn\") SHR\"\n      RetCode = RC\n      If RetCode <> 0 then do\n         Say 'Open error on' inpds 'member' member,\n            'Return Code =' RetCode\n         Exit(1)\n      End\n     \"EXECIO * DISKR\" member \"(STEM LINES. FINIS\"\n      EXITRC = RC\n      RetCode = RC\n      If RetCode <> 0 then do\n         Say 'I/O read error on' inpds 'member' member,\n            'Return Code =' RetCode\n         Exit(1)\n      End\n      If nosep <> 'YES' then do\n         queue sepcard\n        \"EXECIO 1 DISKW OUTSEQ\"\n         RetCode = RC\n         If RetCode <> 0 then do\n            Say 'I/O output error on' inpds 'member' member './ image',\n               'Return Code =' RetCode\n            Exit(1)\n         End\n      End\n\n      \"EXECIO * DISKW OUTSEQ (STEM LINES.\"\n      RetCode = RC\n      If RetCode <> 0 then do\n         Say 'I/O output error on' inpds 'member' member,\n            'Return Code =' RetCode\n         Exit(1)\n      End\n      \"FREE DD(\"member\")\"\n      RetCode = RC\n      If RetCode <> 0 then do\n         Say 'Free error on' inpds 'member' member,\n            'Return Code =' RetCode\n         Exit(1)\n      End\n\n      drop lines.\n   End JJ\n   \"EXECIO 0 DISKW OUTSEQ (FINIS\"\n   RetCode = RC\n   If RetCode <> 0 then do\n      Say 'Close error on' outseq 'Return Code =' RetCode\n      Exit(1)\n   End\n   \"FREE DD(OUTSEQ)\"\n   RetCode = RC\n   If RetCode <> 0 then do\n      Say 'Free error on' outseq 'Return Code =' RetCode\n      Exit(1)\n   End\n   Say '   ' count 'members unloaded...'\n   Exit(0)\n\nDispDoc:\n   Address TSO \"CLEAR\"\n   Say \"                                                             \"\n   Say \"  PDS2Seq   unloads the specified PDS into a sequential file \"\n   Say \"            with or without IEBUPDTE separator cards. The    \"\n   Say \"            LRECL and BLKSIZE of the PDS are used for the    \"\n   Say \"            output file.                                     \"\n   Say \"                                                             \"\n   Say \"  syntax:   PDS2SEQ  PDS-name  OutSeq <NOSEP> <ADD|REPLACE>  \"\n   Say\n   Say \"            PDS-name is the input PDS                        \"\n   Say\n   Say \"            OutSeq is the name, either quoted or not, of the \"\n   Say \"            sequential output file to be created.            \"\n   Say\n   Say \"            <NOSEP>  is an optional parameter to indicate    \"\n   Say \"            whether IEBUPDTE separator cards are generated.  \"\n   Say \"            The default is to have them.                     \"\n   Say\n   Say \"            <ADD|REPLACE> specifies the add or replace option\"\n   Say \"            to be used on IEBUPDTE cards (if generated) - the\"\n   Say \"            default is ADD.                                  \"\n   Say\n   exit(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PK": {"ttr": 34059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xf8\\x00\\xf8\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 248, "newlines": 248, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- PK COLUMNS ONTO SAME OR OTHER COLUMNS  **/\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'PK MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (FRMLEFT,FRMRIGHT,PARMS)\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY PK 'EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT',\n         'WITH NO PENDING EDIT COMMANDS!'\n      SIGNAL EOJ\n   END\n   ADDRESS ISREDIT \"CAPS OFF\"\n\n   ERRORMSG = ''\n   MESG     = ''\n   IF FRMLEFT = ''  |  FRMRIGHT = ''  THEN DO\n      MESG = 'PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMLEFT,'W')  |  FRMLEFT = 0  THEN DO\n      MESG = \"'\"FRMLEFT\"' VALUE OF FROM-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMRIGHT,'W')  |  FRMRIGHT = 0  THEN DO\n      MESG = \"'\"FRMRIGHT\"' VALUE OF FROM-RIGHT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF FRMLEFT > FRMRIGHT THEN DO\n      MESG = \"FROM-LEFT-COL \"FRMLEFT\" IS > THAN FROM-RIGHT-COL \"FRMRIGHT\n      SIGNAL ERROR\n   END\n\n   PARMS   = TRANSLATE(PARMS)\n   LBL1    = \"\"\n   LBL2    = \"\"\n   TOLEFT  = \"\"\n   TORIGHT = \"\"\n   MINUS   = 0\n   DO II = 1 TO 7;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n      END\n      ELSE IF SUBSTR(TOKEN,1,1) = \"-\" THEN DO\n         MINUS = SUBSTR(TOKEN,2)\n      END\n      ELSE DO\n         IF DATATYPE(TOKEN,'W')  THEN DO\n            IF TOLEFT = \"\" THEN TOLEFT = TOKEN\n            ELSE IF TORIGHT = \"\" THEN TORIGHT = TOKEN\n               ELSE DO\n                  ZEDSMSG = \".LABEL RC=8\"\n                  ZEDLMSG = \"TOO MANY COLUMNS --\" TOLEFT TORIGHT TOKEN\n                  ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n                  EXIT 8\n               END\n         END\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n   IF TOLEFT <> \"\" AND TORIGHT = \"\" THEN TORIGHT = TOLEFT\n   IF TOLEFT = \"\" THEN DO\n      TOLEFT  = FRMLEFT\n      TORIGHT = FRMRIGHT\n   END\n\n   IF \u00acDATATYPE(TOLEFT,'W')  |  TOLEFT=0  THEN DO\n      MESG = \"'\"TOLEFT\"' VALUE OF TO-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(TORIGHT,'W')  |  TORIGHT=0  THEN DO\n      MESG = \"'\"TORIGHT\"' VALUE OF TO-RIGHT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   LEN = FRMRIGHT - FRMLEFT + 1\n   IF TOLEFT > TORIGHT THEN DO\n      MESG = \"TO-LEFT-COL \"TOLEFT\" IS GREATER THAN TO-RIGHT-COL \"TORIGHT\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF TORIGHT > LRECL THEN DO\n      MESG = \"TO-RIGHT COLUMN IS GREATER THAN RECORD SIZE (\"LRECL\")\"\n      SIGNAL ERROR\n   END\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR \"\n   \"ISREDIT (\"ANUM\") = AUTONUM \"\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n\n   START = 1\n   IF LBL1 <> '' THEN\n       \"ISREDIT (START) = LINENUM &LBL1\"\n\n   IF LBL2 <> '' THEN\n        \"ISREDIT (END) = LINENUM &LBL2\"\n   ELSE\n        LBL2 = LBL1\n\n   IF START > END THEN DO\n      WST = START\n      START = END\n      END = WST\n   END\n\n   HEX_ZEROS  = '000000000000000000000000000000'X\n   GOOD_NUM   = '0123456789'\n   GOOD_SIGN  = '{ABCDEFGHI}JKLMNOPQR0123456789'\n   FROM_SIGN  = '{ABCDEFGHI}JKLMNOPQR0123456789'\n   TO_SIGN    = '0C1C2C3C4C5C6C7C8C9C'X,\n             || '0D1D2D3D4D5D6D7D8D9D'X,\n             || '0F1F2F3F4F5F6F7F8F9F'X\n   TO_MINUS   = '0D1D2D3D4D5D6D7D8D9D'X,\n             || '0D1D2D3D4D5D6D7D8D9D'X,\n             || '0D1D2D3D4D5D6D7D8D9D'X\n   TO_PLUS    = '0C1C2C3C4C5C6C7C8C9C'X,\n             || '0C1C2C3C4C5C6C7C8C9C'X,\n             || '0C1C2C3C4C5C6C7C8C9C'X\n\n   TOT  = 0\n   OK   = 0\n   OVFL = 0\n   DO PNTR =  START  TO  END  BY 1\n      TOT = TOT + 1\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      IF VERIFY(SUBSTR(RECORD,FRMLEFT,FRMRIGHT-FRMLEFT),GOOD_NUM) = 0,\n            & VERIFY(SUBSTR(RECORD,FRMRIGHT,1),GOOD_SIGN) = 0\n         THEN DO\n            OK = OK + 1\n            USTR = X2C(SUBSTR(RECORD,FRMLEFT,FRMRIGHT-FRMLEFT))\n            IF MINUS = 0,\n               THEN DO\n                  ZSTR = SUBSTR(RECORD,FRMRIGHT,1)\n                  ZSTR = TRANSLATE(ZSTR,TO_SIGN,FROM_SIGN)\n               END\n               ELSE DO\n                  ZSTR = SUBSTR(RECORD,FRMRIGHT,1)\n                  IF SUBSTR(RECORD,MINUS,1) = '-',\n                     THEN ZSTR = TRANSLATE(ZSTR,TO_MINUS,FROM_SIGN)\n                     ELSE ZSTR = TRANSLATE(ZSTR,TO_PLUS,FROM_SIGN)\n               END\n            USTR = USTR || ZSTR\n            IF LENGTH(USTR) > TORIGHT - TOLEFT + 1,\n               THEN DO\n                  RECORD = SUBSTR(RECORD,1,TOLEFT-1),\n                     || SUBSTR(USTR,LENGTH(USTR)-TORIGHT+TOLEFT),\n                     || SUBSTR(RECORD,TORIGHT+1)\n                  USTRO = LENGTH(USTR) - TORIGHT + TOLEFT - 1\n                  ZEROS = COPIES('0',USTRO)\n                  IF SUBSTR(RECORD,FRMLEFT,USTRO) <> ZEROS,\n                     THEN OVFL = OVFL + 1\n               END\n               ELSE DO\n                  USTR0  = TORIGHT - TOLEFT + 1 - LENGTH(USTR)\n                  ZEROS  = SUBSTR(HEX_ZEROS,1,USTR0)\n                  ZEROS  = ZEROS || USTR\n                  RECORD = SUBSTR(RECORD,1,TOLEFT-1),\n                     || ZEROS || SUBSTR(RECORD,TORIGHT+1)\n               END\n         END\n      \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n   END\n\n   STR = OK || '/' || OVFL || '/' || TOT\n   CALL SETMSG '* NO ' STR 'PKED $VALID OVER OVERFLOW OVER TOTAL'\n   \"ISREDIT LOCATE\" START\n   \"ISREDIT AUTONUM =\" ANUM\n    SIGNAL EOJ\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   CALL DISPDOC\n\nEOJ:\n   SAY \"PLEASE NOTE, CAPS IS NOW OFF...\"\n   X = MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"PK - PACK DECIMALS BY COLUMNS \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    PK  FROM-COL1 FROM-COL2  (TO-COL1 TO-COL2) \"\n   SAY \"              (-MINUS-COL)  (.A .B)            \"\n   SAY\n   SAY \"       FROM-COLUMNS ARE REQUIRED. TO-COLUMNS WILL DEFAULT \"\n   SAY \"       TO FROM COLUMNS.  THE MINUS COLUMN AND THE LABEL   \"\n   SAY \"       RANGES ARE OPTIONAL.  THE CAPS OPTION WILL BE      \"\n   SAY \"       TURNED OFF TO PROTECT THE NEW DATA.                \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    PK  1 8  .A .B  -9                               \"\n   SAY \"       WILL PK THE CONTENTS OF COLUMNS 1 THRU 8 ON   \"\n   SAY \"       TOP OF THOSE SAME COLUMNS AND PLACE THE + OR  \"\n   SAY \"       MINUS FROM COLUMN 9 IN THE SIGN PORTION OF    \"\n   SAY \"       COLUMN 8 IN THE RANGE OF .A THROUGH .B.       \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PULL": {"ttr": 34308, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00D\\x00D\\x00\\x00\\xd7\\xe4\\xd3\\xd3@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "PULL"}, "text": "//-YOUR-USERID-P JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  SELECT SPECIFIC RECORDS OFF A SEQUENTIAL FILE\n//***\n//C          EXEC     PGM=IEL0AA,REGION=4M,\n//             PARM=('AG,A,NCT,ESD,F(I),NOFLOW,NIS,NOLIST,M,NMI,NEST',\n//             'MAP,OF,OPT(TIME),OP,SZ(MAX),S,STMT,STG,X(F)')\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-PLI-LIB-\n\n PULL:  PROC OPTIONS(MAIN) REORDER;\n\n        DCL  PULL#(2048,2) FIXED BIN(31) STATIC;\n        DCL  PULL_CNT      FIXED BIN(31) STATIC INIT(0);\n        DCL (II,JJ,KK)     FIXED BIN(31) STATIC;\n        DCL (LL,MM,NN)     FIXED BIN(31) STATIC;\n        DCL  REC           CHAR(32760) STATIC VARYING;\n        DCL  SYSIN_EOF_IND CHAR(00001) STATIC INIT('N');\n\n        ON ENDFILE(SYSIN) SYSIN_EOF_IND = 'Y';\n        READ FILE(SYSIN) INTO(REC);\n        DO PULL_CNT = 1 TO HBOUND(PULL#,1)\n                WHILE ( SYSIN_EOF_IND = 'N' );\n            PULL#(PULL_CNT,1) = SUBSTR(REC,01,8);\n            PULL#(PULL_CNT,2) = SUBSTR(REC,11,8);\n            READ FILE(SYSIN) INTO(REC);\n            END;\n        PULL_CNT = PULL_CNT - 1;\n\n        ON ENDFILE(I) GOTO I_EOF;\n        NN = 0;\n        DO II = 1 TO PULL_CNT;\n            IF PULL#(II,1) > NN\n                THEN DO JJ = ( NN + 1 ) TO ( PULL#(II,1) - 1);\n                    READ FILE(I) INTO(REC);\n                    END;\n            NN = JJ - 1;\n            DO JJ = ( NN + 1 ) TO ( PULL#(II,1) + PULL#(II,2) - 1 );\n                READ FILE(I) INTO(REC);\n                WRITE FILE(O) FROM(REC);\n                END;\n            NN = JJ - 1;\n            END;\n\n I_EOF:\n\n        END PULL;\n\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(CYL,(05,02))\n//***\n//L          EXEC     PGM=HEWLKED,\n//             PARM='XREF,LIST,LET,DCBS,AMODE(31),RMODE(ANY)',\n//             REGION=4M\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE)\n//             DD       *\n  SETSSI   99121500\n  ENTRY    PLISTART\n  NAME     PULL(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PULL$": {"ttr": 34310, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x15\\x00\\x15\\x00\\x00\\xd7\\xe4\\xd3\\xd3@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "PULL"}, "text": "//-YOUR-USERID-P JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//*** PULL RECORD# FOR # OF RECORDS FROM FILE I TO FILE O\n//***\n//CLEANUP    EXEC     PGM=IEFBR14\n//DEL01        DD       DSN=...,\n//             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n//***\n//PULL       EXEC     PGM=PULL,REGION=4M,COND=(5,LT)\n//SYSIN        DD       *         -- REC# IN 1-8; # RECS IN 11-18 --\n00000001  00000030\n00000444  00000030\n//I            DD       DISP=SHR,DCB=BUFNO=32,\n//             DSN=...\n//O            DD       DSN=...,\n//             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(010,010),RLSE),\n//             DCB=(BUFNO=32,RECFM=??,LRECL=?????,BLKSIZE=0)\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSPRINT     DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PY": {"ttr": 34312, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00>\\x00>\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 62, "newlines": 62, "modlines": 0, "user": "REXX"}, "text": "/** REXX - Put lines from the default clipboard after the cursor **/\n\n   Address ISPEXEC\n   'ISREDIT MACRO (PARM1)   PROCESS'\n   Parm1 = translate(Parm1)\n   If Parm1 = '?' then signal DispDoc\n\n   'ISREDIT (Line,Col) = CURSOR'\n   'ISREDIT (ZDest)    = CURSOR'\n   If ZDest = 1  then do\n       'VGET (ZSCREENC,ZSCREENI) SHARED'\n       ii = INDEX(ZScreenI,'* Top of Data *')\n       If ( ZScreenC % 80 )  <=  ( ii % 80 )  then ZDest = 0\n       Else ZDest = 1\n   End\n\n   DATA      = \"...\"\n   CutCount  = -1\n   \"ISREDIT LINE_AFTER &ZDEST = (DATA)\"\n   ii = ZDest + 1\n   \"ISREDIT LABEL\" ii \"= .HERE\"\n   If CutCount = -1 then do\n      \"ISREDIT LINE_AFTER\" ii \"= (DATA)\"\n      jj = ii + 1\n      \"ISREDIT LABEL\" jj \"= .THERE\"\n   End\n   Address ISREDIT \"PASTE AFTER .HERE KEEP\"\n   If RC = 12 then do\n      zedsmsg = 'No \"CUT\" data'\n      zedlmsg = 'There is no data to \"PASTE\" from the ISPF' ,\n                'Default Clipboard.'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n      Exit 12\n   End\n   If CutCount = -1 then do\n      \"ISREDIT (ii) = LINENUM .HERE\"\n      \"ISREDIT (jj) = LINENUM .THERE\"\n      CutCount = jj - ii - 1\n      \"ISREDIT DELETE .THERE .THERE\"\n   End\n   \"ISREDIT DELETE .HERE .HERE\"\n\n   zedsmsg = CutCount 'lines pasted'\n   zedlmsg = CutCount 'lines were pasted into the current file'\n   'SETMSG MSG(ISRZ000)'\n   If Line = 0 & Col = 0 then Exit(1)\n   Else do\n      'ISREDIT CURSOR = ' Line Col\n      Exit\n   End\n\nDispDoc:\n   ADDRESS TSO \"CLEAR\"\n   Say\n   Say ' PY '\n   Say\n   Say ' Enter PY on the COMMAND line and position the cursor on   '\n   Say ' the line after which the cut data is to be inserted. Assign  '\n   Say ' PY to a PF Key and you can just position the cursor and   '\n   Say ' press the PF Key, as often as desired and across files.      '\n   Say\n   Exit(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QCLONE": {"ttr": 34314, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x01A\\x01A\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 321, "newlines": 321, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- CREATE BY JOB ANOTHER VERSION OF A D/S UNDER ISPF 3.4  **/\n\n   PARSE ARG PARMS\n   MSG = MSG(OFF)\n   PARMS = TRANSLATE(PARMS)\n\n   ZINPDSN = \"\"\n   ZNEWDSN = \"\"\n   OPTION  = \"\"\n   NUMOPT  = \"\"\n   NUMCHG  = \"\"\n   RELOPT  = \"\"\n   Q       = 0\n\n   IF WORD(PARMS,2) = \"\" | WORD(PARMS,1) = \"?\"\n      THEN SIGNAL DISPDOC\n\n   DO II = 1 TO 9\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF TOKEN = \"EMPTY\" THEN OPTION = TOKEN\n      ELSE IF TOKEN = \"RELEASE\" THEN RELOPT = \"RELEASE\"\n      ELSE IF SUBSTR(TOKEN,1,1) = \"+\" | SUBSTR(TOKEN,1,1) = \"-\"\n         THEN DO\n            NUMOPT = \"CHG\"\n            NUMCHG = TOKEN\n         END\n      ELSE IF DATATYPE(TOKEN,'W')\n         THEN DO\n            NUMOPT = \"NEW\"\n            NUMCHG = TOKEN\n         END\n      ELSE IF SUBSTR(TOKEN,1,1) = \"=\",\n            | SUBSTR(TOKEN,LENGTH(TOKEN),1) = \"=\"\n         THEN ZNEWDSN = TOKEN\n      ELSE IF SUBSTR(TOKEN,1,1) = \"Q\" & DATATYPE(SUBSTR(TOKEN,2),'W')\n         THEN Q = SUBSTR(TOKEN,2)\n      ELSE DO\n         IF ZNEWDSN = \"\" THEN ZNEWDSN = TOKEN\n                         ELSE ZINPDSN = TOKEN\n      END\n   END II\n\n   IF SUBSTR(ZNEWDSN,1,1) = \"=\" THEN DO\n      IF Q = 0 THEN ZNEWDSN = SUBSTR(ZINPDSN,1,LENGTH(ZINPDSN)-1),\n         || SUBSTR(ZNEWDSN,2) || \"'\"\n      ELSE DO\n         NN = LENGTH(ZINPDSN) - 1\n         DO PP = 1 TO Q\n            DO II = NN TO 1 BY -1 WHILE(SUBSTR(ZINPDSN,II,1) <> \".\")\n            END II\n            NN = II - 1\n         END PP\n         ZNEWDSN = SUBSTR(ZINPDSN,1,NN) || SUBSTR(ZNEWDSN,2) || \"'\"\n      END\n   END\n   ELSE IF SUBSTR(ZNEWDSN,LENGTH(ZNEWDSN),1) = \"=\" THEN DO\n      IF Q = 0 THEN ZNEWDSN = \"'\",\n         || SUBSTR(ZNEWDSN,1,LENGTH(ZNEWDSN)-1) || SUBSTR(ZINPDSN,2)\n      ELSE DO\n         NN = 2\n         DO PP = 1 TO Q\n            DO II = NN TO LENGTH(ZINPDSN)-1,\n                  WHILE(SUBSTR(ZINPDSN,II,1) <> \".\")\n            END II\n            NN = II + 1\n         END PP\n         ZNEWDSN = \"'\" || SUBSTR(ZNEWDSN,1,LENGTH(ZNEWDSN)-1),\n            || SUBSTR(ZINPDSN,NN,LENGTH(ZINPDSN)-NN+1)\n      END\n   END\n\n   IF SYSDSN(ZNEWDSN) = \"OK\" THEN DO\n      SAY \"***> NEW DATA SET ALREADY EXISTS\"\n      EXIT(1)\n   END\n   USER_ID = USERID()\n   LDSI = LISTDSI(ZINPDSN DIRECTORY)\n\n   IF OPTION <> \"EMPTY\" THEN DO\n      IF SYSDSORG = PO & SYSADIRBLK <> \"NO_LIM\" & NUMOPT <> \"\" THEN DO\n         IF NUMOPT = \"NEW\" THEN DIRCNT = NUMCHG\n         ELSE DIRCNT = SYSADIRBLK + NUMCHG\n         IF DIRCNT < SYSUDIRBLK THEN DO\n               SAY \"***> NEW NUMBER OF DIRECTORY BLOCKS (\"DIRCNT\")\",\n                  \"MAY NOT\"\n               SAY \"***> BE LESS THEN THE NUMBER CURRENTLY IN USE\",\n                  \"(\"SYSUDIRBLK\")\"\n               EXIT(1)\n         END\n      END\n      ADDRESS TSO\n      \"FREE DD(SUBXDD)\"\n      \"ALLOC DD(SUBXDD) SYSOUT(A) WRITER(INTRDR)\",\n         \"LRECL(80) BLKSIZE(800) RECFM(F B)\"\n      QUEUE \"//\" || USER_ID || \"Q    JOB      (ACCT-INFO),'\",\n         || USER_ID || \"',\"\n      QUEUE \"//             CLASS=2,MSGCLASS=X,NOTIFY=\",\n         || USER_ID\n      QUEUE \"//***\"\n      IF SUBSTR(ZNEWDSN,1,1) <> \"'\"\n         THEN ZNEWDSN = USER_ID || \".\" || ZNEWDSN\n         ELSE ZNEWDSN = SUBSTR(ZNEWDSN,2,LENGTH(ZNEWDSN)-2)\n      ZINPDSN = SUBSTR(ZINPDSN,2,LENGTH(ZINPDSN)-2)\n\n      IF SYSDSORG = PO THEN DO\n         QUEUE \"//QCLONE     EXEC     PGM=IEBCOPY,REGION=6M\"\n         QUEUE \"//SYSPRINT     DD       SYSOUT=*\"\n         QUEUE \"//SORTIN       DD       DISP=SHR,\"\n         QUEUE \"//             DSN=\" || ZINPDSN\n         IF SYSADIRBLK = \"NO_LIM\" THEN DO\n            IF RELOPT = \"RELEASE\" THEN DO\n               IF SUBSTR(SYSUNITS,1,1) = \"C\" THEN SU = \"CYL\"\n                                             ELSE SU = \"TRK\"\n               QUEUE \"//SORTOUT     DD       DSN=\" || ZNEWDSN || \",\"\n               QUEUE \"//            DISP=(,CATLG),UNIT=SYSDA,\"\n               QUEUE \"//            SPACE=(\" || SU || \",(\",\n                  || SYSALLOC || \",\" || SYSSECONDS,\n                  || \"),RLSE),\"\n               QUEUE \"//            LIKE=\" || ZINPDSN || \",\"\n               QUEUE \"//            DSNTYPE=LIBRARY\"\n            END\n            ELSE DO\n               QUEUE \"//SORTOUT     DD       DSN=\" || ZNEWDSN || \",\"\n               QUEUE \"//            DISP=(,CATLG),UNIT=SYSDA,\"\n               QUEUE \"//            LIKE=\" || ZINPDSN || \",\"\n               QUEUE \"//            DSNTYPE=LIBRARY\"\n            END\n         END\n         ELSE DO\n            IF NUMOPT = \"\" THEN DO\n               IF RELOPT = \"RELEASE\" THEN DO\n                  IF SUBSTR(SYSUNITS,1,1) = \"C\" THEN SU = \"CYL\"\n                                                ELSE SU = \"TRK\"\n                  QUEUE \"//SORTOUT     DD       DSN=\" || ZNEWDSN || \",\"\n                  QUEUE \"//            DISP=(,CATLG),UNIT=SYSDA,\"\n                  QUEUE \"//            SPACE=(\" || SU || \",(\",\n                     || SYSALLOC || \",\" || SYSSECONDS,\n                     || \",\" || SYSADIRBLK,\n                     || \"),RLSE),\"\n                  QUEUE \"//            LIKE=\" || ZINPDSN\n               END\n               ELSE DO\n                  QUEUE \"//SORTOUT     DD       DSN=\" || ZNEWDSN || \",\"\n                  QUEUE \"//            DISP=(,CATLG),UNIT=SYSDA,\"\n                  QUEUE \"//            LIKE=\" || ZINPDSN\n               END\n            END\n            ELSE DO\n               IF NUMOPT = \"NEW\" THEN DIRCNT = NUMCHG\n               ELSE DIRCNT = SYSADIRBLK + NUMCHG\n               IF SUBSTR(SYSUNITS,1,1) = \"C\" THEN SU = \"CYL\"\n                                             ELSE SU = \"TRK\"\n               IF RELOPT = \"RELEASE\" THEN SP_CLOSE = \"),RLSE),\"\n                                     ELSE SP_CLOSE = \")),\"\n               QUEUE \"//SORTOUT      DD       DSN=\" || ZNEWDSN || \",\"\n               QUEUE \"//             DISP=(,CATLG),UNIT=SYSDA,\"\n               QUEUE \"//             SPACE=(\" || SU || \",(\",\n                  || SYSALLOC || \",\" || SYSSECONDS || \",\",\n                  || DIRCNT || SP_CLOSE\n               QUEUE \"//             LIKE=\" || ZINPDSN\n            END\n         END\n         QUEUE \"  COPY  INDD=SORTIN,OUTDD=SORTOUT\"\n         QUEUE \"//***\"\n         \"EXECIO\" QUEUED() \"DISKW SUBXDD (FINIS\"\n         \"FREE DD(SUBXDD)\"\n         CALL SETMSG \"* NO JOB SUBMITTED$JOB SUBMITTED SUCCESSFULLY!\"\n      END\n      ELSE IF SYSDSORG = \"PS\" | SYSDSORG = \"PS-E\" THEN DO\n         QUEUE \"//QCLONE     EXEC     PGM=SORT,REGION=64M\"\n         QUEUE \"//SYSPRINT     DD       SYSOUT=*\"\n         QUEUE \"//SORTLIST     DD       SYSOUT=*\"\n         QUEUE \"//SYSOUT       DD       SYSOUT=*\"\n         QUEUE \"//SORTIN       DD       DISP=SHR,\"\n         QUEUE \"//             DSN=\" || ZINPDSN\n         IF NUMOPT = \"\" THEN DO\n            QUEUE \"//SORTOUT      DD       DSN=\" || ZNEWDSN || \",\"\n            QUEUE \"//             DISP=(,CATLG),UNIT=SYSDA,\"\n            IF RELOPT = \"RELEASE\" THEN DO\n               IF SUBSTR(SYSUNITS,1,1) = \"C\" THEN SU = \"CYL\"\n                                             ELSE SU = \"TRK\"\n               QUEUE \"//             SPACE=(\" || SU || \",(\",\n                  || SYSALLOC || \",\" || SYSSECONDS || \"),RLSE),\"\n            END\n            QUEUE \"//             LIKE=\" || ZINPDSN\n            QUEUE \"  SORT  FIELDS=COPY\"\n         END\n         ELSE DO\n            IF NUMOPT = \"NEW\" THEN NEWLRECL = NUMCHG\n            ELSE NEWLRECL = SYSLRECL + NUMCHG\n            IF SYSRECFM = \"VB\"\n               THEN NEWBLKSIZE = SYSBLKSIZE\n               ELSE NEWBLKSIZE = NEWLRECL * (27998%NEWLRECL)\n            QUEUE \"//SORTOUT     DD       DSN=\" || ZNEWDSN || \",\"\n            QUEUE \"//            DISP=(,CATLG),UNIT=SYSDA,\"\n            IF RELOPT = \"RELEASE\" THEN DO\n               IF SUBSTR(SYSUNITS,1,1) = \"C\" THEN SU = \"CYL\"\n                                             ELSE SU = \"TRK\"\n               QUEUE \"//             SPACE=(\" || SU || \",(\",\n                  || SYSALLOC || \",\" || SYSSECONDS || \"),RLSE),\"\n            END\n            QUEUE \"//            LIKE=\" || ZINPDSN || \",\"\n            QUEUE \"//            LRECL=\" || NEWLRECL || \",\",\n               || \"BLKSIZE=\" || NEWBLKSIZE\n            QUEUE \"  SORT    FIELDS=COPY\"\n            IF NEWLRECL > SYSLRECL & INDEX(SYSRECFM,'F') <> 0 THEN DO\n               PAD = NEWLRECL - SYSLRECL\n               OUTREC_STR = \"  OUTREC  FIELDS=(1,\" || SYSLRECL,\n                  || \",\" || PAD || \"X)\"\n               QUEUE OUTREC_STR\n            END\n         END\n         QUEUE \"//***\"\n         \"EXECIO\" QUEUED() \"DISKW SUBXDD (FINIS\"\n         \"FREE DD(SUBXDD)\"\n         CALL SETMSG \"* NO JOB SUBMITTED$JOB SUBMITTED SUCCESSFULLY!\"\n      END\n   END\n   ELSE DO\n      ADDRESS TSO\n      IF SYSDSORG = PO THEN DO\n         IF SYSADIRBLK = \"NO_LIM\" THEN DO\n            \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n               \"DSNTYPE(LIBRARY) DD(SORTOUT) UNIT(SYSDA)\"\n            IF RC <> 0 THEN DO\n               SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n               SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n               EXIT(1)\n            END\n         END\n         ELSE DO\n            IF NUMOPT = \"\" THEN DO\n               \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n                  \"DIR(\"SYSADIRBLK\") UNIT(SYSDA)\"\n               IF RC <> 0 THEN DO\n                  SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n                  SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n                  EXIT(1)\n               END\n            END\n            ELSE DO\n               IF NUMOPT = \"NEW\" THEN DIRCNT = NUMCHG\n               ELSE DIRCNT = SYSADIRBLK + NUMCHG\n               \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n                  \"DIR(\"DIRCNT\") DD(SORTOUT) UNIT(SYSDA)\"\n               IF RC <> 0 THEN DO\n                  SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n                  SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n                  EXIT(1)\n               END\n            END\n         END\n      END\n      ELSE IF SYSDSORG = \"PS\" | SYSDSORG = \"PS-E\" THEN DO\n         \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\") UNIT(SYSDA)\"\n         IF RC <> 0 THEN DO\n            SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n            SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n            EXIT(1)\n         END\n      END\n   \"FREE  DSN(\"ZNEWDSN\")\"\n   END\n\n   IF OPTION = \"EMPTY\"\n      THEN SAY ZINPDSN \"CLONED TO\" ZNEWDSN \"WITHOUT COPYING DATA\"\n      ELSE SAY \"JOB SUBMITTED TO COPY\" ZINPDSN \"TO\" ZNEWDSN\n   EXIT(0)\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"                                                             \"\n   SAY \" QCLONE         MAKES A COPY OF A DATA SET UNDER ISPF 3.4    \"\n   SAY \"                SIMILAR TO THE ONE POINTED TO EITHER         \"\n   SAY \"                COPYING THE DATA OR NOT. SIMPLY TYPE 'CLONE' \"\n   SAY \"                FOLLOWED BY THE NEW NAME AND, OPTIONALLY,    \"\n   SAY \"                THE KEYWORD 'EMPTY' AND/OR DIRECTORY COUNT   \"\n   SAY \"                AND/OR THE 'RELEASE' KEYWORD. EXITS IF NEW   \"\n   SAY \"                DATA SET EXISTS (SEE QCLONER).               \"\n   SAY \"                                                             \"\n   SAY \"  SYNTAX: QCLONE  NEW-DATASET-NAME                           \"\n   SAY \"                      <EMPTY>  <#>  <RELEASE>  <Q#>          \"\n   SAY\n   SAY \"             NEW-DATASET-NAME   IS THE NAME OF THE DATA SET  \"\n   SAY \"                TO BE CREATED. IT MAY BE QUALIFIED (WITH     \"\n   SAY \"                QUOTES) OR UNQUALIFIED (ASSUMES YOUR USER-   \"\n   SAY \"                ID AT THE FRONT). IT MAY ALSO BE OF THE FORM \"\n   SAY \"                =XXX WHERE XXX IS SUFFIXED TO THE ORIGINAL   \"\n   SAY \"                NAME OR OF THE FORM XXX= WHERE XXX IS        \"\n   SAY \"                PREFIXED TO THE ORIGINAL NAME. THE Q# OPTION \"\n   SAY \"                MAY BE USED TO REMOVE # LEVELS OF QUALIFIERS \"\n   SAY \"                AT THE BACK OR FRONT OF THE ORIGINAL NAME.   \"\n   SAY\n   SAY \"            <EMPTY>  IS AN OPTIONAL PARAMETER TO INDICATE    \"\n   SAY \"                NO DATA IS TO BE COPIED FROM THE ORIGINAL    \"\n   SAY \"                FILE.                                        \"\n   SAY\n   SAY \"            <#> IS AN OPTIONAL CHANGE TO THE NUMBER OF       \"\n   SAY \"                DIRECTORY BLOCKS IF THE DATA SET IS A PDS.   \"\n   SAY \"                A WHOLE NUMBER IS USED AS IS; PREFIXED BY A +\"\n   SAY \"                IS ADDED; BY A - IS SUBTRACTED. NEVER ALLOWS \"\n   SAY \"                BELOW USED BLOCKS. IF THE DATA SET IS        \"\n   SAY \"                SEQUENTIAL, THE NUMBER BECOMES THE LRECL; A +\"\n   SAY \"                PREFIX ADDS BYTES; A - PREFIX SUBTRACTS.     \"\n   SAY\n   SAY \"            <RELEASE> IS AN OPTION THAT WILL RELEASE ANY     \"\n   SAY \"                UNUSED SPACE IN THE RESULTANT FILE           \"\n   SAY\n   SAY \"            <Q#> IS AN OPTION TO REMOVE THAT MANY (#) LEVEL  \"\n   SAY \"                QUALIFIERS OF THE ORIGINAL DATA SET EITHER   \"\n   SAY \"                PREFIXING IT WITH THE XXX FROM THE XXX= INPUT\"\n   SAY \"                OR SUFFIXING IT WITH THE XXX FROM THE =XXX.  \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QCLONER": {"ttr": 34561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x01>\\x01>\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 318, "newlines": 318, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- CREATE BY JOB ANOTHER VERSION OF A D/S UNDER ISPF 3.4  **/\n\n   PARSE ARG PARMS\n   MSG = MSG(OFF)\n   PARMS = TRANSLATE(PARMS)\n\n   ZINPDSN = \"\"\n   ZNEWDSN = \"\"\n   OPTION  = \"\"\n   NUMOPT  = \"\"\n   NUMCHG  = \"\"\n   RELOPT  = \"\"\n   Q       = 0\n\n   IF WORD(PARMS,2) = \"\" | WORD(PARMS,1) = \"?\"\n      THEN SIGNAL DISPDOC\n\n   DO II = 1 TO 9\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF TOKEN = \"EMPTY\" THEN OPTION = TOKEN\n      ELSE IF TOKEN = \"RELEASE\" THEN RELOPT = \"RELEASE\"\n      ELSE IF SUBSTR(TOKEN,1,1) = \"+\" | SUBSTR(TOKEN,1,1) = \"-\"\n         THEN DO\n            NUMOPT = \"CHG\"\n            NUMCHG = TOKEN\n         END\n      ELSE IF DATATYPE(TOKEN,'W')\n         THEN DO\n            NUMOPT = \"NEW\"\n            NUMCHG = TOKEN\n         END\n      ELSE IF SUBSTR(TOKEN,1,1) = \"=\",\n            | SUBSTR(TOKEN,LENGTH(TOKEN),1) = \"=\"\n         THEN ZNEWDSN = TOKEN\n      ELSE IF SUBSTR(TOKEN,1,1) = \"Q\" & DATATYPE(SUBSTR(TOKEN,2),'W')\n         THEN Q = SUBSTR(TOKEN,2)\n      ELSE DO\n         IF ZNEWDSN = \"\" THEN ZNEWDSN = TOKEN\n                         ELSE ZINPDSN = TOKEN\n      END\n   END II\n\n   IF SUBSTR(ZNEWDSN,1,1) = \"=\" THEN DO\n      IF Q = 0 THEN ZNEWDSN = SUBSTR(ZINPDSN,1,LENGTH(ZINPDSN)-1),\n         || SUBSTR(ZNEWDSN,2) || \"'\"\n      ELSE DO\n         NN = LENGTH(ZINPDSN) - 1\n         DO PP = 1 TO Q\n            DO II = NN TO 1 BY -1 WHILE(SUBSTR(ZINPDSN,II,1) <> \".\")\n            END II\n            NN = II - 1\n         END PP\n         ZNEWDSN = SUBSTR(ZINPDSN,1,NN) || SUBSTR(ZNEWDSN,2) || \"'\"\n      END\n   END\n   ELSE IF SUBSTR(ZNEWDSN,LENGTH(ZNEWDSN),1) = \"=\" THEN DO\n      IF Q = 0 THEN ZNEWDSN = \"'\",\n         || SUBSTR(ZNEWDSN,1,LENGTH(ZNEWDSN)-1) || SUBSTR(ZINPDSN,2)\n      ELSE DO\n         NN = 2\n         DO PP = 1 TO Q\n            DO II = NN TO LENGTH(ZINPDSN)-1,\n                  WHILE(SUBSTR(ZINPDSN,II,1) <> \".\")\n            END II\n            NN = II + 1\n         END PP\n         ZNEWDSN = \"'\" || SUBSTR(ZNEWDSN,1,LENGTH(ZNEWDSN)-1),\n            || SUBSTR(ZINPDSN,NN,LENGTH(ZINPDSN)-NN+1)\n      END\n   END\n\n   IF SYSDSN(ZNEWDSN) = \"OK\" THEN ADDRESS TSO DELETE ZNEWDSN\n   USER_ID = USERID()\n   LDSI = LISTDSI(ZINPDSN DIRECTORY)\n\n   IF OPTION <> \"EMPTY\" THEN DO\n      IF SYSDSORG = PO & SYSADIRBLK <> \"NO_LIM\" & NUMOPT <> \"\" THEN DO\n         IF NUMOPT = \"NEW\" THEN DIRCNT = NUMCHG\n         ELSE DIRCNT = SYSADIRBLK + NUMCHG\n         IF DIRCNT < SYSUDIRBLK THEN DO\n               SAY \"***> NEW NUMBER OF DIRECTORY BLOCKS (\"DIRCNT\")\",\n                  \"MAY NOT\"\n               SAY \"***> BE LESS THEN THE NUMBER CURRENTLY IN USE\",\n                  \"(\"SYSUDIRBLK\")\"\n               EXIT(1)\n         END\n      END\n      ADDRESS TSO\n      \"FREE DD(SUBXDD)\"\n      \"ALLOC DD(SUBXDD) SYSOUT(A) WRITER(INTRDR)\",\n         \"LRECL(80) BLKSIZE(800) RECFM(F B)\"\n      QUEUE \"//\" || USER_ID || \"Q    JOB      (ACCT-INFO),'\",\n         || USER_ID || \"',\"\n      QUEUE \"//             CLASS=2,MSGCLASS=X,NOTIFY=\",\n         || USER_ID\n      QUEUE \"//***\"\n      IF SUBSTR(ZNEWDSN,1,1) <> \"'\"\n         THEN ZNEWDSN = USER_ID || \".\" || ZNEWDSN\n         ELSE ZNEWDSN = SUBSTR(ZNEWDSN,2,LENGTH(ZNEWDSN)-2)\n      ZINPDSN = SUBSTR(ZINPDSN,2,LENGTH(ZINPDSN)-2)\n\n      IF SYSDSORG = PO THEN DO\n         QUEUE \"//QCLONER    EXEC     PGM=IEBCOPY,REGION=6M\"\n         QUEUE \"//SYSPRINT     DD       SYSOUT=*\"\n         QUEUE \"//SORTIN       DD       DISP=SHR,\"\n         QUEUE \"//             DSN=\" || ZINPDSN\n         IF SYSADIRBLK = \"NO_LIM\" THEN DO\n            IF RELOPT = \"RELEASE\" THEN DO\n               IF SUBSTR(SYSUNITS,1,1) = \"C\" THEN SU = \"CYL\"\n                                             ELSE SU = \"TRK\"\n               QUEUE \"//SORTOUT     DD       DSN=\" || ZNEWDSN || \",\"\n               QUEUE \"//            DISP=(,CATLG),UNIT=SYSDA,\"\n               QUEUE \"//            SPACE=(\" || SU || \",(\",\n                  || SYSALLOC || \",\" || SYSSECONDS,\n                  || \"),RLSE),\"\n               QUEUE \"//            LIKE=\" || ZINPDSN || \",\"\n               QUEUE \"//            DSNTYPE=LIBRARY\"\n            END\n            ELSE DO\n               QUEUE \"//SORTOUT     DD       DSN=\" || ZNEWDSN || \",\"\n               QUEUE \"//            DISP=(,CATLG),UNIT=SYSDA,\"\n               QUEUE \"//            LIKE=\" || ZINPDSN || \",\"\n               QUEUE \"//            DSNTYPE=LIBRARY\"\n            END\n         END\n         ELSE DO\n            IF NUMOPT = \"\" THEN DO\n               IF RELOPT = \"RELEASE\" THEN DO\n                  IF SUBSTR(SYSUNITS,1,1) = \"C\" THEN SU = \"CYL\"\n                                                ELSE SU = \"TRK\"\n                  QUEUE \"//SORTOUT     DD       DSN=\" || ZNEWDSN || \",\"\n                  QUEUE \"//            DISP=(,CATLG),UNIT=SYSDA,\"\n                  QUEUE \"//            SPACE=(\" || SU || \",(\",\n                     || SYSALLOC || \",\" || SYSSECONDS,\n                     || \",\" || SYSADIRBLK,\n                     || \"),RLSE),\"\n                  QUEUE \"//            LIKE=\" || ZINPDSN\n               END\n               ELSE DO\n                  QUEUE \"//SORTOUT     DD       DSN=\" || ZNEWDSN || \",\"\n                  QUEUE \"//            DISP=(,CATLG),UNIT=SYSDA,\"\n                  QUEUE \"//            LIKE=\" || ZINPDSN\n               END\n            END\n            ELSE DO\n               IF NUMOPT = \"NEW\" THEN DIRCNT = NUMCHG\n               ELSE DIRCNT = SYSADIRBLK + NUMCHG\n               IF SUBSTR(SYSUNITS,1,1) = \"C\" THEN SU = \"CYL\"\n                                             ELSE SU = \"TRK\"\n               IF RELOPT = \"RELEASE\" THEN SP_CLOSE = \"),RLSE),\"\n                                     ELSE SP_CLOSE = \")),\"\n               QUEUE \"//SORTOUT      DD       DSN=\" || ZNEWDSN || \",\"\n               QUEUE \"//             DISP=(,CATLG),UNIT=SYSDA,\"\n               QUEUE \"//             SPACE=(\" || SU || \",(\",\n                  || SYSALLOC || \",\" || SYSSECONDS || \",\",\n                  || DIRCNT || SP_CLOSE\n               QUEUE \"//             LIKE=\" || ZINPDSN\n            END\n         END\n         QUEUE \"  COPY  INDD=SORTIN,OUTDD=SORTOUT\"\n         QUEUE \"//***\"\n         \"EXECIO\" QUEUED() \"DISKW SUBXDD (FINIS\"\n         \"FREE DD(SUBXDD)\"\n         CALL SETMSG \"* NO JOB SUBMITTED$JOB SUBMITTED SUCCESSFULLY!\"\n      END\n      ELSE IF SYSDSORG = \"PS\" | SYSDSORG = \"PS-E\" THEN DO\n         QUEUE \"//QCLONER    EXEC     PGM=SORT,REGION=64M\"\n         QUEUE \"//SYSPRINT     DD       SYSOUT=*\"\n         QUEUE \"//SORTLIST     DD       SYSOUT=*\"\n         QUEUE \"//SYSOUT       DD       SYSOUT=*\"\n         QUEUE \"//SORTIN       DD       DISP=SHR,\"\n         QUEUE \"//             DSN=\" || ZINPDSN\n         IF NUMOPT = \"\" THEN DO\n            QUEUE \"//SORTOUT      DD       DSN=\" || ZNEWDSN || \",\"\n            QUEUE \"//             DISP=(,CATLG),UNIT=SYSDA,\"\n            IF RELOPT = \"RELEASE\" THEN DO\n               IF SUBSTR(SYSUNITS,1,1) = \"C\" THEN SU = \"CYL\"\n                                             ELSE SU = \"TRK\"\n               QUEUE \"//             SPACE=(\" || SU || \",(\",\n                  || SYSALLOC || \",\" || SYSSECONDS || \"),RLSE),\"\n            END\n            QUEUE \"//             LIKE=\" || ZINPDSN\n            QUEUE \"  SORT  FIELDS=COPY\"\n         END\n         ELSE DO\n            IF NUMOPT = \"NEW\" THEN NEWLRECL = NUMCHG\n            ELSE NEWLRECL = SYSLRECL + NUMCHG\n            IF SYSRECFM = \"VB\"\n               THEN NEWBLKSIZE = SYSBLKSIZE\n               ELSE NEWBLKSIZE = NEWLRECL * (27998%NEWLRECL)\n            QUEUE \"//SORTOUT     DD       DSN=\" || ZNEWDSN || \",\"\n            QUEUE \"//            DISP=(,CATLG),UNIT=SYSDA,\"\n            IF RELOPT = \"RELEASE\" THEN DO\n               IF SUBSTR(SYSUNITS,1,1) = \"C\" THEN SU = \"CYL\"\n                                             ELSE SU = \"TRK\"\n               QUEUE \"//             SPACE=(\" || SU || \",(\",\n                  || SYSALLOC || \",\" || SYSSECONDS || \"),RLSE),\"\n            END\n            QUEUE \"//            LIKE=\" || ZINPDSN || \",\"\n            QUEUE \"//            LRECL=\" || NEWLRECL || \",\",\n               || \"BLKSIZE=\" || NEWBLKSIZE\n            QUEUE \"  SORT    FIELDS=COPY\"\n            IF NEWLRECL > SYSLRECL & INDEX(SYSRECFM,'F') <> 0 THEN DO\n               PAD = NEWLRECL - SYSLRECL\n               OUTREC_STR = \"  OUTREC  FIELDS=(1,\" || SYSLRECL,\n                  || \",\" || PAD || \"X)\"\n               QUEUE OUTREC_STR\n            END\n         END\n         QUEUE \"//***\"\n         \"EXECIO\" QUEUED() \"DISKW SUBXDD (FINIS\"\n         \"FREE DD(SUBXDD)\"\n         CALL SETMSG \"* NO JOB SUBMITTED$JOB SUBMITTED SUCCESSFULLY!\"\n      END\n   END\n   ELSE DO\n      ADDRESS TSO\n      IF SYSDSORG = PO THEN DO\n         IF SYSADIRBLK = \"NO_LIM\" THEN DO\n            \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n               \"DSNTYPE(LIBRARY) DD(SORTOUT) UNIT(SYSDA)\"\n            IF RC <> 0 THEN DO\n               SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n               SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n               EXIT(1)\n            END\n         END\n         ELSE DO\n            IF NUMOPT = \"\" THEN DO\n               \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n                  \"DIR(\"SYSADIRBLK\") UNIT(SYSDA)\"\n               IF RC <> 0 THEN DO\n                  SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n                  SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n                  EXIT(1)\n               END\n            END\n            ELSE DO\n               IF NUMOPT = \"NEW\" THEN DIRCNT = NUMCHG\n               ELSE DIRCNT = SYSADIRBLK + NUMCHG\n               \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n                  \"DIR(\"DIRCNT\") DD(SORTOUT) UNIT(SYSDA)\"\n               IF RC <> 0 THEN DO\n                  SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n                  SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n                  EXIT(1)\n               END\n            END\n         END\n      END\n      ELSE IF SYSDSORG = \"PS\" | SYSDSORG = \"PS-E\" THEN DO\n         \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\") UNIT(SYSDA)\"\n         IF RC <> 0 THEN DO\n            SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n            SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n            EXIT(1)\n         END\n      END\n   \"FREE  DSN(\"ZNEWDSN\")\"\n   END\n\n   IF OPTION = \"EMPTY\"\n      THEN SAY ZINPDSN \"CLONED TO\" ZNEWDSN \"WITHOUT COPYING DATA\"\n      ELSE SAY \"JOB SUBMITTED TO COPY\" ZINPDSN \"TO\" ZNEWDSN\n   EXIT(0)\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"                                                             \"\n   SAY \" QCLONER        MAKES A COPY OF A DATA SET UNDER ISPF 3.4    \"\n   SAY \"                SIMILAR TO THE ONE POINTED TO EITHER         \"\n   SAY \"                COPYING THE DATA OR NOT. SIMPLY TYPE 'CLONE' \"\n   SAY \"                FOLLOWED BY THE NEW NAME AND, OPTIONALLY,    \"\n   SAY \"                THE KEYWORD 'EMPTY' AND/OR DIRECTORY COUNT   \"\n   SAY \"                AND/OR THE 'RELEASE' KEYWORD. DELETES AN     \"\n   SAY \"                EXISTING COPY IF IT EXISTS.                  \"\n   SAY \"                                                             \"\n   SAY \"  SYNTAX: QCLONER NEW-DATASET-NAME                           \"\n   SAY \"                      <EMPTY>  <#>  <RELEASE>  <Q#>          \"\n   SAY\n   SAY \"             NEW-DATASET-NAME   IS THE NAME OF THE DATA SET  \"\n   SAY \"                TO BE CREATED. IT MAY BE QUALIFIED (WITH     \"\n   SAY \"                QUOTES) OR UNQUALIFIED (ASSUMES YOUR USER-   \"\n   SAY \"                ID AT THE FRONT). IT MAY ALSO BE OF THE FORM \"\n   SAY \"                =XXX WHERE XXX IS SUFFIXED TO THE ORIGINAL   \"\n   SAY \"                NAME OR OF THE FORM XXX= WHERE XXX IS        \"\n   SAY \"                PREFIXED TO THE ORIGINAL NAME. THE Q# OPTION \"\n   SAY \"                MAY BE USED TO REMOVE # LEVELS OF QUALIFIERS \"\n   SAY \"                AT THE BACK OR FRONT OF THE ORIGINAL NAME.   \"\n   SAY\n   SAY \"            <EMPTY>  IS AN OPTIONAL PARAMETER TO INDICATE    \"\n   SAY \"                NO DATA IS TO BE COPIED FROM THE ORIGINAL    \"\n   SAY \"                FILE.                                        \"\n   SAY\n   SAY \"            <#> IS AN OPTIONAL CHANGE TO THE NUMBER OF       \"\n   SAY \"                DIRECTORY BLOCKS IF THE DATA SET IS A PDS.   \"\n   SAY \"                A WHOLE NUMBER IS USED AS IS; PREFIXED BY A +\"\n   SAY \"                IS ADDED; BY A - IS SUBTRACTED. NEVER ALLOWS \"\n   SAY \"                BELOW USED BLOCKS. IF THE DATA SET IS        \"\n   SAY \"                SEQUENTIAL, THE NUMBER BECOMES THE LRECL; A +\"\n   SAY \"                PREFIX ADDS BYTES; A - PREFIX SUBTRACTS.     \"\n   SAY\n   SAY \"            <RELEASE> IS AN OPTION THAT WILL RELEASE ANY     \"\n   SAY \"                UNUSED SPACE IN THE RESULTANT FILE           \"\n   SAY\n   SAY \"            <Q#> IS AN OPTION TO REMOVE THAT MANY (#) LEVEL  \"\n   SAY \"                QUALIFIERS OF THE ORIGINAL DATA SET EITHER   \"\n   SAY \"                PREFIXING IT WITH THE XXX FROM THE XXX= INPUT\"\n   SAY \"                OR SUFFIXING IT WITH THE XXX FROM THE =XXX.  \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RANCOLS": {"ttr": 34567, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xc8\\x00\\xc8\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 200, "newlines": 200, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- RANDOM NUMBER SPECIFIC COLUMNS  **/\n   RETURN_CODE = 0\n   SAVEMSG = MSG()\n   IF  SAVEMSG = 'OFF'  THEN  X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF  RC <> 0  THEN DO\n      SAY 'RANCOLS MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF  RC = 0  THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (PARMS)\"\n      IF  RC = 0  THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF  DSN = 'DSN'  THEN DO\n      SAY 'RANCOLS EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT',\n          'WITH NO PENDING EDIT COMMANDS!'\n      SIGNAL EOJ\n   END\n\n   PARMS    = TRANSLATE(PARMS)\n   STARTCOL = \"\"\n   ENDCOL   = \"\"\n   MINNUM   = \"\"\n   MAXNUM   = \"\"\n   LBL1     = \"\"\n   LBL2     = \"\"\n   DO II = 1 TO 6;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               SIGNAL DISPDOC\n            END\n      END\n      ELSE DO\n         IF DATATYPE(TOKEN,'W')  THEN DO\n            IF STARTCOL = \"\" THEN STARTCOL = TOKEN\n               ELSE IF ENDCOL   = \"\" THEN ENDCOL   = TOKEN\n               ELSE IF MINNUM   = \"\" THEN MINNUM   = TOKEN\n               ELSE IF MAXNUM   = \"\" THEN MAXNUM   = TOKEN\n                  ELSE DO\n                     ZEDSMSG = \".LABEL RC=8\"\n                     ZEDLMSG = \"TOO MANY NUMBERS --\" TOKEN\n                     ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n                     SIGNAL DISPDOC\n                  END\n         END\n         ELSE DO\n            ZEDSMSG = \"BAD PARM\"\n            ZEDLMSG = \"UNRECOGNIZED PARM --\" TOKEN\n            ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n            SIGNAL DISPDOC\n         END\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n\n   ERRORMSG = ''\n   MESG = ''\n   IF  STARTCOL = ''  |  ENDCOL = ''  THEN DO\n      MESG = 'REQUIRED PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   IF  \u00acDATATYPE(STARTCOL,'W')  |  STARTCOL = 0  THEN DO\n      MESG = \"'\"STARTCOL\"' VALUE OF STARTING COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF  \u00acDATATYPE(ENDCOL,'W') |  ENDCOL = 0  THEN DO\n      MESG = \"'\"ENDCOL\"' VALUE OF NUMBER SIZE IS INVALID!\"\n      SIGNAL ERROR\n   END\n\n   IF  MINNUM = ''  THEN  MINNUM = 1\n   ELSE DO\n      IF  \u00acDATATYPE(MINNUM,'W')  THEN DO\n         MESG = \"'\"MINNUM\"' VALUE OF MINIMUM NUMBER IS INVALID!\"\n         SIGNAL ERROR\n      END\n   END\n   IF  MAXNUM = ''  THEN  MAXNUM = COPIES('9',ENDCOL-STARTCOL+1)\n   ELSE DO\n      IF  \u00acDATATYPE(MAXNUM,'W')  THEN DO\n         MESG = \"'\"MAXNUM\"' VALUE OF MAXIMUM NUMBER IS INVALID!\"\n         SIGNAL ERROR\n      END\n   END\n   IF  MINNUM > MAXNUM  THEN DO\n      HOLDNUM = MINNUM\n      MINNUM  = MAXNUM\n      MAXNUM  = HOLDNUM\n   END\n\n   LEN = ENDCOL - STARTCOL + 1\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF  LEN > LRECL  THEN DO\n      MESG=\"CALCULATED SIZE IS GREATER THAN RECORD SIZE (\"LRECL\")!\"\n      SIGNAL ERROR\n   END\n   IF  ( LEN + STARTCOL - 1 ) > LRECL  THEN DO\n      MESG=\"SIZE WILL OVERFLOW RECORD LENGTH (\"LRECL\")!\"\n      SIGNAL ERROR\n   END\n\n   IF  LBL1 <> ''  THEN DO\n      \"ISREDIT L &LBL1\"\n      IF  RC <> 0  THEN DO\n         MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   IF  LBL2 <> ''  THEN DO\n      \"ISREDIT L &LBL2\"\n       IF  RC <> 0  THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n    END\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR     \"\n   \"ISREDIT (\"ANUM\") = AUTONUM              \"\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n   START = 1\n   IF  LBL1 <> ''  THEN  \"ISREDIT (START) = LINENUM &LBL1\"\n   IF  LBL2 <> ''  THEN  \"ISREDIT (END)   = LINENUM &LBL2\"\n      ELSE LBL2 = LBL1\n   IF  START > END  THEN DO\n      WST   = START\n      START = END\n      END   = WST\n   END\n\n   DO PNTR =  START  TO  END\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      IF LEN < 6 THEN FILLNUM = RANDOM(MINNUM,MAXNUM)\n      ELSE DO\n         TEMPLEN = LEN\n         FILLNUM = \"\"\n         DO WHILE TEMPLEN > 5\n            TEMPNUM = RANDOM(0,99999)\n            FILLNUM = SUBSTR('',1,5-LENGTH(TEMPNUM),'0'),\n               || TEMPNUM || FILLNUM\n            TEMPLEN = TEMPLEN - 5\n         END\n         FILLNUM = RANDOM(0,10**TEMPLEN-1) || FILLNUM\n         NUMERIC DIGITS LEN\n         IF FILLNUM < MINNUM | FILLNUM > MAXNUM THEN\n            FILLNUM = ( FILLNUM // ( MAXNUM - MINNUM ) ) + MINNUM\n         FILLNUM = STRIP(FILLNUM,L,'0')\n      END\n      RECORD  = OVERLAY(RIGHT(FILLNUM,LEN),RECORD,STARTCOL,LEN)\n      \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n   END\n   \"ISREDIT LOCATE\" START\n   \"ISREDIT AUTONUM = \"ANUM\n    SIGNAL EOJ\n\nERROR:\n   IF MESG<>'' THEN DO\n      RETURN_CODE = 20\n      ERRORMSG='===>' MESG\n   END\n   SIGNAL DISPDOC\n\nEOJ:\n   X = MSG(SAVEMSG)\n   RETURN RETURN_CODE\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"RANCOLS - PUT RANDOM NUMBERS INTO SPECIFIC COLUMNS \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    RANCOLS  START-COL END-COL  (MIN-NUM MAX-NUM) (.A .B)\"\n   SAY\n   SAY \"    STARTING AND ENDING COLUMNS ARE MANDATORY AND MUST   \"\n   SAY \"    BE NUMERIC. THE REMAINING PARAMETERS ARE OPTIONAL.   \"\n   SAY \"    MINIMUM AND MAXIMUM MUST ALSO BE NUMERIC IF SUPPLIED,\"\n   SAY \"    DEFAULTING TO 1 AND ALL 9'S RESPECTIVELY IF NOT. THE \"\n   SAY \"    RANGE MAY BE INTERMIXED.                             \"\n   SAY\n   SAY \" EXAMPLES \"\n   SAY \"    RANCOLS  11 15  .AK .AV  100 10000                   \"\n   SAY \"       WILL PUT RANDOM 5 DIGIT NUMBERS IN COLUMNS 11     \"\n   SAY \"       THROUGH 15 OF THE LINE RANGE .AK THROUGH .AV      \"\n   SAY \"       FROM 100 THROUGH 10000.                           \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RANCOLS0": {"ttr": 34571, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xca\\x00\\xca\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 202, "newlines": 202, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- ZERO PAD RANDOM NUMBERS INTO SPECIFIC COLUMNS  **/\n   RETURN_CODE = 0\n   SAVEMSG = MSG()\n   IF  SAVEMSG = 'OFF'  THEN  X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF  RC <> 0  THEN DO\n      SAY 'RANCOLS0 MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF  RC = 0  THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (PARMS)\"\n      IF  RC = 0  THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF  DSN = 'DSN'  THEN DO\n      SAY 'RANCOLS0 EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT',\n          'WITH NO PENDING EDIT COMMANDS!'\n      SIGNAL EOJ\n   END\n\n   PARMS    = TRANSLATE(PARMS)\n   STARTCOL = \"\"\n   ENDCOL   = \"\"\n   MINNUM   = \"\"\n   MAXNUM   = \"\"\n   LBL1     = \"\"\n   LBL2     = \"\"\n   DO II = 1 TO 6;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               SIGNAL DISPDOC\n            END\n      END\n      ELSE DO\n         IF DATATYPE(TOKEN,'W')  THEN DO\n            IF STARTCOL = \"\" THEN STARTCOL = TOKEN\n               ELSE IF ENDCOL   = \"\" THEN ENDCOL   = TOKEN\n               ELSE IF MINNUM   = \"\" THEN MINNUM   = TOKEN\n               ELSE IF MAXNUM   = \"\" THEN MAXNUM   = TOKEN\n                  ELSE DO\n                     ZEDSMSG = \".LABEL RC=8\"\n                     ZEDLMSG = \"TOO MANY NUMBERS --\" TOKEN\n                     ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n                     SIGNAL DISPDOC\n                  END\n         END\n         ELSE DO\n            ZEDSMSG = \"BAD PARM\"\n            ZEDLMSG = \"UNRECOGNIZED PARM --\" TOKEN\n            ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n            SIGNAL DISPDOC\n         END\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n\n   ERRORMSG = ''\n   MESG = ''\n   IF  STARTCOL = ''  |  ENDCOL = ''  THEN DO\n      MESG = 'REQUIRED PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   IF  \u00acDATATYPE(STARTCOL,'W')  |  STARTCOL = 0  THEN DO\n      MESG = \"'\"STARTCOL\"' VALUE OF STARTING COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF  \u00acDATATYPE(ENDCOL,'W') |  ENDCOL = 0  THEN DO\n      MESG = \"'\"ENDCOL\"' VALUE OF NUMBER SIZE IS INVALID!\"\n      SIGNAL ERROR\n   END\n\n   IF  MINNUM = ''  THEN  MINNUM = 1\n   ELSE DO\n      IF  \u00acDATATYPE(MINNUM,'W')  THEN DO\n         MESG = \"'\"MINNUM\"' VALUE OF MINIMUM NUMBER IS INVALID!\"\n         SIGNAL ERROR\n      END\n   END\n   IF  MAXNUM = ''  THEN  MAXNUM = COPIES('9',ENDCOL-STARTCOL+1)\n   ELSE DO\n      IF  \u00acDATATYPE(MAXNUM,'W')  THEN DO\n         MESG = \"'\"MAXNUM\"' VALUE OF MAXIMUM NUMBER IS INVALID!\"\n         SIGNAL ERROR\n      END\n   END\n   IF  MINNUM > MAXNUM  THEN DO\n      HOLDNUM = MINNUM\n      MINNUM  = MAXNUM\n      MAXNUM  = HOLDNUM\n   END\n\n   LEN = ENDCOL - STARTCOL + 1\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF  LEN > LRECL  THEN DO\n      MESG=\"CALCULATED SIZE IS GREATER THAN RECORD SIZE (\"LRECL\")!\"\n      SIGNAL ERROR\n   END\n   IF  ( LEN + STARTCOL - 1 ) > LRECL  THEN DO\n      MESG=\"SIZE WILL OVERFLOW RECORD LENGTH (\"LRECL\")!\"\n      SIGNAL ERROR\n   END\n\n   IF  LBL1 <> ''  THEN DO\n      \"ISREDIT L &LBL1\"\n      IF  RC <> 0  THEN DO\n         MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   IF  LBL2 <> ''  THEN DO\n      \"ISREDIT L &LBL2\"\n       IF  RC <> 0  THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n    END\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR     \"\n   \"ISREDIT (\"ANUM\") = AUTONUM              \"\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n   START = 1\n   IF  LBL1 <> ''  THEN  \"ISREDIT (START) = LINENUM &LBL1\"\n   IF  LBL2 <> ''  THEN  \"ISREDIT (END)   = LINENUM &LBL2\"\n      ELSE LBL2 = LBL1\n   IF  START > END  THEN DO\n      WST   = START\n      START = END\n      END   = WST\n   END\n\n   DO PNTR =  START  TO  END\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      IF LEN < 6 THEN DO\n         FILLNUM = RANDOM(MINNUM,MAXNUM)\n      END\n      ELSE DO\n         TEMPLEN = LEN\n         FILLNUM = \"\"\n         DO WHILE TEMPLEN > 5\n            TEMPNUM = RANDOM(0,99999)\n            FILLNUM = SUBSTR('',1,5-LENGTH(TEMPNUM),'0'),\n               || TEMPNUM || FILLNUM\n            TEMPLEN = TEMPLEN - 5\n         END\n         FILLNUM = RANDOM(0,10**TEMPLEN-1) || FILLNUM\n         NUMERIC DIGITS LEN\n         IF FILLNUM < MINNUM | FILLNUM > MAXNUM THEN\n            FILLNUM = ( FILLNUM // ( MAXNUM - MINNUM ) ) + MINNUM\n      END\n      RECORD = OVERLAY(SUBSTR('',1,LEN-LENGTH(FILLNUM),'0'),\n         || FILLNUM,RECORD,STARTCOL,LEN)\n      \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n   END\n   \"ISREDIT LOCATE\" START\n   \"ISREDIT AUTONUM = \"ANUM\n    SIGNAL EOJ\n\nERROR:\n   IF MESG<>'' THEN DO\n      RETURN_CODE = 20\n      ERRORMSG='===>' MESG\n   END\n   SIGNAL DISPDOC\n\nEOJ:\n   X = MSG(SAVEMSG)\n   RETURN RETURN_CODE\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"RANCOLS0 - PUT ZERO PADDED RANDOM NUMBERS INTO SPECIFIC COLUMNS\"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    RANCOLS0  START-COL  END-COL  MIN-NUM  MAX-NUM  .A .B \"\n   SAY\n   SAY \"    STARTING AND ENDING COLUMNS ARE MANDATORY AND MUST    \"\n   SAY \"    BE NUMERIC. THE REMAINING PARAMETERS ARE OPTIONAL.    \"\n   SAY \"    MINIMUM AND MAXIMUM MUST ALSO BE NUMERIC IF SUPPLIED, \"\n   SAY \"    DEFAULTING TO 1 AND ALL 9'S RESPECTIVELY IF NOT. THE  \"\n   SAY \"    RANGE MAY BE INTERMIXED.                              \"\n   SAY\n   SAY \" EXAMPLES \"\n   SAY \"    RANCOLS0  .AK .AV  11 18  10000001 19999999           \"\n   SAY \"       WILL PUT RANDOM FULL 8 DIGIT NUMBERS IN COLUMNS    \"\n   SAY \"       11 THROUGH 18 OF THE LINE RANGE .AK THROUGH .AV    \"\n   SAY \"       FROM 10000001 THROUGH 19999999.                    \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REALUNIQ": {"ttr": 34820, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x03'\\x1f\\x01\\x03'\\x1f\\x12\\x00\\x00\\xb4\\x00\\xb4\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-09-28T00:00:00", "modifydate": "2003-09-28T12:00:00", "lines": 180, "newlines": 180, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- SORT & SHOW ALL RECORDS THAT ONE OF A KIND  **/\n\n   SUBCOM ISREDIT\n   IF  RC = 0  THEN DO\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT \"ISREDIT MACRO (PARMS)\"\n      IF  RC = 0  THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF  DSN = 'DSN'  THEN DO\n      SAY 'REALUNIQ MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n\n   PARMS   = TRANSLATE(PARMS)\n   PARMCNT = 0\n   COL.    = \"\"\n   LBL1    = \"\"\n   LBL2    = \"\"\n   DO II = 1 TO 16;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n      END\n      ELSE DO\n         PARMCNT     = PARMCNT + 1\n         COL.PARMCNT = TOKEN\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n   IF (PARMCNT // 2) <> 0 THEN DO\n      SAVER       = COL.PARMCNT\n      PARMCNT     = PARMCNT + 1\n      COL.PARMCNT = SAVER\n   END\n\n   ERRORMSG = ''\n   MESG     = ''\n   IF  PARMCNT = 0 THEN DO\n      MESG = 'PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   SORTPARMS = \"\"\n   DO II = 1 TO PARMCNT\n      IF  \u00acDATATYPE(COL.II,'W') | COL.II = 0 THEN DO\n         MESG = \"'\"COL.II\"' COLUMN VALUE IS INVALID!\"\n         SIGNAL ERROR\n      END\n      IF  COL.II > LRECL  THEN DO\n         MESG = \"'\"COL.II\"' IS GREATER THAN RECORD SIZE(\"LRECL\")\"\n         SIGNAL ERROR\n      END\n      SORTPARMS = SORTPARMS || \" \" || COL.II\n   END II\n   DO II = 1 TO PARMCNT BY 2\n      JJ = II + 1\n      IF  COL.II > COL.JJ THEN DO\n         MESG = \"LEFT-COL \"COL.II\" IS GREATER THAN RIGHT-COL \"COL.JJ\n         SIGNAL ERROR\n      END\n   END II\n\n   IF  LBL1 <> ''  THEN DO\n      \"ISREDIT L &LBL1\"\n       IF  RC <>  0 THEN DO\n          MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   IF  LBL2 <> ''  THEN DO\n      \"ISREDIT L &LBL2\"\n       IF  RC <>  0 THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   IF  LBL1 <> ''  THEN  \"ISREDIT (START) = LINENUM &LBL1\"\n                   ELSE  START = 1\n   IF  LBL2 <> ''  THEN  \"ISREDIT (END) = LINENUM &LBL2\"\n                   ELSE  \"ISREDIT (END) = LINENUM .ZLAST\"\n\n   \"ISREDIT (\"ANUM\") = AUTONUM\"\n   \"ISREDIT NUMBER OFF \"\n\n   \"ISREDIT SORT \" SORTPARMS LBL1 LBL2\n\n   \"ISREDIT (RECORD)  = LINE \" START\n   PREVKEY = SUBSTR(RECORD,COL.1,COL.2-COL.1+1)\n   DO II = 3 TO PARMCNT BY 2\n      JJ      = II + 1\n      PREVKEY = PREVKEY || SUBSTR(RECORD,COL.II,COL.JJ-COL.II+1)\n   END II\n   SET = 0\n   \"ISREDIT RESET\"\n\n   XX = 0\n   DO  PNTR  =  (START+1) TO END  BY 1\n      \"ISREDIT (RECORD) = LINE\" PNTR\n      NEXTKEY = SUBSTR(RECORD,COL.1,COL.2-COL.1+1)\n      DO II = 3 TO PARMCNT BY 2\n         JJ      = II + 1\n         NEXTKEY = NEXTKEY || SUBSTR(RECORD,COL.II,COL.JJ-COL.II+1)\n      END II\n      IF PREVKEY == NEXTKEY THEN DO\n         SPNTR = PNTR - 1\n         IF XX = 0 THEN \"ISREDIT LABEL \"SPNTR\" = .AAAA\"\n         XX = XX + 1\n      END\n      ELSE DO\n         IF XX = 0 THEN SET = SET + 1\n         IF XX > 0 THEN DO\n            SPNTR = PNTR - 1\n            \"ISREDIT LABEL \"SPNTR\" = .BBBB\"\n            \"ISREDIT X ALL .AAAA .BBBB\"\n            XX = 0\n         END\n         PREVKEY = NEXTKEY\n      END\n   END\n   IF XX > 0 THEN DO\n      SPNTR = PNTR - 1\n      \"ISREDIT LABEL \"SPNTR\" = .BBBB\"\n      \"ISREDIT X ALL .AAAA .BBBB\"\n   END\n   ELSE SET = SET + 1\n\n   CALL SETMSG '* NO ' SET 'UNIQUE KEY SETS $SETS OF UNIQUE KEYS FOUND  '\n   IF START = 1 THEN \"ISREDIT LOCATE\" 0\n                ELSE DO\n                   START = START - 1\n                   \"ISREDIT LOCATE\" START\n                END\n   \"ISREDIT AUTONUM = \"ANUM\n    SIGNAL EOJ\n\nERROR:\n   IF MESG <> '' THEN DO\n      ERRORMSG = '===>' MESG\n   END\n   SIGNAL DISPDOC\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nEOJ:\n   RETURN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"REALUNIQ - SORT AND SHOW EVERY ONE OF A KIND RECORD \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    REALUNIQ COL1 COL2 ...  ( .LABEL1 .LABEL2 )   \"\n   SAY\n   SAY \"       ONE PAIR OF COLUMNS IS MANDATORY. UP TO 10 \"\n   SAY \"       PAIRS MAY BE SPECIFIED.                    \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY \"    REALUNIQ 17 19 4 11 \"\n   SAY \"       WILL SORT FILE BY COLUMNS 17 THRU 19 AND 4 \"\n   SAY \"       THRU 11 SHOWING (UNEXCLUDING) THE RECORDS  \"\n   SAY \"       THAT HAVE NO DUPS.                         \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REALUNIX": {"ttr": 34824, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x03'\\x1f\\x01\\x03'\\x1f\\x12\\x00\\x00\\xb4\\x00\\xb4\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-09-28T00:00:00", "modifydate": "2003-09-28T12:00:00", "lines": 180, "newlines": 180, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- SHOW ALL RECORDS THAT ONE OF A KIND WITH NO SORT  **/\n\n   SUBCOM ISREDIT\n   IF  RC = 0  THEN DO\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT \"ISREDIT MACRO (PARMS)\"\n      IF  RC = 0  THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF  DSN = 'DSN'  THEN DO\n      SAY 'REALUNIX MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n\n   PARMS   = TRANSLATE(PARMS)\n   PARMCNT = 0\n   COL.    = \"\"\n   LBL1    = \"\"\n   LBL2    = \"\"\n   DO II = 1 TO 16;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n      END\n      ELSE DO\n         PARMCNT     = PARMCNT + 1\n         COL.PARMCNT = TOKEN\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n   IF (PARMCNT // 2) <> 0 THEN DO\n      SAVER       = COL.PARMCNT\n      PARMCNT     = PARMCNT + 1\n      COL.PARMCNT = SAVER\n   END\n\n   ERRORMSG = ''\n   MESG     = ''\n   IF  PARMCNT = 0 THEN DO\n      MESG = 'PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   SORTPARMS = \"\"\n   DO II = 1 TO PARMCNT\n      IF  \u00acDATATYPE(COL.II,'W') | COL.II = 0 THEN DO\n         MESG = \"'\"COL.II\"' COLUMN VALUE IS INVALID!\"\n         SIGNAL ERROR\n      END\n      IF  COL.II > LRECL  THEN DO\n         MESG = \"'\"COL.II\"' IS GREATER THAN RECORD SIZE(\"LRECL\")\"\n         SIGNAL ERROR\n      END\n      SORTPARMS = SORTPARMS || \" \" || COL.II\n   END II\n   DO II = 1 TO PARMCNT BY 2\n      JJ = II + 1\n      IF  COL.II > COL.JJ THEN DO\n         MESG = \"LEFT-COL \"COL.II\" IS GREATER THAN RIGHT-COL \"COL.JJ\n         SIGNAL ERROR\n      END\n   END II\n\n   IF  LBL1 <> ''  THEN DO\n      \"ISREDIT L &LBL1\"\n       IF  RC <>  0 THEN DO\n          MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   IF  LBL2 <> ''  THEN DO\n      \"ISREDIT L &LBL2\"\n       IF  RC <>  0 THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   IF  LBL1 <> ''  THEN  \"ISREDIT (START) = LINENUM &LBL1\"\n                   ELSE  START = 1\n   IF  LBL2 <> ''  THEN  \"ISREDIT (END) = LINENUM &LBL2\"\n                   ELSE  \"ISREDIT (END) = LINENUM .ZLAST\"\n\n   \"ISREDIT (\"ANUM\") = AUTONUM\"\n   \"ISREDIT NUMBER OFF \"\n\n   \"ISREDIT SORT \" SORTPARMS LBL1 LBL2\n\n   \"ISREDIT (RECORD)  = LINE \" START\n   PREVKEY = SUBSTR(RECORD,COL.1,COL.2-COL.1+1)\n   DO II = 3 TO PARMCNT BY 2\n      JJ      = II + 1\n      PREVKEY = PREVKEY || SUBSTR(RECORD,COL.II,COL.JJ-COL.II+1)\n   END II\n   SET = 0\n   \"ISREDIT RESET\"\n\n   XX = 0\n   DO  PNTR  =  (START+1) TO END  BY 1\n      \"ISREDIT (RECORD) = LINE\" PNTR\n      NEXTKEY = SUBSTR(RECORD,COL.1,COL.2-COL.1+1)\n      DO II = 3 TO PARMCNT BY 2\n         JJ      = II + 1\n         NEXTKEY = NEXTKEY || SUBSTR(RECORD,COL.II,COL.JJ-COL.II+1)\n      END II\n      IF PREVKEY == NEXTKEY THEN DO\n         SPNTR = PNTR - 1\n         IF XX = 0 THEN \"ISREDIT LABEL \"SPNTR\" = .AAAA\"\n         XX = XX + 1\n      END\n      ELSE DO\n         IF XX = 0 THEN SET = SET + 1\n         IF XX > 0 THEN DO\n            SPNTR = PNTR - 1\n            \"ISREDIT LABEL \"SPNTR\" = .BBBB\"\n            \"ISREDIT X ALL .AAAA .BBBB\"\n            XX = 0\n         END\n         PREVKEY = NEXTKEY\n      END\n   END\n   IF XX > 0 THEN DO\n      SPNTR = PNTR - 1\n      \"ISREDIT LABEL \"SPNTR\" = .BBBB\"\n      \"ISREDIT X ALL .AAAA .BBBB\"\n   END\n   ELSE SET = SET + 1\n\n   CALL SETMSG '* NO ' SET 'UNIQUE KEY SETS $SETS OF UNIQUE KEYS FOUND  '\n   IF START = 1 THEN \"ISREDIT LOCATE\" 0\n                ELSE DO\n                   START = START - 1\n                   \"ISREDIT LOCATE\" START\n                END\n   \"ISREDIT AUTONUM = \"ANUM\n    SIGNAL EOJ\n\nERROR:\n   IF MESG <> '' THEN DO\n      ERRORMSG = '===>' MESG\n   END\n   SIGNAL DISPDOC\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nEOJ:\n   RETURN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"REALUNIX - SHOW EVERY ONE OF A KIND RECORD W/O SORTING\"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    REALUNIX COL1 COL2 ...  ( .LABEL1 .LABEL2 )   \"\n   SAY\n   SAY \"       ONE PAIR OF COLUMNS IS MANDATORY. UP TO 10 \"\n   SAY \"       PAIRS MAY BE SPECIFIED.                    \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY \"    REALUNIX 17 19 4 11 \"\n   SAY \"       WILL EXCLUDE ENTIRE FILE AND DISPLAY ONLY  \"\n   SAY \"       RECORDS SHOWING (UNEXCLUDING) THAT HAVE NO \"\n   SAY \"       DUPLICATES.                                \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REGS": {"ttr": 34828, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\t\\x00\\t\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         REGS  &PP=R\n         LCLA  &II\n&II      SETA  0\n.LOOP    ANOP\n&PP&II   EQU   &II\n&II      SETA  &II+1\n         AIF   (&II LT 16).LOOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RENTER": {"ttr": 34830, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00%\\x00%\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&NAME    RENTER  &BASEREG=R11,&SALEN=108,&REGS=YES\n         GBLC  &SASIZE\n&SASIZE  SETC  '&SALEN'\n.* THIS MACRO PROVIDES ENTRY CODE FOR A REENTRANT PROGRAM.\n.* THE DEFAULT BASE REGISTER IS 11 BUT MAY BE CHANGED VIA\n.* THE BASEREG PARAMETER.  THE SAVE AREA SIZE MAY BE SET\n.* THROUGH THE SALEN PARAMETER AND DEFAULTS TO 108.\n         AIF   ('&REGS' NE 'YES').NOREGS\n         REGS\n.NOREGS  ANOP\n&NAME    CSECT\n         STM   R14,R12,12(R13)     SAVE INCOMING REGS\n         LR    &BASEREG(1),R15     ESTABLISH ADDRESSABILITY\n&#BR     SETA  N'&BASEREG\n         AIF   (&#BR GT 1).MULTIRG\n         USING &NAME,&BASEREG\n         AGO   .OUTBASE\n.MULTIRG ANOP\n&#BRX    SETA  1\n&#BRY    SETA  2\n         LA    &BASEREG(&#BR),4095\n.LOADNXT LA    &BASEREG(&#BRY),1(&BASEREG(&#BRX),&BASEREG(&#BR))\n&#BRX    SETA  &#BRX+1\n&#BRY    SETA  &#BRY+1\n         AIF   (&#BRY LE &#BR).LOADNXT\n&BASELEN SETA  K'&BASEREG-2\n&BASES   SETC  '&BASEREG'(2,&BASELEN)\n         USING &NAME,&BASES\n.OUTBASE ANOP\n         LA    R0,&SASIZE          LOAD SAVE AREA SIZE FOR GETMAIN\n         STORAGE  OBTAIN,LENGTH=(0),LOC=BELOW\n         ST    R1,8(R13)           STORE ADDRESS OF NEW SAVE AREA\n         ST    R13,4(R1)           SAVE CALLERS SAVE AREA ADDRESS\n         LM    R0,R1,20(R13)       RELOAD R0 & R1\n         L     R13,8(R13)          LOAD NEW SAVE AREA ADDRESS INTO R13\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REVERSEX": {"ttr": 35073, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00:\\x00:\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 58, "newlines": 58, "modlines": 0, "user": "REXX"}, "text": "/***  REXX -- REVERSE A RANGE OF SELECTED LINES  ***/\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'REVERSE MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   UMODE = \"ISREDIT\"\n   ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n   ADDRESS ISREDIT\n   \"MACRO (PARMS) NOPROCESS\"\n   IF PARMS = '?' THEN SIGNAL DISPDOC\n   \"PROCESS RANGE C\"\n   IF RC > 0 THEN\n      DO\n         \"(TOP) = LINENUM .ZFIRST\"\n         \"(BOT) = LINENUM .ZLAST\"\n      END\n   ELSE\n      DO\n         \"(TOP) = LINENUM .ZFRANGE\"\n         \"(BOT) = LINENUM .ZLRANGE\"\n      END\n\n   BOTLESS1 = BOT - 1\n   DO II = TOP TO BOTLESS1\n      \"ISREDIT (RECORD) = LINE\" II\n      \"ISREDIT LINE_AFTER &BOT = (RECORD)\"\n   END\n   \"ISREDIT DELETE\" TOP BOTLESS1\n\nQUIT:\n   ADDRESS ISPEXEC\n   X=MSG(SAVEMSG)\n   ADDRESS ISREDIT \"LOCATE\" TOP\n   ADDRESS ISREDIT \"RESET\"\n   EXIT(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"REVERSEX - REVERSE THE SEQUENCE OF EDITED LINES         \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    REVERSEX                                            \"\n   SAY\n   SAY \"       WILL CAUSE THE MARKED (VIA C/CC/C##) RANGE OF    \"\n   SAY \"       LINES TO BE REVERSED.  IF NO RANGE IS SPECIFIED, \"\n   SAY \"       THE ENTIRE FILE IS REVERSED.  THIS IS ESSENTIALLY\"\n   SAY \"       A \"FLIP\" COMMAND FOR THE LINES INVOLVED.         \"\n   SAY\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/x-diff", "datatype": "ebcdic", "extension": ".diff"}, "REXIT": {"ttr": 35075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\x0e\\x00\\x0e\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&NAME    REXIT &RC15=YES\n         GBLC  &SASIZE\n&NAME    DS    0H\n         LA    R0,&SASIZE          LOAD SAVE AREA LENGTH FOR RELEASE\n         LR    R1,R13              LOAD SAVE AREA ADDRESS FOR RELEASE\n         L     R13,4(R13)          RESTORE CALLING SAVE AREA ADDRESS\n         AIF   ('&RC15' NE 'YES').NORETC\n         ST    R15,16(R13)         SAVE RETURN CODE\n.NORETC  ANOP\n         STORAGE  RELEASE,LENGTH=(0),ADDR=(1)\n         LM    R14,R12,12(R13)     RESTORE CALLING REGS R14 - R12\n         BR    R14\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RJUST": {"ttr": 35077, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00P\\x00P\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 80, "newlines": 80, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- RIGHT JUSTIFIES DATA USING CC/C## RANGE OR DEFAULT TO **/\n/*        FILE; WILL ACCEPT BOUNDARIES AS PARMS OR USE ISPF BOUNDS  */\n\n   SAVEMSG = MSG()\n   X = MSG(\"OFF\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY \"RJUST MUST BE RUN UNDER ISPF EDIT!\"\n      SIGNAL QUIT\n      END\n   SUBCOM ISREDIT\n   UMODE = \"ISREDIT\"\n   ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n   ADDRESS ISREDIT\n   \"MACRO (LEFT,RIGHT) NOPROCESS\"\n   IF LEFT = '?' THEN SIGNAL DISPDOC\n\n   IF LEFT <> \"\" AND RIGHT = \"\" THEN DO\n      \"ISREDIT (L2,RIGHT) = BOUNDS\"\n      END\n\n   \"PROCESS RANGE C\"\n   IF RC > 0 THEN DO\n      \"(TOP) = LINENUM .ZFIRST\"\n      \"(BOT) = LINENUM .ZLAST\"\n   END\n   ELSE DO\n      \"(TOP) = LINENUM .ZFRANGE\"\n      \"(BOT) = LINENUM .ZLRANGE\"\n   END\n\n   \"ISREDIT(\"LB\",\"RB\") = BOUNDS\"\n   IF LEFT  <> \"\" THEN LB = LEFT\n   IF RIGHT <> \"\" THEN RB = RIGHT\n\n   DO II = TOP TO BOT BY 1\n      \"ISREDIT (RECORD) = LINE &II\"\n      DO JJ = RB TO LB BY -1 WHILE(SUBSTR(RECORD,JJ,1) = ' ')\n         END\n      IF RB > JJ THEN DO\n         RECORD = SUBSTR(RECORD,1,LB-1)  || SUBSTR(RECORD,JJ+1,RB-JJ),\n            || SUBSTR(RECORD,LB,JJ-LB+1) || SUBSTR(RECORD,RB+1)\n         \"ISREDIT LINE &II = &STR(RECORD)\"\n         END\n      END\n\nQUIT:\n   ADDRESS ISPEXEC\n   X = MSG(SAVEMSG)\n   ADDRESS ISREDIT \"LOCATE\" TOP\n   EXIT(1)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"RJUST - RIGHT JUSTIFY TEXT W/IN BOUNDS                   \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    RJUST   ( LEFT-COLUMN  RIGHT-COLUMN )                \"\n   SAY\n   SAY \"       WILL CAUSE THE MARKED (VIA C/CC/C##) RANGE OF     \"\n   SAY \"       LINES TO BE RIGHT JUSTIFIED WITHIN THE BOUNDS THEN\"\n   SAY \"       IN FORCE.  IF NO RANGE IS SPECIFIED, THE ENTIRE   \"\n   SAY \"       FILE IS PROCESSED.  THE FIRST AND THE LAST        \"\n   SAY \"       NON-BLANK CHARACTERS WITHIN THE BOUNDS DETERMINE  \"\n   SAY \"       THE SIZE OF THE DATA TO BE RIGHT JUSTIFIED.       \"\n   SAY \"       SPECIFYING A LEFT COLUMN AND RIGHT COLUMN WILL    \"\n   SAY \"       CAUSE ONLY THE DATA IN THOSE COLUMNS TO BE        \"\n   SAY \"       JUSTIFIED.                                        \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    RJUST  1 50                                          \"\n   SAY \"       WILL CAUSE THE TEST IN COLUMNS 1 THRU 50 TO BE    \"\n   SAY \"       SHIFTED RIGHT SO THAT THE LAST NON BLANK IN THOSE \"\n   SAY \"       COLUMNS WILL BE IN POSITION 50.                   \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAVEINPL": {"ttr": 35080, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x8c\\x00\\x8c\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 140, "newlines": 140, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- SAVE MEMBER IN PLACE                                 **/\n/*    THE SAVED MEMBER MUST BE THE SAME SIZE AS THE ORIGINAL       */\n\n   ADDRESS ISPEXEC\n   'CONTROL ERRORS RETURN'\n   'ISREDIT MACRO (PARMS)'\n   IF RC \u00ac=0 THEN DO\n      ZEDSMSG = ''\n      ZEDLMSG = ' SAVEINPL CAN ONLY RUN AS AN ISPF EDIT MACRO !!!'\n      'SETMSG MSG(ISRZ001)'\n      EXIT\n   END\n   IF PARMS = '?' THEN SIGNAL DISPDOC\n\n   'ISREDIT (MYDSN) = DATASET'\n   IF DSN_NOGOOD(MYDSN) THEN EXIT\n   'ISREDIT (MYMEM)    = MEMBER'\n   'ISREDIT (STRTLINE) = LINENUM .ZFIRST'\n   'ISREDIT (ENDLINE)  = LINENUM .ZLAST'\n   'ISREDIT RECOVERY ON'\n   'ISREDIT RESET'\n\n   NUM_LINES = (ENDLINE-STRTLINE)+1\n   DATANAME  = \"'\"||MYDSN||\"(\"||MYMEM||\")'\"\n   FILENAME  = '##'||RANDOM(1000,9999)||RANDOM(10,99)\n   \"ISREDIT (\"LRECL\") = LRECL\"\n   ADDRESS TSO \"ALLOC DA(\"||DATANAME||\") FILE(\"||FILENAME||\") SHR\"\n\n   ADDRESS TSO 'EXECIO * DISKR' FILENAME '(STEM NEWLINE. FINIS'\n   IF NEWLINE.0 <> NUM_LINES THEN DO\n      ZEDSMSG = ''\n      ZEDLMSG = 'NUMBER OF RECORDS WRITTEN OUT IS DIFFERENT THAN',\n                'SIZE OF OLD MEMBER. UPDATE NOT ALLOWED.',\n                'NUMBER OF OLD RECORDS='||NEWLINE.0||'. NUMBER OF NEW',\n                'RECORDS='||NUM_LINES||'.'\n      'SETMSG MSG(ISRZ001)'\n      ADDRESS TSO 'FREE FILE('FILENAME')'\n      EXIT(1)\n   END\n\n   DO I=STRTLINE TO ENDLINE\n      'ISREDIT (MYINPUT) = LINE' I\n      NEWLINE.I = MYINPUT\n   END\n\n   CNT = 0\n   NOT_THE_END = 1\n   DO WHILE NOT_THE_END\n      ADDRESS TSO 'EXECIO 1 DISKRU' FILENAME\n      TEMPRC = RC\n      IF TEMPRC=2 THEN NOT_THE_END = 0\n      ELSE DO\n         IF TEMPRC \u00ac= 0 THEN DO\n            ZEDSMSG = ''\n            ZEDLMSG = 'EXECIO RETCODE='||TEMPRC||'.',\n                      'PARTIAL DATA WAS WRITTEN OUT - PROCESS ABORTED.'\n            'SETMSG MSG(ISRZ001)'\n            CALL CLOSE_FILE\n            EXIT\n         END\n         ELSE DO\n            PULL\n            CNT = CNT + 1\n            QUEUE NEWLINE.CNT\n            ADDRESS TSO 'EXECIO 1 DISKW' FILENAME\n         END\n      END\n   END  /* DO WHILE NOT_THE_END */\n\n   CALL CLOSE_FILE\n\n   ZEDSMSG = ''\n   ZEDLMSG = MYMEM||\" HAS BEEN SUCCESSFULLY SAVED IN \"||MYDSN||\". \",\n      \"DATA BEING EDITED WAS UPDATED IN PLACE.  HOWEVER, THE\",\n      \"THE ISPF STATISTICS WERE NOT CHANGED AND\",\n      \"THEREFORE ARE NO LONGER CORRECT.\"\n   'SETMSG MSG(ISRZ001)'\n   'ISREDIT CANCEL'\n   EXIT\n\nCLOSE_FILE:\n   ADDRESS TSO 'EXECIO 0 DISKW' FILENAME '(FINIS'\n   ADDRESS TSO 'FREE FILE('FILENAME')'\n   RETURN\n\nDSN_NOGOOD:\n   ARG CHECK_DSN\n   CHECK_DSN = \"'\"||STRIP(CHECK_DSN)||\"'\"\n   X = LISTDSI(CHECK_DSN 'NODIRECTORY NORECALL')\n   IF X = 16 THEN DO\n      IF SYSREASON = 9 THEN DO\n         ZEDSMSG = 'DATA SET MIGRATED'\n         ZEDLMSG = ''\n         'SETMSG MSG(ISRZ001)'\n         RETURN 1\n      END\n      IF SYSREASON = 5 THEN DO\n         ZEDSMSG = 'DATASET NOT CATALOGED'\n         ZEDLMSG = ''\n         'SETMSG MSG(ISRZ001)'\n         RETURN 1\n      END\n      ELSE DO\n         ZEDSMSG = 'LISTDSI RC=16'\n         ZEDLMSG = 'LISTDSI ERROR RC=16 - SYSREASON=' SYSREASON\n         'SETMSG MSG(ISRZ001)'\n         RETURN 1\n      END\n   END\n   IF SYSRECFM = 'F' | SYSRECFM = 'FB' THEN NOP\n   ELSE DO\n      ZEDSMSG = ''\n      ZEDLMSG = 'INVALID RECFM AS '||SYSRECFM||'.',\n                'SAVEINPL CAN ONLY BE USED TO PROCESS RECFM F OR FB.'\n      'SETMSG MSG(ISRZ001)'\n      RETURN 1\n   END\n   IF SYSDSORG = 'PO' THEN RETURN 0\n   ELSE DO\n      ZEDSMSG = ''\n      ZEDLMSG = 'INVALID DSORG AS '||SYSDSORG||'.',\n                'SAVEINPL CAN ONLY BE USED TO UPDATE A PDS MEMBER.'\n      'SETMSG MSG(ISRZ001)'\n      RETURN 1\n   END\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"SAVEINPL - OVERLAY CURRENT MEMBER WITH THIS DATA\"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    SAVEINPL \"\n   SAY\n   SAY \"       THE DATA BEING EDITED WILL OVERLAY THE CURRENT MEMBER'S\"\n   SAY \"       DATA IN THE PDS. THE PDS MUST BE FIXED RECORD FORMAT,  \"\n   SAY \"       RECFM EQUAL TO F OR FB, AND THE NUMBER OF LINES MUST   \"\n   SAY \"       NOT HAVE CHANGED.                                      \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCANPDS": {"ttr": 35083, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc3\\xc1\\xd5\\xd7\\xc4\\xe2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SCANPDS"}, "text": "//-YOUR-USERID-S JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  PDS SCAN FOR TEXT STRING\n//***\n//SEARCH     EXEC     PGM=ISRSUPC,REGION=4M,\n//             PARM=(SRCHCMP,'ANYC,IDPFX,NOPRTCC,SDUPM,XREF')\n//OUTDD        DD       SYSOUT=*\n//SYSIN        DD       *\nSRCHFOR   '...'\n//NEWDD        DD       DISP=SHR,DSN=...\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCANPDSX": {"ttr": 35085, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00/\\x00/\\x00\\x00\\xe2\\xc3\\xc1\\xd5\\xd7\\xc4\\xe2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "SCANPDS"}, "text": "//-YOUR-USERID-S JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  PDS SCAN FOR TEXT STRING WITH FULL OPTION DESCRIPTIONS\n//***\n//SEARCH     EXEC     PGM=ISRSUPC,REGION=4M,\n//             PARM=(SRCHCMP,'ANYC,IDPFX,NOPRTCC,SDUPM,LPSF')\n//* ANYC    - PROCESS TEXT LINES AS UPPER CASE\n//* IDPFX   - LIST MEMBER/FILE AS PREFIX TO EACH FOUND LINE\n//* LPSF    - LIST LINES BEFORE AND AFTER - USE W/ LPSFV BELOW\n//*           CONFLICTS WITH XREF\n//* SDUPM   - SEARCH DUPLICATE MEMBERS\n//* XREF    - PROVIDES LINES FOUND FOR EACH SEARCH STRING\n//*           CONFLICTS WITH LPSF\n//* COBOL   - IGNORE SEQUENCE COLUMNS 1-6 ON F 80 INPUT SOURCE FILES\n//* NOPRTCC - NO PRINT CONTROL COLUMN AND PAGE SEPARATORS\n//OUTDD        DD       SYSOUT=*\n//SYSIN        DD       *\nSRCHFOR  './'\nLPSFV 2\n//SYSIN        DD       *\nSRCHFOR  'ABC',01:72\n*  SCAN FOR ABC FROM COLUMNS 1 THROUGH 72\n*  MAY ALSO SPECIFY W FOR WORD, P FOR PREFIX, OR S FOR SUFFIX -\n*    E.G. SRCHFOR 'ABC',P,12 SCANNING FOR ABC AS A PREFIX FROM 12 ON\n*  ANY NUMBER OF SRCHFOR'S MAY BE USED AS ONE OR THE OTHER\nSRCHFORC 'DEF'\n*  USED WITH SRCHFOR TO SPECIFY \"AND\" CONDITION, I.E. DEF MUST BE ON\n*    SAME LINE - ADDING A +, E.G. SRCHFORC 'DEF',+ MEANS DEF MUST\n*    FOLLOW ABC ON SAME LINE\n*  HEX VALUES MAY BE USED ON SRCHFOR/C AS X'......'\n*  TWO QUOTES MAY BE USED TO SPECIFY ONE AS THE SCAN VALUE, E.G.\n*    SRCHFOR  'DON''T'\nCMPCOLM  01:20  45:60\n*  USE TO SPECIFY MULTI COLUMN RANGES TO BE SCANNED\nSTRING(S) SELECT   MEMBER1,MEMBER2,...\n*  SEARCH ONLY MEMBERS SPECIFIED\nDPLINE   'IGNORE LINES WITH THIS DATA'\nDPLINEC  'IGNORE LINES WITH THIS DATA AS WELL AT THAT PRECEDING '\n*  ALLOWS STRINGS WITH THIS SUB-STRING (OR SUB-STRINGS) TO BE IGNORED\n*    DPLINEC ALLOWS AND CONDITION WITH DPLINE\nLPSFV  2\n*  LIST # LINES BEFORE/AFTER EACH FOUND (CONFLICTS WITH XREF) # <= 6\nLSTCOLM  01:60\n*  LIST COLUMNS\n//NEWDD        DD       DISP=SHR,DSN=...\n//***\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SETRC": {"ttr": 35087, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00;\\x00;\\x00\\x00\\xe2\\xc5\\xe3\\xd9\\xc3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 59, "newlines": 59, "modlines": 0, "user": "SETRC"}, "text": "//-YOUR-USERID-S JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//*** PROGRAM TO SET A SYSTEN RETURN CODE; IF NO PARM IS INPUT, RET 0\n//***\n//A          EXEC     PGM=ASMA90,REGION=4M,\n//             PARM='OBJECT'\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n         USING *,11\nSETRC    STM   14,12,12(13)\n         LR    11,15\n         LA    14,SAVEAREA\n         ST    14,8(13)\n         ST    13,4(14)\n         LR    13,14\n         L     3,0(1)           * GET PTR TO PARM\n         LH    4,0(3)           * GET LENGTH OF PARM\n         LTR   4,4\n         BNZ   REALPARM\nDEFAULT  SR    15,15            * IF ZERO LEN, DEFAULT TO 0 RET CODE\n         B     RETCODE\nREALPARM BCTR  4,0\n         STC   4,TRTINST+1      * CHECK FOR NUMERIC\nTRTINST  TRT   2(1,3),NUMTBL\n         BC    7,DEFAULT\n         LA    5,112(4)\n         STC   5,PACKINST+1\nPACKINST PACK  DW,2(1,3)\n         CVB   15,DW\n         C     15,MAX           * CHECK FOR MAX (4095)\n         BH    DEFAULT\nRETCODE  L     13,4(13)\n         L     14,12(13)\n         LM    0,12,20(13)\n         BR    14\nDW       DS    D\nSAVEAREA DS    9D\nNUMTBL   DC    240X'FF',10X'00',6X'FF'\nMAX      DC    F'4095'\n         END   SETRC\n//***\n//L          EXEC     PGM=IEWL,\n//             PARM='XREF,LIST,LET,DCBS',\n//             REGION=4M\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,\n//             DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   99091400\n  NAME     SETRC(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SETRC$": {"ttr": 35089, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x06\\x00\\x06\\x00\\x00\\xe2\\xc5\\xe3\\xd9\\xc3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 6, "newlines": 6, "modlines": 0, "user": "SETRC"}, "text": "//-YOUR-USERID-S JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//SETRETC    EXEC     PGM=SETRC,PARM=0912\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SHIFT": {"ttr": 35091, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xf8\\x00\\xf8\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 248, "newlines": 248, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- SHIFT COLUMNS WITHIN BOUNDS  **/\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'SHIFT MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT \"ISREDIT MACRO (PARMS)\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY SHIFT 'EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT',\n         'WITH NO PENDING EDIT COMMANDS!'\n      SIGNAL EOJ\n   END\n\n   ERRORMSG = \"\"\n   MESG     = \"\"\n\n   PARMS     = TRANSLATE(PARMS)\n   LBL1      = \"\"\n   LBL2      = \"\"\n   DIRECTION = \"\"\n   TYPE      = \"\"\n   LINEEXCL  = \"\"\n   NUMCOLS   = \"\"\n   DO II = 1 TO 20\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \"BAD LABEL\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n      END\n      ELSE DO\n         IF DATATYPE(TOKEN,'W')  THEN DO\n            IF NUMCOLS = \"\" THEN NUMCOLS = TOKEN\n            ELSE IF NUMCOLS <> TOKEN THEN DO\n               ZEDSMSG = \"BAD # COLS\"\n               ZEDLMSG = \"TOO MANY SHIFT COLUMNS --\" NUMCOLS TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n         END\n         ELSE IF TOKEN = 'L' | TOKEN = 'LEFT' THEN DO\n            IF DIRECTION = \"\" THEN DIRECTION = TOKEN\n            ELSE IF DIRECTION <> TOKEN THEN DO\n               ZEDSMSG = \"BAD DIRECTION\"\n               ZEDLMSG = \"TOO MANY DIRECTIONS ENTERED\" DIRECTION TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n         END\n         ELSE IF TOKEN = 'R' | TOKEN = 'RIGHT' THEN DO\n            IF DIRECTION = \"\" THEN DIRECTION = TOKEN\n            ELSE IF DIRECTION <> TOKEN THEN DO\n               ZEDSMSG = \"BAD DIRECTION\"\n               ZEDLMSG = \"TOO MANY DIRECTIONS ENTERED\" DIRECTION TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n         END\n         ELSE IF TOKEN = 'X' THEN DO\n            IF LINEEXCL = \"\" THEN LINEEXCL = TOKEN\n            ELSE IF LINEEXCL <> TOKEN THEN DO\n               ZEDSMSG = \"BAD EXCL OPTION\"\n               ZEDLMSG = \"TOO MANY X|NX ENTERED\" LINEEXCL TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n         END\n         ELSE IF TOKEN = 'NX' THEN DO\n            IF LINEEXCL = \"\" THEN LINEEXCL = TOKEN\n            ELSE IF LINEEXCL <> TOKEN THEN DO\n               ZEDSMSG = \"BAD EXCL OPTION\"\n               ZEDLMSG = \"TOO MANY X|NX ENTERED\" LINEEXCL TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n         END\n         ELSE IF TOKEN = 'MAX' THEN DO\n            IF TYPE = \"\" THEN TYPE = TOKEN\n            ELSE IF TYPE <> TOKEN THEN DO\n               ZEDSMSG = \"BAD TYPE\"\n               ZEDLMSG = \"TOO MANY TYPES ENTERED\" TYPE TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n         END\n         ELSE IF TOKEN = 'LEAVE' THEN DO\n            IF TYPE = \"\" THEN TYPE = TOKEN\n            ELSE IF TYPE <> TOKEN THEN DO\n               ZEDSMSG = \"BAD TYPE\"\n               ZEDLMSG = \"TOO MANY TYPES ENTERED\" TYPE TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n         END\n         ELSE DO\n            ZEDSMSG = \"?\"TOKEN\"?\"\n            ZEDLMSG = \"UNKNOWN OPTION SPECIFIED\" TOKEN\n            ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n            EXIT 8\n         END\n      END\n   END II\n\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n   IF NUMCOLS = '' THEN NUMCOLS = 1\n   IF DIRECTION = ''  THEN DO\n      MESG = 'DIRECTION MUST BE SUPPLIED!'\n      SIGNAL ERROR\n   END\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR \"\n   \"ISREDIT (\"LEFTB\",\"RIGHTB\")   = BOUNDS \"\n   IF NUMCOLS > (RIGHTB-LEFTB+1) THEN NUMCOLS = RIGHTB-LEFTB+1\n   \"ISREDIT (END)                = LINENUM .ZLAST\"\n   START = 1\n   IF LBL1 <> '' THEN \"ISREDIT (START) = LINENUM &LBL1\"\n   IF LBL2 <> '' THEN \"ISREDIT (END) = LINENUM &LBL2\"\n   ELSE LBL2 = LBL1\n   IF START > END THEN DO\n      WST = START\n      START = END\n      END = WST\n   END\n\n   DO PNTR =  START  TO  END  BY 1\n      \"ISREDIT (LINESTAT) = XSTATUS\" PNTR\n      IF LINEEXCL = '' | LINESTAT = LINEEXCL THEN DO\n         \"ISREDIT (REC) = LINE &PNTR\"\n         IF SUBSTR(DIRECTION,1,1) = 'L' THEN DO\n            IF TYPE = ''\n               THEN REC = OVERLAY(SUBSTR(REC,LEFTB+NUMCOLS,\n                  ,RIGHTB-LEFTB+1-NUMCOLS),\n                     ,REC,LEFTB,RIGHTB-LEFTB+1,' ')\n            ELSE IF TYPE = 'MAX' THEN DO\n               XX = VERIFY(SUBSTR(REC,LEFTB,NUMCOLS),' ')\n               IF XX = 0\n                     THEN REC = OVERLAY(SUBSTR(REC,LEFTB+NUMCOLS,\n                        ,RIGHTB-LEFTB+1-NUMCOLS),\n                           ,REC,LEFTB,RIGHTB-LEFTB+1,' ')\n                     ELSE REC = OVERLAY(SUBSTR(REC,LEFTB+XX-1,\n                        ,RIGHTB-LEFTB+1-XX),\n                           ,REC,LEFTB,RIGHTB-LEFTB+1,' ')\n            END\n            ELSE IF VERIFY(SUBSTR(REC,LEFTB,NUMCOLS),' ') = 0\n               THEN REC = OVERLAY(SUBSTR(REC,LEFTB+NUMCOLS,\n                  ,RIGHTB-LEFTB+1-NUMCOLS),\n                     ,REC,LEFTB,RIGHTB-LEFTB+1,' ')\n         END\n         ELSE DO\n            IF TYPE = ''\n               THEN REC = OVERLAY(COPIES(' ',NUMCOLS),\n                  || SUBSTR(REC,LEFTB, RIGHTB-LEFTB+1),\n                        ,REC,LEFTB,RIGHTB-LEFTB+1)\n               ELSE IF TYPE = 'MAX' THEN DO\n                  DO XX = 0 TO NUMCOLS-1,\n                     WHILE SUBSTR(REC,RIGHTB-XX,1) = ' '\n                  END\n                  REC = OVERLAY(COPIES(' ',XX),\n                     || SUBSTR(REC,LEFTB,RIGHTB-LEFTB+1),\n                           ,REC,LEFTB,RIGHTB-LEFTB+1)\n               END\n               ELSE IF SUBSTR(REC,RIGHTB-NUMCOLS+1,NUMCOLS) = ' '\n                  THEN REC = OVERLAY(COPIES(' ',NUMCOLS),\n                     || SUBSTR(REC,LEFTB,RIGHTB-LEFTB+1),\n                           ,REC,LEFTB,RIGHTB-LEFTB+1)\n         END\n         \"ISREDIT LINE &PNTR = &STR(REC)\"\n      END\n   END\n\n   \"ISREDIT LOCATE\" START\n   SIGNAL EOJ\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   CALL DISPDOC\n   SIGNAL EOJ\n\nEOJ:\n   X = MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"SHIFT - SHIFT COLUMNS LEFT OR RIGHT WITHIN BOUNDS  \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    SHIFT  LEFT|RIGHT  ( #COLUMNS )                \"\n   SAY \"           ( X|NX )    ( .A .B )    ( MAX|LEAVE )  \"\n   SAY\n   SAY \"       DIRECTION IS REQUIRED. LEFT MAY BE ENTERED AS 'L'  \"\n   SAY \"       AND RIGHT AS 'R'. # COLUMNS DEFAULTS TO 1. LABEL   \"\n   SAY \"       RANGES ARE OPTIONAL. X OR NX MAY BE SPECIFIED TO   \"\n   SAY \"       RESTRICT THE SHIFT TO EXCLUDED OR UNEXCLUDED LINES \"\n   SAY \"       ONLY (DEFAULT IS ALL LINES). 'MAX' IMPLIES THAT THE\"\n   SAY \"       SHIFT WILL ONLY CUT OFF BLANKS, STOPPING AT NON-   \"\n   SAY \"       BLANKS; 'LEAVE' THAT A SHIFT THAT WOULD TRUNCATE   \"\n   SAY \"       NON BLANKS WILL NOT BE DONE AT ALL. FULL TRUNCATION\"\n   SAY \"       IS THE DEFAULT. OPTIONS MAY BE INTERMIXED.         \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY \"    SHIFT  7  LEFT  .II .JJ                          \"\n   SAY \"       SHIFTS LEFT ALL DATA BETWEEN .II AND .JJ      \"\n   SAY \"       7 COLUMNS, TRUNCATING AS NECESSARY, WITHIN    \"\n   SAY \"       THE CURRENT BOUNDS.                           \"\n   RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHORTEST": {"ttr": 35333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x03'\\x1f\\x01\\x03'\\x1f\\x12\\x00\\x00e\\x00e\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-09-28T00:00:00", "modifydate": "2003-09-28T12:00:00", "lines": 101, "newlines": 101, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- DETERMINE SHORTEST LINE & SHOW 1ST ONE **/\n   ADDRESS \"ISREDIT\"\n   \"MACRO (PARMS) NOPROCESS\"\n\n   LABF   = \"\"\n   LABL   = \"\"\n   FIRST  = -1\n\n   PARMS = TRANSLATE(PARMS)\n   IF PARMS = '?' THEN SIGNAL DISPDOC\n   DO II = 1 TO 10;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LABF = \"\" THEN LABF = TOKEN\n         ELSE IF LABL = \"\" THEN LABL = TOKEN\n         ELSE DO\n            ZEDSMSG = \".LABEL RC=8\"\n            ZEDLMSG = \"TOO MANY LABELS --\" LABF LABL TOKEN\n            ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n            EXIT 8\n         END\n      END\n   END II\n   IF LABF <> \"\"  &  LABL = \"\"  THEN LABL = LABF\n\n   IF LABL = \"\" THEN DO\n      \"PROCESS RANGE C\"\n      IF RC = 0 THEN DO\n         LABF = \".ZFRANGE\"\n         LABL = \".ZLRANGE\"\n      END\n      ELSE DO\n         LABF = \".ZFIRST\"\n         LABL = \".ZLAST\"\n      END\n   END\n\n   \"(LABFNO) = LINENUM\" LABF\n   \"(LABLNO) = LINENUM\" LABL\n   \"ISREDIT (\"LRECL\") = LRECL\"\n   \"ISREDIT (\"RECFM\") = RECFM\"\n\n   SHORTEST_SIZE = LRECL\n   IF SUBSTR(RECFM,1,1) <> \"F\" THEN DO\n      DO II = LABFNO TO LABLNO\n         \"ISREDIT (CURRSIZE) = SAVE_LENGTH\" II\n         IF CURRSIZE < SHORTEST_SIZE THEN DO\n            SHORTEST_SIZE   = CURRSIZE\n            NUMBER_SHORTEST = 1\n            FIRST           = II\n         END\n         ELSE IF CURRSIZE = SHORTEST_SIZE,\n            THEN NUMBER_SHORTEST = NUMBER_SHORTEST + 1\n      END\n   END\n   ELSE DO\n      DO II = LABFNO TO LABLNO\n         \"(REC) = LINE\" II\n         DO JJ = LRECL TO 1 BY -1 WHILE(SUBSTR(REC,JJ,1) = \" \")\n         END JJ\n         IF JJ < SHORTEST_SIZE THEN DO\n            SHORTEST_SIZE   = JJ\n            NUMBER_SHORTEST = 1\n            FIRST           = II\n         END\n         ELSE IF JJ = SHORTEST_SIZE,\n            THEN NUMBER_SHORTEST = NUMBER_SHORTEST + 1\n      END\n   END\n\n   \"LOCATE\" FIRST\n   SHORTEST_SIZE = SHORTEST_SIZE + 0\n   ZEDSMSG = \"SHORTEST\" SHORTEST_SIZE\"(\"NUMBER_SHORTEST\")\"\n   ZEDLMSG = NUMBER_SHORTEST \"RECORDS OF\" SHORTEST_SIZE \"LENGTH\"\n   ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   EXIT(1)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"SHORTEST - FIND FIRST SHORTEST RECORD IN THE RANGE        \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    SHORTEST  ( .A .B )                                   \"\n   SAY\n   SAY \"       MAKES THE FIRST LINE WITH THE SMALLEST LENGTH THE  \"\n   SAY \"       TOP LINE ON THE DISPLAY.  THE ACTUAL LENGTH IS     \"\n   SAY \"       SHOWN IN THE UPPER RIGHT MESSAGE AREA AS WELL AS   \"\n   SAY \"       THE NUMBER OF RECORDS OF SUCH SIZE IN THE RANGE.   \"\n   SAY\n   SAY \"       FOR FIXED DATA, THE SMALLEST LINE HAS THE LARGEST  \"\n   SAY \"       NUMBER OF BLANKS ON THE RIGHT.                     \"\n   SAY\n   SAY \"       EITHER LABELS OR C/CC/C# MAY BE USED TO LIMIT THE  \"\n   SAY \"       LENGTH CHECK; WILL PROCESS THE ENTIRE FILE IF      \"\n   SAY \"       NEITHER IS SPECIFIED.  OBVIOUSLY MOST USEFUL FOR   \"\n   SAY \"       VARIABLE LENGTH FILES.                             \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHUFFLE": {"ttr": 35336, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x008\\x008\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 56, "newlines": 56, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- SHUFFLE A RANGE OF SELECTED LINES  **/\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'SHUFFLE MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   UMODE = \"ISREDIT\"\n   ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n   ADDRESS ISREDIT\n   \"MACRO (PARMS) NOPROCESS\"\n   IF PARMS = '?' THEN SIGNAL DISPDOC\n   \"PROCESS RANGE C\"\n   IF RC > 0 THEN DO\n         \"(TOP) = LINENUM .ZFIRST\"\n         \"(BOT) = LINENUM .ZLAST\"\n      END\n   ELSE DO\n         \"(TOP) = LINENUM .ZFRANGE\"\n         \"(BOT) = LINENUM .ZLRANGE\"\n      END\n\n   DO II = TOP TO BOT\n      RR = RANDOM(TOP,BOT)\n      \"ISREDIT (REC1) = LINE\" II\n      \"ISREDIT (REC2) = LINE\" RR\n      \"ISREDIT LINE &II = &STR(REC2)\"\n      \"ISREDIT LINE &RR = &STR(REC1)\"\n   END\n\nQUIT:\n   ADDRESS ISPEXEC\n   X=MSG(SAVEMSG)\n   ADDRESS ISREDIT \"LOCATE\" TOP\n   ADDRESS ISREDIT \"RESET\"\n   EXIT(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"SHUFFLE - RANDOMLY REARRANGE A FILE OR A GROUP OF LINES   \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    SHUFFLE                                               \"\n   SAY\n   SAY \"       RANDOMLY CHANGES THE SEQUENCE OF EITHER A SPECIFIED\"\n   SAY \"       C/CC/C# RANGE OF LINES OR THE ENTIRE FILE. THE     \"\n   SAY \"       SHUFFLING IS BASED ON THE REXX PSEUDO RANDOM NUMBER\"\n   SAY \"       GENERATOR.                                         \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SLEEP": {"ttr": 35338, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00 \\x00 \\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "REXX"}, "text": "/** REXX -- CAUSE RESPONSE TO SLEEP FOR GIVEN NUMBER OF SECONDS **/\n   ARG PARMS\n   IF PARMS = '?' THEN SIGNAL DISPDOC\n   SECONDS = WORD(PARMS,1)\n   IF DATATYPE(SECONDS,\"WHOLE NUMBER\")\n      THEN SECONDS = ABS(SECONDS)\n      ELSE IF SECONDS = ''\n         THEN SECONDS = 5\n         ELSE SIGNAL DISPDOC\n   IF SYSCALLS('ON') > 0\n      THEN DO\n         SAY 'UNABLE TO ESTABLISH NEEDED SYSCALL ENVIRONMENT'\n         EXITRC = SYSCALLS('ON')\n         EXIT(EXITRC)\n      END\n   ADDRESS SYSCALL 'SLEEP ' SECONDS\n   EXIT(RC)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"SLEEP -- DELAY FOR GIVEN NUMBER OF SECONDS                \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    SLEEP  ( NUM-SECS )                                   \"\n   SAY\n   SAY \"       DELAY FOR NUM-SECS NUMBER OF SECONDS BEFORE        \"\n   SAY \"       RETURNING CONTROL. USES SYSCALLS FACILITY AND      \"\n   SAY \"       WILL DEFAULT TO 5 SECONDS.                         \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SMARTGN": {"ttr": 35340, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x8e\\x00\\x8e\\x00\\x00\\xe2\\xd4\\xc1\\xd9\\xe3\\xc7\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 142, "newlines": 142, "modlines": 0, "user": "SMARTGN"}, "text": "//-YOUR-USERID-S JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  GENERATE CONTROL CARDS FOR A LIST OF DATA SETS\n//***    CONTROL CARDS TO BE GENERATED ARE IN FILE SYSCTL\n//***    INPUT DATA SET NAMES ARE IN FILE SYSIN\n//***    OUTPUT CONTROL CARD COPIES ARE IN FILE SYSOUT\n//***\n//***  ? IN THE CONTROL CARDS WILL BE REPLACED BY THE DATA SET NAME\n//***  # (UP TO 8 IN A ROW) WILL BE REPLACED BY THE INPUT NUMBER\n//***  ! IS REPLACED BY TODAY AS YYMMDD\n//***  % IS REPLACED BY TODAY AS CCYYMMDD\n//***  @ IS REPLACED BY CURRENT TIME AS HHMMSS\n//***\n//C          EXEC     PGM=IEL0AA,REGION=4M,\n//             PARM=('AG,A,NCT,ESD,F(I),NOFLOW,NIS,NOLIST,M,NMI,NEST',\n//             'MAP,OF,OPT(TIME),OP,SZ(MAX),S,STMT,STG,X(F)')\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-PLI-LIB-\n\n SMARTGN: PROC OPTIONS(MAIN) REORDER;\n\n        DCL  REC               CHAR(00080) STATIC;\n        DCL  REC_ARRAY(01000)  CHAR(00080) STATIC INIT('');\n        DCL  NAME              CHAR(00050) STATIC VARYING INIT('');\n        DCL  CCYYMMDD          CHAR(00008) STATIC;\n        DCL  YYMMDD            CHAR(00006) STATIC;\n        DCL  HHMMSS            CHAR(00006) STATIC;\n        DCL  PIC99999999       PIC '99999999' STATIC INIT(0);\n        DCL  PIC_OFFSET        FIXED BIN(31) STATIC;\n        DCL  REC_COUNT         FIXED BIN(31) STATIC INIT(0);\n        DCL  INPUT_COUNT       FIXED BIN(31) STATIC INIT(0);\n        DCL  (II,JJ,KK)        FIXED BIN(31) STATIC INIT(0);\n        DCL  SYSCTL_EOF_IND    CHAR(01) STATIC INIT('N');\n        DCL  SYSIN_EOF_IND     CHAR(01) STATIC INIT('N');\n\n        DCL  DATE      BUILTIN;\n        DCL  TIME      BUILTIN;\n\n\n        YYMMDD   = DATE;\n        IF SUBSTR(YYMMDD,1,2) < '50'\n           THEN CCYYMMDD = '20' || YYMMDD;\n           ELSE CCYYMMDD = '19' || YYMMDD;\n        HHMMSS   = SUBSTR(TIME,01,06);\n\n        ON ENDFILE(SYSCTL) SYSCTL_EOF_IND = 'Y';\n        READ FILE(SYSCTL) INTO(REC);\n        DO WHILE ( SYSCTL_EOF_IND  \u00ac= 'Y' );\n           CALL FILL_CTL_ARRAY;\n           END;\n\n        ON ENDFILE(SYSIN) SYSIN_EOF_IND = 'Y';\n        READ FILE(SYSIN) INTO(REC);\n        DO WHILE ( SYSIN_EOF_IND   \u00ac= 'Y' );\n           CALL GEN_CTL_FOR_EACH_INPUT;\n           END;\n\n\n FILL_CTL_ARRAY: PROC;\n        REC_COUNT = REC_COUNT + 1;\n        REC_ARRAY(REC_COUNT) = REC;\n        IF REC_COUNT >= HBOUND(REC_ARRAY,1)\n           THEN SYSCTL_EOF_IND = 'Y';\n           ELSE READ FILE(SYSCTL) INTO(REC);\n        END FILL_CTL_ARRAY;\n\n GEN_CTL_FOR_EACH_INPUT: PROC;\n        INPUT_COUNT = INPUT_COUNT + 1;\n        DO II = 1 TO LENGTH(REC)\n              WHILE ( SUBSTR(REC,II,1) \u00ac= ' ' );\n           END;\n        IF II = 1\n           THEN NAME = 'BLANK INPUT';\n           ELSE NAME = SUBSTR(REC,1,II-1);\n        DO II = 1 TO REC_COUNT;\n           REC = REC_ARRAY(II);\n           JJ = INDEX(REC,'?');\n           DO WHILE ( JJ > 0 );\n              REC = SUBSTR(REC,1,JJ-1)\n                 || NAME\n                 || SUBSTR(REC,JJ+1);\n              JJ = INDEX(REC,'?');\n              END;\n           JJ = INDEX(REC,'#');\n           DO WHILE ( JJ > 0 );\n              PIC99999999 = INPUT_COUNT;\n              DO KK = JJ TO 80\n                    WHILE ( SUBSTR(REC,KK,1) = '#' );\n                 END;\n              REC = SUBSTR(REC,1,JJ-1)\n                 || SUBSTR(PIC99999999,9-KK+JJ)\n                 || SUBSTR(REC,KK);\n              JJ = INDEX(REC,'#');\n              END;\n           JJ = INDEX(REC,'!');\n           DO WHILE ( JJ > 0 );\n              REC = SUBSTR(REC,1,JJ-1)\n                 || YYMMDD\n                 || SUBSTR(REC,JJ+1);\n              JJ = INDEX(REC,'!');\n              END;\n           JJ = INDEX(REC,'%');\n           DO WHILE ( JJ > 0 );\n              REC = SUBSTR(REC,1,JJ-1)\n                 || CCYYMMDD\n                 || SUBSTR(REC,JJ+1);\n              JJ = INDEX(REC,'%');\n              END;\n           JJ = INDEX(REC,'@');\n           DO WHILE ( JJ > 0 );\n              REC = SUBSTR(REC,1,JJ-1)\n                 || HHMMSS\n                 || SUBSTR(REC,JJ+1);\n              JJ = INDEX(REC,'@');\n              END;\n           WRITE FILE(SYSOUT) FROM(REC);\n           END;\n        READ FILE(SYSIN) INTO(REC);\n        END GEN_CTL_FOR_EACH_INPUT;\n\n        END SMARTGN;\n\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(CYL,(05,02))\n//***\n//L          EXEC     PGM=HEWLKED,\n//             PARM='XREF,LIST,LET,DCBS,AMODE(31),RMODE(ANY)',\n//             REGION=4M\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE)\n//             DD       *\n  SETSSI   99111403\n  ENTRY    PLISTART\n  NAME     SMARTGN(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SMARTGN$": {"ttr": 35344, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xd4\\xc1\\xd9\\xe3\\xc7\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "SMARTGN"}, "text": "//-YOUR-USERID-S JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  GENERATE CONTROL CARDS FOR A LIST OF TOKENS\n//***    CONTROL CARDS TO BE GENERATED ARE IN FILE SYSCTL\n//***    INPUT DATA SET NAMES ARE IN FILE SYSIN\n//***    OUTPUT CONTROL CARD COPIES ARE IN FILE SYSOUT\n//***  ? IN THE CONTROL CARDS WILL BE REPLACED BY A TOKEN\n//***  # (UP TO 8 IN A ROW) WILL BE REPLACED BY THE INPUT NUMBER\n//***  ! IS REPLACED BY TODAY AS YYMMDD\n//***  % IS REPLACED BY TODAY AS CCYYMMDD\n//***  @ IS REPLACED BY CURRENT TIME AS HHMMSS\n//***\n//DELETE     EXEC       PGM=IEFBR14\n//SCRATCH      DD         DISP=(MOD,DELETE,DELETE),\n//             DSN=-YOUR-USERID-.$$$TEMP.SMARTGEN.OUTPUT,          <***\n//             UNIT=SYSDA,SPACE=(TRK,0)\n//***\n//SMARTGEN   EXEC     PGM=SMARTGN,REGION=4M\n//SYSCTL       DD       DATA,DLM=XX                                <***\nDATA-TO-BE-REPLICATED...\n###  !  %  @  DSN(?)  HARD STUFF :)\nXX\n//SYSOUT       DD       DSN=-YOUR-USERID-.$$$TEMP.SMARTGEN.OUTPUT,\n//             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(010,010),RLSE),\n//             DCB=(RECFM=FB,LRECL=00080,BLKSIZE=00000)\n//SYSIN        DD       *                                          <***\nSOME-TOKEN...\nANOTHER-TOKEN...\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SNACK": {"ttr": 35585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\"\\x00\"\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "REXX"}, "text": "/* REXX -- SNACK -- X ALL AND F ALL THE STRING THE CURSOR IS ON     */\n\n   ADDRESS ISREDIT\n   \"MACRO (PARMS)\"\n   IF PARMS = \"?\" THEN SIGNAL DISPDOC\n   ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n   \"(ROW,COL) = CURSOR\"\n   \"(DATA1)   = LINE  \" ROW\n\n   DO JJ = COL-1 TO  1 BY -1 WHILE ( SUBSTR(DATA1,JJ,1) <> ' ' )\n   END\n   DO KK = COL+1 TO 72 BY  1 WHILE ( SUBSTR(DATA1,KK,1) <> ' ' )\n   END\n\n   SRCHSTR = SUBSTR(DATA1,JJ+1,KK-JJ-1)\n   \"X ALL\"\n   \"FIND ALL\" SRCHSTR\n   EXIT(1)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"SNACK - DISPLAY ONLY LINES WITH STRING UNDER CURSOR \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    SNACK  ( ? )                                              \"\n   SAY\n   SAY \"       DOES AN 'X ALL' AND THEN A 'FIND ALL' AGAINST THE      \"\n   SAY \"       STRING UNDER THE CURSOR. THE STRING MUST BE DELIMITED  \"\n   SAY \"       BY BLANKS OR BE AT THE START OR END OF A LINE.         \"\n   SAY\n   EXIT(1)\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SORTNX": {"ttr": 35587, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xc3\\x00\\xc3\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 195, "newlines": 195, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- SORT UNEXCLUDED LINES KEEPING EXCLUDED LINES ATTACHED  **/\n\n   SUBCOM ISREDIT\n   IF  RC = 0  THEN DO\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT \"ISREDIT MACRO (PARMS)\"\n      IF  RC = 0  THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF  DSN = 'DSN'  THEN DO\n      SAY 'SORTNX MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n\n   ADDRESS \"ISREDIT\"\n   PARMS   = TRANSLATE(PARMS)\n   PARMCNT = 0\n   COL.    = \"\"\n   LBL1    = \"\"\n   LBL2    = \"\"\n   DO II = 1 TO 16;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n      END\n      ELSE DO\n         PARMCNT     = PARMCNT + 1\n         COL.PARMCNT = TOKEN\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n   IF (PARMCNT // 2) <> 0 THEN DO\n      SAVER       = COL.PARMCNT\n      PARMCNT     = PARMCNT + 1\n      COL.PARMCNT = SAVER\n   END\n\n   ERRORMSG = ''\n   MESG     = ''\n   IF  PARMCNT = 0 THEN DO\n      MESG = 'PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   DO II = 1 TO PARMCNT\n      IF  \u00acDATATYPE(COL.II,'W') | COL.II = 0 THEN DO\n         MESG = \"'\"COL.II\"' COLUMN VALUE IS INVALID!\"\n         SIGNAL ERROR\n      END\n      IF  COL.II > LRECL  THEN DO\n         MESG = \"'\"COL.II\"' IS GREATER THAN RECORD SIZE(\"LRECL\")\"\n         SIGNAL ERROR\n      END\n   END II\n   DO II = 1 TO PARMCNT BY 2\n      JJ = II + 1\n      IF  COL.II > COL.JJ THEN DO\n         MESG = \"LEFT-COL \"COL.II\" IS GREATER THAN RIGHT-COL \"COL.JJ\n         SIGNAL ERROR\n      END\n   END II\n\n   IF  LBL1 <> ''  THEN DO\n      \"ISREDIT L &LBL1\"\n       IF  RC <>  0 THEN DO\n          MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   IF  LBL2 <> ''  THEN DO\n      \"ISREDIT L &LBL2\"\n       IF  RC <>  0 THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   IF  LBL1 <> ''  THEN  \"ISREDIT (START) = LINENUM &LBL1\"\n                   ELSE  START = 1\n   IF  LBL2 <> ''  THEN  \"ISREDIT (END) = LINENUM &LBL2\"\n                   ELSE  \"ISREDIT (END) = LINENUM .ZLAST\"\n\n   \"ISREDIT (\"ANUM\") = AUTONUM\"\n   \"ISREDIT NUMBER OFF \"\n\n   STEMCNT = 0\n   DO HH = START TO END\n      \"(LINESTAT) = XSTATUS\" HH\n      IF LINESTAT = 'NX' THEN DO\n         \"ISREDIT (RECORD)  = LINE\" HH\n         STEMCNT = STEMCNT + 1\n         IF STEMCNT = 1 THEN START = HH\n         STEM.STEMCNT = SUBSTR(RECORD,COL.1,COL.2-COL.1+1)\n         DO II = 3 TO PARMCNT BY 2\n            JJ = II + 1\n            STEM.STEMCNT = STEM.STEMCNT,\n               || SUBSTR(RECORD,COL.II,COL.JJ-COL.II+1)\n         END II\n         STEM.STEMCNT = STEM.STEMCNT || RIGHT(HH,6,'0')\n      END\n   END HH\n   IF STEMCNT = 0 | STEMCNT = 1 THEN SIGNAL TERM\n\n   HH = 1\n   DO WHILE HH <= (STEMCNT)\n      HH = ( 3 * HH ) + 1\n   END\n   DO WHILE HH > 0\n      DO II = ( HH + 1 ) TO STEMCNT\n         TT = STEM.II\n         JJ = II\n         KK = JJ - HH\n         DO WHILE ( JJ > HH ) & ( STEM.KK >> TT )\n            STEM.JJ = STEM.KK\n            JJ = JJ - HH\n            KK = JJ - HH\n         END\n         STEM.JJ = TT\n      END\n      HH = HH % 3\n   END\n\n\n   DO II = STEMCNT TO 1 BY -1\n      JJ = SUBSTR(STEM.II,LENGTH(STEM.II)-5)\n      \"ISREDIT (RECORD) = LINE\" JJ\n      \"ISREDIT LINE_AFTER &END = (RECORD)\"\n      KK = JJ + 1\n      \"(LINESTAT) = XSTATUS\" KK\n      LL = END + 1\n      DO WHILE LINESTAT = 'X'\n         \"ISREDIT (RECORD) = LINE\" KK\n         \"ISREDIT LINE_AFTER &LL = (RECORD)\"\n         KK = KK + 1\n         LL = LL + 1\n         \"XSTATUS\" LL \"= X\"\n         \"(LINESTAT) = XSTATUS\" KK\n      END\n   END\n   \"ISREDIT DELETE\" START END\n\n\nTERM:\n   CALL SETMSG '* NO ' STEMCNT 'RECORD SETS $UNEXCLUDED RECORDS SORTED'\n   IF START = 1 THEN \"ISREDIT LOCATE\" 0\n                ELSE \"ISREDIT LOCATE\" START\n   \"ISREDIT AUTONUM = \"ANUM\n    SIGNAL EOJ\n\nERROR:\n   IF MESG <> '' THEN DO\n      ERRORMSG = '===>' MESG\n   END\n   SIGNAL DISPDOC\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nEOJ:\n   RETURN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"SORTNX - SORT UNEXCLUDED LINES KEEPING ATTACHED EXCLUDED LINES\"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    SORTNX  COL1 COL2  ...  ( .LABEL1 .LABEL2) \"\n   SAY\n   SAY \"       ONE PAIR OF COLUMNS IS MANDATORY. UP TO 10 PAIR  \"\n   SAY \"       MAY BE SPECIFIED. THE LABEL RANGE IS OPTIONAL    \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    SORTNX  17 19  4 11 \"\n   SAY \"       WILL SORT THE ENTIRE NON EXCLUDED FILE BY COLUMNS\"\n   SAY \"       17 THRU 19 AND 4 THRU 11, PRESERVING ANY EXCLUDED\"\n   SAY \"       LINES IMMEDIATELY FOLLOWING EACH NON EXCLUDED    \"\n   SAY \"       LINE.                                            \"\n   SAY\n   RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SORTX": {"ttr": 35591, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xbd\\x00\\xbd\\x00\\x00\\xe2\\xd6\\xd9\\xe3@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 189, "newlines": 189, "modlines": 0, "user": "SORT"}, "text": "\n//***  GENERATE CURRENT DATE AS MM-DD-YYYY\n  OUTFIL FNAMES=...,OUTREC=(...,&DATE(MD4-),...\n\n//***  CONVERT PACKED TO ZONED IN OUTREC\n  OUTREC FIELDS=(1,10,11,3,PD,TO=ZD,LENGTH=5,...)\n\n//***  CONVERT PACKED TO BINARY IN OUTREC\n  OUTREC FIELDS=(1,10,11,3,PD,TO=BI,LENGTH=4,...)\n\n//***  ADD DECIMAL PLACES ON RIGHT\n  OUTREC FIELDS=(1,7,PD,MUL,+100,TO=PD,LENGTH=8)\n\n//***  COPY AND REPLACE HEX 00 AND FF WITH BLANKS\n  SORT  FIELDS=COPY\n    OUTFIL OUTREC=(1,10,11,10,TRAN=ALTSEQ,21,60)\n    ALTSEQ CODE=(0040,FF40)\n     **   FIRST 10 (1,10) POSITIONS ARE COPIED AS-IS\n     **   NEXT 10 (11,10) ARE TRANSLATED TO BLANKS IF X'00' OR X'FF'\n     **   THE REST OF THE POSITIONS (21,60) ARE COPIED ASIS\n\n//***  SORT AND INCLUDE ONLY CERTAIN VALUES\n  SORT     FIELDS=(0001,0003,CH,A)\n    INCLUDE  COND=(0001,0001,CH,EQ,C'D',\n               AND,0002,0002,CH,GT,C'02')\n\n//***  COPY INCLUDING STRING ANYWHERE WITHIN RANGE OF INPUT\n  SORT    FIELDS=COPY\n    INCLUDE COND=(0001,0080,SS,EQ,C'SOME STRING')\n\n//***  COPY INCLUDING WHERE 2 FIELDS ON SAME RECORD NOT EQUAL\n  SORT FIELDS=COPY\n    INCLUDE COND=(0001,0003,NE,0011,0003),FORMAT=CH\n\n//***  COPY CHANGING THE RANGE INTO ITS HEX EQUIVALENT\n  SORT      FIELDS=COPY\n    OUTREC  FIELDS=(0001,0003,HEX)\n\n//***  SPLIT FILE\n  OPTION  COPY\n    OUTFIL  FNAMES=DDNAME01,STARTREC=0000001,ENDREC=0000005\n    OUTFIL  FNAMES=DDNAME02,STARTREC=0000006,ENDREC=0000011\n    ...\n    OUTFIL  FNAMES=DDNAME99,STARTREC=0000012\n\n//***  PICK, SORT AND ALTER O/P\n  SORT  FIELDS=(0001,0001,CH,A)\n    INCLUDE  COND=(0001,0001,CH,EQ,C'2')\n    OUTREC   FIELDS=(0002X,0001,0001,0002X,C'''OTHER JUNK''',00012X)\n\n//***  SELECT BY NUMBER OF DUPS\n  INREC     FIELDS=(0001,0080,         * ENTIRE RECORD\n                    0004X'00',         * 4 LEADING BINARY 0'S\n                    0001X'1C')         * PACKED DECIMAL 1\n  SORT      FIELDS=(0001,0001,CH,A)    * SORT BY KEY FIELD(S)\n    SUM     FIELDS=(0081,05,PD)        * SUM THE \"COUNTER\"\n    OUTFIL  INCLUDE=(0081,05,PD,GT,2)  * ONLY OUTPUT RECS WITH 2 DUPS\n\n//***  SELECT VARIOUS RECORDS TO VARIED FILES\n   SORT  FIELDS=COPY\n     OUTFIL  FILES=01,                 * PICK OFF A'S\n       INCLUDE=(0001,0001,CH,EQ,C'A')\n     OUTFIL  FILES=02,                 * PICK OFF C'S\n       INCLUDE=(0001,0001,CH,EQ,C'C')\n     ...\n     OUTFIL  FILES=99,SAVE             * REMAINING\n\n//***  SPLIT VARIOUS RECORDS TO VARIED FILES\n  SORT  FIELDS=COPY\n    OUTFIL FNAMES=(FILE1,FILE2),SPLIT,\n      INCLUDE=(0002,0002,ZD,GE,02),OUTREC=(5X,1,75)\n\n//***\n  SUM  FIELDS=NONE,XSUM              * WRITE DUPS TO SORTXSUM DD\n  SORT FIELDS=(0001,0080,CH,A)       * WRITE OTHERS SORTED TO SORTOUT\n\n//***  PICK UP SINGLE ENTRIES ONLY\n  INREC   FIELDS=(0001,0080,            * ENTIRE INPUT RECORD\n                  X'000000001C')        * COUNT AS PIC S9(9) COMP-3\n  SORT    FIELDS=(0001,0001,CH,A)       * SORT BY KEY\n  SUM     FIELDS=(0081,0005,PD)         * ADD UP \"COUNTER\" FIELDS\n  OUTFIL  INCLUDE=(0081,0005,PD,EQ,1),  * ONLY SINGLE OCCURANCES\n          OUTREC=(0001,0080)            * TRIM OFF COUNTER FIELD\n\n//***  ADD FIELDS FROM SAME RECORD\n  INREC FIELDS=(0001,0001,\n                0002X,\n                C'ADDED TO ITSELF IS  ',\n                (0001,0001,ZD,ADD,0001,0001,ZD),ZD,LENGTH=0005,\n                0052X)\n  SORT  FIELDS=(0001,0001,CH,A)\n\n//***  ELIMINATE ALL DUPS\n  SORT  FIELDS=(0001,0001,CH,A)\n    SUM FIELDS=NONE\n\n//***  TALLY KEYS\n  INREC FIELDS=(0001,0001,      * SORT KEY\n                0002X,          * COUPLE OF BLANKS\n                C'00001',       * FIELD TO BE TALLIED\n                0074X)          * BLANK REMAINING DATA\n  SORT  FIELDS=(0001,0001,CH,A) * SORT THEM\n    SUM FIELDS=(0004,0005,ZD)   * COUNT THE DUP KEYS\n\n//***  CHANGE STUFF\n    OPTION COPY * LEAVE 1 TO 10, CHANGE 11 FOR 2\n                * CHANGE 11 TO 66 AND 22 TO 99, ELSE LEAVE ALONE\n                * THEN ALL ELSE\n    OUTREC FIELDS=(1,10,\n      11:1,2,CHANGE=(2,C'11',C'66',C'22',C'99'),\n        NOMATCH=(11,2),\n      13:13,999)\n\n//***  FULL BLOODY REPORT\n  SORT  FIELDS=(0001,0001,CH,A)\n  OUTFIL  LINES=55,\n      HEADER2=(1:'PAGE ',&PAGE,' OF TRIAL REPORT FOR ',&DATE,\n               2/,\n               5:'  KEY   ',25:'DESCRIPTION',/,\n               5:' NUMBER ',25:'  OF TYPE  ',/,\n               5:'--------',25:'-----------'),\n      OUTREC=(0007:0001,0001,\n              0025:0001,0001,CHANGE=(0011,\n                              C'1',C'TYPE I',\n                              C'2',C'TYPE II',\n                              C'3',C'TYPE III'),\n                      NOMATCH=(C'*UNKNOWN TYPE*'),\n              0079:X),\n      TRAILER1=(3/,'NUMBER RECORDS IN = ',COUNT)\n\n//***\n   INREC FIELDS=(11,05,PD,DIV,+50,   * DIVIDE $ BY 50\n      EDIT=(IIIIIIIIT),              * MAKE IT A 9 BYTE ZD FIELD\n      X'0000001C'                    * PD \"COUNTER\" FIELD\n   SORT FIELDS=(01,09,CH,A)          * SORT BY \"BIN\"\n   SUM FIELDS=(10,04,PD)             * SUM \"COUNTER\" FIELD\n   OUTREC FIELDS=(C' ',              * OUTPUT A SPACE,\n      01,09,ZD,MUL,+50,              * RANGE START\n      EDIT=(IIIIIIII9),              * EDIT MASK\n      C' TO ',                       * RANGE SEPARATOR\n      01,09,ZD,MUL,+50,ADD,+49,      * RANGE END\n      EDIT=(IIIIIIII9),              * EDIT MASK\n      C' COUNT:',                    * LITERAL\n      10,04,PD,                      * \"COUNTER\" FIELD\n      EDIT=(IIIIII9))                * EDIT MASK\n\n//***  DFSORT SPECIFY NUMBER OF SORTWK FILES TO BE ALLOCATED\n//DFSPARM DD *\n  OPTION  DYNALLOC=(SYSDA,##)\n\n//***  CHANGE FIELD OR LEAVE AS IT WAS\n SORT   FIELDS=COPY\n   OUTFIL  OUTREC=(001,003,CHANGE=(003,C'236',C'292'),\n      NOMATCH=(001,003),004,0252)\n\n//***  PICK OFF EVERY HUNDREDTH RECORD\n  SORT    FIELDS=COPY\n    INREC FIELDS=(00001,00080,SEQNUM,8,ZD)\n    OUTFIL INCLUDE=(00087,2,CH,EQ,C'00'),\n        OUTREC=(00001,00080)\n\n//***  REVERSE INPUT\n    INREC  FIELDS=(00001,00080,SEQNUM,8,ZD)\n  SORT   FIELDS=(0081,0008,ZD,D)\n  OUTREC FIELDS=(00001,00080)\n\n//***  PICK OFF LAST 20 RECORDS (IN REVERSE ORDER - NEED TO RESORT)\n  INREC  FIELDS=(00001,00080,SEQNUM,8,ZD)\n  SORT   FIELDS=(0081,0008,ZD,D)\n  OUTFIL FNAMES=SORTOUT,ENDREC=20,OUTREC=(1,80)\n\n//***  ADD A PSEUDO TIMESTAMP\n  SORT FIELDS=COPY\n  INREC FIELDS=(1,80,             * KEEP THE ORIGINAL RECORD\n                DATE1,TIME1,1,6)  * ADD CCYYMMDD AND HHMMSS\n  OUTREC FIELDS=(1,80,            * KEEP THE ORIGINAL RECORD\n                81,4,             * CCYY\n                C'-',             * DASH\n                85,2,             * MM\n                C'-',             * DASH\n                87,2,             * DD\n                C'-',             * DASH\n                89,2,             * HH\n                C'.',             * PERIOD\n                91,2,             * MM\n                C'.',             * PERIOD\n                93,2,             * SS\n                C'.000000')       *\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SPLITAFT": {"ttr": 35595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00F\\x00F\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 70, "newlines": 70, "modlines": 0, "user": "REXX"}, "text": "/** REXX - SPLITAFT - SPLIT COLUMNS BASED ON ONE OR MORE CHARACTERS **/\n\n   ADDRESS ISREDIT\n   \"MACRO (STRING INDENT) NOPROCESS\"\n   IF STRING = \"\" | STRING = \"?\" THEN SIGNAL DISPDOC\n   \"PROCESS RANGE C\"\n   IF RC > 0 THEN DO\n      TOP = 1\n      \"(BOT) = LINENUM .ZLAST\"\n   END\n   ELSE DO\n      \"(TOP) = LINENUM .ZFRANGE\"\n      \"(BOT) = LINENUM .ZLRANGE\"\n   END\n   IF SUBSTR(STRING,1,1) = '\"' | SUBSTR(STRING,1,1) = \"'\",\n      THEN STRING = TRANSLATE(SUBSTR(STRING,2,LENGTH(STRING)-2))\n      ELSE STRING = TRANSLATE(STRING)\n   IF INDENT = \"\" | \u00acDATATYPE(INDENT,'W') THEN INDENT = 4\n\n   DO NN = BOT TO TOP BY -1\n      \"(REC) = LINE\" NN\n      II = POS(STRING,REC)\n      IF II > 0 & SUBSTR(REC,7,1) <> \"*\",\n            & SUBSTR(REC,7,1) <> \"/\",\n            & SUBSTR(REC,7,1) <> \"D\" THEN DO\n               DO JJ = 8 TO 72 WHILE(SUBSTR(REC,JJ,1) = \" \")\n               END JJ\n               DO KK = (II+LENGTH(STRING)) TO 72,\n                  WHILE(SUBSTR(REC,KK,1) = \" \")\n               END KK\n               KK = KK - II - LENGTH(STRING)\n               SPLITREC = COPIES(\" \",JJ+INDENT-1-KK),\n                  || SUBSTR(REC,II+LENGTH(STRING))\n               \"LINE_AFTER (NN) = (SPLITREC)\"\n               REC = SUBSTR(REC,1,II+LENGTH(STRING)-1)\n               \"LINE \" NN \" = (REC)\"\n            END\n   END\n\n   \"LOCATE\" TOP\n   RETURN(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"SPLITAFT - SPLIT COLUMNS AFTER STRING                  \"\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    SPLITAFT STRING  ( INDENT )                       \"\n   SAY \"       WILL SPLIT THE SPECIFIED LINES AFTER THE STRING\"\n   SAY \"       PROVIDED. A RANGE OF LINES MAY BE SPECIFIED BY \"\n   SAY \"       C/CC/C## OR THE ENTIRE FILE WILL BE PROCESSED. \"\n   SAY \"       IF NO STRING IS SPECIFIED, THIS HELP WILL BE   \"\n   SAY \"       SHOWN. QUOTES MAY BE USED AROUND THE STRING.   \"\n   SAY \"       INDENT DEFAULTS TO 4.                          \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY \"    SPLITAFT ' TO '                            \"\n   SAY \"       ON THE FOLLOWING:                       \"\n   SAY \"          MOVE      7   TO WS-SHORT-FIELD      \"\n   SAY \"          MOVE     16   TO WS-MIDDLE-FIELD     \"\n   SAY \"          MOVE    427   TO WS-REAL-BIG-FIELD   \"\n   SAY \"       WILL RESULT IN:                         \"\n   SAY \"          MOVE      7   TO                     \"\n   SAY \"              WS-SHORT-FIELD                   \"\n   SAY \"          MOVE     16   TO                     \"\n   SAY \"              WS-MIDDLE-FIELD                  \"\n   SAY \"          MOVE    427   TO                     \"\n   SAY \"              WS-REAL-BIG-FIELD                \"\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SPLITAT": {"ttr": 35597, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x03'\\x1f\\x01\\x03'\\x1f\\x12\\x00\\x00A\\x00A\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-09-28T00:00:00", "modifydate": "2003-09-28T12:00:00", "lines": 65, "newlines": 65, "modlines": 0, "user": "REXX"}, "text": "/** REXX -- SPLITON -- SPLIT COLUMNS BASED ON ONE OR MORE CHARACTERS **/\n\n   ADDRESS ISREDIT\n   \"MACRO (STRING INDENT) NOPROCESS\"\n   IF STRING = \"\" | STRING = \"?\" THEN SIGNAL DISPDOC\n   \"PROCESS RANGE C\"\n   IF RC > 0 THEN DO\n      TOP = 1\n      \"(BOT) = LINENUM .ZLAST\"\n   END\n   ELSE DO\n      \"(TOP) = LINENUM .ZFRANGE\"\n      \"(BOT) = LINENUM .ZLRANGE\"\n   END\n   IF SUBSTR(STRING,1,1) = '\"' | SUBSTR(STRING,1,1) = \"'\",\n      THEN STRING = TRANSLATE(SUBSTR(STRING,2,LENGTH(STRING)-2))\n      ELSE STRING = TRANSLATE(STRING)\n   IF INDENT = \"\" | \u00acDATATYPE(INDENT,'W') THEN INDENT = 4\n\n   DO NN = BOT TO TOP BY -1\n      \"(REC) = LINE\" NN\n      DO JJ = 8 TO 72 WHILE(SUBSTR(REC,JJ,1) = \" \")\n      END JJ\n      II = POS(STRING,REC)\n      IF II > 0 & SUBSTR(REC,7,1) <> \"*\",\n            & SUBSTR(REC,7,1) <> \"/\",\n            & SUBSTR(REC,7,1) <> \"D\" THEN DO\n               SPLITREC = COPIES(\" \",JJ+INDENT-1) || SUBSTR(REC,II)\n               \"LINE_AFTER (NN) = (SPLITREC)\"\n               REC = SUBSTR(REC,1,II-1)\n               \"LINE \" NN \" = (REC)\"\n            END\n   END\n\n   \"LOCATE\" TOP\n   RETURN(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"SPLITON - SPLIT COLUMNS AT STRING                      \"\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    SPLITON  STRING  ( INDENT )                       \"\n   SAY \"       WILL SPLIT THE SPECIFIED LINES AT THE STRING   \"\n   SAY \"       PROVIDED. A RANGE OF LINES MAY BE SPECIFIED BY \"\n   SAY \"       C/CC/C## OR THE ENTIRE FILE WILL BE PROCESSED. \"\n   SAY \"       IF NO STRING IS SPECIFIED, THIS HELP WILL BE   \"\n   SAY \"       SHOWN. QUOTES MAY BE USED AROUND THE STRING.   \"\n   SAY \"       INDENT DEFAULTS TO 4.                          \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY \"    SPLITON  ' TO '                            \"\n   SAY \"       ON THE FOLLOWING:                       \"\n   SAY \"          MOVE      7   TO WS-SHORT-FIELD      \"\n   SAY \"          MOVE     16   TO WS-MIDDLE-FIELD     \"\n   SAY \"          MOVE    427   TO WS-REAL-BIG-FIELD   \"\n   SAY \"       WILL RESULT IN:                         \"\n   SAY \"          MOVE      7                          \"\n   SAY \"              TO WS-SHORT-FIELD                \"\n   SAY \"          MOVE     16                          \"\n   SAY \"              TO WS-MIDDLE-FIELD               \"\n   SAY \"          MOVE    427                          \"\n   SAY \"              TO WS-REAL-BIG-FIELD             \"\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SPLITON": {"ttr": 35841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00@\\x00@\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "REXX"}, "text": "/** REXX -- SPLITON -- SPLIT COLUMNS BASED ON ONE OR MORE CHARACTERS **/\n\n   ADDRESS ISREDIT\n   \"MACRO (STRING INDENT) NOPROCESS\"\n   IF STRING = \"\" | STRING = \"?\" THEN SIGNAL DISPDOC\n   \"PROCESS RANGE C\"\n   IF RC > 0 THEN DO\n      TOP = 1\n      \"(BOT) = LINENUM .ZLAST\"\n   END\n   ELSE DO\n      \"(TOP) = LINENUM .ZFRANGE\"\n      \"(BOT) = LINENUM .ZLRANGE\"\n   END\n   IF SUBSTR(STRING,1,1) = '\"' | SUBSTR(STRING,1,1) = \"'\",\n      THEN STRING = TRANSLATE(SUBSTR(STRING,2,LENGTH(STRING)-2))\n      ELSE STRING = TRANSLATE(STRING)\n   IF INDENT = \"\" | \u00acDATATYPE(INDENT,'W') THEN INDENT = 4\n\n   DO NN = BOT TO TOP BY -1\n      \"(REC) = LINE\" NN\n      DO JJ = 8 TO 72 WHILE(SUBSTR(REC,JJ,1) = \" \")\n      END JJ\n      II = POS(STRING,REC)\n      IF II > 0 & SUBSTR(REC,7,1) <> \"*\",\n            & SUBSTR(REC,7,1) <> \"/\",\n            & SUBSTR(REC,7,1) <> \"D\" THEN DO\n               SPLITREC = COPIES(\" \",JJ+INDENT-1) || SUBSTR(REC,II)\n               \"LINE_AFTER (NN) = (SPLITREC)\"\n               REC = SUBSTR(REC,1,II-1)\n               \"LINE \" NN \" = (REC)\"\n            END\n   END\n\n   \"LOCATE\" TOP\n   RETURN(0)\n\nDISPDOC:\n   SAY \"SPLITON - SPLIT COLUMNS AT STRING                      \"\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    SPLITON  STRING  ( INDENT )                       \"\n   SAY \"       WILL SPLIT THE SPECIFIED LINES AT THE STRING   \"\n   SAY \"       PROVIDED. A RANGE OF LINES MAY BE SPECIFIED BY \"\n   SAY \"       C/CC/C## OR THE ENTIRE FILE WILL BE PROCESSED. \"\n   SAY \"       IF NO STRING IS SPECIFIED, THIS HELP WILL BE   \"\n   SAY \"       SHOWN. QUOTES MAY BE USED AROUND THE STRING.   \"\n   SAY \"       INDENT DEFAULTS TO 4.                          \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY \"    SPLITON  ' TO '                            \"\n   SAY \"       ON THE FOLLOWING:                       \"\n   SAY \"          MOVE      7   TO WS-SHORT-FIELD      \"\n   SAY \"          MOVE     16   TO WS-MIDDLE-FIELD     \"\n   SAY \"          MOVE    427   TO WS-REAL-BIG-FIELD   \"\n   SAY \"       WILL RESULT IN:                         \"\n   SAY \"          MOVE      7                          \"\n   SAY \"              TO WS-SHORT-FIELD                \"\n   SAY \"          MOVE     16                          \"\n   SAY \"              TO WS-MIDDLE-FIELD               \"\n   SAY \"          MOVE    427                          \"\n   SAY \"              TO WS-REAL-BIG-FIELD             \"\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SPLTCOLS": {"ttr": 35843, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x9d\\x00\\x9d\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 157, "newlines": 157, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- SPLIT LINES AT SELECTED COLUMNS  **/\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'SPLTCOLS MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (PARMS)\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY SPLTCOLS 'EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT'\n      SIGNAL EOJ\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n\n   PARMS   = TRANSLATE(PARMS)\n   LBL1    = \"\"\n   LBL2    = \"\"\n   SCOL.   = \"\"\n   SCNT    = 0\n   DO II = 1 TO 50;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n      END\n      ELSE DO\n         IF DATATYPE(TOKEN,'W')  THEN DO\n            SCNT = SCNT + 1\n            SCOL.SCNT = TOKEN\n         END\n         ELSE DO\n            ZEDSMSG = \"BAD PARM\"\n            ZEDLMSG = \"UNRECOGNIZED PARM --\" TOKEN\n            ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n            EXIT 8\n         END\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n\n   IF SCNT = 0 THEN DO\n      MESG = \"NO COLUMNS SPECIFIED!\"\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   DO II = 1 TO SCNT\n      IF SCOL.II > LRECL THEN DO\n      MESG = \"COLUMN\" SCOL.II \"IS GREATER THAN LRECL OF FILE!\"\n         SIGNAL ERROR\n      END\n   END\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n   START = 1\n   IF LBL1 <> '' THEN \"ISREDIT (START) = LINENUM &LBL1\"\n   IF LBL2 <> '' THEN \"ISREDIT (END)   = LINENUM &LBL2\"\n\n   IF START > END THEN DO\n      TEMP  = START\n      START = END\n      END   = TEMP\n   END\n\n   TOT = 0\n   DO PNTR =  END  TO  START  BY -1\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      DO II = SCNT TO 1 BY -1\n         TOT = TOT + 1\n         NEW = SUBSTR(RECORD,SCOL.II)\n         \"ISREDIT LINE_AFTER &PNTR = (NEW)\"\n         RECORD = SUBSTR(RECORD,1,SCOL.II-1)\n      END\n      \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n   END\n\n   STR = TOT 'LINES ADDED'\n   CALL SETMSG '* NO ' STR '$CREATED NEW LINES'\n   \"ISREDIT LOCATE\" START\n   \"ISREDIT AUTONUM =\" ANUM\n    SIGNAL EOJ\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   CALL DISPDOC\n\nEOJ:\n   X = MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"SPLTCOLS - SPLIT LINES AT SPECIFIED COLUMNS               \"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    SPLTCOLS COL-1 ( COL-2 ... )  ( .A .B )               \"\n   SAY\n   SAY \"       AT LEAST ONE SPLIT COLUMN IS REQUIRED. THE LABEL   \"\n   SAY \"       RANGES ARE OPTIONAL AND MAY BE INTERMIXED.         \"\n   SAY\n   SAY \" EXAMPLES \"\n   SAY\n   SAY \"    SPLTCOLS  21  41  61                             \"\n   SAY \"       WILL SPLIT EACH LINE AT COLUMNS 21, 41 AND 61,\"\n   SAY \"       CREATING FOUR LINES FROM EACH ONE IN THE FILE.\"\n   SAY\n   SAY \"    SPLTCOLS  .A .B  41                              \"\n   SAY \"       WILL SPLIT LINES IN THE RANGE .A THRU .B AT   \"\n   SAY \"       COLUMN 41.                                    \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SQUSH": {"ttr": 35847, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00@\\x00@\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- LEFT JUSTIFIES DATA AND TURNS MULTIPLE BLANKS INTO ONE **/\n\n   ADDRESS ISREDIT\n   \"MACRO (LEFT,RIGHT) NOPROCESS\"\n\n   IF LEFT = \"?\" THEN SIGNAL DISPDOC\n   IF LEFT <> \"\" AND RIGHT = \"\" THEN DO\n      \"ISREDIT (L2,RIGHT) = BOUNDS\"\n      END\n\n   \"PROCESS RANGE C\"\n   IF RC = 0 THEN DO\n      \"(FIRST) = LINENUM .ZFRANGE\"\n      \"(LAST)  = LINENUM .ZLRANGE\"\n   END\n   ELSE DO\n      \"(FIRST) = LINENUM .ZFIRST\"\n      \"(LAST)  = LINENUM .ZLAST\"\n   END\n\n   \"ISREDIT (\"LB\",\"RB\") = BOUNDS\"\n   IF LEFT  <> \"\" THEN LB = LEFT\n   IF RIGHT <> \"\" THEN RB = RIGHT\n   \"ISREDIT (\"LRECL\")   = LRECL\"\n\n   DO II = FIRST TO LAST\n      \"(LINE) = LINE \" II\n      IF LB = 1 & RB = LRECL THEN DO\n         SELECT\n            WHEN WORDS(LINE) = 0 THEN NOP\n            OTHERWISE LINE = SPACE(LINE)\n         END  /*** END OF SELECT ***/\n      END\n      ELSE DO\n         BLOCK = SUBSTR(LINE,LB,RB-LB+1)\n         SELECT\n            WHEN WORDS(BLOCK) = 0 THEN NOP\n            OTHERWISE BLOCK = SPACE(BLOCK)\n         END  /*** END OF SELECT ***/\n         LINE = SUBSTR(LINE,1,LB-1) || BLOCK,\n            || COPIES(' ',RB-LB+1-LENGTH(BLOCK)),\n            || SUBSTR(LINE,RB+1)\n      END\n      \"LINE \"II\"= (LINE)\"\n   END II\n\n   \"LOCATE\" FIRST\n   EXIT(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"SQUSH - LEFT JUSTIFY AND REMOVE EXTRA BLANKS              \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    SQUSH  ( LEFT-COLUMN  RIGHT-COLUMN )                  \"\n   SAY\n   SAY \"       PROCESS ENTIRE FILE OR C/CC/C# DELIMITED RANGE AND \"\n   SAY \"       LEFT JUSTIFY AND SQUEEZE OUT EXTRA BLANKS. EITHER  \"\n   SAY \"       THE SPECIFIED COLUMNS OR THE CURRENT BOUNDS ARE    \"\n   SAY \"       USED TO LIMIT PROCESSING.                          \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STEMSRT1": {"ttr": 35849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00>\\x00>\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 62, "newlines": 62, "modlines": 0, "user": "REXX"}, "text": "/* REXX */\nNN    = 50000\nA.0   = NN\nXX    = RANDOM(1,99999,13579)\nDO II = 1 TO NN\n   A.II = RIGHT(RANDOM(1,99999),5,'0') || COPIES(\" \",35)\nEND II\n\n   START_CPU = TIME('R')\n   START_CPU = SYSVAR(SYSCPU)\n\nCALL QUICKSRT\n\n   ENDING_CPU = SYSVAR(SYSCPU) - START_CPU\n   SAY '** ELAPSED TIME IS' TIME('E') 'AND CPU TIME IS' ENDING_CPU\n\n   DO II = 1 TO 10\n      SAY A.II\n   END II\n   DO II = 24996 TO 25005\n      SAY A.II\n   END II\n   DO II = 49991 TO 50000\n      SAY A.II\n   END II\n\nEXIT(0)\n\nQUICKSRT:\n   N = NN\n   S = 1; STACKL.1 = 1; STACKR.1 = N\n   DO UNTIL S = 0\n      L = STACKL.S; R = STACKR.S; S = S - 1\n      DO UNTIL L >= R\n         I = L; J = R; P = (L + R) % 2\n         IF A.L > A.P THEN DO; W = A.L; A.L = A.P; A.P = W; END\n         IF A.L > A.R THEN DO; W = A.L; A.L = A.R; A.R = W; END\n         IF A.P > A.R THEN DO; W = A.P; A.P = A.R; A.R = W; END\n         X = A.P\n         DO UNTIL I > J\n            DO I = I WHILE A.I < X; END\n            DO J = J BY -1 WHILE X < A.J; END\n            IF I <= J THEN DO\n               W = A.I; A.I = A.J; A.J = W\n               I = I + 1; J = J - 1\n            END\n         END\n         IF J - L < R - I THEN DO\n            IF I < R THEN DO\n               S = S + 1; STACKL.S = I; STACKR.S = R\n            END\n            R = J\n         END\n         ELSE DO\n            IF L < J THEN DO\n               S = S + 1; STACKL.S = L; STACKR.S = J\n            END\n            L = I\n         END\n      END  /* UNTIL L >= R */\n   END     /* UNTIL S = 0  */\n   RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STEMSRT2": {"ttr": 35851, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x002\\x002\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "REXX"}, "text": "/* REXX */\nNN    = 50000\nA.0   = NN\nXX    = RANDOM(1,99999,13579)\nDO II = 1 TO NN\n   A.II = RIGHT(RANDOM(1,99999),5,'0') || COPIES(\" \",35)\nEND II\n\n   START_CPU = TIME('R')\n   START_CPU = SYSVAR(SYSCPU)\n\nCALL SHELLSRT\n\n   ENDING_CPU = SYSVAR(SYSCPU) - START_CPU\n   SAY '** ELAPSED TIME IS' TIME('E') 'AND CPU TIME IS' ENDING_CPU\n\n   DO II = 1 TO 10\n      SAY A.II\n   END II\n   DO II = 24996 TO 25005\n      SAY A.II\n   END II\n   DO II = 49991 TO 50000\n      SAY A.II\n   END II\n\nEXIT(0)\n\nSHELLSRT:\n   N = NN\n   H = 1\n   DO WHILE H <= N\n      H = ( 3 * H ) + 1\n   END\n   DO WHILE H > 0\n      DO I = ( H + 1 ) TO N\n         T = A.I\n         J = I\n         KK = J - H\n         DO WHILE ( J > H ) & ( A.KK >> T )\n            A.J = A.KK\n            J = J - H\n            KK = J - H\n         END\n         A.J = T\n      END\n      H = H % 3\n   END\n   RETURN\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STEMSRT3": {"ttr": 35853, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x003\\x003\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "REXX"}, "text": "/* REXX */\nNN    = 50000\nA.0   = NN\nXX    = RANDOM(1,99999,13579)\nDO II = 1 TO NN\n   A.II = RIGHT(RANDOM(1,99999),5,'0') || COPIES(\" \",35)\nEND II\n\n   START_CPU = TIME('R')\n   START_CPU = SYSVAR(SYSCPU)\n\nCALL SORTSRT\n\n   ENDING_CPU = SYSVAR(SYSCPU) - START_CPU\n   SAY '** ELAPSED TIME IS' TIME('E') 'AND CPU TIME IS' ENDING_CPU\n\n   DO II = 1 TO 10\n      SAY A.II\n   END II\n   DO II = 24996 TO 25005\n      SAY A.II\n   END II\n   DO II = 49991 TO 50000\n      SAY A.II\n   END II\n\nEXIT(0)\n\nSORTSRT:\n   ADDRESS TSO\n   SAVEMSG = MSG(\"OFF\")\n   \"FREE  DD(SORTIN SORTOUT SYSIN SYSPRINT) ATTR(FB40)\"\n   \"DEL '-YOUR-USERID-.STEMSRT3.DATA'\"\n   \"ATTR FB40 RECFM(F B) LRECL(40) BLKSIZE(27960)\"\n   \"ALLOC DSN('-YOUR-USERID-.STEMSRT3.DATA') DD(SORTIN) NEW SP(10 10) CYL\",\n      \"USING(FB40) UNIT(SYSDA)\"\n   \"EXECIO 0 DISKW SORTIN (OPEN\"\n   \"EXECIO * DISKW SORTIN(STEM A. FINIS\"\n   \"ALLOC DSN('-YOUR-USERID-.STEMSRT3.DATA') DD(SORTOUT) SHR USING(FB40)\"\n   \"ALLOC DD(SYSPRINT) DSN(*)\"\n   \"ALLOC DD(SYSIN) NEW TRACKS SPACE(1) UNIT(SYSDA)\",\n        \"LRECL(80) BLKSIZE(800) RECFM(F B)\"\n   QUEUE \" SORT FIELDS=(01,40,CH,A)\"\n   \"EXECIO\" QUEUED() \"DISKW SYSIN (FINIS\"\n   \"CALL *(SORT)\"\n   \"EXECIO 0 DISKR SORTIN (OPEN\"\n   \"EXECIO * DISKR SORTIN(STEM A. FINIS\"\n   \"FREE  DD(SORTIN SORTOUT SYSIN SYSPRINT) ATTR(FB40)\"\n   \"DEL '-YOUR-USERID-.STEMSRT3.DATA'\"\n   RETURN\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STOWR": {"ttr": 35855, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x86\\x00\\x86\\x00\\x00\\xe2\\xe3\\xd6\\xe6\\xd9@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 134, "newlines": 134, "modlines": 0, "user": "STOWR"}, "text": "//-YOUR-USERID-S JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  STORE DIRECTORY ENTRY FOR A SPECIFIC MEMBER\n//***\n//A          EXEC     PGM=ASMA90,REGION=4M,COND=(5,LT)\n//SYSLIB       DD       DISP=SHR,DSN=SYS1.MACLIB\n//             DD       DISP=SHR,DSN=-YOUR-SYSLIB-\nSTOWR    TITLE 'DYNAMIC STOW FOR DSN(MEMBER)'\n**********************************************************************\n*  INPUT PARAMETERS ARE:\n*    DATA SET NAME       44 BYTES - ALPHANUMERIC  POINTED TO IN R2\n*    MEMBER               8 BYTES - ALPHANUMERIC                R3\n*    DDNAME               8 BYTES - ALPHANUMERIC                R4\n*    DYNALLOC R15 R/C     2 BYTES - BINARY                      R5\n*    DYNALLOC RETURN CODE 2 BYTES - BINARY                      R6\n*    DYNALLOC REASON CODE 2 BYTES - BINARY                      R7\n*    STOW REPLACE DATA   80 BYTES - ALPHANUMERIC                R8\n**********************************************************************\n         COPY  MACSDYNA\nSTOWR    RENTER\n         LM    R2,R8,0(R1)\n\n         ST    R2,DSADDR          DSNAME ADDR FOR ALLOC MACRO\n\n         LA    R9,PDS\n         USING IHADCB,R9\n\n         CLC   0(8,R4),BLANKS     CHECK IF DDNAME PROVIDED\n         BE    DEFAULT\n         ST    R4,DDADDR          DDNAME ADDR\n         MVC   DCBDDNAM,0(R4)\n         B     POSTDEF\nDEFAULT  LA    R15,DCBDDNAM\n         ST    R15,DDADDR\n\nPOSTDEF  MVC   0(2,R5),HEX00S     DEFAULT RETURN CODES TO 0\n         MVC   0(2,R6),HEX00S\n         MVC   0(2,R7),HEX00S\n\n         ALLOC DISP=SHR,DSN=DSADDR,DDN=DDADDR\n         LTR   R15,R15            CHECK ALLOC RETURN CODE\n         BNZ   CHECKOUT\n\n         OPEN  ((9),UPDAT)\n         LTR   R15,R15            CHECK OPEN RETURN CODE\n         BNZ   OPENPROB\n\n         N     R8,HIBITOFF\n         STOW  (9),(8),R\n         LTR   R15,R15            CHECK STOW RETURN CODE\n         BNZ   STOWPROB\n\n         CLOSE ((9),DISP)\n         LTR   R15,R15            CHECK CLOSE RETURN CODE\n         BNZ   CLOSPROB\n\n         FREE  UNALC,DDN=DDADDR\n         REXIT\n\nCHECKOUT STH   R15,0(R5)          SEND BACK DYNALLOC R15 VALUE\n         DROP  R14\n         USING S99RB,R14\n         MVC   0(2,R6),S99ERROR   SEND ERROR REASON CODE BACK\n         MVC   0(2,R7),S99INFO    SEND INFO  REASON CODE BACK\n         REXIT\n\nCLOSPROB STH   R15,0(R5)          SEND BACK OPEN R15 VALUE\n         MVC   0(2,R6),HEXFES     SET DUMMY REASON CODE\n         MVC   0(2,R7),HEXFES     SET DUMMY INFO CODE\n         REXIT\n\nNOMEMBER LA    R15,32             SEND BACK NO MEMBER SUPPLIED\n         STH   R15,0(R5)\n         STH   R15,0(R6)          SEND ERROR REASON CODE BACK\n         STH   R15,0(R7)          SEND ERROR REASON CODE BACK\n         REXIT\n\nOPENPROB STH   R15,0(R5)          SEND BACK OPEN R15 VALUE\n         MVC   0(2,R6),HEXFFS     SET DUMMY REASON CODE\n         MVC   0(2,R7),HEXFFS     SET DUMMY INFO CODE\n         REXIT\n\nSTOWPROB STH   R15,0(R5)          SEND BACK STOW R15 VALUE\n         STH   R0,0(R6)           SEND ERROR REASON CODE BACK\n         MVC   0(2,R7),HEXFFS     SET DUMMY INFO CODE\n         REXIT\n\n**       ALLOC MACRO PARAMETERS\n\nDSADDR   DS    A\nDSLEN    DC    H'44'              LENGTH  OF DSNAME (44)\nDDADDR   DS    A\nDDLEN    DC    H'08'              LENGTH  OF DDNAME (08)\n\nHIBITOFF DS    0F\n         DC    X'7FFFFFFF'\nBLANKS   DC    CL62' '\nHEX00S   DC    X'0000'\nHEXFFS   DC    X'FFFF'\nHEXFES   DC    X'FFFE'\n\nPDS      DCB   DSORG=PO,MACRF=(R,W),DDNAME=$$DUMMY\n\n         LTORG\n\n         DYNSPACE\n         IEFZB4D0\n         IEFZB4D2\n\n         DCBD  DSORG=(PO),DEVD=DA\n\n         END\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//***\n//L          EXEC     PGM=IEWL,COND=(5,LT),\n//             PARM='XREF,LIST,LET,DCBS',\n//             REGION=4M\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,\n//             DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   99102500\n  ENTRY    STOWR\n  NAME     STOWR(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "STOWU": {"ttr": 36098, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00Q\\x00Q\\x00\\x00\\xe2\\xe3\\xd6\\xe6\\xe4@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 81, "newlines": 81, "modlines": 0, "user": "STOWU"}, "text": "//-YOUR-USERID-S JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  STORE DIRECTORY ENTRY UPDATE\n//***\n//A          EXEC     PGM=ASMA90,REGION=4M,COND=(5,LT)\n//SYSLIB       DD       DISP=SHR,DSN=SYS1.MACLIB\n//             DD       DISP=SHR,DSN=-YOUR-SYSLIB-\nSTOWU    TITLE 'ZAP MEMBER STATISTICS'\n**********************************************************************\n*  INPUT PARAMETERS ARE:\n*    STOW REPLACE DATA   12 BYTES - ALPHANUMERIC          R2\n*    DYNALLOC R15 R/C     2 BYTES - BINARY                R3\n*    DYNALLOC RETURN CODE 2 BYTES - BINARY                R4\n*    DYNALLOC REASON CODE 2 BYTES - BINARY                R5\n**********************************************************************\nSTOWU    RENTER\n         LM    R2,R5,0(R1) LOAD PARAMETERS\n\n         MVC   0(2,R3),HEX00S     DEFAULT RETURN CODES TO 0\n         MVC   0(2,R4),HEX00S\n         MVC   0(2,R5),HEX00S\n\n         OPEN  (PDS,UPDAT)\n         LTR   R15,R15            CHECK OPEN RETURN CODE\n         BNZ   OPENPROB\n\n         FIND  PDS,(2),C\n         STOW  PDS,(2),R\n         LTR   R15,R15            CHECK STOW RETURN CODE\n         BNZ   STOWPROB\n\n         CLOSE (PDS,DISP)\n         LTR   R15,R15            CHECK CLOSE RETURN CODE\n         BNZ   CLOSPROB\n\n         REXIT\n\nCLOSPROB STH   R15,0(R3)          SEND BACK OPEN R15 VALUE\n         MVC   0(2,R4),HEXFES     SET DUMMY REASON CODE\n         MVC   0(2,R5),HEXFES     SET DUMMY INFO CODE\n         REXIT\n\nOPENPROB STH   R15,0(R3)          SEND BACK OPEN R15 VALUE\n         MVC   0(2,R4),HEXFFS     SET DUMMY REASON CODE\n         MVC   0(2,R5),HEXFFS     SET DUMMY INFO CODE\n         REXIT\n\nSTOWPROB STH   R15,0(R3)          SEND BACK STOW R15 VALUE\n         STH   R0,0(R4)           SEND ERROR REASON CODE BACK\n         MVC   0(2,R5),HEXFFS     SET DUMMY INFO CODE\n         REXIT\n\nHEX00S   DC    X'0000'\nHEXFFS   DC    X'FFFF'\nHEXFES   DC    X'FFFE'\n\nPDS      DCB   DSORG=PO,MACRF=(R,W),DDNAME=SYSUT1\n\n         END\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//***\n//L          EXEC     PGM=IEWL,COND=(5,LT),\n//             PARM='XREF,LIST,LET,DCBS',\n//             REGION=4M\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,\n//             DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   04040900\n  ENTRY    STOWU\n  NAME     STOWU(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "STRING": {"ttr": 36101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x05\\x9e\\x05\\x9e\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 1438, "newlines": 1438, "modlines": 0, "user": "MACRO"}, "text": "*/GILBERTM JOB (ACCT#),STRING,\n*/ NOTIFY=&SYSUID,\n*/ CLASS=A,MSGCLASS=X,COND=(0,NE)\n*/ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF,\n*/*FLAG(PAGE0),NORXREF,NODXREF,                   HLASM R3\n*/ NOBATCH)\n***********************************************************************\n*                                                                     *\n* MACRO NAME = STRING                                                 *\n*                                                                     *\n* DESCRIPTIVE NAME = STRING Macro Instruction.                        *\n*                                                                     *\n* FUNCTION = Provide capabilities similar to PUT EDIT (of PL/I)       *\n*            or STRING (of COBOL) to assembler programs.              *\n*                                                                     *\n* STATUS = R510                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-flour <gsf@pobox.com>                        *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*     AMODE = ANY                                                     *\n*     SCP   = OS/360, OS/VS, MVS/370, MVS/XA, MVS/ESA, OS/390 or z/OS *\n*     KEY   = ANY                                                     *\n*     MODE  = ANY                                                     *\n*     APF   = OFF                                                     *\n*                                                                     *\n* OPERATION = SEE DOCUMENTATION AT THE END OF THIS FILE               *\n*                                                                     *\n* INVOCATION = SEE DOCUMENTATION AT THE END OF THIS FILE              *\n*                                                                     *\n* NOTES = SEE DOCUMENTATION AT THE END OF THIS FILE                   *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n*  $301  FIX BUGS WITH (XYZ,,L8) AND INTO=((R1),(R2))                 *\n*  $302  GENERATE $DEBUG BOOT-STRAP IN FINAL_CALL INVOCATION          *\n*  $303  REPLACE @STRPAD WITH @STRBLANKS                              *\n*  $304  USE @00-@15 INSTEAD OF R0-R15 FOR REGISTER EQUATES           *\n*  $306  TAILOR @STRING CSECT TO PROGRAM'S REQUIREMENTS               *\n*        LITERALS CAN BE CODED AS 'ABC' OR C'ABC' OR X'C1C2C3'        *\n*        USE L'PSATOLD AS IMPLICIT LENGTH FOR (PSATOLD-PSA,,X)        *\n*  $307  FINAL_CALL OPTION CHANGED TO GENERATE                        *\n*        ADD NOCSECT AND LOCTR OPTIONS TO GENERATE CALL               *\n*  $308  USE L'RBCDE AS IMPLICIT LENGTH FOR (PRB.RBCDE,,X)            *\n*        PREVENT S0C4 WHEN ADDR IS BAD AND LENGTH IS ZERO             *\n*  $400  REORG THE CODE TO SIMPLIFY FEATURE SELECTION                 *\n*        BLANKS NO LONGER USED OR GENERATED                           *\n*  $401  GENERATE @STRHEXT WHEN ((REG),,X) ONLY HEX FIELD             *\n*  $502  @STRING ROUTINE REWRITTEN FOR MVS/ESA:                       *\n*        -  USE LINKAGE STACK TO STORE CALLER'S REGISTERS             *\n*        -  ADD SUPPORT FOR AR MODE                                   *\n*        -  @STRING now executes in caller's AMODE                    *\n*        -  Rename previous version to STRINGXA                       *\n*  $503  DATE CONVERSION TO YYYY-MM-DD FORMAT (ISO STANDARD)          *\n*        IMPROVE SUPPORT FOR AR MODE                                  *\n*  $504  SET &STRBLANKS TO 10 WHEN PROCESSING DATES                   *\n*  $505  Allow for 128K-offset                                        *\n*  $506  Remove literal from BAL instruction for HLASM R3             *\n*  $507  Merge STRINGXA code, add AR_MODE option                      *\n*        Change syntax of GENERATE call                               *\n*  $508  Compatibility with FLAG(PAGE0) in HLASM R3                   *\n*        Compatibility with pre-XA version of the SAVE macro          *\n*        Remove AMODE-based R2 cleanup in 370 mode                    *\n*  $509  Length of parm-list entries can vary between 2 and 6 bytes   *\n*        Short Literals (one to five bytes) are generated in parm list*\n*        Hex string can contain commas, e.g. X'12,3456,7890'          *\n*  $510  JDATE=90366 produces 90/13/01 instead of S0C7                *\n***********************************************************************\n         MACRO\n&NAME    STRING &INTO=,&PRINT=NOGEN\n         GBLC  &STRING_MACRO_VERSION\n&STRING_MACRO_VERSION SETC '510'       current version\n         AIF   ('&PRINT' EQ 'NOGEN').NOGEN\n         PUSH  PRINT\n         PRINT GEN\n.NOGEN   GBLA  &$_LIT\n         GBLB  &$_FEAT(16)             FEATURES\n.*                                       1 LITERALS\n.*                                       2 REGISTER (BIN)\n.*                                       3 REGISTER (HEX)\n.*                                       4 PACKED\n.*                                       5 JDATE\n.*                                       6 BINARY\n.*                                       7 HEX\n.*                                       8 NUMERIC\n.*                                       9 LEFT JUST (NUMERIC)\n.*                                       10 LEADING ZEROES\n.*                                       11 TRUNCATE (CHAR STRING)\n.*                                       12 %TIME\n         GBLC  &$_LITS(9999)           LITERALS\n         LCLA  &I,&J,&N\n         AIF   (T'&INTO EQ 'O' AND N'&SYSLIST EQ 1                     X\n               AND '&SYSLIST(1,1)' EQ 'GENERATE').GENL\n&LABEL   SETC  'IHB&SYSNDX'            STEM FOR LOCAL LABELS\n&LQ      SETC  'L'''                   LENGTH ATTRIBUTE\n&STR     SETC  '  R&STRING_MACRO_VERSION'\n&NAME    BAS   R14,$STRING&STR         CALL @STRING SUB-ROUTINE\n         AIF   (N'&SYSLIST EQ 0).ERR1  NO POSITIONAL OPERANDS, ERROR\n         AIF   (T'&INTO EQ 'O').ERR2   NO RECEIVING FIELD, ERROR\n         AIF   (N'&INTO GT 2).ERR2     INTO=(A,32,BLURB)\n         DC    AL2((&LABEL.P-*)/2)     OFFSET TO FIELD DESCRIPTORS\n         AIF   (D'$LITERAL).LOCTR2     NOT FIRST TIME, JUMP\n$LTORG   LOCTR                         ADDRESSABLE CONSTANTS\n$FARRTNE LOCTR                         FAR ROUTINES\n.LOCTR2  ANOP\n$LITERAL LOCTR                         NON-ADDRESSABLE CONSTANTS\n&TO1     SETC  '&INTO(1)'\n&TO2     SETC  '&LQ&INTO'\n         AIF   (N'&INTO EQ 1).PUNTO8            JUMP IF INTO=XXX\n         AIF   ('&INTO(1)'(1,1) NE '(').PUNTO3  JUMP IF INTO=(XXX,44)\n&TO1     SETC  '0&INTO(1)'                              INTO=((R3),44)\n.PUNTO3  ANOP\n&TO2     SETC  '&INTO(2)'                               INTO=(XXX,LL)\n         AIF   ('&INTO(2)'(1,1) NE '(').PUNTO8  JUMP IF INTO=(XXX,44)\n&TO2     SETC  '0&INTO(2)'                              INTO=(XXX,(R1))\n.PUNTO8  ANOP\n&LABEL.P DC    S(&TO1,&TO2)\n.*--------------------------------------------------------------------*\n.*-------      FIELDS       ------------------------------------------*\n.*--------------------------------------------------------------------*\n         LCLB  &LAST,&BIN,&HEX,&REG,&PACKED,&LEFT,&ZERO,&TRUNC\n&I       SETA  1\n.*LOOP\n.LOOP1   ANOP\n         ACTR  200                            SYSDEBUG/DIAG055\n         AIF   (N'&SYSLIST(&I) GT 3).FLD990   TOO MANY SUB-OPERANDS\n&LAST    SETB  (&I EQ N'&SYSLIST)                LOOP\n         AIF   ('&SYSLIST(&I)'(1,1) EQ '''').LIT00\n         AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) EQ '''').LIT01\n.*--------------------------------------------------------------------*\n.*       PROCESS FIRST SUBPARAMETER (ADDRESS)                         *\n.*--------------------------------------------------------------------*\n&P1S     SETC  '&SYSLIST(&I,1)'\n&P2L     SETC  '0'                     INPUT LENGTH\n&P3L     SETC  '0'                     OUTPUT LENGTH\n         AIF   ('&SYSLIST(&I)'(1,1) GE '0').FLD180 SPACES\n         AIF   ('&SYSLIST(&I)' EQ '%TIME').FLD190 %TIME\n         AIF   ('&SYSLIST(&I,1)'(1,1) NE '(').FLD115 (R2)\n         AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD250\n&P1S     SETC  '0&SYSLIST(&I,1)'       CHANGE (R1) TO 0(R1)\n.FLD115  ANOP\n.*\n.*       EXTRACT RBCDE FROM PRB.RBCDE (HLASM)\n.*\n&L       SETA  1\n.*--LOOP\n.FLD131  AIF   ('&P1S'(&L,1) EQ '.').FLD133\n&L       SETA  &L+1\n         AIF   (&L LT K'&P1S).FLD131\n.*--ENDLOOP\n&P2L     SETC  '&P1S'                    ABCDEF FROM ABCDEF\n         AGO   .FLD134\n.FLD133  ANOP\n&P2L     SETC  '&P1S'(&L+1,K'&P1S-&L)    RBCDE FROM PRB.RBCDE\n.FLD134  ANOP\n.*\n         AIF   (T'&SYSLIST(&I,2) NE 'O').FLD200\n.*\n         AIF   (NOT D'&P2L).FLD140\n&P2C     SETC  T'&P2L\n.*MNOTE *,'&P1 &P2C'\n         AIF   ('&P2C' EQ 'F' OR '&P2C' EQ 'H' OR '&P2C' EQ 'P').FLD220\n         AIF   ('&P2C' EQ 'G').FLD210  FL2\n.FLD140  ANOP\n.*\n.*       EXTRACT PSATOLD FROM PSATOLD-PSA\n.*\n&L       SETA  1\n.*--LOOP\n.FLD141  AIF   ('&P2L'(&L,1) EQ '-').FLD143\n         AIF   ('&P2L'(&L,1) EQ '+').FLD143\n&L       SETA  &L+1\n         AIF   (&L LT K'&P2L).FLD141\n.*--ENDLOOP\n&P2L     SETC  '&LQ&P2L'               L'ABCDEF\n         AGO   .FLD300\n.FLD143  ANOP\n&P2L     SETC  '&LQ'.'&P2L'(1,&L-1)    L'PSATOLD FROM PSATOLD-PSA\n         AGO   .FLD300\n.*\n.FLD180  AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) NE 'X').FLD800\n&P2L     SETC  '&SYSLIST(&I)'(1,K'&SYSLIST(&I)-1) 12\n         AIF   (&LAST).FLD186\n         DC    X'60',AL1(&P2L)         BLANKS\n         AGO   .LIT90\n.FLD186  DC    X'E0',AL1(&P2L),0S(0)   BLANKS\n         AGO   .LIT90\n.*\n.FLD190  ANOP                          %TIME\n&P1S     SETC  '1(14)'                 %TIME\n&$_FEAT(12) SETB 1                     %TIME\n         AGO   .FLD800\n.*--------------------------------------------------------------------*\n.*       PROCESS SECOND SUBPARAMETER (LENGTH/TYPE)                    *\n.*--------------------------------------------------------------------*\n.FLD200  AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD300 NO LENGTH SPECIFIED\n&P2C     SETC  '&SYSLIST(&I,2)'\n         AGO   .FLD220\n.*T'&P1=G\n.FLD210  ANOP\n&L       SETA  L'&SYSLIST(&I)          T'&P1 = 'G'\n&P2C     SETC  'FL&L'                  T'&P1 = 'G'\n.*\n.FLD220  ANOP\n&P2L     SETC  '0&P2C'                 (R2) LENGTH\n         AIF   ('&P2C'(1,1) EQ '(').FLD300\n&P2L     SETC  '&P2C'                  3(R2) LENGTH\n         AIF   ('&P2C'(K'&P2C,1) EQ ')').FLD300\n&P2L     SETC  '0'\n&PACKED  SETB  ('&P2C' EQ 'P')\n         AIF   (&PACKED).FLD300\n&P2L     SETC  '1'\n         AIF   ('&P2C' EQ 'FL1').FLD240\n&P2L     SETC  '3'\n         AIF   ('&P2C' EQ 'FL2' OR '&P2C' EQ 'H').FLD240\n&P2L     SETC  '7'\n         AIF   ('&P2C' EQ 'FL3').FLD240\n&P2L     SETC  '15'\n         AIF   ('&P2C' EQ 'F').FLD240\n&P2L     SETC  '&P2C'                  IMMEDIATE LENGTH, FIELD\n         AGO   .FLD300\n.*\n.FLD240  ANOP                          BINARY VARIABLE\n&BIN     SETB  1\n         AGO   .FLD300\n.*\n.FLD250  ANOP                          REGISTER CONTENT\n&REG     SETB  1\n.*--------------------------------------------------------------------*\n.*       PROCESS THIRD SUBPARAMETER (OUTPUT FORMAT)                   *\n.*--------------------------------------------------------------------*\n.FLD300  AIF   (T'&SYSLIST(&I,3) EQ 'O').FLD800\n&HEX     SETB  ('&SYSLIST(&I,3)' EQ 'X') HEXADECIMAL\n&TRUNC   SETB  ('&SYSLIST(&I,3)' EQ 'T') TRUNCATE\n         AIF   (&HEX OR &TRUNC).FLD800\n.*\n&P3C     SETC  '&SYSLIST(&I,3)'\n&P3L     SETC  '248'\n         AIF   ('&P3C' EQ 'YYYY-MM-DD' AND &PACKED).FLD308\n&P3L     SETC  '249'\n         AIF   ('&P3C' EQ 'YYYYMMDD' AND &PACKED).FLD308\n&P3L     SETC  '250'\n         AIF   ('&P3C' EQ 'YY/MM/DD' AND &PACKED).FLD308\n&P3L     SETC  '251'\n         AIF   ('&P3C' EQ 'DD/MM/YY' AND &PACKED).FLD308\n&P3L     SETC  '252'\n         AIF   ('&P3C' EQ 'MM/DD/YY' AND &PACKED).FLD308\n&P3L     SETC  '253'\n         AIF   ('&P3C' EQ 'YYMMDD'   AND &PACKED).FLD308\n&P3L     SETC  '0'\n         AIF   (T'&SYSLIST(&I,2) NE 'N').FLD310\n         MNOTE 8,'EDIT PATTERN NOT ALLOWED WITH CHARACTER STRING'\n         AGO   .FLD310\n.FLD308  ANOP\n&$_FEAT(5) SETB 1                      JDATE\n         AGO   .FLD800\n.*--LOOP\n.FLD310  AIF   ('&P3C'(1,1) EQ 'R').FLD318       DEFAULT\n         AIF   ('&P3C'(1,1) EQ 'B').FLD318       DEFAULT\n         AIF   ('&P3C'(1,1) NE 'L').FLD311\n&LEFT    SETB  1\n         AGO   .FLD318\n.FLD311  AIF   ('&P3C'(1,1) NE 'Z').FLD312\n&ZERO    SETB  1\n         AGO   .FLD318\n.FLD312  AIF   ('&P3C'(1,1) LT '0').FLD993\n&P3L     SETC  '&P3L'.'&P3C'(1,1)\n.FLD318  ANOP\n.*MNOTE *,'&SYSLIST(&I) P3C=/&P3C/ P3L=/&P3L/'\n&P3C     SETC  '&P3C'(2,K'&P3C-1)     STRIP OFF FIRST CHARACTER\n         AIF   (K'&P3C GT 0).FLD310\n.*--ENDLOOP\n.*--------------------------------------------------------------------*\n.FLD800  ANOP\n&NUMERIC SETB  (&BIN OR &PACKED OR (&REG AND NOT &HEX))\n&TRUNC   SETB  (&TRUNC OR (&LEFT AND NOT &NUMERIC))\n&LEFT    SETB  (&LEFT AND &NUMERIC)\n         AIF   (NOT &NUMERIC).FLD810\n         AIF   (&LEFT OR '&P3L' NE '0').FLD810\n&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH ((R3))\n         AIF   (&REG).FLD810\n&P3L     SETC  '3'                     DEFAULT OUTPUT LENGTH\n         AIF   ('&P2C' EQ 'FL1').FLD810\n&P3L     SETC  '5'                     DEFAULT OUTPUT LENGTH\n         AIF   ('&P2C' EQ 'H' OR '&P2C' EQ 'FL2').FLD810\n&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH\n.FLD810  ANOP\n&FLAG    SETA  &HEX*8+&BIN*4+&PACKED*2+&REG*1\n&LEN2    SETA  &TRUNC*128+&LEFT*128+&ZERO*64+&P3L\n&$_FEAT(2) SETB (&$_FEAT(2) OR (&REG AND NOT &HEX))   REGISTER (BIN)\n&$_FEAT(3) SETB (&$_FEAT(3) OR (&REG AND &HEX))       REGISTER (HEX)\n&$_FEAT(4) SETB (&$_FEAT(4) OR &PACKED)               PACKED\n&$_FEAT(6) SETB (&$_FEAT(6) OR &BIN)                  BINARY\n&$_FEAT(7) SETB (&$_FEAT(7) OR (&HEX AND NOT &REG))   HEX\n&$_FEAT(8) SETB (&$_FEAT(8) OR &NUMERIC)              BIN,PACKED\n&$_FEAT(9) SETB (&$_FEAT(9) OR (&LEFT AND &NUMERIC))\n&$_FEAT(10) SETB (&$_FEAT(10) OR &ZERO)\n&$_FEAT(11) SETB (&$_FEAT(11) OR &TRUNC)\n&BIN     SETB  0                    RESET FLAGS\n&HEX     SETB  0                    RESET FLAGS\n&REG     SETB  0                    RESET FLAGS\n&PACKED  SETB  0                    RESET FLAGS\n&LEFT    SETB  0                    RESET FLAGS\n&ZERO    SETB  0                    RESET FLAGS\n&TRUNC   SETB  0                    RESET FLAGS\n         AIF   (&FLAG GE 10).FLD995\n         AIF   (&LAST).FLD816\n         DC    X'0&FLAG',AL1(&LEN2),SL2(&P1S,&P2L)\n         AGO   .LIT99\n.FLD816  DC    X'8&FLAG',AL1(&LEN2),SL2(&P1S,&P2L),0S(0)\n         AGO   .LIT99\n.FLD990  MNOTE 12,'OPERAND &I HAS TOO MANY SUB-OPERANDS'\n         AGO   .LIT99\n.FLD993  MNOTE 8,'THIRD SUBPARAMETER IS INVALID: ''&SYSLIST(&I,3)'''\n         AGO   .LIT99\n.FLD995  MNOTE 8,'Invalid Combination of Attributes: &SYSLIST(&I)'\n         AGO   .LIT99\n.*--------------------------------------------------------------------*\n.*------------ LITERALS ----------------------------------------------*\n.*--------------------------------------------------------------------*\n.LIT00   ANOP\n&LIT     SETC  'C&SYSLIST(&I)'\n         AGO   .LIT09\n.LIT01   ANOP\n&LIT     SETC  '&SYSLIST(&I)'\n.LIT09   ANOP                              calculate length of literal\n&J       SETA  3\n&L       SETA  0\n         AIF   ('&LIT'(1,1) EQ 'X').LIT11X\n.*LOOP\n.LIT11C  AIF   ('&LIT'(&J,1) NE '''' AND '&LIT'(&J,1) NE '&&').LIT12C\n&J       SETA  &J+1\n.LIT12C  ANOP\n&J       SETA  &J+1\n&L       SETA  &L+1\n         AIF   (&J LT K'&LIT).LIT11C\n.*ENDLOOP\n         AGO   .LIT15\n.*LOOP\n.LIT11X  AIF   ('&LIT'(&J,1) EQ ',').LIT12X\n&L       SETA  &L+1\n.LIT12X  ANOP\n&J       SETA  &J+1\n         AIF   (&J LT K'&LIT).LIT11X\n.*ENDLOOP\n&L       SETA  (&L+1)/2\n.LIT15   ANOP                               generate in-line literal\n         AIF   (&L GT 5).LIT40\n         AIF   (&LAST).LIT16\n         DC    X'4&L',&LIT\n         AGO   .LIT90\n.LIT16   DC    X'C&L',&LIT,0S(0)\n         AGO   .LIT90\n.LIT40   ANOP                                  check literal table\n         AIF   (&$_LIT EQ 0).LIT50\n&N       SETA  1\n         ACTR  &$_LIT*3+200\n.LIT41   AIF   ('&LIT' EQ '&$_LITS(&N)').LIT80       LOOP\n&N       SETA  &N+1                                  LOOP\n         AIF   (&N LE &$_LIT).LIT41                  LOOP\n.LIT50   ANOP\n&$_LIT   SETA  &$_LIT+1\n&$_LITS(&$_LIT) SETC '&LIT'\n&N       SETA  &$_LIT\n.LIT80   ANOP                               generate remote literal\n&N       SETA  &N+1000\n         AIF   (&LAST).LIT86\n         DC    X'40',AL1(&L),AL2($LIT&N-*)\n         AGO   .LIT90\n.LIT86   DC    X'C0',AL1(&L),AL2($LIT&N-*),0S(0)\n.LIT90   ANOP\n&$_FEAT(1) SETB 1                      LITERAL\n.LIT99   ANOP\n.*--------------------------------------------------------------------*\n&I       SETA  1+&I                              LOOP\n         AIF   (&I LE N'&SYSLIST).LOOP1          LOOP\n.*ENDLOOP\n&SYSLOC  LOCTR\n         AGO   .MEND\n.ERR1    MNOTE 12,'AT LEAST ONE INPUT FIELD MUST BE SPECIFIED'\n         AGO   .MEND\n.ERR2    MNOTE 12,'INVALID OUTPUT AREA SPECIFICATION'\n         AGO   .MEND\n.**********************************************************************\n.*       GENERATE: GENERATE LITERALS AND PROCESSING ROUTINE           *\n.**********************************************************************\n.GENL    ANOP\n         AIF   (N'&SYSLIST(1) GT 3).GENL1R\n&OPT2    SETC  '&SYSLIST(1,2)'\n         AIF   ('&OPT2' NE '' AND '&OPT2' NE 'AR_MODE'                 X\n               AND '&OPT2' NE 'NO_CSECT').GENL1R\n&OPT3    SETC  '&SYSLIST(1,3)'\n         AIF   ('&OPT3' NE '' AND '&OPT3' NE 'LOCTR').GENL1R\n         AIF   ('&OPT2' EQ 'NO_CSECT' AND '&OPT3' EQ 'LOCTR').GENL1R\n         AGO   .GENL1D\n.GENL1R  MNOTE 12,'Invalid GENERATE options, default used'\n&OPT2    SETC  ''\n&OPT3    SETC  ''\n.GENL1D  ANOP\n&STRBLANKS SETA 2\n         AIF   (D'$LTORG).GENL1F             CSECT-ONLY\n&$_FEAT(1) SETB 1,1,1,1,1,1,1,1,1,1,1,1\n.GENL1F  ANOP\n&ALLFEAT SETC  '&$_FEAT(1)&$_FEAT(2)&$_FEAT(3)&$_FEAT(4)'\n&ALLFEAT SETC  '&ALLFEAT&$_FEAT(5)&$_FEAT(7)&$_FEAT(6)&$_FEAT(8)'\n&ALLFEAT SETC  '&ALLFEAT&$_FEAT(9)&$_FEAT(10)&$_FEAT(11)&$_FEAT(12)'\n&STR     SETC  '&STRING_MACRO_VERSION'\n         MNOTE *,'STRING R&STR - FEATURES GENERATED: &ALLFEAT'\n         AIF   (&$_LIT EQ 0).GENL3\n$LITERAL LOCTR\n.GENL2   ANOP                                LOOP\n&N       SETA  &N+1                          LOOP\n&I       SETA  &N+1000                       LOOP\n$LIT&I   DC    &$_LITS(&N)\n         AIF   (&N LT &$_LIT).GENL2          LOOP\n.GENL3   ANOP\n         AIF   ('&OPT2' EQ 'NO_CSECT').GENL8\n&ARMODE  SETB  ('&OPT2' EQ 'AR_MODE')\n.**********************************************************************\n.*                                                                    *\n.*       STRING SUB-ROUTINE                                           *\n.*                                                                    *\n.*             CAUTION: BYTES 49-72 OF THE CALLER'S SAVE AREA         *\n.*                      (R7-R12 SLOTS) ARE USED AS WORK SPACE         *\n.*                                                                    *\n.**********************************************************************\n         AIF   ('&OPT3' EQ 'LOCTR').GENL4L\n@STRING  CSECT\n@STRING  RMODE ANY\n         AGO   .GENL4X\n.GENL4L  PUSH  USING                   GENERATE,LOCTR\n         DROP\n@STRING@ LOCTR\n@STRING  DS    0H                      ALIGNMENT\n.GENL4X  ANOP\n@00      EQU   0                       WORK REGISTER\n@01      EQU   1                       WORK REGISTER\n@02      EQU   2                       WORK REGISTER\n@03      EQU   3                       WORK REGISTER\n@04      EQU   4                       WORK REGISTER\n@05      EQU   5                       WORK REGISTER\n@06      EQU   6                       WORK REGISTER\n         AIF   (NOT &ARMODE).ARMODE1X\n@07      EQU   7                       WORK REGISTER\n@08      EQU   8                       WORK REGISTER\n@09      EQU   9                       WORK REGISTER\n@10      EQU   10                      WORK REGISTER\n@11      EQU   11                      WORK REGISTER\n@12      EQU   12                      WORK REGISTER\n.ARMODE1X ANOP\n@13      EQU   13                      CALLER'S SAVE AREA\n@14      EQU   14                      WORK REGISTER\n@15      EQU   15                      BASE REG\n         USING @STRING,@15\n         USING @STRSAVE,@13\n         B     @STR003                 BRANCH AROUND EYE-CATCHER\n         AIF   (&ARMODE).ARMODE2Y\n         DC    C'@STRING/370 R&STRING_MACRO_VERSION &ALLFEAT',0H'0'\n@STR003  STM   @14,@06,12(@13)         Save caller's registers\n         SLR   @06,@06                 R6=0\n&LAE     SETC  'LA'\n         AGO   .ARMODE2X\n.ARMODE2Y ANOP\n         DC    C'@STRING/390 R&STRING_MACRO_VERSION &ALLFEAT',0H'0'\n@STR002  DC    H'2'\n@STR003  STM   @14,@12,12(@13)         SAVE REGS (DEBUGGING ONLY)\n.*+++    BSM   @14,0                   Set AMODE when invoked via BAL\n         AH    @14,@STR002-@STRING(@15,0) POINT PAST PARM-LIST OFFSET\n         BAKR  @14,0                   SAVE REGS AND RETURN ADDRESS\n         BCTR  @14,0                   ADJUST ADDR OF PARM LIST OFFSET\n         BCTR  @14,0                   ADJUST ADDR OF PARM LIST OFFSET\n         LAE   @06,0                   R6=0 AR6=0\n         CPYA  @14,@06                 AR14=0\n         CPYA  @15,@06                 AR15=0\n&LAE     SETC  'LAE'\n.ARMODE2X ANOP\n         ICM   @06,B'0011',0(@14)      PICK UP PARM-LIST 1/2 OFFSET\n         ALR   @06,@06                 PICK UP PARM-LIST OFFSET\n         ALR   @06,@14                 R6 NOW POINTS TO PARM LIST\n         USING @STRSCON,@06\n         &LAE  @02,@STRSCON            RESOLVE FIRST SCON (ADDR)\n         BAL   @14,@STRS2A             GET ADDRESS IN R2\n         &LAE  @04,0(,@02)             KEEP ADDRESS OF \"INTO\" FIELD\n         L     @14,12(,@13)            RESTORE ADDR OF STRING MACRO\n         OI    0(@04),0                GET CLEAN S0C4 IF ADDRESS IS BAD\n         &LAE  @02,@STRFLEN            RESOLVE SECOND S-CON (LEN)\n         BAL   @14,@STRS2A             GET LENGTH IN R2\n         LR    @05,@02                 KEEP LENGTH OF \"INTO\" FIELD\n         CR    @05,@04                 END ADDRESS?\n         BL    @STR282                 NO, JUMP\n         SR    @05,@04                 CALCULATE LENGTH\n         AIF   (NOT &ARMODE).ARMODE5N\n@STR282  MSTA  @04                     SAVE R4,R5 ON LINKAGE STACK\n.*SLAC   DC    X'B247,0040'            SLAC assembler error\n         AGO   .ARMODE5X\n.ARMODE5N ANOP\n@STR282  ST    @04,8(,@13)             SAVE ADDRESS FOR LATER\n.ARMODE5X ANOP\n.**********************************************************************\n.*       MOVE FIELDS TO OUTPUT AREA                                   *\n.**********************************************************************\n         &LAE  @06,@STRNEXT            POINT TO 1ST FIELD DESC\n         USING @STRPARM,@06\n.*LOOP\n@STR310  EQU   *\n         AIF   (NOT &$_FEAT(1)).FEAT1A\n         TM    @STRFLAG,@STRLIT        IS THIS A LITERAL?\n         BO    @STR372                 YES, JUMP\n.FEAT1A  ANOP\n         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(3)).FEAT23A\n         TM    @STRFLAG,@STRREG        REGISTER?\n         BO    @STR323                 YES, JUMP\n.FEAT23A ANOP\n         AIF   (NOT &$_FEAT(12)).FEAT12A\n         CLI   @STRSCON,X'E0'          IS IT %TIME ?\n         BE    @STR378                 YES, JUMP\n.FEAT12A ANOP\n.*\n.*       IT'S A FIELD (SCON)\n.*\n         &LAE  @02,@STRFLEN            RESOLVE SECOND S-CON (LEN)\n         BAL   @14,@STRS2A             GET LENGTH IN R2\n         AIF   (&$_FEAT(9)).FEAT9E1    (LEFT JUSTIFICATION, NUMERIC)\n         LTR   @03,@02                 KEEP/TEST LENGTH\n         BZ    @STR398                 ZERO LENGTH, DO NOT EDIT\n         AGO   .FEAT9E2\n.FEAT9E1 LTR   @03,@02                 KEEP/TEST LENGTH\n         BP    @STR313                 LENGTH POSITIVE, JUMP\n         TM    @STRLEN2,@STRLEFT       LEFT JUSTIFICATION?\n         BNO   @STR398                 NO, ZERO LENGTH IS NOT OK\n@STR313  EQU   *\n.FEAT9E2 ANOP\n         &LAE  @02,@STRSCON            RESOLVE FIRST SCON (ADDR)\n         BAL   @14,@STRS2A             GET ADDRESS IN R2\n         L     @14,12(,@13)            RESTORE ADDR OF STRING MACRO\n         CLI   0(@02),0                GET CLEAN S0C4 IF ADDRESS IS BAD\n         CR    @03,@02                 END ADDRESS?\n         BL    @STR314                 NO, JUMP\n         LA    @00,X'0080'             PSA ADDRESS\n         CLR   @02,@00                 PSA REFERENCE?\n         BL    @STR314                 YES, JUMP\n         SR    @03,@02                 CALCULATE LENGTH\n@STR314  EQU   *\n         AIF   (NOT &$_FEAT(6)).FEAT6A\n         TM    @STRFLAG,@STRBIN        BINARY FIELD?\n         BO    @STR328                 YES, JUMP\n.FEAT6A  ANOP\n         AIF   (NOT &$_FEAT(4)).FEAT4A\n         TM    @STRFLAG,@STRPACK       PACKED FIELD?\n         BO    @STR351                 YES, JUMP\n.FEAT4A  ANOP\n         AIF   (NOT &$_FEAT(7)).FEAT7A\n         TM    @STRFLAG,@STRHEX        EDIT IN HEX?\n         BO    @STR376                 YES, JUMP\n.FEAT7A  ANOP\n.*\n.*       TRUNCATE CHARACTER STRING\n.*\n         AIF   (NOT &$_FEAT(11)).FEAT11A\n         CLI   @STRLEN2,@STRLEFT       CHECK JUSTIFICATION, OUTPUT LEN\n         BNE   @STR390                 NO STRING TRUNCATION, JUMP\n         &LAE  @01,0(@03,@02)          FIRST BYTE AFTER FIELD\n@STR318  BCTR  @01,0                   DOWN 1 BYTE                 LOOP\n         CLI   0(@01),C' '             IS IT A SPACE ?             LOOP\n         BNE   @STR390                 LAST NON-BLANK BYTE         LOOP\n         BCT   @03,@STR318             LOOP UNTIL 1ST NON-BLANK    LOOP\n         B     @STR398                 BLANK FIELD, DO NOT EDIT\n         AGO   .FEAT11B\n.FEAT11A ANOP\n         AIF (&$_FEAT(2)+&$_FEAT(3)+&$_FEAT(4)+&$_FEAT(6) EQ 0).FEAT11B\n         B     @STR390                 EDIT\n.FEAT11B ANOP\n.*\n.*       REGISTER (R0-R13)\n.*\n         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(3)).FEAT23B\n         AIF   (NOT &ARMODE).ARMODE7N\n@STR323  LH    @01,@STRSCON            REG NUMBER IN BITS 28-31\n         CLI   @STRSCON+1,@06          IS THIS R7-R13?\n         BH    @STR323R                YES, JUMP\n         LR    @07,@01                 SAVE R1 (R)\n         LAE   @10,0(,@04)             SAVE R4\n         LR    @11,@05                 SAVE R5\n         LAE   @12,0(,@06)             SAVE R6\n         EREG  @00,@06                 RELOAD CALLER'S R0-R6\n         EX    @07,@STR323L            COPY R0-R6 VALUE\n         LAE   @04,0(,@10)             RESTORE R4\n         LR    @05,@11                 RESTORE R5\n         LAE   @06,0(,@12)             RESTORE R6\n         B     @STR323T\n@STR323L LR    @00,*-*                 COPY VALUE FOR EDIT\n@STR323R EQU   *\n         EREG  @07,@12                 RESTORE CALLER'S R7-R12\n         EX    @01,@STR323L            COPY R7-R13 INTO R0\n         AGO   .ARMODE7X\n.ARMODE7N ANOP\n@STR323L LR    @00,*-*                 COPY VALUE FOR EDIT\n@STR323  LH    @01,@STRSCON            REG NUMBER IN BITS 28-31\n         EX    @01,@STR323L            COPY R7-R13 INTO R0\n         CLI   @STRSCON+1,@06+1        IS THIS R7-R13?\n         BNL   @STR323T                YES, JUMP\n         SLL   @01,2                   R1= 000000BB BASE * 4\n         L     @00,20(@01,@13)         PICK UP VALUE FOR R0-R6\n.ARMODE7X ANOP\n@STR323T EQU   *\n         AIF   (NOT &$_FEAT(3)).FEAT3R REG,HEX\n         AIF   (NOT &$_FEAT(2)).FEAT2H REG,BIN\n         TM    @STRFLAG,@STRHEX        EDIT IN HEX?\n         BNO   @STR330                 NO, EDIT FWD\n.FEAT2H  ANOP\n         STCM  @00,B'1111',@STRDWD-1   STORE IT FOR CVD/UNPK\n         LA    @03,8                   OUTPUT LENGTH\n         B     @STR376X                EDIT IN HEX\n.FEAT3R  ANOP\n         AIF   (NOT &$_FEAT(6)).FEAT23B\n         B     @STR330                 EDIT R0\n.FEAT23B ANOP\n.*\n.*       BINARY VARIABLE: @03 CONTAINS THE ICM MASK (1 3 7 F)\n.*\n         AIF   (NOT &$_FEAT(6)).FEAT6B\n@STR328M ICM   @00,*-*,0(@02)          **EXECUTED INSTRUCTION**\n@STR328  SLR   @00,@00\n         EX    @03,@STR328M            LOAD THE BINARY VARIABLE\n.FEAT6B  ANOP\n.*\n         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(6)).FEAT6C\n@STR330  CVD   @00,@STRDWD             CONVERT VALUE TO DECIMAL\n         AIF   (NOT &$_FEAT(4)).FEAT6C\n         B     @STR361                 EDIT DWD\n.FEAT6C  ANOP\n.*\n.*       PACKED FIELD\n.*\n         AIF   (NOT &$_FEAT(4)).FEAT4B\n@STRZAP  ZAP   @STRDWD,0(*-*,@02)      MOVE TO @STRDWD\n@STR351  &LAE  @03,0(,@02)             FIRST BYTE OF PACKED FIELD\n         BALR  @14,0\n         TM    0(@03),X'0C'            IS THIS THE SIGN BYTE?\n         LA    @03,1(,@03)              (NEXT BYTE)\n         BNOR  @14                     NO, LOOP MORE\n         SLR   @03,@02                 GET LENGTH OF PACKED FIELD\n         BCTR  @03,0\n         EX    @03,@STRZAP             EXECUTE ZAP\n         AIF   (NOT &$_FEAT(5)).FEAT4B\n         CLI   @STRLEN2,248            JULIAN-TO-YYMMDD CONV?\n         BNL   @STR375                 YES, JUMP\n.FEAT4B  ANOP                          PACKED\n.*\n.*       EDIT @STRDWD (BIN, REG, PACKED)\n.*\n         AIF   (NOT &$_FEAT(8)).FEAT8B\n@STR361  IC    @00,@STRLEN2            OUTPUT LENGTH\n         LA    @03,X'003F'             MASK FOR \"AND\"\n         NR    @03,@00                 OUTPUT LENGTH\n         MVC   @STRWK16(16),@STRMASK   EDIT MASK\n.*\n.*       LEFT-JUSTIFICATION (NUMERIC)\n.*\n         AIF   (NOT &$_FEAT(9)).FEAT9B\n         TM    @STRLEN2,@STRLEFT       LEFT JUSTIFICATION?\n         BNO   @STR367                 NO, JUMP\n         &LAE  @01,@STRWK16+15         PREVENT BAD R1\n         EDMK  @STRWK16(16),@STRDWD    ZONED DECIMAL\n         &LAE  @02,0(,@01)             FIRST STRING POSITION\n         LTR   @03,@03                 CHECK OUTPUT LENGTH\n         BNZ   @STR363                 JUMP IF NOT ZERO\n.*       L0    (LEFT JUSTIFIED, NO PADDING)\n         &LAE  @03,@STRWK16+16         FIRST POSITION AFTER STRING\n         SR    @03,@02                 COMPUTE STRING LENGTH\n         B     @STR390                 MOVE FIELD TO OUTPUT LINE\n.*       L1-L63 (LEFT JUSTIFIED, PADDING)\n@STR363  CR    @03,@05                 COMPARE LENGTH TO REMAINING LEN\n         BNH   @STR364                 LARGE ENOUGH, JUMP\n         LR    @03,@05                 TOO BIG, TRUNCATE TO REM. LEN.\n@STR364  SR    @05,@03                 COMPUTE REMAINING LENGTH\n         AIF   (NOT &ARMODE).ARMODE8N\n         LAE   @08,0(,@04)             POINTER IN OUTPUT LINE\n         LR    @09,@03                 LENGTH WITH PADDING\n         AGO   .ARMODE8X\n.ARMODE8N ANOP\n         LR    @00,@04                 POINTER IN OUTPUT LINE\n         LR    @01,@03                 LENGTH WITH PADDING\n.ARMODE8X ANOP\n         LA    @03,@STRWK16+16         FIRST POSITION AFTER STRING\n         SR    @03,@02                 COMPUTE STRING LENGTH\n         B     @STR392                 MOVE FIELD TO OUTPUT LINE\n@STR367  EQU   *\n.FEAT9B  ANOP\n         AIF   (NOT &$_FEAT(10)).FEAT10B\n         TM    @STRLEN2,@STRZERO       LEADING ZEROES REQ'D?\n         BNO   @STR368                 NO, JUMP\n         MVI   @STRWK16,C'0'           YES, CHANGE X'40' TO C'0'\n@STR368  EQU   *\n.FEAT10B ANOP\n         ED    @STRWK16(16),@STRDWD    ZONED DECIMAL\n         &LAE  @02,@STRWK16+16         FIRST POSITION AFTER STRING\n         SR    @02,@03                 FIRST STRING POSITION\n.FEAT8B  ANOP\n.*\n.*       LITERAL (@STRSCON IS A 16-BIT OFFSET)\n.*       Short Literal (low-order 4 bits of @STRFLAG contains length)\n.*       BLANKS  (@STRSCON=ZERO)\n.*\n         AIF   (NOT &$_FEAT(1)).FEAT1B\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STR372  LA    @01,7                   mask for NR\n         &LAE  @02,@STRLEN2            1st byte of short literal\n         IC    @03,@STRFLAG            pick up flags+length\n         NR    @03,@01                 R3 has length of short literal\n         BNZ   @STR390                 short literal, go move it\n         SLR   @02,@02                 Clear Address Register\n         IC    @03,@STRLEN2            GET LITERAL LENGTH\n         TM    @STRFLAG,@STRX40        string of spaces?\n         BO    @STR390                 yes, go move them\n         ICM   @02,B'0011',@STRSCON    LOAD LITERAL OFFSET\n         LA    @02,@STRSCON(@02)       CONVERT OFFSET TO FULL ADDRESS\n.FEAT1B  ANOP\n.*\n.*       CONVERT JULIAN DATE TO YYMMDD\n.*\n         AIF   (NOT &$_FEAT(5)).FEAT5F\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STR375  LA    @00,248                 MASK FOR 'SLR'\n         SLR   @01,@01\n         IC    @01,@STRLEN2            248-255\n         SLR   @01,@00                 000-007\n         LA    @00,12                  L'@STR375W\n         MR    @00,@00                 COMPUTE OFFSET\n         &LAE  @01,@STR375W(@01)       ENTRY IN \"TR\" MASK TABLE\n         SLR   @03,@03\n         IC    @03,0(,@01)             LENGTH OF DATE (6, 8 OR 10)\n         ZAP   @STRDWD,@STRDWD         DATE=0000000?               @JDT\n         BNZ   @STR375B                NO, JUMP                    @JDT\n@STR375Z &LAE  @02,@STRBLANKS          WORK AREA\n&STRBLANKS SETA 10                     WE NEED AT LEAST 10 BLANKS\n         B     @STR390                 MOVE FIELD TO OUTPUT LINE\n@STR375W DC    AL1(10,C'-',0,1,2,3,8,4,5,8,6,7) YYYY-MM-DD   248\n         DC    AL1(8,C' ',0,1,2,3,4,5,6,7,8,8)  YYYYMMDD//   249\n         DC    AL1(8,C'/',2,3,8,4,5,8,6,7,8,8)  YY/MM/DD//   250\n         DC    AL1(8,C'/',6,7,8,4,5,8,2,3,8,8)  DD/MM/YY//   251\n         DC    AL1(8,C'/',4,5,8,6,7,8,2,3,8,8)  MM/DD/YY//   252\n         DC    AL1(6,C' ',2,3,4,5,6,7,8,8,8,8)  YYMMDD       253\n.*       DC    AL1(6,C' ',6,7,4,5,2,3,8,8,8,8)  DDMMYY       254\n.*       DC    AL1(6,C' ',4,5,6,7,2,3,8,8,8,8)  MMDDYY       255\n@STR375T DC    P'59,31,29,31,30,31,30,31,31,30,31,30,31'\n         DC    P'999'                  Prevent S0C7 with 90366\n@STR375B CLI   @STRDWD+4,X'01'         YEAR 2000 OR ABOVE?\n         BH    @STR375C                CC>01, JUMP (MUST BE 19 OR 20)\n         MVI   @STRDWD+4,X'20'         CC=01, CHANGE TO CC=20\n         BE    @STR375C                CC=01, USE CC=20\n         CLI   @STRDWD+4+1,X'50'       YY<50?\n         BL    @STR375C                YES, USE CC=20\n         MVI   @STRDWD+4,X'19'         NO, FORCE CC=19\n@STR375C UNPK  @STRWK16(5),@STRDWD+4(3) CCYY?\n         ZAP   @STRDWD+1(2),@STR375T+9(1) INIT MONTH COUNTER\n         &LAE  @02,@STR375T            TABLE OF MONTHS (NUMBER OF DAYS)\n         TM    @STRDWD+4+1,X'01'       ODD YEARS\n         BO    @STR375N                  AREN'T LEAP YEARS\n         TM    @STRDWD+4+1,X'12'       ZEROES IN 1980, ALL ONES IN 1992\n         BNM   @STR375L                MIXED IN 1982/1990\n.*       IF IT'S NOT A LEAP YEAR AND DDD>59, THEN ADD 1 TO DDD\n@STR375N CP    @STRDWD+4+2(2),@STR375T ARE WE PAST FEB 28 (DDD>59) ?\n         BNH   @STR375L                NO, JUMP\n         AP    @STRDWD+4+2(2),@STR375T+3(1) ADD 1 (FROM 31) TO DDD\n.*--LOOP WHILE DDD > 0\n@STR375L AP    @STRDWD+1(2),@STR375T+3(1)   ADD 1 (FROM 31) TO MONTH\n         LA    @02,2(,@02)             NEXT ENTRY IN \"MONTHS\" TABLE\n         SP    @STRDWD+4+2(2),0(2,@02) SUB DAYS-IN-MONTH FROM DDD\n         BP    @STR375L\n.*--ENDLOOP\n         AP    @STRDWD+4+2(2),0(2,@02) UNDO LAST \"SP\" INSTRUCTION\n         UNPK  @STRWK16+4(2),@STRDWD+1(2) FYFYFYFY,FMCM??\n         UNPK  @STRWK16+6(2),@STRDWD+6(2) FYFYFYFY,FMCMFDCD\n         MVZ   @STRWK16+1(7),@STRWK16     FYFYFYFY,FMCMFDCD\n         MVC   @STRWK16+8(1),1(@01)    SEPARATOR\n         &LAE  @02,@STRWK16+9          WORK AREA\n         MVC   0(10,@02),2(@01)        MOVE CORRESPONDING MASK\n         TR    0(10,@02),@STRWK16      CONVERT DATE TO THE RIGHT FORMAT\n.FEAT5F  ANOP                          JDATE\n.*\n.*       HEX STRING\n.*\n         AIF   (NOT &$_FEAT(7)).FEAT7B\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STR376M MVC   @STRDWD-1(*-*),0(@02)   PREVENT S0C4 IN UNPK\n@STR376  LA    @00,8                   MAX LENGTH\n         CLR   @03,@00                 CHECK LENGTH\n         BNH   @STR376B                JUMP IF LE 8\n         LR    @03,@00                 TRUNCATE TO MAXIMUM LENGTH\n@STR376B LR    @01,@03                 INPUT LENGTH\n         BCTR  @01,0\n         EX    @01,@STR376M            MOVE DATA TO SAFE STORAGE\n         ALR   @03,@03                 OUTPUT LENGTH\n         AGO   .FEAT37B\n.FEAT7B  ANOP\n         AIF   (NOT &$_FEAT(3)).FEAT37C\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n.FEAT37B ANOP\n@STR376X &LAE  @02,@STRWK16            WORK AREA\n         UNPK  0(9,@02),@STRDWD-1(5)   EXPAND SOURCE BYTES FOR \"TR\"\n         UNPK  8(9,@02),@STRDWD+3(5)   EXPAND SOURCE BYTES FOR \"TR\"\n         TR    0(16,@02),@STRHEXT-240  =C'0123456789ABCDEF'\n.FEAT37C ANOP\n.*\n.*       %TIME\n.*\n         AIF   (NOT &$_FEAT(12)).FEAT12B\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STRTIME DC    X'4021207A20207A20207A20204000'    0X.XX.XX.XX\n@STR378  LR    @02,@15                 SAVE BASE REG\n         TIME  DEC                     GET HHMMSSHH\n         LR    @15,@02                 RESTORE BASE REG\n         ST    @00,@STRDWD             STORE HHMMSSHH\n         MVC   @STRWK16(13),@STRTIME   MOVE EDIT MASK\n         ED    @STRWK16(13),@STRDWD    EDIT HH:MM:SS:HH\n         &LAE  @02,@STRWK16+1          WORK AREA\n         LA    @03,12                  HH:MM:SS:HH+ SPACE\n.FEAT12B ANOP\n.*MOVE\n@STR390  CR    @03,@05                 COMPARE LENGTH TO REMAINING LEN\n         BNH   @STR391                 LARGE ENOUGH, JUMP\n         LR    @03,@05                 TOO BIG, TRUNCATE TO REM. LEN.\n@STR391  SR    @05,@03                 COMPUTE REMAINING LENGTH\n         AIF   (NOT &ARMODE).ARMODE39N\n         LAE   @08,0(,@04)             POINTER IN OUTPUT LINE\n         LR    @09,@03                 PASS REMAINING LENGTH\n         AGO   .ARMODE39X\n.ARMODE39N ANOP\n         LR    @00,@04                 POINTER IN OUTPUT LINE\n         LR    @01,@03                 PASS REMAINING LENGTH\n.ARMODE39X ANOP\n         LTR   @02,@02                 BLANKS?\n         BNZ   @STR392                 NO, JUMP\n         SLR   @03,@03                 YES, ZERO LENGTH\n@STR392  ICM   @03,B'1000',@STRBLANKS  PAD WITH BLANKS\n         AIF   (NOT &ARMODE).ARMODE44N\n         MVCL  @08,@02                 MOVE FIELD TO OUTPUT LINE\n         LR    @04,@08                 NEW POINTER IN OUTPUT LINE\n         AGO   .ARMODE44X\n.ARMODE44N ANOP\n         MVCL  @00,@02                 MOVE FIELD TO OUTPUT LINE\n         LR    @04,@00                 NEW POINTER IN OUTPUT LINE\n.ARMODE44X ANOP\n@STR398  TM    @STRFLAG,@STRLAST       TEST LAST-ENTRY INDICATOR\n         BO    @STR399                 Done, exit\n         AIF   (NOT &$_FEAT(1)).FEAT1C\n         TM    @STRFLAG,@STRLIT+@STRX40 literal or spaces?\n         BM    @STR398L                Literal, not spaces\n         BZ    @STR398X                Neither literal nor spaces\n         LA    @06,@STRSCON            2-byte entry for blank spaces\n         B     @STR310                 PROCESS NEXT ENTRY\n@STR398L LA    @01,7                   mask for NR\n         IC    @03,@STRFLAG            pick up flags+length\n         NR    @03,@01                 R3 has length of short literal\n         BZ    @STR398T                not an in-line literal, jump\n         LA    @06,@STRLEN2(@03)       Skip VL parm for in-line literal\n         B     @STR310                 PROCESS NEXT ENTRY\n@STR398T LA    @06,@STRFLEN            4-byte parm for remote literal\n         B     @STR310                 PROCESS NEXT ENTRY\n.FEAT1C  ANOP\n@STR398X LA    @06,@STRNEXT            BUMP UP TO NEXT ENTRY\n         B     @STR310                 PROCESS NEXT ENTRY\n.*ENDLOOP\n.*\n.*       END-OF-LINE PROCESSING - PAD WITH BLANKS\n.*\n@STR399  SLR   @01,@01                 SET UP R1 FOR PADDING\n         ICM   @01,B'1000',@STRBLANKS  SET UP R1 FOR PADDING\n.***     DROP  @06,@13,@15\n         AIF   (&ARMODE).ARMODE52Y\n         LA    @14,2                   INCREMENT\n         AL    @14,12(,@13)            RETURN ADDRESS\n         LR    @15,@04                 CURRENT POINTER IN OUTPUT FIELD\n         SL    @15,8(,@13)             CALCULATE LENGTH USED\n         MVCL  @04,@00                 PAD WITH BLANKS\n         LM    @00,@06,20(@13)         RESTORE WORK REGISTERS\n         STM   @06+1,@13-1,48(@13)     MAKE SAVE AREA LOOK NORMAL\n         OI    15(@13),1               SIMULATE \"T\" OPTION OF RETURN\n         BR    @14                     RETURN TO CALLER\n         AGO   .ARMODE52X\n.ARMODE52Y ANOP\n         LA    @15,3                   MODIFIABLE AREA\n         ESTA  @14,@15                 R14 = START OF OUTPUT AREA\n         LR    @15,@04                 END OF OUTPUT AREA\n         SR    @15,@14                 R15 = LENGTH USED IN OUTPUT AREA\n         MVCL  @04,@00                 PAD WITH BLANKS\n         EREG  @00,@14                 RESTORE WORK REGISTERS\n         STM   @14,@12,12(@13)         MAKE SAVE AREA LOOK NORMAL\n         OI    15(@13),1               SIMULATE \"T\" OPTION OF RETURN\n         PR                            RETURN TO CALLER\n.ARMODE52X ANOP\n.*\n         AIF   (NOT (&$_FEAT(3) OR &$_FEAT(7))).FEAT37T\n@STRHEXT DC    C'0123456789ABCDEF'     HEX-TO-EBCDIC CONVERSION\n.FEAT37T ANOP\n         AIF   (NOT &$_FEAT(8)).FEAT8T\n@STRMASK DC    X'4020202020202020,2020202020202120'\n.FEAT8T  ANOP\n.**********************************************************************\n.*       Convert S-con to address                                     *\n.*             Input: GPR2 points to an S-CON in the remote parm list *\n.*             Output: GPR2 contains the address                      *\n.**********************************************************************\n@STRS2A  SLR   @00,@00\n         ICM   @00,B'0011',0(@02)      R0 = 0000BDDD\n         SRDL  @00,12                  R0 = 0000000B, R1= DDD.....\n         SRL   @01,20                  R1 = 00000DDD (DISPLACEMENT)\n         AIF   (&ARMODE).ARMODE88Y\n         CLI   0(@02),@06*16+15        R7-R13?\n         BH    @STRS2A3                YES, JUMP\n.*BASE REG IS R0-R6\n         LTR   @02,@00                 IS R0 THE BASE REG?\n         BNZ   @STRS2A2                NO, JUMP\n         LTR   @02,@01                 IS THIS A PSA ADDRESS?\n         BNZR  @14                     YES, GOBACK\n@STRS2A2 SLL   @02,2                   R2= 000000BB BASE * 4\n         L     @02,20(@02,@13)         PICK UP BASE REG VALUE\n         LA    @02,0(@02,@01)          ADD BASE REG VALUE TO DISPL\n         BR    @14\n.*BASE REG IS R7-R13\n@STRS2A3 LR    @02,@00                 R2= 0000000B (BASE REG NUMBER)\n         EX    @02,@STRS2A4            ADD BASE REG VALUE TO DISPL\n         BR    @14\n@STRS2A4 LA    @02,0(*-*,@01)          ADD BASE REG VALUE TO DISPL\n         AGO   .ARMODE88X\n.ARMODE88Y ANOP                        AR_MODE=YES\n         SLL   @00,2                   MULT BY 4\n         CLI   0(@02),@06*16+15        R7-R13?\n         BH    @STRS2A6                YES, JUMP\n.*BASE REG IS R0-R6\n         LTR   @02,@00                 IS R0 THE BASE REG?\n         BNZ   @STRS2A5                NO, JUMP\n         LTR   @02,@01                 IS THIS A PSA ADDRESS?\n         BNZR  @14                     YES, GOBACK\n         EREG  @00,@00                 POP R0\n         LAE   @02,0                   R2=0 AR2=0\n         LR    @02,@00                 PASS R0 VALUE\n         LA    @02,0(,@02)             CLEAN UP\n         BR    @14                     GOBACK\n.*BASE REG IS R1-R6\n@STRS2A5 LR    @07,@00                 SAVE R0 (B*4)\n         LR    @08,@01                 SAVE R1 (DDD)\n         LR    @09,@03                 SAVE R3\n         LAE   @10,0(,@04)             SAVE R4\n         LR    @11,@05                 SAVE R5\n         LAE   @12,0(,@06)             SAVE R6\n         EREG  @01,@06                 RELOAD CALLER'S R1-R6\n         EX    0,@STRS2A7-4(@07)       ADD BASE REG VALUE TO DISPL\n         LR    @03,@09                 RESTORE R3\n         LAE   @04,0(,@10)             RESTORE R4\n         LR    @05,@11                 RESTORE R5\n         LAE   @06,0(,@12)             RESTORE R6\n         BR    @14                     GOBACK\n.*BASE REG IS R7-R13\n@STRS2A6 LR    @02,@00                 R2= 0000000B (BASE REG NUMBER)\n         EREG  @07,@12                 RESTORE CALLER'S R7-R12\n         EX    0,@STRS2A7-4(@02)       ADD BASE REG VALUE TO DISPL\n         BR    @14                     GOBACK\n@STRS2A7 LAE   @02,0(@08,@01)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@02)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@03)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@04)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@05)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@06)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@07)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@08)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@09)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@10)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@11)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@12)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@13)          ADD BASE REG VALUE TO DISPL\n.ARMODE88X ANOP\n         AIF   ('&OPT3' EQ 'LOCTR').GENL7L\n@STRBLANKS DC  CL((((*+&STRBLANKS+7-@STRING)/8)*8)-(*-@STRING))' '\n         AGO   .GENL7X\n.GENL7L  ANOP\n@STRBLANKS DC  CL&STRBLANKS.' '\n.GENL7X  ANOP\n@STRING_SIZE EQU *-@STRING             SIZE OF GENERATED CSECT\n         DROP  @06,@13,@15\n.**********************************************************************\n.*       WORK AREA (CALLER'S SAVE AREA)                               *\n.**********************************************************************\n@STRSAVE DSECT                         24-BYTE WORK AREA\n         DS    A(0,@STRSAVE,@STRSAVE,14,15,0,1,2,3,4,5,6)\n@STRWK16 DS    F'7,8,9,10'             WORK AREA\n@STRDWD  DS    D'1112'                 WORK AREA\n@STRPARM DSECT\n@STRFLAG DS    B                   +0  FORMAT, FLAGS\n@STRLAST EQU   X'80'                     LAST ENTRY\n@STRLIT  EQU   X'40'                     LITERAL, @STRSCON IS AN OFFSET\n@STRX40  EQU   X'20'                   String of Spaces\n.*             X'0F'                   CONVERSION REQUIRED\n.*                                     or length of short literal\n@STRHEX  EQU   X'08'                     HEXADECIMAL\n@STRBIN  EQU   X'04'                     BINARY\n@STRPACK EQU   X'02'                     PACKED\n@STRREG  EQU   X'01'                     REGISTER\n@STRLEN2 DS    B                   +1  FORMAT, OUTPUT LENGTH\n.*                                     or start of short literal\n@STRLEFT EQU   X'80'                     LEFT JUSTIFICATION\n@STRZERO EQU   X'40'                     LEADING ZEROES\n.*             X'3F'                     OUTPUT LENGTH, 0 MEANS TRUNC.\n@STRSCON DS    S                   +2  FIELD ADDRESS\n@STRFLEN DS    S                   +4  FIELD LENGTH\n@STRNEXT EQU   *                   +6\n         AIF   (NOT D'$LTORG).MEND99   CSECT-ONLY\n         AIF   (D'$STRING).MEND99      CSECT-ONLY\n$LTORG   LOCTR\n         AIF   ('&OPT3' EQ 'LOCTR').GENL9L\n         CNOP  0,4\n$STRING  BALR  @15,0                   LOCAL BASE\n         L     @15,6(@15,0)            ROUTINE ADDRESS           00\n         BR    @15                     GO TO @STRING             04\n         AGO   .GENL9\n.GENL8   ANOP                          GENERATE,NOCSECT\n&$_LIT   SETA  0                       DO NOT GENERATE LITERALS TWICE\n&$_FEAT(1) SETB 1,1,1,1,1,1,1,1,1,1,1,1   GENERATE=FULL\n$LTORG   LOCTR\n         CNOP  0,4\n$STRING  BALR  R15,0                   LOCAL BASE\n         L     R15,6(R15,0)            ROUTINE ADDRESS           00\n         BR    R15                     GO TO @STRING             04\n.GENL9   ANOP\n         DC    V(@STRING)              ROUTINE ADDRESS           06\n         AGO   .MEND\n.GENL9L  POP   USING                   GENERATE,LOCTR\n$STRING  BAS   R15,$STRING2\n         DC    Y(@STRING-*)            OFFSET TO @STRING ROUTINE\n$STRING2 AH    R15,0(R15,0)\n         BR    R15\n.MEND    AIF   ('&PRINT' EQ 'NOGEN').MEND99\n         POP   PRINT\n.MEND99  MEND\n         EJECT\n**********************************************************************\n**********************************************************************\n********* TEST PROGRAM FOR THE 'STRING' MACRO ************************\n**********************************************************************\n**********************************************************************\n**       STRING (GENERATE,AR_MODE)\n**       END\n         LCLA  &ASMH_HLASM\n         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X\n&SYSVER  SETC  'ASMH'\n&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n.ASMH1X  ANOP\nTESTPGM  START X'027000'\nTESTPGM  AMODE 24                      (PRE-SMS PUT)\n         BALR  R12,0\n         USING *,R12\n LOAD EP=SYSDEBUG\n LR R15,R0\n BASSM R14,R15\n*STRING 1X,INTO=XXX\n         OPEN  (SYSPRINT,OUTPUT)\n         STRING 'Assembler is &SYSVER, DATE is &SYSDATC',INTO=XXX\n         PUT   SYSPRINT,XXX\nRBPREFIX EQU   *\nRBINTCOD EQU   *+6,2,C'H'\nASCBASID EQU   *+8,2,C'X'\n         L     R1,PSATOLD-PSA(0,0)\n         L     R1,0(,R1)               TCBRBP\n         STRING 'SVC',(RBINTCOD-RBPREFIX(R1),H,R3Z),                   X\n               1X,(WWWW,,T),' - ',     VV.MM OF SVC RTNE               X\n               ((R8),,X),1X,           COM-REG ADDR                    X\n               (ASCBASID,,X),1X,       ASID                            X\n               PARM1,1X,               MAIN PGM NAME                   X\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n*\n         LA    R2,XXX\n         STRING 1X,INTO=((R2),8)\n         MACRO                                       JDATE MACRO\n        @JDATE &DATE                                 JDATE MACRO\n         LA    R1,=P'&DATE'                          JDATE MACRO\n*** STRING ((R1),P),2X,((R1),P),INTO=XXX\n         STRING ((R1),P),2X,((R1),P,YYMMDD),INTO=XXX,                  X\n               3X,((R1),P,YY/MM/DD),                                   X\n               3X,((R1),P,DD/MM/YY),                                   X\n               3X,((R1),P,MM/DD/YY),                                   X\n               3X,((R1),P,YYYYMMDD),                                   X\n               3X,((R1),P,YYYY-MM-DD)\n         PUT   SYSPRINT,XXX                          JDATE MACRO\n         MEND                                        JDATE MACRO\n        @JDATE 90058\n        @JDATE 91059\n        @JDATE 93060\n        @JDATE 94365\n        @JDATE 80058\n        @JDATE 84059\n        @JDATE 88060\n        @JDATE 92061\n        @JDATE 00366\n         LA    R2,1234\n         STRING 'CVTPTR=X''',(CVTPTR,4,X),'''',INTO=XXX,               X\n               ' 1234=',((R2),,R4Z)\n         PUT   SYSPRINT,XXX\n         L     R1,CVTPTR(0,0)\n         STRING 'CVTDATE=',(56(R1),P,YYMMDD),INTO=XXX\n         PUT   SYSPRINT,XXX\n         LA    R0,1000\n         LA    R3,0033\n         STRING 'D1=/',D1,'/,WWWW=/',WWWW,'/',                         X\n               ((R3),,L),'/',((R3),,X),'/',((R0),,L),'/',              X\n               ((R3),,R9B),'/',INTO=XXX\n         LR    R4,R15                   LENGTH USED\n         PUT   SYSPRINT,XXX\n         STRING WWWW,                                                  X\n               (4(R13),4,X),'''',(4(R13),F),'''',                      X\n               (4(R13),F,L),'''',                                      X\n               (4(R13),F,L11),'''',                                    X\n               (4(R13),F,Z9),'''',                                     X\n               8X,'R4=',((R4),,L),      LENGTH USED                    X\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n         STRING %TIME,D1,'B12345678B',5X,(CTR1,P),1X,PARM1,1X,PARM2,   X\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n         LA    R3,22\n         STRING INTO=XXX,'CCC1234A',(D1,(R3)),'.',(CTR1,P,R7Z)\n         PUT   SYSPRINT,XXX\n         STRING C'DDN2(',(D1,,T),')',X'40C1C2,C3C4',                   +\n               ' PSATOLD=',(PSATOLD-PSA,,X),                           +\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n         AIF   ('&SYSVER' EQ 'ASMH').HLASM99\nPSABASE  USING PSA,R0\n         STRING 'PSATOLD=',(PSABASE.PSATOLD,,X),                       +\n               ' PSATOLD=',(PSATOLD-PSA,,X),                           +\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n.HLASM99 ANOP\n         BALR  R0,0\n         STRING 'R0=',((R0),,X),'   16(R0)=',(16(R0),4,X),INTO=XXX\n         PUT   SYSPRINT,XXX\n*\nAMODE31  LA    R12,0(,R12)             BALR->BASR\n         L     R15,=A(*+X'80000006')   AMODE=31\n         BSM   0,R15                   AMODE=31\n         L     R1,=A(@STRING)          point at CSECT\n         CLC   =C'/390',11(R1)         (GENERATE,AR_MODE) ?\n         BNE   EXIT                    no, prevent S0E0\n         DSPSERV CREATE,                                               X\n               NAME==CL8'STRING00',    C'STRING00'                     X\n               BLOCKS=HDRBLKS,         SIZE IN PAGES                   X\n               STOKEN=DSPCSTKN,                                        X\n               ORIGIN=DSPCORG\n         ALESERV ADD,STOKEN=DSPCSTKN,ALET=DSPCALET\n         LAM   R8,R8,DSPCALET          POINT TO THE DATA SPACE\n         L     R8,DSPCORG              SPACE ORIGIN (0 OR 4096)\n         SAC   512                     MODE=AR\n LAM R14,R6,TESTPGM+40                 S0E0-28\n         STRING WWWW,'AR_MODE WORKED OK',INTO=(2048(R8),100)\n         LAM   R2,R2,DSPCALET          POINT TO THE DATA SPACE\n         LR    R2,R8                   SPACE ORIGIN (0 OR 4096)\n         STRING (2048+L'WWWW(R2),30,T),INTO=XXX\n         SAC   0                       MODE=AR OFF\n         PUT   SYSPRINT,XXX            AR_MODE WORKS OK\n*\nEXIT     SLR   R15,R15\n         SVC   3                       GOBACK\nD1       DC    C'D1-----D1    '\nWWWW     DC    C'WWWW'\nCTR1     DC    P'1'\nPARM1    DC    C'<-PARM1->'\nPARM2    DC    C'<-PARM2->'\nXXX      DS    CL132\nDSPCSTKN DS    XL8                  0  AS TOKEN\nDSPCALET DS    F                    8  ALET\nDSPCORG  DS    F                   12  ORIGIN\nHDRBLKS  DC    F'100'\nCVTPTR   EQU   0016,4,C'A'\nSYSPRINT DCB   DSORG=PS,DDNAME=SYSPRINT,MACRF=PM,RECFM=FB,LRECL=121\nXYZ      DSECT\n         STRING GENERATE\n**       STRING (GENERATE,NO_CSECT) -\\\n**       STRING (GENERATE,AR_MODE)  -/\n**       STRING (GENERATE,,LOCTR)\n**       STRING (GENERATE,AR_MODE,LOCTR)\n**       STRING (GENERATE,NO_CSECT,LOCTR)    invalid combination\n         YREGS\nPSA      DSECT\nPSATOLD  EQU   *+X'21C',4,C'A'\n         END\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//GO      EXEC PGM=LOADER,PARM=PRINT,TIME=(,2)\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,DELETE)\n//SYSLOUT  DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//ABNLTERM DD SYSOUT=*\n//ABNLIGNR DD DUMMY\n//SYSDEBUG DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n\n          +----------------------------------------+\n          +                                        +\n          +   Documentation for the STRING macro   +\n          +                                        +\n          +       Last update: 13 Dec 1999         +\n          +----------------------------------------+\n\n  The STRING macro is functionally similar to the COBOL DISPLAY\n  or PL/I PUT EDIT instructions.\n\n  Using STRING, you can concatenate any number of fields, edit\n  each of them if necessary, and get the result in the work area\n  you specify.\n\n  Formats:\n\n    (1) label  STRING {field_specification1}\n                      {,field_specification2}...\n                      ,INTO=workarea|(workarea,length)\n                      {,PRINT=GEN|NOGEN}\n\n    (2) label  STRING GENERATE\n                      {,PRINT=GEN|NOGEN}\n\n\n  field_specification\n\n    Each field to be printed is described as a positional\n    operand.  Each operand specifies the field address, its\n    length, and its formatting requirements.\n\n    Four field description formats are supported:\n\n      1.   symbol\n      2.   (symbol,length,format)\n      3.   (d(r)|(r),length,format)\n      4.   ((r),,format)\n      5.   'character string'\n\n  Symbol specifies the field address.  It must be an\n    S-type (relocatable) address.\n\n  d(r) may be used to specify the field address in S/370\n    base-displacement format.  If d is zero, it may be omitted.\n    If d(r) or (r) is used, length must also be specified.  R14\n    and R15 may not be used.  If d(0) is used, it is handled the\n    way the assembler does, i.e. R0 as a base register is assumed\n    to contain zero: 16(0) is equivalent to 16, CVTPTR or, X'10'.\n\n  ((r),,format) specifies that (r) contains the value\n    itself, not an address.  R14 and R15 may not be used.\n\n  'character string' specifies a literal enclosed in single quotes\n    as specified in a DC instruction.  Hex strings or character\n    strings are supported.  The following expressions are equivalent:\n    'ABC' C'ABC' X'C1C2C3'\n\n  Length specifies the length and/or the type of the input field.\n    It may be specified as an integer, a symbol, a register, or a\n    constant.  When used with symbol, it overrides the assembled\n    length and/or type.  Length is required if field is specified\n    as d(r) or (r).  If a zero length is specified, the field is\n    ignored.\n\n        nn   field length in bytes\n        H    half-word\n        F    full-word\n        FL1  1-byte binary integer\n        FL3  3-byte binary integer\n        P    packed field\n        (r)  length of character string (R0 thru R12)\n        d(r) length of character string (R1 thru R12)\n\n  Notes:  If the field address is specified as a symbol that\n          has been defined previously in the program, the symbol\n          type is known and there is no need to specify it.\n\n          If the length is specified as (r) or d(r) and the value\n          is greater than the address itself, (r) or d(r) is\n          considered to be the end address +1 instead of the length.\n\n          The length is not specified for packed fields.  The\n          @STRING subroutine scans the field left-to-right until it\n          finds a byte with a valid sign in the low-order 4 bits.\n\n          If symbol is an arithmetic expression and no length is coded,\n          the implicit length will be that of the first symbol in the\n          expression;  for example, if symbol is coded as PSATOLD-PSA,\n          then the implicit length will be L'PSATOLD.\n\n          All numeric items are assumed positive.\n\n  format  optionally indicates editing options that must\n          be applied to a field.\n\n      L        left justified\n      R        right justified\n      nn       output length\n      0        adjust length\n      Z        leading zeroes\n      B        leading/trailing blanks\n      T        truncate character string after last non-blank\n      X        display in hexadecimal\n      YYMMDD   convert julian date to YYMMDD\n      YY/MM/DD convert julian date to YY/MM/DD\n      DD/MM/YY convert julian date to DD/MM/YY\n      MM/DD/YY convert julian date to MM/DD/YY\n      YYYYMMDD convert julian date to YYYYMMDD\n      YYYY-MM-DD convert julian date to YYYY-MM-DD\n\n    The default format depends on the field type:\n\n        Type                   Default Format\n\n        character string             L\n        FL1                          R3B\n        H or FL2                     R5B\n        other numeric fields         R7B\n\n    Note: L0 and T are equivalent for character strings.\n\n  'character string' is any character string enclosed in\n  single quotes.  Blank spaces may be specified as nnX,\n  where nn is the number of X'40' bytes you want to be\n  inserted in the output line.  %TIME may be specified to\n  obtain the current time in hh.mm.ss.hh format.\n\nINTO=workarea|(workarea,length)\n\n  INTO indicates the address and length of the output work area\n  into which the result of the concatenation should be placed\n  (left justified).  If the work area is too small, truncation\n  will occur.  If it is too large, it is padded with blanks.\n\n  The address may be a symbol, d(r) (S-type address) or (r).\n\n  The length may be specified as an integer, a symbol, a register,\n  or a constant; it is required if the address is coded as d(r) or\n  (r).  If length is not specified for a symbol-type address, the\n  assembled length of the symbol is used.\n\n  Upon return from STRING, R15 contains the length actually used\n  in the output work area (before padding).\n\nPRINT=GEN|NOGEN\n\n  This operand allows you to temporarily override the PRINT\n  specification (GEN or NOGEN).\n\nGENERATE (format 2)\n\n  The GENERATE format must be specified once at the end of the\n  program.  It generates the @STRING sub-routine as well as all\n  the literals specified in previous invocations of the macro.\n\n  The GENERATE format allows the specifications of the\n  AR_MODE, NO_CSECT and LOCTR options.\n\n         STRING GENERATE<,AR_MODE<,LOCTR>>>\n                          NO_CSECT\n\n  The following combinations are valid:\n\n         STRING GENERATE\n         STRING (GENERATE,NO_CSECT)\n         STRING (GENERATE,AR_MODE)\n         STRING (GENERATE,,LOCTR)\n         STRING (GENERATE,AR_MODE,LOCTR)\n\n  The AR_MODE option can be specified to generate a\n  @STRING module that supportd AR mode.  Example:\n\n         STRING (GENERATE,AR_MODE)\n\n  The NO_CSECT option can be specified to indicate that the\n  @STRING module should not be generated; only the literals\n  are generated in this case.  Example:\n\n         STRING (GENERATE,NO_CSECT)\n\n  The @STRING CSECT contains optional functions (such as %TIME or\n  julian date conversion) that are only generated if they have\n  been specified in the previous invocations of the STRING macro.\n\n  To generate of a @STRING CSECT that supports all of the optional\n  functions, two STRING GENERATE macros must be specified:\n\n         STRING (GENERATE,NO_CSECT)        Generate Literals\n         STRING GENERATE                   Generate CSECT\n\nExamples:\n\n     STRING 'ERROR===>',LINE1,'<=== POS ',((R6),,L0),INTO=WORKAREA\n\n     STRING 8X,C'ERRORS FOUND: ',(ERRORS,,L0),INTO=((R7),44)\n\n     STRING 'CVT ADDR IS ',(CVTPTR,4,X),X'40C1C2C3C4',INTO=LINE\n\n     LA    R5,WORK+16              end addr +1\n     STRING 'R4=',((R4),,X),INTO=(WORK,(R5)),PRINT=GEN\n\n     STRING '//JOBLIB DD DSN=',(DSN1,,T),',DISP=SHR',INTO=((R2),72)\n\n     PUT31 SYSLIN\n     LH    R0,SYSLIN+82            LRECL\n     STRING '   NAME  ',(4(R3),8,T),'(R)',INTO=((R1),(R0))\n\n     STRING GENERATE         Generate literals and sub-routine\n\n\nProgramming Notes:\n\n  A STRING macro generates only 6 bytes that need to be covered by\n  base registers.  More code is generated at the end of the\n  current CSECT (using LOCTR pseudo instruction), but this code\n  does not require addressability.  This is particularly useful\n  when STRING calls specify a large number of literals.\n\n  Additionally, STRING does not use A-type constants (ACON), but\n  S-type constants (SCON) which require symbols to be addressable\n  at the point in the program where STRING is issued.\n\n  While this reduces the number of base registers required to\n  cover the program's code and makes it easier to write reentrant\n  programs, it will produce assembly errors in the following\n  situations:\n\n  a.  STRING is used in more than one CSECT in the same assembly\n\n  b.  the CSECT in which STRING is used is longer than 64K\n\n  c.  symbols are not addressable at the point in the program\n      where STRING is issued\n\n  d.  the $STRING symbol (generated in the $LTORG LOCTR during the\n      GENERATE invocation of the STRING macro) is not addressable\n      in some of the STRING calls.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STRING$": {"ttr": 36615, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00)\\x00)\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "MACRO"}, "text": "//-YOUR-USERID-T JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',                 JOB07215\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//A          EXEC     PGM=ASMA90,REGION=4M,\n//             PARM='OBJECT'\n//SYSLIB       DD       DISP=SHR,DSN=SYS1.MACLIB\n//             DD       DISP=SHR,DSN=-YOUR-SYSLIB-\n         PRINT NOGEN\nBASE     RENTER\n         OPEN  (SYSOUT,OUTPUT)\n         LA    R3,4\n         STRING 'R3=',((R3),,X),INTO=WORK\n         PUT   SYSOUT,WORK\n         IC    R3,X'04'\n         STRING 'R3=',((R3),,X),INTO=WORK\n         PUT   SYSOUT,WORK\n         IC    R3,=X'04'\n         STRING 'R3=',((R3),,X),INTO=WORK\n         PUT   SYSOUT,WORK\n         CLOSE (SYSOUT,)\n         REXIT\nWORK     DC    CL80' '\n         LTORG\nSYSOUT DCB DSORG=PS,MACRF=PM,DDNAME=SYSOUT,RECFM=F,LRECL=80,BLKSIZE=80\n         STRING GENERATE\n         END   BASE\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n//***\n//GO         EXEC     PGM=LOADER,\n//             REGION=4M,COND=(5,LT)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//SYSLOUT      DD       SYSOUT=*\n//SYSPRINT     DD       SYSOUT=*\n//SYSOUT       DD       SYSOUT=*\n//SYSUDUMP     DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "STRING#": {"ttr": 36617, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xe7\\x00\\xe7\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 231, "newlines": 231, "modlines": 0, "user": "MACRO"}, "text": "\n  The STRING macro is functionally similar to the COBOL DISPLAY\n  or PL/I PUT EDIT instructions.\n\n  Using STRING, you can concatenate any number of fields, edit\n  each of them if necessary, and get the result in the work area\n  you specify.\n\n  Formats:\n\n    (1) label  STRING {field_specification1}\n                      {,field_specification2}...\n                      ,INTO=workarea|(workarea,length)\n                      {,PRINT=GEN|NOGEN}\n\n    (2) label  STRING GENERATE\n                      {,PRINT=GEN|NOGEN}\n\n\n  field_specification\n\n    Each field to be printed is described as a positional\n    operand.  Each operand specifies the field address, its\n    length, and its formatting requirements.\n\n    Four field description formats are supported:\n\n      1.   symbol\n      2.   (symbol,length,format)\n      3.   (d(r)|(r),length,format)\n      4.   ((r),,format)\n      5.   'character string'\n\n  Symbol specifies the field address.  It must be an\n    S-type (relocatable) address.\n\n  d(r) may be used to specify the field address in S/370\n    base-displacement format.  If d is zero, it may be omitted.\n    If d(r) or (r) is used, length must also be specified.  R14\n    and R15 may not be used.  If d(0) is used, it is handled the\n    way the assembler does, i.e. R0 as a base register is assumed\n    to contain zero: 16(0) is equivalent to 16, CVTPTR or, X'10'.\n\n  ((r),,format) specifies that (r) contains the value\n    itself, not an address.  R14 and R15 may not be used.\n\n  'character string' specifies a literal enclosed in single quotes\n    as specified in a DC instruction.  Hex strings or character\n    strings are supported.  The following expressions are equivalent:\n    'ABC' C'ABC' X'C1C2C3'\n\n  Length specifies the length and/or the type of the input field.\n    It may be specified as an integer, a symbol, a register, or a\n    constant.  When used with symbol, it overrides the assembled\n    length and/or type.  Length is required if field is specified\n    as d(r) or (r).  If a zero length is specified, the field is\n    ignored.\n\n        nn   field length in bytes\n        H    half-word\n        F    full-word\n        FL1  1-byte binary integer\n        FL3  3-byte binary integer\n        P    packed field\n        (r)  length of character string (R0 thru R12)\n        d(r) length of character string (R1 thru R12)\n\n  Notes:  If the field address is specified as a symbol that\n          has been defined previously in the program, the symbol\n          type is known and there is no need to specify it.\n\n          If the length is specified as (r) or d(r) and the value\n          is greater than the address itself, (r) or d(r) is\n          considered to be the end address +1 instead of the length.\n\n          The length is not specified for packed fields.  The\n          @STRING subroutine scans the field left-to-right until it\n          finds a byte with a valid sign in the low-order 4 bits.\n\n          If symbol is an arithmetic expression and no length is coded,\n          the implicit length will be that of the first symbol in the\n          expression;  for example, if symbol is coded as PSATOLD-PSA,\n          then the implicit length will be L'PSATOLD.\n\n          All numeric items are assumed positive.\n\n  format  optionally indicates editing options that must\n          be applied to a field.\n\n      L        left justified\n      R        right justified\n      nn       output length\n      0        adjust length\n      Z        leading zeroes\n      B        leading/trailing blanks\n      T        truncate character string after last non-blank\n      X        display in hexadecimal\n      YYMMDD   convert julian date to YYMMDD\n      YY/MM/DD convert julian date to YY/MM/DD\n      DD/MM/YY convert julian date to DD/MM/YY\n      MM/DD/YY convert julian date to MM/DD/YY\n      YYYYMMDD convert julian date to YYYYMMDD\n      YYYY-MM-DD convert julian date to YYYY-MM-DD\n\n    The default format depends on the field type:\n\n        Type                   Default Format\n\n        character string             L\n        FL1                          R3B\n        H or FL2                     R5B\n        other numeric fields         R7B\n\n    Note: L0 and T are equivalent for character strings.\n\n  'character string' is any character string enclosed in\n  single quotes.  Blank spaces may be specified as nnX,\n  where nn is the number of X'40' bytes you want to be\n  inserted in the output line.  %TIME may be specified to\n  obtain the current time in hh.mm.ss.hh format.\n\nINTO=workarea|(workarea,length)\n\n  INTO indicates the address and length of the output work area\n  into which the result of the concatenation should be placed\n  (left justified).  If the work area is too small, truncation\n  will occur.  If it is too large, it is padded with blanks.\n\n  The address may be a symbol, d(r) (S-type address) or (r).\n\n  The length may be specified as an integer, a symbol, a register,\n  or a constant; it is required if the address is coded as d(r) or\n  (r).  If length is not specified for a symbol-type address, the\n  assembled length of the symbol is used.\n\n  Upon return from STRING, R15 contains the length actually used\n  in the output work area (before padding).\n\nPRINT=GEN|NOGEN\n\n  This operand allows you to temporarily override the PRINT\n  specification (GEN or NOGEN).\n\nGENERATE (format 2)\n\n  The GENERATE format must be specified once at the end of the\n  program.  It generates the @STRING sub-routine as well as all\n  the literals specified in previous invocations of the macro.\n\n  The GENERATE format allows the specifications of the\n  AR_MODE, NO_CSECT and LOCTR options.\n\n         STRING GENERATE<,AR_MODE<,LOCTR>>>\n                          NO_CSECT\n\n  The following combinations are valid:\n\n         STRING GENERATE\n         STRING (GENERATE,NO_CSECT)\n         STRING (GENERATE,AR_MODE)\n         STRING (GENERATE,,LOCTR)\n         STRING (GENERATE,AR_MODE,LOCTR)\n\n  The AR_MODE option can be specified to generate a\n  @STRING module that supported AR mode.  Example:\n\n         STRING (GENERATE,AR_MODE)\n\n  The NO_CSECT option can be specified to indicate that the\n  @STRING module should not be generated; only the literals\n  are generated in this case.  Example:\n\n         STRING (GENERATE,NO_CSECT)\n\n  The @STRING CSECT contains optional functions (such as %TIME or\n  julian date conversion) that are only generated if they have\n  been specified in the previous invocations of the STRING macro.\n\n  To generate of a @STRING CSECT that supports all of the optional\n  functions, two STRING GENERATE macros must be specified:\n\n         STRING (GENERATE,NO_CSECT)        Generate Literals\n         STRING GENERATE                   Generate CSECT\n\nExamples:\n\n     STRING 'ERROR===>',LINE1,'<=== POS ',((R6),,L0),INTO=WORKAREA\n\n     STRING 8X,C'ERRORS FOUND: ',(ERRORS,,L0),INTO=((R7),44)\n\n     STRING 'CVT ADDR IS ',(CVTPTR,4,X),X'40C1C2C3C4',INTO=LINE\n\n     LA    R5,WORK+16              end addr +1\n     STRING 'R4=',((R4),,X),INTO=(WORK,(R5)),PRINT=GEN\n\n     STRING '//JOBLIB DD DSN=',(DSN1,,T),',DISP=SHR',INTO=((R2),72)\n\n     PUT31 SYSLIN\n     LH    R0,SYSLIN+82            LRECL\n     STRING '   NAME  ',(4(R3),8,T),'(R)',INTO=((R1),(R0))\n\n     STRING GENERATE         Generate literals and sub-routine\n\n\nProgramming Notes:\n\n  A STRING macro generates only 6 bytes that need to be covered by\n  base registers.  More code is generated at the end of the\n  current CSECT (using LOCTR pseudo instruction), but this code\n  does not require addressability.  This is particularly useful\n  when STRING calls specify a large number of literals.\n\n  Additionally, STRING does not use A-type constants (ACON), but\n  S-type constants (SCON) which require symbols to be addressable\n  at the point in the program where STRING is issued.\n\n  While this reduces the number of base registers required to\n  cover the program's code and makes it easier to write reentrant\n  programs, it will produce assembly errors in the following\n  situations:\n\n  a.  STRING is used in more than one CSECT in the same assembly\n\n  b.  the CSECT in which STRING is used is longer than 64K\n\n  c.  symbols are not addressable at the point in the program\n      where STRING is issued\n\n  d.  the $STRING symbol (generated in the $LTORG LOCTR during the\n      GENERATE invocation of the STRING macro) is not addressable\n      in some of the STRING calls.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STRSRCH": {"ttr": 36865, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00o\\x00o\\x00\\x00\\xc5\\xe9\\xd4\\xc1\\xc3\\xd9\\xd6@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 111, "newlines": 111, "modlines": 0, "user": "EZMACRO"}, "text": "MACRO 5 PATTERN PATLEN TARGET TRGLEN POSN MAXPAT 64 MAXTRG 4096\n************************************************************************\n*                                                                      *\n*  MACRO NAME: STRSTCH - Fast string search using the Boyer-Moore      *\n*                        algorithm                                     *\n*                                                                      *\n*  AUTHOR: Russ Jones                                                  *\n*          HCA Wesley Medical Center                                   *\n*          550 N Hillside                                              *\n*          Wichita KS 67212                                            *\n*                                                                      *\n*  DATE WRITTEN: 06/15/87                                              *\n*                                                                      *\n*  REFERENCE: Robert S. Boyer and J. Strother Moore                    *\n*             \"A Fast String Searching Algorithm\"                      *\n*             Communications of the ACM, vol. 20, No. 10               *\n*             (Oct 1977):762-772                                       *\n*                                                                      *\n*             Richard Wiggins and Paul Wolberg                         *\n*             \"Searching for Strings with Boyer-Moore\"                 *\n*             Computer Language, vol. 3, No. 11                        *\n*             (Nov 1986):28-42                                         *\n*                                                                      *\n************************************************************************\nDEFINE SS_TARGET_         W     &MAXTRG A\n  DEFINE SS_TRG_CHAR_      SS_TARGET_ 1 A OCCURS &MAXTRG\nDEFINE SS_TRGLEN_         W           4 P\nDEFINE SS_PATTERN_        W     &MAXPAT A\nDEFINE   SS_PAT_CHAR_     SS_PATTERN_ 1 A OCCURS &MAXPAT\nDEFINE SS_PATLEN_         W           4 P\nDEFINE SS_DELTA_          W           4 P OCCURS 256\nDEFINE SS_SUB_            W           2 B VALUE 0\nDEFINE   SS_SUB_C_        SS_SUB_  +1 1 A\nDEFINE SS_I_              W           4 P\nDEFINE SS_OLDI_           W           4 P\nDEFINE SS_J_              W           4 P\nDEFINE SS_DL_             W           4 P\nDEFINE SS_IDL_            W           4 P\nDEFINE SS_LARGE_          W           4 P VALUE 1000000\nDEFINE SS_PREV_PAT_       W     &MAXPAT A\n*\nSS_TARGET_ = &TARGET\nSS_TRGLEN_ = &TRGLEN\nSS_PATTERN_ = &PATTERN\nSS_PATLEN_ = &PATLEN\nIF SS_PATTERN_ NE SS_PREV_PAT_\n  SS_PREV_PAT_ = SS_PATTERN_\n  SS_I_ = 1\n  DO WHILE SS_I_ LE 256\n    SS_DELTA_ (SS_I_) = SS_PATLEN_\n    SS_I_ = SS_I_ + 1\n  END-DO\n  SS_I_ = 1\n  DO WHILE SS_I_ LE SS_PATLEN_\n    SS_SUB_ = 0\n    SS_SUB_C_ = SS_PAT_CHAR_ (SS_I_)\n    SS_SUB_ = SS_SUB_ + 1\n    IF SS_I_ LT SS_PATLEN_\n      SS_DELTA_ (SS_SUB_) = SS_PATLEN_ - SS_I_\n    ELSE\n      SS_DELTA_ (SS_SUB_) = SS_LARGE_\n    END-IF\n    SS_I_ = SS_I_ + 1\n  END-DO\nEND-IF\nIF SS_PATLEN_ GT SS_TRGLEN_\n  &POSN = 0\n  GO TO SS_EXIT_\nEND-IF\nSS_I_ = SS_PATLEN_\nSS_FAST_\nSS_SUB_ = 0\nSS_SUB_C_ = SS_TRG_CHAR_ (SS_I_)\nSS_SUB_ = SS_SUB_ + 1\nSS_I_ = SS_I_ + SS_DELTA_ (SS_SUB_)\nIF SS_I_ LE SS_TRGLEN_\n  GO TO SS_FAST_\nEND-IF\nIF SS_I_ LE SS_LARGE_\n  &POSN = 0\n  GO TO SS_EXIT_\nEND-IF\nSS_I_ = SS_I_ - SS_LARGE_ - 1\nSS_OLDI_ = SS_I_ + 1\nSS_J_ = SS_PATLEN_ - 1\nSS_SLOW_\nIF SS_J_ = 0\n  &POSN = SS_I_ + 1\n  GO TO SS_EXIT_\nEND-IF\nIF SS_TRG_CHAR_ (SS_I_) = SS_PAT_CHAR_ (SS_J_)\n  SS_I_ = SS_I_ - 1\n  SS_J_ = SS_J_ - 1\n  GO TO SS_SLOW_\nEND-IF\nSS_SUB_ = 0\nSS_SUB_C_ = SS_TRG_CHAR_ (SS_I_)\nSS_SUB_ = SS_SUB_ + 1\nSS_DL_ = SS_DELTA_ (SS_SUB_)\nSS_IDL_ = SS_I_ + SS_DL_\nIF (SS_DL_ NE SS_LARGE_) AND (SS_IDL_ GT SS_OLDI_)\n  SS_I_ = SS_I_ + SS_DL_\nELSE\n  SS_I_ = SS_OLDI_ + 2\nEND-IF\nIF SS_I_ LE SS_TRGLEN_\n  GO TO SS_FAST_\nELSE\n  &POSN = 0\nEND-IF\nSS_EXIT_\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STRSRCH#": {"ttr": 36868, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00Q\\x00Q\\x00\\x00\\xc5\\xe9\\xd4\\xc1\\xc3\\xd9\\xd6@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 81, "newlines": 81, "modlines": 0, "user": "EZMACRO"}, "text": " STRSRCH Macro\n\n    The STRSRCH macro provides a rapid string search that returns the\n    position of the search pattern within the target string, or returns\n    a zero if the search pattern does not occur in the target string.\n\n Syntax\n        +-------------------------------------------------------------------+\n        |                                                                   |\n        |  %STRSRCH pattern pattern-length target target-length position +  |\n        |          {MAXPAT integer} {MAXTRG integer}                        |\n        |                                                                   |\n        +-------------------------------------------------------------------+\n\n pattern         This alpha field or literal is the value for which to search.\n\n pattern-length  This numeric field or literal is the length of the pattern for\n                 which to search.  It does not necessarily have to specify the\n                 entire defined length of the pattern field.  It may be less\n                 than that length, and only the specified number of characters\n                 will be considered.\n\n target          This alpha field or literal is the target string that is to be\n                 searched.\n\n target-length   This numeric field or literal is the length of the target\n                 string.  As with the pattern-length, it does not necessarily\n                 have to specify the entire defined length of the target field.\n                 If it is less than that length, only the specified number of\n                 characters will be considered.\n\n position        This numeric field is where the result of the search is\n                 returned.  A zero indicates that the pattern was not found in\n                 the target string.  Any other value indicates the position in\n                 the target string where the first character of the pattern\n                 occurs.\n\n MAXPAT integer  This keyword parameter specifies the maximum possible size in\n (Optional)      characters of the search pattern.  Its default is 64.\n\n MAXTRG integer  This keyword parameter specifies the maximum possible size in\n (Optional)      characters of the target string.  Its default is 4096.\n\n                 MAXPAT and MAXTRG are used to define storage and need not be\n                 changed unless the maximum possible field sizes are greater\n                 than the defaults.\n\n\n Operation -     STRSRCH generates no output and can be used alone or in\n INLINE          conjunction with other routines and/or EASYTRIEVE PLUS logic.\n\n Operation -     No changes in the specification of parameters are required to\n Data Base       use STRSRCH with data base files.  For files with variable\n                 length records, the EASYTRIEVE PLUS defined field RECORD-LENGTH\n                 may be used for the \"target-length\" parameter, unless  you do\n                 not wish to search the entire input record.\n\n1Reference       This macro uses an algorithm developed by Robert S. Boyer and\n                 J. Strother Moore and discussed in their article \"A Fast String\n                 Searching Algorithm\" in Communications of the ACM, Volume 20,\n+                                        _________________________\n                 Number 10 (October, 1977), pages 762-772.  The Boyer-Moore\n                 algorithm is further discussed by Richard Wiggins and Paul\n                 Wolberg in \"Searching for Strings with Boyer-Moore,\" Computer\n+                                                                     ________\n                 Language, Volume 3, Number 11 (November, 1986), Pages 28-42.\n+                ________\n\n Copyright       The STRSRCH macro and all documentation were written and are\n Information     copyright (c) 1987 by:\n\n                      J. Russell Jones\n                      HCA/Wesley Medical Center\n                      550 N. Hillside\n                      Wichita, KS  67212\n\n                 and are hereby placed in the public domain and may be used and\n                 distributed freely as desired provided that full credit be\n                 given to both the author and HCA/Wesley Medical Center in any\n                 documenation accompanying such use.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STRUCT": {"ttr": 36871, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x03'\\x1f\\x01\\x03'\\x1f\\x12\\x00\\x00\\xab\\x00\\xab\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-09-28T00:00:00", "modifydate": "2003-09-28T12:00:00", "lines": 171, "newlines": 171, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- show the structure of program code. The parm input   **/\n/*           is the language, e.g. COB, EZ, PL/I or REXX; it will  */\n/*           accept a label range to limit processing; Note '//'   */\n/*           denoting JCL and any Easytrieve or COBOL comments are */\n/*           always left excluded                                  */\n/* --------------------------------------------------------------- */\nAddress isredit\n'MACRO (PARM fmlabel tolabel)'\nparm = Translate(parm)\n\nIf parm = 'PLI' | parm = 'PL/I' | parm = 'PL1' | parm = 'PL/1' then\n  Do\n    'EXCLUDE ALL'\n    'F '' | ''          ALL'  fmlabel  tolabel\n    'F '' & ''          ALL'  fmlabel  tolabel\n    'F '' BEGIN ''      ALL'  fmlabel  tolabel\n    'F '' BEGIN;''      ALL'  fmlabel  tolabel\n    'F '' DO ''         ALL'  fmlabel  tolabel\n    'F '' DO;''         ALL'  fmlabel  tolabel\n    'F '' ELSE ''       ALL'  fmlabel  tolabel\n    'F '' ELSE;''       ALL'  fmlabel  tolabel\n    'F '' END ''        ALL'  fmlabel  tolabel\n    'F '' END;''        ALL'  fmlabel  tolabel\n    'F '' IF ''         ALL'  fmlabel  tolabel\n    'F '' OTHERWISE ''  ALL'  fmlabel  tolabel\n    'F '' OTHERWISE;''  ALL'  fmlabel  tolabel\n    'F '' PROC ''       ALL'  fmlabel  tolabel\n    'F '' PROC(''       ALL'  fmlabel  tolabel\n    'F '' PROC;''       ALL'  fmlabel  tolabel\n    'F '' SELECT ''     ALL'  fmlabel  tolabel\n    'F '' THEN ''       ALL'  fmlabel  tolabel\n    'F '' THEN;''       ALL'  fmlabel  tolabel\n    'F '' UNTIL''       ALL'  fmlabel  tolabel\n    'F '' WHEN ''       ALL'  fmlabel  tolabel\n    'F '' WHILE''       ALL'  fmlabel  tolabel\n    'EXCLUDE ALL ''//'' 1'\n    'RESET FIND'\n    'LOCATE 0'\n    'CURSOR = 1 1'\n  End                            /* End of PLI processing         */\n\nElse if parm = 'REX' | parm = 'REXX' then\n  Do\n    'EXCLUDE ALL'\n    'F '' | ''          ALL'  fmlabel  tolabel\n    'F '' & ''          ALL'  fmlabel  tolabel\n    'F '' BEGIN ''      ALL'  fmlabel  tolabel\n    'F '' BEGIN;''      ALL'  fmlabel  tolabel\n    'F '' DO ''         ALL'  fmlabel  tolabel\n    'F '' DO;''         ALL'  fmlabel  tolabel\n    'F '' ELSE ''       ALL'  fmlabel  tolabel\n    'F '' ELSE;''       ALL'  fmlabel  tolabel\n    'F '' END ''        ALL'  fmlabel  tolabel\n    'F '' END;''        ALL'  fmlabel  tolabel\n    'F '' IF ''         ALL'  fmlabel  tolabel\n    'F '' OTHERWISE ''  ALL'  fmlabel  tolabel\n    'F '' OTHERWISE;''  ALL'  fmlabel  tolabel\n    'F '' PROC ''       ALL'  fmlabel  tolabel\n    'F '' PROC(''       ALL'  fmlabel  tolabel\n    'F '' PROC;''       ALL'  fmlabel  tolabel\n    'F '' SELECT ''     ALL'  fmlabel  tolabel\n    'F '' SIGNAL ''     ALL'  fmlabel  tolabel\n    'F '' THEN ''       ALL'  fmlabel  tolabel\n    'F '' THEN;''       ALL'  fmlabel  tolabel\n    'F '' UNTIL''       ALL'  fmlabel  tolabel\n    'F '' WHEN ''       ALL'  fmlabel  tolabel\n    'F '' WHILE''       ALL'  fmlabel  tolabel\n    'EXCLUDE ALL ''//'' 1'\n    'RESET FIND'\n    'LOCATE 0'\n    'CURSOR = 1 1'\n  End                            /* End of REXX processing        */\n\nElse if parm = 'COB' | parm = 'COBOL' Then\n  Do\n    'EXCLUDE ALL'\n    'F '' AND ''         ALL'  fmlabel  tolabel\n    'F '' ELSE ''        ALL'  fmlabel  tolabel\n    'F '' END-EVALUATE'' ALL'  fmlabel  tolabel\n    'F '' END-IF''       ALL'  fmlabel  tolabel\n    'F '' END-PERFORM''  ALL'  fmlabel  tolabel\n    'F '' EVALUATE ''    ALL'  fmlabel  tolabel\n    'F '' GOBACK''       ALL'  fmlabel  tolabel\n    'F '' IF ''          ALL'  fmlabel  tolabel\n    'F '' OR ''          ALL'  fmlabel  tolabel\n    'F '' PERFORM ''     ALL'  fmlabel  tolabel\n    'F '' PROCEDURE ''   ALL'  fmlabel  tolabel\n    'F '' STOP-RUN''     ALL'  fmlabel  tolabel\n    'F '' UNTIL ''       ALL'  fmlabel  tolabel\n    'F '' WHEN ''        ALL'  fmlabel  tolabel\n    'EXCLUDE ALL ''//'' 1'\n    'EXCLUDE ALL ''*'' 7'\n    'RESET FIND'\n    'LOCATE 0'\n    'CURSOR = 1 1'\n  End                            /* End of COB processing         */\n\nElse if parm = 'EZ' Then\n  Do\n    'EXCLUDE ALL'\n    'F '' AND ''        ALL'  fmlabel  tolabel\n    'F ''AND ''       1 ALL'  fmlabel  tolabel\n    'F '' CALL''        ALL'  fmlabel  tolabel\n    'F ''CALL''       1 ALL'  fmlabel  tolabel\n    'F '' CASE''        ALL'  fmlabel  tolabel\n    'F ''CASE''       1 ALL'  fmlabel  tolabel\n    'F '' ELSE ''       ALL'  fmlabel  tolabel\n    'F ''ELSE ''      1 ALL'  fmlabel  tolabel\n    'F '' END-CASE ''   ALL'  fmlabel  tolabel\n    'F ''END-CASE ''  1 ALL'  fmlabel  tolabel\n    'F '' END-DO''      ALL'  fmlabel  tolabel\n    'F ''END-DO''     1 ALL'  fmlabel  tolabel\n    'F '' END-IF ''     ALL'  fmlabel  tolabel\n    'F ''END-IF ''    1 ALL'  fmlabel  tolabel\n    'F '' END-PROC ''   ALL'  fmlabel  tolabel\n    'F ''END-PROC ''  1 ALL'  fmlabel  tolabel\n    'F '' FILE ''       ALL'  fmlabel  tolabel\n    'F ''FILE ''      1 ALL'  fmlabel  tolabel\n    'F '' FINISH ''     ALL'  fmlabel  tolabel\n    'F ''FINISH ''    1 ALL'  fmlabel  tolabel\n    'F '' GOTO ''       ALL'  fmlabel  tolabel\n    'F ''GOTO ''      1 ALL'  fmlabel  tolabel\n    'F '' IF ''         ALL'  fmlabel  tolabel\n    'F ''IF ''        1 ALL'  fmlabel  tolabel\n    'F '' INPUT ''      ALL'  fmlabel  tolabel\n    'F ''JOB ''       1 ALL'  fmlabel  tolabel\n    'F '' JOB ''        ALL'  fmlabel  tolabel\n    'F ''OR ''        1 ALL'  fmlabel  tolabel\n    'F '' OR ''         ALL'  fmlabel  tolabel\n    'F ''PROC ''        ALL'  fmlabel  tolabel\n    'F ''REPORT ''    1 ALL'  fmlabel  tolabel\n    'F '' REPORT ''     ALL'  fmlabel  tolabel\n    'F ''SORT ''      1 ALL'  fmlabel  tolabel\n    'F '' SORT ''       ALL'  fmlabel  tolabel\n    'F ''START ''       ALL'  fmlabel  tolabel\n    'F ''STOP ''      1 ALL'  fmlabel  tolabel\n    'F '' STOP ''       ALL'  fmlabel  tolabel\n    'F ''USING ''       ALL'  fmlabel  tolabel\n    'F ''WHILE ''     1 ALL'  fmlabel  tolabel\n    'F '' WHILE ''      ALL'  fmlabel  tolabel\n    'EXCLUDE ALL ''//'' 1'\n    'EXCLUDE ALL ''*'' 1'\n    'RESET FIND'\n    'LOCATE 0'\n    'CURSOR = 1 1'\n  End                            /* End of E/Z processing         */\nElse\n  Do\n   ADDRESS TSO \"CLEAR\"\n   SAY \"STRUCT - Show program structure\"\n   SAY\n   SAY \" Format \"\n   SAY \"    STRUCT  Language  ( .From-Label  .To-Label ) \"\n   SAY\n   SAY \"       Language may be COB, EZ, PLI or REXX.  The label range  \"\n   SAY \"       is optional defaulting to the entire file. JCL, denoted \"\n   SAY \"       by '//' in column 1, and COBOL and Easytrieve comments, \"\n   SAY \"       indicated by an asterisk (*) in column 1, are always    \"\n   SAY \"       left excluded.                                          \"\n   SAY\n   SAY \" Example \"\n   SAY\n   SAY \"    STRUCT  EZ   .AA .BB\"\n   SAY\n   SAY \"       Will show the structure of the edited code only in \"\n   SAY \"       label range .AA thru .BB\"\n   SAY\n  End                            /* End of HELP                   */\n\nExit 0                           /* Always return a zero          */\n/* -------------------------------------------------------------- */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUBCAN": {"ttr": 36875, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\x16\\x00\\x16\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "REXX"}, "text": "/* REXX - SUBCAN: EDIT MACRO TO SUBMIT JCL AND CANCEL CHANGES         */\n/**********************************************************************/\n\n   ADDRESS ISPEXEC \"ISREDIT MACRO (PARMS)\"\n   IF SUBSTR(PARMS,1,1) = '?' THEN SIGNAL DISPDOC\n\n   ADDRESS ISREDIT \"SUBMIT\"\n   ADDRESS ISREDIT \"CANCEL\"\n\n   EXIT 0\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"SUBCAN -- SUBMIT JOB AND CANCEL EDIT SESSION           \"\n   SAY\n   SAY \"  SUBCAN  ( ? )                                        \"\n   SAY\n   SAY \"  SIMPLY SUBMITS THE EDITED FILE AND DOES A CANCEL.    \"\n   SAY \"  THE ONLY PARAMETER, A QUESTION MARK (?), CAUSES      \"\n   SAY \"  THIS VERY MINIMAL HELP TO BE DISPLAYED.              \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUBO": {"ttr": 36877, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x01\\x86\\x01\\x86\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 390, "newlines": 390, "modlines": 0, "user": "REXX"}, "text": "/**  REXX  --  SUBMIT THE JOB AFTER SUBSTITUTIONS  **/\n\n   SAVEMSG = MSG(\"OFF\")\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'SUBO MUST BE RUN UNDER ISPF!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (PARMS) PROCESS\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      ARG PARMS\n      SIGNAL DSLIST\n   END\n\n   IF SUBSTR(PARMS,1,1) = '?' THEN SIGNAL DISPDOC\n   CALL PARSE_PARMS\n   \"ISREDIT (THISMEM) = MEMBER\"\n   \"ISREDIT (THISDSN) = DATASET\"\n   IF THISMEM <> \"\"\n      THEN ZINPDSN = \"'\" || THISDSN || \"(\" || THISMEM || \")'\"\n      ELSE ZINPDSN = \"'\" || THISDSN || \"'\"\n\n   ADDRESS TSO\n   \"FREE DD(SUBODD)\"\n   \"ALLOC DD(SUBODD) SYSOUT(A) WRITER(INTRDR)\"\n   \"EXECIO 0 DISKW \"SUBODD\"(OPEN\"\n   \"ISREDIT (START) = LINENUM\" .ZFIRST\n   \"ISREDIT (END)   = LINENUM\" .ZLAST\n\n   ORIGIN_NOW = \"YES\"\n   DO PNTR =  START  TO  END  BY  1\n      \"ISREDIT (RECORD)   = LINE &PNTR\"\n      AMPER = 0\n      XX = INDEX(RECORD,\"&\")\n      IF XX > 0 THEN DO WHILE XX > 0\n         CALL PROCESS_TOKENS\n      END\n      IF AMPER > 0 THEN DO KK = 1 TO AMPER\n         LL = REAL.KK\n         RECORD = OVERLAY('&',RECORD,LL,1)\n      END\n      QUEUE RECORD\n      \"EXECIO 1 DISKW\" SUBODD\n      IF ORIGIN = \"YES\" THEN DO\n         IF ORIGIN_NOW = \"YES\" THEN DO\n            DO II = 71 TO 1 BY -1 WHILE SUBSTR(RECORD,II,1) = \" \"\n            END\n            IF SUBSTR(RECORD,II,1) <> \",\" THEN DO\n               CALL GEN_ORIGIN\n               ORIGIN_NOW = \"NO\"\n            END\n         END\n      END\n   END\n\n   IF ABEND <> \"NO\" THEN CALL GEN_ABEND\n   \"EXECIO 0 DISKW \"SUBODD\"(FINIS\"\n   \"FREE DD(SUBODD)\"\n   CALL SETMSG \"* NO JOB SUBMITTED$JOB SUBMITTED SUCCESSFULLY!\"\n   EXIT(0)\n\nDSLIST:\n   DO II = LENGTH(PARMS)-1 TO 1 BY -1 WHILE(SUBSTR(PARMS,II,1) <> \"'\")\n   END II\n   ZINPDSN = SUBSTR(PARMS,II)\n   PARMS   = SUBSTR(PARMS,1,II-1)\n\n   CALL PARSE_PARMS\n\n   ADDRESS TSO\n   \"FREE DD(DDXX SUBODD)\"\n   \"ALLOC DSN(\"ZINPDSN\") DD(DDXX) SHR\"\n   \"ALLOC DD(SUBODD) SYSOUT(A) WRITER(INTRDR)\"\n   \"EXECIO 0 DISKR\" DDXX   \"(OPEN\"\n   \"EXECIO 0 DISKW\" SUBODD \"(OPEN\"\n\n   \"EXECIO 1 DISKR\" DDXX\n   RET_CD     = RC\n   ORIGIN_NOW = 'YES'\n   DO WHILE ( RET_CD = 0 )\n      PULL RECORD\n      AMPER = 0\n      XX = INDEX(RECORD,\"&\")\n      IF XX > 0 THEN DO WHILE XX > 0\n         CALL PROCESS_TOKENS\n      END\n      IF AMPER > 0 THEN DO KK = 1 TO AMPER\n         LL = REAL.KK\n         RECORD = OVERLAY('&',RECORD,LL,1)\n      END\n      QUEUE RECORD\n      \"EXECIO 1 DISKW\" SUBODD\n      IF ORIGIN = 'YES' THEN DO\n         IF ORIGIN_NOW = 'YES' THEN DO\n            DO II = 71 TO 1 BY -1 WHILE SUBSTR(RECORD,II,1) = ' '\n            END\n            IF SUBSTR(RECORD,II,1) <> ',' THEN DO\n               CALL GEN_ORIGIN\n               ORIGIN_NOW = 'NO'\n            END\n         END\n      END\n      \"EXECIO 1 DISKR\" DDXX\n      RET_CD = RC\n   END\n\n   IF ABEND <> \"NO\" THEN CALL GEN_ABEND\n\n   \"EXECIO 0 DISKW\" DDXX \"(FINIS\"\n   \"FREE DD(DDXX SUBDDX)\"\n   EXIT(0)\n\nPROCESS_TOKENS:\n   IF SUBSTR(RECORD,XX+1,10) = \"CCYY/MM/DD\" THEN DO\n      SS = DATE(S)\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || SUBSTR(SS,1,4) || \"/\" || SUBSTR(SS,5,2),\n         || \"/\" || SUBSTR(SS,7,2),\n         || SUBSTR(RECORD,XX+11)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,08) = \"CCYY/DDD\" THEN DO\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || LEFT(DATE(S),4) || \"/\" || RIGHT(DATE(J),3),\n         || SUBSTR(RECORD,XX+9)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,07) = \"CCYYDDD\" THEN DO\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || LEFT(DATE(S),4) || RIGHT(DATE(J),3),\n         || SUBSTR(RECORD,XX+8)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,08) = \"CCYYMMDD\" THEN DO\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || DATE(S),\n         || SUBSTR(RECORD,XX+9)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,08) = \"DD/MM/YY\" THEN DO\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || DATE(E),\n         || SUBSTR(RECORD,XX+9)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,08) = \"HH:MM:SS\" THEN DO\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || TIME(),\n         || SUBSTR(RECORD,XX+9)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,05) = \"HH:MM\" THEN DO\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || LEFT(TIME(),5),\n         || SUBSTR(RECORD,XX+6)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,06) = \"HHMMSS\" THEN DO\n      SS = TIME()\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || SUBSTR(SS,1,2),\n         || SUBSTR(SS,4,2),\n         || SUBSTR(SS,7,2),\n         || SUBSTR(RECORD,XX+7)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,04) = \"HHMM\"  THEN DO\n      SS = TIME()\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || SUBSTR(SS,1,2),\n         || SUBSTR(SS,4,2),\n         || SUBSTR(RECORD,XX+5)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,08) = \"MM/DD/YY\" THEN DO\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || DATE(U),\n         || SUBSTR(RECORD,XX+9)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,06) = \"MMDDYY\" THEN DO\n      SS = DATE(U)\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || SUBSTR(SS,1,2),\n         || SUBSTR(SS,4,2),\n         || SUBSTR(SS,7,2),\n         || SUBSTR(RECORD,XX+7)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,05) = \"MONTH\" THEN DO\n      SS = DATE(U)\n      II = SUBSTR(SS,1,2)\n      IF II = 1 THEN MONTH_NAME = 'JANUARY'\n         ELSE IF II =  2 THEN MONTH_NAME = 'FEBRUARY'\n         ELSE IF II =  3 THEN MONTH_NAME = 'MARCH'\n         ELSE IF II =  4 THEN MONTH_NAME = 'APRIL'\n         ELSE IF II =  5 THEN MONTH_NAME = 'MAY'\n         ELSE IF II =  6 THEN MONTH_NAME = 'JUNE'\n         ELSE IF II =  7 THEN MONTH_NAME = 'JULY'\n         ELSE IF II =  8 THEN MONTH_NAME = 'AUGUST'\n         ELSE IF II =  9 THEN MONTH_NAME = 'SEPTEMBER'\n         ELSE IF II = 10 THEN MONTH_NAME = 'OCTOBER'\n         ELSE IF II = 11 THEN MONTH_NAME = 'NOVEMBER'\n         ELSE IF II = 12 THEN MONTH_NAME = 'DECEMBER'\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || MONTH_NAME,\n         || SUBSTR(RECORD,XX+6)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,03) = \"MON\" THEN DO\n      SS = DATE(U)\n      II = SUBSTR(SS,1,2)\n      IF II = 1 THEN MONTH_NAME = 'JAN'\n         ELSE IF II =  2 THEN MONTH_NAME = 'FEB'\n         ELSE IF II =  3 THEN MONTH_NAME = 'MAR'\n         ELSE IF II =  4 THEN MONTH_NAME = 'APR'\n         ELSE IF II =  5 THEN MONTH_NAME = 'MAY'\n         ELSE IF II =  6 THEN MONTH_NAME = 'JUN'\n         ELSE IF II =  7 THEN MONTH_NAME = 'JUL'\n         ELSE IF II =  8 THEN MONTH_NAME = 'AUG'\n         ELSE IF II =  9 THEN MONTH_NAME = 'SEP'\n         ELSE IF II = 10 THEN MONTH_NAME = 'OCT'\n         ELSE IF II = 11 THEN MONTH_NAME = 'NOV'\n         ELSE IF II = 12 THEN MONTH_NAME = 'DEC'\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || MONTH_NAME,\n         || SUBSTR(RECORD,XX+4)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,07) = \"DAYOFWK\" THEN DO\n      II = DATE('B')//7\n      IF II = 0 THEN MONTH_NAME = 'MONDAY'\n         ELSE IF II =  1 THEN MONTH_NAME = 'TUESDAY'\n         ELSE IF II =  2 THEN MONTH_NAME = 'WEDNESDAY'\n         ELSE IF II =  3 THEN MONTH_NAME = 'THURSDAY'\n         ELSE IF II =  4 THEN MONTH_NAME = 'FRIDAY'\n         ELSE IF II =  5 THEN MONTH_NAME = 'SATURDAY'\n         ELSE IF II =  6 THEN MONTH_NAME = 'SUNDAY'\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || MONTH_NAME,\n         || SUBSTR(RECORD,XX+8)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,03) = \"DOW\" THEN DO\n      II = DATE('B')//7\n      IF II = 0 THEN MONTH_NAME = 'MON'\n         ELSE IF II =  1 THEN MONTH_NAME = 'TUE'\n         ELSE IF II =  2 THEN MONTH_NAME = 'WED'\n         ELSE IF II =  3 THEN MONTH_NAME = 'THU'\n         ELSE IF II =  4 THEN MONTH_NAME = 'FRI'\n         ELSE IF II =  5 THEN MONTH_NAME = 'SAT'\n         ELSE IF II =  6 THEN MONTH_NAME = 'SUN'\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || MONTH_NAME,\n         || SUBSTR(RECORD,XX+4)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,06) = \"USERID\" THEN DO\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || USERID(),\n         || SUBSTR(RECORD,XX+7)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,04) = \"YEAR\" THEN DO\n      SS = DATE(S)\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || SUBSTR(SS,1,4),\n         || SUBSTR(RECORD,XX+5)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,08) = \"YY/MM/DD\" THEN DO\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || DATE(O),\n         || SUBSTR(RECORD,XX+9)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,05) = \"YYDDD\" THEN DO\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || DATE(J),\n         || SUBSTR(RECORD,XX+6)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,06) = \"YYMMDD\" THEN DO\n      SS = DATE(U)\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || SUBSTR(SS,7,2),\n         || SUBSTR(SS,1,2),\n         || SUBSTR(SS,4,2),\n         || SUBSTR(RECORD,XX+7)\n   END\n   ELSE DO\n      RECORD = OVERLAY('.',RECORD,XX,1)\n      AMPER = AMPER + 1\n      REAL.AMPER = XX\n   END\n   XX = INDEX(RECORD,\"&\")\n   RETURN\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nGEN_ORIGIN:\n   ORGREC = \"//***\"\n   QUEUE ORGREC\n   \"EXECIO 1 DISKW\" SUBODD\n   DD = SUBSTR(DATE(U),4,2)\n   IF SUBSTR(DD,2,1) = '1'         THEN XX = 'ST'\n      ELSE IF SUBSTR(DD,2,1) = '2' THEN XX = 'ND'\n      ELSE IF SUBSTR(DD,2,1) = '3' THEN XX = 'RD'\n      ELSE XX = 'TH'\n   IF SUBSTR(DD,1,1) = '0'         THEN DD = SUBSTR(DD,2)\n   UDOW = TRANSLATE(DATE(W))\n   UMON = TRANSLATE(DATE(M))\n   ORGREC = \"//***  SUBMITTED BY \",\n      || USERID() || \" ON \" || UDOW || \" \" || UMON,\n      || \" \" || DD||XX',' SUBSTR(DATE(S),1,4),\n      || \" (DAY\" SUBSTR(DATE(J),3,3)\")\"\n   QUEUE ORGREC\n   \"EXECIO 1 DISKW\" SUBODD\n   ORGREC = \"//***    \" || \" AT \" || TIME(),\n      ||  \" FROM \" || ZINPDSN\n   QUEUE ORGREC\n   \"EXECIO 1 DISKW\" SUBODD\n   ORGREC = \"//***\"\n   QUEUE ORGREC\n   \"EXECIO 1 DISKW\" SUBODD\n   ORIGIN = \"NO\"\n   RETURN\n\nPARSE_PARMS:\n   PARMS     = TRANSLATE(PARMS)\n   ABEND     = \"NO\"\n   CODE      = \"666\"\n   ORIGIN    = \"YES\"\n   DO II = 1 TO 10\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF TOKEN = \"ORIGIN\" | TOKEN = \"ORG\" | TOKEN = \"O\",\n         THEN ORIGIN = \"YES\"\n      IF SUBSTR(TOKEN,1,5) = \"ABEND\" THEN DO\n         IF LENGTH(TOKEN) = 5 THEN ABEND = \"0,LT\"\n         ELSE ABEND = SUBSTR(TOKEN,7,LENGTH(TOKEN)-7)\n      END\n      IF SUBSTR(TOKEN,1,4) = \"CODE\" THEN DO\n         CODE = SUBSTR(TOKEN,6,LENGTH(TOKEN)-6)\n      END\n   END II\n   RETURN\n\nGEN_ABEND:\n   ABENDREC = \"//***\"\n   QUEUE ABENDREC\n   \"EXECIO 1 DISKW\" SUBODD\n   ABENDREC = \"//ABEND      EXEC\",\n      || \"     PGM=ABENDX,PARM=\",\n      || CODE || \",COND=(\" || ABEND || \")\"\n   QUEUE ABENDREC\n   \"EXECIO 1 DISKW\" SUBODD\n   ABENDREC = \"//STEPLIB      DD       DISP=SHR,DSN=\",\n      || \"-YOUR-LOADLIB-\"\n   QUEUE ABENDREC\n   \"EXECIO 1 DISKW\" SUBODD\n   ABENDREC = \"//***\"\n   QUEUE ABENDREC\n   \"EXECIO 1 DISKW\" SUBODD\n   RETURN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"SUBO -- SUBMIT FILE WITH VAR'S SUB & ORIGIN & ABEND   \"\n   SAY\n   SAY \"   SUBO  ( ABEND(COND) )  ( CODE(#) )  ( NOORIGIN )   \"\n   SAY\n   SAY \"     ABEND SPECIFIES COND CODE, DEFAULTS TO '0,LT';   \"\n   SAY \"     CODE SPECIFIES USER ABEND CODE, DEFAULTS TO 666; \"\n   SAY \"     NOORIGIN CAUSES COMMENTS WITH DATE/TIME, SOURCE  \"\n   SAY \"     AND USER NOT TO BE DISPLAYED. TOKENS ARE:        \"\n   SAY\n   SAY \"       &CCYY/MM/DD ==> 2001/02/03                     \"\n   SAY \"       &CCYY/DDD   ==> 2001/034                       \"\n   SAY \"       &CCYYDDD    ==> 2001034                        \"\n   SAY \"       &CCYYMMDD   ==> 20010203                       \"\n   SAY \"       &DAYOFWK    ==> SATURDAY                       \"\n   SAY \"       &DD/MM/YY   ==> 03/02/01                       \"\n   SAY \"       &DOW        ==> SAT                            \"\n   SAY \"       &HH:MM      ==> 12:34                          \"\n   SAY \"       &HH:MM:SS   ==> 12:34:56                       \"\n   SAY \"       &HHMM       ==> 1234                           \"\n   SAY \"       &HHMMSS     ==> 123456                         \"\n   SAY \"       &MM/DD/YY   ==> 02/03/01                       \"\n   SAY \"       &MMDDYY     ==> 020301                         \"\n   SAY \"       &MON        ==> FEB                            \"\n   SAY \"       &MONTH      ==> FEBRUARY                       \"\n   SAY \"       &USERID     ==> SPRK0JG                        \"\n   SAY \"       &YY/MM/DD   ==> 01/02/03                       \"\n   SAY \"       &YYDDD      ==> 01034                          \"\n   SAY \"       &YYMMDD     ==> 010203                         \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUBX": {"ttr": 37126, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x01\\x85\\x01\\x85\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 389, "newlines": 389, "modlines": 0, "user": "REXX"}, "text": "/**  REXX  --  SUBMIT THE JOB AFTER SUBSTITUTIONS  **/\n\n   SAVEMSG = MSG(\"OFF\")\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'SUBX MUST BE RUN UNDER ISPF!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (PARMS) PROCESS\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      ARG PARMS\n      SIGNAL DSLIST\n   END\n\n   IF SUBSTR(PARMS,1,1) = '?' THEN SIGNAL DISPDOC\n   CALL PARSE_PARMS\n   \"ISREDIT (THISMEM) = MEMBER\"\n   \"ISREDIT (THISDSN) = DATASET\"\n   IF THISMEM <> \"\"\n      THEN ZINPDSN = \"'\" || THISDSN || \"(\" || THISMEM || \")'\"\n      ELSE ZINPDSN = \"'\" || THISDSN || \"'\"\n\n   ADDRESS TSO\n   \"FREE DD(SUBXDD)\"\n   \"ALLOC DD(SUBXDD) SYSOUT(A) WRITER(INTRDR)\"\n   \"EXECIO 0 DISKW \"SUBXDD\"(OPEN\"\n   \"ISREDIT (START) = LINENUM\" .ZFIRST\n   \"ISREDIT (END)   = LINENUM\" .ZLAST\n\n   ORIGIN_NOW = \"YES\"\n   DO PNTR =  START  TO  END  BY  1\n      \"ISREDIT (RECORD)   = LINE &PNTR\"\n      AMPER = 0\n      XX = INDEX(RECORD,\"&\")\n      IF XX > 0 THEN DO WHILE XX > 0\n         CALL PROCESS_TOKENS\n      END\n      IF AMPER > 0 THEN DO KK = 1 TO AMPER\n         LL = REAL.KK\n         RECORD = OVERLAY('&',RECORD,LL,1)\n      END\n      QUEUE RECORD\n      \"EXECIO 1 DISKW\" SUBXDD\n      IF ORIGIN = \"YES\" THEN DO\n         IF ORIGIN_NOW = \"YES\" THEN DO\n            DO II = 71 TO 1 BY -1 WHILE SUBSTR(RECORD,II,1) = \" \"\n            END\n            IF SUBSTR(RECORD,II,1) <> \",\" THEN DO\n               CALL GEN_ORIGIN\n               ORIGIN_NOW = \"NO\"\n            END\n         END\n      END\n   END\n\n   IF ABEND <> \"NO\" THEN CALL GEN_ABEND\n   \"EXECIO 0 DISKW \"SUBXDD\"(FINIS\"\n   \"FREE DD(SUBXDD)\"\n   CALL SETMSG \"* NO JOB SUBMITTED$JOB SUBMITTED SUCCESSFULLY!\"\n   EXIT(0)\n\nDSLIST:\n   DO II = LENGTH(PARMS)-1 TO 1 BY -1 WHILE(SUBSTR(PARMS,II,1) <> \"'\")\n   END II\n   ZINPDSN = SUBSTR(PARMS,II)\n   PARMS   = SUBSTR(PARMS,1,II-1)\n\n   CALL PARSE_PARMS\n\n   ADDRESS TSO\n   \"FREE DD(DDXX SUBXDD)\"\n   \"ALLOC DSN(\"ZINPDSN\") DD(DDXX) SHR\"\n   \"ALLOC DD(SUBXDD) SYSOUT(A) WRITER(INTRDR)\"\n   \"EXECIO 0 DISKR\" DDXX   \"(OPEN\"\n   \"EXECIO 0 DISKW\" SUBXDD \"(OPEN\"\n\n   \"EXECIO 1 DISKR\" DDXX\n   RET_CD     = RC\n   ORIGIN_NOW = 'YES'\n   DO WHILE ( RET_CD = 0 )\n      PULL RECORD\n      AMPER = 0\n      XX = INDEX(RECORD,\"&\")\n      IF XX > 0 THEN DO WHILE XX > 0\n         CALL PROCESS_TOKENS\n      END\n      IF AMPER > 0 THEN DO KK = 1 TO AMPER\n         LL = REAL.KK\n         RECORD = OVERLAY('&',RECORD,LL,1)\n      END\n      QUEUE RECORD\n      \"EXECIO 1 DISKW\" SUBXDD\n      IF ORIGIN = 'YES' THEN DO\n         IF ORIGIN_NOW = 'YES' THEN DO\n            DO II = 71 TO 1 BY -1 WHILE SUBSTR(RECORD,II,1) = ' '\n            END\n            IF SUBSTR(RECORD,II,1) <> ',' THEN DO\n               CALL GEN_ORIGIN\n               ORIGIN_NOW = 'NO'\n            END\n         END\n      END\n      \"EXECIO 1 DISKR\" DDXX\n      RET_CD = RC\n   END\n\n   IF ABEND <> \"NO\" THEN CALL GEN_ABEND\n\n   \"EXECIO 0 DISKW\" DDXX \"(FINIS\"\n   \"FREE DD(DDXX SUBDDX)\"\n   EXIT(0)\n\nPROCESS_TOKENS:\n   IF SUBSTR(RECORD,XX+1,10) = \"CCYY/MM/DD\" THEN DO\n      SS = DATE(S)\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || SUBSTR(SS,1,4) || \"/\" || SUBSTR(SS,5,2),\n         || \"/\" || SUBSTR(SS,7,2),\n         || SUBSTR(RECORD,XX+11)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,08) = \"CCYY/DDD\" THEN DO\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || LEFT(DATE(S),4) || \"/\" || RIGHT(DATE(J),3),\n         || SUBSTR(RECORD,XX+9)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,07) = \"CCYYDDD\" THEN DO\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || LEFT(DATE(S),4) || RIGHT(DATE(J),3),\n         || SUBSTR(RECORD,XX+8)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,08) = \"CCYYMMDD\" THEN DO\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || DATE(S),\n         || SUBSTR(RECORD,XX+9)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,08) = \"DD/MM/YY\" THEN DO\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || DATE(E),\n         || SUBSTR(RECORD,XX+9)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,08) = \"HH:MM:SS\" THEN DO\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || TIME(),\n         || SUBSTR(RECORD,XX+9)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,05) = \"HH:MM\" THEN DO\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || LEFT(TIME(),5),\n         || SUBSTR(RECORD,XX+6)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,06) = \"HHMMSS\" THEN DO\n      SS = TIME()\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || SUBSTR(SS,1,2),\n         || SUBSTR(SS,4,2),\n         || SUBSTR(SS,7,2),\n         || SUBSTR(RECORD,XX+7)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,04) = \"HHMM\"  THEN DO\n      SS = TIME()\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || SUBSTR(SS,1,2),\n         || SUBSTR(SS,4,2),\n         || SUBSTR(RECORD,XX+5)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,08) = \"MM/DD/YY\" THEN DO\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || DATE(U),\n         || SUBSTR(RECORD,XX+9)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,06) = \"MMDDYY\" THEN DO\n      SS = DATE(U)\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || SUBSTR(SS,1,2),\n         || SUBSTR(SS,4,2),\n         || SUBSTR(SS,7,2),\n         || SUBSTR(RECORD,XX+7)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,05) = \"MONTH\" THEN DO\n      SS = DATE(U)\n      II = SUBSTR(SS,1,2)\n      IF II = 1 THEN MONTH_NAME = 'JANUARY'\n         ELSE IF II =  2 THEN MONTH_NAME = 'FEBRUARY'\n         ELSE IF II =  3 THEN MONTH_NAME = 'MARCH'\n         ELSE IF II =  4 THEN MONTH_NAME = 'APRIL'\n         ELSE IF II =  5 THEN MONTH_NAME = 'MAY'\n         ELSE IF II =  6 THEN MONTH_NAME = 'JUNE'\n         ELSE IF II =  7 THEN MONTH_NAME = 'JULY'\n         ELSE IF II =  8 THEN MONTH_NAME = 'AUGUST'\n         ELSE IF II =  9 THEN MONTH_NAME = 'SEPTEMBER'\n         ELSE IF II = 10 THEN MONTH_NAME = 'OCTOBER'\n         ELSE IF II = 11 THEN MONTH_NAME = 'NOVEMBER'\n         ELSE IF II = 12 THEN MONTH_NAME = 'DECEMBER'\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || MONTH_NAME,\n         || SUBSTR(RECORD,XX+6)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,03) = \"MON\" THEN DO\n      SS = DATE(U)\n      II = SUBSTR(SS,1,2)\n      IF II = 1 THEN MONTH_NAME = 'JAN'\n         ELSE IF II =  2 THEN MONTH_NAME = 'FEB'\n         ELSE IF II =  3 THEN MONTH_NAME = 'MAR'\n         ELSE IF II =  4 THEN MONTH_NAME = 'APR'\n         ELSE IF II =  5 THEN MONTH_NAME = 'MAY'\n         ELSE IF II =  6 THEN MONTH_NAME = 'JUN'\n         ELSE IF II =  7 THEN MONTH_NAME = 'JUL'\n         ELSE IF II =  8 THEN MONTH_NAME = 'AUG'\n         ELSE IF II =  9 THEN MONTH_NAME = 'SEP'\n         ELSE IF II = 10 THEN MONTH_NAME = 'OCT'\n         ELSE IF II = 11 THEN MONTH_NAME = 'NOV'\n         ELSE IF II = 12 THEN MONTH_NAME = 'DEC'\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || MONTH_NAME,\n         || SUBSTR(RECORD,XX+4)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,07) = \"DAYOFWK\" THEN DO\n      II = DATE('B')//7\n      IF II = 0 THEN MONTH_NAME = 'MONDAY'\n         ELSE IF II =  1 THEN MONTH_NAME = 'TUESDAY'\n         ELSE IF II =  2 THEN MONTH_NAME = 'WEDNESDAY'\n         ELSE IF II =  3 THEN MONTH_NAME = 'THURSDAY'\n         ELSE IF II =  4 THEN MONTH_NAME = 'FRIDAY'\n         ELSE IF II =  5 THEN MONTH_NAME = 'SATURDAY'\n         ELSE IF II =  6 THEN MONTH_NAME = 'SUNDAY'\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || MONTH_NAME,\n         || SUBSTR(RECORD,XX+8)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,03) = \"DOW\" THEN DO\n      II = DATE('B')//7\n      IF II = 0 THEN MONTH_NAME = 'MON'\n         ELSE IF II =  1 THEN MONTH_NAME = 'TUE'\n         ELSE IF II =  2 THEN MONTH_NAME = 'WED'\n         ELSE IF II =  3 THEN MONTH_NAME = 'THU'\n         ELSE IF II =  4 THEN MONTH_NAME = 'FRI'\n         ELSE IF II =  5 THEN MONTH_NAME = 'SAT'\n         ELSE IF II =  6 THEN MONTH_NAME = 'SUN'\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || MONTH_NAME,\n         || SUBSTR(RECORD,XX+4)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,06) = \"USERID\" THEN DO\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || USERID(),\n         || SUBSTR(RECORD,XX+7)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,04) = \"YEAR\" THEN DO\n      SS = DATE(S)\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || SUBSTR(SS,1,4),\n         || SUBSTR(RECORD,XX+5)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,08) = \"YY/MM/DD\" THEN DO\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || DATE(O),\n         || SUBSTR(RECORD,XX+9)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,05) = \"YYDDD\" THEN DO\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || DATE(J),\n         || SUBSTR(RECORD,XX+6)\n   END\n   ELSE IF SUBSTR(RECORD,XX+1,06) = \"YYMMDD\" THEN DO\n      SS = DATE(U)\n      RECORD = SUBSTR(RECORD,1,XX-1),\n         || SUBSTR(SS,7,2),\n         || SUBSTR(SS,1,2),\n         || SUBSTR(SS,4,2),\n         || SUBSTR(RECORD,XX+7)\n   END\n   ELSE DO\n      RECORD = OVERLAY('.',RECORD,XX,1)\n      AMPER = AMPER + 1\n      REAL.AMPER = XX\n   END\n   XX = INDEX(RECORD,\"&\")\n   RETURN\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nGEN_ORIGIN:\n   ORGREC = \"//***\"\n   QUEUE ORGREC\n   \"EXECIO 1 DISKW\" SUBXDD\n   DD = SUBSTR(DATE(U),4,2)\n   IF SUBSTR(DD,2,1) = '1'         THEN XX = 'ST'\n      ELSE IF SUBSTR(DD,2,1) = '2' THEN XX = 'ND'\n      ELSE IF SUBSTR(DD,2,1) = '3' THEN XX = 'RD'\n      ELSE XX = 'TH'\n   IF SUBSTR(DD,1,1) = '0'         THEN DD = SUBSTR(DD,2)\n   UDOW = TRANSLATE(DATE(W))\n   UMON = TRANSLATE(DATE(M))\n   ORGREC = \"//***  SUBMITTED BY \",\n      || USERID() || \" ON \" || UDOW || \" \" || UMON,\n      || \" \" || DD||XX',' SUBSTR(DATE(S),1,4),\n      || \" (DAY\" SUBSTR(DATE(J),3,3)\")\"\n   QUEUE ORGREC\n   \"EXECIO 1 DISKW\" SUBXDD\n   ORGREC = \"//***    \" || \" AT \" || TIME(),\n      ||  \" FROM \" || ZINPDSN\n   QUEUE ORGREC\n   \"EXECIO 1 DISKW\" SUBXDD\n   ORGREC = \"//***\"\n   QUEUE ORGREC\n   \"EXECIO 1 DISKW\" SUBXDD\n   ORIGIN = \"NO\"\n   RETURN\n\nPARSE_PARMS:\n   PARMS     = TRANSLATE(PARMS)\n   ABEND     = \"NO\"\n   CODE      = \"666\"\n   ORIGIN    = \"NO\"\n   DO II = 1 TO 10\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF TOKEN = \"ORIGIN\" | TOKEN = \"ORG\" | TOKEN = \"O\",\n         THEN ORIGIN = \"YES\"\n      IF SUBSTR(TOKEN,1,5) = \"ABEND\" THEN DO\n         IF LENGTH(TOKEN) = 5 THEN ABEND = \"0,LT\"\n         ELSE ABEND = SUBSTR(TOKEN,7,LENGTH(TOKEN)-7)\n      END\n      IF SUBSTR(TOKEN,1,4) = \"CODE\" THEN DO\n         CODE = SUBSTR(TOKEN,6,LENGTH(TOKEN)-6)\n      END\n   END II\n   RETURN\n\nGEN_ABEND:\n   ABENDREC = \"//***\"\n   QUEUE ABENDREC\n   \"EXECIO 1 DISKW\" SUBXDD\n   ABENDREC = \"//ABEND      EXEC\",\n      || \"     PGM=ABENDX,PARM=\",\n      || CODE || \",COND=(\" || ABEND || \")\"\n   QUEUE ABENDREC\n   \"EXECIO 1 DISKW\" SUBXDD\n   ABENDREC = \"//STEPLIB      DD       DISP=SHR,DSN=\",\n      || \"-YOUR-LOADLIB-\"\n   QUEUE ABENDREC\n   \"EXECIO 1 DISKW\" SUBXDD\n   ABENDREC = \"//***\"\n   QUEUE ABENDREC\n   \"EXECIO 1 DISKW\" SUBXDD\n   RETURN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"SUBX -- SUBMIT FILE WITH VAR'S SUB & ORIGIN & ABEND   \"\n   SAY\n   SAY \"   SUBX  ( ABEND(COND) )  ( CODE(#) )  ( ORIGIN )     \"\n   SAY\n   SAY \"     ABEND SPECIFIES COND CODE, DEFAULTS TO '0,LT';   \"\n   SAY \"     CODE SPECIFIES USER ABEND CODE, DEFAULTS TO 666; \"\n   SAY \"     ORIGIN FORCES COMMENTS WITH DATE, LIB AND USER   \"\n   SAY\n   SAY \"       &CCYY/MM/DD ==> 2001/02/03                     \"\n   SAY \"       &CCYY/DDD   ==> 2001/034                       \"\n   SAY \"       &CCYYDDD    ==> 2001034                        \"\n   SAY \"       &CCYYMMDD   ==> 20010203                       \"\n   SAY \"       &DAYOFWK    ==> SATURDAY                       \"\n   SAY \"       &DD/MM/YY   ==> 03/02/01                       \"\n   SAY \"       &DOW        ==> SAT                            \"\n   SAY \"       &HH:MM      ==> 12:34                          \"\n   SAY \"       &HH:MM:SS   ==> 12:34:56                       \"\n   SAY \"       &HHMM       ==> 1234                           \"\n   SAY \"       &HHMMSS     ==> 123456                         \"\n   SAY \"       &MM/DD/YY   ==> 02/03/01                       \"\n   SAY \"       &MMDDYY     ==> 020301                         \"\n   SAY \"       &MON        ==> FEB                            \"\n   SAY \"       &MONTH      ==> FEBRUARY                       \"\n   SAY \"       &USERID     ==> SPRK0JG                        \"\n   SAY \"       &YY/MM/DD   ==> 01/02/03                       \"\n   SAY \"       &YYDDD      ==> 01034                          \"\n   SAY \"       &YYMMDD     ==> 010203                         \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUFFLINE": {"ttr": 37379, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\\\\\x00\\\\\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 92, "newlines": 92, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- SUFF -- WILL SUFFIX LINES WITH A CHARACTER STRING  **/\n   ADDRESS ISREDIT \"MACRO (PARM1) NOPROCESS\"\n   IF RC > 0 THEN DO\n      SIGNAL NOT_IN_EDIT\n      SAY \"THIS IS AN EDIT MACRO\"\n      EXIT\n   END\n\n   IF PARM1 = \"\" | PARM1 = \"?\"  THEN SIGNAL DISPDOC\n\n   ADDRESS ISREDIT \"(TYPE) = PROFILE\"\n\n   PARM1 = TRANSLATE(PARM1)\n   IF PARM1 = \"QUOTE\"       THEN PARM1 = '\"'\n   IF PARM1 = \"APOSTROPHE\"  THEN PARM1 = \"'\"\n   IF PARM1 = \"APOST\"       THEN PARM1 = \"'\"\n   IF PARM1 = \"COMMA\"       THEN PARM1 = \",\"\n\n   ADDRESS ISPEXEC\n   'CONTROL ERRORS RETURN'\n   'ISREDIT PROCESS RANGE C  '\n   SELECT\n      WHEN RC = 0 THEN DO\n         'ISREDIT (CMD) = RANGE_CMD'\n         'ISREDIT (LINE1) = LINENUM .ZFRANGE'\n         'ISREDIT (LINE2) = LINENUM .ZLRANGE'\n         LINESTOCUT = LINE2 - LINE1 + 1\n      END\n      WHEN RC <= 4 THEN DO                      /* NO C OR M ENTERED */\n         'ISREDIT (LINE1) = LINENUM .ZFRANGE'\n         'ISREDIT (LINE2) = LINENUM .ZLRANGE'\n         LINESTOCUT = LINE2 - LINE1 + 1\n      END\n      OTHERWISE  /* LINE COMMAND CONFLICT - EDIT WILL CREATE MESSAGE */\n          EXIT 12\n   END  /* SELECT */\n\n/* PUT THE LINES IN STEM VARBLE */\n   CUTCNT = 0  /* CHANGE LATER */\n   DO I = LINE1 TO LINE2\n      CUTCNT = CUTCNT + 1\n      'ISREDIT (CL'CUTCNT') = LINE' I\n      'ISREDIT (CURLINE) = LINE' I\n      NEWLINE = CURLINE\n      IF NEWLINE = COPIES(\" \",LENGTH(NEWLINE)) THEN DO\n         NEWLENGTH = LENGTH(NEWLINE) - LENGTH(PARM1)\n      END\n      ELSE DO\n         NEWLINE = REVERSE(NEWLINE)\n         PARM1R  = REVERSE(PARM1)\n         DO I2 = 1 TO LENGTH(NEWLINE)\n            IF SUBSTR(NEWLINE,I2,1) <> \" \" THEN DO\n               NEWLINE = COPIES(\" \",I2-1)\"\"PARM1R\"\"SUBSTR(NEWLINE,I2)\n               LEAVE I2\n            END\n         END I2\n      NEWLINE = REVERSE(NEWLINE)\n      END\n      \"ISREDIT LINE\" I \"= (NEWLINE)\"\n      CL.0 = CUTCNT\n   END I\n   EXIT(0)\n\nBAD_INPUT:\n   ZEDSMSG = \"PARM MISSING\"\n   ZEDLMSG = \"RE-EXECUTE FROM COMMAND LINE: SUFF CHARACTER-TO-SUFFIX\"\n   ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n   EXIT(1)\n\nNOT_IN_EDIT:\n   ZEDSMSG = \"NOT IN ISPF EDIT\"\n   ZEDLMSG = \"THIS MUST BE EXECUTED WHILE IN ISPF EDIT AS A MACRO. \"\n   ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n   EXIT(1)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"                                                             \"\n   SAY \"  SUFFLINE  APPENDS A STRING TO THE END OF EVERY SELECTED    \"\n   SAY \"            LINE (VIA C/CC/C#) OR TO EVERY LINE IN THE FILE. \"\n   SAY \"                                                             \"\n   SAY \"     IF YOU WANT TO SUFFIX WITH A QUOTE, USE THE WORD        \"\n   SAY \"     QUOTE; IF YOU WANT TO SUFFIX WITH AN APOSTROPHE,        \"\n   SAY \"     USE THE WORD APOST; IF YOU WANT TO SUFFIX WITH A        \"\n   SAY \"     COMMA, USE THE WORD COMMA.                              \"\n   SAY\n   SAY \"     FOR EXAMPLE,                                            \"\n   SAY \"        SUFFLINE |                                           \"\n   SAY \"     WILL APPEND A VERTICAL BAR TO THE END OF EACH LINE.     \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUMCOLS": {"ttr": 37382, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xac\\x00\\xac\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 172, "newlines": 172, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- SUMS SPECIFIED COLUMNS  **/\n   Numeric Digits 31\n   Address \"ISREDIT\";\n   \"MACRO (PRM1 PRM2 PRM3 PRM4 PRM5 PRM6 PRM7 PRM8 PRM9 PRM10\",\n          \"PRM11 PRM12 PRM13 PRM14 PRM15 PRM16 PRM17 PRM18 PRM19\",\n          \"PRM20) NOPROCESS\"\n   If PRM1 = '' | PRM1 = '?' then signal DISPDOC\n\n   Labels = 0\n   Pairs  = 0\n   tok.   = \"\"\n   Do I = 1 to 20\n      x = value(\"PRM\"I)\n      If x = \"\" then I = 20\n      Else do\n         If substr(x,1,1) = '.' then do\n            If Labels = 0 then LabFrom = x\n            Else LabTo = x\n            Labels = Labels + 1\n         End\n         Else do\n            Pairs = Pairs + 1\n            tok.i = value(\"PRM\"I)\n            If  \u00acDATATYPE(tok.i,\"N\")  then do\n               ZEDSMSG = 'Bad Column'\n               ZEDLMSG = \"Columns must be numeric,\" tok.i \"is not\"\n               Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               Exit(4)\n            End\n         End\n      End\n   End  /* Do I = 1 to 20 */\n\n   If Labels > 0 & Labels <> 2 then do\n      ZEDSMSG = \"Too many lbls\"\n      ZEDLMSG = Labels \"is too many labels\"\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      Exit(4)\n   End\n   If Labels = 2 then do\n      \"(LineBgn) = LINENUM \" LabFrom\n      \"(LineEnd) = LINENUM \" LabTo\n   End\n   Else do\n      \"PROCESS RANGE C\"\n      rch = RC\n      If rch = 0 then do\n         \"(ZFRANGE) = LINENUM .ZFRANGE\"\n         \"(ZLRANGE) = LINENUM .ZLRANGE\"\n         Labels = 2\n      End\n      Else do\n         If rch =  4  then do\n            \"(ZFRANGE) = LINENUM .ZFIRST\"\n            \"(ZLRANGE) = LINENUM .ZLAST\"\n            Labels = 2\n         End\n         Else do\n            \"LINE_BEFORE .ZFIRST = NOTELINE \",\n             \"'ISREDIT PROCESS C or RANGE CC return code is\" rch\"'\"\n             Exit(4)\n         End\n      End\n      LineBgn = ZFRANGE\n      LineEnd = ZLRANGE\n   End\n\n   If LineEnd < LineBgn then do\n      x = LineBgn\n      LineBgn = LineEnd\n      LineEnd = x\n   End\n   IF LineBgn = 0 THEN LineBgn = 1\n   sum. = 0\n\n   Do I = LineBgn to LineEnd by 1\n      \"(XLINE)   = LINE\" I\n      \"(XSTATUS) = XSTATUS\" I\n      If xstatus = \"NX\" then do\n         Rowtot = 0\n         Do J = 1 to 17 by 2\n            If tok.J = \"\" then leave\n            jp1 = J + 1\n            bb = tok.jp1 - tok.J + 1\n            addend = substr(XLINE,tok.J,bb)\n            ii = index(addend,',')\n            Do while ii <> 0\n               addend = substr(addend,1,ii-1),\n                  || substr(addend,ii+1)\n               ii = index(addend,',')\n            End\n            If addend <> ' ' then do\n               If index(addend,'+') = 0 & index(addend,'-') = 0 then do\n                  Do ii = length(addend) to 1 by -1,\n                     while ( substr(addend,ii,1) = ' ' )\n                  End\n                  kk = substr(addend,ii,1)\n                  If kk < '0' | kk > '9' then do\n                     kk = translate(kk)\n                     If verify(kk,'}JKLMNOPQR') = 0\n                        then addend = '-' || substr(addend,1,ii-1),\n                           || translate(kk,'0123456789','}JKLMNOPQR')\n                     Else if verify(kk,'{ABCDEFGHI') = 0\n                        then addend = '+' || substr(addend,1,ii-1),\n                           || translate(kk,'0123456789','{ABCDEFGHI')\n                  End\n               End\n               Else do\n                  If index(addend,'+') <> 0 then do\n                     ii = index(addend,'+')\n                     addend = '+' || substr(addend,1,ii-1),\n                        || substr(addend,ii+1)\n                  End\n                  Else do\n                     ii = index(addend,'-')\n                     addend = '-' || substr(addend,1,ii-1),\n                        || substr(addend,ii+1)\n                  End\n               End\n            End\n            If  DATATYPE(addend,\"N\")  then do\n               sum.J  = sum.J  + addend\n               Rowtot = Rowtot + addend\n            End\n         End  /* Do J = 1 to 19 by 2 */\n      End\n   End  /* Do I = LineBgn to LineEnd by 1 */\n\n   sumtot = 0;\n   \"(LASTLN) = LINENUM .zlast\"\n   If lastln \\= LineEnd then LineEnd = LineEnd + 1\n   Tallies = 1\n   Do J=1 to 17 by  2\n      jp1 = J + 1\n      If tok.J <> \"\" then do\n         Tallies = Tallies + 1\n         sumtot = sumtot + sum.J\n         \"LINE_BEFORE\" LineBgn \"= NOTELINE \"\"\"||TIME('N') ,\n         \"SUM of COLS \" tok.J||\"-\"||tok.jp1||\", total is\" sum.J\"\"\"\"\n      End\n   End\n   \"LINE_BEFORE\" LineBgn \"= NOTELINE '\"||TIME('N'),\n          \"--------------- Total of SUMS is \" sumtot \"'\"\n   \"Loc \" LineBgn\n   \"Up \" Tallies\n   Exit(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"SUMCOLS - Add columns of numbers under Edit/View \"\n   SAY\n   SAY \" Format \"\n   SAY \"    SUMCOLS  1st-col 2nd-col  ( ... )  ( .A .B )        \"\n   SAY \"       At least one set of columns is mandatory. Up to  \"\n   SAY \"       10 sets may be supplied.  Either a CC/CC range   \"\n   SAY \"       may be delimited, labels may be supplied, or the \"\n   SAY \"       whole file will be processed.  The data may be   \"\n   SAY \"       staggered, have decimal places, and/or be signed.\"\n   SAY\n   SAY \" Example \"\n   SAY \"            1---5---10----5---20---                 \"\n   SAY \"              1        -1.1                         \"\n   SAY \"              3            1.1                      \"\n   SAY \"              5          2.3                        \"\n   SAY \"    Given the above data, SUMCOLS  1 5  11 20       \"\n   SAY \"    will produce                                    \"\n   SAY \"       SUM of NX COLS  1-5, total is 9              \"\n   SAY \"       SUM of NX COLS  11-20, total is 2.3          \"\n   SAY \"       --------------- Total of SUMS is  11.3       \"\n   SAY\n   Exit(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYSI": {"ttr": 37386, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xa3\\x00\\xa3\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 163, "newlines": 163, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- DISPLAY GENERAL SYSTEM INFORMATION  **/\nCVT    = STORAGE(10,4)                         /* LOAD A(CVT)        */\nDCVT   = C2D(CVT)                              /* CONVERT TO DECIMAL */\nPCCA   = STORAGE(208,4)                        /* LOAD A(PSAPCCAV)   */\nDPCCA  = C2D(PCCA)                             /* CONVERT TO DECIMAL */\nCVTPFX = DCVT - X2D(100)                       /* ADDR CVTFIX        */\nCPUDATA= STORAGE(C2X(D2C(DPCCA+X2D(04))),12)   /* XTRACT CPU DATA    */\nCPUVER = SUBSTR(CPUDATA,1,2)                   /* FORMAT CPU VERSION */\nCPUSER = 0 || SUBSTR(CPUDATA,4,5)              /* FORMAT CPU SERIAL  */\nCPUTYPE= SUBSTR(CPUDATA,9,4)                   /* FORMAT CPU MODEL   */\nSYSAD  = STORAGE(C2X(D2C(DCVT+X2D(30))),4)     /* LOAD A(CVTSYSAD)   */\nDSYSAD = C2D(SYSAD)                            /* CONVERT TO DECIMAL */\nICPID  = STORAGE(C2X(D2C(DCVT+X2D(5E))),2)     /* ADDR IPLED CPU ID  */\nCVTOPTB= STORAGE(C2X(D2C(DCVT+X2D(7B))),1)     /* ADDR CVTOPTB FLAG  */\nSMCA   = STORAGE(C2X(D2C(DCVT+X2D(C5))),3)     /* LOAD A(SMCA)       */\nDSMCA  = C2D(SMCA)                             /* CONVERT TO DECIMAL */\nGTFST  = STORAGE(C2X(D2C(DCVT+X2D(EC))),1)     /* ADDR GTF STATUS    */\nJESCT  = STORAGE(C2X(D2C(DCVT+X2D(128))),4)    /* ADDR JESCT FROM CVT*/\nDJESCT = C2D(JESCT)                            /* CONVERT TO DECIMAL */\nXTNT2  = STORAGE(C2X(D2C(DCVT+X2D(148))),4)    /* LOAD A(CVTEXT2A)   */\nDXTNT2 = C2D(XTNT2)                            /* CONVERT TO DECIMAL */\nASVT   = STORAGE(C2X(D2C(DCVT+X2D(22C))),4)    /* LOAD A(CVTASVT)    */\nDASVT  = C2D(ASVT)                             /* CONVERT TO DECIMAL */\nGDA    = STORAGE(C2X(D2C(DCVT+X2D(230))),4)    /* LOAD A(CVTGDA)     */\nDGDA   = C2D(GDA)                              /* CONVERT TO DECIMAL */\nCSD    = STORAGE(C2X(D2C(DCVT+X2D(294))),4)    /* LOAD A(CVTCSD)     */\nDCSD   = C2D(CSD)                              /* CONVERT TO DECIMAL */\nASMVT  = STORAGE(C2X(D2C(DCVT+X2D(2C0))),4)    /* LOAD A(CVTASMVT)   */\nDASMVT = C2D(ASMVT)                            /* CONVERT TO DECIMAL */\nMSERV  = STORAGE(C2X(D2C(DCVT+X2D(3C))),4)     /* LOAD A(CVTMSLT)    */\nDMSERV = C2D(MSERV)                            /* CONVERT TO DECIMAL */\nREAL   = STORAGE(C2X(D2C(DCVT+X2D(358))),4)    /* ADDR REAL STORAGE  */\nDREAL  = C2D(REAL)                             /* CONVERT TO DECIMAL */\nRCEP   = STORAGE(C2X(D2C(DCVT+X2D(490))),4)    /* LOAD A(CVTRCEP)    */\nDRCEP  = C2D(RCEP)                             /* CONVERT TO DECIMAL */\nDFAID  = STORAGE(C2X(D2C(DCVT+X2D(4C0))),4)    /* LOAD A(CVTDFA)     */\nDDFAID = C2D(DFAID)                            /* CONVERT TO DECIMAL */\nCPUAL  = STORAGE(C2X(D2C(DCSD+X2D(08))),1)     /* ADDR CSDCPUAL      */\nCPUOL  = STORAGE(C2X(D2C(DCSD+X2D(0A))),2)     /* ADDR CSDCPUOL      */\nDCPUOL = C2D(CPUOL)                            /* CONVERT TO DECIMAL */\nJESSCT = STORAGE(C2X(D2C(DJESCT+X2D(18))),4)   /* ADDR SSCT FROM JSCT*/\nDSSCT  = C2D(JESSCT)                           /* CONVERT TO DECIMAL */\nSSCTNAM= STORAGE(C2X(D2C(DSSCT+X2D(08))),4)    /* ADDR SSCT NAME     */\nSSCTSUE= STORAGE(C2X(D2C(DSSCT+X2D(14))),4)    /* LOAD A(SSCTSUSE)   */\nDSUSE  = C2D(SSCTSUE)                          /* CONVERT TO DECIMAL */\nJESFMID= STORAGE(C2X(D2C(DSUSE+X2D(1C))),8)    /* ADDR JES FMID      */\nPUTLVL = STORAGE(C2X(D2C(DSUSE+X2D(2A))),4)    /* ADDR SYSTEM PUT LVL*/\nNUCID  = STORAGE(C2X(D2C(DXTNT2+X2D(04))),1)   /* ADDR NUCLEUS ID    */\nIOCID  = STORAGE(C2X(D2C(DXTNT2+X2D(06))),2)   /* ADDR I/O CONFIG ID */\nNUCID  = 'IEANUC0' || NUCID                    /* APPEND WITH PREFIX */\nIPLOPT = STORAGE(C2X(D2C(DASMVT+X2D(01))),1)   /* LOAD A(ASMVT)      */\nSPREL  = STORAGE(C2X(D2C(CVTPFX+X2D(D8))),8)   /* ADDR MVS/SP RELEASE*/\nMVSREL = STORAGE(C2X(D2C(CVTPFX+X2D(FC))),4)   /* ADDR MVS RELEASE   */\nDFPREL = STORAGE(C2X(D2C(DDFAID+X2D(02))),2)   /* ADDR DFP VER/RELASE*/\nDFVT   = STORAGE(C2X(D2C(DDFAID+X2D(2C))),4)   /* LOAD A(DFADFVT)    */\nDDFVT  = C2D(DFVT)                             /* CONVERT TO DECIMAL */\nDFPFID = STORAGE(C2X(D2C(DDFVT+X2D(14))),4)    /* LOAD A(DFPFMID)    */\nDDFMID = C2D(DFPFID)                           /* CONVERT TO DECIMAL */\nDFPFMID= STORAGE(C2X(D2C(DDFMID+X2D(3F))),8)   /* ADDR DFP FMID      */\nDFPREL = SUBSTR(C2X(DFPREL),1,3)               /* FORMAT DFP RELEASE */\nDFPREL = INSERT('.',DFPREL,1)                  /* FORMAT DFP RELEASE */\nDFPREL = INSERT('.',DFPREL,3)                  /* FORMAT DFP RELEASE */\nSMPID  = STORAGE(C2X(D2C(CVTPFX+X2D(E0))),8)   /* ADDR SMP FMID      */\nSMFID  = STORAGE(C2X(D2C(DSMCA+X2D(10))),4)    /* ADDR SYSTEM SMFID  */\nIPLTME = STORAGE(C2X(D2C(DSMCA+X2D(150))),4)   /* ADDR IPL TIME FIELD*/\nIPLDTE = STORAGE(C2X(D2C(DSMCA+X2D(154))),4)   /* ADDR IPL DATE FIELD*/\nIPLDTE = INSERT('.',SUBSTR(C2X(IPLDTE),3,5),2) /* FORMAT IPL DATE    */\nIPLHH  = RIGHT(C2D(IPLTME)%100%3600,2,'0')     /* FORMAT IPL HOUR    */\nIPLMM  = RIGHT(C2D(IPLTME)%100//3600%60,2,'0') /* FORMAT IPL MINUTE  */\nIPLSS  = RIGHT(C2D(IPLTME)%100//60,2,'0')      /* FORMAT IPL SECOND  */\nIPLTME = IPLHH || ':' || IPLMM || ':' || IPLSS /* FORMAT IPL TIME    */\nRESADDR= STORAGE(C2X(D2C(DSYSAD+X2D(0D))),3)   /* ADDR SYSRES UCBADDR*/\nRESVOL = STORAGE(C2X(D2C(DSYSAD+X2D(1C))),6)   /* ADDR SYSRES VOLSER */\nREALM  = DREAL/1024 || 'M'                     /* COMP REAL STORAGE  */\nXPAND  = STORAGE(C2X(D2C(DRCEP+X2D(A0))),4)    /* ADDR IARMMRCE+A0   */\nXPAND  = C2D(XPAND)*4/1024 || 'M'              /* CONV FRAME TO MEG. */\nDDFVT  = C2D(DFVT)                             /* CONVERT TO DECIMAL */\nCSASZ  = STORAGE(C2X(D2C(DGDA+X2D(70))),4)     /* ADDR GDACSASZ      */\nECSAS  = STORAGE(C2X(D2C(DGDA+X2D(80))),4)     /* ADDR GDAECSAS      */\nDCSASZ = C2D(CSASZ)/1024 || 'K'                /* COMPUTE CSA SIZE   */\nDECSAS = C2D(ECSAS)/1024 || 'K'                /* COMPUTE CSA/E SIZE */\nSQASZ  = STORAGE(C2X(D2C(DGDA+X2D(94))),4)     /* ADDR GDASQASZ      */\nESQAS  = STORAGE(C2X(D2C(DGDA+X2D(9C))),4)     /* ADDR GDAESQAS      */\nDSQASZ = C2D(SQASZ)/1024 || 'K'                /* COMPUTE SQA SIZE   */\nDESQAS = C2D(ESQAS)/1024 || 'K'                /* COMPUTE CSA/E SIZE */\nPVTSZ  = STORAGE(C2X(D2C(DGDA+X2D(A4))),4)     /* ADDR GDAPVTSZ      */\nEPVTS  = STORAGE(C2X(D2C(DGDA+X2D(AC))),4)     /* ADDR GDAEPVTS      */\nDPVTSZ = C2D(PVTSZ)/1024/1024 || 'M'           /* COMPUTE PVT SIZE   */\nDEPVTS = C2D(SUBSTR(EPVTS,1,3))/1024/4         /* COMPUTE PVT/E SIZE */\nDEPVTS1= C2D(SUBSTR(EPVTS,4,1))/1024/4         /* COMPUTE PVT/E SIZE */\nDEPVTS = DEPVTS + DEPVTS1 || 'M'               /* COMPUTE PVT/E SIZE */\nASCBMAX= C2D(STORAGE(C2X(D2C(DASVT+516)),4))   /* FORMAT MAX USER    */\nASCBACT= 0                                     /* INIT MAX ACT ASCB  */\nDO I = 1 TO ASCBMAX                            /* SCAN ALL ASVT      */\n   ASCB  = STORAGE(C2X(D2C(DASVT+524+I*4)),4)  /* ADDR ASCB FROM ASVT*/\n   IF   ABBREV(C2X(ASCB),'80')  = 1            /* IS IT AVAILABLE?   */\n        THEN ITERATE                           /* YES,LEAVE FOR NEXT */\n   ASCBACT = ASCBACT + 1                       /* NO, COUNT IT       */\nEND                                            /* END OF SCAN        */\nIF   BITAND(CPUAL,'FC'X) = 'FC'X THEN          /* CPU 0-5 AVAILABLE? */\n     CPUAL = 'CPU 0-5'                         /* YES, SAY IT        */\nELSE IF   BITAND(CPUAL,'F8'X) = 'F8'X THEN     /* CPU 0-4 AVAILABLE? */\n          CPUAL = 'CPU 0-4'                    /* YES, SAY IT        */\nELSE IF   BITAND(CPUAL,'F0'X) = 'F0'X THEN     /* CPU 0-3 AVAILABLE? */\n          CPUAL = 'CPU 0-5'                    /* YES, SAY IT        */\nELSE IF   BITAND(CPUAL,'E0'X) = 'E0'X THEN     /* CPU 0-2 AVAILABLE? */\n          CPUAL = 'CPU 0-2'                    /* YES, SAY IT        */\nELSE IF   BITAND(CPUAL,'C0'X) = 'C0'X THEN     /* CPU 0-1 AVAILABLE? */\n          CPUAL = 'CPU 0-1'                    /* YES, SAY IT        */\nELSE IF   BITAND(CPUAL,'80'X) = '80'X THEN     /* CPU 0   AVAILABLE? */\n          CPUAL = 'CPU 0  '                    /* YES, SAY IT        */\nIF   BITAND(IPLOPT,'04'X) = '04'X THEN         /* IS IT WARM STARTED */\n     IPLOPT = 'WARM '                          /* YES, SAY IT        */\nELSE DO                                        /* ELSE CHK OTHERS    */\n        IPLOPT = 'CVIO '                       /* ASSUME CVIO START  */\n        IF   BITAND(IPLOPT,'08'X) = '08'X THEN /* IS IT QUICK START  */\n             IPLOPT = 'QUICK'                  /* YES, SAY IT        */\n        ELSE IPLOPT = 'CLPA '                  /* ELSE SAY CLPA      */\n     END                                       /* END OF IPL CHECK   */\nIF   BITAND(GTFST,'80'X) = '80'X   THEN        /* IS GTF ACTIVATED   */\n     GTFSTAT= 'ACTIVE  '                       /* YES, ACTIVE        */\nELSE GTFSTAT= 'INACTIVE'                       /* NO, INACTIVE       */\nLOGCLS = STORAGE(C2X(D2C(DMSERV+X2D(68))),1)   /* ADDR SYSLOG CLASS  */\nIF   CVTOPTB \\= '10'X THEN                     /* IS SYSLOG ACTIVE?  */\n     LOGSTAT= 'ACTIVE'                         /* YES, SAY ACTIVE    */\nELSE LOGSTAT= 'INACTIVE'                       /* NO, INACTIVE       */\nCLEAR                                          /* CLEAR SCREEN       */\nHEADER = 'SYSTEM INFORMATION'\nHEADER = CENTER(HEADER,79)\nSAY HEADER\nLINE = ' CPU TYPE:' CPUTYPE\nSAY  CENTER(LINE,79)\nSAY  CENTER(LEFT('*',73,'*'),79)\nICPID= SUBSTR(C2X(ICPID),3,2)\nCALL FPRINT('IPL DATE' IPLDTE,\n            'IPL TIME' IPLTME)\nCALL FPRINT('CPU ON-LINE' DCPUOL,\n            'CPU AVAILABLE' CPUAL)\nCALL FPRINT('REAL STORAGE' REALM,\n            'EXPANDED STORAGE' XPAND)\nMVS    = MVSVAR(\"SYSOPSYS\")\nMVS    = SUBWORD(MVS,1,2)\nCALL FPRINT('MVS/SYS' MVS,\n            'MVS/SP REL' SPREL)\nLPARID = MVSVAR(\"SYSNAME\")\nCALL FPRINT('PRIMARY JES' SSCTNAM,\n            'LPAR ID' LPARID)\n'ISPEXEC VGET (ZLOGON) SHARED'\n'ISPEXEC VGET (ZSCRMAX) SHARED'\nCALL FPRINT('logon proc' zlogon,\n            'max scrns' zscrmax)\nSAY  CENTER(LEFT('*',73,'*'),79)\nRETURN(0)\n\n/*     COMMON ROUTINE TO DO THE OUTPUT FORMATING & PRINTING         */\nFPRINT:\nARG DATA\nLINE = LEFT('*' LEFT(SUBWORD(DATA,1,2),15) ||,\n            '|' SUBWORD(DATA,3,1),36) ||,\n       LEFT('*' LEFT(SUBWORD(DATA,4,2),15) ||,\n            '|' SUBWORD(DATA,6),36)\nSAY  CENTER(LINE || '*',79)\nRETURN(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TD": {"ttr": 37390, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00|\\x00|\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 124, "newlines": 124, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- Display and delete PDS Member's statistics             **/\n/*********************************************************************/\n   ARG PARMS\n   Do ii = 2 to length(PARMS) while(substr(PARMS,ii,1) <> '(')\n   End ii\n   jj  = length(PARMS) - 2\n   PDS = substr(PARMS,2,ii-2)\n   MEM = substr(PARMS,ii+1,length(PARMS)-ii-2)\n   Call setup_libdefs\n   quit = 'NO'\n   Call get_stats\n   Call display_panel\n   If quit <> 'YES' then do\n      Call update_stats\n      Address ispexec 'SETMSG MSG(MSGN001)'\n   End\n   Else do\n      Address ispexec\n      \"LMCLOSE   DATAID(&TTID)\"\n      \"LMFREE    DATAID(&TTID)\"\n      Address ispexec 'SETMSG MSG(MSGN003)'\n   End\n   Call destroy_libdefs\n   Return 1\n/******************* setup_libdefs ********************************/\nsetup_libdefs: Procedure Expose ddname\n\n   ddname = '$'right(time(s),7,'0')\n   Address tso 'ALLOC NEW DEL F('ddname') DIR(1) SP(1) TR RECF(F B)\n                BLKS(0) LRECL(80) REU UNIT(SYSDA)'\n   Address ispexec\n   'LMINIT DATAID(DID) DDNAME('ddname') ENQ(EXCLU)'\n   'LMOPEN DATAID(&DID) OPTION(OUTPUT)'\n   a=1\n   Do 2\n     Do a=a to 999 Until substr(line,1,8)='/*MEMBER'\n       line = sourceline(a)\n     End\n     Parse Var line . memname .\n     Do a=a+1 to 999 While substr(line,1,2) \\= '*/'\n       line = sourceline(a)\n       'LMPUT DATAID(&DID) MODE(INVAR) DATALOC(LINE) DATALEN(80)'\n     End\n     'LMMADD DATAID(&DID) MEMBER(&MEMNAME)'\n   End\n   'LMFREE DATAID(&DID)'\n   'LIBDEF ISPPLIB LIBRARY ID('ddname') STACK'\n   'LIBDEF ISPMLIB LIBRARY ID('ddname') STACK'\n   Return\n/********************* get_stats **********************************/\nget_stats:\n   Address ispexec\n   \"LMINIT  DATAID(TTID) DATASET('\"PDS\"') ENQ(SHRW)\"\n   \"LMOPEN  DATAID(&TTID) OPTION(INPUT)\"\n   \"LMMFIND DATAID(&TTID) MEMBER(\"MEM\") STATS(YES)\"\n   VV      = ZLVERS\n   CREDATE = ZLCDATE\n   CHGDATE = ZLMDATE\n   CHGTM   = ZLMTIME\n   INISZ   = ZLINORC\n   CURSZ   = ZLCNORC\n   MD      = ZLMOD\n   USERID  = ZLUSER\n   Return\n/********************* update_stats **********************************/\nupdate_stats:\n   Address ispexec\n   \"LMMSTATS  DATAID(&TTID) MEMBER(\"MEM\") DELETE\"\n   \"LMCLOSE   DATAID(&TTID)\"\n   \"LMFREE    DATAID(&TTID)\"\n   Return\n/********************* DISPLAY PANEL ******************************/\ndisplay_panel:\n   Address ispexec\n   'ADDPOP'\n   'DISPLAY PANEL(POPUP)'\n   If rc = 8 then quit = 'YES'\n   'REMPOP'\n   Return\n/********************* DESTROY_LIBDEFS ***************************/\ndestroy_libdefs:\n   Address ispexec 'LIBDEF ISPPLIB '\n   Address ispexec 'LIBDEF ISPMLIB '\n   Address tso 'FREE F('ddname')'\n   Return\n\n/*------------------------------------------------------------------*/\n/* In-line panels and messages are defined below                    */\n/*------------------------------------------------------------------*/\n/*MEMBER POPUP  This panel prompts for XREF input\n)ATTR DEFAULT(%+_)\n     % TYPE(TEXT)  INTENS (HIGH)\n     + TYPE(TEXT)  INTENS (LOW)  SKIP(ON)\n     _ TYPE(INPUT) INTENS (HIGH) CAPS(ON) JUST(LEFT)\n     $ TYPE(INPUT) INTENS (HIGH) CAPS(ON) JUST(LEFT)\n     @ TYPE(TEXT)  INTENS (HIGH) COLOR(TURQ)\n     ! TYPE(TEXT)  INTENS (LOW)  CAPS(ON)\n)BODY WINDOW(60,16)\n@  -- PDS Statistics Display/Delete                   -- +\n\n%PDS:+$PDS                                          +\n%MEM:+$MEM     +\n\n%Version:   +$VV+\n%Mod Count: +$MD+\n%Create Dt: +$CREDATE +\n%Change Dt: +$CHGDATE +\n%Change Tm: +$CHGTM +\n%Initial Sz:+$INISZ+\n%Current Sz:+$CURSZ+\n%UserID:    +$USERID +\n\n@  -- Press <ENTER> to delete or <PF3> (END) to Quit  -- +\n)INIT\n   .CURSOR  = VV\n)PROC\n)END\n*/\n/*MEMBER MSGN00  This is a message member. Can be in same lib as panel.\nMSGN001 'Processed &MEM member...'\n'Data set produced is &PDS for member &MEM...'\nMSGN003 'No changes made...'\n'Terminated with no changes entered...'\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TERSE$": {"ttr": 37634, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x12\\x00\\x12\\x00\\x00\\xc9\\xc2\\xd4\\xe3\\xc5\\xd9\\xe2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "IBMTERS"}, "text": "//-YOUR-USERID-T JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  COMPRESS ONE FILE INTO ANOTHER\n//***\n//CLEANUP    EXEC     PGM=IEFBR14\n//DEL01        DD       DSN=...,\n//             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\n//***\n//TERSE      EXEC     PGM=TRSMAIN,REGION=4M,PARM='SPACK'\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//INFILE       DD       DISP=SHR,DCB=BUFNO=32,\n//             DSN=...\n//OUTFILE      DD       DISP=(NEW,CATLG),DCB=BUFNO=32,\n//             UNIT=SYSDA,SPACE=(CYL,(010,010),RLSE),\n//             DSN=...\n//SYSPRINT     DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TODAY": {"ttr": 37636, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x03'\\x1f\\x01\\x03'\\x1f\\x12\\x00\\x00S\\x00S\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-09-28T00:00:00", "modifydate": "2003-09-28T12:00:00", "lines": 83, "newlines": 83, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- Show Today's Date  **/\n   ARG PARMS\n   IF SUBSTR(PARMS,1,1) = '?' THEN SIGNAL DISPDOC\n\n   IF PARMS = '' THEN DO\n      DD = SUBSTR(DATE(U),4,2)\n      IF SUBSTR(DD,2,1) = '1'         THEN XX = 'st'\n         ELSE IF SUBSTR(DD,2,1) = '2' THEN XX = 'nd'\n         ELSE IF SUBSTR(DD,2,1) = '3' THEN XX = 'rd'\n         ELSE XX = 'th'\n      IF SUBSTR(DD,1,1) = '0'         THEN DD = SUBSTR(DD,2)\n      LILIAN = DATE('B') - 577734\n      $LILIAN = \"\"\n      DO JJ = 3 TO 21 BY 3 WHILE JJ < LENGTH(LILIAN)\n         $LILIAN = \",\" || SUBSTR(LILIAN,LENGTH(LILIAN)-JJ+1,3),\n            || $LILIAN\n      END\n      $LILIAN = SUBSTR(LILIAN,1,LENGTH(LILIAN)+3-JJ) || $LILIAN\n      SAY DATE(W) DATE(M) DD||XX',' SUBSTR(DATE(S),1,4),\n         '(day' SUBSTR(DATE(J),3,3)') Lillian('$LILIAN')'\n      Exit(0)\n   END\n   IF LENGTH(PARMS) < 7 | LENGTH(PARMS) > 8 THEN SIGNAL DISPDOC\n   IF \u00acDATATYPE(PARMS,'W') THEN SIGNAL DISPDOC\n   IF LENGTH(PARMS) = 7 THEN DO\n      SPARMS = DATE(S,SUBSTR(PARMS,3),J)\n      IF SUBSTR(SPARMS,8,1) = '1'         THEN XX = 'st'\n         ELSE IF SUBSTR(SPARMS,8,1) = '2' THEN XX = 'nd'\n         ELSE IF SUBSTR(SPARMS,8,1) = '3' THEN XX = 'rd'\n         ELSE XX = 'th'\n      DD = SUBSTR(SPARMS,7,2)\n      IF SUBSTR(DD,1,1) = '0'             THEN DD = SUBSTR(DD,2)\n      LL = DD' 'SUBSTR(DATE(M,SPARMS,S),1,3)' 'SUBSTR(PARMS,1,4)\n      LILIAN = DATE('B',LL) - 577734\n      $LILIAN = \"\"\n      DO JJ = 3 TO 21 BY 3 WHILE JJ < LENGTH(LILIAN)\n         $LILIAN = \",\" || SUBSTR(LILIAN,LENGTH(LILIAN)-JJ+1,3),\n            || $LILIAN\n      END\n      $LILIAN = SUBSTR(LILIAN,1,LENGTH(LILIAN)+3-JJ) || $LILIAN\n      SAY DATE(W,SPARMS,S) DATE(M,SPARMS,S) DD||XX',',\n         SUBSTR(PARMS,1,4) '(day' SUBSTR(PARMS,5,3)')',\n         ' Lillian('$LILIAN')'\n   END\n   ELSE DO\n      IF SUBSTR(PARMS,8,1) = '1'         THEN XX = 'st'\n         ELSE IF SUBSTR(PARMS,8,1) = '2' THEN XX = 'nd'\n         ELSE IF SUBSTR(PARMS,8,1) = '3' THEN XX = 'rd'\n         ELSE XX = 'th'\n      DD = SUBSTR(PARMS,7,2)\n      IF SUBSTR(DD,1,1) = '0'            THEN DD = SUBSTR(DD,2)\n      LL = DD' 'SUBSTR(DATE(M,PARMS,S),1,3)' 'SUBSTR(PARMS,1,4)\n      LILIAN = DATE('B',LL) - 577734\n      $LILIAN = \"\"\n      DO JJ = 3 TO 21 BY 3 WHILE JJ < LENGTH(LILIAN)\n         $LILIAN = \",\" || SUBSTR(LILIAN,LENGTH(LILIAN)-JJ+1,3),\n            || $LILIAN\n      END\n      $LILIAN = SUBSTR(LILIAN,1,LENGTH(LILIAN)+3-JJ) || $LILIAN\n      SAY DATE(W,PARMS,S) DATE(M,PARMS,S) DD||XX',',\n         SUBSTR(PARMS,1,4) '(day' RIGHT(DATE(D,PARMS,S),3,'0')')',\n         ' Lillian('$LILIAN')'\n   END\n   Exit(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"TODAY -- Display variations of a date                \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"   TODAY  ( CCYYMMDD | CCYYDDD )                     \"\n   SAY\n   SAY \"       WILL DISPLAY THE FOLLOWING FOR A DATE         \"\n   SAY\n   SAY \"            Wednesday March 28th, 2001 (day 087)     \"\n   SAY \"                                 Lillian(152837)     \"\n   SAY\n   SAY \"       IF A DATE IN THE FORMAT OF CCYYMMDD (LIKE     \"\n   SAY \"       20011231) OR OF CCYYDDD (LIKE 1999365) IS     \"\n   SAY \"       NOT SPECIFIED, TODAY'S DATE WILL BE USED.     \"\n   SAY\n   Exit(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TOUCH": {"ttr": 37639, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x01\\xd2\\x01\\xd2\\x00\\x00\\xe3\\xd6\\xe4\\xc3\\xc8@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 466, "newlines": 466, "modlines": 0, "user": "TOUCH"}, "text": "//-YOUR-USERID-T JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  COMPILE FOR TOUCH WHICH RETRIEVES AND REPLACES A SPECIFIC\n//***  DIRECTORY ENTRY'S STATISTICS. USES BLDLR AND STOWR.\n//***\n//C          EXEC     PGM=IEL0AA,REGION=4M,COND=(5,LT),\n//             PARM=('AG,A,NCT,ESD,F(I),NOFLOW,NIS,NOLIST,M,NMI,NEST',\n//             'MAP,OF,OPT(TIME),OP,SZ(MAX),S,STMT,STG,X(F)')\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-PLI-LIB-\n\n TOUCH: PROC OPTIONS(MAIN) REORDER;\n\n        DCL  SYSIN_EOF               CHAR(01) STATIC INIT('N');\n        DCL  (ADDR, DATE, SUBSTR, TIME)\n                                     BUILTIN;\n\n        DCL  DSNAME                  CHAR(44)       STATIC;\n        DCL  DDNAME                  CHAR(08)       STATIC;\n        DCL  MEMBER                  CHAR(08)       STATIC;\n        DCL  ALIAS                   CHAR(01)       STATIC;\n        DCL  VERSIONNUMBER           PIC'999'       STATIC;\n        DCL  MAINTNUMBER             PIC'999'       STATIC;\n        DCL  CREATEDATE              PIC'99999999'  STATIC;\n        DCL  TODAYDATE               PIC'99999999'  STATIC;\n        DCL  CHANGEDATE              PIC'99999999'  STATIC;\n        DCL  CHANGETIME              PIC'99999'     STATIC;\n        DCL  CURRENTSIZE             PIC'999999'    STATIC;\n        DCL  INITIALSIZE             PIC'999999'    STATIC;\n        DCL  MODCOUNT                PIC'999999'    STATIC;\n        DCL  USERID                  CHAR(07)       STATIC;\n\n        DCL  01  CCYYMMDD                           STATIC,\n                05  CCYY             PIC'9999',\n                05  MM               PIC'99',\n                05  DD               PIC'99';\n        DCL  MMDD_TO_DDD_LEAP(12)    PIC'999'       STATIC\n                                     INIT( 000, 031, 060,\n                                           091, 121, 152,\n                                           182, 213, 244,\n                                           274, 305, 335 );\n        DCL  MMDD_TO_DDD(12)         PIC'999'       STATIC\n                                     INIT( 000, 031, 059,\n                                           090, 120, 151,\n                                           181, 212, 243,\n                                           273, 304, 334 );\n\n        DCL      DIR_DATA    CHAR(80) STATIC;\n        DCL  01  DIRDATA     BASED(DIRDATA_PTR),\n                05  MEMBER_NAME         CHAR(08),\n                05  TT_R                CHAR(03),\n                05  ALIAS_#TTRN_#HW     BIT(08),\n                05  VERSION_NUMBER      CHAR(01),\n                05  MAINTENANCE_NUMBER  CHAR(01),\n                05  FILL_10             CHAR(01),\n                05  FILL_20             CHAR(01),\n                05  CREATE_DATE         CHAR(04),\n                05  CHANGE_DATE         CHAR(04),\n                05  CHANGE_TIME         CHAR(02),\n                05  CURRENT_SIZE        CHAR(02),\n                05  INITIAL_SIZE        CHAR(02),\n                05  MODIFICATION_COUNT  FIXED BIN(15),\n                05  USER_ID             CHAR(07),\n                05  FILL_99             CHAR(41);\n        DCL  DIRDATA_PTR                PTR;\n        DIRDATA_PTR = ADDR(DIR_DATA);\n\n        DCL  FW_SIZE                 FIXED BIN(31)  STATIC;\n        DCL  01 CH_OVLY_FW_SIZE BASED(ADDR(FW_SIZE)),\n                 05  CH_DUMMY        CHAR(02),\n                 05  CH_SIZE         CHAR(02);\n        DCL  PACKED7                 FIXED DEC(07) STATIC;\n        DCL  TODAY                   CHAR(08) STATIC;\n        DCL  HEX04OVLY               BIT(32) BASED(PACKED7_PTR);\n        DCL  CHAR04OVLY              CHAR(04) BASED(PACKED7_PTR);\n        DCL  HEX0000000F             BIT(32) STATIC\n             INIT('00000000000000000000000000001111'B);\n        DCL  PACKED7_PTR             PTR;\n        PACKED7_PTR = ADDR(PACKED7);\n\n        DECLARE BLDLR  ENTRY(CHAR(44),      /* DSNAME            */\n                             CHAR(8),       /* MEMBER            */\n                             CHAR(8),       /* DDNAME            */\n                             FIXED BIN(15), /* DYNALLOC R15 R/C  */\n                             FIXED BIN(15), /* INFO  ERROR  CODE */\n                             FIXED BIN(15), /* INFO  REASON CODE */\n                             CHAR(80)     ) /* RET'D DIRECTORY   */\n                       OPTIONS(ASM);\n\n        DECLARE STOWR  ENTRY(CHAR(44),      /* DSNAME            */\n                             CHAR(8),       /* MEMBER            */\n                             CHAR(8),       /* DDNAME            */\n                             FIXED BIN(15), /* DYNALLOC R15 R/C  */\n                             FIXED BIN(15), /* INFO  ERROR  CODE */\n                             FIXED BIN(15), /* INFO  REASON CODE */\n                             CHAR(80)     ) /* DIRECTORY UPDATE  */\n                       OPTIONS(ASM);\n\n        DCL  HWBIN     FIXED BIN(15) STATIC INIT(0);\n        DCL  CHBIN     CHAR(02) BASED(HWBIN_PTR);\n        DCL  HWBIN_PTR PTR;\n        HWBIN_PTR = ADDR(HWBIN);\n\n        DCL  THREEPACKED\n                       FIXED DECIMAL(5) STATIC;\n        DCL  TWOHEX    CHAR(02) BASED(THREEPACKED_PTR);\n        DCL  NOW       CHAR(04) STATIC;\n        DCL  NOWNUM    PIC'9999' BASED(ADDR(NOW));\n        DCL  THREEPACKED_PTR    PTR;\n        THREEPACKED_PTR = ADDR(THREEPACKED);\n\n        DCL  R15       FIXED BIN(15) STATIC INIT(0);\n        DCL  RC        FIXED BIN(15) STATIC INIT(0);\n        DCL  WHY       FIXED BIN(15) STATIC INIT(0);\n\n     ON ENDFILE(SYSIN) SYSIN_EOF = 'Y';\n\n     DSNAME         = HIGH(44);\n     DDNAME         = ' ';\n     MEMBER         = HIGH(08);\n     ALIAS          = HIGH(01);\n     VERSIONNUMBER  = 999;\n     MAINTNUMBER    = 999;\n     CREATEDATE     = 99999999;\n     CHANGEDATE     = 99999999;\n     CHANGETIME     = 99999;\n     CURRENTSIZE    = 999999;\n     INITIALSIZE    = 999999;\n     MODCOUNT       = 999999;\n     USERID         = HIGH(07);\n\n     GET DATA FILE(SYSIN) COPY(SYSPRINT);\n\n     DO WHILE ( SYSIN_EOF = 'N' );\n\n        IF DSNAME = HIGH(44)\n           THEN DO;\n              PUT EDIT ('**  ERROR  **  ',\n                        'NO SUPPLIED ''DSNAME'' VALUE')\n                       (SKIP(1),A,A);\n              CALL PLIRETC(16);\n              RETURN;\n              END;\n\n        IF MEMBER = HIGH(08)\n           THEN DO;\n              PUT EDIT ('**  ERROR  **  ',\n                        'NO SUPPLIED ''MEMBER'' VALUE')\n                       (SKIP(1),A,A);\n              CALL PLIRETC(20);\n              RETURN;\n              END;\n\n        CALL BLDLR(DSNAME,MEMBER,DDNAME,\n           R15,RC,WHY,DIR_DATA);\n\n        IF R15 \u00ac= 0\n           THEN DO;\n              PUT EDIT ('**  ERROR  **  ',\n                        'BLDL ERROR = ',    R15,\n                        ', REASON CODE = ', RC,\n                        ', OTHER CODE = ',  WHY)\n                       (SKIP(1),A,A,P'9999',A,P'-ZZ,ZZ9',\n                        A,P'-ZZ,ZZ9');\n              PUT EDIT ('               ',\n                        'DSNAME = ', DSNAME)\n                       (SKIP(1),A,A,A);\n              PUT EDIT ('               ',\n                        'MEMBER = ', MEMBER)\n                       (SKIP(1),A,A,A);\n              CALL PLIRETC(24);\n              RETURN;\n              END;\n\n        IF ( ALIAS_#TTRN_#HW & '00011111'B ) < '00001111'B\n           THEN DO;\n              ALIAS_#TTRN_#HW\n                 = ( ALIAS_#TTRN_#HW & '11100000'B ) | '00001111'B;\n              VERSION_NUMBER     = 001;\n              MAINTENANCE_NUMBER = 001;\n              TODAY              = '  ' || DATE;\n              IF SUBSTR(TODAY,3,2) < '50'\n                 THEN SUBSTR(TODAY,1,2) = '20';\n                 ELSE SUBSTR(TODAY,1,2) = '19';\n              STRING(CCYYMMDD) = TODAY;\n              IF MOD(CCYY,4) = 0\n                 THEN TODAYDATE = ( CCYY * 1000 )\n                       + MMDD_TO_DDD_LEAP(MM) + DD;\n                 ELSE TODAYDATE = ( CCYY * 1000 )\n                       + MMDD_TO_DDD(MM) + DD;\n              PACKED7            = TODAYDATE - 1900000;\n              HEX04OVLY          = HEX04OVLY | HEX0000000F;\n              CREATE_DATE        = CHAR04OVLY;\n              CHANGE_DATE        = CHAR04OVLY;\n              NOW                = SUBSTR(TIME,1,4);\n              THREEPACKED        = NOWNUM * 10;\n              CHANGE_TIME        = TWOHEX;\n              FILL_20            = LOW(1);\n              FW_SIZE            = 65535;\n              CURRENT_SIZE       = CH_SIZE;\n              INITIAL_SIZE       = CH_SIZE;\n              MODIFICATION_COUNT = 0;\n              USER_ID            = 'DEFAULT';\n              END;\n\n        IF ALIAS \u00ac= HIGH(01)\n           THEN DO;\n              IF ALIAS = 'Y'\n                 THEN DO;\n                    ALIAS_#TTRN_#HW = ALIAS_#TTRN_#HW | '10000000'B;\n                    END;\n                 ELSE DO;\n                    IF ALIAS = 'N'\n                       THEN DO;\n                          ALIAS_#TTRN_#HW = ALIAS_#TTRN_#HW\n                             & '01111111'B;\n                          END;\n                       ELSE DO;\n                          R15 = 60;\n                          PUT EDIT ('**  ERROR  **  ',\n                                    'ALIAS MUST BE ''Y'' OR ''N'' - ',\n                                    ALIAS)\n                                   (SKIP(1),A,A,A);\n                          END;\n                    END;\n              END;\n\n        IF VERSIONNUMBER \u00ac= 999\n           THEN DO;\n              IF VERSIONNUMBER < 100\n                 THEN DO;\n                    HWBIN = VERSIONNUMBER;\n                    VERSION_NUMBER = SUBSTR(CHBIN,2,1);\n                    END;\n                 ELSE DO;\n                    R15 = 64;\n                    PUT EDIT ('**  ERROR  **  ',\n                              'VERSION NUMBER MUST BE < 100 - ',\n                              VERSIONNUMBER)\n                             (SKIP(1),A,A,P'999');\n                    END;\n              END;\n\n        IF MAINTNUMBER \u00ac= 999\n           THEN DO;\n              IF MAINTNUMBER < 100\n                 THEN DO;\n                    HWBIN = MAINTNUMBER;\n                    MAINTENANCE_NUMBER = SUBSTR(CHBIN,2,1);\n                    END;\n                 ELSE DO;\n                    R15 = 68;\n                    PUT EDIT ('**  ERROR  **  ',\n                              'MAINTENANCE NUMBER MUST BE < 100 - ',\n                              MAINTNUMBER)\n                             (SKIP(1),A,A,P'999');\n                    END;\n              END;\n\n        IF CREATEDATE \u00ac= 99999999\n           THEN DO;\n              IF CREATEDATE > 9999999\n                 THEN DO;\n                    STRING(CCYYMMDD) = CREATEDATE;\n                    IF MOD(CCYY,4) = 0\n                       THEN DO;\n                          CREATEDATE = ( CCYY * 1000 )\n                             + MMDD_TO_DDD_LEAP(MM)\n                             + DD;\n                          END;\n                       ELSE DO;\n                          CREATEDATE = ( CCYY * 1000 )\n                             + MMDD_TO_DDD(MM)\n                             + DD;\n                          END;\n                    END;\n              IF CREATEDATE > 1900000\n                 THEN DO;\n                    PACKED7     = CREATEDATE - 1900000;\n                    HEX04OVLY   = HEX04OVLY | HEX0000000F;\n                    CREATE_DATE = CHAR04OVLY;\n                    END;\n                 ELSE DO;\n                    R15 = 72;\n                    PUT EDIT ('**  ERROR  **  ',\n                              'CREATE DATE SHOULD BE CCYYDDD OR ',\n                              'CCYYMMDD - ',\n                              CREATEDATE)\n                             ( SKIP(1), A, A, A, P'99999999' );\n                    END;\n              END;\n\n        IF CHANGEDATE \u00ac= 99999999\n           THEN DO;\n              IF CHANGEDATE > 9999999\n                 THEN DO;\n                    STRING(CCYYMMDD) = CHANGEDATE;\n                    IF MOD(CCYY,4) = 0\n                       THEN DO;\n                          CHANGEDATE = ( CCYY * 1000 )\n                             + MMDD_TO_DDD_LEAP(MM)\n                             + DD;\n                          END;\n                       ELSE DO;\n                          CHANGEDATE = ( CCYY * 1000 )\n                             + MMDD_TO_DDD(MM)\n                             + DD;\n                          END;\n                    END;\n              IF CHANGEDATE > 1900000\n                 THEN DO;\n                    PACKED7     = CHANGEDATE - 1900000;\n                    HEX04OVLY   = HEX04OVLY | HEX0000000F;\n                    CHANGE_DATE = CHAR04OVLY;\n                    END;\n                 ELSE DO;\n                    R15 = 76;\n                 PUT EDIT ('**  ERROR  **  ',\n                           'CHANGE DATE SHOULD BE CCYYDDD OR ',\n                           'CCYYMMDD - ',\n                           CHANGEDATE)\n                          ( SKIP(1), A, A, A, P'99999999' );\n                    END;\n            END;\n\n        IF CHANGETIME \u00ac= 99999\n           THEN DO;\n              IF CHANGETIME < 2400\n                 THEN DO;\n                    THREEPACKED = CHANGETIME * 10;\n                    CHANGE_TIME = TWOHEX;\n                    FILL_20     = LOW(1);\n                    END;\n                 ELSE DO;\n                    R15 = 80;\n                    PUT EDIT ('**  ERROR  **  ',\n                              'CHANGE TIME SHOULD BE HHMM ',\n                              '(FROM 00:00 TO 23:59) - ',\n                              CHANGETIME)\n                             (SKIP(1),A,A,A,P'99999');\n                    END;\n              END;\n\n        IF CURRENTSIZE \u00ac= 999999\n           THEN DO;\n              IF CURRENTSIZE <= 65535 & CURRENTSIZE > 0\n                 THEN DO;\n                    FW_SIZE      = CURRENTSIZE;\n                    CURRENT_SIZE = CH_SIZE;\n                    END;\n                 ELSE DO;\n                    R15 = 84;\n                    PUT EDIT ('**  ERROR  **  ',\n                              'CURRENT SIZE MUST BE > 0 AND < 65535 - ',\n                              CURRENTSIZE)\n                             (SKIP(1),A,A,P'999999');\n                    END;\n              END;\n\n        IF INITIALSIZE \u00ac= 999999\n           THEN DO;\n              IF INITIALSIZE <= 65535 & INITIALSIZE > 0\n                 THEN DO;\n                    FW_SIZE      = INITIALSIZE;\n                    INITIAL_SIZE = CH_SIZE;\n                    END;\n                 ELSE DO;\n                    R15 = 88;\n                    PUT EDIT ('**  ERROR  **  ',\n                              'INITIAL SIZE MUST BE > 0 AND < 65535 - ',\n                              INITIALSIZE)\n                             (SKIP(1),A,A,P'999999');\n                    END;\n              END;\n\n        IF MODCOUNT \u00ac= 999999\n           THEN DO;\n              IF MODCOUNT < 32768\n                 THEN DO;\n                    MODIFICATION_COUNT = MODCOUNT;\n                    END;\n                 ELSE DO;\n                    R15 = 92;\n                    PUT EDIT ('**  ERROR  **  ',\n                              'MODIFICATION COUNT MUST BE < 32768 - ',\n                              MODCOUNT)\n                             (SKIP(1),A,A,P'999999');\n                    END;\n              END;\n\n        IF USERID \u00ac= HIGH(07)\n           THEN DO;\n              USER_ID = USERID;\n              END;\n\n        IF R15 \u00ac= 0\n           THEN DO;\n              PUT EDIT ('*************  ',\n                        'PROGRAM DISCONTINUED BECAUSE OF INPUT ERRORS')\n                       (SKIP(1),A);\n              CALL PLIRETC(96);\n              RETURN;\n              END;\n\n        CALL STOWR(DSNAME,MEMBER,DDNAME,\n           R15,RC,WHY,DIR_DATA);\n\n        IF R15 \u00ac= 0\n           THEN DO;\n              PUT EDIT ('**  ERROR  **  ',\n                        'STOW ERROR = ',    R15,\n                        ', REASON CODE = ', RC,\n                        ', OTHER CODE = ',  WHY)\n                       (SKIP(1),A,A,P'99999',A,P'-ZZ,ZZ9',\n                        A,P'-ZZ,ZZ9');\n              PUT EDIT ('               ',\n                        'DSNAME = ', DSNAME)\n                       (SKIP(1),A,A,A);\n              PUT EDIT ('               ',\n                        'MEMBER = ', MEMBER)\n                       (SKIP(1),A,A,A);\n              CALL PLIRETC(28);\n              RETURN;\n              END;\n\n        DSNAME         = HIGH(44);\n        DDNAME         = ' ';\n        MEMBER         = HIGH(08);\n        ALIAS          = HIGH(01);\n        VERSIONNUMBER  = 999;\n        MAINTNUMBER    = 999;\n        CREATEDATE     = 99999999;\n        CHANGEDATE     = 99999999;\n        CHANGETIME     = 99999;\n        CURRENTSIZE    = 999999;\n        INITIALSIZE    = 999999;\n        MODCOUNT       = 999999;\n        USERID         = HIGH(07);\n\n        GET DATA FILE(SYSIN) COPY(SYSPRINT);\n\n        END;        /**  END OF DO WHILE ( SYSIN_EOF = 'N' )  **/\n\n     END TOUCH;\n\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(CYL,(05,02))\n//***\n//L          EXEC     PGM=HEWLKED,COND=(5,LT),\n//             PARM='XREF,LIST,LET,DCBS',\n//             REGION=4M\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//             DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   99102600\n  ENTRY    PLISTART\n  NAME     TOUCH(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TOUCH$": {"ttr": 37647, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x17\\x00\\x17\\x00\\x00\\xe3\\xd6\\xe4\\xc3\\xc8@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "TOUCH"}, "text": "//-YOUR-USERID-T JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//*** CHANGE STATS FOR A MEMBER\n//***\n//GO         EXEC     PGM=TOUCH,\n//             REGION=4M\n//SYSIN        DD       *\n  DSNAME = '............................................',\n  MEMBER = '........',\n     ALIAS         = 'N',\n     VERSIONNUMBER = 01,\n     MAINTNUMBER   = 01,\n     CREATEDATE    = 20010101,\n     CHANGEDATE    = 20010101,\n     CHANGETIME    = 1234,\n     INITIALSIZE   = 12345,\n     CURRENTSIZE   = 12345,\n     MODCOUNT      = 0,\n     USERID        = 'COOLGUY';\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSPRINT     DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TRAP": {"ttr": 37890, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x18\\x00\\x18\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- accept any TSO command (including clists and other  **/\n/*           Rexx procedures)that output to the terminal and      */\n/*           trap and display the captured results using View     */\n/* Syntax:    %TRAP tso-command options                           */\n/* -------------------------------------------------------------- */\nx = msg(\"off\")\narg command\nif length(command) = 0 then do\n   say \"Error:  Use of TRAP requires the specification of\"\n   say \"        a TSO command whose results will be captured\"\n   say \"        and displayed using ISPF Browse.\"\n   say \"        (e.g.  %TRAP LISTC)\"\n   exit 12\n   end\nx = outtrap(\"trap.\",\"*\")\ncommand\nx= outtrap(\"off\")\ndd = \"TP\"random()\nda = \"DA\"random()\n\"ALLOC DD(\"dd\") NEW CYL SP(5,2) DA(\"da\")\"\n\"EXECIO * DISKW\" dd \"(FINIS STEM trap.\"\nAddress ISPEXEC \"VIEW DATASET(\"da\")\"\n\"FREE DD(\"dd\")\"\n\"DELETE\" da\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSJ": {"ttr": 37892, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00,\\x00,\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "REXX"}, "text": "/**  REXX - SPLIT OR JOIN LINES - STRIPS BLANKS ON JOIN  **/\n   ADDRESS ISREDIT\n   \"ISREDIT MACRO (PARMS)\"\n   IF PARMS = '?' THEN SIGNAL DISPDOC\n   \"ISREDIT (LINE,COL) = CURSOR\"\n   \"ISREDIT (CURRENT)  = LINE \"LINE\n   \"ISREDIT (END)      = LINENUM .ZLAST\"\n   IF LINE < END\n       THEN \"ISREDIT (NEXT) = LINE \"LINE+1\n       ELSE NEXT = \"   \"\n   IF SUBSTR(CURRENT,COL) = \" \"\n      THEN DO\n         CURRENT = SUBSTR(CURRENT,1,COL-1) || STRIP(NEXT,'L')\n         \"ISREDIT LINE &LINE = (CURRENT)\"\n         DELLINE = LINE + 1\n         \"ISREDIT DELETE &DELLINE\"\n      END\n      ELSE DO\n         BLANKCOLS = VERIFY(CURRENT,\" \") - 1\n         IF BLANKCOLS < 0 THEN BLANKCOLS = 0\n         NEW = COPIES(\" \",BLANKCOLS) || SUBSTR(CURRENT,COL)\n         CURRENT = SUBSTR(CURRENT,1,COL-1)\n         \"ISREDIT LINE &LINE = (CURRENT)\"\n         \"ISREDIT LINE_AFTER &LINE = (NEW)\"\n      END\n   \"ISREDIT CURSOR = \" LINE COL\n   EXIT(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"TSJ - TEXT SPLIT OR JOIN MACRO\"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    SPLIT LINE WHERE CURSOR IS POSITIONED IF ANY NON-    \"\n   SAY \"    BLANK DATA TO RIGHT. DATA WILL BE ALIGNED WITH       \"\n   SAY \"    DATA ON LINE WITH CURSOR.                            \"\n   SAY\n   SAY \"    IF ONLY BLANKS TO RIGHT OF CURSOR POSITION, JOIN     \"\n   SAY \"    DATA FROM NEXT LINE, DELETING THAT LINE. WILL        \"\n   SAY \"    ATTACH ONLY NON BLANK DATA.                          \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TU": {"ttr": 37894, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x80\\x00\\x80\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 128, "newlines": 128, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- Display and allow changes to PDS Member's statistics   **/\n/*********************************************************************/\n   ARG PARMS\n   Do ii = 2 to length(PARMS) while(substr(PARMS,ii,1) <> '(')\n   End ii\n   jj  = length(PARMS) - 2\n   PDS = substr(PARMS,2,ii-2)\n   MEM = substr(PARMS,ii+1,length(PARMS)-ii-2)\n   Call setup_libdefs\n   quit = 'NO'\n   Call get_stats\n   Call display_panel\n   If quit <> 'YES' then do\n      Call update_stats\n      Address ispexec 'SETMSG MSG(MSGN001)'\n   End\n   Else do\n      Address ispexec\n      \"LMCLOSE   DATAID(&TTID)\"\n      \"LMFREE    DATAID(&TTID)\"\n      Address ispexec 'SETMSG MSG(MSGN003)'\n   End\n   Call destroy_libdefs\n   Return 1\n/******************* setup_libdefs ********************************/\nsetup_libdefs: Procedure Expose ddname\n\n   ddname = '$'right(time(s),7,'0')\n   Address tso 'ALLOC NEW DEL F('ddname') DIR(1) SP(1) TR RECF(F B)\n                BLKS(0) LRECL(80) REU UNIT(SYSDA)'\n   Address ispexec\n   'LMINIT DATAID(DID) DDNAME('ddname') ENQ(EXCLU)'\n   'LMOPEN DATAID(&DID) OPTION(OUTPUT)'\n   a=1\n   Do 2\n     Do a=a to 999 Until substr(line,1,8)='/*MEMBER'\n       line = sourceline(a)\n     End\n     Parse Var line . memname .\n     Do a=a+1 to 999 While substr(line,1,2) \\= '*/'\n       line = sourceline(a)\n       'LMPUT DATAID(&DID) MODE(INVAR) DATALOC(LINE) DATALEN(80)'\n     End\n     'LMMADD DATAID(&DID) MEMBER(&MEMNAME)'\n   End\n   'LMFREE DATAID(&DID)'\n   'LIBDEF ISPPLIB LIBRARY ID('ddname') STACK'\n   'LIBDEF ISPMLIB LIBRARY ID('ddname') STACK'\n   Return\n/********************* get_stats **********************************/\nget_stats:\n   Address ispexec\n   \"LMINIT  DATAID(TTID) DATASET('\"PDS\"') ENQ(SHRW)\"\n   \"LMOPEN  DATAID(&TTID) OPTION(INPUT)\"\n   \"LMMFIND DATAID(&TTID) MEMBER(\"MEM\") STATS(YES)\"\n   VV      = ZLVERS\n   CREDATE = ZLCDATE\n   CHGDATE = ZLMDATE\n   CHGTM   = ZLMTIME\n   INISZ   = ZLINORC\n   CURSZ   = ZLCNORC\n   MD      = ZLMOD\n   USERID  = ZLUSER\n   Return\n/********************* update_stats **********************************/\nupdate_stats:\n   Address ispexec\n   \"LMMSTATS   DATAID(&TTID) MEMBER(\"MEM\")\",\n              \"VERSION(\"VV\") MODLEVEL(\"MD\")\",\n              \"CREATED(\"CREDATE\") MODDATE(\"CHGDATE\")\",\n              \"MODTIME(\"CHGTM\") CURSIZE(\"CURSZ\")\",\n              \"INITSIZE(\"INISZ\") USER(\"USERID\")\"\n   \"LMCLOSE   DATAID(&TTID)\"\n   \"LMFREE    DATAID(&TTID)\"\n   Return\n/********************* DISPLAY PANEL ******************************/\ndisplay_panel:\n   Address ispexec\n   'ADDPOP'\n   'DISPLAY PANEL(POPUP)'\n   If rc = 8 then quit = 'YES'\n   'REMPOP'\n   Return\n/********************* DESTROY_LIBDEFS ***************************/\ndestroy_libdefs:\n   Address ispexec 'LIBDEF ISPPLIB '\n   Address ispexec 'LIBDEF ISPMLIB '\n   Address tso 'FREE F('ddname')'\n   Return\n\n/*------------------------------------------------------------------*/\n/* In-line panels and messages are defined below                    */\n/*------------------------------------------------------------------*/\n/*MEMBER POPUP  This panel prompts for XREF input\n)ATTR DEFAULT(%+_)\n     % TYPE(TEXT)  INTENS (HIGH)\n     + TYPE(TEXT)  INTENS (LOW)  SKIP(ON)\n     _ TYPE(INPUT) INTENS (HIGH) CAPS(ON) JUST(LEFT)\n     $ TYPE(INPUT) INTENS (HIGH) CAPS(ON) JUST(LEFT)\n     @ TYPE(TEXT)  INTENS (HIGH) COLOR(TURQ)\n     ! TYPE(TEXT)  INTENS (LOW)  CAPS(ON)\n)BODY WINDOW(60,16)\n@  -- PDS Statistics Display/Update                   -- +\n\n%PDS:+$PDS                                          +\n%MEM:+$MEM     +\n\n%Version:   +$VV+          ** 01 to 99               +\n%Mod Count: +$MD+          ** 00 to 99               +\n%Create Dt: +$CREDATE +    ** YY/MM/DD               +\n%Change Dt: +$CHGDATE +    ** YY/MM/DD               +\n%Change Tm: +$CHGTM +      ** HH:MM                  +\n%Initial Sz:+$INISZ+       ** 0 to 32767             +\n%Current Sz:+$CURSZ+       ** 0 to 32767             +\n%UserID:    +$USERID +     ** 1 to 7 characters      +\n\n@  -- Press <ENTER> to update or <PF3> (END) to Quit  -- +\n)INIT\n   .CURSOR  = VV\n)PROC\n)END\n*/\n/*MEMBER MSGN00  This is a message member. Can be in same lib as panel.\nMSGN001 'Processed &MEM member...'\n'Data set produced is &PDS for member &MEM...'\nMSGN003 'No changes made...'\n'Terminated with no changes entered...'\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T1": {"ttr": 37897, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x04\\x00\\x04\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "REXX"}, "text": "\n   START_CPU = TIME('R')\n   START_CPU = SYSVAR(SYSCPU)\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "T2": {"ttr": 37899, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x04\\x00\\x04\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "REXX"}, "text": "\n   ENDING_CPU = SYSVAR(SYSCPU) - START_CPU\n   SAY '** ELAPSED TIME IS' TIME('E') 'AND CPU TIME IS' ENDING_CPU\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UNIQUE": {"ttr": 37901, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xb9\\x00\\xb9\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 185, "newlines": 185, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- SORT & SHOW ALL RECORDS THAT ARE UNIQUE WITHIN A FILE  **/\n\n   SUBCOM ISREDIT\n   IF  RC = 0  THEN DO\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT \"ISREDIT MACRO (PARMS)\"\n      IF  RC = 0  THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF  DSN = 'DSN'  THEN DO\n      SAY 'UNIQUE MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n\n   PARMS   = TRANSLATE(PARMS)\n   PARMCNT = 0\n   COL.    = \"\"\n   LBL1    = \"\"\n   LBL2    = \"\"\n   DO II = 1 TO 16;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n      END\n      ELSE DO\n         PARMCNT     = PARMCNT + 1\n         COL.PARMCNT = TOKEN\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n   IF (PARMCNT // 2) <> 0 THEN DO\n      SAVER       = COL.PARMCNT\n      PARMCNT     = PARMCNT + 1\n      COL.PARMCNT = SAVER\n   END\n\n   ERRORMSG = ''\n   MESG     = ''\n   IF  PARMCNT = 0 THEN DO\n      MESG = 'PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   SORTPARMS = \"\"\n   DO II = 1 TO PARMCNT\n      IF  \u00acDATATYPE(COL.II,'W') | COL.II = 0 THEN DO\n         MESG = \"'\"COL.II\"' COLUMN VALUE IS INVALID!\"\n         SIGNAL ERROR\n      END\n      IF  COL.II > LRECL  THEN DO\n         MESG = \"'\"COL.II\"' IS GREATER THAN RECORD SIZE(\"LRECL\")\"\n         SIGNAL ERROR\n      END\n      SORTPARMS = SORTPARMS || \" \" || COL.II\n   END II\n   DO II = 1 TO PARMCNT BY 2\n      JJ = II + 1\n      IF  COL.II > COL.JJ THEN DO\n         MESG = \"LEFT-COL \"COL.II\" IS GREATER THAN RIGHT-COL \"COL.JJ\n         SIGNAL ERROR\n      END\n   END II\n\n   IF  LBL1 <> ''  THEN DO\n      \"ISREDIT L &LBL1\"\n       IF  RC <>  0 THEN DO\n          MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   IF  LBL2 <> ''  THEN DO\n      \"ISREDIT L &LBL2\"\n       IF  RC <>  0 THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   IF  LBL1 <> ''  THEN  \"ISREDIT (START) = LINENUM &LBL1\"\n                   ELSE  START = 1\n   IF  LBL2 <> ''  THEN  \"ISREDIT (END) = LINENUM &LBL2\"\n                   ELSE  \"ISREDIT (END) = LINENUM .ZLAST\"\n\n   \"ISREDIT (\"ANUM\") = AUTONUM\"\n   \"ISREDIT NUMBER OFF \"\n\n   \"ISREDIT SORT \" SORTPARMS LBL1 LBL2\n\n   \"ISREDIT (RECORD)  = LINE \" START\n   PREVKEY = SUBSTR(RECORD,COL.1,COL.2-COL.1+1)\n   DO II = 3 TO PARMCNT BY 2\n      JJ      = II + 1\n      PREVKEY = PREVKEY || SUBSTR(RECORD,COL.II,COL.JJ-COL.II+1)\n   END II\n   SET = 1\n   \"ISREDIT RESET\"\n\n   XX = 0\n   DO  PNTR  =  (START+1) TO END  BY 1\n      \"ISREDIT (RECORD) = LINE\" PNTR\n      NEXTKEY = SUBSTR(RECORD,COL.1,COL.2-COL.1+1)\n      DO II = 3 TO PARMCNT BY 2\n         JJ      = II + 1\n         NEXTKEY = NEXTKEY || SUBSTR(RECORD,COL.II,COL.JJ-COL.II+1)\n      END II\n      IF PREVKEY == NEXTKEY THEN DO\n         IF XX = 0 THEN \"ISREDIT LABEL \"PNTR\" = .AAAA\"\n         XX = XX + 1\n      END\n      ELSE DO\n         IF XX > 0 THEN DO\n            IF XX > 1 THEN DO\n               YY = PNTR - 1\n               \"ISREDIT LABEL \"YY\" = .BBBB\"\n               \"ISREDIT X ALL .AAAA .BBBB\"\n            END\n            ELSE \"ISREDIT X ALL .AAAA .AAAA\"\n            XX = 0\n         END\n         SET     = SET + 1\n         PREVKEY = NEXTKEY\n      END\n   END\n   IF XX > 0 THEN DO\n      IF XX > 1 THEN DO\n         YY = PNTR - 1\n         \"ISREDIT LABEL \"YY\" = .BBBB\"\n         \"ISREDIT X ALL .AAAA .BBBB\"\n      END\n      ELSE \"ISREDIT X ALL .AAAA .AAAA\"\n      XX = 0\n   END\n\n   CALL SETMSG '* NO ' SET 'UNIQUE KEY SETS $SETS OF UNIQUE KEYS FOUND'\n   IF START = 1 THEN \"ISREDIT LOCATE\" 0\n                ELSE DO\n                   START = START - 1\n                   \"ISREDIT LOCATE\" START\n                END\n   \"ISREDIT AUTONUM = \"ANUM\n    SIGNAL EOJ\n\nERROR:\n   IF MESG <> '' THEN DO\n      ERRORMSG = '===>' MESG\n   END\n   SIGNAL DISPDOC\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nEOJ:\n   RETURN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"UNIQUE - SORT AND SHOW EVERY UNIQUE RECORD IN RANGE OR FILE\"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    UNIQUE  COL1 COL2  ...  ( .LABEL1 .LABEL2 )   \"\n   SAY\n   SAY \"       ONE PAIR OF COLUMNS IS MANDATORY. UP TO 10 \"\n   SAY \"       PAIRS MAY BE SPECIFIED.                    \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY \"    UNIQUE  17 19  4 11 \"\n   SAY \"       WILL SORT FILE BY COLUMNS 17 THRU 19 AND 4 \"\n   SAY \"       THRU 11 SHOWING (UNEXCLUDING) THE FIRST OR \"\n   SAY \"       ONLY RECORD FOR EACH UNIQUE KEY.           \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNIQUEX": {"ttr": 37905, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xac\\x00\\xac\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 172, "newlines": 172, "modlines": 0, "user": "REXX"}, "text": "/**  REXX - SHOW ALL UNIQUE RECORDS WITHIN A FILE W/O SORTING  **/\n\n   SUBCOM ISREDIT\n   IF  RC = 0  THEN DO\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT \"ISREDIT MACRO (PARMS)\"\n      IF  RC = 0  THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF  DSN = 'DSN'  THEN DO\n      SAY 'UNIQUEX MACRO CAN ONLY BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n\n   PARMS   = TRANSLATE(PARMS)\n   PARMCNT = 0\n   COL.    = \"\"\n   LBL1    = \"\"\n   LBL2    = \"\"\n   DO II = 1 TO 16;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n      END\n      ELSE DO\n         PARMCNT = PARMCNT + 1\n         COL.PARMCNT = TOKEN\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n   IF (PARMCNT // 2) <> 0 THEN DO\n      SAVER       = COL.PARMCNT\n      PARMCNT     = PARMCNT + 1\n      COL.PARMCNT = SAVER\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n   IF  PARMCNT = 0 THEN DO\n      MESG = 'PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   DO II = 1 TO PARMCNT BY 2\n      JJ = II + 1\n      IF  COL.II > COL.JJ THEN DO\n         MESG = \"LEFT-COL \"COL.II\" IS GREATER THAN RIGHT-COL \"COL.JJ\n         SIGNAL ERROR\n      END\n   END II\n\n   IF  LBL1 <> ''  THEN DO\n      \"ISREDIT L &LBL1\"\n       IF  RC <>  0 THEN DO\n          MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   IF  LBL2 <> ''  THEN DO\n      \"ISREDIT L &LBL2\"\n       IF  RC <>  0 THEN DO\n          MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n          SIGNAL ERROR\n       END\n   END\n\n   IF  LBL1 <> ''  THEN  \"ISREDIT (START) = LINENUM &LBL1\"\n                   ELSE  START = 1\n   IF  LBL2 <> ''  THEN  \"ISREDIT (END) = LINENUM &LBL2\"\n                   ELSE  \"ISREDIT (END) = LINENUM .ZLAST\"\n\n   \"ISREDIT (\"ANUM\") = AUTONUM\"\n   \"ISREDIT NUMBER OFF \"\n\n   \"ISREDIT (RECORD)  = LINE \" START\n   PREVKEY = SUBSTR(RECORD,COL.1,COL.2-COL.1+1)\n   DO II = 3 TO PARMCNT BY 2\n      JJ      = II + 1\n      PREVKEY = PREVKEY || SUBSTR(RECORD,COL.II,COL.JJ-COL.II+1)\n   END II\n   \"ISREDIT LABEL\" START \"= .TMP\"\n   SET = 1\n   \"ISREDIT RESET\"\n\n   XX = 0\n   DO  PNTR  =  (START+1) TO END  BY 1\n      \"ISREDIT (RECORD) = LINE\" PNTR\n      NEXTKEY = SUBSTR(RECORD,COL.1,COL.2-COL.1+1)\n      DO II = 3 TO PARMCNT BY 2\n         JJ = II + 1\n         NEXTKEY = NEXTKEY || SUBSTR(RECORD,COL.II,COL.JJ-COL.II+1)\n      END II\n      IF PREVKEY == NEXTKEY THEN DO\n         IF XX = 0 THEN \"ISREDIT LABEL \"PNTR\" = .AAAA\"\n         XX = XX + 1\n      END\n      ELSE DO\n         IF XX > 0 THEN DO\n            IF XX > 1 THEN DO\n               YY = PNTR - 1\n               \"ISREDIT LABEL \"YY\" = .BBBB\"\n               \"ISREDIT X ALL .AAAA .BBBB\"\n            END\n            ELSE \"ISREDIT X ALL .AAAA .AAAA\"\n            XX = 0\n         END\n         PREVKEY = NEXTKEY\n         SET     = SET + 1\n      END\n   END\n   IF XX > 0 THEN DO\n      IF XX > 1 THEN DO\n         YY = PNTR - 1\n         \"ISREDIT LABEL \"YY\" = .BBBB\"\n         \"ISREDIT X ALL .AAAA .BBBB\"\n      END\n      ELSE \"ISREDIT X ALL .AAAA .AAAA\"\n      XX = 0\n   END\n\n   CALL SETMSG '* NO ' SET 'UNIQUE KEY SETS $SETS OF UNIQUE KEYS FOUND'\n   IF START = 1 THEN \"ISREDIT LOCATE\" 0\n                ELSE DO\n                   START = START - 1\n                   \"ISREDIT LOCATE\" START\n                END\n   \"ISREDIT AUTONUM = \"ANUM\n    SIGNAL EOJ\n\nERROR:\n   IF MESG <> '' THEN DO\n      ERRORMSG = '===>' MESG\n   END\n   SIGNAL DISPDOC\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nEOJ:\n   RETURN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"UNIQUEX - SHOW UNIQUE RECORDS WITHIN RANGE OR FILE W/O SORTING\"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    UNIQUEX  COL1 COL2  ...  ( .LABEL1 .LABEL2 )        \"\n   SAY\n   SAY \"       ONE PAIR OF COLUMNS IS MANDATORY. UP TO 10 PAIRS \"\n   SAY \"       MAY BE SPECIFIED.                                \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY \"    UNIQUEX  17 19  4 11 \"\n   SAY \"       WILL SCAN FILE BY COLUMNS 17 THRU 19 AND 4       \"\n   SAY \"       THRU 11 SHOWING (UNEXCLUDING) THE FIRST OR       \"\n   SAY \"       ONLY RECORD WITH A GIVEN KEY.                    \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNPACKDS": {"ttr": 38147, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x01\\n\\x01\\n\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 266, "newlines": 266, "modlines": 0, "user": "REXX"}, "text": "  /*-REXX---------------------- UNPACKDS ----------------------REXX-*/\n  /*                                                                */\n  /* Call TRSMAIN to UNpack a dataset received in packed or tersed  */\n  /* format.                                                        */\n  /*                                                                */\n  /* Syntax:  %UNPACKDS input-DSN output-DSN output-DSORG           */\n  /*                                                                */\n  /*----------------------------------------------------------------*/\n\naddress TSO\n\"subcom ISPEXEC\"; if RC=0 then SPF=1; else SPF=0\ncall   on error   name RXERROR         /* Activate command ERROR trap */\nsignal on syntax  name RXERROR                /* Activate SYNTAX trap */\nsignal on novalue name RXERROR               /* Activate NOVALUE trap */\n\narg INDS OUTDS DSORG                           /* Retrieve input args */\n\nif length(INDS) = 0 | length(OUTDS) = 0 then do\n   if length(INDS) = 0 then CURPOS = 'INDS'; else CURPOS = 'OUTDS'\n   OK = '8'\n   address ISPEXEC \"display panel(UNPACKDS)\"/* Display UNPACKDS panel */\n   drop OK\n   if RC <> 0 then exit 0\nend\n\nTP = sysvar('SYSPREF')                                  /* TSO Prefix */\nif left(INDS,1) = \"'\" then do\n   if right(INDS,1) = \"'\" then nop\n   else INDS = INDS\"'\"\nend\nelse if left(INDS,length(TP)+1) = TP||'.' then INDS = \"'\"INDS\"'\"\n\nif left(OUTDS,1) = \"'\" then do\n   if right(OUTDS,1) = \"'\" then nop\n   else OUTDS = OUTDS\"'\"\nend\nelse if left(OUTDS,length(TP)+1) = TP||'.' then OUTDS = \"'\"OUTDS\"'\"\n\nif DSORG = \"PO\" & (DIR = '' | DIR = 0) then DIR = 45 /* Default DIR's */\n\nX = msg(\"OFF\")\nOK = 'ALL'\n\"free dd(INFILE OUTFILE SYSPRINT)\"              /* Free required DD's */\n\"DEL\" OUTDS                                  /* Delete output dataset */\ndrop OK\nX = msg(\"ON\")\n\n  /* Build output dataset ALLOC statement & allocate */\n\n\"alloc dd(OUTFILE) ds(\"OUTDS\") new catalog release reuse \" ||,\n       space() \"tracks UNIT(SYSDA) \" ||,\n       dsorg() dir() lrecl() recfm() blksize()\n\n\"alloc dd(INFILE) ds(\"INDS\") shr reuse\"     /* Allocate input dataset */\n\n  /*\n\"execio 1 diskr INFILE (finis stem IN.\"\nif \"This is an Inter-Enterprise\" = left(IN.1,27) then do\n   OUT. = \"\"\n   J = 0\n   drop IN.\n   \"execio * diskr INFILE (finis stem IN.\"\n   do I = 2 to IN.0\n      J = J+1\n      OUT.J = IN.I\n   end\n   OUT.0 = J\n   \"execio * diskw INFILE (finis stem OUT.\"\n   drop IN. OUT.\nend\n  */\n\"alloc dd(SYSPRINT) ds(*)\"           /* Allocate SYSPRINT to terminal */\n\n                       /* Modify call stmt if TRSMAIN not in LINKLIST */\n\"call *(TRSMAIN) 'UNPACK'\"                            /* Call TRSMAIN */\n\n\"free dd(INFILE OUTFILE SYSPRINT)\"                       /* Free DD's */\n\nZISPFRC = 0\nif SPF then address ISPEXEC \"vput (ZISPFRC) shared\"\nexit ZISPFRC                                             /* All Done! */\n\n/*====================================================================*/\n/*                       SUBROUTINES/FUNCTIONS                        */\n/*====================================================================*/\n\nspace:                    /* Return formatted or NULL SPACE parameter */\n  if PTRKS = 0 | PTRKS = '' then do\n     call LISTDSI INDS\n     if left(SYSUNITS,1) = \"C\" then PTRKS = (SYSALLOC*15)*5\n     else PTRKS = SYSALLOC*5\n  end\n  if STRKS = 0 | STRKS = '' then STRKS = PTRKS*15\n  SPACE = \"space(\"PTRKS\",\"STRKS\")\"\nreturn SPACE\n\n/*====================================================================*/\n\ndsorg:                    /* Return formatted or NULL DSORG parameter */\n  if (DSORG = '' | DSORG = 'PO') & DIR > 0 then DSORG = \"dsorg(PO)\"\n  else DSORG = \"dsorg(PS)\"\nreturn DSORG\n\n/*====================================================================*/\n\ndir:                      /* Return formatted or NULL DIR parameter */\n  if DIR > 0 then DIR = \"dir(\"DIR\")\"\n  else DIR = ''\nreturn DIR\n\n/*====================================================================*/\n\nlrecl:                    /* Return formatted or NULL LRECL parameter */\n  if LRECL > 0 then LRECL = \"lrecl(\"LRECL\")\"\n  else LRECL = ''\nreturn LRECL\n\n/*====================================================================*/\n\nrecfm:                    /* Return formatted or NULL RECFM parameter */\n  select\n     when RECFM = 'FB'  then RECFM = \"recfm(F B)\"\n     when RECFM = 'FB'  then RECFM = \"recfm(F B)\"\n     when RECFM = 'FBA' then RECFM = \"recfm(F B A)\"\n     when RECFM = 'VBA' then RECFM = \"recfm(V B A)\"\n     otherwise RECFM = ''\n  end\nreturn RECFM\n\n/*====================================================================*/\n\nblksize:                /* Return formatted or NULL BLKSIZE parameter */\n  if BLKSIZE > 0 then BLKSIZE = \"blksize(\"BLKSIZE\")\"\n  else BLKSIZE = ''\nreturn BLKSIZE\n\n/*====================================================================*/\n\n  /*---------------------------- RXERROR ---------------------------*/\n  /*                                                                */\n  /* REXX error condition handler. The routine gets control when a  */\n  /* error condition is raised, and:                                */\n  /*                                                                */\n  /* A. Validates the error condition is OK and if so, returns      */\n  /*    quietly, or                                                 */\n  /*                                                                */\n  /* B. Issues diagnostics messages about the error and where it    */\n  /*    occurred, then exits passing the failed RC to the original  */\n  /*    caller.                                                     */\n  /*                                                                */\n  /* To use this routine, code the following near the top of the    */\n  /* exec:                                                          */\n  /*                                                                */\n  /*   call   on error   name RXERROR                               */\n  /*   signal on syntax  name RXERROR                               */\n  /*   signal on novalue name RXERROR                               */\n  /*                                                                */\n  /* For those Host commands where a failure is possible set the    */\n  /* variable 'OK' to any Return Codes that are acceptable for the  */\n  /* Host command.  For example:                                    */\n  /*                                                                */\n  /*   OK='8';   \"host cmd\"; drop OK <- RC 8 is acceptable.         */\n  /*   OK='4 8'; \"host cmd\"; drop OK <- RC's 4 or 8 are acceptable. */\n  /*   OK='ALL'; \"host cmd\"; drop OK <- ALL RC's are acceptable.    */\n  /*                                                                */\n  /*----------------------------------------------------------------*/\n  /* NOTE: This subroutine does NOT use the PROCEDURE instruction,  */\n  /*       so all variables created within it must be *hidden*, ie. */\n  /*       unique.                                                  */\n  /*----------------------------------------------------------------*/\n\nRXERROR: trace N\naddress TSO\ncall   off error\nsignal off syntax\nsignal off novalue\n_SIGL=SIGL\nif symbol('RC') = 'VAR' then _RC = RC; else _RC = 'N/A'\n\"subcom ISPEXEC\"; if RC=0 then _SPF=1; else _SPF=0\nparse source . . _EXNAME .\n_ERRORTXT = ''\n\nif condition('I') = 'CALL' then ,\n   if symbol('OK') = 'VAR' then ,\n      if wordpos(_RC,OK)>0 | translate(OK)='ALL' then do\n         call   on error   name RXERROR\n         signal on syntax  name RXERROR\n         signal on novalue name RXERROR\n         drop ZERRLM ZERRMSG ZERRSM\n         RC = _RC\n         return\n      end\n      else nop\n\nselect\n   when index(condition('C'),'ERROR FAILURE') > 0 then do\n      _CMD = strip(strip(word(condition('D'),1),'B','\"'),'B',\"'\")\n      _ERRORTXT = '(Host command: '_CMD')'\n      say 'RXERROR-> RC: '_RC' '_ERRORTXT' at line: '_SIGL ||,\n          ' in EXEC: '_EXNAME\n      if _SIGL <= sourceline() then do\n         say ' '\n         say 'RXERROR-> Line '_SIGL': 'strip(sourceline(_SIGL))\n      end\n      if datatype(_RC,'N') then ,\n         if abs(_RC) > 7 then ZISPFRC = abs(_RC)\n         else ZISPFRC = 8\n      else ZISPFRC = 8\n      if _SPF then address ISPEXEC \"vput (ZISPFRC) shared\"\n      exit ZISPFRC\n   end\n\n   when condition('C') = 'SYNTAX' then do\n      if datatype(_RC,'N') = 1 then ,\n         if (_RC >= 0 & _RC < 100) then _ERRORTXT = '('errortext(_RC)')'\n         else nop\n      say 'RXERROR-> RC: '_RC' '_ERRORTXT' at line: '_SIGL ||,\n          ' in EXEC: '_EXNAME\n      if _SIGL <= sourceline() then do\n         say ' '\n         say 'RXERROR-> Line '_SIGL': 'strip(sourceline(_SIGL))\n      end\n      if datatype(_RC,'N') then ,\n         if abs(_RC) > 7 then ZISPFRC = abs(_RC)\n         else ZISPFRC = 8\n      else ZISPFRC = 8\n      if _SPF then address ISPEXEC \"vput (ZISPFRC) shared\"\n      exit ZISPFRC\n   end\n\n   when condition('C') = 'NOVALUE' then do\n      _ERRORTXT = '(No value for variable: 'condition('D')')'\n      say 'RXERROR-> RC: '_RC' '_ERRORTXT' at line: '_SIGL ||,\n          ' in EXEC: '_EXNAME\n      if _SIGL <= sourceline() then do\n         say ' '\n         say \"RXERROR-> Line \"_SIGL\": \"strip(sourceline(_SIGL))\n      end\n      if datatype(_RC,'N') then ,\n         if abs(_RC) > 7 then ZISPFRC = abs(_RC)\n         else ZISPFRC = 8\n      else ZISPFRC = 8\n      if _SPF then address ISPEXEC \"vput (ZISPFRC) shared\"\n      exit ZISPFRC\n   end\n\n   otherwise condition('C') <> '' then do\n      _ERRORTXT = '(Condition='condition('C')', Description=' ||,\n                  condition('D')')'\n      say 'RXERROR-> RC: '_RC' '_ERRORTXT' at line: '_SIGL ||,\n          ' in EXEC: '_EXNAME\n      if _SIGL <= sourceline() then do\n         say ' '\n         say \"RXERROR-> Line \"_SIGL\": \"strip(sourceline(_SIGL))\n      end\n      if datatype(_RC,'N') then ,\n         if abs(_RC) > 7 then ZISPFRC = abs(_RC)\n         else ZISPFRC = 8\n      else ZISPFRC = 8\n      if _SPF then address ISPEXEC \"vput (ZISPFRC) shared\"\n      exit ZISPFRC\n   end\nend\nZISPFRC = 8                                  /* Should NEVER get here */\nif _SPF then address ISPEXEC \"vput (ZISPFRC) shared\"\nexit ZISPFRC                                      /* but just case... */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNPK": {"ttr": 38152, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xfa\\x00\\xfa\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 250, "newlines": 250, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- UNPK COLUMNS ONTO SAME OR OTHER COLUMNS  **/\n   RTN = 0\n   SAVEMSG = MSG()\n   IF SAVEMSG = 'OFF' THEN\n      X = MSG(\"ON\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY 'UNPK MUST BE RUN UNDER ISPF EDIT!'\n      SIGNAL EOJ\n   END\n   SUBCOM ISREDIT\n   IF RC = 0 THEN DO\n      UMODE = 'ISREDIT'\n      ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT,\n         \"ISREDIT MACRO (FRMLEFT,FRMRIGHT,PARMS)\"\n      IF RC = 0 THEN DO\n         ADDRESS ISREDIT \"ISREDIT (\"DSN\") = DATASET\"\n      END\n   END\n   IF DSN = 'DSN' THEN DO\n      SAY UNPK 'EDIT MACRO CAN ONLY BE RUN UNDER ISPF EDIT',\n         'WITH NO PENDING EDIT COMMANDS!'\n      SIGNAL EOJ\n   END\n\n   ERRORMSG = ''\n   MESG = ''\n   IF FRMLEFT = ''  |  FRMRIGHT = ''  THEN DO\n      MESG = 'PARAMETERS ARE MISSING!'\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMLEFT,'W')  |  FRMLEFT = 0  THEN DO\n      MESG = \"'\"FRMLEFT\"' VALUE OF FROM-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(FRMRIGHT,'W')  |  FRMRIGHT = 0  THEN DO\n      MESG = \"'\"FRMRIGHT\"' VALUE OF FROM-RIGHT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF FRMLEFT > FRMRIGHT THEN DO\n      MESG = \"FROM-LEFT-COL \"FRMLEFT\" IS > THAN FROM-RIGHT-COL \"FRMRIGHT\n      SIGNAL ERROR\n   END\n\n   PARMS   = TRANSLATE(PARMS)\n   LBL1    = \"\"\n   LBL2    = \"\"\n   TOLEFT  = \"\"\n   TORIGHT = \"\"\n   MINUS   = 0\n   DO II = 1 TO 5;\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n         IF LBL1 = \"\" THEN LBL1 = TOKEN\n         ELSE IF LBL2 = \"\" THEN LBL2 = TOKEN\n            ELSE DO\n               ZEDSMSG = \".LABEL RC=8\"\n               ZEDLMSG = \"TOO MANY LABELS --\" LBL1 LBL2 TOKEN\n               ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n               EXIT 8\n            END\n      END\n      ELSE IF SUBSTR(TOKEN,1,1) = \"-\" THEN DO\n         MINUS = SUBSTR(TOKEN,2)\n      END\n      ELSE DO\n         IF DATATYPE(TOKEN,'W')  THEN DO\n            IF TOLEFT = \"\" THEN TOLEFT = TOKEN\n            ELSE IF TORIGHT = \"\" THEN TORIGHT = TOKEN\n               ELSE DO\n                  ZEDSMSG = \".LABEL RC=8\"\n                  ZEDLMSG = \"TOO MANY COLUMNS --\" TOLEFT TORIGHT TOKEN\n                  ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n                  EXIT 8\n               END\n         END\n      END\n   END II\n   IF LBL1 <> \"\"  &  LBL2 = \"\"  THEN LBL2 = LBL1\n   IF TOLEFT <> \"\" AND TORIGHT = \"\" THEN TORIGHT = TOLEFT\n   IF TOLEFT = \"\" THEN DO\n      TOLEFT  = FRMLEFT\n      TORIGHT = FRMRIGHT\n   END\n\n   IF \u00acDATATYPE(TOLEFT,'W')  |  TOLEFT=0  THEN DO\n      MESG = \"'\"TOLEFT\"' VALUE OF TO-LEFT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   IF \u00acDATATYPE(TORIGHT,'W')  |  TORIGHT=0  THEN DO\n      MESG = \"'\"TORIGHT\"' VALUE OF TO-RIGHT-COL IS INVALID!\"\n      SIGNAL ERROR\n   END\n   LEN = FRMRIGHT - FRMLEFT + 1\n   IF TOLEFT > TORIGHT THEN DO\n      MESG = \"TO-LEFT-COL \"TOLEFT\" IS GREATER THAN TO-RIGHT-COL \"TORIGHT\n      SIGNAL ERROR\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   IF TORIGHT > LRECL THEN DO\n      MESG = \"TO-RIGHT COLUMN IS GREATER THAN RECORD SIZE (\"LRECL\")\"\n      SIGNAL ERROR\n   END\n\n   IF LBL1 <> '' THEN DO\n      \"ISREDIT L &LBL1\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL1 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   IF LBL2 <> '' THEN DO\n      \"ISREDIT L &LBL2\"\n      IF RC <> 0 THEN DO\n         MESG = \"LABEL\" LBL2 \"NOT FOUND\"\n         SIGNAL ERROR\n      END\n   END\n   \"ISREDIT (\"LRECL\") = LRECL \"\n   \"ISREDIT (\"SAVLINE\",\"SAVCOL\") = CURSOR \"\n   \"ISREDIT (\"ANUM\") = AUTONUM \"\n   \"ISREDIT (END) = LINENUM .ZLAST\"\n\n   START = 1\n   IF LBL1 <> '' THEN\n       \"ISREDIT (START) = LINENUM &LBL1\"\n\n   IF LBL2 <> '' THEN\n        \"ISREDIT (END) = LINENUM &LBL2\"\n   ELSE\n        LBL2 = LBL1\n\n   IF START > END THEN DO\n      WST = START\n      START = END\n      END = WST\n   END\n\n   GOOD_HEX = '00010203040506070809'X || '10111213141516171819'X,\n           || '20212223242526272829'X || '30313233343536373839'X,\n           || '40414243444546474849'X || '50515253545556575859'X,\n           || '60616263646566676869'X || '70717273747576777879'X,\n           || '80818283848586878889'X || '90919293949596979899'X\n   TO_SIGN   = '0123456789}JKLMNOPQR0123456789'\n   TO_SIGN2  = '012345678901234567890123456789'\n   FROM_SIGN = '0C1C2C3C4C5C6C7C8C9C'X,\n            || '0D1D2D3D4D5D6D7D8D9D'X,\n            || '0F1F2F3F4F5F6F7F8F9F'X\n\n   TOT  = 0\n   OK   = 0\n   OVFL = 0\n   DO PNTR =  START  TO  END  BY 1\n      TOT = TOT + 1\n      \"ISREDIT (RECORD) = LINE &PNTR\"\n      IF VERIFY(SUBSTR(RECORD,FRMLEFT,FRMRIGHT-FRMLEFT),GOOD_HEX) = 0,\n            & VERIFY(SUBSTR(RECORD,FRMRIGHT,1),FROM_SIGN) = 0,\n         THEN DO\n            OK = OK + 1\n            USTR = C2X(SUBSTR(RECORD,FRMLEFT,FRMRIGHT-FRMLEFT))\n            IF MINUS = 0,\n               THEN DO\n                  ZSTR = SUBSTR(RECORD,FRMRIGHT,1)\n                  ZSTR = TRANSLATE(ZSTR,TO_SIGN,FROM_SIGN)\n               END\n               ELSE DO\n                  ZSTR = SUBSTR(RECORD,FRMRIGHT,1)\n                  IF VERIFY(ZSTR,'0D1D2D3D4D5D6D7D8D9D'X) = 0,\n                     THEN DO\n                        RECORD = SUBSTR(RECORD,1,MINUS-1),\n                           || '-',\n                           || SUBSTR(RECORD,MINUS+1)\n                     END\n                     ELSE DO\n                        RECORD = SUBSTR(RECORD,1,MINUS-1),\n                           || '+',\n                           || SUBSTR(RECORD,MINUS+1)\n                     END\n                  ZSTR = TRANSLATE(ZSTR,TO_SIGN2,FROM_SIGN)\n               END\n            USTR = USTR || ZSTR\n            IF LENGTH(USTR) > TORIGHT - TOLEFT + 1,\n               THEN DO\n                  RECORD = SUBSTR(RECORD,1,TOLEFT-1),\n                     || SUBSTR(USTR,LENGTH(USTR)-TORIGHT+TOLEFT),\n                     || SUBSTR(RECORD,TORIGHT+1)\n                  USTRO = LENGTH(USTR) - TORIGHT + TOLEFT - 1\n                  ZEROS  = COPIES('0',USTRO)\n                  IF SUBSTR(USTR,1,USTRO) <> ZEROS THEN OVFL = OVFL + 1\n               END\n               ELSE DO\n                  ZEROS  = COPIES('0',TORIGHT-TOLEFT+1-LENGTH(USTR))\n                  ZEROS  = ZEROS || USTR\n                  RECORD = SUBSTR(RECORD,1,TOLEFT-1),\n                     || ZEROS || SUBSTR(RECORD,TORIGHT+1)\n               END\n         END\n      \"ISREDIT LINE &PNTR = &STR(RECORD)\"\n   END\n\n   STR = OK || '/' || OVFL || '/' || TOT\n   CALL SETMSG '* NO ' STR 'UNPKED $VALID OVER OVERFLOW OVER TOTAL'\n   \"ISREDIT LOCATE\" START\n   \"ISREDIT AUTONUM =\" ANUM\n    SIGNAL EOJ\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nERROR:\n   IF MESG <> '' THEN DO\n      RTN = 20\n      ERRORMSG = '===>' MESG\n   END\n   CALL DISPDOC\n   SIGNAL EOJ\n\nEOJ:\n   X = MSG(SAVEMSG)\n   RETURN RTN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"UNPK - DECIMAL UNPACK BY COLUMNS\"\n   SAY\n   SAY ERRORMSG\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    UNPK    FROM-COL1 FROM-COL2 (TO-COL1 TO-COL2)         \"\n   SAY \"              (-MINUS-COL)  (.A .B)                       \"\n   SAY\n   SAY \"       FROM-COLUMNS ARE REQUIRED. TO-COLUMNS WILL DEFAULT \"\n   SAY \"       TO FROM COLUMNS.  THE MINUS COLUMN AND THE LABEL   \"\n   SAY \"       RANGES ARE OPTIONAL. THE MINUS COLUMN, IF          \"\n   SAY \"       SPECIFIED, RECEIVES THE SIGN IN + OR - FORM, ELSE  \"\n   SAY \"       A MINUS VALUE WILL CAUSE THE LAST TO DIGIT TO BE   \"\n   SAY \"       APPROPRIATELY ZONED (-0 = }, -1 = J, -2 = K, ETC). \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY \"    UNPK      15 18  73 80  .A .B  -14                    \"\n   SAY \"       WILL UNPACK THE CONTENTS OF COLS 15 THRU 18 TO     \"\n   SAY \"       COLUMNS 73 THROUGH 80 IN LINE RANGE .A THRU .B     \"\n   SAY \"       AND PUT THE SIGN IN COLUMN 14.                     \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNTOUCH": {"ttr": 38401, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x95\\x00\\x95\\x00\\x00\\xe4\\xd5\\xe3\\xd6\\xe4\\xc3\\xc8@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 149, "newlines": 149, "modlines": 0, "user": "UNTOUCH"}, "text": "//-YOUR-USERID-U JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  COMPILE FOR UNTOUCH WHICH MAKES SURE EVERY DIRECTORY ENTRY\n//***  FOR A GIVEN PDS IS NULL, THAT IS, HAS NO STATISTICS\n//***\n//C          EXEC     PGM=IEL0AA,REGION=4M,COND=(5,LT),\n//             PARM=('AG,A,NCT,ESD,F(I),NOFLOW,NIS,NOLIST,M,NMI,NEST',\n//             'MAP,OF,OPT(TIME),OP,SZ(MAX),S,STMT,STG,X(F)')\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-PLI-LIB-\n\n UNTOUCH:\n      PROC OPTIONS(MAIN) REORDER;\n\n      DCL  SYSIN        FILE INPUT STREAM\n                        ENV(FB, RECSIZE(080), TOTAL);\n      DCL  SYSUT1       FILE INPUT RECORD SEQL\n                        ENV(F, RECSIZE(256), BLKSIZE(256), TOTAL);\n\n      DCL  1  DIR_BLK           BASED(DIR_BLK_PTR),\n              5  LL             FIXED BIN(15,0),\n              5  DATA           CHAR(254);\n      DCL  1  MEM_OVLY          BASED(MEM_OVLY_PTR),\n             10  MEMBER         CHAR(8),\n             10  TTR            CHAR(3),\n             10  C,\n                15  ALIAS       BIT(1),\n                15  TTR_CNT     BIT(2),\n                15  DATA_CNT    BIT(5),\n             10  ORG_HWDS(39)   CHAR(2);\n\n      DCL  FIRST                FIXED BIN(31) STATIC INIT(00000001);\n      DCL  LAST                 FIXED BIN(31) STATIC INIT(99999999);\n      DCL  FIRSTMEM             CHAR(8) STATIC INIT(' ');\n      DCL  MEM_ARRAY(10240)     CHAR(12) STATIC;\n      DCL  MEM_CNT              FIXED BIN(15) STATIC INIT(0);\n      DCL  II                   FIXED BIN(15) STATIC INIT(0);\n      DCL  LASTMEM              CHAR(8) STATIC INIT('99999999');\n      DCL  BASEDATA             CHAR(12) STATIC;\n\n      DCL  R15                  FIXED BIN(15) STATIC INIT(0);\n      DCL  RC                   FIXED BIN(15) STATIC INIT(0);\n      DCL  WHY                  FIXED BIN(15) STATIC INIT(0);\n      DCL  #RESET               FIXED BIN(31) STATIC INIT(0);\n\n      DCL STOWU  ENTRY(CHAR(12),      /* BASIC MEMBER DATA */\n                       FIXED BIN(15), /* DYNALLOC R15 R/C  */\n                       FIXED BIN(15), /* INFO  ERROR  CODE */\n                       FIXED BIN(15)) /* INFO  REASON CODE */\n                 OPTIONS(ASM);\n\n      DCL  ( MEM_OVLY_PTR, DIR_BLK_PTR )\n                                PTR STATIC;\n      DCL  ( MEMNUM, MASK_CTR, LEN, ICTR, JCTR, I_ORG_CNT )\n                                FIXED BIN(31) STATIC INIT(0);\n      DCL  ( HBOUND, SUBSTR, HIGH, LENGTH, ADDR, INDEX )\n                                BUILTIN;\n\n      OPEN FILE(SYSIN), FILE(SYSUT1);\n      GET DATA FILE(SYSIN);\n      ON ENDFILE(SYSUT1) GOTO I_EOF;\n\n I_READ_LOOP:\n      READ FILE(SYSUT1) SET(DIR_BLK_PTR);\n      LEN = 2;\n      MEM_OVLY_PTR = ADDR(DIR_BLK.DATA);\n\n I_MEM_ROUTINE:\n      IF MEM_OVLY.MEMBER = HIGH(8)\n         THEN GOTO I_EOF;\n      MEMNUM = MEMNUM + 1;\n      IF MEMNUM < FIRST | MEM_OVLY.MEMBER < FIRSTMEM\n         THEN GOTO I_NEXT_MEM;\n      IF MEMNUM > LAST | MEM_OVLY.MEMBER > LASTMEM\n         THEN GOTO I_EOF;\n\n      IF MEM_OVLY.C.DATA_CNT > 0\n         THEN DO;\n            MEM_CNT = MEM_CNT + 1;\n            IF MEM_CNT > HBOUND(MEM_ARRAY,1)\n               THEN DO;\n                  PUT EDIT ('**  ERROR  **  ARRAY EXCEEDS BOUNDS ')\n                           (SKIP(1),A);\n                  CALL PLIRETC(16);\n                  RETURN;\n               END;\n            IF ALIAS = '1'B\n               THEN MEM_ARRAY(MEM_CNT) = MEM_OVLY.MEMBER\n                  || TTR || '80'X;\n               ELSE MEM_ARRAY(MEM_CNT) = MEM_OVLY.MEMBER\n                  || TTR || '00'X;\n         END;\n\n I_NEXT_MEM:\n      I_ORG_CNT = MEM_OVLY.C.DATA_CNT + 1;\n      MEM_OVLY_PTR = ADDR(MEM_OVLY.ORG_HWDS(I_ORG_CNT));\n      LEN = LEN + (2 * I_ORG_CNT) + 10;\n      IF DIR_BLK.LL > LEN\n            THEN GOTO I_MEM_ROUTINE;\n            ELSE GOTO I_READ_LOOP;\n\n I_EOF:\n      DO II = 1 TO MEM_CNT;\n         BASEDATA = MEM_ARRAY(II);\n         CALL STOWU(BASEDATA,R15,RC,WHY);\n         IF R15 > 0\n            THEN DO;\n               PUT EDIT ('**  ERROR  **  MEMBER ', MEM_OVLY.MEMBER,\n                         ', STOW ERROR = ',  R15,\n                         ', REASON CODE = ', RC,\n                         ', OTHER CODE = ',  WHY)\n                        (SKIP(1),A,A,A,P'99999',A,P'-ZZ,ZZ9',\n                         A,P'-ZZ,ZZ9');\n               PUT EDIT ('**         **  BASE DATA = ', BASEDATA)\n                        (SKIP(1),A,A);\n               CALL PLIRETC(16);\n            END;\n            ELSE DO;\n               #RESET = #RESET + 1;\n               PUT EDIT ('**  RESET     **  MEMBER ',\n                         SUBSTR(BASEDATA,1,8))\n                        (SKIP(1),A,A);\n            END;\n      END;\n\n      PUT EDIT ('**  COMPLETE  **  # MEMBERS UNTOUCHED ', #RESET)\n               (SKIP(4),A,P'ZZZ,ZZ9');\n      CLOSE FILE(SYSIN), FILE(SYSUT1);\n      END UNTOUCH;\n\n//SYSUT1       DD       UNIT=VIO,SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(CYL,(5,3))\n//***\n//L          EXEC     PGM=HEWLKED,COND=(5,LT),\n//             PARM='XREF,LIST,LET',\n//             REGION=4M\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//             DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSUT1       DD       UNIT=VIO,SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   01020600\n  ENTRY    PLISTART\n  NAME     UNTOUCH(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UNTOUCH$": {"ttr": 38405, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe4\\xd5\\xe3\\xd6\\xe4\\xc3\\xc8@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "UNTOUCH"}, "text": "//-YOUR-USERID-U JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  REMOVE DIRECTORY STATISTICS\n//***\n//UNTCLIST   EXEC     PGM=UNTOUCH,REGION=8M\n//SYSUT1       DD       DISP=SHR,DSN=...                          <***\n    FIRST=000001, LAST=999999, FIRSTMEM='        ', LASTMEM='99999999';\n//SYSPRINT     DD       SYSOUT=*\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VALUES": {"ttr": 38407, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x01\\x8e\\x01\\x8e\\x00\\x00\\xe5\\xc1\\xd3\\xe4\\xc5\\xe2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 398, "newlines": 398, "modlines": 0, "user": "VALUES"}, "text": "//-YOUR-USERID-V JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//***  SUMMARIZE VALUES IN SPECIFIC COLUMNS IN A FILE\n//***\n//C          EXEC     PGM=IEL0AA,REGION=4M,\n//             PARM=('AG,A,NCT,ESD,F(I),NOFLOW,NIS,NOLIST,M,NMI,NEST',\n//             'MAP,OF,OPT(TIME),OP,SZ(MAX),S,STMT,STG,X(F)')\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-PLI-LIB-\n\n VALUES: PROC(PARM) OPTIONS(MAIN) REORDER;\n\n    DCL  PARM          CHAR(00100) VARYING;\n    DCL  REC           CHAR(32760) STATIC VARYING;\n    DCL  REC#          FIXED BIN(31) STATIC INIT(0);\n    DCL  I_EOF_IND     CHAR(01) STATIC INIT('N');\n    DCL  SYSIN_EOF_IND CHAR(01) STATIC INIT('N');\n\n    DCL  1  COL_PAIRS(1024) STATIC,\n          10  LINK_PTR      PTR,\n          10  #VALUES       FIXED BIN(31),\n          10  FIRST_COL     FIXED BIN(15),\n          10  SECOND_COL    FIXED BIN(15),\n          10  LEN_COL       FIXED BIN(15),\n          10  THRU_TYPE     CHAR(01),\n          10  DESC_COL      CHAR(50);\n    DCL  1  SAMPLE          BASED,\n          10  NEXT_PTR      PTR,\n          10  OCCURS        FIXED BIN(31),\n          10  VALUE         CHAR(32760);\n    DCL  COL_PAIRS#         FIXED BIN(15) STATIC INIT(0);\n    DCL  (II,JJ,KK)         FIXED BIN(31) STATIC INIT(0);\n    DCL  (LL,MM,NN)         FIXED BIN(31) STATIC INIT(0);\n    DCL  XX                 CHAR(*)  CTL;\n    DCL  PTR_TBL(*)         PTR      CTL;\n    DCL  TEMP_PTR           PTR STATIC;\n\n    DCL  ADDR               BUILTIN;\n    DCL  NULL               BUILTIN;\n    DCL  SUBSTR             BUILTIN;\n    DCL  TRANSLATE          BUILTIN;\n    DCL  VERIFY             BUILTIN;\n\n    DCL  HEX_LINE1          CHAR(256) STATIC;\n      HEX_LINE1\n             = (16)'0' || (16)'1' || (16)'2' || (16)'3'\n            || (16)'4' || (16)'5' || (16)'6' || (16)'7'\n            || (16)'8' || (16)'9' || (16)'A' || (16)'B'\n            || (16)'C' || (16)'D' || (16)'E' || (16)'F' ;\n    DCL  HEX_LINE2          CHAR(256) STATIC\n         INIT( (16)'0123456789ABCDEF' );\n    DCL  PRINTABLE_CHARACTERS  CHAR(256) STATIC;\n       PRINTABLE_CHARACTERS\n          =    ' !@#$%&*()_+-=0123456789{}|\u00ac\u00a6\\:\";''<>?,./'\n            || 'abcdefghijklmnopqrstuvwxyz'\n            || 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' ;\n    DCL  PRINTABLE             CHAR(256) STATIC VARYING;\n\n\n    ON ENDFILE(SYSIN) SYSIN_EOF_IND = 'Y';\n    READ FILE(SYSIN) INTO(REC);\n\n    DO WHILE ( SYSIN_EOF_IND = 'N' );\n       COL_PAIRS# = COL_PAIRS# + 1;\n       FIRST_COL(COL_PAIRS#)  = SUBSTR(REC,01,05);\n       SECOND_COL(COL_PAIRS#) = SUBSTR(REC,07,05);\n       THRU_TYPE(COL_PAIRS#)  = SUBSTR(REC,06,01);\n       LEN_COL(COL_PAIRS#)    = SECOND_COL(COL_PAIRS#)\n          - FIRST_COL(COL_PAIRS#) + 1;\n       DESC_COL(COL_PAIRS#)   = SUBSTR(REC,12,50);\n       #VALUES(COL_PAIRS#)    = 1;\n       READ FILE(SYSIN) INTO(REC);\n    END;\n\n\n    ON ENDFILE(I) I_EOF_IND = 'Y';\n    READ FILE(I) INTO(REC);\n    IF I_EOF_IND  = 'N'\n       THEN DO;\n          REC# = REC# + 1;\n          DO II = 1 TO COL_PAIRS#;\n             IF THRU_TYPE(II) = '-'\n                THEN DO;\n                   JJ = 8 + LEN_COL(II);\n                   ALLOC XX CHAR(JJ);\n                   LINK_PTR(II) = ADDR(XX);\n                   LINK_PTR(II) -> NEXT_PTR = NULL;\n                   LINK_PTR(II) -> OCCURS   = 1;\n                   SUBSTR(LINK_PTR(II) -> VALUE,1,LEN_COL(II))\n                      = SUBSTR(REC,FIRST_COL(II),LEN_COL(II));\n                END;\n                ELSE DO;\n                   ALLOC XX CHAR(9);\n                   LINK_PTR(II) = ADDR(XX);\n                   LINK_PTR(II) -> NEXT_PTR = NULL;\n                   LINK_PTR(II) -> OCCURS   = 1;\n                   SUBSTR(LINK_PTR(II) -> VALUE,1,1)\n                      = SUBSTR(REC,FIRST_COL(II),1);\n                   DO LL = 1 TO (LEN_COL(II)-1);\n                      TEMP_PTR = LINK_PTR(II);\n                      DO WHILE ( TEMP_PTR \u00ac= NULL );\n                         IF SUBSTR(TEMP_PTR -> VALUE,1,1)\n                               = SUBSTR(REC,FIRST_COL(II)+LL,1)\n                            THEN DO;\n                               TEMP_PTR -> OCCURS\n                                  = TEMP_PTR -> OCCURS + 1;\n                               TEMP_PTR = NULL;\n                            END;\n                            ELSE DO;\n                               TEMP_PTR = TEMP_PTR -> NEXT_PTR;\n                               IF TEMP_PTR = NULL\n                                  THEN DO;\n                                     #VALUES(II) = #VALUES(II) + 1;\n                                     ALLOC XX CHAR(9);\n                                     TEMP_PTR = LINK_PTR(II);\n                                     LINK_PTR(II) = ADDR(XX);\n                                     LINK_PTR(II) -> NEXT_PTR\n                                        = TEMP_PTR;\n                                     LINK_PTR(II) -> OCCURS = 1;\n                                     SUBSTR(LINK_PTR(II) -> VALUE,1,1)\n                                       = SUBSTR(REC,FIRST_COL(II)+ll,1);\n                                     TEMP_PTR = NULL;\n                                  END;\n                            END;\n                      END;\n                   END;\n                END;\n          END;\n       END;\n\n    IF I_EOF_IND  = 'N'\n       THEN READ FILE(I) INTO(REC);\n\n    DO WHILE ( I_EOF_IND  = 'N' );\n       REC# = REC# + 1;\n       DO II = 1 TO COL_PAIRS#;\n          IF THRU_TYPE(II) = '-'\n             THEN DO;\n                TEMP_PTR = LINK_PTR(II);\n                DO WHILE ( TEMP_PTR \u00ac= NULL );\n                   IF SUBSTR(TEMP_PTR -> VALUE,1,LEN_COL(II))\n                         = SUBSTR(REC,FIRST_COL(II),LEN_COL(II))\n                      THEN DO;\n                         TEMP_PTR -> OCCURS = TEMP_PTR -> OCCURS + 1;\n                         TEMP_PTR = NULL;\n                      END;\n                      ELSE DO;\n                         TEMP_PTR = TEMP_PTR -> NEXT_PTR;\n                         IF TEMP_PTR = NULL\n                            THEN DO;\n                               #VALUES(II) = #VALUES(II) + 1;\n                               JJ = 8 + LEN_COL(II);\n                               ALLOC XX CHAR(JJ);\n                               TEMP_PTR     = LINK_PTR(II);\n                               LINK_PTR(II) = ADDR(XX);\n                               LINK_PTR(II) -> NEXT_PTR\n                                  = TEMP_PTR;\n                               LINK_PTR(II) -> OCCURS   = 1;\n                               SUBSTR(LINK_PTR(II)\n                                     -> VALUE,1,LEN_COL(II))\n                                  = SUBSTR(REC,FIRST_COL(II),\n                                     LEN_COL(II));\n                               TEMP_PTR = NULL;\n                            END;\n                      END;\n                END;\n             END;\n             ELSE DO;\n                DO LL = 0 TO (LEN_COL(II)-1);\n                   TEMP_PTR = LINK_PTR(II);\n                   DO WHILE ( TEMP_PTR \u00ac= NULL );\n                      IF SUBSTR(TEMP_PTR -> VALUE,1,1)\n                            = SUBSTR(REC,FIRST_COL(II)+LL,1)\n                         THEN DO;\n                            TEMP_PTR -> OCCURS\n                               = TEMP_PTR -> OCCURS + 1;\n                            TEMP_PTR = NULL;\n                         END;\n                         ELSE DO;\n                            TEMP_PTR = TEMP_PTR -> NEXT_PTR;\n                            IF TEMP_PTR = NULL\n                               THEN DO;\n                                  #VALUES(II) = #VALUES(II) + 1;\n                                  ALLOC XX CHAR(9);\n                                  TEMP_PTR = LINK_PTR(II);\n                                  LINK_PTR(II) = ADDR(XX);\n                                  LINK_PTR(II) -> NEXT_PTR\n                                     = TEMP_PTR;\n                                  LINK_PTR(II) -> OCCURS   = 1;\n                                  SUBSTR(LINK_PTR(II) -> VALUE,1,1)\n                                    = SUBSTR(REC,FIRST_COL(II)+ll,1);\n                                  TEMP_PTR = NULL;\n                               END;\n                         END;\n                   END;\n                END;\n             END;\n       END;\n       READ FILE(I) INTO(REC);\n    END;\n\n\n    IF PARM = ''\n       THEN;\n       ELSE IF PARM = 'VALUES'\n          THEN DO;\n             DO II = 1 TO COL_PAIRS#;\n                IF THRU_TYPE(II) = '-'\n                   THEN DO;\n                      ALLOC PTR_TBL(#VALUES(II));\n                      TEMP_PTR   = LINK_PTR(II);\n                      DO JJ = 1 TO #VALUES(II);\n                         PTR_TBL(JJ) = TEMP_PTR;\n                         TEMP_PTR    = TEMP_PTR -> NEXT_PTR;\n                      END;\n                      DO JJ = 1 TO #VALUES(II) - 1;\n                         DO KK = JJ + 1 TO #VALUES(II);\n                            IF SUBSTR(PTR_TBL(JJ)\n                                     -> VALUE,1,LEN_COL(II))\n                                  > SUBSTR(PTR_TBL(KK)\n                                     -> VALUE,1,LEN_COL(II))\n                               THEN DO;\n                                  TEMP_PTR    = PTR_TBL(JJ);\n                                  PTR_TBL(JJ) = PTR_TBL(KK);\n                                  PTR_TBL(KK) = TEMP_PTR;\n                               END;\n                         END;\n                      END;\n                      LINK_PTR(II) = PTR_TBL(1);\n                      TEMP_PTR     = PTR_TBL(1);\n                      DO JJ = 2 TO #VALUES(II);\n                         TEMP_PTR -> NEXT_PTR = PTR_TBL(JJ);\n                         TEMP_PTR             = PTR_TBL(JJ);\n                      END;\n                      TEMP_PTR -> NEXT_PTR = NULL;\n                      FREE PTR_TBL;\n                   END;\n                   ELSE DO;\n                      ALLOC PTR_TBL(#VALUES(II));\n                      TEMP_PTR   = LINK_PTR(II);\n                      DO JJ = 1 TO #VALUES(II);\n                         PTR_TBL(JJ) = TEMP_PTR;\n                         TEMP_PTR    = TEMP_PTR -> NEXT_PTR;\n                      END;\n                      DO JJ = 1 TO #VALUES(II) - 1;\n                         DO KK = JJ + 1 TO #VALUES(II);\n                            IF SUBSTR(PTR_TBL(JJ)\n                                     -> VALUE,1,1)\n                                  > SUBSTR(PTR_TBL(KK)\n                                     -> VALUE,1,1)\n                               THEN DO;\n                                  TEMP_PTR    = PTR_TBL(JJ);\n                                  PTR_TBL(JJ) = PTR_TBL(KK);\n                                  PTR_TBL(KK) = TEMP_PTR;\n                               END;\n                         END;\n                      END;\n                      LINK_PTR(II) = PTR_TBL(1);\n                      TEMP_PTR     = PTR_TBL(1);\n                      DO JJ = 2 TO #VALUES(II);\n                         TEMP_PTR -> NEXT_PTR = PTR_TBL(JJ);\n                         TEMP_PTR             = PTR_TBL(JJ);\n                      END;\n                      TEMP_PTR -> NEXT_PTR = NULL;\n                      FREE PTR_TBL;\n                   END;\n             END;\n          END;\n          ELSE IF PARM = 'OCCURS'\n             THEN DO;\n                DO II = 1 TO COL_PAIRS#;\n                   ALLOC PTR_TBL(#VALUES(II));\n                   TEMP_PTR   = LINK_PTR(II);\n                   DO JJ = 1 TO #VALUES(II);\n                      PTR_TBL(JJ) = TEMP_PTR;\n                      TEMP_PTR    = TEMP_PTR -> NEXT_PTR;\n                   END;\n                   DO JJ = 1 TO #VALUES(II) - 1;\n                      DO KK = JJ + 1 TO #VALUES(II);\n                         IF PTR_TBL(JJ) -> OCCURS\n                               < PTR_TBL(KK) -> OCCURS\n                            THEN DO;\n                              TEMP_PTR    = PTR_TBL(JJ);\n                              PTR_TBL(JJ) = PTR_TBL(KK);\n                              PTR_TBL(KK) = TEMP_PTR;\n                            END;\n                      END;\n                   END;\n                   LINK_PTR(II) = PTR_TBL(1);\n                   TEMP_PTR     = PTR_TBL(1);\n                   DO JJ = 2 TO #VALUES(II);\n                      TEMP_PTR -> NEXT_PTR = PTR_TBL(JJ);\n                      TEMP_PTR             = PTR_TBL(JJ);\n                   END;\n                   TEMP_PTR -> NEXT_PTR = NULL;\n                   FREE PTR_TBL;\n                END;\n             END;\n\n\n    PUT EDIT ('RECORD COUNT =', REC#)\n             (SKIP(1), A, P'Z,ZZZ,ZZZ,ZZ9');\n\n    DO II = 1 TO COL_PAIRS#;\n       IF THRU_TYPE(II) = '-'\n          THEN DO;\n             TEMP_PTR = LINK_PTR(II);\n             PUT EDIT ('COLUMN(S) ', FIRST_COL(II), '-',\n                       SECOND_COL(II), ' CONTAIN ', #VALUES(II),\n                       ' UNIQUE VALUE(S) -- ', DESC_COL(II))\n                      (SKIP(2), A, P'ZZZZ9', A, P'ZZZZ9',\n                       A, P'Z,ZZZ,ZZZ,ZZ9', A, A);\n             DO WHILE ( TEMP_PTR \u00ac= NULL );\n                IF VERIFY(SUBSTR(TEMP_PTR -> VALUE,1,LEN_COL(II)),\n                      PRINTABLE_CHARACTERS) = 0\n                   THEN DO;\n                      PUT EDIT ('   ', TEMP_PTR -> OCCURS, ' >>',\n                                SUBSTR(TEMP_PTR -> VALUE,1,LEN_COL(II)),\n                                '<<')\n                               (SKIP(1), A, P'Z,ZZZ,ZZZ,ZZ9', A, A, A);\n                      TEMP_PTR = TEMP_PTR -> NEXT_PTR;\n                   END;\n                   ELSE DO;\n                      PRINTABLE = SUBSTR(TEMP_PTR\n                         -> VALUE,1,LEN_COL(II));\n                      PRINTABLE = TRANSLATE(PRINTABLE,HEX_LINE1);\n                      PUT EDIT ('                 >>',\n                                PRINTABLE, '<<')\n                               (SKIP(1), A, A, A);\n                      PRINTABLE = SUBSTR(TEMP_PTR\n                         -> VALUE,1,LEN_COL(II));\n                      PRINTABLE = TRANSLATE(PRINTABLE,HEX_LINE2);\n                      PUT EDIT ('   ', TEMP_PTR -> OCCURS, ' >>',\n                                PRINTABLE, '<<')\n                               (SKIP(1), A, P'Z,ZZZ,ZZZ,ZZ9', A, A, A);\n                      TEMP_PTR = TEMP_PTR -> NEXT_PTR;\n                   END;\n             END;\n          END;\n          ELSE DO;\n             TEMP_PTR = LINK_PTR(II);\n             PUT EDIT ('COLUMN(S) ', FIRST_COL(II), ' THRU ',\n                       SECOND_COL(II), ' HAVE ', #VALUES(II),\n                       ' UNIQUE VALUE(S) -- ', DESC_COL(II))\n                      (SKIP(2), A, P'ZZZZ9', A, P'ZZZZ9',\n                       A, P'Z,ZZZ,ZZZ,ZZ9', A, A);\n             DO WHILE ( TEMP_PTR \u00ac= NULL );\n                IF VERIFY(SUBSTR(TEMP_PTR -> VALUE,1,1),\n                      PRINTABLE_CHARACTERS) = 0\n                   THEN DO;\n                      PUT EDIT ('   ', TEMP_PTR -> OCCURS, ' >>',\n                                SUBSTR(TEMP_PTR -> VALUE,1,1),\n                                '<<')\n                               (SKIP(1), A, P'Z,ZZZ,ZZZ,ZZ9', A, A, A);\n                      TEMP_PTR = TEMP_PTR -> NEXT_PTR;\n                   END;\n                   ELSE DO;\n                      PRINTABLE = SUBSTR(TEMP_PTR\n                         -> VALUE,1,1);\n                      PRINTABLE = TRANSLATE(PRINTABLE,HEX_LINE1);\n                      PUT EDIT ('                 >>',\n                                PRINTABLE, '<<')\n                               (SKIP(1), A, A, A);\n                      PRINTABLE = SUBSTR(TEMP_PTR\n                         -> VALUE,1,1);\n                      PRINTABLE = TRANSLATE(PRINTABLE,HEX_LINE2);\n                      PUT EDIT ('   ', TEMP_PTR -> OCCURS, ' >>',\n                                PRINTABLE, '<<')\n                               (SKIP(1), A, P'Z,ZZZ,ZZZ,ZZ9', A, A, A);\n                      TEMP_PTR = TEMP_PTR -> NEXT_PTR;\n                   END;\n             END;\n          END;\n    END;\n\n\n    END VALUES;\n\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(CYL,(05,02))\n//***\n//L          EXEC     PGM=HEWLKED,\n//             PARM='XREF,LIST,LET,DCBS,AMODE=31,RMODE=ANY',\n//             REGION=4M\n//SYSLIB       DD       DISP=SHR,DSN=-YOUR-SCEELLED-\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE)\n//             DD       *\n  SETSSI   00060600\n  ENTRY    PLISTART\n  NAME     VALUES(R)\n//***\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VALUES$": {"ttr": 38414, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe5\\xc1\\xd3\\xe4\\xc5\\xe2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "VALUES"}, "text": "//-YOUR-USERID-V JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//SUMMARY    EXEC     PGM=VALUES,REGION=464M,\n//             PARM='HEAP(01M,01M,ANYWHERE)/VALUES'\n//I            DD       DISP=SHR,DCB=BUFNO=32,\n//             DSN=...\n//SYSIN        DD       *\n00026-00030 SOME COMMENT...\n    ...     COL 5 <> '-' MEANS SUMMARIZE AS IF INDIVIDUAL BYTES\n    ...        AS MANY FIELDS AS DESIRED\n    ...           ANYTHING AFTER COLUMN 11 IS CONSIDERED A COMMENT\n    ...           AND DISPLAYED ON THE SYSPRINT REPORT\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//SYSPRINT     DD       SYSOUT=*\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VERASE": {"ttr": 38657, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\x10\\x00\\x10\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- Clear Profile Pool CUTX Entries & zero CutCnt  **/\n\n   Address ISPEXEC\n   'ISREDIT MACRO NOPROCESS'\n   RetCode = 0\n   Do ii = 1 to 99999  Until( RetCode <> 0 )\n       'VERASE (CL'ii') PROFILE'\n       RetCode = RC\n   End\n\n   CutCnt = 0\n   'VPUT (CUTCNT) PROFILE'\n\n   ii = ii - 1\n   Say 'Cleared' ii 'Profile Entries and reset CutCnt to zero...'\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VSAVE": {"ttr": 38659, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x02%\\x7f\\x01\\x02%\\x7f\\x12\\x00\\x00\\x80\\x00\\x80\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2002-09-14T12:00:00", "lines": 128, "newlines": 128, "modlines": 0, "user": "REXX"}, "text": "/** REXX - SAVE command for VIEW **************************************/\n/*                                                                    */\n/* Provides the equivalent of the SAVE command in a View session.     */\n/* It uses REPLACE to write the data and LMMSTATS to set the          */\n/* statistics.                                                        */\n/*                                                                    */\n/**********************************************************************/\n   ADDRESS 'ISPEXEC'\n   ADDRESS ISPEXEC \"ISREDIT MACRO (PARMS)\"\n   IF SUBSTR(PARMS,1,1) = '?' THEN SIGNAL DISPDOC\n   IF RC > 0 THEN EXIT RC /* not an EDIT macro */\n   \"CONTROL ERRORS RETURN\"\n   \"ISREDIT (zdsn) = DATASET\"\n   \"ISREDIT (zmemb) = MEMBER\"\n   IF ZMEMB='' THEN CALL PROCESS_SEQUENTIAL_DATA_SET\n/*------------------------------------------------------------------*/\n/*     Fast-path processing when STATS=OFF                          */\n/*------------------------------------------------------------------*/\n   \"ISREDIT (stats) = STATS\"\n   IF STATS='OFF' THEN DO\n      \"ISREDIT REPLACE\" ZMEMB \".ZFIRST .ZLAST\"\n      CALL CHECK_RC RC,0,'REPLACE'\n      \"SETMSG MSG(ISRE016)\"\n      EXIT\n   END\n/*------------------------------------------------------------------*/\n/*     Prevent LMMSTATS failure when VERSION=00                     */\n/*------------------------------------------------------------------*/\n   \"ISREDIT (zlvers) = VERSION\"\n   IF ZLVERS = 0 THEN DO\n      ZEDSMSG = \"Invalid Version\"\n      ZEDLMSG = \"Version 00 is not supported by the LMMSTATS service\".\n         \"SETMSG MSG(ISRZ001)\"\n      EXIT 4             /* not supported in this release */\n   END\n/*------------------------------------------------------------------*/\n/*     Retrieve current statistics from member's directory entry    */\n/*------------------------------------------------------------------*/\n   \"ISREDIT (dataid) = DATAID\"\n   \"LMOPEN DATAID(\"DATAID\")\"\n   CALL CHECK_RC RC,0,'LMOPEN'\n   \"LMMFIND DATAID(\"DATAID\") MEMBER(\"ZMEMB\") STATS(YES)\"\n   LMMFIND_RC=RC\n   CALL CHECK_RC RC,8,'LMMFIND'\n/*------------------------------------------------------------------*/\n/*     Rewrite member using the REPLACE command                     */\n/*------------------------------------------------------------------*/\n   \"ISREDIT (n1,n2) = NUMBER\"\n   MODLINES=0 /* modified lines  */\n   IF N1='ON' & LEFT(N2,1)='S' THEN DO  /* NUMBER ON STD   */\n      \"ISREDIT (ustat) = USER_STATE\" /* push user_state */\n      CALL COUNT_MODLINES /* Cound modified lines   */\n      \"ISREDIT REPLACE\" ZMEMB \".ZF .ZL\"\n      XRC = RC\n      \"ISREDIT USER_STATE = (ustat)\" /* pop user_state  */\n      CALL CHECK_RC XRC,0,'REPLACE'\n   END\n   ELSE DO /* NUMBER OFF      */\n      \"ISREDIT REPLACE\" ZMEMB \".ZF .ZL\"\n      CALL CHECK_RC RC,0,'REPLACE'\n   END\n/*------------------------------------------------------------------*/\n/*     Update statistics using LMMSTATS                             */\n/*------------------------------------------------------------------*/\n   \"ISREDIT (zlvers) = VERSION\" /* NEW VERSION   */\n   \"ISREDIT (zlmod) = LEVEL\" /* NEW LEVEL     */\n   IF LMMFIND_RC=8 THEN /* new member    */\n      \"LMMSTATS DATAID(\"DATAID\") MEMBER(\"ZMEMB\")\" \"VERSION(\"ZLVERS\") ,\n      MODLEVEL(\"ZLMOD\")\" \"MODRECS(\"MODLINES+0\")\"\n   ELSE /* member existed before */\n      \"LMMSTATS DATAID(\"DATAID\") MEMBER(\"ZMEMB\")\" \"VERSION(\"ZLVERS\") ,\n      MODLEVEL(\"ZLMOD\")\" \"CREATED(\"ZLCDATE\") INITSIZE(\"ZLINORC\")\" ,\n      \"MODRECS(\"MODLINES+0\")\"\n   CALL CHECK_RC RC,0,'LMMSTATS'\n/*------------------------------------------------------------------*/\n/*     Issue completion message and exit                            */\n/*------------------------------------------------------------------*/\n   \"LMCLOSE DATAID(\"DATAID\")\"\n   CALL CHECK_RC RC,0,'LMCLOSE'\n   \"SETMSG MSG(ISRE016)\" /* member zmemb saved */\n   EXIT\n/*------------------------------------------------------------------*/\n/*     Count_modlines internal function: Count modified lines       */\n/*------------------------------------------------------------------*/\nCOUNT_MODLINES:\n   \"ISREDIT NUMBER OFF\"\n   \"ISREDIT (recfm) = RECFM\"\n   IF RECFM='F' THEN\n      \"ISREDIT (lrecl) = LRECL\"\n   ELSE\n      LRECL=8 /* RECFM=V        */\n   \"ISREDIT (modlines) = LINENUM .ZL\" /* total number of lines*/\n   \"ISREDIT SEEK '00' ALL\" LRECL-1 /*count unmodified lines*/\n   IF RC=0 THEN\n      DO\n         \"ISREDIT (c1,c2) = SEEK_COUNTS\"\n         MODLINES=MODLINES-C1 /* modified lines*/\n      END\n/*------------------------------------------------------------------*/\n/*           Process a sequential data set                          */\n/*------------------------------------------------------------------*/\nPROCESS_SEQUENTIAL_DATA_SET:\n   \"ISREDIT REPLACE '\"zdsn\"'\" .zfirst .zlast\n   \"SETMSG MSG(ISRE016)\"\n   EXIT\n/*------------------------------------------------------------------*/\n/*           Error routine                                          */\n/*------------------------------------------------------------------*/\nCHECK_RC:\n   IF ARG(1) \\> ARG(2) THEN RETURN /* RC=0 */\n   \"SETMSG MSG(\"ZERRMSG\")\"\n   \"LMCLOSE DATAID(\"DATAID\")\"\n   EXIT 20\n/*------------------------------------------------------------------*/\n/*           Built-in Help                                          */\n/*------------------------------------------------------------------*/\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"VSAVE -- SAVES FILE/MEMBER FROM WITHIN VIEW            \"\n   SAY\n   SAY \"  VSAVE   ( ? )                                        \"\n   SAY\n   SAY \"  WILL SAVE EITHER A VIEWED MEMBER OR SEQUENTIAL FILE, \"\n   SAY \"  WITHOUT HAVING TO DO A MANUAL REPLACE. THE ONLY      \"\n   SAY \"  PARAMETER, A QUESTION MARK (?), CAUSES THIS VERY     \"\n   SAY \"  MINIMAL HELP TO BE DISPLAYED.                        \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VW": {"ttr": 38662, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x9b\\x00\\x9b\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 155, "newlines": 155, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- VIEW  **/\n   ZEDLMSG = \"\"\n   RSLT = \"\"\n   SAVEMSG = MSG()\n   if SAVEMSG = 'ON'  then  X = MSG(\"OFF\")\n   MSGTYPE = \"ISRZ001\"\n   X = ADDRESS()\n   SUBCOM ISREDIT\n   if RC <> 0  then do\n        UMODE = \"NATIVE\"\n        ARG FNAME VOLSER\n        SETMSG = \"     Must be run under ISPF\"\n        call SETM\n        RSLT = \" NOT in ISPF - UNABLE to run.\"\n        signal BYEBYE\n   end\n   address ISPEXEC \"CONTROL ERRORS RETURN\"\n   address ISREDIT \"ISREDIT MACRO (\"FNAME\",\"VOLSER\")\"\n   if RC <> 0  then do\n        UMODE = \"ISPEXEC\"\n        ARG FNAME VOLSER\n   end\n   else  do\n      UMODE = \"ISREDIT\"\n      address ISREDIT \"ISREDIT (\"LIN\",\"COL\") = CURSOR\"\n   end\n\nCHKDSN:\n   WFILE = \"\"\n   if FNAME = \"\"  then do\n      SETMSG = \"     You must supply the DSN to VIEW.\",\n         \"  I.E. VIEW 'some.filename'\"\n      call SETM\n      RSLT = \"NO DSN SUPPLIED\"\n      signal BYEBYE\n   end\n   if substr(FNAME,1,1)=\"'\" & substr(FNAME,length(FNAME),1)=\"'\" then do\n      LEN = length(FNAME)-2\n      WFILE = substr(FNAME,2,LEN)\n      signal BROWSIT\n   end\n   call UPROFREX\n   PROFILE = RESULT\n   if index(PROFILE,'NOPREFIX') = 0    then  WFILE = USERID()\".\"FNAME\n   else WFILE = FNAME\n\nBROWSIT:\n   upper WFILE\n   if VOLSER = \"\"  &  sysdsn(''''WFILE'''') <> 'OK'  then do\n      SETMSG= \"     Can't find \"WFILE\". It may not be CATALOGED or\",\n              \"you didn't spell the file correctly, or you didn't use\",\n              \"QUOTES if they were required, or file may be HELD by \",\n              \"another task.\"\n      call SETM\n      RSLT = \"NOT FOUND\"\n      signal BYEBYE\n   end\n   if VOLSER = \"\" then Address ISPEXEC \"SELECT PGM(ISPSTRT)\",\n      \"PARM(CMD(ISREPDF '\"WFILE\"' V))\"\n   else address ISPEXEC \"VIEW DATASET('\"WFILE\"') VOLUME(\"VOLSER\")\"\n   BRC = RC\n   if BRC = 0  then do\n      RSLT = \"FOUND\"\n      signal OKVIEW\n   end\n\n   X = VSAMCHK(WFILE)\n   if X = 1  then do\n      SETMSG = \"     \"WFILE\" is a VSAM file. Cannot VIEW it.\"\n      call SETM\n      RSLT = \"NO ACTION-VSAM FILE\"\n      signal BYEBYE\n   end\n\n   VOLS = GVOLS(WFILE)\n   VOLCNT = words(VOLS)\n   if VOLCNT = 1  then do\n      if VOLSER <> \"\" then VOLDATA = \"VOLUME(\"VOLSER\")\"\n      else VOLDATA = \"\"\n      D=LISTDSI((FNAME) VOLDATA 'NODIRECTORY')\n      if D <> 0  then do\n         SETMSG = \"     \"WFILE\", VOL \"VOLDATA\" LISTDSI error. RC=\",\n                 D\". \"SYSMSGLVL2\n         call SETM\n         RSLT = \"LISTDSI ERR. RC=\"D\n         signal BYEBYE\n      end\n      if SYSUSED = 0  then do\n         SETMSG = \"     \"WFILE\" contains NO data. Nothing to VIEW.\"\n         call SETM\n         RSLT = \"NO ACTION-EMPTY FILE\"\n         signal BYEBYE\n      end\n      if substr(SYSDSORG,1,1)<>'P' then do\n         SETMSG = \"     Can't VIEW \"WFILE\".  DSORG=\"SYSDSORG\".\"\n         call SETM\n         RSLT = \"NO ACTION-DSORG=\"SYSDSORG\n         signal BYEBYE\n      end\n   end\n\n   VOLSER = word(VOLS,VOLCNT)\n\n   SETMSG = \"     \"WFILE\" was multi-volume, residing on \"VOLS\".\"\n\n   call SETM\n   address ISPEXEC \"VIEW DATASET('\"WFILE\"') VOLUME(\"VOLSER\")\"\n   BRC = RC\n   if BRC = 0  then do\n      RSLT=\" ON \"VOLCNT\" VOLS\"\n      signal OKVIEW\n   end\n\n   QUIT = 'N'\n   do V = VOLCNT TO 1 BY -1\n      if QUIT='Y' then\n         NOP\n      else do\n         VOLSER = word(VOLS,V)\n         address ISPEXEC \"VIEW DATASET('\"WFILE\"') VOLUME(\"VOLSER\") \"\n         BRC = RC\n         if BRC = 0 then QUIT = \"Y\"\n      end\n   end\n\n   if BRC = 0 then do\n      RSLT = \" ON \"VOLCNT\" VOLS-TRUNC\"\n      signal OKVIEW\n   end\n\nHUH:\n   SETMSG = \"     \"WFILE\" on \"VOLS\" cannot be VIEWED.\",\n            \"'VIEW' RC=\"BRC\n   call SETM\n   RSLT = \"NO ACTION-VIEW ERROR RC =\" BRC\n   signal BYEBYE\n\nOKVIEW:\n   MSGTYPE = \"ISRZ000\"\n   signal BYEBYE\n\nBYEBYE:\n   if UMODE <> \"NATIVE\" then address ispexec \"SETMSG MSG(\"MSGTYPE\")\"\n   else say ZEDLMSG\n   if SAVEMSG='ON'  then X=MSG(\"ON\")\n   EXIT  0\n\nSETM:\n   if UMODE <> \"NATIVE\" then\n      ZEDLMSG = center(REX||VERSION,74,' ')\n   else\n      ZEDLMSG = center(REX||VERSION,77,' ')\n   ZEDLMSG = \">\"ZEDLMSG\"<\"\n   ZEDLMSG = ZEDLMSG || SETMSG\n   return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VWV": {"ttr": 38666, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00i\\x00i\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 105, "newlines": 105, "modlines": 0, "user": "REXX"}, "text": "/** REXX -- REPRO a VSAM file to a sequential copy and View it **/\n   Parse Arg Dsn\n   Msg = Msg(Off)\n   Dsn = Translate(Dsn)\n   If substr(Dsn,1,1) = \"?\" | Dsn = \"\" then signal DISPDOC\n   Parms = ''\n   If words(Dsn) > 1 then do\n      Do ii = length(Dsn) to 1 by -1,\n            while(substr(Dsn,ii,1) <> ' ' & substr(Dsn,ii,1) <> ') ')\n      End ii\n      Parms = substr(Dsn,1,ii)\n      Dsn   = substr(Dsn,ii+1)\n   End\n   'ISPEXEC CONTROL ERRORS RETURN'\n   If SysDsn(Dsn) <> 'OK' then DO\n       ZedSmsg=''\n       'ISPEXEC SETMSG MSG(ISRZ000)'\n       Exit(12)\n   End\n   now     = Time(s)\n   Gdd     ='F'  || now\n   Flat    ='FL' || now\n   Vsam    ='VS' || now\n   FlatDSN = '$$$TEMP.VSAM.FLAT.' || Flat\n   'ALLOC DD('Vsam') DSN('Dsn') SHR REUSE'\n   Call GetFileAttr\n   'ALLOC F('Flat') NEW CAT REU RECFM('Recfm')',\n      'LRECL('Lrecl') BLKSIZE(0)',\n      'CYL SP(20 20) RELEASE DSORG(PS) DSN('FlatDSN')'\n   If Rc <> 0 Then do\n       Say '* ERROR allocation for' Flat 'failed with code' RC\n       Exit(12)\n   End\n   'REPRO IFI('Vsam') OFI('Flat')' Parms\n   'FREE DD('Vsam' 'Flat' ifi ofi)'\n   'FREE DSN('Dsn FlatDSN')'\n   ZedSmsg=''\n   ZedLmsg=''\n   Address ISPEXEC \"SELECT PGM(ISPSTRT)\",\n      \"PARM(CMD(ISREPDF \"FlatDSN\" V))\"\n   Exit\n\nGetFileAttr:\n   'ALLOC F('Gdd') NEW DEL REU RECFM(V B)',\n      'LRECL(129) BLKSIZE(0) TR SP(5)',\n       'DSORG(PS)'\n   'LISTCAT ENT('Dsn') ALL OUTFILE('Gdd')'\n   'EXECIO * DISKR 'Gdd' (STEM LCDATA. FINIS)'\n   'FREE F('Gdd')'\n\n   AvgLrecl = 0\n   MaxLrecl = 0\n   Do x = 3 to LcData.0 while(AvgLrecl = 0 | MaxLrecl = 0)\n      If index(LcData.x,'AVGLRECL') <> 0 Then do\n         ii = index(LcData.x,'AVGLRECL')\n         do jj = (ii+8) to 125 while(substr(LcData.x,jj,1) = '-')\n         end jj\n         do kk = (jj+1) to 125 while(substr(LcData.x,kk,1) <> ' ')\n         end kk\n         AvgLrecl = substr(LcData.x,jj,kk-jj)\n      End\n      If index(LcData.x,'MAXLRECL') <> 0 Then do\n         ii = index(LcData.x,'MAXLRECL')\n         do jj = (ii+8) to 125 while(substr(LcData.x,jj,1) = '-')\n         end jj\n         do kk = (jj+1) to 125 while(substr(LcData.x,kk,1) <> ' ')\n         end kk\n         MaxLrecl = substr(LcData.x,jj,kk-jj)\n      End\n   End\n\n   if AvgLrecl = MaxLrecl then do\n      Recfm = 'F B'\n      Lrecl = MaxLrecl\n   End\n   Else do\n      Recfm = 'V B'\n      Lrecl = MaxLrecl + 4\n   End\n   Return\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"VWV  --  View all or part of a VSAM file                  \"\n   SAY\n   SAY \" FORMAT \"\n   SAY\n   SAY \"    VWV  ( limits )  VSAM-file-name                       \"\n   SAY\n   SAY \"       The VSAM file name can be specified or defaulted   \"\n   SAY \"       from a DS List entry.  The limits must be before   \"\n   SAY \"       the file name. They may be COUNT(#), SKIP(#),      \"\n   SAY \"       FROMKEY(key), TOKEY(key), FROMNUMBER(#), or        \"\n   SAY \"       TONUMBER(#). It puts you in View on the set desired\"\n   SAY \"       but saves the time-stamped file upon exit.         \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY\n   SAY \"    VWV  COUNT(500)  A-VSAM-FILE-UNDER-YOUR-ID            \"\n   SAY\n   SAY \"       will View the first 500 records of that file and   \"\n   SAY \"       keep the file on exiting.                          \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WAIT": {"ttr": 38669, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\xb2\\x00\\xb2\\x00\\x00\\xe6\\xc1\\xc9\\xe3@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 178, "newlines": 178, "modlines": 0, "user": "WAIT"}, "text": "//-YOUR-USERID-W JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//*** PROGRAM TO WAIT A GIVEN NUMBER OF SECONDS\n//***\n//A          EXEC     PGM=ASMA90,REGION=4M,\n//             PARM='OBJECT'\n//SYSLIB       DD       DISP=SHR,DSN=SYS1.MACLIB\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*,\n//             DCB=(RECFM=FM,LRECL=121,BLKSIZE=121)\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(MOD,PASS),\n//             UNIT=VIO,SPACE=(2960,(111,12)),DCB=BLKSIZE=2960\n********************************************************************    0002000\n*                                                                  *    0003000\n* NAME - WAIT.  MARK STEELY <MARK.STEELY@WNCO.COM>                 *    0004000\n*                                                                  *    0005000\n* DESCRIPTION -                                                    *    0006000\n*                                                                  *    0007000\n*   THIS MODULE WILL WAIT THE REQUESTED NUMBER OF SECONDS.         *    0008000\n*                                                                  *    0009000\n* TO USE -                                                         *    0010000\n*                                                                  *    0011000\n*   PARM='NNNN', WHERE 0 < NNNN <= 9999, THE NUMBER OF SECONDS TO  *    0012000\n*     WAIT. DEFAULT IS 60 SECONDS.                                 *    0013000\n*                                                                  *    0014000\n* RETURN CODES -                                                   *    0015000\n*                                                                  *    0016000\n*   R15 = 20, BAD PARM FIELD.                                      *    0017000\n*                                                                  *    0018000\n* LOG -                                                            *    0019000\n*   05/30/86 L01 PTW IMPLEMENTED                                   *L01 0020000\n*   09/27/88 L02 PTW IMPLEMENTED                                   *L02 0021000\n*                                                                  *    0022000\n********************************************************************    0023000\n         LCLC  &CSECT                                                   0024000\n&CSECT   SETC  'WAIT'                                                   0025000\n&CSECT   CSECT                                                          0026000\n********************************************************************    0027000\n*                                                                  *    0028000\n*        I N I T I A L I Z E                                       *    0029000\n*                                                                  *    0030000\n********************************************************************    0031000\n         PRINT NOGEN                                                    0032000\n         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME                        0033000\n         LR    R12,R15            ESTABLISH BASE.                       0034000\n         USING &CSECT,R12                                               0035000\n         GETMAIN RU,LV=DYNLEN                                           0036000\n         LR    R2,R13                                                   0037000\n         LR    R13,R1                                                   0038000\n         USING DYNAMIC,R13                                              0039000\n         LR    R0,R1                                                    0040000\n         LA    R14,DYNLEN                                               0041000\n         LA    R1,R1                                                    0042000\n         SLR   R15,R15                                                  0043000\n         MVCL  R0,R14             ZERO STORAGE.                         0044000\n         ST    R2,4(,R13)         BACK CHAIN.                           0045000\n         ST    R13,8(,R2)         FORWARD CHAIN.                        0046000\n         XC    RC,RC                                                    0047000\n********************************************************************    0048000\n*                                                                  *    0049000\n*        P A R M   P R O C E S S I N G                             *    0050000\n*                                                                  *    0051000\n********************************************************************    0052000\n         MVC   SECONDS,=F'60'     DEFAULT.                              0053000\n         L     R2,4(,R13)         A(PREVIOUS SAVEAREA).                 0054000\n         L     R2,24(,R2)         A(A(PARM)).                           0055000\n         LTR   R2,R2              CHECK FOR NULL PARM.                  0056000\n         BZ    DOTIME                                                   0057000\n         L     R2,0(,R2)          A(PARM).                              0058000\n         LH    R3,0(,R2)          L'PARM.                               0059000\n         LTR   R3,R3              IF ZEROS +                            0060000\n         BZ    DOTIME               THEN EXIT.                          0061000\n         CH    R3,=H'4'           IF LENGTH NGT '4' +                   0062000\n         BH    BADTIME            FORGET NEXT.                          0063000\n         LA    R4,2(,R2)                                                0064000\nVERNUM   DS    0H                                                       0065000\n         CLI   0(R4),C'0'         SCAN                                  0066000\n         BL    BADTIME             FORWARD                              0067000\n         CLI   0(R4),C'9'         SCAN                                  0068000\n         BH    BADTIME             FORWARD                              0069000\n         LA    R4,1(,R4)            TO FIRST                            0070000\n         BCT   R3,VERNUM                                                0071000\n         LH    R3,0(,R2)                                                0072000\n         BCTR  R3,0               MACHINE LENGTH.                       0073000\n         EX    R3,PACKSEC         PACK SECONDS.                         0074000\n         CVB   R3,DOUBLE          CONVERT TO BINARY.                    0075000\n         CH    R3,=H'1'           TEST SECONDS                          0076000\n         BL    BADTIME             FOR LIMITS.                          0077000\n         CH    R3,=H'9999'                                              0078000\n         BH    BADTIME                                                  0079000\n         ST    R3,SECONDS          AND STORE.                           0080000\nPACKSEC  PACK  DOUBLE,2(*-*,R2)                                         0081000\n********************************************************************    0082000\n*                                                                  *    0083000\n*        W A I T                                                   *    0084000\n*                                                                  *    0085000\n********************************************************************    0086000\nDOTIME   DS    0H                                                       0087000\n         L     R2,SECONDS                                               0088000\n         MH    R2,=H'100'                                               0089000\n         ST    R2,SECONDS                                               0090000\n         STIMER WAIT,BINTVL=SECONDS                                     0091000\n         XC    RC,RC                                                    0092000\n********************************************************************    0093000\n*                                                                  *    0094000\n*        R E T U R N                                               *    0095000\n*                                                                  *    0096000\n********************************************************************    0097000\nRETURN   DS    0H                                                       0098000\n         L     R2,RC                  R2 = RC.                          0099000\n         LR    R1,R13              PREPARE                              0100000\n         L     R13,4(,R13)         FOR FREEMAIN.                        0101000\n         FREEMAIN RU,LV=DYNLEN,A=(1)                                    0102000\n         LR    R15,R2              AND RETURN                           0103000\n         RETURN (14,12),RC=(15)      WITH R15 = RC.                     0104000\n********************************************************************    0105000\n*                                                                  *    0106000\n*        E R R O R S                                               *    0107000\n*                                                                  *    0108000\n********************************************************************    0109000\nBADTIME  DS    0H                                                       0110000\n         WTO   'WAIT: BAD PARM - SPECIFY NNNN (1-9999 SECONDS).',      X0111000\n               ROUTCDE=11,MCSFLAG=HRDCPY                                0112000\n         MVC   RC,=F'20'                                                0113000\n         B     RETURN                                                   0114000\n********************************************************************    0115000\n*                                                                  *    0116000\n*        S T A T I C   A R E A                                     *    0117000\n*                                                                  *    0118000\n********************************************************************    0119000\nSRCLEVEL DC    C'                                        '              0120000\n         LTORG *                                                        0121000\n********************************************************************    0122000\n*                                                                  *    0123000\n*        D Y N A M I C   A R E A                                   *    0124000\n*                                                                  *    0125000\n********************************************************************    0126000\nDYNAMIC  DSECT                                                          0127000\nSAVE     DS    18F .                                                    0128000\nDOUBLE   DS    D                                                        0129000\nRC       DS    F                                                        0130000\nSECONDS  DS    F                                                        0131000\nDYNLEN   EQU   *-DYNAMIC                                                0132000\n         PRINT OFF                                                      0133000\nR0       EQU   00                                                       0134000\nR1       EQU   01                                                       0135000\nR2       EQU   02                                                       0136000\nR3       EQU   03                                                       0137000\nR4       EQU   04                                                       0138000\nR5       EQU   05                                                       0139000\nR6       EQU   06                                                       0140000\nR7       EQU   07                                                       0141000\nR8       EQU   08                                                       0142000\nR9       EQU   09                                                       0143000\nR10      EQU   10                                                       0144000\nR11      EQU   11                                                       0145000\nR12      EQU   12                 PROGRAM BASE.                         0146000\nR13      EQU   13                 A(SAVE AREA).                         0147000\nR14      EQU   14                                                       0148000\nR15      EQU   15                                                       0149000\n         PRINT ON                                                       0150000\n         END   &CSECT                                                   0151000\n//***\n//L          EXEC     PGM=IEWL,\n//             PARM='XREF,LIST,LET,DCBS',\n//             REGION=4M\n//SYSUT1       DD       UNIT=VIO,\n//             SPACE=(CYL,(05,02),,CONTIG)\n//SYSPRINT     DD       SYSOUT=*\n//SYSLMOD      DD       DSN=-YOUR-LOADLIB-,\n//             DISP=SHR\n//SYSLIN       DD       DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE)\n//             DD       *\n  SETSSI   01501000\n  NAME     WAIT(R)\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WAIT$": {"ttr": 38913, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x06\\x00\\x06\\x00\\x00\\xe6\\xc1\\xc9\\xe3@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 6, "newlines": 6, "modlines": 0, "user": "WAIT"}, "text": "//-YOUR-USERID-W JOB  (-YOUR-ACCT-INFO-),'-YOUR-NAME-',\n//             CLASS=2,MSGCLASS=X,NOTIFY=-YOUR-USERID-\n//***\n//SETWAIT    EXEC     PGM=WAIT,PARM=0090\n//STEPLIB      DD       DISP=SHR,DSN=-YOUR-LOADLIB-\n//***\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XALLMEM": {"ttr": 38915, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x001\\x001\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 49, "newlines": 49, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- Edit every member of a PDS from outside Edit  **/\n\n   arg dsn exec\n   if dsn = \"?\" | dsn = \"\" then signal DispDoc\n\n   x = outtrap(\"lm.\",\"*\")\n   address tso \"LISTDS\" dsn \"MEMBERS\"\n   rcsave = rc\n   if rcsave <> 0 then do\n       say 'RC =' rcsave 'from LISTDS...'\n       exit 16\n   end\n   x = outtrap(\"off\")\n\n   do i = 1 to lm.0\n       if lm.i = \"--MEMBERS--\" then leave\n   end\n\n   do j = i+1 to lm.0\n       parse value lm.j with mem extra\n       if mem = exec then iterate\n       if substr(dsn,1,1) = \"'\" | substr(dsn,1,1) = '\"' then do\n           dsnx = substr(dsn,2,length(dsn)-2)\n           Address ISPEXEC \"EDIT DATASET('\"dsnx\"(\"mem\")') MACRO(\"exec\")\"\n       end\n       else do\n           Address ISPEXEC \"EDIT DATASET(\"dsn\"(\"mem\")) MACRO(\"exec\")\"\n       end\n   end\n\n   Exit(0)\n\nDispDoc:\n   ADDRESS TSO \"CLEAR\"\n   Say \"XALLMEM -- Execute macro against all members of a PDS       \"\n   Say\n   Say \"   XALLMEM  ( ? )  PDS  Macro                               \"\n   Say\n   Say \"       PDS is the name of the Partitioned Data Set which    \"\n   Say \"             will be edited.                                \"\n   Say\n   Say \"       Macro is the name of a macro to execute.  If it      \"\n   Say \"             is a program macro, remember to specify the    \"\n   Say \"             exclamation point before the name.             \"\n   Say\n   Say \"       A question mark (?) as the first parameter will      \"\n   Say \"       cause this built in documentation to display.        \"\n   Say\n   Exit(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XCOPY": {"ttr": 38917, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x03'\\x1f\\x01\\x03'\\x1f\\x12\\x00\\x00u\\x00u\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-09-28T00:00:00", "modifydate": "2003-09-28T12:00:00", "lines": 117, "newlines": 117, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- COPY A DATA SET OR MEMBER INTO THE EDITED FILE  **/\n   NUMERIC DIGITS 20\n   SAVEMSG = MSG()\n   X = MSG(\"OFF\")\n   X = ADDRESS()\n   SUBCOM ISPEXEC\n   IF RC <> 0 THEN DO\n      SAY \"XCOPY MUST BE RUN UNDER ISPF EDIT!\"\n      EXIT(0)\n      END\n   SUBCOM ISREDIT\n   UMODE = \"ISREDIT\"\n   ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n\n   ADDRESS ISREDIT\n   \"MACRO (INFILE FROMREC TOREC) NOPROCESS\"\n   UPPER INFILE\n   IF INFILE = '' THEN SIGNAL DISPDOC\n   DSNSTATUS = SYSDSN(INFILE)\n   IF DSNSTATUS <> \"OK\" THEN DO\n      SAY INFILE DSNSTATUS \":(\"\n      EXIT(0)\n   END\n   IF FROMREC <> '' THEN DO\n      IF \u00acDATATYPE(FROMREC,'W') THEN DO\n         SAY \"FROM RECORD NUMBER, \"FROMREC\", NOT NUMERIC :(\"\n         SIGNAL QUIT\n      END\n   END\n   ELSE FROMREC = 1\n   IF TOREC <> '' THEN DO\n      IF \u00acDATATYPE(TOREC,'W') THEN DO\n         SAY \"TO RECORD NUMBER, \"TOREC\", NOT NUMERIC :(\"\n         SIGNAL QUIT\n      END\n   END\n   ELSE TOREC = 999999999\n\n   \"ISREDIT PROCESS DEST\"\n   IF RC = 0 THEN \"ISREDIT (ZDEST) = LINENUM .ZDEST\"\n             ELSE ZDEST = 0\n\n   ADDRESS TSO\n   \"FREE DD($$INDATA)\"\n   \"ALLOCATE DD($$INDATA) DSN(\"INFILE\") SHR BUFNO(30)\"\n\n   ADDRESS ISREDIT\n   ADDRESS TSO \"EXECIO   0 DISKR\" $$INDATA \"(OPEN\"\n   ADDRESS TSO \"EXECIO 200 DISKR\" $$INDATA \"(STEM RECS.\"\n   RETCODE  = RC\n   READREC  = 0\n   INSERTED = 0\n   II = ZDEST\n   DO WHILE RETCODE = 0\n      DO JJ = 1 TO RECS.0\n         READREC = READREC + 1\n         IF  READREC >= FROMREC  &  READREC <= TOREC  THEN DO\n            INDATA = RECS.JJ\n            \"ISREDIT LINE_AFTER &II = (INDATA)\"\n            II = II + 1\n            INSERTED = INSERTED + 1\n         END\n         ELSE IF READREC > TOREC THEN SIGNAL QUIT0\n      END\n      ADDRESS TSO \"EXECIO 200 DISKR\" $$INDATA \"(STEM RECS.\"\n      RETCODE = RC\n   END\n   IF RETCODE = 2 THEN DO\n      DO JJ = 1 TO RECS.0\n         READREC = READREC + 1\n         IF  READREC >= FROMREC  &  READREC <= TOREC  THEN DO\n            INDATA = RECS.JJ\n            \"ISREDIT LINE_AFTER &II = (INDATA)\"\n            II = II + 1\n            INSERTED = INSERTED + 1\n         END\n         ELSE IF READREC > TOREC THEN SIGNAL QUIT0\n      END\n   END\n\nQUIT0:\n   ADDRESS TSO \"EXECIO 0 DISKR\" $$INDATA \"(FINIS\"\n   ADDRESS TSO \"FREE DD($$INDATA)\"\n\nQUIT:\n   IF ZDEST = 0 THEN ZDEST = 1\n                ELSE ZDEST = ZDEST + 1\n   \"ISREDIT CURSOR = \" ZDEST 1\n   CALL SETMSG '* NO ' INSERTED 'RECORDS INSERTED$RECORDS COPIED'\n   RETURN\n\nSETMSG:\n   PARSE ARG ZERRHM ZERRALRM ZERRSM'$'ZERRLM\n   ADDRESS ISPEXEC 'SETMSG MSG(ISRZ002) COND'\n   RETURN\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"XCOPY - COPY ANY DATASET OR MEMBER DIRECTLY INTO EDITED FILE \"\n   SAY\n   SAY \" FORMAT \"\n   SAY \"    XCOPY  FILE-NAME ( FROM-REC# ( TO-REC# ) )               \"\n   SAY \"       THE FILE NAME OR PDS MEMBER NAME IS MANDATORY.  IF    \"\n   SAY \"       SPECIFIED, ONLY THE RECORDS INCLUDING THE FROM-REC#   \"\n   SAY \"       TO THE TO-REC# (OR TO THE END OF THE FILE IF NO       \"\n   SAY \"       TO-REC# IS SPECIFIED) WILL BE COPIED.  A DESTINATION  \"\n   SAY \"       (EITHER AN 'A' OR 'B' IN THE PREFIX AREA) MAY BE      \"\n   SAY \"       SPECIFIED; IF NONE IS SPECIFIED, THE DATA IS COPIED   \"\n   SAY \"       TO THE FRONT OF THE EDITED FILE.                      \"\n   SAY\n   SAY \" EXAMPLE \"\n   SAY \"    XCOPY  'SYS1.MACLIB(GET)' \"\n   SAY \"       WILL COPY THE 'GET' MEMBER OF SYS1.MACLIB INTO        \"\n   SAY \"       THE EDITIED FILE, EITHER TO THE BEGINNING OR TO       \"\n   SAY \"       WHERE THE AFTER/BEFORE PREFIX WAS SPECIFIED.          \"\n   SAY\n   EXIT(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XINDENT": {"ttr": 38920, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x03'\\x1f\\x01\\x03'\\x1f\\x12\\x00\\x00f\\x00f\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-09-28T00:00:00", "modifydate": "2003-09-28T12:00:00", "lines": 102, "newlines": 102, "modlines": 0, "user": "REXX"}, "text": "/**  REXX -- Exclude a block between lines by indentation  **/\n\n   Address ISREDIT\n   'MACRO (Parms)'\n   If Parms = '?' then signal DispDoc\n   '(Bot) = LINENUM .ZLast'\n   '(Cur,Col) = CURSOR'\n   'RESET LAB'\n\n   If Cur > 0 then do\n      '(Line) = LINE' Cur\n      Do ii = 8 to 71 while ( substr(Line,ii,1) = ' ' )\n      End ii\n      IndentCol = ii - 7\n      If translate(substr(Line,ii,3)) = 'IF ',\n            | translate(substr(Line,ii,8)) = 'PERFORM ',\n            | translate(substr(Line,ii,9)) = 'EVALUATE ',\n         then call Look_Down\n         else if translate(substr(Line,ii,5)) = 'ELSE ',\n            then call Check_Up_or_Down\n            else call Look_Up\n   Exit(0)\n\nLook_Down:\n   ii = Cur + 1\n   'LABEL (ii) = .AXI'\n   Do ii = Cur+1 to Bot\n      '(Line) = LINE' ii\n      If substr(Line,7,IndentCol) = ' ',\n            & ( translate(substr(Line,IndentCol+7,5)) = 'ELSE ',\n              | translate(substr(Line,IndentCol+7,7)) = 'END-IF ',\n              | translate(substr(Line,IndentCol+7,7)) = 'END-IF.',\n              | translate(substr(Line,IndentCol+7,12)) = 'END-PERFORM ',\n              | translate(substr(Line,IndentCol+7,12)),\n                  = 'END-PERFORM.',\n              | translate(substr(Line,IndentCol+7,13)),\n                  = 'END-EVALUATE ',\n              | translate(substr(Line,IndentCol+7,13)),\n                  = 'END-EVALUATE.' )  then do\n            ii = ii - 1\n            If ii <> (Cur+1) then 'LABEL (ii) = .BXI'\n            Leave\n      End\n   End ii\n   If ( ii > Bot ) then 'LABEL (Bot) = .BXI'\n   If ii <> (Cur+1) then 'EXCLUDE .AXI .BXI ALL'\n                    else 'EXCLUDE .AXI .AXI ALL'\n   'RESET LAB'\n   'CURSOR = (Cur,Col)'\n   Return\n\nLook_Up:\n   ii = Cur - 1\n   'LABEL (ii) = .BXI'\n   Do ii = Cur-1 to 1 by -1\n      '(Line) = LINE' ii\n      If substr(Line,7,IndentCol) = ' ',\n            & (  translate(substr(Line,IndentCol+7,5)) = 'ELSE ',\n               | translate(substr(Line,IndentCol+7,3)) = 'IF ',\n               | translate(substr(Line,IndentCol+7,8)),\n                  = 'PERFORM ',\n               | translate(substr(Line,IndentCol+7,9)),\n                  = 'EVALUATE ' ),\n         then do\n            ii = ii + 1\n            If ii <> (Cur-1) then 'LABEL (ii) = .AXI'\n            Leave\n         End\n   End ii\n   If ( ii < 1 )    then 'LABEL (1) = .AXI'\n   If ii <> (Cur-1) then 'EXCLUDE .AXI .BXI ALL'\n                    else 'EXCLUDE .BXI .BXI ALL'\n   'RESET LAB'\n   'CURSOR = (Cur,Col)'\n   Return\n\nCheck_Up_or_Down:\n   ii = Cur - 1\n   '(LineStat) = XSTATUS' ii\n   If LineStat = 'X' then call Look_Down\n                     else call Look_Up\n   Return\n\nDispDoc:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"XINDENT - Exclude code based on indentation               \"\n   SAY\n   SAY \" Format \"\n   SAY\n   SAY \"    XINDENT                                               \"\n   SAY\n   SAY \"       Excludes lines from where the cursor is placed to  \"\n   SAY \"       the correspondingly indented logic statement. If   \"\n   SAY \"       pointing to an 'IF', the macro will exclude to the \"\n   SAY \"       next 'ELSE' or 'END-IF'. If pointing to a 'ELSE',  \"\n   SAY \"       it will exclude upwards to an 'IF' if the line     \"\n   SAY \"       prior is not excluded. Otherwise it goes downwards.\"\n   SAY \"       PERFORM/END-PERFORM and EVALUATE/END-EVALUATE work \"\n   SAY \"       similarly.                                         \"\n   SAY\n   EXIT(0)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZVW": {"ttr": 38923, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x124\\x00\\x88\\x00\\x88\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T12:34:00", "lines": 136, "newlines": 136, "modlines": 0, "user": "REXX"}, "text": "/* REXX -- ZVW  -- View the dataset the cursor is on                */\n\n/* This edit macro allows the user to VIEW the dataset located on   */\n/* the line that the cursor is on.  If the dataset name contains &  */\n/* tokens, i.e.  is within a PROC, ZVW will attempt to interpolate  */\n/* the proper variables if they are defaulted on the PROC. It now   */\n/* opens a new screen session for the View.                         */\n\n  Address ISREDIT\n  \"MACRO (parms)\"\n  If parms = \"?\" then signal DispDoc\n  Address ISPEXEC \"CONTROL ERRORS RETURN\"\n  \"(row,col) = CURSOR\"\n  \"(data1)   = LINE  \" row\n  dsnstart = Pos(\"DSN=\",data1)       /* look for DSN=              */\n  If dsnstart = 0 then do\n    dsnstart = Pos(\"DSNAME=\",data1)  /* look for DSNAME=           */\n    If dsnstart = 0 then do\n      If col < 1 then dsnstart = 1   /* look for delimiters        */\n      Else do\n        Do ii = col to 1 by -1\n          while substr(data1,ii,1) <> \" \" & substr(data1,ii,1) <> \"'\"\n        End ii\n        If ii <  1 then dsnstart = 1\n                   else dsnstart = ii + 1\n      End\n    End\n    Else dsnstart = dsnstart + 7     /* DSNAME= specified in JCL   */\n  End\n  Else dsnstart = dsnstart + 4       /* DSN = specified in JCL     */\n  dsnend = Pos(\",\",data1,dsnstart)   /* look for end of dsn        */\n  If dsnend = 0 then do\n    dsnend = Pos(\" \",data1,dsnstart)\n    If dsnend = 0 then do\n      dsnend = Pos(\"'\",data1,dsnstart)\n      If dsnend = 0 then do\n        zedsmsg = \"No end of DSN\"\n        zedlmsg = \"The data set name is not terminated with a\" ,\n                  \"space or comma.\"\n        Address ISPEXEC \"SETMSG MSG(ISRZ001)\"    /* msg - with alarm */\n        \"CURSOR = \" row col\n        Exit 8\n      End\n    End\n  End\n  dsnend = dsnend - 1\n  dsn = Substr(data1,dsnstart,dsnend-dsnstart+1) /* extract dsn     */\n  If pos(dsn,'&') <> 0 then call Try_If_Proc\n  Address ISPEXEC \"SELECT PGM(ISPSTRT)\",\n     \"PARM(CMD(ISREPDF '\"dsn\"' V))\"\n         /*** Address ISPEXEC \"VIEW DATASET('\"dsn\"')\" ***/\n  If RC <> 0 then Address ISPEXEC \"SETMSG MSG(\"ZERRMSG\")\"\n  \"CURSOR = \" row col\n  Exit 0\n\nTry_If_Proc:\n  \"(proc1) = LINE\" 1\n  If pos(proc1,\" PROC \") <> 0 then do\n    Do ii = 71 to 1 by -1 while substr(proc1,ii,1) = \" \"\n    End\n    If substr(proc1,ii,1) = \",\" | substr(proc1,ii-4,5) <> \" PROC\",\n      then call Process_Proc\n  End\n  Return\n\nProcess_Proc:\n  Call Get_Vary\n  xx = pos(dsn,\"&\")\n  Do while xx <> 0\n    Do yy = xx+1 to length(dsn),\n      while substr(dsn,yy,1) <> \".\"\n    End\n    sought  = substr(dsn,xx+1,yy-xx-1)\n    substit = Vary.sought\n    If yy < length(dsn) then dsn = substr(dsn,1,xx-1),\n      || substit || substr(dsn,yy+1)\n    Else dsn = substr(dsn,1,xx-1) || substit\n    xx = pos(dsn,\"&\")\n  End\n  Return\n\nGet_Vary:\n  jj = pos(proc1,\"=\")\n  ll = 1\n  do while jj <> 0\n    If substr(proc1,1,3) = \"//*\" then do\n      ll = ll + 1\n      \"(proc1) = LINE\" ll\n      jj = pos(proc1,\"=\")\n    End\n    Else do\n      do mm = jj-1 to 1 by -1,\n        while substr(proc1,mm,1) <> \" \",\n          & substr(proc1,mm,1) <> \",\"\n      end\n      stemy = substr(proc1,mm+1,jj-mm-1)\n      do nn = jj+1 to 71,\n        while substr(proc1,nn,1) <> \" \" & substr(proc1,nn,1) <> \",\"\n      end\n      hashy = substr(proc1,jj+1,nn-jj-1)\n      hashy = strip(hashy,B,\"'\")\n      Vary.stemy = hashy\n      proc1 = substr(proc1,1,mm),\n        || copies(\" \",nn-mm+1) || substr(proc1,nn)\n      jj = pos(proc1,\"=\")\n    End\n    If jj = 0 then do\n      Do ii = 71 to 1 by -1 while substr(proc1,ii,1) = \" \"\n      End\n      If substr(proc1,ii,1) = \",\" then do\n        ll = ll + 1\n        \"(proc1) = LINE\" ll\n        jj = pos(proc1,\"=\")\n      End\n      Else jj = 0\n    End\n  End\n  Return\n\nDispDoc:\n  ADDRESS TSO \"CLEAR\"\n  Say \"ZVW  --  View dataset under cursor                          \"\n  Say\n  Say \"   ZVW  ( ? )                                               \"\n  Say\n  Say \"       This macro will attempt to View the dataset on which \"\n  Say \"       the cursor is positioned. If the dataset contains    \"\n  Say \"       PROC substitutions such as &XX, the macro will try   \"\n  Say \"       to fill in the variables from any PROC statement at  \"\n  Say \"       the top of the file.                                 \"\n  Say\n  Say \"       A question mark (?) as the first parameter will      \"\n  Say \"       cause this built in documentation to display.        \"\n  Say\n  Exit(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT357/FILE357.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT357", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}