{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011103000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 411502, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE027.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE027.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x07\\x15'", "DS1TRBAL": "b'\"\\x88'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x00<\\x00\\x04\\x00<\\x00\\x0b\\x00\\x08'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$DOC": {"ttr": 516, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "1\n      THIS IS AN INDEX TO THE MEMBERS IN THIS LIBRARY\n\n    $CLEAR    -    CLEAR FLAG MACRO.  USED WITH $FLAG, $DFLAG AND\n                   $TEST MACROS.\n\n    $DFLAG    -    DEFINE FLAG BYTE MACRO.  USED WITH $FLAG, $CLEAR\n                   AND $TEST MACROS.\n\n    $EPILOG   -    END AND EXIT A PROGRAM CSECT.  USED WITH $PROLOG\n                   MACRO.\n\n    $FLAG     -    SET A FLAG BIT MACRO.  USED WITH $CLEAR, $DFLAG\n                   AND $TEST MACROS.\n\n    $HEAD     -    CREATE HEADER INFO BLOCKS IN ASSEMBLY LISTINGS.\n\n    $PROLOG   -    CREATE STANDARD ENTRY LINKAGE TO A PROGRAM CSECT.\n                   USED WITH $EPILOG MACRO.\n\n    $REGS     -    INTERNAL MARCO USED BY $PROLOG TO GENERATE REGISTER\n                   EQUATES.\n\n    $TEST     -    TEST A FLAG AND BRANCH ON CONDITION MACRO.  USED\n                   WITH $FLAG, $DFLAG AND $CLEAR MACROS.\n\n    #CONVDAT  -    CONVER JULIAN DATE TO GREGORIAN DATE MACRO.\n\n    DATECHCK  -    DATE CHECK PROGRAM SOURCE.\n\n    DAYC????  -    THESE ARE ISPF TUTORIAL MENUS TO EXPLAIN USEAGE OF\n                   DATECHCK UTILITY.\n\n1\n    THIS UTILITY IS IN USE AT DAYCO PRODUCTS INC ON AN IBM 3090\n    PROCESSOR RUNNING MVS/XA 2.1.3 AT PUT LEVEL 8606.  JES2 1.3.4\n    AND JES2 2.1.5 ARE BOTH IN USE AND WE HAVE ISPF/PDF 2.2 RUNNING\n    UNDER TSO/E 2.1.\n\n    THE UTILITY WAS CREATED TO ALLOW PROGRAMMERS WHO BUILD SYSTEMS\n    THAT REQUIRE DATE INPUT TO THE PARM OF A PROGRAM, TO ENSURE THAT\n    IF THE DATE IS ENTERED WRONG THE OPERATOR DOES NOT GET AWAY WITH\n    IT.  I TRIED TO MAKE IT AS FLEXIBLE AS POSSIBLE AND IT HAS EVEN\n    SAVED ME FROM MYSELF AT TIMES.  IT BECAME INVALUBLE WHEN I PUT\n    UP THE PANSPOOL SYSTEM FROM THE MODS TAPE SINCE AN ERROR IN THE\n    ENTERED PARM DATE COULD MEAN CONSIDERABLE HAND WORK TO CORRECT.\n\n    THE MACROS EXECPT THE $DFLAG, $TEST, $FLAG AND $CLEAR ARE FROM\n    VARIOUS FILES IN THE MODES TAPE.  THE #CONVDAT MACRO WAS MODIFIED\n    FOR REENTRANCY AND AN ATTEMPT MADE TO INCLUDE DETERMINING THE\n    DAY OF THE WEEK FROM THE DATE.  SOMEHOW THIS WENT WRONG BUT DID\n    NOT CAUSE PROBLEMS AS FAR AS THE DATECHCK PROGRAM SINCE IT DOES\n    NOT CARE.  IF YOU CAN FIX IT THEN GREATE.\n1\n    THE TAPE ENCLUDED IS AN NL TAPE AT 6250 BPI.  TAPE WAS CREATED\n    USING IEBCOPY UNLOAD FUNCTION AND HAS ONLY ONE FILE.\n-\n-\n                                  JOHN D. SOSTROM\n                                  DAYCO PRODUCTS INC.\n                                  333 W. FIRST STREET\n                                  DAYTON, OHIO   45401\n                                  (513)226-5747\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$CLEAR": {"ttr": 518, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   $CLEAR\n         LCLA  &AA,&BB,&CC,&GG\n         LCLC  &DD,&EE,&FF\n.*  THIS MACRO IS USED IN CONJUNCTION WITH THE $DFLAG, $FLAG AND $TEST\n.*  MACROS TO CLEAR THE FLAG BITS OF A FLAG BYTE DEFINED IN THE $DFLAG\n.*  MACRO THAT MAY HAVE BEEN SET BY THE USE OF THE $FLAG MACRO.\n.*  MULTIPLE FLAG BITS FROM MULTIPLE FLAG BYTES MAY BE CLEARED IN ONE\n.*  CALL OF THIS MACRO.\n.*  TO CLEAR MUTIPLE BITS OF A SINGLE FLAG BYTE SPECIFY\n.*       LABEL $CLEAR FLAGB1-FLAGB2-FLAGB3.....\n.*  TO CLEAR MULTIPLE BITS OF MULTIPLE FLAG BYTES SPECIFY\n.*       LABEL $CLEAR FLAGB1,BFLAGB2,CLFAGB1,......\n.*  A COMBINATION OF THE ABOVE TWO FUNCTION MAY BE ACCOMPLISHED AS\n.*  FOLLOWS\n.*       LABEL $CLEAR FLAGB1,AFLAGB1-AFLAGB4,......\n         AIF   (N'&SYSLIST GT 0).P1\n         MNOTE 8,'AT LEAST ONE FLAG NAME TO SET MUST BE SPECIFIED'\n         MEXIT\n.P1      ANOP\n&AA      SETA  1\n&LABEL   DS    0H\n&BB      SETA  N'&SYSLIST\n         AIF   (N'&SYSLIST GT 1).P2\n&DD      SETC  '&SYSLIST(&AA)'\n&CC      SETA  K'&DD\n&GG      SETA  1\n.P1A     ANOP\n         AIF   ('&DD'(&GG,1) NE '+').P1B\n         MNOTE 8,'OPERAND &DD IS INVALID.'\n         MEXIT\n.P1B     ANOP\n         AIF   ('&GG' EQ '&CC').P1C\n&GG      SETA  &GG+1\n         AGO   .P1A\n.P1C     ANOP\n&GG      SETA  1\n.P1D     ANOP\n         AIF   ('&DD'(&GG,1) EQ '-').P1E\n         AIF   ('&GG' EQ '&CC').P1F\n&GG      SETA  &GG+1\n         AGO   .P1D\n.P1E     ANOP\n&GG      SETA  &GG-1\n&EE      SETC  '&DD'(1,&GG)\n         AGO   .P1G\n.P1F     ANOP\n&EE      SETC  '&DD'\n.P1G     ANOP\n         NI    #&EE,255-&DD\n         MEXIT\n.P2      ANOP\n&AA      SETA  1\n.P3      ANOP\n&DD      SETC  '&SYSLIST(&AA)'\n&CC      SETA  K'&DD\n&GG      SETA  1\n.P3A     ANOP\n         AIF   ('&DD'(&GG,1) NE '+').P3B\n         MNOTE 8,'OPERAND &DD IS INVALID.'\n         MEXIT\n.P3B     ANOP\n         AIF   ('&GG' EQ '&CC').P3C\n&GG      SETA  &GG+1\n         AGO   .P3A\n.P3C     ANOP\n&GG      SETA  1\n.P3D     ANOP\n         AIF   ('&DD'(&GG,1) EQ '-').P3E\n         AIF   ('&GG' EQ '&CC').P3F\n&GG      SETA  &GG+1\n         AGO   .P3D\n.P3E     ANOP\n&GG      SETA  &GG-1\n&EE      SETC  '&DD'(1,&GG)\n         AGO   .P3G\n.P3F     ANOP\n&EE      SETC  '&DD'\n.P3G     ANOP\n         NI    #&EE,255-&DD\n         AIF   ('&AA' EQ '&BB').P4\n&AA      SETA  &AA+1\n         AGO   .P3\n.P4      ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DFLAG": {"ttr": 521, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   $DFLAG\n         LCLA  &CNT1,&CNT2,&LNG\n         LCLC  &NM,&#NM\n         LCLC  &XV(8)\n.*  THIS MACRO BUILDS A FLAG BYTE AND EQUATES FOR TESTING SETTING AND\n.*  CLEARING THE BITS.  IT IS USED ALONG WITH THE $FLAG, $CLEAR AND\n.*  $TEST MACROS.  UP TO 8 FLAGS MAY BE DEFINED.  EACH FLAG NAME HAS\n.*  A MAXIMUM OF 7 CHARACTERS ALLOWED.  THE FLAG BYTES ARE ASSIGNED\n.*  VALUES IN SEQUENCE WITH THE FIRST FLAG = X'80' THE SECOND FLAG\n.*  = X'40' AND SO ON SO THAT EACH FLAG DEFINES ONE BIT IN THE FLAG\n.*  BYTE.\n.*  EACH FLAG MUST BE SEPERATED BY A COMMA.\n&XV(1)   SETC  '80'\n&XV(2)   SETC  '40'\n&XV(3)   SETC  '20'\n&XV(4)   SETC  '10'\n&XV(5)   SETC  '08'\n&XV(6)   SETC  '04'\n&XV(7)   SETC  '02'\n&XV(8)   SETC  '01'\n         AIF   (N'&SYSLIST GT 0).P1\n         MNOTE 8,'AT LEAST ONE FLAG NAME REQUIRED'\n         MEXIT\n.P1      ANOP\n         AIF   (N'&SYSLIST LE 8).P2\n         MNOTE 8,'A MAXIMUM OF 8 FLAG NAMES ARE ALLOWED'\n         MEXIT\n.P2      ANOP\n&CNT1    SETA  N'&SYSLIST         GET THE NUMBER OF NAME ENTRIES\n&CNT2    SETA  0                  SET START LOOP COUNTER\n.P3      ANOP\n         AIF   ('&CNT1' EQ '&CNT2').P4\n&CNT2    SETA  &CNT2+1            ADD ONE TO COUNTER\n&NM      SETC  '&SYSLIST(&CNT2)'\n&LNG     SETA  K'&NM\n         AIF   ('&LNG' LT '8').P3A\n         MNOTE 8,'LABEL &NM IS TOO LONG.  MAXIMUM OF 7 CHARACTERS ALLOWX\n               ED.'\n         MEXIT\n.P3A     ANOP\n         AIF   ('&LNG' GT '0').P3B\n         MNOTE 8,'LABEL IS TOO SHORT. A MINIMUM OF 1 CHARACTER REQUIREDX\n               .'\n         MEXIT\n.P3B     ANOP\n&#NM     SETC  '#&SYSLIST(&CNT2)'\n&#NM     DS    0XL1\n&NM      EQU   X'&XV(&CNT2)'\n         AGO   .P3\n.P4      ANOP\n&LABEL   DC    XL1'00'            INITIAL VALUES SET TO ZERO\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$EPILOG": {"ttr": 523, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   $EPILOG &RC\n&LABEL   LR    R1,R13              GET SAVEAREA ADDRESS\n         L     R13,4(R13)          GET BACK CHAIN POINTER\n         L     R0,16(R13)          GET SAVEAREA LENGTH\n         ST    R15,16(R13)         SAVE REGISTER 15 (RETCODE)\n         FREEMAIN R,LV=(0),A=(1)   FREE SAVEAREA\n         LM    R14,R12,12(R13)     RESTORE CALLERS REGS\n         AIF   (T'&RC EQ 'O').SPEC\n         LA    R15,&RC             SET RETURN CODE\n.SPEC    ANOP\n         BR    R14                 RETURN TO CALLER\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$FLAG": {"ttr": 525, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   $FLAG\n         LCLA  &AA,&BB,&EE,&FF\n         LCLC  &CC,&DD,&ZZ\n.*   THIS MACRO IS USED IN CONJENCTION WITH THE $DFLAG, $CLEAR AND\n.*   $TEST MACROS TO SET FLAG BYTES.  MULTIPLE FLAG BYTES FROM\n.*   DIFFERENT $DFLAG MACRO CALLS MAY BE SET BY ONE CALL OF THE\n.*   $FLAG MACRO.  (I.E. LABEL $FLAG AFLAG1,BFLAG1 WILL SET THE\n.*   FLAGS AFLAG1 FROM ONE $DFLAG MACRO CALL AND BFLAG1 FROM A\n.*   DIFFERENT $DFLAG MACRO CALL OR IF BOTH FLAGS ARE DEFINED IN\n.*   THE SAME $DFLAG MACRO CALL THEN BOTH WILL BE SET.)  ANOTHER\n.*   WAY TO SET MULTIPLE FLAGS FROM THE SAME $DFLAG MACRO CALL\n.*   IS: LABEL $FLAG FLAG1+FLAG2 .\n         AIF   (N'&SYSLIST GT 0).P1\n         MNOTE 8,'AT LEAST ONE FLAG NAME TO SET MUST BE SPECIFIED'\n         MEXIT\n.P1      ANOP\n&LABEL   DS    0H\n&BB      SETA  N'&SYSLIST\n         AIF   (N'&SYSLIST GT 1).P2\n&CC      SETC  '&SYSLIST(1)'\n&EE      SETA  1\n&FF      SETA  K'&CC\n.P1A     ANOP\n         AIF   ('&CC'(&EE,1) EQ '-').P1AE1\n&EE      SETA  &EE+1\n         AIF   ('&EE' EQ '&FF').P1B\n         AGO   .P1A\n.P1AE1   ANOP\n         MNOT  8,' &CC IS AN INVALID FLAG SPECIFICATION.'\n         MEXIT\n.P1B     ANOP\n&EE      SETA  1\n.P1C     ANOP\n         AIF   ('&CC'(&EE,1) EQ '+').P1D\n&EE      SETA  &EE+1\n         AIF   ('&EE' EQ '&FF').P1E\n         AGO   .P1C\n.P1D     ANOP\n&EE      SETA  &EE-1\n&DD      SETC  '&CC'(1,&EE)\n         AGO   .P1F\n.P1E     ANOP\n&DD      SETC  '&CC'\n.P1F     ANOP\n         OI    #&DD,&CC\n         MEXIT\n.P2      ANOP\n&AA      SETA  1\n.P3      ANOP\n&CC      SETC  '&SYSLIST(&AA)'\n&FF      SETA  K'&CC\n&EE      SETA  1\n.P3A     ANOP\n         AIF   ('&CC'(&EE,1) EQ '-').P1AE1\n&EE      SETA  &EE+1\n         AIF   ('&EE' EQ '&FF').P3B\n         AGO   .P3A\n.P3B     ANOP\n&EE      SETA  1\n.P3C     ANOP\n         AIF   ('&CC'(&EE,1) EQ '+').P3D\n&EE      SETA  &EE+1\n         AIF   ('&EE' EQ '&FF').P3E\n         AGO   .P3C\n.P3D     ANOP\n&EE      SETA  &EE-1\n&DD      SETC  '&CC'(1,&EE)\n         AGO   .P3F\n.P3E     ANOP\n&DD      SETC  '&CC'\n.P3F     ANOP\n         OI    #&DD,&CC\n         AIF   ('&AA' EQ '&BB').P4\n&AA      SETA  &AA+1\n         AGO   .P3\n.P4      ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$HEAD": {"ttr": 528, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n        $HEAD  &STRING,           STRING IS EXPANDED                   *\n               &BLOCK=YES,        STRING IS TO BE BLOCKED              *\n               &TITLE=            (A,'B') -GEN TITLE STATEMENT WITH    *\n                                  NAME FIELD A, AND TITLE 'B'\n.*\n.*  THIS MACRO COPIED & ALTERED FROM 'MIM#3' WRITTEN BY C. J. GOELZ\n.*\n         LCLB  &HEADB\n         LCLC  &HEADC(497)\n         LCLA  &I\n         LCLA  &J\n         LCLA  &K\n         LCLA  &L\n         LCLA  &M\n         LCLA  &N\n         LCLC  &F(64)\n         LCLC  &STR(64)\n         LCLC  &B\n         LCLC  &W\n.*\n.*\n         AIF   (&HEADB).PROC\n&HEADB   SETB  (1)\n&HEADC(1)    SETC  ' '\n&HEADC(2)    SETC  '        '\n&HEADC(3)    SETC  '        '\n&HEADC(4)    SETC  '        '\n&HEADC(5)    SETC  '        '\n&HEADC(6)    SETC  '        '\n&HEADC(7)    SETC  '        '\n&HEADC(8)    SETC  '        '\n&HEADC(9)    SETC  '        '\n&HEADC(10)   SETC  'A'\n&HEADC(11)   SETC  '    A   '\n&HEADC(12)   SETC  '   AAA  '\n&HEADC(13)   SETC  '  AA AA '\n&HEADC(14)   SETC  ' AA   AA'\n&HEADC(15)   SETC  ' AA   AA'\n&HEADC(16)   SETC  ' AAAAAAA'\n&HEADC(17)   SETC  ' AA   AA'\n&HEADC(18)   SETC  ' AA   AA'\n&HEADC(19)   SETC  'B'\n&HEADC(20)   SETC  ' BBBBBB '\n&HEADC(21)   SETC  ' BB   BB'\n&HEADC(22)   SETC  ' BB   BB'\n&HEADC(23)   SETC  ' BBBBBB '\n&HEADC(24)   SETC  ' BB   BB'\n&HEADC(25)   SETC  ' BB   BB'\n&HEADC(26)   SETC  ' BB   BB'\n&HEADC(27)   SETC  ' BBBBBB '\n&HEADC(28)   SETC  'C'\n&HEADC(29)   SETC  '  CCCCC '\n&HEADC(30)   SETC  ' CC   CC'\n&HEADC(31)   SETC  ' CC   CC'\n&HEADC(32)   SETC  ' CC     '\n&HEADC(33)   SETC  ' CC     '\n&HEADC(34)   SETC  ' CC   CC'\n&HEADC(35)   SETC  ' CC   CC'\n&HEADC(36)   SETC  '  CCCCC '\n&HEADC(37)   SETC  'D'\n&HEADC(38)   SETC  ' DDDDDD '\n&HEADC(39)   SETC  ' DD   DD'\n&HEADC(40)   SETC  ' DD   DD'\n&HEADC(41)   SETC  ' DD   DD'\n&HEADC(42)   SETC  ' DD   DD'\n&HEADC(43)   SETC  ' DD   DD'\n&HEADC(44)   SETC  ' DD   DD'\n&HEADC(45)   SETC  ' DDDDDD '\n&HEADC(46)   SETC  'E'\n&HEADC(47)   SETC  ' EEEEEE '\n&HEADC(48)   SETC  ' EE     '\n&HEADC(49)   SETC  ' EE     '\n&HEADC(50)   SETC  ' EEEE   '\n&HEADC(51)   SETC  ' EE     '\n&HEADC(52)   SETC  ' EE     '\n&HEADC(53)   SETC  ' EE     '\n&HEADC(54)   SETC  ' EEEEEEE'\n&HEADC(55)   SETC  'F'\n&HEADC(56)   SETC  ' FFFFFFF'\n&HEADC(57)   SETC  ' FF     '\n&HEADC(58)   SETC  ' FF     '\n&HEADC(59)   SETC  ' FFFFF  '\n&HEADC(60)   SETC  ' FF     '\n&HEADC(61)   SETC  ' FF     '\n&HEADC(62)   SETC  ' FF     '\n&HEADC(63)   SETC  ' FF     '\n&HEADC(64)   SETC  'G'\n&HEADC(65)   SETC  '  GGGGG '\n&HEADC(66)   SETC  ' GG   GG'\n&HEADC(67)   SETC  ' GG   GG'\n&HEADC(68)   SETC  ' GG     '\n&HEADC(69)   SETC  ' GG  GGG'\n&HEADC(70)   SETC  ' GG   GG'\n&HEADC(71)   SETC  ' GG   GG'\n&HEADC(72)   SETC  '  GGGGG '\n&HEADC(73)   SETC  'H'\n&HEADC(74)   SETC  ' HH   HH'\n&HEADC(75)   SETC  ' HH   HH'\n&HEADC(76)   SETC  ' HH   HH'\n&HEADC(77)   SETC  ' HHHHHHH'\n&HEADC(78)   SETC  ' HH   HH'\n&HEADC(79)   SETC  ' HH   HH'\n&HEADC(80)   SETC  ' HH   HH'\n&HEADC(81)   SETC  ' HH   HH'\n&HEADC(82)   SETC  'I'\n&HEADC(83)   SETC  '  IIII  '\n&HEADC(84)   SETC  '   II   '\n&HEADC(85)   SETC  '   II   '\n&HEADC(86)   SETC  '   II   '\n&HEADC(87)   SETC  '   II   '\n&HEADC(88)   SETC  '   II   '\n&HEADC(89)   SETC  '   II   '\n&HEADC(90)   SETC  '  IIII  '\n&HEADC(91)   SETC  'J'\n&HEADC(92)   SETC  '      JJ'\n&HEADC(93)   SETC  '      JJ'\n&HEADC(94)   SETC  '      JJ'\n&HEADC(95)   SETC  '      JJ'\n&HEADC(96)   SETC  '      JJ'\n&HEADC(97)   SETC  ' JJ   JJ'\n&HEADC(98)   SETC  ' JJ   JJ'\n&HEADC(99)   SETC  '  JJJJJ '\n&HEADC(100)  SETC  'K'\n&HEADC(101)  SETC  ' KK   KK'\n&HEADC(102)  SETC  ' KK  KK '\n&HEADC(103)  SETC  ' KK KK  '\n&HEADC(104)  SETC  ' KKKK   '\n&HEADC(105)  SETC  ' KKKK   '\n&HEADC(106)  SETC  ' KK KK  '\n&HEADC(107)  SETC  ' KK  KK '\n&HEADC(108)  SETC  ' KK   KK'\n&HEADC(109)  SETC  'L'\n&HEADC(110)  SETC  ' LL     '\n&HEADC(111)  SETC  ' LL     '\n&HEADC(112)  SETC  ' LL     '\n&HEADC(113)  SETC  ' LL     '\n&HEADC(114)  SETC  ' LL     '\n&HEADC(115)  SETC  ' LL     '\n&HEADC(116)  SETC  ' LL     '\n&HEADC(117)  SETC  ' LLLLLLL'\n&HEADC(118)  SETC  'M'\n&HEADC(119)  SETC  ' M     M'\n&HEADC(120)  SETC  ' MM   MM'\n&HEADC(121)  SETC  ' MMM MMM'\n&HEADC(122)  SETC  ' MMMMMMM'\n&HEADC(123)  SETC  ' MM M MM'\n&HEADC(124)  SETC  ' MM   MM'\n&HEADC(125)  SETC  ' MM   MM'\n&HEADC(126)  SETC  ' MM   MM'\n&HEADC(127)  SETC  'N'\n&HEADC(128)  SETC  ' NN   NN'\n&HEADC(129)  SETC  ' NNN  NN'\n&HEADC(130)  SETC  ' NNN  NN'\n&HEADC(131)  SETC  ' NNNN NN'\n&HEADC(132)  SETC  ' NN NNNN'\n&HEADC(133)  SETC  ' NN  NNN'\n&HEADC(134)  SETC  ' NN  NNN'\n&HEADC(135)  SETC  ' NN   NN'\n&HEADC(136)  SETC  'O'\n&HEADC(137)  SETC  '  OOOOO '\n&HEADC(138)  SETC  ' OO   OO'\n&HEADC(139)  SETC  ' OO   OO'\n&HEADC(140)  SETC  ' OO   OO'\n&HEADC(141)  SETC  ' OO   OO'\n&HEADC(142)  SETC  ' OO   OO'\n&HEADC(143)  SETC  ' OO   OO'\n&HEADC(144)  SETC  '  OOOOO '\n&HEADC(145)  SETC  'P'\n&HEADC(146)  SETC  ' PPPPPP '\n&HEADC(147)  SETC  ' PP   PP'\n&HEADC(148)  SETC  ' PP   PP'\n&HEADC(149)  SETC  ' PP   PP'\n&HEADC(150)  SETC  ' PPPPPP '\n&HEADC(151)  SETC  ' PP     '\n&HEADC(152)  SETC  ' PP     '\n&HEADC(153)  SETC  ' PP     '\n&HEADC(154)  SETC  'Q'\n&HEADC(155)  SETC  '  QQQQQ '\n&HEADC(156)  SETC  ' QQ   QQ'\n&HEADC(157)  SETC  ' QQ   QQ'\n&HEADC(158)  SETC  ' QQ   QQ'\n&HEADC(159)  SETC  ' QQ Q QQ'\n&HEADC(160)  SETC  ' QQ  QQQ'\n&HEADC(161)  SETC  ' QQ   QQ'\n&HEADC(162)  SETC  '  QQQQQQ'\n&HEADC(163)  SETC  'R'\n&HEADC(164)  SETC  ' RRRRRR '\n&HEADC(165)  SETC  ' RR   RR'\n&HEADC(166)  SETC  ' RR   RR'\n&HEADC(167)  SETC  ' RR   RR'\n&HEADC(168)  SETC  ' RRRRRR '\n&HEADC(169)  SETC  ' RR RR  '\n&HEADC(170)  SETC  ' RR  RR '\n&HEADC(171)  SETC  ' RR   RR'\n&HEADC(172)  SETC  'S'\n&HEADC(173)  SETC  '  SSSSS '\n&HEADC(174)  SETC  ' SS   SS'\n&HEADC(175)  SETC  ' SS     '\n&HEADC(176)  SETC  '  SSSSS '\n&HEADC(177)  SETC  '      SS'\n&HEADC(178)  SETC  ' SS   SS'\n&HEADC(179)  SETC  ' SS   SS'\n&HEADC(180)  SETC  '  SSSSS '\n&HEADC(181)  SETC  'T'\n&HEADC(182)  SETC  'TTTTTTTT'\n&HEADC(183)  SETC  '   TT   '\n&HEADC(184)  SETC  '   TT   '\n&HEADC(185)  SETC  '   TT   '\n&HEADC(186)  SETC  '   TT   '\n&HEADC(187)  SETC  '   TT   '\n&HEADC(188)  SETC  '   TT   '\n&HEADC(189)  SETC  '   TT   '\n&HEADC(190)  SETC  'U'\n&HEADC(191)  SETC  ' UU   UU'\n&HEADC(192)  SETC  ' UU   UU'\n&HEADC(193)  SETC  ' UU   UU'\n&HEADC(194)  SETC  ' UU   UU'\n&HEADC(195)  SETC  ' UU   UU'\n&HEADC(196)  SETC  ' UU   UU'\n&HEADC(197)  SETC  ' UU   UU'\n&HEADC(198)  SETC  '  UUUUU '\n&HEADC(199)  SETC  'V'\n&HEADC(200)  SETC  ' VV   VV'\n&HEADC(201)  SETC  ' VV   VV'\n&HEADC(202)  SETC  ' VV   VV'\n&HEADC(203)  SETC  ' VV   VV'\n&HEADC(204)  SETC  ' VV   VV'\n&HEADC(205)  SETC  '  VV VV '\n&HEADC(206)  SETC  '   VVV  '\n&HEADC(207)  SETC  '    V   '\n&HEADC(208)  SETC  'W'\n&HEADC(209)  SETC  ' WW   WW'\n&HEADC(210)  SETC  ' WW   WW'\n&HEADC(211)  SETC  ' WW   WW'\n&HEADC(212)  SETC  ' WW   WW'\n&HEADC(213)  SETC  ' WW W WW'\n&HEADC(214)  SETC  ' WWWWWWW'\n&HEADC(215)  SETC  ' WWW WWW'\n&HEADC(216)  SETC  '  W   W '\n&HEADC(217)  SETC  'X'\n&HEADC(218)  SETC  ' XX   XX'\n&HEADC(219)  SETC  ' XX   XX'\n&HEADC(220)  SETC  '  XX XX '\n&HEADC(221)  SETC  '   XXX  '\n&HEADC(222)  SETC  '   XXX  '\n&HEADC(223)  SETC  '  XX XX '\n&HEADC(224)  SETC  ' XX   XX'\n&HEADC(225)  SETC  ' XX   XX'\n&HEADC(226)  SETC  'Y'\n&HEADC(227)  SETC  ' YY   YY'\n&HEADC(228)  SETC  ' YY   YY'\n&HEADC(229)  SETC  ' YY   YY'\n&HEADC(230)  SETC  '  YY YY '\n&HEADC(231)  SETC  '   YYY  '\n&HEADC(232)  SETC  '   YY   '\n&HEADC(233)  SETC  '   YY   '\n&HEADC(234)  SETC  '   YY   '\n&HEADC(235)  SETC  'Z'\n&HEADC(236)  SETC  ' ZZZZZZZ'\n&HEADC(237)  SETC  '      ZZ'\n&HEADC(238)  SETC  '     ZZ '\n&HEADC(239)  SETC  '    ZZ  '\n&HEADC(240)  SETC  '   ZZ   '\n&HEADC(241)  SETC  '  ZZ    '\n&HEADC(242)  SETC  ' ZZ     '\n&HEADC(243)  SETC  ' ZZZZZZZ'\n&HEADC(244)  SETC  '1'\n&HEADC(245)  SETC  '    1   '\n&HEADC(246)  SETC  '   11   '\n&HEADC(247)  SETC  '    1   '\n&HEADC(248)  SETC  '    1   '\n&HEADC(249)  SETC  '    1   '\n&HEADC(250)  SETC  '    1   '\n&HEADC(251)  SETC  '    1   '\n&HEADC(252)  SETC  '   111  '\n&HEADC(253)  SETC  '2'\n&HEADC(254)  SETC  '   222  '\n&HEADC(255)  SETC  '  2   2 '\n&HEADC(256)  SETC  '      2 '\n&HEADC(257)  SETC  '      2 '\n&HEADC(258)  SETC  '   222  '\n&HEADC(259)  SETC  '  2     '\n&HEADC(260)  SETC  '  2     '\n&HEADC(261)  SETC  '  22222 '\n&HEADC(262)  SETC  '3'\n&HEADC(263)  SETC  '   333  '\n&HEADC(264)  SETC  '  3   3 '\n&HEADC(265)  SETC  '      3 '\n&HEADC(266)  SETC  '    33  '\n&HEADC(267)  SETC  '      3 '\n&HEADC(268)  SETC  '  3   3 '\n&HEADC(269)  SETC  '  3   3 '\n&HEADC(270)  SETC  '   333  '\n&HEADC(271)  SETC  '4'\n&HEADC(272)  SETC  '     4  '\n&HEADC(273)  SETC  '    44  '\n&HEADC(274)  SETC  '   4 4  '\n&HEADC(275)  SETC  '  4  4  '\n&HEADC(276)  SETC  ' 444444 '\n&HEADC(277)  SETC  '     4  '\n&HEADC(278)  SETC  '     4  '\n&HEADC(279)  SETC  '     4  '\n&HEADC(280)  SETC  '5'\n&HEADC(281)  SETC  '  55555 '\n&HEADC(282)  SETC  '  5     '\n&HEADC(283)  SETC  '  5     '\n&HEADC(284)  SETC  '  5555  '\n&HEADC(285)  SETC  '      5 '\n&HEADC(286)  SETC  '  5   5 '\n&HEADC(287)  SETC  '  5   5 '\n&HEADC(288)  SETC  '   555  '\n&HEADC(289)  SETC  '6'\n&HEADC(290)  SETC  '   666  '\n&HEADC(291)  SETC  '  6   6 '\n&HEADC(292)  SETC  '  6     '\n&HEADC(293)  SETC  '  6666  '\n&HEADC(294)  SETC  '  6   6 '\n&HEADC(295)  SETC  '  6   6 '\n&HEADC(296)  SETC  '  6   6 '\n&HEADC(297)  SETC  '   666  '\n&HEADC(298)  SETC  '7'\n&HEADC(299)  SETC  '  77777 '\n&HEADC(300)  SETC  '      7 '\n&HEADC(301)  SETC  '      7 '\n&HEADC(302)  SETC  '     7  '\n&HEADC(303)  SETC  '    7   '\n&HEADC(304)  SETC  '   7    '\n&HEADC(305)  SETC  '   7    '\n&HEADC(306)  SETC  '   7    '\n&HEADC(307)  SETC  '8'\n&HEADC(308)  SETC  '   888  '\n&HEADC(309)  SETC  '  8   8 '\n&HEADC(310)  SETC  '  8   8 '\n&HEADC(311)  SETC  '   888  '\n&HEADC(312)  SETC  '  8   8 '\n&HEADC(313)  SETC  '  8   8 '\n&HEADC(314)  SETC  '  8   8 '\n&HEADC(315)  SETC  '   888  '\n&HEADC(316)  SETC  '9'\n&HEADC(317)  SETC  '   999  '\n&HEADC(318)  SETC  '  9   9 '\n&HEADC(319)  SETC  '  9   9 '\n&HEADC(320)  SETC  '  9   9 '\n&HEADC(321)  SETC  '   9999 '\n&HEADC(322)  SETC  '      9 '\n&HEADC(323)  SETC  '  9   9 '\n&HEADC(324)  SETC  '   999  '\n&HEADC(325)  SETC  '0'\n&HEADC(326)  SETC  '   000  '\n&HEADC(327)  SETC  '  0   0 '\n&HEADC(328)  SETC  '  0   0 '\n&HEADC(329)  SETC  '  0   0 '\n&HEADC(330)  SETC  '  0   0 '\n&HEADC(331)  SETC  '  0   0 '\n&HEADC(332)  SETC  '  0   0 '\n&HEADC(333)  SETC  '   000  '\n&HEADC(334)  SETC  '$'\n&HEADC(335)  SETC  '    $   '\n&HEADC(336)  SETC  '  $$$$$ '\n&HEADC(337)  SETC  ' $$ $ $$'\n&HEADC(338)  SETC  ' $$ $   '\n&HEADC(339)  SETC  '  $$$$$ '\n&HEADC(340)  SETC  '    $ $$'\n&HEADC(341)  SETC  ' $$ $ $$'\n&HEADC(342)  SETC  '  $$$$$ '\n&HEADC(343)  SETC  '#'\n&HEADC(344)  SETC  '  ## ## '\n&HEADC(345)  SETC  '  ## ## '\n&HEADC(346)  SETC  ' #######'\n&HEADC(347)  SETC  '  ## ## '\n&HEADC(348)  SETC  '  ## ## '\n&HEADC(349)  SETC  ' #######'\n&HEADC(350)  SETC  '  ## ## '\n&HEADC(351)  SETC  '  ## ## '\n&HEADC(352)  SETC  '@'\n&HEADC(353)  SETC  '  @@@@@ '\n&HEADC(354)  SETC  ' @     @'\n&HEADC(355)  SETC  ' @  @@ @'\n&HEADC(356)  SETC  ' @ @ @ @'\n&HEADC(357)  SETC  '  @  @ @'\n&HEADC(358)  SETC  ' @   @ @'\n&HEADC(359)  SETC  ' @   @ @'\n&HEADC(360)  SETC  '  @@@ @ '\n&HEADC(361)  SETC  ','\n&HEADC(362)  SETC  '        '\n&HEADC(363)  SETC  '        '\n&HEADC(364)  SETC  '        '\n&HEADC(365)  SETC  '        '\n&HEADC(366)  SETC  '   ,,   '\n&HEADC(367)  SETC  '   ,,   '\n&HEADC(368)  SETC  '    ,   '\n&HEADC(369)  SETC  '   ,    '\n&HEADC(370)  SETC  '.'\n&HEADC(371)  SETC  '        '\n&HEADC(372)  SETC  '        '\n&HEADC(373)  SETC  '        '\n&HEADC(374)  SETC  '        '\n&HEADC(375)  SETC  '        '\n&HEADC(376)  SETC  '   ..   '\n&HEADC(377)  SETC  '   ..   '\n&HEADC(378)  SETC  '        '\n&HEADC(379)  SETC  '('\n&HEADC(380)  SETC  '    (   '\n&HEADC(381)  SETC  '   (    '\n&HEADC(382)  SETC  '  (     '\n&HEADC(383)  SETC  '  (     '\n&HEADC(384)  SETC  '  (     '\n&HEADC(385)  SETC  '  (     '\n&HEADC(386)  SETC  '   (    '\n&HEADC(387)  SETC  '    (   '\n&HEADC(388)  SETC  ')'\n&HEADC(389)  SETC  '   )    '\n&HEADC(390)  SETC  '    )   '\n&HEADC(391)  SETC  '     )  '\n&HEADC(392)  SETC  '     )  '\n&HEADC(393)  SETC  '     )  '\n&HEADC(394)  SETC  '     )  '\n&HEADC(395)  SETC  '    )   '\n&HEADC(396)  SETC  '   )    '\n&HEADC(397)  SETC  '+'\n&HEADC(398)  SETC  '        '\n&HEADC(399)  SETC  '    +   '\n&HEADC(400)  SETC  '    +   '\n&HEADC(401)  SETC  '    +   '\n&HEADC(402)  SETC  ' +++++++'\n&HEADC(403)  SETC  '    +   '\n&HEADC(404)  SETC  '    +   '\n&HEADC(405)  SETC  '    +   '\n&HEADC(406)  SETC  '/'\n&HEADC(407)  SETC  '       /'\n&HEADC(408)  SETC  '      / '\n&HEADC(409)  SETC  '     /  '\n&HEADC(410)  SETC  '    /   '\n&HEADC(411)  SETC  '   /    '\n&HEADC(412)  SETC  '  /     '\n&HEADC(413)  SETC  ' /      '\n&HEADC(414)  SETC  '/       '\n&HEADC(415)  SETC  '\"'\n&HEADC(416)  SETC  '   \"\"   '\n&HEADC(417)  SETC  '   \"\"   '\n&HEADC(418)  SETC  '    \"   '\n&HEADC(419)  SETC  '   \"    '\n&HEADC(420)  SETC  '        '\n&HEADC(421)  SETC  '        '\n&HEADC(422)  SETC  '        '\n&HEADC(423)  SETC  '        '\n&HEADC(424)  SETC  '-'\n&HEADC(425)  SETC  '        '\n&HEADC(426)  SETC  '        '\n&HEADC(427)  SETC  '        '\n&HEADC(428)  SETC  '        '\n&HEADC(429)  SETC  ' -------'\n&HEADC(430)  SETC  '        '\n&HEADC(431)  SETC  '        '\n&HEADC(432)  SETC  '        '\n&HEADC(433)  SETC  '*'\n&HEADC(434)  SETC  '        '\n&HEADC(435)  SETC  '  *   * '\n&HEADC(436)  SETC  '   * *  '\n&HEADC(437)  SETC  ' *******'\n&HEADC(438)  SETC  '   * *  '\n&HEADC(439)  SETC  '  *   * '\n&HEADC(440)  SETC  '        '\n&HEADC(441)  SETC  '        '\n&HEADC(442)  SETC  'END'           MARKS END OF THE CHARACTER LIST\n.PROC    ANOP  ,\n.*\n.*\n         AIF   (K'&TITLE LE 0).NTITL\n.*\n         AIF   ('&TITLE' NE 'EJECT').NEJEC\n         EJECT\n         AGO   .NTITL\n.*\n.NEJEC   ANOP\n&TITLE(1) TITLE &TITLE(2)\n.*\n.*\n.NTITL   ANOP\n.*\n.*\n&K       SETA  K'&STRING\n         AIF   ((&K EQ 0) OR (&K GT 64)).DONE\n.*\n.*\n         AIF   ('&BLOCK' EQ 'NO').NBLK1\n MNOTE   '**************************************************************\n               **********'\n&B       SETC  '*'\n.NBLK1   ANOP  ,\n.*\n.*\n.*\n&M       SETA  1\n.COPY2   ANOP  ,\n&STR(&M) SETC  '&STRING'(&M,1)\n&M       SETA  &M+1\n         AIF   (&M LE &K).COPY2\n.*\n&J       SETA  0\n&M       SETA  0\n.*\n.*\n.EDIT    AIF   (&M EQ &K).AGIN\n&M       SETA  &M+1\n&I       SETA  &M\n         AIF   ('&STR(&M)' NE '''').EDIT\n.*\n         AIF   (&J GT 0).QTCK\n.*\n&J       SETA  1\n         AGO   .COMP\n.*\n.*\n.QTCK    AIF   ('&STR(&M+1)' NE '''').COMP\n.*\n&STR(&M) SETC  '\"'\n&J       SETA  0\n&M       SETA  &M+1\n&I       SETA  &M\n.*\n.*\n.COMP    ANOP\n&STR(&I) SETC  '&STR(&I+1)'\n&I       SETA  &I+1\n         AIF   (&I LT &K).COMP\n.*\n&STR(&K) SETC  ' '\n&K       SETA  &K-1\n&M       SETA  &M-1\n         AGO   .EDIT\n.*\n.*\n.AGIN    ANOP\n&I       SETA  1\n&L       SETA  &K-&N\n         AIF   (&L LE 0).ENDOFF\n.*\n         AIF   (&L LE 8).CK4\n.*\n&L       SETA  8\n.*\n.*\n.CK4     ANOP\n&J       SETA  (8-&L)/2*8\n.*\n.*\n.FILT    AIF   (&I GT &J).SETL\n.*\n&F(&I)   SETC  '        '\n&F(&I+1) SETC  '        '\n&F(&I+2) SETC  '        '\n&F(&I+3) SETC  '        '\n&F(&I+4) SETC  '        '\n&F(&I+5) SETC  '        '\n&F(&I+6) SETC  '        '\n&F(&I+7) SETC  '        '\n&I       SETA  &I+8\n         AGO   .FILT\n.*\n.*\n.SETL    ANOP\n&L       SETA  &L+&N\n.*\n.*\n.LOOP    AIF   (&N EQ &L).FINI\n.*\n&N       SETA  &N+1\n&J       SETA  1\n&W       SETC  '&STR(&N)'\n.*\n.*\n.MTCH    AIF   ('&W' EQ '&HEADC(&J)').GO\n.*\n&J       SETA  &J+9\n         AIF   ('&HEADC(&J)' NE 'END').MTCH\n&J       SETA  &J-9\n.*\n.*\n.GO      ANOP\n.*\n&F(&I)   SETC  '&HEADC(&J+1)'\n&F(&I+1) SETC  '&HEADC(&J+2)'\n&F(&I+2) SETC  '&HEADC(&J+3)'\n&F(&I+3) SETC  '&HEADC(&J+4)'\n&F(&I+4) SETC  '&HEADC(&J+5)'\n&F(&I+5) SETC  '&HEADC(&J+6)'\n&F(&I+6) SETC  '&HEADC(&J+7)'\n&F(&I+7) SETC  '&HEADC(&J+8)'\n&I       SETA  &I+8\n         AGO   .LOOP\n.*\n.*\n.FINI    AIF   (&I GT 64).DOIT\n.*\n&F(&I)   SETC  '        '\n&F(&I+1) SETC  '        '\n&F(&I+2) SETC  '        '\n&F(&I+3) SETC  '        '\n&F(&I+4) SETC  '        '\n&F(&I+5) SETC  '        '\n&F(&I+6) SETC  '        '\n&F(&I+7) SETC  '        '\n&I       SETA  &I+8\n         AGO   .FINI\n.*\n.*\n.DOIT    AIF   ('&BLOCK' EQ 'NO').SPACE\n MNOTE   '*                                                            *\n                        *'\n MNOTE   '*                                                            *\n                        *'\n         AGO   .DOIT2\n.SPACE   ANOP   ,\n         SPACE 2\n.DOIT2   ANOP  ,\n MNOTE   '&B  &F(1)&F(9)&F(17)&F(25)&F(33)&F(41)&F(49)&F(57)   &B'\n MNOTE   '&B  &F(2)&F(10)&F(18)&F(26)&F(34)&F(42)&F(50)&F(58)   &B'\n MNOTE   '&B  &F(3)&F(11)&F(19)&F(27)&F(35)&F(43)&F(51)&F(59)   &B'\n MNOTE   '&B  &F(4)&F(12)&F(20)&F(28)&F(36)&F(44)&F(52)&F(60)   &B'\n MNOTE   '&B  &F(5)&F(13)&F(21)&F(29)&F(37)&F(45)&F(53)&F(61)   &B'\n MNOTE   '&B  &F(6)&F(14)&F(22)&F(30)&F(38)&F(46)&F(54)&F(62)   &B'\n MNOTE   '&B  &F(7)&F(15)&F(23)&F(31)&F(39)&F(47)&F(55)&F(63)   &B'\n MNOTE   '&B  &F(8)&F(16)&F(24)&F(32)&F(40)&F(48)&F(56)&F(64)   &B'\n         AGO   .AGIN\n.*\n.*\n.ENDOFF  AIF   ('&BLOCK' EQ 'NO').DONE\n MNOTE   '*                                                            *\n                        *'\n MNOTE   '*                                                            *\n                        *'\n MNOTE   '**************************************************************\n               **********'\n.*\n.*\n.DONE    ANOP\n         SPACE 3\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$PROLOG": {"ttr": 777, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   $PROLOG &LV=0\n.**********************************************************************\n.*\n.*       THIS MACRO WILL PROVIDE ENTRY LINKAGE AND OPTIONALLY\n.*       MULTIPLE BASE REGISTERS.  ALSO, VIA THE 'LV=' KEYWORD\n.*       PROVIDE ADDITIONAL USER STORAGE (APPENDED TO THE\n.*       SAVE AREA) ADDRESSABLE FROM REG 13.  IF NO OPERANDS\n.*       ARE CODED, REG 12 IS ASSUMED THE BASE. EXAMPLE:\n.*              SECTNAME $PROLOG          = STANDARD REG 12 BASE\n.*              SECTNAME $PROLOG 5        = STANDARD, REG 5 BASE\n.*              SECTNAME $PROLOG 10,LV=20 = ADD 20 BYTES TO SAVE AREA\n.*                                             REG 10 IS BASE\n.*              SECTNAME $PROLOG R10,R11  = REGS 10 AND 11 ARE BASES\n.*\n.**********************************************************************\n         LCLA  &AA,&AB,&AC\n         GBLB  &PRORG\n&AC      SETA  4096\n&LABEL   CSECT\n         B     32(R15)             BRANCH AROUND\n         DC    AL1(26)\n         DC    CL8'&LABEL'         CSECT NAME\n         DC    C'-'\n         DC    CL8'&SYSDATE'       COMPILE DATE\n         DC    C'-'\n         DC    CL8'&SYSTIME'       COMPILE TIME\n         CNOP  0,4                 ALIGNMENT\n         STM   R14,R12,12(R13)     SAVE REGISTERS\n         LR    R12,R15             LOAD BASE REG\n         USING &LABEL,R12          INFORM ASSEMBLER\n         AIF   (&LV GT 4023).MERR\n         LA    R0,&LV+72           LOAD REG 0 WITH LENGTH VARIABLE\n         GETMAIN R,LV=(0)          GET CORE FOR SAVEAREA AND USER\n         AIF   (&LV+72 LE 256).XC2\n         AIF   (&LV+72 LE 512).XC1\n         MVI   0(R1),X'00'         MOVE X'00' TO FIRST BYTE\n         LR    R2,R1               SAVE POINTER IN EVEN REG\n         LA    R4,1(R1)            SET RECEIVING POINTER\n         LR    R5,R0               SET RECEIVING LENGTH\n         BCTR  R5,R0               DECREMENT LENGTH\n         LA    R5,0(R5)            CLEAR HIGH ORDER BYTE\n         LA    R3,1                SET SENDING LENGTH\n         MVCL  R4,R2               INSTRUCTION PADS WITH X'00'\n         AGO   .STORE\n.XC1     ANOP\n         XC    256(&LV-184,R1),256(R1)  CLEAR SAVE AREA\n         XC    0(256,R1),0(R1)          CLEAR SAVE AREA\n         AGO   .STORE\n.XC2     ANOP\n         XC    0(&LV+72,R1),0(R1)       CLEAR SAVE AREA\n.STORE   ANOP\n         ST    R13,4(R1)           SAVE BACK CHAIN\n         ST    R1,8(R13)           SET FORWARD CHAIN\n         LR    R11,R1              SAVE NEW SAVEAREA ADDRESS\n         L     R15,16(R13)         RESTORE REG 15\n         ST    R0,16(R13)          SAVE SAVEAREA LENGTH\n         LM    R0,R1,20(R13)       RESTORE REGS USED IN GETMAIN\n         LR    R13,R11             SET SAVEAREA POINTER\n         AIF   (N'&SYSLIST EQ 0).MEND\n         AIF   ('&SYSLIST(1)' EQ 'R12').SKIPIT\n         AIF   ('&SYSLIST(1)' EQ '12').SKIPIT\n         LA    &SYSLIST(1),&LABEL  LOAD REQUESTED BASE REG\n         DROP  R12                 DROP ASSUMED BASE REG\n         USING &LABEL,&SYSLIST(1)  INFORM ASSEMBLER\n.SKIPIT  ANOP\n&AA      SETA  2\n.LOOP    ANOP\n         AIF   (&AA GT N'&SYSLIST).MEXIT\n&AB      SETA  &AA-1\n         LA    &SYSLIST(&AA),2048(&SYSLIST(&AB))  LOAD NEXT BASE REG\n         LA    &SYSLIST(&AA),2048(&SYSLIST(&AA))  LOAD NEXT BASE REG\n         USING &LABEL+&AC,&SYSLIST(&AA) INFORM ASSEMBLER\n&AC      SETA  &AC+4096\n&AA      SETA  &AA+1\n         AGO   .LOOP\n.MEXIT   ANOP\n         AIF   (&PRORG).MEX2\n         SPACE\n         $REGS\n         SPACE\n.MEX2    ANOP\n&AA      SETA  &LV+72\n         MNOTE *,'TOTAL STORAGE AREA RECEIVED = &AA'\n         MEXIT\n.MEND    ANOP\n         MNOTE *,'NO REGISTER SPECIFIED - R12 ASSUMED'\n         AGO   .MEXIT\n.MERR    ANOP\n         MNOTE 12,'LV > 4023 - REQUEST IGNORED'\n         AGO   .MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$REGS": {"ttr": 780, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         $REGS\n         GBLB  &PRORG\n         AIF   (&PRORG).MEX2\n&PRORG   SETB  1\n SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n SPACE\nREG0     EQU   0\nREG1     EQU   1\nREG2     EQU   2\nREG3     EQU   3\nREG4     EQU   4\nREG5     EQU   5\nREG6     EQU   6\nREG7     EQU   7\nREG8     EQU   8\nREG9     EQU   9\nREG10    EQU   10\nREG11    EQU   11\nREG12    EQU   12\nREG13    EQU   13\nREG14    EQU   14\nREG15    EQU   15\n SPACE\n.MEX2    ANOP\n       MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$TEST": {"ttr": 1025, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   $TEST &FLAG,&OPCD,&BR=0\n         LCLA  &RGLN,&FLNG,&PNTR\n         LCLB  &BRREG\n         LCLC  &BRCD,&BRCHR,&FLG1\n&BRREG   SETB  0\n&BRCHR   SETC  '&BR'\n         AIF   ('&BRCHR' NE '0').P1\n         MNOTE 8,'BRANCH LABEL OR REGISTER REQUIRED.'\n         MEXIT\n.P1      ANOP\n         AIF   ('&FLAG' NE '').P2\n         MNOTE 8,'A FLAG TO BE TESTED IS REQUIRED.'\n         MEXIT\n.P2      ANOP\n&FLNG    SETA  K'&FLAG\n&PNTR    SETA  1\n.P2A     ANOP\n         AIF   ('&FLAG'(&PNTR,1) NE '-').P2B\n         MNOTE 8,'FLAG SPECIFIACTION &FLAG IS INVALID.'\n         MEXIT\n.P2B     ANOP\n         AIF   ('&PNTR' EQ '&FLNG').P2C\n&PNTR    SETA  &PNTR+1\n         AGO   .P2A\n.P2C     ANOP\n&PNTR    SETA  1\n.P2D     ANOP\n         AIF   ('&FLAG'(&PNTR,1) EQ '+').P2E\n         AIF   ('&PNTR' EQ '&FLNG').P2F\n&PNTR    SETA  &PNTR+1\n         AGO   .P2D\n.P2E     ANOP\n&PNTR    SETA  &PNTR-1\n&FLG1    SETC  '&FLAG'(1,&PNTR)\n         AGO   .P2G\n.P2F     ANOP\n&FLG1    SETC  '&FLAG'\n.P2G     ANOP\n&LABEL   TM    #&FLG1,&FLAG                 TEST FLAG FOR CC\n         AIF   ('&OPCD' NE '').P3\n         MNOTE 8,'AN OPERATION CODE MUST BE SPECIFIED.'\n         MEXIT\n.P3      ANOP\n         AIF   ('&BRCHR'(1,1) EQ '(').P03\n         AIF   ('&OPCD' NE 'ONES').P4\n&BRCD    SETC  'BO'\n         AGO   .C1\n.P4      ANOP\n         AIF   ('&OPCD' NE 'MIXED').P5\n&BRCD    SETC  'BM'\n         AGO   .C1\n.P5      ANOP\n         AIF   ('&OPCD' NE 'ZEROS').P6\n&BRCD    SETC  'BZ'\n         AGO   .C1\n.P6      ANOP\n         AIF   ('&OPCD' NE 'NONES').P7\n&BRCD    SETC  'BNO'\n         AGO   .C1\n.P7      ANOP\n         AIF   ('&OPCD' NE 'NMIXED').P8\n&BRCD    SETC  'BNM'\n         AGO   .C1\n.P8      ANOP\n         AIF   ('&OPCD' NE 'NZEROS').P9\n&BRCD    SETC  'BNZ'\n         AGO   .C1\n.P9      ANOP\n         MNOTE 8,'INVALID OPERATION CODE. SEE TEST UNDER MASK FOR VALIDX\n               OPCODES.'\n         MEXIT\n.P03     ANOP\n&BRREG   SETB  1\n         AIF   ('&OPCD' NE 'ONES').P04\n&BRCD    SETC  'BOR'\n         AGO   .C1\n.P04     ANOP\n         AIF   ('&OPCD' NE 'MIXED').P05\n&BRCD    SETC  'BMR'\n         AGO   .C1\n.P05     ANOP\n         AIF   ('&OPCD' NE 'ZEROS').P06\n&BRCD    SETC  'BZR'\n         AGO   .C1\n.P06     ANOP\n         AIF   ('&OPCD' NE 'NONES').P07\n&BRCD    SETC  'BNOR'\n         AGO   .C1\n.P07     ANOP\n         AIF   ('&OPCD' NE 'NMIXED').P08\n&BRCD    SETC  'BNMR'\n         AGO   .C1\n.P08     ANOP\n         AIF   ('&OPCD' NE 'NZEROS').P9\n&BRCD    SETC  'BNZR'\n.C1      ANOP\n         AIF   (&BRREG).C2\n         &BRCD &BR                BRANCH ON MET CONDITION\n         MEXIT\n.C2      ANOP\n&RLGN    SETA  2\n.C3      ANOP\n         AIF   ('&BRCHR'(&RLGN,1) EQ ')').C3A\n&RLGN    SETA  &RLGN+1\n         AGO   .C3\n.C3A     ANOP\n&RLGN    SETA  &RLGN-2\n&BRCHR   SETC  '&BRCHR'(2,&RLGN)\n.C4      ANOP\n         &BRCD &BRCHR             BRANCH ON MET CONDITION\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#CONVDAT": {"ttr": 1028, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   #CONVDAT  &REG=2,&MLABEL=MONTH,&DLABEL=DAY,&YLABEL=YEAR,      X\n               &ALABEL=MNTHABRE,&RESTORE=NO,&RENT=YES\n.*\n.*  NAME     $CONVDAT\n.*  DATE     25 NOVEMBER 1986\n.*  AUTHOR   JOHN D. SOSTROM\n.*           DAYCO PRODUCTS INCORPORATED\n.*           333 W. FIRST ST.\n.*           DAYTON, OHIO\n.*           (513)226-5747\n.*\n.*  THIS MACRO CONVERTS A PACKED JULIAN FORMAT DATE PASSED IN A\n.*  TO A GREGORIAN DATE FORMAT POINTED TO BY THE REGISTER USED TO\n.*  SUPPLY THE JULIAN DATE IN THE FIRST PLACE.\n.*\n.*  THE REGISTER PASSED BY THE REG= PARAMETER MAY NOT BE REGISTER\n.*  ZERO(0).  IF THE FIRST INVOKATION OF $CONVDAT IS SPECIFIED WITH\n.*  RENT=YES THEN ALL SUBSIQUENT INVOCATIONS WILL BE HANDELED THE SAME.\n.*\n.*  IF RENT=YES IS SPECIFIED THEN REGISTER ZERO MUST CONTAIN THE\n.*  ADDRESS OF A 160 BYTE WORK AREA.\n.*\n         GBLB  &CONV,&LABPASS,&GRENT,&NGRENT\n         GBLC  &CONVL1,&CONVL2,&CONVL3,&CONVL4,&CONVL5\n         GBLC  &MLAB01,&MLAB02,&MLAB03,&MLAB04,&MLAB05,&MLAB06\n         GBLC  &MLAB07,&MLAB08,&MLAB09,&MLAB10,&MLAB11,&MLAB12,&MLAB13\n         GBLC  &MLAB14,&MLAB15,&MLAB16,&MLAB17,&MLAB18,&MLAB19,&MLAB20\n         GBLC  &WLAB02,&WLAB03,&WLAB04,&WLAB05,&WLAB06,&WLAB07,&MLAB99\n         GBLC  &WLAB08,&WLAB09,&WLAB10,&WLAB11,&WLAB12,&WLAB13,&WLAB14\n         GBLC  &WLAB15,&WLAB16\n         GBLC  &COVSECT,&DSLABEL                .CSECT NAME WHERE AREAS\n         LCLB  &LAB1,&LAB2,&LAB3,&LAB4\n         LCLB  &NSECT,&GPAS1                    .NOT CURRENT CSECT\n         LCLC  &LSECT,&LXLAB1,&LXLAB2,&LXLAB3,&LXLAB4\n   AIF   ('&REG' NE '0' AND '&REG' NE 'R0' AND '&REG' NE 'REG0').CONT1\n         MNOTE 8,'REGISTER 0 CANNOT BE USED SINCE IT IS DESTROYED'\n         MEXIT\n.CONT1   ANOP\n&LSECT   SETC  '&SYSECT'\n         AIF   ('&RENT' EQ 'NO').NSETR1\n&GRENT   SETB  1\n.NSETR1  ANOP\n         AIF   (&NGRENT AND NOT &GRENT).NSETR3\n         AIF   (&GRENT AND NOT &NGRENT).NSETR3\n         AIF   (&NGRENT AND &GRENT).NSETR2\n&NGRENT  SETB  1\n         AGO   .NSETR3\n.NSETR2  ANOP\n         MNOTE 4,'PREVIOUS INVOCATION OF $CONVDAT SPECIFIED RENT=NO. SPX\n               ECIFICATION OF RENT=YES AT THIS IS IGNORED.'\n&GRENT   SETB  0\n.NSETR3  ANOP\n&LXLAB1  SETC  'Z&SYSNDX.S'\n&LXLAB2  SETC  'Z&SYSNDX.T'\n&LXLAB3  SETC  'Z&SYSNDX.U'\n&LXLAB4  SETC  'Z&SYSNDX.V'\n&LAB1    SETB  0\n&LAB2    SETB  0\n&LAB3    SETB  0\n&LAB4    SETB  0\n&NSECT   SETB  0\n         AIF   (&CONV).CHKLAB\n&CONV    SETB  1\n&LABPASS SETB  0\n.* GLOBAL LABELS\n&COVSECT SETC  '&SYSECT'\n&CONVL1  SETC  '&MLABEL'\n&CONVL2  SETC  '&DLABEL'\n&CONVL3  SETC  '&YLABEL'\n&CONVL4  SETC  '&ALABEL'\n&CONVL5  SETC  'D&SYSNDX.A'\n&MLAB01  SETC  'M&SYSNDX.A'\n&MLAB02  SETC  'M&SYSNDX.B'\n&MLAB03  SETC  'M&SYSNDX.C'\n&MLAB04  SETC  'M&SYSNDX.D'\n&MLAB05  SETC  'M&SYSNDX.E'\n&MLAB06  SETC  'M&SYSNDX.F'\n&MLAB07  SETC  'M&SYSNDX.J'\n&MLAB08  SETC  'M&SYSNDX.K'\n&MLAB09  SETC  'M&SYSNDX.O'\n&MLAB10  SETC  'M&SYSNDX.P'\n&MLAB11  SETC  'M&SYSNDX.R'\n&MLAB12  SETC  'M&SYSNDX.S'\n&MLAB13  SETC  'M&SYSNDX.T'\n&MLAB14  SETC  'C&SYSNDX.A'\n&MLAB15  SETC  'C&SYSNDX.B'\n&MLAB16  SETC  'C&SYSNDX.C'\n&MLAB17  SETC  'C&SYSNDX.D'\n&MLAB18  SETC  'C&SYSNDX.E'\n&MLAB19  SETC  'C&SYSNDX.F'\n&MLAB20  SETC  'C&SYSNDX.G'\n&MLAB99  SETC  'M&SYSNDX.U'\n&WLAB02  SETC  'W&SYSNDX.B'\n&WLAB03  SETC  'W&SYSNDX.C'\n&WLAB04  SETC  'W&SYSNDX.D'\n&WLAB05  SETC  'W&SYSNDX.E'\n&WLAB06  SETC  'W&SYSNDX.F'\n&WLAB07  SETC  'W&SYSNDX.G'\n&WLAB08  SETC  'W&SYSNDX.H'\n&WLAB09  SETC  'W&SYSNDX.I'\n&WLAB10  SETC  'W&SYSNDX.J'\n&WLAB11  SETC  'W&SYSNDX.K'\n&WLAB12  SETC  'W&SYSNDX.L'\n&WLAB13  SETC  'W&SYSNDX.M'\n&WLAB14  SETC  'W&SYSNDX.N'\n&WLAB15  SETC  'W&SYSNDX.P'\n&WLAB16  SETC  'W&SYSNDX.Q'\n&DSLABEL SETC  'D&SYSNDX.O'\n         AGO   .NOCHK\n.CHKLAB  ANOP\n         AIF   ('&MLABEL' EQ '&CONVL1').LAB1GO\n&LAB1    SETB  1\n.LAB1GO  ANOP\n         AIF   ('&DLABEL' EQ '&CONVL2').LAB2GO\n&LAB2    SETB  1\n.LAB2GO  ANOP\n         AIF   ('&YLABEL' EQ '&CONVL3').LAB3GO\n&LAB3    SETB  1\n.LAB3GO  ANOP\n         AIF   ('&ALABEL' EQ '&CONVL4').LAB4GO\n&LAB4    SETB  1\n.LAB4GO  ANOP\n         AIF   ('&COVSECT' EQ '&SYSECT').SAMSECT\n&NSECT   SETB  1\n.SAMSECT ANOP\n         AIF   (NOT &NSECT).NMSG01\n*\n*        REG 0 AND 1 ARE DESTROYED BY THIS ROUTINE\n.NMSG01  ANOP\n         AIF   (NOT &GRENT).NMSG02\n*\n*       REGISTER 1 MUST CONTAIN THE ADDRESS OF A 274 BYTE WORK AREA ON\n*              A FULL WORD BOUNDRY FOR THIS ROUTINE\n*\n*        THE MLABEL=, DLABEL=, YLABEL=, ALABEL= AND RETURN= PARAMETERS\n*        ARE IGNORED WHEN RENT=YES IS SPECIFIED.\n*\n*\n*\n*\n*\n*\n*\n*\n.NMSG02  ANOP\n*\n*        REG      = THE REGISTER CONTAING THE PACKED JULIAN DATE\n*        MLABEL   = THE MONTH LABEL YOU WANT. DEFAULT = MONTH\n*        DLABEL   = THE DAY OF THE MONTH LABEL YOU WANT. DEFAULT = DAY\n*              DLABEL VALUE COMES OUT WRONG - NOT FIXED YET\n*        YLABEL   = THE YEAR LABEL YOU WANT. DEFAULT = YEAR\n*        ALABEL   = THE MONTH NAME LABEL YOU WANT\n*        RENT     = SPECIFIES IF THIS MACRO IS TO BE REENTRANT FORMAT\n*                   THE ADDRESS POINTED TO REG 0 MUST BE THE WORK AREA\n*                   TO BE USED ON A DOUBLE WORK BOUNDRY\n*\n*        THIS ROUTINE ALSO USES REGISTERS 2, 3 AND 4 WHICH IT RESTORES\n*        PRIOR TO LOADING THE POINTER REGISTER ADDRESS\n*\n*        THIS ROUTINE CONVERTS THE JULIAN DATE INTO THE CALENDAR DATE\n*\n*        EX.   FROM 75339 TO 12/05/75\n*\n         AIF   (NOT &GRENT).NMSG03\n*\n*        THE REGISTER SPECIFIED IN THE REG= KEYWORD WILL CONTAIN THE\n*        ADDRESS OF THE CONVERTED DATE.\n*\n.NMSG03  ANOP\n*        IF RESTORE=NO IS SPECIFIED (DEFAULT) THEN\n*        THEN THE REGISTER SPECIFIED BY THE REG= KEYWORD IS LOADED WITH\n*        THE ADDRESS OF THE CONVERTED DATE FIELD ADDRESS POINTER.\n*\n*        IF RESTORE=YES IS SPECIFIED THEN\n*        THE REGISTER VALUE PASSED IN THE REGISTER SPECIFIED IN THE\n*        REG= OPERAND IS RESTORED AS OBTAINED\n*\n.NOCHK   ANOP\n&LABEL   DS    0H\n         AIF   (&GRENT).RGO001\n         AIF   (&NSECT).REMOTE\n.RGO001  ANOP\n         AIF   (NOT &GRENT).RGO002\n         USING &DSLABEL,1\n         MVC   &MLAB05.(&LXLAB3),&LXLAB1 INITIALIZE AREA\n         MVC   &MLAB04.(&LXLAB4),&LXLAB2 INITIALIZE AREA\n.RGO002  ANOP\n         STM   2,4,&MLAB12             SAVE REGISTERS 1, 2 AND 3\n         ZAP   &MLAB01,=P'01'          INITIALIZE MONTH\n         ZAP   &MLAB02+2(2),=P'28'     INITIALIZE FEB\n         MVC   &MLAB03.(4),=CL4' '      INITIALIZE MONTH ABREV.\n         ST    &REG,&MLAB04            STORE JULIAN DATE\n         ST    &REG,&MLAB13            STORE JULIAN DATE FOR RESTORE\n         XC    &MLAB05,&MLAB05       ZERO WORK AREA\n         MVC   &MLAB05+3(1),&MLAB04+1 MOVE YEAR INTO WORK\n         L     &REG,&MLAB05            LOAD YEAR INTO REGISTER\n         SLL   &REG,4                  SHIFT LEFT 1/2 BYTE\n         ST    &REG,&MLAB05            STORE YEAR INTO WORK AGAIN\n         OI    &MLAB05+3,X'0F'        CONVERT YEAR INTO PACKED FORMAT\n         ZAP   &MLAB06,&MLAB05         SAVE YEAR\n         DP    &MLAB05,=P'04'         DIVIDE YEAR BY 4\n         CP    &MLAB05+2(2),=P'00'    IF REMAINDER THEN LEAP YEAR\n         BNE   M&SYSNDX.G              NOT A LEAP YEAR\n         ZAP   &MLAB02+2(2),=P'29'     SET MONTH 2 EQUAL TO 29 DAYS\nM&SYSNDX.G LA  2,&MLAB02               SET POINTER TO MONTH TABLE\n         L     3,=F'02'                SET COUNTER\n         LA    4,&MLAB01-1             SET POINTER TO END OF TABLE\nM&SYSNDX.I CP  &MLAB04+2(2),0(2,2)     COMPARE DAYS TO MONTH TABLE\n         BNH   M&SYSNDX.H              LESS THAN TABLE\n         AP    &MLAB01,=P'01'          INCRIMENT MONTH COUNTER\n         SP    &MLAB04+2(2),0(2,2)     SUB TABLE DAY FORM JULIAN DAY\n         LA    2,2(2)                  BUMP POINTER\n         CLC   0(2,2),=X'FFFF'         CONTINUE SCAN\n         BE    M&SYSNDX.H\n         B     M&SYSNDX.I         DO IT AGAIN\nM&SYSNDX.H ZAP &MLAB08,&MLAB04+2(2) SET DAY\n         UNPK  &MLAB05,&MLAB08        UNPACK DAY\n         OI    &MLAB05+3,X'F0'        RESET SIGN\n         MVC   &MLAB11.(2),&MLAB05+2 MOVE DAY TO O/P AREA\n         UNPK  &MLAB05,&MLAB01        UNPACK MONTH\n         OI    &MLAB05+3,X'F0'        RESET SIGN\n         MVC   &MLAB09.(2),&MLAB05+2 MOVE MONTH TO O/P AREA\n         UNPK  &MLAB05,&MLAB06        UNPACK YEAR\n         OI    &MLAB05+3,X'F0'        RESER SIGN\n         MVC   &MLAB10.(2),&MLAB05+2 MOVE YEAR TO O/P AREA\n         LA    &REG,&MLAB07-10         SET TABLE POINTER\n         SPACE 1\n*\n**\n***  FIND WHICH MONTH THIS IS\n**\n*\n         SPACE 1\nM&SYSNDX.L LA  &REG,10(&REG)           BUMP POINTER\n         CLC   0(4,&REG),=XL4'FFFFFFFF' END OF TABLE\n         BE    M&SYSNDX.M              MONTH NOT FOUND\n         CLC   &MLAB09.(2),0(&REG)      THIS MONTH?\n         BNE   M&SYSNDX.L              YES, THEN GO MOVE IT\n         MVC   &MLAB03.(4),2(&REG)      MOVE IN MONTH ABREVIATION\n         EJECT\n*\n**\n***  FIND WHICH DAY OF THE WEEK USING ZELLER CONGRUENCE FORMULA\n***       INIT WORK AREAS\n**\n*\n         SPACE 3\n*  DY=DATE\n         ZAP   &WLAB02.(4),&MLAB08.(2) SET DATE   (DY)\n*  MI=MONTH\n         ZAP   &WLAB03.(4),&MLAB01.(2) SET MONTH  (MI)\n*  YR=YEAR\n         ZAP   &WLAB04.(4),&MLAB06.(2) SET YEAR   (YR)\n         OI    &WLAB02+3,X'0F'    SET TO A POSITIVE SIGN\n         OI    &WLAB03+3,X'0F'    SET TO A POSITIVE SIGN\n         OI    &WLAB04+3,X'0F'    SET TO A POSITIVE SIGN\n         SPACE 3\n*  IF MI>2 THEN MA=MI-2 AND YA=YR\n*     ELSE MA=MI+10 AND YA=YR-1\n         SPACE 1\n         MVC   &WLAB05.(4),&WLAB02\n         MVC   &WLAB06.(4),&WLAB04                       YA=YR\n         CP    &WLAB05.(4),=PL4'+2' GREATER THA FEB?      IF MI>2\n         BH    ZA&SYSNDX          YES\n         AP    &WLAB05.(4),=PL4'+10' ADD 10 TO MONTH     MA=MI+10\n         SP    &WLAB06.(4),=PL4'+1' SUBTRACT 1 FROM YEAR YA=YR-1\n         B     ZB&SYSNDX\nZA&SYSNDX DS 0H\n         SP    &WLAB05.(4),=PL4'+2' SUBTRACT 2           MA=MI-2\n         SPACE 3\n* SD=INT(((13*MA)-1)/5)+DY+CY+INT(CY/4)+INT(CN/4)+(5*CN)\n         SPACE 1\nZB&SYSNDX DS 0H\n         MVC   &WLAB07.(4),&WLAB06\n         MVC   &WLAB09.(4),&WLAB05\n         MP    &WLAB09.(4),=PL2'+13'\n         SP    &WLAB09.(4),=PL4'+1'\n         DP    &WLAB09.(4),=PL2'+5'                 INT(((13*MA)-1)/5)\n         LH    2,&WLAB09\n         ST    2,&WLAB09\n         MVC   &WLAB10.(4),&WLAB07\n         DP    &WLAB10.(4),=PL2'+4'                 INT(CY/4)\n         LH    2,&WLAB10\n         ST    2,&WLAB10\n         MVC   &WLAB11.(4),&WLAB08\n         DP    &WLAB11.(4),=PL2'+4'                 INT(CN/4)\n         LH    2,&WLAB11\n         ST    2,&WLAB11\n         MVC   &WLAB12.(4),&WLAB08\n         MP    &WLAB12.(4),=PL2'+5'                 (CN*5)\n         AP    &WLAB13.(4),&WLAB02       DY+\n         AP    &WLAB13.(4),&WLAB07         CY+\n         AP    &WLAB13.(4),&WLAB09           INT(((13*MA)-1)/5)+\n         AP    &WLAB13.(4),&WLAB10              INT(CY/4)+\n         AP    &WLAB13.(4),&WLAB11                 INT(CN/4)+\n         AP    &WLAB13.(4),&WLAB12                    (CN*5)=(SD)\n         SPACE 3\n*  SN=(SD-(7*INT(SD/7)))+1\n*\n*    SN WILL EQUAL A NUMBER FROM 1 TO 7 THAT CORRESPONDS TO THE DAY\n*    OF THE WEEK WITH SUNDAY = 1 AND SATURDAY = 7\n         MVC   &WLAB14.(4),&WLAB13\n         MVC   &WLAB15.(4),&WLAB13\n         DP    &WLAB15.(4),=PL2'7'            INT(SD/7)\n         LH    2,&WLAB15\n         ST    2,&WLAB15\n         MP    &WLAB15.(4),=PL2'7'            7*INT(SD/7)\n         SP    &WLAB14.(4),&WLAB15            SD-(7*INT(SD/7))\n         AP    &WLAB14.(4),=PL4'+1'           (SD-(7*INT(SD/7)))+1=SN\n         SPACE 3\n*  FIND DAY OF WEEK IN TABLE\n         LA    2,&MLAB07-10\n         UNPK  &WLAB16.(2),&WLAB14+2(2)\n         OI    &WLAB16+1,X'F0'\nZC&SYSNDX DS 0H\n         LA    2,10(2)            BUMP TO NEXT ENTRY\n         CLC   &WLAB16.(2),0(2)  THIS IT?\n         BE    ZD&SYSNDX          YES\n         CLC   0(2,2),=X'FFFF'    END OF TABLE?\n         BE    ZE&SYSNDX          YES, NOT FOUND\n         B     ZC&SYSNDX          TRY NEXT\n         SPACE 1\nZD&SYSNDX DS 0H\n         MVC   &MLAB99.(4),6(2)\nZE&SYSNDX DS 0H\n         AGO   .LOCALS\n.REMOTE  ANOP\n         L     1,=V(&MLAB12)           POINT TO REGISTER SAVE AREA\n         STM   2,4,0(1)                SAVE REGISTERS 1, 2 AND 3\n         L     1,=V(&MLAB01)           INITIALIZE AREAS\n         ZAP   0(2,1),=P'01'           INITIALIZE MONTH\n         L     1,=V(&MLAB02)\n         ZAP   2(2,1),=P'28'            INITIALIZE FEB\n         L     1,=V(&MLAB03)\n         MVC   0(4,1),=CL4' '          INITIALIZE MONTH ABREV.\n         L     1,=V(&MLAB04)           GET ADDRESS\n         ST    &REG,0(1)               STORE JULIAN DATE\n         L     1,=V(&MLAB13)           GET ADDRESS\n         ST    &REG,0(1)               STORE JULIAN DATE FOR RESTORE\n         L     1,=V(&MLAB05)           GET ADDRESS\n         XC    0(4,1),0(1)             ZERO WORK AREA\n         L     &REG,=V(&MLAB04)        GET ADDRESS\n         MVC   3(1,1),1(&REG)          MOVE YEAR INTO WORK\n         L     &REG,0(1)               LOAD YEAR INTO REGISTER\n         SLL   &REG,4                  SHIFT LEFT 1/2 BYTE\n         ST    &REG,0(1)               STORE YEAR INTO WORK AGAIN\n         OI    3(1),X'0F'              CONVERT YEAR INTO PACKED FORMAT\n         L     &REG,=V(&MLAB06)        GET ADDRESS\n         ZAP   0(2,&REG),0(4,1)        SAVE YEAR\n         DP    0(4,1),=P'04'           DIVIDE YEAR BY 4\n         CP    2(2,1),=P'00'           IF REMAINDER THEN LEAP YEAR\n         BNE   M&SYSNDX.G              NOT A LEAP YEAR\n         L     &REG,=V(&MLAB02)\n         ZAP   2(2,&REG),=P'29'        SET MONTH 2 EQUAL TO 29 DAYS\nM&SYSNDX.G L   2,=V(&MLAB02)           SET POINTER TO MONTH TABLE\n         L     3,=F'02'                SET COUNTER\n         L     4,=V(&MLAB01)           SET POINTER TO END OF TABLE\n         S     4,=F'1'                 SET POINTER TO END OF TABLE\n         L     &REG,=V(&MLAB04)\n         L     1,=V(&MLAB01)\nM&SYSNDX.I CP  2(2,&REG),0(2,2)        COMPARE DAYS TO MONTH TABLE\n         BNH   M&SYSNDX.H              LESS THAN TABLE\n         AP    0(2,1),=P'01'           INCRIMENT MONTH COUNTER\n         SP    2(2,&REG),0(2,2)        SUB TABLE DAY FORM JULIAN DAY\n         LA    2,2(2)\n         CLC   0(2,2),=XL2'FFFF'       CONTINUE SCAN\n         BE    M&SYSNDX.H\n         B     M&SYSNDX.I\nM&SYSNDX.H DS  0H\n         L     1,=V(&MLAB08)\n         ZAP   0(2,1),2(2,&REG)       SET DAY\n         L     &REG,=V(&MLAB05)\n         UNPK  0(4,&REG),0(2,1)       UNPACK DAY\n         OI    3(&REG),X'F0'          RESET SIGN\n         L     1,=V(&MLAB11)\n         MVC   0(2,1),2(&REG)         MOVE DAY TO O/P AREA\n         L     1,=V(&MLAB01)\n         UNPK  0(4,&REG),0(2,1)       UNPACK MONTH\n         OI    3(&REG),X'F0'          RESET SIGN\n         L     1,=V(&MLAB09)\n         MVC   0(2,1),2(&REG)         MOVE MONTH TO O/P AREA\n         L     1,=V(&MLAB06)\n         UNPK  0(4,&REG),0(2,1)       UNPACK YEAR\n         OI    3(&REG),X'F0'          RESER SIGN\n         L     1,=V(&MLAB10)\n         MVC   0(2,1),2(&REG)         MOVE YEAR TO O/P AREA\n         L     &REG,=V(&MLAB07)       SET TABLE POINTER\n         S     &REG,=F'10'            SET TABLE POINTER\n         SPACE 1\n*\n**\n***  FIND WHICH MONTH THIS IS\n**\n*\n         SPACE 1\nM&SYSNDX.L LA  &REG,10(&REG)          BUMP POINTER\n         CLC   0(4,&REG),=XL4'FFFFFFFF' END OF TABLE\n         BE    M&SYSNDX.M              MONTH NOT FOUND\n         L     1,=V(&MLAB09)\n         CLC   0(2,1),0(&REG)          THIS MONTH?\n         BNE   M&SYSNDX.L              YES, THEN GO MOVE IT\n         L     1,=V(&MLAB03)\n         MVC   0(4,1),2(&REG)          MOVE IN MONTH ABREVIATION\n         EJECT\n*\n**\n***  FIND WHICH DAY OF THE WEEK USING ZELLER CONGRUENCE FORMULA\n***       INIT WORK AREAS\n**\n*\n         SPACE 3\n*  DY=DATE\n         L     1,=V(&WLAB02)\n         L     2,=V(&MLAB08)\n         ZAP   0(4,1),0(2,2) SET DATE   (DY)\n         OI    0(1),X'0F'    SET TO A POSITIVE SIGN\n*  MI=MONTH\n         L     1,=V(&WLAB03)\n         L     2,=V(&MLAB01)\n         ZAP   0(4,1),0(2,2) SET MONTH  (MI)\n         OI    0(1),X'0F'    SET TO A POSITIVE SIGN\n*  YR=YEAR\n         L     1,=V(&WLAB04)\n         L     2,=V(&MLAB06)\n         ZAP   0(4,1),0(2,2) SET YEAR   (YR)\n         OI    0(1),X'0F'    SET TO A POSITIVE SIGN\n         SPACE 3\n*  IF MI>2 THEN MA=MI-2 AND YA=YR\n*     ELSE MA=MI+10 AND YA=YR-1\n         SPACE 1\n         L     1,=V(&WLAB06)\n         L     2,=V(&WLAB04)\n         MVC   0(4,1),0(2)                          YA=YR\n         L     1,=V(&WLAB05)\n         L     2,=V(&WLAB03)\n         MVC   0(4,1),0(2)\n         CP    0(4,1),=PL4'+2' GREATER THA FEB?      IF MI>2\n         BH    ZA&SYSNDX          YES\n         AP    0(4,1),=PL4'+10' ADD 10 TO MONTH     MA=MI+10\n         L     2,=V(&WLAB06)\n         SP    0(4,2),=PL4'+1' SUBTRACT 1 FROM YEAR YA=YR-1\n         B     ZB&SYSNDX\nZA&SYSNDX DS 0H\n         SP    0(4,1),=PL4'+2' SUBTRACT 2           MA=MI-2\n         SPACE 3\n* SD=INT(((13*MA)-1)/5)+DY+CY+INT(CY/4)+INT(CN/4)+(5*CN)\n         SPACE 1\nZB&SYSNDX DS 0H\n         L     1,=V(&WLAB07)\n         L     2,=V(&WLAB06)\n         MVC   0(4,1),0(2)\n         L     1,=V(&WLAB09)\n         L     2,=V(&WLAB05)\n         MVC   0(4,1),0(2)\n         MP    0(4,1),=PL2'+13'\n         SP    0(4,1),=PL4'+1'\n         DP    0(4,1),=PL2'+5'                 INT(((13*MA)-1)/5)\n         LH    2,0(1)\n         ST    2,0(1)\n         L     1,=V(&WLAB10)\n         L     2,=V(&WLAB07)\n         MVC   0(4,1),0(2)\n         DP    0(4,1),=PL2'+4'                 INT(CY/4)\n         LH    2,0(1)\n         ST    2,0(1)\n         L     1,=V(&WLAB11)\n         L     2,=V(&WLAB08)\n         MVC   0(4,1),0(2)\n         DP    0(4,1),=PL2'+4'                 INT(CN/4)\n         LH    2,0(1)\n         ST    2,0(1)\n         L     1,=V(&WLAB12)\n         L     2,=V(&WLAB08)\n         MVC   0(4,1),0(2)\n         MP    0(4,1),=PL2'+5'                 (CN*5)\n         L     1,=V(&WLAB13)\n         L     2,=V(&WLAB02)\n         AP    0(4,1),0(4,2)         DY+\n         L     2,=V(&WLAB07)\n         AP    0(4,1),0(4,2)          CY+\n         L     2,=V(&WLAB09)\n         AP    0(4,1),0(4,2)            INT(((13*MA)-1)/5)+\n         L     2,=V(&WLAB10)\n         AP    0(4,1),0(4,2)               INT(CY/4)+\n         L     2,=V(&WLAB11)\n         AP    0(4,1),0(4,2)                  INT(CN/4)+\n         L     2,=V(&WLAB12)\n         AP    0(4,1),0(4,2)                     (CN*5)=(SD)\n         SPACE 3\n*  SN=(SD-(7*INT(SD/7)))+1\n*\n*    SN WILL EQUAL A NUMBER FROM 1 TO 7 THAT CORRESPONDS TO THE DAY\n*    OF THE WEEK WITH SUNDAY = 1 AND SATURDAY = 7\n         L     1,=V(&WLAB14)\n         L     2,=V(&WLAB13)\n         MVC   0(4,1),0(2)\n         L     1,=V(&WLAB15)\n         MVC   0(4,1),0(2)\n         DP    0(4,1),=PL2'7'            INT(SD/7)\n         LH    2,0(1)\n         ST    2,0(1)\n         MP    0(4,1),=PL2'7'            7*INT(SD/7)\n         L     2,=V(&WLAB14)\n         SP    0(4,2),0(4,1)             SD-(7*INT(SD/7))\n         AP    0(4,2),=PL4'+1'           (SD-(7*INT(SD/7)))+1=SN\n         SPACE 3\n*  FIND DAY OF WEEK IN TABLE\n         L     1,=V(&WLAB16)\n         L     2,=V(&WLAB16)\n         LA    2,2(0,2)\n         UNPK  0(2,1),0(2,2)\n         OI    1(1),X'F0'\n         L     2,=V(&MLAB07)\n         S     2,=F'10'\nZC&SYSNDX DS 0H\n         LA    2,10(2)            BUMP TO NEXT ENTRY\n         CLC   0(2,1),0(2)  THIS IT?\n         BE    ZD&SYSNDX          YES\n         CLC   0(2,2),=X'FFFF'    END OF TABLE?\n         BE    ZE&SYSNDX          YES, NOT FOUND\n         B     ZC&SYSNDX          TRY NEXT\n         SPACE 1\nZD&SYSNDX DS 0H\n         L     1,=V(&MLAB99)\n         MVC   0(4,1),6(2)\nZE&SYSNDX DS 0H\n.LOCALS  ANOP\n         SPACE 1\nM&SYSNDX.M B   X&SYSNDX.Z              BRANCH AROUND WOKK AREA\n         LTORG                         LITERAL POOL\n         DS    0F\n         AIF   (&LABPASS).NOORG1\n         AIF   (NOT &GRENT).NORM01\n&LABPASS SETB  1\n&DSLABEL DSECT\n&MLAB05  DC    F'00'\n         SPACE 3\n&WLAB02  DC    PL4'+0'                WORK AREA DAY (DY)\n&WLAB03  DC    PL4'+0'                WORK AREA MONTH\n&WLAB04  DC    PL4'+0'                WORK AREA YEAR\n.*  IF MONTH <= 2 THEN MA=MONTH-2 AND YA=YEAR-1 ELSE\n.*                     MA=MONTH+10 AND YA=YEAR\n&WLAB05  DC    PL4'+0'                WORK AREA (MA)\n&WLAB06  DC    PL4'+0'                WORK AREA (YA)\n.*   CY=YA-(100*CN)\n&WLAB07  DC    PL4'+0'                WORK AREA (CY)\n.*  CN=INT(YA/100)\n&WLAB08  DC    PL4'+19'           THIS IS A CONSTANT (CN)\n.*  INT(((13*MA)-1)/5)\n&WLAB09  DC    PL4'+0'            INTERMEDIATE WORK AREA 1\n.*  INT(CY/4)\n&WLAB10  DC    PL4'+0'            INTERMEDIATE WORK AREA 2\n.*  INT(CN/4)\n&WLAB11  DC    PL4'+0'            INTERMEDIATE WORK AREA 3\n.*  CN*5\n&WLAB12  DC    PL4'+0'            INTERMEDIATE WORK AREA 4\n.*  SD=INT(((13*MA)-1)/5)+DY+CY+INT(CY/4)+INT(CN/4)+(5*CN)\n&WLAB13  DC    PL4'+0'            INTERMEDIATE WORK AREA 5 (SD)\n.*  SD-(7*INT(SD/7))\n&WLAB14  DC    PL4'+0'            INTERMEDIATE WORK AREA 6 (SN)\n&WLAB15  DC    PL4'+0'            INTERMEDIATE WORK AREA 7\n&WLAB16  DC    PL4'+0'            INTERMEDIATE WORK AREA 8\n         SPACE 3\n&MLAB02  EQU   *\n         DC    PL2'31'\n         DC    PL2'28'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    X'FFFF'\n&MLAB01  DC    PL2'00'                 MONTH WORK AREA\n&MLAB04  DC    F'00'                   REGISTER SAVE AREA FOR REG\n&MLAB06  DC    PL2'00'                 YEAR WORK AREA\n&MLAB08  DC    PL2'00'                 DAY WORK AREA\n&MLAB09  DC    CL2'  '                 MONTH O/P AREA\n         DC    C'/'\n&MLAB11  DC    CL2'  '                 DAY O/P AREA\n         DC    C'/'\n&MLAB10  DC    CL2'  '                 YEAR O/P AREA\n&MLAB03  DC    CL4' '                  MONTH ABREIVIATION\n&MLAB99  DC    CL4' '                  MONTH ABREIVIATION\n         ORG   &MLAB09\n&CONVL1  DC    CL2' '\n         DC    C'/'\n&CONVL2  DC    CL2' '\n         DC    C'/'\n&CONVL3  DC    CL2' '\n&CONVL4  DC    CL4' '\n&CONVL5  DC    CL4' '\n         ORG\n&MLAB07  DC    CL2'01',CL4'JAN',CL4'MON'\n         DC    CL2'02',CL4'FEB',CL4'TUE'\n         DC    CL2'03',CL4'MAR',CL4'TUE'\n         DC    CL2'04',CL4'APR',CL4'WED'\n         DC    CL2'05',CL4'MAY',CL4'THU'\n         DC    CL2'06',CL4'JUN',CL4'FRI'\n         DC    CL2'07',CL4'JUL',CL4'SAT'\n         DC    CL2'08',CL4'AUG',CL4' '\n         DC    CL2'09',CL4'SEP',CL4' '\n         DC    CL2'10',CL4'OCT',CL4' '\n         DC    CL2'11',CL4'NOV',CL4' '\n         DC    CL2'12',CL4'DEC',CL4' '\n         DC    XL10'FFFFFFFFFFFFFFFFFFFF' END OF TABLE\n&MLAB12  DC 3F'0'                       REGISTER SAVE AREA\n&MLAB13  DC F'0'                        REG= REGISTER SAVE AREA\n&SYSECT  CSECT\n&GPAS1   SETB  1\n&LXLAB1  DC    F'00'\n         DC    PL4'+0'                WORK AREA DAY (DY)\n         DC    PL4'+0'                WORK AREA MONTH\n         DC    PL4'+0'                WORK AREA YEAR\n         DC    PL4'+0'                WORK AREA (MA)\n         DC    PL4'+0'                WORK AREA (YA)\n         DC    PL4'+0'                WORK AREA (CY)\n         DC    PL4'+19'           THIS IS A CONSTANT (CN)\n         DC    PL4'+0'            INTERMEDIATE WORK AREA 1\n         DC    PL4'+0'            INTERMEDIATE WORK AREA 2\n         DC    PL4'+0'            INTERMEDIATE WORK AREA 3\n         DC    PL4'+0'            INTERMEDIATE WORK AREA 4\n         DC    PL4'+0'            INTERMEDIATE WORK AREA 5 (SD)\n         DC    PL4'+0'            INTERMEDIATE WORK AREA 6 (SN)\n         DC    PL4'+0'            INTERMEDIATE WORK AREA 7\n         DC    PL4'+0'            INTERMEDIATE WORK AREA 8\n         DC    PL2'31'\n         DC    PL2'28'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    X'FFFF'\n         DC    PL2'00'                 MONTH WORK AREA\n&LXLAB3  EQU   *-&LXLAB1               MOVE LENGTH #1\n&LXLAB2  DC    F'00'                   REGISTER SAVE AREA FOR REG\n         DC    PL2'00'                 YEAR WORK AREA\n         DC    PL2'00'                 DAY WORK AREA\n         DC    CL2'  '                 MONTH O/P AREA\n         DC    C'/'\n         DC    CL2'  '                 DAY O/P AREA\n         DC    C'/'\n         DC    CL2'  '                 YEAR O/P AREA\n         DC    CL4' '                  MONTH ABREIVIATION\n         DC    CL4' '                  DAY OF WEEK ABREVIATION\n         DC    CL2'01',CL4'JAN',CL4'SUN'\n         DC    CL2'02',CL4'FEB',CL4'MON'\n         DC    CL2'03',CL4'MAR',CL4'TUE'\n         DC    CL2'04',CL4'APR',CL4'WED'\n         DC    CL2'05',CL4'MAY',CL4'THU'\n         DC    CL2'06',CL4'JUN',CL4'FRI'\n         DC    CL2'07',CL4'JUL',CL4'SAT'\n         DC    CL2'08',CL4'AUG',CL4' '\n         DC    CL2'09',CL4'SEP',CL4' '\n         DC    CL2'10',CL4'OCT',CL4' '\n         DC    CL2'11',CL4'NOV',CL4' '\n         DC    CL2'12',CL4'DEC',CL4' '\n         DC    XL10'FFFFFFFFFFFFFFFFFFFF' END OF TABLE\n         DC 3F'0'                       REGISTER SAVE AREA\n         DC F'0'                        REG= REGISTER SAVE AREA\n&LXLAB4  EQU   *-&LXLAB2\n         AGO   .NOORG2\n.NORM01  ANOP\n         AIF   (&GRENT).NOORG2\n&MLAB05  DC    F'00'\n         ENTRY &MLAB05\n         SPACE 3\n&WLAB02  DC    PL4'+0'                WORK AREA DAY (DY)\n         ENTRY &WLAB02\n&WLAB03  DC    PL4'+0'                WORK AREA MONTH\n         ENTRY &WLAB03\n&WLAB04  DC    PL4'+0'                WORK AREA YEAR\n         ENTRY &WLAB04\n.*  IF MONTH <= 2 THEN MA=MONTH-2 AND YA=YEAR-1 ELSE\n.*                     MA=MONTH+10 AND YA=YEAR\n&WLAB05  DC    PL4'+0'                WORK AREA (MA)\n         ENTRY &WLAB05\n&WLAB06  DC    PL4'+0'                WORK AREA (YA)\n         ENTRY &WLAB06\n.*   CY=YA-(100*CN)\n&WLAB07  DC    PL4'+0'                WORK AREA (CY)\n         ENTRY &WLAB07\n.*  CN=INT(YA/100)\n&WLAB08  DC    PL4'+19'           THIS IS A CONSTANT (CN)\n         ENTRY &WLAB08\n.*  INT(((13*MA)-1)/5)\n&WLAB09  DC    PL4'+0'            INTERMEDIATE WORK AREA 1\n         ENTRY &WLAB09\n.*  INT(CY/4)\n&WLAB10  DC    PL4'+0'            INTERMEDIATE WORK AREA 2\n         ENTRY &WLAB10\n.*  INT(CN/4)\n&WLAB11  DC    PL4'+0'            INTERMEDIATE WORK AREA 3\n         ENTRY &WLAB11\n.*  CN*5\n&WLAB12  DC    PL4'+0'            INTERMEDIATE WORK AREA 4\n         ENTRY &WLAB12\n.*  SD=INT(((13*MA)-1)/5)+DY+CY+INT(CY/4)+INT(CN/4)+(5*CN)\n&WLAB13  DC    PL4'+0'            INTERMEDIATE WORK AREA 5 (SD)\n         ENTRY &WLAB13\n.*  SD-(7*INT(SD/7))\n&WLAB14  DC    PL4'+0'            INTERMEDIATE WORK AREA 6 (SN)\n         ENTRY &WLAB14\n&WLAB15  DC    PL4'+0'            INTERMEDIATE WORK AREA 7\n         ENTRY &WLAB15\n&WLAB16  DC    PL4'+0'            INTERMEDIATE WORK AREA 8\n         ENTRY &WLAB16\n         SPACE 3\n&MLAB02 EQU *                          MONTH TABLE\n         ENTRY &MLAB02\n         DC    PL2'31'\n         DC    PL2'28'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    X'FFFF'\n&MLAB01  DC    PL2'00'                 MONTH WORK AREA\n         ENTRY &MLAB01\n&MLAB04  DC    F'00'                   REGISTER SAVE AREA FOR REG\n         ENTRY &MLAB04\n&MLAB06  DC    PL2'00'                 YEAR WORK AREA\n         ENTRY &MLAB06\n&MLAB08  DC    PL2'00'                 DAY WORK AREA\n         ENTRY &MLAB08\n&MLAB09  DC    CL2'  '                 MONTH O/P AREA\n         ENTRY &MLAB09\n         DC    C'/'\n&MLAB11  DC    CL2'  '                 DAY O/P AREA\n         ENTRY &MLAB11\n         DC    C'/'\n&MLAB10  DC    CL2'  '                 YEAR O/P AREA\n         ENTRY &MLAB10\n&MLAB03  DC    CL4' '                  MONTH ABREIVIATION\n&MLAB99  DC    CL4' '                  MONTH ABREIVIATION\n         ENTRY &MLAB03\n         ORG   &MLAB09\n&CONVL1  DC    CL2' '\n         ENTRY &CONVL1\n         DC    C'/'\n&CONVL2  DC    CL2' '\n         ENTRY &CONVL2\n         DC    C'/'\n&CONVL3  DC    CL2' '\n         ENTRY &CONVL3\n&CONVL4  DC    CL4' '\n         ENTRY &CONVL4\n&CONVL5  DC    2CL4' '\n         ENTRY &CONVL5\n         ORG\n         AGO   .RLAB01\n.NOORG1  ANOP\n         AIF   (&GRENT).NOORG2\n         AIF   (NOT &LAB1).LOCLAB1\n&MLABEL  DC    CL2' '\n         DC    C'/'\n.LOCLAB1 ANOP\n         AIF   (NOT &LAB2).LOCLAB2\n&DLABEL  DC    CL2' '\n         DC    C'/'\n.LOCLAB2 ANOP\n         AIF   (NOT &LAB3).LOCLAB3\n&YLABEL  DC    CL2' '\n.LOCLAB3 ANOP\n         AIF   (NOT &LAB4).LOCLAB4\n&ALABEL  DC    2CL4' '\n.LOCLAB4 ANOP\n         AIF   (&LABPASS).NOORG2\n.RLAB01  ANOP\n&LABPASS SETB  1\n&MLAB07  DC     CL2'01',CL4'JAN',CL4'SUN'\n         ENTRY &MLAB07\n         DC    CL2'02',CL4'FEB',CL4'MON'\n         DC    CL2'03',CL4'MAR',CL4'TUE'\n         DC    CL2'04',CL4'APR',CL4'WED'\n         DC    CL2'05',CL4'MAY',CL4'THU'\n         DC    CL2'06',CL4'JUN',CL4'FRI'\n         DC    CL2'07',CL4'JUL',CL4'SAT'\n         DC    CL2'08',CL4'AUG',CL4' '\n         DC    CL2'09',CL4'SEP',CL4' '\n         DC    CL2'10',CL4'OCT',CL4' '\n         DC    CL2'11',CL4'NOV',CL4' '\n         DC    CL2'12',CL4'DEC',CL4' '\n         DC    XL10'FFFFFFFFFFFFFFFFFFFF' END OF TABEL\n&MLAB12  DC 3F'0'                       REGISTER SAVE AREA\n         ENTRY &MLAB12\n&MLAB13  DC F'0'                        REG= REGISTER SAVE AREA\n         ENTRY &MLAB13\n.NOORG2  ANOP\n         AIF   (NOT &GRENT).NOORG3\n         AIF   (&GPAS1).NOORG3\n&LXLAB1  DC    F'00'\n         DC    PL4'+0'                WORK AREA DAY (DY)\n         DC    PL4'+0'                WORK AREA MONTH\n         DC    PL4'+0'                WORK AREA YEAR\n         DC    PL4'+0'                WORK AREA (MA)\n         DC    PL4'+0'                WORK AREA (YA)\n         DC    PL4'+0'                WORK AREA (CY)\n         DC    PL4'+19'           THIS IS A CONSTANT (CN)\n         DC    PL4'+0'            INTERMEDIATE WORK AREA 1\n         DC    PL4'+0'            INTERMEDIATE WORK AREA 2\n         DC    PL4'+0'            INTERMEDIATE WORK AREA 3\n         DC    PL4'+0'            INTERMEDIATE WORK AREA 4\n         DC    PL4'+0'            INTERMEDIATE WORK AREA 5 (SD)\n         DC    PL4'+0'            INTERMEDIATE WORK AREA 6 (SN)\n         DC    PL4'+0'            INTERMEDIATE WORK AREA 7\n         DC    PL4'+0'            INTERMEDIATE WORK AREA 8\n         DC    PL2'31'\n         DC    PL2'28'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    X'FFFF'\n         DC    PL2'00'                 MONTH WORK AREA\n&LXLAB3  EQU   *-&LXLAB1\n&LXLAB2  DC    F'00'                   REGISTER SAVE AREA FOR REG\n         DC    PL2'00'                 YEAR WORK AREA\n         DC    PL2'00'                 DAY WORK AREA\n         DC    CL2'  '                 MONTH O/P AREA\n         DC    C'/'\n         DC    CL2'  '                 DAY O/P AREA\n         DC    C'/'\n         DC    CL2'  '                 YEAR O/P AREA\n         DC    CL4' '                  MONTH ABREIVIATION\n         DC    CL4' '                  MONTH ABREIVIATION\n         DC    CL2'01',CL4'JAN',CL4'SUN'\n         DC    CL2'02',CL4'FEB',CL4'MON'\n         DC    CL2'03',CL4'MAR',CL4'TUE'\n         DC    CL2'04',CL4'APR',CL4'WED'\n         DC    CL2'05',CL4'MAY',CL4'THU'\n         DC    CL2'06',CL4'JUN',CL4'FRI'\n         DC    CL2'07',CL4'JUL',CL4'SAT'\n         DC    CL2'08',CL4'AUG',CL4' '\n         DC    CL2'09',CL4'SEP',CL4' '\n         DC    CL2'10',CL4'OCT',CL4' '\n         DC    CL2'11',CL4'NOV',CL4' '\n         DC    CL2'12',CL4'DEC',CL4' '\n         DC    XL10'FFFFFFFFFFFFFFFFFFFF' END OF TABLE\n         DC 3F'0'                       REGISTER SAVE AREA\n         DC F'0'                        REG= REGISTER SAVE AREA\n&LXLAB4  EQU   *-&LXLAB2\n.NOORG3  ANOP\nX&SYSNDX.Z DS  0H\n         AIF   (NOT &GRENT).GCONT01\n         LM    2,4,&MLAB12             RESTORE REGISTERS 1, 2 AND 3\n         LA    &REG,&MLAB09            POINT REGISTER TO CONVERTED DATE\n         DROP  1\n         MEXIT\n.GCONT01 ANOP\n         AIF   (&NSECT).RMTCDE8\n         AIF   (NOT &LAB1).NEXT01\n         MVC   &MLABEL,&CONVL1         MOVE IN MONTH\n.NEXT01  ANOP\n         AIF   (NOT &LAB2).NEXT02\n         MVC   &DLABEL,&CONVL2         MOVE IN DAY\n.NEXT02  ANOP\n         AIF   (NOT &LAB3).NEXT03\n         MVC   &YLABEL,&CONVL3         MOVE IN YEAR\n.NEXT03  ANOP\n         AIF   (NOT &LAB4).NEXT04\n         MVC   &ALABEL,&CONVL4         MOVE IN MONTH ABREVIATION\n         MVC   &ALABEL+4(4),&CONVL5    MOVE IN DAY OF WEEK\n.NEXT04  ANOP\n         LM    2,4,&MLAB12             RESTORE REGISTERS 1, 2 AND 3\n         AIF   ('&RESTORE' EQ 'YES').YESREST\n         LA    &REG,&MLAB09            POINT REGISTER TO CONVERTED DATE\n         MEXIT\n.YESREST ANOP\n         L     &REG,&MLAB13            RESTORE REGISTER PASSED\n         MEXIT\n.RMTCDE8 ANOP\n         AIF   (NOT &LAB1).NEXT11\n         L     &REG,=V(&CONVL1)\n         MVC   &MLABEL,0(&REG)        MOVE IN MONTH\n.NEXT11  ANOP\n         AIF   (NOT &LAB2).NEXT12\n         L     &REG,=V(&CONVL2)\n         MVC   &DLABEL,0(&REG)         MOVE IN DAY\n.NEXT12  ANOP\n         AIF   (NOT &LAB3).NEXT13\n         L     &REG,=V(&CONVL3)\n         MVC   &YLABEL,0(&REG)         MOVE IN YEAR\n.NEXT13  ANOP\n         AIF   (NOT &LAB4).NEXT14\n         L     &REG,=V(&CONVL4)\n         MVC   &ALABEL,0(&REG)         MOVE IN MONTH ABREVIATION\n         L     &REG,=V(&CONVL5)\n         MVC   &ALABEL+4(4),0(&REG)    MOVE IN MONTH ABREVIATION\n.NEXT14  ANOP\n         L     &REG,=V(&MLAB12)\n         LM    2,4,0(&REG)             RESTORE REGISTERS 1, 2 AND 3\n         AIF   ('&RESTORE' EQ 'YES').XESREST\n         L     &REG,=V(&MLAB09)        POINT TO LABEL\n         MEXIT\n.XESREST ANOP\n         L     &REG,=V(&MLAB13)\n         L     &REG,0(&REG)            RESTORE REGISTER PASSED\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DATECHCK": {"ttr": 1289, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//SOSTRJDQ JOB (99999,T),'JOHN SOSTROM',\n//         CLASS=I,MSGCLASS=X,NOTIFY=SOSTRJD\n//ASM      EXEC PGM=IEV90,PARM='LIST,XREF(SHORT),NOOBJECT,DECK,RENT',\n//             REGION=4096K\n//SYSPRINT  DD SYSOUT=*\n//SYSLIB    DD DSN=SYS1.MACLIB,DISP=SHR\n//          DD DSN=SYSPOTST.DATECHCK.SOURCE,DISP=SHR\n//SYSUT1    DD UNIT=WORK,SPACE=(1700,(1000,100))\n//SYSLIN    DD DUMMY,DCB=BLKSIZE=80\n//SYSPUNCH  DD DSN=&&DECK,UNIT=WORK,DISP=(,PASS),\n//             SPACE=(CYL,(5,1)),\n//             DCB=(LRECL=80,BLKSIZE=3120,RECFM=FB,DSORG=PS)\n//SYSIN     DD *\n         $HEAD 'DATE CHECK RETURN',TITLE=(DATECHCK,'DATE CHECK PROGRAM X\n               DISCRIPTION')\n*---------------------------------------------------------------------*\n*                                                                     *\n*  NAME:      DATECHCK                                                *\n*  CREATED:   11/25/86                                                *\n*  AUTHOR:    JOHN D. SOSTROM                                         *\n*             DAYCO PRODUCTS INC.                                     *\n*             333 W. FIRST ST.                                        *\n*             DAYTON,  OHIO  45401-1004                               *\n*             (513)226-5747                                           *\n*                                                                     *\n*  FUNCTION:                                                          *\n*                                                                     *\n*       DATECHCK ALLOWS A DATE IN GREGORIAN OR JULIAN DATE FORMAT     *\n*  PASSED BY PARAMETER INPUT, TO BE VARRIFIED AGAINST A CONSTANT      *\n*  OF 0, + OR MINUS A NUMBER AGAINST THE CURRENT DATE AND A CONDITION *\n*  TO BE SPECIFIED AS TO ACTION TO TAKE IF THE DATE DOES NOT FALL     *\n*  WITHIN THE REQUESTED BOUNDRIES.  NO DDS ARE REQUIRED BY THIS       *\n*  PROGRAM.  ONLY PARM INPUT IS USED AND A CONDITION CODE OR ABEND    *\n*  IS INVOKED BASED ON THE PARMS.                                     *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*  PARAMETER INPUT:                                                   *\n*                                                                     *\n*      THE PARM SPECIFICATION FOR THIS PROGRAM IS AS FOLLOWS:         *\n*                                                                     *\n*                      |EQ|                                           *\n*            |Jyyddd | |NE| |+|           |ABEND|                     *\n*      PARM='|Gmmddyy|,|LT|,|-|vvv,RC=(nn,|bb   |)'                   *\n*                      |LE|               |WTOR |                     *\n*                      |GT|                                           *\n*                      |GE|                                           *\n*                                                                     *\n*      WHERE:                                                         *\n*                                                                     *\n*            Jyyddd   =   The date to be varified in julian date      *\n*                         format.  Must be proceeded by a J and no    *\n*                         space to the seperator.                     *\n*                                                                     *\n*            Gmmddyy  =   The date in gregorian format.  The          *\n*                         date must be proceeded by a G and no        *\n*                         seperators are to be placed between the     *\n*                         month, date and year values.                *\n*                                                                     *\n*                                                                     *\n*            |EQ|                                                     *\n*            |NE|                                                     *\n*            |LT|     =   This is a operator that will be applied     *\n*            |LE|         against the date that results from the      *\n*            |GT|         addition or subtraction of the vvv value    *\n*            |GE|         from the current system date to establish   *\n*                         a \"GOOD\" condition match to the parm date.  *\n*                                                                     *\n*                                                                     *\n*                         i.e.                                        *\n*                                                                     *\n*                         PARM='J86123,EQ,+003........'               *\n*                                                                     *\n*                         The above example says that the date given  *\n*                         in the parm data must equal the current     *\n*                         system date plus three.                     *\n*                                                                     *\n*                                                                     *\n*                         PARM='J86123,GT,+003........'               *\n*                                                                     *\n*                         The above example the date given in the     *\n*                         parm should be greater than the system      *\n*                         date plus three for a good condition match. *\n*                                                                     *\n*                                                                     *\n*                         PARM='J86123,LE,+039........'               *\n*                                                                     *\n*                         The above example the date given in the     *\n*                         parm should be less than or equal to the    *\n*                         system date plus thirty nine.               *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*            |+|                                                      *\n*            |-|vvv   =   A value that the date shown is to be off    *\n*                         by the current system date plus or minus.   *\n*                         Must be three numeric characters preceeded  *\n*                         by a plus or minus sign(-000 and +000 are   *\n*                         the same date of zero days.).  Maximum      *\n*                         valuse are +366 and -366 (one leap year).   *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*             |ABEND|                                                 *\n*      RC=(nn,|bb   |)    This parameter specifies what action is     *\n*             |WTOR |     to be taken based on the result of the      *\n*                         operation and compare specified by the      *\n*                         previous parameters.  The first operand     *\n*                         nn is the two digit numerical return code   *\n*                         to use if the condition test is good.       *\n*                         The second operand is ABEND, end with return*\n*                         code bb (two digit numeric), or ask the     *\n*                         operator what to do (WTOR) if the test      *\n*                         fails.                                      *\n*                         When WTOR is specified the operator may     *\n*                         reply C to take the good return code nn     *\n*                         or A to abend.                              *\n*                                                                     *\n*                         i.e.                                        *\n*                                                                     *\n*                         PARM='J86123,EQ,+003,RC=(00,ABEND)'         *\n*                                                                     *\n*                         In the above specification if the system    *\n*                         date plus three equals the julian date      *\n*                         then the program ends with a return code of *\n*                         00.  If on the otherhand they are not equal *\n*                         then abend with a user code of 122.         *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                         PARM='J86123,LT,-030,RC=(04,66)'            *\n*                                                                     *\n*                         In the above specification if the system    *\n*                         date minus thirty is Less Than the parm     *\n*                         date then the program ends with a return    *\n*                         code of 4.  If it is not less than the      *\n*                         parm date then the program ends with a      *\n*                         return code of 66.                          *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                         PARM='G110786,GE,-000,RC=(00,WTOR)'         *\n*                                                                     *\n*                         In the above specification if the system    *\n*                         date is Greater than or Equal to the passed *\n*                         date the program end with a condition       *\n*                         code of 0.  Otherwise a the operator is     *\n*                         asked if the program is to Continue or      *\n*                         Abend.  If the operator responds with a     *\n*                         C (continue) then the program will end with *\n*                         a condition code of zero.  If the operator  *\n*                         replies A (abend) then the program ends with*\n*                         a user abend of 222.                        *\n*                                                                     *\n*                                                                     *\n*    If an invalid parm input is detected the program abends with     *\n*    a user abend 522.                                                *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*  MACROS USED:                                                       *\n*                                                                     *\n*       IBM MACROS - GETMAIN, FREEMAIN, WTOR, TIME, WAIT              *\n*                                                                     *\n*       USER MACROS (SYSPOPRD.TECH.MACLIB) - $PROLOG, $EPILOG,        *\n*                    #CONVDAT, $REGS, $DFLAG, $FLAG, $CLEAR,          *\n*                    $TEST, $HEAD                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*    LINKAGE EDITOR ATRIBUTES:  'LIST,LET,XREF,RENT,REUS'             *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*    REGISTER USAGE                                                   *\n*                                                                     *\n*           R0 DSECT BASE FOR REENTRANT #CONVDAT                      *\n*           R1 INPUT PARAMETER POINTER ADDRESS                        *\n*           R1 THROUGH R10 WORK                                       *\n*           R11 AND R12 BASE REGISTERS                                *\n*           R13 SAVE AREA POINTER AND WORK AREA DSECT POINTER         *\n*           R14 BRANCH RETURN ADDRESS                                 *\n*           R15 BRANCH ENTRY POINT                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         $HEAD 'CHANGE HISTORY',TITLE=(,'PROGRAM CHANGE HISTORY')\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         $HEAD 'ENTRY LINKAGE',TITLE=(,'PROGRAM ENTRY POINT LINKAGE')\nDATECHCK $PROLOG R11,R12,LV=4023\n         USING WORKAREA,R13       SET UP ADDRESSABILITY\n         $HEAD 'WORK AREA DSECT',TITLE=(,'DSECT DEFINITION FOR WORKAREAX\n                FROM REG 13')\nWORKAREA DSECT\nSAVEAREA DC    18F'0'             REGISTER SAVE AREA\n         ORG   SAVEAREA\nHSAVE    DC    F'0'               RESERVED\nBACKPONT DC    F'0'               BACKWORD CHAIN POINT\nFOWARDPT DC    F'0'               FORWARD SAVE AREA CHAIN POINTER\nREGS14   DC    F'0'               RETURN ADDRESS\nREGS15   DC    F'0'               ENTRY POINT ADDRESS\nREGS00   DC    F'0'               REGISTER 00 SAVE AREA\nREGS01   DC    F'0'               REGISTER 01 SAVE AREA\nREGS02   DC    F'0'               REGISTER 02 SAVE AREA\nREGS03   DC    F'0'               REGISTER 03 SAVE AREA\nREGS04   DC    F'0'               REGISTER 04 SAVE AREA\nREGS05   DC    F'0'               REGISTER 05 SAVE AREA\nREGS06   DC    F'0'               REGISTER 06 SAVE AREA\nREGS07   DC    F'0'               REGISTER 07 SAVE AREA\nREGS08   DC    F'0'               REGISTER 08 SAVE AREA\nREGS09   DC    F'0'               REGISTER 09 SAVE AREA\nREGS10   DC    F'0'               REGISTER 10 SAVE AREA\nREGS11   DC    F'0'               REGISTER 11 SAVE AREA\nREGS12   DC    F'0'               REGISTER 12 SAVE AREA\n         ORG\n         SPACE 3\n         DS    0F\nDATEWRK1 DC    2CL140' '          DATE WORK AREA #1\n         SPACE 3\n         DS    0F\nDATEWRK2 DC    2CL140' '          DATE WORK AREA #2\n         SPACE 3\nPARSARE  DS    0F\nPARMSTRN DC    CL32' '            INPUT PARM RAW\nPARMDATE DC    CL6' '             PASSED DATE\nPARMAMNT DC    CL3' '             AMMONT TO BE ADDED OR SUBTRACED\nPARMRC1  DC    CL2' '             PASSED RETURN CODE MEETS REQUEST\nPARMRC2  DC    CL2' '             PASSED RETURN CODE NOT-MEETS REQUEST\n         SPACE 1\nPARMFLG1 $DFLAG EQ,NE,LT,LE,GT,GE TEST TYPE PARAMETER FLAGS\n         SPACE 1\nPARMFLG2 $DFLAG ABEND,WTOR,ADD,SUB  ACTION TYPE PARAMETER FLAGS\n         SPACE 1\nPARMFLG3 $DFLAG JDATE,GDATE       TYPE OF PRAMETER DATE INPUT\n         SPACE 1\nPARMFLG4 $DFLAG LEAP1,LEAP2       LEAP YEAR INDICATORS\n         SPACE 3\nGOODRTRN DC    F'0'               GOOD RETURN CODE SPECIFICATION BINARY\nBADRTRN  DC    F'0'               BAD RETURN CODE SPECIFICATION BINARY\nWORK4    DC    F'0'               FULL WORD WORK AREA\nWORK4A   DC    F'0'               FULL WORD WORK AREA\nWORK4B   DC    F'0'               FULL WORD WORK AREA\nWORK4C   DC    F'0'               FULL WORD WORK AREA\nWORK8    DC    D'0'               DOUBLE WORK WORK AREA\nPAKDATEI DC    PL4'+0'            PACKED CONVERTED INPUT DATE\nPAKDATES DC    PL4'+0'            PACKED SYSTEM DATE\nPAKWORK4 DC    PL4'0'             PACKED DECIMAL WORK AREA 4\nPAKWORK3 DC    PL3'0'             PACKED DECIMAL WORK AREA 3\nPAKWORK2 DC    PL2'0'             PACKED DECIMAL WORK AREA 2\nPAKWORK1 DC    PL1'0'             PACKED DECIMAL WORK AREA 1\n         SPACE 3\nWTORREP  DC    CL1' '             REPLY AREA\nWTORECB  DC    F'0'               ECB FOR WTOR\nWTORLST1 WTOR  'PARM DATE OF XX/XX/XX IS NOT ?? TO DATE YY/YY/YY.  REPLX\n               Y C TO CONTINUE WITH RETURN CODE NN OR A TO TAKE ABEND.'X\n               ,0,1,0,MF=L\n         ORG   WTORLST1\n         DC    A(0)               REPLY ADDRESS\n         DC    A(0)               ECB ADDRESS\n         DC    AL1(0)             REPLY LENGTH\n         DC    AL1(0)             TEXT LENGTH\n         DC    B'0000000000000000' MCS FLAGS\n         DC    C'PARM DATE OF '\nW1DATE1  DC    C'XX/XX/XX'\n         DC    C' IS NOT '\nW1CODE   DC    C'??'\n         DC    C' TO DATE '\nW1DATE2  DC    C'YY/YY/YY'\n         DC    C'.  REPLY C TO CONTINUE WITH RETURN CODE '\nW1CODE1  DC    C'NN'\n         DC    C' OR A TO TAKE ABEND.'\n         ORG\n         SPACE 1\nWTORLST2 WTOR  'PARM DATE OF XXXXX IS NOT ?? TO DATE YYYYY.  REPLY C TOX\n                CONTINUE WITH RETURN CODE NN OR A TO TAKE ABEND.',     X\n               0,1,0,MF=L\n         ORG   WTORLST2\n         DC    A(0)               REPLY ADDRESS\n         DC    A(0)               ECB ADDRESS\n         DC    AL1(0)             REPLY LENGTH\n         DC    AL1(0)             TEXT LENGTH\n         DC    B'0000000000000000' MCS FLAGS\n         DC    C'PARM DATE OF '\nW2DATE1  DC    C'XXXXX'\n         DC    C' IS NOT '\nW2CODE   DC    C'??'\n         DC    C' TO DATE '\nW2DATE2  DC    C'YYYYY'\n         DC    C'.  REPLY C TO CONTINUE WITH RETURN CODE '\nW2CODE1  DC    C'NN'\n         DC    C' OR A TO TAKE ABEND.'\n         ORG\n         SPACE 1\nWORKLNG  EQU   *-SAVEAREA\n         $HEAD 'PARSE PARM DATA',TITLE=(,'PARS AND VERIFY INPUT PARM DAX\n               TA')\nDATECHCK CSECT\n         L     R1,0(R1)           POINT TO PARM INPUT\n         LH    R2,0(R1)           GET LENGTH\n         LA    R6,*\n         CH    R2,=H'29'          LARGER THAN\n         BH    ABPARM             ABEND ON PARM ERROR\n         LA    R6,*\n         CH    R2,=H'25'          TOO SHORT\n         BL    ABPARM             ABEND ON PARM ERROR\n         BCTR  R2,0               SUBTRACT ONE\n         EX    R2,MOVEPARM\n         B     PARS001\nMOVEPARM MVC   PARMSTRN(0),2(R1)  MOVE PARM INSTRUCTION\nABPARM   ABEND 522\n         SPACE 1\nPARS001  DS    0H\n         MVC   PARMDATE(6),=CL6' ' PRESET DATE AREA\n         LA    R2,PARMSTRN        POINT TO PARM\n         CLI   0(R2),C'J'         JULIAN DATE ENTERED?\n         BNE   PARS002            NO, THEN CHECK FOR GREGORIAN\n         $FLAG JDATE              JULIAN DATE FLAG\n         MVC   PARMDATE(5),1(R2)\n         LA    R2,7(R2)           POINT TO NEXT EXPECTED PARM\n         B     PARSA06\n         SPACE 1\nPARS002  DS    0H\n         LA    R6,*\n         CLI   PARMSTRN,C'G'      GREGORIAN DATE ENTERD?\n         BNE   ABPARM             NO, THEN CHECK FOR GREGORIAN\n         $FLAG GDATE              GREGORIAN DATE FLAG\n         MVC   PARMDATE(6),1(R2)\n         LA    R2,8(R2)           POINT TO NEXT EXPECTED PARM\n         B     PARSA06            GO DO OPERATOR\n         SPACE 1\nPARS003  DS    0H\n         CLI   0(R2),C'-'         SUBTRACT?\n         BNE   PARS004            NO\n         $FLAG SUB\n         LA    R2,1(R2)           POINT TO AMOUNT\n         B     PARS005\n         SPACE 1\nPARS004  DS    0H\n         LA    R6,*\n         CLI   0(R2),C'+'         ADD?\n         BNE   ABPARM             NO, THEN ERROR\n         $FLAG ADD\n         LA    R2,1(R2)\n         SPACE 1\nPARS005  DS    0H\n         MVC   PARMAMNT,0(R2)     SAVE AMOUNT\n         XC    WORK4,WORK4        CHECK FOR MAXIMUMS\n         PACK  WORK4(4),PARMAMNT(3)\n         OI    WORK4+3,X'0F'\n         LA    R6,*               GET ABEND REFERENCE\n         CP    WORK4+1(3),=PL3'366'\n         BH    ABPARM             GREATER THAN 366\n         LA    R2,4(R2)           BUMP TO NEXT PARM\n         B     PARS011            GO DO RC=(\n         SPACE 1\nPARSA06  DS    0H\n         CLC   0(2,R2),=CL2'EQ'   FIND CONDITION\n         BNE   PARS006\n         $FLAG EQ\n         LA    R2,3(R2)\n         B     PARS003  GO DO AMOUNT\n         SPACE 1\nPARS006  DS    0H\n         CLC   0(2,R2),=CL2'NE'   FIND CONDITION\n         BNE   PARS007\n         $FLAG NE\n         LA    R2,3(R2)\n         B     PARS003  GO DO AMOUNT\n         SPACE 1\nPARS007  DS    0H\n         CLC   0(2,R2),=CL2'LT'   FIND CONDITION\n         BNE   PARS008\n         $FLAG LT\n         LA    R2,3(R2)\n         B     PARS003  GO DO AMOUNT\n         SPACE 1\nPARS008  DS    0H\n         CLC   0(2,R2),=CL2'LE'   FIND CONDITION\n         BNE   PARS009\n         $FLAG LE\n         LA    R2,3(R2)\n         B     PARS003  GO DO AMOUNT\n         SPACE 1\nPARS009  DS    0H\n         CLC   0(2,R2),=CL2'GT'   FIND CONDITION\n         BNE   PARS010\n         $FLAG GT\n         LA    R2,3(R2)\n         B     PARS003  GO DO AMOUNT\n         SPACE 1\nPARS010  DS    0H\n         LA    R6,*\n         CLC   0(2,R2),=CL2'GE'   FIND CONDITION\n         BNE   ABPARM             PARM ERROR\n         $FLAG GE\n         LA    R2,3(R2)\n         B     PARS003\n         SPACE 1\nPARS011  DS    0H\n         LA    R6,*\n         CLC   0(4,R2),=CL4'RC=(' CORRECT FORMAT?\n         BNE   ABPARM             NO, PARM ERROR\n         LA    R2,4(R2)           BUMP TO SUB PARM\n         MVC   PARMRC1(2),0(R2)   GET MET CODE\n         CLI   5(R2),C')'         TWO NUMERIC VERSION?\n         BNE   PARS012            NO\n         MVC   PARMRC2(2),3(R2)   GET NOMATCH RETURN CODE\n         B     PARS014\n         SPACE 1\nPARS012  DS    0H\n         CLC   3(4,R2),=CL4'WTOR' ASK OPERATOR?\n         BNE   PARS013            NO CHECK OTHER\n         $FLAG WTOR\n         B     PARS014            DONE\n         SPACE 1\nPARS013  DS    0H\n         LA    R6,*\n         CLC   3(5,R2),=CL5'ABEND' ABEND ON BAD CHECK?\n         BNE   ABPARM             NO, THEN PARM ERROR\n         $FLAG ABEND\n         SPACE 1\nPARS014  DS    0H\n         TM    PARMDATE,X'F0'     CHECK FOR NUMERIC FIELDS\n         BO    PARSA14            IF NOT THEN PARM ERROR\n         LA    R6,*\n         B     ABPARM             IF NOT THEN PARM ERROR\n         SPACE 1\nPARSA14  DS    0H\n         TM    PARMDATE+1,X'F0'\n         BO    PARSB14            IF NOT THEN PARM ERROR\n         LA    R6,*\n         B     ABPARM             IF NOT THEN PARM ERROR\n         SPACE 1\nPARSB14  DS    0H\n         TM    PARMDATE+2,X'F0'\n         BO    PARSC14            IF NOT THEN PARM ERROR\n         LA    R6,*\n         B     ABPARM             IF NOT THEN PARM ERROR\n         SPACE 1\nPARSC14  DS    0H\n         TM    PARMDATE+3,X'F0'\n         BO    PARSD14            IF NOT THEN PARM ERROR\n         LA    R6,*\n         B     ABPARM             IF NOT THEN PARM ERROR\n         SPACE 1\nPARSD14  DS    0H\n         TM    PARMDATE+4,X'F0'\n         BO    PARSE14            IF NOT THEN PARM ERROR\n         LA    R6,*\n         B     ABPARM             IF NOT THEN PARM ERROR\n         SPACE 1\nPARSE14  DS    0H\n         $TEST JDATE,ONES,BR=PARS015 JULIAN DATE GIVEN\n         TM    PARMDATE+5,X'F0'\n         BO    PARS015            IF NOT THEN PARM ERROR\n         LA    R6,*\n         B     ABPARM             IF NOT THEN PARM ERROR\n         SPACE 1\nPARS015  DS    0H\n         TM    PARMAMNT,X'F0'     CHECK AMOUNT FOR NUMERICS\n         BO    PARSA15            IF NOT THEN PARM ERROR\n         LA    R6,*\n         B     ABPARM             IF NOT THEN PARM ERROR\n         SPACE 1\nPARSA15  DS    0H\n         TM    PARMAMNT+1,X'F0'   CHECK AMOUNT FOR NUMERICS\n         BO    PARSB15            IF NOT THEN PARM ERROR\n         LA    R6,*\n         B     ABPARM             IF NOT THEN PARM ERROR\n         SPACE 1\nPARSB15  DS    0H\n         TM    PARMAMNT+2,X'F0'   CHECK AMOUNT FOR NUMERICS\n         BO    PARSC15            IF NOT THEN PARM ERROR\n         LA    R6,*\n         B     ABPARM             IF NOT THEN PARM ERROR\n         SPACE 1\nPARSC15  DS    0H\n         TM    PARMRC1,X'F0'      CHECK RETURN CODE ONE FOR NUMERICS\n         BO    PARSD15            IF NOT THEN PARM ERROR\n         LA    R6,*\n         B     ABPARM             IF NOT THEN PARM ERROR\n         SPACE 1\nPARSD15  DS    0H\n         TM    PARMRC1+1,X'F0'\n         BO    PARSE15            IF NOT THEN PARM ERROR\n         LA    R6,*\n         B     ABPARM             IF NOT THEN PARM ERROR\nPARSE15  $TEST ABEND+WTOR,MIXED,BR=PARS999\n         TM    PARMRC2,X'F0'      CHECK RETURN CODE TWO FOR NUMERICS\n         BO    PARSF15            IF NOT THEN PARM ERROR\n         LA    R6,*\n         B     ABPARM             IF NOT THEN PARM ERROR\n         SPACE 1\nPARSF15  DS    0H\n         TM    PARMRC2+1,X'F0'\n         BO    PARS999            IF NOT THEN PARM ERROR\n         LA    R6,*\n         B     ABPARM             IF NOT THEN PARM ERROR\n         SPACE 1\nPARS999  DS    0H\n         $HEAD 'CONVERT PARM DATA',TITLE=(,'CONVERT PARMS TO DECIMAL ANX\n               D BINARY DATA')\n         XC    WORK8,WORK8        CLEAR WORK AREA\n         PACK  WORK8+4(4),PARMRC1(2) CONVERT GOOD RETURN CODE\n         CVB   R2,WORK8              TO BINARY\n         ST    R2,GOODRTRN        AND SAVE IT\n         $TEST ABEND+WTOR,ZEROS,BR=CONV0002\n         $TEST ABEND,ZEROS,BR=CONV0001\n         MVC   BADRTRN(4),=F'222' SET FOR ABEND FROM OPERATOR\n         B     CONV0003\n         SPACE 1\nCONV0001 DS    0H\n         MVC   BADRTRN(4),=F'122' SET FOR BAD MATCH ON ABEND REQUEST\n         B     CONV0003\n         SPACE 1\nCONV0002 DS    0H\n         XC    WORK8,WORK8        CLEAR WORK AREA\n         PACK  WORK8+4(4),PARMRC2(2) CONVERT BAD RETURN CODE\n         CVB   R2,WORK8              TO BINARY\n         ST    R2,BADRTRN         AND SAVE IT\n         SPACE 1\nCONV0003 DS    0H\n         $TEST JDATE,ONES,BR=CONV0009\n         B     CONV0004           BRANCH AROUND TABLES\n         SPACE 1\nTABLE1   DS    0F\n         DC    CL2'01',PL2'31'    JANUARY\n         DC    CL2'02',PL2'28'    FEBRUARY (NON-LEAP YEAR)\n         DC    CL2'03',PL2'31'    MARCH\n         DC    CL2'04',PL2'30'    APRIL\n         DC    CL2'05',PL2'31'    MAY\n         DC    CL2'06',PL2'30'    JUNE\n         DC    CL2'07',PL2'31'    JULY\n         DC    CL2'08',PL2'31'    AUGUST\n         DC    CL2'09',PL2'30'    SEPTEMBER\n         DC    CL2'10',PL2'31'    OCTOBER\n         DC    CL2'11',PL2'30'    NOVEMBER\n         DC    CL2'12',PL2'31'    DECEMBER\n         DC    XL4'FFFFFFFF'      END OF TABLE\n         SPACE 1\nTABLE2   DS    0F\n         DC    CL2'01',PL2'31'    JANUARY\n         DC    CL2'02',PL2'29'    FEBRUARY (LEAP YEAR)\n         DC    CL2'03',PL2'31'    MARCH\n         DC    CL2'04',PL2'30'    APRIL\n         DC    CL2'05',PL2'31'    MAY\n         DC    CL2'06',PL2'30'    JUNE\n         DC    CL2'07',PL2'31'    JULY\n         DC    CL2'08',PL2'31'    AUGUST\n         DC    CL2'09',PL2'30'    SEPTEMBER\n         DC    CL2'10',PL2'31'    OCTOBER\n         DC    CL2'11',PL2'30'    NOVEMBER\n         DC    CL2'12',PL2'31'    DECEMBER\n         DC    XL4'FFFFFFFF'      END OF TABLE\n         SPACE 1\nCONV0004 DS    0H\n         PACK  PAKDATEI(4),PARMDATE+4(2) PACK YEAR\n         OI    PAKDATEI+3,X'0F'\n         MVC   PAKWORK3,PAKDATEI+1\n         XC    WORK8(8),WORK8\n         MVC   WORK8+4(4),PAKDATEI\n         MP    WORK8(8),=PL3'+1000'\n         MVC   PAKDATEI(4),WORK8+4\n         OI    PAKDATEI+3,X'0F'\n         XC    WORK8(8),WORK8\n         MVC   WORK8+5(3),PAKWORK3\n         DP    WORK8(8),=PL2'+04'  FIND IF LEAP YEAR\n         OI    WORK8+7,X'0F'\n         CP    WORK8+6(2),=PL2'+00' ANY REMAINDER:\n         BE    CONV0005           NO, THEN LEAP YEAR\n         LA    R2,TABLE1          POINT TO CORECT TABLE\n         B     CONV0006\n         SPACE 1\nCONV0005 DS    0H\n         LA    R2,TABLE2          POINT TO CORECT TABLE\n         SPACE 1\nCONV0006 DS    0H\n         ZAP   PAKWORK2,=PL2'+00'\n         XC    PAKWORK3,PAKWORK3\n         MVI   PAKWORK3+2,X'0F'   MAKE IT PAKED +0\n         SPACE 1\nCONV0007 DS    0H\n         LA    R6,*\n         CLC   0(4,R2),=XL4'FFFFFFFF' END OF TABLE\n         BE    ABPARM             YES\n         CLC   0(2,R2),PARMDATE   THIS MONTH?\n         BE    CONV0008           YES\n         AP    PAKWORK3(3),2(2,R2) ADD THIS NUMBER OF DAYS\n         LA    R2,4(R2)           BUMP POINTER\n         B     CONV0007\n         SPACE 1\nCONV0008 DS    0H\n         PACK  PAKWORK2(2),PARMDATE+2(2) PACK THE DATE OF MONTH\n         AP    PAKWORK3(3),PAKWORK2(2) ADD THIS NUMBER OF DAYS\n         AP    PAKDATEI(4),PAKWORK3(3) AND ADD TO YEAR\n         OI    PAKDATEI+3,X'0F'   MAKE SURE ITS POSITIVE\n         B     CONV0010\n         SPACE 1\nCONV0009 DS    0H\n         PACK  PAKDATEI(4),PARMDATE(5) PACK JULIAN DATE\n         OI    PAKDATEI+3,X'0F'   MAKE SURE ITS POSITIVE\n         SPACE 1\nCONV0010 DS    0H\n         TIME  DEC                GET SYS DATE\n         ST    R1,WORK4           SAVE RETURNED DATE\n         ST    R1,WORK4A          SAVE RETURNED DATE\n         MVC   WORK4B+3(1),WORK4+1\n         L     R2,WORK4B          ADJUST FOR YEAR CROSS OVER\n         SLL   R2,4\n         ST    R2,WORK4B\n         ST    R2,WORK4C\n         XC    WORK8,WORK8\n         ST    R2,WORK8+4\n         OI    WORK8+7,X'0F'\n         DP    WORK8(8),=PL2'04'  IS NEW YEAR LEAP YEAR\n         OI    WORK8+7,X'0F'\n         CP    WORK8+6(2),=PL2'00'\n         BNE   CONV0A10           THIS IS NOT A LEAP YEAR\n         SPACE 1\n         $FLAG LEAP1\nCONV0A10 DS    0H\n         PACK  PAKWORK4(4),PARMAMNT(3) PACK PARM AMOUNT\n         OI    PAKWORK4+3,X'0F'   MAKE SURE ITS POSITIVE\n         $TEST ADD,ONES,BR=CONV0011\n         SP    WORK4(4),PAKWORK4+1(3)\n         CP    WORK4+2(2),=PL2'00' DECRIMENTED TO XX000\n         BE    CONVAB10\n         CLC   WORK4+1(1),WORK4A+1 SAME YEAR\n         BE    CONV0012            THEN DONT ADJUST\n         SPACE 1\nCONVAB10 DS    0H\n         XC    WORK4B,WORK4B      AND GET YEAR VALUE\n         MVC   WORK4B+3(1),WORK4+1\n         L     R2,WORK4B          ADJUST FOR YEAR CROSS OVER\n         SLL   R2,4\n         ST    R2,WORK4B\n         XC    WORK8,WORK8\n         MVC   WORK8+4(4),WORK4B\n         OI    WORK8+7,X'0F'\n         DP    WORK8(8),=PL2'04'  IS NEW YEAR LEAP YEAR\n         OI    WORK8+7,X'0F'\n         CP    WORK8+6(2),=PL2'00'\n         BNE   CONV0B10           THIS IS NOT A LEAP YEAR\n         $FLAG LEAP2\n         SPACE 1\nCONV0B10 DS    0H\n         CP    WORK4+2(2),=PL2'00' DECRIMENTED TO XX000\n         BNE   CONVBB10\n         $TEST LEAP1,ONES,BR=CONV0D10 COMMING FROM A LEAP YEAR\n         XC    WORK8,WORK8\n         MVC   WORK4C(4),WORK4\n         SP    WORK4C(4),=PL3'1000' DECRIMENT YEAR\n         MVC   WORK8+7(1),WORK4C+1\n         L     R2,WORK8+4\n         SLL   R2,4\n         ST    R2,WORK8+4\n         OI    WORK8+7,X'0F'\n         DP    WORK8(8),=PL2'04'\n         OI    WORK8+7,X'0F'\n         CP    WORK8+6(2),=PL2'00'\n         BNE   CONV0D10           NON-LEAP YEAR INTO NON-LEAP YEAR\n         B     CONV0C10           NON-LEAP YEAR INTO LEAP YEAR\n         SPACE 1\nCONVBB10 DS    0H\n         $TEST LEAP1+LEAP2,ZEROS,BR=CONV0D10 NON-LEAP YEAR TO NON-LEAP\n         $TEST LEAP2,ONES,BR=CONV0C10\n         SPACE 1\n*\n** LEAP YEAR INTO NON-LEAP YEAR\n*\n         SPACE 1\n         CP    WORK4A+2(2),=PL2'28'\n         BL    CONV0E10           ORIGINAL DATE AFTER FEB 28\n         SPACE 1\n*\n** COMMING INTO A LEAP YEAR\n*\n         SPACE 1\nCONV0C10 DS    0H\n         SP    WORK4(4),=PL3'634'\n         B     CONV0012            DONE\n         SPACE 1\n*\n** NEITHER YEAR IS A LEAP YEAR\n*\n         SPACE 1\nCONV0D10 DS    0H\n         SP    WORK4(4),=PL3'635'\n         B     CONV0012            DONE\n         SPACE 1\nCONV0E10 DS    0H\n         SP    WORK4(4),=PL3'636'\n         B     CONV0012            DONE\n         SPACE 1\nCONV0011 DS    0H\n         AP    WORK4(4),PAKWORK4+1(3)\n         $TEST LEAP1,ONES,BR=CONV0B11\n         CP    WORK4+2(2),=PL2'365'\n         BH    CONV0A11           MUST BE GREATER THAN XX365\n         B     CONV0012            DONE\n         SPACE 1\nCONV0A11 DS    0H\n         AP    WORK4(4),=PL3'635'     ADD CORRECTION FACTOR\n         B     CONV0012            DONE\n         SPACE 1\nCONV0B11 DS    0H\n         CP    WORK4+2(2),=PL2'366'\n         BH    CONV0C11           MUST BE GREATER THAN XX366\n         B     CONV0012            DONE\n         SPACE 1\nCONV0C11 DS    0H\n         AP    WORK4(4),=PL3'634'     ADD CORRECTION FACTOR\n         SPACE 1\nCONV0012 DS    0H\n         MVC   PAKDATES(4),WORK4\n         OI    PAKDATES+3,X'0F'   MAKE SURE IT IS POSSITIVE\n         $HEAD 'GENNERATE MESSAGE',TITLE=(,'GENNERATE MESSAGE DATA FOR X\n               WTOR MESSAGES')\n         B     GENR0001           GO AROUND CONSTANTS AREA\nWTORDAT1 WTOR  'PARM DATE OF XX/XX/XX IS NOT ?? TO DATE YY/YY/YY.  REPLX\n               Y C TO CONTINUE WITH RETURN CODE NN OR A TO TAKE ABEND.'X\n               ,0,1,0,MF=L\nWTORDT1L EQU   *-WTORDAT1\n         SPACE 1\nWTORDAT2 WTOR  'PARM DATE OF XXXXX IS NOT ?? TO DATE YYYYY.  REPLY C TOX\n                CONTINUE WITH RETURN CODE NN OR A TO TAKE ABEND.',     X\n               0,1,0,MF=L\nWTORDT2L EQU   *-WTORDAT2\n         SPACE 1\nGENR0001 DS    0H\n         MVC   WTORLST1(WTORDT1L),WTORDAT1 INITIALIZE LIST\n         MVC   WTORLST2(WTORDT2L),WTORDAT2 INITIALIZE LIST\n         UNPK  WORK8(8),PAKDATES  UNPACK SYSTEM DATE UPDATED\n         MVC   W2DATE2(5),WORK8+3 AND STICK IN MESSAGE 2\n         OI    W2DATE2+4,C'0'     MAKE NUMERIC\n         UNPK  WORK8(8),PAKDATEI  UNPACK PARM DATE UPDATED\n         MVC   W2DATE1(5),WORK8+3 AND STICK IN MESSAGE 2\n         OI    W2DATE1+4,C'0'     MAKE NUMERIC\n         MVC   W1CODE1(2),PARMRC1\n         MVC   W2CODE1(2),PARMRC1\n         LA    R1,DATEWRK1        POINT TO DATE CONVERSION AREA\n         MVC   WORK4,PAKDATES\n         L     R5,WORK4           AND GET SYSTEM DATE\nGENR0002 #CONVDAT REG=R5,RENT=YES\n         MVC   W1DATE2(8),0(R5)   MOVE CONVERTED DATE TO MESSAGE\n         LA    R1,DATEWRK2        POINT TO DATE CONVERSION AREA\n         MVC   WORK4,PAKDATEI\n         L     R5,WORK4           AND GET PARM DATE\nGENR0003 #CONVDAT REG=R5\n         MVC   W1DATE1(8),0(R5)   MOVE CONVERTED DATE TO MESSAGE\n         $TEST EQ,ZEROS,BR=GENR0004\n         MVC   W1CODE(2),=CL2'EQ'\n         MVC   W2CODE(2),=CL2'EQ'\n         B     GENR0999           DONE\n         SPACE 1\nGENR0004 DS    0H\n         $TEST NE,ZEROS,BR=GENR0005\n         MVC   W1CODE(2),=CL2'NE'\n         MVC   W2CODE(2),=CL2'NE'\n         B     GENR0999           DONE\n         SPACE 1\nGENR0005 DS    0H\n         $TEST LT,ZEROS,BR=GENR0006\n         MVC   W1CODE(2),=CL2'LT'\n         MVC   W2CODE(2),=CL2'LT'\n         B     GENR0999           DONE\n         SPACE 1\nGENR0006 DS    0H\n         $TEST LE,ZEROS,BR=GENR0007\n         MVC   W1CODE(2),=CL2'LE'\n         MVC   W2CODE(2),=CL2'LE'\n         B     GENR0999           DONE\n         SPACE 1\nGENR0007 DS    0H\n         $TEST GT,ZEROS,BR=GENR0008\n         MVC   W1CODE(2),=CL2'GT'\n         MVC   W2CODE(2),=CL2'GT'\n         B     GENR0999           DONE\n         SPACE 1\nGENR0008 DS    0H\n         MVC   W1CODE(2),=CL2'GE'\n         MVC   W2CODE(2),=CL2'GE'\n         SPACE 1\nGENR0999 DS    0H\n         $HEAD 'TEST FUNCTION',TITLE=(,'TEST FOR MEETING CONDITION')\n         $TEST EQ,ZEROS,BR=TEST0001\n         CP    PAKDATEI(4),PAKDATES(4)\n         BE    GOODRCDE\n         B     BADRCDE\n         SPACE 1\nTEST0001 DS    0H\n         $TEST NE,ZEROS,BR=TEST0002\n         CP    PAKDATEI(4),PAKDATES(4)\n         BNE   GOODRCDE\n         B     BADRCDE\n         SPACE 1\nTEST0002 DS    0H\n         $TEST LT,ZEROS,BR=TEST0003\n         CP    PAKDATEI(4),PAKDATES(4)\n         BL    GOODRCDE\n         B     BADRCDE\n         SPACE 1\nTEST0003 DS    0H\n         $TEST LE,ZEROS,BR=TEST0004\n         CP    PAKDATEI(4),PAKDATES(4)\n         BNH   GOODRCDE\n         B     BADRCDE\n         SPACE 1\nTEST0004 DS    0H\n         $TEST GT,ZEROS,BR=TEST0005\n         CP    PAKDATEI(4),PAKDATES(4)\n         BH    GOODRCDE\n         B     BADRCDE\n         SPACE 1\nTEST0005 DS    0H\n         CP    PAKDATEI(4),PAKDATES(4)\n         BNL   GOODRCDE\n         B     BADRCDE\n         SPACE 1\nGOODRCDE DS    0H\n         L     R15,GOODRTRN       GET RETURN CODE\n         B     EXIT               AND LEAVE\n         SPACE 1\nBADRCDE  DS    0H\n         $TEST ABEND+WTOR,MIXED,BR=TEST0006\n         L     R15,BADRTRN        GET RETURN CODE\n         B     EXIT               AND LEAVE\n         SPACE 1\nTEST0006 DS    0H\n         $TEST WTOR,ONES,BR=TEST0007\n         ABEND 122\n         SPACE 1\nTEST0007 DS    0H\n         XC    WTORECB(4),WTORECB CLEAR THE WTOR ECB\n         MVI   WTORREP,C' '       CLEAR THE REPLY AREA\n         $TEST JDATE,ONES,BR=TEST0008\n         WTOR  ,WTORREP,1,WTORECB,MF=(E,WTORLST1)\n         WAIT  1,ECB=WTORECB\n         OI    WTORREP,C' '       MAKE SURE IT IS CAPS\n         CLI   WTORREP,C'C'       END AS IF GOOD?\n         BE    GOODRCDE           YES\n         CLI   WTORREP,C'A'       VALID RESPONSE?\n         BNE   TEST0007           NO, THEN ASK AGAIN\nTESTABND ABEND 222\n         SPACE 1\nTEST0008 DS    0H\n         SPACE 1\n         WTOR  ,WTORREP,1,WTORECB,MF=(E,WTORLST2)\n         WAIT  1,ECB=WTORECB\n         OI    WTORREP,C' '       MAKE SURE IT IS CAPS\n         CLI   WTORREP,C'C'       END AS IF GOOD?\n         BE    GOODRCDE           YES\n         CLI   WTORREP,C'A'       VALID RESPONSE?\n         BNE   TEST0007           NO, THEN ASK AGAIN\n         B     TESTABND\n         $HEAD 'EXIT PROGRAM',TITLE=(,'CLEAN UP AND EXIT')\nEXIT     $EPILOG\n         $HEAD 'LITERAL TABLE',TITLE=(,'PROGRAM LISTERAL TABLE')\n         LTORG\n         SPACE 3\n         END\n/*\n//*-------------------------------------------------------------------*\n//LNKED    EXEC PGM=HEWL,PARM='LIST,LET,XREF,RENT,REUS',REGION=4096K,\n//             COND=((0,NE),(0,EQ))\n/*        CHANGE COND= PARM TO COND=(0,NE) TO LINK AFTER ASSEMBLY\n//SYSPRINT  DD SYSOUT=*\n//SYSLIB    DD DSN=SYS1.LINKLIB,DISP=SHR\n//* SYSLMOD   DD DSN=SYSPOPRD.TECH.LOADS(DATECHCK),DISP=SHR\n//SYSLMOD   DD DSN=SYS1.TEST.INSTALLS(DATECHCK),DISP=SHR\n//SYSUT1    DD UNIT=WORK,SPACE=(CYL,(10,5))\n//SYSUT2    DD UNIT=WORK,SPACE=(CYL,(10,5))\n//SYSLIN    DD DSN=&&DECK,DISP=(OLD,DELETE)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DAYCCA01": {"ttr": 1796, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")ATTR DEFAULT(%@_)\n % TYPE(TEXT) INTENS(HIGH) COLOR(GREEN)\n # TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n @ TYPE(TEXT) INTENS(LOW) COLOR(BLUE)\n $ TYPE(TEXT) INTENS(LOW) COLOR(TURQ)\n _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) COLOR(RED)\n)BODY EXPAND(\u00a6\u00a6)\n\\-\u00a6-\u00a6- DAYCO PRODUCTS INC TUTORIAL -\u00a6-\u00a6-\n%SELECTION ===>_ZCMD                                                           @\n%\n%                     -----------------------------------\n                      |  #         DATECHCK         %   |\n                      -----------------------------------\n@  The DATECHCK program provides a means for operator entered date information\n   to be verified and specific actions taken based on the results.\n\n   All actions are parameter driven via the#EXEC=DATECHCK,PARM=@type of data\n   entry.  There are no DD statements to be coded and actions may be automatic\n   or controled by the operator at your discretion.\n\n   The following is an example of jcl to execute the DATECHCK program:\n\n#  //STEP0010 EXEC PGM=DATECHCK,PARM='G030487,EQ,-007,RC=(00,ABEND)'\n\n@  The same execution useing substitutable parameters from a step execution\n   statement would look something like this:\n\n#  //STEP0010 EXEC PROCNAME,MM=03,DD=04,YY=87\n#  //PROCNAME PROC MM=,DD=,YY=\n#  //STEP0010 EXEC PGM=DATECHCK,PARM='G&&MM.&&DD.&&YY.,EQ,-007,RC=(00,ABEND)'\n)PROC\n     &ZCONT = DAYCCA02\n     &ZUP = DAYCC001\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DAYCCA02": {"ttr": 1798, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")ATTR DEFAULT(%@_)\n % TYPE(TEXT) INTENS(HIGH) COLOR(GREEN)\n # TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n @ TYPE(TEXT) INTENS(LOW) COLOR(BLUE)\n $ TYPE(TEXT) INTENS(LOW) COLOR(TURQ)\n _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) COLOR(RED)\n)BODY EXPAND(\u00a6\u00a6)\n\\-\u00a6-\u00a6- DAYCO PRODUCTS INC TUTORIAL -\u00a6-\u00a6-\n%SELECTION ===>_ZCMD                                                           @\n%\n%\n@  In the above example the parameter data would be interpreted as follows:\n\n@  Check the Gregorian date#03/04/87@to see if it is equal to the current\n   system date minus#7@days.  If the condition is true then end with a return\n   code of#zerro@(0).  If the condition is not true then#ABEND@.\n\n   The format of the parm data is:\n\n\\                  |EQ|\n\\                  |NE|\n\\        |Jyyddd | |LT| |+|           |ABEND|\n\\  PARM='|Gmmddyy|,|LE|,|-|vvv,RC=(nn,|bb   |)'\n\\                  |GT|               |WTOR |\n\\                  |GE|\n\n@  Where:\n         \\Jyyddd@     = The Date to be tested against in Julian format.\n                        The date must be preceeded by a\\J@with\\yy@being\n                        the year and\\ddd@being the day of the year.\n)PROC\n     &ZCONT = DAYCCA03\n     &ZUP = DAYCCA01\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DAYCCA03": {"ttr": 1800, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")ATTR DEFAULT(%@_)\n % TYPE(TEXT) INTENS(HIGH) COLOR(GREEN)\n # TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n @ TYPE(TEXT) INTENS(LOW) COLOR(BLUE)\n $ TYPE(TEXT) INTENS(LOW) COLOR(TURQ)\n _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) COLOR(RED)\n)BODY EXPAND(\u00a6\u00a6)\n\\-\u00a6-\u00a6- DAYCO PRODUCTS INC TUTORIAL -\u00a6-\u00a6-\n%SELECTION ===>_ZCMD                                                           @\n%\n%\n\\                  |EQ|\n\\                  |NE|\n\\        |Jyyddd | |LT| |+|           |ABEND|\n\\  PARM='|Gmmddyy|,|LE|,|-|vvv,RC=(nn,|bb   |)'\n\\                  |GT|               |WTOR |\n\\                  |GE|\n\n@  Continued:\n         \\Gmmddyy@    = The Date to be tested against in Gregorian format.\n                        The date must be preceeded by a\\G@with\\mm@being the\n                        month,\\dd@being the day of the month and\\yy@is the\n                        year.\n\n         \\|EQ|@\n         \\|NE|@\n         \\|LT|@       = This is the test operator that will be used in testing\n         \\|LE|@         the specified date against the current system date as\n         \\|GT|@         modified by the valu\\vvv@to establish a#good@condition\n         \\|GE|@         match.\n)PROC\n     &ZCONT = DAYCCA04\n     &ZUP = DAYCCA02\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DAYCCA04": {"ttr": 1802, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")ATTR DEFAULT(%@_)\n % TYPE(TEXT) INTENS(HIGH) COLOR(GREEN)\n # TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n @ TYPE(TEXT) INTENS(LOW) COLOR(BLUE)\n $ TYPE(TEXT) INTENS(LOW) COLOR(TURQ)\n _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) COLOR(RED)\n)BODY EXPAND(\u00a6\u00a6)\n\\-\u00a6-\u00a6- DAYCO PRODUCTS INC TUTORIAL -\u00a6-\u00a6-\n%SELECTION ===>_ZCMD                                                           @\n%\n%\n\\                  |EQ|\n\\                  |NE|\n\\        |Jyyddd | |LT| |+|           |ABEND|\n\\  PARM='|Gmmddyy|,|LE|,|-|vvv,RC=(nn,|bb   |)'\n\\                  |GT|               |WTOR |\n\\                  |GE|\n\n@  Continued:\n                        In the below example the Julian date specified must be\n                        equal to the current system date plus three.\n\n                  \\PARM='J86123,EQ,+003,...'@\n\n                        In the next example the Gregorian date given sould be\n                        greater than the current system date minus sixteen.\n\n                  \\PARM='G071686,GT,-016,...'@\n\n\n)PROC\n     &ZCONT = DAYCCA05\n     &ZUP = DAYCCA03\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DAYCCA05": {"ttr": 1804, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")ATTR DEFAULT(%@_)\n % TYPE(TEXT) INTENS(HIGH) COLOR(GREEN)\n # TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n @ TYPE(TEXT) INTENS(LOW) COLOR(BLUE)\n $ TYPE(TEXT) INTENS(LOW) COLOR(TURQ)\n _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) COLOR(RED)\n)BODY EXPAND(\u00a6\u00a6)\n\\-\u00a6-\u00a6- DAYCO PRODUCTS INC TUTORIAL -\u00a6-\u00a6-\n%SELECTION ===>_ZCMD                                                           @\n%\n%\n\\                  |EQ|\n\\                  |NE|\n\\        |Jyyddd | |LT| |+|           |ABEND|\n\\  PARM='|Gmmddyy|,|LE|,|-|vvv,RC=(nn,|bb   |)'\n\\                  |GT|               |WTOR |\n\\                  |GE|\n\n@  Continued:\n                        In this example the Julian date given must be equal to\n                        todays date.\n\n                  \\PARM='J87030,EQ,+000,...'@\n\n         \\|+|   @\n         \\|-|vvv@     = A value numeric value#vvv@that is to be added to#+@or\n                        subtracted from#-@the current system date.  The value\n                        must be three digits preceeded by the plus or minus\n                        sign.  The values#+000@and#-000@are both treated as\n                        zero.  The max value allowed is#+366@to#-366@.\n)PROC\n     &ZCONT = DAYCCA06\n     &ZUP = DAYCCA04\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DAYCCA06": {"ttr": 1806, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")ATTR DEFAULT(%@_)\n % TYPE(TEXT) INTENS(HIGH) COLOR(GREEN)\n # TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n @ TYPE(TEXT) INTENS(LOW) COLOR(BLUE)\n $ TYPE(TEXT) INTENS(LOW) COLOR(TURQ)\n _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) COLOR(RED)\n)BODY EXPAND(\u00a6\u00a6)\n\\-\u00a6-\u00a6- DAYCO PRODUCTS INC TUTORIAL -\u00a6-\u00a6-\n%SELECTION ===>_ZCMD                                                           @\n%\n%\n\\                  |EQ|\n\\                  |NE|\n\\        |Jyyddd | |LT| |+|           |ABEND|\n\\  PARM='|Gmmddyy|,|LE|,|-|vvv,RC=(nn,|bb   |)'\n\\                  |GT|               |WTOR |\n\\                  |GE|\n@  Continued:\n               \\ |ABEND|\n         \\RC=(nn,|bb   |)\n                \\|WTOR |\n\n                 @This part of the parameter specification determines what\n                  action is to be taken when the result of the test is good\n                  or bad.  The#RC=(@is required.  The#nn@value is the return\n                  code DATECHCK is to end with if the conditions are good.\n                  This must be a two digit numeric value between#00@and#99@\n                  and must be followed by a comma.  The second (bad condition)\n                  portion of the#RC=@specification may be a two digit numeric\n                  value (#00@to#99@the#bb@spec),#ABEND@unconditionaly, or ask\n)PROC\n     &ZCONT = DAYCCA07\n     &ZUP = DAYCCA05\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DAYCCA07": {"ttr": 1808, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")ATTR DEFAULT(%@_)\n % TYPE(TEXT) INTENS(HIGH) COLOR(GREEN)\n # TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n @ TYPE(TEXT) INTENS(LOW) COLOR(BLUE)\n $ TYPE(TEXT) INTENS(LOW) COLOR(TURQ)\n _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) COLOR(RED)\n)BODY EXPAND(\u00a6\u00a6)\n\\-\u00a6-\u00a6- DAYCO PRODUCTS INC TUTORIAL -\u00a6-\u00a6-\n%SELECTION ===>_ZCMD                                                           @\n%\n%\n\\                  |EQ|\n\\                  |NE|\n\\        |Jyyddd | |LT| |+|           |ABEND|\n\\  PARM='|Gmmddyy|,|LE|,|-|vvv,RC=(nn,|bb   |)'\n\\                  |GT|               |WTOR |\n\\                  |GE|\n@  Continued:\n\n                 @the operator#(WTOR)@whether to continue with the return code\n                  that was specified for a good condition or abend.\n\n                  There are three possible abend codes.  If an invalid paramter\n                  is encountered DATECHCK abends with a user code of 522.  If\n                  the abend is due to a bad comparison of dates and the#ABEND@\n                  was specified the user abend is a 122.  If the abend is from\n                  the operator reply the user abend code is 222.\n\n\n\n)PROC\n     &ZUP = DAYCCA06\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DAYCC001": {"ttr": 1810, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")ATTR DEFAULT(%@_)\n % TYPE(TEXT) INTENS(HIGH) COLOR(GREEN)\n # TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n @ TYPE(TEXT) INTENS(LOW) COLOR(BLUE)\n $ TYPE(TEXT) INTENS(LOW) COLOR(TURQ)\n _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) COLOR(RED)\n)BODY EXPAND(\u00a6\u00a6)\n\\-\u00a6-\u00a6- DAYCO PRODUCTS INC TUTORIAL -\u00a6-\u00a6-\n%SELECTION ===>_ZCMD                                                           @\n%\n%                     -----------------------------------\n                      |  #Non-Vendor Batch Utilities%   |\n                      -----------------------------------\n@  This series of panels describe Dayco developed or other non-vendor\n   supplied batch utilities that can be of help for production and test\n   jobs.\n\n   The following utilities will be presented in order or may be selected.\n\n   \\1 $DATECHCK@  Parm date check utility program.\n   \\2 $WTO     @  Write a message to the operator utility program.\n   \\3 SMART    @  Simple Manual and Report Transcriber\n)PROC\n     &ZSEL = TRANS( &ZCMD\n                1,DAYCCA01\n                2,DAYCCB01\n                2,DAYCCC01\n                *,'?'\n                )\n     &ZUP = DAYC0001\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DAYC0001": {"ttr": 1812, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")ATTR DEFAULT(%@_)\n % TYPE(TEXT) INTENS(HIGH) COLOR(GREEN)\n # TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n @ TYPE(TEXT) INTENS(LOW) COLOR(BLUE)\n $ TYPE(TEXT) INTENS(LOW) COLOR(TURQ)\n _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) COLOR(RED)\n)BODY EXPAND(\u00a6\u00a6)\n\\-\u00a6-\u00a6- DAYCO PRODUCTS INC TUTORIAL -\u00a6-\u00a6-\n%SELECTION ===>_ZCMD                                                           @\n%\n%                     -----------------------------------\n                      |    #  TUTORIAL PURPOSE   %      |\n                      -----------------------------------\n@\n   This set of tutorials is to provide online information to Dayco Products\n   Inc. MIS personnel on data center JCL standards, departmental proceedures,\n   batch utility programs available,  called batch routines,  TSO and ISPF\n   facilities that are not standard ISPF facilities, etc.\n\n   The following topics are presented in sequence, or may be selected by\n   number:\n\n  \\1$ JCL Standards    @ Data center JCL standards for production and test.\n  \\2$ MIS Proceedures  @ Defined Dayco MIS proceedures.\n  \\3$ Batch Utilities  @ Available non-vendor batch utilities.\n  \\4$ Batch Utilities  @ Available vendor batch utilities.\n  \\5$ Called Routines  @ Available program called routines.\n  \\6$ ISPF Facilities  @ Non-standard ISPF facilities.\n  \\7$ TSO Facilities   @ Non-standard TSO facilities.\n\n)PROC\n     &ZSEL = TRANS( &ZCMD\n                1,DAYCA001\n                2,DAYCB001\n                3,DAYCC001\n                4,DAYCD001\n                5,DAYCE001\n                6,DAYCF001\n                7,DAYCG001\n               99,DAYCZ999\n                *,'?'\n                )\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT027/FILE027.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT027", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}