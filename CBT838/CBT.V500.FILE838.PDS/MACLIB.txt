./ ADD NAME=$$$MACDC 0100-10261-10261-2355-00002-00002-00000-MACLIB
  This is the entire macro library, put together in one member.

./ ADD NAME=BREAK    0100-10260-10260-1641-00028-00028-00000-MACLIB
         MACRO ,
&NAME    BREAK ,
.* DATE.     28-JUL-1989
.* REMARKS.  THIS MACRO WORKS WITH THE MACROS WRITTEN BY DON HIGGINS,
.*          FOUND ON FILE 078 OF SHARE MVS GROUP MODS TAPE, V29 (04/84)
.*  SEE CASE,DOCASE,DOMACRO,EQUBC,ELSE,ELSEIF,ESAC,ESACOD,FI,IF,OD;
.*  AND CONTINUE.
.***************
.* NOTE -- THIS MACRO WILL ONLY WORK WHEN IT IS IN A ONE-LEVEL IF
.*        INSIDE A DO-LOOP -- FOR INSTANCE,
.*                     DO UNTIL,(...CONDITION...)
.*                       ...
.*                       IF (..OTHER.CONDITION..)
.*                         BREAK
.*                       FI
.*                       ...
.*                     OD
.*
.* (THIS RESTRICTION IS BECAUSE THE DO MACRO AND THE IF MACRO
.*  USE THE SAME ARRAY, &ELSE(10), TO STORE THEIR INFORMATION.
.*  SOMEDAY WE'LL SPLIT THEM, AND THEN YOU CAN CODE BREAK ANYWHERE.)
.***************
         GBLA  &DO(10),&DOSEQ(10),&DOLVL,&DOLAB
         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB
         LCLA &LCLA
&LCLA    SETA  &LEVEL-1
&NAME    B     IF0&ELSE(&LCLA)     EXIT FROM INNERMOST ENCLOSING LOOP
         MEND  ,
./ ADD NAME=CECDYN   0100-10260-10260-1641-02382-02382-00000-MACLIB
         MACRO ,                                                      1
&NAME    CECDYN &VERB=,&FLG11=,&FLG21=,&FLG22=,&TEXT=,&PREFIX=,&MF=I, 0X
               &LIST=Y,                                                X
               &POS1,&POS2,&POS3,&POS4,&POS5,&POS6,&POS7,&POS8,&POS9,  X
               &POS10
.* NOTE -- ASA CARRIAGE CONTROL CHARACTERS IN COLUMN 71 >>>>>>>>>>>>>>0
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70
.*
.* MACRO NAME = CECDYN
.*
.* (C) COPYRIGHT CENTERIOR ENERGY CORPORATION 1988,1991
.*
.* FUNCTION = BUILD PARAMETER LIST FOR CALL TO DYNALLOC MACRO (SVC99)
.*
.*  THIS MACRO PROCESSES DIFFERENTLY THAN IBM-SUPPLIED MACROS, BECAUSE
.* IT GENERATES A DSECT FOR ITS PARAMETER LIST, AND ALL MOVES INTO THE
.* PARAMETER LIST ARE DONE USING THE NAMES DEFINED IN THE DSECT.
.*
.* IF &PREFIX IS SPECIFIED, SAVE IT IN GLOBAL &CEC#P (3 CHARS OR LESS)
.*                          ELSE GENERATE A UNIQUE 3-CHARACTER &CEC#P.
.* IF MF=E, THEN &PREFIX COULD REPEAT A PREVIOUSLY-SPECIED &PREFIX
.*          ELSE &PREFIX MUST BE UNIQUE.
.*
.* FURTHER PROCESSING IS DONE IN MULTIPLE PASSES:
.*   IF MF=L, 1 PASS -- CREATE DC.S (DEFINE CONSTANT) FOR ALL OPERANDS
.*                      WITH SUPPLIED VALUES FOR NON-REGISTER OPERANDS
.*                      AND WITH VALUES OF 0 FOR REGISTER OPERANDS;
.*            AND MEXIT.
.*   IF MF=I, 2 PASSES -- 1ST PASS EXACTLY LIKE MF=L;
.*                        2ND PASS, MOVE REGISTER OPERANDS TO STORAGE;
.*            AND MEXIT.
.*   IF MF=E, 2 PASSES -- 1ST PASS, DEFINE &CEC#P.DSECT, IF VALUE OF
.*                        &PREFIX WAS NOT ENCOUNTERED BEFORE;
.*                     -- 2ND PASS, MOVE ALL OPERANDS TO STORAGE,
.*                        BOTH REGISTER AND NON-REGISTER;
.*            AND MEXIT.
.*
.*  THE VALUES THE USER CAN CODE FOR VERB,FLG11,FLG21,FLG22 ARE THE
.* NAMES FROM MACRO IEFZB4D0, MINUS THE PREFIX 'S99'.  THE VALUES ARE
.* NOT CHECKED, BUT INCORRECT VALUES WILL CAUSE ASSEMBLY ERRORS
.* BECAUSE THEN THE GENERATED NAMES ARE NOT DEFINED BY IEFZB4D0.
.*  THE ADVANTAGE OF NOT CHECKING IS THAT, IF IBM DEFINES NEW VALID
.* VALUES IN MACRO IEFZB4D0, NO UPDATE OF THIS MACRO IS NECESSARY TO
.* RECOGNIZE AND PROCESS THE NEW VALUES.
.*  AS OF 14-FEB-1991, VALID VALUES DEFINED IN IEFZB4D0 ARE:
.* VERB COULD BE AL/UN/CC/DC/RI/DN/IN (CHOOSE ONLY ONE).
.* FLG11 COULD BE ONCNV, NOCNV, NOMNT, JBSYS, CNENQ.
.* FLG21 COULD BE WTVOL,WTDSN,NORES,WTUNT,OFFLN,TIONQ,CATLG,MOUNT.
.* FLG22 COULD BE UDEVT, PCINT, DYNDI.
.* FOR THE FLG.S, SPECIFY MULTIPLE VALUES WITHIN PARENTHESES.
.*
.*  TEXT UNITS ARE SPECIFIED IN THE FORM (KEY,<(VALUE0<,VALUE1...>)>).
.* IF A TEXT UNIT KEY IS SUPPLIED FOR A VERB FOR WHICH IT IS NOT
.* VALID, IT IS NOT CHECKED BY THIS MACRO, BUT IT CAUSES AN ASSEMBLY
.* ERROR BECAUSE THEN THE GENERATED KEY NAME IS NOT DEFINED BY
.* IEFZB4D2.
.*  EACH KEY NAME IS 'D' FOLLOWED BY THE 2-CHAR VERB NAME, FOLLOWED
.* BY THE TEXT UNIT NAME.
.*
.*                                                                    -
.* EXAMPLE OF CALLING SEQUENCE:
.*         CECDYN PREFIX=X01,MF=(E,WORKAREA),                       X
.*               VERB=AL,FLG11=(ONCNV,NOMNT),                       X
.*               TEXT=((DDNAM,DSCL8),(SYSOU,'A'),RTORG)
.* IF ANY TEXT UNITS SHOULD RETURN VALUES, THE VALUES WILL BE FOUND
.* IN FIELDS LABELLED WITH THE 3 CHARACTERS SPECIFIED BY &PREFIX,
.* PLUS THE TEXT UNIT'S NAME.  THE ABOVE CALL WILL DEFINE ORDINARY
.* LABEL X01RTORG.
.*
.*   IF &PREFIX IS REPEATED ACROSS CALLS, THE DSECT IS NOT DUPLICATED,
.* BUT THE EXACT SAME TEXT UNITS MUST BE SPECIFIED AS WERE ON THE
.* ORIGINAL CALL.  (OR, AT LEAST, NO TEXT UNITS THAT DID NOT APPEAR
.* IN THE ORIGINAL CALL.  THAT IS, FEWER COULD BE SPECIFIED.)  THE
.* FLAG FIELDS CAN BE DIFFERENT THAN ON THE ORIGINAL CALL.
.*
.* GLOBALS
         GBLA  &CEC#CMT1COL  DEFAULT COLUMN FOR COMMENT 1 FIELD
         GBLA  &CEC#CMT2COL  DEFAULT COLUMN FOR COMMENT 2 FIELD
         GBLA  &CECCMT1COL   CURRENT COLUMN FOR COMMENT 1 FIELD
         GBLA  &CECCMT2COL   CURRENT COLUMN FOR COMMENT 2 FIELD
         GBLC  &CEC#CMT2VAL  TEXT AT RIGHT-HAND END OF GENERATED STMTS
         GBLC  &CEC#DBG#HDR  TEXT AT LEFT-HAND OF DEBUGGING MNOTES
         GBLB  &CEC#DEBUG    Q. ISSUE MSG.S ABOUT INTERNAL PROCESSING?
         GBLA  &CEC#FLAG(5)  CONTROLS MULTIPLE PASSES WITHIN .COMMON
         GBLB  &CEC#KEYDONE  Q. DONE RECOGNIZING TEXT UNIT?
         GBLB  &CEC#NEWP     Q. WE HAD TO ADD &CEC#P TO &CEC#PTBL?
         GBLB  &CEC#NOT1ST   Q. HAS CECDYN EVER BEEN CALLED?
         GBLC  &CEC#P        3-CHAR VALUE USED IN GENERATED CODE
         GBLA  &CEC#PMAX     MAXIMUM ENTRIES SAVED IN &CEC#PTBL(100)
         GBLC  &CEC#PTBL(100) SAVES ALL UNIQUE &CEC#P.S EVER SEEN
         GBLB  &CEC#PUSHED   Q. DO WE NEED TO POP PRINT AT MEXIT?
         GBLA  &CEC#SYSNDX   HOW MANY TIMES CECDYN HAS BEEN CALLED
         GBLB  &CEC#XLAT     Q. TABLE CODED IN &POS9 OF .DOKEY CALL?
         GBLC  &CEC#3CH      UNIQUE, GENERATED INTERNALLY
.* LOCALS
         LCLA  &I,&J,&LCLA,&LCLA2,&LCLA3
         LCLA  &I1,&I10,&IIX
         LCLC  &KEY,&VALUE
         LCLB  &LCLB,&LCLB1
         LCLC  &LBL,&OPR,&OPD,&CMT
         LCLC  &LCLC,&LCLC2,&LCLC3
         LCLC  &DUP,&TYP,&LGH,&VAL
         LCLA  &DV,&LV
         LCLC  &DX,&LX,&VV
.*
&NX      SETC  '&SYSNDX'               DEFINE SHORTER NAME FOR LATER
.*
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7
.*
         AIF   (&CEC#NOT1ST).NOT1STA
         MNOTE '* MACRO CECDYN, LAST CHANGE 14-JAN-1993 11.31'
.* CHANGE LOG: (NEWEST CHANGE ON TOP)
.* 14-JAN-1993  L.SOMOS  AFTER .CLEAR, CHECK FOR '*' TO SET HI-BIT.
.* 14-MAR-1991  L.SOMOS  CORRECT PROCESSING OF REGISTER OPERANDS.
.NOT1STA ANOP  ,
.*
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71
.*
         AIF   (&CEC#NOT1ST).NOT1STB
.* FOLLOWING PROCESSING DONE ONLY ONCE PER SOURCE MODULE
.*
&CEC#CMT1COL SETA 33         COLUMN OF COMMENTS ON GENERATED LINES
&CEC#CMT2COL SETA 63         COLUMN OF COMMENTS ON GENERATED LINES
&CEC#DEBUG SETB 0      TURN OFF
.* TURN ON BY CALLING WITH ONLY 1 POSITIONAL PARAMETER, DEBUG
.*
&CEC#NOT1ST SETB 1           ABOVE PROCESSING NEVER REPEATED AGAIN
.NOT1STB ANOP  ,
.*
.* THIS MUST COME AFTER .NOT1STB:
         AIF   (0 NE N'&SYSLIST).SUBROUT   GO CHECK SUBROUTINE CALLS
.* ONLY KEYWORD PARMS ARE USED IN EXTERNAL CALLS, NO POSITIONAL PARMS.
.* POSITIONAL PARMS ARE ONLY USED IN RECURSIVE INNER MACRO SELF-CALLS.
.*
&CEC#SYSNDX SETA 1+&CEC#SYSNDX    COUNT NON-SUBROUTINE CALLS TO CECDYN
.*
         MNOTE                                      '* MACRO CECDYN IS X
               (C) COPYRIGHT CENTERIOR ENERGY CORPORATION 1988,1991   '
.*
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7
.*
.* SET THE VALUE OF &CEC#3CH
&Q1      SETA  (&CEC#SYSNDX-1)/36      1ST QUOTIENT
&R1      SETA  (&CEC#SYSNDX-1)-36*&Q1  1ST REMAINDER, FOR 3RD CHAR
&Q2      SETA  &Q1/36                  2ND QUOTIENT
&R2      SETA  &Q1-36*&Q2              2ND REMAINDER, FOR 2ND CHAR
&Q3      SETA  &Q2/26                  3RD QUOTIENT
&R3      SETA  &Q2-26*&Q3              3RD REMAINDER, FOR 1ST CHAR
.* R1 AND R2 ARE ALWAYS 0 THROUGH 35   (1+&R? IS ALWAYS 1 THRU 36)
.* R3 IS ALWAYS 0 THROUGH 25       (10+1+&R3 IS ALWAYS 11 THRU 36)
&LCLC    SETC  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' LENGTH 36
&CEC#3CH SETC  '&LCLC'(10+1+&R3,1).'&LCLC'(1+&R2,1).'&LCLC'(1+&R1,1)
.* &CEC#3CH IS UNIQUE FOR &CEC#SYSNDX LE 26*36*36 = 33696.
.* &CEC#3CH ALWAYS BEGINS WITH ALPHA, NEXT 2 CHARS ARE ALPHANUMERIC.
.* R1 CHANGES MOST QUICKLY, R2 NEXT, AND R3 CHANGES SLOWEST.
.* &CEC#3CH RANGES THROUGH A00,A01...A09,A0A,A0B...A0Z,
.*                         A10,A11...A19,A1A,...A1Z, A20...A29, ETC.
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7
.*
.* SET THE VALUE OF &CEC#P
         AIF   (T'&PREFIX EQ 'O').SETP WE MUST SUPPLY IT
&CEC#P   SETC  '&PREFIX'
         AIF   (K'&PREFIX GE 1 AND K'&PREFIX LE 3).PREFIXD ALL DONE
&CEC#P   SETC  '&PREFIX'(1,3)          ONLY FIRST THREE CHARACTERS
         CECDYN MNOTE,'ONLY FIRST 3 CHARACTERS OF PREFIX ARE USED, ',  X
               '"&CEC#P" INSTEAD OF "&PREFIX"'
         AGO   .PREFIXD                  ALL DONE
.SETP    ANOP  , NO VALUE SPECIFIED, SO CREATE ONE.
&CEC#P   SETC  '&CEC#3CH'
.PREFIXD ANOP  ,
.*
         AIF   ('&CEC#P' EQ '&CEC#3CH').PEQ3CH
         CECDYN MNOTE,'*        PREFIX=&PREFIX WAS SPECIFIED -- ',     X
               'ELSE, PREFIX WOULD HAVE BEEN SET TO "',&CEC#3CH,       X
               '", GENERATED FROM CEC#SYSNDX=&CEC#SYSNDX..'
.PEQ3CH  ANOP  ,
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7
.*
.* SAVE &CEC#P IN &CEC#PTBL
&CEC#NEWP SETB 0                       CLEAR FLAG
&I       SETA  1
.NEXTI01 ANOP  ,
         AIF   ('&CEC#PTBL(&I)' EQ '&CEC#P').OLDP YES, WE FOUND IT
.ADVI01  ANOP  , ADVANCE &I
&I       SETA  &I+1
         AIF   (&I LE &CEC#PMAX).NEXTI01
.* OK, IT HAS NEVER BEEN SEEN BEFORE
&CEC#NEWP SETB 1                       SET FLAG FOR LATER CHECKING
&CEC#PMAX SETA &CEC#PMAX+1             INCREASE COUNTER
&CEC#PTBL(&CEC#PMAX) SETC '&CEC#P'     PLACE INTO TABLE
.OLDP    ANOP  ,
.* NOTE - THE ABOVE CODE DOES A SUPERFLUOUS COMPARISON WHEN
.*       &CEC#PMAX==0, BUT THIS DOES NOT AFFECT CORRECT PROCESSING.
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7
.*
.* CHECK &LIST PARAMETER FOR ERRORS.
         AIF   ('&LIST' EQ 'YES' OR '&LIST' EQ 'NO').LISTOK
         AIF   ('&LIST' EQ 'Y' OR '&LIST' EQ 'N').LISTOK
         MNOTE 12,'LIST=&LIST INVALID, LIST=YES ASSUMED'
.LISTOK  ANOP  ,
         AIF   ('&LIST' EQ 'NO').LISTNO
         AIF   ('&LIST' EQ 'N').LISTNO
         AGO   .LISTEX
.LISTNO  ANOP  ,
         AIF   (&CEC#PUSHED).PUSHED
         PUSH  PRINT         PUSH PRINT
&CEC#PUSHED SETB 1
.PUSHED  ANOP  ,
         PRINT OFF           LIST=NO WAS REQUESTED
.LISTEX  ANOP  ,
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7
.*
.* CHECK &MF PARAMETER FOR ERRORS.
         AIF   ('&MF' EQ '').MFOK
         AIF   ('&MF' EQ 'L' OR '&MF' EQ 'I').MFOK
         AIF   ('&MF(1)' EQ 'E').MFOK
         MNOTE 12,'MF=&MF INVALID, NORMAL FORM ASSUMED'
.MFOK    ANOP  ,
&LCLC    SETC  'CECDYN -- SECOND PARAM REQUIRED FOR MF=E'
         AIF   (N'&MF LT 2 AND ('&MF(1)' EQ 'E')).ERRMAIN
&LCLC    SETC  'CECDYN -- TOO MANY PARAMS FOR MF'
         AIF   (N'&MF GT 2 AND ('&MF(1)' EQ 'E')).ERRMAIN
         AIF   ('&MF(1)' EQ 'L').TYPEL
         AIF   ('&MF(1)' EQ 'E').TYPEE
         AGO   .TYPEI              ASSUME NORMAL FORM
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7
.*
.ERRMAIN MNOTE '&LCLC'       ISSUE MESSAGE AND EXIT
         AGO   .MEXIT
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7
.*
.MEXIT   ANOP  ,             USE THIS EXIT FROM MAINLINE
         AIF   (NOT &CEC#PUSHED).NOPOP1 THEN WE DON'T NEED TO UN-DO IT.
         POP   PRINT
&CEC#PUSHED SETB 0
.NOPOP1  ANOP  ,
&CEC#DEBUG SETB 0      TURN OFF
         MEXIT ,
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71
.*
.TYPEI   ANOP  , NORMAL FORM
         CECDYN DEBUG,.TYPEI SAVE HEADING FOR DEBUG MESSAGES
         CNOP  0,4           ALIGN LIST TO FULLWORD
         BAS   1,IGX&NX      BRANCH AROUND LIST, POINT REG1 TO LIST
&CEC#FLAG(1) SETA 1,0,0,0,1  YES DC, NO DS, NO REG, NO MOVES, COMMON1
         AGO   .COMMON
.COMMON1 ANOP  ,
IGX&NX   DS    0H            BRANCHED AROUND LIST
&CEC#FLAG(1) SETA 0,0,1,0,2  NO DC, NO DS, YES REG, NO MOVES, COMMON2
         AGO   .COMMON
.COMMON2 ANOP  ,
         AGO   .MEXIT
.*
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7
.*
.TYPEL   ANOP  , LIST FORM
         CECDYN DEBUG,.TYPEL SAVE HEADING FOR DEBUG MESSAGES
&CEC#FLAG(1) SETA 1,0,0,0,3  YES DC, NO DS, NO REG, NO MOVES, COMMON3
         AGO   .COMMON
.COMMON3 ANOP  ,
         AGO   .MEXIT
.*
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7
.*
.TYPEE   ANOP  , EXECUTE FORM
         CECDYN DEBUG,.TYPEE SAVE HEADING FOR DEBUG MESSAGES
.*
.* CREATE A DSECT:
&CEC#FLAG(1) SETA 0,1,0,0,4  NO DC, YES DS, NO REG, NO MOVES, COMMON4
         AGO   .COMMON
.COMMON4 ANOP ,
.*
         AIF   ('&MF(2)'(1,1) EQ '('             AND                   X
               '&MF(2)'(K'&MF(2),1) EQ ')').USEREG
&NAME    LA    1,&MF(2)                LOAD ADDRESS OF PARAMETER LIST
         AGO   .REG1SET
.*
.USEREG  ANOP  ,                       IF A REGISTER WAS SPECIFIED
&LCLC    SETC  '&MF(2)'(2,K'&MF(2)-2)  REGISTER NAME (W/O PARENS)
         AIF   ('&LCLC' EQ '1').GENDS0H
&NAME    LR    1,&LCLC                 LOAD PARAMETER LIST ADDRESS
         AGO   .REG1SET
.*
.GENDS0H ANOP  ,
&NAME    DS    0H                      REG 1 CONTAINS LIST ADDRESS
         AGO   .REG1SET
.*
.REG1SET ANOP  ,
         USING &CEC#P.DSECT,1          REGISTER 1 POINTS TO DSECT
.*
&CEC#FLAG(1) SETA 0,0,1,1,5  NO DC, NO DS, YES REG, YES MOVES, COMMON5
         AGO   .COMMON
.COMMON5 ANOP  ,
         DROP  1
.*
         AGO   .MEXIT
.*
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71
.*
.COMMON  ANOP  , GENERATE STRUCTURE OF PARAMETER LIST
.* THIS IS AN AGO-TYPE INTERNAL ROUTINE --
.* IT EXITS WITH THE STATEMENT:            AGO .COMMON&CEC#FLAG(5)
         CECDYN DEBUG,'START .COMMON, RETURN INDEX=&CEC#FLAG(5); ',    X
               'FLAGS=&CEC#FLAG(1),&CEC#FLAG(2),',                     X
               '&CEC#FLAG(3),&CEC#FLAG(4).'
.* .COMMON IS CALLED WITH FLAGS 1,0,0,0 -- JUST &CEC#FLAG(1),
.*                           OR 0,1,0,0 -- JUST &CEC#FLAG(2),
.*                           OR 0,0,1,0 -- JUST &CEC#FLAG(3),
.*                           OR 0,0,1,1 -- WITH &CEC#FLAG(3) AND (4).
.* IF &CEC#FLAG(1), MAKE DC.S FOR ALL OP.S, WITH ZEROS FOR REG. OP.S
.* IF &CEC#FLAG(2), MAKE DS.S FOR ALL OP.S, WITH ZEROS FOR ALL OP.S
.* IF &CEC#FLAG(3), THEN MOVE ONLY OPERANDS WHICH CANNOT BE GENERATED
.*               IN DC.S (REGISTER OPERANDS, AND SYMBOLIC OPERANDS
.*               FOR CONSTANTS OF TYPES WHICH REQUIRE QUOTES.)
.* IF &CEC#FLAG(4), THEN MOVE OTHER OPERANDS (LITERALS, ACONS, NULLS)
.*
.*                                                                    -
         AIF   (NOT &CEC#FLAG(1) AND NOT &CEC#FLAG(2)).NOEQU1
         AIF   (NOT &CEC#NEWP).COMEXIT SKIP -- ASSUME ALREADY DONE.
         CECDYN DEBUG,'NEWP=1, GENERATE DSECT'
         SPACE 2
&LCLC    SETC '&CEC#P.ORG'
         AIF   (&CEC#FLAG(1)).ORGDC
         AIF   (&CEC#FLAG(2)).ORGDSCT
         MNOTE 16,'SEVERE INTERNAL ERROR'
         MNOTE 'CEC#FLAG(1)=&CEC#FLAG(1) CEC#FLAG(2)=&CEC#FLAG(2)'
&CEC#DEBUG SETB 1      TURN ON
         AGO   .MEXIT
.ORGDC   ANOP  ,
&LCLC2   SETC  'DC'
&LCLC3   SETC  '0F''0'''
         AGO   .EQU1
.ORGDSCT ANOP  ,
&LCLC2   SETC  'DSECT'
&LCLC3   SETC  ''
.EQU1    ANOP  ,
&LCLC    &LCLC2 &LCLC3
*...+....1....+....2....+....3....+....4....+....5....+....6....+....7
*                SVC 99 INPUT REQUEST BLOCK
*...+....1....+....2....+....3....+....4....+....5....+....6....+....7
.NOEQU1  ANOP  ,
.*..+....1....+....2....+....3                                        0
.*
.* BUILD &LCL#FLG11, &LCLFLG21, &LCLFLG22 BY SUMMING BIT MASKS:
.*..+....1....+....2                                                  0
.*
&LCL#FLG11 SETC '0'
         AIF   (K'&FLG11 EQ 0).FLG11ZZ
&I       SETA  1
&LCL#FLG11 SETC 'S99&FLG11(&I)'
         AIF   (N'&FLG11 LE &I).FLG11XX
.FLG11QQ ANOP  ,
&I       SETA  &I+1
&LCL#FLG11 SETC '&LCL#FLG11.+S99&FLG11(&I)'
         AIF   (N'&FLG11 GT &I).FLG11QQ
.FLG11XX ANOP  ,
.FLG11ZZ ANOP  ,
.*..+....1....+....2                                                  0
.*
&LCL#FLG21 SETC '0'
         AIF   (K'&FLG21 EQ 0).FLG21ZZ
&I       SETA  1
&LCL#FLG21 SETC 'S99&FLG21(&I)'
         AIF   (N'&FLG21 LE &I).FLG21XX
.FLG21QQ ANOP  ,
&I       SETA  &I+1
&LCL#FLG21 SETC '&LCL#FLG21.+'.'S99&FLG21(&I)'
         AIF   (N'&FLG21 GT &I).FLG21QQ
.FLG21XX ANOP  ,
.FLG21ZZ ANOP  ,
.*..+....1....+....2                                                  0
.*
&LCL#FLG22 SETC '0'
         AIF   (K'&FLG22 EQ 0).FLG22ZZ
&I       SETA  1
&LCL#FLG22 SETC 'S99&FLG22(&I)'
         AIF   (N'&FLG22 LE &I).FLG22XX
.FLG22QQ ANOP  ,
&I       SETA  &I+1
&LCL#FLG22 SETC '&LCL#FLG22.+'.'S99&FLG22(&I)'
         AIF   (N'&FLG22 GT &I).FLG22QQ
.FLG22XX ANOP  ,
.FLG22ZZ ANOP  ,
.*..+....1....+....2....+....3                                        0
.*
.* (SEE .CREAT SUBROUTINE FOR MEANING OF PARAMETERS)
.*
&CECCMT1COL SETA &CEC#CMT1COL COMMENT 1 FIELD'S COLUMN
&CECCMT2COL SETA &CEC#CMT2COL COMMENT 2 FIELD'S COLUMN
.* (EACH CALL TO .CREAT DOES ABOVE SETA.S, JUST BEFORE EXITING)
.*
&CEC#P.RBP   CECDYN CREAT,0,F
&CEC#P.RBPTR CECDYN CREAT,,A,*,A(&CEC#P.RB),'REQUEST BLOCK POINTER'
.*                 (*=HIGH BIT ON)
&CEC#P.RB    CECDYN CREAT,0,F,,,'REQUEST BLOCK'
&CEC#P.RBLN  CECDYN CREAT,,A,1,&CEC#P.RBEND-&CEC#P.RB,                 X
               'LENGTH OF REQUEST BLOCK'
&CEC#P.VERB  CECDYN CREAT,,A,1,S99VRB&VERB,'VERB CODE'
&CEC#P.FLAG1 CECDYN CREAT,0,C,2,,FLAGS
&CEC#P.FLG11 CECDYN CREAT,,A,1,&LCL#FLG11,'FIRST FLAGS BYTE'
&CEC#P.FLG12 CECDYN CREAT,,A,1,0,'SECOND BYTE OF FLAGS'
&CEC#P.RSC   CECDYN CREAT,0,C,4,,'REASON CODE FIELDS'
&CEC#P.ERROR CECDYN CREAT,,X,2,0,'ERROR REASON CODE'
&CEC#P.INFO  CECDYN CREAT,,X,2,0,'INFORMATION REASON CODE'
&CEC#P.TXTPP CECDYN CREAT,,A,,A(&CEC#P.TUPL),                          X
               'ADDR OF LIST OF TEXT UNIT PTRS'
&CEC#P.RSV01 CECDYN CREAT,,F,,0,RESERVED
&CEC#P.FLAG2 CECDYN CREAT,0,C,4,,'FLAGS FOR AUTHORIZED FUNCTIONS'
&CEC#P.FLG21 CECDYN CREAT,,A,1,&LCL#FLG21,'FIRST BYTE OF FLAGS'
&CEC#P.FLG22 CECDYN CREAT,,A,1,&LCL#FLG22,'SECOND BYTE OF FLAGS'
&CEC#P.FLG23 CECDYN CREAT,,A,1,0,'THIRD BYTE OF FLAGS'
&CEC#P.FLG24 CECDYN CREAT,,A,1,0,'FOURTH BYTE OF FLAGS'
&CEC#P.RBEND CECDYN CREAT,0,,0,,'END MARKER'
.*                                                                    1
         AIF   (NOT &CEC#FLAG(1) AND NOT &CEC#FLAG(2)).NOEQU2
*...+....1....+....2....+....3....+....4....+....5....+....6....+....7
* SVC 99 TEXT UNIT POINTER LIST
*...+....1....+....2....+....3....+....4....+....5....+....6....+....7
.NOEQU2  ANOP  ,
.*
&CEC#P.TUPL  CECDYN CREAT,0,F,,,'TEXT UNIT POINTER LIST'
&I       SETA   1
.NEXTPTR ANOP  ,
&I1      SETA  &I-10*(&I/10)           1'S DIGIT OF &I
&I10     SETA  (&I/10)-10*(&I/100)     10'S DIGIT OF &I
&IIX     SETA  1+3*(&I1*(&I10-1)/(&I10-1)) IGNORE &I1 IF (&I10-1) EQ 0
&ITH     SETC  'TH ST ND RD TH TH TH TH TH TH '(&IIX,2) 0TH, 1ST, ETC.
&HIBIT   SETC  '*'                     SET FLAG TO SET HIGH BIT
         AIF   (&I EQ N'&TEXT).LASTPTR
&HIBIT   SETC  ''                      RESET FLAG TO SET HIGH BIT
.LASTPTR ANOP  ,
&LCLC3   SETC  'A(&CEC#P.TU&I)'
&LCLC4   SETC  '&TEXT(&I,1)'
         AIF   (T'&TEXT(&I,1) NE 'O').NORMAL1 NOT- SKIPPED UNIT
&LCLC3   SETC  '0'
&LCLC4   SETC  '(OMITTED)'
.NORMAL1 ANOP  ,
.* ACTUAL CODE GENERATION:                                            -
&CEC#P.PTR&I CECDYN CREAT,,A,&HIBIT,                                   X
               &LCLC3,                                                 X
               '&I&ITH TEXT UNIT POINTER, &LCLC4'
.***************************
.* THE EFFECT OF THE ABOVE CODE IS:
.* &CEC#P.PTR&I CECDYN CREAT,,A,&HIBIT,                                X
               A(&CEC#P.&TEXT(&I,1).-(S99TUPAR-S99TUNIT)),             X
               '&I&ITH TEXT UNIT POINTER, &TEXT(&I,1)'
.***************************
.ADVPTR  ANOP  , ADVANCE &I
&I       SETA  &I+1
         AIF   (&I LE N'&TEXT).NEXTPTR
.*
.*                                                                    1
         AIF   (NOT &CEC#FLAG(1) AND NOT &CEC#FLAG(2)).NOEQU3
*...+....1....+....2....+....3....+....4....+....5....+....6....+....7
* SVC 99 TEXT UNITS
*...+....1....+....2....+....3....+....4....+....5....+....6....+....7
.NOEQU3  ANOP  ,
.*
.*   BEGIN A HUGE LOOP, AROUND ALL SELF-CALLS TO .DOKEY SUBROUTINE.
.* THIS LOOP USES &I AS AN INDEX TO STEP THROUGH ALL SUBLIST ENTRIES
.* SPECIFIED IN THE TEXT= PARAMETER IN THE OUTER CALL TO CECDYN.
.*
&I       SETA   1
.NEXTI09 ANOP  ,
.*
&I1      SETA  &I-10*(&I/10)           1'S DIGIT OF &I
&I10     SETA  (&I/10)-10*(&I/100)     10'S DIGIT OF &I
&IIX     SETA  1+3*(&I1*(&I10-1)/(&I10-1)) IGNORE &I1 IF (&I10-1) EQ 0
&ITH     SETC  'TH ST ND RD TH TH TH TH TH TH '(&IIX,2) 0TH, 1ST, ETC.
&KEY     SETC  'D&VERB.&TEXT(&I,1)'
.*
         AIF   (T'&TEXT(&I,1) EQ 'O').ADVI09  SKIPPED UNIT
.*
         AIF   (T'&TEXT(&I,1) NE 'O').NORMAL2 NOT- SKIPPED UNIT
&KEY     SETC  '(OMITTED)'
.NORMAL2 ANOP  ,
.*
         CECDYN CMT2,        SET &CEC#CMT2VAL (TO BLANKS)
.*
&CECCMT1COL SETA &CEC#CMT1COL-6 SHIFT CHARS LEFT, SO 'BEGIN' STANDS OUT
&CEC#P.TU&I  CECDYN CREAT,0,F,,,'BEGIN &I&ITH TEXT UNIT, &KEY'
.*
         AIF   (T'&TEXT(&I,1) EQ 'O').ADVI09  SKIPPED UNIT
.*
&CEC#P.KEY&I CECDYN CREAT,,A,2,&KEY,'&I&ITH KEY'
.*
&CEC#KEYDONE SETB 0          PREPARE TO SEARCH
.*
.*  INFORMATION BELOW IS FROM MVS/XA SPL: SYSTEM MACROS AND FACILITIES
.* GC28-1150-2.
.*
.* (SEE .DOKEY SUBROUTINE FOR MEANING OF PARAMETERS)
.* DSNAME ALLOCATION TEXT UNITS                                       -
         AIF   ('&VERB' NE 'AL').AL#DONE
.*
.* DDNAME
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDDNAM,1,C,(1,8)
         AIF   (&CEC#KEYDONE).ADVI09
.* DSNAME (MUTUALLY EXCLUSIVE WITH DALQNAME, DALIPLTX)
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDSNAM,1,C,(1,44)
         AIF   (&CEC#KEYDONE).ADVI09
.* PDS MEMBER (REQUIRES DALDSNAM ALSO)
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMEMBR,1,C,(1,8)
         AIF   (&CEC#KEYDONE).ADVI09
.* DATA SET STATUS (MUTUALLY EXCLUSIVE WITH DALSYSOU)
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSTATS,1,A,1,              X
               ((OLD,X'01'),(MOD,X'02'),(NEW,X'04'),(SHR,X'08'),       X
               *) (USER MAY CODE VALUE DIRECTLY)
         AIF   (&CEC#KEYDONE).ADVI09
.* NORMAL DISPOSITION (MUTUALLY EXCLUSIVE WITH DALSYSOU)
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALNDISP,1,A,1,              X
               ((UNCATLG,X'01'),(CATLG,X'02'),                         X
               (DELETE,X'04'),(KEEP,X'08'),                            X
               *) (USER MAY CODE VALUE DIRECTLY)
         AIF   (&CEC#KEYDONE).ADVI09
.* CONDITIONAL DISPOSITION (MUTUALLY EXCLUSIVE WITH DALSYSOU)
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCDISP,1,A,1,              X
               ((UNCATLG,X'01'),(CATLG,X'02'),                         X
               (DELETE,X'04'),(KEEP,X'08'),                            X
               *) (USER MAY CODE VALUE DIRECTLY)
         AIF   (&CEC#KEYDONE).ADVI09
.* UNIT OF DALPRIME, DALSECND WILL BE TRACKS
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALTRK,0
         AIF   (&CEC#KEYDONE).ADVI09
.* UNIT OF DALPRIME, DALSECND WILL BE CYLINDERS
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCYL,0
         AIF   (&CEC#KEYDONE).ADVI09
.* AVERAGE BLOCK LENGTH TO USE FOR UNIT OF DALPRIME, DALSECND
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBLKLN,1,A,3,,'<=65535'
         AIF   (&CEC#KEYDONE).ADVI09
.* PRIMARY SPACE QUANTITY
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPRIME,1,A,3
         AIF   (&CEC#KEYDONE).ADVI09
.* SECONDARY SPACE QUANTITY
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSECND,1,A,3
         AIF   (&CEC#KEYDONE).ADVI09
.* NUMBER OF DIRECTORY BLOCKS FOR A PDS
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDIR,1,A,3
         AIF   (&CEC#KEYDONE).ADVI09
.* RELEASE UNUSED SPACE AT CLOSE TIME
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRLSE,0
         AIF   (&CEC#KEYDONE).ADVI09
.* FORMAT OF ALLOCATED SPACE
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSPFRM,1,A,1,              X
               ((ALX,X'02'),  USE DIFFERENT AREAS OF CONTIGUOUS SPACE  X
               (MXIG,X'04'),      MAXIMUM CONTIGUOUS SPACE IS REQUIRED X
               (CONTIG,X'08'),    SPACE MUST BE CONTIGUOUS             X
               *) (USER MAY CODE VALUE DIRECTLY)
         AIF   (&CEC#KEYDONE).ADVI09
.* ALLOCATE IN WHOLE CYLINDERS
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALROUND,0
         AIF   (&CEC#KEYDONE).ADVI09
.* VOLUME SERIAL NUMBERS (MUTUALLY EXCLUSIVE WITH DALSYSOU, DALVLRDS)
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALVLSER,(1,6),C,6
         AIF   (&CEC#KEYDONE).ADVI09
.* ASSIGN USE ATTRIBUTE OF PRIVATE (MUTUALLY EXCLUSIVE WITH DALSYSOU)
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPRIVT,0
         AIF   (&CEC#KEYDONE).ADVI09
.* VOL-SEQ WITHIN MULTI-VOLUME DATA SET (MUT.EXCL.W/DALSYSOU)
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALVLSEQ,1,A,2,,'<=255'
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALVLCT,1,A,1
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALVLRDS,1,C,(1,44)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUNIT,1,C,(1,8)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUNCNT,1,A,1,,'<=59'
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPARAL,0
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSYSOU,(0,1),C,1
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSPGNM,1,C,(1,8)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSFMNO,1,C,(1,4)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALOUTLM,1,A,3
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCLOSE,0
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCOPYS,1,1,A
         AIF   (&CEC#KEYDONE).ADVI09
.* LABEL TYPE OF VOLUME
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALLABEL,1,A,1,              X
               ((NL,X'01'),  NO LABEL                                  X
               (SL,X'02'),   IBM STANDARD LABELS                       X
               (NSL,X'04'),  NON-STANDARD LABELS                       X
               (SUL,X'0A'),  IBM STANDARD LABEL PLUS USER LABEL        X
               (BLP,X'10'),  BYPASS LABEL PROCESSING                   X
               (LTM,X'21'),  CHECK FOR AND BYPASS LEADING TAPE MARK    X
               (AL,X'40'),   AMERICAN NATIONAL STANDARD LABEL          X
               (AUL,X'48'),  AL PLUS USER LABEL                        X
               *) (USER MAY CODE VALUE DIRECTLY)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDSSEQ,1,A,2,,'<=9999'
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPASPR,1,A,1,              X
               ((PASSWORD,X'10'),(NOPWREAD,X'30'),                     X
               *) (USER MAY CODE VALUE DIRECTLY)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALINOUT,1,A,1,              X
               ((OUT,X'40'),(IN,X'80'),                                X
               *) (USER MAY CODE VALUE DIRECTLY)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALEXPDT,1,C,5
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRETPD,1,A,2,,'<=9999'
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDUMMY,0
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFCBIM,1,C,(1,4)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFCBAV,1,A,1,              X
               ((VERIFY,X'04'),(ALIGN,X'08'),                          X
               *) (USER MAY CODE VALUE DIRECTLY)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALQNAME,1,C,(1,17)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALTERM,0
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUCS,1,C,(1,4)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUFOLD,0
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUVRFY,0
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDCBDS,1,C,(1,44)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDCBDD,1,C,(1,8)
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSUSER,1,C,(1,8)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSHOLD,0
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMSVGP,1,C,(1,8)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSSNM,(0,1),C,(1,4)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSSPRM,(1,254),C,(0,67)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPROT,0
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUSRID,1,A,(1,8)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBURST,1,A,1,              X
               ((Y,X'02'),(N,X'04'),(YES,X'02'),(NO,X'04'),            X
               *) (USER MAY CODE VALUE DIRECTLY)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCHARS,(1,4),C,(1,4)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCOPYG,(1,8),A,1
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFFORM,1,C,(1,4)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFCNT,1,A,1
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMMOD,1,C,(1,4)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMTRC,1,A,1
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDEFER,0
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALOUTPT,(1,128),C,(1,26)
         AIF   (&CEC#KEYDONE).ADVI09
.* DCB ATTRIBUTE TEXT UNITS                                           -
.*
.* BUFFER ALIGNMENT
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBFALN,1,A,1,              X
               ((F,X'01'),   FULLWORD, NOT DOUBLEWORD                  X
               (D,X'02'),    DOUBLEWORD                                X
               *) (USER MAY CODE VALUE DIRECTLY)
         AIF   (&CEC#KEYDONE).ADVI09
.* BUFFERING TECHNIQUE
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBFTEK,1,A,1,              X
               ((D,X'08'),   DYNAMIC                                   X
               (E,X'10'),    EXCHANGE                                  X
               (R,X'20'),    RECORD                                    X
               (S,X'40'),    SIMPLE                                    X
               (A,X'60'),    RECORD AREA                               X
               *) (USER MAY CODE VALUE DIRECTLY)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBLKSZ,1,A,2,,'<=32760'
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFIN,1,A,1,,'<=15'
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFL,1,A,2,,'<=32760'
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFMX,1,A,1,,'<=15'
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFNO,1,A,1
         AIF   (&CEC#KEYDONE).ADVI09
.* BUFFER OFFSET
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFOF,1,A,1,              X
               ((L,X'80'),   BLOCK PREFIX IS 4 BYTES, CONTAINS LENGTH  X
               *),           USER CODES VALUE OF BLOCK PREFIX          X
               '<=99'
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFOU,1,A,1,,'<=15'
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFRQ,1,A,1
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFSZ,1,A,2
         AIF   (&CEC#KEYDONE).ADVI09
.* PAPER TAPE CODE:
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCODE,1,A,1,               X
               ((T,X'02'),   TELETYPE 5-TRACK                          X
               (A,X'04'),    USASCII 8-TRACK                           X
               (C,X'08'),    NATIONAL CASH REGISTER 8-TRACK            X
               (B,X'10'),    BURROUGHS 7-TRACK                         X
               (F,X'20'),    FRIDEN 8-TRACK                            X
               (I,X'40'),    IBM BCD 8-TRACK                           X
               (N,X'80'),    NO CONVERSION                             X
               *)            (USER MAY CODE VALUE DIRECTLY)
         AIF   (&CEC#KEYDONE).ADVI09
.* SEND/RECEIVE PRIORITY
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCPRI,1,A,1,               X
               ((S,X'01'),   SEND PRIORITY                             X
               (E,X'02'),    EQUAL PRIORITY                            X
               (R,X'04'),    RECEIVING PRIORITY                        X
               *)            (USER MAY CODE VALUE DIRECTLY)
         AIF   (&CEC#KEYDONE).ADVI09
.* MAGNETIC TAPE DENSITY:
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDEN,1,A,1,                X
               ((0,X'03'),   200 BPI 7-TRACK                           X
               (1,X'43'),    556 BPI 7-TRACK                           X
               (2,X'83'),    800 BPI 7-TRACK OR 9-TRACK                X
               (3,X'C3'),    1600 BPI 9-TRACK                          X
               (4,X'D3'),    6250 BPI 9-TRACK                          X
               *)            (USER MAY CODE VALUE DIRECTLY)
         AIF   (&CEC#KEYDONE).ADVI09
.* DATA SET ORGANIZATION
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDSORG,1,A,2,              X
               ((TCAM3705,X'0004'), TCAM 3705                          X
               (VSAM,X'0008'), VSAM                                    X
               (TQ,X'0020'), TCAM MESSAGE QUEUE                        X
               (TX,X'0040'), TCAM LINE GROUP                           X
               (GS,X'0080'), GRAPHICS                                  X
               (PO,X'0200'), PARTITIONED ORGANIZATION                  X
               (POU,X'0300'), PARTITIONED ORGANIZATION UNMOVABLE       X
               (MQ,X'0400'), TELECOMMUNICATIONS MESSAGE PROCESSING Q.  X
               (CQ,X'0800'), DIRECT ACCESS MESSAGE QUEUE               X
               (CX,X'1000'), COMMUNICATION LINE GROUP                  X
               (DA,X'2000'), DIRECT ACCESS                             X
               (DAU,X'2100'), DIRECT ACCESS UNMOVABLE                  X
               (PS,X'4000'), PHYSICAL SEQUENTIAL                       X
               (PSU,X'4100'), PHYSICAL SEQUENTIAL UNMOVABLE            X
               *)            (USER MAY CODE VALUE DIRECTLY)
         AIF   (&CEC#KEYDONE).ADVI09
.* ERROR PROCESSING OPTION
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALEROPT,1,A,1,              X
               ((T,X'10'),   BSAM TESTING                              X
               (ABE,X'20'),  CAUSE ABNORMAL END OF TASK                X
               (SKP,X'40'),  SKIP BLOCK CAUSING ERROR                  X
               (ACC,X'80'),  ACCEPT BLOCK CAUSING ERROR                X
               *)            (USER MAY CODE VALUE DIRECTLY)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALGNCP,1,A,1,,'<=99'
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALINTVL,1,A,1
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALKYLEN,1,A,1
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALLIMCT,1,A,3,,'<=32760'
         AIF   (&CEC#KEYDONE).ADVI09
.* ACTUAL OR MAXIMUM LENGTH OF A LOGICAL RECORD, IN BYTES
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALLRECL,1,A,2,              X
               ((X,X'8000'), LRECL EXCEEDS 32756 (QSAM, BSAM SPANNED)  X
               *),           (USER MAY CODE VALUE DIRECTLY)            X
               '<=32760'
         AIF   (&CEC#KEYDONE).ADVI09
.* MODE OF OPERATION FOR CARD READER OR PUNCH
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMODE,1,A,1,               X
               ((E,X'40'),   EBCDIC MODE                               X
               (ER,X'50'),   EBCDIC, READ COLUMN ELIMINATE MODE        X
               (EO,X'60'),   EBCDIC, OPTICAL MARK READ MODE            X
               (C,X'80'),    CARD IMAGE MODE                           X
               (CR,X'90'),   CARD IMAGE, READ COLUMN ELIMINATE MODE    X
               (CO,X'A0'),   CARD IMAGE, OPTICAL MARK READ MODE        X
               *)            (USER MAY CODE VALUE DIRECTLY)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALNCP,1,A,1,,'<=99'
         AIF   (&CEC#KEYDONE).ADVI09
.* OPTIONAL SERVICES TO BE PERFORMED
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALOPTCD,1,A,1,              X
               (+, TRANSLATE + SUM                                     X
               (R,X'01'), RELATIVE BLOCK ADDRESSING                    X
               (J,X'01'), SELECT CHARACTER ARRANGEMENT TABLES(3800)    X
               (T,X'02'), USER TOTALING FACILITY                       X
               (Z,X'04'), REDUCED TAPE ERR RECOVERY/DIRECT DASD SEARCH X
               (A,X'08'), DIRECT ADDRESSING                            X
               (Q,X'08'), TRANSLATE ASCII TO/FROM EBCDIC               X
               (F,X'10'), FEEDBACK                                     X
               (H,X'10'), HOPPER-EMPTY EXIT                            X
               (O,X'10'), ONLINE CORRECTION (OPTICAL READERS)          X
               (C,X'20'), CHAINED SCHEDULING/TCAM SEGMENT IDENTIFICA'N X
               (E,X'20'), EXTENDED SEARCH                              X
               (B,X'40'), DISREGARD EOF RECOGNITION (TAPE)             X
               (U,X'40'), ALLOW DATA CHECKS CAUSED BY INVALID CHARS    X
               (W,X'80')) WRITE VALIDITY CHECK/PLACE TCAM MESSAGE IN   X
                                   AN EIGHT-BYTE FIELD IN THE WORKAREA
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPCIR,1,A,1,               X
               ((R,X'02'),(N,X'08'),(A,X'20'),(X,X'80'),               X
               *)            (USER MAY CODE VALUE DIRECTLY)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPCIS,1,A,1,               X
               ((R,X'01'),(N,X'04'),(A,X'10'),(X,X'40'),               X
               *)            (USER MAY CODE VALUE DIRECTLY)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPRTSP,1,A,1,              X
               ((0,X'01'),(1,X'09'),(2,X'11'),(3,X'19'),               X
               *)            (USER MAY CODE VALUE DIRECTLY)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRECFM,1,A,1,              X
               (+, TRANSLATE + SUM                                     X
               (M,X'02'),(R,X'02'),(A,X'04'),(G,X'04'),(S,X'08'),      X
               (B,X'10'),(D,X'20'),(T,X'20'),(V,X'40'),(F,X'80'),      X
               (U,X'C0'),                                              X
               *)            (USER MAY CODE VALUE DIRECTLY)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRSRVF,1,A,1
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRSRVS,1,A,1
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSOWA,1,A,2,,'<=32760'
         AIF   (&CEC#KEYDONE).ADVI09
.* STACKER SELECTION
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSTACK,1,A,1,              X
               ((1,1),(2,2))            ONLY  1  OR  2  IS VALID       X
                        NO '*' IN &POS9 -- ALL OTHERS HAVE '*' CODED   X
                        AS LAST ENTRY IN &POS9.
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALTHRSH,1,A,1,,'<=100'
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALTRTCH,1,A,1,              X
               ((C,X'13'),(E,X'23'),(ET,X'2B'),(T,X'3B'),              X
               *)            (USER MAY CODE VALUE DIRECTLY)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALIPLTX,1,C,(1,8)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDIAGN,0
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFUNC,1,A,1,               X
               ((W,X'10'),(WT,X'12'),(WX,X'14'),(WXT,X'16'),           X
               (P,X'20'),(PW,X'30'),(PWX,X'34'),(PWXT,X'36'),          X
               (R,X'40'),(RW,X'50'),(RWT,X'52'),(RWX,X'54'),           X
               (RWXT,X'56'),(RP,X'60'),(RPD,X'68'),(RPW,X'70'),        X
               (RPWX,X'74'),(RPWXT,X'76'),(RPWD,X'78'),(I,X'80'),      X
               *)            (USER MAY CODE VALUE DIRECTLY)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFRID,1,C,(1,4)
         AIF   (&CEC#KEYDONE).ADVI09
.* NON-JCL DYNAMIC ALLOCATION FUNCTIONS                               -
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPASSW,1,C,(1,8)
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPERMA,0
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCNVRT,0
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRTDDN,1,C,8,*
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRTDSN,1,C,44,*
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRTORG,1,X,2,*
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSSREQ,(0,1),C,(1,4)
         AIF   (&CEC#KEYDONE).ADVI09
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRTVOL,1,C,6,*
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSSATT,1,X,1,              X
               ((*,X'80'))                          CONSTANT X'80'
         AIF   (&CEC#KEYDONE).ADVI09
.AL#DONE ANOP  ,
.* DYNAMIC UNALLOCATION TEXT UNITS                                    -
         AIF   ('&VERB' NE 'UN').UN#DONE
.*
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNDDNAM,1,C,(1,8)
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNDSNAM,1,C,(1,44)
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNMEMBR,1,C,(1,8)
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVDSP,1,A,1,              X
               ((UNCATLG,X'01'),(CATLG,X'02'),                         X
               (DELETE,X'04'),(KEEP,X'08'),                            X
               *)            (USER MAY CODE VALUE DIRECTLY)
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNUNALC,0
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNREMOV,0
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVSNH,0
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVCLS,1,C,1
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVSUS,1,C,(1,8)
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVSHQ,0
         AIF   (&CEC#KEYDONE).ADVI09
.UN#DONE ANOP  ,
.* DYNAMIC CONCATENATION TEXT UNITS                                   -
         AIF   ('&VERB' NE 'CC').CC#DONE
.*
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DCCDDNAM,(2,16),C,(1,8)
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DCCPERMC,0
         AIF   (&CEC#KEYDONE).ADVI09
.CC#DONE ANOP  ,
.* DYNAMIC DECONCATENATION TEXT UNIT                                  -
         AIF   ('&VERB' NE 'DC').DC#DONE
.*
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DDCDDNAM,1,C,(1,8)
         AIF   (&CEC#KEYDONE).ADVI09
.DC#DONE ANOP  ,
.* TEXT UNITS FOR REMOVING THE IN-USE ATTRIBUTE BASED ON TASK-ID      -
         AIF   ('&VERB' NE 'RI').RI#DONE
.*
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DRITCBAD,1,A,4
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DRICURNT,0
         AIF   (&CEC#KEYDONE).ADVI09
.RI#DONE ANOP  ,
.* DDNAME ALLOCATION TEXT UNITS                                       -
         AIF   ('&VERB' NE 'DN').DN#DONE
.*
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DDNDDNAM,1,C,(1,8)
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DDNRTDUM,1,X,1,*
         AIF   (&CEC#KEYDONE).ADVI09
.DN#DONE ANOP  ,
.* DYNAMIC INFORMATION RETRIEVAL TEXT UNITS                           -
         AIF   ('&VERB' NE 'IN').IN#DONE
.*
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINDDNAM,1,C,(1,8)
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINDSNAM,1,C,(1,44)
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTDDN,1,C,8,*
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTDSN,1,C,44,*
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTMEM,1,C,8,*
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTSTA,1,X,1,*
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTNDP,1,X,1,*
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTCDP,1,X,1,*
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTORG,1,X,2,*
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTLIM,1,X,2,*
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTATT,1,X,1,*
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTLST,1,X,1,*
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTTYP,1,X,1,*
         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRELNO,1,X,2,*
         AIF   (&CEC#KEYDONE).ADVI09
.IN#DONE ANOP  ,
.*                                                                    -
.* TO GET HERE, 1 OF 3:   1. USER KEYED INVALID TEXT KEY NAME
.*                        2. ERROR IN THIS MACRO
.*                        3. IBM DEFINED A KEY NOT KNOWN TO THIS MACRO
&LCLC    SETC  'TEXT UNIT KEY ''''&KEY'''' NOT KNOWN TO THIS MACRO--'
&LCLC    SETC  '&LCLC.TEXT UNIT KEY SPELLED WRONG, OR ERROR IN CECDYN'
         MNOTE 12,'&LCLC'
.*
.* BOTTOM OF HUGE LOOP
.ADVI09  ANOP  , ADVANCE &I
&I       SETA  &I+1
         AIF   (&I LE N'&TEXT).NEXTI09
.*                                                                    1
         AIF   (NOT &CEC#FLAG(1) AND NOT &CEC#FLAG(2)).NOEQU4
         SPACE 1
         DS    0D                  FILL OUT DATA SECTION
         SPACE 1
&LCLC    SETC  '&CEC#P.&CEC#3CH'
&LCLC.A  EQU   *-&CEC#P.ORG        CALCULATE THE HEX LENGTH
         ORG   &CEC#P.ORG
&LCLC2   SETC  '&CEC#P.DSECT'
&LCLC2   DS    CL(&LCLC.A)         NOW L'&CEC#P.DSECT AVAILABLE
         SPACE 1
*...+....1....+....2....+....3....+....4....+....5....+....6....+....7
         AIF   (NOT &CEC#FLAG(2)).NOEQU4
         SPACE 1
&SYSECT. CSECT , RETURN TO CODE
         AIF   ('&SYSLOC' EQ '&SYSECT').NOEQU4  SKIP IF UNNECESSARY
&SYSLOC. LOCTR , RETURN TO ORIGINAL LOCATION COUNTER
.NOEQU4  ANOP  ,
.*
.COMEXIT ANOP  ,
.*
.* ACTUAL CODE GENERATION:                                            -
&LCLA    SETA  &CEC#FLAG(5)  FETCH RETURN INDEX
         AGO   (&LCLA).COMMON1,.COMMON2,.COMMON3,.COMMON4,.COMMON5
.***************************
.* THE EFFECT OF THE ABOVE CODE IS:
.*       AGO   .COMMON&CEC#FLAG(5)
.***************************
         MNOTE 16,'SEVERE INTERNAL ERROR'
         MNOTE 'CEC#FLAG(5)=&CEC#FLAG(5)'
&CEC#DEBUG SETB 1      TURN ON
         AGO   .MEXIT
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71
.SUBROUT ANOP  ,                                                      0
.*
         AIF   ('&POS1' EQ 'CMT2').CMT2
         AIF   ('&POS1' EQ 'CREAT').CREAT
         AIF   ('&POS1' EQ 'DEBUG').DEBUG
         AIF   ('&POS1' EQ 'DOKEY').DOKEY
         AIF   ('&POS1' EQ 'MNOTE').MNOTE
&LCLC    SETC  'CECDYN -- INVALID INTERNAL CALL, "&POS1"'
         AGO   .ERRMAIN
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7-
.SUBEXIT MEXIT ,             USE THIS EXIT FROM SUBROUTINES           0
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7-
.CMT2    ANOP  , SELF-CALL INTERNAL ROUTINE -- SET &CEC#CMT2VAL       0
&CEC#CMT2VAL SETC '&POS2'
         AGO   .SUBEXIT
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7-
.CREAT   ANOP  , SELF-CALL INTERNAL ROUTINE -- CREATE LINE(S) OF CODE 0
         CECDYN DEBUG,.CREAT SAVE HEADING FOR DEBUG MESSAGES
         CECDYN DEBUG,'&NAME CECDYN CREAT,&POS2,&POS3,&POS4,&POS5,"',  X
               &POS6,'"'
.* IF &CEC#FLAG(1), GENERATE "DEFINE CONSTANT" FOR ALL OPERANDS,
.*        WITH VALUES SPECIFIED BY USER,
.*        AND VALUES OF 0 FOR OPERANDS SPECIFIED THROUGH REGISTERS
.* IF &CEC#FLAG(2), GENERATE "DEFINE STORAGE" FOR ALL OPERANDS,
.*        WITH VALUES OF 0 FOR ALL OPERANDS
.* IF &CEC#FLAG(3), THEN MOVE ONLY OPERANDS WHICH CANNOT BE GENERATED
.*        IN DEFINE CONSTANTS (REGISTER OPERANDS, AND SYMBOLIC
.*        OPERANDS FOR CONSTANTS OF TYPES WHICH REQUIRE QUOTES)
.* IF &CEC#FLAG(4), THEN MOVE OTHER OPERANDS (LITERALS, ACONS, NULLS)
.*
.* FORMAT OF .CREAT SELF-CALLS IS:
.*       CECDYN CREAT,<DUP>,<TYP>,<LGH>,<VAL>,<COMMENT>
.* ( DUPLICATION FACTOR, FIELD TYPE, LENGTH, NOMINAL VALUE, TEXT )
.* OPTIONAL <DUP> IS SELF-DEFINING DECIMAL TERM (WHEN NULL, ASSUME 1)
.*                        (WHEN 0, THEN INTERNALLY FORCE &CEC#FLAG(1)
.*                        TO ACT LIKE &CEC#FLAG(2)
.* OPTIONAL <TYP> IS A SINGLE CHARACTER (ASSEMBLER TYPE ATTRIBUTE T' )
.*                        H=HALFWORD, F=FULLWORD, A=ADDRESS CONSTANT,
.*                        B=BINARY, C=CHARACTER, X=HEX, <NULL>='EQU *'
.* OPTIONAL <LGH>IS SELF-DEFINING DECIMAL TERM
.*                        (WHEN NULL, ASSUME 2 FOR HALFWORD,
.*                        4 FOR FULLWORD OR ADDRESS CONSTANT, ELSE 0)
.*          <VAL> VALUE IS ONLY USED WHEN &CEC#FLAG(1)  (THAT IS,
.*                        WHEN GENERATING "DEFINE CONSTANT"S).
.*                        IT IS REQUIRED WHEN <DUP> NOT 0
.* OPTIONAL <COMMENT> IS TEXT OF COMMENT TO BE GENERATED
.*
.*..+....1....+....2....+....3
.*
&DUP     SETC '&POS2'
&TYP     SETC '&POS3'
&LGH     SETC '&POS4'
&VAL     SETC '&POS5'
&CMT     SETC '&POS6'
.*
.* &DUP AND &LGH ARE THE PARAMETERS SPECIFIED ON THE .CREAT SELF-CALL
.* &DV AND &LV ARE LCLA (NUMERIC) VALUES USED IN INTERNAL PROCESSING
.* &DX AND &LX ARE LCLC (CHARACTER) VALUES USED IN GENERATING CODE
.*
.* &NUL,&LIT,&REG,&ACN ARE LCLB (FLAGS) DESCRIBE THE &VAL SPECIFIED
.* &VV IS THE NOMINAL VALUE (WITHOUT QUOTES, PARENS, A(, ) )
.*..+....1....+....2....+....3                                        0
.*
.* ANALYSE DUPLICATION FACTOR:
.* &DUP=''        PRODUCES &DV=1,         &DX=''
.* &DUP=0         PRODUCES &DV=0,         &DX='0'
.* &DUP=1         PRODUCES &DV=1,         &DX=''
.* &DUP=<NUMERIC> PRODUCES &DV=<NUMERIC>, &DX='<NUMERIC>'.
&DV      SETA  1             SET INITIAL DEFAULTS
&DX      SETC  ''            SET INITIAL DEFAULTS
         AIF   (K'&DUP EQ 0).XDUP
&DV      SETA  &DUP          MUST BE SELF-DEFINING DECIMAL TERM
         AIF   ('&DUP' EQ '1').XDUP   LEAVE &DX AS ''
&DX      SETC  '&DUP'
.XDUP    ANOP  ,
.*..+....1....+....2....+....3                                        0
.*
.* ANALYSE LENGTH:
.* &LGH=''        PRODUCES &LV=DEFAULT,   &LX=''
.*                            (DEFAULT DEPENDS ON DATA TYPE)
.*                        (WHEN NULL, ASSUME 2 FOR HALFWORD,
.*                        4 FOR FULLWORD OR ADDRESS CONSTANT, ELSE 0)
.* &LGH=<NUMERIC> PRODUCES &LV=<NUMERIC>, &LX='L<NUMERIC>'
&HIBIT   SETB  0
&LX      SETC  ''            SET INITIAL DEFAULTS
&LCLC    SETC  'HFA'
&LCLC2   SETC  '2440'  EXTRA CHARACTER GIVES DEFAULT '0' FOR NON-H,F,A
.* H,2; F,4; A,4; OTHER,0.
&I       SETA  1
.NEXTI08 ANOP  ,
         AIF   ('&LCLC'(&I,1) EQ '&TYP').EXITI08
.ADVI08  ANOP  , ADVANCE &I
&I       SETA  &I+1
         AIF   (&I LE K'&LCLC).NEXTI08
.EXITI08 ANOP  ,
&LCLC    SETC  '&LCLC2'(&I,1)          FETCH CHARACTER FROM 2ND ARRAY
&LV      SETA  &LCLC                      AND CHANGE TO NUMERIC
         AIF   (K'&LGH EQ 0).NOLGH             USE DEFAULT LENGTH
&HIBIT   SETB  ('&LGH'(K'&LGH,1) EQ '*')  SET BY '*', OR '4*', ETC.
         AIF   (K'&LGH EQ 1 AND &HIBIT).NOLGH  USE DEFAULT LENGTH
&LCLC    SETC  '&LGH'(1,K'&LGH-&HIBIT) TRIM POSSIBLE '*' (K'&LGH GE 2)
&LV      SETA  &LCLC         MUST BE SELF-DEFINING DECIMAL TERM
&LX      SETC  'L&LV'
.NOLGH   ANOP  ,
         AIF   (&LV NE 0).XLGH
&LV      SETA  K'&VAL
         AIF   (&LV EQ 0).XLGH
&LX      SETC  'L&LV'
.XLGH    ANOP  ,
.*..+....1....+....2....+....3                                        0
.*
.* ANALYSE NOMINAL VALUE:
.* &VAL=''        PRODUCES &NUL=1, &VV=DEFAULT
.*                                    (DEFAULT DEPENDS ON DATA TYPE)
.* &VAL='...'     PRODUCES &LIT=1, &VV=...   (WITHOUT QUOTES)
.* &VAL=(...)     PRODUCES &REG=1, &VV=...   (WITHOUT PARENS)
.* &VAL=A(...)    PRODUCES &ACN=1, &VV=...   (WITHOUT A(, ) )
.* &VAL=<OTHER>   PRODUCES &NUL=&LIT=&REG=&ACN=0, &SYMBOL=1,
.*                                 &VV=&VAL
&LIT     SETB  0             LITERAL
&REG     SETB  0             REGISTER
&ACN     SETB  0             ADDRESS CONSTANT
&NUL     SETB  1             NULL -- OMITTED
&LCLC    SETC  'C'
&LCLC2   SETC  ' 0'     EXTRA CHARACTER GIVES DEFAULT '0' FOR NON-C
.* C,' '; OTHER,0.
&I       SETA  1
.NEXTI05 ANOP  ,
         AIF   ('&LCLC'(&I,1) EQ '&TYP').EXITI05
.ADVI05  ANOP  , ADVANCE &I
&I       SETA  &I+1
         AIF   (&I LE K'&LCLC).NEXTI05
.EXITI05 ANOP  ,
&VV      SETC  '&LCLC2'(&I,1)          FETCH CHARACTER FROM 2ND ARRAY
&DFLTVV  SETC  '&VV'                   SAVE FOR LATER, ' ' OR '0'
         AIF   (K'&VAL EQ 0).ZVAL                .* IF NULL SKIP
         AIF   ('&VAL' EQ '').ZVAL               .* IF NULL SKIP
&NUL     SETB  0                               .* RESET NULL IF NOT
         AIF   (K'&VAL LT 3).XVAL      TOO SHORT TO BE ANYTHING
&VV      SETC  '&VAL'(2,K'&VAL-2)      REMOVE QUOTES/PARENS
&LIT     SETB  ('&VAL'(1,1) EQ '''' AND '&VAL'(K'&VAL,1) EQ '''')
         AIF   (&LIT).ZVAL
&REG     SETB  ('&VAL'(1,1) EQ '(' AND '&VAL'(K'&VAL,1) EQ ')')
         AIF   (&REG).ZVAL
         AIF   (K'&VAL LT 4).XVAL      TOO SHORT TO BE ACN
&ACN     SETB  ('&VAL'(1,2) EQ 'A(' AND '&VAL'(K'&VAL,1) EQ ')')
&VV      SETC  '&VAL'(3,K'&VAL-3)      REMOVE A(, )
         AIF   (&ACN).ZVAL
.XVAL    ANOP  ,
&VV      SETC  '&VAL'
.ZVAL    ANOP  ,
.*..+....1....+....2....+....3                                        0
.*
&SYMBOL  SETB  (NOT &NUL AND NOT &LIT AND NOT &REG AND NOT &ACN)
.*                     (SOMETHING, BUT NONE OF THE ABOVE)
&MUSTMOV SETB  0             PREP IT TO 0
         AIF   (&REG).MM1    IF &REG, CANNOT BE DC.-D
         AIF   (&NUL).MMXX              NULL VALUE CAN ALWAYS BE DC.-D
         AIF   (&LIT AND ('&TYP' EQ 'C')).MMXX   LITERALS CAN BE DC.-D
         AIF   (NOT &LIT AND ('&TYP' EQ 'C')).MM1   OTHERS CANNOT
         AIF   ('&TYP' EQ 'A').MMXX       WITHOUT QUOTES, CAN BE DC.-D
         AGO   .MMXX
.MM1     ANOP  ,
&MUSTMOV SETB  1             CHANGE IT TO 1
.MMXX    ANOP  ,
.*    &MUSTMOV IS A FLAG THAT SAYS SOME CODE IS NEEDED FOR A FIELD,
.*  THAT IT CANNOT BE JUST ASSEMBLED INTO A DC. (AS IN MF=L)
         CECDYN DEBUG,'VAL="',&VV.,                                    X
               '", NUL=&NUL., LIT=&LIT., REG=&REG., ACN=&ACN.',        X
               ', SYMBOL=&SYMBOL., MUSTMOV=&MUSTMOV..'
.*..+....1....+....2....+....3                                        0
.*
.* PROCESS COMMENT FIELD:
         AIF   (K'&CMT EQ 0).NOQUOT1
         AIF   ('&CMT'(1,1) NE '''').NOQUOT1
         AIF   ('&CMT'(K'&CMT,1) NE '''').NOQUOT1
&CMT     SETC  '&CMT'(2,K'&CMT-2)     REMOVE QUOTES
.NOQUOT1 ANOP  ,
.*..+....1....+....2....+....3                                        0
.*
         AIF   (NOT &CEC#DEBUG).XDEBUG3
         CECDYN DEBUG,'NAME=&NAME DUP=&DUP TYP=&TYP LGH=&LGH VAL="',   X
               &VV,'"'
         CECDYN MNOTE,'        POS6=&CMT, POS7=&POS7..'
         CECDYN MNOTE,'        DV=&DV DX="&DX"  LV=&LV LX="&LX"'
         CECDYN MNOTE,'   VAL: NUL=&NUL, LIT=&LIT, REG=&REG, ACN=&ACN'
&LCLA    SETA  N'&LGH
         CECDYN MNOTE,'        N''LGH=&LCLA, HIBIT=&HIBIT'
.XDEBUG3 ANOP  ,
.*..+....1....+....2....+....3                                        0
.*
&GENRETI SETA  1        DEFAULT RETURN FROM .GENCOM:  .CR#EXIT
.*
         AIF   (&CEC#FLAG(1)).G#DCDS   GENERATE DC/DS
         AIF   (&CEC#FLAG(2)).G#DCDS   GENERATE DC/DS
         AIF   (&DV EQ 0).CR#EXIT      DUPLICATION FACTOR ZERO--EXIT!
         AIF   (&CEC#FLAG(3)).G#MOVE   GENERATE MOVES
         AIF   (&CEC#FLAG(4)).G#MOVE   GENERATE MOVES
&LCLC    SETC  'INTERNAL ERROR IN .CREAT SUBROUTINE, SYSNDX=&SYSNDX '
&LCLC    SETC  '&LCLC'.'FLAGS=&CEC#FLAG(1),&CEC#FLAG(2),'
&LCLC    SETC  '&LCLC'.'&CEC#FLAG(3),&CEC#FLAG(4)..'
         MNOTE 16,'&LCLC'
&CEC#DEBUG SETB 1      TURN ON
         MHELP 1+2+4+8+16+32+64
         AGO   .CR#EXIT
.*..+....1....+....2....+....3....+....4                              0
.*
.G#DCDS  ANOP  ,             GENERATE DC OR DS
&LBL     SETC  '&NAME'
         AIF   (&LV EQ 0 AND &DV EQ 0 AND '&TYP' EQ '').G#EQU INSTEAD
.*..+....1
         AIF   (NOT &MUSTMOV).LEAVEVV
&VV      SETC  '&DFLTVV'               SAVED DEFAULT
         CECDYN DEBUG,'VAL="',&VV.,                                    X
               '", NUL=&NUL., LIT=&LIT., REG=&REG., ACN=&ACN.',        X
               ', SYMBOL=&SYMBOL., MUSTMOV=&MUSTMOV., VV=&VV..'
.LEAVEVV ANOP  , DON'T SET BACK TO DEFAULT
.*..+....1
         AIF   (&CEC#FLAG(1) AND &DV EQ 0).FLAG2A GENERATE DS, NOT DC
         AIF   (&CEC#FLAG(1)).FLAG1A
         AIF   (&CEC#FLAG(2)).FLAG2A
.*..+....1
.FLAG1A  ANOP  ,
&OPR     SETC  'DC'
&OPD     SETC  '&DX&TYP&LX'.'(&VV)'    A(<VALUE>)
         AIF   ('&TYP' EQ 'A').FLAG1B
&OPD     SETC  '&DX&TYP&LX'.'''&VV'''  C'<VALUE>' OR F'<VALUE>' OR X..
         AGO   .FLAG1X                 DONE SETTING UP
.FLAG1B  ANOP  ,
         AIF   (NOT &HIBIT).FLAG1X     NOTHING SPECIAL TO DO
         AIF   (&ACN).FLAG1C           OK, SKIP ERROR MESSAGE
         MNOTE 12,'INTERNAL ERROR, HIBIT ONLY VALID FOR ADCON.S'
&CEC#DEBUG SETB 1      TURN ON
.FLAG1C  ANOP  ,
&OPD     SETC  '&DX&TYP&LX'.'(&VV+X''80000000'')'  SET HIGH BIT ON
.FLAG1X  AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.*..+....1
.FLAG2A  ANOP  ,
&OPR     SETC  'DS'
&OPD     SETC  '&DX&TYP&LX'
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.*..+....1
.G#EQU   ANOP  ,
&OPR     SETC  'EQU'
&OPD     SETC  '*'
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.*..+....1....+....2....+....3....+....4                              0
.*
.G#MOVE  CECDYN DEBUG,.G#MOVE         GENERATE MOVES
&LBL     SETC  ''
&LCLC    SETC  'SYMBOL=&SYMBOL., MUSTMOV=&MUSTMOV.'
&LCLC    SETC  '&LCLC., FLAG(3)=&CEC#FLAG(3)., FLAG(4)=&CEC#FLAG(4).'
         CECDYN DEBUG,'&LCLC'
&LCLB    SETB                (     &MUSTMOV   AND (NOT &CEC#FLAG(3) ))
&LCLC    SETC        '&LCLB.=(     &MUSTMOV.  AND (NOT &CEC#FLAG(3)))'
         CECDYN DEBUG,'&LCLC.=(     MUSTMOV   AND (NOT  FLAG(3) ))'
&LCLB1   SETB                ((NOT &MUSTMOV ) AND (NOT &CEC#FLAG(4) ))
&LCLC    SETC       '&LCLB1.=((NOT &MUSTMOV.) AND (NOT &CEC#FLAG(4)))'
         CECDYN DEBUG,'&LCLC.=((NOT MUSTMOV ) AND (NOT  FLAG(4) ))'
         CECDYN DEBUG,'    IF EITHER OF ABOVE IS TRUE, THEN MEXIT'
         AIF   (&LCLB OR &LCLB1).CR#EXIT                 NOTHING TO DO
         AIF   ('&DUP' EQ '0' AND K'&CMT EQ 0).CR#EXIT   NOTHING TO DO
         AIF   ('&DUP' EQ '0').ONLYCMT  NO CODE TO BE GENERATED
         AIF   (&NUL AND                                               X
               '&TYP' EQ 'C').BLANK  TO-FIELD IS CHARACTER             X
                                        AND NO NOMINAL VALUE SPECIFIED
         AIF   (&NUL AND                                               X
               '&TYP' EQ 'F').ZERO   TO-FIELD IS A FULLWORD            X
                                        AND NO NOMINAL VALUE SPECIFIED
         AIF   (&NUL).CLEAR          NO NOMINAL VALUE SPECIFIED
         AIF   ('&VV' EQ '0').CLEAR  VALUE TO GENERATE IS 0
         AIF   ('&TYP' EQ 'C').AAACH TO-FIELD IS A CHARACTER FIELD
         AIF   ('&LV' EQ '1' AND                                       X
               ('&TYP' EQ 'A' OR '&TYP' EQ 'X' OR '&TYP' EQ 'F' OR     X
               '&TYP' EQ 'H')).AAA1N TO-FIELD IS LENGTH 1, NUMERIC
         AIF   ('&LV' EQ '2' AND                                       X
               ('&TYP' EQ 'A' OR '&TYP' EQ 'X' OR '&TYP' EQ 'F' OR     X
               '&TYP' EQ 'H')).AAA2N TO-FIELD IS LENGTH 2, NUMERIC
         AIF   ('&LV' EQ '3' AND                                       X
               ('&TYP' EQ 'A' OR '&TYP' EQ 'X' OR '&TYP' EQ 'F' OR     X
               '&TYP' EQ 'H')).AAA3N TO-FIELD IS LENGTH 3, NUMERIC
         AIF   ('&LV' EQ '4' AND                                       X
               ('&TYP' EQ 'A' OR '&TYP' EQ 'X' OR '&TYP' EQ 'F' OR     X
               '&TYP' EQ 'H')).AAA4N TO-FIELD IS LENGTH 4, NUMERIC
         MNOTE 12,'INTERNAL ERROR IN CREAT ROUTINE:'
 MNOTE '            NAME=&NAME DUP=&DUP TYP=&TYP LGH=&LGH VAL="&VV"'
 MNOTE '            POS6=&CMT..'
 MNOTE '            DV=&DV DX="&DX"  LV=&LV LX="&LX"'
 MNOTE '       VAL: NUL=&NUL, LIT=&LIT, REG=&REG, ACN=&ACN'
&CEC#DEBUG SETB 1      TURN ON
         AGO   .CR#EXIT
.*..+....1....+....2                                                  0
.*
.* (EACH 'AGO .GENCOM" WITH NO RETURN IS FOLLOWED BY DOUBLE-SPACE)
.*..+....1....+....2                                                  0
.ONLYCMT CECDYN CMT2,.ONLYCMT    DUPLICATION FACTOR ZERO--ONLY COMMENT0
&LBL     SETC  '*'
&OPR     SETC  ''
&OPD     SETC  '&NAME'
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.*..+....1....+....2                                                  0
.BLANK   CECDYN CMT2,.BLANK     NO NOMINAL VALUE FOR 'C'--BLANK-FILL  0
         AIF   (&LV LE 0 OR &LV GT 8).BLANK1   CONTINUE THINKING
.BLANK8  CECDYN CMT2,.BLANK8    USER SPECIFIED &LGH LE 8--USE LITERAL
&OPR     SETC  'MVC'
&OPD     SETC  '&NAME'.'(&LV),=CL8'' '''
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.BLANK1  CECDYN CMT2,.BLANK1    MOVE A SINGLE BLANK                   0
&OPR     SETC  'MVI'
&OPD     SETC  '&NAME,C'' '''
         AIF   (&LV EQ 1).GENCOM GO GENERATE A LINE, THEN .CR#EXIT
&GENRETI SETA  3             PREPARE RETURN POINTER
         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET3
.GENRET3 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW
&CMT     SETC  'PROPOGATE INITIAL BLANK'
         AIF   (&LV EQ 0).BLANK0
.BLANKX  CECDYN CMT2,.BLANKX USER SPECIFIED &LGH--USE IT              0
&OPR     SETC  'MVC'
&OPD     SETC  '&NAME+1(&LV-1),&NAME'
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.BLANK0  CECDYN CMT2,.BLANK0 NO &LGH--HOPE ASMBLR CAN FIGURE IT OUT   0
&OPR     SETC  'MVC'
&OPD     SETC  '&NAME+1(L''&NAME-1),&NAME'
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.*..+....1....+....2                                                  0
.ZERO    CECDYN CMT2,.ZERO      NO NOMINAL VALUE FOR 'F'--LOAD ZEROES 0
         AIF   (&LV GE 4).CLEAR LGH GREATER THAN TYPE F--USE XC
&OPR     SETC  'MVC'
&OPD     SETC  '&NAME,=F''0'''
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.*..+....1....+....2                                                  0
.CLEAR   CECDYN CMT2,.CLEAR     NO NOMINAL VALUE--CLEAR TO HEX ZEROES 0
&OPR     SETC  'MVI'
&OPD     SETC  '&NAME,0'
         AIF   (&LV EQ 1).GENCOM GO GENERATE A LINE, THEN .CR#EXIT
         AIF   (&LV EQ 0).CLEAR0
&OPR     SETC  'XC'
&OPD     SETC  '&NAME'.'(&LV),&NAME'
&GENRETI SETA  2 PREPARE RETURN POINTER--CHECK FOR HIBIT AFTERWARD
         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2
.CLEAR0  CECDYN CMT2,.CLEAR0 NO &LGH--HOPE ASMBLR CAN FIGURE IT OUT   0
&OPR     SETC  'XC'
&OPD     SETC  '&NAME,&NAME'
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.*..+....1....+....2                                                  0
.AAACH   CECDYN CMT2,.AAACH , TO-FIELD IS A CHARACTER FIELD           0
         AIF   (&REG).REGCH   TO-FIELD IS CHAR, SOURCE IS REG-FORMAT
         AIF   (&ACN).ACNCH   TO-FIELD IS CHAR, SOURCE IS ACON-FORMAT
         AIF   (&LIT).LITCH   TO-FIELD IS CHAR, SOURCE IS LITERAL
.SYMCH   ANOP  ,              TO-FIELD IS CHAR, SOURCE IS A SYMBOL    0
&OPR     SETC  'MVC'
&OPD     SETC  '&NAME,&VV' OR '&NAME,&VAL'
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.LITCH   CECDYN CMT2,.LITCH   TO-FIELD IS CHAR, SOURCE IS LITERAL     0
         AIF   (&LV EQ 1).LIT1CH TO-FIELD IS 1-CHAR, SOURCE IS LITERAL
&OPR     SETC  'MVC'
&OPD     SETC  '&NAME,=C&LX''&VV''' OR '&NAME,=C&LX&VAL'
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.LIT1CH  CECDYN CMT2,.LIT1CH  TO-FIELD IS 1-CHAR, SOURCE IS LITERAL   0
&OPR     SETC  'MVI'
&OPD     SETC  '&NAME,''&VV''' OR '&NAME,&VAL'
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.REGCH   CECDYN CMT2,.REGCH   TO-FIELD IS CHAR, SOURCE IS REG-FORMAT  0
&OPR     SETC  'MVC'
&OPD     SETC  '&NAME,0(&VV)' OR '&NAME,0&VAL'
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.ACNCH   CECDYN CMT2,.ACNCH   TO-FIELD IS CHAR, SOURCE IS ACON-FORMAT 0
&CMTSAVE SETC  '&CMT'        SAVE COMMENT
&OPR     SETC  'LA'
&OPD     SETC  '15,&VV'
&CMT     SETC  'LOAD ADDRESS OF FIELD'
&GENRETI SETA  4             PREPARE RETURN POINTER
         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET4
.GENRET4 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW
&OPR     SETC  'MVC'
&OPD     SETC  '&NAME,0(15)'
&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.*..+....1....+....2                                                  0
.AAA1N   CECDYN CMT2,.AAA1N , TO-FIELD IS LENGTH 1, NUMERIC           0
         AIF   (&REG).REG1N TO-FIELD LGH 1 NUMERIC, SOURCE REG-FORMAT
         AIF   (&ACN).ACN1N TO-FIELD LGH 1 NUMERIC, SOURCE ACON-FORMAT
         AIF   (&LIT).LIT1N TO-FIELD LGH 1 NUMERIC, SOURCE A LITERAL
.SYM1N   ANOP  ,            TO-FIELD LGH 1 NUMERIC, SOURCE A SYMBOL   0
&OPR     SETC  'MVI'
&OPD     SETC  '&NAME,&VV' OR '&NAME,&VAL'
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.LIT1N   CECDYN CMT2,.LIT1N TO-FIELD LGH 1 NUMERIC, SOURCE A LITERAL  0
&OPR     SETC  'MVI'
&OPD     SETC  '&NAME,C''&VV''' OR '&NAME,C&VAL'
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.REG1N   CECDYN CMT2,.REG1N TO-FIELD LGH 1 NUMERIC, SOURCE REG-FORMAT 0
&CMTSAVE SETC  '&CMT'        SAVE COMMENT
&OPR     SETC  'L'
&OPD     SETC  '15,0(&VV)' OR '15,0&VAL'
&CMT     SETC  'FETCH FULLWORD POINTED-TO BY REGISTER'
&GENRETI SETA  7             PREPARE RETURN POINTER
         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET7
.GENRET7 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW
&OPR     SETC  'STC'
&OPD     SETC  '15,&NAME'
&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.ACN1N   CECDYN CMT2,.ACN1N TO-FIELD LGH 1 NUMERIC, SOURCE ACON-FORMAT0
         LA    15,&VV        LOAD ADDRESS OF FIELD            .ACN1N
&OPR     SETC  'STC'
&OPD     SETC  '15,&NAME'
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.*..+....1....+....2                                                  0
.AAA2N   CECDYN CMT2,.AAA2N , TO-FIELD IS LENGTH 2, NUMERIC           0
         AIF   (&REG).REG2N TO-FIELD LGH 2 NUMERIC, SOURCE REG-FORMAT
         AIF   (&ACN).ACN2N TO-FIELD LGH 2 NUMERIC, SOURCE ACON-FORMAT
         AIF   (&LIT).LIT2N TO-FIELD LGH 2 NUMERIC, SOURCE A LITERAL
.SYM2N   ANOP  ,            TO-FIELD LGH 2 NUMERIC, SOURCE A SYMBOL   0
&OPR     SETC  'MVC'
&OPD     SETC  '&NAME,=AL2(&VV)' OR '&NAME,=AL2(&VAL)'
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.LIT2N   CECDYN CMT2,.LIT2N TO-FIELD LGH 2 NUMERIC, SOURCE A LITERAL  0
&OPR     SETC  'MVC'
&OPD     SETC  '&NAME,=AL2(C''&VV'')' OR '&NAME,=AL2(C&VAL)'
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.REG2N   CECDYN CMT2,.REG2N TO-FIELD LGH 2 NUMERIC, SOURCE REG-FORMAT 0
&CMTSAVE SETC  '&CMT'        SAVE COMMENT
&OPR     SETC  'L'
&OPD     SETC  '15,0(&VV)' OR '15,0&VAL'
&CMT     SETC  'FETCH FULLWORD POINTED-TO BY REGISTER'
&GENRETI SETA  6             PREPARE RETURN POINTER
         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET6
.GENRET6 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW
&OPR     SETC  'STH'
&OPD     SETC  '15,&NAME'    STORE HALFWORD FROM REG.
&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.ACN2N   CECDYN CMT2,.ACN2N TO-FIELD LGH 2 NUMERIC, SOURCE ACON-FORMAT0
         LA    15,&VV        LOAD ADDRESS OF FIELD            .ACN2N
&OPR     SETC  'STH'
&OPD     SETC  '15,&NAME'    STORE HALFWORD FROM REG.
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.*..+....1....+....2                                                  0
.AAA3N   CECDYN CMT2,.AAA3N , TO-FIELD IS LENGTH 3, NUMERIC           0
         AIF   (&REG).REG3N TO-FIELD LGH 3 NUMERIC, SOURCE REG-FORMAT
         AIF   (&ACN).ACN3N TO-FIELD LGH 3 NUMERIC, SOURCE ACON-FORMAT
         AIF   (&LIT).LIT3N TO-FIELD LGH 3 NUMERIC, SOURCE A LITERAL
.SYM3N   ANOP  ,            TO-FIELD LGH 3 NUMERIC, SOURCE A SYMBOL   0
&CMTSAVE SETC  '&CMT'        SAVE COMMENT
&OPR     SETC  'L'
&OPD     SETC  '15,&VV'
&CMT     SETC  'FETCH FULLWORD'
&GENRETI SETA  9             PREPARE RETURN POINTER
         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET9
.GENRET9 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW
&OPR     SETC  'STCM'
&OPD     SETC  '15,B''0111'',&NAME'
&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.LIT3N   CECDYN CMT2,.LIT3N TO-FIELD LGH 3 NUMERIC, SOURCE A LITERAL  0
         LA    15,=C'&VV'    POINT TO FULLWORD                .LIT3N
&OPR     SETC  'STCM'
&OPD     SETC  '15,B''0111'',&NAME'
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.REG3N   CECDYN CMT2,.REG3N TO-FIELD LGH 3 NUMERIC, SOURCE REG-FORMAT 0
&CMTSAVE SETC  '&CMT'        SAVE COMMENT
&OPR     SETC  'L'
&OPD     SETC  '15,0(&VV)' OR '15,0&VAL'
&CMT     SETC  'FETCH FULLWORD POINTED-TO BY REGISTER'
&GENRETI SETA  8             PREPARE RETURN POINTER
         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET8
.GENRET8 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW
&OPR     SETC  'STCM'
&OPD     SETC  '15,B''0111'',&NAME'
&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.ACN3N   CECDYN CMT2,.ACN3N TO-FIELD LGH 3 NUMERIC, SOURCE ACON-FORMAT0
         LA    15,&VV        LOAD ADDRESS OF FIELD            .ACN3N
&OPR     SETC  'STCM'
&OPD     SETC  '15,B''0111'',&NAME'
         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT
.*..+....1....+....2                                                  0
.AAA4N   CECDYN CMT2,.AAA4N , TO-FIELD IS LENGTH 4, NUMERIC           0
&GENRETI SETA  2 PREPARE RETURN POINTER--CHECK FOR HIBIT AFTERWARD
         AIF   (&REG).REG4N TO-FIELD LGH 4 NUMERIC, SOURCE REG-FORMAT
         AIF   (&ACN).ACN4N TO-FIELD LGH 4 NUMERIC, SOURCE ACON-FORMAT
         AIF   (&LIT).LIT4N TO-FIELD LGH 4 NUMERIC, SOURCE A LITERAL
.SYM4N   ANOP  ,            TO-FIELD LGH 4 NUMERIC, SOURCE A SYMBOL   0
&OPR     SETC  'MVC'
&OPD     SETC  '&NAME'.'(4),&VV' OR '&NAME'.'(4),&VAL'
         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2
.LIT4N   CECDYN CMT2,.LIT4N TO-FIELD LGH 4 NUMERIC, SOURCE A LITERAL  0
         LA    15,=C'&VV'       FETCH WORD                    .LIT4N
&OPR     SETC  'ST'
&OPD     SETC  '15,&NAME'
         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2
.REG4N   CECDYN CMT2,.REG4N TO-FIELD LGH 4 NUMERIC, SOURCE REG-FORMAT 0
&OPR     SETC  'MVC'
&OPD     SETC  '&NAME,0(&VV)' OR '&NAME,0&VAL'
         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2
.ACN4N   CECDYN CMT2,.ACN4N TO-FIELD LGH 4 NUMERIC, SOURCE ACON-FORMAT0
&CMTSAVE SETC  '&CMT'        SAVE COMMENT
&OPR     SETC  'LA'
&OPD     SETC  '15,&VV'
&CMT     SETC  'LOAD ADDRESS OF FIELD'
&GENRETI SETA  5             PREPARE RETURN POINTER
         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET5
.GENRET5 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW
&OPR     SETC  'ST'
&OPD     SETC  '15,&NAME'
&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT
&GENRETI SETA  2 PREPARE RETURN POINTER--CHECK FOR HIBIT AFTERWARD
         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2
.*
.GENRET2 AIF   (NOT &HIBIT).CR#EXIT    NOTHING SPECIAL TO DO          0
         OI    &NAME,X'80'      TURN ON HIGH BIT              .GENRET2
         AGO   .CR#EXIT
.*..+....1....+....2....+....3....+....4                              1
.GENCOM  ANOP , GENERATE A STMT, W/ COMMENT FIELD AND W/ &CEC#CMT2VAL 0
.* THIS IS AN AGO-TYPE INTERNAL ROUTINE --
.* IT EXITS WITH THE STATEMENT:            AGO .GENRET&GENRETI
.*
.* INPUTS: LOCAL SETC VARIABLES: &LBL          LABEL
.*                               &OPR          OPERATOR
.*                               &OPD          OPERAND
.*                               &CMT          COMMENT
.*         GLOBAL SETC VARIABLE: &CEC#CMT2VAL  SECONDARY COMMENT
.* OUTPUT: STATEMENT/MNOTE: &LBL     &OPR  &OPD&CMT&CEC#CMT2VAL
.*         WITH COLUMNS:   '....+....1....+..  .   .
.*         (&LBL IN COLUMN 1,
.*          &OPR IN COLUMN 10 IF POSSIBLE, ELSE SHIFTED,
.*          &OPD IN COLUMN 16 IF POSSIBLE, ELSE SHIFTED,
.*          &CMT IN COLUMN &CECCMT1COL (ON A CONT'N IF NECESSARY),
.*  &CEC#CMT2VAL IN COLUMN &CECCMT2COL (ON A CONT'N IF NECESSARY).)
.*..+....1....+....2....+....3                                        0
.*
.* TRIM ALL BLANKS FROM RIGHT-HAND END OF &LBL
         AIF   (K'&LBL EQ 0).OKLBL     LENGTH ZERO--NO TRIM NECESSARY
.TRIMLBL AIF   ('&LBL'(K'&LBL,1) NE ' ').OKLBL  Q. LAST CHAR A BLANK?
.* A. YES, LAST CHARACTER IS A BLANK
         AIF   (K'&LBL EQ 1).ZZLBL     LENGTH ONE--NO PAD NECESSARY
&LBL     SETC  '&LBL'(1,K'&LBL-1)      A. YES--TRIM LAST CHARACTER AND
         AGO   .TRIMLBL                    GO BACK AND CHECK SOME MORE
.OKLBL   ANOP  ,                       A. NO--NO MORE TRIM NECESSARY
.*
&LBL     SETC  '&LBL. '                ADD EXACTLY 1 BLANK
.ZZLBL   ANOP  ,
.*
.* CALCULATE HOW MUCH ROOM WE HAVE TO WORK WITH:
&LCLA    SETA  10-1          COLUMNS 1 THROUGH JUST-BEFORE 10
.*
         AIF   (&LCLA LE K'&LBL).PADLBLZ NO PAD NECESSARY
&LBL     SETC  '&LBL'.(&LCLA-K'&LBL)' ' PAD TO LENGTH NECESSARY
.PADLBLZ ANOP  ,
.*..+....1....+....2....+....3                                        0
.*
.* TRIM ALL BLANKS FROM RIGHT-HAND END OF &OPR
         AIF   (K'&OPR EQ 0).OKOPR     LENGTH ZERO--NO TRIM NECESSARY
.TRIMOPR AIF   ('&OPR'(K'&OPR,1) NE ' ').OKOPR  Q. LAST CHAR A BLANK?
.* A. YES, LAST CHARACTER IS A BLANK
         AIF   (K'&OPR EQ 1).ZZOPR     LENGTH ONE--NO PAD NECESSARY
&OPR     SETC  '&OPR'(1,K'&OPR-1)      A. YES--TRIM LAST CHARACTER AND
         AGO   .TRIMOPR                    GO BACK AND CHECK SOME MORE
.OKOPR   ANOP  ,                       A. NO--NO MORE TRIM NECESSARY
.*
&OPR     SETC  '&OPR. '                ADD EXACTLY 1 BLANK
.ZZOPR   ANOP  ,
.*
.* CALCULATE HOW MUCH ROOM WE HAVE TO WORK WITH:
&LCLA    SETA  16-10         COLUMNS 10 THROUGH JUST-BEFORE 16
.*
         AIF   (&LCLA LE K'&OPR).PADOPRZ NO PAD NECESSARY
&OPR     SETC  '&OPR'.(&LCLA-K'&OPR)' ' PAD TO LENGTH NECESSARY
.PADOPRZ ANOP  ,
.*..+....1....+....2....+....3                                        0
.*
.* TRIM ALL BLANKS FROM RIGHT-HAND END OF &OPD
         AIF   (K'&OPD EQ 0).OKOPD     LENGTH ZERO--NO TRIM NECESSARY
.TRIMOPD AIF   ('&OPD'(K'&OPD,1) NE ' ').OKOPD  Q. LAST CHAR A BLANK?
.* A. YES, LAST CHARACTER IS A BLANK
         AIF   (K'&OPD EQ 1).ZZOPD     LENGTH ONE--NO PAD NECESSARY
&OPD     SETC  '&OPD'(1,K'&OPD-1)      A. YES--TRIM LAST CHARACTER AND
         AGO   .TRIMOPD                    GO BACK AND CHECK SOME MORE
.OKOPD   ANOP  ,                       A. NO--NO MORE TRIM NECESSARY
.*
&OPD     SETC  '&OPD. '                ADD EXACTLY 1 BLANK
.ZZOPD   ANOP  ,
.*
.* CALCULATE HOW MUCH ROOM WE HAVE TO WORK WITH:
&LCLA    SETA  &CECCMT1COL-16
.*
.PADOPDL ANOP  ,                       ADDITIONAL LINE
         AIF   (K'&OPD LE &LCLA).PADOPDY                               X
                                       Q. &OPD SHORT ENOUGH TO FIT?
&LCLA    SETA  &LCLA+56                 A. NO--USE AN ADDITIONAL LINE
.* NOTE--EACH CONTINUATION LINE GIVES 56 MORE CHARACTERS (COLS 16-71)
         AGO   .PADOPDL
.PADOPDY ANOP  ,                        A. YES--IT WILL FIT
.*
         AIF   (&LCLA LE K'&OPD).PADOPDZ NO PAD NECESSARY
&OPD     SETC  '&OPD'.(&LCLA-K'&OPD)' ' PAD TO LENGTH NECESSARY
.PADOPDZ ANOP  ,
.*..+....1....+....2....+....3                                        0
.*
.* TRIM ALL BLANKS FROM RIGHT-HAND END OF &CMT
         AIF   (K'&CMT EQ 0).OKCMT     LENGTH ZERO--NO TRIM NECESSARY
.TRIMCMT AIF   ('&CMT'(K'&CMT,1) NE ' ').OKCMT  Q. LAST CHAR A BLANK?
         AIF   (K'&CMT EQ 1).ZZCMT     LENGTH ONE--NO PAD NECESSARY
&CMT     SETC  '&CMT'(1,K'&CMT-1)      A. YES--TRIM LAST CHARACTER AND
         AGO   .TRIMCMT                    GO BACK AND CHECK SOME MORE
.OKCMT   ANOP  ,                       A. NO--NO MORE TRIM NECESSARY
.*
&CMT     SETC  '&CMT. '                ADD EXACTLY 1 BLANK
.ZZCMT   ANOP  ,
.*
.* CALCULATE HOW MUCH ROOM WE HAVE TO WORK WITH:
&LCLA    SETA  &CECCMT2COL-&CECCMT1COL
.*
.PADCMTL ANOP  ,                       ADDITIONAL LINE
         AIF   (K'&CMT LE &LCLA).PADCMTY Q. &CMT SHORT ENOUGH TO FIT?
&LCLA    SETA  &LCLA+56                  A. NO--USE AN ADDITIONAL LINE
.* NOTE--EACH CONTINUATION LINE GIVES 56 MORE CHARACTERS (COLS 16-71)
         AGO   .PADCMTL
.PADCMTY ANOP  ,                        A. YES--IT WILL FIT
.*
         AIF   (&LCLA LE K'&CMT).PADCMTZ NO PAD NECESSARY
&CMT     SETC  '&CMT'.(&LCLA-K'&CMT)' ' PAD TO LENGTH NECESSARY
.PADCMTZ ANOP  ,
.*..+....1....+....2....+....3                                        0
.*
         AIF   ('&LBL'(1,1) EQ '*').DOMNOTE
&LCLAX(1) SETA K'&LBL,K'&OPR,K'&OPD,K'&CMT
         CECDYN DEBUG,' CECDYN *2',                                    X
               ' LBL=&LCLAX(1),"&LBL"',                                X
               ' OPR=&LCLAX(2),"&OPR"',                                X
               ' OPD=&LCLAX(3),"&OPD"',                                X
               ' CMT=&LCLAX(4),"&CMT"',                                X
               ' CMT1COL=&CECCMT1COL, CMT2COL=&CECCMT2COL',            X
               ' CEC#CMT1COL=&CEC#CMT1COL, CEC#CMT2COL=&CEC#CMT2COL'
.*
.* THIS IS THE MAIN PURPOSE OF ROUTINE .GENCOM:
&LBL     &OPR  &OPD&CMT&CEC#CMT2VAL
.* THAT WAS THE MAIN PURPOSE OF ROUTINE .GENCOM--YOU ALMOST MISSED IT.
.*
         AGO   .DONEIT
.*..+....1....+....2                                                  0
.*
.DOMNOTE ANOP  ,
.*
         MNOTE '&LBL&OPR&OPD&CMT&CEC#CMT2VAL'
.*
         AGO   .DONEIT
.*..+....1                                                            0
.*
.DONEIT  ANOP  ,
.*
&LCLA    SETA  &GENRETI      FETCH RETURN INDEX
&GENRETI SETA  1             RETURN POINTER TO DEFAULT, FOR NEXT TIME
.* ACTUAL CODE GENERATION:                                            -
         AGO   (&LCLA).GENRET1,.GENRET2,.GENRET3,.GENRET4,.GENRET5,    X
               .GENRET6,.GENRET7,.GENRET8,.GENRET9
.***************************
.* THE EFFECT OF THE ABOVE CODE IS:
.*       AGO   .GENRET&LCLA
.***************************
         MNOTE 16,'SEVERE INTERNAL ERROR'
         MNOTE 'GENRETI=&LCLA'
&CEC#DEBUG SETB 1      TURN ON
         AGO   .CR#EXIT
.*..+....1                                                            0
.*
.GENRET1 AGO   .CR#EXIT , DEFAULT EXIT
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70
.*
.CR#EXIT ANOP  ,
&CECCMT1COL SETA &CEC#CMT1COL COMMENT 1 FIELD'S COLUMN
&CECCMT2COL SETA &CEC#CMT2COL COMMENT 2 FIELD'S COLUMN
         AGO   .SUBEXIT , EXIT FROM .CREAT
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71
.DEBUG   ANOP  , SELF-CALL INTERNAL ROUTINE -- DISPLAY DEBUG MNOTES   0
.*
.* IF NO PARAMETERS BESIDES FIRST, TURN ON DEBUGGING AND .SUBEXIT
         AIF   (N'&SYSLIST NE 1).NORMALDBG
&CEC#DEBUG SETB 1      TURN ON
         AGO   .SUBEXIT
.NORMALDBG ANOP  ,
.*
.* IF JUST 1 PARAMETER BESIDES FIRST, AND IT STARTS WITH ".", SAVE IT
.* OR IF IT STARTS WITH ".'", SAVE IT WITHOUT QUOTES
         AIF   (N'&SYSLIST NE 2).NOSAVE
         AIF   ('&POS2'(1,1) EQ '.').YSSAVE
         AIF   ('&POS2'(1,2) EQ '''.').YSSAVEQ
         AGO   .NOSAVE
.YSSAVE  ANOP  ,
&CEC#DBG#HDR SETC '&POS2'
         AGO   .SUBEXIT
.YSSAVEQ ANOP   ,
&CEC#DBG#HDR SETC '&POS2'(2,K'&POS2-2) REMOVE QUOTES
         AGO   .SUBEXIT
.NOSAVE  ANOP  ,
.*
         AIF   (NOT &CEC#DEBUG).SUBEXIT IMMEDIATE RETURN
.*
         CECDYN MNOTE,&CEC#DBG#HDR,' -- ',&POS2,&POS3,&POS4,&POS5,     X
               &POS6,&POS7,&POS8,&POS9,&POS10
         AGO   .SUBEXIT
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71
.DOKEY   ANOP  , SELF-CALL INTERNAL ROUTINE -- PROCESS ONE TEXT UNIT  0
.* ('USER-SUPPLIED' MEANS ON THE OUTER CALL TO CECDYN, FROM OPEN CODE)
.* INPUT: POSITIONAL PARAMETERS
.* &POS1  ALWAYS DOKEY
.* &POS2  ALWAYS &I, ORDINAL TEXT UNIT NUMBER (BUILD '1ST','2ND',ETC.)
.* &POS3  ALWAYS &KEY, USER-SUPPLIED TEXT UNIT KEY
.* &POS4  ALWAYS &TEXT(&I,2), USER-SUPPLIED VALUE(S)
.* &POS5  A TEXT UNIT NAME FROM IEFZB4D2
.* &POS6  A SINGLE NUMBER OR A PAIR OF NUMBERS (MINPRMS,MAXPRMS) .
.*         THIS GIVES LIMITS FOR S99TUNUM, WHICH "SPECIFIES THE NUMBER
.*         OF LENGTH-AND-PARAMETER COMBINATIONS IN THE TEXT UNIT".
.* &POS7  A SINGLE CHARACTER, THE FIELD TYPE C/X/F/A TO BE GENERATED.
.* &POS8  A SINGLE NUMBER OR A PAIR OF NUMBERS (MINLNG,MAXLNG) .
.*         THIS GIVES LIMITS FOR S99TULNG, WHICH "SPECIFIES THE LENGTH
.*         OF THE FOLLOWING PARAMETER FIELD".
.* &POS9  * -- A SINGLE ASTERISK
.*        OR A LIST ((<CHARS>,<VALU>), (<CHARS>,<VALU>), ...)
.*     OR A LIST (+, (<CHARS>,<VALU>), (<CHARS>,<VALU>), ...) .
.*        WHEN A SINGLE ASTERISK IS SPECIFIED, A LABEL IS GENERATED
.*     FOR AN INFORMATION-RETURN FIELD, CONSISTING OF &PREFIX PLUS
.*     THE TEXT UNIT'S NAME.
.*        WHEN A LIST IS SPECIFIED, THE USER-SUPPLIED VALUE(S) ARE
.*     COMPARED AGAINST EACH <CHARS> ENTRY IN THE LIST, AND WHEN
.*     AN EQUAL IS FOUND, THE CORRESPONDING <VALU> IS USED.
.*     ORDINARILY, THE USER CAN ONLY SPECIFY ONE VALUE.  WHEN THE
.*     LIST BEGINS WITH '+', MULTIPLE VALUES SPECIFIED BY THE USER
.*     ARE TRANSLATED INTO MULTIPLE <VALU>S WHICH ARE THEN SUMMED TO
.*     GENERATE A VALUE.
.*        A <CHARS> ENTRY OF A SINGLE ASTERISK IS CONSIDERED A MATCH
.*     FOR ANY VALUE SPECIFIED BY THE USER.
.*        IN ADDITION TO THE VALUE GENERATED, A COMMENT IS GENERATED
.*     IN THE FORM "<CHARS>=<VALU>".
.*        IF THE LIST ENDS WITH AN ASTERISK, THEN NO ERROR MESSAGE
.*     IS GENERATED FOR THE USER-SPECIFIED VALUE NOT BEING FOUND
.*     AMONG THE <CHARS> ENTRIES, AND THE USER-SPECIFIED VALUE IS
.*     USED AS-IS.
.* &POS10  TEXT APPENDED TO THE GENERATED COMMENT.
.*
.*
.*
.* IF THERE IS ONLY 1 TEXT UNIT NAME IN THE LIST (N'&POS5 EQ 1) AND
.* IT DOES NOT EQUAL THE ONE THE USER SUPPLIED    ('&POS3' NE '&POS5')
.* THEN EXIT IMMEDIATELY     (.SUBEXIT)
         AIF   (                                  N'&POS5 EQ 1  AND    X
                                                   '&POS3' NE '&POS5'  X
                             ).SUBEXIT
.*
.*
.* IN CASE MORE THAN 1 TEXT UNIT NAME IS CODED,
.* FIND USER-SUPPLIED &POS3 IN THE &POS5 LIST OF TEXT UNIT NAMES
&J       SETA  1
.NEXTJ01 ANOP  ,
         AIF   ('&POS3' EQ '&POS5(&J)').EXITJ01
.ADVJ01  ANOP  , ADVANCE &J
&J       SETA  &J+1
         AIF   (&J LE N'&POS5).NEXTJ01
         AGO   .SUBEXIT , NOT FOUND, EXIT IMMEDIATELY
.EXITJ01 ANOP  ,
.* NOW &J POINTS TO THE ENTRY IN THE &POS5 LIST THAT MATCHES &POS3.
.*
.*
.A#DOKEY CECDYN DEBUG,'.DOKEY A#DOKEY' SAVE HEADING FOR DEBUG MESSAGES
.*
.******* CECDYN DEBUG,'&NAME CECDYN *1 &POS1,&POS2,"',                 X
               &POS3,'",&POS4,"',                                      X
               &POS5,'","',                                            X
               &POS6,'",&POS7,&POS8,"',                                X
               &POS9,'"'
.*
&CEC#KEYDONE SETB 1          INFORM CALLER, KEY HAS BEEN FOUND
&I       SETA  &POS2
&KEY     SETC  '&POS3'
.*
&CECCMT1COL SETA &CEC#CMT1COL COMMENT 1 FIELD'S COLUMN
&CECCMT2COL SETA &CEC#CMT2COL COMMENT 2 FIELD'S COLUMN
.* (EACH CALL TO .CREAT DOES ABOVE SETA.S, JUST BEFORE EXITING)
.*
&CEC#XLAT SETB (N'&POS9 GT 1  OR  '&POS7' EQ 'A')
.*           IF N'&POS9 GT 1, THEN DEFINITELY A TRANSLATION TABLE.
.* BUT, &POS9 MAY BE OMITTED;  IF '&POS7' EQ 'A', IT IS NUMERIC;
.* ACT LIKE #XLAT.
.*..+....1....+....2....+....3....+....4                              0
.*
.A#XLAT  CECDYN DEBUG,'.DOKEY A#XLAT' SAVE HEADING FOR DEBUG MESSAGES
&MAXJ    SETA  1             ONE VALUE TO BE GENERATED
         AIF   (&CEC#XLAT).GENHDR     GENERATE GROUP HEADER
.*..+....1....+....2....+....3....+....4                              0
.*
.A#XCHK  CECDYN DEBUG,'.DOKEY A#XCHK' SAVE HEADING FOR DEBUG MESSAGES
.*                           SET &MAXJ, AND OTHER THINGS
.* FALL-THRU TO .GENHDR      AND THEN GENERATE GROUP HEADER
.*
.*
.* FIRST, CROSS-CHECK BETWEEN:
.*       N'&POS4 (NUMBER OF VALUES SPECIFIED BY THE CALLER)
.*     AND &POS6 (NUMBER OF VALUES EXPECTED).
.*
         AIF   ((N'&POS6-1)*(N'&POS6-2) EQ 0).C#XCHK
         MNOTE 4,'INTERNAL ERROR PROCESSING KEY &POS3 -- &&POS6 SHOULD X
               HAVE ONLY 1 OR 2 ENTRIES, IT WAS "&POS6"'
.C#XCHK  ANOP  ,
.* IF N'&POS6=1, A FIXED # VALUES IS EXPECTED, &POS6(1)
.* IF N'&POS6=2, MIN # VALUES EXPECTED IS &POS6(1), MAX IS &POS6(2)
         AIF   (N'&POS6 NE 1).D#XCHK  VARIABLE NUMBER POSSIBLE? YES
         AIF   (&POS6(1) NE 0).D#XCHK NON-ZERO NUMBER REQUIRED? YES
         AIF   (N'&POS4 NE 0).D#XCHK  USER SUPPLIED AT LEAST 1? YES
.* FIXED NUMBER POSSIBLE, WHICH IS ZERO, AND USER DID NOT SUPPLY ANY:
&MAXJ    SETA  0            NO VALUES TO BE GENERATED
         AGO   .F#XCHK      GO GENERATE THEM
.D#XCHK  AIF   (N'&POS4 LE &POS6(N'&POS6)).E#XCHK Q. TOO MANY? A. NO  0
&LCLA2   SETA  N'&POS4      # VALUES SPECIFIED                 A. YES
         MNOTE 8,'ERROR: &LCLA2 VALUES WERE SPECIFIED FOR KEY &POS3 -- X
               &POS6(N'&POS6) IS THE MAXIMUM NUMBER PERMITTED.'
.E#XCHK  ANOP  ,
&MAXJ    SETA  &POS6(1)     FIRST OR ONLY -- MINIMUM OR REQUIRED #
         AIF   (&MAXJ GT N'&POS4).F#XCHK CALLER SPECIFIED FEWER? YES,  X
                                       GENERATE THE MINIMUM # REQUIRED
&MAXJ    SETA  N'&POS4 NO, GENERATE AS MANY VALUES AS CALLER SPECIFIED
.*
.F#XCHK  ANOP  ,
.*
         CECDYN DEBUG,'POS4=&POS4, POS6=&POS6, SO MAXJ=&MAXJ..'
.*
         AGO   .GENHDR
.*..+....1....+....2....+....3....+....4                              0
.*
.GENHDR  ANOP  ,             GENERATE GROUP HEADER
.*
.* BOTH .XLAT AND .XCHK PASS THROUGH HERE
.*
         AIF   (&CEC#XLAT).Q#XLAT
.Q#XCHK  CECDYN CMT2,.XCHK   SET &CEC#CMT2VAL
         AGO   .Q#BOTH
.Q#XLAT  CECDYN CMT2,.XLAT   SET &CEC#CMT2VAL
.Q#BOTH  ANOP  ,
.*
&CEC#P.NUM&I CECDYN CREAT,,A,2,&MAXJ,'# OF LENGTH+PARAMETER ENTRIES'
.*..+....1....+....2....+....3....+....4                              0
.*
.*
.* IF &POS9 IS NOT A TRANSLATION TABLE, GENERATE MULTIPLE VALUES.
.*
         AIF   (&MAXJ EQ 0).SUBEXIT   NO VALUES TO BE GENERATED? YES
.*
.* IF THERE IS A MINIMUM NUMBER, DO THAT MANY (NULL VALUES, IF NEEDED)
.*                               ELSE DO AS MANY AS CALLER SPECIFIED
.*
.* NOW, LOOP THROUGH REQUIRED NUMBER (FROM 1 UP THROUGH &MAXJ)
&J       SETA  1
.NEXTJ02 CECDYN DEBUG,'.DOKEY NEXTJ02' SAVE HEADING FOR DEBUG MESSAGES
&SUFFIX  SETC  ''                  NO SUFFIX NEEDED, IF ONLY 1 FIELD
         AIF   (&MAXJ EQ 1).SFXOK  YES, ONLY 1 FIELD TO BE GENERATED
&SUFFIX  SETC  '#&J'               IF MORE THAN 1, DISTINGUISH THEM
.SFXOK   ANOP  ,
&CEC#P.ENT&I&SUFFIX CECDYN CREAT,0,C,,,'ENTRY OF LENGTH+PARAMETER'
.*..+....1....+....2....+....3....+....4                              0
.*..+....1....+....2....+....3....+....4                              1
.*
         AIF   (NOT &CEC#XLAT).NOXLAT2
.*
.XLATVV  ANOP  , WHEN &CEC#XLAT, SET &VALUE, &VALUE2, &LV
.*             (NOTE: WHEN &CEC#XLAT, THEN &MAXJ IS 1, SO THIS CODE
.*              IS NOT DONE EACH TIME THROUGH THE .NEXTJ02 LOOP)
.*
.*       &POS4 IS VALUES SPECIFIED BY CALLER;              (INDEX &K)
.*       &POS9 IS TRANSLATION TABLE   ((R,2),(N,8),...)
.*                               OR (+,(R,2),(N,8),...)    (INDEX &L)
.* EACH TRANSLATION TABLE ENTRY CONSISTS OF:
.*      &POS9(&L,1) <CHARS> FROM, AND &POS9(&L,2) <VALU> TO
.*
.* TWO LOOPS BELOW, LOOP BY &L WITHIN LOOP BY &K
.*
&VALUE   SETC  '&POS4'                 VALUE
&VALUE2  SETC  '&KEY'                  COMMENT
         AIF   (N'&POS9 EQ 0 AND N'&POS4 EQ 1).EXITK02 SKIP ENTIRELY
.*
.T#XLAT  CECDYN DEBUG,'.DOKEY T#XLAT' SAVE HEADING FOR DEBUG MESSAGES
&VALUE   SETC  '0'                     INITIAL VALUE
&VALUE2  SETC  ''                      INITIAL COMMENT
         AIF   (N'&POS4 EQ 0).EXITK02
&K       SETA  1
.NEXTK02 ANOP  ,
.*
.* PROCESS ENTRY &POS4(&K) SPECIFIED BY USER
.*
&POS4K   SETC  '&POS4(&K)'
         AIF   (N'&POS4 NE 1 OR &MAXJ NE 1).POS4KOK
&POS4K   SETC  '&POS4'       PASS-THRU PARENS OF REGISTER OPERAND
.POS4KOK ANOP  ,
.*
&LCLC    SETC  '0'                          DEFAULT VALUE
&LCLC2   SETC  'IGNORE &POS4K'              DEFAULT COMMENT
.*
.*          IF (&K EQ 1) ALWAYS TRANSLATE FIRST USER-SPECIFIED VALUE:
         AIF   (&K EQ 1).YESXLAT
.*          IF WE ARE SUMMING, TRANSLATE ALL USER-SPECIFIED VALUES:
         AIF   ('&POS9(1)' EQ '+' OR '&POS9(1)' EQ '''+''').YESXLAT
         AGO   .SKIPXLT IF NOT SUMMING, ONLY TRANSLATE FIRST VALUE
.YESXLAT ANOP  ,
.*
&L       SETA  1
.NEXTL02 ANOP  ,
         AIF   (N'&POS9(&L) NE 2).ADVL02 (SKIP NON-PAIRS IN &POS9)
         AIF   ('&POS9(&L,1)' EQ '*').MATCH
         AIF   ('&POS9(&L,1)' EQ '&POS4K').MATCH
         AGO   .ADVL02
.MATCH   ANOP  ,
&LCLC    SETC  '&POS9(&L,2)'                RETURN VALUE
&LCLC2   SETC  '&POS9(&L,1)=&POS9(&L,2)'    RETURN COMMENT
         AGO   .EXITL02
.ADVL02  ANOP  , ADVANCE &L
&L       SETA  &L+1
         AIF   (&L LE N'&POS9).NEXTL02
.*
.* WE REACH HERE IF &POS4K IS NOT FOUND IN THE TRANSLATE TABLE
         AIF   ('&POS9(&L-1)' NE '*').EXITL02
.* IF LAST ENTRY IN TRANSLATE TABLE IS '*', OK TO BE NOT-FOUND
&LCLC    SETC  '&POS4K'                     RETURN VALUE
&LCLC2   SETC  '&POS4K NOT TRANSLATED'      RETURN COMMENT
.*
.EXITL02 ANOP  , &LCLC=RETURN VALUE, &LCLC2=RETURN COMMENT
.*
.SKIPXLT ANOP  , SKIP TRANSLATION CODE ABOVE
         AIF   (&K NE 1).ADDVALS ELSE SETVALS
.SETVALS ANOP  ,
&VALUE   SETC  '&LCLC'                 SET VALUE
&VALUE2  SETC  '&KEY &LCLC2'           SET COMMENT
         AGO   .ADVK02
.ADDVALS ANOP  ,
&VALUE   SETC  '&VALUE+&LCLC'          APPEND TO VALUE
&VALUE2  SETC  '&VALUE2, &LCLC2'       APPEND TO COMMENT
.ADVK02  ANOP  , ADVANCE &K
&K       SETA  &K+1
         AIF   (&K LE N'&POS4).NEXTK02
         AGO   .EXITK02
.*
.EXITK02 ANOP  ,
.*
&LCLC    SETC  '&POS10'                           FETCH VALUE
         AIF   (K'&LCLC LE 2).NOTCOMT             TOO SHORT FOR QUOTES
         AIF   ('&LCLC'(1,1) NE '''').NOTCOMT       NOT LEADING QUOTE,
         AIF   ('&LCLC'(K'&LCLC,1) NE '''').NOTCOMT NOR TRAILING.
&LCLC    SETC  '&LCLC'(2,K'&LCLC-2)               REMOVE QUOTES
.NOTCOMT ANOP  ,
&VALUE2  SETC  '&VALUE2 &LCLC'
.*
         AIF   (&CEC#FLAG(1)).B#CHGV2      DC -- TEXT ONLY
         AIF   (&CEC#FLAG(2)).B#CHGV2      DS -- TEXT ONLY
         AIF   ('&VALUE2' NE '').X#CHGV2      ACTIVE -- DESCRIBE XLATE
.* IF NO XLATE WAS DONE, FALL THRU TO TEXT ONLY
.B#CHGV2 ANOP  ,
&VALUE2  SETC  ''   LET IT BE OVERRIDDEN LATER
.X#CHGV2 ANOP  ,
.*
&LV      SETA  &POS8(1)
.*
.NOXLAT2 ANOP  ,
.*..+....1....+....2....+....3....+....4                              0
.*..+....1....+....2....+....3....+....4                              1
.*
         AIF   (&CEC#XLAT).NOXCHK2
.*
.XCHKVV  ANOP  , WHEN NOT &CEC#XLAT, SET &VALUE, &VALUE2, &LV
.*
.* ANALYSE CALLER-SPECIFIED VALUE:
.* &POS4(&J)=''      PRODUCES &NUL=1
.*
.* &POS4(&J)='...' PRODUCES &LIT=1
.* &POS4(&J)=(...) PRODUCES &REG=1
.* &POS4(&J)=A(...) PRODUCES &ACN=1
.*   NOTE--IF A LIST WITH ONLY 1 ENTRY IS SPECIFIED, THAT IS &REG.
&VALUE   SETC  '&POS4(&J)'
         AIF   (N'&POS4 NE 1).BBVAL
&VALUE   SETC  '&POS4'       PROPOGATE PARENS, SO &REG IS CORRECT
.BBVAL   ANOP  ,
.*
&LIT     SETB  0             LITERAL
&REG     SETB  0             REGISTER
&ACN     SETB  0             ADDRESS CONSTANT
&NUL     SETB  1             NULL -- OMITTED
&LCLC    SETC   'POS4(J=&J.)=&VALUE.,'     PREPARE FOR DEBUGGING
         AIF   (K'&VALUE EQ 0).ZZVAL             .* IF NULL SKIP
         AIF   ('&VALUE' EQ '').ZZVAL            .* IF NULL SKIP
&NUL     SETB  0                               .* RESET NULL IF NOT
         AIF   (K'&VALUE LT 3).XXVAL TOO SHORT TO BE ANYTHING
&LIT     SETB  ('&VALUE'(1,1) EQ '''' AND '&VALUE'(K'&VALUE,1) EQ '''')
&LCLC    SETC   'POS4(J=&J.)='.'&VALUE'(2,K'&VALUE-2).','
         AIF   (&LIT).ZZVAL
&LCLC    SETC   'POS4(J=&J.)=&VALUE.,'     PREPARE FOR DEBUGGING
&REG     SETB  ('&VALUE'(1,1) EQ '(' AND '&VALUE'(K'&VALUE,1) EQ ')')
         AIF   (&REG).ZZVAL
         AIF   (K'&VALUE LT 4).XXVAL TOO SHORT TO BE ACN
&ACN     SETB  ('&VALUE'(1,2) EQ 'A(' AND '&VALUE'(K'&VALUE,1) EQ ')')
         AIF   (&ACN).ZZVAL
.XXVAL   ANOP  ,
.ZZVAL   ANOP  ,
         CECDYN DEBUG,'&LCLC NUL=&NUL, LIT=&LIT, REG=&REG, ACN=&ACN..'
.*..+....1....+....2....+....3                                        0
.*
.A#LGH   CECDYN DEBUG,'.DOKEY A#LGH' SAVE HEADING FOR DEBUG MESSAGES
.* DEFAULT VALUE LENGTH IS MAX VALUE LENGTH
.* IF RANGE PERMITTED, AND CALLER SPECIFIED LITERAL VALUE,
.*       THEN USE MAXIMUM OF (CALLER'S VALUE'S LENGTH, MINIMUM LENGTH)
.*       &POS4 IS (VALUES) SPECIFIED BY CALLER;
.*       &POS8 IS LENGTH OF EACH VALUE EXPECTED
         AIF   ((N'&POS8-1)*(N'&POS8-2) EQ 0).B#LGH
         MNOTE 4,'INTERNAL ERROR PROCESSING KEY &POS3 -- &&POS8 SHOULD X
               HAVE ONLY 1 OR 2 ENTRIES, IT WAS "&POS8"'
.B#LGH   ANOP  ,
.* IF N'&POS8=1, A FIXED LENGTH IS EXPECTED,  &POS8(1)
.* IF N'&POS8=2, MINIMUM LENGTH EXPECTED IS &POS8(1), MAX IS &POS8(2)
&LMIN    SETA  &POS8(1)      MUST BE SELF-DEFINING DECIMAL TERM
&LMAX    SETA  &POS8(N'&POS8) MUST BE SELF-DEFINING DECIMAL TERM
&LV      SETA  &LMAX         DEFAULT VALUE LENGTH IS MAX VALUE LENGTH
         AIF   (N'&POS8 EQ 1).G#LGH OK--ONLY 1, USE THAT LENGTH
         AIF   (NOT &LIT).G#LGH       OK--USE MAX (OR ONLY) LENGTH
&LV      SETA  &LMIN         DEFAULT VALUE LENGTH IS MIN VALUE LENGTH
&LCLA2   SETA  K'&POS4(&J)-2 LENGTH OF VALUE SPECIFIED (W/O QUOTES)
         AIF   (&LCLA2 LT &LMIN).G#LGH  OK--FORCE MINIMUM LENGTH
&LV      SETA  &LCLA2        OK--USE CALLER'S VALUE'S LENGTH
.G#LGH   ANOP  ,
.X#LGH   ANOP  ,
         CECDYN DEBUG,' POS8=&POS8.; MIN=&LMIN., MAX=&LMAX..'
&LCLC    SETC  'K''''POS4(J=&J.)=K'''''.'&POS4(&J).=&LCLA2.;'
&LCLC    SETC  '&LCLC. LENGTH USED IS LV=&LV..'
         CECDYN DEBUG,'&LCLC'
.*
&VALUE2  SETC  ''   LET IT BE OVERRIDDEN LATER
.*
.NOXCHK2 ANOP  ,                                                      0
.*..+....1....+....2....+....3....+....4                              -
.*..+....1....+....2....+....3....+....4                              -
&I1      SETA  &I-10*(&I/10)           1'S DIGIT OF &I
&I10     SETA  (&I/10)-10*(&I/100)     10'S DIGIT OF &I
&IIX     SETA  1+3*(&I1*(&I10-1)/(&I10-1)) IGNORE &I1 IF (&I10-1) EQ 0
&ITH     SETC  'TH ST ND RD TH TH TH TH TH TH '(&IIX,2) 0TH, 1ST, ETC.
.*..+....1
&J1      SETA  &J-10*(&J/10)           1'S DIGIT OF &J
&J10     SETA  (&J/10)-10*(&J/100)     10'S DIGIT OF &J
&JIX     SETA  1+3*(&J1*(&J10-1)/(&J10-1)) IGNORE &J1 IF (&J10-1) EQ 0
&JTH     SETC  'TH ST ND RD TH TH TH TH TH TH '(&JIX,2) 0TH, 1ST, ETC.
.*..+....1
&CEC#P.LNG&I&SUFFIX CECDYN CREAT,,A,2,&LV,                             X
               'LENGTH OF &J&JTH PARM. OF &I&ITH KEY'
         AIF   (&J NE 1).NOLABEL             LABEL ONLY FOR FIRST
.******* AIF   ('&POS9' NE '*').NOLABEL Q. MUST WE DEFINE NAME? A. NO
.*                                                              A. YES
         AIF   ('&POS9' NE '*' AND '&CEC#CMT2VAL' EQ '.XLAT').NOLABEL
.* (FOR .XCHK, FALL THROUGH ALL THE TIME)
.*
&LCLC    SETC  '&CEC#P'.'&KEY'(4,K'&KEY-3)
&LCLC    CECDYN CREAT,0,&POS7,&LV,,'DEFINE NAME FOR USER'
.NOLABEL ANOP  ,
.*
         AIF   ('&VALUE2' NE '').NOTNULL
&VALUE2  SETC  'VALUE OF &J&JTH PARM. OF &I&ITH KEY' OVERRIDE HERE
.NOTNULL ANOP  ,
.*
&CEC#P.PAR&I&SUFFIX CECDYN CREAT,,&POS7,&LV,&VALUE,'&VALUE2'
.*..+....1....+....2....+....3                                        0
.*
.ADVJ02  ANOP  , ADVANCE &J
&J       SETA  &J+1
         AIF   (&J LE &MAXJ).NEXTJ02
.*
         AGO   .SUBEXIT
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71
.MNOTE   ANOP  , SELF-CALL INTERNAL ROUTINE -- MNOTE '&POS2&POS3...'
&LCLC    SETC  ''
.*
&J       SETA  2
.NEXTJ04 ANOP  ,
.*
.*
         AIF   ('&SYSLIST(&J)' EQ '').EXITI04
&LCLB    SETB  ('&SYSLIST(&J)'(1,1) EQ '''' AND                        X
                             '&SYSLIST(&J)'(K'&SYSLIST(&J),1) EQ '''')
.* QUOTES AT BOTH ENDS?
&I       SETA  1+&LCLB    IF YES, SKIP BEGINNING QUOTE
.NEXTI04 ANOP  ,
         AIF   (K'&LCLC GE 254).EXITI04      .TOOBIG
         AIF   ('&SYSLIST(&J)'(&I,1) EQ '''').DOUBLE
         AIF   ('&SYSLIST(&J)'(&I,1) EQ '&&').DOUBLE
&LCLC    SETC  '&LCLC'.'&SYSLIST(&J)'(&I,1)
         AGO   .ADVI04
.TOOBIG  MNOTE '&&LCLC TOO LONG -- &&J=&J -- &&I=&I -- &&LCLC="&LCLC"'
         AGO   .ADVI04
.DOUBLE  ANOP  ,
&LCLC    SETC  '&LCLC'.'&SYSLIST(&J)'(&I,1).'&SYSLIST(&J)'(&I,1)
         AGO   .ADVI04
.ADVI04  ANOP  , ADVANCE &I
&I       SETA  &I+1
         AIF   (&I LE K'&SYSLIST(&J)-&LCLB).NEXTI04 SKIP ENDING QUOTE
.EXITI04 ANOP  ,
.*
.*
.ADVJ04  ANOP  , ADVANCE &J
&J       SETA  &J+1
         AIF   (&J LE N'&SYSLIST).NEXTJ04
.EXITJ04 ANOP  ,
.*
         MNOTE '&LCLC'                                                -
         AGO   .SUBEXIT                                               -
.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7
         MEND ,                                                       0
         AGO   .SKIPTEXT
                                                                      1
@P
1* (C) COPYRIGHT CENTERIOR ENERGY CORPORATION 1988,1991
-CECDYN -- macro for building Dynamic Allocation parameter list
-     This macro builds a parameter list which can be used by SVC 99.
      It does not issue a call to SVC 99, it only builds the parameter
      list in storage and returns control.
0     Unlike the IBM-supplied macros, instead of calculating offsets
      into the parameter list to store values into it, a dummy control
      section and symbolic names are generated and used.  If a USING
      is issued on the dummy section, the symbolic names can then be
      used to modify the parameter list.  All symbolic names generated
      by one call to CECDYN start with the same three characters.  The
      three characters can be specified by the caller, or will be
      assigned by the macro.
0     The standard form of the CECDYN macro instruction is written
      as follows:

>     ----------------------------------------------------------------
0     <name>              <name>: symbol.  Begin <name> in column 1.
0     b
+     /                   One or more blanks must precede CECDYN.
0     CECDYN
0     b
+     /                   One or more blanks must follow CECDYN.

>     ----------------------------------------------------------------
0     VERB=<verb>         <verb>: two byte character string
0     ,PREFIX=<prefix>    <prefix>: maximum-of-3 byte character string
0     ,FLG11=(<flg11>)
      ,FLG21=(<flg21>)
      ,FLG22=(<flg22>)    <flg11>/<flg21>/<flg22>: one or more 5 byte
                          character strings, seperated by commas.  For
                          example, FLG##=(<flg##>,<flg##>,<flg##>) .
                          If only one <flg##> is specified, the outer
                          parentheses may be omitted.
0     ,TEXT=(<text unit>) <text unit>: either a maximum-of-5 byte
                          character string, or a parenthesized pair
                          consisting of a maximum-of-5 byte character
                          string plus one of: literal delimited by
                          quotes, A-type address, register (2)-(12).
                          If only one <text unit> is specified, the
                          outer parentheses must still be coded.
                          Note:  <text unit> is one or more text
                          units, seperated by commas.  For example,
                          TEXT=(<text unit>,<text unit>,<text unit>)
0     ,LIST=NO            Default: LIST=YES
      ,LIST=YES

>     ----------------------------------------------------------------
-     The parameters are explained below:
-     VERB=<verb>
0       specifies the SVC 99 function requested.  The two bytes
        supplied will be prepended with 'S99VRB' to build a symbol
        which specifies a verb code.  The seven verb codes are defined
        in the IBM-supplied macro IEFZB4D0, described in "System
        Macros and Facilities".
0       No checking is done for validity, but values not defined in
        IEBZB4D0 will create undefined symbols.
0       There is no default for this parameter.
-     FLG11=<flg11>
      FLG21=<flg21>
      FLG22=<flg22>
0       specify certain available options.  Each 5 bytes supplied will
        be prepended with 'S99' to build a symbol which specifies an
        option, and all the <flg11> will be summed to produce FLG11,
        all the <flg21> will be summed to produce FLG21, all the
        <flg22> will be summed to produce FLG22.
        FLG11 options are available to all SVC 99 callers.
        FLG21 & FLG22 options are only available to authorized
        callers.
        The options available are defined in IBM-supplied macro
        IEFZB4D0, described in "System Macros and Facilities".
0       No checking is done for validity, but values not defined in
        IEBZB4D0 will create undefined symbols.
-     Note: No checking is done that a FLG11 option is specified for
        FLG21, etc., or vice versa.  It will not cause an assembly
        error, but results are unpredictable.
-     ,PREFIX=<prefix>
        optionally supplies up-to-3 characters to be used in building
        the symbolic names for fields in the parameter list.  If not
        specified, CECDYN will create a 3-character prefix dependent
        on the assembler system variable &SYSNDX.  The prefix created
        by CECDYN will start with an alphabetic character which will
        range through A thru Z, and its next two characters will each
        range through 0 thru 9 and A thru Z, the last character
        varying most quickly, as &SYSNDX increases.
        The dummy section created is named <prefix>DSECT, and it's
        length is available as L'<prefix>DSECT .
-     ,TEXT=(<text unit>)
        specifies the text units to be placed in the parameter list.
        Each text unit specified will usually be a parenthesized pair
        consisting of a maximum-of-5 byte character string plus one
        of:  literal delimited by quotes, A-type address, register
        (2)-(12).
        The character string will be prepended with the character 'D'
        plus the VERB specified, to make a symbol which is defined in
        the IBM-supplied macro IEFZB4D2, described in "System Macros
        and Facilities".
0       No checking is done for validity of the character string, but
        values not defined in IEBZB4D2 will create undefined symbols.
0       Some text units do not require a value, and these will be
        specified by only the maximum-of-5 byte character string.  For
        these, the inner parentheses may be omitted.
0       If no text units are specified, only the request block pointer
        and the request block are built.  If null text units are
        specified, then text unit pointers with a value of zero are
        built.
0       Certain text units may have multiple values specified which
        are then summed to build one value (DALOPTCD).  These, and
        others, may have their values specified as character strings
        which are then translated by CECDYN to be the proper hex
        values -- For example, (STATS,OLD) will generate a value of
        X'01'.  If you wish, you may code the actual hex value.
0       Certain other text units may have multiple values which create
        multiple fields in the parameter list (DALVLSER,etc.)  CECDYN
        will check whether multiple values are specified for a text
        unit which does not allow multiple values.
0     ,LIST=NO
      ,LIST=YES
        specifies whether or not generated code is to be printed.
        If this parameter is not specifed, a default of YES is used.
-     When control is returned, register 1 points to the parameter
      list.  SVC 99 can be issued immediately, or the parameter list
      can be modified before issuing SVC 99.
      The addresses of text units are stored in the parameter list
      starting at the location labelled <prefix>TUPL.  The address of
      each text unit is stored in the parameter list in field
      <prefix>PTR<#>, where <prefix> is the PREFIX specified or
      generated, and <#> ranges from 1 through the number of text
      units specified.  Each text unit begins at the field labelled
      <prefix>TU<#>.  Each text unit will always have a KEY subfield
      <prefix>KEY<#> containing the text unit key, and a NUMBER
      subfield <prefix>NUM<#> containing the number of length and
      parameter combinations in the text unit.  Some text units will
      have only these two subfields, if its NUMBER subfield has a
      value of zero.
-Example 1
0     Operation: Unallocate the data set associated with ddname
      IEFRDER.  CECDYN will assign a 3-byte prefix to the names
      generated.
0     NAME     CECDYN VERB=UN,TEXT=((DDNAM,'IEFRDER'))
               DYNALLOC
               LTR   15,15          WAS SVC99 SUCCESSFUL ?
               ...
0
-Example 2
0     Operation: Request all available information text units, for the
      data set currently allocated to the ddname stored in symbol
      WRKDD.  Returned information will be in the fields ZZZRTLST,
      ZZZRTDDN, etc.
      These fields will be accessible by issuing a USING ZZZDSECT,1 .
0     INFORM   CECDYN  PREFIX=ZZZ,                                     X
                     VERB=IN,                                          X
                     TEXT=((DDNAM,WRKDD),                              X
                     RTLST,RTDDN,RTDSN,RTMEM,RTSTA,                    X
                     RTNDP,RTCDP,RTORG,RTLIM,RTATT,RTTYP)
               DYNALLOC
               LTR   15,15          WAS SVC99 SUCCESSFUL ?
               BNZ   ERROR          NO.
               USING ZZZDSECT,1     ADDRESSABILITY TO PARAMETER LIST
               MVC   LASTIND,ZZZRTLST
               MVC   MEMBER,ZZZRTMEM
               ...
-Example 3
0     Operation: Build a list to be modified later.  In the list,
      specify 'do not mount volumes or consider offline devices'.
      Reserve space for 5 text unit addresses.  Modify the first three
      addresses by using the list form of the CALL macro instruction.
0     ALLOCIT  CECDYN  PREFIX=Q02,                                     X
                     VERB=AL,                                          X
                     FLG11=NOMNT,                                      X
                     TEXT=(,,,,)
               USING Q02DSECT,1
               MVC   Q02TUPL(CALLISTX-CALLIST),CALLIST
               DYNALLOC
               LTR   15,15          WAS SVC99 SUCCESSFUL ?
               ...
               ...
      CALLIST  CALL  ,(THIS,THAT,OTHER),VL,MF=L
      CALLISTX EQU   *
1
-CECDYN (List Form)
-     The list form of the CECDYN macro instruction is used to
      construct a nonexecutable SVC 99 parameter list.  This list form
      generates only ADCONs of the text unit parameters.  This
      parameter list can be referred to in the execute form of a
      CECDYN macro instruction.
0     The list form of the CECDYN macro instruction is written as
      follows:

>     ----------------------------------------------------------------
0     <name>              <name>: symbol.  Begin <name> in column 1.
0     b
+     /                   One or more blanks must precede CECDYN.
0     CECDYN
0     b
+     /                   One or more blanks must follow CECDYN.

>     ----------------------------------------------------------------
0     VERB=<verb>         <verb>: two byte character string
0     ,PREFIX=<prefix>    <prefix>: maximum-of-3 byte character string
0     ,FLG11=(<flg11>)
      ,FLG21=(<flg21>)
      ,FLG22=(<flg22>)    <flg11>/<flg21>/<flg22>: one or more 5 byte
                          character strings, seperated by commas.  For
                          example, FLG##=(<flg##>,<flg##>,<flg##>) .
                          If only one <flg##> is specified, the outer
                          parentheses may be omitted.
0     ,TEXT=(<text unit>) <text unit>: either a maximum-of-5 byte
                          character string, or a parenthesized pair
                          consisting of a maximum-of-5 byte character
                          string plus one of: literal delimited by
                          quotes, A-type address, register (2)-(12).
                          If only one <text unit> is specified, the
                          outer parentheses must still be coded.
                          Note: <text unit> is one or more text units,
                          seperated by commas.  For example,
                          TEXT=(<text unit>,<text unit>,<text unit>)
0     ,LIST=NO            Default: LIST=YES
      ,LIST=YES
0     ,MF=L

>     ----------------------------------------------------------------
-     The parameters are explained under the standard form of the
      CECDYN macro instruction, with the following exception:
-     MF=L
0       specifies the list form of the CECDYN macro instruction.
1
-CECDYN (Execute Form)
-     A remote SVC 99 parameter list is referred to and can be
      modified by the execute form of the CECDYN macro instruction.
      Only executable instructions are generated.  The first time a
      particular PREFIX is used, a DSECT is defined.  Each execute
      form CECDYN macro instruction later in a program which uses the
      same PREFIX must have the same VERB as specified on the list
      form CECDYN macro instruction, or symbolic names referred-to in
      the generated code will not be previously defined.  A
      combination of FLG11, FLG21, and FLG22 values can be specified
      that is different than that specified on the list form CECDYN
      macro instruction.
      The TEXT may have fewer entries specified, but should have no
      new maximum-of-5 byte character strings which were not on the
      list form CECDYN macro instruction.
0     The execute form of the CECDYN macro instruction is written as
      follows:

>     ----------------------------------------------------------------
0     <name>              <name>: symbol.  Begin <name> in column 1.
0     b
+     /                   One or more blanks must precede CECDYN.
0     CECDYN
0     b
+     /                   One or more blanks must follow CECDYN.

>     ----------------------------------------------------------------
0     VERB=<verb>         <verb>: two byte character string
0     ,PREFIX=<prefix>    <prefix>: maximum-of-3 byte character string
0     ,FLG11=(<flg11>)
      ,FLG21=(<flg21>)
      ,FLG22=(<flg22>)    <flg11>/<flg21>/<flg22>: one or more 5 byte
                          character strings, seperated by commas.  For
                          example, FLG##=(<flg##>,<flg##>,<flg##>) .
                          If only one <flg##> is specified, the outer
                          parentheses may be omitted.
0     ,TEXT=(<text unit>) <text unit>: either a maximum-of-5 byte
                          character string, or a parenthesized pair
                          consisting of a maximum-of-5 byte character
                          string plus one of: literal delimited by
                          quotes, A-type address, register (2)-(12).
                          If only one <text unit> is specified, the
                          outer parentheses must still be coded.
                          Note: <text unit> is one or more text units,
                          seperated by commas.  For example,
                          TEXT=(<text unit>,<text unit>,<text unit>)
0     ,LIST=NO            Default: LIST=YES
      ,LIST=YES
0     ,MF=(E,<remote addr>)
                          <remote addr>: RX-type address, or register
                          (1) or (2)-(12).

>     ----------------------------------------------------------------
-     The parameters are explained under the standard form of the
      CECDYN macro instruction, with the following exception:
-     MF=(E,<remote addr>)
0       specifies the execute form of the CECDYN macro instruction.
        The text units specified are built at the address specified in
        the MF parameter.
9SYS2.CEI.MACLIB(CECDYN)                                   08-MAR-1991
.SKIPTEXT ANOP ,
./ ADD NAME=CONTINUE 0100-10260-10260-1641-00011-00011-00000-MACLIB
         MACRO ,
&NAME    CONTINUE ,
.* DATE.     28-JUL-1989
.* REMARKS.  THIS MACRO WORKS WITH THE MACROS WRITTEN BY DON HIGGINS,
.*          FOUND ON FILE 078 OF SHARE MVS GROUP MODS TAPE, V29 (04/84)
.*  SEE CASE,DOCASE,DOMACRO,EQUBC,ELSE,ELSEIF,ESAC,ESACOD,FI,IF,OD;
.*  AND BREAK.
         GBLA  &DO(10),&DOSEQ(10),&DOLVL,&DOLAB
         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB
&NAME    B     DO&DO(&DOLVL)       GO IMMEDIATELY TO TEST PART OF LOOP
         MEND  ,
./ ADD NAME=DOMACRO  0100-10260-10260-1641-00122-00122-00000-MACLIB
*          DATA SET AM010800   AT LEVEL 001 AS OF 10/28/75
*          DATA SET AM010800   AT LEVEL 004 AS OF 08/14/74
         MACRO
         DO
         GBLA  &DO(10),&DOSEQ(10),&DOLVL,&DOLAB
         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB
         LCLA  &N,&M,&S,&LAB1,&L,&I
         LCLA  &UNTIL
         LCLC  &OP,&OPR
         LCLB  &TESTSW
         EQUBC ,             DEFINE CONDITIONS, IF NOT ALREADY DEFINED
.*             AUTHOR.   DON HIGGINS.
.*             DATE.     03/27/74.
.*             REMARKS.  MACRO TO ALLOW STRUCTURED PROGRAMMING USING
.*                       IF, THEN, ELSE, AND DO UP TO TEN LEVELS DEEP
.*                       AND NO BRANCH INSTRUCTIONS. SEE IF MACRO.
         AIF   (&DOLVL EQ 10).ERR1
&N       SETA  N'&SYSLIST
         AIF   (&N LT 1).ERR2
         AIF   ('&SYSLIST(1)' EQ 'END').END
         AIF   ('&SYSLIST(1)' EQ 'FOREVER').WHILE
         AIF   (&N LT 2).ERR2
         AIF   ('&SYSLIST(1)' EQ 'WHILE').WHILE
         AIF   ('&SYSLIST(1)' NE 'UNTIL').ERR3
.UNTIL   ANOP
&DOLVL   SETA  &DOLVL+1
&UNTIL   SETA  &DOLAB+1
&DOLAB   SETA  &DOLAB+2
         B     DO&UNTIL
         AGO   .COMM
.WHILE   ANOP
&DOLVL   SETA  &DOLVL+1
&DOLAB   SETA  &DOLAB+1
.COMM    ANOP
&DOSEQ(&DOLVL) SETA 1
&DO(&DOLVL) SETA &DOLAB
DO&DOLAB EQU   *
         AIF   (&LEVEL EQ 10).ERR1
&LEVEL   SETA  &LEVEL+1
&SEQ(&LEVEL) SETA 1
&LAB     SETA  &LAB+1
&ELSE(&LEVEL) SETA &LAB
         AIF   ('&SYSLIST(1)' EQ 'FOREVER').EXIT
&S       SETA  1
.NEXTAND ANOP
&TESTSW  SETB  0
.TEST    ANOP
&S       SETA  &S+1
         AIF   (&S GT &N).ERR2
&M       SETA  N'&SYSLIST(&S)
         AIF   (&M LT 2).ERR3
         AIF   (&M GT 5).ERR3
&I       SETA  2
&OPR     SETC  ''
&OP      SETC  '&SYSLIST(&S,1)'
         AIF   (&M GT 2).TESTOPR
         &OP
         AGO   .TESTEND
.TESTOPR ANOP
         AIF   ('&SYSLIST(&S,&I)'(1,1) NE '''').NOLIT
&L       SETA  K'&SYSLIST(&S,&I)
&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'(2,&L-2)
         AGO   .NEXTOPR
.NOLIT   ANOP
&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'
.NEXTOPR ANOP
&I       SETA  &I+1
         AIF   (&I EQ &M).TESTGEN
&OPR     SETC  '&OPR'.','
         AGO   .TESTOPR
.TESTGEN ANOP
         &OP   &OPR
.TESTEND ANOP
         AIF   (&TESTSW EQ 1).ORBC
.AMBC    ANOP
         BC    15-&SYSLIST(&S,&M),IF0&LAB
.CONNECT ANOP
&S       SETA  &S+1
         AIF   (&S GT &N).CHKUNTL
&M       SETA  N'&SYSLIST(&S)
         AIF   (&M NE 1).ERR3  BAD CONNECTOR
         AIF   ('&SYSLIST(&S)' EQ 'AND').NEXTAND
         AIF   ('&SYSLIST(&S)' NE 'OR').ERR3  BAD CONNECTOR
.NEXTOR   ANOP
&LAB1    SETA  &LAB+1
         B     IF0&LAB1  SKIP TEST IF LAST ONE TRUE
IF0&LAB   EQU *          DO TEST IF LAST ONE FALSE
&LAB     SETA  &LAB+2
&ELSE(&LEVEL) SETA &LAB
&TESTSW  SETB  1
         AGO   .TEST
.ORBC    ANOP
         BC    15-&SYSLIST(&S,&M),IF0&LAB
IF0&LAB1 EQU *
         AGO   .CONNECT
.CHKUNTL ANOP
         AIF   (&UNTIL EQ 0).EXIT
&LAB     SETA  &LAB+1
         B     IF0&LAB
IF0&ELSE(&LEVEL) EQU *
&ELSE(&LEVEL) SETA &LAB
DO&UNTIL EQU *
         AGO   .EXIT
.END     ANOP
         AIF   (&N GT 1).ERR3
         AIF   (&DOLVL EQ 0).ERR4
         AIF   (&DOSEQ(&DOLVL) NE 1).ERR4
&DOSEQ(&DOLVL) SETA 0
         B     DO&DO(&DOLVL)
&DOLVL   SETA  &DOLVL-1
IF0&ELSE(&LEVEL) EQU *
&LEVEL   SETA  &LEVEL-1
         AGO   .EXIT
.ERR1    MNOTE 8,'DO - LEVEL OVERFLOW'
         AGO   .EXIT
.ERR2    MNOTE 8,'DO - MISSING OPERAND'
         AGO   .EXIT
.ERR3    MNOTE 8,'DO - INVALID OPERAND'
         AGO   .EXIT
.ERR4    MNOTE 8,'DO - END OUT OF SEQUENCE'
.EXIT    ANOP
         MEND
./ ADD NAME=ELSE     0100-10260-10260-1641-00046-00046-00000-MACLIB
* COPIED FROM FILE 078 OF SHARE MVS GROUP MODS TAPE, V29 (04/84)
*          DATA SET AM010700   AT LEVEL 003 AS OF 05/23/76
         MACRO
         ELSE  &OPT
         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB
         GBLA  &ELSEIF(10)
.* AUTHOR.   DON HIGGINS.
.* DATE.     03/27/74.
.* REMARKS.  MACRO TO ALLOW STRUCTURED PROGRAMMING USING
.*           IF, THEN, ELSE, AND DO UP TO TEN LEVELS DEEP
.*           AND NO BRANCH INSTRUCTIONS. SEE IF MACRO.
.* REV1 05/23/76 DSH - SUPPORT ELSEIF
         AIF   (&LEVEL EQ 0).ERR0
         AIF   (T'&OPT EQ 'O').BEGIN
         AIF   ('&OPT' EQ 'BEGIN').BEGIN
         AIF   ('&OPT' EQ 'END').END
         AIF   ('&OPT' EQ 'CONTINUE').CONT
         MNOTE 8,'ELSE - INVALID OPERAND'
         AGO   .EXIT
.BEGIN   ANOP  ,
         AIF   (&SEQ(&LEVEL) GT 3).ERR1
&LAB     SETA  &LAB+1
         B     IF0&LAB
IF0&ELSE(&LEVEL) EQU *
&ELSE(&LEVEL) SETA &LAB
&SEQ(&LEVEL) SETA 4
         AGO .EXIT
.END     ANOP  ,
         AIF   (&SEQ(&LEVEL) NE 4).ERR2
.DEQUE   ANOP  ,
IF0&ELSE(&LEVEL) EQU *
&LEVEL   SETA &LEVEL-1
         AIF   (&ELSEIF(&LEVEL+1) EQ 1).DEQUE
         AGO   .EXIT
.CONT    ANOP  ,
         AIF   (&SEQ(&LEVEL) GT 3).ERR3
         AGO   .DEQUE
.ERR0    MNOTE 8,'ELSE - MISSING IF'
         AGO   .EXIT
.ERR1    MNOTE 8,'ELSE BEGIN - OUT OF SEQUENCE'
         AGO   .EXIT
.ERR2    MNOTE 8,'ELSE END - OUT OF SEQUENCE'
         AGO   .EXIT
.ERR3    MNOTE 8,'ELSE CONTINUE - OUT OF SEQUENCE'
.EXIT    ANOP  ,
         MEND  ,
./ ADD NAME=ELSEIF   0100-10260-10260-1641-00083-00083-00000-MACLIB
* COPIED FROM FILE 078 OF SHARE MVS GROUP MODS TAPE, V29 (04/84)
*          DATA SET AM013600   AT LEVEL 002 AS OF 05/23/76
         MACRO ,
         ELSEIF ,
         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB
         GBLA  &ELSEIF(10)
         LCLA  &N,&M,&S,&LAB1,&L,&I
         LCLC  &OP,&OPR
         LCLB  &TESTSW
.* AUTHOR.   DON HIGGINS.
.* DATE.     05/23/76.
.* REMARKS.  CONTROL STRUCTURE FOR CONDITIONAL EXECUTION.
         AIF   (&LEVEL EQ 10).ERR1
         ELSE  ,
&LEVEL   SETA  &LEVEL+1
&ELSEIF(&LEVEL) SETA 1
&SEQ(&LEVEL) SETA 1
&LAB     SETA  &LAB+1
&ELSE(&LEVEL) SETA &LAB
&N       SETA N'&SYSLIST
.NEXTAND ANOP  ,
&TESTSW  SETB  0
.TEST    ANOP  ,
&S       SETA  &S+1
         AIF   (&S GT &N).ERR2
&M       SETA  N'&SYSLIST(&S)
         AIF   (&M EQ 1).TESTEND
         AIF   (&M LT 2).ERR3
         AIF   (&M GT 5).ERR4
&I       SETA  2
&OPR     SETC  ''
&OP      SETC  '&SYSLIST(&S,1)'
         AIF   (&M GT 2).TESTOPR
         &OP                                                         ,
         AGO   .TESTEND
.TESTOPR ANOP  ,
         AIF   ('&SYSLIST(&S,&I)'(1,1) NE '''').NOLIT
&L       SETA  K'&SYSLIST(&S,&I)
&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'(2,&L-2)
         AGO   .NEXTOPR
.NOLIT   ANOP  ,
&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'
.NEXTOPR ANOP  ,
&I       SETA  &I+1
         AIF   (&I EQ &M).TESTGEN
&OPR     SETC  '&OPR'.','
         AGO   .TESTOPR
.TESTGEN ANOP  ,
         &OP   &OPR                                                  ,
.TESTEND ANOP  ,
         AIF   (&TESTSW EQ 1).ORBC
.AMBC    ANOP  ,
         BC    15-&SYSLIST(&S,&M),IF0&LAB
.CONNECT ANOP  ,
&S       SETA  &S+1
         AIF   (&S GT &N).EXIT
&M       SETA  N'&SYSLIST(&S)
         AIF   (&M NE 1).ERR5  BAD CONNECTOR
         AIF   ('&SYSLIST(&S)' EQ 'AND').NEXTAND
         AIF   ('&SYSLIST(&S)' NE 'OR').ERR5  BAD CONNECTOR
.NEXTOR   ANOP ,
&LAB1    SETA  &LAB+1
         B     IF0&LAB1  SKIP TEST IF LAST ONE TRUE
IF0&LAB   EQU *          DO TEST IF LAST ONE FALSE
&LAB     SETA  &LAB+2
&ELSE(&LEVEL) SETA &LAB
&TESTSW  SETB  1
         AGO   .TEST
.ORBC    ANOP  ,
         BC    15-&SYSLIST(&S,&M),IF0&LAB
IF0&LAB1 EQU *
         AGO   .CONNECT
.ERR1    MNOTE 8,'IF - LEVEL OVERFLOW'
         AGO   .EXIT
.ERR2    MNOTE 8,'IF - MISSING TEST LIST'
         AGO   .EXIT
.ERR3    MNOTE 8,'IF - TEST LIST TOO SHORT'
         AGO   .EXIT
.ERR4    MNOTE 8,'IF - TEST LIST TOO LONG'
         AGO   .EXIT
.ERR5    MNOTE 8,'IF - INVALID CONNECTOR'
.EXIT    ANOP  ,
         MEND  ,
./ ADD NAME=EQUBC    0100-10260-10260-1641-00031-00031-00000-MACLIB
* MODIFIED 03-JUN-1989 TO ACT LIKE IEZBITS (MULTIPLE CALLS OK)
*          DATA SET AM010900   AT LEVEL 001 AS OF 10/28/75
*          DATA SET AM010900   AT LEVEL 002 AS OF 04/02/74
         MACRO ,
         EQUBC ,
         GBLA  &EQUBC
         AIF   (&EQUBC EQ 0).SETSW
         MEXIT ,
.SETSW   ANOP  ,
&EQUBC   SETA  1
         SPACE 2
H        EQU   2
L        EQU   4
E        EQU   8
NH       EQU   13
NL       EQU   11
NE       EQU   7
O        EQU   1
P        EQU   2
M        EQU   4
Z        EQU   8
NP       EQU   13
NM       EQU   11
NZ       EQU   7
NO       EQU   14
EQ       EQU   8
GT       EQU   2
LT       EQU   4
GE       EQU   11
LE       EQU   13
         MEND  ,
./ ADD NAME=FI       0100-10260-10260-1641-00011-00011-00000-MACLIB
*          DATA SET AM011000   AT LEVEL 001 AS OF 10/28/75
*          DATA SET AM011000   AT LEVEL 001 AS OF 06/28/74
         MACRO
&N       FI
         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB
         AIF   (&SEQ(&LEVEL) NE 4).CONT
&N       ELSE  END
         MEXIT
.CONT    ANOP
&N       ELSE  CONTINUE
         MEND
./ ADD NAME=IF       0100-10260-10260-1641-00103-00103-00000-MACLIB
* COPIED FROM FILE 078 OF SHARE MVS GROUP MODS TAPE, V29 (04/84)
*          DATA SET AM010500   AT LEVEL 002 AS OF 05/23/76
*          DATA SET AM010500   AT LEVEL 001 AS OF 10/28/75
*          DATA SET AM010500   AT LEVEL 001 AS OF 04/01/74
         MACRO ,
         IF    ,
         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB
         GBLA  &ELSEIF(10)
         LCLA  &N,&M,&S,&LAB1,&L,&I
         LCLC  &OP,&OPR
         LCLB  &TESTSW
         EQUBC ,             DEFINE CONDITIONS, IF NOT ALREADY DEFINED
.* AUTHOR.   DON HIGGINS.
.* DATE.     03/27/74.
.* REMARKS.  MACRO TO ALLOW STRUCTURED PROGRAMMING USING
.*           IF, THEN, ELSE, AND DO UP TO TEN LEVELS DEEP
.*           AND NO BRANCH INSTRUCTIONS.
.*
.*           EXAMPLE FORM.
.*               SAMPLE  SUBENTRY
.*                       IF (CLI,FLAG,TRUE,EQ)
.*                       THEN BEGIN
.*                            DO  WHILE,(CLC,A,B,NE)
.*                               PERFORM R100PROC,R190EXIT
.*                            DO END
.*                       THEN END
.*                       ELSE BEGIN
.*                            PERFORM R200LIST,R290EXIT
.*                       ELSE END
.*                       IF (CLI,SW,TRUE,EQ),AND,(SRC,R1,E)
.*                            PERFORM R300RPT,R390EXIT
.*                       ELSE CONTINUE
.*                       SUBEXIT
         AIF   (&LEVEL EQ 10).ERR1
&LEVEL   SETA  &LEVEL+1
&ELSEIF(&LEVEL) SETA 0
&SEQ(&LEVEL) SETA 1
&LAB     SETA  &LAB+1
&ELSE(&LEVEL) SETA &LAB
&N       SETA N'&SYSLIST
.NEXTAND ANOP
&TESTSW  SETB  0
.TEST    ANOP
&S       SETA  &S+1
         AIF   (&S GT &N).ERR2
&M       SETA  N'&SYSLIST(&S)
         AIF   (&M EQ 1).TESTEND
         AIF   (&M LT 2).ERR3
         AIF   (&M GT 5).ERR4
&I       SETA  2
&OPR     SETC  ''
&OP      SETC  '&SYSLIST(&S,1)'
         AIF   (&M GT 2).TESTOPR
         &OP
         AGO   .TESTEND
.TESTOPR ANOP
         AIF   ('&SYSLIST(&S,&I)'(1,1) NE '''').NOLIT
&L       SETA  K'&SYSLIST(&S,&I)
&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'(2,&L-2)
         AGO   .NEXTOPR
.NOLIT   ANOP
&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'
.NEXTOPR ANOP
&I       SETA  &I+1
         AIF   (&I EQ &M).TESTGEN
&OPR     SETC  '&OPR'.','
         AGO   .TESTOPR
.TESTGEN ANOP
         &OP   &OPR
.TESTEND ANOP
         AIF   (&TESTSW EQ 1).ORBC
.AMBC    ANOP
         BC    15-&SYSLIST(&S,&M),IF0&LAB
.CONNECT ANOP
&S       SETA  &S+1
         AIF   (&S GT &N).EXIT
&M       SETA  N'&SYSLIST(&S)
         AIF   (&M NE 1).ERR5  BAD CONNECTOR
         AIF   ('&SYSLIST(&S)' EQ 'AND').NEXTAND
         AIF   ('&SYSLIST(&S)' NE 'OR').ERR5  BAD CONNECTOR
.NEXTOR   ANOP
&LAB1    SETA  &LAB+1
         B     IF0&LAB1  SKIP TEST IF LAST ONE TRUE
IF0&LAB   EQU *          DO TEST IF LAST ONE FALSE
&LAB     SETA  &LAB+2
&ELSE(&LEVEL) SETA &LAB
&TESTSW  SETB  1
         AGO   .TEST
.ORBC    ANOP
         BC    15-&SYSLIST(&S,&M),IF0&LAB
IF0&LAB1 EQU *
         AGO   .CONNECT
.ERR1    MNOTE 8,'IF - LEVEL OVERFLOW'
         AGO   .EXIT
.ERR2    MNOTE 8,'IF - MISSING TEST LIST'
         AGO   .EXIT
.ERR3    MNOTE 8,'IF - TEST LIST TOO SHORT'
         AGO   .EXIT
.ERR4    MNOTE 8,'IF - TEST LIST TOO LONG'
         AGO   .EXIT
.ERR5    MNOTE 8,'IF - INVALID CONNECTOR'
.EXIT    ANOP
         MEND
./ ADD NAME=OD       0100-10260-10260-1641-00006-00006-00000-MACLIB
*          DATA SET AM011200   AT LEVEL 001 AS OF 10/28/75
*          DATA SET AM011200   AT LEVEL 001 AS OF 07/01/74
         MACRO
&N       OD
&N       DO    END
         MEND
./ ADD NAME=THEN     0100-10260-10260-1641-00030-00030-00000-MACLIB
*          DATA SET AM010600   AT LEVEL 001 AS OF 10/28/75
*          DATA SET AM010600   AT LEVEL 001 AS OF 04/01/74
         MACRO
         THEN  &OPT
         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB
.*             AUTHOR.   DON HIGGINS.
.*             DATE.     03/27/74.
.*             REMARKS.  MACRO TO ALLOW STRUCTURED PROGRAMMING USING
.*                       IF, THEN, ELSE, AND DO UP TO TEN LEVELS DEEP
.*                       AND NO BRANCH INSTRUCTIONS. SEE IF MACRO.
         AIF   (&LEVEL EQ 0).ERR0
         AIF   ('&OPT' EQ 'BEGIN').BEGIN
         AIF   ('&OPT' EQ 'END').END
         MNOTE 4,'THEN - INVALID OPERAND - IGNORED'
         AGO   .EXIT
.BEGIN   ANOP
         AIF   (&SEQ(&LEVEL) NE 1).ERR1
&SEQ(&LEVEL) SETA 2
         AGO   .EXIT
.END     ANOP
         AIF   (&SEQ(&LEVEL) NE 2).ERR2
&SEQ(&LEVEL) SETA 3
         AGO   .EXIT
.ERR0    MNOTE 8,'THEN - MISSING IF'
         AGO   .EXIT
.ERR1    MNOTE 4,'THEN BEGIN - OUT OF SEQUENCE'
         AGO   .EXIT
.ERR2    MNOTE 4,'THEN END - OUT OF SEQUENCE'
.EXIT    ANOP
         MEND
