{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012923000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1528436, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE838.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1528436, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1528436, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE838.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x19\\x04'", "DS1TRBAL": "b'\\xcf\\x96'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05\\xce\\x00\\x08\\x05\\xd0\\x00\\x03\\x00\\x1a'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04P\\x005\\x01\\x10&\\x9f\\x01\\x10&\\x9f\\x08I\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf0@@@'", "ispf": {"version": "04.80", "flags": 0, "createdate": "2010-09-26T00:00:00", "modifydate": "2010-09-26T08:49:35", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-480"}, "text": "REGULAR CBT TAPE - VERSION 480    FILE:  838\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT480.FILE838\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 20 MEMBERS COUNTED; CUMULATIVE SIZE IS 14,146 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   09/26/10    08:49:35    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE1": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x005\\x01\\x10&/\\x01\\x10&/\\t9\\x009\\x009\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-09-19T00:00:00", "modifydate": "2010-09-19T09:39:35", "lines": 57, "newlines": 57, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Re: Posted File 838 on Updates\nFrom:     Eugene Vogt <racfra2@bluewin.ch>\nDate:     Sun, 19 Sep 2010 12:55:20 +0200\nTo:       Sam Golob <sbgolob@cbttape.org>\n\nHi Sam\n\nHere is now the corrected version:\n\nCHANGES by Eugene Vogt:\n2010-09-017 FIXED SYSOU MVI ERROR\n2010-09-018 INSERTED ESA AND Z/OS RELATED MISSING TEXT UNITS\n            ALL CHANGES HAVE BEEN MARKED WITH EUGENE VOGT\n            BUT HAVE NOT BEEN TESTED.\n\nI tested Subsystems with subparms and it works ESA - z/OS .\n\nI stuffed all documentation found into ONE macro called CECDYN\n(at the bottom).\n\nI guess it is the most up-to-date MACRO concerning SVC 99 text\nunit generation found on CBT or the internet.\n\nIf there is as mentioned a new version around let me know so I\ncan cross check.\n\nSo paid my tribute I hope so anyway;)\n\nCheers\nEugene\n\n  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -\n\nOn 19.9.2010 7:14 Uhr, \"Sam Golob\" <sbgolob@cbttape.org> wrote:\n\n>> Hi Gene,\n>>\n>>    I posted File 838 on Updates.  You are welcome to make any\n>> changes, as you research, code, and test them.\n>>\n>>    Thanks much for bringing this subject to my attention.\n>>\n>>    All the best of everything to you and your family.\n>>\n>> Sincerely,    Sam\n>>\n>> P.S.  If you find anything else he's done, please send any\n>> references to them, so I can look.\n\n\nCECDYN\n\nContent-Type:\n application/octet-stream\nContent-Encoding:\n base64\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$README": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10&\\x0f\\x01\\x10&\\x0f\\x16(\\x00\\xb8\\x00\\xb8\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-09-17T00:00:00", "modifydate": "2010-09-17T16:28:00", "lines": 184, "newlines": 184, "modlines": 0, "user": "SBGOLOB"}, "text": "1                                                          CECDYN   1/4\n0+---------------------------------------------------------------------+\n |                                                                     |\n |       The accompanying programs, developed at Centerior Energy      |\n |  Corporation, are submitted for unrestricted distribution.  The     |\n |  programs have met a basic set of programming and documentation     |\n |  standards, but have not been tested in any formal fashion by       |\n |  Centerior Energy Corporation.  The user is expected to make the    |\n |  final evaluation as to the usefulness in their own environment.    |\n |                                                                     |\n |       Centerior Energy Corporation makes no warranty, expressed or  |\n |  implied, including, but not limited to, the implied warranties of  |\n |  merchantability and fitness for a particular purpose as to the     |\n |  documentation, function, or performance of these programs.         |\n |                                                                     |\n |       Acceptance and use of these programs constitutes a release    |\n |  from liability of Centerior Energy Corporation for any problems    |\n |  use of the programs may cause at the user's installation.          |\n |                                                                     |\n |       The programs are made available by Centerior Energy           |\n |  Corporation without charge or consideration.  Recipients are free  |\n |  to make the programs available to others in like manner.  They     |\n |  may not be sold.                                                   |\n |                                                                     |\n |       The assembler macros CECDYN, BREAK, and CONTINUE, and the     |\n |  example test program DUMPINFO were written by:                     |\n |                                                                     |\n |    Leslie J. Somos                                                  |\n |    Centerior Energy Corporation                                     |\n |    Mail Stop IND-149                                                |\n |    6200 Oak Tree Boulevard                                          |\n |    Independence, Ohio 44131                                         |\n |                                                                     |\n |       The assembler macros DO, OD, IF, ELSE, ELSEIF, FI, THEN,      |\n |  and EQUBC, were contributed to the SHARE MVS Group Modification    |\n |  Tape, by:                                                          |\n |    Donald S. Higgins                                                |\n |    Florida Power Corporation                                        |\n |    P.O.Box 14042       B-3-B                                        |\n |    St. Petersburg, FL 33733                                         |\n |                                                                     |\n |                                                                     |\n |       Centerior Energy Corporation does not guarantee to keep any   |\n |  material provided up to date, nor does it guarantee to provide     |\n |  any corrections or extensions described by the user or             |\n |  corrections or extensions made in the future by Centerior Energy   |\n |  Corporation itself.                                                |\n |                                                                     |\n +---------------------------------------------------------------------+\n-                                                            21-APR-1993\n1                                                          CECDYN   2/4\n BACKGROUND\n0    I work in the Technical Services department of Centerior Energy\n Corporation, an electric utility located in northern Ohio.\n-    The IBM manual describing Dynamic Allocation (SVC 99) has page\n upon page of text, listing all the text units available.  (For the\n release of MVS that I work with, the manual is GC28-1150 MVS/Extended\n Architecture System Programming Library: System Macros and Facilities\n Volume 1.)\n0    While I was writing a program that made multiple calls to SVC 99,\n I noticed that I repeated a small segment of code, with slight\n variations.  I decided to fold the intelligence necessary into a\n macro, so I would not need to use my (error-prone) memory as much.\n That macro is CECDYN.\n-IMPLEMENTATION\n0    Because CECDYN uses SETC symbol names longer than 7 characters,\n it can only be used with IEV90 (the H-level assembler), or higher.\n0    CECDYN has profuse internal comments.  It also has a DEBUG\n facility, which can be turned on if you suspect it is processing\n incorrectly.  The debugging is turned on by coding \" CECDYN DEBUG \".\n Also, any detected internal error turns on debugging.\n0    The information listed in the IBM manual for each text unit key\n is encoded in an internal table in CECDYN.\n0    CECDYN calls itself multiple times, like an assembler source-\n level subroutine.  It was coded this way, so that CECDYN is a single\n unit, and not multiple macros.\n     Only keyword parameters are used in user calls to CECDYN, no\n positional parameters.  Positional parameters are only used in\n recursive inner macro self-calls.\n     There are 5 internal entry points, and a branch table at label\n .SUBROUT .  The internal entry points and their functions are:\n .CMT2   give a value to symbol &CEC#CMT2VAL, displayed in MNOTEs;\n .CREAT  actually generate lines of code;\n .DEBUG  either turn on debugging, or display debugging messages;\n .DOKEY  check a text unit key against internal information;\n .MNOTE  actually issue all MNOTEs.\n     The 'internal table' of text units is implemented as a series of\n calls to the .DOKEY subroutine, within a loop that looks at each\n sublist entry in the TEXT parameter.  Each call to the .DOKEY\n subroutine encodes the processing necessary for a particular text unit\n key, and if it matches the key being processed, also turns on a flag\n that short-circuits scanning the following calls to the .DOKEY\n subroutine.\n1                                                          CECDYN   3/4\n EXAMPLES\n0    The IBM manual referred-to above has an example of a dynamic\n allocation request to allocate SYS1.LINKLIB with a status of SHARE.\n The corresponding code, using CECDYN, is:\n-DYN   CSECT ,\n       USING *,15\n       STM   14,12,12(13)\n       BALR  12,0\n BEGIN DS    0H\n       USING BEGIN,12\n * (All names generated by the CECDYN macro will begin with 'ABC'.)\n       LA    0,L'ABCDSECT  AMOUNT OF STORAGE REQUIRED FOR THIS REQUEST.\n       GETMAIN R,LV=(0)    GET THE STORAGE NECESSARY FOR THE REQUEST.\n       LR    8,1           SAVE THE ADDRESS OF THE RETURNED STORAGE.\n       CECDYN PREFIX=ABC,        All names generated begin with 'ABC'\n                MF=(E,(8)),      Build the parameter list here\n                VERB=AL,   SET THE VERB CODE TO ALLOCATION FUNCTION.\n                TEXT=((DSNAM,'SYS1.LINKLIB'),     FIRST TEXT UNIT\n                (STATS,SHR),                      SECOND TEXT UNIT\n                (RTDDN))                          THIRD TEXT UNIT\n       DYNALLOC            INVOKE SVC 99 TO PROCESS THE REQUEST.\n       USING ABCDSECT,8          All the ABC- names are found here\n * The returned DDNAME is found at label ABCRTDDN\n       LM    14,12,12(13)\n       BR    14            RETURN TO CALLER.\n       END\n-\n_    There are also examples in CECDYN itself, at the end, where they\n will not interfere with the normal functioning of the macro.\n1                                                          CECDYN   4/4\n EXAMPLES\n0    When the supplied test program DUMPINFO is run with the supplied\n JCL:\n //GO2      EXEC PGM=*.LINK2.SYSLMOD\n //SYSUDUMP DD  SYSOUT=&SYSOUT,DCB=DSORG=PSU\n //INTRDR   DD  SYSOUT=(,INTRDR)\n //OL#CT#DL DD  DSN=*.LINK2.SYSLMOD,DISP=(OLD,CATLG,DELETE),\n //             DCB=DSORG=IS,\n //             UNIT=SYSDA,VOL=REF=*.LINK2.SYSLMOD\n //SH#DL#CT DD  DSN=*.GO.STEPLIB,DISP=(SHR,DELETE,CATLG),\n //             DCB=DSORG=DAU,\n //             UNIT=SYSDA,VOL=REF=*.GO.STEPLIB\n //NW#UC#KP DD  DSN=&&JUNK(@#$@#$),DISP=(NEW,UNCATLG,KEEP),\n //             DCB=DSORG=CX,\n //             UNIT=SYSDA,SPACE=(CYL,1)\n //DUMMY#DA DD  DUMMY,DCB=DSORG=DA\n //SYSLIB   DD  DSN=SYS1.MACLIB,DISP=(SHR,KEEP,KEEP)\n //         DD  DSN=&&CONCAT(MD#PS#UC),DISP=(MOD,PASS,UNCATLG),\n //             DCB=DSORG=POU,\n //             UNIT=SYSDA,SPACE=(TRK,(1,,1))\n //SYSIN    DD  *\n-then the results should resemble:\n0DUMPINFO (ASM 04/21/93 14.16) CENTERIOR JOB 7678  M831CDYN  GO2\n0RELNO DDN     DSN                                         MEM      STA    NDP\n 0001 PGM=*.DD SYS93111.T141625.RA000.M831CDYN.TEMPLOAD    DUMPINFO 01=OLD\n08=KE\n 0002 SYSUDUMP JES2.JOB07678.SO000115                               02=MOD\n04=DE\n 0003 INTRDR   JES2.JOB07678.SO000116                               02=MOD\n04=DE\n 0004 OL#CT#DL SYS93111.T141625.RA000.M831CDYN.TEMPLOAD    DUMPINFO 01=OLD\n10=PA\n 0005 SH#DL#CT SYS93111.T141625.RA000.M831CDYN.TEMPLOAD    DUMPINFO 08=SHR\n04=DE\n 0006 NW#UC#KP SYS93111.T141625.RA000.M831CDYN.JUNK        @#$@#$   04=NEW\n10=PA\n 0007 DUMMY#DA NULLFILE                                             04=NEW\n04=DE\n 0008 SYSLIB   SYS1.MACLIB                                          08=SHR\n08=KE\n 0009          SYS93111.T141625.RA000.M831CDYN.CONCAT      MD#PS#UC 02=MOD\n10=PA\n 000A SYSIN    JES2.JOB07678.SI000106                               04=NEW\n04=DE\n 000B SYSPRINT JES2.JOB07678.SO000117                               02=MOD\n04=DE\n0LST-INDICATE LAST: 80,LAST.\n STA - DSET STATUS: 01,=OLD; 02,=MOD; 04,=NEW; 08,=SHR.\n NDP - NORMAL DISP: 01,=UNC; 02,=CAT; 04,=DEL; 08,=KEE; 10,=PAS.\n CDP - COND\"L DISP: 01,=UNC; 02,=CAT; 04,=DEL; 08,=KEE; 10,=PAS.\n ORG - ORGANIZATION: 0004,=TR ; 0008,=VSA; 0020,=TQ ; 0040,=TX ; 0080,=GS ;\n0200\n ORG - ORGANIZATION: 2000,=DA ; 2100,=DAU; 4000,=PS ; 4100,=PSU; 8000,=IS ;\n8100\n TYP - TYPE: 80,=DUMM; 40,=TERM; 20,=SYSI; 10,=SYSO.\n ATT - BIT 0=PERM'LY CONCAT'D; BIT 1=IN USE; BIT 2=PERM'LY ALLOCATED; BIT\n3=CONV\n1/*\n //* REFER M831.SOMOS.TEXT(CECDYN) AS OF 21-APR-1993 AT 16:45\n //\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$OBIT": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x10&/\\x01\\x10&/\\x002\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-09-19T00:00:00", "modifydate": "2010-09-19T00:32:54", "lines": 15, "newlines": 15, "modlines": 0, "user": "SBGOLOB"}, "text": "LESLIE J. SOMOS\n\n (Leslie was from Cleveland before, and I had heard of some of\n  his work in the past.  When I looked him up, unfortunately\n  this is what I found....SBG)\n\n LESLIE J. SOMOS, age 57. Beloved husband of 28 years to\n Kathryn L. Bacon; son of late Sandor and Maria Somos; brother of\n Michael and Neal (Jackie). Passed away April 10, 2010 at his\n home in South Berwick, Maine. A memorial celebration of Leslie's\n life will be held at the Holiday Inn, 6001 Rockside Rd.,\n Independence, OH on SATURDAY, JUNE 19, 1-3 P.M. See also\n www.caringbridge.org (website \"ljsomos\").\n\nPublished in The Plain Dealer on June 13, 2010\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE838": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04P\\x00)\\x01\\x10&\\x9f\\x01\\x10&\\x9f\\x08I\\x00 \\x00 \\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf0@@@'", "ispf": {"version": "04.80", "flags": 0, "createdate": "2010-09-26T00:00:00", "modifydate": "2010-09-26T08:49:29", "lines": 32, "newlines": 32, "modlines": 0, "user": "CBT-480"}, "text": "//***FILE 838 is an original post by Leslie J. Somos in the C370-L  *   FILE 838\n//*           list from March 11, 1994.  This post contains his     *   FILE 838\n//*           CECDYN macro and supporting materials to dynamically  *   FILE 838\n//*           allocate a file and self-generate the parameters.     *   FILE 838\n//*           See member CECDYNRW in this pds for the original      *   FILE 838\n//*           post that he made on C370-L.                          *   FILE 838\n//*                                                                 *   FILE 838\n//*           Unfortunately, Leslie Somos has passed away.  This    *   FILE 838\n//*           file will remain as a tribute to him and to his work. *   FILE 838\n//*           We will try and add any additional materials we find  *   FILE 838\n//*           from him, to this file as well.                       *   FILE 838\n//*                                                                 *   FILE 838\n//*           An updated version of CECDYN was supplied by Eugene   *   FILE 838\n//*           Vogt, which accounts for more newly supported text    *   FILE 838\n//*           units.  The original version is renamed:  CECDYNO.    *   FILE 838\n//*           Except as marked, all other members were supplied     *   FILE 838\n//*           from Leslie Somos' original version.                  *   FILE 838\n//*                                                                 *   FILE 838\n//*       Subject:        Re: Program to dynamically alloc a file   *   FILE 838\n//*       From:   \"Leslie J. Somos\" <\u00ddlog in to unmask\u00a8>            *   FILE 838\n//*       Reply-To:       Leslie J. Somos                           *   FILE 838\n//*       Date:   Fri, 11 Mar 1994 22:58:14 GMT                     *   FILE 838\n//*       Content-Type:   text/plain                                *   FILE 838\n//*                                                                 *   FILE 838\n//*           Please address questions to either Sam Golob or       *   FILE 838\n//*           Eugene Vogt.                                          *   FILE 838\n//*                                                                 *   FILE 838\n//*       email:  sbgolob@cbttape.org      or                       *   FILE 838\n//*               sbgolob@attglobal.net                             *   FILE 838\n//*                                                                 *   FILE 838\n//*               Eugene Vogt <racfra2@bluewin.ch>                  *   FILE 838\n//*                                                                 *   FILE 838\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BREAK": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10&\\x0f\\x01\\x10&\\x0f\\x16A\\x00\\x1c\\x00\\x1c\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-09-17T00:00:00", "modifydate": "2010-09-17T16:41:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    BREAK ,\n.* DATE.     28-JUL-1989\n.* REMARKS.  THIS MACRO WORKS WITH THE MACROS WRITTEN BY DON HIGGINS,\n.*          FOUND ON FILE 078 OF SHARE MVS GROUP MODS TAPE, V29 (04/84)\n.*  SEE CASE,DOCASE,DOMACRO,EQUBC,ELSE,ELSEIF,ESAC,ESACOD,FI,IF,OD;\n.*  AND CONTINUE.\n.***************\n.* NOTE -- THIS MACRO WILL ONLY WORK WHEN IT IS IN A ONE-LEVEL IF\n.*        INSIDE A DO-LOOP -- FOR INSTANCE,\n.*                     DO UNTIL,(...CONDITION...)\n.*                       ...\n.*                       IF (..OTHER.CONDITION..)\n.*                         BREAK\n.*                       FI\n.*                       ...\n.*                     OD\n.*\n.* (THIS RESTRICTION IS BECAUSE THE DO MACRO AND THE IF MACRO\n.*  USE THE SAME ARRAY, &ELSE(10), TO STORE THEIR INFORMATION.\n.*  SOMEDAY WE'LL SPLIT THEM, AND THEN YOU CAN CODE BREAK ANYWHERE.)\n.***************\n         GBLA  &DO(10),&DOSEQ(10),&DOLVL,&DOLAB\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n         LCLA &LCLA\n&LCLA    SETA  &LEVEL-1\n&NAME    B     IF0&ELSE(&LCLA)     EXIT FROM INNERMOST ENCLOSING LOOP\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CECDYN": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x10\\x01\\x10&\\x9f\\x01\\x10&\\x9f\\x08F\\x0b\\xa1\\x0b\\xa1\\x00\\x02\\xc5`\\xe5\\xd6\\xc7\\xe3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-09-26T00:00:00", "modifydate": "2010-09-26T08:46:10", "lines": 2977, "newlines": 2977, "modlines": 2, "user": "E-VOGT"}, "text": "         MACRO ,\n&NAME    CECDYN &VERB=,&FLG11=,&FLG21=,&FLG22=,&TEXT=,&PREFIX=,&MF=I,  X\n               &LIST=Y,                                                X\n               &POS1,&POS2,&POS3,&POS4,&POS5,&POS6,&POS7,&POS8,&POS9,  X\n               &POS10\n.* NOTE -- ASA CARRIAGE CONTROL CHARACTERS IN COLUMN 71 >>>>>>>>>>>>>>\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70\n.*-- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- -\n.*\n.* MACRO NAME = CECDYN\n.*\n.* (C) COPYRIGHT CENTERIOR ENERGY CORPORATION 1988,1991\n.*\n.*-- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- -\n.* The documentation on how to use this macro can be found\n.* at label \".DOCPART ANOP  ,\"\n.* I put it there so everything is within one 'file'.\n.*\n.*-- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- -\n.*\n.* CHANGES by Eugene Vogt:\n.* 2010-09-17  FIXED SYSOU MVI ERROR\n.* 2010-09-18  INSERTED ESA AND Z/OS RELATED MiSSING TEXT UNITS\n.*             ALL CHANGES HAVE BEEN MARKED WITH EUGENE VOGT\n.*             BUT HAVE NOT BEEN TESTED.\n.* 2010-09-20  INSERTED  AT LABEL \".FLAG1B  ANOP  ,\":\n.*             THE \"AGO   .FLAG1C\"\n.*             to fix MNOTE 12 HIBIT error.\n.* 2010-09-26  FIXED BAD CONTINUATION OF INSERTED NEW DEFINITIONS\n.*             WHICH ONLY SHOWED UP DURING FURTHER TESTS.\n.*\n.*-- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- -\n.*\n.* SADLY THE AUTHOR OF THIS GREAT MACRO PASSED AWAY.\n.*\n.* I TRIED MY BEST TO PROPERLY INSERT ALL NEW SVC 99 TEXT UNITS BUT\n.* I HAVE NO ENVIRONMENT TO TEST EM ALL.\n.*\n.* IF YOU AS A USER COME AROUND TO DETECT ANY ERRORS PLEASE LET US\n.* KNOW DIRECTLY RACFRA2@BLUEWIN.CH OR CONTACT SAM GOLOB AT\n.* WWW.CBTTAPE.ORG\n.*\n.*\n.* MANY THANKS TO THE AUTHOR:\n.* Leslie J. Somos\n.* Centerior Energy Corporation\n.* Mail Stop IND-149\n.* 6200 Oak Tree Boulevard\n.* Independence, Ohio 44131\n.*\n.*\n.*\n.*   +-------------------------------------------------------+\n.*   |                                                       |\n.*   |   THESE MATERIALS ARE PROVIDED FOR DISTRIBUTION TO    |\n.*   |   INTERESTED THIRD PARTIES ON A NOT-FOR-PROFIT BASIS. |\n.*   |                                                       |\n.*   |   THE CONTENTS OF THIS PACKAGE MAY BE FURTHER COPIED  |\n.*   |   AND DISTRIBUTED, PROVIDED CREDIT IS GIVEN TO        |\n.*   |   CENTERIOR ENERGY CORPORATION AND THAT NO CHARGE IS  |\n.*   |   MADE EXCEPT TO RECOVER THE COSTS OF SUCH            |\n.*   |   DISTRIBUTION.                                       |\n.*   |                                                       |\n.*   |   NO WARRANTY AS TO THE COMPLETENESS OR CORRECTNESS   |\n.*   |   OF THE SOFTWARE IS EXPRESSED OR IMPLIED BY          |\n.*   |   CENTERIOR ENERGY CORPORATION.                       |\n.*   |                                                       |\n.*   |                                                       |\n.*   |                                                       |\n.*   +-------------------------------------------------------+\n.*\n.*-- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- -\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70\n.*\n.* FUNCTION = BUILD PARAMETER LIST FOR CALL TO DYNALLOC MACRO (SVC99)\n.*\n.*  THIS MACRO PROCESSES DIFFERENTLY THAN IBM-SUPPLIED MACROS, BECAUSE\n.* IT GENERATES A DSECT FOR ITS PARAMETER LIST, AND ALL MOVES INTO THE\n.* PARAMETER LIST ARE DONE USING THE NAMES DEFINED IN THE DSECT.\n.*\n.* IF &PREFIX IS SPECIFIED, SAVE IT IN GLOBAL &CEC#P (3 CHARS OR LESS)\n.*                          ELSE GENERATE A UNIQUE 3-CHARACTER &CEC#P.\n.* IF MF=E, THEN &PREFIX COULD REPEAT A PREVIOUSLY-SPECIED &PREFIX\n.*          ELSE &PREFIX MUST BE UNIQUE.\n.*\n.* FURTHER PROCESSING IS DONE IN MULTIPLE PASSES:\n.*   IF MF=L, 1 PASS -- CREATE DC.S (DEFINE CONSTANT) FOR ALL OPERANDS\n.*                      WITH SUPPLIED VALUES FOR NON-REGISTER OPERANDS\n.*                      AND WITH VALUES OF 0 FOR REGISTER OPERANDS;\n.*            AND MEXIT.\n.*   IF MF=I, 2 PASSES -- 1ST PASS EXACTLY LIKE MF=L;\n.*                        2ND PASS, MOVE REGISTER OPERANDS TO STORAGE;\n.*            AND MEXIT.\n.*   IF MF=E, 2 PASSES -- 1ST PASS, DEFINE &CEC#P.DSECT, IF VALUE OF\n.*                        &PREFIX WAS NOT ENCOUNTERED BEFORE;\n.*                     -- 2ND PASS, MOVE ALL OPERANDS TO STORAGE,\n.*                        BOTH REGISTER AND NON-REGISTER;\n.*            AND MEXIT.\n.*\n.*  THE VALUES THE USER CAN CODE FOR VERB,FLG11,FLG21,FLG22 ARE THE\n.* NAMES FROM MACRO IEFZB4D0, MINUS THE PREFIX 'S99'.  THE VALUES ARE\n.* NOT CHECKED, BUT INCORRECT VALUES WILL CAUSE ASSEMBLY ERRORS\n.* BECAUSE THEN THE GENERATED NAMES ARE NOT DEFINED BY IEFZB4D0.\n.*  THE ADVANTAGE OF NOT CHECKING IS THAT, IF IBM DEFINES NEW VALID\n.* VALUES IN MACRO IEFZB4D0, NO UPDATE OF THIS MACRO IS NECESSARY TO\n.* RECOGNIZE AND PROCESS THE NEW VALUES.\n.*  AS OF 14-FEB-1991, VALID VALUES DEFINED IN IEFZB4D0 ARE:\n.* VERB COULD BE AL/UN/CC/DC/RI/DN/IN (CHOOSE ONLY ONE).\n.* FLG11 COULD BE ONCNV, NOCNV, NOMNT, JBSYS, CNENQ.\n.* FLG21 COULD BE WTVOL,WTDSN,NORES,WTUNT,OFFLN,TIONQ,CATLG,MOUNT.\n.* FLG22 COULD BE UDEVT, PCINT, DYNDI.\n.* FOR THE FLG.S, SPECIFY MULTIPLE VALUES WITHIN PARENTHESES.\n.*\n.*  TEXT UNITS ARE SPECIFIED IN THE FORM (KEY,<(VALUE0<,VALUE1...>)>).\n.* IF A TEXT UNIT KEY IS SUPPLIED FOR A VERB FOR WHICH IT IS NOT\n.* VALID, IT IS NOT CHECKED BY THIS MACRO, BUT IT CAUSES AN ASSEMBLY\n.* ERROR BECAUSE THEN THE GENERATED KEY NAME IS NOT DEFINED BY\n.* IEFZB4D2.\n.*  EACH KEY NAME IS 'D' FOLLOWED BY THE 2-CHAR VERB NAME, FOLLOWED\n.* BY THE TEXT UNIT NAME.\n.*\n.*\n.* EXAMPLE OF CALLING SEQUENCE:\n.*         CECDYN PREFIX=X01,MF=(E,WORKAREA),                       X\n.*               VERB=AL,FLG11=(ONCNV,NOMNT),                       X\n.*               TEXT=((DDNAM,DSCL8),(SYSOU,'A'),RTORG)\n.* IF ANY TEXT UNITS SHOULD RETURN VALUES, THE VALUES WILL BE FOUND\n.* IN FIELDS LABELLED WITH THE 3 CHARACTERS SPECIFIED BY &PREFIX,\n.* PLUS THE TEXT UNIT'S NAME.  THE ABOVE CALL WILL DEFINE ORDINARY\n.* LABEL X01RTORG.\n.*\n.*   IF &PREFIX IS REPEATED ACROSS CALLS, THE DSECT IS NOT DUPLICATED,\n.* BUT THE EXACT SAME TEXT UNITS MUST BE SPECIFIED AS WERE ON THE\n.* ORIGINAL CALL.  (OR, AT LEAST, NO TEXT UNITS THAT DID NOT APPEAR\n.* IN THE ORIGINAL CALL.  THAT IS, FEWER COULD BE SPECIFIED.)  THE\n.* FLAG FIELDS CAN BE DIFFERENT THAN ON THE ORIGINAL CALL.\n.*\n.* GLOBALS\n         GBLA  &CEC#CMT1COL  DEFAULT COLUMN FOR COMMENT 1 FIELD\n         GBLA  &CEC#CMT2COL  DEFAULT COLUMN FOR COMMENT 2 FIELD\n         GBLA  &CECCMT1COL   CURRENT COLUMN FOR COMMENT 1 FIELD\n         GBLA  &CECCMT2COL   CURRENT COLUMN FOR COMMENT 2 FIELD\n         GBLC  &CEC#CMT2VAL  TEXT AT RIGHT-HAND END OF GENERATED STMTS\n         GBLC  &CEC#DBG#HDR  TEXT AT LEFT-HAND OF DEBUGGING MNOTES\n         GBLB  &CEC#DEBUG    Q. ISSUE MSG.S ABOUT INTERNAL PROCESSING?\n         GBLA  &CEC#FLAG(5)  CONTROLS MULTIPLE PASSES WITHIN .COMMON\n         GBLB  &CEC#KEYDONE  Q. DONE RECOGNIZING TEXT UNIT?\n         GBLB  &CEC#NEWP     Q. WE HAD TO ADD &CEC#P TO &CEC#PTBL?\n         GBLB  &CEC#NOT1ST   Q. HAS CECDYN EVER BEEN CALLED?\n         GBLC  &CEC#P        3-CHAR VALUE USED IN GENERATED CODE\n         GBLA  &CEC#PMAX     MAXIMUM ENTRIES SAVED IN &CEC#PTBL(100)\n         GBLC  &CEC#PTBL(100) SAVES ALL UNIQUE &CEC#P.S EVER SEEN\n         GBLB  &CEC#PUSHED   Q. DO WE NEED TO POP PRINT AT MEXIT?\n         GBLA  &CEC#SYSNDX   HOW MANY TIMES CECDYN HAS BEEN CALLED\n         GBLB  &CEC#XLAT     Q. TABLE CODED IN &POS9 OF .DOKEY CALL?\n         GBLC  &CEC#3CH      UNIQUE, GENERATED INTERNALLY\n.* LOCALS\n         LCLA  &I,&J,&LCLA,&LCLA2,&LCLA3\n         LCLA  &I1,&I10,&IIX\n         LCLC  &KEY,&VALUE\n         LCLB  &LCLB,&LCLB1\n         LCLC  &LBL,&OPR,&OPD,&CMT\n         LCLC  &LCLC,&LCLC2,&LCLC3\n         LCLC  &DUP,&TYP,&LGH,&VAL\n         LCLA  &DV,&LV\n         LCLC  &DX,&LX,&VV\n.*\n&NX      SETC  '&SYSNDX'               DEFINE SHORTER NAME FOR LATER\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n         AIF   (&CEC#NOT1ST).NOT1STA\n         MNOTE '* MACRO CECDYN, LAST CHANGE 14-JAN-1993 11.31'\n.* CHANGE LOG: (NEWEST CHANGE ON TOP)\n.* 14-JAN-1993  L.SOMOS  AFTER .CLEAR, CHECK FOR '*' TO SET HI-BIT.\n.* 14-MAR-1991  L.SOMOS  CORRECT PROCESSING OF REGISTER OPERANDS.\n.NOT1STA ANOP  ,\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70\n.*\n         AIF   (&CEC#NOT1ST).NOT1STB\n.* FOLLOWING PROCESSING DONE ONLY ONCE PER SOURCE MODULE\n.*\n&CEC#CMT1COL SETA 33         COLUMN OF COMMENTS ON GENERATED LINES\n&CEC#CMT2COL SETA 63         COLUMN OF COMMENTS ON GENERATED LINES\n&CEC#DEBUG   SETB 0          TURN OFF <--------------\n.* TURN ON BY CALLING WITH ONLY 1 POSITIONAL PARAMETER, DEBUG\n.*\n&CEC#NOT1ST SETB 1           ABOVE PROCESSING NEVER REPEATED AGAIN\n.NOT1STB ANOP  ,\n.*\n.* THIS MUST COME AFTER .NOT1STB:\n         AIF   (0 NE N'&SYSLIST).SUBROUT   GO CHECK SUBROUTINE CALLS\n.* ONLY KEYWORD PARMS ARE USED IN EXTERNAL CALLS, NO POSITIONAL PARMS.\n.* POSITIONAL PARMS ARE ONLY USED IN RECURSIVE INNER MACRO SELF-CALLS.\n.*\n&CEC#SYSNDX SETA 1+&CEC#SYSNDX    COUNT NON-SUBROUTINE CALLS TO CECDYN\n.*\n         MNOTE                                      '* MACRO CECDYN IS X\n               (C) COPYRIGHT CENTERIOR ENERGY CORPORATION 1988,1991   '\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.* SET THE VALUE OF &CEC#3CH\n&Q1      SETA  (&CEC#SYSNDX-1)/36      1ST QUOTIENT\n&R1      SETA  (&CEC#SYSNDX-1)-36*&Q1  1ST REMAINDER, FOR 3RD CHAR\n&Q2      SETA  &Q1/36                  2ND QUOTIENT\n&R2      SETA  &Q1-36*&Q2              2ND REMAINDER, FOR 2ND CHAR\n&Q3      SETA  &Q2/26                  3RD QUOTIENT\n&R3      SETA  &Q2-26*&Q3              3RD REMAINDER, FOR 1ST CHAR\n.* R1 AND R2 ARE ALWAYS 0 THROUGH 35   (1+&R? IS ALWAYS 1 THRU 36)\n.* R3 IS ALWAYS 0 THROUGH 25       (10+1+&R3 IS ALWAYS 11 THRU 36)\n&LCLC    SETC  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' LENGTH 36\n&CEC#3CH SETC  '&LCLC'(10+1+&R3,1).'&LCLC'(1+&R2,1).'&LCLC'(1+&R1,1)\n.* &CEC#3CH IS UNIQUE FOR &CEC#SYSNDX LE 26*36*36 = 33696.\n.* &CEC#3CH ALWAYS BEGINS WITH ALPHA, NEXT 2 CHARS ARE ALPHANUMERIC.\n.* R1 CHANGES MOST QUICKLY, R2 NEXT, AND R3 CHANGES SLOWEST.\n.* &CEC#3CH RANGES THROUGH A00,A01...A09,A0A,A0B...A0Z,\n.*                         A10,A11...A19,A1A,...A1Z, A20...A29, ETC.\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.* SET THE VALUE OF &CEC#P\n         AIF   (T'&PREFIX EQ 'O').SETP WE MUST SUPPLY IT\n&CEC#P   SETC  '&PREFIX'\n         AIF   (K'&PREFIX GE 1 AND K'&PREFIX LE 3).PREFIXD ALL DONE\n&CEC#P   SETC  '&PREFIX'(1,3)          ONLY FIRST THREE CHARACTERS\n         CECDYN MNOTE,'ONLY FIRST 3 CHARACTERS OF PREFIX ARE USED, ',  X\n               '\"&CEC#P\" INSTEAD OF \"&PREFIX\"'\n         AGO   .PREFIXD                  ALL DONE\n.SETP    ANOP  , NO VALUE SPECIFIED, SO CREATE ONE.\n&CEC#P   SETC  '&CEC#3CH'\n.PREFIXD ANOP  ,\n.*\n         AIF   ('&CEC#P' EQ '&CEC#3CH').PEQ3CH\n         CECDYN MNOTE,'*        PREFIX=&PREFIX WAS SPECIFIED -- ',     X\n               'ELSE, PREFIX WOULD HAVE BEEN SET TO \"',&CEC#3CH,       X\n               '\", GENERATED FROM CEC#SYSNDX=&CEC#SYSNDX..'\n.PEQ3CH  ANOP  ,\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.* SAVE &CEC#P IN &CEC#PTBL\n&CEC#NEWP SETB 0                       CLEAR FLAG\n&I       SETA  1\n.NEXTI01 ANOP  ,\n         AIF   ('&CEC#PTBL(&I)' EQ '&CEC#P').OLDP YES, WE FOUND IT\n.ADVI01  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE &CEC#PMAX).NEXTI01\n.* OK, IT HAS NEVER BEEN SEEN BEFORE\n&CEC#NEWP SETB 1                       SET FLAG FOR LATER CHECKING\n&CEC#PMAX SETA &CEC#PMAX+1             INCREASE COUNTER\n&CEC#PTBL(&CEC#PMAX) SETC '&CEC#P'     PLACE INTO TABLE\n.OLDP    ANOP  ,\n.* NOTE - THE ABOVE CODE DOES A SUPERFLUOUS COMPARISON WHEN\n.*       &CEC#PMAX==0, BUT THIS DOES NOT AFFECT CORRECT PROCESSING.\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.* CHECK &LIST PARAMETER FOR ERRORS.\n         AIF   ('&LIST' EQ 'YES' OR '&LIST' EQ 'NO').LISTOK\n         AIF   ('&LIST' EQ 'Y' OR '&LIST' EQ 'N').LISTOK\n         MNOTE 12,'LIST=&LIST INVALID, LIST=YES ASSUMED'\n.LISTOK  ANOP  ,\n         AIF   ('&LIST' EQ 'NO').LISTNO\n         AIF   ('&LIST' EQ 'N').LISTNO\n         AGO   .LISTEX\n.LISTNO  ANOP  ,\n         AIF   (&CEC#PUSHED).PUSHED\n         PUSH  PRINT         PUSH PRINT\n&CEC#PUSHED SETB 1\n.PUSHED  ANOP  ,\n         PRINT OFF           LIST=NO WAS REQUESTED\n.LISTEX  ANOP  ,\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.* CHECK &MF PARAMETER FOR ERRORS.\n         AIF   ('&MF' EQ '').MFOK\n         AIF   ('&MF' EQ 'L' OR '&MF' EQ 'I').MFOK\n         AIF   ('&MF(1)' EQ 'E').MFOK\n         MNOTE 12,'MF=&MF INVALID, NORMAL FORM ASSUMED'\n.MFOK    ANOP  ,\n&LCLC    SETC  'CECDYN -- SECOND PARAM REQUIRED FOR MF=E'\n         AIF   (N'&MF LT 2 AND ('&MF(1)' EQ 'E')).ERRMAIN\n&LCLC    SETC  'CECDYN -- TOO MANY PARAMS FOR MF'\n         AIF   (N'&MF GT 2 AND ('&MF(1)' EQ 'E')).ERRMAIN\n         AIF   ('&MF(1)' EQ 'L').TYPEL\n         AIF   ('&MF(1)' EQ 'E').TYPEE\n         AGO   .TYPEI              ASSUME NORMAL FORM\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.ERRMAIN MNOTE '&LCLC'       ISSUE MESSAGE AND EXIT\n         AGO   .MEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.MEXIT   ANOP  ,             USE THIS EXIT FROM MAINLINE\n         AIF   (NOT &CEC#PUSHED).NOPOP1 THEN WE DON'T NEED TO UN-DO IT.\n         POP   PRINT\n&CEC#PUSHED SETB 0\n.NOPOP1  ANOP  ,\n&CEC#DEBUG SETB 0      TURN OFF\n         MEXIT ,\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.TYPEI   ANOP  , NORMAL FORM\n         CECDYN DEBUG,.TYPEI SAVE HEADING FOR DEBUG MESSAGES\n         CNOP  0,4           ALIGN LIST TO FULLWORD\n         BAS   1,IGX&NX      BRANCH AROUND LIST, POINT REG1 TO LIST\n&CEC#FLAG(1) SETA 1,0,0,0,1  YES DC, NO DS, NO REG, NO MOVES, COMMON1\n         AGO   .COMMON\n.COMMON1 ANOP  ,\nIGX&NX   DS    0H            BRANCHED AROUND LIST\n&CEC#FLAG(1) SETA 0,0,1,0,2  NO DC, NO DS, YES REG, NO MOVES, COMMON2\n         AGO   .COMMON\n.COMMON2 ANOP  ,\n         AGO   .MEXIT\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.TYPEL   ANOP  , LIST FORM\n         CECDYN DEBUG,.TYPEL SAVE HEADING FOR DEBUG MESSAGES\n&CEC#FLAG(1) SETA 1,0,0,0,3  YES DC, NO DS, NO REG, NO MOVES, COMMON3\n         AGO   .COMMON\n.COMMON3 ANOP  ,\n         AGO   .MEXIT\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.TYPEE   ANOP  , EXECUTE FORM\n         CECDYN DEBUG,.TYPEE SAVE HEADING FOR DEBUG MESSAGES\n.*\n.* CREATE A DSECT:\n&CEC#FLAG(1) SETA 0,1,0,0,4  NO DC, YES DS, NO REG, NO MOVES, COMMON4\n         AGO   .COMMON\n.COMMON4 ANOP ,\n.*\n         AIF   ('&MF(2)'(1,1) EQ '('             AND                   X\n               '&MF(2)'(K'&MF(2),1) EQ ')').USEREG\n&NAME    LA    1,&MF(2)                LOAD ADDRESS OF PARAMETER LIST\n         AGO   .REG1SET\n.*\n.USEREG  ANOP  ,                       IF A REGISTER WAS SPECIFIED\n&LCLC    SETC  '&MF(2)'(2,K'&MF(2)-2)  REGISTER NAME (W/O PARENS)\n         AIF   ('&LCLC' EQ '1').GENDS0H\n&NAME    LR    1,&LCLC                 LOAD PARAMETER LIST ADDRESS\n         AGO   .REG1SET\n.*\n.GENDS0H ANOP  ,\n&NAME    DS    0H                      REG 1 CONTAINS LIST ADDRESS\n         AGO   .REG1SET\n.*\n.REG1SET ANOP  ,\n         USING &CEC#P.DSECT,1          REGISTER 1 POINTS TO DSECT\n.*\n&CEC#FLAG(1) SETA 0,0,1,1,5  NO DC, NO DS, YES REG, YES MOVES, COMMON5\n         AGO   .COMMON\n.COMMON5 ANOP  ,\n         DROP  1\n.*\n         AGO   .MEXIT\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70\n.*\n.COMMON  ANOP  , GENERATE STRUCTURE OF PARAMETER LIST\n.* THIS IS AN AGO-TYPE INTERNAL ROUTINE --\n.* IT EXITS WITH THE STATEMENT:            AGO .COMMON&CEC#FLAG(5)\n         CECDYN DEBUG,'START .COMMON, RETURN INDEX=&CEC#FLAG(5); ',    X\n               'FLAGS=&CEC#FLAG(1),&CEC#FLAG(2),',                     X\n               '&CEC#FLAG(3),&CEC#FLAG(4).'\n.* .COMMON IS CALLED WITH FLAGS 1,0,0,0 -- JUST &CEC#FLAG(1),\n.*                           OR 0,1,0,0 -- JUST &CEC#FLAG(2),\n.*                           OR 0,0,1,0 -- JUST &CEC#FLAG(3),\n.*                           OR 0,0,1,1 -- WITH &CEC#FLAG(3) AND (4).\n.* IF &CEC#FLAG(1), MAKE DC.S FOR ALL OP.S, WITH ZEROS FOR REG. OP.S\n.* IF &CEC#FLAG(2), MAKE DS.S FOR ALL OP.S, WITH ZEROS FOR ALL OP.S\n.* IF &CEC#FLAG(3), THEN MOVE ONLY OPERANDS WHICH CANNOT BE GENERATED\n.*               IN DC.S (REGISTER OPERANDS, AND SYMBOLIC OPERANDS\n.*               FOR CONSTANTS OF TYPES WHICH REQUIRE QUOTES.)\n.* IF &CEC#FLAG(4), THEN MOVE OTHER OPERANDS (LITERALS, ACONS, NULLS)\n.*\n.*\n         AIF   (NOT &CEC#FLAG(1) AND NOT &CEC#FLAG(2)).NOEQU1\n         AIF   (NOT &CEC#NEWP).COMEXIT SKIP -- ASSUME ALREADY DONE.\n         CECDYN DEBUG,'NEWP=1, GENERATE DSECT'\n         SPACE 2\n&LCLC    SETC '&CEC#P.ORG'\n         AIF   (&CEC#FLAG(1)).ORGDC\n         AIF   (&CEC#FLAG(2)).ORGDSCT\n         MNOTE 16,'SEVERE INTERNAL ERROR'\n         MNOTE 'CEC#FLAG(1)=&CEC#FLAG(1) CEC#FLAG(2)=&CEC#FLAG(2)'\n&CEC#DEBUG SETB 1      TURN ON\n         AGO   .MEXIT\n.ORGDC   ANOP  ,\n&LCLC2   SETC  'DC'\n&LCLC3   SETC  '0F''0'''\n         AGO   .EQU1\n.ORGDSCT ANOP  ,\n&LCLC2   SETC  'DSECT'\n&LCLC3   SETC  ''\n.EQU1    ANOP  ,\n&LCLC    &LCLC2 &LCLC3\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n*                SVC 99 INPUT REQUEST BLOCK\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.NOEQU1  ANOP  ,\n.*..+....1....+....2....+....3\n.*\n.* BUILD &LCL#FLG11, &LCLFLG21, &LCLFLG22 BY SUMMING BIT MASKS:\n.*..+....1....+....2\n.*\n&LCL#FLG11 SETC '0'\n         AIF   (K'&FLG11 EQ 0).FLG11ZZ\n&I       SETA  1\n&LCL#FLG11 SETC 'S99&FLG11(&I)'\n         AIF   (N'&FLG11 LE &I).FLG11XX\n.FLG11QQ ANOP  ,\n&I       SETA  &I+1\n&LCL#FLG11 SETC '&LCL#FLG11.+S99&FLG11(&I)'\n         AIF   (N'&FLG11 GT &I).FLG11QQ\n.FLG11XX ANOP  ,\n.FLG11ZZ ANOP  ,\n.*..+....1....+....2\n.*\n&LCL#FLG21 SETC '0'\n         AIF   (K'&FLG21 EQ 0).FLG21ZZ\n&I       SETA  1\n&LCL#FLG21 SETC 'S99&FLG21(&I)'\n         AIF   (N'&FLG21 LE &I).FLG21XX\n.FLG21QQ ANOP  ,\n&I       SETA  &I+1\n&LCL#FLG21 SETC '&LCL#FLG21.+'.'S99&FLG21(&I)'\n         AIF   (N'&FLG21 GT &I).FLG21QQ\n.FLG21XX ANOP  ,\n.FLG21ZZ ANOP  ,\n.*..+....1....+....2\n.*\n&LCL#FLG22 SETC '0'\n         AIF   (K'&FLG22 EQ 0).FLG22ZZ\n&I       SETA  1\n&LCL#FLG22 SETC 'S99&FLG22(&I)'\n         AIF   (N'&FLG22 LE &I).FLG22XX\n.FLG22QQ ANOP  ,\n&I       SETA  &I+1\n&LCL#FLG22 SETC '&LCL#FLG22.+'.'S99&FLG22(&I)'\n         AIF   (N'&FLG22 GT &I).FLG22QQ\n.FLG22XX ANOP  ,\n.FLG22ZZ ANOP  ,\n.*..+....1....+....2....+....3\n.*\n.* (SEE .CREAT SUBROUTINE FOR MEANING OF PARAMETERS)\n.*\n&CECCMT1COL SETA &CEC#CMT1COL COMMENT 1 FIELD'S COLUMN\n&CECCMT2COL SETA &CEC#CMT2COL COMMENT 2 FIELD'S COLUMN\n.* (EACH CALL TO .CREAT DOES ABOVE SETA.S, JUST BEFORE EXITING)\n.*\n&CEC#P.RBP   CECDYN CREAT,0,F\n&CEC#P.RBPTR CECDYN CREAT,,A,*,A(&CEC#P.RB),'REQUEST BLOCK POINTER'\n.*                 (*=HIGH BIT ON)\n&CEC#P.RB    CECDYN CREAT,0,F,,,'REQUEST BLOCK'\n&CEC#P.RBLN  CECDYN CREAT,,A,1,&CEC#P.RBEND-&CEC#P.RB,                 X\n               'LENGTH OF REQUEST BLOCK'\n&CEC#P.VERB  CECDYN CREAT,,A,1,S99VRB&VERB,'VERB CODE'\n.*\n&CEC#P.FLAG1 CECDYN CREAT,0,C,2,,FLAGS\n&CEC#P.FLG11 CECDYN CREAT,,A,1,&LCL#FLG11,'FIRST FLAGS BYTE'\n&CEC#P.FLG12 CECDYN CREAT,,A,1,0,'SECOND BYTE OF FLAGS'\n&CEC#P.RSC   CECDYN CREAT,0,C,4,,'REASON CODE FIELDS'\n&CEC#P.ERROR CECDYN CREAT,,X,2,0,'ERROR REASON CODE'\n&CEC#P.INFO  CECDYN CREAT,,X,2,0,'INFORMATION REASON CODE'\n&CEC#P.TXTPP CECDYN CREAT,,A,,A(&CEC#P.TUPL),                          X\n               'ADDR OF LIST OF TEXT UNIT PTRS'\n&CEC#P.RSV01 CECDYN CREAT,,F,,0,RESERVED\n&CEC#P.FLAG2 CECDYN CREAT,0,C,4,,'FLAGS FOR AUTHORIZED FUNCTIONS'\n&CEC#P.FLG21 CECDYN CREAT,,A,1,&LCL#FLG21,'FIRST BYTE OF FLAGS'\n&CEC#P.FLG22 CECDYN CREAT,,A,1,&LCL#FLG22,'SECOND BYTE OF FLAGS'\n&CEC#P.FLG23 CECDYN CREAT,,A,1,0,'THIRD BYTE OF FLAGS'\n&CEC#P.FLG24 CECDYN CREAT,,A,1,0,'FOURTH BYTE OF FLAGS'\n&CEC#P.RBEND CECDYN CREAT,0,,0,,'END MARKER'\n.*\n         AIF   (NOT &CEC#FLAG(1) AND NOT &CEC#FLAG(2)).NOEQU2\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n* SVC 99 TEXT UNIT POINTER LIST\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.NOEQU2  ANOP  ,\n.*\n&CEC#P.TUPL  CECDYN CREAT,0,F,,,'TEXT UNIT POINTER LIST'\n&I       SETA   1\n.NEXTPTR ANOP  ,\n&I1      SETA  &I-10*(&I/10)           1'S DIGIT OF &I\n&I10     SETA  (&I/10)-10*(&I/100)     10'S DIGIT OF &I\n&IIX     SETA  1+3*(&I1*(&I10-1)/(&I10-1)) IGNORE &I1 IF (&I10-1) EQ 0\n&ITH     SETC  'TH ST ND RD TH TH TH TH TH TH '(&IIX,2) 0TH, 1ST, ETC.\n&HIBIT   SETC  '*'                     SET FLAG TO SET HIGH BIT\n         AIF   (&I EQ N'&TEXT).LASTPTR\n&HIBIT   SETC  ''                      RESET FLAG TO SET HIGH BIT\n.LASTPTR ANOP  ,\n&LCLC3   SETC  'A(&CEC#P.TU&I)'\n&LCLC4   SETC  '&TEXT(&I,1)'\n         AIF   (T'&TEXT(&I,1) NE 'O').NORMAL1 NOT- SKIPPED UNIT\n&LCLC3   SETC  '0'\n&LCLC4   SETC  '(OMITTED)'\n.NORMAL1 ANOP  ,\n.* ACTUAL CODE GENERATION:\n&CEC#P.PTR&I CECDYN CREAT,,A,&HIBIT,                                   X\n               &LCLC3,                                                 X\n               '&I&ITH TEXT UNIT POINTER, &LCLC4'\n.***************************\n.* THE EFFECT OF THE ABOVE CODE IS:\n.* &CEC#P.PTR&I CECDYN CREAT,,A,&HIBIT,                                X\n               A(&CEC#P.&TEXT(&I,1).-(S99TUPAR-S99TUNIT)),             X\n               '&I&ITH TEXT UNIT POINTER, &TEXT(&I,1)'\n.***************************\n.ADVPTR  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE N'&TEXT).NEXTPTR\n.*\n.*\n         AIF   (NOT &CEC#FLAG(1) AND NOT &CEC#FLAG(2)).NOEQU3\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n* SVC 99 TEXT UNITS\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.NOEQU3  ANOP  ,\n.*\n.*   BEGIN A HUGE LOOP, AROUND ALL SELF-CALLS TO .DOKEY SUBROUTINE.\n.* THIS LOOP USES &I AS AN INDEX TO STEP THROUGH ALL SUBLIST ENTRIES\n.* SPECIFIED IN THE TEXT= PARAMETER IN THE OUTER CALL TO CECDYN.\n.*\n&I       SETA   1\n.NEXTI09 ANOP  ,\n.*\n&I1      SETA  &I-10*(&I/10)           1'S DIGIT OF &I\n&I10     SETA  (&I/10)-10*(&I/100)     10'S DIGIT OF &I\n&IIX     SETA  1+3*(&I1*(&I10-1)/(&I10-1)) IGNORE &I1 IF (&I10-1) EQ 0\n&ITH     SETC  'TH ST ND RD TH TH TH TH TH TH '(&IIX,2) 0TH, 1ST, ETC.\n&KEY     SETC  'D&VERB.&TEXT(&I,1)'\n.*\n         AIF   (T'&TEXT(&I,1) EQ 'O').ADVI09  SKIPPED UNIT\n.*\n         AIF   (T'&TEXT(&I,1) NE 'O').NORMAL2 NOT- SKIPPED UNIT\n&KEY     SETC  '(OMITTED)'\n.NORMAL2 ANOP  ,\n.*\n         CECDYN CMT2,        SET &CEC#CMT2VAL (TO BLANKS)\n.*\n&CECCMT1COL SETA &CEC#CMT1COL-6 SHIFT CHARS LEFT, SO 'BEGIN' STANDS OUT\n&CEC#P.TU&I  CECDYN CREAT,0,F,,,'BEGIN &I&ITH TEXT UNIT, &KEY'\n.*\n         AIF   (T'&TEXT(&I,1) EQ 'O').ADVI09  SKIPPED UNIT\n.*\n&CEC#P.KEY&I CECDYN CREAT,,A,2,&KEY,'&I&ITH KEY'\n.*\n&CEC#KEYDONE SETB 0          PREPARE TO SEARCH\n.*\n.*  INFORMATION BELOW IS FROM MVS/XA SPL: SYSTEM MACROS AND FACILITIES\n.* GC28-1150-2.\n.*\n.*     CECDYN PREFIX=ABC,      ALL NAMES GENERATED BEGIN WITH 'ABC'  X\n.*           MF=(E,WORKAREA), BUILD THE PARAMETER LIST HERE          X\n.*           VERB=AL,   SET THE VERB CODE TO ALLOCATION FUNCTION.    X\n.*           TEXT=((DSNAM,'CICSA.CICS.DFHLOG'), IRST TEXT UNIT       X\n.*           (DDNAM,=CL8'TESTCICS'),          SECOND TEXT UNIT       X\n.*           (SSNM,'LOGR'),                      ND TEXT UNIT        X\n.*           (SSPRM,                             ND TEXT UNIT        X\n.*           (=CL8'DFHLGCNV',                                        X\n.*           =CL15'TO=(,12:00),GMT',                                 X\n.*           =CL17'COMPAT41,SETBRCUR')),                             X\n.*           (STATS,SHR))                     SECOND TEXT UNIT\n.*     DYNALLOC            INVOKE SVC 99 TO PROCESS THE REQUEST.\n*\n.*0001 DALDDNAM Associates a ddname with an allocation request.\n.*0002 DALDSNAM Names the data set to be allocated.\n.*0003 DALMEMBR Specifies data set number or relative generation numbr.\n.*0004 DALSTATS Specifies the data set status.\n.*0005 DALNDISP Specifies the data set's normal disposition.\n.*0006 DALCDISP Specifies the data set's conditional disposition.\n.*0007 DALTRK  Specifies the space allocation in tracks.\n.*0008 DALCYL  Specifies the space allocation in cylinders.\n.*0009 DALBLKLN Specifies the average data block length.\n.*000A DALPRIME Specifies a primary space quantity.\n.*000B DALSECND Specifies a secondary space quantity.\n.*000C DALDIR  Specifies the number of PDS directory blocks.\n.*000D DALRLSE Deletes unused space at data set closure.\n.*000E DALSPFRM Ensures a specific allocated space format.\n.*000F DALROUND Specifies space allocation in whole cylinders.\n.*0010 DALVLSER Specifies volume serial numbers.\n.*0011 DALPRIVT Specifies the private volume use attribute.\n.*0012 DALVLSEQ Specifies the volume sequence number processing.\n.*0013 DALVLCNT Specifies the data set's volume count.\n.*0014 DALVLRDS Specifies volume reference to a cataloged data set.\n.*0015 DALUNIT Describes the unit specification.\n.*0016 DALUNCNT Specifies the number of devices to be allocated.\n.*0017 DALPARAL Specifies parallel mounting for a data set's volumes.\n.*0018 DALSYSOU Specifies the SYSOUT data set and defines its class.\n.*0019 DALSPGNM Specifies the SYSOUT program name.\n.*001A DALSFMNO Specifies the SYSOUT form number.\n.*001B DALOUTLM Limits the SYSOUT data set's logical record count.\n.*001C DALCLOSE Frees a data set at closure.\n.*001D DALCOPYS Specifies the SYSOUT listing copies count.\n.*001E DALLABEL Specifies the type of volume label.\n.*001F DALDSSEQ Specifies a tape data set's relative position.\n.*0020 DALPASPR Password protects the created data set.\n.*0021 DALINOUT Specifies ?input only? or ?output only?\n.*             data set processing.\n.*0022 DALEXPDT Specifies the data set's expiration date.\n.*0023 DALRETPD Specifies the data set's retention period.\n.*0024 DALDUMMY Allocates a dummy data set.\n.*0025 DALFCBIM Identifies the forms control buffer image.\n.*0026 DALFCBAV Requests operator verification of the image display or\n.*             forms alignment,\n.*0027 DALQNAME Names a TPROCESS macro, and a TCAM procedure.\n.*0028 DALTERM Specifies a time sharing terminal as an I/O device.\n.*0029 DALUCS  Specifies a universal character set\n.*002A DALUFOLD Specifies ?fold mode? for loading the requested print\n.*             chain or train.\n.*002B DALUVRFY Requests operator verification of the correct print\n.*             chain or train mounting.\n.*002C DALDCBDS Specifies the retrieval of DCB information from a\n.*             cataloged data set's label.\n.*002D DALDCBDD Specifies the retrieval of DCB information from a\n.*             ddname-related, currently allocated data set.\n.*0058 DALSUSER Specifies the destination to which the SYSOUT data set\n.*             is data set is to be routed.\n.*\n.*Note:\n.*Keys 0058 and 0063 are equivalent to the JCL DEST= parameter, where\n.*DEST=(dalsuser) or DEST=(dalsuser,dalusrid).\n.*\n.*0059 DALSHOLD Specifies hold queue routing for the SYSOUT data set.\n.*005F DALSSNM Requests allocation of a subsystem data set.\n.*0060 DALSSPRM Specifies subsystem-defined parameters for use with key\n.*             DALSSNM.\n.*0061 DALPROT Requests that the direct access data set or\n.*             tape volume be RACF-protected.\n.*0063 DALUSRID Specifies the destination user ID to which the\n.*             SYSOUT data set is to be routed.\n.*             If used, requires that DALSUSER also be specified.\n.*\n.*Note:\n.*Keys 0058 and 0063 are equivalent to the JCL DEST= parameter, where\n.*DEST=(dalsuser) or DEST=(dalsuser,dalusrid).\n.*\n.*0064 DALBURST Specifies which stacker of the 3800\n.*             Printing Subsystem is to receive the paper output.\n.*0065 DALCHARS Specifies the name or names of character arrangement\n.*             tables for printing a data set on the 3800.\n.*0066 DALCOPYG Specifies how copies are to be grouped if printing is\n.*             done on a 3800.\n.*0067 DALFFORM Specifies the forms overlay to be used on the\n.*             3800 Printing Subsystem.\n.*0068 DALFCNT Specifies the number of copies on which the forms\n.*             overlay is to be printed.\n.*0069 DALMMOD Specifies the name of the copy modification module\n.*             to be loaded into the 3800 Printing Subsystem.\n.*006A DALMTRC Specifies the table reference character that corresponds\n.*             to a character arrangement table\n.*             used for printing the copy modification data.\n.*006C DALDEFER Specifies that the system should allocate a device\n.*             to the data set, but defer mounting the volume(s)\n.*             ) until the data set is opened.\n.*006D DALEXPDL Specifies the data set's expiration date. This differs\n.*             from DALEXPDT because the year\n.*             is specified with 4 digits instead of 2.\n.*0070 DALOVAFF Specifies the override of system affinity for a\n.*             job submitted to the internal reader.\n.*0071 DALRTCTK Specifies that the JES Client Token (CTOKEN) be\n.*             returned to the caller of DYNALLOC.\n.*8001 DALACODE Specifies an access code for an IOS/ANSI/FIPS\n.*             Version 3 tape data set.\n.*8002 DALOUTPT Refers to a specific OUTPUT JCL statement or\n.*             or dynamic output descriptor\n.*8003 DALCNTL Refers to a JCL CNTL statement.\n.*8004 DALSTCL Specifies the storage class of a new SMS-managed DSN\n.*8005 DALMGCL Specifies the management class of a new SMS-managed DSN\n.*8006 DALDACL Specifies the data class of a new SMS-managed DSN\n.*800B DALRECO Specifies the record organization of a VSAM data set.\n.*800C DALKEYO Specifies the key offset of a VSAM data set.\n.*800D DALREFD Specifies the name of the JCL DD statement\n.*             statement from which the attributes are to be copied.\n.*800E DALSECM DALSECM Specifies the name of  the RACF\n.*             profile from which the RACF profile is to be copied.\n.*800F DALLIKE For SMS-managed data sets, specifies the name of a\n.*             data set from which the attributes are to be copied.\n.*8010 DALAVGR Specifies the allocation unit to be used when the\n.*             the data set is allocated.\n.*8012 DALDSNT Specifies a data set type attribute.\n.*8013 DALSPIN Specifies whether the output for the SYSOUT data set\n.*             is to be printed immediately upon unallocation\n.*             of the data set, or at the end of the job.\n.*8014 DALSEGM Specifies the number of logical, line-mode pages\n.*             (the segment) to be produced for a SYSOUT data set\n.*             before the segment becomes eligible for immediate\n.*             printing.\n.*8017 DALPATH Specifies the HFS file pathname.\n.*8018 DALPOPT Specifies the HFS file options.\n.*8019 DALPMDE Specifies the HFS file access attributes.\n.*801A DALPNDS Specifies the disposition of the HFS file during\n.*             normal step termination.\n.*801B DALPCDS Specifies the disposition of the HFS file during\n.*             abnormal step termination.\n.*801C DALRLS  Specifies the record-level sharing protocol for\n.*             a VSAM data set.\n.*801D DALFDAT Specifies the organization of a hierarchical file.\n.*801F DALLGST Specifies the VSAM RLS log stream.\n.*8020 DALDCCS Specifies the Coded Character Set Identifier.\n.*8022 DALBSLM Specifies the upward limit that is used by the\n.*             by the system-determined block size processing.\n.*8023 DALKYL1 Specifies the label for the key encrypting key used\n.*             by the key manager. The key encrypting key\n.*             is used to encrypt the data (encryption) key.\n.*8024 DALKYL2 Specifies the label for the key encrypting key used\n.*             by the key manager. The key encrypting key is used\n.*             to encrypt the data (encryption) key.\n.*8025 DALKCD1 Specifies how the label for the key encrypting key\n.*             specified by DALKYL1 for this DD is to be\n.*             be encoded by the key manager and stored on\n.*             the tape cartridge.\n.*8026 DALKCD2 Specifies how the label for the key encrypting key\n.*             specified by DALKYL2 for this DD is to\n.*             be encoded by the key manager and stored\n.*             on the tape cartridge.\n.*\n.*\n.* (SEE .DOKEY SUBROUTINE FOR MEANING OF PARAMETERS)\n.* DSNAME ALLOCATION TEXT UNITS\n         AIF   ('&VERB' NE 'AL').AL#DONE\n.*\n.*       CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDDNAM,1,C,(1,8)\n.*              .     .  .    .           .        . .  .    .\n.*              .     .  .    .           .        . .  .    .pos9\n.*              .     .  .    .           .        . .  .\n.*              .     .  .    .           .        . .  .pos8\n.*              .     .  .    .           .        . .\n.*              .     .  .    .           .        . .\n.*              .     .  .    .           .        . . pos7\n.*              .     .  .    .           .        .\n.*              .     .  .    .           .        . pos6\n.*              .     .  .    .           .\n.*              .     .  .    .           . pos5\n.*              .     .  .    .\n.*              .     .  .    .\n.*              .     .  .    .\n.*              .     .  .    .pos4\n.*              .     .  .\n.*              .     .  .pos3\n.*              .     .\n.*              .     .pos2\n.*              .\n.*              .pos1\n.*\n.*\n.*\n.* (SEE .DOKEY SUBROUTINE FOR MEANING OF PARAMETERS)\n.* DSNAME ALLOCATION TEXT UNITS                                       -\n         AIF   ('&VERB' NE 'AL').AL#DONE\n.*\n.* DDNAME\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDDNAM,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* DSNAME (MUTUALLY EXCLUSIVE WITH DALQNAME, DALIPLTX)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDSNAM,1,C,(1,44)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* PDS MEMBER (REQUIRES DALDSNAM ALSO)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMEMBR,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* DATA SET STATUS (MUTUALLY EXCLUSIVE WITH DALSYSOU)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSTATS,1,A,1,              X\n               ((OLD,X'01'),(MOD,X'02'),(NEW,X'04'),(SHR,X'08'),       X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* NORMAL DISPOSITION (MUTUALLY EXCLUSIVE WITH DALSYSOU)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALNDISP,1,A,1,              X\n               ((UNCATLG,X'01'),(CATLG,X'02'),                         X\n               (DELETE,X'04'),(KEEP,X'08'),                            X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* CONDITIONAL DISPOSITION (MUTUALLY EXCLUSIVE WITH DALSYSOU)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCDISP,1,A,1,              X\n               ((UNCATLG,X'01'),(CATLG,X'02'),                         X\n               (DELETE,X'04'),(KEEP,X'08'),                            X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* UNIT OF DALPRIME, DALSECND WILL BE TRACKS\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALTRK,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.* UNIT OF DALPRIME, DALSECND WILL BE CYLINDERS\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCYL,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.* AVERAGE BLOCK LENGTH TO USE FOR UNIT OF DALPRIME, DALSECND\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBLKLN,1,A,3,,'<=65535'\n         AIF   (&CEC#KEYDONE).ADVI09\n.* PRIMARY SPACE QUANTITY\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPRIME,1,A,3\n         AIF   (&CEC#KEYDONE).ADVI09\n.* SECONDARY SPACE QUANTITY\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSECND,1,A,3\n         AIF   (&CEC#KEYDONE).ADVI09\n.* NUMBER OF DIRECTORY BLOCKS FOR A PDS\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDIR,1,A,3\n         AIF   (&CEC#KEYDONE).ADVI09\n.* RELEASE UNUSED SPACE AT CLOSE TIME\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRLSE,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.* FORMAT OF ALLOCATED SPACE\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSPFRM,1,A,1,              X\n               ((ALX,X'02'),  USE DIFFERENT AREAS OF CONTIGUOUS SPACE  X\n               (MXIG,X'04'),      MAXIMUM CONTIGUOUS SPACE IS REQUIRED X\n               (CONTIG,X'08'),    SPACE MUST BE CONTIGUOUS             X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* ALLOCATE IN WHOLE CYLINDERS\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALROUND,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.* VOLUME SERIAL NUMBERS (MUTUALLY EXCLUSIVE WITH DALSYSOU, DALVLRDS)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALVLSER,(1,6),C,6\n         AIF   (&CEC#KEYDONE).ADVI09\n.* ASSIGN USE ATTRIBUTE OF PRIVATE (MUTUALLY EXCLUSIVE WITH DALSYSOU)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPRIVT,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.* VOL-SEQ WITHIN MULTI-VOLUME DATA SET (MUT.EXCL.W/DALSYSOU)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALVLSEQ,1,A,2,,'<=255'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALVLCT,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALVLRDS,1,C,(1,44)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUNIT,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUNCNT,1,A,1,,'<=59'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPARAL,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSYSOU,(0,1),C,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSPGNM,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSFMNO,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALOUTLM,1,A,3\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCLOSE,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCOPYS,1,1,A\n         AIF   (&CEC#KEYDONE).ADVI09\n.* LABEL TYPE OF VOLUME\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALLABEL,1,A,1,              X\n               ((NL,X'01'),  NO LABEL                                  X\n               (SL,X'02'),   IBM STANDARD LABELS                       X\n               (NSL,X'04'),  NON-STANDARD LABELS                       X\n               (SUL,X'0A'),  IBM STANDARD LABEL PLUS USER LABEL        X\n               (BLP,X'10'),  BYPASS LABEL PROCESSING                   X\n               (LTM,X'21'),  CHECK FOR AND BYPASS LEADING TAPE MARK    X\n               (AL,X'40'),   AMERICAN NATIONAL STANDARD LABEL          X\n               (AUL,X'48'),  AL PLUS USER LABEL                        X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDSSEQ,1,A,2,,'<=9999'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPASPR,1,A,1,              X\n               ((PASSWORD,X'10'),(NOPWREAD,X'30'),                     X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALINOUT,1,A,1,              X\n               ((OUT,X'40'),(IN,X'80'),                                X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALEXPDT,1,C,5\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRETPD,1,A,2,,'<=9999'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDUMMY,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFCBIM,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFCBAV,1,A,1,              X\n               ((VERIFY,X'04'),(ALIGN,X'08'),                          X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALQNAME,1,C,(1,17)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALTERM,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUCS,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUFOLD,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUVRFY,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDCBDS,1,C,(1,44)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDCBDD,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSUSER,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSHOLD,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMSVGP,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSSNM,(0,1),C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSSPRM,(1,254),C,(0,67)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPROT,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUSRID,1,A,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBURST,1,A,1,              X\n               ((Y,X'02'),(N,X'04'),(YES,X'02'),(NO,X'04'),            X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCHARS,(1,4),C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCOPYG,(1,8),A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFFORM,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFCNT,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMMOD,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMTRC,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDEFER,0\n.*\n.*\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALEXPDL,1,C,7\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALOFAFF,0\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRTCTK,1,X,80\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSMSHR,0\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALACODE,1,C,(1,8)\n.*\n.*\n.*\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALOUTPT,(1,128),C,(1,26)\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCNTL,1,C,(1,26)\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSTCL,1,C,(1,8)\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMGCL,1,C,(1,8)\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDACL,1,C,(1,8)\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRECO,1,A,1,               X\n               ((KSDS,X'80'),      VSAM KSDS                           X\n               (ESDS,X'40'),       VSAM ESDS                           X\n               (RRDS,X'20'),       VSAM RRDS                           X\n               (LRDS,X'10'),       VSAM LRDS linear                    X\n               *) (USER MAY CODE VALUE DIRECTLY)\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALKEYO,1,X,4\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSECM,(1,2),X,(1,128)\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALLIKE,1,C,(1,44)\n.*\n.*       DALAVGR:\n.*      X'80' Represents single-record units.\n.*      X'40' Represents thousand-record units.\n.*      X'20' Represents million-record units\n.*\n.*\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALAVGR,1,X,1\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDSNT,1,A,1,               X\n               ((PSDE,X'80'),                                          X\n               (PDS,X'40'),                                            X\n               (FIFO,X'20'),                                           X\n               (HFS,X'10'),                                            X\n               (EXTREQ,X'08'),                                         X\n               (EXTPREF,X'04'),                                        X\n               (BASIC,X'02'),                                          X\n               (LARGE,X'01'),                                          X\n               *) (USER MAY CODE VALUE DIRECTLY)\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSPIN,1,A,1,               X\n               ((UNALLOC,X'80'), AVAILABLE WHEN UNALLOCATED            X\n               (EOJ,X'40'),      AVAILABLE WHEN END OF JOB             X\n               *) (USER MAY CODE VALUE DIRECTLY)\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSEGM,1,A,4\n.*       must contain a must contain a\n.*       positive hexadecimal integer from X'00000001' to X'0001869F'\n.*       (equivalent decimal value from 1 to 99,999).\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPATH,1,X,(1,255)\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPOPT,1,A,4,               X\n               ((OSYNC,X'00000100'),                                   X\n               (OCREAT,X'00000080'),                                   X\n               (OEXCL,X'00000040'),                                    X\n               (ONOCTTY,X'00000020'),                                  X\n               (OTRUNC,X'00000010'),                                   X\n               (OAPPEND,X'00000008'),                                  X\n               (ONONBLOCK,X'00000004'),                                X\n               (ORDWR,X'00000003'),                                    X\n               (ORDONLY,X'00000002'),                                  X\n               (OWRONLY,X'00000001'),                                  X\n               *) (USER MAY CODE VALUE DIRECTLY)\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n.*       any combination of the\n.*       following values - THEN USER DEFINED|\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPMDE,1,A,4,               X\n               ((SISUID,X'00000800'),                                  X\n               (SISGID,X'00000400'),                                   X\n               (SIRUSR,X'00000100'),                                   X\n               (SIWUSR,X'00000080'),                                   X\n               (SIXUSR,X'00000040'),                                   X\n               (SIRWXU,X'000001C0'),                                   X\n               (SIRGRP,X'00000020'),                                   X\n               (SIWGRP,X'00000010'),                                   X\n               (SIXGRP,X'00000008'),                                   X\n               (SIRWXG,X'00000038'),                                   X\n               (SIROTH,X'00000004'),                                   X\n               (SIWOTH,X'00000002'),                                   X\n               (SIXOTH,X'00000001'),                                   X\n               (SIRWXO,X'00000007'),                                   X\n               *) (USER MAY CODE VALUE DIRECTLY)\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPNDS,1,A,1,               X\n               ((DELETE,X'04'), the file is to be deleted              X\n               (KEEP,X'08'),    the file is to be kept                 X\n               *) (USER MAY CODE VALUE DIRECTLY)\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPCDS,1,A,1,               X\n               ((DELETE,X'04'), the file is to be deleted              X\n               (KEEP,X'08'),    the file is to be kept                 X\n               *) (USER MAY CODE VALUE DIRECTLY)\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRLS,1,A,1,                X\n               ((NRI,X'80'),   NRI (DALNRI) No read integrity          X\n               (CR,X'40'),     CR (DALCR) Consistent read              X\n               (CRE,X'20'),    CRE (DALCR) Consistent read explicit    X\n               *) (USER MAY CODE VALUE DIRECTLY)\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFDAT,1,A,1,               X\n               ((FDAT80,X'80'),  binary records not delimited          X\n               (FDAT40,X'40'),   text records are EBCDIC delimited     X\n               (FDAT20,X'20'),   data records with a prefix            X\n               *) (USER MAY CODE VALUE DIRECTLY)\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALLGST,1,C,(1,26)\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDCCS,1,A,4,,'<=65535'\n.*\n.*       Block size limit specification EBCDIC\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBSLM,1,C,(1,10)\n.*\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALKYL1,1,C,(1,64)\n.*\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALKYL2,1,C,(1,64)\n.*\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALKYC1,1,A,1,               X\n               ((L,X'03'),   EEDK structure                            X\n               (H,X'08'),    Indicates that a hash of the public key   X\n               *) (USER MAY CODE VALUE DIRECTLY)\n.*\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALKYC2,1,A,1,               X\n               ((EXT,X'01'), No Extended Attributes allowed            X\n               (PUB,X'02'),  public key referenced                     X\n               *) (USER MAY CODE VALUE DIRECTLY)\n.*\n.*\n         AIF   (&CEC#KEYDONE).ADVI09   EUGENE VOGT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALEATT,1,A,1,               X\n               ((EXT,X'01'), No Extended Attributes allowed            X\n               (OPT,X'02'),  Extended attributes are optional          X\n               *) (USER MAY CODE VALUE DIRECTLY)\n.*\n         AIF   (&CEC#KEYDONE).ADVI09\n.* DCB ATTRIBUTE TEXT UNITS\n.*\n.* BUFFER ALIGNMENT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBFALN,1,A,1,              X\n               ((F,X'01'),   FULLWORD, NOT DOUBLEWORD                  X\n               (D,X'02'),    DOUBLEWORD                                X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* BUFFERING TECHNIQUE\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBFTEK,1,A,1,              X\n               ((D,X'08'),   DYNAMIC                                   X\n               (E,X'10'),    EXCHANGE                                  X\n               (R,X'20'),    RECORD                                    X\n               (S,X'40'),    SIMPLE                                    X\n               (A,X'60'),    RECORD AREA                               X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBLKSZ,1,A,2,,'<=32760'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFIN,1,A,1,,'<=15'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFL,1,A,2,,'<=32760'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFMX,1,A,1,,'<=15'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFNO,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n.* BUFFER OFFSET\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFOF,1,A,1,              X\n               ((L,X'80'),   BLOCK PREFIX IS 4 BYTES, CONTAINS LENGTH  X\n               *),           USER CODES VALUE OF BLOCK PREFIX          X\n               '<=99'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFOU,1,A,1,,'<=15'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFRQ,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFSZ,1,A,2\n         AIF   (&CEC#KEYDONE).ADVI09\n.* PAPER TAPE CODE:\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCODE,1,A,1,               X\n               ((T,X'02'),   TELETYPE 5-TRACK                          X\n               (A,X'04'),    USASCII 8-TRACK                           X\n               (C,X'08'),    NATIONAL CASH REGISTER 8-TRACK            X\n               (B,X'10'),    BURROUGHS 7-TRACK                         X\n               (F,X'20'),    FRIDEN 8-TRACK                            X\n               (I,X'40'),    IBM BCD 8-TRACK                           X\n               (N,X'80'),    NO CONVERSION                             X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* SEND/RECEIVE PRIORITY\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCPRI,1,A,1,               X\n               ((S,X'01'),   SEND PRIORITY                             X\n               (E,X'02'),    EQUAL PRIORITY                            X\n               (R,X'04'),    RECEIVING PRIORITY                        X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* MAGNETIC TAPE DENSITY:\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDEN,1,A,1,                X\n               ((0,X'03'),   200 BPI 7-TRACK                           X\n               (1,X'43'),    556 BPI 7-TRACK                           X\n               (2,X'83'),    800 BPI 7-TRACK OR 9-TRACK                X\n               (3,X'C3'),    1600 BPI 9-TRACK                          X\n               (4,X'D3'),    6250 BPI 9-TRACK                          X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* DATA SET ORGANIZATION\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDSORG,1,A,2,              X\n               ((TCAM3705,X'0004'), TCAM 3705                          X\n               (VSAM,X'0008'), VSAM                                    X\n               (TQ,X'0020'), TCAM MESSAGE QUEUE                        X\n               (TX,X'0040'), TCAM LINE GROUP                           X\n               (GS,X'0080'), GRAPHICS                                  X\n               (PO,X'0200'), PARTITIONED ORGANIZATION                  X\n               (POU,X'0300'), PARTITIONED ORGANIZATION UNMOVABLE       X\n               (MQ,X'0400'), TELECOMMUNICATIONS MESSAGE PROCESSING Q.  X\n               (CQ,X'0800'), DIRECT ACCESS MESSAGE QUEUE               X\n               (CX,X'1000'), COMMUNICATION LINE GROUP                  X\n               (DA,X'2000'), DIRECT ACCESS                             X\n               (DAU,X'2100'), DIRECT ACCESS UNMOVABLE                  X\n               (PS,X'4000'), PHYSICAL SEQUENTIAL                       X\n               (PSU,X'4100'), PHYSICAL SEQUENTIAL UNMOVABLE            X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* ERROR PROCESSING OPTION\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALEROPT,1,A,1,              X\n               ((T,X'10'),   BSAM TESTING                              X\n               (ABE,X'20'),  CAUSE ABNORMAL END OF TASK                X\n               (SKP,X'40'),  SKIP BLOCK CAUSING ERROR                  X\n               (ACC,X'80'),  ACCEPT BLOCK CAUSING ERROR                X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALGNCP,1,A,1,,'<=99'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALINTVL,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALKYLEN,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALLIMCT,1,A,3,,'<=32760'\n         AIF   (&CEC#KEYDONE).ADVI09\n.* ACTUAL OR MAXIMUM LENGTH OF A LOGICAL RECORD, IN BYTES\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALLRECL,1,A,2,              X\n               ((X,X'8000'), LRECL EXCEEDS 32756 (QSAM, BSAM SPANNED)  X\n               *),           (USER MAY CODE VALUE DIRECTLY)            X\n               '<=32760'\n         AIF   (&CEC#KEYDONE).ADVI09\n.* MODE OF OPERATION FOR CARD READER OR PUNCH\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMODE,1,A,1,               X\n               ((E,X'40'),   EBCDIC MODE                               X\n               (ER,X'50'),   EBCDIC, READ COLUMN ELIMINATE MODE        X\n               (EO,X'60'),   EBCDIC, OPTICAL MARK READ MODE            X\n               (C,X'80'),    CARD IMAGE MODE                           X\n               (CR,X'90'),   CARD IMAGE, READ COLUMN ELIMINATE MODE    X\n               (CO,X'A0'),   CARD IMAGE, OPTICAL MARK READ MODE        X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALNCP,1,A,1,,'<=99'\n         AIF   (&CEC#KEYDONE).ADVI09\n.* OPTIONAL SERVICES TO BE PERFORMED\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALOPTCD,1,A,1,              X\n               (+, TRANSLATE + SUM                                     X\n               (R,X'01'), RELATIVE BLOCK ADDRESSING                    X\n               (J,X'01'), SELECT CHARACTER ARRANGEMENT TABLES(3800)    X\n               (T,X'02'), USER TOTALING FACILITY                       X\n               (Z,X'04'), REDUCED TAPE ERR RECOVERY/DIRECT DASD SEARCH X\n               (A,X'08'), DIRECT ADDRESSING                            X\n               (Q,X'08'), TRANSLATE ASCII TO/FROM EBCDIC               X\n               (F,X'10'), FEEDBACK                                     X\n               (H,X'10'), HOPPER-EMPTY EXIT                            X\n               (O,X'10'), ONLINE CORRECTION (OPTICAL READERS)          X\n               (C,X'20'), CHAINED SCHEDULING/TCAM SEGMENT IDENTIFICA'N X\n               (E,X'20'), EXTENDED SEARCH                              X\n               (B,X'40'), DISREGARD EOF RECOGNITION (TAPE)             X\n               (U,X'40'), ALLOW DATA CHECKS CAUSED BY INVALID CHARS    X\n               (W,X'80')) WRITE VALIDITY CHECK/PLACE TCAM MESSAGE IN   X\n                                   AN EIGHT-BYTE FIELD IN THE WORKAREA\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPCIR,1,A,1,               X\n               ((R,X'02'),(N,X'08'),(A,X'20'),(X,X'80'),               X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPCIS,1,A,1,               X\n               ((R,X'01'),(N,X'04'),(A,X'10'),(X,X'40'),               X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPRTSP,1,A,1,              X\n               ((0,X'01'),(1,X'09'),(2,X'11'),(3,X'19'),               X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRECFM,1,A,1,              X\n               (+, TRANSLATE + SUM                                     X\n               (M,X'02'),(R,X'02'),(A,X'04'),(G,X'04'),(S,X'08'),      X\n               (B,X'10'),(D,X'20'),(T,X'20'),(V,X'40'),(F,X'80'),      X\n               (U,X'C0'),                                              X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRSRVF,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRSRVS,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSOWA,1,A,2,,'<=32760'\n         AIF   (&CEC#KEYDONE).ADVI09\n.* STACKER SELECTION\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSTACK,1,A,1,              X\n               ((1,1),(2,2))            ONLY  1  OR  2  IS VALID       X\n                        NO '*' IN &POS9 -- ALL OTHERS HAVE '*' CODED   X\n                        AS LAST ENTRY IN &POS9.\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALTHRSH,1,A,1,,'<=100'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALTRTCH,1,A,1,              X\n               ((C,X'13'),(E,X'23'),(ET,X'2B'),(T,X'3B'),              X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALIPLTX,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDIAGN,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFUNC,1,A,1,               X\n               ((W,X'10'),(WT,X'12'),(WX,X'14'),(WXT,X'16'),           X\n               (P,X'20'),(PW,X'30'),(PWX,X'34'),(PWXT,X'36'),          X\n               (R,X'40'),(RW,X'50'),(RWT,X'52'),(RWX,X'54'),           X\n               (RWXT,X'56'),(RP,X'60'),(RPD,X'68'),(RPW,X'70'),        X\n               (RPWX,X'74'),(RPWXT,X'76'),(RPWD,X'78'),(I,X'80'),      X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFRID,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* NON-JCL DYNAMIC ALLOCATION FUNCTIONS\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPASSW,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPERMA,0\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCNVRT,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRTDDN,1,C,8,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRTDSN,1,C,44,*\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRTORG,1,X,2,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSSREQ,(0,1),C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRTVOL,1,C,6,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSSATT,1,X,1,              X\n               ((*,X'80'))                          CONSTANT X'80'\n         AIF   (&CEC#KEYDONE).ADVI09\n.AL#DONE ANOP  ,\n.* DYNAMIC UNALLOCATION TEXT UNITS\n         AIF   ('&VERB' NE 'UN').UN#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNDDNAM,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNDSNAM,1,C,(1,44)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNMEMBR,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVDSP,1,A,1,              X\n               ((UNCATLG,X'01'),(CATLG,X'02'),                         X\n               (DELETE,X'04'),(KEEP,X'08'),                            X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNUNALC,0\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNREMOV,0\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVSNH,0\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVCLS,1,C,1\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVSUS,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVSHQ,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.UN#DONE ANOP  ,\n.* DYNAMIC CONCATENATION TEXT UNITS\n         AIF   ('&VERB' NE 'CC').CC#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DCCDDNAM,(2,16),C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DCCPERMC,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.CC#DONE ANOP  ,\n.* DYNAMIC DECONCATENATION TEXT UNIT\n         AIF   ('&VERB' NE 'DC').DC#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DDCDDNAM,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n.DC#DONE ANOP  ,\n.* TEXT UNITS FOR REMOVING THE IN-USE ATTRIBUTE BASED ON TASK-ID\n         AIF   ('&VERB' NE 'RI').RI#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DRITCBAD,1,A,4\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DRICURNT,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.RI#DONE ANOP  ,\n.* DDNAME ALLOCATION TEXT UNITS\n         AIF   ('&VERB' NE 'DN').DN#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DDNDDNAM,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DDNRTDUM,1,X,1,*\n         AIF   (&CEC#KEYDONE).ADVI09\n.DN#DONE ANOP  ,\n.* DYNAMIC INFORMATION RETRIEVAL TEXT UNITS\n         AIF   ('&VERB' NE 'IN').IN#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINDDNAM,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINDSNAM,1,C,(1,44)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTDDN,1,C,8,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTDSN,1,C,44,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTMEM,1,C,8,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTSTA,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTNDP,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTCDP,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTORG,1,X,2,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTLIM,1,X,2,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTATT,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTLST,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTTYP,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRELNO,1,X,2,*\n         AIF   (&CEC#KEYDONE).ADVI09\n.IN#DONE ANOP  ,\n.*\n.* TO GET HERE, 1 OF 3:   1. USER KEYED INVALID TEXT KEY NAME\n.*                        2. ERROR IN THIS MACRO\n.*                        3. IBM DEFINED A KEY NOT KNOWN TO THIS MACRO\n&LCLC    SETC  'TEXT UNIT KEY ''''&KEY'''' NOT KNOWN TO THIS MACRO--'\n&LCLC    SETC  '&LCLC.TEXT UNIT KEY SPELLED WRONG, OR ERROR IN CECDYN'\n         MNOTE 12,'&LCLC'\n.*\n.* BOTTOM OF HUGE LOOP\n.ADVI09  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE N'&TEXT).NEXTI09\n.*                                                                    1\n         AIF   (NOT &CEC#FLAG(1) AND NOT &CEC#FLAG(2)).NOEQU4\n         SPACE 1\n         DS    0D                  FILL OUT DATA SECTION\n         SPACE 1\n&LCLC    SETC  '&CEC#P.&CEC#3CH'\n&LCLC.A  EQU   *-&CEC#P.ORG        CALCULATE THE HEX LENGTH\n         ORG   &CEC#P.ORG\n&LCLC2   SETC  '&CEC#P.DSECT'\n&LCLC2   DS    CL(&LCLC.A)         NOW L'&CEC#P.DSECT AVAILABLE\n         SPACE 1\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n         AIF   (NOT &CEC#FLAG(2)).NOEQU4\n         SPACE 1\n&SYSECT. CSECT , RETURN TO CODE\n         AIF   ('&SYSLOC' EQ '&SYSECT').NOEQU4  SKIP IF UNNECESSARY\n&SYSLOC. LOCTR , RETURN TO ORIGINAL LOCATION COUNTER\n.NOEQU4  ANOP  ,\n.*\n.COMEXIT ANOP  ,\n.*\n.* ACTUAL CODE GENERATION:\n&LCLA    SETA  &CEC#FLAG(5)  FETCH RETURN INDEX\n         AGO   (&LCLA).COMMON1,.COMMON2,.COMMON3,.COMMON4,.COMMON5\n.***************************\n.* THE EFFECT OF THE ABOVE CODE IS:\n.*       AGO   .COMMON&CEC#FLAG(5)\n.***************************\n         MNOTE 16,'SEVERE INTERNAL ERROR'\n         MNOTE 'CEC#FLAG(5)=&CEC#FLAG(5)'\n&CEC#DEBUG SETB 1      TURN ON\n         AGO   .MEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.SUBROUT ANOP  ,                                                      0\n.*\n         AIF   ('&POS1' EQ 'CMT2').CMT2\n         AIF   ('&POS1' EQ 'CREAT').CREAT\n         AIF   ('&POS1' EQ 'DEBUG').DEBUG\n         AIF   ('&POS1' EQ 'DOKEY').DOKEY\n         AIF   ('&POS1' EQ 'MNOTE').MNOTE\n&LCLC    SETC  'CECDYN -- INVALID INTERNAL CALL, \"&POS1\"'\n         AGO   .ERRMAIN\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.SUBEXIT MEXIT ,             USE THIS EXIT FROM SUBROUTINES           0\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.CMT2    ANOP  , SELF-CALL INTERNAL ROUTINE -- SET &CEC#CMT2VAL       0\n&CEC#CMT2VAL SETC '&POS2'\n         AGO   .SUBEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.CREAT   ANOP  , SELF-CALL INTERNAL ROUTINE -- CREATE LINE(S) OF CODE 0\n         CECDYN DEBUG,.CREAT SAVE HEADING FOR DEBUG MESSAGES\n         CECDYN DEBUG,'&NAME CECDYN CREAT,&POS2,&POS3,&POS4,&POS5,\"',  X\n               &POS6,'\"'\n.* IF &CEC#FLAG(1), GENERATE \"DEFINE CONSTANT\" FOR ALL OPERANDS,\n.*        WITH VALUES SPECIFIED BY USER,\n.*        AND VALUES OF 0 FOR OPERANDS SPECIFIED THROUGH REGISTERS\n.* IF &CEC#FLAG(2), GENERATE \"DEFINE STORAGE\" FOR ALL OPERANDS,\n.*        WITH VALUES OF 0 FOR ALL OPERANDS\n.* IF &CEC#FLAG(3), THEN MOVE ONLY OPERANDS WHICH CANNOT BE GENERATED\n.*        IN DEFINE CONSTANTS (REGISTER OPERANDS, AND SYMBOLIC\n.*        OPERANDS FOR CONSTANTS OF TYPES WHICH REQUIRE QUOTES)\n.* IF &CEC#FLAG(4), THEN MOVE OTHER OPERANDS (LITERALS, ACONS, NULLS)\n.*\n.* FORMAT OF .CREAT SELF-CALLS IS:\n.*       CECDYN CREAT,<DUP>,<TYP>,<LGH>,<VAL>,<COMMENT>\n.* ( DUPLICATION FACTOR, FIELD TYPE, LENGTH, NOMINAL VALUE, TEXT )\n.* OPTIONAL <DUP> IS SELF-DEFINING DECIMAL TERM (WHEN NULL, ASSUME 1)\n.*                        (WHEN 0, THEN INTERNALLY FORCE &CEC#FLAG(1)\n.*                        TO ACT LIKE &CEC#FLAG(2)\n.* OPTIONAL <TYP> IS A SINGLE CHARACTER (ASSEMBLER TYPE ATTRIBUTE T' )\n.*                        H=HALFWORD, F=FULLWORD, A=ADDRESS CONSTANT,\n.*                        B=BINARY, C=CHARACTER, X=HEX, <NULL>='EQU *'\n.* OPTIONAL <LGH>IS SELF-DEFINING DECIMAL TERM\n.*                        (WHEN NULL, ASSUME 2 FOR HALFWORD,\n.*                        4 FOR FULLWORD OR ADDRESS CONSTANT, ELSE 0)\n.*          <VAL> VALUE IS ONLY USED WHEN &CEC#FLAG(1)  (THAT IS,\n.*                        WHEN GENERATING \"DEFINE CONSTANT\"S).\n.*                        IT IS REQUIRED WHEN <DUP> NOT 0\n.* OPTIONAL <COMMENT> IS TEXT OF COMMENT TO BE GENERATED\n.*\n.*..+....1....+....2....+....3\n.*\n&DUP     SETC '&POS2'\n&TYP     SETC '&POS3'\n&LGH     SETC '&POS4'\n&VAL     SETC '&POS5'\n&CMT     SETC '&POS6'\n.*\n.* &DUP AND &LGH ARE THE PARAMETERS SPECIFIED ON THE .CREAT SELF-CALL\n.* &DV AND &LV ARE LCLA (NUMERIC) VALUES USED IN INTERNAL PROCESSING\n.* &DX AND &LX ARE LCLC (CHARACTER) VALUES USED IN GENERATING CODE\n.*\n.* &NUL,&LIT,&REG,&ACN ARE LCLB (FLAGS) DESCRIBE THE &VAL SPECIFIED\n.* &VV IS THE NOMINAL VALUE (WITHOUT QUOTES, PARENS, A(, ) )\n.*..+....1....+....2....+....3                                        0\n.*\n.* ANALYSE DUPLICATION FACTOR:\n.* &DUP=''        PRODUCES &DV=1,         &DX=''\n.* &DUP=0         PRODUCES &DV=0,         &DX='0'\n.* &DUP=1         PRODUCES &DV=1,         &DX=''\n.* &DUP=<NUMERIC> PRODUCES &DV=<NUMERIC>, &DX='<NUMERIC>'.\n&DV      SETA  1             SET INITIAL DEFAULTS\n&DX      SETC  ''            SET INITIAL DEFAULTS\n         AIF   (K'&DUP EQ 0).XDUP\n&DV      SETA  &DUP          MUST BE SELF-DEFINING DECIMAL TERM\n         AIF   ('&DUP' EQ '1').XDUP   LEAVE &DX AS ''\n&DX      SETC  '&DUP'\n.XDUP    ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* ANALYSE LENGTH:\n.* &LGH=''        PRODUCES &LV=DEFAULT,   &LX=''\n.*                            (DEFAULT DEPENDS ON DATA TYPE)\n.*                        (WHEN NULL, ASSUME 2 FOR HALFWORD,\n.*                        4 FOR FULLWORD OR ADDRESS CONSTANT, ELSE 0)\n.* &LGH=<NUMERIC> PRODUCES &LV=<NUMERIC>, &LX='L<NUMERIC>'\n&HIBIT   SETB  0\n&LX      SETC  ''            SET INITIAL DEFAULTS\n&LCLC    SETC  'HFA'\n&LCLC2   SETC  '2440'  EXTRA CHARACTER GIVES DEFAULT '0' FOR NON-H,F,A\n.* H,2; F,4; A,4; OTHER,0.\n&I       SETA  1\n.NEXTI08 ANOP  ,\n         AIF   ('&LCLC'(&I,1) EQ '&TYP').EXITI08\n.ADVI08  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE K'&LCLC).NEXTI08\n.EXITI08 ANOP  ,\n&LCLC    SETC  '&LCLC2'(&I,1)          FETCH CHARACTER FROM 2ND ARRAY\n&LV      SETA  &LCLC                      AND CHANGE TO NUMERIC\n         AIF   (K'&LGH EQ 0).NOLGH             USE DEFAULT LENGTH\n&HIBIT   SETB  ('&LGH'(K'&LGH,1) EQ '*')  SET BY '*', OR '4*', ETC.\n         AIF   (K'&LGH EQ 1 AND &HIBIT).NOLGH  USE DEFAULT LENGTH\n&LCLC    SETC  '&LGH'(1,K'&LGH-&HIBIT) TRIM POSSIBLE '*' (K'&LGH GE 2)\n&LV      SETA  &LCLC         MUST BE SELF-DEFINING DECIMAL TERM\n&LX      SETC  'L&LV'\n.NOLGH   ANOP  ,\n         AIF   (&LV NE 0).XLGH\n&LV      SETA  K'&VAL\n         AIF   (&LV EQ 0).XLGH\n&LX      SETC  'L&LV'\n.XLGH    ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* ANALYSE NOMINAL VALUE:\n.* &VAL=''        PRODUCES &NUL=1, &VV=DEFAULT\n.*                                    (DEFAULT DEPENDS ON DATA TYPE)\n.* &VAL='...'     PRODUCES &LIT=1, &VV=...   (WITHOUT QUOTES)\n.* &VAL=(...)     PRODUCES &REG=1, &VV=...   (WITHOUT PARENS)\n.* &VAL=A(...)    PRODUCES &ACN=1, &VV=...   (WITHOUT A(, ) )\n.* &VAL=<OTHER>   PRODUCES &NUL=&LIT=&REG=&ACN=0, &SYMBOL=1,\n.*                                 &VV=&VAL\n&LIT     SETB  0             LITERAL\n&REG     SETB  0             REGISTER\n&ACN     SETB  0             ADDRESS CONSTANT\n&NUL     SETB  1             NULL -- OMITTED\n&LCLC    SETC  'C'\n&LCLC2   SETC  ' 0'     EXTRA CHARACTER GIVES DEFAULT '0' FOR NON-C\n.* C,' '; OTHER,0.\n&I       SETA  1\n.NEXTI05 ANOP  ,\n         AIF   ('&LCLC'(&I,1) EQ '&TYP').EXITI05\n.ADVI05  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE K'&LCLC).NEXTI05\n.EXITI05 ANOP  ,\n&VV      SETC  '&LCLC2'(&I,1)          FETCH CHARACTER FROM 2ND ARRAY\n&DFLTVV  SETC  '&VV'                   SAVE FOR LATER, ' ' OR '0'\n         AIF   (K'&VAL EQ 0).ZVAL                .* IF NULL SKIP\n         AIF   ('&VAL' EQ '').ZVAL               .* IF NULL SKIP\n&NUL     SETB  0                               .* RESET NULL IF NOT\n         AIF   (K'&VAL LT 3).XVAL      TOO SHORT TO BE ANYTHING\n&VV      SETC  '&VAL'(2,K'&VAL-2)      REMOVE QUOTES/PARENS\n&LIT     SETB  ('&VAL'(1,1) EQ '''' AND '&VAL'(K'&VAL,1) EQ '''')\n         AIF   (&LIT).ZVAL\n&REG     SETB  ('&VAL'(1,1) EQ '(' AND '&VAL'(K'&VAL,1) EQ ')')\n         AIF   (&REG).ZVAL\n         AIF   (K'&VAL LT 4).XVAL      TOO SHORT TO BE ACN\n&ACN     SETB  ('&VAL'(1,2) EQ 'A(' AND '&VAL'(K'&VAL,1) EQ ')')\n&VV      SETC  '&VAL'(3,K'&VAL-3)      REMOVE A(, )\n         AIF   (&ACN).ZVAL\n.XVAL    ANOP  ,\n&VV      SETC  '&VAL'\n.ZVAL    ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n&SYMBOL  SETB  (NOT &NUL AND NOT &LIT AND NOT &REG AND NOT &ACN)\n.*                     (SOMETHING, BUT NONE OF THE ABOVE)\n&MUSTMOV SETB  0             PREP IT TO 0\n         AIF   (&REG).MM1    IF &REG, CANNOT BE DC.-D\n         AIF   (&NUL).MMXX              NULL VALUE CAN ALWAYS BE DC.-D\n         AIF   (&LIT AND ('&TYP' EQ 'C')).MMXX   LITERALS CAN BE DC.-D\n         AIF   (NOT &LIT AND ('&TYP' EQ 'C')).MM1   OTHERS CANNOT\n         AIF   ('&TYP' EQ 'A').MMXX       WITHOUT QUOTES, CAN BE DC.-D\n         AGO   .MMXX\n.MM1     ANOP  ,\n&MUSTMOV SETB  1             CHANGE IT TO 1\n.MMXX    ANOP  ,\n.*    &MUSTMOV IS A FLAG THAT SAYS SOME CODE IS NEEDED FOR A FIELD,\n.*  THAT IT CANNOT BE JUST ASSEMBLED INTO A DC. (AS IN MF=L)\n         CECDYN DEBUG,'VAL=\"',&VV.,                                    X\n               '\", NUL=&NUL., LIT=&LIT., REG=&REG., ACN=&ACN.',        X\n               ', SYMBOL=&SYMBOL., MUSTMOV=&MUSTMOV..'\n.*..+....1....+....2....+....3                                        0\n.*\n.* PROCESS COMMENT FIELD:\n         AIF   (K'&CMT EQ 0).NOQUOT1\n         AIF   ('&CMT'(1,1) NE '''').NOQUOT1\n         AIF   ('&CMT'(K'&CMT,1) NE '''').NOQUOT1\n&CMT     SETC  '&CMT'(2,K'&CMT-2)     REMOVE QUOTES\n.NOQUOT1 ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n         AIF   (NOT &CEC#DEBUG).XDEBUG3\n         CECDYN DEBUG,'NAME=&NAME DUP=&DUP TYP=&TYP LGH=&LGH VAL=\"',   X\n               &VV,'\"'\n         CECDYN MNOTE,'        POS6=&CMT, POS7=&POS7..'\n         CECDYN MNOTE,'        DV=&DV DX=\"&DX\"  LV=&LV LX=\"&LX\"'\n         CECDYN MNOTE,'   VAL: NUL=&NUL, LIT=&LIT, REG=&REG, ACN=&ACN'\n&LCLA    SETA  N'&LGH\n         CECDYN MNOTE,'        N''LGH=&LCLA, HIBIT=&HIBIT'\n.XDEBUG3 ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n&GENRETI SETA  1        DEFAULT RETURN FROM .GENCOM:  .CR#EXIT\n.*\n         AIF   (&CEC#FLAG(1)).G#DCDS   GENERATE DC/DS\n         AIF   (&CEC#FLAG(2)).G#DCDS   GENERATE DC/DS\n         AIF   (&DV EQ 0).CR#EXIT      DUPLICATION FACTOR ZERO--EXIT!\n         AIF   (&CEC#FLAG(3)).G#MOVE   GENERATE MOVES\n         AIF   (&CEC#FLAG(4)).G#MOVE   GENERATE MOVES\n&LCLC    SETC  'INTERNAL ERROR IN .CREAT SUBROUTINE, SYSNDX=&SYSNDX '\n&LCLC    SETC  '&LCLC'.'FLAGS=&CEC#FLAG(1),&CEC#FLAG(2),'\n&LCLC    SETC  '&LCLC'.'&CEC#FLAG(3),&CEC#FLAG(4)..'\n         MNOTE 16,'&LCLC'\n&CEC#DEBUG SETB 1      TURN ON\n         MHELP 1+2+4+8+16+32+64\n         AGO   .CR#EXIT\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.G#DCDS  ANOP  ,             GENERATE DC OR DS\n&LBL     SETC  '&NAME'\n         AIF   (&LV EQ 0 AND &DV EQ 0 AND '&TYP' EQ '').G#EQU INSTEAD\n.*..+....1\n         AIF   (NOT &MUSTMOV).LEAVEVV\n&VV      SETC  '&DFLTVV'               SAVED DEFAULT\n         CECDYN DEBUG,'VAL=\"',&VV.,                                    X\n               '\", NUL=&NUL., LIT=&LIT., REG=&REG., ACN=&ACN.',        X\n               ', SYMBOL=&SYMBOL., MUSTMOV=&MUSTMOV., VV=&VV..'\n.LEAVEVV ANOP  , DON'T SET BACK TO DEFAULT\n.*..+....1\n         AIF   (&CEC#FLAG(1) AND &DV EQ 0).FLAG2A GENERATE DS, NOT DC\n         AIF   (&CEC#FLAG(1)).FLAG1A\n         AIF   (&CEC#FLAG(2)).FLAG2A\n.*..+....1\n.FLAG1A  ANOP  ,\n&OPR     SETC  'DC'\n&OPD     SETC  '&DX&TYP&LX'.'(&VV)'    A(<VALUE>)\n         AIF   ('&TYP' EQ 'A').FLAG1B\n&OPD     SETC  '&DX&TYP&LX'.'''&VV'''  C'<VALUE>' OR F'<VALUE>' OR X..\n         AGO   .FLAG1X                 DONE SETTING UP\n.FLAG1B  ANOP  ,\n         AIF   (NOT &HIBIT).FLAG1X     NOTHING SPECIAL TO DO\n.*-- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- -\n.*       2010-09-20  Eugene Vogt\n.*       inserted \".AGO .FLAG1C\"  due to text=(,,,,) issue\n.*\n         AGO   .FLAG1C\n.*                                     * no clue why this creates\n.*                                     * an error when it is\n.*                                     * correct for TEXT=(,,,,)\n.*                                     * creation\n.*\n.*-- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- -\n         AIF   (&ACN).FLAG1C           OK, SKIP ERROR MESSAGE\n         MNOTE 12,'INTERNAL ERROR, HIBIT ONLY VALID FOR ADCON.S'\n&CEC#DEBUG SETB 1      TURN ON\n.FLAG1C  ANOP  ,\n&OPD     SETC  '&DX&TYP&LX'.'(&VV+X''80000000'')'  SET HIGH BIT ON\n.FLAG1X  AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1\n.FLAG2A  ANOP  ,\n&OPR     SETC  'DS'\n&OPD     SETC  '&DX&TYP&LX'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1\n.G#EQU   ANOP  ,\n&OPR     SETC  'EQU'\n&OPD     SETC  '*'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.G#MOVE  CECDYN DEBUG,.G#MOVE         GENERATE MOVES\n&LBL     SETC  ''\n&LCLC    SETC  'SYMBOL=&SYMBOL., MUSTMOV=&MUSTMOV.'\n&LCLC    SETC  '&LCLC., FLAG(3)=&CEC#FLAG(3)., FLAG(4)=&CEC#FLAG(4).'\n         CECDYN DEBUG,'&LCLC'\n&LCLB    SETB                (     &MUSTMOV   AND (NOT &CEC#FLAG(3) ))\n&LCLC    SETC        '&LCLB.=(     &MUSTMOV.  AND (NOT &CEC#FLAG(3)))'\n         CECDYN DEBUG,'&LCLC.=(     MUSTMOV   AND (NOT  FLAG(3) ))'\n&LCLB1   SETB                ((NOT &MUSTMOV ) AND (NOT &CEC#FLAG(4) ))\n&LCLC    SETC       '&LCLB1.=((NOT &MUSTMOV.) AND (NOT &CEC#FLAG(4)))'\n         CECDYN DEBUG,'&LCLC.=((NOT MUSTMOV ) AND (NOT  FLAG(4) ))'\n         CECDYN DEBUG,'    IF EITHER OF ABOVE IS TRUE, THEN MEXIT'\n         AIF   (&LCLB OR &LCLB1).CR#EXIT                 NOTHING TO DO\n         AIF   ('&DUP' EQ '0' AND K'&CMT EQ 0).CR#EXIT   NOTHING TO DO\n         AIF   ('&DUP' EQ '0').ONLYCMT  NO CODE TO BE GENERATED\n         AIF   (&NUL AND                                               X\n               '&TYP' EQ 'C').BLANK  TO-FIELD IS CHARACTER             X\n                                        AND NO NOMINAL VALUE SPECIFIED\n         AIF   (&NUL AND                                               X\n               '&TYP' EQ 'F').ZERO   TO-FIELD IS A FULLWORD            X\n                                        AND NO NOMINAL VALUE SPECIFIED\n         AIF   (&NUL).CLEAR          NO NOMINAL VALUE SPECIFIED\n         AIF   ('&VV' EQ '0').CLEAR  VALUE TO GENERATE IS 0\n         AIF   ('&TYP' EQ 'C').AAACH TO-FIELD IS A CHARACTER FIELD\n         AIF   ('&LV' EQ '1' AND                                       X\n               ('&TYP' EQ 'A' OR '&TYP' EQ 'X' OR '&TYP' EQ 'F' OR     X\n               '&TYP' EQ 'H')).AAA1N TO-FIELD IS LENGTH 1, NUMERIC\n         AIF   ('&LV' EQ '2' AND                                       X\n               ('&TYP' EQ 'A' OR '&TYP' EQ 'X' OR '&TYP' EQ 'F' OR     X\n               '&TYP' EQ 'H')).AAA2N TO-FIELD IS LENGTH 2, NUMERIC\n         AIF   ('&LV' EQ '3' AND                                       X\n               ('&TYP' EQ 'A' OR '&TYP' EQ 'X' OR '&TYP' EQ 'F' OR     X\n               '&TYP' EQ 'H')).AAA3N TO-FIELD IS LENGTH 3, NUMERIC\n         AIF   ('&LV' EQ '4' AND                                       X\n               ('&TYP' EQ 'A' OR '&TYP' EQ 'X' OR '&TYP' EQ 'F' OR     X\n               '&TYP' EQ 'H')).AAA4N TO-FIELD IS LENGTH 4, NUMERIC\n         MNOTE 12,'INTERNAL ERROR IN CREAT ROUTINE:'\n MNOTE '            NAME=&NAME DUP=&DUP TYP=&TYP LGH=&LGH VAL=\"&VV\"'\n MNOTE '            POS6=&CMT..'\n MNOTE '            DV=&DV DX=\"&DX\"  LV=&LV LX=\"&LX\"'\n MNOTE '       VAL: NUL=&NUL, LIT=&LIT, REG=&REG, ACN=&ACN'\n&CEC#DEBUG SETB 1      TURN ON\n         AGO   .CR#EXIT\n.*..+....1....+....2                                                  0\n.*\n.* (EACH 'AGO .GENCOM\" WITH NO RETURN IS FOLLOWED BY DOUBLE-SPACE)\n.*..+....1....+....2                                                  0\n.ONLYCMT CECDYN CMT2,.ONLYCMT    DUPLICATION FACTOR ZERO--ONLY COMMENT0\n&LBL     SETC  '*'\n&OPR     SETC  ''\n&OPD     SETC  '&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.BLANK   CECDYN CMT2,.BLANK     NO NOMINAL VALUE FOR 'C'--BLANK-FILL  0\n         AIF   (&LV LE 0 OR &LV GT 8).BLANK1   CONTINUE THINKING\n.BLANK8  CECDYN CMT2,.BLANK8    USER SPECIFIED &LGH LE 8--USE LITERAL\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME'.'(&LV),=CL8'' '''\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.BLANK1  CECDYN CMT2,.BLANK1    MOVE A SINGLE BLANK                   0\n&OPR     SETC  'MVI'\n&OPD     SETC  '&NAME,C'' '''\n         AIF   (&LV EQ 1).GENCOM GO GENERATE A LINE, THEN .CR#EXIT\n&GENRETI SETA  3             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET3\n.GENRET3 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&CMT     SETC  'PROPOGATE INITIAL BLANK'\n         AIF   (&LV EQ 0).BLANK0\n.BLANKX  CECDYN CMT2,.BLANKX USER SPECIFIED &LGH--USE IT              0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME+1(&LV-1),&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.BLANK0  CECDYN CMT2,.BLANK0 NO &LGH--HOPE ASMBLR CAN FIGURE IT OUT   0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME+1(L''&NAME-1),&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.ZERO    CECDYN CMT2,.ZERO      NO NOMINAL VALUE FOR 'F'--LOAD ZEROES 0\n         AIF   (&LV GE 4).CLEAR LGH GREATER THAN TYPE F--USE XC\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,=F''0'''\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.CLEAR   CECDYN CMT2,.CLEAR     NO NOMINAL VALUE--CLEAR TO HEX ZEROES 0\n&OPR     SETC  'MVI'\n&OPD     SETC  '&NAME,0'\n         AIF   (&LV EQ 1).GENCOM GO GENERATE A LINE, THEN .CR#EXIT\n         AIF   (&LV EQ 0).CLEAR0\n&OPR     SETC  'XC'\n&OPD     SETC  '&NAME'.'(&LV),&NAME'\n&GENRETI SETA  2 PREPARE RETURN POINTER--CHECK FOR HIBIT AFTERWARD\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2\n.CLEAR0  CECDYN CMT2,.CLEAR0 NO &LGH--HOPE ASMBLR CAN FIGURE IT OUT   0\n&OPR     SETC  'XC'\n&OPD     SETC  '&NAME,&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.AAACH   CECDYN CMT2,.AAACH , TO-FIELD IS A CHARACTER FIELD           0\n         AIF   (&REG).REGCH   TO-FIELD IS CHAR, SOURCE IS REG-FORMAT\n         AIF   (&ACN).ACNCH   TO-FIELD IS CHAR, SOURCE IS ACON-FORMAT\n         AIF   (&LIT).LITCH   TO-FIELD IS CHAR, SOURCE IS LITERAL\n.SYMCH   ANOP  ,              TO-FIELD IS CHAR, SOURCE IS A SYMBOL    0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,&VV' OR '&NAME,&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.LITCH   CECDYN CMT2,.LITCH   TO-FIELD IS CHAR, SOURCE IS LITERAL     0\n         AIF   (&LV EQ 1).LIT1CH TO-FIELD IS 1-CHAR, SOURCE IS LITERAL\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,=C&LX''&VV''' OR '&NAME,=C&LX&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.LIT1CH  CECDYN CMT2,.LIT1CH  TO-FIELD IS 1-CHAR, SOURCE IS LITERAL   0\n&OPR     SETC  'MVI'\n&OPD     SETC  '&NAME,C''&VV'''                 vogt new\n.*       SETC  '&NAME,''&VV''' OR '&NAME,&VAL'  vogt - bad opd card\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.REGCH   CECDYN CMT2,.REGCH   TO-FIELD IS CHAR, SOURCE IS REG-FORMAT  0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,0(&VV)' OR '&NAME,0&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.ACNCH   CECDYN CMT2,.ACNCH   TO-FIELD IS CHAR, SOURCE IS ACON-FORMAT 0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'LA'\n&OPD     SETC  '15,&VV'\n&CMT     SETC  'LOAD ADDRESS OF FIELD'\n&GENRETI SETA  4             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET4\n.GENRET4 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,0(15)'\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.AAA1N   CECDYN CMT2,.AAA1N , TO-FIELD IS LENGTH 1, NUMERIC           0\n         AIF   (&REG).REG1N TO-FIELD LGH 1 NUMERIC, SOURCE REG-FORMAT\n         AIF   (&ACN).ACN1N TO-FIELD LGH 1 NUMERIC, SOURCE ACON-FORMAT\n         AIF   (&LIT).LIT1N TO-FIELD LGH 1 NUMERIC, SOURCE A LITERAL\n.SYM1N   ANOP  ,            TO-FIELD LGH 1 NUMERIC, SOURCE A SYMBOL   0\n&OPR     SETC  'MVI'\n&OPD     SETC  '&NAME,&VV' OR '&NAME,&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.LIT1N   CECDYN CMT2,.LIT1N TO-FIELD LGH 1 NUMERIC, SOURCE A LITERAL  0\n&OPR     SETC  'MVI'\n&OPD     SETC  '&NAME,C''&VV''' OR '&NAME,C&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.REG1N   CECDYN CMT2,.REG1N TO-FIELD LGH 1 NUMERIC, SOURCE REG-FORMAT 0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'L'\n&OPD     SETC  '15,0(&VV)' OR '15,0&VAL'\n&CMT     SETC  'FETCH FULLWORD POINTED-TO BY REGISTER'\n&GENRETI SETA  7             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET7\n.GENRET7 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'STC'\n&OPD     SETC  '15,&NAME'\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.ACN1N   CECDYN CMT2,.ACN1N TO-FIELD LGH 1 NUMERIC, SOURCE ACON-FORMAT0\n         LA    15,&VV        LOAD ADDRESS OF FIELD            .ACN1N\n&OPR     SETC  'STC'\n&OPD     SETC  '15,&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.AAA2N   CECDYN CMT2,.AAA2N , TO-FIELD IS LENGTH 2, NUMERIC           0\n         AIF   (&REG).REG2N TO-FIELD LGH 2 NUMERIC, SOURCE REG-FORMAT\n         AIF   (&ACN).ACN2N TO-FIELD LGH 2 NUMERIC, SOURCE ACON-FORMAT\n         AIF   (&LIT).LIT2N TO-FIELD LGH 2 NUMERIC, SOURCE A LITERAL\n.SYM2N   ANOP  ,            TO-FIELD LGH 2 NUMERIC, SOURCE A SYMBOL   0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,=AL2(&VV)' OR '&NAME,=AL2(&VAL)'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.LIT2N   CECDYN CMT2,.LIT2N TO-FIELD LGH 2 NUMERIC, SOURCE A LITERAL  0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,=AL2(C''&VV'')' OR '&NAME,=AL2(C&VAL)'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.REG2N   CECDYN CMT2,.REG2N TO-FIELD LGH 2 NUMERIC, SOURCE REG-FORMAT 0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'L'\n&OPD     SETC  '15,0(&VV)' OR '15,0&VAL'\n&CMT     SETC  'FETCH FULLWORD POINTED-TO BY REGISTER'\n&GENRETI SETA  6             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET6\n.GENRET6 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'STH'\n&OPD     SETC  '15,&NAME'    STORE HALFWORD FROM REG.\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.ACN2N   CECDYN CMT2,.ACN2N TO-FIELD LGH 2 NUMERIC, SOURCE ACON-FORMAT0\n         LA    15,&VV        LOAD ADDRESS OF FIELD            .ACN2N\n&OPR     SETC  'STH'\n&OPD     SETC  '15,&NAME'    STORE HALFWORD FROM REG.\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.AAA3N   CECDYN CMT2,.AAA3N , TO-FIELD IS LENGTH 3, NUMERIC           0\n         AIF   (&REG).REG3N TO-FIELD LGH 3 NUMERIC, SOURCE REG-FORMAT\n         AIF   (&ACN).ACN3N TO-FIELD LGH 3 NUMERIC, SOURCE ACON-FORMAT\n         AIF   (&LIT).LIT3N TO-FIELD LGH 3 NUMERIC, SOURCE A LITERAL\n.SYM3N   ANOP  ,            TO-FIELD LGH 3 NUMERIC, SOURCE A SYMBOL   0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'L'\n&OPD     SETC  '15,&VV'\n&CMT     SETC  'FETCH FULLWORD'\n&GENRETI SETA  9             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET9\n.GENRET9 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'STCM'\n&OPD     SETC  '15,B''0111'',&NAME'\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.LIT3N   CECDYN CMT2,.LIT3N TO-FIELD LGH 3 NUMERIC, SOURCE A LITERAL  0\n         LA    15,=C'&VV'    POINT TO FULLWORD                .LIT3N\n&OPR     SETC  'STCM'\n&OPD     SETC  '15,B''0111'',&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.REG3N   CECDYN CMT2,.REG3N TO-FIELD LGH 3 NUMERIC, SOURCE REG-FORMAT 0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'L'\n&OPD     SETC  '15,0(&VV)' OR '15,0&VAL'\n&CMT     SETC  'FETCH FULLWORD POINTED-TO BY REGISTER'\n&GENRETI SETA  8             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET8\n.GENRET8 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'STCM'\n&OPD     SETC  '15,B''0111'',&NAME'\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.ACN3N   CECDYN CMT2,.ACN3N TO-FIELD LGH 3 NUMERIC, SOURCE ACON-FORMAT0\n         LA    15,&VV        LOAD ADDRESS OF FIELD            .ACN3N\n&OPR     SETC  'STCM'\n&OPD     SETC  '15,B''0111'',&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.AAA4N   CECDYN CMT2,.AAA4N , TO-FIELD IS LENGTH 4, NUMERIC           0\n&GENRETI SETA  2 PREPARE RETURN POINTER--CHECK FOR HIBIT AFTERWARD\n         AIF   (&REG).REG4N TO-FIELD LGH 4 NUMERIC, SOURCE REG-FORMAT\n         AIF   (&ACN).ACN4N TO-FIELD LGH 4 NUMERIC, SOURCE ACON-FORMAT\n         AIF   (&LIT).LIT4N TO-FIELD LGH 4 NUMERIC, SOURCE A LITERAL\n.SYM4N   ANOP  ,            TO-FIELD LGH 4 NUMERIC, SOURCE A SYMBOL   0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME'.'(4),&VV' OR '&NAME'.'(4),&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2\n.LIT4N   CECDYN CMT2,.LIT4N TO-FIELD LGH 4 NUMERIC, SOURCE A LITERAL  0\n         LA    15,=C'&VV'       FETCH WORD                    .LIT4N\n&OPR     SETC  'ST'\n&OPD     SETC  '15,&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2\n.REG4N   CECDYN CMT2,.REG4N TO-FIELD LGH 4 NUMERIC, SOURCE REG-FORMAT 0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,0(&VV)' OR '&NAME,0&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2\n.ACN4N   CECDYN CMT2,.ACN4N TO-FIELD LGH 4 NUMERIC, SOURCE ACON-FORMAT0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'LA'\n&OPD     SETC  '15,&VV'\n&CMT     SETC  'LOAD ADDRESS OF FIELD'\n&GENRETI SETA  5             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET5\n.GENRET5 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'ST'\n&OPD     SETC  '15,&NAME'\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n&GENRETI SETA  2 PREPARE RETURN POINTER--CHECK FOR HIBIT AFTERWARD\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2\n.*\n.GENRET2 AIF   (NOT &HIBIT).CR#EXIT    NOTHING SPECIAL TO DO          0\n         OI    &NAME,X'80'      TURN ON HIGH BIT              .GENRET2\n         AGO   .CR#EXIT\n.*..+....1....+....2....+....3....+....4                              1\n.GENCOM  ANOP , GENERATE A STMT, W/ COMMENT FIELD AND W/ &CEC#CMT2VAL 0\n.* THIS IS AN AGO-TYPE INTERNAL ROUTINE --\n.* IT EXITS WITH THE STATEMENT:            AGO .GENRET&GENRETI\n.*\n.* INPUTS: LOCAL SETC VARIABLES: &LBL          LABEL\n.*                               &OPR          OPERATOR\n.*                               &OPD          OPERAND\n.*                               &CMT          COMMENT\n.*         GLOBAL SETC VARIABLE: &CEC#CMT2VAL  SECONDARY COMMENT\n.* OUTPUT: STATEMENT/MNOTE: &LBL     &OPR  &OPD&CMT&CEC#CMT2VAL\n.*         WITH COLUMNS:   '....+....1....+..  .   .\n.*         (&LBL IN COLUMN 1,\n.*          &OPR IN COLUMN 10 IF POSSIBLE, ELSE SHIFTED,\n.*          &OPD IN COLUMN 16 IF POSSIBLE, ELSE SHIFTED,\n.*          &CMT IN COLUMN &CECCMT1COL (ON A CONT'N IF NECESSARY),\n.*  &CEC#CMT2VAL IN COLUMN &CECCMT2COL (ON A CONT'N IF NECESSARY).)\n.*..+....1....+....2....+....3                                        0\n.*\n.* TRIM ALL BLANKS FROM RIGHT-HAND END OF &LBL\n         AIF   (K'&LBL EQ 0).OKLBL     LENGTH ZERO--NO TRIM NECESSARY\n.TRIMLBL AIF   ('&LBL'(K'&LBL,1) NE ' ').OKLBL  Q. LAST CHAR A BLANK?\n.* A. YES, LAST CHARACTER IS A BLANK\n         AIF   (K'&LBL EQ 1).ZZLBL     LENGTH ONE--NO PAD NECESSARY\n&LBL     SETC  '&LBL'(1,K'&LBL-1)      A. YES--TRIM LAST CHARACTER AND\n         AGO   .TRIMLBL                    GO BACK AND CHECK SOME MORE\n.OKLBL   ANOP  ,                       A. NO--NO MORE TRIM NECESSARY\n.*\n&LBL     SETC  '&LBL. '                ADD EXACTLY 1 BLANK\n.ZZLBL   ANOP  ,\n.*\n.* CALCULATE HOW MUCH ROOM WE HAVE TO WORK WITH:\n&LCLA    SETA  10-1          COLUMNS 1 THROUGH JUST-BEFORE 10\n.*\n         AIF   (&LCLA LE K'&LBL).PADLBLZ NO PAD NECESSARY\n&LBL     SETC  '&LBL'.(&LCLA-K'&LBL)' ' PAD TO LENGTH NECESSARY\n.PADLBLZ ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* TRIM ALL BLANKS FROM RIGHT-HAND END OF &OPR\n         AIF   (K'&OPR EQ 0).OKOPR     LENGTH ZERO--NO TRIM NECESSARY\n.TRIMOPR AIF   ('&OPR'(K'&OPR,1) NE ' ').OKOPR  Q. LAST CHAR A BLANK?\n.* A. YES, LAST CHARACTER IS A BLANK\n         AIF   (K'&OPR EQ 1).ZZOPR     LENGTH ONE--NO PAD NECESSARY\n&OPR     SETC  '&OPR'(1,K'&OPR-1)      A. YES--TRIM LAST CHARACTER AND\n         AGO   .TRIMOPR                    GO BACK AND CHECK SOME MORE\n.OKOPR   ANOP  ,                       A. NO--NO MORE TRIM NECESSARY\n.*\n&OPR     SETC  '&OPR. '                ADD EXACTLY 1 BLANK\n.ZZOPR   ANOP  ,\n.*\n.* CALCULATE HOW MUCH ROOM WE HAVE TO WORK WITH:\n&LCLA    SETA  16-10         COLUMNS 10 THROUGH JUST-BEFORE 16\n.*\n         AIF   (&LCLA LE K'&OPR).PADOPRZ NO PAD NECESSARY\n&OPR     SETC  '&OPR'.(&LCLA-K'&OPR)' ' PAD TO LENGTH NECESSARY\n.PADOPRZ ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* TRIM ALL BLANKS FROM RIGHT-HAND END OF &OPD\n         AIF   (K'&OPD EQ 0).OKOPD     LENGTH ZERO--NO TRIM NECESSARY\n.TRIMOPD AIF   ('&OPD'(K'&OPD,1) NE ' ').OKOPD  Q. LAST CHAR A BLANK?\n.* A. YES, LAST CHARACTER IS A BLANK\n         AIF   (K'&OPD EQ 1).ZZOPD     LENGTH ONE--NO PAD NECESSARY\n&OPD     SETC  '&OPD'(1,K'&OPD-1)      A. YES--TRIM LAST CHARACTER AND\n         AGO   .TRIMOPD                    GO BACK AND CHECK SOME MORE\n.OKOPD   ANOP  ,                       A. NO--NO MORE TRIM NECESSARY\n.*\n&OPD     SETC  '&OPD. '                ADD EXACTLY 1 BLANK\n.ZZOPD   ANOP  ,\n.*\n.* CALCULATE HOW MUCH ROOM WE HAVE TO WORK WITH:\n&LCLA    SETA  &CECCMT1COL-16\n.*\n.PADOPDL ANOP  ,                       ADDITIONAL LINE\n         AIF   (K'&OPD LE &LCLA).PADOPDY                               X\n                                       Q. &OPD SHORT ENOUGH TO FIT?\n&LCLA    SETA  &LCLA+56                 A. NO--USE AN ADDITIONAL LINE\n.* NOTE--EACH CONTINUATION LINE GIVES 56 MORE CHARACTERS (COLS 16-71)\n         AGO   .PADOPDL\n.PADOPDY ANOP  ,                        A. YES--IT WILL FIT\n.*\n         AIF   (&LCLA LE K'&OPD).PADOPDZ NO PAD NECESSARY\n&OPD     SETC  '&OPD'.(&LCLA-K'&OPD)' ' PAD TO LENGTH NECESSARY\n.PADOPDZ ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* TRIM ALL BLANKS FROM RIGHT-HAND END OF &CMT\n         AIF   (K'&CMT EQ 0).OKCMT     LENGTH ZERO--NO TRIM NECESSARY\n.TRIMCMT AIF   ('&CMT'(K'&CMT,1) NE ' ').OKCMT  Q. LAST CHAR A BLANK?\n         AIF   (K'&CMT EQ 1).ZZCMT     LENGTH ONE--NO PAD NECESSARY\n&CMT     SETC  '&CMT'(1,K'&CMT-1)      A. YES--TRIM LAST CHARACTER AND\n         AGO   .TRIMCMT                    GO BACK AND CHECK SOME MORE\n.OKCMT   ANOP  ,                       A. NO--NO MORE TRIM NECESSARY\n.*\n&CMT     SETC  '&CMT. '                ADD EXACTLY 1 BLANK\n.ZZCMT   ANOP  ,\n.*\n.* CALCULATE HOW MUCH ROOM WE HAVE TO WORK WITH:\n&LCLA    SETA  &CECCMT2COL-&CECCMT1COL\n.*\n.PADCMTL ANOP  ,                       ADDITIONAL LINE\n         AIF   (K'&CMT LE &LCLA).PADCMTY Q. &CMT SHORT ENOUGH TO FIT?\n&LCLA    SETA  &LCLA+56                  A. NO--USE AN ADDITIONAL LINE\n.* NOTE--EACH CONTINUATION LINE GIVES 56 MORE CHARACTERS (COLS 16-71)\n         AGO   .PADCMTL\n.PADCMTY ANOP  ,                        A. YES--IT WILL FIT\n.*\n         AIF   (&LCLA LE K'&CMT).PADCMTZ NO PAD NECESSARY\n&CMT     SETC  '&CMT'.(&LCLA-K'&CMT)' ' PAD TO LENGTH NECESSARY\n.PADCMTZ ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n         AIF   ('&LBL'(1,1) EQ '*').DOMNOTE\n&LCLAX(1) SETA K'&LBL,K'&OPR,K'&OPD,K'&CMT\n         CECDYN DEBUG,' CECDYN *2',                                    X\n               ' LBL=&LCLAX(1),\"&LBL\"',                                X\n               ' OPR=&LCLAX(2),\"&OPR\"',                                X\n               ' OPD=&LCLAX(3),\"&OPD\"',                                X\n               ' CMT=&LCLAX(4),\"&CMT\"',                                X\n               ' CMT1COL=&CECCMT1COL, CMT2COL=&CECCMT2COL',            X\n               ' CEC#CMT1COL=&CEC#CMT1COL, CEC#CMT2COL=&CEC#CMT2COL'\n.*\n.* THIS IS THE MAIN PURPOSE OF ROUTINE .GENCOM:\n&LBL     &OPR  &OPD&CMT&CEC#CMT2VAL\n.* THAT WAS THE MAIN PURPOSE OF ROUTINE .GENCOM--YOU ALMOST MISSED IT.\n.*\n         AGO   .DONEIT\n.*..+....1....+....2                                                  0\n.*\n.DOMNOTE ANOP  ,\n.*\n         MNOTE '&LBL&OPR&OPD&CMT&CEC#CMT2VAL'\n.*\n         AGO   .DONEIT\n.*..+....1                                                            0\n.*\n.DONEIT  ANOP  ,\n.*\n&LCLA    SETA  &GENRETI      FETCH RETURN INDEX\n&GENRETI SETA  1             RETURN POINTER TO DEFAULT, FOR NEXT TIME\n.* ACTUAL CODE GENERATION:\n         AGO   (&LCLA).GENRET1,.GENRET2,.GENRET3,.GENRET4,.GENRET5,    X\n               .GENRET6,.GENRET7,.GENRET8,.GENRET9\n.***************************\n.* THE EFFECT OF THE ABOVE CODE IS:\n.*       AGO   .GENRET&LCLA\n.***************************\n         MNOTE 16,'SEVERE INTERNAL ERROR'\n         MNOTE 'GENRETI=&LCLA'\n&CEC#DEBUG SETB 1      TURN ON\n         AGO   .CR#EXIT\n.*..+....1                                                            0\n.*\n.GENRET1 AGO   .CR#EXIT , DEFAULT EXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70\n.*\n.CR#EXIT ANOP  ,\n&CECCMT1COL SETA &CEC#CMT1COL COMMENT 1 FIELD'S COLUMN\n&CECCMT2COL SETA &CEC#CMT2COL COMMENT 2 FIELD'S COLUMN\n         AGO   .SUBEXIT , EXIT FROM .CREAT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.DEBUG   ANOP  , SELF-CALL INTERNAL ROUTINE -- DISPLAY DEBUG MNOTES   0\n.*\n.* IF NO PARAMETERS BESIDES FIRST, TURN ON DEBUGGING AND .SUBEXIT\n         AIF   (N'&SYSLIST NE 1).NORMALDBG\n&CEC#DEBUG SETB 1      TURN ON\n         AGO   .SUBEXIT\n.NORMALDBG ANOP  ,\n.*\n.* IF JUST 1 PARAMETER BESIDES FIRST, AND IT STARTS WITH \".\", SAVE IT\n.* OR IF IT STARTS WITH \".'\", SAVE IT WITHOUT QUOTES\n         AIF   (N'&SYSLIST NE 2).NOSAVE\n         AIF   ('&POS2'(1,1) EQ '.').YSSAVE\n         AIF   ('&POS2'(1,2) EQ '''.').YSSAVEQ\n         AGO   .NOSAVE\n.YSSAVE  ANOP  ,\n&CEC#DBG#HDR SETC '&POS2'\n         AGO   .SUBEXIT\n.YSSAVEQ ANOP   ,\n&CEC#DBG#HDR SETC '&POS2'(2,K'&POS2-2) REMOVE QUOTES\n         AGO   .SUBEXIT\n.NOSAVE  ANOP  ,\n.*\n         AIF   (NOT &CEC#DEBUG).SUBEXIT IMMEDIATE RETURN\n.*\n         CECDYN MNOTE,&CEC#DBG#HDR,' -- ',&POS2,&POS3,&POS4,&POS5,     X\n               &POS6,&POS7,&POS8,&POS9,&POS10\n         AGO   .SUBEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.DOKEY   ANOP  , SELF-CALL INTERNAL ROUTINE -- PROCESS ONE TEXT UNIT  0\n.* ('USER-SUPPLIED' MEANS ON THE OUTER CALL TO CECDYN, FROM OPEN CODE)\n.* INPUT: POSITIONAL PARAMETERS\n.* &POS1  ALWAYS DOKEY\n.* &POS2  ALWAYS &I, ORDINAL TEXT UNIT NUMBER (BUILD '1ST','2ND',ETC.)\n.* &POS3  ALWAYS &KEY, USER-SUPPLIED TEXT UNIT KEY\n.* &POS4  ALWAYS &TEXT(&I,2), USER-SUPPLIED VALUE(S)\n.* &POS5  A TEXT UNIT NAME FROM IEFZB4D2\n.* &POS6  A SINGLE NUMBER OR A PAIR OF NUMBERS (MINPRMS,MAXPRMS) .\n.*         THIS GIVES LIMITS FOR S99TUNUM, WHICH \"SPECIFIES THE NUMBER\n.*         OF LENGTH-AND-PARAMETER COMBINATIONS IN THE TEXT UNIT\".\n.* &POS7  A SINGLE CHARACTER, THE FIELD TYPE C/X/F/A TO BE GENERATED.\n.* &POS8  A SINGLE NUMBER OR A PAIR OF NUMBERS (MINLNG,MAXLNG) .\n.*         THIS GIVES LIMITS FOR S99TULNG, WHICH \"SPECIFIES THE LENGTH\n.*         OF THE FOLLOWING PARAMETER FIELD\".\n.* &POS9  * -- A SINGLE ASTERISK\n.*        OR A LIST ((<CHARS>,<VALU>), (<CHARS>,<VALU>), ...)\n.*     OR A LIST (+, (<CHARS>,<VALU>), (<CHARS>,<VALU>), ...) .\n.*        WHEN A SINGLE ASTERISK IS SPECIFIED, A LABEL IS GENERATED\n.*     FOR AN INFORMATION-RETURN FIELD, CONSISTING OF &PREFIX PLUS\n.*     THE TEXT UNIT'S NAME.\n.*        WHEN A LIST IS SPECIFIED, THE USER-SUPPLIED VALUE(S) ARE\n.*     COMPARED AGAINST EACH <CHARS> ENTRY IN THE LIST, AND WHEN\n.*     AN EQUAL IS FOUND, THE CORRESPONDING <VALU> IS USED.\n.*     ORDINARILY, THE USER CAN ONLY SPECIFY ONE VALUE.  WHEN THE\n.*     LIST BEGINS WITH '+', MULTIPLE VALUES SPECIFIED BY THE USER\n.*     ARE TRANSLATED INTO MULTIPLE <VALU>S WHICH ARE THEN SUMMED TO\n.*     GENERATE A VALUE.\n.*        A <CHARS> ENTRY OF A SINGLE ASTERISK IS CONSIDERED A MATCH\n.*     FOR ANY VALUE SPECIFIED BY THE USER.\n.*        IN ADDITION TO THE VALUE GENERATED, A COMMENT IS GENERATED\n.*     IN THE FORM \"<CHARS>=<VALU>\".\n.*        IF THE LIST ENDS WITH AN ASTERISK, THEN NO ERROR MESSAGE\n.*     IS GENERATED FOR THE USER-SPECIFIED VALUE NOT BEING FOUND\n.*     AMONG THE <CHARS> ENTRIES, AND THE USER-SPECIFIED VALUE IS\n.*     USED AS-IS.\n.* &POS10  TEXT APPENDED TO THE GENERATED COMMENT.\n.*\n.*\n.*\n.* IF THERE IS ONLY 1 TEXT UNIT NAME IN THE LIST (N'&POS5 EQ 1) AND\n.* IT DOES NOT EQUAL THE ONE THE USER SUPPLIED    ('&POS3' NE '&POS5')\n.* THEN EXIT IMMEDIATELY     (.SUBEXIT)\n         AIF   (                                  N'&POS5 EQ 1  AND    X\n                                                   '&POS3' NE '&POS5'  X\n                             ).SUBEXIT\n.*\n.*\n.* IN CASE MORE THAN 1 TEXT UNIT NAME IS CODED,\n.* FIND USER-SUPPLIED &POS3 IN THE &POS5 LIST OF TEXT UNIT NAMES\n&J       SETA  1\n.NEXTJ01 ANOP  ,\n         AIF   ('&POS3' EQ '&POS5(&J)').EXITJ01\n.ADVJ01  ANOP  , ADVANCE &J\n&J       SETA  &J+1\n         AIF   (&J LE N'&POS5).NEXTJ01\n         AGO   .SUBEXIT , NOT FOUND, EXIT IMMEDIATELY\n.EXITJ01 ANOP  ,\n.* NOW &J POINTS TO THE ENTRY IN THE &POS5 LIST THAT MATCHES &POS3.\n.*\n.*\n.A#DOKEY CECDYN DEBUG,'.DOKEY A#DOKEY' SAVE HEADING FOR DEBUG MESSAGES\n.*\n.******* CECDYN DEBUG,'&NAME CECDYN *1 &POS1,&POS2,\"',                 X\n               &POS3,'\",&POS4,\"',                                      X\n               &POS5,'\",\"',                                            X\n               &POS6,'\",&POS7,&POS8,\"',                                X\n               &POS9,'\"'\n.*\n&CEC#KEYDONE SETB 1          INFORM CALLER, KEY HAS BEEN FOUND\n&I       SETA  &POS2\n&KEY     SETC  '&POS3'\n.*\n&CECCMT1COL SETA &CEC#CMT1COL COMMENT 1 FIELD'S COLUMN\n&CECCMT2COL SETA &CEC#CMT2COL COMMENT 2 FIELD'S COLUMN\n.* (EACH CALL TO .CREAT DOES ABOVE SETA.S, JUST BEFORE EXITING)\n.*\n&CEC#XLAT SETB (N'&POS9 GT 1  OR  '&POS7' EQ 'A')\n.*           IF N'&POS9 GT 1, THEN DEFINITELY A TRANSLATION TABLE.\n.* BUT, &POS9 MAY BE OMITTED;  IF '&POS7' EQ 'A', IT IS NUMERIC;\n.* ACT LIKE #XLAT.\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.A#XLAT  CECDYN DEBUG,'.DOKEY A#XLAT' SAVE HEADING FOR DEBUG MESSAGES\n&MAXJ    SETA  1             ONE VALUE TO BE GENERATED\n         AIF   (&CEC#XLAT).GENHDR     GENERATE GROUP HEADER\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.A#XCHK  CECDYN DEBUG,'.DOKEY A#XCHK' SAVE HEADING FOR DEBUG MESSAGES\n.*                           SET &MAXJ, AND OTHER THINGS\n.* FALL-THRU TO .GENHDR      AND THEN GENERATE GROUP HEADER\n.*\n.*\n.* FIRST, CROSS-CHECK BETWEEN:\n.*       N'&POS4 (NUMBER OF VALUES SPECIFIED BY THE CALLER)\n.*     AND &POS6 (NUMBER OF VALUES EXPECTED).\n.*\n         AIF   ((N'&POS6-1)*(N'&POS6-2) EQ 0).C#XCHK\n         MNOTE 4,'INTERNAL ERROR PROCESSING KEY &POS3 -- &&POS6 SHOULD X\n               HAVE ONLY 1 OR 2 ENTRIES, IT WAS \"&POS6\"'\n.C#XCHK  ANOP  ,\n.* IF N'&POS6=1, A FIXED # VALUES IS EXPECTED, &POS6(1)\n.* IF N'&POS6=2, MIN # VALUES EXPECTED IS &POS6(1), MAX IS &POS6(2)\n         AIF   (N'&POS6 NE 1).D#XCHK  VARIABLE NUMBER POSSIBLE? YES\n         AIF   (&POS6(1) NE 0).D#XCHK NON-ZERO NUMBER REQUIRED? YES\n         AIF   (N'&POS4 NE 0).D#XCHK  USER SUPPLIED AT LEAST 1? YES\n.* FIXED NUMBER POSSIBLE, WHICH IS ZERO, AND USER DID NOT SUPPLY ANY:\n&MAXJ    SETA  0            NO VALUES TO BE GENERATED\n         AGO   .F#XCHK      GO GENERATE THEM\n.D#XCHK  AIF   (N'&POS4 LE &POS6(N'&POS6)).E#XCHK Q. TOO MANY? A. NO  0\n&LCLA2   SETA  N'&POS4      # VALUES SPECIFIED                 A. YES\n         MNOTE 8,'ERROR: &LCLA2 VALUES WERE SPECIFIED FOR KEY &POS3 -- X\n               &POS6(N'&POS6) IS THE MAXIMUM NUMBER PERMITTED.'\n.E#XCHK  ANOP  ,\n&MAXJ    SETA  &POS6(1)     FIRST OR ONLY -- MINIMUM OR REQUIRED #\n         AIF   (&MAXJ GT N'&POS4).F#XCHK CALLER SPECIFIED FEWER? YES,  X\n                                       GENERATE THE MINIMUM # REQUIRED\n&MAXJ    SETA  N'&POS4 NO, GENERATE AS MANY VALUES AS CALLER SPECIFIED\n.*\n.F#XCHK  ANOP  ,\n.*\n         CECDYN DEBUG,'POS4=&POS4, POS6=&POS6, SO MAXJ=&MAXJ..'\n.*\n         AGO   .GENHDR\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.GENHDR  ANOP  ,             GENERATE GROUP HEADER\n.*\n.* BOTH .XLAT AND .XCHK PASS THROUGH HERE\n.*\n         AIF   (&CEC#XLAT).Q#XLAT\n.Q#XCHK  CECDYN CMT2,.XCHK   SET &CEC#CMT2VAL\n         AGO   .Q#BOTH\n.Q#XLAT  CECDYN CMT2,.XLAT   SET &CEC#CMT2VAL\n.Q#BOTH  ANOP  ,\n.*\n&CEC#P.NUM&I CECDYN CREAT,,A,2,&MAXJ,'# OF LENGTH+PARAMETER ENTRIES'\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.*\n.* IF &POS9 IS NOT A TRANSLATION TABLE, GENERATE MULTIPLE VALUES.\n.*\n         AIF   (&MAXJ EQ 0).SUBEXIT   NO VALUES TO BE GENERATED? YES\n.*\n.* IF THERE IS A MINIMUM NUMBER, DO THAT MANY (NULL VALUES, IF NEEDED)\n.*                               ELSE DO AS MANY AS CALLER SPECIFIED\n.*\n.* NOW, LOOP THROUGH REQUIRED NUMBER (FROM 1 UP THROUGH &MAXJ)\n&J       SETA  1\n.NEXTJ02 CECDYN DEBUG,'.DOKEY NEXTJ02' SAVE HEADING FOR DEBUG MESSAGES\n&SUFFIX  SETC  ''                  NO SUFFIX NEEDED, IF ONLY 1 FIELD\n         AIF   (&MAXJ EQ 1).SFXOK  YES, ONLY 1 FIELD TO BE GENERATED\n&SUFFIX  SETC  '#&J'               IF MORE THAN 1, DISTINGUISH THEM\n.SFXOK   ANOP  ,\n&CEC#P.ENT&I&SUFFIX CECDYN CREAT,0,C,,,'ENTRY OF LENGTH+PARAMETER'\n.*..+....1....+....2....+....3....+....4                              0\n.*..+....1....+....2....+....3....+....4                              1\n.*\n         AIF   (NOT &CEC#XLAT).NOXLAT2\n.*\n.XLATVV  ANOP  , WHEN &CEC#XLAT, SET &VALUE, &VALUE2, &LV\n.*             (NOTE: WHEN &CEC#XLAT, THEN &MAXJ IS 1, SO THIS CODE\n.*              IS NOT DONE EACH TIME THROUGH THE .NEXTJ02 LOOP)\n.*\n.*       &POS4 IS VALUES SPECIFIED BY CALLER;              (INDEX &K)\n.*       &POS9 IS TRANSLATION TABLE   ((R,2),(N,8),...)\n.*                               OR (+,(R,2),(N,8),...)    (INDEX &L)\n.* EACH TRANSLATION TABLE ENTRY CONSISTS OF:\n.*      &POS9(&L,1) <CHARS> FROM, AND &POS9(&L,2) <VALU> TO\n.*\n.* TWO LOOPS BELOW, LOOP BY &L WITHIN LOOP BY &K\n.*\n&VALUE   SETC  '&POS4'                 VALUE\n&VALUE2  SETC  '&KEY'                  COMMENT\n         AIF   (N'&POS9 EQ 0 AND N'&POS4 EQ 1).EXITK02 SKIP ENTIRELY\n.*\n.T#XLAT  CECDYN DEBUG,'.DOKEY T#XLAT' SAVE HEADING FOR DEBUG MESSAGES\n&VALUE   SETC  '0'                     INITIAL VALUE\n&VALUE2  SETC  ''                      INITIAL COMMENT\n         AIF   (N'&POS4 EQ 0).EXITK02\n&K       SETA  1\n.NEXTK02 ANOP  ,\n.*\n.* PROCESS ENTRY &POS4(&K) SPECIFIED BY USER\n.*\n&POS4K   SETC  '&POS4(&K)'\n         AIF   (N'&POS4 NE 1 OR &MAXJ NE 1).POS4KOK\n&POS4K   SETC  '&POS4'       PASS-THRU PARENS OF REGISTER OPERAND\n.POS4KOK ANOP  ,\n.*\n&LCLC    SETC  '0'                          DEFAULT VALUE\n&LCLC2   SETC  'IGNORE &POS4K'              DEFAULT COMMENT\n.*\n.*          IF (&K EQ 1) ALWAYS TRANSLATE FIRST USER-SPECIFIED VALUE:\n         AIF   (&K EQ 1).YESXLAT\n.*          IF WE ARE SUMMING, TRANSLATE ALL USER-SPECIFIED VALUES:\n         AIF   ('&POS9(1)' EQ '+' OR '&POS9(1)' EQ '''+''').YESXLAT\n         AGO   .SKIPXLT IF NOT SUMMING, ONLY TRANSLATE FIRST VALUE\n.YESXLAT ANOP  ,\n.*\n&L       SETA  1\n.NEXTL02 ANOP  ,\n         AIF   (N'&POS9(&L) NE 2).ADVL02 (SKIP NON-PAIRS IN &POS9)\n         AIF   ('&POS9(&L,1)' EQ '*').MATCH\n         AIF   ('&POS9(&L,1)' EQ '&POS4K').MATCH\n         AGO   .ADVL02\n.MATCH   ANOP  ,\n&LCLC    SETC  '&POS9(&L,2)'                RETURN VALUE\n&LCLC2   SETC  '&POS9(&L,1)=&POS9(&L,2)'    RETURN COMMENT\n         AGO   .EXITL02\n.ADVL02  ANOP  , ADVANCE &L\n&L       SETA  &L+1\n         AIF   (&L LE N'&POS9).NEXTL02\n.*\n.* WE REACH HERE IF &POS4K IS NOT FOUND IN THE TRANSLATE TABLE\n         AIF   ('&POS9(&L-1)' NE '*').EXITL02\n.* IF LAST ENTRY IN TRANSLATE TABLE IS '*', OK TO BE NOT-FOUND\n&LCLC    SETC  '&POS4K'                     RETURN VALUE\n&LCLC2   SETC  '&POS4K NOT TRANSLATED'      RETURN COMMENT\n.*\n.EXITL02 ANOP  , &LCLC=RETURN VALUE, &LCLC2=RETURN COMMENT\n.*\n.SKIPXLT ANOP  , SKIP TRANSLATION CODE ABOVE\n         AIF   (&K NE 1).ADDVALS ELSE SETVALS\n.SETVALS ANOP  ,\n&VALUE   SETC  '&LCLC'                 SET VALUE\n&VALUE2  SETC  '&KEY &LCLC2'           SET COMMENT\n         AGO   .ADVK02\n.ADDVALS ANOP  ,\n&VALUE   SETC  '&VALUE+&LCLC'          APPEND TO VALUE\n&VALUE2  SETC  '&VALUE2, &LCLC2'       APPEND TO COMMENT\n.ADVK02  ANOP  , ADVANCE &K\n&K       SETA  &K+1\n         AIF   (&K LE N'&POS4).NEXTK02\n         AGO   .EXITK02\n.*\n.EXITK02 ANOP  ,\n.*\n&LCLC    SETC  '&POS10'                           FETCH VALUE\n         AIF   (K'&LCLC LE 2).NOTCOMT             TOO SHORT FOR QUOTES\n         AIF   ('&LCLC'(1,1) NE '''').NOTCOMT       NOT LEADING QUOTE,\n         AIF   ('&LCLC'(K'&LCLC,1) NE '''').NOTCOMT NOR TRAILING.\n&LCLC    SETC  '&LCLC'(2,K'&LCLC-2)               REMOVE QUOTES\n.NOTCOMT ANOP  ,\n&VALUE2  SETC  '&VALUE2 &LCLC'\n.*\n         AIF   (&CEC#FLAG(1)).B#CHGV2      DC -- TEXT ONLY\n         AIF   (&CEC#FLAG(2)).B#CHGV2      DS -- TEXT ONLY\n         AIF   ('&VALUE2' NE '').X#CHGV2      ACTIVE -- DESCRIBE XLATE\n.* IF NO XLATE WAS DONE, FALL THRU TO TEXT ONLY\n.B#CHGV2 ANOP  ,\n&VALUE2  SETC  ''   LET IT BE OVERRIDDEN LATER\n.X#CHGV2 ANOP  ,\n.*\n&LV      SETA  &POS8(1)\n.*\n.NOXLAT2 ANOP  ,\n.*..+....1....+....2....+....3....+....4                              0\n.*..+....1....+....2....+....3....+....4                              1\n.*\n         AIF   (&CEC#XLAT).NOXCHK2\n.*\n.XCHKVV  ANOP  , WHEN NOT &CEC#XLAT, SET &VALUE, &VALUE2, &LV\n.*\n.* ANALYSE CALLER-SPECIFIED VALUE:\n.* &POS4(&J)=''      PRODUCES &NUL=1\n.*\n.* &POS4(&J)='...' PRODUCES &LIT=1\n.* &POS4(&J)=(...) PRODUCES &REG=1\n.* &POS4(&J)=A(...) PRODUCES &ACN=1\n.*   NOTE--IF A LIST WITH ONLY 1 ENTRY IS SPECIFIED, THAT IS &REG.\n&VALUE   SETC  '&POS4(&J)'\n         AIF   (N'&POS4 NE 1).BBVAL\n&VALUE   SETC  '&POS4'       PROPOGATE PARENS, SO &REG IS CORRECT\n.BBVAL   ANOP  ,\n.*\n&LIT     SETB  0             LITERAL\n&REG     SETB  0             REGISTER\n&ACN     SETB  0             ADDRESS CONSTANT\n&NUL     SETB  1             NULL -- OMITTED\n&LCLC    SETC   'POS4(J=&J.)=&VALUE.,'     PREPARE FOR DEBUGGING\n         AIF   (K'&VALUE EQ 0).ZZVAL             .* IF NULL SKIP\n         AIF   ('&VALUE' EQ '').ZZVAL            .* IF NULL SKIP\n&NUL     SETB  0                               .* RESET NULL IF NOT\n         AIF   (K'&VALUE LT 3).XXVAL TOO SHORT TO BE ANYTHING\n&LIT     SETB  ('&VALUE'(1,1) EQ '''' AND '&VALUE'(K'&VALUE,1) EQ '''')\n&LCLC    SETC   'POS4(J=&J.)='.'&VALUE'(2,K'&VALUE-2).','\n         AIF   (&LIT).ZZVAL\n&LCLC    SETC   'POS4(J=&J.)=&VALUE.,'     PREPARE FOR DEBUGGING\n&REG     SETB  ('&VALUE'(1,1) EQ '(' AND '&VALUE'(K'&VALUE,1) EQ ')')\n         AIF   (&REG).ZZVAL\n         AIF   (K'&VALUE LT 4).XXVAL TOO SHORT TO BE ACN\n&ACN     SETB  ('&VALUE'(1,2) EQ 'A(' AND '&VALUE'(K'&VALUE,1) EQ ')')\n         AIF   (&ACN).ZZVAL\n.XXVAL   ANOP  ,\n.ZZVAL   ANOP  ,\n         CECDYN DEBUG,'&LCLC NUL=&NUL, LIT=&LIT, REG=&REG, ACN=&ACN..'\n.*..+....1....+....2....+....3                                        0\n.*\n.A#LGH   CECDYN DEBUG,'.DOKEY A#LGH' SAVE HEADING FOR DEBUG MESSAGES\n.* DEFAULT VALUE LENGTH IS MAX VALUE LENGTH\n.* IF RANGE PERMITTED, AND CALLER SPECIFIED LITERAL VALUE,\n.*       THEN USE MAXIMUM OF (CALLER'S VALUE'S LENGTH, MINIMUM LENGTH)\n.*       &POS4 IS (VALUES) SPECIFIED BY CALLER;\n.*       &POS8 IS LENGTH OF EACH VALUE EXPECTED\n         AIF   ((N'&POS8-1)*(N'&POS8-2) EQ 0).B#LGH\n         MNOTE 4,'INTERNAL ERROR PROCESSING KEY &POS3 -- &&POS8 SHOULD X\n               HAVE ONLY 1 OR 2 ENTRIES, IT WAS \"&POS8\"'\n.B#LGH   ANOP  ,\n.* IF N'&POS8=1, A FIXED LENGTH IS EXPECTED,  &POS8(1)\n.* IF N'&POS8=2, MINIMUM LENGTH EXPECTED IS &POS8(1), MAX IS &POS8(2)\n&LMIN    SETA  &POS8(1)      MUST BE SELF-DEFINING DECIMAL TERM\n&LMAX    SETA  &POS8(N'&POS8) MUST BE SELF-DEFINING DECIMAL TERM\n&LV      SETA  &LMAX         DEFAULT VALUE LENGTH IS MAX VALUE LENGTH\n         AIF   (N'&POS8 EQ 1).G#LGH OK--ONLY 1, USE THAT LENGTH\n         AIF   (NOT &LIT).G#LGH       OK--USE MAX (OR ONLY) LENGTH\n&LV      SETA  &LMIN         DEFAULT VALUE LENGTH IS MIN VALUE LENGTH\n&LCLA2   SETA  K'&POS4(&J)-2 LENGTH OF VALUE SPECIFIED (W/O QUOTES)\n         AIF   (&LCLA2 LT &LMIN).G#LGH  OK--FORCE MINIMUM LENGTH\n&LV      SETA  &LCLA2        OK--USE CALLER'S VALUE'S LENGTH\n.G#LGH   ANOP  ,\n.X#LGH   ANOP  ,\n         CECDYN DEBUG,' POS8=&POS8.; MIN=&LMIN., MAX=&LMAX..'\n&LCLC    SETC  'K''''POS4(J=&J.)=K'''''.'&POS4(&J).=&LCLA2.;'\n&LCLC    SETC  '&LCLC. LENGTH USED IS LV=&LV..'\n         CECDYN DEBUG,'&LCLC'\n.*\n&VALUE2  SETC  ''   LET IT BE OVERRIDDEN LATER\n.*\n.NOXCHK2 ANOP  ,                                                      0\n.*..+....1....+....2....+....3....+....4\n.*..+....1....+....2....+....3....+....4\n&I1      SETA  &I-10*(&I/10)           1'S DIGIT OF &I\n&I10     SETA  (&I/10)-10*(&I/100)     10'S DIGIT OF &I\n&IIX     SETA  1+3*(&I1*(&I10-1)/(&I10-1)) IGNORE &I1 IF (&I10-1) EQ 0\n&ITH     SETC  'TH ST ND RD TH TH TH TH TH TH '(&IIX,2) 0TH, 1ST, ETC.\n.*..+....1\n&J1      SETA  &J-10*(&J/10)           1'S DIGIT OF &J\n&J10     SETA  (&J/10)-10*(&J/100)     10'S DIGIT OF &J\n&JIX     SETA  1+3*(&J1*(&J10-1)/(&J10-1)) IGNORE &J1 IF (&J10-1) EQ 0\n&JTH     SETC  'TH ST ND RD TH TH TH TH TH TH '(&JIX,2) 0TH, 1ST, ETC.\n.*..+....1\n&CEC#P.LNG&I&SUFFIX CECDYN CREAT,,A,2,&LV,                             X\n               'LENGTH OF &J&JTH PARM. OF &I&ITH KEY'\n         AIF   (&J NE 1).NOLABEL             LABEL ONLY FOR FIRST\n.******* AIF   ('&POS9' NE '*').NOLABEL Q. MUST WE DEFINE NAME? A. NO\n.*                                                              A. YES\n         AIF   ('&POS9' NE '*' AND '&CEC#CMT2VAL' EQ '.XLAT').NOLABEL\n.* (FOR .XCHK, FALL THROUGH ALL THE TIME)\n.*\n&LCLC    SETC  '&CEC#P'.'&KEY'(4,K'&KEY-3)\n&LCLC    CECDYN CREAT,0,&POS7,&LV,,'DEFINE NAME FOR USER'\n.NOLABEL ANOP  ,\n.*\n         AIF   ('&VALUE2' NE '').NOTNULL\n&VALUE2  SETC  'VALUE OF &J&JTH PARM. OF &I&ITH KEY' OVERRIDE HERE\n.NOTNULL ANOP  ,\n.*\n&CEC#P.PAR&I&SUFFIX CECDYN CREAT,,&POS7,&LV,&VALUE,'&VALUE2'\n.*..+....1....+....2....+....3                                        0\n.*\n.ADVJ02  ANOP  , ADVANCE &J\n&J       SETA  &J+1\n         AIF   (&J LE &MAXJ).NEXTJ02\n.*\n         AGO   .SUBEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.MNOTE   ANOP  , SELF-CALL INTERNAL ROUTINE -- MNOTE '&POS2&POS3...'\n&LCLC    SETC  ''\n.*\n&J       SETA  2\n.NEXTJ04 ANOP  ,\n.*\n.*\n         AIF   ('&SYSLIST(&J)' EQ '').EXITI04\n&LCLB    SETB  ('&SYSLIST(&J)'(1,1) EQ '''' AND                        X\n                             '&SYSLIST(&J)'(K'&SYSLIST(&J),1) EQ '''')\n.* QUOTES AT BOTH ENDS?\n&I       SETA  1+&LCLB    IF YES, SKIP BEGINNING QUOTE\n.NEXTI04 ANOP  ,\n         AIF   (K'&LCLC GE 254).EXITI04      .TOOBIG\n         AIF   ('&SYSLIST(&J)'(&I,1) EQ '''').DOUBLE\n         AIF   ('&SYSLIST(&J)'(&I,1) EQ '&&').DOUBLE\n&LCLC    SETC  '&LCLC'.'&SYSLIST(&J)'(&I,1)\n         AGO   .ADVI04\n.TOOBIG  MNOTE '&&LCLC TOO LONG -- &&J=&J -- &&I=&I -- &&LCLC=\"&LCLC\"'\n         AGO   .ADVI04\n.DOUBLE  ANOP  ,\n&LCLC    SETC  '&LCLC'.'&SYSLIST(&J)'(&I,1).'&SYSLIST(&J)'(&I,1)\n         AGO   .ADVI04\n.ADVI04  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE K'&SYSLIST(&J)-&LCLB).NEXTI04 SKIP ENDING QUOTE\n.EXITI04 ANOP  ,\n.*\n.*\n.ADVJ04  ANOP  , ADVANCE &J\n&J       SETA  &J+1\n         AIF   (&J LE N'&SYSLIST).NEXTJ04\n.EXITJ04 ANOP  ,\n.*\n         MNOTE '&LCLC'\n         AGO   .SUBEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n         MEND ,                                                       0\n         AGO   .SKIPTEXT\n.DOCPART ANOP  ,\n*\n*\n*        The accompanying programs, developed at Centerior Energy\n*   Corporation, are submitted for unrestricted distribution.  The\n*   programs have met a basic set of programming and documentation\n*   standards, but have not been tested in any formal fashion by\n*   Centerior Energy Corporation.  The user is expected to make the\n*   final evaluation as to the usefulness in their own environment.\n*\n*        Centerior Energy Corporation makes no warranty, expressed or\n*   implied, including, but not limited to, the implied warranties of\n*   merchantability and fitness for a particular purpose as to the\n*   documentation, function, or performance of these programs.\n*\n*        Acceptance and use of these programs constitutes a release\n*   from liability of Centerior Energy Corporation for any problems\n*   use of the programs may cause at the user's installation.\n*\n*        The programs are made available by Centerior Energy\n*   Corporation without charge or consideration.  Recipients are free\n*   to make the programs available to others in like manner.  They\n*   may not be sold.\n*\n*        The assembler macros CECDYN, BREAK, and CONTINUE, and the\n*   example test program DUMPINFO were written by:\n*\n*     Leslie J. Somos\n*     Centerior Energy Corporation\n*     Mail Stop IND-149\n*     6200 Oak Tree Boulevard\n*     Independence, Ohio 44131\n*\n*        The assembler macros DO, OD, IF, ELSE, ELSEIF, FI, THEN,\n*   and EQUBC, were contributed to the SHARE MVS Group Modification\n*   Tape, by:\n*     Donald S. Higgins\n*     Florida Power Corporation\n*     P.O.Box 14042       B-3-B\n*     St. Petersburg, FL 33733\n*\n*\n*        Centerior Energy Corporation does not guarantee to keep any\n*   material provided up to date, nor does it guarantee to provide\n*   any corrections or extensions described by the user or\n*   corrections or extensions made in the future by Centerior Energy\n*   Corporation itself.\n*\n*\n*BACKGROUND\n*    I work in the Technical Services department of Centerior Energy\n*Corporation, an electric utility located in northern Ohio.\n*    The IBM manual describing Dynamic Allocation (SVC 99) has page\n*upon page of text, listing all the text units available.  (For the\n*release of MVS that I work with, the manual is GC28-1150 MVS/Extended\n*Architecture System Programming Library: System Macros and Facilities\n*Volume 1.)\n*    While I was writing a program that made multiple calls to SVC 99,\n*I noticed that I repeated a small segment of code, with slight\n*variations.  I decided to fold the intelligence necessary into a\n*macro, so I would not need to use my (error-prone) memory as much.\n*That macro is CECDYN.\n*IMPLEMENTATION\n*    Because CECDYN uses SETC symbol names longer than 7 characters,\n*it can only be used with IEV90 (the H-level assembler), or higher.\n*    CECDYN has profuse internal comments.  It also has a DEBUG\n*facility, which can be turned on if you suspect it is processing\n*incorrectly.  The debugging is turned on by coding \" CECDYN DEBUG \".\n*Also, any detected internal error turns on debugging.\n*    The information listed in the IBM manual for each text unit key\n*is encoded in an internal table in CECDYN.\n*    CECDYN calls itself multiple times, like an assembler source-\n*level subroutine.  It was coded this way, so that CECDYN is a single\n*unit, and not multiple macros.\n*    Only keyword parameters are used in user calls to CECDYN, no\n*positional parameters.  Positional parameters are only used in\n*recursive inner macro self-calls.\n*    There are 5 internal entry points, and a branch table at label\n*.SUBROUT .  The internal entry points and their functions are:\n*.CMT2   give a value to symbol &CEC#CMT2VAL, displayed in MNOTEs;\n*.CREAT  actually generate lines of code;\n*.DEBUG  either turn on debugging, or display debugging messages;\n*.DOKEY  check a text unit key against internal information;\n*.MNOTE  actually issue all MNOTEs.\n*    The 'internal table' of text units is implemented as a series of\n*calls to the .DOKEY subroutine, within a loop that looks at each\n*sublist entry in the TEXT parameter.  Each call to the .DOKEY\n*subroutine encodes the processing necessary for a particular text unit\n*key, and if it matches the key being processed, also turns on a flag\n*that short-circuits scanning the following calls to the .DOKEY\n*subroutine.\n*\n*EXAMPLES\n*    The IBM manual referred-to above has an example of a dynamic\n*allocation request to allocate SYS1.LINKLIB with a status of SHARE.\n*The corresponding code, using CECDYN, is:\n*DYN   CSECT ,\n*      USING *,15\n*      STM   14,12,12(13)\n*      BALR  12,0\n*BEGIN DS    0H\n*      USING BEGIN,12\n** (All names generated by the CECDYN macro will begin with 'ABC'.)\n*      LA    0,L'ABCDSECT  AMOUNT OF STORAGE REQUIRED FOR THIS REQUEST.\n*      GETMAIN R,LV=(0)    GET THE STORAGE NECESSARY FOR THE REQUEST.\n*      LR    8,1           SAVE THE ADDRESS OF THE RETURNED STORAGE.\n*      CECDYN PREFIX=ABC,        All names generated begin with 'ABC'\n*               MF=(E,(8)),      Build the parameter list here\n*               VERB=AL,   SET THE VERB CODE TO ALLOCATION FUNCTION.\n*               TEXT=((DSNAM,'SYS1.LINKLIB'),     FIRST TEXT UNIT\n*               (STATS,SHR),                      SECOND TEXT UNIT\n*               (RTDDN))                          THIRD TEXT UNIT\n*      DYNALLOC            INVOKE SVC 99 TO PROCESS THE REQUEST.\n*      USING ABCDSECT,8          All the ABC- names are found here\n** The returned DDNAME is found at label ABCRTDDN\n*      LM    14,12,12(13)\n*      BR    14            RETURN TO CALLER.\n*      END\n*\n*\n*\n** (C) COPYRIGHT CENTERIOR ENERGY CORPORATION 1988,1991\n*CECDYN -- macro for building Dynamic Allocation parameter list\n*     This macro builds a parameter list which can be used by SVC 99.\n*     It does not issue a call to SVC 99, it only builds the parameter\n*     list in storage and returns control.\n*     Unlike the IBM-supplied macros, instead of calculating offsets\n*     into the parameter list to store values into it, a dummy control\n*     section and symbolic names are generated and used.  If a USING\n*     is issued on the dummy section, the symbolic names can then be\n*     used to modify the parameter list.  All symbolic names generated\n*     by one call to CECDYN start with the same three characters.  The\n*     three characters can be specified by the caller, or will be\n*     assigned by the macro.\n*     The standard form of the CECDYN macro instruction is written\n*     as follows:\n*\n*     ----------------------------------------------------------------\n*     <name>              <name>: symbol.  Begin <name> in column 1.\n*     b\n*     /                   One or more blanks must precede CECDYN.\n*     CECDYN\n*     b\n*     /                   One or more blanks must follow CECDYN.\n*\n*     ----------------------------------------------------------------\n*     VERB=<verb>         <verb>: two byte character string\n*     ,PREFIX=<prefix>    <prefix>: maximum-of-3 byte character string\n*     ,FLG11=(<flg11>)\n*     ,FLG21=(<flg21>)\n*     ,FLG22=(<flg22>)    <flg11>/<flg21>/<flg22>: one or more 5 byte\n*                         character strings, seperated by commas.  For\n*                         example, FLG##=(<flg##>,<flg##>,<flg##>) .\n*                         If only one <flg##> is specified, the outer\n*                         parentheses may be omitted.\n*     ,TEXT=(<text unit>) <text unit>: either a maximum-of-5 byte\n*                         character string, or a parenthesized pair\n*                         consisting of a maximum-of-5 byte character\n*                         string plus one of: literal delimited by\n*                         quotes, A-type address, register (2)-(12).\n*                         If only one <text unit> is specified, the\n*                         outer parentheses must still be coded.\n*                         Note:  <text unit> is one or more text\n*                         units, seperated by commas.  For example,\n*                         TEXT=(<text unit>,<text unit>,<text unit>)\n*     ,LIST=NO            Default: LIST=YES\n*     ,LIST=YES\n*\n*     ----------------------------------------------------------------\n*     The parameters are explained below:\n*     VERB=<verb>\n*       specifies the SVC 99 function requested.  The two bytes\n*       supplied will be prepended with 'S99VERB' to build a symbol\n*       which specifies a verb code.  The seven verb codes are defined\n*       in the IBM-supplied macro IEFZB4D0, described in \"System\n*       Macros and Facilities\".\n*       No checking is done for validity, but values not defined in\n*       IEBZB4D0 will create undefined symbols.\n*       There is no default for this parameter.\n*     FLG11=<flg11>\n*     FLG21=<flg21>\n*     FLG22=<flg22>\n*       specify certain available options.  Each 5 bytes supplied will\n*       be prepended with 'S99' to build a symbol which specifies an\n*       option, and all the <flg11> will be summed to produce FLG11,\n*       all the <flg21> will be summed to produce FLG21, all the\n*       <flg22> will be summed to produce FLG22.\n*       FLG11 options are available to all SVC 99 callers.\n*       FLG21 & FLG22 options are only available to authorized\n*       callers.\n*       The options available are defined in IBM-supplied macro\n*       IEFZB4D0, described in \"System Macros and Facilities\".\n*       No checking is done for validity, but values not defined in\n*       IEBZB4D0 will create undefined symbols.\n*     Note: No checking is done that a FLG11 option is specified for\n*       FLG21, etc., or vice versa.  It will not cause an assembly\n*       error, but results are unpredictable.\n*     ,PREFIX=<prefix>\n*       optionally supplies up-to-3 characters to be used in building\n*       the symbolic names for fields in the parameter list.  If not\n*       specified, CECDYN will create a 3-character prefix dependent\n*       on the assembler system variable &SYSNDX.  The prefix created\n*       by CECDYN will start with an alphabetic character which will\n*       range through A thru Z, and its next two characters will each\n*       range through 0 thru 9 and A thru Z, the last character\n*       varying most quickly, as &SYSNDX increases.\n*       The dummy section created is named <prefix>DSECT, and it's\n*       length is available as L'<prefix>DSECT .\n*     ,TEXT=(<text unit>)\n*       specifies the text units to be placed in the parameter list.\n*       Each text unit specified will usually be a parenthesized pair\n*       consisting of a maximum-of-5 byte character string plus one\n*       of:  literal delimited by quotes, A-type address, register\n*       (2)-(12).\n*       The character string will be prepended with the character 'D'\n*       plus the VERB specified, to make a symbol which is defined in\n*       the IBM-supplied macro IEFZB4D2, described in \"System Macros\n*       and Facilities\".\n*       No checking is done for validity of the character string, but\n*       values not defined in IEBZB4D2 will create undefined symbols.\n*       Some text units do not require a value, and these will be\n*       specified by only the maximum-of-5 byte character string.  For\n*       these, the inner parentheses may be omitted.\n*       If no text units are specified, only the request block pointer\n*       and the request block are built.  If null text units are\n*       specified, then text unit pointers with a value of zero are\n*       built.\n*       Certain text units may have multiple values specified which\n*       are then summed to build one value (DALOPTCD).  These, and\n*       others, may have their values specified as character strings\n*       which are then translated by CECDYN to be the proper hex\n*       values -- For example, (STATS,OLD) will generate a value of\n*       X'01'.  If you wish, you may code the actual hex value.\n*       Certain other text units may have multiple values which create\n*       multiple fields in the parameter list (DALVLSER,etc.)  CECDYN\n*       will check whether multiple values are specified for a text\n*       unit which does not allow multiple values.\n*     ,LIST=NO\n*     ,LIST=YES\n*       specifies whether or not generated code is to be printed.\n*       If this parameter is not specifed, a default of YES is used.\n*     When control is returned, register 1 points to the parameter\n*     list.  SVC 99 can be issued immediately, or the parameter list\n*     can be modified before issuing SVC 99.\n*     The addresses of text units are stored in the parameter list\n*     starting at the location labelled <prefix>TUPL.  The address of\n*     each text unit is stored in the parameter list in field\n*     <prefix>PTR<#>, where <prefix> is the PREFIX specified or\n*     generated, and <#> ranges from 1 through the number of text\n*     units specified.  Each text unit begins at the field labelled\n*     <prefix>TU<#>.  Each text unit will always have a KEY subfield\n*     <prefix>KEY<#> containing the text unit key, and a NUMBER\n*     subfield <prefix>NUM<#> containing the number of length and\n*     parameter combinations in the text unit.  Some text units will\n*     have only these two subfields, if its NUMBER subfield has a\n*     value of zero.\n*Example 1\n*     Operation: Unallocate the data set associated with ddname\n*     IEFRDER.  CECDYN will assign a 3-byte prefix to the names\n*     generated.\n*     NAME     CECDYN VERB=UN,TEXT=((DDNAM,'IEFRDER'))\n*              DYNALLOC\n*              LTR   15,15          WAS SVC99 SUCCESSFUL ?\n*              ...\n*\n*Example 2\n*     Operation: Request all available information text units, for the\n*     data set currently allocated to the ddname stored in symbol\n*     WRKDD.  Returned information will be in the fields ZZZRTLST,\n*     ZZZRTDDN, etc.\n*     These fields will be accessible by issuing a USING ZZZDSECT,1 .\n*     INFORM   CECDYN  PREFIX=ZZZ,                                     X\n*                    VERB=IN,                                          X\n*                    TEXT=((DDNAM,WRKDD),                              X\n*                    RTLST,RTDDN,RTDSN,RTMEM,RTSTA,                    X\n*                    RTNDP,RTCDP,RTORG,RTLIM,RTATT,RTTYP)\n*              DYNALLOC\n*              LTR   15,15          WAS SVC99 SUCCESSFUL ?\n*              BNZ   ERROR          NO.\n*              USING ZZZDSECT,1     ADDRESSABILITY TO PARAMETER LIST\n*              MVC   LASTIND,ZZZRTLST\n*              MVC   MEMBER,ZZZRTMEM\n*              ...\n*Example 3\n*     Operation: Build a list to be modified later.  In the list,\n*     specify 'do not mount volumes or consider offline devices'.\n*     Reserve space for 5 text unit addresses.  Modify the first three\n*     addresses by using the list form of the CALL macro instruction.\n*     ALLOCIT  CECDYN  PREFIX=Q02,                                     X\n*                    VERB=AL,                                          X\n*                    FLG11=NOMNT,                                      X\n*                    TEXT=(,,,,)\n*              USING Q02DSECT,1\n*              MVC   Q02TUPL(CALLISTX-CALLIST),CALLIST\n*              DYNALLOC\n*              LTR   15,15          WAS SVC99 SUCCESSFUL ?\n*              ...\n*              ...\n*     CALLIST  CALL  ,(THIS,THAT,OTHER),VL,MF=L\n*     CALLISTX EQU   *\n*              ...\n*\n*Example 4\n*        CECDYN PREFIX=ABC,      ALL NAMES GENERATED BEGIN WITH 'ABC'  X\n*              MF=(E,WORKAREA), BUILD THE PARAMETER LIST HERE          X\n*              VERB=AL,   SET THE VERB CODE TO ALLOCATION FUNCTION.    X\n*              TEXT=((DSNAM,'IFASMF.LOCAL.SEC'),  IRST TEXT UNIT       X\n*              (DDNAM,'SYSUT1  '),              SECOND TEXT UNIT       X\n*              (SSNM,'LOGR'),                                          X\n*              (SSPRM,'IFASEXIT'),                                     X\n*              (STATS,SHR))\n*        DYNALLOC            INVOKE SVC 99 TO PROCESS THE REQUEST.\n*        LA    R8,WORKAREA\n*        USING ABCDSECT,8\n*\n*\n*\n*\n*\n*\n*\n*CECDYN (List Form)\n*     The list form of the CECDYN macro instruction is used to\n*     construct a nonexecutable SVC 99 parameter list.  This list form\n*     generates only ADCONs of the text unit parameters.  This\n*     parameter list can be referred to in the execute form of a\n*     CECDYN macro instruction.\n*     The list form of the CECDYN macro instruction is written as\n*     follows:\n*\n*     ----------------------------------------------------------------\n*     <name>              <name>: symbol.  Begin <name> in column 1.\n*     b\n*     /                   One or more blanks must precede CECDYN.\n*     CECDYN\n*     b\n*     /                   One or more blanks must follow CECDYN.\n*\n*     ----------------------------------------------------------------\n*     VERB=<verb>         <verb>: two byte character string\n*     ,PREFIX=<prefix>    <prefix>: maximum-of-3 byte character string\n*     ,FLG11=(<flg11>)\n*     ,FLG21=(<flg21>)\n*     ,FLG22=(<flg22>)    <flg11>/<flg21>/<flg22>: one or more 5 byte\n*                         character strings, seperated by commas.  For\n*                         example, FLG##=(<flg##>,<flg##>,<flg##>) .\n*                         If only one <flg##> is specified, the outer\n*                         parentheses may be omitted.\n*     ,TEXT=(<text unit>) <text unit>: either a maximum-of-5 byte\n*                         character string, or a parenthesized pair\n*                         consisting of a maximum-of-5 byte character\n*                         string plus one of: literal delimited by\n*                         quotes, A-type address, register (2)-(12).\n*                         If only one <text unit> is specified, the\n*                         outer parentheses must still be coded.\n*                         Note: <text unit> is one or more text units,\n*                         seperated by commas.  For example,\n*                         TEXT=(<text unit>,<text unit>,<text unit>)\n*     ,LIST=NO            Default: LIST=YES\n*     ,LIST=YES\n*     ,MF=L\n*\n*     ----------------------------------------------------------------\n*     The parameters are explained under the standard form of the\n*     CECDYN macro instruction, with the following exception:\n*     MF=L\n*       specifies the list form of the CECDYN macro instruction.\n*\n*CECDYN (Execute Form)\n*     A remote SVC 99 parameter list is referred to and can be\n*     modified by the execute form of the CECDYN macro instruction.\n*     Only executable instructions are generated.  The first time a\n*     particular PREFIX is used, a DSECT is defined.  Each execute\n*     form CECDYN macro instruction later in a program which uses the\n*     same PREFIX must have the same VERB as specified on the list\n*     form CECDYN macro instruction, or symbolic names referred-to in\n*     the generated code will not be previously defined.  A\n*     combination of FLG11, FLG21, and FLG22 values can be specified\n*     that is different than that specified on the list form CECDYN\n*     macro instruction.\n*     The TEXT may have fewer entries specified, but should have no\n*     new maximum-of-5 byte character strings which were not on the\n*     list form CECDYN macro instruction.\n*     The execute form of the CECDYN macro instruction is written as\n*     follows:\n*\n*     ----------------------------------------------------------------\n*     <name>              <name>: symbol.  Begin <name> in column 1.\n*     b\n*     /                   One or more blanks must precede CECDYN.\n*     CECDYN\n*     b\n*     /                   One or more blanks must follow CECDYN.\n*\n*     ----------------------------------------------------------------\n*     VERB=<verb>         <verb>: two byte character string\n*     ,PREFIX=<prefix>    <prefix>: maximum-of-3 byte character string\n*     ,FLG11=(<flg11>)\n*     ,FLG21=(<flg21>)\n*     ,FLG22=(<flg22>)    <flg11>/<flg21>/<flg22>: one or more 5 byte\n*                         character strings, seperated by commas.  For\n*                         example, FLG##=(<flg##>,<flg##>,<flg##>) .\n*                         If only one <flg##> is specified, the outer\n*                         parentheses may be omitted.\n*     ,TEXT=(<text unit>) <text unit>: either a maximum-of-5 byte\n*                         character string, or a parenthesized pair\n*                         consisting of a maximum-of-5 byte character\n*                         string plus one of: literal delimited by\n*                         quotes, A-type address, register (2)-(12).\n*                         If only one <text unit> is specified, the\n*                         outer parentheses must still be coded.\n*                         Note: <text unit> is one or more text units,\n*                         seperated by commas.  For example,\n*                         TEXT=(<text unit>,<text unit>,<text unit>)\n*     ,LIST=NO            Default: LIST=YES\n*     ,LIST=YES\n*     ,MF=(E,<remote addr>)\n*                         <remote addr>: RX-type address, or register\n*                         (1) or (2)-(12).\n*\n*     ----------------------------------------------------------------\n*     The parameters are explained under the standard form of the\n*     CECDYN macro instruction, with the following exception:\n*     MF=(E,<remote addr>)\n*       specifies the execute form of the CECDYN macro instruction.\n*       The text units specified are built at the address specified in\n*       the MF parameter.\n*SYS2.CEI.MACLIB(CECDYN)                                   08-MAR-1991\n.SKIPTEXT ANOP ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CECDYNO": {"ttr": 1799, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10&\\x0f\\x01\\x10&\\x0f\\x16A\\tN\\tN\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-09-17T00:00:00", "modifydate": "2010-09-17T16:41:00", "lines": 2382, "newlines": 2382, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,                                                      1\n&NAME    CECDYN &VERB=,&FLG11=,&FLG21=,&FLG22=,&TEXT=,&PREFIX=,&MF=I, 0X\n               &LIST=Y,                                                X\n               &POS1,&POS2,&POS3,&POS4,&POS5,&POS6,&POS7,&POS8,&POS9,  X\n               &POS10\n.* NOTE -- ASA CARRIAGE CONTROL CHARACTERS IN COLUMN 71 >>>>>>>>>>>>>>0\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70\n.*\n.* MACRO NAME = CECDYN\n.*\n.* (C) COPYRIGHT CENTERIOR ENERGY CORPORATION 1988,1991\n.*\n.* FUNCTION = BUILD PARAMETER LIST FOR CALL TO DYNALLOC MACRO (SVC99)\n.*\n.*  THIS MACRO PROCESSES DIFFERENTLY THAN IBM-SUPPLIED MACROS, BECAUSE\n.* IT GENERATES A DSECT FOR ITS PARAMETER LIST, AND ALL MOVES INTO THE\n.* PARAMETER LIST ARE DONE USING THE NAMES DEFINED IN THE DSECT.\n.*\n.* IF &PREFIX IS SPECIFIED, SAVE IT IN GLOBAL &CEC#P (3 CHARS OR LESS)\n.*                          ELSE GENERATE A UNIQUE 3-CHARACTER &CEC#P.\n.* IF MF=E, THEN &PREFIX COULD REPEAT A PREVIOUSLY-SPECIED &PREFIX\n.*          ELSE &PREFIX MUST BE UNIQUE.\n.*\n.* FURTHER PROCESSING IS DONE IN MULTIPLE PASSES:\n.*   IF MF=L, 1 PASS -- CREATE DC.S (DEFINE CONSTANT) FOR ALL OPERANDS\n.*                      WITH SUPPLIED VALUES FOR NON-REGISTER OPERANDS\n.*                      AND WITH VALUES OF 0 FOR REGISTER OPERANDS;\n.*            AND MEXIT.\n.*   IF MF=I, 2 PASSES -- 1ST PASS EXACTLY LIKE MF=L;\n.*                        2ND PASS, MOVE REGISTER OPERANDS TO STORAGE;\n.*            AND MEXIT.\n.*   IF MF=E, 2 PASSES -- 1ST PASS, DEFINE &CEC#P.DSECT, IF VALUE OF\n.*                        &PREFIX WAS NOT ENCOUNTERED BEFORE;\n.*                     -- 2ND PASS, MOVE ALL OPERANDS TO STORAGE,\n.*                        BOTH REGISTER AND NON-REGISTER;\n.*            AND MEXIT.\n.*\n.*  THE VALUES THE USER CAN CODE FOR VERB,FLG11,FLG21,FLG22 ARE THE\n.* NAMES FROM MACRO IEFZB4D0, MINUS THE PREFIX 'S99'.  THE VALUES ARE\n.* NOT CHECKED, BUT INCORRECT VALUES WILL CAUSE ASSEMBLY ERRORS\n.* BECAUSE THEN THE GENERATED NAMES ARE NOT DEFINED BY IEFZB4D0.\n.*  THE ADVANTAGE OF NOT CHECKING IS THAT, IF IBM DEFINES NEW VALID\n.* VALUES IN MACRO IEFZB4D0, NO UPDATE OF THIS MACRO IS NECESSARY TO\n.* RECOGNIZE AND PROCESS THE NEW VALUES.\n.*  AS OF 14-FEB-1991, VALID VALUES DEFINED IN IEFZB4D0 ARE:\n.* VERB COULD BE AL/UN/CC/DC/RI/DN/IN (CHOOSE ONLY ONE).\n.* FLG11 COULD BE ONCNV, NOCNV, NOMNT, JBSYS, CNENQ.\n.* FLG21 COULD BE WTVOL,WTDSN,NORES,WTUNT,OFFLN,TIONQ,CATLG,MOUNT.\n.* FLG22 COULD BE UDEVT, PCINT, DYNDI.\n.* FOR THE FLG.S, SPECIFY MULTIPLE VALUES WITHIN PARENTHESES.\n.*\n.*  TEXT UNITS ARE SPECIFIED IN THE FORM (KEY,<(VALUE0<,VALUE1...>)>).\n.* IF A TEXT UNIT KEY IS SUPPLIED FOR A VERB FOR WHICH IT IS NOT\n.* VALID, IT IS NOT CHECKED BY THIS MACRO, BUT IT CAUSES AN ASSEMBLY\n.* ERROR BECAUSE THEN THE GENERATED KEY NAME IS NOT DEFINED BY\n.* IEFZB4D2.\n.*  EACH KEY NAME IS 'D' FOLLOWED BY THE 2-CHAR VERB NAME, FOLLOWED\n.* BY THE TEXT UNIT NAME.\n.*\n.*                                                                    -\n.* EXAMPLE OF CALLING SEQUENCE:\n.*         CECDYN PREFIX=X01,MF=(E,WORKAREA),                       X\n.*               VERB=AL,FLG11=(ONCNV,NOMNT),                       X\n.*               TEXT=((DDNAM,DSCL8),(SYSOU,'A'),RTORG)\n.* IF ANY TEXT UNITS SHOULD RETURN VALUES, THE VALUES WILL BE FOUND\n.* IN FIELDS LABELLED WITH THE 3 CHARACTERS SPECIFIED BY &PREFIX,\n.* PLUS THE TEXT UNIT'S NAME.  THE ABOVE CALL WILL DEFINE ORDINARY\n.* LABEL X01RTORG.\n.*\n.*   IF &PREFIX IS REPEATED ACROSS CALLS, THE DSECT IS NOT DUPLICATED,\n.* BUT THE EXACT SAME TEXT UNITS MUST BE SPECIFIED AS WERE ON THE\n.* ORIGINAL CALL.  (OR, AT LEAST, NO TEXT UNITS THAT DID NOT APPEAR\n.* IN THE ORIGINAL CALL.  THAT IS, FEWER COULD BE SPECIFIED.)  THE\n.* FLAG FIELDS CAN BE DIFFERENT THAN ON THE ORIGINAL CALL.\n.*\n.* GLOBALS\n         GBLA  &CEC#CMT1COL  DEFAULT COLUMN FOR COMMENT 1 FIELD\n         GBLA  &CEC#CMT2COL  DEFAULT COLUMN FOR COMMENT 2 FIELD\n         GBLA  &CECCMT1COL   CURRENT COLUMN FOR COMMENT 1 FIELD\n         GBLA  &CECCMT2COL   CURRENT COLUMN FOR COMMENT 2 FIELD\n         GBLC  &CEC#CMT2VAL  TEXT AT RIGHT-HAND END OF GENERATED STMTS\n         GBLC  &CEC#DBG#HDR  TEXT AT LEFT-HAND OF DEBUGGING MNOTES\n         GBLB  &CEC#DEBUG    Q. ISSUE MSG.S ABOUT INTERNAL PROCESSING?\n         GBLA  &CEC#FLAG(5)  CONTROLS MULTIPLE PASSES WITHIN .COMMON\n         GBLB  &CEC#KEYDONE  Q. DONE RECOGNIZING TEXT UNIT?\n         GBLB  &CEC#NEWP     Q. WE HAD TO ADD &CEC#P TO &CEC#PTBL?\n         GBLB  &CEC#NOT1ST   Q. HAS CECDYN EVER BEEN CALLED?\n         GBLC  &CEC#P        3-CHAR VALUE USED IN GENERATED CODE\n         GBLA  &CEC#PMAX     MAXIMUM ENTRIES SAVED IN &CEC#PTBL(100)\n         GBLC  &CEC#PTBL(100) SAVES ALL UNIQUE &CEC#P.S EVER SEEN\n         GBLB  &CEC#PUSHED   Q. DO WE NEED TO POP PRINT AT MEXIT?\n         GBLA  &CEC#SYSNDX   HOW MANY TIMES CECDYN HAS BEEN CALLED\n         GBLB  &CEC#XLAT     Q. TABLE CODED IN &POS9 OF .DOKEY CALL?\n         GBLC  &CEC#3CH      UNIQUE, GENERATED INTERNALLY\n.* LOCALS\n         LCLA  &I,&J,&LCLA,&LCLA2,&LCLA3\n         LCLA  &I1,&I10,&IIX\n         LCLC  &KEY,&VALUE\n         LCLB  &LCLB,&LCLB1\n         LCLC  &LBL,&OPR,&OPD,&CMT\n         LCLC  &LCLC,&LCLC2,&LCLC3\n         LCLC  &DUP,&TYP,&LGH,&VAL\n         LCLA  &DV,&LV\n         LCLC  &DX,&LX,&VV\n.*\n&NX      SETC  '&SYSNDX'               DEFINE SHORTER NAME FOR LATER\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n         AIF   (&CEC#NOT1ST).NOT1STA\n         MNOTE '* MACRO CECDYN, LAST CHANGE 14-JAN-1993 11.31'\n.* CHANGE LOG: (NEWEST CHANGE ON TOP)\n.* 14-JAN-1993  L.SOMOS  AFTER .CLEAR, CHECK FOR '*' TO SET HI-BIT.\n.* 14-MAR-1991  L.SOMOS  CORRECT PROCESSING OF REGISTER OPERANDS.\n.NOT1STA ANOP  ,\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.*\n         AIF   (&CEC#NOT1ST).NOT1STB\n.* FOLLOWING PROCESSING DONE ONLY ONCE PER SOURCE MODULE\n.*\n&CEC#CMT1COL SETA 33         COLUMN OF COMMENTS ON GENERATED LINES\n&CEC#CMT2COL SETA 63         COLUMN OF COMMENTS ON GENERATED LINES\n&CEC#DEBUG SETB 0      TURN OFF\n.* TURN ON BY CALLING WITH ONLY 1 POSITIONAL PARAMETER, DEBUG\n.*\n&CEC#NOT1ST SETB 1           ABOVE PROCESSING NEVER REPEATED AGAIN\n.NOT1STB ANOP  ,\n.*\n.* THIS MUST COME AFTER .NOT1STB:\n         AIF   (0 NE N'&SYSLIST).SUBROUT   GO CHECK SUBROUTINE CALLS\n.* ONLY KEYWORD PARMS ARE USED IN EXTERNAL CALLS, NO POSITIONAL PARMS.\n.* POSITIONAL PARMS ARE ONLY USED IN RECURSIVE INNER MACRO SELF-CALLS.\n.*\n&CEC#SYSNDX SETA 1+&CEC#SYSNDX    COUNT NON-SUBROUTINE CALLS TO CECDYN\n.*\n         MNOTE                                      '* MACRO CECDYN IS X\n               (C) COPYRIGHT CENTERIOR ENERGY CORPORATION 1988,1991   '\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.* SET THE VALUE OF &CEC#3CH\n&Q1      SETA  (&CEC#SYSNDX-1)/36      1ST QUOTIENT\n&R1      SETA  (&CEC#SYSNDX-1)-36*&Q1  1ST REMAINDER, FOR 3RD CHAR\n&Q2      SETA  &Q1/36                  2ND QUOTIENT\n&R2      SETA  &Q1-36*&Q2              2ND REMAINDER, FOR 2ND CHAR\n&Q3      SETA  &Q2/26                  3RD QUOTIENT\n&R3      SETA  &Q2-26*&Q3              3RD REMAINDER, FOR 1ST CHAR\n.* R1 AND R2 ARE ALWAYS 0 THROUGH 35   (1+&R? IS ALWAYS 1 THRU 36)\n.* R3 IS ALWAYS 0 THROUGH 25       (10+1+&R3 IS ALWAYS 11 THRU 36)\n&LCLC    SETC  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' LENGTH 36\n&CEC#3CH SETC  '&LCLC'(10+1+&R3,1).'&LCLC'(1+&R2,1).'&LCLC'(1+&R1,1)\n.* &CEC#3CH IS UNIQUE FOR &CEC#SYSNDX LE 26*36*36 = 33696.\n.* &CEC#3CH ALWAYS BEGINS WITH ALPHA, NEXT 2 CHARS ARE ALPHANUMERIC.\n.* R1 CHANGES MOST QUICKLY, R2 NEXT, AND R3 CHANGES SLOWEST.\n.* &CEC#3CH RANGES THROUGH A00,A01...A09,A0A,A0B...A0Z,\n.*                         A10,A11...A19,A1A,...A1Z, A20...A29, ETC.\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.* SET THE VALUE OF &CEC#P\n         AIF   (T'&PREFIX EQ 'O').SETP WE MUST SUPPLY IT\n&CEC#P   SETC  '&PREFIX'\n         AIF   (K'&PREFIX GE 1 AND K'&PREFIX LE 3).PREFIXD ALL DONE\n&CEC#P   SETC  '&PREFIX'(1,3)          ONLY FIRST THREE CHARACTERS\n         CECDYN MNOTE,'ONLY FIRST 3 CHARACTERS OF PREFIX ARE USED, ',  X\n               '\"&CEC#P\" INSTEAD OF \"&PREFIX\"'\n         AGO   .PREFIXD                  ALL DONE\n.SETP    ANOP  , NO VALUE SPECIFIED, SO CREATE ONE.\n&CEC#P   SETC  '&CEC#3CH'\n.PREFIXD ANOP  ,\n.*\n         AIF   ('&CEC#P' EQ '&CEC#3CH').PEQ3CH\n         CECDYN MNOTE,'*        PREFIX=&PREFIX WAS SPECIFIED -- ',     X\n               'ELSE, PREFIX WOULD HAVE BEEN SET TO \"',&CEC#3CH,       X\n               '\", GENERATED FROM CEC#SYSNDX=&CEC#SYSNDX..'\n.PEQ3CH  ANOP  ,\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.* SAVE &CEC#P IN &CEC#PTBL\n&CEC#NEWP SETB 0                       CLEAR FLAG\n&I       SETA  1\n.NEXTI01 ANOP  ,\n         AIF   ('&CEC#PTBL(&I)' EQ '&CEC#P').OLDP YES, WE FOUND IT\n.ADVI01  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE &CEC#PMAX).NEXTI01\n.* OK, IT HAS NEVER BEEN SEEN BEFORE\n&CEC#NEWP SETB 1                       SET FLAG FOR LATER CHECKING\n&CEC#PMAX SETA &CEC#PMAX+1             INCREASE COUNTER\n&CEC#PTBL(&CEC#PMAX) SETC '&CEC#P'     PLACE INTO TABLE\n.OLDP    ANOP  ,\n.* NOTE - THE ABOVE CODE DOES A SUPERFLUOUS COMPARISON WHEN\n.*       &CEC#PMAX==0, BUT THIS DOES NOT AFFECT CORRECT PROCESSING.\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.* CHECK &LIST PARAMETER FOR ERRORS.\n         AIF   ('&LIST' EQ 'YES' OR '&LIST' EQ 'NO').LISTOK\n         AIF   ('&LIST' EQ 'Y' OR '&LIST' EQ 'N').LISTOK\n         MNOTE 12,'LIST=&LIST INVALID, LIST=YES ASSUMED'\n.LISTOK  ANOP  ,\n         AIF   ('&LIST' EQ 'NO').LISTNO\n         AIF   ('&LIST' EQ 'N').LISTNO\n         AGO   .LISTEX\n.LISTNO  ANOP  ,\n         AIF   (&CEC#PUSHED).PUSHED\n         PUSH  PRINT         PUSH PRINT\n&CEC#PUSHED SETB 1\n.PUSHED  ANOP  ,\n         PRINT OFF           LIST=NO WAS REQUESTED\n.LISTEX  ANOP  ,\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.* CHECK &MF PARAMETER FOR ERRORS.\n         AIF   ('&MF' EQ '').MFOK\n         AIF   ('&MF' EQ 'L' OR '&MF' EQ 'I').MFOK\n         AIF   ('&MF(1)' EQ 'E').MFOK\n         MNOTE 12,'MF=&MF INVALID, NORMAL FORM ASSUMED'\n.MFOK    ANOP  ,\n&LCLC    SETC  'CECDYN -- SECOND PARAM REQUIRED FOR MF=E'\n         AIF   (N'&MF LT 2 AND ('&MF(1)' EQ 'E')).ERRMAIN\n&LCLC    SETC  'CECDYN -- TOO MANY PARAMS FOR MF'\n         AIF   (N'&MF GT 2 AND ('&MF(1)' EQ 'E')).ERRMAIN\n         AIF   ('&MF(1)' EQ 'L').TYPEL\n         AIF   ('&MF(1)' EQ 'E').TYPEE\n         AGO   .TYPEI              ASSUME NORMAL FORM\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.ERRMAIN MNOTE '&LCLC'       ISSUE MESSAGE AND EXIT\n         AGO   .MEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.MEXIT   ANOP  ,             USE THIS EXIT FROM MAINLINE\n         AIF   (NOT &CEC#PUSHED).NOPOP1 THEN WE DON'T NEED TO UN-DO IT.\n         POP   PRINT\n&CEC#PUSHED SETB 0\n.NOPOP1  ANOP  ,\n&CEC#DEBUG SETB 0      TURN OFF\n         MEXIT ,\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.*\n.TYPEI   ANOP  , NORMAL FORM\n         CECDYN DEBUG,.TYPEI SAVE HEADING FOR DEBUG MESSAGES\n         CNOP  0,4           ALIGN LIST TO FULLWORD\n         BAS   1,IGX&NX      BRANCH AROUND LIST, POINT REG1 TO LIST\n&CEC#FLAG(1) SETA 1,0,0,0,1  YES DC, NO DS, NO REG, NO MOVES, COMMON1\n         AGO   .COMMON\n.COMMON1 ANOP  ,\nIGX&NX   DS    0H            BRANCHED AROUND LIST\n&CEC#FLAG(1) SETA 0,0,1,0,2  NO DC, NO DS, YES REG, NO MOVES, COMMON2\n         AGO   .COMMON\n.COMMON2 ANOP  ,\n         AGO   .MEXIT\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.TYPEL   ANOP  , LIST FORM\n         CECDYN DEBUG,.TYPEL SAVE HEADING FOR DEBUG MESSAGES\n&CEC#FLAG(1) SETA 1,0,0,0,3  YES DC, NO DS, NO REG, NO MOVES, COMMON3\n         AGO   .COMMON\n.COMMON3 ANOP  ,\n         AGO   .MEXIT\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.TYPEE   ANOP  , EXECUTE FORM\n         CECDYN DEBUG,.TYPEE SAVE HEADING FOR DEBUG MESSAGES\n.*\n.* CREATE A DSECT:\n&CEC#FLAG(1) SETA 0,1,0,0,4  NO DC, YES DS, NO REG, NO MOVES, COMMON4\n         AGO   .COMMON\n.COMMON4 ANOP ,\n.*\n         AIF   ('&MF(2)'(1,1) EQ '('             AND                   X\n               '&MF(2)'(K'&MF(2),1) EQ ')').USEREG\n&NAME    LA    1,&MF(2)                LOAD ADDRESS OF PARAMETER LIST\n         AGO   .REG1SET\n.*\n.USEREG  ANOP  ,                       IF A REGISTER WAS SPECIFIED\n&LCLC    SETC  '&MF(2)'(2,K'&MF(2)-2)  REGISTER NAME (W/O PARENS)\n         AIF   ('&LCLC' EQ '1').GENDS0H\n&NAME    LR    1,&LCLC                 LOAD PARAMETER LIST ADDRESS\n         AGO   .REG1SET\n.*\n.GENDS0H ANOP  ,\n&NAME    DS    0H                      REG 1 CONTAINS LIST ADDRESS\n         AGO   .REG1SET\n.*\n.REG1SET ANOP  ,\n         USING &CEC#P.DSECT,1          REGISTER 1 POINTS TO DSECT\n.*\n&CEC#FLAG(1) SETA 0,0,1,1,5  NO DC, NO DS, YES REG, YES MOVES, COMMON5\n         AGO   .COMMON\n.COMMON5 ANOP  ,\n         DROP  1\n.*\n         AGO   .MEXIT\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.*\n.COMMON  ANOP  , GENERATE STRUCTURE OF PARAMETER LIST\n.* THIS IS AN AGO-TYPE INTERNAL ROUTINE --\n.* IT EXITS WITH THE STATEMENT:            AGO .COMMON&CEC#FLAG(5)\n         CECDYN DEBUG,'START .COMMON, RETURN INDEX=&CEC#FLAG(5); ',    X\n               'FLAGS=&CEC#FLAG(1),&CEC#FLAG(2),',                     X\n               '&CEC#FLAG(3),&CEC#FLAG(4).'\n.* .COMMON IS CALLED WITH FLAGS 1,0,0,0 -- JUST &CEC#FLAG(1),\n.*                           OR 0,1,0,0 -- JUST &CEC#FLAG(2),\n.*                           OR 0,0,1,0 -- JUST &CEC#FLAG(3),\n.*                           OR 0,0,1,1 -- WITH &CEC#FLAG(3) AND (4).\n.* IF &CEC#FLAG(1), MAKE DC.S FOR ALL OP.S, WITH ZEROS FOR REG. OP.S\n.* IF &CEC#FLAG(2), MAKE DS.S FOR ALL OP.S, WITH ZEROS FOR ALL OP.S\n.* IF &CEC#FLAG(3), THEN MOVE ONLY OPERANDS WHICH CANNOT BE GENERATED\n.*               IN DC.S (REGISTER OPERANDS, AND SYMBOLIC OPERANDS\n.*               FOR CONSTANTS OF TYPES WHICH REQUIRE QUOTES.)\n.* IF &CEC#FLAG(4), THEN MOVE OTHER OPERANDS (LITERALS, ACONS, NULLS)\n.*\n.*                                                                    -\n         AIF   (NOT &CEC#FLAG(1) AND NOT &CEC#FLAG(2)).NOEQU1\n         AIF   (NOT &CEC#NEWP).COMEXIT SKIP -- ASSUME ALREADY DONE.\n         CECDYN DEBUG,'NEWP=1, GENERATE DSECT'\n         SPACE 2\n&LCLC    SETC '&CEC#P.ORG'\n         AIF   (&CEC#FLAG(1)).ORGDC\n         AIF   (&CEC#FLAG(2)).ORGDSCT\n         MNOTE 16,'SEVERE INTERNAL ERROR'\n         MNOTE 'CEC#FLAG(1)=&CEC#FLAG(1) CEC#FLAG(2)=&CEC#FLAG(2)'\n&CEC#DEBUG SETB 1      TURN ON\n         AGO   .MEXIT\n.ORGDC   ANOP  ,\n&LCLC2   SETC  'DC'\n&LCLC3   SETC  '0F''0'''\n         AGO   .EQU1\n.ORGDSCT ANOP  ,\n&LCLC2   SETC  'DSECT'\n&LCLC3   SETC  ''\n.EQU1    ANOP  ,\n&LCLC    &LCLC2 &LCLC3\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n*                SVC 99 INPUT REQUEST BLOCK\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.NOEQU1  ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* BUILD &LCL#FLG11, &LCLFLG21, &LCLFLG22 BY SUMMING BIT MASKS:\n.*..+....1....+....2                                                  0\n.*\n&LCL#FLG11 SETC '0'\n         AIF   (K'&FLG11 EQ 0).FLG11ZZ\n&I       SETA  1\n&LCL#FLG11 SETC 'S99&FLG11(&I)'\n         AIF   (N'&FLG11 LE &I).FLG11XX\n.FLG11QQ ANOP  ,\n&I       SETA  &I+1\n&LCL#FLG11 SETC '&LCL#FLG11.+S99&FLG11(&I)'\n         AIF   (N'&FLG11 GT &I).FLG11QQ\n.FLG11XX ANOP  ,\n.FLG11ZZ ANOP  ,\n.*..+....1....+....2                                                  0\n.*\n&LCL#FLG21 SETC '0'\n         AIF   (K'&FLG21 EQ 0).FLG21ZZ\n&I       SETA  1\n&LCL#FLG21 SETC 'S99&FLG21(&I)'\n         AIF   (N'&FLG21 LE &I).FLG21XX\n.FLG21QQ ANOP  ,\n&I       SETA  &I+1\n&LCL#FLG21 SETC '&LCL#FLG21.+'.'S99&FLG21(&I)'\n         AIF   (N'&FLG21 GT &I).FLG21QQ\n.FLG21XX ANOP  ,\n.FLG21ZZ ANOP  ,\n.*..+....1....+....2                                                  0\n.*\n&LCL#FLG22 SETC '0'\n         AIF   (K'&FLG22 EQ 0).FLG22ZZ\n&I       SETA  1\n&LCL#FLG22 SETC 'S99&FLG22(&I)'\n         AIF   (N'&FLG22 LE &I).FLG22XX\n.FLG22QQ ANOP  ,\n&I       SETA  &I+1\n&LCL#FLG22 SETC '&LCL#FLG22.+'.'S99&FLG22(&I)'\n         AIF   (N'&FLG22 GT &I).FLG22QQ\n.FLG22XX ANOP  ,\n.FLG22ZZ ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* (SEE .CREAT SUBROUTINE FOR MEANING OF PARAMETERS)\n.*\n&CECCMT1COL SETA &CEC#CMT1COL COMMENT 1 FIELD'S COLUMN\n&CECCMT2COL SETA &CEC#CMT2COL COMMENT 2 FIELD'S COLUMN\n.* (EACH CALL TO .CREAT DOES ABOVE SETA.S, JUST BEFORE EXITING)\n.*\n&CEC#P.RBP   CECDYN CREAT,0,F\n&CEC#P.RBPTR CECDYN CREAT,,A,*,A(&CEC#P.RB),'REQUEST BLOCK POINTER'\n.*                 (*=HIGH BIT ON)\n&CEC#P.RB    CECDYN CREAT,0,F,,,'REQUEST BLOCK'\n&CEC#P.RBLN  CECDYN CREAT,,A,1,&CEC#P.RBEND-&CEC#P.RB,                 X\n               'LENGTH OF REQUEST BLOCK'\n&CEC#P.VERB  CECDYN CREAT,,A,1,S99VRB&VERB,'VERB CODE'\n&CEC#P.FLAG1 CECDYN CREAT,0,C,2,,FLAGS\n&CEC#P.FLG11 CECDYN CREAT,,A,1,&LCL#FLG11,'FIRST FLAGS BYTE'\n&CEC#P.FLG12 CECDYN CREAT,,A,1,0,'SECOND BYTE OF FLAGS'\n&CEC#P.RSC   CECDYN CREAT,0,C,4,,'REASON CODE FIELDS'\n&CEC#P.ERROR CECDYN CREAT,,X,2,0,'ERROR REASON CODE'\n&CEC#P.INFO  CECDYN CREAT,,X,2,0,'INFORMATION REASON CODE'\n&CEC#P.TXTPP CECDYN CREAT,,A,,A(&CEC#P.TUPL),                          X\n               'ADDR OF LIST OF TEXT UNIT PTRS'\n&CEC#P.RSV01 CECDYN CREAT,,F,,0,RESERVED\n&CEC#P.FLAG2 CECDYN CREAT,0,C,4,,'FLAGS FOR AUTHORIZED FUNCTIONS'\n&CEC#P.FLG21 CECDYN CREAT,,A,1,&LCL#FLG21,'FIRST BYTE OF FLAGS'\n&CEC#P.FLG22 CECDYN CREAT,,A,1,&LCL#FLG22,'SECOND BYTE OF FLAGS'\n&CEC#P.FLG23 CECDYN CREAT,,A,1,0,'THIRD BYTE OF FLAGS'\n&CEC#P.FLG24 CECDYN CREAT,,A,1,0,'FOURTH BYTE OF FLAGS'\n&CEC#P.RBEND CECDYN CREAT,0,,0,,'END MARKER'\n.*                                                                    1\n         AIF   (NOT &CEC#FLAG(1) AND NOT &CEC#FLAG(2)).NOEQU2\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n* SVC 99 TEXT UNIT POINTER LIST\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.NOEQU2  ANOP  ,\n.*\n&CEC#P.TUPL  CECDYN CREAT,0,F,,,'TEXT UNIT POINTER LIST'\n&I       SETA   1\n.NEXTPTR ANOP  ,\n&I1      SETA  &I-10*(&I/10)           1'S DIGIT OF &I\n&I10     SETA  (&I/10)-10*(&I/100)     10'S DIGIT OF &I\n&IIX     SETA  1+3*(&I1*(&I10-1)/(&I10-1)) IGNORE &I1 IF (&I10-1) EQ 0\n&ITH     SETC  'TH ST ND RD TH TH TH TH TH TH '(&IIX,2) 0TH, 1ST, ETC.\n&HIBIT   SETC  '*'                     SET FLAG TO SET HIGH BIT\n         AIF   (&I EQ N'&TEXT).LASTPTR\n&HIBIT   SETC  ''                      RESET FLAG TO SET HIGH BIT\n.LASTPTR ANOP  ,\n&LCLC3   SETC  'A(&CEC#P.TU&I)'\n&LCLC4   SETC  '&TEXT(&I,1)'\n         AIF   (T'&TEXT(&I,1) NE 'O').NORMAL1 NOT- SKIPPED UNIT\n&LCLC3   SETC  '0'\n&LCLC4   SETC  '(OMITTED)'\n.NORMAL1 ANOP  ,\n.* ACTUAL CODE GENERATION:                                            -\n&CEC#P.PTR&I CECDYN CREAT,,A,&HIBIT,                                   X\n               &LCLC3,                                                 X\n               '&I&ITH TEXT UNIT POINTER, &LCLC4'\n.***************************\n.* THE EFFECT OF THE ABOVE CODE IS:\n.* &CEC#P.PTR&I CECDYN CREAT,,A,&HIBIT,                                X\n               A(&CEC#P.&TEXT(&I,1).-(S99TUPAR-S99TUNIT)),             X\n               '&I&ITH TEXT UNIT POINTER, &TEXT(&I,1)'\n.***************************\n.ADVPTR  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE N'&TEXT).NEXTPTR\n.*\n.*                                                                    1\n         AIF   (NOT &CEC#FLAG(1) AND NOT &CEC#FLAG(2)).NOEQU3\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n* SVC 99 TEXT UNITS\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.NOEQU3  ANOP  ,\n.*\n.*   BEGIN A HUGE LOOP, AROUND ALL SELF-CALLS TO .DOKEY SUBROUTINE.\n.* THIS LOOP USES &I AS AN INDEX TO STEP THROUGH ALL SUBLIST ENTRIES\n.* SPECIFIED IN THE TEXT= PARAMETER IN THE OUTER CALL TO CECDYN.\n.*\n&I       SETA   1\n.NEXTI09 ANOP  ,\n.*\n&I1      SETA  &I-10*(&I/10)           1'S DIGIT OF &I\n&I10     SETA  (&I/10)-10*(&I/100)     10'S DIGIT OF &I\n&IIX     SETA  1+3*(&I1*(&I10-1)/(&I10-1)) IGNORE &I1 IF (&I10-1) EQ 0\n&ITH     SETC  'TH ST ND RD TH TH TH TH TH TH '(&IIX,2) 0TH, 1ST, ETC.\n&KEY     SETC  'D&VERB.&TEXT(&I,1)'\n.*\n         AIF   (T'&TEXT(&I,1) EQ 'O').ADVI09  SKIPPED UNIT\n.*\n         AIF   (T'&TEXT(&I,1) NE 'O').NORMAL2 NOT- SKIPPED UNIT\n&KEY     SETC  '(OMITTED)'\n.NORMAL2 ANOP  ,\n.*\n         CECDYN CMT2,        SET &CEC#CMT2VAL (TO BLANKS)\n.*\n&CECCMT1COL SETA &CEC#CMT1COL-6 SHIFT CHARS LEFT, SO 'BEGIN' STANDS OUT\n&CEC#P.TU&I  CECDYN CREAT,0,F,,,'BEGIN &I&ITH TEXT UNIT, &KEY'\n.*\n         AIF   (T'&TEXT(&I,1) EQ 'O').ADVI09  SKIPPED UNIT\n.*\n&CEC#P.KEY&I CECDYN CREAT,,A,2,&KEY,'&I&ITH KEY'\n.*\n&CEC#KEYDONE SETB 0          PREPARE TO SEARCH\n.*\n.*  INFORMATION BELOW IS FROM MVS/XA SPL: SYSTEM MACROS AND FACILITIES\n.* GC28-1150-2.\n.*\n.* (SEE .DOKEY SUBROUTINE FOR MEANING OF PARAMETERS)\n.* DSNAME ALLOCATION TEXT UNITS                                       -\n         AIF   ('&VERB' NE 'AL').AL#DONE\n.*\n.* DDNAME\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDDNAM,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* DSNAME (MUTUALLY EXCLUSIVE WITH DALQNAME, DALIPLTX)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDSNAM,1,C,(1,44)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* PDS MEMBER (REQUIRES DALDSNAM ALSO)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMEMBR,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* DATA SET STATUS (MUTUALLY EXCLUSIVE WITH DALSYSOU)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSTATS,1,A,1,              X\n               ((OLD,X'01'),(MOD,X'02'),(NEW,X'04'),(SHR,X'08'),       X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* NORMAL DISPOSITION (MUTUALLY EXCLUSIVE WITH DALSYSOU)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALNDISP,1,A,1,              X\n               ((UNCATLG,X'01'),(CATLG,X'02'),                         X\n               (DELETE,X'04'),(KEEP,X'08'),                            X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* CONDITIONAL DISPOSITION (MUTUALLY EXCLUSIVE WITH DALSYSOU)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCDISP,1,A,1,              X\n               ((UNCATLG,X'01'),(CATLG,X'02'),                         X\n               (DELETE,X'04'),(KEEP,X'08'),                            X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* UNIT OF DALPRIME, DALSECND WILL BE TRACKS\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALTRK,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.* UNIT OF DALPRIME, DALSECND WILL BE CYLINDERS\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCYL,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.* AVERAGE BLOCK LENGTH TO USE FOR UNIT OF DALPRIME, DALSECND\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBLKLN,1,A,3,,'<=65535'\n         AIF   (&CEC#KEYDONE).ADVI09\n.* PRIMARY SPACE QUANTITY\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPRIME,1,A,3\n         AIF   (&CEC#KEYDONE).ADVI09\n.* SECONDARY SPACE QUANTITY\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSECND,1,A,3\n         AIF   (&CEC#KEYDONE).ADVI09\n.* NUMBER OF DIRECTORY BLOCKS FOR A PDS\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDIR,1,A,3\n         AIF   (&CEC#KEYDONE).ADVI09\n.* RELEASE UNUSED SPACE AT CLOSE TIME\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRLSE,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.* FORMAT OF ALLOCATED SPACE\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSPFRM,1,A,1,              X\n               ((ALX,X'02'),  USE DIFFERENT AREAS OF CONTIGUOUS SPACE  X\n               (MXIG,X'04'),      MAXIMUM CONTIGUOUS SPACE IS REQUIRED X\n               (CONTIG,X'08'),    SPACE MUST BE CONTIGUOUS             X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* ALLOCATE IN WHOLE CYLINDERS\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALROUND,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.* VOLUME SERIAL NUMBERS (MUTUALLY EXCLUSIVE WITH DALSYSOU, DALVLRDS)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALVLSER,(1,6),C,6\n         AIF   (&CEC#KEYDONE).ADVI09\n.* ASSIGN USE ATTRIBUTE OF PRIVATE (MUTUALLY EXCLUSIVE WITH DALSYSOU)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPRIVT,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.* VOL-SEQ WITHIN MULTI-VOLUME DATA SET (MUT.EXCL.W/DALSYSOU)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALVLSEQ,1,A,2,,'<=255'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALVLCT,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALVLRDS,1,C,(1,44)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUNIT,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUNCNT,1,A,1,,'<=59'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPARAL,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSYSOU,(0,1),C,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSPGNM,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSFMNO,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALOUTLM,1,A,3\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCLOSE,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCOPYS,1,1,A\n         AIF   (&CEC#KEYDONE).ADVI09\n.* LABEL TYPE OF VOLUME\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALLABEL,1,A,1,              X\n               ((NL,X'01'),  NO LABEL                                  X\n               (SL,X'02'),   IBM STANDARD LABELS                       X\n               (NSL,X'04'),  NON-STANDARD LABELS                       X\n               (SUL,X'0A'),  IBM STANDARD LABEL PLUS USER LABEL        X\n               (BLP,X'10'),  BYPASS LABEL PROCESSING                   X\n               (LTM,X'21'),  CHECK FOR AND BYPASS LEADING TAPE MARK    X\n               (AL,X'40'),   AMERICAN NATIONAL STANDARD LABEL          X\n               (AUL,X'48'),  AL PLUS USER LABEL                        X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDSSEQ,1,A,2,,'<=9999'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPASPR,1,A,1,              X\n               ((PASSWORD,X'10'),(NOPWREAD,X'30'),                     X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALINOUT,1,A,1,              X\n               ((OUT,X'40'),(IN,X'80'),                                X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALEXPDT,1,C,5\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRETPD,1,A,2,,'<=9999'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDUMMY,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFCBIM,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFCBAV,1,A,1,              X\n               ((VERIFY,X'04'),(ALIGN,X'08'),                          X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALQNAME,1,C,(1,17)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALTERM,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUCS,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUFOLD,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUVRFY,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDCBDS,1,C,(1,44)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDCBDD,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSUSER,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSHOLD,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMSVGP,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSSNM,(0,1),C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSSPRM,(1,254),C,(0,67)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPROT,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUSRID,1,A,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBURST,1,A,1,              X\n               ((Y,X'02'),(N,X'04'),(YES,X'02'),(NO,X'04'),            X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCHARS,(1,4),C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCOPYG,(1,8),A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFFORM,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFCNT,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMMOD,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMTRC,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDEFER,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALOUTPT,(1,128),C,(1,26)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* DCB ATTRIBUTE TEXT UNITS                                           -\n.*\n.* BUFFER ALIGNMENT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBFALN,1,A,1,              X\n               ((F,X'01'),   FULLWORD, NOT DOUBLEWORD                  X\n               (D,X'02'),    DOUBLEWORD                                X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* BUFFERING TECHNIQUE\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBFTEK,1,A,1,              X\n               ((D,X'08'),   DYNAMIC                                   X\n               (E,X'10'),    EXCHANGE                                  X\n               (R,X'20'),    RECORD                                    X\n               (S,X'40'),    SIMPLE                                    X\n               (A,X'60'),    RECORD AREA                               X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBLKSZ,1,A,2,,'<=32760'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFIN,1,A,1,,'<=15'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFL,1,A,2,,'<=32760'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFMX,1,A,1,,'<=15'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFNO,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n.* BUFFER OFFSET\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFOF,1,A,1,              X\n               ((L,X'80'),   BLOCK PREFIX IS 4 BYTES, CONTAINS LENGTH  X\n               *),           USER CODES VALUE OF BLOCK PREFIX          X\n               '<=99'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFOU,1,A,1,,'<=15'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFRQ,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFSZ,1,A,2\n         AIF   (&CEC#KEYDONE).ADVI09\n.* PAPER TAPE CODE:\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCODE,1,A,1,               X\n               ((T,X'02'),   TELETYPE 5-TRACK                          X\n               (A,X'04'),    USASCII 8-TRACK                           X\n               (C,X'08'),    NATIONAL CASH REGISTER 8-TRACK            X\n               (B,X'10'),    BURROUGHS 7-TRACK                         X\n               (F,X'20'),    FRIDEN 8-TRACK                            X\n               (I,X'40'),    IBM BCD 8-TRACK                           X\n               (N,X'80'),    NO CONVERSION                             X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* SEND/RECEIVE PRIORITY\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCPRI,1,A,1,               X\n               ((S,X'01'),   SEND PRIORITY                             X\n               (E,X'02'),    EQUAL PRIORITY                            X\n               (R,X'04'),    RECEIVING PRIORITY                        X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* MAGNETIC TAPE DENSITY:\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDEN,1,A,1,                X\n               ((0,X'03'),   200 BPI 7-TRACK                           X\n               (1,X'43'),    556 BPI 7-TRACK                           X\n               (2,X'83'),    800 BPI 7-TRACK OR 9-TRACK                X\n               (3,X'C3'),    1600 BPI 9-TRACK                          X\n               (4,X'D3'),    6250 BPI 9-TRACK                          X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* DATA SET ORGANIZATION\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDSORG,1,A,2,              X\n               ((TCAM3705,X'0004'), TCAM 3705                          X\n               (VSAM,X'0008'), VSAM                                    X\n               (TQ,X'0020'), TCAM MESSAGE QUEUE                        X\n               (TX,X'0040'), TCAM LINE GROUP                           X\n               (GS,X'0080'), GRAPHICS                                  X\n               (PO,X'0200'), PARTITIONED ORGANIZATION                  X\n               (POU,X'0300'), PARTITIONED ORGANIZATION UNMOVABLE       X\n               (MQ,X'0400'), TELECOMMUNICATIONS MESSAGE PROCESSING Q.  X\n               (CQ,X'0800'), DIRECT ACCESS MESSAGE QUEUE               X\n               (CX,X'1000'), COMMUNICATION LINE GROUP                  X\n               (DA,X'2000'), DIRECT ACCESS                             X\n               (DAU,X'2100'), DIRECT ACCESS UNMOVABLE                  X\n               (PS,X'4000'), PHYSICAL SEQUENTIAL                       X\n               (PSU,X'4100'), PHYSICAL SEQUENTIAL UNMOVABLE            X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* ERROR PROCESSING OPTION\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALEROPT,1,A,1,              X\n               ((T,X'10'),   BSAM TESTING                              X\n               (ABE,X'20'),  CAUSE ABNORMAL END OF TASK                X\n               (SKP,X'40'),  SKIP BLOCK CAUSING ERROR                  X\n               (ACC,X'80'),  ACCEPT BLOCK CAUSING ERROR                X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALGNCP,1,A,1,,'<=99'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALINTVL,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALKYLEN,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALLIMCT,1,A,3,,'<=32760'\n         AIF   (&CEC#KEYDONE).ADVI09\n.* ACTUAL OR MAXIMUM LENGTH OF A LOGICAL RECORD, IN BYTES\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALLRECL,1,A,2,              X\n               ((X,X'8000'), LRECL EXCEEDS 32756 (QSAM, BSAM SPANNED)  X\n               *),           (USER MAY CODE VALUE DIRECTLY)            X\n               '<=32760'\n         AIF   (&CEC#KEYDONE).ADVI09\n.* MODE OF OPERATION FOR CARD READER OR PUNCH\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMODE,1,A,1,               X\n               ((E,X'40'),   EBCDIC MODE                               X\n               (ER,X'50'),   EBCDIC, READ COLUMN ELIMINATE MODE        X\n               (EO,X'60'),   EBCDIC, OPTICAL MARK READ MODE            X\n               (C,X'80'),    CARD IMAGE MODE                           X\n               (CR,X'90'),   CARD IMAGE, READ COLUMN ELIMINATE MODE    X\n               (CO,X'A0'),   CARD IMAGE, OPTICAL MARK READ MODE        X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALNCP,1,A,1,,'<=99'\n         AIF   (&CEC#KEYDONE).ADVI09\n.* OPTIONAL SERVICES TO BE PERFORMED\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALOPTCD,1,A,1,              X\n               (+, TRANSLATE + SUM                                     X\n               (R,X'01'), RELATIVE BLOCK ADDRESSING                    X\n               (J,X'01'), SELECT CHARACTER ARRANGEMENT TABLES(3800)    X\n               (T,X'02'), USER TOTALING FACILITY                       X\n               (Z,X'04'), REDUCED TAPE ERR RECOVERY/DIRECT DASD SEARCH X\n               (A,X'08'), DIRECT ADDRESSING                            X\n               (Q,X'08'), TRANSLATE ASCII TO/FROM EBCDIC               X\n               (F,X'10'), FEEDBACK                                     X\n               (H,X'10'), HOPPER-EMPTY EXIT                            X\n               (O,X'10'), ONLINE CORRECTION (OPTICAL READERS)          X\n               (C,X'20'), CHAINED SCHEDULING/TCAM SEGMENT IDENTIFICA'N X\n               (E,X'20'), EXTENDED SEARCH                              X\n               (B,X'40'), DISREGARD EOF RECOGNITION (TAPE)             X\n               (U,X'40'), ALLOW DATA CHECKS CAUSED BY INVALID CHARS    X\n               (W,X'80')) WRITE VALIDITY CHECK/PLACE TCAM MESSAGE IN   X\n                                   AN EIGHT-BYTE FIELD IN THE WORKAREA\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPCIR,1,A,1,               X\n               ((R,X'02'),(N,X'08'),(A,X'20'),(X,X'80'),               X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPCIS,1,A,1,               X\n               ((R,X'01'),(N,X'04'),(A,X'10'),(X,X'40'),               X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPRTSP,1,A,1,              X\n               ((0,X'01'),(1,X'09'),(2,X'11'),(3,X'19'),               X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRECFM,1,A,1,              X\n               (+, TRANSLATE + SUM                                     X\n               (M,X'02'),(R,X'02'),(A,X'04'),(G,X'04'),(S,X'08'),      X\n               (B,X'10'),(D,X'20'),(T,X'20'),(V,X'40'),(F,X'80'),      X\n               (U,X'C0'),                                              X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRSRVF,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRSRVS,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSOWA,1,A,2,,'<=32760'\n         AIF   (&CEC#KEYDONE).ADVI09\n.* STACKER SELECTION\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSTACK,1,A,1,              X\n               ((1,1),(2,2))            ONLY  1  OR  2  IS VALID       X\n                        NO '*' IN &POS9 -- ALL OTHERS HAVE '*' CODED   X\n                        AS LAST ENTRY IN &POS9.\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALTHRSH,1,A,1,,'<=100'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALTRTCH,1,A,1,              X\n               ((C,X'13'),(E,X'23'),(ET,X'2B'),(T,X'3B'),              X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALIPLTX,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDIAGN,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFUNC,1,A,1,               X\n               ((W,X'10'),(WT,X'12'),(WX,X'14'),(WXT,X'16'),           X\n               (P,X'20'),(PW,X'30'),(PWX,X'34'),(PWXT,X'36'),          X\n               (R,X'40'),(RW,X'50'),(RWT,X'52'),(RWX,X'54'),           X\n               (RWXT,X'56'),(RP,X'60'),(RPD,X'68'),(RPW,X'70'),        X\n               (RPWX,X'74'),(RPWXT,X'76'),(RPWD,X'78'),(I,X'80'),      X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFRID,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* NON-JCL DYNAMIC ALLOCATION FUNCTIONS                               -\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPASSW,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPERMA,0\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCNVRT,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRTDDN,1,C,8,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRTDSN,1,C,44,*\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRTORG,1,X,2,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSSREQ,(0,1),C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRTVOL,1,C,6,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSSATT,1,X,1,              X\n               ((*,X'80'))                          CONSTANT X'80'\n         AIF   (&CEC#KEYDONE).ADVI09\n.AL#DONE ANOP  ,\n.* DYNAMIC UNALLOCATION TEXT UNITS                                    -\n         AIF   ('&VERB' NE 'UN').UN#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNDDNAM,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNDSNAM,1,C,(1,44)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNMEMBR,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVDSP,1,A,1,              X\n               ((UNCATLG,X'01'),(CATLG,X'02'),                         X\n               (DELETE,X'04'),(KEEP,X'08'),                            X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNUNALC,0\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNREMOV,0\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVSNH,0\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVCLS,1,C,1\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVSUS,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVSHQ,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.UN#DONE ANOP  ,\n.* DYNAMIC CONCATENATION TEXT UNITS                                   -\n         AIF   ('&VERB' NE 'CC').CC#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DCCDDNAM,(2,16),C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DCCPERMC,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.CC#DONE ANOP  ,\n.* DYNAMIC DECONCATENATION TEXT UNIT                                  -\n         AIF   ('&VERB' NE 'DC').DC#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DDCDDNAM,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n.DC#DONE ANOP  ,\n.* TEXT UNITS FOR REMOVING THE IN-USE ATTRIBUTE BASED ON TASK-ID      -\n         AIF   ('&VERB' NE 'RI').RI#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DRITCBAD,1,A,4\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DRICURNT,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.RI#DONE ANOP  ,\n.* DDNAME ALLOCATION TEXT UNITS                                       -\n         AIF   ('&VERB' NE 'DN').DN#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DDNDDNAM,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DDNRTDUM,1,X,1,*\n         AIF   (&CEC#KEYDONE).ADVI09\n.DN#DONE ANOP  ,\n.* DYNAMIC INFORMATION RETRIEVAL TEXT UNITS                           -\n         AIF   ('&VERB' NE 'IN').IN#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINDDNAM,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINDSNAM,1,C,(1,44)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTDDN,1,C,8,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTDSN,1,C,44,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTMEM,1,C,8,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTSTA,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTNDP,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTCDP,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTORG,1,X,2,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTLIM,1,X,2,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTATT,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTLST,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTTYP,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRELNO,1,X,2,*\n         AIF   (&CEC#KEYDONE).ADVI09\n.IN#DONE ANOP  ,\n.*                                                                    -\n.* TO GET HERE, 1 OF 3:   1. USER KEYED INVALID TEXT KEY NAME\n.*                        2. ERROR IN THIS MACRO\n.*                        3. IBM DEFINED A KEY NOT KNOWN TO THIS MACRO\n&LCLC    SETC  'TEXT UNIT KEY ''''&KEY'''' NOT KNOWN TO THIS MACRO--'\n&LCLC    SETC  '&LCLC.TEXT UNIT KEY SPELLED WRONG, OR ERROR IN CECDYN'\n         MNOTE 12,'&LCLC'\n.*\n.* BOTTOM OF HUGE LOOP\n.ADVI09  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE N'&TEXT).NEXTI09\n.*                                                                    1\n         AIF   (NOT &CEC#FLAG(1) AND NOT &CEC#FLAG(2)).NOEQU4\n         SPACE 1\n         DS    0D                  FILL OUT DATA SECTION\n         SPACE 1\n&LCLC    SETC  '&CEC#P.&CEC#3CH'\n&LCLC.A  EQU   *-&CEC#P.ORG        CALCULATE THE HEX LENGTH\n         ORG   &CEC#P.ORG\n&LCLC2   SETC  '&CEC#P.DSECT'\n&LCLC2   DS    CL(&LCLC.A)         NOW L'&CEC#P.DSECT AVAILABLE\n         SPACE 1\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n         AIF   (NOT &CEC#FLAG(2)).NOEQU4\n         SPACE 1\n&SYSECT. CSECT , RETURN TO CODE\n         AIF   ('&SYSLOC' EQ '&SYSECT').NOEQU4  SKIP IF UNNECESSARY\n&SYSLOC. LOCTR , RETURN TO ORIGINAL LOCATION COUNTER\n.NOEQU4  ANOP  ,\n.*\n.COMEXIT ANOP  ,\n.*\n.* ACTUAL CODE GENERATION:                                            -\n&LCLA    SETA  &CEC#FLAG(5)  FETCH RETURN INDEX\n         AGO   (&LCLA).COMMON1,.COMMON2,.COMMON3,.COMMON4,.COMMON5\n.***************************\n.* THE EFFECT OF THE ABOVE CODE IS:\n.*       AGO   .COMMON&CEC#FLAG(5)\n.***************************\n         MNOTE 16,'SEVERE INTERNAL ERROR'\n         MNOTE 'CEC#FLAG(5)=&CEC#FLAG(5)'\n&CEC#DEBUG SETB 1      TURN ON\n         AGO   .MEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.SUBROUT ANOP  ,                                                      0\n.*\n         AIF   ('&POS1' EQ 'CMT2').CMT2\n         AIF   ('&POS1' EQ 'CREAT').CREAT\n         AIF   ('&POS1' EQ 'DEBUG').DEBUG\n         AIF   ('&POS1' EQ 'DOKEY').DOKEY\n         AIF   ('&POS1' EQ 'MNOTE').MNOTE\n&LCLC    SETC  'CECDYN -- INVALID INTERNAL CALL, \"&POS1\"'\n         AGO   .ERRMAIN\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7-\n.SUBEXIT MEXIT ,             USE THIS EXIT FROM SUBROUTINES           0\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7-\n.CMT2    ANOP  , SELF-CALL INTERNAL ROUTINE -- SET &CEC#CMT2VAL       0\n&CEC#CMT2VAL SETC '&POS2'\n         AGO   .SUBEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7-\n.CREAT   ANOP  , SELF-CALL INTERNAL ROUTINE -- CREATE LINE(S) OF CODE 0\n         CECDYN DEBUG,.CREAT SAVE HEADING FOR DEBUG MESSAGES\n         CECDYN DEBUG,'&NAME CECDYN CREAT,&POS2,&POS3,&POS4,&POS5,\"',  X\n               &POS6,'\"'\n.* IF &CEC#FLAG(1), GENERATE \"DEFINE CONSTANT\" FOR ALL OPERANDS,\n.*        WITH VALUES SPECIFIED BY USER,\n.*        AND VALUES OF 0 FOR OPERANDS SPECIFIED THROUGH REGISTERS\n.* IF &CEC#FLAG(2), GENERATE \"DEFINE STORAGE\" FOR ALL OPERANDS,\n.*        WITH VALUES OF 0 FOR ALL OPERANDS\n.* IF &CEC#FLAG(3), THEN MOVE ONLY OPERANDS WHICH CANNOT BE GENERATED\n.*        IN DEFINE CONSTANTS (REGISTER OPERANDS, AND SYMBOLIC\n.*        OPERANDS FOR CONSTANTS OF TYPES WHICH REQUIRE QUOTES)\n.* IF &CEC#FLAG(4), THEN MOVE OTHER OPERANDS (LITERALS, ACONS, NULLS)\n.*\n.* FORMAT OF .CREAT SELF-CALLS IS:\n.*       CECDYN CREAT,<DUP>,<TYP>,<LGH>,<VAL>,<COMMENT>\n.* ( DUPLICATION FACTOR, FIELD TYPE, LENGTH, NOMINAL VALUE, TEXT )\n.* OPTIONAL <DUP> IS SELF-DEFINING DECIMAL TERM (WHEN NULL, ASSUME 1)\n.*                        (WHEN 0, THEN INTERNALLY FORCE &CEC#FLAG(1)\n.*                        TO ACT LIKE &CEC#FLAG(2)\n.* OPTIONAL <TYP> IS A SINGLE CHARACTER (ASSEMBLER TYPE ATTRIBUTE T' )\n.*                        H=HALFWORD, F=FULLWORD, A=ADDRESS CONSTANT,\n.*                        B=BINARY, C=CHARACTER, X=HEX, <NULL>='EQU *'\n.* OPTIONAL <LGH>IS SELF-DEFINING DECIMAL TERM\n.*                        (WHEN NULL, ASSUME 2 FOR HALFWORD,\n.*                        4 FOR FULLWORD OR ADDRESS CONSTANT, ELSE 0)\n.*          <VAL> VALUE IS ONLY USED WHEN &CEC#FLAG(1)  (THAT IS,\n.*                        WHEN GENERATING \"DEFINE CONSTANT\"S).\n.*                        IT IS REQUIRED WHEN <DUP> NOT 0\n.* OPTIONAL <COMMENT> IS TEXT OF COMMENT TO BE GENERATED\n.*\n.*..+....1....+....2....+....3\n.*\n&DUP     SETC '&POS2'\n&TYP     SETC '&POS3'\n&LGH     SETC '&POS4'\n&VAL     SETC '&POS5'\n&CMT     SETC '&POS6'\n.*\n.* &DUP AND &LGH ARE THE PARAMETERS SPECIFIED ON THE .CREAT SELF-CALL\n.* &DV AND &LV ARE LCLA (NUMERIC) VALUES USED IN INTERNAL PROCESSING\n.* &DX AND &LX ARE LCLC (CHARACTER) VALUES USED IN GENERATING CODE\n.*\n.* &NUL,&LIT,&REG,&ACN ARE LCLB (FLAGS) DESCRIBE THE &VAL SPECIFIED\n.* &VV IS THE NOMINAL VALUE (WITHOUT QUOTES, PARENS, A(, ) )\n.*..+....1....+....2....+....3                                        0\n.*\n.* ANALYSE DUPLICATION FACTOR:\n.* &DUP=''        PRODUCES &DV=1,         &DX=''\n.* &DUP=0         PRODUCES &DV=0,         &DX='0'\n.* &DUP=1         PRODUCES &DV=1,         &DX=''\n.* &DUP=<NUMERIC> PRODUCES &DV=<NUMERIC>, &DX='<NUMERIC>'.\n&DV      SETA  1             SET INITIAL DEFAULTS\n&DX      SETC  ''            SET INITIAL DEFAULTS\n         AIF   (K'&DUP EQ 0).XDUP\n&DV      SETA  &DUP          MUST BE SELF-DEFINING DECIMAL TERM\n         AIF   ('&DUP' EQ '1').XDUP   LEAVE &DX AS ''\n&DX      SETC  '&DUP'\n.XDUP    ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* ANALYSE LENGTH:\n.* &LGH=''        PRODUCES &LV=DEFAULT,   &LX=''\n.*                            (DEFAULT DEPENDS ON DATA TYPE)\n.*                        (WHEN NULL, ASSUME 2 FOR HALFWORD,\n.*                        4 FOR FULLWORD OR ADDRESS CONSTANT, ELSE 0)\n.* &LGH=<NUMERIC> PRODUCES &LV=<NUMERIC>, &LX='L<NUMERIC>'\n&HIBIT   SETB  0\n&LX      SETC  ''            SET INITIAL DEFAULTS\n&LCLC    SETC  'HFA'\n&LCLC2   SETC  '2440'  EXTRA CHARACTER GIVES DEFAULT '0' FOR NON-H,F,A\n.* H,2; F,4; A,4; OTHER,0.\n&I       SETA  1\n.NEXTI08 ANOP  ,\n         AIF   ('&LCLC'(&I,1) EQ '&TYP').EXITI08\n.ADVI08  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE K'&LCLC).NEXTI08\n.EXITI08 ANOP  ,\n&LCLC    SETC  '&LCLC2'(&I,1)          FETCH CHARACTER FROM 2ND ARRAY\n&LV      SETA  &LCLC                      AND CHANGE TO NUMERIC\n         AIF   (K'&LGH EQ 0).NOLGH             USE DEFAULT LENGTH\n&HIBIT   SETB  ('&LGH'(K'&LGH,1) EQ '*')  SET BY '*', OR '4*', ETC.\n         AIF   (K'&LGH EQ 1 AND &HIBIT).NOLGH  USE DEFAULT LENGTH\n&LCLC    SETC  '&LGH'(1,K'&LGH-&HIBIT) TRIM POSSIBLE '*' (K'&LGH GE 2)\n&LV      SETA  &LCLC         MUST BE SELF-DEFINING DECIMAL TERM\n&LX      SETC  'L&LV'\n.NOLGH   ANOP  ,\n         AIF   (&LV NE 0).XLGH\n&LV      SETA  K'&VAL\n         AIF   (&LV EQ 0).XLGH\n&LX      SETC  'L&LV'\n.XLGH    ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* ANALYSE NOMINAL VALUE:\n.* &VAL=''        PRODUCES &NUL=1, &VV=DEFAULT\n.*                                    (DEFAULT DEPENDS ON DATA TYPE)\n.* &VAL='...'     PRODUCES &LIT=1, &VV=...   (WITHOUT QUOTES)\n.* &VAL=(...)     PRODUCES &REG=1, &VV=...   (WITHOUT PARENS)\n.* &VAL=A(...)    PRODUCES &ACN=1, &VV=...   (WITHOUT A(, ) )\n.* &VAL=<OTHER>   PRODUCES &NUL=&LIT=&REG=&ACN=0, &SYMBOL=1,\n.*                                 &VV=&VAL\n&LIT     SETB  0             LITERAL\n&REG     SETB  0             REGISTER\n&ACN     SETB  0             ADDRESS CONSTANT\n&NUL     SETB  1             NULL -- OMITTED\n&LCLC    SETC  'C'\n&LCLC2   SETC  ' 0'     EXTRA CHARACTER GIVES DEFAULT '0' FOR NON-C\n.* C,' '; OTHER,0.\n&I       SETA  1\n.NEXTI05 ANOP  ,\n         AIF   ('&LCLC'(&I,1) EQ '&TYP').EXITI05\n.ADVI05  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE K'&LCLC).NEXTI05\n.EXITI05 ANOP  ,\n&VV      SETC  '&LCLC2'(&I,1)          FETCH CHARACTER FROM 2ND ARRAY\n&DFLTVV  SETC  '&VV'                   SAVE FOR LATER, ' ' OR '0'\n         AIF   (K'&VAL EQ 0).ZVAL                .* IF NULL SKIP\n         AIF   ('&VAL' EQ '').ZVAL               .* IF NULL SKIP\n&NUL     SETB  0                               .* RESET NULL IF NOT\n         AIF   (K'&VAL LT 3).XVAL      TOO SHORT TO BE ANYTHING\n&VV      SETC  '&VAL'(2,K'&VAL-2)      REMOVE QUOTES/PARENS\n&LIT     SETB  ('&VAL'(1,1) EQ '''' AND '&VAL'(K'&VAL,1) EQ '''')\n         AIF   (&LIT).ZVAL\n&REG     SETB  ('&VAL'(1,1) EQ '(' AND '&VAL'(K'&VAL,1) EQ ')')\n         AIF   (&REG).ZVAL\n         AIF   (K'&VAL LT 4).XVAL      TOO SHORT TO BE ACN\n&ACN     SETB  ('&VAL'(1,2) EQ 'A(' AND '&VAL'(K'&VAL,1) EQ ')')\n&VV      SETC  '&VAL'(3,K'&VAL-3)      REMOVE A(, )\n         AIF   (&ACN).ZVAL\n.XVAL    ANOP  ,\n&VV      SETC  '&VAL'\n.ZVAL    ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n&SYMBOL  SETB  (NOT &NUL AND NOT &LIT AND NOT &REG AND NOT &ACN)\n.*                     (SOMETHING, BUT NONE OF THE ABOVE)\n&MUSTMOV SETB  0             PREP IT TO 0\n         AIF   (&REG).MM1    IF &REG, CANNOT BE DC.-D\n         AIF   (&NUL).MMXX              NULL VALUE CAN ALWAYS BE DC.-D\n         AIF   (&LIT AND ('&TYP' EQ 'C')).MMXX   LITERALS CAN BE DC.-D\n         AIF   (NOT &LIT AND ('&TYP' EQ 'C')).MM1   OTHERS CANNOT\n         AIF   ('&TYP' EQ 'A').MMXX       WITHOUT QUOTES, CAN BE DC.-D\n         AGO   .MMXX\n.MM1     ANOP  ,\n&MUSTMOV SETB  1             CHANGE IT TO 1\n.MMXX    ANOP  ,\n.*    &MUSTMOV IS A FLAG THAT SAYS SOME CODE IS NEEDED FOR A FIELD,\n.*  THAT IT CANNOT BE JUST ASSEMBLED INTO A DC. (AS IN MF=L)\n         CECDYN DEBUG,'VAL=\"',&VV.,                                    X\n               '\", NUL=&NUL., LIT=&LIT., REG=&REG., ACN=&ACN.',        X\n               ', SYMBOL=&SYMBOL., MUSTMOV=&MUSTMOV..'\n.*..+....1....+....2....+....3                                        0\n.*\n.* PROCESS COMMENT FIELD:\n         AIF   (K'&CMT EQ 0).NOQUOT1\n         AIF   ('&CMT'(1,1) NE '''').NOQUOT1\n         AIF   ('&CMT'(K'&CMT,1) NE '''').NOQUOT1\n&CMT     SETC  '&CMT'(2,K'&CMT-2)     REMOVE QUOTES\n.NOQUOT1 ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n         AIF   (NOT &CEC#DEBUG).XDEBUG3\n         CECDYN DEBUG,'NAME=&NAME DUP=&DUP TYP=&TYP LGH=&LGH VAL=\"',   X\n               &VV,'\"'\n         CECDYN MNOTE,'        POS6=&CMT, POS7=&POS7..'\n         CECDYN MNOTE,'        DV=&DV DX=\"&DX\"  LV=&LV LX=\"&LX\"'\n         CECDYN MNOTE,'   VAL: NUL=&NUL, LIT=&LIT, REG=&REG, ACN=&ACN'\n&LCLA    SETA  N'&LGH\n         CECDYN MNOTE,'        N''LGH=&LCLA, HIBIT=&HIBIT'\n.XDEBUG3 ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n&GENRETI SETA  1        DEFAULT RETURN FROM .GENCOM:  .CR#EXIT\n.*\n         AIF   (&CEC#FLAG(1)).G#DCDS   GENERATE DC/DS\n         AIF   (&CEC#FLAG(2)).G#DCDS   GENERATE DC/DS\n         AIF   (&DV EQ 0).CR#EXIT      DUPLICATION FACTOR ZERO--EXIT!\n         AIF   (&CEC#FLAG(3)).G#MOVE   GENERATE MOVES\n         AIF   (&CEC#FLAG(4)).G#MOVE   GENERATE MOVES\n&LCLC    SETC  'INTERNAL ERROR IN .CREAT SUBROUTINE, SYSNDX=&SYSNDX '\n&LCLC    SETC  '&LCLC'.'FLAGS=&CEC#FLAG(1),&CEC#FLAG(2),'\n&LCLC    SETC  '&LCLC'.'&CEC#FLAG(3),&CEC#FLAG(4)..'\n         MNOTE 16,'&LCLC'\n&CEC#DEBUG SETB 1      TURN ON\n         MHELP 1+2+4+8+16+32+64\n         AGO   .CR#EXIT\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.G#DCDS  ANOP  ,             GENERATE DC OR DS\n&LBL     SETC  '&NAME'\n         AIF   (&LV EQ 0 AND &DV EQ 0 AND '&TYP' EQ '').G#EQU INSTEAD\n.*..+....1\n         AIF   (NOT &MUSTMOV).LEAVEVV\n&VV      SETC  '&DFLTVV'               SAVED DEFAULT\n         CECDYN DEBUG,'VAL=\"',&VV.,                                    X\n               '\", NUL=&NUL., LIT=&LIT., REG=&REG., ACN=&ACN.',        X\n               ', SYMBOL=&SYMBOL., MUSTMOV=&MUSTMOV., VV=&VV..'\n.LEAVEVV ANOP  , DON'T SET BACK TO DEFAULT\n.*..+....1\n         AIF   (&CEC#FLAG(1) AND &DV EQ 0).FLAG2A GENERATE DS, NOT DC\n         AIF   (&CEC#FLAG(1)).FLAG1A\n         AIF   (&CEC#FLAG(2)).FLAG2A\n.*..+....1\n.FLAG1A  ANOP  ,\n&OPR     SETC  'DC'\n&OPD     SETC  '&DX&TYP&LX'.'(&VV)'    A(<VALUE>)\n         AIF   ('&TYP' EQ 'A').FLAG1B\n&OPD     SETC  '&DX&TYP&LX'.'''&VV'''  C'<VALUE>' OR F'<VALUE>' OR X..\n         AGO   .FLAG1X                 DONE SETTING UP\n.FLAG1B  ANOP  ,\n         AIF   (NOT &HIBIT).FLAG1X     NOTHING SPECIAL TO DO\n         AIF   (&ACN).FLAG1C           OK, SKIP ERROR MESSAGE\n         MNOTE 12,'INTERNAL ERROR, HIBIT ONLY VALID FOR ADCON.S'\n&CEC#DEBUG SETB 1      TURN ON\n.FLAG1C  ANOP  ,\n&OPD     SETC  '&DX&TYP&LX'.'(&VV+X''80000000'')'  SET HIGH BIT ON\n.FLAG1X  AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1\n.FLAG2A  ANOP  ,\n&OPR     SETC  'DS'\n&OPD     SETC  '&DX&TYP&LX'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1\n.G#EQU   ANOP  ,\n&OPR     SETC  'EQU'\n&OPD     SETC  '*'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.G#MOVE  CECDYN DEBUG,.G#MOVE         GENERATE MOVES\n&LBL     SETC  ''\n&LCLC    SETC  'SYMBOL=&SYMBOL., MUSTMOV=&MUSTMOV.'\n&LCLC    SETC  '&LCLC., FLAG(3)=&CEC#FLAG(3)., FLAG(4)=&CEC#FLAG(4).'\n         CECDYN DEBUG,'&LCLC'\n&LCLB    SETB                (     &MUSTMOV   AND (NOT &CEC#FLAG(3) ))\n&LCLC    SETC        '&LCLB.=(     &MUSTMOV.  AND (NOT &CEC#FLAG(3)))'\n         CECDYN DEBUG,'&LCLC.=(     MUSTMOV   AND (NOT  FLAG(3) ))'\n&LCLB1   SETB                ((NOT &MUSTMOV ) AND (NOT &CEC#FLAG(4) ))\n&LCLC    SETC       '&LCLB1.=((NOT &MUSTMOV.) AND (NOT &CEC#FLAG(4)))'\n         CECDYN DEBUG,'&LCLC.=((NOT MUSTMOV ) AND (NOT  FLAG(4) ))'\n         CECDYN DEBUG,'    IF EITHER OF ABOVE IS TRUE, THEN MEXIT'\n         AIF   (&LCLB OR &LCLB1).CR#EXIT                 NOTHING TO DO\n         AIF   ('&DUP' EQ '0' AND K'&CMT EQ 0).CR#EXIT   NOTHING TO DO\n         AIF   ('&DUP' EQ '0').ONLYCMT  NO CODE TO BE GENERATED\n         AIF   (&NUL AND                                               X\n               '&TYP' EQ 'C').BLANK  TO-FIELD IS CHARACTER             X\n                                        AND NO NOMINAL VALUE SPECIFIED\n         AIF   (&NUL AND                                               X\n               '&TYP' EQ 'F').ZERO   TO-FIELD IS A FULLWORD            X\n                                        AND NO NOMINAL VALUE SPECIFIED\n         AIF   (&NUL).CLEAR          NO NOMINAL VALUE SPECIFIED\n         AIF   ('&VV' EQ '0').CLEAR  VALUE TO GENERATE IS 0\n         AIF   ('&TYP' EQ 'C').AAACH TO-FIELD IS A CHARACTER FIELD\n         AIF   ('&LV' EQ '1' AND                                       X\n               ('&TYP' EQ 'A' OR '&TYP' EQ 'X' OR '&TYP' EQ 'F' OR     X\n               '&TYP' EQ 'H')).AAA1N TO-FIELD IS LENGTH 1, NUMERIC\n         AIF   ('&LV' EQ '2' AND                                       X\n               ('&TYP' EQ 'A' OR '&TYP' EQ 'X' OR '&TYP' EQ 'F' OR     X\n               '&TYP' EQ 'H')).AAA2N TO-FIELD IS LENGTH 2, NUMERIC\n         AIF   ('&LV' EQ '3' AND                                       X\n               ('&TYP' EQ 'A' OR '&TYP' EQ 'X' OR '&TYP' EQ 'F' OR     X\n               '&TYP' EQ 'H')).AAA3N TO-FIELD IS LENGTH 3, NUMERIC\n         AIF   ('&LV' EQ '4' AND                                       X\n               ('&TYP' EQ 'A' OR '&TYP' EQ 'X' OR '&TYP' EQ 'F' OR     X\n               '&TYP' EQ 'H')).AAA4N TO-FIELD IS LENGTH 4, NUMERIC\n         MNOTE 12,'INTERNAL ERROR IN CREAT ROUTINE:'\n MNOTE '            NAME=&NAME DUP=&DUP TYP=&TYP LGH=&LGH VAL=\"&VV\"'\n MNOTE '            POS6=&CMT..'\n MNOTE '            DV=&DV DX=\"&DX\"  LV=&LV LX=\"&LX\"'\n MNOTE '       VAL: NUL=&NUL, LIT=&LIT, REG=&REG, ACN=&ACN'\n&CEC#DEBUG SETB 1      TURN ON\n         AGO   .CR#EXIT\n.*..+....1....+....2                                                  0\n.*\n.* (EACH 'AGO .GENCOM\" WITH NO RETURN IS FOLLOWED BY DOUBLE-SPACE)\n.*..+....1....+....2                                                  0\n.ONLYCMT CECDYN CMT2,.ONLYCMT    DUPLICATION FACTOR ZERO--ONLY COMMENT0\n&LBL     SETC  '*'\n&OPR     SETC  ''\n&OPD     SETC  '&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.BLANK   CECDYN CMT2,.BLANK     NO NOMINAL VALUE FOR 'C'--BLANK-FILL  0\n         AIF   (&LV LE 0 OR &LV GT 8).BLANK1   CONTINUE THINKING\n.BLANK8  CECDYN CMT2,.BLANK8    USER SPECIFIED &LGH LE 8--USE LITERAL\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME'.'(&LV),=CL8'' '''\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.BLANK1  CECDYN CMT2,.BLANK1    MOVE A SINGLE BLANK                   0\n&OPR     SETC  'MVI'\n&OPD     SETC  '&NAME,C'' '''\n         AIF   (&LV EQ 1).GENCOM GO GENERATE A LINE, THEN .CR#EXIT\n&GENRETI SETA  3             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET3\n.GENRET3 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&CMT     SETC  'PROPOGATE INITIAL BLANK'\n         AIF   (&LV EQ 0).BLANK0\n.BLANKX  CECDYN CMT2,.BLANKX USER SPECIFIED &LGH--USE IT              0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME+1(&LV-1),&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.BLANK0  CECDYN CMT2,.BLANK0 NO &LGH--HOPE ASMBLR CAN FIGURE IT OUT   0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME+1(L''&NAME-1),&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.ZERO    CECDYN CMT2,.ZERO      NO NOMINAL VALUE FOR 'F'--LOAD ZEROES 0\n         AIF   (&LV GE 4).CLEAR LGH GREATER THAN TYPE F--USE XC\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,=F''0'''\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.CLEAR   CECDYN CMT2,.CLEAR     NO NOMINAL VALUE--CLEAR TO HEX ZEROES 0\n&OPR     SETC  'MVI'\n&OPD     SETC  '&NAME,0'\n         AIF   (&LV EQ 1).GENCOM GO GENERATE A LINE, THEN .CR#EXIT\n         AIF   (&LV EQ 0).CLEAR0\n&OPR     SETC  'XC'\n&OPD     SETC  '&NAME'.'(&LV),&NAME'\n&GENRETI SETA  2 PREPARE RETURN POINTER--CHECK FOR HIBIT AFTERWARD\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2\n.CLEAR0  CECDYN CMT2,.CLEAR0 NO &LGH--HOPE ASMBLR CAN FIGURE IT OUT   0\n&OPR     SETC  'XC'\n&OPD     SETC  '&NAME,&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.AAACH   CECDYN CMT2,.AAACH , TO-FIELD IS A CHARACTER FIELD           0\n         AIF   (&REG).REGCH   TO-FIELD IS CHAR, SOURCE IS REG-FORMAT\n         AIF   (&ACN).ACNCH   TO-FIELD IS CHAR, SOURCE IS ACON-FORMAT\n         AIF   (&LIT).LITCH   TO-FIELD IS CHAR, SOURCE IS LITERAL\n.SYMCH   ANOP  ,              TO-FIELD IS CHAR, SOURCE IS A SYMBOL    0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,&VV' OR '&NAME,&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.LITCH   CECDYN CMT2,.LITCH   TO-FIELD IS CHAR, SOURCE IS LITERAL     0\n         AIF   (&LV EQ 1).LIT1CH TO-FIELD IS 1-CHAR, SOURCE IS LITERAL\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,=C&LX''&VV''' OR '&NAME,=C&LX&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.LIT1CH  CECDYN CMT2,.LIT1CH  TO-FIELD IS 1-CHAR, SOURCE IS LITERAL   0\n&OPR     SETC  'MVI'\n&OPD     SETC  '&NAME,''&VV''' OR '&NAME,&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.REGCH   CECDYN CMT2,.REGCH   TO-FIELD IS CHAR, SOURCE IS REG-FORMAT  0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,0(&VV)' OR '&NAME,0&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.ACNCH   CECDYN CMT2,.ACNCH   TO-FIELD IS CHAR, SOURCE IS ACON-FORMAT 0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'LA'\n&OPD     SETC  '15,&VV'\n&CMT     SETC  'LOAD ADDRESS OF FIELD'\n&GENRETI SETA  4             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET4\n.GENRET4 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,0(15)'\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.AAA1N   CECDYN CMT2,.AAA1N , TO-FIELD IS LENGTH 1, NUMERIC           0\n         AIF   (&REG).REG1N TO-FIELD LGH 1 NUMERIC, SOURCE REG-FORMAT\n         AIF   (&ACN).ACN1N TO-FIELD LGH 1 NUMERIC, SOURCE ACON-FORMAT\n         AIF   (&LIT).LIT1N TO-FIELD LGH 1 NUMERIC, SOURCE A LITERAL\n.SYM1N   ANOP  ,            TO-FIELD LGH 1 NUMERIC, SOURCE A SYMBOL   0\n&OPR     SETC  'MVI'\n&OPD     SETC  '&NAME,&VV' OR '&NAME,&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.LIT1N   CECDYN CMT2,.LIT1N TO-FIELD LGH 1 NUMERIC, SOURCE A LITERAL  0\n&OPR     SETC  'MVI'\n&OPD     SETC  '&NAME,C''&VV''' OR '&NAME,C&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.REG1N   CECDYN CMT2,.REG1N TO-FIELD LGH 1 NUMERIC, SOURCE REG-FORMAT 0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'L'\n&OPD     SETC  '15,0(&VV)' OR '15,0&VAL'\n&CMT     SETC  'FETCH FULLWORD POINTED-TO BY REGISTER'\n&GENRETI SETA  7             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET7\n.GENRET7 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'STC'\n&OPD     SETC  '15,&NAME'\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.ACN1N   CECDYN CMT2,.ACN1N TO-FIELD LGH 1 NUMERIC, SOURCE ACON-FORMAT0\n         LA    15,&VV        LOAD ADDRESS OF FIELD            .ACN1N\n&OPR     SETC  'STC'\n&OPD     SETC  '15,&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.AAA2N   CECDYN CMT2,.AAA2N , TO-FIELD IS LENGTH 2, NUMERIC           0\n         AIF   (&REG).REG2N TO-FIELD LGH 2 NUMERIC, SOURCE REG-FORMAT\n         AIF   (&ACN).ACN2N TO-FIELD LGH 2 NUMERIC, SOURCE ACON-FORMAT\n         AIF   (&LIT).LIT2N TO-FIELD LGH 2 NUMERIC, SOURCE A LITERAL\n.SYM2N   ANOP  ,            TO-FIELD LGH 2 NUMERIC, SOURCE A SYMBOL   0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,=AL2(&VV)' OR '&NAME,=AL2(&VAL)'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.LIT2N   CECDYN CMT2,.LIT2N TO-FIELD LGH 2 NUMERIC, SOURCE A LITERAL  0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,=AL2(C''&VV'')' OR '&NAME,=AL2(C&VAL)'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.REG2N   CECDYN CMT2,.REG2N TO-FIELD LGH 2 NUMERIC, SOURCE REG-FORMAT 0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'L'\n&OPD     SETC  '15,0(&VV)' OR '15,0&VAL'\n&CMT     SETC  'FETCH FULLWORD POINTED-TO BY REGISTER'\n&GENRETI SETA  6             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET6\n.GENRET6 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'STH'\n&OPD     SETC  '15,&NAME'    STORE HALFWORD FROM REG.\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.ACN2N   CECDYN CMT2,.ACN2N TO-FIELD LGH 2 NUMERIC, SOURCE ACON-FORMAT0\n         LA    15,&VV        LOAD ADDRESS OF FIELD            .ACN2N\n&OPR     SETC  'STH'\n&OPD     SETC  '15,&NAME'    STORE HALFWORD FROM REG.\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.AAA3N   CECDYN CMT2,.AAA3N , TO-FIELD IS LENGTH 3, NUMERIC           0\n         AIF   (&REG).REG3N TO-FIELD LGH 3 NUMERIC, SOURCE REG-FORMAT\n         AIF   (&ACN).ACN3N TO-FIELD LGH 3 NUMERIC, SOURCE ACON-FORMAT\n         AIF   (&LIT).LIT3N TO-FIELD LGH 3 NUMERIC, SOURCE A LITERAL\n.SYM3N   ANOP  ,            TO-FIELD LGH 3 NUMERIC, SOURCE A SYMBOL   0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'L'\n&OPD     SETC  '15,&VV'\n&CMT     SETC  'FETCH FULLWORD'\n&GENRETI SETA  9             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET9\n.GENRET9 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'STCM'\n&OPD     SETC  '15,B''0111'',&NAME'\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.LIT3N   CECDYN CMT2,.LIT3N TO-FIELD LGH 3 NUMERIC, SOURCE A LITERAL  0\n         LA    15,=C'&VV'    POINT TO FULLWORD                .LIT3N\n&OPR     SETC  'STCM'\n&OPD     SETC  '15,B''0111'',&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.REG3N   CECDYN CMT2,.REG3N TO-FIELD LGH 3 NUMERIC, SOURCE REG-FORMAT 0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'L'\n&OPD     SETC  '15,0(&VV)' OR '15,0&VAL'\n&CMT     SETC  'FETCH FULLWORD POINTED-TO BY REGISTER'\n&GENRETI SETA  8             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET8\n.GENRET8 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'STCM'\n&OPD     SETC  '15,B''0111'',&NAME'\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.ACN3N   CECDYN CMT2,.ACN3N TO-FIELD LGH 3 NUMERIC, SOURCE ACON-FORMAT0\n         LA    15,&VV        LOAD ADDRESS OF FIELD            .ACN3N\n&OPR     SETC  'STCM'\n&OPD     SETC  '15,B''0111'',&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.AAA4N   CECDYN CMT2,.AAA4N , TO-FIELD IS LENGTH 4, NUMERIC           0\n&GENRETI SETA  2 PREPARE RETURN POINTER--CHECK FOR HIBIT AFTERWARD\n         AIF   (&REG).REG4N TO-FIELD LGH 4 NUMERIC, SOURCE REG-FORMAT\n         AIF   (&ACN).ACN4N TO-FIELD LGH 4 NUMERIC, SOURCE ACON-FORMAT\n         AIF   (&LIT).LIT4N TO-FIELD LGH 4 NUMERIC, SOURCE A LITERAL\n.SYM4N   ANOP  ,            TO-FIELD LGH 4 NUMERIC, SOURCE A SYMBOL   0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME'.'(4),&VV' OR '&NAME'.'(4),&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2\n.LIT4N   CECDYN CMT2,.LIT4N TO-FIELD LGH 4 NUMERIC, SOURCE A LITERAL  0\n         LA    15,=C'&VV'       FETCH WORD                    .LIT4N\n&OPR     SETC  'ST'\n&OPD     SETC  '15,&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2\n.REG4N   CECDYN CMT2,.REG4N TO-FIELD LGH 4 NUMERIC, SOURCE REG-FORMAT 0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,0(&VV)' OR '&NAME,0&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2\n.ACN4N   CECDYN CMT2,.ACN4N TO-FIELD LGH 4 NUMERIC, SOURCE ACON-FORMAT0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'LA'\n&OPD     SETC  '15,&VV'\n&CMT     SETC  'LOAD ADDRESS OF FIELD'\n&GENRETI SETA  5             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET5\n.GENRET5 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'ST'\n&OPD     SETC  '15,&NAME'\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n&GENRETI SETA  2 PREPARE RETURN POINTER--CHECK FOR HIBIT AFTERWARD\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2\n.*\n.GENRET2 AIF   (NOT &HIBIT).CR#EXIT    NOTHING SPECIAL TO DO          0\n         OI    &NAME,X'80'      TURN ON HIGH BIT              .GENRET2\n         AGO   .CR#EXIT\n.*..+....1....+....2....+....3....+....4                              1\n.GENCOM  ANOP , GENERATE A STMT, W/ COMMENT FIELD AND W/ &CEC#CMT2VAL 0\n.* THIS IS AN AGO-TYPE INTERNAL ROUTINE --\n.* IT EXITS WITH THE STATEMENT:            AGO .GENRET&GENRETI\n.*\n.* INPUTS: LOCAL SETC VARIABLES: &LBL          LABEL\n.*                               &OPR          OPERATOR\n.*                               &OPD          OPERAND\n.*                               &CMT          COMMENT\n.*         GLOBAL SETC VARIABLE: &CEC#CMT2VAL  SECONDARY COMMENT\n.* OUTPUT: STATEMENT/MNOTE: &LBL     &OPR  &OPD&CMT&CEC#CMT2VAL\n.*         WITH COLUMNS:   '....+....1....+..  .   .\n.*         (&LBL IN COLUMN 1,\n.*          &OPR IN COLUMN 10 IF POSSIBLE, ELSE SHIFTED,\n.*          &OPD IN COLUMN 16 IF POSSIBLE, ELSE SHIFTED,\n.*          &CMT IN COLUMN &CECCMT1COL (ON A CONT'N IF NECESSARY),\n.*  &CEC#CMT2VAL IN COLUMN &CECCMT2COL (ON A CONT'N IF NECESSARY).)\n.*..+....1....+....2....+....3                                        0\n.*\n.* TRIM ALL BLANKS FROM RIGHT-HAND END OF &LBL\n         AIF   (K'&LBL EQ 0).OKLBL     LENGTH ZERO--NO TRIM NECESSARY\n.TRIMLBL AIF   ('&LBL'(K'&LBL,1) NE ' ').OKLBL  Q. LAST CHAR A BLANK?\n.* A. YES, LAST CHARACTER IS A BLANK\n         AIF   (K'&LBL EQ 1).ZZLBL     LENGTH ONE--NO PAD NECESSARY\n&LBL     SETC  '&LBL'(1,K'&LBL-1)      A. YES--TRIM LAST CHARACTER AND\n         AGO   .TRIMLBL                    GO BACK AND CHECK SOME MORE\n.OKLBL   ANOP  ,                       A. NO--NO MORE TRIM NECESSARY\n.*\n&LBL     SETC  '&LBL. '                ADD EXACTLY 1 BLANK\n.ZZLBL   ANOP  ,\n.*\n.* CALCULATE HOW MUCH ROOM WE HAVE TO WORK WITH:\n&LCLA    SETA  10-1          COLUMNS 1 THROUGH JUST-BEFORE 10\n.*\n         AIF   (&LCLA LE K'&LBL).PADLBLZ NO PAD NECESSARY\n&LBL     SETC  '&LBL'.(&LCLA-K'&LBL)' ' PAD TO LENGTH NECESSARY\n.PADLBLZ ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* TRIM ALL BLANKS FROM RIGHT-HAND END OF &OPR\n         AIF   (K'&OPR EQ 0).OKOPR     LENGTH ZERO--NO TRIM NECESSARY\n.TRIMOPR AIF   ('&OPR'(K'&OPR,1) NE ' ').OKOPR  Q. LAST CHAR A BLANK?\n.* A. YES, LAST CHARACTER IS A BLANK\n         AIF   (K'&OPR EQ 1).ZZOPR     LENGTH ONE--NO PAD NECESSARY\n&OPR     SETC  '&OPR'(1,K'&OPR-1)      A. YES--TRIM LAST CHARACTER AND\n         AGO   .TRIMOPR                    GO BACK AND CHECK SOME MORE\n.OKOPR   ANOP  ,                       A. NO--NO MORE TRIM NECESSARY\n.*\n&OPR     SETC  '&OPR. '                ADD EXACTLY 1 BLANK\n.ZZOPR   ANOP  ,\n.*\n.* CALCULATE HOW MUCH ROOM WE HAVE TO WORK WITH:\n&LCLA    SETA  16-10         COLUMNS 10 THROUGH JUST-BEFORE 16\n.*\n         AIF   (&LCLA LE K'&OPR).PADOPRZ NO PAD NECESSARY\n&OPR     SETC  '&OPR'.(&LCLA-K'&OPR)' ' PAD TO LENGTH NECESSARY\n.PADOPRZ ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* TRIM ALL BLANKS FROM RIGHT-HAND END OF &OPD\n         AIF   (K'&OPD EQ 0).OKOPD     LENGTH ZERO--NO TRIM NECESSARY\n.TRIMOPD AIF   ('&OPD'(K'&OPD,1) NE ' ').OKOPD  Q. LAST CHAR A BLANK?\n.* A. YES, LAST CHARACTER IS A BLANK\n         AIF   (K'&OPD EQ 1).ZZOPD     LENGTH ONE--NO PAD NECESSARY\n&OPD     SETC  '&OPD'(1,K'&OPD-1)      A. YES--TRIM LAST CHARACTER AND\n         AGO   .TRIMOPD                    GO BACK AND CHECK SOME MORE\n.OKOPD   ANOP  ,                       A. NO--NO MORE TRIM NECESSARY\n.*\n&OPD     SETC  '&OPD. '                ADD EXACTLY 1 BLANK\n.ZZOPD   ANOP  ,\n.*\n.* CALCULATE HOW MUCH ROOM WE HAVE TO WORK WITH:\n&LCLA    SETA  &CECCMT1COL-16\n.*\n.PADOPDL ANOP  ,                       ADDITIONAL LINE\n         AIF   (K'&OPD LE &LCLA).PADOPDY                               X\n                                       Q. &OPD SHORT ENOUGH TO FIT?\n&LCLA    SETA  &LCLA+56                 A. NO--USE AN ADDITIONAL LINE\n.* NOTE--EACH CONTINUATION LINE GIVES 56 MORE CHARACTERS (COLS 16-71)\n         AGO   .PADOPDL\n.PADOPDY ANOP  ,                        A. YES--IT WILL FIT\n.*\n         AIF   (&LCLA LE K'&OPD).PADOPDZ NO PAD NECESSARY\n&OPD     SETC  '&OPD'.(&LCLA-K'&OPD)' ' PAD TO LENGTH NECESSARY\n.PADOPDZ ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* TRIM ALL BLANKS FROM RIGHT-HAND END OF &CMT\n         AIF   (K'&CMT EQ 0).OKCMT     LENGTH ZERO--NO TRIM NECESSARY\n.TRIMCMT AIF   ('&CMT'(K'&CMT,1) NE ' ').OKCMT  Q. LAST CHAR A BLANK?\n         AIF   (K'&CMT EQ 1).ZZCMT     LENGTH ONE--NO PAD NECESSARY\n&CMT     SETC  '&CMT'(1,K'&CMT-1)      A. YES--TRIM LAST CHARACTER AND\n         AGO   .TRIMCMT                    GO BACK AND CHECK SOME MORE\n.OKCMT   ANOP  ,                       A. NO--NO MORE TRIM NECESSARY\n.*\n&CMT     SETC  '&CMT. '                ADD EXACTLY 1 BLANK\n.ZZCMT   ANOP  ,\n.*\n.* CALCULATE HOW MUCH ROOM WE HAVE TO WORK WITH:\n&LCLA    SETA  &CECCMT2COL-&CECCMT1COL\n.*\n.PADCMTL ANOP  ,                       ADDITIONAL LINE\n         AIF   (K'&CMT LE &LCLA).PADCMTY Q. &CMT SHORT ENOUGH TO FIT?\n&LCLA    SETA  &LCLA+56                  A. NO--USE AN ADDITIONAL LINE\n.* NOTE--EACH CONTINUATION LINE GIVES 56 MORE CHARACTERS (COLS 16-71)\n         AGO   .PADCMTL\n.PADCMTY ANOP  ,                        A. YES--IT WILL FIT\n.*\n         AIF   (&LCLA LE K'&CMT).PADCMTZ NO PAD NECESSARY\n&CMT     SETC  '&CMT'.(&LCLA-K'&CMT)' ' PAD TO LENGTH NECESSARY\n.PADCMTZ ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n         AIF   ('&LBL'(1,1) EQ '*').DOMNOTE\n&LCLAX(1) SETA K'&LBL,K'&OPR,K'&OPD,K'&CMT\n         CECDYN DEBUG,' CECDYN *2',                                    X\n               ' LBL=&LCLAX(1),\"&LBL\"',                                X\n               ' OPR=&LCLAX(2),\"&OPR\"',                                X\n               ' OPD=&LCLAX(3),\"&OPD\"',                                X\n               ' CMT=&LCLAX(4),\"&CMT\"',                                X\n               ' CMT1COL=&CECCMT1COL, CMT2COL=&CECCMT2COL',            X\n               ' CEC#CMT1COL=&CEC#CMT1COL, CEC#CMT2COL=&CEC#CMT2COL'\n.*\n.* THIS IS THE MAIN PURPOSE OF ROUTINE .GENCOM:\n&LBL     &OPR  &OPD&CMT&CEC#CMT2VAL\n.* THAT WAS THE MAIN PURPOSE OF ROUTINE .GENCOM--YOU ALMOST MISSED IT.\n.*\n         AGO   .DONEIT\n.*..+....1....+....2                                                  0\n.*\n.DOMNOTE ANOP  ,\n.*\n         MNOTE '&LBL&OPR&OPD&CMT&CEC#CMT2VAL'\n.*\n         AGO   .DONEIT\n.*..+....1                                                            0\n.*\n.DONEIT  ANOP  ,\n.*\n&LCLA    SETA  &GENRETI      FETCH RETURN INDEX\n&GENRETI SETA  1             RETURN POINTER TO DEFAULT, FOR NEXT TIME\n.* ACTUAL CODE GENERATION:                                            -\n         AGO   (&LCLA).GENRET1,.GENRET2,.GENRET3,.GENRET4,.GENRET5,    X\n               .GENRET6,.GENRET7,.GENRET8,.GENRET9\n.***************************\n.* THE EFFECT OF THE ABOVE CODE IS:\n.*       AGO   .GENRET&LCLA\n.***************************\n         MNOTE 16,'SEVERE INTERNAL ERROR'\n         MNOTE 'GENRETI=&LCLA'\n&CEC#DEBUG SETB 1      TURN ON\n         AGO   .CR#EXIT\n.*..+....1                                                            0\n.*\n.GENRET1 AGO   .CR#EXIT , DEFAULT EXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70\n.*\n.CR#EXIT ANOP  ,\n&CECCMT1COL SETA &CEC#CMT1COL COMMENT 1 FIELD'S COLUMN\n&CECCMT2COL SETA &CEC#CMT2COL COMMENT 2 FIELD'S COLUMN\n         AGO   .SUBEXIT , EXIT FROM .CREAT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.DEBUG   ANOP  , SELF-CALL INTERNAL ROUTINE -- DISPLAY DEBUG MNOTES   0\n.*\n.* IF NO PARAMETERS BESIDES FIRST, TURN ON DEBUGGING AND .SUBEXIT\n         AIF   (N'&SYSLIST NE 1).NORMALDBG\n&CEC#DEBUG SETB 1      TURN ON\n         AGO   .SUBEXIT\n.NORMALDBG ANOP  ,\n.*\n.* IF JUST 1 PARAMETER BESIDES FIRST, AND IT STARTS WITH \".\", SAVE IT\n.* OR IF IT STARTS WITH \".'\", SAVE IT WITHOUT QUOTES\n         AIF   (N'&SYSLIST NE 2).NOSAVE\n         AIF   ('&POS2'(1,1) EQ '.').YSSAVE\n         AIF   ('&POS2'(1,2) EQ '''.').YSSAVEQ\n         AGO   .NOSAVE\n.YSSAVE  ANOP  ,\n&CEC#DBG#HDR SETC '&POS2'\n         AGO   .SUBEXIT\n.YSSAVEQ ANOP   ,\n&CEC#DBG#HDR SETC '&POS2'(2,K'&POS2-2) REMOVE QUOTES\n         AGO   .SUBEXIT\n.NOSAVE  ANOP  ,\n.*\n         AIF   (NOT &CEC#DEBUG).SUBEXIT IMMEDIATE RETURN\n.*\n         CECDYN MNOTE,&CEC#DBG#HDR,' -- ',&POS2,&POS3,&POS4,&POS5,     X\n               &POS6,&POS7,&POS8,&POS9,&POS10\n         AGO   .SUBEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.DOKEY   ANOP  , SELF-CALL INTERNAL ROUTINE -- PROCESS ONE TEXT UNIT  0\n.* ('USER-SUPPLIED' MEANS ON THE OUTER CALL TO CECDYN, FROM OPEN CODE)\n.* INPUT: POSITIONAL PARAMETERS\n.* &POS1  ALWAYS DOKEY\n.* &POS2  ALWAYS &I, ORDINAL TEXT UNIT NUMBER (BUILD '1ST','2ND',ETC.)\n.* &POS3  ALWAYS &KEY, USER-SUPPLIED TEXT UNIT KEY\n.* &POS4  ALWAYS &TEXT(&I,2), USER-SUPPLIED VALUE(S)\n.* &POS5  A TEXT UNIT NAME FROM IEFZB4D2\n.* &POS6  A SINGLE NUMBER OR A PAIR OF NUMBERS (MINPRMS,MAXPRMS) .\n.*         THIS GIVES LIMITS FOR S99TUNUM, WHICH \"SPECIFIES THE NUMBER\n.*         OF LENGTH-AND-PARAMETER COMBINATIONS IN THE TEXT UNIT\".\n.* &POS7  A SINGLE CHARACTER, THE FIELD TYPE C/X/F/A TO BE GENERATED.\n.* &POS8  A SINGLE NUMBER OR A PAIR OF NUMBERS (MINLNG,MAXLNG) .\n.*         THIS GIVES LIMITS FOR S99TULNG, WHICH \"SPECIFIES THE LENGTH\n.*         OF THE FOLLOWING PARAMETER FIELD\".\n.* &POS9  * -- A SINGLE ASTERISK\n.*        OR A LIST ((<CHARS>,<VALU>), (<CHARS>,<VALU>), ...)\n.*     OR A LIST (+, (<CHARS>,<VALU>), (<CHARS>,<VALU>), ...) .\n.*        WHEN A SINGLE ASTERISK IS SPECIFIED, A LABEL IS GENERATED\n.*     FOR AN INFORMATION-RETURN FIELD, CONSISTING OF &PREFIX PLUS\n.*     THE TEXT UNIT'S NAME.\n.*        WHEN A LIST IS SPECIFIED, THE USER-SUPPLIED VALUE(S) ARE\n.*     COMPARED AGAINST EACH <CHARS> ENTRY IN THE LIST, AND WHEN\n.*     AN EQUAL IS FOUND, THE CORRESPONDING <VALU> IS USED.\n.*     ORDINARILY, THE USER CAN ONLY SPECIFY ONE VALUE.  WHEN THE\n.*     LIST BEGINS WITH '+', MULTIPLE VALUES SPECIFIED BY THE USER\n.*     ARE TRANSLATED INTO MULTIPLE <VALU>S WHICH ARE THEN SUMMED TO\n.*     GENERATE A VALUE.\n.*        A <CHARS> ENTRY OF A SINGLE ASTERISK IS CONSIDERED A MATCH\n.*     FOR ANY VALUE SPECIFIED BY THE USER.\n.*        IN ADDITION TO THE VALUE GENERATED, A COMMENT IS GENERATED\n.*     IN THE FORM \"<CHARS>=<VALU>\".\n.*        IF THE LIST ENDS WITH AN ASTERISK, THEN NO ERROR MESSAGE\n.*     IS GENERATED FOR THE USER-SPECIFIED VALUE NOT BEING FOUND\n.*     AMONG THE <CHARS> ENTRIES, AND THE USER-SPECIFIED VALUE IS\n.*     USED AS-IS.\n.* &POS10  TEXT APPENDED TO THE GENERATED COMMENT.\n.*\n.*\n.*\n.* IF THERE IS ONLY 1 TEXT UNIT NAME IN THE LIST (N'&POS5 EQ 1) AND\n.* IT DOES NOT EQUAL THE ONE THE USER SUPPLIED    ('&POS3' NE '&POS5')\n.* THEN EXIT IMMEDIATELY     (.SUBEXIT)\n         AIF   (                                  N'&POS5 EQ 1  AND    X\n                                                   '&POS3' NE '&POS5'  X\n                             ).SUBEXIT\n.*\n.*\n.* IN CASE MORE THAN 1 TEXT UNIT NAME IS CODED,\n.* FIND USER-SUPPLIED &POS3 IN THE &POS5 LIST OF TEXT UNIT NAMES\n&J       SETA  1\n.NEXTJ01 ANOP  ,\n         AIF   ('&POS3' EQ '&POS5(&J)').EXITJ01\n.ADVJ01  ANOP  , ADVANCE &J\n&J       SETA  &J+1\n         AIF   (&J LE N'&POS5).NEXTJ01\n         AGO   .SUBEXIT , NOT FOUND, EXIT IMMEDIATELY\n.EXITJ01 ANOP  ,\n.* NOW &J POINTS TO THE ENTRY IN THE &POS5 LIST THAT MATCHES &POS3.\n.*\n.*\n.A#DOKEY CECDYN DEBUG,'.DOKEY A#DOKEY' SAVE HEADING FOR DEBUG MESSAGES\n.*\n.******* CECDYN DEBUG,'&NAME CECDYN *1 &POS1,&POS2,\"',                 X\n               &POS3,'\",&POS4,\"',                                      X\n               &POS5,'\",\"',                                            X\n               &POS6,'\",&POS7,&POS8,\"',                                X\n               &POS9,'\"'\n.*\n&CEC#KEYDONE SETB 1          INFORM CALLER, KEY HAS BEEN FOUND\n&I       SETA  &POS2\n&KEY     SETC  '&POS3'\n.*\n&CECCMT1COL SETA &CEC#CMT1COL COMMENT 1 FIELD'S COLUMN\n&CECCMT2COL SETA &CEC#CMT2COL COMMENT 2 FIELD'S COLUMN\n.* (EACH CALL TO .CREAT DOES ABOVE SETA.S, JUST BEFORE EXITING)\n.*\n&CEC#XLAT SETB (N'&POS9 GT 1  OR  '&POS7' EQ 'A')\n.*           IF N'&POS9 GT 1, THEN DEFINITELY A TRANSLATION TABLE.\n.* BUT, &POS9 MAY BE OMITTED;  IF '&POS7' EQ 'A', IT IS NUMERIC;\n.* ACT LIKE #XLAT.\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.A#XLAT  CECDYN DEBUG,'.DOKEY A#XLAT' SAVE HEADING FOR DEBUG MESSAGES\n&MAXJ    SETA  1             ONE VALUE TO BE GENERATED\n         AIF   (&CEC#XLAT).GENHDR     GENERATE GROUP HEADER\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.A#XCHK  CECDYN DEBUG,'.DOKEY A#XCHK' SAVE HEADING FOR DEBUG MESSAGES\n.*                           SET &MAXJ, AND OTHER THINGS\n.* FALL-THRU TO .GENHDR      AND THEN GENERATE GROUP HEADER\n.*\n.*\n.* FIRST, CROSS-CHECK BETWEEN:\n.*       N'&POS4 (NUMBER OF VALUES SPECIFIED BY THE CALLER)\n.*     AND &POS6 (NUMBER OF VALUES EXPECTED).\n.*\n         AIF   ((N'&POS6-1)*(N'&POS6-2) EQ 0).C#XCHK\n         MNOTE 4,'INTERNAL ERROR PROCESSING KEY &POS3 -- &&POS6 SHOULD X\n               HAVE ONLY 1 OR 2 ENTRIES, IT WAS \"&POS6\"'\n.C#XCHK  ANOP  ,\n.* IF N'&POS6=1, A FIXED # VALUES IS EXPECTED, &POS6(1)\n.* IF N'&POS6=2, MIN # VALUES EXPECTED IS &POS6(1), MAX IS &POS6(2)\n         AIF   (N'&POS6 NE 1).D#XCHK  VARIABLE NUMBER POSSIBLE? YES\n         AIF   (&POS6(1) NE 0).D#XCHK NON-ZERO NUMBER REQUIRED? YES\n         AIF   (N'&POS4 NE 0).D#XCHK  USER SUPPLIED AT LEAST 1? YES\n.* FIXED NUMBER POSSIBLE, WHICH IS ZERO, AND USER DID NOT SUPPLY ANY:\n&MAXJ    SETA  0            NO VALUES TO BE GENERATED\n         AGO   .F#XCHK      GO GENERATE THEM\n.D#XCHK  AIF   (N'&POS4 LE &POS6(N'&POS6)).E#XCHK Q. TOO MANY? A. NO  0\n&LCLA2   SETA  N'&POS4      # VALUES SPECIFIED                 A. YES\n         MNOTE 8,'ERROR: &LCLA2 VALUES WERE SPECIFIED FOR KEY &POS3 -- X\n               &POS6(N'&POS6) IS THE MAXIMUM NUMBER PERMITTED.'\n.E#XCHK  ANOP  ,\n&MAXJ    SETA  &POS6(1)     FIRST OR ONLY -- MINIMUM OR REQUIRED #\n         AIF   (&MAXJ GT N'&POS4).F#XCHK CALLER SPECIFIED FEWER? YES,  X\n                                       GENERATE THE MINIMUM # REQUIRED\n&MAXJ    SETA  N'&POS4 NO, GENERATE AS MANY VALUES AS CALLER SPECIFIED\n.*\n.F#XCHK  ANOP  ,\n.*\n         CECDYN DEBUG,'POS4=&POS4, POS6=&POS6, SO MAXJ=&MAXJ..'\n.*\n         AGO   .GENHDR\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.GENHDR  ANOP  ,             GENERATE GROUP HEADER\n.*\n.* BOTH .XLAT AND .XCHK PASS THROUGH HERE\n.*\n         AIF   (&CEC#XLAT).Q#XLAT\n.Q#XCHK  CECDYN CMT2,.XCHK   SET &CEC#CMT2VAL\n         AGO   .Q#BOTH\n.Q#XLAT  CECDYN CMT2,.XLAT   SET &CEC#CMT2VAL\n.Q#BOTH  ANOP  ,\n.*\n&CEC#P.NUM&I CECDYN CREAT,,A,2,&MAXJ,'# OF LENGTH+PARAMETER ENTRIES'\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.*\n.* IF &POS9 IS NOT A TRANSLATION TABLE, GENERATE MULTIPLE VALUES.\n.*\n         AIF   (&MAXJ EQ 0).SUBEXIT   NO VALUES TO BE GENERATED? YES\n.*\n.* IF THERE IS A MINIMUM NUMBER, DO THAT MANY (NULL VALUES, IF NEEDED)\n.*                               ELSE DO AS MANY AS CALLER SPECIFIED\n.*\n.* NOW, LOOP THROUGH REQUIRED NUMBER (FROM 1 UP THROUGH &MAXJ)\n&J       SETA  1\n.NEXTJ02 CECDYN DEBUG,'.DOKEY NEXTJ02' SAVE HEADING FOR DEBUG MESSAGES\n&SUFFIX  SETC  ''                  NO SUFFIX NEEDED, IF ONLY 1 FIELD\n         AIF   (&MAXJ EQ 1).SFXOK  YES, ONLY 1 FIELD TO BE GENERATED\n&SUFFIX  SETC  '#&J'               IF MORE THAN 1, DISTINGUISH THEM\n.SFXOK   ANOP  ,\n&CEC#P.ENT&I&SUFFIX CECDYN CREAT,0,C,,,'ENTRY OF LENGTH+PARAMETER'\n.*..+....1....+....2....+....3....+....4                              0\n.*..+....1....+....2....+....3....+....4                              1\n.*\n         AIF   (NOT &CEC#XLAT).NOXLAT2\n.*\n.XLATVV  ANOP  , WHEN &CEC#XLAT, SET &VALUE, &VALUE2, &LV\n.*             (NOTE: WHEN &CEC#XLAT, THEN &MAXJ IS 1, SO THIS CODE\n.*              IS NOT DONE EACH TIME THROUGH THE .NEXTJ02 LOOP)\n.*\n.*       &POS4 IS VALUES SPECIFIED BY CALLER;              (INDEX &K)\n.*       &POS9 IS TRANSLATION TABLE   ((R,2),(N,8),...)\n.*                               OR (+,(R,2),(N,8),...)    (INDEX &L)\n.* EACH TRANSLATION TABLE ENTRY CONSISTS OF:\n.*      &POS9(&L,1) <CHARS> FROM, AND &POS9(&L,2) <VALU> TO\n.*\n.* TWO LOOPS BELOW, LOOP BY &L WITHIN LOOP BY &K\n.*\n&VALUE   SETC  '&POS4'                 VALUE\n&VALUE2  SETC  '&KEY'                  COMMENT\n         AIF   (N'&POS9 EQ 0 AND N'&POS4 EQ 1).EXITK02 SKIP ENTIRELY\n.*\n.T#XLAT  CECDYN DEBUG,'.DOKEY T#XLAT' SAVE HEADING FOR DEBUG MESSAGES\n&VALUE   SETC  '0'                     INITIAL VALUE\n&VALUE2  SETC  ''                      INITIAL COMMENT\n         AIF   (N'&POS4 EQ 0).EXITK02\n&K       SETA  1\n.NEXTK02 ANOP  ,\n.*\n.* PROCESS ENTRY &POS4(&K) SPECIFIED BY USER\n.*\n&POS4K   SETC  '&POS4(&K)'\n         AIF   (N'&POS4 NE 1 OR &MAXJ NE 1).POS4KOK\n&POS4K   SETC  '&POS4'       PASS-THRU PARENS OF REGISTER OPERAND\n.POS4KOK ANOP  ,\n.*\n&LCLC    SETC  '0'                          DEFAULT VALUE\n&LCLC2   SETC  'IGNORE &POS4K'              DEFAULT COMMENT\n.*\n.*          IF (&K EQ 1) ALWAYS TRANSLATE FIRST USER-SPECIFIED VALUE:\n         AIF   (&K EQ 1).YESXLAT\n.*          IF WE ARE SUMMING, TRANSLATE ALL USER-SPECIFIED VALUES:\n         AIF   ('&POS9(1)' EQ '+' OR '&POS9(1)' EQ '''+''').YESXLAT\n         AGO   .SKIPXLT IF NOT SUMMING, ONLY TRANSLATE FIRST VALUE\n.YESXLAT ANOP  ,\n.*\n&L       SETA  1\n.NEXTL02 ANOP  ,\n         AIF   (N'&POS9(&L) NE 2).ADVL02 (SKIP NON-PAIRS IN &POS9)\n         AIF   ('&POS9(&L,1)' EQ '*').MATCH\n         AIF   ('&POS9(&L,1)' EQ '&POS4K').MATCH\n         AGO   .ADVL02\n.MATCH   ANOP  ,\n&LCLC    SETC  '&POS9(&L,2)'                RETURN VALUE\n&LCLC2   SETC  '&POS9(&L,1)=&POS9(&L,2)'    RETURN COMMENT\n         AGO   .EXITL02\n.ADVL02  ANOP  , ADVANCE &L\n&L       SETA  &L+1\n         AIF   (&L LE N'&POS9).NEXTL02\n.*\n.* WE REACH HERE IF &POS4K IS NOT FOUND IN THE TRANSLATE TABLE\n         AIF   ('&POS9(&L-1)' NE '*').EXITL02\n.* IF LAST ENTRY IN TRANSLATE TABLE IS '*', OK TO BE NOT-FOUND\n&LCLC    SETC  '&POS4K'                     RETURN VALUE\n&LCLC2   SETC  '&POS4K NOT TRANSLATED'      RETURN COMMENT\n.*\n.EXITL02 ANOP  , &LCLC=RETURN VALUE, &LCLC2=RETURN COMMENT\n.*\n.SKIPXLT ANOP  , SKIP TRANSLATION CODE ABOVE\n         AIF   (&K NE 1).ADDVALS ELSE SETVALS\n.SETVALS ANOP  ,\n&VALUE   SETC  '&LCLC'                 SET VALUE\n&VALUE2  SETC  '&KEY &LCLC2'           SET COMMENT\n         AGO   .ADVK02\n.ADDVALS ANOP  ,\n&VALUE   SETC  '&VALUE+&LCLC'          APPEND TO VALUE\n&VALUE2  SETC  '&VALUE2, &LCLC2'       APPEND TO COMMENT\n.ADVK02  ANOP  , ADVANCE &K\n&K       SETA  &K+1\n         AIF   (&K LE N'&POS4).NEXTK02\n         AGO   .EXITK02\n.*\n.EXITK02 ANOP  ,\n.*\n&LCLC    SETC  '&POS10'                           FETCH VALUE\n         AIF   (K'&LCLC LE 2).NOTCOMT             TOO SHORT FOR QUOTES\n         AIF   ('&LCLC'(1,1) NE '''').NOTCOMT       NOT LEADING QUOTE,\n         AIF   ('&LCLC'(K'&LCLC,1) NE '''').NOTCOMT NOR TRAILING.\n&LCLC    SETC  '&LCLC'(2,K'&LCLC-2)               REMOVE QUOTES\n.NOTCOMT ANOP  ,\n&VALUE2  SETC  '&VALUE2 &LCLC'\n.*\n         AIF   (&CEC#FLAG(1)).B#CHGV2      DC -- TEXT ONLY\n         AIF   (&CEC#FLAG(2)).B#CHGV2      DS -- TEXT ONLY\n         AIF   ('&VALUE2' NE '').X#CHGV2      ACTIVE -- DESCRIBE XLATE\n.* IF NO XLATE WAS DONE, FALL THRU TO TEXT ONLY\n.B#CHGV2 ANOP  ,\n&VALUE2  SETC  ''   LET IT BE OVERRIDDEN LATER\n.X#CHGV2 ANOP  ,\n.*\n&LV      SETA  &POS8(1)\n.*\n.NOXLAT2 ANOP  ,\n.*..+....1....+....2....+....3....+....4                              0\n.*..+....1....+....2....+....3....+....4                              1\n.*\n         AIF   (&CEC#XLAT).NOXCHK2\n.*\n.XCHKVV  ANOP  , WHEN NOT &CEC#XLAT, SET &VALUE, &VALUE2, &LV\n.*\n.* ANALYSE CALLER-SPECIFIED VALUE:\n.* &POS4(&J)=''      PRODUCES &NUL=1\n.*\n.* &POS4(&J)='...' PRODUCES &LIT=1\n.* &POS4(&J)=(...) PRODUCES &REG=1\n.* &POS4(&J)=A(...) PRODUCES &ACN=1\n.*   NOTE--IF A LIST WITH ONLY 1 ENTRY IS SPECIFIED, THAT IS &REG.\n&VALUE   SETC  '&POS4(&J)'\n         AIF   (N'&POS4 NE 1).BBVAL\n&VALUE   SETC  '&POS4'       PROPOGATE PARENS, SO &REG IS CORRECT\n.BBVAL   ANOP  ,\n.*\n&LIT     SETB  0             LITERAL\n&REG     SETB  0             REGISTER\n&ACN     SETB  0             ADDRESS CONSTANT\n&NUL     SETB  1             NULL -- OMITTED\n&LCLC    SETC   'POS4(J=&J.)=&VALUE.,'     PREPARE FOR DEBUGGING\n         AIF   (K'&VALUE EQ 0).ZZVAL             .* IF NULL SKIP\n         AIF   ('&VALUE' EQ '').ZZVAL            .* IF NULL SKIP\n&NUL     SETB  0                               .* RESET NULL IF NOT\n         AIF   (K'&VALUE LT 3).XXVAL TOO SHORT TO BE ANYTHING\n&LIT     SETB  ('&VALUE'(1,1) EQ '''' AND '&VALUE'(K'&VALUE,1) EQ '''')\n&LCLC    SETC   'POS4(J=&J.)='.'&VALUE'(2,K'&VALUE-2).','\n         AIF   (&LIT).ZZVAL\n&LCLC    SETC   'POS4(J=&J.)=&VALUE.,'     PREPARE FOR DEBUGGING\n&REG     SETB  ('&VALUE'(1,1) EQ '(' AND '&VALUE'(K'&VALUE,1) EQ ')')\n         AIF   (&REG).ZZVAL\n         AIF   (K'&VALUE LT 4).XXVAL TOO SHORT TO BE ACN\n&ACN     SETB  ('&VALUE'(1,2) EQ 'A(' AND '&VALUE'(K'&VALUE,1) EQ ')')\n         AIF   (&ACN).ZZVAL\n.XXVAL   ANOP  ,\n.ZZVAL   ANOP  ,\n         CECDYN DEBUG,'&LCLC NUL=&NUL, LIT=&LIT, REG=&REG, ACN=&ACN..'\n.*..+....1....+....2....+....3                                        0\n.*\n.A#LGH   CECDYN DEBUG,'.DOKEY A#LGH' SAVE HEADING FOR DEBUG MESSAGES\n.* DEFAULT VALUE LENGTH IS MAX VALUE LENGTH\n.* IF RANGE PERMITTED, AND CALLER SPECIFIED LITERAL VALUE,\n.*       THEN USE MAXIMUM OF (CALLER'S VALUE'S LENGTH, MINIMUM LENGTH)\n.*       &POS4 IS (VALUES) SPECIFIED BY CALLER;\n.*       &POS8 IS LENGTH OF EACH VALUE EXPECTED\n         AIF   ((N'&POS8-1)*(N'&POS8-2) EQ 0).B#LGH\n         MNOTE 4,'INTERNAL ERROR PROCESSING KEY &POS3 -- &&POS8 SHOULD X\n               HAVE ONLY 1 OR 2 ENTRIES, IT WAS \"&POS8\"'\n.B#LGH   ANOP  ,\n.* IF N'&POS8=1, A FIXED LENGTH IS EXPECTED,  &POS8(1)\n.* IF N'&POS8=2, MINIMUM LENGTH EXPECTED IS &POS8(1), MAX IS &POS8(2)\n&LMIN    SETA  &POS8(1)      MUST BE SELF-DEFINING DECIMAL TERM\n&LMAX    SETA  &POS8(N'&POS8) MUST BE SELF-DEFINING DECIMAL TERM\n&LV      SETA  &LMAX         DEFAULT VALUE LENGTH IS MAX VALUE LENGTH\n         AIF   (N'&POS8 EQ 1).G#LGH OK--ONLY 1, USE THAT LENGTH\n         AIF   (NOT &LIT).G#LGH       OK--USE MAX (OR ONLY) LENGTH\n&LV      SETA  &LMIN         DEFAULT VALUE LENGTH IS MIN VALUE LENGTH\n&LCLA2   SETA  K'&POS4(&J)-2 LENGTH OF VALUE SPECIFIED (W/O QUOTES)\n         AIF   (&LCLA2 LT &LMIN).G#LGH  OK--FORCE MINIMUM LENGTH\n&LV      SETA  &LCLA2        OK--USE CALLER'S VALUE'S LENGTH\n.G#LGH   ANOP  ,\n.X#LGH   ANOP  ,\n         CECDYN DEBUG,' POS8=&POS8.; MIN=&LMIN., MAX=&LMAX..'\n&LCLC    SETC  'K''''POS4(J=&J.)=K'''''.'&POS4(&J).=&LCLA2.;'\n&LCLC    SETC  '&LCLC. LENGTH USED IS LV=&LV..'\n         CECDYN DEBUG,'&LCLC'\n.*\n&VALUE2  SETC  ''   LET IT BE OVERRIDDEN LATER\n.*\n.NOXCHK2 ANOP  ,                                                      0\n.*..+....1....+....2....+....3....+....4                              -\n.*..+....1....+....2....+....3....+....4                              -\n&I1      SETA  &I-10*(&I/10)           1'S DIGIT OF &I\n&I10     SETA  (&I/10)-10*(&I/100)     10'S DIGIT OF &I\n&IIX     SETA  1+3*(&I1*(&I10-1)/(&I10-1)) IGNORE &I1 IF (&I10-1) EQ 0\n&ITH     SETC  'TH ST ND RD TH TH TH TH TH TH '(&IIX,2) 0TH, 1ST, ETC.\n.*..+....1\n&J1      SETA  &J-10*(&J/10)           1'S DIGIT OF &J\n&J10     SETA  (&J/10)-10*(&J/100)     10'S DIGIT OF &J\n&JIX     SETA  1+3*(&J1*(&J10-1)/(&J10-1)) IGNORE &J1 IF (&J10-1) EQ 0\n&JTH     SETC  'TH ST ND RD TH TH TH TH TH TH '(&JIX,2) 0TH, 1ST, ETC.\n.*..+....1\n&CEC#P.LNG&I&SUFFIX CECDYN CREAT,,A,2,&LV,                             X\n               'LENGTH OF &J&JTH PARM. OF &I&ITH KEY'\n         AIF   (&J NE 1).NOLABEL             LABEL ONLY FOR FIRST\n.******* AIF   ('&POS9' NE '*').NOLABEL Q. MUST WE DEFINE NAME? A. NO\n.*                                                              A. YES\n         AIF   ('&POS9' NE '*' AND '&CEC#CMT2VAL' EQ '.XLAT').NOLABEL\n.* (FOR .XCHK, FALL THROUGH ALL THE TIME)\n.*\n&LCLC    SETC  '&CEC#P'.'&KEY'(4,K'&KEY-3)\n&LCLC    CECDYN CREAT,0,&POS7,&LV,,'DEFINE NAME FOR USER'\n.NOLABEL ANOP  ,\n.*\n         AIF   ('&VALUE2' NE '').NOTNULL\n&VALUE2  SETC  'VALUE OF &J&JTH PARM. OF &I&ITH KEY' OVERRIDE HERE\n.NOTNULL ANOP  ,\n.*\n&CEC#P.PAR&I&SUFFIX CECDYN CREAT,,&POS7,&LV,&VALUE,'&VALUE2'\n.*..+....1....+....2....+....3                                        0\n.*\n.ADVJ02  ANOP  , ADVANCE &J\n&J       SETA  &J+1\n         AIF   (&J LE &MAXJ).NEXTJ02\n.*\n         AGO   .SUBEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.MNOTE   ANOP  , SELF-CALL INTERNAL ROUTINE -- MNOTE '&POS2&POS3...'\n&LCLC    SETC  ''\n.*\n&J       SETA  2\n.NEXTJ04 ANOP  ,\n.*\n.*\n         AIF   ('&SYSLIST(&J)' EQ '').EXITI04\n&LCLB    SETB  ('&SYSLIST(&J)'(1,1) EQ '''' AND                        X\n                             '&SYSLIST(&J)'(K'&SYSLIST(&J),1) EQ '''')\n.* QUOTES AT BOTH ENDS?\n&I       SETA  1+&LCLB    IF YES, SKIP BEGINNING QUOTE\n.NEXTI04 ANOP  ,\n         AIF   (K'&LCLC GE 254).EXITI04      .TOOBIG\n         AIF   ('&SYSLIST(&J)'(&I,1) EQ '''').DOUBLE\n         AIF   ('&SYSLIST(&J)'(&I,1) EQ '&&').DOUBLE\n&LCLC    SETC  '&LCLC'.'&SYSLIST(&J)'(&I,1)\n         AGO   .ADVI04\n.TOOBIG  MNOTE '&&LCLC TOO LONG -- &&J=&J -- &&I=&I -- &&LCLC=\"&LCLC\"'\n         AGO   .ADVI04\n.DOUBLE  ANOP  ,\n&LCLC    SETC  '&LCLC'.'&SYSLIST(&J)'(&I,1).'&SYSLIST(&J)'(&I,1)\n         AGO   .ADVI04\n.ADVI04  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE K'&SYSLIST(&J)-&LCLB).NEXTI04 SKIP ENDING QUOTE\n.EXITI04 ANOP  ,\n.*\n.*\n.ADVJ04  ANOP  , ADVANCE &J\n&J       SETA  &J+1\n         AIF   (&J LE N'&SYSLIST).NEXTJ04\n.EXITJ04 ANOP  ,\n.*\n         MNOTE '&LCLC'                                                -\n         AGO   .SUBEXIT                                               -\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n         MEND ,                                                       0\n         AGO   .SKIPTEXT\n                                                                      1\n@P\n1* (C) COPYRIGHT CENTERIOR ENERGY CORPORATION 1988,1991\n-CECDYN -- macro for building Dynamic Allocation parameter list\n-     This macro builds a parameter list which can be used by SVC 99.\n      It does not issue a call to SVC 99, it only builds the parameter\n      list in storage and returns control.\n0     Unlike the IBM-supplied macros, instead of calculating offsets\n      into the parameter list to store values into it, a dummy control\n      section and symbolic names are generated and used.  If a USING\n      is issued on the dummy section, the symbolic names can then be\n      used to modify the parameter list.  All symbolic names generated\n      by one call to CECDYN start with the same three characters.  The\n      three characters can be specified by the caller, or will be\n      assigned by the macro.\n0     The standard form of the CECDYN macro instruction is written\n      as follows:\n\n>     ----------------------------------------------------------------\n0     <name>              <name>: symbol.  Begin <name> in column 1.\n0     b\n+     /                   One or more blanks must precede CECDYN.\n0     CECDYN\n0     b\n+     /                   One or more blanks must follow CECDYN.\n\n>     ----------------------------------------------------------------\n0     VERB=<verb>         <verb>: two byte character string\n0     ,PREFIX=<prefix>    <prefix>: maximum-of-3 byte character string\n0     ,FLG11=(<flg11>)\n      ,FLG21=(<flg21>)\n      ,FLG22=(<flg22>)    <flg11>/<flg21>/<flg22>: one or more 5 byte\n                          character strings, seperated by commas.  For\n                          example, FLG##=(<flg##>,<flg##>,<flg##>) .\n                          If only one <flg##> is specified, the outer\n                          parentheses may be omitted.\n0     ,TEXT=(<text unit>) <text unit>: either a maximum-of-5 byte\n                          character string, or a parenthesized pair\n                          consisting of a maximum-of-5 byte character\n                          string plus one of: literal delimited by\n                          quotes, A-type address, register (2)-(12).\n                          If only one <text unit> is specified, the\n                          outer parentheses must still be coded.\n                          Note:  <text unit> is one or more text\n                          units, seperated by commas.  For example,\n                          TEXT=(<text unit>,<text unit>,<text unit>)\n0     ,LIST=NO            Default: LIST=YES\n      ,LIST=YES\n\n>     ----------------------------------------------------------------\n-     The parameters are explained below:\n-     VERB=<verb>\n0       specifies the SVC 99 function requested.  The two bytes\n        supplied will be prepended with 'S99VRB' to build a symbol\n        which specifies a verb code.  The seven verb codes are defined\n        in the IBM-supplied macro IEFZB4D0, described in \"System\n        Macros and Facilities\".\n0       No checking is done for validity, but values not defined in\n        IEBZB4D0 will create undefined symbols.\n0       There is no default for this parameter.\n-     FLG11=<flg11>\n      FLG21=<flg21>\n      FLG22=<flg22>\n0       specify certain available options.  Each 5 bytes supplied will\n        be prepended with 'S99' to build a symbol which specifies an\n        option, and all the <flg11> will be summed to produce FLG11,\n        all the <flg21> will be summed to produce FLG21, all the\n        <flg22> will be summed to produce FLG22.\n        FLG11 options are available to all SVC 99 callers.\n        FLG21 & FLG22 options are only available to authorized\n        callers.\n        The options available are defined in IBM-supplied macro\n        IEFZB4D0, described in \"System Macros and Facilities\".\n0       No checking is done for validity, but values not defined in\n        IEBZB4D0 will create undefined symbols.\n-     Note: No checking is done that a FLG11 option is specified for\n        FLG21, etc., or vice versa.  It will not cause an assembly\n        error, but results are unpredictable.\n-     ,PREFIX=<prefix>\n        optionally supplies up-to-3 characters to be used in building\n        the symbolic names for fields in the parameter list.  If not\n        specified, CECDYN will create a 3-character prefix dependent\n        on the assembler system variable &SYSNDX.  The prefix created\n        by CECDYN will start with an alphabetic character which will\n        range through A thru Z, and its next two characters will each\n        range through 0 thru 9 and A thru Z, the last character\n        varying most quickly, as &SYSNDX increases.\n        The dummy section created is named <prefix>DSECT, and it's\n        length is available as L'<prefix>DSECT .\n-     ,TEXT=(<text unit>)\n        specifies the text units to be placed in the parameter list.\n        Each text unit specified will usually be a parenthesized pair\n        consisting of a maximum-of-5 byte character string plus one\n        of:  literal delimited by quotes, A-type address, register\n        (2)-(12).\n        The character string will be prepended with the character 'D'\n        plus the VERB specified, to make a symbol which is defined in\n        the IBM-supplied macro IEFZB4D2, described in \"System Macros\n        and Facilities\".\n0       No checking is done for validity of the character string, but\n        values not defined in IEBZB4D2 will create undefined symbols.\n0       Some text units do not require a value, and these will be\n        specified by only the maximum-of-5 byte character string.  For\n        these, the inner parentheses may be omitted.\n0       If no text units are specified, only the request block pointer\n        and the request block are built.  If null text units are\n        specified, then text unit pointers with a value of zero are\n        built.\n0       Certain text units may have multiple values specified which\n        are then summed to build one value (DALOPTCD).  These, and\n        others, may have their values specified as character strings\n        which are then translated by CECDYN to be the proper hex\n        values -- For example, (STATS,OLD) will generate a value of\n        X'01'.  If you wish, you may code the actual hex value.\n0       Certain other text units may have multiple values which create\n        multiple fields in the parameter list (DALVLSER,etc.)  CECDYN\n        will check whether multiple values are specified for a text\n        unit which does not allow multiple values.\n0     ,LIST=NO\n      ,LIST=YES\n        specifies whether or not generated code is to be printed.\n        If this parameter is not specifed, a default of YES is used.\n-     When control is returned, register 1 points to the parameter\n      list.  SVC 99 can be issued immediately, or the parameter list\n      can be modified before issuing SVC 99.\n      The addresses of text units are stored in the parameter list\n      starting at the location labelled <prefix>TUPL.  The address of\n      each text unit is stored in the parameter list in field\n      <prefix>PTR<#>, where <prefix> is the PREFIX specified or\n      generated, and <#> ranges from 1 through the number of text\n      units specified.  Each text unit begins at the field labelled\n      <prefix>TU<#>.  Each text unit will always have a KEY subfield\n      <prefix>KEY<#> containing the text unit key, and a NUMBER\n      subfield <prefix>NUM<#> containing the number of length and\n      parameter combinations in the text unit.  Some text units will\n      have only these two subfields, if its NUMBER subfield has a\n      value of zero.\n-Example 1\n0     Operation: Unallocate the data set associated with ddname\n      IEFRDER.  CECDYN will assign a 3-byte prefix to the names\n      generated.\n0     NAME     CECDYN VERB=UN,TEXT=((DDNAM,'IEFRDER'))\n               DYNALLOC\n               LTR   15,15          WAS SVC99 SUCCESSFUL ?\n               ...\n0\n-Example 2\n0     Operation: Request all available information text units, for the\n      data set currently allocated to the ddname stored in symbol\n      WRKDD.  Returned information will be in the fields ZZZRTLST,\n      ZZZRTDDN, etc.\n      These fields will be accessible by issuing a USING ZZZDSECT,1 .\n0     INFORM   CECDYN  PREFIX=ZZZ,                                     X\n                     VERB=IN,                                          X\n                     TEXT=((DDNAM,WRKDD),                              X\n                     RTLST,RTDDN,RTDSN,RTMEM,RTSTA,                    X\n                     RTNDP,RTCDP,RTORG,RTLIM,RTATT,RTTYP)\n               DYNALLOC\n               LTR   15,15          WAS SVC99 SUCCESSFUL ?\n               BNZ   ERROR          NO.\n               USING ZZZDSECT,1     ADDRESSABILITY TO PARAMETER LIST\n               MVC   LASTIND,ZZZRTLST\n               MVC   MEMBER,ZZZRTMEM\n               ...\n-Example 3\n0     Operation: Build a list to be modified later.  In the list,\n      specify 'do not mount volumes or consider offline devices'.\n      Reserve space for 5 text unit addresses.  Modify the first three\n      addresses by using the list form of the CALL macro instruction.\n0     ALLOCIT  CECDYN  PREFIX=Q02,                                     X\n                     VERB=AL,                                          X\n                     FLG11=NOMNT,                                      X\n                     TEXT=(,,,,)\n               USING Q02DSECT,1\n               MVC   Q02TUPL(CALLISTX-CALLIST),CALLIST\n               DYNALLOC\n               LTR   15,15          WAS SVC99 SUCCESSFUL ?\n               ...\n               ...\n      CALLIST  CALL  ,(THIS,THAT,OTHER),VL,MF=L\n      CALLISTX EQU   *\n1\n-CECDYN (List Form)\n-     The list form of the CECDYN macro instruction is used to\n      construct a nonexecutable SVC 99 parameter list.  This list form\n      generates only ADCONs of the text unit parameters.  This\n      parameter list can be referred to in the execute form of a\n      CECDYN macro instruction.\n0     The list form of the CECDYN macro instruction is written as\n      follows:\n\n>     ----------------------------------------------------------------\n0     <name>              <name>: symbol.  Begin <name> in column 1.\n0     b\n+     /                   One or more blanks must precede CECDYN.\n0     CECDYN\n0     b\n+     /                   One or more blanks must follow CECDYN.\n\n>     ----------------------------------------------------------------\n0     VERB=<verb>         <verb>: two byte character string\n0     ,PREFIX=<prefix>    <prefix>: maximum-of-3 byte character string\n0     ,FLG11=(<flg11>)\n      ,FLG21=(<flg21>)\n      ,FLG22=(<flg22>)    <flg11>/<flg21>/<flg22>: one or more 5 byte\n                          character strings, seperated by commas.  For\n                          example, FLG##=(<flg##>,<flg##>,<flg##>) .\n                          If only one <flg##> is specified, the outer\n                          parentheses may be omitted.\n0     ,TEXT=(<text unit>) <text unit>: either a maximum-of-5 byte\n                          character string, or a parenthesized pair\n                          consisting of a maximum-of-5 byte character\n                          string plus one of: literal delimited by\n                          quotes, A-type address, register (2)-(12).\n                          If only one <text unit> is specified, the\n                          outer parentheses must still be coded.\n                          Note: <text unit> is one or more text units,\n                          seperated by commas.  For example,\n                          TEXT=(<text unit>,<text unit>,<text unit>)\n0     ,LIST=NO            Default: LIST=YES\n      ,LIST=YES\n0     ,MF=L\n\n>     ----------------------------------------------------------------\n-     The parameters are explained under the standard form of the\n      CECDYN macro instruction, with the following exception:\n-     MF=L\n0       specifies the list form of the CECDYN macro instruction.\n1\n-CECDYN (Execute Form)\n-     A remote SVC 99 parameter list is referred to and can be\n      modified by the execute form of the CECDYN macro instruction.\n      Only executable instructions are generated.  The first time a\n      particular PREFIX is used, a DSECT is defined.  Each execute\n      form CECDYN macro instruction later in a program which uses the\n      same PREFIX must have the same VERB as specified on the list\n      form CECDYN macro instruction, or symbolic names referred-to in\n      the generated code will not be previously defined.  A\n      combination of FLG11, FLG21, and FLG22 values can be specified\n      that is different than that specified on the list form CECDYN\n      macro instruction.\n      The TEXT may have fewer entries specified, but should have no\n      new maximum-of-5 byte character strings which were not on the\n      list form CECDYN macro instruction.\n0     The execute form of the CECDYN macro instruction is written as\n      follows:\n\n>     ----------------------------------------------------------------\n0     <name>              <name>: symbol.  Begin <name> in column 1.\n0     b\n+     /                   One or more blanks must precede CECDYN.\n0     CECDYN\n0     b\n+     /                   One or more blanks must follow CECDYN.\n\n>     ----------------------------------------------------------------\n0     VERB=<verb>         <verb>: two byte character string\n0     ,PREFIX=<prefix>    <prefix>: maximum-of-3 byte character string\n0     ,FLG11=(<flg11>)\n      ,FLG21=(<flg21>)\n      ,FLG22=(<flg22>)    <flg11>/<flg21>/<flg22>: one or more 5 byte\n                          character strings, seperated by commas.  For\n                          example, FLG##=(<flg##>,<flg##>,<flg##>) .\n                          If only one <flg##> is specified, the outer\n                          parentheses may be omitted.\n0     ,TEXT=(<text unit>) <text unit>: either a maximum-of-5 byte\n                          character string, or a parenthesized pair\n                          consisting of a maximum-of-5 byte character\n                          string plus one of: literal delimited by\n                          quotes, A-type address, register (2)-(12).\n                          If only one <text unit> is specified, the\n                          outer parentheses must still be coded.\n                          Note: <text unit> is one or more text units,\n                          seperated by commas.  For example,\n                          TEXT=(<text unit>,<text unit>,<text unit>)\n0     ,LIST=NO            Default: LIST=YES\n      ,LIST=YES\n0     ,MF=(E,<remote addr>)\n                          <remote addr>: RX-type address, or register\n                          (1) or (2)-(12).\n\n>     ----------------------------------------------------------------\n-     The parameters are explained under the standard form of the\n      CECDYN macro instruction, with the following exception:\n-     MF=(E,<remote addr>)\n0       specifies the execute form of the CECDYN macro instruction.\n        The text units specified are built at the address specified in\n        the MF parameter.\n9SYS2.CEI.MACLIB(CECDYN)                                   08-MAR-1991\n.SKIPTEXT ANOP ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CECDYNRW": {"ttr": 2822, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x07\\x01\\x10&\\x0f\\x01\\x10&/\\x00\\x05\\x10~\\x10~\\x00\\x00\\xd6\\xd9\\xc9\\xc7\\xc9\\xd5\\xd3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-09-17T00:00:00", "modifydate": "2010-09-19T00:05:07", "lines": 4222, "newlines": 4222, "modlines": 0, "user": "ORIGINL"}, "text": "LISTSERV mailing list manager   LISTSERV 15.5 at Central Michigan University\n\nHelp for C370-L Archives\nSubscriber's Corner     Email Lists             Log In\n\nC370-L Archives\nC370-L Archives\n\nView:\n\n\nNext Message | Previous Message\nNext in Topic | Previous in Topic\nNext by Same Author | Previous by Same Author\nChronologically | Most Recent First\nProportional Font | Monospaced Font\n\n\nOptions:\n\n\nJoin or Leave C370-L\nReply | Post New Message\nSearch Archives\n\nSubject:        Re: Program to dynamically alloc a file\nFrom:   \"Leslie J. Somos\" <\u00ddlog in to unmask\u00a8>\nReply-To:       Leslie J. Somos\nDate:   Fri, 11 Mar 1994 22:58:14 GMT\nContent-Type:   text/plain\nParts/Attachments:\nParts/Attachments\n\ntext/plain (4187 lines)\n\nIn a previous article, \u00ddlog in to unmask\u00a8 (Duane Weaver) says:\n\n>Does anyone have a simple program that dynamically\n>allocates a file using SVC99 and catalogs the data set?\n>\n>I am attempting to solve a problem with dynamic allocation\n>in another C program that was not written locally.\n>\n>I am trying to determine if something is missing in the program\n>that we have, or there is something wrong on our system.\n>\n>Duane\n>\n\n\nWell, this is not in C, but seeing how it does things, or reading\nthe IBM manuals that it references in internal comments, may help\nyou.  I wrote this a while ago, and it has turned out to be\nenormously useful.  It is solid, it works, a major programmer tool\nat our site depends on it.\nEnjoy.\n\n\nFrom ah739 Tue Jun 22 05:16:52 1993\nX-Freenet-Flags:  R\nReceived:  by slc10.INS.CWRU.Edu (5.65b+ida+/CWRU-1.5.3-freenet)\n        id AA21704; Tue, 22 Jun 93 05:16:52 -0400 (from ah739 for\n/usr/local/bin/m2mbox /u2/25/ah739/mbox)\nMessage-Id: <[log in to unmask]>\nDate: Tue, 22 Jun 93 05:16:52 -0400\nFrom: [log in to unmask] (Leslie J. Somos)\nX-To: ah739\nSubject: CECDYN.MAC\nReply-To: [log in to unmask] (Leslie J. Somos)\n\n\n\n//*.+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n//*\n//*      +-------------------------------------------------------+\n//*      |                                                       |\n//*      |   THESE MATERIALS ARE PROVIDED FOR DISTRIBUTION TO    |\n//*      |   INTERESTED THIRD PARTIES ON A NOT-FOR-PROFIT BASIS. |\n//*      |                                                       |\n//*      |   THE CONTENTS OF THIS PACKAGE MAY BE FURTHER COPIED  |\n//*      |   AND DISTRIBUTED, PROVIDED CREDIT IS GIVEN TO        |\n//*      |   CENTERIOR ENERGY CORPORATION AND THAT NO CHARGE IS  |\n//*      |   MADE EXCEPT TO RECOVER THE COSTS OF SUCH            |\n//*      |   DISTRIBUTION.                                       |\n//*      |                                                       |\n//*      |   NO WARRANTY AS TO THE COMPLETENESS OR CORRECTNESS   |\n//*      |   OF THE SOFTWARE IS EXPRESSED OR IMPLIED BY          |\n//*      |   CENTERIOR ENERGY CORPORATION.                       |\n//*      |                                                       |\n//*      |                                                       |\n//*      | +---------------------------------------------------+ |\n//*      | |                                                   | |\n//*      | |   MACRO CECDYN,    WRITTEN IN IBM 370 ASSEMBLER   | |\n//*      | |                                                   | |\n//*      | |   NO LABEL,  1 FILE,  FB / 80 / 32720,  6250BPI   | |\n//*      | |                                                   | |\n//*      | +---------------------------------------------------+ |\n//*      |                                                       |\n//*      +-------------------------------------------------------+\n//*\n//*.+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n//* PRINT THE DESCRIPTION OF THIS FILE\n//CONTENTS EXEC PGM=IEBGENER\n//SYSPRINT DD  DUMMY\n//SYSIN    DD  DUMMY\n//SYSUT1   DD  *\n1  CONTENTS OF THIS FILE:\n THIS IS A SEQUENTIAL FILE CONSISTING OF THE FOLLOWING JCL STEPS:\n\n CONTENTS  THIS STEP PRINTS THE TEXT YOU ARE READING\n IEFBR14   THIS STEP IS REFERRED-TO BY SUBSEQUENT STEPS\n DOCUMENT  ADD DOCUMENTATION TO YOUR CARD-IMAGE LIBRARY, USING IEBUPDTE\n MACROS    ADD MACROS TO YOUR MACRO LIBRARY, USING IEBUPDTE\n SOURCE0   ADD THE SOURCE MODULES TO YOUR SOURCE LIBRARY, USING IEBUPDTE\n SOURCE2   COPY THE EXAMPLE DRIVER SOURCE TO A SEQUENTIAL FILE\n ASSEMBL2  ASSEMBLE THE EXAMPLE DRIVER PROGRAM TO A TEMPORARY FILE\n LINK2     LINK THE TEMPORARY FILE TO A TEMPORARY LOAD LIBRARY\n GO        EXECUTE THE EXAMPLE DRIVER PROGRAM\n GO2       EXECUTE THE EXAMPLE DRIVER PROGRAM, AND MAKE IT WORK HARD\n\n\n THE CODE WAS WRITTEN ON AN MVS/XA SYSTEM, BUT IT SHOULD WORK JUST AS\n WELL ON MVS/ESA OR MVS/SP.\n THE MACRO CECDYN WILL PERFORM AS WELL ON VM OR DOS/VSE, BUT THERE IS\n NO SYSTEM SERVICE THAT USES SVC99-FORMAT PARAMETER LISTS.\n\n\n/*\n//SYSUT2   DD  SYSOUT=A,DCB=(RECFM=FA,LRECL=80,BLKSIZE=80)\n//*.+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n//*\n//*      REPLACE THE FOLLOWING REFERENCES WITH REFERENCES TO YOUR OWN\n//* DOCUMENTATION, MACRO, AND SOURCE LIBRARIES, WITHOUT THE DCB\n//* OR SPACE SPECIFICATIONS.\n//*      (OR, YOU CAN RUN THIS JOB JUST AS IT IS NOW.  EVERYTHING WILL\n//* BE COPIED TO TEMPORARY FILES, AND NO PERMANENT CHANGES WILL BE\n//* MADE TO YOUR SYSTEM.)\n//*\n//*      DO NOT CHANGE THE STEPNAME 'IEFBR14', IT IS REFERRED-TO LATER.\n//*\n//IEFBR14  EXEC PGM=IEFBR14\n//DOCUMENT DD  DSN=&&DOCUMENT,DISP=(NEW,PASS),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000),\n//             UNIT=SYSDA,SPACE=(CYL,(5,5,5))\n//MACLIB   DD  DSN=&&MACLIB,DISP=(NEW,PASS),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000),\n//             UNIT=SYSDA,SPACE=(CYL,(5,5,5))\n//SOURCE   DD  DSN=&&SOURCE,DISP=(NEW,PASS),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000),\n//             UNIT=SYSDA,SPACE=(CYL,(5,5,5))\n//*.+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n//INLINE   PROC SYSOUT=A\n//*.+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n//* ADD DOCUMENTATION TO YOUR DOCUMENTATION LIBRARY\n//DOCUMENT EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD  SYSOUT=&SYSOUT\n//SYSIN    DD  DUMMY\n//SYSUT2   DD  DISP=(OLD,PASS),DSN=*.IEFBR14.DOCUMENT\n//*.+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n//* ADD MACROS TO YOUR MACRO LIBRARY\n//MACROS   EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD  SYSOUT=&SYSOUT\n//SYSIN    DD  DUMMY\n//SYSUT2   DD  DISP=(OLD,PASS),DSN=*.IEFBR14.MACLIB\n//*.+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n//* ADD THE SOURCE MODULES TO YOUR SOURCE LIBRARY\n//SOURCE0  EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD  SYSOUT=&SYSOUT\n//SYSIN    DD  DUMMY\n//SYSUT2   DD  DISP=(OLD,PASS),DSN=*.IEFBR14.SOURCE\n//*.+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n//* COPY THE EXAMPLE DRIVER SOURCE TO A SEQUENTIAL FILE\n//SOURCE2  EXEC PGM=IEBUPDTE\n//SYSPRINT DD  SYSOUT=&SYSOUT\n//SYSIN    DD  DUMMY\n//SYSUT1   DD  DISP=(OLD,PASS),DSN=*.IEFBR14.SOURCE\n//SYSUT2   DD  DISP=(NEW,PASS),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000),\n//             UNIT=SYSDA,SPACE=(TRK,(15,15),RLSE)\n//*.+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n//* ASSEMBLE THE EXAMPLE DRIVER PROGRAM TO A TEMPORARY FILE\n//ASSEMBL2 EXEC PGM=IEV90,PARM='DECK,NOOBJECT'\n//SYSPRINT DD  SYSOUT=&SYSOUT\n//SYSIN    DD  DSN=*.SOURCE2.SYSUT2,DISP=(OLD,DELETE)\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT2   DD  UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT3   DD  UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSLIB   DD  DSN=*.IEFBR14.MACLIB,DISP=(SHR,PASS)\n//         DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.AMODGEN,DISP=SHR    MACRO IEZBITS\n//SYSPUNCH DD  DISP=(NEW,PASS),\n//             UNIT=SYSDA,SPACE=(TRK,(15,15),RLSE)\n//*.+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n//* LINK THE TEMPORARY FILE TO A TEMPORARY LOAD LIBRARY\n//LINK2    EXEC PGM=IEWL,PARM='LIST,LET,NCAL,XREF'\n//SYSPRINT DD  SYSOUT=&SYSOUT\n//SYSLIN   DD  DSN=*.ASSEMBL2.SYSPUNCH,DISP=(OLD,DELETE)\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSLMOD  DD  DSN=&&TEMPLOAD(DUMPINFO),DISP=(NEW,PASS),\n//             UNIT=SYSDA,SPACE=(CYL,(1,1,1))\n//*.+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n//* EXECUTE THE EXAMPLE DRIVER PROGRAM\n//GO       EXEC PGM=DUMPINFO\n//STEPLIB  DD  DSN=*.LINK2.SYSLMOD,DISP=(OLD,PASS)\n//SYSPRINT DD  SYSOUT=&SYSOUT\n//*.+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n//* EXECUTE THE EXAMPLE DRIVER PROGRAM AGAIN, AND MAKE IT WORK HARD:\n//GO2      EXEC PGM=*.LINK2.SYSLMOD\n//* THE PROGRAM WILL DYNAMICALLY ALLOCATE SYSPRINT, IF NOT PRESENT.\n//SYSUDUMP DD  SYSOUT=&SYSOUT,DCB=DSORG=PSU\n//INTRDR   DD  SYSOUT=(,INTRDR)\n//OL#CT#DL DD  DSN=*.LINK2.SYSLMOD,DISP=(OLD,CATLG,DELETE),\n//             DCB=DSORG=IS,\n//             UNIT=SYSDA,VOL=REF=*.LINK2.SYSLMOD\n//SH#DL#CT DD  DSN=*.GO.STEPLIB,DISP=(SHR,DELETE,CATLG),\n//             DCB=DSORG=DAU,\n//             UNIT=SYSDA,VOL=REF=*.GO.STEPLIB\n//NW#UC#KP DD  DSN=&&JUNK(@#$@#$),DISP=(NEW,UNCATLG,KEEP),\n//             DCB=DSORG=CX,\n//             UNIT=SYSDA,SPACE=(CYL,1)\n//DUMMY#DA DD  DUMMY,DCB=DSORG=DA\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=(SHR,KEEP,KEEP)\n//         DD  DSN=&&CONCAT(MD#PS#UC),DISP=(MOD,PASS,UNCATLG),\n//             DCB=DSORG=POU,\n//             UNIT=SYSDA,SPACE=(TRK,(1,,1))\n//*.+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n//         PEND INLINE\n//         EXEC INLINE\n//DOCUMENT.SYSIN DD *\n./ ADD NAME=CECDYN\n1                                                          CECDYN   1/4\n0+---------------------------------------------------------------------+\n |                                                                     |\n |       The accompanying programs, developed at Centerior Energy      |\n |  Corporation, are submitted for unrestricted distribution.  The     |\n |  programs have met a basic set of programming and documentation     |\n |  standards, but have not been tested in any formal fashion by       |\n |  Centerior Energy Corporation.  The user is expected to make the    |\n |  final evaluation as to the usefulness in their own environment.    |\n |                                                                     |\n |       Centerior Energy Corporation makes no warranty, expressed or  |\n |  implied, including, but not limited to, the implied warranties of  |\n |  merchantability and fitness for a particular purpose as to the     |\n |  documentation, function, or performance of these programs.         |\n |                                                                     |\n |       Acceptance and use of these programs constitutes a release    |\n |  from liability of Centerior Energy Corporation for any problems    |\n |  use of the programs may cause at the user's installation.          |\n |                                                                     |\n |       The programs are made available by Centerior Energy           |\n |  Corporation without charge or consideration.  Recipients are free  |\n |  to make the programs available to others in like manner.  They     |\n |  may not be sold.                                                   |\n |                                                                     |\n |       The assembler macros CECDYN, BREAK, and CONTINUE, and the     |\n |  example test program DUMPINFO were written by:                     |\n |                                                                     |\n |    Leslie J. Somos                                                  |\n |    Centerior Energy Corporation                                     |\n |    Mail Stop IND-149                                                |\n |    6200 Oak Tree Boulevard                                          |\n |    Independence, Ohio 44131                                         |\n |                                                                     |\n |       The assembler macros DO, OD, IF, ELSE, ELSEIF, FI, THEN,      |\n |  and EQUBC, were contributed to the SHARE MVS Group Modification    |\n |  Tape, by:                                                          |\n |    Donald S. Higgins                                                |\n |    Florida Power Corporation                                        |\n |    P.O.Box 14042       B-3-B                                        |\n |    St. Petersburg, FL 33733                                         |\n |                                                                     |\n |                                                                     |\n |       Centerior Energy Corporation does not guarantee to keep any   |\n |  material provided up to date, nor does it guarantee to provide     |\n |  any corrections or extensions described by the user or             |\n |  corrections or extensions made in the future by Centerior Energy   |\n |  Corporation itself.                                                |\n |                                                                     |\n +---------------------------------------------------------------------+\n-                                                            21-APR-1993\n1                                                          CECDYN   2/4\n BACKGROUND\n0    I work in the Technical Services department of Centerior Energy\n Corporation, an electric utility located in northern Ohio.\n-    The IBM manual describing Dynamic Allocation (SVC 99) has page\n upon page of text, listing all the text units available.  (For the\n release of MVS that I work with, the manual is GC28-1150 MVS/Extended\n Architecture System Programming Library: System Macros and Facilities\n Volume 1.)\n0    While I was writing a program that made multiple calls to SVC 99,\n I noticed that I repeated a small segment of code, with slight\n variations.  I decided to fold the intelligence necessary into a\n macro, so I would not need to use my (error-prone) memory as much.\n That macro is CECDYN.\n-IMPLEMENTATION\n0    Because CECDYN uses SETC symbol names longer than 7 characters,\n it can only be used with IEV90 (the H-level assembler), or higher.\n0    CECDYN has profuse internal comments.  It also has a DEBUG\n facility, which can be turned on if you suspect it is processing\n incorrectly.  The debugging is turned on by coding \" CECDYN DEBUG \".\n Also, any detected internal error turns on debugging.\n0    The information listed in the IBM manual for each text unit key\n is encoded in an internal table in CECDYN.\n0    CECDYN calls itself multiple times, like an assembler source-\n level subroutine.  It was coded this way, so that CECDYN is a single\n unit, and not multiple macros.\n     Only keyword parameters are used in user calls to CECDYN, no\n positional parameters.  Positional parameters are only used in\n recursive inner macro self-calls.\n     There are 5 internal entry points, and a branch table at label\n .SUBROUT .  The internal entry points and their functions are:\n .CMT2   give a value to symbol &CEC#CMT2VAL, displayed in MNOTEs;\n .CREAT  actually generate lines of code;\n .DEBUG  either turn on debugging, or display debugging messages;\n .DOKEY  check a text unit key against internal information;\n .MNOTE  actually issue all MNOTEs.\n     The 'internal table' of text units is implemented as a series of\n calls to the .DOKEY subroutine, within a loop that looks at each\n sublist entry in the TEXT parameter.  Each call to the .DOKEY\n subroutine encodes the processing necessary for a particular text unit\n key, and if it matches the key being processed, also turns on a flag\n that short-circuits scanning the following calls to the .DOKEY\n subroutine.\n1                                                          CECDYN   3/4\n EXAMPLES\n0    The IBM manual referred-to above has an example of a dynamic\n allocation request to allocate SYS1.LINKLIB with a status of SHARE.\n The corresponding code, using CECDYN, is:\n-DYN   CSECT ,\n       USING *,15\n       STM   14,12,12(13)\n       BALR  12,0\n BEGIN DS    0H\n       USING BEGIN,12\n * (All names generated by the CECDYN macro will begin with 'ABC'.)\n       LA    0,L'ABCDSECT  AMOUNT OF STORAGE REQUIRED FOR THIS REQUEST.\n       GETMAIN R,LV=(0)    GET THE STORAGE NECESSARY FOR THE REQUEST.\n       LR    8,1           SAVE THE ADDRESS OF THE RETURNED STORAGE.\n       CECDYN PREFIX=ABC,        All names generated begin with 'ABC'\n                MF=(E,(8)),      Build the parameter list here\n                VERB=AL,   SET THE VERB CODE TO ALLOCATION FUNCTION.\n                TEXT=((DSNAM,'SYS1.LINKLIB'),     FIRST TEXT UNIT\n                (STATS,SHR),                      SECOND TEXT UNIT\n                (RTDDN))                          THIRD TEXT UNIT\n       DYNALLOC            INVOKE SVC 99 TO PROCESS THE REQUEST.\n       USING ABCDSECT,8          All the ABC- names are found here\n * The returned DDNAME is found at label ABCRTDDN\n       LM    14,12,12(13)\n       BR    14            RETURN TO CALLER.\n       END\n-\n_    There are also examples in CECDYN itself, at the end, where they\n will not interfere with the normal functioning of the macro.\n1                                                          CECDYN   4/4\n EXAMPLES\n0    When the supplied test program DUMPINFO is run with the supplied\n JCL:\n //GO2      EXEC PGM=*.LINK2.SYSLMOD\n //SYSUDUMP DD  SYSOUT=&SYSOUT,DCB=DSORG=PSU\n //INTRDR   DD  SYSOUT=(,INTRDR)\n //OL#CT#DL DD  DSN=*.LINK2.SYSLMOD,DISP=(OLD,CATLG,DELETE),\n //             DCB=DSORG=IS,\n //             UNIT=SYSDA,VOL=REF=*.LINK2.SYSLMOD\n //SH#DL#CT DD  DSN=*.GO.STEPLIB,DISP=(SHR,DELETE,CATLG),\n //             DCB=DSORG=DAU,\n //             UNIT=SYSDA,VOL=REF=*.GO.STEPLIB\n //NW#UC#KP DD  DSN=&&JUNK(@#$@#$),DISP=(NEW,UNCATLG,KEEP),\n //             DCB=DSORG=CX,\n //             UNIT=SYSDA,SPACE=(CYL,1)\n //DUMMY#DA DD  DUMMY,DCB=DSORG=DA\n //SYSLIB   DD  DSN=SYS1.MACLIB,DISP=(SHR,KEEP,KEEP)\n //         DD  DSN=&&CONCAT(MD#PS#UC),DISP=(MOD,PASS,UNCATLG),\n //             DCB=DSORG=POU,\n //             UNIT=SYSDA,SPACE=(TRK,(1,,1))\n //SYSIN    DD  *\n-then the results should resemble:\n0DUMPINFO (ASM 04/21/93 14.16) CENTERIOR JOB 7678  M831CDYN  GO2\n0RELNO DDN     DSN                                         MEM      STA    NDP\n 0001 PGM=*.DD SYS93111.T141625.RA000.M831CDYN.TEMPLOAD    DUMPINFO 01=OLD\n08=KE\n 0002 SYSUDUMP JES2.JOB07678.SO000115                               02=MOD\n04=DE\n 0003 INTRDR   JES2.JOB07678.SO000116                               02=MOD\n04=DE\n 0004 OL#CT#DL SYS93111.T141625.RA000.M831CDYN.TEMPLOAD    DUMPINFO 01=OLD\n10=PA\n 0005 SH#DL#CT SYS93111.T141625.RA000.M831CDYN.TEMPLOAD    DUMPINFO 08=SHR\n04=DE\n 0006 NW#UC#KP SYS93111.T141625.RA000.M831CDYN.JUNK        @#$@#$   04=NEW\n10=PA\n 0007 DUMMY#DA NULLFILE                                             04=NEW\n04=DE\n 0008 SYSLIB   SYS1.MACLIB                                          08=SHR\n08=KE\n 0009          SYS93111.T141625.RA000.M831CDYN.CONCAT      MD#PS#UC 02=MOD\n10=PA\n 000A SYSIN    JES2.JOB07678.SI000106                               04=NEW\n04=DE\n 000B SYSPRINT JES2.JOB07678.SO000117                               02=MOD\n04=DE\n0LST-INDICATE LAST: 80,LAST.\n STA - DSET STATUS: 01,=OLD; 02,=MOD; 04,=NEW; 08,=SHR.\n NDP - NORMAL DISP: 01,=UNC; 02,=CAT; 04,=DEL; 08,=KEE; 10,=PAS.\n CDP - COND\"L DISP: 01,=UNC; 02,=CAT; 04,=DEL; 08,=KEE; 10,=PAS.\n ORG - ORGANIZATION: 0004,=TR ; 0008,=VSA; 0020,=TQ ; 0040,=TX ; 0080,=GS ;\n0200\n ORG - ORGANIZATION: 2000,=DA ; 2100,=DAU; 4000,=PS ; 4100,=PSU; 8000,=IS ;\n8100\n TYP - TYPE: 80,=DUMM; 40,=TERM; 20,=SYSI; 10,=SYSO.\n ATT - BIT 0=PERM'LY CONCAT'D; BIT 1=IN USE; BIT 2=PERM'LY ALLOCATED; BIT\n3=CONV\n1/*\n //* REFER M831.SOMOS.TEXT(CECDYN) AS OF 21-APR-1993 AT 16:45\n //\n./ ENDUP\n/*\n//MACROS.SYSIN DD *\n./       ADD   NAME=BREAK\n         MACRO ,\n&NAME    BREAK ,\n.* DATE.     28-JUL-1989\n.* REMARKS.  THIS MACRO WORKS WITH THE MACROS WRITTEN BY DON HIGGINS,\n.*          FOUND ON FILE 078 OF SHARE MVS GROUP MODS TAPE, V29 (04/84)\n.*  SEE CASE,DOCASE,DOMACRO,EQUBC,ELSE,ELSEIF,ESAC,ESACOD,FI,IF,OD;\n.*  AND CONTINUE.\n.***************\n.* NOTE -- THIS MACRO WILL ONLY WORK WHEN IT IS IN A ONE-LEVEL IF\n.*        INSIDE A DO-LOOP -- FOR INSTANCE,\n.*                     DO UNTIL,(...CONDITION...)\n.*                       ...\n.*                       IF (..OTHER.CONDITION..)\n.*                         BREAK\n.*                       FI\n.*                       ...\n.*                     OD\n.*\n.* (THIS RESTRICTION IS BECAUSE THE DO MACRO AND THE IF MACRO\n.*  USE THE SAME ARRAY, &ELSE(10), TO STORE THEIR INFORMATION.\n.*  SOMEDAY WE'LL SPLIT THEM, AND THEN YOU CAN CODE BREAK ANYWHERE.)\n.***************\n         GBLA  &DO(10),&DOSEQ(10),&DOLVL,&DOLAB\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n         LCLA &LCLA\n&LCLA    SETA  &LEVEL-1\n&NAME    B     IF0&ELSE(&LCLA)     EXIT FROM INNERMOST ENCLOSING LOOP\n         MEND  ,\n./       ADD   NAME=CECDYN\n         MACRO ,                                                      1\n&NAME    CECDYN &VERB=,&FLG11=,&FLG21=,&FLG22=,&TEXT=,&PREFIX=,&MF=I, 0X\n               &LIST=Y,                                                X\n               &POS1,&POS2,&POS3,&POS4,&POS5,&POS6,&POS7,&POS8,&POS9,  X\n               &POS10\n.* NOTE -- ASA CARRIAGE CONTROL CHARACTERS IN COLUMN 71 >>>>>>>>>>>>>>0\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70\n.*\n.* MACRO NAME = CECDYN\n.*\n.* (C) COPYRIGHT CENTERIOR ENERGY CORPORATION 1988,1991\n.*\n.* FUNCTION = BUILD PARAMETER LIST FOR CALL TO DYNALLOC MACRO (SVC99)\n.*\n.*  THIS MACRO PROCESSES DIFFERENTLY THAN IBM-SUPPLIED MACROS, BECAUSE\n.* IT GENERATES A DSECT FOR ITS PARAMETER LIST, AND ALL MOVES INTO THE\n.* PARAMETER LIST ARE DONE USING THE NAMES DEFINED IN THE DSECT.\n.*\n.* IF &PREFIX IS SPECIFIED, SAVE IT IN GLOBAL &CEC#P (3 CHARS OR LESS)\n.*                          ELSE GENERATE A UNIQUE 3-CHARACTER &CEC#P.\n.* IF MF=E, THEN &PREFIX COULD REPEAT A PREVIOUSLY-SPECIED &PREFIX\n.*          ELSE &PREFIX MUST BE UNIQUE.\n.*\n.* FURTHER PROCESSING IS DONE IN MULTIPLE PASSES:\n.*   IF MF=L, 1 PASS -- CREATE DC.S (DEFINE CONSTANT) FOR ALL OPERANDS\n.*                      WITH SUPPLIED VALUES FOR NON-REGISTER OPERANDS\n.*                      AND WITH VALUES OF 0 FOR REGISTER OPERANDS;\n.*            AND MEXIT.\n.*   IF MF=I, 2 PASSES -- 1ST PASS EXACTLY LIKE MF=L;\n.*                        2ND PASS, MOVE REGISTER OPERANDS TO STORAGE;\n.*            AND MEXIT.\n.*   IF MF=E, 2 PASSES -- 1ST PASS, DEFINE &CEC#P.DSECT, IF VALUE OF\n.*                        &PREFIX WAS NOT ENCOUNTERED BEFORE;\n.*                     -- 2ND PASS, MOVE ALL OPERANDS TO STORAGE,\n.*                        BOTH REGISTER AND NON-REGISTER;\n.*            AND MEXIT.\n.*\n.*  THE VALUES THE USER CAN CODE FOR VERB,FLG11,FLG21,FLG22 ARE THE\n.* NAMES FROM MACRO IEFZB4D0, MINUS THE PREFIX 'S99'.  THE VALUES ARE\n.* NOT CHECKED, BUT INCORRECT VALUES WILL CAUSE ASSEMBLY ERRORS\n.* BECAUSE THEN THE GENERATED NAMES ARE NOT DEFINED BY IEFZB4D0.\n.*  THE ADVANTAGE OF NOT CHECKING IS THAT, IF IBM DEFINES NEW VALID\n.* VALUES IN MACRO IEFZB4D0, NO UPDATE OF THIS MACRO IS NECESSARY TO\n.* RECOGNIZE AND PROCESS THE NEW VALUES.\n.*  AS OF 14-FEB-1991, VALID VALUES DEFINED IN IEFZB4D0 ARE:\n.* VERB COULD BE AL/UN/CC/DC/RI/DN/IN (CHOOSE ONLY ONE).\n.* FLG11 COULD BE ONCNV, NOCNV, NOMNT, JBSYS, CNENQ.\n.* FLG21 COULD BE WTVOL,WTDSN,NORES,WTUNT,OFFLN,TIONQ,CATLG,MOUNT.\n.* FLG22 COULD BE UDEVT, PCINT, DYNDI.\n.* FOR THE FLG.S, SPECIFY MULTIPLE VALUES WITHIN PARENTHESES.\n.*\n.*  TEXT UNITS ARE SPECIFIED IN THE FORM (KEY,<(VALUE0<,VALUE1...>)>).\n.* IF A TEXT UNIT KEY IS SUPPLIED FOR A VERB FOR WHICH IT IS NOT\n.* VALID, IT IS NOT CHECKED BY THIS MACRO, BUT IT CAUSES AN ASSEMBLY\n.* ERROR BECAUSE THEN THE GENERATED KEY NAME IS NOT DEFINED BY\n.* IEFZB4D2.\n.*  EACH KEY NAME IS 'D' FOLLOWED BY THE 2-CHAR VERB NAME, FOLLOWED\n.* BY THE TEXT UNIT NAME.\n.*\n.*                                                                    -\n.* EXAMPLE OF CALLING SEQUENCE:\n.*         CECDYN PREFIX=X01,MF=(E,WORKAREA),                       X\n.*               VERB=AL,FLG11=(ONCNV,NOMNT),                       X\n.*               TEXT=((DDNAM,DSCL8),(SYSOU,'A'),RTORG)\n.* IF ANY TEXT UNITS SHOULD RETURN VALUES, THE VALUES WILL BE FOUND\n.* IN FIELDS LABELLED WITH THE 3 CHARACTERS SPECIFIED BY &PREFIX,\n.* PLUS THE TEXT UNIT'S NAME.  THE ABOVE CALL WILL DEFINE ORDINARY\n.* LABEL X01RTORG.\n.*\n.*   IF &PREFIX IS REPEATED ACROSS CALLS, THE DSECT IS NOT DUPLICATED,\n.* BUT THE EXACT SAME TEXT UNITS MUST BE SPECIFIED AS WERE ON THE\n.* ORIGINAL CALL.  (OR, AT LEAST, NO TEXT UNITS THAT DID NOT APPEAR\n.* IN THE ORIGINAL CALL.  THAT IS, FEWER COULD BE SPECIFIED.)  THE\n.* FLAG FIELDS CAN BE DIFFERENT THAN ON THE ORIGINAL CALL.\n.*\n.* GLOBALS\n         GBLA  &CEC#CMT1COL  DEFAULT COLUMN FOR COMMENT 1 FIELD\n         GBLA  &CEC#CMT2COL  DEFAULT COLUMN FOR COMMENT 2 FIELD\n         GBLA  &CECCMT1COL   CURRENT COLUMN FOR COMMENT 1 FIELD\n         GBLA  &CECCMT2COL   CURRENT COLUMN FOR COMMENT 2 FIELD\n         GBLC  &CEC#CMT2VAL  TEXT AT RIGHT-HAND END OF GENERATED STMTS\n         GBLC  &CEC#DBG#HDR  TEXT AT LEFT-HAND OF DEBUGGING MNOTES\n         GBLB  &CEC#DEBUG    Q. ISSUE MSG.S ABOUT INTERNAL PROCESSING?\n         GBLA  &CEC#FLAG(5)  CONTROLS MULTIPLE PASSES WITHIN .COMMON\n         GBLB  &CEC#KEYDONE  Q. DONE RECOGNIZING TEXT UNIT?\n         GBLB  &CEC#NEWP     Q. WE HAD TO ADD &CEC#P TO &CEC#PTBL?\n         GBLB  &CEC#NOT1ST   Q. HAS CECDYN EVER BEEN CALLED?\n         GBLC  &CEC#P        3-CHAR VALUE USED IN GENERATED CODE\n         GBLA  &CEC#PMAX     MAXIMUM ENTRIES SAVED IN &CEC#PTBL(100)\n         GBLC  &CEC#PTBL(100) SAVES ALL UNIQUE &CEC#P.S EVER SEEN\n         GBLB  &CEC#PUSHED   Q. DO WE NEED TO POP PRINT AT MEXIT?\n         GBLA  &CEC#SYSNDX   HOW MANY TIMES CECDYN HAS BEEN CALLED\n         GBLB  &CEC#XLAT     Q. TABLE CODED IN &POS9 OF .DOKEY CALL?\n         GBLC  &CEC#3CH      UNIQUE, GENERATED INTERNALLY\n.* LOCALS\n         LCLA  &I,&J,&LCLA,&LCLA2,&LCLA3\n         LCLA  &I1,&I10,&IIX\n         LCLC  &KEY,&VALUE\n         LCLB  &LCLB,&LCLB1\n         LCLC  &LBL,&OPR,&OPD,&CMT\n         LCLC  &LCLC,&LCLC2,&LCLC3\n         LCLC  &DUP,&TYP,&LGH,&VAL\n         LCLA  &DV,&LV\n         LCLC  &DX,&LX,&VV\n.*\n&NX      SETC  '&SYSNDX'               DEFINE SHORTER NAME FOR LATER\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n         AIF   (&CEC#NOT1ST).NOT1STA\n         MNOTE '* MACRO CECDYN, LAST CHANGE 14-JAN-1993 11.31'\n.* CHANGE LOG: (NEWEST CHANGE ON TOP)\n.* 14-JAN-1993  L.SOMOS  AFTER .CLEAR, CHECK FOR '*' TO SET HI-BIT.\n.* 14-MAR-1991  L.SOMOS  CORRECT PROCESSING OF REGISTER OPERANDS.\n.NOT1STA ANOP  ,\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.*\n         AIF   (&CEC#NOT1ST).NOT1STB\n.* FOLLOWING PROCESSING DONE ONLY ONCE PER SOURCE MODULE\n.*\n&CEC#CMT1COL SETA 33         COLUMN OF COMMENTS ON GENERATED LINES\n&CEC#CMT2COL SETA 63         COLUMN OF COMMENTS ON GENERATED LINES\n&CEC#DEBUG SETB 0      TURN OFF\n.* TURN ON BY CALLING WITH ONLY 1 POSITIONAL PARAMETER, DEBUG\n.*\n&CEC#NOT1ST SETB 1           ABOVE PROCESSING NEVER REPEATED AGAIN\n.NOT1STB ANOP  ,\n.*\n.* THIS MUST COME AFTER .NOT1STB:\n         AIF   (0 NE N'&SYSLIST).SUBROUT   GO CHECK SUBROUTINE CALLS\n.* ONLY KEYWORD PARMS ARE USED IN EXTERNAL CALLS, NO POSITIONAL PARMS.\n.* POSITIONAL PARMS ARE ONLY USED IN RECURSIVE INNER MACRO SELF-CALLS.\n.*\n&CEC#SYSNDX SETA 1+&CEC#SYSNDX    COUNT NON-SUBROUTINE CALLS TO CECDYN\n.*\n         MNOTE                                      '* MACRO CECDYN IS X\n               (C) COPYRIGHT CENTERIOR ENERGY CORPORATION 1988,1991   '\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.* SET THE VALUE OF &CEC#3CH\n&Q1      SETA  (&CEC#SYSNDX-1)/36      1ST QUOTIENT\n&R1      SETA  (&CEC#SYSNDX-1)-36*&Q1  1ST REMAINDER, FOR 3RD CHAR\n&Q2      SETA  &Q1/36                  2ND QUOTIENT\n&R2      SETA  &Q1-36*&Q2              2ND REMAINDER, FOR 2ND CHAR\n&Q3      SETA  &Q2/26                  3RD QUOTIENT\n&R3      SETA  &Q2-26*&Q3              3RD REMAINDER, FOR 1ST CHAR\n.* R1 AND R2 ARE ALWAYS 0 THROUGH 35   (1+&R? IS ALWAYS 1 THRU 36)\n.* R3 IS ALWAYS 0 THROUGH 25       (10+1+&R3 IS ALWAYS 11 THRU 36)\n&LCLC    SETC  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' LENGTH 36\n&CEC#3CH SETC  '&LCLC'(10+1+&R3,1).'&LCLC'(1+&R2,1).'&LCLC'(1+&R1,1)\n.* &CEC#3CH IS UNIQUE FOR &CEC#SYSNDX LE 26*36*36 = 33696.\n.* &CEC#3CH ALWAYS BEGINS WITH ALPHA, NEXT 2 CHARS ARE ALPHANUMERIC.\n.* R1 CHANGES MOST QUICKLY, R2 NEXT, AND R3 CHANGES SLOWEST.\n.* &CEC#3CH RANGES THROUGH A00,A01...A09,A0A,A0B...A0Z,\n.*                         A10,A11...A19,A1A,...A1Z, A20...A29, ETC.\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.* SET THE VALUE OF &CEC#P\n         AIF   (T'&PREFIX EQ 'O').SETP WE MUST SUPPLY IT\n&CEC#P   SETC  '&PREFIX'\n         AIF   (K'&PREFIX GE 1 AND K'&PREFIX LE 3).PREFIXD ALL DONE\n&CEC#P   SETC  '&PREFIX'(1,3)          ONLY FIRST THREE CHARACTERS\n         CECDYN MNOTE,'ONLY FIRST 3 CHARACTERS OF PREFIX ARE USED, ',  X\n               '\"&CEC#P\" INSTEAD OF \"&PREFIX\"'\n         AGO   .PREFIXD                  ALL DONE\n.SETP    ANOP  , NO VALUE SPECIFIED, SO CREATE ONE.\n&CEC#P   SETC  '&CEC#3CH'\n.PREFIXD ANOP  ,\n.*\n         AIF   ('&CEC#P' EQ '&CEC#3CH').PEQ3CH\n         CECDYN MNOTE,'*        PREFIX=&PREFIX WAS SPECIFIED -- ',     X\n               'ELSE, PREFIX WOULD HAVE BEEN SET TO \"',&CEC#3CH,       X\n               '\", GENERATED FROM CEC#SYSNDX=&CEC#SYSNDX..'\n.PEQ3CH  ANOP  ,\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.* SAVE &CEC#P IN &CEC#PTBL\n&CEC#NEWP SETB 0                       CLEAR FLAG\n&I       SETA  1\n.NEXTI01 ANOP  ,\n         AIF   ('&CEC#PTBL(&I)' EQ '&CEC#P').OLDP YES, WE FOUND IT\n.ADVI01  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE &CEC#PMAX).NEXTI01\n.* OK, IT HAS NEVER BEEN SEEN BEFORE\n&CEC#NEWP SETB 1                       SET FLAG FOR LATER CHECKING\n&CEC#PMAX SETA &CEC#PMAX+1             INCREASE COUNTER\n&CEC#PTBL(&CEC#PMAX) SETC '&CEC#P'     PLACE INTO TABLE\n.OLDP    ANOP  ,\n.* NOTE - THE ABOVE CODE DOES A SUPERFLUOUS COMPARISON WHEN\n.*       &CEC#PMAX==0, BUT THIS DOES NOT AFFECT CORRECT PROCESSING.\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.* CHECK &LIST PARAMETER FOR ERRORS.\n         AIF   ('&LIST' EQ 'YES' OR '&LIST' EQ 'NO').LISTOK\n         AIF   ('&LIST' EQ 'Y' OR '&LIST' EQ 'N').LISTOK\n         MNOTE 12,'LIST=&LIST INVALID, LIST=YES ASSUMED'\n.LISTOK  ANOP  ,\n         AIF   ('&LIST' EQ 'NO').LISTNO\n         AIF   ('&LIST' EQ 'N').LISTNO\n         AGO   .LISTEX\n.LISTNO  ANOP  ,\n         AIF   (&CEC#PUSHED).PUSHED\n         PUSH  PRINT         PUSH PRINT\n&CEC#PUSHED SETB 1\n.PUSHED  ANOP  ,\n         PRINT OFF           LIST=NO WAS REQUESTED\n.LISTEX  ANOP  ,\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.* CHECK &MF PARAMETER FOR ERRORS.\n         AIF   ('&MF' EQ '').MFOK\n         AIF   ('&MF' EQ 'L' OR '&MF' EQ 'I').MFOK\n         AIF   ('&MF(1)' EQ 'E').MFOK\n         MNOTE 12,'MF=&MF INVALID, NORMAL FORM ASSUMED'\n.MFOK    ANOP  ,\n&LCLC    SETC  'CECDYN -- SECOND PARAM REQUIRED FOR MF=E'\n         AIF   (N'&MF LT 2 AND ('&MF(1)' EQ 'E')).ERRMAIN\n&LCLC    SETC  'CECDYN -- TOO MANY PARAMS FOR MF'\n         AIF   (N'&MF GT 2 AND ('&MF(1)' EQ 'E')).ERRMAIN\n         AIF   ('&MF(1)' EQ 'L').TYPEL\n         AIF   ('&MF(1)' EQ 'E').TYPEE\n         AGO   .TYPEI              ASSUME NORMAL FORM\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.ERRMAIN MNOTE '&LCLC'       ISSUE MESSAGE AND EXIT\n         AGO   .MEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.MEXIT   ANOP  ,             USE THIS EXIT FROM MAINLINE\n         AIF   (NOT &CEC#PUSHED).NOPOP1 THEN WE DON'T NEED TO UN-DO IT.\n         POP   PRINT\n&CEC#PUSHED SETB 0\n.NOPOP1  ANOP  ,\n&CEC#DEBUG SETB 0      TURN OFF\n         MEXIT ,\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.*\n.TYPEI   ANOP  , NORMAL FORM\n         CECDYN DEBUG,.TYPEI SAVE HEADING FOR DEBUG MESSAGES\n         CNOP  0,4           ALIGN LIST TO FULLWORD\n         BAS   1,IGX&NX      BRANCH AROUND LIST, POINT REG1 TO LIST\n&CEC#FLAG(1) SETA 1,0,0,0,1  YES DC, NO DS, NO REG, NO MOVES, COMMON1\n         AGO   .COMMON\n.COMMON1 ANOP  ,\nIGX&NX   DS    0H            BRANCHED AROUND LIST\n&CEC#FLAG(1) SETA 0,0,1,0,2  NO DC, NO DS, YES REG, NO MOVES, COMMON2\n         AGO   .COMMON\n.COMMON2 ANOP  ,\n         AGO   .MEXIT\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.TYPEL   ANOP  , LIST FORM\n         CECDYN DEBUG,.TYPEL SAVE HEADING FOR DEBUG MESSAGES\n&CEC#FLAG(1) SETA 1,0,0,0,3  YES DC, NO DS, NO REG, NO MOVES, COMMON3\n         AGO   .COMMON\n.COMMON3 ANOP  ,\n         AGO   .MEXIT\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.TYPEE   ANOP  , EXECUTE FORM\n         CECDYN DEBUG,.TYPEE SAVE HEADING FOR DEBUG MESSAGES\n.*\n.* CREATE A DSECT:\n&CEC#FLAG(1) SETA 0,1,0,0,4  NO DC, YES DS, NO REG, NO MOVES, COMMON4\n         AGO   .COMMON\n.COMMON4 ANOP ,\n.*\n         AIF   ('&MF(2)'(1,1) EQ '('             AND                   X\n               '&MF(2)'(K'&MF(2),1) EQ ')').USEREG\n&NAME    LA    1,&MF(2)                LOAD ADDRESS OF PARAMETER LIST\n         AGO   .REG1SET\n.*\n.USEREG  ANOP  ,                       IF A REGISTER WAS SPECIFIED\n&LCLC    SETC  '&MF(2)'(2,K'&MF(2)-2)  REGISTER NAME (W/O PARENS)\n         AIF   ('&LCLC' EQ '1').GENDS0H\n&NAME    LR    1,&LCLC                 LOAD PARAMETER LIST ADDRESS\n         AGO   .REG1SET\n.*\n.GENDS0H ANOP  ,\n&NAME    DS    0H                      REG 1 CONTAINS LIST ADDRESS\n         AGO   .REG1SET\n.*\n.REG1SET ANOP  ,\n         USING &CEC#P.DSECT,1          REGISTER 1 POINTS TO DSECT\n.*\n&CEC#FLAG(1) SETA 0,0,1,1,5  NO DC, NO DS, YES REG, YES MOVES, COMMON5\n         AGO   .COMMON\n.COMMON5 ANOP  ,\n         DROP  1\n.*\n         AGO   .MEXIT\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.*\n.COMMON  ANOP  , GENERATE STRUCTURE OF PARAMETER LIST\n.* THIS IS AN AGO-TYPE INTERNAL ROUTINE --\n.* IT EXITS WITH THE STATEMENT:            AGO .COMMON&CEC#FLAG(5)\n         CECDYN DEBUG,'START .COMMON, RETURN INDEX=&CEC#FLAG(5); ',    X\n               'FLAGS=&CEC#FLAG(1),&CEC#FLAG(2),',                     X\n               '&CEC#FLAG(3),&CEC#FLAG(4).'\n.* .COMMON IS CALLED WITH FLAGS 1,0,0,0 -- JUST &CEC#FLAG(1),\n.*                           OR 0,1,0,0 -- JUST &CEC#FLAG(2),\n.*                           OR 0,0,1,0 -- JUST &CEC#FLAG(3),\n.*                           OR 0,0,1,1 -- WITH &CEC#FLAG(3) AND (4).\n.* IF &CEC#FLAG(1), MAKE DC.S FOR ALL OP.S, WITH ZEROS FOR REG. OP.S\n.* IF &CEC#FLAG(2), MAKE DS.S FOR ALL OP.S, WITH ZEROS FOR ALL OP.S\n.* IF &CEC#FLAG(3), THEN MOVE ONLY OPERANDS WHICH CANNOT BE GENERATED\n.*               IN DC.S (REGISTER OPERANDS, AND SYMBOLIC OPERANDS\n.*               FOR CONSTANTS OF TYPES WHICH REQUIRE QUOTES.)\n.* IF &CEC#FLAG(4), THEN MOVE OTHER OPERANDS (LITERALS, ACONS, NULLS)\n.*\n.*                                                                    -\n         AIF   (NOT &CEC#FLAG(1) AND NOT &CEC#FLAG(2)).NOEQU1\n         AIF   (NOT &CEC#NEWP).COMEXIT SKIP -- ASSUME ALREADY DONE.\n         CECDYN DEBUG,'NEWP=1, GENERATE DSECT'\n         SPACE 2\n&LCLC    SETC '&CEC#P.ORG'\n         AIF   (&CEC#FLAG(1)).ORGDC\n         AIF   (&CEC#FLAG(2)).ORGDSCT\n         MNOTE 16,'SEVERE INTERNAL ERROR'\n         MNOTE 'CEC#FLAG(1)=&CEC#FLAG(1) CEC#FLAG(2)=&CEC#FLAG(2)'\n&CEC#DEBUG SETB 1      TURN ON\n         AGO   .MEXIT\n.ORGDC   ANOP  ,\n&LCLC2   SETC  'DC'\n&LCLC3   SETC  '0F''0'''\n         AGO   .EQU1\n.ORGDSCT ANOP  ,\n&LCLC2   SETC  'DSECT'\n&LCLC3   SETC  ''\n.EQU1    ANOP  ,\n&LCLC    &LCLC2 &LCLC3\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n*                SVC 99 INPUT REQUEST BLOCK\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.NOEQU1  ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* BUILD &LCL#FLG11, &LCLFLG21, &LCLFLG22 BY SUMMING BIT MASKS:\n.*..+....1....+....2                                                  0\n.*\n&LCL#FLG11 SETC '0'\n         AIF   (K'&FLG11 EQ 0).FLG11ZZ\n&I       SETA  1\n&LCL#FLG11 SETC 'S99&FLG11(&I)'\n         AIF   (N'&FLG11 LE &I).FLG11XX\n.FLG11QQ ANOP  ,\n&I       SETA  &I+1\n&LCL#FLG11 SETC '&LCL#FLG11.+S99&FLG11(&I)'\n         AIF   (N'&FLG11 GT &I).FLG11QQ\n.FLG11XX ANOP  ,\n.FLG11ZZ ANOP  ,\n.*..+....1....+....2                                                  0\n.*\n&LCL#FLG21 SETC '0'\n         AIF   (K'&FLG21 EQ 0).FLG21ZZ\n&I       SETA  1\n&LCL#FLG21 SETC 'S99&FLG21(&I)'\n         AIF   (N'&FLG21 LE &I).FLG21XX\n.FLG21QQ ANOP  ,\n&I       SETA  &I+1\n&LCL#FLG21 SETC '&LCL#FLG21.+'.'S99&FLG21(&I)'\n         AIF   (N'&FLG21 GT &I).FLG21QQ\n.FLG21XX ANOP  ,\n.FLG21ZZ ANOP  ,\n.*..+....1....+....2                                                  0\n.*\n&LCL#FLG22 SETC '0'\n         AIF   (K'&FLG22 EQ 0).FLG22ZZ\n&I       SETA  1\n&LCL#FLG22 SETC 'S99&FLG22(&I)'\n         AIF   (N'&FLG22 LE &I).FLG22XX\n.FLG22QQ ANOP  ,\n&I       SETA  &I+1\n&LCL#FLG22 SETC '&LCL#FLG22.+'.'S99&FLG22(&I)'\n         AIF   (N'&FLG22 GT &I).FLG22QQ\n.FLG22XX ANOP  ,\n.FLG22ZZ ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* (SEE .CREAT SUBROUTINE FOR MEANING OF PARAMETERS)\n.*\n&CECCMT1COL SETA &CEC#CMT1COL COMMENT 1 FIELD'S COLUMN\n&CECCMT2COL SETA &CEC#CMT2COL COMMENT 2 FIELD'S COLUMN\n.* (EACH CALL TO .CREAT DOES ABOVE SETA.S, JUST BEFORE EXITING)\n.*\n&CEC#P.RBP   CECDYN CREAT,0,F\n&CEC#P.RBPTR CECDYN CREAT,,A,*,A(&CEC#P.RB),'REQUEST BLOCK POINTER'\n.*                 (*=HIGH BIT ON)\n&CEC#P.RB    CECDYN CREAT,0,F,,,'REQUEST BLOCK'\n&CEC#P.RBLN  CECDYN CREAT,,A,1,&CEC#P.RBEND-&CEC#P.RB,                 X\n               'LENGTH OF REQUEST BLOCK'\n&CEC#P.VERB  CECDYN CREAT,,A,1,S99VRB&VERB,'VERB CODE'\n&CEC#P.FLAG1 CECDYN CREAT,0,C,2,,FLAGS\n&CEC#P.FLG11 CECDYN CREAT,,A,1,&LCL#FLG11,'FIRST FLAGS BYTE'\n&CEC#P.FLG12 CECDYN CREAT,,A,1,0,'SECOND BYTE OF FLAGS'\n&CEC#P.RSC   CECDYN CREAT,0,C,4,,'REASON CODE FIELDS'\n&CEC#P.ERROR CECDYN CREAT,,X,2,0,'ERROR REASON CODE'\n&CEC#P.INFO  CECDYN CREAT,,X,2,0,'INFORMATION REASON CODE'\n&CEC#P.TXTPP CECDYN CREAT,,A,,A(&CEC#P.TUPL),                          X\n               'ADDR OF LIST OF TEXT UNIT PTRS'\n&CEC#P.RSV01 CECDYN CREAT,,F,,0,RESERVED\n&CEC#P.FLAG2 CECDYN CREAT,0,C,4,,'FLAGS FOR AUTHORIZED FUNCTIONS'\n&CEC#P.FLG21 CECDYN CREAT,,A,1,&LCL#FLG21,'FIRST BYTE OF FLAGS'\n&CEC#P.FLG22 CECDYN CREAT,,A,1,&LCL#FLG22,'SECOND BYTE OF FLAGS'\n&CEC#P.FLG23 CECDYN CREAT,,A,1,0,'THIRD BYTE OF FLAGS'\n&CEC#P.FLG24 CECDYN CREAT,,A,1,0,'FOURTH BYTE OF FLAGS'\n&CEC#P.RBEND CECDYN CREAT,0,,0,,'END MARKER'\n.*                                                                    1\n         AIF   (NOT &CEC#FLAG(1) AND NOT &CEC#FLAG(2)).NOEQU2\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n* SVC 99 TEXT UNIT POINTER LIST\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.NOEQU2  ANOP  ,\n.*\n&CEC#P.TUPL  CECDYN CREAT,0,F,,,'TEXT UNIT POINTER LIST'\n&I       SETA   1\n.NEXTPTR ANOP  ,\n&I1      SETA  &I-10*(&I/10)           1'S DIGIT OF &I\n&I10     SETA  (&I/10)-10*(&I/100)     10'S DIGIT OF &I\n&IIX     SETA  1+3*(&I1*(&I10-1)/(&I10-1)) IGNORE &I1 IF (&I10-1) EQ 0\n&ITH     SETC  'TH ST ND RD TH TH TH TH TH TH '(&IIX,2) 0TH, 1ST, ETC.\n&HIBIT   SETC  '*'                     SET FLAG TO SET HIGH BIT\n         AIF   (&I EQ N'&TEXT).LASTPTR\n&HIBIT   SETC  ''                      RESET FLAG TO SET HIGH BIT\n.LASTPTR ANOP  ,\n&LCLC3   SETC  'A(&CEC#P.TU&I)'\n&LCLC4   SETC  '&TEXT(&I,1)'\n         AIF   (T'&TEXT(&I,1) NE 'O').NORMAL1 NOT- SKIPPED UNIT\n&LCLC3   SETC  '0'\n&LCLC4   SETC  '(OMITTED)'\n.NORMAL1 ANOP  ,\n.* ACTUAL CODE GENERATION:                                            -\n&CEC#P.PTR&I CECDYN CREAT,,A,&HIBIT,                                   X\n               &LCLC3,                                                 X\n               '&I&ITH TEXT UNIT POINTER, &LCLC4'\n.***************************\n.* THE EFFECT OF THE ABOVE CODE IS:\n.* &CEC#P.PTR&I CECDYN CREAT,,A,&HIBIT,                                X\n               A(&CEC#P.&TEXT(&I,1).-(S99TUPAR-S99TUNIT)),             X\n               '&I&ITH TEXT UNIT POINTER, &TEXT(&I,1)'\n.***************************\n.ADVPTR  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE N'&TEXT).NEXTPTR\n.*\n.*                                                                    1\n         AIF   (NOT &CEC#FLAG(1) AND NOT &CEC#FLAG(2)).NOEQU3\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n* SVC 99 TEXT UNITS\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.NOEQU3  ANOP  ,\n.*\n.*   BEGIN A HUGE LOOP, AROUND ALL SELF-CALLS TO .DOKEY SUBROUTINE.\n.* THIS LOOP USES &I AS AN INDEX TO STEP THROUGH ALL SUBLIST ENTRIES\n.* SPECIFIED IN THE TEXT= PARAMETER IN THE OUTER CALL TO CECDYN.\n.*\n&I       SETA   1\n.NEXTI09 ANOP  ,\n.*\n&I1      SETA  &I-10*(&I/10)           1'S DIGIT OF &I\n&I10     SETA  (&I/10)-10*(&I/100)     10'S DIGIT OF &I\n&IIX     SETA  1+3*(&I1*(&I10-1)/(&I10-1)) IGNORE &I1 IF (&I10-1) EQ 0\n&ITH     SETC  'TH ST ND RD TH TH TH TH TH TH '(&IIX,2) 0TH, 1ST, ETC.\n&KEY     SETC  'D&VERB.&TEXT(&I,1)'\n.*\n         AIF   (T'&TEXT(&I,1) EQ 'O').ADVI09  SKIPPED UNIT\n.*\n         AIF   (T'&TEXT(&I,1) NE 'O').NORMAL2 NOT- SKIPPED UNIT\n&KEY     SETC  '(OMITTED)'\n.NORMAL2 ANOP  ,\n.*\n         CECDYN CMT2,        SET &CEC#CMT2VAL (TO BLANKS)\n.*\n&CECCMT1COL SETA &CEC#CMT1COL-6 SHIFT CHARS LEFT, SO 'BEGIN' STANDS OUT\n&CEC#P.TU&I  CECDYN CREAT,0,F,,,'BEGIN &I&ITH TEXT UNIT, &KEY'\n.*\n         AIF   (T'&TEXT(&I,1) EQ 'O').ADVI09  SKIPPED UNIT\n.*\n&CEC#P.KEY&I CECDYN CREAT,,A,2,&KEY,'&I&ITH KEY'\n.*\n&CEC#KEYDONE SETB 0          PREPARE TO SEARCH\n.*\n.*  INFORMATION BELOW IS FROM MVS/XA SPL: SYSTEM MACROS AND FACILITIES\n.* GC28-1150-2.\n.*\n.* (SEE .DOKEY SUBROUTINE FOR MEANING OF PARAMETERS)\n.* DSNAME ALLOCATION TEXT UNITS                                       -\n         AIF   ('&VERB' NE 'AL').AL#DONE\n.*\n.* DDNAME\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDDNAM,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* DSNAME (MUTUALLY EXCLUSIVE WITH DALQNAME, DALIPLTX)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDSNAM,1,C,(1,44)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* PDS MEMBER (REQUIRES DALDSNAM ALSO)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMEMBR,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* DATA SET STATUS (MUTUALLY EXCLUSIVE WITH DALSYSOU)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSTATS,1,A,1,              X\n               ((OLD,X'01'),(MOD,X'02'),(NEW,X'04'),(SHR,X'08'),       X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* NORMAL DISPOSITION (MUTUALLY EXCLUSIVE WITH DALSYSOU)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALNDISP,1,A,1,              X\n               ((UNCATLG,X'01'),(CATLG,X'02'),                         X\n               (DELETE,X'04'),(KEEP,X'08'),                            X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* CONDITIONAL DISPOSITION (MUTUALLY EXCLUSIVE WITH DALSYSOU)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCDISP,1,A,1,              X\n               ((UNCATLG,X'01'),(CATLG,X'02'),                         X\n               (DELETE,X'04'),(KEEP,X'08'),                            X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* UNIT OF DALPRIME, DALSECND WILL BE TRACKS\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALTRK,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.* UNIT OF DALPRIME, DALSECND WILL BE CYLINDERS\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCYL,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.* AVERAGE BLOCK LENGTH TO USE FOR UNIT OF DALPRIME, DALSECND\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBLKLN,1,A,3,,'<=65535'\n         AIF   (&CEC#KEYDONE).ADVI09\n.* PRIMARY SPACE QUANTITY\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPRIME,1,A,3\n         AIF   (&CEC#KEYDONE).ADVI09\n.* SECONDARY SPACE QUANTITY\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSECND,1,A,3\n         AIF   (&CEC#KEYDONE).ADVI09\n.* NUMBER OF DIRECTORY BLOCKS FOR A PDS\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDIR,1,A,3\n         AIF   (&CEC#KEYDONE).ADVI09\n.* RELEASE UNUSED SPACE AT CLOSE TIME\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRLSE,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.* FORMAT OF ALLOCATED SPACE\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSPFRM,1,A,1,              X\n               ((ALX,X'02'),  USE DIFFERENT AREAS OF CONTIGUOUS SPACE  X\n               (MXIG,X'04'),      MAXIMUM CONTIGUOUS SPACE IS REQUIRED X\n               (CONTIG,X'08'),    SPACE MUST BE CONTIGUOUS             X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* ALLOCATE IN WHOLE CYLINDERS\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALROUND,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.* VOLUME SERIAL NUMBERS (MUTUALLY EXCLUSIVE WITH DALSYSOU, DALVLRDS)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALVLSER,(1,6),C,6\n         AIF   (&CEC#KEYDONE).ADVI09\n.* ASSIGN USE ATTRIBUTE OF PRIVATE (MUTUALLY EXCLUSIVE WITH DALSYSOU)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPRIVT,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.* VOL-SEQ WITHIN MULTI-VOLUME DATA SET (MUT.EXCL.W/DALSYSOU)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALVLSEQ,1,A,2,,'<=255'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALVLCT,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALVLRDS,1,C,(1,44)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUNIT,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUNCNT,1,A,1,,'<=59'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPARAL,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSYSOU,(0,1),C,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSPGNM,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSFMNO,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALOUTLM,1,A,3\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCLOSE,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCOPYS,1,1,A\n         AIF   (&CEC#KEYDONE).ADVI09\n.* LABEL TYPE OF VOLUME\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALLABEL,1,A,1,              X\n               ((NL,X'01'),  NO LABEL                                  X\n               (SL,X'02'),   IBM STANDARD LABELS                       X\n               (NSL,X'04'),  NON-STANDARD LABELS                       X\n               (SUL,X'0A'),  IBM STANDARD LABEL PLUS USER LABEL        X\n               (BLP,X'10'),  BYPASS LABEL PROCESSING                   X\n               (LTM,X'21'),  CHECK FOR AND BYPASS LEADING TAPE MARK    X\n               (AL,X'40'),   AMERICAN NATIONAL STANDARD LABEL          X\n               (AUL,X'48'),  AL PLUS USER LABEL                        X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDSSEQ,1,A,2,,'<=9999'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPASPR,1,A,1,              X\n               ((PASSWORD,X'10'),(NOPWREAD,X'30'),                     X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALINOUT,1,A,1,              X\n               ((OUT,X'40'),(IN,X'80'),                                X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALEXPDT,1,C,5\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRETPD,1,A,2,,'<=9999'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDUMMY,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFCBIM,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFCBAV,1,A,1,              X\n               ((VERIFY,X'04'),(ALIGN,X'08'),                          X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALQNAME,1,C,(1,17)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALTERM,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUCS,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUFOLD,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUVRFY,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDCBDS,1,C,(1,44)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDCBDD,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSUSER,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSHOLD,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMSVGP,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSSNM,(0,1),C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSSPRM,(1,254),C,(0,67)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPROT,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUSRID,1,A,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBURST,1,A,1,              X\n               ((Y,X'02'),(N,X'04'),(YES,X'02'),(NO,X'04'),            X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCHARS,(1,4),C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCOPYG,(1,8),A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFFORM,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFCNT,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMMOD,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMTRC,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDEFER,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALOUTPT,(1,128),C,(1,26)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* DCB ATTRIBUTE TEXT UNITS                                           -\n.*\n.* BUFFER ALIGNMENT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBFALN,1,A,1,              X\n               ((F,X'01'),   FULLWORD, NOT DOUBLEWORD                  X\n               (D,X'02'),    DOUBLEWORD                                X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* BUFFERING TECHNIQUE\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBFTEK,1,A,1,              X\n               ((D,X'08'),   DYNAMIC                                   X\n               (E,X'10'),    EXCHANGE                                  X\n               (R,X'20'),    RECORD                                    X\n               (S,X'40'),    SIMPLE                                    X\n               (A,X'60'),    RECORD AREA                               X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBLKSZ,1,A,2,,'<=32760'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFIN,1,A,1,,'<=15'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFL,1,A,2,,'<=32760'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFMX,1,A,1,,'<=15'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFNO,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n.* BUFFER OFFSET\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFOF,1,A,1,              X\n               ((L,X'80'),   BLOCK PREFIX IS 4 BYTES, CONTAINS LENGTH  X\n               *),           USER CODES VALUE OF BLOCK PREFIX          X\n               '<=99'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFOU,1,A,1,,'<=15'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFRQ,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFSZ,1,A,2\n         AIF   (&CEC#KEYDONE).ADVI09\n.* PAPER TAPE CODE:\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCODE,1,A,1,               X\n               ((T,X'02'),   TELETYPE 5-TRACK                          X\n               (A,X'04'),    USASCII 8-TRACK                           X\n               (C,X'08'),    NATIONAL CASH REGISTER 8-TRACK            X\n               (B,X'10'),    BURROUGHS 7-TRACK                         X\n               (F,X'20'),    FRIDEN 8-TRACK                            X\n               (I,X'40'),    IBM BCD 8-TRACK                           X\n               (N,X'80'),    NO CONVERSION                             X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* SEND/RECEIVE PRIORITY\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCPRI,1,A,1,               X\n               ((S,X'01'),   SEND PRIORITY                             X\n               (E,X'02'),    EQUAL PRIORITY                            X\n               (R,X'04'),    RECEIVING PRIORITY                        X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* MAGNETIC TAPE DENSITY:\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDEN,1,A,1,                X\n               ((0,X'03'),   200 BPI 7-TRACK                           X\n               (1,X'43'),    556 BPI 7-TRACK                           X\n               (2,X'83'),    800 BPI 7-TRACK OR 9-TRACK                X\n               (3,X'C3'),    1600 BPI 9-TRACK                          X\n               (4,X'D3'),    6250 BPI 9-TRACK                          X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* DATA SET ORGANIZATION\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDSORG,1,A,2,              X\n               ((TCAM3705,X'0004'), TCAM 3705                          X\n               (VSAM,X'0008'), VSAM                                    X\n               (TQ,X'0020'), TCAM MESSAGE QUEUE                        X\n               (TX,X'0040'), TCAM LINE GROUP                           X\n               (GS,X'0080'), GRAPHICS                                  X\n               (PO,X'0200'), PARTITIONED ORGANIZATION                  X\n               (POU,X'0300'), PARTITIONED ORGANIZATION UNMOVABLE       X\n               (MQ,X'0400'), TELECOMMUNICATIONS MESSAGE PROCESSING Q.  X\n               (CQ,X'0800'), DIRECT ACCESS MESSAGE QUEUE               X\n               (CX,X'1000'), COMMUNICATION LINE GROUP                  X\n               (DA,X'2000'), DIRECT ACCESS                             X\n               (DAU,X'2100'), DIRECT ACCESS UNMOVABLE                  X\n               (PS,X'4000'), PHYSICAL SEQUENTIAL                       X\n               (PSU,X'4100'), PHYSICAL SEQUENTIAL UNMOVABLE            X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* ERROR PROCESSING OPTION\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALEROPT,1,A,1,              X\n               ((T,X'10'),   BSAM TESTING                              X\n               (ABE,X'20'),  CAUSE ABNORMAL END OF TASK                X\n               (SKP,X'40'),  SKIP BLOCK CAUSING ERROR                  X\n               (ACC,X'80'),  ACCEPT BLOCK CAUSING ERROR                X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALGNCP,1,A,1,,'<=99'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALINTVL,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALKYLEN,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALLIMCT,1,A,3,,'<=32760'\n         AIF   (&CEC#KEYDONE).ADVI09\n.* ACTUAL OR MAXIMUM LENGTH OF A LOGICAL RECORD, IN BYTES\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALLRECL,1,A,2,              X\n               ((X,X'8000'), LRECL EXCEEDS 32756 (QSAM, BSAM SPANNED)  X\n               *),           (USER MAY CODE VALUE DIRECTLY)            X\n               '<=32760'\n         AIF   (&CEC#KEYDONE).ADVI09\n.* MODE OF OPERATION FOR CARD READER OR PUNCH\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMODE,1,A,1,               X\n               ((E,X'40'),   EBCDIC MODE                               X\n               (ER,X'50'),   EBCDIC, READ COLUMN ELIMINATE MODE        X\n               (EO,X'60'),   EBCDIC, OPTICAL MARK READ MODE            X\n               (C,X'80'),    CARD IMAGE MODE                           X\n               (CR,X'90'),   CARD IMAGE, READ COLUMN ELIMINATE MODE    X\n               (CO,X'A0'),   CARD IMAGE, OPTICAL MARK READ MODE        X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALNCP,1,A,1,,'<=99'\n         AIF   (&CEC#KEYDONE).ADVI09\n.* OPTIONAL SERVICES TO BE PERFORMED\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALOPTCD,1,A,1,              X\n               (+, TRANSLATE + SUM                                     X\n               (R,X'01'), RELATIVE BLOCK ADDRESSING                    X\n               (J,X'01'), SELECT CHARACTER ARRANGEMENT TABLES(3800)    X\n               (T,X'02'), USER TOTALING FACILITY                       X\n               (Z,X'04'), REDUCED TAPE ERR RECOVERY/DIRECT DASD SEARCH X\n               (A,X'08'), DIRECT ADDRESSING                            X\n               (Q,X'08'), TRANSLATE ASCII TO/FROM EBCDIC               X\n               (F,X'10'), FEEDBACK                                     X\n               (H,X'10'), HOPPER-EMPTY EXIT                            X\n               (O,X'10'), ONLINE CORRECTION (OPTICAL READERS)          X\n               (C,X'20'), CHAINED SCHEDULING/TCAM SEGMENT IDENTIFICA'N X\n               (E,X'20'), EXTENDED SEARCH                              X\n               (B,X'40'), DISREGARD EOF RECOGNITION (TAPE)             X\n               (U,X'40'), ALLOW DATA CHECKS CAUSED BY INVALID CHARS    X\n               (W,X'80')) WRITE VALIDITY CHECK/PLACE TCAM MESSAGE IN   X\n                                   AN EIGHT-BYTE FIELD IN THE WORKAREA\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPCIR,1,A,1,               X\n               ((R,X'02'),(N,X'08'),(A,X'20'),(X,X'80'),               X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPCIS,1,A,1,               X\n               ((R,X'01'),(N,X'04'),(A,X'10'),(X,X'40'),               X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPRTSP,1,A,1,              X\n               ((0,X'01'),(1,X'09'),(2,X'11'),(3,X'19'),               X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRECFM,1,A,1,              X\n               (+, TRANSLATE + SUM                                     X\n               (M,X'02'),(R,X'02'),(A,X'04'),(G,X'04'),(S,X'08'),      X\n               (B,X'10'),(D,X'20'),(T,X'20'),(V,X'40'),(F,X'80'),      X\n               (U,X'C0'),                                              X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRSRVF,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRSRVS,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSOWA,1,A,2,,'<=32760'\n         AIF   (&CEC#KEYDONE).ADVI09\n.* STACKER SELECTION\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSTACK,1,A,1,              X\n               ((1,1),(2,2))            ONLY  1  OR  2  IS VALID       X\n                        NO '*' IN &POS9 -- ALL OTHERS HAVE '*' CODED   X\n                        AS LAST ENTRY IN &POS9.\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALTHRSH,1,A,1,,'<=100'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALTRTCH,1,A,1,              X\n               ((C,X'13'),(E,X'23'),(ET,X'2B'),(T,X'3B'),              X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALIPLTX,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDIAGN,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFUNC,1,A,1,               X\n               ((W,X'10'),(WT,X'12'),(WX,X'14'),(WXT,X'16'),           X\n               (P,X'20'),(PW,X'30'),(PWX,X'34'),(PWXT,X'36'),          X\n               (R,X'40'),(RW,X'50'),(RWT,X'52'),(RWX,X'54'),           X\n               (RWXT,X'56'),(RP,X'60'),(RPD,X'68'),(RPW,X'70'),        X\n               (RPWX,X'74'),(RPWXT,X'76'),(RPWD,X'78'),(I,X'80'),      X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFRID,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* NON-JCL DYNAMIC ALLOCATION FUNCTIONS                               -\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPASSW,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPERMA,0\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCNVRT,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRTDDN,1,C,8,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRTDSN,1,C,44,*\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRTORG,1,X,2,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSSREQ,(0,1),C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRTVOL,1,C,6,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSSATT,1,X,1,              X\n               ((*,X'80'))                          CONSTANT X'80'\n         AIF   (&CEC#KEYDONE).ADVI09\n.AL#DONE ANOP  ,\n.* DYNAMIC UNALLOCATION TEXT UNITS                                    -\n         AIF   ('&VERB' NE 'UN').UN#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNDDNAM,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNDSNAM,1,C,(1,44)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNMEMBR,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVDSP,1,A,1,              X\n               ((UNCATLG,X'01'),(CATLG,X'02'),                         X\n               (DELETE,X'04'),(KEEP,X'08'),                            X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNUNALC,0\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNREMOV,0\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVSNH,0\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVCLS,1,C,1\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVSUS,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVSHQ,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.UN#DONE ANOP  ,\n.* DYNAMIC CONCATENATION TEXT UNITS                                   -\n         AIF   ('&VERB' NE 'CC').CC#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DCCDDNAM,(2,16),C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DCCPERMC,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.CC#DONE ANOP  ,\n.* DYNAMIC DECONCATENATION TEXT UNIT                                  -\n         AIF   ('&VERB' NE 'DC').DC#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DDCDDNAM,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n.DC#DONE ANOP  ,\n.* TEXT UNITS FOR REMOVING THE IN-USE ATTRIBUTE BASED ON TASK-ID      -\n         AIF   ('&VERB' NE 'RI').RI#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DRITCBAD,1,A,4\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DRICURNT,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.RI#DONE ANOP  ,\n.* DDNAME ALLOCATION TEXT UNITS                                       -\n         AIF   ('&VERB' NE 'DN').DN#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DDNDDNAM,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DDNRTDUM,1,X,1,*\n         AIF   (&CEC#KEYDONE).ADVI09\n.DN#DONE ANOP  ,\n.* DYNAMIC INFORMATION RETRIEVAL TEXT UNITS                           -\n         AIF   ('&VERB' NE 'IN').IN#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINDDNAM,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINDSNAM,1,C,(1,44)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTDDN,1,C,8,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTDSN,1,C,44,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTMEM,1,C,8,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTSTA,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTNDP,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTCDP,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTORG,1,X,2,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTLIM,1,X,2,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTATT,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTLST,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTTYP,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRELNO,1,X,2,*\n         AIF   (&CEC#KEYDONE).ADVI09\n.IN#DONE ANOP  ,\n.*                                                                    -\n.* TO GET HERE, 1 OF 3:   1. USER KEYED INVALID TEXT KEY NAME\n.*                        2. ERROR IN THIS MACRO\n.*                        3. IBM DEFINED A KEY NOT KNOWN TO THIS MACRO\n&LCLC    SETC  'TEXT UNIT KEY ''''&KEY'''' NOT KNOWN TO THIS MACRO--'\n&LCLC    SETC  '&LCLC.TEXT UNIT KEY SPELLED WRONG, OR ERROR IN CECDYN'\n         MNOTE 12,'&LCLC'\n.*\n.* BOTTOM OF HUGE LOOP\n.ADVI09  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE N'&TEXT).NEXTI09\n.*                                                                    1\n         AIF   (NOT &CEC#FLAG(1) AND NOT &CEC#FLAG(2)).NOEQU4\n         SPACE 1\n         DS    0D                  FILL OUT DATA SECTION\n         SPACE 1\n&LCLC    SETC  '&CEC#P.&CEC#3CH'\n&LCLC.A  EQU   *-&CEC#P.ORG        CALCULATE THE HEX LENGTH\n         ORG   &CEC#P.ORG\n&LCLC2   SETC  '&CEC#P.DSECT'\n&LCLC2   DS    CL(&LCLC.A)         NOW L'&CEC#P.DSECT AVAILABLE\n         SPACE 1\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n         AIF   (NOT &CEC#FLAG(2)).NOEQU4\n         SPACE 1\n&SYSECT. CSECT , RETURN TO CODE\n         AIF   ('&SYSLOC' EQ '&SYSECT').NOEQU4  SKIP IF UNNECESSARY\n&SYSLOC. LOCTR , RETURN TO ORIGINAL LOCATION COUNTER\n.NOEQU4  ANOP  ,\n.*\n.COMEXIT ANOP  ,\n.*\n.* ACTUAL CODE GENERATION:                                            -\n&LCLA    SETA  &CEC#FLAG(5)  FETCH RETURN INDEX\n         AGO   (&LCLA).COMMON1,.COMMON2,.COMMON3,.COMMON4,.COMMON5\n.***************************\n.* THE EFFECT OF THE ABOVE CODE IS:\n.*       AGO   .COMMON&CEC#FLAG(5)\n.***************************\n         MNOTE 16,'SEVERE INTERNAL ERROR'\n         MNOTE 'CEC#FLAG(5)=&CEC#FLAG(5)'\n&CEC#DEBUG SETB 1      TURN ON\n         AGO   .MEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.SUBROUT ANOP  ,                                                      0\n.*\n         AIF   ('&POS1' EQ 'CMT2').CMT2\n         AIF   ('&POS1' EQ 'CREAT').CREAT\n         AIF   ('&POS1' EQ 'DEBUG').DEBUG\n         AIF   ('&POS1' EQ 'DOKEY').DOKEY\n         AIF   ('&POS1' EQ 'MNOTE').MNOTE\n&LCLC    SETC  'CECDYN -- INVALID INTERNAL CALL, \"&POS1\"'\n         AGO   .ERRMAIN\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7-\n.SUBEXIT MEXIT ,             USE THIS EXIT FROM SUBROUTINES           0\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7-\n.CMT2    ANOP  , SELF-CALL INTERNAL ROUTINE -- SET &CEC#CMT2VAL       0\n&CEC#CMT2VAL SETC '&POS2'\n         AGO   .SUBEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7-\n.CREAT   ANOP  , SELF-CALL INTERNAL ROUTINE -- CREATE LINE(S) OF CODE 0\n         CECDYN DEBUG,.CREAT SAVE HEADING FOR DEBUG MESSAGES\n         CECDYN DEBUG,'&NAME CECDYN CREAT,&POS2,&POS3,&POS4,&POS5,\"',  X\n               &POS6,'\"'\n.* IF &CEC#FLAG(1), GENERATE \"DEFINE CONSTANT\" FOR ALL OPERANDS,\n.*        WITH VALUES SPECIFIED BY USER,\n.*        AND VALUES OF 0 FOR OPERANDS SPECIFIED THROUGH REGISTERS\n.* IF &CEC#FLAG(2), GENERATE \"DEFINE STORAGE\" FOR ALL OPERANDS,\n.*        WITH VALUES OF 0 FOR ALL OPERANDS\n.* IF &CEC#FLAG(3), THEN MOVE ONLY OPERANDS WHICH CANNOT BE GENERATED\n.*        IN DEFINE CONSTANTS (REGISTER OPERANDS, AND SYMBOLIC\n.*        OPERANDS FOR CONSTANTS OF TYPES WHICH REQUIRE QUOTES)\n.* IF &CEC#FLAG(4), THEN MOVE OTHER OPERANDS (LITERALS, ACONS, NULLS)\n.*\n.* FORMAT OF .CREAT SELF-CALLS IS:\n.*       CECDYN CREAT,<DUP>,<TYP>,<LGH>,<VAL>,<COMMENT>\n.* ( DUPLICATION FACTOR, FIELD TYPE, LENGTH, NOMINAL VALUE, TEXT )\n.* OPTIONAL <DUP> IS SELF-DEFINING DECIMAL TERM (WHEN NULL, ASSUME 1)\n.*                        (WHEN 0, THEN INTERNALLY FORCE &CEC#FLAG(1)\n.*                        TO ACT LIKE &CEC#FLAG(2)\n.* OPTIONAL <TYP> IS A SINGLE CHARACTER (ASSEMBLER TYPE ATTRIBUTE T' )\n.*                        H=HALFWORD, F=FULLWORD, A=ADDRESS CONSTANT,\n.*                        B=BINARY, C=CHARACTER, X=HEX, <NULL>='EQU *'\n.* OPTIONAL <LGH>IS SELF-DEFINING DECIMAL TERM\n.*                        (WHEN NULL, ASSUME 2 FOR HALFWORD,\n.*                        4 FOR FULLWORD OR ADDRESS CONSTANT, ELSE 0)\n.*          <VAL> VALUE IS ONLY USED WHEN &CEC#FLAG(1)  (THAT IS,\n.*                        WHEN GENERATING \"DEFINE CONSTANT\"S).\n.*                        IT IS REQUIRED WHEN <DUP> NOT 0\n.* OPTIONAL <COMMENT> IS TEXT OF COMMENT TO BE GENERATED\n.*\n.*..+....1....+....2....+....3\n.*\n&DUP     SETC '&POS2'\n&TYP     SETC '&POS3'\n&LGH     SETC '&POS4'\n&VAL     SETC '&POS5'\n&CMT     SETC '&POS6'\n.*\n.* &DUP AND &LGH ARE THE PARAMETERS SPECIFIED ON THE .CREAT SELF-CALL\n.* &DV AND &LV ARE LCLA (NUMERIC) VALUES USED IN INTERNAL PROCESSING\n.* &DX AND &LX ARE LCLC (CHARACTER) VALUES USED IN GENERATING CODE\n.*\n.* &NUL,&LIT,&REG,&ACN ARE LCLB (FLAGS) DESCRIBE THE &VAL SPECIFIED\n.* &VV IS THE NOMINAL VALUE (WITHOUT QUOTES, PARENS, A(, ) )\n.*..+....1....+....2....+....3                                        0\n.*\n.* ANALYSE DUPLICATION FACTOR:\n.* &DUP=''        PRODUCES &DV=1,         &DX=''\n.* &DUP=0         PRODUCES &DV=0,         &DX='0'\n.* &DUP=1         PRODUCES &DV=1,         &DX=''\n.* &DUP=<NUMERIC> PRODUCES &DV=<NUMERIC>, &DX='<NUMERIC>'.\n&DV      SETA  1             SET INITIAL DEFAULTS\n&DX      SETC  ''            SET INITIAL DEFAULTS\n         AIF   (K'&DUP EQ 0).XDUP\n&DV      SETA  &DUP          MUST BE SELF-DEFINING DECIMAL TERM\n         AIF   ('&DUP' EQ '1').XDUP   LEAVE &DX AS ''\n&DX      SETC  '&DUP'\n.XDUP    ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* ANALYSE LENGTH:\n.* &LGH=''        PRODUCES &LV=DEFAULT,   &LX=''\n.*                            (DEFAULT DEPENDS ON DATA TYPE)\n.*                        (WHEN NULL, ASSUME 2 FOR HALFWORD,\n.*                        4 FOR FULLWORD OR ADDRESS CONSTANT, ELSE 0)\n.* &LGH=<NUMERIC> PRODUCES &LV=<NUMERIC>, &LX='L<NUMERIC>'\n&HIBIT   SETB  0\n&LX      SETC  ''            SET INITIAL DEFAULTS\n&LCLC    SETC  'HFA'\n&LCLC2   SETC  '2440'  EXTRA CHARACTER GIVES DEFAULT '0' FOR NON-H,F,A\n.* H,2; F,4; A,4; OTHER,0.\n&I       SETA  1\n.NEXTI08 ANOP  ,\n         AIF   ('&LCLC'(&I,1) EQ '&TYP').EXITI08\n.ADVI08  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE K'&LCLC).NEXTI08\n.EXITI08 ANOP  ,\n&LCLC    SETC  '&LCLC2'(&I,1)          FETCH CHARACTER FROM 2ND ARRAY\n&LV      SETA  &LCLC                      AND CHANGE TO NUMERIC\n         AIF   (K'&LGH EQ 0).NOLGH             USE DEFAULT LENGTH\n&HIBIT   SETB  ('&LGH'(K'&LGH,1) EQ '*')  SET BY '*', OR '4*', ETC.\n         AIF   (K'&LGH EQ 1 AND &HIBIT).NOLGH  USE DEFAULT LENGTH\n&LCLC    SETC  '&LGH'(1,K'&LGH-&HIBIT) TRIM POSSIBLE '*' (K'&LGH GE 2)\n&LV      SETA  &LCLC         MUST BE SELF-DEFINING DECIMAL TERM\n&LX      SETC  'L&LV'\n.NOLGH   ANOP  ,\n         AIF   (&LV NE 0).XLGH\n&LV      SETA  K'&VAL\n         AIF   (&LV EQ 0).XLGH\n&LX      SETC  'L&LV'\n.XLGH    ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* ANALYSE NOMINAL VALUE:\n.* &VAL=''        PRODUCES &NUL=1, &VV=DEFAULT\n.*                                    (DEFAULT DEPENDS ON DATA TYPE)\n.* &VAL='...'     PRODUCES &LIT=1, &VV=...   (WITHOUT QUOTES)\n.* &VAL=(...)     PRODUCES &REG=1, &VV=...   (WITHOUT PARENS)\n.* &VAL=A(...)    PRODUCES &ACN=1, &VV=...   (WITHOUT A(, ) )\n.* &VAL=<OTHER>   PRODUCES &NUL=&LIT=&REG=&ACN=0, &SYMBOL=1,\n.*                                 &VV=&VAL\n&LIT     SETB  0             LITERAL\n&REG     SETB  0             REGISTER\n&ACN     SETB  0             ADDRESS CONSTANT\n&NUL     SETB  1             NULL -- OMITTED\n&LCLC    SETC  'C'\n&LCLC2   SETC  ' 0'     EXTRA CHARACTER GIVES DEFAULT '0' FOR NON-C\n.* C,' '; OTHER,0.\n&I       SETA  1\n.NEXTI05 ANOP  ,\n         AIF   ('&LCLC'(&I,1) EQ '&TYP').EXITI05\n.ADVI05  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE K'&LCLC).NEXTI05\n.EXITI05 ANOP  ,\n&VV      SETC  '&LCLC2'(&I,1)          FETCH CHARACTER FROM 2ND ARRAY\n&DFLTVV  SETC  '&VV'                   SAVE FOR LATER, ' ' OR '0'\n         AIF   (K'&VAL EQ 0).ZVAL                .* IF NULL SKIP\n         AIF   ('&VAL' EQ '').ZVAL               .* IF NULL SKIP\n&NUL     SETB  0                               .* RESET NULL IF NOT\n         AIF   (K'&VAL LT 3).XVAL      TOO SHORT TO BE ANYTHING\n&VV      SETC  '&VAL'(2,K'&VAL-2)      REMOVE QUOTES/PARENS\n&LIT     SETB  ('&VAL'(1,1) EQ '''' AND '&VAL'(K'&VAL,1) EQ '''')\n         AIF   (&LIT).ZVAL\n&REG     SETB  ('&VAL'(1,1) EQ '(' AND '&VAL'(K'&VAL,1) EQ ')')\n         AIF   (&REG).ZVAL\n         AIF   (K'&VAL LT 4).XVAL      TOO SHORT TO BE ACN\n&ACN     SETB  ('&VAL'(1,2) EQ 'A(' AND '&VAL'(K'&VAL,1) EQ ')')\n&VV      SETC  '&VAL'(3,K'&VAL-3)      REMOVE A(, )\n         AIF   (&ACN).ZVAL\n.XVAL    ANOP  ,\n&VV      SETC  '&VAL'\n.ZVAL    ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n&SYMBOL  SETB  (NOT &NUL AND NOT &LIT AND NOT &REG AND NOT &ACN)\n.*                     (SOMETHING, BUT NONE OF THE ABOVE)\n&MUSTMOV SETB  0             PREP IT TO 0\n         AIF   (&REG).MM1    IF &REG, CANNOT BE DC.-D\n         AIF   (&NUL).MMXX              NULL VALUE CAN ALWAYS BE DC.-D\n         AIF   (&LIT AND ('&TYP' EQ 'C')).MMXX   LITERALS CAN BE DC.-D\n         AIF   (NOT &LIT AND ('&TYP' EQ 'C')).MM1   OTHERS CANNOT\n         AIF   ('&TYP' EQ 'A').MMXX       WITHOUT QUOTES, CAN BE DC.-D\n         AGO   .MMXX\n.MM1     ANOP  ,\n&MUSTMOV SETB  1             CHANGE IT TO 1\n.MMXX    ANOP  ,\n.*    &MUSTMOV IS A FLAG THAT SAYS SOME CODE IS NEEDED FOR A FIELD,\n.*  THAT IT CANNOT BE JUST ASSEMBLED INTO A DC. (AS IN MF=L)\n         CECDYN DEBUG,'VAL=\"',&VV.,                                    X\n               '\", NUL=&NUL., LIT=&LIT., REG=&REG., ACN=&ACN.',        X\n               ', SYMBOL=&SYMBOL., MUSTMOV=&MUSTMOV..'\n.*..+....1....+....2....+....3                                        0\n.*\n.* PROCESS COMMENT FIELD:\n         AIF   (K'&CMT EQ 0).NOQUOT1\n         AIF   ('&CMT'(1,1) NE '''').NOQUOT1\n         AIF   ('&CMT'(K'&CMT,1) NE '''').NOQUOT1\n&CMT     SETC  '&CMT'(2,K'&CMT-2)     REMOVE QUOTES\n.NOQUOT1 ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n         AIF   (NOT &CEC#DEBUG).XDEBUG3\n         CECDYN DEBUG,'NAME=&NAME DUP=&DUP TYP=&TYP LGH=&LGH VAL=\"',   X\n               &VV,'\"'\n         CECDYN MNOTE,'        POS6=&CMT, POS7=&POS7..'\n         CECDYN MNOTE,'        DV=&DV DX=\"&DX\"  LV=&LV LX=\"&LX\"'\n         CECDYN MNOTE,'   VAL: NUL=&NUL, LIT=&LIT, REG=&REG, ACN=&ACN'\n&LCLA    SETA  N'&LGH\n         CECDYN MNOTE,'        N''LGH=&LCLA, HIBIT=&HIBIT'\n.XDEBUG3 ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n&GENRETI SETA  1        DEFAULT RETURN FROM .GENCOM:  .CR#EXIT\n.*\n         AIF   (&CEC#FLAG(1)).G#DCDS   GENERATE DC/DS\n         AIF   (&CEC#FLAG(2)).G#DCDS   GENERATE DC/DS\n         AIF   (&DV EQ 0).CR#EXIT      DUPLICATION FACTOR ZERO--EXIT!\n         AIF   (&CEC#FLAG(3)).G#MOVE   GENERATE MOVES\n         AIF   (&CEC#FLAG(4)).G#MOVE   GENERATE MOVES\n&LCLC    SETC  'INTERNAL ERROR IN .CREAT SUBROUTINE, SYSNDX=&SYSNDX '\n&LCLC    SETC  '&LCLC'.'FLAGS=&CEC#FLAG(1),&CEC#FLAG(2),'\n&LCLC    SETC  '&LCLC'.'&CEC#FLAG(3),&CEC#FLAG(4)..'\n         MNOTE 16,'&LCLC'\n&CEC#DEBUG SETB 1      TURN ON\n         MHELP 1+2+4+8+16+32+64\n         AGO   .CR#EXIT\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.G#DCDS  ANOP  ,             GENERATE DC OR DS\n&LBL     SETC  '&NAME'\n         AIF   (&LV EQ 0 AND &DV EQ 0 AND '&TYP' EQ '').G#EQU INSTEAD\n.*..+....1\n         AIF   (NOT &MUSTMOV).LEAVEVV\n&VV      SETC  '&DFLTVV'               SAVED DEFAULT\n         CECDYN DEBUG,'VAL=\"',&VV.,                                    X\n               '\", NUL=&NUL., LIT=&LIT., REG=&REG., ACN=&ACN.',        X\n               ', SYMBOL=&SYMBOL., MUSTMOV=&MUSTMOV., VV=&VV..'\n.LEAVEVV ANOP  , DON'T SET BACK TO DEFAULT\n.*..+....1\n         AIF   (&CEC#FLAG(1) AND &DV EQ 0).FLAG2A GENERATE DS, NOT DC\n         AIF   (&CEC#FLAG(1)).FLAG1A\n         AIF   (&CEC#FLAG(2)).FLAG2A\n.*..+....1\n.FLAG1A  ANOP  ,\n&OPR     SETC  'DC'\n&OPD     SETC  '&DX&TYP&LX'.'(&VV)'    A(<VALUE>)\n         AIF   ('&TYP' EQ 'A').FLAG1B\n&OPD     SETC  '&DX&TYP&LX'.'''&VV'''  C'<VALUE>' OR F'<VALUE>' OR X..\n         AGO   .FLAG1X                 DONE SETTING UP\n.FLAG1B  ANOP  ,\n         AIF   (NOT &HIBIT).FLAG1X     NOTHING SPECIAL TO DO\n         AIF   (&ACN).FLAG1C           OK, SKIP ERROR MESSAGE\n         MNOTE 12,'INTERNAL ERROR, HIBIT ONLY VALID FOR ADCON.S'\n&CEC#DEBUG SETB 1      TURN ON\n.FLAG1C  ANOP  ,\n&OPD     SETC  '&DX&TYP&LX'.'(&VV+X''80000000'')'  SET HIGH BIT ON\n.FLAG1X  AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1\n.FLAG2A  ANOP  ,\n&OPR     SETC  'DS'\n&OPD     SETC  '&DX&TYP&LX'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1\n.G#EQU   ANOP  ,\n&OPR     SETC  'EQU'\n&OPD     SETC  '*'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.G#MOVE  CECDYN DEBUG,.G#MOVE         GENERATE MOVES\n&LBL     SETC  ''\n&LCLC    SETC  'SYMBOL=&SYMBOL., MUSTMOV=&MUSTMOV.'\n&LCLC    SETC  '&LCLC., FLAG(3)=&CEC#FLAG(3)., FLAG(4)=&CEC#FLAG(4).'\n         CECDYN DEBUG,'&LCLC'\n&LCLB    SETB                (     &MUSTMOV   AND (NOT &CEC#FLAG(3) ))\n&LCLC    SETC        '&LCLB.=(     &MUSTMOV.  AND (NOT &CEC#FLAG(3)))'\n         CECDYN DEBUG,'&LCLC.=(     MUSTMOV   AND (NOT  FLAG(3) ))'\n&LCLB1   SETB                ((NOT &MUSTMOV ) AND (NOT &CEC#FLAG(4) ))\n&LCLC    SETC       '&LCLB1.=((NOT &MUSTMOV.) AND (NOT &CEC#FLAG(4)))'\n         CECDYN DEBUG,'&LCLC.=((NOT MUSTMOV ) AND (NOT  FLAG(4) ))'\n         CECDYN DEBUG,'    IF EITHER OF ABOVE IS TRUE, THEN MEXIT'\n         AIF   (&LCLB OR &LCLB1).CR#EXIT                 NOTHING TO DO\n         AIF   ('&DUP' EQ '0' AND K'&CMT EQ 0).CR#EXIT   NOTHING TO DO\n         AIF   ('&DUP' EQ '0').ONLYCMT  NO CODE TO BE GENERATED\n         AIF   (&NUL AND                                               X\n               '&TYP' EQ 'C').BLANK  TO-FIELD IS CHARACTER             X\n                                        AND NO NOMINAL VALUE SPECIFIED\n         AIF   (&NUL AND                                               X\n               '&TYP' EQ 'F').ZERO   TO-FIELD IS A FULLWORD            X\n                                        AND NO NOMINAL VALUE SPECIFIED\n         AIF   (&NUL).CLEAR          NO NOMINAL VALUE SPECIFIED\n         AIF   ('&VV' EQ '0').CLEAR  VALUE TO GENERATE IS 0\n         AIF   ('&TYP' EQ 'C').AAACH TO-FIELD IS A CHARACTER FIELD\n         AIF   ('&LV' EQ '1' AND                                       X\n               ('&TYP' EQ 'A' OR '&TYP' EQ 'X' OR '&TYP' EQ 'F' OR     X\n               '&TYP' EQ 'H')).AAA1N TO-FIELD IS LENGTH 1, NUMERIC\n         AIF   ('&LV' EQ '2' AND                                       X\n               ('&TYP' EQ 'A' OR '&TYP' EQ 'X' OR '&TYP' EQ 'F' OR     X\n               '&TYP' EQ 'H')).AAA2N TO-FIELD IS LENGTH 2, NUMERIC\n         AIF   ('&LV' EQ '3' AND                                       X\n               ('&TYP' EQ 'A' OR '&TYP' EQ 'X' OR '&TYP' EQ 'F' OR     X\n               '&TYP' EQ 'H')).AAA3N TO-FIELD IS LENGTH 3, NUMERIC\n         AIF   ('&LV' EQ '4' AND                                       X\n               ('&TYP' EQ 'A' OR '&TYP' EQ 'X' OR '&TYP' EQ 'F' OR     X\n               '&TYP' EQ 'H')).AAA4N TO-FIELD IS LENGTH 4, NUMERIC\n         MNOTE 12,'INTERNAL ERROR IN CREAT ROUTINE:'\n MNOTE '            NAME=&NAME DUP=&DUP TYP=&TYP LGH=&LGH VAL=\"&VV\"'\n MNOTE '            POS6=&CMT..'\n MNOTE '            DV=&DV DX=\"&DX\"  LV=&LV LX=\"&LX\"'\n MNOTE '       VAL: NUL=&NUL, LIT=&LIT, REG=&REG, ACN=&ACN'\n&CEC#DEBUG SETB 1      TURN ON\n         AGO   .CR#EXIT\n.*..+....1....+....2                                                  0\n.*\n.* (EACH 'AGO .GENCOM\" WITH NO RETURN IS FOLLOWED BY DOUBLE-SPACE)\n.*..+....1....+....2                                                  0\n.ONLYCMT CECDYN CMT2,.ONLYCMT    DUPLICATION FACTOR ZERO--ONLY COMMENT0\n&LBL     SETC  '*'\n&OPR     SETC  ''\n&OPD     SETC  '&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.BLANK   CECDYN CMT2,.BLANK     NO NOMINAL VALUE FOR 'C'--BLANK-FILL  0\n         AIF   (&LV LE 0 OR &LV GT 8).BLANK1   CONTINUE THINKING\n.BLANK8  CECDYN CMT2,.BLANK8    USER SPECIFIED &LGH LE 8--USE LITERAL\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME'.'(&LV),=CL8'' '''\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.BLANK1  CECDYN CMT2,.BLANK1    MOVE A SINGLE BLANK                   0\n&OPR     SETC  'MVI'\n&OPD     SETC  '&NAME,C'' '''\n         AIF   (&LV EQ 1).GENCOM GO GENERATE A LINE, THEN .CR#EXIT\n&GENRETI SETA  3             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET3\n.GENRET3 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&CMT     SETC  'PROPOGATE INITIAL BLANK'\n         AIF   (&LV EQ 0).BLANK0\n.BLANKX  CECDYN CMT2,.BLANKX USER SPECIFIED &LGH--USE IT              0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME+1(&LV-1),&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.BLANK0  CECDYN CMT2,.BLANK0 NO &LGH--HOPE ASMBLR CAN FIGURE IT OUT   0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME+1(L''&NAME-1),&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.ZERO    CECDYN CMT2,.ZERO      NO NOMINAL VALUE FOR 'F'--LOAD ZEROES 0\n         AIF   (&LV GE 4).CLEAR LGH GREATER THAN TYPE F--USE XC\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,=F''0'''\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.CLEAR   CECDYN CMT2,.CLEAR     NO NOMINAL VALUE--CLEAR TO HEX ZEROES 0\n&OPR     SETC  'MVI'\n&OPD     SETC  '&NAME,0'\n         AIF   (&LV EQ 1).GENCOM GO GENERATE A LINE, THEN .CR#EXIT\n         AIF   (&LV EQ 0).CLEAR0\n&OPR     SETC  'XC'\n&OPD     SETC  '&NAME'.'(&LV),&NAME'\n&GENRETI SETA  2 PREPARE RETURN POINTER--CHECK FOR HIBIT AFTERWARD\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2\n.CLEAR0  CECDYN CMT2,.CLEAR0 NO &LGH--HOPE ASMBLR CAN FIGURE IT OUT   0\n&OPR     SETC  'XC'\n&OPD     SETC  '&NAME,&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.AAACH   CECDYN CMT2,.AAACH , TO-FIELD IS A CHARACTER FIELD           0\n         AIF   (&REG).REGCH   TO-FIELD IS CHAR, SOURCE IS REG-FORMAT\n         AIF   (&ACN).ACNCH   TO-FIELD IS CHAR, SOURCE IS ACON-FORMAT\n         AIF   (&LIT).LITCH   TO-FIELD IS CHAR, SOURCE IS LITERAL\n.SYMCH   ANOP  ,              TO-FIELD IS CHAR, SOURCE IS A SYMBOL    0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,&VV' OR '&NAME,&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.LITCH   CECDYN CMT2,.LITCH   TO-FIELD IS CHAR, SOURCE IS LITERAL     0\n         AIF   (&LV EQ 1).LIT1CH TO-FIELD IS 1-CHAR, SOURCE IS LITERAL\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,=C&LX''&VV''' OR '&NAME,=C&LX&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.LIT1CH  CECDYN CMT2,.LIT1CH  TO-FIELD IS 1-CHAR, SOURCE IS LITERAL   0\n&OPR     SETC  'MVI'\n&OPD     SETC  '&NAME,''&VV''' OR '&NAME,&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.REGCH   CECDYN CMT2,.REGCH   TO-FIELD IS CHAR, SOURCE IS REG-FORMAT  0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,0(&VV)' OR '&NAME,0&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.ACNCH   CECDYN CMT2,.ACNCH   TO-FIELD IS CHAR, SOURCE IS ACON-FORMAT 0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'LA'\n&OPD     SETC  '15,&VV'\n&CMT     SETC  'LOAD ADDRESS OF FIELD'\n&GENRETI SETA  4             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET4\n.GENRET4 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,0(15)'\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.AAA1N   CECDYN CMT2,.AAA1N , TO-FIELD IS LENGTH 1, NUMERIC           0\n         AIF   (&REG).REG1N TO-FIELD LGH 1 NUMERIC, SOURCE REG-FORMAT\n         AIF   (&ACN).ACN1N TO-FIELD LGH 1 NUMERIC, SOURCE ACON-FORMAT\n         AIF   (&LIT).LIT1N TO-FIELD LGH 1 NUMERIC, SOURCE A LITERAL\n.SYM1N   ANOP  ,            TO-FIELD LGH 1 NUMERIC, SOURCE A SYMBOL   0\n&OPR     SETC  'MVI'\n&OPD     SETC  '&NAME,&VV' OR '&NAME,&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.LIT1N   CECDYN CMT2,.LIT1N TO-FIELD LGH 1 NUMERIC, SOURCE A LITERAL  0\n&OPR     SETC  'MVI'\n&OPD     SETC  '&NAME,C''&VV''' OR '&NAME,C&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.REG1N   CECDYN CMT2,.REG1N TO-FIELD LGH 1 NUMERIC, SOURCE REG-FORMAT 0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'L'\n&OPD     SETC  '15,0(&VV)' OR '15,0&VAL'\n&CMT     SETC  'FETCH FULLWORD POINTED-TO BY REGISTER'\n&GENRETI SETA  7             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET7\n.GENRET7 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'STC'\n&OPD     SETC  '15,&NAME'\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.ACN1N   CECDYN CMT2,.ACN1N TO-FIELD LGH 1 NUMERIC, SOURCE ACON-FORMAT0\n         LA    15,&VV        LOAD ADDRESS OF FIELD            .ACN1N\n&OPR     SETC  'STC'\n&OPD     SETC  '15,&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.AAA2N   CECDYN CMT2,.AAA2N , TO-FIELD IS LENGTH 2, NUMERIC           0\n         AIF   (&REG).REG2N TO-FIELD LGH 2 NUMERIC, SOURCE REG-FORMAT\n         AIF   (&ACN).ACN2N TO-FIELD LGH 2 NUMERIC, SOURCE ACON-FORMAT\n         AIF   (&LIT).LIT2N TO-FIELD LGH 2 NUMERIC, SOURCE A LITERAL\n.SYM2N   ANOP  ,            TO-FIELD LGH 2 NUMERIC, SOURCE A SYMBOL   0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,=AL2(&VV)' OR '&NAME,=AL2(&VAL)'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.LIT2N   CECDYN CMT2,.LIT2N TO-FIELD LGH 2 NUMERIC, SOURCE A LITERAL  0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,=AL2(C''&VV'')' OR '&NAME,=AL2(C&VAL)'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.REG2N   CECDYN CMT2,.REG2N TO-FIELD LGH 2 NUMERIC, SOURCE REG-FORMAT 0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'L'\n&OPD     SETC  '15,0(&VV)' OR '15,0&VAL'\n&CMT     SETC  'FETCH FULLWORD POINTED-TO BY REGISTER'\n&GENRETI SETA  6             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET6\n.GENRET6 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'STH'\n&OPD     SETC  '15,&NAME'    STORE HALFWORD FROM REG.\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.ACN2N   CECDYN CMT2,.ACN2N TO-FIELD LGH 2 NUMERIC, SOURCE ACON-FORMAT0\n         LA    15,&VV        LOAD ADDRESS OF FIELD            .ACN2N\n&OPR     SETC  'STH'\n&OPD     SETC  '15,&NAME'    STORE HALFWORD FROM REG.\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.AAA3N   CECDYN CMT2,.AAA3N , TO-FIELD IS LENGTH 3, NUMERIC           0\n         AIF   (&REG).REG3N TO-FIELD LGH 3 NUMERIC, SOURCE REG-FORMAT\n         AIF   (&ACN).ACN3N TO-FIELD LGH 3 NUMERIC, SOURCE ACON-FORMAT\n         AIF   (&LIT).LIT3N TO-FIELD LGH 3 NUMERIC, SOURCE A LITERAL\n.SYM3N   ANOP  ,            TO-FIELD LGH 3 NUMERIC, SOURCE A SYMBOL   0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'L'\n&OPD     SETC  '15,&VV'\n&CMT     SETC  'FETCH FULLWORD'\n&GENRETI SETA  9             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET9\n.GENRET9 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'STCM'\n&OPD     SETC  '15,B''0111'',&NAME'\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.LIT3N   CECDYN CMT2,.LIT3N TO-FIELD LGH 3 NUMERIC, SOURCE A LITERAL  0\n         LA    15,=C'&VV'    POINT TO FULLWORD                .LIT3N\n&OPR     SETC  'STCM'\n&OPD     SETC  '15,B''0111'',&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.REG3N   CECDYN CMT2,.REG3N TO-FIELD LGH 3 NUMERIC, SOURCE REG-FORMAT 0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'L'\n&OPD     SETC  '15,0(&VV)' OR '15,0&VAL'\n&CMT     SETC  'FETCH FULLWORD POINTED-TO BY REGISTER'\n&GENRETI SETA  8             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET8\n.GENRET8 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'STCM'\n&OPD     SETC  '15,B''0111'',&NAME'\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.ACN3N   CECDYN CMT2,.ACN3N TO-FIELD LGH 3 NUMERIC, SOURCE ACON-FORMAT0\n         LA    15,&VV        LOAD ADDRESS OF FIELD            .ACN3N\n&OPR     SETC  'STCM'\n&OPD     SETC  '15,B''0111'',&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.AAA4N   CECDYN CMT2,.AAA4N , TO-FIELD IS LENGTH 4, NUMERIC           0\n&GENRETI SETA  2 PREPARE RETURN POINTER--CHECK FOR HIBIT AFTERWARD\n         AIF   (&REG).REG4N TO-FIELD LGH 4 NUMERIC, SOURCE REG-FORMAT\n         AIF   (&ACN).ACN4N TO-FIELD LGH 4 NUMERIC, SOURCE ACON-FORMAT\n         AIF   (&LIT).LIT4N TO-FIELD LGH 4 NUMERIC, SOURCE A LITERAL\n.SYM4N   ANOP  ,            TO-FIELD LGH 4 NUMERIC, SOURCE A SYMBOL   0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME'.'(4),&VV' OR '&NAME'.'(4),&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2\n.LIT4N   CECDYN CMT2,.LIT4N TO-FIELD LGH 4 NUMERIC, SOURCE A LITERAL  0\n         LA    15,=C'&VV'       FETCH WORD                    .LIT4N\n&OPR     SETC  'ST'\n&OPD     SETC  '15,&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2\n.REG4N   CECDYN CMT2,.REG4N TO-FIELD LGH 4 NUMERIC, SOURCE REG-FORMAT 0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,0(&VV)' OR '&NAME,0&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2\n.ACN4N   CECDYN CMT2,.ACN4N TO-FIELD LGH 4 NUMERIC, SOURCE ACON-FORMAT0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'LA'\n&OPD     SETC  '15,&VV'\n&CMT     SETC  'LOAD ADDRESS OF FIELD'\n&GENRETI SETA  5             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET5\n.GENRET5 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'ST'\n&OPD     SETC  '15,&NAME'\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n&GENRETI SETA  2 PREPARE RETURN POINTER--CHECK FOR HIBIT AFTERWARD\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2\n.*\n.GENRET2 AIF   (NOT &HIBIT).CR#EXIT    NOTHING SPECIAL TO DO          0\n         OI    &NAME,X'80'      TURN ON HIGH BIT              .GENRET2\n         AGO   .CR#EXIT\n.*..+....1....+....2....+....3....+....4                              1\n.GENCOM  ANOP , GENERATE A STMT, W/ COMMENT FIELD AND W/ &CEC#CMT2VAL 0\n.* THIS IS AN AGO-TYPE INTERNAL ROUTINE --\n.* IT EXITS WITH THE STATEMENT:            AGO .GENRET&GENRETI\n.*\n.* INPUTS: LOCAL SETC VARIABLES: &LBL          LABEL\n.*                               &OPR          OPERATOR\n.*                               &OPD          OPERAND\n.*                               &CMT          COMMENT\n.*         GLOBAL SETC VARIABLE: &CEC#CMT2VAL  SECONDARY COMMENT\n.* OUTPUT: STATEMENT/MNOTE: &LBL     &OPR  &OPD&CMT&CEC#CMT2VAL\n.*         WITH COLUMNS:   '....+....1....+..  .   .\n.*         (&LBL IN COLUMN 1,\n.*          &OPR IN COLUMN 10 IF POSSIBLE, ELSE SHIFTED,\n.*          &OPD IN COLUMN 16 IF POSSIBLE, ELSE SHIFTED,\n.*          &CMT IN COLUMN &CECCMT1COL (ON A CONT'N IF NECESSARY),\n.*  &CEC#CMT2VAL IN COLUMN &CECCMT2COL (ON A CONT'N IF NECESSARY).)\n.*..+....1....+....2....+....3                                        0\n.*\n.* TRIM ALL BLANKS FROM RIGHT-HAND END OF &LBL\n         AIF   (K'&LBL EQ 0).OKLBL     LENGTH ZERO--NO TRIM NECESSARY\n.TRIMLBL AIF   ('&LBL'(K'&LBL,1) NE ' ').OKLBL  Q. LAST CHAR A BLANK?\n.* A. YES, LAST CHARACTER IS A BLANK\n         AIF   (K'&LBL EQ 1).ZZLBL     LENGTH ONE--NO PAD NECESSARY\n&LBL     SETC  '&LBL'(1,K'&LBL-1)      A. YES--TRIM LAST CHARACTER AND\n         AGO   .TRIMLBL                    GO BACK AND CHECK SOME MORE\n.OKLBL   ANOP  ,                       A. NO--NO MORE TRIM NECESSARY\n.*\n&LBL     SETC  '&LBL. '                ADD EXACTLY 1 BLANK\n.ZZLBL   ANOP  ,\n.*\n.* CALCULATE HOW MUCH ROOM WE HAVE TO WORK WITH:\n&LCLA    SETA  10-1          COLUMNS 1 THROUGH JUST-BEFORE 10\n.*\n         AIF   (&LCLA LE K'&LBL).PADLBLZ NO PAD NECESSARY\n&LBL     SETC  '&LBL'.(&LCLA-K'&LBL)' ' PAD TO LENGTH NECESSARY\n.PADLBLZ ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* TRIM ALL BLANKS FROM RIGHT-HAND END OF &OPR\n         AIF   (K'&OPR EQ 0).OKOPR     LENGTH ZERO--NO TRIM NECESSARY\n.TRIMOPR AIF   ('&OPR'(K'&OPR,1) NE ' ').OKOPR  Q. LAST CHAR A BLANK?\n.* A. YES, LAST CHARACTER IS A BLANK\n         AIF   (K'&OPR EQ 1).ZZOPR     LENGTH ONE--NO PAD NECESSARY\n&OPR     SETC  '&OPR'(1,K'&OPR-1)      A. YES--TRIM LAST CHARACTER AND\n         AGO   .TRIMOPR                    GO BACK AND CHECK SOME MORE\n.OKOPR   ANOP  ,                       A. NO--NO MORE TRIM NECESSARY\n.*\n&OPR     SETC  '&OPR. '                ADD EXACTLY 1 BLANK\n.ZZOPR   ANOP  ,\n.*\n.* CALCULATE HOW MUCH ROOM WE HAVE TO WORK WITH:\n&LCLA    SETA  16-10         COLUMNS 10 THROUGH JUST-BEFORE 16\n.*\n         AIF   (&LCLA LE K'&OPR).PADOPRZ NO PAD NECESSARY\n&OPR     SETC  '&OPR'.(&LCLA-K'&OPR)' ' PAD TO LENGTH NECESSARY\n.PADOPRZ ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* TRIM ALL BLANKS FROM RIGHT-HAND END OF &OPD\n         AIF   (K'&OPD EQ 0).OKOPD     LENGTH ZERO--NO TRIM NECESSARY\n.TRIMOPD AIF   ('&OPD'(K'&OPD,1) NE ' ').OKOPD  Q. LAST CHAR A BLANK?\n.* A. YES, LAST CHARACTER IS A BLANK\n         AIF   (K'&OPD EQ 1).ZZOPD     LENGTH ONE--NO PAD NECESSARY\n&OPD     SETC  '&OPD'(1,K'&OPD-1)      A. YES--TRIM LAST CHARACTER AND\n         AGO   .TRIMOPD                    GO BACK AND CHECK SOME MORE\n.OKOPD   ANOP  ,                       A. NO--NO MORE TRIM NECESSARY\n.*\n&OPD     SETC  '&OPD. '                ADD EXACTLY 1 BLANK\n.ZZOPD   ANOP  ,\n.*\n.* CALCULATE HOW MUCH ROOM WE HAVE TO WORK WITH:\n&LCLA    SETA  &CECCMT1COL-16\n.*\n.PADOPDL ANOP  ,                       ADDITIONAL LINE\n         AIF   (K'&OPD LE &LCLA).PADOPDY                               X\n                                       Q. &OPD SHORT ENOUGH TO FIT?\n&LCLA    SETA  &LCLA+56                 A. NO--USE AN ADDITIONAL LINE\n.* NOTE--EACH CONTINUATION LINE GIVES 56 MORE CHARACTERS (COLS 16-71)\n         AGO   .PADOPDL\n.PADOPDY ANOP  ,                        A. YES--IT WILL FIT\n.*\n         AIF   (&LCLA LE K'&OPD).PADOPDZ NO PAD NECESSARY\n&OPD     SETC  '&OPD'.(&LCLA-K'&OPD)' ' PAD TO LENGTH NECESSARY\n.PADOPDZ ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* TRIM ALL BLANKS FROM RIGHT-HAND END OF &CMT\n         AIF   (K'&CMT EQ 0).OKCMT     LENGTH ZERO--NO TRIM NECESSARY\n.TRIMCMT AIF   ('&CMT'(K'&CMT,1) NE ' ').OKCMT  Q. LAST CHAR A BLANK?\n         AIF   (K'&CMT EQ 1).ZZCMT     LENGTH ONE--NO PAD NECESSARY\n&CMT     SETC  '&CMT'(1,K'&CMT-1)      A. YES--TRIM LAST CHARACTER AND\n         AGO   .TRIMCMT                    GO BACK AND CHECK SOME MORE\n.OKCMT   ANOP  ,                       A. NO--NO MORE TRIM NECESSARY\n.*\n&CMT     SETC  '&CMT. '                ADD EXACTLY 1 BLANK\n.ZZCMT   ANOP  ,\n.*\n.* CALCULATE HOW MUCH ROOM WE HAVE TO WORK WITH:\n&LCLA    SETA  &CECCMT2COL-&CECCMT1COL\n.*\n.PADCMTL ANOP  ,                       ADDITIONAL LINE\n         AIF   (K'&CMT LE &LCLA).PADCMTY Q. &CMT SHORT ENOUGH TO FIT?\n&LCLA    SETA  &LCLA+56                  A. NO--USE AN ADDITIONAL LINE\n.* NOTE--EACH CONTINUATION LINE GIVES 56 MORE CHARACTERS (COLS 16-71)\n         AGO   .PADCMTL\n.PADCMTY ANOP  ,                        A. YES--IT WILL FIT\n.*\n         AIF   (&LCLA LE K'&CMT).PADCMTZ NO PAD NECESSARY\n&CMT     SETC  '&CMT'.(&LCLA-K'&CMT)' ' PAD TO LENGTH NECESSARY\n.PADCMTZ ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n         AIF   ('&LBL'(1,1) EQ '*').DOMNOTE\n&LCLAX(1) SETA K'&LBL,K'&OPR,K'&OPD,K'&CMT\n         CECDYN DEBUG,' CECDYN *2',                                    X\n               ' LBL=&LCLAX(1),\"&LBL\"',                                X\n               ' OPR=&LCLAX(2),\"&OPR\"',                                X\n               ' OPD=&LCLAX(3),\"&OPD\"',                                X\n               ' CMT=&LCLAX(4),\"&CMT\"',                                X\n               ' CMT1COL=&CECCMT1COL, CMT2COL=&CECCMT2COL',            X\n               ' CEC#CMT1COL=&CEC#CMT1COL, CEC#CMT2COL=&CEC#CMT2COL'\n.*\n.* THIS IS THE MAIN PURPOSE OF ROUTINE .GENCOM:\n&LBL     &OPR  &OPD&CMT&CEC#CMT2VAL\n.* THAT WAS THE MAIN PURPOSE OF ROUTINE .GENCOM--YOU ALMOST MISSED IT.\n.*\n         AGO   .DONEIT\n.*..+....1....+....2                                                  0\n.*\n.DOMNOTE ANOP  ,\n.*\n         MNOTE '&LBL&OPR&OPD&CMT&CEC#CMT2VAL'\n.*\n         AGO   .DONEIT\n.*..+....1                                                            0\n.*\n.DONEIT  ANOP  ,\n.*\n&LCLA    SETA  &GENRETI      FETCH RETURN INDEX\n&GENRETI SETA  1             RETURN POINTER TO DEFAULT, FOR NEXT TIME\n.* ACTUAL CODE GENERATION:                                            -\n         AGO   (&LCLA).GENRET1,.GENRET2,.GENRET3,.GENRET4,.GENRET5,    X\n               .GENRET6,.GENRET7,.GENRET8,.GENRET9\n.***************************\n.* THE EFFECT OF THE ABOVE CODE IS:\n.*       AGO   .GENRET&LCLA\n.***************************\n         MNOTE 16,'SEVERE INTERNAL ERROR'\n         MNOTE 'GENRETI=&LCLA'\n&CEC#DEBUG SETB 1      TURN ON\n         AGO   .CR#EXIT\n.*..+....1                                                            0\n.*\n.GENRET1 AGO   .CR#EXIT , DEFAULT EXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70\n.*\n.CR#EXIT ANOP  ,\n&CECCMT1COL SETA &CEC#CMT1COL COMMENT 1 FIELD'S COLUMN\n&CECCMT2COL SETA &CEC#CMT2COL COMMENT 2 FIELD'S COLUMN\n         AGO   .SUBEXIT , EXIT FROM .CREAT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.DEBUG   ANOP  , SELF-CALL INTERNAL ROUTINE -- DISPLAY DEBUG MNOTES   0\n.*\n.* IF NO PARAMETERS BESIDES FIRST, TURN ON DEBUGGING AND .SUBEXIT\n         AIF   (N'&SYSLIST NE 1).NORMALDBG\n&CEC#DEBUG SETB 1      TURN ON\n         AGO   .SUBEXIT\n.NORMALDBG ANOP  ,\n.*\n.* IF JUST 1 PARAMETER BESIDES FIRST, AND IT STARTS WITH \".\", SAVE IT\n.* OR IF IT STARTS WITH \".'\", SAVE IT WITHOUT QUOTES\n         AIF   (N'&SYSLIST NE 2).NOSAVE\n         AIF   ('&POS2'(1,1) EQ '.').YSSAVE\n         AIF   ('&POS2'(1,2) EQ '''.').YSSAVEQ\n         AGO   .NOSAVE\n.YSSAVE  ANOP  ,\n&CEC#DBG#HDR SETC '&POS2'\n         AGO   .SUBEXIT\n.YSSAVEQ ANOP   ,\n&CEC#DBG#HDR SETC '&POS2'(2,K'&POS2-2) REMOVE QUOTES\n         AGO   .SUBEXIT\n.NOSAVE  ANOP  ,\n.*\n         AIF   (NOT &CEC#DEBUG).SUBEXIT IMMEDIATE RETURN\n.*\n         CECDYN MNOTE,&CEC#DBG#HDR,' -- ',&POS2,&POS3,&POS4,&POS5,     X\n               &POS6,&POS7,&POS8,&POS9,&POS10\n         AGO   .SUBEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.DOKEY   ANOP  , SELF-CALL INTERNAL ROUTINE -- PROCESS ONE TEXT UNIT  0\n.* ('USER-SUPPLIED' MEANS ON THE OUTER CALL TO CECDYN, FROM OPEN CODE)\n.* INPUT: POSITIONAL PARAMETERS\n.* &POS1  ALWAYS DOKEY\n.* &POS2  ALWAYS &I, ORDINAL TEXT UNIT NUMBER (BUILD '1ST','2ND',ETC.)\n.* &POS3  ALWAYS &KEY, USER-SUPPLIED TEXT UNIT KEY\n.* &POS4  ALWAYS &TEXT(&I,2), USER-SUPPLIED VALUE(S)\n.* &POS5  A TEXT UNIT NAME FROM IEFZB4D2\n.* &POS6  A SINGLE NUMBER OR A PAIR OF NUMBERS (MINPRMS,MAXPRMS) .\n.*         THIS GIVES LIMITS FOR S99TUNUM, WHICH \"SPECIFIES THE NUMBER\n.*         OF LENGTH-AND-PARAMETER COMBINATIONS IN THE TEXT UNIT\".\n.* &POS7  A SINGLE CHARACTER, THE FIELD TYPE C/X/F/A TO BE GENERATED.\n.* &POS8  A SINGLE NUMBER OR A PAIR OF NUMBERS (MINLNG,MAXLNG) .\n.*         THIS GIVES LIMITS FOR S99TULNG, WHICH \"SPECIFIES THE LENGTH\n.*         OF THE FOLLOWING PARAMETER FIELD\".\n.* &POS9  * -- A SINGLE ASTERISK\n.*        OR A LIST ((<CHARS>,<VALU>), (<CHARS>,<VALU>), ...)\n.*     OR A LIST (+, (<CHARS>,<VALU>), (<CHARS>,<VALU>), ...) .\n.*        WHEN A SINGLE ASTERISK IS SPECIFIED, A LABEL IS GENERATED\n.*     FOR AN INFORMATION-RETURN FIELD, CONSISTING OF &PREFIX PLUS\n.*     THE TEXT UNIT'S NAME.\n.*        WHEN A LIST IS SPECIFIED, THE USER-SUPPLIED VALUE(S) ARE\n.*     COMPARED AGAINST EACH <CHARS> ENTRY IN THE LIST, AND WHEN\n.*     AN EQUAL IS FOUND, THE CORRESPONDING <VALU> IS USED.\n.*     ORDINARILY, THE USER CAN ONLY SPECIFY ONE VALUE.  WHEN THE\n.*     LIST BEGINS WITH '+', MULTIPLE VALUES SPECIFIED BY THE USER\n.*     ARE TRANSLATED INTO MULTIPLE <VALU>S WHICH ARE THEN SUMMED TO\n.*     GENERATE A VALUE.\n.*        A <CHARS> ENTRY OF A SINGLE ASTERISK IS CONSIDERED A MATCH\n.*     FOR ANY VALUE SPECIFIED BY THE USER.\n.*        IN ADDITION TO THE VALUE GENERATED, A COMMENT IS GENERATED\n.*     IN THE FORM \"<CHARS>=<VALU>\".\n.*        IF THE LIST ENDS WITH AN ASTERISK, THEN NO ERROR MESSAGE\n.*     IS GENERATED FOR THE USER-SPECIFIED VALUE NOT BEING FOUND\n.*     AMONG THE <CHARS> ENTRIES, AND THE USER-SPECIFIED VALUE IS\n.*     USED AS-IS.\n.* &POS10  TEXT APPENDED TO THE GENERATED COMMENT.\n.*\n.*\n.*\n.* IF THERE IS ONLY 1 TEXT UNIT NAME IN THE LIST (N'&POS5 EQ 1) AND\n.* IT DOES NOT EQUAL THE ONE THE USER SUPPLIED    ('&POS3' NE '&POS5')\n.* THEN EXIT IMMEDIATELY     (.SUBEXIT)\n         AIF   (                                  N'&POS5 EQ 1  AND    X\n                                                   '&POS3' NE '&POS5'  X\n                             ).SUBEXIT\n.*\n.*\n.* IN CASE MORE THAN 1 TEXT UNIT NAME IS CODED,\n.* FIND USER-SUPPLIED &POS3 IN THE &POS5 LIST OF TEXT UNIT NAMES\n&J       SETA  1\n.NEXTJ01 ANOP  ,\n         AIF   ('&POS3' EQ '&POS5(&J)').EXITJ01\n.ADVJ01  ANOP  , ADVANCE &J\n&J       SETA  &J+1\n         AIF   (&J LE N'&POS5).NEXTJ01\n         AGO   .SUBEXIT , NOT FOUND, EXIT IMMEDIATELY\n.EXITJ01 ANOP  ,\n.* NOW &J POINTS TO THE ENTRY IN THE &POS5 LIST THAT MATCHES &POS3.\n.*\n.*\n.A#DOKEY CECDYN DEBUG,'.DOKEY A#DOKEY' SAVE HEADING FOR DEBUG MESSAGES\n.*\n.******* CECDYN DEBUG,'&NAME CECDYN *1 &POS1,&POS2,\"',                 X\n               &POS3,'\",&POS4,\"',                                      X\n               &POS5,'\",\"',                                            X\n               &POS6,'\",&POS7,&POS8,\"',                                X\n               &POS9,'\"'\n.*\n&CEC#KEYDONE SETB 1          INFORM CALLER, KEY HAS BEEN FOUND\n&I       SETA  &POS2\n&KEY     SETC  '&POS3'\n.*\n&CECCMT1COL SETA &CEC#CMT1COL COMMENT 1 FIELD'S COLUMN\n&CECCMT2COL SETA &CEC#CMT2COL COMMENT 2 FIELD'S COLUMN\n.* (EACH CALL TO .CREAT DOES ABOVE SETA.S, JUST BEFORE EXITING)\n.*\n&CEC#XLAT SETB (N'&POS9 GT 1  OR  '&POS7' EQ 'A')\n.*           IF N'&POS9 GT 1, THEN DEFINITELY A TRANSLATION TABLE.\n.* BUT, &POS9 MAY BE OMITTED;  IF '&POS7' EQ 'A', IT IS NUMERIC;\n.* ACT LIKE #XLAT.\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.A#XLAT  CECDYN DEBUG,'.DOKEY A#XLAT' SAVE HEADING FOR DEBUG MESSAGES\n&MAXJ    SETA  1             ONE VALUE TO BE GENERATED\n         AIF   (&CEC#XLAT).GENHDR     GENERATE GROUP HEADER\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.A#XCHK  CECDYN DEBUG,'.DOKEY A#XCHK' SAVE HEADING FOR DEBUG MESSAGES\n.*                           SET &MAXJ, AND OTHER THINGS\n.* FALL-THRU TO .GENHDR      AND THEN GENERATE GROUP HEADER\n.*\n.*\n.* FIRST, CROSS-CHECK BETWEEN:\n.*       N'&POS4 (NUMBER OF VALUES SPECIFIED BY THE CALLER)\n.*     AND &POS6 (NUMBER OF VALUES EXPECTED).\n.*\n         AIF   ((N'&POS6-1)*(N'&POS6-2) EQ 0).C#XCHK\n         MNOTE 4,'INTERNAL ERROR PROCESSING KEY &POS3 -- &&POS6 SHOULD X\n               HAVE ONLY 1 OR 2 ENTRIES, IT WAS \"&POS6\"'\n.C#XCHK  ANOP  ,\n.* IF N'&POS6=1, A FIXED # VALUES IS EXPECTED, &POS6(1)\n.* IF N'&POS6=2, MIN # VALUES EXPECTED IS &POS6(1), MAX IS &POS6(2)\n         AIF   (N'&POS6 NE 1).D#XCHK  VARIABLE NUMBER POSSIBLE? YES\n         AIF   (&POS6(1) NE 0).D#XCHK NON-ZERO NUMBER REQUIRED? YES\n         AIF   (N'&POS4 NE 0).D#XCHK  USER SUPPLIED AT LEAST 1? YES\n.* FIXED NUMBER POSSIBLE, WHICH IS ZERO, AND USER DID NOT SUPPLY ANY:\n&MAXJ    SETA  0            NO VALUES TO BE GENERATED\n         AGO   .F#XCHK      GO GENERATE THEM\n.D#XCHK  AIF   (N'&POS4 LE &POS6(N'&POS6)).E#XCHK Q. TOO MANY? A. NO  0\n&LCLA2   SETA  N'&POS4      # VALUES SPECIFIED                 A. YES\n         MNOTE 8,'ERROR: &LCLA2 VALUES WERE SPECIFIED FOR KEY &POS3 -- X\n               &POS6(N'&POS6) IS THE MAXIMUM NUMBER PERMITTED.'\n.E#XCHK  ANOP  ,\n&MAXJ    SETA  &POS6(1)     FIRST OR ONLY -- MINIMUM OR REQUIRED #\n         AIF   (&MAXJ GT N'&POS4).F#XCHK CALLER SPECIFIED FEWER? YES,  X\n                                       GENERATE THE MINIMUM # REQUIRED\n&MAXJ    SETA  N'&POS4 NO, GENERATE AS MANY VALUES AS CALLER SPECIFIED\n.*\n.F#XCHK  ANOP  ,\n.*\n         CECDYN DEBUG,'POS4=&POS4, POS6=&POS6, SO MAXJ=&MAXJ..'\n.*\n         AGO   .GENHDR\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.GENHDR  ANOP  ,             GENERATE GROUP HEADER\n.*\n.* BOTH .XLAT AND .XCHK PASS THROUGH HERE\n.*\n         AIF   (&CEC#XLAT).Q#XLAT\n.Q#XCHK  CECDYN CMT2,.XCHK   SET &CEC#CMT2VAL\n         AGO   .Q#BOTH\n.Q#XLAT  CECDYN CMT2,.XLAT   SET &CEC#CMT2VAL\n.Q#BOTH  ANOP  ,\n.*\n&CEC#P.NUM&I CECDYN CREAT,,A,2,&MAXJ,'# OF LENGTH+PARAMETER ENTRIES'\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.*\n.* IF &POS9 IS NOT A TRANSLATION TABLE, GENERATE MULTIPLE VALUES.\n.*\n         AIF   (&MAXJ EQ 0).SUBEXIT   NO VALUES TO BE GENERATED? YES\n.*\n.* IF THERE IS A MINIMUM NUMBER, DO THAT MANY (NULL VALUES, IF NEEDED)\n.*                               ELSE DO AS MANY AS CALLER SPECIFIED\n.*\n.* NOW, LOOP THROUGH REQUIRED NUMBER (FROM 1 UP THROUGH &MAXJ)\n&J       SETA  1\n.NEXTJ02 CECDYN DEBUG,'.DOKEY NEXTJ02' SAVE HEADING FOR DEBUG MESSAGES\n&SUFFIX  SETC  ''                  NO SUFFIX NEEDED, IF ONLY 1 FIELD\n         AIF   (&MAXJ EQ 1).SFXOK  YES, ONLY 1 FIELD TO BE GENERATED\n&SUFFIX  SETC  '#&J'               IF MORE THAN 1, DISTINGUISH THEM\n.SFXOK   ANOP  ,\n&CEC#P.ENT&I&SUFFIX CECDYN CREAT,0,C,,,'ENTRY OF LENGTH+PARAMETER'\n.*..+....1....+....2....+....3....+....4                              0\n.*..+....1....+....2....+....3....+....4                              1\n.*\n         AIF   (NOT &CEC#XLAT).NOXLAT2\n.*\n.XLATVV  ANOP  , WHEN &CEC#XLAT, SET &VALUE, &VALUE2, &LV\n.*             (NOTE: WHEN &CEC#XLAT, THEN &MAXJ IS 1, SO THIS CODE\n.*              IS NOT DONE EACH TIME THROUGH THE .NEXTJ02 LOOP)\n.*\n.*       &POS4 IS VALUES SPECIFIED BY CALLER;              (INDEX &K)\n.*       &POS9 IS TRANSLATION TABLE   ((R,2),(N,8),...)\n.*                               OR (+,(R,2),(N,8),...)    (INDEX &L)\n.* EACH TRANSLATION TABLE ENTRY CONSISTS OF:\n.*      &POS9(&L,1) <CHARS> FROM, AND &POS9(&L,2) <VALU> TO\n.*\n.* TWO LOOPS BELOW, LOOP BY &L WITHIN LOOP BY &K\n.*\n&VALUE   SETC  '&POS4'                 VALUE\n&VALUE2  SETC  '&KEY'                  COMMENT\n         AIF   (N'&POS9 EQ 0 AND N'&POS4 EQ 1).EXITK02 SKIP ENTIRELY\n.*\n.T#XLAT  CECDYN DEBUG,'.DOKEY T#XLAT' SAVE HEADING FOR DEBUG MESSAGES\n&VALUE   SETC  '0'                     INITIAL VALUE\n&VALUE2  SETC  ''                      INITIAL COMMENT\n         AIF   (N'&POS4 EQ 0).EXITK02\n&K       SETA  1\n.NEXTK02 ANOP  ,\n.*\n.* PROCESS ENTRY &POS4(&K) SPECIFIED BY USER\n.*\n&POS4K   SETC  '&POS4(&K)'\n         AIF   (N'&POS4 NE 1 OR &MAXJ NE 1).POS4KOK\n&POS4K   SETC  '&POS4'       PASS-THRU PARENS OF REGISTER OPERAND\n.POS4KOK ANOP  ,\n.*\n&LCLC    SETC  '0'                          DEFAULT VALUE\n&LCLC2   SETC  'IGNORE &POS4K'              DEFAULT COMMENT\n.*\n.*          IF (&K EQ 1) ALWAYS TRANSLATE FIRST USER-SPECIFIED VALUE:\n         AIF   (&K EQ 1).YESXLAT\n.*          IF WE ARE SUMMING, TRANSLATE ALL USER-SPECIFIED VALUES:\n         AIF   ('&POS9(1)' EQ '+' OR '&POS9(1)' EQ '''+''').YESXLAT\n         AGO   .SKIPXLT IF NOT SUMMING, ONLY TRANSLATE FIRST VALUE\n.YESXLAT ANOP  ,\n.*\n&L       SETA  1\n.NEXTL02 ANOP  ,\n         AIF   (N'&POS9(&L) NE 2).ADVL02 (SKIP NON-PAIRS IN &POS9)\n         AIF   ('&POS9(&L,1)' EQ '*').MATCH\n         AIF   ('&POS9(&L,1)' EQ '&POS4K').MATCH\n         AGO   .ADVL02\n.MATCH   ANOP  ,\n&LCLC    SETC  '&POS9(&L,2)'                RETURN VALUE\n&LCLC2   SETC  '&POS9(&L,1)=&POS9(&L,2)'    RETURN COMMENT\n         AGO   .EXITL02\n.ADVL02  ANOP  , ADVANCE &L\n&L       SETA  &L+1\n         AIF   (&L LE N'&POS9).NEXTL02\n.*\n.* WE REACH HERE IF &POS4K IS NOT FOUND IN THE TRANSLATE TABLE\n         AIF   ('&POS9(&L-1)' NE '*').EXITL02\n.* IF LAST ENTRY IN TRANSLATE TABLE IS '*', OK TO BE NOT-FOUND\n&LCLC    SETC  '&POS4K'                     RETURN VALUE\n&LCLC2   SETC  '&POS4K NOT TRANSLATED'      RETURN COMMENT\n.*\n.EXITL02 ANOP  , &LCLC=RETURN VALUE, &LCLC2=RETURN COMMENT\n.*\n.SKIPXLT ANOP  , SKIP TRANSLATION CODE ABOVE\n         AIF   (&K NE 1).ADDVALS ELSE SETVALS\n.SETVALS ANOP  ,\n&VALUE   SETC  '&LCLC'                 SET VALUE\n&VALUE2  SETC  '&KEY &LCLC2'           SET COMMENT\n         AGO   .ADVK02\n.ADDVALS ANOP  ,\n&VALUE   SETC  '&VALUE+&LCLC'          APPEND TO VALUE\n&VALUE2  SETC  '&VALUE2, &LCLC2'       APPEND TO COMMENT\n.ADVK02  ANOP  , ADVANCE &K\n&K       SETA  &K+1\n         AIF   (&K LE N'&POS4).NEXTK02\n         AGO   .EXITK02\n.*\n.EXITK02 ANOP  ,\n.*\n&LCLC    SETC  '&POS10'                           FETCH VALUE\n         AIF   (K'&LCLC LE 2).NOTCOMT             TOO SHORT FOR QUOTES\n         AIF   ('&LCLC'(1,1) NE '''').NOTCOMT       NOT LEADING QUOTE,\n         AIF   ('&LCLC'(K'&LCLC,1) NE '''').NOTCOMT NOR TRAILING.\n&LCLC    SETC  '&LCLC'(2,K'&LCLC-2)               REMOVE QUOTES\n.NOTCOMT ANOP  ,\n&VALUE2  SETC  '&VALUE2 &LCLC'\n.*\n         AIF   (&CEC#FLAG(1)).B#CHGV2      DC -- TEXT ONLY\n         AIF   (&CEC#FLAG(2)).B#CHGV2      DS -- TEXT ONLY\n         AIF   ('&VALUE2' NE '').X#CHGV2      ACTIVE -- DESCRIBE XLATE\n.* IF NO XLATE WAS DONE, FALL THRU TO TEXT ONLY\n.B#CHGV2 ANOP  ,\n&VALUE2  SETC  ''   LET IT BE OVERRIDDEN LATER\n.X#CHGV2 ANOP  ,\n.*\n&LV      SETA  &POS8(1)\n.*\n.NOXLAT2 ANOP  ,\n.*..+....1....+....2....+....3....+....4                              0\n.*..+....1....+....2....+....3....+....4                              1\n.*\n         AIF   (&CEC#XLAT).NOXCHK2\n.*\n.XCHKVV  ANOP  , WHEN NOT &CEC#XLAT, SET &VALUE, &VALUE2, &LV\n.*\n.* ANALYSE CALLER-SPECIFIED VALUE:\n.* &POS4(&J)=''      PRODUCES &NUL=1\n.*\n.* &POS4(&J)='...' PRODUCES &LIT=1\n.* &POS4(&J)=(...) PRODUCES &REG=1\n.* &POS4(&J)=A(...) PRODUCES &ACN=1\n.*   NOTE--IF A LIST WITH ONLY 1 ENTRY IS SPECIFIED, THAT IS &REG.\n&VALUE   SETC  '&POS4(&J)'\n         AIF   (N'&POS4 NE 1).BBVAL\n&VALUE   SETC  '&POS4'       PROPOGATE PARENS, SO &REG IS CORRECT\n.BBVAL   ANOP  ,\n.*\n&LIT     SETB  0             LITERAL\n&REG     SETB  0             REGISTER\n&ACN     SETB  0             ADDRESS CONSTANT\n&NUL     SETB  1             NULL -- OMITTED\n&LCLC    SETC   'POS4(J=&J.)=&VALUE.,'     PREPARE FOR DEBUGGING\n         AIF   (K'&VALUE EQ 0).ZZVAL             .* IF NULL SKIP\n         AIF   ('&VALUE' EQ '').ZZVAL            .* IF NULL SKIP\n&NUL     SETB  0                               .* RESET NULL IF NOT\n         AIF   (K'&VALUE LT 3).XXVAL TOO SHORT TO BE ANYTHING\n&LIT     SETB  ('&VALUE'(1,1) EQ '''' AND '&VALUE'(K'&VALUE,1) EQ '''')\n&LCLC    SETC   'POS4(J=&J.)='.'&VALUE'(2,K'&VALUE-2).','\n         AIF   (&LIT).ZZVAL\n&LCLC    SETC   'POS4(J=&J.)=&VALUE.,'     PREPARE FOR DEBUGGING\n&REG     SETB  ('&VALUE'(1,1) EQ '(' AND '&VALUE'(K'&VALUE,1) EQ ')')\n         AIF   (&REG).ZZVAL\n         AIF   (K'&VALUE LT 4).XXVAL TOO SHORT TO BE ACN\n&ACN     SETB  ('&VALUE'(1,2) EQ 'A(' AND '&VALUE'(K'&VALUE,1) EQ ')')\n         AIF   (&ACN).ZZVAL\n.XXVAL   ANOP  ,\n.ZZVAL   ANOP  ,\n         CECDYN DEBUG,'&LCLC NUL=&NUL, LIT=&LIT, REG=&REG, ACN=&ACN..'\n.*..+....1....+....2....+....3                                        0\n.*\n.A#LGH   CECDYN DEBUG,'.DOKEY A#LGH' SAVE HEADING FOR DEBUG MESSAGES\n.* DEFAULT VALUE LENGTH IS MAX VALUE LENGTH\n.* IF RANGE PERMITTED, AND CALLER SPECIFIED LITERAL VALUE,\n.*       THEN USE MAXIMUM OF (CALLER'S VALUE'S LENGTH, MINIMUM LENGTH)\n.*       &POS4 IS (VALUES) SPECIFIED BY CALLER;\n.*       &POS8 IS LENGTH OF EACH VALUE EXPECTED\n         AIF   ((N'&POS8-1)*(N'&POS8-2) EQ 0).B#LGH\n         MNOTE 4,'INTERNAL ERROR PROCESSING KEY &POS3 -- &&POS8 SHOULD X\n               HAVE ONLY 1 OR 2 ENTRIES, IT WAS \"&POS8\"'\n.B#LGH   ANOP  ,\n.* IF N'&POS8=1, A FIXED LENGTH IS EXPECTED,  &POS8(1)\n.* IF N'&POS8=2, MINIMUM LENGTH EXPECTED IS &POS8(1), MAX IS &POS8(2)\n&LMIN    SETA  &POS8(1)      MUST BE SELF-DEFINING DECIMAL TERM\n&LMAX    SETA  &POS8(N'&POS8) MUST BE SELF-DEFINING DECIMAL TERM\n&LV      SETA  &LMAX         DEFAULT VALUE LENGTH IS MAX VALUE LENGTH\n         AIF   (N'&POS8 EQ 1).G#LGH OK--ONLY 1, USE THAT LENGTH\n         AIF   (NOT &LIT).G#LGH       OK--USE MAX (OR ONLY) LENGTH\n&LV      SETA  &LMIN         DEFAULT VALUE LENGTH IS MIN VALUE LENGTH\n&LCLA2   SETA  K'&POS4(&J)-2 LENGTH OF VALUE SPECIFIED (W/O QUOTES)\n         AIF   (&LCLA2 LT &LMIN).G#LGH  OK--FORCE MINIMUM LENGTH\n&LV      SETA  &LCLA2        OK--USE CALLER'S VALUE'S LENGTH\n.G#LGH   ANOP  ,\n.X#LGH   ANOP  ,\n         CECDYN DEBUG,' POS8=&POS8.; MIN=&LMIN., MAX=&LMAX..'\n&LCLC    SETC  'K''''POS4(J=&J.)=K'''''.'&POS4(&J).=&LCLA2.;'\n&LCLC    SETC  '&LCLC. LENGTH USED IS LV=&LV..'\n         CECDYN DEBUG,'&LCLC'\n.*\n&VALUE2  SETC  ''   LET IT BE OVERRIDDEN LATER\n.*\n.NOXCHK2 ANOP  ,                                                      0\n.*..+....1....+....2....+....3....+....4                              -\n.*..+....1....+....2....+....3....+....4                              -\n&I1      SETA  &I-10*(&I/10)           1'S DIGIT OF &I\n&I10     SETA  (&I/10)-10*(&I/100)     10'S DIGIT OF &I\n&IIX     SETA  1+3*(&I1*(&I10-1)/(&I10-1)) IGNORE &I1 IF (&I10-1) EQ 0\n&ITH     SETC  'TH ST ND RD TH TH TH TH TH TH '(&IIX,2) 0TH, 1ST, ETC.\n.*..+....1\n&J1      SETA  &J-10*(&J/10)           1'S DIGIT OF &J\n&J10     SETA  (&J/10)-10*(&J/100)     10'S DIGIT OF &J\n&JIX     SETA  1+3*(&J1*(&J10-1)/(&J10-1)) IGNORE &J1 IF (&J10-1) EQ 0\n&JTH     SETC  'TH ST ND RD TH TH TH TH TH TH '(&JIX,2) 0TH, 1ST, ETC.\n.*..+....1\n&CEC#P.LNG&I&SUFFIX CECDYN CREAT,,A,2,&LV,                             X\n               'LENGTH OF &J&JTH PARM. OF &I&ITH KEY'\n         AIF   (&J NE 1).NOLABEL             LABEL ONLY FOR FIRST\n.******* AIF   ('&POS9' NE '*').NOLABEL Q. MUST WE DEFINE NAME? A. NO\n.*                                                              A. YES\n         AIF   ('&POS9' NE '*' AND '&CEC#CMT2VAL' EQ '.XLAT').NOLABEL\n.* (FOR .XCHK, FALL THROUGH ALL THE TIME)\n.*\n&LCLC    SETC  '&CEC#P'.'&KEY'(4,K'&KEY-3)\n&LCLC    CECDYN CREAT,0,&POS7,&LV,,'DEFINE NAME FOR USER'\n.NOLABEL ANOP  ,\n.*\n         AIF   ('&VALUE2' NE '').NOTNULL\n&VALUE2  SETC  'VALUE OF &J&JTH PARM. OF &I&ITH KEY' OVERRIDE HERE\n.NOTNULL ANOP  ,\n.*\n&CEC#P.PAR&I&SUFFIX CECDYN CREAT,,&POS7,&LV,&VALUE,'&VALUE2'\n.*..+....1....+....2....+....3                                        0\n.*\n.ADVJ02  ANOP  , ADVANCE &J\n&J       SETA  &J+1\n         AIF   (&J LE &MAXJ).NEXTJ02\n.*\n         AGO   .SUBEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.MNOTE   ANOP  , SELF-CALL INTERNAL ROUTINE -- MNOTE '&POS2&POS3...'\n&LCLC    SETC  ''\n.*\n&J       SETA  2\n.NEXTJ04 ANOP  ,\n.*\n.*\n         AIF   ('&SYSLIST(&J)' EQ '').EXITI04\n&LCLB    SETB  ('&SYSLIST(&J)'(1,1) EQ '''' AND                        X\n                             '&SYSLIST(&J)'(K'&SYSLIST(&J),1) EQ '''')\n.* QUOTES AT BOTH ENDS?\n&I       SETA  1+&LCLB    IF YES, SKIP BEGINNING QUOTE\n.NEXTI04 ANOP  ,\n         AIF   (K'&LCLC GE 254).EXITI04      .TOOBIG\n         AIF   ('&SYSLIST(&J)'(&I,1) EQ '''').DOUBLE\n         AIF   ('&SYSLIST(&J)'(&I,1) EQ '&&').DOUBLE\n&LCLC    SETC  '&LCLC'.'&SYSLIST(&J)'(&I,1)\n         AGO   .ADVI04\n.TOOBIG  MNOTE '&&LCLC TOO LONG -- &&J=&J -- &&I=&I -- &&LCLC=\"&LCLC\"'\n         AGO   .ADVI04\n.DOUBLE  ANOP  ,\n&LCLC    SETC  '&LCLC'.'&SYSLIST(&J)'(&I,1).'&SYSLIST(&J)'(&I,1)\n         AGO   .ADVI04\n.ADVI04  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE K'&SYSLIST(&J)-&LCLB).NEXTI04 SKIP ENDING QUOTE\n.EXITI04 ANOP  ,\n.*\n.*\n.ADVJ04  ANOP  , ADVANCE &J\n&J       SETA  &J+1\n         AIF   (&J LE N'&SYSLIST).NEXTJ04\n.EXITJ04 ANOP  ,\n.*\n         MNOTE '&LCLC'                                                -\n         AGO   .SUBEXIT                                               -\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n         MEND ,                                                       0\n         AGO   .SKIPTEXT\n                                                                      1\n@P\n1* (C) COPYRIGHT CENTERIOR ENERGY CORPORATION 1988,1991\n-CECDYN -- macro for building Dynamic Allocation parameter list\n-     This macro builds a parameter list which can be used by SVC 99.\n      It does not issue a call to SVC 99, it only builds the parameter\n      list in storage and returns control.\n0     Unlike the IBM-supplied macros, instead of calculating offsets\n      into the parameter list to store values into it, a dummy control\n      section and symbolic names are generated and used.  If a USING\n      is issued on the dummy section, the symbolic names can then be\n      used to modify the parameter list.  All symbolic names generated\n      by one call to CECDYN start with the same three characters.  The\n      three characters can be specified by the caller, or will be\n      assigned by the macro.\n0     The standard form of the CECDYN macro instruction is written\n      as follows:\n\n>     ----------------------------------------------------------------\n0     <name>              <name>: symbol.  Begin <name> in column 1.\n0     b\n+     /                   One or more blanks must precede CECDYN.\n0     CECDYN\n0     b\n+     /                   One or more blanks must follow CECDYN.\n\n>     ----------------------------------------------------------------\n0     VERB=<verb>         <verb>: two byte character string\n0     ,PREFIX=<prefix>    <prefix>: maximum-of-3 byte character string\n0     ,FLG11=(<flg11>)\n      ,FLG21=(<flg21>)\n      ,FLG22=(<flg22>)    <flg11>/<flg21>/<flg22>: one or more 5 byte\n                          character strings, seperated by commas.  For\n                          example, FLG##=(<flg##>,<flg##>,<flg##>) .\n                          If only one <flg##> is specified, the outer\n                          parentheses may be omitted.\n0     ,TEXT=(<text unit>) <text unit>: either a maximum-of-5 byte\n                          character string, or a parenthesized pair\n                          consisting of a maximum-of-5 byte character\n                          string plus one of: literal delimited by\n                          quotes, A-type address, register (2)-(12).\n                          If only one <text unit> is specified, the\n                          outer parentheses must still be coded.\n                          Note:  <text unit> is one or more text\n                          units, seperated by commas.  For example,\n                          TEXT=(<text unit>,<text unit>,<text unit>)\n0     ,LIST=NO            Default: LIST=YES\n      ,LIST=YES\n\n>     ----------------------------------------------------------------\n-     The parameters are explained below:\n-     VERB=<verb>\n0       specifies the SVC 99 function requested.  The two bytes\n        supplied will be prepended with 'S99VRB' to build a symbol\n        which specifies a verb code.  The seven verb codes are defined\n        in the IBM-supplied macro IEFZB4D0, described in \"System\n        Macros and Facilities\".\n0       No checking is done for validity, but values not defined in\n        IEBZB4D0 will create undefined symbols.\n0       There is no default for this parameter.\n-     FLG11=<flg11>\n      FLG21=<flg21>\n      FLG22=<flg22>\n0       specify certain available options.  Each 5 bytes supplied will\n        be prepended with 'S99' to build a symbol which specifies an\n        option, and all the <flg11> will be summed to produce FLG11,\n        all the <flg21> will be summed to produce FLG21, all the\n        <flg22> will be summed to produce FLG22.\n        FLG11 options are available to all SVC 99 callers.\n        FLG21 & FLG22 options are only available to authorized\n        callers.\n        The options available are defined in IBM-supplied macro\n        IEFZB4D0, described in \"System Macros and Facilities\".\n0       No checking is done for validity, but values not defined in\n        IEBZB4D0 will create undefined symbols.\n-     Note: No checking is done that a FLG11 option is specified for\n        FLG21, etc., or vice versa.  It will not cause an assembly\n        error, but results are unpredictable.\n-     ,PREFIX=<prefix>\n        optionally supplies up-to-3 characters to be used in building\n        the symbolic names for fields in the parameter list.  If not\n        specified, CECDYN will create a 3-character prefix dependent\n        on the assembler system variable &SYSNDX.  The prefix created\n        by CECDYN will start with an alphabetic character which will\n        range through A thru Z, and its next two characters will each\n        range through 0 thru 9 and A thru Z, the last character\n        varying most quickly, as &SYSNDX increases.\n        The dummy section created is named <prefix>DSECT, and it's\n        length is available as L'<prefix>DSECT .\n-     ,TEXT=(<text unit>)\n        specifies the text units to be placed in the parameter list.\n        Each text unit specified will usually be a parenthesized pair\n        consisting of a maximum-of-5 byte character string plus one\n        of:  literal delimited by quotes, A-type address, register\n        (2)-(12).\n        The character string will be prepended with the character 'D'\n        plus the VERB specified, to make a symbol which is defined in\n        the IBM-supplied macro IEFZB4D2, described in \"System Macros\n        and Facilities\".\n0       No checking is done for validity of the character string, but\n        values not defined in IEBZB4D2 will create undefined symbols.\n0       Some text units do not require a value, and these will be\n        specified by only the maximum-of-5 byte character string.  For\n        these, the inner parentheses may be omitted.\n0       If no text units are specified, only the request block pointer\n        and the request block are built.  If null text units are\n        specified, then text unit pointers with a value of zero are\n        built.\n0       Certain text units may have multiple values specified which\n        are then summed to build one value (DALOPTCD).  These, and\n        others, may have their values specified as character strings\n        which are then translated by CECDYN to be the proper hex\n        values -- For example, (STATS,OLD) will generate a value of\n        X'01'.  If you wish, you may code the actual hex value.\n0       Certain other text units may have multiple values which create\n        multiple fields in the parameter list (DALVLSER,etc.)  CECDYN\n        will check whether multiple values are specified for a text\n        unit which does not allow multiple values.\n0     ,LIST=NO\n      ,LIST=YES\n        specifies whether or not generated code is to be printed.\n        If this parameter is not specifed, a default of YES is used.\n-     When control is returned, register 1 points to the parameter\n      list.  SVC 99 can be issued immediately, or the parameter list\n      can be modified before issuing SVC 99.\n      The addresses of text units are stored in the parameter list\n      starting at the location labelled <prefix>TUPL.  The address of\n      each text unit is stored in the parameter list in field\n      <prefix>PTR<#>, where <prefix> is the PREFIX specified or\n      generated, and <#> ranges from 1 through the number of text\n      units specified.  Each text unit begins at the field labelled\n      <prefix>TU<#>.  Each text unit will always have a KEY subfield\n      <prefix>KEY<#> containing the text unit key, and a NUMBER\n      subfield <prefix>NUM<#> containing the number of length and\n      parameter combinations in the text unit.  Some text units will\n      have only these two subfields, if its NUMBER subfield has a\n      value of zero.\n-Example 1\n0     Operation: Unallocate the data set associated with ddname\n      IEFRDER.  CECDYN will assign a 3-byte prefix to the names\n      generated.\n0     NAME     CECDYN VERB=UN,TEXT=((DDNAM,'IEFRDER'))\n               DYNALLOC\n               LTR   15,15          WAS SVC99 SUCCESSFUL ?\n               ...\n0\n-Example 2\n0     Operation: Request all available information text units, for the\n      data set currently allocated to the ddname stored in symbol\n      WRKDD.  Returned information will be in the fields ZZZRTLST,\n      ZZZRTDDN, etc.\n      These fields will be accessible by issuing a USING ZZZDSECT,1 .\n0     INFORM   CECDYN  PREFIX=ZZZ,                                     X\n                     VERB=IN,                                          X\n                     TEXT=((DDNAM,WRKDD),                              X\n                     RTLST,RTDDN,RTDSN,RTMEM,RTSTA,                    X\n                     RTNDP,RTCDP,RTORG,RTLIM,RTATT,RTTYP)\n               DYNALLOC\n               LTR   15,15          WAS SVC99 SUCCESSFUL ?\n               BNZ   ERROR          NO.\n               USING ZZZDSECT,1     ADDRESSABILITY TO PARAMETER LIST\n               MVC   LASTIND,ZZZRTLST\n               MVC   MEMBER,ZZZRTMEM\n               ...\n-Example 3\n0     Operation: Build a list to be modified later.  In the list,\n      specify 'do not mount volumes or consider offline devices'.\n      Reserve space for 5 text unit addresses.  Modify the first three\n      addresses by using the list form of the CALL macro instruction.\n0     ALLOCIT  CECDYN  PREFIX=Q02,                                     X\n                     VERB=AL,                                          X\n                     FLG11=NOMNT,                                      X\n                     TEXT=(,,,,)\n               USING Q02DSECT,1\n               MVC   Q02TUPL(CALLISTX-CALLIST),CALLIST\n               DYNALLOC\n               LTR   15,15          WAS SVC99 SUCCESSFUL ?\n               ...\n               ...\n      CALLIST  CALL  ,(THIS,THAT,OTHER),VL,MF=L\n      CALLISTX EQU   *\n1\n-CECDYN (List Form)\n-     The list form of the CECDYN macro instruction is used to\n      construct a nonexecutable SVC 99 parameter list.  This list form\n      generates only ADCONs of the text unit parameters.  This\n      parameter list can be referred to in the execute form of a\n      CECDYN macro instruction.\n0     The list form of the CECDYN macro instruction is written as\n      follows:\n\n>     ----------------------------------------------------------------\n0     <name>              <name>: symbol.  Begin <name> in column 1.\n0     b\n+     /                   One or more blanks must precede CECDYN.\n0     CECDYN\n0     b\n+     /                   One or more blanks must follow CECDYN.\n\n>     ----------------------------------------------------------------\n0     VERB=<verb>         <verb>: two byte character string\n0     ,PREFIX=<prefix>    <prefix>: maximum-of-3 byte character string\n0     ,FLG11=(<flg11>)\n      ,FLG21=(<flg21>)\n      ,FLG22=(<flg22>)    <flg11>/<flg21>/<flg22>: one or more 5 byte\n                          character strings, seperated by commas.  For\n                          example, FLG##=(<flg##>,<flg##>,<flg##>) .\n                          If only one <flg##> is specified, the outer\n                          parentheses may be omitted.\n0     ,TEXT=(<text unit>) <text unit>: either a maximum-of-5 byte\n                          character string, or a parenthesized pair\n                          consisting of a maximum-of-5 byte character\n                          string plus one of: literal delimited by\n                          quotes, A-type address, register (2)-(12).\n                          If only one <text unit> is specified, the\n                          outer parentheses must still be coded.\n                          Note: <text unit> is one or more text units,\n                          seperated by commas.  For example,\n                          TEXT=(<text unit>,<text unit>,<text unit>)\n0     ,LIST=NO            Default: LIST=YES\n      ,LIST=YES\n0     ,MF=L\n\n>     ----------------------------------------------------------------\n-     The parameters are explained under the standard form of the\n      CECDYN macro instruction, with the following exception:\n-     MF=L\n0       specifies the list form of the CECDYN macro instruction.\n1\n-CECDYN (Execute Form)\n-     A remote SVC 99 parameter list is referred to and can be\n      modified by the execute form of the CECDYN macro instruction.\n      Only executable instructions are generated.  The first time a\n      particular PREFIX is used, a DSECT is defined.  Each execute\n      form CECDYN macro instruction later in a program which uses the\n      same PREFIX must have the same VERB as specified on the list\n      form CECDYN macro instruction, or symbolic names referred-to in\n      the generated code will not be previously defined.  A\n      combination of FLG11, FLG21, and FLG22 values can be specified\n      that is different than that specified on the list form CECDYN\n      macro instruction.\n      The TEXT may have fewer entries specified, but should have no\n      new maximum-of-5 byte character strings which were not on the\n      list form CECDYN macro instruction.\n0     The execute form of the CECDYN macro instruction is written as\n      follows:\n\n>     ----------------------------------------------------------------\n0     <name>              <name>: symbol.  Begin <name> in column 1.\n0     b\n+     /                   One or more blanks must precede CECDYN.\n0     CECDYN\n0     b\n+     /                   One or more blanks must follow CECDYN.\n\n>     ----------------------------------------------------------------\n0     VERB=<verb>         <verb>: two byte character string\n0     ,PREFIX=<prefix>    <prefix>: maximum-of-3 byte character string\n0     ,FLG11=(<flg11>)\n      ,FLG21=(<flg21>)\n      ,FLG22=(<flg22>)    <flg11>/<flg21>/<flg22>: one or more 5 byte\n                          character strings, seperated by commas.  For\n                          example, FLG##=(<flg##>,<flg##>,<flg##>) .\n                          If only one <flg##> is specified, the outer\n                          parentheses may be omitted.\n0     ,TEXT=(<text unit>) <text unit>: either a maximum-of-5 byte\n                          character string, or a parenthesized pair\n                          consisting of a maximum-of-5 byte character\n                          string plus one of: literal delimited by\n                          quotes, A-type address, register (2)-(12).\n                          If only one <text unit> is specified, the\n                          outer parentheses must still be coded.\n                          Note: <text unit> is one or more text units,\n                          seperated by commas.  For example,\n                          TEXT=(<text unit>,<text unit>,<text unit>)\n0     ,LIST=NO            Default: LIST=YES\n      ,LIST=YES\n0     ,MF=(E,<remote addr>)\n                          <remote addr>: RX-type address, or register\n                          (1) or (2)-(12).\n\n>     ----------------------------------------------------------------\n-     The parameters are explained under the standard form of the\n      CECDYN macro instruction, with the following exception:\n-     MF=(E,<remote addr>)\n0       specifies the execute form of the CECDYN macro instruction.\n        The text units specified are built at the address specified in\n        the MF parameter.\n9SYS2.CEI.MACLIB(CECDYN)                                   08-MAR-1991\n.SKIPTEXT ANOP ,\n./       ADD   NAME=CONTINUE\n         MACRO ,\n&NAME    CONTINUE ,\n.* DATE.     28-JUL-1989\n.* REMARKS.  THIS MACRO WORKS WITH THE MACROS WRITTEN BY DON HIGGINS,\n.*          FOUND ON FILE 078 OF SHARE MVS GROUP MODS TAPE, V29 (04/84)\n.*  SEE CASE,DOCASE,DOMACRO,EQUBC,ELSE,ELSEIF,ESAC,ESACOD,FI,IF,OD;\n.*  AND BREAK.\n         GBLA  &DO(10),&DOSEQ(10),&DOLVL,&DOLAB\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n&NAME    B     DO&DO(&DOLVL)       GO IMMEDIATELY TO TEST PART OF LOOP\n         MEND  ,\n./       ADD   NAME=DOMACRO\n*          DATA SET AM010800   AT LEVEL 001 AS OF 10/28/75\n*          DATA SET AM010800   AT LEVEL 004 AS OF 08/14/74\n         MACRO\n         DO\n         GBLA  &DO(10),&DOSEQ(10),&DOLVL,&DOLAB\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n         LCLA  &N,&M,&S,&LAB1,&L,&I\n         LCLA  &UNTIL\n         LCLC  &OP,&OPR\n         LCLB  &TESTSW\n         EQUBC ,             DEFINE CONDITIONS, IF NOT ALREADY DEFINED\n.*             AUTHOR.   DON HIGGINS.\n.*             DATE.     03/27/74.\n.*             REMARKS.  MACRO TO ALLOW STRUCTURED PROGRAMMING USING\n.*                       IF, THEN, ELSE, AND DO UP TO TEN LEVELS DEEP\n.*                       AND NO BRANCH INSTRUCTIONS. SEE IF MACRO.\n         AIF   (&DOLVL EQ 10).ERR1\n&N       SETA  N'&SYSLIST\n         AIF   (&N LT 1).ERR2\n         AIF   ('&SYSLIST(1)' EQ 'END').END\n         AIF   ('&SYSLIST(1)' EQ 'FOREVER').WHILE\n         AIF   (&N LT 2).ERR2\n         AIF   ('&SYSLIST(1)' EQ 'WHILE').WHILE\n         AIF   ('&SYSLIST(1)' NE 'UNTIL').ERR3\n.UNTIL   ANOP\n&DOLVL   SETA  &DOLVL+1\n&UNTIL   SETA  &DOLAB+1\n&DOLAB   SETA  &DOLAB+2\n         B     DO&UNTIL\n         AGO   .COMM\n.WHILE   ANOP\n&DOLVL   SETA  &DOLVL+1\n&DOLAB   SETA  &DOLAB+1\n.COMM    ANOP\n&DOSEQ(&DOLVL) SETA 1\n&DO(&DOLVL) SETA &DOLAB\nDO&DOLAB EQU   *\n         AIF   (&LEVEL EQ 10).ERR1\n&LEVEL   SETA  &LEVEL+1\n&SEQ(&LEVEL) SETA 1\n&LAB     SETA  &LAB+1\n&ELSE(&LEVEL) SETA &LAB\n         AIF   ('&SYSLIST(1)' EQ 'FOREVER').EXIT\n&S       SETA  1\n.NEXTAND ANOP\n&TESTSW  SETB  0\n.TEST    ANOP\n&S       SETA  &S+1\n         AIF   (&S GT &N).ERR2\n&M       SETA  N'&SYSLIST(&S)\n         AIF   (&M LT 2).ERR3\n         AIF   (&M GT 5).ERR3\n&I       SETA  2\n&OPR     SETC  ''\n&OP      SETC  '&SYSLIST(&S,1)'\n         AIF   (&M GT 2).TESTOPR\n         &OP\n         AGO   .TESTEND\n.TESTOPR ANOP\n         AIF   ('&SYSLIST(&S,&I)'(1,1) NE '''').NOLIT\n&L       SETA  K'&SYSLIST(&S,&I)\n&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'(2,&L-2)\n         AGO   .NEXTOPR\n.NOLIT   ANOP\n&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'\n.NEXTOPR ANOP\n&I       SETA  &I+1\n         AIF   (&I EQ &M).TESTGEN\n&OPR     SETC  '&OPR'.','\n         AGO   .TESTOPR\n.TESTGEN ANOP\n         &OP   &OPR\n.TESTEND ANOP\n         AIF   (&TESTSW EQ 1).ORBC\n.AMBC    ANOP\n         BC    15-&SYSLIST(&S,&M),IF0&LAB\n.CONNECT ANOP\n&S       SETA  &S+1\n         AIF   (&S GT &N).CHKUNTL\n&M       SETA  N'&SYSLIST(&S)\n         AIF   (&M NE 1).ERR3  BAD CONNECTOR\n         AIF   ('&SYSLIST(&S)' EQ 'AND').NEXTAND\n         AIF   ('&SYSLIST(&S)' NE 'OR').ERR3  BAD CONNECTOR\n.NEXTOR   ANOP\n&LAB1    SETA  &LAB+1\n         B     IF0&LAB1  SKIP TEST IF LAST ONE TRUE\nIF0&LAB   EQU *          DO TEST IF LAST ONE FALSE\n&LAB     SETA  &LAB+2\n&ELSE(&LEVEL) SETA &LAB\n&TESTSW  SETB  1\n         AGO   .TEST\n.ORBC    ANOP\n         BC    15-&SYSLIST(&S,&M),IF0&LAB\nIF0&LAB1 EQU *\n         AGO   .CONNECT\n.CHKUNTL ANOP\n         AIF   (&UNTIL EQ 0).EXIT\n&LAB     SETA  &LAB+1\n         B     IF0&LAB\nIF0&ELSE(&LEVEL) EQU *\n&ELSE(&LEVEL) SETA &LAB\nDO&UNTIL EQU *\n         AGO   .EXIT\n.END     ANOP\n         AIF   (&N GT 1).ERR3\n         AIF   (&DOLVL EQ 0).ERR4\n         AIF   (&DOSEQ(&DOLVL) NE 1).ERR4\n&DOSEQ(&DOLVL) SETA 0\n         B     DO&DO(&DOLVL)\n&DOLVL   SETA  &DOLVL-1\nIF0&ELSE(&LEVEL) EQU *\n&LEVEL   SETA  &LEVEL-1\n         AGO   .EXIT\n.ERR1    MNOTE 8,'DO - LEVEL OVERFLOW'\n         AGO   .EXIT\n.ERR2    MNOTE 8,'DO - MISSING OPERAND'\n         AGO   .EXIT\n.ERR3    MNOTE 8,'DO - INVALID OPERAND'\n         AGO   .EXIT\n.ERR4    MNOTE 8,'DO - END OUT OF SEQUENCE'\n.EXIT    ANOP\n         MEND\n./       ADD   NAME=ELSE\n* COPIED FROM FILE 078 OF SHARE MVS GROUP MODS TAPE, V29 (04/84)\n*          DATA SET AM010700   AT LEVEL 003 AS OF 05/23/76\n         MACRO\n         ELSE  &OPT\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n         GBLA  &ELSEIF(10)\n.* AUTHOR.   DON HIGGINS.\n.* DATE.     03/27/74.\n.* REMARKS.  MACRO TO ALLOW STRUCTURED PROGRAMMING USING\n.*           IF, THEN, ELSE, AND DO UP TO TEN LEVELS DEEP\n.*           AND NO BRANCH INSTRUCTIONS. SEE IF MACRO.\n.* REV1 05/23/76 DSH - SUPPORT ELSEIF\n         AIF   (&LEVEL EQ 0).ERR0\n         AIF   (T'&OPT EQ 'O').BEGIN\n         AIF   ('&OPT' EQ 'BEGIN').BEGIN\n         AIF   ('&OPT' EQ 'END').END\n         AIF   ('&OPT' EQ 'CONTINUE').CONT\n         MNOTE 8,'ELSE - INVALID OPERAND'\n         AGO   .EXIT\n.BEGIN   ANOP  ,\n         AIF   (&SEQ(&LEVEL) GT 3).ERR1\n&LAB     SETA  &LAB+1\n         B     IF0&LAB\nIF0&ELSE(&LEVEL) EQU *\n&ELSE(&LEVEL) SETA &LAB\n&SEQ(&LEVEL) SETA 4\n         AGO .EXIT\n.END     ANOP  ,\n         AIF   (&SEQ(&LEVEL) NE 4).ERR2\n.DEQUE   ANOP  ,\nIF0&ELSE(&LEVEL) EQU *\n&LEVEL   SETA &LEVEL-1\n         AIF   (&ELSEIF(&LEVEL+1) EQ 1).DEQUE\n         AGO   .EXIT\n.CONT    ANOP  ,\n         AIF   (&SEQ(&LEVEL) GT 3).ERR3\n         AGO   .DEQUE\n.ERR0    MNOTE 8,'ELSE - MISSING IF'\n         AGO   .EXIT\n.ERR1    MNOTE 8,'ELSE BEGIN - OUT OF SEQUENCE'\n         AGO   .EXIT\n.ERR2    MNOTE 8,'ELSE END - OUT OF SEQUENCE'\n         AGO   .EXIT\n.ERR3    MNOTE 8,'ELSE CONTINUE - OUT OF SEQUENCE'\n.EXIT    ANOP  ,\n         MEND  ,\n./       ADD   NAME=ELSEIF\n* COPIED FROM FILE 078 OF SHARE MVS GROUP MODS TAPE, V29 (04/84)\n*          DATA SET AM013600   AT LEVEL 002 AS OF 05/23/76\n         MACRO ,\n         ELSEIF ,\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n         GBLA  &ELSEIF(10)\n         LCLA  &N,&M,&S,&LAB1,&L,&I\n         LCLC  &OP,&OPR\n         LCLB  &TESTSW\n.* AUTHOR.   DON HIGGINS.\n.* DATE.     05/23/76.\n.* REMARKS.  CONTROL STRUCTURE FOR CONDITIONAL EXECUTION.\n         AIF   (&LEVEL EQ 10).ERR1\n         ELSE  ,\n&LEVEL   SETA  &LEVEL+1\n&ELSEIF(&LEVEL) SETA 1\n&SEQ(&LEVEL) SETA 1\n&LAB     SETA  &LAB+1\n&ELSE(&LEVEL) SETA &LAB\n&N       SETA N'&SYSLIST\n.NEXTAND ANOP  ,\n&TESTSW  SETB  0\n.TEST    ANOP  ,\n&S       SETA  &S+1\n         AIF   (&S GT &N).ERR2\n&M       SETA  N'&SYSLIST(&S)\n         AIF   (&M EQ 1).TESTEND\n         AIF   (&M LT 2).ERR3\n         AIF   (&M GT 5).ERR4\n&I       SETA  2\n&OPR     SETC  ''\n&OP      SETC  '&SYSLIST(&S,1)'\n         AIF   (&M GT 2).TESTOPR\n         &OP                                                         ,\n         AGO   .TESTEND\n.TESTOPR ANOP  ,\n         AIF   ('&SYSLIST(&S,&I)'(1,1) NE '''').NOLIT\n&L       SETA  K'&SYSLIST(&S,&I)\n&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'(2,&L-2)\n         AGO   .NEXTOPR\n.NOLIT   ANOP  ,\n&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'\n.NEXTOPR ANOP  ,\n&I       SETA  &I+1\n         AIF   (&I EQ &M).TESTGEN\n&OPR     SETC  '&OPR'.','\n         AGO   .TESTOPR\n.TESTGEN ANOP  ,\n         &OP   &OPR                                                  ,\n.TESTEND ANOP  ,\n         AIF   (&TESTSW EQ 1).ORBC\n.AMBC    ANOP  ,\n         BC    15-&SYSLIST(&S,&M),IF0&LAB\n.CONNECT ANOP  ,\n&S       SETA  &S+1\n         AIF   (&S GT &N).EXIT\n&M       SETA  N'&SYSLIST(&S)\n         AIF   (&M NE 1).ERR5  BAD CONNECTOR\n         AIF   ('&SYSLIST(&S)' EQ 'AND').NEXTAND\n         AIF   ('&SYSLIST(&S)' NE 'OR').ERR5  BAD CONNECTOR\n.NEXTOR   ANOP ,\n&LAB1    SETA  &LAB+1\n         B     IF0&LAB1  SKIP TEST IF LAST ONE TRUE\nIF0&LAB   EQU *          DO TEST IF LAST ONE FALSE\n&LAB     SETA  &LAB+2\n&ELSE(&LEVEL) SETA &LAB\n&TESTSW  SETB  1\n         AGO   .TEST\n.ORBC    ANOP  ,\n         BC    15-&SYSLIST(&S,&M),IF0&LAB\nIF0&LAB1 EQU *\n         AGO   .CONNECT\n.ERR1    MNOTE 8,'IF - LEVEL OVERFLOW'\n         AGO   .EXIT\n.ERR2    MNOTE 8,'IF - MISSING TEST LIST'\n         AGO   .EXIT\n.ERR3    MNOTE 8,'IF - TEST LIST TOO SHORT'\n         AGO   .EXIT\n.ERR4    MNOTE 8,'IF - TEST LIST TOO LONG'\n         AGO   .EXIT\n.ERR5    MNOTE 8,'IF - INVALID CONNECTOR'\n.EXIT    ANOP  ,\n         MEND  ,\n./       ADD   NAME=EQUBC\n* MODIFIED 03-JUN-1989 TO ACT LIKE IEZBITS (MULTIPLE CALLS OK)\n*          DATA SET AM010900   AT LEVEL 001 AS OF 10/28/75\n*          DATA SET AM010900   AT LEVEL 002 AS OF 04/02/74\n         MACRO ,\n         EQUBC ,\n         GBLA  &EQUBC\n         AIF   (&EQUBC EQ 0).SETSW\n         MEXIT ,\n.SETSW   ANOP  ,\n&EQUBC   SETA  1\n         SPACE 2\nH        EQU   2\nL        EQU   4\nE        EQU   8\nNH       EQU   13\nNL       EQU   11\nNE       EQU   7\nO        EQU   1\nP        EQU   2\nM        EQU   4\nZ        EQU   8\nNP       EQU   13\nNM       EQU   11\nNZ       EQU   7\nNO       EQU   14\nEQ       EQU   8\nGT       EQU   2\nLT       EQU   4\nGE       EQU   11\nLE       EQU   13\n         MEND  ,\n./       ADD   NAME=FI\n*          DATA SET AM011000   AT LEVEL 001 AS OF 10/28/75\n*          DATA SET AM011000   AT LEVEL 001 AS OF 06/28/74\n         MACRO\n&N       FI\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n         AIF   (&SEQ(&LEVEL) NE 4).CONT\n&N       ELSE  END\n         MEXIT\n.CONT    ANOP\n&N       ELSE  CONTINUE\n         MEND\n./       ADD   NAME=IF\n* COPIED FROM FILE 078 OF SHARE MVS GROUP MODS TAPE, V29 (04/84)\n*          DATA SET AM010500   AT LEVEL 002 AS OF 05/23/76\n*          DATA SET AM010500   AT LEVEL 001 AS OF 10/28/75\n*          DATA SET AM010500   AT LEVEL 001 AS OF 04/01/74\n         MACRO ,\n         IF    ,\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n         GBLA  &ELSEIF(10)\n         LCLA  &N,&M,&S,&LAB1,&L,&I\n         LCLC  &OP,&OPR\n         LCLB  &TESTSW\n         EQUBC ,             DEFINE CONDITIONS, IF NOT ALREADY DEFINED\n.* AUTHOR.   DON HIGGINS.\n.* DATE.     03/27/74.\n.* REMARKS.  MACRO TO ALLOW STRUCTURED PROGRAMMING USING\n.*           IF, THEN, ELSE, AND DO UP TO TEN LEVELS DEEP\n.*           AND NO BRANCH INSTRUCTIONS.\n.*\n.*           EXAMPLE FORM.\n.*               SAMPLE  SUBENTRY\n.*                       IF (CLI,FLAG,TRUE,EQ)\n.*                       THEN BEGIN\n.*                            DO  WHILE,(CLC,A,B,NE)\n.*                               PERFORM R100PROC,R190EXIT\n.*                            DO END\n.*                       THEN END\n.*                       ELSE BEGIN\n.*                            PERFORM R200LIST,R290EXIT\n.*                       ELSE END\n.*                       IF (CLI,SW,TRUE,EQ),AND,(SRC,R1,E)\n.*                            PERFORM R300RPT,R390EXIT\n.*                       ELSE CONTINUE\n.*                       SUBEXIT\n         AIF   (&LEVEL EQ 10).ERR1\n&LEVEL   SETA  &LEVEL+1\n&ELSEIF(&LEVEL) SETA 0\n&SEQ(&LEVEL) SETA 1\n&LAB     SETA  &LAB+1\n&ELSE(&LEVEL) SETA &LAB\n&N       SETA N'&SYSLIST\n.NEXTAND ANOP\n&TESTSW  SETB  0\n.TEST    ANOP\n&S       SETA  &S+1\n         AIF   (&S GT &N).ERR2\n&M       SETA  N'&SYSLIST(&S)\n         AIF   (&M EQ 1).TESTEND\n         AIF   (&M LT 2).ERR3\n         AIF   (&M GT 5).ERR4\n&I       SETA  2\n&OPR     SETC  ''\n&OP      SETC  '&SYSLIST(&S,1)'\n         AIF   (&M GT 2).TESTOPR\n         &OP\n         AGO   .TESTEND\n.TESTOPR ANOP\n         AIF   ('&SYSLIST(&S,&I)'(1,1) NE '''').NOLIT\n&L       SETA  K'&SYSLIST(&S,&I)\n&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'(2,&L-2)\n         AGO   .NEXTOPR\n.NOLIT   ANOP\n&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'\n.NEXTOPR ANOP\n&I       SETA  &I+1\n         AIF   (&I EQ &M).TESTGEN\n&OPR     SETC  '&OPR'.','\n         AGO   .TESTOPR\n.TESTGEN ANOP\n         &OP   &OPR\n.TESTEND ANOP\n         AIF   (&TESTSW EQ 1).ORBC\n.AMBC    ANOP\n         BC    15-&SYSLIST(&S,&M),IF0&LAB\n.CONNECT ANOP\n&S       SETA  &S+1\n         AIF   (&S GT &N).EXIT\n&M       SETA  N'&SYSLIST(&S)\n         AIF   (&M NE 1).ERR5  BAD CONNECTOR\n         AIF   ('&SYSLIST(&S)' EQ 'AND').NEXTAND\n         AIF   ('&SYSLIST(&S)' NE 'OR').ERR5  BAD CONNECTOR\n.NEXTOR   ANOP\n&LAB1    SETA  &LAB+1\n         B     IF0&LAB1  SKIP TEST IF LAST ONE TRUE\nIF0&LAB   EQU *          DO TEST IF LAST ONE FALSE\n&LAB     SETA  &LAB+2\n&ELSE(&LEVEL) SETA &LAB\n&TESTSW  SETB  1\n         AGO   .TEST\n.ORBC    ANOP\n         BC    15-&SYSLIST(&S,&M),IF0&LAB\nIF0&LAB1 EQU *\n         AGO   .CONNECT\n.ERR1    MNOTE 8,'IF - LEVEL OVERFLOW'\n         AGO   .EXIT\n.ERR2    MNOTE 8,'IF - MISSING TEST LIST'\n         AGO   .EXIT\n.ERR3    MNOTE 8,'IF - TEST LIST TOO SHORT'\n         AGO   .EXIT\n.ERR4    MNOTE 8,'IF - TEST LIST TOO LONG'\n         AGO   .EXIT\n.ERR5    MNOTE 8,'IF - INVALID CONNECTOR'\n.EXIT    ANOP\n         MEND\n./       ADD   NAME=OD\n*          DATA SET AM011200   AT LEVEL 001 AS OF 10/28/75\n*          DATA SET AM011200   AT LEVEL 001 AS OF 07/01/74\n         MACRO\n&N       OD\n&N       DO    END\n         MEND\n./       ADD   NAME=THEN\n*          DATA SET AM010600   AT LEVEL 001 AS OF 10/28/75\n*          DATA SET AM010600   AT LEVEL 001 AS OF 04/01/74\n         MACRO\n         THEN  &OPT\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n.*             AUTHOR.   DON HIGGINS.\n.*             DATE.     03/27/74.\n.*             REMARKS.  MACRO TO ALLOW STRUCTURED PROGRAMMING USING\n.*                       IF, THEN, ELSE, AND DO UP TO TEN LEVELS DEEP\n.*                       AND NO BRANCH INSTRUCTIONS. SEE IF MACRO.\n         AIF   (&LEVEL EQ 0).ERR0\n         AIF   ('&OPT' EQ 'BEGIN').BEGIN\n         AIF   ('&OPT' EQ 'END').END\n         MNOTE 4,'THEN - INVALID OPERAND - IGNORED'\n         AGO   .EXIT\n.BEGIN   ANOP\n         AIF   (&SEQ(&LEVEL) NE 1).ERR1\n&SEQ(&LEVEL) SETA 2\n         AGO   .EXIT\n.END     ANOP\n         AIF   (&SEQ(&LEVEL) NE 2).ERR2\n&SEQ(&LEVEL) SETA 3\n         AGO   .EXIT\n.ERR0    MNOTE 8,'THEN - MISSING IF'\n         AGO   .EXIT\n.ERR1    MNOTE 4,'THEN BEGIN - OUT OF SEQUENCE'\n         AGO   .EXIT\n.ERR2    MNOTE 4,'THEN END - OUT OF SEQUENCE'\n.EXIT    ANOP\n         MEND\n./ ENDUP\n/*\n//SOURCE0.SYSIN DD *\n./ ADD NAME=DUMPINFO\n./ NUMBER NEW1=1000,INCR=1000\nDUMPINFO TITLE                                                        'X\n               -- DUMP SVC99 INFORMATION RETRIEVAL INFO --             X\n               CENTERIOR ENERGY CORPORATION'\n* MODULE NAME = DUMPINFO\n* FUNCTION = PRINT SVC99 INFORMATION FROM ALL CURRENT ALLOCATIONS.\n* OPERATION = GETMAIN WORKING STORAGE, ESTABLISH SAVEAREA LINKAGES;\n*             IF DCB NOT SUPPLIED, OPEN DDNAME SYSPRINT;\n*             PRINT SUPPLIED CHARACTER STRING ON SYSPRINT;\n*             FOR EACH EXISTING ALLOCATION,\n*                CALL SVC99 FOR INFORMATION;\n*                PRINT INFORMATION ON SYSPRINT;\n*             DUMP TRANSLATE TABLES\n*             IF DCB WAS NOT SUPPLIED, CLOSE SYSPRINT;\n*             UNLINK SAVEAREAS, FREEMAIN STORAGE, RETURN.\n* PARAMETERS = 1. CHARACTER STRING ( AL2(LENGTH), CL(LENGTH)'...' )\n*                TO BE PRINTED IN HEADINGS.\n*              2. CHARACTER STRING ( CL8'...' )\n*                DDNAME OF PRINT FILE TO BE USED\n*             WHEN INVOKED THROUGH JCL, PARAMETER 2 NOT PRESENT.\n* ATTRIBUTES = REENTRANT, REUSABLE, PROBLEM PROGRAM STATE\n* DURING EXECUTION:  R13 POINTS TO GOTTEN STORAGE (SAVEAREA @ START)\n*                    R12 POINTS TO START OF CSECT, IS BASE REGISTER\n*                    R9 POINTS TO SYSPRINT DCB\n*\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n*\nDUMPINFO CSECT\nDUMPINFO AMODE 24\nDUMPINFO RMODE 24\n         PRINT ON,GEN\n         SPLEVEL\n*\n*...+....1....+....2....+....3....+,\n         MACRO                     , THE LOCAL SYSTEM VARIABLE SYMBOL\n         SETTEMP                   , &SYSECT IS ASSIGNED A VALUE WHEN\n         GBLC  &TEMP               , A MACRO IS CALLED, AND THE VALUE\n&TEMP    SETC '&SYSECT.'           , IS ONLY AVAILABLE IN THE MACRO--\n         MEND                      , THIS MACRO, PLUS THE DECLARATION\n         GBLC  &TEMP               , OF &TEMP, PROPOGATE IT OUTSIDE.\n*...+....1....+....2....+....3....+,\n*\n         LCLC  &CSECTNM            , DEFINE FOR LATER USE\n         SETTEMP                   , MAKE &SYSECT AVAILABLE, IN &TEMP\n&CSECTNM SETC  '&TEMP.'            ,   AND SAVE IT FOR LATER USE\n*\n         LCLA  &LCLA\n         LCLC  &LCLC\n&LCLC    SETC  '&CSECTNM. (ASM &SYSDATE. &SYSTIME.) CENTERIOR '\n&LCLA    SETA  (K'&LCLC+8-1)/8*8-1   PAD TO A MULTIPLE OF 8 MINUS 1\n*\n         B     AROUND-*(,R15)      BRANCH AROUND LGH BYTE, ID TEXT\n*\nLGHBYTE  DC    AL1(&LCLA.)                       LGH BYTE,\nIDTEXT   DC    CL&LCLA.'&LCLC.'                          , ID TEXT\n*\nAROUND   DS    0H\n         SAVE  (14,12)             SAVE CALLER'S REGISTERS\n*\n         LR    R12,R15             COPY BASE REGISTER\n         USING &CSECTNM.,R12       TELL ASEMBLER\n*\n         LA    R0,L'USRDSECT       LENGTH OF DSECT\n         GETMAIN RU,LV=(0)         UNCONDITIONAL\n* REGISTERS 0,1,15 NOT PRESERVED -- ADDRESS OF GOTTEN STORAGE IS IN R1\n*\n         LR    R2,R1               PAIR R2,R3 = GOTTEN STORAGE,LENGTH\n         LA    R3,L'USRDSECT       PAIR R2,R3 = GOTTEN STORAGE,LENGTH\n         LR    R4,R1            PAIR R4,R5 = ANYWHERE LOC, 0 LENGTH/PAD\n         XR    R5,R5            PAIR R4,R5 = ANYWHERE LOC, 0 LENGTH/PAD\n         MVCL  R2,R4               CLEAR THE GOTTEN STORAGE\n*\n* CHAIN THE SAVE AREAS\n         ST    R13,4(,R1)          STORE BACKWARD PTR IN GOTTEN\n         ST    R1,8(,R13)          STORE FORWARD PTR IN CALLER'S\n         LR    R13,R1              POINT R13 TO GOTTEN STORAGE\n         USING USRDSECT,R13        ESTABLISH ADDRESSABILITY\n*\n         B     AROUND2             SKIP TO CONTINUED PROCESSING\n*\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n*\nRETURN   DS    0H\n*\n         L     R8,RC               SAVE RETURN CODE, BEFORE DROP R13\n*\n*        PREPARE R0 AND R1 FOR FREEMAIN, BEFORE R13 IS DROPPED\n         LA    R0,L'USRDSECT       LENGTH OF AREA TO FREEMAIN\n         LA    R1,USRDSECT         ADDRESS OF AREA TO FREEMAIN\n         DROP  R13\n         L     R13,4(,R13)         RESTORE PTR TO CALLER'S SAVE AREA\n         FREEMAIN RU,LV=(0),A=(1)  UNCONDITIONAL\n*\n         LR    R15,R8              MOVE RETURN CODE TO PROPER REGISTER\n         RETURN (14,12),T,RC=(15)  RETURN TO CALLER, WITH RC IN R15\n*\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n*\nAROUND2  DS    0H\n         USING USRDSECT,R13        RE-ESTABLISH ADDRESSABILITY\n*\n         MVC   LBLSTM16,=CL4':STM'  FOR DEBUGGING PURPOSES\n         MVC   LBLWCRE,=CL4'WCRE'   FOR DEBUGGING PURPOSES\n         MVC   LBLDS1F,=CL4'DS1F'   FOR DEBUGGING PURPOSES\n         MVC   LBLDS1H,=CL4'DS1H'   FOR DEBUGGING PURPOSES\n         MVC   LBLDS1X,=CL4'DS1X'   FOR DEBUGGING PURPOSES\n         MVC   ZTLIBGOT,=CL8':TLIBGOT'\n         MVC   ZSDCBGOT,=CL8':SDCBGOT'\n         MVC   ZOPENGOT,=CL8':OPENGOT'\n         MVC   ZSNAPGOT,=CL8':SNAPGOT'\n         MVC   ZWRITGOT,=CL8':WRITGOT'\n*\n         MVI   PRTLINE,C' '\n         MVC   PRTLINE+1(L'PRTLINE-1),PRTLINE\n*\n         MVC   SDCBGOT(DCBL#L),SDCBL       MOVE MODEL TO GOTTEN\n*\n         L     R6,SAVE#BWD         FETCH POINTER TO CALLER'S SAVEAREA\n         L     R6,SAVE#R1-SAVEAREA(R6) FETCH SAVED PARM POINTER\n         LTR   R6,R6               Q. ANY PARAMETERS?\n         BZ    XPARM2               A. NO -- NO PARM 2\n         TM    0(R6),X'80'         Q. IS HIGH BIT SET IN 1ST POINTER ?\n         BO    XPARM2               A. YES -- ONLY 1 PARM, NO PARM 2\n         L     R8,4(R6)            FETCH SECOND PARAMETER\n         LTR   R8,R8               Q. IS ADDRESS ZERO ?\n         BZ    XPARM2               A. YES -- NO DCB SUPPLIED\n         LA    R9,SDCBGOT          R9 -> SDCBGOT\n         USING IHADCB,R9           ESTABLISH ADDRESSABILITY\n         MVC   DCBDDNAM,0(R8)      MOVE IN DDNAME SUPPLIED\n         DROP  R9                  DROP ADDRESSABILITY\nXPARM2   DS    0H\n*\n         TM    SYSPROPN,X'FF'      TEST THE FLAG FIELD\n         BO    SNAPOPEN            FLAG WAS SET, MEANS NO NEED TO OPEN.\n         LA    R9,SDCBGOT          R9 -> SDCBGOT\n         USING IHADCB,R9           ESTABLISH ADDRESSABILITY\n         MVC   OPENGOT(OPENL#L),OPENL     MOVE MODEL TO GOTTEN\n         OPEN  ((R9),OUTPUT),MF=(E,OPENGOT)\n         TM    DCBOFLGS,DCBOFOPN   Q. OPEN SUCCESSFUL ?\n         BO    SNAPOPEN            A. YES -- SKIP ERROR MESSAGE\n* ALLOCATE DDNAME SYSPRINT, WITH DEFAULT SYSOUT CLASS\n         CECDYN  PREFIX=YYY,MF=(E,WORKAREA),                           X\n               VERB=AL,      ALLOCATE                                  X\n               TEXT=((DDNAM,'SYSPRINT'),SYSOU)\n         DYNALLOC            ISSUE SVC99\n         OPEN  ((R9),OUTPUT),MF=(E,OPENGOT)\n         MVI   SYSPRDYN,X'FF'      REMEMBER TO DEALLOCATE\n         TM    DCBOFLGS,DCBOFOPN   Q. OPEN SUCCESSFUL ?\n         BO    SNAPOPEN            A. YES -- SKIP ERROR MESSAGE\n         MVI   SYSPRDYN,X'00'      NO NEED TO DEALLOCATE\n         DROP  R9                  DROP ADDRESSABILITY\n         WTO   '&CSECTNM. -- OPEN UNSUCCESSFUL FOR SYSPRINT'\n         MVC   RC,=F'16'           SET RETURN CODE\n         B     RETURN              AND RETURN\nSNAPOPEN DS    0H\n         MVI   SYSPROPN,X'FF'      MESSAGE FILE IS OPEN\n*\n         MVC   SNAPGOT(SNAPL#L),SNAPL     MOVE MODEL TO GOTTEN\n*                   (MUST BE DONE BEFORE FIRST   SNAP MF=(E,SNAPGOT) )\n*\n         MVC   WRITGOT(WRITL#L),WRITL     MOVE MODEL TO GOTTEN\n*                      (MUST BE DONE BEFORE FIRST   BAS R14,WRITCHEK )\n*\n******** LA    R3,L'USRDSECT(R13)    POINT TO END OF GOTTEN STORAGE\n******** LA    R2,LTORGED            POINT TO END OF CODE\n******** SNAP  DCB=(R9),MF=(E,SNAPGOT),ID=101,STORAGE=((R13),(R3),     X\n               (R12),(R2)),PDATA=REGS,SDATA=CB\n*\n         MVI   PRTLINE,C'1'\n         LA    R5,PRTLINE+1\n*\n         MVC   0(L'IDTEXT,R5),IDTEXT                                 A\n         LA    R5,L'IDTEXT+1(,R5)                                     B\n*\n         L     R6,SAVE#BWD         FETCH POINTER TO CALLER'S SAVEAREA\n         ICM   R6,B'1111',SAVE#R1-SAVEAREA(R6) FETCH AND TEST SAVED R1\n         BZ    YPARM1              WAS ZERO -- NO PARMS AT ALL\n         L     R8,0(R6)            FETCH POINTER TO 1ST PARAMETER\n LA    R1,=CL16'PARMLGH='                                        DEBUG\n LA    R1,8(R1)          TARGET ADDRESS   NON-REENTRANT!!!       DEBUG\n LA    R2,0(R8)          SOURCE ADDRESS                          DEBUG\n LA    R3,2              SOURCE LENGTH                           DEBUG\n BAS   R14,CONVHEX       CALL SUBROUTINE                         DEBUG\n LA    R1,=CL16'PARM1-8='                                        DEBUG\n LA    R1,8(R1)          TARGET ADDRESS   NON-REENTRANT!!!       DEBUG\n MVC   0(8,R1),2(R8)     SOURCE ADDRESS                          DEBUG\n         LH    R7,0(R8)            FETCH LENGTH FIELD\n         LTR   R7,R7               Q. WAS LENGTH ZERO ?\n         BZ    YPARM1              A. YES -- NULL STRING\n STH   R7,DS1H                                                   DEBUG\n LA    R1,=CL8'.R7='                                             DEBUG\n LA    R1,4(R1)          TARGET ADDRESS   NON-REENTRANT!!!       DEBUG\n LA    R2,DS1H           SOURCE ADDRESS                          DEBUG\n LA    R3,2              SOURCE LENGTH                           DEBUG\n BAS   R14,CONVHEX       CALL SUBROUTINE                         DEBUG\n         CH    R7,=AL2(L'PRTLINE-1-L'IDTEXT) CHECK WHETHER TOO LONG\n         BL    R7OK                NO, IT IS OK\n         LH    R7,=AL2(L'PRTLINE-1-L'IDTEXT) TOO LONG -- LIMIT TO MAX.\nR7OK     BCTR  R7,0                DECREMENT FOR EX INSTRUCTIONS\n         EX    R7,EXMVCPRT         MOVE CHARACTER STRING TO PRINT LINE\n         LA    R5,0+1+2(R7,R5)                                        B\n         C     R7,=F'3'            CHECK PARM LENGTH (REMEMBER, -1)\n         BL    ZPARM1              SHORTER THAN 4\n         CLC   =C'SNAP',2(R8)      Q. CHECK 1ST 4 CHARACTERS\n         BNE   ZPARM1              A. NO, SNAP NOT REQUESTED\n         LA    R3,L'USRDSECT(R13)    POINT TO END OF GOTTEN STORAGE\n         LA    R2,LTORGED            POINT TO END OF CODE\n         SNAP  DCB=(R9),MF=(E,SNAPGOT),ID=103,STORAGE=((R13),(R3),     X\n               (R12),(R2)),PDATA=REGS,SDATA=CB\n         B     ZPARM1\nEXMVCPRT MVC   0(*-*,R5),2(R8)     WILL BE EXECUTED\nYPARM1   DS    0H\n* FOLLOWING CODE FROM \"MVS UPDATE\" NO.22, JULY 1988, XEPHON INC.\n         L     R2,16               POINT TO CVT\n         L     R2,0(,R2)           TO TCBWORDS\n         L     R2,4(,R2)           TO TCB\n         L     R3,12(,R2)                    TO TIOT, & SAVE IN R3\n         L     R2,180(,R2)         TO JSCB (TCBJSCB)\n         L     R2,348(,R2)         TO ACTIVE JSCB (JSCBACT)\n         ICM   R2,B'1111',316(R2)  TO LIFE-OF-JOB SSIB (JSCBSSIB)\n         MVC   DSCL8(8),=CL8' '\n         BZ    NOID                (SKIP IF NO L-O-J SSIB)\n         MVC   DSCL8(8),12(R2)     COPY JOB NUMBER (SSIBJBID)\nNOID     EQU   *\n*     ABOVE CODE FROM \"MVS UPDATE\" NO.22, JULY 1988, XEPHON INC.\n*\n         MVC   0(8,R5),DSCL8       JOB NUMBER FROM SSIB              A\n         LA    R5,8+2(,R5)                                            B\n*\n         MVC   0(8,R5),0(R3)       JOB NAME FROM TIOT                A\n         LA    R5,8+2(,R5)                                            B\n*\n         MVC   0(8,R5),8(R3)       STEP NAME FROM TIOT               A\n         LA    R5,8+2(,R5)                                            B\n*\n         MVC   0(8,R5),16(R3)      PROCSTEPNAME FROM TIOT            A\n         LA    R5,8+2(,R5)                                            B\n*\n         USING PSA,R0              MACRO IHAPSA FROM SYS1.MACLIB\n         L     R1,FLCCVT      ADDRESS OF CVT (AFTER IPL).  THIS OFFSET\n*                             FIXED BY ARCHITECTURE.  (MDC450) @G50EP9A\n         DROP  R0                  MACRO IHAPSA FROM SYS1.MACLIB\n         USING CVT,R1              MACRO CVT FROM SYS1.AMODGEN\n         L     R2,CVTSMCA    ADDRESS OF THE SYSTEM MANAGEMENT CONTROL\n*                            AREA (SMCA) IF THE SYSTEM MANAGEMENT\n*                            FACILITIES (SMF) OPTION IS PRESENT IN THE\n*                            SYSTEM.  OTHERWISE, ZERO.\n         DROP  R1                  MACRO CVT FROM SYS1.AMODGEN\n         USING SMCABASE,R2         MACRO IEESMCA FROM SYS1.AMODGEN\n         LA    R3,SMCASID    SYSTEM IDENTIFICATION (SID)         MDC002\n         DROP  R2                  MACRO IEESMCA FROM SYS1.AMODGEN\n*\n         MVC   0(4,R5),0(R3)       SYSTEM IDENTIFICATION (SID)       A\n         LA    R5,4+2(,R5)                                            B\n*\n         TIME  , RETURN DATE IN R1 AS 00YYDDDC, TIME IN R0 AS HHMMSSTH\n         STM   R0,R1,STM16F        SAVE\n*\n         MVC   0(6,R5),=XL7'F0202020202020'                          A\n         ED    0(6,R5),STM16F+5    SOURCE IS YYDDDC, FROM R1         A\n         MVI   0(R5),C'D'          LEADING CHARACTER                 A\n         LA    R5,6+2(,R5)                                            B\n*\n         MVC   0(7,R5),=XL7'F0202020202020'                          A\n         ED    0(7,R5),STM16F      SOURCE IS HHMMSSTH, FROM R0       A\n         MVI   0(R5),C'T'          LEADING CHARACTER                 A\n         LA    R5,7+2(,R5)                                            B\n* NOTE: THE EDIT MASKS ABOVE ARE BOTH XL7, SO ONLY 1 FIELD IS USED,\n*      BUT DIFFERENT SUBSTRINGS OF IT ARE USED IN THE TWO INSTANCES.\n*\nZPARM1   DS    0H\n         BAS   R14,WRITCHEK\n*\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         MACRO\n         PRTFORM\n&KEYSFX  SETC  '&SYSLIST(2)'(4,K'&SYSLIST(2)-4+1) RTSTA,RTTYP,RELNO,ETC\n         AIF   (N'&SYSLIST NE 4).NO4TH\n&SHORT   SETC  '&SYSLIST(4)'\n         AIF   (K'&SHORT LT 4).NO4TH\n         AIF   ('&SHORT'(1,1) NE '''' OR '&SHORT'(K'&SHORT,1) NE '''').X\n               SHORTED\n&SHORT   SETC  '&SHORT'(2,K'&SHORT-2)      TRIM QUOTES\n         AGO   .SHORTED                    SPECIAL CASE -- PRTBITS\n.NO4TH   ANOP\n&SHORT   SETC  '&KEYSFX'    DUPLICATE\n         AIF   ('&KEYSFX'(1,2) NE 'RT').SHORTED\n&SHORT   SETC  '&KEYSFX'(3,K'&KEYSFX-3+1)         STA,  TYP,  LNO,  ETC\n.SHORTED ANOP  , DONE SHORTENING                              RELNO.\n&LCLA    SETA  K'&SHORT\n         AIF   ('&SYSLIST(1)' EQ 'HEAD').HEAD\n         AIF   ('&SYSLIST(1)' EQ 'DETAIL').DETAIL\n         MNOTE 12,'&SYSLIST(1) INVALID, ONLY HEAD OR DETAIL PERMITTED'\n.HEAD    MVC   PRT&KEYSFX.(&LCLA.),=C'&SHORT.'\n         MEXIT\n.MVC     MVC   PRT&KEYSFX.(L'&SYSLIST(2).),&SYSLIST(2).\n         MEXIT\n.DETAIL  ANOP\n         AIF   (T'&SYSLIST(2) EQ 'C').MVC\n         LA    R1,PRT&KEYSFX.      LOAD TARGET ADDRESS\n         LA    R2,&SYSLIST(2).     LOAD SOURCE ADDRESS\n         LA    R3,L'&SYSLIST(2).   LOAD SOURCE LENGTH\n         BAS   R14,CONVHEX         CALL SUBROUTINE\n         AIF   ('&SYSLIST(3)' EQ 'LOOKUP').LOOKUP\n         AIF   ('&SYSLIST(3)' EQ '').MEXIT\n         MNOTE 12,'SYSLIST(3)=&SYSLIST(3) INVALID, ONLY LOOKUP VALID'\n.MEXIT   MEXIT\n.LOOKUP  LA    R1,PRT&KEYSFX.      LOAD ADDRESS OF KEY TO LOOKUP\n         LA    R2,TBL&KEYSFX.      LOAD ADDRESS OF TABLE\n         BAS   R14,LOOKUP          CALL SUBROUTINE\n         MEND\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n*\n         PRTFORM HEAD,ZZZRELNO\n         PRTFORM HEAD,ZZZRTDDN,,' DDN'\n         PRTFORM HEAD,ZZZRTDSN\n         PRTFORM HEAD,ZZZRTMEM\n         PRTFORM HEAD,ZZZRTSTA\n         PRTFORM HEAD,ZZZRTNDP\n         PRTFORM HEAD,ZZZRTCDP\n         PRTFORM HEAD,ZZZRTORG\n         PRTFORM HEAD,ZZZRTLIM\n         PRTFORM HEAD,ZZZRTTYP\n         PRTFORM HEAD,ZZZRTATT\n         PRTFORM HEAD,PRTBITS,,' ATTBITS'\n         PRTFORM HEAD,ZZZRTLST\n         MVI   PRTCCG,C'0'\n*\n         BAS   R14,WRITCHEK\n*\n*\n******** LA    R3,L'USRDSECT(R13)    POINT TO END OF GOTTEN STORAGE\n******** LA    R2,LTORGED            POINT TO END OF CODE\n******** SNAP  DCB=(R9),MF=(E,SNAPGOT),ID=105,STORAGE=((R13),(R3),     X\n               (R12),(R2)),PDATA=REGS,SDATA=CB\n*\n* MAIN LOOP:\n         LA    R5,1          SET COUNTER TO ORDINAL 1 (1ST)\nNEXTINFO EQU   *\n         ST    R5,DS#RELNO\n         LA    R4,DS#RELNO\n* REQUEST INFORMATION FOR RELATIVE NUMBER SPECIFIED IN REGISTER 5:\n         CECDYN  PREFIX=ZZZ,MF=(E,WORKAREA),                           X\n               VERB=IN,      INFORMATION RETRIEVAL                     X\n               TEXT=((RELNO,(R4)),RTLST,RTDDN,RTDSN,RTMEM,RTSTA,       X\n               RTNDP,RTCDP,RTORG,RTLIM,RTATT,RTTYP)\n         DYNALLOC            ISSUE SVC99\n*\n         LA    R8,WORKAREA\n         USING ZZZDSECT,R8   ESTABLISH ADDRESSABILITY TO ZZZ... FIELDS\n         PRTFORM DETAIL,ZZZRELNO\n         PRTFORM DETAIL,ZZZRTDDN\n         PRTFORM DETAIL,ZZZRTDSN\n         PRTFORM DETAIL,ZZZRTMEM\n         PRTFORM DETAIL,ZZZRTSTA,LOOKUP\n         PRTFORM DETAIL,ZZZRTNDP,LOOKUP\n         PRTFORM DETAIL,ZZZRTCDP,LOOKUP\n         PRTFORM DETAIL,ZZZRTORG,LOOKUP\n         PRTFORM DETAIL,ZZZRTLIM\n         PRTFORM DETAIL,ZZZRTTYP,LOOKUP\n         PRTFORM DETAIL,ZZZRTATT\n         MVC   DS1X,ZZZRTATT\n         BAS   R14,DS1XBITS  TRANSFORM DS1X INTO PRTBITS\n         PRTFORM DETAIL,ZZZRTLST,LOOKUP\n         DROP  R8            NO MORE NEED FOR ZZZ... FIELDS\n*\n         BAS   R14,WRITCHEK\n*\n* FORMAT INFORMATION RETURNED:\n******** LA    R3,L'USRDSECT(R13)    POINT TO END OF GOTTEN STORAGE\n******** LA    R2,LTORGED            POINT TO END OF CODE\n******** SNAP  DCB=(R9),MF=(E,SNAPGOT),ID=(R5),STORAGE=((R13),(R3),    X\n               (R12),(R2)),PDATA=REGS,SDATA=CB\n*\n         LA    R5,1(R5)      INCREMENT RELATIVE NUMBER REQUESTED\n         LA    R1,WORKAREA   LOAD ADDRESS OF LIST\n         USING ZZZDSECT,R1   REG1 POINTS TO DSECT\n         TM    ZZZRTLST,X'80'  Q. IS THE HIGH BIT ON?\n         DROP  R1\n         BZ    NEXTINFO        A. NO, GO DO ANOTHER ONE\n*\n*\n         LA    R1,TBLRTLST\n         LA    R3,PRTLINE+1\n         LA    R4,PRTLINE+L'PRTLINE-9\n         BAS   R14,TBLDUMP\n         MVI   PRTCCG,C'0'\n         BAS   R14,WRITCHEK\n*\n         LA    R1,TBLRTSTA\n         LA    R3,PRTLINE+1\n         LA    R4,PRTLINE+L'PRTLINE-9\n         BAS   R14,TBLDUMP\n         BAS   R14,WRITCHEK\n*\n         LA    R1,TBLRTNDP\n         LA    R3,PRTLINE+1\n         LA    R4,PRTLINE+L'PRTLINE-9\n         BAS   R14,TBLDUMP\n         BAS   R14,WRITCHEK\n*\n         LA    R1,TBLRTCDP\n         LA    R3,PRTLINE+1\n         LA    R4,PRTLINE+L'PRTLINE-9\n         BAS   R14,TBLDUMP\n         BAS   R14,WRITCHEK\n*\n         LA    R1,TBLRTORG\n         LA    R3,PRTLINE+1\n         LA    R4,PRTLINE+L'PRTLINE-9\n         BAS   R14,TBLDUMP\nMORE#ORG STM   R15,R2,STM16F SAVE POINTERS+INDICATORS BEFORE WRITCHEK\n*STM   R15,R2,STM16F     SAVE REGISTERS                          DEBUG\n*LA    R1,=CL64'MORE#ORG R15,0-2'                                DEBUG\n*LA    R1,16(R1)         TARGET ADDRESS   NON-REENTRANT!!!       DEBUG\n*LA    R2,STM16F         SOURCE ADDRESS                          DEBUG\n*LA    R3,4              SOURCE LENGTH                           DEBUG\n*BAS   R14,CONVHEX       CALL SUBROUTINE                         DEBUG\n*BAS   R14,CONVHEX       CALL SUBROUTINE                         DEBUG\n*BAS   R14,CONVHEX       CALL SUBROUTINE                         DEBUG\n*BAS   R14,CONVHEX       CALL SUBROUTINE                         DEBUG\n*LM    R15,R2,STM16F     RESTORE REGISTERS                       DEBUG\n         BAS   R14,WRITCHEK\n         LM    R15,R2,STM16F RESTORE POINTERS & INDICATORS\n         LTR   R15,R15       CHECK RETURN FROM TBLDUMP ROUTINE\n         BZ    DONE#ORG      NO, THERE IS NO MORE TO DO\n         BAS   R14,TBLDUMP2  ALTERNATE ENTRY POINT -- R0-4 SET-UP\n         B     MORE#ORG\nDONE#ORG DS    0H\n*\n         LA    R1,TBLRTTYP\n         LA    R3,PRTLINE+1\n         LA    R4,PRTLINE+L'PRTLINE-9\n         BAS   R14,TBLDUMP\n         BAS   R14,WRITCHEK\n*\n*                               '....+....1....+...~.2....+...~.3.'\n         MVC   PRTLINE(31),=CL31' ATT - BIT 0=PERM''LY CONCAT''D; '\n*                                  '....+....1....'\n         MVC   PRTLINE+31(14),=CL14'BIT 1=IN USE; '\n*                                     '....+....1.~...+....2....+'\n         MVC   PRTLINE+31+14(25),=CL25'BIT 2=PERM''LY ALLOCATED; '\n*                                        '....+....1....+....'\n         MVC   PRTLINE+31+14+25(19),=CL19'BIT 3=CONVERTIBLE; '\n*                                           '....+....1....+~...'\n         MVC   PRTLINE+31+14+25+19(18),=CL18'BIT 4=DYNALLOC''D; '\n*                                              '....+....1....+...'\n         MVC   PRTLINE+31+14+25+19+18(18),=CL18'BITS 5-7=RESERVED.'\n         BAS   R14,WRITCHEK\n*\n*\n******** LA    R3,L'USRDSECT(R13)    POINT TO END OF GOTTEN STORAGE\n******** LA    R2,LTORGED            POINT TO END OF CODE\n******** SNAP  DCB=(R9),MF=(E,SNAPGOT),ID=255,STORAGE=((R13),(R3),     X\n               (R12),(R2)),PDATA=REGS,SDATA=CB\n*\n         CLOSE ((R9)),MF=(E,OPENGOT)\nSNAPCLOS DS    0H\n*\n         TM    SYSPRDYN,X'01'      TEST A BIT OF FLAG FIELD\n         BNO   SYSPRUN             FLAG IS NO, NO NEED TO UNALLOCATE\n* UNALLOCATE DDNAME SYSPRINT\n         CECDYN  PREFIX=XXX,MF=(E,WORKAREA),                           X\n               VERB=UN,      UNALLOCATE                                X\n               TEXT=((DDNAM,'SYSPRINT'))\n         DYNALLOC            ISSUE SVC99\nSYSPRUN  EQU   *\n*\n         B     RETURN              ALL DONE WITH PROCESSING\n*\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n*\nWRITCHEK ST    R14,WC#R14    SAVE, BECAUSE WRITE & CHECK WILL USE R14.\n         LA    R0,L'PRTLINE+L'PRTRDW+L'PRTRDW00+L'PRTBDW+L'PRTBDW00\n         STH   R0,PRTBDW\n         XC    PRTBDW00,PRTBDW00\n         LA    R0,L'PRTLINE+L'PRTRDW+L'PRTRDW00\n         STH   R0,PRTRDW\n         XC    PRTRDW00,PRTRDW00\n         WRITE WRITGOT,SF,(R9),PRTAREA,MF=E\n         CHECK WRITGOT\n         MVI   PRTLINE,C' '\n         MVC   PRTLINE+1(L'PRTLINE-1),PRTLINE\n         L     R14,WC#R14    RESTORE\n         BR    R14\n*\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         EJECT\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\nCONVHEX  DS   0H , CONVERT BINARY TO ZONED HEXIDECIMAL EQUIVALENT\n* R1    = TARGET ADDRESS.   (TARGET EXACTLY TWICE AS LONG AS SOURCE)\n* R2    = SOURCE ADDRESS.\n* R3    = SOURCE LENGTH.    (ONLY 1 THRU 16 IS PERMITTED)\n* R4,R5 = WORK REGISTERS.\n* R14   = RETURN ADDRESS -- CALL:  BAS R14,CONVHEX\n* ON RETURN: R1 & R2 WILL BE POSITIONED JUST-PAST PROCESSED AREAS,\n*            R3 WILL BE UNCHANGED.\n         SAVE  (3,5)\n         N     R3,=X'000000FF' FORCE TO 16 OR LESS\n         LTR   R4,R3         RESULT:  L'SRC\n         BZ    XCONVHEX      IF ZERO, DO NOTHING\n         BCTR  R4,0          RESULT:  L'SRC-1\n         IC    R5,0(R2,R4)   FETCH LAST BYTE OF SOURCE\n         AR    R4,R4         RESULT:  2*L'SRC-2\n         STC   R5,1(R1,R4)   STORE INTO LAST BYTE OF TARGET\n         LR    R5,R4         SAVE     2*L'SRC-2   FOR LATER EXMVZ\n         SLL   R4,FOUR       RESULT:  AL1(2*L'SRC-2),AL1(0)\n         OR    R4,R3         RESULT:  AL1(2*L'SRC-2),AL1(L'SRC)\n         BCTR  R4,0          RESULT:  AL1(2*L'SRC-2),AL1(L'SRC-1)\n         EX    R4,EXUNPK     UNPACK (SOURCE) TO (TARGET MINUS 1 BYTE)\n         NI    0(R1),X'0F'   CLEAR FIRST HI-BYTE OF TARGET\n         EX    R5,EXMVZ      CLEAR ALL HI-BYTES OF TARGET\n         LA    R5,1(R5)      RESULT:  2*L'SRC-1\n         EX    R5,EXTR       CHANGE LO-BYTES TO PRINTABLE CHARACTERS\n         LA    R1,1(R5,R1)   ADVANCE PAST TARGET\n         LA    R2,0(R3,R2)   ADVANCE PAST SOURCE\nXCONVHEX RETURN (3,5),RC=0   RETURN TO CALLER\nEXUNPK   UNPK  0(*-*,R1),0(*-*,R2)    EXECUTED\nEXMVZ    MVZ   1(*-*,R1),0(R1)        EXECUTED\nEXTR     TR    0(*-*,R1),TRANTBL      EXECUTED\nTRANTBL  DC    C'0123456789ABCDEF' TRANSLATE TABLE\nFOUR     EQU   4\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         EJECT\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n* LOOKUP -- LOOKUP VALUE IN TABLE, REPLACE WITH TABLE ENTRY'S VALUE\n* R1    = ADDRESS OF KEY TO LOOKUP\n* R2    = ADDRESS OF TABLE\n* R14   = RETURN ADDRESS.      CALL:    BAS R14,LOOKUP\n* R15,R0,R3,R4 = WORK REGISTERS.\n* ON RETURN: R1 AND R2 WILL BE UNCHANGED.\n*            IF KEY WAS FOUND IN TABLE,\n*                 REPLACEMENT VALUE WAS PLACED JUST-AFTER KEY AND R15=0\n*            IF KEY WAS NOT FOUND, R15 IS NON-ZERO\n* FIRST FULLWORD AT START OF TABLE IS A(TABLE ID), WHICH IS AL1(),C'  '\n* NEXT FULLWORD AT START OF TABLE CONTAINS:\n*  1 BYTE = KEY LENGTH, 1 BYTE = REPLACEMENT LENGTH,\n*  HALFWORD = NUMBER OF PAIRS IN TABLE;\n* THEN FOLLOWING, PAIRS OF KEY + REPLACEMENT.\nEXCLC1F  CLC   0(*-*,R1),0(R15)        WILL BE EXECUTED (R1, R'F')\nEXMVC3F  MVC   0(*-*,R3),0(R15)        WILL BE EXECUTED (R3, R'F')\nLOOKUP   LA    R0,1                    PRIME\n         XR    R3,R3                   CLEAR\n         XR    R4,R4                   CLEAR\n         IC    R3,4(R2)                FETCH KEY LENGTH FROM TABLE\n         IC    R4,5(R2)                FETCH REPLACEMENT LENGTH\n         AH    R0,6(R2)                R0 CONTAINS 1 + # OF ENTRIES\n         LA    R15,8(R2)               POINT TO FIRST TABLE ENTRY\n         BCTR  R3,0                    DECREMENT FOR EX INSTRUCTIONS\n         BCTR  R4,0                    DECREMENT FOR EX INSTRUCTIONS\nLOOKLOOP EX    R3,EXCLC1F              Q. IS IT A MATCH ?\n         LA    R15,1(R3,R15)           STEP PAST KEY (NO CC CHANGE)\n         BE    LOOKHERE                A. YES, JUMP OUT OF LOOP\n         LA    R15,1(R4,R15)           STEP PAST REPLACEMENT\n         BCT   R0,LOOKLOOP             POSSIBLY CHECK SOME MORE\n         RETURN RC=(15)                RETURN TO CALLER (R15 NON-ZERO)\nLOOKHERE LA    R3,1(R1,R3)             POINT TO JUST-PAST KEY\n         C     R4,=F'-1'               Q. WAS REPLACEMENT LENGTH 0 ?\n         BE    LOOKDONE                A. YES--NO REPLACE, JUST RETURN\n         EX    R4,EXMVC3F              MOVE REPLACEMENT THERE\nLOOKDONE RETURN RC=0                   RETURN TO CALLER WITH R15=0\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         EJECT\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n* TBLDUMP -- FORMAT TRANSFORMATION TABLE FOR PRINTING\n* R1    = ADDRESS OF TABLE\n* R3    = ADDRESS OF PRINT LINE\n* R4    = ADDRESS OF END OF PRINT LINE (TO CHECK FOR FILLING-UP)\n* R14   = RETURN ADDRESS.      CALL:    BAS R14,TBLDUMP\n* R15,R0,R2,R3,R4,R5 = WORK REGISTERS\n* DURING EXECUTION: R15 POINTS TO LAST BYTE MOVED INTO PRINT LINE\n*                   R0 CONTAINS COUNT OF ENTRIES TO BE PROCESSED\n* ON RETURN: R1,R3,R4 WILL BE UNCHANGED.\n*            PRTLINE WILL BE SET-UP.\n*            IF TABLE EXHAUSTED, RC=0 -- ELSE, NON-ZERO.\n*\n* FIRST FULLWORD AT START OF TABLE IS A(TABLE ID), WHICH IS AL1(),C'  '\n* NEXT FULLWORD AT START OF TABLE CONTAINS:\n*  1 BYTE = KEY LENGTH, 1 BYTE = REPLACEMENT LENGTH,\n*  HALFWORD = NUMBER OF PAIRS IN TABLE;\n* THEN FOLLOWING, PAIRS OF KEY + REPLACEMENT.\nEXMVCF2  MVC   0(*-*,R15),0(R2)        WILL BE EXECUTED (R'F', R2)\nEXMVCF3  MVC   0(*-*,R15),0(R3)        WILL BE EXECUTED (R'F', R3)\nTBLDUMP  DS   0H                       NORMAL ENTRY POINT.\n         LH    R0,6(R1)                FETCH # OF ENTRIES IN TABLE\n         LA    R2,8(R1)                POINT TO FIRST TABLE ENTRY\nTBLDUMP2 DS   0H , ALTERNATE ENTRY POINT: EXPECT R0,R2 UNCHANGED\n         SAVE  (3,4)\n         LR    R15,R3                  SAVE START-ADDRESS OF PRINT LINE\n         LR    R5,R4                   SAVE END-ADDRESS OF PRINT LINE\n         L     R3,0(R1)                FETCH ADDRESS OF TABLE-ID\n         XR    R4,R4                   CLEAR\n         IC    R4,0(R3)                FETCH TABLE-ID LENGTH FROM TABLE\n         BCTR  R4,0                    DECREMENT FOR EX INSTRUCTIONS\n         LA    R3,1(R3)                POINT TO TABLE-ID CHARACTERS\n         EX    R4,EXMVCF3              MOVE TABLE-ID TO PRINT LINE\n         LA    R15,1(R4,R15)           ADVANCE TARGET POINTER, R4+1\n         MVI   0(R15),C':'             MOVE TO PRINT LINE\n         XR    R3,R3                   CLEAR\n         XR    R4,R4                   CLEAR\n         IC    R3,4(R1)                FETCH KEY LENGTH FROM TABLE\n         IC    R4,5(R1)                FETCH REPLACEMENT LENGTH\n         BCTR  R3,0                    DECREMENT FOR EX INSTRUCTIONS\n         BCTR  R4,0                    DECREMENT FOR EX INSTRUCTIONS\nDUMPLOOP LA    R15,2(R15)              ADVANCE TARGET POINTER, 2 BYTES\n         EX    R3,EXMVCF2              MOVE KEY TO PRINT LINE\n         LA    R2,1(R3,R2)             STEP PAST KEY,          R3+1\n         LA    R15,1(R3,R15)           ADVANCE TARGET POINTER, R3+1\n         MVI   0(R15),C','             MOVE TO PRINT LINE\n         C     R4,=F'-1'               Q. WAS REPLACEMENT LENGTH 0 ?\n         BE    DONTEXR4                A. DON'T MOVE REPLACEMENT\n         LA    R15,1(R15)              ADVANCE TARGET POINTER\n         EX    R4,EXMVCF2              MOVE REPLACEMENT TO PRINT LINE\n         LA    R2,1(R4,R2)             STEP PAST REPLACEMENT,  R4+1\n         LA    R15,1(R4,R15)           ADVANCE TARGET POINTER, R4+1\nDONTEXR4 MVI   0(R15),C';'             MOVE TO PRINT LINE\n         CR    R15,R5                  Q. ARE WE PAST THE END ?\n         BNL   TBLOVER                 A. YES, DON'T LOOP\nTBLBCT   BCT   R0,DUMPLOOP             POSSIBLY CHECK SOME MORE\n         MVI   0(R15),C'.'             MOVE TO PRINT LINE, REPLACE ';'\n         RETURN (3,4),RC=0             RETURN TO CALLER WITH R15=0\nTBLOVER  DS   0H                       PRTLINE IS FULL\n         BCTR  R0,0                    DECREMENT, FOR NEXT TIME ROUND\n         RETURN (3,4),RC=4             RETURN TO CALLER WITH R15 NON-0\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         EJECT\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n* DS1XBITS -- TAKE DS1X, CHANGE BITS TO DIGITS 0/1 IN FIELD PRTBITS.\n* R14   = RETURN ADDRESS.      CALL:    BAS R14,DS1XBITS\n* R15   = WORK REGISTER.\n*\nDS1XBITS MVC   PRTBITS(8),=CL8'00000XXX'   SET DEFAULT\n*\n*...+....1....+....2....+....3....+....4....+..&B\n         MACRO ,                               &B\n         TESTBIT &MASK,&BIT                    &B\n&B       SETC  ''                              &B\n&OPND    SETC  'DS1X,X''&MASK.''             ' &B\n&OPND    SETC  '&OPND'(1,20).'TEST BIT &BIT.'  &B\n         TM    &OPND.&B&B&B&B&B&B&B&B&B&B&B&B&B&B\n&OPND    SETC  'XBIT&BIT                     ' &B\n&OPND    SETC  '&OPND'(1,20).'DONE W/BIT &BIT' &B\n         BZ    &OPND.&B&B&B&B&B&B&B&B&B&B&B&B&B&B\n&OPND    SETC  'PRTBITS+&BIT.,C''1''         ' &B\n&OPND    SETC  '&OPND'(1,20).'IT WAS NON-ZERO' &B\n         MVI   &OPND.&B&B&B&B&B&B&B&B&B&B&B&B&B&B\n&OPND    SETC  '0H'                            &B\nXBIT&BIT DS    &OPND.&B&B&B&B&B&B&B&B&B&B&B&B&B&B\n         MEND                                  &B\n*...+....1....+....2....+....3....+....4....+..&B\n*\n         TESTBIT 80,0\n         TESTBIT 40,1\n         TESTBIT 20,2\n         TESTBIT 10,3\n         TESTBIT 08,4\n         BR    R14                     RETURN TO CALLER\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         EJECT\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n*\n* MODEL MACRO CALLS\n*\nOPENL    DS    0F\n         OPEN  (,),MF=L\nOPENL#L  EQU   *-OPENL             LENGTH OF MODEL\n*\nSDCBL    DCB   MACRF=(W),DDNAME=SYSPRINT,                         DEBUGX\n               DSORG=PS,RECFM=VBA,LRECL=125,BLKSIZE=1632          DEBUG\nDCBL#L   EQU   *-SDCBL             LENGTH OF MODEL\n*\nSNAPL    SNAP  MF=L,STORAGE=(,,,)  ROOM FOR TWO PAIRS OF ADDRESSES\nSNAPL#L  EQU   *-SNAPL             LENGTH OF MODEL\n*\nWRITL    WRITE WRITDECB,SF,MF=L\nWRITL#L  EQU   *-WRITL\n*\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         EJECT\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n*\nWORKDSCT DSECT , THIS STORAGE MUST BE GOTTEN BELOW 16M,                X\n               BECAUSE IT CONTAINS DCB.S\n*\nSAVEAREA DC    0CL72' '\nDONOTUSE DC    F'0'    DO NOT USE\nSAVE#BWD DC    F'0'\nSAVE#FWD DC    F'0'\nSAVE#R14 DC    F'0'\nSAVE#R15 DC    F'0'\nSAVE#R0  DC    F'0'\nSAVE#R1  DC    F'0'\nSAVE#R2  DC    F'0'\nSAVE#R3  DC    F'0'\nSAVE#R4  DC    F'0'\nSAVE#R5  DC    F'0'\nSAVE#R6  DC    F'0'\nSAVE#R7  DC    F'0'\nSAVE#R8  DC    F'0'\nSAVE#R9  DC    F'0'\nSAVE#R10 DC    F'0'\nSAVE#R11 DC    F'0'\nSAVE#R12 DC    F'0'\n*\nZTLIBGOT DC    CL8':SDCBGOT'\nTLIBGOT  DS    0F'0',CL(DCBL#L)      DCB LIST IN GOTTEN STORAGE\nZSDCBGOT DC    CL8':SDCBGOT'\nSDCBGOT  DS    0F'0',CL(DCBL#L)      DCB LIST IN GOTTEN STORAGE\n*\nSYSPRDYN DS    X             FLAG WHETHER TO DEALLOCATE SYSPRINT @ END\nSYSPROPN DS    X             FLAG WHETHER DCB IS OPENED\n*\n         DS    0F\n*\nLBLSTM16 DC    CL4':STM'\nSTM16F   DS    16F\n*\nLBLWCRE  DC    CL4'WCRE'     R'E' = R14\nWC#R14   DC    1F'0'\n*\nLBLDS1F  DC    CL4'DS1F'\nDS1F     DC    1F'0'\nLBLDS1H  DC    CL4'DS1H'\nDS1H     DC    1H'0'\nLBLDS1X  DC    CL4'DS1X'\nDS1X     DC    1X'0'\nDSCL8    DC    CL8' '\n         DS    C\n*\nDS#RELNO DS    F\n*\nRC       DS    F             RETURN CODE TO BE PASSED BACK\n*\nZOPENGOT DC    CL8':OPENGOT'\nOPENGOT  DS    0F'0',CL(OPENL#L)     OPEN LIST IN GOTTEN STORAGE\nZSNAPGOT DC    CL8':SNAPGOT'\nSNAPGOT  DS    0F'0',CL(SNAPL#L)     SNAP LIST IN GOTTEN STORAGE\n*\nPRTLINEX DS    F             WILL CONTAIN A(PRTLINE+L'PRTLINE)\n*\nPRTAREA  DS    0F            ALIGN\nPRTBDW   DS    AL2           RESERVE SPACE FOR BDW, RDW\nPRTBDW00 DC    AL2(0)\nPRTRDW   DS    AL2           RESERVE SPACE FOR BDW, RDW\nPRTRDW00 DC    AL2(0)\nPRTBEGIN EQU   *             PRTLINE WILL BEGIN HERE\nPRTCCG   DS    CL1\nPRTRELNO DS    CL5\nPRTRTDDN DS    CL8,CL1\nPRTRTDSN DS    CL44\nPRTRTMEM DS    CL8,CL1\nPRTRTSTA DS    CL2                 KEY FIELD\nPRTXXSTA DS            CL4,CL1         TRANSLATED KEY FIELD, BLANK\nPRTRTNDP DS    CL2                 KEY FIELD\nPRTXXNDP DS            CL4,CL1         TRANSLATED KEY FIELD, BLANK\nPRTRTCDP DS    CL2                 KEY FIELD\nPRTXXCDP DS            CL4,CL1         TRANSLATED KEY FIELD, BLANK\nPRTRTORG DS    CL4                 KEY FIELD\nPRTXXORG DS            CL4,CL1         TRANSLATED KEY FIELD, BLANK\nPRTRTTYP DS    CL2                 KEY FIELD\nPRTXXTYP DS            CL5,CL1         TRANSLATED KEY FIELD, BLANK\nPRTRTLIM DS    CL5\nPRTRTATT DS    CL3\nPRTBITS  DS    CL9\nPRTRTLST DS    CL2                 KEY FIELD\nPRTXXLST DS            CL4,CL1         TRANSLATED KEY FIELD, BLANK\n*\n******** ORG   PRTBEGIN+125                               LIMIT TO 125\n******** 125 IS THE MAX. PERMITTED ON SNAP DCB            LIMIT TO 125\n*\nPRTLGH   EQU   *-PRTBEGIN\n         ORG   PRTBEGIN\nPRTLINE  DS    CL(PRTLGH)\n*\n         ORG   ,                                          LIMIT TO 125\n*        JUMP PAST ANY SHORTENING ORG.S                   LIMIT TO 125\n*\n         DS    CL20               PAD, JUST IN CASE\n*\nZWRITGOT DC    CL8':WRITGOT'\nWRITGOT  DC    0F'0',CL(WRITL#L)' ' WRITE LIST IN GOTTEN STORAGE\n*\nWORKAREA DS    CL512\n*\nLASTWORD DS    F\n*\n*-------------*\n* FOLLOWING CODE WORKS, AS LONG THE DSECT HAS A NAME.\n         SETTEMP                   , MAKE &SYSECT AVAILABLE, IN &TEMP\nUSRDSCTL EQU   *-&TEMP             , NON-RELOCATABLE, LENGTH OF DSECT\n         ORG   &TEMP\nUSRDSECT DS    CL(USRDSCTL)        NOW L'USRDSECT AVAILABLE IN CONDITIOX\n               NAL ASSEMBLY STATEMENTS                                 X\n               NOTE -- IT MUST BE DS, DC HAS A MAX OF 256\n*\n&CSECTNM. CSECT , BACK TO CODE\n*\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         EJECT\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n*\n* CONSTANTS\n*\n*\n         MACRO\n&NAME    TABLE &POS1,&ID=,&L1=,&L2=\n         GBLC  &CEC#L1,&CEC#L2\n         GBLC  &CEC#GBLC\n&NX      SETC  '&SYSNDX'\n         AIF   ('&POS1' EQ 'START').START\n         AIF   ('&POS1' EQ 'END').END\n         AIF   ('&POS1' EQ 'ENTRY').ENTRY\n         MNOTE 12,'&POS1 INVALID, ONLY START/END/ENTRY PERMITTED'\n         MEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n.START   ANOP\n         AIF   (K'&ID GT 2).STARTOK\n         AIF   ('&ID'(1,1) EQ '''').STARTOK\n         AIF   ('&ID'(K'&ID,1) EQ '''').STARTOK\n         MNOTE 12,'ERROR, QUOTES REQUIRED ON ID=\"&ID\"'\n.STARTOK ANOP\n&LCLC    SETC  '&ID'(2,K'&ID-2) REMOVE QUOTES\n&CEC#L1  SETC  '&L1'\n&CEC#L2  SETC  '&L2'\n&LCLA    SETA  K'&LCLC\nCEC&NX.A DC   0F'0',AL1(&LCLA),CL&LCLA'&LCLC'        TABLE ID\n&NAME    DC    A(CEC&NX.A)                           A(TABLE ID)\n         DC    AL1(&CEC#L1),AL1(&CEC#L2)             FIELD LENGTHS\n         DS    AL2                 RESERVE SPACE FOR # ENTRIES IN TABLE\nCEC&NX.B EQU   *\n&CEC#GBLC SETC 'CEC&NX'\n         MEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n.END     ANOP\n&LCLC    SETC  '&CEC#GBLC.C'\n&LCLC2   SETC  '   CALCULATE # ENTRIES'\n&LCLC    EQU   (*-&CEC#GBLC.B)/(&CEC#L1+&CEC#L2)&LCLC2\n         ORG   &CEC#GBLC.B-2       POSITION TO PROPER PLACE\n         DC    AL2(&LCLC)          FIXUP # ENTRIES IN TABLE\n         ORG\n         MEXIT\n.ENTRY   ANOP\n&I       SETA  2\n.NEXTI   ANOP\n&LCLC    SETC  '&SYSLIST(&I)'\n&LCLC2   SETC  '&SYSLIST(&I+1)'\n         AIF   ('&CEC#L2' EQ '0').NOL2\n         DC    CL(&CEC#L1)'&LCLC',CL(&CEC#L2)'&LCLC2'\n         AGO   .ADVI\n.NOL2    DC    CL(&CEC#L1)'&LCLC'\n.ADVI    ANOP\n&I       SETA  &I+2\n         AIF   (&I LT N'&SYSLIST).NEXTI\n         MEND\n*\n*\nTBLRTLST TABLE START,ID='LST-INDICATE LAST',L1=L'PRTRTLST,L2=L'PRTXXLST\n         TABLE ENTRY,80,LAST\n         TABLE END\n*\n*\nTBLRTSTA TABLE START,ID='STA - DSET STATUS',L1=L'PRTRTSTA,L2=L'PRTXXSTA\n         TABLE ENTRY,01,=OLD,02,=MOD,04,=NEW,08,=SHR\n         TABLE END\n*\n*\nTBLRTNDP TABLE START,ID='NDP - NORMAL DISP',L1=L'PRTRTNDP,L2=L'PRTXXNDP\n         TABLE ENTRY,01,=UNCATLG,02,=CATLG,04,=DELETE,08,=KEEP,10,=PASS\n         TABLE END\n*\n*\nTBLRTCDP TABLE START,ID='CDP - COND\"L DISP',L1=L'PRTRTCDP,L2=L'PRTXXCDP\n         TABLE ENTRY,01,=UNCATLG,02,=CATLG,04,=DELETE,08,=KEEP,10,=PASS\n         TABLE END\n*\n*\nTBLRTORG TABLE START,ID='ORG - ORGANIZATION',                          X\n               L1=L'PRTRTORG,L2=L'PRTXXORG\n         TABLE ENTRY,0004,=TR,0008,=VSAM,0020,=TQ,0040,=TX,0080,=GS\n         TABLE ENTRY,0200,=PO,0300,=POU,0400,=MQ,0800,=CQ,1000,=CX\n         TABLE ENTRY,2000,=DA,2100,=DAU,4000,=PS,4100,=PSU,8000,=IS\n         TABLE ENTRY,8100,=ISU\n         TABLE END\n*\n*\nTBLRTTYP TABLE START,ID='TYP - TYPE',L1=L'PRTRTTYP,L2=L'PRTXXTYP\n         TABLE ENTRY,80,=DUMMY,40,=TERM,20,=SYSIN,10,=SYSOUT\n         TABLE END\n         SPACE 1\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         EJECT\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         SPACE 1 LINE\n&CSECTNM. CSECT , BACK TO CODE\n*\n         LTORG ,             GENERATE ALL LITERALS HERE\nLTORGED  EQU   * ,           NO MORE CODE BEYOND THIS POINT\n         SPACE 1\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         SPACE 1 LINE\n         PRINT ON,NOGEN\n         CVT   DSECT=YES           FROM SYS1.AMODGEN\n         DCBD  DSORG=XE,DEVD=DA    FROM SYS1.MACLIB\n         IEESMCA ,                 FROM SYS1.AMODGEN\n         IEFZB4D0 ,                FROM SYS1.MACLIB\n         IEFZB4D2 ,                FROM SYS1.MACLIB\n         IHAPSA ,                  FROM SYS1.MACLIB\n         SPACE 1\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         SPACE 1 LINE\n         END\n./ ENDUP\n/*\n//SOURCE2.SYSIN DD *\n./ REPRO NAME=DUMPINFO,NEW=PS\n./ ENDUP\n/*\n//GO2.SYSIN DD * (THIS CANNOT BE IN THE PROC)\n/*\n//*.+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CONTINUE": {"ttr": 4612, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10&\\x0f\\x01\\x10&\\x0f\\x16A\\x00\\x0b\\x00\\x0b\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-09-17T00:00:00", "modifydate": "2010-09-17T16:41:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "MACRO"}, "text": "         MACRO ,\n&NAME    CONTINUE ,\n.* DATE.     28-JUL-1989\n.* REMARKS.  THIS MACRO WORKS WITH THE MACROS WRITTEN BY DON HIGGINS,\n.*          FOUND ON FILE 078 OF SHARE MVS GROUP MODS TAPE, V29 (04/84)\n.*  SEE CASE,DOCASE,DOMACRO,EQUBC,ELSE,ELSEIF,ESAC,ESACOD,FI,IF,OD;\n.*  AND BREAK.\n         GBLA  &DO(10),&DOSEQ(10),&DOLVL,&DOLAB\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n&NAME    B     DO&DO(&DOLVL)       GO IMMEDIATELY TO TEST PART OF LOOP\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DOMACRO": {"ttr": 4614, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10&\\x0f\\x01\\x10&\\x0f\\x16A\\x00z\\x00z\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-09-17T00:00:00", "modifydate": "2010-09-17T16:41:00", "lines": 122, "newlines": 122, "modlines": 0, "user": "MACRO"}, "text": "*          DATA SET AM010800   AT LEVEL 001 AS OF 10/28/75\n*          DATA SET AM010800   AT LEVEL 004 AS OF 08/14/74\n         MACRO\n         DO\n         GBLA  &DO(10),&DOSEQ(10),&DOLVL,&DOLAB\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n         LCLA  &N,&M,&S,&LAB1,&L,&I\n         LCLA  &UNTIL\n         LCLC  &OP,&OPR\n         LCLB  &TESTSW\n         EQUBC ,             DEFINE CONDITIONS, IF NOT ALREADY DEFINED\n.*             AUTHOR.   DON HIGGINS.\n.*             DATE.     03/27/74.\n.*             REMARKS.  MACRO TO ALLOW STRUCTURED PROGRAMMING USING\n.*                       IF, THEN, ELSE, AND DO UP TO TEN LEVELS DEEP\n.*                       AND NO BRANCH INSTRUCTIONS. SEE IF MACRO.\n         AIF   (&DOLVL EQ 10).ERR1\n&N       SETA  N'&SYSLIST\n         AIF   (&N LT 1).ERR2\n         AIF   ('&SYSLIST(1)' EQ 'END').END\n         AIF   ('&SYSLIST(1)' EQ 'FOREVER').WHILE\n         AIF   (&N LT 2).ERR2\n         AIF   ('&SYSLIST(1)' EQ 'WHILE').WHILE\n         AIF   ('&SYSLIST(1)' NE 'UNTIL').ERR3\n.UNTIL   ANOP\n&DOLVL   SETA  &DOLVL+1\n&UNTIL   SETA  &DOLAB+1\n&DOLAB   SETA  &DOLAB+2\n         B     DO&UNTIL\n         AGO   .COMM\n.WHILE   ANOP\n&DOLVL   SETA  &DOLVL+1\n&DOLAB   SETA  &DOLAB+1\n.COMM    ANOP\n&DOSEQ(&DOLVL) SETA 1\n&DO(&DOLVL) SETA &DOLAB\nDO&DOLAB EQU   *\n         AIF   (&LEVEL EQ 10).ERR1\n&LEVEL   SETA  &LEVEL+1\n&SEQ(&LEVEL) SETA 1\n&LAB     SETA  &LAB+1\n&ELSE(&LEVEL) SETA &LAB\n         AIF   ('&SYSLIST(1)' EQ 'FOREVER').EXIT\n&S       SETA  1\n.NEXTAND ANOP\n&TESTSW  SETB  0\n.TEST    ANOP\n&S       SETA  &S+1\n         AIF   (&S GT &N).ERR2\n&M       SETA  N'&SYSLIST(&S)\n         AIF   (&M LT 2).ERR3\n         AIF   (&M GT 5).ERR3\n&I       SETA  2\n&OPR     SETC  ''\n&OP      SETC  '&SYSLIST(&S,1)'\n         AIF   (&M GT 2).TESTOPR\n         &OP\n         AGO   .TESTEND\n.TESTOPR ANOP\n         AIF   ('&SYSLIST(&S,&I)'(1,1) NE '''').NOLIT\n&L       SETA  K'&SYSLIST(&S,&I)\n&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'(2,&L-2)\n         AGO   .NEXTOPR\n.NOLIT   ANOP\n&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'\n.NEXTOPR ANOP\n&I       SETA  &I+1\n         AIF   (&I EQ &M).TESTGEN\n&OPR     SETC  '&OPR'.','\n         AGO   .TESTOPR\n.TESTGEN ANOP\n         &OP   &OPR\n.TESTEND ANOP\n         AIF   (&TESTSW EQ 1).ORBC\n.AMBC    ANOP\n         BC    15-&SYSLIST(&S,&M),IF0&LAB\n.CONNECT ANOP\n&S       SETA  &S+1\n         AIF   (&S GT &N).CHKUNTL\n&M       SETA  N'&SYSLIST(&S)\n         AIF   (&M NE 1).ERR3  BAD CONNECTOR\n         AIF   ('&SYSLIST(&S)' EQ 'AND').NEXTAND\n         AIF   ('&SYSLIST(&S)' NE 'OR').ERR3  BAD CONNECTOR\n.NEXTOR   ANOP\n&LAB1    SETA  &LAB+1\n         B     IF0&LAB1  SKIP TEST IF LAST ONE TRUE\nIF0&LAB   EQU *          DO TEST IF LAST ONE FALSE\n&LAB     SETA  &LAB+2\n&ELSE(&LEVEL) SETA &LAB\n&TESTSW  SETB  1\n         AGO   .TEST\n.ORBC    ANOP\n         BC    15-&SYSLIST(&S,&M),IF0&LAB\nIF0&LAB1 EQU *\n         AGO   .CONNECT\n.CHKUNTL ANOP\n         AIF   (&UNTIL EQ 0).EXIT\n&LAB     SETA  &LAB+1\n         B     IF0&LAB\nIF0&ELSE(&LEVEL) EQU *\n&ELSE(&LEVEL) SETA &LAB\nDO&UNTIL EQU *\n         AGO   .EXIT\n.END     ANOP\n         AIF   (&N GT 1).ERR3\n         AIF   (&DOLVL EQ 0).ERR4\n         AIF   (&DOSEQ(&DOLVL) NE 1).ERR4\n&DOSEQ(&DOLVL) SETA 0\n         B     DO&DO(&DOLVL)\n&DOLVL   SETA  &DOLVL-1\nIF0&ELSE(&LEVEL) EQU *\n&LEVEL   SETA  &LEVEL-1\n         AGO   .EXIT\n.ERR1    MNOTE 8,'DO - LEVEL OVERFLOW'\n         AGO   .EXIT\n.ERR2    MNOTE 8,'DO - MISSING OPERAND'\n         AGO   .EXIT\n.ERR3    MNOTE 8,'DO - INVALID OPERAND'\n         AGO   .EXIT\n.ERR4    MNOTE 8,'DO - END OUT OF SEQUENCE'\n.EXIT    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DUMPINFO": {"ttr": 4617, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x003\\x01\\x10&\\x0f\\x01\\x10&/\\x00\\x00\\x03\\x9f\\x03\\xa1\\x03\\x9f\\xc5\\xe7\\xc1\\xd4\\xd7\\xd3\\xc5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2010-09-17T00:00:00", "modifydate": "2010-09-19T00:00:33", "lines": 927, "newlines": 929, "modlines": 927, "user": "EXAMPLE"}, "text": "DUMPINFO TITLE                                                        'X\n               -- DUMP SVC99 INFORMATION RETRIEVAL INFO --             X\n               CENTERIOR ENERGY CORPORATION'\n* MODULE NAME = DUMPINFO\n* FUNCTION = PRINT SVC99 INFORMATION FROM ALL CURRENT ALLOCATIONS.\n* OPERATION = GETMAIN WORKING STORAGE, ESTABLISH SAVEAREA LINKAGES;\n*             IF DCB NOT SUPPLIED, OPEN DDNAME SYSPRINT;\n*             PRINT SUPPLIED CHARACTER STRING ON SYSPRINT;\n*             FOR EACH EXISTING ALLOCATION,\n*                CALL SVC99 FOR INFORMATION;\n*                PRINT INFORMATION ON SYSPRINT;\n*             DUMP TRANSLATE TABLES\n*             IF DCB WAS NOT SUPPLIED, CLOSE SYSPRINT;\n*             UNLINK SAVEAREAS, FREEMAIN STORAGE, RETURN.\n* PARAMETERS = 1. CHARACTER STRING ( AL2(LENGTH), CL(LENGTH)'...' )\n*                TO BE PRINTED IN HEADINGS.\n*              2. CHARACTER STRING ( CL8'...' )\n*                DDNAME OF PRINT FILE TO BE USED\n*             WHEN INVOKED THROUGH JCL, PARAMETER 2 NOT PRESENT.\n* ATTRIBUTES = REENTRANT, REUSABLE, PROBLEM PROGRAM STATE\n* DURING EXECUTION:  R13 POINTS TO GOTTEN STORAGE (SAVEAREA @ START)\n*                    R12 POINTS TO START OF CSECT, IS BASE REGISTER\n*                    R9 POINTS TO SYSPRINT DCB\n*\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n*\nDUMPINFO CSECT\nDUMPINFO AMODE 24\nDUMPINFO RMODE 24\n         PRINT ON,GEN\n         SPLEVEL\n*\n*...+....1....+....2....+....3....+,\n         MACRO                     , THE LOCAL SYSTEM VARIABLE SYMBOL\n         SETTEMP                   , &SYSECT IS ASSIGNED A VALUE WHEN\n         GBLC  &TEMP               , A MACRO IS CALLED, AND THE VALUE\n&TEMP    SETC '&SYSECT.'           , IS ONLY AVAILABLE IN THE MACRO--\n         MEND                      , THIS MACRO, PLUS THE DECLARATION\n         GBLC  &TEMP               , OF &TEMP, PROPOGATE IT OUTSIDE.\n*...+....1....+....2....+....3....+,\n*\n         LCLC  &CSECTNM            , DEFINE FOR LATER USE\n         SETTEMP                   , MAKE &SYSECT AVAILABLE, IN &TEMP\n&CSECTNM SETC  '&TEMP.'            ,   AND SAVE IT FOR LATER USE\n*\n         LCLA  &LCLA\n         LCLC  &LCLC\n&LCLC    SETC  '&CSECTNM. (ASM &SYSDATE. &SYSTIME.) CENTERIOR '\n&LCLA    SETA  (K'&LCLC+8-1)/8*8-1   PAD TO A MULTIPLE OF 8 MINUS 1\n*\n         B     AROUND-*(,R15)      BRANCH AROUND LGH BYTE, ID TEXT\n*\nLGHBYTE  DC    AL1(&LCLA.)                       LGH BYTE,\nIDTEXT   DC    CL&LCLA.'&LCLC.'                          , ID TEXT\n*\nAROUND   DS    0H\n         SAVE  (14,12)             SAVE CALLER'S REGISTERS\n*\n         LR    R12,R15             COPY BASE REGISTER\n         USING &CSECTNM.,R12       TELL ASEMBLER\n*\n         LA    R0,L'USRDSECT       LENGTH OF DSECT\n         GETMAIN RU,LV=(0)         UNCONDITIONAL\n* REGISTERS 0,1,15 NOT PRESERVED -- ADDRESS OF GOTTEN STORAGE IS IN R1\n*\n         LR    R2,R1               PAIR R2,R3 = GOTTEN STORAGE,LENGTH\n         LA    R3,L'USRDSECT       PAIR R2,R3 = GOTTEN STORAGE,LENGTH\n         LR    R4,R1            PAIR R4,R5 = ANYWHERE LOC, 0 LENGTH/PAD\n         XR    R5,R5            PAIR R4,R5 = ANYWHERE LOC, 0 LENGTH/PAD\n         MVCL  R2,R4               CLEAR THE GOTTEN STORAGE\n*\n* CHAIN THE SAVE AREAS\n         ST    R13,4(,R1)          STORE BACKWARD PTR IN GOTTEN\n         ST    R1,8(,R13)          STORE FORWARD PTR IN CALLER'S\n         LR    R13,R1              POINT R13 TO GOTTEN STORAGE\n         USING USRDSECT,R13        ESTABLISH ADDRESSABILITY\n*\n         B     AROUND2             SKIP TO CONTINUED PROCESSING\n*\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n*\nRETURN   DS    0H\n*\n         L     R8,RC               SAVE RETURN CODE, BEFORE DROP R13\n*\n*        PREPARE R0 AND R1 FOR FREEMAIN, BEFORE R13 IS DROPPED\n         LA    R0,L'USRDSECT       LENGTH OF AREA TO FREEMAIN\n         LA    R1,USRDSECT         ADDRESS OF AREA TO FREEMAIN\n         DROP  R13\n         L     R13,4(,R13)         RESTORE PTR TO CALLER'S SAVE AREA\n         FREEMAIN RU,LV=(0),A=(1)  UNCONDITIONAL\n*\n         LR    R15,R8              MOVE RETURN CODE TO PROPER REGISTER\n         RETURN (14,12),T,RC=(15)  RETURN TO CALLER, WITH RC IN R15\n*\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n*\nAROUND2  DS    0H\n         USING USRDSECT,R13        RE-ESTABLISH ADDRESSABILITY\n*\n         MVC   LBLSTM16,=CL4':STM'  FOR DEBUGGING PURPOSES\n         MVC   LBLWCRE,=CL4'WCRE'   FOR DEBUGGING PURPOSES\n         MVC   LBLDS1F,=CL4'DS1F'   FOR DEBUGGING PURPOSES\n         MVC   LBLDS1H,=CL4'DS1H'   FOR DEBUGGING PURPOSES\n         MVC   LBLDS1X,=CL4'DS1X'   FOR DEBUGGING PURPOSES\n         MVC   ZTLIBGOT,=CL8':TLIBGOT'\n         MVC   ZSDCBGOT,=CL8':SDCBGOT'\n         MVC   ZOPENGOT,=CL8':OPENGOT'\n         MVC   ZSNAPGOT,=CL8':SNAPGOT'\n         MVC   ZWRITGOT,=CL8':WRITGOT'\n*\n         MVI   PRTLINE,C' '\n         MVC   PRTLINE+1(L'PRTLINE-1),PRTLINE\n*\n         MVC   SDCBGOT(DCBL#L),SDCBL       MOVE MODEL TO GOTTEN\n*\n         L     R6,SAVE#BWD         FETCH POINTER TO CALLER'S SAVEAREA\n         L     R6,SAVE#R1-SAVEAREA(R6) FETCH SAVED PARM POINTER\n         LTR   R6,R6               Q. ANY PARAMETERS?\n         BZ    XPARM2               A. NO -- NO PARM 2\n         TM    0(R6),X'80'         Q. IS HIGH BIT SET IN 1ST POINTER ?\n         BO    XPARM2               A. YES -- ONLY 1 PARM, NO PARM 2\n         L     R8,4(R6)            FETCH SECOND PARAMETER\n         LTR   R8,R8               Q. IS ADDRESS ZERO ?\n         BZ    XPARM2               A. YES -- NO DCB SUPPLIED\n         LA    R9,SDCBGOT          R9 -> SDCBGOT\n         USING IHADCB,R9           ESTABLISH ADDRESSABILITY\n         MVC   DCBDDNAM,0(R8)      MOVE IN DDNAME SUPPLIED\n         DROP  R9                  DROP ADDRESSABILITY\nXPARM2   DS    0H\n*\n         TM    SYSPROPN,X'FF'      TEST THE FLAG FIELD\n         BO    SNAPOPEN            FLAG WAS SET, MEANS NO NEED TO OPEN.\n         LA    R9,SDCBGOT          R9 -> SDCBGOT\n         USING IHADCB,R9           ESTABLISH ADDRESSABILITY\n         MVC   OPENGOT(OPENL#L),OPENL     MOVE MODEL TO GOTTEN\n         OPEN  ((R9),OUTPUT),MF=(E,OPENGOT)\n         TM    DCBOFLGS,DCBOFOPN   Q. OPEN SUCCESSFUL ?\n         BO    SNAPOPEN            A. YES -- SKIP ERROR MESSAGE\n* ALLOCATE DDNAME SYSPRINT, WITH DEFAULT SYSOUT CLASS\n         CECDYN  PREFIX=YYY,MF=(E,WORKAREA),                           X\n               VERB=AL,      ALLOCATE                                  X\n               TEXT=((DDNAM,'SYSPRINT'),SYSOU)\n         DYNALLOC            ISSUE SVC99\n         OPEN  ((R9),OUTPUT),MF=(E,OPENGOT)\n         MVI   SYSPRDYN,X'FF'      REMEMBER TO DEALLOCATE\n         TM    DCBOFLGS,DCBOFOPN   Q. OPEN SUCCESSFUL ?\n         BO    SNAPOPEN            A. YES -- SKIP ERROR MESSAGE\n         MVI   SYSPRDYN,X'00'      NO NEED TO DEALLOCATE\n         DROP  R9                  DROP ADDRESSABILITY\n         WTO   '&CSECTNM. -- OPEN UNSUCCESSFUL FOR SYSPRINT'\n         MVC   RC,=F'16'           SET RETURN CODE\n         B     RETURN              AND RETURN\nSNAPOPEN DS    0H\n         MVI   SYSPROPN,X'FF'      MESSAGE FILE IS OPEN\n*\n         MVC   SNAPGOT(SNAPL#L),SNAPL     MOVE MODEL TO GOTTEN\n*                   (MUST BE DONE BEFORE FIRST   SNAP MF=(E,SNAPGOT) )\n*\n         MVC   WRITGOT(WRITL#L),WRITL     MOVE MODEL TO GOTTEN\n*                      (MUST BE DONE BEFORE FIRST   BAS R14,WRITCHEK )\n*\n******** LA    R3,L'USRDSECT(R13)    POINT TO END OF GOTTEN STORAGE\n******** LA    R2,LTORGED            POINT TO END OF CODE\n******** SNAP  DCB=(R9),MF=(E,SNAPGOT),ID=101,STORAGE=((R13),(R3),     X\n               (R12),(R2)),PDATA=REGS,SDATA=CB\n*\n         MVI   PRTLINE,C'1'\n         LA    R5,PRTLINE+1\n*\n         MVC   0(L'IDTEXT,R5),IDTEXT                                 A\n         LA    R5,L'IDTEXT+1(,R5)                                     B\n*\n         L     R6,SAVE#BWD         FETCH POINTER TO CALLER'S SAVEAREA\n         ICM   R6,B'1111',SAVE#R1-SAVEAREA(R6) FETCH AND TEST SAVED R1\n         BZ    YPARM1              WAS ZERO -- NO PARMS AT ALL\n         L     R8,0(R6)            FETCH POINTER TO 1ST PARAMETER\n LA    R1,=CL16'PARMLGH='                                        DEBUG\n LA    R1,8(R1)          TARGET ADDRESS   NON-REENTRANT!!!       DEBUG\n LA    R2,0(R8)          SOURCE ADDRESS                          DEBUG\n LA    R3,2              SOURCE LENGTH                           DEBUG\n BAS   R14,CONVHEX       CALL SUBROUTINE                         DEBUG\n LA    R1,=CL16'PARM1-8='                                        DEBUG\n LA    R1,8(R1)          TARGET ADDRESS   NON-REENTRANT!!!       DEBUG\n MVC   0(8,R1),2(R8)     SOURCE ADDRESS                          DEBUG\n         LH    R7,0(R8)            FETCH LENGTH FIELD\n         LTR   R7,R7               Q. WAS LENGTH ZERO ?\n         BZ    YPARM1              A. YES -- NULL STRING\n STH   R7,DS1H                                                   DEBUG\n LA    R1,=CL8'.R7='                                             DEBUG\n LA    R1,4(R1)          TARGET ADDRESS   NON-REENTRANT!!!       DEBUG\n LA    R2,DS1H           SOURCE ADDRESS                          DEBUG\n LA    R3,2              SOURCE LENGTH                           DEBUG\n BAS   R14,CONVHEX       CALL SUBROUTINE                         DEBUG\n         CH    R7,=AL2(L'PRTLINE-1-L'IDTEXT) CHECK WHETHER TOO LONG\n         BL    R7OK                NO, IT IS OK\n         LH    R7,=AL2(L'PRTLINE-1-L'IDTEXT) TOO LONG -- LIMIT TO MAX.\nR7OK     BCTR  R7,0                DECREMENT FOR EX INSTRUCTIONS\n         EX    R7,EXMVCPRT         MOVE CHARACTER STRING TO PRINT LINE\n         LA    R5,0+1+2(R7,R5)                                        B\n         C     R7,=F'3'            CHECK PARM LENGTH (REMEMBER, -1)\n         BL    ZPARM1              SHORTER THAN 4\n         CLC   =C'SNAP',2(R8)      Q. CHECK 1ST 4 CHARACTERS\n         BNE   ZPARM1              A. NO, SNAP NOT REQUESTED\n         LA    R3,L'USRDSECT(R13)    POINT TO END OF GOTTEN STORAGE\n         LA    R2,LTORGED            POINT TO END OF CODE\n         SNAP  DCB=(R9),MF=(E,SNAPGOT),ID=103,STORAGE=((R13),(R3),     X\n               (R12),(R2)),PDATA=REGS,SDATA=CB\n         B     ZPARM1\nEXMVCPRT MVC   0(*-*,R5),2(R8)     WILL BE EXECUTED\nYPARM1   DS    0H\n* FOLLOWING CODE FROM \"MVS UPDATE\" NO.22, JULY 1988, XEPHON INC.\n         L     R2,16               POINT TO CVT\n         L     R2,0(,R2)           TO TCBWORDS\n         L     R2,4(,R2)           TO TCB\n         L     R3,12(,R2)                    TO TIOT, & SAVE IN R3\n         L     R2,180(,R2)         TO JSCB (TCBJSCB)\n         L     R2,348(,R2)         TO ACTIVE JSCB (JSCBACT)\n         ICM   R2,B'1111',316(R2)  TO LIFE-OF-JOB SSIB (JSCBSSIB)\n         MVC   DSCL8(8),=CL8' '\n         BZ    NOID                (SKIP IF NO L-O-J SSIB)\n         MVC   DSCL8(8),12(R2)     COPY JOB NUMBER (SSIBJBID)\nNOID     EQU   *\n*     ABOVE CODE FROM \"MVS UPDATE\" NO.22, JULY 1988, XEPHON INC.\n*\n         MVC   0(8,R5),DSCL8       JOB NUMBER FROM SSIB              A\n         LA    R5,8+2(,R5)                                            B\n*\n         MVC   0(8,R5),0(R3)       JOB NAME FROM TIOT                A\n         LA    R5,8+2(,R5)                                            B\n*\n         MVC   0(8,R5),8(R3)       STEP NAME FROM TIOT               A\n         LA    R5,8+2(,R5)                                            B\n*\n         MVC   0(8,R5),16(R3)      PROCSTEPNAME FROM TIOT            A\n         LA    R5,8+2(,R5)                                            B\n*\n         USING PSA,R0              MACRO IHAPSA FROM SYS1.MACLIB\n         L     R1,FLCCVT      ADDRESS OF CVT (AFTER IPL).  THIS OFFSET\n*                             FIXED BY ARCHITECTURE.  (MDC450) @G50EP9A\n         DROP  R0                  MACRO IHAPSA FROM SYS1.MACLIB\n         USING CVT,R1              MACRO CVT FROM SYS1.AMODGEN\n         L     R2,CVTSMCA    ADDRESS OF THE SYSTEM MANAGEMENT CONTROL\n*                            AREA (SMCA) IF THE SYSTEM MANAGEMENT\n*                            FACILITIES (SMF) OPTION IS PRESENT IN THE\n*                            SYSTEM.  OTHERWISE, ZERO.\n         DROP  R1                  MACRO CVT FROM SYS1.AMODGEN\n         USING SMCABASE,R2         MACRO IEESMCA FROM SYS1.AMODGEN\n         LA    R3,SMCASID    SYSTEM IDENTIFICATION (SID)         MDC002\n         DROP  R2                  MACRO IEESMCA FROM SYS1.AMODGEN\n*\n         MVC   0(4,R5),0(R3)       SYSTEM IDENTIFICATION (SID)       A\n         LA    R5,4+2(,R5)                                            B\n*\n         TIME  , RETURN DATE IN R1 AS 00YYDDDC, TIME IN R0 AS HHMMSSTH\n         STM   R0,R1,STM16F        SAVE\n*\n         MVC   0(6,R5),=XL7'F0202020202020'                          A\n         ED    0(6,R5),STM16F+5    SOURCE IS YYDDDC, FROM R1         A\n         MVI   0(R5),C'D'          LEADING CHARACTER                 A\n         LA    R5,6+2(,R5)                                            B\n*\n         MVC   0(7,R5),=XL7'F0202020202020'                          A\n         ED    0(7,R5),STM16F      SOURCE IS HHMMSSTH, FROM R0       A\n         MVI   0(R5),C'T'          LEADING CHARACTER                 A\n         LA    R5,7+2(,R5)                                            B\n* NOTE: THE EDIT MASKS ABOVE ARE BOTH XL7, SO ONLY 1 FIELD IS USED,\n*      BUT DIFFERENT SUBSTRINGS OF IT ARE USED IN THE TWO INSTANCES.\n*\nZPARM1   DS    0H\n         BAS   R14,WRITCHEK\n*\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         MACRO\n         PRTFORM\n&KEYSFX  SETC  '&SYSLIST(2)'(4,K'&SYSLIST(2)-4+1) RTSTA,RTTYP,RELNO,ETC\n         AIF   (N'&SYSLIST NE 4).NO4TH\n&SHORT   SETC  '&SYSLIST(4)'\n         AIF   (K'&SHORT LT 4).NO4TH\n         AIF   ('&SHORT'(1,1) NE '''' OR '&SHORT'(K'&SHORT,1) NE '''').X\n               SHORTED\n&SHORT   SETC  '&SHORT'(2,K'&SHORT-2)      TRIM QUOTES\n         AGO   .SHORTED                    SPECIAL CASE -- PRTBITS\n.NO4TH   ANOP\n&SHORT   SETC  '&KEYSFX'    DUPLICATE\n         AIF   ('&KEYSFX'(1,2) NE 'RT').SHORTED\n&SHORT   SETC  '&KEYSFX'(3,K'&KEYSFX-3+1)         STA,  TYP,  LNO,  ETC\n.SHORTED ANOP  , DONE SHORTENING                              RELNO.\n&LCLA    SETA  K'&SHORT\n         AIF   ('&SYSLIST(1)' EQ 'HEAD').HEAD\n         AIF   ('&SYSLIST(1)' EQ 'DETAIL').DETAIL\n         MNOTE 12,'&SYSLIST(1) INVALID, ONLY HEAD OR DETAIL PERMITTED'\n.HEAD    MVC   PRT&KEYSFX.(&LCLA.),=C'&SHORT.'\n         MEXIT\n.MVC     MVC   PRT&KEYSFX.(L'&SYSLIST(2).),&SYSLIST(2).\n         MEXIT\n.DETAIL  ANOP\n         AIF   (T'&SYSLIST(2) EQ 'C').MVC\n         LA    R1,PRT&KEYSFX.      LOAD TARGET ADDRESS\n         LA    R2,&SYSLIST(2).     LOAD SOURCE ADDRESS\n         LA    R3,L'&SYSLIST(2).   LOAD SOURCE LENGTH\n         BAS   R14,CONVHEX         CALL SUBROUTINE\n         AIF   ('&SYSLIST(3)' EQ 'LOOKUP').LOOKUP\n         AIF   ('&SYSLIST(3)' EQ '').MEXIT\n         MNOTE 12,'SYSLIST(3)=&SYSLIST(3) INVALID, ONLY LOOKUP VALID'\n.MEXIT   MEXIT\n.LOOKUP  LA    R1,PRT&KEYSFX.      LOAD ADDRESS OF KEY TO LOOKUP\n         LA    R2,TBL&KEYSFX.      LOAD ADDRESS OF TABLE\n         BAS   R14,LOOKUP          CALL SUBROUTINE\n         MEND\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n*\n         PRTFORM HEAD,ZZZRELNO\n         PRTFORM HEAD,ZZZRTDDN,,' DDN'\n         PRTFORM HEAD,ZZZRTDSN\n         PRTFORM HEAD,ZZZRTMEM\n         PRTFORM HEAD,ZZZRTSTA\n         PRTFORM HEAD,ZZZRTNDP\n         PRTFORM HEAD,ZZZRTCDP\n         PRTFORM HEAD,ZZZRTORG\n         PRTFORM HEAD,ZZZRTLIM\n         PRTFORM HEAD,ZZZRTTYP\n         PRTFORM HEAD,ZZZRTATT\n         PRTFORM HEAD,PRTBITS,,' ATTBITS'\n         PRTFORM HEAD,ZZZRTLST\n         MVI   PRTCCG,C'0'\n*\n         BAS   R14,WRITCHEK\n*\n*\n******** LA    R3,L'USRDSECT(R13)    POINT TO END OF GOTTEN STORAGE\n******** LA    R2,LTORGED            POINT TO END OF CODE\n******** SNAP  DCB=(R9),MF=(E,SNAPGOT),ID=105,STORAGE=((R13),(R3),     X\n               (R12),(R2)),PDATA=REGS,SDATA=CB\n*\n* MAIN LOOP:\n         LA    R5,1          SET COUNTER TO ORDINAL 1 (1ST)\nNEXTINFO EQU   *\n         ST    R5,DS#RELNO\n         LA    R4,DS#RELNO\n* REQUEST INFORMATION FOR RELATIVE NUMBER SPECIFIED IN REGISTER 5:\n         CECDYN  PREFIX=ZZZ,MF=(E,WORKAREA),                           X\n               VERB=IN,      INFORMATION RETRIEVAL                     X\n               TEXT=((RELNO,(R4)),RTLST,RTDDN,RTDSN,RTMEM,RTSTA,       X\n               RTNDP,RTCDP,RTORG,RTLIM,RTATT,RTTYP)\n         DYNALLOC            ISSUE SVC99\n*\n         LA    R8,WORKAREA\n         USING ZZZDSECT,R8   ESTABLISH ADDRESSABILITY TO ZZZ... FIELDS\n         PRTFORM DETAIL,ZZZRELNO\n         PRTFORM DETAIL,ZZZRTDDN\n         PRTFORM DETAIL,ZZZRTDSN\n         PRTFORM DETAIL,ZZZRTMEM\n         PRTFORM DETAIL,ZZZRTSTA,LOOKUP\n         PRTFORM DETAIL,ZZZRTNDP,LOOKUP\n         PRTFORM DETAIL,ZZZRTCDP,LOOKUP\n         PRTFORM DETAIL,ZZZRTORG,LOOKUP\n         PRTFORM DETAIL,ZZZRTLIM\n         PRTFORM DETAIL,ZZZRTTYP,LOOKUP\n         PRTFORM DETAIL,ZZZRTATT\n         MVC   DS1X,ZZZRTATT\n         BAS   R14,DS1XBITS  TRANSFORM DS1X INTO PRTBITS\n         PRTFORM DETAIL,ZZZRTLST,LOOKUP\n         DROP  R8            NO MORE NEED FOR ZZZ... FIELDS\n*\n         BAS   R14,WRITCHEK\n*\n* FORMAT INFORMATION RETURNED:\n******** LA    R3,L'USRDSECT(R13)    POINT TO END OF GOTTEN STORAGE\n******** LA    R2,LTORGED            POINT TO END OF CODE\n******** SNAP  DCB=(R9),MF=(E,SNAPGOT),ID=(R5),STORAGE=((R13),(R3),    X\n               (R12),(R2)),PDATA=REGS,SDATA=CB\n*\n         LA    R5,1(R5)      INCREMENT RELATIVE NUMBER REQUESTED\n         LA    R1,WORKAREA   LOAD ADDRESS OF LIST\n         USING ZZZDSECT,R1   REG1 POINTS TO DSECT\n         TM    ZZZRTLST,X'80'  Q. IS THE HIGH BIT ON?\n         DROP  R1\n         BZ    NEXTINFO        A. NO, GO DO ANOTHER ONE\n*\n*\n         LA    R1,TBLRTLST\n         LA    R3,PRTLINE+1\n         LA    R4,PRTLINE+L'PRTLINE-9\n         BAS   R14,TBLDUMP\n         MVI   PRTCCG,C'0'\n         BAS   R14,WRITCHEK\n*\n         LA    R1,TBLRTSTA\n         LA    R3,PRTLINE+1\n         LA    R4,PRTLINE+L'PRTLINE-9\n         BAS   R14,TBLDUMP\n         BAS   R14,WRITCHEK\n*\n         LA    R1,TBLRTNDP\n         LA    R3,PRTLINE+1\n         LA    R4,PRTLINE+L'PRTLINE-9\n         BAS   R14,TBLDUMP\n         BAS   R14,WRITCHEK\n*\n         LA    R1,TBLRTCDP\n         LA    R3,PRTLINE+1\n         LA    R4,PRTLINE+L'PRTLINE-9\n         BAS   R14,TBLDUMP\n         BAS   R14,WRITCHEK\n*\n         LA    R1,TBLRTORG\n         LA    R3,PRTLINE+1\n         LA    R4,PRTLINE+L'PRTLINE-9\n         BAS   R14,TBLDUMP\nMORE#ORG STM   R15,R2,STM16F SAVE POINTERS+INDICATORS BEFORE WRITCHEK\n*STM   R15,R2,STM16F     SAVE REGISTERS                          DEBUG\n*LA    R1,=CL64'MORE#ORG R15,0-2'                                DEBUG\n*LA    R1,16(R1)         TARGET ADDRESS   NON-REENTRANT!!!       DEBUG\n*LA    R2,STM16F         SOURCE ADDRESS                          DEBUG\n*LA    R3,4              SOURCE LENGTH                           DEBUG\n*BAS   R14,CONVHEX       CALL SUBROUTINE                         DEBUG\n*BAS   R14,CONVHEX       CALL SUBROUTINE                         DEBUG\n*BAS   R14,CONVHEX       CALL SUBROUTINE                         DEBUG\n*BAS   R14,CONVHEX       CALL SUBROUTINE                         DEBUG\n*LM    R15,R2,STM16F     RESTORE REGISTERS                       DEBUG\n         BAS   R14,WRITCHEK\n         LM    R15,R2,STM16F RESTORE POINTERS & INDICATORS\n         LTR   R15,R15       CHECK RETURN FROM TBLDUMP ROUTINE\n         BZ    DONE#ORG      NO, THERE IS NO MORE TO DO\n         BAS   R14,TBLDUMP2  ALTERNATE ENTRY POINT -- R0-4 SET-UP\n         B     MORE#ORG\nDONE#ORG DS    0H\n*\n         LA    R1,TBLRTTYP\n         LA    R3,PRTLINE+1\n         LA    R4,PRTLINE+L'PRTLINE-9\n         BAS   R14,TBLDUMP\n         BAS   R14,WRITCHEK\n*\n*                               '....+....1....+...~.2....+...~.3.'\n         MVC   PRTLINE(31),=CL31' ATT - BIT 0=PERM''LY CONCAT''D; '\n*                                  '....+....1....'\n         MVC   PRTLINE+31(14),=CL14'BIT 1=IN USE; '\n*                                     '....+....1.~...+....2....+'\n         MVC   PRTLINE+31+14(25),=CL25'BIT 2=PERM''LY ALLOCATED; '\n*                                        '....+....1....+....'\n         MVC   PRTLINE+31+14+25(19),=CL19'BIT 3=CONVERTIBLE; '\n*                                           '....+....1....+~...'\n         MVC   PRTLINE+31+14+25+19(18),=CL18'BIT 4=DYNALLOC''D; '\n*                                              '....+....1....+...'\n         MVC   PRTLINE+31+14+25+19+18(18),=CL18'BITS 5-7=RESERVED.'\n         BAS   R14,WRITCHEK\n*\n*\n******** LA    R3,L'USRDSECT(R13)    POINT TO END OF GOTTEN STORAGE\n******** LA    R2,LTORGED            POINT TO END OF CODE\n******** SNAP  DCB=(R9),MF=(E,SNAPGOT),ID=255,STORAGE=((R13),(R3),     X\n               (R12),(R2)),PDATA=REGS,SDATA=CB\n*\n         CLOSE ((R9)),MF=(E,OPENGOT)\nSNAPCLOS DS    0H\n*\n         TM    SYSPRDYN,X'01'      TEST A BIT OF FLAG FIELD\n         BNO   SYSPRUN             FLAG IS NO, NO NEED TO UNALLOCATE\n* UNALLOCATE DDNAME SYSPRINT\n         CECDYN  PREFIX=XXX,MF=(E,WORKAREA),                           X\n               VERB=UN,      UNALLOCATE                                X\n               TEXT=((DDNAM,'SYSPRINT'))\n         DYNALLOC            ISSUE SVC99\nSYSPRUN  EQU   *\n*\n         B     RETURN              ALL DONE WITH PROCESSING\n*\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n*\nWRITCHEK ST    R14,WC#R14    SAVE, BECAUSE WRITE & CHECK WILL USE R14.\n         LA    R0,L'PRTLINE+L'PRTRDW+L'PRTRDW00+L'PRTBDW+L'PRTBDW00\n         STH   R0,PRTBDW\n         XC    PRTBDW00,PRTBDW00\n         LA    R0,L'PRTLINE+L'PRTRDW+L'PRTRDW00\n         STH   R0,PRTRDW\n         XC    PRTRDW00,PRTRDW00\n         WRITE WRITGOT,SF,(R9),PRTAREA,MF=E\n         CHECK WRITGOT\n         MVI   PRTLINE,C' '\n         MVC   PRTLINE+1(L'PRTLINE-1),PRTLINE\n         L     R14,WC#R14    RESTORE\n         BR    R14\n*\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         EJECT\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\nCONVHEX  DS   0H , CONVERT BINARY TO ZONED HEXIDECIMAL EQUIVALENT\n* R1    = TARGET ADDRESS.   (TARGET EXACTLY TWICE AS LONG AS SOURCE)\n* R2    = SOURCE ADDRESS.\n* R3    = SOURCE LENGTH.    (ONLY 1 THRU 16 IS PERMITTED)\n* R4,R5 = WORK REGISTERS.\n* R14   = RETURN ADDRESS -- CALL:  BAS R14,CONVHEX\n* ON RETURN: R1 & R2 WILL BE POSITIONED JUST-PAST PROCESSED AREAS,\n*            R3 WILL BE UNCHANGED.\n         SAVE  (3,5)\n         N     R3,=X'000000FF' FORCE TO 16 OR LESS\n         LTR   R4,R3         RESULT:  L'SRC\n         BZ    XCONVHEX      IF ZERO, DO NOTHING\n         BCTR  R4,0          RESULT:  L'SRC-1\n         IC    R5,0(R2,R4)   FETCH LAST BYTE OF SOURCE\n         AR    R4,R4         RESULT:  2*L'SRC-2\n         STC   R5,1(R1,R4)   STORE INTO LAST BYTE OF TARGET\n         LR    R5,R4         SAVE     2*L'SRC-2   FOR LATER EXMVZ\n         SLL   R4,FOUR       RESULT:  AL1(2*L'SRC-2),AL1(0)\n         OR    R4,R3         RESULT:  AL1(2*L'SRC-2),AL1(L'SRC)\n         BCTR  R4,0          RESULT:  AL1(2*L'SRC-2),AL1(L'SRC-1)\n         EX    R4,EXUNPK     UNPACK (SOURCE) TO (TARGET MINUS 1 BYTE)\n         NI    0(R1),X'0F'   CLEAR FIRST HI-BYTE OF TARGET\n         EX    R5,EXMVZ      CLEAR ALL HI-BYTES OF TARGET\n         LA    R5,1(R5)      RESULT:  2*L'SRC-1\n         EX    R5,EXTR       CHANGE LO-BYTES TO PRINTABLE CHARACTERS\n         LA    R1,1(R5,R1)   ADVANCE PAST TARGET\n         LA    R2,0(R3,R2)   ADVANCE PAST SOURCE\nXCONVHEX RETURN (3,5),RC=0   RETURN TO CALLER\nEXUNPK   UNPK  0(*-*,R1),0(*-*,R2)    EXECUTED\nEXMVZ    MVZ   1(*-*,R1),0(R1)        EXECUTED\nEXTR     TR    0(*-*,R1),TRANTBL      EXECUTED\nTRANTBL  DC    C'0123456789ABCDEF' TRANSLATE TABLE\nFOUR     EQU   4\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         EJECT\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n* LOOKUP -- LOOKUP VALUE IN TABLE, REPLACE WITH TABLE ENTRY'S VALUE\n* R1    = ADDRESS OF KEY TO LOOKUP\n* R2    = ADDRESS OF TABLE\n* R14   = RETURN ADDRESS.      CALL:    BAS R14,LOOKUP\n* R15,R0,R3,R4 = WORK REGISTERS.\n* ON RETURN: R1 AND R2 WILL BE UNCHANGED.\n*            IF KEY WAS FOUND IN TABLE,\n*                 REPLACEMENT VALUE WAS PLACED JUST-AFTER KEY AND R15=0\n*            IF KEY WAS NOT FOUND, R15 IS NON-ZERO\n* FIRST FULLWORD AT START OF TABLE IS A(TABLE ID), WHICH IS AL1(),C'  '\n* NEXT FULLWORD AT START OF TABLE CONTAINS:\n*  1 BYTE = KEY LENGTH, 1 BYTE = REPLACEMENT LENGTH,\n*  HALFWORD = NUMBER OF PAIRS IN TABLE;\n* THEN FOLLOWING, PAIRS OF KEY + REPLACEMENT.\nEXCLC1F  CLC   0(*-*,R1),0(R15)        WILL BE EXECUTED (R1, R'F')\nEXMVC3F  MVC   0(*-*,R3),0(R15)        WILL BE EXECUTED (R3, R'F')\nLOOKUP   LA    R0,1                    PRIME\n         XR    R3,R3                   CLEAR\n         XR    R4,R4                   CLEAR\n         IC    R3,4(R2)                FETCH KEY LENGTH FROM TABLE\n         IC    R4,5(R2)                FETCH REPLACEMENT LENGTH\n         AH    R0,6(R2)                R0 CONTAINS 1 + # OF ENTRIES\n         LA    R15,8(R2)               POINT TO FIRST TABLE ENTRY\n         BCTR  R3,0                    DECREMENT FOR EX INSTRUCTIONS\n         BCTR  R4,0                    DECREMENT FOR EX INSTRUCTIONS\nLOOKLOOP EX    R3,EXCLC1F              Q. IS IT A MATCH ?\n         LA    R15,1(R3,R15)           STEP PAST KEY (NO CC CHANGE)\n         BE    LOOKHERE                A. YES, JUMP OUT OF LOOP\n         LA    R15,1(R4,R15)           STEP PAST REPLACEMENT\n         BCT   R0,LOOKLOOP             POSSIBLY CHECK SOME MORE\n         RETURN RC=(15)                RETURN TO CALLER (R15 NON-ZERO)\nLOOKHERE LA    R3,1(R1,R3)             POINT TO JUST-PAST KEY\n         C     R4,=F'-1'               Q. WAS REPLACEMENT LENGTH 0 ?\n         BE    LOOKDONE                A. YES--NO REPLACE, JUST RETURN\n         EX    R4,EXMVC3F              MOVE REPLACEMENT THERE\nLOOKDONE RETURN RC=0                   RETURN TO CALLER WITH R15=0\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         EJECT\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n* TBLDUMP -- FORMAT TRANSFORMATION TABLE FOR PRINTING\n* R1    = ADDRESS OF TABLE\n* R3    = ADDRESS OF PRINT LINE\n* R4    = ADDRESS OF END OF PRINT LINE (TO CHECK FOR FILLING-UP)\n* R14   = RETURN ADDRESS.      CALL:    BAS R14,TBLDUMP\n* R15,R0,R2,R3,R4,R5 = WORK REGISTERS\n* DURING EXECUTION: R15 POINTS TO LAST BYTE MOVED INTO PRINT LINE\n*                   R0 CONTAINS COUNT OF ENTRIES TO BE PROCESSED\n* ON RETURN: R1,R3,R4 WILL BE UNCHANGED.\n*            PRTLINE WILL BE SET-UP.\n*            IF TABLE EXHAUSTED, RC=0 -- ELSE, NON-ZERO.\n*\n* FIRST FULLWORD AT START OF TABLE IS A(TABLE ID), WHICH IS AL1(),C'  '\n* NEXT FULLWORD AT START OF TABLE CONTAINS:\n*  1 BYTE = KEY LENGTH, 1 BYTE = REPLACEMENT LENGTH,\n*  HALFWORD = NUMBER OF PAIRS IN TABLE;\n* THEN FOLLOWING, PAIRS OF KEY + REPLACEMENT.\nEXMVCF2  MVC   0(*-*,R15),0(R2)        WILL BE EXECUTED (R'F', R2)\nEXMVCF3  MVC   0(*-*,R15),0(R3)        WILL BE EXECUTED (R'F', R3)\nTBLDUMP  DS   0H                       NORMAL ENTRY POINT.\n         LH    R0,6(R1)                FETCH # OF ENTRIES IN TABLE\n         LA    R2,8(R1)                POINT TO FIRST TABLE ENTRY\nTBLDUMP2 DS   0H , ALTERNATE ENTRY POINT: EXPECT R0,R2 UNCHANGED\n         SAVE  (3,4)\n         LR    R15,R3                  SAVE START-ADDRESS OF PRINT LINE\n         LR    R5,R4                   SAVE END-ADDRESS OF PRINT LINE\n         L     R3,0(R1)                FETCH ADDRESS OF TABLE-ID\n         XR    R4,R4                   CLEAR\n         IC    R4,0(R3)                FETCH TABLE-ID LENGTH FROM TABLE\n         BCTR  R4,0                    DECREMENT FOR EX INSTRUCTIONS\n         LA    R3,1(R3)                POINT TO TABLE-ID CHARACTERS\n         EX    R4,EXMVCF3              MOVE TABLE-ID TO PRINT LINE\n         LA    R15,1(R4,R15)           ADVANCE TARGET POINTER, R4+1\n         MVI   0(R15),C':'             MOVE TO PRINT LINE\n         XR    R3,R3                   CLEAR\n         XR    R4,R4                   CLEAR\n         IC    R3,4(R1)                FETCH KEY LENGTH FROM TABLE\n         IC    R4,5(R1)                FETCH REPLACEMENT LENGTH\n         BCTR  R3,0                    DECREMENT FOR EX INSTRUCTIONS\n         BCTR  R4,0                    DECREMENT FOR EX INSTRUCTIONS\nDUMPLOOP LA    R15,2(R15)              ADVANCE TARGET POINTER, 2 BYTES\n         EX    R3,EXMVCF2              MOVE KEY TO PRINT LINE\n         LA    R2,1(R3,R2)             STEP PAST KEY,          R3+1\n         LA    R15,1(R3,R15)           ADVANCE TARGET POINTER, R3+1\n         MVI   0(R15),C','             MOVE TO PRINT LINE\n         C     R4,=F'-1'               Q. WAS REPLACEMENT LENGTH 0 ?\n         BE    DONTEXR4                A. DON'T MOVE REPLACEMENT\n         LA    R15,1(R15)              ADVANCE TARGET POINTER\n         EX    R4,EXMVCF2              MOVE REPLACEMENT TO PRINT LINE\n         LA    R2,1(R4,R2)             STEP PAST REPLACEMENT,  R4+1\n         LA    R15,1(R4,R15)           ADVANCE TARGET POINTER, R4+1\nDONTEXR4 MVI   0(R15),C';'             MOVE TO PRINT LINE\n         CR    R15,R5                  Q. ARE WE PAST THE END ?\n         BNL   TBLOVER                 A. YES, DON'T LOOP\nTBLBCT   BCT   R0,DUMPLOOP             POSSIBLY CHECK SOME MORE\n         MVI   0(R15),C'.'             MOVE TO PRINT LINE, REPLACE ';'\n         RETURN (3,4),RC=0             RETURN TO CALLER WITH R15=0\nTBLOVER  DS   0H                       PRTLINE IS FULL\n         BCTR  R0,0                    DECREMENT, FOR NEXT TIME ROUND\n         RETURN (3,4),RC=4             RETURN TO CALLER WITH R15 NON-0\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         EJECT\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n* DS1XBITS -- TAKE DS1X, CHANGE BITS TO DIGITS 0/1 IN FIELD PRTBITS.\n* R14   = RETURN ADDRESS.      CALL:    BAS R14,DS1XBITS\n* R15   = WORK REGISTER.\n*\nDS1XBITS MVC   PRTBITS(8),=CL8'00000XXX'   SET DEFAULT\n*\n*...+....1....+....2....+....3....+....4....+..&B\n         MACRO ,                               &B\n         TESTBIT &MASK,&BIT                    &B\n&B       SETC  ''                              &B\n&OPND    SETC  'DS1X,X''&MASK.''             ' &B\n&OPND    SETC  '&OPND'(1,20).'TEST BIT &BIT.'  &B\n         TM    &OPND.&B&B&B&B&B&B&B&B&B&B&B&B&B&B\n&OPND    SETC  'XBIT&BIT                     ' &B\n&OPND    SETC  '&OPND'(1,20).'DONE W/BIT &BIT' &B\n         BZ    &OPND.&B&B&B&B&B&B&B&B&B&B&B&B&B&B\n&OPND    SETC  'PRTBITS+&BIT.,C''1''         ' &B\n&OPND    SETC  '&OPND'(1,20).'IT WAS NON-ZERO' &B\n         MVI   &OPND.&B&B&B&B&B&B&B&B&B&B&B&B&B&B\n&OPND    SETC  '0H'                            &B\nXBIT&BIT DS    &OPND.&B&B&B&B&B&B&B&B&B&B&B&B&B&B\n         MEND                                  &B\n*...+....1....+....2....+....3....+....4....+..&B\n*\n         TESTBIT 80,0\n         TESTBIT 40,1\n         TESTBIT 20,2\n         TESTBIT 10,3\n         TESTBIT 08,4\n         BR    R14                     RETURN TO CALLER\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         EJECT\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n*\n* MODEL MACRO CALLS\n*\nOPENL    DS    0F\n         OPEN  (,),MF=L\nOPENL#L  EQU   *-OPENL             LENGTH OF MODEL\n*\nSDCBL    DCB   MACRF=(W),DDNAME=SYSPRINT,                         DEBUGX\n               DSORG=PS,RECFM=VBA,LRECL=125,BLKSIZE=1632          DEBUG\nDCBL#L   EQU   *-SDCBL             LENGTH OF MODEL\n*\nSNAPL    SNAP  MF=L,STORAGE=(,,,)  ROOM FOR TWO PAIRS OF ADDRESSES\nSNAPL#L  EQU   *-SNAPL             LENGTH OF MODEL\n*\nWRITL    WRITE WRITDECB,SF,MF=L\nWRITL#L  EQU   *-WRITL\n*\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         EJECT\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n*\nWORKDSCT DSECT , THIS STORAGE MUST BE GOTTEN BELOW 16M,                X\n               BECAUSE IT CONTAINS DCB.S\n*\nSAVEAREA DC    0CL72' '\nDONOTUSE DC    F'0'    DO NOT USE\nSAVE#BWD DC    F'0'\nSAVE#FWD DC    F'0'\nSAVE#R14 DC    F'0'\nSAVE#R15 DC    F'0'\nSAVE#R0  DC    F'0'\nSAVE#R1  DC    F'0'\nSAVE#R2  DC    F'0'\nSAVE#R3  DC    F'0'\nSAVE#R4  DC    F'0'\nSAVE#R5  DC    F'0'\nSAVE#R6  DC    F'0'\nSAVE#R7  DC    F'0'\nSAVE#R8  DC    F'0'\nSAVE#R9  DC    F'0'\nSAVE#R10 DC    F'0'\nSAVE#R11 DC    F'0'\nSAVE#R12 DC    F'0'\n*\nZTLIBGOT DC    CL8':SDCBGOT'\nTLIBGOT  DS    0F'0',CL(DCBL#L)      DCB LIST IN GOTTEN STORAGE\nZSDCBGOT DC    CL8':SDCBGOT'\nSDCBGOT  DS    0F'0',CL(DCBL#L)      DCB LIST IN GOTTEN STORAGE\n*\nSYSPRDYN DS    X             FLAG WHETHER TO DEALLOCATE SYSPRINT @ END\nSYSPROPN DS    X             FLAG WHETHER DCB IS OPENED\n*\n         DS    0F\n*\nLBLSTM16 DC    CL4':STM'\nSTM16F   DS    16F\n*\nLBLWCRE  DC    CL4'WCRE'     R'E' = R14\nWC#R14   DC    1F'0'\n*\nLBLDS1F  DC    CL4'DS1F'\nDS1F     DC    1F'0'\nLBLDS1H  DC    CL4'DS1H'\nDS1H     DC    1H'0'\nLBLDS1X  DC    CL4'DS1X'\nDS1X     DC    1X'0'\nDSCL8    DC    CL8' '\n         DS    C\n*\nDS#RELNO DS    F\n*\nRC       DS    F             RETURN CODE TO BE PASSED BACK\n*\nZOPENGOT DC    CL8':OPENGOT'\nOPENGOT  DS    0F'0',CL(OPENL#L)     OPEN LIST IN GOTTEN STORAGE\nZSNAPGOT DC    CL8':SNAPGOT'\nSNAPGOT  DS    0F'0',CL(SNAPL#L)     SNAP LIST IN GOTTEN STORAGE\n*\nPRTLINEX DS    F             WILL CONTAIN A(PRTLINE+L'PRTLINE)\n*\nPRTAREA  DS    0F            ALIGN\nPRTBDW   DS    AL2           RESERVE SPACE FOR BDW, RDW\nPRTBDW00 DC    AL2(0)\nPRTRDW   DS    AL2           RESERVE SPACE FOR BDW, RDW\nPRTRDW00 DC    AL2(0)\nPRTBEGIN EQU   *             PRTLINE WILL BEGIN HERE\nPRTCCG   DS    CL1\nPRTRELNO DS    CL5\nPRTRTDDN DS    CL8,CL1\nPRTRTDSN DS    CL44\nPRTRTMEM DS    CL8,CL1\nPRTRTSTA DS    CL2                 KEY FIELD\nPRTXXSTA DS            CL4,CL1         TRANSLATED KEY FIELD, BLANK\nPRTRTNDP DS    CL2                 KEY FIELD\nPRTXXNDP DS            CL4,CL1         TRANSLATED KEY FIELD, BLANK\nPRTRTCDP DS    CL2                 KEY FIELD\nPRTXXCDP DS            CL4,CL1         TRANSLATED KEY FIELD, BLANK\nPRTRTORG DS    CL4                 KEY FIELD\nPRTXXORG DS            CL4,CL1         TRANSLATED KEY FIELD, BLANK\nPRTRTTYP DS    CL2                 KEY FIELD\nPRTXXTYP DS            CL5,CL1         TRANSLATED KEY FIELD, BLANK\nPRTRTLIM DS    CL5\nPRTRTATT DS    CL3\nPRTBITS  DS    CL9\nPRTRTLST DS    CL2                 KEY FIELD\nPRTXXLST DS            CL4,CL1         TRANSLATED KEY FIELD, BLANK\n*\n******** ORG   PRTBEGIN+125                               LIMIT TO 125\n******** 125 IS THE MAX. PERMITTED ON SNAP DCB            LIMIT TO 125\n*\nPRTLGH   EQU   *-PRTBEGIN\n         ORG   PRTBEGIN\nPRTLINE  DS    CL(PRTLGH)\n*\n         ORG   ,                                          LIMIT TO 125\n*        JUMP PAST ANY SHORTENING ORG.S                   LIMIT TO 125\n*\n         DS    CL20               PAD, JUST IN CASE\n*\nZWRITGOT DC    CL8':WRITGOT'\nWRITGOT  DC    0F'0',CL(WRITL#L)' ' WRITE LIST IN GOTTEN STORAGE\n*\nWORKAREA DS    CL512\n*\nLASTWORD DS    F\n*\n*-------------*\n* FOLLOWING CODE WORKS, AS LONG THE DSECT HAS A NAME.\n         SETTEMP                   , MAKE &SYSECT AVAILABLE, IN &TEMP\nUSRDSCTL EQU   *-&TEMP             , NON-RELOCATABLE, LENGTH OF DSECT\n         ORG   &TEMP\nUSRDSECT DS    CL(USRDSCTL)        NOW L'USRDSECT AVAILABLE IN CONDITIOX\n               NAL ASSEMBLY STATEMENTS                                 X\n               NOTE -- IT MUST BE DS, DC HAS A MAX OF 256\n*\n&CSECTNM. CSECT , BACK TO CODE\n*\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         EJECT\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n*\n* CONSTANTS\n*\n*\n         MACRO\n&NAME    TABLE &POS1,&ID=,&L1=,&L2=\n         GBLC  &CEC#L1,&CEC#L2\n         GBLC  &CEC#GBLC\n&NX      SETC  '&SYSNDX'\n         AIF   ('&POS1' EQ 'START').START\n         AIF   ('&POS1' EQ 'END').END\n         AIF   ('&POS1' EQ 'ENTRY').ENTRY\n         MNOTE 12,'&POS1 INVALID, ONLY START/END/ENTRY PERMITTED'\n         MEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n.START   ANOP\n         AIF   (K'&ID GT 2).STARTOK\n         AIF   ('&ID'(1,1) EQ '''').STARTOK\n         AIF   ('&ID'(K'&ID,1) EQ '''').STARTOK\n         MNOTE 12,'ERROR, QUOTES REQUIRED ON ID=\"&ID\"'\n.STARTOK ANOP\n&LCLC    SETC  '&ID'(2,K'&ID-2) REMOVE QUOTES\n&CEC#L1  SETC  '&L1'\n&CEC#L2  SETC  '&L2'\n&LCLA    SETA  K'&LCLC\nCEC&NX.A DC   0F'0',AL1(&LCLA),CL&LCLA'&LCLC'        TABLE ID\n&NAME    DC    A(CEC&NX.A)                           A(TABLE ID)\n         DC    AL1(&CEC#L1),AL1(&CEC#L2)             FIELD LENGTHS\n         DS    AL2                 RESERVE SPACE FOR # ENTRIES IN TABLE\nCEC&NX.B EQU   *\n&CEC#GBLC SETC 'CEC&NX'\n         MEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n.END     ANOP\n&LCLC    SETC  '&CEC#GBLC.C'\n&LCLC2   SETC  '   CALCULATE # ENTRIES'\n&LCLC    EQU   (*-&CEC#GBLC.B)/(&CEC#L1+&CEC#L2)&LCLC2\n         ORG   &CEC#GBLC.B-2       POSITION TO PROPER PLACE\n         DC    AL2(&LCLC)          FIXUP # ENTRIES IN TABLE\n         ORG\n         MEXIT\n.ENTRY   ANOP\n&I       SETA  2\n.NEXTI   ANOP\n&LCLC    SETC  '&SYSLIST(&I)'\n&LCLC2   SETC  '&SYSLIST(&I+1)'\n         AIF   ('&CEC#L2' EQ '0').NOL2\n         DC    CL(&CEC#L1)'&LCLC',CL(&CEC#L2)'&LCLC2'\n         AGO   .ADVI\n.NOL2    DC    CL(&CEC#L1)'&LCLC'\n.ADVI    ANOP\n&I       SETA  &I+2\n         AIF   (&I LT N'&SYSLIST).NEXTI\n         MEND\n*\n*\nTBLRTLST TABLE START,ID='LST-INDICATE LAST',L1=L'PRTRTLST,L2=L'PRTXXLST\n         TABLE ENTRY,80,LAST\n         TABLE END\n*\n*\nTBLRTSTA TABLE START,ID='STA - DSET STATUS',L1=L'PRTRTSTA,L2=L'PRTXXSTA\n         TABLE ENTRY,01,=OLD,02,=MOD,04,=NEW,08,=SHR\n         TABLE END\n*\n*\nTBLRTNDP TABLE START,ID='NDP - NORMAL DISP',L1=L'PRTRTNDP,L2=L'PRTXXNDP\n         TABLE ENTRY,01,=UNCATLG,02,=CATLG,04,=DELETE,08,=KEEP,10,=PASS\n         TABLE END\n*\n*\nTBLRTCDP TABLE START,ID='CDP - COND\"L DISP',L1=L'PRTRTCDP,L2=L'PRTXXCDP\n         TABLE ENTRY,01,=UNCATLG,02,=CATLG,04,=DELETE,08,=KEEP,10,=PASS\n         TABLE END\n*\n*\nTBLRTORG TABLE START,ID='ORG - ORGANIZATION',                          X\n               L1=L'PRTRTORG,L2=L'PRTXXORG\n         TABLE ENTRY,0004,=TR,0008,=VSAM,0020,=TQ,0040,=TX,0080,=GS\n         TABLE ENTRY,0200,=PO,0300,=POU,0400,=MQ,0800,=CQ,1000,=CX\n         TABLE ENTRY,2000,=DA,2100,=DAU,4000,=PS,4100,=PSU,8000,=IS\n         TABLE ENTRY,8100,=ISU\n         TABLE END\n*\n*\nTBLRTTYP TABLE START,ID='TYP - TYPE',L1=L'PRTRTTYP,L2=L'PRTXXTYP\n         TABLE ENTRY,80,=DUMMY,40,=TERM,20,=SYSIN,10,=SYSOUT\n         TABLE END\n         SPACE 1\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         EJECT\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         SPACE 1 LINE\n&CSECTNM. CSECT , BACK TO CODE\n*\n         LTORG ,             GENERATE ALL LITERALS HERE\nLTORGED  EQU   * ,           NO MORE CODE BEYOND THIS POINT\n         SPACE 1\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         SPACE 1 LINE\n         PRINT ON,NOGEN\n         CVT   DSECT=YES           FROM SYS1.AMODGEN\n         DCBD  DSORG=XE,DEVD=DA    FROM SYS1.MACLIB\n         IEESMCA ,                 FROM SYS1.AMODGEN\n         IEFZB4D0 ,                FROM SYS1.MACLIB\n         IEFZB4D2 ,                FROM SYS1.MACLIB\n         IHAPSA ,                  FROM SYS1.MACLIB\n         SPACE 1\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7*\n         SPACE 1 LINE\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ELSE": {"ttr": 4875, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10&\\x0f\\x01\\x10&\\x0f\\x16A\\x00.\\x00.\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-09-17T00:00:00", "modifydate": "2010-09-17T16:41:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "MACRO"}, "text": "* COPIED FROM FILE 078 OF SHARE MVS GROUP MODS TAPE, V29 (04/84)\n*          DATA SET AM010700   AT LEVEL 003 AS OF 05/23/76\n         MACRO\n         ELSE  &OPT\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n         GBLA  &ELSEIF(10)\n.* AUTHOR.   DON HIGGINS.\n.* DATE.     03/27/74.\n.* REMARKS.  MACRO TO ALLOW STRUCTURED PROGRAMMING USING\n.*           IF, THEN, ELSE, AND DO UP TO TEN LEVELS DEEP\n.*           AND NO BRANCH INSTRUCTIONS. SEE IF MACRO.\n.* REV1 05/23/76 DSH - SUPPORT ELSEIF\n         AIF   (&LEVEL EQ 0).ERR0\n         AIF   (T'&OPT EQ 'O').BEGIN\n         AIF   ('&OPT' EQ 'BEGIN').BEGIN\n         AIF   ('&OPT' EQ 'END').END\n         AIF   ('&OPT' EQ 'CONTINUE').CONT\n         MNOTE 8,'ELSE - INVALID OPERAND'\n         AGO   .EXIT\n.BEGIN   ANOP  ,\n         AIF   (&SEQ(&LEVEL) GT 3).ERR1\n&LAB     SETA  &LAB+1\n         B     IF0&LAB\nIF0&ELSE(&LEVEL) EQU *\n&ELSE(&LEVEL) SETA &LAB\n&SEQ(&LEVEL) SETA 4\n         AGO .EXIT\n.END     ANOP  ,\n         AIF   (&SEQ(&LEVEL) NE 4).ERR2\n.DEQUE   ANOP  ,\nIF0&ELSE(&LEVEL) EQU *\n&LEVEL   SETA &LEVEL-1\n         AIF   (&ELSEIF(&LEVEL+1) EQ 1).DEQUE\n         AGO   .EXIT\n.CONT    ANOP  ,\n         AIF   (&SEQ(&LEVEL) GT 3).ERR3\n         AGO   .DEQUE\n.ERR0    MNOTE 8,'ELSE - MISSING IF'\n         AGO   .EXIT\n.ERR1    MNOTE 8,'ELSE BEGIN - OUT OF SEQUENCE'\n         AGO   .EXIT\n.ERR2    MNOTE 8,'ELSE END - OUT OF SEQUENCE'\n         AGO   .EXIT\n.ERR3    MNOTE 8,'ELSE CONTINUE - OUT OF SEQUENCE'\n.EXIT    ANOP  ,\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ELSEIF": {"ttr": 5122, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10&\\x0f\\x01\\x10&\\x0f\\x16A\\x00S\\x00S\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-09-17T00:00:00", "modifydate": "2010-09-17T16:41:00", "lines": 83, "newlines": 83, "modlines": 0, "user": "MACRO"}, "text": "* COPIED FROM FILE 078 OF SHARE MVS GROUP MODS TAPE, V29 (04/84)\n*          DATA SET AM013600   AT LEVEL 002 AS OF 05/23/76\n         MACRO ,\n         ELSEIF ,\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n         GBLA  &ELSEIF(10)\n         LCLA  &N,&M,&S,&LAB1,&L,&I\n         LCLC  &OP,&OPR\n         LCLB  &TESTSW\n.* AUTHOR.   DON HIGGINS.\n.* DATE.     05/23/76.\n.* REMARKS.  CONTROL STRUCTURE FOR CONDITIONAL EXECUTION.\n         AIF   (&LEVEL EQ 10).ERR1\n         ELSE  ,\n&LEVEL   SETA  &LEVEL+1\n&ELSEIF(&LEVEL) SETA 1\n&SEQ(&LEVEL) SETA 1\n&LAB     SETA  &LAB+1\n&ELSE(&LEVEL) SETA &LAB\n&N       SETA N'&SYSLIST\n.NEXTAND ANOP  ,\n&TESTSW  SETB  0\n.TEST    ANOP  ,\n&S       SETA  &S+1\n         AIF   (&S GT &N).ERR2\n&M       SETA  N'&SYSLIST(&S)\n         AIF   (&M EQ 1).TESTEND\n         AIF   (&M LT 2).ERR3\n         AIF   (&M GT 5).ERR4\n&I       SETA  2\n&OPR     SETC  ''\n&OP      SETC  '&SYSLIST(&S,1)'\n         AIF   (&M GT 2).TESTOPR\n         &OP                                                         ,\n         AGO   .TESTEND\n.TESTOPR ANOP  ,\n         AIF   ('&SYSLIST(&S,&I)'(1,1) NE '''').NOLIT\n&L       SETA  K'&SYSLIST(&S,&I)\n&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'(2,&L-2)\n         AGO   .NEXTOPR\n.NOLIT   ANOP  ,\n&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'\n.NEXTOPR ANOP  ,\n&I       SETA  &I+1\n         AIF   (&I EQ &M).TESTGEN\n&OPR     SETC  '&OPR'.','\n         AGO   .TESTOPR\n.TESTGEN ANOP  ,\n         &OP   &OPR                                                  ,\n.TESTEND ANOP  ,\n         AIF   (&TESTSW EQ 1).ORBC\n.AMBC    ANOP  ,\n         BC    15-&SYSLIST(&S,&M),IF0&LAB\n.CONNECT ANOP  ,\n&S       SETA  &S+1\n         AIF   (&S GT &N).EXIT\n&M       SETA  N'&SYSLIST(&S)\n         AIF   (&M NE 1).ERR5  BAD CONNECTOR\n         AIF   ('&SYSLIST(&S)' EQ 'AND').NEXTAND\n         AIF   ('&SYSLIST(&S)' NE 'OR').ERR5  BAD CONNECTOR\n.NEXTOR   ANOP ,\n&LAB1    SETA  &LAB+1\n         B     IF0&LAB1  SKIP TEST IF LAST ONE TRUE\nIF0&LAB   EQU *          DO TEST IF LAST ONE FALSE\n&LAB     SETA  &LAB+2\n&ELSE(&LEVEL) SETA &LAB\n&TESTSW  SETB  1\n         AGO   .TEST\n.ORBC    ANOP  ,\n         BC    15-&SYSLIST(&S,&M),IF0&LAB\nIF0&LAB1 EQU *\n         AGO   .CONNECT\n.ERR1    MNOTE 8,'IF - LEVEL OVERFLOW'\n         AGO   .EXIT\n.ERR2    MNOTE 8,'IF - MISSING TEST LIST'\n         AGO   .EXIT\n.ERR3    MNOTE 8,'IF - TEST LIST TOO SHORT'\n         AGO   .EXIT\n.ERR4    MNOTE 8,'IF - TEST LIST TOO LONG'\n         AGO   .EXIT\n.ERR5    MNOTE 8,'IF - INVALID CONNECTOR'\n.EXIT    ANOP  ,\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EQUBC": {"ttr": 5125, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10&\\x0f\\x01\\x10&\\x0f\\x16A\\x00\\x1f\\x00\\x1f\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-09-17T00:00:00", "modifydate": "2010-09-17T16:41:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "MACRO"}, "text": "* MODIFIED 03-JUN-1989 TO ACT LIKE IEZBITS (MULTIPLE CALLS OK)\n*          DATA SET AM010900   AT LEVEL 001 AS OF 10/28/75\n*          DATA SET AM010900   AT LEVEL 002 AS OF 04/02/74\n         MACRO ,\n         EQUBC ,\n         GBLA  &EQUBC\n         AIF   (&EQUBC EQ 0).SETSW\n         MEXIT ,\n.SETSW   ANOP  ,\n&EQUBC   SETA  1\n         SPACE 2\nH        EQU   2\nL        EQU   4\nE        EQU   8\nNH       EQU   13\nNL       EQU   11\nNE       EQU   7\nO        EQU   1\nP        EQU   2\nM        EQU   4\nZ        EQU   8\nNP       EQU   13\nNM       EQU   11\nNZ       EQU   7\nNO       EQU   14\nEQ       EQU   8\nGT       EQU   2\nLT       EQU   4\nGE       EQU   11\nLE       EQU   13\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FI": {"ttr": 5127, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10&\\x0f\\x01\\x10&\\x0f\\x16A\\x00\\x0b\\x00\\x0b\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-09-17T00:00:00", "modifydate": "2010-09-17T16:41:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "MACRO"}, "text": "*          DATA SET AM011000   AT LEVEL 001 AS OF 10/28/75\n*          DATA SET AM011000   AT LEVEL 001 AS OF 06/28/74\n         MACRO\n&N       FI\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n         AIF   (&SEQ(&LEVEL) NE 4).CONT\n&N       ELSE  END\n         MEXIT\n.CONT    ANOP\n&N       ELSE  CONTINUE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IF": {"ttr": 5129, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10&\\x0f\\x01\\x10&\\x0f\\x16A\\x00g\\x00g\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-09-17T00:00:00", "modifydate": "2010-09-17T16:41:00", "lines": 103, "newlines": 103, "modlines": 0, "user": "MACRO"}, "text": "* COPIED FROM FILE 078 OF SHARE MVS GROUP MODS TAPE, V29 (04/84)\n*          DATA SET AM010500   AT LEVEL 002 AS OF 05/23/76\n*          DATA SET AM010500   AT LEVEL 001 AS OF 10/28/75\n*          DATA SET AM010500   AT LEVEL 001 AS OF 04/01/74\n         MACRO ,\n         IF    ,\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n         GBLA  &ELSEIF(10)\n         LCLA  &N,&M,&S,&LAB1,&L,&I\n         LCLC  &OP,&OPR\n         LCLB  &TESTSW\n         EQUBC ,             DEFINE CONDITIONS, IF NOT ALREADY DEFINED\n.* AUTHOR.   DON HIGGINS.\n.* DATE.     03/27/74.\n.* REMARKS.  MACRO TO ALLOW STRUCTURED PROGRAMMING USING\n.*           IF, THEN, ELSE, AND DO UP TO TEN LEVELS DEEP\n.*           AND NO BRANCH INSTRUCTIONS.\n.*\n.*           EXAMPLE FORM.\n.*               SAMPLE  SUBENTRY\n.*                       IF (CLI,FLAG,TRUE,EQ)\n.*                       THEN BEGIN\n.*                            DO  WHILE,(CLC,A,B,NE)\n.*                               PERFORM R100PROC,R190EXIT\n.*                            DO END\n.*                       THEN END\n.*                       ELSE BEGIN\n.*                            PERFORM R200LIST,R290EXIT\n.*                       ELSE END\n.*                       IF (CLI,SW,TRUE,EQ),AND,(SRC,R1,E)\n.*                            PERFORM R300RPT,R390EXIT\n.*                       ELSE CONTINUE\n.*                       SUBEXIT\n         AIF   (&LEVEL EQ 10).ERR1\n&LEVEL   SETA  &LEVEL+1\n&ELSEIF(&LEVEL) SETA 0\n&SEQ(&LEVEL) SETA 1\n&LAB     SETA  &LAB+1\n&ELSE(&LEVEL) SETA &LAB\n&N       SETA N'&SYSLIST\n.NEXTAND ANOP\n&TESTSW  SETB  0\n.TEST    ANOP\n&S       SETA  &S+1\n         AIF   (&S GT &N).ERR2\n&M       SETA  N'&SYSLIST(&S)\n         AIF   (&M EQ 1).TESTEND\n         AIF   (&M LT 2).ERR3\n         AIF   (&M GT 5).ERR4\n&I       SETA  2\n&OPR     SETC  ''\n&OP      SETC  '&SYSLIST(&S,1)'\n         AIF   (&M GT 2).TESTOPR\n         &OP\n         AGO   .TESTEND\n.TESTOPR ANOP\n         AIF   ('&SYSLIST(&S,&I)'(1,1) NE '''').NOLIT\n&L       SETA  K'&SYSLIST(&S,&I)\n&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'(2,&L-2)\n         AGO   .NEXTOPR\n.NOLIT   ANOP\n&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'\n.NEXTOPR ANOP\n&I       SETA  &I+1\n         AIF   (&I EQ &M).TESTGEN\n&OPR     SETC  '&OPR'.','\n         AGO   .TESTOPR\n.TESTGEN ANOP\n         &OP   &OPR\n.TESTEND ANOP\n         AIF   (&TESTSW EQ 1).ORBC\n.AMBC    ANOP\n         BC    15-&SYSLIST(&S,&M),IF0&LAB\n.CONNECT ANOP\n&S       SETA  &S+1\n         AIF   (&S GT &N).EXIT\n&M       SETA  N'&SYSLIST(&S)\n         AIF   (&M NE 1).ERR5  BAD CONNECTOR\n         AIF   ('&SYSLIST(&S)' EQ 'AND').NEXTAND\n         AIF   ('&SYSLIST(&S)' NE 'OR').ERR5  BAD CONNECTOR\n.NEXTOR   ANOP\n&LAB1    SETA  &LAB+1\n         B     IF0&LAB1  SKIP TEST IF LAST ONE TRUE\nIF0&LAB   EQU *          DO TEST IF LAST ONE FALSE\n&LAB     SETA  &LAB+2\n&ELSE(&LEVEL) SETA &LAB\n&TESTSW  SETB  1\n         AGO   .TEST\n.ORBC    ANOP\n         BC    15-&SYSLIST(&S,&M),IF0&LAB\nIF0&LAB1 EQU *\n         AGO   .CONNECT\n.ERR1    MNOTE 8,'IF - LEVEL OVERFLOW'\n         AGO   .EXIT\n.ERR2    MNOTE 8,'IF - MISSING TEST LIST'\n         AGO   .EXIT\n.ERR3    MNOTE 8,'IF - TEST LIST TOO SHORT'\n         AGO   .EXIT\n.ERR4    MNOTE 8,'IF - TEST LIST TOO LONG'\n         AGO   .EXIT\n.ERR5    MNOTE 8,'IF - INVALID CONNECTOR'\n.EXIT    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MACLIB": {"ttr": 5132, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x002\\x01\\x10&\\x0f\\x01\\x10&\\x1f#V\\x0b3\\x0b0\\x00\\x00\\xd4\\xc1\\xc3\\xd3\\xc9\\xc2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-09-17T00:00:00", "modifydate": "2010-09-18T23:56:32", "lines": 2867, "newlines": 2864, "modlines": 0, "user": "MACLIB"}, "text": "./ ADD NAME=$$$MACDC 0100-10261-10261-2355-00002-00002-00000-MACLIB\n  This is the entire macro library, put together in one member.\n\n./ ADD NAME=BREAK    0100-10260-10260-1641-00028-00028-00000-MACLIB\n         MACRO ,\n&NAME    BREAK ,\n.* DATE.     28-JUL-1989\n.* REMARKS.  THIS MACRO WORKS WITH THE MACROS WRITTEN BY DON HIGGINS,\n.*          FOUND ON FILE 078 OF SHARE MVS GROUP MODS TAPE, V29 (04/84)\n.*  SEE CASE,DOCASE,DOMACRO,EQUBC,ELSE,ELSEIF,ESAC,ESACOD,FI,IF,OD;\n.*  AND CONTINUE.\n.***************\n.* NOTE -- THIS MACRO WILL ONLY WORK WHEN IT IS IN A ONE-LEVEL IF\n.*        INSIDE A DO-LOOP -- FOR INSTANCE,\n.*                     DO UNTIL,(...CONDITION...)\n.*                       ...\n.*                       IF (..OTHER.CONDITION..)\n.*                         BREAK\n.*                       FI\n.*                       ...\n.*                     OD\n.*\n.* (THIS RESTRICTION IS BECAUSE THE DO MACRO AND THE IF MACRO\n.*  USE THE SAME ARRAY, &ELSE(10), TO STORE THEIR INFORMATION.\n.*  SOMEDAY WE'LL SPLIT THEM, AND THEN YOU CAN CODE BREAK ANYWHERE.)\n.***************\n         GBLA  &DO(10),&DOSEQ(10),&DOLVL,&DOLAB\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n         LCLA &LCLA\n&LCLA    SETA  &LEVEL-1\n&NAME    B     IF0&ELSE(&LCLA)     EXIT FROM INNERMOST ENCLOSING LOOP\n         MEND  ,\n./ ADD NAME=CECDYN   0100-10260-10260-1641-02382-02382-00000-MACLIB\n         MACRO ,                                                      1\n&NAME    CECDYN &VERB=,&FLG11=,&FLG21=,&FLG22=,&TEXT=,&PREFIX=,&MF=I, 0X\n               &LIST=Y,                                                X\n               &POS1,&POS2,&POS3,&POS4,&POS5,&POS6,&POS7,&POS8,&POS9,  X\n               &POS10\n.* NOTE -- ASA CARRIAGE CONTROL CHARACTERS IN COLUMN 71 >>>>>>>>>>>>>>0\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70\n.*\n.* MACRO NAME = CECDYN\n.*\n.* (C) COPYRIGHT CENTERIOR ENERGY CORPORATION 1988,1991\n.*\n.* FUNCTION = BUILD PARAMETER LIST FOR CALL TO DYNALLOC MACRO (SVC99)\n.*\n.*  THIS MACRO PROCESSES DIFFERENTLY THAN IBM-SUPPLIED MACROS, BECAUSE\n.* IT GENERATES A DSECT FOR ITS PARAMETER LIST, AND ALL MOVES INTO THE\n.* PARAMETER LIST ARE DONE USING THE NAMES DEFINED IN THE DSECT.\n.*\n.* IF &PREFIX IS SPECIFIED, SAVE IT IN GLOBAL &CEC#P (3 CHARS OR LESS)\n.*                          ELSE GENERATE A UNIQUE 3-CHARACTER &CEC#P.\n.* IF MF=E, THEN &PREFIX COULD REPEAT A PREVIOUSLY-SPECIED &PREFIX\n.*          ELSE &PREFIX MUST BE UNIQUE.\n.*\n.* FURTHER PROCESSING IS DONE IN MULTIPLE PASSES:\n.*   IF MF=L, 1 PASS -- CREATE DC.S (DEFINE CONSTANT) FOR ALL OPERANDS\n.*                      WITH SUPPLIED VALUES FOR NON-REGISTER OPERANDS\n.*                      AND WITH VALUES OF 0 FOR REGISTER OPERANDS;\n.*            AND MEXIT.\n.*   IF MF=I, 2 PASSES -- 1ST PASS EXACTLY LIKE MF=L;\n.*                        2ND PASS, MOVE REGISTER OPERANDS TO STORAGE;\n.*            AND MEXIT.\n.*   IF MF=E, 2 PASSES -- 1ST PASS, DEFINE &CEC#P.DSECT, IF VALUE OF\n.*                        &PREFIX WAS NOT ENCOUNTERED BEFORE;\n.*                     -- 2ND PASS, MOVE ALL OPERANDS TO STORAGE,\n.*                        BOTH REGISTER AND NON-REGISTER;\n.*            AND MEXIT.\n.*\n.*  THE VALUES THE USER CAN CODE FOR VERB,FLG11,FLG21,FLG22 ARE THE\n.* NAMES FROM MACRO IEFZB4D0, MINUS THE PREFIX 'S99'.  THE VALUES ARE\n.* NOT CHECKED, BUT INCORRECT VALUES WILL CAUSE ASSEMBLY ERRORS\n.* BECAUSE THEN THE GENERATED NAMES ARE NOT DEFINED BY IEFZB4D0.\n.*  THE ADVANTAGE OF NOT CHECKING IS THAT, IF IBM DEFINES NEW VALID\n.* VALUES IN MACRO IEFZB4D0, NO UPDATE OF THIS MACRO IS NECESSARY TO\n.* RECOGNIZE AND PROCESS THE NEW VALUES.\n.*  AS OF 14-FEB-1991, VALID VALUES DEFINED IN IEFZB4D0 ARE:\n.* VERB COULD BE AL/UN/CC/DC/RI/DN/IN (CHOOSE ONLY ONE).\n.* FLG11 COULD BE ONCNV, NOCNV, NOMNT, JBSYS, CNENQ.\n.* FLG21 COULD BE WTVOL,WTDSN,NORES,WTUNT,OFFLN,TIONQ,CATLG,MOUNT.\n.* FLG22 COULD BE UDEVT, PCINT, DYNDI.\n.* FOR THE FLG.S, SPECIFY MULTIPLE VALUES WITHIN PARENTHESES.\n.*\n.*  TEXT UNITS ARE SPECIFIED IN THE FORM (KEY,<(VALUE0<,VALUE1...>)>).\n.* IF A TEXT UNIT KEY IS SUPPLIED FOR A VERB FOR WHICH IT IS NOT\n.* VALID, IT IS NOT CHECKED BY THIS MACRO, BUT IT CAUSES AN ASSEMBLY\n.* ERROR BECAUSE THEN THE GENERATED KEY NAME IS NOT DEFINED BY\n.* IEFZB4D2.\n.*  EACH KEY NAME IS 'D' FOLLOWED BY THE 2-CHAR VERB NAME, FOLLOWED\n.* BY THE TEXT UNIT NAME.\n.*\n.*                                                                    -\n.* EXAMPLE OF CALLING SEQUENCE:\n.*         CECDYN PREFIX=X01,MF=(E,WORKAREA),                       X\n.*               VERB=AL,FLG11=(ONCNV,NOMNT),                       X\n.*               TEXT=((DDNAM,DSCL8),(SYSOU,'A'),RTORG)\n.* IF ANY TEXT UNITS SHOULD RETURN VALUES, THE VALUES WILL BE FOUND\n.* IN FIELDS LABELLED WITH THE 3 CHARACTERS SPECIFIED BY &PREFIX,\n.* PLUS THE TEXT UNIT'S NAME.  THE ABOVE CALL WILL DEFINE ORDINARY\n.* LABEL X01RTORG.\n.*\n.*   IF &PREFIX IS REPEATED ACROSS CALLS, THE DSECT IS NOT DUPLICATED,\n.* BUT THE EXACT SAME TEXT UNITS MUST BE SPECIFIED AS WERE ON THE\n.* ORIGINAL CALL.  (OR, AT LEAST, NO TEXT UNITS THAT DID NOT APPEAR\n.* IN THE ORIGINAL CALL.  THAT IS, FEWER COULD BE SPECIFIED.)  THE\n.* FLAG FIELDS CAN BE DIFFERENT THAN ON THE ORIGINAL CALL.\n.*\n.* GLOBALS\n         GBLA  &CEC#CMT1COL  DEFAULT COLUMN FOR COMMENT 1 FIELD\n         GBLA  &CEC#CMT2COL  DEFAULT COLUMN FOR COMMENT 2 FIELD\n         GBLA  &CECCMT1COL   CURRENT COLUMN FOR COMMENT 1 FIELD\n         GBLA  &CECCMT2COL   CURRENT COLUMN FOR COMMENT 2 FIELD\n         GBLC  &CEC#CMT2VAL  TEXT AT RIGHT-HAND END OF GENERATED STMTS\n         GBLC  &CEC#DBG#HDR  TEXT AT LEFT-HAND OF DEBUGGING MNOTES\n         GBLB  &CEC#DEBUG    Q. ISSUE MSG.S ABOUT INTERNAL PROCESSING?\n         GBLA  &CEC#FLAG(5)  CONTROLS MULTIPLE PASSES WITHIN .COMMON\n         GBLB  &CEC#KEYDONE  Q. DONE RECOGNIZING TEXT UNIT?\n         GBLB  &CEC#NEWP     Q. WE HAD TO ADD &CEC#P TO &CEC#PTBL?\n         GBLB  &CEC#NOT1ST   Q. HAS CECDYN EVER BEEN CALLED?\n         GBLC  &CEC#P        3-CHAR VALUE USED IN GENERATED CODE\n         GBLA  &CEC#PMAX     MAXIMUM ENTRIES SAVED IN &CEC#PTBL(100)\n         GBLC  &CEC#PTBL(100) SAVES ALL UNIQUE &CEC#P.S EVER SEEN\n         GBLB  &CEC#PUSHED   Q. DO WE NEED TO POP PRINT AT MEXIT?\n         GBLA  &CEC#SYSNDX   HOW MANY TIMES CECDYN HAS BEEN CALLED\n         GBLB  &CEC#XLAT     Q. TABLE CODED IN &POS9 OF .DOKEY CALL?\n         GBLC  &CEC#3CH      UNIQUE, GENERATED INTERNALLY\n.* LOCALS\n         LCLA  &I,&J,&LCLA,&LCLA2,&LCLA3\n         LCLA  &I1,&I10,&IIX\n         LCLC  &KEY,&VALUE\n         LCLB  &LCLB,&LCLB1\n         LCLC  &LBL,&OPR,&OPD,&CMT\n         LCLC  &LCLC,&LCLC2,&LCLC3\n         LCLC  &DUP,&TYP,&LGH,&VAL\n         LCLA  &DV,&LV\n         LCLC  &DX,&LX,&VV\n.*\n&NX      SETC  '&SYSNDX'               DEFINE SHORTER NAME FOR LATER\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n         AIF   (&CEC#NOT1ST).NOT1STA\n         MNOTE '* MACRO CECDYN, LAST CHANGE 14-JAN-1993 11.31'\n.* CHANGE LOG: (NEWEST CHANGE ON TOP)\n.* 14-JAN-1993  L.SOMOS  AFTER .CLEAR, CHECK FOR '*' TO SET HI-BIT.\n.* 14-MAR-1991  L.SOMOS  CORRECT PROCESSING OF REGISTER OPERANDS.\n.NOT1STA ANOP  ,\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.*\n         AIF   (&CEC#NOT1ST).NOT1STB\n.* FOLLOWING PROCESSING DONE ONLY ONCE PER SOURCE MODULE\n.*\n&CEC#CMT1COL SETA 33         COLUMN OF COMMENTS ON GENERATED LINES\n&CEC#CMT2COL SETA 63         COLUMN OF COMMENTS ON GENERATED LINES\n&CEC#DEBUG SETB 0      TURN OFF\n.* TURN ON BY CALLING WITH ONLY 1 POSITIONAL PARAMETER, DEBUG\n.*\n&CEC#NOT1ST SETB 1           ABOVE PROCESSING NEVER REPEATED AGAIN\n.NOT1STB ANOP  ,\n.*\n.* THIS MUST COME AFTER .NOT1STB:\n         AIF   (0 NE N'&SYSLIST).SUBROUT   GO CHECK SUBROUTINE CALLS\n.* ONLY KEYWORD PARMS ARE USED IN EXTERNAL CALLS, NO POSITIONAL PARMS.\n.* POSITIONAL PARMS ARE ONLY USED IN RECURSIVE INNER MACRO SELF-CALLS.\n.*\n&CEC#SYSNDX SETA 1+&CEC#SYSNDX    COUNT NON-SUBROUTINE CALLS TO CECDYN\n.*\n         MNOTE                                      '* MACRO CECDYN IS X\n               (C) COPYRIGHT CENTERIOR ENERGY CORPORATION 1988,1991   '\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.* SET THE VALUE OF &CEC#3CH\n&Q1      SETA  (&CEC#SYSNDX-1)/36      1ST QUOTIENT\n&R1      SETA  (&CEC#SYSNDX-1)-36*&Q1  1ST REMAINDER, FOR 3RD CHAR\n&Q2      SETA  &Q1/36                  2ND QUOTIENT\n&R2      SETA  &Q1-36*&Q2              2ND REMAINDER, FOR 2ND CHAR\n&Q3      SETA  &Q2/26                  3RD QUOTIENT\n&R3      SETA  &Q2-26*&Q3              3RD REMAINDER, FOR 1ST CHAR\n.* R1 AND R2 ARE ALWAYS 0 THROUGH 35   (1+&R? IS ALWAYS 1 THRU 36)\n.* R3 IS ALWAYS 0 THROUGH 25       (10+1+&R3 IS ALWAYS 11 THRU 36)\n&LCLC    SETC  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' LENGTH 36\n&CEC#3CH SETC  '&LCLC'(10+1+&R3,1).'&LCLC'(1+&R2,1).'&LCLC'(1+&R1,1)\n.* &CEC#3CH IS UNIQUE FOR &CEC#SYSNDX LE 26*36*36 = 33696.\n.* &CEC#3CH ALWAYS BEGINS WITH ALPHA, NEXT 2 CHARS ARE ALPHANUMERIC.\n.* R1 CHANGES MOST QUICKLY, R2 NEXT, AND R3 CHANGES SLOWEST.\n.* &CEC#3CH RANGES THROUGH A00,A01...A09,A0A,A0B...A0Z,\n.*                         A10,A11...A19,A1A,...A1Z, A20...A29, ETC.\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.* SET THE VALUE OF &CEC#P\n         AIF   (T'&PREFIX EQ 'O').SETP WE MUST SUPPLY IT\n&CEC#P   SETC  '&PREFIX'\n         AIF   (K'&PREFIX GE 1 AND K'&PREFIX LE 3).PREFIXD ALL DONE\n&CEC#P   SETC  '&PREFIX'(1,3)          ONLY FIRST THREE CHARACTERS\n         CECDYN MNOTE,'ONLY FIRST 3 CHARACTERS OF PREFIX ARE USED, ',  X\n               '\"&CEC#P\" INSTEAD OF \"&PREFIX\"'\n         AGO   .PREFIXD                  ALL DONE\n.SETP    ANOP  , NO VALUE SPECIFIED, SO CREATE ONE.\n&CEC#P   SETC  '&CEC#3CH'\n.PREFIXD ANOP  ,\n.*\n         AIF   ('&CEC#P' EQ '&CEC#3CH').PEQ3CH\n         CECDYN MNOTE,'*        PREFIX=&PREFIX WAS SPECIFIED -- ',     X\n               'ELSE, PREFIX WOULD HAVE BEEN SET TO \"',&CEC#3CH,       X\n               '\", GENERATED FROM CEC#SYSNDX=&CEC#SYSNDX..'\n.PEQ3CH  ANOP  ,\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.* SAVE &CEC#P IN &CEC#PTBL\n&CEC#NEWP SETB 0                       CLEAR FLAG\n&I       SETA  1\n.NEXTI01 ANOP  ,\n         AIF   ('&CEC#PTBL(&I)' EQ '&CEC#P').OLDP YES, WE FOUND IT\n.ADVI01  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE &CEC#PMAX).NEXTI01\n.* OK, IT HAS NEVER BEEN SEEN BEFORE\n&CEC#NEWP SETB 1                       SET FLAG FOR LATER CHECKING\n&CEC#PMAX SETA &CEC#PMAX+1             INCREASE COUNTER\n&CEC#PTBL(&CEC#PMAX) SETC '&CEC#P'     PLACE INTO TABLE\n.OLDP    ANOP  ,\n.* NOTE - THE ABOVE CODE DOES A SUPERFLUOUS COMPARISON WHEN\n.*       &CEC#PMAX==0, BUT THIS DOES NOT AFFECT CORRECT PROCESSING.\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.* CHECK &LIST PARAMETER FOR ERRORS.\n         AIF   ('&LIST' EQ 'YES' OR '&LIST' EQ 'NO').LISTOK\n         AIF   ('&LIST' EQ 'Y' OR '&LIST' EQ 'N').LISTOK\n         MNOTE 12,'LIST=&LIST INVALID, LIST=YES ASSUMED'\n.LISTOK  ANOP  ,\n         AIF   ('&LIST' EQ 'NO').LISTNO\n         AIF   ('&LIST' EQ 'N').LISTNO\n         AGO   .LISTEX\n.LISTNO  ANOP  ,\n         AIF   (&CEC#PUSHED).PUSHED\n         PUSH  PRINT         PUSH PRINT\n&CEC#PUSHED SETB 1\n.PUSHED  ANOP  ,\n         PRINT OFF           LIST=NO WAS REQUESTED\n.LISTEX  ANOP  ,\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.* CHECK &MF PARAMETER FOR ERRORS.\n         AIF   ('&MF' EQ '').MFOK\n         AIF   ('&MF' EQ 'L' OR '&MF' EQ 'I').MFOK\n         AIF   ('&MF(1)' EQ 'E').MFOK\n         MNOTE 12,'MF=&MF INVALID, NORMAL FORM ASSUMED'\n.MFOK    ANOP  ,\n&LCLC    SETC  'CECDYN -- SECOND PARAM REQUIRED FOR MF=E'\n         AIF   (N'&MF LT 2 AND ('&MF(1)' EQ 'E')).ERRMAIN\n&LCLC    SETC  'CECDYN -- TOO MANY PARAMS FOR MF'\n         AIF   (N'&MF GT 2 AND ('&MF(1)' EQ 'E')).ERRMAIN\n         AIF   ('&MF(1)' EQ 'L').TYPEL\n         AIF   ('&MF(1)' EQ 'E').TYPEE\n         AGO   .TYPEI              ASSUME NORMAL FORM\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.ERRMAIN MNOTE '&LCLC'       ISSUE MESSAGE AND EXIT\n         AGO   .MEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.MEXIT   ANOP  ,             USE THIS EXIT FROM MAINLINE\n         AIF   (NOT &CEC#PUSHED).NOPOP1 THEN WE DON'T NEED TO UN-DO IT.\n         POP   PRINT\n&CEC#PUSHED SETB 0\n.NOPOP1  ANOP  ,\n&CEC#DEBUG SETB 0      TURN OFF\n         MEXIT ,\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.*\n.TYPEI   ANOP  , NORMAL FORM\n         CECDYN DEBUG,.TYPEI SAVE HEADING FOR DEBUG MESSAGES\n         CNOP  0,4           ALIGN LIST TO FULLWORD\n         BAS   1,IGX&NX      BRANCH AROUND LIST, POINT REG1 TO LIST\n&CEC#FLAG(1) SETA 1,0,0,0,1  YES DC, NO DS, NO REG, NO MOVES, COMMON1\n         AGO   .COMMON\n.COMMON1 ANOP  ,\nIGX&NX   DS    0H            BRANCHED AROUND LIST\n&CEC#FLAG(1) SETA 0,0,1,0,2  NO DC, NO DS, YES REG, NO MOVES, COMMON2\n         AGO   .COMMON\n.COMMON2 ANOP  ,\n         AGO   .MEXIT\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.TYPEL   ANOP  , LIST FORM\n         CECDYN DEBUG,.TYPEL SAVE HEADING FOR DEBUG MESSAGES\n&CEC#FLAG(1) SETA 1,0,0,0,3  YES DC, NO DS, NO REG, NO MOVES, COMMON3\n         AGO   .COMMON\n.COMMON3 ANOP  ,\n         AGO   .MEXIT\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*\n.TYPEE   ANOP  , EXECUTE FORM\n         CECDYN DEBUG,.TYPEE SAVE HEADING FOR DEBUG MESSAGES\n.*\n.* CREATE A DSECT:\n&CEC#FLAG(1) SETA 0,1,0,0,4  NO DC, YES DS, NO REG, NO MOVES, COMMON4\n         AGO   .COMMON\n.COMMON4 ANOP ,\n.*\n         AIF   ('&MF(2)'(1,1) EQ '('             AND                   X\n               '&MF(2)'(K'&MF(2),1) EQ ')').USEREG\n&NAME    LA    1,&MF(2)                LOAD ADDRESS OF PARAMETER LIST\n         AGO   .REG1SET\n.*\n.USEREG  ANOP  ,                       IF A REGISTER WAS SPECIFIED\n&LCLC    SETC  '&MF(2)'(2,K'&MF(2)-2)  REGISTER NAME (W/O PARENS)\n         AIF   ('&LCLC' EQ '1').GENDS0H\n&NAME    LR    1,&LCLC                 LOAD PARAMETER LIST ADDRESS\n         AGO   .REG1SET\n.*\n.GENDS0H ANOP  ,\n&NAME    DS    0H                      REG 1 CONTAINS LIST ADDRESS\n         AGO   .REG1SET\n.*\n.REG1SET ANOP  ,\n         USING &CEC#P.DSECT,1          REGISTER 1 POINTS TO DSECT\n.*\n&CEC#FLAG(1) SETA 0,0,1,1,5  NO DC, NO DS, YES REG, YES MOVES, COMMON5\n         AGO   .COMMON\n.COMMON5 ANOP  ,\n         DROP  1\n.*\n         AGO   .MEXIT\n.*\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.*\n.COMMON  ANOP  , GENERATE STRUCTURE OF PARAMETER LIST\n.* THIS IS AN AGO-TYPE INTERNAL ROUTINE --\n.* IT EXITS WITH THE STATEMENT:            AGO .COMMON&CEC#FLAG(5)\n         CECDYN DEBUG,'START .COMMON, RETURN INDEX=&CEC#FLAG(5); ',    X\n               'FLAGS=&CEC#FLAG(1),&CEC#FLAG(2),',                     X\n               '&CEC#FLAG(3),&CEC#FLAG(4).'\n.* .COMMON IS CALLED WITH FLAGS 1,0,0,0 -- JUST &CEC#FLAG(1),\n.*                           OR 0,1,0,0 -- JUST &CEC#FLAG(2),\n.*                           OR 0,0,1,0 -- JUST &CEC#FLAG(3),\n.*                           OR 0,0,1,1 -- WITH &CEC#FLAG(3) AND (4).\n.* IF &CEC#FLAG(1), MAKE DC.S FOR ALL OP.S, WITH ZEROS FOR REG. OP.S\n.* IF &CEC#FLAG(2), MAKE DS.S FOR ALL OP.S, WITH ZEROS FOR ALL OP.S\n.* IF &CEC#FLAG(3), THEN MOVE ONLY OPERANDS WHICH CANNOT BE GENERATED\n.*               IN DC.S (REGISTER OPERANDS, AND SYMBOLIC OPERANDS\n.*               FOR CONSTANTS OF TYPES WHICH REQUIRE QUOTES.)\n.* IF &CEC#FLAG(4), THEN MOVE OTHER OPERANDS (LITERALS, ACONS, NULLS)\n.*\n.*                                                                    -\n         AIF   (NOT &CEC#FLAG(1) AND NOT &CEC#FLAG(2)).NOEQU1\n         AIF   (NOT &CEC#NEWP).COMEXIT SKIP -- ASSUME ALREADY DONE.\n         CECDYN DEBUG,'NEWP=1, GENERATE DSECT'\n         SPACE 2\n&LCLC    SETC '&CEC#P.ORG'\n         AIF   (&CEC#FLAG(1)).ORGDC\n         AIF   (&CEC#FLAG(2)).ORGDSCT\n         MNOTE 16,'SEVERE INTERNAL ERROR'\n         MNOTE 'CEC#FLAG(1)=&CEC#FLAG(1) CEC#FLAG(2)=&CEC#FLAG(2)'\n&CEC#DEBUG SETB 1      TURN ON\n         AGO   .MEXIT\n.ORGDC   ANOP  ,\n&LCLC2   SETC  'DC'\n&LCLC3   SETC  '0F''0'''\n         AGO   .EQU1\n.ORGDSCT ANOP  ,\n&LCLC2   SETC  'DSECT'\n&LCLC3   SETC  ''\n.EQU1    ANOP  ,\n&LCLC    &LCLC2 &LCLC3\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n*                SVC 99 INPUT REQUEST BLOCK\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.NOEQU1  ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* BUILD &LCL#FLG11, &LCLFLG21, &LCLFLG22 BY SUMMING BIT MASKS:\n.*..+....1....+....2                                                  0\n.*\n&LCL#FLG11 SETC '0'\n         AIF   (K'&FLG11 EQ 0).FLG11ZZ\n&I       SETA  1\n&LCL#FLG11 SETC 'S99&FLG11(&I)'\n         AIF   (N'&FLG11 LE &I).FLG11XX\n.FLG11QQ ANOP  ,\n&I       SETA  &I+1\n&LCL#FLG11 SETC '&LCL#FLG11.+S99&FLG11(&I)'\n         AIF   (N'&FLG11 GT &I).FLG11QQ\n.FLG11XX ANOP  ,\n.FLG11ZZ ANOP  ,\n.*..+....1....+....2                                                  0\n.*\n&LCL#FLG21 SETC '0'\n         AIF   (K'&FLG21 EQ 0).FLG21ZZ\n&I       SETA  1\n&LCL#FLG21 SETC 'S99&FLG21(&I)'\n         AIF   (N'&FLG21 LE &I).FLG21XX\n.FLG21QQ ANOP  ,\n&I       SETA  &I+1\n&LCL#FLG21 SETC '&LCL#FLG21.+'.'S99&FLG21(&I)'\n         AIF   (N'&FLG21 GT &I).FLG21QQ\n.FLG21XX ANOP  ,\n.FLG21ZZ ANOP  ,\n.*..+....1....+....2                                                  0\n.*\n&LCL#FLG22 SETC '0'\n         AIF   (K'&FLG22 EQ 0).FLG22ZZ\n&I       SETA  1\n&LCL#FLG22 SETC 'S99&FLG22(&I)'\n         AIF   (N'&FLG22 LE &I).FLG22XX\n.FLG22QQ ANOP  ,\n&I       SETA  &I+1\n&LCL#FLG22 SETC '&LCL#FLG22.+'.'S99&FLG22(&I)'\n         AIF   (N'&FLG22 GT &I).FLG22QQ\n.FLG22XX ANOP  ,\n.FLG22ZZ ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* (SEE .CREAT SUBROUTINE FOR MEANING OF PARAMETERS)\n.*\n&CECCMT1COL SETA &CEC#CMT1COL COMMENT 1 FIELD'S COLUMN\n&CECCMT2COL SETA &CEC#CMT2COL COMMENT 2 FIELD'S COLUMN\n.* (EACH CALL TO .CREAT DOES ABOVE SETA.S, JUST BEFORE EXITING)\n.*\n&CEC#P.RBP   CECDYN CREAT,0,F\n&CEC#P.RBPTR CECDYN CREAT,,A,*,A(&CEC#P.RB),'REQUEST BLOCK POINTER'\n.*                 (*=HIGH BIT ON)\n&CEC#P.RB    CECDYN CREAT,0,F,,,'REQUEST BLOCK'\n&CEC#P.RBLN  CECDYN CREAT,,A,1,&CEC#P.RBEND-&CEC#P.RB,                 X\n               'LENGTH OF REQUEST BLOCK'\n&CEC#P.VERB  CECDYN CREAT,,A,1,S99VRB&VERB,'VERB CODE'\n&CEC#P.FLAG1 CECDYN CREAT,0,C,2,,FLAGS\n&CEC#P.FLG11 CECDYN CREAT,,A,1,&LCL#FLG11,'FIRST FLAGS BYTE'\n&CEC#P.FLG12 CECDYN CREAT,,A,1,0,'SECOND BYTE OF FLAGS'\n&CEC#P.RSC   CECDYN CREAT,0,C,4,,'REASON CODE FIELDS'\n&CEC#P.ERROR CECDYN CREAT,,X,2,0,'ERROR REASON CODE'\n&CEC#P.INFO  CECDYN CREAT,,X,2,0,'INFORMATION REASON CODE'\n&CEC#P.TXTPP CECDYN CREAT,,A,,A(&CEC#P.TUPL),                          X\n               'ADDR OF LIST OF TEXT UNIT PTRS'\n&CEC#P.RSV01 CECDYN CREAT,,F,,0,RESERVED\n&CEC#P.FLAG2 CECDYN CREAT,0,C,4,,'FLAGS FOR AUTHORIZED FUNCTIONS'\n&CEC#P.FLG21 CECDYN CREAT,,A,1,&LCL#FLG21,'FIRST BYTE OF FLAGS'\n&CEC#P.FLG22 CECDYN CREAT,,A,1,&LCL#FLG22,'SECOND BYTE OF FLAGS'\n&CEC#P.FLG23 CECDYN CREAT,,A,1,0,'THIRD BYTE OF FLAGS'\n&CEC#P.FLG24 CECDYN CREAT,,A,1,0,'FOURTH BYTE OF FLAGS'\n&CEC#P.RBEND CECDYN CREAT,0,,0,,'END MARKER'\n.*                                                                    1\n         AIF   (NOT &CEC#FLAG(1) AND NOT &CEC#FLAG(2)).NOEQU2\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n* SVC 99 TEXT UNIT POINTER LIST\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.NOEQU2  ANOP  ,\n.*\n&CEC#P.TUPL  CECDYN CREAT,0,F,,,'TEXT UNIT POINTER LIST'\n&I       SETA   1\n.NEXTPTR ANOP  ,\n&I1      SETA  &I-10*(&I/10)           1'S DIGIT OF &I\n&I10     SETA  (&I/10)-10*(&I/100)     10'S DIGIT OF &I\n&IIX     SETA  1+3*(&I1*(&I10-1)/(&I10-1)) IGNORE &I1 IF (&I10-1) EQ 0\n&ITH     SETC  'TH ST ND RD TH TH TH TH TH TH '(&IIX,2) 0TH, 1ST, ETC.\n&HIBIT   SETC  '*'                     SET FLAG TO SET HIGH BIT\n         AIF   (&I EQ N'&TEXT).LASTPTR\n&HIBIT   SETC  ''                      RESET FLAG TO SET HIGH BIT\n.LASTPTR ANOP  ,\n&LCLC3   SETC  'A(&CEC#P.TU&I)'\n&LCLC4   SETC  '&TEXT(&I,1)'\n         AIF   (T'&TEXT(&I,1) NE 'O').NORMAL1 NOT- SKIPPED UNIT\n&LCLC3   SETC  '0'\n&LCLC4   SETC  '(OMITTED)'\n.NORMAL1 ANOP  ,\n.* ACTUAL CODE GENERATION:                                            -\n&CEC#P.PTR&I CECDYN CREAT,,A,&HIBIT,                                   X\n               &LCLC3,                                                 X\n               '&I&ITH TEXT UNIT POINTER, &LCLC4'\n.***************************\n.* THE EFFECT OF THE ABOVE CODE IS:\n.* &CEC#P.PTR&I CECDYN CREAT,,A,&HIBIT,                                X\n               A(&CEC#P.&TEXT(&I,1).-(S99TUPAR-S99TUNIT)),             X\n               '&I&ITH TEXT UNIT POINTER, &TEXT(&I,1)'\n.***************************\n.ADVPTR  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE N'&TEXT).NEXTPTR\n.*\n.*                                                                    1\n         AIF   (NOT &CEC#FLAG(1) AND NOT &CEC#FLAG(2)).NOEQU3\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n* SVC 99 TEXT UNITS\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.NOEQU3  ANOP  ,\n.*\n.*   BEGIN A HUGE LOOP, AROUND ALL SELF-CALLS TO .DOKEY SUBROUTINE.\n.* THIS LOOP USES &I AS AN INDEX TO STEP THROUGH ALL SUBLIST ENTRIES\n.* SPECIFIED IN THE TEXT= PARAMETER IN THE OUTER CALL TO CECDYN.\n.*\n&I       SETA   1\n.NEXTI09 ANOP  ,\n.*\n&I1      SETA  &I-10*(&I/10)           1'S DIGIT OF &I\n&I10     SETA  (&I/10)-10*(&I/100)     10'S DIGIT OF &I\n&IIX     SETA  1+3*(&I1*(&I10-1)/(&I10-1)) IGNORE &I1 IF (&I10-1) EQ 0\n&ITH     SETC  'TH ST ND RD TH TH TH TH TH TH '(&IIX,2) 0TH, 1ST, ETC.\n&KEY     SETC  'D&VERB.&TEXT(&I,1)'\n.*\n         AIF   (T'&TEXT(&I,1) EQ 'O').ADVI09  SKIPPED UNIT\n.*\n         AIF   (T'&TEXT(&I,1) NE 'O').NORMAL2 NOT- SKIPPED UNIT\n&KEY     SETC  '(OMITTED)'\n.NORMAL2 ANOP  ,\n.*\n         CECDYN CMT2,        SET &CEC#CMT2VAL (TO BLANKS)\n.*\n&CECCMT1COL SETA &CEC#CMT1COL-6 SHIFT CHARS LEFT, SO 'BEGIN' STANDS OUT\n&CEC#P.TU&I  CECDYN CREAT,0,F,,,'BEGIN &I&ITH TEXT UNIT, &KEY'\n.*\n         AIF   (T'&TEXT(&I,1) EQ 'O').ADVI09  SKIPPED UNIT\n.*\n&CEC#P.KEY&I CECDYN CREAT,,A,2,&KEY,'&I&ITH KEY'\n.*\n&CEC#KEYDONE SETB 0          PREPARE TO SEARCH\n.*\n.*  INFORMATION BELOW IS FROM MVS/XA SPL: SYSTEM MACROS AND FACILITIES\n.* GC28-1150-2.\n.*\n.* (SEE .DOKEY SUBROUTINE FOR MEANING OF PARAMETERS)\n.* DSNAME ALLOCATION TEXT UNITS                                       -\n         AIF   ('&VERB' NE 'AL').AL#DONE\n.*\n.* DDNAME\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDDNAM,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* DSNAME (MUTUALLY EXCLUSIVE WITH DALQNAME, DALIPLTX)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDSNAM,1,C,(1,44)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* PDS MEMBER (REQUIRES DALDSNAM ALSO)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMEMBR,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* DATA SET STATUS (MUTUALLY EXCLUSIVE WITH DALSYSOU)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSTATS,1,A,1,              X\n               ((OLD,X'01'),(MOD,X'02'),(NEW,X'04'),(SHR,X'08'),       X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* NORMAL DISPOSITION (MUTUALLY EXCLUSIVE WITH DALSYSOU)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALNDISP,1,A,1,              X\n               ((UNCATLG,X'01'),(CATLG,X'02'),                         X\n               (DELETE,X'04'),(KEEP,X'08'),                            X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* CONDITIONAL DISPOSITION (MUTUALLY EXCLUSIVE WITH DALSYSOU)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCDISP,1,A,1,              X\n               ((UNCATLG,X'01'),(CATLG,X'02'),                         X\n               (DELETE,X'04'),(KEEP,X'08'),                            X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* UNIT OF DALPRIME, DALSECND WILL BE TRACKS\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALTRK,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.* UNIT OF DALPRIME, DALSECND WILL BE CYLINDERS\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCYL,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.* AVERAGE BLOCK LENGTH TO USE FOR UNIT OF DALPRIME, DALSECND\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBLKLN,1,A,3,,'<=65535'\n         AIF   (&CEC#KEYDONE).ADVI09\n.* PRIMARY SPACE QUANTITY\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPRIME,1,A,3\n         AIF   (&CEC#KEYDONE).ADVI09\n.* SECONDARY SPACE QUANTITY\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSECND,1,A,3\n         AIF   (&CEC#KEYDONE).ADVI09\n.* NUMBER OF DIRECTORY BLOCKS FOR A PDS\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDIR,1,A,3\n         AIF   (&CEC#KEYDONE).ADVI09\n.* RELEASE UNUSED SPACE AT CLOSE TIME\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRLSE,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.* FORMAT OF ALLOCATED SPACE\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSPFRM,1,A,1,              X\n               ((ALX,X'02'),  USE DIFFERENT AREAS OF CONTIGUOUS SPACE  X\n               (MXIG,X'04'),      MAXIMUM CONTIGUOUS SPACE IS REQUIRED X\n               (CONTIG,X'08'),    SPACE MUST BE CONTIGUOUS             X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* ALLOCATE IN WHOLE CYLINDERS\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALROUND,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.* VOLUME SERIAL NUMBERS (MUTUALLY EXCLUSIVE WITH DALSYSOU, DALVLRDS)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALVLSER,(1,6),C,6\n         AIF   (&CEC#KEYDONE).ADVI09\n.* ASSIGN USE ATTRIBUTE OF PRIVATE (MUTUALLY EXCLUSIVE WITH DALSYSOU)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPRIVT,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.* VOL-SEQ WITHIN MULTI-VOLUME DATA SET (MUT.EXCL.W/DALSYSOU)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALVLSEQ,1,A,2,,'<=255'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALVLCT,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALVLRDS,1,C,(1,44)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUNIT,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUNCNT,1,A,1,,'<=59'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPARAL,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSYSOU,(0,1),C,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSPGNM,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSFMNO,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALOUTLM,1,A,3\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCLOSE,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCOPYS,1,1,A\n         AIF   (&CEC#KEYDONE).ADVI09\n.* LABEL TYPE OF VOLUME\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALLABEL,1,A,1,              X\n               ((NL,X'01'),  NO LABEL                                  X\n               (SL,X'02'),   IBM STANDARD LABELS                       X\n               (NSL,X'04'),  NON-STANDARD LABELS                       X\n               (SUL,X'0A'),  IBM STANDARD LABEL PLUS USER LABEL        X\n               (BLP,X'10'),  BYPASS LABEL PROCESSING                   X\n               (LTM,X'21'),  CHECK FOR AND BYPASS LEADING TAPE MARK    X\n               (AL,X'40'),   AMERICAN NATIONAL STANDARD LABEL          X\n               (AUL,X'48'),  AL PLUS USER LABEL                        X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDSSEQ,1,A,2,,'<=9999'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPASPR,1,A,1,              X\n               ((PASSWORD,X'10'),(NOPWREAD,X'30'),                     X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALINOUT,1,A,1,              X\n               ((OUT,X'40'),(IN,X'80'),                                X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALEXPDT,1,C,5\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRETPD,1,A,2,,'<=9999'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDUMMY,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFCBIM,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFCBAV,1,A,1,              X\n               ((VERIFY,X'04'),(ALIGN,X'08'),                          X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALQNAME,1,C,(1,17)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALTERM,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUCS,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUFOLD,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUVRFY,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDCBDS,1,C,(1,44)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDCBDD,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSUSER,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSHOLD,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMSVGP,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSSNM,(0,1),C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSSPRM,(1,254),C,(0,67)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPROT,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALUSRID,1,A,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBURST,1,A,1,              X\n               ((Y,X'02'),(N,X'04'),(YES,X'02'),(NO,X'04'),            X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCHARS,(1,4),C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCOPYG,(1,8),A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFFORM,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFCNT,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMMOD,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMTRC,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDEFER,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALOUTPT,(1,128),C,(1,26)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* DCB ATTRIBUTE TEXT UNITS                                           -\n.*\n.* BUFFER ALIGNMENT\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBFALN,1,A,1,              X\n               ((F,X'01'),   FULLWORD, NOT DOUBLEWORD                  X\n               (D,X'02'),    DOUBLEWORD                                X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* BUFFERING TECHNIQUE\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBFTEK,1,A,1,              X\n               ((D,X'08'),   DYNAMIC                                   X\n               (E,X'10'),    EXCHANGE                                  X\n               (R,X'20'),    RECORD                                    X\n               (S,X'40'),    SIMPLE                                    X\n               (A,X'60'),    RECORD AREA                               X\n               *) (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBLKSZ,1,A,2,,'<=32760'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFIN,1,A,1,,'<=15'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFL,1,A,2,,'<=32760'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFMX,1,A,1,,'<=15'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFNO,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n.* BUFFER OFFSET\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFOF,1,A,1,              X\n               ((L,X'80'),   BLOCK PREFIX IS 4 BYTES, CONTAINS LENGTH  X\n               *),           USER CODES VALUE OF BLOCK PREFIX          X\n               '<=99'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFOU,1,A,1,,'<=15'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFRQ,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALBUFSZ,1,A,2\n         AIF   (&CEC#KEYDONE).ADVI09\n.* PAPER TAPE CODE:\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCODE,1,A,1,               X\n               ((T,X'02'),   TELETYPE 5-TRACK                          X\n               (A,X'04'),    USASCII 8-TRACK                           X\n               (C,X'08'),    NATIONAL CASH REGISTER 8-TRACK            X\n               (B,X'10'),    BURROUGHS 7-TRACK                         X\n               (F,X'20'),    FRIDEN 8-TRACK                            X\n               (I,X'40'),    IBM BCD 8-TRACK                           X\n               (N,X'80'),    NO CONVERSION                             X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* SEND/RECEIVE PRIORITY\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCPRI,1,A,1,               X\n               ((S,X'01'),   SEND PRIORITY                             X\n               (E,X'02'),    EQUAL PRIORITY                            X\n               (R,X'04'),    RECEIVING PRIORITY                        X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* MAGNETIC TAPE DENSITY:\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDEN,1,A,1,                X\n               ((0,X'03'),   200 BPI 7-TRACK                           X\n               (1,X'43'),    556 BPI 7-TRACK                           X\n               (2,X'83'),    800 BPI 7-TRACK OR 9-TRACK                X\n               (3,X'C3'),    1600 BPI 9-TRACK                          X\n               (4,X'D3'),    6250 BPI 9-TRACK                          X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* DATA SET ORGANIZATION\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDSORG,1,A,2,              X\n               ((TCAM3705,X'0004'), TCAM 3705                          X\n               (VSAM,X'0008'), VSAM                                    X\n               (TQ,X'0020'), TCAM MESSAGE QUEUE                        X\n               (TX,X'0040'), TCAM LINE GROUP                           X\n               (GS,X'0080'), GRAPHICS                                  X\n               (PO,X'0200'), PARTITIONED ORGANIZATION                  X\n               (POU,X'0300'), PARTITIONED ORGANIZATION UNMOVABLE       X\n               (MQ,X'0400'), TELECOMMUNICATIONS MESSAGE PROCESSING Q.  X\n               (CQ,X'0800'), DIRECT ACCESS MESSAGE QUEUE               X\n               (CX,X'1000'), COMMUNICATION LINE GROUP                  X\n               (DA,X'2000'), DIRECT ACCESS                             X\n               (DAU,X'2100'), DIRECT ACCESS UNMOVABLE                  X\n               (PS,X'4000'), PHYSICAL SEQUENTIAL                       X\n               (PSU,X'4100'), PHYSICAL SEQUENTIAL UNMOVABLE            X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* ERROR PROCESSING OPTION\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALEROPT,1,A,1,              X\n               ((T,X'10'),   BSAM TESTING                              X\n               (ABE,X'20'),  CAUSE ABNORMAL END OF TASK                X\n               (SKP,X'40'),  SKIP BLOCK CAUSING ERROR                  X\n               (ACC,X'80'),  ACCEPT BLOCK CAUSING ERROR                X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALGNCP,1,A,1,,'<=99'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALINTVL,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALKYLEN,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALLIMCT,1,A,3,,'<=32760'\n         AIF   (&CEC#KEYDONE).ADVI09\n.* ACTUAL OR MAXIMUM LENGTH OF A LOGICAL RECORD, IN BYTES\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALLRECL,1,A,2,              X\n               ((X,X'8000'), LRECL EXCEEDS 32756 (QSAM, BSAM SPANNED)  X\n               *),           (USER MAY CODE VALUE DIRECTLY)            X\n               '<=32760'\n         AIF   (&CEC#KEYDONE).ADVI09\n.* MODE OF OPERATION FOR CARD READER OR PUNCH\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALMODE,1,A,1,               X\n               ((E,X'40'),   EBCDIC MODE                               X\n               (ER,X'50'),   EBCDIC, READ COLUMN ELIMINATE MODE        X\n               (EO,X'60'),   EBCDIC, OPTICAL MARK READ MODE            X\n               (C,X'80'),    CARD IMAGE MODE                           X\n               (CR,X'90'),   CARD IMAGE, READ COLUMN ELIMINATE MODE    X\n               (CO,X'A0'),   CARD IMAGE, OPTICAL MARK READ MODE        X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALNCP,1,A,1,,'<=99'\n         AIF   (&CEC#KEYDONE).ADVI09\n.* OPTIONAL SERVICES TO BE PERFORMED\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALOPTCD,1,A,1,              X\n               (+, TRANSLATE + SUM                                     X\n               (R,X'01'), RELATIVE BLOCK ADDRESSING                    X\n               (J,X'01'), SELECT CHARACTER ARRANGEMENT TABLES(3800)    X\n               (T,X'02'), USER TOTALING FACILITY                       X\n               (Z,X'04'), REDUCED TAPE ERR RECOVERY/DIRECT DASD SEARCH X\n               (A,X'08'), DIRECT ADDRESSING                            X\n               (Q,X'08'), TRANSLATE ASCII TO/FROM EBCDIC               X\n               (F,X'10'), FEEDBACK                                     X\n               (H,X'10'), HOPPER-EMPTY EXIT                            X\n               (O,X'10'), ONLINE CORRECTION (OPTICAL READERS)          X\n               (C,X'20'), CHAINED SCHEDULING/TCAM SEGMENT IDENTIFICA'N X\n               (E,X'20'), EXTENDED SEARCH                              X\n               (B,X'40'), DISREGARD EOF RECOGNITION (TAPE)             X\n               (U,X'40'), ALLOW DATA CHECKS CAUSED BY INVALID CHARS    X\n               (W,X'80')) WRITE VALIDITY CHECK/PLACE TCAM MESSAGE IN   X\n                                   AN EIGHT-BYTE FIELD IN THE WORKAREA\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPCIR,1,A,1,               X\n               ((R,X'02'),(N,X'08'),(A,X'20'),(X,X'80'),               X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPCIS,1,A,1,               X\n               ((R,X'01'),(N,X'04'),(A,X'10'),(X,X'40'),               X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPRTSP,1,A,1,              X\n               ((0,X'01'),(1,X'09'),(2,X'11'),(3,X'19'),               X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRECFM,1,A,1,              X\n               (+, TRANSLATE + SUM                                     X\n               (M,X'02'),(R,X'02'),(A,X'04'),(G,X'04'),(S,X'08'),      X\n               (B,X'10'),(D,X'20'),(T,X'20'),(V,X'40'),(F,X'80'),      X\n               (U,X'C0'),                                              X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRSRVF,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRSRVS,1,A,1\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSOWA,1,A,2,,'<=32760'\n         AIF   (&CEC#KEYDONE).ADVI09\n.* STACKER SELECTION\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSTACK,1,A,1,              X\n               ((1,1),(2,2))            ONLY  1  OR  2  IS VALID       X\n                        NO '*' IN &POS9 -- ALL OTHERS HAVE '*' CODED   X\n                        AS LAST ENTRY IN &POS9.\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALTHRSH,1,A,1,,'<=100'\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALTRTCH,1,A,1,              X\n               ((C,X'13'),(E,X'23'),(ET,X'2B'),(T,X'3B'),              X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALIPLTX,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALDIAGN,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFUNC,1,A,1,               X\n               ((W,X'10'),(WT,X'12'),(WX,X'14'),(WXT,X'16'),           X\n               (P,X'20'),(PW,X'30'),(PWX,X'34'),(PWXT,X'36'),          X\n               (R,X'40'),(RW,X'50'),(RWT,X'52'),(RWX,X'54'),           X\n               (RWXT,X'56'),(RP,X'60'),(RPD,X'68'),(RPW,X'70'),        X\n               (RPWX,X'74'),(RPWXT,X'76'),(RPWD,X'78'),(I,X'80'),      X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALFRID,1,C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n.* NON-JCL DYNAMIC ALLOCATION FUNCTIONS                               -\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPASSW,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALPERMA,0\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALCNVRT,0\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRTDDN,1,C,8,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRTDSN,1,C,44,*\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRTORG,1,X,2,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSSREQ,(0,1),C,(1,4)\n         AIF   (&CEC#KEYDONE).ADVI09\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALRTVOL,1,C,6,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DALSSATT,1,X,1,              X\n               ((*,X'80'))                          CONSTANT X'80'\n         AIF   (&CEC#KEYDONE).ADVI09\n.AL#DONE ANOP  ,\n.* DYNAMIC UNALLOCATION TEXT UNITS                                    -\n         AIF   ('&VERB' NE 'UN').UN#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNDDNAM,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNDSNAM,1,C,(1,44)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNMEMBR,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVDSP,1,A,1,              X\n               ((UNCATLG,X'01'),(CATLG,X'02'),                         X\n               (DELETE,X'04'),(KEEP,X'08'),                            X\n               *)            (USER MAY CODE VALUE DIRECTLY)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNUNALC,0\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNREMOV,0\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVSNH,0\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVCLS,1,C,1\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVSUS,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DUNOVSHQ,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.UN#DONE ANOP  ,\n.* DYNAMIC CONCATENATION TEXT UNITS                                   -\n         AIF   ('&VERB' NE 'CC').CC#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DCCDDNAM,(2,16),C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DCCPERMC,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.CC#DONE ANOP  ,\n.* DYNAMIC DECONCATENATION TEXT UNIT                                  -\n         AIF   ('&VERB' NE 'DC').DC#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DDCDDNAM,1,C,(1,8)\n         AIF   (&CEC#KEYDONE).ADVI09\n.DC#DONE ANOP  ,\n.* TEXT UNITS FOR REMOVING THE IN-USE ATTRIBUTE BASED ON TASK-ID      -\n         AIF   ('&VERB' NE 'RI').RI#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DRITCBAD,1,A,4\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DRICURNT,0\n         AIF   (&CEC#KEYDONE).ADVI09\n.RI#DONE ANOP  ,\n.* DDNAME ALLOCATION TEXT UNITS                                       -\n         AIF   ('&VERB' NE 'DN').DN#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DDNDDNAM,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DDNRTDUM,1,X,1,*\n         AIF   (&CEC#KEYDONE).ADVI09\n.DN#DONE ANOP  ,\n.* DYNAMIC INFORMATION RETRIEVAL TEXT UNITS                           -\n         AIF   ('&VERB' NE 'IN').IN#DONE\n.*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINDDNAM,1,C,(1,8)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINDSNAM,1,C,(1,44)\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTDDN,1,C,8,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTDSN,1,C,44,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTMEM,1,C,8,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTSTA,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTNDP,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTCDP,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTORG,1,X,2,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTLIM,1,X,2,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTATT,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTLST,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRTTYP,1,X,1,*\n         CECDYN DOKEY,&I,&KEY,&TEXT(&I,2),DINRELNO,1,X,2,*\n         AIF   (&CEC#KEYDONE).ADVI09\n.IN#DONE ANOP  ,\n.*                                                                    -\n.* TO GET HERE, 1 OF 3:   1. USER KEYED INVALID TEXT KEY NAME\n.*                        2. ERROR IN THIS MACRO\n.*                        3. IBM DEFINED A KEY NOT KNOWN TO THIS MACRO\n&LCLC    SETC  'TEXT UNIT KEY ''''&KEY'''' NOT KNOWN TO THIS MACRO--'\n&LCLC    SETC  '&LCLC.TEXT UNIT KEY SPELLED WRONG, OR ERROR IN CECDYN'\n         MNOTE 12,'&LCLC'\n.*\n.* BOTTOM OF HUGE LOOP\n.ADVI09  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE N'&TEXT).NEXTI09\n.*                                                                    1\n         AIF   (NOT &CEC#FLAG(1) AND NOT &CEC#FLAG(2)).NOEQU4\n         SPACE 1\n         DS    0D                  FILL OUT DATA SECTION\n         SPACE 1\n&LCLC    SETC  '&CEC#P.&CEC#3CH'\n&LCLC.A  EQU   *-&CEC#P.ORG        CALCULATE THE HEX LENGTH\n         ORG   &CEC#P.ORG\n&LCLC2   SETC  '&CEC#P.DSECT'\n&LCLC2   DS    CL(&LCLC.A)         NOW L'&CEC#P.DSECT AVAILABLE\n         SPACE 1\n*...+....1....+....2....+....3....+....4....+....5....+....6....+....7\n         AIF   (NOT &CEC#FLAG(2)).NOEQU4\n         SPACE 1\n&SYSECT. CSECT , RETURN TO CODE\n         AIF   ('&SYSLOC' EQ '&SYSECT').NOEQU4  SKIP IF UNNECESSARY\n&SYSLOC. LOCTR , RETURN TO ORIGINAL LOCATION COUNTER\n.NOEQU4  ANOP  ,\n.*\n.COMEXIT ANOP  ,\n.*\n.* ACTUAL CODE GENERATION:                                            -\n&LCLA    SETA  &CEC#FLAG(5)  FETCH RETURN INDEX\n         AGO   (&LCLA).COMMON1,.COMMON2,.COMMON3,.COMMON4,.COMMON5\n.***************************\n.* THE EFFECT OF THE ABOVE CODE IS:\n.*       AGO   .COMMON&CEC#FLAG(5)\n.***************************\n         MNOTE 16,'SEVERE INTERNAL ERROR'\n         MNOTE 'CEC#FLAG(5)=&CEC#FLAG(5)'\n&CEC#DEBUG SETB 1      TURN ON\n         AGO   .MEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.SUBROUT ANOP  ,                                                      0\n.*\n         AIF   ('&POS1' EQ 'CMT2').CMT2\n         AIF   ('&POS1' EQ 'CREAT').CREAT\n         AIF   ('&POS1' EQ 'DEBUG').DEBUG\n         AIF   ('&POS1' EQ 'DOKEY').DOKEY\n         AIF   ('&POS1' EQ 'MNOTE').MNOTE\n&LCLC    SETC  'CECDYN -- INVALID INTERNAL CALL, \"&POS1\"'\n         AGO   .ERRMAIN\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7-\n.SUBEXIT MEXIT ,             USE THIS EXIT FROM SUBROUTINES           0\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7-\n.CMT2    ANOP  , SELF-CALL INTERNAL ROUTINE -- SET &CEC#CMT2VAL       0\n&CEC#CMT2VAL SETC '&POS2'\n         AGO   .SUBEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7-\n.CREAT   ANOP  , SELF-CALL INTERNAL ROUTINE -- CREATE LINE(S) OF CODE 0\n         CECDYN DEBUG,.CREAT SAVE HEADING FOR DEBUG MESSAGES\n         CECDYN DEBUG,'&NAME CECDYN CREAT,&POS2,&POS3,&POS4,&POS5,\"',  X\n               &POS6,'\"'\n.* IF &CEC#FLAG(1), GENERATE \"DEFINE CONSTANT\" FOR ALL OPERANDS,\n.*        WITH VALUES SPECIFIED BY USER,\n.*        AND VALUES OF 0 FOR OPERANDS SPECIFIED THROUGH REGISTERS\n.* IF &CEC#FLAG(2), GENERATE \"DEFINE STORAGE\" FOR ALL OPERANDS,\n.*        WITH VALUES OF 0 FOR ALL OPERANDS\n.* IF &CEC#FLAG(3), THEN MOVE ONLY OPERANDS WHICH CANNOT BE GENERATED\n.*        IN DEFINE CONSTANTS (REGISTER OPERANDS, AND SYMBOLIC\n.*        OPERANDS FOR CONSTANTS OF TYPES WHICH REQUIRE QUOTES)\n.* IF &CEC#FLAG(4), THEN MOVE OTHER OPERANDS (LITERALS, ACONS, NULLS)\n.*\n.* FORMAT OF .CREAT SELF-CALLS IS:\n.*       CECDYN CREAT,<DUP>,<TYP>,<LGH>,<VAL>,<COMMENT>\n.* ( DUPLICATION FACTOR, FIELD TYPE, LENGTH, NOMINAL VALUE, TEXT )\n.* OPTIONAL <DUP> IS SELF-DEFINING DECIMAL TERM (WHEN NULL, ASSUME 1)\n.*                        (WHEN 0, THEN INTERNALLY FORCE &CEC#FLAG(1)\n.*                        TO ACT LIKE &CEC#FLAG(2)\n.* OPTIONAL <TYP> IS A SINGLE CHARACTER (ASSEMBLER TYPE ATTRIBUTE T' )\n.*                        H=HALFWORD, F=FULLWORD, A=ADDRESS CONSTANT,\n.*                        B=BINARY, C=CHARACTER, X=HEX, <NULL>='EQU *'\n.* OPTIONAL <LGH>IS SELF-DEFINING DECIMAL TERM\n.*                        (WHEN NULL, ASSUME 2 FOR HALFWORD,\n.*                        4 FOR FULLWORD OR ADDRESS CONSTANT, ELSE 0)\n.*          <VAL> VALUE IS ONLY USED WHEN &CEC#FLAG(1)  (THAT IS,\n.*                        WHEN GENERATING \"DEFINE CONSTANT\"S).\n.*                        IT IS REQUIRED WHEN <DUP> NOT 0\n.* OPTIONAL <COMMENT> IS TEXT OF COMMENT TO BE GENERATED\n.*\n.*..+....1....+....2....+....3\n.*\n&DUP     SETC '&POS2'\n&TYP     SETC '&POS3'\n&LGH     SETC '&POS4'\n&VAL     SETC '&POS5'\n&CMT     SETC '&POS6'\n.*\n.* &DUP AND &LGH ARE THE PARAMETERS SPECIFIED ON THE .CREAT SELF-CALL\n.* &DV AND &LV ARE LCLA (NUMERIC) VALUES USED IN INTERNAL PROCESSING\n.* &DX AND &LX ARE LCLC (CHARACTER) VALUES USED IN GENERATING CODE\n.*\n.* &NUL,&LIT,&REG,&ACN ARE LCLB (FLAGS) DESCRIBE THE &VAL SPECIFIED\n.* &VV IS THE NOMINAL VALUE (WITHOUT QUOTES, PARENS, A(, ) )\n.*..+....1....+....2....+....3                                        0\n.*\n.* ANALYSE DUPLICATION FACTOR:\n.* &DUP=''        PRODUCES &DV=1,         &DX=''\n.* &DUP=0         PRODUCES &DV=0,         &DX='0'\n.* &DUP=1         PRODUCES &DV=1,         &DX=''\n.* &DUP=<NUMERIC> PRODUCES &DV=<NUMERIC>, &DX='<NUMERIC>'.\n&DV      SETA  1             SET INITIAL DEFAULTS\n&DX      SETC  ''            SET INITIAL DEFAULTS\n         AIF   (K'&DUP EQ 0).XDUP\n&DV      SETA  &DUP          MUST BE SELF-DEFINING DECIMAL TERM\n         AIF   ('&DUP' EQ '1').XDUP   LEAVE &DX AS ''\n&DX      SETC  '&DUP'\n.XDUP    ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* ANALYSE LENGTH:\n.* &LGH=''        PRODUCES &LV=DEFAULT,   &LX=''\n.*                            (DEFAULT DEPENDS ON DATA TYPE)\n.*                        (WHEN NULL, ASSUME 2 FOR HALFWORD,\n.*                        4 FOR FULLWORD OR ADDRESS CONSTANT, ELSE 0)\n.* &LGH=<NUMERIC> PRODUCES &LV=<NUMERIC>, &LX='L<NUMERIC>'\n&HIBIT   SETB  0\n&LX      SETC  ''            SET INITIAL DEFAULTS\n&LCLC    SETC  'HFA'\n&LCLC2   SETC  '2440'  EXTRA CHARACTER GIVES DEFAULT '0' FOR NON-H,F,A\n.* H,2; F,4; A,4; OTHER,0.\n&I       SETA  1\n.NEXTI08 ANOP  ,\n         AIF   ('&LCLC'(&I,1) EQ '&TYP').EXITI08\n.ADVI08  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE K'&LCLC).NEXTI08\n.EXITI08 ANOP  ,\n&LCLC    SETC  '&LCLC2'(&I,1)          FETCH CHARACTER FROM 2ND ARRAY\n&LV      SETA  &LCLC                      AND CHANGE TO NUMERIC\n         AIF   (K'&LGH EQ 0).NOLGH             USE DEFAULT LENGTH\n&HIBIT   SETB  ('&LGH'(K'&LGH,1) EQ '*')  SET BY '*', OR '4*', ETC.\n         AIF   (K'&LGH EQ 1 AND &HIBIT).NOLGH  USE DEFAULT LENGTH\n&LCLC    SETC  '&LGH'(1,K'&LGH-&HIBIT) TRIM POSSIBLE '*' (K'&LGH GE 2)\n&LV      SETA  &LCLC         MUST BE SELF-DEFINING DECIMAL TERM\n&LX      SETC  'L&LV'\n.NOLGH   ANOP  ,\n         AIF   (&LV NE 0).XLGH\n&LV      SETA  K'&VAL\n         AIF   (&LV EQ 0).XLGH\n&LX      SETC  'L&LV'\n.XLGH    ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* ANALYSE NOMINAL VALUE:\n.* &VAL=''        PRODUCES &NUL=1, &VV=DEFAULT\n.*                                    (DEFAULT DEPENDS ON DATA TYPE)\n.* &VAL='...'     PRODUCES &LIT=1, &VV=...   (WITHOUT QUOTES)\n.* &VAL=(...)     PRODUCES &REG=1, &VV=...   (WITHOUT PARENS)\n.* &VAL=A(...)    PRODUCES &ACN=1, &VV=...   (WITHOUT A(, ) )\n.* &VAL=<OTHER>   PRODUCES &NUL=&LIT=&REG=&ACN=0, &SYMBOL=1,\n.*                                 &VV=&VAL\n&LIT     SETB  0             LITERAL\n&REG     SETB  0             REGISTER\n&ACN     SETB  0             ADDRESS CONSTANT\n&NUL     SETB  1             NULL -- OMITTED\n&LCLC    SETC  'C'\n&LCLC2   SETC  ' 0'     EXTRA CHARACTER GIVES DEFAULT '0' FOR NON-C\n.* C,' '; OTHER,0.\n&I       SETA  1\n.NEXTI05 ANOP  ,\n         AIF   ('&LCLC'(&I,1) EQ '&TYP').EXITI05\n.ADVI05  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE K'&LCLC).NEXTI05\n.EXITI05 ANOP  ,\n&VV      SETC  '&LCLC2'(&I,1)          FETCH CHARACTER FROM 2ND ARRAY\n&DFLTVV  SETC  '&VV'                   SAVE FOR LATER, ' ' OR '0'\n         AIF   (K'&VAL EQ 0).ZVAL                .* IF NULL SKIP\n         AIF   ('&VAL' EQ '').ZVAL               .* IF NULL SKIP\n&NUL     SETB  0                               .* RESET NULL IF NOT\n         AIF   (K'&VAL LT 3).XVAL      TOO SHORT TO BE ANYTHING\n&VV      SETC  '&VAL'(2,K'&VAL-2)      REMOVE QUOTES/PARENS\n&LIT     SETB  ('&VAL'(1,1) EQ '''' AND '&VAL'(K'&VAL,1) EQ '''')\n         AIF   (&LIT).ZVAL\n&REG     SETB  ('&VAL'(1,1) EQ '(' AND '&VAL'(K'&VAL,1) EQ ')')\n         AIF   (&REG).ZVAL\n         AIF   (K'&VAL LT 4).XVAL      TOO SHORT TO BE ACN\n&ACN     SETB  ('&VAL'(1,2) EQ 'A(' AND '&VAL'(K'&VAL,1) EQ ')')\n&VV      SETC  '&VAL'(3,K'&VAL-3)      REMOVE A(, )\n         AIF   (&ACN).ZVAL\n.XVAL    ANOP  ,\n&VV      SETC  '&VAL'\n.ZVAL    ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n&SYMBOL  SETB  (NOT &NUL AND NOT &LIT AND NOT &REG AND NOT &ACN)\n.*                     (SOMETHING, BUT NONE OF THE ABOVE)\n&MUSTMOV SETB  0             PREP IT TO 0\n         AIF   (&REG).MM1    IF &REG, CANNOT BE DC.-D\n         AIF   (&NUL).MMXX              NULL VALUE CAN ALWAYS BE DC.-D\n         AIF   (&LIT AND ('&TYP' EQ 'C')).MMXX   LITERALS CAN BE DC.-D\n         AIF   (NOT &LIT AND ('&TYP' EQ 'C')).MM1   OTHERS CANNOT\n         AIF   ('&TYP' EQ 'A').MMXX       WITHOUT QUOTES, CAN BE DC.-D\n         AGO   .MMXX\n.MM1     ANOP  ,\n&MUSTMOV SETB  1             CHANGE IT TO 1\n.MMXX    ANOP  ,\n.*    &MUSTMOV IS A FLAG THAT SAYS SOME CODE IS NEEDED FOR A FIELD,\n.*  THAT IT CANNOT BE JUST ASSEMBLED INTO A DC. (AS IN MF=L)\n         CECDYN DEBUG,'VAL=\"',&VV.,                                    X\n               '\", NUL=&NUL., LIT=&LIT., REG=&REG., ACN=&ACN.',        X\n               ', SYMBOL=&SYMBOL., MUSTMOV=&MUSTMOV..'\n.*..+....1....+....2....+....3                                        0\n.*\n.* PROCESS COMMENT FIELD:\n         AIF   (K'&CMT EQ 0).NOQUOT1\n         AIF   ('&CMT'(1,1) NE '''').NOQUOT1\n         AIF   ('&CMT'(K'&CMT,1) NE '''').NOQUOT1\n&CMT     SETC  '&CMT'(2,K'&CMT-2)     REMOVE QUOTES\n.NOQUOT1 ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n         AIF   (NOT &CEC#DEBUG).XDEBUG3\n         CECDYN DEBUG,'NAME=&NAME DUP=&DUP TYP=&TYP LGH=&LGH VAL=\"',   X\n               &VV,'\"'\n         CECDYN MNOTE,'        POS6=&CMT, POS7=&POS7..'\n         CECDYN MNOTE,'        DV=&DV DX=\"&DX\"  LV=&LV LX=\"&LX\"'\n         CECDYN MNOTE,'   VAL: NUL=&NUL, LIT=&LIT, REG=&REG, ACN=&ACN'\n&LCLA    SETA  N'&LGH\n         CECDYN MNOTE,'        N''LGH=&LCLA, HIBIT=&HIBIT'\n.XDEBUG3 ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n&GENRETI SETA  1        DEFAULT RETURN FROM .GENCOM:  .CR#EXIT\n.*\n         AIF   (&CEC#FLAG(1)).G#DCDS   GENERATE DC/DS\n         AIF   (&CEC#FLAG(2)).G#DCDS   GENERATE DC/DS\n         AIF   (&DV EQ 0).CR#EXIT      DUPLICATION FACTOR ZERO--EXIT!\n         AIF   (&CEC#FLAG(3)).G#MOVE   GENERATE MOVES\n         AIF   (&CEC#FLAG(4)).G#MOVE   GENERATE MOVES\n&LCLC    SETC  'INTERNAL ERROR IN .CREAT SUBROUTINE, SYSNDX=&SYSNDX '\n&LCLC    SETC  '&LCLC'.'FLAGS=&CEC#FLAG(1),&CEC#FLAG(2),'\n&LCLC    SETC  '&LCLC'.'&CEC#FLAG(3),&CEC#FLAG(4)..'\n         MNOTE 16,'&LCLC'\n&CEC#DEBUG SETB 1      TURN ON\n         MHELP 1+2+4+8+16+32+64\n         AGO   .CR#EXIT\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.G#DCDS  ANOP  ,             GENERATE DC OR DS\n&LBL     SETC  '&NAME'\n         AIF   (&LV EQ 0 AND &DV EQ 0 AND '&TYP' EQ '').G#EQU INSTEAD\n.*..+....1\n         AIF   (NOT &MUSTMOV).LEAVEVV\n&VV      SETC  '&DFLTVV'               SAVED DEFAULT\n         CECDYN DEBUG,'VAL=\"',&VV.,                                    X\n               '\", NUL=&NUL., LIT=&LIT., REG=&REG., ACN=&ACN.',        X\n               ', SYMBOL=&SYMBOL., MUSTMOV=&MUSTMOV., VV=&VV..'\n.LEAVEVV ANOP  , DON'T SET BACK TO DEFAULT\n.*..+....1\n         AIF   (&CEC#FLAG(1) AND &DV EQ 0).FLAG2A GENERATE DS, NOT DC\n         AIF   (&CEC#FLAG(1)).FLAG1A\n         AIF   (&CEC#FLAG(2)).FLAG2A\n.*..+....1\n.FLAG1A  ANOP  ,\n&OPR     SETC  'DC'\n&OPD     SETC  '&DX&TYP&LX'.'(&VV)'    A(<VALUE>)\n         AIF   ('&TYP' EQ 'A').FLAG1B\n&OPD     SETC  '&DX&TYP&LX'.'''&VV'''  C'<VALUE>' OR F'<VALUE>' OR X..\n         AGO   .FLAG1X                 DONE SETTING UP\n.FLAG1B  ANOP  ,\n         AIF   (NOT &HIBIT).FLAG1X     NOTHING SPECIAL TO DO\n         AIF   (&ACN).FLAG1C           OK, SKIP ERROR MESSAGE\n         MNOTE 12,'INTERNAL ERROR, HIBIT ONLY VALID FOR ADCON.S'\n&CEC#DEBUG SETB 1      TURN ON\n.FLAG1C  ANOP  ,\n&OPD     SETC  '&DX&TYP&LX'.'(&VV+X''80000000'')'  SET HIGH BIT ON\n.FLAG1X  AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1\n.FLAG2A  ANOP  ,\n&OPR     SETC  'DS'\n&OPD     SETC  '&DX&TYP&LX'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1\n.G#EQU   ANOP  ,\n&OPR     SETC  'EQU'\n&OPD     SETC  '*'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.G#MOVE  CECDYN DEBUG,.G#MOVE         GENERATE MOVES\n&LBL     SETC  ''\n&LCLC    SETC  'SYMBOL=&SYMBOL., MUSTMOV=&MUSTMOV.'\n&LCLC    SETC  '&LCLC., FLAG(3)=&CEC#FLAG(3)., FLAG(4)=&CEC#FLAG(4).'\n         CECDYN DEBUG,'&LCLC'\n&LCLB    SETB                (     &MUSTMOV   AND (NOT &CEC#FLAG(3) ))\n&LCLC    SETC        '&LCLB.=(     &MUSTMOV.  AND (NOT &CEC#FLAG(3)))'\n         CECDYN DEBUG,'&LCLC.=(     MUSTMOV   AND (NOT  FLAG(3) ))'\n&LCLB1   SETB                ((NOT &MUSTMOV ) AND (NOT &CEC#FLAG(4) ))\n&LCLC    SETC       '&LCLB1.=((NOT &MUSTMOV.) AND (NOT &CEC#FLAG(4)))'\n         CECDYN DEBUG,'&LCLC.=((NOT MUSTMOV ) AND (NOT  FLAG(4) ))'\n         CECDYN DEBUG,'    IF EITHER OF ABOVE IS TRUE, THEN MEXIT'\n         AIF   (&LCLB OR &LCLB1).CR#EXIT                 NOTHING TO DO\n         AIF   ('&DUP' EQ '0' AND K'&CMT EQ 0).CR#EXIT   NOTHING TO DO\n         AIF   ('&DUP' EQ '0').ONLYCMT  NO CODE TO BE GENERATED\n         AIF   (&NUL AND                                               X\n               '&TYP' EQ 'C').BLANK  TO-FIELD IS CHARACTER             X\n                                        AND NO NOMINAL VALUE SPECIFIED\n         AIF   (&NUL AND                                               X\n               '&TYP' EQ 'F').ZERO   TO-FIELD IS A FULLWORD            X\n                                        AND NO NOMINAL VALUE SPECIFIED\n         AIF   (&NUL).CLEAR          NO NOMINAL VALUE SPECIFIED\n         AIF   ('&VV' EQ '0').CLEAR  VALUE TO GENERATE IS 0\n         AIF   ('&TYP' EQ 'C').AAACH TO-FIELD IS A CHARACTER FIELD\n         AIF   ('&LV' EQ '1' AND                                       X\n               ('&TYP' EQ 'A' OR '&TYP' EQ 'X' OR '&TYP' EQ 'F' OR     X\n               '&TYP' EQ 'H')).AAA1N TO-FIELD IS LENGTH 1, NUMERIC\n         AIF   ('&LV' EQ '2' AND                                       X\n               ('&TYP' EQ 'A' OR '&TYP' EQ 'X' OR '&TYP' EQ 'F' OR     X\n               '&TYP' EQ 'H')).AAA2N TO-FIELD IS LENGTH 2, NUMERIC\n         AIF   ('&LV' EQ '3' AND                                       X\n               ('&TYP' EQ 'A' OR '&TYP' EQ 'X' OR '&TYP' EQ 'F' OR     X\n               '&TYP' EQ 'H')).AAA3N TO-FIELD IS LENGTH 3, NUMERIC\n         AIF   ('&LV' EQ '4' AND                                       X\n               ('&TYP' EQ 'A' OR '&TYP' EQ 'X' OR '&TYP' EQ 'F' OR     X\n               '&TYP' EQ 'H')).AAA4N TO-FIELD IS LENGTH 4, NUMERIC\n         MNOTE 12,'INTERNAL ERROR IN CREAT ROUTINE:'\n MNOTE '            NAME=&NAME DUP=&DUP TYP=&TYP LGH=&LGH VAL=\"&VV\"'\n MNOTE '            POS6=&CMT..'\n MNOTE '            DV=&DV DX=\"&DX\"  LV=&LV LX=\"&LX\"'\n MNOTE '       VAL: NUL=&NUL, LIT=&LIT, REG=&REG, ACN=&ACN'\n&CEC#DEBUG SETB 1      TURN ON\n         AGO   .CR#EXIT\n.*..+....1....+....2                                                  0\n.*\n.* (EACH 'AGO .GENCOM\" WITH NO RETURN IS FOLLOWED BY DOUBLE-SPACE)\n.*..+....1....+....2                                                  0\n.ONLYCMT CECDYN CMT2,.ONLYCMT    DUPLICATION FACTOR ZERO--ONLY COMMENT0\n&LBL     SETC  '*'\n&OPR     SETC  ''\n&OPD     SETC  '&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.BLANK   CECDYN CMT2,.BLANK     NO NOMINAL VALUE FOR 'C'--BLANK-FILL  0\n         AIF   (&LV LE 0 OR &LV GT 8).BLANK1   CONTINUE THINKING\n.BLANK8  CECDYN CMT2,.BLANK8    USER SPECIFIED &LGH LE 8--USE LITERAL\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME'.'(&LV),=CL8'' '''\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.BLANK1  CECDYN CMT2,.BLANK1    MOVE A SINGLE BLANK                   0\n&OPR     SETC  'MVI'\n&OPD     SETC  '&NAME,C'' '''\n         AIF   (&LV EQ 1).GENCOM GO GENERATE A LINE, THEN .CR#EXIT\n&GENRETI SETA  3             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET3\n.GENRET3 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&CMT     SETC  'PROPOGATE INITIAL BLANK'\n         AIF   (&LV EQ 0).BLANK0\n.BLANKX  CECDYN CMT2,.BLANKX USER SPECIFIED &LGH--USE IT              0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME+1(&LV-1),&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.BLANK0  CECDYN CMT2,.BLANK0 NO &LGH--HOPE ASMBLR CAN FIGURE IT OUT   0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME+1(L''&NAME-1),&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.ZERO    CECDYN CMT2,.ZERO      NO NOMINAL VALUE FOR 'F'--LOAD ZEROES 0\n         AIF   (&LV GE 4).CLEAR LGH GREATER THAN TYPE F--USE XC\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,=F''0'''\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.CLEAR   CECDYN CMT2,.CLEAR     NO NOMINAL VALUE--CLEAR TO HEX ZEROES 0\n&OPR     SETC  'MVI'\n&OPD     SETC  '&NAME,0'\n         AIF   (&LV EQ 1).GENCOM GO GENERATE A LINE, THEN .CR#EXIT\n         AIF   (&LV EQ 0).CLEAR0\n&OPR     SETC  'XC'\n&OPD     SETC  '&NAME'.'(&LV),&NAME'\n&GENRETI SETA  2 PREPARE RETURN POINTER--CHECK FOR HIBIT AFTERWARD\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2\n.CLEAR0  CECDYN CMT2,.CLEAR0 NO &LGH--HOPE ASMBLR CAN FIGURE IT OUT   0\n&OPR     SETC  'XC'\n&OPD     SETC  '&NAME,&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.AAACH   CECDYN CMT2,.AAACH , TO-FIELD IS A CHARACTER FIELD           0\n         AIF   (&REG).REGCH   TO-FIELD IS CHAR, SOURCE IS REG-FORMAT\n         AIF   (&ACN).ACNCH   TO-FIELD IS CHAR, SOURCE IS ACON-FORMAT\n         AIF   (&LIT).LITCH   TO-FIELD IS CHAR, SOURCE IS LITERAL\n.SYMCH   ANOP  ,              TO-FIELD IS CHAR, SOURCE IS A SYMBOL    0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,&VV' OR '&NAME,&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.LITCH   CECDYN CMT2,.LITCH   TO-FIELD IS CHAR, SOURCE IS LITERAL     0\n         AIF   (&LV EQ 1).LIT1CH TO-FIELD IS 1-CHAR, SOURCE IS LITERAL\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,=C&LX''&VV''' OR '&NAME,=C&LX&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.LIT1CH  CECDYN CMT2,.LIT1CH  TO-FIELD IS 1-CHAR, SOURCE IS LITERAL   0\n&OPR     SETC  'MVI'\n&OPD     SETC  '&NAME,''&VV''' OR '&NAME,&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.REGCH   CECDYN CMT2,.REGCH   TO-FIELD IS CHAR, SOURCE IS REG-FORMAT  0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,0(&VV)' OR '&NAME,0&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.ACNCH   CECDYN CMT2,.ACNCH   TO-FIELD IS CHAR, SOURCE IS ACON-FORMAT 0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'LA'\n&OPD     SETC  '15,&VV'\n&CMT     SETC  'LOAD ADDRESS OF FIELD'\n&GENRETI SETA  4             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET4\n.GENRET4 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,0(15)'\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.AAA1N   CECDYN CMT2,.AAA1N , TO-FIELD IS LENGTH 1, NUMERIC           0\n         AIF   (&REG).REG1N TO-FIELD LGH 1 NUMERIC, SOURCE REG-FORMAT\n         AIF   (&ACN).ACN1N TO-FIELD LGH 1 NUMERIC, SOURCE ACON-FORMAT\n         AIF   (&LIT).LIT1N TO-FIELD LGH 1 NUMERIC, SOURCE A LITERAL\n.SYM1N   ANOP  ,            TO-FIELD LGH 1 NUMERIC, SOURCE A SYMBOL   0\n&OPR     SETC  'MVI'\n&OPD     SETC  '&NAME,&VV' OR '&NAME,&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.LIT1N   CECDYN CMT2,.LIT1N TO-FIELD LGH 1 NUMERIC, SOURCE A LITERAL  0\n&OPR     SETC  'MVI'\n&OPD     SETC  '&NAME,C''&VV''' OR '&NAME,C&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.REG1N   CECDYN CMT2,.REG1N TO-FIELD LGH 1 NUMERIC, SOURCE REG-FORMAT 0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'L'\n&OPD     SETC  '15,0(&VV)' OR '15,0&VAL'\n&CMT     SETC  'FETCH FULLWORD POINTED-TO BY REGISTER'\n&GENRETI SETA  7             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET7\n.GENRET7 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'STC'\n&OPD     SETC  '15,&NAME'\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.ACN1N   CECDYN CMT2,.ACN1N TO-FIELD LGH 1 NUMERIC, SOURCE ACON-FORMAT0\n         LA    15,&VV        LOAD ADDRESS OF FIELD            .ACN1N\n&OPR     SETC  'STC'\n&OPD     SETC  '15,&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.AAA2N   CECDYN CMT2,.AAA2N , TO-FIELD IS LENGTH 2, NUMERIC           0\n         AIF   (&REG).REG2N TO-FIELD LGH 2 NUMERIC, SOURCE REG-FORMAT\n         AIF   (&ACN).ACN2N TO-FIELD LGH 2 NUMERIC, SOURCE ACON-FORMAT\n         AIF   (&LIT).LIT2N TO-FIELD LGH 2 NUMERIC, SOURCE A LITERAL\n.SYM2N   ANOP  ,            TO-FIELD LGH 2 NUMERIC, SOURCE A SYMBOL   0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,=AL2(&VV)' OR '&NAME,=AL2(&VAL)'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.LIT2N   CECDYN CMT2,.LIT2N TO-FIELD LGH 2 NUMERIC, SOURCE A LITERAL  0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,=AL2(C''&VV'')' OR '&NAME,=AL2(C&VAL)'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.REG2N   CECDYN CMT2,.REG2N TO-FIELD LGH 2 NUMERIC, SOURCE REG-FORMAT 0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'L'\n&OPD     SETC  '15,0(&VV)' OR '15,0&VAL'\n&CMT     SETC  'FETCH FULLWORD POINTED-TO BY REGISTER'\n&GENRETI SETA  6             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET6\n.GENRET6 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'STH'\n&OPD     SETC  '15,&NAME'    STORE HALFWORD FROM REG.\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.ACN2N   CECDYN CMT2,.ACN2N TO-FIELD LGH 2 NUMERIC, SOURCE ACON-FORMAT0\n         LA    15,&VV        LOAD ADDRESS OF FIELD            .ACN2N\n&OPR     SETC  'STH'\n&OPD     SETC  '15,&NAME'    STORE HALFWORD FROM REG.\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.AAA3N   CECDYN CMT2,.AAA3N , TO-FIELD IS LENGTH 3, NUMERIC           0\n         AIF   (&REG).REG3N TO-FIELD LGH 3 NUMERIC, SOURCE REG-FORMAT\n         AIF   (&ACN).ACN3N TO-FIELD LGH 3 NUMERIC, SOURCE ACON-FORMAT\n         AIF   (&LIT).LIT3N TO-FIELD LGH 3 NUMERIC, SOURCE A LITERAL\n.SYM3N   ANOP  ,            TO-FIELD LGH 3 NUMERIC, SOURCE A SYMBOL   0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'L'\n&OPD     SETC  '15,&VV'\n&CMT     SETC  'FETCH FULLWORD'\n&GENRETI SETA  9             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET9\n.GENRET9 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'STCM'\n&OPD     SETC  '15,B''0111'',&NAME'\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.LIT3N   CECDYN CMT2,.LIT3N TO-FIELD LGH 3 NUMERIC, SOURCE A LITERAL  0\n         LA    15,=C'&VV'    POINT TO FULLWORD                .LIT3N\n&OPR     SETC  'STCM'\n&OPD     SETC  '15,B''0111'',&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.REG3N   CECDYN CMT2,.REG3N TO-FIELD LGH 3 NUMERIC, SOURCE REG-FORMAT 0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'L'\n&OPD     SETC  '15,0(&VV)' OR '15,0&VAL'\n&CMT     SETC  'FETCH FULLWORD POINTED-TO BY REGISTER'\n&GENRETI SETA  8             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET8\n.GENRET8 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'STCM'\n&OPD     SETC  '15,B''0111'',&NAME'\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.ACN3N   CECDYN CMT2,.ACN3N TO-FIELD LGH 3 NUMERIC, SOURCE ACON-FORMAT0\n         LA    15,&VV        LOAD ADDRESS OF FIELD            .ACN3N\n&OPR     SETC  'STCM'\n&OPD     SETC  '15,B''0111'',&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .CR#EXIT\n.*..+....1....+....2                                                  0\n.AAA4N   CECDYN CMT2,.AAA4N , TO-FIELD IS LENGTH 4, NUMERIC           0\n&GENRETI SETA  2 PREPARE RETURN POINTER--CHECK FOR HIBIT AFTERWARD\n         AIF   (&REG).REG4N TO-FIELD LGH 4 NUMERIC, SOURCE REG-FORMAT\n         AIF   (&ACN).ACN4N TO-FIELD LGH 4 NUMERIC, SOURCE ACON-FORMAT\n         AIF   (&LIT).LIT4N TO-FIELD LGH 4 NUMERIC, SOURCE A LITERAL\n.SYM4N   ANOP  ,            TO-FIELD LGH 4 NUMERIC, SOURCE A SYMBOL   0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME'.'(4),&VV' OR '&NAME'.'(4),&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2\n.LIT4N   CECDYN CMT2,.LIT4N TO-FIELD LGH 4 NUMERIC, SOURCE A LITERAL  0\n         LA    15,=C'&VV'       FETCH WORD                    .LIT4N\n&OPR     SETC  'ST'\n&OPD     SETC  '15,&NAME'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2\n.REG4N   CECDYN CMT2,.REG4N TO-FIELD LGH 4 NUMERIC, SOURCE REG-FORMAT 0\n&OPR     SETC  'MVC'\n&OPD     SETC  '&NAME,0(&VV)' OR '&NAME,0&VAL'\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2\n.ACN4N   CECDYN CMT2,.ACN4N TO-FIELD LGH 4 NUMERIC, SOURCE ACON-FORMAT0\n&CMTSAVE SETC  '&CMT'        SAVE COMMENT\n&OPR     SETC  'LA'\n&OPD     SETC  '15,&VV'\n&CMT     SETC  'LOAD ADDRESS OF FIELD'\n&GENRETI SETA  5             PREPARE RETURN POINTER\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET5\n.GENRET5 ANOP  , &CMT HAS BEEN GENERATED, WE CAN OVERLAY IT NOW\n&OPR     SETC  'ST'\n&OPD     SETC  '15,&NAME'\n&CMT     SETC  '&CMTSAVE'    RESTORE SAVED COMMENT\n&GENRETI SETA  2 PREPARE RETURN POINTER--CHECK FOR HIBIT AFTERWARD\n         AGO   .GENCOM       GO GENERATE A LINE, THEN .GENRET2\n.*\n.GENRET2 AIF   (NOT &HIBIT).CR#EXIT    NOTHING SPECIAL TO DO          0\n         OI    &NAME,X'80'      TURN ON HIGH BIT              .GENRET2\n         AGO   .CR#EXIT\n.*..+....1....+....2....+....3....+....4                              1\n.GENCOM  ANOP , GENERATE A STMT, W/ COMMENT FIELD AND W/ &CEC#CMT2VAL 0\n.* THIS IS AN AGO-TYPE INTERNAL ROUTINE --\n.* IT EXITS WITH THE STATEMENT:            AGO .GENRET&GENRETI\n.*\n.* INPUTS: LOCAL SETC VARIABLES: &LBL          LABEL\n.*                               &OPR          OPERATOR\n.*                               &OPD          OPERAND\n.*                               &CMT          COMMENT\n.*         GLOBAL SETC VARIABLE: &CEC#CMT2VAL  SECONDARY COMMENT\n.* OUTPUT: STATEMENT/MNOTE: &LBL     &OPR  &OPD&CMT&CEC#CMT2VAL\n.*         WITH COLUMNS:   '....+....1....+..  .   .\n.*         (&LBL IN COLUMN 1,\n.*          &OPR IN COLUMN 10 IF POSSIBLE, ELSE SHIFTED,\n.*          &OPD IN COLUMN 16 IF POSSIBLE, ELSE SHIFTED,\n.*          &CMT IN COLUMN &CECCMT1COL (ON A CONT'N IF NECESSARY),\n.*  &CEC#CMT2VAL IN COLUMN &CECCMT2COL (ON A CONT'N IF NECESSARY).)\n.*..+....1....+....2....+....3                                        0\n.*\n.* TRIM ALL BLANKS FROM RIGHT-HAND END OF &LBL\n         AIF   (K'&LBL EQ 0).OKLBL     LENGTH ZERO--NO TRIM NECESSARY\n.TRIMLBL AIF   ('&LBL'(K'&LBL,1) NE ' ').OKLBL  Q. LAST CHAR A BLANK?\n.* A. YES, LAST CHARACTER IS A BLANK\n         AIF   (K'&LBL EQ 1).ZZLBL     LENGTH ONE--NO PAD NECESSARY\n&LBL     SETC  '&LBL'(1,K'&LBL-1)      A. YES--TRIM LAST CHARACTER AND\n         AGO   .TRIMLBL                    GO BACK AND CHECK SOME MORE\n.OKLBL   ANOP  ,                       A. NO--NO MORE TRIM NECESSARY\n.*\n&LBL     SETC  '&LBL. '                ADD EXACTLY 1 BLANK\n.ZZLBL   ANOP  ,\n.*\n.* CALCULATE HOW MUCH ROOM WE HAVE TO WORK WITH:\n&LCLA    SETA  10-1          COLUMNS 1 THROUGH JUST-BEFORE 10\n.*\n         AIF   (&LCLA LE K'&LBL).PADLBLZ NO PAD NECESSARY\n&LBL     SETC  '&LBL'.(&LCLA-K'&LBL)' ' PAD TO LENGTH NECESSARY\n.PADLBLZ ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* TRIM ALL BLANKS FROM RIGHT-HAND END OF &OPR\n         AIF   (K'&OPR EQ 0).OKOPR     LENGTH ZERO--NO TRIM NECESSARY\n.TRIMOPR AIF   ('&OPR'(K'&OPR,1) NE ' ').OKOPR  Q. LAST CHAR A BLANK?\n.* A. YES, LAST CHARACTER IS A BLANK\n         AIF   (K'&OPR EQ 1).ZZOPR     LENGTH ONE--NO PAD NECESSARY\n&OPR     SETC  '&OPR'(1,K'&OPR-1)      A. YES--TRIM LAST CHARACTER AND\n         AGO   .TRIMOPR                    GO BACK AND CHECK SOME MORE\n.OKOPR   ANOP  ,                       A. NO--NO MORE TRIM NECESSARY\n.*\n&OPR     SETC  '&OPR. '                ADD EXACTLY 1 BLANK\n.ZZOPR   ANOP  ,\n.*\n.* CALCULATE HOW MUCH ROOM WE HAVE TO WORK WITH:\n&LCLA    SETA  16-10         COLUMNS 10 THROUGH JUST-BEFORE 16\n.*\n         AIF   (&LCLA LE K'&OPR).PADOPRZ NO PAD NECESSARY\n&OPR     SETC  '&OPR'.(&LCLA-K'&OPR)' ' PAD TO LENGTH NECESSARY\n.PADOPRZ ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* TRIM ALL BLANKS FROM RIGHT-HAND END OF &OPD\n         AIF   (K'&OPD EQ 0).OKOPD     LENGTH ZERO--NO TRIM NECESSARY\n.TRIMOPD AIF   ('&OPD'(K'&OPD,1) NE ' ').OKOPD  Q. LAST CHAR A BLANK?\n.* A. YES, LAST CHARACTER IS A BLANK\n         AIF   (K'&OPD EQ 1).ZZOPD     LENGTH ONE--NO PAD NECESSARY\n&OPD     SETC  '&OPD'(1,K'&OPD-1)      A. YES--TRIM LAST CHARACTER AND\n         AGO   .TRIMOPD                    GO BACK AND CHECK SOME MORE\n.OKOPD   ANOP  ,                       A. NO--NO MORE TRIM NECESSARY\n.*\n&OPD     SETC  '&OPD. '                ADD EXACTLY 1 BLANK\n.ZZOPD   ANOP  ,\n.*\n.* CALCULATE HOW MUCH ROOM WE HAVE TO WORK WITH:\n&LCLA    SETA  &CECCMT1COL-16\n.*\n.PADOPDL ANOP  ,                       ADDITIONAL LINE\n         AIF   (K'&OPD LE &LCLA).PADOPDY                               X\n                                       Q. &OPD SHORT ENOUGH TO FIT?\n&LCLA    SETA  &LCLA+56                 A. NO--USE AN ADDITIONAL LINE\n.* NOTE--EACH CONTINUATION LINE GIVES 56 MORE CHARACTERS (COLS 16-71)\n         AGO   .PADOPDL\n.PADOPDY ANOP  ,                        A. YES--IT WILL FIT\n.*\n         AIF   (&LCLA LE K'&OPD).PADOPDZ NO PAD NECESSARY\n&OPD     SETC  '&OPD'.(&LCLA-K'&OPD)' ' PAD TO LENGTH NECESSARY\n.PADOPDZ ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n.* TRIM ALL BLANKS FROM RIGHT-HAND END OF &CMT\n         AIF   (K'&CMT EQ 0).OKCMT     LENGTH ZERO--NO TRIM NECESSARY\n.TRIMCMT AIF   ('&CMT'(K'&CMT,1) NE ' ').OKCMT  Q. LAST CHAR A BLANK?\n         AIF   (K'&CMT EQ 1).ZZCMT     LENGTH ONE--NO PAD NECESSARY\n&CMT     SETC  '&CMT'(1,K'&CMT-1)      A. YES--TRIM LAST CHARACTER AND\n         AGO   .TRIMCMT                    GO BACK AND CHECK SOME MORE\n.OKCMT   ANOP  ,                       A. NO--NO MORE TRIM NECESSARY\n.*\n&CMT     SETC  '&CMT. '                ADD EXACTLY 1 BLANK\n.ZZCMT   ANOP  ,\n.*\n.* CALCULATE HOW MUCH ROOM WE HAVE TO WORK WITH:\n&LCLA    SETA  &CECCMT2COL-&CECCMT1COL\n.*\n.PADCMTL ANOP  ,                       ADDITIONAL LINE\n         AIF   (K'&CMT LE &LCLA).PADCMTY Q. &CMT SHORT ENOUGH TO FIT?\n&LCLA    SETA  &LCLA+56                  A. NO--USE AN ADDITIONAL LINE\n.* NOTE--EACH CONTINUATION LINE GIVES 56 MORE CHARACTERS (COLS 16-71)\n         AGO   .PADCMTL\n.PADCMTY ANOP  ,                        A. YES--IT WILL FIT\n.*\n         AIF   (&LCLA LE K'&CMT).PADCMTZ NO PAD NECESSARY\n&CMT     SETC  '&CMT'.(&LCLA-K'&CMT)' ' PAD TO LENGTH NECESSARY\n.PADCMTZ ANOP  ,\n.*..+....1....+....2....+....3                                        0\n.*\n         AIF   ('&LBL'(1,1) EQ '*').DOMNOTE\n&LCLAX(1) SETA K'&LBL,K'&OPR,K'&OPD,K'&CMT\n         CECDYN DEBUG,' CECDYN *2',                                    X\n               ' LBL=&LCLAX(1),\"&LBL\"',                                X\n               ' OPR=&LCLAX(2),\"&OPR\"',                                X\n               ' OPD=&LCLAX(3),\"&OPD\"',                                X\n               ' CMT=&LCLAX(4),\"&CMT\"',                                X\n               ' CMT1COL=&CECCMT1COL, CMT2COL=&CECCMT2COL',            X\n               ' CEC#CMT1COL=&CEC#CMT1COL, CEC#CMT2COL=&CEC#CMT2COL'\n.*\n.* THIS IS THE MAIN PURPOSE OF ROUTINE .GENCOM:\n&LBL     &OPR  &OPD&CMT&CEC#CMT2VAL\n.* THAT WAS THE MAIN PURPOSE OF ROUTINE .GENCOM--YOU ALMOST MISSED IT.\n.*\n         AGO   .DONEIT\n.*..+....1....+....2                                                  0\n.*\n.DOMNOTE ANOP  ,\n.*\n         MNOTE '&LBL&OPR&OPD&CMT&CEC#CMT2VAL'\n.*\n         AGO   .DONEIT\n.*..+....1                                                            0\n.*\n.DONEIT  ANOP  ,\n.*\n&LCLA    SETA  &GENRETI      FETCH RETURN INDEX\n&GENRETI SETA  1             RETURN POINTER TO DEFAULT, FOR NEXT TIME\n.* ACTUAL CODE GENERATION:                                            -\n         AGO   (&LCLA).GENRET1,.GENRET2,.GENRET3,.GENRET4,.GENRET5,    X\n               .GENRET6,.GENRET7,.GENRET8,.GENRET9\n.***************************\n.* THE EFFECT OF THE ABOVE CODE IS:\n.*       AGO   .GENRET&LCLA\n.***************************\n         MNOTE 16,'SEVERE INTERNAL ERROR'\n         MNOTE 'GENRETI=&LCLA'\n&CEC#DEBUG SETB 1      TURN ON\n         AGO   .CR#EXIT\n.*..+....1                                                            0\n.*\n.GENRET1 AGO   .CR#EXIT , DEFAULT EXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70\n.*\n.CR#EXIT ANOP  ,\n&CECCMT1COL SETA &CEC#CMT1COL COMMENT 1 FIELD'S COLUMN\n&CECCMT2COL SETA &CEC#CMT2COL COMMENT 2 FIELD'S COLUMN\n         AGO   .SUBEXIT , EXIT FROM .CREAT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.DEBUG   ANOP  , SELF-CALL INTERNAL ROUTINE -- DISPLAY DEBUG MNOTES   0\n.*\n.* IF NO PARAMETERS BESIDES FIRST, TURN ON DEBUGGING AND .SUBEXIT\n         AIF   (N'&SYSLIST NE 1).NORMALDBG\n&CEC#DEBUG SETB 1      TURN ON\n         AGO   .SUBEXIT\n.NORMALDBG ANOP  ,\n.*\n.* IF JUST 1 PARAMETER BESIDES FIRST, AND IT STARTS WITH \".\", SAVE IT\n.* OR IF IT STARTS WITH \".'\", SAVE IT WITHOUT QUOTES\n         AIF   (N'&SYSLIST NE 2).NOSAVE\n         AIF   ('&POS2'(1,1) EQ '.').YSSAVE\n         AIF   ('&POS2'(1,2) EQ '''.').YSSAVEQ\n         AGO   .NOSAVE\n.YSSAVE  ANOP  ,\n&CEC#DBG#HDR SETC '&POS2'\n         AGO   .SUBEXIT\n.YSSAVEQ ANOP   ,\n&CEC#DBG#HDR SETC '&POS2'(2,K'&POS2-2) REMOVE QUOTES\n         AGO   .SUBEXIT\n.NOSAVE  ANOP  ,\n.*\n         AIF   (NOT &CEC#DEBUG).SUBEXIT IMMEDIATE RETURN\n.*\n         CECDYN MNOTE,&CEC#DBG#HDR,' -- ',&POS2,&POS3,&POS4,&POS5,     X\n               &POS6,&POS7,&POS8,&POS9,&POS10\n         AGO   .SUBEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.DOKEY   ANOP  , SELF-CALL INTERNAL ROUTINE -- PROCESS ONE TEXT UNIT  0\n.* ('USER-SUPPLIED' MEANS ON THE OUTER CALL TO CECDYN, FROM OPEN CODE)\n.* INPUT: POSITIONAL PARAMETERS\n.* &POS1  ALWAYS DOKEY\n.* &POS2  ALWAYS &I, ORDINAL TEXT UNIT NUMBER (BUILD '1ST','2ND',ETC.)\n.* &POS3  ALWAYS &KEY, USER-SUPPLIED TEXT UNIT KEY\n.* &POS4  ALWAYS &TEXT(&I,2), USER-SUPPLIED VALUE(S)\n.* &POS5  A TEXT UNIT NAME FROM IEFZB4D2\n.* &POS6  A SINGLE NUMBER OR A PAIR OF NUMBERS (MINPRMS,MAXPRMS) .\n.*         THIS GIVES LIMITS FOR S99TUNUM, WHICH \"SPECIFIES THE NUMBER\n.*         OF LENGTH-AND-PARAMETER COMBINATIONS IN THE TEXT UNIT\".\n.* &POS7  A SINGLE CHARACTER, THE FIELD TYPE C/X/F/A TO BE GENERATED.\n.* &POS8  A SINGLE NUMBER OR A PAIR OF NUMBERS (MINLNG,MAXLNG) .\n.*         THIS GIVES LIMITS FOR S99TULNG, WHICH \"SPECIFIES THE LENGTH\n.*         OF THE FOLLOWING PARAMETER FIELD\".\n.* &POS9  * -- A SINGLE ASTERISK\n.*        OR A LIST ((<CHARS>,<VALU>), (<CHARS>,<VALU>), ...)\n.*     OR A LIST (+, (<CHARS>,<VALU>), (<CHARS>,<VALU>), ...) .\n.*        WHEN A SINGLE ASTERISK IS SPECIFIED, A LABEL IS GENERATED\n.*     FOR AN INFORMATION-RETURN FIELD, CONSISTING OF &PREFIX PLUS\n.*     THE TEXT UNIT'S NAME.\n.*        WHEN A LIST IS SPECIFIED, THE USER-SUPPLIED VALUE(S) ARE\n.*     COMPARED AGAINST EACH <CHARS> ENTRY IN THE LIST, AND WHEN\n.*     AN EQUAL IS FOUND, THE CORRESPONDING <VALU> IS USED.\n.*     ORDINARILY, THE USER CAN ONLY SPECIFY ONE VALUE.  WHEN THE\n.*     LIST BEGINS WITH '+', MULTIPLE VALUES SPECIFIED BY THE USER\n.*     ARE TRANSLATED INTO MULTIPLE <VALU>S WHICH ARE THEN SUMMED TO\n.*     GENERATE A VALUE.\n.*        A <CHARS> ENTRY OF A SINGLE ASTERISK IS CONSIDERED A MATCH\n.*     FOR ANY VALUE SPECIFIED BY THE USER.\n.*        IN ADDITION TO THE VALUE GENERATED, A COMMENT IS GENERATED\n.*     IN THE FORM \"<CHARS>=<VALU>\".\n.*        IF THE LIST ENDS WITH AN ASTERISK, THEN NO ERROR MESSAGE\n.*     IS GENERATED FOR THE USER-SPECIFIED VALUE NOT BEING FOUND\n.*     AMONG THE <CHARS> ENTRIES, AND THE USER-SPECIFIED VALUE IS\n.*     USED AS-IS.\n.* &POS10  TEXT APPENDED TO THE GENERATED COMMENT.\n.*\n.*\n.*\n.* IF THERE IS ONLY 1 TEXT UNIT NAME IN THE LIST (N'&POS5 EQ 1) AND\n.* IT DOES NOT EQUAL THE ONE THE USER SUPPLIED    ('&POS3' NE '&POS5')\n.* THEN EXIT IMMEDIATELY     (.SUBEXIT)\n         AIF   (                                  N'&POS5 EQ 1  AND    X\n                                                   '&POS3' NE '&POS5'  X\n                             ).SUBEXIT\n.*\n.*\n.* IN CASE MORE THAN 1 TEXT UNIT NAME IS CODED,\n.* FIND USER-SUPPLIED &POS3 IN THE &POS5 LIST OF TEXT UNIT NAMES\n&J       SETA  1\n.NEXTJ01 ANOP  ,\n         AIF   ('&POS3' EQ '&POS5(&J)').EXITJ01\n.ADVJ01  ANOP  , ADVANCE &J\n&J       SETA  &J+1\n         AIF   (&J LE N'&POS5).NEXTJ01\n         AGO   .SUBEXIT , NOT FOUND, EXIT IMMEDIATELY\n.EXITJ01 ANOP  ,\n.* NOW &J POINTS TO THE ENTRY IN THE &POS5 LIST THAT MATCHES &POS3.\n.*\n.*\n.A#DOKEY CECDYN DEBUG,'.DOKEY A#DOKEY' SAVE HEADING FOR DEBUG MESSAGES\n.*\n.******* CECDYN DEBUG,'&NAME CECDYN *1 &POS1,&POS2,\"',                 X\n               &POS3,'\",&POS4,\"',                                      X\n               &POS5,'\",\"',                                            X\n               &POS6,'\",&POS7,&POS8,\"',                                X\n               &POS9,'\"'\n.*\n&CEC#KEYDONE SETB 1          INFORM CALLER, KEY HAS BEEN FOUND\n&I       SETA  &POS2\n&KEY     SETC  '&POS3'\n.*\n&CECCMT1COL SETA &CEC#CMT1COL COMMENT 1 FIELD'S COLUMN\n&CECCMT2COL SETA &CEC#CMT2COL COMMENT 2 FIELD'S COLUMN\n.* (EACH CALL TO .CREAT DOES ABOVE SETA.S, JUST BEFORE EXITING)\n.*\n&CEC#XLAT SETB (N'&POS9 GT 1  OR  '&POS7' EQ 'A')\n.*           IF N'&POS9 GT 1, THEN DEFINITELY A TRANSLATION TABLE.\n.* BUT, &POS9 MAY BE OMITTED;  IF '&POS7' EQ 'A', IT IS NUMERIC;\n.* ACT LIKE #XLAT.\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.A#XLAT  CECDYN DEBUG,'.DOKEY A#XLAT' SAVE HEADING FOR DEBUG MESSAGES\n&MAXJ    SETA  1             ONE VALUE TO BE GENERATED\n         AIF   (&CEC#XLAT).GENHDR     GENERATE GROUP HEADER\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.A#XCHK  CECDYN DEBUG,'.DOKEY A#XCHK' SAVE HEADING FOR DEBUG MESSAGES\n.*                           SET &MAXJ, AND OTHER THINGS\n.* FALL-THRU TO .GENHDR      AND THEN GENERATE GROUP HEADER\n.*\n.*\n.* FIRST, CROSS-CHECK BETWEEN:\n.*       N'&POS4 (NUMBER OF VALUES SPECIFIED BY THE CALLER)\n.*     AND &POS6 (NUMBER OF VALUES EXPECTED).\n.*\n         AIF   ((N'&POS6-1)*(N'&POS6-2) EQ 0).C#XCHK\n         MNOTE 4,'INTERNAL ERROR PROCESSING KEY &POS3 -- &&POS6 SHOULD X\n               HAVE ONLY 1 OR 2 ENTRIES, IT WAS \"&POS6\"'\n.C#XCHK  ANOP  ,\n.* IF N'&POS6=1, A FIXED # VALUES IS EXPECTED, &POS6(1)\n.* IF N'&POS6=2, MIN # VALUES EXPECTED IS &POS6(1), MAX IS &POS6(2)\n         AIF   (N'&POS6 NE 1).D#XCHK  VARIABLE NUMBER POSSIBLE? YES\n         AIF   (&POS6(1) NE 0).D#XCHK NON-ZERO NUMBER REQUIRED? YES\n         AIF   (N'&POS4 NE 0).D#XCHK  USER SUPPLIED AT LEAST 1? YES\n.* FIXED NUMBER POSSIBLE, WHICH IS ZERO, AND USER DID NOT SUPPLY ANY:\n&MAXJ    SETA  0            NO VALUES TO BE GENERATED\n         AGO   .F#XCHK      GO GENERATE THEM\n.D#XCHK  AIF   (N'&POS4 LE &POS6(N'&POS6)).E#XCHK Q. TOO MANY? A. NO  0\n&LCLA2   SETA  N'&POS4      # VALUES SPECIFIED                 A. YES\n         MNOTE 8,'ERROR: &LCLA2 VALUES WERE SPECIFIED FOR KEY &POS3 -- X\n               &POS6(N'&POS6) IS THE MAXIMUM NUMBER PERMITTED.'\n.E#XCHK  ANOP  ,\n&MAXJ    SETA  &POS6(1)     FIRST OR ONLY -- MINIMUM OR REQUIRED #\n         AIF   (&MAXJ GT N'&POS4).F#XCHK CALLER SPECIFIED FEWER? YES,  X\n                                       GENERATE THE MINIMUM # REQUIRED\n&MAXJ    SETA  N'&POS4 NO, GENERATE AS MANY VALUES AS CALLER SPECIFIED\n.*\n.F#XCHK  ANOP  ,\n.*\n         CECDYN DEBUG,'POS4=&POS4, POS6=&POS6, SO MAXJ=&MAXJ..'\n.*\n         AGO   .GENHDR\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.GENHDR  ANOP  ,             GENERATE GROUP HEADER\n.*\n.* BOTH .XLAT AND .XCHK PASS THROUGH HERE\n.*\n         AIF   (&CEC#XLAT).Q#XLAT\n.Q#XCHK  CECDYN CMT2,.XCHK   SET &CEC#CMT2VAL\n         AGO   .Q#BOTH\n.Q#XLAT  CECDYN CMT2,.XLAT   SET &CEC#CMT2VAL\n.Q#BOTH  ANOP  ,\n.*\n&CEC#P.NUM&I CECDYN CREAT,,A,2,&MAXJ,'# OF LENGTH+PARAMETER ENTRIES'\n.*..+....1....+....2....+....3....+....4                              0\n.*\n.*\n.* IF &POS9 IS NOT A TRANSLATION TABLE, GENERATE MULTIPLE VALUES.\n.*\n         AIF   (&MAXJ EQ 0).SUBEXIT   NO VALUES TO BE GENERATED? YES\n.*\n.* IF THERE IS A MINIMUM NUMBER, DO THAT MANY (NULL VALUES, IF NEEDED)\n.*                               ELSE DO AS MANY AS CALLER SPECIFIED\n.*\n.* NOW, LOOP THROUGH REQUIRED NUMBER (FROM 1 UP THROUGH &MAXJ)\n&J       SETA  1\n.NEXTJ02 CECDYN DEBUG,'.DOKEY NEXTJ02' SAVE HEADING FOR DEBUG MESSAGES\n&SUFFIX  SETC  ''                  NO SUFFIX NEEDED, IF ONLY 1 FIELD\n         AIF   (&MAXJ EQ 1).SFXOK  YES, ONLY 1 FIELD TO BE GENERATED\n&SUFFIX  SETC  '#&J'               IF MORE THAN 1, DISTINGUISH THEM\n.SFXOK   ANOP  ,\n&CEC#P.ENT&I&SUFFIX CECDYN CREAT,0,C,,,'ENTRY OF LENGTH+PARAMETER'\n.*..+....1....+....2....+....3....+....4                              0\n.*..+....1....+....2....+....3....+....4                              1\n.*\n         AIF   (NOT &CEC#XLAT).NOXLAT2\n.*\n.XLATVV  ANOP  , WHEN &CEC#XLAT, SET &VALUE, &VALUE2, &LV\n.*             (NOTE: WHEN &CEC#XLAT, THEN &MAXJ IS 1, SO THIS CODE\n.*              IS NOT DONE EACH TIME THROUGH THE .NEXTJ02 LOOP)\n.*\n.*       &POS4 IS VALUES SPECIFIED BY CALLER;              (INDEX &K)\n.*       &POS9 IS TRANSLATION TABLE   ((R,2),(N,8),...)\n.*                               OR (+,(R,2),(N,8),...)    (INDEX &L)\n.* EACH TRANSLATION TABLE ENTRY CONSISTS OF:\n.*      &POS9(&L,1) <CHARS> FROM, AND &POS9(&L,2) <VALU> TO\n.*\n.* TWO LOOPS BELOW, LOOP BY &L WITHIN LOOP BY &K\n.*\n&VALUE   SETC  '&POS4'                 VALUE\n&VALUE2  SETC  '&KEY'                  COMMENT\n         AIF   (N'&POS9 EQ 0 AND N'&POS4 EQ 1).EXITK02 SKIP ENTIRELY\n.*\n.T#XLAT  CECDYN DEBUG,'.DOKEY T#XLAT' SAVE HEADING FOR DEBUG MESSAGES\n&VALUE   SETC  '0'                     INITIAL VALUE\n&VALUE2  SETC  ''                      INITIAL COMMENT\n         AIF   (N'&POS4 EQ 0).EXITK02\n&K       SETA  1\n.NEXTK02 ANOP  ,\n.*\n.* PROCESS ENTRY &POS4(&K) SPECIFIED BY USER\n.*\n&POS4K   SETC  '&POS4(&K)'\n         AIF   (N'&POS4 NE 1 OR &MAXJ NE 1).POS4KOK\n&POS4K   SETC  '&POS4'       PASS-THRU PARENS OF REGISTER OPERAND\n.POS4KOK ANOP  ,\n.*\n&LCLC    SETC  '0'                          DEFAULT VALUE\n&LCLC2   SETC  'IGNORE &POS4K'              DEFAULT COMMENT\n.*\n.*          IF (&K EQ 1) ALWAYS TRANSLATE FIRST USER-SPECIFIED VALUE:\n         AIF   (&K EQ 1).YESXLAT\n.*          IF WE ARE SUMMING, TRANSLATE ALL USER-SPECIFIED VALUES:\n         AIF   ('&POS9(1)' EQ '+' OR '&POS9(1)' EQ '''+''').YESXLAT\n         AGO   .SKIPXLT IF NOT SUMMING, ONLY TRANSLATE FIRST VALUE\n.YESXLAT ANOP  ,\n.*\n&L       SETA  1\n.NEXTL02 ANOP  ,\n         AIF   (N'&POS9(&L) NE 2).ADVL02 (SKIP NON-PAIRS IN &POS9)\n         AIF   ('&POS9(&L,1)' EQ '*').MATCH\n         AIF   ('&POS9(&L,1)' EQ '&POS4K').MATCH\n         AGO   .ADVL02\n.MATCH   ANOP  ,\n&LCLC    SETC  '&POS9(&L,2)'                RETURN VALUE\n&LCLC2   SETC  '&POS9(&L,1)=&POS9(&L,2)'    RETURN COMMENT\n         AGO   .EXITL02\n.ADVL02  ANOP  , ADVANCE &L\n&L       SETA  &L+1\n         AIF   (&L LE N'&POS9).NEXTL02\n.*\n.* WE REACH HERE IF &POS4K IS NOT FOUND IN THE TRANSLATE TABLE\n         AIF   ('&POS9(&L-1)' NE '*').EXITL02\n.* IF LAST ENTRY IN TRANSLATE TABLE IS '*', OK TO BE NOT-FOUND\n&LCLC    SETC  '&POS4K'                     RETURN VALUE\n&LCLC2   SETC  '&POS4K NOT TRANSLATED'      RETURN COMMENT\n.*\n.EXITL02 ANOP  , &LCLC=RETURN VALUE, &LCLC2=RETURN COMMENT\n.*\n.SKIPXLT ANOP  , SKIP TRANSLATION CODE ABOVE\n         AIF   (&K NE 1).ADDVALS ELSE SETVALS\n.SETVALS ANOP  ,\n&VALUE   SETC  '&LCLC'                 SET VALUE\n&VALUE2  SETC  '&KEY &LCLC2'           SET COMMENT\n         AGO   .ADVK02\n.ADDVALS ANOP  ,\n&VALUE   SETC  '&VALUE+&LCLC'          APPEND TO VALUE\n&VALUE2  SETC  '&VALUE2, &LCLC2'       APPEND TO COMMENT\n.ADVK02  ANOP  , ADVANCE &K\n&K       SETA  &K+1\n         AIF   (&K LE N'&POS4).NEXTK02\n         AGO   .EXITK02\n.*\n.EXITK02 ANOP  ,\n.*\n&LCLC    SETC  '&POS10'                           FETCH VALUE\n         AIF   (K'&LCLC LE 2).NOTCOMT             TOO SHORT FOR QUOTES\n         AIF   ('&LCLC'(1,1) NE '''').NOTCOMT       NOT LEADING QUOTE,\n         AIF   ('&LCLC'(K'&LCLC,1) NE '''').NOTCOMT NOR TRAILING.\n&LCLC    SETC  '&LCLC'(2,K'&LCLC-2)               REMOVE QUOTES\n.NOTCOMT ANOP  ,\n&VALUE2  SETC  '&VALUE2 &LCLC'\n.*\n         AIF   (&CEC#FLAG(1)).B#CHGV2      DC -- TEXT ONLY\n         AIF   (&CEC#FLAG(2)).B#CHGV2      DS -- TEXT ONLY\n         AIF   ('&VALUE2' NE '').X#CHGV2      ACTIVE -- DESCRIBE XLATE\n.* IF NO XLATE WAS DONE, FALL THRU TO TEXT ONLY\n.B#CHGV2 ANOP  ,\n&VALUE2  SETC  ''   LET IT BE OVERRIDDEN LATER\n.X#CHGV2 ANOP  ,\n.*\n&LV      SETA  &POS8(1)\n.*\n.NOXLAT2 ANOP  ,\n.*..+....1....+....2....+....3....+....4                              0\n.*..+....1....+....2....+....3....+....4                              1\n.*\n         AIF   (&CEC#XLAT).NOXCHK2\n.*\n.XCHKVV  ANOP  , WHEN NOT &CEC#XLAT, SET &VALUE, &VALUE2, &LV\n.*\n.* ANALYSE CALLER-SPECIFIED VALUE:\n.* &POS4(&J)=''      PRODUCES &NUL=1\n.*\n.* &POS4(&J)='...' PRODUCES &LIT=1\n.* &POS4(&J)=(...) PRODUCES &REG=1\n.* &POS4(&J)=A(...) PRODUCES &ACN=1\n.*   NOTE--IF A LIST WITH ONLY 1 ENTRY IS SPECIFIED, THAT IS &REG.\n&VALUE   SETC  '&POS4(&J)'\n         AIF   (N'&POS4 NE 1).BBVAL\n&VALUE   SETC  '&POS4'       PROPOGATE PARENS, SO &REG IS CORRECT\n.BBVAL   ANOP  ,\n.*\n&LIT     SETB  0             LITERAL\n&REG     SETB  0             REGISTER\n&ACN     SETB  0             ADDRESS CONSTANT\n&NUL     SETB  1             NULL -- OMITTED\n&LCLC    SETC   'POS4(J=&J.)=&VALUE.,'     PREPARE FOR DEBUGGING\n         AIF   (K'&VALUE EQ 0).ZZVAL             .* IF NULL SKIP\n         AIF   ('&VALUE' EQ '').ZZVAL            .* IF NULL SKIP\n&NUL     SETB  0                               .* RESET NULL IF NOT\n         AIF   (K'&VALUE LT 3).XXVAL TOO SHORT TO BE ANYTHING\n&LIT     SETB  ('&VALUE'(1,1) EQ '''' AND '&VALUE'(K'&VALUE,1) EQ '''')\n&LCLC    SETC   'POS4(J=&J.)='.'&VALUE'(2,K'&VALUE-2).','\n         AIF   (&LIT).ZZVAL\n&LCLC    SETC   'POS4(J=&J.)=&VALUE.,'     PREPARE FOR DEBUGGING\n&REG     SETB  ('&VALUE'(1,1) EQ '(' AND '&VALUE'(K'&VALUE,1) EQ ')')\n         AIF   (&REG).ZZVAL\n         AIF   (K'&VALUE LT 4).XXVAL TOO SHORT TO BE ACN\n&ACN     SETB  ('&VALUE'(1,2) EQ 'A(' AND '&VALUE'(K'&VALUE,1) EQ ')')\n         AIF   (&ACN).ZZVAL\n.XXVAL   ANOP  ,\n.ZZVAL   ANOP  ,\n         CECDYN DEBUG,'&LCLC NUL=&NUL, LIT=&LIT, REG=&REG, ACN=&ACN..'\n.*..+....1....+....2....+....3                                        0\n.*\n.A#LGH   CECDYN DEBUG,'.DOKEY A#LGH' SAVE HEADING FOR DEBUG MESSAGES\n.* DEFAULT VALUE LENGTH IS MAX VALUE LENGTH\n.* IF RANGE PERMITTED, AND CALLER SPECIFIED LITERAL VALUE,\n.*       THEN USE MAXIMUM OF (CALLER'S VALUE'S LENGTH, MINIMUM LENGTH)\n.*       &POS4 IS (VALUES) SPECIFIED BY CALLER;\n.*       &POS8 IS LENGTH OF EACH VALUE EXPECTED\n         AIF   ((N'&POS8-1)*(N'&POS8-2) EQ 0).B#LGH\n         MNOTE 4,'INTERNAL ERROR PROCESSING KEY &POS3 -- &&POS8 SHOULD X\n               HAVE ONLY 1 OR 2 ENTRIES, IT WAS \"&POS8\"'\n.B#LGH   ANOP  ,\n.* IF N'&POS8=1, A FIXED LENGTH IS EXPECTED,  &POS8(1)\n.* IF N'&POS8=2, MINIMUM LENGTH EXPECTED IS &POS8(1), MAX IS &POS8(2)\n&LMIN    SETA  &POS8(1)      MUST BE SELF-DEFINING DECIMAL TERM\n&LMAX    SETA  &POS8(N'&POS8) MUST BE SELF-DEFINING DECIMAL TERM\n&LV      SETA  &LMAX         DEFAULT VALUE LENGTH IS MAX VALUE LENGTH\n         AIF   (N'&POS8 EQ 1).G#LGH OK--ONLY 1, USE THAT LENGTH\n         AIF   (NOT &LIT).G#LGH       OK--USE MAX (OR ONLY) LENGTH\n&LV      SETA  &LMIN         DEFAULT VALUE LENGTH IS MIN VALUE LENGTH\n&LCLA2   SETA  K'&POS4(&J)-2 LENGTH OF VALUE SPECIFIED (W/O QUOTES)\n         AIF   (&LCLA2 LT &LMIN).G#LGH  OK--FORCE MINIMUM LENGTH\n&LV      SETA  &LCLA2        OK--USE CALLER'S VALUE'S LENGTH\n.G#LGH   ANOP  ,\n.X#LGH   ANOP  ,\n         CECDYN DEBUG,' POS8=&POS8.; MIN=&LMIN., MAX=&LMAX..'\n&LCLC    SETC  'K''''POS4(J=&J.)=K'''''.'&POS4(&J).=&LCLA2.;'\n&LCLC    SETC  '&LCLC. LENGTH USED IS LV=&LV..'\n         CECDYN DEBUG,'&LCLC'\n.*\n&VALUE2  SETC  ''   LET IT BE OVERRIDDEN LATER\n.*\n.NOXCHK2 ANOP  ,                                                      0\n.*..+....1....+....2....+....3....+....4                              -\n.*..+....1....+....2....+....3....+....4                              -\n&I1      SETA  &I-10*(&I/10)           1'S DIGIT OF &I\n&I10     SETA  (&I/10)-10*(&I/100)     10'S DIGIT OF &I\n&IIX     SETA  1+3*(&I1*(&I10-1)/(&I10-1)) IGNORE &I1 IF (&I10-1) EQ 0\n&ITH     SETC  'TH ST ND RD TH TH TH TH TH TH '(&IIX,2) 0TH, 1ST, ETC.\n.*..+....1\n&J1      SETA  &J-10*(&J/10)           1'S DIGIT OF &J\n&J10     SETA  (&J/10)-10*(&J/100)     10'S DIGIT OF &J\n&JIX     SETA  1+3*(&J1*(&J10-1)/(&J10-1)) IGNORE &J1 IF (&J10-1) EQ 0\n&JTH     SETC  'TH ST ND RD TH TH TH TH TH TH '(&JIX,2) 0TH, 1ST, ETC.\n.*..+....1\n&CEC#P.LNG&I&SUFFIX CECDYN CREAT,,A,2,&LV,                             X\n               'LENGTH OF &J&JTH PARM. OF &I&ITH KEY'\n         AIF   (&J NE 1).NOLABEL             LABEL ONLY FOR FIRST\n.******* AIF   ('&POS9' NE '*').NOLABEL Q. MUST WE DEFINE NAME? A. NO\n.*                                                              A. YES\n         AIF   ('&POS9' NE '*' AND '&CEC#CMT2VAL' EQ '.XLAT').NOLABEL\n.* (FOR .XCHK, FALL THROUGH ALL THE TIME)\n.*\n&LCLC    SETC  '&CEC#P'.'&KEY'(4,K'&KEY-3)\n&LCLC    CECDYN CREAT,0,&POS7,&LV,,'DEFINE NAME FOR USER'\n.NOLABEL ANOP  ,\n.*\n         AIF   ('&VALUE2' NE '').NOTNULL\n&VALUE2  SETC  'VALUE OF &J&JTH PARM. OF &I&ITH KEY' OVERRIDE HERE\n.NOTNULL ANOP  ,\n.*\n&CEC#P.PAR&I&SUFFIX CECDYN CREAT,,&POS7,&LV,&VALUE,'&VALUE2'\n.*..+....1....+....2....+....3                                        0\n.*\n.ADVJ02  ANOP  , ADVANCE &J\n&J       SETA  &J+1\n         AIF   (&J LE &MAXJ).NEXTJ02\n.*\n         AGO   .SUBEXIT\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....70\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....71\n.MNOTE   ANOP  , SELF-CALL INTERNAL ROUTINE -- MNOTE '&POS2&POS3...'\n&LCLC    SETC  ''\n.*\n&J       SETA  2\n.NEXTJ04 ANOP  ,\n.*\n.*\n         AIF   ('&SYSLIST(&J)' EQ '').EXITI04\n&LCLB    SETB  ('&SYSLIST(&J)'(1,1) EQ '''' AND                        X\n                             '&SYSLIST(&J)'(K'&SYSLIST(&J),1) EQ '''')\n.* QUOTES AT BOTH ENDS?\n&I       SETA  1+&LCLB    IF YES, SKIP BEGINNING QUOTE\n.NEXTI04 ANOP  ,\n         AIF   (K'&LCLC GE 254).EXITI04      .TOOBIG\n         AIF   ('&SYSLIST(&J)'(&I,1) EQ '''').DOUBLE\n         AIF   ('&SYSLIST(&J)'(&I,1) EQ '&&').DOUBLE\n&LCLC    SETC  '&LCLC'.'&SYSLIST(&J)'(&I,1)\n         AGO   .ADVI04\n.TOOBIG  MNOTE '&&LCLC TOO LONG -- &&J=&J -- &&I=&I -- &&LCLC=\"&LCLC\"'\n         AGO   .ADVI04\n.DOUBLE  ANOP  ,\n&LCLC    SETC  '&LCLC'.'&SYSLIST(&J)'(&I,1).'&SYSLIST(&J)'(&I,1)\n         AGO   .ADVI04\n.ADVI04  ANOP  , ADVANCE &I\n&I       SETA  &I+1\n         AIF   (&I LE K'&SYSLIST(&J)-&LCLB).NEXTI04 SKIP ENDING QUOTE\n.EXITI04 ANOP  ,\n.*\n.*\n.ADVJ04  ANOP  , ADVANCE &J\n&J       SETA  &J+1\n         AIF   (&J LE N'&SYSLIST).NEXTJ04\n.EXITJ04 ANOP  ,\n.*\n         MNOTE '&LCLC'                                                -\n         AGO   .SUBEXIT                                               -\n.*..+....1....+....2....+....3....+....4....+....5....+....6....+....7\n         MEND ,                                                       0\n         AGO   .SKIPTEXT\n                                                                      1\n@P\n1* (C) COPYRIGHT CENTERIOR ENERGY CORPORATION 1988,1991\n-CECDYN -- macro for building Dynamic Allocation parameter list\n-     This macro builds a parameter list which can be used by SVC 99.\n      It does not issue a call to SVC 99, it only builds the parameter\n      list in storage and returns control.\n0     Unlike the IBM-supplied macros, instead of calculating offsets\n      into the parameter list to store values into it, a dummy control\n      section and symbolic names are generated and used.  If a USING\n      is issued on the dummy section, the symbolic names can then be\n      used to modify the parameter list.  All symbolic names generated\n      by one call to CECDYN start with the same three characters.  The\n      three characters can be specified by the caller, or will be\n      assigned by the macro.\n0     The standard form of the CECDYN macro instruction is written\n      as follows:\n\n>     ----------------------------------------------------------------\n0     <name>              <name>: symbol.  Begin <name> in column 1.\n0     b\n+     /                   One or more blanks must precede CECDYN.\n0     CECDYN\n0     b\n+     /                   One or more blanks must follow CECDYN.\n\n>     ----------------------------------------------------------------\n0     VERB=<verb>         <verb>: two byte character string\n0     ,PREFIX=<prefix>    <prefix>: maximum-of-3 byte character string\n0     ,FLG11=(<flg11>)\n      ,FLG21=(<flg21>)\n      ,FLG22=(<flg22>)    <flg11>/<flg21>/<flg22>: one or more 5 byte\n                          character strings, seperated by commas.  For\n                          example, FLG##=(<flg##>,<flg##>,<flg##>) .\n                          If only one <flg##> is specified, the outer\n                          parentheses may be omitted.\n0     ,TEXT=(<text unit>) <text unit>: either a maximum-of-5 byte\n                          character string, or a parenthesized pair\n                          consisting of a maximum-of-5 byte character\n                          string plus one of: literal delimited by\n                          quotes, A-type address, register (2)-(12).\n                          If only one <text unit> is specified, the\n                          outer parentheses must still be coded.\n                          Note:  <text unit> is one or more text\n                          units, seperated by commas.  For example,\n                          TEXT=(<text unit>,<text unit>,<text unit>)\n0     ,LIST=NO            Default: LIST=YES\n      ,LIST=YES\n\n>     ----------------------------------------------------------------\n-     The parameters are explained below:\n-     VERB=<verb>\n0       specifies the SVC 99 function requested.  The two bytes\n        supplied will be prepended with 'S99VRB' to build a symbol\n        which specifies a verb code.  The seven verb codes are defined\n        in the IBM-supplied macro IEFZB4D0, described in \"System\n        Macros and Facilities\".\n0       No checking is done for validity, but values not defined in\n        IEBZB4D0 will create undefined symbols.\n0       There is no default for this parameter.\n-     FLG11=<flg11>\n      FLG21=<flg21>\n      FLG22=<flg22>\n0       specify certain available options.  Each 5 bytes supplied will\n        be prepended with 'S99' to build a symbol which specifies an\n        option, and all the <flg11> will be summed to produce FLG11,\n        all the <flg21> will be summed to produce FLG21, all the\n        <flg22> will be summed to produce FLG22.\n        FLG11 options are available to all SVC 99 callers.\n        FLG21 & FLG22 options are only available to authorized\n        callers.\n        The options available are defined in IBM-supplied macro\n        IEFZB4D0, described in \"System Macros and Facilities\".\n0       No checking is done for validity, but values not defined in\n        IEBZB4D0 will create undefined symbols.\n-     Note: No checking is done that a FLG11 option is specified for\n        FLG21, etc., or vice versa.  It will not cause an assembly\n        error, but results are unpredictable.\n-     ,PREFIX=<prefix>\n        optionally supplies up-to-3 characters to be used in building\n        the symbolic names for fields in the parameter list.  If not\n        specified, CECDYN will create a 3-character prefix dependent\n        on the assembler system variable &SYSNDX.  The prefix created\n        by CECDYN will start with an alphabetic character which will\n        range through A thru Z, and its next two characters will each\n        range through 0 thru 9 and A thru Z, the last character\n        varying most quickly, as &SYSNDX increases.\n        The dummy section created is named <prefix>DSECT, and it's\n        length is available as L'<prefix>DSECT .\n-     ,TEXT=(<text unit>)\n        specifies the text units to be placed in the parameter list.\n        Each text unit specified will usually be a parenthesized pair\n        consisting of a maximum-of-5 byte character string plus one\n        of:  literal delimited by quotes, A-type address, register\n        (2)-(12).\n        The character string will be prepended with the character 'D'\n        plus the VERB specified, to make a symbol which is defined in\n        the IBM-supplied macro IEFZB4D2, described in \"System Macros\n        and Facilities\".\n0       No checking is done for validity of the character string, but\n        values not defined in IEBZB4D2 will create undefined symbols.\n0       Some text units do not require a value, and these will be\n        specified by only the maximum-of-5 byte character string.  For\n        these, the inner parentheses may be omitted.\n0       If no text units are specified, only the request block pointer\n        and the request block are built.  If null text units are\n        specified, then text unit pointers with a value of zero are\n        built.\n0       Certain text units may have multiple values specified which\n        are then summed to build one value (DALOPTCD).  These, and\n        others, may have their values specified as character strings\n        which are then translated by CECDYN to be the proper hex\n        values -- For example, (STATS,OLD) will generate a value of\n        X'01'.  If you wish, you may code the actual hex value.\n0       Certain other text units may have multiple values which create\n        multiple fields in the parameter list (DALVLSER,etc.)  CECDYN\n        will check whether multiple values are specified for a text\n        unit which does not allow multiple values.\n0     ,LIST=NO\n      ,LIST=YES\n        specifies whether or not generated code is to be printed.\n        If this parameter is not specifed, a default of YES is used.\n-     When control is returned, register 1 points to the parameter\n      list.  SVC 99 can be issued immediately, or the parameter list\n      can be modified before issuing SVC 99.\n      The addresses of text units are stored in the parameter list\n      starting at the location labelled <prefix>TUPL.  The address of\n      each text unit is stored in the parameter list in field\n      <prefix>PTR<#>, where <prefix> is the PREFIX specified or\n      generated, and <#> ranges from 1 through the number of text\n      units specified.  Each text unit begins at the field labelled\n      <prefix>TU<#>.  Each text unit will always have a KEY subfield\n      <prefix>KEY<#> containing the text unit key, and a NUMBER\n      subfield <prefix>NUM<#> containing the number of length and\n      parameter combinations in the text unit.  Some text units will\n      have only these two subfields, if its NUMBER subfield has a\n      value of zero.\n-Example 1\n0     Operation: Unallocate the data set associated with ddname\n      IEFRDER.  CECDYN will assign a 3-byte prefix to the names\n      generated.\n0     NAME     CECDYN VERB=UN,TEXT=((DDNAM,'IEFRDER'))\n               DYNALLOC\n               LTR   15,15          WAS SVC99 SUCCESSFUL ?\n               ...\n0\n-Example 2\n0     Operation: Request all available information text units, for the\n      data set currently allocated to the ddname stored in symbol\n      WRKDD.  Returned information will be in the fields ZZZRTLST,\n      ZZZRTDDN, etc.\n      These fields will be accessible by issuing a USING ZZZDSECT,1 .\n0     INFORM   CECDYN  PREFIX=ZZZ,                                     X\n                     VERB=IN,                                          X\n                     TEXT=((DDNAM,WRKDD),                              X\n                     RTLST,RTDDN,RTDSN,RTMEM,RTSTA,                    X\n                     RTNDP,RTCDP,RTORG,RTLIM,RTATT,RTTYP)\n               DYNALLOC\n               LTR   15,15          WAS SVC99 SUCCESSFUL ?\n               BNZ   ERROR          NO.\n               USING ZZZDSECT,1     ADDRESSABILITY TO PARAMETER LIST\n               MVC   LASTIND,ZZZRTLST\n               MVC   MEMBER,ZZZRTMEM\n               ...\n-Example 3\n0     Operation: Build a list to be modified later.  In the list,\n      specify 'do not mount volumes or consider offline devices'.\n      Reserve space for 5 text unit addresses.  Modify the first three\n      addresses by using the list form of the CALL macro instruction.\n0     ALLOCIT  CECDYN  PREFIX=Q02,                                     X\n                     VERB=AL,                                          X\n                     FLG11=NOMNT,                                      X\n                     TEXT=(,,,,)\n               USING Q02DSECT,1\n               MVC   Q02TUPL(CALLISTX-CALLIST),CALLIST\n               DYNALLOC\n               LTR   15,15          WAS SVC99 SUCCESSFUL ?\n               ...\n               ...\n      CALLIST  CALL  ,(THIS,THAT,OTHER),VL,MF=L\n      CALLISTX EQU   *\n1\n-CECDYN (List Form)\n-     The list form of the CECDYN macro instruction is used to\n      construct a nonexecutable SVC 99 parameter list.  This list form\n      generates only ADCONs of the text unit parameters.  This\n      parameter list can be referred to in the execute form of a\n      CECDYN macro instruction.\n0     The list form of the CECDYN macro instruction is written as\n      follows:\n\n>     ----------------------------------------------------------------\n0     <name>              <name>: symbol.  Begin <name> in column 1.\n0     b\n+     /                   One or more blanks must precede CECDYN.\n0     CECDYN\n0     b\n+     /                   One or more blanks must follow CECDYN.\n\n>     ----------------------------------------------------------------\n0     VERB=<verb>         <verb>: two byte character string\n0     ,PREFIX=<prefix>    <prefix>: maximum-of-3 byte character string\n0     ,FLG11=(<flg11>)\n      ,FLG21=(<flg21>)\n      ,FLG22=(<flg22>)    <flg11>/<flg21>/<flg22>: one or more 5 byte\n                          character strings, seperated by commas.  For\n                          example, FLG##=(<flg##>,<flg##>,<flg##>) .\n                          If only one <flg##> is specified, the outer\n                          parentheses may be omitted.\n0     ,TEXT=(<text unit>) <text unit>: either a maximum-of-5 byte\n                          character string, or a parenthesized pair\n                          consisting of a maximum-of-5 byte character\n                          string plus one of: literal delimited by\n                          quotes, A-type address, register (2)-(12).\n                          If only one <text unit> is specified, the\n                          outer parentheses must still be coded.\n                          Note: <text unit> is one or more text units,\n                          seperated by commas.  For example,\n                          TEXT=(<text unit>,<text unit>,<text unit>)\n0     ,LIST=NO            Default: LIST=YES\n      ,LIST=YES\n0     ,MF=L\n\n>     ----------------------------------------------------------------\n-     The parameters are explained under the standard form of the\n      CECDYN macro instruction, with the following exception:\n-     MF=L\n0       specifies the list form of the CECDYN macro instruction.\n1\n-CECDYN (Execute Form)\n-     A remote SVC 99 parameter list is referred to and can be\n      modified by the execute form of the CECDYN macro instruction.\n      Only executable instructions are generated.  The first time a\n      particular PREFIX is used, a DSECT is defined.  Each execute\n      form CECDYN macro instruction later in a program which uses the\n      same PREFIX must have the same VERB as specified on the list\n      form CECDYN macro instruction, or symbolic names referred-to in\n      the generated code will not be previously defined.  A\n      combination of FLG11, FLG21, and FLG22 values can be specified\n      that is different than that specified on the list form CECDYN\n      macro instruction.\n      The TEXT may have fewer entries specified, but should have no\n      new maximum-of-5 byte character strings which were not on the\n      list form CECDYN macro instruction.\n0     The execute form of the CECDYN macro instruction is written as\n      follows:\n\n>     ----------------------------------------------------------------\n0     <name>              <name>: symbol.  Begin <name> in column 1.\n0     b\n+     /                   One or more blanks must precede CECDYN.\n0     CECDYN\n0     b\n+     /                   One or more blanks must follow CECDYN.\n\n>     ----------------------------------------------------------------\n0     VERB=<verb>         <verb>: two byte character string\n0     ,PREFIX=<prefix>    <prefix>: maximum-of-3 byte character string\n0     ,FLG11=(<flg11>)\n      ,FLG21=(<flg21>)\n      ,FLG22=(<flg22>)    <flg11>/<flg21>/<flg22>: one or more 5 byte\n                          character strings, seperated by commas.  For\n                          example, FLG##=(<flg##>,<flg##>,<flg##>) .\n                          If only one <flg##> is specified, the outer\n                          parentheses may be omitted.\n0     ,TEXT=(<text unit>) <text unit>: either a maximum-of-5 byte\n                          character string, or a parenthesized pair\n                          consisting of a maximum-of-5 byte character\n                          string plus one of: literal delimited by\n                          quotes, A-type address, register (2)-(12).\n                          If only one <text unit> is specified, the\n                          outer parentheses must still be coded.\n                          Note: <text unit> is one or more text units,\n                          seperated by commas.  For example,\n                          TEXT=(<text unit>,<text unit>,<text unit>)\n0     ,LIST=NO            Default: LIST=YES\n      ,LIST=YES\n0     ,MF=(E,<remote addr>)\n                          <remote addr>: RX-type address, or register\n                          (1) or (2)-(12).\n\n>     ----------------------------------------------------------------\n-     The parameters are explained under the standard form of the\n      CECDYN macro instruction, with the following exception:\n-     MF=(E,<remote addr>)\n0       specifies the execute form of the CECDYN macro instruction.\n        The text units specified are built at the address specified in\n        the MF parameter.\n9SYS2.CEI.MACLIB(CECDYN)                                   08-MAR-1991\n.SKIPTEXT ANOP ,\n./ ADD NAME=CONTINUE 0100-10260-10260-1641-00011-00011-00000-MACLIB\n         MACRO ,\n&NAME    CONTINUE ,\n.* DATE.     28-JUL-1989\n.* REMARKS.  THIS MACRO WORKS WITH THE MACROS WRITTEN BY DON HIGGINS,\n.*          FOUND ON FILE 078 OF SHARE MVS GROUP MODS TAPE, V29 (04/84)\n.*  SEE CASE,DOCASE,DOMACRO,EQUBC,ELSE,ELSEIF,ESAC,ESACOD,FI,IF,OD;\n.*  AND BREAK.\n         GBLA  &DO(10),&DOSEQ(10),&DOLVL,&DOLAB\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n&NAME    B     DO&DO(&DOLVL)       GO IMMEDIATELY TO TEST PART OF LOOP\n         MEND  ,\n./ ADD NAME=DOMACRO  0100-10260-10260-1641-00122-00122-00000-MACLIB\n*          DATA SET AM010800   AT LEVEL 001 AS OF 10/28/75\n*          DATA SET AM010800   AT LEVEL 004 AS OF 08/14/74\n         MACRO\n         DO\n         GBLA  &DO(10),&DOSEQ(10),&DOLVL,&DOLAB\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n         LCLA  &N,&M,&S,&LAB1,&L,&I\n         LCLA  &UNTIL\n         LCLC  &OP,&OPR\n         LCLB  &TESTSW\n         EQUBC ,             DEFINE CONDITIONS, IF NOT ALREADY DEFINED\n.*             AUTHOR.   DON HIGGINS.\n.*             DATE.     03/27/74.\n.*             REMARKS.  MACRO TO ALLOW STRUCTURED PROGRAMMING USING\n.*                       IF, THEN, ELSE, AND DO UP TO TEN LEVELS DEEP\n.*                       AND NO BRANCH INSTRUCTIONS. SEE IF MACRO.\n         AIF   (&DOLVL EQ 10).ERR1\n&N       SETA  N'&SYSLIST\n         AIF   (&N LT 1).ERR2\n         AIF   ('&SYSLIST(1)' EQ 'END').END\n         AIF   ('&SYSLIST(1)' EQ 'FOREVER').WHILE\n         AIF   (&N LT 2).ERR2\n         AIF   ('&SYSLIST(1)' EQ 'WHILE').WHILE\n         AIF   ('&SYSLIST(1)' NE 'UNTIL').ERR3\n.UNTIL   ANOP\n&DOLVL   SETA  &DOLVL+1\n&UNTIL   SETA  &DOLAB+1\n&DOLAB   SETA  &DOLAB+2\n         B     DO&UNTIL\n         AGO   .COMM\n.WHILE   ANOP\n&DOLVL   SETA  &DOLVL+1\n&DOLAB   SETA  &DOLAB+1\n.COMM    ANOP\n&DOSEQ(&DOLVL) SETA 1\n&DO(&DOLVL) SETA &DOLAB\nDO&DOLAB EQU   *\n         AIF   (&LEVEL EQ 10).ERR1\n&LEVEL   SETA  &LEVEL+1\n&SEQ(&LEVEL) SETA 1\n&LAB     SETA  &LAB+1\n&ELSE(&LEVEL) SETA &LAB\n         AIF   ('&SYSLIST(1)' EQ 'FOREVER').EXIT\n&S       SETA  1\n.NEXTAND ANOP\n&TESTSW  SETB  0\n.TEST    ANOP\n&S       SETA  &S+1\n         AIF   (&S GT &N).ERR2\n&M       SETA  N'&SYSLIST(&S)\n         AIF   (&M LT 2).ERR3\n         AIF   (&M GT 5).ERR3\n&I       SETA  2\n&OPR     SETC  ''\n&OP      SETC  '&SYSLIST(&S,1)'\n         AIF   (&M GT 2).TESTOPR\n         &OP\n         AGO   .TESTEND\n.TESTOPR ANOP\n         AIF   ('&SYSLIST(&S,&I)'(1,1) NE '''').NOLIT\n&L       SETA  K'&SYSLIST(&S,&I)\n&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'(2,&L-2)\n         AGO   .NEXTOPR\n.NOLIT   ANOP\n&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'\n.NEXTOPR ANOP\n&I       SETA  &I+1\n         AIF   (&I EQ &M).TESTGEN\n&OPR     SETC  '&OPR'.','\n         AGO   .TESTOPR\n.TESTGEN ANOP\n         &OP   &OPR\n.TESTEND ANOP\n         AIF   (&TESTSW EQ 1).ORBC\n.AMBC    ANOP\n         BC    15-&SYSLIST(&S,&M),IF0&LAB\n.CONNECT ANOP\n&S       SETA  &S+1\n         AIF   (&S GT &N).CHKUNTL\n&M       SETA  N'&SYSLIST(&S)\n         AIF   (&M NE 1).ERR3  BAD CONNECTOR\n         AIF   ('&SYSLIST(&S)' EQ 'AND').NEXTAND\n         AIF   ('&SYSLIST(&S)' NE 'OR').ERR3  BAD CONNECTOR\n.NEXTOR   ANOP\n&LAB1    SETA  &LAB+1\n         B     IF0&LAB1  SKIP TEST IF LAST ONE TRUE\nIF0&LAB   EQU *          DO TEST IF LAST ONE FALSE\n&LAB     SETA  &LAB+2\n&ELSE(&LEVEL) SETA &LAB\n&TESTSW  SETB  1\n         AGO   .TEST\n.ORBC    ANOP\n         BC    15-&SYSLIST(&S,&M),IF0&LAB\nIF0&LAB1 EQU *\n         AGO   .CONNECT\n.CHKUNTL ANOP\n         AIF   (&UNTIL EQ 0).EXIT\n&LAB     SETA  &LAB+1\n         B     IF0&LAB\nIF0&ELSE(&LEVEL) EQU *\n&ELSE(&LEVEL) SETA &LAB\nDO&UNTIL EQU *\n         AGO   .EXIT\n.END     ANOP\n         AIF   (&N GT 1).ERR3\n         AIF   (&DOLVL EQ 0).ERR4\n         AIF   (&DOSEQ(&DOLVL) NE 1).ERR4\n&DOSEQ(&DOLVL) SETA 0\n         B     DO&DO(&DOLVL)\n&DOLVL   SETA  &DOLVL-1\nIF0&ELSE(&LEVEL) EQU *\n&LEVEL   SETA  &LEVEL-1\n         AGO   .EXIT\n.ERR1    MNOTE 8,'DO - LEVEL OVERFLOW'\n         AGO   .EXIT\n.ERR2    MNOTE 8,'DO - MISSING OPERAND'\n         AGO   .EXIT\n.ERR3    MNOTE 8,'DO - INVALID OPERAND'\n         AGO   .EXIT\n.ERR4    MNOTE 8,'DO - END OUT OF SEQUENCE'\n.EXIT    ANOP\n         MEND\n./ ADD NAME=ELSE     0100-10260-10260-1641-00046-00046-00000-MACLIB\n* COPIED FROM FILE 078 OF SHARE MVS GROUP MODS TAPE, V29 (04/84)\n*          DATA SET AM010700   AT LEVEL 003 AS OF 05/23/76\n         MACRO\n         ELSE  &OPT\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n         GBLA  &ELSEIF(10)\n.* AUTHOR.   DON HIGGINS.\n.* DATE.     03/27/74.\n.* REMARKS.  MACRO TO ALLOW STRUCTURED PROGRAMMING USING\n.*           IF, THEN, ELSE, AND DO UP TO TEN LEVELS DEEP\n.*           AND NO BRANCH INSTRUCTIONS. SEE IF MACRO.\n.* REV1 05/23/76 DSH - SUPPORT ELSEIF\n         AIF   (&LEVEL EQ 0).ERR0\n         AIF   (T'&OPT EQ 'O').BEGIN\n         AIF   ('&OPT' EQ 'BEGIN').BEGIN\n         AIF   ('&OPT' EQ 'END').END\n         AIF   ('&OPT' EQ 'CONTINUE').CONT\n         MNOTE 8,'ELSE - INVALID OPERAND'\n         AGO   .EXIT\n.BEGIN   ANOP  ,\n         AIF   (&SEQ(&LEVEL) GT 3).ERR1\n&LAB     SETA  &LAB+1\n         B     IF0&LAB\nIF0&ELSE(&LEVEL) EQU *\n&ELSE(&LEVEL) SETA &LAB\n&SEQ(&LEVEL) SETA 4\n         AGO .EXIT\n.END     ANOP  ,\n         AIF   (&SEQ(&LEVEL) NE 4).ERR2\n.DEQUE   ANOP  ,\nIF0&ELSE(&LEVEL) EQU *\n&LEVEL   SETA &LEVEL-1\n         AIF   (&ELSEIF(&LEVEL+1) EQ 1).DEQUE\n         AGO   .EXIT\n.CONT    ANOP  ,\n         AIF   (&SEQ(&LEVEL) GT 3).ERR3\n         AGO   .DEQUE\n.ERR0    MNOTE 8,'ELSE - MISSING IF'\n         AGO   .EXIT\n.ERR1    MNOTE 8,'ELSE BEGIN - OUT OF SEQUENCE'\n         AGO   .EXIT\n.ERR2    MNOTE 8,'ELSE END - OUT OF SEQUENCE'\n         AGO   .EXIT\n.ERR3    MNOTE 8,'ELSE CONTINUE - OUT OF SEQUENCE'\n.EXIT    ANOP  ,\n         MEND  ,\n./ ADD NAME=ELSEIF   0100-10260-10260-1641-00083-00083-00000-MACLIB\n* COPIED FROM FILE 078 OF SHARE MVS GROUP MODS TAPE, V29 (04/84)\n*          DATA SET AM013600   AT LEVEL 002 AS OF 05/23/76\n         MACRO ,\n         ELSEIF ,\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n         GBLA  &ELSEIF(10)\n         LCLA  &N,&M,&S,&LAB1,&L,&I\n         LCLC  &OP,&OPR\n         LCLB  &TESTSW\n.* AUTHOR.   DON HIGGINS.\n.* DATE.     05/23/76.\n.* REMARKS.  CONTROL STRUCTURE FOR CONDITIONAL EXECUTION.\n         AIF   (&LEVEL EQ 10).ERR1\n         ELSE  ,\n&LEVEL   SETA  &LEVEL+1\n&ELSEIF(&LEVEL) SETA 1\n&SEQ(&LEVEL) SETA 1\n&LAB     SETA  &LAB+1\n&ELSE(&LEVEL) SETA &LAB\n&N       SETA N'&SYSLIST\n.NEXTAND ANOP  ,\n&TESTSW  SETB  0\n.TEST    ANOP  ,\n&S       SETA  &S+1\n         AIF   (&S GT &N).ERR2\n&M       SETA  N'&SYSLIST(&S)\n         AIF   (&M EQ 1).TESTEND\n         AIF   (&M LT 2).ERR3\n         AIF   (&M GT 5).ERR4\n&I       SETA  2\n&OPR     SETC  ''\n&OP      SETC  '&SYSLIST(&S,1)'\n         AIF   (&M GT 2).TESTOPR\n         &OP                                                         ,\n         AGO   .TESTEND\n.TESTOPR ANOP  ,\n         AIF   ('&SYSLIST(&S,&I)'(1,1) NE '''').NOLIT\n&L       SETA  K'&SYSLIST(&S,&I)\n&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'(2,&L-2)\n         AGO   .NEXTOPR\n.NOLIT   ANOP  ,\n&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'\n.NEXTOPR ANOP  ,\n&I       SETA  &I+1\n         AIF   (&I EQ &M).TESTGEN\n&OPR     SETC  '&OPR'.','\n         AGO   .TESTOPR\n.TESTGEN ANOP  ,\n         &OP   &OPR                                                  ,\n.TESTEND ANOP  ,\n         AIF   (&TESTSW EQ 1).ORBC\n.AMBC    ANOP  ,\n         BC    15-&SYSLIST(&S,&M),IF0&LAB\n.CONNECT ANOP  ,\n&S       SETA  &S+1\n         AIF   (&S GT &N).EXIT\n&M       SETA  N'&SYSLIST(&S)\n         AIF   (&M NE 1).ERR5  BAD CONNECTOR\n         AIF   ('&SYSLIST(&S)' EQ 'AND').NEXTAND\n         AIF   ('&SYSLIST(&S)' NE 'OR').ERR5  BAD CONNECTOR\n.NEXTOR   ANOP ,\n&LAB1    SETA  &LAB+1\n         B     IF0&LAB1  SKIP TEST IF LAST ONE TRUE\nIF0&LAB   EQU *          DO TEST IF LAST ONE FALSE\n&LAB     SETA  &LAB+2\n&ELSE(&LEVEL) SETA &LAB\n&TESTSW  SETB  1\n         AGO   .TEST\n.ORBC    ANOP  ,\n         BC    15-&SYSLIST(&S,&M),IF0&LAB\nIF0&LAB1 EQU *\n         AGO   .CONNECT\n.ERR1    MNOTE 8,'IF - LEVEL OVERFLOW'\n         AGO   .EXIT\n.ERR2    MNOTE 8,'IF - MISSING TEST LIST'\n         AGO   .EXIT\n.ERR3    MNOTE 8,'IF - TEST LIST TOO SHORT'\n         AGO   .EXIT\n.ERR4    MNOTE 8,'IF - TEST LIST TOO LONG'\n         AGO   .EXIT\n.ERR5    MNOTE 8,'IF - INVALID CONNECTOR'\n.EXIT    ANOP  ,\n         MEND  ,\n./ ADD NAME=EQUBC    0100-10260-10260-1641-00031-00031-00000-MACLIB\n* MODIFIED 03-JUN-1989 TO ACT LIKE IEZBITS (MULTIPLE CALLS OK)\n*          DATA SET AM010900   AT LEVEL 001 AS OF 10/28/75\n*          DATA SET AM010900   AT LEVEL 002 AS OF 04/02/74\n         MACRO ,\n         EQUBC ,\n         GBLA  &EQUBC\n         AIF   (&EQUBC EQ 0).SETSW\n         MEXIT ,\n.SETSW   ANOP  ,\n&EQUBC   SETA  1\n         SPACE 2\nH        EQU   2\nL        EQU   4\nE        EQU   8\nNH       EQU   13\nNL       EQU   11\nNE       EQU   7\nO        EQU   1\nP        EQU   2\nM        EQU   4\nZ        EQU   8\nNP       EQU   13\nNM       EQU   11\nNZ       EQU   7\nNO       EQU   14\nEQ       EQU   8\nGT       EQU   2\nLT       EQU   4\nGE       EQU   11\nLE       EQU   13\n         MEND  ,\n./ ADD NAME=FI       0100-10260-10260-1641-00011-00011-00000-MACLIB\n*          DATA SET AM011000   AT LEVEL 001 AS OF 10/28/75\n*          DATA SET AM011000   AT LEVEL 001 AS OF 06/28/74\n         MACRO\n&N       FI\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n         AIF   (&SEQ(&LEVEL) NE 4).CONT\n&N       ELSE  END\n         MEXIT\n.CONT    ANOP\n&N       ELSE  CONTINUE\n         MEND\n./ ADD NAME=IF       0100-10260-10260-1641-00103-00103-00000-MACLIB\n* COPIED FROM FILE 078 OF SHARE MVS GROUP MODS TAPE, V29 (04/84)\n*          DATA SET AM010500   AT LEVEL 002 AS OF 05/23/76\n*          DATA SET AM010500   AT LEVEL 001 AS OF 10/28/75\n*          DATA SET AM010500   AT LEVEL 001 AS OF 04/01/74\n         MACRO ,\n         IF    ,\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n         GBLA  &ELSEIF(10)\n         LCLA  &N,&M,&S,&LAB1,&L,&I\n         LCLC  &OP,&OPR\n         LCLB  &TESTSW\n         EQUBC ,             DEFINE CONDITIONS, IF NOT ALREADY DEFINED\n.* AUTHOR.   DON HIGGINS.\n.* DATE.     03/27/74.\n.* REMARKS.  MACRO TO ALLOW STRUCTURED PROGRAMMING USING\n.*           IF, THEN, ELSE, AND DO UP TO TEN LEVELS DEEP\n.*           AND NO BRANCH INSTRUCTIONS.\n.*\n.*           EXAMPLE FORM.\n.*               SAMPLE  SUBENTRY\n.*                       IF (CLI,FLAG,TRUE,EQ)\n.*                       THEN BEGIN\n.*                            DO  WHILE,(CLC,A,B,NE)\n.*                               PERFORM R100PROC,R190EXIT\n.*                            DO END\n.*                       THEN END\n.*                       ELSE BEGIN\n.*                            PERFORM R200LIST,R290EXIT\n.*                       ELSE END\n.*                       IF (CLI,SW,TRUE,EQ),AND,(SRC,R1,E)\n.*                            PERFORM R300RPT,R390EXIT\n.*                       ELSE CONTINUE\n.*                       SUBEXIT\n         AIF   (&LEVEL EQ 10).ERR1\n&LEVEL   SETA  &LEVEL+1\n&ELSEIF(&LEVEL) SETA 0\n&SEQ(&LEVEL) SETA 1\n&LAB     SETA  &LAB+1\n&ELSE(&LEVEL) SETA &LAB\n&N       SETA N'&SYSLIST\n.NEXTAND ANOP\n&TESTSW  SETB  0\n.TEST    ANOP\n&S       SETA  &S+1\n         AIF   (&S GT &N).ERR2\n&M       SETA  N'&SYSLIST(&S)\n         AIF   (&M EQ 1).TESTEND\n         AIF   (&M LT 2).ERR3\n         AIF   (&M GT 5).ERR4\n&I       SETA  2\n&OPR     SETC  ''\n&OP      SETC  '&SYSLIST(&S,1)'\n         AIF   (&M GT 2).TESTOPR\n         &OP\n         AGO   .TESTEND\n.TESTOPR ANOP\n         AIF   ('&SYSLIST(&S,&I)'(1,1) NE '''').NOLIT\n&L       SETA  K'&SYSLIST(&S,&I)\n&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'(2,&L-2)\n         AGO   .NEXTOPR\n.NOLIT   ANOP\n&OPR     SETC  '&OPR'.'&SYSLIST(&S,&I)'\n.NEXTOPR ANOP\n&I       SETA  &I+1\n         AIF   (&I EQ &M).TESTGEN\n&OPR     SETC  '&OPR'.','\n         AGO   .TESTOPR\n.TESTGEN ANOP\n         &OP   &OPR\n.TESTEND ANOP\n         AIF   (&TESTSW EQ 1).ORBC\n.AMBC    ANOP\n         BC    15-&SYSLIST(&S,&M),IF0&LAB\n.CONNECT ANOP\n&S       SETA  &S+1\n         AIF   (&S GT &N).EXIT\n&M       SETA  N'&SYSLIST(&S)\n         AIF   (&M NE 1).ERR5  BAD CONNECTOR\n         AIF   ('&SYSLIST(&S)' EQ 'AND').NEXTAND\n         AIF   ('&SYSLIST(&S)' NE 'OR').ERR5  BAD CONNECTOR\n.NEXTOR   ANOP\n&LAB1    SETA  &LAB+1\n         B     IF0&LAB1  SKIP TEST IF LAST ONE TRUE\nIF0&LAB   EQU *          DO TEST IF LAST ONE FALSE\n&LAB     SETA  &LAB+2\n&ELSE(&LEVEL) SETA &LAB\n&TESTSW  SETB  1\n         AGO   .TEST\n.ORBC    ANOP\n         BC    15-&SYSLIST(&S,&M),IF0&LAB\nIF0&LAB1 EQU *\n         AGO   .CONNECT\n.ERR1    MNOTE 8,'IF - LEVEL OVERFLOW'\n         AGO   .EXIT\n.ERR2    MNOTE 8,'IF - MISSING TEST LIST'\n         AGO   .EXIT\n.ERR3    MNOTE 8,'IF - TEST LIST TOO SHORT'\n         AGO   .EXIT\n.ERR4    MNOTE 8,'IF - TEST LIST TOO LONG'\n         AGO   .EXIT\n.ERR5    MNOTE 8,'IF - INVALID CONNECTOR'\n.EXIT    ANOP\n         MEND\n./ ADD NAME=OD       0100-10260-10260-1641-00006-00006-00000-MACLIB\n*          DATA SET AM011200   AT LEVEL 001 AS OF 10/28/75\n*          DATA SET AM011200   AT LEVEL 001 AS OF 07/01/74\n         MACRO\n&N       OD\n&N       DO    END\n         MEND\n./ ADD NAME=THEN     0100-10260-10260-1641-00030-00030-00000-MACLIB\n*          DATA SET AM010600   AT LEVEL 001 AS OF 10/28/75\n*          DATA SET AM010600   AT LEVEL 001 AS OF 04/01/74\n         MACRO\n         THEN  &OPT\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n.*             AUTHOR.   DON HIGGINS.\n.*             DATE.     03/27/74.\n.*             REMARKS.  MACRO TO ALLOW STRUCTURED PROGRAMMING USING\n.*                       IF, THEN, ELSE, AND DO UP TO TEN LEVELS DEEP\n.*                       AND NO BRANCH INSTRUCTIONS. SEE IF MACRO.\n         AIF   (&LEVEL EQ 0).ERR0\n         AIF   ('&OPT' EQ 'BEGIN').BEGIN\n         AIF   ('&OPT' EQ 'END').END\n         MNOTE 4,'THEN - INVALID OPERAND - IGNORED'\n         AGO   .EXIT\n.BEGIN   ANOP\n         AIF   (&SEQ(&LEVEL) NE 1).ERR1\n&SEQ(&LEVEL) SETA 2\n         AGO   .EXIT\n.END     ANOP\n         AIF   (&SEQ(&LEVEL) NE 2).ERR2\n&SEQ(&LEVEL) SETA 3\n         AGO   .EXIT\n.ERR0    MNOTE 8,'THEN - MISSING IF'\n         AGO   .EXIT\n.ERR1    MNOTE 4,'THEN BEGIN - OUT OF SEQUENCE'\n         AGO   .EXIT\n.ERR2    MNOTE 4,'THEN END - OUT OF SEQUENCE'\n.EXIT    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OD": {"ttr": 6401, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10&\\x0f\\x01\\x10&\\x0f\\x16A\\x00\\x06\\x00\\x06\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-09-17T00:00:00", "modifydate": "2010-09-17T16:41:00", "lines": 6, "newlines": 6, "modlines": 0, "user": "MACRO"}, "text": "*          DATA SET AM011200   AT LEVEL 001 AS OF 10/28/75\n*          DATA SET AM011200   AT LEVEL 001 AS OF 07/01/74\n         MACRO\n&N       OD\n&N       DO    END\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "THEN": {"ttr": 6403, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10&\\x0f\\x01\\x10&\\x0f\\x16A\\x00\\x1e\\x00\\x1e\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-09-17T00:00:00", "modifydate": "2010-09-17T16:41:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "MACRO"}, "text": "*          DATA SET AM010600   AT LEVEL 001 AS OF 10/28/75\n*          DATA SET AM010600   AT LEVEL 001 AS OF 04/01/74\n         MACRO\n         THEN  &OPT\n         GBLA  &ELSE(10),&SEQ(10),&LEVEL,&LAB\n.*             AUTHOR.   DON HIGGINS.\n.*             DATE.     03/27/74.\n.*             REMARKS.  MACRO TO ALLOW STRUCTURED PROGRAMMING USING\n.*                       IF, THEN, ELSE, AND DO UP TO TEN LEVELS DEEP\n.*                       AND NO BRANCH INSTRUCTIONS. SEE IF MACRO.\n         AIF   (&LEVEL EQ 0).ERR0\n         AIF   ('&OPT' EQ 'BEGIN').BEGIN\n         AIF   ('&OPT' EQ 'END').END\n         MNOTE 4,'THEN - INVALID OPERAND - IGNORED'\n         AGO   .EXIT\n.BEGIN   ANOP\n         AIF   (&SEQ(&LEVEL) NE 1).ERR1\n&SEQ(&LEVEL) SETA 2\n         AGO   .EXIT\n.END     ANOP\n         AIF   (&SEQ(&LEVEL) NE 2).ERR2\n&SEQ(&LEVEL) SETA 3\n         AGO   .EXIT\n.ERR0    MNOTE 8,'THEN - MISSING IF'\n         AGO   .EXIT\n.ERR1    MNOTE 4,'THEN BEGIN - OUT OF SEQUENCE'\n         AGO   .EXIT\n.ERR2    MNOTE 4,'THEN END - OUT OF SEQUENCE'\n.EXIT    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT838/FILE838.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT838", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}