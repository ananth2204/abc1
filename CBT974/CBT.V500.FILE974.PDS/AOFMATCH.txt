        TITLE  'AOFMATCH - Find a match in AOF TABLE'
*PROCESS  USING(NOWARN)
AOFMATCH CSECT ,
AOFMATCH AMODE 31
AOFMATCH RMODE ANY
***********************************************************************
*---------------------------------------------------------------------*
*- register usage                                                    -*
*---------------------------------------------------------------------*
R0      EQU    0                  work reg
R1      EQU    1                  work and parm reg
R2      EQU    2                  work reg
R3      EQU    3                  work reg
R4      EQU    4                  work reg
R5      EQU    5                  pointer to end of the mdb
R6      EQU    6                  next mdb pointer
R7      EQU    7
R8      EQU    8
R9      EQU    9
R10     EQU    10
R11     EQU    11                 dynamic storage base
R12     EQU    12                 module base
R13     EQU    13                 linkage
R14     EQU    14                 linkage
R15     EQU    15                 linkage
***********************************************************************
*                                                                     *
***********************************************************************
* begin linkage convention
       BAKR    R14,0              save regs
       L       R10,0(,R1)         Load pointer
       USING   AOFCB,R10
       L       R9,4(,R1)          Load pointer
       USING   MSGCB,R9
       LA      R12,0(R15,0)       base and address regs
       USING   AOFMATCH,R12       addressability
       MODID   ,                  eye catcher and date
       STORAGE OBTAIN,LENGTH=DYNL get dynamic storage
       LA      R11,0(0,R1)        use R11 as dyn base
       USING   DYNAREA,R11        map model over dynamic area
       LA      R13,SAVEAREA       put save area addr in R13
       MVC     4(4,R13),=C'F1SA'  set acro in save area
       LA      R2,INITVALC        address of dynamic area model
       L       R3,=A(INITVALL)    length of dynamic area
       LA      R4,INITVALS        address of dynamic area
       LR      R5,R3              length of dynamic area
       MVCL    R4,R2              copy model to dynamic area
       L       R7,TRUTABL          get address of table.
       LTR     R7,R7               check it out
       BZ      AOFMEXIT            no table, no work to do.
*      TM      MSGCSUPB,MSGCSSSI+MSGCSWTO+MSGCSMPF Suppressed?
*      BNZ     AOFMEXIT            Yes, then leave
       TM      MSGCSUPB,MSGCSAUT   Automation specified?
       BNO     AOFMEXIT            No, then leave
       SPACE   1
***********************************************************************
* If we get here there is a (valid) AOF table.
* The validity of the table is determined at AOF startup/table reload
* time.
* R7 will serve as a base register for the AOF table current entry
***********************************************************************
***********************************************************************
* Isolate the message id and preserve it for future examination.      *
***********************************************************************
       LA      R2,MSGENTRY+2       Get address of text
       ST      R2,STRSTART         and remember for AOFPARS later
       MVI     MSGID,C' '          Blank message id
       MVC     MSGID+1(L'MSGID-1),MSGID
       LA      R4,MSGID            Location to store message id
       LA      R3,L'MSGID          Get max length of MSGID
       CH      R3,MSGENTRY         Greater than length of message?
       BL      TXTLOOP             No, then procede
       LH      R3,MSGENTRY         Yes, load length of message
TXTLOOP DS     0H                  Copy message ID from message
       CLI     0(R2),C' '          Blank?
       BE      TXTBLANK            Yes, end of message id
       MVC     0(1,R4),0(R2)       No, move to MSGID
       LA      R2,1(,R2)           Bump source pointer
       LA      R4,1(,R4)           Bump target pointer
       BCT     R3,TXTLOOP          Loop
TXTBLANK DS    0H
       LH      R1,MSGENTRY         get text object length
       ST      R1,STRLEN           save length for later
************************************************************
* Here is where we examine the text of the WTO to see if we should
* take action.
* The address of the table is in TRUTABL,
* R6: points to current table entry, during test processing.
************************************************************
       LA      R1,MSGID
       ST      R1,BSCANPRM1
       LA      R1,TRUBSTS
       ST      R1,BSCANPRM2
       LA      R1,BSCANPRM
       CALL    AOFBSCAN
       LTR     R15,R15
       BZ      TSTALLMG                  0 not found, look msg=*
       L       R7,0(,R1)                point at first AOFNTRY
       USING   AOFNTRY,R7
       B       MATCHMSG                  4 found, do entries
*
TSTALLMG DS    0H
       ICM     R7,B'1111',TRUALMS       point at MSG=* entries
       BZ      AOFMEXIT                 if none, then all done
       OI      AOFMFLG,X'10'            indicate MSG=* processing
       B       MATCHMSG                 go process all entries
       SPACE   2
***********************************************************************
* We come here when a match has been found in the message id section  *
* of an AOF table entry. The processing continues with the performing *
* of any tests that needs to be issued. If all tests are matched,     *
* then branch to the PERFACT routine, which will perform any actions  *
* required. If the tests are not met, continue searching the table as *
* there may be another match.                                         *
***********************************************************************
MATCHMSG DS    0H
       ST      R7,CURTABAD              save current entry addr
       L       R6,AOFTESTP               load up test entry.
       USING   ATSNTRY,R6
TESTLOOP DS    0H                        loop for test entries
       LTR     R6,R6                     any more test entries ?
       BZ      TESTSUCC                  nope, all tests must be oK
       L       R1,ATSWORD          load substr or word number
       ST      R1,WORD1            and remember it.
       L       R1,ATSLNGTH         load length
       ST      R1,WORD2
       MVC     WORDSEPS(4),ATSSEPS load word separators.
***********************************************************************
* We must determine the test type                                     *
***********************************************************************
       CLC     ATSTYPE,=CL2'W '    is it a word ?
       BE      WORDTYPE            yup, go process it
       CLC     ATSTYPE,=CL2'WX'    is it a word exclusion ?
       BE      WORDTYPE            yup, go process it
       CLC     ATSTYPE,=CL2'P '    is it a substring ?
       BE      SUBSTYPE            yup, go process it.
       CLC     ATSTYPE,=CL2'PX'    is it a substring exclusion ?
       BE      SUBSTYPE            yup, go process it.
       CLC     ATSTYPE,=CL2'S '    is it a substring ?
       BE      SUBSTYPE            yup, go process it.
       CLC     ATSTYPE,=CL2'SX'    is it a substring exclusion ?
       BE      SUBSTYPE            yup, go process it.
       CLC     ATSTYPE,=CL2'L '    is it a line number?
       BE      LINETYPE            yup, go process it.
       CLC     ATSTYPE,=CL2'D '    is it a descriptor code ?
       BE      DESCTYPE            yup, go process it.
       B       TESTTBAD            no, it is wrong
       SPACE   1
TESTTBAD DS    0H                  invalid test type
* Invalid test type, ** PROBLEM **
       WTO     'AOF9202E INVALID TEST TYPE- IGNORING MESSAGE ID'
       B       AOFMEXIT            stop processing on failure
       EJECT   ,
***********************************************************************
* We come here when we have a word test. The routine will perform the
* following procedures.
*                                                                     *
* 1) Use AOFPARS to parse the message, based on the separator chars   *
*    specified in the table.                                          *
* 2) Perform the test based on the desired word, using the length     *
*    specified in the table.                                          *
* 3) Either go to testfail, or perform another test.                  *
*                                                                     *
***********************************************************************
WORDTYPE DS    0H
       L       R8,STRSTART       get address of string
       ST      R8,PARS1          theres operand number 1
*
       MVC     PARS2(4),STRLEN    length of wto messages
*
       LR      R8,R2
       LR      R5,R3
       LA      R2,PARARRAY
       L       R3,=A(LPARRAY)
       SLR     R0,R0
       SLR     R1,R1
       ICM     R1,B'1000',=C' '
       MVCL    R2,R0
       LR      R2,R8
       LR      R3,R5
*      MVI     PARARRAY,X'40'
*      MVC     PARARRAY+1(255),PARARRAY      blank out PARARRAY
*      MVC     PARARRAY+256(LPARRAY-256),PARARRAY
       MVC     PARARRAY(2),=H'20'           max of 20 tokens.
       LA      R8,PARARRAY       PARARRAY is third parameter
       ST      R8,PARS3          store in parm list.
*
       LA      R8,WORDSEPS       use word separators on test directive
       ST      R8,PARS4          and store in fourth word in parm list.
*
       LA      R1,PARSPARM
       CALL    AOFPARS           ** p a r s e   i t   **
*      MVC     PARARRAY(2),=H'1'
       LH      R8,PARARRAY      how many did we get back
       C       R8,WORD1         see which one was specified in the
*                                test parameter list.
       BL      WORDFAIL          not enough words.. fail this test.
       LA      R8,PARARRAY+2    point to word number 1
       L       R5,WORD1          get word  requested
       BCTR    R5,0
       SLL     R5,6              multiply by 64
       LA      R8,0(R5,R8)       point to token
       ST      R8,TOKADDR       remember where token was found.
***********************************************************************
* At this point, TOKADDR contains the address of the token (word) that
* was located by AOFPARS. We will compare this word, for n characters
* against what was specified in the AOF table. If matched, great
* if not, test has failed.
*
* We need to load up the match text as specified in the AOF table.
***********************************************************************
       LH      R4,ATSTXTL       get matching text length
***********************************************************************
* Note, the matching text string is at 20(R6) where R6 points to the
* test parameter entry (tpe).
***********************************************************************
       L       R5,TOKADDR       load token address
       BCTR    R4,0             -1 for how hardware works
       EX      R4,COMPSTR       do compare !
       BE      WORDSUCC        word matched !!
       BNE     WORDFAIL         word didnt match !!!
COMPSTR DS     0H
       CLC     0(*-*,R5),ATSTXT   ** executed **
************************************************************
* We come here if the word matched, implying that this particular
* test was successfull. Now we will go see if there are any more
* tests..
************************************************************
WORDSUCC DS    0H
       CLI     ATSTYPE+1,C'X'   is it an exclusion test?
       BE      TESTFAIL         yes, so the test failed
       L       R6,ATSNXT        get next test entry
       B       TESTLOOP         and try again...
*
WORDFAIL DS    0H
       CLI     ATSTYPE+1,C'X'   is it an exclusion test?
       BNE     TESTFAIL         no, it really is a failure
       L       R6,ATSNXT        get next test entry
       B       TESTLOOP         and try again...
*
***********************************************************************
* The user requested a substring type of test on the message.         *
* The routine will provide that test.                                 *
* The test is:                                                        *
* substr(mvswto,start in AOF,length in AOF) ?= matchtex in AOF.       *
*                                                                     *
***********************************************************************
SUBSTYPE DS    0H
       L       R5,STRSTART      get start of mvs message.
       L       R4,WORD1         get start as specified in AOF.
       BCTR    R4,0             -1 to get correct character.
       LA      R5,0(R4,R5)      point to start of substring in msg
       L       R4,WORD2         get length for compare.
       BCTR    R4,0             -1 for execute
       EX      R4,COMPSTR2      perform the substring compare.
       BE      SUBSSUCC         they matched! -> test succeded.
       BNE     SUBSFAIL         no matched- subs failed
***********************************************************************
* Note that the match text is in 20(R6) where R6 points to the current
* AOF table.
***********************************************************************
COMPSTR2 DS    0H
       CLC     0(*-*,R5),ATSTXT   ** executed **
***********************************************************************
* We get here if the substring test was successfull. AOF will
* check the next entry in the table and attempt the next test
***********************************************************************
SUBSSUCC DS    0H
       CLI     ATSTYPE+1,C'X'   is it an exclusion test?
       BE      TESTFAIL         yes, so the test fails
       L       R6,ATSNXT        get next test entry
       B       TESTLOOP         and try again...
*
***********************************************************************
* We come here if this substring test has failed. If this is the case
* then we will continuing search AOF table entries in hopes of again
* finding the msg id.
***********************************************************************
SUBSFAIL DS    0H
       CLI     ATSTYPE+1,C'X'   is it an exclusion test?
       BNE     TESTFAIL         no, it really is a failure
       L       R6,ATSNXT        get next test entry
       B       TESTLOOP         and try again...
       SPACE   2
***********************************************************************
* The user requested a line type of test on the message.              *
* The routine will provide that test.                                 *
***********************************************************************
LINETYPE DS    0H
       CLC     ATSLINE,MSGLCNT  Is it more than the lines available?
       BH      TESTFAIL         No - line failed
***********************************************************************
* We get here if the line test was successfull.
* AOF will check the next entry in the table and attempt the next test
***********************************************************************
LINESUCC DS    0H
       LA      R3,MSGENTRY         Get address of text
       L       R1,ATSLINE          Get offset ...
       S       R1,=F'1'            ... to the line wanted
       SLL     R1,7                multiply by 128
       LA      R2,2(R1,R3)         Point to MLWTO line specified
       ST      R2,STRSTART         Save text address for later
       LH      R1,0(R1,R3)         get text length
       ST      R1,STRLEN           save length for later
       L       R6,ATSNXT        get next test entry
       B       TESTLOOP         and try again...
*
***********************************************************************
* The user requested a desc type of test on the message.              *
* The routine will provide that test.                                 *
***********************************************************************
DESCTYPE DS    0H
       SLR     R1,R1            zero out for IC
       SLR     R2,R2            zero out for IC
       IC      R1,ATSDESC1      Get first desc byte from table
       IC      R2,ATSDESC2      Get second desc byte from table
       EX      R1,DESCTM1       Test desc codes
       BNZ     DESCSUCC
       EX      R2,DESCTM2       Test desc codes
       BNZ     DESCSUCC
       B       TESTFAIL         No - desc failed
DESCTM1  DS    0H
       TM      MSGDESC1,X'00'    Was this a desc code I care about?
DESCTM2  DS    0H
       TM      MSGDESC2,X'00'    Was this a desc code I care about?
***********************************************************************
* We get here if the desc test was successfull.
* AOF will check the next entry in the table and attempt the next test
***********************************************************************
DESCSUCC DS    0H
       L       R6,ATSNXT        get next test entry
       B       TESTLOOP         and try again...
*
       SPACE   2
***********************************************************************
* We come here if a test fails. if this should happen we continue     *
* searching through all AOF table entries for another match on the    *
* msgid.                                                              *
***********************************************************************
TESTFAIL DS    0H
       B       RUNTABL          go test another AOF entry
*
***********************************************************************
* We come here if all tests have been succussfull for this table entry*
* We set the MLWTO line back to the first line                        *
* AOF will go and perform the action requested and continue searching *
* the table for any additional entries.                               *
***********************************************************************
TESTSUCC DS    0H
       LA      R1,MSGENTRY+2       Get address of first line of text
       ST      R1,STRSTART         store it
       LH      R1,MSGENTRY         get text length
       ST      R1,STRLEN           save length for later
       B       PERFACT
       DROP    R6
*
************************************************************
* We come here when we have found a WTO in the table, and the tests
* specified for the entry have been met. At that time, we perform
* the action specified in the ACTION= parameter for the entry.
*
* Processing continues as follows:
*
* 1) If matchlim processing has been specified (matchlim > 0) deduct
*    one from matchlim. If matchlim = 999999 then don't bother. If
*    matchlim = 0 then do not perform the requested function after all.
*
* 2) We identifiy the action specified and branch to the appropriate
*    routine.
*    Note that R7 points to the entry in the AOF table.
*
************************************************************
PERFACT DS     0H
       L       R2,AOFMLIM                pick up matchlim value.
       C       R2,=F'999999'             was matchlim specified ?
       BE      PASTMLIM                  no - dont bother deducting
       LTR     R2,R2                     is count already zero ?
       BZ      AOFMNACT                  no, take no action...
       BCTR    R2,0                      Take  one away from matchlim
       ST      R2,AOFMLIM                and store new matchlim back
***********************************************************************
* Here, we have survived matchlim processing, and are ready to take   *
* on the action specified in the ACTION= parameter of the AOF table   *
***********************************************************************
PASTMLIM DS    0H
       CLC     AOFACTN,=CL8'NONE'       is this a dummy request?
       BE      GETNEXT                  yes, so we have done it
*
       CLC     AOFACTN,=CL8'REPLY'       request to reply ?
       BE      AOFMRPLY
       CLC     AOFACTN,=CL8'OSCMD'      request for an OS command ?
       BE      AOFMCMND
       CLC     AOFACTN,=CL8'OSCMDT'     request for an OS command ?
*                                       in test mode ?
       BE      AOFMCMDT
*
       CLC     AOFACTN,=CL8'POST'       is this request for post
       BE      AOFMPOST
*
       WTO     'AOF9203E INVALID TEXT SPECIFICATION'
       B       AOFMEXIT                 SCOTTY, beam me up.
***********************************************************************
* Here, the matchlim test has determined a zero matchlim              *
***********************************************************************
AOFMNACT DS    0H
       B       GETNEXT                 get next AOF table entry
***********************************************************************
* Here, the OSCMDT was specified so set the test mode bit             *
***********************************************************************
AOFMCMDT DS    0H
       OI      AOFMFLG,X'20'           indicate test mode
       B       AOFMCMND
************************************************************
* Here is the entry point for issuing OS commands based on WTO's.
************************************************************
AOFMCMND DS    0H
       LA      R2,MVSCMDTX       starting point for mvs cmd
       MVI     MVSCMDTX,X'40'         blank out the
       MVC     MVSCMDTX+1(L'MVSCMDTX-1),MVSCMDTX command buffer
       LA      R3,AOFACT         start point for MVS directive
       LH      R4,AOFACTL        length of message
CMNDLOOP DS    0H
       LTR     R4,R4            check to see if any chars remain
*                               in buffer. this could have happened
*                               if the formatting option had been
*                               the last thing in the text operand
       BZ      ISSUECMD
       CLI     0(R3),C'\'       significance character on?
       BE      SIGON             well.. it is now.
       MVC     0(1,R2),0(R3)    Move in character
       LA      R2,1(,R2)        Bump CMD buffer ptr
       LA      R3,1(,R3)        Bump AOF CMD ptr
       BCT     R4,CMNDLOOP      Loop through AOF CMD
       B       ISSUECMD          go do the command
*
************************************************************
* We come here when we find the '\' directive in the AOF table
* entry for this message. This means we have some work to do.
************************************************************
SIGON  DS      0H
       LA      R3,1(,R3)          point to next character
       CLI     0(R3),C'A'         looking for ASID ?
       BE      SIGONA             yup, go do it !!
       CLI     0(R3),C'J'         looking for jobname ?
       BE      SIGONJ             yup, go do it !!
       CLI     0(R3),C'P'         looking for position character?
       BE      SIGONP             yup.. got it
       CLI     0(R3),C'S'         check its synonym
       BE      SIGONP             yup.. got it
       CLI     0(R3),C'W'         looking for some 'word' ?
       BE      SIGONW             yup, go do it !!
       CLI     0(R3),C'L'         looking for specific line
       BE      SIGONL             yup, go do it !!
       B       SIGWRONG           no, invalid '\' directive...
       SPACE   2
SIGONA DS      0H
       CLI     1(R3),C'\'         check for correct format.
       BNE     SIGWRONGA
*
       ICM     R0,B'0011',MSGMASID     Load ASID
       BZ      SIGWRONGA               No ASID, Oh Well
       SRDL    R0,4                    move nybble into R1
       SRL     R1,4                    move over one nybble
       SRDL    R0,4                    move nybble into R1
       SRL     R1,4                    move over one nybble
       SRDL    R0,4                    move nybble into R1
       SRL     R1,4                    move over one nybble
       SRDL    R0,4                    move nybble into R1
       SRL     R1,4                    move over one nybble
       ST      R1,0(,R2)               Save in command
       OC      0(4,R2),=X'F0F0F0F0'    convert to zoned
       TR      0(4,R2),TRHEXTBL        TR 0-9,A-F
       LA      R2,4(,R2)               next char in cmd buffer
       LA      R3,2(,R3)                move past \ stuff in
*                                       AOF table
       SH      R4,=H'3'                Length remaining in entry
       LTR     R4,R4
       BM      SIGWRONGA
       B       CMNDLOOP
SIGWRONGA DS    0H
       WTO     'AOF9204E ERROR IN DEFINITION (A) WTO MSG'
       B       AOFMEXIT
*
       SPACE   2
SIGONJ DS      0H
       CLI     1(R3),C'\'         check for correct format.
       BNE     SIGWRONGJ1
*
       LA      R8,MSGMJOBN        Load jobname ptr
       LA      R1,MSGMJOBN+L'MSGMJOBN-1 Point end of jobname
SIGONJ1 DS     0H
       CLI     0(R1),C' '         Did we find last character?
       BNE     SIGONJ2            Yes, leave loop
       BCTR    R1,0               decrement R1
       CR      R1,R8              Have we reached the begining?
       BNL     SIGONJ1            loop
       LA      R1,MSGMJOBN        Jobname is all blanks
SIGONJ2 DS     0H
       SR      R1,R8              Get length - 1
       LA      R1,1(,R1)          Get length
       ST      R1,SIGCOUNT        Save count
************************************************************
* At this point, we have the parameters needed for jobname
* substitution in the OS command to be issued.
************************************************************
       L       R1,SIGCOUNT              Get count for execute
       BCTR    R1,0                     sub one for EX
       EX      R1,MOVESIGJ              Move the stuff...
       B       ARJ2
MOVESIGJ DS    0H
       MVC     0(*-*,R2),0(R8)   ** executed **
ARJ2   DS      0H
       A       R2,SIGCOUNT              Next char in cmd buffer
       LA      R3,2(,R3)                Move past \ stuff in
*                                       AOF table
       SH      R4,=H'3'
       LTR     R4,R4
       BM      SIGWRONGJ4
       B       CMNDLOOP
SIGWRONGJ1 DS   0H
       WTO     'AOF9215E ERROR IN DEFINITION (J) WTO MSG'
       B       AOFMEXIT
SIGWRONGJ3 DS   0H
       WTO     'AOF9235E ERROR IN DEFINITION (J) WTO MSG'
       B       AOFMEXIT
SIGWRONGJ4 DS   0H
       WTO     'AOF9245E ERROR IN DEFINITION (J) WTO MSG'
       B       AOFMEXIT
*
       SPACE   2
SIGONP DS      0H
       CLI     4(R3),C','         Check for correct format.
       BNE     SIGWRONGP1
       CLI     7(R3),C'\'         Check for closing terminator.
       BNE     SIGWRONGP2         Oh well...
*
       LA      R1,1(,R3)
       ST      R1,CVTPARM1
       LA      R1,=H'3'
       ST      R1,CVTPARM2
       LA      R1,WORKAREA
       ST      R1,CVTPARM3
       LA      R1,CVTPARMS        Set address
       CALL    AOFCVTDB           ** convert **
       LTR     R1,R1
       BZ      SIGWRONGP3         Invalid data
       ST      R1,SIGSTART        Remember starting point
       LA      R1,5(,R3)          Get new start point for convert
       ST      R1,CVTPARM1
       LA      R1,=H'2'
       ST      R1,CVTPARM2
       LA      R1,WORKAREA
       ST      R1,CVTPARM3
       LA      R1,CVTPARMS        Set address
       CALL    AOFCVTDB           ** convert **
       LTR     R1,R1
       BZ      SIGWRONGP4         Invalid data
       ST      R1,SIGCOUNT        Save count
************************************************************
* At this point, we have the parameters needed for text
* substitution in the os command to be issued.
************************************************************
       L       R1,STRLEN        Calculate ...
       S       R1,SIGSTART      ... length ...
       AH      R1,=H'1'         ...... remaining
       LTR     R1,R1            Anything left?
       BNP     SIGWRONGP7       No, put out error message
       C       R1,SIGCOUNT      Is it less than what was asked for
       BNH     SKIP_LOAD        Yes, skip load
       L       R1,SIGCOUNT              Get count for execute
SKIP_LOAD DS   0H
       ST      R1,SIGCOUNT      Save length
       BCTR    R1,0                     Less one for EX
       L       R8,STRSTART              Get start address of text
       L       R5,SIGSTART              Get starting offset
       C       R5,STRLEN                Check against length
       BNH     BUMP_STRPTR              If not too high, bump pointer
       B       SIGWRONGP5               If too high, forget it
BUMP_STRPTR DS 0H
       LA      R8,0(R8,R5)              Point to starting point in text
*                                       for move.
       BCTR    R8,0                     Get exact correct postition
       EX      R1,MOVESIG               Move the stuff...
       B       AR2
MOVESIG DS     0H
       MVC     0(*-*,R2),0(R8)    ** executed **
AR2    DS      0H
       A       R2,SIGCOUNT              Next char in cmd buffer
       LA      R3,8(,R3)                Move past \ stuff in AOF table
       SH      R4,=H'9'
       LTR     R4,R4
       BM      SIGWRONGP6
       B       CMNDLOOP
SIGWRONGP1 DS    0H
       WTO     'AOF92061E ERROR IN DEFINITION (S) WTO MSG'
       B       AOFMEXIT
SIGWRONGP2 DS    0H
       WTO     'AOF92062E ERROR IN DEFINITION (S) WTO MSG'
       B       AOFMEXIT
SIGWRONGP3 DS    0H
       WTO     'AOF92063E ERROR IN DEFINITION (S) WTO MSG'
       B       AOFMEXIT
SIGWRONGP4 DS    0H
       WTO     'AOF92064E ERROR IN DEFINITION (S) WTO MSG'
       B       AOFMEXIT
SIGWRONGP5 DS    0H
       WTO     'AOF92065E ERROR IN DEFINITION (S) WTO MSG'
       B       AOFMEXIT
SIGWRONGP6 DS    0H
       WTO     'AOF92066E ERROR IN DEFINITION (S) WTO MSG'
       B       AOFMEXIT
SIGWRONGP7 DS    0H
       WTO     'AOF92067E ERROR IN DEFINITION (S) WTO MSG'
       B       AOFMEXIT
*
SIGONW DS      0H
       CLI     7(R3),C'\'               Termination for w directive
       BNE     SIGWBAD                 Shucks
       MVC     SEPCHAR(4),1(R3)        Get separator characters
       LA      R1,5(,R3)               Get start for convert rtn
       ST      R1,CVTPARM1
       LA      R1,=H'2'
       ST      R1,CVTPARM2
       LA      R1,WORKAREA
       ST      R1,CVTPARM3
       LA      R1,CVTPARMS        Set address
       CALL    AOFCVTDB                Get decimal
       LTR     R1,R1                   Check it out
       BZ      SIGWBAD
       ST      R1,WORDREQ              This is the requested word
       CH      R1,=H'20'               But is it ok?
       BH      SIGWBAD                 No
************************************************************
* Now, we must set up the parse routine. The general idea is to
* parse the wto msg into user defined words, and then get the one
* he wants.
************************************************************
       L       R8,STRSTART        Get address of string
       ST      R8,PARS1           Theres operand number 1
*
       MVC     PARS2(4),STRLEN    Length of WTO messages
*
       LR      R8,R2
       LR      R5,R3
       LA      R2,PARARRAY
       L       R3,=A(LPARRAY)
       SLR     R0,R0
       SLR     R1,R1
       ICM     R1,B'1000',=C' '
       MVCL    R2,R0
       LR      R2,R8
       LR      R3,R5
*      MVI     PARARRAY,X'40'
*      MVC     PARARRAY+1(255),PARARRAY      Blank out PARARRAY
*      MVC     PARARRAY+256(LPARRAY-256),PARARRAY
       MVC     PARARRAY(2),=H'20'           Max of 20 tokens.
       LA      R8,PARARRAY
       ST      R8,PARS3
*
       LA      R8,SEPCHAR
       ST      R8,PARS4
*
       LA      R1,PARSPARM
       CALL    AOFPARS           ** P A R S E   I T   **
       LH      R8,PARARRAY       How many did we get back
       C       R8,WORDREQ        See how many he wanted
       BL      NOWORDS           Not enough words.. forget it.
       LA      R8,PARARRAY+2     Point to word number 1
       L       R5,WORDREQ        Get words requested
       BCTR    R5,0
       SLL     R5,6              Multiply by 64
       LA      R8,0(R5,R8)       Point to token... now we get length
       ST      R8,TOKADDR        Remember where token was found.
       XR      R5,R5
       LA      R1,64             Tokens are 64 bytes long
************************************************************
* At this point, r8 points to the token returned by the parse routine
************************************************************
WLOOP  DS      0H
       CLI     0(R8),C' '
       BE      ENDTOKEN
       LA      R5,1(,R5)
       LA      R8,1(,R8)
       BCT     R1,WLOOP
ENDTOKEN DS    0H
       ST      R5,LWORDREQ       Store length of requested word
************************************************************
* At this point, we have all the information needed to do  *
* the parameter substitution. R2 points to the spot to     *
* substitute.                                              *
************************************************************
       L       R5,LWORDREQ              Get length of word
       BCTR    R5,0                     Minus 1 for execute
       L       R8,TOKADDR
       EX      R5,MOVEWORD
       B       AR3
MOVEWORD DS    0H
       MVC     0(*-*,R2),0(R8)    ** executed **
AR3    DS      0H
       A       R2,LWORDREQ
       LA      R3,8(,R3)
       SH      R4,=H'9'
       LTR     R4,R4
       BM      SIGWBAD
       B       CMNDLOOP
*
SIGONL DS      0H
       CLI     4(R3),C'\'               Termination for L directive
       BNE     SIGLBAD                 Shucks
       LA      R1,1(,R3)               Get start for convert rtn
       ST      R1,CVTPARM1
       LA      R1,=H'3'
       ST      R1,CVTPARM2
       LA      R1,WORKAREA
       ST      R1,CVTPARM3
       LA      R1,CVTPARMS         Set address
       CALL    AOFCVTDB                Get decimal
       LTR     R1,R1                   Check it out
       BZ      SIGLBAD
       ST      R1,LINEREQ              Save the redquested line
       C       R1,MSGLCNT       Is it more than the lines available?
       BH      SIGLBAD          Yes, let her know
       LA      R5,MSGENTRY         Get address of text
       S       R1,=F'1'
       SLL     R1,7                Multiply by 128
       LA      R0,2(R1,R5)         Point to MLWTO line specified
       ST      R0,STRSTART
       LH      R1,0(R1,R5)         get text length
       ST      R1,STRLEN           Save length for later
       LA      R3,5(,R3)
       SH      R4,=H'6'
       LTR     R4,R4
       BM      SIGLBAD
       B       CMNDLOOP
************************************************************
* Issue error messages
************************************************************
NOWORDS  DS    0H
       WTO     'AOF9207E NOT ENOUGH TOKENS IN WTO TO PROCESS'
       B       AOFMEXIT
SIGWBAD  DS    0H
       WTO     'AOF9208E ERROR PROCESSING W DIRECTIVE- MSG IGNORED'
       B       AOFMEXIT
SIGLBAD  DS    0H
       WTO     'AOF9209E ERROR PROCESSING L DIRECTIVE- ENTRY IGNORED'
       B       AOFMEXIT
SIGWRONG DS    0H
       WTO     'AOF9210E ERROR IN DEFINITION FOR WTO MSG'
       B       AOFMEXIT
************************************************************
* Issue command
************************************************************
ISSUECMD DS    0H
       TM      AOFMFLG,X'20'            Was OSCMD specified ?
       BNO     ISSURCMD                Go issue real command
************************************************************
* Here, we will not issue the command, but we will WTO out what the
* command would have been
************************************************************
       MVC     WTO1+11(L'MVSCMDTX),MVSCMDTX
       WTO     MF=(E,WTO1)            (MSG 207) defined in this module
       B       GETNEXT            Try the next AOF table entry
*
ISSURCMD DS    0H
       MVC     WTO1+11(L'MVSCMDTX),MVSCMDTX
       CLC     AOFECHO,=CL2'NO'                Echo on ?
       BE      ECHOOFF1                        No, go issue command
       CLC     AOFECHO,=CL2'LO'                Echo on for logging ?
       BE      ECHOLOG1
       CLC     AOFECHO,=CL2'YE'                Echo on ?
       BE      ECHOYES1
ECHOOFF1 DS    0H
       B       AFTECHO1                        No echo, what a shame
*
ECHOYES1 DS    0H
       WTO     MF=(E,WTO1)         (MSG207)
       B       AFTECHO1                        Echo to mastcons
*
ECHOLOG1 DS    0H
       MVC     WTL1+11(L'MVSCMDTX),MVSCMDTX
       WTL     MF=(E,WTL1)
       B       AFTECHO1
*
AFTECHO1 DS    0H
       MODESET MF=(E,SUP0)        Sup state, key 0 for MSGCRE
       LA      R2,MVSCMD          Get address of length field
       MGCRE   TEXT=(R2),         Point text to CIB data length field  X
               CONSID=MSGCNID,    Issue from my console                X
               CART=MSGMCART,     Use input CART to correlate response X
               MF=(E,MGCREPL)     List form in MGCREPL
       MODESET MF=(E,PROB)        Back to problem state, key
       B       GETNEXT
*
***********************************************************************
* This is the entry point for the AOF reply function. The idea        *
* here is to intercept the WTOR, format a reply command of the form   *
* R NNNN,MSG-TEXT where NNNN is picked up from the MSGMRPYI
* field and MSG-TXT is picked up from the AOF table.
* The REPLY command is used to reply to those messages.
***********************************************************************
AOFMRPLY DS    0H
       MVI     REPLYMSG,X'40'
       MVC     REPLYMSG+1(L'REPLYMSG-1),REPLYMSG   Clear replymsg
       MVC     REPLY(2),=Y(REPLYLEN) Length of reply buffer
       MVC     REPLYCMD,=C'R '
       LA      R8,MSGMRPYI
       LA      R1,REPLYMSG
       LA      R2,L'MSGMRPYI
REPLYNUM_LOOP DS 0H
       CLC     0(1,R8),=C' '
       BE      GOT_REPLYNUM
       MVC     0(1,R1),0(R8)
       LA      R8,1(R8)
       LA      R1,1(R1)
       BCT     R2,REPLYNUM_LOOP
GOT_REPLYNUM  DS 0H
       MVI     0(R1),C','
       LH      R2,AOFACTL               Pick up length of reply
       BCTR    R2,0
       EX      R2,MOVERPLY        Move in automatic reply
       B       AR4
MOVERPLY DS    0H
       MVC     1(*-*,R1),AOFACT   ** executed **
***********************************************************************
* The reply directive is supported by the echo facility. Check to see *
* if the tabentry macro specified echo= on the card, and take action  *
***********************************************************************
AR4      DS    0H
       MVC     WTO1+11(L'REPLYMSG+L'REPLYCMD),REPLYCMD
       CLC     AOFECHO,=CL2'NO'                Echo on ?
       BE      ECHOOFF2                        No, go issue command
       CLC     AOFECHO,=CL2'LO'                Echo on for logging ?
       BE      ECHOLOG2
       CLC     AOFECHO,=CL2'YE'                Echo on ?
       BE      ECHOYES2
ECHOOFF2 DS    0H
       B       AFTECHO2                        No echo, what a shame
*
ECHOYES2 DS    0H
       WTO     MF=(E,WTO1)
       B       AFTECHO2                        Echo to mastcons
*
ECHOLOG2 DS    0H
       MVC     WTO1+11(L'REPLYMSG+L'REPLYCMD),REPLYCMD
       WTL     MF=(E,WTL1)
       B       AFTECHO2
AFTECHO2 DS    0H
       MODESET MF=(E,SUP0)        Sup state, key 0 for SVC34
       LA      R2,REPLY           Get address of length field
       MGCRE   TEXT=(R2),         Point text to CIB data length field  X
               CONSID=MSGCNID,    Issue from my console                X
               CART=MSGMCART,     Use input CART to correlate response X
               MF=(E,MGCREPL)     List form in MGCREPL
       MODESET MF=(E,PROB)        Back to problem state, key
       B       GETNEXT
***********************************************************************
* This is the entry point for the AOF post routine, allowing the      *
* caller to wait on a given message or AOF msg id before being posted *
* The caller will be the AOFWAIT REXX function.                       *
* Standard AOF action is the following:                               *
*                                                                     *
* 1) Determine if the current message is active. If not, terminate    *
*    immediately.                                                     *
*                                                                     *
* 2) Use IEANTRT to retrive the token that contains the ASCB and ECB  *
*    pointers                                                         *
*                                                                     *
* 3) Post the ECB in the specified address space                      *
*                                                                     *
* 4) Go to next entry.                                                *
*                                                                     *
***********************************************************************
***********************************************************************
*                                                                     *
* Set up name_token parm lists
*
***********************************************************************
AOFMPOST DS    0H
       MVC     NT_NAME,NT_NAMEC
       MVI     NT_ENTRYID,C' '
       MVC     NT_ENTRYID+1(L'NT_ENTRYID-1),NT_ENTRYID
       MVC     NT_ENTRYID(L'AOFENTR),AOFENTR
       LA      R1,NT_LEVEL
       ST      R1,NTRT_PARMLIST
       LA      R1,NT_NAME
       ST      R1,NTRT_PARMLIST+4
       LA      R1,NT_TOKEN
       ST      R1,NTRT_PARMLIST+8
       LA      R1,NT_RETCODE
       ST      R1,NTRT_PARMLIST+12
       XC      NT_RETCODE,NT_RETCODE
***********************************************************************
*                                                                     *
*        Call IEANTRT                                                 *
*                                                                     *
***********************************************************************
       USING   PSA,0
       L       R15,CVTPTR                 Get the CVT pointer
       USING   CVTMAP,R15
       L       R15,CVTCSRT
       DROP    R15
       L       R15,X'14'(R15,0)
       L       R15,X'08'(R15,0)            Get address of IEANTRT
       LA      R1,NTRT_PARMLIST
       BALR    R14,R15
       L       R15,NT_RETCODE
       LTR     R15,R15
       BNZ     ENDPOST
       L       R2,NT_ECBPTR     Pick up ECB to post....
       L       R3,NT_ASCBPTR    And get the address space.
       POST    (R2),X'000',ASCB=(R3),ERRET=ENDPOST,MF=(E,POST1)
ENDPOST DS     0H
       B       GETNEXT
***********************************************************************
* AOF has performed the requested function, however, we can now
* continue to scan the AOF table, in hopes of finding another
* table entry to match this message id.
***********************************************************************
GETNEXT DS     0H                       Get the next entry for msg
       TM      AOFMFLG,X'10'            Doing MSG=* processing?
       BO      RUNTABL                  Yes so do all entries
       CLC     =CL8'ZZZZZZZZ',AOFENTR   Was there an entry name?
       BE      AOFMEXIT                 No, required actions done
*
RUNTABL DS     0H                       Run the rest of table
       ICM     R7,15,AOFBNXT            Next AOF in bscan chain
       BNZ     MATCHMSG                 Have same message id
       TM      AOFMFLG,X'10'            Done MSG=* processing??
       BZ      TSTALLMG                 No, try the MSG=* type
       B       AOFMEXIT                 All done with MSG=*
       EJECT
       DROP    R7
       SPACE   2
***********************************************************************
* Finished with doing the AOF processing of the message, exit nicely  *
***********************************************************************
AOFMEXIT DS    0H
       STORAGE RELEASE,           free dynamic storage                 X
               LENGTH=DYNL,                                            X
               ADDR=(R11)
       PR                         Exit program
       DROP    R10                 End major addressability
       TITLE   'DATA AREAS'
************************************************************
*                                                          *
*        Constants                                         *
*                                                          *
************************************************************
TRHEXTBL EQU   *-X'F0'
         DC    C'0123456789ABCDEF'
NT_PERSOPT        DC    A(IEANT_NOPERSIST)    Persist option
NT_LEVEL          DC    A(IEANT_SYSTEM_LEVEL)
NT_NAMEC          EQU   *,16
                  DC    CL4'~AOF'
                  DC    CL12' '
INITVALC DS    0F
* MVSCMD
         DC    AL2(L'MVSCMDTX+2)
* MVSCMDTX
         DC    CL105' '
* WTO1
         WTO   '(AOF):                                                 X
                                                                       X
                             ',MF=L
*
* WTL1
         WTL   '(AOF):                                                 X
                                                                       X
                             ',MF=L
* MGCREPL
        MGCRE  MF=(L)             MGCRE parameter list
* SUP0
        MODESET MODE=SUP,                                              X
               KEY=ZERO,MF=L      MODESET parm list for sup, key 0
* PROB
        MODESET MODE=PROB,                                             X
               KEY=NZERO,MF=L MODESET parm list for problem state
* POST1
         POST  ,ASCB=0,ERRET=0,MF=L
*
INITVALL EQU   *-INITVALC
         EJECT
         LTORG ,
************************************************************
*                                                          *
*        DSECTS                                            *
*                                                          *
************************************************************
*---------------------------------------------------------------------*
*- dynamic area model                                                -*
*---------------------------------------------------------------------*
DYNAREA  DSECT
SAVEAREA DS    18F                Save area
*
CVTPARMS DS    3A
        ORG    CVTPARMS
CVTPARM1 DS    A
CVTPARM2 DS    A
CVTPARM3 DS    A
BSCANPRM DS    2F
         ORG   BSCANPRM
BSCANPRM1 DS   F
BSCANPRM2 DS   F
TOFF     DS    H
WORKAREA DS    CL200            Used for convert routines
***********************************************************************
* Variables used to process requests of part 1 of this routine, the   *
* interface to the oscmd command.                                     *
*                                                                     *
***********************************************************************
*
*
CURTABAD DS    A                Current AOF table address we are
*                               Dealing with
MSGID    DS    CL12             First 12 bytes of WTO/WTOR
REPLY    DC    Y(REPLYLEN)         Reply command prefix
REPLYCMD DC    CL2'R '             Reply command
REPLYMSG DC    CL109' '
REPLYLEN EQU   *-REPLYCMD          Length of reply buffer
***********************************************************************
* Re-entrant macro definitions...                                     *
*                                                                     *
***********************************************************************
INITVALS DS    0F
MVSCMD   DC    AL2(L'MVSCMDTX+2)
MVSCMDTX DC    CL105' '
WTO1     WTO   '(AOF):                                                 X
                                                                       X
                             ',MCSFLAG=(BRDCST,HRDCPY),MF=L
WTL1     WTL   '(AOF):                                                 X
                                                                       X
                             ',MF=L
MGCREPL MGCRE  MF=(L)             MGCRE parameter list
SUP0    MODESET MODE=SUP,                                              X
               KEY=ZERO,MF=L      MODESET parm list for sup, key 0
PROB    MODESET MODE=PROB,                                             X
               KEY=NZERO,MF=L MODESET parm list for problem state
POST1    POST  ,ASCB=0,ERRET=0,MF=L
************************************************************
* Variables used to process test requests in AOF table.
************************************************************
WORD1    DS    F                If TYPE=SUBSTR  starting character
*                               If TYPE=WORD    word number
WORD2    DS    F                Length of word
WORDSEPS DS    CL4              Separator charactors for words.
STRSTART DS    A                Address of first character of message.
STRLEN   DS    A                Length of WTO message
************************************************************
* Variables used to process P directive in OSCMD request
************************************************************
SIGSTART DS    F                Starting address of significance
SIGCOUNT DS    F                Number of characters
************************************************************
* Variables used to process W directive in OSCMD request
************************************************************
SEPCHAR  DS    F           Separator characters for parse
WORDREQ  DS    F
LWORDREQ DS    F
TOKADDR  DS    F           Address of requested token in
*                          parse array
************************************************************
* Variables used to process L directive in OSCMD request
************************************************************
LINEREQ  DS    F
*
************************************************************
* Variables used to process post request
************************************************************
NT_TOKEN      DS    4A       Token
              ORG   NT_TOKEN
NT_ECBPTR     DS    A
NT_ASCBPTR    DS    A
              ORG
NT_NAME       DS    CL16
              ORG   NT_NAME
NT_PREFIX     DS    CL4'~AOF'
NT_ENTRYID    DS    CL12' '
              ORG
NT_RETCODE    DS    F'0'
NTRT_PARMLIST   DS    4A
*
************************************************************
* Flags used in processing requests
************************************************************
AOFMFLG  DS    X
* X'80'  NOT USED
* X'40'  NOT USED
* X'20'  OSCMDT WAS SPECIFIED
* X'10'  MSG=* PROCESSING
************************************************************
* Parse parameters
************************************************************
PARSPARM DS    0A
PARS1    DS    A
PARS2    DS    A
PARS3    DS    A
PARS4    DS    A
PARARRAY DS    CL2,20CL64  Space for count and 20 items
LPARRAY  EQU   *-PARARRAY
DYNL    EQU    *-DYNAREA          Dynamic area length
         AOFNTRY
         AOFCB
         MSGCB
         IEAVG132 ,
         IEAVM105 ,
         PRINT ON, NOGEN
         CVT   DSECT=YES
         IHAPSA
         IEANTASM
         END   AOFMATCH
