{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013636000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 764218, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 12, "INMDSNAM": "CBT.V500.FILE974.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 764218, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 764218, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE974.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\r\\x0b'", "DS1TRBAL": "b'f\\x00'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\n2\\x00\\x02\\n3\\x00\\x00\\x00\\x0e'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04`\\x00!\\x01\\x180\\x8f\\x01\\x180\\x8f\\x18\\x10\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf6@@@'", "ispf": {"version": "04.96", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T18:10:21", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-496"}, "text": "REGULAR CBT TAPE - VERSION 496    FILE:  974\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT496.FILE974\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 41 MEMBERS COUNTED; CUMULATIVE SIZE IS 6,629 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/04/18    18:10:21    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$UGUIDE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Q\\x01\\x18\\x08\\x1f\\x01\\x18\\x08\\x1f\\t\\x13\\x02\\xed\\x02\\xed\\x00\\x00\\xd4\\xe2\\xe6\\xd6\\xd9\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-03-22T00:00:00", "modifydate": "2018-03-22T09:13:51", "lines": 749, "newlines": 749, "modlines": 0, "user": "MSWORD"}, "mimetype": "application/msword", "datatype": "binary", "extension": ".doc"}, "##GUIDE": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x17\\x01\\x18\\x07\\x9f\\x01\\x18\\x07\\x9f\\x13 \\x02\\x97\\x02\\x10\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-03-20T00:00:00", "modifydate": "2018-03-20T13:20:17", "lines": 663, "newlines": 528, "modlines": 0, "user": "GIBSONJ"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "##MEMBS": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00G\\x01\\x18\\x07\\x9f\\x01\\x18\\x07\\x9f\\x13\\x07\\x00E\\x00;\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2018-03-20T00:00:00", "modifydate": "2018-03-20T13:07:47", "lines": 69, "newlines": 59, "modlines": 0, "user": "GIBSONJ"}, "text": "Member   | Description\n---------|------------------------------------------------------------------\n##MEMBS  | This member\n---------|------------------------------------------------------------------\n#AOFWAIT | JCL to call REXX @AOFWAIT to test AOFWAIT that posts message\n---------|------------------------------------------------------------------\n#AOFWTO  | JCL to call REXX @AOFWTO  to test AOFWTO to issue WTO\n---------|------------------------------------------------------------------\n#AOFWTOR | JCL to call REXX @AOFWTOR to test AOFWTOR to issue WTOR\n---------|------------------------------------------------------------------\n@AOFPAUS | REXX exec to call AOFPAUSE to wait specified seconds\n---------|------------------------------------------------------------------\n@AOFWAIT | REXX exec to call AOFWAIT to wait for message to be posted\n---------|------------------------------------------------------------------\n@AOFWTO  | REXX exec to issue WTO\n---------|------------------------------------------------------------------\n@AOFWTOR | REXX exec to issue WTOR\n---------|------------------------------------------------------------------\n@AOFWTO2 | REXX exec to issue WTO\n---------|------------------------------------------------------------------\nALLCLOAD | JCL to allocate AOF LOADLIB\n---------|------------------------------------------------------------------\nAOFBSCAN | Assembler routine to do a binary scan of AOF message table\n---------|------------------------------------------------------------------\nAOFCB    | AOF control block DSECT\n---------|------------------------------------------------------------------\nAOFCVTDB | Assembler routine to convert ebcdic decimal to binary\n---------|------------------------------------------------------------------\nAOFLOAD  | Assembler routine to load AOF table\n---------|------------------------------------------------------------------\nAOFMATCH | Assembler routine to scan AOF table for a match\n---------|------------------------------------------------------------------\nAOFMCS   | Main Assembler routine\n---------|------------------------------------------------------------------\nAOFNTRY  | DSECT for entry in AOF table\n---------|------------------------------------------------------------------\nAOFPARS  | Assembler routine to parse message strings\n---------|------------------------------------------------------------------\nAOFPAUSE | Assembler routine to pause specified number of seconds\n---------|------------------------------------------------------------------\nAOFPROC  | AOF startup PROC\n---------|------------------------------------------------------------------\nAOFSAMP  | Sample AOF table\n---------|------------------------------------------------------------------\nAOFSVC   | Assembler SVC routine to issue system level token create/delete\n         | Used by AOFWAIT\n---------|------------------------------------------------------------------\nAOFWAIT  | Assembler routine for AOFWAIT REXX function to wait for message\n---------|------------------------------------------------------------------\nAOFWTO   | Assembler routine for AOFWTO  REXX function to issue WTO\n---------|------------------------------------------------------------------\nAOFWTOR  | Assembler routine for AOFWTOR REXX function to issue WTOR\n---------|------------------------------------------------------------------\nASMALL   | JCL to do all assemblies (assembly for AOFSVC is commented out)\n---------|------------------------------------------------------------------\nASMONE   | JCL to asseble AOFWTO\n---------|------------------------------------------------------------------\nASMSAMP  | JCL to assemble sample AOF table AOFSAMP\n---------|------------------------------------------------------------------\nMSGCB    | Message control block DSECT\n---------|------------------------------------------------------------------\nTABEND   | End of table MACRO\n---------|------------------------------------------------------------------\nTABENTRY | Table entry MACRO\n---------|------------------------------------------------------------------\nTABSTART | Table start MACRO\n---------|------------------------------------------------------------------\nWTOTEST  | JCL to issue test WTO\n---------|------------------------------------------------------------------\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#AOFWAIT": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\"\\x01\\x07)\\x1f\\x01\\x18\\x07\\x9f\\x13 \\x00\\x07\\x00\\x07\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-10-18T00:00:00", "modifydate": "2018-03-20T13:20:22", "lines": 7, "newlines": 7, "modlines": 0, "user": "GIBSONJ"}, "text": "//#AOFWAIT JOB  SYSTEMS,GIBSONJ,CLASS=A,MSGCLASS=X\n//STEP1    EXEC PGM=IRXJCL,PARM='@AOFWAIT JU01UP 60'\n//STEPLIB  DD   DSN=SYS0.AOF.LOADLIB,DISP=SHR\n//SYSTSPRT DD   SYSOUT=*\n//SYSEXEC  DD   DSN=SYS0.AOF.SOURCE,DISP=SHR\n//SYSABEND DD   SYSOUT=*\n//ABNLIGNR DD   DUMMY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#AOFWTO": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00'\\x01\\x07)o\\x01\\x18\\x07\\x9f\\x13 \\x00\\x08\\x00\\x08\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "2007-10-23T00:00:00", "modifydate": "2018-03-20T13:20:27", "lines": 8, "newlines": 8, "modlines": 0, "user": "GIBSONJ"}, "text": "//#AOFWTO  JOB  SYSTEMS,GIBSONJ,CLASS=A,MSGCLASS=X\n//STEP1    EXEC PGM=IRXJCL,\n// PARM='@AOFWTO AOFTEST ----3----+----4----+----5----+----6----+----7'\n//STEPLIB  DD   DSN=SYS0.AOF.LOADLIB,DISP=SHR\n//SYSTSPRT DD   SYSOUT=*\n//SYSEXEC  DD   DSN=SYS0.AOF.SOURCE,DISP=SHR\n//SYSABEND DD   SYSOUT=*\n//ABNLIGNR DD   DUMMY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#AOFWTOR": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x000\\x01\\x07)\\x1f\\x01\\x18\\x07\\x9f\\x13 \\x00\\x08\\x00\\x08\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2007-10-18T00:00:00", "modifydate": "2018-03-20T13:20:30", "lines": 8, "newlines": 8, "modlines": 0, "user": "GIBSONJ"}, "text": "//#AOFWTOR JOB  SYSTEMS,GIBSONJ,CLASS=A,MSGCLASS=X\n//STEP1    EXEC PGM=IRXJCL,\n// PARM='@AOFWTOR +REPLYTEST 2'\n//STEPLIB  DD   DSN=SYS0.AOF.LOADLIB,DISP=SHR\n//SYSTSPRT DD   SYSOUT=*\n//SYSEXEC  DD   DSN=SYS0.AOF.SOURCE,DISP=SHR\n//SYSABEND DD   SYSOUT=*\n//ABNLIGNR DD   DUMMY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@AOFPAUS": {"ttr": 1038, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x07(/\\x01\\x18\\x07\\x9f\\x13 \\x00\\x07\\x00\\x07\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-10-09T00:00:00", "modifydate": "2018-03-20T13:20:33", "lines": 7, "newlines": 7, "modlines": 0, "user": "GIBSONJ"}, "text": "/* REXX */\nARG seconds\nSAY 'Issuing  PAUSE 'seconds'.'\nx = AOFPAUSE(seconds)\nx = x + 0\nIF x <> 0 THEN SAY aofpause_error\nEXIT x\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@AOFWAIT": {"ttr": 1040, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\t\\x007\\x01\\x07'\\x0f\\x01\\x18\\x07\\x9f\\x13 \\x00\\x08\\x00\\x03\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@\"", "ispf": {"version": "01.09", "flags": 0, "createdate": "2007-09-27T00:00:00", "modifydate": "2018-03-20T13:20:37", "lines": 8, "newlines": 3, "modlines": 0, "user": "GIBSONJ"}, "text": "/* REXX */\nARG entryid waittime\nSAY 'Waiting for message 'entryid' for 'waittime' seconds.'\nx = AOFWAIT(entryid,waittime)\nx = x + 0\nSAY aofwait_error\nSAY x\nEXIT x\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@AOFWTO": {"ttr": 1042, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00A\\x01\\x07(/\\x01\\x18\\x07\\x9f\\x13 \\x00\\x07\\x00\\x07\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-10-09T00:00:00", "modifydate": "2018-03-20T13:20:41", "lines": 7, "newlines": 7, "modlines": 0, "user": "GIBSONJ"}, "text": "/* REXX */\nARG text\nSAY 'Issuing  WTO 'text'.'\nx = AOFWTO(text)\nIF x <> 0 THEN SAY aofwtor_error\nSAY aofwtor_error\nEXIT x\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@AOFWTOR": {"ttr": 1044, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00E\\x01\\x07'o\\x01\\x18\\x07\\x9f\\x13 \\x00\\x08\\x00\\x08\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-10-03T00:00:00", "modifydate": "2018-03-20T13:20:45", "lines": 8, "newlines": 8, "modlines": 0, "user": "GIBSONJ"}, "text": "/* REXX */\nARG text reply_length\nSAY 'Issuing  WTOR 'text' with reply length 'reply_length'.'\nx = AOFWTOR(text,reply_length)\nx = x + 0\nIF x = 0 THEN SAY \"Reply is '\"aofwtor_reply\"'.\"\nSAY aofwtor_error\nEXIT x\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@AOFWTO2": {"ttr": 1046, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00I\\x01\\x07(\\x9f\\x01\\x18\\x07\\x9f\\x13 \\x00\\x07\\x00\\x07\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2007-10-16T00:00:00", "modifydate": "2018-03-20T13:20:49", "lines": 7, "newlines": 7, "modlines": 0, "user": "GIBSONJ"}, "text": "/* REXX */\nARG text\nSAY 'Issuing  WTO 'text'.'\nx = AOFWTO('This is a test of 'text'.')\nIF x <> 0 THEN SAY aofwtor_error\nSAY aofwtor_error\nEXIT x\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE974": {"ttr": 1048, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04`\\x00\\x15\\x01\\x180\\x8f\\x01\\x180\\x8f\\x18\\x10\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf6@@@'", "ispf": {"version": "04.96", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T18:10:15", "lines": 11, "newlines": 11, "modlines": 0, "user": "CBT-496"}, "text": "//***FILE 974 is from Jamie Gibson and contains a rewrite of the    *   FILE 974\n//*           TSSO console automation facility, that uses enhanced  *   FILE 974\n//*           console support instead of the subsystem interface.   *   FILE 974\n//*           The program is called AOF (Automated Operations       *   FILE 974\n//*           Facility).                                            *   FILE 974\n//*                                                                 *   FILE 974\n//*           support email:   sbgolob@cbttape.org   (for now)      *   FILE 974\n//*                                                                 *   FILE 974\n//*           A user guide has been supplied, both in text format   *   FILE 974\n//*           and in WORD format.                                   *   FILE 974\n//*                                                                 *   FILE 974\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ALLCLOAD": {"ttr": 1050, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x12\\x01\\x18\\x07\\x9f\\x01\\x18\\x07\\x9f\\x11V\\x00\\x07\\x00\\x07\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-03-20T00:00:00", "modifydate": "2018-03-20T11:56:12", "lines": 7, "newlines": 7, "modlines": 0, "user": "GIBSONJ"}, "text": "//ALLCLOAD JOB  ,,CLASS=A,MSGCLASS=X\n//STEP1    EXEC PGM=IEFBR14\n//LOADLIB  DD   DSN=SYS0.AOF.LOADLIB,\n//         DISP=(NEW,CATLG),\n//         SPACE=(CYL,(10,,10)),\n//         UNIT=SYSDA,\n//         RECFM=U,LRECL=32760\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AOFBSCAN": {"ttr": 1052, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x00T\\x01\\x07%\\x7f\\x01\\x18\\x07\\x9f\\x13 \\x00j\\x00\\x92\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "2007-09-14T00:00:00", "modifydate": "2018-03-20T13:20:54", "lines": 106, "newlines": 146, "modlines": 0, "user": "GIBSONJ"}, "text": "         TITLE 'BINARY SEARCH ROUTINE'\n***********************************************************************\n*                                                                     *\n* Binary search routine - generalized                                 *\n*                                                                     *\n* This routine will scan the index table built when the AOF table     *\n* was loaded. The index table has the message ids in alphabetical     *\n* order (std collating seq.). This allows the table to be searched    *\n* via the binary search method.                                       *\n*                                                                     *\n* Input                                                               *\n*   R1  --  Points to parameter list                                  *\n*       Parameters                                                    *\n*       1) Address of field to compare to                             *\n*       2) Address of a three word field containing                   *\n*          Address of start of table                                  *\n*          Address of end of table                                    *\n*          Length of table (must be a power of 2)                     *\n*   R13 --  Save area address                                         *\n*   R14 --  Return address                                            *\n* Output                                                              *\n*   R1  --  Return parameter (see below)                              *\n*   R15 --  Return code                                               *\n* Return codes                                                        *\n*    0  --  Not found                                                 *\n*             R1 points to item to insert after                       *\n*    4  --  Found                                                     *\n*             R1 points to match                                      *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*PROCESS  USING(NOWARN)\nAOFBSCAN CSECT ,\nAOFBSCAN AMODE 31\nAOFBSCAN RMODE ANY\n***********************************************************************\n*---------------------------------------------------------------------*\n*- register usage                                                    -*\n*---------------------------------------------------------------------*\nR0      EQU    0                  work reg\nR1      EQU    1                  work and parm reg\nR2      EQU    2                  work reg\nR3      EQU    3                  work reg\nR4      EQU    4                  work reg\nR5      EQU    5                  pointer to end of the mdb\nR6      EQU    6                  next mdb pointer\nR7      EQU    7\nR8      EQU    8\nR9      EQU    9\nR10     EQU    10\nR11     EQU    11\nR12     EQU    12                 module base\nR13     EQU    13                 linkage\nR14     EQU    14                 linkage\nR15     EQU    15                 linkage\n***********************************************************************\n* Begin linkage convention\n***********************************************************************\n       BAKR    R14,0              save regs\n       LA      R12,0(R15,0)       base and address regs\n       USING   AOFBSCAN,R12       addressability\n       MODID   ,                  eye catcher and date\n***********************************************************************\n* Begin initialization\n***********************************************************************\n         L     R2,0(,R1)                Get address for compare field\n         L     R1,4(,R1)                Get address for table scan\n         LM    R4,R6,0(R1)              Load table scan parameters\n         LNR   R3,R6                    Get -length for andinG\n         LA    R8,4(R4)\nBSLOOP   LR    R1,R5                    Get end address\n         SR    R1,R4                    Get difference\n         SRL   R1,1                     Divide by 2\n         NR    R1,R3                    Round down to entry boundary\n         AR    R1,R4                    Add in base of table\n         CLC   0(12,R2),4(R1)           Do the compare\n         BE    RET4                     If equal then all donE\n         BH    BSHIGH                   Go handle high case\n*    LOW - NEED TO GO CLOSER TO START\n         CR    R1,R4                    Are we already at start of tbl\n         BE    BSUPONE                  Not found, but need to adj R1\n         LR    R5,R1                    Set new high to current\n         SR    R5,R6                    Set new high to below current\n         B     BSLOOP                   Try again\n*    HIGH - NEED TO GO CLOSER TO END\nBSHIGH   DS    0H\n         CR    R1,R5                    Are we already at end of table\n         BE    RET0                     Not found, R1 is ok\n         LR    R4,R1                    Set new low to current\n         AR    R4,R6                    Set new low above current\n         B     BSLOOP                   Try again\nBSUPONE  DS    0H\n         SR    R1,R6                    Set pointer to one before\n*                                       Canidate\nRET0     DS    0H                       Exit not found\n         SLR   R15,R15                  With return code 0\n         B     EXIT\nRET4     DS    0H                       Exit found\n         LA    R15,4                    With return code 4\n         B     EXIT\n***********************************************************************\n*  All done!!!!! now freE up storage and exit                         *\n***********************************************************************\nEXIT     DS   0H\n         PR                         Exit program\n         END   AOFBSCAN\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AOFCB": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00$\\x01\\x07%_\\x01\\x18\\x07\\x9f\\x13!\\x00 \\x00\\x1f\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2007-09-12T00:00:00", "modifydate": "2018-03-20T13:21:24", "lines": 32, "newlines": 31, "modlines": 0, "user": "GIBSONJ"}, "text": "         MACRO\n         AOFCB &DSECT=YES\n***********************************************************************\n*                                                                     *\n* AOF Control block                                                   *\n*                                                                     *\n*                                                                     *\n* Created                                                             *\n*                                                                     *\n* ddmmmyy   Change description                                        *\n*                                                                     *\n***********************************************************************\n         AIF   ('&DSECT' EQ 'YES').L0001\nAOFCB    DS    0D        AOFTBL  Parameter List\n         AGO   .L0002\n.L0001   ANOP\nAOFCB    DSECT           AOFTBL  Parameter List\n.L0002   ANOP\nTRUTABN  DS    CL8                Name of table to load\nTRUTABL  DS    A(0)               Address of loaded table\nTRUBSTH  DS    A(0)         Address of header of block containiNG\n*                           binary search table\nTRUBSTS  DS    A(0)         Address of start of binary search table\n*                           for extended operator function.\nTRUBSTE  DS    A(0)         Address of end of binary search table\n*                           for extended operator function.\nTRUBSTL  DS    F'0'         Length of entry in binary search table\n*                           for extended operator function.\nTRUALMS  DS    A(0)         Address of chain of aofntry blocks for\n*                           MSG=* processing.\n         ORG   ,\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AOFCVTDB": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00)\\x01\\x07&\\x0f\\x01\\x18\\x07\\x9f\\x13!\\x00\\x95\\x00\\xa6\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2007-09-17T00:00:00", "modifydate": "2018-03-20T13:21:29", "lines": 149, "newlines": 166, "modlines": 0, "user": "GIBSONJ"}, "text": "          TITLE 'AOF EBCDIC DECIMAL TO BINARY CONVERT ROUTINES'\n*PROCESS  USING(NOWARN)\nAOFCVTDB CSECT ,\nAOFCVTDB AMODE 31\nAOFCVTDB RMODE ANY\n***********************************************************************\n* Subroutine name -\n*\n*         AOFCVTDB\n*\n* Function -\n*\n*         Converts the EBCDIC decimal field designated to a full word\n*         of binary\n*\n* Attributes -\n*\n*         Serially reusable, reSIDent, called via BALR\n*\n* Entry points -\n*\n*         AOFCVTDB - Convert ebcdic decimal to binary\n*\n* Entry conditions -\n*\n* R1 -> parameters\n*         PARM1 -> The first byte of the field\n*         PARM2 -> Halfword containing the length of field\n*         PARM3 -> Doubleword work area\n*\n* Exit conditions -\n*\n*         R1  = Full word of binary; if error R1 = 0\n*         R15 = Return code\n*\n*         CC = 0; If error cc \u00ac= 0\n*\n* Calls to other routines -\n*\n*         NONE\n*\n* External references -\n*\n*         NONE\n*\n* Tables / Work areas -\n*\n*         Workdword\n*\n* Register usage -\n*\n*         R11 = Work area base register\n*         R12 = Base register\n*         R14 = Return register\n*\n*         R0, R1, R2 = Work registers\n*\n*         All other registers are not used\n*\n* Notes -\n*\n*         None\n*\n* Operation -\n*\n*         1. Save registers.\n*         2. If length greater than 10 digits indicate error.\n*         3. Validity check all EBCDIC decimal digits.\n*         4. Pack field.\n*         5. If result is greater than 2**31-1 indicate error.\n*         6. Convert result to binary.\n*         7. Restore registers.\n*\n*.\n*---------------------------------------------------------------------*\n*- register usage                                                    -*\n*---------------------------------------------------------------------*\nR0      EQU    0                  work reg\nR1      EQU    1                  work and parm reg\nR2      EQU    2                  work reg\nR3      EQU    3                  work reg\nR4      EQU    4                  work reg\nR5      EQU    5\nR6      EQU    6\nR7      EQU    7\nR8      EQU    8\nR9      EQU    9\nR10     EQU    10\nR11     EQU    11                 work area base\nR12     EQU    12                 module base\nR13     EQU    13                 linkage\nR14     EQU    14                 linkage\nR15     EQU    15                 linkage\n***********************************************************************\n* begin linkage convention\n       BAKR    R14,0              save regs\n       LR      R10,R1             Save parm pointer\n       LA      R12,0(R15,0)       base and address regs\n       USING   AOFCVTDB,R12       addressability\n       MODID   ,                  eye catcher and date\n***********************************************************************\n          L     R1,0(,R10)\n          L     R11,4(,R10)\n          LH    R0,0(,R11)\n          L     R11,8(,R10)\n          USING WORKAREA,R11\n          CH    R0,=H'10'      Greater than 10 digits ?\n          BH    EXIT8\n          LR    R2,R0          Get length of field\n          BCTR  R2,0           Decrement for EX\nDECCHK    CLI   0(R1),C'0'\n          BL    EXIT8\n          CLI   0(R1),C'9'\n          BH    EXIT8\n          LA    R1,1(,R1)\n          BCT   R0,DECCHK\n          L     R1,0(,R10)\n          EX    R2,PACK        ...\n          B     CHKMAX\nPACK      PACK  WORKDWORD,0(*-*,R1) Executed PACK instruction\nCHKMAX    DS    0H\n          CP    WORKDWORD,=PL8'2147483647' Greater than 2**31-1 ?\n          BH    EXIT8          Branch if yes\n          CVB   R1,WORKDWORD   Convert to binary\n          L     R15,=F'0'      Set return code to 0\n          B     ENDPROG\nEXIT8     EQU   *\n          L     R1,=F'0'       return vaule 0\n          L     R15,=F'8'      Set return code to 8\n          B     ENDPROG\n          SPACE 1\n          EJECT\n          LTORG\n          EJECT\n***********************************************************************\n*  All done!!!!! now free up storage and exit                         *\n***********************************************************************\nENDPROG  DS   0H\n         PR                         Exit program\n         EJECT\n         LTORG ,\n         EJECT\n*---------------------------------------------------------------------*\n*- work area                                                         -*\n*---------------------------------------------------------------------*\nWORKAREA DSECT\nWORKDWORD DS    D\n*\n         END   AOFCVTDB\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AOFLOAD": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01'\\x005\\x01\\x07%O\\x01\\x18\\x07\\x9f\\x13!\\x00\\xf9\\x01/\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@\"", "ispf": {"version": "01.39", "flags": 0, "createdate": "2007-09-11T00:00:00", "modifydate": "2018-03-20T13:21:35", "lines": 249, "newlines": 303, "modlines": 0, "user": "GIBSONJ"}, "text": "        TITLE  'TRU - LOAD AOF TABLE'\n*PROCESS  USING(NOWARN)\nAOFLOAD  CSECT ,\nAOFLOAD  AMODE 31\nAOFLOAD  RMODE ANY\n***********************************************************************\n*---------------------------------------------------------------------*\n*- Register usage                                                    -*\n*---------------------------------------------------------------------*\nR0      EQU    0                  work reg\nR1      EQU    1                  work and parm reg\nR2      EQU    2                  work reg\nR3      EQU    3                  work reg\nR4      EQU    4                  work reg\nR5      EQU    5                  pointer to end of the mdb\nR6      EQU    6                  next mdb pointer\nR7      EQU    7\nR8      EQU    8\nR9      EQU    9\nR10     EQU    10\nR11     EQU    11                 dynamic storage base\nR12     EQU    12                 module base\nR13     EQU    13                 linkage\nR14     EQU    14                 linkage\nR15     EQU    15                 linkage\n***********************************************************************\n* Return codes:                                                       *\n*   None                                                              *\n*                                                                     *\n***********************************************************************\n* Begin linkage convention\n       BAKR    R14,0              Save regs\n       LR      R10,R1             Save parm pointer\n       USING   AOFCB,R10\n       SAC     512                Set AR mode\n       SYSSTATE ASCENV=AR         Let macros know\n       LA      R12,0(R15,0)       Base and address regs\n       USING   AOFLOAD,R12        Addressability\n       MODID   ,                  Eye catcher and date\n       STORAGE OBTAIN,LENGTH=DYNL Get dynamic storage\n       LA      R11,0(0,R1)        Use R11 as dyn base\n       LA      R2,DYNMODEL        Address of dynamic area model\n       L       R3,=A(DYNL)        Length of dynamic area\n       LA      R4,0(0,R11)        Address of dynamic area\n       LR      R5,R3              Length of dynamic area\n       MVCL    R4,R2              Copy model to dynamic area\n       USING   DYNMODEL,R11       Map model over dynamic area\n       LA      R13,SV             Put save area addr in R13\n       MVC     4(4,R13),=C'F1SA'  sSt acro in save area\n* Begin initialization\n       SAC     0                  Set primary mode\n       SYSSTATE ASCENV=P          Let macros know\n************************************************************\n*                                                          *\n*        Get name of module to load                        *\n*                                                          *\n************************************************************\n         CLC   TRUTABN(8),=CL8' '\n         BNE   GETTABLE\n         MVC   TRUTABN(8),=CL8'AOFTABL'\n************************************************************\n*                                                          *\n*        Load the automated operator facility table        *\n*                                                          *\n************************************************************\nGETTABLE DS    0H\n         LA    R2,TRUTABN\n         LOAD  EPLOC=(R2),LSEARCH=YES,ERRET=NOLOAD,                    X\n               SF=(E,LOAD1D)\n         LR    R6,R0                         Remember load address\n         B     CHCKTABL\nAOFLOADB DS    0H\n         MVC   WTO05D+49(8),8(R7)\n         WTO   MF=(E,WTO05D)          (MSG 05)\n         B     ENDPROG\nCHCKTABL DS    0H\n         CLC   4(8,R6),=CL8'AOFTABL'         Make sure we really\n*                                            have an AOF table\n         BNE   TABNGOOD                      Darn\n         CLC   44(8,R6),=CL8'AOF 1.0'        Check version number\n         BNE   TABNGOO2                      Incorrect version\n         ST    R6,TRUTABL\n         MVC   WTO01D+37(8),TRUTABN\n         WTO   MF=(E,WTO01D)           (MSG 01)\n         B     ENDSTP16\nTABNGOOD DS    0H                      ** Not an AOF table **\n         MVC   WTO03D+20(8),TRUTABN\n         WTO   MF=(E,WTO03D)           (MSG 03)\n         B     BADE16                  Go to bad end of step 16\nTABNGOO2 DS    0H                      ** Table at incorrect version **\n         MVC   WTO04D+19(8),TRUTABN\n         WTO   MF=(E,WTO04D)           (MSG 04)\n         B     BADE16                  Go to bad end of step 16\nNOLOAD   DS    0H\n         MVC   WTO02D+20(8),TRUTABN\n         WTO   MF=(E,WTO02D)           (MSG 02)\n         B     BADE16A                 Go to bad end of step 16 w/o del\nBADE16   DS    0H\n         LA    R3,TRUTABN\n         DELETE EPLOC=(R3)\nBADE16A  DS    0H\n         XR    R3,R3\n         ST    R3,TRUTABL\n         MVC   TRUTABN,=CL8'NONE'      Indicate no table\n         B     ENDPROG\nENDSTP16 DS    0H\n***********************************************************************\n*  Table is now loaded and validated, go and build the index.         *\n***********************************************************************\n         L     R3,TRUTABL               Get pointer to actual table\n         L     R2,52(,R3)               Point at entry count\n         L     R2,0(,R2)                Get count of entries\n         LA    R2,1(,R2)                Plus 1\n         SLL   R2,4                     Assume worst,\n*                                       all entries different\n         LA    R2,4(,R2)                Plus header\n         STORAGE OBTAIN,LENGTH=(2)      Get dynamic storage\n         ST    R2,0(,R1)                Set length\n         ST    R1,TRUBSTH               Save address of index block\n         AR    R1,R2                    Point to real end\n         SH    R1,=H'16'                Less an entry size\n         MVC   4(L'AOFMSGID,R1),=CL12'ZZZZZZZZZZZZ' put in dummy entry\n         XC    0(4,R1),0(R1)            Clear pointer\n         ST    R1,TRUBSTS               Save pointer to start\n         ST    R1,TRUBSTE               Save pointer to current last\n         MVI   TRUBSTL+3,16             Set length\n         L     R3,0(,R3)                Get address of first entry\n         USING AOFNTRY,R3               Setup addressability\nLPAOFN   DS    0H\n         LTR   R3,R3                    Any entry\n         BZ    ENDPROG                  All done, so exit\n         CLC   AOFMSGID,=CL12'*'        Is it match all\n         BNE   DORMSG                   No, do real message\n         LA    R7,TRUALMS               Point to head of all msg\n         ICM   R4,15,0(R7)              *TEST 6/9/2014\n         B     CHAINNEW                 Chain it on\nDORMSG   DS    0H                       Do real message\n         LA    R1,AOFMSGID\n         ST    R1,BSCANPRM1\n         LA    R1,TRUBSTS\n         ST    R1,BSCANPRM2\n         LA    R1,BSCANPRM\n         CALL  AOFBSCAN                 Call BSCAN\n         LR    R7,R1\n         LTR   R15,R15\n         BZ    ADD                      +0 not in table, add it\n         ICM   R4,15,0(R7)              *TEST 6/9/2014\n         B     CHAINNEW                 +4 in table, chain it\n*\n**       Chain new AOF entry to previous entries or head\n*\nCHAINNEW ICM   R4,15,0(R7)              Get pointer to first\n         BNZ   CHNLP                    If one exists then handlE\n         ST    R3,0(,R7)                Set first entry\n         B     CHNELP                   Now clear new tail\nCHNLP    LR    R7,R4\n         ICM   R4,15,AOFBNXT-AOFNTRY(R7) Any more\n         BNZ   CHNLP\n         ST    R3,AOFBNXT-AOFNTRY(,R7)  Chain new on\nCHNELP   DS    0H\n         XC    AOFBNXT,AOFBNXT          Clear new tail\n         L     R3,AOFNXT                Point to next\n         B     LPAOFN                   Go do next\n*\n**       Add in new entry to index\n*\n*                       Note\n*                            - R7 points to entry\n*                              That the new one should follow\n*                            - TRUBSTS and TRUBSTE point to\n*                              the end of current table. TRUBSTS\n*                              will be modified by this routiNE\nADD      DS    0H                       Add in new entry\n         LM    R4,R6,TRUBSTS            Get start and end ptrs\n*\n**       Compute length to move\n*\n         LR    R1,R7\n         SR    R1,R4                    Get length to move\n         BNM   ADDNTY                   Go and do move\n*\n**       ADD TO FRONT OF TABLE\n*\n         SR    R4,R6                    Get new low value\n         ST    R4,TRUBSTS               Save new start\n         MVC   4(L'AOFMSGID,R4),AOFMSGID         Set new message id\n         XC    0(4,R4),0(R4)            Clear chain\n         LR    R7,R4                    Point to entry to add\n         ICM   R4,15,0(R7)              *TEST 6/9/2014\n         B     CHAINNEW                 Put on chain\n*\n**       Add somewhere in table (even end)\n*\nADDNTY   DS    0H\n         AR    R1,R6                    Add in an entry\n         LR    R0,R4                    Get old start\n         SR    R0,R6                    Make it new start\n         ST    R0,TRUBSTS\n         LR    R5,R1                    Set old length\n         MVCL  R0,R4                    Move front of table up\n*                                       R7 will point to open entry\n         MVC   4(L'AOFMSGID,R7),AOFMSGID Set new message id\n         XC    0(4,R7),0(R7)            Clear chain\n         ICM   R4,15,0(R7)              *TEST 6/9/2014\n         B     CHAINNEW\n***********************************************************************\n*  All done!!!!! now free up storage and exit                         *\n***********************************************************************\nENDPROG  DS   0H\n       STORAGE RELEASE,           free dynamic storage                 X\n               LENGTH=DYNL,                                            X\n               ADDR=(R11)\n         PR                         exit program\n         EJECT\n         LTORG ,\n         EJECT\n*---------------------------------------------------------------------*\n*- Dynamic area model                                                -*\n*---------------------------------------------------------------------*\nDYNMODEL DS    0F\nSV       DS    18F                save area\nBSCANPRM DS    2F\n         ORG   BSCANPRM\nBSCANPRM1 DS   F\nBSCANPRM2 DS   F\n*\nWTO01D   WTO   'AOF0001I AOF IS USING TABLE NAME XXXXXXXX FOR THE AUTOMx\n               ATED OPERATIONS FACILITY',CONSID=,MF=L\n*\nWTO02D   WTO   'AOF2000S MODULE XXXXXXXX NOT FOUND, AUTOMATED OPERATIONX\n               S FACILITY DEACTIVATED',DESC=1,MF=L\n*\nWTO03D   WTO   'AOF0003S MODULE XXXXXXXX IS NOT AN AUTOMATED OPERATIONSX\n                FACILITY TABLE- FUNCTION DEACTIVATED',DESC=(1),MF=L\n*\nWTO04D   WTO   'AOF0004S TABLE XXXXXXXX IS AT AN INCORRECT LEVEL- REASSX\n               EMBLE',DESC=1,MF=L\n*\n*\nWTO05D   WTO   'AOF0005A AN ERROR HAS OCCURED LOADING MODULE XXXXXXXX',X\n               DESC=(1),MF=L\n*\n        EJECT\nLOAD1D   LOAD  EPLOC=0,LSEARCH=YES,ERRET=AOFLOADB,                     X\n               SF=L\nDYNL    EQU    *-DYNMODEL         dynamic area length\n         AOFNTRY\n         AOFCB\n         END   AOFLOAD\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AOFMATCH": {"ttr": 1294, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x008\\x01\\x14\\x14\\x9f\\x01\\x18\\x07\\x9f\\x13!\\x04V\\x04K\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "2014-05-29T00:00:00", "modifydate": "2018-03-20T13:21:38", "lines": 1110, "newlines": 1099, "modlines": 0, "user": "GIBSONJ"}, "text": "        TITLE  'AOFMATCH - Find a match in AOF TABLE'\n*PROCESS  USING(NOWARN)\nAOFMATCH CSECT ,\nAOFMATCH AMODE 31\nAOFMATCH RMODE ANY\n***********************************************************************\n*---------------------------------------------------------------------*\n*- register usage                                                    -*\n*---------------------------------------------------------------------*\nR0      EQU    0                  work reg\nR1      EQU    1                  work and parm reg\nR2      EQU    2                  work reg\nR3      EQU    3                  work reg\nR4      EQU    4                  work reg\nR5      EQU    5                  pointer to end of the mdb\nR6      EQU    6                  next mdb pointer\nR7      EQU    7\nR8      EQU    8\nR9      EQU    9\nR10     EQU    10\nR11     EQU    11                 dynamic storage base\nR12     EQU    12                 module base\nR13     EQU    13                 linkage\nR14     EQU    14                 linkage\nR15     EQU    15                 linkage\n***********************************************************************\n*                                                                     *\n***********************************************************************\n* begin linkage convention\n       BAKR    R14,0              save regs\n       L       R10,0(,R1)         Load pointer\n       USING   AOFCB,R10\n       L       R9,4(,R1)          Load pointer\n       USING   MSGCB,R9\n       LA      R12,0(R15,0)       base and address regs\n       USING   AOFMATCH,R12       addressability\n       MODID   ,                  eye catcher and date\n       STORAGE OBTAIN,LENGTH=DYNL get dynamic storage\n       LA      R11,0(0,R1)        use R11 as dyn base\n       USING   DYNAREA,R11        map model over dynamic area\n       LA      R13,SAVEAREA       put save area addr in R13\n       MVC     4(4,R13),=C'F1SA'  set acro in save area\n       LA      R2,INITVALC        address of dynamic area model\n       L       R3,=A(INITVALL)    length of dynamic area\n       LA      R4,INITVALS        address of dynamic area\n       LR      R5,R3              length of dynamic area\n       MVCL    R4,R2              copy model to dynamic area\n       L       R7,TRUTABL          get address of table.\n       LTR     R7,R7               check it out\n       BZ      AOFMEXIT            no table, no work to do.\n*      TM      MSGCSUPB,MSGCSSSI+MSGCSWTO+MSGCSMPF Suppressed?\n*      BNZ     AOFMEXIT            Yes, then leave\n       TM      MSGCSUPB,MSGCSAUT   Automation specified?\n       BNO     AOFMEXIT            No, then leave\n       SPACE   1\n***********************************************************************\n* If we get here there is a (valid) AOF table.\n* The validity of the table is determined at AOF startup/table reload\n* time.\n* R7 will serve as a base register for the AOF table current entry\n***********************************************************************\n***********************************************************************\n* Isolate the message id and preserve it for future examination.      *\n***********************************************************************\n       LA      R2,MSGENTRY+2       Get address of text\n       ST      R2,STRSTART         and remember for AOFPARS later\n       MVI     MSGID,C' '          Blank message id\n       MVC     MSGID+1(L'MSGID-1),MSGID\n       LA      R4,MSGID            Location to store message id\n       LA      R3,L'MSGID          Get max length of MSGID\n       CH      R3,MSGENTRY         Greater than length of message?\n       BL      TXTLOOP             No, then procede\n       LH      R3,MSGENTRY         Yes, load length of message\nTXTLOOP DS     0H                  Copy message ID from message\n       CLI     0(R2),C' '          Blank?\n       BE      TXTBLANK            Yes, end of message id\n       MVC     0(1,R4),0(R2)       No, move to MSGID\n       LA      R2,1(,R2)           Bump source pointer\n       LA      R4,1(,R4)           Bump target pointer\n       BCT     R3,TXTLOOP          Loop\nTXTBLANK DS    0H\n       LH      R1,MSGENTRY         get text object length\n       ST      R1,STRLEN           save length for later\n************************************************************\n* Here is where we examine the text of the WTO to see if we should\n* take action.\n* The address of the table is in TRUTABL,\n* R6: points to current table entry, during test processing.\n************************************************************\n       LA      R1,MSGID\n       ST      R1,BSCANPRM1\n       LA      R1,TRUBSTS\n       ST      R1,BSCANPRM2\n       LA      R1,BSCANPRM\n       CALL    AOFBSCAN\n       LTR     R15,R15\n       BZ      TSTALLMG                  0 not found, look msg=*\n       L       R7,0(,R1)                point at first AOFNTRY\n       USING   AOFNTRY,R7\n       B       MATCHMSG                  4 found, do entries\n*\nTSTALLMG DS    0H\n       ICM     R7,B'1111',TRUALMS       point at MSG=* entries\n       BZ      AOFMEXIT                 if none, then all done\n       OI      AOFMFLG,X'10'            indicate MSG=* processing\n       B       MATCHMSG                 go process all entries\n       SPACE   2\n***********************************************************************\n* We come here when a match has been found in the message id section  *\n* of an AOF table entry. The processing continues with the performing *\n* of any tests that needs to be issued. If all tests are matched,     *\n* then branch to the PERFACT routine, which will perform any actions  *\n* required. If the tests are not met, continue searching the table as *\n* there may be another match.                                         *\n***********************************************************************\nMATCHMSG DS    0H\n       ST      R7,CURTABAD              save current entry addr\n       L       R6,AOFTESTP               load up test entry.\n       USING   ATSNTRY,R6\nTESTLOOP DS    0H                        loop for test entries\n       LTR     R6,R6                     any more test entries ?\n       BZ      TESTSUCC                  nope, all tests must be oK\n       L       R1,ATSWORD          load substr or word number\n       ST      R1,WORD1            and remember it.\n       L       R1,ATSLNGTH         load length\n       ST      R1,WORD2\n       MVC     WORDSEPS(4),ATSSEPS load word separators.\n***********************************************************************\n* We must determine the test type                                     *\n***********************************************************************\n       CLC     ATSTYPE,=CL2'W '    is it a word ?\n       BE      WORDTYPE            yup, go process it\n       CLC     ATSTYPE,=CL2'WX'    is it a word exclusion ?\n       BE      WORDTYPE            yup, go process it\n       CLC     ATSTYPE,=CL2'P '    is it a substring ?\n       BE      SUBSTYPE            yup, go process it.\n       CLC     ATSTYPE,=CL2'PX'    is it a substring exclusion ?\n       BE      SUBSTYPE            yup, go process it.\n       CLC     ATSTYPE,=CL2'S '    is it a substring ?\n       BE      SUBSTYPE            yup, go process it.\n       CLC     ATSTYPE,=CL2'SX'    is it a substring exclusion ?\n       BE      SUBSTYPE            yup, go process it.\n       CLC     ATSTYPE,=CL2'L '    is it a line number?\n       BE      LINETYPE            yup, go process it.\n       CLC     ATSTYPE,=CL2'D '    is it a descriptor code ?\n       BE      DESCTYPE            yup, go process it.\n       B       TESTTBAD            no, it is wrong\n       SPACE   1\nTESTTBAD DS    0H                  invalid test type\n* Invalid test type, ** PROBLEM **\n       WTO     'AOF9202E INVALID TEST TYPE- IGNORING MESSAGE ID'\n       B       AOFMEXIT            stop processing on failure\n       EJECT   ,\n***********************************************************************\n* We come here when we have a word test. The routine will perform the\n* following procedures.\n*                                                                     *\n* 1) Use AOFPARS to parse the message, based on the separator chars   *\n*    specified in the table.                                          *\n* 2) Perform the test based on the desired word, using the length     *\n*    specified in the table.                                          *\n* 3) Either go to testfail, or perform another test.                  *\n*                                                                     *\n***********************************************************************\nWORDTYPE DS    0H\n       L       R8,STRSTART       get address of string\n       ST      R8,PARS1          theres operand number 1\n*\n       MVC     PARS2(4),STRLEN    length of wto messages\n*\n       LR      R8,R2\n       LR      R5,R3\n       LA      R2,PARARRAY\n       L       R3,=A(LPARRAY)\n       SLR     R0,R0\n       SLR     R1,R1\n       ICM     R1,B'1000',=C' '\n       MVCL    R2,R0\n       LR      R2,R8\n       LR      R3,R5\n*      MVI     PARARRAY,X'40'\n*      MVC     PARARRAY+1(255),PARARRAY      blank out PARARRAY\n*      MVC     PARARRAY+256(LPARRAY-256),PARARRAY\n       MVC     PARARRAY(2),=H'20'           max of 20 tokens.\n       LA      R8,PARARRAY       PARARRAY is third parameter\n       ST      R8,PARS3          store in parm list.\n*\n       LA      R8,WORDSEPS       use word separators on test directive\n       ST      R8,PARS4          and store in fourth word in parm list.\n*\n       LA      R1,PARSPARM\n       CALL    AOFPARS           ** p a r s e   i t   **\n*      MVC     PARARRAY(2),=H'1'\n       LH      R8,PARARRAY      how many did we get back\n       C       R8,WORD1         see which one was specified in the\n*                                test parameter list.\n       BL      WORDFAIL          not enough words.. fail this test.\n       LA      R8,PARARRAY+2    point to word number 1\n       L       R5,WORD1          get word  requested\n       BCTR    R5,0\n       SLL     R5,6              multiply by 64\n       LA      R8,0(R5,R8)       point to token\n       ST      R8,TOKADDR       remember where token was found.\n***********************************************************************\n* At this point, TOKADDR contains the address of the token (word) that\n* was located by AOFPARS. We will compare this word, for n characters\n* against what was specified in the AOF table. If matched, great\n* if not, test has failed.\n*\n* We need to load up the match text as specified in the AOF table.\n***********************************************************************\n       LH      R4,ATSTXTL       get matching text length\n***********************************************************************\n* Note, the matching text string is at 20(R6) where R6 points to the\n* test parameter entry (tpe).\n***********************************************************************\n       L       R5,TOKADDR       load token address\n       BCTR    R4,0             -1 for how hardware works\n       EX      R4,COMPSTR       do compare !\n       BE      WORDSUCC        word matched !!\n       BNE     WORDFAIL         word didnt match !!!\nCOMPSTR DS     0H\n       CLC     0(*-*,R5),ATSTXT   ** executed **\n************************************************************\n* We come here if the word matched, implying that this particular\n* test was successfull. Now we will go see if there are any more\n* tests..\n************************************************************\nWORDSUCC DS    0H\n       CLI     ATSTYPE+1,C'X'   is it an exclusion test?\n       BE      TESTFAIL         yes, so the test failed\n       L       R6,ATSNXT        get next test entry\n       B       TESTLOOP         and try again...\n*\nWORDFAIL DS    0H\n       CLI     ATSTYPE+1,C'X'   is it an exclusion test?\n       BNE     TESTFAIL         no, it really is a failure\n       L       R6,ATSNXT        get next test entry\n       B       TESTLOOP         and try again...\n*\n***********************************************************************\n* The user requested a substring type of test on the message.         *\n* The routine will provide that test.                                 *\n* The test is:                                                        *\n* substr(mvswto,start in AOF,length in AOF) ?= matchtex in AOF.       *\n*                                                                     *\n***********************************************************************\nSUBSTYPE DS    0H\n       L       R5,STRSTART      get start of mvs message.\n       L       R4,WORD1         get start as specified in AOF.\n       BCTR    R4,0             -1 to get correct character.\n       LA      R5,0(R4,R5)      point to start of substring in msg\n       L       R4,WORD2         get length for compare.\n       BCTR    R4,0             -1 for execute\n       EX      R4,COMPSTR2      perform the substring compare.\n       BE      SUBSSUCC         they matched! -> test succeded.\n       BNE     SUBSFAIL         no matched- subs failed\n***********************************************************************\n* Note that the match text is in 20(R6) where R6 points to the current\n* AOF table.\n***********************************************************************\nCOMPSTR2 DS    0H\n       CLC     0(*-*,R5),ATSTXT   ** executed **\n***********************************************************************\n* We get here if the substring test was successfull. AOF will\n* check the next entry in the table and attempt the next test\n***********************************************************************\nSUBSSUCC DS    0H\n       CLI     ATSTYPE+1,C'X'   is it an exclusion test?\n       BE      TESTFAIL         yes, so the test fails\n       L       R6,ATSNXT        get next test entry\n       B       TESTLOOP         and try again...\n*\n***********************************************************************\n* We come here if this substring test has failed. If this is the case\n* then we will continuing search AOF table entries in hopes of again\n* finding the msg id.\n***********************************************************************\nSUBSFAIL DS    0H\n       CLI     ATSTYPE+1,C'X'   is it an exclusion test?\n       BNE     TESTFAIL         no, it really is a failure\n       L       R6,ATSNXT        get next test entry\n       B       TESTLOOP         and try again...\n       SPACE   2\n***********************************************************************\n* The user requested a line type of test on the message.              *\n* The routine will provide that test.                                 *\n***********************************************************************\nLINETYPE DS    0H\n       CLC     ATSLINE,MSGLCNT  Is it more than the lines available?\n       BH      TESTFAIL         No - line failed\n***********************************************************************\n* We get here if the line test was successfull.\n* AOF will check the next entry in the table and attempt the next test\n***********************************************************************\nLINESUCC DS    0H\n       LA      R3,MSGENTRY         Get address of text\n       L       R1,ATSLINE          Get offset ...\n       S       R1,=F'1'            ... to the line wanted\n       SLL     R1,7                multiply by 128\n       LA      R2,2(R1,R3)         Point to MLWTO line specified\n       ST      R2,STRSTART         Save text address for later\n       LH      R1,0(R1,R3)         get text length\n       ST      R1,STRLEN           save length for later\n       L       R6,ATSNXT        get next test entry\n       B       TESTLOOP         and try again...\n*\n***********************************************************************\n* The user requested a desc type of test on the message.              *\n* The routine will provide that test.                                 *\n***********************************************************************\nDESCTYPE DS    0H\n       SLR     R1,R1            zero out for IC\n       SLR     R2,R2            zero out for IC\n       IC      R1,ATSDESC1      Get first desc byte from table\n       IC      R2,ATSDESC2      Get second desc byte from table\n       EX      R1,DESCTM1       Test desc codes\n       BNZ     DESCSUCC\n       EX      R2,DESCTM2       Test desc codes\n       BNZ     DESCSUCC\n       B       TESTFAIL         No - desc failed\nDESCTM1  DS    0H\n       TM      MSGDESC1,X'00'    Was this a desc code I care about?\nDESCTM2  DS    0H\n       TM      MSGDESC2,X'00'    Was this a desc code I care about?\n***********************************************************************\n* We get here if the desc test was successfull.\n* AOF will check the next entry in the table and attempt the next test\n***********************************************************************\nDESCSUCC DS    0H\n       L       R6,ATSNXT        get next test entry\n       B       TESTLOOP         and try again...\n*\n       SPACE   2\n***********************************************************************\n* We come here if a test fails. if this should happen we continue     *\n* searching through all AOF table entries for another match on the    *\n* msgid.                                                              *\n***********************************************************************\nTESTFAIL DS    0H\n       B       RUNTABL          go test another AOF entry\n*\n***********************************************************************\n* We come here if all tests have been succussfull for this table entry*\n* We set the MLWTO line back to the first line                        *\n* AOF will go and perform the action requested and continue searching *\n* the table for any additional entries.                               *\n***********************************************************************\nTESTSUCC DS    0H\n       LA      R1,MSGENTRY+2       Get address of first line of text\n       ST      R1,STRSTART         store it\n       LH      R1,MSGENTRY         get text length\n       ST      R1,STRLEN           save length for later\n       B       PERFACT\n       DROP    R6\n*\n************************************************************\n* We come here when we have found a WTO in the table, and the tests\n* specified for the entry have been met. At that time, we perform\n* the action specified in the ACTION= parameter for the entry.\n*\n* Processing continues as follows:\n*\n* 1) If matchlim processing has been specified (matchlim > 0) deduct\n*    one from matchlim. If matchlim = 999999 then don't bother. If\n*    matchlim = 0 then do not perform the requested function after all.\n*\n* 2) We identifiy the action specified and branch to the appropriate\n*    routine.\n*    Note that R7 points to the entry in the AOF table.\n*\n************************************************************\nPERFACT DS     0H\n       L       R2,AOFMLIM                pick up matchlim value.\n       C       R2,=F'999999'             was matchlim specified ?\n       BE      PASTMLIM                  no - dont bother deducting\n       LTR     R2,R2                     is count already zero ?\n       BZ      AOFMNACT                  no, take no action...\n       BCTR    R2,0                      Take  one away from matchlim\n       ST      R2,AOFMLIM                and store new matchlim back\n***********************************************************************\n* Here, we have survived matchlim processing, and are ready to take   *\n* on the action specified in the ACTION= parameter of the AOF table   *\n***********************************************************************\nPASTMLIM DS    0H\n       CLC     AOFACTN,=CL8'NONE'       is this a dummy request?\n       BE      GETNEXT                  yes, so we have done it\n*\n       CLC     AOFACTN,=CL8'REPLY'       request to reply ?\n       BE      AOFMRPLY\n       CLC     AOFACTN,=CL8'OSCMD'      request for an OS command ?\n       BE      AOFMCMND\n       CLC     AOFACTN,=CL8'OSCMDT'     request for an OS command ?\n*                                       in test mode ?\n       BE      AOFMCMDT\n*\n       CLC     AOFACTN,=CL8'POST'       is this request for post\n       BE      AOFMPOST\n*\n       WTO     'AOF9203E INVALID TEXT SPECIFICATION'\n       B       AOFMEXIT                 SCOTTY, beam me up.\n***********************************************************************\n* Here, the matchlim test has determined a zero matchlim              *\n***********************************************************************\nAOFMNACT DS    0H\n       B       GETNEXT                 get next AOF table entry\n***********************************************************************\n* Here, the OSCMDT was specified so set the test mode bit             *\n***********************************************************************\nAOFMCMDT DS    0H\n       OI      AOFMFLG,X'20'           indicate test mode\n       B       AOFMCMND\n************************************************************\n* Here is the entry point for issuing OS commands based on WTO's.\n************************************************************\nAOFMCMND DS    0H\n       LA      R2,MVSCMDTX       starting point for mvs cmd\n       MVI     MVSCMDTX,X'40'         blank out the\n       MVC     MVSCMDTX+1(L'MVSCMDTX-1),MVSCMDTX command buffer\n       LA      R3,AOFACT         start point for MVS directive\n       LH      R4,AOFACTL        length of message\nCMNDLOOP DS    0H\n       LTR     R4,R4            check to see if any chars remain\n*                               in buffer. this could have happened\n*                               if the formatting option had been\n*                               the last thing in the text operand\n       BZ      ISSUECMD\n       CLI     0(R3),C'\\'       significance character on?\n       BE      SIGON             well.. it is now.\n       MVC     0(1,R2),0(R3)    Move in character\n       LA      R2,1(,R2)        Bump CMD buffer ptr\n       LA      R3,1(,R3)        Bump AOF CMD ptr\n       BCT     R4,CMNDLOOP      Loop through AOF CMD\n       B       ISSUECMD          go do the command\n*\n************************************************************\n* We come here when we find the '\\' directive in the AOF table\n* entry for this message. This means we have some work to do.\n************************************************************\nSIGON  DS      0H\n       LA      R3,1(,R3)          point to next character\n       CLI     0(R3),C'A'         looking for ASID ?\n       BE      SIGONA             yup, go do it !!\n       CLI     0(R3),C'J'         looking for jobname ?\n       BE      SIGONJ             yup, go do it !!\n       CLI     0(R3),C'P'         looking for position character?\n       BE      SIGONP             yup.. got it\n       CLI     0(R3),C'S'         check its synonym\n       BE      SIGONP             yup.. got it\n       CLI     0(R3),C'W'         looking for some 'word' ?\n       BE      SIGONW             yup, go do it !!\n       CLI     0(R3),C'L'         looking for specific line\n       BE      SIGONL             yup, go do it !!\n       B       SIGWRONG           no, invalid '\\' directive...\n       SPACE   2\nSIGONA DS      0H\n       CLI     1(R3),C'\\'         check for correct format.\n       BNE     SIGWRONGA\n*\n       ICM     R0,B'0011',MSGMASID     Load ASID\n       BZ      SIGWRONGA               No ASID, Oh Well\n       SRDL    R0,4                    move nybble into R1\n       SRL     R1,4                    move over one nybble\n       SRDL    R0,4                    move nybble into R1\n       SRL     R1,4                    move over one nybble\n       SRDL    R0,4                    move nybble into R1\n       SRL     R1,4                    move over one nybble\n       SRDL    R0,4                    move nybble into R1\n       SRL     R1,4                    move over one nybble\n       ST      R1,0(,R2)               Save in command\n       OC      0(4,R2),=X'F0F0F0F0'    convert to zoned\n       TR      0(4,R2),TRHEXTBL        TR 0-9,A-F\n       LA      R2,4(,R2)               next char in cmd buffer\n       LA      R3,2(,R3)                move past \\ stuff in\n*                                       AOF table\n       SH      R4,=H'3'                Length remaining in entry\n       LTR     R4,R4\n       BM      SIGWRONGA\n       B       CMNDLOOP\nSIGWRONGA DS    0H\n       WTO     'AOF9204E ERROR IN DEFINITION (A) WTO MSG'\n       B       AOFMEXIT\n*\n       SPACE   2\nSIGONJ DS      0H\n       CLI     1(R3),C'\\'         check for correct format.\n       BNE     SIGWRONGJ1\n*\n       LA      R8,MSGMJOBN        Load jobname ptr\n       LA      R1,MSGMJOBN+L'MSGMJOBN-1 Point end of jobname\nSIGONJ1 DS     0H\n       CLI     0(R1),C' '         Did we find last character?\n       BNE     SIGONJ2            Yes, leave loop\n       BCTR    R1,0               decrement R1\n       CR      R1,R8              Have we reached the begining?\n       BNL     SIGONJ1            loop\n       LA      R1,MSGMJOBN        Jobname is all blanks\nSIGONJ2 DS     0H\n       SR      R1,R8              Get length - 1\n       LA      R1,1(,R1)          Get length\n       ST      R1,SIGCOUNT        Save count\n************************************************************\n* At this point, we have the parameters needed for jobname\n* substitution in the OS command to be issued.\n************************************************************\n       L       R1,SIGCOUNT              Get count for execute\n       BCTR    R1,0                     sub one for EX\n       EX      R1,MOVESIGJ              Move the stuff...\n       B       ARJ2\nMOVESIGJ DS    0H\n       MVC     0(*-*,R2),0(R8)   ** executed **\nARJ2   DS      0H\n       A       R2,SIGCOUNT              Next char in cmd buffer\n       LA      R3,2(,R3)                Move past \\ stuff in\n*                                       AOF table\n       SH      R4,=H'3'\n       LTR     R4,R4\n       BM      SIGWRONGJ4\n       B       CMNDLOOP\nSIGWRONGJ1 DS   0H\n       WTO     'AOF9215E ERROR IN DEFINITION (J) WTO MSG'\n       B       AOFMEXIT\nSIGWRONGJ3 DS   0H\n       WTO     'AOF9235E ERROR IN DEFINITION (J) WTO MSG'\n       B       AOFMEXIT\nSIGWRONGJ4 DS   0H\n       WTO     'AOF9245E ERROR IN DEFINITION (J) WTO MSG'\n       B       AOFMEXIT\n*\n       SPACE   2\nSIGONP DS      0H\n       CLI     4(R3),C','         Check for correct format.\n       BNE     SIGWRONGP1\n       CLI     7(R3),C'\\'         Check for closing terminator.\n       BNE     SIGWRONGP2         Oh well...\n*\n       LA      R1,1(,R3)\n       ST      R1,CVTPARM1\n       LA      R1,=H'3'\n       ST      R1,CVTPARM2\n       LA      R1,WORKAREA\n       ST      R1,CVTPARM3\n       LA      R1,CVTPARMS        Set address\n       CALL    AOFCVTDB           ** convert **\n       LTR     R1,R1\n       BZ      SIGWRONGP3         Invalid data\n       ST      R1,SIGSTART        Remember starting point\n       LA      R1,5(,R3)          Get new start point for convert\n       ST      R1,CVTPARM1\n       LA      R1,=H'2'\n       ST      R1,CVTPARM2\n       LA      R1,WORKAREA\n       ST      R1,CVTPARM3\n       LA      R1,CVTPARMS        Set address\n       CALL    AOFCVTDB           ** convert **\n       LTR     R1,R1\n       BZ      SIGWRONGP4         Invalid data\n       ST      R1,SIGCOUNT        Save count\n************************************************************\n* At this point, we have the parameters needed for text\n* substitution in the os command to be issued.\n************************************************************\n       L       R1,STRLEN        Calculate ...\n       S       R1,SIGSTART      ... length ...\n       AH      R1,=H'1'         ...... remaining\n       LTR     R1,R1            Anything left?\n       BNP     SIGWRONGP7       No, put out error message\n       C       R1,SIGCOUNT      Is it less than what was asked for\n       BNH     SKIP_LOAD        Yes, skip load\n       L       R1,SIGCOUNT              Get count for execute\nSKIP_LOAD DS   0H\n       ST      R1,SIGCOUNT      Save length\n       BCTR    R1,0                     Less one for EX\n       L       R8,STRSTART              Get start address of text\n       L       R5,SIGSTART              Get starting offset\n       C       R5,STRLEN                Check against length\n       BNH     BUMP_STRPTR              If not too high, bump pointer\n       B       SIGWRONGP5               If too high, forget it\nBUMP_STRPTR DS 0H\n       LA      R8,0(R8,R5)              Point to starting point in text\n*                                       for move.\n       BCTR    R8,0                     Get exact correct postition\n       EX      R1,MOVESIG               Move the stuff...\n       B       AR2\nMOVESIG DS     0H\n       MVC     0(*-*,R2),0(R8)    ** executed **\nAR2    DS      0H\n       A       R2,SIGCOUNT              Next char in cmd buffer\n       LA      R3,8(,R3)                Move past \\ stuff in AOF table\n       SH      R4,=H'9'\n       LTR     R4,R4\n       BM      SIGWRONGP6\n       B       CMNDLOOP\nSIGWRONGP1 DS    0H\n       WTO     'AOF92061E ERROR IN DEFINITION (S) WTO MSG'\n       B       AOFMEXIT\nSIGWRONGP2 DS    0H\n       WTO     'AOF92062E ERROR IN DEFINITION (S) WTO MSG'\n       B       AOFMEXIT\nSIGWRONGP3 DS    0H\n       WTO     'AOF92063E ERROR IN DEFINITION (S) WTO MSG'\n       B       AOFMEXIT\nSIGWRONGP4 DS    0H\n       WTO     'AOF92064E ERROR IN DEFINITION (S) WTO MSG'\n       B       AOFMEXIT\nSIGWRONGP5 DS    0H\n       WTO     'AOF92065E ERROR IN DEFINITION (S) WTO MSG'\n       B       AOFMEXIT\nSIGWRONGP6 DS    0H\n       WTO     'AOF92066E ERROR IN DEFINITION (S) WTO MSG'\n       B       AOFMEXIT\nSIGWRONGP7 DS    0H\n       WTO     'AOF92067E ERROR IN DEFINITION (S) WTO MSG'\n       B       AOFMEXIT\n*\nSIGONW DS      0H\n       CLI     7(R3),C'\\'               Termination for w directive\n       BNE     SIGWBAD                 Shucks\n       MVC     SEPCHAR(4),1(R3)        Get separator characters\n       LA      R1,5(,R3)               Get start for convert rtn\n       ST      R1,CVTPARM1\n       LA      R1,=H'2'\n       ST      R1,CVTPARM2\n       LA      R1,WORKAREA\n       ST      R1,CVTPARM3\n       LA      R1,CVTPARMS        Set address\n       CALL    AOFCVTDB                Get decimal\n       LTR     R1,R1                   Check it out\n       BZ      SIGWBAD\n       ST      R1,WORDREQ              This is the requested word\n       CH      R1,=H'20'               But is it ok?\n       BH      SIGWBAD                 No\n************************************************************\n* Now, we must set up the parse routine. The general idea is to\n* parse the wto msg into user defined words, and then get the one\n* he wants.\n************************************************************\n       L       R8,STRSTART        Get address of string\n       ST      R8,PARS1           Theres operand number 1\n*\n       MVC     PARS2(4),STRLEN    Length of WTO messages\n*\n       LR      R8,R2\n       LR      R5,R3\n       LA      R2,PARARRAY\n       L       R3,=A(LPARRAY)\n       SLR     R0,R0\n       SLR     R1,R1\n       ICM     R1,B'1000',=C' '\n       MVCL    R2,R0\n       LR      R2,R8\n       LR      R3,R5\n*      MVI     PARARRAY,X'40'\n*      MVC     PARARRAY+1(255),PARARRAY      Blank out PARARRAY\n*      MVC     PARARRAY+256(LPARRAY-256),PARARRAY\n       MVC     PARARRAY(2),=H'20'           Max of 20 tokens.\n       LA      R8,PARARRAY\n       ST      R8,PARS3\n*\n       LA      R8,SEPCHAR\n       ST      R8,PARS4\n*\n       LA      R1,PARSPARM\n       CALL    AOFPARS           ** P A R S E   I T   **\n       LH      R8,PARARRAY       How many did we get back\n       C       R8,WORDREQ        See how many he wanted\n       BL      NOWORDS           Not enough words.. forget it.\n       LA      R8,PARARRAY+2     Point to word number 1\n       L       R5,WORDREQ        Get words requested\n       BCTR    R5,0\n       SLL     R5,6              Multiply by 64\n       LA      R8,0(R5,R8)       Point to token... now we get length\n       ST      R8,TOKADDR        Remember where token was found.\n       XR      R5,R5\n       LA      R1,64             Tokens are 64 bytes long\n************************************************************\n* At this point, r8 points to the token returned by the parse routine\n************************************************************\nWLOOP  DS      0H\n       CLI     0(R8),C' '\n       BE      ENDTOKEN\n       LA      R5,1(,R5)\n       LA      R8,1(,R8)\n       BCT     R1,WLOOP\nENDTOKEN DS    0H\n       ST      R5,LWORDREQ       Store length of requested word\n************************************************************\n* At this point, we have all the information needed to do  *\n* the parameter substitution. R2 points to the spot to     *\n* substitute.                                              *\n************************************************************\n       L       R5,LWORDREQ              Get length of word\n       BCTR    R5,0                     Minus 1 for execute\n       L       R8,TOKADDR\n       EX      R5,MOVEWORD\n       B       AR3\nMOVEWORD DS    0H\n       MVC     0(*-*,R2),0(R8)    ** executed **\nAR3    DS      0H\n       A       R2,LWORDREQ\n       LA      R3,8(,R3)\n       SH      R4,=H'9'\n       LTR     R4,R4\n       BM      SIGWBAD\n       B       CMNDLOOP\n*\nSIGONL DS      0H\n       CLI     4(R3),C'\\'               Termination for L directive\n       BNE     SIGLBAD                 Shucks\n       LA      R1,1(,R3)               Get start for convert rtn\n       ST      R1,CVTPARM1\n       LA      R1,=H'3'\n       ST      R1,CVTPARM2\n       LA      R1,WORKAREA\n       ST      R1,CVTPARM3\n       LA      R1,CVTPARMS         Set address\n       CALL    AOFCVTDB                Get decimal\n       LTR     R1,R1                   Check it out\n       BZ      SIGLBAD\n       ST      R1,LINEREQ              Save the redquested line\n       C       R1,MSGLCNT       Is it more than the lines available?\n       BH      SIGLBAD          Yes, let her know\n       LA      R5,MSGENTRY         Get address of text\n       S       R1,=F'1'\n       SLL     R1,7                Multiply by 128\n       LA      R0,2(R1,R5)         Point to MLWTO line specified\n       ST      R0,STRSTART\n       LH      R1,0(R1,R5)         get text length\n       ST      R1,STRLEN           Save length for later\n       LA      R3,5(,R3)\n       SH      R4,=H'6'\n       LTR     R4,R4\n       BM      SIGLBAD\n       B       CMNDLOOP\n************************************************************\n* Issue error messages\n************************************************************\nNOWORDS  DS    0H\n       WTO     'AOF9207E NOT ENOUGH TOKENS IN WTO TO PROCESS'\n       B       AOFMEXIT\nSIGWBAD  DS    0H\n       WTO     'AOF9208E ERROR PROCESSING W DIRECTIVE- MSG IGNORED'\n       B       AOFMEXIT\nSIGLBAD  DS    0H\n       WTO     'AOF9209E ERROR PROCESSING L DIRECTIVE- ENTRY IGNORED'\n       B       AOFMEXIT\nSIGWRONG DS    0H\n       WTO     'AOF9210E ERROR IN DEFINITION FOR WTO MSG'\n       B       AOFMEXIT\n************************************************************\n* Issue command\n************************************************************\nISSUECMD DS    0H\n       TM      AOFMFLG,X'20'            Was OSCMD specified ?\n       BNO     ISSURCMD                Go issue real command\n************************************************************\n* Here, we will not issue the command, but we will WTO out what the\n* command would have been\n************************************************************\n       MVC     WTO1+11(L'MVSCMDTX),MVSCMDTX\n       WTO     MF=(E,WTO1)            (MSG 207) defined in this module\n       B       GETNEXT            Try the next AOF table entry\n*\nISSURCMD DS    0H\n       MVC     WTO1+11(L'MVSCMDTX),MVSCMDTX\n       CLC     AOFECHO,=CL2'NO'                Echo on ?\n       BE      ECHOOFF1                        No, go issue command\n       CLC     AOFECHO,=CL2'LO'                Echo on for logging ?\n       BE      ECHOLOG1\n       CLC     AOFECHO,=CL2'YE'                Echo on ?\n       BE      ECHOYES1\nECHOOFF1 DS    0H\n       B       AFTECHO1                        No echo, what a shame\n*\nECHOYES1 DS    0H\n       WTO     MF=(E,WTO1)         (MSG207)\n       B       AFTECHO1                        Echo to mastcons\n*\nECHOLOG1 DS    0H\n       MVC     WTL1+11(L'MVSCMDTX),MVSCMDTX\n       WTL     MF=(E,WTL1)\n       B       AFTECHO1\n*\nAFTECHO1 DS    0H\n       MODESET MF=(E,SUP0)        Sup state, key 0 for MSGCRE\n       LA      R2,MVSCMD          Get address of length field\n       MGCRE   TEXT=(R2),         Point text to CIB data length field  X\n               CONSID=MSGCNID,    Issue from my console                X\n               CART=MSGMCART,     Use input CART to correlate response X\n               MF=(E,MGCREPL)     List form in MGCREPL\n       MODESET MF=(E,PROB)        Back to problem state, key\n       B       GETNEXT\n*\n***********************************************************************\n* This is the entry point for the AOF reply function. The idea        *\n* here is to intercept the WTOR, format a reply command of the form   *\n* R NNNN,MSG-TEXT where NNNN is picked up from the MSGMRPYI\n* field and MSG-TXT is picked up from the AOF table.\n* The REPLY command is used to reply to those messages.\n***********************************************************************\nAOFMRPLY DS    0H\n       MVI     REPLYMSG,X'40'\n       MVC     REPLYMSG+1(L'REPLYMSG-1),REPLYMSG   Clear replymsg\n       MVC     REPLY(2),=Y(REPLYLEN) Length of reply buffer\n       MVC     REPLYCMD,=C'R '\n       LA      R8,MSGMRPYI\n       LA      R1,REPLYMSG\n       LA      R2,L'MSGMRPYI\nREPLYNUM_LOOP DS 0H\n       CLC     0(1,R8),=C' '\n       BE      GOT_REPLYNUM\n       MVC     0(1,R1),0(R8)\n       LA      R8,1(R8)\n       LA      R1,1(R1)\n       BCT     R2,REPLYNUM_LOOP\nGOT_REPLYNUM  DS 0H\n       MVI     0(R1),C','\n       LH      R2,AOFACTL               Pick up length of reply\n       BCTR    R2,0\n       EX      R2,MOVERPLY        Move in automatic reply\n       B       AR4\nMOVERPLY DS    0H\n       MVC     1(*-*,R1),AOFACT   ** executed **\n***********************************************************************\n* The reply directive is supported by the echo facility. Check to see *\n* if the tabentry macro specified echo= on the card, and take action  *\n***********************************************************************\nAR4      DS    0H\n       MVC     WTO1+11(L'REPLYMSG+L'REPLYCMD),REPLYCMD\n       CLC     AOFECHO,=CL2'NO'                Echo on ?\n       BE      ECHOOFF2                        No, go issue command\n       CLC     AOFECHO,=CL2'LO'                Echo on for logging ?\n       BE      ECHOLOG2\n       CLC     AOFECHO,=CL2'YE'                Echo on ?\n       BE      ECHOYES2\nECHOOFF2 DS    0H\n       B       AFTECHO2                        No echo, what a shame\n*\nECHOYES2 DS    0H\n       WTO     MF=(E,WTO1)\n       B       AFTECHO2                        Echo to mastcons\n*\nECHOLOG2 DS    0H\n       MVC     WTO1+11(L'REPLYMSG+L'REPLYCMD),REPLYCMD\n       WTL     MF=(E,WTL1)\n       B       AFTECHO2\nAFTECHO2 DS    0H\n       MODESET MF=(E,SUP0)        Sup state, key 0 for SVC34\n       LA      R2,REPLY           Get address of length field\n       MGCRE   TEXT=(R2),         Point text to CIB data length field  X\n               CONSID=MSGCNID,    Issue from my console                X\n               CART=MSGMCART,     Use input CART to correlate response X\n               MF=(E,MGCREPL)     List form in MGCREPL\n       MODESET MF=(E,PROB)        Back to problem state, key\n       B       GETNEXT\n***********************************************************************\n* This is the entry point for the AOF post routine, allowing the      *\n* caller to wait on a given message or AOF msg id before being posted *\n* The caller will be the AOFWAIT REXX function.                       *\n* Standard AOF action is the following:                               *\n*                                                                     *\n* 1) Determine if the current message is active. If not, terminate    *\n*    immediately.                                                     *\n*                                                                     *\n* 2) Use IEANTRT to retrive the token that contains the ASCB and ECB  *\n*    pointers                                                         *\n*                                                                     *\n* 3) Post the ECB in the specified address space                      *\n*                                                                     *\n* 4) Go to next entry.                                                *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n*                                                                     *\n* Set up name_token parm lists\n*\n***********************************************************************\nAOFMPOST DS    0H\n       MVC     NT_NAME,NT_NAMEC\n       MVI     NT_ENTRYID,C' '\n       MVC     NT_ENTRYID+1(L'NT_ENTRYID-1),NT_ENTRYID\n       MVC     NT_ENTRYID(L'AOFENTR),AOFENTR\n       LA      R1,NT_LEVEL\n       ST      R1,NTRT_PARMLIST\n       LA      R1,NT_NAME\n       ST      R1,NTRT_PARMLIST+4\n       LA      R1,NT_TOKEN\n       ST      R1,NTRT_PARMLIST+8\n       LA      R1,NT_RETCODE\n       ST      R1,NTRT_PARMLIST+12\n       XC      NT_RETCODE,NT_RETCODE\n***********************************************************************\n*                                                                     *\n*        Call IEANTRT                                                 *\n*                                                                     *\n***********************************************************************\n       USING   PSA,0\n       L       R15,CVTPTR                 Get the CVT pointer\n       USING   CVTMAP,R15\n       L       R15,CVTCSRT\n       DROP    R15\n       L       R15,X'14'(R15,0)\n       L       R15,X'08'(R15,0)            Get address of IEANTRT\n       LA      R1,NTRT_PARMLIST\n       BALR    R14,R15\n       L       R15,NT_RETCODE\n       LTR     R15,R15\n       BNZ     ENDPOST\n       L       R2,NT_ECBPTR     Pick up ECB to post....\n       L       R3,NT_ASCBPTR    And get the address space.\n       POST    (R2),X'000',ASCB=(R3),ERRET=ENDPOST,MF=(E,POST1)\nENDPOST DS     0H\n       B       GETNEXT\n***********************************************************************\n* AOF has performed the requested function, however, we can now\n* continue to scan the AOF table, in hopes of finding another\n* table entry to match this message id.\n***********************************************************************\nGETNEXT DS     0H                       Get the next entry for msg\n       TM      AOFMFLG,X'10'            Doing MSG=* processing?\n       BO      RUNTABL                  Yes so do all entries\n       CLC     =CL8'ZZZZZZZZ',AOFENTR   Was there an entry name?\n       BE      AOFMEXIT                 No, required actions done\n*\nRUNTABL DS     0H                       Run the rest of table\n       ICM     R7,15,AOFBNXT            Next AOF in bscan chain\n       BNZ     MATCHMSG                 Have same message id\n       TM      AOFMFLG,X'10'            Done MSG=* processing??\n       BZ      TSTALLMG                 No, try the MSG=* type\n       B       AOFMEXIT                 All done with MSG=*\n       EJECT\n       DROP    R7\n       SPACE   2\n***********************************************************************\n* Finished with doing the AOF processing of the message, exit nicely  *\n***********************************************************************\nAOFMEXIT DS    0H\n       STORAGE RELEASE,           free dynamic storage                 X\n               LENGTH=DYNL,                                            X\n               ADDR=(R11)\n       PR                         Exit program\n       DROP    R10                 End major addressability\n       TITLE   'DATA AREAS'\n************************************************************\n*                                                          *\n*        Constants                                         *\n*                                                          *\n************************************************************\nTRHEXTBL EQU   *-X'F0'\n         DC    C'0123456789ABCDEF'\nNT_PERSOPT        DC    A(IEANT_NOPERSIST)    Persist option\nNT_LEVEL          DC    A(IEANT_SYSTEM_LEVEL)\nNT_NAMEC          EQU   *,16\n                  DC    CL4'~AOF'\n                  DC    CL12' '\nINITVALC DS    0F\n* MVSCMD\n         DC    AL2(L'MVSCMDTX+2)\n* MVSCMDTX\n         DC    CL105' '\n* WTO1\n         WTO   '(AOF):                                                 X\n                                                                       X\n                             ',MF=L\n*\n* WTL1\n         WTL   '(AOF):                                                 X\n                                                                       X\n                             ',MF=L\n* MGCREPL\n        MGCRE  MF=(L)             MGCRE parameter list\n* SUP0\n        MODESET MODE=SUP,                                              X\n               KEY=ZERO,MF=L      MODESET parm list for sup, key 0\n* PROB\n        MODESET MODE=PROB,                                             X\n               KEY=NZERO,MF=L MODESET parm list for problem state\n* POST1\n         POST  ,ASCB=0,ERRET=0,MF=L\n*\nINITVALL EQU   *-INITVALC\n         EJECT\n         LTORG ,\n************************************************************\n*                                                          *\n*        DSECTS                                            *\n*                                                          *\n************************************************************\n*---------------------------------------------------------------------*\n*- dynamic area model                                                -*\n*---------------------------------------------------------------------*\nDYNAREA  DSECT\nSAVEAREA DS    18F                Save area\n*\nCVTPARMS DS    3A\n        ORG    CVTPARMS\nCVTPARM1 DS    A\nCVTPARM2 DS    A\nCVTPARM3 DS    A\nBSCANPRM DS    2F\n         ORG   BSCANPRM\nBSCANPRM1 DS   F\nBSCANPRM2 DS   F\nTOFF     DS    H\nWORKAREA DS    CL200            Used for convert routines\n***********************************************************************\n* Variables used to process requests of part 1 of this routine, the   *\n* interface to the oscmd command.                                     *\n*                                                                     *\n***********************************************************************\n*\n*\nCURTABAD DS    A                Current AOF table address we are\n*                               Dealing with\nMSGID    DS    CL12             First 12 bytes of WTO/WTOR\nREPLY    DC    Y(REPLYLEN)         Reply command prefix\nREPLYCMD DC    CL2'R '             Reply command\nREPLYMSG DC    CL109' '\nREPLYLEN EQU   *-REPLYCMD          Length of reply buffer\n***********************************************************************\n* Re-entrant macro definitions...                                     *\n*                                                                     *\n***********************************************************************\nINITVALS DS    0F\nMVSCMD   DC    AL2(L'MVSCMDTX+2)\nMVSCMDTX DC    CL105' '\nWTO1     WTO   '(AOF):                                                 X\n                                                                       X\n                             ',MCSFLAG=(BRDCST,HRDCPY),MF=L\nWTL1     WTL   '(AOF):                                                 X\n                                                                       X\n                             ',MF=L\nMGCREPL MGCRE  MF=(L)             MGCRE parameter list\nSUP0    MODESET MODE=SUP,                                              X\n               KEY=ZERO,MF=L      MODESET parm list for sup, key 0\nPROB    MODESET MODE=PROB,                                             X\n               KEY=NZERO,MF=L MODESET parm list for problem state\nPOST1    POST  ,ASCB=0,ERRET=0,MF=L\n************************************************************\n* Variables used to process test requests in AOF table.\n************************************************************\nWORD1    DS    F                If TYPE=SUBSTR  starting character\n*                               If TYPE=WORD    word number\nWORD2    DS    F                Length of word\nWORDSEPS DS    CL4              Separator charactors for words.\nSTRSTART DS    A                Address of first character of message.\nSTRLEN   DS    A                Length of WTO message\n************************************************************\n* Variables used to process P directive in OSCMD request\n************************************************************\nSIGSTART DS    F                Starting address of significance\nSIGCOUNT DS    F                Number of characters\n************************************************************\n* Variables used to process W directive in OSCMD request\n************************************************************\nSEPCHAR  DS    F           Separator characters for parse\nWORDREQ  DS    F\nLWORDREQ DS    F\nTOKADDR  DS    F           Address of requested token in\n*                          parse array\n************************************************************\n* Variables used to process L directive in OSCMD request\n************************************************************\nLINEREQ  DS    F\n*\n************************************************************\n* Variables used to process post request\n************************************************************\nNT_TOKEN      DS    4A       Token\n              ORG   NT_TOKEN\nNT_ECBPTR     DS    A\nNT_ASCBPTR    DS    A\n              ORG\nNT_NAME       DS    CL16\n              ORG   NT_NAME\nNT_PREFIX     DS    CL4'~AOF'\nNT_ENTRYID    DS    CL12' '\n              ORG\nNT_RETCODE    DS    F'0'\nNTRT_PARMLIST   DS    4A\n*\n************************************************************\n* Flags used in processing requests\n************************************************************\nAOFMFLG  DS    X\n* X'80'  NOT USED\n* X'40'  NOT USED\n* X'20'  OSCMDT WAS SPECIFIED\n* X'10'  MSG=* PROCESSING\n************************************************************\n* Parse parameters\n************************************************************\nPARSPARM DS    0A\nPARS1    DS    A\nPARS2    DS    A\nPARS3    DS    A\nPARS4    DS    A\nPARARRAY DS    CL2,20CL64  Space for count and 20 items\nLPARRAY  EQU   *-PARARRAY\nDYNL    EQU    *-DYNAREA          Dynamic area length\n         AOFNTRY\n         AOFCB\n         MSGCB\n         IEAVG132 ,\n         IEAVM105 ,\n         PRINT ON, NOGEN\n         CVT   DSECT=YES\n         IHAPSA\n         IEANTASM\n         END   AOFMATCH\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AOFMCS": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x11\\x00A\\x01\\x07'\\x8f\\x01\\x18\\x07\\x9f\\x13!\\x03\\xb9\\x03\\x93\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@\"", "ispf": {"version": "01.17", "flags": 0, "createdate": "2007-10-05T00:00:00", "modifydate": "2018-03-20T13:21:41", "lines": 953, "newlines": 915, "modlines": 0, "user": "GIBSONJ"}, "text": "        TITLE  'AOFMCS'\n*PROCESS  USING(NOWARN)\nAOFMCS CSECT ,\nAOFMCS AMODE 31\nAOFMCS RMODE ANY\n*---------------------------------------------------------------------*\n*- AOFMCS: PROGRAM ENTRY POINT, APF AUTHORIZATION REQUIRED           -*\n*-                                                                   -*\n*-                                                                   -*\n*-                                                                   -*\n*-                                                                   -*\n*- Function: An example showing how to use the extended console      -*\n*-           programming interface to activate a console, deactivate -*\n*-           a console, receive messages, process MDB objects, and   -*\n*-           listen for console alerts.                              -*\n*-                                                                   -*\n*-           This example also illustrates use of some other MVS     -*\n*-           operations facilities including:                        -*\n*-           the MODIFY/STOP interface (using EXTRACT and QEDIT),    -*\n*-           CONVCON to see if a console is active,                  -*\n*-           MGCRE to issue system commands,                         -*\n*-           WTO using the TEXT key,                                 -*\n*-           and DOM to delete a held message.                       -*\n*-                                                                   -*\n*-           This program is intended to be used as an example or    -*\n*-           skeleton for use of those services.  It is not intended -*\n*-           to provide any other useful function.                   -*\n*-                                                                   -*\n*-         AOFMCS responds to the following MODIFY commands:         -*\n*-                                                                   -*\n*-              ACTIVATE <optional console name>                     -*\n*-                 to activate its extended console                  -*\n*-                                                                   -*\n*-              DEACTIVATE                                           -*\n*-                 to deactivate its extended console                -*\n*-                                                                   -*\n*-              RELOAD <optional AOF table name>                     -*\n*-                 to reload AOF table                               -*\n*-                                                                   -*\n*-           Any other modify command will be ignored                -*\n*-                                                                   -*\n*-         AOFMCS is implemented as a reentrant program.    It must  -*\n*-           be APF authorized.  Wherever possible it runs problem   -*\n*-           state, key 8.                                           -*\n*-                                                                   -*\n*- Operation:                                                        -*\n*-     initialization                                                -*\n*-     main router loop                                              -*\n*-       if done, exit                                               -*\n*-       if message queued, process all messages                     -*\n*-          process all MDBs in the message                          -*\n*-            determine object type                                  -*\n*-            call appropriate processing routine                    -*\n*-       if alert posted, process the alert                          -*\n*-          display any alert conditions                             -*\n*-          this code    doesn't try to recover from any alert       -*\n*-           conditions, it just deactivates the console             -*\n*-       if modify or stop queued, process the CIB                   -*\n*-          when CIB is a modify, determine command                  -*\n*-             when 'RELOAD' reload the AOF table                    -*\n*-             when 'ACTIVATE' the console is activated              -*\n*-             when 'DEACTIVATE' the console is deactivated          -*\n*-             otherwise complain about invalid command              -*\n*-          when CIB is a stop, set done flag                        -*\n*-          delete the CIB                                           -*\n*-                                                                   -*\n*- NOTE: This is a re-entrant program, but should be assembled   @P1A-*\n*-       without the PARM=RENT option. If PARM=RENT is used,     @P1A-*\n*-       the assembler will issue warning messages saying        @P1A-*\n*-       \"RE-ENTRANT CHECK FAILED\".                              @P1A-*\n*-       Dynamic variables should be added between the labels    @P1A-*\n*-       DYNMODEL and DYNL.                                      @P1A-*\n*-                                                                   -*\n*---------------------------------------------------------------------*\n* begin AR mode linkage convention\n       BAKR    R14,0              save regs\n       LR      R6,R1              Save parm pointer\n       SAC     512                set AR mode\n       SYSSTATE ASCENV=AR         let macros know\n       LAE     R12,0(R15,0)       base and address regs\n       USING   AOFMCS,R12         addressability\n       MODID   ,                  eye catcher and date\n       STORAGE OBTAIN,LENGTH=DYNL get dynamic storage\n       LAE     R11,0(0,R1)        use R11 as dyn base\n       LAE     R2,DYNMODEL        address of dynamic area model\n       L       R3,=A(DYNL)        length of dynamic area\n       LAE     R4,0(0,R11)        address of dynamic area\n       LR      R5,R3              length of dynamic area\n       MVCL    R4,R2              copy model to dynamic area\n       USING   DYNMODEL,R11       map model over dynamic area\n       LAE     R13,SV             put save area addr in R13\n       MVC     4(4,R13),=C'F1SA'  set acro in save area\n       STORAGE OBTAIN,LENGTH=MSGCBL Get storage\n       LAE     R10,0(0,R1)        use R10 as MSGCB base\n       USING   MSGCB,R10          map model over dynamic area\n       XC      MSGLCNT,MSGLCNT    Clear line count\n* end AR mode linkage convention\n* begin initialization\n       SAC     0                  set primary mode\n       SYSSTATE ASCENV=P          let macros know\n       LA      R9,COMADDR         get address for com area\n       EXTRACT (R9),FIELDS=COMM,  extract the com area                 X\n               MF=(E,EXTRACT)\n       L       R9,COMADDR         get address of the area\n       USING   COM,R9             use R9 as base address of comm area\n       ICM     R7,15,COMCIBPT     get address of the CIB\n       BZ      NOCIB              no start CIB\n       BAL     R14,DOCIB          process the CIB\nNOCIB  DS      0H\n       QEDIT   ORIGIN=COMCIBPT,                                        X\n               CIBCTR=1           set modify limit to 1\n       L       R1,COMECBPT        get address of the com ecb\n       O       R1,=X'80000000'    set high bit - last ecb in list\n       ST      R1,MODECB          put addr of modify ecb in list\n       LA      R1,ECB             get addr of message ecb\n       ST      R1,MECB            put into ecb list\n       LA      R1,ALERT           get addr of alert ecb\n       ST      R1,AECB            put into ecb list\n       MVC     CMDRSP,STRTD       started task, init msg back to cons\n       LA      R1,INITMSG         get initialization message\n       BAL     R14,MESSR          display message\n       MVI     CMDRSP,0           make sure command response reset\n       MVC     TRUTABN,=CL8'AOFTABLE'\n       L       R1,0(,R6)          point to first parameter\n       LTR     R1,R1\n       BZ      LINKAOF\n       LH      R2,0(,R1)\n       LTR     R2,R2\n       BZ      LINKAOF\n       CH      R2,=H'8'\n       BNH     GETPARM\n       LA      R1,BADPARM         get error message\n       BAL     R14,MESSR          show it\n       B       LINKAOF\nGETPARM DS     0H\n       MVC     TRUTABN,=CL8' '\n       LA      R1,2(,R1)\n       BCTR    R2,0\n       EX      R2,MVCTBLNM\n       B       LINKAOF\nMVCTBLNM MVC   TRUTABN(*-*),0(R1) Set table name\nLINKAOF DS     0H\n       LA      R1,AOFCB           Point to paramter list\n       MVC     LINK1D(LINK1CE-LINK1C),LINK1C\n       LINK    EP=AOFLOAD,SF=(E,LINK1D)\n       LTR     R15,R15\n       BZ      INITCON\n       MVI     DONE,0\nINITCON DS     0H\n       L       R2,CVTPTR          get the cvt pointer\n       USING   CVTMAP,R2\n       MVC     CNAME(4),CVTSNAME  Move system to CNAME\n       MVC     CNAME+4(4),=C'AOFC'  default name if none supplied\n       L       R1,PSAAOLD-PSA(,R0)  Get ASCB Pointer\n       MVC     MYASID,ASCBASID-ASCB(R1) Save my ASID\n       DROP    R2\n       BAL     R14,ACTCON\n       B       LOOP\n* end initialization\n*---------------------------------------------------------------------*\n*-                                                                   -*\n*- LOOP:     ASCMODE=PRIMARY, IN-LINE ENTRY                          -*\n*- Function: Main processing loop; watch for done and posted ECBs    -*\n*- Operation:                                                        -*\n*-     if done then exit                                             -*\n*-     wait for ecb post (message, alert, or modify/stop)            -*\n*-     if message ecb posted, call GETMSGS                           -*\n*-     if alert ecb posted, call DOALERT                             -*\n*-     if modify/stop ecb posted, call DOCIB                         -*\n*-     go back to top of loop                                        -*\n*-                                                                   -*\n*---------------------------------------------------------------------*\nLOOP   DS      0H                 main processing loop\n       CLI     DONE,0             check for termination\n       BZ      WAIT               no, do wait\n       STORAGE RELEASE,           free dynamic storage                 X\n               LENGTH=DYNL,                                            X\n               ADDR=(R11)\n       STORAGE RELEASE,           free dynamic storage                 X\n               LENGTH=MSGCBL,                                          X\n               ADDR=(R10)\n       PR                         exit program\nWAIT   DS      0H\n       WAIT    ECBLIST=ECBS       wait for a message/alert/modify/stop\n       L       R1,ECB             get msg ecb\n       N       R1,=X'40000000'    check for post\n       BZ      CKALRT             not set, check alert\n       XC      ECB,ECB            clear message ecb\n       BAL     R14,GETMSGS        process the message\nCKALRT DS      0H\n       L       R1,ALERT           get alert ecb\n       N       R1,=X'40000000'    check for post\n       BZ      CKCIB              not posted, check modify\n       XC      ALERT,ALERT        clear alert ecb\n       BAL     R14,DOALERT        process alert\nCKCIB  DS      0H\n       ICM     R1,15,COMCIBPT     get CIB pointer\n       BZ      LOOP               no CIB, back to main loop\n       BAL     R14,DOCIB          process the CIB (QEDIT takes care of X\n                                  the ECB)\n       B       LOOP               back to main loop\n*---------------------------------------------------------------------*\n*-                                                                   -*\n*- GETMSGS:  BRANCH ENTERED ASCMODE=PRIMARY, sets ASCMODE=AR         -*\n*- Function: process all messages queued to this console             -*\n*- Operation:                                                        -*\n*-     invoke MCSOPMSG in supervisor state                           -*\n*-     when a message is returned (GOTMDB)                           -*\n*-        loop through the mdb objects                               -*\n*-          when general object, call GOTMDBG                        -*\n*-          when control prog object, call GOTMDBC                   -*\n*-          when text object, call GOTMDBT                           -*\n*-          otherwise unknown object type                            -*\n*-     when an error occurs in MCSOPMSG (GOTERR)                     -*\n*-        put out error message                                      -*\n*-        set done flag to exit program                              -*\n*-     return to caller                                              -*\n*-                                                                   -*\n*---------------------------------------------------------------------*\n       SYSSTATE ASCENV=P          let macros know primary mode\nGETMSGS DS     0H\n       BAKR    R14,0              save caller environment\nMSGLP  DS      0H\n       L       R8,MSGCNID         load the console id in reg 8     @P4A\n       LTR     R8,R8              is the id = 0 (ie was it             X\n                                           deactivated?            @P4A\n       BZ      LVGETM             then leave this proc - no msgs       X\n                                           to receive              @P4A\n       SAC     0                  set primary mode for modeset\n       MODESET MF=(E,SUP)         set sup state\n       SAC     512                this procedure runs in AR mode\n       SYSSTATE ASCENV=AR         let macros know\n       MCSOPMSG REQUEST=GETMSG,   get a message                        X\n               NAME=CNAME,        my console name                  @P5CX\n               RTNCODE=RC,        save return code                     X\n               RSNCODE=RSN,       save reason code                     X\n               MF=(E,MCSOPMPL)\n       LAE     R8,0(0,R1)         put mdb address in R8\n       USING   MDB,R8             addressability to the mdb\n       SAC     0                  set primary mode for modeset\n       SYSSTATE ASCENV=P          let macro know\n       MODESET MF=(E,PROB)        set problem state\n       SAC     512                this procedure runs in AR mode\n       SYSSTATE ASCENV=AR         let macros know\n       MVI     MDBFLGS,0          clear processing flags\n       MVI     CMDRSP,0           assume not issuing command response\n       LA      R15,8              looking for message returned\n       C       R15,RC             see if any messages\n       BH      GOTMDB             process it (rc<8)\n       BL      GOTERR             some kind of error (rc>8)\n       PR                         no more messages (rc=8)\nGOTERR DS      0H\n       LA      R1,BADGET          get error message\n       BAL     R14,MESSR          show it\n       MVI     DONE,1             set done flag\nLVGETM EQU     *                  Exit point of GETMSGS            @P4A\n       PR                         return error message\n*---------------------------------------------------------------------*\n*-                                                                   -*\n*- GOTMDB:   ENTRY VIA BRANCH (NOT A SUBROUTINE)                     -*\n*- Function: Process the general object and control program object   -*\n*-           for a message.  Assumptions must not be made that these -*\n*-           objects will preceed any text objects.                  -*\n*- Operation:                                                        -*\n*-     find end of MDB                                               -*\n*-     loop through objects                                          -*\n*-         when general object                                       -*\n*-           call GOTMDBG to process general object                  -*\n*-         when control program object                               -*\n*-           call GOTMDBC to process control program object          -*\n*-         otherwise ignore object                                   -*\n*-       if both objects found, go process text objects              -*\n*-       skip to next object                                         -*\n*-         add object length                                         -*\n*-         if end of MDB, this MDB does not have proper objects      -*\n*-           to process as a message; just ignore it                 -*\n*-                                                                   -*\n*---------------------------------------------------------------------*\nGOTMDB DS      0H\n       LR      R5,R8              calc end of mbd in R5\n       AH      R5,MDBLEN          start+mdblen in header\n       LR      R6,R8              remember start of MDB for pass 2\n       LA      R8,MDBHLEN(R8)     bump to 1st object\nOBJLP  DS      0H                 loop through the objects\n       LH      R3,MDBTYPE         get type\n       C       R3,=A(MDBGOBJ)     check for general object\n       BNE     NOTG               not general object\n       TM      MDBFLGS,MDBFGO     see if first general object\n       BO      CHKASID            no, skip it\n       BAL     R14,GOTMDBG        process general object\n       B       CHKASID            bump to next object\nNOTG   DS      0H\n       C       R3,=A(MDBCOBJ)     check for control prog object\n       BNE     NOTC               not control prog object\n       TM      MDBFLGS,MDBFCO     see if first control prog object\n       BO      CHKASID            no, skip it\n       BAL     R14,GOTMDBC        process control prog object\n       B       CHKASID            bump to next object\nNOTC   DS      0H                 not control prog obj\nCHKASID DS     0H                 find next object\n       CLC     MSGMASID,MYASID    Is the messge coming from me?\n       BE      NXTOBJ             Yes, skip it\n       TM      MDBFLGS,MDBFGO+MDBFCO see if we found general and SCP\n       BO      FNDTXT             got them, loop through text objs\nNXTOBJ DS      0H                 find next object\n       AH      R8,MDBLEN          bump to next object\n       CR      R8,R5              see if this is the end\n       BL      OBJLP              no, get another object\n       B       MSGLP              missing necessary objects, skip it\n*---------------------------------------------------------------------*\n*-                                                                   -*\n*- FNDTXT:   ENTRY VIA BRANCH (NOT A SUBROUTINE)                     -*\n*- Function: Process all text objects in all MDBs for this message.  -*\n*-           Text objects are always ordered, but it cannot be       -*\n*-           assumed that they are contiguous.                       -*\n*- Operation:                                                        -*\n*-     find end of MDB                                               -*\n*-     get pointer to next MDB in message                            -*\n*-     loop through MDBs                                             -*\n*-        loop through objects                                       -*\n*-            when text object                                       -*\n*-              call GOTMDBT to store text object                    -*\n*-            otherwise ignore object                                -*\n*-          skip to next object                                      -*\n*-            add object length                                      -*\n*-            if end of MDB, call AOF to process message             -*\n*-              move to next MDB                                     -*\n*-                                                                   -*\n*---------------------------------------------------------------------*\nFNDTXT DS      0H\n       LR      R8,R6              reset R8 to start of MDB\nTXTLP  DS      0H\n       LR      R5,R8              calc end of mbd in R5\n       AH      R5,MDBLEN          start+mdblen in header\n       LAE     R6,0(0,R8)         calc prefix address in R6\n       SH      R6,=AL2(MDBPLNNO)  prefix=start-prefix length\n       USING   MDBPRFX,R6         get addressability\n       L       R6,MDBPNEXT        get forward pointer in R6\n       DROP    R6                 R6 no longer base for prefix\n       LA      R8,MDBHLEN(R8)     bump to 1st object\n       SLR     R4,R4              zero line count\n       ST      R4,MSGLCNT         Store line count\n       LA      R1,MSGENTRY        Get address of start of messages\n       S       R1,=A(L'MSGENTRY)  Go back one entry length\n       ST      R1,MSGLAST         And save address of next message\nTOBJLP DS      0H                 loop through the objects\n       LH      R3,MDBTYPE         get type\n       C       R3,=A(MDBTOBJ)     check for text object\n       BNE     NOTT               not text object\n       BAL     R14,GOTMDBT        process text object\nNOTT   DS      0H\n       AH      R8,MDBLEN          bump to next object\n       CR      R8,R5              see if this is the end\n       BL      TOBJLP             no, get another object\n       LTR     R6,R6              check for more MDBs for message\n       BZ      TXTDONE            done with message\n       LR      R8,R6              next mdb\n       B       TXTLP              process the mdb\nTXTDONE DC     0H\n       SAC     0                  set primary mode for AOFMATCH\n       SYSSTATE ASCENV=P          let macro know\n       LA      R1,AOFCB\n       ST      R1,MATCHPRM1\n       LA      R1,MSGCB\n       ST      R1,MATCHPRM2\n       LA      R1,MATCHPRMS\n       CALL    AOFMATCH\n       SAC     512                this procedure runs in AR mode\n       SYSSTATE ASCENV=AR         let macros know\n       XC      MSGLCNT,MSGLCNT    Clear line count\n       B       MSGLP              done with message\n       DROP    R8\n*---------------------------------------------------------------------*\n*-                                                                   -*\n*- GOTMDBG:  BRANCH ENTERED, ASCMODE=AR, R8=ADDR(general object)     -*\n*- Function: process MDB general object                              -*\n*- Operation:                                                        -*\n*-     establish addressability to the general object                -*\n*-     indicate general object processed                             -*\n*-                                                                   -*\n*---------------------------------------------------------------------*\n       SYSSTATE ASCENV=AR         let macros know AR mode\nGOTMDBG DS     0H\n       BAKR    R14,0              save caller environment\n       USING   MDBG,R8            addressability to general object\n       OI      MDBFLGS,MDBFGO     set processed general object\n       PR\n       DROP    R8\n*---------------------------------------------------------------------*\n*-                                                                   -*\n*- GOTMDBC:  BRANCH ENTERED, ASCMODE=AR, R8=ADDR(control prog object)-*\n*- Function: process MDB control program object                      -*\n*- Operation:                                                        -*\n*-     establish addressability to the control program object        -*\n*-     if this is an MVS object                                      -*\n*-        set flag indicating control prog object found for the msg  -*\n*-        save message text offset for text processing               -*\n*-        if this is a command response message                      -*\n*-           save the CART                                           -*\n*-           indicate that the text echo should be command response  -*\n*-                                                                   -*\n*---------------------------------------------------------------------*\n       SYSSTATE ASCENV=AR         let macros know AR mode\nGOTMDBC DS     0H\n       BAKR    R14,0              save caller environment\n       USING   MDBSCP,R8          addressability to control prog object\n       CLC     MDBCPNAM,=C'MVS '  make sure it is an MVS object\n       BNE     GOTC1              if not, just skip it\n       OI      MDBFLGS,MDBFCO     set processed control prog object\n       LH      R1,MDBCTOFF        get text offset\n       ST      R1,TOFF            save it for text processing\n       TM      MDBCATT1,MDBCMCSC  check if command response\n       BZ      GOTC1              not command response\n       MVI     CMDRSP,1           issue any WTOs as cmd response\nGOTC1  DS      0H\n       MVC     MSGMCART,MDBCCART  hold onto cart\n       MVC     MSGMASID,MDBCASID  hold onto ASID\n       MVC     MSGMJOBN,MDBCOJBN  hold onto JOBNAME\n       MVC     MSGMRPYI,MDBCRPYI  hold onto Reply ID\n       MVC     MSGCSUPB,MDBCSUPB  hold onto Suppression byte\n       MVC     MSGCDESC,MDBCDESC  hold onto Descriptor codes\n       PR\n       DROP    R8\n*---------------------------------------------------------------------*\n*-                                                                   -*\n*- GOTMDBT:  BRANCH ENTERED, ASCMODE=AR, R8=ADDR(text object)        -*\n*- Function: process MDB text objects                                -*\n*- Operation:                                                        -*\n*-     establish addressability to the text object                   -*\n*-     calculate the length of the text                              -*\n*-     move it to a buffer                                           -*\n*-     set the length                                                -*\n*-     R4 contains line count for MLWTOs                             -*\n*-                                                                   -*\n*---------------------------------------------------------------------*\n       SYSSTATE ASCENV=AR         let macros know AR mode\nGOTMDBT DS     0H\n       BAKR    R14,0              save caller environment\n       L       R1,MSGLCNT\n       C       R1,=F'255'         Reached maximum number of lines?\n       BNL     GOTTX              Yes, can't do any more\n       A       R1,=F'1'           Add one to line count\n       ST      R1,MSGLCNT         and save it\n       USING   MDBT,R8            addressability to text object\n       LH      R1,MDBTLEN         get text object length\n       S       R1,=A(MDBTMSGT-MDBTLEN) subtract non-text size\n       S       R1,TOFF            take off offset to text\n       S       R1,=F'1'           set up for MVC\n       LAE     R2,MDBTMSGT        get address of text\n       A       R2,TOFF            bump past prefix info\n       L       R3,MSGLAST\n       LA      R3,L'MSGENTRY(,R3)\n       ST      R3,MSGLAST\n       EX      R1,GOTTMVC         move text to buffer\n       LA      R1,1(,R1)\n       STH     R1,0(,R3)          set message length\n*      CLC     0(8,R2),=CL8'$HASP050'\n*      BNE     GOTTX\n*      EX      R0,*\nGOTTX  DS      0H\n       PR\nGOTTMVC DS      0H\n       MVC     2(*-*,R3),0(R2)\n       DROP    R8\n*---------------------------------------------------------------------*\n*-                                                                   -*\n*- DOALERT:  BRANCH ENTERED ASCMODE=PRIMARY, sets ASCMODE=AR         -*\n*- Function: process a console alert notification                    -*\n*- Operation:                                                        -*\n*-     establish addressability the the console status area          -*\n*-     check each alert indicator                                    -*\n*-       if set, put out a message                                   -*\n*-     no error handling is performed this example, just             -*\n*-      deactivate the console on any alert                          -*\n*-                                                                   -*\n*---------------------------------------------------------------------*\nDOALERT DS     0H\n       BAKR    R14,0              save caller environment\n       SAC     512                get into AR mode\n       SYSSTATE ASCENV=AR         let macros know\n       L       R2,CSA             get address of the status area\n       LAM     R2,R2,CSAALET      get ALET for status area\n       USING   MCSCSA,R2          establish addressability\n       CLI     MCSCMLIM,0         reached memory limit?\n       BZ      ALRT1              no\n       LA      R1,MSGMLIM         get error message\n       BAL     R14,MESSR          display it\nALRT1  DS      0H\n       CLI     MCSCDLIM,0         reached queue limit?\n       BZ      ALRT2              no\n       LA      R1,MSGDLIM         get error message\n       BAL     R14,MESSR          display it\nALRT2  DS      0H\n       CLI     MCSCINTR,0         internal error?\n       BZ      ALRT3              no\n       LA      R1,MSGINTR         get error message\n       BAL     R14,MESSR          display it\nALRT3  DS      0H\n       CLI     MCSCALRT,0         reached alert percent?\n       BZ      ALRT4              no\n       LA      R1,MSGALRT         get error message\n       BAL     R14,MESSR          display it\nALRT4  DS      0H\n       LA      R1,ALRMSG          get alert message\n       BAL     R14,MESSR          display it\n       BAL     R14,DEACT          deactivate console\n       PR\n*---------------------------------------------------------------------*\n*-                                                                   -*\n*- DOCIB:    BRANCH ENTERED ASCMODE=PRIMARY                          -*\n*- Function: process all CIBs queued to this job                     -*\n*- Operation:                                                        -*\n*-     loop while there are CIBs                                     -*\n*-        when modify CIB                                            -*\n*-           save requesting console id                              -*\n*-           when activate command                                   -*\n*-              invoke MCSOPER to activate the console               -*\n*-              display acknowledgement or error                     -*\n*-           when deactivate command                                 -*\n*-              invoke MCSOPER to deactivate the console             -*\n*-              display acknowledgement or error                     -*\n*-        when stop CIB                                              -*\n*-           set done indicator                                      -*\n*-        delete the CIB                                             -*\n*-     return to caller                                              -*\n*-                                                                   -*\n*---------------------------------------------------------------------*\n       SYSSTATE ASCENV=P          let macros know primary mode\nDOCIB  DS      0H\n       BAKR    R14,0              save caller environment\n       MVI     CMDRSP,1           issue WTOs as command response\nCIBLP  DS      0H\n       ICM     R7,15,COMCIBPT     get address of the CIB\n       BNZ     SVINFO             got one, check the CIB type\n       MVI     CMDRSP,0           turn off cmd response flag\n       PR                         no, return to caller\n       USING   CIB,R7             CIB based on R7\nSVINFO DS      0H\n       LR      R1,R7              get consid and CART from CIBX\n       AH      R1,CIBXOFF         CIBX=addr(CIB)+CIBXOFF\n       USING   CIBX,R1            get addressability\n       MVC     MYOPER,CIBXCNID get console id that I will talk to\n       MVC     MSGMCART,CIBXCART  keep CART for a cmd response\n       DROP    R1                 done with CIBX\n       CLI     CIBVERB,CIBMODFY   check for modify\n       BNE     CKSTOP             no, try stop\n       CLC     MSGID,=F'0'        do I have a message to be DOMed\n       BE      DOFCMD             no\n       DOM     MSG=MSGID          DOM it\n       XC      MSGID,MSGID        clear held message id\nDOFCMD DS      0H\n       LH      R3,CIBDATLN        get text length in R3\n       C       R3,=A(L'CMDACT)    check cmd length\n       BL      NOTACT             too short\n       CLC     CMDACT(L'CMDACT),CIBDATA  check text\n       BNE     NOTACT             not activate\n       L       R1,MSGCNID         see if I have a console active\n       LTR     R1,R1              any id?\n       BZ      NOCNID             yes, don't activate another\n       LA      R1,DIDACT          error, console already active\n       BAL     R14,MESSR          show message\n       B       DELCIB             done with CIB\nNOCNID DS      0H\n       L       R2,CVTPTR          get the cvt pointer\n       USING   CVTMAP,R2\n       MVC     CNAME(4),CVTSNAME  Move system to CNAME\n       MVC     CNAME+4(4),=C'AOFC'  default name if none supplied\n       DROP    R2\n       LA      R2,L'CMDACT+1      R2-->past activate command\n       SR      R3,R2              remaining chars in command\n       BNP     CALLACT            no console name provided\n       C       R3,=F'8'           no more than 8 chars in console name\n       BH      CALLACT            too much text for name - ignore it\n       MVC     CNAME,=CL8' '      start with a blank name field\n       LA      R2,CIBDATA(R2)     get address of name in the cib\n       S       R3,=F'1'           calc move length\n       EX      R3,MOVECN          do the move\n       B       CALLACT            call actcon routine\nMOVECN DS      0H\n       MVC     CNAME(0),0(R2)     this move instruction is EX'ed\nCALLACT DS     0H                 check if console active using convcon\n       BAL     R14,ACTCON\n       B       DELCIB             done with CIB\nNOTACT DS      0H\n       C       R3,=A(L'CMDDACT)   check for deactivate command\n       BL      NOTDACT            bad length\n       CLC     CMDDACT(L'CMDDACT),CIBDATA check text\n       BNE     NOTDACT            not deactivate command\n       BAL     R14,DEACT          deactivate console\n       B       DELCIB             done with CIB\nNOTDACT DS     0H\n       C       R3,=A(L'CMDRELO)   Check for reload command\n       BL      NOTRELO            Too short\n       CLC     CMDRELO(L'CMDRELO),CIBDATA check text\n       BNE     NOTRELO            not reload command\n       BAL     R14,RELOAD         reload AOF table\n       B       DELCIB             done with CIB\nNOTRELO DS     0H\n       B       DELCIB             done with CIB\nCKSTOP DS      0H\n       CLI     CIBVERB,CIBSTOP    check for stop CIB\n       BNE     CKSTRT             not stop either\n       MVI     DONE,1             signal done\n       ICM     R1,15,MSGCNID      get console id\n       BZ      DELCIB             the console is not active\n       BAL     R14,DEACT          deactivate it\n       B       DELCIB             done with CIB\nCKSTRT DS      0H\n       CLI     CIBVERB,CIBSTART   check for start CIB\n       BNE     DELCIB             CIB not used by this prog\n       MVI     STRTD,1            this is a started task\nDELCIB DS      0H\n       QEDIT   ORIGIN=COMCIBPT,                                        X\n               BLOCK=(R7)         free the CIB\n       B       CIBLP              go look for another\n*---------------------------------------------------------------------*\n*-                                                                   -*\n*- DEACT:     BRANCH ENTERED, SETS ASCMODE=PRIMARY                   -*\n*- Function:  deactivate the console                                 -*\n*- Operation:                                                        -*\n*-     save caller state                                             -*\n*-     set sup state for MCSOPER deactivate                          -*\n*-     if rc is 0 then                                               -*\n*-        set current console id to 0 (MSGCNID)                      -*\n*-        display console deactivated message                        -*\n*-      else                                                         -*\n*-        display deactivation error message                         -*\n*-                                                                   -*\n*---------------------------------------------------------------------*\nDEACT  DS      0H\n       BAKR    R14,0              save caller state\n       SAC     0                  runs in primary mode\n       SYSSTATE ASCENV=P          tell macros\n       MODESET MF=(E,SUP)         set sup state\n       MCSOPER REQUEST=DEACTIVATE,                                     X\n               NAME=CNAME,        deactivate the console           @P5CX\n               RTNCODE=RC,        save return code                     X\n               RSNCODE=RSN,       save reason code                     X\n               MF=(E,MCSOPPL)\n       MODESET MF=(E,PROB)        set problem state\n       ICM     R15,15,RC          get return code\n       BNZ     DACTERR            if non-zero, process error\n       XC      MSGCNID,MSGCNID    zero console id to show not active\n       LA      R1,NOWDACT         get not active message\n       BAL     R14,MESSR          display it\n       PR                         return\nDACTERR DS     0H\n       LA      R1,BADDACT         deactivate error\n       BAL     R14,MESSR          display message\n       PR                         return\n*---------------------------------------------------------------------*\n*-                                                                   -*\n*- ACTCON     BRANCH ENTERED, SETS ASCMODE=PRIMARY                   -*\n*- Function:  activate console                                       -*\n*- Operation:                                                        -*\n*-     save caller state                                             -*\n*-     activate console                                              -*\n*-     if rc is 0 then                                               -*\n*-        display table loaded message                               -*\n*-      else                                                         -*\n*-        display load error message                                 -*\n*-                                                                   -*\n*---------------------------------------------------------------------*\nACTCON DS      0H\n       BAKR    R14,0              save caller state\n       SAC     0                  runs in primary mode\n       SYSSTATE ASCENV=P          tell macros\n*                                 check if console active using convcon\n       XC      CONV(CONVPLEN),CONV clear convcon parm list\n       MVC     CONVACRO,=C'CONV'  set acronym\n       MVI     CONVVRSN,CONVRID   set version\n       OI      CONVFLGS,CONVPFLD  set name to id conversion\n       MVC     CONVFLD,CNAME      set console name\n       OI      CONVGFLG,CONVNPAR  set no area verification\n       CONVCON CONV               call convcon\n       LTR     R15,R15            check rc\n       BNZ     DOACT              branch if not active\n       LA      R1,DIDACT          error, console already active\n       BAL     R14,MESSR          show message\n       B       ENDACT             return\nDOACT  DS      0H\n       LA      R1,OPERPRM         build operparm defaults\n       USING   MCSOPPRM,R1        map area\n       XC      OPERPRM(MCSOPLEN),OPERPRM clear operparm parm list\n       MVI     MCSOAUTH,MCSOMSTR  set master authority\n       MVI     MCSORCFL,MCSORCAL  all route codes\n       MVC     MCSOKEY,CNAME      set key\n       MVC     MCSOSTOR,=H'150'   Set storage limit for messages in MB\n       OI      MCSOMISC,MCSOAUTY  Set to receive auto msgs\n       OI      MCSOMISC,MCSOHDCY  Set to receive harcpy msgs\n       OI      MCSOMSFG,MCSOSLST  Set to list systems for MSCOPE\n       LA      R2,OPERSCP         get address of MSCOPE table\n       ST      R2,MCSOMSPT        Save in parm list\n       USING   MCSOTBL,R2\n       MVC     MCSOMSNM,=F'1'     Only one system for MSCOPE\n       MVC     MCSOTSYS,=CL8'*'   Set to MSCOPE to *\n       DROP    R2\n       MODESET MF=(E,SUP)         set sup state to activate console\n       MCSOPER REQUEST=ACTIVATE,  activate the console                 X\n               NAME=CNAME,        activate name found in CNAME         X\n               TERMNAME=CNAME,    use CNAME for the termname audit     X\n               OPERPARM=OPERPRM,  use my OPERPARMs if none in RACF     X\n               MSGDLVRY=FIFO,     request fifo delivery                X\n               MSGECB=ECB,        ecb to be posted when msg is queued  X\n               ALERTECB=ALERT,    ecb to be posted when alert occurs   X\n               MCSCSA=CSA,        returned status area address         X\n               MCSCSAA=CSAALET,   returned status area alet            X\n               CONSID=MSGCNID,    returned console id                  X\n               RTNCODE=RC,        save return code                     X\n               RSNCODE=RSN,       save reason code                     X\n               MF=(E,MCSOPPL)\n       MODESET MF=(E,PROB)        back to problem state\n       ICM     R15,15,RC          get return code\n       BNZ     ACTERR             if non-zero, process error\n       LA      R1,NOWACT          now active message\n       BAL     R14,MESSR          display it\n       B       ENDACT\nACTERR DS      0H\n       LA      R1,BADINI          console initialization error\n       BAL     R14,MESSR          display message\nENDACT DS      0H\n       PR                         return\n*---------------------------------------------------------------------*\n*-                                                                   -*\n*- RELOAD     BRANCH ENTERED, SETS ASCMODE=PRIMARY                   -*\n*- Function:  reload AOF table                                       -*\n*- Operation:                                                        -*\n*-     save caller state                                             -*\n*-     reload AOF table                                              -*\n*-     if rc is 0 then                                               -*\n*-        display table loaded message                               -*\n*-      else                                                         -*\n*-        display load error message                                 -*\n*-                                                                   -*\n*---------------------------------------------------------------------*\nRELOAD DS      0H\n       BAKR    R14,0              save caller state\n       SAC     0                  runs in primary mode\n       SYSSTATE ASCENV=P          tell macros\n       L       R6,TRUTABL         CHECK TO SEE IF table loaded\n       LTR     R6,R6              WELL.. IS IT ?\n       BZ      NODEL              NO table, NO NEED TO DELETE\n       L       R10,TRUBSTH              GET POINTER TO INDEX TABLE\n       L       R2,0(,R10)               GET LENGTH AND SUBPOOL\n       XC      TRUBSTH(TRUBSTL+4-TRUBSTH),TRUBSTH CLR PTRS\n       XC      TRUTABL,TRUTABL          INDICATE NO POINTER\n       STORAGE RELEASE,           free dynamic storage                 X\n               LENGTH=(R2),                                            X\n               ADDR=(R10)\n       LA      R6,TRUTABN         GET CURRENT TABLE NAME\n       DELETE  EPLOC=(R6)           DELETE IT !\n       MVC     TRUTABN(8),=CL8' '\nNODEL  DS      0H\n       LA      R2,L'CMDRELO+1     R2-->past activate command\n       SR      R3,R2              remaining chars in command\n       BNP     LOADERR            no table name provided\n       C       R3,=F'8'           no more than 8 chars in table name\n       BH      LOADERR            too much text for name - ignore it\n       MVC     TRUTABN,=CL8' '    start with a blank name field\n       LA      R2,CIBDATA(R2)     get address of name in the cib\n       S       R3,=F'1'           calc move length\n       EX      R3,MOVEAOF         do the move\n       B       AOFLOAD            see if it is already active\nMOVEAOF DS     0H\n       MVC     TRUTABN(0),0(R2)   this move instruction is EX'ed\nAOFLOAD DS     0H\n       CLC     TRUTABN,=CL8'NONE'      OPERATOR WANTS NO table loaded?\n       BNE     LOADNTAB                  NO, LOAD NEW TABLE\n*\nLOADNTAB DS    0H\n       LA      R1,AOFCB           Point to paramter list\n       MVC     LINK1D(LINK1CE-LINK1C),LINK1C\n       LINK    EP=AOFLOAD,SF=(E,LINK1D)\n       LTR     R15,R15\n       BNZ     LOADERR            if non-zero, process error\n       PR                         return\nLOADERR DS     0H\n       MVC     TRUTABN,=CL8'NONE' No AOF table loaded\n       LA      R1,BADLOAD         load error\n       BAL     R14,MESSR          display message\n       PR                         return\n*---------------------------------------------------------------------*\n*-                                                                   -*\n*- MESSR:     BRANCH ENTERED, R1=ADDR(message), SETS ASCMODE=PRIMARY -*\n*- Function:  display a message                                      -*\n*- Operation:                                                        -*\n*-       does a WTO of the message passed as the parameter           -*\n*-                                                                   -*\n*---------------------------------------------------------------------*\nMESSR  DS      0H\n       BAKR    R14,0              save caller environment\n       SAC     0                  run in primary mode\n       SYSSTATE ASCENV=P          tell macros primary mode\n       LR      R2,R1              use R2 for text in WTO\n       CLI     CMDRSP,1           check for command response\n       BE      MESSRC             yes, issue as cmd response\n       WTO     TEXT=(R2),         display message                      X\n               MF=(E,WTOPL)\n       PR                         return to caller\nMESSRC DS      0H\n       WTO     TEXT=(R2),         display message                      X\n               CONSID=MYOPER,                                          X\n               CART=MSGMCART,                                          X\n               MF=(E,WTOPLCR)\n       PR                         return to caller\n*---------------------------------------------------------------------*\n*- messages                                                          -*\n*---------------------------------------------------------------------*\nBADINI  DC     AL2(L'MSG0)\nMSG0    DC     C'AOF000I ERROR ACTIVATING CONSOLE'\nBADGET  DC     AL2(L'MSG1)\nMSG1    DC     C'AOF001I ERROR TRYING TO GET A MESSAGE'\nDIDACT  DC     AL2(L'MSG2)\nMSG2    DC     C'AOF002I CONSOLE IS ALREADY ACTIVE'\nNOWACT  DC     AL2(L'MSG3)\nMSG3    DC     C'AOF003I CONSOLE HAS BEEN ACTIVATED'\nNOWDACT DC     AL2(L'MSG5)\nMSG5    DC     C'AOF005I CONSOLE HAS BEEN DEACTIVATED'\nBADDACT DC     AL2(L'MSG6)\nMSG6    DC     C'AOF006I ERROR DEACTIVATING CONSOLE'\nALRMSG  DC     AL2(L'MSG7)\nMSG7    DC     C'AOF007I ALERT DETECTED - DEACTIVATING CONSOLE'\nINITMSG DC     AL2(L'MSG8)\nMSG8    DC     C'AOF008I NOW ACCEPTING MODIFY COMMANDS'\nMSGMLIM DC     AL2(L'MSG9)\nMSG9    DC     C'AOF009I CONSOLE QUEUEING STOPPED DUE TO MEMORY LIMIT'\nMSGDLIM DC     AL2(L'MSG10)\nMSG10   DC     C'AOF010I CONSOLE QUEUEING STOPPED DUE TO DEPTH LIMIT'\nMSGINTR DC     AL2(L'MSG11)\nMSG11   DC     C'AOF011I INTERNAL SYSTEM ERROR ON CONSOLE'\nMSGALRT DC     AL2(L'MSG12)\nMSG12   DC     C'AOF012I RECEIVED QUEUE DEPTH ALERT'\nBADPARM DC     AL2(L'MSG13)\nMSG13   DC     C'AOF013I INVALID AOF TABLE NAME SPECIFIED IN PARM'\nBADLOAD DC     AL2(L'MSG14)\nMSG14   DC     C'AOF014I INVALID AOF TABLE NAME SPECIFIED'\n*---------------------------------------------------------------------*\n*- static variables                                                  -*\n*---------------------------------------------------------------------*\nCMDACT  DC     C'ACTIVATE'        activate command\nCMDDACT DC     C'DEACTIVATE'      deactivate command\nCMDRELO DC     C'RELOAD'          reload command\nLINK1C  LINK   LSEARCH=YES,SF=L\nLINK1CE EQU    *\n        LTORG\n*---------------------------------------------------------------------*\n*- dynamic area model                                                -*\n*---------------------------------------------------------------------*\nDYNMODEL DS    0F\nECBS    DS     0CL12              ecb list for wait\nMECB    DS     A                    addr(message ecb)\nAECB    DS     A                    addr(alert ecb)\nMODECB  DS     A                    addr(modify/stop ecb)\nCSA     DS     A                  addr(mcscsa)\nCSAALET DS     F                  alet(mcscsa)\nECB     DC     F'0'               message ecb\nALERT   DC     F'0'               alert ecb\nCOMADDR DS     F                  addr(comarea) from extract\nRC      DS     F                  return code from mcsoper/mcsopmsg\nRSN     DS     F                  reason code from mcsoper/mcsopmsg\nMYOPER  DS     F                  console id from last modify command\nMYASID  DS     H                  ASID AOFMCS is running under\nMSGID   DC     F'0'\nOPERPRM DS     CL(MCSOPLEN)       OPERPARMs area\nOPERSCP DS     CL(68)             MSCOPE table area\nCNAME   DS     CL8                console name to activate\n        DC     CL2'  '            space for area id on convcon\nSV      DS     18F                save area\nMATCHPRMS DS   2F                 Parm list for AOFMATCH\n        ORG    MATCHPRMS\nMATCHPRM1 DS   F\nMATCHPRM2 DS   F\nTOFF    DS     F                  offset to message in text object\nDONE    DC     FL1'0'             done flag\nMDBFLGS DC     FL1'0'             mdb flags\nMDBFGO  EQU    X'01'              processed general object\nMDBFCO  EQU    X'02'              processed control prog object\nCMDRSP  DC     FL1'0'             command response flag\nSTRTD   DC     FL1'0'             indicator that this was started task\n        DS     0H\n        EJECT\nWTOPL   WTO    TEXT=,             WTO parameter list                   X\n               DESC=(7),                                               X\n               MF=L\nWTOPLCR WTO    TEXT=,             WTO parameter list for cmd response  X\n               CONSID=,                                                X\n               CART=,                                                  X\n               DESC=(5,7),        descriptor code 5 is cmd response    X\n               MF=L\n        EJECT\nLINK1D  LINK   LSEARCH=YES,SF=L\n        EJECT\nMGCREPL MGCRE  MF=(L)             MGCRE parameter list\n        EJECT\nSUP     MODESET MODE=SUP,MF=L     MODESET parm list for sup state\nSUP0    MODESET MODE=SUP,                                              X\n               KEY=ZERO,MF=L      MODESET parm list for sup, key 0\nPROB    MODESET MODE=PROB,                                             X\n               KEY=NZERO,MF=L MODESET parm list for problem state\nEXTRACT EXTRACT MF=L              EXTRACT parameter list\n        EJECT\n        IEZVG200 DSECT=NO         CONVCON parameter list\n        EJECT\n        MCSOPER MF=(L,MCSOPPL)    MCSOPER parameter list\n        EJECT\n        MCSOPMSG MF=(L,MCSOPMPL),PLISTVER=2 MCSOPMSG Parm List     @P5C\n        EJECT\n        AOFCB DSECT=NO\nDYNL    EQU    *-DYNMODEL         dynamic area length\n*---------------------------------------------------------------------*\n*- required DSECTs                                                   -*\n*---------------------------------------------------------------------*\n        MSGCB\n        EJECT\n        CVT     DSECT=YES,LIST=YES\n        EJECT\n        IHAPSA  LIST=YES\n        EJECT\n        IHAASCB LIST=YES\n        EJECT\n        IEAVG132 ,                mdb prefix\n        EJECT\n        IEAVM105 ,                mdb\n        EJECT\n        IEAVG131 ,                console status area\n        EJECT\n        IEZVG111 ,                operparm parameter area\n        EJECT\nCOM     DSECT\n        IEZCOM   ,                COM area\n        EJECT\nCIB     DSECT\n        IEZCIB   ,                CIB and CIBX\n*---------------------------------------------------------------------*\n*- register usage                                                    -*\n*---------------------------------------------------------------------*\nR0      EQU    0                  work reg\nR1      EQU    1                  work and parm reg\nR2      EQU    2                  work reg\nR3      EQU    3                  work reg\nR4      EQU    4                  work reg\nR5      EQU    5                  pointer to end of the mdb\nR6      EQU    6                  next mdb pointer\nR7      EQU    7                  base for CIB\nR8      EQU    8                  base for mdb and mdb objects\nR9      EQU    9                  base for com area\nR10     EQU    10                 dynamic storage base\nR11     EQU    11                 dynamic storage base\nR12     EQU    12                 module base\nR13     EQU    13                 linkage\nR14     EQU    14                 linkage\nR15     EQU    15                 linkage\n        END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AOFNTRY": {"ttr": 2308, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00H\\x01\\x07%O\\x01\\x18\\x07\\x9f\\x13!\\x00:\\x00S\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2007-09-11T00:00:00", "modifydate": "2018-03-20T13:21:48", "lines": 58, "newlines": 83, "modlines": 0, "user": "GIBSONJ"}, "text": "         MACRO\n         AOFNTRY\n***********************************************************************\n*                                                                     *\n* Description of AOF entry generated by the TABENTRY macro.           *\n*                                                                     *\n***********************************************************************\nAOFNTRY  DSECT\nAOFNXT   DS    A                   Ptr to next phy entry\nAOFBNXT  DS    A                   Ptr to next identical entry\nAOFMSGID DS    CL12                Message id (first 8 chars) or '*'\nAOFACTN  DS    CL8                 Action function\n*                                   'POST' A waiting OSWAIT command\n*                                   'NONE' Perform no action\n*                                   'OSCMD' Issue command\n*                                   'OSCMDT' WTO command (test mode)\n*                                   'REPLY' Use text to reply to WTOR\nAOFTESTP DS    A                   Ptr to test blocks\nAOFNTRCT DS    AL2                 Entry number in load module\nAOFECHO  DS    CL2                 Echo parameter\n*                                    'YE'  yes echo to console\n*                                    'NO'  no suppress from console\n*                                    'LO'  log to syslog\nAOFMLIM  DS    AL4                 Matchlim count\nAOFENTR  DS    CL8                 Entry name, either label or\n*                                   Generated name 'ENTRN'\nAOFAORP  DS    0X                  Different segments for actions\n*\n**       For ACTION=OSCMD, ACTION=OSCMDT, ACTION=REPLY\n*\nAOFACTL  DS    AL2                 Length of action text\nAOFACT   DS    0C                  Start of action text\n         EJECT\nATSNTRY  DSECT ,                   Test operand entry\nATSNXT   DS    A                   Ptr to next test entry\nATSTYPE  DS    CL2                 Test type\n*                                    'W ' word type test\n*                                    'WX' word exclude test\n*                                    'S ' substring type test\n*                                    'SX' substring exclude test\n*                                    'L ' line number test\n*                                    'D ' descriptor code number test\n         DS    CL2                 Reserved\nATSWORD  DS    A                   Word number\nATSSUBST EQU   ATSWORD             Substring character position\nATSLINE  EQU   ATSWORD             Line number\nATSDESC  EQU   ATSWORD             Descriptor codes\nATSDESC1 EQU   ATSWORD             First descriptor code byte\nATSDESC2 EQU   ATSWORD+1           Second descriptor code byte\nATSEXTN  DS    0X                  Start of variable extensions\n*\n**       Extension for character tests (word, substring)\n*\nATSLNGTH DS    A                   Length of substring\nATSSEPS  DS    CL4                 Parse separators\nATSTXTL  DS    H                   Length of text\nATSTXT   DS    0C                  Text to compare\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AOFPARS": {"ttr": 2310, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x04\\x01\\x07&\\x0f\\x01\\x08\\x00\\x8f\\x11\\x04\\x00\\xf8\\x01\\x04\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2007-09-17T00:00:00", "modifydate": "2008-01-08T11:04:04", "lines": 248, "newlines": 260, "modlines": 0, "user": "GIBSONJ"}, "text": "          TITLE 'AOF PARSE ROUTINE'\n*PROCESS  USING(NOWARN)\nAOFPARS CSECT ,\nAOFPARS AMODE 31\nAOFPARS RMODE ANY\n***********************************************************************\n* Subroutine name -\n*\n*         AOFPARS\n*\n* Function -\n*\n*         Parse almost any string\n*\n* Attributes -\n*\n*         Serially reusable, resident, called via BALR\n*\n* Entry points -\n*\n*         AOFPARS - Parse string\n*\n* Entry conditions -\n*\n* 0(R1)- Points to the string to be deciphered.\n* 4(R1)- A fullword containing the length of the string\n* 8(R1)  An array of sixtyfour byte entries. The first 2 bytes of the\n*        array contain a count of the maximum number of entries in the\n*        array\n* 12(R1) A 4 Byte string of seperator characters. any of the characters\n*        in the string may be used as the separator.\n*\n* Exit conditions -\n*\n* R15 = 0:\n* 0(ARRAY): AOFPARS will return the number of entries in the array in\n*           the first two bytes.\n*\n* Calls to other routines -\n*\n*         None\n*\n* External references -\n*\n*         None\n*\n*.\n*---------------------------------------------------------------------*\n*- register usage                                                    -*\n*---------------------------------------------------------------------*\nR0      EQU    0                  Work reg\nR1      EQU    1                  Work and parm reg\nR2      EQU    2                  Work reg\nR3      EQU    3                  Work reg\nR4      EQU    4                  Work reg\nR5      EQU    5                  Work reg\nR6      EQU    6                  Work reg\nR7      EQU    7\nR8      EQU    8\nR9      EQU    9\nR10     EQU    10\nR11     EQU    11                 Dynamic storage base\nR12     EQU    12                 Module base\nR13     EQU    13                 Linkage\nR14     EQU    14                 Linkage\nR15     EQU    15                 Linkage\n***********************************************************************\n* begin linkage convention\n       BAKR    R14,0              Save regs\n       LR      R10,R1             Save parm pointer\n       LA      R12,0(R15,0)       Base and address regs\n       USING   AOFPARS,R12        Addressability\n       MODID   ,                  Eye catcher and date\n       STORAGE OBTAIN,LENGTH=DYNL Get dynamic storage\n       LA      R11,0(0,R1)        Use R11 as dyn base\n       USING   DYNAREA,R11        Map over dynamic area\n***********************************************************************\n***********************************************************************\n         LR    R1,R10\n         L     R2,0(,R1)              Get address of string\n         L     R7,8(,R1)              Get address of array\n         ST    R7,ARRAY               Put it away for later\n         LH    R3,0(,R7)              Get maximum 64 byte entries\n         STH   R3,MAXCOUNT\n         LA    R7,2(,R7)              Now point to start of array\n         L     R4,4(,R1)              Get length of string\n         LA    R4,0(R2,R4)            End of string + 1\n         BCTR  R4,0                   End of string\n         L     R3,12(,R1)             Point to sepchars\n         MVC   SEPCHARS(4),0(R3)\n         XC    ARRCOUNT(2),ARRCOUNT   Zero out ARRCOUNT\n*\nPRSELOOP DS    0H\n***********************************************************************\n* R7 - Next position in array\n* R2 - Current position in string\n***********************************************************************\n         BAL   R14,FNDNBLNK           Find next non blank\n         LTR   R15,R15                 What happened ?\n         BNZ   ALLBLANK              It was all blank !\n* R2 points to first non blank character in rest of string\n         LR    R5,R2                 Remember (Spock to McCoy)\n         BAL   R14,FNDBLANK          Get next blank character\n         CH    R15,=H'0'             What happened this time ?\n         BE    GOTBLNK               Got a blank\n         CH    R15,=H'4'             How about now ?\n         BE    NOBLANKS              No more blanks left !\n         CH    R15,=H'8'             What about this ?\n         BE    TOBIG                 More then sixteen tokens !\n*\nGOTBLNK  DS    0H\n* R2 PTS TO ENDING BLANK\n* R5 PTS TO START OF STRING\n* R3 HAS COUNT OF CHARS\n* R7 HAS CURRENT TOKEN POSITION\n         BCTR  R3,0\n         EX    R3,MOVEIT\n         B     AR1\nMOVEIT   MVC   0(*-*,R7),0(R5)         ** Executed **\nAR1      DS    0H\n         LA    R7,64(,R7)             Point to next token position\n         LH    R3,ARRCOUNT\n         LA    R3,1(,R3)\n         STH   R3,ARRCOUNT\n         B     NEXTTOKE              Check for next token...\n*\nNOBLANKS DS    0H\n* No blanks found at end of string.. process this last token and exit\n* R2 - end of string\n* R3 - length\n* R5 - start of string\n* R7 - current token position\n         BCTR  R3,0\n         EX    R3,MOVEIT\n         LH    R3,ARRCOUNT\n         LA    R3,1(,R3)\n         STH   R3,ARRCOUNT\n         B     PARSEND\n*\nALLBLANK DS    0H\n         B     LASTTOKE\n*\nTOBIG    DS    0H\n         MVC   0(64,R7),0(R5)\n         LA    R2,1(,R2)             Point to next character\n         LA    R7,64(,R7)\n         LH    R3,ARRCOUNT\n         LA    R3,1(,R3)\n         STH   R3,ARRCOUNT\n         B     NEXTTOKE\n*\nNEXTTOKE DS    0H\n         LH    R3,ARRCOUNT           Get ARRCOUNT\n         CH    R3,MAXCOUNT           Are we at end of rope ?\n         BNL   LASTTOKE\n         B     PRSELOOP              Go around again\nLASTTOKE DS    0H\n         B     PARSEND\nPARSEND  DS    0H\n         LH    R1,ARRCOUNT\n         L     R2,ARRAY\n         STH   R1,0(,R2)         Put number of tokens away\nENDPROG  DS   0H\n         SLR    R15,R15\n       STORAGE RELEASE,           Free dynamic storage                 X\n               LENGTH=DYNL,                                            X\n               ADDR=(R11)\n         PR                         Exit program\n*\n*\nFNDBLANK DS    0H\n* R2- a non blank\n* R4- a(last character in string)\n         LA    R3,1             Include first character found\nBLNKLOOP DS    0H\n         CR    R2,R4            At end of string\n         BE    LASTWD           Yup, last word...\n         LA    R2,1(,R2)         Scan next character\n         CLC   0(1,R2),SEPCHARS   Got a separator ?\n         BE    FNDBLK           Yup- got one\n         CLC   0(1,R2),SEPCHARS+1    Got a separator ?\n         BE    FNDBLK           Yup- got one\n         CLC   0(1,R2),SEPCHARS+2    Got a separator ?\n         BE    FNDBLK           Yup- got one\n         CLC   0(1,R2),SEPCHARS+3    Got a separator ?\n         BE    FNDBLK           Yup- got one\n         CLI   0(R2),X'00'      Is this zeros ?\n         BE    FNDBLK\n         LA    R3,1(R3)         Increment count\n         CH    R3,=H'64'        Token to big ?\n         BE    WORD64           Yup- quite sad..\n         B     BLNKLOOP\n*\nFNDBLK   DS    0H\n         XR    R15,R15\n         BR    R14\n*\nLASTWD   DS    0H\n         LA    R15,4\n         BR    R14\n*\nWORD64   DS    0H\n         LA    R15,8\n         BR    R14\n*\n*\nFNDNBLNK DS    0H\n* Find next non blank character in string\n* R2- points to current position in string\n* R4- points to end of string\n         CLC   0(1,R2),SEPCHARS   Got a separator ?\n         BE    NGOTIT           Yup- got one\n         CLC   0(1,R2),SEPCHARS+1    GOt a separator ?\n         BE    NGOTIT           Yup- got one\n         CLC   0(1,R2),SEPCHARS+2    Got a separator ?\n         BE    NGOTIT           Yup- got one\n         CLC   0(1,R2),SEPCHARS+3    Got a separator ?\n         BE    NGOTIT           Yup- got one\n         CLI   0(R2),X'00'      Zeros count as blanks...\n         BE    NGOTIT\n         B     GOTIT             No, got next non-blanK\nNGOTIT   DS    0H\n         LA    R2,1(,R2)         Increment\n         CR    R2,R4             At end of string ?\n         BH    ENDOSTR           Yup- quite sad.\n         B     FNDNBLNK\nGOTIT    DS    0H\n         XR    R15,R15\n         BR    R14\nENDOSTR  DS    0H\n         LA    R15,4\n         BR    R14\n*\n         EJECT\n         LTORG ,\n         EJECT\n*---------------------------------------------------------------------*\n*- Dynamic area                                                      -*\n*---------------------------------------------------------------------*\nDYNAREA  DSECT\nSEPCHARS DS    CL4               Separator characters\nARRCOUNT DS    H\nMAXCOUNT DS    H\nARRAY    DS    A                 Address of array\nDUMMY    DS    F\n*\nDYNL    EQU    *-DYNAREA          Dynamic area length\n         END   AOFPARS\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AOFPAUSE": {"ttr": 2315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x000\\x01\\x07(/\\x01\\x07)/\\x121\\x00\\xac\\x00\\xaa\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2007-10-09T00:00:00", "modifydate": "2007-10-19T12:31:30", "lines": 172, "newlines": 170, "modlines": 0, "user": "GIBSONJ"}, "text": "          TITLE 'AOF ROUTINE TO WAIT FOR MESSAGE'\n*PROCESS  USING(NOWARN)\nAOFPAUSE  CSECT ,\nAOFPAUSE  AMODE 31\nAOFPAUSE  RMODE ANY\n***********************************************************************\n* This is the AOFPAUSE REXX function.                                 *\n***********************************************************************\n* command syntax:                                                     *\n*                                                                     *\n* AOFPAUSErc = AOFPAUSE(seconds)                                      *\n*                                                                     *\n* Where seconds is the amount of time in seconds to pause execution   *\n*                                                                     *\n*                                                                     *\n* This command is designed to be used with the AOF application. It is *\n* intended to provide an AOF automation exec  with the capability of  *\n* waiting a given number of seconds.                                  *\n*                                                                     *\n***********************************************************************\n*---------------------------------------------------------------------*\n*- Register usage                                                    -*\n*---------------------------------------------------------------------*\nR0      EQU    0                  Work reg\nR1      EQU    1                  Work and parm reg\nR2      EQU    2                  Work reg\nR3      EQU    3                  Work reg\nR4      EQU    4                  Work reg\nR5      EQU    5\nR6      EQU    6\nR7      EQU    7\nR8      EQU    8\nR9      EQU    9\nR10     EQU    10\nR11     EQU    11                 Work area base\nR12     EQU    12                 Module base\nR13     EQU    13                 Linkage\nR14     EQU    14                 Linkage\nR15     EQU    15                 Linkage\n***********************************************************************\n* Begin linkage convention\n       STM     R14,R12,12(R13)\n       LR      R2,R13             Save savearea\n       LR      R10,R1             Save parm pointer\n       LA      R12,0(R15)         base and address regs\n       USING   AOFPAUSE,R12\n       USING   PSA,0\n       MODID   ,                  eye catcher and date\n       STORAGE OBTAIN,LENGTH=DYNL get dynamic storage\n       LA      R11,0(0,R1)        use R11 as dyn base\n       USING   DYNAREA,R11        map model over dynamic area\n       LA      R13,SAVEAREA\n       ST      R13,8(R2)          Link saveareas\n       ST      R2,SAVEAREA+4\n******************************************************************\n       L       R1,16(R10)          let's get our argument\n       CLC     0(L'PARMEND,R1),PARMEND    is there an argument\n       BE      BAD_PAUSE           no, then send error\n       ICM     R3,15,4(R1)         get the length of argument\n       BZ      BAD_PAUSE           if none send error\n       CH      R3,=H'3'            verify it's not too long\n       BH      BAD_PAUSE           It is, send error\n       L       R7,0(R1)            point to the argument\n       LR      R0,R3\n       LR      R1,R7\nTEST_PAUSE_LOOP EQU     *\n       CLC     0(1,R1),=C'0'\n       BL      BAD_PAUSE\n       CLC     0(1,R1),=C'9'\n       BH      BAD_PAUSE\n       LA      R1,1(,R1)\n       BCT     R0,TEST_PAUSE_LOOP\n       BCTR    R3,0\n       EX      R3,PACK\n       B       CONVERT_PAUSE\nPACK   DS      0H\n       PACK    DWORD,0(*-*,R7)\nCONVERT_PAUSE EQU     *\n       CVB     R3,DWORD              convert to binary\n       C       R3,=F'1'\n       BL      BAD_PAUSE\n       C       R3,=F'7200'           two hours\n       BH      BAD_PAUSE\n       M       R2,=F'100'            change to hundreths\n       ST      R3,PAUSEVAL\n       B       DO_STIMER\n***********************************************************************\n*                                                                     *\n* Set up STIMER\n*\n***********************************************************************\nDO_STIMER DS 0H\n       STIMER WAIT,BINTVL=PAUSEVAL   ** DO IT **\n       MVC     RETCODE(2),=CL2'00'    set return code\n       B       PAUSE_OK\n***********************************************************************\n*                                                                     *\n* SET REPLY\n*\n***********************************************************************\nPAUSE_OK       EQU   *\n       MVC     REPLY_AREA(L'OK_FUNCTION),OK_FUNCTION\n       L       R8,=A(L'OK_FUNCTION)\n       MVC     RETCODE(2),=CL2'00'    set return code\n       B       SETERRORMSG\nBAD_PAUSE      EQU   *\n       MVC     REPLY_AREA(L'ERROR_FUNCTION),ERROR_FUNCTION\n       L       R8,=A(L'ERROR_FUNCTION)\n       MVC     RETCODE(2),=CL2'08'    set return code\n       B       SETERRORMSG\nSETERRORMSG DS    0H\n       LA      R1,IRXSHVBSTG\n       USING   SHVBLOCK,R1\n       LA      R5,KAOFPAUSE_ERROR\n       ST      R5,SHVNAMA\n       LA      R5,REPLY_AREA\n       ST      R5,SHVVALA\n       LA      R5,L'KAOFPAUSE_ERROR\n       ST      R5,SHVNAML\n       ST      R8,SHVVALL\n       SR      R0,R0        No environment block\n       ST      R0,SHVNEXT\n       MVI     SHVCODE,SHVSTORE\n       DROP    R1\n       LINK       EP=IRXEXCOM,DCB=0,MF=(E,CALLIST),SF=(E,LINKLIST),    *\n               PARAM=(EYEC,DUMMY,DUMMY,IRXSHVBSTG),VL=1\n       B       SETRETCODE\nSETRETCODE DS  0H\n       L       R7,20(R10)\n       L       R7,0(R7)\n       USING   EVALBLOCK,R7\n       MVC     EVALBLOCK_EVLEN,=F'2'\n       MVC     EVALBLOCK_EVDATA(2),RETCODE\nENDPROG EQU    *\n       L       R3,SAVEAREA+4\n       STORAGE RELEASE,           Free dynamic storage                 X\n               LENGTH=DYNL,                                            X\n               ADDR=(R11)\n       SLR     R15,R15\n       L       R14,12(R3)\n       LM      R0,R12,20(R3)\n       BR      R14\n*\nPARMEND           DC    X'FFFFFFFFFFFFFFFF'\nERROR_FUNCTION    DC    C'ERROR IN SPECIFYING AOFPAUSE FUNCTION'\nOK_FUNCTION       DC    C'OK'\nKAOFPAUSE_ERROR   DC    C'AOFPAUSE_ERROR'\nEYEC              DC    CL8'IRXEXCOM'\nDUMMY             DC    A(0)\n              LTORG\n*================================================================\nDYNAREA       DSECT\nSAVEAREA      DS    18F\nREPLY_AREA    DS    CL120\nDWORD         DS    D\nPAUSEVAL      DS    F\n**\nRETCODE       DS    H\n**\nLINKLIST      LINK    EP=IRXEXCOM,DCB=0,SF=L\nCALLIST       CALL    ,(EYEC,DUMMY,DUMMY,IRXSHVBSTG),VL,MF=L\nIRXSHVBSTG    DS      CL(SHVBLEN)\n**\n*\nDYNL          EQU  *-SAVEAREA\n         IRXSHVB\n         IRXEVALB\n         IEANTASM\n         PRINT ON\n         CVT   DSECT=YES\n         IHAPSA\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AOFPROC": {"ttr": 2561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x07)/\\x01\\x07)/\\x14C\\x00\\x07\\x00\\x07\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-10-19T00:00:00", "modifydate": "2007-10-19T14:43:01", "lines": 7, "newlines": 7, "modlines": 0, "user": "GIBSONJ"}, "text": "//AOF      PROC\n//AOF      EXEC PGM=AOFMCS,REGION=128M,DYNAMNBR=20,TIME=NOLIMIT,\n//     PARM='AOFTABL'\n//STEPLIB  DD   DSN=SYS0.AOF.LOADLIB,DISP=SHR\n//ABNLIGNR DD   DUMMY\n//SYSABEND DD   SYSOUT=*\n//         PEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AOFSAMP": {"ttr": 2563, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00%\\x01\\x18\\x07\\x9f\\x01\\x18\\x07\\x9f\\x11I\\x01%\\x01%\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-03-20T00:00:00", "modifydate": "2018-03-20T11:49:25", "lines": 293, "newlines": 293, "modlines": 0, "user": "GIBSONJ"}, "text": "***********************************************************************\n* THIS IS THE AUTOMATED OPERATIONS FACILITY TABLE FOR TEST            *\n*                                                                     *\n* Note: If testing for Multi-line WTO the \"(L,nn)\" has to be the      *\n*       First operand in the test.                                    *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         PRINT GEN\nAOFSAMP  TABSTART ID=SAMP\n***********************************************************************\n*                                                                     *\n*  ----->  GENERAL SECTION                                            *\n*                            GENERAL MESSAGE HANDLING                 *\n*=====================================================================*\n* 1.  ARC0310A\n         TABENTRY MSG=ARC0310A,ACTION=REPLY,TEXT='Y',ECHO=NO\n* 2.  HSM ARC0381A Tape drive not available\n         TABENTRY MSG=ARC0381A,ACTION=REPLY,TEXT='CANCEL',ECHO=NO\n* 3.  HSM ARC0380A Volume not available\n         TABENTRY MSG=ARC0380A,ACTION=REPLY,TEXT='WAIT',ECHO=NO\n* 4.  ARC0037I\n         TABENTRY MSG='ARC0037I',ACTION=OSCMD,TEST=((L,1)),            X\n               TEXT='S PDOCOPY'\n* 5.  OPC MESSAGE EQQE036I\n         TABENTRY MSG='EQQE036I',ACTION=OSCMD,TEST=((L,1)),            X\n               TEXT='.EQQE036I \\S014,35\\ \\L002\\\\S060,04\\ \\L003\\\\S011,23X\n               \\'\n* 6.  IHINITT MESSAGE IEC701D\n         TABENTRY MSG='IEC701D',ACTION=REPLY,                          X\n               TEXT='M',ECHO=NO\n* 7.  IGW023A and IOEZ00068E MESSAGES (filesystem monitoring)\n         TABENTRY MSG='IGW023A',ACTION=OSCMD,                          X\n               TEXT='.HFSMONIT \\S013,44\\ \\L002\\\\W    02\\'\n         TABENTRY MSG='IOEZ00068E',ACTION=OSCMD,                       X\n               TEXT='.ZFSMONIT \\S028,56\\'\n* 8.  ICK003D\n         TABENTRY MSG='ICK003D',ACTION=REPLY,                          X\n               TEXT='U',ECHO=NO\n* 9.  IFB080E\n         TABENTRY MSG='IFB080E',ACTION=OSCMD,                          X\n               TEXT='.DMPLGREC'\n*10.  IFB08II\n         TABENTRY MSG='IFB081I',ACTION=OSCMD,                          X\n               TEXT='.DMPLGREC'\n*11.  IEE043I log queued\n         TABENTRY MSG='IEE043I',ACTION=OSCMD,                          X\n               TEXT='S SRSLOG'\n*12.  EQQW776I MESSAGE (Job past deadline)\n         TABENTRY MSG='EQQW776I',ACTION=OSCMD,TEST=((L,2)),            X\n               TEXT='.OPCLATE \\L002\\\\W    04\\ \\W    05\\'\n*13.  EQQQ515W MESSAGE (Job past deadline)\n         TABENTRY MSG='EQQQ515W',ACTION=OSCMD,TEST=((L,1)),            X\n               TEXT='.OPCWAIT \\W    03\\'\n*14.  ADR369D\n         TABENTRY MSG='ADR369D',ACTION=REPLY,                          X\n               TEXT='U',ECHO=NO\n*15.  IVT5529I  MESSAGE (Reply from D NET,CSM)\n         TABENTRY MSG='IVT5529I',ACTION=OSCMD,                         X\n               TEST=((L,29),                                           X\n               (W,07,07,'CURRENT',' ')),                               X\n               TEXT='.CHKCSM FIXED \\L029\\\\W.=  04\\ \\W.=  07\\'\n         TABENTRY MSG='IVT5529I',ACTION=OSCMD,                         X\n               TEST=((L,32),                                           X\n               (W,07,07,'CURRENT',' ')),                               X\n               TEXT='.CHKCSM ECSA \\L032\\\\W.=  04\\ \\W.=  07\\'\n*16.  $HASP375\n         TABENTRY MSG='$HASP375',ACTION=OSCMD,                         X\n               TEXT='.HASP375  ''\\S001,77\\'''\n*17.  EQQE037I MESSAGE (OPC JOB IS LATE)\n         TABENTRY MSG='EQQE037I',ACTION=OSCMD,                         X\n               TEXT='.TRULATE \\L001\\\\W()  03\\'\n*18.  EQQF015I MESSAGE (OPC CONTROLLER MEMBER GONE)\n         TABENTRY MSG='EQQF015I',ACTION=OSCMD,                         X\n               TEXT='.OPCCYCLE \\J\\'\n*19.  EQQE038I MESSAGE (Job past deadline)\n         TABENTRY MSG='EQQE038I',ACTION=OSCMD,                         X\n               TEXT='.OPCLONG \\L001\\\\W()  06\\'\n*20.  ICH408I   MESSAGE (Security error)\n        TABENTRY MSG='ICH408I',ACTION=OSCMD,                           X\n               TEST=((L,1),(W,02,04,'USER','()  '),                    X\n               (L,2),(W,04,09,'EXCESSIVE','/-  '),                     X\n               (W,05,08,'PASSWORD','/-  ')),                           X\n               TEXT='.REVOKED \\L001\\\\W()  03\\'\n*21.  @SCS0918D MESSAGE (STK mount failed)\n        TABENTRY MSG='@SCS0918D',ACTION=OSCMD,                         X\n               TEXT='.SCS0918  ''\\S001,92\\'''\n*22.  IEF238D   MESSAGE (Reply device name or cancel)\n        TABENTRY MSG='IEF238D',ACTION=REPLY,                           X\n               TEST=((W,04,04,'WAIT','''-  ')),                        X\n               TEXT='WAIT'\n*23.  IEF238D   MESSAGE (Reply cancel for allocation)\n        TABENTRY MSG='IEF238D',ACTION=REPLY,                           X\n               TEST=((W,04,06,'DEVICE','''-  '),                       X\n               (W,05,04,'NAME','''-  ')),                              X\n               TEXT='CANCEL'\n*24.  IEF433D MESSAGE (Reply nohold for allocation)\n        TABENTRY MSG='IEF433D',ACTION=REPLY,                           X\n               TEXT='NOHOLD'\n*25.  AOFTEST MESSAGE\nAOFWAIT  TABENTRY MSG='+AOFWAIT',ACTION=POST\n*26.  ARC0624I MESSAGE (HSM full volume backup failed)\n        TABENTRY MSG='ARC0624I',ACTION=OSCMD,                          X\n               TEXT='.ARC0624I \\W.=  05\\'\n*27.  IOS071I  MESSAGE (Missing channel and device end)\n        TABENTRY MSG='IOS071I',ACTION=OSCMD,                           X\n               TEXT='.IOS071I \\S009,54\\'\n*28.  IEE800D   MESSAGE (Reply YES to VARY OFFLINE,FORCE)\n        TABENTRY MSG='IEE800D',ACTION=REPLY,                           X\n               TEST=((S,032,01,'4')),                                  X\n               TEXT='YES'\n*29.  EQQE039I MESSAGE (Long time on input queue)\n         TABENTRY MSG='+EQQE039I',ACTION=OSCMD,                        X\n               TEST=((L,3),                                            X\n               (W,04,04,'PLN1',' =,')),                                X\n               TEXT='.OPCINQUE \\L001\\\\W()  09\\'\n*30. DB2 update activity suspended\nSUSPEND  TABENTRY MSG='DSNJ372I',ACTION=POST\n         TABENTRY MSG='DSNJ372I',ACTION=OSCMD,                         X\n               TEXT='.DBSUSPND \\L002\\\\W(), 03\\ \\L002\\\\W(), 06\\ \\L002\\\\WX\n               (), 08\\ \\L003\\\\W(), 03\\'\n*31. DB2 update activity resume\nRESUME   TABENTRY MSG='DSNJ373I',ACTION=POST\n*32. IOS002A no paths available\n        TABENTRY MSG='IOS002A',ACTION=OSCMD,                           X\n               TEXT='.IOS002A \\S008,54\\'\n*33. HANDLE RMF202I MESSAGE\n*     +RMF202I 3B: APPLP2TF Performance Index: 0.70   Limit: 0.1\n         TABENTRY MSG='+RMF202I',ACTION=OSCMD,                         X\n               TEXT='.PIALERT ''\\W    03\\ \\W    06\\'''\n*34. EMCCV39R reply\n*     +EMCCV39R VERIFY DYNAMIC RDF REQUEST\n         TABENTRY MSG='EMCCV39R',ACTION=REPLY,TEXT='CONTINUE',ECHO=NO\n*35. EMCCV39R reply\n*     +EMCCV36R SRDF SETTING R1 TO RESUME MODE\n         TABENTRY MSG='EMCCV36R',ACTION=REPLY,TEXT='CONTINUE',ECHO=NO\n*36. EMCCV03R reply\n*     +EMCCV03R\n         TABENTRY MSG='EMCCV03R',ACTION=REPLY,TEXT='CONTINUE',ECHO=NO\n*37. HANDLE EMCCV01R reply\n*     +EMCCV01R\n         TABENTRY MSG='EMCCV01R',ACTION=REPLY,TEXT='CONTINUE',ECHO=NO\n*38. HANDLE CSQI010I  MESSAGE (Reply from JU01 DIS USAGE PSID(*))\n         TABENTRY MSG='CSQI010I',ACTION=OSCMD,                         X\n               TEST=((L,4),                                            X\n               (W,02,1,'0',' ')),                                      X\n               TEXT='.CHKMQ 0 \\L004\\\\W.=  04\\ \\W.=  05\\'\n         TABENTRY MSG='CSQI010I',ACTION=OSCMD,                         X\n               TEST=((L,5),                                            X\n               (W,02,1,'1',' ')),                                      X\n               TEXT='.CHKMQ 1 \\L005\\\\W.=  04\\ \\W.=  05\\'\n         TABENTRY MSG='CSQI010I',ACTION=OSCMD,                         X\n               TEST=((L,6),                                            X\n               (W,02,1,'2',' ')),                                      X\n               TEXT='.CHKMQ 2 \\L006\\\\W.=  04\\ \\W.=  05\\'\n         TABENTRY MSG='CSQI010I',ACTION=OSCMD,                         X\n               TEST=((L,7),                                            X\n               (W,02,1,'3',' ')),                                      X\n               TEXT='.CHKMQ 3 \\L007\\\\W.=  04\\ \\W.=  05\\'\n         TABENTRY MSG='CSQI010I',ACTION=OSCMD,                         X\n               TEST=((L,8),                                            X\n               (W,02,1,'3',' ')),                                      X\n               TEXT='.CHKMQ 4 \\L008\\\\W.=  04\\ \\W.=  05\\'\n***********************************************************************\n*                                                                     *\n*  ----->  IPL STARTUP SECTION                                        *\n*                            HANDLE NECESSARY CONDITIONS AT IPL       *\n*=====================================================================*\n* 1.  VTAM UP                                                         *\nVTAMUP   TABENTRY MSG='IST020I',ACTION=POST\n* 2.  DB2 DSNJ UP                                                     *\nDSNJUP   TABENTRY MSG='DSN9022I',ACTION=POST,                          X\n               TEST=((W,02,01,'<','''   '),                            X\n               (W,04,05,'START','''   '),                              X\n               (W,05,03,'DB2','''   '))\n* 3.  DB2 DSNT UP                                                     *\nDSNTUP   TABENTRY MSG='DSN9022I',ACTION=POST,                          X\n               TEST=((W,02,01,'?','''   '),                            X\n               (W,04,05,'START','''   '),                              X\n               (W,05,03,'DB2','''   '))\n* 4.  MQM JU01 UP                                                     *\nJU01UP   TABENTRY MSG='+CSQX022I',ACTION=POST,                         X\n               TEST=((W,02,04,'JU01','''   '),                         X\n               (W,04,07,'Channel','''   '),                            X\n               (W,05,09,'initiator','''   '),                          X\n               (W,06,14,'initialization','''   '),                     X\n               (W,07,08,'complete','''   '))\n* 5.  SLS0 UP                                                         *\nSLS0UP   TABENTRY MSG='!SLS1030I',ACTION=POST\n* 6.  TCPIP UP                                                        *\nTCPIPUP  TABENTRY MSG='EZAIN11I',ACTION=POST\n* 7.  RMF UP                                                          *\nRMFUP    TABENTRY MSG='ERB100I',ACTION=POST\n* 8.  REPLY CONT TO OAM STARTUP                                       *\n         TABENTRY MSG=CBR7516D,ACTION=REPLY,TEXT='CONT',ECHO=NO\n         EJECT\n***********************************************************************\n*                                                                     *\n*  ----->  SHUTDOWN SECTION                                           *\n*                            KEEP TRACK OF SHUTDOWN PROGRESS AND      *\n*                            ISSUE REPLIES TO NECESSARY MESSAGES      *\n*                            (ALL MESSAGE GENERATED COMMANDS SHOULD   *\n*                             TEST IF IN SHUTDOWN MODE (%ISSHUT))     *\n*=====================================================================*\n* 1.  REPLY 'SIC' TO TCAS TERMINATION MESSAGE                         *\n         TABENTRY MSG=IKT010D,ACTION=REPLY,TEXT='SIC',ECHO=NO\n*=====================================================================*\n* 2.  REPLY 'U' TO TCAS TERMINATION MESSAGE, AND ONLY REPLY ONCE      *\n         TABENTRY MSG=IKT012D,ACTION=REPLY,TEXT='U',ECHO=NO\n*=====================================================================*\n* 3.  REPLY 'YES' TO FFST SHUTDOWN MESSAGE, AND ONLY REPLY ONCE       *\n         TABENTRY MSG=EPW0309I,ACTION=REPLY,TEXT='YES',ECHO=NO\n***********************************************************************\n*                                                                     *\n*  ----->  UNIALERT  section                                          *\n*                                                                     *\n*=====================================================================*\n* 1.  ARC0909E DFSMSHSM JOURNAL THRESHOLD                             *\n         TABENTRY MSG='ARC0909E',ACTION=OSCMD,                         X\n               TEXT='.UNIALERT Notify IBM SYSTEMS, JOB:\\J\\ MSG:''\\S001,X\n               57\\''',ECHO=NO\n* 2.  IVT5563I CSM FIXED STORAGE AT CRITICAL LEVEL                    *\n         TABENTRY MSG='IVT5563I',ACTION=OSCMD,                         X\n               TEXT='.UNIALERT Notify IBM SYSTEMS, JOB:\\J\\ MSG:''\\S001,X\n               57\\''',ECHO=NO\n* 3.  IEE141A  CONSOLE LOST                                           *\n         TABENTRY MSG='IEE141A',ACTION=OSCMD,                          X\n               TEXT='.UNIALERT Notify IBM SYSTEMS, JOB:\\J\\ MSG:''\\S001,X\n               57\\''',ECHO=NO\n* 4.  EQQZ045E  OPC SUBTASK ISSUES                                    *\n         TABENTRY MSG='EQQZ045E',ACTION=OSCMD,                         X\n               TEXT='.UNIALERT Notify IBM SYSTEMS, JOB:\\J\\ MSG:''\\S001,X\n               57\\''',ECHO=NO\n* 5.  SMC0110  STK SILO MESSAGE                                       *\n         TABENTRY MSG='SMC0110',ACTION=OSCMD,                          X\n               TEXT='.UNIALERT Notify IBM SYSTEMS, JOB:\\J\\ MSG:''\\S001,X\n               57\\''',ECHO=NO\n* 6.  IGW027E  HFS SYNC ERROR MESSAGE                                 *\n         TABENTRY MSG='IGW027E',ACTION=OSCMD,                          X\n               TEXT='.UNIALERT Notify IBM SYSTEMS, JOB:\\J\\ MSG:''\\S001,X\n               57\\''',ECHO=NO\n* 7.  HZS0001I HEALTH CHECKER MESAAGE                                 *\n         TABENTRY MSG='HZS0001I',ACTION=OSCMD,                         X\n               TEXT='.UNIALERT Notify IBM SYSTEMS, JOB:\\J\\ MSG:''\\S001,X\n               57\\''',ECHO=NO\n* 8.  ISG353E  GRS RESOURCE SHORTAGE MESSAGE                          *\n         TABENTRY MSG='ISG353E',ACTION=OSCMD,                          X\n               TEXT='.UNIALERT Notify IBM SYSTEMS, JOB:\\J\\ MSG:''\\S001,X\n               57\\''',ECHO=NO\n* 9.  IEC361I  CATALOG MAX EXTENTS THRESHOLD                          *\n         TABENTRY MSG='IEC361I',ACTION=OSCMD,                          X\n               TEXT='.UNIALERT Notify IBM SYSTEMS, JOB:\\J\\ MSG:''\\S001,X\n               57\\''',ECHO=NO\n* 10. IEF187I  SYSTEM ERROR IN INITIATOR MSG                          *\n         TABENTRY MSG='IEF187I',ACTION=OSCMD,                          X\n               TEXT='.UNIALERT Notify IBM SYSTEMS, JOB:\\J\\ MSG:''\\S001,X\n               57\\''',ECHO=NO\n* 11. IOS000I  I/O EROR                                               *\n         TABENTRY MSG='IOS000I',ACTION=OSCMD,                          X\n               TEXT='.UNIALERT Notify IBM SYSTEMS, JOB:\\J\\ MSG:''\\S001,X\n               57\\''',ECHO=NO\n* 12. IEE985A  SMF IS PROCESSING LAST DATASET                         *\n         TABENTRY MSG='IEE985A',ACTION=OSCMD,                          X\n               TEXT='.UNIALERT Notify IBM SYSTEMS, JOB:\\J\\ MSG:''\\S001,X\n               57\\''',ECHO=NO\n* 13. $HASP050 JES2 RESOURCE SHORTAGE                                 *\n         TABENTRY MSG='$HASP050',ACTION=OSCMD,                         X\n               TEXT='.UNIALERT Notify IBM SYSTEMS, JOB:\\J\\ MSG:''\\S001,X\n               57\\''',ECHO=NO\n* 14. HANDLE DSNR035I (UNCOMMITTED UR AFTER number CHECKPOINTS)       *\n         TABENTRY MSG='DSNR035I',ACTION=OSCMD,                         X\n               TEXT='.UNIALERT Notify IBM SYSTEMS, JOB:\\L003\\\\W=   03\\ X\n               ''MSG:DSNR035I - UNCOMMITTED UR AFTER \\L002\\\\W    01\\ CHX\n               ECKPOINTS''',ECHO=NO\n* 15. HANDLE DSNJ031I (UNCOMMITTED UR HAS WRITTEN number LOG RECORDS) *\n*        TABENTRY MSG='DSNJ031I',ACTION=OSCMD,\n*              TEXT='.UNIALERT Notify IBM SYSTEMS, JOB:\\L003\\\\W=   03\\\n*              ''MSG:DSNJ031I - UNCOMMITTED UR HAS WRITTEN \\L002\\\\W\n*              03\\ LOG RECORDS''',ECHO=NO\n* 16. HANDLE IEA480E MESSAGE                                          *\n         TABENTRY MSG='IEA480E',ACTION=OSCMD,                          X\n               TEXT='.UNIALERT Notify IBM SYSTEMS, MSG:''IEA480E \\L002\\X\n               \\S001,13\\\\L001\\\\S009,56\\''',ECHO=NO\n* 99. HANDLE ALL ACTION DESCRIPTOR CODES                              *\n         TABENTRY MSG='*',ACTION=OSCMD,TEST=((D,E020)),                X\n               TEXT='.UNIALERT Notify IBM SYSTEMS, JOB:\\J\\ MSG:''\\S001,X\n               57\\''',ECHO=NO\n***********************************************************************\n*                                                                     *\n* DO NOT LEAVE THE TABEND MACRO OUT OF THIS ASSEMBLY.                 *\n*                                                                     *\n***********************************************************************\n         TABEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AOFSVC": {"ttr": 2569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00$\\x01\\x07)o\\x01\\x11\\x15O\\tC\\x00\\xd3\\x00\\xbb\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2007-10-23T00:00:00", "modifydate": "2011-06-03T09:43:24", "lines": 211, "newlines": 187, "modlines": 0, "user": "GIBSONJ"}, "text": "         TITLE 'AOFSVC - ISSUE SYSTEM LEVEL TOKEN CREATE/DELETE'\n***********************************************************************\n*                                                                     *\n* MODULE NAME: AOFSVC (SVC 254)                                       *\n*                                                                     *\n* DESCRIPTION: ROUTINE TO ISSUE SYSTEM LEVEL TOKEN CREATE/DELETE      *\n*                                                                     *\n* Function:                                                           *\n*                                                                     *\n*  1) CHECK TO SEE IF USER IS AUTHORIZED TO ISSE SVC                  *\n*         If not return with code 8                                   *\n*                                                                     *\n*  2) Check to see if DELETE or CREATE was specified                  *\n*                                                                     *\n*  3a) If DELETE then CALL IEANTDL to delete a system level           *\n*      name/token pair                                                *\n*                                                                     *\n*  3b) If CREATE then CALL IEANTCR to create a system level           *\n*      name/token pair                                                *\n*                                                                     *\n*  4) Return with IEANTDL or IEANTCR return code                      *\n*                                                                     *\n*  Entry point:                                                       *\n*      AOFSVC                                                         *\n*                                                                     *\n*  Purpose:                                                           *\n*      Delete or create a system level name/token pair                *\n*                                                                     *\n*  Input:                                                             *\n*      R0  = Pointer to character string \"CREATE\" or \"DELETE\"         *\n*      R1  = Address of IEANTDL or IEANTCR parameter list             *\n*      R6  = Entry point                                              *\n*      R7  = ADDRESS OF ASCB                                          *\n*      R13 =                                                          *\n*      R14 = Return address                                           *\n*                                                                     *\n*  Output:                                                            *\n*      Return code of 8 if user not authorized for $TRU NT.AOFSVC     *\n*      otherwise return code from IEANTDL or IEANTCR                  *\n*                                                                     *\n*  Register useage:                                                   *\n*       R0  - Work register                                           *\n*       R1  - Work register                                           *\n*       R2  - Work                                                    *\n*       R3  - Work                                                    *\n*       R4  - Work                                                    *\n*       R5  - Work                                                    *\n*       R6  - Base register for program                               *\n*       R7  - Unused                                                  *\n*       R8  - Unused                                                  *\n*       R9  - Unused                                                  *\n*       R10 - Unused                                                  *\n*       R11 - Unused                                                  *\n*       R12 - Unused                                                  *\n*       R13 - Unused                                                  *\n*       R14 - Return address                                          *\n*       R15 - Linkage and return code                                 *\n*                                                                     *\n***********************************************************************\n*---------------------------------------------------------------------*\n*- Register usage                                                    -*\n*---------------------------------------------------------------------*\nR0      EQU    0                  Work reg\nR1      EQU    1                  Work and parm reg\nR2      EQU    2                  Work reg\nR3      EQU    3                  Work reg\nR4      EQU    4                  Work reg\nR5      EQU    5\nR6      EQU    6                  Module base\nR7      EQU    7\nR8      EQU    8\nR9      EQU    9\nR10     EQU    10\nR11     EQU    11\nR12     EQU    12\nR13     EQU    13                 Dynamic storage base\nR14     EQU    14                 Linkage\nR15     EQU    15                 Linkage\n        EJECT ,\n        PRINT ON,GEN\nAOFSVC  CSECT\nAOFSVC  AMODE 31\nAOFSVC  RMODE ANY\n         USING AOFSVC,R6       Set addressability\n         MODID\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        Save parameters and get storage                              *\n*                                                                     *\n***********************************************************************\n         LR    R5,R1            Save parm address\n         LR    R4,R0            Save parm address\n         GETMAIN RU,LV=DATALEN,SP=252 Get storage\n         LR    R13,R1\n         USING DATA,R13\n         ST    R14,RETADDR\n         MVC   FUNCTION,0(R4)\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        Check authority                                              *\n*                                                                     *\n***********************************************************************\n         MVC   RESOURCE,RESOURCEC      Init resource to 'NT.AOFSVC'\n         LA    R0,ENTITYL\n         STH   R0,ENTITY\n         XC    ENTITY2,ENTITY2\n         MVC   AUTHCHK(AUTHCHKL),AUTHCHKC Init RACROUTE macro\n         LA    R3,ENTITY\n         RACROUTE REQUEST=AUTH,                                        X\n               RELEASE=1.9,                                            X\n               ENTITYX=((R3)),                                         X\n               WORKA=SAFWORK,                                          X\n               MF=(E,AUTHCHK)\n         C     R15,=F'8'               Is user authorized?\n         BNL   RET8\n         SPACE 2\n         CLC   FUNCTION,=CL6'DELETE'\n         BE    CALL_DELETE\n         CLC   FUNCTION,=CL6'CREATE'\n         BE    CALL_CREATE\n         B     RET8\n***********************************************************************\n*                                                                     *\n*        Call IEANTDL                                                 *\n*                                                                     *\n***********************************************************************\nCALL_DELETE DS 0H\n         USING PSA,0\n         L     R15,CVTPTR                 Get the CVT pointer\n         USING CVTMAP,R15\n         L     R15,CVTCSRT\n         DROP  R15\n         L     R15,X'14'(R15,0)\n         L     R15,X'0C'(R15,0)            Get address of IEANTDL\n         LR    R1,R5\n         BALR  R14,R15\n         LR    R2,R15\n         B     RETURN\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*        Call IEANTCR                                                 *\n*                                                                     *\n***********************************************************************\nCALL_CREATE DS 0H\n         USING PSA,0\n         L     R15,CVTPTR                 Get the CVT Pointer\n         USING CVTMAP,R15\n         L     R15,CVTCSRT\n         DROP  R15\n         L     R15,X'14'(R15,0)\n         L     R15,X'04'(R15,0)\n         LR    R1,R5\n         BALR  R14,R15\n         LR    R2,R15\n         B     RETURN\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*        Return                                                       *\n*                                                                     *\n***********************************************************************\nRET8     DS    0H\n         LA    R2,8                     Load return code of 8\n         B     RETURN                   BR to return\nRETURN   DS    0H\n         L     R3,RETADDR\n         LR    R1,R13\n         FREEMAIN RU,LV=DATALEN,A=(1),SP=252 Free data dsect storage\n         LR    R14,R3\n         LR    R15,R2\n         BR    R14                      Return\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*        Literals                                                     *\n*                                                                     *\n***********************************************************************\n         LTORG ,\nAUTHCHKC RACROUTE REQUEST=AUTH,                                        X\n               CLASS='$TRU',                                           X\n               RELEASE=1.9,                                            X\n               MF=L\nAUTHCHKL EQU   *-AUTHCHKC\nRESOURCEC DC   C'NT.AOFSVC'\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*        DATA DSECT                                                   *\n*                                                                     *\n***********************************************************************\nDATA     DSECT  ,\nSAVEAREA DS     18F\nRETADDR  DS     F\nFUNCTION DS     CL6\nAUTHCHK  RACROUTE REQUEST=AUTH,                                        X\n               CLASS='$TRU',                                           X\n               RELEASE=1.9,                                            X\n               MF=L\nENTITY   DS    AL2(ENTITYL)\nENTITY2  DS    AL2(0)\nRESOURCE DS    C'NT.AOFSVC'\nENTITYL  EQU   *-RESOURCE\nSAFWORK  DS    XL512\nDATALEN  EQU    *-DATA\n         PRINT ON, NOGEN\n         CVT   DSECT=YES\n         IHAPSA\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AOFWAIT": {"ttr": 2574, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01#\\x00$\\x01\\x07&\\x8f\\x01\\x07)o\\t \\x01\\xa3\\x00\\x85\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.35", "flags": 0, "createdate": "2007-09-25T00:00:00", "modifydate": "2007-10-23T09:20:24", "lines": 419, "newlines": 133, "modlines": 0, "user": "GIBSONJ"}, "text": "          TITLE 'AOF ROUTINE TO WAIT FOR MESSAGE'\n*PROCESS  USING(NOWARN)\nAOFWAIT   CSECT ,\nAOFWAIT   AMODE 31\nAOFWAIT   RMODE ANY\n***********************************************************************\n* This is the AOFWAIT REXX function.                                  *\n***********************************************************************\n* command syntax:                                                     *\n*                                                                     *\n* aofwaitrc = AOFWAIT(entryid,timeout)                                *\n*                                                                     *\n* Where entryid is the an entry label for the message entry in the    *\n*       AOF table of the message to wait for and                      *\n*       timeout is the amount of time in seconds to wait              *\n*       for the message to appear.                                    *\n*                                                                     *\n*                                                                     *\n* This command is designed to be used with the AOF application. It is *\n* intended to provide an AOF automation exec  with the capability of  *\n* waiting until a given message appears before continuing. When the   *\n* message appears on the z/OS console, this function will be posted.  *\n* If the message does not appear before the timeout value is reached  *\n* the function will exit with a function value of 4.                  *\n*                                                                     *\n* If the message does appear the function will exit with a function   *\n* value of 0.                                                         *\n***********************************************************************\n*---------------------------------------------------------------------*\n*- register usage                                                    -*\n*---------------------------------------------------------------------*\nR0      EQU    0                  work reg\nR1      EQU    1                  work and parm reg\nR2      EQU    2                  work reg\nR3      EQU    3                  work reg\nR4      EQU    4                  work reg\nR5      EQU    5\nR6      EQU    6\nR7      EQU    7\nR8      EQU    8\nR9      EQU    9\nR10     EQU    10\nR11     EQU    11                 work area base\nR12     EQU    12                 module base\nR13     EQU    13                 linkage\nR14     EQU    14                 linkage\nR15     EQU    15                 linkage\n***********************************************************************\n* begin linkage convention\n       STM     R14,R12,12(R13)\n       LR      R2,R13             Save savearea\n       LR      R10,R1             Save parm pointer\n       LA      R12,0(R15)         base and address regs\n       USING   AOFWAIT,R12\n       USING   PSA,0\n       MODID   ,                  eye catcher and date\n       STORAGE OBTAIN,LENGTH=DYNL get dynamic storage\n       LA      R11,0(0,R1)        use R11 as dyn base\n       USING   DYNAREA,R11        map model over dynamic area\n       LA      R13,SAVEAREA\n       ST      R13,8(R2)          Link saveareas\n       ST      R2,SAVEAREA+4\n******************************************************************\n       L       R1,16(R10)          let's get our argument\n       CLC     0(L'PARMEND,R1),PARMEND    is there an argument\n       BE      BAD_WAIT            no, then send error\n       ICM     R3,15,4(R1)         get the length of argument\n       BZ      BAD_WAIT            if none send error\n       CH      R3,=AL2(L'ENTRYID)    verify it's not too long\n       BH      BAD_WAIT            yes, send error\n       MVI     ENTRYID,C' '\n       MVC     ENTRYID+1(L'ENTRYID-1),ENTRYID\n       STH     R3,ENTRYID_LENGTH   save the length of entryid\n       BCTR    R3,0                decrement for execute move\n       L       R7,0(R1)            and address the argument\n       EX      R3,MOVEENTRYID      MVC   ENTRYID(0),0(R7)\n       B       GET_TIMEOUT\nMOVEENTRYID DS 0H\n       MVC     ENTRYID(*-*),0(R7)  executed\n******************************************************************\nGET_TIMEOUT EQU   *\n       LA      R1,8(,R1)\n       CLC     0(L'PARMEND,R1),PARMEND    is there an argument?\n       BE      DEFAULT_TIMEOUT     no, then use default wait time\n       ICM     R3,15,4(R1)         get the length of descriptor\n       BZ      DEFAULT_TIMEOUT     zero, then use default wait time\n       CH      R3,=H'5'            verify it's not too long\n       BH      BAD_WAIT            no, then continue\n       L       R7,0(R1)            point to the argument\n       LR      R0,R3\n       LR      R1,R7\nTEST_TIMEOUT_LOOP EQU   *\n       CLC     0(1,R1),=C'0'\n       BL      BAD_WAIT\n       CLC     0(1,R1),=C'9'\n       BH      BAD_WAIT\n       LA      R1,1(,R1)\n       BCT     R0,TEST_TIMEOUT_LOOP\n       BCTR    R3,0\n       EX      R3,PACK\n       B       CONVERT_TIMEOUT\nPACK   DS      0H\n       PACK    DWORD,0(*-*,R7)\nCONVERT_TIMEOUT EQU   *\n       CVB     R3,DWORD              convert to binary\n       C       R3,=F'1'\n       BL      BAD_WAIT\n       C       R3,=F'7200'           two hours\n       BH      BAD_WAIT\n       M       R2,=F'100'            change to hundreths\n       ST      R3,TIMEOUTVAL\n       B       TIMEOK\nDEFAULT_TIMEOUT EQU   *\n       MVC     TIMEOUTVAL,=F'1000'   default 10 seconds\n***********************************************************************\n*                                                                     *\n* Set up name_token parm lists\n*\n***********************************************************************\nTIMEOK EQU     *\n       MVC     NT_NAME,NT_NAMEC\n       MVI     NT_ENTRYID,C' '\n       MVC     NT_ENTRYID+1(L'NT_ENTRYID-1),NT_ENTRYID\n       MVC     NT_ENTRYID(L'ENTRYID),ENTRYID\n       LA      R1,NT_LEVEL\n       ST      R1,NTCR_PARMLIST\n       ST      R1,NTDL_PARMLIST\n       LA      R1,NT_NAME\n       ST      R1,NTCR_PARMLIST+4\n       ST      R1,NTDL_PARMLIST+4\n       LA      R1,NT_TOKEN\n       ST      R1,NTCR_PARMLIST+8\n       ST      R1,NTDL_PARMLIST+8\n       LA      R1,NT_PERSOPT\n       ST      R1,NTCR_PARMLIST+12\n       LA      R1,NT_RETCODE\n       ST      R1,NTCR_PARMLIST+16\n       ST      R1,NTDL_PARMLIST+12\n***********************************************************************\n*                                                                     *\n* Create wait ecb token\n*\n***********************************************************************\nSET_TOKEN DS 0H\n       LA      R2,AOFWTECB\n       ST      R2,NT_ECBPTR        deposit ecb ptr into token\n       L       R2,PSAAOLD\n       ST      R2,NT_ASCBPTR       deposit ascb ptr into token\n       XC      NT_RETCODE,NT_RETCODE\n       LA      R1,NTCR_PARMLIST\n       LA      R0,=C'CREATE'\n       SVC     254\n       CLC     NT_RETCODE,=F'4'\n       BH      BAD_TOKEN2\n       BE      BAD_TOKEN1\n       B       DO_STIMER\n***********************************************************************\n*                                                                     *\n* Set up STIMER\n*\n***********************************************************************\nDO_STIMER DS 0H\n***********************************************************************\n* Next, we prepare to await the message. We will wait for one of two  *\n* events, either the message will appear and we will be posted or the *\n* timer will pop, because the message did not appear.                 *\n***********************************************************************\n       MVC     STIMERD(STIMRPEN-STIMRPRE),STIMRPRE     copy STIMER\n       LA      R2,DYNAREA\n       ST      R2,STIMPARM         get address of dsect area for parms\n       LA      R2,STIMEREX         get address of stimer exit\n       ST      R2,STIMREAL         and tell stimer preprocessor\n       STIMER  REAL,STIMERD,BINTVL=TIMEOUTVAL\n***********************************************************************\n* We will awaken upon one of two events. If the STIMER expires, the   *\n* STIMEREX exit is driven, and this will post the ecb. This means that*\n* the expected message never did materialize, and therefore, we will  *\n* dummy up the response, set a condition code of 8 and return.        *\n* On the other hand, if the message did materialize, we will cancel   *\n* stimer, set a condition code of 0 and return.                       *\n***********************************************************************\n       XC      AOFWTECB(4),AOFWTECB\n       XC      STIMRECB(4),STIMRECB\n       LA      R2,AOFWTECB            get address of AOFETECB\n       ST      R2,LISTECBS            store in list\n       LA      R2,STIMRECB            get address of other ecb\n       ST      R2,LISTECBS+4           store in list\n       OI      LISTECBS+4,X'80'       set high order bit\n       WAIT    ECBLIST=LISTECBS\n***********************************************************************\n* We have been posted, either from the message being posted, or from  *\n* the STIMER popping... If posted through our STIMER exit, we are     *\n* ok, if posted through the AOF xmem post, we should cancel the STIMER*\n***********************************************************************\n       TM      AOFWTECB,X'40'         post bit on ?\n       BNO     PSTTSTIM\n       TTIMER  CANCEL\n***********************************************************************\n* Following the TTIMER, there is a chance that the timer exit was     *\n* scheduled (if time remaining is zero) but not yet called.           *\n* We will check to see if we need to handle this rare occurance.      *\n***********************************************************************\n       LTR     R0,R0          any time interval remaining ?\n       BNZ     NOWAIT2        no, no need to be concerned...\n       TM      STIMRECB,X'40' were we already posted ?\n       BNZ     NOWAIT2        no, no need to be concerned...\n       WAIT    ECB=STIMRECB   we have to be concerned... wait till\n*                             stimer exit pops before continuing.\n***********************************************************************\n* Delete the AOF message token.                                       *\n***********************************************************************\nNOWAIT2 DS     0H\n       LA      R1,NTDL_PARMLIST\n       LA      R0,=C'DELETE'\n       SVC     254\n*\n       MVC     RETCODE(2),=H'0'       Set return code\n       B       MSG_POSTED\n*\n***********************************************************************\n* Here, the STIMER exit has popped, and posted the STIMERECB, meaning *\n* that the message has not appeared. we will set a return code of 8   *\n* and terminate.                                                      *\n***********************************************************************\nPSTTSTIM DS    0H\n       LA      R1,NTDL_PARMLIST\n       LA      R0,=C'DELETE'\n       SVC     254\n*\n       B       MSG_TIMEOUT\n***********************************************************************\n*                                                                     *\n* SET REPLY\n*\n***********************************************************************\nMSG_POSTED     EQU   *\n       MVC     REPLY_AREA(L'OK_FUNCTION),OK_FUNCTION\n       L       R8,=A(L'OK_FUNCTION)\n       MVC     RETCODE(2),=CL2'00'    set return code\n       B       SETERRORMSG\nMSG_TIMEOUT    EQU   *\n       MVC     REPLY_AREA(L'ERROR_TIMEOUT),ERROR_TIMEOUT\n       L       R8,=A(L'ERROR_TIMEOUT)\n       MVC     RETCODE(2),=CL2'04'    set return code\n       B       SETERRORMSG\nBAD_TOKEN1     EQU   *\n       MVC     REPLY_AREA(L'ERROR_TOKEN1),ERROR_TOKEN1\n       L       R8,=A(L'ERROR_TOKEN1)\n       MVC     RETCODE(2),=CL2'08'    set return code\n       B       SETERRORMSG\nBAD_TOKEN2     EQU   *\n       MVC     REPLY_AREA(L'ERROR_TOKEN2),ERROR_TOKEN2\n       L       R8,=A(L'ERROR_TOKEN2)\n       MVC     RETCODE(2),=CL2'08'    set return code\n       B       SETERRORMSG\nBAD_WAIT       EQU   *\n       MVC     REPLY_AREA(L'ERROR_FUNCTION),ERROR_FUNCTION\n       L       R8,=A(L'ERROR_FUNCTION)\n       MVC     RETCODE(2),=CL2'08'    set return code\n       B       SETERRORMSG\nSETERRORMSG DS    0H\n       LA      R1,IRXSHVBSTG\n       USING   SHVBLOCK,R1\n       LA      R5,KAOFWAIT_ERROR\n       ST      R5,SHVNAMA\n       LA      R5,REPLY_AREA\n       ST      R5,SHVVALA\n       LA      R5,L'KAOFWAIT_ERROR\n       ST      R5,SHVNAML\n       ST      R8,SHVVALL\n       SR      R0,R0        NO ENVIRONMENT BLOCK\n       ST      R0,SHVNEXT\n       MVI     SHVCODE,SHVSTORE\n       DROP    R1\n       LINK       EP=IRXEXCOM,DCB=0,MF=(E,CALLIST),SF=(E,LINKLIST),    *\n               PARAM=(EYEC,DUMMY,DUMMY,IRXSHVBSTG),VL=1\n       B       SETRETCODE\nSETRETCODE DS  0H\n       L       R7,20(R10)\n       L       R7,0(R7)\n       USING   EVALBLOCK,R7\n       MVC     EVALBLOCK_EVLEN,=F'2'\n       MVC     EVALBLOCK_EVDATA(2),RETCODE\nENDPROG EQU    *\n       L       R3,SAVEAREA+4\n       STORAGE RELEASE,           free dynamic storage                 X\n               LENGTH=DYNL,                                            X\n               ADDR=(R11)\n       SLR     R15,R15\n       L       R14,12(R3)\n       LM      R0,R12,20(R3)\n       BR      R14\n***********************************************************************\n* This is the stimer exit routine. It is branched to by the stimer    *\n* preprocessing routine that is set up to pass parameters. The        *\n* registers on entry to this routine are:                             *\n*                                                                     *\n* R1: address of the aofwait dsect.                                   *\n* R13: savearea                                                       *\n* R14: place to return to.                                            *\n* R15: address of stimerex\n*\n***********************************************************************\nSTIMEREX DS    0H\n       PUSH    USING\n       DROP    R12,R11\n       STM     R14,R12,12(R13)     save os regs for stimer\n       LR      R12,R15             get good base\n       USING   STIMEREX,R12        tell assembler\n       LR      R11,R1              get address of AOFWAIT dsect area\n       USING   DYNAREA,R11         tell assembler\n***********************************************************************\n* The whole idea of this code is to post the ecb associated with the  *\n* stimer. The ecb is now conviently addressable.                      *\n***********************************************************************\n       L       R1,TIMEOUTVAL\n       LA      R2,STIMRECB         get address of stimer ecb\n       POST    (R2),0              post ecb with comp code zero\n***********************************************************************\n* NOW WE WILL TERMINATE STIMER EXIT PROCESSING BY RESTORING REGISTERS *\n* INCLUDING R1 AND R15 PREVIOUSLY DESTROYED. NOTE THAT THESE WERE     *\n* SAVED IN THE DSECT AREA, WHICH WE STILL HAVE ADDRESSABILITY TO.     *\n***********************************************************************\n         L     R15,R15SAVED        restore R15\n         L     R1,R1SAVED          restore R1\n         L     R14,12(R13)         restore return address\n         LM    R2,R12,28(R13)      restore everything else.\n         BR    R14\n         DROP  R11\n         DROP  R12\n         POP   USING\n***********************************************************************\n* Although this looks like real code, it's actually a mechanism used  *\n* to pass a parameter to a stimer exit routine. We will preporcess the*\n* routine with this one, which is copied to the dsect area.           *\n***********************************************************************\nSTIMRPRE DS    0D\n         DROP  R12,R11\n         USING *,R15            on entry, r15 points to stimer exit.\n         ST    R15,20(R15)      store register 15 in dsect area\n         ST    R1,24(R15)       store register 1  in dsect area\n         L     R1,PARMADDR      Load parameter r1 from dsect area\n         L     R15,STMRADDR     load register 15 with \"real\" stimer\n*                               exit routine\n         BR    R15              branch to real stimer exit routine\nSTIMER_CODEL      EQU  *-STIMRPRE    length of code\nR15SAVE           DS    A            room for R15\nR1SAVE            DS    A            room for R1\nSTMRADDR          DC    A(STIMEREX)  address of real stimer exit\nPARMADDR          DS    F            to be filled in by program.\nSTIMRPEN          DS    0H\n*\nPARMEND           DC    X'FFFFFFFFFFFFFFFF'\nERROR_TOKEN1      DC    C'AOFWAIT ECB FOR MESSAGE ALREADY EXISTS'\nERROR_TOKEN2      DC    C'ERROR IN CALL TO IEANTCR'\nERROR_FUNCTION    DC    C'ERROR IN SPECIFYING AOFWAIT FUNCTION'\nERROR_TIMEOUT     DC    C'AOFWAIT TIMED OUT WAITING FOR MESSAGE'\nOK_FUNCTION       DC    C'OK'\nKAOFWAIT_ERROR    DC    C'AOFWAIT_ERROR'\nEYEC              DC    CL8'IRXEXCOM'\nDUMMY             DC    A(0)\nNT_PERSOPT        DC    A(IEANT_NOPERSIST)    persist option\nNT_LEVEL          DC    A(IEANT_SYSTEM_LEVEL)\nNT_NAMEC          EQU   *,16\n                  DC    CL4'~AOF'\n                  DC    CL12' '\n              LTORG\n*================================================================\nDYNAREA       DSECT\nSAVEAREA      DS    18F\nREPLY_AREA    DS    CL120\nENTRYID_LENGTH DS   H\nENTRYID       DS    CL8\nDWORD         DS    D\nTIMEOUTVAL    DS    F\nIEANTCR       DS    A\nIEANTDL       DS    A\nNT_TOKEN      DS    4A       token\n              ORG   NT_TOKEN\nNT_ECBPTR     DS    A\nNT_ASCBPTR    DS    A\n              ORG\nNT_NAME       DS    CL16\n              ORG   NT_NAME\nNT_PREFIX     DS    CL4'~AOF'\nNT_ENTRYID    DS    CL12' '\n              ORG\nNT_RETCODE    DS    F'0'\nNTCR_PARMLIST   DS    5A\nNTDL_PARMLIST   DS    4A\n**\nRETCODE       DS    H\n**\nLINKLIST      LINK    EP=IRXEXCOM,DCB=0,SF=L\nCALLIST       CALL    ,(EYEC,DUMMY,DUMMY,IRXSHVBSTG),VL,MF=L\nIRXSHVBSTG    DS      CL(SHVBLEN)\n**\nLISTECBS      DS    0F\n              DC    A(0)            one for the AOFWTECB\n              DC    X'80'\n              DC    A(0)\nAOFWTECB      DS    F                ecb for the aofwait function\nSTIMRECB      DS    F                ecb for the stimer.\n**\nSTIMERD       DS    0D\n              DS    CL(STIMER_CODEL)   length of code copied here\nR15SAVED      DS    A\nR1SAVED       DS    A\nSTIMREAL      DS    A\nSTIMPARM      DS    F\n*\nDYNL          EQU  *-SAVEAREA\n         IRXSHVB\n         IRXEVALB\n         IEANTASM\n         PRINT ON\n         CVT   DSECT=YES\n         IHAPSA\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AOFWTO": {"ttr": 2823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00!\\x01\\x07(/\\x01\\x14\\x16\\x1f\\x137\\x00\\x9c\\x00\\x9c\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2007-10-09T00:00:00", "modifydate": "2014-06-10T13:37:21", "lines": 156, "newlines": 156, "modlines": 0, "user": "GIBSONJ"}, "text": "          TITLE 'AOF ROUTINE TO WAIT FOR MESSAGE'\n*PROCESS  USING(NOWARN)\nAOFWTO    CSECT ,\nAOFWTO    AMODE 31\nAOFWTO    RMODE ANY\n***********************************************************************\n* This is the AOFWTO REXX function.                                   *\n***********************************************************************\n* command syntax:                                                     *\n*                                                                     *\n* aofwtorc = AOFWTO(text)                                             *\n*                                                                     *\n* Where text is the text to put out with the wto.                     *\n*                                                                     *\n*                                                                     *\n* This command is designed to be used with the AOF application. It is *\n* intended to provide an AOF automation exec  with the capability of  *\n* issuing  a WTO.                                                     *\n*                                                                     *\n***********************************************************************\n*---------------------------------------------------------------------*\n*- register usage                                                    -*\n*---------------------------------------------------------------------*\nR0      EQU    0                  work reg\nR1      EQU    1                  work and parm reg\nR2      EQU    2                  work reg\nR3      EQU    3                  work reg\nR4      EQU    4                  work reg\nR5      EQU    5\nR6      EQU    6\nR7      EQU    7\nR8      EQU    8\nR9      EQU    9\nR10     EQU    10\nR11     EQU    11                 work area base\nR12     EQU    12                 module base\nR13     EQU    13                 linkage\nR14     EQU    14                 linkage\nR15     EQU    15                 linkage\n***********************************************************************\n* begin linkage convention\n       STM     R14,R12,12(R13)\n       LR      R2,R13             Save savearea\n       LR      R10,R1             Save parm pointer\n       LA      R12,0(R15)         base and address regs\n       USING   AOFWTO,R12\n       MODID   ,                  eye catcher and date\n       STORAGE OBTAIN,LENGTH=DYNL get dynamic storage\n       LA      R11,0(0,R1)        use R11 as dyn base\n       USING   DYNAREA,R11        map model over dynamic area\n       LA      R13,SAVEAREA\n       ST      R13,8(R2)          Link saveareas\n       ST      R2,SAVEAREA+4\n******************************************************************\n       L       R1,16(R10)          let's get our argument\n       CLC     0(L'PARMEND,R1),PARMEND    is there an argument\n       BE      BAD_WTO             no, then send error\n       ICM     R3,15,4(R1)         get the length of argument\n       BZ      BAD_WTO             if none send error\n       CH      R3,=AL2(L'WTO_TEXT) verify it's not too long\n       BNH     SAVE_LENGTH         No, set length\n       LH      R3,=AL2(L'WTO_TEXT) set length to max\nSAVE_LENGTH DS 0H\n       STH     R3,WTO_TEXT_LENGTH  save the length of WTO\n       BCTR    R3,0                decrement for executed mvc\n       L       R7,0(R1)            and address the argument\n       EX      R3,MOVEWTO          MVC   WTO_TEXT(0),0(R7)\n       B       DO_WTO\nMOVEWTO DS     0H\n       MVC     WTO_TEXT(*-*),0(R7) executed\n******************************************************************\n***********************************************************************\n*                                                                     *\n* Issue WTO\n*\n***********************************************************************\nDO_WTO EQU     *\n       LA      R4,WTO_TEXT_LENGTH\n       WTO     TEXT=((4)),DESC=12\n       B       OK\n***********************************************************************\n*                                                                     *\n* SET REPLY\n*\n***********************************************************************\nOK     EQU     *\n       MVC     ERROR(L'OK_FUNCTION),OK_FUNCTION\n       L       R8,=A(L'OK_FUNCTION)\n       MVC     RETCODE(2),=CL2'00'    set return code\n       B       SETERRORMSG\nBAD_WTO        EQU   *\n       MVC     ERROR(L'ERROR_FUNCTION),ERROR_FUNCTION\n       L       R8,=A(L'ERROR_FUNCTION)\n       MVC     RETCODE(2),=CL2'08'    set return code\n       B       SETERRORMSG\nSETERRORMSG DS    0H\n       LA      R1,IRXSHVBSTG\n       USING   SHVBLOCK,R1\n       LA      R5,KAOFWTO_ERROR\n       ST      R5,SHVNAMA\n       LA      R5,ERROR\n       ST      R5,SHVVALA\n       LA      R5,L'KAOFWTO_ERROR\n       ST      R5,SHVNAML\n       ST      R8,SHVVALL\n       SR      R0,R0        NO ENVIRONMENT BLOCK\n       ST      R0,SHVNEXT\n       MVI     SHVCODE,SHVSTORE\n       DROP    R1\n       LINK       EP=IRXEXCOM,DCB=0,MF=(E,CALLIST),SF=(E,LINKLIST),    *\n               PARAM=(EYEC,DUMMY,DUMMY,IRXSHVBSTG),VL=1\n       B       SETRETCODE\nSETRETCODE DS  0H\n       L       R7,20(R10)\n       L       R7,0(R7)\n       USING   EVALBLOCK,R7\n       MVC     EVALBLOCK_EVLEN,=F'2'\n       MVC     EVALBLOCK_EVDATA(2),RETCODE\nENDPROG EQU    *\n       L       R3,SAVEAREA+4\n       STORAGE RELEASE,           free dynamic storage                 X\n               LENGTH=DYNL,                                            X\n               ADDR=(R11)\n       SLR     R15,R15\n       L       R14,12(R3)\n       LM      R0,R12,20(R3)\n       BR      R14\n*\nPARMEND           DC    X'FFFFFFFFFFFFFFFF'\nERROR_FUNCTION    DC    C'ERROR IN SPECIFYING AOFWTO FUNCTION'\nOK_FUNCTION       DC    C'OK'\nKAOFWTO_ERROR     DC    C'AOFWTO_ERROR'\nEYEC              DC    CL8'IRXEXCOM'\nDUMMY             DC    A(0)\n              LTORG\n*================================================================\nDYNAREA       DSECT\nSAVEAREA      DS    18F\nERROR         DS    CL120\nDWORD         DS    D\nWTO_TEXT_LENGTH   DS  H\nWTO_TEXT      DS  CL122\n**\nRETCODE       DS    H\n**\nLINKLIST      LINK    EP=IRXEXCOM,DCB=0,SF=L\nCALLIST       CALL    ,(EYEC,DUMMY,DUMMY,IRXSHVBSTG),VL,MF=L\nIRXSHVBSTG    DS      CL(SHVBLEN)\n**\n**\n*\nDYNL          EQU  *-SAVEAREA\n         IRXSHVB\n         IRXEVALB\n         IEANTASM\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AOFWTOR": {"ttr": 2827, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x08\\x009\\x01\\x07'o\\x01\\x07)\\x1f \\x02\\x00\\xe1\\x01\\x9c\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@\"", "ispf": {"version": "01.08", "flags": 0, "createdate": "2007-10-03T00:00:00", "modifydate": "2007-10-18T20:02:39", "lines": 225, "newlines": 412, "modlines": 0, "user": "GIBSONJ"}, "text": "          TITLE 'AOF ROUTINE TO WAIT FOR MESSAGE'\n*PROCESS  USING(NOWARN)\nAOFWTOR   CSECT ,\nAOFWTOR   AMODE 31\nAOFWTOR   RMODE ANY\n***********************************************************************\n* This is the AOFWTOR REXX function.                                  *\n***********************************************************************\n* command syntax:                                                     *\n*                                                                     *\n* aofwtorrc = AOFWTOR(text,reply_length)                              *\n*                                                                     *\n* Where text is the text to put out with the wtor and reply_length    *\n*       is the maximum length of the reply.                           *\n*                                                                     *\n* Deafult reply_length is 119                                         *\n*                                                                     *\n* This command is designed to be used with the AOF application. It is *\n* intended to provide an AOF automation exec  with the capability of  *\n* issuing  a WTOR and getting the reply back in rexx variable         *\n* aofwtor_reply.                                                      *\n*                                                                     *\n* If the message does appear the function will exit with a return     *\n* code of 0.                                                          *\n***********************************************************************\n*---------------------------------------------------------------------*\n*- register usage                                                    -*\n*---------------------------------------------------------------------*\nR0      EQU    0                  work reg\nR1      EQU    1                  work and parm reg\nR2      EQU    2                  work reg\nR3      EQU    3                  work reg\nR4      EQU    4                  work reg\nR5      EQU    5\nR6      EQU    6\nR7      EQU    7\nR8      EQU    8\nR9      EQU    9\nR10     EQU    10\nR11     EQU    11                 work area base\nR12     EQU    12                 module base\nR13     EQU    13                 linkage\nR14     EQU    14                 linkage\nR15     EQU    15                 linkage\n***********************************************************************\n* begin linkage convention\n       STM     R14,R12,12(R13)\n       LR      R2,R13             Save savearea\n       LR      R10,R1             Save parm pointer\n       LA      R12,0(R15)         base and address regs\n       USING   AOFWTOR,R12\n       MODID   ,                  eye catcher and date\n       STORAGE OBTAIN,LENGTH=DYNL get dynamic storage\n       LA      R11,0(0,R1)        use R11 as dyn base\n       USING   DYNAREA,R11        map model over dynamic area\n       LA      R13,SAVEAREA\n       ST      R13,8(R2)          Link saveareas\n       ST      R2,SAVEAREA+4\n******************************************************************\n       L       R1,16(R10)          let's get our argument\n       CLC     0(L'PARMEND,R1),PARMEND    is there an argument\n       BE      BAD_WTOR            no, then send error\n       ICM     R3,15,4(R1)         get the length of argument\n       BZ      BAD_WTOR            if none send error\n       CH      R3,=AL2(L'WTOR_TEXT) verify it's not too long\n       BNH     SAVE_LENGTH         no, set length\n       LH      R3,=AL2(L'WTOR_TEXT) set length to max\nSAVE_LENGTH DS 0H\n       STH     R3,WTOR_TEXT_LENGTH save the length of wtor\n       BCTR    R3,0                decrement for executed mvc\n       L       R7,0(R1)            and address the argument\n       EX      R3,MOVEWTOR\n       B       GET_REPLY_LENGTH\nMOVEWTOR DS    0H\n       MVC     WTOR_TEXT(*-*),0(R7) executed\n******************************************************************\nGET_REPLY_LENGTH EQU   *\n       LA      R1,8(,R1)\n       CLC     0(L'PARMEND,R1),PARMEND    is there an argument?\n       BE      SET_DEFAULT         no, then use default reply length\n       ICM     R3,15,4(R1)         get the length of descriptor\n       BZ      SET_DEFAULT         zero, then use default reply length\n       CH      R3,=H'3'            verify it's not too long\n       BH      BAD_WTOR            too long\n       L       R7,0(R1)            point to the argument\n       LR      R0,R3\n       LR      R1,R7\nTEST_REPLY_LENGTH_LOOP EQU *\n       CLC     0(1,R1),=C'0'\n       BL      BAD_WTOR\n       CLC     0(1,R1),=C'9'\n       BH      BAD_WTOR\n       LA      R1,1(,R1)\n       BCT     R0,TEST_REPLY_LENGTH_LOOP\n       BCTR    R3,0\n       EX      R3,PACK\n       B       CONVERT_REPLY_LENGTH\nPACK   DS      0H\n       PACK    DWORD,0(*-*,R7)\nCONVERT_REPLY_LENGTH EQU *\n       CVB     R3,DWORD              convert to binary\n       C       R3,=F'1'\n       BL      SET_DEFAULT\n       C       R3,=F'119'\n       BH      SET_DEFAULT\n       STH     R3,REPLY_LENGTH\n       B       REPLY_LENGTH_OK\nSET_DEFAULT EQU *\n       MVC     REPLY_LENGTH,=H'119' default to 119\n***********************************************************************\n*                                                                     *\n* Issue WTOR\n*\n***********************************************************************\nREPLY_LENGTH_OK EQU *\n       MVI     REPLY,C' '\n       MVC     REPLY+1(L'REPLY-1),REPLY\n       LA      R2,REPLY\n       XC      WTORECB,WTORECB\n       LA      R3,WTORECB\n       LA      R4,WTOR_TEXT_LENGTH\n       LH      R8,REPLY_LENGTH\n       WTOR    TEXT=((4),(2),(8),(3))\n       WAIT    ECB=(3)\n***********************************************************************\n*                                                                     *\n* SET aofwtor_reply\n*\n***********************************************************************\n       LA      R1,IRXSHVBSTG\n       USING   SHVBLOCK,R1\n       LA      R5,KAOFWTOR_REPLY\n       ST      R5,SHVNAMA\n       LA      R5,REPLY\n       ST      R5,SHVVALA\n       LA      R5,L'KAOFWTOR_REPLY\n       ST      R5,SHVNAML\n       ST      R8,SHVVALL\n       SR      R0,R0        NO ENVIRONMENT BLOCK\n       ST      R0,SHVNEXT\n       MVI     SHVCODE,SHVSTORE\n       DROP    R1\n       LINK       EP=IRXEXCOM,DCB=0,MF=(E,CALLIST),SF=(E,LINKLIST),    *\n               PARAM=(EYEC,DUMMY,DUMMY,IRXSHVBSTG),VL=1\n       B       OK\n***********************************************************************\n*                                                                     *\n* SET REPLY\n*\n***********************************************************************\nOK     EQU     *\n       MVC     ERROR(L'OK_FUNCTION),OK_FUNCTION\n       L       R8,=A(L'OK_FUNCTION)\n       MVC     RETCODE(2),=CL2'00'    set return code\n       B       SETERRORMSG\nBAD_WTOR       EQU   *\n       MVC     ERROR(L'ERROR_FUNCTION),ERROR_FUNCTION\n       L       R8,=A(L'ERROR_FUNCTION)\n       MVC     RETCODE(2),=CL2'08'    set return code\n       B       SETERRORMSG\nSETERRORMSG DS    0H\n       LA      R1,IRXSHVBSTG\n       USING   SHVBLOCK,R1\n       LA      R5,KAOFWTOR_ERROR\n       ST      R5,SHVNAMA\n       LA      R5,ERROR\n       ST      R5,SHVVALA\n       LA      R5,L'KAOFWTOR_ERROR\n       ST      R5,SHVNAML\n       ST      R8,SHVVALL\n       SR      R0,R0        NO ENVIRONMENT BLOCK\n       ST      R0,SHVNEXT\n       MVI     SHVCODE,SHVSTORE\n       DROP    R1\n       LINK       EP=IRXEXCOM,DCB=0,MF=(E,CALLIST),SF=(E,LINKLIST),    *\n               PARAM=(EYEC,DUMMY,DUMMY,IRXSHVBSTG),VL=1\n       B       SETRETCODE\nSETRETCODE DS  0H\n       L       R7,20(R10)\n       L       R7,0(R7)\n       USING   EVALBLOCK,R7\n       MVC     EVALBLOCK_EVLEN,=F'2'\n       MVC     EVALBLOCK_EVDATA(2),RETCODE\nENDPROG EQU    *\n       L       R3,SAVEAREA+4\n       STORAGE RELEASE,           free dynamic storage                 X\n               LENGTH=DYNL,                                            X\n               ADDR=(R11)\n       SLR     R15,R15\n       L       R14,12(R3)\n       LM      R0,R12,20(R3)\n       BR      R14\n*\nPARMEND           DC    X'FFFFFFFFFFFFFFFF'\nERROR_FUNCTION    DC    C'ERROR IN SPECIFYING AOFWTOR FUNCTION'\nOK_FUNCTION       DC    C'OK'\nKAOFWTOR_ERROR    DC    C'AOFWTOR_ERROR'\nKAOFWTOR_REPLY    DC    C'AOFWTOR_REPLY'\nEYEC              DC    CL8'IRXEXCOM'\nDUMMY             DC    A(0)\n              LTORG\n*================================================================\nDYNAREA       DSECT\nSAVEAREA      DS    18F\nREPLY         DS    CL119\nERROR         DS    CL120\nDWORD         DS    D\nWTORECB       DS    F\nREPLY_LENGTH  DS    H\nWTOR_TEXT_LENGTH  DS  H\nWTOR_TEXT     DS  CL122\n**\nRETCODE       DS    H\n**\nLINKLIST      LINK    EP=IRXEXCOM,DCB=0,SF=L\nCALLIST       CALL    ,(EYEC,DUMMY,DUMMY,IRXSHVBSTG),VL,MF=L\nIRXSHVBSTG    DS      CL(SHVBLEN)\n**\n**\n*\nDYNL          EQU  *-SAVEAREA\n         IRXSHVB\n         IRXEVALB\n         IEANTASM\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASMALL": {"ttr": 3077, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00U\\x01\\x07&/\\x01\\x18\\x07\\x9f\\x11 \\x00u\\x00D\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2007-09-19T00:00:00", "modifydate": "2018-03-20T11:20:55", "lines": 117, "newlines": 68, "modlines": 0, "user": "GIBSONJ"}, "text": "//ASMALL   JOB  SYSTEMS,GIBSONJ,CLASS=A,MSGCLASS=X\n//AOFCVTDB EXEC    HLASMCL\n//C.SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//           DD DSN=SYS1.MODGEN,DISP=SHR\n//           DD DSN=SYS0.AOF.SOURCE,DISP=SHR\n//C.SYSIN    DD DSN=SYS0.AOF.SOURCE(AOFCVTDB),DISP=SHR\n//L.SYSLMOD  DD DSNAME=SYS0.AOF.LOADLIB,DISP=SHR\n//L.SYSIN    DD *\n    ENTRY AOFCVTDB\n    NAME  AOFCVTDB(R)\n/*\n//AOFPARS  EXEC    HLASMCL\n//C.SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//           DD DSN=SYS1.MODGEN,DISP=SHR\n//           DD DSN=SYS0.AOF.SOURCE,DISP=SHR\n//C.SYSIN    DD DSN=SYS0.AOF.SOURCE(AOFPARS),DISP=SHR\n//L.SYSLMOD  DD DSNAME=SYS0.AOF.LOADLIB,DISP=SHR\n//L.SYSIN    DD *\n    ENTRY AOFPARS\n    NAME  AOFPARS(R)\n/*\n//AOFBSCAN EXEC    HLASMCL\n//C.SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//           DD DSN=SYS1.MODGEN,DISP=SHR\n//           DD DSN=SYS0.AOF.SOURCE,DISP=SHR\n//C.SYSIN    DD DSN=SYS0.AOF.SOURCE(AOFBSCAN),DISP=SHR\n//L.SYSLMOD  DD DSNAME=SYS0.AOF.LOADLIB,DISP=SHR\n//L.SYSIN    DD *\n    ENTRY AOFBSCAN\n    NAME  AOFBSCAN(R)\n/*\n//AOFLOAD  EXEC    HLASMCL\n//C.SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//           DD DSN=SYS1.MODGEN,DISP=SHR\n//           DD DSN=SYS0.AOF.SOURCE,DISP=SHR\n//C.SYSIN    DD DSN=SYS0.AOF.SOURCE(AOFLOAD),DISP=SHR\n//L.SYSLMOD  DD DSNAME=SYS0.AOF.LOADLIB,DISP=SHR\n//L.SYSIN    DD *\n    INCLUDE SYSLMOD(AOFBSCAN)\n    ENTRY AOFLOAD\n    NAME  AOFLOAD(R)\n/*\n//AOFMATCH EXEC    HLASMCL\n//C.SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//           DD DSN=SYS1.MODGEN,DISP=SHR\n//           DD DSN=SYS0.AOF.SOURCE,DISP=SHR\n//C.SYSIN    DD DSN=SYS0.AOF.SOURCE(AOFMATCH),DISP=SHR\n//L.SYSLMOD  DD DSNAME=SYS0.AOF.LOADLIB,DISP=SHR\n//L.SYSIN    DD *\n    INCLUDE SYSLMOD(AOFBSCAN)\n    INCLUDE SYSLMOD(AOFPARS)\n    INCLUDE SYSLMOD(AOFCVTDB)\n    ENTRY AOFMATCH\n    NAME  AOFMATCH(R)\n/*\n//AOFMCS   EXEC    HLASMCL\n//C.SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//           DD DSN=SYS1.MODGEN,DISP=SHR\n//           DD DSN=SYS0.AOF.SOURCE,DISP=SHR\n//C.SYSIN    DD DSN=SYS0.AOF.SOURCE(AOFMCS),DISP=SHR\n//L.SYSLMOD  DD DSNAME=SYS0.AOF.LOADLIB,DISP=SHR\n//L.SYSIN    DD *\n    INCLUDE SYSLMOD(AOFMATCH)\n    SETCODE AC(1)\n    ENTRY AOFMCS\n    NAME  AOFMCS(R)\n/*\n//AOFWAIT  EXEC    HLASMCL\n//C.SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//           DD DSN=SYS1.MODGEN,DISP=SHR\n//           DD DSN=SYS0.AOF.SOURCE,DISP=SHR\n//C.SYSIN    DD DSN=SYS0.AOF.SOURCE(AOFWAIT),DISP=SHR\n//L.SYSLMOD  DD DSNAME=SYS0.AOF.LOADLIB,DISP=SHR\n//L.SYSIN    DD *\n    ENTRY AOFWAIT\n    NAME  AOFWAIT(R)\n/*\n//AOFWTO   EXEC    HLASMCL\n//C.SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//           DD DSN=SYS1.MODGEN,DISP=SHR\n//           DD DSN=SYS0.AOF.SOURCE,DISP=SHR\n//C.SYSIN    DD DSN=SYS0.AOF.SOURCE(AOFWTO),DISP=SHR\n//L.SYSLMOD  DD DSNAME=SYS0.AOF.LOADLIB,DISP=SHR\n//L.SYSIN    DD *\n    ENTRY AOFWTO\n    NAME  AOFWTO(R)\n/*\n//AOFWTOR  EXEC    HLASMCL\n//C.SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//           DD DSN=SYS1.MODGEN,DISP=SHR\n//           DD DSN=SYS0.AOF.SOURCE,DISP=SHR\n//C.SYSIN    DD DSN=SYS0.AOF.SOURCE(AOFWTOR),DISP=SHR\n//L.SYSLMOD  DD DSNAME=SYS0.AOF.LOADLIB,DISP=SHR\n//L.SYSIN    DD *\n    ENTRY AOFWTOR\n    NAME  AOFWTOR(R)\n/*\n//AOFPAUSE EXEC    HLASMCL\n//C.SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//           DD DSN=SYS1.MODGEN,DISP=SHR\n//           DD DSN=SYS0.AOF.SOURCE,DISP=SHR\n//C.SYSIN    DD DSN=SYS0.AOF.SOURCE(AOFPAUSE),DISP=SHR\n//L.SYSLMOD  DD DSNAME=SYS0.AOF.LOADLIB,DISP=SHR\n//L.SYSIN    DD *\n    ENTRY AOFPAUSE\n    NAME  AOFPAUSE(R)\n/*\n//*//AOFSVC  EXEC     HLASMCL\n//*//C.SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//*//           DD DSN=SYS1.MODGEN,DISP=SHR\n//*//           DD DSN=SYS0.AOF.SOURCE,DISP=SHR\n//*//C.SYSIN    DD DSN=SYS0.AOF.SOURCE(AOFSVC),DISP=SHR\n//*//L.SYSLMOD  DD DSNAME=SYS1.LPALIB,DISP=SHR\n//*//L.SYSIN    DD *\n//*    ENTRY AOFSVC\n//*    NAME  AOFSVC(R)\n//*/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMONE": {"ttr": 3080, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x007\\x01\\x07&\\x8f\\x01\\x14\\x16\\x1f\\x13E\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2007-09-25T00:00:00", "modifydate": "2014-06-10T13:45:37", "lines": 11, "newlines": 11, "modlines": 0, "user": "GIBSONJ"}, "text": "//AOFWTO   JOB  SYSTEMS,GIBSONJ,CLASS=A,MSGCLASS=X\n//AOFWTO   EXEC    HLASMCL\n//C.SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//           DD DSN=SYS1.MODGEN,DISP=SHR\n//           DD DSN=SYS0.AOF.SOURCE,DISP=SHR\n//C.SYSIN    DD DSN=SYS0.AOF.SOURCE(AOFWTO),DISP=SHR\n//L.SYSLMOD  DD DSNAME=SYS0.AOF.LOADLIB,DISP=SHR\n//L.SYSIN    DD *\n    ENTRY AOFWTO\n    NAME  AOFWTO(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMRACF": {"ttr": 3082, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00'\\x01\\x18\\x07\\x9f\\x01\\x18\\x07\\x9f\\x11\\x07\\x000\\x00E\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-03-20T00:00:00", "modifydate": "2018-03-20T11:07:27", "lines": 48, "newlines": 69, "modlines": 0, "user": "GIBSONJ"}, "text": "//ASMRACF  JOB  ,,CLASS=A,MSGCLASS=X\n//ICHRRCDE EXEC PGM=ASMA90,PARM='OBJ,NODECK,RENT,XREF(SHORT)'\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.MODGEN,DISP=SHR\n//SYSLIN   DD  DSN=&&OBJ1,SPACE=(3040,(40,40),,,ROUND),\n//             UNIT=SYSALLDA,DISP=(MOD,PASS),\n//             DCB=(BLKSIZE=3040,LRECL=80,RECFM=FB,BUFNO=1)\n//SYSIN    DD  *\n*  SPECIFY A UNIQUE NUMBER BETWEEN 19 AND 56 INCLUSIVE FOR\n*  POSIT FOR EACH CLASS\n      ICHERCDE CLASS=$TRU,         TRU    CLASS                        +\n               ID=255,                                                 +\n               POSIT=21,                                               +\n               MAXLNTH=44,                                             +\n               FIRST=ALPHANUM,                                         +\n               OTHER=ANY,                                              +\n               DFTUACC=NONE,       DEFAULT ACCESS TO \"NONE\"            +\n               OPER=YES\n*     THE LAST ICHRRCDE MACRO HAS TO BE BLANK\n      ICHERCDE\n               END   ,\n//*\n//LINK1    EXEC PGM=IEWL,PARM='XREF,LET,LIST,NCAL,RENT'\n//SYSPRINT DD  SYSOUT=*\n//SYSLMOD  DD   DSN=SYS1.LINKLIB,DISP=SHR\n//SYSLIN   DD   DSN=&&OBJ1,DISP=(OLD,DELETE)\n//         DD   *\n NAME ICHRRCDE(R)\n/*\n//ICHRFR01 EXEC PGM=ASMA90,PARM='OBJ,NODECK,RENT,XREF(SHORT)'\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.MODGEN,DISP=SHR\n//SYSLIN   DD  DSN=&&OBJ2,SPACE=(3040,(40,40),,,ROUND),\n//             UNIT=SYSALLDA,DISP=(MOD,PASS),\n//             DCB=(BLKSIZE=3040,LRECL=80,RECFM=FB,BUFNO=1)\n//SYSIN    DD   *\nICHRFR01 CSECT\n$TRU     ICHRFRTB CLASS=$TRU,ACTION=RACF\nENDTAB  ICHRFRTB TYPE=END\n        END   ICHRFR01\n/*\n//LINK2    EXEC PGM=IEWL,PARM='XREF,LET,LIST,NCAL,RENT'\n//SYSPRINT DD  SYSOUT=*\n//SYSLMOD  DD   DSN=SYS1.LINKLIB,DISP=SHR\n//SYSLIN   DD   DSN=&&OBJ2,DISP=(OLD,DELETE)\n//         DD   *\n NAME ICHRFR01(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASMSAMP": {"ttr": 3084, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01\\x18\\x07\\x9f\\x01\\x18\\x07\\x9f\\x11H\\x00\\x17\\x00\\x17\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-03-20T00:00:00", "modifydate": "2018-03-20T11:48:10", "lines": 23, "newlines": 23, "modlines": 0, "user": "GIBSONJ"}, "text": "//AOFTBL  JOB ,,CLASS=A,MSGCLASS=X\n//***************************************************************\n//* THIS JCL IS USED TO ASSEMBLE AN AOF AUTOMATED OPERATIONS    *\n//* FACILITY TABLE.                                             *\n//*                                                             *\n//* TO RELOAD TABLE                                             *\n//* F AOF,RELOAD AOFSAMP                                        *\n//*                                                             *\n//***************************************************************\n//ASSEM    EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOALIGN)\n//SYSLIB   DD   DSN=SYS0.AOF.SOURCE,DISP=SHR\n//         DD   DSN=SYS1.MACLIB,DISP=SHR\n//         DD   DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD  UNIT=(SYSDA,SEP=SYSLIB),SPACE=(CYL,(10,5)),DSN=&SYSUT1\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DISP=(,PASS),UNIT=SYSDA,SPACE=(CYL,(5,5)),\n//         DCB=(BLKSIZE=400),DSN=&&LOADSET\n//SYSIN    DD   DSN=SYS0.AOF.TABLES(AOFSAMP),DISP=SHR\n//LKED     EXEC PGM=HEWL,PARM='XREF,LIST,LET'\n//SYSPRINT DD   SYSOUT=*\n//SYSUT1   DD   DSN=&&UT1,UNIT=SYSDA,SPACE=(TRK,(2,1))\n//SYSLIN   DD   DISP=SHR,DSN=&&LOADSET\n//SYSLMOD  DD   DSN=SYS0.AOF.LOADLIB(AOFSAMP),DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ICHRRCDE": {"ttr": 3086, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x18\\x07\\x9f\\x01\\x18\\x07\\x9f\\x10\"\\x00\\x04\\x00\\x04\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-03-20T00:00:00", "modifydate": "2018-03-20T10:22:56", "lines": 4, "newlines": 4, "modlines": 0, "user": "GIBSONJ"}, "text": "ICHRFR01 CSECT\n$TRU     ICHRFRTB CLASS=$TRU,ACTION=RACF\nENDTAB   ICHRFRTB TYPE=END\n         END      ICHRFR01\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEASVC00": {"ttr": 3088, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x18\\x07\\x9f\\x01\\x18\\x07\\x9f\\x11\\x17\\x00\\x06\\x00\\x06\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-03-20T00:00:00", "modifydate": "2018-03-20T11:17:04", "lines": 6, "newlines": 6, "modlines": 0, "user": "GIBSONJ"}, "text": " /* LIB: SYS1.PARMLIB(IEASVC00)                                      */\n /* DOC: THIS MEMBER CONTAINS USER SVC DEFINITIONS.                  */\n /*                                                                  */\n /* 254 IS USED BY AOF                                               */\n /*                                                                  */\n SVCPARM 254,REPLACE,TYPE(4),EPNAME(AOFSVC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MSGCB": {"ttr": 3090, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00X\\x01\\x07&\\x1f\\x01\\x14\"\\x7f\\x10%\\x00<\\x00\\x15\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2007-09-18T00:00:00", "modifydate": "2014-08-15T10:25:58", "lines": 60, "newlines": 21, "modlines": 0, "user": "GIBSONJ"}, "text": "         MACRO\n         MSGCB\n***********************************************************************\n*                                                                     *\n* MSG Control block                                                   *\n*                                                                     *\n*                                                                     *\n* Created                                                             *\n*                                                                     *\n* ddmmmyy   Change description                                        *\n* 29May14   Added MSGDESC1 & MSGDESC2 to hold descriptor codes        *\n*                                                                     *\n***********************************************************************\nMSGCB    DSECT\nMSGCNID  DS    F            Console id\nMSGMCART DS    CL8          CART from message or CIB\nMSGMASID DS    H            ASID of issuer\nMSGMJOBN DS    CL8          Originating job name\nMSGMRPYI DS    CL8          Reply ID (EBCDIC representation)\nMSGCSUPB DS    B            Suppression byte\nMSGCSNSV EQU   X'80'        Not serviced by any WTO user exit routine\nMSGCSEER EQU   X'40'        A WTO user exit ABENDed while processing   X\n                            this message\nMSGCSNSI EQU   X'20'        Not serviced because of an incompatible    X\n                            request\nMSGCSAUT EQU   X'10'        Indicate automation specified\nMSGC_Processed_By_MFA EQU   X'08'    Message Flood Automation          X\n                                     processed this message\nMSGCSSSI EQU   X'04'        Suppressed by a subsystem\nMSGCSWTO EQU   X'02'        Suppressed by a WTO user exit routine\nMSGCSMPF EQU   X'01'        Suppressed by MPF or Message Flood         X\n                            Automation\nMSGCDESC DS    0CL2         Descriptor codes\nMSGDESC1 DS    CL1          Descriptor codes byte 1\nMSGDESCA EQU   X'80'        System failure\nMSGDESCB EQU   X'40'        Immediate action required\nMSGDESCC EQU   X'20'        Eventual action required\nMSGDESCD EQU   X'10'        System status\nMSGDESCE EQU   X'08'        Immediate command response\nMSGDESCF EQU   X'04'        Job status\nMSGDESCG EQU   X'02'        Application program/processor\nMSGDESCH EQU   X'01'        Out-of-line\nMSGDESC2 DS    CL1          Descriptor codes byte 2\nMSGDESCI EQU   X'80'        Operator's request\nMSGDESCJ EQU   X'40'        Reserved\nMSGDESCK EQU   X'20'        Critical eventual action\nMSGDESCL EQU   X'10'        Important Information\nMSGDESCM EQU   X'08'        Previously automated\nMSGDESCN EQU   X'04'        Reserved\nMSGDESCO EQU   X'02'        Reserved\nMSGDESCP EQU   X'01'        Reserved\nMSGLCNT  DS    F            MLWTO line count\nMSGLAST  DS    A            Ptr to Last line\nMSGENTRY DS    255CL128     First 255 LINES OF mlwto\n         ORG   MSGENTRY\nMSGLEN   DS    H\nMSGTEXT  DS    CL126\n         ORG\nMSGCBL   EQU   *-MSGCB\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TABEND": {"ttr": 3092, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00D\\x00\\x97&\\x9f\\x01\\x07)/\\x11%\\x00\\x18\\x00\\x17\\x00\\x0b\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "2007-10-19T11:25:44", "lines": 24, "newlines": 23, "modlines": 11, "user": "GIBSONJ"}, "text": "         MACRO\n.**********************************************************************\n.* VERSION LEVEL - AOF  VERSION 1.0                                   *\n.*                                                                    *\n.* MODIFIED                                                           *\n.*                                                                    *\n.**********************************************************************\n         TABEND\n         GBLA  &ENTCOUNT\n.***************************************************************\n.* THE TABEND MACRO IS USED TO END AN AOF TABLE DEFINITION     *\n.***************************************************************\n         DC    A(0)\n         DC    A(0)\n         DC    CL12'ZZZZZZZZZZZZ'      MESSAGE IDENTIFIER\n         DC    CL8'ZZZZZZZZ'           ACTION PARM\n         DC    A(0)                    NO TEST ENTRIES\n         DC    H'0'                    LENGTH OF ACTION-TEXT\n         DC    CL2'NO'\n         DC    AL4(999999)\n         DC    12C'Z'                  JUST TO MAKE SURE.\nENTCNT   DC    A(&ENTCOUNT)            NUMBER OF ENTRIES.\n         END\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TABENTRY": {"ttr": 3094, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x16\\x00\\x12\\x01\\x022O\\x01\\x14\\x15?\\x08\\x05\\x01K\\x01\\x8c\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.22", "flags": 0, "createdate": "2002-11-20T00:00:00", "modifydate": "2014-06-02T08:05:12", "lines": 331, "newlines": 396, "modlines": 0, "user": "GIBSONJ"}, "text": "         MACRO\n.**********************************************************************\n.* Version level: AOF  Version 1.0                                    *\n.*              : Written  9/20/07                                    *\n.*              : Updated  5/29/14 to include descriptor code test    *\n.*                                                                    *\n.**********************************************************************\n&EID     TABENTRY &MSG=,&ACTION=,&TEXT=,&TEST=,&ECHO=,&MATCHLIM=\n         GBLA  &ENTCOUNT\n         LCLA  &LOOPCNT,&LMATTEXT,&LTEXT\n         LCLB  &BTEXT\n         LCLC  &TTYPE,&STRSTAR,&STRLEN,&SEPCHAR,&MATTEXT\n         LCLC  &ECHOVAR,&MLIMNMBR,&ENTRYID\n&BTEXT   SETB  0\n         AIF   (K'&MSG EQ 0).NOMSG\n         AIF   (K'&ACTION EQ 0).NOACT\n         AIF   ('&ACTION' EQ 'POST').ACTOK\n         AIF   ('&ACTION' EQ 'NONE').ACTOK\n&BTEXT   SETB  1\n         AIF   ('&ACTION' EQ 'OSCMD').ACTOK\n         AIF   ('&ACTION' EQ 'OSCMDT').ACTOK\n         AIF   ('&ACTION' EQ 'REPLY').ACTOK\n         AGO   .ACTBAD\n.ACTOK   ANOP\n.**********************************************************************\n.* ONCE WE VERIFY THE CORRECTNESS OF THE MSG AND ACTION PARMS, WE     *\n.* START GENERATING TSSO AOF CONTROL BLOCKS. THE CONTROL BLOCK HEADER *\n.* IS GENERATED FIRST, FOLLOWED BY ANY TESTS THE USER MAY HAVE        *\n.* SPECIFIED.                                                         *\n.**********************************************************************\nNENT&SYSNDX    DC    A(ENDE&SYSNDX)       ADDRESS OF NEXT MAJOR ENTRY\n               DC    A(0)                 ADDRESS OF NEXT IDENT. ENTRY\n.**********************************************************************\n.*GENERATE THE MSG AND ACTION PARAMATERS, FOLLOWED BY THE TEXT        *\n.*OPERAND.                                                            *\n.**********************************************************************\n         AIF   ('&MSG'(1,1) EQ '''').MSGQUO\nMID&SYSNDX     DC    CL12'&MSG'          MESSAGE TO SEARCH FOR.\n         AGO   .NOMSGQ\n.MSGQUO  ANOP  ,\nMID&SYSNDX     DC    CL12&MSG            MESSAGE TO SEARCH FOR.\n.NOMSGQ  ANOP  ,\nAID&SYSNDX     DC    CL8'&ACTION'        ACTION TYPE\n               DS    0F\n.**********************************************************************\n.* ENSURE THAT MSG='*' IS NOT SPECIFIED UNLESS TEST PARAMETERS ARE ALSO\n.* SPECIFIED.\n.**********************************************************************\n         AIF   ('&MSG' EQ '*' AND N'&TEST EQ 0).NTRAPALL\n         AIF   (N'&TEST EQ 0).GENA0\n.*\n               DC    A(FIRT&SYSNDX)      ADDRESS OF FIRST TEST PARM\n         AGO   .GENCOUNT\n.*\n.GENA0         ANOP\n               DC    A(0)                NO TEST PARM FOR THIS ENTRY\n               AGO   .GENCOUNT\n.*\n.GENCOUNT      ANOP\n.**********************************************************************\n.*UPDATE THE COUNT FIELD FOR GENERATION INTO THIS ENTRY. DEFINE A HALF*\n.*WORD WITH THE CURRENT NUMBER                                        *\n.**********************************************************************\n&ENTCOUNT      SETA  &ENTCOUNT+1\n               DC    AL2(&ENTCOUNT)     AOF ENTRY NUMBER &ENTCOUNT\n               AGO   .GENECHO\n.*\n.GENECHO       ANOP\n.**********************************************************************\n.*CREATE THE ECHO PARAMETER BASED ON USER INPUT. USE THE FOLLOWING    *\n.*TABLE TO DETERMINE ECHO PARAMETERS...                               *\n.*                                                                    *\n.*ECHO=YES :   DC  CL2'YE'                                            *\n.*ECHO=NO  :   DC  CL2'NO'                                            *\n.*ECHO=LOG :   DC  CL2'LO'                                            *\n.*                                                                    *\n.**********************************************************************\n&ECHOVAR       SETC '&ECHO'\n               AIF  ('&ECHOVAR' NE '').ECHOSPEC\n&ECHOVAR       SETC 'NO'\n.ECHOSPEC      ANOP\n               AIF  ('&ECHOVAR' EQ 'YES').ECHOYES\n               AIF  ('&ECHOVAR' EQ 'NO').ECHONO\n               AIF  ('&ECHOVAR' EQ 'LOG').ECHOLOG\n               AGO  .ECHOERR\n.ECHOYES       ANOP\nECHO&ENTCOUNT  DC   CL2'YE'             ECHO = YES SPECIFIED.\n               AGO  .ENDECHO\n.*\n.ECHONO        ANOP\nECHO&ENTCOUNT  DC   CL2'NO'             ECHO = NO  SPECIFIED.\n               AGO  .ENDECHO\n.*\n.ECHOLOG       ANOP\nECHO&ENTCOUNT  DC   CL2'LO'             ECHO = LOG SPECIFIED.\n               AGO  .ENDECHO\n.*\n.ENDECHO       ANOP\n               AGO  .GENMLIM\n.*\n.*\n.GENMLIM       ANOP\n.**********************************************************************\n.*CREATE THE MATCHLIM PARAMETER ENTRY BY GENERATING A FULLWORD WITH   *\n.*THE USER SPECIFIED MATCHLIM COUNT. IF MATCHLIM IS NOT SPECIFIED,    *\n.*IT WILL DEFAULT TO UNLIMITED MATCHING (I.E. ALWAYS PERFORM THE      *\n.*ACTIONS SPECIFIED IN THE ACTION = PARAMETER.                        *\n.*NOTE THAT THE DEFAULT VALUE \"999999\" WILL BE CHECKED BY TSSOSS09    *\n.*AS A FLAG TO DEMONSTRATE NO MATCHLIM IS IN EFFECT.                  *\n.**********************************************************************\n&MLIMNMBR      SETC '&MATCHLIM'\n               AIF  ('&MLIMNMBR' NE '').GOTMTCH\n&MLIMNMBR      SETC '999999'\n.GOTMTCH       ANOP\nMLIM&SYSNDX    DC   AL4(&MLIMNMBR)      MATCH LIMIT VALUE.\n.ENDMTCH       ANOP\n.**********************************************************************\n.*                                                                    *\n.* NEXT, WE GENERATE THE 8 CHARACTER ENTRY ID THAT WAS SPECIFIED IN   *\n.* THE LABEL FIELD OF THE TABENTRY MACRO.                             *\n.*                                                                    *\n.**********************************************************************\n               AIF  (K'&EID  EQ 0).DEFEID\n&ENTRYID       SETC '&EID'\n               AGO  .GENEID\n.*\n.DEFEID        ANOP\n.*\n&ENTRYID       SETC 'ENTR&ENTCOUNT'\n               AGO  .GENEID\n.GENEID        ANOP\n.*\nEID&SYSNDX     DC   CL8'&ENTRYID'\n               AGO  .GENTEXT\n.*\n.*\n.*\n.*\n.GENTEXT       ANOP\n               AIF   (K'&TEXT EQ 0).NOACTTEX\n               AIF   (&BTEXT NE 1).TEXTERR\n&LTEXT         SETA  K'&TEXT\n&LTEXT         SETA  &LTEXT-2\n               DC    AL2(ATEC&SYSNDX-ATEX&SYSNDX)    LENGTH OF ACT-TEXT\nATEX&SYSNDX    DC    C&TEXT             ACTION-TEXT\nATEC&SYSNDX    EQU   *\n               AGO   .DOTESTS\n.*\n.NOACTTEX      ANOP\n               AIF   ('&ACTION' EQ 'POST').ACTOK2\n               AIF   ('&ACTION' EQ 'NONE').ACTOK2\n               AGO   .INVMIX\n.ACTOK2        ANOP\n               DC    AL2(0)             NO ACTION-TEXT\n               AGO   .DOTESTS\n.*\n.*\n.DOTESTS ANOP\n&LOOPCNT SETA  1\nFIRT&SYSNDX    DS    0D\n.*\n.*\n.**********************************************************************\n.* WE ARE NOW READY TO GENERATE THE CONTROL BLOCKS TO REPRESENT ANY   *\n.* TEST ENTRIES WE MAY HAVE FOUND. THE VARIABLE \"TEST\" CONTAINS AN    *\n.* ARRAY OF SUCH ENTRIES. EACH LINE (ROW) CONTAINS THE FOLLOWING      *\n.* VARIABLES:                                                         *\n.*                                                                    *\n.* TEST TYPE, SUBSTRING OR WORD START, LENGTH, MATCHING STRING        *\n.*                                                                    *\n.* AND THE CONTROL BLOCK TO REPRESENT THIS WILL LOOK LIKE:            *\n.*                                                                    *\n.*     DC    A(NEXT TEST CONTROL BLOCK, OR ZERO)                      *\n.*     DC    CL2'TEST TYPE'    S=SUBSTR  W=WORD  L=LINE               *\n.*     DC    F'SUBSTRING OR WORD STARTING POINT OR LINE NO.'          *\n.*                                                                    *\n.* IF THE TEST IS FOR A 'S' OR 'W', THE FOLLOWING DATA IS PRESENT;    *\n.*                                                                    *\n.*     DC    F'LENGTH'                                                *\n.*     DC    CL&LENGTH'MATCHING STRING'                               *\n.*                                                                    *\n.*                                                                    *\n.* THE MACRO WILL LOOP, FOR THE NUMBER OF TEST ENTRIES SPECIFIED      *\n.* GENERATING THESE CONTROL BLOCKS.                                   *\n***********************************************************************\n.TOPTLOOP ANOP\n         AIF   (&LOOPCNT GT  N'&TEST).ENDTESTS\n.*\n         AIF   (&LOOPCNT EQ  N'&TEST).GENA02\n               DC   A(NTE&LOOPCNT.&SYSNDX)\n         AGO   .GENTTYPE\n.*\n.GENA02        DC   A(0)\n         AGO   .GENTTYPE\n.*\n.GENTTYPE ANOP\n.**********************************************************************\n.* HERE, WE GENERATE THE TYPE OF TEST TO PERFORM. THE POSSIBLE TYPES\n.* ARE:\n.*\n.* S  - PERFORM A SUBSTRING MATCHING TEST ON THE MESSAGE\n.* SX - PERFORM A SUBSTRING EXCLUDED TEST ON THE MESSAGE\n.* W  - PERFORM A WORD MATCHING TEST ON THE MESSAGE\n.* WX - PERFORM A WORD EXCLUDED TEST ON THE MESSAGE\n.* L  - PERFORM A LINE NUMBER MATCHING TEST ON THE MESSAGE\n.* D  - PERFORM A DESCRIPTOR CODE MATCHING TEST ON THE MESSAGE\n.**********************************************************************\n&TTYPE   SETC  '&TEST(&LOOPCNT,1)'\n         AIF   ('&TTYPE' EQ 'S').TYPEOK\n         AIF   ('&TTYPE' EQ 'SX').TYPEOK\n         AIF   ('&TTYPE' EQ 'W').TYPEOK\n         AIF   ('&TTYPE' EQ 'WX').TYPEOK\n         AIF   ('&TTYPE' EQ 'L').TYPEOK\n         AIF   ('&TTYPE' EQ 'D').TYPEOK\n         AGO   .TYPEBAD\n.TYPEOK  ANOP\n         DC    CL2'&TTYPE'       TYPE OF ENTRY\n         DC    CL2' '            RESERVED, ALIGN TO WORD BOUNDARY\n.**********************************************************************\n.*\n.* NEXT, GENERATE DESC OR, THE SUBSTRING OR WORD START POINT\n.*\n.**********************************************************************\n         AIF   ('&TTYPE' NE 'D').STRSTDF\n&DESCCDS SETC  '&TEST(&LOOPCNT,2)'\n         DS    0F\n         DC    XL2'&DESCCDS'       DESCRIPTOR CODES TO TEST\n         DC    CL2'  '\n         AGO   .BOTTLOOP\n.STRSTDF ANOP\n&STRSTAR SETC  '&TEST(&LOOPCNT,2)'\n         DC    F'&STRSTAR'       START OF SUBSTR, NO. OF WORD OR LINE\n         AIF   ('&TTYPE' EQ 'L').BOTTLOOP\n.**********************************************************************\n.*\n.* NOW, WE GENERATE THE LENGTH THAT WE WILL COMPARE\n.*\n.**********************************************************************\n&STRLEN  SETC  '&TEST(&LOOPCNT,3)'\n         DC    F'&STRLEN'        LENGTH OF SUBSTRING OR WORD\n.*\n.**********************************************************************\n.*\n.* NOW, WE GENERATE THE POSSIBLE SEPERATOR CHARACTERS, IF THE TYPE WAS\n.* FOR A WORD SEARCH. FIRST, CHECK IF THE TYPE WAS S OR W\n.**********************************************************************\n&SEPCHAR SETC  '&TEST(&LOOPCNT,5)'\n         AIF   ('&TTYPE' EQ 'S').CHEKSERR    CHECK FOR AN ERROR\n         AIF   ('&TTYPE' EQ 'SX').CHEKSERR    CHECK FOR AN ERROR\n.**********************************************************************\n.* TYPE WAS \"W\" - USE SEPCHARS\n.**********************************************************************\n         DC    CL4&SEPCHAR      SEPARATOR CHARS FOR ENTRY\n         AGO   .GENMTEXT\n.*\n.CHEKSERR ANOP\n         AIF   (K'&SEPCHAR EQ 0).GENNSEP\n         AGO   .INVMIX\n.*\n.GENNSEP  ANOP\n          DC   CL4' '            NO SEPARATOR FOR \"S\" TYPE ENTRY\n         AGO   .GENMTEXT\n.*\n***********************************************************************\n.* NOW, WE HAVE GENERATED ALL BUT THE MATCHING TEXT. WE GENERATED THE *\n.* TEXT AS A STRING, PROCEDED BY A TWO BYTE LENGTH FIELD.             *\n.**********************************************************************\n.GENMTEXT ANOP\n&MATTEXT  SETC  '&TEST(&LOOPCNT,4)'\n&LMATTEXT SETA  K'&MATTEXT\n&LMATTEXT SETA  &LMATTEXT-2             ACCOUNT FOR QUOTES\n          DC   H'&LMATTEXT'             LENGTH OF MATCH-TEXT\n          DC   C&MATTEXT                MATCH-TEXT\n***********************************************************************\n.* LASTLY, WE MUST GENERATE THE LABEL TO BE USED BY THE NEXT TEST     *\n.* ENTRY, IF THERE IS ONE, AND INCREMENT &LOOPCNT                     *\n.**********************************************************************\n.BOTTLOOP ANOP\nNTE&LOOPCNT.&SYSNDX   DS     0D\n&LOOPCNT  SETA  &LOOPCNT+1\n          AGO  .TOPTLOOP\n.*\n.ENDTESTS ANOP\n.**********************************************************************\n.* WHEN THE CONTROL BLOCKS FOR ALL THE APPROPRIATE TESTS HAVE BEEN    *\n.* GENERATED, WE GENERATE THE LABEL FOR THE NEXT MSG ENTRY, IF WE     *\n.* HAVE ONE.                                                          *\n.**********************************************************************\nENDE&SYSNDX DS   0D\n          AGO    .ENDIT\n.**********************************************************************\n.* ERROR ROUTINES TO GENERATE MNOTES GO HERE                          *\n.*                                                                    *\n.**********************************************************************\n.NOMSG    ANOP\n  MNOTE 12,'AOFG001A REQUIRED PARAMETER \"MSG\" MISSING'\n          AGO    .ENDIT\n.*\n.NOACT    ANOP\n  MNOTE 12,'AOFG002A REQUIRED PARAMETER \"ACTION\" MISSING'\n          AGO    .ENDIT\n.*\n.ACTBAD   ANOP\n  MNOTE 12,'AOFG003A ACTION PARAMETER INVALID'\n          AGO    .ENDIT\n.*\n.INVMIX   ANOP\n  MNOTE 12,'AOFG004A INVALID MIXTURE OF PARAMETERS- CHECK USER GUIDE'\n          AGO    .ENDIT\n.*\n.TYPEBAD  ANOP\n  MNOTE 12,'AOFG005A TYPE INVALID, MUST BE \"S\" OR \"W\"'\n          AGO    .ENDIT\n.*\n.NTRAPALL ANOP\n  MNOTE 12,'AOFG006A MSG = \"*\" WITH NO TEST PARAMETERS IS INVALID, AS'\n  MNOTE 12,'AOFG006A (CONT) THIS WOULD TRAP ALL WTO MESSAGES'\n          AGO    .ENDIT\n.*\n.ECHOERR  ANOP\n  MNOTE 12,'AOFG007A IMPROPER SPECIFICATION OF ECHO PARAMETER'\n  MNOTE 12,'AOFG007A TRY \"YES\", \"NO\" OR \"LOG\"'\n          AGO    .ENDIT\n.*\n.TEXTERR  ANOP\n  MNOTE 4,'AOFG008I TEXT PARAMETER INVALID FOR THIS ACTION. IGNORED'\n          AGO    .NOACTTEX\n.*\n.ENDIT    ANOP\n          MEXIT\n          MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TABSTART": {"ttr": 3334, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x97&\\x9f\\x01\\x07)/\\x10Y\\x00 \\x00#\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "2007-10-19T10:59:00", "lines": 32, "newlines": 35, "modlines": 0, "user": "GIBSONJ"}, "text": "         MACRO\n.**********************************************************************\n.* Version level: AOF  Version 1.0       09/20/07                     *\n.*                                                                    *\n.*                                                                    *\n.* Modified                                                           *\n.*   DDMMMYY  JAG  COMMENT                                            *\n.*                                                                    *\n.**********************************************************************\n&TABNAME TABSTART &ID=\n          GBLA  &ENTCOUNT\n&ENTCOUNT SETA   0\n          AIF (T'&TABNAME EQ 'O').TABNBAD\n&TABNAME CSECT ,\n&TABNAME AMODE 31\n&TABNAME RMODE ANY\n         DC  A(FIRSTENT)      +0     Address of first entry into table\n         DC  CL8'AOFTABL'     +4     Control block identifier\n         DC  CL8'&ID'         +12    User specified id\n         DC  CL8'&TABNAME'    +20    Name of the table.\n         DC  CL8'&SYSDATE'    +28    Date of assembly\n         DC  CL8'&SYSTIME'    +36    Time of assembly\n         DC  CL8'AOF 1.0'     +44    AOF version number\n         DC  A(ENTCNT)        +52    Address of entry count\n*                             +56\nFIRSTENT DS  0F\n         MEXIT\n.TABNBAD  ANOP\n         MNOTE 12,'The tabstart macro must have a label'\n         AGO   .ERREXIT\n.ERREXIT ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WTOTEST": {"ttr": 3336, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x11\\x01\\x07)\\x0f\\x01\\x18\\x07\\x9f\\x11'\\x00\\x05\\x00\\x0e\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "2007-10-17T00:00:00", "modifydate": "2018-03-20T11:27:11", "lines": 5, "newlines": 14, "modlines": 0, "user": "GIBSONJ"}, "text": "//WTOCALL  JOB  SYSTEMS,&SYSUID,CLASS=A,MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//STEP1    EXEC  PGM=WTO,\n// PARM='XOEZ00068E zFS file system OMVS.ZOS18.TEST.VAR exceeds 85% fulX\n//             l'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMIT": {"ttr": 3338, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00U\\x01\\x18\\x07\\x9f\\x01\\x18\\x07\\x9f\\x13&\\x00\\t\\x00\\t\\x00\\x00\\xc7\\xc9\\xc2\\xe2\\xd6\\xd5\\xd1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-03-20T00:00:00", "modifydate": "2018-03-20T13:26:55", "lines": 9, "newlines": 9, "modlines": 0, "user": "GIBSONJ"}, "text": "//XMIT     JOB  ,,CLASS=A,MSGCLASS=X\n//STEP2    EXEC PGM=IKJEFT1B\n//SYSTSPRT DD   SYSOUT=*\n//SYSTSIN  DD   *\n  EXECUTIL SEARCHDD(YES)\n  PROFILE NOPREFIX\n  XMIT TEST.SYSTEMS NOLOG DSN(SYS0.AOF.SOURCE         ) +\n  OUTDSN(SYS0.AOF.SOURCE.XMIT)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT974/FILE974.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT974", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}