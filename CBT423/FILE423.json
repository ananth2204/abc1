{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012005000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1763580, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 19, "INMDSNAM": "CBT.V500.FILE423.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1763580, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1763580, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE423.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x1d\\x05'", "DS1TRBAL": "b'\\xa3\\xe4'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\x0e\\x00\\x07\\x03\\x10\\x00\\x06\\x00\\x1e'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$$$NEW": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x007\\x00\\x92\\x19\\x1f\\x01\\x18\\x04O\\x14\\x17\\x00\\x19\\x00\\x0e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1992-07-09T00:00:00", "modifydate": "2018-02-13T14:17:37", "lines": 25, "newlines": 14, "modlines": 0, "user": "SBGOLOB"}, "text": "                  A SHORT NOTE FROM SAM GOLOB\n\nI needed Jeff Broido's LAA command to work with SWA \"above the line\",\nso I asked Jeff to fix it.  Jeff obliged.  Jeff thinks that a bunch\nof his other commands also won't work with SWA above the line, but\nhe doesn't have a chance right now to fix this entire file.  I didn't\nwant to deprive all of you from at least using LAA, and seeing how\nJeff fixed it.  Therefore, I'm replacing LAA with the fixed version.\nThe rest of File 423 is unchanged.\n\n                                  Sam Golob  -  July 9, 92.\n\nCreated PUTLINE version of LAA using Howard Dean, Jim Elsworth\ntechnology from File 136.  Old versions still here.    Jan. 20, 2006.\n\n\nP.S.  Macro IHAQDB comes from PVTMACS and is not licensed software.\n      Now macro IHAQDB is in SYS1.MODGEN.  (z/OS 1.1x)\n\nAdditionally:  I've added several programs from Jeff to this file.\n      DUMPV.......DUMP VARIABLES AND THEIR EVALUATIONS\n                  IN CLISTS AND REXX EXECS\n      FINDEM......GDG VOLSER DISPLAY PROGRAM (TSO COMMAND)\n      FIXSMPLG....FIX AN SMP/E LOG FILE THAT WAS CORRUPTED\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00Y\\x00\\x85\\x18/\\x01\\x14 ?\"\\x16\\x00&\\x00\"\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "2014-07-22T22:16:59", "lines": 38, "newlines": 34, "modlines": 0, "user": "SBGOLOB"}, "text": "$$$DOC......THIS MEMBER\n$$$COJRB....ASSEMBLER MACRO FOR COPYRIGHT NOTICE\n#CHECKDD....HELP MEMBER FOR CHECKDD\n#CKDAY......HELP MEMBER FOR CKDAY\n#CKM........HELP MEMBER FOR CKM\n#CKMOUNT....HELP MEMBER FOR CKMOUNT\n#CKO........HELP MEMBER FOR CKO\n#CLRDAY.....HELP MEMBER FOR CLEARDAY\n#LAA........HELP MEMBER FOR LAA\n#QUOTE......HELP MEMBER FOR QUOTE\n#TELL.......HELP MEMBER FOR TELL\nBRODCAST....SOURCE CODE FOR PGM TO LOAD SYS1.BRODCAST\nCHECKDD.....SOURCE CODE FOR PGM TO CHECK FOR ALLOCATED FILENAMES\nCKC.........SOURCE CODE FOR COMMAND TO CHECK AVAILABLE STORAGE\nCKDAY.......SOURCE CODE FOR PGM TO CHECK FOR 1ST LOGON OF THE DAY\nCKM.........SOURCE CODE FOR PGM TO CHECK PRESENCE OF MEMBER IN PDS\nCKMOUNT.....SOURCE CODE FOR PGM TO CHECK A USER'S MOUNT PRIVILEDGE\nCKO.........SOURCE CODE FOR PGM TO CHECK A USER'S PRIVILEDGES\nCMAP........SOURCE CODE FOR PGM TO PRODUCE A CSA STORAGE MAP\nDIGCLK......SOURCE CODE FOR CMD TO DISPLAY TIME ON 3270 TERMINALS\nK...........ASSEMBLER MACRO\nLAA.........SOURCE CODE FOR PGM TO PRODUCE AN EXPANDED ALLOCATION LISTER\nMAPSP.......SOURCE CODE FOR PGM TO PRODUCE MVS/SP STORAGE MAP\nMAPXA.......SOURCE CODE FOR PGM TO PRODUCE MVS/XA STORAGE MAP\nMERKNOW.....SOURCE CODE FOR SUPPORT ROUTINE FOR THE NOW MACRO\nNOW.........ASSEMBLER MACRO\nOFF.........ASSEMBLER MACRO\nON..........ASSEMBLER MACRO\nQUOTE.......SOURCE CODE FOR PGM TO READ 'QUOTE-OF-THE-DAY'\nREGS........ASSEMBLER MACRO\nSMAP........SOURCE CODE FOR PGM TO PRODUCE A STORAGE MAP\nTELL........SOURCE CODE FOR PGM FOR TELECONFERENCING TSO COMMAND\nTERMTYPE....SOURCE CODE FOR PGM THAT SAYS HOW MANY LINES YOUR TERMINAL\n            CAN DISPLAY\nTF..........ASSEMBLER MACRO\nVPUT........ASSEMBLER MACRO\nVTPUT.......ASSEMBLER MACRO\nVWTPU.......ASSEMBLER MACRO\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$#DATE": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00H\\x01 \\x03O\\x01 \\x03O\\x08X\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2020-02-03T00:00:00", "modifydate": "2020-02-03T08:58:48", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-499"}, "text": "REGULAR CBT TAPE - VERSION 499    FILE:  423\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT499.FILE423\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 78 MEMBERS COUNTED; CUMULATIVE SIZE IS 15,849 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   02/03/20    08:58:48    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$COJRB": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00Q\\x00\\x85\\x18/\\x01\\x13\\x13/\\x14U\\x00\\x0e\\x00\\x0f\\x00\\x0e\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "2013-05-12T14:55:51", "lines": 14, "newlines": 15, "modlines": 14, "user": "SBGOLOB"}, "text": ".**********************************************************************\n.*                                                                    *\n.*  COPYRIGHT (C) 19?? BY BROIDO COMPUTER CONSULTING.  ALL RIGHTS     *\n.*  RESERVED EXCEPT:                                                  *\n.*                                                                    *\n.*  PARTICULAR LICENSE IS GRANTED TO DISTRIBUTE THIS MACRO FREE       *\n.*  OF CHARGE, BUT IT MUST NOT BE SOLD.  A SERVICE CHARGE FOR         *\n.*  HANDLING A COLLECTION OF SOFTWARE OF WHICH THIS IS A PART,        *\n.*  ON THE OTHER HAND, IS APPROPRIATE.                                *\n.*                                                                    *\n.*                                  BROIDO COMPUTER CONSULTING        *\n.*                                  broidoj@gmail.com                 *\n.*                                                                    *\n.**********************************************************************\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$$PERMT": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x13\\x12\\x8f\\x01\\x13\\x12\\x8f\\x17\\x00\\x00\\x05\\x00\\x05\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-05-08T00:00:00", "modifydate": "2013-05-08T17:00:53", "lines": 5, "newlines": 5, "modlines": 0, "user": "SBGOLOB"}, "text": "As per a verbal conversation with Jeff Broido in early May 2013,\nJeff gave me permission to put his programs on the CBT Tape.\n\nSam Golob.   2013 May 8\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE01": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00P\\x01\\x14 \\x1f\\x01\\x14 /\\x00'\\x00a\\x00`\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "2014-07-20T00:00:00", "modifydate": "2014-07-21T00:27:50", "lines": 97, "newlines": 96, "modlines": 0, "user": "SBGOLOB"}, "text": "***********************************************************************\n*                                                                     *\n*     LISTHEAD - TSO command to list the eye-catcher, if any, in      *\n*           the entry point CSECT of a load module in the normal      *\n*           search path.                                              *\n*                                                                     *\n*           Modified to list more non-standard eye catchers. (SG)     *\n*                                                                     *\n*     Register usage:                                                 *\n*           R5 - WORK.                                                *\n*           R6 - Work.                                                *\n*           R7 - Work.                                                *\n*           R8 - Work.                                                *\n*           R9 - Work, Parse PDEs.                                    *\n*          R10 - CPPL pointer.                                        *\n*          R12 - Base.                                                *\n*                                                                     *\n*                               Jeffrey R. Broido                     *\n*                               25 April 2001                         *\n*                                                                     *\n*                               Modified by S.Golob  -  4/10          *\n*                               Modified by Updater  -  7/14          *\n*                                                                     *\n*     Change History (of sorts):                                      *\n*                                                                     *\n*        The original purpose of this program seems to have been,     *\n*        to display standard IBM headers in their load modules.       *\n*        Traditionally, an IBM-written load module would begin        *\n*        with an unconditional branch instruction X'47F0' that        *\n*        would branch over a standard-looking eyecatcher which        *\n*        told you the name of the module, and its release or PTF      *\n*        level.  These headers seem to be what the author of          *\n*        this program wanted to display.  ONLY THOSE HEADERS and      *\n*        no others.                                                   *\n*                                                                     *\n*        But things have changed in the IBM world, and the load       *\n*        modules which IBM produces, have fully reflected these       *\n*        changes.                                                     *\n*                                                                     *\n*        There are now other instructions which do unconditional      *\n*        branches, besides the BC instruction (whose unconditional    *\n*        format is X'47F0').  There are JUMP instructions and LARL    *\n*        instructions, and there are also BAKR and PR combinations.   *\n*        IBM uses all of these, and therefore, this program must      *\n*        change to reflect all of this new stuff from IBM.            *\n*                                                                     *\n*        The program works (currently) by issuing a LOAD macro        *\n*        against the entry point of the desired load module, and      *\n*        it searches the first few bytes of the loaded module,        *\n*        to see what is there.  If there are branch or jump           *\n*        instructions, then the program displays what was branched    *\n*        or jumped over.  For diagnosis purposes, if you need to      *\n*        investigate near the beginning of any module entry point,    *\n*        you can activate the option described in the previous        *\n*        paragraph.                                                   *\n*                                                                     *\n*        If a load module contains multiple modules, each with its    *\n*        own header, these are not displayed.  Only the entry point   *\n*        header is displayed.                                         *\n*                                                                     *\n*        Sometimes a program is coded with comments at the beginning  *\n*        and the entry point, off the beginning, points to a BAKR     *\n*        instruction, or something similar, with the (non-executable) *\n*        comments at the beginning.  The LOAD macro does not return   *\n*        the address of these comments, and at the present time       *\n*        therefore, they cannot be displayed.  If the entry point     *\n*        is a BAKR instruction, the program was changed to say so.    *\n*        Hope this helps a bit more than before.  (SBG - June 2014)   *\n*                                                                     *\n*        Updated by Updater (July 20, 2014):                          *\n*        Process now adjusted to load the entire module, even if the  *\n*        entry point is not at the beginning.  This takes care of     *\n*        \"almost normal\" modules from SYS1.VTAMLIB and such, with     *\n*        the entry point just AFTER the eyecatcher.  The command      *\n*        previously would not therefore show such an eyecatcher.      *\n*        So the command was modified to find the address at the       *\n*        beginning of the module, even if the entry point officially  *\n*        was later.  If you want to display the entry point alone,    *\n*        then use the ENTRY keyword after the module name:            *\n*                                                                     *\n*                 example:    LISTHEAD modname ENTRY                  *\n*                                                                     *\n*        Suggestion:  To see the hex values in the first bytes of     *\n*         the header, use a SYSOUTTRAP tool to EDIT or VIEW the       *\n*         output of this command, such as the TSOV tool from CBT      *\n*         File 434 (from Mark Zelden):  Do as follows:                *\n*                                                                     *\n*                 TSO TSOV LISTHEAD modname ENTRY                     *\n*                                                                     *\n*         and put HEX mode on, in ISPF.                               *\n*                                                                     *\n*         For some modules, such as IEBCOPY, you have to use the      *\n*         ENTRY parameter to get a realistic eyecatcher.  You'll      *\n*         have to try both ways with some modules, to see which       *\n*         way shows the beginning of the module more realistically.   *\n*                                                                     *\n***********************************************************************\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE02": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x14 \\x1f\\x01\\x14 \\x1f \\x03\\x00+\\x00+\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-07-20T00:00:00", "modifydate": "2014-07-20T20:03:21", "lines": 43, "newlines": 43, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Re: LISTHEAD program\nFrom:     Updater\nDate:     7/20/2014 3:27 PM\nTo:       Sam Golob <sbgolob@cbttape.org>\n\nHi Sam,\n\nI have put an updated LISTHEAD program in my READY.ASM PDS. It\nnow uses the beginning of the loaded module instead of the entry\npoint, unless the ENTRY keyword is also specified.\n\nThere is nothing special about the imbedded comments in programs\nthat begin with BAKR. In the IKJEFLN2 program the BAKR\ninstruction is identified by the \"END BEGIN\" statement as the\nentry point, so the entry point is not the beginning of the\nloaded program, the comment is. The LOAD macro only returns the\nentry point address, unless the LOADPT= operand is specified.\nThere is no LOADPT= operand on old systems like MVS 3.8. I don't\nknow when that was added.\n\nInstead of using LOADPT=, I added code to find the CDE for the\nloaded module, which leads to the beginning address of the loaded\nmodule, regardless of the entry point. That might work on MVS 3.8\ntoo, but I haven't tried it.\n\nI also changed the logic that displays the first 200 bytes, so it\ndisplays fewer than 200 if the module size is less than 200.\n\nI also added a keyword named ENTRY that makes the command use the\nentry point like it did before, so you can see the difference.\n\nA program could be coded with comments just like those in\nIKJEFLN2, with no branch around them, and still use STM or the\nSAVE macro, as long as the entry point in the END statement\nspecifies the line with the STM or SAVE macro. There is no\nconvention that a program using BAKR has to be coded like\nIKJEFLN2. IKJEFLN2 might be the only one coded that way.\n\nA program could also be coded with a branch around the comments,\nfollowed by a BAKR.\n\nBest wishes. .\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE03": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x07\\x01\\x16)?\\x01\\x16)?#8\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-10-19T00:00:00", "modifydate": "2016-10-19T23:38:07", "lines": 12, "newlines": 12, "modlines": 0, "user": "SBGOLOB"}, "text": "Note about the LAA program.\n\nBack in 1978, the macro IHAQDB was probably in PVTMACS and not in\nSYS1.MODGEN.  So that is why Jeff Broido probably saw fit to include\nit internally in the source.  Nowadays this macro is in SYS1.MODGEN.\n\nSo I removed the macro source from the LAA program source.  It gets\nincluded from SYS1.MODGEN in the SYSLIB concatenation in the assembly.\n\nSBG (Sam Golob - 2016/10/19)\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE04": {"ttr": 533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x18\\x04O\\x01\\x18\\x04O\\x01\\x13\\x00\\x02\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-02-13T00:00:00", "modifydate": "2018-02-13T01:13:09", "lines": 2, "newlines": 2, "modlines": 0, "user": "SBGOLOB"}, "text": "Note:  You can get rid of some of the dependency on the Broido macro\n       library, by replacing his REGS macro with IBM's new YREGS macro.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$MACLIB": {"ttr": 535, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x007\\x00\\x85\\x18/\\x01\\x13\\x13/\\x15\\x07\\t\\x9c\\t\\xaa\\x00\\x00\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "2013-05-12T15:07:37", "lines": 2460, "newlines": 2474, "modlines": 0, "user": "BROIDO"}, "text": "./ ADD NAME=$$$COJRB 0104-82333-86143-2103-00017-00015-00017-JEFBRO\n.*\n.**********************************************************************\n.*                                                                    *\n.*   COPYRIGHT (C) 19XX BY JEFFREY R. BROIDO.  ALL RIGHTS RESERVED.   *\n.*                                                                    *\n.*   LICENSE IS HEREBY GRANTED TO WESTERN UNION TELEGRAPH COMPANY     *\n.*   AND ITS AFFILIATES TO USE THIS MACRO.  HOWEVER, IT MUST NOT      *\n.*   BE SOLD, GIVEN, OR OTHERWISE DISTRIBUTED TO ANY OTHER            *\n.*   COMPANY OR DATA CENTER WITHOUT PRIOR WRITTEN PERMISSION OF:      *\n.*                                                                    *\n.*                                                                    *\n.*                                 JEFFREY R. BROIDO                  *\n.*                                 broidoj@gmail.com                  *\n.*                                                                    *\n.***********************************************************************\n.*\n./ ADD NAME=EMACRO   0104-84300-84301-1418-00026-00030-00011-ANDERSO\n         MACRO\n&NAME    EMACRO &PLIST,&PROCESS\n.*\n.*       This macro issues an ISREDIT MACRO command to identify\n.* an assembler program as an edit macro\n.*\n         LCLC  &CP,&OPT\n&CP      SETC  ''\n&OPT     SETC  'PROCESS'\n.LUP     AIF   ('&PROCESS' EQ '&CP').GO\n         AIF   ('&PROCESS' EQ '&CP.PR').GO\n         AIF   ('&PROCESS' EQ '&CP.PROC').GO\n         AIF   ('&PROCESS' EQ '&CP.PROCESS').GO\n         AIF   ('&OPT' EQ 'NOPROCESS').MERR\n&CP      SETC  'NO'\n&OPT     SETC  'NOPROCESS'\n         AGO   .LUP\n.*\n.GO      ANOP\n&NAME    ISRED 'MACRO &PLIST &OPT'\n         MEXIT\n.*\n.MERR    ANOP\n         MNOTE 8,'ILLEGAL PARAMETER.'\n         MNOTE '    USE ''PROCESS'' OR ''NOPROCESS''.'\n         MEND\n./ ADD NAME=GCALL    0116-82225-82333-1754-00913-00272-00913-ZADSJBR\n         MACRO\n&NAME    GCALL &AAB=AAB,&GPARMS=GPARMS\n         LCLA  &CURSOR,&IX\n         LCLC  &W\n.*\n.**********************************************************************\n.*                                                                    *\n.*   COPYRIGHT (C) 1982 BY JEFFREY R. BROIDO.  ALL RIGHTS RESERVED.   *\n.*                                                                    *\n.*   LICENSE IS HEREBY GRANTED TO AMERICAN INTERNATIONAL GROUP AND    *\n.*   ITS AFFILIATES TO USE THIS MACRO.  HOWEVER, IT MUST NOT BE BE    *\n.*   SOLD, GIVEN, OR OTHERWISE DISTRIBUTED TO ANY OTHER COMPANY OR    *\n.*   DATA CENTER WITHOUT PRIOR WRITTEN PERMISSION OF:                 *\n.*                                                                    *\n.*                                                                    *\n.*                                 JEFFREY R. BROIDO                  *\n.*                                 broidoj@gmail.com                  *\n.*                                                                    *\n.**********************************************************************\n.*\n.*\n.**********************************************************************\n.*                                                                    *\n.*  GCALL - MACRO TO CALL GDDM ROUTINES VIA THE SYSTEM PROGRAMMER     *\n.*     INTERFACE.  FORMAT IS:  GCALL MNEMONIC,PARM,PARM, ETC.  IT     *\n.*     IS ASSUMED THAT YOUR APPLICATION ANCHOR BLOCK IS AT            *\n.*     ADDRESS AAB (OR SPECIFY AAB=).  YOU MUST ALSO HAVE DEFINED     *\n.*     A SERIES OF FULLWORDS AT LABEL GPARMS FOR THE PARMS TO BE      *\n.*     STORED IN, AT LEAST ONE WORD FOR EACH POSSIBLE PARM.  YOU      *\n.*     MUST ALSO DEFINE A WORD AT LABEL ADMASPP THAT CONTAINS THE     *\n.*     ADDRESS OF ROUTINE ADMASP (EITHER LOADED OR LINKED).  SEE      *\n.*     MANUAL SC33-0101-1 FOR EXPLANATION.  VERSION 1.00 WRITTEN      *\n.*     AT A.I.G.  BY J.  BROIDO, 8/11/82.                             *\n.*                                                                    *\n.**********************************************************************\n.*\n         AIF   (N'&SYSLIST NE 0).NOT0\n         MNOTE 4,'GCALL NEEDS AT LEAST ONE PARM; RESULT IS NOP.'\n         MEXIT\n.NOT0    ANOP\n&NAME    LA    1,&GPARMS           POINT TO EXTERNAL PARM LIST.\n         LA    0,&AAB              MOVE ADDRESS OF APPLICATION ...\n         ST    0,0(,1)             ... ANCHOR BLOCK TO PARM LIST.\n&W       SETC  '&SYSLIST(1)'\n         AIF   ('&W' NE 'FSTRCE').#001\n         LA    0,=X'00020000'      SPECIFY TRACE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#001    AIF   ('&W' NE 'FSEXIT').#002\n         LA    0,=X'00030000'      SPECIFY SET ERROR EXIT.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#002    AIF   ('&W' NE 'FSQERR').#003\n         LA    0,=X'00040000'      SPECIFY QUERY LAST ERROR.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#003    AIF   ('&W' NE 'SPINIT').#004\n         LA    0,=X'00050000'      SPECIFY SPI SPECIAL INIT.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#004    AIF   ('&W' NE 'ESLIB').#005\n         LA    0,=X'08142000'      SPECIFY DEFINE LIBRARY.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#005    AIF   ('&W' NE 'ESPCB').#006\n         LA    0,=X'081C1000'      SPECIFY DEFINE PCB.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#006    AIF   ('&W' NE 'FSTERM').#007\n         LA    0,=X'0C000000'      SPECIFY TERMINATION.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#007    AIF   ('&W' NE 'FSINIT').#008\n         LA    0,=X'0C000001'      SPECIFY INITIALIZATION.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#008    AIF   ('&W' NE 'FSRNIT').#009\n         LA    0,=X'0C000002'      SPECIFY RE-INITIALIZATION.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#009    AIF   ('&W' NE 'DSOPEN').#010\n         LA    0,=X'0C000200'      SPECIFY OPEN DEVICE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#010    AIF   ('&W' NE 'DSCLS').#011\n         LA    0,=X'0C000201'      SPECIFY CLOSE DEVICE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#011    AIF   ('&W' NE 'DSUSE').#012\n         LA    0,=X'0C000202'      SPECIFY DEVICE USAGE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#012    AIF   ('&W' NE 'DSDROP').#013\n         LA    0,=X'0C000203'      SPECIFY DROP DEVICE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#013    AIF   ('&W' NE 'DSQUID').#014\n         LA    0,=X'0C000204'      SPECIFY QUERY UNIQUE DEVICE ID.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#014    AIF   ('&W' NE 'DSQUSE').#015\n         LA    0,=X'0C000205'      SPECIFY QUERY USAGE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#015    AIF   ('&W' NE 'DSQDEV').#016\n         LA    0,=X'0C000206'      SPECIFY QUERY DEVICE CHRISTCS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#016    AIF   ('&W' NE 'DSRNIT').#017\n         LA    0,=X'0C000207'      SPECIFY RE-INIT DEVICE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#017    AIF   ('&W' NE 'FSPCRT').#018\n         LA    0,=X'0C040000'      SPECIFY PAGE CREATION.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#018    AIF   ('&W' NE 'FSPSEL').#019\n         LA    0,=X'0C040001'      SPECIFY PAGE SELECTION.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#019    AIF   ('&W' NE 'FSPDEL').#020\n         LA    0,=X'0C040002'      SPECIFY PAGE DELETION.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#020    AIF   ('&W' NE 'FSPCLR').#021\n         LA    0,=X'0C040003'      SPECIFY PAGE CLEAR.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#021    AIF   ('&W' NE 'FSPQRY').#022\n         LA    0,=X'0C040004'      SPECIFY QUERY PAGE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#022    AIF   ('&W' NE 'FSQCPG').#023\n         LA    0,=X'0C040005'      SPECIFY QUERY CURRENT PAGE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#023    AIF   ('&W' NE 'SSQF').#024\n         LA    0,=X'0C040100'      SPECIFY QUERY S SETS ON FILE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#024    AIF   ('&W' NE 'PSQSS').#025\n         LA    0,=X'0C040101'      SPECIFY QUERY LOADED PS SETS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#025    AIF   ('&W' NE 'GSQNSS').#026\n         LA    0,=X'0C040102'      SPECIFY QUERY NO LOADED GRA SS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#026    AIF   ('&W' NE 'GSQSS').#027\n         LA    0,=X'0C040103'      SPECIFY QUERY LOADED GRPHCS SS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#027    AIF   ('&W' NE 'PSLSS').#028\n         LA    0,=X'0C040200'      SPECIFY LOAD PROG SYMBOL SET.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#028    AIF   ('&W' NE 'PSLSSC').#029\n         LA    0,=X'0C040201'      SPECIFY COND LOAD PROG SYM SET.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#029    AIF   ('&W' NE 'PSDSS').#030\n         LA    0,=X'0C040202'      SPECIFY DEFINE PROG SYMBOL SET.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#030    AIF   ('&W' NE 'PSRSV').#031\n         LA    0,=X'0C040203'      SPECIFY RESERVE PROG SYM SET.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#031    AIF   ('&W' NE 'GSLSS').#032\n         LA    0,=X'0C040300'      SPECIFY LOAD GRPH SYMBOL SET.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#032    AIF   ('&W' NE 'GSDSS').#033\n         LA    0,=X'0C040301'      SPECIFY DEFINE GRPH SYMBOL SET.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#033    AIF   ('&W' NE 'PSRSS').#034\n         LA    0,=X'0C040400'      SPECIFY RELEASE PROG SYM SET.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#034    AIF   ('&W' NE 'GSRSS').#035\n         LA    0,=X'0C040401'      SPECIFY RELEASE GRPH SYM SET.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#035    AIF   ('&W' NE 'FSQDEV').#036\n         LA    0,=X'0C040500'      SPECIFY QUERY DEVICE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#036    AIF   ('&W' NE 'FSQUPG').#037\n         LA    0,=X'0C040900'      SPECIFY QUERY UNIQUE PAGE ID.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#037    AIF   ('&W' NE 'SSREAD').#038\n         LA    0,=X'0C040B00'      SPECIFY READ SYMBOL SET.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#038    AIF   ('&W' NE 'SSWRT').#039\n         LA    0,=X'0C040B01'      SPECIFY WRITE SYMBOL SET.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#039    AIF   ('&W' NE 'FSALRM').#040\n         LA    0,=X'0C080000'      SPECIFY SOUND ALARM.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#040    AIF   ('&W' NE 'ASFCUR').#041\n         LA    0,=X'0C080100'      SPECIFY MOVE CURSOR.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#041    AIF   ('&W' NE 'ASDFLT').#042\n         LA    0,=X'0C080200'      SPECIFY SET DEFAULT FLD ATTRS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#042    AIF   ('&W' NE 'ASDTRN').#043\n         LA    0,=X'0C080300'      SPECIFY DEFINE XLATE TABLE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#043    AIF   ('&W' NE 'ASFCLR').#044\n         LA    0,=X'0C080400'      SPECIFY CLEAR ALPHA FIELDS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#044    AIF   ('&W' NE 'ASFTYP').#045\n         LA    0,=X'0C080500'      SPECIFY SET FIELD TYPE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#045    AIF   ('&W' NE 'ASFINT').#046\n         LA    0,=X'0C080501'      SPECIFY SET FIELD INTENSITY.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#046    AIF   ('&W' NE 'ASFCOL').#047\n         LA    0,=X'0C080502'      SPECIFY SET FIELD COLOR.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#047    AIF   ('&W' NE 'ASFPSS').#048\n         LA    0,=X'0C080503'      SPECIFY SET FIELD PRIMARY SS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#048    AIF   ('&W' NE 'ASFHLT').#049\n         LA    0,=X'0C080504'      SPECIFY SET FIELD HILITE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#049    AIF   ('&W' NE 'ASFEND').#050\n         LA    0,=X'0C080505'      SPECIFY SET END FLD ATTRIBUTE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#050    AIF   ('&W' NE 'ASFOUT').#051\n         LA    0,=X'0C080506'      SPECIFY SET FIELD O/P NULLS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#051    AIF   ('&W' NE 'ASFIN').#052\n         LA    0,=X'0C080507'      SPECIFY SET FIELD I/P BLANKS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#052    AIF   ('&W' NE 'ASFTRN').#053\n         LA    0,=X'0C080508'      SPECIFY SET FLD XLATE TABLE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#053    AIF   ('&W' NE 'ASCHLT').#054\n         LA    0,=X'0C080600'      SPECIFY SET CHARACTER HILITES.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#054    AIF   ('&W' NE 'ASCCOL').#055\n         LA    0,=X'0C080601'      SPECIFY SET CHARACTER COLORS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#055    AIF   ('&W' NE 'ASCSS').#056\n         LA    0,=X'0C080602'      SPECIFY SET CHAR SYMBOL SETS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#056    AIF   ('&W' NE 'ASCPUT').#057\n         LA    0,=X'0C080603'      SPECIFY SET CHARACTER CODES.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#057    AIF   ('&W' NE 'ASDFLD').#058\n         LA    0,=X'0C080700'      SPECIFY DEFINE ALPHA FIELD.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#058    AIF   ('&W' NE 'ASRFMT').#059\n         LA    0,=X'0C080800'      SPECIFY REDEFINE ALPHA FIELDS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#059    AIF   ('&W' NE 'ASDFMT').#060\n         LA    0,=X'0C080801'      SPECIFY DEFINE ALPHA FIELDS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#060    AIF   ('&W' NE 'ASRATT').#061\n         LA    0,=X'0C080802'      SPECIFY REDEFINE FIELD ATTR.S.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#061    AIF   ('&W' NE 'ASQHLT').#062\n         LA    0,=X'0C080900'      SPECIFY QUERY CHAR HILITES.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#062    AIF   ('&W' NE 'ASQCOL').#063\n         LA    0,=X'0C080901'      SPECIFY QUERY CHARACTER COLORS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#063    AIF   ('&W' NE 'ASQSS').#064\n         LA    0,=X'0C080902'      SPECIFY QUERY CHAR SYMBOL SETS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#064    AIF   ('&W' NE 'ASCGET').#065\n         LA    0,=X'0C080903'      SPECIFY QUERY CHARACTER CODES.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#065    AIF   ('&W' NE 'ASQFLD').#066\n         LA    0,=X'0C080A00'      SPECIFY QUERY FLD ATTRIBUTES.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#066    AIF   ('&W' NE 'ASQMOD').#067\n         LA    0,=X'0C080B00'      SPECIFY QUERY MODIFIED FIELDS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#067    AIF   ('&W' NE 'FSREST').#068\n         LA    0,=X'0C080C00'      SPECIFY RESTORE SCREEN.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#068    AIF   ('&W' NE 'ASMODE').#069\n         LA    0,=X'0C080D00'      SPECIFY SET REPLY MODE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#069    AIF   ('&W' NE 'ASQMAX').#070\n         LA    0,=X'0C080E00'      SPECIFY QUERY NO. OF FIELDS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#070    AIF   ('&W' NE 'ASQCUR').#071\n         LA    0,=X'0C080F00'      SPECIFY QUERY CURSOR.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#071    AIF   ('&W' NE 'ASFMOD').#072\n         LA    0,=X'0C081100'      SPECIFY MODIFY FIELD.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#072    AIF   ('&W' NE 'ASTYPE').#073\n         LA    0,=X'0C081300'      SPECIFY SET TERMINAL TYPE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#073    AIF   ('&W' NE 'ASGPUT').#074\n         LA    0,=X'0C081503'      SPECIFY SET DUAL-CHARACTERS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#074    AIF   ('&W' NE 'ASGGET').#075\n         LA    0,=X'0C081603'      SPECIFY QUERY DUAL-CHARACTERS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#075    AIF   ('&W' NE 'GSFLD').#076\n         LA    0,=X'0C0C0000'      SPECIFY GRAPHICS FIELD.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#076    AIF   ('&W' NE 'GSPS').#077\n         LA    0,=X'0C0C0001'      SPECIFY PICTURE SPACE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#077    AIF   ('&W' NE 'GSWIN').#078\n         LA    0,=X'0C0C0002'      SPECIFY  SPECIFY WINDOW.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#078    AIF   ('&W' NE 'GSVIEW').#079\n         LA    0,=X'0C0C0003'      SPECIFY  SPECIFY VIEWPORT.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#079    AIF   ('&W' NE 'GSQPS').#080\n         LA    0,=X'0C0C0004'      SPECIFY QUERY PICTURE SPACE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#080    AIF   ('&W' NE 'GSQVIE').#081\n         LA    0,=X'0C0C0005'      SPECIFY QUERY VIEWPORT.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#081    AIF   ('&W' NE 'GSQWIN').#082\n         LA    0,=X'0C0C0006'      SPECIFY QUERY WINDOW.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#082    AIF   ('&W' NE 'GSQMAX').#083\n         LA    0,=X'0C0C0100'      SPECIFY QUERY SEGMENT RANGE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#083    AIF   ('&W' NE 'GSQCUR').#084\n         LA    0,=X'0C0C0101'      SPECIFY QUERY CURSOR.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#084    AIF   ('&W' NE 'GSQCEL').#085\n         LA    0,=X'0C0C0202'      SPECIFY QUERY CELL SIZE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#085    AIF   ('&W' NE 'GSCLP').#086\n         LA    0,=X'0C0C0203'      SPECIFY  SPECIFY CLIPPING.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#086    AIF   ('&W' NE 'GSQCLP').#087\n         LA    0,=X'0C0C0204'      SPECIFY QUERY CLIPPING.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#087    AIF   ('&W' NE 'GSSEG').#088\n         LA    0,=X'0C0C0300'      SPECIFY CREATE SEGMENT.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#088    AIF   ('&W' NE 'GSSCLS').#089\n         LA    0,=X'0C0C0301'      SPECIFY CLOSE SEGMENT.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#089    AIF   ('&W' NE 'GSSDEL').#090\n         LA    0,=X'0C0C0302'      SPECIFY DELETE SEGMENT.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#090    AIF   ('&W' NE 'GSCLR').#091\n         LA    0,=X'0C0C0303'      SPECIFY CLEAR GRAPHICS FIELD.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#091    AIF   ('&W' NE 'GSMOVE').#092\n         LA    0,=X'0C0C0400'      SPECIFY MOVE TO.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#092    AIF   ('&W' NE 'GSLINE').#093\n         LA    0,=X'0C0C0401'      SPECIFY LINE TO.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#093    AIF   ('&W' NE 'GSPLNE').#094\n         LA    0,=X'0C0C0402'      SPECIFY POLYLINE TO.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#094    AIF   ('&W' NE 'GSMARK').#095\n         LA    0,=X'0C0C0406'      SPECIFY MARKER AT.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#095    AIF   ('&W' NE 'GSMRKS').#096\n         LA    0,=X'0C0C0407'      SPECIFY POLY MARKER AT.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#096    AIF   ('&W' NE 'GSAREA').#097\n         LA    0,=X'0C0C0408'      SPECIFY BEGIN AREA.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#097    AIF   ('&W' NE 'GSENDA').#098\n         LA    0,=X'0C0C0409'      SPECIFY END AREA.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#098    AIF   ('&W' NE 'GSVECM').#099\n         LA    0,=X'0C0C040A'      SPECIFY VECTOR.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#099    AIF   ('&W' NE 'GSCHAR').#100\n         LA    0,=X'0C0C0500'      SPECIFY CHARACTER STRING AT.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#100    AIF   ('&W' NE 'GSCHAP').#101\n         LA    0,=X'0C0C0501'      SPECIFY CHARACTER STRING.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#101    AIF   ('&W' NE 'GSARC').#102\n         LA    0,=X'0C0C0600'      SPECIFY ARC.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#102    AIF   ('&W' NE 'GSELPS').#103\n         LA    0,=X'0C0C0601'      SPECIFY ELLIPSE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#103    AIF   ('&W' NE 'GSPFLT').#104\n         LA    0,=X'0C0C0602'      SPECIFY FILLET.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#104    AIF   ('&W' NE 'GSQCP').#105\n         LA    0,=X'0C0C0700'      SPECIFY QUERY CURRENT POSN.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#105    AIF   ('&W' NE 'GSCOL').#106\n         LA    0,=X'0C0C0701'      SPECIFY SET COLOR.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#106    AIF   ('&W' NE 'GSMIX').#107\n         LA    0,=X'0C0C0702'      SPECIFY SET MIX MODE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#107    AIF   ('&W' NE 'GSLT').#108\n         LA    0,=X'0C0C0703'      SPECIFY SET LINE TYPE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#108    AIF   ('&W' NE 'GSLW').#109\n         LA    0,=X'0C0C0704'      SPECIFY SET LINE WIDTH.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#109    AIF   ('&W' NE 'GSCM').#110\n         LA    0,=X'0C0C0705'      SPECIFY SET CHARACTER MODE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#110    AIF   ('&W' NE 'GSCS').#111\n         LA    0,=X'0C0C0706'      SPECIFY SET CHARACTER SET.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#111    AIF   ('&W' NE 'GSCB').#112\n         LA    0,=X'0C0C0707'      SPECIFY SET CHARACTER BOX.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#112    AIF   ('&W' NE 'GSCA').#113\n         LA    0,=X'0C0C0708'      SPECIFY SET CHARACTER ANGLE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#113    AIF   ('&W' NE 'GSCD').#114\n         LA    0,=X'0C0C0709'      SPECIFY SET CHARACTER DIRCTN.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#114    AIF   ('&W' NE 'GSPAT').#115\n         LA    0,=X'0C0C070A'      SPECIFY SET PATTERN.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#115    AIF   ('&W' NE 'GSMS').#116\n         LA    0,=X'0C0C070B'      SPECIFY SET MARKER SYMBOL.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#116    AIF   ('&W' NE 'GSCH').#117\n         LA    0,=X'0C0C070C'      SPECIFY SET CHARACTER SHEAR.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#117    AIF   ('&W' NE 'GSQCOL').#118\n         LA    0,=X'0C0C0711'      SPECIFY QUERY COLOR.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#118    AIF   ('&W' NE 'GSQMIX').#119\n         LA    0,=X'0C0C0712'      SPECIFY QUERY MIX MODE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#119    AIF   ('&W' NE 'GSQLT').#120\n         LA    0,=X'0C0C0713'      SPECIFY QUERY LINE TYPE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#120    AIF   ('&W' NE 'GSQLW').#121\n         LA    0,=X'0C0C0714'      SPECIFY QUERY LINE WIDTH.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#121    AIF   ('&W' NE 'GSQCM').#122\n         LA    0,=X'0C0C0715'      SPECIFY QUERY CHARACTER MODE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#122    AIF   ('&W' NE 'GSQCS').#123\n         LA    0,=X'0C0C0716'      SPECIFY QUERY CHARACTER SET.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#123    AIF   ('&W' NE 'GSQCB').#124\n         LA    0,=X'0C0C0717'      SPECIFY QUERY CHARACTER BOX.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#124    AIF   ('&W' NE 'GSQCA').#125\n         LA    0,=X'0C0C0718'      SPECIFY QUERY CHARACTER ANG.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#125    AIF   ('&W' NE 'GSQCD').#126\n         LA    0,=X'0C0C0719'      SPECIFY QUERY CHARACTER DIRN.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#126    AIF   ('&W' NE 'GSQPAT').#127\n         LA    0,=X'0C0C071A'      SPECIFY QUERY PATTERN.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#127    AIF   ('&W' NE 'GSQMS').#128\n         LA    0,=X'0C0C071B'      SPECIFY QUERY MARKER SYMBOL.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#128    AIF   ('&W' NE 'GSQCH').#129\n         LA    0,=X'0C0C071C'      SPECIFY QUERY CHARACTER SHEAR.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#129    AIF   ('&W' NE 'GSPUT').#130\n         LA    0,=X'0C0C0900'      SPECIFY INCLUDE GDF.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#130    AIF   ('&W' NE 'GSIMG').#131\n         LA    0,=X'0C0C0A00'      SPECIFY LIMITED IMAGE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#131    AIF   ('&W' NE 'GSGETS').#132\n         LA    0,=X'0C0C0B00'      SPECIFY RETRIEVE GDF.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#132    AIF   ('&W' NE 'GSGETE').#133\n         LA    0,=X'0C0C0B01'      SPECIFY END GDF RETRIEVAL.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#133    AIF   ('&W' NE 'GSGET').#134\n         LA    0,=X'0C0C0B02'      SPECIFY GET GDF BUFFER.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#134    AIF   ('&W' NE 'ASREAD').#135\n         LA    0,=X'0C100000'      SPECIFY READ.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#135    AIF   ('&W' NE 'FSFRCE').#136\n         LA    0,=X'0C100001'      SPECIFY FORCE OUTPUT.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#136    AIF   ('&W' NE 'FSCHEK').#137\n         LA    0,=X'0C100002'      SPECIFY PREPARE PS FOR OUTPUT.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#137    AIF   ('&W' NE 'FSSAVE').#138\n         LA    0,=X'0C100004'      SPECIFY SAVE SCREEN.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#138    AIF   ('&W' NE 'FSSHOW').#139\n         LA    0,=X'0C100005'      SPECIFY SHOW SCREEN.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#139    AIF   ('&W' NE 'FSOPEN').#140\n         LA    0,=X'0C180000'      SPECIFY OPEN PRINTER DESTINTN.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#140    AIF   ('&W' NE 'FSCOPY').#141\n         LA    0,=X'0C180001'      SPECIFY PAGE COPY.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#141    AIF   ('&W' NE 'GSCOPY').#142\n         LA    0,=X'0C180002'      SPECIFY GRAPHICS COPY.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#142    AIF   ('&W' NE 'FSLOG').#143\n         LA    0,=X'0C180003'      SPECIFY LINE-BY-LINE OUTPUT.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#143    AIF   ('&W' NE 'FSCLS').#144\n         LA    0,=X'0C180004'      SPECIFY CLOSE PRINTER DESTINTN.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#144    AIF   ('&W' NE 'CHTERM').#145\n         LA    0,=X'10000100'      SPECIFY TERMINATE BUS. GRAPHIC.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#145    AIF   ('&W' NE 'CHRNIT').#146\n         LA    0,=X'10010100'      SPECIFY REINITIALIZE BUS GRAPH.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#146    AIF   ('&W' NE 'CHSET').#147\n         LA    0,=X'10020101'      SPECIFY SET OPTIONS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#147    AIF   ('&W' NE 'CHKEY').#148\n         LA    0,=X'10020201'      SPECIFY CHART KEYS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#148    AIF   ('&W' NE 'CHHEAD').#149\n         LA    0,=X'10020202'      SPECIFY CHART HEADING.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#149    AIF   ('&W' NE 'CHMARK').#150\n         LA    0,=X'10020301'      SPECIFY MARKER INFORMATION.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#150    AIF   ('&W' NE 'CHLT').#151\n         LA    0,=X'10020302'      SPECIFY LINETYPES TO USE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#151    AIF   ('&W' NE 'CHCOL').#152\n         LA    0,=X'10020303'      SPECIFY COLORS TO USE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#152    AIF   ('&W' NE 'CHPAT').#153\n         LA    0,=X'10020304'      SPECIFY SHADING PATTERNS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#153    AIF   ('&W' NE 'CHXSET').#154\n         LA    0,=X'10020401'      SPECIFY X AXIS SELECTION.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#154    AIF   ('&W' NE 'CHYSET').#155\n         LA    0,=X'10020402'      SPECIFY Y AXIS SELECTION.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#155    AIF   ('&W' NE 'CHXTTL').#156\n         LA    0,=X'10020501'      SPECIFY X AXIS TITLE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#156    AIF   ('&W' NE 'CHYTTL').#157\n         LA    0,=X'10020502'      SPECIFY Y AXIS TITLE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#157    AIF   ('&W' NE 'CHXLAB').#158\n         LA    0,=X'10020503'      SPECIFY X AXIS LABEL.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#158    AIF   ('&W' NE 'CHYLAB').#159\n         LA    0,=X'10020504'      SPECIFY Y AXIS LABEL.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#159    AIF   ('&W' NE 'CHXSCL').#160\n         LA    0,=X'10020607'      SPECIFY SET X SELECT.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#160    AIF   ('&W' NE 'CHYSCL').#161\n         LA    0,=X'10020608'      SPECIFY SET Y SEL.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#161    AIF   ('&W' NE 'CHXMTH').#162\n         LA    0,=X'10020609'      SPECIFY SET X AXIS MONTH.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#162    AIF   ('&W' NE 'CHYMTH').#163\n         LA    0,=X'1002060A'      SPECIFY SET Y AXIS MONTH.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#163    AIF   ('&W' NE 'CHXDAY').#164\n         LA    0,=X'1002060B'      SPECIFY SET X AXIS DAY.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#164    AIF   ('&W' NE 'CHYDAY').#165\n         LA    0,=X'1002060C'      SPECIFY SET Y AXIS DAY.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#165    AIF   ('&W' NE 'CHNUM').#166\n         LA    0,=X'1002060F'      SPECIFY SET # OF COMPONENTS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#166    AIF   ('&W' NE 'CHGAP').#167\n         LA    0,=X'10020610'      SPECIFY SET BAR GAP WIDTH.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#167    AIF   ('&W' NE 'CHGGAP').#168\n         LA    0,=X'10020611'      SPECIFY SET BAR GROUP GAP.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#168    AIF   ('&W' NE 'CHHMAR').#169\n         LA    0,=X'10020612'      SPECIFY SET HORZIONTAL MARGINS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#169    AIF   ('&W' NE 'CHVMAR').#170\n         LA    0,=X'10020613'      SPECIFY SET VERTICLE MARGINS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#170    AIF   ('&W' NE 'CHPIER').#171\n         LA    0,=X'10020614'      SPECIFY SET PIE REDUCTION.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#171    AIF   ('&W' NE 'CHCGRD').#172\n         LA    0,=X'10020615'      SPECIFY SET CHARACTER SIZE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#172    AIF   ('&W' NE 'CHVCHR').#173\n         LA    0,=X'10020616'      SPECIFY # CHARS ON BAR.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#173    AIF   ('&W' NE 'CHFINE').#174\n         LA    0,=X'1002061A'      SPECIFY # CURVE-FIT LINES.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#174    AIF   ('&W' NE 'CHAATT').#175\n         LA    0,=X'10020701'      SPECIFY SET AXIS ATTRIBUTES.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#175    AIF   ('&W' NE 'CHGATT').#176\n         LA    0,=X'10020702'      SPECIFY SET GRID ATTRIBUTES.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#176    AIF   ('&W' NE 'CHKEYP').#177\n         LA    0,=X'10020801'      SPECIFY SET KEY POSITIONING.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#177    AIF   ('&W' NE 'CHHATT').#178\n         LA    0,=X'10020901'      SPECIFY SET HEADING ATTRIBUTES.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#178    AIF   ('&W' NE 'CHTATT').#179\n         LA    0,=X'10020902'      SPECIFY SET TITLE ATTRIBUTES.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#179    AIF   ('&W' NE 'CHLATT').#180\n         LA    0,=X'10020903'      SPECIFY SET LABEL ATTRIBUTES.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#180    AIF   ('&W' NE 'CHKATT').#181\n         LA    0,=X'10020905'      SPECIFY SET KEY ATTRIBUTES.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#181    AIF   ('&W' NE 'CHVATT').#182\n         LA    0,=X'10020906'      SPECIFY SET VALUE ATTRIBUTES.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#182    AIF   ('&W' NE 'CHAREA').#183\n         LA    0,=X'10020A02'      SPECIFY SET AREA      BOUNDS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#183    AIF   ('&W' NE 'CHXRNG').#184\n         LA    0,=X'100A0601'      SPECIFY SET X AXIS RANGE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#184    AIF   ('&W' NE 'CHYRNG').#185\n         LA    0,=X'100A0602'      SPECIFY SET Y AXIS RANGE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#185    AIF   ('&W' NE 'CHXINT').#186\n         LA    0,=X'100A0603'      SPECIFY SET X INTERCEPT.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#186    AIF   ('&W' NE 'CHYINT').#187\n         LA    0,=X'100A0604'      SPECIFY SET Y INTERCEPT.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#187    AIF   ('&W' NE 'CHXTIC').#188\n         LA    0,=X'100A0605'      SPECIFY SET X TIC MARK.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#188    AIF   ('&W' NE 'CHYTIC').#189\n         LA    0,=X'100A0606'      SPECIFY SET Y TICK MARK.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#189    AIF   ('&W' NE 'CHKOFF').#190\n         LA    0,=X'100A0618'      SPECIFY SET LEGEND OFFSETS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#190    AIF   ('&W' NE 'CHKMAX').#191\n         LA    0,=X'100A0619'      SPECIFY SET LEGEND DIMENSIONS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#191    AIF   ('&W' NE 'CHNOFF').#192\n         LA    0,=X'100B0617'      SPECIFY SET ANNOTATION OFFSETS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#192    AIF   ('&W' NE 'CHNATT').#193\n         LA    0,=X'100B0904'      SPECIFY SET ANNOTATION ATTRBTS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#193    AIF   ('&W' NE 'CHDATT').#194\n         LA    0,=X'100B0A01'      SPECIFY SET DATUM LINE ATTRBTS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#194    AIF   ('&W' NE 'CHBATT').#195\n         LA    0,=X'100B0A03'      SPECIFY SET CHART BOX      ATTRBTS.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#195    AIF   ('&W' NE 'CHBAR').#196\n         LA    0,=X'100D0A01'      SPECIFY PLOT A BAR CHART.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#196    AIF   ('&W' NE 'CHHIST').#197\n         LA    0,=X'100D0A02'      SPECIFY PLOT A HISTOGRAM.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#197    AIF   ('&W' NE 'CHPLOT').#198\n         LA    0,=X'100D0A03'      SPECIFY PLOT A LINE GRAPH.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#198    AIF   ('&W' NE 'CHSURF').#199\n         LA    0,=X'100D0A04'      SPECIFY PLOT A SURFACE CHART.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#199    AIF   ('&W' NE 'CHVENN').#200\n         LA    0,=X'100D0A05'      SPECIFY MAKE A VENN DIAGRAM.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#200    AIF   ('&W' NE 'CHPIE').#201\n         LA    0,=X'100D0A06'      SPECIFY CONSTRUCT A PIE CHART.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#201    AIF   ('&W' NE 'CHXDTM').#202\n         LA    0,=X'100E060D'      SPECIFY SET X AXIS DATUM LINE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#202    AIF   ('&W' NE 'CHYDTM').#203\n         LA    0,=X'100E060E'      SPECIFY SET Y AXIS DATUM LINE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#203    AIF   ('&W' NE 'CHXSEL').#204\n         LA    0,=X'100F0801'      SPECIFY CHANGE X AXIS SELECTED.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#204    AIF   ('&W' NE 'CHYSEL').#205\n         LA    0,=X'100F0802'      SPECIFY CHANGE Y AXIS SELECTED.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#205    AIF   ('&W' NE 'CHSTRT').#206\n         LA    0,=X'10110100'      SPECIFY RESUME STATE ONE.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#206    AIF   ('&W' NE 'CHNOTE').#207\n         LA    0,=X'10130100'      SPECIFY ANNOTATE CHART.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#207    AIF   ('&W' NE 'CHDRAX').#208\n         LA    0,=X'10140100'      SPECIFY REDRAW SELECTED AXES.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#208    AIF   ('&W' NE 'CHART').#209\n         LA    0,=X'14000000'      SPECIFY CHART UTILITY.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#209    AIF   ('&W' NE 'ISSE').#210\n         LA    0,=X'18000000'      SPECIFY INVOKE SYMBOL EDITOR.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.#210    AIF   ('&W' NE 'VSSE').BADCODE\n         LA    0,=X'20000000'      SPECIFY INVOKE VECTOR EDITOR.\n         ST    0,4(,1)             SAVE ITS POINTER IN PARM LIST.\n         AGO   .PP\n.BADCODE MNOTE 8,'&W IS NOT A VALID FUNCTION CODE.'\n         MEXIT\n.PP      ANOP\n&CURSOR  SETA  4                   SET OUTPUT PARM CURSOR TO 4.\n&IX      SETA  1                   SET INPUT PARM INDEX TO 1.\n.LOOP    ANOP\n&IX      SETA  &IX+1               BUMP PARM INDEX.\n         AIF   (&IX GT N'&SYSLIST).MRKLAST\n&CURSOR  SETA  &CURSOR+4           BUMP OUTPUT CURSOR.\n         AIF   ('&SYSLIST(&IX)' NE '').NOTNULL\n         LA    0,=F'0'             INDICATE NULL PARAMETER AND ...\n         AGO   .STORE\n.NOTNULL AIF   ('&SYSLIST(&IX)(1,1)' NE '(').NOTREG\n&W       SETC  '&SYSLIST(&IX)'\n&W       SETC  '&W'(2,K'&W-1)\n         LR    0,&W                LOAD PARAMETER AND ...\n         AGO   .STORE\n.NOTREG  LA    0,&SYSLIST(&IX)     LOAD PARAMETER AND ...\n.STORE   ST    0,&CURSOR.(,1)      ... STORE PARAMETER IN LIST.\n         AGO   .LOOP\n.MRKLAST OI    &CURSOR.(1),X'80'   MARK END OF VARIABLE PARM LIST.\n         L     15,ADMASPP          POINT TO GDDM SPI MODULE.\n         BALR  14,15               BRANCH TO GDDM.\n         MEND\n./ ADD NAME=HOME     0105-80094-82335-0931-00024-00007-00019-ZADSJBR\n         MACRO\n&N       HOME\n.*\n.**********************************************************************\n.*                                                                    *\n.*   COPYRIGHT (C) 1980 BY JEFFREY R. BROIDO.  ALL RIGHTS RESERVED.   *\n.*                                                                    *\n.*   LICENSE IS HEREBY GRANTED TO AMERICAN INTERNATIONAL GROUP AND    *\n.*   ITS AFFILIATES TO USE THIS MACRO.  HOWEVER, IT MUST NOT BE BE    *\n.*   SOLD, GIVEN, OR OTHERWISE DISTRIBUTED TO ANY OTHER COMPANY OR    *\n.*   DATA CENTER WITHOUT PRIOR WRITTEN PERMISSION OF:                 *\n.*                                                                    *\n.*                                                                    *\n.*                                 JEFFREY R. BROIDO                  *\n.*                                 broidoj@gmail.com                  *\n.*                                                                    *\n.**********************************************************************\n.*\n&N       LA    0,4                     LOAD LENGTH.\n         LA    1,=X'F1114040'          POINT TO HOME SEQUENCE.\n         ICM   1,8,=X'03'              SET FULLSCR OPTION.\n         SVC   93                      INVOKE TPUT.\n         MEND\n./ ADD NAME=IKJERASE 0103-79066-81120-1639-00007-00007-00007-BROIDO\n         MACRO\n&N       IKJERASE ,                    IDENTICAL TO THE ERASE MACRO.\n&N       LA    0,9                     LOAD LENGTH.\n         LA    1,=X'F11140403C40400013'\n         ICM   1,8,=X'03'              SET FULLSCR OPTION.\n         SVC   93                      INVOKE TPUT.\n         MEND\n./ ADD NAME=ISRED    0104-84304-84306-1149-00072-00066-00008-ANDERSO\n         MACRO\n&NAME    ISRED &CMD,&LEN\n         LCLC  &T1,&T2,&CMDN,&LENN\n         LCLB  &R01,&R02,&DLEN,&LN1B\n&CMDN    SETC  'CMD&SYSNDX'\n&LENN    SETC  'LEN&SYSNDX'\n&T1      SETC  '&CMD'(1,1)         TEST FOR LITERAL OR CONSTANT\n&DLEN    SETB  (K'&LEN EQ 0)\n&R01     SETB  0\n&R02     SETB  0\n&NAME    B     GO&SYSNDX           BRANCH AROUND CONSTANTS\n         AIF   (D'ISREDLIT).SKIP1  GENERATE 'ISREDIT' ONLY IF NEEDED\nISREDLIT DC    CL8'ISREDIT'\n.SKIP1   ANOP\n         AIF   ('&T1' EQ ''''  AND  &DLEN).CENTLEN\n         AIF   ('&T1' EQ '''').DCCMD\n         AIF   ('&T1' EQ '(').REGCMD\n&CMDN    SETC  '&CMD'\n         AGO   .DOLENG\n.DCCMD   ANOP\nCMD&SYSNDX DC  C&CMD\n         AGO   .DOLENG\n.REGCMD  ANOP\nCMD&SYSNDX DS  F\n&R01     SETB  1\n.DOLENG  ANOP\n         AIF   (K'&LEN EQ 0).DEFLEN\n&T2      SETC  '&LEN'(1,1)\n         AIF   ('&T2' EQ '''').DCLEN\n         AIF   ('&T2' EQ '(').REGLEN\n&LENN    SETC  '&LEN'              LENGTH FIELD FROM SPECIFIED FIELD\n         AGO   .DOCODE\n.REGLEN  ANOP\nLEN&SYSNDX DS  F\n&R02     SETB  1\n         AGO   .DOCODE\n.DCLEN   ANOP\nLEN&SYSNDX DC  F&LEN               LENGTH FROM LITERAL\n         AGO   .DOCODE\n.DEFLEN  ANOP\n&GLEN    SETA  L'&CMD\nLEN&SYSNDX DC  F'&GLEN'            GENERATE LENGTH FROM ATTRIBUTE\n&LN1B    SETB  (&GLEN EQ 1)        TEST FOR DEFAULT ATTRIBUTE\n         AGO   .DOCODE\n.CENTLEN ANOP\n         AIF   (D'EDMLENG0).SKIP2  GENERATE LENGTH FIELD = 0 IF NEEDED\nEDMLENG0 DC    F'0'\n.SKIP2   ANOP\nLEN&SYSNDX EQU EDMLENG0\nCMD&SYSNDX DC  C'\u00a2'                GENERATE COMMAND DELIMITED BY '\u00a2'\n         DC    C&CMD\n         DC    C'\u00a2'\n         DS    0H\n.DOCODE  ANOP\nGO&SYSNDX DS   0H\n         AIF   (NOT &LN1B).NOLENG\n&L       SETC  'L''&CMD'\n         LA    15,&L               USE LENGTH ATTRIBUTE AT ASSEMBLY\n         ST    15,LEN&SYSNDX           TIME.  MAY BE MORE ACCURATE\n.NOLENG  ANOP\n         AIF   (NOT (&R01)).NOSAV1\n&CK      SETA  K'&CMD-2\n&CSTR    SETC  '&CMD'(2,&CK)\n         ST    &CSTR,CMD&SYSNDX    STORE COMMAND FROM REGISTER\n.NOSAV1  ANOP\n         AIF   (NOT (&R02)).NOSAV2\n&CK      SETA  K'&LEN-2\n&CSTR    SETC  '&LEN'(2,&CK)\n         ST    &CSTR,LEN&SYSNDX    STORE LENGTH FROM REGISTER\n.NOSAV2  ANOP\n         CALL  ISPLINK,(ISREDLIT,&LENN,&CMDN),VL\n         MEND\n./ ADD NAME=JTPUT,SSI=38111094\n         MACRO\n&NAME    TPUT  &BFF,&SIZE,&EDIT,&WAIT,&HOLD,&BRKI,&PRTY,&TJID=,        *\n               &TJIDLOC=,&ASID=,&ASIDLOC=,&USERIDL=,&MF=       @G76XRYU\n.* A000000-999999                                              @G76XR00\n.* A770501,896051,896076,896158,896167,960000                  @OZ43223\n.* C896050,896054,896063-896064,896075,896089,896157,896159,   @OZ43223\n.* C896166,896168                                              @OZ43223\n.* D896058-896062,896083-896087                                @OZ43223\n.* C204500,206000-207000,216500,218000-218500,D219000          @OZ44359\n.*\n         LCLA  &FLAGON,&FLAGOFF,&FLAGS2,&OPT,&NTJ,&RET         @G76XRYU\n         LCLB  &E,&W,&H,&B,&P,&OLDBUFF                         @G76XRYU\n         LCLC  &TSID,&TSIDLOC,&PARM,&NDX,&ID                   @G76XRYU\n&NDX     SETC  '&SYSNDX'                                       @G76XRYU\n         AIF   (N'&SYSLIST LE 7).POSOPOK .IF TOO MANY OPERANDS @G76XRYU\n         MNOTE 12,'IHB300 EXCESSIVE POSITIONAL OPERANDS SPECIFIED'\n         MEXIT                                                 @G76XRYU\n.POSOPOK ANOP                         ..POSITIONAL OPERANDS OK @G76XRYU\n         AIF   ('&MF' EQ '').FORMOK     NON-EXTENDED FORM OK   @G76XRYU\n         AIF   ('&MF' EQ 'I' OR '&MF' EQ 'L' OR ('&MF(1)' EQ 'E' AND N'*\n               &MF EQ 2)).FORMOK     ...FORMAT OPERANDS OK...  @G76XRYU\n         MNOTE 12,'IHB303 INVALID OPERAND MF=&MF '             @G76XRYU\n         MEXIT                                                 @G76XRYU\n.FORMOK  ANOP                                                  @G76XRYU\n         AIF   (('&BFF' EQ '' OR '&SIZE' EQ '') AND '&MF' EQ '').ERROR1\n         AIF   ('&SIZE' EQ '' AND '&MF' EQ 'I').SIZERR         @G76XRYU\n         AIF   ('&BFF' NE '' OR '&MF' NE 'I').BFFEXOK          @G76XRYU\n         MNOTE 12,'IHB300 BUFFER ADDRESS NOT SPECIFIED'        @G76XRYU\n         MEXIT                                                 @G76XRYU\n.BFFEXOK ANOP              ...BUFFER ADDR GIVEN W/ MF=I,E,L    @G76XRYU\n&ID      SETC  '0'                                             @G76XRYU\n&FLAGOFF SETA  127                   ...SET FOR AND OPERATION  @G76XRYU\n&NTJ     SETA  N'&TJID+N'&TJIDLOC+N'&ASID+N'&ASIDLOC+N'&USERIDL\n         AIF   (&NTJ GT 1).ERROR2\n         AIF   (&NTJ EQ 0).KEEPID    ..IF ANY ID SPECIFIED ..  @G76XRYU\n&FLAGOFF SETA  &FLAGOFF-64            ..INSURE USER ID FLAG    @G76XRYU\n.*                                      TURNED OFF FOR EX FORM @G76XRYU\n.KEEPID  ANOP                        ..ELSE RETAIN PRESENT SET @G76XRYU\n&TSID    SETC  '&ASID&TJID'\n&TSIDLOC SETC  '&ASIDLOC&TJIDLOC'\n         AIF   ('&EDIT' EQ 'R').RF      CHECK FOR R FORM\n&PARM    SETC  '&EDIT'\n         AIF   ('&USERIDL' EQ '').CKPARM\n&OPT     SETA  X'40'                    DENOTE USERID SPECIFIED\n&FLAGON  SETA  &FLAGON+64               TO OR USER ID FLAG     @G76XRYU\n.CKPARM  ANOP\n&RET     SETA  &RET+1\n         AIF   ('&PARM' EQ '').RET           NULL, TRY NEXT\n         AIF   ('&PARM' EQ 'EDIT').EDI       SET EDIT\n         AIF   ('&PARM' EQ 'ASIS').ASI       SET ASIS\n         AIF   ('&PARM' EQ 'CONTROL').CON    SET CONTROL\n         AIF   ('&PARM' EQ 'FULLSCR').FULLS  SET FULL SCREEN    SA60002\n         AIF   ('&PARM' EQ 'NOEDIT').NOED    SET NO EDIT MODE  @G76XRYU\n         AIF   ('&PARM' EQ 'WAIT').WAI       SET WAIT\n         AIF   ('&PARM' EQ 'NOWAIT').NOW     SET NOWAIT\n         AIF   ('&PARM' EQ 'HOLD').HOL       SET HOLD\n         AIF   ('&PARM' EQ 'NOHOLD').NOH     SET NOHOLD\n         AIF   ('&PARM' EQ 'NOBREAK').NOB    SET NOBREAK\n         AIF   ('&PARM' EQ 'BREAKIN').BRE    SET BREAKIN\n         AIF   ('&PARM' EQ 'HIGHP').HPR      SET HIGHP\n         AIF   ('&PARM' EQ 'LOWP').LPR       SET LOWP\n         AGO   .ERROR3\n.EDI     ANOP\n         AIF   (&E).ERROR2              DUP OPTION\n&E       SETB  1                        EDIT OPTION SPECFIED\n&FLAGOFF SETA  &FLAGOFF-3               EDIT FOR EXECUTE FORM  @G76XRYU\n         AGO   .EDDONE                                         @G76XRYU\n.ASI     ANOP\n         AIF   (&E).ERROR2              DUP OPTION\n&E       SETB  1                        EDIT OPTION SPECFIED\n&FLAGOFF SETA  &FLAGOFF-2               1ST BIT OF ASIS FOR EX @G76XRYU\n&FLAGON  SETA  &FLAGON+1                2ND BIT OF ASIS FOR EX @G76XRYU\n&OPT     SETA  &OPT+1                   SET EDIT=ASIS\n         AGO   .EDDONE                                         @G76XRYU\n.CON     ANOP\n         AIF   (&E).ERROR2              DUP OPTION\n&E       SETB  1                        EDIT OPTION SPECFIED\n&OPT     SETA  &OPT+2                   SET EDIT=CONTROL\n&FLAGOFF SETA  &FLAGOFF-1               1ST BIT OF CNTR FOR EX @G76XRYU\n&FLAGON  SETA  &FLAGON+2                2ND BIT OF CNTR FOR EX @G76XRYU\n         AGO   .EDDONE                                         @G76XRYU\n.FULLS   ANOP                                                   SA60002\n         AIF   (&E).ERROR2              DUP OPTION              SA60002\n&E       SETB  1                        EDIT OPTION SPECIFIED   SA60002\n&OPT     SETA  &OPT+3                   CNTL+ASIS FOR FULLSCR   SA60002\n&FLAGON  SETA  &FLAGON+3                SET FULLSCREEN FOR EX  @G76XRYU\n         AGO   .EDDONE                                         @G76XRYU\n.NOED    ANOP                                                  @G76XRYU\n         AIF   (&E).ERROR2              DUP OPTION             @G76XRYU\n         AIF   (&NTJ EQ 1).ASIDERR      CAN'T SAY NOEDIT & ASID@OZ43223\n&E       SETB  1                                               @G76XRYU\n&OPT     SETA  &OPT+3                   FLAGS1 TO FULLSCR STAN @G76XRYU\n&FLAGS2  SETA  1                        SET FLAGS2 TO NOEDIT   @G76XRYU\n&FLAGON  SETA  &FLAGON+3                FLAGS1 TO FULLSCR EXEC @G76XRYU\n.EDDONE  ANOP                      EDIT OPERAND IN RIGHT PLACE @G76XRYU\n         AIF   (&RET NE 1).BADPOS  ..IF NOT IN 3RD POS-WARNING @G76XRYU\n         AGO   .RET                ..ELSE OK                   @G76XRYU\n.WAI     ANOP\n         AIF   (&W).ERROR2              DUP OPTION\n&W       SETB  1                        WAIT OPTION SPECIFIED\n&FLAGOFF SETA  &FLAGOFF-16              SET WAIT OPTION IN EX  @G76XRYU\n         AGO   .WAIDONE                 CHECK POSITION         @G76XRYU\n.NOW     ANOP\n         AIF   (&W).ERROR2              DUP OPTION\n&W       SETB  1                        WAIT OPTION SPECIFIED\n&OPT     SETA  &OPT+X'10'               SET WAIT=NOWAIT\n&FLAGON  SETA  &FLAGON+16               SET FOR NOWAIT IN EXEC @G76XRYU\n.WAIDONE ANOP                       ..WAIT IN RIGHT POSITION   @G76XRYU\n         AIF   (&RET NE 2).BADPOS   ..IF NOT 4TH, WARNING      @G76XRYU\n         AGO   .RET                 ..ELSE OK                  @G76XRYU\n.HOL     ANOP\n         AIF   (&H).ERROR2              DUP OPTION\n&H       SETB  1                        HOLD OPTION SPECIFIED\n&OPT     SETA  &OPT+X'08'               SET HOLD=HOLD\n&FLAGON  SETA  &FLAGON+8                SET FOR HOLD IN EXEC   @G76XRYU\n         AGO   .HOLDONE                 CHECK POSITION         @G76XRYU\n.NOH     ANOP\n         AIF   (&H).ERROR2              DUP OPTION\n&H       SETB  1                        NOHOLD OPTION SPECIFIED\n&FLAGOFF SETA  &FLAGOFF-8               SET FOR NOHOLD IN EXEC @G76XRYU\n.HOLDONE ANOP                        ..CHECK HOLD POSITION     @G76XRYU\n         AIF   (&RET NE 3).BADPOS    ..IF \u00ac 5TH OPER, WARNING  @G76XRYU\n         AGO   .RET                  ..ELSE OK                 @G76XRYU\n.BRE     ANOP\n         AIF   (&B).ERROR2              DUP OPTION\n&B       SETB  1                        BREAK OPTION SPECIFIED\n&OPT     SETA  &OPT+X'04'               SET BREAKIN\n&FLAGON  SETA  &FLAGON+4                SET BREAKIN IN EXEC    @G76XRYU\n         AGO   .BRDONE                  CHECK BREAK POSITION   @G76XRYU\n.NOB     ANOP\n         AIF   (&B).ERROR2              DUP OPTION\n&B       SETB  1                        BREAK OPTION SPECIFIED\n&FLAGOFF SETA  &FLAGOFF-4               SET NOBREAK OPTION EX  @G76XRYU\n.BRDONE  ANOP                           CHECK BREAK POSITION   @G76XRYU\n         AIF   (&RET NE 4).BADPOS    ..IF NOT THE 6TH OPERAND  @G76XRYU\n         AGO   .RET                  ..ELSE OK                 @G76XRYU\n.HPR     ANOP\n         AIF   (&P).ERROR2              DUP OPTION\n&P       SETB  1                        PRIORITY OPTION SPECIFIED\n&FLAGOFF SETA  &FLAGOFF-32              SET HI PRIO OPTION EX  @G76XRYU\n         AGO   .PRDONE                  CHECK POSITION         @G76XRYU\n.LPR     ANOP\n         AIF   (&P).ERROR2              DUP OPTION\n&P       SETB  1                        PRIORITY OPTION SPECIFIED\n&OPT     SETA  &OPT+X'20'               SET  LOW PRIORITY OPTION\n&FLAGON  SETA  &FLAGON+32               SET LOW PRI OPTION EX  @G76XRYU\n.PRDONE  ANOP                     ..CHECK PRIORITY OPERAND POS @G76XRYU\n         AIF   (&RET NE 5).BADPOS   ..IF \u00ac7TH OPERAND,WARNING  @G76XRYU\n         AGO   .RET                 ..ELSE OK                  @G76XRYU\n.BADPOS  ANOP             ..ISSUE WARNING IF OPERAND MISPLACED @G76XRYU\n         MNOTE 4,'IHB300 WARNING: &PARM POSITIONAL PARAMETER MISPLACED'\n.RET     ANOP\n&PARM    SETC  '&WAIT'\n         AIF   ('&RET' EQ '1').CKPARM   CHECK WAIT\n&PARM    SETC  '&HOLD'\n         AIF   ('&RET' EQ '2').CKPARM   CHECK HOLD\n&PARM    SETC  '&BRKI'\n         AIF   ('&RET' EQ '3').CKPARM   CHECK BRKI\n&PARM    SETC  '&PRTY'\n         AIF   ('&RET' EQ '4').CKPARM   CHECK PRTY\n.*  PARAMETERS PROCESSED                                       @G76XRYU\n         AIF   ('&MF' EQ '' AND &FLAGS2 EQ 0).OLD NON-EXTENDED @G76XRYU\n         AIF   ('&MF' EQ 'L').LFORM       ...LIST EXPANSION... @G76XRYU\n         AIF   ('&MF' EQ 'I' OR '&MF' EQ '').STFORM .ST. FORM. @G76XRYU\n.******************                                            @G76XRYU\n.*  EXECUTE FORM  *                                            @G76XRYU\n.******************                                            @G76XRYU\n&NAME    CNOP  0,4                          TPUT EXECUTE FORM  @G76XRYU\n         AIF   ('&MF(2)'(1,1) EQ '(').MFREG  IF IN RX FORM  .. @G76XRYU\n         LA    1,&MF(2)                     R1=>USER PARM LIST @G76XRYU\n         AGO   .GOTPARM                                        @G76XRYU\n.MFREG   ANOP                             .. ELSE, IN A REG .. @G76XRYU\n         AIF   ('&MF(2)' EQ '(1)').GOTPARM ..IF NOT REG 1..    @G76XRYU\n         LR    1,&MF(2)                     POINT R1 AT PARMS  @G76XRYU\n.GOTPARM ANOP                                                  @G76XRYU\n         AIF   (&FLAGOFF EQ 127).SKIPAND ..TURN OFF ANY FLAGS? @G76XRYU\n         NI    4(1),&FLAGOFF                RESET FLAGS 1      @G76XRYU\n.SKIPAND ANOP                      ..CHECK FOR FLAGS TURNED ON @G76XRYU\n         AIF   (&FLAGON EQ 0).NOSET  ..TURN ON ANY FLAGS?      @G76XRYU\n         OI    4(1),&FLAGON                 IN EXEC PARM LIST  @G76XRYU\n.NOSET   ANOP                                                  @G76XRYU\n         AIF   (&FLAGS2 EQ 0 AND NOT &E).NOFLAG2 ..IF NEW EDIT @G76XRYU\n         MVI   12(1),&FLAGS2                RESET FLAGS2       @G76XRYU\n.NOFLAG2 ANOP                                                  @G76XRYU\n         AGO   .PARMCHK                 ..END UNIQUE E CODE..  @G76XRYU\n.****************************                                  @G76XRYU\n.*  STANDARD EXTENDED FORM  *                                  @G76XRYU\n.****************************                                  @G76XRYU\n.STFORM  ANOP                   ..STANDARD EXTENDED FORM CODE. @G76XRYU\n&NAME    CNOP  0,4                          STANDARD EXTENDED  @G76XRYU\n         AIF   ('&BFF' NE '(1)').NOTOLD  .IF OLD STANDARD FORM @G76XRYU\n         STCM  1,B'0111',*+13               OLD SUPPORT ONLY   @G76XRYU\n&OLDBUFF SETB  1                         .FLAG OLD BUFF ADDR.. @G76XRYU\n.NOTOLD  ANOP                                                  @G76XRYU\n         BAL   1,*+20                       BRANCH AROUND PARM @G76XRYU\nTPUT&NDX DS    0H                           TPUT EXTENDED PARM @G76XRYU\n         DC    H'0'                         ADDR SPACE ID      @G76XRYU\n         DC    H'0'                         OUTPUT BUFFER SIZE @G76XRYU\n         DC    AL1(&OPT)                    FLAGS 1            @G76XRYU\n         DC    AL3(0)                       OUTPUT BUFFER ADDR @G76XRYU\n         DC    A(0)                         ADDRESS OF USER ID @G76XRYU\n         DC    AL1(&FLAGS2)                 FLAGS 2            @G76XRYU\n         DC    AL3(0)                       RESERVED BYTES     @G76XRYU\n.************************************************              @G76XRYU\n.*  COMMON CODE FOR STANDARD AND EXECUTE FORMS  *              @G76XRYU\n.************************************************              @G76XRYU\n.PARMCHK ANOP                           ..GET PARMS FOR E & I  @G76XRYU\n         AIF   ('&SIZE' EQ '').CKID     ...IF BUFF SIZE GIVEN. @G76XRYU\n         AIF   ('&SIZE'(1,1) EQ '(').SIZEREG  ...IF AN INTEGER @G76XRYU\n         AIF   (T'&SIZE NE 'N').SIZEQU  IF AN EQUATE           @OZ43223\n         AIF   (&SIZE GT 32767).SIZERR          .NOT > 32767.. @G76XRYU\n.SIZEQU  ANOP                                                  @OZ43223\n         AIF   ('&MF' NE 'I' AND '&MF' NE '').SIZEEX .STANDARD @G76XRYU\n         ORG   TPUT&NDX+2                   PUT SIZE VALUE     @G76XRYU\n         DC    AL2(&SIZE)                   IN PARM LIST       @OZ43223\n         ORG\n         AGO   .CKID                                           @G76XRYU\n.SIZEEX  ANOP                         ..IF EXECUTE             @G76XRYU\n         B     *+6                          BR PAST SIZE VALUE @OZ43223\n         DC    AL2(&SIZE)                   BUFSIZE            @OZ43223\n         LH    0,*-2                        GET THE SIZE VALUE @G76XRYU\n         STH   0,2(1)                       INTO THE PARM LIST @G76XRYU\n         AGO   .CKID                                           @G76XRYU\n.SIZEREG ANOP                                 ...ELSE A REG .. @G76XRYU\n         STH   &SIZE(1),2(1)                PUT SIZE IN PARM   @G76XRYU\n.CKID    ANOP                           ... CHECK IDS ...      @G76XRYU\n         AIF   (&NTJ EQ 0).CKADDR       ..IF THERE IS AN ID..  @G76XRYU\n         AIF   ('&TSID' EQ '').CKIDLOC  ..IF AN ASID # GIVEN.. @G76XRYU\n         AIF   ('&TSID'(1,1) EQ '(').ASIDREG  ..IF AN INTEGER. @G76XRYU\n         AIF   ((T'&ASID NE 'N' AND T'&TJID EQ 'O') OR (T'&TJID NE 'N' X\n               AND T'&ASID EQ 'O')).IDEQU                      @OZ43223\n         AIF   (&TSID GT 32767).IDERROR         .NOT > 32767.. @G76XRYU\n.IDEQU   ANOP                                                  @OZ43223\n         AIF   ('&MF' NE 'I' AND '&MF' NE '').IDEX ..STANDARD  @G76XRYU\n         ORG   TPUT&NDX                     PUT ASID VALUE     @G76XRYU\n         DC    AL2(&TSID)                   IN PARM LIST       @G76XRYU\n         ORG\n         AGO   .CKADDR                                         @G76XRYU\n.IDEX    ANOP                               IF EXECUTE         @G76XRYU\n         B     *+6                          GET AROUND ID #    @G76XRYU\n         DC    AL2(&TSID)                   PUT ID # HERE      @OZ43223\n         LH    0,*-2                        STORE ASID # IN    @G76XRYU\n         STH   0,0(1)                       PARAMETER LIST     @G76XRYU\n         AGO   .CKADDR                                         @G76XRYU\n.ASIDREG ANOP                           .. ELSE ASID IN A REG. @G76XRYU\n         STH   &TSID,0(1)                   STORE REG IN PARM  @G76XRYU\n         AGO   .CKADDR                                         @G76XRYU\n.CKIDLOC ANOP                           .. ELSE ID AT AN ADDR  @G76XRYU\n.*                                            (ASIDLOC)        @G76XRYU\n         AIF   ('&TSIDLOC' EQ '').CKUSER ..IF AN ADDRESS GIVEN @G76XRYU\n         AIF   ('&TSIDLOC'(1,1) EQ '(').LOCIDRG  ..IF RX ADDR. @G76XRYU\n         MVC   0(2,1),&TSIDLOC              MOVE ID INTO PARMS @G76XRYU\n         AGO   .CKADDR                                         @G76XRYU\n.LOCIDRG ANOP                           .. ELSE ID ADDR IN REG @G76XRYU\n         MVC   0(2,1),0&TSIDLOC             MOVE ID INTO PARMS @G76XRYU\n         AGO   .CKADDR                                         @G76XRYU\n.CKUSER  ANOP                           ..ELSE A USER ID GIVEN @G76XRYU\n         AIF   ('&USERIDL'(1,1) EQ '(').USEREG ..IF RX ADDR..  @G76XRYU\n         AIF   ('&USERIDL'(K'&USERIDL,1) EQ ')' OR ('&MF' NE 'I' AND '&*\n               MF' NE '')).USERX         ..IF STANDARD FORM    @G76XRYU\n         ORG   TPUT&NDX+8                   PUT USER ID ADDR   @G76XRYU\n         DC    A(&USERIDL)                  IN PARM LIST       @G76XRYU\n         ORG\n         AGO   .CKADDR                                         @G76XRYU\n.USERX   ANOP                         ..IF EXECUTE OR LA ADDR  @G76XRYU\n         LA    0,&USERIDL                   GET USER ID ADDR   @G76XRYU\n         ST    0,8(1)                       INTO THE PARM LIST @G76XRYU\n         AGO   .CKADDR                                         @G76XRYU\n.USEREG  ANOP                           ...      ELSE A REG .. @G76XRYU\n         ST    &USERIDL(1),8(1)             PUT ID IN PARM     @G76XRYU\n.CKADDR  ANOP                           ..GET OUT BUFFER ADDR  @G76XRYU\n         AIF   (&OLDBUFF).FINISH        ..IF OLD FORM,COMPLETE @G76XRYU\n         AIF   ('&BFF' EQ '').FINISH    ..IF BUFFER ADDR GIVEN @G76XRYU\n         AIF   ('&BFF'(1,1) EQ '(').BFFREG  ..IF AN RX ADDR... @G76XRYU\n         AIF   ('&BFF'(K'&BFF,1) EQ ')' OR ('&MF' NE 'I' AND '&MF' NE '*\n               ')).BFFRX                 ..AND STANDARD FORM   @G76XRYU\n         ORG   TPUT&NDX+5                   PUT BUFFER ADDRESS @G76XRYU\n         DC    AL3(&BFF)                    IN PARM LIST       @G76XRYU\n         ORG\n         AGO   .FINISH                                         @G76XRYU\n.BFFRX   ANOP                      ..IF EXECUTE OR LA TYPE..   @G76XRYU\n         LA    0,&BFF                       GET ADDR OF BUFFER @G76XRYU\n         STCM  0,B'0111',5(1)               PUT IN PARM LIST   @G76XRYU\n         AGO   .FINISH                                         @G76XRYU\n.BFFREG  ANOP                               ..ELSE IN A REG .. @G76XRYU\n         STCM  &BFF(1),B'0111',5(1)         STORE BUFFER ADDR  @G76XRYU\n.FINISH  ANOP                                                  @G76XRYU\n         OI    12(1),128                    SET HI BIT OF PARM @G76XRYU\n         ICM   0,B'1000',*-3                SET HI BIT OF R0   @G76XRYU\n.*                                        FROM 128 IN OI INSTR @G76XRYU\n.SVCNEW  ANOP                           .. ISSUE SVC HERE ...  @G76XRYU\n         SVC   93                           SVC TO MSG ROUTER  @G76XRYU\n         MEXIT                                                 @G76XRYU\n.**********************                                        @G76XRYU\n.*  LIST FORM CODE    *                                        @G76XRYU\n.**********************                                        @G76XRYU\n.LFORM   ANOP                                                  @G76XRYU\n         AIF   ('&TSIDLOC' EQ '').IDLOCOK ..IF L FORM INVALID. @G76XRYU\n         MNOTE 12,'IHB300 INCOMPATIBLE OPERANDS: MF=L, ASIDLOC'\n         MEXIT                                                 @G76XRYU\n.IDLOCOK ANOP                           ..ASIDLOC OPERAND NULL @G76XRYU\n&NAME    DS    0F                           L-FORM PARM LIST   @G76XRYU\n         AIF   ('&TSID' NE '').LSTID    ..IF NO TSID GIVEN..   @G76XRYU\n         DC    H'0'                         ASID HALFWORD      @G76XRYU\n         AGO   .LBFFSIZ                                        @G76XRYU\n.LSTID   ANOP                           ..ELSE TSID SPECIFIED. @G76XRYU\n         AIF   ('&TSID'(1,1) EQ '(').REGERR   ..NOT A REGISTER @G76XRYU\n         AIF   ((T'&ASID NE 'N' AND T'&TJID EQ 'O') OR (T'&TJID NE 'N' X\n               AND T'&ASID EQ 'O')).IDEQU0                     @OZ43223\n         AIF   (&TSID GT 32767).IDERROR         ..NOT > 32767. @G76XRYU\n.IDEQU0  ANOP                                                  @OZ43223\n         DC    AL2(&TSID)                   ADDR SPACE VALUE   @OZ43223\n.LBFFSIZ ANOP                           .. CHECK BUFFER SIZE . @G76XRYU\n         AIF   ('&SIZE' NE '').LSTSIZE  .. IF NO BUFFER SIZE . @G76XRYU\n         DC    H'0'                         BUFF SIZE HALFWORD @G76XRYU\n         AGO   .LBFADDR                                        @G76XRYU\n.LSTSIZE ANOP                           .. ELSE A BUFFER SIZE. @G76XRYU\n         AIF   ('&SIZE'(1,1) EQ '(').REGERR   .IF NOT IN A REG @G76XRYU\n         AIF   (T'&SIZE NE 'N').SIZEQU0 IF AN EQUATE           @OZ43223\n         AIF   (&SIZE GT 32767).SIZERR          .NOT > 32767.. @G76XRYU\n.SIZEQU0 ANOP                                                  @OZ43223\n         DC    AL2(&SIZE)                   BUFFER SIZE VALUE  @OZ43223\n.LBFADDR ANOP                           .. CHECK BUFFER ADDR.. @G76XRYU\n         DC    AL1(&OPT)                    FLAGS 1            @G76XRYU\n         AIF   ('&BFF' NE '').LBFFLAB   ..IF NO BUFFER ADDR..  @G76XRYU\n         DC    AL3(0)                       BUFFER ADDRESS     @G76XRYU\n         AGO   .LSTUSER                                        @G76XRYU\n.LBFFLAB ANOP                           .. ELSE BUFFER ADDRESS @G76XRYU\n         AIF   ('&BFF'(1,1) EQ '(').REGERR  ..IF NOT IN A REG  @G76XRYU\n         DC    AL3(&BFF)                    ADDR OUTPUT BUFFER @G76XRYU\n.LSTUSER ANOP                                                  @G76XRYU\n         AIF   ('&USERIDL' NE '').LUSADDR  ..IF NO USER ID ..  @G76XRYU\n         DC    A(0)                         USER ID            @G76XRYU\n         AGO   .LISTEND                                        @G76XRYU\n.LUSADDR ANOP                              ..ELSE USER ID ...  @G76XRYU\n         AIF   ('&USERIDL'(1,1) EQ '(').REGERR  ..IF NOT REG . @G76XRYU\n         DC    A(&USERIDL)                  USER ID            @G76XRYU\n.LISTEND ANOP                               .. GEN FLAGS2 ..   @G76XRYU\n         DC    AL1(&FLAGS2)                 FLAGS 2            @G76XRYU\n         DC    AL3(0)                       RESERVED           @G76XRYU\n         MEXIT                                                 @G76XRYU\n.REGERR  ANOP                              ..REGISTER ERROR..  @G76XRYU\n         MNOTE 12,'IHB300 INCOMPATIBLE OPERANDS: MF=L, REGISTER OPERANDX\n                SPECIFIED'                                     @G76XRYU\n         MEXIT                                                 @G76XRYU\n.*********************                                         @G76XRYU\n.*   REGISTER FORM   *                                         @G76XRYU\n.*********************                                         @G76XRYU\n.RF      ANOP\n         AIF   ('&MF' EQ '').RFNOMF   ..IF MF OPERAND GIVEN... @G76XRYU\n         MNOTE 12,'IHB300 INCOMPATIBLE OPERANDS: R, MF'        @G76XRYU\n         MEXIT                                                 @G76XRYU\n.RFNOMF  ANOP                         ..IF NOEDIT SPECIFIED... @G76XRYU\n         AIF   ('&WAIT' NE 'NOEDIT' AND '&HOLD' NE 'NOEDIT' AND '&BRKI'*\n               NE 'NOEDIT' AND '&PRTY' NE 'NOEDIT').RFNOED     @G76XRYU\n         MNOTE 12,'IHB300, INCOMPATIBLE OPERANDS: R, NOEDIT'   @G76XRYU\n         MEXIT                                                 @G76XRYU\n.RFNOED  ANOP                         CHECK REMAINING OPERANDS @G76XRYU\n         AIF   ('&WAIT' NE '' OR '&HOLD' NE '' OR '&BRKI' NE '' OR '&PRX\n               TY' NE '' OR &NTJ GT 0).RERR\n         AIF   ('&BFF'(1,1) NE '(' OR '&SIZE'(1,1) NE '(').RERR\n&NAME    DS    0H\n         AIF   ('&BFF' EQ '(1)').SIZE\n         LR    1,&BFF(1)                LOAD OPTIONS & BUFFER ADDR\n.SIZE    AIF   ('&SIZE' EQ '(0)').SVC    ..IF REG 0-ISSUE SVC..\n         LR    0,&SIZE(1)               LOAD TJID & BUFFER SIZE\n         AGO   .SVC                     ... ISSUE SVC CALL ...\n.************                                                  @G76XRYU\n.*  MNOTES  *                                                  @G76XRYU\n.************                                                  @G76XRYU\n.SIZERR  ANOP                      ..SIZE INTEGER NOT 0-32767. @G76XRYU\n&PARM    SETC  'SIZE'                ..INDICATE BAD SIZE PARM. @G76XRYU\n         AGO   .INTERR                                         @G76XRYU\n.IDERROR ANOP                      ..ASID INTEGER NOT 0-32767. @G76XRYU\n&PARM    SETC  'ASID'                ..INDICATE BAD ASID PARM. @G76XRYU\n.INTERR  MNOTE 12,'IHB300 &PARM NOT IN RANGE 0-32767'          @G76XRYU\n         MEXIT                                                 @G76XRYU\n.RERR    IHBERMAC 192\n         MEXIT\n.ERROR1  IHBERMAC 24\n         MEXIT\n.ERROR2  IHBERMAC 54,,,\n         MEXIT\n.ERROR3  IHBERMAC 49,,&PARM\n         MEXIT                                                 @OZ43223\n.ASIDERR MNOTE 12,'IHB300 ASID/USERID INVALID WITH NOEDIT'     @OZ43223\n         MEXIT                                                 @OZ43223\n.***********************                                       @G76XRYU\n.*  NON-EXTENDED FORM  *                                       @G76XRYU\n.***********************                                       @G76XRYU\n.OLD     ANOP            ....NON EXTENDED TPUT EXPANSION       @G76XRYU\n         AIF   ('&BFF'(1,1) EQ '(' OR '&SIZE'(1,1) EQ '(').REGFM  REG.\n.*                                      FORM MACRO\n         AIF   ('&TSID' EQ '').CHKLOC   GOTO CHECK TSIDLOC\n         AIF   ('&TSID'(1,1) EQ '(').REGFM   REG. FORM MACRO\n&ID      SETC  '&TSID'                  SET TSID\n         AGO   .EXPAND                  GOTO EXPANSION\n.CHKLOC  AIF   ('&TSIDLOC' EQ '').EXPAND  GO EXPAND IF NO 'TSIDLOC'\n         AIF   ('&TSIDLOC'(1,1) EQ '(').REGFM  REG. FORM MACRO\n.*   REGULAR FORMAT OF MACRO\n.EXPAND  CNOP  0,4\n         AIF   ('&TSIDLOC' NE '').LOC   TJLOC SPECIFIED\n&NAME    B     *+10                BR AROUND CONS           JRB UZ31094\n         DC    AL2(&ID)                 TSID\n         DC    AL2(&SIZE)               BUFFER SIZE\n         DC    AL1(&OPT,0)         OPTS AND PAD             JRB UZ31094\n         L     0,*-6               LOAD SIZE                JRB UZ31094\n         LA    1,&BFF              LOAD BUFF ADDR           JRB UZ31094\n         ICM   1,8,*-10            INSERT OPT BYTE          JRB UZ31094\n.SVC     ANOP\n         AIF   ('&USERIDL' EQ '').GENSVC\n         AIF   ('&USERIDL'(1,1) EQ '(').LR\n         LA    15,&USERIDL\n         AGO   .GENSVC\n.LR      ANOP\n         AIF   ('&USERIDL' EQ '(15)').GENSVC\n         LR    15,&USERIDL(1)\n.GENSVC  ANOP\n         SVC   93                       ISSUE TGET/TPUT SVC\n         SPACE 1\n         MEXIT\n.*   TSIDLOC IS SPECIFIED\n.LOC     ANOP\n&NAME    ICM   0,B'0011',&TSIDLOC       TSID IN HIGH 2 BYTES   @G76XRYU\n         SLL   0,16                     SHIFT TJID TO HI-ORDER BYTES\n         AIF   (&OPT EQ 0).ZERO         BRANCH IF OPTIONS ARE ZERO\n         O     0,*+8                    LOAD BUFFER SIZE\n         B     *+10                BR AROUND CONS           JRB UZ31094\n         DC    AL2(0)                   TJID\n         DC    AL2(&SIZE)               BUFFER SIZE\n         DC    AL1(&OPT,0)         OPTS AND PAD             JRB UZ31094\n         LA    1,&BFF                   LOAD BUFFER ADDRESS    @ZA44359\n         ICM   1,8,*-6             INSERT OPT BYTE          JRB UZ31094\n         AGO   .SVC                     GOTO ISSUE SVC\n.ZERO    LA    1,&SIZE                  LOAD BUFFER SIZE\n         OR    0,1                      OR IT INTO REGISTER 0\n         LA    1,&BFF                   Z HIGH ORDR BYTE & LD BFR ADDR\n         AGO   .SVC                     GOTO ISSUE SVC\n.*   REGISTER FORMAT\n.REGFM   AIF   ('&TSIDLOC' EQ '').NOLOC   SKIP IF TJIDLOC NOT SPECIFIED\n         AIF   ('&TSIDLOC'(1,1) EQ '(').REGLOC    LOC IN REG  FORM\n&NAME    ICM   15,B'0011',&TSIDLOC      TSID IN HIGH 2 BYTES   @G76XRYU\n         SLL   15,16                    MOVE TJID TO HI=ORDER 2 BYTES\n         AGO   .CHKSIZE                 GOTO CHECK SIZE\n.REGLOC  ANOP\n&NAME    ICM   15,B'0011',0&TSIDLOC     TSID IN HIGH 2 BYTES   @G76XRYU\n         SLL   15,16                    MOVE TJID TO HI-ORDER 2 BYTES\n         AGO   .CHKSIZE                 GOTO CHECK SIZE\n.*   WHEN TJIDLOC IS NOT SPECIFIED\n.NOLOC   AIF   ('&TSID' NE '').TJIDYES\n&NAME    DS    0H                       TJID IS '0'\n         AGO   .CHKSIZE                 GOTO CHECK SIZE\n.TJIDYES AIF   ('&TSID'(1,1) EQ '(').IDREG   TJID IN REG FORM\n&NAME    LA    15,&TSID                 LOAD TJID\n         AGO   .SHIFT                   GOTO SHIFT REG.0\n.IDREG   ANOP\n&NAME    LR    15,&TSID                 LOAD TJID IN REG 15\n.SHIFT   SLL   15,16                    SHIFT TJID TO HI-ORDER BYTE\n.*  CHECK SIZE OF BUFFER (BY NOW TJID IS IN HI-ORDER 2 BYTES OF REG 15)\n.CHKSIZE AIF   ('&SIZE'(1,1) EQ '(').SZREG   SKIP IF SIZE IN REG\n         LA    0,&SIZE                  LOAD SIZE IN REG.0\n         AGO   .ORSIZE                  GOTO OR SIZE\n.SZREG   AIF   ('&SIZE' EQ '(0)').ORSIZE  GOTO SET SIZE IN REG. 0\n         LR    0,&SIZE(1)               LOAD BUFFER SIZE\n.ORSIZE  AIF   ('&TSID' EQ '' AND '&TSIDLOC' EQ '').PAST\n         OR    0,15                     LOAD TJID + BUFFER SIZE\n.PAST    AIF   (&OPT EQ 0 AND '&BFF'(1,1) EQ '(').ORONE\n         AIF   (&OPT EQ 0 AND '&BFF'(1,1) NE '(').ZOPT ZERO OPTN\n         CNOP  0,4\n         B     *+8\n         DC    AL1(&OPT)                OPTION BITS\n         AIF   ('&BFF'(1,1) EQ '(').REGGO   BFFR IN REG.\n         DC    AL3(&BFF)                BUFFER ADDR\n         L     1,*-4                    LOAD PARAMETER IN REG.1\n         AGO   .SVC                     GOTO ISSUE SVC\n.ZOPT    LA    1,&BFF                   LOAD BUFFER ADDR IN REG 1\n         AGO   .SVC                     ISSUE SVC\n.REGGO   DC    AL3(0)                   BUFFER ADDR\n         AIF   ('&BFF' EQ '(1)').ORONE  GOTO OR OPTIONS\n         L     1,*-4                    LOAD OPTIONS\n         OR    1,&BFF(1)                SET OPTIONS AND BUFFER ADDR\n         AGO   .SVC                     GOTO ISSUE SVC\n.ORONE   LA    1,0(,&BFF(1))            CLR HIGH ORDR BYTE + LD BFR ADR\n         AIF   (&OPT EQ 0).SVC          GOTO ISSUE SVC IF OPT EQ 0\n         O     1,*-8                    SET OPTIONS\n         AGO   .SVC\n         MEND\n./ ADD NAME=K        0108-79143-81120-1639-00007-00007-00005-BROIDO\n         MACRO\n&N       K     ,                       IDENTICAL TO THE ERASE MACRO.\n&N       LA    0,9                     LOAD LENGTH.\n         LA    1,=X'F11140403C40400013'\n         ICM   1,8,=X'03'              SET FULLSCR OPTION.\n         SVC   93                      INVOKE TPUT.\n         MEND\n./ ADD NAME=MRSCTLB  0112-79089-81160-1112-00034-00026-00034-LANDERS\n         MACRO\n&NAME    MRSCTLB\n         AIF   ('&NAME' EQ '').CONT\n&NAME    DSECT\n.CONT    ANOP\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        M.R.S CONTROL BLOCK                            28 DEC 79- JRB*\n*                                                                     *\n***********************************************************************\n         SPACE 1\nMCB      DS    0CL200\nMCBIDENT DC    C'MCB '             CONTROL BLOCK-ID.\nMCBUSER  DS    CL7                 USER-ID\nMCBUPDTE DS    CL1                 UPDATE SWITCH (Y OR N)\nMCBJOB   DS    CL8                 JOBNAME\nMCBSTEM  DS    CL3                 STEM\nMCBSTRNG DS    CL80                USER STRING\nMCBDSN   DS    CL3                 DSN (CONSTANT MRS)\nMCBCPPL  DS    AL4                 CPPL ADDRESS (NOT FW ALIGNED)   JRB\nMCBHARDC DS    C                   HARD COPY Y OR N\n         DS    X                   RESERVED.                       JRB\n         SPACE 1\nMCBFLAG  DC    AL1(MCBGBIT)        BIT FLAGS.                      JRB\nMCBTSO   EQU   B'10000000'         ONLINE USER.                    JRB\nMCBTUBE  EQU   B'01000000'         TERMINAL IS CRT (327X)          JRB\nMCBAJ    EQU   B'00100000'         AJ TERMINAL WAS SETUP BY AJSET. JRB\nMCBGBIT  EQU   B'00000010'         GUARD BIT.  IF OFF, BAD NEWS.   JRB\nMCBFCMD  EQU   B'00000001'         FIRST COMMAND FLAG              JRB\nMCBDDNAM DC    CL6'FILE  '         LAST 6 CH. OF DATABASE DDNAMES  JDC\nBLDLADDR DS    F                   ADDRESS OF BLDL LIST            JML\n         DS    CL76                RESERVED.\n         MEND\n./ ADD NAME=MVC2L    0101-84306-84306-1348-00047-00049-00011-ANDERSO\n         MACRO\n&NAME    MVC2L &DEST,&SRC\n         LCLC  &LENG,&S9,&SRC1\n         LCLA  &K,&X,&Y,&LEN\n&K       SETA  K'&SRC\n&S9      SETC  '&SRC'(&K,1)\n&Y       SETA  1\n.YLOOP   AIF   ('&SRC'(&Y,1) EQ '''').FDLIT    FIND ' FOR LITERAL\n&Y       SETA  &Y+1                LOOK AT NEXT\n         AIF   (&Y LT &K).YLOOP    LOOP UNTIL END\n         AIF   ('&S9' EQ ')').CLENG    FOUND A LENGTH ON OPERAND\n&LENG    SETC  'L''&SRC'           USE LENGTH OF 2ND OPERAND\n&NAME    MVC   &DEST.(&LENG),&SRC\n         MEXIT\n.CLENG   ANOP\n&X       SETA  1\n.XLOOP   AIF   ('&SRC'(&X,1) EQ '(').FDPAREN    FIND START OF LENGTH\n&X       SETA  &X+1\n         AIF   (&X LT &K).XLOOP    LOOP UNTIL END\n         MNOTE 12,ILLEGAL LENGTH SPECIFICATION ON 2ND OPERAND\n         MEXIT\n.FDPAREN ANOP\n&LENG    SETC  '&SRC'(&X+1,&K-&X-1)\n&SRC1    SETC  '&SRC'(1,&X-1)\n&NAME    MVC   &DEST.(&LENG),&SRC1\n         MEXIT\n.FDLIT   ANOP\n&X       SETA  1\n.LLOOP   AIF   ('&SRC'(&X,1) EQ 'L').FLENG    FIND LENGTH ON LITERAL\n&X       SETA  &X+1\n         AIF   (&X LT &Y).LLOOP    LOOP UNTIL START OF VALUE\n&LEN     SETA  &K-&Y-1             INITIALIZE LENGTH OF STRING\n.ADJLOOP ANOP\n&X       SETA  &X+1\n         AIF   (&X GT &K-2).ENDADJ    GET OUT IF TOO FAR\n         AIF   ('&SRC'(&X,2) EQ '''''').ADJLEN\n         AIF   ('&SRC'(&X,2) NE '&&').ADJLOOP\n.ADJLEN  ANOP\n&LEN     SETA  &LEN-1\n         AGO   .ADJLOOP\n.ENDADJ  ANOP\n&NAME    MVC   &DEST.(&LEN),&SRC\n         MEXIT\n.FLENG   ANOP\n&LENG    SETC  '&SRC'(&X+1,&Y-&X-1)\n&NAME    MVC   &DEST.(&LENG),&SRC\n         MEND\n./ ADD NAME=NOW      0102-80015-84264-0929-00059-00056-00006-BROIDO\n         MACRO\n&NAME    NOW   &T,&X,&F\n         LCLA  &A\n* JOHNSON AND JOHNSON NOW MACRO                             CHANGE 1.0\n.* AUTHOR: J. VAN DOREN\n         AIF   ('&NAME' EQ '').NONAME\n&NAME    DS    0H\n.NONAME  AIF   ('&X' EQ '').STD\n         AIF   ('&X' EQ 'STD').STD\n         AIF   ('&X' EQ 'NOTIME').NT\n         AIF   ('&X' EQ 'NODAY').ND\n         AIF   ('&X' EQ 'NEITHER').N\n         AIF   ('&X' EQ 'SLASH').S\n         AIF   ('&X' EQ 'SNOTIME').SNT\n         AIF   ('&X' EQ 'SNODAY').SND\n         AIF   ('&X' EQ 'SONLY').SO\n         MNOTE 16,'FORMAT (PARM 2) IF SPECIFIED MUST BE STD (DEFAULT), X\n               NEITHER, NOTIME, NODAY, SLASH, SNOTIME, SNODAY, OR SONLYX\n               FOUND: &X'\n         MEXIT\n.STD     ANOP\n&A       SETA  &A+1\n         AGO   .FCHK\n.NT      ANOP\n&A       SETA  &A+8\n         AGO   .STD\n.ND      ANOP\n&A       SETA  &A+2\n         AGO   .STD\n.N       ANOP\n&A       SETA  &A+10\n         AGO   .STD\n.S       ANOP\n&A       SETA  &A+4\n         AGO   .FCHK\n.SNT     ANOP\n&A       SETA  &A+8\n         AGO   .S\n.SND     ANOP\n&A       SETA  &A+2\n         AGO   .S\n.SO      ANOP\n&A       SETA  &A+10\n         AGO   .S\n.FCHK    AIF   ('&F' EQ '').FOK\n         AIF   ('&F' EQ '(15)').F\n         AIF   ('&F' EQ '(R15)').F\n         L     2,=A(&F)            LOAD REGISTER 2 WITH ADDR OF DATE.\n.F       ANOP\n&A       SETA  &A+128\n.FOK     AIF   ('&T' EQ '').R1\n         AIF   ('&T' EQ '(1)').R1\n         AIF   ('&T' EQ '(R1)').R1\n         L     1,=A(&T)                LOAD RECV ADDR\n.R1      ANOP\n         LA    0,&A                    LOAD PARAMETER REG\n         L     15,=V(MERKNOW)      POINT TO NOW SUBROUTINE.\n         BALR  14,15               CALL NOW SUBROUTINE.\n         MEND\n./ ADD NAME=OFF      0200-85137-85137-0814-00023-00023-00000-BROIDO\n         MACRO\n&NAME    OFF   &FLAG\n.*\n.**********************************************************************\n.*                                                                    *\n.*   COPYRIGHT (C) 1981 BY JEFFREY R. BROIDO.  ALL RIGHTS RESERVED.   *\n.*                                                                    *\n.*     LICENSE IS HEREBY GRANTED TO WESTERN UNION INTERNATIONAL       *\n.*     (A SUBSIDIARY OF MCI, INCORPORATED) AND ITS AFFILIATES TO      *\n.*     USE THIS MACRO.  HOWEVER, IT MUST NOT BE BE SOLD, GIVEN,       *\n.*     OR OTHERWISE DISTRIBUTED TO ANY OTHER COMPANY OR DATA          *\n.*     CENTER WITHOUT PRIOR WRITTEN PERMISSION OF:                    *\n.*                                                                    *\n.*                                 JEFFREY R. BROIDO                  *\n.*                                 broidoj@gmail.com                  *\n.*                                                                    *\n.**********************************************************************\n.*\n         LCLC  &L\n&L       SETC  'L'''\n&NAME    NI    &FLAG,255-&L.&FLAG          (TURN OFF BIT FLAG)\n         MEND\n./ ADD NAME=OLDTGET,SSI=20730006\n         MACRO\n&NAME    TGET  &BFF,&SIZE,&EDIT,&WAIT\n.*********************************************************************.\n.*                                                                    *\n.*RELEASE 23 DELETIONS                                               *.\n.*                                                                   *.\n.*RELEASE 22 DELETIONS                                               *.\n.*                                                                   *.\n.*RELEASE 21 DELETIONS                                               *.\n.*                                                                   *.\n.*STATUS - CHANGE LEVEL 000                                          *.\n.*                                                                   *.\n.*NAME - TGET                                                        *.\n.*                                                                   *.\n.*FUNCTION - THIS MACRO IS USED TO MOVE A LINE OF INPUT FROM THE TIOC*.\n.*   INPUT BUFFER TO THE USER'S BUFFER AREA.                         *.\n.*                                                                   *.\n.*********************************************************************.\n.*\n.*   TGET BUFFER AREA,BUFFER SIZE,EDIT,WAIT  (EDIT/WAIT ARE DEFAULT)\n.*          (2-12)      (2-12)    ASIS NOWAIT\n.*\n         LCLA  &OPT\n         LCLB  &SW1,&SW2\n         LCLB  &E,&W,&RET\n         LCLC  &ERROPT\n&OPT     SETA  X'80'\n         AIF   ('&BFF' EQ '' OR '&SIZE' EQ '').ERROR1  ERROR CHECK\n         AIF   ('&EDIT' EQ 'R').RF      CHECK FOR R FORM\n         AIF   ('&EDIT' EQ '').WAIT       SKIP IF NULL\n         AIF   ('&EDIT' EQ 'EDIT').EDI    SET EDIT\n         AIF   ('&EDIT' EQ 'ASIS').ASI    SET ASIS\n         AIF   ('&EDIT' EQ 'WAIT').WAI    SET WAIT\n         AIF   ('&EDIT' EQ 'NOWAIT').NOW  SET NOWAIT\n&ERROPT  SETC  '&EDIT'                  SET FOR ERROR MSG\n         AGO   .ERROR3\n.WAIT    ANOP\n&RET     SETB  1\n         AIF   ('&WAIT' EQ '').CHKREG     SKIP IF NULL\n         AIF   ('&WAIT' EQ 'EDIT').EDI    SET EDIT\n         AIF   ('&WAIT' EQ 'ASIS').ASI    SET ASIS\n         AIF   ('&WAIT' EQ 'WAIT').WAI    SET WAIT\n         AIF   ('&WAIT' EQ 'NOWAIT').NOW  SET NOWAIT\n&ERROPT  SETC  '&WAIT'                  SET FOR ERROR MSG\n         AGO   .ERROR3\n.EDI     ANOP\n         AIF   (&E).ERROR2              DUP OPTION\n&E       SETB  1                        EDIT OPTION SPECFIED\n         AGO   .RET\n.ASI     ANOP\n         AIF   (&E).ERROR2              DUP OPTION\n&E       SETB  1                        EDIT OPTION SPECFIED\n&SW1     SETB  1                        ASIS OPTION\n         AGO   .RET\n.WAI     ANOP\n         AIF   (&W).ERROR2              DUP OPTION\n&W       SETB  1                        WAIT OPTION SPECIFIED\n         AGO   .RET\n.NOW     ANOP\n         AIF   (&W).ERROR2              DUP OPTION\n&W       SETB  1                        WAIT OPTION SPECIFIED\n&SW2     SETB  1                        NOWAIT OPTION\n         AGO   .RET\n.RET     ANOP\n         AIF   (&RET).CHKREG\n         AGO   .WAIT                    NEXT POSITION\n.CHKREG  SPACE 1\n         CNOP  0,4\n&OPT     SETA  &OPT+&SW2*16+&SW1        SET OPTIONS\n         AIF   ('&BFF'(1,1) EQ '(' OR '&SIZE'(1,1) EQ '(').REGST REG.\n.*                                      NOTATION\n.*\n.*   REGULAR EXPANSION\n.*\n&NAME    B     *+12                     BRANCH AROUND CONSTANTS\n         DC    AL2(0)                   FILLER\n         DC    AL2(&SIZE)               BUFFER SIZE\n         DC    AL1(&OPT)                OPTION BITS\n         DC    AL3(&BFF)                ADDR OF BUFFER\n         LM    0,1,*-8                  LOAD PARAMETER REGISTERS\n.SVC     SVC   93                       ISSUE SVC\n         SPACE\n         MEXIT\n.*\n.*   REGISTER NOTATION\n.*\n.REGST   ANOP\n&NAME    B     *+8                      BRANCH AROUND CONSTANT\n         AIF   ('&BFF'(1,1) EQ '(' AND '&SIZE'(1,1) EQ '(').BOTH BOTH\n.*                                      PARAMETERS ARE IN REG. FORM\n         AIF   ('&SIZE'(1,1) EQ '(').SZREG   SIZE IN REG\n.*\n.*   BUFFER ADDR IN REGISTER FORM\n.*\n         DC    AL1(&OPT)                OPTION BITS\n         DC    AL3(0)                   BUFFER ADDR\n         LA    1,0(,&BFF(1))            CLR HIGH ORDR BYTE + LD BFR ADR\n         O     1,*-8                    SET OPTIONS\n         LA    0,&SIZE                  LOAD SIZE OF BUFFER\n         AGO   .SVC                     GOTO ISSUE SVC\n.*\n.*   BUFFER SIZE IN REGISTER FORM\n.*\n.SZREG   DC    AL1(&OPT)                OPTION BITS\n         DC    AL3(&BFF)                BUFFER ADDR\n         L     1,*-4                    LOAD PARAMETER REGISTER\n         AIF   ('&SIZE' EQ '(0)').SVC   SIZE IN REG. 0\n         LR    0,&SIZE(1)               LOAD BUFFER SIZE IN REG 0\n         AGO   .SVC                     GOTO ISSUE SVC\n.*\n.*   WHEN BOTH ARE IN REGISTER NOTATION\n.*\n.BOTH    DC    AL1(&OPT)                OPTION BITS\n         DC    AL3(0)                   BUFFER ADDR\n         LA    1,0(,&BFF(1))            CLR HIGH ORDR BYTE + LD BFR ADR\n         O     1,*-8                    SET OPTIONS\n         AIF   ('&SIZE' EQ '(0)').SVC   GOTO SVC IF (0) SPECIFIED\n         LR    0,&SIZE(1)               LOAD BUFFER SIZE IN REG 0\n         AGO   .SVC                     GOTO ISSUE SVC\n.RF      ANOP\n         AIF   ('&WAIT' NE '').RERR\n         AIF   ('&BFF'(1,1) NE '(' OR '&SIZE'(1,1) NE '(').RERR\n&NAME    DS    0H\n         AIF   ('&BFF' EQ '(1)').SIZE\n         LR    1,&BFF(1)                LOAD BUFFER ADDRESS IN REG 1\n.SIZE    AIF   ('&SIZE' EQ '(0)').SVC\n         LR    0,&SIZE(1)               LOAD BUFFER SIZE IN REG 0\n         AGO   .SVC\n.RERR    IHBERMAC 192\n         MEXIT\n.ERROR1  IHBERMAC 24\n         MEXIT\n.ERROR2  IHBERMAC 54,,,\n         MEXIT\n.ERROR3  IHBERMAC 49,,&ERROPT\n         MEND\n./ ADD NAME=ON       0200-85137-85137-0814-00023-00023-00000-BROIDO\n         MACRO\n&NAME    ON    &FLAG\n.*\n.**********************************************************************\n.*                                                                    *\n.*   COPYRIGHT (C) 1981 BY JEFFREY R. BROIDO.  ALL RIGHTS RESERVED.   *\n.*                                                                    *\n.*     LICENSE IS HEREBY GRANTED TO WESTERN UNION INTERNATIONAL       *\n.*     (A SUBSIDIARY OF MCI, INCORPORATED) AND ITS AFFILIATES TO      *\n.*     USE THIS MACRO.  HOWEVER, IT MUST NOT BE BE SOLD, GIVEN,       *\n.*     OR OTHERWISE DISTRIBUTED TO ANY OTHER COMPANY OR DATA          *\n.*     CENTER WITHOUT PRIOR WRITTEN PERMISSION OF:                    *\n.*                                                                    *\n.*                                 JEFFREY R. BROIDO                  *\n.*                                 broidoj@gmail.com                  *\n.*                                                                    *\n.**********************************************************************\n.*\n         LCLC  &L\n&L       SETC  'L'''\n&NAME    OI    &FLAG,&L.&FLAG              (TURN ON BIT FLAG)\n         MEND\n./ ADD NAME=REGS     0103-79143-82335-0931-00026-00009-00019-ZADSJBR\n         MACRO\n&NAME    REGS\n.*\n.**********************************************************************\n.*                                                                    *\n.*   COPYRIGHT (C) 1979 BY JEFFREY R. BROIDO.  ALL RIGHTS RESERVED.   *\n.*                                                                    *\n.*   LICENSE IS HEREBY GRANTED TO AMERICAN INTERNATIONAL GROUP AND    *\n.*   ITS AFFILIATES TO USE THIS MACRO.  HOWEVER, IT MUST NOT BE BE    *\n.*   SOLD, GIVEN, OR OTHERWISE DISTRIBUTED TO ANY OTHER COMPANY OR    *\n.*   DATA CENTER WITHOUT PRIOR WRITTEN PERMISSION OF:                 *\n.*                                                                    *\n.*                                                                    *\n.*                                 JEFFREY R. BROIDO                  *\n.*                                 broidoj@gmail.com                  *\n.*                                                                    *\n.**********************************************************************\n.*\n         LCLA  &I\n&I       SETA  0\n.LUP     ANOP\nR&I      EQU   &I\n&I       SETA  &I+1\n         AIF   (&I LE 15).LUP\n         MEND\n./ ADD NAME=REQU     0100-85260-85260-1113-00030-00030-00000-BROIDO\n         MACRO\n&NAME    REQU\n.*\n.**********************************************************************\n.*                                                                    *\n.*   COPYRIGHT (C) 1979 BY JEFFREY R. BROIDO.  ALL RIGHTS RESERVED.   *\n.*                                                                    *\n.*   LICENSE IS HEREBY GRANTED TO AMERICAN INTERNATIONAL GROUP AND    *\n.*   ITS AFFILIATES TO USE THIS MACRO.  HOWEVER, IT MUST NOT BE BE    *\n.*   SOLD, GIVEN, OR OTHERWISE DISTRIBUTED TO ANY OTHER COMPANY OR    *\n.*   DATA CENTER WITHOUT PRIOR WRITTEN PERMISSION OF:                 *\n.*                                                                    *\n.*                                                                    *\n.*                                 JEFFREY R. BROIDO                  *\n.*                                 broidoj@gmail.com                  *\n.*                                                                    *\n.**********************************************************************\n.*                                                                    *\n.*   THIS VERSION OF MY REGS MACRO IS SUPPLIED FOR COMPATIBILITY      *\n.*   WITH THE VIRGINIA BLUE CROSS DISASSEMBLER.                       *\n.*                                                                    *\n.**********************************************************************\n         LCLA  &I\n&I       SETA  0\n.LUP     ANOP\nR&I      EQU   &I\n&I       SETA  &I+1\n         AIF   (&I LE 15).LUP\n         MEND\n./ ADD NAME=RESTORE  0101-85261-85284-1505-00034-00034-00001-BROIDO\n         MACRO\n.*\n.**********************************************************************\n.*                                                                    *\n.*   COPYRIGHT (C) 1985 BY BROIDO COMPUTER CONSULTING.                *\n.*   ALL RIGHTS RESERVED.                                             *\n.*                                                                    *\n.*   LICENSE IS HEREBY GRANTED TO MCI/WESTERN UNION INTERNATIONAL AND *\n.*   ITS AFFILIATES TO USE THIS MACRO.  HOWEVER, IT MUST NOT BE BE    *\n.*   SOLD, GIVEN, OR OTHERWISE DISTRIBUTED TO ANY OTHER COMPANY OR    *\n.*   DATA CENTER WITHOUT PRIOR WRITTEN PERMISSION OF:                 *\n.*                                                                    *\n.*                                                                    *\n.*                                 JEFFREY R. BROIDO                  *\n.*                                 broidoj@gmail.com                  *\n.*                                                                    *\n.**********************************************************************\n.*\n.**********************************************************************\n.*                                                                    *\n.*    THIS IS A REPLACEMENT FOR IBM'S RESTORE MACRO WHICH IS NOT      *\n.*        DISTRIBUTED TO ITS CUSTOMERS.  IT'S CONSTRUCTION WAS        *\n.*        INFERRED FROM THE DEBUGGING GUIDE.                          *\n.*                                                                    *\n.**********************************************************************\n.*\n&NAME    RESTORE &CHAIN,&RELATED=\n         AIF   ('&CHAIN' EQ '').E1\n&NAME    IHBINNRA &CHAIN           LOAD REGISTER 1.\n         SVC   17                  ISSUE RESTORE SVC.\n         MEXIT\n.E1      IHBERMAC 01,150                    MISSING PARAMETER\n         MEND\n./ ADD NAME=SPIB     0107-82223-82335-0932-00086-00054-00038-ZADSJBR\n         MACRO\n&NAME    SPIB  &DSECT=NO\n         LCLC  &N\n.*\n.**********************************************************************\n.*                                                                    *\n.*   COPYRIGHT (C) 1982 BY JEFFREY R. BROIDO.  ALL RIGHTS RESERVED.   *\n.*                                                                    *\n.*   LICENSE IS HEREBY GRANTED TO AMERICAN INTERNATIONAL GROUP AND    *\n.*   ITS AFFILIATES TO USE THIS MACRO.  HOWEVER, IT MUST NOT BE BE    *\n.*   SOLD, GIVEN, OR OTHERWISE DISTRIBUTED TO ANY OTHER COMPANY OR    *\n.*   DATA CENTER WITHOUT PRIOR WRITTEN PERMISSION OF:                 *\n.*                                                                    *\n.*                                                                    *\n.*                                 JEFFREY R. BROIDO                  *\n.*                                 broidoj@gmail.com                  *\n.*                                                                    *\n.**********************************************************************\n.*\n.**********************************************************************\n.*                                                                    *\n.*      SPIP - GDDM SYSTEM PROGRAMMER INTERFACE BLOCK.  USED WITH     *\n.*         THE GDDM SYSTEM PROGRAMMER VERSION OF THE REENTRANT        *\n.*         INTERFACE.  CONTROL BLOCK FORMAT COPIED FROM               *\n.*         SC33-0101-1:  GRAPHICAL DATA DISPLAY MANAGER RELEASE 2     *\n.*         USER'S GUIDE.  MACRO VERSION 1.00, WRITTEN AT A.I.G.       *\n.*         BY J. BROIDO, 8/11/82.                                     *\n.*                                                                    *\n.**********************************************************************\n.*\n*                                  MACRO VERSION 1.00, 8/11/82\n.*\n         AIF   ('&DSECT' EQ 'NO').NODSECT\n&N       SETC  '&NAME'\n         AIF   ('&N' NE '').NAMEOK\n&N       SETC  'SPIB'\n.NAMEOK  ANOP\n&N       DSECT                     GDDM SYS. PGMMR. INTERFACE BLOCK.\n         AGO   .DCONT\n.NODSECT ANOP\n&NAME    DS    0H                  GDDM SYS. PGMMR. INTERFACE BLOCK.\n.DCONT   ANOP\nSPIBHEAD EQU   *\nSPIBFLAG DC    XL4'00'             FOUR BYTES OF FLAGS.\n         ORG   SPIBFLAG\nSPIBFLGG DS    X                   GENERAL PURPOSE FLAGS.\nSPIBPVCF EQU   B'10000000'           PARAMETER VERIFICATION FLAG.\nSPIBSTGF EQU   B'01000000'           STORAGE CONTROL FLAG.\nSPIBERBF EQU   B'00100000'           ERROR FEEDBACK BLOCK FLAG.\nSPIBERTF EQU   B'00010000'           ERROR THRESHOLD FLAG.\nSPIBSTXF EQU   B'00001000'           STORAGE REQUEST EXITS FLAG.\nSPIBABRF EQU   B'00000100'           ABEND RETURN FLAG.\n         SPACE 1\nSPIBFLGD DS    X                   DEVICE PROTOCOL FLAGS.\nSPIBPA2F EQU   B'01000000'           RETURN PA2 TO ASREAD.\nSPIBXFBF EQU   B'00001000'           ATTENTION FEEDBACK BLOCK FLAG.\n         SPACE 1\nSPIBFLGA DS    X                   CICS CONTROL FLAGS.\nSPIBTISF EQU   B'10000000'           TRANSACTION INDEPENDENCE FLAG.\nSPIBAUDF EQU   B'01000000'           RECORD RESOURCES FLAG.\n         SPACE 1\n         DS    X                   RESERVED.\nSPIBERBL DC    F'0'                LENGTH OF ERROR FEEDBACK BLOCK...\n*                                  ... REQUIRED IF SPIBERBF = 1.\nSPIBERBP DC    F'0'                ADDRESS OF ERROR FEEDBACK BLOCK...\n*                                  ... REQUIRED IF SPIBERBF = 1.\nSPIBERTH DC    F'0'                ERROR THRESHOLD ...\n*                                  ... REQUIRED IF SPIBERTF = 1.\nSPIBSRAP DC    F'0'                ADDRESS OF STORAGE AUDIT TRAIL ...\n*                                  ... ANCHOR (IF SPIBAUDF = 1).\nSPIBPRAP DC    F'0'                ADDRESS OF PROGRAM AUDIT TRAIL ...\n*                                  ... ANCHOR (IF SPIBAUDF = 1).\n         DC    F'0'                RESERVED.\nSPIBXFBL DC    F'0'                LENGTH OF ATTENTION FEEDBACK ...\n*                                  ... BLOCK (IF SPIBXFBF = 1).\nSPIBXFBP DC    F'0'                ADDRESS OF ATTENTION FEEDBACK ...\n*                                  ... BLOCK (IF SPIBXFBF = 1).\nSPIBSXGP DC    F'0'                ADDRESS OF GET STORAGE APPLI- ...\n*                                  ... CATION EXIT (IF SPIBSTXF = 1).\nSPIBSXFP DC    F'0'                ADDRESS OF FREE STORAGE APPLI- ...\n*                                  ... CATION EXIT (IF SPIBSTXF = 1).\nSPIBSXPA DC    F'0'                USER DEFINED PARAMETER TO BE ...\n*                                  ... PASSED TP APPLICATION ...\n*                                  ... STORAGE EXIT (IF SPIBSTXF = 1).\n         MEND\n./ ADD NAME=TEST     0104-79143-82335-0932-00027-00010-00018-ZADSJBR\n         MACRO\n&NAME    TEST  &MASK=F\n.*\n.**********************************************************************\n.*                                                                    *\n.*   COPYRIGHT (C) 1976 BY JEFFREY R. BROIDO.  ALL RIGHTS RESERVED.   *\n.*                                                                    *\n.*   LICENSE IS HEREBY GRANTED TO AMERICAN INTERNATIONAL GROUP AND    *\n.*   ITS AFFILIATES TO USE THIS MACRO.  HOWEVER, IT MUST NOT BE BE    *\n.*   SOLD, GIVEN, OR OTHERWISE DISTRIBUTED TO ANY OTHER COMPANY OR    *\n.*   DATA CENTER WITHOUT PRIOR WRITTEN PERMISSION OF:                 *\n.*                                                                    *\n.*                                                                    *\n.*                                 JEFFREY R. BROIDO                  *\n.*                                 broidoj@gmail.com                  *\n.*                                                                    *\n.**********************************************************************\n.*\n         AIF   (K'&MASK GT 1).ERR1\n         CNOP  0,4\n&NAME    BAL   1,*+10\n         DC    X'0&MASK',VL3(TSOSPIE),X'7FFF'    PICA.\n         SVC   14                                ISSUE SPIE SVC.\n         MEXIT\n.ERR1    MNOTE 8,'INVALID PROGRAM MASK.'\n         MEND\n./ ADD NAME=TF       0108-81041-85184-0754-00023-00004-00021-BROIDO\n         MACRO\n&NAME    TF    &FLAG\n.*\n.**********************************************************************\n.*                                                                    *\n.*   COPYRIGHT (C) 1981 BY JEFFREY R. BROIDO.  ALL RIGHTS RESERVED.   *\n.*                                                                    *\n.*   LICENSE IS HEREBY GRANTED TO AMERICAN INTERNATIONAL GROUP AND    *\n.*   ITS AFFILIATES TO USE THIS MACRO.  HOWEVER, IT MUST NOT BE BE    *\n.*   SOLD, GIVEN, OR OTHERWISE DISTRIBUTED TO ANY OTHER COMPANY OR    *\n.*   DATA CENTER WITHOUT PRIOR WRITTEN PERMISSION OF:                 *\n.*                                                                    *\n.*                                                                    *\n.*                                 JEFFREY R. BROIDO                  *\n.*                                 broidoj@gmail.com                  *\n.*                                                                    *\n.**********************************************************************\n.*\n         LCLC  &L\n&L       SETC  'L'''\n&NAME    TM    &FLAG,&L.&FLAG              (TEST FLAG).\n         MEND\n./ ADD NAME=VDEF     0108-84303-84306-1149-00103-00088-00044-ANDERSO\n         MACRO\n&NAME    VDEF  &VLIST\n         LCLA  &LENG,&CTRBASE,&SUB\n         LCLB  &FIXB(99),&BITB(99),&HEXB(99),&CHRB(99),&INVB(99)\n         LCLB  &LN1B(99),&BGO\n         LCLC  &E\n         GBLA  &CTR\n&SUB     SETA  1                   SET ORIGINAL SUB\n&CTRBASE SETA  &CTR                KEEP TRACK OF ORIGINAL FOR 2ND PASS\n         AIF   (&BGO).BDONE\n&BGO     SETB  1\n&NAME    B     GO&SYSNDX\n.BDONE   ANOP\n         AIF   (D'VDEFLIT).LOOP    SEE IF 'VDEFINE' DEFINED YET\nVDEFLIT  DC    CL8'VDEFINE'        NAME OF SERVICE\n.LOOP    ANOP\n&E       SETC  '&VLIST(&SUB)'      GET CURRENT ENTRY IN LIST\n         AIF   (T'&E NE 'U').DEFINED\n.UNDEF   MNOTE 8,'VARIABLE &VLIST(&SUB) NOT DEFINED IN PROGRAM'\n&INVB(&SUB) SETB 1\n         AGO   .ENDLOOP\n.DEFINED ANOP\nVNAM&CTR DC    C'(&VLIST(&SUB))'   CONSTANT FOR NAME OF VARIABLE\n         AIF   (T'&E EQ 'A').FIXED    FIND FORMAT FOR TYPE\n         AIF   (T'&E EQ 'F').FIXED\n         AIF   (T'&E EQ 'G').FIXED\n         AIF   (T'&E EQ 'H').FIXED\n         AIF   (T'&E EQ 'Q').FIXED\n         AIF   (T'&E EQ 'R').FIXED\n         AIF   (T'&E EQ 'S').FIXED\n         AIF   (T'&E EQ 'V').FIXED\n         AIF   (T'&E EQ 'Y').FIXED\n         AIF   (T'&E EQ 'B').BIT\n         AIF   (T'&E EQ 'X').HEX\n         AIF   (T'&E EQ 'C').CHAR\n         AIF   (T'&E EQ 'Z').CHAR\n         MNOTE 8,'ILLEGAL TYPE ON VARIABLE &VLIST(&SUB)'\n&INVB(&SUB) SETB 1\n         AGO   .ENDLOOP\n.FIXED   ANOP  ,                   FIXED FORMAT:\n&FIXB(&SUB) SETB  1                         SET FLAG\n         AIF   (D'FIXEDLIT).GETLENG     IF NEEDED,\nFIXEDLIT DC    C'FIXED'                      GENERATE LITERAL\n         AGO   .GETLENG\n.BIT     ANOP  ,                   BIT FORMAT\n&BITB(&SUB) SETB  1\n         AIF   (D'BITLIT).GETLENG\nBITLIT   DC    C'BIT'\n         AGO   .GETLENG\n.HEX     ANOP  ,                   HEX FORMAT\n&HEXB(&SUB) SETB  1\n         AIF   (D'HEXLIT).GETLENG\nHEXLIT   DC    C'HEX'\n         AGO   .GETLENG\n.CHAR    ANOP  ,                   CHAR FORMAT\n&CHRB(&SUB) SETB  1\n         AIF   (D'CHARLIT).GETLENG\nCHARLIT  DC    C'CHAR'\n.GETLENG ANOP  ,                   GET LENGTH OF VARIABLE\n&LENG    SETA  L'&VLIST(&SUB)      LENGTH ATTRIBUTE\nLENG&CTR DC    F'&LENG'                      DEFINE LENGTH\n&LNB1(&SUB) SETB (&LENG EQ 1)\n.SKIPLEN ANOP\n.ENDLOOP ANOP\n&CTR     SETA  &CTR+1              NEXT CTR\n&SUB     SETA  &SUB+1              NEXT SUB\n         AIF   (&SUB LE N'&VLIST).LOOP\n&SUB     SETA  1                   START OVER TO GENERATE CALLS\n&CTR     SETA  &CTRBASE            RESET CTR TO BASE\nGO&SYSNDX DS   0H\n.CLOOP   ANOP\n         AIF   (NOT &LNB1(&SUB)).NOLENG\n&L       SETC  'L''&VLIST(&SUB)'\n         LA    15,&L               LENGTH DID NOT EXIST AT MACRO\n         ST    15,LENG&CTR             EXPANSION:  CALCULATE IT\n.NOLENG  ANOP\n         AIF   (&INVB(&SUB)).ENDCL\n         AIF   (&FIXB(&SUB)).CFIX\n         AIF   (&BITB(&SUB)).CBIT\n         AIF   (&HEXB(&SUB)).CHEX\n         AIF   (&CHRB(&SUB)).CCHAR\n         MNOTE 12,'MACRO ERROR -- ILLEGAL FLAGS FOR &VLIST(&SUB)'\n.CFIX    ANOP\n         CALL  ISPLINK,(VDEFLIT,VNAM&CTR,&VLIST(&SUB),FIXEDLIT,        +\n               LENG&CTR),VL\n         AGO   .ENDCL\n.CBIT    ANOP\n         CALL  ISPLINK,(VDEFLIT,VNAM&CTR,&VLIST(&SUB),BITLIT,          +\n               LENG&CTR),VL\n         AGO   .ENDCL\n.CHEX    ANOP\n         CALL  ISPLINK,(VDEFLIT,VNAM&CTR,&VLIST(&SUB),HEXLIT,          +\n               LENG&CTR),VL\n         AGO   .ENDCL\n.CCHAR   ANOP\n         CALL  ISPLINK,(VDEFLIT,VNAM&CTR,&VLIST(&SUB),CHARLIT,         +\n               LENG&CTR),VL\n         AGO   .ENDCL\n.ENDCL   ANOP\n&CTR     SETA  &CTR+1\n&SUB     SETA  &SUB+1\n         AIF   (&SUB LE N'&VLIST).CLOOP\n         MEND\n./ ADD NAME=VOPUT    0100-80009-80009-1134-00035-00035-00000-BROIDO\n         MACRO\n&NAME    VOPUT &M,&MF=I\n         LCLA  &LEN,&I\n         LCLB  &PAIR\n&LEN     SETA  K'&M-2\n&PAIR    SETB  0\n&I       SETA  1\n.QLOOPH  ANOP\n&I       SETA  &I+1+&PAIR\n         AIF   (&I GE K'&M).QDONEH\n&PAIR    SETB  ('&M'(&I,2) EQ '''''' OR '&M'(&I,2) EQ '&&')\n&LEN     SETA  &LEN-&PAIR\n         AGO   .QLOOPH\n.QDONEH  ANOP\n         AIF   ('&MF' EQ 'E').E\n         AIF   ('&MF' EQ 'L').L\n&NAME    BAL   1,V&SYSNDX          POINT TO MESSAGE.\n         DC    C&M                 MESSAGE.\n         DS    0H\nV&SYSNDX LA    0,&LEN              LOAD LENGTH.\n         LA    1,0(,1)             CLEAR OPTION BYTE.\n         BAL   14,OUT              CALL OUTPUT SUBROUTINE.\n         MEXIT\n.E       ANOP\n&NAME    SR    0,0                 LOAD ...\n         ICM   0,3,&M              ... LENGTH.\n         LA    1,&M+2              POIN TO MESSAGE.\n         BAL   14,OUT              CALL OUTPUT SUBROUTINE.\n         MEXIT\n.L       AIF   (&LEN EQ 0).LZ\n&NAME    DC    AL2(&LEN),C&M       MESSAGE.\n         MEXIT\n.LZ      ANOP\n&NAME    DC    AL2(0)              EMPTY MESSAGE.\n         MEND\n./ ADD NAME=VPUT     0105-79143-85287-1302-00044-00027-00037-BROIDO\n         MACRO\n&NAME    VPUT  &M,&MF=I,&MLOC=,&DCB=SYSPRINT\n.*\n.**********************************************************************\n.*                                                                    *\n.*   COPYRIGHT (C) 1979 BY JEFFREY R. BROIDO.  ALL RIGHTS RESERVED.   *\n.*                                                                    *\n.*   LICENSE IS HEREBY GRANTED TO AMERICAN INTERNATIONAL GROUP AND    *\n.*   ITS AFFILIATES TO USE THIS MACRO.  HOWEVER, IT MUST NOT BE BE    *\n.*   SOLD, GIVEN, OR OTHERWISE DISTRIBUTED TO ANY OTHER COMPANY OR    *\n.*   DATA CENTER WITHOUT PRIOR WRITTEN PERMISSION OF:                 *\n.*                                                                    *\n.*                                                                    *\n.*                                 JEFFREY R. BROIDO                  *\n.*                                 broidoj@gmail.com                  *\n.*                                                                    *\n.**********************************************************************\n.*\n         LCLB  &PAIR\n         LCLA  &LEN,&I\n&LEN     SETA  K'&M+2\n&PAIR    SETB  0\n&I       SETA  1\n.LOOP    ANOP\n&I       SETA  &I+1+&PAIR\n         AIF   (&I GE K'&M).DONE\n&PAIR    SETB  ('&M'(&I,2) EQ '''''' OR '&M'(&I,2) EQ '&&')\n&LEN     SETA  &LEN-&PAIR\n         AGO   .LOOP\n.DONE    ANOP\n         AIF   ('&MF' EQ 'L').VL\n&NAME    LA    1,&DCB              LOAD DCB ADDRESS.\n         BAL   0,VPUT&SYSNDX       LOAD MSG ADDRESS\n         DC    AL2(&LEN),AL2(0)    RCW - LENGTH OF MESSAGE.\n         AIF   (&LEN LE 4).NOMSG\n&MLOC    DC    C&M\n.NOMSG   ANOP\nVPUT&SYSNDX PUT (1),(0)\n         MEXIT\n.VL      ANOP\n&NAME    DC    AL2(&LEN),AL2(0)    RCW - LENGTH OF MESSAGE.\n&MLOC    DC    C&M\n         MEND\n./ ADD NAME=VTPUT    0105-79143-82335-0933-00052-00032-00023-ZADSJBR\n         MACRO\n&NAME    VTPUT &M,&MLAB,&MF=I\n.*\n.**********************************************************************\n.*                                                                    *\n.*   COPYRIGHT (C) 1979 BY JEFFREY R. BROIDO.  ALL RIGHTS RESERVED.   *\n.*                                                                    *\n.*   LICENSE IS HEREBY GRANTED TO AMERICAN INTERNATIONAL GROUP AND    *\n.*   ITS AFFILIATES TO USE THIS MACRO.  HOWEVER, IT MUST NOT BE BE    *\n.*   SOLD, GIVEN, OR OTHERWISE DISTRIBUTED TO ANY OTHER COMPANY OR    *\n.*   DATA CENTER WITHOUT PRIOR WRITTEN PERMISSION OF:                 *\n.*                                                                    *\n.*                                                                    *\n.*                                 JEFFREY R. BROIDO                  *\n.*                                 broidoj@gmail.com                  *\n.*                                                                    *\n.**********************************************************************\n.*\n         LCLA  &LEN,&I\n         LCLB  &PAIR\n&LEN     SETA  K'&M-2\n&PAIR    SETB  0\n&I       SETA  1\n.QLOOPH  ANOP\n&I       SETA  &I+1+&PAIR\n         AIF   (&I GE K'&M).QDONEH\n&PAIR    SETB  ('&M'(&I,2) EQ '''''' OR '&M'(&I,2) EQ '&&')\n&LEN     SETA  &LEN-&PAIR\n         AGO   .QLOOPH\n.QDONEH  ANOP\n         AIF   ('&MF' EQ 'E').E\n         AIF   ('&MF' EQ 'L').L\n&NAME    BAL   1,V&SYSNDX          POINT TO MESSAGE.\n&MLAB    DC    C&M                 MESSAGE.\n         DS    0H\nV&SYSNDX LA    0,&LEN              LOAD LENGTH.\n         LA    1,0(,1)             CLEAR OPTION BYTE.\n         SVC   93                  ISSUE TPUT/TGET SVC.\n         MEXIT\n.E       ANOP\n&NAME    SR    0,0                 LOAD ...\n         ICM   0,3,&M              ... LENGTH.\n         LA    1,&M+2              POIN TO MESSAGE.\n         SVC   93                  ISSUE TPUT/TGET SVC.\n         MEXIT\n.L       AIF   (&LEN EQ 0).LZ\n&NAME    DC    AL2(&LEN),C&M       MESSAGE.\n         MEXIT\n.LZ      ANOP\n&NAME    DC    AL2(0)              EMPTY MESSAGE.\n         MEND\n./ ADD NAME=VWTPU    0158-79065-84033-2006-00114-00028-00104-Z53\n         MACRO\n&NAME    VWTPU &MM,&MLAB1,&MF=I,&MODE=\n.*\n.**********************************************************************\n.*                                                                    *\n.*   COPYRIGHT (C) 1979 BY JEFFREY R. BROIDO.  ALL RIGHTS RESERVED.   *\n.*                                                                    *\n.*   LICENSE IS HEREBY GRANTED TO MANUFACTURERS HANOVER TRUST AND     *\n.*   ITS AFFILIATES TO USE THIS MACRO.  HOWEVER, IT MUST NOT BE BE    *\n.*   SOLD, GIVEN, OR OTHERWISE DISTRIBUTED TO ANY OTHER COMPANY OR    *\n.*   DATA CENTER WITHOUT PRIOR WRITTEN PERMISSION OF:                 *\n.*                                                                    *\n.*                                                                    *\n.*                                 JEFFREY R. BROIDO                  *\n.*                                 broidoj@gmail.com                  *\n.*                                                                    *\n.**********************************************************************\n.*\n         LCLA  &LEN,&I,&J,&LEN1\n         LCLB  &PAIR\n         LCLC  &M1,&M2,&U,&L,&MLAB,&X,&M\n&M       SETC  '&MM'\n&MLAB    SETC  '&MLAB1'\n&U       SETC  'AEIOUBCDFGHJKLMNPQRSTVWXYZ'\n&L       SETC  'aeioubcdfghjklmnpqrstvwxyz'\n&LEN     SETA  K'&M-2\n         AIF   ('&MF' EQ 'E').QEX\n         AIF   ('&MODE' NE 'FOLD' OR '&MLAB' NE '').QCONT8\n&MLAB    SETC  'V&SYSNDX.E'\n.QCONT8  ANOP\n&PAIR    SETB  0\n&I       SETA  1\n&LEN1    SETA  &LEN+2\n.QLOOPH  ANOP\n&I       SETA  &I+1+&PAIR\n         AIF   (&I GE K'&M).QDONEH\n&PAIR    SETB  ('&M'(&I,2) EQ '''''' OR '&M'(&I,2) EQ '&&')\n&LEN     SETA  &LEN-&PAIR\n         AGO   .QLOOPH\n.QDONEH  ANOP\n         AIF   ('&MF' EQ 'L').QPARM\n&NAME    CNOP  0,4                 FULLWORD ALIGN PARM LIST.\n         BAL   1,V&SYSNDX.A        POINT TO MESSAGE.\n         AGO   .QCONT\n.QPARM   ANOP\n&NAME    DS    0F                  FULLWORD ALIGN PARM LIST.\n.QCONT   ANOP\n         DC    AL2(&LEN+4),X'8000' LENGTH AND FLAGS FOR WTO.\n         AIF   ('&MODE' EQ 'FOLD').MFOLD\n&MLAB    DC    C&M                 MESSAGE.\n         AGO   .QCONT1\n.MFOLD   ANOP\n&M2      SETC  ''\n&J       SETA  1\n.LU1     ANOP\n         AIF   ('&J' GT '&LEN1').QCONT5\n&I       SETA  1\n.LU2     ANOP\n         AIF   ('&M'(&J,1) NE '&L'(&I,1)).BU2\n&M2      SETC  '&M2'.'&U'(&I,1)\n         AGO   .BU1\n.BU2     ANOP\n&I       SETA  &I+1\n         AIF   (&I LE 26).LU2\n&M2      SETC  '&M2'.'&M'(&J,1)\n.BU1     ANOP\n&J       SETA  &J+1\n         AGO   .LU1\n.QCONT5  ANOP\n&X       SETC  'V&SYSNDX.D'\n&X       DC    C&M2                UPPERCASE MESSAGE.\n.QCONT1  DC    X'02000020'         ROUTCDE=11,DESC=7\n         AIF   ('&MF' EQ 'L').QEND\n         AIF   ('&MODE' NE 'FOLD').QCONT2\n&MLAB    DC    C&M                 RAW MESSAGE.\n.QCONT2  DS    0H\n&X       SETC  'V&SYSNDX.A'\n&X       TM    FLAG,$TSO           RUNNING UNDER TSO?\n         BO    V&SYSNDX.B          B IF YES.\n         SVC   35                  DO WTO (FOR WTP).\n         B     V&SYSNDX.C          CONTINUE.\n         AIF   ('&MODE' NE 'FOLD').QCONT6\n&X       SETC  'V&SYSNDX.B'\n&X       LA    1,&MLAB             POINT TO MESSAGE.\n         AGO   .QCONT7\n.QCONT6  ANOP\n&X       SETC  'V&SYSNDX.B'\n&X       LA    1,4(,1)             POINT TO MESSAGE.\n.QCONT7  LA    0,&LEN              LOAD LENGTH.\n         SVC   93                  TPUT SVC.\n&X       SETC  'V&SYSNDX.C'\n&X       EQU   *\n.QEND    MEXIT\n.QEX     AIF   ('&M' EQ '').QEX2\n         AIF   ('&M' EQ '(1)').QEX2\n         AIF   ('&M'(1,1) EQ '(').QEX1\n         LA    1,&M                POINT TO PARM.\n         AGO   .QEX2\n.QEX1    ANOP\n&M1      SETC  '&M'\n         LR    1,&M1               POINT TO PARM.\n.QEX2    TM    FLAG,$TSO           RUNNING UNDER TSO?\n         BO    V&SYSNDX.B          B IF YES.\n         SVC   35                  DO WTO (FOR WTP).\n         B     V&SYSNDX.C          CONTINUE.\n&X       SETC  'V&SYSNDX.B'\n&X       LH    0,0(,1)             LOAD LENGTH.\n         SH    0,=H'4'             CORRECT LENGTH.\n         LA    1,4(,1)             POINT TO MESSAGE.\n         SVC   93                  TPUT SVC.\n&X       SETC  'V&SYSNDX.C'\n&X       EQU   *\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#CHECKDD": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x18/\\x00\\x85\\x18/\\x18%\\x00\\x10\\x00\\x10\\x00\\x00\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "1985-07-01T18:25:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "BROIDO"}, "text": ")F FUNCTION        * A utility for the authors of CLISTS *\n\n   CHECKDD - Command to check if one or more DDNAMEs is presently\n             allocated to your TSO session.\n)X SYNTAX\n\n     CHECKDD ...ddname list...\n\n       If all the DDNAMEs in the list are presently allocated, the\n       command will return a condition code of 0 (&LASTCC=0).   If\n       any of the DDNAMEs are missing,  it will return a condition\n       code of 4 (&LASTCC=4).\n)O OPERANDS\n\n))DDNAME LIST - List of DDNAMEs to check (either a single DDNAME or\n                a list enclosed in parentheses).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#CKDAY": {"ttr": 1546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x18/\\x00\\x85\\x18/\\x18%\\x00\\x1c\\x00\\x1c\\x00\\x00\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "1985-07-01T18:25:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "BROIDO"}, "text": ")F FUNCTION        * A utility command for authors of CLISTS *\n\n    CKDAY - Command to check for prior execution on this date of the\n            CKDAY command.  This command is expecially useful when\n            included in a CLIST that is executed automatically at\n            LOGON time.  CKDAY can determine whether it is the first\n            execution of the CLIST (therefore the first LOGON of the\n            day) and direct the CLIST to perform some action\n            appropriate to this first LOGON.\n\n       Check &LASTCC: IF 0, CKDAY has already been executed today.\n                         4, CKDAY last executed prior to today.\n                         8, CKDAY has never executed (or not executed\n                            since CLEARDAY command executed).\n                        12, CKDAY can't store date (the area used to\n                            store date is in use by some other\n                            program).\n                        16, Command not running under TSO.\n\n    Type  H CLEARDAY  for more information.\n\n)X SYNTAX\n\n     CKDAY\n)O OPERANDS\n\n     None.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#CKM": {"ttr": 1548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x18/\\x00\\x85\\x18/\\x18%\\x00\\x1d\\x00\\x1d\\x00\\x00\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "1985-07-01T18:25:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "BROIDO"}, "text": ")F FUNCTION        * A utility command for authors of CLISTS *\n\n       CKM - Command to check the presence of a particular member\n             in a partitioned data set.\n\n     To Use: 1) Allocate the PDS, with the member specified in\n                parentheses.\n\n             2) CKM ..DDNAME.. where DDNAME is optional, and defaults\n                to SYSUT9 if not specified.  It must be the same\n                DDNAME (FILENAME) used to allocate the PDS in step 1)\n                above.\n\n             3) Check &LASTCC.  IF 0, MEMBER IS PRESENT.\n                                   4, MEMBER IS NOT IN DATASET.\n                                   8, NO MEMBER SPECIFIED.\n                                  16, DATASET IS NOT PARTITIONED.\n                                  20, DATASET NOT FOUND ON VOLUME.\n                                  24, SYSUT9 (OR YOUR OWN DDNAME)\n                                      NOT ALLOCATED.\n)X SYNTAX\n\n     CKM ...DDNAME...\n)O OPERANDS\n\n))DDNAME\n\n    Required - none\n    Default  - DDNAME defaults to SYSUT9.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#CKMOUNT": {"ttr": 1550, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x18/\\x00\\x85\\x18/\\x18%\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "1985-07-01T18:25:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "BROIDO"}, "text": ")F FUNCTION        * A utility for the authors of clists *\n\n\n    CKMOUNT - Command to determine TSO user's volume mount privelege.\n)X SYNTAX\n\n     CKMOUNT\n\n        The condition code (&LASTCC) is returned as follows:\n             &LASTCC = 0  -  User is not mount priveleged.\n             &LASTCC = 4  -  User is mount priveleged.\n\n)O OPERANDS\n    none.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#CKO": {"ttr": 1552, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x18/\\x00\\x85\\x18/\\x18%\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "1985-07-01T18:25:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "BROIDO"}, "text": ")F FUNCTION        * A utility command for authors of CLISTS *\n\n       CKO - Command to determine TSO user's level of privilege.\n)X SYNTAX\n\n     CKO\n\n        The condition code (&LASTCC) is returned as follows:\n             &LASTCC = 0  -  User is neither OPER nor ACCT privileged.\n             &LASTCC = 4  -  User is OPER but not ACCT privileged.\n             &LASTCC = 8  -  User is both OPER and ACCT privileged.\n\n)O OPERANDS\n     none.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#CLRDAY": {"ttr": 1554, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x18/\\x00\\x85\\x18/\\x18%\\x00\\x14\\x00\\x14\\x00\\x00\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "1985-07-01T18:25:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "BROIDO"}, "text": ")F FUNCTION        * A utility command for authors of CLISTS *\n\n    CLEARDAY   Command to clear CKDAY's saved date field.\n\n       Check &LASTCC: IF 0, CLEARDAY has executed properly.\n                         8, Date field was already blank.\n                        12, CLEARDAY can't clear date (the area used\n                            to store date is in use by some other\n                            program).\n                        16, Command not running under TSO.\n\n    Type  H CKDAY for more information.\n\n)X SYNTAX\n\n     CLEARDAY\n)O OPERANDS\n\n     None.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#LAA": {"ttr": 1556, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x18/\\x00\\x85\\x18/\\x18%\\x00\\x13\\x00\\x13\\x00\\x00\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "1985-07-01T18:25:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "BROIDO"}, "text": ")F FUNCTION -\n\n  The LAA command is used to  display the names of currently alloc-\n  ated data sets.  Unlike LISTALC, LAA displays all information for\n  a dataset on one line,  and  takes no operands to control what is\n  listed.   LAA tells you allocation statys as opposed to dealloca-\n  tion disposition.\n\n)X SYNTAX -\n\n         LAA     K\n\n)O OPERANDS -\n\n))K        - If your terminal is a 32xx or 31xx tube, the screen will\n             be cleared before execution.\n\n  Required - none\n  Defaults - none\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#QUOTE": {"ttr": 1558, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x18/\\x00\\x85\\x18/\\x18%\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "1985-07-01T18:25:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "BROIDO"}, "text": ")F FUNCTION -\n\n  The  QUOTE  command is used to display the Quote-of-the-Day,  along\n  with background information and references.  Note  that if you have\n  any comments about any of the quotes.\n\n  The  quotations  used,  in  most cases,  will be famous, and in all\n  cases must be documentable.   If possible, they will be appropriate\n  as well.\n\n  The  Quote-of-the-Day represents no particular editorial view,  and\n  must be taken only for what it is,  a  pet  project of a moderately\n  eccentric  Systems Programmer.   Specifically, the Quote-of-the-Day\n  does NOT represent the views of ... fill in the shop ...\n)X SYNTAX -\n\n         %QUOTE LONG/SHORT PAUSE/NOPAUSE CLEAR/NOCLEAR\n\nDEFAULTS: LONG, PAUSE, CLEAR\n)O OPERANDS -\n))LONG    - The quotation will be listed with all background info.\n))SHORT   - The quotation will be listed without background info.\n))PAUSE   - Allows pauses at appropriate points.\n))NOPAUSE - Tells QUOTE not to pause during output.\n))CLEAR   - QUOTE will clear the display screen before output.\n))NOCLEAR - Tells QUOTE not to clear the display screen before output.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#TELL": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x18/\\x00\\x85\\x18/\\x18%\\x008\\x008\\x00\\x00\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "1985-07-01T18:25:00", "lines": 56, "newlines": 56, "modlines": 0, "user": "BROIDO"}, "text": ")F FUNCTION -\n\n   The TELL command sets-up a teleconference with another user.  The\nuser must be logged-on and accepting messages.  If both users are\nusing this command, communications between them can be much more\nconvenient than if they use the SEND command, but still more\ndifficult than that exotic new invention, the telephone.\n)X SYNTAX -\n\n          TELL 'userid'\n\n   You will find that this command works best if you keep a couple of\nthings in mind, and follow a few rules.  Once you have established a\nTELL session, almost everything you type is sent verbatim to the other\nuser.  Your set of messages are preceded by a single line:\n\n              FOLLOWING MESSAGES FROM ...your userid...-\n\n   Each line that you type gets a dash (-) attached to the end of it,\ntelling the other user that you are not finished with your current\ntrain of thought.  After you are done with a single train of thought\n(and keep them short, please), leave a couple of spaces and type the\ncharacters\n\n             GA\n\non the end of the last line you typed.  a dash will not be appended to\nthat line, and the \"GA\" will be the cue to your other user to start\nreplying.  If you ever teleconferenced before, particularly on the\nARPANET, you might realize that \"GA\" stands for \"Go Ahead.\"  When you\nsee your other user's \"GA,\" then you start typing again, and so on.\n\n   There's one little problem with this, and that's the fact that you\nmust hit the ENTER key to see your other user's messages.  This is due\nto the fact that TSO terminal support can't send output to your\nterminal while it is waiting for input.  You can get around this by\ngoing into what I call \"half duplex mode.\"  Simply type .h as the first\ntwo characters on a line.  At that point your keyboard will lock.  To\nunlock the keyboard, hit the ATTN key.  The keyboard will stay unlocked\nuntil TELL sees GA on the end of a line, with which it will lock the\nkeyboard again.  While the keyboard is locked, any messages sent to you\nwill appear as the other user hits ENTER.  To reply, hit ATTN again,\nand so forth.  Don't forget to type GA at the end of a message, or your\nother user will not know to reply, and the keyboard will not lock.\n\nAt any time if the ATTN key does not work, as it will not with older \"A\"\ntype non-SNA 327x sessions (see the lower left corner of your screen),\ntry the sequence RESET - PA1.\n\n   To end a TELL session, type    /*   as the first 2 characters of a\nline.  Your other user will then get the following message:\n\n         END OF MESSAGES FROM ...your userid...\n)O\n   Good luck, and happy teleconferencing.  Just remember one thing:\nIf you can, use the phone...  It's a lot quicker.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE423": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00A\\x01 \\x03O\\x01 \\x03O\\x08X\\x00\\\\\\x00\\\\\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2020-02-03T00:00:00", "modifydate": "2020-02-03T08:58:41", "lines": 92, "newlines": 92, "modlines": 0, "user": "CBT-499"}, "text": "//***FILE 423 IS FROM JEFF BROIDO OF BROIDO COMPUTER CONSULTING.    *   FILE 423\n//*           THIS FILE IS IN IEBUPDTE SYSIN FORMAT AND CONTAINS    *   FILE 423\n//*           THE FOLLOWING MEMBERS :                               *   FILE 423\n//*                                                                 *   FILE 423\n//*           This is all Jeff Broido's stuff, but I made a few     *   FILE 423\n//*           changes here and there, like PUTLINE-ing LAA and      *   FILE 423\n//*           other programs which were coded with TPUT, etc.       *   FILE 423\n//*           (Sam Golob), adding LISTHEAD, etc. which I found      *   FILE 423\n//*           among Jeff's later programs, and modifying it some.   *   FILE 423\n//*                                                                 *   FILE 423\n//*        email:   broidoj@gmail.com                               *   FILE 423\n//*         or  :   sbgolob@cbttape.org                             *   FILE 423\n//*                                                                 *   FILE 423\n//*        $$$COJRB....ASSEMBLER MACRO FOR COPYRIGHT NOTICE         *   FILE 423\n//*        #CHECKDD....HELP MEMBER FOR CHECKDD                      *   FILE 423\n//*        #CKDAY......HELP MEMBER FOR CKDAY                        *   FILE 423\n//*        #CKM........HELP MEMBER FOR CKM                          *   FILE 423\n//*        #CKMOUNT....HELP MEMBER FOR CKMOUNT                      *   FILE 423\n//*        #CKO........HELP MEMBER FOR CKO                          *   FILE 423\n//*        #CLRDAY.....HELP MEMBER FOR CLEARDAY                     *   FILE 423\n//*        #LAA........HELP MEMBER FOR LAA                          *   FILE 423\n//*        #QUOTE......HELP MEMBER FOR QUOTE                        *   FILE 423\n//*        #TELL.......HELP MEMBER FOR TELL                         *   FILE 423\n//*        BRODCAST....SOURCE CODE FOR PGM TO LOAD SYS1.BRODCAST    *   FILE 423\n//*        CHECKDD.....SOURCE CODE FOR PGM TO CHECK FOR ALLOCATED   *   FILE 423\n//*                    FILENAMES                                    *   FILE 423\n//*        CKC.........SOURCE CODE FOR PGM TO CHECK AVAILABLE       *   FILE 423\n//*                    CORE STORAGE FOR YOUR TSO SESSION            *   FILE 423\n//*        CKDAY.......SOURCE CODE FOR PGM TO CHECK FOR 1ST LOGON   *   FILE 423\n//*                    OF THE DAY                                   *   FILE 423\n//*        CKM.........SOURCE CODE FOR PGM TO CHECK PRESENCE OF     *   FILE 423\n//*                    MEMBER IN PDS                                *   FILE 423\n//*        CKMOUNT.....SOURCE CODE FOR PGM TO CHECK A USER'S MOUNT  *   FILE 423\n//*                    PRIVILEGE                                    *   FILE 423\n//*        CKO.........SOURCE CODE FOR PGM TO CHECK A USER'S        *   FILE 423\n//*                    PRIVILEGES                                   *   FILE 423\n//*        DIGCLK......SOURCE CODE FOR CMD TO DISPLAY TIME          *   FILE 423\n//*                    ON 3270 TERMINALS                            *   FILE 423\n//*        DUMPV.......DUMP VARIABLES AND THEIR EVALUATIONS         *   FILE 423\n//*                    IN CLISTS AND REXX EXECS                     *   FILE 423\n//*        FINDEM......GDG VOLSER DISPLAY PROGRAM (TSO COMMAND)     *   FILE 423\n//*        FIXSMPLG....FIX AN SMP/E LOG FILE THAT WAS CORRUPTED     *   FILE 423\n//*        HEXPGM......TYPE IN HEX CHARACTERS AND DISPLAY ON THE    *   FILE 423\n//*                    TERMINAL IN ANY TPUT MODE.                   *   FILE 423\n//*        K...........ASSEMBLER MACRO                              *   FILE 423\n//*        LAA.........SOURCE CODE FOR PGM TO PRODUCE AN EXPANDED   *   FILE 423\n//*                    ALLOCATION LISTER - Now a PUTLINE version    *   FILE 423\n//*        LISTATTR....LIST ATTRIBUTE LISTS. (PARM OF A, LIST ALL)  *   FILE 423\n//*        (LAT)            (alias)  -  PUTLINE output.             *   FILE 423\n//*        LISTHEAD....LOAD a module into storage and list the      *   FILE 423\n//*                    \"header\" information at the beginning.       *   FILE 423\n//*                    (Modified to show more headers, and          *   FILE 423\n//*                    to display the first 300 bytes of the        *   FILE 423\n//*                    load module.)                                *   FILE 423\n//*        LISTMOD.....LIST an entire module, either from the       *   FILE 423\n//*        LISTMODD....beginning, or from the entry point if the    *   FILE 423\n//*                    ENTRY keyword is used. Not written by Jeff   *   FILE 423\n//*                    Broido, but the idea came from his LISTHEAD  *   FILE 423\n//*                    program. Kept here because it is closely     *   FILE 423\n//*                    related to LISTHEAD.                         *   FILE 423\n//*                    LISTMOD shows displacements in HEX           *   FILE 423\n//*                    LISTMODD shows displacements in DECIMAL      *   FILE 423\n//*        MAPSP.......SOURCE CODE FOR PGM TO PRODUCE MVS/SP        *   FILE 423\n//*                    STORAGE MAP                                  *   FILE 423\n//*        MAPXA.......SOURCE CODE FOR PGM TO PRODUCE MVS/XA        *   FILE 423\n//*                    STORAGE MAP (tested to z/OS 2.1)             *   FILE 423\n//*        MERKNOW.....SOURCE CODE FOR SUPPORT ROUTINE FOR THE      *   FILE 423\n//*                    NOW MACRO                                    *   FILE 423\n//*        NOW.........ASSEMBLER MACRO                              *   FILE 423\n//*        OFF.........ASSEMBLER MACRO                              *   FILE 423\n//*        ON..........ASSEMBLER MACRO                              *   FILE 423\n//*        QUOTE.......SOURCE CODE FOR PGM TO READ                  *   FILE 423\n//*                    'QUOTE-OF-THE-DAY'                           *   FILE 423\n//*        REGS........ASSEMBLER MACRO                              *   FILE 423\n//*        SMAP........SOURCE CODE FOR PGM TO PRODUCE A STORAGE     *   FILE 423\n//*                    MAP                                          *   FILE 423\n//*        TELL........SOURCE CODE FOR PGM FOR TELECONFERENCING     *   FILE 423\n//*                    TSO COMMAND                                  *   FILE 423\n//*                    (Fixed for XA thry z/OS by Sam Golob.)       *   FILE 423\n//*        TERMSZ......Same as TERMSIZE, but it is a TSO command,   *   FILE 423\n//*                    which gets the info directly from the TSB,   *   FILE 423\n//*                    and therefore it has to be APF-authorized.   *   FILE 423\n//*        TERMSIZE....Same as TERMTYPE, but it is a TSO command,   *   FILE 423\n//*                    which PUTLINE's the terminal size info       *   FILE 423\n//*                    to the terminal.  Output of GTSIZE macro.    *   FILE 423\n//*        TERMTYPE....SOURCE PGM THAT TELLS YOU HOW MANY LINES     *   FILE 423\n//*                    YOUR TERMINAL CAN DISPLAY (GTSIZE TOOL)      *   FILE 423\n//*        TF..........ASSEMBLER MACRO                              *   FILE 423\n//*        VPUT........ASSEMBLER MACRO                              *   FILE 423\n//*        VTPUT.......ASSEMBLER MACRO                              *   FILE 423\n//*        VWTPU.......ASSEMBLER MACRO                              *   FILE 423\n//*                                                                 *   FILE 423\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BRODCAST": {"ttr": 1798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x00\\x85\\x18/\\x01\\x13\\x13/\\x15\\x08\\x02w\\x02x\\x02w\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "2013-05-12T15:08:31", "lines": 631, "newlines": 632, "modlines": 631, "user": "BROIDO"}, "text": "BRODCAST TITLE 'BRODCAST - LOAD ''SYS1.BRODCAST'' DATASET.  '\n*%A AMODGEN PPLINK AC(1) NOTEST SUBLIB\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  COPYRIGHT (C) 1982 BY BROIDO COMPUTER CONSULTING.  ALL RIGHTS      *\n*  RESERVED EXCEPT:                                                   *\n*                                                                     *\n*  PARTICULAR LICENSE IS GRANTED TO DISTRIBUTE THIS PROGRAM FREE      *\n*  OF CHARGE, BUT IT MUST NOT BE SOLD.  A SERVICE CHARGE FOR          *\n*  HANDLING A COLLECTION OF SOFTWARE OF WHICH THIS IS A PART,         *\n*  ON THE OTHER HAND, IS APPROPRIATE.                                 *\n*                                                                     *\n*                                  BROIDO COMPUTER CONSULTING         *\n*                                  broidoj@gmail.com                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         GBLC  &TSO,&QUOTE\n         GBLB  &VITAL\n&TSO     SETC  'VANILLA'           SET TO 'E' FOR TSO/E, IN ...\n*                                  ... WHICH CASE PROGRAM MUST ...\n*                                  ... BE AUTHORIZED.\n&QUOTE   SETC  'SYS1.DAILY.QUOTE'  PDS CONTAINING NOTICES/QUOTATIONS.\n&VITAL   SETB  (1)                 SET TO 0 TO SUPPRESS SETTING ...\n*                                  ... VITAL MESSAGE BIT IN ...\n*                                  ... CVTUSER. IF &VITAL IS 1, ...\n*                                  ... PROGRAM MUST BE AUTHORIZED.\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   BRODCAST - PROGRAM TO LOAD NOTICES AND AN OPTIONAL QUOTE-OF-      *\n*       THE-DAY FROM AN EDITABLE PDS TO 'SYS1.BRODCAST'.  THIS        *\n*       PROGRAM WILL RUN EITHER AS A TSO COMMAND OR AS A STARTED      *\n*       TASK.  IT IS INTENDED THAT THIS PROGRAM RUN AT LEAST ONCE     *\n*       DAILY, PERHAPS AT 01:00, TO LOAD THE QUOTE-OF-THE-DAY.        *\n*       THE RESULTS ARE NOT CUMULATIVE, AND ALL NOTICE/QUOTE          *\n*       INFORMATION IS RE-WRITTEN EACH TIME THE PROGRAM RUNS (IT      *\n*       TAKES NO MORE THAN A COUPLE OF SECONDS).                      *\n*       THE PROGRAM INTERFERES IN NO WAY WITH NORMAL 'SYS1.BRODCAST'  *\n*       PROCESSING, AND EITHER SEND COMMAND CAN BE USED TO ADD        *\n*       NOTICES AND MAIL AS NORMAL.                                   *\n*                                                                     *\n*       THE SIGNIFICANT ATTRIBUTES OF THE SOURCE PDS ARE:             *\n*       LRECL(92) RECFM(V B) DSORG(PO).  THE NOTICE MEMBER NAMES      *\n*       ARE OF THE FORM HEAD@@@@ WHERE @@@@ IS THE SMF ID OF THE      *\n*       SYSTEM THE PROGRAM IS RUNNING ON.  THUS, YOU CAN HAVE         *\n*       MULTIPLE NOTICE MEMBERS FOR MULTIPLE SYSTEMS SHARING ONE      *\n*       SOURCE PDS.  THE QUOTE-OF-THE-DAY MEMBER NAMES ARE OF THE     *\n*       FORM QYYMMDD, WHERE YYMMDD, OBVIOUSLY, IS THE YEAR, MONTH     *\n*       AND DAY.                                                      *\n*                                                                     *\n*       IN EITHER TYPE OF MEMBER, ONLY COLUMNS 9-76 ARE               *\n*       SIGNIFICANT, ALLOWING STANDARD VARIBLE RECORD SEQUENCE        *\n*       NUMBERS IN COLUMNS 1-8.  LINES WITH /* STARTING IN COLUMN     *\n*       9 ARE TREATED AS COMMENDS WITH THE EXCEPTION THAT IF, IN      *\n*       THE APPROPRIATE NOTICE MEMBER, THE TEXT \"/*VITAL\" BEGINS      *\n*       ANY RECORD, THE PROGRAM WILL TURN ON THE SECOND BIT           *\n*       (X'40') IN THE FIRST BYTE OF CVTUSER TO TELL A COMPANION      *\n*       LOGON EXIT (IKJEFLD) THAT THE NOTICES ARE VITAL, AND NOT      *\n*       TO ALLOW SUPPRESSION VIA THE LOGON KEYWORD \"NONOTICES\".       *\n*                                                                     *\n*       IN QUOTE MEMBER RECORDS, AN \"@\" OR \"#\" IN COLUMN 9            *\n*       SIGNIFIES THAT THE RECORD IS PART OF THE QUOTATION'S          *\n*       BACKGROUND INFORMATION, AND NOT TO BE DISPLAYED AT LOGON,     *\n*       BUT ONLY IF THE TSO USER EXECUTES THE \"QUOTE\" COMMAND.        *\n*       RECORDS STARTING WITH ANYTHING ELSE ARE PART OF THE MAIN      *\n*       LOGON-TIME QUOTATION, AND ARE PLACED AFTER THE NOTICES        *\n*       FROM MEMBER HEAD@@@@.  THE \"#\" SIGNIFIES THAT THE QUOTE       *\n*       COMMMAND SHOULD STOP BEFORE DISPLAYING THE LINE(S) IN         *\n*       QUESTION AND ASK IF THE USER WISHES TO SEE ANY MORE           *\n*       BACKGROUND INFORMATION.  THE FOLLOWING ARE EXAMPLES OF        *\n*       TWO QUOTE MEMBERS:                                            *\n*                                                                     *\n*   COL. 9                                                 col. 76    *\n*   |                                                            |    *\n*       THE FOLLOWING IS MEMBER Q850524:                              *\n*                                                                     *\n*   \"The world will never have lasting peace so long as men           *\n*       reserve for war the finest human qualities.\"                  *\n*                                   John Foster Dulles (1888-1959)    *\n*   @This to remind us that next Thursday, observed Monday, is        *\n*   @Memorial Day.                                                    *\n*   @Dr. L. J. Peter, \"Peter's Quotations,\" first edition, P515.      *\n*                                                                     *\n*           A MORE GENERALLY COMPLEX EXAMPLE IS Q850626:              *\n*                                                                     *\n*          \"And I honor the man who is willing to sink                *\n*           Half his present repute for the freedom to think,         *\n*           And, when he has thought, be his cause strong or weak,    *\n*           Will risk t' other half for the freedom to speak.\"        *\n*                                      James Russell Lowell (1848)    *\n*   @From \"A Fable for Critics.\"  Appropriate to the title of the     *\n*   @poem is another stanza:                                          *\n*   @    \"Nature fits all her children with something to do,          *\n*   @     He who would write and can't write, can surely review.\"     *\n*   @John Bartlett, \"Familiar Quotations,\" 15th ed., P567:17,19.      *\n*   #Years before, in 1811, Samuel Coleridge said in a lecture,       *\n*   @\"Reviewers are usually people who would have been poets,         *\n*   @historians, biographers, etc., if they could; they have tried    *\n*   @their talents at one or at the other, and have failed;           *\n*   @therfore they turn critics.\"                                     *\n*   @John Bartlett, \"Familiar Quotations,\" 15th ed., P436:15.         *\n*   #And years later, in 1870, Benjamin Disraeli wrote in chapter     *\n*   @35 of his book, \"Lothair,\" \"You know who the critics are?        *\n*   @The men who have failed in literature and art.\"                  *\n*   @John Bartlett, \"Familiar Quotations,\" 15th ed., P502:12.         *\n*                                                                     *\n*        ASM SYSLIB: SYS1.MACLIB, SYS1.AMODGEN, CBT.MACLIB.ASM.       *\n*        LKED SYSLIB: WUI1.SUBLIB (FOR SUBROUTINE MERKNOW).           *\n*        NOT REENTRANT.                                               *\n*                                                                     *\n*                                  JEFFREY R. BROIDO                  *\n*                                  BROIDO COMPUTER CONSULTING         *\n*                                  104 MILLS STREET                   *\n*                                  MORRISTOWN, NJ  07960              *\n*                                                                     *\n*        WRITTEN IN MARCH, 1982 BY J. R. BROIDO AT AMERICAN           *\n*        INTERNATIONAL GROUP, INC., EAST ORANGE, NJ, REPLACING        *\n*        A CUMBERSOME CLIST DRIVEN PROCESS DESIGNED BY THE            *\n*        AUTHOR AT JOHNSON & JOHNSON, RARITAN, NJ IN 1979.            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nBRODCAST CSECT\n         REGS\n         USING BRODCAST,R15        (ESTABLISH TEMPORARY BASE).\n         B     BEGIN               SKIP OVER HEADER.\nHEAD0    DC    AL1(HEADL)          EXCLUSIVE LENGTH OF HEADER.\nHEAD     DC    C'BRODCAST - &SYSDATE - &SYSTIME -'\n         DC    C'COPYRIGHT (C) BROIDO COMPUTER CONSULTING '\n         DC    C'1982 - '\n         DC    C'ALL RIGHTS RESERVED'\nHEADL    EQU   *-HEAD\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)\n         LR    R12,R15\n         USING BRODCAST,R12\n         LR    R14,R13\n         LA    R13,SAVE\n         ST    R14,SAVE+4\n         ST    R13,8(,R14)\n         SPACE 1\n         L     R1,16               POINT TO CVT.\n         L     R1,0(,R1)           POINT TO TCB-ASCB WORDS.\n         L     R2,8(,R1)           POINT TO MY ASCB.\n         USING ASCB,R2             (TELL ASSEMBLER).\n         LA    R15,8               DEFAULT CC TO 8.\n         CLC   =A(0),ASCBJBNI      IS THIS A TSO USER OR STARTED TASK?\n         BNE   EOJNOF              B IF NOT EITHER.\n         L     R2,0(,R1)           POINT TO TCB.\n         USING TCB,R2              (TELL ASSEMBLER).\n         L     R2,TCBJSCB          POINT TO JSCB.\n         USING IEZJSCB,R2          (TELL ASSEMBLER).\n         ICM   R3,X'F',JSCBPSCB    POINT TO PSCB.\n         USING PSCB,R3             (TELL ASSEMBLER).\n         BZ    CKALLOC             B IF THERE IS NO PSCB.  MUST BE STC.\n         TM    PSCBATR1,PSCBCTRL+PSCBACCT  DOES USER HAVE ...\n*                                  ... OPER AND ACCT PRIVELEGES?\n         BO    CKALLOC             B IF YES.\n         VTPUT 'Sorry, you are not authorized to execute this command.'\n         LA    R15,8               SET CC OF 8.\n         B     EOJNOF              BYE.\n         DROP  R3\nCKALLOC  L     R3,JSCDSABQ         POINT TO QDB FOR DSAB QUEUE.\n         DROP  R2\n         L     R3,12(,R3)          POINT TO FIRST DSAB.\n         LA    R4,DDTAB            POINT TO DD NAME TABLE.\nDDNLOOP  CLI   0(R4),0             END OF TABLE?\n         BE    OPEN                B IF YES.\n         LR    R2,R3               POINT TO FIRST DSAB.\nDSABLOOP LTR   R2,R2               END OF DSAB CHAIN?\n         BE    ALLOC               B IF YES.\n         L     R1,16(,R2)          POINT TO TIOT ENTRY FOR DDNAME.\n         CLC   0(8,R4),4(R1)       DDNAME MATCH MY TABLE?\n         BE    DDNBUMP             B IF YES.  CK NEXT DDN IN TABLE.\n         L     R2,4(,R2)           POINT TO NEXT DSAB.\n         B     DSABLOOP            LOOP THROUGH DSAB QUEUE.\nALLOC    MVC   TU0001L,8(R4)       MOVE LENGTH OF DDNAME TO TU.\n         MVC   DDNAME,0(R4)        MOVE DDNAME.\n         LH    R1,10(,R4)          LOAD LENGTH OF DSNAME.\n         STH   R1,TU0002L          SAVE DSN LENGTH IN TU0002\n         BCTR  R1,*-*              GENERATE SS LENGTH.\n         EX    R1,MVDSN            MOVE DSNAME TO TU0002\n*      ( MVC   DSN(*-*),12(R4)   )\n         LA    R1,S99RBPTR         POINT TO RB FOR DYNALLOC.\n         DYNALLOC                  ALLOCATE DATASET.\n         LTR   R15,R15             ALLOCATE OK?\n         BNZ   ALLOCFA             B IF NOT.\nDDNBUMP  LH    R1,10(,R4)          POINT TO ...\n         LA    R4,12(R1,R4)        ... NEXT DD TABLE ENTRY.\n         B     DDNLOOP             CHECK NEXT ENTRY IN DD TABLE.\nALLOCFA  ST    R15,D99RET          SAVE DYNALLOC RETURN CODE.\n         LA    R1,DFPARM           POINT TO DAIRFAIL PARMS.\n         LINK  EP=IKJEFF18         ISSUE DAIRFAIL MESSAGE.\n         LA    15,8                LOAD CC OF 8.\n         B     EOJNOF              EXIT\nOPEN     OPEN  (SYSLBC,UPDAT,QUOTE)\n         LA    R15,8               PRE-LOAD CC OF 8.\n         TM    SYSLBC+48,X'10'     BRODCAST DATASET OPEN OK?\n         BZ    EOJNOF              B IF NOT.\n         TM    QUOTE+48,X'10'      QUOTE DATASET OPEN OK?\n         BZ    EOJNOF              B IF NOT.\n         LH    R2,QUOTE+X'3E'      LOAD BLOCKSIZE.\n         GETMAIN RU,LV=(R2)        GET QUOTE DS BUFFER STORAGE.\n         ST    R1,QBHEAD           SAVE BUFFER POINTER.\n         L     R1,X'10'            POINT TO CVT.\n         USING CVT,R1              (TELL ASSEMBLER).\n         ICM   R1,X'F',CVTSMCA     POINT TO SMCA.\n         USING SMCABASE,R1         (TELL ASSEMBLER).\n         BZ    EOJ8                B IF SMF NOT PRESENT.\n         MVC   SMFID,SMCASID       MOVE SMF ID\n         DROP  R1\n         FIND  QUOTE,MEMNAME,D     FIND MEMBER \"HEADSSSS\" WHERE ...\n*                                  ... SSSS IS SMF ID.\n         LTR   R15,R15             HEADER FOUND?\n         BNZ   EOJ8                B IF NOT.\n         LA    R10,QEHEAD          POINT TO FIRST EOD ROUTINE ADDRESS.\nQNEBH    ENQ   (QNAME,BLOCK#,E,3,SYSTEM),RET=HAVE ENQ B'CST HEADER.\n         LTR   R3,R15              ENQ OK?\n         BZ    READBH              B IF YES.\n         VWTPU 'LOGIC ERROR ENQ''ING BROADCAST HEADER.'\n         LR    R15,R3              RESTORE CC.\n         B     EOJ                 BYE.\nREADBH   ON    HENQFG              TURN ON HEADER ENQUEUE FLAG.\n         BAL   R14,BREAD           READ BRODCAST HEADER.\n         MVC   BRRN0,BDATA         SAVE HEADER.\n         MVC   SYSLBC+82(2),BRRN0+10  MOVE NUMBER OF RECS. IN BRODCAST\n*                                  ... DATASET TO LIMCT IN DCB.\n         XC    BRRN0+123(6),BRRN0+123 CLEAR QUOTE 1ST + LAST LINE PTRS.\n         ICM   R3,7,BRRN0+120      LOAD POINTER TO FIRST EXTENDED ...\n*                                  ... QUOTE (KEY C'Q') RECORD.\n         BZ    READDIR0            B IF THERE ARE NONE.\n         XC    BRRN0+120(3),BRRN0+120 ZERO POINTER TO 'Q' RECORDS.\nFQLOOP   STCM  R3,7,BLOCK#         SAVE BLOCK #.\n         ENQ   (QNAME,BLOCK#,E,3,SYSTEM),RET=HAVE  ENQ ON 'Q' BLOCK.\n         BAL   R14,BREAD           READ 'Q' BLOCK.\n         CLI   KEY,C'Q'            IS THE KEY A PROPER 'Q'?\n         BE    FQKEYOK             B IF YES.\nFQERR    DEQ   (QNAME,BLOCK#,3,SYSTEM)   DEQUEUE RECORD.\n         VWTPU 'ERROR IN EXTENDED (''Q'') QUOTE RECORD CHAIN.'\n         B     READDIR0            CONTINUE.\nFQKEYOK  MVI   KEY,X'FF'           CHANGE KEY TO MAKE THIS A FREE REC.\n         L     R1,BDECB+16         POINT TO IOB.\n         MVC   BDATA(1),39(R1)     MOVE RECORD NUMBER FROM IOB TO REC.\n         SR    R3,R3               CLEAR INSERT REG.\n         ICM   R3,7,BDATA+126      LOAD POINTER TO NEXT RECORD\n         XC    BDATA+126(3),BDATA+126  ZERO CHAIN FIELD.\n         BAL   R14,BWRITE          RE-WRITE RECORD.\n         DEQ   (QNAME,BLOCK#,3,SYSTEM)   DEQUEUE RECORD.\n         LTR   R3,R3               IS THERE ANOTHER 'Q' IN CHAIN?\n         BNZ   FQLOOP              B IF YES.\nREADDIR0 MVC   BLOCK#,BRRN0+1      MOVE RRN OF FIRST NOTICE DIR BLK.\nREADDIR  BAL   R14,BREAD           READ NOTICE DIRECTORY BLOCK.\n         MVC   DIRBLK,BDATA        MOVE DIRECTORY BLOCK.\n         MVC   DIRBLK#,BLOCK#      SAVE CURRENT RRN.\n         LM    R3,R5,DIRBXP        LOAD BXLE REGISTERS.\nDIRLOOP  OI    0(R3),X'80'         DEFAULT NOTICE TO INACTIVE.\n         BO    QLEN0               B IF YES.  GO WRITE BLANK REC.\n         TF    EODQFG              ANY MORE QUOTE DS LINES TO READ?\n         BO    DIRBUMP             BUMP INDEX AND LOOP.\n         MVC   BLOCK#,2(R3)        MOVE RRN OF THIS POINTER'S NOTICE.\n         MVI   BDATA,X'00'         CLEAR...\n         MVC   BDATA+1(128),BDATA  ... DATA AREA.\nQREC     BAL   R14,GETQ            GET A QUOTE RECORD.\n         LR    R9,R1               PRESERVE LREC POINTER.\n         LH    R1,0(,R9)           LOAD LENGTH OF RECORD.\n         LTR   R1,R1               DATA LENGTH 0?\n         BNZ   QHLENOK0            B IF NOT.\nQLEN0    MVC   BDATA(3),=X'014000'   CONSTRUCT AN ...\n         MVC   BDATA+3(126),BDATA+2  ... EMPTY LINE.\n         B     WRTNOT              GO WRITE THE BLANK LINE.\nQHLENOK0 SH    R1,=H'12'           SUBTRACT LENGTH OF RDW AND LINE #.\n         BNP   QLEN0               B IF NO DATA BEYOND LINE #.\n         CH    R1,=H'68'           LENGTH OVER 67?\n         BNH   QHLENOK1            B IF NOT.\n         LA    R1,68               TRUNCATE LENGTH TO 67.\nQHLENOK1 CH    R1,=H'2'            LENGTH AT LEAST 2?\n         BL    QHLENOK2            B IF NOT.\n         CH    R1,=H'7'            LENGTH AT LEAST 7?\n         BL    CKGROOT             B IF NOT.\n         MVC   WORK(7),12(R9)      MOVE FIRST 7 CHARS OF REC.\n         OC    WORK+2(5),=CL5' '   UPPERCASE.\n         CLC   =C'/*VITAL',WORK    IS THIS A VITAL MESSAGE?\n         BNE   CKGROOT             B IF NOT.\n         ON    VITALFG             TURN ON VITAL FLAG.\n         B     QREC                READ ANOTHER RECORD.\nCKGROOT  CLC   =C'/*',12(R9)       GROOT?\n         BE    QREC                B IF A GROOT.  IGNORE.\nQHLENOK2 STC   R1,BDATA            SAVE LENGTH IN OUTPUT RECORD.\n         BCTR  R1,*-*              GENERATE SS LENGTH.\n         EX    R1,MOVEQ            MOVE NOTICE LINE.\n         CLI   12(R9),C'@'         EXTENDED MSG?\n         BE    WRTXMSG             B IF YES.\n         CLI   12(R9),C'='         ALTERNATE EXTENDED MSG?\n         BE    WRTXMSG             B IF YES.\n         CLI   12(R9),C'#'         \"MORE\" FLAG?\n         BE    WRTXMSG             B IF YES.\nWRTNOT   NI    0(R3),X'7F'         ACTIVATE THIS NOTICE.\n         MVC   BLOCK#,2(R3)        MOVE CURRENT BLOCK #.\n         MVI   KEY,X'02'           MAKE RECORD TYPE \"NOTICE\"\n         BAL   R14,BWRITE          WRITE A NOTICE RECORD.\n         TF    QFG                 DID WE JUST WRITE A Q-O-T-D REC?\n         BZ    DIRBUMP             B IF NOT.\n         MVC   BRRN0+126(3),2(R3)  MOVE ITS RRN TO HEADER IN CASE ...\n         B     DIRBUMP             ... IT IS THE LAST Q-O-T-D REC.\nWRTXMSG  MVC   BDATA1,BDATA        PRESERVE 'Q' REC. TO BE WRITTEN.\nWRTXMSG1 MVI   KEY,X'FF'           SET KEY TO SEARCH FOR BLANK REC.\n         READ  B2DECB,DKF,MF=E     SEARCH FOR FREE RECORD.\n         CHECK B2DECB              WAIT FOR I/O TO COMPLETE.\n         TF    PEFG                PERMANENT ERROR?\n         BZ    CKXSF               B IF NOT.\n         LA    R15,16              SET CC OF 16.\n         OFF   PEFG                TURN OFF PERM ERROR FLAG.\n         B     EOJ                 EXIT.\nCKXSF    TF    SFFG                SEARCH FOR KEY X'FF' A SUCCESS?\n         BZ    ENQX                B IF YES.\n         VWTPU 'BRODCAST DATASET HAS NO FREE RECORDS LEFT.'\n         LA    R15,16              SET CC OF 16\n         B     EOJ                 EXIT.\nENQX     ENQ   (QNAME,BLOCK#,E,3,SYSTEM),RET=HAVE ENQUEUE ON RECORD.\n         BAL   R14,BREAD           RE-READ RECORD\n         CLI   KEY,X'FF'           RECORD STILL FREE?\n         BE    WRTXREC             B IF YES.\n         DEQ   (QNAME,BLOCK#,3,SYSTEM)  DEQUEUE RECORD.\n         B     WRTXMSG1            GO TRY ANOTHER RECORD.\nWRTXREC  MVC   BDATA,BDATA1        MOVE RECORD TO OUTPUT AREA.\n         XC    BDATA+126(3),BDATA+126  ZERO CHAIN FIELD.\n         MVI   KEY,C'Q'            SET KEY TO \"Q\".\n         BAL   R14,BWRITE          WRITE RECORD.\n         DEQ   (QNAME,BLOCK#,3,SYSTEM)  DEQUEUE RECORD.\n         ICM   R7,7,CHAIN#         LOAD LAST 'Q' REC. BLOCK #.\n         BNZ   WRTXREC1            B IF NOT FIRST 'Q' REC.\n         MVC   BRRN0+120(3),BLOCK# SAVE IN HEADER AS START-OF-CHAIN.\n         MVC   CHAIN#,BLOCK#       SAVE IN LAST 'Q' REC POINTER.\n         B     QREC                GET ANOTHER QUOTE MEMBER REC.\nWRTXREC1 MVC   CHAIN#,BLOCK#       SAVE CURRENT BLOCK # AS LAST.\n         STCM  R7,7,BLOCK#         READ LAST ...\n         BAL   R14,BREAD           ... 'Q' RECORD.\n         CLI   KEY,C'Q'            IS IT REALLY A 'Q' REC?\n         BE    CKXCHN              B IF YES.\nWRTXERR  VWTPU 'ERROR CHAINING \"Q\" RECORDS.'\n         LA    R15,16              SET CC OF 16.\n         B     EOJ                 EXIT.\nCKXCHN   CLC   =XL3'00',BDATA+126  WAS LAST RECORD ON END OF CHAIN?\n         BNE   WRTXERR             B IF NOT.\nWRTXREC2 MVC   BDATA+126(3),CHAIN# CHAIN 'Q' RECORD TO CURRENT.\n         BAL   R14,BWRITE          RE-WRITE IT.\n         B     QREC                GET ANOTHER QUOTE MEMBER REC.\n         SPACE 1\n*        EOD FOR QUOTE DS HEADER MEMBER.\n         SPACE 1\n*QEHEAD  NOW   MDY,SNOTIME         FORMAT TODAY'S DATE.\n         SPACE 1\n* FOLLOWING IS SUBSTITUTE FOR NOW MACRO EXPANSION.\n         SPACE 1\nQEHEAD   LA    R1,MDY              POINT TO OUTPUT AREA.\n         LA    R0,12               FORMAT: SLASH, NOTIME.\n         L     R15,=V(MERKNOW)     POINT TO NOW ROUTINE.\n         BALR  R14,R15             GO FORMAT DATE.\n         SPACE 1\n* PRECEDING IS SUBSTITUTE FOR NOW MACRO EXPANSION.\n         SPACE 1\n         CLI   MDY,C' '            MONTH NUMBER NEED PADDING?\n         BNE   MNOPAD              B IF NOT.\n         MVI   MDY,C'0'            MOVE \"0\" OVER BLANK IN MONTH.\nMNOPAD   MVC   MEMNAME,=CL8'Q'     BUILD DATE DERIVED MEMBER ...\n         MVC   MEMNAME+1(2),MDY+6  ... NAME OF ...\n         MVC   MEMNAME+3(2),MDY    ... QUOTE OF ...\n         MVC   MEMNAME+5(2),MDY+3  ... THE DAY.\n         FIND  QUOTE,MEMNAME,D     FIND MEMBER \"QYYMMDD\".\n         LTR   R15,R15             HAVE WE A QUOTE FOR TODAY?\n         BNZ   DIRBUMP             NO.  CONTINUE FORMATING INDEX.\n         MVC   BRRN0+123(3),2(R3)  MOVE RRN OF FIRST NORMAL QUOTE REC.\n         OFF   EODQFG              TURN OFF EOD-HIT FLAG.\n         ON    QFG                 TURN ON Q-O-T-D MEMBER FLAG.\n         LA    R10,QEQUOTE         POINT TO NEW EOD ADDRESS.\n         B     DIRLOOP             GO GET Q-O-T-D.\n         SPACE 1\n*        EOD FOR QUOTE DS Q-O-T-D MEMBER.\n         SPACE 1\nQEQUOTE  ON    EODQFG              TURN ON EOD-HIT FLAG.\n         OFF   QFG                 TURN OFF Q-O-T-D IN PROCESS FLAG.\n         B     QLEN0               GO WRITE BLANK LINE.\nDIRBUMP  BXLE  R3,R4,DIRLOOP       BUMP POINTER AND LOOP.\n         MVC   BLOCK#,DIRBLK#      SET BLOCK # TO LAST DIR BLK READ.\n         MVC   BDATA,DIRBLK        MOVE DIR BLOCK TO OUTPUT AREA.\n         MVI   KEY,X'00'           MAKE RECORD TYPE \"NOTICE DIR\".\n         BAL   R14,BWRITE          OUTPUT NOTICE DIR BLK.\n         SR    R15,R15             DEFAULT CC OF 0.\n         CLC   =XL3'00',DIRBLK+126 THIS THE LAST BLOCK?\n         BE    EOJ                 B IF YES.\n         MVC   BLOCK#,DIRBLK+126   MOVE RRN OF NEXT DIR. BLK.\n         B     READDIR             READ NEXT BLOCK.\nEOJ8     LA    R15,8               SET CC OF 8.\nEOJ      STH   R15,CC              SAVE CC.\n         AIF   ('&TSO' NE 'E').NOTSOE\n*\n*        THE FOLLOWING CODE STICKS A BLANK LINE ON THE END VIA SEND\n*        OF THE NOTICES TO FORCE TSO/E TO READ THE NOTICES\n*        INTO CORE.  TAKE THE CODE OUT WHEN YOU FIGURE OUT\n*        THE APPROPRIATE SYSEVENT.\n*\n*        AT THAT TIME, REMOVE THE AC(1).\n*\n         MODESET KEY=ZERO\n         L     R0,=A(X'00008000')  SET SUPER-WHOOPEE AUTHORITY.\n         LA    R1,CMD0             POINT TO SEND COMMAND.\n         SVC   34                  SEND COMMAND\n         MODESET KEY=NZERO\n*\n*\n.NOTSOE  TF    HENQFG              MUST WE WRITE & DEQUEUE HEADER?\n         BZ    FREEBUF             B IF NOT.\n         MVC   BDATA,BRRN0         MOVE R0 TO OUTPUT AREA.\n         XC    BLOCK#,BLOCK#       SET BLOCK NUMBER TO 0.\n         MVI   KEY,X'04'           MAKE RECORD TYPE \"HEADER\"\n         BAL   R14,BWRITE          RE-WRITE HEADER.\n         DEQ   (QNAME,BLOCK#,3,SYSTEM)   DEQUEUE HEADER RECORD.\n         OFF   HENQFG              TURN OFF FLAG.\nFREEBUF  L     R3,QBHEAD           POINT TO GETMAINED AREA.\n         LH    R2,QUOTE+X'3E'      LOAD BLOCKSIZE.\n         FREEMAIN RU,LV=(R2),A=(R3)  FREE BUFFER STORAGE.\n         TM    SYSLBC+48,X'10'     SYSLBC STILL OPEN?\n         BZ    EOJ1                B IF NOT.\n         CLOSE (SYSLBC)\nEOJ1     TM    QUOTE+48,X'10'      QUOTE STILL OPEN?\n         BZ    EOJ2                B IF NOT.\n         CLOSE (QUOTE)\nEOJ2     EQU   *\n         AIF   (NOT &VITAL).NOVITAL\n         L     R3,16               POINT TO CVT.\n         LA    R3,X'CC'(,R3)       POINT TO CVTUSER.\n         TM    0(R3),X'40'         IS THE CVTUSER VITAL MSG FLAG ON?\n         BZ    EOJ3                B IF NOT.\n         TF    VITALFG             IS IT SUPPOSED TO BE ON?\n         BO    EOJ4                B IF YES.  LEAVE IT ON.\n         MODESET KEY=ZERO\n         NI    0(R3),255-X'40'     TURN OFF VITAL MSG BIT.\n         MODESET KEY=NZERO\n         B     EOJ4                CONTINUE\nEOJ3     TF    VITALFG             CVT BIT OFF.  SUPPOSED TO BE ON?\n         BZ    EOJ4                B IF NOT.\n         MODESET KEY=ZERO\n         OI    0(R3),X'40'         TURN ON VITAL MSG BIT.\n         MODESET KEY=NZERO\n.NOVITAL ANOP\nEOJ4     LH    R15,CC              RE-LOAD CC.\nEOJNOF   LTR   R8,R15              CC 0?\n         BZ    EOJNOF1             B IF YES.\n         VWTPU 'WARNING: BRODCAST DATASET NOT LOADED.'\n         LR    R15,R8              RE-LOAD CC.\nEOJNOF1  L     R13,SAVE+4\n         LM    R0,R12,20(R13)\n         L     R14,12(,R13)\n         BR    R14\n         TITLE 'BRODCAST - BRODCAST DATASET READ AND WRITE ROUTINES.'\nBREAD    ST    R14,SAVE            SAVE RETURN ADDR.\n         READ  BDECB,DI,MF=E       READ A BRODCAST RECORD.\n         CHECK BDECB               WAIT FOR IO COMPLETION.\n         LA    R15,16              PRE-SET CC OF 16\n         TF    PEFG                PERM ERROR?\n         BO    EOJNOF              B IF YES.\n         L     R14,SAVE            RE-LOAD RETURN ADDR.\n         BR    R14                 RETURN.\n         SPACE 1\nBWRITE   ST    R14,SAVE            SAVE RETURN ADDR.\n         WRITE BDECB,DI,MF=E       WRITE A BRODCAST RECORD.\n         CHECK BDECB               WAIT FOR IO COMPLETION.\n         LA    R15,16              PRE-SET CC OF 16\n         TF    PEFG                PERM ERROR?\n         BO    EOJNOF              B IF YES.\n         L     R14,SAVE            RE-LOAD RETURN ADDR.\n         BR    R14                 RETURN.\n         SPACE 1\n         TITLE 'BRODCAST - GETQ SUBROUTINE (PSEUDO QSAM FOR QUOTE DATAS+\n               T).'\nGETQ     STM   R14,R12,12(R13)\n         LR    R14,R13\n         LA    R13,SAVE1\n         ST    R14,4(,R13)\n         ST    R13,8(,R14)\n         L     R9,QBHEAD           POINT TO DATA IO AREA.\n         ICM   R8,15,QRPTR         POINT TO LREC.\n         BZ    GETQREAD            B IF POINTER ZERO (INITIAL READ).\n         LH    R2,0(,R9)           LOAD LENGTH OF BLOCK.\n         AR    R2,R9               POINT TO LAST BYTE+1.\n         LH    R1,0(,R8)           LOAD LAST LRECL.\n         AR    R1,R8               POINT TO NEXT LRECL.\n         CR    R1,R2               PAST THE END OF THE BLOCK?\n         BNL   GETQREAD            B IF YES.\n         ST    R1,QRPTR            SAVE POINTER.\n         B     GETQRET             RETURN.\nGETQREAD XC    QRPTR,QRPTR         CLEAR NEXT REC PTR IN CASE EOD.\n         READ  QDECB,SF,,(R9),MF=E READ A QUOTE DS RECORD.\n         CHECK QDECB               WAIT FOR IO TO COMPLETE.\n         LA    R1,4(,R9)           POINT TO FIRST LREC.\n         ST    R1,QRPTR            SAVE POINTER.\nGETQRET  L     R13,SAVE1+4\n         LM    R2,R12,28(R13)\n         L     R14,12(,R13)\n         BR    R14\nEODQUOTE ON    EODQFG              TURN ON QUOTE-AT-EOD FLAG.\n         L     R13,SAVE1+4\n         LM    R0,R12,20(R13)\n         L     R14,12(,R13)\n         BR    R10                 RETURN TO APPROPRIATE EOD ADDR.\n         SPACE 1\nBSYNAD   LR    R2,R0               POINT TO DECB.\n         TM    1(R2),X'80'         ERROR BECAUSE RECORD NOT FOUND?\n         BZ    SYNAD1              B IF THAT ISN'T IT.\n         ON    SFFG                TURN ON SEARCH-FAILED FLAG.\n         BR    R14                 RETURN\nSYNAD1   SYNADAF ACSMETH=BDAM\n         STM   R14,R12,12(R13)\n         LR    R14,R13\n         LA    R13,SAVE2\n         ST    R14,4(,R13)\n         ST    R13,8(,R14)\n         ON    PEFG                TURN ON PERMANENT ERROR FLAG.\n         LH    R0,0(,R1)           LOAD LENGTH OF SYNADAF MSG.\n         SH    R0,=H'4'            SUBTRACT LEN OF PSEUDO RDW.\n         LA    R1,4(,R1)           POINT TO SYNADAF MSG.\n         TPUT  (1),(0)             OUTPUT ERROR MSG.\n         L     R13,SAVE2+4\n         LM    R14,R12,12(R13)\n         SYNADRLS                  FREE SYSTEM SA AND MESSAGE AREA.\n         BR    R14                 RETURN TO SYSTEM.\n         TITLE 'STATIC DATA AREA.'\nSAVE     DS    9D                  SAVE AREA.\nSAVE1    DS    9D                  SAVE AREA FOR GETQ ROUTINE.\nSAVE2    DS    9D                  SAVE AREA FOR SYNAD EXIT.\nWORK     DS    D                   WORK AREA.\nQBHEAD   DS    A                   QUOTE DS BUFFER POINTER.\nQRPTR    DC    A(0)                QUOTE DS LREC POINTER.\n         SPACE 1\nCMD0     DC    AL2(CLEN,0)         COMMAND HEADER.\nCMD      DC    C'SE '' '',SAVE'    COMMAND.\nCLEN     EQU   *-CMD0              COMMAND LENGTH.\n         SPACE 1\nCVTFLAG  DS    X                   IMAGE OF FIRST CVTUSER BYTE.\nCC       DS    H                   COND. CODE SAVE AREA.\nMDY      DS    CL8                 RETURN AREA FOR NOW SUBROUTINE.\nMOVEQ    MVC   BDATA+1(*-*),12(R9) ** EXECUTED **\n         SPACE 1\nEODQFG   EQU   *,B'10000000'       QUOTE MEMBER REACHED EOD.\nHENQFG   EQU   *,B'01000000'       HEADER ENQ'D FLAG.\nQFG      EQU   *,B'00100000'       READING Q-O-T-D MEMBER.\nPEFG     EQU   *,B'00010000'       PERMANENT ERROR ON BRODCAST DS.\nSFFG     EQU   *,B'00001000'       SEARCH FAILED FLAG.\n$TSO     EQU     B'00000100'       TSO FLAG FOR VWTPU MACRO.\nVITALFG  EQU   *,B'00000010'       VITAL MESSAGE FLAG.\nFLAG     DC    X'00'               VARIOUS FLAGS.\n         SPACE 1\nKEY      DS    X                   KEY OF RECORD.\nBDATA    DS    CL129               BRODCAST I/O AREA.\nBDATA1   DS    CL129               ALTERNATE I/O AREA.\nBRRN0    DS    CL129               BRODCAST HEADER (RRN 0).\nDIRBLK   DS    CL129               CURRENT DIRECTORY BLOCK.\nDIRBLK#  DS    AL3(0)              CURRENT DIRECTORY BLOCK RRN.\nQNAME    DC    CL8'SYSIKJBC'       QNAME FOR BRODCAST RECORDS (RNAME\n*                                  IS 3 BYTE RRN).\nMEMNAME  DC    CL8'HEAD'           NAME OF HEADER MEMBER IN QUOTE DS.\n         ORG   MEMNAME+4\nSMFID    DS    CL4                 SMFID OF SYSTEM.\n         ORG\n         SPACE 1\nDIRBXP   DC    A(DIRBLK)           DIRECTORY BXLE PARMS.\n         DC    F'5'                DIRECTORY POINTER LEN.\n         DC    A(DIRBLK+124)       ADDRESS PAST LAST POINTER.\n         SPACE 1\nDDTAB    DC    CL8'SYSLBC'         TABLE OF DATASET NAMES FOR DYNALLOC.\n         DC    AL2(6)              LENGTH OF DDNAME.\n         DC    AL2(L'DSN1)         LENGTH OF DSNAME.\nDSN1     DC    C'SYS1.BRODCAST'    DSNAME\n         DC    CL8'QUOTE'          DDNAME\n         DC    AL2(5)              LENGTH OF DDNAME.\n         DC    AL2(L'DSN2)         LENGTH OF DSNAME.\nDSN2     DC    C'&QUOTE'           DSNAME.\n         DC    X'00'               END OF TABLE.\n         SPACE 1\nDFPARM   DC    A(S99RB)            DAIRFAIL PARMS.\nDFRCP    DC    A(D99RET)           DYNALLOC RETURN CODE.\n         DC    A(DFKRUD)           ADDRESS OF A FULLWORD OF ZEROS.\n         DC    A(DFIDP)            ADDRESS OF OPTIONS\nDFCPPLP  DC    A(0)                POINTER TO CPPL (UNUSED).\nDFKRUD   DC    A(0)                UNUSED.\nD99RET   DC    A(0)                RETURN CODE.\nDFIDP    DC    X'8032'             SAY DO WTP, PROBLEM IN SVC99.\n         SPACE 1\nS99RBPTR DS    0A                  DYNALLOC RB POINTER\n         DC    X'80',AL3(S99RB)\n         SPACE 1\nS99RB    DC    AL1(20,1,0,0)       LENGTH, VERB, FLAGS.\n         DC    AL2(0,0)            ERROR, INFO RETURN CODES.\nS99TU    DC    A(TUPS)             TU POINTER POINTER.\n         DC    A(0)                RESERVED.\n         DC    A(0)                UNUSED FLAGS.\n         SPACE 1\nTUPS     DS    0A                  TU POINTERS.\n         DC    A(TU0001)           POINTER TO DDNAME TU.\n         DC    A(TU0002)           POINTER TO DSNAME TU.\n         DC    X'80',AL3(TU0004)   POINTER TO STATUS TU.\n         SPACE 1\nTU0001   DC    AL2(1,1)            DDNAME TU.\nTU0001L  DC    AL2(0)\nDDNAME   DC    CL8'XXXXXXXX'\nTU0002   DC    AL2(2,1)            DSNAME TU.\nTU0002L  DC    AL2(0)\nDSN      DC    44C'X'\nTU0004   DC    AL2(4,1,1),X'08'    STATUS TU (DISP=SHR).\n         SPACE 1\nMVDSN    MVC   DSN(*-*),12(R4)     ** EXECUTED **\nBLOCK#   DC    AL3(0)              CURRENT RELATIVE BLOCK NUMBER.\nCHAIN#   DC    AL3(0)              REL BLOCK NUMBER OF LAST 'Q' REC.\n         READ  BDECB,DI,SYSLBC,BDATA,'S',KEY,BLOCK#,MF=L BRDCST DECB 1.\n         READ  B2DECB,DKF,SYSLBC,BDATA,'S',KEY,BLOCK#,MF=L \"    \"    2.\n         READ  QDECB,SF,QUOTE,,'S',MF=L                QUOTE DECB.\n         PRINT NOGEN\nSYSLBC   DCB   DDNAME=SYSLBC,KEYLEN=1,RECFM=F,BLKSIZE=129,DSORG=DA,    +\n               MACRF=(RIKC,WIC),OPTCD=REF,SYNAD=BSYNAD\nQUOTE    DCB   DDNAME=QUOTE,RECFM=VB,LRECL=92,DSORG=PO,MACRF=R,        +\n               EODAD=EODQUOTE\n         TITLE 'MAPPING MACRO DSECTS.'\n         IHAASCB\n         IKJTCB\n         IKJPSCB\n         IEZJSCB\n         CVT   DSECT=YES\n         IEESMCA\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHECKDD": {"ttr": 2054, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00C\\x00\\x85\\x18/\\x01\\x13\\x13/\\x15\\x08\\x00\\x88\\x00\\x89\\x00)\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "2013-05-12T15:08:43", "lines": 136, "newlines": 137, "modlines": 41, "user": "BROIDO"}, "text": "CHECKDD  TITLE 'CHECKDD - CLIST UTILITY TO CHECK FOR LIST OF ALLOCATED +\n               FILENAMES.'\n*%A PPLINK NOTEST\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  COPYRIGHT (C) 1979 BY BROIDO COMPUTER CONSULTING.  ALL RIGHTS      *\n*  RESERVED EXCEPT:                                                   *\n*                                                                     *\n*  PARTICULAR LICENSE IS GRANTED TO DISTRIBUTE THIS PROGRAM FREE      *\n*  OF CHARGE, BUT IT MUST NOT BE SOLD.  A SERVICE CHARGE FOR          *\n*  HANDLING A COLLECTION OF SOFTWARE OF WHICH THIS IS A PART,         *\n*  ON THE OTHER HAND, IS APPROPRIATE.                                 *\n*                                                                     *\n*                                  BROIDO COMPUTER CONSULTING         *\n*                                  broidoj@gmail.com                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  CLIST UTILITY TO CHECK FOR ALLOCATION OF LIST OF FILE NAMES.       *\n*                                                                     *\n*    CHECKDD ...ddname list...                                        *\n*                                                                     *\n*      If all the DDNAMEs in the list are presently allocated, the    *\n*      command will return a condition code of 0 (&LASTCC=0).   If    *\n*      any of the DDNAMEs are missing,  it will return a condition    *\n*      code of 4 (&lastcc=4).                                         *\n*                                                                     *\n*                                  JEFFREY R. BROIDO                  *\n*                                  J & J, MIC                         *\n*                                  1979                               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nCHECKDD  CSECT\n         REGS\n         USING CHECKDD,R15         (ESTABLISH TEMPORARY BASE).\n         B     BEGIN               SKIP OVER HEADER.\nHEAD0    DC    AL1(HEADL)          EXCLUSIVE LENGTH OF HEADER.\nHEAD     DC    C'CHECKDD - &SYSDATE - &SYSTIME -'\n         DC    C'COPYRIGHT (C) BROIDO COMPUTER CONSULTING '\n         DC    C'1979 - '\n         DC    C'ALL RIGHTS RESERVED'\nHEADL    EQU   *-HEAD\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)\n         USING CHECKDD,R12\n         USING CPPL,R3\n         USING DDDSECT,R5\n         LR    R12,R15\n         LA    R2,SAVE\n         ST    R2,8(,R13)\n         ST    R13,SAVE+4\n         LR    R13,R2\n         SPACE 1\n         LR    R3,R1               SAVE CPPL PTR.\n         L     R1,0(,R1)           POINT TO COMMAND BUFFER.\n         ST    R1,PPLCBUF          SAVE IT IN PPL.\n         LTR   R1,R1               IS POINTER 0?\n         BZ    NOTCMD              B IF YES.  NOT A COMMAND.  ERROR.\n         LH    R2,0(,R1)           LOAD LENGTH.\n         CH    R2,=H'4'            IS LENGTH IMPOSSIBLE?\n         BZ    NOTCMD              B IF YES.  NOT A COMMAND.  ERROR.\n         CLI   2(R1),X'00'         PROPER OFFSET?\n         BE    ISCMD               B IF YES.  OK.\nNOTCMD   VTPUT 'CHECKDD MUST BE EXECUTED AS A COMMAND.'\nEXIT8    LA    R15,8               LOAD CC OF 8.\n         B     EXIT1               CONTINUE.\nEXIT     LR    R9,R15\n         IKJRLSA ANSPLACE          FREEMAIN CORE.\n         LR    R15,R9\nEXIT1    L     R13,SAVE+4\n         LM    R0,R12,20(R13)\n         L     R14,12(,R13)\n         BR    R14\n         SPACE 1\nISCMD    MVC   PPLUPT,CPPLUPT      MOVE UPT POINTER.\n         MVC   PPLECT,CPPLECT      MOVE ECT POINTER.\n         LA    R1,PPL              POINT TO PPL.\n         LINK  EP=IKJPARS          PARSE INPUT.\n         L     R5,ANSPLACE         POINT TO ANSWER PLACE.\n         LA    R2,DDNAMES          POINT TO DDNAMES.\n         L     R4,16               POINT TO CVT.\n         L     R4,0(,R4)           POINT TO TCB WORDS.\n         L     R4,0(,R4)           POINT TO TCB.\n         L     R4,12(,R4)          POINT TO TIOT.\n         LA    R4,24(,R4)          POINT TO FIRST DD ENTRY.\n         SR    R10,R10             CLEAR WORK REG.\nDDMAJLUP TM    6(R2),X'80'         PARM PRESENT?\n         BZ    MAJBUMP             B IF NOT.\n         L     R6,0(,R2)           POINT TO DDNAME TO BE FOUND.\n         LH    R1,4(,R2)           LOAD LENGTH OF THIS DDNAME.\n         BCTR  R1,*-*              CREATE SS LENGTH.\n         MVC   DDAREA,=CL8' '      CLEAR DDNAME AREA.\n         EX    R1,DDNMOVE          MOVE DDNAME.\n         LR    R7,R4               POINT TO FIRST TIOT DD ENTRY.\nDDMINLUP IC    R10,0(,R7)          LOAD ENTRY LENGTH.\n         LTR   R10,R10             END OF TIOT?\n         BNZ   DDPOS               B IF NOT.\n         LA    R15,4               SET CC OF 4.  A DDNAME NOT FOUND.\n         B     EXIT                BYE.\nDDPOS    CLC   DDAREA,4(R7)        COMPARE DDNAME.\n         BE    MAJBUMP             B IF EQUAL.  FOUND THIS ONE.\n         LA    R7,0(R10,R7)        POINT TO NEXT DD ENTRY IN TIOT.\n         B     DDMINLUP            LOOP THROUGH TIOT.\nMAJBUMP  L     R2,8(,R2)           POINT TO NEXT PARSE LIST ENTRY.\n         LA    R2,0(,R2)           CLEAR HIGH BYTE.\n         LTR   R2,R2               ANY MORE LIST ENTRIES?\n         BNZ   DDMAJLUP            B IF YES.\n         SR    R15,R15             CLEAR CC.  FOUND ALL DDNAMES.\n         B     EXIT                BYE.\n         SPACE 3\nSAVE     DS    9D\nDDNMOVE  MVC   DDAREA(*-*),0(R6)   EXECUTED.\nDDAREA   DS    CL8                 DDNAME AREA FOR COMPARES.\nPPL      DS    0A                  PARSE PARM LIST.\nPPLUPT   DC    A(0)\nPPLECT   DC    A(0)\nPPLECB   DC    A(CPECB)\nPPLPCL   DC    A(DDPCL)\nPPLANS   DC    A(ANSPLACE)\nPPLCBUF  DC    A(0)\nPPLUWA   DC    A(0)\n         SPACE 1\nCPECB    DC    A(0)                ECB FOR PARSE.\nANSPLACE DC    A(0)                PARSE ANSWER PLACE\n         PRINT NOGEN\nDDPCL    IKJPARM DSECT=DDDSECT\nDDNAMES  IKJIDENT 'DDNAME',LIST,MAXLNTH=8,OTHER=ALPHANUM,              X\n               PROMPT='DDNAME LIST +',HELP='LIST OF DDNAMES YOU WISH TOX\n                CHECK.'\n         IKJENDP\n         IKJCPPL\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CKC": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x1d\\x00\\x19\\x00y\\x05\\x7f\\x01\\x14 ?\"\"\\x02\\x15\\x00H\\x02\\x05\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "00.29", "flags": 0, "createdate": "1979-02-26T00:00:00", "modifydate": "2014-07-22T22:22:19", "lines": 533, "newlines": 72, "modlines": 517, "user": "SBGOLOB"}, "text": "CKC      TITLE 'TSO COMMAND TO REPORT ON REGION REMAINING.'\n*%A SERV AC(1) NOTEST ALIGN\n***********************************************************************\n*                                                                     *\n*  COPYRIGHT (C) 1977 BY JEFFREY R. BROIDO.  ALL RIGHTS RESERVED.     *\n*                                                                     *\n*  LICENSE IS HEREBY GRANTED TO PERSHING SYSTEMS, INCORPORATED        *\n*  NEW YORK, NEW YORK AND ITS AFFILIATES TO USE THIS PROGRAM.         *\n*  HOWEVER, IT MUST NOT BE SOLD, GIVEN, OR OTHERWISE DISTRIBUTED      *\n*  TO ANY OTHER COMPANY OR DATA CENTER WITHOUT PRIOR WRITTEN          *\n*  PERMISSION OF:                                                     *\n*                                                                     *\n*                                  BROIDO COMPUTER CONSULTING         *\n*                                  broidoj@gmail.com                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*    TSO command to tell TSO user total storage currently available.  *\n*                                                                     *\n*                                           BROIDO - 8 APRIL 77       *\n*                                                                     *\n*    MODIFIED BY:    S. GOLOB   -  JULY 22,2014                       *\n*                                                                     *\n*                                                                     *\n*    SAMPLE OUTPUT:                                                   *\n*                                                                     *\n*                                                                     *\n*           ---  DISPLAY FREE CORE FOR TSO USER  ---                  *\n*                ------- ---- ---- --- --- ----                       *\n* BYTES AVAILABLE: 00562000 (0005512K) IN SUBPOOL 000, BELOW THE LINE.*\n*     STARTING ADDRESS: 00423000                                      *\n* BYTES AVAILABLE: 73777000 (1891804K) IN SUBPOOL 000, ABOVE THE LINE.*\n*     STARTING ADDRESS: 0BB54000                                      *\n*                                                                     *\n*                                                                     *\n*    CHANGE LOG :                                                     *\n*                                                                     *\n*      S.GOLOB    -  JULY 22, 2014                                    *\n*                                                                     *\n*      1.  Included IBM macro YREGS and converted register notation   *\n*          to R*.                                                     *\n*                                                                     *\n*      2.  Hex display of core size was dropping hi-order 2 digits,   *\n*          so I corrected that.                                       *\n*                                                                     *\n*      3.  Added display of start address of available storage.       *\n*          (It's there, so show it!)                                  *\n*                                                                     *\n*      4.  Added title lines.                                         *\n*                                                                     *\n*      5.  Converted TSO output from TPUT to PUTLINE, so it can be    *\n*          trapped and displayed in a scrollable manner.              *\n*                                                                     *\n***********************************************************************\n* ------------------------------------------------------------------- *\n         MACRO\n.*     --------------------------------------\n.*     DISPLAY HEX VALUES IN CHARACTER FORMAT\n.*     --------------------------------------\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R7,SAVER7A               Save area for BAL register\n         STM   R15,R1,HEXSAVE           Save work registers\n         LA    R1,&FROM                 Load from address\n         LA    R0,&LEN                  Load number of chars to move\n         LA    R15,&TO                  Load to address\n         BAL   R7,HEX                   Go to routine - do the work\n         LM    R15,R1,HEXSAVE           Restore work registers\n         L     R7,SAVER7A               Restore BAL register\n         MEND\n* ------------------------------------------------------------------- *\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\n         YREGS\nCKC      CSECT\n         USING CKC,R15             (ESTABLISH TEMPORARY BASE).\n         B     BEGIN               SKIP OVER HEADER.\nHEAD0    DC    AL1(HEADL)          EXCLUSIVE LENGTH OF HEADER.\nHEAD     DC    C'CKC - &SYSDATE - &SYSTIME -'\n         DC    C'COPYRIGHT (C) BROIDO COMPUTER CONSULTING '\n         DC    C'1977 - '\n         DC    C'ALL RIGHTS RESERVED'\nHEADL    EQU   *-HEAD\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)\n         LR    R12,R15             LOAD BASE.\n         USING CKC,R12\n         LA    R2,SAVE\n         ST    R2,8(,R13)\n         ST    R13,SAVE+4\n         LR    R13,R2\nINITCON  DS    0H\n         MVI   LINE-1,X'40'\n         MVC   LINE,LINE-1\n         XC    SAV14TO1,SAV14TO1\n         STM   R14,R1,SAV14TO1\n         APUT  TITLE0,L'TITLE0\n         APUT  TITLED,L'TITLED\n         LM    R14,R1,SAV14TO1\n         L     R2,0(,R1)           POINT TO COMMAND BUFFER.\n         SPACE 2\n         SR    R4,R4               DEFAULT TO SUBPOOL 0.\n         LH    R3,0(,R2)           LOAD TOTAL LENGTH.\n         SH    R3,=H'5'            CORRECT LENGTH.\n         SH    R3,2(,R2)           CORRECT LENGTH.\n         BM    GET                 B IF NO PARM. SUBPOOL 0.\n         CH    R3,=H'2'            TOO MUCH SUBPOOL?\n         BH    GET                 FORGET IT.\n         AH    R2,2(,R2)           POINT ...\n         LA    R2,4(,R2)           ... TO PARM.\n         XC    WORK(3),WORK\n         EX    R3,SPMVZ            MOVE SUBPOOL ZONES.\n         EX    R3,SPCLC            NUMERIC?\n         BNE   GET                 FORGET IT.\n         EX    R3,SPPK             PACK IT.\n         CVB   R4,WORK             BINARIZE IT.\n         CH    R4,=H'127'          OVER 127?\n         BNH   GET                 B IF NOT.\n         MODESET KEY=ZERO\nGET      DS    0H\n         XC    GMANS,GMANS\n         GETMAIN  VRC,LV=(X'7FFFFFFF',8),SP=(4) GET UP TO 2 GIGABYTES.\nGET1     DS    0H\n         XC    GMANS,GMANS\n         ST    R1,GMANS            SAVE GOTTEN LOCATION.\n         ST    R0,GMANS+4          SAVE LENGTH\n         FREEMAIN RU,SP=(4),LV=(0),A=(1)  FREE GOTTEN STORAGE.\n         L     R1,GMANS+4          LOAD TOTAL CORE GOTTEN.\n         SRL   R1,10               DIVIDE BY 1K.\n         CVD   R1,WORK             DECIMALATE.\n         UNPK  OUT2,WORK+4(4)      UNPACK TO ANSWER AREA\n         OI    OUT2+6,C'0'         FIX THE SIGN\n         HEX   OUT1,4,GMANS+4      DISPLAY CORE SIZE IN HEX\n         CVD   R4,WORK             DECIMALIZE SUBPOOL.\n         UNPK  OUT3,WORK+6(2)      UNPACK IT TO MSG.\n         OI    OUT3+2,X'F0'        FIXATE THE SIGNO.\n         STM   R14,R1,SAV14TO1     APUT MAY DESTROY SOME REGISTERS\n         APUT  OUT,OUTL            OUTPUT THE ANSWER.\n         MVI   LINE-1,X'40'        BLANK\n         MVC   LINE,LINE-1           THE OUTPUT LINE.\n         MVC   LINE(22),STLIT      MOVE IN STARTING ADDRESS LITERAL.\n         HEX   LINE+22,4,GMANS     DISPLAY THE STARTING ADDRESS.\n         APUT  LINE,40             OUTPUT THE LINE.\n         LM    R14,R1,SAV14TO1     RESTORE REGS USED BY APUT.\n         TF    EXITFG              SHOULD WE EXIT?\n         BO    EXIT                B IF YES.\n         MVC   OUT4,=C'ABOVE'      MOVE ABOVE-THE-LINE GRAPHIC.\n         GETMAIN  VRC,LV=(X'7FFFFFFF',8),SP=(4),LOC=(ANY,ANY)\n         ON    EXITFG              TURN ON EXIT FLAG.\n         B     GET1                LOOP.\nEXIT     L     R13,SAVE+4          RESTORE CALLER'S SAVE AREA PTR.\n         LM    R14,R12,12(R13)     RESTORE CALLER'S REGISTERS.\n         SR    R15,R15             SET CC = 0.\n         BR    R14                 EXIT.\nWORK     DS    D\nSAVE     DS    9D\n         SPACE 1\nSPMVZ    MVZ   WORK(*-*),0(R2)\nSPCLC    CLC   WORK(*-*),=C'000'\nSPPK     PACK  WORK,0(*-*,R2)\n         SPACE\nFLAG     DC    X'00'               FLAGS.\nEXITFG   EQU   FLAG,B'10000000'    EXIT-AFTER-THIS-ITERATION FLAG.\n         SPACE\nGMANS    DS    2A                  GETMAIN ANSWER AREA.\nSAV14TO1 DS    4F                  SAVE REGS USED BY APUT.\nSIGNOFF  DC    X'0000000F'\n         DC    C' '\nLINE     DS    CL80\nOUT      DC    C'BYTES AVAILABLE: '\nOUT1     DC    C'XXXXXXXX',C' ('\nOUT2     DC    C'XXXXXXX',C'K) IN SUBPOOL '\nOUT3     DC    C'XXX',C', '\nOUT4     DC    C'BELOW',C' THE LINE.'\nOUTL     EQU   *-OUT\nSTLIT    DC    C'    STARTING ADDRESS: '\nHEXTAB   DC    C'0123456789ABCDEF'\nTITLE0   DC    C'          ---  DISPLAY FREE CORE FOR TSO USER  ---   '\nTITLED   DC    C'               ------- ---- ---- --- --- ----        '\nHEXSAVE  DS    3F                     For HEX routine - save regs\nSAVER7A  DS    F                      Save R7 during BAL\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      MVC   1(1,R15),0(R1)         Move byte\n         UNPK  0(3,R15),1(2,R15)      Unpack\n         TR    0(2,R15),HEXTAB-240    Translate\n         LA    R15,2(,R15)            Increment output pointer\n         LA    R1,1(,R1)              Increment input pointer\n         BCT   R0,HEX                 Decrement length, then loop\n         MVI   0(R15),C' '            Blank the trailing byte\n         BR    R7                     Return to caller\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         LTORG\n         END   CKC\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUEMNTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   255                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         EJECT\n         IHAPSA   LIST=YES                                     HD APR88\n         EJECT                                                 HD APR88\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   14,12,12(13)       SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES            RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    1,8(13)            OUR SAVE AREA POINTER\n         ST    13,4(1)            POINTER TO CALLERS SAVE AREA\n         LR    13,1               @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(R13)         POINT TO CALLERS RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 ASSUME BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 ASSUME BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(RML)               MESSAGE LENGTH\n         STH   R15,PUTLEN                 PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    2,R13                    @OUR SAVE AREA\n         LR    3,R15                    SAVE RETURN CODE\n         L     R13,4(R13)               @CALLERS SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,3                    RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END   EPUTL\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CKC$": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00H\\x01\\x055O\\x01\\x14 /\\x12#\\x00\\x1e\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2005-12-20T00:00:00", "modifydate": "2014-07-21T12:23:48", "lines": 30, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.B.ASM\n//         DD DISP=SHR,DSN=SBGOLOB.JRB.MACLIB.ASM\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(CKC)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,9),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET,NOREUS,NORENT'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(0)\n SETSSI  CB489423\n ENTRY   CKC\n NAME    CKC(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CKDAY": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00R\\x00\\x85\\x18/\\x01\\x13\\x13/\\x15\\x08\\x00u\\x00v\\x008\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "2013-05-12T15:08:52", "lines": 117, "newlines": 118, "modlines": 56, "user": "BROIDO"}, "text": "CKDAY    TITLE 'CLIST UTILITY TO DETECT THE FIRST LOGON OF THE DAY.'\n*%A NOTEST PPLINK\n*LALIAS CLEARDAY\n*LNAME CKDAY(R)\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  COPYRIGHT (C) 1982 BY BROIDO COMPUTER CONSULTING.  ALL RIGHTS      *\n*  RESERVED EXCEPT:                                                   *\n*                                                                     *\n*  PARTICULAR LICENSE IS GRANTED TO DISTRIBUTE THIS PROGRAM FREE      *\n*  OF CHARGE, BUT IT MUST NOT BE SOLD.  A SERVICE CHARGE FOR          *\n*  HANDLING A COLLECTION OF SOFTWARE OF WHICH THIS IS A PART,         *\n*  ON THE OTHER HAND, IS APPROPRIATE.                                 *\n*                                                                     *\n*                                  BROIDO COMPUTER CONSULTING         *\n*                                  BROIDOJ@GMAIL.COM                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* CKDAY - CLIST UTILITY TO DETECT THE FIRST LOGON OF THE DAY, ETC.    *\n*                                                                     *\n*  RETURNS CC OF 0 IF THIS COMMAND HAS BEEN EXECUTED ALREADY TODAY.   *\n*                4 IF COMMAND HAS BEEN EXECUTED, BUT NOT YET TODAY.   *\n*                8 IF COMMAND HAS NEVER BEEN EXECUTED.                *\n*               12 IF COMMAND CANNOT SAVE DATE BECAUSE UPTUSER        *\n*                  IS IN USE BY SOME OTHER PIECE OF SOFTWARE.         *\n*               16 IF COMMAND NOT RUN UNDER TSO.                      *\n*                                                                     *\n*  ENTRY POINT CLEARDAY SETS THE FIRST 6 BYTES OF UPTUSER TO X'00'    *\n*  CLEARDAY MUST BE ASSIGNED AS AN ALIAS.                             *\n*                                                                     *\n*                                  JEFFREY  R.  BROIDO                *\n*                                  AIGDC-E. ORANGE, NJ                *\n*                                  3  SEPTEMBER   1982                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nCKDAY    CSECT\n         ENTRY CLEARDAY\n         REGS\n         USING CKDAY,R15\n         B     CKDAY0              SKIP HEADER.\nHEAD0    DC    AL1(HEADL)          EXCLUSIVE LENGTH OF HEADER.\nHEAD     DC    C' CKDAY COPYRIGHT (C) BROIDO COMPUTER CONSULTING '\n         DC    C'1982 - '\n         DC    C'ALL RIGHTS RESERVED'\nHEADL    EQU   *-HEAD\n         USING CLEARDAY,R15\nCLEARDAY STM   R14,R12,12(R13)\n         SR    R11,R11             CLEAR R11 (ENTRY FLAG).\n         LR    R12,R15\n         SH    R12,=AL2(CLEARDAY-CKDAY) SUBTRACT EP OFFSET.\n         B     CKDAY1              CONTINUE\n         LTORG\n         DROP  R15\nCKDAY0   STM   R14,R12,12(R13)\n         LA    R11,1               SET R11 TO 1 (ENTRY FLAG).\n         LR    R12,R15\n         USING CKDAY,R12\nCKDAY1   LR    R14,R13\n         LA    R13,SAVE\n         ST    R13,8(,R14)\n         ST    R14,SAVE+4\n         SPACE 2\n         L     R2,X'10'            POINT TO CVT.\n         ED    DATE,X'39'(R2)      UNPACK SYSTEM DATE.\n         L     R2,0(,R2)           POINT TO TCB/ASCB WORDS.\n         L     R3,X'C'(,R2)        POINT TO ASCB.\n         CLC   =A(0),X'3C'(R3)     ANY TSB?\n         BNE   ONLINE              B IF NOT.\n         LA    R15,16              SET CC OF 16.  NOT UNDER TSO.\n         B     EOJ                 BYE.\nONLINE   L     R3,0(,R2)           POINT TO TCB.\n         L     R3,X'B4'(,R3)       POINT TO JSCB.\n         L     R3,X'108'(,R3)      POINT TO PSCB.\n         L     R3,X'34'(,R3)       POINT TO UPT.\n         CLC   =XL6'00',2(R3)      FIRST 6 BYTES OF UPTUSER ZERO?\n         BNE   NOTZERO             B IF NOT.\n         LA    R15,8               SET CC OF 8.  COMMAND NEVER EXEC.\n         LTR   R11,R11             CLEARDAY?\n         BZ    EOJ                 B IF YES.\n         MVC   2(6,R3),DATE+1      MOVE TODAY'S DATE TO UPT.\n         B     EOJ                 BYE.\nNOTZERO  MVZ   ZONETEST,2(R3)      MOVE ZONES.\n         CLC   ZONETEST,=C'00 000' FORMAT CHECK OUT?\n         BE    CKPD                B IF YES.\n         LA    R15,12              SET CC OF 12.  UPTUSER IN USE.\n         B     EOJ                 BYE.\nCKPD     CLI   4(R3),C'.'          ...BUT IS 3RD BYTE A PERIOD?\n         BE    CKENTRY             B IF YES.\n         LA    R15,12              SET CC OF 12.  UPTUSER IN USE.\n         B     EOJ                 BYE.\nCKENTRY  LTR   R11,R11             CHECK ENTRY POINT FLAG.\n         BNZ   CKTODAY             B IF CKDAY ENTRY.\n         MVC   2(6,R3),=XL6'00'    CLEAR FIRST 6 BYTES OF UPTUSER.\n         B     EOJ0                BYE.\nCKTODAY  CLC   2(6,R3),DATE+1      COMPARE IT TO DATE IN UPT.\n         BE    EOJ0                B IF THEY ARE THE SAME.\n         LA    R15,4               SET CC OF 4.  CMD NOT EXEC TODAY.\n         MVC   2(6,R3),DATE+1      MOVE TODAY'S DATE TO UPT.\n         B     EOJ                 BYE.\nEOJ0     SR    R15,R15             SET CC OF 0.  CMD EXEC TODAY.\nEOJ      L     R13,SAVE+4\n         LM    R0,R12,20(R13)\n         L     R14,12(,R13)\n         BR    R14\n         SPACE 2\nSAVE     DS    18F\nZONETEST DC    CL6' '              ZONE TEST COMPARAND AREA.\nDATE     DC    X'4021204B202020'   DATE UNPACK AREA.\n         END\nLINKEDIT TITLE 'CKDAY - LINKAGE EDITOR CONTROL CARDS.'\n         PUNCH ' ALIAS CLEARDAY'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CKM": {"ttr": 2316, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x03\\x00\\x85\\x18/\\x01\\x13\\x13/\\x15\\t\\x00v\\x00w\\x00]\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "2013-05-12T15:09:03", "lines": 118, "newlines": 119, "modlines": 93, "user": "BROIDO"}, "text": "*%A PPLINK NOTEST\nCKM      TITLE 'COMMAND TO CHECK PRESENCE OF MEMBER IN PDS.'\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  COPYRIGHT (C) 1978 BY BROIDO COMPUTER CONSULTING.  ALL RIGHTS      *\n*  RESERVED EXCEPT:                                                   *\n*                                                                     *\n*  PARTICULAR LICENSE IS GRANTED TO DISTRIBUTE THIS PROGRAM FREE      *\n*  OF CHARGE, BUT IT MUST NOT BE SOLD.  A SERVICE CHARGE FOR          *\n*  HANDLING A COLLECTION OF SOFTWARE OF WHICH THIS IS A PART,         *\n*  ON THE OTHER HAND, IS APPROPRIATE.                                 *\n*                                                                     *\n*                                  BROIDO COMPUTER CONSULTING         *\n*                                  BROIDOJ@GMAIL.COM                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n**********************************************************************\n*                                                                    *\n*      CKM - COMMAND TO CHECK PRESENCE OF MEMBER IN PDS.             *\n*                                                                    *\n*        USE: 1) ALLOCATE THE PDS, SPECIFING MEMBER.  USE FILENAME   *\n*                OF SYSUT9 IF YOU TAKE THE COMMAND DEFAULT.          *\n*                                                                    *\n*             2) CKM ..DDNAME.. WHERE DDNAME IS OPTIONAL,            *\n*                AND DEFAULTS TO SYSUT9 IF NOT SPECIFIED.  IF        *\n*                DDNAME IS OVER 8 CHARACTERS, DEFAULT IS TAKEN.      *\n*                                                                    *\n*             3) CHECK &LASTCC.  IF 0, MEMBER IS PRESENT.            *\n*                                   4, MEMBER IS NOT IN DATASET.     *\n*                                   8, NO MEMBER SPECIFIED.          *\n*                                  16, DATASET IS NOT PARTITIONED.   *\n*                                  20, DATASET NOT FOUND ON VOLUME.  *\n*                                  24, SYSUT9 (OR YOUR OWN DDNAME)   *\n*                                      NOT ALLOCATED.                *\n*                                                                    *\n*                                     JEFFREY R. BROIDO              *\n*                                     27 OCT 78                      *\n*                                                                    *\n**********************************************************************\n         SPACE 3\nCKM      CSECT\n         REGS\n         EJECT\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         USING CKM,R12\n         LA    R2,SAVE\n         ST    R2,8(,R13)\n         ST    R13,SAVE+4\n         LR    R13,R2\n         SPACE 2\n         L     R2,0(,R1)           POINT TO BUFFER.\n         LH    R4,0(,R2)           LOAD LENGTH.\n         LTR   R4,R4               POSSIBLE NULL BATCH PARM?\n         BZ    CONT                B IF YES.  USE DDNAME OF SYSUT9.\n         CLI   2(R2),0             TSO COMMAND BUFFER?\n         BNE   CONT                B IF NOT.  USE DDNAME OF SYSUT9.\n         LH    R3,2(,R2)           LOAD OFFSET.\n         LA    R3,4(,R3)           MAKE OFFSET ABSOLUTE.\n         AR    R2,R3               POINT TO PARM.\n         CLI   0(R2),C' '          ANY PARM?\n         BE    CONT                B IF NOT.\n         SR    R4,R3               GENERATE LENGTH ...\n         BCTR  R4,*-*              ... OF DDNAME\n         CH    R4,=H'7'            GREATER THAN 7?\n         BH    CONT                B IF YES. USE SYSUT9.\n         MVC   SYSUT9+41(7),=CL8' '     CLEAR DDNAME.\n         EX    R4,DDMOVE           MOVE DDNAME TO DCB.\n         OC    SYSUT9+40(8),=CL8' '     UPPERCASE DDNAME.\nCONT     SR    R3,R3               CLEAR CC.\n         RDJFCB (SYSUT9)           GET JFCB.\nPOSTR    LTR   R15,R15             SYSUT9 EXIST?\n         BZ    CONT0               B IF YES.\n         LA    R3,24               SET CC OF 24.\n         B     EXIT                EXIT.\nCONT0    MVC   VOL,JFCB+118        MOVE VOLUME NAME FOR OBTAIN.\n         OBTAIN OBCAM              OBTAIN TO CKECK FOR DATA SET.\n         LTR   R15,R15             DATA SET EXIST?\n         BZ    CONT1               B IF YES.\n         LA    R3,20               SET CC OF 20.\n         B     EXIT                EXIT.\nCONT1    TM    OBWORK+38,X'02'     CHECK OBTAINED DSCB FOR DSORG.\n         BO    CONT2               B IF PARTITIONED.\n         LA    R3,16               SET CC OF 16.\n         B     EXIT                EXIT.\nCONT2    TM    JFCB+86,X'01'       MEMBER SPECIFIED?\n         BO    CONT3               B IF YES\n         LA    R3,8                SET CC OF 8.\n         B     EXIT                EXIT\nCONT3    MVC   BLDLMEM,JFCB+44     MOVE MEMBER NAME.\n         OPEN  (SYSUT9),TYPE=J     OPEN DATASET.\n         BLDL  SYSUT9,BL           BLDL MEMBER.\n         LR    R4,R15              SAVE CC.\n         CLOSE  (SYSUT9)           CLOSE DATASET\n         LTR   R4,R4               MEMBER FOUND?\n         BZ    EXIT                B IF YES. EVERYTHING OK.\n         LA    R3,4                SET CC OF 4.\nEXIT     L     R13,SAVE+4\n         L     R14,12(,R13)        LOAD RETURN ADDR.\n         LR    R15,R3              SET CC.\n         LM    R0,R12,20(R13)\n         BR    R14\n         SPACE 2\nSAVE     DS    9D\nOBCAM    CAMLST SEARCH,JFCB,VOL,OBWORK\nDDMOVE   MVC   SYSUT9+40(*-*),0(R2) EXECUTED.\nVOL      DS    CL6\nOBWORK   DS    CL140\nBL       DC    H'1',H'12'\nBLDLMEM  DS    CL8,XL4\nRJ       DS    0A\n         DC    X'07',AL3(JFCB)\nJFCB     DS    CL176\n         PRINT NOGEN\nSYSUT9   DCB   DDNAME=SYSUT9,EXLST=RJ,DSORG=PS,MACRF=(E)\n         END   CKM\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CKMOUNT": {"ttr": 2561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00$\\x00\\x85\\x18/\\x01\\x13\\x13/\\x15\\t\\x00I\\x00J\\x00 \\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "2013-05-12T15:09:24", "lines": 73, "newlines": 74, "modlines": 32, "user": "BROIDO"}, "text": "CKMOUNT  TITLE 'A CLIST UTILITY TO DETERMINE USER''S MOUNT PRIVELEGE.'\n*%A AMODGEN PPLINK\n***********************************************************************\n*                                                                     *\n*  COPYRIGHT (C) 1984 BY BROIDO COMPUTER CONSULTING.  ALL RIGHTS      *\n*  RESERVED EXCEPT:                                                   *\n*                                                                     *\n*  PARTICULAR LICENSE IS GRANTED TO DISTRIBUTE THIS PROGRAM FREE      *\n*  OF CHARGE, BUT IT MUST NOT BE SOLD.  A SERVICE CHARGE FOR          *\n*  HANDLING A COLLECTION OF SOFTWARE OF WHICH THIS IS A PART,         *\n*  ON THE OTHER HAND, IS APPROPRIATE.                                 *\n*                                                                     *\n*                                  BROIDO COMPUTER CONSULTING         *\n*                                  BROIDOJ@GMAIL.COM                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   CKMOUNT - A TSO CLIST UTILITY TO RETURN IN THE CONDITION CODE     *\n*       (&LASTCC) THE USER'S MOUNT PRIVELEGES.                        *\n*                                                                     *\n*      &LASTCC = 0  -  USER IS NOT MOUNT PRIVELEGED.                  *\n*      &LASTCC = 4  -  USER IS MOUNT PRIVELEGED.                      *\n*                                                                     *\n*                                  JEFFREY R. BROIDO                  *\n*                                  TWIN COUNTY GROCERS, INC           *\n*                                  145 TALMADGE ROAD                  *\n*                                  EDISON, NJ 08818                   *\n*                                  19 SEPTEMBER 1984                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nCKMOUNT  CSECT\nCKMOUNT  AMODE 24\nCKMOUNT  RMODE 24\n         REGS\n         USING CKMOUNT,R15\n         B     BEGIN               SKIP OVER HEADER.\n         DC    AL1(HEADEND-HEAD)   HEADER LENGTH.\nHEAD     DC    C' CKMOUNT - &SYSDATE &SYSTIME - '\n         DC    C'COPYRIGHT (C) BROIDO COMPUTER CONSULTING '\n         DC    C'1985 - ALL RIGHTS RESERVED'\nHEADEND  EQU   *\nBEGIN    STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS.\n         LR    R12,R15             COPY PRE-LOADED BASE.\n         USING CKMOUNT,R12         (TELL ASSEMBLER).\n         DROP  R15                 DROP TEMPORARY BASE.\n         LR    R14,R13             PRESERVE CALLER'S SAVE AREA POINTER.\n         LA    R13,SAVE            POINT TO MY SAVE AREA.\n         ST    R13,8(,R14)         CHAIN ...\n         ST    R14,4(,R13)         ... SAVE AREAS.\n         SPACE 2\n         L     R2,X'10'            POINT TO CVT.\n         L     R2,0(,R2)           POINT TO TCB/ASCB WORDS.\n         L     R2,0(,R2)           POINT TO CURRENT TCB.\n         L     R2,X'B4'(,R2)       POINT TO JSCB.\n         L     R2,X'108'(,R2)      POINT TO PSCB.\n         USING PSCB,R2             TELL ASSEMBLER.\n         SR    R15,R15             PRESET CC TO 0 (NO MOUNT PRIVELEGE).\n         TM    PSCBATR1,PSCBVMNT   TEST FOR MOUNT PRIVELEGE.\n         BZ    EOJ                 B IF NOT MOUNT PRIVELEGED.\n         LA    R15,4               SET CC TO 4 (MOUNT PRIVELEGED).\n         SPACE 1\nEOJ      L     R13,SAVE+4          POINT TO CALLER'S SAVE AREA.\n         LM    R0,R12,20(R13)      RELOAD CALLER'S REGISTERS.\n         L     R14,12(,R13)        RELOAD RETURN ADDRESS.\n         BR    R14                 RETURN TO CALLER.\n         SPACE 2\nSAVE     DS    9D                  SAVE AREA.\n         TITLE 'CONTROL BLOCK DSECTS.'\n         IKJPSCB\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CKO": {"ttr": 2564, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x007\\x00\\x85\\x18/\\x01\\x13\\x13/\\x15\\t\\x00O\\x00P\\x00\\x1b\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "2013-05-12T15:09:37", "lines": 79, "newlines": 80, "modlines": 27, "user": "BROIDO"}, "text": "CKO      TITLE 'A CLIST UTILITY TO DETERMINE USER''S PRIVELEGE.'\n*%A AMODGEN PPLINK\n***********************************************************************\n*                                                                     *\n*  COPYRIGHT (C) 1984 BY BROIDO COMPUTER CONSULTING.  ALL RIGHTS      *\n*  RESERVED EXCEPT:                                                   *\n*                                                                     *\n*  PARTICULAR LICENSE IS GRANTED TO DISTRIBUTE THIS PROGRAM FREE      *\n*  OF CHARGE, BUT IT MUST NOT BE SOLD.  A SERVICE CHARGE FOR          *\n*  HANDLING A COLLECTION OF SOFTWARE OF WHICH THIS IS A PART,         *\n*  ON THE OTHER HAND, IS APPROPRIATE.                                 *\n*                                                                     *\n*                                  BROIDO COMPUTER CONSULTING         *\n*                                  BROIDOJ@GMAIL.COM                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   CKO - A TSO CLIST UTILITY TO RETURN IN THE CONDITION CODE         *\n*       (&LASTCC) THE USER'S PRIVILEGES.                              *\n*                                                                     *\n*      &LASTCC = 0  -  USER IS NEITHER OPER NOR ACCT PRIVILEGED.      *\n*      &LASTCC = 4  -  USER IS OPER BUT NOT ACCT PRIVILEGED.          *\n*      &LASTCC = 8  -  USER IS BOTH OPER AND ACCT PRIVILEGED.         *\n*                                                                     *\n*                                  JEFFREY R. BROIDO                  *\n*                                  TWIN COUNTY GROCERS, INC           *\n*                                  145 TALMADGE ROAD                  *\n*                                  EDISON, NJ 08818                   *\n*                                  19 SEPTEMBER 1984                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nCKO      CSECT\n         REGS\n         USING CKO,R15             (ESTABLISH TEMPORARY BASE).\n         B     BEGIN               SKIP OVER HEADER.\nHEAD0    DC    AL1(HEADL)          EXCLUSIVE LENGTH OF HEADER.\nHEAD     DC    C' CKO - &SYSDATE - &SYSTIME -'\n         DC    C'COPYRIGHT (C) BROIDO COMPUTER CONSULTING '\n         DC    C'1984 - '\n         DC    C'ALL RIGHTS RESERVED'\nHEADL    EQU   *-HEAD\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS.\n         LR    R12,R15             COPY PRE-LOADED BASE.\n         USING CKO,R12             (TELL ASSEMBLER).\n         DROP  R15                 DROP TEMPORARY BASE.\n         LR    R14,R13             PRESERVE CALLER'S SAVE AREA POINTER.\n         LA    R13,SAVE            POINT TO MY SAVE AREA.\n         ST    R13,8(,R14)         CHAIN ...\n         ST    R14,4(,R13)         ... SAVE AREAS.\n         SPACE 2\n         L     R2,X'10'            POINT TO CVT.\n         L     R2,0(,R2)           POINT TO TCB/ASCB WORDS.\n         L     R2,0(,R2)           POINT TO CURRENT TCB.\n         L     R2,X'B4'(,R2)       POINT TO JSCB.\n         L     R2,X'108'(,R2)      POINT TO PSCB.\n         USING PSCB,R2             TELL ASSEMBLER.\n         SR    R15,R15             PRESET CC TO 0 (NO PRIVILEGES).\n         TM    PSCBATR1,PSCBCTRL+PSCBACCT  TEST FOR OPER, ACCT.\n         BZ    EOJ                 B IF NEITHER OPER, ACCT.\n         BM    CKOPER              B IF EITHER OPER OR ACCT.\n         LA    R15,8               SET CC TO 8 (OPER AND ACCT).\n         B     EOJ                 CONTINUE.\nCKOPER   TM    PSCBATR1,PSCBCTRL   OPER PRIVILEGED?\n         BZ    EOJ                 ACCT BUT NOT OPER - EXIT W/ CC=0.\n         LA    R15,4               SET CC TO 4 (OPER ONLY).\n         SPACE 2\nEOJ      L     R13,SAVE+4          POINT TO CALLER'S SAVE AREA.\n         LM    R0,R12,20(R13)      RELOAD CALLER'S REGISTERS.\n         L     R14,12(,R13)        RELOAD RETURN ADDRESS.\n         BR    R14                 RETURN TO CALLER.\n         SPACE 2\nSAVE     DS    9D                  SAVE AREA.\n         TITLE 'CONTROL BLOCK DSECTS.'\n         IKJPSCB\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DIGCLK": {"ttr": 2567, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x11\\x00y\\x05\\x7f\\x01\\x13\\x13/\\x15\\x10\\x01\\x16\\x00\\x9f\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1979-02-26T00:00:00", "modifydate": "2013-05-12T15:10:11", "lines": 278, "newlines": 159, "modlines": 0, "user": "SBGOLOB"}, "text": "   TITLE 'DIGCLK   --   3270 TERMINAL DIGITAL CLOCK'                    00002\n* ------------------------------------------------------------------- *\n*  CHANGE LOG:                                                      UTC\n*                                                                   UTC\n*   1.  Insert global assembly adjustments to account for time      UTC\n*       zone differences.  (SBG - 12May2013)                        UTC\n*                                                                   UTC\n* ------------------------------------------------------------------UTC\n*                    SET THE TIME ZONE HERE                         UTC\n*                    --- --- ---- ---- ----                         UTC\n*  As this command is currently coded, you will have to adjust for  UTC\n*  the current time zone and re-assemble this command.  The adjust- UTC\n*  ments are coded using the settings below....                     UTC\n*                                                                   UTC\n*  A.  First adjust &PLUSMIN if you are east or west of Greenwich.  UTC\n*      Set it to '-' if you are west.                               UTC\n*      Set it to '+' if you are east.                               UTC\n*                                                                   UTC\n*  B.  Then adjust &DISPLHR to tell the program how many hours of   UTC\n*      displacement (already set to plus or minus).                 UTC\n*                                                                   UTC\n*  C.  If your time zone is not an even hour, plus or minus of      UTC\n*      Greenwich, then set the appropriate number of minutes to     UTC\n*      add, in &ADDMIN.   &ADDMIN will add only, not subtract.      UTC\n*      So you may have to adjust &ADDMIN and &DISPLHR together,     UTC\n*      to get the actual correct displacement from UTC.             UTC\n*                                                                   UTC\n* ------------------------------------------------------------------UTC\n         LCLC  &PLUSMIN         PLUS OR MINUS FROM UTC.             UTC 01677\n         LCLA  &DISPLHR,&ADDMIN     HOURS, MINUTES.                 UTC 01678\n*                                                                   UTC\n&PLUSMIN SETC  '-'              ('+' FOR PLUS, '-' FOR MINUS)       UTC 01684\n&DISPLHR SETA  4                HOW MANY HOURS                      UTC 01683\n&ADDMIN  SETA  0                ADD MINUTES - ALWAYS ADD.....       UTC\n*                                                                   UTC\n*                               (IF PLUSMIN IS NEGATIVE AND         UTC\n*                               MINUTES IS NOT ZERO, THEN CONSIDER  UTC\n*                               ADDING ONE HOUR TO DISPLHR, TO      UTC\n*                               MAKE SURE THE TIME IS CORRECT.      UTC\n*                               &ADDMIN MAY HAVE TO BE SET TO       UTC\n*                               60 MINUS THE REAL NUMBER OF         UTC\n*                               MINUTES IN UTC-HH.MM.)              UTC\n* ------------------------------------------------------------------- *\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  COPYRIGHT (C) 1979 BY JEFFREY R. BROIDO.  ALL RIGHTS RESERVED.     *\n*                                                                     *\n*  LICENSE IS HEREBY GRANTED TO WESTERN UNION INTERNATIONAL (A        *\n*  SUBSIDIARY OF MCI, INCORPORATED) AND ITS AFFILIATES TO USE THIS    *\n*  PROGRAM.  HOWEVER, IT MUST NOT BE BE SOLD, GIVEN, OR OTHERWISE     *\n*  DISTRIBUTED TO ANY OTHER COMPANY OR DATA CENTER WITHOUT PRIOR      *\n*  WRITTEN PERMISSION OF:                                             *\n*                                                                     *\n*                                  BROIDO COMPUTER CONSULTING         *\n*                                  broidoj@gmail.com                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        DIGCLK - DIGITAL CLOCK FOR 327X TERMINALS.  WRITTEN AT       *\n*              COLGATE-PALMOLIVE,  MODIFIED AT JOHNSON & JOHNSON.     *\n*                                                                     *\n*                                  JEFFREY R. BROIDO                  *\n*                                                                     *\n***********************************************************************\nDIGCLK   CSECT\n         YREGS\n         USING DIGCLK,R15          (ESTABLISH TEMPORARY BASE).\n         B     BEGIN               SKIP OVER HEADER.\nHEAD0    DC    AL1(HEADL)          EXCLUSIVE LENGTH OF HEADER.\nHEAD     DC    C' DIGCLK - &SYSDATE - &SYSTIME -'\n         DC    C'COPYRIGHT (C) BROIDO COMPUTER CONSULTING '\n         DC    C'1979 - '\n         DC    C'ALL RIGHTS RESERVED'\nHEADL    EQU   *-HEAD\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)\n         LR    R12,R15\n         USING DIGCLK,R12\n         ST    R12,BSAVE\n         LA    R2,SAVE\n         ST    R2,8(,R13)\n         ST    R13,SAVE+4\n         LR    R13,R2\n         GTSIZE ,\n         LTR   R0,R0               DISPLAY?\n         BNZ   OKDISP              B IF YES.\n         VTPUT 'This program will only run on a display terminal.'\n         B     EXITTTY\nOKDISP   SR    R9,R9\n         SR    R10,R10\n         LA    R1,STAXLIST\n         STAX  ATTN,MF=(E,(1))\n         SPACE 1\nCLKLUP   SR    R6,R6               CLEAR COUNTER\nCLKLUP1  STCK  WORK1               STORE CLOCK.\n         LM    R2,R3,WORK1         LOAD IT.\n         SRDL  R2,12\n         D     R2,=F'86400000'\n         LR    R5,R2\n         SR    R2,R2\n         D     R2,=F'1000'\n         LR    R3,R2\n         M     R2,=F'86400000'\n         ALR   R3,R5\n         BC    12,NOCARRY\n         LA    R2,1(,R2)\nNOCARRY  D     R2,=F'10000'        MAKE R3 HUNDREDTHS OF SECONDS.\n         SR    R2,R2               CLEAR REMAINDER.\n         D     R2,=F'100'          ISOLATE HUNDREDTHS.\n         CH    R2,=H'10'           LESS THAN TENTH AWAY?\n         BH    OLDCK               B IF NO.\n         LTR   R10,R10\n         BZ    SLEEP1\n         CR    R10,R3               STILL SAME TIME?\n         BE    SLEEP1\n         B     SECTEST\nOLDCK    LTR   R9,R9               OLD TIME INVALID?\n         BZ    SLEEP0              B IF YES.\n         CR    R9,R3               OLD TIME EQUAL?\n         BE    SLEEP1              B IF YES.\n         LR    R3,R9\n         B     SECTEST\nSLEEP0   LR    R9,R3\n         SR    R10,R10\nSLEEP1   STIMER  WAIT,BINTVL=INTRVL   SLEEP.\n         TM    FLAG,ENDFLG         END AT HAND?\n         BO    EXIT                YUP.\n         LA    R6,1(,R6)           BUMP COUNT.\n         B     CLKLUP1             DO IT AGAIN.\nSECTEST  SR    R2,R2               CLEAR REMAINDER\n         D     R2,=F'60'           ISOLATE SECONDS.\n         MVI   CLK02,C'-'          DEFAULT TO DASH (SEC EVEN).\n         EX    R2,REGTEST          SECONDS EVEN?\n         BZ    SECEV               B IF YES.\n         MVI   CLK02,X'6D'         MOVE UNDERLINE (SEC ODD).\nSECEV    CVD   R2,WORK1            DECIMALIZE SECS.\n         ZAP   DECCLK,WORK1+6(2)   MOVE SECS.\n         SR    R2,R2               CLEAR REMAINDER.\n         D     R2,=F'60'           ISOLATE MINUTES.\n* -------------------------------------------------------------- *  UTC\n*     Add minutes to UTC correction. ADD ONLY!!!! If &PLUSMIN is *  UTC\n*     negative, then adjust &DISPLHR up by one, and the &ADDMIN  *  UTC\n*     to the 60's complement.                                    *  UTC\n* -------------------------------------------------------------- *  UTC\n         A     R2,=F'&ADDMIN'      ADD UTC DISPLACEMENT IN MINUTES  UTC\n         C     R2,=F'60'           LESS THAN 60 MINUTES             UTC\n         BL    NOADDHR             FINE. NO CHANGE.                 UTC\n         S     R2,=F'60'           SUBTRACT 60 MINUTES              UTC\n         LA    R3,1(,R3)           ADD 1 HOUR                       UTC\nNOADDHR  DS    0H                                                   UTC\n         CVD   R2,WORK1            DEC. MINUTES.\n         SRP   WORK1+5(3),2,0      SHIFT MINUTES LEFT.\n         AP    DECCLK+1(3),WORK1+5(3) ADD MINUTES.\n* --------------------------------------------------------------- * UTC\n*   To change UTC hours correction, insert code here:       below * UTC\n* --------------------------------------------------------------- * UTC\nSETUTC   DS    0H                  Set hours difference from UTC    UTC\n         AIF   ('&PLUSMIN' EQ '+').SETPLUS                          UTC\n         AIF   ('&PLUSMIN' EQ '-').SETMINUS                         UTC\n         AGO   .SETMINUS           Default is minus.                UTC\n.SETMINUS ANOP                                                      UTC\n         S     R3,=F'&DISPLHR'     UTC - n HOURS  (CHANGE)          UTC\n         BNM   SETMNNG             LESS THAN 0 ?                    UTC\n         A     R3,=F'24'           YES. ADD 24 HOURS.               UTC\nSETMNNG  DS    0H                                                   UTC\n         AGO   .DONESET                                             UTC\n.SETPLUS ANOP                                                       UTC\n         LA    R4,&DISPLHR         LOAD REG WITH HOURS DISPLACEMENT UTC\n         LA    R3,0(R4,R3)         UTC + n HOURS  (CHANGE)          UTC\n.DONESET ANOP                                                       UTC\n* --------------------------------------------------------------- * UTC\n*   To change UTC hours correction, insert code here:       above * UTC\n* --------------------------------------------------------------- * UTC\n         CH    R3,=H'24'           CORRECTED TIME PAST MIDNIGHT?\n         BL    NOTMID              B IF NOT.\n         SH    R3,=H'24'           CORRECT FOR NEXT DAY.\nNOTMID   CVD   R3,WORK1            DEC HOURS.\n         SRP   WORK1+4(4),4,0      SHIFT HOURS LEFT.\n         AP    DECCLK,WORK1+4(4)   ADD HOURS.\n         SRP   DECCLK,1,0          SHIFT LEFT ONE.\n         MVC   CLK01,CLKPAT1       MOVE PATTERN.\n         ED    CLK01,DECCLK        EDIT TIME.\n         CVD   R6,WORK1            DECIMALIZE COUNT FOR POSSIBLE DISP.\n         C     R6,=F'6'            IS COUNT OVER 6?\n         BL    CKLOW               B IF NOT.\n         L     R1,INTRVL           OVER 6.  TOO MANY POPS. BUMP UP ...\n         LA    R1,1(,R1)           ... THE INTERVAL BY 1/100 SEC.\n         ST    R1,INTRVL           SAVE NEW INTERVAL.\n         B     CNTOK               CONTINUE.\nCKLOW    C     R6,=F'2'            COUNT UNDER 2?\n         BH    CNTOK               B IF NOT.\n         L     R1,INTRVL           UNDER 2.  TO FEW POPS.  SHAVE ...\n         BCTR  R1,*-*              ... INTERVAL BY 1/100 SEC.\n         ST    R1,INTRVL           SAVE NEW INTERVAL.\nCNTOK    TM    FLAG,CNTFLG\n         BZ    FPUT\n         UNPK  CTOUT,WORK1+5(3)\n         OI    CTOUT+4,X'F0'\n         L     R6,INTRVL\n         CVD   R6,WORK1\n         UNPK  INTOUT,WORK1+6(2)\n         OI    INTOUT+2,X'F0'\nFPUT     TPUT  CLK00,LCLK00,FULLSCR\n         LR    R10,R9\n         SR    R9,R9\n         TM    FLAG,ENDFLG             END AT HAND?\n         BO    EXIT                    B IF YES\n         TM    FLAG,QFLG               QUERY END FLAG SET?\n         BZ    CLKLUP                  B IF NOT.\n         LH    R1,QCNT                 LOAD COUNT.\n         LA    R1,1(,R1)               BUMP IT.\n         STH   R1,QCNT                 RESTORE IT.\n         CH    R1,=H'2'                OVER 2?\n         BNH   CLKLUP                  B IF NOT.\n         NI    FLAG,X'FF'-QFLG         OFF QFLG.\n         B     CLKLUP\n         SPACE 1\nEXIT     K\n         STIMER WAIT,BINTVL=HALF\n         VTPUT 'Bye!'\nEXITTTY  L     R13,SAVE+4\n         LM    R14,R12,12(R13)\n         BR    R14\n         SPACE 1\n         USING *,R15\nATTN     L     R12,BSAVE\n         LR    R5,R14\n         DROP  R15\n         TM    FLAG,QFLG               QUERY END FLAG ON?\n         BZ    ATTN1                   B IF NOT\n         OI    FLAG,ENDFLG             ON FINAL END FLAG.\n         BR    R5                      RETURN\nATTN1    XC    QCNT,QCNT               CLEAR END INTERVAL COUNT\n         XI    FLAG,CNTFLG             FLIP-FLOP INTERNAL INFO FLG.\n         OI    FLAG,QFLG               ON QUERY END FLAG.\n         MVI   CTOUT,C' '\n         MVC   CTOUT+1(9),CTOUT\n         K\n         STIMER WAIT,BINTVL=HALF\n         VTPUT 'Hit ENTER to continue, or type E to end.'\n         TGET  IN,1\n         OI    IN,C' '\n         CLI   IN,C'E'\n         BNER  R5                  RETURN IF NOT END\n         OI    FLAG,ENDFLG\n         BR    R5                  RETURN\n         SPACE 1\nBSAVE    DS    F\nSAVE     DS    9D\nWORK1    DS    D\nWORK     DS    F\nDECCLK   DS    PL4\nFLAG     DC    X'00'\nCNTFLG   EQU   B'10000000'\nENDFLG   EQU   B'01000000'\nQFLG     EQU   B'00100000'\nQCNT     DS    H\nSTAXLIST STAX  ATTN,MF=L\nINTRVL   DC    F'33'\nHALF     DC    F'50'\nCLK00    DC    X'F11140C13C404000114ED11D60'\nCLK01    DS    CL9\n         DC    X'1DE8'\nCLK02    DS    C\n         DC    X'1140401DE8'\nCTOUT    DS    CL5\n         DC    CL2' '\nINTOUT   DS    CL3\n         DC    X'11404013'\nLCLK00   EQU   *-CLK00\nCLKPAT1  DC    X'4021207A20207A2020'\nREGTEST  TM    EVODD,*-*\nEVODD    DC    X'01'\nIN       DS    C\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DIGCLK$": {"ttr": 2572, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x17\\x01\\x126?\\x01\\x13\\x13/\\x14G\\x00\\x1d\\x00\\x1c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2012-12-28T00:00:00", "modifydate": "2013-05-12T14:47:17", "lines": 29, "newlines": 28, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.JRB.MACLIB.ASM (FROM MEMBER $MACLIB)\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(DIGCLK)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n ORDER   DIGCLK\n SETSSI  CB487423\n SETCODE AC(0)\n ENTRY   DIGCLK\n NAME    DIGCLK(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DIGCLK#": {"ttr": 2574, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x15\\x00\\x82\\x13\\x8f\\x01\\x13\\x13/\\x11X\\x003\\x00\\x0c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1982-05-18T00:00:00", "modifydate": "2013-05-12T11:58:15", "lines": 51, "newlines": 12, "modlines": 0, "user": "SBGOLOB"}, "text": ")F FUNCTION -\n\n  The DIGCLK command takes control of your 3270 terminal\n  and uses it as a digital clock.\n\n)X SYNTAX -\n\n         DIGCLK\n\n)O OPERAND - NONE\n  REQUIRED - NONE\n  DEFAULTS - NONE\n  Note -     To exit the digital clock, you have to reset\n             the screen and then press PA1 (attention).\n             You will then be prompted to press enter or\n             end.  To get out, you have to type the letter\n             E.\n\n  Note2 -    The way this command is currently coded, you\n             have to hard-code the difference between\n             Greenwich Time (or UTC) and your current time\n             zone.  See global settings at the beginning of\n             the program.\n\n             If your region switches to Daylight Savings\n             time twice a year, it may be best to assemble\n             two versions of this program, one for the\n             Standard Time, and one for the Daylight Savings\n             time, and rename the two versions as appropriate.\n\n  Note3 -    Setting the time zones before assembly.\n\n                      SET THE TIME ZONE HERE\n                      --- --- ---- ---- ----\n    As this command is currently coded, you will have to adjust for\n    the current time zone and re-assemble this command.  The adjust-\n    ments are coded using the settings below....\n\n    A.  First adjust &PLUSMIN if you are east or west of Greenwich.\n        Set it to '-' if you are west.\n        Set it to '+' if you are east.\n\n    B.  Then adjust &DISPLHR to tell the program how many hours of\n        displacement (already set to plus or minus).\n\n    C.  If your time zone is not an even hour, plus or minus of\n        Greenwich, then set the appropriate number of minutes to\n        add, in &PLUSMIN.  &PLUSMIN will add only, not subtract.\n        So you may have to adjust &PLUSMIN and &DISPLHR together,\n        to get the actual correct displacement from UTC.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DUMPV": {"ttr": 2576, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x12\\x00\\x92\\x01\\x0f\\x01\\x18\\x04O\\x01\\x06\\x00\\xc4\\x00\\xc2\\x00(\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1992-01-10T00:00:00", "modifydate": "2018-02-13T01:06:12", "lines": 196, "newlines": 194, "modlines": 40, "user": "BROIDO"}, "text": "DUMPV    TITLE 'DUMPS CLIST VARIABLES.'\n*%A PPLINK NOTEST AMODGEN\n***********************************************************************\n*                                                                     *\n*  COPYRIGHT (C) 1992 BY JEFFREY R. BROIDO.  ALL RIGHTS RESERVED.     *\n*                                                                     *\n*  LICENSE IS HEREBY GRANTED TO PERSHING SYSTEMS, INCORPORATED,       *\n*  NEW YORK, NEW YORK, AND ITS AFFILIATES TO USE THIS PROGRAM.        *\n*  HOWEVER, IT MUST NOT BE SOLD, GIVEN, OR OTHERWISE DISTRIBUTED      *\n*  TO ANY OTHER COMPANY OR DATA CENTER WITHOUT PRIOR WRITTEN          *\n*  PERMISSION OF:                                                     *\n*                                                                     *\n*                                  BROIDO COMPUTER CONSULTING         *\n*                                  broidoj@gmail.com                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        DUMPV - A utility for authors of CLISTs and/or REXX execs.   *\n*                Executed as a TSO command with no operands, DUMPV    *\n*                lists all variables and their contents excepting     *\n*                variables which cannot be evaluated.                 *\n*                                                                     *\n*                                  Jeffrey  R.  Broido                *\n*                                  20   December  1991                *\n*                                  @SP/RCC, Kenilworth                *\n*                                                                     *\n*        Operands:     None.                                          *\n*        Return codes:  0 - Normal.                                   *\n*                       8 - Not run under CLIST or REXX exec.         *\n*                      16 - Not run as a TSO command.                 *\n*                                                                     *\n*        Registers:    12 - Base.                                     *\n*                       4 - Address of IKJCT441.                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nDUMPV    CSECT\nDUMPV    AMODE 31\n         REGS\n         USING DUMPV,R15           (ESTABLISH TEMPORARY BASE).\n         B     BEGIN               SKIP OVER HEADER.\nHEAD0    DC    AL1(HEADL)          EXCLUSIVE LENGTH OF HEADER.\nHEAD     DC    C' DUMPV - &SYSDATE - &SYSTIME -'\n         DC    C'COPYRIGHT (C) BROIDO COMPUTER CONSULTING '\n         DC    C'1992 - '\n         DC    C'ALL RIGHTS RESERVED'\nHEADL    EQU   *-HEAD\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         LR    R12,R15             COPY BASE.\n         USING DUMPV,R12           (TELL ASSEMBLER).\n         LR    R14,R13             COPY CALLER'S SAVE AREA POINTER.\n         LA    R13,SAVE            POINT TO MY SAVE AREA.\n         ST    R13,8(,R14)         CHAIN ...\n         ST    R14,4(,R13)         ... AREAS.\n         ST    R1,SAVE             PRESERVE CPPL POINTER.\n         SPACE 1\n         L     R4,X'10'            POINT TO CVT.\n         USING CVT,R4              (TELL ASM)\n         MVC   PUTLADDR,CVTPUTL    COPY ADDRESS OF PUTLINE ROUTINE.\n         L     R4,CVTTVT           PONT TO THE TSVT.\n         USING TSVT,R4             (TELL ASM).\n         L     R4,TSVTVACC         POINT TO IKJCT441 (CLIST ...\n*                                  ... AND REX VARIABLE ACCESS RTN).\n         L     R1,SAVE             RELOAD CPPL POINTER.\n         LTR   R1,R1               IS THERE THE POSSIBILITY OF A CPPL?\n         BNZ   CKCBUF              B IF YES.\nNOTCMD   VTPUT 'DUMPV must run directly as a TSO command.'\n         LA    R15,16              SET CC OF 16.\n         B     EXIT                EXIT.\n         USING CPPL,R1\nCKCBUF   ICM   R14,X'F',CPPLCBUF   POINT TO SUPPOSED COMMAND BUFFER.\n         BZ    NOTCMD              B IF POINTER IS ZERO.  NOT CPPL.\n         CLC   =H'4',0(R14)        IS LENGTH < 4?\n         BH    NOTCMD              B IF YES.  NOT CPPL.\n         CLI   2(R14),X'00'        POSSIBLE OFFSET?\n         BNE   NOTCMD              B IF NOT.  NOT CPPL.\nCPPLOK   MVC   IOPLUPT,CPPLUPT     INITIALIZE ...\n         MVC   IOPLECT,CPPLECT     ... PUTLINE IOPL.\n         DROP  R1\n*                                  ... VARIABLE ACCESS ROUTINE).\nLOOP     LR    R15,R4              POINT TO VARIABLE ACCESS ROUTINE.\n         LA    R1,PARM441          POINT TO VARIABLE ACCESS RTN PARMS.\n         BALR  R14,R15             CALL VARIABLE ACCESS ROUTINE.\n         LR    R8,R15              PRESERVE RETURN CODE.\n         CH    R8,=H'40'           IS CALL FROM WITHIN CLIST OR REXX?\n         BNE   CLISTOK             B IF ENVIRONMENT IS OK.\n         L     R15,PUTLADDR        POINT TO IKJPUTL.\n         LA    R2,NPMSG0           POINT TO NO-PURPOSE MESSAGE.\n         PUTLINE OUTPUT=((R2),DATA),ENTRY=(15),MF=(E,IOPL) SEND LINE.\n* SAY: DUMPV SERVES NO PURPOSE UNLESS YOU''RE RUNNING UNDER A CLIST.\n         LA    R15,8               SET CC = 8.\n         B     EXIT                EXIT.\nCLISTOK  CH    R8,=H'20'           ARE THERE NO MORE VARIABLES?\n         BE    EXIT0               EXIT IF THERE ARE NO MORE.\n         CH    R8,=H'8'            VARIABLE REQUIRES EVALUATION?\n         BE    LOOP                IGNORE IT IF YES.\n         CH    R8,=H'12'           VARIABLE IS A LABEL?\n         BE    LOOP                IGNORE IT IF YES.\n         CH    R8,=H'24'           VARIABLE IS A PROC NAME?\n         BE    LOOP                IGNORE IT IF YES.\nDONAME   MVI   OUTNAME+1,C' '                   CLEAR ...\n         MVC   OUTNAME+2(L'OUTNAME-2),OUTNAME+1 ... NAME AREA.\n         L     R1,NAMEPTR          POINT TO VARIABLE NAME.\n         L     R15,NAMELEN         LOAD LENGTH OF NAME.\n         BCTR  R15,*-*             GENERATE SS LENGTH.\n         CH    R15,=AL2(L'OUTNAME-1) WILL NAME FIT?\n         BNH   NLOK                B IF YES.\n         LA    R15,L'OUTNAME-4     CHANGE TO TRUNCATED LENGTH.\n         EX    R15,MVNAME          MOVE NAME TO OUTPUT AREA.\n*      ( MVC   OUTNAME(*-*),0(R1)  )\n         MVC   OUTNAME+L'OUTNAME-3(3),=C'...' MOVE TRUNC. INDICATOR.\n         B     DOVAL\nNLOK     EX    R15,MVNAME          MOVE NAME TO OUTPUT AREA.\n*      ( MVC   OUTNAME(*-*),0(R1)  )\n         LA    R1,OUT+1(R15)       BUMP PAST NAME.\n*        MVI   0(R1),C':'          MOVE COLON TO END OF NAME.\nDOVAL    L     R1,VALUEPTR         POINT TO VARIABLE VALUE, IF ANY.\n         ICM   R15,X'F',VALUELEN   IS VALUE NULL?\n         BNZ   VNOTNULL            B IF NOT.\n         LA    R15,NULLLEN         LOAD LENGTH OF \"NULL\" GRAPHIC.\n         LA    R1,NULLVAL          POINT TO \"NULL\" GRAPHIC.\nVNOTNULL BCTR  R15,*-*             GENERATE SS LENGTH OF VALUE.\n         CH    R15,=AL2(L'OUTVAL-1) WILL VALUE FIT?\n         BNH   VLOK                B IF YES.\n         LA    R15,L'OUTVAL-4      CHANGE TO TRUNCATED LENGTH.\n         EX    R15,MVVAL           MOVE VALUE TO OUTPUT AREA.\n*      ( MVC   OUTVAL(*-*),0(R1)   )\n         MVC   OUTVAL+L'OUTVAL-3(3),=C'...'\n         LA    R15,3(,R15)         BUMP LENGTH TO ACCOUNT FOR \"...\"\n         B     PUT                 CONTINUE.\nVLOK     EX    R15,MVVAL           MOVE VALUE TO OUTPUT AREA.\n*      ( MVC   OUTVAL(*-*),0(R1)   )\nPUT      LA    R14,L'OUTNAME+L'OUTFILL+1(R15) LOAD TOTAL LENGTH.\n         LA    R14,4(,R14)         ADD RDW TO LENGTH.\n         STH   R14,OUT0            SAVE LENGTH IN RDW.\n         LA    R2,OUT0             POINT TO OUTPUT AREA.\n         L     R15,PUTLADDR        POINT TO IKJPUTL.\n         PUTLINE OUTPUT=((R2),DATA),ENTRY=(15),MF=(E,IOPL) SEND LINE.\n         MVC   VALUEPTR,=A(NULLVAL) RESET VALUE TO NULL IN CASE ...\n         MVC   VALUELEN,=A(NULLLEN) ... NEXT CALL RETURNS NO VALUE.\n         B     LOOP\nEXIT0    SR    R15,R15             SET CC OF 0.\nEXIT     L     R13,SAVE+4          POINT TO CALLER'S SAVE AREA.\n         LM    R0,R12,12(R13)      RELOAD CALLER'S REGISTERS.\n         L     R14,12(,R13)        RELOAD RETURN ADDRESS.\n         BR    R14                 RETURN TO CALLER.\n         DROP  R4\nMVNAME   MVC   OUTNAME(*-*),0(R1)  *** EXECUTED ***\nMVVAL    MVC   OUTVAL(*-*),0(R1)   *** EXECUTED ***\n         TITLE '- DATA AREAS.'\nSAVE     DS    9D                  MAIN SAVE AREA.\nNAMEPTR  DS    A                   CLIST VARIABLE NAME POINTER.\nNAMELEN  DS    F                   CLIST VARIABLE LENGTH.\nVALUEPTR DS    A                   CLIST VARIABLE VALUE POINTER.\nVALUELEN DS    F                   CLIST VARIABLE VALUE LENGTH.\nNULLVAL  DC    C'< Null >'         NULL VARIABLE GRAPHIC.\nNULLLEN  EQU   *-NULLVAL\n         SPACE 1\nPTPB0    PUTLINE OUTPUT=(OUT0,DATA),MF=L\nIOPL     DS    0A                  IOPL FOR PUTLINE.\nIOPLUPT  DC    A(0)                POINTER TO UPT.\nIOPLECT  DC    A(0)                POINTER TO ECT.\nIOPLECB  DC    A(PUTECB)           POINTER TO ECB.\nIOPLIOPB DC    A(PTPB0)            POINTER TO PTPB.\nPUTECB   DC    A(0)                ECB FOR USE BY PUTLINE.\nPUTLADDR DS    A                   ADDRESS OF PUTLINE ROUTINE.\n         SPACE 1\nNPMSG0   DS    0A                  NO-PURPOSE MESSAGE.\n         DC    AL2(NPMSGLEN,0)     HEADER.\n         DC    C'DUMPV serves no purpose unless you''re running '\n         DC    C'under a CLIST or REXX exec.'\nNPMSGLEN EQU   *-NPMSG0            LENGTH OF MESSAGE.\n         SPACE 1\nOUT0     DS    0A                  OUTPUT BUFFER FOR NAME LIST MODE.\n         DC    AL2(OUTLEN,0)       OUTPUT HEADER.\nOUT      DS    0C                  OUTPUT BUFFER.\nOUTNAME  DC    CL15' '             OUTPUT VARIABLE NAME.\nOUTFILL  DC    C' '                OUTPUT SPACER.\nOUTVAL   DC    CL63' '             OUTPUT VARIABLE CONTENTS.\nOUTLEN   EQU   *-OUT0              LENGTH OF OUTPUT BUFFER.\n         SPACE 1\nPARM441  CALL  ,(ECODE,NAMEPTR,NAMELEN,VALUEPTR,VALUELEN,TOKEN),       +\n               VL,MF=L             PARM LIST FOR IKJCT441.\n         SPACE 1\nIDATE    DC    PL3'00',X'000000'\nTOKEN    DC    A(0)                TOKEN FOR MULTIPLE CALLS.\nECODE    DC    A(TSVELOC)          ENTRY CODE: RETURN ALL VARIABLES.\n         TITLE '- MAPPING DSECT MACROS.'\n         PRINT NOGEN\n         IKJTSVT\n         CVT   DSECT=YES\n         IKJCPPL\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUMPV$": {"ttr": 2820, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00A\\x01\\x01\\x05O\\x01\\x18\\x04O\\x01\\x00\\x00\\x1d\\x00\\x1c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2001-02-23T00:00:00", "modifydate": "2018-02-13T01:00:41", "lines": 29, "newlines": 28, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.JRB.MACLIB.ASM   (FILE 423)\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(DUMPV)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(1)\n SETSSI  CB496423\n NAME    DUMPV(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FINDEM": {"ttr": 2822, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00X\\x00\\x813_\\x01\\x18\\x04O\\x01X\\x00\\xc9\\x00\\xb1\\x00\"\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1981-12-01T00:00:00", "modifydate": "2018-02-13T01:58:58", "lines": 201, "newlines": 177, "modlines": 34, "user": "BROIDO"}, "text": "FINDEM   TITLE 'GDG VOLSER DISPLAY PROGRAM'\n*%A RENT SERV\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  COPYRIGHT (C) 1980 BY JAMES L. LANDERS.   ALL RIGHTS RESERVED.     *\n*                                                                     *\n*  LICENSE IS HEREBY GRANTED TO PERSHING SYSTEMS, INCORPORATED        *\n*  NEW YORK, NEW YORK AND ITS AFFILIATES TO USE THIS                  *\n*  PROGRAM.  HOWEVER, IT MUST NOT BE SOLD, GIVEN, OR OTHERWISE        *\n*  DISTRIBUTED TO ANY OTHER COMPANY OR DATA CENTER WITHOUT PRIOR      *\n*  WRITTEN PERMISSION OF:                                             *\n*                                                                     *\n*                                  BROIDO COMPUTER CONSULTING         *\n*                                  broidoj@gmail.com                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*    THIS  PROGRAM WILL DISPLAY VOLSERS OF ALL CATALOGUED LEVELS      *\n*                 OF A GDG.                                           *\n*                                       JAMES L. LANDERS              *\n*                                       J&J - RARITAN                 *\n*                                                                     *\n*    CHANGED TO PREVENT LOOP IF DATASET IS NOT A GDG.  11/12/81   KTB *\n*    DROP QUOTES IN DSNAME                             11/12/81   KTB *\n*    CHANGED TO ELIMINATE SILLY MESSAGES.  12/29/81, J. BROIDO, AIG   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nFINDEM   CSECT\n         REGS                          EQUATE REGS\n         STM   R14,R12,12(R13)         SAVE HIS REGS\n         LR    R12,R15                 ESTABLISH BASE\n         LR    R3,R1                   LOAD POINTER TO PARAMETER\n         USING FINDEM,R12\n         GETMAIN  R,LV=DYNL            GET STORAGE\n         ST    R1,4(,R13)              GIVE HIM ADDRESS OF MY SAVAREA\n         ST    R13,4(,R1)              POINT TO HIS SAVAREA\n         LR    R13,R1                  POINT GPR 13 TO MY SAVAREA\n         USING DYN,R13\n         MVI   FLAG,X'00'              SET FLAG\n         MVC   NONEMSG(71),NMSG        INITIALIZE MESSAGE\nLOAD8    L     R8,0(,R3)               LOAD ADDRESS OF PARAMETER\nLOAD4    LH    R4,0(,R8)               LOAD LENGTH OF PARAMETER\n         SH    R4,=H'4'                SUBTRACT FIRST WORD\n         SH    R4,2(,R8)               SUBTRACT OFFSET\nPIGGY    AH    R8,2(,R8)               ADD OFFSET TO PARM ADDRESS\n         AH    R8,=H'4'                ADD LENGTH OF FIRST WORD\n*                                      GPR8 NOW POINTS TO BEGINNING\n*                                      OF DSNAME FIELD AND GPR4\n*                                      CONTAINS THE LENGTH\n*\n*\n         C     R4,=F'0'                IS THERE NO PARM\n         BE    TELLEM                  IF SO ASK FOR ONE\n         CLI   0(R8),X'7D'             Q. IS DSNAME WITHIN QUOTES? KTB\n         BNE   TQUOTE                  -YES.  CHECK TRAILING QUOTE KTB\n         LA    R8,1(,R8)               DROP THE LEADING QOUTE      KTB\n         BCTR  R4,0                    REDUCE THE LENGTH           KTB\nTQUOTE   LA    R7,0(R4,R8)             POINT PAST LAST BYTE IN DSN KTB\n         BCTR  R7,0                    BACKUP TO LAST BYTE         KTB\n         CLI   0(R7),X'7D'             Q. DO WE HAVE AN END QUOTE? KTB\n         BNE   LOAD5                   -NO. THEN CONTINUE          KTB\n         BCTR  R4,0                    REDUCE THE LENGTH AGAIN     KTB\nLOAD5    LA    R5,DSAREA               LOAD ADDRESS OF DSN\n         SR    R7,R7                   ZERO OUT GPR7\n         MVC   DSAREA(44),BLANKS       BLANK OUT DSAREA\n         BCTR  R4,R0                   TAKE AWAY ONE\n         EX    R4,MOVEM                MOVE INPUT TO DSAREA\n         EX    R4,OREM                 UPPERCASE INPUT\n         LA    R4,1(,R4)               PUT ONE BACK\n         SR    R2,R2                   ZERO OUT GPR2\nLOC      LA    R6,RESULT               LOAD ADDRESS OF RESULT AREA\n         LA    R5,DSAREA               LOAD ADDRESS OF DSN\n         MVC   LOCLIST(LOCMODL),LOCMOD MOVE MODEL TO DSECT\n         LA    R1,DSAREA               POINT TO DSAREA\n         ST    R1,LOCLIST+4            STORE ADDRESS OF DSAREA\n         LA    R1,RESULT               POINT TO RESULT\n         ST    R1,LOCLIST+12           STORE ADDRESS OF RESULT\n         LOCATE LOCLIST                LOCATE DSAREA\n         AR    R5,R4                   POINT GPR5 TO END OF DSNAME\nCC       C     15,=F'0'                CHECK FOR VALID CC\n         LA    2,1(,2)                 INCREMENT LOCATE COUNTER\n         BNE   THATSIT                 BRANCH IF INVALID\n         C     R2,=F'2'                IS MORE THAN THE SECOND TIME ?\n         BL    NONGDG                  IF NOT BRANCH\nBONZO    LH    R10,0(6)                INSERT # OF VOLS INTO GPR 10\n         MVC   LINE+6(44),DSAREA       MOVE ABSOLUTE GEN TO OUTPUT LINE\n         LA    R1,LINE                 POINT TO BUFFER\n         TPUT  (1),50                  PUT DSNAME TO TERMINAL\n         OI    FLAG,DISP               TURN ON FLAG\n         LA    R3,7                    LOAD GPR 3 WITH MAX VOLSERS\n         LA    R9,LINE2                LOAD ADDRESS OF LINE2\nMOVIT    BCT   R3,MOVEVOL              BRANCH IF LINE\n         B     NEXTLINE                               IS FULL\nBACKUP   LA    R3,7                    LOAD GPR 3 WITH MAX VOLSERS\nMOVEVOL  MVC   4(6,R9),6(6)            MOVE VOLSER TO OUTPUT LINE\n         LA    R9,10(,R9)              INCREMENT OUTPUT LINE POINTER\n         LA    R6,12(,R6)              INCREMENT RESULT AREA POINTER\n         BCT   R10,MOVIT               BRANCH WHEN NUMBER OF VOLUMES\n         LA    R1,LINE2                POINT TO BUFFER\n         TPUT  (1),78                  PUT VOLSER(S) TO TERMINAL\n         TM    FLAG,NGDG               Q. IS THIS A NON-GDG DATASET?\n         BO    NOMORE                  -YES. LOOK NO MORE          KTB\n         MVI   LINE2,X'40'             MOVE BLANKS TO\n         MVC   LINE2+1(77),LINE2                      OUTPUT LINE\nGENERATE LA    R11,UGEN                POINT TO UNPACKED GENERATION\n         CVD   R7,PGEN                 CONVERT GEN TO DECIMAL\n         LA    R7,1(,R7)               INCREMENT GENERATION POINTER\n         UNPK  UGEN(16),PGEN(8)        UNPACK RELATIVE GEN\n         OI    UGEN+15,X'F0'           CLEAR SIGN\n         CLC   UGEN(16),=16X'F0'       IS IT ALL ZEROES ?\n         LA    R3,UGEN+1               POINT TO UGEN+1\n         BE    ZEROES                  IF SO ....BRANCH\nTEST     CLI   0(R11),X'F0'            IS IT A ZERO\n         LA    R11,1(,R11)             INCREMENT COUNTER\n         BE    TEST                    IF NOT -- NEXT CHARACTER\n         SR    R11,R3                  DETERMINE # OF ZEROES\nUPTHERE  S     R3,=F'1'                POINT TO UGEN\n         LR    R8,R3                   POINT GPR8 TO BEGINNING OF GEN\n         AR    R8,R11                  POINT GPR8 TO FIRST NON-ZERO\n         S     R11,=F'16'              SUBTRACT TOTAL # OF CHARACTERS\n         LPR   R11,R11                 MAKE IT POSITIVE\n         LR    R3,R4                   LOAD LENGTH INTO GPR7\n         S     R3,=F'44'               SUBTRACT TOTAL FIELD LENGTH\n         LPR   R3,R3                   MAKE IT POSITIVE\n         BCTR  R3,R0                   TAKE ONE AWAY\n         MVI   0(R5),X'40'             BLANK OUT END\n         EX    R3,BLANKO                     OF DSNAME\n         MVC   0(2,R5),=C'(-'          MOVE (- AFTER DSN\n         LA    R5,2(,R5)               INCREMENT POINTER AT END OF DSN\n         EX    R11,MOVER               MOVE RELATIVE GEN TO DSN\n         AR    R5,R11                  INCREMENT DSN POINTER\n         MVI   0(R5),C')'              MOVE ) TO END OF DSN\n         LA    R11,2(,R11)             INCREMENT LENGTH POINTER\n         SR    R5,R11                  SET POINTER BACK\n         MVC   LINE(6),0(R5)           MOVE RELATIVE GEN TO OUTPUT\nBACK     B     LOC\nZEROES   L     R11,=F'15'              SET # OF LEADING ZEROES TO 15\n         B     UPTHERE                 BRANCH BACK AFTER CALCULATION\nNEXTLINE LA    9,LINE2                 LOAD ADDRESS OF OUTPUT LINE 2\nPUTOUT   LA    R1,LINE2\n         TPUT  (1),78\n         MVI   LINE2,X'40'             MOVE BLANKS TO\n         MVC   LINE2+1(77),LINE2                      OUTPUT LINE\n         B     BACKUP\nNONGDG   VTPUT 'This file is not a  GDG.'\n         OI    FLAG,NGDG               TURN NON-GDG FLAG ON\n         B     BONZO\nTHATSIT  C     2,=F'01'\n         BH    NONE\n         B     GENERATE\n*OMORE   VTPUT '...and there aint no more.'\nNOMORE   EQU   *                                                   JRB\n         SR    R15,R15                 LOAD GPR15 WITH CLEAN CC\nX        LR    R3,R15                  STORE CC\n         LR    R1,R13                  LOAD STORAGE ADDRESS\n         L     R13,4(,R13)             POINT TO HIS SAVAREA\n         FREEMAIN R,LV=DYNL,A=(1)      FREE VIRTUAL STORAGE\n         LR    R15,R3                  RESTORE CC\n         LM    R0,R12,20(R13)          RESTORE HIS REGS\n         L     R14,12(,R13)            RESTORE GPR14\n         BR    14                      RETURN\nTELLEM   VTPUT 'You must supply a DSNAME. Try again, please.'\n         LH    R15,=H'8'               LOAD GPR15 WITH BAD CC\n         B     X\nNONE     TM    FLAG,DISP               HAS A DSN BEEN DISPLAYED ?\n         BNZ   NOMORE                  IF SO, BRANCH\n         MVC   NONEDS,DSAREA           PUT DSNAME INTO MESSAGE\n         LA    R1,NONEMSG              POINT TO MESSAGE FOR TPUT\n         TPUT  (R1),L'NONEMSG          TELL THE OPERATOR\n         LH    R15,=H'4'               LOAD BAD CC\n         B     X\nOREM     OC    DSAREA(*-*),BLANKS      UPPERCASE 'EM\nMOVEM    MVC   0(*-*,5),0(8)           MOVE INPUT PARAMETER TO DSAREA\nMOVER    MVC   0(*-*,5),0(8)           MOVE INPUT PARAMETER TO DSAREA\nBLANKO   MVC   1(*-*,5),BLANKS\nNMSG     DC    CL69'There are no entries for '\nBLANKS   DC    44C' '\nLOCMOD   CAMLST NAME,0,,0\nLOCMODL  EQU   *-LOCMOD\nDYN      DSECT\n         DS    9D\nUGEN     DS    CL16\nNONEMSG  DS    CL71                    DSN NOT FOUND MESSAGE       KTB\nNONEDS   EQU   NONEMSG+27,44\nPGEN     DS    PL8\nLOCLIST  CAMLST NAME,0,,0\nDSAREA   DS    CL44\n         DS    0D\nRESULT   DS    CL266\nLINE     DS    CL44\nLINE2    DS    CL240\nFLAG     DS    X                                                   KTB\nDISP     EQU   X'80'                   AT LEAST ONE FOUND          KTB\nNGDG     EQU   X'40'                   ON IF A NON-GDG             KTB\nDYNL     EQU   *-DYN\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FINDEM$": {"ttr": 2826, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00&\\x01\\x01\\x05O\\x01\\x18\\x04O\\x01W\\x00\\x1d\\x00\\x1c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "2001-02-23T00:00:00", "modifydate": "2018-02-13T01:57:26", "lines": 29, "newlines": 28, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.JRB.MACLIB.ASM   (FILE 423)\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(FINDEM)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET,RENT'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(1)\n SETSSI  CB496423\n NAME    FINDEM(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FIXSMPL$": {"ttr": 2828, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00Y\\x01\\x01\\x05O\\x01\\x18\\x04O\\x111\\x00\\x1d\\x00\\x1c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2001-02-23T00:00:00", "modifydate": "2018-02-13T11:31:59", "lines": 29, "newlines": 28, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.JRB.MACLIB.ASM   (FILE 423)\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(FIXSMPLG)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(0)\n SETSSI  CB496423\n NAME    FIXSMPLG(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FIXSMPLG": {"ttr": 2830, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00 \\x00\\x864?\\x01\\x18\\x04O\\x110\\x00;\\x002\\x00\\x17\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-12-09T00:00:00", "modifydate": "2018-02-13T11:30:20", "lines": 59, "newlines": 50, "modlines": 23, "user": "SBGOLOB"}, "text": "FIXSMPLG TITLE 'ONE SHOT PROGRAM TO FIX SMPLOG.'\n***********************************************************************\n*                                                                     *\n*    FIXSMPLG - PROGRAM TO FIX A HOPEFULLY UNCOMMON PROBLEM           *\n*        PLAGUEING OUR SMPLOG DATASET.  THE DATASET IS SUPPOSED       *\n*        TO BE VB, 3200, 260.  BUT SOME OF IT, IN THE MIDDLE, IS      *\n*        UNBLOCKED.  THIS PROGRAM WILL TAKE AS INPUT, ON DDNAME       *\n*        IN, THE BAD DATASET, DETERMINE WHICH RECORDS ARE BLOCKED     *\n*        AND WHICH ARE NOT, AND COPY THE WHOLE THING TO DDNAME        *\n*        OUT.                                                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nFIXSMPLG CSECT\n         YREGS\n         USING FIXSMPLG,R15        (ESTABLISH TEMPORARY BASE).\n         B     BEGIN               SKIP OVER HEADER.\nHEAD0    DC    AL1(HEADL)          EXCLUSIVE LENGTH OF HEADER.\nHEAD     DC    C'FIXSMPLG - &SYSDATE - &SYSTIME '\nHEADL    EQU   *-HEAD\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         LR    R12,R15             COPY BASE.\n         USING FIXSMPLG,R12        (TELL ASSEMBLER).\n         LR    R14,R13             COPY CALLER'S SAVE AREA POINTER.\n         LA    R13,SAVE            POINT TO MY SAVE AREA.\n         ST    R13,8(,R14)         CHAIN ...\n         ST    R14,SAVE+4          ... SAVE AREAS.\n         SPACE 1\n         OPEN  (OUT,OUTPUT,IN)\n         GETMAIN RU,LV=32760       GET INPUT BUFFER.\n         LR    R8,R1               COPY BUFFER POINTER.\nINLUP    READ  RDECB,SF,IN,(R8)    READ BLOCK OF INPUT DATA.\n         CHECK RDECB               (WAIT FOR READ TO COMPLETE)\n         LH    R3,0(,R8)           LOAD LENGTH OF BLOCK.\n         CH    R3,=H'4'            IS LENGTH GREATER THAN 4?\n         BNH   INLUP               B IF NOT.  DISCARD NULL BLOCK.\n         LR    R4,R8               GENERATE PAST-END- ...\n         AR    R4,R3               ... OF-BLOCK ADDRESS.\n         LA    R5,4(,R8)           POINT TO FIRST LOGICAL RECORD.\nOUTLUP   CR    R5,R4               PAST END OF BLOCK?\n         BNL   INLUP               GET ANOTHER BLOCK IF YES.\n         TM    0(R5),X'80'         IS THE RDW REALLY A DATE?\n         BO    OUTLUPB             B IF YES.  NO LOGICAL RECS. IN  BLK.\n         PUT   OUT,(R5)            OUTPUT NORMAL LOGICAL RECORD.\n         AH    R5,0(,R5)           POINT TO NEXT LOGICAL RECORD.\n         B     OUTLUP              OUTPUT NEXT LOGICAL RECORD.\nOUTLUPB  PUT   OUT,(R8)            OUTPUT UN-BLOCK AS LOGICAL RECORD.\n         VTPUT 'UN-BLOCK FOUND.'\n         B     INLUP               GET ANOTHER BLOCK.\nEOD      EQU   *\nPOSTGET  SVC   3\n         TITLE 'DATA AREAS.'\nSAVE     DS    9D\nIN       DCB   DDNAME=IN,BLKSIZE=32760,RECFM=V,DSORG=PS,EODAD=EOD,     +\n               MACRF=R\nOUT      DCB   DDNAME=OUT,LRECL=260,RECFM=VB,DSORG=PS,                 +\n               MACRF=PM\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HEXPGM": {"ttr": 2832, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x011\\x00\\x00\\x00y\\x06o\\x01\\x18\\x04_\\x16T\\x00\\xf8\\x00<\\x00\\xd1\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.49", "flags": 0, "createdate": "1979-03-07T00:00:00", "modifydate": "2018-02-14T16:54:00", "lines": 248, "newlines": 60, "modlines": 209, "user": "SBGOLOB"}, "text": "HEXPGM TITLE 'HEXPGM - INPUT HEX, OUTPUT TO 327X IN ANY MODE VIA TPUT'\n*%A PPLINK NOTEST\n***********************************************************************\n*                                                                     *\n*  COPYRIGHT (C) 1979 BY JEFFREY R. BROIDO.  ALL RIGHTS RESERVED.     *\n*                                                                     *\n*  LICENSE IS HEREBY GRANTED TO WESTERN UNION INTERNATIONAL (A        *\n*  SUBSIDIARY OF MCI, INCORPORATED) AND ITS AFFILIATES TO USE THIS    *\n*  PROGRAM.  HOWEVER, IT MUST NOT BE BE SOLD, GIVEN, OR OTHERWISE     *\n*  DISTRIBUTED TO ANY OTHER COMPANY OR DATA CENTER WITHOUT PRIOR      *\n*  WRITTEN PERMISSION OF:                                             *\n*                                                                     *\n*                                  BROIDO COMPUTER CONSULTING         *\n*                                  broidoj@gmail.com                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*     HEXPGM - TEST COMMAND TO TAKE TERMINAL INPUT IN HEX CODED       *\n*           BINARY, AND OUTPUT TO THE TERMINAL IN ANY TPUT MODE.      *\n*                                                                     *\n*   Modifications:                                                    *\n*                                                                     *\n*   2018/02/14 -  S.Golob                                             *\n*   0.  Change title to HEXPGM so as not to interfere with other      *\n*         programs.  (Originally it was called HEX.)                  *\n*   1.  Provide more \"escape routes\":  BYE, QUIT, END, besides /*     *\n*   2.  Allow question mark \"?\" as HELP.                              *\n*       (HELP shows the terminal control modes.)                      *\n*   3.  Abbreviate HELP to HEL and HE.                                *\n*   4.  Add to program title display, at initial execution,           *\n*       to better explain the program's purpose to the user.          *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nHEXPGM   CSECT\n         REGS\n         USING HEXPGM,R15          (ESTABLISH TEMPORARY BASE).\n         B     BEGIN               SKIP OVER HEADER.\nHEAD0    DC    AL1(HEADL)          EXCLUSIVE LENGTH OF HEADER.\nHEAD     DC    C' HEXPGM - &SYSDATE - &SYSTIME -'\n         DC    C'COPYRIGHT (C) BROIDO COMPUTER CONSULTING '\n         DC    C'1979 - '\n         DC    C'ALL RIGHTS RESERVED'\nHEADL    EQU   *-HEAD\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)\n         USING HEXPGM,R12\n         LR    R12,R15\n         LA    R2,SAVE\n         ST    R2,8(,R13)\n         ST    R13,SAVE+4\n         LR    R13,R2\n         ST    R12,BSAVE           SAVE BASE.\n         SPACE 1\n         MVI   TOPT,X'34'\n         VTPUT 'Interpret HEX characters and write them to the'\n         VTPUT '  terminal in any of several modes. '\n         VTPUT '  Enter  ? or HElp         for help.'\n         VTPUT '  /*, BYE, QUIT, or END     to exit.'\n         VTPUT '   '\n         VTPUT 'Enter HEX characters, COMMAND, HELP, /* TO EXIT.'\nLUP      TGET  BUFFER,L'BUFFER     GET BUFFER FULL OF HEX.\n         OC    BUFFER(8),=CL8' '   Uppercase....\n         LTR   R2,R1               EMPTY?\n         BNZ   NOTEMPTY            B IF NO.\n         TM    FLAG,VALID          BUFFER IS VALID?\n         BZ    LUP                 B IF YES.\n         B     TPUT                OUTPUT IT.\nNOTEMPTY DS    0H\n         CLC   =C'?',BUFFER        DO WE WANT HELP?\n         BE    HELTEXT             PUT OUT HELP INSTRUCTIONS\n         CLC   =C'BYE',BUFFER      PROVIDE\n         BE    END                   MORE\n         CLC   =C'END',BUFFER          ESCAPE\n         BE    END                       ROUTES\n         CLC   =C'QUIT',BUFFER             ******\n         BE    END                           ******\n* --------------------------------------------------------------- *\n*  At this point, we do not want to allow one hexadecimal digit.  *\n* --------------------------------------------------------------- *\n         CH    R1,=H'2'            COMPARE TO 2. HEX NUMBERS LENGTH=2.\n         BL    INVPARM             ERROR IF LEN 1.\n         BH    SPECIAL             CHECK SPECIAL COMMANDS.\n         CLC   =C'/*',BUFFER       LEN = 2; CHECK FOR END.\n         BE    END                 B IF END.\nSPECIAL  CLC   =C'ASIS',BUFFER     ASIS?\n         BNE   NOTASIS             B IF NOT.\n         NI    TOPT,X'FC'          SET ...\n         OI    TOPT,X'01'          ASIS.\n         VTPUT '\"ASIS\" output mode set.'\n         B     LUP                 GET NEW INPUT.\nNOTASIS  CLC   =C'CONTROL',BUFFER  CONTROL?\n         BNE   NOTCNTL             B IF NOT.\n         NI    TOPT,X'FC'          SET...\n         OI    TOPT,X'02'          ... CONTROL.\n         VTPUT '\"CONTROL\" output mode set.'\n         B     LUP                 GET NEW INPUT.\nNOTCNTL  CLC   =C'FULLSCR',BUFFER  FULLSCREEN?\n         BNE   NOTFULL             B IF NOT.\n         OI    TOPT,X'03'          SET FULLSCR.\n         VTPUT '\"FULLSCR\" output mode set.'\n         B     LUP                 GET NEW INPUT.\nNOTFULL  CLC   =C'NORMAL',BUFFER   NORMAL?\n         BNE   NOTNORM             B IF NOT.\n         NI    TOPT,X'FC'          SET NORMAL OUTPUT MODE.\n         VTPUT '\"NORMAL\" output mode set.'\n         B     LUP                 GET NEW INPUT.\nNOTNORM  CLC   =C'USER ',BUFFER    DIRECTED OUTPUT?\n         BNE   NOTUSER             B IF NOT.\n         CLI   BUFFER+5,C'*'       USER YOU?\n         BNE   U0                  B IF NOT.\n         NI    FLAG,X'FF'-USER     RESET FLAG.\n         VTPUT 'User reset to you.'\n         B     LUP                 LOOP.\nU0       MVC   USERID,BUFFER+5     UNSOPHISTICATED MOVE.\n         OC    USERID,=CL8' '      UPPERCASE IT.\n         OI    FLAG,USER           SET FLAG.\n         MVC   UM1,USERID          MOVE USERID.\n         TPUT  M1,M1L              SAY: USER RESET TO XXXXXXXX.\n         B     LUP                 LOOP.\nNOTUSER  CLC   =C'POP',BUFFER      POP?\n         BNE   NOTPOP              NO.\n         OI    FLAG,POP            SET POP FLAG.\n         VTPUT 'Pop it is.'        OY.\n         B     LUP                 LOOP.\nNOTPOP   CLC   =C'HELP',BUFFER     HELP?\n         BE    HELTEXT             B IF NOT.\n         CLC   =C'HEL',BUFFER      ABBREVIATE 'HELP'\n         BE    HELTEXT\n         CLC   =C'HE',BUFFER       ABBREVIATE 'HELP'\n         BE    HELTEXT\n         B     CONVERT\nHELTEXT  DS    0H\n         VTPUT 'Enter:  /* to exit.'\n         VTPUT '        FULLSCR for fullscr mode.'\n         VTPUT '        NORMAL for normal mode.'\n         VTPUT '        ASIS for asis mode.'\n         VTPUT '        CONTROL for control mode.'\n         B     LUP\nCONVERT  BCTR  R1,*-*              CREATE SS LENGTH\n         EX    R1,TRANSLAT         TRANSLATE BUFFER\n         LA    R1,BUFFER           POINT TO BUFFER.\n         LR    R3,R1               COPY POINTER.\n         SR    R4,R4               CLEAR VALID CHARACTER COUNTER.\nCONLUP   CLI   0(R1),X'FF'         VALID CHARACTER?\n         BE    CONBUMP             B IF NOT.\n         MVC   0(1,R3),0(R1)       MOVE A CHARACTER.\n         LA    R3,1(,R3)           BUMP OUTPUT POINTER.\n         LA    R4,1(,R4)           BUMP COUNTER.\nCONBUMP  LA    R1,1(,R1)           BUMP INPUT POINTER.\n         BCT   R2,CONLUP           CHECK ANOTHER CHARACTER.\n         LTR   R4,R4               ANYTHING VALID?\n         BZ    INVPARM             B IF NOT.\n         EX    R4,TESTEVEN         EVEN NUMBER OF CHARACTERS?\n         BNO   INVPARM             B IF NOT.\n         LA    R9,BUFFER           POINT TO BUFFER.\n         LA    R10,BUFFOUT         POINT TO OUTPUT.\n         SRL   R4,1                CREATE OUTPUT LENGTH\n         LR    R5,R4               TRANSFER LENGTH.\nPLUP     IC    R1,0(,R9)           LOAD EVEN CHARACTER.\n         SLL   R1,4                SHIFT TO HIGH BYTE.\n         EX    R1,OR               OR IT WITH NEXT BYTE.\n         MVC   0(1,R10),1(R9)      MOVE CHAR TO OUTPUT.\n         LA    R9,2(,R9)           BUMP INPUT.\n         LA    R10,1(,R10)         BUMP OUTPUT.\n         BCT   R5,PLUP             LOOP.\n         OI    FLAG,VALID          VALIDATE BUFFOUT.\nTPUT     TM    FLAG,USER           DIRECTED OUTPUT?\n         BO    TPUT0               B IF YES.\n         NI    TOPT,X'BF'          OFF TOPT USERIDL FLAG.\n         B     TPUT1               CONT.\nTPUT0    OI    TOPT,X'40'          ON TOPT USERIDL FLAG.\n         LA    R15,USERID          POINT TO USERID.\nTPUT1    TPUT  BUFFOUT,(R4),ASIS   OUTPUT IN BINARY.\nTOPT     EQU   *-12                TPUT OPTION FLAG (WATCH IT!).\n         LTR   R15,R15             ALL OK?\n         BNZ   TPUT2               B IF YES.\n         TM    FLAG,POP            SHALL WE POP?\n         BZ    LUP                 NOPE.\n         XC    ECB,ECB             CLEAR ECB.\n         LA    R1,STAXLIST         SET ...\n         STAX  ATTNEXIT,MF=(E,(1)) ... ATTN EXIT.\n         STIMER REAL,TEXIT,BINTVL=INT    WAIT.\n         WAIT  ECB=ECB\n         TM    ECB+2,1             POSTED BY TIMER EXIT?\n         BO    TPUT                YES. OUTPUT IT AGAIN.\n         STAX  ,                   NO. CANCEL STAX.\n         B     LUP                 GET ANOTHER CMD.\nTPUT2    MVC   UM2,USERID          MOVE USERID.\n         TPUT  M2,M2L              SAY: XXXXXXXX NOT AT HOME.\n         NI    FLAG,X'FF'-USER-POP RESET USER OPTION.\n         B     LUP                 CONT.\nINVPARM  VTPUT 'INVALID PARM.'\n         B     LUP                 GET ANOTHER BUFFER.\nEND      VTPUT 'BYE!'\n         L     R13,SAVE+4\n         LM    R14,R12,12(R13)\n         SR    R15,R15\n         BR    R14\n         SPACE 1\n         USING *,R15\nATTNEXIT L     R12,BSAVE           RELOAD BASE.\n         LR    R5,R14              PRESERVE RTN.\n         DROP  R15\n         NI    FLAG,X'FF'-POP      OFF POP FLAG.\n         POST  ECB                 POST THE ECB.\n         BR    R5                  RETURN.\n         USING *,R15\nTEXIT    L     R12,BSAVE\n         DROP  R15\n         LR    R5,R14\n         POST  ECB,1               POST ECB WITH SPECIAL CODE.\n         BR    R5\nSAVE     DS    9D\nBSAVE    DS    A                   BASE SAVE AREA FOR STAX.\nBUFFER   DS    CL255               INPUT BUFFER.\nBUFFOUT  DS    CL128               OUTPUT BUFFER\nUSERID   DS    CL8                 USERID FOR DIRECTED TPUT.\n         SPACE 1\nFLAG     DC    X'00'               FLAGS.\nVALID    EQU   B'10000000'         BUFFER IS VALID.\nUSER     EQU   B'01000000'         DIRECTED TPUT.\nPOP      EQU   B'00100000'         POP FLAG.\n         SPACE 1\nECB      DS    F                   ECB FOR STAX, TIMER.\nINT      DC    F'1000'             10 SECOND POP RATE.\nOR       OI    1(R9),*-*           * EXECUTED *\nTRANSLAT TR    BUFFER(*-*),TAB     * EXECUTED *\nTESTEVEN TM    =X'FE',*-*          * EXECUTED *\nM1       DC    C'User set to '\nUM1      DC    CL8' '\nM1L      EQU   *-M1\nM2       EQU   *\nUM2      DC    CL8' ',C'no longer at home.  Reset to you.'\nM2L      EQU   *-M2\nSTAXLIST STAX  ATTNEXIT,MF=L\n         SPACE 1\nTAB      DC    256X'FF'            TRANSLATE TABLE\n         ORG   TAB+X'81'\n         DC    X'0A0B0C0D0E0F'\n         ORG   TAB+C'A'\n         DC    X'0A0B0C0D0E0F'\n         ORG   TAB+C'0'\n         DC    X'00010203040506070809'\n         ORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HEXPGM$": {"ttr": 3077, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00F\\x01\\x05\\x13_\\x01\\x18\\x04_\\x16$\\x00 \\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2005-05-15T00:00:00", "modifydate": "2018-02-14T16:24:46", "lines": 32, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,\n//     PARM='OBJECT,NODECK,ESD,RLD,BATCH,FLAG(5)'\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.JRB.MACLIB.ASM   (FILE 423)\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(HEXPGM)\n//SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(2,2))\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSALLDA,SPACE=(CYL,(4,4)),DISP=(,PASS),\n//            DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY   HEXPGM\n SETSSI  CB496423\n SETCODE AC(0)\n NAME    HEXPGM(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "K": {"ttr": 3079, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x18/\\x00\\x85\\x18/\\x18%\\x00\\x07\\x00\\x07\\x00\\x00\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "1985-07-01T18:25:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "BROIDO"}, "text": "         MACRO\n&N       K     ,                       IDENTICAL TO THE ERASE MACRO.\n&N       LA    0,9                     LOAD LENGTH.\n         LA    1,=X'F11140403C40400013'\n         ICM   1,8,=X'03'              SET FULLSCR OPTION.\n         SVC   93                      INVOKE TPUT.\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LAA": {"ttr": 3081, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00Q\\x00\\x92\\x19\\x1f\\x01\\x16)O\\x00\\x02\\x02C\\x00\\xea\\x01\\xe0\\xd7\\xe4\\xe3\\xd3\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1992-07-09T00:00:00", "modifydate": "2016-10-20T00:02:51", "lines": 579, "newlines": 234, "modlines": 480, "user": "PUTLINE"}, "text": "LAA      TITLE 'LAA - EXPANDED, DEFAULT-ONLY, ALLOCATION LISTER.'\n*%A PPLINK NOTEST AMODGEN\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  COPYRIGHT 1978, 1992 BY JEFFREY R. BROIDO.  ALL RIGHTS RESERVED.   *\n*                                                                     *\n*  LICENSE IS HEREBY GRANTED TO PERSHING SYSTEMS, INCORPORATED        *\n*  COMPANY, JERSEY CITY, NJ AND ITS AFFILIATES TO USE THIS            *\n*  PROGRAM.  HOWEVER, IT MUST NOT BE SOLD, GIVEN, OR OTHERWISE        *\n*  DISTRIBUTED TO ANY OTHER COMPANY OR DATA CENTER WITHOUT PRIOR      *\n*  WRITTEN PERMISSION OF:                                             *\n*                                                                     *\n*                                  BROIDO COMPUTER CONSULTING         *\n*                                  broidoj@gmail.com                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        LAA -  PROGRAM TO LIST ALLOCATION IN A FASHION SIMILAR TO    *\n*               LISTALC COMMAND.  THIS COMMAND TAKES NO OPERANDS,     *\n*               AND PRINTS THE DATASETS, WITH DDNAMES, IN A MORE      *\n*               LINEWISE-COMPACT WAY THAN LISTALC.                    *\n*                                                                     *\n*                                  JEFFREY R. BROIDO - 20 FEB 78      *\n*                                  COLGATE-PALMOLIVE, PISCATAWAY.     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        MODIFIED 1 FEB 79 AT J & J MIC TO TAKE A K OPERAND TO        *\n*                 CLEAR THE SCREEN OF A DISPLAY TUBE BEFORE           *\n*                 EXECUTION.                                          *\n*                                                 JRB                 *\n*                                                                     *\n*        MODIFIED 8 JUL 92 AT PERSHING TO WORK PROPERLY WITH          *\n*                 SWA ABOVE THE LINE.                                 *\n*                                                 JRB                 *\n*                                                                     *\n*        MACRO IHAQDB IS NOW PART OF SYS1.MODGEN.  IT DOES NOT HAVE   *\n*          TO BE INCLUDED IN THE SOURCE HERE AT THIS TIME.  SBG       *\n*                                                                     *\n***********************************************************************\n* ------------------------------------------------------------------- *\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\n*\n*        %GOTO QDBL1;  /*\n         SPACE 3\nLAA      CSECT\nLAA      AMODE 31\nLAA      RMODE 24\n         YREGS\n         USING LAA,R15             (ESTABLISH TEMPORARY BASE).\n         B     BEGIN               SKIP OVER HEADER.\nHEAD0    DC    AL1(HEADL)          EXCLUSIVE LENGTH OF HEADER.\nHEAD     DC    C' LAA - &SYSDATE - &SYSTIME -'\n         DC    C'COPYRIGHT (C) BROIDO COMPUTER CONSULTING '\n         DC    C'1978, 1992 - '\n         DC    C'ALL RIGHTS RESERVED'\nHEADL    EQU   *-HEAD\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         LR    R12,R15             COPY BASE.\n         USING LAA,R12             (TELL ASSEMBLER).\n         LR    R14,R13             COPY CALLER'S SAVE AREA POINTER.\n         LA    R13,SAVE            POINT TO MY SAVE AREA.\n         ST    R13,8(,R14)         CHAIN ...\n         ST    R14,SAVE+4          ... SAVE AREAS.\n         SPACE 1\n*              LOCATE THE DSAB QUEUE.\n         SPACE 1\n         LTR   R1,R1               ANY CPPL OR PARM POINTER?\n         BZ    LAASTART            B IF NOT.\n         L     R2,0(,R1)           POINT TO BUFFER\n         LTR   R2,R2               ANY?\n         BZ    LAASTART            B IF NOT.\n         LH    R3,0(R2)            LOAD LENGTH.\n         LTR   R3,R3               ANY?\n         BZ    LAASTART            B IF NOT.\n         CLI   2(R2),X'00'         COMMAND PROCESSOR INVOKATION?\n         BE    LAACP\n         LA    R2,2(,R2)           POINT TO PARM.\n         B     PARM\nLAACP    CH    R3,=H'4'            ANY PARM?\n         BE    LAASTART            B IF NOT.\n         AH    R2,2(,R2)           POINT TO ...\n         LA    R2,4(,R2)           ... PARM.\nPARM     OI    0(R2),C' '          UPPERCASE.\n         CLI   0(R2),C'K'          CLEAR?\n         BNE   LAASTART            B IF NOT.\n         GTSIZE\n         LTR   R0,R0               DISPLAY?\n         BZ    LAASTART            B IF NOT.\n         K     ,                   CLEAR SCREEN.\nLAASTART L     R5,X'10'            POINT TO THE CVT.\n         L     R5,0(,R5)           POINT TO TCB WORDS.\n         L     R5,0(,R5)           POINT TO MY TCB.\n         USING TCB,R5              (TELL ASSEMBLER).\n         L     R5,TCBJSCB          POINT TO MY JSCB.\n         USING IEZJSCB,R5          (TELL ASSEMBLER).\n         L     R5,JSCDSABQ         POINT TO MY QDB FOR DSAB QUEUE.\n         USING QDB,R5              (TELL ASSEMBLER).\n         L     R5,QDBFELMP         POINT TO FIRST DSAB.\n         USING DSAB,R5             (TELL ASSEMBLER).\n         MVI   OUT,X'40'           CLEAR ...\n         MVC   OUT+1(OUTLEN-1),OUT ... OUTPUT AREA\n         B     CKEND\nTLUP     L     R5,DSABFCHN         POINT TO NEXT DSAB.\nCKEND    LTR   R5,R5               END OF DSAB QUEUE?\n         BNZ   CKDD                B IF NOT\n         L     R13,SAVE+4             E\n         LM    R14,R12,12(R13)          X\n         SR    R15,R15                    I\n         BR    R14                          T\nCKDD     L     R2,DSABTIOT         POINT TO ASSOCIATED TIOT ENTRY.\n         USING TIOENTRY,R2         (TELL ASSEMBLER).\n         MVI   DISP,X'40'                CLEAR DISP, TFLAG ...\n         MVC   DISP+1(OUTEND-DISP),DISP  ... AND DSN.\n         MVC   DDN,TIOEDDNM        MOVE DDNAME\n         MVC   DEV,=CL6'Term'      MOVE DEVICE NAME OF TERM.\n         TM    TIOELINK,TIOTTERM   IS IT A TERMINAL?\n         BO    OUTPUT              B IF YES.\n         MVC   DEV,=CL6'Sysout'    MOVE DEV NAME OF SYSOUT.\n         LA    R6,EPAL             POINT TO THE EPAL.\n         USING ZB505,R6            (TELL ASSEMBLER)\n         XC    EPAL,EPAL           CLEAR THE EPAL.\n         MVC   SWVA,TIOEJFCB       MOVE TOKEN FOR JFCB TO EPAL.\n         SWAREQ FCODE=RL,EPA=EPALPTR,UNAUTH=YES,                       +\n               MF=(E,SWAPARMS)     GET ADDRESS OF JFCB.\n         L     R4,SWBLKPTR         POINT TO JFCB.\n         USING JFCB,R4             (TELL ASSEMBLER).\n         TM    TIOELINK,TIOESYOT   IS IT A SUBSYSTEM DATASET?\n         BZ    MVDSN               B IF NOT.\n         MVC   DSN(6),=C'Class='   MOVE SYSOUT CLASS GRAPHIC.\n         L     R15,X'14'(,R5)      POINT TO SIOT.\n         XC    EPAL,EPAL           CLEAR THE EPAL.\n         MVC   SWVA,DSABSSVA       MOVE TOKEN FOR SIOT TO EPAL.\n         SWAREQ FCODE=RL,EPA=EPALPTR,UNAUTH=YES,                       +\n               MF=(E,SWAPARMS)     GET ADDRESS OF SIOT.\n         L     R15,SWBLKPTR        POINT TO SIOT.\n         DROP  R15\n         USING INDMSIOT,R15        (TELL ASSEMBLER).\n         MVC   DSN+6(1),SCTOUTPN   MOVE SYSOUT CLASS FROM SIOT.\n         DROP  R15\n         B     OUTPUT              CONTINUE.\nMVDSN    MVC   DSN,JFCBDSNM        MOVE DATASET NAME.\n         CLC   =C'NULLFILE ',DSN   DUMMY DATASET?\n         BNE   MVVOL               B IF NOT.\n         MVC   DEV,=CL6'Dummy'     MOVE DUMMY GRAPHIC.\n         B     CKTCAM              CONTINUE.\nMVVOL    MVC   DEV,JFCBVOLS        MOVE VOLUME NAME.\nCKTCAM   TM    TIOELINK,TIOTREM    TCAM?\n         BZ    CKVIO               B IF NOT\n         MVC   DSN(11),=C'TCAM Queue:'\n         MVC   DEV,=CL6'Queue'     MOVE DEV NAME OF QUEUE (TCAM).\n         MVC   DSN+12(8),JFCBDSNM  MOVE DATASET NAME AGAIN.\n         B     OUTPUT              CONT.\nCKVIO    TM    JFCFLGS1,JFCVRDS    VIO DATASET?\n         BZ    GETUNIT             B IF NOT.\n         MVC   DEV,=CL6'Vio'       MOVE VIO GRAPHIC.\n         B     CKVTOC              CONT.\nGETUNIT  CLC   DEV,=CL6' '         HAS DEVICE FIELD BEEN FILLED?\n         BNE   CKVTOC              B IF YES.\n         SR    R1,R1               LOAD ...\n         ICM   R1,7,TIOEFSRT       ... POINTER TO UCB.\n         USING UCBCMEXT,R1         (TELL ASSEMBLER)\n         MVC   DEV,=CL6'(###)'     MOVE DEVICE GRAPHIC.\n         MVC   DEV+1(3),UCBNAME    MOVE DEVICE ADDRESS.\n         DROP  R1,R2\nCKVTOC   CLI   DSN,X'04'           IS THIS THE DSN FOR VTOC?\n         BNE   CKDISP              B IF NOT.\n         MVC   DSN,=CL44'           -- Volume Table of Contents --'\nCKDISP   MVC   DISP,=C'SHR'        MOVE SHR GRAPHIC.\n         TM    JFCBIND2,JFCSHARE   SHARED?\n         BO    CKTEMP              B IF YES\n         MVC   DISP,=C'NEW'        MOVE NEW GRAPHIC.\n         TM    JFCBIND2,JFCNEW     TEST OLD-NEW BITS.\n         BO    CKTEMP              B IF NEW.\n         MVC   DISP,=C'OLD'        MOVE OLD GRAPHIC.\n         TM    JFCBIND2,JFCOLD     OLD?\n         BO    CKTEMP              B IF YES.\n         MVC   DISP,=C'MOD'        MOVE MOD GRAPHICS.\nCKTEMP   TM    DSABFLG1,DSABPALC   PERMANENT ALLOCATION?\n         BO    NOTTEMP             B IF YES.\n         MVI   TFLAG,C'*'          MOVE TEMP. ALLOCATION FLAG.\nNOTTEMP  CLI   JFCBELNM,C' '       MEMBER OR GENERATION?\n         BE    OUTPUT              B IF NOT.\nMEM      LA    R1,8                LD MAX MEMBER LEN FOR BCT.\n         LA    R2,JFCBELNM         PT TO MEMBER.\nMEMLUP   CLI   0(R2),C' '          CHAR BLANK?\n         BE    MEMLCALC            B IF YES.\n         LA    R2,1(,R2)           BUMP POINTER.\n         BCT   R1,MEMLUP\nMEMLCALC LA    R3,8                CALC ...\n         SR    R3,R1               ... MEMBER LENGTH.\n         LA    R1,76-(OUT-DSN)     GENERATE ...\n         SR    R1,R3               ... DSN SCAN INDEX.\n         LA    R2,DSN              POINT TO DSN.\nDFBLUP   CLI   0(R2),C' '          CHAR BLANK?\n         BE    DFBSET              B IF YES.\n         LA    R2,1(,R2)           BUMP POINTER.\n         BCT   R1,DFBLUP           LOOK AT ANOTHER CHAR.\n         B     OUTPUT              NO ROOM FOR MEMBER.  SKIP IT.\nDFBSET   MVI   0(R2),C'('          MOVE PAREN.\n         EX    R3,MVMEMB           MOVE MEMBER (+ ONE CHAR).\n*      ( MVC   1(*-*,R2),JFCBELNM  )\n         LA    R2,0(R2,R3)         BUMP PTR.\n         MVI   1(R2),C')'          MOVE PAREN.\nOUTPUT   APUT  OUT,OUTLEN          OUTPUT LINE\n         B     TLUP                LOOP.\nSAVE     DS    9D\nMVMEMB   MVC   1(*-*,R2),JFCBELNM  *** EXECUTED ***\nOUT      EQU   *\nDDN      DS    CL8,3X\nDEV      DS    CL6,3X\nDISP     DS    CL3,2X\nTFLAG    DS    C\nDSN      DS    CL44\nOUTEND   EQU   *\nOUTLEN   EQU   *-OUT\n         SPACE 1\nPOOP     DC    X'00'               BUFFER.\nEPALPTR  DC    A(EPAL)             POINTER TO EPAL.\nEPAL     DS    CL28                EPAL.\nSWAPARMS SWAREQ MF=L               SWAREQ PARMS\n         TITLE '- MAPPING MACROS.'\n         IEFZB505 LOCEPAX=YES      MAP THE EPAL.\n         CVT   DSECT=YES           MAP THE CVT.\n         IEFJESCT                  MAP THE JESCT.\n         IEZJSCB                   MAP THE JSCB.\n         IKJTCB                    MAP THE TCB.\n         IHAQDB                    MAP THE QDB.\n         IHADSAB                   MAP THE DSAB.\n         IEFTIOT1                  MAP THE TIOT.\nJFCB     DSECT\n         IEFJFCBN                  MAP THE JFCB.\n         IEFASIOT                  MAP THE SIOT.\n         IEFUCBOB                  MAP THE UCB.\n         END   LAA\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUEMNTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   255                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         EJECT\n         IHAPSA   LIST=YES                                     HD APR88\n         EJECT                                                 HD APR88\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   14,12,12(13)       SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES            RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    1,8(13)            OUR SAVE AREA POINTER\n         ST    13,4(1)            POINTER TO CALLERS SAVE AREA\n         LR    13,1               @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(R13)         POINT TO CALLERS RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 ASSUME BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 ASSUME BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(RML)               MESSAGE LENGTH\n         STH   R15,PUTLEN                 PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    2,R13                    @OUR SAVE AREA\n         LR    3,R15                    SAVE RETURN CODE\n         L     R13,4(R13)               @CALLERS SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,3                    RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END   EPUTL\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LAA$": {"ttr": 3334, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x009\\x01\\x05\\x13_\\x01\\x16)?\\x14E\\x00 \\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2005-05-15T00:00:00", "modifydate": "2016-10-19T14:45:39", "lines": 32, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,\n//     PARM='OBJECT,NODECK,ESD,RLD,BATCH,FLAG(5)'\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.JRB.MACLIB.ASM   (FILE 423)\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(LAA)\n//SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(2,2))\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSALLDA,SPACE=(CYL,(4,4)),DISP=(,PASS),\n//            DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY   LAA\n SETSSI  CB493423\n SETCODE AC(0)\n NAME    LAA(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LAAOLD": {"ttr": 3336, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x005\\x00\\x85\\x18/\\x01\\x13\\x13/\\x15\\x00\\x00\\xbe\\x00\\xbf\\x00L\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "2013-05-12T15:00:35", "lines": 190, "newlines": 191, "modlines": 76, "user": "BROIDO"}, "text": "LAA      TITLE 'LAA - EXPANDED, DEFAULT-ONLY, ALLOCATION LISTER.'\n*%A PPLINK NOTEST\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  COPYRIGHT (C) 1978 BY BROIDO COMPUTER CONSULTING.  ALL RIGHTS      *\n*  RESERVED EXCEPT:                                                   *\n*                                                                     *\n*  PARTICULAR LICENSE IS GRANTED TO DISTRIBUTE THIS PROGRAM FREE      *\n*  OF CHARGE, BUT IT MUST NOT BE SOLD.  A SERVICE CHARGE FOR          *\n*  HANDLING A COLLECTION OF SOFTWARE OF WHICH THIS IS A PART,         *\n*  ON THE OTHER HAND, IS APPROPRIATE.                                 *\n*                                                                     *\n*                                  BROIDO COMPUTER CONSULTING         *\n*                                  broidoj@gmail.com                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        LAA -  PROGRAM TO LIST ALLOCATION IN A FASHION SIMILAR TO    *\n*               LISTALC COMMAND.  THIS COMMAND TAKES NO OPERANDS,     *\n*               AND PRINTS THE DATASETS, WITH DDNAMES, IN A MORE      *\n*               LINEWISE-COMPACT WAY THAN LISTALC.                    *\n*                                                                     *\n*                                  JEFFREY R. BROIDO - 20 FEB 78      *\n*                                  COLGATE-PALMOLIVE, PISCATAWAY.     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        MODIFIED 1 FEB 79 AT J & J MIC TO TAKE A K OPERAND TO        *\n*                 CLEAR THE SCREEN OF A DISPLAY TUBE BEFORE           *\n*                 EXECUTION.                                          *\n*                                  JRB                                *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nLAA      CSECT\n         REGS\n         USING LAA,R15             (ESTABLISH TEMPORARY BASE).\n         B     BEGIN               SKIP OVER HEADER.\nHEAD0    DC    AL1(HEADL)          EXCLUSIVE LENGTH OF HEADER.\nHEAD     DC    C' LAA - &SYSDATE - &SYSTIME -'\n         DC    C'COPYRIGHT (C) BROIDO COMPUTER CONSULTING '\n         DC    C'1978 - '\n         DC    C'ALL RIGHTS RESERVED'\nHEADL    EQU   *-HEAD\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         LR    R12,R15             COPY BASE.\n         USING LAA,R12             (TELL ASSEMBLER).\n         LR    R14,R13             COPY CALLER'S SAVE AREA POINTER.\n         LA    R13,SAVE            POINT TO MY SAVE AREA.\n         ST    R13,8(,R14)         CHAIN ...\n         ST    R14,SAVE+4          ... SAVE AREAS.\n         SPACE 1\n*              LOCATE THE DSAB QUEUE.\n         SPACE 1\n         LTR   R1,R1               ANY CPPL OR PARM POINTER?\n         BZ    LAASTART            B IF NOT.\n         L     R2,0(,R1)           POINT TO BUFFER\n         LTR   R2,R2               ANY?\n         BZ    LAASTART            B IF NOT.\n         LH    R3,0(R2)            LOAD LENGTH.\n         LTR   R3,R3               ANY?\n         BZ    LAASTART            B IF NOT.\n         CLI   2(R2),X'00'         COMMAND PROCESSOR INVOKATION?\n         BE    LAACP\n         LA    R2,2(,R2)           POINT TO PARM.\n         B     PARM\nLAACP    CH    R3,=H'4'            ANY PARM?\n         BE    LAASTART            B IF NOT.\n         AH    R2,2(,R2)           POINT TO ...\n         LA    R2,4(,R2)           ... PARM.\nPARM     OI    0(R2),C' '          UPPERCASE.\n         CLI   0(R2),C'K'          CLEAR?\n         BNE   LAASTART            B IF NOT.\n         GTSIZE\n         LTR   R0,R0               DISPLAY?\n         BZ    LAASTART            B IF NOT.\n         K     ,                   CLEAR SCREEN.\nLAASTART L     R5,X'10'            POINT TO THE CVT.\n         L     R5,0(,R5)           POINT TO TCB WORDS.\n         L     R5,0(,R5)           POINT TO MY TCB.\n         L     R5,X'B4'(,R5)       POINT TO MY JSCB.\n         L     R5,X'140'(,R5)      POINT TO MY QDB FOR DSAB QUEUE.\n*        L     R5,X'10'(,R5)       POINT TO MY FIRST DSAB.\n         L     R5,X'C'(,R5)        POINT TO MY FIRST DSAB.\n         MVI   OUT,X'40'           CLEAR ...\n         MVC   OUT+1(OUTLEN-1),OUT ... OUTPUT AREA\n         B     CKEND\n*TLUP    L     R5,8(,R5)           POINT TO NEXT DSAB.\nTLUP     L     R5,4(,R5)           POINT TO NEXT DSAB.\nCKEND    LTR   R5,R5               END OF DSAB QUEUE?\n         BNZ   CKDD                B IF NOT\n         L     R13,SAVE+4             E\n         LM    R14,R12,12(R13)          X\n         SR    R15,R15                    I\n         BR    R14                          T\nCKDD     L     R2,16(,R5)          POINT TO ASSOCIATED TIOT ENTRY.\n         MVI   DISP,X'40'                CLEAR DISP, TFLAG ...\n         MVC   DISP+1(OUTEND-DISP),DISP  ... AND DSN.\n         MVC   DDN,4(R2)           MOVE DDNAME\n         MVC   DEV,=CL6'Term'      MOVE DEVICE NAME OF TERM.\n         TM    3(R2),X'20'         IS IT A TERMINAL?\n         BO    OUTPUT              B IF YES.\n         MVC   DEV,=CL6'Sysout'    MOVE DEV NAME OF SYSOUT.\n         TM    3(R2),X'02'         SUBSYSTEM DATASET?\n         BZ    MVDSN               B IF NOT.\n         MVC   DSN(6),=C'Class='   MOVE SYSOUT CLASS GRAPHIC.\n         ICM   R4,7,12(R2)         LOAD JFCB HEADER ADDRESS.\n         MVC   DSN+6(1),X'120'(R4) MOVE SYSOUT CLASS FROM SIOT.\n* NOTE THAT THE ABOVE INSTRUCTION REPRESENTS ABOUT AS SLOPPY A\n* PRACTICE AS I'VE EVER USED.  IT DEPENDS UPON THE SIOT FOLLOWING\n* THE JFCB IN STORAGE AND THE JFCB LENGTH REMAINING CONSTANT.\n*\n         B     OUTPUT              CONTINUE.\nMVDSN    ICM   R4,7,12(R2)         LOAD JFCB HEADER ADDRESS.\n         MVC   DSN,16(R4)          MOVE DATASET NAME.\n         CLC   =C'NULLFILE ',DSN   DUMMY DATASET?\n         BNE   MVVOL               B IF NOT.\n         MVC   DEV,=CL6'Dummy'     MOVE DUMMY GRAPHIC.\n         B     CKTCAM              CONTINUE.\nMVVOL    MVC   DEV,X'86'(R4)       MOVE VOLUME NAME.\nCKTCAM   TM    3(R2),X'08'         TCAM?\n         BZ    CKVIO               B IF NOT\n         MVC   DSN(11),=C'TCAM Queue:'\n         MVC   DEV,=CL6'Queue'     MOVE DEV NAME OF QUEUE (TCAM).\n         MVC   DSN+12(8),16(R4)    MOVE DATASET NAME AGAIN.\n         B     OUTPUT              CONT.\nCKVIO    TM    X'AF'(R4),X'04'     VIO DATASET?\n         BZ    GETUNIT             B IF NOT.\n         MVC   DEV,=CL6'Vio'       MOVE VIO GRAPHIC.\n         B     CKDISP              CONT.\nGETUNIT  CLC   DEV,=CL6' '         HAS DEVICE FIELD BEEN FILLED?\n         BNE   CKDISP              B IF YES.\n         SR    R1,R1               LOAD ...\n         ICM   R1,7,X'11'(R2)      ... POINTER TO UCB.\n         MVC   DEV,=CL6'(###)'     MOVE DEVICE GRAPHIC.\n         MVC   DEV+1(3),X'D'(R1)   MOVE DEVICE ADDRESS.\nCKDISP   MVC   DISP,=C'SHR'        MOVE SHR GRAPHIC.\n         TM    X'67'(R4),X'08'     SHARED?\n         BO    CKTEMP              B IF YES\n         MVC   DISP,=C'NEW'        MOVE NEW GRAPHIC.\n         TM    X'67'(R4),X'C0'     TEST OLD-NEW BITS.\n         BO    CKTEMP              B IF NEW.\n         MVC   DISP,=C'OLD'        MOVE OLD GRAPHIC.\n         TM    X'67'(R4),X'40'     OLD?\n         BO    CKTEMP              B IF YES.\n         MVC   DISP,=C'MOD'        MOVE MOD GRAPHICS.\nCKTEMP   TM    X'22'(R5),X'40'     PERMANENT ALLOCATION?\n         BO    NOTTEMP             B IF YES.\n         MVI   TFLAG,C'*'          MOVE TEMP. ALLOCATION FLAG.\nNOTTEMP  CLI   X'3C'(R4),C' '      MEMBER OR GENERATION?\n         BE    OUTPUT              B IF NOT.\nMEM      LA    R1,8                LD MAX MEMBER LEN FOR BCT.\n         LA    R2,X'3C'(R4)        PT TO MEMBER.\nMEMLUP   CLI   0(R2),C' '          CHAR BLANK?\n         BE    MEMLCALC            B IF YES.\n         LA    R2,1(,R2)           BUMP POINTER.\n         BCT   R1,MEMLUP\nMEMLCALC LA    R3,8                CALC ...\n         SR    R3,R1               ... MEMBER LENGTH.\n         LA    R1,76-(OUT-DSN)     GENERATE ...\n         SR    R1,R3               ... DSN SCAN INDEX.\n         LA    R2,DSN              POINT TO DSN.\nDFBLUP   CLI   0(R2),C' '          CHAR BLANK?\n         BE    DFBSET              B IF YES.\n         LA    R2,1(,R2)           BUMP POINTER.\n         BCT   R1,DFBLUP           LOOK AT ANOTHER CHAR.\n         B     OUTPUT              NO ROOM FOR MEMBER.  SKIP IT.\nDFBSET   MVI   0(R2),C'('          MOVE PAREN.\n         EX    R3,MVMEMB           MOVE MEMBER (+ ONE CHAR).\n         LA    R2,0(R2,R3)         BUMP PTR.\n         MVI   1(R2),C')'          MOVE PAREN.\nOUTPUT   TPUT  OUT,OUTLEN          OUTPUT LINE\n         B     TLUP                LOOP.\nSAVE     DS    9D\nMVMEMB   MVC   1(*-*,R2),X'3C'(R4) EXECUTED.\nOUT      EQU   *\nDDN      DS    CL8,3X\nDEV      DS    CL6,3X\nDISP     DS    CL3,2X\nTFLAG    DS    C\nDSN      DS    CL44\nOUTEND   EQU   *\nOUTLEN   EQU   *-OUT\n         END   LAA\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LAAT": {"ttr": 3340, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00E\\x00\\x92\\x19\\x1f\\x01\\x13\\x13/\\x15\\x00\\x01$\\x00\\xea\\x00\\xc0\\xe3\\xd7\\xe4\\xe3@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1992-07-09T00:00:00", "modifydate": "2013-05-12T15:00:45", "lines": 292, "newlines": 234, "modlines": 192, "user": "TPUT"}, "text": "LAA      TITLE 'LAA - EXPANDED, DEFAULT-ONLY, ALLOCATION LISTER.'\n*%A PPLINK NOTEST AMODGEN\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  COPYRIGHT 1978, 1992 BY JEFFREY R. BROIDO.  ALL RIGHTS RESERVED.   *\n*                                                                     *\n*  LICENSE IS HEREBY GRANTED TO PERSHING SYSTEMS, INCORPORATED        *\n*  COMPANY, JERSEY CITY, NJ AND ITS AFFILIATES TO USE THIS            *\n*  PROGRAM.  HOWEVER, IT MUST NOT BE SOLD, GIVEN, OR OTHERWISE        *\n*  DISTRIBUTED TO ANY OTHER COMPANY OR DATA CENTER WITHOUT PRIOR      *\n*  WRITTEN PERMISSION OF:                                             *\n*                                                                     *\n*                                  BROIDO COMPUTER CONSULTING         *\n*                                  broidoj@gmail.com                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        LAA -  PROGRAM TO LIST ALLOCATION IN A FASHION SIMILAR TO    *\n*               LISTALC COMMAND.  THIS COMMAND TAKES NO OPERANDS,     *\n*               AND PRINTS THE DATASETS, WITH DDNAMES, IN A MORE      *\n*               LINEWISE-COMPACT WAY THAN LISTALC.                    *\n*                                                                     *\n*                                  JEFFREY R. BROIDO - 20 FEB 78      *\n*                                  COLGATE-PALMOLIVE, PISCATAWAY.     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        MODIFIED 1 FEB 79 AT J & J MIC TO TAKE A K OPERAND TO        *\n*                 CLEAR THE SCREEN OF A DISPLAY TUBE BEFORE           *\n*                 EXECUTION.                                          *\n*                                                 JRB                 *\n*                                                                     *\n*        MODIFIED 8 JUL 92 AT PERSHING TO WORK PROPERLY WITH          *\n*                 SWA ABOVE THE LINE.                                 *\n*                                                 JRB                 *\n*                                                                     *\n***********************************************************************\n*\n*        %GOTO QDBL1;  /*\n         MACRO\n         IHAQDB &DSECT=YES    */\n*%QDBL1 : ;\n*\n*/* **************************************************************** */\n*/*                                                                  */\n*/*                         QUEUE DESCRIPTOR BLOCK                   */\n*/*                                                                  */\n*/*  OS/VS2 RELEASE 2, 08/02/72, LEVEL=1                             */\n*/*                                                                  */\n*/*  METHOD OF ACCESS                                                */\n*/*      BAL   - DSECT IS PRODUCED UNLESS DSECT=NO IS SPECIFIED.     */\n*/*              USING ON QDB GIVES ADDRESSABILITY FOR ALL SYMBOLS.  */\n*/*      PL/S  - DCL QDBPTR PTR                                      */\n*/*                                                                  */\n*/* **************************************************************** */\n*%GOTO QDBL2;  /*\n         SPACE 1\n         AIF ('DSECT' EQ 'NO').QDB10\nQDB      DSECT\n         AGO   .QDB20\n.QDB10    ANOP\n         DS    0D\nQDB      EQU   *\n.QDB20   ANOP\nQDBQDB   DS    CL4 -          ACRONYM IN EBCDIC -QDB-\nQDBATTR  DS    BL2 -          QUEUE ATTRIBUTES\nQDBRV001 DS    H -            RESERVED\nQDBNELMS DS    F -            NUMBER OF ELEMENTS ON QUEUE\nQDBFELMP DS    A -            POINTER TO FIRST ELEMENT\nQDBLELMP DS    A -            POINTER TO LAST ELEMENT\nQDBFPTDS DS    H -            FORWARD POINTER DISPLACEMENT\nQDBBPTDS DS    H -            BACKWARD POINTER DISPLACEMENT\nQDBPRSZ  DS    H -            PRIORITY FIELD SIZE\nQDBPRDS  DS    H -            PRIORITY FIELD DISPLACEMENT\nQDBRV002 DS    A -            RESERVED\n         MEND  , -  */\n*%QDBL2 : ;\n*\n*DECLARE\n*  1 QDB     BASED(QDBPTR)  BDY(WORD),\n*   2 QDBQDB      CHAR(4) BDY(WORD),     /* ACRONYM IN EBCIDIC -QDB- */\n*   2 QDBATTR     CHAR(2),               /* QUEUE ATTRIBUTES         */\n*   2 QDBRV001    FIXED(15),             /* RESERVED                 */\n*   2 QDBNELMS    FIXED(31),             /* NUMBER OF ELEMENTS ON\n*                                           QUEUE                    */\n*   2 QDBFELMP    PTR(31),               /* POINTER TO FIRST ELEMENT */\n*   2 QDBLELMP    PTR(31),               /* POINTER TO LAST ELEMENT  */\n*   2 QDBFPTDS    FIXED(15),             /* FORWARD POINTER\n*                                           DISPLACEMENT             */\n*   2 QDBBPTDS    FIXED(15),             /* BACKWARD POINTER\n*                                           DISPLACEMENT             */\n*   2 QDBPRSZ     FIXED(15),             /* PRIORITY FIELD SIZE      */\n*   2 QDBPRDS     FIXED(15),             /* PRIORITY FIELD\n*                                           DISPLACEMENT             */\n*   2 QDBRV002    PTR(31);               /* RESERVED                 */\n*\n         SPACE 3\nLAA      CSECT\nLAA      AMODE 31\nLAA      RMODE 24\n         REGS\n         USING LAA,R15             (ESTABLISH TEMPORARY BASE).\n         B     BEGIN               SKIP OVER HEADER.\nHEAD0    DC    AL1(HEADL)          EXCLUSIVE LENGTH OF HEADER.\nHEAD     DC    C' LAA - &SYSDATE - &SYSTIME -'\n         DC    C'COPYRIGHT (C) BROIDO COMPUTER CONSULTING '\n         DC    C'1978, 1992 - '\n         DC    C'ALL RIGHTS RESERVED'\nHEADL    EQU   *-HEAD\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         LR    R12,R15             COPY BASE.\n         USING LAA,R12             (TELL ASSEMBLER).\n         LR    R14,R13             COPY CALLER'S SAVE AREA POINTER.\n         LA    R13,SAVE            POINT TO MY SAVE AREA.\n         ST    R13,8(,R14)         CHAIN ...\n         ST    R14,SAVE+4          ... SAVE AREAS.\n         SPACE 1\n*              LOCATE THE DSAB QUEUE.\n         SPACE 1\n         LTR   R1,R1               ANY CPPL OR PARM POINTER?\n         BZ    LAASTART            B IF NOT.\n         L     R2,0(,R1)           POINT TO BUFFER\n         LTR   R2,R2               ANY?\n         BZ    LAASTART            B IF NOT.\n         LH    R3,0(R2)            LOAD LENGTH.\n         LTR   R3,R3               ANY?\n         BZ    LAASTART            B IF NOT.\n         CLI   2(R2),X'00'         COMMAND PROCESSOR INVOKATION?\n         BE    LAACP\n         LA    R2,2(,R2)           POINT TO PARM.\n         B     PARM\nLAACP    CH    R3,=H'4'            ANY PARM?\n         BE    LAASTART            B IF NOT.\n         AH    R2,2(,R2)           POINT TO ...\n         LA    R2,4(,R2)           ... PARM.\nPARM     OI    0(R2),C' '          UPPERCASE.\n         CLI   0(R2),C'K'          CLEAR?\n         BNE   LAASTART            B IF NOT.\n         GTSIZE\n         LTR   R0,R0               DISPLAY?\n         BZ    LAASTART            B IF NOT.\n         K     ,                   CLEAR SCREEN.\nLAASTART L     R5,X'10'            POINT TO THE CVT.\n         L     R5,0(,R5)           POINT TO TCB WORDS.\n         L     R5,0(,R5)           POINT TO MY TCB.\n         USING TCB,R5              (TELL ASSEMBLER).\n         L     R5,TCBJSCB          POINT TO MY JSCB.\n         USING IEZJSCB,R5          (TELL ASSEMBLER).\n         L     R5,JSCDSABQ         POINT TO MY QDB FOR DSAB QUEUE.\n         USING QDB,R5              (TELL ASSEMBLER).\n         L     R5,QDBFELMP         POINT TO FIRST DSAB.\n         USING DSAB,R5             (TELL ASSEMBLER).\n         MVI   OUT,X'40'           CLEAR ...\n         MVC   OUT+1(OUTLEN-1),OUT ... OUTPUT AREA\n         B     CKEND\nTLUP     L     R5,DSABFCHN         POINT TO NEXT DSAB.\nCKEND    LTR   R5,R5               END OF DSAB QUEUE?\n         BNZ   CKDD                B IF NOT\n         L     R13,SAVE+4             E\n         LM    R14,R12,12(R13)          X\n         SR    R15,R15                    I\n         BR    R14                          T\nCKDD     L     R2,DSABTIOT         POINT TO ASSOCIATED TIOT ENTRY.\n         USING TIOENTRY,R2         (TELL ASSEMBLER).\n         MVI   DISP,X'40'                CLEAR DISP, TFLAG ...\n         MVC   DISP+1(OUTEND-DISP),DISP  ... AND DSN.\n         MVC   DDN,TIOEDDNM        MOVE DDNAME\n         MVC   DEV,=CL6'Term'      MOVE DEVICE NAME OF TERM.\n         TM    TIOELINK,TIOTTERM   IS IT A TERMINAL?\n         BO    OUTPUT              B IF YES.\n         MVC   DEV,=CL6'Sysout'    MOVE DEV NAME OF SYSOUT.\n         LA    R6,EPAL             POINT TO THE EPAL.\n         USING ZB505,R6            (TELL ASSEMBLER)\n         XC    EPAL,EPAL           CLEAR THE EPAL.\n         MVC   SWVA,TIOEJFCB       MOVE TOKEN FOR JFCB TO EPAL.\n         SWAREQ FCODE=RL,EPA=EPALPTR,UNAUTH=YES,                       +\n               MF=(E,SWAPARMS)     GET ADDRESS OF JFCB.\n         L     R4,SWBLKPTR         POINT TO JFCB.\n         USING JFCB,R4             (TELL ASSEMBLER).\n         TM    TIOELINK,TIOESYOT   IS IT A SUBSYSTEM DATASET?\n         BZ    MVDSN               B IF NOT.\n         MVC   DSN(6),=C'Class='   MOVE SYSOUT CLASS GRAPHIC.\n         L     R15,X'14'(,R5)      POINT TO SIOT.\n         XC    EPAL,EPAL           CLEAR THE EPAL.\n         MVC   SWVA,DSABSSVA       MOVE TOKEN FOR SIOT TO EPAL.\n         SWAREQ FCODE=RL,EPA=EPALPTR,UNAUTH=YES,                       +\n               MF=(E,SWAPARMS)     GET ADDRESS OF SIOT.\n         L     R15,SWBLKPTR        POINT TO SIOT.\n         USING INDMSIOT,R15        (TELL ASSEMBLER).\n         MVC   DSN+6(1),SCTOUTPN   MOVE SYSOUT CLASS FROM SIOT.\n         DROP  R15\n         B     OUTPUT              CONTINUE.\nMVDSN    MVC   DSN,JFCBDSNM        MOVE DATASET NAME.\n         CLC   =C'NULLFILE ',DSN   DUMMY DATASET?\n         BNE   MVVOL               B IF NOT.\n         MVC   DEV,=CL6'Dummy'     MOVE DUMMY GRAPHIC.\n         B     CKTCAM              CONTINUE.\nMVVOL    MVC   DEV,JFCBVOLS        MOVE VOLUME NAME.\nCKTCAM   TM    TIOELINK,TIOTREM    TCAM?\n         BZ    CKVIO               B IF NOT\n         MVC   DSN(11),=C'TCAM Queue:'\n         MVC   DEV,=CL6'Queue'     MOVE DEV NAME OF QUEUE (TCAM).\n         MVC   DSN+12(8),JFCBDSNM  MOVE DATASET NAME AGAIN.\n         B     OUTPUT              CONT.\nCKVIO    TM    JFCFLGS1,JFCVRDS    VIO DATASET?\n         BZ    GETUNIT             B IF NOT.\n         MVC   DEV,=CL6'Vio'       MOVE VIO GRAPHIC.\n         B     CKVTOC              CONT.\nGETUNIT  CLC   DEV,=CL6' '         HAS DEVICE FIELD BEEN FILLED?\n         BNE   CKVTOC              B IF YES.\n         SR    R1,R1               LOAD ...\n         ICM   R1,7,TIOEFSRT       ... POINTER TO UCB.\n         USING UCBCMEXT,R1         (TELL ASSEMBLER)\n         MVC   DEV,=CL6'(###)'     MOVE DEVICE GRAPHIC.\n         MVC   DEV+1(3),UCBNAME    MOVE DEVICE ADDRESS.\n         DROP  R1,R2\nCKVTOC   CLI   DSN,X'04'           IS THIS THE DSN FOR VTOC?\n         BNE   CKDISP              B IF NOT.\n         MVC   DSN,=CL44'           -- Volume Table of Contents --'\nCKDISP   MVC   DISP,=C'SHR'        MOVE SHR GRAPHIC.\n         TM    JFCBIND2,JFCSHARE   SHARED?\n         BO    CKTEMP              B IF YES\n         MVC   DISP,=C'NEW'        MOVE NEW GRAPHIC.\n         TM    JFCBIND2,JFCNEW     TEST OLD-NEW BITS.\n         BO    CKTEMP              B IF NEW.\n         MVC   DISP,=C'OLD'        MOVE OLD GRAPHIC.\n         TM    JFCBIND2,JFCOLD     OLD?\n         BO    CKTEMP              B IF YES.\n         MVC   DISP,=C'MOD'        MOVE MOD GRAPHICS.\nCKTEMP   TM    DSABFLG1,DSABPALC   PERMANENT ALLOCATION?\n         BO    NOTTEMP             B IF YES.\n         MVI   TFLAG,C'*'          MOVE TEMP. ALLOCATION FLAG.\nNOTTEMP  CLI   JFCBELNM,C' '       MEMBER OR GENERATION?\n         BE    OUTPUT              B IF NOT.\nMEM      LA    R1,8                LD MAX MEMBER LEN FOR BCT.\n         LA    R2,JFCBELNM         PT TO MEMBER.\nMEMLUP   CLI   0(R2),C' '          CHAR BLANK?\n         BE    MEMLCALC            B IF YES.\n         LA    R2,1(,R2)           BUMP POINTER.\n         BCT   R1,MEMLUP\nMEMLCALC LA    R3,8                CALC ...\n         SR    R3,R1               ... MEMBER LENGTH.\n         LA    R1,76-(OUT-DSN)     GENERATE ...\n         SR    R1,R3               ... DSN SCAN INDEX.\n         LA    R2,DSN              POINT TO DSN.\nDFBLUP   CLI   0(R2),C' '          CHAR BLANK?\n         BE    DFBSET              B IF YES.\n         LA    R2,1(,R2)           BUMP POINTER.\n         BCT   R1,DFBLUP           LOOK AT ANOTHER CHAR.\n         B     OUTPUT              NO ROOM FOR MEMBER.  SKIP IT.\nDFBSET   MVI   0(R2),C'('          MOVE PAREN.\n         EX    R3,MVMEMB           MOVE MEMBER (+ ONE CHAR).\n*      ( MVC   1(*-*,R2),JFCBELNM  )\n         LA    R2,0(R2,R3)         BUMP PTR.\n         MVI   1(R2),C')'          MOVE PAREN.\nOUTPUT   TPUT  OUT,OUTLEN          OUTPUT LINE\n         B     TLUP                LOOP.\nSAVE     DS    9D\nMVMEMB   MVC   1(*-*,R2),JFCBELNM  *** EXECUTED ***\nOUT      EQU   *\nDDN      DS    CL8,3X\nDEV      DS    CL6,3X\nDISP     DS    CL3,2X\nTFLAG    DS    C\nDSN      DS    CL44\nOUTEND   EQU   *\nOUTLEN   EQU   *-OUT\n         SPACE 1\nPOOP     DC    X'00'               BUFFER.\nEPALPTR  DC    A(EPAL)             POINTER TO EPAL.\nEPAL     DS    CL28                EPAL.\nSWAPARMS SWAREQ MF=L               SWAREQ PARMS\n         TITLE '- MAPPING MACROS.'\n         IEFZB505 LOCEPAX=YES      MAP THE EPAL.\n         CVT   DSECT=YES           MAP THE CVT.\n         IEFJESCT                  MAP THE JESCT.\n         IEZJSCB                   MAP THE JSCB.\n         IKJTCB                    MAP THE TCB.\n         IHAQDB                    MAP THE QDB.\n         IHADSAB                   MAP THE DSAB.\n         IEFTIOT1                  MAP THE TIOT.\nJFCB     DSECT\n         IEFJFCBN                  MAP THE JFCB.\n         IEFASIOT                  MAP THE SIOT.\n         IEFUCBOB                  MAP THE UCB.\n         END   LAA\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTATT$": {"ttr": 3589, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00&\\x01\\x05\\x13_\\x01\\x18\\x04o\\x13I\\x00!\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "2005-05-15T00:00:00", "modifydate": "2018-02-15T13:49:26", "lines": 33, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,\n//     PARM='OBJECT,NODECK,ESD,RLD,BATCH,FLAG(5)'\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//*        DD DISP=SHR,DSN=SYS1.MODGEN\n//*        DD DISP=SHR,DSN=SBGOLOB.JRB.MACLIB.ASM   (FILE 423)\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(LISTATTR)\n//SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(2,2))\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSALLDA,SPACE=(CYL,(4,4)),DISP=(,PASS),\n//            DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET,RENT'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY   LISTATTR\n ALIAS   LAT\n SETSSI  CB495423\n SETCODE AC(0)\n NAME    LISTATTR(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTATTR": {"ttr": 3591, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x13\\x00\\x06\\x00y\\x05\\x7f\\x01\\x18\\x04o\\x14\\x11\\x03?\\x01\\xc9\\x03?\\xd7\\xe4\\xe3\\xd3\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "00.19", "flags": 0, "createdate": "1979-02-26T00:00:00", "modifydate": "2018-02-15T14:11:06", "lines": 831, "newlines": 457, "modlines": 831, "user": "PUTLINE"}, "text": "LAT      TITLE 'LISTATTR - TSO COMMAND TO LIST ATTRIBUTE LIST ATTRIBUTE+\n               S.'\n*%A RENT AMODGEN PPLINK ADATA NOTEST\n*L ALIAS LAT\n* ------------------------------------------------------------------- *\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\n         SPACE 3\nLISTATTR CSECT\n***********************************************************************\n*                                                                     *\n*  THIS PROGRAM IS IN THE PUBLIC DOMAIN.                              *\n*  ITS SOURCE IS THE SHARE/GUIDE MVS TAPE, AND HAS BEEN MODIFIED BY:  *\n*                                                                     *\n*                                  JEFFREY R. BROIDO                  *\n*                                  broidoj@gmail.com                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        LISTATTR  -  DAVID G. SAGER  -  FEB, 1976                    *\n*                                                                     *\n*        ATTRIBUTES - REENTRANT, REFRESHABLE, REUSEABLE               *\n*                                                                     *\n*        SYNTAX  -    LISTATTR  | A                                   *\n*                     LAT                                             *\n*                                                                     *\n*                                                                  JRB*\n*        MODIFIED BY J. BROIDO TO TAKE A PARM OF 'A' TO TELL       JRB*\n*        PROGRAM TO LIST ATTRIBUTES OF ALL ALLOCATED FILES.        JRB*\n*                                                                     *\n*        Added PUTLINE output, fixed LA and ST and L instructions     *\n*        not to use the index register.  (SBG)                        *\n*                                                                     *\n***********************************************************************\n         SPACE 1                                                   JRB\n         YREGS                                                     JRB\n         EJECT\n         SAVE  (14,12),,*\n         LR    R12,R15\n         USING LISTATTR,R12\n         LR    R2,R1              A(CPPL)\n         GETMAIN R,LV=WKAL\n         LR    R11,R1\n         USING WKA,R11\n         LA    R10,SAVE\n         ST    R13,SAVE+4\n         ST    R10,8(,R13)\n         LR    R13,R10\n         MVI   SW,X'00'\n         LTR   R2,R2               CK. PARM POINTER.               JRB\n         BZ    FCONT1              EMPTY. FORGET IT.               JRB\n         L     R3,0(,R2)           POINT TO CMD BUFF. OR OS PARM.  JRB\n         CH    R3,=H'00'           CHECK LENGTH.                   JRB\n         BE    FCONT1              EMPTY PARM. FORGET IT.          JRB\n         CLI   2(R3),X'00'         OS PARM?                        JRB\n         BE    CPPLPARM            B IF NOT.                       JRB\n         LA    3,2(,R3)            POINT TO OS PARM.               JRB\n         B     FCONT0              CONTINUE.                       JRB\nCPPLPARM LH    R4,2(,R3)           LOAD BUFFER OFFSET.             JRB\n         CH    R4,0(,R3)           OVER THE TOP?                   JRB\n         BNL   FCONT1              B IF YES.                       JRB\n         AR    R3,R4               POINT ...                       JRB\n         LA    R3,4(,R3)           ... TO PARM.                    JRB\nFCONT0   OI    0(R3),C' '          UPPERCASE.                      JRB\n         CLI   0(R3),C'A'          LIST ATTR. OF ALL DATASETS?     JRB\n         BNE   FCONT1              B IF NOT.                       JRB\n         OI    SW,ALLFLG           TURN ON LISTALL FLAG.           JRB\nFCONT1   L     R3,16                                  CVT\n         L     R3,0(,R3)                              NEW/CURRENT TCB\n         L     R3,4(,R3)                              CURRENT TCB\n         L     R3,12(,R3)                             TIOT\n         LA    R3,24(,R3)         FIRST TIOT ENTRY\n         USING TIOELNGH,R3\nTIOTENT  XR    R4,R4\n         IC    R4,TIOELNGH        LENGTH OF THIS ENTRY\n         LTR   R4,R4              END OF TIOT?\n         BZ    EXIT               YES, EXIT\n         CLI   TIOEDDNM,X'00'     VALID DDNAME?\n         BE    NEXTTIO            NO, CONTINUE\n         CLI   TIOEDDNM,X'40'     VALID DDNAME?\n         BE    NEXTTIO            NO, CONTINUE\n         XR    R5,R5\n         ICM   R5,7,TIOEJFCB      A(JFCB)-16\n         BZ    NEXTTIO            IF ZERO, SKIP\n         LA    R5,16(,R5)          A(JFCB)\n         TM    SW,ALLFLG           LIST ATTRIBUTES OF ALL FILES?   JRB\n         BO    FORMATA             B IF YES.                       JRB\n         USING INFMJFCB,R5\n         CLC   JFCBDSNM(44),NULLFILE  DSNAME = NULLFILE?\n         BE    FORMAT             YES, REPRESENTS ATTRIBUTE\nNEXTTIO  DS    0H\n         AR    R3,R4              POINT TO NEXT TIOT ENTRY\n         B     TIOTENT\nFORMAT   DS    0H\n         TM    TIOELINK,TIOTTERM  IS THIS A TERMINAL FILE?\n         BO    NEXTTIO            YES, SKIP\nFORMATA  OI    SW,ANYATTR          TURN ON ATTR LIST FOUND FLG.    JRB\n         MVI   OUT,X'40'                              BLANK OUT\n         MVC   OUT+1(249),OUT\n         LA    R10,OUT\n         MVC   0(8,R10),TIOEDDNM                      MOVE IN NAME\n         LA    R10,9(,R10)\nTTINPUT  TM    JFCBFLG2,X'80'                           INPUT?\n         BNO   TTOUTPUT                                 NO\n         MVC   0(5,R10),=CL5'INPUT'\n         LA    R10,6(,R10)\n         B     TEXPDT\nTTOUTPUT TM    JFCBFLG2,X'40'                            OUTPUT?\n         BNO   TDIAGNS                                   NO\n         MVC   0(6,R10),=CL6'OUTPUT'\n         LA    R10,7(,R10)\nTDIAGNS  TM    JFCBFLG2,X'04'                            GTF TRACE?\n         BNO   TEXPDT                                    NO\n         MVC   0(13,R10),=CL13'DIAGNS(TRACE)'\n         LA    R10,14(,R10)\nTEXPDT   CLC   JFCBXPDT(3),ZERO                       ANY EXPDT?\n         BE    TBUFNO                                 NO\n         SR    R6,R6                                      PICK\n         MVC   0(12,R10),=CL12'EXPDT(00000)'              UP\n         IC    R6,JFCBXPDT                                  YEAR\n         CVD   R6,DBLEWORD\n         UNPK  ANSWER(8),DBLEWORD+4(4)\n         OI    ANSWER+7,X'F0'\n         MVC   6(2,R10),ANSWER+6\n         SR    R6,R6                                      PICK\n         LH    R6,JFCBXPDT+1                               UP\n         CVD   R6,DBLEWORD                                  DAY\n         UNPK  ANSWER(8),DBLEWORD+4(4)                       OF\n         OI    ANSWER+7,X'F0'                                 YEAR\n         MVC   8(3,R10),ANSWER+5\n         LA    R10,13(,R10)\nTBUFNO   CLI   JFCBUFNO,X'00'                         ANY BUFNO?\n         BE    TBFTEK                                 NO\n         SR    R6,R6                                      PICK\n         IC    R6,JFCBUFNO                                 UP\n         CVD   R6,DBLEWORD                                  BUFNO\n         UNPK  ANSWER(8),DBLEWORD+4(4)\n         MVC   0(10,R10),=CL10'BUFNO(000)'\n         OI    ANSWER+7,X'F0'\n         MVC   6(3,R10),ANSWER+5\n         LA    R10,11(,R10)\nTBFTEK   CLI   JFCBFTEK,X'00'                         ANY BFTEK?\n         BE    TBUFL                                  NO\n         MVC   0(8,R10),=CL8'BFTEK(D)'\n         TM    JFCBFTEK,X'60'                             AUTO?\n         BNO   TTBFTS                                     NO\n         MVI   6(R10),C'A'\n         B     TBFTEKE\nTTBFTS   TM    JFCBFTEK,X'40'                             SIMPLE?\n         BNO   TTBFTR                                     NO\n         MVI   6(R10),C'S'\n         B     TBFTEKE\nTTBFTR   TM    JFCBFTEK,X'20'                             RECORD?\n         BNO   TTBFTE                                     NO\n         MVI   6(R10),C'R'\n         B     TBFTEKE\nTTBFTE   TM    JFCBFTEK,X'10'                             EXCHANGE\n         BNO   TBFALND                                    NO\n         MVI   6(R10),C'E'\nTBFTEKE  LA    R10,9(,R10)\nTBFALND  TM    JFCBFTEK,X'02'                         ANY BFALN(DBLWRD)\n         BNO   TBFALNF                                NO\n         MVC   0(8,R10),=CL8'BFALN(D)'\n         LA    R10,9(,R10)\n         B     TBUFL\nTBFALNF  TM    JFCBFTEK,X'01'                         ANY BFALN(FLLWRD)\n         BNO   TBUFL                                  NO\n         MVC   0(8,R10),=CL8'BFALN(F)'\n         LA    R10,9(,R10)\nTBUFL    CLC   JFCBUFL(2),ZERO                        ANY BUFL\n         BE    TRKP                                   NO\n         SR    R6,R6                                      PICK\n         LH    R6,JFCBUFL                                  UP\n         CVD   R6,DBLEWORD                                  BUFL\n         UNPK  ANSWER(8),DBLEWORD+4(4)\n         MVC   0(11,R10),=CL11'BUFL(00000)'\n         OI    ANSWER+7,X'F0'\n         MVC   5(5,R10),ANSWER+3\n         LA    R10,12(,R10)\nTRKP     CLC   JFCRKP(2),ZERO                         ANY BUFL\n         BE    TEROPT                                 NO\n         SR    R6,R6                                      PICK\n         LH    R6,JFCRKP                                   UP\n         CVD   R6,DBLEWORD                                  BUFL\n         UNPK  ANSWER(8),DBLEWORD+4(4)\n         MVC   0(10,R10),=CL10'RKP(00000)'\n         OI    ANSWER+7,X'F0'\n         MVC   4(5,R10),ANSWER+3\n         LA    R10,11(,R10)\nTEROPT   CLI   JFCEROPT,X'00'                         ANY EROPT?\n         BE    TBUFOF                                 NO\n         MVC   0(10,R10),=CL10'EROPT(ABE)'\nTTACCEPT TM    JFCEROPT,X'80'                             ACCEPT?\n         BNO   TTSKIP                                     NO\n         MVC   6(3,R10),=CL3'ACC'\n         B     TEROPTE\nTTSKIP   TM    JFCEROPT,X'40'                             SKIP?\n         BNO   TEROPTE                                    NO\n         MVC   6(3,R10),=CL3'SKP'\nTEROPTE  LA    R10,11(,R10)\nTBUFOF   CLI   JFCBUFOF,X'00'                         ANY BUFOF?\n         BE    TRECFM                                 NO\n         MVC   0(6,R10),=CL6'BUFOF('\n         LA    R10,6(,R10)\n         TM    JFCBUFOF,X'80'                         L?\n         BNO   TBUFOF1                                NO\n         MVI   0(R10),C'L'\n         LA    R10,1(,R10)\n         B     TBUFOFE\nTBUFOF1  SR    R6,R6                                      PICK\n         IC    R6,JFCBUFOF                                 UP\n         CVD   R6,DBLEWORD                                  BUFOF\n         UNPK  ANSWER(8),DBLEWORD+4(4)\n         OI    ANSWER+7,X'F0'\n         MVC   0(3,R10),ANSWER+5\n         LA    R10,3(,R10)\nTBUFOFE  MVI   0(R10),C')'\n         LA    R10,2(,R10)\nTRECFM   CLI   JFCRECFM,X'00'                         ANY RECFM?\n         BE    TOPTCD                                 NO\n         MVC   0(6,R10),=CL6'RECFM('\n         LA    R10,6(,R10)\nTTUNDEF  TM    JFCRECFM,X'C0'                             UNDEFINED?\n         BNO   TTFIXED                                    NO\n         MVI   0(R10),C'U'\n         LA    R10,1(,R10)\n         B     TRECFME\nTTFIXED  TM    JFCRECFM,X'80'                             FIXED?\n         BNO   TTVARIBL                                   NO\n         MVI   0(R10),C'F'\n         LA    R10,1(,R10)\nTTVARIBL TM    JFCRECFM,X'40'                             VARIBLE\n         BNO   TTTRKOV                                    NO\n         MVI   0(R10),C'V'\n         LA    R10,1(,R10)\nTTTRKOV  TM    JFCRECFM,X'20'                             TRKOVERFLW?\n         BNO   TTBLKED                                    NO\n         MVI   0(R10),C'T'\n         LA    R10,1(,R10)\nTTBLKED  TM    JFCRECFM,X'10'                             BLOCKED?\n         BNO   TTSTDBL                                    NO\n         MVI   0(R10),C'B'\n         LA    R10,1(,R10)\nTTSTDBL  TM    JFCRECFM,X'08'                             STANDARD?\n         BNO   TTASAPC                                    NO\n         MVI   0(R10),C'S'\n         LA    R10,1(,R10)\nTTASAPC  TM    JFCRECFM,X'04'                             ASCI CAR CNT?\n         BNO   TTMACHCC                                   NO\n         MVI   0(R10),C'A'\n         LA    R10,1(,R10)\nTTMACHCC TM    JFCRECFM,X'02'                             MCHN CAR CNT?\n         BNO   TRECFME                                     NO\n         MVI   0(R10),C'M'\n         LA    R10,1(,R10)\nTRECFME  MVI   0(R10),C')'\n         LA    R10,2(,R10)\nTOPTCD   CLI   JFCOPTCD,X'00'                         ANY OPTCD?\n         BE    TDSORG                                 NO\n         MVC   0(6,R10),=CL6'OPTCD('\n         LA    R10,6(,R10)\n         TM    JFCDSORG,X'20'                             DIRECT ACCES?\n         BO    TOPTDA                                     YES\nTOPTPS   DS    0H\nTTWTVCH  TM    JFCOPTCD,X'80'                             VALD CHK?\n         BNO   TTBEOF                                     NO\n         MVI   0(R10),C'W'\n         LA    R10,1(,R10)\nTTBEOF   TM    JFCOPTCD,X'40'                             BYPASS EOF?\n         BNO   TTCHNSCH                                   NO\n         MVI   0(R10),C'B'\n         LA    R10,1(,R10)\nTTCHNSCH TM    JFCOPTCD,X'20'                             CHAIN SCHD?\n         BNO   TTANSITR                                   NO\n         MVI   0(R10),C'C'\n         LA    R10,1(,R10)\nTTANSITR TM    JFCOPTCD,X'08'                             TRANSLATE?\n         BNO   TTREDERR                                   NO\n         MVI   0(R10),C'Q'\n         LA    R10,1(,R10)\nTTREDERR TM    JFCOPTCD,X'04'                             REDUCED ERR?\n         BNO   TTUSERT                                    NO\n         MVI   0(R10),C'Z'\n         LA    R10,1(,R10)\nTTUSERT  TM    JFCOPTCD,X'02'                             USER TOTAL?\n         BNO   TOPTCDJ                                    NO\n         MVI   0(R10),C'T'\n         LA    R10,1(,R10)\nTOPTCDJ  TM    JFCOPTCD,X'01'                             3800 CHAR?\n         BNO   TOPTCDE                                    NO\n         MVI   0(R10),C'J'\n         LA    R10,1(,R10)\n         B     TOPTCDE\nTOPTDA   DS    0H\nTTWTVCH1 TM    JFCOPTCD,X'80'                             VALD CHK?\n         BNO   TTOVFL                                     NO\n         MVI   0(R10),C'W'\n         LA    R10,1(,R10)\nTTOVFL   TM    JFCOPTCD,X'40'                             TRK OVFLOW?\n         BNO   TTEXTS                                     NO\n         MVI   0(R10),C'T'\n         LA    R10,1(,R10)\nTTEXTS   TM    JFCOPTCD,X'20'                             EXT SEARCH?\n         BNO   TTFDBK                                     NO\n         MVI   0(R10),C'E'\n         LA    R10,1(,R10)\nTTFDBK   TM    JFCOPTCD,X'10'                             FEEDBACK?\n         BNO   TTACTADR                                   NO\n         MVI   0(R10),C'F'\n         LA    R10,1(,R10)\nTTACTADR TM    JFCOPTCD,X'08'                             ACTUAL ADDR?\n         BNO   TTRELBLK                                   NO\n         MVI   0(R10),C'A'\n         LA    R10,1(,R10)\nTTRELBLK TM    JFCOPTCD,X'01'                             RELATIVE BLK?\n         BNO   TOPTCDE                                    NO\n         MVI   0(R10),C'R'\n         LA    R10,1(,R10)\n         B     TOPTCDE\nTOPTCDE  MVI   0(R10),C')'\n         LA    R10,2(,R10)\nTDSORG   CLI   JFCDSORG,X'00'                         ANY DSORG?\n         BE    TBLKSI                                 NO\n         MVC   0(10,R10),=CL10'DSORG(** )'\nTTIS     TM    JFCDSORG,X'80'                             IS?\n         BNO   TTPS                                       NO\n         MVC   6(2,R10),=CL2'IS'\nTTPS     TM    JFCDSORG,X'40'                             PS?\n         BNO   TTDA                                       NO\n         MVC   6(2,R10),=CL2'PS'\nTTDA     TM    JFCDSORG,X'20'                             DA?\n         BNO   TTPO                                       NO\n         MVC   6(2,R10),=CL2'DA'\nTTPO     TM    JFCDSORG,X'02'                             PO?\n         BNO   TTU                                        NO\n         MVC   6(2,R10),=CL2'PO'\nTTU      TM    JFCDSORG,X'01'                             UNMOVABLE?\n         BNO   TDSORGE                                    NO\n         MVI   8(R10),C'U'\nTDSORGE  LA    R10,11(,R10)\nTLIMCT   TM    JFCDSORG,X'20'                         DA?\n         BNO   TBLKSI                                 NO, NO LIMCT\n         CLC   JFCLIMCT(3),ZERO                       ANY LIMCT?\n         BE    TBLKSI                                 NO\n         SR    R6,R6                                      PICK\n         ICM   R6,7,JFCLIMCT                               UP\n         CVD   R6,DBLEWORD                                  LIMCT\n         UNPK  ANSWER(8),DBLEWORD+4(4)\n         MVC   0(9,R10),=CL9'LIMCT(00)'\n         OI    ANSWER+7,X'F0'\n         MVC   6(2,R10),ANSWER+6\n         LA    R10,10(,R10)\nTBLKSI   CLC   JFCBLKSI(2),ZERO                       ANY BLKSIZE?\n         BE    TLRECL                                 NO\n         SR    R6,R6                                      PICK\n         LH    R6,JFCBLKSI                                 UP\n         CVD   R6,DBLEWORD                                  BLKSIZE\n         UNPK  ANSWER(8),DBLEWORD+4(4)\n         MVC   0(14,R10),=CL14'BLKSIZE(00000)'\n         OI    ANSWER+7,X'F0'\n         MVC   8(5,R10),ANSWER+3\n         LA    R10,15(,R10)\nTLRECL   CLC   JFCLRECL(2),ZERO                       ANY LRECL?\n         BE    TNCP                                   NO\n         CLC   JFCLRECL(2),=XL2'8000'  LRECL=X?\n         BNE   TLRECL1            NO\n         MVC   0(8,R10),=CL8'LRECL(X)'\n         LA    R10,9(,R10)\n         B     TNCP\nTLRECL1  SR    R6,R6                                      PICK\n         LH    R6,JFCLRECL                                 UP\n         CVD   R6,DBLEWORD                                  LRECL\n         UNPK  ANSWER(8),DBLEWORD+4(4)\n         MVC   0(12,R10),=CL12'LRECL(00000)'\n         OI    ANSWER+7,X'F0'\n         MVC   6(5,R10),ANSWER+3\n         LA    R10,13(,R10)\nTNCP     CLI   JFCNCP,X'00'                           ANY NCP?\n         BE    TDEN                                   NO\n         SR    R6,R6                                      PICK\n         IC    R6,JFCNCP                                   UP\n         CVD   R6,DBLEWORD                                  NCP\n         UNPK  ANSWER(8),DBLEWORD+4(4)\n         MVC   0(7,R10),=CL7'NCP(00)'\n         OI    ANSWER+7,X'F0'\n         MVC   4(2,R10),ANSWER+6\n         LA    R10,8(,R10)\nTDEN     CLI   JFCDEN,X'00'                           ANY DEN?\n         BE    TTRTCH                                 NO\n         MVC   0(6,R10),=CL6'DEN(*)'\nTTDEN0   CLI   JFCDEN,X'03'                               200 BPI?\n         BNE   TTDEN1                                     NO\n         MVI   4(R10),C'0'\nTTDEN1   CLI   JFCDEN,X'43'                               556 BPI?\n         BNE   TTDEN2                                     NO\n         MVI   4(R10),C'1'\nTTDEN2   CLI   JFCDEN,X'83'                               800 BPI?\n         BNE   TTDEN3                                     NO\n         MVI   4(R10),C'2'\nTTDEN3   CLI   JFCDEN,X'C3'                               1600 BPI?\n         BNE   TTDEN4                                     NO\n         MVI   4(R10),C'3'\nTTDEN4   CLI   JFCDEN,X'D3'                               6250 BPI?\n         BNE   TDENE                                      NO\n         MVI   4(R10),C'4'\nTDENE    LA    R10,7(,R10)\nTTRTCH   CLI   JFCTRTCH,X'00'                         ANY DEN?\n         BE    WRITE                                  NO\n         MVC   0(9,R10),=CL9'TRTCH(* )'\nTTTRE    CLI   JFCTRTCH,X'23'                             E?\n         BNE   TTTRT                                      NO\n         MVI   6(R10),C'E'\n         B     TTRTCHE\nTTTRT    CLI   JFCTRTCH,X'3B'                             T?\n         BNE   TTTRC                                      NO\n         MVI   6(R10),C'T'\n         B     TTRTCHE\nTTTRC    CLI   JFCTRTCH,X'13'                             C?\n         BNE   TTTRET                                     NO\n         MVI   6(R10),C'C'\n         B     TTRTCHE\nTTTRET   CLI   JFCTRTCH,X'2B'                             ET?\n         BNE   TKEYLEN                                    NO\n         MVC   6(2,R10),=CL2'ET'\n         B     TTRTCHE\nTKEYLEN  SR    R6,R6                                      PICK\n         IC    R6,JFCKEYLE                                 UP\n         CVD   R6,DBLEWORD                                  KEYLEN\n         UNPK  ANSWER(8),DBLEWORD+4(4)\n         MVC   0(11,R10),=CL11'KEYLEN(000)'\n         OI    ANSWER+7,X'F0'\n         MVC   7(3,R10),ANSWER+5\nTTRTCHE  LA    R10,12(,R10)\n         SPACE  2\nWRITE    LA    R6,OUT\n         SR    R10,R6\n*\n*              PRINT ONLY 79 CHARACTERS PER LINES\n*              MAKE SURE LAST CHARACTER OF A LINE IS A BLANK\n*\nGTRTHN79 LA    R7,79\n         CR    R10,R7\n         BNH   TPUTFNL\n         CLI   79(R6),C' '\n         BNE   ADD\n         LA    R7,1(R7)\n         B     TPUT\nADD      AR    R7,R6\nDECRMNT  S     R7,=F'1'\n         CLI   0(R7),C' '\n         BNE   DECRMNT\n         SR    R7,R6\nTPUT     APUT  (R6),(R7)\n         AR    R6,R7\n         SR    R10,R7\n         B     GTRTHN79\nTPUTFNL  APUT  (R6),(R10)\n         B     NEXTTIO\nEXIT     DS    0H\n         TM    SW,ANYATTR         ANY ATTR?                        JRB\n         BO    RETURN             YES\n         APUT  =C'NO ATTRIBUTE LISTS WERE FOUND.',30\n*        VTPUT 'NO ATTRIBUTE LISTS WERE FOUND.'\nRETURN   L     R13,SAVE+4\n         LR    R1,R11\n         FREEMAIN R,LV=WKAL,A=(1)\n         L     R13,SAVE+4\n         LM    R14,R12,12(R13)\n         SR    R15,R15\n         BR    R14\n         EJECT\nZERO     DC    F'0'\nBLANK    DC    CL4' '\nNULLFILE DC    CL44'NULLFILE'\nWKA      DSECT\nSAVE     DS    18F\nDBLEWORD DS    D\nANSWER   DS    D\nOUT      DS    CL250\n         SPACE 1                                                   JRB\nSW       DS    X                   FLAGS.                          JRB\nANYATTR  EQU   B'10000000'         ATTRIBUTE LIST FOUND FLAG.      JRB\nALLFLG   EQU   B'01000000'         ALL LIST FLAG.                  JRB\n         SPACE 1                                                   JRB\nWKAE     EQU   *\nWKAL     EQU   WKAE-WKA\n         IEFTIOT1\n         IEFJFCBN\n         END\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*  CLEANED A BIT  . . . 08/17\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATER  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUMENTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFORE R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   255                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nR3       EQU   3                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         EJECT\n         IHAPSA   LIST=YES                                     HD APR88\n         EJECT                                                 HD APR88\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\n         DS    0D\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   R14,R12,12(R13)    SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES            RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    R1,8(,R13)         OUR SAVE AREA POINTER\n         ST    R13,4(,R1)         POINTER TO CALLER'S SAVE AREA\n         LR    R13,R1             @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(,R13)        POINT TO CALLER'S RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 RC IF BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 RC IF BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(,RML)              MESSAGE LENGTH\n         STH   R15,PUTLEN               PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(,R2)       @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(,R2)               REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    R2,R13                   @OUR SAVE AREA\n         LR    R3,R15                   SAVE RETURN CODE\n         L     R13,4(,R13)              @CALLER'S SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,R3                   RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLER'S REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END   EPUTL\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTHEA$": {"ttr": 3848, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00$\\x01\\x055O\\x01 \\x03O\\x08V\\x00\\x1c\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2005-12-20T00:00:00", "modifydate": "2020-02-03T08:56:24", "lines": 28, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT499.FILE423(LISTHEAD)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,9),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET,NOREUS,NORENT'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(0)\n SETSSI  CB499423\n ENTRY   LISTHEAD\n NAME    LISTHEAD(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTHEA#": {"ttr": 3850, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x008\\x01\\x12#\\x9f\\x01\\x19#? \"\\x00f\\x00/\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2012-08-26T00:00:00", "modifydate": "2019-08-21T20:22:38", "lines": 102, "newlines": 47, "modlines": 0, "user": "SBGOLOB"}, "text": "         HELP MEMBER FOR LISTHEAD TSO COMMAND PROCESSOR\n         ---- ------ --- -------- --- ------- ---------\n\n)F FUNCTION -\n\n    The LISTHEAD TSO command was written by Jeff Broido, with the\n    purpose of finding out whether modules from the system, have\n    standard headers.  In the \"old days\", before the greatly\n    extended instruction set for z/OS, there were just a few\n    standard ways for starting a module, and displaying a header\n    for it, which would tell you which version of the module you\n    have.  Now, there are a lot more ways of starting a module,\n    and IBM has taken advantage of them.  Therefore, there are a\n    lot more ways to create \"IBM standard headers\".\n\n    Jeff's original program is kept here as member LISTHE01.\n\n    LISTHEAD operates by doing a LOAD macro instruction, to attempt\n    to load a module into your private storage.  Then it looks at\n    the beginning of the module to determine if there is a standard\n    header for it, in some standard IBM format.  The way Jeff wrote\n    this program, if the header was not standard, the program would\n    not display it.  I wanted to generalize the program so that all\n    normal header information, \"IBM standard\" or not, would be\n    displayed.\n\n    So I added a display to show the first 300 bytes from the\n    beginning of the module's storage, in any case, so you can see\n    what's there.  If the format of the eyecatcher at the beginning\n    is \"somewhat standard\", in other words, the program branches\n    past it, and goes on to execute \"real instructions\", then I\n    attempt to display the stuff that has been branched around,\n    considering it as \"header information\".\n\n    New instructions that can be used to start a module are BRC\n    (Branch Relative on Condition - unconditional JUMP), and LARL\n    (Load Address Relative Long).  IBM uses these to start a module\n    VERY OFTEN nowadays.  So these are now looked for, by LISTHEAD.\n    Also, BAS (Branch and Save) sometimes also occurs at the\n    beginning of a module.\n\n)X SYNTAX  -\n\n    LISTHEAD modname  (operands)\n\n)O OPERANDS -\n\n    none (default)  -  Show everything\n\n    ENTRY   -  Loads the module starting from the entry point\n\n    NOHEX   -  Does not \"hex display\" the first 300 bytes at the\n               beginning of the module.\n\n    NOTITLE -  Does not display the title line saying which module\n               was loaded.\n\nNotes:\n\n  Here is some sample output from this program.  The program now\n   filters out most unprintable characters.\n\nSample Outputs:                         (extend to 100 bytes out)\n\nLISTHEAD IKJEFT02\nLoaded Program Name:  IKJEFT02\n-----------------------------------------------------------------\nLength  of loaded module:     0000AB50\nFirst 300 bytes of Loaded Storage (load module e.p. + 300 bytes):\n-----------------------------------------------------------------\n 00  k IKJEFT02:TMP MAINLINE CONTROL PROGRAM 17075 140244 HTE77B0\n4FF4093CDDCCEFF7EDD4DCCDDCDC4CDDEDDD4DDDCDCD4FFFFF4FFFFFF4CECFFCF\n700802A92156302A3470419539550365396307967914017075014024408357720\n----+----1----+----2----+----3----+----4----+----5---------6----+\n     0-     i0    -      A&}{ &{} q1}   \u00a200    &          {\nB4004F6200108F00BF6111071C5DC05CD09FD11D4FF00F55B443001544C014130\n6670700200209008FD0EB1A8810004000881008CA0047F8065100CB31000A3B3E\n----+----1----+----2----+----3----+----4----+----5---------6----+\nj    \\-o \\S   \\     o    0-  a    m\"   \\   \\\\% \\\\ &\\           \\\n98374E695EE658E3B001988A4F6A18B001978A5E025EE65EE15E855282B0204E6\n10007006802880002A00600A7000812A004F0A8024800C8004000880002A00502\n----+----1----+----2----+----3----+----4----+----5---------6----+\n-----------------------------------------------------------------\nLoad Module Header at Entry Point:\n k IKJEFT02:TMP MAINLINE CONTROL PROGRAM 17075 140244 HTE77B0 \u00e500\n\n\n\nLISTHEAD IKJEFT02 NOHEX\nLoaded Program Name:  IKJEFT02\nLength  of loaded module:     0000AB50\n-----------------------------------------------------------------\nLoad Module Header at Entry Point:\n k IKJEFT02:TMP MAINLINE CONTROL PROGRAM 17075 140244 HTE77B0 \u00e500\n\n\n\nLISTHEAD IKJEFT02 NOHEX NOTITLE\n\n k IKJEFT02:TMP MAINLINE CONTROL PROGRAM 17075 140244 HTE77B0 \u00e500\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTHEAD": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01P\\x00\\x14\\x01\\x19$\\x9f\\x01 \\x03O\\x089\\x04\\xf3\\x04\\x95\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.80", "flags": 0, "createdate": "2019-09-06T00:00:00", "modifydate": "2020-02-03T08:39:14", "lines": 1267, "newlines": 1173, "modlines": 0, "user": "SBGOLOB"}, "text": "LISTHEAD TITLE '- TSO command to list load module eye-catchers.'\n         SPACE 1\n* ------------------------------------------------------------------- *\n***********************************************************************\n*                                                                     *\n*     LISTHEAD - TSO command to list the eye-catcher, if any, in      *\n*           the entry point CSECT of a load module in the normal      *\n*           search path.                                              *\n*                                                                     *\n*           Modified to list more non-standard eye catchers. (SG)     *\n*           Modified to give a 3-line hex display. (SG) - 7/19        *\n*           Modified to access the entry point or the load point,     *\n*               using the keyword ENTRY or by omitting it.            *\n*                                                                     *\n*     Register usage:                                                 *\n*           R5 - Base.                                                *\n*           R6 - Work.                                                *\n*           R7 - Work.                                                *\n*           R8 - Work.                                                *\n*           R9 - Work, Parse PDEs.                                    *\n*          R10 - CPPL pointer.                                        *\n*          R12 - Base.                                                *\n*                                                                     *\n*                               Jeffrey R. Broido                     *\n*                               25 April 2001                         *\n*                                                                     *\n*                               Modified by S.Golob  -  4/10          *\n*                               Modified by Updater  -  7/14          *\n*                               Modified by S.Golob  - 12/16          *\n*                               Modified by S.Golob  -  7/19          *\n*                               Modified by S.Golob  -  8/19          *\n*                               Modified by S.Golob  -  9/19          *\n*                                                                     *\n*     Change History (of sorts):                                      *\n*                                                                     *\n*        The original purpose of this program seems to have been,     *\n*        to display standard IBM headers in their load modules.       *\n*        Traditionally, an IBM-written load module would begin        *\n*        with an unconditional branch instruction X'47F0' that        *\n*        would branch over a standard-looking eyecatcher which        *\n*        told you the name of the module, and its release or PTF      *\n*        level.  These headers seem to be what the author of          *\n*        this program wanted to display.  ONLY THOSE HEADERS and      *\n*        no others.                                                   *\n*                                                                     *\n*        But things have changed in the IBM world, and the load       *\n*        modules which IBM produces, have fully reflected these       *\n*        changes.                                                     *\n*                                                                     *\n*        There are now other instructions which do unconditional      *\n*        branches, besides the BC instruction (whose unconditional    *\n*        format is X'47F0').  There are JUMP instructions and LARL    *\n*        instructions, and there are also BAKR and PR combinations.   *\n*        IBM uses all of these, and therefore, this program must      *\n*        change to reflect all of this new stuff from IBM.            *\n*                                                                     *\n*        The program works (currently) by issuing a LOAD macro        *\n*        against desired load module, and it searches the first       *\n*        few bytes of the loaded module, to see what is there.        *\n*                                                                     *\n*        If there are branch or jump instructions, then the program   *\n*        displays what was branched or jumped over.                   *\n*                                                                     *\n*        For diagnosis purposes, if you need to investigate near      *\n*        the beginning of any module entry point, the program will    *\n*        display the first 300 bytes at the load module entry         *\n*        point, in 3-line hexadecimal representation.                 *\n*                                                                     *\n*        If a load module contains multiple modules, each with its    *\n*        own header, these are not displayed.  Only the entry point   *\n*        header is displayed, or the header at the beginning of the   *\n*        module is displayed, if the ENTRY keyword was not used.      *\n*                                                                     *\n*        Sometimes a program is coded with comments at the beginning  *\n*        and the entry point, off the beginning, points to a BAKR     *\n*        instruction, or something similar, with the (non-executable) *\n*        comments at the beginning.  The LOAD macro does not return   *\n*        the address of these comments, and at the present time       *\n*        therefore, they cannot be displayed.  If the entry point     *\n*        is a BAKR instruction, the program was changed to say so.    *\n*        Hope this helps a bit more than before.  (SBG - June 2014)   *\n*                                                                     *\n*        Updated by Updater (July 20, 2014):                          *\n*        Process now adjusted to load the entire module, even if the  *\n*        entry point is not at the beginning.  This takes care of     *\n*        \"almost normal\" modules from SYS1.VTAMLIB and such, with     *\n*        the entry point just AFTER the eyecatcher.  The command      *\n*        previously would not therefore show such an eyecatcher.      *\n*        So the command was modified to find the address at the       *\n*        beginning of the module, even if the entry point officially  *\n*        was later.  If you want to display the entry point alone,    *\n*        then use the ENTRY keyword after the module name:            *\n*                                                                     *\n*                 example:    LISTHEAD modname ENTRY                  *\n*                                                                     *\n*        Please note that the HEX display will show all hex values    *\n*        in \"printable\" format, so you don't need any other tools     *\n*        to see the first 300 bytes of the load modules, displayed    *\n*        in a 3-line hexadecimal display.                             *\n*                                                                     *\n*        For some modules, such as IEBCOPY, you have to use the       *\n*        ENTRY parameter to get a realistic eyecatcher.  You'll       *\n*        have to try both ways with some modules, to see which        *\n*        way shows the beginning of the module more realistically.    *\n*                                                                     *\n*        If you want to see a hex display of the entire module, or    *\n*        from the entry point to the end of the module, use the       *\n*        LISTMOD program, which is a derivative of this program.      *\n*        (CBT File 423 or 994).                                       *\n*                                                                     *\n*        Updated by Sam Golob (December 12, 2016):           *DEC-2016*\n*        Updated by Sam Golob again (June 2, 2019)                    *\n*           (Made 3-line hex display instead of raw data)             *\n*        Updated by Sam Golob again (September 2019)                  *\n*                                                                     *\n*        Added a few extra keywords to limit the display:             *\n*                                                                     *\n*         NOHEX   - Leaves out the hex display of the first 300       *\n*                   bytes of the module.                              *\n*         NOTITLE - Leaves out the line telling you which module      *\n*                   got loaded.                                       *\n*                                                                     *\n*        Executing with NOHEX and NOTITLE produces the result that    *\n*        this program used to produce, before it was modified.        *\n*                                                                     *\n*        Accounted for possible NOOP instructions at the beginning    *\n*        of the program, before the branch over the header.           *\n*                                                                     *\n*        Fixed bug in EPUTL to GETMAIN SP=0 and FREEMAIN SP=0         *\n*                                                                     *\n*     CHANGES:  2020/02/03 - SBG                                      *\n*               Changed ruler to go from 0 to 99 instead of           *\n*               from 1 to 100.  It had been one byte off.             *\n*                                                                     *\n***********************************************************************\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\n         MACRO                         Display hex numbers\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         STM   R15,R1,HEXSAVE          Save work registers.\n         LA    R1,&FROM                From location\n         LA    R0,&LEN                 Length to display\n         LA    R15,&TO                 Where to display\n         BAL   R4,HEX                  Do it.\n         LM    R15,R1,HEXSAVE          Restore work registers.\n         MEND\n* ------------------------------------------------------------------- *\nLISTHEAD AMODE 31                  Display load module headers.\nLISTHEAD RMODE ANY\nLISTHEAD CSECT\n         SPACE 1\n         SPACE 1\n         YREGS\n         USING LISTHEAD,R15        (ESTABLISH TEMPORARY BASE).\n         B     BEGIN               SKIP OVER HEADER.\nHEAD0    DC    AL1(HEADL)          EXCLUSIVE LENGTH OF HEADER.\nHEAD     DC    C'LISTHEAD - &SYSDATE - &SYSTIME  '\nHEADL    EQU   *-HEAD\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         LR    R12,R15             COPY BASE.\n         USING LISTHEAD,R12,R5     (TELL ASSEMBLER).\n         LA    R5,4095(,R12)\n         LA    R5,1(,R5)\n         LR    R14,R13             COPY CALLER'S SAVE AREA POINTER.\n         LA    R13,SAVE            POINT TO MY SAVE AREA.\n         ST    R14,SAVE+4          CHAIN ...\n         ST    R13,8(,R14)         ... SAVE AREAS.\n         SPACE 1\n         MVI   LINE-1,X'40'\n         MVC   LINE,LINE-1\n         MVI   BLANKS-1,X'40'      FILL THE BLANKS FIELD\n         MVC   BLANKS,BLANKS-1       WITH BLANKS\n         MVC   MEMBER,BLANKS       Initialize member name with blanks.\n         LR    R10,R1              PRESERVE CPPL POINTER.\n         XC    FLAG3,FLAG3\n         USING CPPL,R10            (TELL ASSEMBLER)\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        Initialize the Parse Parameter List and call TSO Parse.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         MVC   PPLUPT,CPPLUPT      COPY UPT ADDRESS.\n         MVC   PPLECT,CPPLECT      COPY ECT ADDRESS.\n         MVC   PPLCBUF,CPPLCBUF    COPY COMMAND BUFFER ADDRESS.\n         SPACE 1\n         LA    R1,PPL              POINT TO THE PPL.\n         XC    ECB,ECB             CLEAR ECB.\n         CALLTSSR EP=IKJPARS       PARSE INPUT.\n         ST    R15,SAVPARCD        SAVE RETURN CODE.\n         L     R9,ANS              POINT TO PDES.\n         USING PDL,R9              TELL ASSEMBLER.\n         LH    R1,PDLLM+4          LOAD LENGTH OF LOAD MODULE NAME.\n         BCTR  R1,*-*              DECREMENT LENGTH.\n         L     R15,PDLLM           POINT TO RETURNED MEMBER NAME.\n         EX    R1,MVMEM            COPY MEMBER NAME FROM PDL\n*      ( MVC   MEMBER(*-*),0(R15)  )\n         MVC   ENTRYOP,ENTRYKW     COPY PDE'S\n         MVC   NOHEXOP,NOHEXKW                               *DEC-2016*\n         MVC   NOTITOP,NOTITKW                               *DEC-2016*\n         MVC   HEXOP,HEXKW\n         MVC   TITOP,TITKW\n*                                  DON'T DO IKJRLSA\nGODISPLY DS    0H\n         MVI   LINE-1,X'40'        INITIALIZE DISPLAY AREA\n         L     R15,SAVPARCD        RETURN CODE FROM IKJPARS\n         LTR   R15,R15             INVALID PARAMETER ?\n         BNZ   HELPMSG             GO ISSUE HELP MSG AND EXIT.\n         DROP  R9\n         CLI   NOTITOP+1,1         NOTITLE?\n         BE    NOTIT1              YES, SKIP DISPLAY OF TITLE.\n         MVC   LINE,LINE-1\n         MVC   LINE(22),=C'Loaded Program Name:  '\n         MVC   LINE+22(8),MEMBER\n         CLI   ENTRYOP+1,1\n         BNE   PUTTIT01\n         MVC   LINE+42(13),=C'(Entry Point)'\n         B     PUTTIT02\nPUTTIT01 DS    0H\n         MVC   LINE+42(12),=C'(Load Point)'\nPUTTIT02 DS    0H\n         APUT  LINE,60\nNOTIT1   DS    0H                  Print a line of dashes\n         CLI   NOHEXOP+1,1         If NOHEX keyword\n         BE    LPA0                Then don't print dashes\n         MVC   LINE,LINE-1\n         MVC   LINE(65),DASHES\n         APUT  LINE,65\nNOTIT2   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        Fetch the user-specified load module.                        *\n*                                                                     *\n***********************************************************************\n* ------------------------------------------------------------------- *\n*    We first ask if the module is from LPA, and if not, then we      *\n*    LOAD it.                                                         *\n* ------------------------------------------------------------------- *\n*    LOGIC OF THE PROGRAM WAS CHANGED TO DO A STANDARD \"LOAD\" FOR     *\n*    THE MODULE REQUESTED, BUT TO AFTERWARDS, ALSO CALCULATE THE      *\n*    MODULE ENTRY POINT IN THE DIFFERENT WAYS POSSIBLE, AND TO SAVE   *\n*    ALL THE RESULTS.  AFTERWARDS, DEPENDING ON WHETHER THE \"ENTRY\"   *\n*    PARAMETER WAS CODED, THE RESULTS ARE DISPLAYED ACCORDINGLY.      *\n* ------------------------------------------------------------------- *\nLPA0     DS    0H\n         LM    R0,R1,MEMBER       Load member name for IEAVVMSR\n         STM   R7,R8,LPAREGS      Save registers\n         L     R3,16              CVT\n         L     R15,352(,R3)       CVTLPDSR\n         BALR  R14,R15            CALL IEAVVMSR\n         B     LPAINFO            MODULE IS IN LPA, GET LPDE.\n         B     LOAD0              NOT IN LPA, TRY LOADING IT.\nLPAINFO  DS    0H\n         OI    FLAG2,X'01'        FLAG THE MODULE AS AN LPA MODULE.\n         LM    R7,R8,LPAREGS      RESTORE REGISTERS\n         LR    R6,R0              SAVE LPDE ADDRESS\n         ST    R6,LPDEADDR        And store it for reporting\n         L     R9,16(,R6)         GET ENTRY POINT ADDRESS\n         N     R9,=X'7FFFFFFF'    Get rid of high bit.\n         ST    R9,SAVER9B         SAVE MODULE ENTRY POINT\n         TM    X'1C'(R6),X'04'    IS THIS A MINOR LPDE (ALIAS)?\n         BZ    MAJLPDE            NO. PROCESS AS A MAJOR.\n         OI    FLAG2,X'02'        Mark this one as an alias.\n         MVC   MAJNAME(8),X'20'(R6)  Copy the major name for report.\n         L     R6,X'14'(,R6)      YES. GET ADDRESS OF MAJOR LPDE.\nMAJLPDE  DS    0H\n         L     R9,X'24'(,R6)      GET MODULE LOAD POINT.\n         N     R9,=X'7FFFFFFF'    Remove the 31-bit indicator\n         ST    R9,ADRSTART        Start of the full data of the module\n         ST    R9,SAVER9A         Save it in another place\n         ST    R9,SAVER9C         SAVE THE LOAD POINT.\n         L     R9,X'20'(,R6)      GET THE SIZE OF THE LOAD MODULE.\n         ST    R9,LOADLEN         SAVE THE ENTIRE SIZE\n         MVC   LOADWHOL,LOADLEN   COPY WHOLE SIZE\n         L     R2,SAVER9B         GET THE ENTRY POINT\n         L     R3,SAVER9C         SUBTRACT THE LOAD POINT\n         SR    R2,R3              GET THE DISPLACEMENT\n         BNP   ENTRYPM1           GO TO SAME CALC AS WITH LOAD\n         ST    R2,STORDIFF        SAVE THE DISPLACEMENT\n         B     ENTRYPM0           GO TO THE SAME CALC AS WITH LOAD\n* ------------------------------------------------------------------- *\n         SPACE 1\nLOAD0    DS    0H\n         LOAD  EPLOC=MEMBER,ERRET=LOAD1  FETCH LOAD MODULE TO LIST.\n*    Put in a display of x number of bytes at the load point, here.\nLOAD1    LTR   R15,R15             WAS LOAD SUCCESSFUL?\n         BZ    LOAD2               B IF YES; CONTINUE.\n*              SAY: CANNOT LOAD MEMBER.\n         MVC   LINE,LINE-1\n         MVC   LINE(MSG002L),MSG002\n         APUT  LINE,MSG002L\n         LA    R15,8               SET CC = 8.\n         ST    R15,SAVER15A        SAVE THE RETURN CODE\n         B     EXIT                EXIT.\nLOAD2    DS    0H\n         LR    R9,R0               POINT TO LOAD MODULE TO BE LISTED.\n         N     R9,=X'7FFFFFFF'     Get rid of high bit for calculations\n         ST    R9,ADRSTART         Start of the full data of the module\n         ST    R9,SAVER9A          Save load module data address\n         ST    R9,SAVER9B          Save it again in another place\n         NC    SAVER9B(4),=A(X'7FFFFFFF')  Maybe not necessary\n         N     R1,=A(X'00FFFFFF')  ISOLATE LENGTH IN DWORDS  *JUL-2014*\n         ST    R3,SAVER3B          Save R3\n         LR    R3,R1               Get length in doublewords\n         SLL   R3,3                Convert to bytes\n         ST    R3,SAVER3A          SAVE ORIGINAL LENGTH\n         L     R3,SAVER3B          Restore R3\n         SLL   R1,3                COMPUTE LENGTH IN BYTES   *JUL-2014*\n         ST    R1,LOADLEN          SAVE MAX DISPLAY LENGTH   *JUL-2014*\n         MVC   LOADWHOL,LOADLEN    Save it again\n* NOTE: IF THE 'ENTRY' KEYWORD IS SPECIFIED, AND THE         *JUL-2014*\n* ENTRY POINT IS NEAR THE END OF THE MODULE, THERE MAY BE    *JUL-2014*\n* FEWER BYTES THAN THE LOADLEN VALUE FROM THE ENTRY POINT    *JUL-2014*\n* TO THE END OF THE MODULE. AS A RESULT, THE DISPLAY OF      *JUL-2014*\n* LOADLEN BYTES MIGHT INCLUDE THE CONTENTS OF MEMORY BEYOND  *JUL-2014*\n* THE END OF THE MODULE.                                     *JUL-2014*\n*        CLI   ENTRYOP+1,1         IF ENTRY OR EP KEYWORD    *JUL-2014*\n*        BE    KEEPR9              SKIP THE NEW CODE         *JUL-2014*\n* IF THE LAST CDE IN JOB PACK AREA QUEUE IS FOR A MODULE     *JUL-2014*\n* THAT CONTAINS THE ENTRY POINT ADDRESS IN R9, USE THE       *JUL-2014*\n* ADDRESS OF THE MODULE INSTEAD OF THE ENTRY POINT.          *JUL-2014*\n* NOTE: COULD ALSO USE LOADPT= ON THE LOAD MACRO, BUT        *JUL-2014*\n* MVS 3.8 SYSTEMS DON'T HAVE LOADPT=.                        *JUL-2014*\n         N     R9,=A(X'7FFFFFFF')                            *JUL-2014*\n         L     R14,540             PSATOLD -> CURRENT TCB    *JUL-2014*\n         L     R14,TCBJSTCB-TCB(,R14) POINT TO JOB STEP TCB  *JUL-2014*\n         L     R14,TCBJPQ-TCB(,R14) PNT TO LAST CDE IN JPAQ  *JUL-2014*\n* ------------------------------------------------------------------- *\n*              The correct CDE might not be the last one,             *\n*             so chain back until you've got a name match.            *\n* ------------------------------------------------------------------- *\nCDELOOP  DS    0H                  Check if CDE matches member name\n         CLC   MEMBER(8),8(R14)    Is this the correct CDE? (match)\n         BE    CDEEND              Yes, then process it.\n         CLC   FULLZERO,0(R14)     Back at the beginning of the chain\n         BE    CDEBAD                without a match? Then error.\n         L     R14,0(,R14)         No match. Go back one previous CDE.\n         B     CDELOOP             Keep trying till match or first CDE\n*                                    without a match.\nCDEBAD   DS    0H\n         MVC   LINE,LINE-1         Error message if beginning of CDE\n         MVC   LINE(MSG003L),MSG003  was reached without a name match.\n         APUT  LINE,MSG003L\n         B     EXIT12              Code 12 for this one.\nCDEEND   DS    0H\n         ST    R14,CDEADDR         Store address of CDE found.\n         TM    CDATTR-CDENTRY(R14),CDMIN TEST FOR MINOR CDE  *JUL-2014*\n         BZ    MAJCDE              BRANCH IF MAJOR CDE       *JUL-2014*\n         L     R14,CDXLMJP-CDENTRY(,R14) POINT TO MAJOR CDE  *JUL-2014*\nMAJCDE   L     R14,CDXLMJP-CDENTRY(,R14) POINT TO EXTENT     *JUL-2014*\n         L     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*\n         ST    R0,SAVER9C\n         CR    R9,R0                                         *JUL-2014*\n         BL    KEEPR9                                        *JUL-2014*\n         L     R0,XTLMSBLA-XTLST(,R14) LENGTH OF MODULE      *JUL-2014*\n         N     R0,=A(X'7FFFFFFF')                            *JUL-2014*\n         ST    R0,SAVER1B\n         A     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*\n         ST    R0,SAVER9D\n         CR    R9,R0                                         *JUL-2014*\n         BNL   KEEPR9                                        *JUL-2014*\n         L     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*\n         LR    R9,R0                                         *JUL-2014*\n         ST    R9,SAVER9E\n* ------------------------------------------------------------------- *\n*            COME HERE FOR BOTH LPA AND LOADED MODULES                *\n* ------------------------------------------------------------------- *\nENTRYPM  DS    0H                  Check if entry point is displaced.\n         L     R2,SAVER9B          Get entry point of module\n         L     R3,SAVER9C          Get beginning addr of module\n         SR    R2,R3               Calculate difference in length\n         BNP   ENTRYPM1            Do a LOAD if number is not reliable\n         ST    R2,STORDIFF         Save the entry point displacement.\n*\nENTRYPM0 DS    0H\n         LTR   R2,R2               Is then entry point displacement 0?\n         BZ    NODIFF              Then do the whole module.\n*\nENTRYPM1 DS    0H                  It is different, then calculate.\n         L     R1,LOADWHOL         Entire length from LOAD macro\n         MVC   SAVER3A,LOADWHOL    Save it.\n         S     R1,STORDIFF         Subtract offset of entry point\n         ST    R1,LOADSMAL         Preserve reduced load length\n         MVC   SAVER3B,LOADSMAL    Save short length for later\n         B     YESDIFF             Yes, entry point diff from load pt\nKEEPR9   EQU   *                                             *JUL-2014*\n*\nNODIFF   DS    0H                  Go here if entry pt is load point\n         MVC   LOADSMAL,LOADWHOL   Size is from beginning to end\n         MVC   SAVER3B,LOADSMAL    Save size from entry point to end\n         L     R1,LOADWHOL         Load R1 with size\n         OI    FLAG1,X'01'         Flag load point equal entry point\n         L     R9,ADRSTART         Load R9 with data address\n*\nYESDIFF  DS    0H\n         TM    FLAG1,X'01'         Load point different from entry pt?\n         BZ    ENTRYDIF            No. Skip this section.\n         L     R1,LOADWHOL         Start R1 with whole size.\n         ST    R1,LOADLEN          And store it in LOADLEN.\n         L     R9,ADRSTART         Load R9 with data address\n* ------------------------------------------------------------------- *\nENTRYDIF DS    0H                  Display of Diagnostic Data\n         ST    R9,SAVER9A          SAVE THE PROGRAM DATA\n         CLI   NOTITOP+1,1         NOTITLE coded?\n         BE    KEEPR9A             Yes. Then skip this display.\n         MVC   LINE,LINE-1\n         MVC   LINE(28),=C'Length  of loaded module:     '\n         HEX   LINE+28,4,SAVER3A\n         MVC   LINE+41(11),=C'Load point:'\n         HEX   LINE+54,4,SAVER9C\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,65\n         LM    R14,R1,SAVE14T1\n         MVC   LINE,LINE-1\n         MVC   LINE(25),=C'Entry Point Displacement:'\n         HEX   LINE+28,4,STORDIFF\n         MVC   LINE+40(12),=C'Entry point:'\n         HEX   LINE+54,4,SAVER9B\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,65\n         LM    R14,R1,SAVE14T1\nKEEPR9A  DS    0H\n*\n         ST    R0,LADRSAVE\n         CLI   NOHEXOP+1,1         IF NOHEX KEYWORD          *DEC-2016*\n         BE    NODASH1             THEN DON'T PRINT HEX TITLE\n         MVC   LINE,LINE-1         PRINT THE HEX DISPLAY TITLE\n         MVC   LINE(65),=C'First 300 bytes of Loaded Storage (load modux\n               le e.p. + 300 bytes):'\n         APUT  LINE,70\n         MVC   LINE,LINE-1\n         MVC   LINE(65),DASHES\n         APUT  LINE,65\nNODASH1  DS    0H                                            *DEC-2016*\n* ------------------------------------------------------------------- *\n*              PREPARE FOR HEX DISPLAY OF ALL LINES                   *\n* ------------------------------------------------------------------- *\nENTRYPRM DS    0H                  Process the ENTRY keyword here.\n         CLI   ENTRYOP+1,1         Entry keyword not there?\n         BNE   BIGMOD              Go treat whole module.\n         L     R9,SAVER9B          Data address at entry point\n         ST    R9,SAVER9A          Store address away for display.\n         L     R1,LOADSMAL         Load reduced size, e.p. to end.\n         ST    R1,LOADLEN          Store that length for display\n         B     SMALLMOD            Don't display the whole module.\nBIGMOD   DS    0H\n         L     R9,SAVER9C          Address of beginning of the data.\n         ST    R9,SAVER9A          Store address away for display.\n         L     R1,LOADWHOL         Load the full size of the module.\n         ST    R1,LOADLEN          Store that length for display\n*        MVC   LOADLEN,LOADWHOL\n*              IF THE MODULE SIZE < 64 THEN DON'T SHOW 64\nSMALLMOD DS    0H\n         ST    R9,SAVER9A          Save pointer to the data.\n         CLI   NOHEXOP+1,1         If NOHEX keyword\n         BE    JUST1               Then skip all the hex printing.\n* ------------------------------------------------------------------- *\n*              PREPARE FOR HEX DISPLAY OF ONE LINE                    *\n* ------------------------------------------------------------------- *\n         L     R9,SAVER9A          Reload address of the data\n*              IF THE MODULE SIZE < 100 THEN DON'T SHOW 100\n         L     R1,LOADLEN          Get module length in bytes\n         CH    R1,=H'100'          Less than 100?\n         BNH   *+8                 Yes, skip limit to 100.\n         LH    R1,=H'100'          No. Just print 100 at a time\n         BCTR  R1,0                One less for execute.\n         ST    R1,SAVER1A          Save the length - 1\n         BAL   R7,PRTXLINE         Print these 100 bytes in hex\n* ------------------------------------------------------------------- *\n*                       DISPLAY SECOND LINE                           *\n* ------------------------------------------------------------------- *\n         L     R9,SAVER9A          Reload address of the data\n         LA    R9,100(,R9)         Skip 100 bytes from current\n         L     R1,LOADLEN          Get module length in bytes\n         S     R1,=F'100'          Subtract 100\n         BNP   JUST1               Finished? Stop the process.\n         CH    R1,=H'100'          Less than 100 bytes left?\n         BNH   *+8                 Yes. Use the current value\n         LH    R1,=H'100'          No. Limit the print to 100 bytes.\n         BCTR  R1,0                One less for execute.\n         ST    R1,SAVER1A          Save the length - 1\n         BAL   R7,PRTXLINE         Print these 100 bytes in hex\n* ------------------------------------------------------------------- *\n*                        DISPLAY THIRD LINE                           *\n* ------------------------------------------------------------------- *\n         L     R9,SAVER9A          Reload address of the data\n         LA    R9,200(,R9)         Skip 200 bytes from current\n         L     R1,LOADLEN          Get module length in bytes\n         S     R1,=F'200'          Subtract 200\n         BNP   JUST1               Finished? Stop the process.\n         CH    R1,=H'100'          Less than 100 bytes left?\n         BNH   *+8                 Yes. Use the current value\n         LH    R1,=H'100'          No. Limit the print to 100 bytes.\n         BCTR  R1,0                One less for execute.\n         ST    R1,SAVER1A          Save the length - 1\n         BAL   R7,PRTXLINE         Print these 100 bytes in hex\n* ------------------------------------------------------------------- *\n*                      END OF HEX DISPLAY                             *\n* ------------------------------------------------------------------- *\n*      NOW CHECK TO SEE IF THERE IS SOME KIND OF STANDARD HEADER      *\n* ------------------------------------------------------------------- *\nJUST1    EQU   *                   CHECK FOR INITIAL INSTRUCTIONS\n         L     R9,SAVER9A          Point to the data to check it.\n* ------------------------------------------------------------------- *\n*        ARE THERE LEADING NOOPS OR NULL BRANCHES OF ANY KIND?        *\n* ------------------------------------------------------------------- *\n         LA    R6,0                INITIALIZE R6 FOR LIMITING DISPLAY\nSKIPLOOP DS    0H                  SKIP ANY NOOP INSTRUCTIONS\n         MVC   WORKINST(8),0(R9)   MOVE 8 BYTES TO WORK AREA\n         CLC   =X'A704',WORKINST   IS THIS A JUMP NOOP?\n         BNE   TRYMOR01            NO. NEXT TRY.\n         LA    R9,4(,R9)           ADVANCE 4 BYTES\n         LA    R6,4(,R6)           SUBTRACT 4 BYTES PAST HEADER\n         B     SKIPLOOP            TRY IF MORE NOOPS\nTRYMOR01 DS    0H                  IS THIS A BRANCH NOOP?\n         MVC   WORKINST(8),0(R9)   RELOAD WORK AREA\n         NC    WORKINST(2),=X'FFF0'  IGNORE INDEX REGISTER\n         CLC   =X'4700',WORKINST   CHECK IF BRANCH NOP TO ANYWHERE\n         BNE   TRYMOR02            NO. NEXT TRY.\n         MVC   WORKINST(8),0(R9)   YES. RELOAD WORK AREA\n         LA    R9,4(,R9)           ADVANCE 4 BYTES\n         LA    R6,4(,R6)           SUBTRACT 4 BYTES PAST HEADER\n         B     SKIPLOOP            TRY IF MORE NOOPS.\nTRYMOR02 DS    0H                  IS THIS A BR NOOP?\n         MVC   WORKINST(8),0(R9)   RELOAD WORK AREA\n         NC    WORKINST(2),=X'FFF0'  IGNORE DESTINATION REGISTER\n         CLC   =X'0700',WORKINST   IS IT A NOPR?\n         BNE   TRYMORE             NO. NEXT TRY.\n         LA    R9,2(,R9)           ADVANCE 2 BYTES\n         LA    R6,2(,R6)           SUBTRACT 2 BYTES PAST HEADER\n         B     SKIPLOOP            TRY IF MORE NOOPS.\nTRYMORE  DS    0H\n*\n*    CHECK FIRST FOR LARL AT THE BEGINNING OF THE MODULE..........  SBG\n*    CHECK ALSO FOR BRANCH AND SAVE AT THE BEGINNING..............  SBG\n*\n         CLC   =X'0D',0(R9)        IS BEGINNING OF MODULE BAS?\n         BNE   TRYLARL             NO. TRY LARL.\n         LA    R9,2(,R9)           BUMP PAST BAS.\n         LA    R6,2(,R6)\n         B     TRYNORML            CHECK IF NORMAL LABEL IS THERE.\nTRYLARL  DS    0H\n         CLC   =X'C0300000',0(R9)  LARL?                            SBG\n         BNE   TRYNORML            NO. REGULAR PROCESSING.          SBG\n         LA    R9,6(,R9)           BUMP PAST STUFF.                 SBG\n         LA    R6,6(,R6)\nTRYNORML DS    0H\n         CLC   =X'47F0',0(R9)      POSSIBLY STANDARD HEADER?\n         BE    LOAD3               B IF YES; CONTINUE.\n         CLC   =X'05F047F0',0(R9)  POSSIBLY STANDARD HEADER?\n         BNE   TRYNORMZ            NO. TRY NEW JUMP INSTRUCTION.    SBG\n         LA    R9,2(,R9)           YES. BUMP LOAD MODULE ORIGIN.\n         LA    R6,2(,R6)\n         B     LOAD3               CONTINUE.\nTRYNORMZ DS    0H\n         CLC   =X'47FF',0(R9)      POSSIBLY STANDARD HEADER?\n         BE    LOAD3               B IF YES; CONTINUE.\n         CLC   =X'05F047FF',0(R9)  POSSIBLY STANDARD HEADER?\n         BNE   TRYA7               NO. TRY NEW JUMP INSTRUCTION.    SBG\n         LA    R9,2(,R9)           YES. BUMP LOAD MODULE ORIGIN.\n         LA    R6,2(,R6)\n         B     LOAD3               CONTINUE.\nTRYA7    DS    0H\n         CLC   =X'A7F4',0(R9)      IS IT BRC UNCONDITIONAL?\n         BNE   TRYSTMF             B IF NOT.  ERROR.\n         MVC   WORKHALF(2),2(R9)   GET NUMBER OF HALFWORDS\n         L     R8,WORKFULL         LOAD REGISTER WITH THEM\n         SLL   R8,1                MULTIPLY BY 2 TO GET BYTES\n         B     BRANCHA7            CONTINUE PROCESSING NORMALLY\nTRYSTMF  DS    0H                  TRY STORE MULTIPLE FIRST\n         MVC   WORK08(8),0(R9)     X'90ECD00C05B047F0'\n         NI    WORK08+5,X'0F'      NULLIFY BASE REG FOR COMPARE\n         CLC   =X'90ECD00C050047F0',WORK08     Example: AMDPRFMT\n         BNE   TRYLR\n         LA    R9,6(,R9)           Get to the 47F0.\n         LA    R6,6(,R6)           Eliminate stuff at beginning.\n         OI    FLAG3,X'01'         Kludge flag for this header.\n         B     TRYNORML            Look at regular 47F0 from here.\nTRYLR    DS    0H                  TRY STORE MULTIPLE FIRST\n         MVC   WORK08(8),0(R9)     X'90ECD00C18xf47F0'\n         NI    WORK08+5,X'0F'      NULLIFY BASE REG FOR COMPARE\n         CLC   =X'90ECD00C180F47F0',WORK08     Example: IEBGENER\n         BNE   NONSTD\n         LA    R9,6(,R9)           Get to the 47F0.\n         LA    R6,6(,R6)           Eliminate stuff at beginning.\n         OI    FLAG3,X'01'         Kludge flag for this header.\n         B     TRYNORML            Look at regular 47F0 from here.\nNONSTD   DS    0H\n*                         SAY: LOAD MODULE HAS NON-STANDARD HEADER.\n         CLI   NOTITOP+1,1         Displaying titles?\n         BE    NOSTDASH            No. Skip dashes to be more readable\n         MVC   LINE,LINE-1\n         MVC   LINE(65),DASHES\n         APUT  LINE,65\nNOSTDASH DS    0H                  Display 'non-std header' message.\n         MVC   LINE,LINE-1\n         MVC   LINE(MSG001L),MSG001\n         APUT  LINE,MSG001L\n         LA    R15,4               SET CC = 4.\n         ST    R15,SAVER15A        SAVE THE RETURN CODE\n         B     EXIT                EXIT.\nLOADA7   DS    0H\nLOAD3    DS    0H\n*        B     LOAD5         TEST TEST TEST\n*        SR    R8,R8               CLEAR INSERT REGISTER AND ...\n*        ICM   R8,B'0001',3(R9)    ... LOAD HEADER LENGTH.\n*        BZ    LOAD4               B IF BYTE LENGTH IS ZERO.\nLOAD5    DS    0H\n* --->\n         MVC   WORKHALF(2),2(R9)   PUT FULL Fhhh VALUE IN WORKAREA\n         NI    WORKHALF,X'0F'      GET RID OF REGISTER, LEAVING NUMBER\nLOAD5A   DS    0H\n*\n*        MVC   LINE,LINE-1\n*        HEX   LINE,2,WORKHALF\n*        APUT  LINE,10\n*\n         L     R8,WORKFULL         LOAD R8 BACK WITH NUMBER\n         TM    FLAG3,X'01'\n         BZ    BRANCHA7\n         LA    R8,6(,R8)           KLUDGE\nBRANCHA7 DS    0H\n         SR    R8,R6               SPACE TAKEN BY LEADING NULL BRANCHES\n         C     R8,=F'200'          BIGGER THAN 200?\n         BNH   LOADHALF            NO, JUST LOAD NUMBER ITSELF\n         L     R8,=F'200'          YES, LOAD 200 TO LIMIT SIZE TO MOVE\nLOADHALF DS    0H\n         ST    R8,SAVER8A\n*        MVC   LINE,LINE-1\n*        HEX   LINE,4,SAVER8A\n*        APUT  LINE,10\n* --->\nHEADOUT  DS    0H                  Now display the load module header.\n         L     R8,SAVER8A\n         S     R8,=F'5'\n         BNP   EXIT0\n         STC   R8,MOVEIC\n         CLI   NOTITOP+1,1         If we don't display titles,\n         BE    NOTIT3              Then skip this title for the header.\n         MVC   LINE,LINE-1\n         MVC   LINE(65),DASHES\n         APUT  LINE,65\n         MVC   LINE,LINE-1\n         CLI   ENTRYOP+1,1  Differentiate between load pt and entry pt\n         BNE   LOADPT01\n         MVC   LINE(36),=C'Load Module Header at Entry Point:  '\n         B     LOADPT02\nLOADPT01 DS    0H\n         MVC   LINE(36),=C'Load Module Header at Load Point:   '\nLOADPT02 DS    0H\n         APUT  LINE,40\nNOTIT3   DS    0H                  Now display the header itself.\n         MVC   LINE,LINE-1\n         EX    R8,MVHEAD           MOVE HEADER TO LINE.\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,200            Put the data out.\n         LM    R14,R1,SAVE14T1\n         LA    R15,0\n         ST    R15,SAVER15A        SAVE THE RETURN CODE\n         B     EXIT0               EXIT WITH CC = 0.\nEXIT12   LA    R15,12\n         ST    R15,SAVER15A        SAVE THE RETURN CODE\n         B     EXIT\nEXIT0    SR    R15,R15             SET CC = 0.\n         ST    R15,SAVER15A        SAVE THE RETURN CODE\nEXIT     DS    0H\n         TM    FLAG2,X'01'\n         BO    WASLPA\n         DELETE EP=MEMBER\nWASLPA   DS    0H\n         L     R13,SAVE+4          POINT TO CALLER'S SAVE AREA.\n         L     R15,SAVER15A        GET THE RETURN CODE\n         ST    R15,16(,R13)\n         LM    R0,R12,20(R13)      RELOAD MOST OF CALLER'S REGISTERS.\n         L     R14,12(,R13)        RELOAD RETURN ADDRESS.\n         BR    R14                 RETURN TO CALLER.\n* ------------------------------------------------------------------- *\n*                          HEX DISPLAY                                *\n* ------------------------------------------------------------------- *\nPRTXLINE DS    0H                Print 3 lines in ISPF HEX format\n         ST    R7,SAVER7A            Plus a fourth ruler line.\n         MVC   LINE,LINE-1\n         L     R1,SAVER1A\n         B     *+10\n         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE\n         EX    R1,*-6\n         L     R1,SAVER1A          RELOAD THE LENGTH\n         B     *+10\nTRHEXL0  TR    LINE(*-*),TRTBL0    MAKE A PRINTABLE LINE\n         EX    R1,TRHEXL0\n         APUT  LINE,100\n         MVC   LINE,LINE-1\n         L     R1,SAVER1A          RELOAD THE LENGTH\n         B     *+10\n         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE\n         EX    R1,*-6\n         B     *+10\nTRHEXL1  TR    LINE(*-*),TRTBL1    HIGH NIBBLE IN HEX DISPLAY\n         EX    R1,TRHEXL1\n         APUT  LINE,100\n         MVC   LINE,LINE-1         RELOAD THE LENGTH\n         L     R1,SAVER1A\n         B     *+10\n         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE\n         EX    R1,*-6\n         B     *+10\nTRHEXL2  TR    LINE(*-*),TRTBL2    LOW NIBBLE IN HEX DISPLAY\n         EX    R1,TRHEXL2\n         APUT  LINE,100\n         MVC   LINE,LINE-1\n         L     R1,SAVER1A          RELOAD LENGTH\n*                                  APUT DESTROYS R1.\n         B     *+10\n         MVC   LINE(0),RULERL      MOVE DATA TO PRINT LINE\n         EX    R1,*-6\n         APUT  LINE,100\n         L     R7,SAVER7A\n         BR    R7\n* ------------------------------------------------------------------- *\nHELPMSG  DS    0H\n         STM   R14,R1,SAVE14T1\n         MVC   LINE,LINE-1\n         MVC   LINE(37),=C'-------------------------------------'\n         APUT  LINE,37\n         MVC   LINE,LINE-1\n         MVC   LINE(37),=C'Syntax: LISTHEAD modname (parameters)'\n         APUT  LINE,37\n         MVC   LINE,LINE-1\n         MVC   LINE(10),BLANKS\n         APUT  LINE,10\n         MVC   LINE,LINE-1\n         MVC   LINE(37),=C'Parameters:  ENTRY, NOTITLE, NOHEX   '\n         APUT  LINE,37\n         MVC   LINE,LINE-1\n         MVC   LINE(37),=C'-------------------------------------'\n         APUT  LINE,37\n         LM    R14,R1,SAVE14T1\n         LA    R15,4               Make return code 4.\n         B     EXIT\n* ------------------------------------------------------------------- *\n         TITLE '- Static data area.'\nSAVE     DS    9D                  SAVE AREA.\nCVDWORK  DS    D                   CVD work area\nLADRSAVE DS    D\nLOADLEN  DS    F                                             *JUL-2014*\nLPAREGS  DS    2F\nLOADWHOL DS    F                   Entire size of load module\nLOADSMAL DS    F                   Distance from entry point to end.\nSTORDIFF DS    F                   Displacement of entry point.\nENTRYOP  DS    F                                             *JUL-2014*\nNOHEXOP  DS    F                                             *DEC-2016*\nNOTITOP  DS    F                                             *DEC-2016*\nHEXOP    DS    F                                             *DEC-2016*\nTITOP    DS    F                                             *DEC-2016*\nSAVE14T1 DS    4F\nADRENTRY DS    F\nADRSTART DS    F\nLPDEADDR DS    F\nCDEADDR  DS    F\nSAVPARCD DS    F\nSAVER1A  DS    F\nSAVER1B  DS    F\nSAVER1L  DS    F                   HOLDS DECREMENTED LENGTH OF MODULE\nSAVER1P  DS    F                   HOLDS LENGTH OF PRINTED LINE - 1\nSAVER3A  DS    F\nSAVER3B  DS    F\nSAVER3C  DS    F\nSAVER6A  DS    F\nSAVER7A  DS    F\nSAVER8A  DS    F\nSAVER9A  DS    F\nSAVER9B  DS    F\nSAVER9C  DS    F\nSAVER9D  DS    F\nSAVER9E  DS    F\nSAVER10A DS    F\nSAVER15A DS    F\nDISPR8A  DS    F\nWORK08   DS    CL8\nMAJNAME  DS    CL8\nFLAG1    DS    X                   X'01' if entry point at beginning\nFLAG2    DS    X                   X'01' if LPA module\nFLAG3    DS    X                   X'01' if need to kludge header size\nMASK10   DC    XL10'40202020202020202120'\nWORKINST DS    2F                   COPY OF INSTRUCTION\nMOVEIC   DC    X'00'\nDASHES   DS    0CL65\nDASHEZ   DC    65C'-'\n         DS    CL1\nBLANKS   DS    CL65' '\nFULLZERO DC    F'0'\n         SPACE 1\n*IOPL     DS    0A                  IOPL FOR PUTLINE.\n*IOPLUPT  DS    A                   POINTER TO USER PROFILE TABLE.\n*IOPLECT  DS    A                   POINTER TO ENVIRONMENT CONTROL TAB.\n*IOPLECB  DC    A(ECB)              POINTER TO ECB.\n*IOPLIOPB DC    A(PTPB)             POINTER TO PTPB.\n         SPACE 1\n         SPACE 1\n*PTPB     PUTLINE MF=L PUTLINE PARM. BLOCK.\n         SPACE 1\nMVMEM    MVC   MEMBER(*-*),0(R15)  *** EXECUTED ***\nMVHEAD   MVC   LINE(*-*),4(R9)     *** EXECUTED ***\nRULERL   DC    C'0----+----1----+----2----+----3----+----4----+----5---x\n               -+----6----+----7----+----8----+----9----+----'\n         DS    CL1\nLINE     DS    CL200\n         SPACE 1\n         LTORG\nWORKFULL DS    0F\n         DC    H'0'\nWORKHALF DC    H'0'\n         TITLE '- MESSAGES.'\nMSG001   DC    C'Load module has non-standard header.'\nMSG001L  EQU   *-MSG001\n         SPACE 1\nMSG002   DC    C'Cannot load '\nMEMBER   DC    CL8' '              NAME OF MEMBER TO BE EXAMINED.\n         DC    C' from any library in normal search path.'\nMSG002L  EQU   *-MSG002\nMSG003   DC    C'Beginning of CDE chain reached without a name match.'\nMSG003L  EQU   *-MSG003\n         TITLE '- Parse parameters.'\nPPL      DS    0A                  PARSE PARM LIST.\nPPLUPT   DS    A                   POINT TO UPT.\nPPLECT   DS    A                   POINT TO ECT.\nPPLECB   DC    A(ECB)              POINT TO ECB.\nPPLPCL   DC    A(PCL)              POINT TO PCL.\nPPLANS   DC    A(ANS)              POINT TO ANSWER PLACE.\nPPLCBUF  DS    A                   POINT TO COMMAND BUFFER.\nPPLWA    DC    A(0)                NO WORK AREA.\n         SPACE 1\nANS      DS    A                   ANSWER PLACE.\nECB      DC    A(0)                COMMAND PROCESSOR ECB.\nPCL      IKJPARM DSECT=PDL         PARSE PCL CSECT.\nPDLLM    IKJIDENT 'Load Module',FIRST=ALPHA,OTHER=ALPHANUM,            +\n               PROMPT='Load Module+',MAXLNTH=8,                        +\n               HELP=('Name of load module to be listed.')\nENTRYKW  IKJKEYWD ,\n         IKJNAME 'ENTRY'\nNOHEXKW  IKJKEYWD ,\n         IKJNAME 'NOHEX'\nNOTITKW  IKJKEYWD ,\n         IKJNAME 'NOTITLE'\nHEXKW    IKJKEYWD ,\n         IKJNAME 'HEX  '\nTITKW    IKJKEYWD ,\n         IKJNAME 'TITLE'\n         IKJENDP\nHEX      DS    0H\n         ST    R4,SAVER4A\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         L     R4,SAVER4A\n         BR    R4                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\nSAVER4A  DS    F\nHEXSAVE  DS    3F                    Register save for HEX macro\n         DS    CL1\nTRTBL0   DS    0D\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'404040404040404040404A4B4C4D4E4F'\n         DC    XL16'504040404040404040405A5B5C5D5E5F'\n         DC    XL16'606140404040404040406A6B6C6D6E6F'\n         DC    XL16'404040404040404040407A7B7C7D7E7F'\n         DC    XL16'40818283848586878889404040404040'\n         DC    XL16'40919293949596979899404040404040'\n         DC    XL16'4040A2A3A4A5A6A7A8A9404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'C0C1C2C3C4C5C6C7C8C9404040404040'\n         DC    XL16'D0D1D2D3D4D5D6D7D8D9404040404040'\n         DC    XL16'E040E2E3E4E5E6E7E8E9404040404040'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9404040404040'\nTRTBL1   DS    0D\n         DC    XL16'F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0'\n         DC    XL16'F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1'\n         DC    XL16'F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2'\n         DC    XL16'F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3'\n         DC    XL16'F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4'\n         DC    XL16'F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5'\n         DC    XL16'F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6'\n         DC    XL16'F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7'\n         DC    XL16'F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8'\n         DC    XL16'F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9'\n         DC    XL16'C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1'\n         DC    XL16'C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2'\n         DC    XL16'C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3'\n         DC    XL16'C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4'\n         DC    XL16'C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5'\n         DC    XL16'C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6'\nTRTBL2   DS    0D\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         TITLE '- Mapping DSECTs.'\n         PRINT GEN\n         IKJCPPL                   MAP COMMAND PROCESSOR PARM LIST.\n         CVT   DSECT=YES\n         IKJTCB                                              *JUL-2014*\n         IHACDE                                              *JUL-2014*\n         IHAXTLST                                            *JUL-2014*\n         END   LISTHEAD\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*  CLEANED A BIT  . . . 08/17\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATER  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUMENTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFORE R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   255                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nR3       EQU   3                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         EJECT\n         IHAPSA   LIST=YES                                     HD APR88\n         EJECT                                                 HD APR88\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\n         DS    0D\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   R14,R12,12(R13)    SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES,SP=0       RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    R1,8(,R13)         OUR SAVE AREA POINTER\n         ST    R13,4(,R1)         POINTER TO CALLER'S SAVE AREA\n         LR    R13,R1             @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(,R13)        POINT TO CALLER'S RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 RC IF BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 RC IF BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(,RML)              MESSAGE LENGTH\n         STH   R15,PUTLEN               PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(,R2)       @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(,R2)               REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    R2,R13                   @OUR SAVE AREA\n         LR    R3,R15                   SAVE RETURN CODE\n         L     R13,4(,R13)              @CALLER'S SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,R3                   RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLER'S REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END   EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTHE01": {"ttr": 4611, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00 \\x01\\x01\\x11_\\x01\\x10\\x13/\\x11T\\x00\\xdb\\x00\\xb1\\x00\\x00\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2001-04-25T00:00:00", "modifydate": "2010-05-12T11:54:20", "lines": 219, "newlines": 177, "modlines": 0, "user": "BROIDO"}, "text": "LISTHEAD TITLE '- TSO command to list load module eye-catchers.'\n         SPACE 1\nLISTHEAD AMODE 31\nLISTHEAD RMODE ANY\nLISTHEAD CSECT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        LISTHEAD - TSO command to list the eye-catcher, if any, in   *\n*              the entry point CSECT of a load module in the normal   *\n*              search path.                                           *\n*                                                                     *\n*              Modified to list more non-standard eye catchers. (SG)  *\n*                                                                     *\n*        Register usage:                                              *\n*              R5 - WORK.                                             *\n*              R6 - Work.                                             *\n*              R7 - Work.                                             *\n*              R8 - Work.                                             *\n*              R9 - Work, Parse PDEs.                                 *\n*             R10 - CPPL pointer.                                     *\n*             R12 - Base.                                             *\n*                                                                     *\n*                                  Jeffrey R. Broido                  *\n*                                  25 April 2001                      *\n*                                                                     *\n*                                  Modified by S.Golob  -  4/10       *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         YREGS\n         USING LISTHEAD,R15        (ESTABLISH TEMPORARY BASE).\n         B     BEGIN               SKIP OVER HEADER.\nHEAD0    DC    AL1(HEADL)          EXCLUSIVE LENGTH OF HEADER.\nHEAD     DC    C'LISTHEAD - &SYSDATE - &SYSTIME  '\nHEADL    EQU   *-HEAD\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         LR    R12,R15             COPY BASE.\n         USING LISTHEAD,R12        (TELL ASSEMBLER).\n         LR    R14,R13             COPY CALLER'S SAVE AREA POINTER.\n         LA    R13,SAVE            POINT TO MY SAVE AREA.\n         ST    R14,SAVE+4          CHAIN ...\n         ST    R13,8(,R14)         ... SAVE AREAS.\n         SPACE 1\n         LR    R10,R1              PRESERVE CPPL POINTER.\n         USING CPPL,R10            (TELL ASSEMBLER)\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        INITIALIZE THE IOPL FOR PUTLINE.                             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         MVC   IOPLUPT,CPPLUPT     COPY UPT ADDRESS.\n         MVC   IOPLECT,CPPLECT     COPY ECT ADDRESS.\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        Initialize the Parse Parameter List and call TSO Parse.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         MVC   PPLUPT,CPPLUPT      COPY UPT ADDRESS.\n         MVC   PPLECT,CPPLECT      COPY ECT ADDRESS.\n         MVC   PPLCBUF,CPPLCBUF    COPY COMMAND BUFFER ADDRESS.\n         SPACE 1\n         LA    R1,PPL              POINT TO THE PPL.\n         XC    ECB,ECB             CLEAR ECB.\n         CALLTSSR EP=IKJPARS       PARSE INPUT.\n         L     R9,ANS              POINT TO PDES.\n         USING PDL,R9              TELL ASSEMBLER.\n         LH    R1,PDLLM+4          LOAD LENGTH OF LOAD MODULE NAME.\n         BCTR  R1,*-*              DECREMENT LENGTH.\n         L     R15,PDLLM           POINT TO RETURNED MEMBER NAME.\n         EX    R1,MVMEM            COPY MEMBER NAME FROM PDL\n*      ( MVC   MEMBER(*-*),0(R15)  )\nFREEPDES IKJRLSA ANS               FREE THE PDES.\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        Fetch the user-specified load module.                        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nLOAD0    LOAD  EPLOC=MEMBER,ERRET=LOAD1  FETCH LOAD MODULE TO LIST.\nLOAD1    LTR   R15,R15             WAS LOAD SUCCESSFUL?\n         BZ    LOAD2               B IF YES; CONTINUE.\n         XC    ECB,ECB             CLEAR ECB.\n         PUTLINE OUTPUT=(MSG002,,DATA),MF=(E,IOPL)\n*              SAY: CANNOT LOAD MEMBER.\n         LA    R15,8               SET CC = 8.\n         B     EXIT                EXIT.\nLOAD2    LR    R9,R0               POINT TO LOAD MODULE TO BE LISTED.\n         CLC   =X'47F0',0(R9)      POSSIBLY STANDARD HEADER?\n         BE    LOAD3               B IF YES; CONTINUE.\n         CLC   =X'05F047F0',0(R9)  POSSIBLY STANDARD HEADER?\n         BNE   NONSTD              B IF NOT.  ERROR.\n         LA    R9,2(,R9)           BUMP LOAD MODULE ORIGIN.\n         B     LOAD3               CONTINUE.\nNONSTD   XC    ECB,ECB             CLEAR ECB.\n         PUTLINE OUTPUT=(MSG001,,DATA),MF=(E,IOPL)\n*              SAY: LOAD MODULE HAS NON-STANDARD HEADER.\n         LA    R15,4               SET CC = 4.\n         B     EXIT                EXIT.\nLOAD3    SR    R8,R8               CLEAR INSERT REGISTER AND ...\n         ICM   R8,B'0001',4(R9)    ... LOAD HEADER LENGTH.\n         BZ    LOAD4               B IF BYTE LENGTH IS ZERO.\n         LA    R7,5(,R9)           POINT TO HEADER.\nLOAD5    LR    R6,R8               COPY LENGTH.\n         BCTR  R8,*-*              DECREMENT LENGTH.\n         EX    R8,TRT              CHECK FOR PRINTABLE CHARACTERS.\n*      ( TRT   0(*-*,R7),TRTAB     )\n         BZ    HEADOUT             CONTINUE IF ALL PRINTABLE.\n         SR    R8,R8               CLEAR INSERT REGISTER AND ...\n         IC    R8,3(,R9)           ... LOAD DISP. TO FIRST SIG. INST.\n         LA    R7,4(,R9)           POINT TO FIRST CHAR. AFTER BRANCH.\n         SH    R8,=H'5'            DECREMENT LENGTH.\n         LA    R6,1(,R8)           INCREMENT LENGTH.\n         EX    R8,TRT              CHECK FOR PRINTABLE CHARACTERS.\n*      ( TRT   0(*-*,R7),TRTAB     )\n*        BNZ   NONSTD              B IF ANY NON-PRINTABLE CHARS.\nHEADOUT  LA    R6,4(,R6)           BUMP LENGTH FOR RDW-OID.\n         STORAGE OBTAIN,LENGTH=(R6) GET PUTLINE BUFFER.\n         LR    R5,R1               PRESERVE ADDRESS POINTER.\n         STH   R6,0(,R5)           SAVE LENGTH FOR PUTLINE.\n         XC    2(2,R5),2(R5)       ZERO OFFSET FOR PUTLINE.\n         EX    R8,MVHEAD           MOVE HEADER TO PUTLINE BUFFER.\n*      ( MVC   4(*-*,R5),0(R7)     )\n         XC    ECB,ECB             CLEAR ECB.\n         PUTLINE OUTPUT=((R5),,DATA),MF=(E,IOPL) OUTPUT HEADER.\n         STORAGE RELEASE,LENGTH=(R6),ADDR=(R5) FREE PUTLINE BUFFER.\n         B     EXIT0               EXIT WITH CC = 0.\nLOAD4    LH    R8,4(,R9)           LOAD HALFWORD LENGTH.\n         LA    R7,6(,R9)           POINT TO HEADER.\n         B     LOAD5               CONTINUE.\nEXIT0    SR    R15,R15             SET CC = 0.\nEXIT     L     R13,SAVE+4          POINT TO CALLER'S SAVE AREA.\n         LM    R0,R12,20(R13)      RELOAD MOST OF CALLER'S REGISTERS.\n         L     R14,12(,R13)        RELOAD RETURN ADDRESS.\n         BR    R14                 RETURN TO CALLER.\n         TITLE '- Static data area.'\nSAVE     DS    9D                  SAVE AREA.\n         SPACE 1\nIOPL     DS    0A                  IOPL FOR PUTLINE.\nIOPLUPT  DS    A                   POINTER TO USER PROFILE TABLE.\nIOPLECT  DS    A                   POINTER TO ENVIRONMENT CONTROL TAB.\nIOPLECB  DC    A(ECB)              POINTER TO ECB.\nIOPLIOPB DC    A(PTPB)             POINTER TO PTPB.\n         SPACE 1\n         SPACE 1\nPTPB     PUTLINE MF=L PUTLINE PARM. BLOCK.\n         SPACE 1\nMVMEM    MVC   MEMBER(*-*),0(R15)  *** EXECUTED ***\nMVHEAD   MVC   4(*-*,R5),0(R7)     *** EXECUTED ***\nTRT      TRT   0(*-*,R7),TRTAB     *** EXECUTED ***\n         SPACE 1\nTRTAB    DC    256X'01'            TRT TABLE TO DETECT ...\n         ORG   TRTAB+C'a'          ... NON-DISPLAY CHARACTERS.\n         DC    9X'00'\n         ORG   TRTAB+C'j'\n         DC    9X'00'\n         ORG   TRTAB+C's'\n         DC    8X'00'\n         ORG   TRTAB+C'A'\n         DC    9X'00'\n         ORG   TRTAB+C'J'\n         DC    9X'00'\n         ORG   TRTAB+C'S'\n         DC    8X'00'\n         ORG   TRTAB+C'0'\n         DC    10X'00'\n         ORG   TRTAB+X'4A'\n         DC    7X'00'\n         ORG   TRTAB+C'!'\n         DC    8X'00'\n         ORG   TRTAB+X'6A'\n         DC    6X'00'\n         ORG   TRTAB+C':'\n         DC    6X'00'\n         ORG   TRTAB+X'AF'\n         DC    18X'00'\n         ORG   TRTAB+C'\\'\n         DC    2X'00'\n         ORG   TRTAB+C' '\n         DC    X'00'\n         ORG   ,\n         SPACE 1\n         LTORG\n         TITLE '- MESSAGES.'\nMSG001   DC    AL2(MSG001L,0),C'Load module has non-standard header.'\nMSG001L  EQU   *-MSG001\n         space 1\nMSG002   DC    AL2(MSG002L,0),C'Cannot load '\nMEMBER   DC    CL8' '              NAME OF MEMBER TO BE EXAMINED.\n         DC    C' from any library in normal search path.'\nMSG002L  EQU   *-MSG002\n         TITLE '- Parse parameters.'\nPPL      DS    0A                  PARSE PARM LIST.\nPPLUPT   DS    A                   POINT TO UPT.\nPPLECT   DS    A                   POINT TO ECT.\nPPLECB   DC    A(ECB)              POINT TO ECB.\nPPLPCL   DC    A(PCL)              POINT TO PCL.\nPPLANS   DC    A(ANS)              POINT TO ANSWER PLACE.\nPPLCBUF  DS    A                   POINT TO COMMAND BUFFER.\nPPLWA    DC    A(0)                NO WORK AREA.\n         SPACE 1\nANS      DS    A                   ANSWER PLACE.\nECB      DC    A(0)                COMMAND PROCESSOR ECB.\nPCL      IKJPARM DSECT=PDL         PARSE PCL CSECT.\nPDLLM    IKJIDENT 'Load Module',FIRST=ALPHA,OTHER=ALPHANUM,            +\n               PROMPT='Load Module+',MAXLNTH=8,                        +\n               HELP=('Name of load module to be listed.')\n         IKJENDP\n         TITLE '- Mapping DSECTs.'\n         PRINT NOGEN\n         IKJCPPL                   MAP COMMAND PROCESSOR PARM LIST.\n         CVT   DSECT=YES\n         END   LISTHEAD\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTMOD": {"ttr": 4616, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00W\\x01\\x14 \\x1f\\x01 \\x03O\\x08\\x15\\x04^\\x02\\xcc\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2014-07-20T00:00:00", "modifydate": "2020-02-03T08:15:57", "lines": 1118, "newlines": 716, "modlines": 0, "user": "SBGOLOB"}, "text": "LISTMOD  TITLE '- TSO command to list load module in hex format'\n         SPACE 1\n* ------------------------------------------------------------------- *\n***********************************************************************\n*                                                                     *\n*     LISTMOD - TSO command to list an entire module in ISPF-like     *\n*               hexadecimal format.  Width of the display is 75       *\n*               bytes wide.                                           *\n*                                                                     *\n*               Displacements of data are marked in hexadecimal.      *\n*                                                                     *\n*               Using the ENTRY parameter, the display goes from      *\n*               the entry point until the physical end of the module. *\n*               Otherwise, the display includes the entire module     *\n*               from beginning to end.                                *\n*                                                                     *\n*     Register usage:                                                 *\n*           R5 - Base.                                                *\n*           R6 - Work.                                                *\n*           R7 - Work.                                                *\n*           R8 - Work.                                                *\n*           R9 - Work, Parse PDEs.                                    *\n*          R10 - CPPL pointer.                                        *\n*          R12 - Base.                                                *\n*                                                                     *\n*     Ideas in the program were developed by Jeffrey Broido and       *\n*     Bill Godfrey.  The program was adapted for dumping load         *\n*     modules, by Sam Golob.                                          *\n*                                                                     *\n*     Partial description of the program:  Display the bytes of       *\n*     a load module in ISPF-like 3-line hexadecimal format, with      *\n*     ruler to help measure and locate particular bytes.              *\n*                                                                     *\n*     The program works (currently) by first testing if the module    *\n*     is in the Link Pack Area (LPA).  If so, then the LPDE is        *\n*     looked up, to obtain the relevant information.  If the program  *\n*     is not in LPA, then a LOAD macro is issued to obtain the        *\n*     information.                                                    *\n*                                                                     *\n*     The program either displays the entire load module, or,         *\n*     using the ENTRY parameter, it starts with the entry point,      *\n*     and it dumps the contents of the rest of the load module,       *\n*     in 3-line hex format with ruler, to see what is there.          *\n*                                                                     *\n*     All the bytes of the program are displayed, if there is no      *\n*     parameter.  If the ENTRY parameter is used, then all the        *\n*     bytes from the entry point to the end of the module, are        *\n*     displayed.                                                      *\n*                                                                     *\n*              example:    LISTMOD modname ENTRY                      *\n*                                                                     *\n*     Please note that the HEX display will show all hex values       *\n*     in \"printable\" format, so you don't need any other tools        *\n*     to see the contents of the load modules, displayed in a         *\n*     3-line hexadecimal display with added ruler.                    *\n*                                                                     *\n*     For some modules, such as IEBCOPY, you have to use the          *\n*     ENTRY parameter to see a realistic eyecatcher.  But since       *\n*     (with IEBCOPY and with many other load modules) the entry       *\n*     point is in the middle of the load module, LISTMOD will         *\n*     then (using the ENTRY keyword) only list the bytes from         *\n*     the entry point location until the end of the module.           *\n*                                                                     *\n*     CHANGES:  2020/02/03 - SBG                                      *\n*               Changed ruler to go from X'00' to X'3F'.              *\n*               It had been one byte off.                             *\n*                                                                     *\n***********************************************************************\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\n*      PRODUCE A \"DISPLAY REPRESENTATION\" OF HEXADECIMAL NUMBERS      *\n* ------------------------------------------------------------------- *\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         STM   R15,R1,HEXSAVE\n         LA    R1,&FROM\n         LA    R0,&LEN\n         LA    R15,&TO\n         BAL   R4,HEX\n         LM    R15,R1,HEXSAVE\n         MEND\n* ------------------------------------------------------------------- *\n*                   BEGINNING OF THE PROGRAM                          *\n* ------------------------------------------------------------------- *\nLISTMOD AMODE 31\nLISTMOD RMODE ANY\nLISTMOD CSECT\n         SPACE 1\n         SPACE 1\n         YREGS\n         USING LISTMOD,R15         (ESTABLISH TEMPORARY BASE).\n         B     BEGIN               SKIP OVER HEADER.\nHEAD0    DC    AL1(HEADL)          EXCLUSIVE LENGTH OF HEADER.\nHEAD     DC    C'LISTMOD - &SYSDATE - &SYSTIME  '\nHEADL    EQU   *-HEAD\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         LR    R12,R15             COPY BASE.\n         USING LISTMOD,R12,R5      SET UP BASE REGISTERS.\n         LA    R5,4095(,R12)\n         LA    R5,1(,R5)\n         LR    R14,R13             COPY CALLER'S SAVE AREA POINTER.\n         LA    R13,SAVE            POINT TO MY SAVE AREA.\n         ST    R14,SAVE+4          CHAIN ...\n         ST    R13,8(,R14)         ... SAVE AREAS.\n         SPACE 1\n         MVI   LINE-1,X'40'\n         MVC   LINE,LINE-1\n         MVI   BLANKS-1,X'40'      FILL THE BLANKS FIELD\n         MVC   BLANKS,BLANKS-1       WITH BLANKS\n         MVC   MEMBER,BLANKS       Initialize member name with blanks.\n         LR    R10,R1              PRESERVE CPPL POINTER.\n         MVC   MAJNAME,BLANKS\n         USING CPPL,R10            (TELL ASSEMBLER)\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        Initialize the Parse Parameter List and call TSO Parse.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         MVC   PPLUPT,CPPLUPT      COPY UPT ADDRESS.\n         MVC   PPLECT,CPPLECT      COPY ECT ADDRESS.\n         MVC   PPLCBUF,CPPLCBUF    COPY COMMAND BUFFER ADDRESS.\n         SPACE 1\n         LA    R1,PPL              POINT TO THE PPL.\n         XC    ECB,ECB             CLEAR ECB.\n         CALLTSSR EP=IKJPARS       PARSE INPUT.\n         LTR   R15,R15             Check return code from IKJPARS\n         BNZ   HELPMSG             Not zero, Help message and end.\n         L     R9,ANS              POINT TO PDES.\n         USING PDL,R9              TELL ASSEMBLER.\n         LH    R1,PDLLM+4          LOAD LENGTH OF LOAD MODULE NAME.\n         BCTR  R1,*-*              DECREMENT LENGTH.\n         L     R15,PDLLM           POINT TO RETURNED MEMBER NAME.\n         EX    R1,MVMEM            COPY MEMBER NAME FROM PDL\n*      ( MVC   MEMBER(*-*),0(R15)  )\n         MVC   ENTRYOP,ENTRYKW\n         MVC   NOHEXOP,NOHEXKW                               *DEC-2016*\n         MVC   HEXOP,HEXKW\n*        MVC   NOTITOP,NOTITKW                               *DEC-2016*\n         MVI   FLAG1,X'00'             Initialize flag.\n         MVC   STORDIFF,=X'00000000'   Assume the entry point at 0.\nFREEPDES IKJRLSA ANS               FREE THE PDES.\n*        CLI   NOTITOP+1,0                                   *DEC-2016*\n*        BNE   NOTIT2                                        *DEC-2016*\n         MVC   LINE,LINE-1\n         MVC   LINE(22),=C'Loaded Program Name:  '\n         MVC   LINE+22(8),MEMBER\n         APUT  LINE,40\nNOTIT1   DS    0H                                            *DEC-2016*\n*        CLI   NOHEXOP+1,0         IF NOHEX KEYWORD          *DEC-2016*\n*        BNE   LPA0\n         MVC   LINE,LINE-1\n         MVC   LINE(65),DASHES\n         APUT  LINE,65\nNOTIT2   DS    0H                                            *DEC-2016*\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              FETCH THE USER-SPECIFIED LOAD MODULE.                  *\n*                                                                     *\n***********************************************************************\n* ------------------------------------------------------------------- *\n*    LOGIC OF THE PROGRAM WAS CHANGED TO DO A STANDARD \"LOAD\" FOR     *\n*    THE MODULE REQUESTED, BUT TO AFTERWARDS, ALSO CALCULATE THE      *\n*    MODULE ENTRY POINT IN THE DIFFERENT WAYS POSSIBLE, AND TO SAVE   *\n*    ALL THE RESULTS.  AFTERWARDS, DEPENDING ON WHETHER THE \"ENTRY\"   *\n*    PARAMETER WAS CODED, THE RESULTS ARE DISPLAYED ACCORDINGLY.      *\n* ------------------------------------------------------------------- *\n*    We first ask if the module is from LPA, and if not, then we      *\n*    LOAD it.                                                         *\n* ------------------------------------------------------------------- *\nLPA0     DS    0H\n         LM    R0,R1,MEMBER       Load member name for IEAVVMSR\n         STM   R7,R8,LPAREGS      Save registers\n         L     R3,16              CVT\n         L     R15,352(,R3)       CVTLPDSR\n         BALR  R14,R15            CALL IEAVVMSR\n         B     LPAINFO            MODULE IS IN LPA, GET LPDE.\n         B     LOAD0              NOT IN LPA, TRY LOADING IT.\nLPAINFO  DS    0H\n         OI    FLAG2,X'01'        FLAG THE MODULE AS AN LPA MODULE.\n         LM    R7,R8,LPAREGS      RESTORE REGISTERS\n         LR    R6,R0              SAVE LPDE ADDRESS\n         ST    R6,LPDEADDR        And store it for reporting\n         L     R9,16(,R6)         GET ENTRY POINT ADDRESS\n         N     R9,=X'7FFFFFFF'    Get rid of high bit.\n         ST    R9,SAVER9B         SAVE MODULE ENTRY POINT\n         TM    X'1C'(R6),X'04'    IS THIS A MINOR LPDE (ALIAS)?\n         BZ    MAJLPDE            NO. PROCESS AS A MAJOR.\n         OI    FLAG2,X'02'        Mark this one as an alias.\n         MVC   MAJNAME(8),X'20'(R6)  Copy the major name for report.\n         L     R6,X'14'(,R6)      YES. GET ADDRESS OF MAJOR LPDE.\nMAJLPDE  DS    0H\n         L     R9,X'24'(,R6)      GET MODULE LOAD POINT.\n         N     R9,=X'7FFFFFFF'    Remove the 31-bit indicator\n         ST    R9,ADRSTART        Start of the full data of the module\n         ST    R9,SAVER9A         Save it in another place\n         ST    R9,SAVER9C         SAVE THE LOAD POINT.\n         L     R9,X'20'(,R6)      GET THE SIZE OF THE LOAD MODULE.\n         ST    R9,LOADLEN         SAVE THE ENTIRE SIZE\n         MVC   LOADWHOL,LOADLEN   COPY WHOLE SIZE\n         L     R2,SAVER9B         GET THE ENTRY POINT\n         L     R3,SAVER9C         SUBTRACT THE LOAD POINT\n         SR    R2,R3              GET THE DISPLACEMENT\n         BNP   ENTRYPM1           GO TO SAME CALC AS WITH LOAD\n         ST    R2,STORDIFF        SAVE THE DISPLACEMENT\n         B     ENTRYPM0           GO TO THE SAME CALC AS WITH LOAD\n* ------------------------------------------------------------------- *\nLOAD0    DS    0H                 NOT IN LPA. LOAD THE MODULE.\n         LM    R7,R8,LPAREGS      RESTORE REGISTERS\n         LOAD  EPLOC=MEMBER,ERRET=LOAD1  FETCH LOAD MODULE TO LIST.\n*    Put in a display of x number of bytes at the load point, here.\nLOAD1    LTR   R15,R15             WAS LOAD SUCCESSFUL?\n         BZ    LOAD2               B IF YES; CONTINUE.\n*              SAY: CANNOT LOAD MEMBER.\n         MVC   LINE,LINE-1\n         MVC   LINE(MSG002L),MSG002\n         APUT  LINE,MSG002L\n         LA    R15,8               SET CC = 8.\n         B     EXIT                EXIT.\nLOAD2    DS    0H\n         LR    R9,R0               POINT TO LOAD MODULE TO BE LISTED.\n         N     R9,=X'7FFFFFFF'     Get rid of high bit for calculations\n         ST    R9,ADRSTART         Start of the full data of the module\n         ST    R9,SAVER9A          Save it in another place\n         ST    R9,SAVER9B          Save it again in another place\n         NC    SAVER9B(4),=A(X'7FFFFFFF')  Maybe not necessary\n         N     R1,=A(X'00FFFFFF')  ISOLATE LENGTH IN DWORDS  *JUL-2014*\n         ST    R3,SAVER3B          Save R3 to restore later\n         LR    R3,R1               Get length in doublewords\n         SLL   R3,3                Convert to bytes (multiply by 8)\n         ST    R3,SAVER3A          Save length in bytes\n         L     R3,SAVER3B          Restore original R3\n         SLL   R1,3                Do the same for R1        *JUL-2014*\n         ST    R1,LOADLEN          And save the max display length\n         MVC   LOADWHOL,LOADLEN    Save it again\n* ------------------------------------------------------------------- *\n* NOTE: IF THE 'ENTRY' KEYWORD IS SPECIFIED, AND THE         *JUL-2014*\n* ENTRY POINT IS NEAR THE END OF THE MODULE, THERE MAY BE    *JUL-2014*\n* FEWER BYTES THAN THE LOADLEN VALUE FROM THE ENTRY POINT    *JUL-2014*\n* TO THE END OF THE MODULE. AS A RESULT, THE DISPLAY OF      *JUL-2014*\n* LOADLEN BYTES MIGHT INCLUDE THE CONTENTS OF MEMORY BEYOND  *JUL-2014*\n* THE END OF THE MODULE.                                     *JUL-2014*\n* IF THE LAST CDE IN JOB PACK AREA QUEUE IS FOR A MODULE     *JUL-2014*\n* THAT CONTAINS THE ENTRY POINT ADDRESS IN R9, USE THE       *JUL-2014*\n* ADDRESS OF THE MODULE INSTEAD OF THE ENTRY POINT.          *JUL-2014*\n* NOTE: COULD ALSO USE LOADPT= ON THE LOAD MACRO, BUT        *JUL-2014*\n* MVS 3.8 SYSTEMS DON'T HAVE LOADPT=.                        *JUL-2014*\n* ------------------------------------------------------------------- *\n*       CALCULATE THE ENTRY POINT ADDRESS OF THE LOAD MODULE          *\n*              THIS CODE IS NOW, ALWAYS EXECUTED.                     *\n* ------------------------------------------------------------------- *\n         N     R9,=A(X'7FFFFFFF')                            *JUL-2014*\n         L     R14,540             PSATOLD -> CURRENT TCB    *JUL-2014*\n         L     R14,TCBJSTCB-TCB(,R14) POINT TO JOB STEP TCB  *JUL-2014*\n         L     R14,TCBJPQ-TCB(,R14) PNT TO LAST CDE IN JPAQ  *JUL-2014*\n* ------------------------------------------------------------------- *\n*              The correct CDE might not be the last one,             *\n*             so chain back until you've got a name match.            *\n* ------------------------------------------------------------------- *\nCDELOOP  DS    0H                  Check if CDE matches member name\n         CLC   MEMBER(8),8(R14)    Is this the correct CDE? (match)\n         BE    CDEEND              Yes, then process it.\n         CLC   FULLZERO,0(R14)     Back at the beginning of the chain\n         BE    CDEBAD                without a match? Then error.\n         L     R14,0(,R14)         No match. Go back one previous CDE.\n         B     CDELOOP             Keep trying till match or first CDE\n*                                    without a match.\nCDEBAD   DS    0H\n         MVC   LINE,LINE-1         Error message if beginning of CDE\n         MVC   LINE(MSG003L),MSG003  was reached without a name match.\n         APUT  LINE,MSG003L\n         B     EXIT12              Code 12 for this one.\nCDEEND   DS    0H\n         ST    R14,CDEADDR         Store address of CDE found.\n         TM    CDATTR-CDENTRY(R14),CDMIN TEST FOR MINOR CDE  *JUL-2014*\n         BZ    MAJCDE              BRANCH IF MAJOR CDE       *JUL-2014*\n         L     R14,CDXLMJP-CDENTRY(,R14) POINT TO MAJOR CDE  *JUL-2014*\n         OI    FLAG2,X'20'        Mark as CDE of an alias.\n         MVC   MAJNAME(8),X'8'(R14)     REAL NAME OF MODULE\nMAJCDE   L     R14,CDXLMJP-CDENTRY(,R14) POINT TO EXTENT     *JUL-2014*\n         L     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*\n         ST    R0,SAVER9C\n         CR    R9,R0                                         *JUL-2014*\n         BL    KEEPR9                                        *JUL-2014*\n         L     R0,XTLMSBLA-XTLST(,R14) LENGTH OF MODULE      *JUL-2014*\n         N     R0,=A(X'7FFFFFFF')                            *JUL-2014*\n         ST    R0,SAVER1B\n         A     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*\n         ST    R0,SAVER9D\n         CR    R9,R0                                         *JUL-2014*\n         BNL   KEEPR9                                        *JUL-2014*\n         L     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*\n         LR    R9,R0                                         *JUL-2014*\n         ST    R9,SAVER9E\n* ------------------------------------------------------------------- *\n*            COME HERE FOR BOTH LPA AND LOADED MODULES                *\n* ------------------------------------------------------------------- *\nENTRYPM  DS    0H                  Check if entry point is displaced.\n         L     R2,SAVER9B          Get entry point of module\n         L     R3,SAVER9C          Get beginning addr of module\n         SR    R2,R3               Calculate difference in length\n         BNP   ENTRYPM1            Number is not reliable\n         ST    R2,STORDIFF         Save the entry point displacement.\nENTRYPM0 DS    0H\n         LTR   R2,R2               Is it zero?\n         BZ    NODIFF              Then do the whole module.\nENTRYPM1 DS    0H\n         L     R1,LOADWHOL         Load length from LOAD macro\n         MVC   SAVER3A,LOADWHOL\n         S     R1,STORDIFF         Subtract offset of entry point\n         ST    R1,LOADSMAL         Preserve reduced load length\n         MVC   SAVER3B,LOADSMAL    Save short length for later\n         B     YESDIFF             Yes, entry point diff from load pt\nKEEPR9   DS    0H\n*\nNODIFF   DS    0H                  Go here if entry pt is load point\n         MVC   LOADSMAL,LOADWHOL   Size is from beginning to end\n         MVC   SAVER3B,LOADSMAL    Save size from entry point to end\n         L     R1,LOADWHOL         Load R1 with size\n         OI    FLAG1,X'01'         Flag load point equal entry point\n         L     R9,ADRSTART         Load R9 with data address\n*\nYESDIFF  DS    0H\n         TM    FLAG1,X'01'         Load point different from entry pt?\n         BZ    ENTRYDIF            No. Skip this section.\n         L     R1,LOADWHOL         Start R1 with whole size.\n         ST    R1,LOADLEN          And store it in LOADLEN.\n         L     R9,ADRSTART         Load R9 with data address\n* ------------------------------------------------------------------- *\nENTRYDIF DS    0H                  Display of Diagnostic Data\n         ST    R9,SAVER9A          SAVE THE PROGRAM DATA\n*        CLI   NOTITOP+1,0\n*        BNE   KEEPR9A\n         TM    FLAG2,X'20'\n         BO    NOTLPA00\n         TM    FLAG2,X'01'\n         BO    MARKLPA\nNOTLPA00 DS    0H\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Module has been LOADED.'\n         MVC   LINE+24(13),=C'CDE Address: '\n         HEX   LINE+37,4,CDEADDR\n         TM    FLAG2,X'20'\n         BZ    MARKCDEA\n         MVC   LINE+47(10),=C'Alias of: '\n         MVC   LINE+57(8),MAJNAME\nMARKCDEA DS    0H\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,75\n         LM    R14,R1,SAVE14T1\n         B     MOREDSPL\nMARKLPA  DS    0H\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Module is from LPA.    '\n         MVC   LINE+21(14),=C'LPDE Address: '\n         HEX   LINE+35,4,LPDEADDR\n         TM    FLAG2,X'02'\n         BZ    MARKLPAA\n         MVC   LINE+46(10),=C'Alias of: '\n         MVC   LINE+56(8),MAJNAME\nMARKLPAA DS    0H\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,65\n         LM    R14,R1,SAVE14T1\nMOREDSPL DS    0H\n         MVC   LINE,LINE-1\n         HEX   LINE+30,4,SAVER3A\n         MVC   LINE(30),=C'Length of loaded module Hex:  '\n         L     R3,SAVER3A\n         CVD   R3,CVDWORK          Convert to Decimal\n         MVC   LINE+42(9),=C'Decimal: '\n         MVC   LINE+52(10),MASK10\n         ED    LINE+52(10),CVDWORK+3\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,75\n         LM    R14,R1,SAVE14T1\n         MVC   LINE,LINE-1\n         HEX   LINE+30,4,LOADSMAL\n         MVC   LINE(30),=C'Length after entry address :  '\n         L     R3,LOADSMAL\n         CVD   R3,CVDWORK          Convert to Decimal\n         MVC   LINE+42(9),=C'Decimal: '\n         MVC   LINE+52(10),MASK10\n         ED    LINE+52(10),CVDWORK+3\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,75\n         LM    R14,R1,SAVE14T1\n         MVC   LINE,LINE-1\n         HEX   LINE+30,4,STORDIFF\n         MVC   LINE(30),=C'Displacement of entry point:  '\n         L     R3,STORDIFF\n         CVD   R3,CVDWORK          Convert to Decimal\n         MVC   LINE+42(9),=C'Decimal: '\n         MVC   LINE+52(10),MASK10\n         ED    LINE+52(10),CVDWORK+3\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,75\n         LM    R14,R1,SAVE14T1\n         MVC   LINE,LINE-1             Test diagnostics display.\n         HEX   LINE,4,SAVER9A\n         HEX   LINE+10,4,SAVER9B\n         HEX   LINE+20,4,SAVER9C\n         HEX   LINE+30,4,SAVER9D\n         HEX   LINE+40,4,SAVER9E\n         HEX   LINE+50,4,LOADSMAL\n         HEX   LINE+60,4,LOADWHOL\n         HEX   LINE+70,4,STORDIFF\n         HEX   LINE+80,4,ADRSTART\n         HEX   LINE+90,4,SAVER1B\n         HEX   LINE+100,1,FLAG1\n*        STM   R14,R1,SAVE14T1\n*        APUT  LINE,105\n*        LM    R14,R1,SAVE14T1\nKEEPR9A  DS    0H\n*\n         CLI   NOHEXOP+1,0                                   *DEC-2016*\n         BNE   JUST1                                         *DEC-2016*\n         MVC   LINE,LINE-1         Print a line of dashes\n         MVC   LINE(65),DASHES\n         APUT  LINE,65\nNODASH1  DS    0H                                            *DEC-2016*\n* ------------------------------------------------------------------- *\n*              PREPARE FOR HEX DISPLAY OF ALL LINES                   *\n* ------------------------------------------------------------------- *\nENTRYPRM DS    0H                  Process the ENTRY keyword here.\n         CLI   ENTRYOP+1,0         Entry keyword not there?\n         BE    BIGMOD              Go treat whole module.\n         L     R9,SAVER9B          Data address at entry point\n         L     R1,LOADSMAL         Load reduced size, e.p. to end.\n         B     SMALLMOD            Don't display the whole module.\nBIGMOD   DS    0H\n         L     R9,SAVER9C          Address of beginning of the data.\n         L     R1,LOADWHOL         Load the full size of the module.\n*              IF THE MODULE SIZE < 64 THEN DON'T SHOW 64\nSMALLMOD DS    0H\n         LR    R10,R1              Save length for calculation\n         ST    R1,SAVER1L          Store it for printing\nLATENTRY DS    0H\n         ST    R10,SAVER10A        Store it for safety\n* ------------------------------------------------------------------- *\n*            Calculate how many lines we will need to print.          *\n* ------------------------------------------------------------------- *\n         SRDA  R10,32(0)           Set up divide\n         D     R10,=F'64'          Divide by 64 decimal\n         LTR   R10,R10             Even division?\n         BZ    NOREMNDR            Yes. Don't compensate for remainder\n         LA    R11,1(,R11)         Add 1 to compensate for remainder\n*                                    and print a partial line.\nNOREMNDR DS    0H\n         XR    R8,R8               Initialize byte counter\n* ------------------------------------------------------------------- *\n*                     Print All The Lines                             *\n* ------------------------------------------------------------------- *\nPRNTLOOP DS    0H\n*   R1 has quantity SAVER1L in it here.\n         C     R1,=F'64'           Less than 64?\n         BNH   *+8                 Yes, skip limit to 64.\n         L     R1,=F'64'           No. Just print 64 at a time\n         BCTR  R1,0                One less for execute.\n         STM   R14,R1,SAVE14T1     Protect registers used by APUT\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1A\n         APUT  LINE,4,SAVER1A\n         LM    R14,R1,SAVE14T1\n*   R1 has quantity SAVER1P in it here.\n         ST    R1,SAVER1P          Save the length - 1\n         STM   R14,R1,SAVE14T1     Protect registers used by PRTXLINE\n         L     R1,SAVER1P          Save the length - 1\n         BAL   R7,PRTXLINE         Print these 64 bytes in hex\n         LM    R14,R1,SAVE14T1\n*   DISPLAY LATER LINES\n         LA    R9,64(,R9)          Skip 64 bytes from current\n         L     R1,SAVER1L          Reload remaining data length\n         S     R1,=F'64'           Subtract 64\n         BNP   JUST1               Finished? Stop the process.\n         ST    R1,SAVER1L          Decremented length\n         BCT   R11,PRNTLOOP\n* ------------------------------------------------------------------- *\n*                      END OF HEX DISPLAY                             *\n* ------------------------------------------------------------------- *\nJUST1    DS    0H                  CHECK FOR INITIAL INSTRUCTIONS\n         CLI   NOHEXOP+1,0\n         BE    NODASH01\n         MVC   LINE,LINE-1\n         MVC   LINE(65),DASHES\n         APUT  LINE,65\nNODASH01 DS    0H\n         TM    FLAG2,X'01'\n         BO    WASLPA\n         DELETE EPLOC=MEMBER\nWASLPA   DS    0H\n*\nEXIT0    SR    R15,R15             SET CC = 0.\n         ST    R15,SAVER15A        SAVE THE RETURN CODE\nEXIT     L     R13,SAVE+4          POINT TO CALLER'S SAVE AREA.\n         LM    R0,R12,20(R13)      RELOAD MOST OF CALLER'S REGISTERS.\n         L     R14,12(,R13)        RELOAD RETURN ADDRESS.\n         BR    R14                 RETURN TO CALLER.\nEXIT12   LA    R15,12\n         ST    R15,SAVER15A        SAVE THE RETURN CODE\n         B     EXIT\n* ------------------------------------------------------------------- *\n*                     HEX DISPLAY SUBROUTINE                          *\n* ------------------------------------------------------------------- *\nPRTXLINE DS    0H                  4-line hex printout routine.\n         ST    R7,SAVER7A\n         ST    R8,SAVER8A\n         CVD   R8,CVDWORK          The line number of bytes so far\n         MVC   LINE,LINE-1\n         L     R1,SAVER1P          Length of line to print\n         B     *+10\n         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE\n         EX    R1,*-6\n         L     R1,SAVER1P          RELOAD THE LENGTH\n         B     *+10\nTRHEXL0  TR    LINE(*-*),TRTBL0    Make the line of printables\n         EX    R1,TRHEXL0\n         HEX   LINE+67,4,SAVER8A       Print counter after 1st line\n         APUT  LINE,80             Print the line of printables\n         MVC   LINE,LINE-1\n         L     R1,SAVER1P          Reload the length of the line\n         B     *+10\n         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE\n         EX    R1,*-6\n         B     *+10\nTRHEXL1  TR    LINE(*-*),TRTBL1    HIGH NIBBLE IN HEX DISPLAY\n         EX    R1,TRHEXL1\n         APUT  LINE,64\n         MVC   LINE,LINE-1\n         L     R1,SAVER1P          Reload the length of the line\n         B     *+10\n         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE\n         EX    R1,*-6\n         B     *+10\nTRHEXL2  TR    LINE(*-*),TRTBL2    LOW NIBBLE IN HEX DISPLAY\n         EX    R1,TRHEXL2\n         APUT  LINE,64\n         MVC   LINE,LINE-1\n         L     R1,SAVER1P          Reload the length of the line\n*                                  since APUT destroys R1.\n         B     *+10\n         MVC   LINE(0),RULERL      Print the ruler line\n         EX    R1,*-6\n         APUT  LINE,64\n         LA    R8,64(,R8)          Increment counter (x 64)\n         L     R7,SAVER7A\n         BR    R7\n* ------------------------------------------------------------------- *\nHELPMSG  DS    0H\n         STM   R14,R1,SAVE14T1\n         APUT  '-------------------------------------------------',49\n         APUT  'Correct usage of LISTMOD is as follows:  ',41\n         APUT  '   ',3\n         APUT  '  LISTMOD modname (optional parameters)  ',41\n         APUT  '   ',3\n         APUT  'Parameters are:  NOHEX and ENTRY      ',39\n         APUT  '   ',3\n         APUT  'Required is the name of the module to load.',43\n         APUT  '   ',3\n         APUT  'Leaving out parameters produces the hex display',47\n         APUT  '  from the beginning of the module.  ENTRY starts',49\n         APUT  '  the display from the entry point of the module.',49\n         APUT  '   ',3\n         APUT  '  NOHEX prints the header information only.      ',49\n         APUT  '-------------------------------------------------',49\n         STM   R14,R1,SAVE14T1\n         B     EXIT\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         TITLE '- Static data area.'\n* ------------------------------------------------------------------- *\nSAVE     DS    9D                  SAVE AREA.\nCVDWORK  DS    D                   CVD work area\nLOADLEN  DS    F\nLPAREGS  DS    2F\nLOADWHOL DS    F                   Entire size of load module\nLOADSMAL DS    F                   Distance from entry point to end.\nSTORDIFF DS    F                   Displacement of entry point.\nENTRYOP  DS    F\nNOHEXOP  DS    F\nNOTITOP  DS    F\nHEXOP    DS    F\nTITOP    DS    F\nSAVE14T1 DS    4F\nADRENTRY DS    F\nADRSTART DS    F\nLPDEADDR DS    F\nCDEADDR  DS    F\nSAVER1A  DS    F\nSAVER1B  DS    F\nSAVER1L  DS    F                   HOLDS DECREMENTED LENGTH OF MODULE\nSAVER1P  DS    F                   HOLDS LENGTH OF PRINTED LINE - 1\nSAVER3A  DS    F\nSAVER3B  DS    F\nSAVER3C  DS    F\nSAVER7A  DS    F\nSAVER8A  DS    F\nSAVER9A  DS    F\nSAVER9B  DS    F\nSAVER9C  DS    F\nSAVER9D  DS    F\nSAVER9E  DS    F\nSAVER10A DS    F\nSAVER15A DS    F\nMAJNAME  DS    CL8\nFLAG1    DS    X                   X'01' if entry point at beginning\nFLAG2    DS    X                   X'01' if LPA module\nMASK10   DC    XL10'40202020202020202120'\nDASHES   DS    0CL65\nDASHEZ   DC    65C'-'\n         SPACE 1\n*IOPL     DS    0A                 IOPL FOR PUTLINE.\n*IOPLUPT  DS    A                  POINTER TO USER PROFILE TABLE.\n*IOPLECT  DS    A                  POINTER TO ENVIRONMENT CONTROL TAB.\n*IOPLECB  DC    A(ECB)             POINTER TO ECB.\n*IOPLIOPB DC    A(PTPB)            POINTER TO PTPB.\n         SPACE 1\n         SPACE 1\n*PTPB     PUTLINE MF=L PUTLINE PARM. BLOCK.\n         SPACE 1\nMVMEM    MVC   MEMBER(*-*),0(R15)  *** EXECUTED ***\n*VHEAD   MVC   0(*-*,R5),4(R9)     *** EXECUTED ***\nMVHEAD   MVC   LINE(*-*),4(R9)     *** EXECUTED ***\nTRT      TRT   0(*-*,R7),TRTAB     *** EXECUTED ***\nBLANKS   DC    CL65' '\nFULLZERO DC    F'0'\nRULERL   DC    C'0---+---+---+---1---+---+---+---2---+---+---+---3---+-x\n               --+---+---'\n         SPACE 1\nTRTAB    DC    256X'01'            TRT TABLE TO DETECT ...\n         ORG   TRTAB+C'a'          ... NON-DISPLAY CHARACTERS.\n         DC    9X'00'\n         ORG   TRTAB+C'j'\n         DC    9X'00'\n         ORG   TRTAB+C's'\n         DC    8X'00'\n         ORG   TRTAB+C'A'\n         DC    9X'00'\n         ORG   TRTAB+C'J'\n         DC    9X'00'\n         ORG   TRTAB+C'S'\n         DC    8X'00'\n         ORG   TRTAB+C'0'\n         DC    10X'00'\n         ORG   TRTAB+X'4A'\n         DC    7X'00'\n         ORG   TRTAB+C'!'\n         DC    8X'00'\n         ORG   TRTAB+X'6A'\n         DC    6X'00'\n         ORG   TRTAB+C':'\n         DC    6X'00'\n         ORG   TRTAB+X'AF'\n         DC    18X'00'\n         ORG   TRTAB+C'\\'\n         DC    2X'00'\n         ORG   TRTAB+C' '\n         DC    X'00'\n         ORG   ,\n         SPACE 1\n         LTORG\nWORKFULL DS    0F\n         DC    H'0'\nWORKHALF DC    H'0'\n         TITLE '- MESSAGES.'\nMSG001   DC    C'Load module has non-standard header.'\nMSG001L  EQU   *-MSG001\n         SPACE 1\nMSG002   DC    C'Cannot load '\nMEMBER   DC    CL8' '              NAME OF MEMBER TO BE EXAMINED.\n         DC    C' from any library in normal search path.'\nMSG002L  EQU   *-MSG002\nMSG003   DC    C'Beginning of CDE chain reached without a name match.'\nMSG003L  EQU   *-MSG003\n         TITLE '- Parse parameters.'\nPPL      DS    0A                  PARSE PARM LIST.\nPPLUPT   DS    A                   POINT TO UPT.\nPPLECT   DS    A                   POINT TO ECT.\nPPLECB   DC    A(ECB)              POINT TO ECB.\nPPLPCL   DC    A(PCL)              POINT TO PCL.\nPPLANS   DC    A(ANS)              POINT TO ANSWER PLACE.\nPPLCBUF  DS    A                   POINT TO COMMAND BUFFER.\nPPLWA    DC    A(0)                NO WORK AREA.\n         SPACE 1\nANS      DS    A                   ANSWER PLACE.\nECB      DC    A(0)                COMMAND PROCESSOR ECB.\nPCL      IKJPARM DSECT=PDL         PARSE PCL CSECT.\nPDLLM    IKJIDENT 'Load Module',FIRST=ALPHA,OTHER=ALPHANUM,            +\n               PROMPT='Load Module+',MAXLNTH=8,                        +\n               HELP=('Name of load module to be listed.')\nENTRYKW  IKJKEYWD ,\n         IKJNAME 'ENTRY'\nNOHEXKW  IKJKEYWD ,\n         IKJNAME 'NOHEX'\nHEXKW    IKJKEYWD ,\n         IKJNAME 'HEX'\n*NOTITKW IKJKEYWD ,\n*        IKJNAME 'NOTITLE'\n         IKJENDP\nHEX      DS    0H\n         ST    R4,SAVER4A\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         L     R4,SAVER4A\n         BR    R4                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\nSAVER4A  DS    F\nHEXSAVE  DS    3F                    Register save for HEX macro\n         DS    CL1\nLINE     DS    CL200\nTRTBL0   DS    0D\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'404040404040404040404A4B4C4D4E4F'\n         DC    XL16'504040404040404040405A5B5C5D5E5F'\n         DC    XL16'606140404040404040406A6B6C6D6E6F'\n         DC    XL16'404040404040404040407A7B7C7D7E7F'\n         DC    XL16'40818283848586878889404040404040'\n         DC    XL16'40919293949596979899404040404040'\n         DC    XL16'4040A2A3A4A5A6A7A8A9404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'C0C1C2C3C4C5C6C7C8C9404040404040'\n         DC    XL16'D0D1D2D3D4D5D6D7D8D9404040404040'\n         DC    XL16'E040E2E3E4E5E6E7E8E9404040404040'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9404040404040'\nTRTBL1   DS    0D\n         DC    XL16'F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0'\n         DC    XL16'F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1'\n         DC    XL16'F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2'\n         DC    XL16'F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3'\n         DC    XL16'F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4'\n         DC    XL16'F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5'\n         DC    XL16'F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6'\n         DC    XL16'F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7'\n         DC    XL16'F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8'\n         DC    XL16'F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9'\n         DC    XL16'C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1'\n         DC    XL16'C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2'\n         DC    XL16'C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3'\n         DC    XL16'C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4'\n         DC    XL16'C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5'\n         DC    XL16'C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6'\nTRTBL2   DS    0D\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         TITLE '- Mapping DSECTs.'\n         PRINT GEN\n         IKJCPPL                   MAP COMMAND PROCESSOR PARM LIST.\n         CVT   DSECT=YES\n         IKJTCB                                              *JUL-2014*\n         IHACDE                                              *JUL-2014*\n         IHAXTLST                                            *JUL-2014*\n         END   LISTMOD\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*  CLEANED A BIT  . . . 08/17\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATER  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUMENTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFORE R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   255                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nR3       EQU   3                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         EJECT\n         IHAPSA   LIST=YES                                     HD APR88\n         EJECT                                                 HD APR88\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\n         DS    0D\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   R14,R12,12(R13)    SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES,SP=0       RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    R1,8(,R13)         OUR SAVE AREA POINTER\n         ST    R13,4(,R1)         POINTER TO CALLER'S SAVE AREA\n         LR    R13,R1             @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(,R13)        POINT TO CALLER'S RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 RC IF BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 RC IF BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(,RML)              MESSAGE LENGTH\n         STH   R15,PUTLEN               PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(,R2)       @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(,R2)               REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    R2,R13                   @OUR SAVE AREA\n         LR    R3,R15                   SAVE RETURN CODE\n         L     R13,4(,R13)              @CALLER'S SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,R3                   RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLER'S REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END   EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTMOD$": {"ttr": 5124, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\t\\x01\\x055O\\x01 \\x03O\\x08W\\x00\\x1c\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2005-12-20T00:00:00", "modifydate": "2020-02-03T08:57:09", "lines": 28, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(LISTMOD)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,9),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET,NOREUS,NORENT'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(0)\n SETSSI  CB499994\n ENTRY   LISTMOD\n NAME    LISTMOD(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTMOD#": {"ttr": 5126, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x19\"O\\x01\\x19\"O\\x15\\x18\\x00\\x13\\x00\\x13\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-08-12T00:00:00", "modifydate": "2019-08-12T15:18:38", "lines": 19, "newlines": 19, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBT  JOB (ACCT#),S-GOLOB,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//* --------------------------------------------------------------- *//\n//*  EXAMPLE OF RUNNING LISTMOD AGAINST A LARGE MODULE TO CAPTURE   *//\n//*  THE DATA FOR EXAMINATION.  TSO-IN-BATCH.                       *//\n//* --------------------------------------------------------------- *//\n//TSOBATCH EXEC PGM=IKJEFT01\n//STEPLIB  DD DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSTSPRT DD DISP=(NEW,CATLG,DELETE),DSN=SBGOLOB.LISTMOD.IEFW21SD,\n//         UNIT=SYSALLDA,VOL=SER=WORKS3,\n//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920),\n//         SPACE=(CYL,(3,9),RLSE)\n//SYSTSIN DD *\nLISTMOD IEFW21SD\n/*\n//\nLISTMOD IEFAB4A0 ENTRY\nLISTMOD IEFW21SD ENTRY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTMODD": {"ttr": 5128, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x17\\x01\\x14 \\x1f\\x01 \\x03O\\x08\\x15\\x04`\\x02\\xcc\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2014-07-20T00:00:00", "modifydate": "2020-02-03T08:15:17", "lines": 1120, "newlines": 716, "modlines": 0, "user": "SBGOLOB"}, "text": "LISTMODD TITLE '- TSO command to list load module in hex format'\n         SPACE 1\n* ------------------------------------------------------------------- *\n***********************************************************************\n*                                                                     *\n*     LISTMODD - TSO command to list an entire module in ISPF-like    *\n*               hexadecimal format.  Width of the display is          *\n*               112 bytes wide, so that a wide screen is preferable.  *\n*                                                                     *\n*               Displacements of data are marked in decimal.          *\n*                                                                     *\n*               Using the ENTRY parameter, the display goes from      *\n*               the entry point until the physical end of the module. *\n*               Otherwise, the display includes the entire module     *\n*               from beginning to end.                                *\n*                                                                     *\n*     Register usage:                                                 *\n*           R5 - Base.                                                *\n*           R6 - Work.                                                *\n*           R7 - Work.                                                *\n*           R8 - Work.                                                *\n*           R9 - Work, Parse PDEs.                                    *\n*          R10 - CPPL pointer.                                        *\n*          R12 - Base.                                                *\n*                                                                     *\n*     Ideas in the program were developed by Jeffrey Broido and       *\n*     Bill Godfrey.  The program was adapted for dumping load         *\n*     modules, by Sam Golob.                                          *\n*                                                                     *\n*     Partial description of the program:  Display the bytes of       *\n*     a load module in ISPF-like 3-line hexadecimal format, with      *\n*     ruler to help measure and locate particular bytes.              *\n*                                                                     *\n*     The program works (currently) by first testing if the module    *\n*     is in the Link Pack Area (LPA).  If so, then the LPDE is        *\n*     looked up, to obtain the relevant information.  If the program  *\n*     is not in LPA, then a LOAD macro is issued to obtain the        *\n*     information.                                                    *\n*                                                                     *\n*     The program either displays the entire load module, or,         *\n*     using the ENTRY parameter, it starts with the entry point,      *\n*     and it dumps the contents of the rest of the load module,       *\n*     in 3-line hex format with ruler, to see what is there.          *\n*                                                                     *\n*     All the bytes of the program are displayed, if there is no      *\n*     parameter.  If the ENTRY parameter is used, then all the        *\n*     bytes from the entry point to the end of the module, are        *\n*     displayed.                                                      *\n*                                                                     *\n*              example:    LISTMODD modname ENTRY                     *\n*                                                                     *\n*     Please note that the HEX display will show all hex values       *\n*     in \"printable\" format, so you don't need any other tools        *\n*     to see the contents of the load modules, displayed in a         *\n*     3-line hexadecimal display with added ruler.                    *\n*                                                                     *\n*     For some modules, such as IEBCOPY, you have to use the          *\n*     ENTRY parameter to see a realistic eyecatcher.  But since       *\n*     (with IEBCOPY and with many other load modules) the entry       *\n*     point is in the middle of the load module, LISTMODD will        *\n*     then (using the ENTRY keyword) only list the bytes from         *\n*     the entry point location until the end of the module.           *\n*                                                                     *\n*     CHANGES:  2020/02/03 - SBG                                      *\n*               Changed ruler to go from 0 to 99 instead of           *\n*               from 1 to 100.  It had been one byte off.             *\n*                                                                     *\n***********************************************************************\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\n*      PRODUCE A \"DISPLAY REPRESENTATION\" OF HEXADECIMAL NUMBERS      *\n* ------------------------------------------------------------------- *\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         STM   R15,R1,HEXSAVE\n         LA    R1,&FROM\n         LA    R0,&LEN\n         LA    R15,&TO\n         BAL   R4,HEX\n         LM    R15,R1,HEXSAVE\n         MEND\n* ------------------------------------------------------------------- *\n*                   BEGINNING OF THE PROGRAM                          *\n* ------------------------------------------------------------------- *\nLISTMODD AMODE 31\nLISTMODD RMODE ANY\nLISTMODD CSECT\n         SPACE 1\n         SPACE 1\n         YREGS\n         USING LISTMODD,R15        (ESTABLISH TEMPORARY BASE).\n         B     BEGIN               SKIP OVER HEADER.\nHEAD0    DC    AL1(HEADL)          EXCLUSIVE LENGTH OF HEADER.\nHEAD     DC    C'LISTMODD - &SYSDATE - &SYSTIME  '\nHEADL    EQU   *-HEAD\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         LR    R12,R15             COPY BASE.\n         USING LISTMODD,R12,R5     SET UP BASE REGISTERS.\n         LA    R5,4095(,R12)\n         LA    R5,1(,R5)\n         LR    R14,R13             COPY CALLER'S SAVE AREA POINTER.\n         LA    R13,SAVE            POINT TO MY SAVE AREA.\n         ST    R14,SAVE+4          CHAIN ...\n         ST    R13,8(,R14)         ... SAVE AREAS.\n         SPACE 1\n         MVI   LINE-1,X'40'\n         MVC   LINE,LINE-1\n         MVI   BLANKS-1,X'40'      FILL THE BLANKS FIELD\n         MVC   BLANKS,BLANKS-1       WITH BLANKS\n         MVC   MEMBER,BLANKS       Initialize member name with blanks.\n         LR    R10,R1              PRESERVE CPPL POINTER.\n         MVC   MAJNAME,BLANKS\n         USING CPPL,R10            (TELL ASSEMBLER)\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        Initialize the Parse Parameter List and call TSO Parse.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         MVC   PPLUPT,CPPLUPT      COPY UPT ADDRESS.\n         MVC   PPLECT,CPPLECT      COPY ECT ADDRESS.\n         MVC   PPLCBUF,CPPLCBUF    COPY COMMAND BUFFER ADDRESS.\n         SPACE 1\n         LA    R1,PPL              POINT TO THE PPL.\n         XC    ECB,ECB             CLEAR ECB.\n         CALLTSSR EP=IKJPARS       PARSE INPUT.\n         LTR   R15,R15             Check return code from IKJPARS\n         BNZ   HELPMSG             Not zero, Help message and end.\n         L     R9,ANS              POINT TO PDES.\n         USING PDL,R9              TELL ASSEMBLER.\n         LH    R1,PDLLM+4          LOAD LENGTH OF LOAD MODULE NAME.\n         BCTR  R1,*-*              DECREMENT LENGTH.\n         L     R15,PDLLM           POINT TO RETURNED MEMBER NAME.\n         EX    R1,MVMEM            COPY MEMBER NAME FROM PDL\n*      ( MVC   MEMBER(*-*),0(R15)  )\n         MVC   ENTRYOP,ENTRYKW\n         MVC   NOHEXOP,NOHEXKW                               *DEC-2016*\n         MVC   HEXOP,HEXKW\n*        MVC   NOTITOP,NOTITKW                               *DEC-2016*\n         MVI   FLAG1,X'00'             Initialize flag.\n         MVC   STORDIFF,=X'00000000'   Assume the entry point at 0.\nFREEPDES IKJRLSA ANS               FREE THE PDES.\n*        CLI   NOTITOP+1,0                                   *DEC-2016*\n*        BNE   NOTIT2                                        *DEC-2016*\n         MVC   LINE,LINE-1\n         MVC   LINE(22),=C'Loaded Program Name:  '\n         MVC   LINE+22(8),MEMBER\n         APUT  LINE,40\nNOTIT1   DS    0H                                            *DEC-2016*\n*        CLI   NOHEXOP+1,0         IF NOHEX KEYWORD          *DEC-2016*\n*        BNE   LPA0\n         MVC   LINE,LINE-1\n         MVC   LINE(65),DASHES\n         APUT  LINE,65\nNOTIT2   DS    0H                                            *DEC-2016*\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              FETCH THE USER-SPECIFIED LOAD MODULE.                  *\n*                                                                     *\n***********************************************************************\n* ------------------------------------------------------------------- *\n*    LOGIC OF THE PROGRAM WAS CHANGED TO DO A STANDARD \"LOAD\" FOR     *\n*    THE MODULE REQUESTED, BUT TO AFTERWARDS, ALSO CALCULATE THE      *\n*    MODULE ENTRY POINT IN THE DIFFERENT WAYS POSSIBLE, AND TO SAVE   *\n*    ALL THE RESULTS.  AFTERWARDS, DEPENDING ON WHETHER THE \"ENTRY\"   *\n*    PARAMETER WAS CODED, THE RESULTS ARE DISPLAYED ACCORDINGLY.      *\n* ------------------------------------------------------------------- *\n*    We first ask if the module is from LPA, and if not, then we      *\n*    LOAD it.                                                         *\n* ------------------------------------------------------------------- *\nLPA0     DS    0H\n         LM    R0,R1,MEMBER       Load member name for IEAVVMSR\n         STM   R7,R8,LPAREGS      Save registers\n         L     R3,16              CVT\n         L     R15,352(,R3)       CVTLPDSR\n         BALR  R14,R15            CALL IEAVVMSR\n         B     LPAINFO            MODULE IS IN LPA, GET LPDE.\n         B     LOAD0              NOT IN LPA, TRY LOADING IT.\nLPAINFO  DS    0H\n         OI    FLAG2,X'01'        FLAG THE MODULE AS AN LPA MODULE.\n         LM    R7,R8,LPAREGS      RESTORE REGISTERS\n         LR    R6,R0              SAVE LPDE ADDRESS\n         ST    R6,LPDEADDR        And store it for reporting\n         L     R9,16(,R6)         GET ENTRY POINT ADDRESS\n         N     R9,=X'7FFFFFFF'    Get rid of high bit.\n         ST    R9,SAVER9B         SAVE MODULE ENTRY POINT\n         TM    X'1C'(R6),X'04'    IS THIS A MINOR LPDE (ALIAS)?\n         BZ    MAJLPDE            NO. PROCESS AS A MAJOR.\n         OI    FLAG2,X'02'        Mark this one as an alias.\n         MVC   MAJNAME(8),X'20'(R6)  Copy the major name for report.\n         L     R6,X'14'(,R6)      YES. GET ADDRESS OF MAJOR LPDE.\nMAJLPDE  DS    0H\n         L     R9,X'24'(,R6)      GET MODULE LOAD POINT.\n         N     R9,=X'7FFFFFFF'    Remove the 31-bit indicator\n         ST    R9,ADRSTART        Start of the full data of the module\n         ST    R9,SAVER9A         Save it in another place\n         ST    R9,SAVER9C         SAVE THE LOAD POINT.\n         L     R9,X'20'(,R6)      GET THE SIZE OF THE LOAD MODULE.\n         ST    R9,LOADLEN         SAVE THE ENTIRE SIZE\n         MVC   LOADWHOL,LOADLEN   COPY WHOLE SIZE\n         L     R2,SAVER9B         GET THE ENTRY POINT\n         L     R3,SAVER9C         SUBTRACT THE LOAD POINT\n         SR    R2,R3              GET THE DISPLACEMENT\n         BNP   ENTRYPM1           GO TO SAME CALC AS WITH LOAD\n         ST    R2,STORDIFF        SAVE THE DISPLACEMENT\n         B     ENTRYPM0           GO TO THE SAME CALC AS WITH LOAD\n* ------------------------------------------------------------------- *\nLOAD0    DS    0H                 NOT IN LPA. LOAD THE MODULE.\n         LM    R7,R8,LPAREGS      RESTORE REGISTERS\n         LOAD  EPLOC=MEMBER,ERRET=LOAD1  FETCH LOAD MODULE TO LIST.\n*    Put in a display of x number of bytes at the load point, here.\nLOAD1    LTR   R15,R15             WAS LOAD SUCCESSFUL?\n         BZ    LOAD2               B IF YES; CONTINUE.\n*              SAY: CANNOT LOAD MEMBER.\n         MVC   LINE,LINE-1\n         MVC   LINE(MSG002L),MSG002\n         APUT  LINE,MSG002L\n         LA    R15,8               SET CC = 8.\n         B     EXIT                EXIT.\nLOAD2    DS    0H\n         LR    R9,R0               POINT TO LOAD MODULE TO BE LISTED.\n         N     R9,=X'7FFFFFFF'     Get rid of high bit for calculations\n         ST    R9,ADRSTART         Start of the full data of the module\n         ST    R9,SAVER9A          Save it in another place\n         ST    R9,SAVER9B          Save it again in another place\n         NC    SAVER9B(4),=A(X'7FFFFFFF')  Maybe not necessary\n         N     R1,=A(X'00FFFFFF')  ISOLATE LENGTH IN DWORDS  *JUL-2014*\n         ST    R3,SAVER3B          Save R3 to restore later\n         LR    R3,R1               Get length in doublewords\n         SLL   R3,3                Convert to bytes (multiply by 8)\n         ST    R3,SAVER3A          Save length in bytes\n         L     R3,SAVER3B          Restore original R3\n         SLL   R1,3                Do the same for R1        *JUL-2014*\n         ST    R1,LOADLEN          And save the max display length\n         MVC   LOADWHOL,LOADLEN    Save it again\n* ------------------------------------------------------------------- *\n* NOTE: IF THE 'ENTRY' KEYWORD IS SPECIFIED, AND THE         *JUL-2014*\n* ENTRY POINT IS NEAR THE END OF THE MODULE, THERE MAY BE    *JUL-2014*\n* FEWER BYTES THAN THE LOADLEN VALUE FROM THE ENTRY POINT    *JUL-2014*\n* TO THE END OF THE MODULE. AS A RESULT, THE DISPLAY OF      *JUL-2014*\n* LOADLEN BYTES MIGHT INCLUDE THE CONTENTS OF MEMORY BEYOND  *JUL-2014*\n* THE END OF THE MODULE.                                     *JUL-2014*\n* IF THE LAST CDE IN JOB PACK AREA QUEUE IS FOR A MODULE     *JUL-2014*\n* THAT CONTAINS THE ENTRY POINT ADDRESS IN R9, USE THE       *JUL-2014*\n* ADDRESS OF THE MODULE INSTEAD OF THE ENTRY POINT.          *JUL-2014*\n* NOTE: COULD ALSO USE LOADPT= ON THE LOAD MACRO, BUT        *JUL-2014*\n* MVS 3.8 SYSTEMS DON'T HAVE LOADPT=.                        *JUL-2014*\n* ------------------------------------------------------------------- *\n*       CALCULATE THE ENTRY POINT ADDRESS OF THE LOAD MODULE          *\n*              THIS CODE IS NOW, ALWAYS EXECUTED.                     *\n* ------------------------------------------------------------------- *\n         N     R9,=A(X'7FFFFFFF')                            *JUL-2014*\n         L     R14,540             PSATOLD -> CURRENT TCB    *JUL-2014*\n         L     R14,TCBJSTCB-TCB(,R14) POINT TO JOB STEP TCB  *JUL-2014*\n         L     R14,TCBJPQ-TCB(,R14) PNT TO LAST CDE IN JPAQ  *JUL-2014*\n* ------------------------------------------------------------------- *\n*              The correct CDE might not be the last one,             *\n*             so chain back until you've got a name match.            *\n* ------------------------------------------------------------------- *\nCDELOOP  DS    0H                  Check if CDE matches member name\n         CLC   MEMBER(8),8(R14)    Is this the correct CDE? (match)\n         BE    CDEEND              Yes, then process it.\n         CLC   FULLZERO,0(R14)     Back at the beginning of the chain\n         BE    CDEBAD                without a match? Then error.\n         L     R14,0(,R14)         No match. Go back one previous CDE.\n         B     CDELOOP             Keep trying till match or first CDE\n*                                    without a match.\nCDEBAD   DS    0H\n         MVC   LINE,LINE-1         Error message if beginning of CDE\n         MVC   LINE(MSG003L),MSG003  was reached without a name match.\n         APUT  LINE,MSG003L\n         B     EXIT12              Code 12 for this one.\nCDEEND   DS    0H\n         ST    R14,CDEADDR\n         TM    CDATTR-CDENTRY(R14),CDMIN TEST FOR MINOR CDE  *JUL-2014*\n         BZ    MAJCDE              BRANCH IF MAJOR CDE       *JUL-2014*\n         L     R14,CDXLMJP-CDENTRY(,R14) POINT TO MAJOR CDE  *JUL-2014*\n         OI    FLAG2,X'20'        Mark as CDE of an alias.\n         MVC   MAJNAME(8),X'8'(R14)     REAL NAME OF MODULE\nMAJCDE   L     R14,CDXLMJP-CDENTRY(,R14) POINT TO EXTENT     *JUL-2014*\n         L     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*\n         ST    R0,SAVER9C\n         CR    R9,R0                                         *JUL-2014*\n         BL    KEEPR9                                        *JUL-2014*\n         L     R0,XTLMSBLA-XTLST(,R14) LENGTH OF MODULE      *JUL-2014*\n         N     R0,=A(X'7FFFFFFF')                            *JUL-2014*\n         ST    R0,SAVER1B\n         A     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*\n         ST    R0,SAVER9D\n         CR    R9,R0                                         *JUL-2014*\n         BNL   KEEPR9                                        *JUL-2014*\n         L     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*\n         LR    R9,R0                                         *JUL-2014*\n         ST    R9,SAVER9E\n* ------------------------------------------------------------------- *\n*            COME HERE FOR BOTH LPA AND LOADED MODULES                *\n* ------------------------------------------------------------------- *\nENTRYPM  DS    0H                  Check if entry point is displaced.\n         L     R2,SAVER9B          Get entry point of module\n         L     R3,SAVER9C          Get beginning addr of module\n         SR    R2,R3               Calculate difference in length\n         BNP   ENTRYPM1            Number is not reliable\n         ST    R2,STORDIFF         Save the entry point displacement.\nENTRYPM0 DS    0H\n         LTR   R2,R2               Is it zero?\n         BZ    NODIFF              Then do the whole module.\nENTRYPM1 DS    0H\n         L     R1,LOADWHOL         Load length from LOAD macro\n         MVC   SAVER3A,LOADWHOL\n         S     R1,STORDIFF         Subtract offset of entry point\n         ST    R1,LOADSMAL         Preserve reduced load length\n         MVC   SAVER3B,LOADSMAL    Save short length for later\n         B     YESDIFF             Yes, entry point diff from load pt\nKEEPR9   DS    0H\n*\nNODIFF   DS    0H                  Go here if entry pt is load point\n         MVC   LOADSMAL,LOADWHOL   Size is from beginning to end\n         MVC   SAVER3B,LOADSMAL    Save size from entry point to end\n         L     R1,LOADWHOL         Load R1 with size\n         OI    FLAG1,X'01'         Flag load point equal entry point\n         L     R9,ADRSTART         Load R9 with data address\n*\nYESDIFF  DS    0H\n         TM    FLAG1,X'01'         Load point different from entry pt?\n         BZ    ENTRYDIF            No. Skip this section.\n         L     R1,LOADWHOL         Start R1 with whole size.\n         ST    R1,LOADLEN          And store it in LOADLEN.\n         L     R9,ADRSTART         Load R9 with data address\n* ------------------------------------------------------------------- *\nENTRYDIF DS    0H                  Display of Diagnostic Data\n         ST    R9,SAVER9A          SAVE THE PROGRAM DATA\n*        CLI   NOTITOP+1,0\n*        BNE   KEEPR9A\n         TM    FLAG2,X'20'\n         BO    NOTLPA00\n         TM    FLAG2,X'01'\n         BO    MARKLPA\nNOTLPA00 DS    0H\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Module has been LOADED.'\n         MVC   LINE+24(13),=C'CDE Address: '\n         HEX   LINE+37,4,CDEADDR\n         TM    FLAG2,X'20'\n         BZ    MARKCDEA\n         MVC   LINE+47(10),=C'Alias of: '\n         MVC   LINE+57(8),MAJNAME\nMARKCDEA DS    0H\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,75\n         LM    R14,R1,SAVE14T1\n         B     MOREDSPL\nMARKLPA  DS    0H\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Module is from LPA.    '\n         MVC   LINE+21(14),=C'LPDE Address: '\n         HEX   LINE+35,4,LPDEADDR\n         TM    FLAG2,X'02'\n         BZ    MARKLPAA\n         MVC   LINE+46(10),=C'Alias of: '\n         MVC   LINE+56(8),MAJNAME\nMARKLPAA DS    0H\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,65\n         LM    R14,R1,SAVE14T1\nMOREDSPL DS    0H\n         MVC   LINE,LINE-1\n         HEX   LINE+30,4,SAVER3A\n         MVC   LINE(30),=C'Length of loaded module Hex:  '\n         L     R3,SAVER3A\n         CVD   R3,CVDWORK          Convert to Decimal\n         MVC   LINE+42(9),=C'Decimal: '\n         MVC   LINE+52(10),MASK10\n         ED    LINE+52(10),CVDWORK+3\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,75\n         LM    R14,R1,SAVE14T1\n         MVC   LINE,LINE-1\n         HEX   LINE+30,4,LOADSMAL\n         MVC   LINE(30),=C'Length after entry address :  '\n         L     R3,LOADSMAL\n         CVD   R3,CVDWORK          Convert to Decimal\n         MVC   LINE+42(9),=C'Decimal: '\n         MVC   LINE+52(10),MASK10\n         ED    LINE+52(10),CVDWORK+3\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,75\n         LM    R14,R1,SAVE14T1\n         MVC   LINE,LINE-1\n         HEX   LINE+30,4,STORDIFF\n         MVC   LINE(30),=C'Displacement of entry point:  '\n         L     R3,STORDIFF\n         CVD   R3,CVDWORK          Convert to Decimal\n         MVC   LINE+42(9),=C'Decimal: '\n         MVC   LINE+52(10),MASK10\n         ED    LINE+52(10),CVDWORK+3\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,75\n         LM    R14,R1,SAVE14T1\n         MVC   LINE,LINE-1             Test diagnostics display.\n         HEX   LINE,4,SAVER9A\n         HEX   LINE+10,4,SAVER9B\n         HEX   LINE+20,4,SAVER9C\n         HEX   LINE+30,4,SAVER9D\n         HEX   LINE+40,4,SAVER9E\n         HEX   LINE+50,4,LOADSMAL\n         HEX   LINE+60,4,LOADWHOL\n         HEX   LINE+70,4,STORDIFF\n         HEX   LINE+80,4,ADRSTART\n         HEX   LINE+90,4,SAVER1B\n         HEX   LINE+100,1,FLAG1\n*        STM   R14,R1,SAVE14T1\n*        APUT  LINE,105\n*        LM    R14,R1,SAVE14T1\nKEEPR9A  DS    0H\n*\n         CLI   NOHEXOP+1,0                                   *DEC-2016*\n         BNE   JUST1                                         *DEC-2016*\n         MVC   LINE,LINE-1         Print a line of dashes\n         MVC   LINE(65),DASHES\n         APUT  LINE,65\nNODASH1  DS    0H                                            *DEC-2016*\n* ------------------------------------------------------------------- *\n*              PREPARE FOR HEX DISPLAY OF ALL LINES                   *\n* ------------------------------------------------------------------- *\nENTRYPRM DS    0H                  Process the ENTRY keyword here.\n         CLI   ENTRYOP+1,0         Entry keyword not there?\n         BE    BIGMOD              Go treat whole module.\n         L     R9,SAVER9B          Data address at entry point\n         L     R1,LOADSMAL         Load reduced size, e.p. to end.\n         B     SMALLMOD            Don't display the whole module.\nBIGMOD   DS    0H\n         L     R9,SAVER9C          Address of beginning of the data.\n         L     R1,LOADWHOL         Load the full size of the module.\n*              IF THE MODULE SIZE < 100 THEN DON'T SHOW 100\nSMALLMOD DS    0H\n         LR    R10,R1              Save length for calculation\n         ST    R1,SAVER1L          Store it for printing\nLATENTRY DS    0H\n         ST    R10,SAVER10A        Store it for safety\n* ------------------------------------------------------------------- *\n*            Calculate how many lines we will need to print.          *\n* ------------------------------------------------------------------- *\n         SRDA  R10,32(0)           Set up divide\n         D     R10,=F'100'         Divide by 100 decimal\n         LTR   R10,R10             Even division?\n         BZ    NOREMNDR            Yes. Don't compensate for remainder\n         LA    R11,1(,R11)         Add 1 to compensate for remainder\n*                                    and print a partial line.\nNOREMNDR DS    0H\n         XR    R8,R8               Initialize byte counter\n* ------------------------------------------------------------------- *\n*                     Print All The Lines                             *\n* ------------------------------------------------------------------- *\nPRNTLOOP DS    0H\n*   R1 has quantity SAVER1L in it here.\n         C     R1,=F'100'          Less than 100?\n         BNH   *+8                 Yes, skip limit to 100.\n         L     R1,=F'100'          No. Just print 100 at a time\n         BCTR  R1,0                One less for execute.\n         STM   R14,R1,SAVE14T1     Protect registers used by APUT\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1A\n         APUT  LINE,4,SAVER1A\n         LM    R14,R1,SAVE14T1\n*   R1 has quantity SAVER1P in it here.\n         ST    R1,SAVER1P          Save the length - 1\n         STM   R14,R1,SAVE14T1     Protect registers used by PRTXLINE\n         L     R1,SAVER1P          Save the length - 1\n         BAL   R7,PRTXLINE         Print these 100 bytes in hex\n         LM    R14,R1,SAVE14T1\n*   DISPLAY LATER LINES\n         LA    R9,100(,R9)         Skip 100 bytes from current\n         L     R1,SAVER1L          Reload remaining data length\n         S     R1,=F'100'          Subtract 100\n         BNP   JUST1               Finished? Stop the process.\n         ST    R1,SAVER1L          Decremented length\n         BCT   R11,PRNTLOOP\n* ------------------------------------------------------------------- *\n*                      END OF HEX DISPLAY                             *\n* ------------------------------------------------------------------- *\nJUST1    DS    0H                  CHECK FOR INITIAL INSTRUCTIONS\n         CLI   NOHEXOP+1,0\n         BE    NODASH01\n         MVC   LINE,LINE-1\n         MVC   LINE(65),DASHES\n         APUT  LINE,65\nNODASH01 DS    0H\n         TM    FLAG2,X'01'\n         BO    WASLPA\n         DELETE EPLOC=MEMBER\nWASLPA   DS    0H\n*\nEXIT0    SR    R15,R15             SET CC = 0.\n         ST    R15,SAVER15A        SAVE THE RETURN CODE\nEXIT     L     R13,SAVE+4          POINT TO CALLER'S SAVE AREA.\n         LM    R0,R12,20(R13)      RELOAD MOST OF CALLER'S REGISTERS.\n         L     R14,12(,R13)        RELOAD RETURN ADDRESS.\n         BR    R14                 RETURN TO CALLER.\nEXIT12   LA    R15,12\n         ST    R15,SAVER15A        SAVE THE RETURN CODE\n         B     EXIT\n* ------------------------------------------------------------------- *\n*                     HEX DISPLAY SUBROUTINE                          *\n* ------------------------------------------------------------------- *\nPRTXLINE DS    0H                  4-line hex printout routine.\n         ST    R7,SAVER7A\n         ST    R8,SAVER8A\n         CVD   R8,CVDWORK          The line number of bytes so far\n         MVC   LINE,LINE-1\n         L     R1,SAVER1P          Length of line to print\n         B     *+10\n         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE\n         EX    R1,*-6\n         L     R1,SAVER1P          RELOAD THE LENGTH\n         B     *+10\nTRHEXL0  TR    LINE(*-*),TRTBL0    Make the line of printables\n         EX    R1,TRHEXL0\n         MVC   LINE+100(10),MASK10     Print counter after 1st line\n         MVC   LINE+110(2),=C'00'      Show it in hundreds\n         ED    LINE+100(10),CVDWORK+3  Plug the number in\n         APUT  LINE,112            Print the line of printables\n         MVC   LINE,LINE-1\n         L     R1,SAVER1P          Reload the length of the line\n         B     *+10\n         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE\n         EX    R1,*-6\n         B     *+10\nTRHEXL1  TR    LINE(*-*),TRTBL1    HIGH NIBBLE IN HEX DISPLAY\n         EX    R1,TRHEXL1\n         APUT  LINE,100\n         MVC   LINE,LINE-1\n         L     R1,SAVER1P          Reload the length of the line\n         B     *+10\n         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE\n         EX    R1,*-6\n         B     *+10\nTRHEXL2  TR    LINE(*-*),TRTBL2    LOW NIBBLE IN HEX DISPLAY\n         EX    R1,TRHEXL2\n         APUT  LINE,100\n         MVC   LINE,LINE-1\n         L     R1,SAVER1P          Reload the length of the line\n*                                  since APUT destroys R1.\n         B     *+10\n         MVC   LINE(0),RULERL      Print the ruler line\n         EX    R1,*-6\n         APUT  LINE,100\n         LA    R8,1(,R8)           Increment counter (x 100)\n         L     R7,SAVER7A\n         BR    R7\n* ------------------------------------------------------------------- *\nHELPMSG  DS    0H\n         STM   R14,R1,SAVE14T1\n         APUT  '-------------------------------------------------',49\n         APUT  'Correct usage of LISTMODD is as follows:  ',42\n         APUT  '   ',3\n         APUT  '  LISTMODD modname (optional parameters)  ',42\n         APUT  '   ',3\n         APUT  'Parameters are:  NOHEX and ENTRY      ',39\n         APUT  '   ',3\n         APUT  'Required is the name of the module to load.',43\n         APUT  '   ',3\n         APUT  'Leaving out parameters produces the hex display',47\n         APUT  '  from the beginning of the module.  ENTRY starts',49\n         APUT  '  the display from the entry point of the module.',49\n         APUT  '   ',3\n         APUT  '  NOHEX prints the header information only.      ',49\n         APUT  '-------------------------------------------------',49\n         STM   R14,R1,SAVE14T1\n         B     EXIT\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         TITLE '- Static data area.'\n* ------------------------------------------------------------------- *\nSAVE     DS    9D                  SAVE AREA.\nCVDWORK  DS    D                   CVD work area\nLOADLEN  DS    F\nLPAREGS  DS    2F\nLOADWHOL DS    F                   Entire size of load module\nLOADSMAL DS    F                   Distance from entry point to end.\nSTORDIFF DS    F                   Displacement of entry point.\nENTRYOP  DS    F\nNOHEXOP  DS    F\nNOTITOP  DS    F\nHEXOP    DS    F\nTITOP    DS    F\nSAVE14T1 DS    4F\nADRENTRY DS    F\nADRSTART DS    F\nLPDEADDR DS    F\nCDEADDR  DS    F\nSAVER1A  DS    F\nSAVER1B  DS    F\nSAVER1L  DS    F                   HOLDS DECREMENTED LENGTH OF MODULE\nSAVER1P  DS    F                   HOLDS LENGTH OF PRINTED LINE - 1\nSAVER3A  DS    F\nSAVER3B  DS    F\nSAVER3C  DS    F\nSAVER7A  DS    F\nSAVER8A  DS    F\nSAVER9A  DS    F\nSAVER9B  DS    F\nSAVER9C  DS    F\nSAVER9D  DS    F\nSAVER9E  DS    F\nSAVER10A DS    F\nSAVER15A DS    F\nMAJNAME  DS    CL8\nFLAG1    DS    X                   X'01' if entry point at beginning\nFLAG2    DS    X                   X'01' if LPA module\nMASK10   DC    XL10'40202020202020202120'\nDASHES   DS    0CL65\nDASHEZ   DC    65C'-'\n         SPACE 1\n*IOPL     DS    0A                 IOPL FOR PUTLINE.\n*IOPLUPT  DS    A                  POINTER TO USER PROFILE TABLE.\n*IOPLECT  DS    A                  POINTER TO ENVIRONMENT CONTROL TAB.\n*IOPLECB  DC    A(ECB)             POINTER TO ECB.\n*IOPLIOPB DC    A(PTPB)            POINTER TO PTPB.\n         SPACE 1\n         SPACE 1\n*PTPB     PUTLINE MF=L PUTLINE PARM. BLOCK.\n         SPACE 1\nMVMEM    MVC   MEMBER(*-*),0(R15)  *** EXECUTED ***\n*VHEAD   MVC   0(*-*,R5),4(R9)     *** EXECUTED ***\nMVHEAD   MVC   LINE(*-*),4(R9)     *** EXECUTED ***\nTRT      TRT   0(*-*,R7),TRTAB     *** EXECUTED ***\nBLANKS   DC    CL65' '\nFULLZERO DC    F'0'\nRULERL   DC    C'0----+----1----+----2----+----3----+----4----+----5---x\n               -+----6----+----7----+----8----+----9----+----'\n         SPACE 1\nTRTAB    DC    256X'01'            TRT TABLE TO DETECT ...\n         ORG   TRTAB+C'a'          ... NON-DISPLAY CHARACTERS.\n         DC    9X'00'\n         ORG   TRTAB+C'j'\n         DC    9X'00'\n         ORG   TRTAB+C's'\n         DC    8X'00'\n         ORG   TRTAB+C'A'\n         DC    9X'00'\n         ORG   TRTAB+C'J'\n         DC    9X'00'\n         ORG   TRTAB+C'S'\n         DC    8X'00'\n         ORG   TRTAB+C'0'\n         DC    10X'00'\n         ORG   TRTAB+X'4A'\n         DC    7X'00'\n         ORG   TRTAB+C'!'\n         DC    8X'00'\n         ORG   TRTAB+X'6A'\n         DC    6X'00'\n         ORG   TRTAB+C':'\n         DC    6X'00'\n         ORG   TRTAB+X'AF'\n         DC    18X'00'\n         ORG   TRTAB+C'\\'\n         DC    2X'00'\n         ORG   TRTAB+C' '\n         DC    X'00'\n         ORG   ,\n         SPACE 1\n         LTORG\nWORKFULL DS    0F\n         DC    H'0'\nWORKHALF DC    H'0'\n         TITLE '- MESSAGES.'\nMSG001   DC    C'Load module has non-standard header.'\nMSG001L  EQU   *-MSG001\n         SPACE 1\nMSG002   DC    C'Cannot load '\nMEMBER   DC    CL8' '              NAME OF MEMBER TO BE EXAMINED.\n         DC    C' from any library in normal search path.'\nMSG002L  EQU   *-MSG002\nMSG003   DC    C'Beginning of CDE chain reached without a name match.'\nMSG003L  EQU   *-MSG003\n         TITLE '- Parse parameters.'\nPPL      DS    0A                  PARSE PARM LIST.\nPPLUPT   DS    A                   POINT TO UPT.\nPPLECT   DS    A                   POINT TO ECT.\nPPLECB   DC    A(ECB)              POINT TO ECB.\nPPLPCL   DC    A(PCL)              POINT TO PCL.\nPPLANS   DC    A(ANS)              POINT TO ANSWER PLACE.\nPPLCBUF  DS    A                   POINT TO COMMAND BUFFER.\nPPLWA    DC    A(0)                NO WORK AREA.\n         SPACE 1\nANS      DS    A                   ANSWER PLACE.\nECB      DC    A(0)                COMMAND PROCESSOR ECB.\nPCL      IKJPARM DSECT=PDL         PARSE PCL CSECT.\nPDLLM    IKJIDENT 'Load Module',FIRST=ALPHA,OTHER=ALPHANUM,            +\n               PROMPT='Load Module+',MAXLNTH=8,                        +\n               HELP=('Name of load module to be listed.')\nENTRYKW  IKJKEYWD ,\n         IKJNAME 'ENTRY'\nNOHEXKW  IKJKEYWD ,\n         IKJNAME 'NOHEX'\nHEXKW    IKJKEYWD ,\n         IKJNAME 'HEX'\n*NOTITKW IKJKEYWD ,\n*        IKJNAME 'NOTITLE'\n         IKJENDP\nHEX      DS    0H\n         ST    R4,SAVER4A\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         L     R4,SAVER4A\n         BR    R4                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\nSAVER4A  DS    F\nHEXSAVE  DS    3F                    Register save for HEX macro\n         DS    CL1\nLINE     DS    CL200\nTRTBL0   DS    0D\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'404040404040404040404A4B4C4D4E4F'\n         DC    XL16'504040404040404040405A5B5C5D5E5F'\n         DC    XL16'606140404040404040406A6B6C6D6E6F'\n         DC    XL16'404040404040404040407A7B7C7D7E7F'\n         DC    XL16'40818283848586878889404040404040'\n         DC    XL16'40919293949596979899404040404040'\n         DC    XL16'4040A2A3A4A5A6A7A8A9404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'C0C1C2C3C4C5C6C7C8C9404040404040'\n         DC    XL16'D0D1D2D3D4D5D6D7D8D9404040404040'\n         DC    XL16'E040E2E3E4E5E6E7E8E9404040404040'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9404040404040'\nTRTBL1   DS    0D\n         DC    XL16'F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0'\n         DC    XL16'F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1'\n         DC    XL16'F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2'\n         DC    XL16'F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3'\n         DC    XL16'F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4'\n         DC    XL16'F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5'\n         DC    XL16'F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6'\n         DC    XL16'F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7'\n         DC    XL16'F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8'\n         DC    XL16'F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9'\n         DC    XL16'C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1'\n         DC    XL16'C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2'\n         DC    XL16'C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3'\n         DC    XL16'C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4'\n         DC    XL16'C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5'\n         DC    XL16'C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6'\nTRTBL2   DS    0D\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         TITLE '- Mapping DSECTs.'\n         PRINT GEN\n         IKJCPPL                   MAP COMMAND PROCESSOR PARM LIST.\n         CVT   DSECT=YES\n         IKJTCB                                              *JUL-2014*\n         IHACDE                                              *JUL-2014*\n         IHAXTLST                                            *JUL-2014*\n         END   LISTMODD\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*  CLEANED A BIT  . . . 08/17\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATER  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUMENTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFORE R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   255                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nR3       EQU   3                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         EJECT\n         IHAPSA   LIST=YES                                     HD APR88\n         EJECT                                                 HD APR88\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\n         DS    0D\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   R14,R12,12(R13)    SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES,SP=0       RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    R1,8(,R13)         OUR SAVE AREA POINTER\n         ST    R13,4(,R1)         POINTER TO CALLER'S SAVE AREA\n         LR    R13,R1             @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(,R13)        POINT TO CALLER'S RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 RC IF BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 RC IF BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(,RML)              MESSAGE LENGTH\n         STH   R15,PUTLEN               PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(,R2)       @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(,R2)               REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    R2,R13                   @OUR SAVE AREA\n         LR    R3,R15                   SAVE RETURN CODE\n         L     R13,4(,R13)              @CALLER'S SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,R3                   RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLER'S REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END   EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAPSP": {"ttr": 5635, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x17\\x00\\x85\\x18/\\x01\\x13\\x13/\\x15\\x01\\x01`\\x01a\\x00\\xb9\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "2013-05-12T15:01:17", "lines": 352, "newlines": 353, "modlines": 185, "user": "BROIDO"}, "text": "MAPSP    TITLE 'MAPSP - TSO COMMAND TO PROVIDE MVS/SP STORAGE LAYOUT MA+\n               P.'\n         SPACE 2\n*%A PPLINK AMODGEN NOTEST AC(1)\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  COPYRIGHT (C) 1984 BY BROIDO COMPUTER CONSULTING.  ALL RIGHTS      *\n*  RESERVED EXCEPT:                                                   *\n*                                                                     *\n*  PARTICULAR LICENSE IS GRANTED TO DISTRIBUTE THIS PROGRAM FREE      *\n*  OF CHARGE, BUT IT MUST NOT BE SOLD.  A SERVICE CHARGE FOR          *\n*  HANDLING A COLLECTION OF SOFTWARE OF WHICH THIS IS A PART,         *\n*  ON THE OTHER HAND, IS APPROPRIATE.                                 *\n*                                                                     *\n*                                  BROIDO COMPUTER CONSULTING         *\n*                                  BROIDOJ@GMAIL.COM                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        MAPSP - TSO COMMAND TO PRODUCE STORAGE BOUNDARY MAP FOR      *\n*                MVS/SP (NON-XA).                                     *\n*                                                                     *\n*                SYSLIB: ASM: SYS1.AMODGEN.                           *\n*                        LNK: NONE.                                   *\n*                                                                     *\n*                NOT REENTRANT.                                       *\n*                TESTED THROUGH LEVEL SP 1.3.4.                       *\n*                                                                     *\n*                                  JEFFREY R. BROIDO                  *\n*                                  MHT/WCF-4/NYP-NYC                  *\n*                                  26  JANUARY  1984                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nMAPSP    CSECT\n         REGS\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS.\n         LR    R12,R15             COPY BASE.\n         USING MAPSP,R12           TELL ASSEMBLER.\n         LR    R14,R13             PRESERVE CALLER'S SA PTR.\n         LA    R13,SAVE            POINT TO MY SAVE AREA.\n         ST    R14,SAVE+4          CHAIN ...\n         ST    R13,8(,R13)         ... SAVE AREAS.\n         SPACE 1\n         L     R9,X'10'            POINT TO CVT.\n         USING CVT,R9              TELL ASSEMBLER.\n         L     R8,0(,R9)           POINT TO TCB/ASCB WORDS.\n         L     R8,0(,R8)           POINT TO TCB.\n         L     R8,X'B4'(,R8)       POINT TO JSCB.\n         TM    X'EC'(R8),X'01'     OK TO DO MODESET?\n         BZ    NOAUTH              B IF NOT.\n         MODESET KEY=ZERO\n         ON    AFLG                TURN ON OK-TO-MODESET FLAG.\nNOAUTH   L     R8,CVTGDA           POINT TO GDA.\n         USING GDA,R8              TELL ASSEMBLER.\n         GTSIZE ,                  GET SCREEN SIZE, IF ANY.\n         LTR   R0,R0               IS THIS A PAPER TERMINAL (NO DEPTH)?\n         BZ    HEADOUT             B IF YES.\n         STFSMODE ON,INITIAL=YES\n*        TPUT  CLEAR,L'CLEAR,FULLSCR CLEAR THE DISPLAY SCREEN.\n         TPUT  CLEAR,L'CLEAR,NOEDIT  CLEAR THE DISPLAY SCREEN.\n         STFSMODE OFF\n         ON    GFLG                TURN ON 3X7X FLAG.\nHEADOUT  TPUT  HEAD1,LEN           OUTPUT HEADINGS.\n         TPUT  HEAD2,LEN           OUTPUT UNDERLINES.\n         LA    R3,TABLE            POINT TO TABLE ENTRY.\n         USING TABLED,R3           TELL ASSEMBLER.\nTABLUP   CLI   0(R3),X'00'         END OF TABLE?\n         BE    EXIT                B IF YES.\n         MVC   AREA,TABTITLE       MOVE ENTRY TITLE.\n         L     R15,TABRES          POINT TO DATA RESOLUTION ROUTINE.\n         BALR  R14,R15             FILL-IN TABLE ENTRY.\n         LA    R1,TABSTART         POINT TO AREA START ADDRESS.\n         TM    0(R1),X'80'         IS START ADDRESS PTR NEGATIVE?\n         BO    MISSING             B IF YES.  AREA IS INDEED MISSING.\n         BAL   R14,HEXOUT          CONVERT TO CHARACTER HEX.\n         MVC   START,WORK+2        MOVE START ADDR. CHARACTER HEX.\n         LA    R1,TABEND           POINT TO AREA END ADDRESS.\n         BAL   R14,HEXOUT          CONVERT TO CHARACTER HEX.\n         MVC   END,WORK+2          MOVE END ADDR. CHAR. HEX.\n         L     R1,TABLEN           LOAD AREA LENGTH FROM TABLE.\n         SRL   R1,10               \"DIVIDE\" BY 1K.\n         CVD   R1,WORK             DECIMALIZE IT.\n         MVC   LENGTH,=X'40206B2020206B202120'  MOVE EDIT PATTERN.\n         ED    LENGTH,WORK+4       EDIT LENGTH.\n         ICM   R1,15,TABFULL       LOAD AREA BYTES USED.\n         BNZ   TFE                 B IF NOT ZERO.\n         MVC   FULL,=C'--'         MOVE \"NOT APPLICABLE\" GRAPHIC.\n         B     DETPUT              CONTINUE.\nMISSING  MVC   START,=C'    --  '  MOVE \"MISSING\" GRAPHIC.\n         MVC   END,=C'    --  '    MOVE \"MISSING\" GRAPHIC.\n         MVC   LENGTH,=C'        --'  MOVE \"MISSING\" GRAPHIC.\n         MVC   FULL,=C'--'         MOVE \"MISSING\" GRAPHIC.\n         B     DETPUT              CONTINUE.\nTFE      L     R5,TABLEN           LOAD DIVISOR.\n         MH    R1,=H'100'          MULTIPLY BYTES BY 100.\n         SR    R0,R0               ZERO HIGH ORDER DIVIDEND.\n         DR    R0,R5               GENERATE PERCENT USED.\n         SRL   R5,1                \"DIVIDE\" DIVISOR BY 2.\n         CR    R0,R5               SHALL I ROUND?\n         BL    NOROUND             B IF NOT.\n         LA    R1,1(,R1)           ROUND PERCENTAGE.\nNOROUND  CVD   R1,WORK             DECIMALIZE PERCENT.\n         UNPK  WORK1(3),WORK+6(2)  UNPAKC PERCENT.\n         MVC   FULL,WORK1+1        MOVE PERCENT.\n         OI    FULL+1,C'0'         FIX SIGN.\nDETPUT   TPUT  DETAIL,LEN          OUTPUT DETAIL LINE.\n         LA    R3,TLEN(,R3)        BUMP TO NEXT TABLE ENTRY.\n         B     TABLUP              LOOP.\n         SPACE 1\nEXIT     TF    AFLG                OK TO DO MODESET?\n         BZ    EXIT1               B IF NOT.\n         MODESET KEY=NZERO\nEXIT1    L     R13,SAVE+4          POINT TO CALLER'S SAVE AREA.\n         LM    R14,R12,12(R13)     RELOAD CALLER'S REGISTERS.\n         SR    R15,R15             SET CC OF 0\n         BR    R14                 RETURN TO CALLER.\n         TITLE 'DATA RESOLUTION ROUTINES.'\nNOPRES   BR    R14                 NOOP RESOLUTION ROUTINE.\nPRES     L     R1,PASIZE           LOAD PRIVATE SIZE.\n         ST    R1,TABLEN           SAVE IT IN TABLE.\n         L     R2,PASTRT           LOAD PRIVATE START ADDRESS.\n         ST    R2,TABSTART         SAVE IT IN TABLE.\n         AR    R1,R2               GENERATE ...\n         BCTR  R1,*-*              ... END ADDRESS.\n         ST    R1,TABEND           SAVE IT IN TABLE.\n         BR    R14                 RETURN.\nPLPARES  L     R1,PLPAEND          LOAD END OF PLPA + 1\n         LR    R15,R1              PRESERVE IT.\n         L     R2,CVTLPDIA         POINT TO START OF PLPA.\n         LA    R2,0(,R2)           CLEAR FLAG BYTE.\n         ST    R2,TABSTART         SAVE IN TABLE.\n         ST    R2,LPASTART         SAVE FOR MLPARES.\n         SR    R1,R2               GENERATE LENGTH OF PLPA.\n         ST    R1,TABLEN           SAVE IN TABLE.\n         BCTR  R15,*-*             GENERATE END OF PLPA.\n         ST    R15,TABEND          SAVE IN TABLE.\n         BR    R14                 RETURN.\nMLPARES  L     R1,CVTVPSA          POINT TO SYSGENED PSA.\n         LA    R1,X'FFF'(,R1)      GENERATE START ...\n         LA    R1,1(,R1)           ... OF MLPA AND/OR BLDL.\n         L     R2,LPASTART         POINT TO START OF PLPA.\n         OI    TABSTART,X'80'      TELL TABLE AREA MISSING BY DEFAULT.\n         CR    R1,R2               ANY MLPA AND/OR BLDL?\n         BER   R14                 RETURN IF NOT.\n         ST    R1,TABSTART         SAVE START ADDRESS IN TABLE.\n         LR    R15,R2              PRESERVE END ADDRESS.\n         BCTR  R2,*-*              GENERATE END ADDRESS.\n         ST    R2,TABEND           SAVE IN TABLE.\n         SR    R15,R1              GENERATE LENGTH.\n         ST    R15,TABLEN          SAVE IN TABLE.\n         BR    R14                 RETURN.\nSPSARES  L     R1,CVTVPSA          POINT TO SYSGENED PSA.\n         ST    R1,TABSTART         SAVE IN TABLE.\n         LA    R1,X'FFF'(,R1)      GENERATE END ADDRESS (+4K-1).\n         ST    R1,TABEND           SAVE IN TABLE.\n         BR    R14                 RETURN.\nCRES     L     R15,CSAPQEP         POINT TO CSA PQE.\n         USING PQESECT,R15         (TELL ASSEMBLER).\n         L     R1,PQEREGN          POINT TO START OF CSA REGION.\n         ST    R1,TABSTART         SAVE IN TABLE.\n         L     R0,PQESIZE          LOAD LENGTH OF CSA REGION.\n         ST    R0,TABLEN           SAVE IN TABLE.\n         AR    R1,R0               GENERATE ...\n         BCTR  R1,*-*              ... END ADDRESS.\n         ST    R1,TABEND           SAVE IN TABLE.\n         TF    AFLG                OK TO LOOK AT FETCH PROT. AREAS?\n         BZR   R14                 B IF NOT.  RETURN.\n         L     R4,PQEFFBQE         POINT TO FIRST FBQE.\n         USING FBQESECT,R4         (TELL ASSEMBLER).\nCFBQELUP CR    R15,R4              FBQE PTR POINT BACK TO PQE?\n         BE    CSUB                B IF YES.  END.\n         S     R0,SIZE             SUBTRACT FREE BLOCK SIZE.\n         L     R4,0(,R4)           POINT TO NEXT FBQE.\n         B     CFBQELUP            LOOP.\nCSUB     L     R15,CSASPQEP        POINT TO LAST CSA SPQE.\n         USING SPQESECT,R15        (TELL ASSEMBLER)\nCSPQELUP ICM   R4,7,SPDQEPTR+1     POINT TO FIRST DQE FOR THIS SUBPOOL.\n         USING DQESECT,R4          (TELL ASSEMBLER)\n         BZ    CSPQEBMP            B IF NO DQES FOR THIS SUBPOOL.\nCDQELUP  CLC   DQFQEPTR,=A(0)      THIS DQE DESCRIBE STORAGE?\n         BE    CDQEBUMP            B IF NOT.\n         L     R10,DQFQEPTR        POINT TO FIRST FQE.\n         USING FQESECT,R10         TELL ASSEMBLER.\nCFQELUP  LA    R10,0(,R10)         CLEAR HIGH BYTE.\n         LTR   R10,R10             ANY MORE FREE AREAS?\n         BZ    CDQEBUMP            B IF NOT.\n         S     R0,FQELNTH          DECREMENT USED SPACE ACCUM.\n         L     R10,FQEPTR          BUMP TO NEXT FQE.\n         B     CFQELUP             LOOP.\nCDQEBUMP ICM   R4,7,DQEPTR+1       BUMP TO NEXT DQE.\n         BNZ   CDQELUP             LOOP.\nCSPQEBMP TM    SPQEFLGS,LASTSPQE   THIS THE LAST SPQE?\n         BO    CRESFREE            B IF YES. CALCULATE FREE SPACE.\n         L     R15,SPQEAD          POINT TO PREVIOUS SPQE.\n         B     CSPQELUP            LOOP.\nCRESFREE ST    R0,TABFULL          SAVE CSA USED LENGTH IN TABLE.\n         DROP  R15,R4,R10\n         BR    R14                 RETURN.\nSRES     L     R15,SQASPQEP        POINT TO SQE (SP 245) SPQE.\n         USING SPQESECT,R15        (TELL ASSEMBLER)\n         L     R4,SPDQEPTR         POINT TO ONLY DQE FOR THIS SUBPOOL.\n         USING DQESECT,R4          (TELL ASSEMBLER)\n         L     R1,DQEBLKAD         LOAD START ADDRESS OF SQA.\n         ST    R1,TABSTART         SAVE IN TABLE.\n         ST    R1,PLPAEND          SAVE FOR PLPARES ROUTINE.\n         L     R0,DQELNTH          LOAD LENGTH OF SQA.\n         ST    R0,TABLEN           SAVE IN TABLE.\n         AR    R1,R0               GENERATE ...\n         BCTR  R1,*-*              ... END ADDRESS.\n         ST    R1,TABEND           SAVE IN TABLE.\n         L     R10,DQFQEPTR        POINT TO FIRST FQE.\n         USING FQESECT,R10         TELL ASSEMBLER.\nSFQELUP  LA    R10,0(,R10)         CLEAR HIGH BYTE.\n         LTR   R10,R10             ANY MORE FREE AREAS?\n         BZ    SRESFREE            B IF NOT.\n         S     R0,FQELNTH          DECREMENT USED SPACE ACCUM.\n         L     R10,FQEPTR          BUMP TO NEXT FQE.\n         B     SFQELUP             LOOP.\nSRESFREE ST    R0,TABFULL          SAVE SQA USED LENGTH IN TABLE.\n         DROP  R15,R4,R10\n         BR    R14                 RETURN.\nVRRES    L     R15,VRPQEP          POINT TO V=R PQE.\n         USING PQESECT,R15         (TELL ASSEMBLER).\n         L     R1,PQEREGN          POINT TO START OF V=R REGION.\n         ST    R1,TABSTART         SAVE IN TABLE.\n         L     R2,PQESIZE          LOAD LENGTH OF V=R REGION.\n         ST    R2,TABLEN           SAVE IN TABLE.\n         AR    R1,R2               GENERATE ...\n         BCTR  R1,*-*              ... END ADDRESS.\n         ST    R1,TABEND           SAVE IN TABLE.\n         DROP  R15\n         BR    R14                 RETURN.\nNUCRES   L     R1,CVTNUCB          POINT PAST END OF NUC.\n         BCTR  R1,*-*              GENERATE END OF NUC.\n         ST    R1,TABEND           SAVE IN TABLE.\n         SH    R2,=H'4095'         GENERATE NUC LENGTH.\n         ST    R2,TABLEN           SAVE IN TABLE.\n         BR    R14                 RETURN.\n         TITLE 'SUBROUTINE(S).'\n***********************************************************************\n*                                                                     *\n*    HEXOUT - SUBROUTINE TO GENERATE CHARACTER CODED HEXADECIMAL      *\n*        FOR OUTPUT.  R1 POINTS TO THE FULLWORD TO BE TRANSLATED.     *\n*        FIND OUTPUT CHARACTER RESULT IN DOUBLEWORD \"WORK.\"           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nHEXOUT   MVO   WORK1,0(4,R1)       GENERATE PSEUDO PACKED VALUE.\n         UNPK  WORK,WORK1+3(5)     SEPARATE NIBBLES.\n         NC    WORK,=X'0F0F0F0F0F0F0F0F' ELIMINATE ZONES.\n         TR    WORK,=C'0123456789ABCDEF' TRANSLATE TO PRINTABLE HEX.\n         BR    R14                 RETURN TO CALLER.\n         TITLE 'DATA AREAS.'\nSAVE     DS    9D                  SAVE AREA.\nWORK     DS    D                   WORK DOUBLEWORD.\nWORK1    DS    D                   WORK DOUBLEWORD.\nPLPAEND  DC    A(0)                END OF PLPA + 1 (SAVED BY SRES).\nLPASTART DC    A(0)                START OF PLPA.\n         SPACE 1\nFLAG     DC    X'00'               VARIOUS FLAG(S).\nGFLG     EQU   FLAG,B'10000000'    USER AT DISPLAY TERMINAL.\nAFLG     EQU   FLAG,B'01000000'    OK TO DO MODESET.\n         SPACE 1\n*CLEAR   DC    X'F31140403C40400013' CLEAR 3X7X TERMINAL.\nCLEAR    DC    X'F5F313'           CLEAR 3X7X TERMINAL.\n         SPACE 1\nHEAD1    DC    C'AREA          '\nHEAD1A   DC    C'START    '\nHEAD1B   DC    C'END      '\nHEAD1C   DC    C'LENGTH (K)  '\nHEAD1D   DC    C'%FULL'\nLEN      EQU   *-HEAD1\nHEAD2    DC    CL(LEN)' '\n         ORG   HEAD2\nHEAD2A   DC    C'------------'\n         ORG   HEAD2+(HEAD1A-HEAD1)\nHEAD2B   DC    C'------'\n         ORG   HEAD2+(HEAD1B-HEAD1)\nHEAD2C   DC    C'------'\n         ORG   HEAD2+(HEAD1C-HEAD1)\nHEAD2D   DC    C'----------'\n         ORG   HEAD2+(HEAD1D-HEAD1)\nHEAD2E   DC    C'-------'\n         ORG\nDETAIL   DC    CL(LEN)' '\n         ORG   DETAIL\nAREA     EQU   *,12\n         ORG   DETAIL+(HEAD1A-HEAD1)\nSTART    EQU   *,8\n         ORG   DETAIL+(HEAD1B-HEAD1)\nEND      EQU   *,8\n         ORG   DETAIL+(HEAD1C-HEAD1)\nLENGTH   EQU   *,10\n         ORG   DETAIL+(HEAD1D-HEAD1)\nFULL     EQU   *,2\n         ORG\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*    THE FOLLOWING IS A TABLE OF STORAGE AREAS TO MAP.  THE FIRST     *\n*        12 BYTES OF EACH ENTRY IS THE AREA TITLE, THE NEXT WORD      *\n*        IS THE AREA START ADDRESS, THE NEXT WORD IS THE LENGTH,      *\n*        THE NEXT WORD IS THE END ADDRESS, THE NEXT WORD IS THE       *\n*        NUMBER OF BYTES USED OR 0 AND THE LAST WORD IS THE DATA      *\n*        RESOLUTION ROUTINE ADDRESS.                                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nTABLE    DS    0A                  START OF TABLE OF AREAS.\n         DC    CL12'SQA',A(0),A(0),A(0),A(0),A(SRES)\n         DC    CL12'PLPA',A(0),A(0),A(0),A(0),A(PLPARES)\n*        DC    CL12'FLPA',A(CVTFLPAS-CVTVSTGX),A(0),A(0),A(0),A(CXRES)\n         DC    CL12'MLPA/BLDL',A(0),A(0),A(0),A(0),A(MLPARES)\n         DC    CL12'SYSGEN PSA',A(0),A(4096),A(0),A(0),A(SPSARES)\n         DC    CL12'CSA',A(0),A(0),A(0),A(0),A(CRES)\n         DC    CL12'V=R (IF ANY)',A(0),A(0),A(0),A(0),A(VRRES)\n         DC    CL12'PRIVATE',A(4096),A(0),A(0),A(0),A(PRES)\n         DC    CL12'NUCLEUS',A(4096),A(0),A(0),A(0),A(NUCRES)\n         DC    CL12'PSA',A(0),A(4096),A(4095),A(0),A(NOPRES)\n         DC    X'00'               END OF TABLE.\n         TITLE 'MAPSP - DSECTS.'\n         CVT   DSECT=YES\n         IHAGDA\n         IHAPQE\n         IHASPQE\n         IHADQE\n         IHAFBQE\n         SPACE 1\n*        IHAFQE                    MAPPING MACRO NOT ON SYSTEM.\nFQESECT  DSECT                     FREE QUEUE ELEMENT.\nFQETYPE  DS    AL1                 FLAG BYTE.\nFQERGNFL EQU   B'10000000'         REGION FLAG.\nFQECPB   EQU   B'01000000'         FREE AREA CROSSES PAGE BOUNDARY.\n         ORG   FQETYPE\nFQEPTR   DS    A                   PTR TO NEXT LOWER FQE.\nFQELNTH  DS    A                   NUMBER OF BYTES IN FREE SPACE.\nFQAREA   DS    A                   HIGH ADDRESS OF FREE SPACE.\nFQERSVD  DS    A                   YOU KNOW WHAT.\n         SPACE 1\nTABLED   DSECT                     TABLE ENTRY MAPPING DSECT.\nTABTITLE DS    CL12                TABLE ENTRY TITLE.\nTABSTART DS    A                   START ADDRESS OF ENTRY'S AREA.\nTABLEN   DS    A                   LENGTH OF ENTRY'S AREA.\nTABEND   DS    A                   END ADDRESS OF ENTRY'S AREA.\nTABFULL  DS    A                   NUMBER OF BYTES USED.\nTABRES   DS    A                   ADDRESS OF RESOLUTION ROUTINE.\nTLEN     EQU   *-TABLED            LENGTH OF TABLE ENTRY.\n         END   MAPSP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAPXA": {"ttr": 5642, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x17\\x00\\x986O\\x01\\x14\\x16\\x7f\\x02\\x14\\x02\\xa2\\x018\\x01\\x82\\xd7\\xe4\\xe3\\xd3\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "1998-12-30T00:00:00", "modifydate": "2014-06-16T02:14:17", "lines": 674, "newlines": 312, "modlines": 386, "user": "PUTLINE"}, "text": "MAPXA    TITLE 'MAPXA - TSO COMMAND TO PROVIDE MVS/XA STORAGE LAYOUT MA+\n               P.'\n*%A AMODGEN PPLINK ADATA NOTEST\n*L ALIAS MAPSP\n         MACRO\n&NAME    ON    &FLAG\n.*\n         LCLC  &L\n&L       SETC  'L'''\n&NAME    OI    &FLAG,&L.&FLAG              (TURN ON BIT FLAG)\n         MEND\n         MACRO\n&NAME    OFF   &FLAG\n.*\n         LCLC  &L\n&L       SETC  'L'''\n&NAME    NI    &FLAG,255-&L.&FLAG          (TURN OFF BIT FLAG)\n         MEND\n* ------------------------------------------------------------------- *\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        MAPXA - TSO COMMAND TO PRODUCE STORAGE BOUNDARY MAP FOR      *\n*                MVS/XA, ESA, OS/390.                                 *\n*                                                                     *\n*                SYSLIB: ASM: SYS1.MODGEN.                            *\n*                        LNK: NONE.                                   *\n*                                                                     *\n*                NOT REENTRANT.                                       *\n*                TESTED THROUGH LEVEL Z/OS 2.1   (SBG)                *\n*                                                                     *\n*                                  JEFFREY R. BROIDO                  *\n*                                  MHT/WCF-4/NYP-NYC                  *\n*                                  26  JANUARY  1984                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nMAPXA    CSECT\nMAPXA    RMODE 24                  RESIDE BELOW THE LINE.\nMAPXA    AMODE 31                  USE 31 BIT ADDRESSING.\n         YREGS\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS.\n         LR    R12,R15             COPY BASE.\n         USING MAPXA,R12           TELL ASSEMBLER.\n         LR    R14,R13             PRESERVE CALLER'S SA PTR.\n         LA    R13,SAVE            POINT TO MY SAVE AREA.\n         ST    R14,SAVE+4          CHAIN ...\n         ST    R13,8(,R13)         ... SAVE AREAS.\n         SPACE 1\n         L     R9,X'10'            POINT TO CVT.\n         USING CVT,R9              TELL ASSEMBLER.\n         L     R8,CVTGDA           POINT TO GDA.\n         USING GDA,R8              TELL ASSEMBLER.\n         L     R7,CVTSMEXT         POINT TO CVT EXTENSION.\n         USING CVTVSTGX,R7         TELL ASSEMBLER.\n         GTSIZE ,                  GET SCREEN SIZE, IF ANY.\n         LTR   R0,R0               IS THIS A PAPER TERMINAL (NO DEPTH)?\n         BZ    HEADOUT             B IF YES.\n         STFSMODE ON,INITIAL=YES\n*        TPUT  CLEAR,L'CLEAR,FULLSCR CLEAR THE DISPLAY SCREEN.\n*        TPUT  CLEAR,L'CLEAR,NOEDIT  CLEAR THE DISPLAY SCREEN.\n         STFSMODE OFF\n         ON    GFLG                TURN ON 3X7X FLAG.\nHEADOUT  APUT  HEAD1,LEN           OUTPUT HEADINGS.\n         APUT  HEAD2,LEN           OUTPUT UNDERLINES.\n         LA    R3,TABLE            POINT TO TABLE ENTRY.\n         USING TABLED,R3           TELL ASSEMBLER.\nTABLUP   CLI   0(R3),X'00'         END OF TABLE?\n         BE    EXIT                B IF YES.\n         MVC   AREA,TABTITLE       MOVE ENTRY TITLE.\n         L     R15,TABRES          POINT TO DATA RESOLUTION ROUTINE.\n         BALR  R14,R15             FILL-IN TABLE ENTRY.\n         LA    R1,TABSTART         POINT TO AREA START ADDRESS.\n         TM    0(R1),X'80'         BUT IS AREA MISSING?\n         BO    MISSING             B IF AREA IS INDEED MISSING.\n         BAL   R14,HEXOUT          CONVERT TO CHARACTER HEX.\n         MVC   START,WORK          MOVE START ADDR. CHARACTER HEX.\n         LA    R1,TABEND           POINT TO AREA END ADDRESS.\n         BAL   R14,HEXOUT          CONVERT TO CHARACTER HEX.\n         MVC   END,WORK            MOVE END ADDR. CHAR. HEX.\n         L     R1,TABLEN           LOAD AREA LENGTH FROM TABLE.\n         SRL   R1,10               \"DIVIDE\" BY 1K.\n         CVD   R1,WORK             DECIMALIZE IT.\n         MVC   LENGTH,=X'40206B2020206B202120'  MOVE EDIT PATTERN.\n         ED    LENGTH,WORK+4       EDIT LENGTH.\n         ICM   R1,15,TABFULL       LOAD AREA BYTES USED.\n         BNZ   TFE                 B IF NOT ZERO.\n         MVC   FULL,=C'--'         MOVE \"NOT APPLICABLE\" GRAPHIC.\n         B     DETPUT              CONTINUE.\nMISSING  MVC   START,=C'      --'  MOVE \"MISSING\" GRAPHIC.\n         MVC   END,=C'      --'    MOVE \"MISSING\" GRAPHIC.\n         MVC   LENGTH,=C'        --'  MOVE \"MISSING\" GRAPHIC.\n         MVC   FULL,=C'--'         MOVE \"MISSING\" GRAPHIC.\n         B     DETPUT              CONTINUE.\nTFE      L     R5,TABLEN           LOAD DIVISOR.\n         MH    R1,=H'100'          MULTIPLY BYTES BY 100.\n         SR    R0,R0               ZERO HIGH ORDER DIVIDEND.\n         DR    R0,R5               GENERATE PERCENT USED.\n         SRL   R5,1                \"DIVIDE\" DIVISOR BY 2.\n         CR    R0,R5               SHALL I ROUND?\n         BL    NOROUND             B IF NOT.\n         LA    R1,1(,R1)           ROUND PERCENTAGE.\nNOROUND  CVD   R1,WORK             DECIMALIZE PERCENT.\n         UNPK  WORK1(3),WORK+6(2)  UNPAKC PERCENT.\n         MVC   FULL,WORK1+1        MOVE PERCENT.\n         OI    FULL+1,C'0'         FIX SIGN.\nDETPUT   APUT  DETAIL,LEN          OUTPUT DETAIL LINE.\n         LA    R3,TLEN(,R3)        BUMP TO NEXT TABLE ENTRY.\n         B     TABLUP              LOOP.\n         SPACE 1\nEXIT     L     R13,SAVE+4          POINT TO CALLER'S SAVE AREA.\n         LM    R14,R12,12(R13)     RELOAD CALLER'S REGISTERS.\n         SR    R15,R15             SET CC OF 0\n         BR    R14                 RETURN TO CALLER.\n         TITLE 'DATA RESOLUTION ROUTINES.'\nNOPRES   BR    R14                 NOOP RESOLUTION ROUTINE.\nPRES     L     R1,GDAPVTSZ         LOAD PRIVATE SIZE.\n         BCTR  R1,*-*              GENERATE TRUE END ADDRESS.\n         ST    R1,TABEND           SAVE IN TABLE.\n         S     R1,TABSTART         GENERATE ...\n         LA    R1,1(,R1)           ... TRUE LENGTH.\n         ST    R1,TABLEN           SAVE IN TABLE.\n         BR    R14                 RETURN.\nEPRES    L     R1,GDAEPVT          LOAD START OF E-PRIVATE.\n         ST    R1,TABSTART         SAVE IN TABLE.\n         L     R2,GDAEPVTS         LOAD LENGTH OF E-PRIVATE\n         ST    R2,TABLEN           SAVE IN TABLE.\n         AR    R1,R2               GENERATE ...\n         BCTR  R1,*-*              ... E-PRIVATE END ADDRESS.\n         ST    R1,TABEND           SAVE END ADDRESS IN TABLE.\n         BR    R14                 RETURN.\nCRES     L     R1,GDACSA           LOAD START OF CSA.\n         ST    R1,TABSTART         SAVE IN TABLE.\n         L     R2,GDACSASZ         LOAD LENGTH OF CSA.\n         ST    R2,TABLEN           SAVE IN TABLE.\n         AR    R1,R2               GENERATE ...\n         BCTR  R1,*-*              ... CSA END ADDRESS.\n         ST    R1,TABEND           SAVE IN TABLE.\n         S     R2,GDACSARE         GENERATE BYTES USED.\n         ST    R2,TABFULL          SAVE IN TABLE.\n         BR    R14                 RETURN.\nECRES    L     R1,GDAECSA          LOAD START OF E-CSA.\n         ST    R1,TABSTART         SAVE IN TABLE.\n         L     R2,GDAECSAS         LOAD LENGTH OF E-CSA.\n         ST    R2,TABLEN           SAVE IN TABLE.\n         AR    R1,R2               GENERATE ...\n         BCTR  R1,*-*              ... E-CSA END ADDRESS.\n         ST    R1,TABEND           SAVE IN TABLE.\n         BR    R14                 RETURN.\nSRES     L     R1,GDASQA           LOAD START OF SQA.\n         ST    R1,TABSTART         SAVE IN TABLE.\n         L     R2,GDASQASZ         LOAD LENGTH OF SQA.\n         ST    R2,TABLEN           SAVE IN TABLE.\n         AR    R1,R2               GENERATE ...\n         BCTR  R1,*-*              ... SQA END ADDRESS.\n         ST    R1,TABEND           SAVE IN TABLE.\n         BR    R14                 RETURN.\nESRES    L     R1,GDAESQA          LOAD START OF E-SQA.\n         ST    R1,TABSTART         SAVE IN TABLE.\n         L     R2,GDAESQAS         LOAD LENGTH OF E-SQA.\n         ST    R2,TABLEN           SAVE IN TABLE.\n         AR    R1,R2               GENERATE ...\n         BCTR  R1,*-*              ... E-SQA END ADDRESS.\n         ST    R1,TABEND           SAVE IN TABLE.\n         BR    R14                 RETURN.\nNRORES   DS    0H\n         STM   R14,R1,SAVEAP       APUT USES R14 AND R15.\n         APUT  LINE,LINEL          HERE I DRAW THE LINE.\n         LM    R14,R1,SAVEAP       RESTORE R14, R15 ETC.\n         L     R1,CVTRONS          LOAD START OF NUC R/O AREA.\n         ST    R1,TABSTART         SAVE IN TABLE.\n         L     R2,TABEND           LOAD X'00FFFFFF'.\n         SR    R2,R1               GENERATE ...\n         LA    R2,1(,R2)           ... LENGTH.\n         ST    R2,TABLEN           SAVE IT IN TABLE.\n         BR    R14                 RETURN.\nENRORES  L     R1,TABSTART         LOAD X'01000000'.\n         L     R2,CVTRONE          LOAD END OF NUC R/O AREA.\n         O     R2,=A(X'00000FFF')  FORCE ALIGNMENT TO END OF PAGE.\n         ST    R2,TABEND           SAVE IN TABLE.\n         SR    R2,R1               GENERATE ...\n         LA    R2,1(,R2)           ... LENGTH.\n         ST    R2,TABLEN           SAVE IN TABLE.\n         BR    R14                 RETURN.\nVRRES    L     R1,GDAVR            LOAD START OF V=R AREA.\n         ST    R1,TABSTART         SAVE IN TABLE.\n         L     R2,GDAVRSZ          LOAD LENGTH OF V=R AREA.\n         ST    R2,TABLEN           SAVE LENGTH IN TABLE.\n         AR    R1,R2               GENERATE ...\n         BCTR  R1,*-*              ... V=R END ADDRESS.\n         ST    R1,TABEND           SAVE IN TABLE.\n         BR    R14                 RETURN.\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*    THE FOLLOWING IS A GENERAL DATA RESOLUTION ROUTINE FOR           *\n*        STARTING-ENDING ADDRESS PAIRS IN THE VCT VS ADDRESS          *\n*        EXTENSION.  THE TABLE CONTAINS THE ABSOLUTE DISPLACEMENT     *\n*        IN THE CVT EXTENSION TO THE STARTING ADDRESS RATHER THAN     *\n*        THE STARTING ADDRESS ITSELF; THE ENDING ADDRESS IS           *\n*        PRESUMED TO FOLLOW IN THE CVT EXTENSION.                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nCXRES    LR    R1,R7               POINT TO THE CVT EXTENSION.\n         A     R1,TABSTART         POINT TO THE STARTING ADDRESS.\n         ICM   R2,15,4(R1)         LOAD ENDING ADDRESS.\n         BNP   CXNA                B IF THIS AREA IS MISSING.\n         L     R1,0(,R1)           LOAD STARTING ADDRESS.\n         ST    R1,TABSTART         SAVE IT IN TABLE.\n         O     R2,=A(X'00000FFF')  FORCE END OF PAGE ALIGNMENT TO ...\n*                                  ... ACCOUNT FOR WASTE AT CHANGE ...\n*                                  ... OF PROTECTION BOUNDARIES.\n         ST    R2,TABEND           SAVE ENDING ADDRESS IN TABLE.\n         SR    R2,R1               GENERATE ...\n         LA    R2,1(,R2)           LENGTH.\n         ST    R2,TABLEN           SAVE IN TABLE.\n         BR    R14                 RETURN.\nCXNA     LNR   R1,R1               MAKE R1 NEGATIVE.\n         ST    R1,TABSTART         SAVE IN TABLE START POSITION.\n         BR    R14                 RETURN.\n         TITLE 'SUBROUTINE(S).'\n***********************************************************************\n*                                                                     *\n*    HEXOUT - SUBROUTINE TO GENERATE CHARACTER CODED HEXADECIMAL      *\n*        FOR OUTPUT.  R1 POINTS TO THE FULLWORD TO BE TRANSLATED.     *\n*        FIND OUTPUT CHARACTER RESULT IN DOUBLEWORD \"WORK.\"           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nHEXOUT   MVO   WORK1,0(4,R1)       GENERATE PSEUDO PACKED VALUE.\n         UNPK  WORK,WORK1+3(5)     SEPARATE NIBBLES.\n         NC    WORK,=X'0F0F0F0F0F0F0F0F' ELIMINATE ZONES.\n         TR    WORK,=C'0123456789ABCDEF' TRANSLATE TO PRINTABLE HEX.\n         BR    R14                 RETURN TO CALLER.\n         TITLE 'DATA AREAS.'\nSAVE     DS    9D                  SAVE AREA.\nWORK     DS    D                   WORK DOUBLEWORD.\nWORK1    DS    D                   WORK DOUBLEWORD.\n         SPACE 1\nFLAG     DC    X'00'               VARIOUS FLAG(S).\nGFLG     EQU   FLAG,B'10000000'    USER AT DISPLAY TERMINAL.\n         SPACE 1\n*CLEAR   DC    X'F31140403C40400013' CLEAR 3X7X TERMINAL.\nCLEAR    DC    X'F5F313'           CLEAR 3X7X TERMINAL.\n         SPACE 1\nHEAD1    DC    C'Area          '\nHEAD1A   DC    C'Start      '\nHEAD1B   DC    C'End        '\nHEAD1C   DC    C'Length (K)  '\nHEAD1D   DC    C'%Full'\nLEN      EQU   *-HEAD1\nHEAD2    DC    CL(LEN)' '\n         ORG   HEAD2\nHEAD2A   DC    C'------------'\n         ORG   HEAD2+(HEAD1A-HEAD1)\nHEAD2B   DC    C'--------'\n         ORG   HEAD2+(HEAD1B-HEAD1)\nHEAD2C   DC    C'--------'\n         ORG   HEAD2+(HEAD1C-HEAD1)\nHEAD2D   DC    C'----------'\n         ORG   HEAD2+(HEAD1D-HEAD1)\nHEAD2E   DC    C'-------'\n         ORG\nDETAIL   DC    CL(LEN)' '\n         ORG   DETAIL\nAREA     EQU   *,12\n         ORG   DETAIL+(HEAD1A-HEAD1)\nSTART    EQU   *,8\n         ORG   DETAIL+(HEAD1B-HEAD1)\nEND      EQU   *,8\n         ORG   DETAIL+(HEAD1C-HEAD1)\nLENGTH   EQU   *,10\n         ORG   DETAIL+(HEAD1D-HEAD1)\nFULL     EQU   *,2\n         ORG\n*LINE     DC    (LEN)C'-',C'   The Line.'\nLINE     DC    C'-----------------------------------------------------',\n               ,C'   The Line.'\nLINEL    EQU   *-LINE\nSAVEAP   DS    4F\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*    THE FOLLOWING IS A TABLE OF STORAGE AREAS TO MAP.  THE FIRST     *\n*        12 BYTES OF EACH ENTRY IS THE AREA TITLE, THE NEXT WORD      *\n*        IS THE AREA START ADDRESS, THE NEXT WORD IS THE LENGTH,      *\n*        THE NEXT WORD IS THE END ADDRESS, THE NEXT WORD IS THE       *\n*        NUMBER OF BYTES USED OR 0 AND THE LAST WORD IS THE DATA      *\n*        RESOLUTION ROUTINE ADDRESS.  IN THE CASE OF RESOLUTION       *\n*        ROUTINE CXRES, THE START ADDRESS IS REPLACED BY THE          *\n*        ABSOLUTE DISPLACEMENT TO THE START ADDRESS IN THE CVT VS     *\n*        EXTENSION.                                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nTABLE    DS    0A                  START OF TABLE OF AREAS.\n         DC    CL12'E-Private',A(0),A(0),A(0),A(0),A(EPRES)\n         DC    CL12'E-CSA',A(0),A(0),A(0),A(0),A(ECRES)\n         DC    CL12'E-MLPA'\n         DC    A(CVTEMLPS-CVTVSTGX),A(0),A(0),A(0),A(CXRES)\n         DC    CL12'E-FLPA'\n         DC    A(CVTEFLPS-CVTVSTGX),A(0),A(0),A(0),A(CXRES)\n         DC    CL12'E-PLPA'\n         DC    A(CVTEPLPS-CVTVSTGX),A(0),A(0),A(0),A(CXRES)\n         DC    CL12'E-SQA',A(0),A(0),A(0),A(0),A(ESRES)\n         DC    CL12'E-Nuc. (RW)'\n         DC    A(CVTERWNS-CVTVSTGX),A(0),A(0),A(0),A(CXRES)\n         DC    CL12'E-Nuc. (RO)'\n         DC    X'01000000',A(0),A(0),A(0),A(ENRORES)\n         DC    CL12'Nucleus (RO)'\n         DC    A(0),A(0),X'00FFFFFF',A(0),A(NRORES)\n         DC    CL12'Nucleus (RW)'\n         DC    A(CVTRWNS-CVTVSTGX),A(0),A(0),A(0),A(CXRES)\n         DC    CL12'SQA',A(0),A(0),A(0),A(0),A(SRES)\n         DC    CL12'PLPA',A(CVTPLPAS-CVTVSTGX),A(0),A(0),A(0),A(CXRES)\n         DC    CL12'FLPA',A(CVTFLPAS-CVTVSTGX),A(0),A(0),A(0),A(CXRES)\n         DC    CL12'MLPA',A(CVTMLPAS-CVTVSTGX),A(0),A(0),A(0),A(CXRES)\n         DC    CL12'CSA',A(0),A(0),A(0),A(0),A(CRES)\n         DC    CL12'Private',A(4096),A(0),A(0),A(0),A(PRES)\n         DC    CL12'V=R (if any)',A(0),A(0),A(0),A(0),A(VRRES)\n         DC    CL12'PSA',A(0),A(4096),A(4095),A(0),A(NOPRES)\n         DC    X'00'               END OF TABLE.\n         TITLE 'MAPXA - DSECTS.'\n         CVT   DSECT=YES\n         IHAGDA\nTABLED   DSECT                     TABLE ENTRY MAPPING DSECT.\nTABTITLE DS    CL12                TABLE ENTRY TITLE.\nTABSTART DS    A                   START ADDRESS OF ENTRY'S AREA.\nTABLEN   DS    A                   LENGTH OF ENTRY'S AREA.\nTABEND   DS    A                   END ADDRESS OF ENTRY'S AREA.\nTABFULL  DS    A                   NUMBER OF BYTES USED.\nTABRES   DS    A                   ADDRESS OF RESOLUTION ROUTINE.\nTLEN     EQU   *-TABLED            LENGTH OF TABLE ENTRY.\n         END   MAPXA\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUEMNTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   255                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         EJECT\n         IHAPSA   LIST=YES                                     HD APR88\n         EJECT                                                 HD APR88\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   14,12,12(13)       SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES            RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    1,8(13)            OUR SAVE AREA POINTER\n         ST    13,4(1)            POINTER TO CALLERS SAVE AREA\n         LR    13,1               @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(R13)         POINT TO CALLERS RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 ASSUME BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 ASSUME BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(RML)               MESSAGE LENGTH\n         STH   R15,PUTLEN                 PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    2,R13                    @OUR SAVE AREA\n         LR    3,R15                    SAVE RETURN CODE\n         L     R13,4(R13)               @CALLERS SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,3                    RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END   EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAPXA$": {"ttr": 5898, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x13\\x01\\x055O\\x01\\x14\\x04\\x7f\\x00I\\x00\\x1c\\x00\\x1d\\x00\\x00\\xc1\\xe2\\xd4\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2005-12-20T00:00:00", "modifydate": "2014-02-16T00:49:13", "lines": 28, "newlines": 29, "modlines": 0, "user": "ASMJCL"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.B.ASM\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(MAPXA)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,9),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(1)\n ENTRY   MAPXA\n NAME    MAPXA(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MAPXA01": {"ttr": 6145, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00C\\x00\\x986O\\x01\\x14\\x16\\x7f\\x02\\x14\\x01H\\x018\\x00\"\\xe3\\xd7\\xe4\\xe3@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1998-12-30T00:00:00", "modifydate": "2014-06-16T02:14:43", "lines": 328, "newlines": 312, "modlines": 34, "user": "TPUT"}, "text": "MAPXA    TITLE 'MAPXA - TSO COMMAND TO PROVIDE MVS/XA STORAGE LAYOUT MA+\n               P.'\n*%A AMODGEN PPLINK ADATA NOTEST\n*L ALIAS MAPSP\n         MACRO\n&NAME    ON    &FLAG\n.*\n         LCLC  &L\n&L       SETC  'L'''\n&NAME    OI    &FLAG,&L.&FLAG              (TURN ON BIT FLAG)\n         MEND\n         MACRO\n&NAME    OFF   &FLAG\n.*\n         LCLC  &L\n&L       SETC  'L'''\n&NAME    NI    &FLAG,255-&L.&FLAG          (TURN OFF BIT FLAG)\n         MEND\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        MAPXA - TSO COMMAND TO PRODUCE STORAGE BOUNDARY MAP FOR      *\n*                MVS/XA, ESA, OS/390.                                 *\n*                                                                     *\n*                SYSLIB: ASM: SYS1.AMODGEN.                           *\n*                        LNK: NONE.                                   *\n*                                                                     *\n*                NOT REENTRANT.                                       *\n*                TESTED THROUGH LEVEL Z/OS 2.1    (SBG)               *\n*                                                                     *\n*                                  JEFFREY R. BROIDO                  *\n*                                  MHT/WCF-4/NYP-NYC                  *\n*                                  26  JANUARY  1984                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nMAPXA    CSECT\nMAPXA    RMODE 24                  RESIDE BELOW THE LINE.\nMAPXA    AMODE 31                  USE 31 BIT ADDRESSING.\n         YREGS\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS.\n         LR    R12,R15             COPY BASE.\n         USING MAPXA,R12           TELL ASSEMBLER.\n         LR    R14,R13             PRESERVE CALLER'S SA PTR.\n         LA    R13,SAVE            POINT TO MY SAVE AREA.\n         ST    R14,SAVE+4          CHAIN ...\n         ST    R13,8(,R13)         ... SAVE AREAS.\n         SPACE 1\n         L     R9,X'10'            POINT TO CVT.\n         USING CVT,R9              TELL ASSEMBLER.\n         L     R8,CVTGDA           POINT TO GDA.\n         USING GDA,R8              TELL ASSEMBLER.\n         L     R7,CVTSMEXT         POINT TO CVT EXTENSION.\n         USING CVTVSTGX,R7         TELL ASSEMBLER.\n         GTSIZE ,                  GET SCREEN SIZE, IF ANY.\n         LTR   R0,R0               IS THIS A PAPER TERMINAL (NO DEPTH)?\n         BZ    HEADOUT             B IF YES.\n         STFSMODE ON,INITIAL=YES\n*        TPUT  CLEAR,L'CLEAR,FULLSCR CLEAR THE DISPLAY SCREEN.\n         TPUT  CLEAR,L'CLEAR,NOEDIT  CLEAR THE DISPLAY SCREEN.\n         STFSMODE OFF\n         ON    GFLG                TURN ON 3X7X FLAG.\nHEADOUT  TPUT  HEAD1,LEN           OUTPUT HEADINGS.\n         TPUT  HEAD2,LEN           OUTPUT UNDERLINES.\n         LA    R3,TABLE            POINT TO TABLE ENTRY.\n         USING TABLED,R3           TELL ASSEMBLER.\nTABLUP   CLI   0(R3),X'00'         END OF TABLE?\n         BE    EXIT                B IF YES.\n         MVC   AREA,TABTITLE       MOVE ENTRY TITLE.\n         L     R15,TABRES          POINT TO DATA RESOLUTION ROUTINE.\n         BALR  R14,R15             FILL-IN TABLE ENTRY.\n         LA    R1,TABSTART         POINT TO AREA START ADDRESS.\n         TM    0(R1),X'80'         BUT IS AREA MISSING?\n         BO    MISSING             B IF AREA IS INDEED MISSING.\n         BAL   R14,HEXOUT          CONVERT TO CHARACTER HEX.\n         MVC   START,WORK          MOVE START ADDR. CHARACTER HEX.\n         LA    R1,TABEND           POINT TO AREA END ADDRESS.\n         BAL   R14,HEXOUT          CONVERT TO CHARACTER HEX.\n         MVC   END,WORK            MOVE END ADDR. CHAR. HEX.\n         L     R1,TABLEN           LOAD AREA LENGTH FROM TABLE.\n         SRL   R1,10               \"DIVIDE\" BY 1K.\n         CVD   R1,WORK             DECIMALIZE IT.\n         MVC   LENGTH,=X'40206B2020206B202120'  MOVE EDIT PATTERN.\n         ED    LENGTH,WORK+4       EDIT LENGTH.\n         ICM   R1,15,TABFULL       LOAD AREA BYTES USED.\n         BNZ   TFE                 B IF NOT ZERO.\n         MVC   FULL,=C'--'         MOVE \"NOT APPLICABLE\" GRAPHIC.\n         B     DETPUT              CONTINUE.\nMISSING  MVC   START,=C'      --'  MOVE \"MISSING\" GRAPHIC.\n         MVC   END,=C'      --'    MOVE \"MISSING\" GRAPHIC.\n         MVC   LENGTH,=C'        --'  MOVE \"MISSING\" GRAPHIC.\n         MVC   FULL,=C'--'         MOVE \"MISSING\" GRAPHIC.\n         B     DETPUT              CONTINUE.\nTFE      L     R5,TABLEN           LOAD DIVISOR.\n         MH    R1,=H'100'          MULTIPLY BYTES BY 100.\n         SR    R0,R0               ZERO HIGH ORDER DIVIDEND.\n         DR    R0,R5               GENERATE PERCENT USED.\n         SRL   R5,1                \"DIVIDE\" DIVISOR BY 2.\n         CR    R0,R5               SHALL I ROUND?\n         BL    NOROUND             B IF NOT.\n         LA    R1,1(,R1)           ROUND PERCENTAGE.\nNOROUND  CVD   R1,WORK             DECIMALIZE PERCENT.\n         UNPK  WORK1(3),WORK+6(2)  UNPAKC PERCENT.\n         MVC   FULL,WORK1+1        MOVE PERCENT.\n         OI    FULL+1,C'0'         FIX SIGN.\nDETPUT   TPUT  DETAIL,LEN          OUTPUT DETAIL LINE.\n         LA    R3,TLEN(,R3)        BUMP TO NEXT TABLE ENTRY.\n         B     TABLUP              LOOP.\n         SPACE 1\nEXIT     L     R13,SAVE+4          POINT TO CALLER'S SAVE AREA.\n         LM    R14,R12,12(R13)     RELOAD CALLER'S REGISTERS.\n         SR    R15,R15             SET CC OF 0\n         BR    R14                 RETURN TO CALLER.\n         TITLE 'DATA RESOLUTION ROUTINES.'\nNOPRES   BR    R14                 NOOP RESOLUTION ROUTINE.\nPRES     L     R1,GDAPVTSZ         LOAD PRIVATE SIZE.\n         BCTR  R1,*-*              GENERATE TRUE END ADDRESS.\n         ST    R1,TABEND           SAVE IN TABLE.\n         S     R1,TABSTART         GENERATE ...\n         LA    R1,1(,R1)           ... TRUE LENGTH.\n         ST    R1,TABLEN           SAVE IN TABLE.\n         BR    R14                 RETURN.\nEPRES    L     R1,GDAEPVT          LOAD START OF E-PRIVATE.\n         ST    R1,TABSTART         SAVE IN TABLE.\n         L     R2,GDAEPVTS         LOAD LENGTH OF E-PRIVATE\n         ST    R2,TABLEN           SAVE IN TABLE.\n         AR    R1,R2               GENERATE ...\n         BCTR  R1,*-*              ... E-PRIVATE END ADDRESS.\n         ST    R1,TABEND           SAVE END ADDRESS IN TABLE.\n         BR    R14                 RETURN.\nCRES     L     R1,GDACSA           LOAD START OF CSA.\n         ST    R1,TABSTART         SAVE IN TABLE.\n         L     R2,GDACSASZ         LOAD LENGTH OF CSA.\n         ST    R2,TABLEN           SAVE IN TABLE.\n         AR    R1,R2               GENERATE ...\n         BCTR  R1,*-*              ... CSA END ADDRESS.\n         ST    R1,TABEND           SAVE IN TABLE.\n         S     R2,GDACSARE         GENERATE BYTES USED.\n         ST    R2,TABFULL          SAVE IN TABLE.\n         BR    R14                 RETURN.\nECRES    L     R1,GDAECSA          LOAD START OF E-CSA.\n         ST    R1,TABSTART         SAVE IN TABLE.\n         L     R2,GDAECSAS         LOAD LENGTH OF E-CSA.\n         ST    R2,TABLEN           SAVE IN TABLE.\n         AR    R1,R2               GENERATE ...\n         BCTR  R1,*-*              ... E-CSA END ADDRESS.\n         ST    R1,TABEND           SAVE IN TABLE.\n         BR    R14                 RETURN.\nSRES     L     R1,GDASQA           LOAD START OF SQA.\n         ST    R1,TABSTART         SAVE IN TABLE.\n         L     R2,GDASQASZ         LOAD LENGTH OF SQA.\n         ST    R2,TABLEN           SAVE IN TABLE.\n         AR    R1,R2               GENERATE ...\n         BCTR  R1,*-*              ... SQA END ADDRESS.\n         ST    R1,TABEND           SAVE IN TABLE.\n         BR    R14                 RETURN.\nESRES    L     R1,GDAESQA          LOAD START OF E-SQA.\n         ST    R1,TABSTART         SAVE IN TABLE.\n         L     R2,GDAESQAS         LOAD LENGTH OF E-SQA.\n         ST    R2,TABLEN           SAVE IN TABLE.\n         AR    R1,R2               GENERATE ...\n         BCTR  R1,*-*              ... E-SQA END ADDRESS.\n         ST    R1,TABEND           SAVE IN TABLE.\n         BR    R14                 RETURN.\nNRORES   TPUT  LINE,LINEL          HERE I DRAW THE LINE.\n         L     R1,CVTRONS          LOAD START OF NUC R/O AREA.\n         ST    R1,TABSTART         SAVE IN TABLE.\n         L     R2,TABEND           LOAD X'00FFFFFF'.\n         SR    R2,R1               GENERATE ...\n         LA    R2,1(,R2)           ... LENGTH.\n         ST    R2,TABLEN           SAVE IT IN TABLE.\n         BR    R14                 RETURN.\nENRORES  L     R1,TABSTART         LOAD X'01000000'.\n         L     R2,CVTRONE          LOAD END OF NUC R/O AREA.\n         O     R2,=A(X'00000FFF')  FORCE ALIGNMENT TO END OF PAGE.\n         ST    R2,TABEND           SAVE IN TABLE.\n         SR    R2,R1               GENERATE ...\n         LA    R2,1(,R2)           ... LENGTH.\n         ST    R2,TABLEN           SAVE IN TABLE.\n         BR    R14                 RETURN.\nVRRES    L     R1,GDAVR            LOAD START OF V=R AREA.\n         ST    R1,TABSTART         SAVE IN TABLE.\n         L     R2,GDAVRSZ          LOAD LENGTH OF V=R AREA.\n         ST    R2,TABLEN           SAVE LENGTH IN TABLE.\n         AR    R1,R2               GENERATE ...\n         BCTR  R1,*-*              ... V=R END ADDRESS.\n         ST    R1,TABEND           SAVE IN TABLE.\n         BR    R14                 RETURN.\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*    THE FOLLOWING IS A GENERAL DATA RESOLUTION ROUTINE FOR           *\n*        STARTING-ENDING ADDRESS PAIRS IN THE VCT VS ADDRESS          *\n*        EXTENSION.  THE TABLE CONTAINS THE ABSOLUTE DISPLACEMENT     *\n*        IN THE CVT EXTENSION TO THE STARTING ADDRESS RATHER THAN     *\n*        THE STARTING ADDRESS ITSELF; THE ENDING ADDRESS IS           *\n*        PRESUMED TO FOLLOW IN THE CVT EXTENSION.                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nCXRES    LR    R1,R7               POINT TO THE CVT EXTENSION.\n         A     R1,TABSTART         POINT TO THE STARTING ADDRESS.\n         ICM   R2,15,4(R1)         LOAD ENDING ADDRESS.\n         BNP   CXNA                B IF THIS AREA IS MISSING.\n         L     R1,0(,R1)           LOAD STARTING ADDRESS.\n         ST    R1,TABSTART         SAVE IT IN TABLE.\n         O     R2,=A(X'00000FFF')  FORCE END OF PAGE ALIGNMENT TO ...\n*                                  ... ACCOUNT FOR WASTE AT CHANGE ...\n*                                  ... OF PROTECTION BOUNDARIES.\n         ST    R2,TABEND           SAVE ENDING ADDRESS IN TABLE.\n         SR    R2,R1               GENERATE ...\n         LA    R2,1(,R2)           LENGTH.\n         ST    R2,TABLEN           SAVE IN TABLE.\n         BR    R14                 RETURN.\nCXNA     LNR   R1,R1               MAKE R1 NEGATIVE.\n         ST    R1,TABSTART         SAVE IN TABLE START POSITION.\n         BR    R14                 RETURN.\n         TITLE 'SUBROUTINE(S).'\n***********************************************************************\n*                                                                     *\n*    HEXOUT - SUBROUTINE TO GENERATE CHARACTER CODED HEXADECIMAL      *\n*        FOR OUTPUT.  R1 POINTS TO THE FULLWORD TO BE TRANSLATED.     *\n*        FIND OUTPUT CHARACTER RESULT IN DOUBLEWORD \"WORK.\"           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nHEXOUT   MVO   WORK1,0(4,R1)       GENERATE PSEUDO PACKED VALUE.\n         UNPK  WORK,WORK1+3(5)     SEPARATE NIBBLES.\n         NC    WORK,=X'0F0F0F0F0F0F0F0F' ELIMINATE ZONES.\n         TR    WORK,=C'0123456789ABCDEF' TRANSLATE TO PRINTABLE HEX.\n         BR    R14                 RETURN TO CALLER.\n         TITLE 'DATA AREAS.'\nSAVE     DS    9D                  SAVE AREA.\nWORK     DS    D                   WORK DOUBLEWORD.\nWORK1    DS    D                   WORK DOUBLEWORD.\n         SPACE 1\nFLAG     DC    X'00'               VARIOUS FLAG(S).\nGFLG     EQU   FLAG,B'10000000'    USER AT DISPLAY TERMINAL.\n         SPACE 1\n*CLEAR   DC    X'F31140403C40400013' CLEAR 3X7X TERMINAL.\nCLEAR    DC    X'F5F313'           CLEAR 3X7X TERMINAL.\n         SPACE 1\nHEAD1    DC    C'Area          '\nHEAD1A   DC    C'Start      '\nHEAD1B   DC    C'End        '\nHEAD1C   DC    C'Length (K)  '\nHEAD1D   DC    C'%Full'\nLEN      EQU   *-HEAD1\nHEAD2    DC    CL(LEN)' '\n         ORG   HEAD2\nHEAD2A   DC    C'------------'\n         ORG   HEAD2+(HEAD1A-HEAD1)\nHEAD2B   DC    C'--------'\n         ORG   HEAD2+(HEAD1B-HEAD1)\nHEAD2C   DC    C'--------'\n         ORG   HEAD2+(HEAD1C-HEAD1)\nHEAD2D   DC    C'----------'\n         ORG   HEAD2+(HEAD1D-HEAD1)\nHEAD2E   DC    C'-------'\n         ORG\nDETAIL   DC    CL(LEN)' '\n         ORG   DETAIL\nAREA     EQU   *,12\n         ORG   DETAIL+(HEAD1A-HEAD1)\nSTART    EQU   *,8\n         ORG   DETAIL+(HEAD1B-HEAD1)\nEND      EQU   *,8\n         ORG   DETAIL+(HEAD1C-HEAD1)\nLENGTH   EQU   *,10\n         ORG   DETAIL+(HEAD1D-HEAD1)\nFULL     EQU   *,2\n         ORG\nLINE     DC    (LEN)C'-',C'   The Line.'\nLINEL    EQU   *-LINE\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*    THE FOLLOWING IS A TABLE OF STORAGE AREAS TO MAP.  THE FIRST     *\n*        12 BYTES OF EACH ENTRY IS THE AREA TITLE, THE NEXT WORD      *\n*        IS THE AREA START ADDRESS, THE NEXT WORD IS THE LENGTH,      *\n*        THE NEXT WORD IS THE END ADDRESS, THE NEXT WORD IS THE       *\n*        NUMBER OF BYTES USED OR 0 AND THE LAST WORD IS THE DATA      *\n*        RESOLUTION ROUTINE ADDRESS.  IN THE CASE OF RESOLUTION       *\n*        ROUTINE CXRES, THE START ADDRESS IS REPLACED BY THE          *\n*        ABSOLUTE DISPLACEMENT TO THE START ADDRESS IN THE CVT VS     *\n*        EXTENSION.                                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nTABLE    DS    0A                  START OF TABLE OF AREAS.\n         DC    CL12'E-Private',A(0),A(0),A(0),A(0),A(EPRES)\n         DC    CL12'E-CSA',A(0),A(0),A(0),A(0),A(ECRES)\n         DC    CL12'E-MLPA'\n         DC    A(CVTEMLPS-CVTVSTGX),A(0),A(0),A(0),A(CXRES)\n         DC    CL12'E-FLPA'\n         DC    A(CVTEFLPS-CVTVSTGX),A(0),A(0),A(0),A(CXRES)\n         DC    CL12'E-PLPA'\n         DC    A(CVTEPLPS-CVTVSTGX),A(0),A(0),A(0),A(CXRES)\n         DC    CL12'E-SQA',A(0),A(0),A(0),A(0),A(ESRES)\n         DC    CL12'E-Nuc. (RW)'\n         DC    A(CVTERWNS-CVTVSTGX),A(0),A(0),A(0),A(CXRES)\n         DC    CL12'E-Nuc. (RO)'\n         DC    X'01000000',A(0),A(0),A(0),A(ENRORES)\n         DC    CL12'Nucleus (RO)'\n         DC    A(0),A(0),X'00FFFFFF',A(0),A(NRORES)\n         DC    CL12'Nucleus (RW)'\n         DC    A(CVTRWNS-CVTVSTGX),A(0),A(0),A(0),A(CXRES)\n         DC    CL12'SQA',A(0),A(0),A(0),A(0),A(SRES)\n         DC    CL12'PLPA',A(CVTPLPAS-CVTVSTGX),A(0),A(0),A(0),A(CXRES)\n         DC    CL12'FLPA',A(CVTFLPAS-CVTVSTGX),A(0),A(0),A(0),A(CXRES)\n         DC    CL12'MLPA',A(CVTMLPAS-CVTVSTGX),A(0),A(0),A(0),A(CXRES)\n         DC    CL12'CSA',A(0),A(0),A(0),A(0),A(CRES)\n         DC    CL12'Private',A(4096),A(0),A(0),A(0),A(PRES)\n         DC    CL12'V=R (if any)',A(0),A(0),A(0),A(0),A(VRRES)\n         DC    CL12'PSA',A(0),A(4096),A(4095),A(0),A(NOPRES)\n         DC    X'00'               END OF TABLE.\n         TITLE 'MAPXA - DSECTS.'\n         CVT   DSECT=YES\n         IHAGDA\nTABLED   DSECT                     TABLE ENTRY MAPPING DSECT.\nTABTITLE DS    CL12                TABLE ENTRY TITLE.\nTABSTART DS    A                   START ADDRESS OF ENTRY'S AREA.\nTABLEN   DS    A                   LENGTH OF ENTRY'S AREA.\nTABEND   DS    A                   END ADDRESS OF ENTRY'S AREA.\nTABFULL  DS    A                   NUMBER OF BYTES USED.\nTABRES   DS    A                   ADDRESS OF RESOLUTION ROUTINE.\nTLEN     EQU   *-TABLED            LENGTH OF TABLE ENTRY.\n         END   MAPXA\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MERKNOW": {"ttr": 6151, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x007\\x00\\x85\\x18/\\x01\\x13\\x13/\\x15\\x01\\x01%\\x01&\\x00P\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "2013-05-12T15:01:37", "lines": 293, "newlines": 294, "modlines": 80, "user": "BROIDO"}, "text": "MERKNOW  TITLE 'SUPPORT SUBROUTINE FOR JOHNSON && JOHNSON NOW MACRO.'\n*%A AMODGEN LO(WUI1.SUBLIB)\n***********************************************************************\n*                                                                     *\n*  COPYRIGHT (C) 1976 BY JEFFREY C. VAN DOREN.  ALL RIGHTS            *\n*  RESERVED EXCEPT:                                                   *\n*                                                                     *\n*  PARTICULAR LICENSE IS GRANTED TO DISTRIBUTE THIS PROGRAM FREE      *\n*  OF CHARGE, BUT IT MUST NOT BE SOLD.  A SERVICE CHARGE FOR          *\n*  HANDLING A COLLECTION OF SOFTWARE OF WHICH THIS IS A PART,         *\n*  ON THE OTHER HAND, IS APPROPRIATE.                                 *\n*                                                                     *\n*                                  BROIDO COMPUTER CONSULTING         *\n*                                  BROIDOJ@GMAIL.COM                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        MODIFIED  TO  SET  STORAGE KEY TO USER'S NORMAL KEY TO       *\n*        PREVENT OVERLAYS OF STORAGE IF BAD DESTINATION PARM IS       *\n*        PASSED IN REG 1.                                             *\n*                                                                     *\n*                                  JEFFREY R. BROIDO - 21 FEB 79      *\n*                                                                     *\n***********************************************************************\n         SPACE 1                                                   JRB\n***********************************************************************\n*                                                                     *\n*        MACLIBS:     SYS1.AMODGEN                                 JRB*\n*                     CBT.MACLIB.ASM                               JRB*\n*                     SYS1.MACLIB                                  JRB*\n*                                                                     *\n***********************************************************************\n         SPACE 2\nMERKNOW  CSECT\n         STM   14,12,12(13)         LINKAGE ....                   VRK\n         LR    12,15                ....                           VRK\n         USING MERKNOW,12           ....                           VRK\n         LR    14,13                ....                           VRK\n         LA    13,SAVE              ....                           VRK\n         ST    13,8(,14)            ....                           VRK\n         ST    14,4(,13)            .... CONVENTIONS               VRK\n         LR    11,1                SAVE REGISTER 1 IN 11\n         LR    8,2                 PUT R2 IN R8 FOR CONSISTENCY    VRK\n         LR    3,0                 LOAD PARMS IN 0 FOR CONSISTENCY VRK\n         LTR   10,0                Q. SYSTEM FUNCTION?\n         BZ    SYSFUNC\nEXTPRES  EQU   *\n         TITLE 'SUPPORT FOR NOW MACRO                     J. VAN DOREN'\n         STC   0,FUNCTION          SAVE FUNCTION\n         L     1,16                POINT TO CVT.                   JRB\n         L     1,0(,1)             POINT TO TCB WORDS.             JRB\n         L     1,4(,1)             POINT TO CURRENT TCB.           JRB\n         USING TCBFIX,1            BASE TCB.                       JRB\n         USING RBPRFX,3            BASE RB.                        JRB\n         LA    1,2                 TIME=STD\n         SVC   11                  ISSUE TIME SVC\n         LR    15,8\n         TM    FUNCTION,X'80' Q    HAS DAY AND TIME BEEN PROVIDED?\n         BZ    NOTPROVD            - NO\n         XC    DBLWORD,DBLWORD     CLEAR WORK\n         MVC   DBLWORD+1(6),0(15)  MOVE IN PROVIDED DATA\n         LA    8,DBLWORD+1\n         LA    7,2\n         BAL   9,LOOP1\n         MVI   DBLWORD+7,X'0F'\n         LA    7,3\n         LA    8,DBLWORD+4\n         BAL   9,LOOP1\n         L     1,WORD1             INSERT DAY\n         L     0,WORD              INSERT TIME\nNOTPROVD EQU   *\n         SRL   0,4                 SHIFT TIME 0HHMMSST\n         STM   0,1,TIME            SAVE THEM\n         TM    FUNCTION,2          Q. NOWKDAY\n         BZ    CHK2\n         SH    11,=H'10'\nCHK2     TM    FUNCTION,4\n         BZ    CHK3\n         SH    11,=H'10'\n         TM    FUNCTION,2\n         BNZ   CHK3\n         SH    11,=H'10'\nCHK3     TM    FUNCTION,8\n         BO    NOTIME\n         EJECT\n         SPACE  3\n*    REGISTER 0 CODE MEANINGS (BYTE 3)\n* 100000000 R15 DAY IS TO BE USED INSTEAD OF SYSTEM DATE\n* 00000001 STANDARD FORMAT\n* 00000010 NO WEEKDAY IS TO BE PRINTED\n* 00000100 SLASH DATE FORMAT MM/DD/YY\n* 00001000 NO TIME IS TO BE PRINTED\n         SPACE 3\n*        STANDARD FORMAT: (41 BYTES LONG (MAX) RIGHT JUSTIFIED)\n*         WWWWWWWWW MMMMMMMMM DD, 19YY, HH.MM.SS XM\n* E.G.          MONDAY JANUARY 1, 1973, 10.55.00 PM\n*                    FRIDAY MAY 4, 1973, 8.15.13 AM\n*         WEDNESDAY SEPTEMBER 12, 1973, 12.03.00 PM\n         SPACE  3\nSTANDARD EQU   *\n         OI    TIME+3,X'0F'        FIX SIGN\n         MVC   28(13,11),TIMEMASK  MOVE IN MASK\n         CP    TIME,=P'120000'     Q. PAST 12\n         BL    AM                  NO\n         MVI   39(11),C'P'         MOVE IN P FOR PM\n         SP    TIME,=P'120000'     MAKE FROM 0-12\nAM       CP    TIME,=P'9999'       Q. ZERO HOUR\n         BH    *+10                NO\n         AP    TIME,=P'120000'     MAKE IT 12 IF 0\n         ED    28(11,11),TIME      EDIT IN TIME\n         MVI   0(11),C' '\n         CLI   30(11),C' '         HIGH ORDER HOUR BLANK?\n         BNE   *+8\n         LA    11,1(11) .          BUMP TO POINTER\n         MVI   28(11),C','         MOVE IN COMMA\n         EJECT\n         SPACE 3\n*        DETERMINE MONTH\n         SPACE 3\nNOTIME   LA    6,MONTHS            START OF TABLE\n         SRL   1,12                SHIFT TO GET YEAR\n         ST    1,WORD              SAVE IT\n         OI    WORD+3,X'0F'        FIX SIGN\n         XC    WORD1,WORD1         CLEAR WORD\n         SP    DAYS,0(2,6)         SUBTRACT NUMBER OF DAYS IN MONTH\n         BNP   MONTHHIT            IF NOT POS RIGHT MONTH\n         CVB   9,DBLWORD\n         SR    8,8                 DETERMINE LEAP YEAR\n         D     8,=F'4'\n         LTR   8,8                 IF REMAINDER ZERO THIS IS LEAP YEAR\n         BNZ   MONTHLP\n         SP    DAYS,PACKED1        SUBRACT 1 DAY FOR LEAP YEAR\nMONTHLP  LA    6,16(6)             BUMP TABLE POINTER\n         SP    DAYS,0(2,6)         SUBTRACT DAYS PER MONTH\n         BP    MONTHLP\nMONTHHIT AP    DAYS,0(2,6)         REG 6=MONTH INDEX\n         CLC   =C' 2',14(6)        FEBRUARY?                       JRB\n         BNE   NOTLF               B IF NOT.                       JRB\n         LTR   8,8                 LEAP YEAR?                      JRB\n         BNZ   NOTLF               B IF NOT.                       JRB\n         AP    DAYS,PACKED1        ADD BACK ONE DAY FOR FEB. YECH. JRB\n*        I INITIAL THE ABOVE LINES RELUCTANTLY.                    JRB\nNOTLF    TM    FUNCTION,4\n         BZ    NOSLASH\nSLASH    UNPK  26(2,11),WORD       INSERT YEAR\n         OI    27(11),X'F0'        FIX SIGN\n         UNPK  23(2,11),DAYS       INSERT DAYS\n         OI    24(11),X'F0'        FIX SIGN\n         MVC   20(2,11),14(6)      MOVE IN MONTH\n         MVI   25(11),C'/'\n         MVI   22(11),C'/'\n         B     ENOWKDAY                                 TAR\nLOOP1    EQU   *\n         TM    0(8),X'80'\n         BZ    OK1\n         TM    0(8),X'60'\n         BNZ   BADDTA\nOK1      EQU   *\n         TM    0(8),X'08'\n         BZ    OK2\n         TM    0(8),X'06'\n         BNZ   BADDTA\nOK2      EQU   *\n         LA    8,1(8)\n         BCT   7,LOOP1\n         TM    0(8),X'80'\n         BZ    OK3\n         TM    0(8),X'60'\n         BNZ   BADDTA\nOK3      EQU   *\n         TM    0(8),X'0F'\n         BNO   BADDTA\n         BR    9\nBADDTA   EQU   *\n         LA    15,8\n         B     LAST\nNOSLASH  EQU   *\n         UNPK  26(2,11),WORD       PUT IN YEAR\n         OI    27(11),X'F0'        FIX SIGN\n         UNPK  20(2,11),DAYS       PUT IN DAY\n         MVC   22(4,11),=C', 19'   MOVE IN CENTURY\n         OI    21(11),X'F0'        FIX SIGN\n         MVI   0(11),C' '\n         CLI   20(11),C'0'\n         BNE   *+8\n         LA    11,1(11)\n         MVI   19(11),C' '\n         MVC   10(9,11),2(6)       MOVE IN MONTH\n         SR    2,2\n         IC    2,11(6)             SAVE LENGTH INDEX\n         TM    FUNCTION,2\n         BNZ   ENOWKDAY\n         AP    DAYS,12(1,6)       ADD FUDGE\n         EJECT\n         SPACE 3\n*  FORMULA FOR DAY OF WEEK\n*  DOW IS REMAINDER OF (D+FUDGE+5(3+YRADJ/4)+R)/7\n* YRADJ=  YEAR IF MONTH>2 OR YEAR-1 IF MONTH<3\n* FUDGE IS TABLE ENTRY 4\n* R=REMAINDER OF YRADJ/4\n* D=DAY OF MONTH\n* DOW=0=SUNDAY, 1=MONDAY, U.S.W.\n         SP    WORD,13(1,6)        NORMALIZE YEAR\n         XC    WORD1,WORD1\n         CVB   9,DBLWORD\n         SR    8,8                 CLEAR FOR DIVIDE\n         D     8,=F'4'\n         LA    9,3(9)              ADD 3\n         MH    9,=H'5'             MULTIPLY BY 5\n         ZAP   DBLWORD,DAYS\n         CVB   6,DBLWORD\n         LA    9,0(8,9)\n         SR    8,8\n         LA    9,0(6,9)\n         D     8,=F'7'\n         LR    15,8                DAY OF WEEK IN R15\n         MVI   0(11),C' '\n         MVC   1(9,11),0(11)        CLEAR IT\n         AR    2,11                 INDEX FOR MOVE\n         MH    8,=H'7'             DAY TABLE LENGTH\n         LA    7,DAYNAMES(8)\n         MVC   0(6,2),0(7)         MOVE IN DAY\n         MVC   6(3,2),=C'DAY'\n         SR    1,1                  CLEAR REG 1\n         IC    1,6(7)\n         AR    1,2                 START OF STRING IN R1\n         B     LAST                RETURN\nENOWKDAY LA    1,0(2,11)\n         B     RETURN\n         EJECT\n         SPACE 3\n* MONTH TABLE IN THE FOLLOWING FORMAT:\n* PL2 NUMBER OF DAYS PER MONTH\n* CL9 RT JUSTIFIED MONTH NAME                                      JRB\n* 1 BYTE BINARY DIFF. OF 9 AND LENGTH OF MONTH.                    JRB\n* PL1 NORMAL YEAR (BASE MARCH ADJUSTMENT)\n*  CL2 MONTH NUMBER\n          SPACE  3\nMONTHS   DC    P'31',CL9'  JANUARY',AL1(2),P'0',P'1',C' 1'\n         DC    P'28',CL9' FEBRUARY',AL1(1),P'3',P'1',C' 2'\n         DC    P'31',CL9'    MARCH',AL1(4),P'2',P'0',C' 3'\n         DC    P'30',CL9'    APRIL',AL1(4),P'5',P'0',C' 4'\n         DC    P'31',CL9'      MAY',AL1(6),P'0',P'0',C' 5'\n         DC    P'30',CL9'     JUNE',AL1(5),P'3',P'0',C' 6'\n         DC    P'31',CL9'     JULY',AL1(5),P'5',P'0',C' 7'\n         DC    P'31',CL9'   AUGUST',AL1(3),P'1',P'0',C' 8'\n         DC    P'30',CL9'SEPTEMBER',AL1(0),P'4',P'0',C' 9'\n         DC    P'31',CL9'  OCTOBER',AL1(2),P'6',P'0',C'10'\n         DC    P'30',CL9' NOVEMBER',AL1(1),P'2',P'0',C'11'\n         DC    P'31',CL9' DECEMBER',AL1(1),P'4',P'0',C'12'\nTIMEMASK DC    X'402020214B20204B202040',C'AM'\nPACKED1  DC    PL2'1'\nDAYNAMES DC    CL6'   SUN',AL1(3)\n         DC    CL6'   MON',AL1(3)\n         DC    CL6'  TUES',AL1(2)\n         DC    CL6'WEDNES',AL1(0)\n         DC    CL6' THURS',AL1(1)\n         DC    CL6'   FRI',AL1(3)\n         DC    CL6' SATUR',AL1(1)\n         TITLE 'SUPPORT FOR $LOADPSW MACRO                J. VAN DOREN'\nSYSFUNC  CLC   1(5,11),SYSCONST    Q. VALID LIST FOR $LOADPSW?\n         BNE   BADRET              NO\n         XC    17(1,6),0(11)       FLIP FLOP BITS IN PSW\n         XC    0(1,11),17(6)       *\n         XC    17(1,6),0(11)       *\nRETURN   XR    15,15               SET RETURN CODE\n         B     LAST                 BRANCH TO LAST\n         SPACE 3\nBADRET   LA    15,16               SET BAD RETURN CODE\nLAST     L     13,4(,13)                 RESTORE CALLERS SAVE AREA VRK\n         L     14,12(,13)                RESTORE R14               VRK\n         LM    0,12,20(13)               RESTORE REST OF REGISTERS VRK\n         BR    14                        OUT                       VRK\n         SPACE 3\nENABLE   DC    X'FF'               SYSTEM MASK FOR ENABLED STATE\nSYSCONST DC    C'$',X'17000AFC'    SECUTITY LIST CHECKER\nSAVE     DS    18F\n         LTORG\n         DS    0D                  END OF MODULE\nDBLWORD  DS    0D\nWORD1    DS    F\nWORD     DS    F\nTIME     DS    F                   0HHMMSST\nDAY      DS    F                   00YYDDDF\n         ORG   *-2\nDAYS     DS    PL2\n         ORG\nFUNCTION DS    C                   FUNCTION BYTE FROM R0\n         IKJTCB                                                    JRB\n         IHARB                                                     JRB\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NOW": {"ttr": 6402, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00R\\x00\\x85\\x18/\\x01\\x13\\x13/\\x15\\x01\\x00I\\x00J\\x00\\x14\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "2013-05-12T15:01:52", "lines": 73, "newlines": 74, "modlines": 20, "user": "BROIDO"}, "text": "         MACRO\n.**********************************************************************\n.*                                                                    *\n.*  COPYRIGHT (C) 1978 BY JEFFREY C. VANDOREN.  ALL RIGHTS            *\n.*  RESERVED EXCEPT:                                                  *\n.*                                                                    *\n.*  PARTICULAR LICENSE IS GRANTED TO DISTRIBUTE THIS MACRO FREE       *\n.*  OF CHARGE, BUT IT MUST NOT BE SOLD.  A SERVICE CHARGE FOR         *\n.*  HANDLING A COLLECTION OF SOFTWARE OF WHICH THIS IS A PART,        *\n.*  ON THE OTHER HAND, IS APPROPRIATE.                                *\n.*                                                                    *\n.*                                  BROIDO COMPUTER CONSULTING        *\n.*                                  BROIDOJ@GMAIL.COM                 *\n.*                                                                    *\n.**********************************************************************\n&NAME    NOW   &T,&X,&F\n         LCLA  &A\n* JOHNSON AND JOHNSON NOW MACRO                             CHANGE 1.0\n.* AUTHOR: J. VAN DOREN\n         AIF   ('&NAME' EQ '').NONAME\n&NAME    DS    0H\n.NONAME  AIF   ('&X' EQ '').STD\n         AIF   ('&X' EQ 'STD').STD\n         AIF   ('&X' EQ 'NOTIME').NT\n         AIF   ('&X' EQ 'NODAY').ND\n         AIF   ('&X' EQ 'NEITHER').N\n         AIF   ('&X' EQ 'SLASH').S\n         AIF   ('&X' EQ 'SNOTIME').SNT\n         AIF   ('&X' EQ 'SNODAY').SND\n         AIF   ('&X' EQ 'SONLY').SO\n         MNOTE 16,'FORMAT (PARM 2) IF SPECIFIED MUST BE STD (DEFAULT), X\n               NEITHER, NOTIME, NODAY, SLASH, SNOTIME, SNODAY, OR SONLYX\n               FOUND: &X'\n         MEXIT\n.STD     ANOP\n&A       SETA  &A+1\n         AGO   .FCHK\n.NT      ANOP\n&A       SETA  &A+8\n         AGO   .STD\n.ND      ANOP\n&A       SETA  &A+2\n         AGO   .STD\n.N       ANOP\n&A       SETA  &A+10\n         AGO   .STD\n.S       ANOP\n&A       SETA  &A+4\n         AGO   .FCHK\n.SNT     ANOP\n&A       SETA  &A+8\n         AGO   .S\n.SND     ANOP\n&A       SETA  &A+2\n         AGO   .S\n.SO      ANOP\n&A       SETA  &A+10\n         AGO   .S\n.FCHK    AIF   ('&F' EQ '').FOK\n         AIF   ('&F' EQ '(15)').F\n         AIF   ('&F' EQ '(R15)').F\n         L     2,=A(&F)            LOAD REGISTER 2 WITH ADDR OF DATE.\n.F       ANOP\n&A       SETA  &A+128\n.FOK     AIF   ('&T' EQ '').R1\n         AIF   ('&T' EQ '(1)').R1\n         AIF   ('&T' EQ '(R1)').R1\n         L     1,=A(&T)                LOAD RECV ADDR\n.R1      ANOP\n         LA    0,&A                    LOAD PARAMETER REG\n         L     15,=V(MERKNOW)      POINT TO NOW SUBROUTINE.\n         BALR  14,15               CALL NOW SUBROUTINE.\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OFF": {"ttr": 6405, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x03\\x00\\x85\\x18/\\x01\\x13\\x13/\\x15\\x02\\x00\\x16\\x00\\x17\\x00\\x0e\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "2013-05-12T15:02:03", "lines": 22, "newlines": 23, "modlines": 14, "user": "BROIDO"}, "text": "         MACRO\n&NAME    OFF   &FLAG\n.*\n.**********************************************************************\n.*                                                                    *\n.*  COPYRIGHT (C) 1981 BY BROIDO COMPUTER CONSULTING.  ALL RIGHTS     *\n.*  RESERVED EXCEPT:                                                  *\n.*                                                                    *\n.*  PARTICULAR LICENSE IS GRANTED TO DISTRIBUTE THIS MACRO FREE       *\n.*  OF CHARGE, BUT IT MUST NOT BE SOLD.  A SERVICE CHARGE FOR         *\n.*  HANDLING A COLLECTION OF SOFTWARE OF WHICH THIS IS A PART,        *\n.*  ON THE OTHER HAND, IS APPROPRIATE.                                *\n.*                                                                    *\n.*                                  BROIDO COMPUTER CONSULTING        *\n.*                                  BROIDOJ@GMAIL.COM                 *\n.*                                                                    *\n.**********************************************************************\n.*\n         LCLC  &L\n&L       SETC  'L'''\n&NAME    NI    &FLAG,255-&L.&FLAG          (TURN OFF BIT FLAG)\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ON": {"ttr": 6407, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x13\\x00\\x85\\x18/\\x01\\x13\\x13/\\x15\\x02\\x00\\x16\\x00\\x17\\x00\\x0e\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "2013-05-12T15:02:13", "lines": 22, "newlines": 23, "modlines": 14, "user": "BROIDO"}, "text": "         MACRO\n&NAME    ON    &FLAG\n.*\n.**********************************************************************\n.*                                                                    *\n.*  COPYRIGHT (C) 1981 BY BROIDO COMPUTER CONSULTING.  ALL RIGHTS     *\n.*  RESERVED EXCEPT:                                                  *\n.*                                                                    *\n.*  PARTICULAR LICENSE IS GRANTED TO DISTRIBUTE THIS MACRO FREE       *\n.*  OF CHARGE, BUT IT MUST NOT BE SOLD.  A SERVICE CHARGE FOR         *\n.*  HANDLING A COLLECTION OF SOFTWARE OF WHICH THIS IS A PART,        *\n.*  ON THE OTHER HAND, IS APPROPRIATE.                                *\n.*                                                                    *\n.*                                  BROIDO COMPUTER CONSULTING        *\n.*                                  BROIDOJ@GMAIL.COM                 *\n.*                                                                    *\n.**********************************************************************\n.*\n         LCLC  &L\n&L       SETC  'L'''\n&NAME    OI    &FLAG,&L.&FLAG              (TURN ON BIT FLAG)\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "QUOTE": {"ttr": 6409, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00$\\x00\\x85\\x18/\\x01\\x13\\x13/\\x15\\x02\\x01\\x8e\\x01\\x8f\\x01\\x8d\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "2013-05-12T15:02:24", "lines": 398, "newlines": 399, "modlines": 397, "user": "BROIDO"}, "text": "QUOTE    TITLE 'QUOTE - TSO COMMAND TO READ QUOTE-OF-THE-DAY.'\n*%A PPLINK\nQUOTE    CSECT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  COPYRIGHT (C) 1982 BY BROIDO COMPUTER CONSULTING.  ALL RIGHTS      *\n*  RESERVED EXCEPT:                                                   *\n*                                                                     *\n*  PARTICULAR LICENSE IS GRANTED TO DISTRIBUTE THIS PROGRAM FREE      *\n*  OF CHARGE, BUT IT MUST NOT BE SOLD.  A SERVICE CHARGE FOR          *\n*  HANDLING A COLLECTION OF SOFTWARE OF WHICH THIS IS A PART,         *\n*  ON THE OTHER HAND, IS APPROPRIATE.                                 *\n*                                                                     *\n*                                  BROIDO COMPUTER CONSULTING         *\n*                                  broidoj@gmail.com                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  QUOTE - TSO COMMAND TO READ QUOTE-OF-THE-DAY WITH BACKGROUND       *\n*          FROM SYS1.BRODCAST DATASET.  THE BRODCAST PROGRAM LOADS    *\n*          SYS1.BRODCAST WITH THE APPROPRIATE QUOTE-OF-THE-DAY,       *\n*          PLACING THE QUOTE ITSELF IN THE NOTICES AREA OF THE        *\n*          DATASE AND THE BACKGROUND IN THE MAIL AREA.  IT            *\n*          PLACES THE ADDRES (TTR) OF THE FIRST MAIL (\"@\")            *\n*          RECORD IN A RESERVED FIELD IN THE BRODCAST HEADER,         *\n*          WHICH THIS PROGRAM READS.                                  *\n*                                                                     *\n*                                  JEFFREY  R.  BROIDO                *\n*                                  AIG - E. ORANGE, NJ                *\n*                                  16    MARCH    1982                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         REGS\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         USING QUOTE,R12\n         ST    R12,PPLUWA          SAVE BASE FOR PARSE VLD. CHECKER.\n         LR    R14,R13\n         LA    R13,SAVE\n         ST    R14,4(,R13)\n         ST    R13,8(,R14)\n         SPACE 1\n         LR    R2,R1\n         USING CPPL,R2\n         MVC   PPLUPT,CPPLUPT      MOVE CONTROL ...\n         MVC   PPLECT,CPPLECT      ... POINTERS FROM ...\n         MVC   PPLCBUF,CPPLCBUF    ... CPPL TO PPL.\n         MVC   PSCB,CPPLPSCB       SAVE ADDR. OF PSCB.\n         ST    R2,DFCPPLP          SAVE ADDR OF CPPL FOR DAIRFAIL.\n         LA    R1,PPL              POINT TO PARSE PARM LIST.\n         L     R15,16              POINT TO CVT.\n         L     R15,X'20C'(,R15)    POINT TO IKJPARS.\n         BALR  R14,R15             PARSE COMMAND BUFFER.\n         CH    R15,=H'4'           PARSE GO OK?\n         BNH   PARSEOK             B IF YES.\n         VTPUT 'Unable to parse your command.  Please call a Systems Pr+\n               ogrammer.'\n         B     EOJ                 BYE.\nPARSEOK  ON    PARSOKFG            SAY PARSE WENT OK.\n         L     R6,ANSWERPL         POINT TO PDES.\n         USING IKJPARMD,R6\n         L     R2,16               POINT TO CVT.\n         L     R2,0(,R2)           POINT TO TCB WORDS.\n         L     R2,0(,R2)           POINT TO TCB.\n         L     R3,X'B4'(,R2)       POINT TO JSCB.\n         L     R3,X'140'(,R3)      POINT TO QDB FOR DSAB QUEUE.\n         ICM   R3,7,13(R3)         POINT TO FIRST DSAB.\n         BZ    ALLOCATE            B IF NO DSABS... ALLOCATE DATASET.\nDSABLOOP L     R1,16(,R3)          POINT TO TIOT ENTRY FOR DDNAME.\n         CLC   =C'SYSLBC ',4(R1)   IS THIS THE BRODCAST DS ALLOCATION?\n         BE    OPEN                B IF YES.\n         ICM   R3,7,5(R3)          POINT TO NEXT DSAB.\n         BNZ   DSABLOOP            B IF NOT END OF CHAIN.\nALLOCATE LA    R1,S99RBPTR         POINT TO RB POINTER FOR DYNALLOC.\n         DYNALLOC                  ALLOCATE 'SYS1.BRODCAST'\n         LTR   R15,R15             DYNALLOC SUCCESSFUL?\n         BZ    OPEN                B IF YES.\n         ST    R15,D99RET          SAVE RETURN CODE.\n         LA    R1,DFPARM           POINT TO DAIRFAIL PARMS.\n         LINK  EP=IKJEFF18         ISSUE BONZO MESSAGE.\n         LA    R15,16              SET CC OF 16.\n         B     EOJ                 BYE.\nOPEN     OPEN  (SYSLBC)            OPEN BRODCAST DATASET.\n         TM    SYSLBC+48,X'10'     OPEN OK?\n         BO    OPEN1\n         VTPUT 'Unable to open BRODCAST dataset.  Please call Systems P+\n               rogrammer.'\n         LA    R15,8\n         B     EOJ\nOPEN1    BAL   R14,BREAD           READ HEADER.\n         MVC   EPTR(9),BDATA+120   MOVE QUOTE MESSAGE POINTERS.\n         SR    R3,R3               CLEAR INSERT ...\n         LR    R5,R3               ... REGISTERS FOR BXLE PARMS.\n         LA    R4,1                LOAD BXLE INCREMENT.\n         ICM   R3,7,FQPTR          POINT TO FIRST QUOTE RECORD.\n         BNZ   OPEN2               B IF THERE IS A QUOTE.\n         VTPUT 'There is no Quote-of-the-Day today.'\n         LA    R15,4               SET CC OF 4.\n         B     EOJ                 BYE.\nOPEN2    ICM   R5,7,LQPTR          POINT TO LAST QUOTE RECORD.\n         GTSIZE ,                  GET TERMINAL DEPTH.\n         LTR   R0,R0               IS THERE ANY DEPTH (DISPLAY)?\n         BZ    OPEN3               B IF NOT.\n         ON    DISPFG              TURN ON DISPLAY FLAG.\n         CLI   CLEARK+1,X'01'      USER SAY \"NOCLEAR?\"\n         BE    OPEN3               B IF YES.\n         STFSMODE ON,INITIAL=YES   SET FULLSCREEN MODE.\n         K     ,                   CLEAR THE SCREEN.\nOPEN3    LM    R0,R1,BLN           WRITE ...\n         TPUT  (1),(0)             ... TWO ...\n         LM    R0,R1,BLN           ... BLANK ...\n         TPUT  (1),(0)             ... LINES.\nQLOOP    STCM  R3,7,BLOCK#         SAVE BLOCK # OF CURRENT QUOTE REC.\n         BAL   R14,BREAD           READ CURRENT QUOTE REC.\n         CLI   KEY,X'02'           THIS A PROPER NOTICE RECORD?\n         BE    QLOOP0              B IT YES.\n         VTPUT '\"NOTICE\" record expected, not found.  Please call Syste+\n               ms Programmer.'\n         LA    R15,16              SET CC OF 16.\n         B     EOJ                 BYE.\nQLOOP0   SR    R0,R0               CLEAR LENGTH REGISTER.\n         ICM   R0,1,BDATA          INSERT LENGTH OF MESSAGE.\n         BNZ   QLOOP1              B IF THERE IS A MESSAGE.\n         LM    R0,R1,BLN           POINT TO BLANK LINE (IF 0 LEN MSG).\n         B     QLOOP2              OUTPUT BLANK LINE.\nQLOOP1   LA    R1,BDATA+1          POINT TO MESSAGE.\nQLOOP2   TPUT  (1),(0)             OUTPUT QUOTE.\n         BXLE  R3,R4,QLOOP         GET ANOTHER QUOTE RECORD.\n         LM    R0,R1,BLN           OUTPUT ...\n         TPUT  (1),(0)             ... BLANK LINE.\n         CLI   LENGTHK+1,X'01'     USER SAY \"SHORT?\"\n         BNE   EHEAD               B IF NO.  OUTPUT EXTENDED MSGS.\n         SR    R15,R15             SET CC OF 0.\n         B     EOJ                 BYE.\nEHEAD    ICM   R3,7,EPTR           POINT TO FIRST EXTENDED MESSAGE.\n         BNZ   ELOOP               B IF THERE ARE ANY.\n         SR    R15,R15             SET CC OF 0.\n         B     EOJ                 BYE.\nELOOP    STCM  R3,7,BLOCK#         SAVE BLOCK OF CURRENT EXTENDED REC.\n         BAL   R14,BREAD           READ CURRENT EXTENDED RECORD.\n         CLI   KEY,C'Q'            IS THIS A PROPER EXTENDED RECORD?\n         BE    ELOOP0              B IF YES.\n         VTPUT '\"Q\" record expected, not found.  Please call Systems Pr+\n               ogrammer.'\n         LA    R15,16              SET CC OF 16.\n         B     EOJ                 BYE.\nELOOP0   SR    R4,R4               CLEAR LENGTH INSERT REGISTER.\n         IC    R4,BDATA            LOAD LENGTH OF MESSAGE.\n         SH    R4,=H'1'            SUBTRACT LENGTH OF FLAG CHARACTER.\n         BNM   ELOOP1              B IF LENGTH AT LEAST 1.\n         VTPUT '\"Q\" record length is 0.  Please call Systems Programmer+\n               .'\n         LA    R15,16              SET CC OF 16.\n         B     EOJ                 BYE.\nELOOP1   CLI   BDATA+1,C'@'        NORMAL EXTENDED MESSAGE?\n         BE    ELOOP2              B IF YES.\n         CLI   BDATA+1,C'='        ALMOST NORMAL EXTENDED MSG (FOR OLD\n*                                  QUOTE CLIST, WOULD KNOW TO COMPRESS\n*                                  PAIRS OF APOSTROPHES).\n         BE    ELOOP2              B IF YES.\n         CLI   BDATA+1,C'#'        \"MORE?\" FLAG?\n         BE    ELOOPM              B IF YES.\n         VTPUT '\"Q\" record has invalid flag character.  Please call Sys+\n               tems Programmer.'\n         LA    R15,16              SET CC OF 16.\n         B     EOJ                 BYE.\nELOOPM   CLI   PAUSEK+1,X'01'      USER SAY \"NOPAUSE?\"\n         BE    ELOOP2              HE DID, SO DON'T ASK FOR MORE.\n         LM    R0,R1,BLN           OUTPUT ...\n         TPUT  (1),(0)             ... BLANK LINE.\n         LM    R0,R1,MORE          POINT TO \"MORE?\"\n         TPUT  (1),(0),ASIS        PLEASE, SIR, COULD I HAVE S'\"MORE?\"\n         TGET  ANSWER,20           GET ANSWER.\n         LTR   R1,R1               NULL LINE?\n         BZ    ELOOPM1             B IF YES (USER WANTS MORE).\n         TRT   ANSWER,TRTAB        FIND ANSWER.\n         BZ    ELOOPM1             B IF NOTHING BUT BLANKS.\n         EX    R2,COMP             IS FIRST CHARACTER \"N\"?\n*      ( CLI   =X'02',*-*)\n         BNE   ELOOPM1             B IF NOT (USER WANTS MORE).\n         SR    R15,R15             SET CC OF 0.\n         B     EOJ                 BYE.\nELOOPM1  LM    R0,R1,BLN           OUTPUT ...\n         TPUT  (1),(0)             ... BLANK LINE.\nELOOP2   LA    R1,BDATA+2          POINT TO ACTUAL MESSAGE.\n         LTR   R0,R4               EMPTY LINE?\n         BNZ   ELOOP3              B IF NOT.\n         LM    R0,R1,BLN           POINT TO BLANK LINE.\nELOOP3   TPUT  (1),(0)             OUTPUT EXTENDED QUOTE RECORD.\n         ICM   R3,7,BDATA+126      LOAD RRN OF NEXT EXTENDED RECORD.\n         BNZ   ELOOP               B IF CHAIN FIELD NON-ZERO.\n         LM    R0,R1,BLN           OUTPUT BLANK ...\n         TPUT  (1),(0)             ... LINE.\n         SR    R15,R15             SET CC OF 0.\n         B     EOJ                 BYE.\nBREAD    ST    R14,SAVE1           SAVE RETURN ADDR.\n         READ  BDECB,DI,SYSLBC,BDATA,'S',KEY,BLOCK#   READ A BC REC.\n         CHECK BDECB               WAIT FOR IO TO COMPLETE.\n         LA    R15,16              PRE-LOAD CC OF 16.\n         TF    SYNADFG             IO ERROR?\n         BO    EOJ                 B IF YES.\n         L     R14,SAVE1           RE-LOAD RETURN ADDR.\n         BR    R14                 RETURN TO CALLER.\n         SPACE 1\nEOJ      LR    R4,R15              SAVE CC.\n         TM    SYSLBC+48,X'10'     IS DCB OPEN?\n         BZ    EOJ1                B IF NOT.\n         CLOSE (SYSLBC)            CLOSE FILE.\n         TF    DISPFG              THIS A DISPLAY CONSOLE?\n         BZ    EOJ1                B IF NOT.\n         STFSMODE OFF              SET MESSAGE STREAM MODE.\nEOJ1     TF    PARSOKFG            PARSE GO OK?\n         BZ    EOJ2                B IF NOT.\n         IKJRLSA ANSWERPL          RELEASE PARSE GETMAINED STORAGE.\nEOJ2     LR    R15,R4              RE-LOAD CC.\n         L     R13,SAVE+4          RELOAD  ...\n         LM    R0,R12,20(R13)      ... CALLER'S ...\n         L     R14,12(,R13)        ... REGISTERS.\n         BR    R14                 RETURN TO CALLER.\n         SPACE 1\nSYNAD    SYNADAF ACSMETH=BDAM,PARM1(1)\n         STM   R14,R12,12(R13)     SAVE REGS IN SYNADAF PROVIDED S.A.\n         LR    R14,R13             CHAIN ...\n         LA    R13,SAVE1           ...\n         ST    R14,4(,R13)         ...\n         ST    R13,8(,R14)         ... SAVE AREAS.\n         LH    R0,0(,R1)           LOAD LENGTH OF SYNADAF MESSAGE\n         SH    R0,=H'4'            SUBTRACT LENGTH OF PSEUDO RDW.\n         LA    R1,4(,R1)           POINT TO MESSAGE TEXT.\n         TPUT  (1),(0)             OUTPUT SYNADAF MESSAGE.\n         ON    SYNADFG             TURN ON SYNAD-EXIT-ENTERED FLAG.\n         L     R13,SAVE1+4\n         LM    R14,R12,12(R13)\n         SYNADRLS                  FREE SAVE AREA AND MESSAGE.\n         BR    R14                 RETURN.\n         SPACE 1\nDV       STM   R14,R12,12(R13)     SAVE PARSE'S REGISTERS.\n         L     R12,4(,R1)          RE-LOAD BASE ADDRESS.\n         LR    R14,R13             CHAIN ...\n         LA    R13,SAVE1           ... SAVE\n         ST    R13,8(,R14)         ...\n         ST    R14,4(,R13)         ... AREAS.\n         L     R8,0(,R1)           POINT TO PDE.\n         LH    R3,4(,R8)           LOAD LENGTH.\n         CH    R3,=H'6'            IS IT AT LEAST 6 CHARACTERS?\n         BL    DVEOJBAD            B IF NOT.\n         L     R4,0(,R8)           POINT TO PARM.\n         CLI   1(R4),C'/'          SECOND CHAR A SLASH?\n         BNE   DV1                 B IF NOT.\n         MVC   MONTH+1(1),0(R4)    MOVE ONE CHAR. MONTH.\n         LA    R4,2(,R4)           POINT TO DAY.\n         B     DV2\nDV1      CLI   2(R4),C'/'          THIRD CHAR. A SLASH?\n         BNE   DVEOJBAD            B IF NOT.\n         MVC   MONTH,0(R4)         MOVE TWO CHAR. MONTH.\n         LA    R4,3(,R4)           POINT TO DAY.\nDV2      CLI   1(R4),C'/'          SECOND CHAR. OF DAY A SLASH?\n         BNE   DV3                 B IF NOT.\n         MVC   DAY+1(1),0(R4)      MOVE ONE CHAR. DAY.\n         LA    R4,2(,R4)           POINT TO YEAR.\n         B     DV4\nDV3      CLI   2(R4),C'/'          THIRD CHAR. OF DAY A SLASH?\n         BNE   DVEOJBAD            B IF NOT.\n         MVC   DAY,0(R4)           MOVE TWO CHAR. DAY.\n         LA    R4,3(,R4)           POINT TO YEAR.\nDV4      MVC   YEAR,0(R4)          MOVE YEAR.\n         MVZ   DTEST,YEAR          MOVE ZONES OF YEAR-MONTH-DAY.\n         CLC   DTEST,=C'000000'    ALL NUMERIC?\n         BNE   DVEOJBAD            B IF NOT.\n         SR    R15,R15             SET CC OF 0 IF YES.\n         B     DVEOJ               EXIT VALIDITY CHECKER.\nDVEOJBAD LM    R0,R1,BLN           OUTPUT ...\n         TPUT  (1),(0)             ... BLANK LINE.\n         VTPUT 'Date must be of the form MM/DD/YY.'\n         LA    R15,8               SET CC OF 8.\nDVEOJ    L     R13,SAVE1+4\n         LM    R0,R12,20(R13)\n         L     R14,12(,R13)\n         BR    R14\n         SPACE 1\nSAVE     DS    9D                  SAVE AREA\nSAVE1    DS    9D                  ALTERNATE SAVE AREA.\n         SPACE 1\nDMEM     DC    C'Q'                ALTERNATE MEMBER NAME.\nYEAR     DC    C'00'               OUTPUT ...\nMONTH    DC    C'00'               ... FROM DATE VALIDITY\nDAY      DC    C'00'               ... CHECKING ROUTINE.\nDTEST    DC    XL6'00'             MVZ GENERATED COMPARAND.\n         SPACE 1\nCOMP     CLI   =X'02',*-*          ** EXECUTED **\n         SPACE 1\nSYNADFG  EQU   *,B'10000000'       SYNAD ROUTINE ENTERED FLAG.\nDISPFG   EQU   *,B'01000000'       USER AT DISPLAY TERMINAL.\nPARSOKFG EQU   *,B'00100000'       PARSE WENT OK.\nFLAG     DC    X'00'               VARIOUS FLAGS.\n         SPACE 1\nEPTR     DS    XL3                 RRN OF FIRST EXTENDED ('Q') REC.\nFQPTR    DS    XL3                 RRN OF FIRST NORMAL QUOTE REC.\nLQPTR    DS    XL3                 RRN OF LAST NORMAL QUOTE REC.\n         SPACE 1\nBLN      DC    A(1)                BLANK OUTPUT LINE.\n         DC    A(*+4)              (TPUT PARMS AND A BLANK)\n         DC    C' '\n         SPACE 1\nKEY      DS    X                   KEY OF BRODCAST RECORD.\nBDATA    DS    CL129               I/O BUFFER.\nBLOCK#   DC    X'000000'           RELATIVE BLOCK #.\n         SPACE 1\nMORE     DC    A(L'MORE1)          LENGTH OF MESSAGE.\n         DC    A(MORE1)            PTR TO MESSAGE.\nMORE1    DC    C'   More? (Hit ENTER or type \"no\") '\nANSWER   DS    CL20                ANSWER AREA FOR \"MORE?\"\n         SPACE 1\nDFPARM   DC    A(S99RB)            DAIRFAIL PARMS.\nDFRCP    DC    A(D99RET)           DYNALLOC RETURN CODE.\n         DC    A(DFKRUD)           ADDRESS OF A FULLWORD OF ZEROS.\n         DC    A(DFIDP)            ADDRESS OF OPTIONS\nDFCPPLP  DC    A(0)                POINTER TO CPPL.\nDFKRUD   DC    A(0)                UNUSED.\nD99RET   DC    A(0)                RETURN CODE.\nDFIDP    DC    X'0032'             SAY PROBLEM IN SVC99.\n         SPACE 1\nS99RBPTR DS    0A                  DYNALLOC ...\n         DC    X'80',AL3(S99RB)    ... RB POINTER.\nS99RB    DC    AL1(20,1,0,0)       LENGTH, VERB CODE, FLAGS.\n         DC    AL2(0,0)            ERROR, INFO CODES.\nS99TU    DC    A(TUPS)             TU POINTERS POINTER.\n         DC    A(0)                RESERVED.\n         DC    A(0)                UNUSED FLAGS.\n         SPACE 1\nTUPS     DS    0A                  TU POINTERS.\n         DC    A(TU0001)           POINTER TO DDNAME TU.\n         DC    A(TU0002)           POINTER TO DSNAME TU.\n         DC    X'80',AL3(TU0004)   POINTER TO STATUS TU.\n         SPACE 1\nTU0001   DC    AL2(1,1,6),C'SYSLBC'  DDNAME.\nTU0002   DC    AL2(2,1,L'DSN)\nDSN      DC    C'SYS1.BRODCAST'      DSNAME.\nTU0004   DC    AL2(4,1,1),X'08'      DISP=SHR.\n         SPACE 1\n         PRINT NOGEN\nSYSLBC   DCB   DDNAME=SYSLBC,DSORG=DA,RECFM=F,BLKSIZE=129,KEYLEN=1,    +\n               MACRF=(RIC),OPTCD=R,SYNAD=SYNAD\n         PRINT GEN\nTRTAB    DC    256X'01'            TRANSLATE-AND-TEST TABLE.\n         ORG   TRTAB+C' '\n         DC    X'00'               SKIP BLANKS.\n         ORG   TRTAB+C'n'\n         DC    X'02'               LOOKING FOR SMALL \"n\" ...\n         ORG   TRTAB+C'N'\n         DC    X'02'               ... OR CAPITAL \"N\".\n         ORG\n         SPACE 1\nPSCB     DS    A                   PSCB ADDRESS.\n         SPACE 1\nPPL      DS    0F                  PARSE PARM LIST.\nPPLUPT   DS    A                   POINTER TO UPT.\nPPLECT   DS    A                   POINTER TO ECT.\nPPLECB   DC    A(ECB)              POINTER TO ECB.\nPPLPCL   DC    A(PCL)              POINTER TO PCL.\nPPLANS   DC    A(ANSWERPL)         POINTER TO ANSWER PLACE.\nPPLCBUF  DS    A                   POINTER TO COMMAND BUFFER.\nPPLUWA   DS    A                   USER WORK AREA.\n         SPACE 1\nECB      DC    A(0)                ECB FOR PARSE.\nANSWERPL DS    A                   ANSWER PLACE.\n         SPACE 1\nPCL      IKJPARM\nLENGTHK  IKJKEYWD\n         IKJNAME SHORT\n         IKJNAME LONG\nPAUSEK   IKJKEYWD\n         IKJNAME NOPAUSE\n         IKJNAME PAUSE\nDISPK    IKJKEYWD\n         IKJNAME TOMORROW,ALIAS='PLUS',SUBFLD=DAYSS\n         IKJNAME YESTERDAY,ALIAS='MINUS',SUBFLD=DAYSS\n         IKJNAME MEMBER,SUBFLD=MEMBERS\n         IKJNAME DATE,SUBFLD=DATES\nCLEARK   IKJKEYWD\n         IKJNAME NOCLEAR\n         IKJNAME CLEAR\nDAYSS    IKJSUBF\nDAYS     IKJIDENT 'NUMBER OF DAYS',INTEG,LIST\nMEMBERS  IKJSUBF\nMEMBER   IKJIDENT 'MEMBER NAME',OTHER=ALPHANUM,PROMPT='MEMBER NAME',   +\n               LIST\nDATES    IKJSUBF\nDATE     IKJIDENT 'DATE+',FIRST=ANY,OTHER=ANY,PROMPT='DATE+',          +\n               HELP=('DATE YOU WISH TO SEE QUOTATION FOR+',            +\n               'DATE OF THE FORM MM/DD/YY.'),MAXLNTH=8,VALIDCK=DV,LIST\n         IKJENDP\n         IKJCPPL\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REGS": {"ttr": 6416, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x005\\x00\\x85\\x18/\\x01\\x13\\x13/\\x15\\x02\\x00\\x1b\\x00\\x1c\\x00\\x14\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "2013-05-12T15:02:35", "lines": 27, "newlines": 28, "modlines": 20, "user": "BROIDO"}, "text": "         MACRO\n&NAME    REGS\n.*\n.**********************************************************************\n.*                                                                    *\n.*  COPYRIGHT (C) 1979 BY BROIDO COMPUTER CONSULTING.  ALL RIGHTS     *\n.*  RESERVED EXCEPT:                                                  *\n.*                                                                    *\n.*  PARTICULAR LICENSE IS GRANTED TO DISTRIBUTE THIS MACRO FREE       *\n.*  OF CHARGE, BUT IT MUST NOT BE SOLD.  A SERVICE CHARGE FOR         *\n.*  HANDLING A COLLECTION OF SOFTWARE OF WHICH THIS IS A PART,        *\n.*  ON THE OTHER HAND, IS APPROPRIATE.                                *\n.*                                                                    *\n.*                                  BROIDO COMPUTER CONSULTING        *\n.*                                  BROIDOJ@GMAIL.COM                 *\n.*                                                                    *\n.**********************************************************************\n.*\n.*       I KNOW, ARNOLD...  EVERYONE'S GOT A REGS MACRO!\n.*\n         LCLA  &I\n&I       SETA  0\n.LUP     ANOP\nR&I      EQU   &I\n&I       SETA  &I+1\n         AIF   (&I LE 15).LUP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SMAP": {"ttr": 6657, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00E\\x00\\x85\\x18/\\x01\\x13\\x13/\\x15\\x02\\x00\\xba\\x00\\xbb\\x00\\x91\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "2013-05-12T15:02:45", "lines": 186, "newlines": 187, "modlines": 145, "user": "BROIDO"}, "text": "SMAP     TITLE 'SMAP - TSO COMMAND TO PRODUCE STORAGE MAP.'\n*%A PPLINK NOTEST\n***********************************************************************\n*                                                                     *\n*  COPYRIGHT (C) 1984 BY BROIDO COMPUTER CONSULTING.  ALL RIGHTS      *\n*  RESERVED EXCEPT:                                                   *\n*                                                                     *\n*  PARTICULAR LICENSE IS GRANTED TO DISTRIBUTE THIS PROGRAM FREE      *\n*  OF CHARGE, BUT IT MUST NOT BE SOLD.  A SERVICE CHARGE FOR          *\n*  HANDLING A COLLECTION OF SOFTWARE OF WHICH THIS IS A PART,         *\n*  ON THE OTHER HAND, IS APPROPRIATE.                                 *\n*                                                                     *\n*                                  BROIDO COMPUTER CONSULTING         *\n*                                  BROIDOJ@GMAIL.COM                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nSMAP     CSECT\n         REGS\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         USING SMAP,R12\n         LR    R14,R13\n         LA    R13,SAVE\n         ST    R13,8(,R14)\n         ST    R14,SAVE+4\n         SPACE 1\n         L     R3,16               POINT TO CVT.\n         L     R3,0(,R3)           POINT TO TCB/ASCB WORDS.\n         L     R3,12(,R3)          POINT TO ASCB.\n         L     R4,X'30'(,R3)       POINT TO LDA.\n         L     R1,X'5C0'(,R4)      LOAD TO TOP OF REGION.\n         BAL   R14,OUTHEX          HEXIFY TOP.\n         MVC   HEADTOP,WORK+2      MOVE TOP ADDR.\n         L     R1,X'5CC'(,R4)      LOAD TO LIMIT.\n         BAL   R14,OUTHEX          HEXIFY LIMIT.\n         MVC   HEADLIM,WORK+2      MOVE LIMIT.\n         SRL   R1,10               DIVIDE BY 1024.\n         CVD   R1,WORK             DECIMALIZE LIMIT.\n         UNPK  HEADLIMK,WORK+5(3)  UNPACK LIMIT.\n         OI    HEADLIMK+4,C'0'     FIX SIGN.\n         L     R4,8(,R4)           POINT TO REGION PQE.\n         L     R1,X'18'(,R4)       LOAD BOTTOM OF REGION.\n         BAL   R14,OUTHEX          HEXIFY BOTTOM.\n         MVC   HEADBOT,WORK+2      MOVE BOTTOM.\n         L     R1,X'14'(,R4)       LOAD REGION SIZE.\n         BAL   R14,OUTHEX          HEXIFY REGION.\n         MVC   HEADREG,WORK+2      MOVE REGION.\n         SRL   R1,10               DIVIDE REGION BY 1024.\n         CVD   R1,WORK             DECIMALIZE REGION.\n         UNPK  HEADREGK,WORK+5(3)  UNPACK REGION.\n         OI    HEADREGK+4,C'0'     FIX SIGN.\n         TPUT  HEAD,HEADL          OUTPUT HEADER.\n         L     R5,0(,R4)           POINT TO FIRST FBQE.\nFBQELOOP CR    R4,R5               FBQE POINTER POINT BACK TO PQE?\n         BE    TCB0                B IF YES.  END OF CHAIN.\n         L     R1,12(,R5)          LOAD ADDRESS OF FREE BLOCK.\n         BAL   R14,OUTHEX          HEXIFY.\n         MVC   OUT2ADDR,WORK+2     MOVE ADDRESS OF FREE BLOCK.\n         L     R1,8(,R5)           LOAD SIZE OF FREE BLOCK.\n         BAL   R14,OUTHEX          HEXIFY.\n         MVC   OUT2LEN,WORK+2      MOVE SIZE.\n         SRL   R1,10               DIVIDE SIZE OF FREE BLOCK BY 1K.\n         CVD   R1,WORK             DECIMALIZE.\n         UNPK  OUT2K,WORK+5(3)     UNPACK.\n         OI    OUT2K+4,C'0'        FIX SIGN.\n         TPUT  OUT2,OUT2L          OUTPUT FREE BLOCK LINE.\n         L     R5,0(,R5)           POINT TO NEXT FBQE\n         B     FBQELOOP            LOOP.\nTCB0     L     R3,X'6C'(,R3)       POINT TO ASXB.\n         L     R3,4(,R3)           POINT TO FIRST TCB.\nTCBLOOP  LTR   R3,R3               END OF TCB CHAIN?\n         BNZ   TCB1                B IF NOT.\n         L     R13,SAVE+4\n         LM    R14,R12,12(R13)\n         SR    R15,R15\n         BR    R14                 BYE.\nTCB1     LR    R1,R3               HEXIFY ...\n         BAL   R14,OUTHEX          ... TCB ADDRESS.\n         MVC   OUT4ADDR,WORK+2     MOVE TCB ADDRESS.\n         L     R1,0(,R3)           POINT TO RB.\n         L     R1,12(,R1)          POINT TO CDE.\n         MVC   OUT4NAME,8(R1)      MOVE PROGRAM NAME FROM CDE.\n*        MVC   OUT4NAME,X'60'(R1)  MOVE NAME FROM RB (XA).\n         TPUT  OUT4,OUT4L          OUTPUT TCB LINE.\nSPQE0    L     R4,X'18'(,R3)       POINT TO FIRST SPQE.\nSPQELOOP LTR   R4,R4               END OF SPQE CHAIN?\n         BNZ   SPQE1               B IF NOT.\n         L     R3,X'74'(,R3)       POINT TO NEXT TCB.\n         B     TCBLOOP             LOOP.\nSPQE1    SR    R1,R1               CLEAR INSERT REG.\n         IC    R1,X'A'(,R4)        LOAD SUBPOOL.\n         CVD   R1,WORK             DECIMALIZE SUBPOOL.\n         UNPK  OUT0SP,WORK+6(2)    UNPACK SUBPOOL.\n         OI    OUT0SP+2,C'0'       FIX SIGN.\n         IC    R1,X'B'(,R4)        LOAD KEY.\n         BAL   R14,OUTHEX          HEXIFY KEY.\n         MVC   OUT0KEY,WORK+6      MOVE KEY.\n         TPUT  OUT0,OUT0L          OUTPUT MAJOR LINE.\n         L     R5,4(,R4)           POINT TO FIRST DQE FOR THIS SP.\nDQELOOP  LTR   R5,R5               END OF DQE CHAIN?\n         BNZ   DQE1                B IF NOT.\n         L     R4,0(,R4)           POINT TO SPQE FOR NEXT SUBPOOL.\n         B     SPQELOOP            LOOP.\nDQE1     L     R1,12(,R5)          LOAD LENGTH OF BLOCK IN SUBPOOL.\n         LTR   R1,R1               0 LENGTH?\n         BZ    DQEBUMP             B IF YES.  NULL ENTRY.\n         BAL   R14,OUTHEX          HEXIFY LENGTH.\n         MVC   OUT1LEN,WORK+2      MOVE LENGTH TO OUTPUT LINE.\n         SRL   R1,10               DIVIDE BY 1024 (2**10).\n         CVD   R1,WORK             DECIMALIZE LENGTH/1024.\n         UNPK  OUT1K,WORK+5(3)     UNPACK LENGTH.\n         OI    OUT1K+4,C'0'        FIX SIGN.\n         L     R1,8(,R5)           LOAD ADDRESS OF STORAGE BLOCK.\n         BAL   R14,OUTHEX          HEXIFY ADDRESS.\n         MVC   OUT1ADDR,WORK+2     MOVE ADDRESS TO OUTPUT LINE.\n         TPUT  OUT1,OUT1L          OUTPUT LINE.\nFQE0     L     R6,0(,R5)           POINT TO FIRST FQE.\nFQELOOP  LA    R6,0(,R6)           CLEAR HIGH BYTE.\n         LTR   R6,R6               ANY MORE FREE AREAS IN BLOCK?\n         BNZ   FQE1                B IF YES.\nDQEBUMP  L     R5,4(,R5)           POINT TO NEXT DQE.\n         B     DQELOOP             LOOP.\nFQE1     L     R1,8(,R6)           LOAD HIGH ADDRESS PLUS 1.\n         BCTR  R1,*-*              MAKE IT REAL HIGH ADDRESS.\n         BAL   R14,OUTHEX          HEXIFY HIGH ADDRESS.\n         MVC   OUT3TOP,WORK+2      MOVE TO OUTPUT AREA.\n         S     R1,4(,R6)           SUBTRACT LENGTH FROM HIGH ADDR.\n         LA    R1,1(,R1)           ADD ONE TO GEN. LOW ADDRESS.\n         BAL   R14,OUTHEX          HEXIFY LOW ADDRESS.\n         MVC   OUT3BOT,WORK+2      MOVE TO OUTPUT AREA.\n         L     R1,4(,R6)           LOAD LENGTH.\n         BAL   R14,OUTHEX          HEXIFY LENGTH.\n         MVC   OUT3LEN,WORK+2      MOVE TO OUTPUT AREA.\n         SRL   R1,10               DIVIDE BY 1024.\n         CVD   R1,WORK             DECIMALIZE LENGTH/1024.\n         UNPK  OUT3K,WORK+5(3)     UNPACK TO OUTPUT AREA.\n         OI    OUT3K+4,C'0'        FIX SIGN.\n         TPUT  OUT3,OUT3L          OUTPUT FREE RECORD.\n         L     R6,0(,R6)           POINT TO NEXT FQE.\n         B     FQELOOP             LOOP.\n         SPACE 2\n         TITLE 'SMAP - HEX OUTPUT ROUTINE.'\nOUTHEX   ST    R1,WORK\n         MVO   WORK1,WORK(4)       MOVE OVER TO ALLOW FOR SIGN.\n         UNPK  WORK,WORK1+3(5)     SEPARATE NIBBLES.\n         NC    WORK,=8X'0F'        KILL ZONES.\n         TR    WORK,=C'0123456789ABCDEF' TRANSLATE TO HEX GRAPHICS.\n         BR    14                  RETURN\n         TITLE 'SMAP - DATA AREAS.'\nSAVE     DS    9D\nWORK     DS    D\nWORK1    DS    D\nHEAD     DC    C'PRIVATE('\nHEADREG  DC    C'XXXXXX',C','\nHEADREGK DC    C'#####',C'K) LIMIT('\nHEADLIM  DC    C'XXXXXX',C','\nHEADLIMK DC    C'#####',C'K) BNDS('\nHEADBOT  DC    C'XXXXXX',C'-'\nHEADTOP  DC    C'XXXXXX',C')'\nHEADL    EQU   *-HEAD\nOUT0     DC    C'  SP('\nOUT0SP   DC    C'###',C') KEY('\nOUT0KEY  DC    C'X',C')'\nOUT0L    EQU   *-OUT0\nOUT1     DC    C'     BLOCK ADDR('\nOUT1ADDR DC    C'XXXXXX',C') LEN('\nOUT1LEN  DC    C'XXXXXX',C','\nOUT1K    DC    C'#####',C'K)'\nOUT1L    EQU   *-OUT1\nOUT2     DC    C'FREE BLOCK ADDR('\nOUT2ADDR DC    C'XXXXXX',C') LEN('\nOUT2LEN  DC    C'XXXXXX',C','\nOUT2K    DC    C'#####',C'K)'\nOUT2L    EQU   *-OUT2\nOUT3     DC    C'           FREE ADDR('\nOUT3BOT  DC    C'XXXXXX',C'-'\nOUT3TOP  DC    C'XXXXXX',C') LEN('\nOUT3LEN  DC    C'XXXXXX',C','\nOUT3K    DC    C'#####',C'K)'\nOUT3L    EQU   *-OUT3\nOUT4     DC    C'TCB('\nOUT4ADDR DC    C'XXXXXX',C') RBNAME('\nOUT4NAME DC    C'CCCCCCCC',C')'\nOUT4L    EQU   *-OUT4\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TELL": {"ttr": 6661, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01$\\x00\\x12\\x00\\x85\\x18/\\x01\\x164\\x9f\\x11Q\\x01B\\x00\\xf3\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.36", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "2016-12-14T11:51:12", "lines": 322, "newlines": 243, "modlines": 0, "user": "SBGOLOB"}, "text": "TELL     TITLE 'TELL - TELECONFERENCING TSO COMMAND.'\n*%A PPLINK AC(1)\n***********************************************************************\n*                                                                     *\n*  COPYRIGHT (C) 1978 BY BROIDO COMPUTER CONSULTING.  ALL RIGHTS      *\n*  RESERVED EXCEPT:                                                   *\n*                                                                     *\n*  PARTICULAR LICENSE IS GRANTED TO DISTRIBUTE THIS PROGRAM FREE      *\n*  OF CHARGE, BUT IT MUST NOT BE SOLD.  A SERVICE CHARGE FOR          *\n*  HANDLING A COLLECTION OF SOFTWARE OF WHICH THIS IS A PART,         *\n*  ON THE OTHER HAND, IS APPROPRIATE.                                 *\n*                                                                     *\n*                                  BROIDO COMPUTER CONSULTING         *\n*                                  broidoj@gmail.com                  *\n*                                                                     *\n*  Change Log:                                                        *\n*                                                                     *\n*  2016/12/14 - Sam Golob                                             *\n*                                                                     *\n*    - For z/OS 2.2 -                                                 *\n*    Needed AMODE 31 in general, and in particular, to access the     *\n*    CSCB, which is above the line.  The CSCB is more accurate, to    *\n*    determine that the address space is indeed a TSO user.           *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n* ------                     MACRO FOR HEX DISPLAYS\n*                             (USED FOR DIAGNOSIS)\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R5,SAV4HEX\n         STM   R15,R1,HEXSAVE\n         LA    R1,&FROM\n         LA    R0,&LEN\n         LA    R15,&TO\n         BAL   R5,HEX\n         L     R5,SAV4HEX\n         LM    R15,R1,HEXSAVE\n         MEND\n* ------                     ----------------------\n         YREGS\nTELL     CSECT\nTELL     AMODE 31\nTELL     RMODE 24\n         USING TELL,R15            (ESTABLISH TEMPORARY BASE).\n         B     BEGIN               SKIP OVER HEADER.\nHEAD0    DC    AL1(HEADL)          EXCLUSIVE LENGTH OF HEADER.\nHEAD     DC    C' TELL - for z/OS - &SYSDATE - &SYSTIME - '\n         DC    C'COPYRIGHT (C) BROIDO COMPUTER CONSULTING '\n         DC    C'1978 - '\n         DC    C'ALL RIGHTS RESERVED'\nHEADL    EQU   *-HEAD\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         LR    R12,R15             COPY BASE.\n         USING TELL,R12            (TELL ASSEMBLER).\n         ST    R12,BSAVE           SAVE BASE\n         LR    R14,R13             COPY CALLER'S SAVE AREA POINTER.\n         LA    R13,SAVE            POINT TO MY SAVE AREA.\n         ST    R14,4(,R13)         CHAIN ...\n         ST    R13,8(,R14)         ... SAVE AREAS.\n         SPACE 2\n         L     R2,16                   POINT TO CVT.\n         L     R2,0(,R2)               POINT TO TCB WORDS.\n         L     R2,0(,R2)               POINT TO TCB.\n         L     R2,12(,R2)              POINT TO TIOT.\n         MVC   HIID,0(R2)              MOVE USERID.\n         MVC   ENDID,0(R2)              \"     \"\n         L     R2,0(,R1)           POINT TO COMMAND BUFFER\n         LH    R3,0(,R2)           LOAD LENGTH.\n         LH    R4,2(,R2)           LOAD OFFSET.\n         LA    R4,4(,R4)           ABSOLUTIZE OFFSET.\n         ICM   R4,8,=X'00'         REMEMBER AMODE 31\n         SR    R3,R4               GENERATE LENGTH.\n         CH    R3,=H'7'            GREATER THAN 7?\n         BH    USER1               B IF Y.\n         LTR   R3,R3               ZERO LENGTH?\n         BZ    USER1               B IF Y.\n         AR    R2,R4               POINT TO PARM.\n         CLI   0(R2),C' '          BLANK USERID?\n         BE    USER1               B IF YES.\n         BCTR  R3,*-*              SS-IFY LENGTH.\n         EX    R3,USERMOVE         MOVE USERID ...\n         OC    USERID,=CL8' '      ... UPPERCASE ...\n         MVC   ENDID1,USERID       ...   ...\n         B     USER2               ... AND CONTINUE.\nUSERMOVE MVC   USERID(*-*),0(R2)   EXECUTED USERID MOVE.\n         SPACE 1\nUSER0    VTPUT 'User logged off or not accepting messages.'\nUSER1    VTPUT 'Enter USERID, or /* to exit.'\n         TGET  BUFF,80\n         LTR   R1,R1               NO USERID?\n         BZ    USER1               B IF NONE.\n         LA    R2,BUFF             POINT R2 TO BUFFER.\nULUP     CLI   0(R2),C' '          LEADING BLANK?\n         BNE   MVU                 B IF NOT.\n         LA    R2,1(,R2)           BUMP BUFFER POINTER.\n         BCT   R1,ULUP             LOOP.\n         B     USER1               B IF USER ENTERED ALL BLANKS.\nMVU      CH    R1,=H'7'            USERID TOO LARGE?\n         BNH   MVU1                B IF NOT.\n         VTPUT 'USERID too long.'\n         B     USER1\nMVU1     DS    0H\n         BCTR  R1,*-*              REDUCE LENGTH BY 1 FOR SS LEN.\n         MVC   USERID,=CL8' '      CLEAR USERID.\n         EX    R1,USERMOVE         MOVE USERID.\n         OC    USERID,=CL8' '\n         MVC   ENDID1,USERID       MOVE IT HERE, TOO.\n         CLC   USERID(2),=C'/*'    END?\n         BE    EOD1                B IF YES.\nUSER2    OI    FLAG,FIRST          SET FIRST TIME FLAG.\n         L     R2,X'10'            POINT TO CVT.\n         L     R2,X'22C'(,R2)      POINT TO ASVT.\n         LA    R7,X'210'(,R2)      POINT TO FIRST ASCB ENTRY.\n         L     R6,X'204'(,R2)      NUMBER OF ASVT ENTRIES\n         LR    R2,R7               LOAD STARTING POINT BACK TO R2\n         BCTR  R6,0                ONE LESS. DON'T RUN OVER END.\n*                                  FIRST ONE IS *MASTER* ANYWAY...\nMLUP     DS    0H                  NOT TSO, SO...\n         LA    R2,4(,R2)           BUMP TO NEXT ASCB POINTER.\n         L     R3,0(,R2)           POINT TO ...\n         LA    R3,0(,R3)           ... ASCB.\n         C     R3,=X'80000000'     END OF ASVT'S ASCB POINTERS?\n         BE    NOTYRID             YES. MESSAGE AND ASK USER AGAIN.\n         TM    0(R2),X'80'         THIS ASCB IN USE? (BIT OFF)\n         BZ    CKCSCB              YES. CHECK ITS PROPERTIES.\n         BCT   R6,MLUP             NO. TRY THE NEXT ONE.\n*\nNOTYRID  DS    0H                  NOT YOUR ID. WHADDYA DO?\n         MVC   NOTLID(7),USERID    MOVE DEST. USERID\n         TPUT  NOTLMSG,LNOTLMSG    TELL USER USER NOT LOGGED ON.\n         B     USER1               GET ANOTHER ID.\n* ------------------------------------------------------------------ *\n*   THE CSCB IS A CHAIN OF ENTRIES, EACH RELATING TO AN ACTIVE       *\n*   ADDRESS SPACE.  BUT YOU DON'T HAVE TO RUN THE CHAIN, BECAUSE     *\n*   IF THE ASCB IS ACTIVE, THEN +X'38' OFF IT POINTS TO THE CORRECT  *\n*   CSCB ENTRY THAT RELATES TO THIS PARTICULAR ADDRESS SPACE.        *\n*   FOR AN INACTIVE ADDRESS SPACE, X'38' OFF THE ASCB POINTS TO A    *\n*   FULLWORD OF ZEROS.  SO WE CHECK FOR BOTH CONDITIONS.             *\n* ------------------------------------------------------------------ *\nCKCSCB   DS    0H\n         L     R4,X'38'(,R3)       POINT TO CSCB ENTRY FROM THIS ASCB.\n         LTR   R4,R4               IS THERE A CSCB ENTRY CONNECTED?\n         BNZ   TESTNX1             YES. CHECK IT OUT.\n         BCT   R6,MLUP             NO. CAN'T EVER BE TSO. SO SKIP.\n         B     NOTYRID             END OF ASVT? ASK FOR USER AGAIN.\n*\nTESTNX1  DS    0H                  THERE IS A CSCB ENTRY. EXAMINE IT.\n         CLI   X'1C'(R4),X'01'     GOOD CSCB. THEN IS THIS A TSO USER?\n         BE    TESTNX2             YES FOR SURE. PROCESS THE USERID.\n         BCT   R6,MLUP             NO. ANOTHER TYPE OF JOB OR STC...\n         B     NOTYRID             END OF ASVT? ASK FOR USER AGAIN.\n*\nTESTNX2  DS    0H                  DEFINITELY TSO. BUT IS IT OURS?\n         CLC   USERID(7),8(R4)     IS THIS THE USERID WE WANT?\n         BE    TESTNX3             YES. THEN GO SEND MESSAGES TO IT.\n         BCT   R6,MLUP             NO. NOT THE TSO ID WE ASKED FOR.\n         B     NOTYRID             END OF ASVT? ASK FOR USER AGAIN.\n*\nTESTNX3  DS    0H                  WE HAVE ID. START MESSAGE ENTRY.\n         VTPUT 'Enter messages.  /* to end'\n* ------------------------------------------------------------------ *\n*       UNTIL HERE IS ROUTINE TO GET THE DESTINATION USERID.         *\n*       FROM HERE ON, IS THE ACTUAL MESSAGE SENDING PROCESS.         *\n* ------------------------------------------------------------------ *\nLOOP     TM    FLAG,HMOD+UNLOCK    ARE WE IN HALF DUPLEX MODE?\n         BNM   LOOP0               B IF NOT (OR UNLOCKED).\n         XC    XECB,XECB           CLEAR STAX ECB.\n         WAIT  ECB=XECB            WAIT.\n         VTPUT '.Enter messages.'\nLOOP0    TGET  BUFF,80             GET INPUT.\n         TM    FLAG,KILLSTAX       KILL STAX EXIT?\n         BZ    LOOP1               B IF NOT\n         NI    FLAG,X'FF'-KILLSTAX-STAXON   OFF STAX FLAGS.\n         STAX  ,                   CANCEL STAX\nLOOP1    LTR   R2,R1               SAVE AND TEST LENGTH.\n         BZ    LOOP                B IF NULL INPUT.\n         TM    FLAG,FIRST          FIRST MESSAGE TO THIS USER?\n         CH    R2,=H'2'            LEN = 2?\n         BL    LOOP7               B IF LOW.\n         BH    LOOP2               B IF HIGH\n         MVC   TESTGA,BUFF         MOVE CHARACTERS.\n         B     LOOP6               CONTINUE.\nLOOP2    LA    R1,BUFF-3(R2)       POINT TO LAST CHAR OF BUFFER -3\n         CLI   0(R1),C' '          PRECEDED BY BLANK?\n         BNE   LOOP7\n         MVC   TESTGA,1(R1)        MOVE CHARACTERS.\nLOOP6    OC    TESTGA,=C'  '       UPPERCASE.\n         CLC   TESTGA,=C'GA'       IS IT GO AHEAD?\n         BNE   LOOP7               B IF NOT.\n         TM    FLAG,HMOD           IN HALF DUPLEX?\n         BZ    LOOP8               B IF NOT.\n         NI    FLAG,X'FF'-UNLOCK   OFF UNLOCK KEYBOARD FLAG.\n         VTPUT '.Waiting for response.'\n         B     LOOP8\nLOOP7    CH    R2,=H'77'           LENGTH GREATER THAN 77?\n         BNL   LOOP8\n         LA    R2,2(,R2)           BUMP LENGTH.\n         LA    R1,BUFF-1(R2)       POINT TO LAST CHAR.\n         MVI   0(R1),C'-'          MOVE A DASH.\nLOOP8    CLC   BUFF(2),=C'/*'      END?\n         BE    EOD .               B IF YES.\n         CLI   BUFF,C'.'           COMMAND?\n         BNE   PUT                 B IF NOT.\n         OI    BUFF+1,C' '         UPPERCASE.\n         CLI   BUFF+1,C'H'         HALF DUPLEX MODE?\n         BNE   CKFULL              B IF NOT.\n         OI    FLAG,HMOD           ON HALF DUPLEX FLAG.\n         NI    FLAG,X'FF'-UNLOCK   OFF UNLOCK FLAG.\n         VTPUT '.Half duplex mode set; waiting for response.'\n         TM    FLAG,STAXON         STAX SET?\n         BO    LOOP                B IF YES.\n         OI    FLAG,STAXON         ON STAX FLAG.\n         LA    R1,STAXLIST         SET ...\n         STAX  STAXEXIT,MF=(E,(1)) ... STAX EXIT.\n         B     LOOP\nCKFULL   CLI   BUFF+1,C'F'         FULL DUPLEX MODE?\n         BNE   CERR                B IF NOT.\n         VTPUT '.Full duplex mode restored.'\n         NI    FLAG,X'FF'-HMOD-UNLOCK OFF HALF DUPLEX FLAG.\n         TM    FLAG,STAXON         STAX ON?\n         BZ    LOOP                B IF NOT.\n         STAX  ,                   OFF STAX EXIT.\n         B     LOOP\nCERR     VTPUT '.Invalid command.  Valid commands are .H and .F'\n         B     LOOP\nPUT      TM    FLAG,FIRST          FIRST TIME FOR THIS USER?\n         BZ    PUT0                B IF NOT.\n         NI    FLAG,X'FF'-FIRST    OFF FIRST FLAG.\n*        MODESET KEY=ZERO,MODE=SUP\n         TPUT  HIMSG,LEHIMSG,,NOWAIT,NOHOLD,BREAKIN,HIGHP,             +\n               USERIDL=USERID\n*        LR    R6,R15\n*        MODESET KEY=NZERO,MODE=PROB\n*        LTR   R6,R6\n         LTR   R15,R15\n         BNZ   USER0\n*UT0     MODESET KEY=ZERO,MODE=SUP\nPUT0     TPUT  BUFF,(2),,NOWAIT,NOHOLD,BREAKIN,HIGHP,                  +\n               USERIDL=USERID\n*        LR    R6,R15\n*        MODESET KEY=NZERO,MODE=PROB\n*        LTR   R6,R6\n         LTR   R15,R15\n         BZ    LOOP\n         B     USER0\nEOD      TM    FLAG,FIRST          FIRST TIME FLAG STILL SET?\n         BZ    EOD0                B IF NOT.\n         TPUT  EMSG1,LEMSG1        SEND WARNING END MESSAGES.\n         B     EOD1\nEOD0     TPUT  EMSG,LEEMSG,,,,BREAKIN,USERIDL=USERID\nEOD1     VTPUT 'BYE.'\n         L     R13,SAVE+4\n         LM    R14,R12,12(R13)\n         SR    R15,R15\n         BR    R14\n         SPACE 1\n         USING STAXEXIT,R15\nSTAXEXIT L     R12,BSAVE           RELOAD BASE\n         LR    R5,R14              SAVE RETURN ADDR.\n         DROP  R15\nSTAX1    TM    XECB,X'40'          ECB POSTED?\n         BZ    STAX2               B IF NO. GO POST.\n         VTPUT '.Full duplex mode restored.'\n         NI    FLAG,X'FF'-HMOD-UNLOCK  SET FULL DUPLEX.\n         OI    FLAG,KILLSTAX\n         BR    R5                  RETURN\nSTAX2    POST  XECB                POST IT.\n         OI    FLAG,UNLOCK         TURN ON UNLOCK FLAG.\n         BR    R5                  RETURN.\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H                    HEX DISPLAY ROUTINE - KEEP IN\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         BR    R5                    RETURN TO CALLER\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nSAVE     DS    9D\nSAVE1401 DS    5F\nHEXSAVE  DS    3F\nSAV4HEX  DC    F'0'\nUSERID   DC    CL8' '\n         DC    C' '\nMESSLINE DS    CL40\nBSAVE    DS    A                   BASE SAVE AREA.\nXECB     DC    A(0)                ECB\nEMSG     DC    C'END OF MESSAGES FROM '\nENDID    DC    CL7' '\nLEEMSG   EQU   *-EMSG\nEMSG1    DC    C'.WARNING:  NO MESSAGES WERE SENT TO '\nENDID1   DC    CL7' '\nLEMSG1   EQU   *-EMSG1\nHIMSG    DC    C'FOLLOWING MESSAGES FROM '\nHIID     DC    CL7' '\n         DC    C'-'\nLEHIMSG  EQU   *-HIMSG\nNOTLMSG  EQU   *\nNOTLID   DC    CL7' '\n         DC    C' NOT LOGGED ON.'\nLNOTLMSG EQU   *-NOTLMSG\nBUFF     DS    CL80\nTESTGA   DS    CL2\n         SPACE 1\nFLAG     DC    X'00'               OPTION FLAGS.\nHMOD     EQU   B'10000000'         HALF DUPLEX MODE FLAG.\nUNLOCK   EQU   B'01000000'         HALF DUPLEX, UNLOCKED.\nFIRST    EQU   B'00100000'         FIRST MESSAGE FLAG.\nSTAXON   EQU   B'00010000'         STAX EXIT IN FORCE.\nKILLSTAX EQU   B'00001000'         KILL STAX EXIT.\n         SPACE 1\nSTAXLIST STAX  STAXEXIT,MF=L\n         LTORG\n         END   TELL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TELL$": {"ttr": 6667, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00Y\\x01\\x05\\x13_\\x01\\x164\\x9f\\tX\\x00 \\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2005-05-15T00:00:00", "modifydate": "2016-12-14T09:58:59", "lines": 32, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,\n//     PARM='OBJECT,NODECK,ESD,RLD,BATCH,FLAG(5)'\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.JRB.MACLIB.ASM   (FILE 423)\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT493.FILE423(TELL)\n//SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(2,2))\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSALLDA,SPACE=(CYL,(4,4)),DISP=(,PASS),\n//            DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY   TELL\n SETSSI  CB493423\n SETCODE AC(0)\n NAME    TELL(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TERMSIZ$": {"ttr": 6669, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x005\\x01\\x126?\\x01\\x13\\x15\\x0f\\x10Y\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2012-12-28T00:00:00", "modifydate": "2013-05-30T10:59:35", "lines": 28, "newlines": 28, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD,RENT)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT487.FILE423(TERMSIZE)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,RENT'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n ORDER   TERMSIZE\n SETSSI  CB487300\n SETCODE AC(0)\n ENTRY   TERMSIZE\n NAME    TERMSIZE(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TERMSIZE": {"ttr": 6913, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01,\\x00B\\x00y\\x17\\x9f\\x01\\x19\\x18_\\x14P\\x01\\xb6\\x00$\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.44", "flags": 0, "createdate": "1979-06-28T00:00:00", "modifydate": "2019-07-04T14:50:42", "lines": 438, "newlines": 36, "modlines": 0, "user": "SBGOLOB"}, "text": "TERMSIZE TITLE 'TERMSIZE - COMMAND TO RETURN GTSIZE INFO TO DISPLAY.'\n*\n***********************************************************************\n*                                                                     *\n*    TERMSIZE - THE GTSIZE MACRO RETURNS THE NUMBER OF ROWS           *\n*               FOR THE ISSUING TERMINAL IN R0.                       *\n*               THE GTSIZE MACRO RETURNS THE NUMBER OF COLUMNS        *\n*               FOR THE ISSUING TERMINAL IN R1.                       *\n*                                                                     *\n*               WE JUST FORMAT THE OUTPUT.                            *\n*               (REENTRANT)                                           *\n*                                                                     *\n*    ADAPTED FROM JEFF BROIDO'S TERMTYPE PROGRAM AS FOLLOWS:          *\n*                                                                     *\n*    1. WE TAKE FULLER ADVANTAGE OF THE GTSIZE MACRO INFORMATION.     *\n*    2. WE DO NOT REQUIRE A CLIST TO FORMAT THE OUTPUT OF THE         *\n*         GTSIZE MACRO. THIS COMMAND FORMATS ITS OWN OUTPUT.          *\n*    3. CHANGED NAME TO TERMSIZE SO AS NOT TO CONFUSE WITH TERMTYPE.  *\n*    4. TSO OUTPUT IS NOW PUTLINE, SO IT CAN BE CAPTURED AND          *\n*         DISPLAYED SCROLLABLE.                                       *\n*                                                                     *\n*           SAMPLE OUTPUT                                             *\n*                                                                     *\n*    * GTSIZE-BASED TERMINAL DISPLAY *                                *\n*      ------------ -------- -------                                  *\n*    THIS TERMINAL HAS     32  ROWS                                   *\n*    THIS TERMINAL HAS     80  COLUMNS                                *\n*                                                                     *\n***********************************************************************\n* ------------------------------------------------------------------- *\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\nSP000    EQU   0\n*\nTERMSIZE CSECT\nTERMSIZE AMODE 31\nTERMSIZE RMODE 24\n         YREGS                      NOW IBM HAS DONE IT\n         STM   R14,R12,12(R13)      SAVE REGISTERS\n         USING TERMSIZE,R12\n         LR    R12,R15              BASE REGISTER\n         L     R0,WORKDL\n         GETMAIN RU,LV=WORKDL,SP=SP000,LOC=BELOW\n         LR    R9,R1\n         USING WORKD,R9\n         ST    R9,GOTADDR\n         LA    R2,SAVE              NEW SAVE AREA\n         ST    R2,8(,R13)           PUT IT AWAY\n         ST    R13,SAVE+4           OLD SAVE AREA\n         LR    R13,R2               POINT R13 TO NEW SAVE AREA\n*                          GET TERMINAL SIZE\n         GTSIZE\n*\n         ST    R0,ROWS                 STORE NUMBER OF ROWS\n         ST    R1,COLS                 STORE NUMBER OF COLUMNS\n         LR    R6,R0                   GET NUMBER OF ROWS\n         CVD   R6,DWORK                CONVERT TO PACKED\n         MVC   MESROWS,LITROWS         MOVE LITERAL PART\n         MVC   MESCOLS,LITCOLS           OF MESSAGES\n         MVC   NUMROWS,MASK7A          EDIT MASK\n         ED    NUMROWS,DWORK+5         DISPLAY NUMBER IN MESSAGE\n         MVI   NUMROWS+6,C' '\n         MVC   MESROWS+18(7),NUMROWS\n         LR    R6,R1                   GET NUMBER OF COLUMNS\n         CVD   R6,DWORK                CONVERT TO PACKED\n         MVC   NUMCOLS,MASK7A          EDIT MASK\n         ED    NUMCOLS,DWORK+5         DISPLAY NUMBER IN MESSAGE\n         MVI   NUMCOLS+6,C' '\n         MVC   MESCOLS+18(7),NUMCOLS\n         APUT  TITLEA,L'TITLEA         PUT OUT THE ENTIRE DISPLAY\n         APUT  TITLEU,L'TITLEU\n         APUT  MESROWS,L'MESROWS\n         APUT  MESCOLS,L'MESCOLS\n*\n         L     R13,SAVE+4           LOAD OLD SAVE AREA\n         L     R9,GOTADDR           POINT TO ADDRESS TO FREEMAIN\n         FREEMAIN RU,LV=WORKDL,A=(R9),SP=SP000\n         DROP  R9\n         LM    R14,R12,12(R13)      PUT REGISTERS BACK\n         BR    R14                  RETURN TO CALLER\n*\nTITLEA   DC    C'* GTSIZE-BASED TERMINAL DISPLAY *'\nTITLEU   DC    C'  ------------ -------- -------  '\nMASK7A   DC    XL7'40202020212020'\nLITROWS  DC    C'THIS TERMINAL HAS         ROWS'\nLITCOLS  DC    C'THIS TERMINAL HAS         COLUMNS'\n         LTORG\n*\nWORKD    DSECT\n         DS    0D\nSAVE     DS    18F                  SAVE AREA\nGOTADDR  DS    F\nROWS     DS    F\nCOLS     DS    F\nNUMROWS  DS    CL7\nNUMCOLS  DS    CL7\nMESROWS  DC    C'THIS TERMINAL HAS         ROWS'\nMESCOLS  DC    C'THIS TERMINAL HAS         COLUMNS'\nDWORK    DS    D\nWORKDL   EQU   *-WORKD\n         END\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUEMNTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   255                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         EJECT\n         IHAPSA   LIST=YES                                     HD APR88\n         EJECT                                                 HD APR88\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   14,12,12(13)       SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES            RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    1,8(13)            OUR SAVE AREA POINTER\n         ST    13,4(1)            POINTER TO CALLERS SAVE AREA\n         LR    13,1               @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(R13)         POINT TO CALLERS RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 ASSUME BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 ASSUME BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(RML)               MESSAGE LENGTH\n         STH   R15,PUTLEN                 PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    2,R13                    @OUR SAVE AREA\n         LR    3,R15                    SAVE RETURN CODE\n         L     R13,4(R13)               @CALLERS SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,3                    RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END   EPUTL\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TERMSZ": {"ttr": 6921, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x019\\x00X\\x00y\\x17\\x9f\\x01\\x19\\x19\\x1f\\x16'\\x01\\xf1\\x00$\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.57", "flags": 0, "createdate": "1979-06-28T00:00:00", "modifydate": "2019-07-10T16:27:58", "lines": 497, "newlines": 36, "modlines": 0, "user": "SBGOLOB"}, "text": "TERMSZ   TITLE 'TERMSZ - COMMAND TO RETURN TERMINAL SIZE INFO.'\n*\n***********************************************************************\n*                                                                     *\n*    REMARK -   THIS COMMAND IS A PROGRAMMING EXERCISE, AND WAS       *\n*               DERIVED FROM THE TERMSIZE TSO COMMAND.                *\n*               (SEE COMMENTS BELOW)                                  *\n*                                                                     *\n*    TERMSZ -   THE GTSIZE MACRO RETURNS THE NUMBER OF ROWS           *\n*               FOR THE ISSUING TERMINAL IN R0.                       *\n*               THE GTSIZE MACRO RETURNS THE NUMBER OF COLUMNS        *\n*               FOR THE ISSUING TERMINAL IN R1.                       *\n*                                                                     *\n*               BUT WE DO IT THE HARD WAY, WITHOUT THE GTSIZE         *\n*               MACRO.  WE HAVE TO BE APF-AUTHORIZED, AND WE          *\n*               GET THE INFO DIRECTLY FROM THE TSB.                   *\n*                                                                     *\n*               TSB + X'66'  -  NUMBER OF ROWS     (ONE BYTE)         *\n*               TSB + X'67'  -  NUMBER OF COLUMNS  (ONE BYTE)         *\n*                                                                     *\n*               NEVERTHELESS, WE CAN CONVERT THIS SOURCE CODE         *\n*               INTO THE EQUIVALENT (NON-AUTHORIZED) GTSIZE-          *\n*               BASED CODE.  SEE REMARKS BELOW AT THE GTSIZE          *\n*               MACRO CALL, WHICH IS CURRENTLY COMMENTED OUT.         *\n*                                                                     *\n*               (REENTRANT)                                           *\n*                                                                     *\n*    ADAPTED FROM JEFF BROIDO'S TERMTYPE PROGRAM AS FOLLOWS:          *\n*                                                                     *\n*    1. WE TAKE FULLER ADVANTAGE OF THE GTSIZE MACRO INFORMATION.     *\n*    2. WE DO NOT REQUIRE A CLIST TO FORMAT THE OUTPUT OF THE         *\n*         GTSIZE MACRO. THIS COMMAND FORMATS ITS OWN OUTPUT.          *\n*    3. CHANGED NAME TO TERMSZ SO AS NOT TO CONFUSE WITH TERMSIZE.    *\n*    4. TSO OUTPUT IS NOW PUTLINE, SO IT CAN BE CAPTURED AND          *\n*         DISPLAYED SCROLLABLE.                                       *\n*                                                                     *\n*           SAMPLE OUTPUT                                             *\n*                                                                     *\n*    * TERMINAL SIZE DIRECTLY FROM TSB *                              *\n*      -------- ---- -------- ---- ---                                *\n*    THIS TERMINAL HAS     32  ROWS                                   *\n*    THIS TERMINAL HAS     80  COLUMNS                                *\n*                                                                     *\n***********************************************************************\n* ------------------------------------------------------------------- *\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\nSP000    EQU   0\n*\nTERMSZ   CSECT\nTERMSZ   AMODE 31\nTERMSZ   RMODE 24\n         YREGS                      NOW IBM HAS DONE IT\n         STM   R14,R12,12(R13)      SAVE REGISTERS\n         USING TERMSZ,R12\n         LR    R12,R15              BASE REGISTER\n         L     R0,WORKDL\n         GETMAIN RU,LV=WORKDL,SP=SP000,LOC=BELOW\n         LR    R9,R1\n         USING WORKD,R9\n         ST    R9,GOTADDR\n         LA    R2,SAVE              NEW SAVE AREA\n         ST    R2,8(,R13)           PUT IT AWAY\n         ST    R13,SAVE+4           OLD SAVE AREA\n         LR    R13,R2               POINT R13 TO NEW SAVE AREA\n* ------------------------------------------------------------------- *\n*                          GET TERMINAL SIZE\n*        GTSIZE\n*                        SEE EXPLANATION BELOW\n* ------------------------------------------------------------------- *\n*        PERFORM THE FUNCTION OF THE GTSIZE MACRO, BUT GET THE        *\n*        INFORMATION DIRECTLY FROM THE TSB.  UNFORTUNATELY, THE       *\n*        TSB IS IN PROTECTED STORAGE, KEY 6, SP 231. AND WE HAVE      *\n*        TO BE APF-AUTHORIZED AND GET INTO KEY 0 TO ACCESS IT.        *\n* ------------------------------------------------------------------- *\n*        SINCE THE GTSIZE MACRO CALLS AN SVC (94), IT CAN GET         *\n*        INTO SUPERVISOR STATE AND DO THE STORAGE FETCH, RETURNING    *\n*        TO PROBLEM STATE.  SO THE \"GTSIZE\" VERSION OF THIS PROGRAM   *\n*        DOES NOT HAVE TO BE APF-AUTHORIZED, WHILE THIS PROGRAM HAS   *\n*        TO BE APF-AUTHORIZED.                                        *\n* ------------------------------------------------------------------- *\n*        TO CONVERT THIS PROGRAM TO THE NON-AUTHORIZED FORM, JUST     *\n*        UNCOMMENT THE GTSIZE MACRO, AND COMMENT OUT ALL THE LINES    *\n*        BELOW, IN-BETWEEN THE ARROW COMMENTS (BELOW AND ABOVE).      *\n* ------------------------------------------------------------------- *\n*                PERFORM THE GTSIZE MACRO FUNCTIONALITY               *\n* ------------------------------------------------------------------- *\n* ----------------------------------- >>>>>   BELOW   <<<<< --------- *\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         L     R5,X'224'               POINT TO ASCB\n         L     R5,X'3C'(,R5)           POINT TO TSB\n         XR    R0,R0                   CLEAR R0 AND R1 AS\n         XR    R1,R1                     WORK REGISTERS\n         STM   R0,R1,SAVER01           PRESERVE R0 AND R1\n         MODESET KEY=ZERO\n         LM    R0,R1,SAVER01           RESTORE  R0 AND R1\n         IC    R0,X'66'(,R5)           RETRIEVE NUMBER OF ROWS\n         IC    R1,X'67'(,R5)           RETRIEVE NUMBER OF COLUMNS\n         STM   R0,R1,SAVER01           PRESERVE R0 AND R1\n         MODESET KEY=NZERO\n         LM    R0,R1,SAVER01           RESTORE  R0 AND R1\n* ----------------------------------- >>>>>   ABOVE   <<<<< --------- *\n         ST    R0,ROWS                 STORE NUMBER OF ROWS\n         ST    R1,COLS                 STORE NUMBER OF COLUMNS\n         LR    R6,R0                   GET NUMBER OF ROWS\n         CVD   R6,DWORK                CONVERT TO PACKED\n         MVC   MESROWS,LITROWS         MOVE LITERAL PART\n         MVC   MESCOLS,LITCOLS           OF MESSAGES\n         MVC   NUMROWS,MASK7A          EDIT MASK\n         ED    NUMROWS,DWORK+5         DISPLAY NUMBER IN MESSAGE\n         MVI   NUMROWS+6,C' '\n         MVC   MESROWS+18(7),NUMROWS\n         LR    R6,R1                   GET NUMBER OF COLUMNS\n         CVD   R6,DWORK                CONVERT TO PACKED\n         MVC   NUMCOLS,MASK7A          EDIT MASK\n         ED    NUMCOLS,DWORK+5         DISPLAY NUMBER IN MESSAGE\n         MVI   NUMCOLS+6,C' '\n         MVC   MESCOLS+18(7),NUMCOLS\n         APUT  TITLEA,L'TITLEA         PUT OUT THE ENTIRE DISPLAY\n         APUT  TITLEU,L'TITLEU\n         APUT  MESROWS,L'MESROWS\n         APUT  MESCOLS,L'MESCOLS\n*\nRETURN   DS    0H\n         L     R13,SAVE+4           LOAD OLD SAVE AREA\n         L     R9,GOTADDR           POINT TO ADDRESS TO FREEMAIN\n         FREEMAIN RU,LV=WORKDL,A=(R9),SP=SP000\n         DROP  R9\n         LM    R14,R12,12(R13)      PUT REGISTERS BACK\n         BR    R14                  RETURN TO CALLER\n*\nNOTAUTH  DS    0H\n         APUT  AUTHMSG,L'AUTHMSG\n         B     RETURN\nTITLEA   DC    C'* TERMINAL SIZE DIRECTLY FROM TSB *'\nTITLEU   DC    C'  -------- ---- -------- ---- ---  '\n*TITLEA  DC    C'* GTSIZE-BASED TERMINAL DISPLAY *'\n*TITLEU  DC    C'  ------------ -------- -------  '\nMASK7A   DC    XL7'40202020212020'\nLITROWS  DC    C'THIS TERMINAL HAS         ROWS'\nLITCOLS  DC    C'THIS TERMINAL HAS         COLUMNS'\nAUTHMSG  DC    C'THIS COMMAND MUST BE APF-AUTHORIZED.'\n         LTORG\n*\nWORKD    DSECT\n         DS    0D\nSAVE     DS    18F                  SAVE AREA\nSAVER01  DS    2F\nGOTADDR  DS    F\nROWS     DS    F\nCOLS     DS    F\nNUMROWS  DS    CL7\nNUMCOLS  DS    CL7\nMESROWS  DC    C'THIS TERMINAL HAS         ROWS'\nMESCOLS  DC    C'THIS TERMINAL HAS         COLUMNS'\nDWORK    DS    D\nWORKDL   EQU   *-WORKD\n         END\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUEMNTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   255                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         EJECT\n         IHAPSA   LIST=YES                                     HD APR88\n         EJECT                                                 HD APR88\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   14,12,12(13)       SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES            RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    1,8(13)            OUR SAVE AREA POINTER\n         ST    13,4(1)            POINTER TO CALLERS SAVE AREA\n         LR    13,1               @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(R13)         POINT TO CALLERS RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 ASSUME BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 ASSUME BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(RML)               MESSAGE LENGTH\n         STH   R15,PUTLEN                 PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    2,R13                    @OUR SAVE AREA\n         LR    3,R15                    SAVE RETURN CODE\n         L     R13,4(R13)               @CALLERS SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,3                    RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END   EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TERMSZ$": {"ttr": 7176, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00%\\x01\\x126?\\x01\\x19\\x19\\x1f\\x161\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2012-12-28T00:00:00", "modifydate": "2019-07-10T16:31:25", "lines": 28, "newlines": 28, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD,RENT)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT498.FILE423(TERMSZ)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,RENT'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n ORDER   TERMSZ\n SETSSI  CB498423\n SETCODE AC(1)\n ENTRY   TERMSZ\n NAME    TERMSZ(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TERMTYP": {"ttr": 7178, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00I\\x01\\x13\\x14\\x7f\\x01\\x13\\x14\\x8f\\x01\\x04\\x00\\x06\\x00\\x03\\x00\\x00\\xc3\\xd3\\xc9\\xe2\\xe3@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2013-05-27T00:00:00", "modifydate": "2013-05-28T01:04:49", "lines": 6, "newlines": 3, "modlines": 0, "user": "CLIST"}, "text": "PROC 0\n/*  YOU SHOULD SHORTEN THE NAME OF THIS CLIST TO TTYP OR WHATEVER  */\n/*  IS CONVENIENT TO TYPE, LIKE TTYP OR TRMT OR TT....             */\nWRITE  **  TERMINAL SIZE DISPLAY  **\nTERMTYPE\nWRITE   THIS TERMINAL HAS &LASTCC LINES.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TERMTYP$": {"ttr": 7180, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x13\\x01\\x126?\\x01\\x13\\x14\\x7f\\x129\\x00\\x1d\\x00\\x1c\\x00\\x00\\xc1\\xe2\\xd4\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2012-12-28T00:00:00", "modifydate": "2013-05-27T12:39:13", "lines": 29, "newlines": 28, "modlines": 0, "user": "ASMJCL"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.FILE300.MACROS\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(TERMTYPE)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n ORDER   TERMTYPE\n SETSSI  CB487300\n SETCODE AC(0)\n ENTRY   TERMTYPE\n NAME    TERMTYPE(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TERMTYPE": {"ttr": 7182, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\"\\x00y\\x17\\x9f\\x01\\x13\\x14\\x8f\\x01\\x01\\x004\\x00$\\x00!\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1979-06-28T00:00:00", "modifydate": "2013-05-28T01:01:22", "lines": 52, "newlines": 36, "modlines": 33, "user": "BROIDO"}, "text": "TERMTYPE TITLE 'TERMTYPE - COMMAND TO RETURN GTSIZE INFO FOR CLISTS.'\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  COPYRIGHT (C) 1979 BY JEFFREY R. BROIDO.  ALL RIGHTS RESERVED.     *\n*                                                                     *\n*  LICENSE IS HEREBY GRANTED TO WESTERN UNION INTERNATIONAL (A        *\n*  SUBSIDIARY OF MCI, INCORPORATED) AND ITS AFFILIATES TO USE THIS    *\n*  PROGRAM.  HOWEVER, IT MUST NOT BE BE SOLD, GIVEN, OR OTHERWISE     *\n*  DISTRIBUTED TO ANY OTHER COMPANY OR DATA CENTER WITHOUT PRIOR      *\n*  WRITTEN PERMISSION OF:                                             *\n*                                                                     *\n*                                  BROIDO COMPUTER CONSULTING         *\n*                                  BROIDOJ@GMAIL.COM                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        TERMTYPE - RETURNS IN &LASTCC (R15) THE CONTENTS OF R0       *\n*                   AFTER A GTSIZE MACRO HAS BEEN EXECUTED.  THAT     *\n*                   IS, &LASTCC WILL = 0 IF TERMINAL IS A TTY, AND    *\n*                   24 (OR 43 OR USER DEFINED SCREEN DEPTH) FOR A     *\n*                   DISPLAY TERMINAL.                                 *\n*                                                                     *\n*                                  JEFFREY  R.  BROIDO                *\n*                                  J+J - MIC - RARITAN                *\n*                                  28     JUNE    1979                *\n*                                                                     *\n***********************************************************************\n*\nTERMTYPE CSECT\n         YREGS                      NOW IBM HAS DONE IT\n         STM   R14,R12,12(R13)      SAVE REGISTERS\n         USING TERMTYPE,R12\n         LR    R12,R15              BASE REGISTER\n         LA    R2,SAVE              NEW SAVE AREA\n         ST    R2,8(,R13)           PUT IT AWAY\n         ST    R13,SAVE+4           OLD SAVE AREA\n         LR    R13,R2               POINT R13 TO NEW SAVE AREA\n*                                   GET TERMINAL SIZE\n         GTSIZE\n*\n         LR    R15,R0               LOAD SIZE IN RETURN CODE R15\n         SPACE 1\n         L     R13,SAVE+4           LOAD OLD SAVE AREA\n         LM    R0,R12,20(R13)       PUT OTHER REGISTERS BACK\n         L     R14,12(,R13)         INCLUDING R14\n         BR    R14                  RETURN TO CALLER\n*\nSAVE     DS    18F                  SAVE AREA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TF": {"ttr": 7184, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x05\\x00\\x85\\x18/\\x01\\x13\\x13/\\x15\\x03\\x00\\x16\\x00\\x17\\x00\\x14\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "2013-05-12T15:03:05", "lines": 22, "newlines": 23, "modlines": 20, "user": "BROIDO"}, "text": "         MACRO\n&NAME    TF    &FLAG\n.*\n.**********************************************************************\n.*                                                                    *\n.*  COPYRIGHT (C) 1981 BY BROIDO COMPUTER CONSULTING.  ALL RIGHTS     *\n.*  RESERVED EXCEPT:                                                  *\n.*                                                                    *\n.*  PARTICULAR LICENSE IS GRANTED TO DISTRIBUTE THIS MACRO FREE       *\n.*  OF CHARGE, BUT IT MUST NOT BE SOLD.  A SERVICE CHARGE FOR         *\n.*  HANDLING A COLLECTION OF SOFTWARE OF WHICH THIS IS A PART,        *\n.*  ON THE OTHER HAND, IS APPROPRIATE.                                *\n.*                                                                    *\n.*                                  BROIDO COMPUTER CONSULTING        *\n.*                                  BROIDOJ@GMAIL.COM                 *\n.*                                                                    *\n.**********************************************************************\n.*\n         LCLC  &L\n&L       SETC  'L'''\n&NAME    TM    &FLAG,&L.&FLAG      TEST FLAG.\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VPUT": {"ttr": 7186, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x16\\x00\\x85\\x18/\\x01\\x13\\x13/\\x15\\x03\\x00+\\x00,\\x00#\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "2013-05-12T15:03:16", "lines": 43, "newlines": 44, "modlines": 35, "user": "BROIDO"}, "text": "         MACRO\n&NAME    VPUT  &M,&MF=I,&MLOC=\n.*\n.**********************************************************************\n.*                                                                    *\n.*  COPYRIGHT (C) 1979 BY BROIDO COMPUTER CONSULTING.  ALL RIGHTS     *\n.*  RESERVED EXCEPT:                                                  *\n.*                                                                    *\n.*  PARTICULAR LICENSE IS GRANTED TO DISTRIBUTE THIS MACRO FREE       *\n.*  OF CHARGE, BUT IT MUST NOT BE SOLD.  A SERVICE CHARGE FOR         *\n.*  HANDLING A COLLECTION OF SOFTWARE OF WHICH THIS IS A PART,        *\n.*  ON THE OTHER HAND, IS APPROPRIATE.                                *\n.*                                                                    *\n.*                                  BROIDO COMPUTER CONSULTING        *\n.*                                  BROIDOJ@GMAIL.COM                 *\n.*                                                                    *\n.**********************************************************************\n.*\n         LCLB  &PAIR\n         LCLA  &LEN,&I\n&LEN     SETA  K'&M+2\n&PAIR    SETB  0\n&I       SETA  1\n.LOOP    ANOP\n&I       SETA  &I+1+&PAIR\n         AIF   (&I GE K'&M).DONE\n&PAIR    SETB  ('&M'(&I,2) EQ '''''' OR '&M'(&I,2) EQ '&&')\n&LEN     SETA  &LEN-&PAIR\n         AGO   .LOOP\n.DONE    ANOP\n         AIF   ('&MF' EQ 'L').VL\n&NAME    LA    1,SYSPRINT          LOAD DCB ADDRESS.\n         BAL   0,VPUT&SYSNDX       LOAD MSG ADDRESS\n         DC    AL2(&LEN),AL2(0)    RCW - LENGTH OF MESSAGE.\n         AIF   (&LEN LE 4).NOMSG\n&MLOC    DC    C&M\n.NOMSG   ANOP\nVPUT&SYSNDX PUT (1),(0)\n         MEXIT\n.VL      ANOP\n&NAME    DC    AL2(&LEN),AL2(0)    RCW - LENGTH OF MESSAGE.\n&MLOC    DC    C&M\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTPUT": {"ttr": 7425, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00'\\x00\\x85\\x18/\\x01\\x13\\x13/\\x15\\x03\\x003\\x004\\x00\\x16\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "2013-05-12T15:03:27", "lines": 51, "newlines": 52, "modlines": 22, "user": "BROIDO"}, "text": "         MACRO\n&NAME    VTPUT &M,&MLAB,&MF=I\n.*\n.**********************************************************************\n.*                                                                    *\n.*  COPYRIGHT (C) 1979 BY BROIDO COMPUTER CONSULTING.  ALL RIGHTS     *\n.*  RESERVED EXCEPT:                                                  *\n.*                                                                    *\n.*  PARTICULAR LICENSE IS GRANTED TO DISTRIBUTE THIS MACRO FREE       *\n.*  OF CHARGE, BUT IT MUST NOT BE SOLD.  A SERVICE CHARGE FOR         *\n.*  HANDLING A COLLECTION OF SOFTWARE OF WHICH THIS IS A PART,        *\n.*  ON THE OTHER HAND, IS APPROPRIATE.                                *\n.*                                                                    *\n.*                                  BROIDO COMPUTER CONSULTING        *\n.*                                  BROIDOJ@GMAIL.COM                 *\n.*                                                                    *\n.**********************************************************************\n.*\n         LCLA  &LEN,&I\n         LCLB  &PAIR\n&LEN     SETA  K'&M-2\n&PAIR    SETB  0\n&I       SETA  1\n.QLOOPH  ANOP\n&I       SETA  &I+1+&PAIR\n         AIF   (&I GE K'&M).QDONEH\n&PAIR    SETB  ('&M'(&I,2) EQ '''''' OR '&M'(&I,2) EQ '&&')\n&LEN     SETA  &LEN-&PAIR\n         AGO   .QLOOPH\n.QDONEH  ANOP\n         AIF   ('&MF' EQ 'E').E\n         AIF   ('&MF' EQ 'L').L\n&NAME    BAL   1,V&SYSNDX          POINT TO MESSAGE.\n&MLAB    DC    C&M                 MESSAGE.\n         DS    0H\nV&SYSNDX LA    0,&LEN              LOAD LENGTH.\n         LA    1,0(,1)             CLEAR OPTION BYTE.\n         SVC   93                  ISSUE TPUT/TGET SVC.\n         MEXIT\n.E       ANOP\n&NAME    SR    0,0                 LOAD ...\n         ICM   0,3,&M              ... LENGTH.\n         LA    1,&M+2              POINT TO MESSAGE.\n         SVC   93                  ISSUE TPUT/TGET SVC.\n         MEXIT\n.L       AIF   (&LEN EQ 0).LZ\n&NAME    DC    AL2(&LEN),C&M       MESSAGE.\n         MEXIT\n.LZ      ANOP\n&NAME    DC    AL2(0)              EMPTY MESSAGE.\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VWTPU": {"ttr": 7427, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00G\\x00\\x85\\x18/\\x01\\x13\\x13/\\x14Y\\x00q\\x00r\\x00g\\xc2\\xd9\\xd6\\xc9\\xc4\\xd6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-07-01T00:00:00", "modifydate": "2013-05-12T14:59:47", "lines": 113, "newlines": 114, "modlines": 103, "user": "BROIDO"}, "text": "         MACRO\n&NAME    VWTPU &MM,&MLAB1,&MF=I,&MODE=\n.*\n.**********************************************************************\n.*                                                                    *\n.*  COPYRIGHT (C) 1979 BY BROIDO COMPUTER CONSULTING.  ALL RIGHTS     *\n.*  RESERVED EXCEPT:                                                  *\n.*                                                                    *\n.*  PARTICULAR LICENSE IS GRANTED TO DISTRIBUTE THIS MACRO FREE       *\n.*  OF CHARGE, BUT IT MUST NOT BE SOLD.  A SERVICE CHARGE FOR         *\n.*  HANDLING A COLLECTION OF SOFTWARE OF WHICH THIS IS A PART,        *\n.*  ON THE OTHER HAND, IS APPROPRIATE.                                *\n.*                                                                    *\n.*                                  BROIDO COMPUTER CONSULTING        *\n.*                                  broidoj@gmail.com                 *\n.*                                                                    *\n.**********************************************************************\n.*\n         LCLA  &LEN,&I,&J,&LEN1\n         LCLB  &PAIR\n         LCLC  &M1,&M2,&U,&L,&MLAB,&X,&M\n&M       SETC  '&MM'\n&MLAB    SETC  '&MLAB1'\n&U       SETC  'AEIOUBCDFGHJKLMNPQRSTVWXYZ'\n&L       SETC  'aeioubcdfghjklmnpqrstvwxyz'\n&LEN     SETA  K'&M-2\n         AIF   ('&MF' EQ 'E').QEX\n         AIF   ('&MODE' NE 'FOLD' OR '&MLAB' NE '').QCONT8\n&MLAB    SETC  'V&SYSNDX.E'\n.QCONT8  ANOP\n&PAIR    SETB  0\n&I       SETA  1\n&LEN1    SETA  &LEN+2\n.QLOOPH  ANOP\n&I       SETA  &I+1+&PAIR\n         AIF   (&I GE K'&M).QDONEH\n&PAIR    SETB  ('&M'(&I,2) EQ '''''' OR '&M'(&I,2) EQ '&&')\n&LEN     SETA  &LEN-&PAIR\n         AGO   .QLOOPH\n.QDONEH  ANOP\n         AIF   ('&MF' EQ 'L').QPARM\n&NAME    CNOP  0,4                 FULLWORD ALIGN PARM LIST.\n         BAL   1,V&SYSNDX.A        POINT TO MESSAGE.\n         AGO   .QCONT\n.QPARM   ANOP\n&NAME    DS    0F                  FULLWORD ALIGN PARM LIST.\n.QCONT   ANOP\n         DC    AL2(&LEN+4),X'8000' LENGTH AND FLAGS FOR WTO.\n         AIF   ('&MODE' EQ 'FOLD').MFOLD\n&MLAB    DC    C&M                 MESSAGE.\n         AGO   .QCONT1\n.MFOLD   ANOP\n&M2      SETC  ''\n&J       SETA  1\n.LU1     ANOP\n         AIF   ('&J' GT '&LEN1').QCONT5\n&I       SETA  1\n.LU2     ANOP\n         AIF   ('&M'(&J,1) NE '&L'(&I,1)).BU2\n&M2      SETC  '&M2'.'&U'(&I,1)\n         AGO   .BU1\n.BU2     ANOP\n&I       SETA  &I+1\n         AIF   (&I LE 26).LU2\n&M2      SETC  '&M2'.'&M'(&J,1)\n.BU1     ANOP\n&J       SETA  &J+1\n         AGO   .LU1\n.QCONT5  ANOP\n&X       SETC  'V&SYSNDX.D'\n&X       DC    C&M2                UPPERCASE MESSAGE.\n.QCONT1  DC    X'02000020'         ROUTCDE=11,DESC=7\n         AIF   ('&MF' EQ 'L').QEND\n         AIF   ('&MODE' NE 'FOLD').QCONT2\n&MLAB    DC    C&M                 RAW MESSAGE.\n.QCONT2  DS    0H\n&X       SETC  'V&SYSNDX.A'\n&X       TM    FLAG,$TSO           RUNNING UNDER TSO?\n         BO    V&SYSNDX.B          B IF YES.\n         SVC   35                  DO WTO (FOR WTP).\n         B     V&SYSNDX.C          CONTINUE.\n         AIF   ('&MODE' NE 'FOLD').QCONT6\n&X       SETC  'V&SYSNDX.B'\n&X       LA    1,&MLAB             POINT TO MESSAGE.\n         AGO   .QCONT7\n.QCONT6  ANOP\n&X       SETC  'V&SYSNDX.B'\n&X       LA    1,4(,1)             POINT TO MESSAGE.\n.QCONT7  LA    0,&LEN              LOAD LENGTH.\n         SVC   93                  TPUT SVC.\n&X       SETC  'V&SYSNDX.C'\n&X       EQU   *\n.QEND    MEXIT\n.QEX     AIF   ('&M' EQ '').QEX2\n         AIF   ('&M' EQ '(1)').QEX2\n         AIF   ('&M'(1,1) EQ '(').QEX1\n         LA    1,&M                POINT TO PARM.\n         AGO   .QEX2\n.QEX1    ANOP\n&M1      SETC  '&M'\n         LR    1,&M1               POINT TO PARM.\n.QEX2    TM    FLAG,$TSO           RUNNING UNDER TSO?\n         BO    V&SYSNDX.B          B IF YES.\n         SVC   35                  DO WTO (FOR WTP).\n         B     V&SYSNDX.C          CONTINUE.\n&X       SETC  'V&SYSNDX.B'\n&X       LH    0,0(,1)             LOAD LENGTH.\n         SH    0,=H'4'             CORRECT LENGTH.\n         LA    1,4(,1)             POINT TO MESSAGE.\n         SVC   93                  TPUT SVC.\n&X       SETC  'V&SYSNDX.C'\n&X       EQU   *\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT423/FILE423.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT423", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}