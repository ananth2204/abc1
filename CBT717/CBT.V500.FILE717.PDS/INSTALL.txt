//IBMUSERA JOB 'INIT',MSGLEVEL=(0,0),MSGCLASS=X,REGION=2048K,CLASS=A
//*
//*THIS JCL STREAM WILL INSTALL 5 OBJECTS.  THIS INCLUDES THE REXX
//*MODULE AND THE 4 ISPF PANEL OBJECTS.  THE REXX OBJECT IS INCLUDED
//*IN THE FIRST JCL STREAM.  THE PANEL OBJECTS ARE INCLUDED IN THE
//*SECOND STREAM.  THE SECOND STREAM WILL BE FOUND IMMEDIATELY
//*FOLLOWING THIS STREAM.  YOU CAN USE THE FIND COMMAND TO SEARCH
//*FOR SYSUT2 OR USERID.
//*
//*CHANGE USERID TO YOUR TSO LOGIN ID.  LEAVE THE APPENDED A.
//*SEE THE BELOW NOTE ABOUT SYSUT2.
//*
//* START JCL
//INIT    EXEC PGM=IEBUPDTE,PARM=NEW
//SYSPRINT DD SYSOUT=X
//*
//SYSUT2   DD DSN=REXX.SOURCE,DISP=SHR
//*
//*CHANGE sysut2 to point to the sysexec library where the rexx user
//*programs reside.  you may need to have racf authorization to write
//*to this data set.
//*
//SYSIN    DD DATA,DLM=XQ
./ ADD NAME=JUMPLIST,LIST=ALL
/* REXX */
ARG ARG1
CALL JUMPLIST_START
RETURN

JUMPLIST_START: PROCEDURE EXPOSE ARG1
PREFIX=SYSVAR(SYSPREF)
"PROFILE NOPREFIX"
IF ARG1 = 'SETUP' THEN DO
   CALL SETUP
   RETURN
   END
ELSE
   IF SYSDSN('ADMIN.JUMPLIST(JLADMIN)') = 'OK' THEN DO
      "ISPEXEC LIBDEF ISPTlIB DATASET ID('ADMIN.JUMPLIST') STACK"
      "ISPEXEC LIBDEF ISPTABL DATASET ID('ADMIN.JUMPLIST') STACK"
      "ISPEXEC TBOPEN JLADMIN NOWRITE"
      SUKEY = 'SETUP'
      "ISPEXEC TBGET JLADMIN"
      "ISPEXEC TBCLOSE JLADMIN"
      END
   ELSE
      IF SYSDSN('ADMIN.JUMPLIST(JLADMIN)') <> 'OK' THEN DO
         CALL SETUP
         RETURN
         END
IF ISPPLIB \= '' THEN
   IF SYSDSN("'"ISPPLIB"'") ='OK' THEN
      "ISPEXEC LIBDEF ISPPLIB DATASET ID('"ISPPLIB"') STACK"
   ELSE DO
      SAY "LIBRARY "ISPPLIB" DOES NOT EXIST"
      RETURN
      END
IF ARG1 \= '/CLOSE' THEN
   JUMPPROF = ARG1
STATUS = MSG('OFF')
/*                  SYSTEMS PROGRAMMER ATTENTION                    */
/*                                                                  */
/* SEND QUERIES TO JOE.CAUGHMAN@GMAIL.COM                           */
/*                                                                  */
/* SYSTEMS_CONSOLE IS SET TO OFF, OR 0.  IF SET ON, OR 1, THE USER  */
/* COMMANDS WILL LOAD FROM A PRIMARY CONSOLE, ASSUMED TO BE A       */
/* LIBRARY THAT THE SYSTEMS ANALYST USED TO CREATE ENVIRONMENT      */
/* COMMANDS.                                                        */
/*                                                                  */
/* FOR THE OWNER OF THE PRIMARY CONSOLE COMMANDS, THE               */
/* SYSTEM_CONSOLE MUST BE SET TO OFF, OR 0.                         */
/*                                                                  */
/* USER_CONSOLE IS SET TO ON, OR 1.  IF SET ON, OR 1, THE USER      */
/* COMMANDS WILL LOAD FROM THE LOCAL CONSOLE, A LIBRARY THAT        */
/* JUMPLIST ALLOCATED FOR LOCAL USER COMMANDS.                      */
/*                                                                  */
/* IF SYSTEMS_CONSOLE IS SET TO ON AND USER_CONSOLE IS SET TO ON,   */
/* BOTH COMMANDS FROM THE SYSTEMS CONSOLE AND USER CONSOLE WILL     */
/* LOAD.                                                            */
/*                                                                  */

IF USERID() \ = "'"SYSID"'" THEN DO
   SYSTEMS_CONSOLE = 1
   USER_CONSOLE = 0
   END
ELSE DO
   SYSTEMS_CONSOLE = 0
   USER_CONSOLE = 1
   END
MAXCOMMANDS = MAXC
SYSTEMS_ISPTLIB = ""SYSID".JUMPLIST"
SYSTEMS_ISPTABL = ""SYSID".JUMPLIST"
CALL START
IF PREFIX \= '' THEN
   "PROFILE PREFIX("PREFIX")"
RETURN

START:
IF JUMPPROF ='/RESET' THEN DO
   @USER = ''
   "ISPEXEC VPUT (@USER) PROFILE"
   JUMPPROF = ''
   "ISPEXEC VPUT (JUMPPROF) PROFILE"
   RETURN
   END
TCNT = 0
ERRORCOND = 0
USENAME1 = 'Member';USENAME2 = 'Script'
SYSTEMCMDS. = ''
USERCMDS. = ''
SYSLIST = ''
SYSCOMMANDLIST = ''
USERCMD = 0
USERLIST = ''
USERCOMMANDLIST = ''
INFO1 = ''
INFO2 = ''
CURPOS = '@USER'
FILLER = '__'
FILLER1 = '__'
FILLER2 = '__'
TRAP =0
JLCOMMANDS = '/I, /IXX, /D, /DXX, /R, /RXX, /XPN, E, ESCR, V, B, Z,'
JLCOMMANDS = JLCOMMANDS 'J, ES, XI, XS, FE, FJ, /CLOSE, and /RESET.'
JLCMDLIST = '/I /IXX /D /DXX /R /RXX /XPN E ESCR V B Z J ES XI XS FE FJ'
JLCMDLIST = JLCMDLIST '/CLOSE /RESET'
IF JUMPPROF = '' THEN DO
   "ISPEXEC VGET (JUMPPROF) PROFILE"
   IF JUMPPROF  = '' THEN JUMPPROF = 'GENERIC'
   END
"ISPEXEC VGET (@USER) PROFILE"
IF @USER = '' THEN
   @USER = USERID()
IF SYSDSN("'"@USER".JUMPLIST'") <> 'OK' THEN DO
   "ALLOCATE DD(ALLOCDD) DSN('"@USER".JUMPLIST') SPACE (100 10)",
   "DSORG(PO) DIR(500) LRECL(80) BLKSIZE(3200) RECFM(F,B) MOD REUSE"
   "FREE DD(ALLOCDD)"
   END
IF SYSDSN("'"@USER".JUMPLIST.ROLLOVER'") <> 'OK' THEN
  "ALLOCATE DD(rollibdd) DSN('"@USER".JUMPLIST.ROLLOVER')",
  "SPACE (100 10) DSORG(PO) DIR(50) LRECL(80) BLKSIZE(3120) RECFM(F,B)",
  "MOD REUSE"
ELSE DO
   "ALLOCATE DD(rollibdd) DSN('"@USER".JUMPLIST.ROLLOVER') SHR REUSE"
   END
IF SYSDSN("'"@USER".JUMPLIST.SCRIPT'") <> 'OK' THEN DO
   "ALLOCATE DD(ALLOCDD) DSN('"@USER".JUMPLIST.SCRIPT') SPACE (100 10)",
   "DSORG(PO) DIR(100) LRECL(80) BLKSIZE(3120) RECFM(F,B)"
   "FREE DD(ALLOCDD)"
   END
ENDSESSION = 0
restoreprof = ''
"ispexec control errors return"
"ISPEXEC LIBDEF ISPTlib DATASET ID('"@USER".JUMPLIST') STACK"
"ISPEXEC LIBDEF ISPTABL DATASET ID('"@USER".JUMPLIST') STACK"
IF ARG1 = '/CLOSE' THEN DO
   "ISPEXEC TBCLOSE "JUMPPROF""
   "ISPEXEC LIBDEF ISPTLIB"
   "ISPEXEC LIBDEF ISPTABL"
   RETURN
   END
IF SYSDSN("'"@USER".JUMPLIST("JUMPPROF")'") <> 'OK' THEN
   CALL CREATE_TABLE
ELSE DO
   "ISPEXEC CONTROL ERRORS RETURN"
   "ISPEXEC TBOPEN "JUMPPROF" SHARE"
   IF RC = 12 THEN DO
      INFO1 = ""jumpprof" is being updated.  A temporary profile has",
         "been created."
      ERRORCOND = 1
      "ISPEXEC LIBDEF ISPTLIB"
      "ISPEXEC LIBDEF ISPTABL"
      "ISPEXEC LIBDEF ISPTlib DATASET ID('"@USER".JUMPLIST.rollover')"
      "ISPEXEC LIBDEF ISPTABL DATASET ID('"@USER".JUMPLIST.rollover')"
      "ISPEXEC TBOPEN "JUMPPROF" SHARE"
      END
   ELSE DO
      "ISPEXEC TBSAVE "JUMPPROF" NAME(TEMPPROF) LIBRARY(rollibdd)",
         "REPLCOPY"
      CALL COPYPROF
      END
   END
"ISPEXEC TBTOP "JUMPPROF""
CRP1 = 1
GERROR = 0
startup='';shutdown=''
IF SYSTEMS_CONSOLE THEN
   CALL SYSTEMS_CONSOLE
IF USER_CONSOLE THEN do
   ucuser = userid()
   IF SYSDSN("'"ucuser".JUMPLIST(@USERCMD)'") = 'OK' THEN
      CALL USER_CONSOLE
   end
if startup \= '' then
   CALL STARTUP
DO WHILE \ ENDSESSION
   IF JUMPPROF = '@USERCMD' THEN DO
      USENAME1 = 'Command'
      USENAME2 = ''
      INFO1 = 'RESTART JUMPLIST TO LOAD UPDATED USER COMMANDS.'
      INFO2 = ''
      END
   else DO
      USENAME1 = 'Member'
      USENAME2 = 'Script'
      END
   ERRORCOND = 0
   PARSE UPPER VAR JUMPPROF JUMPPROF
   OLDUSER = @USER
   OLDPROF = JUMPPROF
   "ISPEXEC TBSKIP "JUMPPROF" NUMBER("CRP1")"
   if rc = 20 then endsession = 1
   "ISPEXEC TBDISPL "JUMPPROF" PANEL(JUMPLIST) POSITION(CRP)"
         INFO1 = ''
         INFO2 = ''
   CRP1 = ZTDTOP
   IF RC = 8 THEN ENDSESSION = 1
   PARSE UPPER VAR HELP HELP
   PARSE UPPER VAR DIR DIR
   IF HELP = 'S' THEN
      CALL JUMPLIST_HELP
   IF DIR = 'S' THEN
      CALL DIRECTORY
   CALL HANDLE_PROFILE_USER
   CALL PROCESS_DISPLAY
   END
if shutdown \= '' then
   call shutdown
"ISPEXEC TBCLOSE "OLDPROF""
IF JUMPPROF \= '@USERCMD' THEN
   "ISPEXEC VPUT (JUMPPROF) PROFILE"
"ISPEXEC VPUT (@USER) PROFILE"
 DATALINE = ""@USER".JUMPLIST.ROLLOVER"
 CALL COMPRESS
"ISPEXEC LIBDEF ISPTLIB"
"ISPEXEC LIBDEF ISPTABL"
RETURN

DIRECTORY:
INFO1 = 'USE S TO SELECT A PROFILE.  USE D TO DELETE A PROFILE OR',
   'script.'
@INITIAL = ''
CURPOS  = 'ZCMD'
"ISPEXEC TBCLOSE "OLDPROF""
"ISPEXEC TBCREATE DIRECT NAMES(@MEMBER, @INITIAL, @DATASET) NOWRITE"
MEMLIST. = ''
Y = OUTTRAP('MEMLIST.')
ISOURCE = ""@USER".JUMPLIST"
"LISTDS ('"ISOURCE"') MEMBERS"
DO II = 7 TO MEMLIST.0
   @MEMBER = STRIP(MEMLIST.II,'B')
   @DATASET = ISOURCE
   "ISPEXEC TBADD DIRECT"
   END
MEMLIST. = ''
@MEMBER = ''
Y = OUTTRAP('OFF')
Y = OUTTRAP('MEMLIST.')
ISOURCE = ""@USER".JUMPLIST.SCRIPT"
"LISTDS ('"ISOURCE"') MEMBERS"
DO II = 7 TO MEMLIST.0
   @INITIAL = STRIP(MEMLIST.II,'B')
   @DATASET = ISOURCE
   "ISPEXEC TBADD DIRECT"
   END
Y = OUTTRAP('OFF')
"ISPEXEC TBTOP DIRECT"
"ISPEXEC TBDISPL DIRECT PANEL(JUMPLIST)"
NEWPROF = OLDPROF
IF ZTDSELS > 0 THEN
   DO WHILE ZTDSELS > 0
      PARSE UPPER VAR CMD CMD
      IF CMD = 'S' THEN
         IF @MEMBER \= '' THEN
            NEWPROF = @MEMBER
         ELSE NOP
      ELSE
         IF CMD = 'D' THEN do
            IF SYSDSN("'"@DATASET"("@MEMBER")'") = 'OK' THEN DO
               DELETE "'"@DATASET"("@MEMBER")'"
               @DATASET = 'DELETED'
               "ISPEXEC TBDELETE DIRECT"
               "ISPEXEC TBMOD DIRECT"
               END
            ELSE
               IF SYSDSN("'"@DATASET"("@INITIAL")'") = 'OK' THEN DO
                  DELETE "'"@DATASET"("@INITIAL")'"
                  @DATASET = 'DELETED'
                  "ISPEXEC TBDELETE DIRECT"
                  "ISPEXEC TBMOD DIRECT"
                  END
            @DATASET = 'DELETED'
            "ISPEXEC TBDELETE DIRECT"
            "ISPEXEC TBMOD DIRECT"
            end
      IF CMD = 'S' THEN
         IF ZTDSELS = 1 THEN
            "ISPEXEC CONTROL DISPLAY LOCK"
      CMD = ''
      "ISPEXEC TBDISPL DIRECT"
      END
"ISPEXEC TBCLOSE DIRECT"
INFO1 = ''
JUMPPROF = NEWPROF
/*OLDPROF = NEWPROF*/
"ISPEXEC TBOPEN "OLDPROF" SHARE"
DIR = ''
RETURN

JUMPLIST_HELP:
HELP = ''
"ISPEXEC CONTROL DISPLAY SAVE"
"ISPEXEC DISPLAY PANEL(JLHELP)"
"ISPEXEC CONTROL DISPLAY RESTORE"
RETURN

HANDLE_PROFILE_USER:
IF (@USER \ = OLDUSER),
| (OLDPROF \ = JUMPPROF) THEN DO
   "ISPEXEC TBCLOSE "OLDPROF""
   IF SYSDSN("'"@USER".JUMPLIST'") = 'OK' THEN DO
      "ISPEXEC LIBDEF ISPTLIB"
      "ISPEXEC LIBDEF ISPTABL"
      "ISPEXEC LIBDEF ISPTLIB DATASET ID('"@USER".JUMPLIST')"
      "ISPEXEC LIBDEF ISPTABL DATASET ID('"@USER".JUMPLIST')"
      "FREE DD(rollibdd)"
      "ALLOCATE DD(rollibdd) DSN('"@USER".JUMPLIST.ROLLOVER') SHR REUSE"
      END
   ELSE DO
      @USER = OLDUSER
      "ISPEXEC LIBDEF ISPTLIB"
      "ISPEXEC LIBDEF ISPTABL"
      "ISPEXEC LIBDEF ISPTLIB DATASET ID('"@USER".JUMPLIST')"
      "ISPEXEC LIBDEF ISPTABL DATASET ID('"@USER".JUMPLIST')"
      END
   IF SYSDSN("'"@USER".JUMPLIST("JUMPPROF")'") = 'OK' THEN DO
      "ISPEXEC CONTROL ERRORS RETURN"
      "ISPEXEC TBOPEN "JUMPPROF" SHARE"
      IF RC = 12 THEN DO
         INFO1 = ""jumpprof" is being updated.  A temporary profile",
            "has been created."
         ERRORCOND = 1
         "ISPEXEC LIBDEF ISPTLIB"
         "ISPEXEC LIBDEF ISPTABL"
         "ISPEXEC LIBDEF ISPTlib DATASET",
            "ID('"@USER".JUMPLIST.rollover')"
         "ISPEXEC LIBDEF ISPTABL DATASET",
            "ID('"@USER".JUMPLIST.rollover')"
         "ISPEXEC TBOPEN "JUMPPROF" SHARE"
         IF RC = 8 THEN DO
            "ISPEXEC LIBDEF ISPTABL"
            "ISPEXEC LIBDEF ISPTLIB"
            "ISPEXEC LIBDEF ISPTlib DATASET",
               "ID('"@USER".JUMPLIST')"
            "ISPEXEC LIBDEF ISPTABL DATASET",
               "ID('"@USER".JUMPLIST')"
            INFO1 = 'REQUEST REFUSED.  THE PROFILE IS OPEN'
            ERRORCOND = 1
            @USER = OLDUSER
            JUMPPROF = OLDPROF
           "ISPEXEC TBOPEN "JUMPPROF" SHARE"
            END
         END
      ELSE DO
         "ISPEXEC TBSAVE "JUMPPROF" NAME(TEMPPROF) LIBRARY(rollibdd)",
            "REPLCOPY"
         CALL COPYPROF
         IF RC = 20 THEN DO
            "ISPEXEC LIBDEF ISPTABL"
            "ISPEXEC LIBDEF ISPTLIB"
            "ISPEXEC LIBDEF ISPTlib DATASET",
               "ID('"@USER".JUMPLIST')"
            "ISPEXEC LIBDEF ISPTABL DATASET",
               "ID('"@USER".JUMPLIST')"
            INFO1 = 'REQUEST REFUSED.  THE PROFILE IS OPEN.'
            ERRORCOND = 1
            @USER = OLDUSER
            JUMPPROF = OLDPROF
            "ISPEXEC TBOPEN "JUMPPROF" SHARE"
            END
         END
      END
   ELSE
      CALL CREATE_TABLE
   END
OLDPROF = NEWPROF
RETURN

CREATE_TABLE:
CALL CLEAR_EXTENDS
"ISPEXEC TBCREATE "JUMPPROF" NAMES(@MEMBER,@INITIAL,@DATASET,EXTENDA,",
   "EXTENDB, EXTENDC, EXTENDD, EXTENDE, EXTENDF, EXTENDG, EXTENDH,",
   "EXTENDI, EXTENDJ, EXTENDK, EXTENDL, EXTENDM, EXTENDN, EXTENDO,",
   "EXTENDP, EXTENDQ, EXTENDR, EXTENDS, EXTENDT, EXTENDU, EXTENDV,",
   "EXTENDW, EXTENDX, EXTENDY, EXTENDZ) share REPLACE"
@MEMBER = '';@DATASET = '';@INITIAL = ''
DO II = 1 TO 10
   "ISPEXEC TBADD "JUMPPROF""
   END
"ispexec tbclose "jumpprof""
"ispexec tbopen "jumpprof" share"
"ISPEXEC TBTOP "JUMPPROF""
RETURN

PROCESS_DISPLAY:
HZTDSELS = ZTDSELS
ZEDLMSG = ''
IF ZTDSELS > 0 THEN DO
   DO WHILE ZTDSELS > 0
      PARSE UPPER VAR @MEMBER @MEMBER
      PARSE UPPER VAR @INITIAL @INITIAL
      PARSE UPPER VAR @DATASET @DATASET
      PUC = 1
      PTC = 1
      EXTENDA = @DATASET
      CALL NULL_EXTENDS
      CALL APPEND_EXTENDS
      PARSE UPPER VAR CMD CMD
      IF @EXTEND \ = '' THEN DO
         IF POS('{',@EXTEND) = 1 THEN
            DATALINE = SUBSTR(@EXTEND,POS('}',@EXTEND)+1)
         ELSE
            IF POS('{',@EXTEND) > 0 THEN
               DATALINE = SUBSTR(@EXTEND,1,POS('{',@EXTEND)-1)
            ELSE
               DATALINE = @EXTEND
         END
      ELSE
         IF POS('{',@DATASET) = 1 THEN
            DATALINE = SUBSTR(@DATASET,POS('}',@DATASET)+1)
         ELSE
            IF POS('{',@DATASET) > 0 THEN
               DATALINE = SUBSTR(@DATASET,1,POS('{',@DATASET)-1)
            ELSE
               DATALINE = @DATASET
      DATALINE = STRIP(DATALINE,'B')
      IF JUMPPROF = '@USERCMD' THEN USERCMD = 1
      ELSE USERCMD = 0
      callparms. = ''
      SELECT
         WHEN SUBSTR(CMD,1,2) = '/I' THEN
            CALL EXECUTE_PROFILE_INSERT
         WHEN SUBSTR(CMD,1,2) = '/D' THEN
            CALL EXECUTE_PROFILE_DELETE
         WHEN SUBSTR(CMD,1,2) = '/R' THEN
            CALL EXECUTE_PROFILE_REPEAT
         WHEN CMD = 'ES' & \ USERCMD THEN
            IF @INITIAL \ = '' THEN
               IF @INITIAL = JUMPPROF THEN
                  ZEDLMSG = 'SCRIPT NAME CANNOT BE THE SAME AS THE',
                    'JUMPLIST PROFILE NAME.'
               ELSE
                  CALL EDIT_SCRIPT
            ELSE
               ZEDLMSG = 'A SCRIPT NAME MUST BE ENTERED.'
         WHEN CMD = 'XS' & \ USERCMD THEN
            IF @INITIAL \ = '' THEN DO
               CALL EXECUTE_SCRIPT
               "ISPEXEC LIBDEF ISPTLIB"
               "ISPEXEC LIBDEF ISPTABL"
               END
         WHEN CMD = 'E' & \ USERCMD THEN DO
            CALL CHECKTYPE
            IF GDGFOUND THEN
               CALL CHECKGDG
            CALL EXECUTE_EDIT
            END
         WHEN CMD = 'ESCR' & \ USERCMD THEN DO
            CALL CHECKTYPE
            IF GDGFOUND THEN
               CALL CHECKGDG
            CALL EXECUTE_EDIT
            END
         WHEN CMD = 'XI' & \ USERCMD,
         | CMD = 'B' & POS(SUBSTR(DATALINE,1,1),'- =') > 0 THEN DO
            ERRORCOND = 0
            DATALINEZ = DATALINE
            DATALINEH = DATALINE
            DO UNTIL DATALINEH = ''
               IF POS(';;',DATALINEH) > 0 THEN DO
                  DATALINE = SUBSTR(DATALINEH,1,POS(';;',DATALINEH)-1)
                  DATALINE = STRIP(DATALINE,'B')
                  DATALINEH = SUBSTR(DATALINEH,POS(';;',DATALINEH)+2)
                  END
               ELSE DO
                  DATALINE = DATALINEH
                  DATALINE = STRIP(DATALINE,'B')
                  DATALINEH = ''
                  END
               CALL EXECUTE_IMMEDIATE DATALINE
               IF ERRORCOND THEN LEAVE
               END
            END
         WHEN CMD = 'B' & \ USERCMD THEN DO
            CALL CHECKTYPE
            IF GDGFOUND THEN
               CALL CHECKGDG
            CALL EXECUTE_BROWSE
            END
         WHEN CMD = 'V' & \ USERCMD THEN DO
            CALL CHECKTYPE
            IF GDGFOUND THEN
               CALL CHECKGDG
            CALL EXECUTE_VIEW
            END
         WHEN CMD = 'J' & \ USERCMD THEN
            CALL SUBMIT
         WHEN CMD = 'Z' & \ USERCMD THEN
            CALL COMPRESS
         WHEN CMD = 'FE' & \ USERCMD THEN DO
            IF SYSDSN("'"@USER".JUMPLIST.SCRIPT("@INITIAL")'") \ = 'OK',
            THEN
               ZEDLMSG = 'THE INITIAL SCRIPT HAS NOT BEEN DEFINED.'
            ELSE
            IF SYSDSN("'"SYSID".JUMPLIST.SCRIPT("@INITIAL")'") \ = 'OK'
            THEN
               ZEDLMSG = 'THE INITIAL SCRIPT HAS NOT BEEN DEFINED.'
            ELSE DO
               CALL EXECUTE_SCRIPT
               CALL FILETAILOR_EDIT
               "ISPEXEC LIBDEF ISPTLIB"
               "ISPEXEC LIBDEF ISPTABL"
               END
            END
         WHEN CMD = 'FJ' & \ USERCMD THEN
            IF SYSDSN("'"@USER".JUMPLIST.SCRIPT("@INITIAL")'") = 'OK',
            | SYSDSN("'"SYSID".JUMPLIST.SCRIPT("@INITIAL")'") = 'OK'
            THEN DO
               CALL EXECUTE_SCRIPT
               CALL FILETAILOR_SUBMIT
               "ISPEXEC LIBDEF ISPTLIB"
               "ISPEXEC LIBDEF ISPTABL"
               END
            ELSE
               ZEDLMSG = 'THE INITIAL SCRIPT HAS NOT BEEN DEFINED.'
         WHEN CMD = '/XPN' THEN DO
            EXTENDA = @DATASET
            "ISPEXEC CONTROL DISPLAY SAVE"
            "ISPEXEC DISPLAY PANEL(JLXPND)"
            "ISPEXEC CONTROL DISPLAY RESTORE"
            @DATASET = EXTENDA
            END
         WHEN POS(CMD, SYSLIST) > 0 THEN
            CALL SYS_FUNCTION CMD
         WHEN POS(CMD, USERLIST) > 0 & \ USERCMD THEN
            CALL USER_FUNCTION CMD
         WHEN CMD = '  ' THEN NOP
         OTHERWISE CALL ERROR_LIST
         END
      IF USERCMD & POS(@MEMBER, JLCMDLIST) > 0 THEN DO
         ZEDLMSG = 'THIS IS ALREADY DEFINED AS A SYSTEM COMMAND.'
         @MEMBER = ''
         END
      IF USER_CONSOLE & USERCMD & POS(@MEMBER, SYSLIST) > 0 THEN DO
         ZEDLMSG = 'THIS IS ALREADY DEFINED AS A SYSTEMS LEVEL COMMAND.'
         @MEMBER = ''
         END
      "ISPEXEC TBDELETE "JUMPPROF""
      "ISPEXEC TBMOD "JUMPPROF""
      CMD =''
      IF JUMPPROF = '@USERCMD' THEN USERCMD = 1
      ELSE USERCMD = 0
      IF ZEDLMSG  = '' THEN DO
         IF ZTDSELS = 1 THEN
            "ISPEXEC CONTROL DISPLAY LOCK"
         "ISPEXEC TBDISPL "JUMPPROF""
         END
      ELSE DO
         IF GERROR THEN TIMER = 4
         ELSE TIMER = 2
         DO II = 1 TO TIMER
            "ISPEXEC CONTROL DISPLAY LOCK"
            "ISPEXEC SETMSG MSG(ISRZ000)"
            "ISPEXEC TBDISPL "JUMPPROF""
            CALL SLEEP
            END
         END
      IF RC = 8 THEN ENDSESSION = 1
      END
   END
RETURN

SYS_FUNCTION: PROCEDURE EXPOSE SYSTEMCMDS. @MEMBER DATALINE,
   ERRORCOND INFO1 INFO2 USERCMDS. USERLIST SYSLIST PUC PTC,
   CALLPARMS. ZEDLMSG
ARG CMD
TRACE = 0
DATALINEH = SYSTEMCMDS.CMD
DATALINEZ = DATALINEH
DO UNTIL DATALINEH = ''
   IF POS(';;',DATALINEH) > 0 THEN DO
      DATALINEC = SUBSTR(DATALINEH,1,POS(';;',DATALINEH)-1)
      DATALINEC = STRIP(DATALINEC,'B')
      DATALINEH = SUBSTR(DATALINEH,POS(';;',DATALINEH)+2)
      DATALINEH = STRIP(DATALINEH,'B')
      END
   ELSE DO
      DATALINEC = DATALINEH
      DATALINEC = STRIP(DATALINEC,'B')
      DATALINEH = ''
      END
   IF TRACE THEN
      SAY DATALINEC
   CALL EXECUTE_IMMEDIATE DATALINEC
   IF ERRORCOND THEN LEAVE
   END
RETURN

USER_FUNCTION: PROCEDURE EXPOSE USERCMDS. @MEMBER DATALINE ERRORCOND,
 INFO1 INFO2 SYSTEMCMDS. SYSLIST USERLIST PTC PUC CALLPARMS. ZEDLMSG
ARG CMD
DATALINEH = USERCMDS.CMD
DATALINEZ = DATALINEH
TRACE = 0
DO UNTIL DATALINEH = ''
   IF POS(';;',DATALINEH) > 0 THEN DO
      DATALINEC = SUBSTR(DATALINEH,1,POS(';;',DATALINEH)-1)
      DATALINEC = STRIP(DATALINEC,'B')
      DATALINEH = SUBSTR(DATALINEH,POS(';;',DATALINEH)+2)
      DATALINEH = STRIP(DATALINEH,'B')
      END
   ELSE DO
      DATALINEC = DATALINEH
      DATALINEC = STRIP(DATALINEC,'B')
      DATALINEH = ''
      END
   IF TRACE THEN
      SAY DATALINEC
   CALL EXECUTE_IMMEDIATE DATALINEC
   IF ERRORCOND THEN LEAVE
   END
RETURN

ERROR_LIST:
IF USERCMD THEN
   ZEDLMSG = 'THE FUNCTION IS NOT AVAILABLE DURING THE USER COMMAND',
     'SESSION.'
ELSE DO
   ZEDLMSG = 'THE AVAILABLE FUNCTIONS ARE: ' JLCOMMANDS
   GERROR = 1
   INFO1 = JLCOMMANDS
   IF SYSCOMMANDLIST \ = '' THEN DO
      ZEDLMSG = ZEDLMSG SYSCOMMANDLIST || '.'
      INFO2 = SYSCOMMANDLIST
      END
   IF USERLIST \= '' THEN DO
      ZEDLMSG = ZEDLMSG '    THE AVAILABLE USER FUNCTIONS ARE: ',
          USERCOMMANDLIST
      INFO2 = INFO2 USERCOMMANDLIST
      END
   END
RETURN

SLEEP:
CALL SYSCALLS('ON')
ADDRESS SYSCALL
SLEEP 1
ADDRESS TSO
RETURN

EXECUTE_PROFILE_DELETE:
IF DATATYPE(SUBSTR(CMD,3)) = 'NUM' THEN
   REPCNT = SUBSTR(CMD,3)
ELSE REPCNT = 1
IF REPCNT > ((ZTDROWS - CRP) + 1) THEN
   REPCNT = (ZTDROWS - CRP) + 1
DO II = 1 TO REPCNT
   "ISPEXEC TBDELETE "JUMPPROF""
   IF (II + crp) < ztdrows + 1 THEN
      "ISPEXEC TBSKIP "JUMPPROF" NUMBER(+1)"
   ELSE
      "ISPEXEC TBSKIP "JUMPPROF" NUMBER(+0)"
   END
RETURN

EXECUTE_PROFILE_INSERT:
CALL CLEAR_EXTENDS
IF DATATYPE(SUBSTR(CMD,3)) = 'NUM' THEN
   REPCNT = SUBSTR(CMD,3)
ELSE REPCNT = 1
   @MEMBER = '';@DATASET = ' ';@INITIAL = ' '
   @EXTEND = ' '
   DO II = 1 TO REPCNT
      "ISPEXEC TBADD "JUMPPROF""
      END
RETURN

EXECUTE_PROFILE_REPEAT:
IF DATATYPE(SUBSTR(CMD,3)) = 'NUM' THEN
   REPCNT = SUBSTR(CMD,3)
ELSE REPCNT = 1
   DO II = 1 TO REPCNT
      "ISPEXEC TBADD "JUMPPROF""
      END
RETURN

EXECUTE_EDIT:
SYSDSORG = ''
DSORG2 = SYSDSORG
X = LISTDSI("'"DATALINE"'")
IF DSORG2 = 'VS' THEN
   ZEDLMSG = 'EDIT DOES NOT SUPPORT VSAM FORMAT.',
      ' USE BROWSE TO BROWSE VSAM CONTENT. '
ELSE
   IF POS('*',DATALINE) > 0,
   |  POS('%',DATALINE) > 0 THEN
      CALL EDIT 'SCR'
   ELSE
      IF GDGBASEFOUND & \ GDGRELFOUND THEN
         CALL EDIT 'SCR'
      ELSE
         IF SYSDSN("'"DATALINE"'") = 'OK' THEN
            IF CMD = 'ESCR' THEN
               CALL EDIT 'SCR'
            ELSE
               CALL EDIT
         ELSE
            ZEDLMSG = 'DATA SET DOES NOT EXIST.  '
RETURN

EXECUTE_VIEW:
SYSDSORG = ''
DSORG2 = SYSDSORG
X = LISTDSI("'"DATALINE"'")
IF DSORG2 = 'VS' THEN
   ZEDLMSG = 'VIEW DOES NOT SUPPORT VSAM FORMAT.',
      ' USE BROWSE TO BROWSE VSAM CONTENT. '
ELSE
   IF @MEMBER \= '' THEN
      IF SYSDSN("'"DATALINE"'") = 'OK' THEN
         IF SYSDSN("'"DATALINE"("@MEMBER")'") = 'OK' THEN
            CALL VIEW
         ELSE
            ZEDLMSG = 'MEMBER DOES NOT EXIST.  '
      ELSE
         IF DATALINE = '' THEN
            ZEDLMSG = 'NO DATA SET NAME WAS ENTERED.'
         ELSE
            ZEDLMSG = 'DATA SET DOES NOT EXIST.  '
   ELSE
      IF POS('*',DATALINE) > 0,
      |  POS('%',DATALINE) > 0 THEN
         CALL EDIT 'SCR'
      ELSE
         IF GDGBASEFOUND & \ GDGRELFOUND THEN
            CALL EDIT 'SCR'
         ELSE
            IF SYSDSN("'"DATALINE"'") = 'OK' THEN
               CALL VIEW
            ELSE
               IF DATALINE = '' THEN
                  ZEDLMSG = 'NO DATA SET NAME WAS ENTERED.'
               ELSE
                  ZEDLMSG = 'DATA SET DOES NOT EXIST.  '
RETURN

EXECUTE_BROWSE:
SYSDSORG = ''
X = LISTDSI("'"DATALINE"'")
DSORG2 = SYSDSORG
IF DSORG2 = 'VS' THEN
   CALL LMINIT_BROWSE
ELSE
   IF @MEMBER \= '' THEN
      IF SYSDSN("'"DATALINE"'") = 'OK' THEN
         IF SYSDSN("'"DATALINE"("@MEMBER")'") = 'OK' THEN
            CALL BROWSE
         ELSE
            ZEDLMSG = 'MEMBER DOES NOT EXIST.  '
      ELSE
         IF DATALINE = '' THEN
            ZEDLMSG = 'NO DATA SET NAME WAS ENTERED.'
         ELSE
            ZEDLMSG = 'DATA SET DOES NOT EXIST.  '
   ELSE
      IF POS('*',DATALINE) > 0,
      |  POS('%',DATALINE) > 0 THEN
         CALL EDIT 'SCR'
      ELSE
         IF GDGBASEFOUND & \ GDGRELFOUND THEN
            CALL EDIT 'SCR'
         ELSE
            IF SYSDSN("'"DATALINE"'") = 'OK' THEN
               CALL BROWSE
            ELSE
               IF DATALINE = '' THEN
                  ZEDLMSG = 'NO DATA SET NAME WAS ENTERED.'
               ELSE
                  ZEDLMSG = 'DATA SET DOES NOT EXIST.  '
RETURN

EDIT: PROCEDURE EXPOSE DATALINE @MEMBER ETYPE
ARG EDITTYPE
"ISPEXEC CONTROL DISPLAY SAVE"
"ISPEXEC CONTROL ERRORS RETURN"
IF DATALINE \ = '' THEN
   IF @MEMBER \ = '' THEN
      "ISPEXEC EDIT DATASET ('"DATALINE"("@MEMBER")')"
   ELSE
      IF EDITTYPE \= 'SCR' THEN DO
         SELECT
            WHEN ETYPE = '1' THEN DO
               "ISPEXEC LMINIT DATAID("ZTEMPDD") DATASET('"DATALINE"')"
               "ISPEXEC MEMLIST DATAID("ZTEMPDD") CONFIRM(YES) FIELD(1)"
               "ISPEXEC LMFREE DATAID("ZTEMPDD")"
               END
            WHEN ETYPE = '9' THEN DO
               "ISPEXEC LMINIT DATAID("ZTEMPDD") DATASET('"DATALINE"')"
               "ISPEXEC MEMLIST DATAID("ZTEMPDD") CONFIRM(YES) FIELD(9)"
               "ISPEXEC LMFREE DATAID("ZTEMPDD")"
               END
            OTHERWISE
               "ISPEXEC EDIT DATASET ('"DATALINE"')"
            END
         END
      ELSE
         "ISPEXEC SELECT PGM(ISRDSLST) PARM(DSL '"DATALINE"')",
         "SUSPEND SCRNAME(DSLIST)"
IF RC = 14 THEN
   ZEDLMSG = 'DATA SET OR MEMBER IN USE.'
ELSE
   IF RC = 20 THEN
      ZEDLMSG = 'MEMBER NOT ACCESSIBLE.  CHECK THE MEMBER SYNTAX.'
"ISPEXEC CONTROL DISPLAY RESTORE"
RETURN

BROWSE:
"ISPEXEC CONTROL DISPLAY SAVE"
IF DATALINE \ = '' THEN
   IF @MEMBER \= '' THEN
      "ISPEXEC BROWSE DATASET ('"DATALINE"("@MEMBER")')"
   ELSE
      "ISPEXEC BROWSE DATASET ('"DATALINE"')"
"ISPEXEC CONTROL DISPLAY RESTORE"
RETURN

VIEW:
"ISPEXEC CONTROL DISPLAY SAVE"
"ISPEXEC CONTROL ERRORS RETURN"
IF DATALINE \ = '' THEN
   IF @MEMBER \= '' THEN
      "ISPEXEC VIEW DATASET ('"DATALINE"("@MEMBER")')"
   ELSE
      "ISPEXEC VIEW DATASET ('"DATALINE"')"
"ISPEXEC CONTROL DISPLAY RESTORE"
RETURN

CHECKTYPE:
PDSFOUND = 0
PSFOUND = 0
VSAMFOUND = 0
GDGFOUND = 0
GDGBASEFOUND = 0
GDGRELFOUND = 0
POS1 = POS('(',DATALINE)
IF POS1 > 0 THEN
   ISOURCE = SUBSTR(DATALINE,1,POS1-1)
ELSE
   ISOURCE = DATALINE
Y = OUTTRAP('DSLIST.')
"LISTDS '"ISOURCE"'"
DO II = 1 TO DSLIST.0
   IF POS('PS',DSLIST.II) > 0 THEN
      PSFOUND = 1
   ELSE
      IF POS('PO',DSLIST.II) > 0 THEN
         PDSFOUND = 1
      ELSE
         IF POS('VSAM',DSLIST.II) > 0 THEN
            VSAMFOUND = 1
         ELSE
            IF POS('GDG',DSLIST.II) > 0 THEN
               GDGFOUND = 1
   END
Y = OUTTRAP('OFF')
RETURN

CHECKGDG:
GDGCNT = 0
GDGBASEFOUND = 0
GDGRELFOUND = 0
POS1 = POS('(',DATALINE)
IF POS1 > 0 THEN
   ISOURCE = SUBSTR(DATALINE,1,POS1-1)
ELSE
   ISOURCE = DATALINE
Y = OUTTRAP('GDGLIST.')
"LISTCAT ENTRIES('"ISOURCE"')"
GDGBASEFOUND = 1
IF POS1 > 0 THEN DO
   POS2 = POS(')',DATALINE)
   GDGNUM = SUBSTR(DATALINE,POS1+1,POS2-POS1-1)
   IF DATATYPE(GDGNUM) = 'NUM' THEN DO
      ABSGEN = ABS(GDGNUM)
      ABSGEN = ABSGEN + 1
      END
   GDGLEVEL. =''
   GDGCNT = 1
   GDGBASEFOUND = 1
   DO II = GDGLIST.0 TO 2 BY -1
      IF POS(ISOURCE,GDGLIST.II) > 0 THEN DO
         GDGLEVEL.GDGCNT = WORD(GDGLIST.II,3)
         GDGCNT = GDGCNT + 1
         GDGRELFOUND = 1
         END
      END
   DATALINE = GDGLEVEL.ABSGEN
   END
Y = OUTTRAP('OFF')
RETURN

COMPRESS: PROCEDURE EXPOSE DATALINE SYSDSORG ZEDLMSG INFO1
X = LISTDSI("'"DATALINE"'")
DSORG2 = SYSDSORG
IF DSORG2 \ = 'VS' THEN
   IF SYSDSN("'"DATALINE"'") = 'OK' THEN DO
      "ISPEXEC LMINIT DATASET('"DATALINE"') DATAID("INP") ENQ(EXCLU)"
      "ISPEXEC LMCOMP DATAID("INP")"
      IF RC \= 0 THEN DO
         ZEDLMSG = 'COULD NOT COMPRESS THE DATA SET.  THE DATA SET',
            'MAY BE IN USE.  USER ISRDDN INSTEAD IF THE DATA SET IS',
            'PART OF A LIBDEF.'
         INFO1 = 'DATA SET COMPRESSION FAILURE'
         RC = 0
         END
      ELSE
         ZEDLMSG = 'DATA SET COMPRESSED.'
      "ISPEXEC LMCLOSE DATAID("INP")"
      "ISPEXEC LMFREE DATAID("INP")"
      END
   ELSE
      ZEDLMSG = 'DATA SET DOES NOT EXIST.'
ELSE
   ZEDLMSG = 'CANNOT COMPRESS VSAM FILE.'
RETURN

EXECUTE_IMMEDIATE:
ARG DATALINEC
"ISPEXEC CONTROL DISPLAY SAVE"
TRACE = 0
rc = 0
GOTO = ''
IF DATALINEC \ = '' THEN
   IF DATALINEC = '-' THEN
      ZEDLMSG = 'THE COMMAND NEEDS TO IMMEDIATELY FOLLOW THE -.'
   ELSE
      IF DATALINEC = '=' THEN
         ZEDLMSG = 'THE COMMAND NEEDS TO IMMEDIATELY FOLLOW THE =.'
      ELSE
         IF DATALINEC = ':' THEN
            ZEDLMSG = 'THE LABEL NEEDS TO IMMEDIATELY FOLLOW THE :.'
         ELSE
            IF SUBSTR(DATALINEC,1,1) = '-',
            | SUBSTR(DATALINEC,1,1) = '=',
            | SUBSTR(DATALINEC,1,1) = ':' then
               IF SUBSTR(DATALINEC,1,1) = '-' THEN DO
                  SCRIPTl = SUBSTR(DATALINEC,2)
                  STATUS = MSG('ON')
                  CALL INTERPRET_XI_SCRIPT
                  IF GOTO \= '' THEN DO
                     GLABEL = ':' || GOTO
                     DATALINEH = SUBSTR(DATALINEZ,POS(GLABEL,DATALINEZ))
                     END
                  STATUS = MSG('OFF')
                  END
               ELSE
                  IF SUBSTR(DATALINEC,1,1) = '=',
                  & PUC THEN DO
                    XCMD = SUBSTR(DATALINEC,2)
                    STATUS = MSG('ON')
                    USERCMD = 1
                    IF POS(CMD, SYSLIST) > 0 THEN
                       CALL SYS_FUNCTION XCMD
                    ELSE
                       IF POS(CMD, USERLIST) > 0 THEN
                          CALL USER_FUNCTION XCMD
                    IF RC \= 0 THEN INFO1 = 'TSO SCRIPT ERROR' XCMD
                    RC = 0
                    STATUS = MSG('OFF')
                    END
                  ELSE
                     IF SUBSTR(DATALINEC,1,1) = ':' THEN NOP
                     ELSE DO
                        ZEDLMSG = 'NOT IN COMMAND FORMAT.'
                        INFO1 = ZEDLMSG
                        ERRORCOND = 1
                        END
"ISPEXEC CONTROL DISPLAY RESTORE"
RETURN

EDIT_SCRIPT:
"ISPEXEC CONTROL DISPLAY SAVE"
"ISPEXEC LIBDEF ISPTLIB DATASET ID('"@USER".JUMPLIST.SCRIPT') STACK"
"ISPEXEC LIBDEF ISPTABL DATASET ID('"@USER".JUMPLIST.SCRIPT') STACK"
IF SYSDSN("'"@USER".JUMPLIST.SCRIPT("@INITIAL")'") <> 'OK' THEN DO
   "ISPEXEC TBCREATE "@INITIAL" NAMES(SCRIPTL) WRITE REPLACE"
   SCRIPTL = '              '
   DO II = 1 TO 20
      "ISPEXEC TBADD "@INITIAL""
      END
   "ISPEXEC TBCLOSE "@INITIAL""
   END
IF CMD = 'ESC' THEN DO
   "ISPEXEC TBCLOSE "@INITIAL""
   RETURN
   END
"ISPEXEC TBOPEN "@INITIAL" SHARE"
"ISPEXEC TBTOP "@INITIAL""
"ISPEXEC TBDISPL "@INITIAL" PANEL(JLSCRIPT)"
IF ZTDSELS > 0 THEN
   DO WHILE ZTDSELS > 0
      "ISPEXEC TBDELETE "@INITIAL""
      "ISPEXEC TBMOD "@INITIAL""
      "ISPEXEC TBDISPL "@INITIAL""
      END
"ISPEXEC TBTOP "@INITIAL""
"ISPEXEC TBCLOSE "@INITIAL""
"ISPEXEC LIBDEF ISPTLIB"
"ISPEXEC LIBDEF ISPTABL"
"ISPEXEC CONTROL DISPLAY RESTORE"
RETURN

EXECUTE_SCRIPT:
"ISPEXEC CONTROL DISPLAY SAVE"
IF SYSDSN("'"sysid".JUMPLIST.SCRIPT("@INITIAL")'") = 'OK' THEN
   if sysid \= userid() then
      "ISPEXEC LIBDEF ISPTLIB DATASET",
          "ID('"sysid".JUMPLIST.SCRIPT') STACK"
   else DO
      "ISPEXEC LIBDEF ISPTLIB DATASET",
          "ID('"sysid".JUMPLIST.SCRIPT') STACK"
      "ISPEXEC LIBDEF ISPTABL DATASET",
          "ID('"sysid".JUMPLIST.SCRIPT') STACK"
      END
else
   "ISPEXEC LIBDEF ISPTlib DATASET ID('"@USER".JUMPLIST.SCRIPT') STACK"
"ISPEXEC TBOPEN "@INITIAL" SHARE"
"ISPEXEC TBTOP "@INITIAL""
FTJCL = ''
DO II = 1 TO 20
   "ISPEXEC TBSKIP "@INITIAL" NUMBER(+1)"
   IF SCRIPTL \ = '' THEN
      CALL INTERPRET_SCRIPT
   IF ERRORCOND THEN LEAVE
   END
IF FTJCL = '' THEN FTJCL = @INITIAL
"ISPEXEC TBCLOSE "@INITIAL""
"ISPEXEC CONTROL DISPLAY RESTORE"
RETURN

SUBMIT:
"ISPEXEC CONTROL DISPLAY SAVE"
IF DATALINE \ = '' THEN
   IF @MEMBER \= '' THEN
      "SUBMIT '"DATALINE"("@MEMBER")'"
ZEDLMSG = 'JOB SUBMITTED.'
"ISPEXEC CONTROL DISPLAY RESTORE"
RETURN

FILETAILOR_EDIT: PROCEDURE EXPOSE DATALINE FTJCL @MEMBER
"ISPEXEC CONTROL DISPLAY SAVE"
"ISPEXEC VGET ZTEMPF"
"ISPEXEC FTOPEN TEMP"
"ISPEXEC FTINCL "FTJCL""
"ISPEXEC FTCLOSE"
"ISPEXEC VGET ZTEMPN SHARED"
"ISPEXEC LMINIT DATAID(ZTEMPDD) DDNAME("ZTEMPN")"
"ISPEXEC EDIT DATAID("ZTEMPDD")"
"ISPEXEC LMFREE DATAID("ZTEMPDD")"
"ISPEXEC CONTROL DISPLAY restore"
RETURN

FILETAILOR_SUBMIT:
"ISPEXEC VGET ZTEMPF"
 "ISPEXEC FTOPEN TEMP"
"ISPEXEC FTINCL "FTJCL""
 "ISPEXEC FTCLOSE"
"SUBMIT '"ZTEMPF"'"
RETURN

INTERPRET_XI_SCRIPT:
"ISPEXEC CONTROL ERRORS RETURN"
SCRIPTA = 'SIGNAL ON SYNTAX NAME SCRIPT_XI_ERROR; ' || SCRIPTL
INTERPRET ""SCRIPTA""
IF TRACE THEN
   if rc = 0 then
      SAY 'COMMAND RC ' RC
   else
      SAY 'COMMAND RC ' RC zerrlm zedlmsg
ERRRETURN1: NOP
RETURN

SCRIPT_XI_ERROR:
ZEDLMSG = 'AN ERROR OCCURRED IN SCRIPT LINE ' SCRIPTL
ERRORCOND = '1'
INFO1 = 'SCRIPT ERROR ' SCRIPTL
RC = 0
SIGNAL ERRRETURN1
RETURN

INTERPRET_SCRIPT:
SCRIPTA = 'SIGNAL ON SYNTAX NAME ERRORCOND; ' || SCRIPTL
INTERPRET SCRIPTA
RETURN

ERRORCOND:
ZEDLMSG = 'AN ERROR OCCURRED IN SCRIPT LINE ' SCRIPTL
ERRORCOND = '1'
RETURN

CLEAR_EXTENDS:
EXTENDA = ''
EXTENDB = ''
EXTENDC = ''
EXTENDD = ''
EXTENDE = ''
EXTENDF = ''
EXTENDG = ''
EXTENDH = ''
EXTENDI = ''
EXTENDJ = ''
EXTENDK = ''
EXTENDL = ''
EXTENDM = ''
EXTENDN = ''
EXTENDO = ''
EXTENDP = ''
EXTENDQ = ''
EXTENDR = ''
EXTENDS = ''
EXTENDT = ''
EXTENDU = ''
EXTENDV = ''
EXTENDW = ''
EXTENDX = ''
EXTENDY = ''
EXTENDZ = ''
RETURN

NULL_EXTENDS:
IF EXTENDA = 'EXTENDA' THEN EXTENDA = ''
IF EXTENDB = 'EXTENDB' THEN EXTENDB = ''
IF EXTENDC = 'EXTENDC' THEN EXTENDC = ''
IF EXTENDD = 'EXTENDD' THEN EXTENDD = ''
IF EXTENDE = 'EXTENDE' THEN EXTENDE = ''
IF EXTENDF = 'EXTENDF' THEN EXTENDF = ''
IF EXTENDG = 'EXTENDG' THEN EXTENDG = ''
IF EXTENDH = 'EXTENDH' THEN EXTENDH = ''
IF EXTENDI = 'EXTENDI' THEN EXTENDI = ''
IF EXTENDJ = 'EXTENDJ' THEN EXTENDJ = ''
IF EXTENDK = 'EXTENDK' THEN EXTENDK = ''
IF EXTENDL = 'EXTENDL' THEN EXTENDL = ''
IF EXTENDM = 'EXTENDM' THEN EXTENDM = ''
IF EXTENDN = 'EXTENDN' THEN EXTENDN = ''
IF EXTENDO = 'EXTENDO' THEN EXTENDO = ''
IF EXTENDP = 'EXTENDP' THEN EXTENDP = ''
IF EXTENDQ = 'EXTENDQ' THEN EXTENDQ = ''
IF EXTENDR = 'EXTENDR' THEN EXTENDR = ''
IF EXTENDS = 'EXTENDS' THEN EXTENDS = ''
IF EXTENDT = 'EXTENDT' THEN EXTENDT = ''
IF EXTENDU = 'EXTENDU' THEN EXTENDU = ''
IF EXTENDV = 'EXTENDV' THEN EXTENDV = ''
IF EXTENDW = 'EXTENDW' THEN EXTENDW = ''
IF EXTENDX = 'EXTENDX' THEN EXTENDX = ''
IF EXTENDY = 'EXTENDY' THEN EXTENDY = ''
IF EXTENDZ = 'EXTENDZ' THEN EXTENDZ = ''
RETURN

APPEND_EXTENDS:
@EXTEND = EXTENDA  EXTENDB  EXTENDC  EXTENDD  EXTENDE  EXTENDF
@EXTEND = @EXTEND  EXTENDG  EXTENDH  EXTENDI  EXTENDJ  EXTENDK
@EXTEND = @EXTEND  EXTENDL  EXTENDM  EXTENDN  EXTENDO  EXTENDP
@EXTEND = @EXTEND  EXTENDQ  EXTENDR  EXTENDS  EXTENDT  EXTENDU
@EXTEND = @EXTEND  EXTENDV  EXTENDW  EXTENDX  EXTENDY  EXTENDZ
RETURN

SYSTEMS_CONSOLE:
"ISPEXEC LIBDEF ISPTLIB DATASET ID('"SYSTEMS_ISPTLIB"') STACK"
"ISPEXEC LIBDEF ISPTABL DATASET ID('"SYSTEMS_ISPTABL"') STACK"
"ISPEXEC TBOPEN @USERCMD SHARE"
ZRC = RC
"ISPEXEC TBTOP "@USERCMD""
SYSTEMCMDS. = ''
SYSLIST = ''
SYSCOMMANDLIST = ''
IF ZRC = 0 THEN
DO II = 1 TO MAXCOMMANDS
   CALL CLEAR_EXTENDS
   "ISPEXEC TBSKIP "@USERCMD" NUMBER(+1)"
   IF RC= 8 THEN LEAVE
   IF @MEMBER = '' THEN LEAVE
   PARSE UPPER VAR @MEMBER @MEMBER
   CALL NULL_EXTENDS
   CALL APPEND_EXTENDS
   if substr(@member,1,1) = '<' then
      startup = startup @member
      if substr(@member,1,1) = '>' then
         shutdown = shutdown @member
   SYSLIST = SYSLIST @MEMBER
   SYSTEMCMDS.@MEMBER = @EXTEND
   END
IF WORDS(SYSLIST) > 1 THEN DO
   DO ULIST = 1 TO WORDS(SYSLIST) - 1
      SYSCOMMANDLIST = SYSCOMMANDLIST WORD(SYSLIST,ULIST) || ','
      END
   SYSCOMMANDLIST = SYSCOMMANDLIST 'AND' WORD(SYSLIST,ULIST) || '.'
   END
ELSE
   SYSCOMMANDLIST = SYSLIST || '.'
"ISPEXEC TBCLOSE "@USERCMD""
"ISPEXEC LIBDEF ISPTLIB"
"ISPEXEC LIBDEF ISPTABL"
RETURN

USER_CONSOLE:
"ISPEXEC LIBDEF ISPTlib DATASET ID('"ucUSER".JUMPLIST') STACK"
"ISPEXEC LIBDEF ISPTABL DATASET ID('"ucUSER".JUMPLIST') STACK"
IF JUMPPROF = '@USERCMD' THEN
   "ISPEXEC TBCLOSE "@USERCMD""
"ISPEXEC TBOPEN @USERCMD SHARE"
"ISPEXEC TBTOP "@USERCMD""
USERCMDS. = ''
USERLIST = ''
USERCOMMANDLIST = ''
DO II = 1 TO MAXCOMMANDS
   CALL CLEAR_EXTENDS
   "ISPEXEC TBSKIP "@USERCMD" NUMBER(+1)"
   IF RC= 8 THEN LEAVE
   IF @MEMBER = '' THEN LEAVE
   PARSE UPPER VAR @MEMBER @MEMBER
   CALL NULL_EXTENDS
   CALL APPEND_EXTENDS
   if substr(@member,1,1) = '<' then
      startup = startup @member
   if substr(@member,1,1) = '>' then
      shutdown = shutdown @member
   USERLIST = USERLIST @MEMBER
   USERCMDS.@MEMBER = @EXTEND
   END
IF WORDS(USERLIST) > 1 THEN DO
   DO ULIST = 1 TO WORDS(USERLIST) - 1
      USERCOMMANDLIST = USERCOMMANDLIST WORD(USERLIST,ULIST) || ','
      END
   USERCOMMANDLIST = USERCOMMANDLIST 'AND' WORD(USERLIST,ULIST) || '.'
   END
ELSE
   USERCOMMANDLIST = USERLIST || '.'
"ISPEXEC TBCLOSE "@USERCMD""
PARSE UPPER VAR USERLIST USERLIST
"ISPEXEC LIBDEF ISPTLIB"
"ISPEXEC LIBDEF ISPTABL"
RETURN

startup:
do ii = 1 to words(startup)
   cmd = word(startup,ii)
   CALL SYS_FUNCTION CMD
   CALL USER_FUNCTION CMD
   end
return

shutdown:
do ii = 1 to words(shutdown)
   cmd = word(shutdown,ii)
   CALL SYS_FUNCTION CMD
   CALL USER_FUNCTION CMD
   end
return

LMINIT_BROWSE: PROCEDURE EXPOSE DATALINE
"ISPEXEC CONTROL DISPLAY SAVE"
"ISPEXEC VGET ZTEMPN SHARED"
"ISPEXEC LMINIT DATAID(ZTEMPDD) DDNAME("ZTEMPN")"
"REPRO INDATASET('"DATALINE"')",
    "OUTFILE("ZTEMPN")"
"ISPEXEC BROWSE DATAID("ZTEMPDD")"
"ISPEXEC LMFREE DATAID("ZTEMPDD")"
"ISPEXEC CONTROL DISPLAY RESTORE"
RETURN

COPYprof: procedure expose @user JUMPPROF
CDSN =  ""@USER".JUMPLIST.ROLLOVER"
CDSN1 = ""@USER".JUMPLIST.ROLLOVER"
"ISPEXEC CONTROL ERRORS RETURN"
"ISPEXEC LMINIT DATAID("ZTEMPDA") DATASET('"CDSN"')"
"ISPEXEC LMINIT DATAID("ZTEMPDB") DATASET('"CDSN1"')"
"ISPEXEC LMCOPY FROMID("ZTEMPDA") FROMMEM(TEMPPROF)",
   "TODATAID("ZTEMPDB") TOMEM("JUMPPROF") REPLACE"
"ISPEXEC LMFREE DATAID("ZTEMPDA")"
"ISPEXEC LMFREE DATAID("ZTEMPDB")"
RETURN

SETUP:
USERID = USERID()
IF SYSDSN('ADMIN.JUMPLIST') <> 'OK' THEN DO
   "ALlocate DD(ALLOCDD) DSN('ADMIN.JUMPLIST') SPACE (1 10)",
   "DSORG(PO) DIR(5) LRECL(80) BLKSIZE(3200) RECFM(F,B) MOD REUSE"
   "FREE DD(ALLOCDD)"
   end
"ISPEXEC LIBDEF ISPTlIB DATASET ID('ADMIN.JUMPLIST') STACK"
"ISPEXEC LIBDEF ISPTABL DATASET ID('ADMIN.JUMPLIST') STACK"
IF SYSDSN('ADMIN.JUMPLIST(JLADMIN)') <> 'OK' THEN
   "ISPEXEC TBCREATE JLADMIN KEYS(SUKEY)",
      "NAMES(SYSID, MAXC, ETYPE, ISPPLIB) WRITE REPLACE"
ELSE
   "ISPEXEC TBOPEN JLADMIN WRITE"
"ISPEXEC CONTROL DISPLAY SAVE"
SUKEY = 'SETUP'
"ISPEXEC TBGET JLADMIN"
"ISPEXEC DISPLAY PANEL(JLSETUP)"
"ISPEXEC TBMOD JLADMIN"
"ISPEXEC CONTROL DISPLAY RESTORE"
"ISPEXEC TBCLOSE JLADMIN"
"ISPEXEC LIBDEF ISPTLIB"
"ISPEXEC LIBDEF ISPTABL"
RETURN
XQ ENDUP
/*
//IBMUSERA JOB 'INIT',MSGLEVEL=(0,0),MSGCLASS=X,REGION=2048K,CLASS=A          00
//*                                                                           00
//*CHANGE USERID TO YOUR TSO LOGIN ID.  LEAVE THE APPENDED A.                 00
//*
//* START JCL
//INIT    EXEC PGM=IEBUPDTE,PARM=NEW
//SYSPRINT DD SYSOUT=X
//*
//SYSUT2   DD DSN=USER.ISPPLIB,DISP=SHR
//*
//*CHANGE sysut2 to point to the ispf panel library where the user
//*panels reside.  you may need to have racf authorization to write
//*to this data set.
//*
//SYSIN    DD DATA
./ ADD NAME=JUMPLIST,LIST=ALL
)ATTR
( TYPE(input) INTENS(high) color(green)
- TYPE(input) INTENS(high) color(white) hilite(uscore)
+ TYPE(TEXT) INTENS(HIGH) COLOR(turquoise)
# TYPE(TEXT) INTENS(HIGH) COLOR(red) SKIP(ON)
* TYPE(INPUT) INTENS(HIGH) COLOR(GREEN) hilite(uscore)
% TYPE(text) INTENS(HIGH) COLOR(white)
\ TYPE(text) INTENS(HIGH) COLOR(blue)
^ TYPE(output) INTENS(HIGH) COLOR(BLUE) skip(on)
$ TYPE(output) INTENS(HIGH) COLOR(turquoise) skip(on)
! TYPE(INPUT) INTENS(HIGH) COLOR(red) HILITE(USCORE)
)BODY EXPAND(//)
+COMMAND%===>(ZCMD
+ / /#J+u m p #L+i s t/ /
+
+User ID*@user    +Profile*jumpprof+View Help*z+Directory*z#
^info1
^info2
+CMD   $Usename1  $Usename2
)MODEL
-CMD ^Z!@MEMBER ^Z!@INITIAl^z*@DATASET
)INIT
.ZVARS = '(help dir FILLER filler1 filler2)'
.CURSOR = &CURPOS
IF (&DIR = 'S')
   .ATTR (@USER) = 'TYPE(OUTPUT) COLOR(GREEN) HILITE(USCORE) SKIP(ON)'
   .ATTR (JUMPPROF) ='TYPE(OUTPUT) COLOR(GREEN) HILITE(USCORE) SKIP(ON)'
   .ATTR (@MEMBER) ='TYPE(OUTPUT) COLOR(RED) HILITE(USCORE) SKIP(ON)'
   .ATTR (@INITIAL) ='TYPE(OUTPUT) COLOR(RED) HILITE(USCORE) SKIP(ON)'
   .ATTR (@DATASET) ='TYPE(OUTPUT) COLOR(GREEN) HILITE(USCORE) SKIP(ON)'
   .CURSOR = &CURPOS
&ZTDMARK = ' '
&CMD = ''
&HPROF = &JUMPPROF
&HUSER = &@USER
)REINIT
.CURSOR = &CURPOS
)PROC
.CURSOR = &CURPOS
IF (&DIR = 'S')
   .ATTR (@USER) = 'TYPE(OUTPUT) COLOR(RED)'
&ZTOP = ZTDSIZE
IF (&JUMPPROF = '')
   &JUMPPROF = &HPROF
IF (&HUSER = '')
   &@USER = &HUSER
)END
./ ADD NAME=JLHELP,LIST=ALL
)ATTR
( TYPE(input) INTENS(high) color(green)
# TYPE(TEXT) INTENS(HIGH) COLOR(red) SKIP(ON)
* TYPE(INPUT) INTENS(HIGH) COLOR(GREEN) hilite(uscore)
% TYPE(text) INTENS(HIGH) COLOR(yellow)
\ TYPE(text) INTENS(HIGH) COLOR(TURQUOISE)
^ TYPE(output) INTENS(HIGH) COLOR(BLUE) skip(on)
! TYPE(text) INTENS(HIGH) COLOR(turquoise)
$  AREA(SCRL) EXTEND(ON)
)BODY EXPAND(~~)
$MYAREA ---------------------------------------------------------------$
)AREA MYAREA DEPTH(1)
!
%~ ~ JUMPLIST QUICK REFERENCE ~ ~
!
%CMD OPTIONS
\#E\Edits the specified data set.  If a member is not specified then
\ a listing will be shown of the data set contents.  Use an#S!to select
\ the desired member.  If a source member is specified in MEMBER then
\ the member is edited.  If a data set is sequential then the file is
\ directly edited. The edit function does not support VSAM files.
\
+#ESCR\Forces a data set edit using the DSLIST function of option 3.4.
+
\#V\Views the specified data set   If the data set is
\ partitioned then a list of its members is shown.  The user can then
\ select the member to view.  If the data set is sequential then the
\ file is directly viewed.  If a member is specified then the member is
\ directly viewed.  The view function does not support VSAM files.
\
\#B\Browses the data set specified in DATASET.  If the data set is
\ partitioned then a list of its members is shown.  The user can then
\ select the member to browse.  If the data set is sequential then the
\ file is directly browsed.  If a member is specified then the member is
\ directly browsed.  The Browse function can be used for VSAM files.
\
\#Z\Compresses the specified data set.
\
\#J\Submits the JCL member in MEMBER.  The data set must be specified.
\ This function only supports PDS files.
\
\#ES\Edits the script that is specified in INITIAL.  The script is in
\ an ISPF display table format.  REXX type commands can be entered to
\ allow for symbolic variable replacement to occur for file tailoring.
\ The file tailoring member name is specified in MEMBER and is
\ referenced by the ISPSLIB libdef.  The libdef can be overridden
\ by specifying the data set name in the rightmost entry field.
\ The file tailoring member must exist in the ISPSLIB libdef library.
\
\#FE\File tailor edit.  Edits the results of the file tailoring
\ process that occurred for the file tailor MEMBER name.  The symbolics
\ that were specified in MEMBER will be replaced by the values that
\ were specified in INITIAL.
\
\#FJ\File tailor submit.  Submits the results of the file tailoring
\ process that occurred for the file tailor MEMBER name.  The symbolics
\ that were specified in MEMBER will be replaced by the values that
\ were specified in INITIAL.
\
\#XI\Executes the immediate script specified on the JumpList panel.
\
\#XS\Tests the script that is specified in INITIAL.
\
\#/I\Inserts one blank line into the profile.
\
\#/Ixx\Inserts xx blank lines into the profile, where xx is a two digit
\ numeric value.
\
\#/D\Deletes one blank line from the profile.
\
\#/Dxx\Deletes xx blank lines from the profile, where xx is a two digit
\ numeric value.
\
\#/R\Replicates a line in the profile.
\
\#/Rxx\Replicates xx blank lines in the profile, where xx is a two digit
\ numeric value.
\
%JUMPLIST USAGE
\ Enter TSO JUMPLIST profname where profname is the profile name to be
\ created.  An example is TSO JUMPLIST UTILS.  If the profile is new
\ then a profile screen with 10 blank entry lines is displayed.  The
\ number of lines can be adjusted with the CMD functions presented
\ in this article.  If the profile already exists then that profile will
\ be displayed.
\#Note\ A profile name can be up to 8 characters long and must begin
\ with an alpha character.  No special characters can be used in the
\ name.
\
\ Profile names can be changed in the middle of a JUMPLIST session.
\ Simply key the name of the profile and press enter.  Other user's
\ profiles can be used also.  Key in the name of the user id in USER
\ and key the profile name in.  If the profile is in use by the owner
\ then JUMPLIST will generate a temporary copy of the profile that
\ is read only.  If a profile is specified twice, through duplicate
\ JumpList sessions, errors may occur if the profile is modified
\ and may result in a ISPF error.  If this occurs then restart
\ JumpList using TSO JUMPLIST /CLOSE.  This will deallocate the
\ profile.
\
%Immediate Scripts
! Enter commands in the rightmost field.
!
! Precede Rexx and TSO commands with a dash.  Enclose TSO commands
! with with the#"!character.
!
! Use /XPN in CMD to expand the field to 2045 characters.  A new
! window will appear to allow for the expanded entry.
!
! Append double semicolons after all logical commands.  A logical
! command is similar to:
!
!#-DO II = 1 TO 100;SAY II;END;;
!
! Use XI in CMD to execute the script.
\
%User and Supervisor Commands
! Enter @USERCMD as the profile name to start the command editor.
!
! Supervisor commands are simply commands created by the supervisor
! or systems analyst.  See the notes at the top of the JUMPLIST
! Rexx Exec to properly configure the global access.
!
! Enter the name of the new command under the COMMAND field.  For
! short commands, the commands will be enter in the rightmost field.
! Use /XPN in CMD to expand the field to 2045 characters.  A new
! window will appear to allow for the expanded entry.
!
! Previously defined commands can be executed in the new command by
! preceding it with an equal sign.  Prior defined commands cannot be
! executed within a logical Rexx statement such as
!
!#-DO II = 1 TO 100;=CMD1;END;;
!
! However, the GOTO='label' clause, where label is some user defined
! label name, allows execution paths to be altered in a series of
! Rexx commands, such as
!
!#X=10;;:label;;-X=X-1;=CMD1;;-IF X > 0 THEN GOTO='label';;
!
! This allows for previously defined user commands to be conditionally
! executed in a script.
!
!#-DO II = 1 TO 100;SAY II;END;;
!
! Commands can be stacked if they are separated by the#;;!delimiter.
!
! The user or supervisor command name cannot be more than 4 characters
! in length The exception is if the command will be used as a startup or
! shutdown command.
!
! A startup command will be preceded with a less than sign such as
! <START1.  A shutdown command will be preceded with a greater than
! sign such as >SHUTDN1.  If a coding error prevents the utility
! from starting then issue TSO JUMPLIST /CLOSE.  This will prevent
! the commands from executing and will allow the repair of the command.
! Is is best to write the command as an immediate script first to
! allow it to be tested and then transfer it to a START/STOP script.
!
! PF3 back to TSO and restart JumpList to load the updated user
! command list.
!
%Directory Assistance
! Profiles can be selected and maintained through the Directory
! function.  A list of available profiles and INITIAL scripts is
! shown.  You can select a profile with a#S!or delete a profile or
! INITIAL script with a #D! in the CMD field.
!
%Internal Notes
\ Profiles are retained in an ISPF data set as separate table entries.
\ See MAINTENANCE NOTES below for the naming convention.  There is
\ enough directory and table space available for a reasonable number
\ of entries.  If more space is needed then rename the profile
\ data set, increase the space and directory size in the utility and
\ restart JumpList.  Then copy the backed up profiles to the redefined
\ data set.
\
\ The structure of JumpList uses 3 key table elements.  They are
\ @MEMBER, for the Member name, @INITIAL for the script name, and
\ DATALINE for data set, immediate script, and user command entry.
\ DATALINE is a subordinate name to @DATASET which is used in the
\ table definition.  The extended entries for DATALINE are kept in
\ the EXTEND variables which are a part of the table definition.  These
\ variables are not directly accessible by the user.
\
%Maintenance Notes
\ The user profiles are kept in
\ userid.JUMPLIST
\ The user scripts are kept in
\ userid.JUMPLIST.SCRIPT
\ Rollover scripts are kept in
\ userid.JUMPLIST.ROLLOVER
\ where userid is the TSO login ID.
\ The Rollover data set is internal to the utility and allows for
\ duplicate profiles to be utilized when a requested foreign profile
\ is in use.  It normally will be of no concern to the user.
)INIT
)PROC
)END
./ ADD NAME=JLSCRIPT,LIST=ALL
)ATTR
- TYPE(output) INTENS(high) color(yellow)
@ TYPE(INPUT) INTENS(HIGH) COLOR(GREEN)
# TYPE(TEXT) INTENS(HIGH) COLOR(red) SKIP(ON)
* TYPE(INPUT) INTENS(HIGH) COLOR(GREEN) hilite(uscore)
% TYPE(text) INTENS(HIGH) COLOR(white)
+ TYPE(text) INTENS(HIGH) COLOR(blue)
^ TYPE(INPUT) INTENS(HIGH) COLOR(BLUE) HILITE(USCORE)
! TYPE(INPUT) INTENS(HIGH) COLOR(red) HILITE(USCORE)
_ TYPE(INPUT) INTENS(HIGH) COLOR(GREEN) hilite(uscore)
)BODY EXPAND(//)
+COMMAND%===>@ZCMD
+
+ / /#J+u m p #L+i s t / /
+
+REXX MODE SCRIPT LINES
)MODEL
_SCRIPTL
)INIT
&ZTDMARK = ' '
)REINIT
)PROC
)END
./ ADD NAME=JLSETUP,LIST=ALL
)ATTR
# TYPE(TEXT) INTENS(LOW) SKIP(ON)
+ TYPE(TEXT) INTENS(HIGH) COLOR(BLUE)
* TYPE(TEXT) INTENS(HIGH) COLOR(RED)
% TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) SKIP(ON)
@ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)
- TYPE(OUTPUT) INTENS(HIGH) COLOR(BLUE)
$ TYPE(OUTPUT) INTENS(HIGH) COLOR(GREEN)
) TYPE(OUTPUT) INTENS(HIGH) COLOR(YELLOW)
_ TYPE(INPUT) INTENS(HIGH) COLOR(GREEN) HILITE(USCORE)
( TYPE(INPUT) INTENS(HIGH) COLOR(GREEN)
)BODY EXPAND(//)
+COMMAND%===>(ZCMD
+
 / /*J u m p L i s t   Setup/ /
+
)ZINFO                                                        #
+
%Panel Library Definition
@The LIBDEF is the data set where the JumpList panels reside.  If left
@blank, the system libdef defined in the login proc will be used.
_ISPPLIB                         #
+
%System Command Administrator#
_SYSID  #
#
%Edit Type
@1 for single character command column
@8 for 8 character command column
@9 for 9 character command column
_Z#
+
%Maximum Commands
_MAXC#
)INIT
.ZVARS = '(ETYPE)'
IF (&SYSID = '')
   &SYSID = &USERID
IF (&ETYPE = '')
   &ETYPE = '8'
IF (&MAXC = '')
   &MAXC = 1000
VER(&ETYPE,LIST,1,8,9)
IF (&SYSID NE &USERID)
   &ZINFO = 'AUTHORIZATION ERROR.  BROWSE MODE SUBSTITUTED'
   .ATTR (SYSID) = 'TYPE(OUTPUT) COLOR(RED) HILITE(USCORE) SKIP(ON)'
   .ATTR (ETYPE) = 'TYPE(OUTPUT) COLOR(RED) HILITE(USCORE) SKIP(ON)'
   .ATTR (MAXC) = 'TYPE(OUTPUT) COLOR(RED) HILITE(USCORE) SKIP(ON)'
)REINIT
)PROC
VER(&ETYPE,LIST,1,8,9)
IF (&MAXC = '')
   &MAXC = 1000
)END
./ ADD NAME=JLXPND,LIST=ALL
)ATTR
( TYPE(input) INTENS(high) color(green)
+ TYPE(TEXT) INTENS(HIGH) COLOR(turquoise)
# TYPE(TEXT) INTENS(HIGH) COLOR(red) SKIP(ON)
% TYPE(text) INTENS(HIGH) COLOR(white)
\ TYPE(text) INTENS(HIGH) COLOR(blue)
^ TYPE(INPUT) INTENS(HIGH) COLOR(RED) HILITE(USCORE)
! TYPE(INPUT) INTENS(HIGH) COLOR(GREEN) HILITE(USCORE)
$  AREA(SCRL) EXTEND(ON)
)BODY EXPAND(//)
$MYAREA -----------------------------------------------------------------------$
)AREA MYAREA DEPTH(1)
+
+COMMAND%===>(ZCMD                                                             #
+ / /#J+u m p #L+i s t/ /
+
+Precede logical Rexx commands with -.
+Precede references to user commands with =.
+Separate logical commands with double semicolons ;;
+
^EXTENDA                                           #
^EXTENDB
^EXTENDC
^EXTENDD
^EXTENDE
^EXTENDF
^EXTENDG
^EXTENDH
^EXTENDI
^EXTENDJ
^EXTENDK
^EXTENDL
^EXTENDM
^EXTENDN
^EXTENDO
^EXTENDP
^EXTENDQ
^EXTENDR
^EXTENDS
^EXTENDT
^EXTENDU
^EXTENDV
^EXTENDW
^EXTENDX
^EXTENDY
^EXTENDZ
)INIT
)REINIT
)PROC
)END
./ ENDUP
/*
