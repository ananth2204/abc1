{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012903000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1998724, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE826.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1998724, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1998724, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE826.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00 \\t'", "DS1TRBAL": "b'i\\x96'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05\\xa7\\x00\\x0b\\x05\\xa9\\x00\\r\\x00!'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00@\\x01 \\x01\\x9f\\x01 \\x01\\x9f\\x14R\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2020-01-19T00:00:00", "modifydate": "2020-01-19T14:52:40", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-499"}, "text": "REGULAR CBT TAPE - VERSION 499    FILE:  826\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT499.FILE826\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 27 MEMBERS COUNTED; CUMULATIVE SIZE IS 18,747 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   01/19/20    14:52:40    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$CAUTION": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x001\\x01\\x12(\\x8f\\x01\\x17\\x17?\\x11\\x03\\x00,\\x00\\x1e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2012-10-14T00:00:00", "modifydate": "2017-06-22T11:03:31", "lines": 44, "newlines": 30, "modlines": 0, "user": "SBGOLOB"}, "text": "                          -----          -------------\nNote about CNCLPG version 1.2.6.         C A U T I O N\n           ------         -----          -------------\n\nThe current release, 1.2.10E is higher than 1.2.6.\n\nCNCLPG version 1.2.6 contains the undocumented capability of\nbeing able to BURN an address space, which is like a FORCE.\nThe burn can be done, without the address space being either\ncancelable or forcible.  The BURN is done via a CALLRTM macro\nwith TYPE=MEMTERM.  KILL is the same as BURN, except that if\nthe job is really NON-FORCIBLE in that the ASCB \"no MEMTERM\"\nbit(s) are set, KILL will turn these bits off before doing\nthe MEMTERM, so it will be sure(r) to get rid of the address\nspace.  (Whack it, baby...!!!)\n\nSometimes it is necessary for a systems programmer to\nsurgically remove an address space from the system, if it is\nnot functioning properly, and to restart it afterwards.  This\nis what the BURN function is for.  It is to be used VERY VERY\nCAREFULLY, AND ONLY WHEN ABSOLUTELY NEEDED.  Same for KILL.\n\nSince, when you do a BURN on an address space, you remove it,\nthis is kind of dangerous.  Therefore ALWAYS run a DISPlay\nfunction before running a BURN, and ALWAYS use the ASID(nnnn)\nparameter of CNCLPG so that you know BOTH the full jobname\nand the ASID of the job, to be absolutely definite that THIS\nis the address space you want to BURN, and NOT ANY OTHER !!!!!\nSame for KILL......\n\nPlease note that as the program is currently coded, if you do\na partial jobname, like JES2, other jobnames like JES2AUX and\nJES2MON are also included in the CSCB search, and the name\nJES2 does not necessarily come out first in the search of the\nCSCB.  Therefore, using the ASID(nnnn) parameter is IMPERATIVE\nwhen you are doing a BURN, so you get the EXACT address space\nand not the wrong one.  Same for KILL.....\n\nThis feature is not found in CNCLPG version 1.2.0.  The \"5\"\nis an indicator that this feature is present in your version\nof the CNCLPG program.  \"6\" for KILL.  Version is 1.2.6.\n\nGood luck.  BE VERY VERY VERY CAREFUL........\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$CNCLPGH": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x14\\x01\\x17\\x15\\x9f\\x01\\x17\\x17?\\x11\\x03\\x009\\x00 \\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2017-06-08T00:00:00", "modifydate": "2017-06-22T11:03:14", "lines": 57, "newlines": 32, "modlines": 0, "user": "SBGOLOB"}, "text": "\nSyntax:     TSO Command:  APF-authorized.\n\n    CNCLPG |jobid \u00ddASID(hhhh)\u00a8 |CNCL|NCNC (cancelable, non-canc)\n           |ASID(hhhh)         |FORC    (force w/o cancel)\n           |                   |NFRC    (force needs cancel)\n           |                   |NSWP|SWAP (non-swap, swappable)\n           |                   |TSWP (transwap)\n           |                   |FSWP (force swappable immediate)\n           |                   |CSCB or DISP (display CSCB blks)\n           |                   |BURN (memterm the address space)\n           |                   |KILL (memterm after turning\n           |                   |      off non-memtermable bits)\n           |                   |NMEM|MEMT  (turn on/off\n           |                   |        non-memtermable bits)\n           |                   |COUNT  (display DONTSWAP count)\n           |-  (displays the entire CSCB chain)\n           |?  (displays help)\n\n\n The following display was produced by CNCLPG ?\n\n\nCNCLPG 1.2.10E - Alter Characteristics of a Running Address Space\n------ ------- - ----- --------------- -- - ------- ------- -----\n  * -----  ALWAYS DO A DISPLAY FIRST  ----- *\nSyntax:  CNCLPG jobname ASID(hhhh) FUNCtion\n   Function is:  CNCL, NCNC, FORC, NFRC, NSWP,\n   SWAP, MEMT, NMEM, TSWP, or COUNT.\n FSWP, BURN, or KILL are dangerous.\n   TSWP will do a TRANSWAP.\nOr code CSCB or DISP to just display CSCB entries.\n   DISPlay or CSCB will display CSCB chain entries,\n   without changing them.\n-----------------------------------------------\n When affecting a job, we must affect the CORRECT job,\n  therefore you should use the DISPlay option first.\n-----------------------------------------------\n To display the whole CSCB, code - (dash) for JOBNAME.\n To see this help message, code ? for JOBNAME.\n-----------------------------------------------\n** NOTES (IMPORTANT) :  ** BE SURE TO READ THIS **\n-----------------------------------------------\n CSCB (DISP) display for an ASID shows ALL occurrences\n  for that ASID, regardless of JOBNAME.\n CSCB (DISP) display for a JOBNAME shows ALL occurrences\n  for those JOBNAME characters, regardless of ASID.\n CNCL, NCNC, FORC, NFRC, NSWP, SWAP changes the FIRST\n  entry in the CSCB chain that matches, if multiple\n  entries exist. But DISP will display ALL applicable\n  matching entries in the CSCB chain, so you can see\n  which one you want to change specifically.\n When you code BOTH jobname AND asid, to CHANGE it,\n  then ONLY that specific job and asid gets changed.\n-----------------------------------------------\n  * -----  ALWAYS DO A DISPLAY FIRST  ----- *\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$DESCR": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x17\\x01\\x10\\x10_\\x01\\x17\\x18?\\x14\\x01\\x00\\xc3\\x00\\x87\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2010-04-15T00:00:00", "modifydate": "2017-07-02T14:01:17", "lines": 195, "newlines": 135, "modlines": 0, "user": "SBGOLOB"}, "text": "Notes about the CNCLPG TSO command:\n\n\nThe CNCLPG TSO command is an APF-authorized command (which has to\nappear in the IKJEFTE2 table (AUTHCMD)) and which will make an address\nspace Cancelable, Non-Cancelable, Forcible, or Non-Forcible.  Also,\nNon-swappaple or Swappable.\n\nWith later releases, CNCLPG can do much more.  See the SYNTAX below.\n\nSince this is a standalone command and is not part of any other\npackage, it is transportable between shops and you can use it\nanywhere.  It is (of course) also FREE and Public Domain.\n\nAuthority required:  As coded, the TSO user needs PSCB OPER authority.\n                     For BURN and KILL, PSCB ACCOUNT authority is\n                     needed in addition to OPER.  You can add more\n                     authority checking according to shop requirements.\n\n  SYNTAX:     TSO Command:  APF-authorized.\n\n    CNCLPG |jobid \u00ddASID(hhhh)\u00a8 |CNCL|NCNC (cancelable, non-cancelable)\n           |ASID(hhhh)         |FORC    (force w/o cancel)\n           |                   |NFRC    (force needs cancel first)\n           |                   |NSWP|SWAP (non-swap, swappable)\n           |                   |TSWP (transwap)\n           |                   |FSWP (force swappable immediately)\n           |                   |CSCB or DISP (display CSCB blks)\n           |                   |BURN (memterm the address space)\n           |                   |KILL (do memterm after turning\n           |                   |      off non-memtermable bits)\n           |                   |NMEM|MEMT  (turn on/off\n           |                   |        non-memtermable bits)\n           |                   |COUNT  (display DONTSWAP count)\n           |-  (displays the entire CSCB chain)\n           |?  (displays help)\n\n    The first parameter of the command is the \"jobname\" field.\n\n    In this first field, you can put the Jobname to change, or\n    an ASID(nnnn), or a dash (-) for a display of the entire\n    CSCB chain of address spaces, or a ? for help.\n\n    The field after the jobname, ASID(hhhh) or both,\n    is a command field.\n\n    There are \"action\" commands and \"display\" commands.\n\n    Action  commands are:  CNCL, NCNC, FORC, NFRC, NSWP, SWAP,\n                           BURN, KILL, TSWP, FSWP. NMEM, MEMT\n\n    Display commands are:  CSCB or DISP\n\n    Action commands will change only the FIRST entry encountered.\n\n    Display commands will show ALL eligible entries satisfying\n    equality with the stated parameters: jobname, ASID(hhhh),\n    or both.\n\n    Therefore, to do an action, it is recommended to do display\n    commands first, to narrow down the choice of job to exactly\n    the ONE ADDRESS SPACE that you want to change.  Usually you\n    have to do this by specifying BOTH jobname and ASID(hhhh)\n    for that particular job, when you issue an \"action\" command.\n\n    There, you tell the program what to do with the chosen\n    address space (make it cancelable, non-cancelable,\n    forcible, or non-forcible, swappable, or non-swappable).\n\n    Probably the best thing to do is to say CSCB or DISP to\n    display all the jobnames and address spaces that match the\n    chosen combination, and then you can try to change only\n    the exact jobname and address space number combination.\n\n    For the following examples, please note that CNCLPG\n    is at level 1.2.10E now.\n\n    Example:   tsov cnclpg sbgolob disp\n\n    Result:\n\nCNCLPG 1.2.10E - Alter Characteristics of a Running Address Space\n------ ------- - ----- --------------- -- - ------- ------- -----\nSearch Jobname:  SBGOLOB\n----------------------------\nAction code   :  CSCB  (DISPlay)\nThis is a run of the CSCB Chain only ...\n----------------------------\nJob  ID :  SBGOLOB\nProc ID :  SPFPROCE\nASID    :  0051\nCurrent  CHACT Flags:  C8\nJob Status:  Cancelable\nJob Status:  Cancel + Force\nJob Status:  Swappable\nJob Status:  Memtermable\n----------------------------\nJob  ID :  SBGOLOB\nProc ID :  SBGOLOB\nASID    :  004D\nCurrent  CHACT Flags:  08\nJob Status:  Cancelable\nJob Status:  Cancel + Force\nJob Status:  Non-Swappable\nJob Status:  Memtermable\n----------------------------\nReturn code is 0\n\n\n    You see that there are two address spaces with name SBGOLOB,\none has ASID(0051) and the other has ASID(004D).  To change the\none we want to change, that is, the one with ASID(0051), you want\nto code both parameters:\n\n    CNCLPG SBGOLOB ASID(51) NCNC (or whichever of the commands)\n\nThe result of this command is:\n\nCNCLPG 1.2.10E - Alter Characteristics of a Running Address Spacep)\n------ ------- - ----- --------------- -- - ------- ------- -----\nSearch Jobname:  SBGOLOB\n----------------------------\nASID parm entered  :   51\nSearch ASID   :      0051\n----------------------------\nJob  ID :  SBGOLOB\nProc ID :  SPFPROCE\nASID    :  0051\nPrevious CHACT Flags:  C8\nJob Status:  Cancelable\nJob Status:  Cancel + Force\nJob Status:  Swappable\nJob Status:  Memtermable\n----------------------------\nJob  ID :  SBGOLOB\nProc ID :  SPFPROCE\nASID    :  0051\nModified CHACT Flags:  C0\n----------------------------\nAction code   :  NCNC\nCancel Indicator Flag :  F7\nCurrent  CHACT Flags:  C0\nJob Status:  Non-Cancelable\nJob Status:  Cancel + Force\nJob Status:  Swappable\nJob Status:  Memtermable\nReturn code is 0\n\n\n    It may be surprising, but on some systems, there are two\ndistinct entries on the CSCB table with the same ASID.  I didn't\nknow that, but here they are:  You see that each entry has\ndifferent properties.\n\n    CNCLPG ASID(3B) DISP\n\nCNCLPG 1.2.10E - Alter Characteristics of a Running Address Space )\n------ ------- - ----- --------------- -- - ------- ------- -----\nASID parm entered  :   4d\nSearch ASID   :      004D\n----------------------------\nAction code   :  CSCB  (DISPlay)\nThis is a run of the CSCB Chain only ...\n----------------------------\nJob  ID :  BPXAS\nProc ID :  BPXAS\nASID    :  004D\nCurrent  CHACT Flags:  00\nJob Status:  Non-Cancelable\nJob Status:  Cancel + Force\nJob Status:  Non-Swappable\nJob Status:  Memtermable\n----------------------------\nJob  ID :  SBGOLOB\nProc ID :  SBGOLOB\nASID    :  004D\nCurrent  CHACT Flags:  08\nJob Status:  Cancelable\nJob Status:  Cancel + Force\nJob Status:  Non-Swappable\nJob Status:  Memtermable\n----------------------------\nReturn code is 0\n\n\n    So the idea is, that you should use DISP to show you what\nentries are in the CSCB chain with regard to your job, and then\nbe very specific, using both jobname and asid, when you are\nmaking your changes.\n\n    Best of luck to all of you.  Use this utility in good health!\nAnd THINK before you change anything.....!!!\n\nSam\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$DISCLAM": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x12(\\x8f\\x01\\x12(\\x8f\\x18I\\x00o\\x00o\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-10-14T00:00:00", "modifydate": "2012-10-14T18:49:09", "lines": 111, "newlines": 111, "modlines": 0, "user": "SBGOLOB"}, "text": "All CBT Tape disclaimers apply to this file, and to all CBT Tape files.\n--- --- ---- ----------- ----- -- ---- ----  --- -- --- --- ---- -----\n\n//*******************************************************************\n//***SECTION DISCLAIMER SECTION                                     *\n//*******************************************************************\n//*                                                                 *\n//*            D I S C L A I M E R    S E C T I O N                 *\n//*                                                                 *\n//*******************************************************************\n//*                                                                 *\n//*   The tapes commonly referred to as \"The CBT MVS Utilities      *\n//*   Tape\", and \"The CBT Overflow Tape\", as well as \"The CBT       *\n//*   Overflow Tape Two\" are hereinafter referred to as \"this       *\n//*   tape\".  The materials on these \"tapes\", even if they are      *\n//*   not physically on a tape, but they exist on a cd-rom disk,    *\n//*   or on any other machine-readable medium, or printed, or       *\n//*   written, or in analog or digital form, or in any data         *\n//*   representation format, such as EBCDIC or ASCII or any other   *\n//*   data representation scheme, or they are in any compressed     *\n//*   or encrypted format, shall fully be included in all           *\n//*   disclaimers of responsibility, as though these materials      *\n//*   were actually physically on tape.                             *\n//*                                                                 *\n//*******************************************************************\n//*                                                                 *\n//*  THIS TAPE CONTAINS FREE SOFTWARE, NOT TO BE CHARGED FOR,       *\n//*  EXCEPT FOR HANDLING COSTS.                                     *\n//*                                                                 *\n//*  THIS TAPE MAY BE FREELY DUPLICATED.                            *\n//*                                                                 *\n//*******************************************************************\n//*                                                                 *\n//*  NOTICE.  There are certain copyrighted sections on this tape   *\n//*   which contain reservations of rights.  Owners of these        *\n//*   sections have given permission for the use of their           *\n//*   materials subject to the conditions stated in each case.      *\n//*                                                                 *\n//*   THESE RESERVATIONS DO NOT APPLY TO THE ENTIRE TAPE ... !!!.   *\n//*                                                                 *\n//*******************************************************************\n//*                                                                 *\n//*  DISCLAIMER REGARDING \"NON-FREE\" MATERIALS.                     *\n//*   The editor and/or any other persons or institutions,          *\n//*   corporations, or any other entity handling this tape,         *\n//*   do not assume responsibility for the inadvertent inclusion    *\n//*   of non-\"free\" materials.  If any such materials are found     *\n//*   to have been accidentally included on this tape, please       *\n//*   inform the editor immediately, and such materials will be     *\n//*   promptly removed.                                             *\n//*                                                                 *\n//*   ALL DISCLAIMERS OF RESPONSIBILITY, ABOVE AND BELOW, APPLY     *\n//*   TO ALL PERSONS AND/OR INSTALLATIONS OR ANY OTHER ENTITY       *\n//*   EDITING, DUPLICATING, PROCESSING, OR OTHERWISE HANDLING       *\n//*   THIS TAPE, AS WELL AS TO ALL AUTHORS AND CONTRIBUTORS OF      *\n//*   MATERIAL TO THIS TAPE.  NO RESPONSIBILITIES ARE ASSUMED       *\n//*   BY ANY OF THESE PERSONS, INSTALLATIONS, CORPORATIONS,         *\n//*   ENTITIES, INSTITUTIONS, OR ORGANIZATIONS.                     *\n//*                                                                 *\n//*   No warranty, expressed or implied, is provided by any or      *\n//*   all of the persons and/or installations editing,              *\n//*   duplicating, or otherwise handling this tape, as well as      *\n//*   by all authors and contributors of material to this tape.     *\n//*   Persons and/or installations using any of the programs or     *\n//*   materials on this tape, do so entirely at their own risk.     *\n//*                                                                 *\n//*******************************************************************\n//*                                                                 *\n//*   NO WARRANTY IS MADE TO THE ACCURACY OF THE PROGRAMS OR        *\n//*   RELATED MATERIAL AND NO RESPONSIBILITY IS ASSUMED FOR ANY     *\n//*   MODIFICATION DIRECTLY OR INDIRECTLY CAUSED BY THE USE OF      *\n//*   THIS SOFTWARE.  IT IS THE USER'S RESPONSIBILITY TO EVALUATE   *\n//*   THE USEFULNESS OF THE MATERIAL SUPPLIED.                      *\n//*                                                                 *\n//*   We do not guarantee to keep any material provided up to       *\n//*   date, nor do we guarantee to provide any corrections or       *\n//*   extensions described by anyone, or corrections or             *\n//*   extensions made in the future.                                *\n//*                                                                 *\n//*   NO WARRANTY, EXPRESSED OR IMPLIED, IS PROVIDED BY ANY OR      *\n//*   ALL OF THE PERSONS AND/OR INSTALLATIONS EDITING,              *\n//*   DUPLICATING, OR OTHERWISE HANDLING THIS TAPE, AS WELL AS      *\n//*   BY ALL AUTHORS AND CONTRIBUTORS OF MATERIAL TO THIS TAPE.     *\n//*   PERSONS AND/OR INSTALLATIONS USING ANY OF THE PROGRAMS OR     *\n//*   MATERIALS ON THIS TAPE, DO SO ENTIRELY AT THEIR OWN RISK.     *\n//*                                                                 *\n//*******************************************************************\n//*                                                                 *\n//*   THE EDITOR AND/OR ANY OTHER PERSONS, INSTITUTIONS,            *\n//*   CORPORATIONS, OR ANY OTHER ENTITY HANDLING THIS TAPE, AS      *\n//*   WELL AS ANY AUTHORS OR CONTRIBUTORS OF MATERIAL TO THIS       *\n//*   TAPE, DO NOT ASSUME ANY RESPONSIBILITY, EXPRESS, IMPLIED,     *\n//*   OR TO BE CONSTRUED IN ANY WAY, TO UPDATE THIS TAPE AT         *\n//*   ALL.  ANY STATEMENTS TO THE CONTRARY, ANYWHERE ON THIS        *\n//*   TAPE, ARE HEREBY OVERRIDDEN BY THIS STATEMENT.                *\n//*                                                                 *\n//*   Specifically, but not limited thereto, no responsibility      *\n//*   is assumed, in any way, by anyone handling this tape, or      *\n//*   by any author or contributor of material to this tape, to     *\n//*   ensure YEAR 2000 compliance of any materials on this          *\n//*   tape, at all.                                                 *\n//*                                                                 *\n//*   THESE STATEMENTS, IN THEIR GENERAL APPLICATION, AND NOT       *\n//*   LIMITED TO YEAR 2000 CONSIDERATIONS, APPLY TO ALL             *\n//*   MATERIALS CONTAINED ON THIS TAPE, WITHOUT EXCEPTION.          *\n//*                                                                 *\n//*   These statements OVERRIDE ANY STATEMENT OF DOCUMENTATION,     *\n//*   anywhere else on this tape, that any software or materials    *\n//*   contained on this tape are YEAR 2000 compliant or functional. *\n//*                                                                 *\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$SUBCOMM": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x19\\x01\\x17\\x15\\x0f\\x01\\x17\\x17?\\x11\\x02\\x00\\x14\\x00\\x13\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2017-05-30T00:00:00", "modifydate": "2017-06-22T11:02:19", "lines": 20, "newlines": 19, "modlines": 0, "user": "SBGOLOB"}, "text": "               SUBCOMMANDS OF THE CNCLPG PROGRAM      v 1.2.10E\n\n ----  -  ------------------------------------------------------------\n'CSCB' -  DISPLAY ALL address spaces and ASIDs satisfying the parms\n'DISP' -  DISPLAY ALL address spaces and ASIDs satisfying the parms\n ----  -  ------------------------------------------------------------\n'CNCL' -  Make the address space cancelable\n'NCNC' -  Make the address space non-cancelable\n'SWAP' -  Make the address space swappable.\n'FSWP' -  Forces the address space swappable when DONTSWAP count > 1\n'NSWP' -  Make the address space non-swappable (add 1 to DONTSWAP cnt)\n'TSWP' -  Do a TRANSWAP on the address space to make it non-swappable\n'FORC' -  Allow the address space to be FORCED without a CANCEL first\n'NFRC' -  To FORCE the address space, you must do a CANCEL first\n'BURN' -  Do a CALLRTM TYPE=MEMTERM to get rid of an address space\n'KILL' -  Do a CALLRTM TYPE=MEMTERM-first turn off non-memtermable bits\n'NMEM' -  Turn on the main non-memtermable bit, make non-cancelable too\n'MEMT' -  Turn off the main non-memtermable bit for the address space\n'COUNT -  Display the DONTSWAP count of an address space\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$WHACKIT": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x01\\x17\\x13O\\x01\\x185\\x1f\\x13!\\x00U\\x00@\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2017-05-14T00:00:00", "modifydate": "2018-12-17T13:21:00", "lines": 85, "newlines": 64, "modlines": 0, "user": "SBGOLOB"}, "text": "         GETTING RID OF AN ADDRESS SPACE (or WHACKING A JOB)\n\n\n               Use this completely at your own risk.\n\n                  ALL CBT TAPE DISCLAIMERS APPLY..\n\n         *-------------------------------------------------*\n         *                                                 *\n         *   THIS ONLY APPLIES TO CNCLPG RELEASE 1.2.8     *\n         *                  AND HIGHER.                    *\n         * USE RELEASE 1.2.0 FOR ALL OTHER PURPOSES...!!!  *\n         *                                                 *\n         *-------------------------------------------------*\n\n     In my career as a system doctor, I've had trouble, more than\nonce, in getting rid of an address space that was malfunctioning, and\nstarting over.  Sometimes the address space was marked \"NON-CANCELABLE\"\nand I've even seen address spaces marked \"NON-FORCIBLE\".\n\n     Mentioning this problem to fellow sysprogs, I've gotten answers\nlike: \"You've got to learn how to use FORCE correctly.\"  Or they'd say\nsome similar nonsense.  Sometimes they're right.  But a bunch of times,\nthere are a couple of bits in the way.  And if you can't get past them,\nyou can't get rid of the job or other address space.  I've seen this\nsituation force an IPL in the middle of the day.  (NO GOOD....!!!)\n\n***********************************************************************\n\n     NOTE:  In order to use CNCLPG you have to have PSCB OPER authority.\nIn order to use the BURN or KILL options of CNCLPG, you need to have\nPSCB ACCOUNT authority in addition to PSCB OPER authority.\n\n***********************************************************************\n\n     So what do you do?  There are two free APF-authorized TSO commands\nwhich can help you.\n\n     One is called CSCF, and it is on CBT File 954.  The other is\ncalled CNCLPG, and it is on CBT File 826.  CSCF can get rid of the\nmain offending bits.  CNCLPG (with the KILL option) can do that, and\nthen whack the job or address space.  Now, CNCLPG has been extended\n(in version 1.2.10E) to perform equivalent functionality to most of\nwhat CSCF can do, except for the timeout stuff.\n\n     Both of these commands do multiple functions.  But to get rid of\na job or system task, you first need to change its status to CANCELABLE\nor FORCIBLE, and then you need to CANCEL it or FORCE it.  Sometimes,\nyou can just \"whack it\".  To do so, use the KILL subcommand of the\nCNCLPG command.\n\n     The KILL subcommand of CNCLPG will do a CALLRTM TYPE=MEMTERM\noperation on the address space, but before it does so, it turns off the\nASCBNOMT and ASCBNOMD bits in the ASCB.  ASCBNOMT is what makes a job\n\"NON-FORCIBLE\", and ASCBNOMD off, makes it FORCIBLE even if the error\nwas a DAT error.  THEN the KILL subcommand does the CALLRTM MEMTERM.\nIn that way, KILL makes sure that nothing will get in the way of the\n\"FORCE\" operation, and the address space will be duly \"whacked\".  Then\nyou can start it over.\n\n     ONE NOTE OF CAUTION:  YOU HAVE TO WHACK OR ALTER THE CORRECT\nADDRESS SPACE.  IF YOU DON'T, YOU CAN CAUSE HAVOC.\n\n     WHY?  Both CNCLPG and CSCF have to run the CSCB chain.  This is\na chain representing all the active jobs, system tasks, and TSU's in\nthe system.  Sometimes there are many address spaces with the SAME\nname.  And there can be more than one address space with the SAME\nASID (I bet you didn't know that).  So in order to make sure you are\naltering the correct address space, you have to specify BOTH the ASID\nand the JOBNAME when you run CNCLPG.\n\n     How do you get that information in the first place?\n\n     Run CNCLPG with the DISPLAY command.\n\n     The DISPLAY command will show all matches and all occurrences.\n\n     So if you run:  CNCLPG jobname DISP, you will see all the CSCB\nentries matching your jobname, and you can specify the one with the\ncorrect ASID by using the ASID(hex) parameter together with the\njobname parameter.\n\n     Do this first, and you won't be sorry later.  Do DISP several\ntimes, UNTIL YOU SEE ONLY ONE ENTRY--the entry that you want to alter.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#CNCNPG#": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00)\\x01\\x17\\x16\\x9f\\x01\\x17\\x17?\\x15\\x18\\x01N\\x00\\xfb\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2017-06-18T00:00:00", "modifydate": "2017-06-22T15:18:29", "lines": 334, "newlines": 251, "modlines": 0, "user": "SBGOLOB"}, "text": "              A HISTORY OF THE CNCLPG TSO COMMAND\n              - ------- -- --- ------ --- -------\n\nThis piece is worth reading, because it explains what you can do with\nthe CNCLPG TSO command, which is quite complicated.  An effort was\nmade to show how the development of each feature of CNCLPG was logical\nand how one function's development followed from the previous things\nthat were there.  Then, everything makes sense.\n\n                      ** - - - - - - **\n\nPART ONE.  INTRODUCTION:\n\n    The CNCLPG command was originally written to make a non-cancelable\naddress space cancelable.  Of course, you had to go the other way too,\nand make a cancelable address space non-cancelable.\n\n    To do this, I found that this property is keyed off the CHACT bits\nin the CSCB chain of control blocks, mapped by macro IEECHAIN.  I wrote\nmy own parser, and used the parameters of CNCL and NCNC to make an\naddress space \"cancelable\" or \"non-cancelable\".\n\n    The CSCB chain roughly represents all active address spaces.\n\n    The program expanded from there.\n\n    There are other CHACT bits as well.  One of them controlled if you\nneed to do a CANCEL command before you did a FORCE command.  So I made\na FORC and NFRC action, to flip that bit as well.  I later found out\nthat to really make an address space \"non-forcible\", you have to set a\nbit in the ASCB called ASCBNOMT.  This is a separate matter indeed, and\nthe command to do so was named NMEM or \"non-memtermable\".  Its opposite\nwas named MEMT, or \"memtermable\".  But I am going ahead of myself.  I\nam not there yet.  (See Part Three for that history.)\n\n    There is a bit in the CHACT byte in the CSCB that seems to say an\naddress space is swappable or non-swappable.  That bit may be a sign\nthat the address space actually IS swappable or non-swappable, but it\ndoes not MAKE an address swappable or non-swappable.  To do that, you\nhave to issue a SYSEVENT macro in Key 0 state.  (I use the CHACT\n\"swappable\" bit for reference only.  I don't know if it actually does\nanything on the system.)\n\n    A SYSEVENT macro can only be issued in the address space which it\naffects.  Therefore, if that address space is not yours, you have to\nissue an SRB to run it in the appropriate address space, and then get\nthe results back.  I wasn't up to writing such code at that point, so\nI gave the job to my friend Joe Reichman, who did it very well.\n\n    So now, the CNCLPG command could make an address space cancelable,\nnon-cancelable, and it can require a CANCEL before a FORCE or not,\nand it could make an address swappable or nonswappable.\n\n    It was a reasonably good accomplishment so far.\n\n    End Part One.  There is more.\n\n                      ** - - - - - - **\n\nPART TWO.  IMPORTANT USE CONSIDERATIONS.\n\n    The CSCB chain of control blocks roughly represents all active\naddress spaces.  But there is a complication.  You can have several\nCSCB control blocks with the same jobname.  And you can have several\ndifferent CSCB entries that have the same ASID.\n\n    For the CNCLPG program, ALL ASID NUMBERS are in hexadecimal, NOT\nin decimal form.\n\n    To display the entire CSCB chain, I required a dash ( - ) instead\nof the jobname, in the CNCLPG call.  To just display a limited number\nof CSCB entries, I introduced the CSCB or DISPlay keyword.  So if you\nwant to show the CSCB entry (entries) for a jobname, you code:\n\nCNCLPG jobname DISP\n\nOr if you want to display all CSCB entries corresponding to a given\nASID number, you code:\n\nCNCLPG ASID(hhhh) DISP\n\n    Simple enough?  OK.  But there is more to know.\n\n    There may be more than one CSCB entry for a given jobname, and\nthere may be more than one CSCB entry for a given ASID.  If a job\nis running under an initiator, they both have the same ASID, but\nthey have different CSCB entries with different properties.\n\n    So that brings us to the next topic.\n\n    In CNCLPG there is a distinction between DISPLAY type keywords\nand ACTION type keywords.  Since the DISPLAY type keywords do not\nactually affect the address space, CNCLPG shows ALL MATCHES that fit\nthe operands entered.  With the DISPLAY command, you want to find out\nALL CSCB ENTRIES THAT FIT.\n\n    Not so with ACTION-type commands such as SWAP or NSWP.  With\nthose commands, you just want to affect ONE address space.  It is the\nFIRST address space hit with a match, when you are running the CSCB\nchain.  YOU MUST MAKE SURE THAT YOUR CNCLPG command DOES NOT AFFECT\nTHE WRONG ADDRESS SPACE.....!!!!\n\n    Therefore, in CNCLPG you can use BOTH the jobname and the\nASID(hhhh) parameters together, to narrow down the address space that\nyou want to affect.  An example would be:\n\nCNCLPG JES2 ASID(20) DISP\n\n    If you displayed just jobname JES2, the CSCB search would come up\nwith JES2, JES2AUX, and JES2MON.  Only the first of these would be\naffected by an ACTION-type command.  To narrow down the address space\nto the correct one you want to change, you should use BOTH parameters\nof jobname AND ASID(hhhh) combined.  Only when you are absolutely\nsure that you are affecting the correct address space, ONLY THEN\nSHOULD YOU ATTEMPT TO CHANGE IT.\n\n    End Part Two.\n\n                      ** - - - - - - **\n\nPART THREE - MORE FUNCTIONS\n\n    I asked my friend Joe Reichman to write a new BURN TSO command, to\n\"memterm\" an address space.  This is done by issuing a CALLRTM macro\nwith TYPE=MEMTERM.  This is basically what happens when you FORCE an\naddress space.\n\n    After Joe wrote his independent BURN command (which we will not\ndiscuss here), I incorporated his working code into CNCLPG, and thus\nwas born the CNCLPG BURN command.\n\n    It sounds simple enough.\n\n    But then I was talking to another friend (name withheld) who told\nme that he once wrote a similar program to CNCLPG.  He sent me his\ncode, and it was different.  His code flipped a different bit, not in\nthe CSCB, but in the ASCB of the address space.  This bit was called\nASCBNOMT, and it makes an address space truly NON-FORCIBLE.  In other\nwords, if you try and FORCE that address space with an operator command,\na message comes back:  NON-FORCIBLE.  This has to be combined with the\nCANCELABLE bit from the CSCB being OFF (non-cancelable) as well.  And\nthen the job becomes truly non-cancelable and non-forcible.\n\n    When you try and issue a BURN command with CNCLPG, and the ASCBNOMT\nbit is on in the ASCB, then the BURN does not work.  That is how the\nKILL command was born.\n\n    I figured, if you REALLY want to get rid of an address space, but\nthe ASCBNOMT (and maybe the ASCBNOMD) bit (also) is on, then a FORCE\nwon't work.  So if you really want to blast that address space, then\nturn those bits off in the ASCB first.  Then you can whack the address\nspace, and nothing should be in the way.  This gave birth to the KILL\ncommand, which first turns off the ASCBNOMT and ASCBNOMD bits, and\nthen issues the CALLRTM TYPE=MEMTERM.\n\n    But what if you don't really want to get rid of the address space,\nbut you just want to flip the bits.  So we have new commands:  NMEM\n(make non-memtermable) and MEMT (make memtermable).\n\n    There is one extra thing that is needed to know here.  NMEM does\ntwo things:  It flips on the ASCBNOMT bit to make the address\nNON-FORCIBLE.  But it also goes to the CSCB and makes the address\nspace NON-CANCELABLE as well.  NON-FORCIBLE without NON-CANCELABLE\nis not really effective.  To undo NMEM, issuing MEMT will leave the\naddress space non-cancelable.  So you have to issue a CNCL afterwards\nto undo that, and make the address space cancelable.\n\n    End Part Three.\n\n                      ** - - - - - - **\n\nPART FOUR - TRANSWAP, DONTSWAP, AND \"DONTSWAP COUNTS\"\n\n    There are two ways to make an address space nonswappable.  They\nare SYSEVENT DONTSWAP and SYSEVENT TRANSWAP.  The final result of both\noperations is that the address space is nonswappable.  But there is a\ndifference, which is why there are two separate operations.\n\n    SYSEVENT DONTSWAP freezes the pages of the address space where they\nare.  SYSEVENT TRANSWAP wants to do a neater job.  It first swaps the\naddress space out.  Then afterwards, it swaps the address space in,\nNEATLY, and tries to make use of \"preferred storage\" frames rather than\n\"reconfigurable storage\" frames.  This leads to a more stable solution,\njust in case some of the reconfigurable storage needs to be taken away\nfrom that processor later.  If there are fixed pages there, the pages\ncan't be removed from that processor.\n\n    In either case, the address space originally has to be swappable.\nWhat if it isn't?  If you try and DONTSWAP or TRANSWAP an address space\nthat is already non-swappable, then essentially nothing is done, except\nthat a \"DONTSWAP count\" is incremented in the OUCB field OUCBNDS, which\nis a halfword.  The reason for this is that any address space can make\nanother address space non-swappable, because it needs that address space\nto be nonswappable.  Every subsequent SYSEVENT OKSWAP which occurs\nagainst that address space, decrements the \"DONTSWAP count\" by one,\nuntil it is X'0001', after which the next OKSWAP against the address\nspace will make it swappable.  This is a safeguard against making an\naddress swappable when it shouldn't be.\n\n    So I needed a way to display the \"DONTSWAP count\" in CNCLPG\nmessages.\n\n    First, I put them into the NSWP and TSWP commands.  These are\ncommands in CNCLPG to make an address space non-swappable or to TRANSWAP\nit.  NSWP and TSWP display the \"DONTSWAP count\" in their display\nresults.  Then I needed to implement a COUNT command, which looks at an\naddress space and displays its \"DONTSWAP count\", even if it is\nswappable.  Even though the COUNT command is for display only, in CNCLPG\nit is considered an \"action\" command, because it has to issue an SRB to\nobtain the results for any address space (when it is not yours).\n\n    So if you issue:  CNCLPG jobname ASID(hhhh) COUNT, you get the\n\"DONTSWAP count\" as well as some CSCB information for that address\nspace:\n\n    An extreme example:  CNCLPG *MASTER* COUNT will yield:\n\nCNCLPG 1.2.10C - Alter Characteristics of a Running Address Space\n------ ------- - ----- --------------- -- - ------- ------- -----\nSearch Jobname:  *MASTER*\n----------------------------\nFunction COUNT was called for.\nJob  ID :  *MASTER*\nProc ID :  *MASTER*\nASID    :  0001\n  Outstanding DONTSWAP requests:   0001\n----------------------------\nFinal Job Status Report.\nCurrent  CHACT Flags:  00\nJob Status:  Non-Cancelable\nJob Status:  Cancel + Force\nJob Status:  Non-Swappable\nJob Status:  Non-Memtermable\nReturn code is 0\n\n    And you can do this for any address space.\n\n    End Part Four.\n\n                      ** - - - - - - **\n\nPART FIVE:  FSWP (Force an Address Space to be Swappable)\n\n    To complete the picture, you may have an address space which has\nproblems.  It has a high \"DONTSWAP count\", and for some good reason,\nyou need to make it swappable right away, without having to issue\nmultiple SWAP commands against it.  For this emergency purpose I created\nthe FSWP command, to force and address space to be swappable.\n\n    FSWP works by setting the \"DONTSWAP count\" to X'0001' no matter\nwhat it was before.  Then it issues a SYSEVENT OKSWAP and makes the\naddress space swappable.  I understand that you'd really need an\nemergency to use this effectively.  However it is there if needed.\n\n    End Part Five.\n\n                      ** - - - - - - **\n\nPART SIX:  SYSEVENT RETURN CODES\n\n    When you issue a SYSEVENT OKSWAP, DONTSWAP, or TRANSWAP, a return\ncode is issued in Register 1, in byte 3 (the low order byte).  The only\nreturn code of interest to us, is a possible return code of 4, from\nTRANSWAP.  That occurs when you try and TRANSWAP an already nonswappable\naddress space.  The \"DONTSWAP count\" is incremented, nothing further is\ndone, and the SYSEVENT Return Code in that case is 4.\n\n    If the TSWP was REALLY done (to a swappable address space) then\nthe SYSEVENT Return Code is 0.\n\n    To indicate what has happened (after a TSWP command to an already\nnonswappable address space), a message is issued, showing a SYSEVENT\nReturn Code of 4.  When the TSWP was actually done, then SYSEVENT\nTRANSWAP returns a code of 0, and this is also reported by CNCLPG.\n\n    CNCLPG reports the SYSEVENT Return Code after the NSWP and TSWP\ncommands have been issued.\n\n    End Part Six.\n\n                      ** - - - - - - **\n\nPART SEVEN:  IS IT REALLY NON-SWAPPABLE?\n\n    \"Before\" and \"after\" images showing what was done:\n\n    I try and show \"before\" and \"after\" images of the address space\nwhich is being changed, together with enough identifying information\nso you can figure out exactly which address space was dealt with, and\nexactly what was done to the address space by the CNCLPG program.\n\n    However, there was still a problem, especially with the swappable\nand non-swappable messages.  You could figure the situation out from\nthe rest of the messages, but it really wasn't clearly stated in the\nmessages themselves.  Consider the following:\n\nJob IBMUSER  for ASID 0051 made non-swappable.\n\n    This message would have been sent (version 1.2.10D and below) even\nif the address space was already non-swappable, and we tried to make\nit non-swappable again (raising the DONTSWAP count).  However, I\nimplemented the following messages to make things clearer to the user:\n\nJob IBMUSER  for ASID 0051 already non-swappable.\n\nand\n\nJob IBMUSER  for ASID 0051 was already swappable.\n\nif you tried to make a non-swappable address space non-swappable again,\nor if you tried to make a swappable address space swappable again.\n\n    In order to implement this, I had to create \"before\" and \"after\"\nimages of swappability or non-swappability.  And in order to do that,\nI had to find out where the definitive indicator (in the system) of\nwhat swappability and non-swappability was.\n\n    It is in the OUCB (macro IRAOUCB) + X'11' which is OUCBSFL (flags)\nand the requisite flag showing \"address space non-swappable\" is X'80'\nor OUCBNSW.  I had to put in code to test this bit in all requisite\nplaces, both in our own address space, and in other address spaces\nwhere you needed to run an SRB.  The SRB code was modified to extract\nthe requisite information.  And the proper comparisons between \"before\"\nand \"after\" were made, to distinguish all the cases.\n\n    End Part Seven.\n\n\nCONCLUSION:\n\n    So I hope that this will better explain what CNCLPG can do.  Use it\nwisely.  Don't use it any other way....!!!!\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE826": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x004\\x01 \\x01\\x9f\\x01 \\x01\\x9f\\x14R\\x00\\xaa\\x00\\xaa\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2020-01-19T00:00:00", "modifydate": "2020-01-19T14:52:34", "lines": 170, "newlines": 170, "modlines": 0, "user": "CBT-499"}, "text": "//***FILE 826 is from Sam Golob and contains a FREE TSO command to  *   FILE 826\n//*           alter the status of an address space, by making it    *   FILE 826\n//*           Cancelable or Non-Cancelable, Non-Memtermable (can't  *   FILE 826\n//*           be FORCEd), Memtermable, Swappable, Non-Swappable.    *   FILE 826\n//*           (Also if FORCE needs a CANCEL).  Joe Reichman put     *   FILE 826\n//*           in Swappable and Non-Swappable for any address space. *   FILE 826\n//*           This command is one of the very rare FREE commands    *   FILE 826\n//*           (APF-authorized) which can make any address space     *   FILE 826\n//*           non-swappable or swappable.  Thanks, Joe!             *   FILE 826\n//*                                                                 *   FILE 826\n//*           The current version of CNCLPG is 1.2.10F .            *   FILE 826\n//*           Some previous versions are also included here.        *   FILE 826\n//*                                                                 *   FILE 826\n//*           The current version can TRANSWAP any address space,   *   FILE 826\n//*           (function TSWP) and can display the count of noswap   *   FILE 826\n//*           requests (function COUNT--and others).  You have to   *   FILE 826\n//*           be very careful to use TRANSWAP only when necessary.  *   FILE 826\n//*                                                                 *   FILE 826\n//*      ->   Additionally, there is now included a program called  *   FILE 826\n//*      ->   WAITT which can alter the job step wait time of your  *   FILE 826\n//*      ->   TSO session, or turn on the exemption bit to allow    *   FILE 826\n//*      ->   disregard of the wait time altogether.  (Can turn     *   FILE 826\n//*      ->   it off, too.)  See members WAITT*                     *   FILE 826\n//*                                                                 *   FILE 826\n//*      ->   Addition of WAITT to this file, gives you the         *   FILE 826\n//*      ->   enhanced ability to control your session's            *   FILE 826\n//*      ->   wait time limit, which CNCLPG doesn't currently do.   *   FILE 826\n//*                                                                 *   FILE 826\n//*  <<****>> Please read the #CNCLPG# member of this pds before    *   FILE 826\n//*  <<****>> using the CNCLPG command.  It is an \"easy read\".      *   FILE 826\n//*                                                                 *   FILE 826\n//*  <<****>> Also please read member $DESCR, which is important,   *   FILE 826\n//*  <<****>> if you want to use this command SAFELY....!!!         *   FILE 826\n//*                                                                 *   FILE 826\n//*           Non-Forcible here, is:  *NOT* \"NON-FORCIBLE\" in the   *   FILE 826\n//*           absolute sense of \"NON-MEMTERMABLE\".  Rather, it is   *   FILE 826\n//*           the bit in the CSCB which requires that you have to   *   FILE 826\n//*           do a CANCEL before you do a FORCE.                    *   FILE 826\n//*                                                                 *   FILE 826\n//*           If you want to make an address space really           *   FILE 826\n//*           \"NON-MEMTERMABLE\", then use action NMEM in CNCLPG.    *   FILE 826\n//*           \"MEMTERMABLE\" (or really Forcible) is action MEMT.    *   FILE 826\n//*                                                                 *   FILE 826\n//*           To display how many \"DONTSWAP\" requests exist         *   FILE 826\n//*           against an address space, use the function COUNT.     *   FILE 826\n//*                                                                 *   FILE 826\n//*           Sometimes there are multiple DONTSWAP actions         *   FILE 826\n//*           against an address space.  To turn them all off,      *   FILE 826\n//*           and make the address space SWAPPABLE, use FSWP        *   FILE 826\n//*           (or Forced SWAP).  Otherwise run the SWAP action      *   FILE 826\n//*           multiple times (FSWP eliminates that problem).        *   FILE 826\n//*           But use FSWP very carefully, because there might      *   FILE 826\n//*           be multiple reasons why the address space is          *   FILE 826\n//*           currently nonswappable.  This is only an emergency    *   FILE 826\n//*           tool.                                                 *   FILE 826\n//*                                                                 *   FILE 826\n//*           To use the CNCLPG TSO command, you first find the     *   FILE 826\n//*           correct address space, and then you do an operation   *   FILE 826\n//*           on it.  (See the use of the DISP action, described    *   FILE 826\n//*           below.  THIS IS VERY IMPORTANT....!!!)                *   FILE 826\n//*                                                                 *   FILE 826\n//*     Syntax:     TSO Command:  APF-authorized.  (v. 1.2.10F)     *   FILE 826\n//*                                                                 *   FILE 826\n//*  CNCLPG |jobid \u00ddASID(hhhh)\u00a8 |CNCL|NCNC (cancelable,             *   FILE 826\n//*         |                   |           non-cancelable)         *   FILE 826\n//*         |ASID(hhhh)         |FORC    (force w/o cancel)         *   FILE 826\n//*         |                   |NFRC    (force needs cancel first) *   FILE 826\n//*         |                   |NSWP|SWAP (non-swap, swappable)    *   FILE 826\n//*         |                   |TSWP (transwap)                    *   FILE 826\n//*         |                   |FSWP (force swappable immediately) *   FILE 826\n//*         |                   |BURN (memterm the address space)   *   FILE 826\n//*         |                   |KILL (do memterm after turning     *   FILE 826\n//*         |                   |      off non-memtermable bits)    *   FILE 826\n//*         |                   |NMEM|MEMT  (turn on/off            *   FILE 826\n//*         |                   |        non-memtermable bits)      *   FILE 826\n//*         |                   |CSCB or DISP (display CSCB blks)   *   FILE 826\n//*         |                   |COUNT  (display DONTSWAP count)    *   FILE 826\n//*         |-  (displays the entire CSCB chain)                    *   FILE 826\n//*         |?  (displays help)                                     *   FILE 826\n//*                                                                 *   FILE 826\n//*           !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   *   FILE 826\n//*                                                                 *   FILE 826\n//*           The following also applies to higher releases of      *   FILE 826\n//*           the CNCLPG program:  (current V1R210E)                *   FILE 826\n//*                                                                 *   FILE 826\n//*           V1R2M8 of the CNCLPG program also includes a BURN     *   FILE 826\n//*           parameter to remove the address space if necessary.   *   FILE 826\n//*           Also NMEM (make Non-MEMTERMABLE) and MEMT (make       *   FILE 826\n//*           Memtermable) added in V1R2M8.                         *   FILE 826\n//*                                                                 *   FILE 826\n//*           As coded, you need PSCB ACCOUNT privilege to run      *   FILE 826\n//*           the BURN, KILL, NMEM actions.  You need PSCB OPER     *   FILE 826\n//*           privilege to run the program.  You may add code       *   FILE 826\n//*           to secure this program better, to your needs.         *   FILE 826\n//*                                                                 *   FILE 826\n//*              THIS IS FOR EMERGENCY USE ONLY. IF THE BURN        *   FILE 826\n//*              FACILITY IS NOT WANTED, INSTALL CNCLPG20.          *   FILE 826\n//*                                                                 *   FILE 826\n//*    NOTE:  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   *   FILE 826\n//*    -----                                                        *   FILE 826\n//*    >>>>>  If you think BURN or KILL are too dangerous, then     *   FILE 826\n//*    >>>>>  you can install CNCLPG20 instead, which is a          *   FILE 826\n//*    >>>>>  previous version that cannot do BURN or KILL.         *   FILE 826\n//*                                                                 *   FILE 826\n//*           !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   *   FILE 826\n//*                                                                 *   FILE 826\n//*           V1R2M8 of CNCLPG includes the KILL option, which      *   FILE 826\n//*           you can think of as \"BURN plus\".  KILL turns off      *   FILE 826\n//*           the no-MEMTERM bits in the ASID before issuing a      *   FILE 826\n//*           CALLRTM MEMTERM.  Mitigating factor is that you       *   FILE 826\n//*           need PSCB OPER authority to run this version of       *   FILE 826\n//*           CNCLPG.  And to do BURN or KILL, you ALSO need        *   FILE 826\n//*           PSCB ACCOUNT authority, as well as OPER authority.    *   FILE 826\n//*                                                                 *   FILE 826\n//*           If you install this command, you are welcome to add   *   FILE 826\n//*           additional authorization checks to it, obviously.     *   FILE 826\n//*                                                                 *   FILE 826\n//*           !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   *   FILE 826\n//*                                                                 *   FILE 826\n//*           You can TRANSWAP a swappable address space, using     *   FILE 826\n//*           the TSWP function of CNCLPG.                          *   FILE 826\n//*                                                                 *   FILE 826\n//*           This command also contains fairly detailed messaging  *   FILE 826\n//*           and displays, as well as in-context help:  CNCLPG ?   *   FILE 826\n//*                                                                 *   FILE 826\n//*           You can run and display the entire CSCB chain by      *   FILE 826\n//*           typing a dash ( - ) instead of the jobname.           *   FILE 826\n//*                                                                 *   FILE 826\n//*           You can display ALL eligible CSCB entries that        *   FILE 826\n//*           satisfy a jobname equal, or and ASID(hhhh) equal,     *   FILE 826\n//*           by using the DISP or CSCB keyword parameter after     *   FILE 826\n//*           specifying either jobname, ASID(hhhh), or both.       *   FILE 826\n//*                                                                 *   FILE 826\n//*           If you issue a command to CHANGE an address space:    *   FILE 826\n//*           CNCL, NCNC, FORC, NFRC, NSWP or SWAP - then the       *   FILE 826\n//*           FIRST CSCB entry encountered, is the one changed.     *   FILE 826\n//*           ----- ---- ----- -----------         --- -------      *   FILE 826\n//*                                                                 *   FILE 826\n//*           Therefore it pays to issue a DISP or CSCB (display)   *   FILE 826\n//*           command first, to find ALL eligible entries for the   *   FILE 826\n//*           address space in the CSCB chain.  Then issue the      *   FILE 826\n//*           \"action\" command to change the exact address space    *   FILE 826\n//*           that you want to change, specifying BOTH jobname      *   FILE 826\n//*           and ASID(hhhh).                                       *   FILE 826\n//*                                                                 *   FILE 826\n//*           Joe Reichman put in the SWAP and NSWP service for     *   FILE 826\n//*           different target address spaces than the one that     *   FILE 826\n//*           issued the CNCLPG command.  He did all the cross      *   FILE 826\n//*           memory stuff (scheduling the SRB) that was needed     *   FILE 826\n//*           to make a different address space non-swappable       *   FILE 826\n//*           or swappable.                                         *   FILE 826\n//*                                                                 *   FILE 826\n//*           CNCLPG is an APF-authorized TSO command.  To learn    *   FILE 826\n//*           more about \"personal\" APF-authorization of TSO        *   FILE 826\n//*           commands, see CBT Files 185 and 797.                  *   FILE 826\n//*                                                                 *   FILE 826\n//*           See pds member $DESCR for more details on how this    *   FILE 826\n//*           command works.  It is very important to read this     *   FILE 826\n//*           member, and you really shouldn't use the CNCLPG       *   FILE 826\n//*           command without doing so.                             *   FILE 826\n//*                                                                 *   FILE 826\n//*           For more details about the history and structure of   *   FILE 826\n//*           the CNCLPG program, please read member #CNCNPG#.      *   FILE 826\n//*                                                                 *   FILE 826\n//*           This is a FREE command, with functionality that       *   FILE 826\n//*           is usually obtainable only in expensive vendor        *   FILE 826\n//*           packages.  And it's here for you to enjoy.            *   FILE 826\n//*                                                                 *   FILE 826\n//*       email:  sbgolob@cbttape.org                               *   FILE 826\n//*                                                                 *   FILE 826\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CNCLPG": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01)\\x00I\\x01\\x17\\x15\\x8f\\x01 \\x01/\\x11\\x03\\x0bE\\tD\\x00\\x00\\xe5\\xf1\\xd9\\xf2\\xf1\\xf0\\xc6@@@'", "ispf": {"version": "01.41", "flags": 0, "createdate": "2017-06-07T00:00:00", "modifydate": "2020-01-12T11:03:49", "lines": 2885, "newlines": 2372, "modlines": 0, "user": "V1R210F"}, "text": "CNCLPG   TITLE 'Alter characteristics of a running address space. '\n*  -----------------------------------------------------------------  *\n*                                                                     *\n*    Function:   To make an address space Cancelable or               *\n*                Non-Cancelable, Forcible or Non-Forcible,            *\n*                Swappable or Non-Swappable.  Or BURN the             *\n*                address space (version 1.2.5).  KILL the             *\n*                address space is same as BURN, but first             *\n*                the non-MEMTERM bits in the ASCB are                 *\n*                turned off (version 1.2.6).                          *\n*                                                                     *\n*                Other properties of an address space can be          *\n*                altered, as well.  See below.                        *\n*                                                                     *\n*                If the address space is non-MEMTERM-able,            *\n*                and you try to BURN it, an error message             *\n*                is issued, and nothing occurs.  But if you           *\n*                try and KILL it, the non-MEMTERM bits are            *\n*                turned off, and the address space is whacked.        *\n*                The message will tell you so.                        *\n*                                                                     *\n*    Authority:  You need PSCB OPER authority to run this             *\n*                command.  To do BURN, KILL, NMEM, and MEMT           *\n*                functions, you ALSO need PSCB ACCOUNT authority.     *\n*                Any function controlled by the KILLFLAG, needs       *\n*                PSCB ACCOUNT authority.                              *\n*                                                                     *\n*  -----------------------------------------------------------------  *\n*                                                                     *\n*    Notes:                                                           *\n*                                                                     *\n*           CANCELABLE, NON-CANCELABLE, FORCIBLE, NON-FORCIBLE:       *\n*                                                                     *\n*    CSCB        Cancelable, Non-cancelable, Forcible, Non-forcible   *\n*    chain       are determined by bit settings in the address        *\n*                space's CSCB, which is part of the CSCB chain.       *\n*                                                                     *\n*    Jobname     Each active address space has a CSCB in the chain.   *\n*    and/or      You get to a particular address space by running     *\n*    ASID        the entire CSCB chain (mapped by the IEECHAIN        *\n*    match       macro) looking for a match on jobname and/or ASID,   *\n*                and preferably on both.                              *\n*                                                                     *\n*    DISPlay     There may be more than one address space for a       *\n*    or          given job name, and more than one CSCB entry         *\n*    \"CSCB\"      for a given ASID.  The CSCB or DISPlay option        *\n*    option      of CNCLPG will run the entire CSCB chain and         *\n*                it will show ALL the matches for the parameters      *\n*                given.  To display the ENTIRE CSCB chain from start  *\n*                to finish, use a dash ( - ) instead of the jobname.  *\n*                                                                     *\n*    Multiple    If only the jobname or the ASID number alone         *\n*    jobs        are used to do an ACTION, then CNCLPG will stop      *\n*    with the    at the FIRST CSCB which matches, when an ACTION is   *\n*    same name   called for (but NOT for a DISPLAY).  That is why     *\n*                it is better to run the DISPlay (or CSCB) function   *\n*                of CNCLPG first, to display all the possible CSCB    *\n*                entries that might match, before changing any        *\n*                particular address space.  There might be more       *\n*                than one address space with the same jobname or      *\n*                ASID, and you want to change only the correct        *\n*                one, NOT the wrong one.  So it is good practice      *\n*                to display first, and then do a change to the        *\n*                exact address space you want to affect, using        *\n*                both the jobname and ASID(hhhh) parameters.          *\n*                                                                     *\n*           SWAPPABLE AND NON-SWAPPABLE:                              *\n*                                                                     *\n*    SWAP and    Setting an address space to be swappable or          *\n*    NSWP need   non-swappable, is accomplished by executing          *\n*    to run a    a SYSEVENT macro.  This has to execute in the        *\n*    SYSEVENT    target address space, and it was done here by        *\n*    macro in    scheduling an SRB to run in the target address       *\n*    the         space, when it is different from the address         *\n*    target      space running the program.  That piece of code       *\n*    address     was written by Joe Reichman.  Thanks, Joe.           *\n*    space       You did the hard part!                               *\n*                                                                     *\n*    TSWP or     When an address space is set by the SYSTEM to be     *\n*    TRANSWAP    non-swappable, it is first swapped out, and then     *\n*    as          a TRANSWAP is done, to put the pages for the         *\n*    compared    address space into preferred storage, rather         *\n*    to NSWP     than reconfigurable storage.  This is when the       *\n*                SYSTEM does it initially.  But when you do it        *\n*                later to the address space, using the NSWP option    *\n*                of CNCLPG, which is really a SYSEVENT DONTSWAP,      *\n*                the address space is made non-swappable with the     *\n*                pages remaining where they were.  This is not the    *\n*                best situation.  What you really might want is a     *\n*                TRANSWAP and not a DONTSWAP.                         *\n*                                                                     *\n*                If your address space was initially swappable,       *\n*                you can accomplish non-swappability the way the      *\n*                system does, by doing a TRANSWAP, using the TSWP     *\n*                function of CNCLPG.                                  *\n*                                                                     *\n*                The TSWP option initially swaps the address space    *\n*                out, and then swaps it in, in an orderly manner,     *\n*                and then makes it non-swappable.  A NSWP command,    *\n*                on the other hand, fixes the pages where they        *\n*                were, in a haphazard manner, whether they were in    *\n*                preferred storage or in reconfigurable storage.      *\n*                Sometimes, you can't do a TRANSWAP, because it       *\n*                would move the pages of the running job in an        *\n*                unpredictable manner.  So then you do an NSWP.       *\n*                                                                     *\n*    FSWP or     Use this very cautiously, to make sure that you      *\n*    Forced      will not disturb a running job that may need its     *\n*    Swappable   existing pages intact, or a V=R job.                 *\n*    as                                                               *\n*    opposed     Every time the system gets a DONTSWAP or TRANSWAP    *\n*    to SWAP     request against an address space, it keeps a         *\n*                count of how many of them there are.  This is        *\n*                because any address space can issue such a           *\n*                request against any other address space.  Of         *\n*                course the issuing address space has to be APF       *\n*                authorized.  Our target address space can only       *\n*                me made SWAPPABLE when the count of DONTSWAP         *\n*                requests against it, goes down to 1.                 *\n*                                                                     *\n*                FSWP forces the count to one, and then makes         *\n*                the address space swappable, no matter how many      *\n*                outstanding DONTSWAP requests, the address space     *\n*                has against it.  FSWP is an emergency measure,       *\n*                and it has been put there, only to deal with         *\n*                extraordinary circumstances.  You should hardly      *\n*                ever use it, OR NEVER USE IT!  But it is there.      *\n*                                                                     *\n*                                                                     *\n*       NON-MEMTERMABLE AND MEMTERMABLE: (THE REAL \"NON-FORCIBLE\")    *\n*                                                                     *\n*    NMEM makes  In the ASCB of an address space there are two        *\n*    a job both  bits, ASCBNOMT and less importantly, ASCBNOMD.       *\n*    NON-FORCI-  ASCBNOMT controls the attribute, when it is on,      *\n*    BLE and     that the address space is NON-MEMTERMABLE or         *\n*    NON-CANCEL- NON-FORCIBLE.  If NON-CANCELABLE is also true,       *\n*    ABLE.       as well as the non-memtermable bit ASCBNOMT,         *\n*                then when you try and cancel the job, it will say,   *\n*    MEMT makes  NON-CANCELABLE, and when you try and FORCE the       *\n*    the job     job, it will say NON-FORCIBLE.  The two bits         *\n*    FORCIBLE,   ASCBNOMT in the ASCB which has to be on, and         *\n*    but leaves  the cancelable bit in the job's CSCB entry,          *\n*    it to be    CNCL in flag CHACT, which has to be off,             *\n*    NON-CANCEL- control this situation.                              *\n*    ABLE.                                                            *\n*                A job should not be left NON-FORCIBLE and            *\n*                CANCELABLE.  That defeats the purpose of             *\n*                NON-FORCIBLE, in that the job can easily             *\n*                then be cancelled, because CANCEL will work.         *\n*                                                                     *\n*                The action NMEM (non-memtermable) sets both          *\n*                then non-forcible bit in the ASCB on, and the        *\n*                cancelable bit in the job's CSCB entry, off.         *\n*                The action MEMT (make memtermable) turns only        *\n*                the ASCBNOMT bit (non-memtermable) off, but          *\n*                leaves the non-cancelable situation in place.        *\n*                If you want to turn off non-cancelable later,        *\n*                then the CNCL action will do this.                   *\n*                                                                     *\n*    -------------------------------------------------------------    *\n*    BURN        BURN -  Kill the designated address space with a     *\n*    (v 1.2.5)   CALLRTM TYPE=MEMTERM (like a FORCE).  Be careful !   *\n*    -------------------------------------------------------------    *\n*    KILL        KILL -  Kill the designated address space with a     *\n*    (v 1.2.6)   CALLRTM TYPE=MEMTERM (like a FORCE).  Be careful !   *\n*                KILL is a \"super BURN\".  Be VERY careful.....!       *\n*                Before doing the MEMTERM, KILL turns off bits        *\n*                in the ASCB (ASCBNOMT and ASCBNOMD), the             *\n*                \"non-FORCIBLE\" bits.  Can whack any address space.   *\n*    (v 1.2.7)   You need PSCB ACCOUNT authority to run BURN or KILL, *\n*                along with OPER authority to run the rest of the     *\n*                program.                                             *\n*    -------------------------------------------------------------    *\n*    NMEM and    NMEM will make the address space NON-FORCIBLE        *\n*    MEMT        and NON-CANCELABLE.  MEMT will make the address      *\n*    (v 1.2.8)   space FORCIBLE, but it will leave the cancelable     *\n*                bit in place, however it was before.                 *\n*                (Since the FORCE operator command actually equates   *\n*                to a CALLRTM TYPE=MEMTERM macro call, making an      *\n*                address space NON-FORCIBLE is also called making     *\n*                it NON-MEMTERMABLE.                                  *\n*    -------------------------------------------------------------    *\n*    TSWP        Instead of initially making an address nonswappable  *\n*    (v 1.2.9)   using a DONTSWAP function in the SYSEVENT macro,     *\n*                there is now an alternative of doing a TRANSWAP      *\n*                function, which operates on a swappable address      *\n*                space, swaps it out, and then swaps it in, trying    *\n*                to use protected storage frames.  This only works    *\n*                if the address space was swappable to begin with.    *\n*                Otherwise, the TSWP seems to work like an NSWP.      *\n*                IBM recommends TSWP instead of NSWP if the address   *\n*                space is to remain non-swappable for a long time.    *\n*                                                                     *\n*                NUMBER OF DONTSWAP REQUESTS - OUCBNDS field of the   *\n*                        OUCB control block (macro IRAOUCB)           *\n*                Each NSWP or TSWP request increments this number     *\n*                by one.  An address space cannot be made swappable   *\n*                until this number is reduced to one, and a           *\n*                SYSEVENT OKSWAP is issued.  If the number is more    *\n*                than one, then each successive SYSEVENT OKSWAP       *\n*                against the address space, decrements this number    *\n*                by one.  NSWP, TSWP, and SWAP requests now display   *\n*                this number.                                         *\n*    -------------------------------------------------------------    *\n*    FSWP        If several users issued DONTSWAP requests against    *\n*    (v 1.2.10)  the same address space, then the OUCBNDS field,      *\n*                which is a halfword number, contains a quantity      *\n*                that is more than X'0001'.  To make that address     *\n*                space swappable, you would have to issue that        *\n*                number of SYSEVENT OKSWAP requests.  Each OKSWAP     *\n*                request reduces the number by one.  FSWP (Forced     *\n*                SWAP) first sets this number to X'0001' and then     *\n*                issues a SYSEVENT OKSWAP.  So you can be sure to     *\n*                make that address swappable right away, with ONE     *\n*                action, and not many.                                *\n*    -------------------------------------------------------------    *\n*    (v 1.2.10A)  This version is a cleanup of all the previous       *\n*                versions.  The messages have (hopefully) been        *\n*                made consistent and accurate.  The HELP has been     *\n*                made clearer, hopefully.  TSWP has been cleaned      *\n*                up to work as safely as possible.                    *\n*    -------------------------------------------------------------    *\n*    (v 1.2.10B)  This version has the COUNT function which does no   *\n*                action besides displaying the DONTSWAP count for     *\n*                that address space.                                  *\n*    -------------------------------------------------------------    *\n*    (v 1.2.10C)  Cleaned up various bugs with COUNT, and also made   *\n*                the displays more consistent.  Changed TITLE of      *\n*                the program, because it does many kinds of major     *\n*                alterations to a running address space.              *\n*    -------------------------------------------------------------    *\n*    (v 1.2.10D)  Cleaned up \"IKJ56500I COMMAND CNCLPG NOT FOUND\"     *\n*                message to accommodate different length command      *\n*                name.  Use ECTPCMD field to extract command name.    *\n*    -------------------------------------------------------------    *\n*    (v 1.2.10E)  Fixed messaging problem when a swappable addrspc    *\n*                was being made swappable again.  Same problem with   *\n*                non-swappable addrspc being made non-swappable.      *\n*                Message has to reflect that condition was not        *\n*                changed, except for possibly the DONTSWAP count.     *\n*    -------------------------------------------------------------    *\n*    (v 1.2.10F)  Report on CHSTS flags for CSCB chain entries,       *\n*                just for informational purposes.  This program       *\n*                is useful for showing things about CSCB entries.     *\n*    -------------------------------------------------------------    *\n*    Syntax:     TSO Command:  APF-authorized.                        *\n*                                                                     *\n*     CNCLPG |jobid \u00ddASID(hhhh)\u00a8 |CNCL|NCNC (cancelable, non-canc)    *\n*            |ASID(hhhh)         |FORC    (force w/o cancel)          *\n*            |                   |NFRC    (force needs cancel)        *\n*            |                   |NSWP|SWAP (non-swap, swappable)     *\n*            |                   |TSWP (transwap)                     *\n*            |                   |FSWP (force swappable immediately)  *\n*            |                   |CSCB or DISP (display CSCB blks)    *\n*            |                   |BURN (memterm the address space)    *\n*            |                   |KILL (memterm after turning         *\n*            |                   |      off non-memtermable bits)     *\n*            |                   |NMEM|MEMT  (turn on/off             *\n*            |                   |        non-memtermable bits)       *\n*            |                   |COUNT  (display DONTSWAP count)     *\n*            |-  (displays the entire CSCB chain)                     *\n*            |?  (displays help)                                      *\n*                                                                     *\n*    Date:       April 15, 2010                                       *\n*                                                                     *\n*    Latest Modification:   January 12, 2020                          *\n*                                                                     *\n*    Authors:    Sam Golob, Joe Reichman (who did the hard part)      *\n*                                                                     *\n*    Technical Detail:  PUTLINE interface for TSO Output.             *\n*                       Uses the APUT macro, and EPUTL module.        *\n*                                                                     *\n*    Changes:  1.  SWAP, NSWP support dropped from this program       *\n*                   initially.  Version is 1.0.0.                     *\n*                                                                     *\n*              2.  Messages and DISP improved, to just show matching  *\n*                   CSCB chain entries, instead of all of them.       *\n*                   Coding a dash instead of a jobname or asid(hhhh)  *\n*                   - will display the entire CSCB chain.             *\n*                                                                     *\n*              3.  SWAP, NSWP support put back in this program.       *\n*                   Version is 1.1.0   (June 16, 2010)                *\n*                   It now does your own address space.  The cross    *\n*                   memory stuff was not put in yet, to make other    *\n*                   address spaces swappable, or non-swappable.       *\n*                                                                     *\n*              4.  Complete SWAP, NSWP support for cross address      *\n*                   space communication, was put in by Joe            *\n*                   Reichman.  (Oct 2011)  Version is 1.2.0.          *\n*                                                                     *\n*              5.  Burn an address space, if that is desired.         *\n*                   (Oct 2012)  Version is 1.2.5.                     *\n*                                                                     *\n*              6.  Kill an address space.  Before you do the          *\n*                  CALLRTM MEMTERM, the non-forcible flags in the     *\n*                  ASCB are turned off.                               *\n*                   (May 2017)  Version is 1.2.6.                     *\n*                                                                     *\n*              7.  Authority checking. So far, you need PSCB OPER     *\n*                   to do anything. ACCT to do BURN or KILL.          *\n*                   Version is 1.2.7.                                 *\n*                                                                     *\n*              8.  Make address space Non-Memtermable (can't be       *\n*                   FORCEd), or Memtermable (can be FORCEd).          *\n*                   Non-Memtermable implies Non-Cancelable, because   *\n*                   it isn't effective if the address space is        *\n*                   Cancelable but non-Memtermable).  You can easily  *\n*                   get rid of it, and it defeats the purpose of      *\n*                   non-Memtermable.  If you later make it            *\n*                   Memtermable, you can make it Cancelable next.     *\n*                                                                     *\n*              9.  Add TSWP function to do a TRANSWAP instead of      *\n*                   a DONTSWAP.  It really is only good if you do     *\n*                   it the first time, on an initially swappable      *\n*                   address space.  If you TRANSWAP an address        *\n*                   space that is already nonswappable, then you      *\n*                   will merely increase the number of DONTSWAP       *\n*                   requests by one, and the SYSEVENT return code     *\n*                   will be 4.                                        *\n*                                                                     *\n*             10.  Added display of the OUCBNDS field (halfword),     *\n*                   which is the number of outstanding DONTSWAP       *\n*                   requests.  The address space cannot become        *\n*                   swappable until this number is reduced to 1,      *\n*                   and an OKSWAP is done.                            *\n*                                                                     *\n*             11.  SRB was modified to run in 31-bit mode (from Joe). *\n*                                                                     *\n*             12.  Added Forced SWAP option to make the address       *\n*                   space swappable even though there are a number    *\n*                   of DONTSWAP requests still against it.  One       *\n*                   application of this is if you want to TRANSWAP    *\n*                   the address space.  First you FSWP it to ensure   *\n*                   that it is swappable, and then you TSWP it to     *\n*                   do the TRANSWAP.  THIS SHOULD ONLY BE DONE,       *\n*                   IF YOU KNOW WHAT YOU ARE DOING.                   *\n*                                                                     *\n*             13.  Cleaned up the messages and the help, to make      *\n*                   them (hopefully) consistent, and to hopefully     *\n*                   supply the information needed to know what is     *\n*                   going on with the address space being             *\n*                   manipulated.                                      *\n*                                                                     *\n*             14.  Added option to display the DONTSWAP COUNT         *\n*                   associated with an address space.                 *\n*                                                                     *\n*                                                                     *\n*   Change   Pgmr                   Description                       *\n*   -------  -----   ----------------------------------------------   *\n*                                                                     *\n*            JOER     Add SRB code to allow swapping in xmem.         *\n*                     (See lines commented with JOE.)                 *\n*                                                                     *\n*  -----------------------------------------------------------------  *\n*\n*  This macro lets you display hex values in a report.\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    STM   R15,R1,HEXSAVE           Save work registers.\n         LA    R1,&FROM                 Load from address.\n         LA    R0,&LEN                  Load length of hex number.\n         LA    R15,&TO                  Load to address.\n         BAL   R9,HEX                   BAL to routine.\n         LM    R15,R1,HEXSAVE           Restore work registers.\n         MEND\n*  -----------------------------------------------------------------  *\n*  --           Create PUTLINE environment.                       --  *\n*  -----------------------------------------------------------------  *\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP THE PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\n* --       End of Internal Macros......                            -- *\n* ------------------------------------------------------------------- *\n         SPACE 3\n* ------------------------------------------------------------------- *\n*   The CSCB chain of control blocks is above the line, so you need   *\n*    to have AMODE 31.  So is the OUCB.                               *\n* ------------------------------------------------------------------- *\nCNCLPG   CSECT\nCNCLPG   AMODE 31\nCNCLPG   RMODE ANY\n         YREGS\n         USING CNCLPG,R15          (Establish temporary base).\n         B     BEGIN               Skip over eyecatcher.\nEYEC0    DC    AL1(EYECL)          Exclusive length of header.\nEYEC     DC    C' CNCLPG - &SYSDATE - &SYSTIME -'\n         DC    C'     --------------------------------    '\n         DC    C' VER 1.2.10F '\n         DC    C'                   '\nEYECL    EQU   *-EYEC\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)     Save caller's registers\n         LR    R6,R1               Preserve CPPL pointer.\n         LR    R12,R15             Copy base.\n         USING CNCLPG,R12,R11,R10  (Tell assembler).\n         LA    R11,4095(,R12)      Load bases.\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)\n         LA    R10,1(,R10)\n         LR    R14,R13             Copy caller's save area pointer.\n         LA    R13,SAVE            Point to my save area.\n         ST    R13,8(,R14)         Chain ...\n         ST    R14,SAVE+4          ... Save areas.\n         ST    R6,SAVECPPL\n*                                  Get PSCBATR1 byte and copy it\n         ST    R1,SAVER1A          Save work register\n         L     R1,16               CVTPTR\n         L     R1,0(,R1)           TCB words\n         L     R1,4(,R1)           Current TCB\n         L     R1,180(,R1)         TCBJSCB\n         L     R1,264(,R1)         JSCBPSCB\n         LA    R1,0(,R1)           Clear hi order byte\n         LTR   R1,R1               Is there a PSCB ?\n         BZ    NOTFOUND            No, Issue COMMAND-NOT-FOUND msg\n         MVI   FLAG0,X'00'         Zero FLAG0 for safety\n         MVC   FLAG0(1),X'10'(R1)  Overlay it with PSCBATR1\n         L     R1,SAVER1A          Restore work register\nINITCON  DS    0H                  Initialize some constants.\n         MVI   FLAG1,X'00'\n         MVI   FLAG2,X'00'\n         MVI   FLAG3,X'00'\n         MVI   ONSWIT,X'00'\n         MVI   NSWFLG,X'00'\n         MVI   RTMCOD,X'00'\n         MVI   KEY0SFL,X'00'\n         MVI   SRB0SFL,X'00'\n         MVI   SRBNSWI,X'00'\n         MVI   SRBNSWO,X'00'\n         MVC   SRBNDS,=H'0'\n         MVC   KEY0NDS,=H'0'\n         MVI   ERRASID,X'00'\n         MVI   CANCINDC,X'00'\n         MVI   KILLFLAG,X'00'\n         MVI   OUTPUT-1,X'40'\n         MVC   OUTPUT,OUTPUT-1\n         MVI   NEWCHACT,X'00'\nMYASID   DS    0H                  Get my ASID\n         L     R2,X'224'           Point to PSAAOLD (my ASCB)\n         LA    R2,X'24'(,R2)       Point to my own ASID (ASCBASID)\n         MVC   OWNASID(2),0(R2)    Save it for comparison later\n         B     CONT0               Branch past constant\nOWNASID  DS    H\nCONT0    DS    0H                  Look at command's parameters.\n         LTR   R6,R6               Any CPPL?\n         BZ    EOJ8                No.  Get out.\n* ------------------------------------------------------------------- *\n*  R6 ---> CPPL           Find command being executed and its length. *\n*                         This is for the \"COMMAND CNCLPG NOT FOUND\"  *\n*                         message. It might be under another pgmname. *\n* ------------------------------------------------------------------- *\n*                                  Get ECT address\n         STM   R3,R5,SAVER345      Save work registers\n         L     R5,12(,R6)          Point to ECT\n         MVC   ECTPGM(8),BLANKS    Initialize command name field\n         MVC   ECTPGM(8),12(R5)    Get command name being executed\n         MVI   ECTPGML,X'00'       Initialize command length\n         LA    R4,8                Load BCT register\n         LA    R5,12(,R5)          Point to ECTPCMD field\n         LA    R3,0                Initialize counter\nGETLEN   DS    0H                  Loop\n         CLI   0(R5),X'40'         Is the character blank?\n         BE    GETLFND             Yes. We've finished.\n         LA    R5,1(,R5)           No. Advance pointer.\n         LA    R3,1(,R3)           Increment counter.\n         BCT   R4,GETLEN           Loop up to 8 times.\nGETLFND  DS    0H\n         STC   R3,ECTPGML          Store found length.\n         LM    R3,R5,SAVER345      Restore work registers\n* ------------------------------------------------------------------- *\nAUTHTEST DS    0H\n         TM    FLAG0,X'80'         PSCB OPER AUTHORITY?\n         BZ    NOTFOUND            No, Issue COMMAND-NOT-FOUND msg\n* ------------------------------------------------------------------- *\nPRTITLE  DS    0H                  Print program title. Not before\n*                                   authority test.\n         APUT  MESSAGET,L'MESSAGET\n         APUT  MESSAGEU,L'MESSAGEU\n* ------------------------------------------------------------------- *\n         L     R6,SAVECPPL         Just make sure we still have CPPL.\n         L     R1,0(,R6)           Pt to cmd buffer. (R6 reused later)\n         LTR   R1,R1               Any CMD buffer?\n         BZ    EOJ8                Get out if none.\n         LH    R3,0(,R1)           Load length.\n         CH    R3,=H'4'            Anything?\n         BNH   EOJ4                No. Get out.\n         LR    R5,R3               Length of command + 4\n         ICM   R5,14,FULLZERO      Clear hi order 3 bytes.\n         LH    R3,2(,R1)           Load offset.\n         SR    R5,R3               Subtract offset from full length+4\n         SH    R5,=H'4'            Correct for length of cmdbufr header\n         BC    8,WMESS2            Zero, message to enter userid.\n         BC    5,EOJ8              Less, or overflow, out.\nPARM     DS    0H\n         BAL   R9,GETIDS           Get parameters for the command.\n*                                  All the processing hooks off here.\n         B     EOJ0\n** ---------------------------------------------------------------- **\nWMESS2   DS    0H                  Print help messages.\n         BAL   R9,PRINTERR\n         B     EOJ4\n** ---------------------------------------------------------------- **\nEOJ0     DS    0H                  End of job.\n         APUT  RETURN0,L'RETURN0\n         LA    R15,0               Set CC = 0.\n         B     RETURN\nEOJ4     DS    0H\n         APUT  RETURN4,L'RETURN4\n         LA    R15,4               Set CC = 4.\n         B     RETURN\nEOJ8     DS    0H\n         APUT  RETURN8,L'RETURN8\n         LA    R15,8               Set CC = 8.\n         B     RETURN\nRETURN   L     R13,SAVE+4\n         L     R14,12(,R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n** ---------------------------------------------------------------- **\nNOTAUTH  DS    0H                  Command not APF authorized message.\n         APUT  MESSAGNA,L'MESSAGNA\n         B     EOJ4\n** ---------------------------------------------------------------- **\n*                       IBM's message is                             *\n*               IKJ56500I COMMAND CNCLPG NOT FOUND                   *\n*   We are faking this message, but CNCLPG possibly is being called  *\n*   by another command name.  Therefore, the message must remain     *\n*   authentic-looking even if the command length is different.       *\n*   The command name is extracted from the field ECTPCMD, ECT+X'C'   *\n** ---------------------------------------------------------------- **\nNOTFOUND DS    0H                  Fake \"COMMAND NOT FOUND\" message.\n         LA    R5,MESSAGAU         Point to \"COMMAND NOT FOUND\" messg\n         LA    R5,18(,R5)          Point past \"IKJ56500I COMMAND \"\n         XR    R4,R4               Clear work register\n         ICM   R4,1,ECTPGML        Insert program name length found\n         BCTR  R4,0                One less for EXECUTE\n         MVC   MESSAGAV,BLANKS     Nine blanks in message\n         EX    R4,MOVNAME          Move command name in\n         A     R4,=F'1'            Restore command name length\n         LA    R5,1(R4,R5)         Point past command name\n         MVC   0(L'MESSAGAW,R5),MESSAGAW  Move the rest of message in\n         APUT  MESSAGAU,L'MESSAGAU\n         B     RETURN              Get out of program\nMOVNAME  MVC   MESSAGAV(*-*),ECTPGM     ** EXECUTED **\n** ---------------------------------------------------------------- **\nNOTALLOW DS    0H                  Command NOT ALLOWED message.\n         APUT  MESSAGAT,L'MESSAGAT\n         B     RETURN\n** ---------------------------------------------------------------- **\nNOTMEMTM DS    0H                  Address space not MEMTERM-able.\n         MVC   MESSAGNM+4(8),FOUNJOBI    Jobname into message\n         HEX   MESSAGNM+22,2,FOUNASID    ASID into message\n         APUT  MESSAGNM,L'MESSAGNM       Say job Not-Memterm-able\n         APUT  MESSAGEL,L'MESSAGEL         and not burned,\n         APUT  MESSAGFL,L'MESSAGFL\n         BAL   R9,FORCHACT                 But show final status.\n         B     RETURN\n** ---------------------------------------------------------------- **\n* ---           Everything after here is subroutines.            --- *\n** ---------------------------------------------------------------- **\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                Get the parameters for the command.              *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*   Notes:  The ASID(xxx) can be coded first, without a userid.   *\n*           A dash can be coded first, to run the entire CSCB     *\n*            chain and display all the jobnames in it, with       *\n*            their associated ASIDs.  ? coded first gives HELP.   *\n*           If you code the word CSCB or DISP(lay) after either   *\n*            a jobname or an ASID(hhhh) then a display of ALL     *\n*            matching CSCB chain entries will be displayed, and   *\n*            no changes will be made.                             *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETIDS   DS    0H                  Get all parameters for the program.\n         ST    R9,SAVER9A\n         ST    R4,SAVER4C\n         AR    R1,R3               Point ...\n         LA    R1,4(,R1)           ... to char.\n         LA    R6,8                Load reg for BCT loop.\n         LR    R7,R1               Initialize pointer to first\n         LA    R7,0(,R7)                character of the ID field.\n         LA    R8,0                Initialize character count.\n         MVC   JOBID(8),BLANKS     Clear (first param - JOBNAME) field.\n         LA    R4,JOBID            Point reg to beginng of JOBID field.\n*\nCUTIDLEN DS    0H                  Look at the JOBID field first.\n*                                  (May contain ASID( or CSCB.)\n*\n         CLI   0(R7),X'40'         Is this character a blank?\n         BE    NOMORCUT            Yes, we are at the end of the field.\n         MVC   0(1,R4),0(R7)       Move only one character at a time.\n         OC    JOBID(8),BLANKS     And uppercase the partial jobid.\n*\n*   Is this a run of the CSCB chain only?\n* -- >  Test for CSCB  first  ---- below\n         CLI   JOBID,C'-'          Did we code '-' first?\n         BNE   CSCBHELP            No. Try if help asked for.\n         B     CSCBRUN1            Yes. Run entire CSCB chain.\n* - > Help\nCSCBHELP DS    0H\n         CLI   JOBID,C'?'          Help?\n         BNE   NOCSCB              No. Skip this code.\n         BAL   R9,PRINTERR         Yes. Print messages\n         B     EOJ0                  and get out with code 0.\n* - > Help\nCSCBRUN1 DS    0H\n         ST    R8,SAVER8A          Store count for display if needed.\n         OI    FLAG2,X'40'         Mark that this is CSCB only run.\n         BAL   R9,RUNCSCB          Do the run for CSCB chain.\n         B     EOJ0                Out with normal return code.\nNOCSCB   DS    0H\n* -- >  Test for CSCB  first  ---- above\n*\n*   Was the ASCB(hhh) parameter coded without the jobid?\n* -- >  Test for ASID( first  ---- below\n         CLC   JOBID(L'ASIDC),ASIDC  Did we code ASID( in jobid field?\n         BNE   NOASIDF             No. Pass this code.\n         OI    FLAG1,X'01'         Flag that ASID( ) was first.\n         NI    FLAG1,X'FF'-X'02'   Turn off Jobname in jobid field flag\n         MVC   ASIDWKL(L'ASIDC),JOBID  Move the ASID( to proper field.\n         MVC   JOBID,BLANKS        Blank out Job ID if ASID( coded.\n         LA    R7,1(,R7)           Bump another character.\n         LA    R8,1(,R8)           Count another character.\n         LA    R6,1                Set number of branches later.\n*                                  This will limit number of params\n*                                   that are searched for.\n         B     ASIDONLY            Bypass all the real jobname stuff.\n* -- >  Test for ASID( first  ---- above\nNOASIDF  DS    0H                  ASID( is not the first parameter.\n         LA    R4,1(,R4)           Bump another character.\n         LA    R7,1(,R7)           Bump another character.\n         LA    R8,1(,R8)           Count another character.\n         CR    R8,R5               End of command buffer ?\n         BNL   NOMORCUT            Yes. Get out now.\n         BCT   R6,CUTIDLEN         Try for the next blank, up till 8.\nNOMORCUT DS    0H\n         STC   R8,SAVCOUNT         Save length of Jobname\n         L     R4,SAVER4C          Restore work register for use later.\n         OC    JOBID(8),BLANKS     Uppercase the new Job Id.\n         OI    FLAG1,X'02'         Set 'Jobname Coded' flag.\n*  -  Display the found JOBID - below\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Search Jobname:'\n         MVC   OUTPUT+17(8),JOBID\n         APUT  OUTPUT,30\n         APUT  MESSAGEL,L'MESSAGEL\n*  -  Display the found JOBID - above\n         LA    R6,1                Set number of branches later.\n*                                  This will limit number of params\n*                                   that are searched for.\n         B     LOOKKEYW\n*  Constants - below - ***\nJOBID    DC    C'        '         STORE PARM USERID HERE\nBLANKS   DC    C'         '        9 BLANKS\nMESSAGET DC   C'CNCLPG 1.2.10F - Alter Characteristics of a Running AddX\n               ress Space'\nMESSAGEU DC   C'------ ------- - ----- --------------- -- - ------- ---X\n               ---- -----'\nMESSAGEL DC    C'----------------------------'\nMESSAGEM DC    C'-----------------------------------------------'\nMESSAG2A DC    C'Syntax:  CNCLPG jobname ASID(hhhh) FUNCtion   '\nMESSAG2B DC    C'   Function is:  CNCL, NCNC, FORC, NFRC, NSWP, '\nMESSAG2V DC    C'   SWAP, MEMT, NMEM, TSWP, or COUNT.   '\nMESSAG2Y DC    C' FSWP, BURN, or KILL are dangerous.    '\nMESSAG2W DC    C'   TSWP will do a TRANSWAP.                        '\nMESSAG2U DC    C'Or code CSCB or DISP to just display CSCB entries.'\nMESSAG2C DC    C'   DISPlay or CSCB will display CSCB chain entries,'\nMESSAG2D DC    C'   without changing them.'\nMESSAG2E DC   C' When affecting a job, we must affect the CORRECT job,'\nMESSAG2F DC    C'  therefore you should use the DISPlay option first.'\nMESSAG2G DC   C' To display the whole CSCB, code - (dash) for JOBNAME.'\nMESSAG2H DC    C' To see this help message, code ? for JOBNAME.'\nMESSAG2I DC    C'** NOTES (IMPORTANT) :  ** BE SURE TO READ THIS **'\nMESSAG2J DC   C' CSCB (DISP) display for an ASID shows ALL occurrences'\nMESSAG2K DC    C'  for that ASID, regardless of JOBNAME.      '\nMESSAG2L DC C' CSCB (DISP) display for a JOBNAME shows ALL occurrences'\nMESSAG2M DC    C'  for those JOBNAME characters, regardless of ASID.  '\nMESSAG2N DC    C' CNCL, NCNC, FORC, NFRC, NSWP, SWAP changes the FIRST'\nMESSAG2O DC    C'  entry in the CSCB chain that matches, if multiple '\nMESSAG2P DC    C'  entries exist. But DISP will display ALL applicable'\nMESSAG2Q DC    C'  matching entries in the CSCB chain, so you can see'\nMESSAG2R DC    C'  which one you want to change specifically.'\nMESSAG2S DC    C' When you code BOTH jobname AND asid, to CHANGE it,'\nMESSAG2T DC    C'  then ONLY that specific job and asid gets changed.'\nMESSAGNG DC    C'Job was not done. SYSEVENT return code was     '\nMESSAGNH DC    C'   SYSEVENT return code was     '\nMESSAGNS DC    C'Job xxxxxxxx for ASID HHHH made non-swappable.'\nMESSAGTS DC    C'Job xxxxxxxx for ASID HHHH was trans-swppped.'\nMESSAGSW DC    C'Job xxxxxxxx for ASID HHHH was made swappable.'\nMESSAGSY DC C'  Job xxxxxxxx for ASID HHHH was not made swappable yet.'\nMESSAGAN DC    C'Job xxxxxxxx for ASID HHHH already non-swappable.'\nMESSAGAS DC    C'Job xxxxxxxx for ASID HHHH was already swappable.'\nMESSAGFN DC    C'Function xxxx was called for.'\nMESSAGFX DC    C'Function xxxxx was called for.'\nMESSAGBU DC    C'Job xxxxxxxx for ASID HHHH has been burned.'\nMESSAGKI DC    C'Job xxxxxxxx for ASID HHHH has been killed.'\nMESSAGAT DC    C'Lacking authority to execute this command.'\nMESSAGNM DC    C'Job xxxxxxxx for ASID HHHH not MEMTERM-able. Not burnex\n               d.'\nMESSAGM1 DC    C'Job xxxxxxxx for ASID HHHH made non-memtermable.'\nMESSAGM2 DC    C'Job xxxxxxxx for ASID HHHH was made memtermable.'\nMESSAGAL DC    C'  * -----  ALWAYS DO A DISPLAY FIRST  ----- * '\nMESSAGFL DC    C'Final Job Status Report.'\nRETURN0  DC    C'Return code is 0'\nRETURN4  DC    C'Return code is 4'\nRETURN8  DC    C'Return code is 8'\nMESSAGAU DS    0CL38\n         DC    CL18'IKJ56500I COMMAND '\nMESSAGAV DC    C'        '\n         DC    C'         '\n         DC    C'    '\n*                     ***  Places to save registers  ***  below\nECTPGM   DC    CL8' '\nECTPGML  DC    X'00'\nMESSAGAW DC    C'NOT FOUND'\nSAVER345 DS    3F\nSAVECPPL DS    F\nSAVER1A  DS    F\nSAVER3A  DS    F\nSAVER3B  DS    F\nSAVER3C  DS    F\nSAVER3D  DS    F\nSAVER3E  DS    F\nSAVER3F  DS    F\nSAVER3G  DS    F\nSAVER3H  DS    F\nSAVER4A  DS    F\nSAVER4B  DS    F\nSAVER4C  DS    F\nSAVER4D  DS    F\nSAVER5A  DS    F\nSAVER6A  DS    F\nSAVER6B  DS    F\nSAVER7A  DS    F\nSAVER7B  DS    F\nSAVER8A  DS    F\nSAVER9A  DS    F\nSAVER9B  DS    F\nSAVER9C  DS    F\nSAVER9D  DS    F\nSAVER9E  DS    F\nSAVER9F  DS    F\nSAVER9G  DS    F\nSAVER9H  DS    F\nSAVER9I  DS    F\nSAVER9J  DS    F\nSAVER9K  DS    F\nSAVER9L  DS    F\nSAVER9M  DS    F\nSAVER9N  DS    F\nSAVER9O  DS    F\n*                     ***  Places to save registers  ***  above\nSAVCOUNT DS    X\nKILLFLAG DS    X\n*              X'01'               KILL indicated\n*              X'02'               BURN indicated  X'01' also on\n*              X'04'               NMEM indicated\n*              X'08'               MEMT indicated\nDUBLZERO DC    D'0'\nFULLZERO DC    F'0'\nCANCINDC DC    X'00'\nCANCKEY0 DC    X'00'\nNEWCHACT DC    X'00'\n*  Constants - above - ***\nLOOKKEYW DS    0H                  Look for additional keywords.\n         LA    R7,1(,R7)           Bump command buffer pointer.\n         LA    R8,1(,R8)           Bump character counter.\n         CR    R8,R5               End of command buffer?\n         BNL   GETIDEND            Yes. Don't look any more.\n         MVC   ASIDWKL(5),BLANKS   Clear parameter work field.\n         MVC   ASIDWKL(5),0(R7)    Next 5 characters to work field.\nASIDONLY DS    0H                  Jump to here if ASID( coded first.\n         OC    ASIDWKL(4),BLANKS   Uppercase work field.\n         CLC   ASIDC,ASIDWKL       Is the ASID( keyword there?\n         BE    DOASID              Yes. Process it.\n         CLC   CNCLC,ASIDWKL       Is the CNCL  keyword there?\n         BE    DOCNCL              Yes. Process it.\n         CLC   NCNCC,ASIDWKL       Is the NCNC  keyword there?\n         BE    DONCNC              Yes. Process it.\n         CLC   SWAPC,ASIDWKL       Is the SWAP  keyword there?\n         BE    DOSWAP              Yes. Process it.\n         CLC   NSWPC,ASIDWKL       Is the NSWP  keyword there?\n         BE    DONSWP              Yes. Process it.\n         CLC   TSWPC,ASIDWKL       Is the TSWP  keyword there?\n         BE    DOTSWP              Yes. Process it.\n         CLC   FSWPC,ASIDWKL       Is the FSWP  keyword there?\n         BE    DOFSWP              Yes. Process it.\n         CLC   FORCC,ASIDWKL       Is the FORC  keyword there?\n         BE    DOFORC              Yes. Process it.\n         CLC   NFRCC,ASIDWKL       Is the NFRC  keyword there?\n         BE    DONFRC              Yes. Process it.\n         CLC   CSCBC,ASIDWKL       Is the CSCB  keyword there?\n         BE    DOCSCB              Yes. Process it.\n         CLC   DISPC,ASIDWKL       Is the DISP  keyword there?\n         BE    DOCSCB              Yes. Process it.\n         CLC   BURNC,ASIDWKL       Is the BURN  keyword there?      BUR\n         BE    DOBURN              Yes. Process it.                 BUR\n         CLC   KILLC,ASIDWKL       Is the KILL  keyword there?      KIL\n         BE    DOKILL              Yes. Process it.                 KIL\n         CLC   NMEMC,ASIDWKL       Is the NMEM  keyword there?\n         BE    DONMEM              Yes. Process it.\n         CLC   MEMTC,ASIDWKL       Is the MEMT  keyword there?\n         BE    DOMEMT              Yes. Process it.\n         CLC   COUNTC(4),ASIDWKL   Is the COUNT keyword there?\n         BE    DOCOUNT             Yes. Process it.\n         B     LOOKKEYW            Go loop and look at next character.\nASIDWKL  DC    CL5' '              Second parameter work area.\n*\nASIDC    DC    C'ASID('            Literals....\nCNCLC    DC    C'CNCL'\nNCNCC    DC    C'NCNC'\nSWAPC    DC    C'SWAP'\nNSWPC    DC    C'NSWP'\nTSWPC    DC    C'TSWP'\nFSWPC    DC    C'FSWP'\nFORCC    DC    C'FORC'\nNFRCC    DC    C'NFRC'\nCSCBC    DC    C'CSCB'\nDISPC    DC    C'DISP'\nBURNC    DC    C'BURN'\nKILLC    DC    C'KILL'\nNMEMC    DC    C'NMEM'\nMEMTC    DC    C'MEMT'\nCOUNTC   DC    C'COUNT'\n*\nDOASID   DS    0H                  Look for hex value of the ASID.\n         OI    FLAG1,X'04'         Show that ASID( was coded.\n         BAL   R9,GETASID          Go get the rest of the parameters.\n         MVC   ASIDWKL(5),BLANKS   Blank out the second wkarea for\n*                                   a further parameter search.\n         B     LOOKKEYW            Re-loop to look further for params.\n*\n* ------------------------------------------------------------------- *\nDOCNCL   DS    0H                  Handle CNCL (cancelable) keyword.\n         OI    CANCINDC,X'08'      Show which CHACT bit is affected.\n         OI    FLAG2,X'01'         Show that CNCL was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'01'        Set to OR the bits\n         NI    ONSWIT,X'FF'-X'02'   and not to AND the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n*                                    Print the action code.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),CNCLC\n         APUT  OUTPUT,25\n*                                    Print the bit in CHACT affected.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDONCNC   DS    0H                  Handle NCNC (non-cancelable) keyword\n         OI    CANCINDC,X'08'      Show which CHACT bit is affected.\n         OI    FLAG2,X'02'         Show that NCNC was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'02'        Set to AND the bits\n         NI    ONSWIT,X'FF'-X'01'   and not to OR the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n*                                    Print the action code.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),NCNCC\n         APUT  OUTPUT,25\n*                                    Print the bit in CHACT affected.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDOCOUNT  DS    0H                  Display DONTSWAP count only.\n         OI    FLAG3,X'10'         Turn on. DONTSWAP count only.\n         MVC   MESSAGFX+9(5),COUNTC  Write message to say COUNT\n         APUT  MESSAGFX,L'MESSAGFX\n         BAL   R9,FINDCSCB         Get the correct CSCB member\n         BAL   R9,PRNTJOBI         Job identification output.\n         BAL   R9,KEY0SWNS         Do not do SYSEVENT, just get count.\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDOFSWP   DS    0H\n         OI    FLAG3,X'02'         Indicate FSWP instead of SWAP.\nDOSWAP   DS    0H                  Now this routine is operational.\n         OI    FLAG2,X'04'         Show that SWAP was coded.\n         TM    FLAG3,X'02'         Was Forced SWAP indicated?\n         BO    DOMSGFSW            Show that FSWP was coded.\n         MVC   MESSAGFN+9(4),SWAPC   Write message to say SWAP.\n         B     DOMSGPRT\nDOMSGFSW MVC   MESSAGFN+9(4),FSWPC   Write message to say FSWP.\nDOMSGPRT DS    0H\n         APUT  MESSAGFN,L'MESSAGFN\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         BAL   R9,KEY0SWNS         Do SYSEVENT OKSWAP, xmem or not.\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDONSWP   DS    0H                  Now this routine is operational.\n         OI    FLAG2,X'08'         Show that NSWP was coded.\n         MVC   MESSAGFN+9(4),NSWPC   Write message to say that.\n         APUT  MESSAGFN,L'MESSAGFN\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         BAL   R9,KEY0SWNS         Do SYSEVENT DONTSWAP, xmem or not.\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDOTSWP   DS    0H                  Now this routine is operational.\n         OI    FLAG2,X'08'         Show that NSWP was coded.\n         OI    FLAG3,X'01'         Show that TSWP was coded.\n         MVC   MESSAGFN+9(4),TSWPC   Write message to say that.\n         APUT  MESSAGFN,L'MESSAGFN\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         BAL   R9,KEY0SWNS         Do SYSEVENT TRANSWAP, xmem or not.\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDOFORC   DS    0H                  Handle FORC (forcible) keyword\n         OI    FLAG2,X'10'         Show which CHACT bit is affected.\n         OI    CANCINDC,X'01'      Show that FORC was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'01'        Set to OR the bits\n         NI    ONSWIT,X'FF'-X'02'   and not to AND the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n*\n         MVC   OUTPUT,OUTPUT-1       Print the action code.\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),FORCC\n         APUT  OUTPUT,25\n*\n         MVC   OUTPUT,OUTPUT-1       Print the bit in CHACT affected.\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDONFRC   DS    0H                  Handle NFRC (non-forcible) keyword\n         OI    FLAG2,X'20'         Show which CHACT bit is affected.\n         OI    CANCINDC,X'01'      Show that NFRC was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'02'        Set to AND the bits\n         NI    ONSWIT,X'FF'-X'01'   and not to OR the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n*\n         MVC   OUTPUT,OUTPUT-1       Print the action code.\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),NFRCC\n         APUT  OUTPUT,25\n*\n         MVC   OUTPUT,OUTPUT-1       Print the bit in CHACT affected.\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDOCSCB   DS    0H\n         OI    FLAG1,X'08'         Show CSCB keyword was coded.\n         OI    FLAG2,X'40'         Show CSCB keyword was coded.\n         MVC   OUTPUT,OUTPUT-1       Print the action code.\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),CSCBC\n         MVC   OUTPUT+23(9),=C'(DISPlay)'\n         APUT  OUTPUT,35\n         BAL   R9,RUNCSCB          Run the CSCB chain with print.\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\n*      GETIDEND is processing at the end of program execution.        *\n* ------------------------------------------------------------------- *\n*  GETIDEND has been modified to do \"final reporting\" for most of     *\n*  the functions, because its timing is the latest you can get here.  *\n* ------------------------------------------------------------------- *\nGETIDEND DS    0H                  End of keyword processing.\n         TM    FLAG3,X'10'         Count only? There is activity.\n         BO    GETKEYNS            So bypass FLAG2 & KILLFLAG check.\n* ------------------------------------------------------------------- *\n*   Earlier functionality of this program was keyed off of FLAG2.     *\n*   Later, KILLFLAG and FLAG3 were implemented to control further     *\n*   funtionality that was developed later.                            *\n* ------------------------------------------------------------------- *\n         TM    FLAG2,X'FF'         Check if any real actions asked\n         BNZ   GETKEYNR            Yes, some were.\n         APUT  MESSAGEY,L'MESSAGEY    No. Display help messages.\n         BAL   R9,PRINTERR\n         B     EOJ4                   And end with code = 4.\nGETKEYNR DS    0H                  Real actions WERE asked for.\n         TM    KILLFLAG,X'FF'      Any of the KILLFLAG options on?\n         BZ    SKPKEYNR            No, no extra printout.\n         TM    KILLFLAG,X'03'      If kill, then don't need status.\n         BNZ   SKPKEYNR             (The job is dead anyway.)\nGETKEYNS DS    0H                  Real actions WERE asked for.\n         APUT  MESSAGEL,L'MESSAGEL\n         APUT  MESSAGFL,L'MESSAGFL\n         TM    FLAG3,X'10'         When COUNT only, don't need\n         BO    SKPKEYNR             extra CHACT format here.\n         BAL   R9,FORCHACT         Show summary after actions.\nSKPKEYNR DS    0H                  There IS something left to report.\n         TM    FLAG3,X'01'         TRANSWAP?\n         BZ    SKPDISP1            Not important for not TRANSWAP\n         CLC   OWNASID,FOUNASID    Target ASID different from ours?\n         BNE   SKPDISP0            No. Just do SYSEVENT in this adrspc\n*                                  because there is no timing problem.\n         BAL   R9,DISPNDS          True count for TRANSWAP\n         B     SKPDISP1\nSKPDISP0 DS    0H                  Not enough time to update count\n         BAL   R9,DISPNDSX         Kludged count for TRANSWAP,\n*                                  because the real TRANSWAP takes\n*                                  time, and there wasn't enough\n*                                  time within the program, to report\n*                                  the updated DONTSWAP count.\nSKPDISP1 DS    0H\n         TM    FLAG1,X'08'         CSCB coded ?\n         BO    SKPDISP2            Yes. All reporting was already done.\n         TM    KILLFLAG,X'0F'      Any KILLFLAG stuff?\n         BNZ   SKPDISP2            Yes. Formatting not relevant.\n*                                  All reporting already done there.\n* ------------------------------------------------------------------- *\n         L     R3,FOUNCSCB         Go reload our CSCB entry in chain.\n         USING CHAIN,R3\n         MVC   SAVEACTF(1),CHACT   Current CHACT flags for this CSCB.\n         MVC   SAVESTSF(1),CHSTS   Current CHSTS flags for this CSCB.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Current  CHSTS Flags:'\n         HEX   OUTPUT+23,1,CHSTS\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Current  CHACT Flags:'\n         HEX   OUTPUT+23,1,CHACT\n         APUT  OUTPUT,25\n         DROP  R3\n         BAL   R9,FORCHACT         Format the new CHACT flags.\nSKPDISP2 DS    0H\n         L     R9,SAVER9A\n         B     EOJ0                And end with normal return code.\n** ---------------------------------------------------------------- **\n**               O T H E R     S U B R O U T I N E S                **\n** ---------------------------------------------------------------- **\nHEX      DS    0H                  Display hex values.\n         ST    R9,SAVER9B\n         MVC   1(1,R15),0(R1)      Move byte.\n         UNPK  0(3,R15),1(2,R15)   Unpack.\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)         Increment output pointer.\n         LA    R1,1(,R1)           Increment input pointer.\n         BCT   R0,HEX              Decrement length, then loop.\n         MVI   0(R15),C' '         Blank the trailing byte.\n         L     R9,SAVER9B\n         BR    R9                  Return to caller.\nHEXTAB   DC    C'0123456789ABCDEF' Translate table.\n** ---------------------------------------------------------------- **\nDISPNDS  DS    0H                  Display count of DONTSWAP requests\n         ST    R9,SAVER9ND           for the current address space\n         ST    R3,SAVER3H\n         L     R2,X'224'                 ASCB\n         L     R2,X'90'(,R2)             ASCBOUCB\n         LA    R3,X'11'(,R2)             OUCBSFL\n         LA    R2,X'88'(,R2)             OUCBNDS (Count Field)\n         MVC   KEY0NDS(2),0(R2)          Move the count to display.\n         MVC   KEY0SFL(1),0(R3)          Move the set of flags\n         MVC   OUTPUT,OUTPUT-1           Clear output area.\n         MVC   OUTPUT+2(32),=C'Outstanding DONTSWAP requests:  '\n         HEX   OUTPUT+35,2,0(R2)         Display the number found.\n*        TM    KEY0SFL,X'80'\n*        BZ    DISPNDX1\n*        MVC   OUTPUT+45(3),=C'NSW'\n         B     DISPNDX2\nDISPNDX1 DS    0H\n*        MVC   OUTPUT+45(3),=C'SWP'\nDISPNDX2 DS    0H\n         APUT  OUTPUT,50\n         L     R3,SAVER3H\n         L     R9,SAVER9ND\n         BR    R9\nSAVER9ND DS    F\n** ---------------------------------------------------------------- **\n*    EXPLANATION OF THE TRANSWAP TIMING DELAY FROM CROSS-MEMORY.     *\n** ---------------------------------------------------------------- **\n*    A real TRANSWAP has a timing delay, if it is done on a          *\n*      different address space.  You have to schedule an SRB to      *\n*      execute.  Then the address space needs a swap-out and a       *\n*      swap-in.  The job is not finished before this program ends.   *\n*                                                                    *\n*    A TRANSWAP of an already nonswappable address space does not    *\n*      have much delay, because nothing is really being done,        *\n*      except an increase in the DONTSWAP count.                     *\n*                                                                    *\n*    If the TRANSWAP is on your own address space, you don't have    *\n*      to schedule an SRB, and it finishes quicker.  The correct     *\n*      number of the DONTSWAP count is available to report.          *\n*      (No kludge is needed.)                                        *\n*                                                                    *\n*    Why the kludge?                                                 *\n*                                                                    *\n*    Therefore, since the real OUCBNDS count of 1, is not attained   *\n*      before this program finishes, and we want to report the       *\n*      right number 1, we have to fake the number to be 1, because   *\n*      the system doesn't show the correct information yet.  We      *\n*      know that the X'0001' will soon show up in the OUCBNDS        *\n*      field of the OUCB.  But it is not there yet, and we have      *\n*      to report it in our program now.  So we fake it.              *\n*                                                                    *\n*    What do we do cross-memory to obtain the DONTSWAP count?        *\n*                                                                    *\n*    Where do we get the OUCBNDS number cross-memory?  We extract    *\n*      it from the SRB code, which remains in common storage,        *\n*      and it can still be referenced after the SRB code has         *\n*      finished executing (done in section BUILDSRB).                *\n*                                                                    *\n*    KEY0NDS is copied from the cross-memory SRB code's storage,     *\n*      and obtained from the halfword storage field SRBNDS.          *\n** ---------------------------------------------------------------- **\nDISPNDSX DS    0H        \"REAL\" Transwap DONTSWAP number display\n** ---------------------------------------------------------------- **\n         ST    R9,SAVER9ND         Kludge count for timing delay.\n         LH    R3,KEY0NDS          Only applies to real xmem TRANSWAP.\n         CH    R3,=X'0000'         After TRANSWAP, is the code 0 ?\n         BNE   DISPNOCH            Not zero, don't add one.\n         AH    R3,=H'1'            One more. System catches up later.\n         STH   R3,KEY0NDSX         Store for display only, not to use.\n         B     DISPNOCI            Jump to the display.\nDISPNOCH DS    0H                     If kludge is not necessary,\n         MVC   KEY0NDSX,KEY0NDS       Display real count, not kludged.\nDISPNOCI DS    0H                     Print the display out.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT+2(32),=C'Outstanding DONTSWAP requests:  '\n         HEX   OUTPUT+35,2,KEY0NDSX   Display the DONTSWAP number.\n         APUT  OUTPUT,50\n         L     R9,SAVER9ND\n         BR    R9\n** ---------------------------------------------------------------- **\n**         Get Current SWAP state of our own address space          **\n** ---------------------------------------------------------------- **\nGETSWST  DS    0H         Get current swap state of our address space\n         ST    R9,SAVER9O\n         L     R2,X'224'                 Our ASCB\n         L     R2,X'90'(,R2)             ASCBOUCB\n         TM    X'11'(R2),X'80'           Test OUCBNSW bit of OUCBSFL.\n         BZ    GETSWSSW                  Not on. Say swappable.\n         OI    NSWFLG,X'01'              On. Say non-swappable.\n         B     GETSWSEN                  Leave routine.\nGETSWSSW DS    0H\n         NI    NSWFLG,X'FE'              Show swappable to our pgm.\nGETSWSEN DS    0H                        Leave routine.\n         L     R9,SAVER9O\n         BR    R9\n** ---------------------------------------------------------------- **\n**               EXTRACT ASID NUMBER FROM PARM                      **\n** ---------------------------------------------------------------- **\nGETASID  DS    0H                  Get hex ASID for 2 bytes.\n         ST    R9,SAVER9C          Save registers.\n         STM   R1,R6,SAVERGS1\n         LA    R6,4                Load BCT register.\n         LA    R4,ASIDWK           Point to ASID work area.\n         TM    FLAG1,X'02'         Ask if Job name was coded.\n         BZ    GETAFL01            Wasn't. Have to adjust pointers.\n         LA    R7,5(,R7)           Bump command buffer pointer.\n         LA    R8,5(,R8)           Bump character counter.\nGETAFL01 DS    0H\nGETASIDL DS    0H                  Loop to get hex ASID for 4 display\n*                                    bytes to convert to 2 hex bytes.\n         CLI   0(R7),C')'          Have we reached close parenthesis?\n         BE    GETASIDG            Yes, assume we've got it.\n         CLI   0(R7),C' '          Have we hit a blank?\n         BE    GETASIDG            Yes, assume we've got it.\n         MVC   0(1,R4),0(R7)       Otherwise move one character over.\n         LA    R4,1(,R4)           Bump one ASIDWK character (target)\n         LA    R7,1(,R7)           Bump command buffer pointer.\n         LA    R8,1(,R8)           Bump character counter.\n         BCT   R6,GETASIDL         Loop for 4 characters.\n         B     GETASIDG            We don't look for more than 4.\nGETASIDG DS    0H\n*        APUT  ASIDWK,4\n         LA    R4,ASIDWK           Point register at workarea again.\n         LA    R1,4                Maximum of 4 characters.\nGETASIDA DS    0H\n         CLI   3(R4),X'40'         Is last character a blank (<4 total)\n         BNE   GETASIDM            No. We're finished sliding.\n         BCTR  R4,0                Slide the pointer one place back.\n         BCT   R1,GETASIDA         Do it no more than 4 times.\nGETASIDM DS    0H\n         MVC   ASIDMV(4),0(R4)     Move 4 characters so last one\n*                                     is not blank.\n         MVC   ASIDWKSV(4),ASIDMV    Save these 4 characters\n         MVC   ASIDWKS(4),ASIDMV        in two places.\n         MVC   OUTPUT,OUTPUT-1       Clear output line.\n         MVC   OUTPUT(25),ASIDMSG    Move coded display format asid.\n         APUT  OUTPUT,40             And put out the message.\n         TR    ASIDMV(4),ASIDVAL     Translate display format message\n*                                      into format X'0h0h0h0h'.\n*        MVC   OUTPUT,OUTPUT-1       Test display of hex result.\n*        HEX   OUTPUT,4,ASIDMV\n*        APUT  OUTPUT,10\n         BAL   R9,VALIDTR            Validity check the hex number.\n         PACK  ASIDGET(3),ASIDMV(5)  Get rid of all zone nibbles.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Search ASID   :' Print resulting 2-bytes\n         HEX   OUTPUT+21,2,ASIDBIN\n         APUT  OUTPUT,30\n         APUT  MESSAGEL,L'MESSAGEL   Add underline for clear display.\n*\nGETASIDE DS    0H                    End of routine.\n         LM    R1,R6,SAVERGS1        Restore registers\n         L     R9,SAVER9C               and\n         BR    R9                          exit.\n** ---------------------------------------------------------------- **\nASIDWKB  DC    CL4'    '\nASIDWK   DC    CL4'    '\nASIDWKF  DC    CL4' '\nASIDMV   DC    CL4'    '\nASIDMVF  DC    CL4' '\nASIDBIN  DS    0XL2\nASIDGET  DC    XL4'00000000'\nSAVERGS1 DS    6F\n** ---------------------------------------------------------------- JOE\n*   GETASCB - Return ASCB, given the ASID of the address space      JOE\n*   -------                                                         JOE\n*  Input:                                                           JOE\n*      FOUNASID = ASID                                              JOE\n*  Output:                                                          JOE\n*      R15 = 0    Error                                             JOE\n*      R15 = ASCB                                                   JOE\n** ---------------------------------------------------------------- JOE\nGETASCB  DS    0H                                                   JOE\n         ST    R9,SAVER9M            Save Register                  JOE\n         L     R15,CVTPTR            R15 -> CVT                     JOE\n         L     R15,CVTASVT-CVT(,R15)  R15 -> ASVT                   JOE\n         USING ASVT,R15                                             JOE\n         CLC   ASVTASVT-ASVT(4,R15),=C'ASVT'  check eyecatcher      JOE\n         BNE   NOASCB                                               JOE\n         LA    R15,ASVTENTY-ASVT(,R15) Get first ASVT slot          JOE\n         LH    R0,FOUNASID           Get ASID in question           JOE\n         BCTR  R0,0                  Down By 1                      JOE\n         SLL   R0,2                  Multiply by 4                  JOE\n         AR    R15,R0                Point to ASCB                  JOE\n         B     GETASCBE              Exit this routine              JOE\nNOASCB   DS    0H                                                   JOE\n         XR    R15,R15               Clear R15 - no ASCB there      JOE\nGETASCBE DS    0H                                                   JOE\n         L     R9,SAVER9M            Restore Register               JOE\n         BR    R9                                                   JOE\n** ---------------------------------------------------------------- JOE\n*               Translate table to validity check ASID.              *\n*                 Convert display values to X'0h'                    *\n*                 (where h is the hex value).                        *\n** ---------------------------------------------------------------- **\nASIDVAL  DS    0D\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'00CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CC0A0B0C0D0E0FCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CC0A0B0C0D0E0FCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'00010203040506070809CCCCCCCCCCCC'\nFILLER1  DS    CL24\nASIDMSG  DC    CL21'ASID parm entered  : '\nASIDWKSV DC    CL4' '\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\n**        FIND WHICH CSCB ENTRY SATISFIES THE PARM REQUEST          **\n** ---------------------------------------------------------------- **\nFINDCSCB DS    0H                  Find CSCB entry to change or report.\n         ST    R9,SAVER9D          Save registers.\n         ST    R3,SAVER3A\nFINDCSST DS    0H                  Get the first CSCB.\n         L     R3,16               CVT\n         L     R3,X'94'(,R3)       MSER - pointer to CSCB chain.\n         ICM   R3,15,0(R3)         First CSCB entry.\n         USING CHAIN,R3            Tell assembler.\n         BZ    FINDCSEC            If zero, we are at end of CSCB chain\nFINDCSLP DS    0H                  Loop through the CSCB entries.\n         MVC   CSCBACTF(1),CHACT     Save CSCB ACT flag for this CSCB.\n         MVC   SAVEACTF(1),CHACT     Save CSCB ACT flag for this CSCB.\n         MVC   SAVESTSF(1),CHSTS     Save CSCB STS flag for this CSCB.\n         MVC   CSCBJOBI(8),CHKEY     Save CSCB Jobid (CHKEY).\n         MVC   CSCBPROC(8),CHCLS     Save CSCB PROC id (CHCLS).\n         MVC   CSCBASID(2),CHASID    Save CSCB ASID (CHASID).\n* ------------------------------------------------------------------- *\n* We first try to match a JOBID if coded, to the job id in this CSCB. *\n* If equal, we see if an ASID has been coded, and both have to match. *\n* Otherwise, with no match, we go to the end of the CSCB chain.       *\n* ------------------------------------------------------------------- *\nFINDCSMY DS    0H                  Find the CSCB that I want.\n         TM    FLAG1,X'04'         Was ASID( coded at all?\n         BZ    FINDCSJB            No. Just find a JOBID match.\n         TM    FLAG1,X'01'         Is the JOB id missing?\n         BO    FINDCSAS            Yes, just look for an ASID match.\n         TM    FLAG1,X'02'         Was JOB id coded?\n         BO    FINDCSJB            Yes. Look for it.\n         ICM   R3,15,0(R3)         Go to next CSCB.\n         BZ    FINDCSEC            If zero, we are at end of CSCB chain\n         B     FINDCSLP            Look at next CSCB entry in table.\nFINDCSJB DS    0H                  Check for JOBID match in this CSCB.\n         CLC   JOBID(8),CSCBJOBI   Compare coded JOBID to CSCB jobname.\n         BE    FINDCSIA            Equal, check if ASID is there.\n         ICM   R3,15,0(R3)         Otherwise go to the next CSCB.\n         BZ    FINDCSEC            Zero, end of the CSCB chain.\n         B     FINDCSLP            Not zero, look at the next entry.\nFINDCSIA DS    0H\n         TM    FLAG1,X'04'         Was ASID( coded?\n         BZ    FINDCSFD            No. Found it on just a job match.\n*                                   So this is the first job that\n*                                   matched, if there are multiple\n*                                   jobs with the same name.\nFINDCSAS DS    0H                  Check the ASID in the CSCB.\n         CLC   ASIDBIN(2),CSCBASID Is this our ASID? Does it match.\n         BE    FINDCSFD            I guess we found it.\n         ICM   R3,15,0(R3)         Go to the next CSCB.\n         BZ    FINDCSEC            Zero marks the end of the CSCB chain\n         B     FINDCSLP            Not zero. Look at the next entry.\nFINDCSFD DS    0H                  Our CSCB has been found.\n         ST    R3,FOUNCSCB         Save found CSCB address.\n         MVC   FOUNACTF,CHACT      Save\n         MVC   SAVEACTF,CHACT      Save\n         MVC   SAVESTSF,CHSTS      Save\n         MVC   FOUNJOBI,CHKEY        CSCB\n         MVC   FOUNPROC,CHCLS          info.\n         MVC   FOUNASID,CHASID\n         MVC   SAVEASID,CHASID\n         BAL   R9,PRNTCSCB         Print info from the current CSCB.\n         TM    FLAG3,X'10'         COUNT only?\n         BO    FINDCSF1            Yes. Don't format CSCB begin.\n         BAL   R9,FORCHACT         Format some CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Put out an underline.\nFINDCSF1 DS    0H\n         B     FINDCSEN            Go to end of routine.\n         DROP  R3\nFINDCSEC DS    0H                  Came to end of CSCB chain.\n         APUT  MESSAGEN,L'MESSAGEN   Then put out a message\n         B     EOJ4                  And end with code 4.\nFINDCSEN DS    0H\n         L     R3,SAVER3A\n         L     R9,SAVER9D\n         BR    R9\n*            Constants associated with this routine.    -    below\nFOUNACTF DC    X'00'\nSAVEACTF DC    X'00'\nSAVESTSF DC    X'00'\nFOUNCSCB DS    F                   FOUND CSCB ADDRESS\nFOUNJOBI DC    CL8' '\nFOUNPROC DC    CL8' '\nFOUNASID DC    H'0'\nSAVEASID DC    H'0'\nCSCBACTF DC    X'00'\nCSCBJOBI DC    CL8' '\nCSCBPROC DC    CL8' '\nCSCBASID DC    H'0'\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\n**                 VALIDATE HEX CHARACTERS CODED                    **\n** ---------------------------------------------------------------- **\nVALIDTR  DS    0H                  Validate hex characters coded.\n         ST    R9,SAVER9E          Save\n         STM   R4,R6,SAVEWRK          registers.\n         LA    R4,ASIDMV           Point to translated display chars.\n         LA    R6,ASIDWKS          Point to chars with error signs.\n         LA    R5,4                BCT register - only 4 times.\nVALIDTRS DS    0H\n         CLI   0(R4),X'CC'         Is this an invalid character?\n         BE    VALIDTRR            Yes. Substitute a ? for message.\n         LA    R4,1(,R4)           Next translated character.\n         LA    R6,1(,R6)           Next char for error message.\n         BCT   R5,VALIDTRS         Loop to test validity of this char.\n         TM    ERRASID,X'01'       After 4 chars, any errors found?\n         BO    VALIDERR            Yes. Write messages.\n         B     VALIDTRE            No. Get out of routine.\nVALIDTRR DS    0H                  Come here if invalid char found.\n         OI    ERRASID,X'01'       Flag that at least one was found.\n         MVI   0(R6),C'?'          Substitute a ? for it in message.\n         LA    R4,1(,R4)           Next translated character.\n         LA    R6,1(,R6)           Next char in error message.\n         BCT   R5,VALIDTRS         Check that character for validity.\nVALIDERR DS    0H                  Error messages if char is invalid.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(37),ASIDBADM\n         APUT  OUTPUT,45\n*        MVC   OUTPUT,OUTPUT-1\n*        MVC   OUTPUT(51),MSGBADPR\n*        APUT  OUTPUT,52\n         B     EOJ4                Get out with code 4.\nVALIDTRE DS    0H\n         L     R4,SAVER4B          Restore regs used in this routine.\n         LM    R4,R6,SAVEWRK\n         BR    R9\n*            Constants associated with this routine.    -    below\nERRASID  DC    X'00'\nSAVEWRK  DS    3F\nMSGBADPR DC    C'Bad ASID entered. Use end parenthesis ) to delimit.'\nASIDBADM DC    CL33'Bad Characters marked with a ?:  '\nASIDWKS  DC    CL4' '\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\n**            PRINT SOME INFORMATION FROM A CSCB ENTRY              **\n** ---------------------------------------------------------------- **\n* -- -- -- -- -- -- -- --    USED BY THE COUNT FUNCTION    -- -- -- *\nPRNTJOBI DS    0H                  Print a CSCB entry.\n         ST    R9,SAVER9F          Save BAL register.\n         ST    R3,SAVECSCB         Saved found CSCB address.\n         L     R3,FOUNCSCB         Point to the current CSCB.\n         USING CHAIN,R3\n*                   Print info from current CSCB\n         MVC   OUTPUT,OUTPUT-1            Format some stuff from it.\n         MVC   OUTPUT(9),=C'Job  ID :'\n         MVC   OUTPUT+11(8),CHKEY\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Proc ID :'\n         MVC   OUTPUT+11(8),CHCLS\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'ASID    :'\n         HEX   OUTPUT+11,2,CHASID\n         APUT  OUTPUT,25\n         DROP  R3\nPRNTJOBF DS    0H                                                   BUR\n         L     R3,SAVECSCB         Restore register to what it was.\n         L     R9,SAVER9F          Restore BAL register and\n*                                     branch back to caller.        BUR\n         BR    R9\n** ---------------------------------------------------------------- **\n**            PRINT SOME INFORMATION FROM A CSCB ENTRY              **\n** ---------------------------------------------------------------- **\n* -- -- -- -- -- -- -- -- -- -- -- --    R3 points to a CSCB address\nPRNTCSCB DS    0H                  Print a CSCB entry.\n         ST    R9,SAVER9F          Save BAL register.\n         ST    R3,SAVECSCB         Saved found CSCB address.\n         TM    FLAG3,X'10'         COUNT display only?\n         BO    PRNTFINI            Yes. Don't do this routine.\n*                                  Use PRNTJOBI instead.\n         USING CHAIN,R3\n*                   Print info from current CSCB\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Job  ID :'\n         MVC   OUTPUT+11(8),CHKEY\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Proc ID :'\n         MVC   OUTPUT+11(8),CHCLS\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'ASID    :'\n         HEX   OUTPUT+11,2,CHASID\n         APUT  OUTPUT,25\n         TM    FLAG2,X'80'                Is this a BURN or KILL?   KIL\n         BO    PRNTFINI                   Yes. Abridge the messages BUR\n         TM    FLAG2,X'40'                CSCB only run. i.e. DISPLAY\n         BO    PRNTCSC1\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Previous CHACT Flags:'\n         HEX   OUTPUT+23,1,CHACT\n         APUT  OUTPUT,25\n         B     PRNTCSC2\nPRNTCSC1 DS    0H\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Current  CHSTS Flags:'\n         HEX   OUTPUT+23,1,CHSTS\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Current  CHACT Flags:'\n         HEX   OUTPUT+23,1,CHACT\n         APUT  OUTPUT,25\nPRNTCSC2 DS    0H\n         DROP  R3\nPRNTFINI DS    0H                                                   BUR\n         L     R3,SAVECSCB         Restore register to what it was.\n         L     R9,SAVER9F          Restore BAL register and\n*                                     branch back to caller.        BUR\n         BR    R9\nSAVECSCB DS    F                   Saved address of found CSCB.\n** ---------------------------------------------------------------- **\n**                  RUN THROUGH THE CSCB CHAIN                      **\n** ---------------------------------------------------------------- **\nRUNCSCB  DS    0H                  Run through the CSCB chain.\n         ST    R9,SAVER9G          Save work registers\n         ST    R3,SAVER3C\n         ST    R7,SAVER7A\nRUNCSCBT DS    0H\n         TM    FLAG2,X'40'         Only run if CSCB keyword was coded.\n         BZ    RUNCSCBE            Not coded, get out.\n*                                  Display this is a CSCB chain run.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(40),=C'This is a run of the CSCB Chain only ...'\n         APUT  OUTPUT,45\n         APUT  MESSAGEL,L'MESSAGEL   Print underline.\n*                                  Find the CSCB chain:\n         L     R3,16               CVT\n         L     R3,X'94'(,R3)       MSER - pointer to CSCB chain.\n         ICM   R3,15,0(R3)         First CSCB entry.\n         BZ    RUNCSCBE            If zero, end of CSCB chain.\n*                                  Otherwise points to next CSCB in\n*                                    the table.\n         USING CHAIN,R3\nRUNCSCBD DS    0H                  Loop through CSCB entries.\n         MVC   CSCBACTF(1),CHACT     Save CSCB ACT flag for this CSCB.\n         MVC   SAVEACTF(1),CHACT     Save CSCB ACT flag for this CSCB.\n         MVC   SAVESTSF(1),CHSTS     Save CSCB STS flag for this CSCB.\n         MVC   CSCBJOBI(8),CHKEY     Save CSCB JOBID (CHKEY).\n         MVC   CSCBPROC(8),CHCLS     Save CSCB PROC id (CHCLS).\n         MVC   CSCBASID(2),CHASID    Save CSCB ASID (CHASID).\n         MVC   SAVEASID(2),CHASID    Save CSCB ASID (CHASID).\n* -- Limit print of entries to Jobname or ASID only ----  below\n         CLI   JOBID,C'-'          Are we printing the whole CSCB?\n         BE    RUNCSCBY            Yes.\n         CLC   ASIDBIN,=X'0000'    Was an ASID coded for a search?\n         BNE   RUNCSCB2            No. Just check for Jobname.\nRUNCSCB1 DS    0H                  Check for Jobname match.\n         XR    R7,R7               Clear work register.\n         IC    R7,SAVCOUNT         Insert saved length of Jobid.\n         BCTR  R7,0                Decrement for execute.\n         EX    R7,RUNCSCOM         Do the compare for proper length.\n*        BNE   RUNCSCBS            Not equal, don't print result.\n         BE    RUNCSCBP            Equal, print this CSCB entry.\nRUNCSCB2 DS    0H                  Check if ASID was coded.\n         CLC   ASIDBIN,CHASID      ASID match?\n         BNE   RUNCSCBS            No. Skip print of CSCB entry.\nRUNCSCBY DS    0H\n* -- Limit print of entries to Jobname or ASID only ----  above\nRUNCSCBP DS    0H                  Print this entry....\n         BAL   R9,PRNTCSCB         Print of current CSCB information.\n         BAL   R9,FORCHACT         Format some CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline line.\nRUNCSCBS DS    0H                  If skipping an entry print, go here.\n         ICM   R3,15,0(R3)         Go to next CSCB entry in table.\n         BZ    RUNCSCBE            If it is zero, end of CSCB chain.\n         B     RUNCSCBD            Not zero, loop to next entry and\n*                                    print it.\nRUNCSCBE DS    0H                  End of routine.\n         L     R3,SAVER3C          Restore\n         L     R7,SAVER7A\n         L     R9,SAVER9G             registers and\n         BR    R9                        go back to caller.\nRUNCSCOM CLC   JOBID(*-*),CHKEY    Executed\n         DROP  R3\n** ---------------------------------------------------------------- **\n**           KEY 0 STUFF FOR THE CHACT FLAG BIT CHANGING            **\n** ---------------------------------------------------------------- **\nKEYZERO  DS    0H                  Into Key 0 and change CSCB cntl blk.\n         ST    R9,SAVER9H\n         ST    R4,SAVER4A\n*\n* -- >  Test if this command is being run APF Authorized - below\n         STM   R15,R1,SAVE14T1     Now save registers and test if APF\n         XR    R15,R15                  authorized.\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.\n* -- >  Test if this command is being run APF Authorized - above\n*\n* -- >    ***    Do as little as possible under Key 0.    ***\nKEYPRLIM DS    0H\n         TM    ONSWIT,X'01'        Are we OR-ing?\n         BZ    SWITOFF             No. Try AND-ing?\n         MVC   CANCKEY0,CANCINDC   Pre-process affecting bits.\n         B     SWITON              All done pre-processing.\nSWITOFF  DS    0H\n         TM    ONSWIT,X'02'        Are we AND-ing?\n         BZ    KEY0BYPS            No. Don't do anything else.\n         XC    CANCINDC,=X'FF'     Reverse the affected bits for AND.\n         MVC   CANCKEY0,CANCINDC   And move them to staging area.\nSWITON   DS    0H\n         USING CHAIN,R3\n         L     R3,FOUNCSCB         Save address of \"found CSCB\".\n*\n* -- >                             We're authorized. Go Key 0.\n         MODESET KEY=ZERO\n         TM    ONSWIT,X'01'        Are we OR-ing?\n         BZ    KEY0OFF             No. Try AND-ing.\n         OC    CHACT(1),CANCKEY0   Do the OR.\n         B     KEY0END             Out of Key 0.\nKEY0OFF  DS    0H\n         TM    ONSWIT,X'02'        Are we AND-ing?\n         BZ    KEY0END             No. Get out altogether.\n         NC    CHACT(1),CANCKEY0   Do the AND.\nKEY0END  DS    0H                  Out of Key 0.\n         MODESET KEY=NZERO\n*\nKEY0BYPS DS    0H                  Key 0 bypass - branch to here.\n         MVC   SAVEACTF(1),CHACT   Record for posterity\n         MVC   SAVESTSF(1),CHSTS   Record for posterity\n         DROP  R3\n         L     R4,SAVER4A\n         L     R9,SAVER9H\n         BR    R9\n** ---------------------------------------------------------------- **\n**             PRINT CSCB STUFF AFTER IT WAS CHANGED                **\n** ---------------------------------------------------------------- **\nPRNWCSCB DS    0H                  Print the changed CSCB entry.\n         ST    R9,SAVER9I          Save BAL register.\n         ST    R3,SAVER3D\n         L     R3,FOUNCSCB         Saved found CSCB address.\n         USING CHAIN,R3\n*                   Print info from changed CSCB.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Job  ID :'\n         MVC   OUTPUT+11(8),CHKEY\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Proc ID :'\n         MVC   OUTPUT+11(8),CHCLS\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'ASID    :'\n         HEX   OUTPUT+11,2,CHASID\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Modified CHACT Flags:'\n         HEX   OUTPUT+23,1,CHACT\n         APUT  OUTPUT,25\n         APUT  MESSAGEL,L'MESSAGEL\n         DROP  R3\n         L     R3,SAVER3D          Restore register to what it was.\n         L     R9,SAVER9I          Restore BAL register and\n         BR    R9                     branch back to caller.\n** ---------------------------------------------------------------- **\n**             REPORT - Format the CHACT Flags - REPORT             **\n** ---------------------------------------------------------------- **\nFORCHACT DS    0H                  SAVEACTF less volatile than CHACT.\n         ST    R9,SAVER9J          Save\n         ST    R3,SAVER3E             registers.\n         USING CHAIN,R3\nFORCANC0 DS    0H                  Show cancelable or not.\n         TM    SAVEACTF,CHCL       Is job cancelable?\n         BO    FORCANC1            Yes, show cancelable.\n         BZ    FORCANC2            No. Show non-cancelable.\n         B     FORFORC0            Fall through, try forceable.\nFORCANC1 DS    0H\n         MVC   MESSTXT,MESSCAN     Tell em job is cancelable.\n         B     FORCANCP\nFORCANC2 DS    0H\n         MVC   MESSTXT,MESSNCN     Tell em job is non-cancelable.\nFORCANCP DS    0H                  Write the actual message out.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(28),FORMTMSG\n         APUT  OUTPUT,30\nFORFORC0 DS    0H                  Show forceable or not.\n         TM    SAVEACTF,CHAFORCE   Can you do FORCE w/o CANCEL?\n         BO    FORFORC1            Yes. Don't need CANCEL first.\n         BZ    FORFORC2            No. Show you need CANCEL first.\nFORFORC1 DS    0H\n         MVC   MESSTXT,MESSFOR     Tell em FORCE ok w/o CANCEL.\n         B     FORFORCP\nFORFORC2 DS    0H\n         MVC   MESSTXT,MESSNFR     Tell em need CANCEL before FORCE.\nFORFORCP DS    0H                  Write the actual message out.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(28),FORMTMSG\n         APUT  OUTPUT,30\nFORSWAP0 DS    0H                  Show non-swappable or swappable.\n         TM    SAVEACTF,CHSWAP     Test bit.\n         BO    FORSWAP1            On, show non-swappable.\n         BZ    FORSWAP2            Off, show swappable.\n         B     FORKILLF            Safety net. Branch not taken.\nFORSWAP1 DS    0H\n         MVC   MESSTXT,MESSSWP     Show swappable\n         B     FORSWAPP\nFORSWAP2 DS    0H\n         MVC   MESSTXT,MESSNSW     Show non-swappable\nFORSWAPP DS    0H                  Print message.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(28),FORMTMSG\n         APUT  OUTPUT,30\nFORKILLF DS    0H                  Figure out if Non-Memtermable or not\n         ST    R4,SAVER4D          Save work register\nFORKILLX MVC   FOUNASID,SAVEASID   Stage ASID for GETASCB routine.\nFORKILLY DS    0H\n         BAL   R9,GETASCB          Get the ASCB.\n         LTR   R15,R15             Is there one?\n         BZ    FORCHEND            No. Exit this routine.\n         ST    R15,SAVEASCB        Save address of ASCB.\n         L     R4,SAVEASCB         Reload address of ASCB in work reg.\n         L     R4,0(,R4)           Get actual ASCB into register.\n         USING ASCB,R4\n         TM    ASCBFLG2,ASCBNOMT   Test if Non-Memtermable bit is on.\n         BZ    FOROMEMT            No. Report that it's off.\n         MVC   MESSTXT,MESSNMT     Yes. Put Non-Memtermable into msg.\n         B     FORKILLO            And put out the message.\nFOROMEMT DS    0H\n         MVC   MESSTXT,MESSMMT     No. Put Memtermable into message.\nFORKILLO MVC   OUTPUT,OUTPUT-1     And put out the message.\n         MVC   OUTPUT(28),FORMTMSG\n         APUT  OUTPUT,30\n         L     R4,SAVER4D          Restore work register.\n         DROP  R4                  Lose ASCB addressability.\nFORCHEND DS    0H\n         DROP  R3\n         L     R3,SAVER3E          Restore\n         L     R9,SAVER9J             registers.\n         BR    R9\n*            Constants associated with this routine.    -    below\nMESSCAN  DC    CL15'Cancelable     '\nMESSNCN  DC    CL15'Non-Cancelable '\nMESSSWP  DC    CL15'Swappable      '\nMESSNSW  DC    CL15'Non-Swappable  '\nMESSFOR  DC    CL15'Force w/o Cncel'\nMESSNFR  DC    CL15'Cancel + Force '\nMESSNMT  DC    CL15'Non-Memtermable'\nMESSMMT  DC    CL15'Memtermable    '\nFORMTMSG DS    0CL28\nMESS000  DC    CL13'Job Status:  '\nMESSTXT  DC    CL15'               '\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\n**        HELP MESSAGES TO BE ABLE TO FIX THE PARMS AND STUFF       **\n** ---------------------------------------------------------------- **\nPRINTERR DS    0H                    Print help messages.\n         ST    R9,SAVER9K            Save BAL register.\n         APUT  MESSAGAL,L'MESSAGAL\n         APUT  MESSAG2A,L'MESSAG2A\n         APUT  MESSAG2B,L'MESSAG2B\n         APUT  MESSAG2V,L'MESSAG2V\n         APUT  MESSAG2Y,L'MESSAG2Y\n         APUT  MESSAG2W,L'MESSAG2W\n         APUT  MESSAG2U,L'MESSAG2U\n         APUT  MESSAG2C,L'MESSAG2C\n         APUT  MESSAG2D,L'MESSAG2D\n         APUT  MESSAGEM,L'MESSAGEM\n         APUT  MESSAG2E,L'MESSAG2E\n         APUT  MESSAG2F,L'MESSAG2F\n         APUT  MESSAGEM,L'MESSAGEM\n         APUT  MESSAG2G,L'MESSAG2G\n         APUT  MESSAG2H,L'MESSAG2H\n         APUT  MESSAGEM,L'MESSAGEM\n         APUT  MESSAG2I,L'MESSAG2I\n         APUT  MESSAGEM,L'MESSAGEM\n         APUT  MESSAG2J,L'MESSAG2J\n         APUT  MESSAG2K,L'MESSAG2K\n         APUT  MESSAG2L,L'MESSAG2L\n         APUT  MESSAG2M,L'MESSAG2M\n         APUT  MESSAG2N,L'MESSAG2N\n         APUT  MESSAG2O,L'MESSAG2O\n         APUT  MESSAG2P,L'MESSAG2P\n         APUT  MESSAG2Q,L'MESSAG2Q\n         APUT  MESSAG2R,L'MESSAG2R\n         APUT  MESSAG2S,L'MESSAG2S\n         APUT  MESSAG2T,L'MESSAG2T\n         APUT  MESSAGEM,L'MESSAGEM\n         APUT  MESSAGAL,L'MESSAGAL\n         L     R9,SAVER9K            Restore BAL register.\n         BR    R9\n** ----------------------------------------------------------------- **\n*        Control of the following routines are under control of       *\n*           the KILLFLAG, and are not under control of FLAG2.         *\n*                                                                     *\n*        KILLFLAG controls processes KILL, BURN, NMEM and MEMT.       *\n*              (Routine must set FLAG2 EQU X'80')                     *\n*  ------------------------------------------------------------------ *\n*                   Settings of the KILLFLAG                          *\n*                                                                     *\n*  KILLFLAG  equals  X'01'            for KILL (whack always)         *\n*                    X'01' and X'02'  for BURN (whack only if MEMT)   *\n*                    X'04'            for NMEM (make NON-memtermable) *\n*                    X'08'            for MEMT (make memtermable)     *\n*                                                                     *\n** ----------------------------------------------------------------- **\nDONMEM   DS    0H                        NON-MEMTERMABLE   FLAG X'04'\n         NI    KILLFLAG,X'04'            ONLY NMEM FLAG ON. Others off\n         OI    KILLFLAG,X'04'            TURN NMEM FLAG ON\n         B     FLGSDONE\nDOMEMT   DS    0H                        MEMTERMABLE       FLAG X'08'\n         NI    KILLFLAG,X'08'            ONLY MEMT FLAG ON  Others off\n         OI    KILLFLAG,X'08'            TURN MEMT FLAG ON\n         B     FLGSDONE\nDOBURN   DS    0H                        BURN. X'02' and X'01' both on\n         OI    KILLFLAG,X'02'            Announce BURN as keyword\nDOKILL   DS    0H                        KILL process. KILL flag on.\n         OI    KILLFLAG,X'01'            Announce KILL as keyword\nFLGSDONE DS    0H                        Flags have been set.\n         TM    FLAG0,X'40'               Have PSCB ACCT authority?\n         BZ    NOTALLOW                  No. Can't do these commands.\n*  ------------------------------------------------------------------ *\n*                    Print the action code for                        *\n*                    everything under FLAG2=X'80'                     *\n*  ------------------------------------------------------------------ *\n         OI    FLAG2,X'80'               Mark under KILLFLAG control.\n*  ------------------------------------------------------------------ *\n         MVC   OUTPUT,OUTPUT-1           Print message accordingly\n         MVC   OUTPUT(15),=C'Action code   :'\nTRYBURN  TM    KILLFLAG,X'02'            For BURN, X'01' and X'02' on.\n         BZ    TRYKILL\n         MVC   OUTPUT+17(4),BURNC        Mark as a BURN.\n         B     PRTCODE\nTRYKILL  TM    KILLFLAG,X'01'\n         BZ    TRYNMEM\n         MVC   OUTPUT+17(4),KILLC        Mark as a KILL.\n         B     PRTCODE\nTRYNMEM  TM    KILLFLAG,X'04'\n         BZ    TRYMEMT\n         MVC   OUTPUT+17(4),NMEMC        Mark as a NMEM.\n         B     PRTCODE\nTRYMEMT  TM    KILLFLAG,X'08'\n         BZ    PRTCODE\n         MVC   OUTPUT+17(4),MEMTC        Mark as a MEMT.\nPRTCODE  DS     0H                       And print the result.\n         APUT  OUTPUT,25\n*  ------------------------------------------------------------------ *\n* -- >  Test if this command is being run APF Authorized - below    BUR\n*  ------------------------------------------------------------------ *\nTAUTH    STM   R15,R1,SAVE14T1   Now save registers and test if APF BUR\n         XR    R15,R15                authorized.                   BUR\n         TESTAUTH FCTN=1           Are we authorized?               BUR\n         LTR   R15,R15             Test the return code.            BUR\n         BNZ   NOTAUTH           Not zero, tell not authorized.     BUR\n         LM    R15,R1,SAVE14T1   Restore registers used by TESTAUTH BUR\n*  ------------------------------------------------------------------ *\n* -- >  Test if this command is being run APF Authorized - above    BUR\n*  ------------------------------------------------------------------ *\n         BAL   R9,FINDCSCB               Get correct CSCB entry.    BUR\n         MODESET KEY=ZERO,MODE=SUP                                  BUR\n         ST    R7,SAVER7B                Store work register        BUR\n         LH    R7,CSCBASID               Set ASID                   BUR\n         TM    KILLFLAG,X'0C'            NMEM or MEMT action?\n         BNZ   ASCBBITS                  If either, then not KILL\n*----->               KILL routine - below                          KIL\n         TM    KILLFLAG,X'01'            Is the KILL flag on?       KIL\n         BZ    SKIPMEMT                  No. Exit this routine.     KIL\nASCBBITS DS    0H\n         CLC   CSCBASID,=X'0000'         Did FINDCSCB find a CSCB?  KIL\n         BE    SKIPMEMT                  No. Exit this routine.     KIL\n         MVC   FOUNASID,CSCBASID         Stage ASID to get the ASCB KIL\n         BAL   R9,GETASCB                Get the ASCB.              KIL\n         LTR   R15,R15                   Is there one?              KIL\n         BZ    SKIPMEMT                  No. Exit this routine.     KIL\n         ST    R15,SAVEASCB              Save address of ASCB.      KIL\n         L     R15,0(,R15)               Load it to address fields. KIL\n         USING ASCB,R15                                             KIL\n         TM    KILLFLAG,X'08'            MEMT?\n         BO    FORCEOFF\n         TM    KILLFLAG,X'04'            NMEM?\n         BO    FORCEON\n         TM    KILLFLAG,X'02'            BURN only?                 BUR\n         BO    EXITKILL                  Non-forcible still on.     BUR\n         TM    KILLFLAG,X'01'            If not X'01' then no MEMTERM.\n         BZ    SKIPMEMT                  Yes. Turn off ASCB bits first.\n         NI    ASCBFLG2,255-ASCBNOMT     Turn off NON-FORCIBLE bit  KIL\n         NI    ASCBFLG2,255-ASCBNOMD     Turn off Dat error bit     KIL\n         B     EXITKILL                  Go do MEMTERM.\nFORCEOFF NI    ASCBFLG2,255-ASCBNOMT     Turn off NON-FORCIBLE bit\n         NI    ASCBFLG2,255-ASCBNOMD     Turn off Dat error bit\n         B     SKIPMEMT                  And skip MEMTERM.\nFORCEON  DS    0H                        Make Non-Memtermable.\n         OI    ASCBFLG2,ASCBNOMT         Put the ASCBNOMT bit on.\n         ST    R3,SAVER3F                Then\n         L     R3,FOUNCSCB                  Make\n         USING CHAIN,R3                        Job\n         NI    CHACT,255-X'08'                    Non-Cancelable too.\n         MVC   SAVEACTF(1),CHACT         Save for reporting\n         L     R3,SAVER3F                Restore work register.\n         B     SKIPMEMT                  Don't do CALLRTM MEMTERM.\n         DROP  R3\nEXITKILL DS    0H                        Now do CALLRTM MEMTERM.    KIL\n         DROP  R15                       Drop ASCB addressability   KIL\n*----->               KILL routine - above                          KIL\n         ST    R13,SAVER13A              Save R13                   BUR\n         LA    R13,RTMSAVE               RTM save area              BUR\n         CALLRTM TYPE=MEMTERM,ASID=(R7),COMPCOD=100                 BUR\n         STC   R15,RTMCOD                Save MEMTERM Return Code\n         L     R13,SAVER13A              Restore R13                BUR\nSKIPMEMT DS    0H\n         L     R7,SAVER7B                Restore work register      BUR\n         MODESET KEY=NZERO,MODE=PROB                                BUR\n         CLI   RTMCOD,X'2C'              Non-memtermable addr space?\n         BE    NOTMEMTM                  Yes. Issue message to say so.\n*\n         TM    KILLFLAG,X'04'            Message if NMEM done.\n         BZ    TRYMMEMT\n         MVC   MESSAGM1+4(8),FOUNJOBI    Jobname into message       BUR\n         HEX   MESSAGM1+22,2,FOUNASID    ASID into message          BUR\n         APUT  MESSAGM1,L'MESSAGM1       Say job made non-memtermable\n         B     BURNEND                   Done with message\nTRYMMEMT DS    0H\n         TM    KILLFLAG,X'08'\n         BZ    TRYMBURN\n         MVC   MESSAGM2+4(8),FOUNJOBI    Jobname into message       BUR\n         HEX   MESSAGM2+22,2,FOUNASID    ASID into message          BUR\n         APUT  MESSAGM2,L'MESSAGM2       Say job was killed.        BUR\n         B     BURNEND                   Done with message          KIL\nTRYMBURN TM    KILLFLAG,X'02'            KILL msg instead of BURN?  KIL\n         BO    BURNMSG                   Yes. Run BURN message.     KIL\n         MVC   MESSAGKI+4(8),FOUNJOBI    Jobname into message       BUR\n         HEX   MESSAGKI+22,2,FOUNASID    ASID into message          BUR\n         APUT  MESSAGKI,L'MESSAGKI       Say job was killed.        BUR\n         B     BURNEND                   Skip BURN message          KIL\nBURNMSG  DS    0H\n         MVC   MESSAGBU+4(8),FOUNJOBI    Jobname into message       KIL\n         HEX   MESSAGBU+22,2,FOUNASID    ASID into message          KIL\n         APUT  MESSAGBU,L'MESSAGBU       Say job was burned.        KIL\nBURNEND  DS    0H\n         B     GETIDEND            After enough looks, end.         KIL\nRTMSAVE  DS    CL72                Work area for RTM                BUR\nSAVER13A DS    F                   Place to save R13                BUR\nSAVEASCB DS    F                   Save ASCB address                KIL\n** ---------------------------------------------------------------- **\n**            SETUP FOR KEY 0 SWAP-RELATED FUNCTIONS                **\n** ---------------------------------------------------------------- **\nKEY0SWNS DS    0H                    Key 0 for SWAP or NSWP or TSWP\n         ST    R9,SAVER9L            Save BAL register.\n         ST    R6,SAVER6A            Save work register.\nKEY0TSTA DS    0H\n* -- >  Test if this command is being run APF Authorized - below\n         STM   R15,R1,SAVE14T1     Now save registers and test if APF\n         XR    R15,R15                  authorized.\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.\n* -- >  Test if this command is being run APF Authorized - above\n*   COUNT is keyed off here also, besides SWAP, NSWP and TSWP.\n         TM    FLAG2,X'04'         Make ASID swappable?\n         BO    KEY0SWAP            Yes. Do it.\n         TM    FLAG2,X'08'         Make ASID non-swappable?\n         BO    KEY0NSWP            Yes. Do it.\n         TM    FLAG3,X'10'         If COUNT only, then BUILDSRB and\n         BO    KEY0DONS             SWAPXMEM will only get KEY0NDS.\n*                                   No SYSEVENTs will be done there.\n         B     KEY0EXIT            Not SWAP or NSWP, or COUNT, then\n*                                   we don't belong here.\n** ---------------------------------------------------------------- **\n*       M A K E   A D D R E S S   N O N S W A P P A B L E            *\n** ---------------------------------------------------------------- **\nKEY0NSWP DS    0H                    Make address space non-swappable.\n*\n         CLC   OWNASID,FOUNASID    Target ASID different from ours?\n         BE    KEY0DNSW            No. Just do SYSEVENT in this adrspc\n         TM    FLAG3,X'10'         COUNT only,\n         BO    KEY0DONS              skip the actions.\n         TM    FLAG3,X'01'           Was TRANSWAP asked for?\n         BO    KEY0TSWP              Yes. Go set it.\n         MVC   FUNC,=CL8'DONTSWAP'   Set DONTSWAP function          JOE\n         B     KEY0DONS              Go set up SRB and SYSEVENT stuff\nKEY0TSWP DS    0H\n         MVC   FUNC,=CL8'TRANSWAP'   Set TRANSWAP function\nKEY0DONS DS    0H\n         BAL   R9,BUILDSRB           Build SRB block                JOE\n* -----\n*                                                                   JOE\n* ISSUE SUCCESSFUL MESSAGE                                          JOE\n*                                                                   JOE\n* -----\n**** ------ >>>>     TEST TEST     See if we are getting good values\n*        STM   R14,R1,SAVE14W1       from the SRB.\n*        MVC   OUTPUT,OUTPUT-1\n*        HEX   OUTPUT+4,1,KEY0SFLI\n*        HEX   OUTPUT+14,1,KEY0SFLO\n*        HEX   OUTPUT+24,1,KEY0SFL\n*        MVC   OUTPUT+34(3),=C'NSW'\n*        APUT  OUTPUT,50\n*        LM    R14,R1,SAVE14W1\n**** ------ >>>>\n         TM    FLAG3,X'10'           COUNT only?\n         BO    KEY0NOM1              Skip. SYSEVENT not relevant.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(L'MESSAGNH),MESSAGNH   Print SYSEVENT code\n         HEX   OUTPUT+29,1,SYSEVCOD+3\n         APUT  OUTPUT,50\nKEY0NOM1 DS    0H\n         TM    FLAG3,X'10'           COUNT only?\n         BO    KEY0NOM2\n* -----\n         MODESET MODE=SUP,KEY=ZERO\n*                            ADJUST CSCB FLAG FOR NON-SWAPPABLE\n         ST    R3,SAVER3G\n         L     R3,FOUNCSCB           Saved found CSCB address.\n         USING CHAIN,R3\n         NI    CHACT,X'7F'           Turn off swappable bit.\n         L     R3,SAVER3G\n         DROP  R3\n         MODESET MODE=PROB,KEY=NZERO\nKEY0NOM2 DS    0H\n* ----- >           Find OUCBNDS Count        < ----- *     below\n         TM    FLAG3,X'01'               TRANSWAP ?\n         BO    KEY0NFAK                  Display appropriately.\n         MVC   OUTPUT,OUTPUT-1           Display DONTSWAP count\n         MVC   OUTPUT+2(32),=C'Outstanding DONTSWAP requests:  '\n         HEX   OUTPUT+35,2,KEY0NDS   Number was gotten from the SRB.\n         APUT  OUTPUT,50\n         TM    FLAG3,X'10'           COUNT only?\n         BO    KEY0RPTS              Yes. Skip all the nswp stuff.\nKEY0NFAK DS    0H\n**--->>\n         TM    KEY0SFLO,X'01'        Is addrspc non-swappable now?\n         BZ    KEY0RPTS              No. We don't belong here.\n         CLC   KEY0SFLO,KEY0SFLI     Have we changed status?\n         BNE   KEY0MCH0                  Yes. Don't do this message.\n         MVC   MESSAGAN+4(8),FOUNJOBI    Already nonswappable msg\n         HEX   MESSAGAN+22,2,FOUNASID\n         APUT  MESSAGAN,L'MESSAGAN\n         B     KEY0RPTS\nKEY0MCH0 DS    0H\n**--->>\n* ----- >           Find OUCBNDS Count        < ----- *     above\n         TM    FLAG3,X'01'               Different msgs for TSWP, NSWP\n         BZ    KEY0RPNS\n         MVC   MESSAGTS+4(8),FOUNJOBI    TRANSWAP messages\n         HEX   MESSAGTS+22,2,FOUNASID\n         APUT  MESSAGTS,L'MESSAGTS\n         B     KEY0RPTS\nKEY0RPNS DS    0H\n         MVC   MESSAGNS+4(8),FOUNJOBI    DONTSWAP messages          JOE\n         HEX   MESSAGNS+22,2,FOUNASID                               JOE\n         APUT  MESSAGNS,L'MESSAGNS                                  JOE\nKEY0RPTS DS    0H\n         L     R6,SAVER6A            Restore Register               JOE\n         L     R9,SAVER9L            Restore BAL register.          JOE\n         BR    R9                    go back                        JOE\nTEMPSAVE DS    4F                    save area                      JOE\n* ---------------------------------------------------------------- *\n*           NONSWAPPABLE ACTIONS FOR OUR ADDRESS SPACE             *\n* ---------------------------------------------------------------- *\nKEY0DNSW DS    0H                    Action for our address space\n         MODESET MODE=SUP,KEY=ZERO\n         BAL   R9,GETSWST\n         MVC   KEY0SFLI(1),NSWFLG\nKEY0SYSD DS    0H\n         TM    FLAG3,X'10'           COUNT only?\n         BO    KEY0DISN              Skip the SYSEVENT stuff.\n         LH    R6,FOUNASID           Load your own ASID.\n         TM    FLAG3,X'01'           TSWP instead of NSWP?\n         BO    KEY0SYST              Yes. Do TRANSWAP function.\n         SYSEVENT DONTSWAP,ASID=(R6),ENTRY=SVC\n         ST    R1,SYSEVCOD           Return code from SYSEVENT.\n         B     KEY0NNRM              No.  Do DONTSWAP function.\nKEY0SYST SYSEVENT TRANSWAP,ASID=(R6),ENTRY=SVC\n         ST    R1,SYSEVCOD           Return code from SYSEVENT.\n*                            ADJUST CSCB FLAG FOR NON-SWAPPABLE\n         ST    R3,SAVER3G\n         L     R3,FOUNCSCB               Saved found CSCB address.\n         USING CHAIN,R3\n         NI    CHACT,X'7F'               Turn off swappable bit.\n         L     R3,SAVER3G\n         DROP  R3\n* -----\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(L'MESSAGNH),MESSAGNH    Print SYSEVENT code.\n         HEX   OUTPUT+29,1,SYSEVCOD+3\n         APUT  OUTPUT,50\n* -----\nKEY0NNRM DS    0H                    Display the results.\n*                            ADJUST CSCB FLAG FOR NON-SWAPPABLE\n         ST    R3,SAVER3G\n         L     R3,FOUNCSCB               Saved found CSCB address.\n         USING CHAIN,R3\n         NI    CHACT,X'7F'               Turn off swappable bit.\n         L     R3,SAVER3G\n         DROP  R3\n* -----\nKEY0DISN DS    0H\n* ----- >           Find OUCBNDS Count        < ----- *     below\n         ST    R3,SAVER3H\n         L     R2,X'224'                 ASCB\n         L     R2,X'90'(,R2)             ASCBOUCB\n         LA    R2,X'88'(,R2)             OUCBNDS (Count Field)\n         LA    R3,X'11'(,R2)             OUCBSFL\n         MVC   KEY0NDS(2),0(R2)          Move count to display field.\n         MVC   KEY0SFL(1),0(R3)          Move field of flags.\n         TM    FLAG3,X'01'               TSWP ?\n         BO    KEY0NMS1                  Yes. Bypass extra message.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT+2(32),=C'Outstanding DONTSWAP requests:  '\n         HEX   OUTPUT+35,2,KEY0NDS       Display the number found.\n         APUT  OUTPUT,50\n         L     R3,SAVER3H\nKEY0NMS1 DS    0H\n         BAL   R9,GETSWST\n         MVC   KEY0SFLO(1),NSWFLG\n* ----- >           Find OUCBNDS Count        < ----- *     below\n         MODESET MODE=PROB,KEY=NZERO\n         TM    FLAG3,X'10'               Count only?\n         BO    KEY0EXIT                  Yes. Nothing to do with nswps.\n         TM    KEY0SFLO,X'01'\n         BZ    KEY0MCH1\n         CLC   KEY0SFLO,KEY0SFLI\n         BNE   KEY0MCH1\n         MVC   MESSAGAN+4(8),FOUNJOBI    Already nonswappable msg\n         HEX   MESSAGAN+22,2,FOUNASID\n         APUT  MESSAGAN,L'MESSAGAN\n         B     KEY0EXIT\nKEY0MCH1 DS    0H\n         TM    FLAG3,X'01'\n         BZ    KEY0METS\n         MVC   MESSAGTS+4(8),FOUNJOBI    TRANSWAP message\n         HEX   MESSAGTS+22,2,FOUNASID\n         APUT  MESSAGTS,L'MESSAGTS\n         B     KEY0EXIT\nKEY0METS DS    0H\n         MVC   MESSAGNS+4(8),FOUNJOBI    DONTSWAP message\n         HEX   MESSAGNS+22,2,FOUNASID                               JOE\n         APUT  MESSAGNS,L'MESSAGNS\n         B     KEY0EXIT\n** ---------------------------------------------------------------- **\n*           M A K E   A D D R E S S   S W A P P A B L E              *\n** ---------------------------------------------------------------- **\nKEY0SWAP DS    0H                    Make address space swappable.\n         CLC   OWNASID,FOUNASID      Target asid different from ours?\n         BE    KEY0DSWP              No. Just do SYSEVENT.\n         TM    FLAG3,X'10'           COUNT option only?\n         BO    KEY0BILD              Yes. Just get value from SRB.\n         MVC   FUNC,=CL8'OKSWAP'     Set function                   JOE\nKEY0BILD DS    0H\n         BAL   R9,BUILDSRB           Build SRB CSA CONTROL BLOCKS   JOE\n*                                                                   JOE\n*  ISSUE SUCCESSFUL MESSAGE                                         JOE\n*                                                                   JOE\n**** ------ >>>>     TEST TEST     See if we are getting good values\n*        STM   R14,R1,SAVE14W1       from the SRB.\n*        MVC   OUTPUT,OUTPUT-1\n*        HEX   OUTPUT+4,1,KEY0SFLI\n*        HEX   OUTPUT+14,1,KEY0SFLO\n*        HEX   OUTPUT+24,1,KEY0SFL\n*        MVC   OUTPUT+34(3),=C'SWP'\n*        APUT  OUTPUT,50\n*        LM    R14,R1,SAVE14W1\n**** ------ >>>>\n* ----- >                         Display outstanding DONTSWAP count\n         MVC   OUTPUT,OUTPUT-1       and show still non-swappable\n         MVC   OUTPUT+2(32),=C'Outstanding DONTSWAP requests:  '\n         HEX   OUTPUT+35,2,KEY0NDS   DONTSWAP count in display\n         APUT  OUTPUT,50\n         CLC   KEY0NDS,=X'0000'   Positive DONTSWAP count?  Yes?\n         BNH   KEY0NOMX           Display instructional message.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT+2(32),=C'Run SWAP again until count is 0.'\n         APUT  OUTPUT,50\n         MVC   MESSAGSY+6(8),FOUNJOBI    Show job not done yet.\n         HEX   MESSAGSY+24,2,FOUNASID\n         APUT  MESSAGSY,L'MESSAGSY\n         TM    FLAG3,X'10'        For COUNT, don't mess with CHACT.\n         BO    KEY0NOMQ\n         MODESET MODE=SUP,KEY=ZERO\n*                            ADJUST CSCB FLAG FOR NON-SWAPPABLE\n*                            BECAUSE OF POSITIVE DONTSWAP COUNT > 1.\n         ST    R3,SAVER3G\n         L     R3,FOUNCSCB           Saved found CSCB address.\n         USING CHAIN,R3\n         NI    CHACT,X'7F'           Turn off swappable bit.\n         L     R3,SAVER3G\n         MODESET MODE=PROB,KEY=NZERO\nKEY0NOMQ DS    0H\n         B     KEY0SNDN\n         DROP  R3\n* -----\n         TM    FLAG3,X'01'               Different msgs for TSWP, NSWP\n         BO    KEY0SNDN\nKEY0NOMX DS    0H          BRANCH HERE IF ADDRESS SPACE MADE SWAPPABLE.\n* ----- >                             Display job is now swappable\n         TM    KEY0SFLO,X'01'         Is the job non-swappable now?\n         BO    KEY0SNDN               Yes. We don't belong here.\n         CLC   KEY0SFLO,KEY0SFLI      Has its status changed?\n         BNE   KEY0SDNE               Yes. Say we changed it.\n         MVC   MESSAGAS+4(8),FOUNJOBI    No. Say already swappable.\n         HEX   MESSAGAS+22,2,FOUNASID\n         APUT  MESSAGAS,L'MESSAGAS\n         B     KEY0SNZ1\n*\n         TM    FLAG3,X'10'           For COUNT, don't mess with CHACT.\n         BO    KEY0SNZ1\nKEY0SDNE DS    0H\n         MVC   MESSAGSW+4(8),FOUNJOBI                               JOE\n         HEX   MESSAGSW+22,2,FOUNASID                               JOE\n         APUT  MESSAGSW,L'MESSAGSW                                  JOE\nKEY0SNZ1 DS    0H\n         TM    FLAG3,X'10'           For COUNT, don't mess with CHACT.\n         BO    KEY0SNDN\n         MODESET MODE=SUP,KEY=ZERO\n*                                 ADJUST CSCB FLAG FOR SWAPPABLE\n         ST    R3,SAVER3G\n         L     R3,FOUNCSCB           Saved found CSCB address.\n         USING CHAIN,R3\n         OI    CHACT,X'80'           Turn on swappable bit.\n         L     R3,SAVER3G\n         MODESET MODE=PROB,KEY=NZERO\n         DROP  R3\nKEY0SNDN L     R6,SAVER6A            Restore Registers              JOE\n         L     R9,SAVER9L            Restore BAL register.          JOE\n         BR    R9                                                   JOE\n* ---------------------------------------------------------------- *\n*            SWAPPABLE ACTIONS FOR OUR ADDRESS SPACE               *\n* ---------------------------------------------------------------- *\nKEY0DSWP DS    0H\n         LH    R6,FOUNASID\n* ---- >          FSWP code below\n         MODESET MODE=SUP,KEY=ZERO\n         BAL   R9,GETSWST\n         MVC   KEY0SFLI(1),NSWFLG\n         TM    FLAG3,X'02'\n         BZ    KEY0DSNF\n         L     R2,X'224'                 ASCB\n         L     R2,X'90'(,R2)             ASCBOUCB\n         LA    R2,X'88'(,R2)             OUCBNDS (Count Field)\n         MVC   0(2,R2),=X'0001'          Set DONTSWAP count to 1\nKEY0DSNF DS    0H\n* ---- >          FSWP code above\n         SYSEVENT OKSWAP,ASID=(R6),ENTRY=SVC\n         ST    R1,SYSEVCOD           Return code from SYSEVENT.\nKEY0SNRM DS    0H\n* ----- >           Find OUCBNDS Count        < ----- *     below\n         ST    R3,SAVER3H\n         L     R2,X'224'                 ASCB\n         L     R2,X'90'(,R2)             ASCBOUCB\n         LA    R2,X'88'(,R2)             OUCBNDS (Count Field)\n         LA    R3,X'11'(,R2)             OUCBSFL\n         MVC   KEY0NDS(2),0(R2)          Move to staging area.\n         MVC   KEY0SFL(1),0(R3)          Move field of flags.\n         MVC   OUTPUT,OUTPUT-1           Display DONTSWAP count.\n         MVC   OUTPUT+2(32),=C'Outstanding DONTSWAP requests:  '\n         HEX   OUTPUT+35,2,KEY0NDS\n         APUT  OUTPUT,50\n         L     R3,SAVER3H\n* ----- >           Find OUCBNDS Count        < ----- *     above\n*                                 ADJUST CSCB FLAG FOR SWAPPABLE\n         TM    FLAG3,X'10'           For COUNT, don't mess with CHACT.\n         BO    KEY0SNRN\n         ST    R3,SAVER3G\n         L     R3,FOUNCSCB           Saved found CSCB address.\n         USING CHAIN,R3\n         OI    CHACT,X'80'           Turn on swappable bit.\n         L     R3,SAVER3G\n         DROP  R3\nKEY0SNRN DS    0H\n         BAL   R9,GETSWST\n         MVC   KEY0SFLO(1),NSWFLG\n*\n         MODESET MODE=PROB,KEY=NZERO\n         TM    KEY0SFLO,X'01'\n         BO    KEY0SNCH\n         CLC   KEY0SFLO,KEY0SFLI\n         BNE   KEY0SNCH\n         MVC   MESSAGAS+4(8),FOUNJOBI    Yes. Display that it's done.\n         HEX   MESSAGAS+22,2,FOUNASID\n         APUT  MESSAGAS,L'MESSAGAS\n         B     KEY0EXIT\nKEY0SNCH DS    0H\n         CLC   KEY0NDS(2),=X'0001'       DONTSWAP count low enough?\n         BNL   KEY0NODO                  No. Tell em \"no can do\".\n         MVC   MESSAGSW+4(8),FOUNJOBI    Yes. Display that it's done.\n         HEX   MESSAGSW+22,2,FOUNASID                               JOE\n         APUT  MESSAGSW,L'MESSAGSW\n         B     KEY0EXIT                  Finished with this routine.\nKEY0NODO DS    0H                        DONTSWAP count too high.\n         TM    FLAG3,X'10'           For COUNT, don't mess with CHACT.\n         BO    KEY0NODP\n         MODESET MODE=SUP,KEY=ZERO\n*                               ADJUST CSCB FLAG FOR NON-SWAPPABLE\n         ST    R3,SAVER3G\n         L     R3,FOUNCSCB           Saved found CSCB address.\n         USING CHAIN,R3\n         NI    CHACT,X'7F'           Turn off swappable bit.\n         L     R3,SAVER3G\n         DROP  R3\n*\n         MODESET MODE=PROB,KEY=NZERO\nKEY0NODP DS    0H\n         MVC   OUTPUT,OUTPUT-1           Display \"no can do\" message\n         MVC   MESSAGSY+6(8),FOUNJOBI\n         HEX   MESSAGSY+24,2,FOUNASID\n         APUT  MESSAGSY,L'MESSAGSY\n         MVC   OUTPUT,OUTPUT-1           Display instructional message\n         MVC   OUTPUT+2(32),=C'Run SWAP again until count is 0.'\n         APUT  OUTPUT,50\n         MVC   OUTPUT,OUTPUT-1\n         HEX   MESSAGNG+43,1,SYSEVCOD+3  Display RC from SYSEVENT.\n         APUT  MESSAGNG,L'MESSAGNG\nKEY0EXIT DS    0H\n         L     R6,SAVER6A\n         L     R9,SAVER9L                Restore BAL register.\n         BR    R9\n* ---------------------------------------------------------------- *\nKEY0SFLI DS    X                     Initial swap state\nKEY0SFLO DS    X                     Final swap state\nNSWFLG   DS    X                     Our flag to show state\nKEY0SFL  DS    X\nKEY0NDS  DS    H\nKEY0NDSX DS    H\n*--------------------------------------------------------------*    JOE\n*                                                              *    JOE\n*        BUILD SRB CONTROL BLOCK AND ACCOMPANYING CODE         *    JOE\n*                                                              *    JOE\n*--------------------------------------------------------------*    JOE\nBUILDSRB DS    0H                                                   JOE\n         STM   R6,R9,TEMPSAVE        Save Registers                 JOE\n         BAL   R9,GETASCB            Find ASCB for this asid        JOE\n         LR    R9,R15                Hold ASCB                      JOE\n         L     R9,0(,R9)             Point to ASCB                  JOE\n         MODESET MODE=SUP,KEY=ZERO   Get into supervisor state      JOE\n*                                                                   JOE\nCSA_LEN  EQU  SRBSIZE+84             CSA SRBLOCK AND PARAMTERS      JOE\n*                                                                   JOE\n*---------------------------------------------------------------*   JOE\n*       Get CSA for SRB CONTROL BLOCK SUBPOOL 241               *   JOE\n*---------------------------------------------------------------*   JOE\n         STORAGE OBTAIN,SP=241,LENGTH=CSA_LEN Get Some CSA          JOE\n         LR    R6,R1                 Point R6 to SRB control block  JOE\n         USING SRB,R6                Address SRB                    JOE\n         XC    SRB(SRBSIZE),SRB      Clear out SRB                  JOE\n         ST    R9,SRBASCB            Save ASCB                      JOE\n         LA    R8,SRBSIZE(,R6)       R8 -> paramlist                JOE\n*       Get CSA paramter list                                   *   JOE\n         ST    R8,SRBPARM            Store paramter list address    JOE\n         LA    R7,72(,R8)            Point to ECB                   JOE\n         XC    0(4,R7),0(R7)         Clear ECB Address              JOE\n         LA    R7,4(,R7)             Point to ASCB                  JOE\n         MVC   0(4,R7),X'224'        Move \"HOME\" PSAAOLD address sp JOE\n         LA    R7,4(,R7)             Bump to next param             JOE\n         CLC   FUNC,=C'DONTSWAP'     Q. non swappable function      JOE\n         BE    NONSWAP               Yes; branch if so              JOE\n         CLC   FUNC,=C'TRANSWAP'     Q. non swappable function      JOE\n         BE    TRNSWAP               Yes; branch if so              JOE\n         MVC   0(4,R7),=C'OKSW'      Otherwise swappable            JOE\n         MVC   SRBFLAG3(1),FLAG3\n         B     SETEPA                Set SRB program entry point    JOE\nNONSWAP  DS    0H                                                   JOE\n         MVC   0(4,R7),=C'DONT'      Set FUNCTION IN R7             JOE\n         MVC   SRBFLAG3(1),FLAG3\n         B     ENDSWAP\nTRNSWAP  DS    0H\n         MVC   0(4,R7),=C'TRAN'      Set FUNCTION IN R7\n         MVC   SRBFLAG3(1),FLAG3\nENDSWAP  DS    0H\n*---------------------------------------------------------------*   JOE\n*       Get CSA to contain SRB ROUTINE - SUBPOOL 227            *   JOE\n*---------------------------------------------------------------*   JOE\nSETEPA   DS    0H                                                   JOE\n         MVC   SRBFLAG3(1),FLAG3\n         STORAGE OBTAIN,SP=227,LENGTH=SWAPLEN  Get Fixed CSA        JOE\n         O     R1,=X'80000000'       SRB must run in 31-bit mode.   JOE\n         ST    R1,SRBEPA             Set entry point                JOE\n         LR    R14,R1                Hold that thought              JOE\n         LA    R15,SWAPLEN           Get Length                     JOE\n         LR    R1,R15                                               JOE\n         LA    R0,SWAPXMEM           Point to SRB routine           JOE\n         MVCL  R14,R0                Move routine                   JOE\n*                                                                   JOE\n         SCHEDULE SRB=(R6),SCOPE=GLOBAL,MODE=NONXM                  JOE\n*                                                                   JOE\n         LA    R7,72(,R8)            Point to ECB                   JOE\n*                                                                   JOE\n         WAIT  ECB=(R7)                                             JOE\n*                                                                   JOE\n         L     R9,SRBEPA             Get Entry Point Address        JOE\n         MVC   KEY0NDS(2),SRBNDS-SWAPXMEM(R9)   Get OUCBNDS out.\n         MVC   KEY0SFL(1),SRB0SFL-SWAPXMEM(R9)  Get OUCBSFL out.\n         MVC   SYSEVCOD(4),SRBEVCOD-SWAPXMEM(R9)  Get SYSEVENT code\n         MVC   SAVNDS1(2),KEY0NDS                 Copy count.\n         MVC   KEY0SFLI(1),SRBNSWI-SWAPXMEM(R9)   Initial swap state.\n         MVC   KEY0SFLO(1),SRBNSWO-SWAPXMEM(R9)   Final swap state.\n*                                                                   JOE\n         STORAGE RELEASE,ADDR=(R6),LENGTH=CSA_LEN,SP=241            JOE\n*                                                                   JOE\n         STORAGE RELEASE,ADDR=(R9),LENGTH=SWAPLEN,SP=227            JOE\n*                                                                   JOE\n         MODESET KEY=NZERO,MODE=PROB                                JOE\n*                                                                   JOE\n         LM    R6,R9,TEMPSAVE        Save Registers                 JOE\n         BR    R9                    Return                         JOE\nSAVE14W1 DS    2D                    Save area for display test\nSYSEVCOD DC    F'0'                  SYSEVENT Return Code\nSAVNDS1  DS    H                     Copied DONTSWAP count\n** ---------------------------------------------------------------- **\n** --                C  O  N  S  T  A  N  T  S                   -- **\n** ---------------------------------------------------------------- **\nMESSAGNA DC    C'Command was not invoked APF authorized.'\nMESSAGEN DC    C'End of CSCB chain was reached.'\nMESSAGEY DC    C'No valid keyword was coded.'\nFLAG0    DC    X'00'               Copy of PSCBATR1 - Authority levels\nFLAG1    DC    X'00'               Needed to parse parameters\n*              X'01'               ASID ONLY - NO JOBNAME\n*              X'02'               JOBNAME IS PRESENT.\n*              X'04'               ASID( WAS PRESENT IN PARMS.\n*              X'08'               CSCB CHAIN DISPLAY ONLY.\nFLAG2    DC    X'00'\n*              X'01'               CNCL WAS CODED\n*              X'02'               NCNC WAS CODED\n*              X'04'               SWAP WAS CODED\n*              X'08'               NSWP WAS CODED\n*              X'10'               FORC WAS CODED\n*              X'20'               CSCB WAS CODED\n*              X'80'               BURN OR KILL WAS CODED           KIL\n*              X'40'               CSCB chain run only.\nFLAG3    DC    X'00'\nRTMCOD   DC    X'00'               Saved return code from MEMTERM\nONSWIT   DC    X'00'\n*              X'01'               TURN BIT ON\n*              X'02'               TURN BIT OFF\nHEXSAVE  DS    3F                  SAVE FOR HEX MACRO\nSAVE     DS    9D                  Program Save Area\nSAVE14T1 DS    2D                  Save \"system-used\" registers.\n         DC    C' '                Blank before OUTPUT line.\nOUTPUT   DC    CL80'  '            Variable output line.\nFUNC     DS    CL8                 Swapppinmg function\n         LTORG\n*-----------------------------------------------------------------* JOE\n*                         SRB CODE                                * JOE\n*-----------------------------------------------------------------* JOE\nSWAPXMEM DS    0D                  This is the SRB code.            JOE\n         DROP  R12,R11,R10                                          JOE\n         BASR  R5,0                Base for SRB code                JOE\n         USING *,R5                Entry Point                      JOE\n         LR    R10,R14             Save return address              JOE\n         LR    R13,R1                                               JOE\n*                                                                   JOE\n         LA    R9,72(,R13)         Point to ECB Address             JOE\n         LA    R8,76(,R13)         Point to ASCB Address            JOE\n         L     R8,0(,R8)           Load ASCB                        JOE\n         L     R7,80(,R13)         Get code                         JOE\n*                                                                   JOE\n         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=STDSAVE         JOE\n* ------------------------------------------------------------------- *\n*    The definitive proof an address space is non-swappable, is       *\n*    if the OUCBNSW bit (X'80') of the OUCBSFL flag byte, is on.      *\n* ------------------------------------------------------------------- *\n* --- >            Get initial swap state          < --- *  below\n         L     R2,X'224'                 ASCB\n         L     R4,X'90'(,R2)             ASCBOUCB\n         TM    X'11'(R4),X'80'           NONSWAPPABLE? OUCBNSW bit on?\n         BZ    SWISWSSW\n         OI    SRBNSWI,X'01'             Show NSW initially.\n         B     SWISWSEN                  NON-SWAPPABLE\nSWISWSSW DS    0H\n         NI    SRBNSWI,X'FE'             Show swappable initially.\nSWISWSEN DS    0H\n* --- >            Get initial swap state          < --- *  above\n* ------------------------------------------------------------------- *\n         TM    SRBFLAG3,X'10'      Count only?\n         BO    SWAPDONT            Skip SYSEVENT actions.\n*                                  Just get count.\n* ------------------------------------------------------------------- *\n*                                                                   JOE\n         C      R7,=C'OKSW'        OKSWAP ?                         JOE\n         BE     SETSWAP                                             JOE\n*                                                                   JOE\n         XR    R1,R1               Undocumented instead of WAIT     JOE\n         TM    SRBFLAG3,X'01'      Transwap ?\n         BO    SWAPTRAN            Go there. Otherwise DONTSWAP.\n         SYSEVENT DONTSWAP,ENTRY=BRANCH                             JOE\n         ST    R1,SRBEVCOD               Return code from SYSEVENT.\n         B     SWAPDONT                  DONTSWAP, not TRANSWAP\nSWAPTRAN DS    0H\n         SYSEVENT TRANSWAP,ENTRY=BRANCH                             JOE\n         ST    R1,SRBEVCOD               Return code from SYSEVENT.\nSWAPDONT DS    0H                        Out of SYSEVENT here\n*                                                                   JOE\n* ----- >           Find OUCBNDS Count        < ----- *     below\n         L     R2,X'224'                 ASCB\n         L     R4,X'90'(,R2)             ASCBOUCB\n         LA    R2,X'88'(,R4)             OUCBNDS (Count Field)\n         LA    R3,X'11'(,R4)             OUCBNSW\n         MVC   SRBNDS(2),0(R2)\n         MVC   SRB0SFL(1),0(R3)\n* ----- >           Find OUCBNDS Count        < ----- *     above\n         B     SWAPFINL                                             JOE\n*                                                                   JOE\nSETSWAP  DS    0H                        Set address space swappable\n*\n* ----- >           FSWP code                 < ----- *     below\n         TM    SRBFLAG3,X'02'            Are we forcing a SWAP ?\n         BZ    SETSWAPF                  No. So take it naturally.\n*                                        Access the DONTSWAP count.\n         L     R2,X'224'                 ASCB\n         L     R4,X'90'(,R2)             ASCBOUCB\n         LA    R2,X'88'(,R4)             OUCBNDS (Count Field)\n         LA    R3,X'11'(,R4)             OUCBSFL\n         MVC   0(2,R2),=X'0001'          Set DONTSWAP count to 1\nSETSWAPF DS    0H\n* ----- >           FSWP code                 < ----- *     above\n*                                                                   JOE\n         XR    R1,R1               Undocumented instead of WAIT     JOE\n         SYSEVENT OKSWAP,ENTRY=BRANCH                               JOE\n         ST    R1,SRBEVCOD               Return code from SYSEVENT.\n* ----- >           Find OUCBNDS Count        < ----- *     below\nSWAPCOUN DS    0H\n         L     R2,X'224'                 ASCB\n         L     R4,X'90'(,R2)             ASCBOUCB\n         LA    R2,X'88'(,R4)             OUCBNDS (Count Field)\n         LA    R3,X'11'(,R4)             OUCBSFL\n         MVC   SRBNDS(2),0(R2)           Get DONTSWAP count\n         MVC   SRB0SFL(1),0(R3)          Get OUCBSFL flags (not needed)\n* ----- >           Find OUCBNDS Count        < ----- *     above\n* --- >            Get final swap state            < --- *  below\nSWAPFINL DS    0H\n         L     R2,X'224'                 ASCB\n         L     R4,X'90'(,R2)             ASCBOUCB\n         TM    X'11'(R4),X'80'           NONSWAPPABLE? OUCBNSW bit on?\n         BZ    SWISWSSX                  No. Show swappable.\n         OI    SRBNSWO,X'01'             Set flag to show NSW.\n         B     SWISWSED                  Exit this routine.\nSWISWSSX DS    0H                        Go to SWISWSTX except for TSWP\n**-->>                                   Fudge flags for TRANSWAP\n         TM    SRBFLAG3,X'01'            TRANSWAP NEEDS FUDGING\n         BZ    SWISWSTX                  Not TRANSWAP. No fudge.\n         OI    SRBNSWO,X'01'             TRANSWAP,force our NSW flag\n         OI    SRB0SFL,X'80'             And show NSW to the program\n         B     SWISWSED                  Exit this routine.\nSWISWSTX DS    0H\n**-->>                                   All other cases, if OUCBNSW\n         NI    SRBNSWO,X'FE'             is off, show swappable.\nSWISWSED DS    0H\n* --- >            Get final swap state            < --- *  above\nUNLOCK   DS    0H                                                   JOE\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE                    JOE\n*                                                                   JOE\n*                                                                   JOE\n         POST  (R9),ASCB=(R8),ERRET=GOBACK,LINKAGE=BRANCH           JOE\n*                                                                   JOE\nGOBACK   LR    R14,R10               Return Address                 JOE\n         BR    R14                   Return                         JOE\n         LTORG                                                      JOE\nSRBFLAG3 DC    X'00'                 Copy of program's FLAG3\nSRBNSWI  DC    X'00'\nSRBNSWO  DC    X'00'\nSRB0SFL  DC    X'00'\nSRBEVCOD DC    F'0'                  SYSEVENT return code, FULL R1\nSRBNDS   DS    H                     Storage for OUCBNDS value\nSWAPRTM  DS    0D                    Align on doubleword            JOE\nSWAPLEN  EQU   *-SWAPXMEM                                           JOE\n** ---------------------------------------------------------------- **\n         SPACE\n         TITLE '- MAPPING MACROS.'\n         CVT   DSECT=YES           Map the CVT.\n         IEECHAIN                  Map the CSCB control block.\n         IHASRB                                                     JOE\n         IHAASVT                                                    JOE\n         IHAASCB                                                    JOE\n         IHAASXB                                                    JOE\n         IRAOUCB                                                    JOE\n         IHAPSA   DSECT=YES,LIST=YES                           HD APR88\n         IHAFRRS\n         EJECT                                                 HD APR88\n         IKJEFLWA                                                   JOE\n         END   CNCLPG\n** ---------------------------------------------------------------- **\n*  -----------------------------------------------------------------  *\n*  --           Create PUTLINE environment.                       --  *\n*  -----------------------------------------------------------------  *\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUEMNTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   255                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         IHAPSA   DSECT=YES,LIST=YES                           HD APR88\n         EJECT\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   14,12,12(13)       SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES            RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    1,8(13)            OUR SAVE AREA POINTER\n         ST    13,4(1)            POINTER TO CALLERS SAVE AREA\n         LR    13,1               @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(R13)         POINT TO CALLERS RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 ASSUME BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 ASSUME BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(RML)               MESSAGE LENGTH\n         STH   R15,PUTLEN                 PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    2,R13                    @OUR SAVE AREA\n         LR    3,R15                    SAVE RETURN CODE\n         L     R13,4(R13)               @CALLERS SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,3                    RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CNCLPG$": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00(\\x01\\x07\"\\x7f\\x01\\x17\\x13/\\x15\\x02\\x00\\x1c\\x00\\x1c\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "2007-08-15T00:00:00", "modifydate": "2017-05-12T15:02:28", "lines": 28, "newlines": 28, "modlines": 0, "user": "JCL"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT495.FILE826(CNCLPG)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB,UNIT=SYSALLDA,VOL=SER=\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB,UNIT=SYSALLDA,VOL=SER=\n//SYSLIN   DD  DSN=&&TEMP,DISP=(OLD,PASS)\n//         DD  DDNAME=SYSIN\n//SYSIN    DD  *\n ENTRY   CNCLPG\n SETSSI  CB495826\n SETCODE AC(1)\n NAME    CNCLPG(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CNCLPG$$": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\t\\x01\\x07\"\\x7f\\x01\\x17\\x14\\x1f\\x17\\x11\\x00\\x1c\\x00\\x1c\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "2007-08-15T00:00:00", "modifydate": "2017-05-21T17:11:09", "lines": 28, "newlines": 28, "modlines": 0, "user": "JCL"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT495.FILE826(CNCLPG)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=IBMUSER.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=IBMUSER.LOAD\n//SYSLIN   DD  DSN=&&TEMP,DISP=(OLD,PASS)\n//         DD  DDNAME=SYSIN\n//SYSIN    DD  *\n ENTRY   CNCLPG\n SETSSI  CB495826\n SETCODE AC(1)\n NAME    CNCLPG(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CNCLPG10": {"ttr": 2059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00F\\x01\\x08\\x15?\\x01\\x17\\x13o\\x142\\x05\\x17\\x05\\x17\\x00\\x00\\xe5\\xf1\\xd9\\xf1\\xd4\\xf0@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2008-06-01T00:00:00", "modifydate": "2017-05-16T14:32:46", "lines": 1303, "newlines": 1303, "modlines": 0, "user": "V1R1M0"}, "text": "CNCLPG   TITLE 'Make an address space cancelable or non-canclable. '\n*  -----------------------------------------------------------------  *\n*                                                                     *\n*    Function:   To make an address space Cancelable, Non-cancelable, *\n*                Forcible, or Non-forcible.                           *\n*                                                                     *\n*                This is determined by bit settings in the address    *\n*                space's CSCB.                                        *\n*                                                                     *\n*    Syntax:     TSO Command:                                         *\n*                                                                     *\n*        CNCLPG |jobid \u00ddASID(hhhh)\u00a8 |CNCL|NCNC|FORC|NFRC              *\n*               |ASID(hhhh)         |CNCL|NCNC|FORC|NFRC              *\n*               |                   |CSCB or DISP                     *\n*               |-  (displays the entire CSCB chain)                  *\n*               |?  (displays help)                                   *\n*                                                                     *\n*    Date:       April 15, 2010                                       *\n*                                                                     *\n*    Author:     Sam Golob                                            *\n*                                                                     *\n*    Technical Detail:  PUTLINE interface for TSO Output.             *\n*                                                                     *\n*                                                                     *\n*    Changes:  1.  SWAP, NSWP support dropped from this program.      *\n*                                                                     *\n*              2.  Messages and DISP improved, to just show matching  *\n*                   CSCB chain entries, instead of all of them.       *\n*                                                                     *\n*  -----------------------------------------------------------------  *\n*  This macro lets you display hex values in a report.\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    STM   R15,R1,HEXSAVE           Save work registers.\n         LA    R1,&FROM                 Load from address.\n         LA    R0,&LEN                  Load length of hex number.\n         LA    R15,&TO                  Load to address.\n         BAL   R9,HEX                   BAL to routine.\n         LM    R15,R1,HEXSAVE           Restore work registers.\n         MEND\n*  -----------------------------------------------------------------  *\n*  --           Create PUTLINE environment.                       --  *\n*  -----------------------------------------------------------------  *\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\n* --       End of Internal Macros......                            -- *\n* ------------------------------------------------------------------- *\n         SPACE 3\nCNCLPG   CSECT\nCNCLPG   AMODE 31\nCNCLPG   RMODE ANY\n         YREGS\n         USING CNCLPG,R15          (Establish temporary base).\n         B     BEGIN               Skip over eyecatcher.\nEYEC0    DC    AL1(EYECL)          Exclusive length of header.\nEYEC     DC    C' CNCLPG - &SYSDATE - &SYSTIME -'\n         DC    C'     --------------------------------    '\n         DC    C' VER 1.0.0   '\n         DC    C'                   '\nEYECL    EQU   *-EYEC\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)     Save caller's registers\n         LR    R6,R1               Preserve CPPL pointer.\n         LR    R12,R15             Copy base.\n         USING CNCLPG,R12,R11,R10  (Tell assembler).\n         LA    R11,4095(,R12)      Load bases.\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)\n         LA    R10,1(,R10)\n         LR    R14,R13             Copy caller's save area pointer.\n         LA    R13,SAVE            Point to my save area.\n         ST    R13,8(,R14)         Chain ...\n         ST    R14,SAVE+4          ... Save areas.\n         SPACE 1\nAUTHTEST DS    0H\n         ST    R1,SAVER1A\n         L     R1,16               CVTPTR\n         L     R1,0(,R1)           TCB WORDS\n         L     R1,4(,R1)           CURRENT TCB\n         L     R1,180(,R1)         TCBJSCB\n         L     R1,264(,R1)         JSCBPSCB\n         LA    R1,0(,R1)           CLEAR HI ORDER BYTE\n         LTR   R1,R1               IS THERE A PSCB\n         BZ    NOTFOUND            NO, ISSUE COMMAND-NOT-FOUND MSG\n         TM    X'10'(R1),X'80'     PSCB OPER AUTHORITY?\n         BZ    NOTFOUND            NO, ISSUE COMMAND-NOT-FOUND MSG\n         L     R1,SAVER1A\nINITCON  DS    0H                  Initialize some constants.\n         MVI   FLAG1,X'00'\n         MVI   FLAG2,X'00'\n         MVI   ONSWIT,X'00'\n         MVI   ERRASID,X'00'\n         MVI   CANCINDC,X'00'\n         MVI   OUTPUT-1,X'40'\n         MVC   OUTPUT,OUTPUT-1\n         MVI   NEWCHACT,X'00'\nPRTITLE  DS    0H                  Print program title.\n         APUT  MESSAGET,L'MESSAGET\n         APUT  MESSAGEU,L'MESSAGEU\nCONT0    DS    0H                  Look at command's parameters.\n         LTR   R6,R6               Any CPPL?\n         BZ    EOJ8                No.  Get out.\n         L     R1,0(,R6)           Pt to cmd buffer. (R6 reused later)\n         LTR   R1,R1               Any CMD buffer?\n         BZ    EOJ8                Get out if none.\n         LH    R3,0(,R1)           Load length.\n         CH    R3,=H'4'            Anything?\n         BNH   EOJ4                No. Get out.\n         LR    R5,R3               Length of command + 4\n         ICM   R5,14,FULLZERO      Clear hi order 3 bytes.\n         LH    R3,2(,R1)           Load offset.\n         SR    R5,R3               Subtract offset from full length+4\n         SH    R5,=H'4'            Correct for length of cmdbufr header\n         BC    8,WMESS2            Zero, message to enter userid.\n         BC    5,EOJ8              Less, or overflow, out.\nPARM     DS    0H\n         BAL   R9,GETIDS           Get parameters for the command.\n         B     EOJ0\n*\n* --- Parms gotten at this point.                            -------- *\n*\n** ---------------------------------------------------------------- **\nWMESS2   DS    0H                  Print help messages.\n         BAL   R9,PRINTERR\n         B     EOJ4\n** ---------------------------------------------------------------- **\nEOJ0     DS    0H                  End of job.\n         APUT  RETURN0,L'RETURN0\n         LA    R15,0               Set CC = 0.\n         B     RETURN\nEOJ4     DS    0H\n         APUT  RETURN4,L'RETURN4\n         LA    R15,4               Set CC = 4.\n         B     RETURN\nEOJ8     DS    0H\n         APUT  RETURN8,L'RETURN8\n         LA    R15,8               Set CC = 8.\n         B     RETURN\nRETURN   L     R13,SAVE+4\n         L     R14,12(,R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n** ---------------------------------------------------------------- **\nNOTAUTH  DS    0H                  Command not APF authorized message.\n         APUT  MESSAGNA,L'MESSAGNA\n         B     EOJ4\n** ---------------------------------------------------------------- **\nNOTFOUND DS    0H                  Command NOT ALLOWED message.\n         APUT  MESSAGAU,L'MESSAGAU\n         B     RETURN\n** ---------------------------------------------------------------- **\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        Get the parameters for the command.                      *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*   Notes:  The ASID(xxx) can be coded first, without a userid.   *\n*           A dash can be coded first, to run the entire CSCB     *\n*            chain and display all the jobnames in it, with       *\n*            their associated ASIDs.  ? coded first gives HELP.   *\n*           If you code the word CSCB or DISP(lay) after either   *\n*            a jobname or an ASID(hhhh) then a display of the     *\n*            matching CSCB chain entries will be displayed, and   *\n*            no changes will be made.                             *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETIDS   DS    0H                  Get all parameters for the program.\n         ST    R9,SAVER9A\n         ST    R4,SAVER4C\n         AR    R1,R3               Point ...\n         LA    R1,4(,R1)           ... to char.\n         LA    R6,8                Load reg for BCT loop.\n         LR    R7,R1               Initialize pointer to first\n         LA    R7,0(,R7)                character of the ID field.\n         LA    R8,0                Initialize character count.\n         MVC   JOBID(8),BLANKS     Clear (first param - JOBNAME) field.\n         LA    R4,JOBID            Point reg to beginng of JOBID field.\n*\nCUTIDLEN DS    0H                  Look at the JOBID field first.\n*                                  (May contain ASID( or CSCB.)\n*\n         CLI   0(R7),X'40'         Is this character a blank?\n         BE    NOMORCUT            Yes, we are at the end of the field.\n         MVC   0(1,R4),0(R7)       Move only one character at a time.\n         OC    JOBID(8),BLANKS     And uppercase the partial jobid.\n*\n*   Is this a run of the CSCB chain only?\n* -- >  Test for CSCB  first  ---- below\n         CLI   JOBID,C'-'          Did we code '-' first?\n         BNE   CSCBHELP            No. Try if help asked for.\n         B     CSCBRUN1            Yes. Run entire CSCB chain.\n* - > Help\nCSCBHELP DS    0H\n         CLI   JOBID,C'?'          Help?\n         BNE   NOCSCB              No. Skip this code.\n         BAL   R9,PRINTERR         Yes. Print messages\n         B     EOJ0                  and get out with code 0.\n* - > Help\nCSCBRUN1 DS    0H\n         ST    R8,SAVER8A          Store count for display if needed.\n         OI    FLAG2,X'40'         Mark that this is CSCB only run.\n         BAL   R9,RUNCSCB          Do the run for CSCB chain.\n         B     EOJ0                Out with normal return code.\nNOCSCB   DS    0H\n* -- >  Test for CSCB  first  ---- above\n*\n*   Was the ASCB(hhh) parameter coded without the jobid?\n* -- >  Test for ASID( first  ---- below\n         CLC   JOBID(L'ASIDC),ASIDC  Did we code ASID( in jobid field?\n         BNE   NOASIDF             No. Pass this code.\n         OI    FLAG1,X'01'         Flag that ASID( ) was first.\n         NI    FLAG1,X'FF'-X'02'   Turn off Jobname in jobid field flag\n         MVC   ASIDWKL(L'ASIDC),JOBID  Move the ASID( to proper field.\n         MVC   JOBID,BLANKS        Blank out Job ID if ASID( coded.\n         LA    R7,1(,R7)           Bump another character.\n         LA    R8,1(,R8)           Count another character.\n         LA    R6,1                Set number of branches later.\n*                                  This will limit number of params\n*                                   that are searched for.\n         B     ASIDONLY            Bypass all the real jobname stuff.\n* -- >  Test for ASID( first  ---- above\nNOASIDF  DS    0H                  ASID( is not the first parameter.\n         LA    R4,1(,R4)           Bump another character.\n         LA    R7,1(,R7)           Bump another character.\n         LA    R8,1(,R8)           Count another character.\n         CR    R8,R5               End of command buffer ?\n         BNL   NOMORCUT            Yes. Get out now.\n         BCT   R6,CUTIDLEN         Try for the next blank, up till 8.\nNOMORCUT DS    0H\n         STC   R8,SAVCOUNT         Save length of Jobname\n         L     R4,SAVER4C          Restore work register for use later.\n         OC    JOBID(8),BLANKS     Uppercase the new Job Id.\n         OI    FLAG1,X'02'         Set 'Jobname Coded' flag.\n*  -  Display the found JOBID - below\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Search Jobname:'\n         MVC   OUTPUT+17(8),JOBID\n         APUT  OUTPUT,30\n         APUT  MESSAGEL,L'MESSAGEL\n*  -  Display the found JOBID - above\n         LA    R6,1                Set number of branches later.\n*                                  This will limit number of params\n*                                   that are searched for.\n         B     LOOKKEYW\n*  Constants - below - ***\nJOBID    DC    C'        '         STORE PARM USERID HERE\nBLANKS   DC    C'        '         8 BLANKS\nMESSAGET DC    C'CNCLPG - Make a Job, STC or TSU Cancelable, etc. (? foX\n               r help)'\nMESSAGEU DC    C'------ - ---- - ---- --- -- --- ----------- ----'\nMESSAGEL DC    C'----------------------------'\nMESSAGEM DC    C'-----------------------------------------------'\nMESSAG2A DC    C'Enter JOBNAME and/or ASID(hhhh) after COMMAND name,'\nMESSAG2B DC    C'   then CNCL, NCNC, FORC, NFRC, or code CSCB or DISP.'\nMESSAG2C DC    C'   DISPlay or CSCB will display CSCB chain entries,'\nMESSAG2D DC    C'   without changing them.'\nMESSAG2E DC    C' When changing a job, we want to be accurate, '\nMESSAG2F DC    C'  therefore you should use the DISPlay option first.'\nMESSAG2G DC   C' To display the whole CSCB, code - (dash) for JOBNAME.'\nMESSAG2H DC    C' To see this help message, code ? for JOBNAME.'\nMESSAG2I DC    C'Notes : '\nMESSAG2J DC   C' CSCB (DISP) display for an ASID shows all occurrences'\nMESSAG2K DC    C'  for that ASID, regardless of JOBNAME.      '\nMESSAG2L DC C' CSCB (DISP) display for a JOBNAME shows all occurrences'\nMESSAG2M DC    C'  for that JOBNAME, regardless of ASID.      '\nMESSAG2N DC    C' CNCL, NCNC, FORC, NFRC will change the first '\nMESSAG2O DC    C'  entry in the CSCB chain that matches, if multiple '\nMESSAG2P DC    C'  entries exist. But DISP will display ALL applicable'\nMESSAG2Q DC    C'  matching entries in the CSCB chain, so you can see'\nMESSAG2R DC    C'  which one you want to change specifically.'\nMESSAG2S DC    C' When you code BOTH jobname and asid, to CHANGE it,'\nMESSAG2T DC    C'  then ONLY that specific job and asid gets changed.'\nMESSAGE3 DC    C'WE GOT HERE'\nMESSAGE4 DC    C'TEST CHECK THIS'\nMESSAGAU DC    C'IKJ56500I COMMAND CNCLPG NOT FOUND'\nRETURN0  DC    C'Return code is 0'\nRETURN4  DC    C'Return code is 4'\nRETURN8  DC    C'Return code is 8'\n*                     ***  Places to save registers  ***  below\nSAVER1A  DS    F\nSAVER3A  DS    F\nSAVER3B  DS    F\nSAVER3C  DS    F\nSAVER3D  DS    F\nSAVER3E  DS    F\nSAVER4A  DS    F\nSAVER4B  DS    F\nSAVER4C  DS    F\nSAVER5A  DS    F\nSAVER7A  DS    F\nSAVER8A  DS    F\nSAVER9A  DS    F\nSAVER9B  DS    F\nSAVER9C  DS    F\nSAVER9D  DS    F\nSAVER9E  DS    F\nSAVER9F  DS    F\nSAVER9G  DS    F\nSAVER9H  DS    F\nSAVER9I  DS    F\nSAVER9J  DS    F\nSAVER9K  DS    F\n*                     ***  Places to save registers  ***  above\nSAVCOUNT DS    X\nDUBLZERO DC    D'0'\nFULLZERO DC    F'0'\nCANCINDC DC    X'00'\nCANCKEY0 DC    X'00'\nNEWCHACT DC    X'00'\n*  Constants - above - ***\nLOOKKEYW DS    0H                  Look for additional keywords.\n         LA    R7,1(,R7)           Bump command buffer pointer.\n         LA    R8,1(,R8)           Bump character counter.\n         CR    R8,R5               End of command buffer?\n         BNL   GETIDEND            Yes. Don't look any more.\n         MVC   ASIDWKL(5),BLANKS   Clear parameter work field.\n         MVC   ASIDWKL(5),0(R7)    Next 5 characters to work field.\nASIDONLY DS    0H                  Jump to here if ASID( coded first.\n         OC    ASIDWKL(4),BLANKS   Uppercase work field.\n         CLC   ASIDC,ASIDWKL       Is the ASID( keyword there?\n         BE    DOASID              Yes. Process it.\n         CLC   CNCLC,ASIDWKL       Is the CNCL  keyword there?\n         BE    DOCNCL              Yes. Process it.\n         CLC   NCNCC,ASIDWKL       Is the NCNC  keyword there?\n         BE    DONCNC              Yes. Process it.\n         CLC   FORCC,ASIDWKL       Is the FORC  keyword there?\n         BE    DOFORC              Yes. Process it.\n         CLC   NFRCC,ASIDWKL       Is the NFRC  keyword there?\n         BE    DONFRC              Yes. Process it.\n         CLC   CSCBC,ASIDWKL       Is the CSCB  keyword there?\n         BE    DOCSCB              Yes. Process it.\n         CLC   DISPC,ASIDWKL       Is the DISP  keyword there?\n         BE    DOCSCB              Yes. Process it.\n         B     LOOKKEYW            Go loop and look at next character.\nASIDWKL  DC    CL5' '              Second parameter work area.\n*\nASIDC    DC    C'ASID('            Literals....\nCNCLC    DC    C'CNCL'\nNCNCC    DC    C'NCNC'\nFORCC    DC    C'FORC'\nNFRCC    DC    C'NFRC'\nCSCBC    DC    C'CSCB'\nDISPC    DC    C'DISP'\n*\nDOASID   DS    0H                  Look for hex value of the ASID.\n         OI    FLAG1,X'04'         Show that ASID( was coded.\n         BAL   R9,GETASID          Go get the rest of the parameters.\n         MVC   ASIDWKL(5),BLANKS   Blank out the second wkarea for\n*                                   a further parameter search.\n         B     LOOKKEYW            Re-loop to look further for params.\n*\nDOCNCL   DS    0H                  Handle CNCL (cancelable) keyword.\n         OI    CANCINDC,X'08'      Show which CHACT bit is affected.\n         OI    FLAG2,X'01'         Show that CNCL was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'01'        Set to OR the bits\n         NI    ONSWIT,X'FF'-X'02'   and not to AND the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n* ------------------------------------------------------------------- *\n*                                    Print the action code.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),CNCLC\n         APUT  OUTPUT,25\n*                                    Print the bit in CHACT affected.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDONCNC   DS    0H                  Handle NCNC (non-cancelable) keyword\n         OI    CANCINDC,X'08'      Show which CHACT bit is affected.\n         OI    FLAG2,X'02'         Show that NCNC was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'02'        Set to AND the bits\n         NI    ONSWIT,X'FF'-X'01'   and not to OR the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n*                                    Print the action code.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),NCNCC\n         APUT  OUTPUT,25\n*                                    Print the bit in CHACT affected.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDOFORC   DS    0H                  Handle FORC (forcible) keyword\n         OI    FLAG2,X'10'         Show which CHACT bit is affected.\n         OI    CANCINDC,X'01'      Show that FORC was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'01'        Set to OR the bits\n         NI    ONSWIT,X'FF'-X'02'   and not to AND the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n*\n         MVC   OUTPUT,OUTPUT-1       Print the action code.\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),FORCC\n         APUT  OUTPUT,25\n*\n         MVC   OUTPUT,OUTPUT-1       Print the bit in CHACT affected.\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDONFRC   DS    0H                  Handle NFRC (non-forcible) keyword\n         OI    FLAG2,X'20'         Show which CHACT bit is affected.\n         OI    CANCINDC,X'01'      Show that NFRC was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'02'        Set to AND the bits\n         NI    ONSWIT,X'FF'-X'01'   and not to OR the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n*\n         MVC   OUTPUT,OUTPUT-1       Print the action code.\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),NFRCC\n         APUT  OUTPUT,25\n*\n         MVC   OUTPUT,OUTPUT-1       Print the bit in CHACT affected.\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDOCSCB   DS    0H\n         OI    FLAG1,X'08'         Show CSCB keyword was coded.\n         OI    FLAG2,X'40'         Show CSCB keyword was coded.\n         MVC   OUTPUT,OUTPUT-1       Print the action code.\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),CSCBC\n         MVC   OUTPUT+23(9),=C'(DISPlay)'\n         APUT  OUTPUT,35\n         BAL   R9,RUNCSCB          Run the CSCB chain with print.\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nGETIDEND DS    0H                  End of keyword processing.\n         TM    FLAG2,X'7F'         Check if any real actions were asked\n         BM    GETKEYNR            Yes, some were.\n         APUT  MESSAGEY,L'MESSAGEY    No. Display help messages.\n         BAL   R9,PRINTERR\n         B     EOJ4                   And end with code = 4.\nGETKEYNR DS    0H                  Real actions WERE asked for.\n         B     EOJ0                So end with normal return code.\n         L     R9,SAVER9A\n         BR    R9\n** ---------------------------------------------------------------- **\nHEX      DS    0H                  Display hex values.\n         ST    R9,SAVER9B\n         MVC   1(1,R15),0(R1)      Move byte.\n         UNPK  0(3,R15),1(2,R15)   Unpack.\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)         Increment output pointer.\n         LA    R1,1(,R1)           Increment input pointer.\n         BCT   R0,HEX              Decrement length, then loop.\n         MVI   0(R15),C' '         Blank the trailing byte.\n         L     R9,SAVER9B\n         BR    R9                  Return to caller.\nHEXTAB   DC    C'0123456789ABCDEF' Translate table.\n** ---------------------------------------------------------------- **\nGETASID  DS    0H                  Get hex ASID for 2 bytes.\n         ST    R9,SAVER9C          Save registers.\n         STM   R1,R6,SAVERGS1\n         LA    R6,4                Load BCT register.\n         LA    R4,ASIDWK           Point to ASID work area.\n         TM    FLAG1,X'02'         Ask if Job name was coded.\n         BZ    GETAFL01            Wasn't. Have to adjust pointers.\n         LA    R7,5(,R7)           Bump command buffer pointer.\n         LA    R8,5(,R8)           Bump character counter.\nGETAFL01 DS    0H\nGETASIDL DS    0H                  Loop to get hex ASID for 4 display\n*                                    bytes to convert to 2 hex bytes.\n         CLI   0(R7),C')'          Have we reached close parenthesis?\n         BE    GETASIDG            Yes, assume we've got it.\n         CLI   0(R7),C' '          Have we hit a blank?\n         BE    GETASIDG            Yes, assume we've got it.\n         MVC   0(1,R4),0(R7)       Otherwise move one character over.\n         LA    R4,1(,R4)           Bump one ASIDWK character (target)\n         LA    R7,1(,R7)           Bump command buffer pointer.\n         LA    R8,1(,R8)           Bump character counter.\n         BCT   R6,GETASIDL         Loop for 4 characters.\n         B     GETASIDG            We don't look for more than 4.\nGETASIDG DS    0H\n*        APUT  ASIDWK,4\n         LA    R4,ASIDWK           Point register at workarea again.\n         LA    R1,4                Maximum of 4 characters.\nGETASIDA DS    0H\n         CLI   3(R4),X'40'         Is last character a blank (<4 total)\n         BNE   GETASIDM            No. We're finished sliding.\n         BCTR  R4,0                Slide the pointer one place back.\n         BCT   R1,GETASIDA         Do it no more than 4 times.\nGETASIDM DS    0H\n         MVC   ASIDMV(4),0(R4)     Move 4 characters so last one\n*                                     is not blank.\n         MVC   ASIDWKSV(4),ASIDMV    Save these 4 characters\n         MVC   ASIDWKS(4),ASIDMV        in two places.\n         MVC   OUTPUT,OUTPUT-1       Clear output line.\n         MVC   OUTPUT(25),ASIDMSG    Move coded display format asid.\n         APUT  OUTPUT,40             And put out the message.\n         TR    ASIDMV(4),ASIDVAL     Translate display format message\n*                                      into format X'0h0h0h0h'.\n         BAL   R9,VALIDTR            Validity check the hex number.\n         PACK  ASIDGET(3),ASIDMV(5)  Get rid of all zone nibbles.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Search ASID   :' Print resulting 2-bytes\n         HEX   OUTPUT+21,2,ASIDBIN\n         APUT  OUTPUT,30\n         APUT  MESSAGEL,L'MESSAGEL   Add underline for clear display.\n*\nGETASIDE DS    0H                    End of routine.\n         LM    R1,R6,SAVERGS1        Restore registers\n         L     R9,SAVER9C               and\n         BR    R9                          exit.\n*            Constants associated with this routine.    -    below\nASIDWKB  DC    CL4'    '\nASIDWK   DC    CL4'    '\nASIDWKF  DC    CL4' '\nASIDMV   DC    CL4'    '\nASIDMVF  DC    CL4' '\nASIDBIN  DS    0XL2\nASIDGET  DC    XL4'00000000'\n\nSAVERGS1 DS    6F\n*                   Translate table to validity check ASID.\n*                     Convert display values to X'0h'\n*                     (where h is the hex value).\nASIDVAL  DS    0D\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'00CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CC0A0B0C0D0E0FCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CC0A0B0C0D0E0FCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'00010203040506070809CCCCCCCCCCCC'\nFILLER1  DS    CL24\nASIDMSG  DC    CL21'ASID parm entered  : '\nASIDWKSV DC    CL4' '\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\nFINDCSCB DS    0H                  Find CSCB entry to change or report.\n         ST    R9,SAVER9D          Save registers.\n         ST    R3,SAVER3A\nFINDCSST DS    0H                  Get the first CSCB.\n         L     R3,16               CVT\n         L     R3,X'94'(,R3)       MSER - pointer to CSCB chain.\n         ICM   R3,15,0(R3)         First CSCB entry.\n         USING CHAIN,R3            Tell assembler.\n         BZ    FINDCSEC            If zero, we are at end of CSCB chain\nFINDCSLP DS    0H                  Loop through the CSCB entries.\n         MVC   CSCBACTF(1),CHACT     Save CSCB ACT flag for this CSCB.\n         MVC   CSCBJOBI(8),CHKEY     Save CSCB Jobid (CHKEY).\n         MVC   CSCBPROC(8),CHCLS     Save CSCB PROC id (CHCLS).\n         MVC   CSCBASID(2),CHASID    Save CSCB ASID (CHASID).\n* ------------------------------------------------------------------- *\n* We first try to match a JOBID if coded, to the job id in this CSCB. *\n* If equal, we see if an ASID has been coded, and both have to match. *\n* Otherwise, with no match, we go to the end of the CSCB chain.       *\n* ------------------------------------------------------------------- *\nFINDCSMY DS    0H                  Find the CSCB that I want.\n         TM    FLAG1,X'04'         Was ASID( coded at all?\n         BZ    FINDCSJB            No. Just find a JOBID match.\n         TM    FLAG1,X'01'         Is the JOB id missing?\n         BO    FINDCSAS            Yes, just look for an ASID match.\n         TM    FLAG1,X'02'         Was JOB id coded?\n         BO    FINDCSJB            Yes. Look for it.\n         ICM   R3,15,0(R3)         Go to next CSCB.\n         BZ    FINDCSEC            If zero, we are at end of CSCB chain\n         B     FINDCSLP            Look at next CSCB entry in table.\nFINDCSJB DS    0H                  Check for JOBID match in this CSCB.\n         CLC   JOBID(8),CSCBJOBI   Compare coded JOBID to CSCB jobname.\n         BE    FINDCSIA            Equal, check if ASID is there.\n         ICM   R3,15,0(R3)         Otherwise go to the next CSCB.\n         BZ    FINDCSEC            Zero, end of the CSCB chain.\n         B     FINDCSLP            Not zero, look at the next entry.\nFINDCSIA DS    0H\n         TM    FLAG1,X'04'         Was ASID( coded?\n         BZ    FINDCSFD            No. Found it on just a job match.\n*                                   So this is the first job that\n*                                   matched, if there are multiple\n*                                   jobs with the same name.\nFINDCSAS DS    0H                  Check the ASID in the CSCB.\n         CLC   ASIDBIN(2),CSCBASID Is this our ASID? Does it match.\n         BE    FINDCSFD            I guess we found it.\n         ICM   R3,15,0(R3)         Go to the next CSCB.\n         BZ    FINDCSEC            Zero marks the end of the CSCB chain\n         B     FINDCSLP            Not zero. Look at the next entry.\nFINDCSFD DS    0H                  Our CSCB has been found.\n         ST    R3,FOUNCSCB         Save found CSCB address.\n         MVC   FOUNACTF,CHACT      Save\n         MVC   FOUNJOBI,CHKEY        CSCB\n         MVC   FOUNPROC,CHCLS          info.\n         MVC   FOUNASID,CHASID\n         BAL   R9,PRNTCSCB         Print info from the current CSCB.\n         BAL   R9,FORCHACT         Format some CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Put out an underline.\n         B     FINDCSEN            Go to end of routine.\n         DROP  R3\nFINDCSEC DS    0H                  Came to end of CSCB chain.\n         APUT  MESSAGEN,L'MESSAGEN   Then put out a message\n         B     EOJ4                  And end with code 4.\nFINDCSEN DS    0H\n         L     R3,SAVER3A\n         L     R9,SAVER9D\n         BR    R9\n*            Constants associated with this routine.    -    below\nFOUNCSCB DS    F                   FOUND CSCB ADDRESS\nFOUNACTF DC    X'00'\nFOUNJOBI DC    CL8' '\nFOUNPROC DC    CL8' '\nFOUNASID DC    XL2'0000'\nCSCBACTF DC    X'00'\nCSCBJOBI DC    CL8' '\nCSCBPROC DC    CL8' '\nCSCBASID DC    XL2'0000'\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\nVALIDTR  DS    0H                  Validate hex characters coded.\n         ST    R9,SAVER9E          Save\n         STM   R4,R6,SAVEWRK          registers.\n         LA    R4,ASIDMV           Point to translated display chars.\n         LA    R6,ASIDWKS          Point to chars with error signs.\n         LA    R5,4                BCT register - only 4 times.\nVALIDTRS DS    0H\n         CLI   0(R4),X'CC'         Is this an invalid character?\n         BE    VALIDTRR            Yes. Substitute a ? for message.\n         LA    R4,1(,R4)           Next translated character.\n         LA    R6,1(,R6)           Next char for error message.\n         BCT   R5,VALIDTRS         Loop to test validity of this char.\n         TM    ERRASID,X'01'       After 4 chars, any errors found?\n         BO    VALIDERR            Yes. Write messages.\n         B     VALIDTRE            No. Get out of routine.\nVALIDTRR DS    0H                  Come here if invalid char found.\n         OI    ERRASID,X'01'       Flag that at least one was found.\n         MVI   0(R6),C'?'          Substitute a ? for it in message.\n         LA    R4,1(,R4)           Next translated character.\n         LA    R6,1(,R6)           Next char in error message.\n         BCT   R5,VALIDTRS         Check that character for validity.\nVALIDERR DS    0H                  Error messages if char is invalid.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(37),ASIDBADM\n         APUT  OUTPUT,45\n         B     EOJ4                Get out with code 4.\nVALIDTRE DS    0H\n         L     R4,SAVER4B          Restore regs used in this routine.\n         LM    R4,R6,SAVEWRK\n         BR    R9\n*            Constants associated with this routine.    -    below\nERRASID  DC    X'00'\nSAVEWRK  DS    3F\nMSGBADPR DC    C'Bad ASID entered. Use end parenthesis ) to delimit.'\nASIDBADM DC    CL33'Bad Characters marked with a ?:  '\nASIDWKS  DC    CL4' '\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\n* -- -- -- -- -- -- -- -- -- -- -- --    R3 points to a CSCB address\nPRNTCSCB DS    0H                  Print a CSCB entry.\n         ST    R9,SAVER9F          Save BAL register.\n         ST    R3,SAVECSCB         Saved found CSCB address.\n         USING CHAIN,R3\n*                   Print info from current CSCB\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Job  ID :'\n         MVC   OUTPUT+11(8),CHKEY\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Proc ID :'\n         MVC   OUTPUT+11(8),CHCLS\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'ASID    :'\n         HEX   OUTPUT+11,2,CHASID\n         APUT  OUTPUT,25\n         TM    FLAG2,X'40'\n         BO    PRNTCSC1\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Previous CHACT Flags:'\n         HEX   OUTPUT+23,1,CHACT\n         APUT  OUTPUT,25\n         B     PRNTCSC2\nPRNTCSC1 DS    0H\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Current  CHACT Flags:'\n         HEX   OUTPUT+23,1,CHACT\n         APUT  OUTPUT,25\nPRNTCSC2 DS    0H\n         DROP  R3\n         L     R3,SAVECSCB         Restore register to what it was.\n         L     R9,SAVER9F          Restore BAL register and\n         BR    R9                     branch back to caller.\nSAVECSCB DS    F                   Saved address of found CSCB.\n** ---------------------------------------------------------------- **\nRUNCSCB  DS    0H                  Run through the CSCB chain.\n         ST    R9,SAVER9G\n         ST    R3,SAVER3C\n         ST    R7,SAVER7A\nRUNCSCBT DS    0H\n         TM    FLAG2,X'40'         Only run if CSCB keyword was coded.\n         BZ    RUNCSCBE            Not coded, get out.\n*                                  Display this is a CSCB chain run.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(40),=C'This is a run of the CSCB Chain only ...'\n         APUT  OUTPUT,45\n         APUT  MESSAGEL,L'MESSAGEL   Print underline.\n*                                  Find the CSCB chain:\n         L     R3,16               CVT\n         L     R3,X'94'(,R3)       MSER - pointer to CSCB chain.\n         ICM   R3,15,0(R3)         First CSCB entry.\n         BZ    RUNCSCBE            If zero, end of CSCB chain.\n*                                  Otherwise points to next CSCB in\n*                                    the table.\n         USING CHAIN,R3\nRUNCSCBD DS    0H                  Loop through CSCB entries.\n         MVC   CSCBACTF(1),CHACT     Save CSCB ACT flag for this CSCB.\n         MVC   CSCBJOBI(8),CHKEY     Save CSCB JOBID (CHKEY).\n         MVC   CSCBPROC(8),CHCLS     Save CSCB PROC id (CHCLS).\n         MVC   CSCBASID(2),CHASID    Save CSCB ASID (CHASID).\n*\n* -- Limit print of entries to Jobname or ASID only ----  below\n         CLI   JOBID,C'-'          Are we printing the whole CSCB?\n         BE    RUNCSCBY            Yes.\n         CLC   ASIDBIN,=X'0000'    Was an ASID coded for a search?\n         BNE   RUNCSCB2            No. Just check for Jobname.\nRUNCSCB1 DS    0H                  Check for Jobname match.\n         XR    R7,R7               Clear work register.\n         IC    R7,SAVCOUNT         Insert saved length of Jobid.\n         BCTR  R7,0                Decrement for execute.\n         EX    R7,RUNCSCOM         Do the compare for proper length.\n*        BNE   RUNCSCBS            Not equal, don't print result.\n         BE    RUNCSCBP            Equal, print this CSCB entry.\nRUNCSCB2 DS    0H                  Check if ASID was coded.\n         CLC   ASIDBIN,CHASID      ASID match?\n         BNE   RUNCSCBS            No. Skip print of CSCB entry.\nRUNCSCBY DS    0H\n* -- Limit print of entries to Jobname or ASID only ----  above\nRUNCSCBP DS    0H                  Print this entry....\n         BAL   R9,PRNTCSCB         Print of current CSCB information.\n         BAL   R9,FORCHACT         Format some CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline line.\nRUNCSCBS DS    0H                  If skipping an entry print, go here.\n         ICM   R3,15,0(R3)         Go to next CSCB entry in table.\n         BZ    RUNCSCBE            If it is zero, end of CSCB chain.\n         B     RUNCSCBD            Not zero, loop to next entry and\n*                                    print it.\nRUNCSCBE DS    0H                  End of routine.\n         L     R3,SAVER3C          Restore\n         L     R7,SAVER7A\n         L     R9,SAVER9G             registers and\n         BR    R9                        go back to caller.\nRUNCSCOM CLC   JOBID(*-*),CHKEY   Executed\n         DROP  R3\n** ---------------------------------------------------------------- **\nKEYZERO  DS    0H                  Into Key 0 and change CSCB cntl blk.\n         ST    R9,SAVER9H\n         ST    R4,SAVER4A\n*\n* -- >  Test if this command is being run APF Authorized - below\n         STM   R15,R1,SAVE14T1     Now save registers and test if APF\n         XR    R15,R15                  authorized.\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.\n* -- >  Test if this command is being run APF Authorized - above\n*\n* -- >    ***    Do as little as possible under Key 0.    ***\nKEYPRLIM DS    0H\n         TM    ONSWIT,X'01'        Are we OR-ing?\n         BZ    SWITOFF             No. Try AND-ing?\n         MVC   CANCKEY0,CANCINDC   Pre-process affecting bits.\n         B     SWITON              All done pre-processing.\nSWITOFF  DS    0H\n         TM    ONSWIT,X'02'        Are we AND-ing?\n         BZ    KEY0BYPS            No. Don't do anything else.\n         XC    CANCINDC,=X'FF'     Reverse the affected bits for AND.\n         MVC   CANCKEY0,CANCINDC   And move them to staging area.\nSWITON   DS    0H\n         USING CHAIN,R3\n         L     R3,FOUNCSCB         Save address of \"found CSCB\".\n*\n* -- >                             We're authorized. Go Key 0.\n         MODESET KEY=ZERO\n         TM    ONSWIT,X'01'        Are we OR-ing?\n         BZ    KEY0OFF             No. Try AND-ing.\n         OC    CHACT(1),CANCKEY0   Do the OR.\n         B     KEY0END             Out of Key 0.\nKEY0OFF  DS    0H\n         TM    ONSWIT,X'02'        Are we AND-ing?\n         BZ    KEY0END             No. Get out altogether.\n         NC    CHACT(1),CANCKEY0   Do the AND.\nKEY0END  DS    0H                  Out of Key 0.\n         MODESET KEY=NZERO\n*\nKEY0BYPS DS    0H                  Key 0 bypass - branch to here.\n         DROP  R3\n         L     R4,SAVER4A\n         L     R9,SAVER9H\n         BR    R9\n** ---------------------------------------------------------------- **\nPRNWCSCB DS    0H                  Print the changed CSCB entry.\n         ST    R9,SAVER9I          Save BAL register.\n         ST    R3,SAVER3D\n         L     R3,FOUNCSCB         Saved found CSCB address.\n         USING CHAIN,R3\n*                   Print info from changed CSCB.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Job  ID :'\n         MVC   OUTPUT+11(8),CHKEY\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Proc ID :'\n         MVC   OUTPUT+11(8),CHCLS\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'ASID    :'\n         HEX   OUTPUT+11,2,CHASID\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Modified CHACT Flags:'\n         HEX   OUTPUT+23,1,CHACT\n         APUT  OUTPUT,25\n         APUT  MESSAGEL,L'MESSAGEL\n         DROP  R3\n         L     R3,SAVER3D          Restore register to what it was.\n         L     R9,SAVER9I          Restore BAL register and\n         BR    R9                     branch back to caller.\n** ---------------------------------------------------------------- **\nFORCHACT DS    0H                  Format the CHACT Flags\n         ST    R9,SAVER9J          Save\n         ST    R3,SAVER3E             registers.\n         USING CHAIN,R3\nFORCANC0 DS    0H                  Show cancelable or not.\n         TM    CHACT,CHCL          Is job cancelable?\n         BO    FORCANC1            Yes, show cancelable.\n         BZ    FORCANC2            No. Show non-cancelable.\n         B     FORFORC0            Fall through, try forceable.\nFORCANC1 DS    0H\n         MVC   MESSTXT,MESSCAN     Tell em job is cancelable.\n         B     FORCANCP\nFORCANC2 DS    0H\n         MVC   MESSTXT,MESSNCN     Tell em job is non-cancelable.\nFORCANCP DS    0H                  Write the actual message out.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(28),FORMTMSG\n         APUT  OUTPUT,30\nFORFORC0 DS    0H                  Show forceable or not.\n         TM    CHACT,CHAFORCE      Is job forceable?\n         BO    FORFORC1            Yes, show forceable.\n         BZ    FORFORC2            No. Show non-forceable.\nFORFORC1 DS    0H\n         MVC   MESSTXT,MESSFOR     Tell em job is forceable.\n         B     FORFORCP\nFORFORC2 DS    0H\n         MVC   MESSTXT,MESSNFR     Tell em job is non-forceable.\nFORFORCP DS    0H                  Write the actual message out.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(28),FORMTMSG\n         APUT  OUTPUT,30\nFORCHEND DS    0H\n         DROP  R3\n         L     R3,SAVER3E          Restore\n         L     R9,SAVER9J             registers.\n         BR    R9\n*            Constants associated with this routine.    -    below\nMESSCAN  DC    CL14'Cancelable    '\nMESSNCN  DC    CL14'Non-Cancelable'\nMESSFOR  DC    CL14'Forcible      '\nMESSNFR  DC    CL14'Non-Forcible  '\nFORMTMSG DS    0CL28\nMESS000  DC    CL14'Job Status:   '\nMESSTXT  DC    CL14'              '\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\nPRINTERR DS    0H                    Print help messages.\n         ST    R9,SAVER9K            Save BAL register.\n         APUT  MESSAG2A,L'MESSAG2A\n         APUT  MESSAG2B,L'MESSAG2B\n         APUT  MESSAG2C,L'MESSAG2C\n         APUT  MESSAG2D,L'MESSAG2D\n         APUT  MESSAG2E,L'MESSAG2E\n         APUT  MESSAG2F,L'MESSAG2F\n         APUT  MESSAGEM,L'MESSAGEM\n         APUT  MESSAG2G,L'MESSAG2G\n         APUT  MESSAG2H,L'MESSAG2H\n         APUT  MESSAGEM,L'MESSAGEM\n         APUT  MESSAG2I,L'MESSAG2I\n         APUT  MESSAG2J,L'MESSAG2J\n         APUT  MESSAG2K,L'MESSAG2K\n         APUT  MESSAG2L,L'MESSAG2L\n         APUT  MESSAG2M,L'MESSAG2M\n         APUT  MESSAG2N,L'MESSAG2N\n         APUT  MESSAG2O,L'MESSAG2O\n         APUT  MESSAG2P,L'MESSAG2P\n         APUT  MESSAG2Q,L'MESSAG2Q\n         APUT  MESSAG2R,L'MESSAG2R\n         APUT  MESSAG2S,L'MESSAG2S\n         APUT  MESSAG2T,L'MESSAG2T\n         APUT  MESSAGEM,L'MESSAGEM\n         L     R9,SAVER9K            Restore BAL register.\n         BR    R9\n** ---------------------------------------------------------------- **\n** --         C  O  N  S  T  A  N  T  S                          -- **\n** ---------------------------------------------------------------- **\nMESSAGNA DC    C'Command was not invoked APF authorized.'\nMESSAGEN DC    C'End of CSCB chain was reached.'\nMESSAGEY DC    C'No valid keyword was coded.'\nFLAG1    DC    X'00'\n*              X'01'               ASID ONLY - NO JOBNAME\n*              X'02'               JOBNAME IS PRESENT.\n*              X'04'               ASID( WAS PRESENT IN PARMS.\n*              X'08'               CSCB CHAIN DISPLAY ONLY.\nFLAG2    DC    X'00'\n*              X'01'               CNCL WAS CODED\n*              X'02'               NCNC WAS CODED\n*              X'04'               SWAP WAS CODED\n*              X'08'               NSWP WAS CODED\n*              X'10'               FORC WAS CODED\n*              X'20'               CSCB WAS CODED\nONSWIT   DC    X'00'\n*              X'01'               TURN BIT ON\n*              X'02'               TURN BIT OFF\nHEXSAVE  DS    3F                  SAVE FOR HEX MACRO\nSAVE     DS    9D                  Program Save Area\nSAVE14T1 DS    2D                  Save \"system-used\" registers.\n         DC    C' '                Blank before OUTPUT line.\nOUTPUT   DC    CL80'  '            Variable output line.\n         LTORG\n** ---------------------------------------------------------------- **\n         SPACE\n         TITLE '- MAPPING MACROS.'\n         CVT   DSECT=YES           Map the CVT.\n         IEECHAIN                  Map the CSCB control block.\n         END   CNCLPG\n** ---------------------------------------------------------------- **\n*  -----------------------------------------------------------------  *\n*  --           Create PUTLINE environment.                       --  *\n*  -----------------------------------------------------------------  *\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUEMNTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   128                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         EJECT\n         IHAPSA   LIST=YES                                     HD APR88\n         EJECT                                                 HD APR88\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   14,12,12(13)       SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES            RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    1,8(13)            OUR SAVE AREA POINTER\n         ST    13,4(1)            POINTER TO CALLERS SAVE AREA\n         LR    13,1               @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(R13)         POINT TO CALLERS RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 ASSUME BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 ASSUME BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(RML)               MESSAGE LENGTH\n         STH   R15,PUTLEN                 PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    2,R13                    @OUR SAVE AREA\n         LR    3,R15                    SAVE RETURN CODE\n         L     R13,4(R13)               @CALLERS SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,3                    RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CNCLPG11": {"ttr": 2569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00A\\x01\\x11)\\x8f\\x01\\x17\\x13o\\x14)\\x063\\x06 \\x00\\x00\\xe5\\xf1\\xd9\\xf1\\xd4\\xf1@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2011-10-25T00:00:00", "modifydate": "2017-05-16T14:29:41", "lines": 1587, "newlines": 1568, "modlines": 0, "user": "V1R1M1"}, "text": "CNCLPG   TITLE 'Make address space cancelable, non-swappable, etc. '\n*  -----------------------------------------------------------------  *\n*                                                                     *\n*    Function:   To make an address space Cancelable or               *\n*                Non-cancelable, Forcible or Non-forcible,            *\n*                Swappable or Non-swappable.                          *\n*                                                                     *\n*                This is determined by bit settings in the address    *\n*                space's CSCB.                                        *\n*                                                                     *\n*    Syntax:     TSO Command:  APF-authorized.                        *\n*                                                                     *\n*        CNCLPG |jobid \u00ddASID(hhhh)\u00a8 |CNCL|NCNC|FORC|NFRC|NSWP|SWAP    *\n*               |ASID(hhhh)         |CNCL|NCNC|FORC|NFRC|NSWP|SWAP    *\n*               |                   |CSCB or DISP                     *\n*               |-  (displays the entire CSCB chain)                  *\n*               |?  (displays help)                                   *\n*                                                                     *\n*    Date:       April 15, 2010                                       *\n*                                                                     *\n*    Author:     Sam Golob                                            *\n*                                                                     *\n*    Technical Detail:  PUTLINE interface for TSO Output.             *\n*                                                                     *\n*                                                                     *\n*    Changes:  1.  SWAP, NSWP support dropped from this program.      *\n*                   Version is 1.0.0                                  *\n*                                                                     *\n*              2.  Messages and DISP improved, to just show matching  *\n*                   CSCB chain entries, instead of all of them.       *\n*                   - will show the entire CSCB chain.                *\n*                                                                     *\n*              3.  SWAP, NSWP support put back in this program.       *\n*                   Version is 1.1.0   (June 16, 2010)                *\n*                   It now does your own address space.  The cross    *\n*                   memory stuff was not put in yet, for other        *\n*                   address spaces.                                   *\n*                                                                     *\n*   change   pgmr                   description                       *\n*   -------  -----   ----------------------------------------------   *\n*                                                                     *\n*            joer     Add SRB code to allow swapping in xmem          *\n*  -----------------------------------------------------------------  *\n*  This macro lets you display hex values in a report.\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    STM   R15,R1,HEXSAVE           Save work registers.\n         LA    R1,&FROM                 Load from address.\n         LA    R0,&LEN                  Load length of hex number.\n         LA    R15,&TO                  Load to address.\n         BAL   R9,HEX                   BAL to routine.\n         LM    R15,R1,HEXSAVE           Restore work registers.\n         MEND\n*  -----------------------------------------------------------------  *\n*  --           Create PUTLINE environment.                       --  *\n*  -----------------------------------------------------------------  *\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\n* --       End of Internal Macros......                            -- *\n* ------------------------------------------------------------------- *\n         SPACE 3\nCNCLPG   CSECT\nCNCLPG   AMODE 31\nCNCLPG   RMODE ANY\n         YREGS\n         USING CNCLPG,R15          (Establish temporary base).\n         B     BEGIN               Skip over eyecatcher.\nEYEC0    DC    AL1(EYECL)          Exclusive length of header.\nEYEC     DC    C' CNCLPG - &SYSDATE - &SYSTIME -'\n         DC    C'     --------------------------------    '\n         DC    C' VER 1.1.0   '\n         DC    C'                   '\nEYECL    EQU   *-EYEC\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)     Save caller's registers\n         LR    R6,R1               Preserve CPPL pointer.\n         LR    R12,R15             Copy base.\n         USING CNCLPG,R12,R11,R10  (Tell assembler).\n         LA    R11,4095(,R12)      Load bases.\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)\n         LA    R10,1(,R10)\n         LR    R14,R13             Copy caller's save area pointer.\n         LA    R13,SAVE            Point to my save area.\n         ST    R13,8(,R14)         Chain ...\n         ST    R14,SAVE+4          ... Save areas.\n         SPACE 1\nAUTHTEST DS    0H\n         ST    R1,SAVER1A\n         L     R1,16               CVTPTR\n         L     R1,0(,R1)           TCB WORDS\n         L     R1,4(,R1)           CURRENT TCB\n         L     R1,180(,R1)         TCBJSCB\n         L     R1,264(,R1)         JSCBPSCB\n         LA    R1,0(,R1)           CLEAR HI ORDER BYTE\n         LTR   R1,R1               IS THERE A PSCB\n         BZ    NOTFOUND            NO, ISSUE COMMAND-NOT-FOUND MSG\n         TM    X'10'(R1),X'80'     PSCB OPER AUTHORITY?\n         BZ    NOTFOUND            NO, ISSUE COMMAND-NOT-FOUND MSG\n         L     R1,SAVER1A\nINITCON  DS    0H                  Initialize some constants.\n         MVI   FLAG1,X'00'\n         MVI   FLAG2,X'00'\n         MVI   ONSWIT,X'00'\n         MVI   ERRASID,X'00'\n         MVI   CANCINDC,X'00'\n         MVI   OUTPUT-1,X'40'\n         MVC   OUTPUT,OUTPUT-1\n         MVI   NEWCHACT,X'00'\n*        B     TEST                TEST CODE\nMYASID   DS    0H                  Get my ASID\n         L     R2,X'224'           Point to PSAAOLD (my ASCB)\n         LA    R2,X'24'(,R2)       Point to my own ASID (ASCBASID)\n         MVC   OWNASID(2),0(R2)    Save it for comparison later\n         B     PRTITLE             Branch past constant\nOWNASID  DS    H\nPRTITLE  DS    0H                  Print program title.\n         APUT  MESSAGET,L'MESSAGET\n         APUT  MESSAGEU,L'MESSAGEU\nCONT0    DS    0H                  Look at command's parameters.\n         LTR   R6,R6               Any CPPL?\n         BZ    EOJ8                No.  Get out.\n         L     R1,0(,R6)           Pt to cmd buffer. (R6 reused later)\n         LTR   R1,R1               Any CMD buffer?\n         BZ    EOJ8                Get out if none.\n         LH    R3,0(,R1)           Load length.\n         CH    R3,=H'4'            Anything?\n         BNH   EOJ4                No. Get out.\n         LR    R5,R3               Length of command + 4\n         ICM   R5,14,FULLZERO      Clear hi order 3 bytes.\n         LH    R3,2(,R1)           Load offset.\n         SR    R5,R3               Subtract offset from full length+4\n         SH    R5,=H'4'            Correct for length of cmdbufr header\n         BC    8,WMESS2            Zero, message to enter userid.\n         BC    5,EOJ8              Less, or overflow, out.\nPARM     DS    0H\n         BAL   R9,GETIDS           Get parameters for the command.\n         B     EOJ0\n*\n* --- Parms gotten at this point.                            -------- *\n*\n** ---------------------------------------------------------------- **\nWMESS2   DS    0H                  Print help messages.\n         BAL   R9,PRINTERR\n         B     EOJ4\n** ---------------------------------------------------------------- **\nEOJ0     DS    0H                  End of job.\n         APUT  RETURN0,L'RETURN0\n         LA    R15,0               Set CC = 0.\n         B     RETURN\nEOJ4     DS    0H\n         APUT  RETURN4,L'RETURN4\n         LA    R15,4               Set CC = 4.\n         B     RETURN\nEOJ8     DS    0H\n         APUT  RETURN8,L'RETURN8\n         LA    R15,8               Set CC = 8.\n         B     RETURN\nRETURN   L     R13,SAVE+4\n         L     R14,12(,R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n** ---------------------------------------------------------------- **\nNOTAUTH  DS    0H                  Command not APF authorized message.\n         APUT  MESSAGNA,L'MESSAGNA\n         B     EOJ4\n** ---------------------------------------------------------------- **\nNOTFOUND DS    0H                  Command NOT ALLOWED message.\n         APUT  MESSAGAU,L'MESSAGAU\n         B     RETURN\n** ---------------------------------------------------------------- **\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        Get the parameters for the command.                      *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*   Notes:  The ASID(xxx) can be coded first, without a userid.   *\n*           A dash can be coded first, to run the entire CSCB     *\n*            chain and display all the jobnames in it, with       *\n*            their associated ASIDs.  ? coded first gives HELP.   *\n*           If you code the word CSCB or DISP(lay) after either   *\n*            a jobname or an ASID(hhhh) then a display of the     *\n*            matching CSCB chain entries will be displayed, and   *\n*            no changes will be made.                             *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETIDS   DS    0H                  Get all parameters for the program.\n         ST    R9,SAVER9A\n         ST    R4,SAVER4C\n         AR    R1,R3               Point ...\n         LA    R1,4(,R1)           ... to char.\n         LA    R6,8                Load reg for BCT loop.\n         LR    R7,R1               Initialize pointer to first\n         LA    R7,0(,R7)                character of the ID field.\n         LA    R8,0                Initialize character count.\n         MVC   JOBID(8),BLANKS     Clear (first param - JOBNAME) field.\n         LA    R4,JOBID            Point reg to beginng of JOBID field.\n*\nCUTIDLEN DS    0H                  Look at the JOBID field first.\n*                                  (May contain ASID( or CSCB.)\n*\n         CLI   0(R7),X'40'         Is this character a blank?\n         BE    NOMORCUT            Yes, we are at the end of the field.\n         MVC   0(1,R4),0(R7)       Move only one character at a time.\n         OC    JOBID(8),BLANKS     And uppercase the partial jobid.\n*\n*   Is this a run of the CSCB chain only?\n* -- >  Test for CSCB  first  ---- below\n         CLI   JOBID,C'-'          Did we code '-' first?\n         BNE   CSCBHELP            No. Try if help asked for.\n         B     CSCBRUN1            Yes. Run entire CSCB chain.\n* - > Help\nCSCBHELP DS    0H\n         CLI   JOBID,C'?'          Help?\n         BNE   NOCSCB              No. Skip this code.\n         BAL   R9,PRINTERR         Yes. Print messages\n         B     EOJ0                  and get out with code 0.\n* - > Help\nCSCBRUN1 DS    0H\n         ST    R8,SAVER8A          Store count for display if needed.\n         OI    FLAG2,X'40'         Mark that this is CSCB only run.\n         BAL   R9,RUNCSCB          Do the run for CSCB chain.\n         B     EOJ0                Out with normal return code.\nNOCSCB   DS    0H\n* -- >  Test for CSCB  first  ---- above\n*\n*   Was the ASCB(hhh) parameter coded without the jobid?\n* -- >  Test for ASID( first  ---- below\n         CLC   JOBID(L'ASIDC),ASIDC  Did we code ASID( in jobid field?\n         BNE   NOASIDF             No. Pass this code.\n         OI    FLAG1,X'01'         Flag that ASID( ) was first.\n         NI    FLAG1,X'FF'-X'02'   Turn off Jobname in jobid field flag\n         MVC   ASIDWKL(L'ASIDC),JOBID  Move the ASID( to proper field.\n         MVC   JOBID,BLANKS        Blank out Job ID if ASID( coded.\n         LA    R7,1(,R7)           Bump another character.\n         LA    R8,1(,R8)           Count another character.\n         LA    R6,1                Set number of branches later.\n*                                  This will limit number of params\n*                                   that are searched for.\n         B     ASIDONLY            Bypass all the real jobname stuff.\n* -- >  Test for ASID( first  ---- above\nNOASIDF  DS    0H                  ASID( is not the first parameter.\n         LA    R4,1(,R4)           Bump another character.\n         LA    R7,1(,R7)           Bump another character.\n         LA    R8,1(,R8)           Count another character.\n         CR    R8,R5               End of command buffer ?\n         BNL   NOMORCUT            Yes. Get out now.\n         BCT   R6,CUTIDLEN         Try for the next blank, up till 8.\nNOMORCUT DS    0H\n         STC   R8,SAVCOUNT         Save length of Jobname\n         L     R4,SAVER4C          Restore work register for use later.\n         OC    JOBID(8),BLANKS     Uppercase the new Job Id.\n         OI    FLAG1,X'02'         Set 'Jobname Coded' flag.\n*  -  Display the found JOBID - below\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Search Jobname:'\n         MVC   OUTPUT+17(8),JOBID\n         APUT  OUTPUT,30\n         APUT  MESSAGEL,L'MESSAGEL\n*  -  Display the found JOBID - above\n         LA    R6,1                Set number of branches later.\n*                                  This will limit number of params\n*                                   that are searched for.\n         B     LOOKKEYW\n*  Constants - below - ***\nJOBID    DC    C'        '         STORE PARM USERID HERE\nBLANKS   DC    C'        '         8 BLANKS\nMESSAGET DC    C'CNCLPG - Make a Job, STC or TSU Cancelable, etc. (? foX\n               r help)'\nMESSAGEU DC    C'------ - ---- - ---- --- -- --- ----------- ----'\nMESSAGEL DC    C'----------------------------'\nMESSAGEM DC    C'-----------------------------------------------'\nMESSAG2A DC    C'Enter JOBNAME and/or ASID(hhhh) after COMMAND name,'\nMESSAG2B DC    C'   then CNCL, NCNC, FORC, NFRC, or code CSCB or DISP.'\nMESSAG2C DC    C'   DISPlay or CSCB will display CSCB chain entries,'\nMESSAG2D DC    C'   without changing them.'\nMESSAG2E DC    C' When changing a job, we want to be accurate, '\nMESSAG2F DC    C'  therefore you should use the DISPlay option first.'\nMESSAG2G DC   C' To display the whole CSCB, code - (dash) for JOBNAME.'\nMESSAG2H DC    C' To see this help message, code ? for JOBNAME.'\nMESSAG2I DC    C'Notes : '\nMESSAG2J DC   C' CSCB (DISP) display for an ASID shows all occurrences'\nMESSAG2K DC    C'  for that ASID, regardless of JOBNAME.      '\nMESSAG2L DC C' CSCB (DISP) display for a JOBNAME shows all occurrences'\nMESSAG2M DC    C'  for that JOBNAME, regardless of ASID.      '\nMESSAG2N DC    C' CNCL, NCNC, FORC, NFRC will change the first '\nMESSAG2O DC    C'  entry in the CSCB chain that matches, if multiple '\nMESSAG2P DC    C'  entries exist. But DISP will display ALL applicable'\nMESSAG2Q DC    C'  matching entries in the CSCB chain, so you can see'\nMESSAG2R DC    C'  which one you want to change specifically.'\nMESSAG2S DC    C' When you code BOTH jobname and asid, to CHANGE it,'\nMESSAG2T DC    C'  then ONLY that specific job and asid gets changed.'\nMESSAGE3 DC    C'WE GOT HERE'\nMESSAGE4 DC    C'TEST CHECK THIS'\nMESSAGNG DC    C'Job was not done. SYSEVENT return code was     '\nMESSAGNS DC    C'Job xxxxxxxx was made non-swappable.'\nMESSAGSW DC    C'Job xxxxxxxx was made swappable.'\nMESSAGAN DC    C'Job xxxxxxxx was already non-swappable.'\nMESSAGAS DC    C'Job xxxxxxxx was already swappable.'\nMESSAGFN DC    C'Function xxxx was called for.'\nMESSAGAU DC    C'IKJ56500I COMMAND CNCLPG NOT FOUND'\nRETURN0  DC    C'Return code is 0'\nRETURN4  DC    C'Return code is 4'\nRETURN8  DC    C'Return code is 8'\n*                     ***  Places to save registers  ***  below\nSAVER1A  DS    F\nSAVER3A  DS    F\nSAVER3B  DS    F\nSAVER3C  DS    F\nSAVER3D  DS    F\nSAVER3E  DS    F\nSAVER4A  DS    F\nSAVER4B  DS    F\nSAVER4C  DS    F\nSAVER5A  DS    F\nSAVER6A  DS    F\nSAVER6B  DS    F\nSAVER7A  DS    F\nSAVER8A  DS    F\nSAVER9A  DS    F\nSAVER9B  DS    F\nSAVER9C  DS    F\nSAVER9D  DS    F\nSAVER9E  DS    F\nSAVER9F  DS    F\nSAVER9G  DS    F\nSAVER9H  DS    F\nSAVER9I  DS    F\nSAVER9J  DS    F\nSAVER9K  DS    F\nSAVER9L  DS    F\nSAVER9M  DS    F\nSAVER9N  DS    F\nSAVER9O  DS    F                                                    JOE\nSAVESRB  DS    F                                                    JOE\n*                     ***  Places to save registers  ***  above\nSAVCOUNT DS    X\nDUBLZERO DC    D'0'\nFULLZERO DC    F'0'\nCANCINDC DC    X'00'\nCANCKEY0 DC    X'00'\nNEWCHACT DC    X'00'\n*  Constants - above - ***\nLOOKKEYW DS    0H                  Look for additional keywords.\n         LA    R7,1(,R7)           Bump command buffer pointer.\n         LA    R8,1(,R8)           Bump character counter.\n         CR    R8,R5               End of command buffer?\n         BNL   GETIDEND            Yes. Don't look any more.\n         MVC   ASIDWKL(5),BLANKS   Clear parameter work field.\n         MVC   ASIDWKL(5),0(R7)    Next 5 characters to work field.\nASIDONLY DS    0H                  Jump to here if ASID( coded first.\n         OC    ASIDWKL(4),BLANKS   Uppercase work field.\n         CLC   ASIDC,ASIDWKL       Is the ASID( keyword there?\n         BE    DOASID              Yes. Process it.\n         CLC   CNCLC,ASIDWKL       Is the CNCL  keyword there?\n         BE    DOCNCL              Yes. Process it.\n         CLC   NCNCC,ASIDWKL       Is the NCNC  keyword there?\n         BE    DONCNC              Yes. Process it.\n         CLC   SWAPC,ASIDWKL       Is the SWAP  keyword there?\n         BE    DOSWAP              Yes. Process it.\n         CLC   NSWPC,ASIDWKL       Is the NSWP  keyword there?\n         BE    DONSWP              Yes. Process it.\n         CLC   FORCC,ASIDWKL       Is the FORC  keyword there?\n         BE    DOFORC              Yes. Process it.\n         CLC   NFRCC,ASIDWKL       Is the NFRC  keyword there?\n         BE    DONFRC              Yes. Process it.\n         CLC   CSCBC,ASIDWKL       Is the CSCB  keyword there?\n         BE    DOCSCB              Yes. Process it.\n         CLC   DISPC,ASIDWKL       Is the DISP  keyword there?\n         BE    DOCSCB              Yes. Process it.\n         B     LOOKKEYW            Go loop and look at next character.\nASIDWKL  DC    CL5' '              Second parameter work area.\n*\nASIDC    DC    C'ASID('            Literals....\nCNCLC    DC    C'CNCL'\nNCNCC    DC    C'NCNC'\nSWAPC    DC    C'SWAP'\nNSWPC    DC    C'NSWP'\nFORCC    DC    C'FORC'\nNFRCC    DC    C'NFRC'\nCSCBC    DC    C'CSCB'\nDISPC    DC    C'DISP'\n*\nDOASID   DS    0H                  Look for hex value of the ASID.\n         OI    FLAG1,X'04'         Show that ASID( was coded.\n         BAL   R9,GETASID          Go get the rest of the parameters.\n         MVC   ASIDWKL(5),BLANKS   Blank out the second wkarea for\n*                                   a further parameter search.\n         B     LOOKKEYW            Re-loop to look further for params.\n*\nDOCNCL   DS    0H                  Handle CNCL (cancelable) keyword.\n         OI    CANCINDC,X'08'      Show which CHACT bit is affected.\n         OI    FLAG2,X'01'         Show that CNCL was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'01'        Set to OR the bits\n         NI    ONSWIT,X'FF'-X'02'   and not to AND the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n* ------------------------------------------------------------------- *\n*                                    Print the action code.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),CNCLC\n         APUT  OUTPUT,25\n*                                    Print the bit in CHACT affected.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDONCNC   DS    0H                  Handle NCNC (non-cancelable) keyword\n         OI    CANCINDC,X'08'      Show which CHACT bit is affected.\n         OI    FLAG2,X'02'         Show that NCNC was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'02'        Set to AND the bits\n         NI    ONSWIT,X'FF'-X'01'   and not to OR the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n*                                    Print the action code.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),NCNCC\n         APUT  OUTPUT,25\n*                                    Print the bit in CHACT affected.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDOSWAP   DS    0H                  Not active yet.\n         OI    FLAG2,X'04'\n         MVC   MESSAGFN+9(4),SWAPC\n         APUT  MESSAGFN,L'MESSAGFN\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         BAL   R9,KEY0SWNS\n         BCT   R6,LOOKKEYW\n         B     GETIDEND\n* ------------------------------------------------------------------- *\nDONSWP   DS    0H                  Not active yet.\n         OI    FLAG2,X'08'\n         MVC   MESSAGFN+9(4),NSWPC\n         APUT  MESSAGFN,L'MESSAGFN\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         BAL   R9,KEY0SWNS\n         BCT   R6,LOOKKEYW\n         B     GETIDEND\n* ------------------------------------------------------------------- *\nDOFORC   DS    0H                  Handle FORC (forcible) keyword\n         OI    FLAG2,X'10'         Show which CHACT bit is affected.\n         OI    CANCINDC,X'01'      Show that FORC was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'01'        Set to OR the bits\n         NI    ONSWIT,X'FF'-X'02'   and not to AND the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n*\n         MVC   OUTPUT,OUTPUT-1       Print the action code.\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),FORCC\n         APUT  OUTPUT,25\n*\n         MVC   OUTPUT,OUTPUT-1       Print the bit in CHACT affected.\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDONFRC   DS    0H                  Handle NFRC (non-forcible) keyword\n         OI    FLAG2,X'20'         Show which CHACT bit is affected.\n         OI    CANCINDC,X'01'      Show that NFRC was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'02'        Set to AND the bits\n         NI    ONSWIT,X'FF'-X'01'   and not to OR the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n*\n         MVC   OUTPUT,OUTPUT-1       Print the action code.\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),NFRCC\n         APUT  OUTPUT,25\n*\n         MVC   OUTPUT,OUTPUT-1       Print the bit in CHACT affected.\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDOCSCB   DS    0H\n         OI    FLAG1,X'08'         Show CSCB keyword was coded.\n         OI    FLAG2,X'40'         Show CSCB keyword was coded.\n         MVC   OUTPUT,OUTPUT-1       Print the action code.\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),CSCBC\n         MVC   OUTPUT+23(9),=C'(DISPlay)'\n         APUT  OUTPUT,35\n         BAL   R9,RUNCSCB          Run the CSCB chain with print.\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nGETIDEND DS    0H                  End of keyword processing.\n         TM    FLAG2,X'7F'         Check if any real actions were asked\n         BM    GETKEYNR            Yes, some were.\n         APUT  MESSAGEY,L'MESSAGEY    No. Display help messages.\n         BAL   R9,PRINTERR\n         B     EOJ4                   And end with code = 4.\nGETKEYNR DS    0H                  Real actions WERE asked for.\n         B     EOJ0                So end with normal return code.\n         L     R9,SAVER9A\n         BR    R9\n** ---------------------------------------------------------------- **\nHEX      DS    0H                  Display hex values.\n         ST    R9,SAVER9B\n         MVC   1(1,R15),0(R1)      Move byte.\n         UNPK  0(3,R15),1(2,R15)   Unpack.\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)         Increment output pointer.\n         LA    R1,1(,R1)           Increment input pointer.\n         BCT   R0,HEX              Decrement length, then loop.\n         MVI   0(R15),C' '         Blank the trailing byte.\n         L     R9,SAVER9B\n         BR    R9                  Return to caller.\nHEXTAB   DC    C'0123456789ABCDEF' Translate table.\n** ---------------------------------------------------------------- **\nGETASID  DS    0H                  Get hex ASID for 2 bytes.\n         ST    R9,SAVER9C          Save registers.\n         STM   R1,R6,SAVERGS1\n         LA    R6,4                Load BCT register.\n         LA    R4,ASIDWK           Point to ASID work area.\n         TM    FLAG1,X'02'         Ask if Job name was coded.\n         BZ    GETAFL01            Wasn't. Have to adjust pointers.\n         LA    R7,5(,R7)           Bump command buffer pointer.\n         LA    R8,5(,R8)           Bump character counter.\nGETAFL01 DS    0H\nGETASIDL DS    0H                  Loop to get hex ASID for 4 display\n*                                    bytes to convert to 2 hex bytes.\n         CLI   0(R7),C')'          Have we reached close parenthesis?\n         BE    GETASIDG            Yes, assume we've got it.\n         CLI   0(R7),C' '          Have we hit a blank?\n         BE    GETASIDG            Yes, assume we've got it.\n         MVC   0(1,R4),0(R7)       Otherwise move one character over.\n         LA    R4,1(,R4)           Bump one ASIDWK character (target)\n         LA    R7,1(,R7)           Bump command buffer pointer.\n         LA    R8,1(,R8)           Bump character counter.\n         BCT   R6,GETASIDL         Loop for 4 characters.\n         B     GETASIDG            We don't look for more than 4.\nGETASIDG DS    0H\n*        APUT  ASIDWK,4\n         LA    R4,ASIDWK           Point register at workarea again.\n         LA    R1,4                Maximum of 4 characters.\nGETASIDA DS    0H\n         CLI   3(R4),X'40'         Is last character a blank (<4 total)\n         BNE   GETASIDM            No. We're finished sliding.\n         BCTR  R4,0                Slide the pointer one place back.\n         BCT   R1,GETASIDA         Do it no more than 4 times.\nGETASIDM DS    0H\n         MVC   ASIDMV(4),0(R4)     Move 4 characters so last one\n*                                     is not blank.\n         MVC   ASIDWKSV(4),ASIDMV    Save these 4 characters\n         MVC   ASIDWKS(4),ASIDMV        in two places.\n         MVC   OUTPUT,OUTPUT-1       Clear output line.\n         MVC   OUTPUT(25),ASIDMSG    Move coded display format asid.\n         APUT  OUTPUT,40             And put out the message.\n         TR    ASIDMV(4),ASIDVAL     Translate display format message\n*                                      into format X'0h0h0h0h'.\n*        MVC   OUTPUT,OUTPUT-1       Test display of hex result.\n*        HEX   OUTPUT,4,ASIDMV\n*        APUT  OUTPUT,10\n         BAL   R9,VALIDTR            Validity check the hex number.\n         PACK  ASIDGET(3),ASIDMV(5)  Get rid of all zone nibbles.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Search ASID   :' Print resulting 2-bytes\n         HEX   OUTPUT+21,2,ASIDBIN\n         APUT  OUTPUT,30\n         APUT  MESSAGEL,L'MESSAGEL   Add underline for clear display.\n*\nGETASIDE DS    0H                    End of routine.\n         LM    R1,R6,SAVERGS1        Restore registers\n         L     R9,SAVER9C               and\n         BR    R9                          exit.\n** ---------------------------------------------------------------- **\n*\n*  Input:\n*      FOUNASID = ASID\n*  OutPut:\n*      r15 = 0    Error\n*      r15 = ASCB\n** ---------------------------------------------------------------- **\nGETASCB  DS    0H                                                   JOE\n         ST    R9,SAVER9D            Save Register                  JOE\n         L     R15,CVTPTR            R15 -> cvt                     JOE\n         L     R15,CVTASVT-CVT(,R15)  R15 -> asvt                   JOE\n         USING ASVT,R15                                             JOE\n         CLC   ASVTASVT-ASVT(4,R15),=C'ASVT'  check eyecatcher      JOE\n         BNE   NOASCB                                               JOE\n         LA    R15,ASVTENTY-ASVT(,R15) Get first asvt slot          JOE\n         LH    R0,FOUNASID           Get asid in question           JOE\n         BCTR  R0,0                  Down By 1                      JOE\n         SLL   R0,2                  Multiply by 4                  JOE\n         AR    R15,R0                Point to ASCB                  JOE\n         BR    R9                                                   JOE\nNOASCB   DS    0H                                                   JOE\n         XR    R15,R15               Clear r15                      JOE\n         BR    R9\nASIDWKB  DC    CL4'    '\nASIDWK   DC    CL4'    '\nASIDWKF  DC    CL4' '\nASIDMV   DC    CL4'    '\nASIDMVF  DC    CL4' '\nASIDBIN  DS    0XL2\nASIDGET  DC    XL4'00000000'\n\nSAVERGS1 DS    6F\n*                   Translate table to validity check ASID.\n*                     Convert display values to X'0h'\n*                     (where h is the hex value).\nASIDVAL  DS    0D\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'00CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CC0A0B0C0D0E0FCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CC0A0B0C0D0E0FCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'00010203040506070809CCCCCCCCCCCC'\nFILLER1  DS    CL24\nASIDMSG  DC    CL21'ASID parm entered  : '\nASIDWKSV DC    CL4' '\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\nFINDCSCB DS    0H                  Find CSCB entry to change or report.\n         ST    R9,SAVER9D          Save registers.\n         ST    R3,SAVER3A\nFINDCSST DS    0H                  Get the first CSCB.\n         L     R3,16               CVT\n         L     R3,X'94'(,R3)       MSER - pointer to CSCB chain.\n         ICM   R3,15,0(R3)         First CSCB entry.\n         USING CHAIN,R3            Tell assembler.\n         BZ    FINDCSEC            If zero, we are at end of CSCB chain\nFINDCSLP DS    0H                  Loop through the CSCB entries.\n         MVC   CSCBACTF(1),CHACT     Save CSCB ACT flag for this CSCB.\n         MVC   CSCBJOBI(8),CHKEY     Save CSCB Jobid (CHKEY).\n         MVC   CSCBPROC(8),CHCLS     Save CSCB PROC id (CHCLS).\n         MVC   CSCBASID(2),CHASID    Save CSCB ASID (CHASID).\n* ------------------------------------------------------------------- *\n* We first try to match a JOBID if coded, to the job id in this CSCB. *\n* If equal, we see if an ASID has been coded, and both have to match. *\n* Otherwise, with no match, we go to the end of the CSCB chain.       *\n* ------------------------------------------------------------------- *\nFINDCSMY DS    0H                  Find the CSCB that I want.\n         TM    FLAG1,X'04'         Was ASID( coded at all?\n         BZ    FINDCSJB            No. Just find a JOBID match.\n         TM    FLAG1,X'01'         Is the JOB id missing?\n         BO    FINDCSAS            Yes, just look for an ASID match.\n         TM    FLAG1,X'02'         Was JOB id coded?\n         BO    FINDCSJB            Yes. Look for it.\n         ICM   R3,15,0(R3)         Go to next CSCB.\n         BZ    FINDCSEC            If zero, we are at end of CSCB chain\n         B     FINDCSLP            Look at next CSCB entry in table.\nFINDCSJB DS    0H                  Check for JOBID match in this CSCB.\n         CLC   JOBID(8),CSCBJOBI   Compare coded JOBID to CSCB jobname.\n         BE    FINDCSIA            Equal, check if ASID is there.\n         ICM   R3,15,0(R3)         Otherwise go to the next CSCB.\n         BZ    FINDCSEC            Zero, end of the CSCB chain.\n         B     FINDCSLP            Not zero, look at the next entry.\nFINDCSIA DS    0H\n         TM    FLAG1,X'04'         Was ASID( coded?\n         BZ    FINDCSFD            No. Found it on just a job match.\n*                                   So this is the first job that\n*                                   matched, if there are multiple\n*                                   jobs with the same name.\nFINDCSAS DS    0H                  Check the ASID in the CSCB.\n         CLC   ASIDBIN(2),CSCBASID Is this our ASID? Does it match.\n         BE    FINDCSFD            I guess we found it.\n         ICM   R3,15,0(R3)         Go to the next CSCB.\n         BZ    FINDCSEC            Zero marks the end of the CSCB chain\n         B     FINDCSLP            Not zero. Look at the next entry.\nFINDCSFD DS    0H                  Our CSCB has been found.\n         ST    R3,FOUNCSCB         Save found CSCB address.\n         MVC   FOUNACTF,CHACT      Save\n         MVC   FOUNJOBI,CHKEY        CSCB\n         MVC   FOUNPROC,CHCLS          info.\n         MVC   FOUNASID,CHASID\n         BAL   R9,PRNTCSCB         Print info from the current CSCB.\n         BAL   R9,FORCHACT         Format some CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Put out an underline.\n         B     FINDCSEN            Go to end of routine.\n         DROP  R3\nFINDCSEC DS    0H                  Came to end of CSCB chain.\n         APUT  MESSAGEN,L'MESSAGEN   Then put out a message\n         B     EOJ4                  And end with code 4.\nFINDCSEN DS    0H\n         L     R3,SAVER3A\n         L     R9,SAVER9D\n         BR    R9\n*            Constants associated with this routine.    -    below\nFOUNACTF DC    X'00'\nFOUNCSCB DS    F                   FOUND CSCB ADDRESS\nFOUNJOBI DC    CL8' '\nFOUNPROC DC    CL8' '\nECB      DS    F          SRB TO POST COMPLETION                    JOE\nFOUNASID DC    H'0'\nCSCBACTF DC    X'00'\nCSCBJOBI DC    CL8' '\nCSCBPROC DC    CL8' '\nCSCBASID DC    H'0'\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\nVALIDTR  DS    0H                  Validate hex characters coded.\n         ST    R9,SAVER9E          Save\n         STM   R4,R6,SAVEWRK          registers.\n         LA    R4,ASIDMV           Point to translated display chars.\n         LA    R6,ASIDWKS          Point to chars with error signs.\n         LA    R5,4                BCT register - only 4 times.\nVALIDTRS DS    0H\n         CLI   0(R4),X'CC'         Is this an invalid character?\n         BE    VALIDTRR            Yes. Substitute a ? for message.\n         LA    R4,1(,R4)           Next translated character.\n         LA    R6,1(,R6)           Next char for error message.\n         BCT   R5,VALIDTRS         Loop to test validity of this char.\n         TM    ERRASID,X'01'       After 4 chars, any errors found?\n         BO    VALIDERR            Yes. Write messages.\n         B     VALIDTRE            No. Get out of routine.\nVALIDTRR DS    0H                  Come here if invalid char found.\n         OI    ERRASID,X'01'       Flag that at least one was found.\n         MVI   0(R6),C'?'          Substitute a ? for it in message.\n         LA    R4,1(,R4)           Next translated character.\n         LA    R6,1(,R6)           Next char in error message.\n         BCT   R5,VALIDTRS         Check that character for validity.\nVALIDERR DS    0H                  Error messages if char is invalid.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(37),ASIDBADM\n         APUT  OUTPUT,45\n*        MVC   OUTPUT,OUTPUT-1\n*        MVC   OUTPUT(51),MSGBADPR\n*        APUT  OUTPUT,52\n         B     EOJ4                Get out with code 4.\nVALIDTRE DS    0H\n         L     R4,SAVER4B          Restore regs used in this routine.\n         LM    R4,R6,SAVEWRK\n         BR    R9\n*            Constants associated with this routine.    -    below\nERRASID  DC    X'00'\nSAVEWRK  DS    3F\nMSGBADPR DC    C'Bad ASID entered. Use end parenthesis ) to delimit.'\nASIDBADM DC    CL33'Bad Characters marked with a ?:  '\nASIDWKS  DC    CL4' '\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\n* -- -- -- -- -- -- -- -- -- -- -- --    R3 points to a CSCB address\nPRNTCSCB DS    0H                  Print a CSCB entry.\n         ST    R9,SAVER9F          Save BAL register.\n         ST    R3,SAVECSCB         Saved found CSCB address.\n         USING CHAIN,R3\n*                   Print info from current CSCB\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Job  ID :'\n         MVC   OUTPUT+11(8),CHKEY\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Proc ID :'\n         MVC   OUTPUT+11(8),CHCLS\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'ASID    :'\n         HEX   OUTPUT+11,2,CHASID\n         APUT  OUTPUT,25\n         TM    FLAG2,X'40'\n         BO    PRNTCSC1\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Previous CHACT Flags:'\n         HEX   OUTPUT+23,1,CHACT\n         APUT  OUTPUT,25\n         B     PRNTCSC2\nPRNTCSC1 DS    0H\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Current  CHACT Flags:'\n         HEX   OUTPUT+23,1,CHACT\n         APUT  OUTPUT,25\nPRNTCSC2 DS    0H\n         DROP  R3\n         L     R3,SAVECSCB         Restore register to what it was.\n         L     R9,SAVER9F          Restore BAL register and\n         BR    R9                     branch back to caller.\nSAVECSCB DS    F                   Saved address of found CSCB.\n** ---------------------------------------------------------------- **\nRUNCSCB  DS    0H                  Run through the CSCB chain.\n         ST    R9,SAVER9G\n         ST    R3,SAVER3C\n         ST    R7,SAVER7A\nRUNCSCBT DS    0H\n         TM    FLAG2,X'40'         Only run if CSCB keyword was coded.\n         BZ    RUNCSCBE            Not coded, get out.\n*                                  Display this is a CSCB chain run.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(40),=C'This is a run of the CSCB Chain only ...'\n         APUT  OUTPUT,45\n         APUT  MESSAGEL,L'MESSAGEL   Print underline.\n*                                  Find the CSCB chain:\n         L     R3,16               CVT\n         L     R3,X'94'(,R3)       MSER - pointer to CSCB chain.\n         ICM   R3,15,0(R3)         First CSCB entry.\n         BZ    RUNCSCBE            If zero, end of CSCB chain.\n*                                  Otherwise points to next CSCB in\n*                                    the table.\n         USING CHAIN,R3\nRUNCSCBD DS    0H                  Loop through CSCB entries.\n         MVC   CSCBACTF(1),CHACT     Save CSCB ACT flag for this CSCB.\n         MVC   CSCBJOBI(8),CHKEY     Save CSCB JOBID (CHKEY).\n         MVC   CSCBPROC(8),CHCLS     Save CSCB PROC id (CHCLS).\n         MVC   CSCBASID(2),CHASID    Save CSCB ASID (CHASID).\n*  Test\n*        MVC   OUTPUT,OUTPUT-1\n*        HEX   OUTPUT,2,CHASID\n*        HEX   OUTPUT+6,2,ASIDBIN\n*        MVI   OUTPUT+15,C'i'\n*        APUT  OUTPUT,25\n*  Test\n* -- Limit print of entries to Jobname or ASID only ----  below\n         CLI   JOBID,C'-'          Are we printing the whole CSCB?\n         BE    RUNCSCBY            Yes.\n         CLC   ASIDBIN,=X'0000'    Was an ASID coded for a search?\n         BNE   RUNCSCB2            No. Just check for Jobname.\nRUNCSCB1 DS    0H                  Check for Jobname match.\n         XR    R7,R7               Clear work register.\n         IC    R7,SAVCOUNT         Insert saved length of Jobid.\n         BCTR  R7,0                Decrement for execute.\n         EX    R7,RUNCSCOM         Do the compare for proper length.\n*        BNE   RUNCSCBS            Not equal, don't print result.\n         BE    RUNCSCBP            Equal, print this CSCB entry.\nRUNCSCB2 DS    0H                  Check if ASID was coded.\n         CLC   ASIDBIN,CHASID      ASID match?\n         BNE   RUNCSCBS            No. Skip print of CSCB entry.\nRUNCSCBY DS    0H\n* -- Limit print of entries to Jobname or ASID only ----  above\nRUNCSCBP DS    0H                  Print this entry....\n         BAL   R9,PRNTCSCB         Print of current CSCB information.\n         BAL   R9,FORCHACT         Format some CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline line.\nRUNCSCBS DS    0H                  If skipping an entry print, go here.\n         ICM   R3,15,0(R3)         Go to next CSCB entry in table.\n         BZ    RUNCSCBE            If it is zero, end of CSCB chain.\n         B     RUNCSCBD            Not zero, loop to next entry and\n*                                    print it.\nRUNCSCBE DS    0H                  End of routine.\n         L     R3,SAVER3C          Restore\n         L     R7,SAVER7A\n         L     R9,SAVER9G             registers and\n         BR    R9                        go back to caller.\nRUNCSCOM CLC   JOBID(*-*),CHKEY   Executed\n         DROP  R3\n** ---------------------------------------------------------------- **\nKEYZERO  DS    0H                  Into Key 0 and change CSCB cntl blk.\n         ST    R9,SAVER9H\n         ST    R4,SAVER4A\n*\n* -- >  Test if this command is being run APF Authorized - below\n         STM   R15,R1,SAVE14T1     Now save registers and test if APF\n         XR    R15,R15                  authorized.\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.\n* -- >  Test if this command is being run APF Authorized - above\n*\n* -- >    ***    Do as little as possible under Key 0.    ***\nKEYPRLIM DS    0H\n         TM    ONSWIT,X'01'        Are we OR-ing?\n         BZ    SWITOFF             No. Try AND-ing?\n         MVC   CANCKEY0,CANCINDC   Pre-process affecting bits.\n         B     SWITON              All done pre-processing.\nSWITOFF  DS    0H\n         TM    ONSWIT,X'02'        Are we AND-ing?\n         BZ    KEY0BYPS            No. Don't do anything else.\n         XC    CANCINDC,=X'FF'     Reverse the affected bits for AND.\n         MVC   CANCKEY0,CANCINDC   And move them to staging area.\nSWITON   DS    0H\n         USING CHAIN,R3\n         L     R3,FOUNCSCB         Save address of \"found CSCB\".\n*\n* -- >                             We're authorized. Go Key 0.\n         MODESET KEY=ZERO\n         TM    ONSWIT,X'01'        Are we OR-ing?\n         BZ    KEY0OFF             No. Try AND-ing.\n         OC    CHACT(1),CANCKEY0   Do the OR.\n         B     KEY0END             Out of Key 0.\nKEY0OFF  DS    0H\n         TM    ONSWIT,X'02'        Are we AND-ing?\n         BZ    KEY0END             No. Get out altogether.\n         NC    CHACT(1),CANCKEY0   Do the AND.\nKEY0END  DS    0H                  Out of Key 0.\n         MODESET KEY=NZERO\n*\nKEY0BYPS DS    0H                  Key 0 bypass - branch to here.\n         DROP  R3\n         L     R4,SAVER4A\n         L     R9,SAVER9H\n         BR    R9\n** ---------------------------------------------------------------- **\nPRNWCSCB DS    0H                  Print the changed CSCB entry.\n         ST    R9,SAVER9I          Save BAL register.\n         ST    R3,SAVER3D\n         L     R3,FOUNCSCB         Saved found CSCB address.\n         USING CHAIN,R3\n*                   Print info from changed CSCB.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Job  ID :'\n         MVC   OUTPUT+11(8),CHKEY\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Proc ID :'\n         MVC   OUTPUT+11(8),CHCLS\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'ASID    :'\n         HEX   OUTPUT+11,2,CHASID\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Modified CHACT Flags:'\n         HEX   OUTPUT+23,1,CHACT\n         APUT  OUTPUT,25\n         APUT  MESSAGEL,L'MESSAGEL\n         DROP  R3\n         L     R3,SAVER3D          Restore register to what it was.\n         L     R9,SAVER9I          Restore BAL register and\n         BR    R9                     branch back to caller.\n** ---------------------------------------------------------------- **\nFORCHACT DS    0H                  Format the CHACT Flags\n         ST    R9,SAVER9J          Save\n         ST    R3,SAVER3E             registers.\n         USING CHAIN,R3\nFORCANC0 DS    0H                  Show cancelable or not.\n         TM    CHACT,CHCL          Is job cancelable?\n         BO    FORCANC1            Yes, show cancelable.\n         BZ    FORCANC2            No. Show non-cancelable.\n         B     FORFORC0            Fall through, try forceable.\nFORCANC1 DS    0H\n         MVC   MESSTXT,MESSCAN     Tell em job is cancelable.\n         B     FORCANCP\nFORCANC2 DS    0H\n         MVC   MESSTXT,MESSNCN     Tell em job is non-cancelable.\nFORCANCP DS    0H                  Write the actual message out.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(28),FORMTMSG\n         APUT  OUTPUT,30\nFORFORC0 DS    0H                  Show forceable or not.\n         TM    CHACT,CHAFORCE      Is job forceable?\n         BO    FORFORC1            Yes, show forceable.\n         BZ    FORFORC2            No. Show non-forceable.\nFORFORC1 DS    0H\n         MVC   MESSTXT,MESSFOR     Tell em job is forceable.\n         B     FORFORCP\nFORFORC2 DS    0H\n         MVC   MESSTXT,MESSNFR     Tell em job is non-forceable.\nFORFORCP DS    0H                  Write the actual message out.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(28),FORMTMSG\n         APUT  OUTPUT,30\nFORCHEND DS    0H\n         DROP  R3\n         L     R3,SAVER3E          Restore\n         L     R9,SAVER9J             registers.\n         BR    R9\n*            Constants associated with this routine.    -    below\nMESSCAN  DC    CL14'Cancelable    '\nMESSNCN  DC    CL14'Non-Cancelable'\nMESSFOR  DC    CL14'Forcible      '\nMESSNFR  DC    CL14'Non-Forcible  '\nFORMTMSG DS    0CL28\nMESS000  DC    CL14'Job Status:   '\nMESSTXT  DC    CL14'              '\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\nPRINTERR DS    0H                    Print help messages.\n         ST    R9,SAVER9K            Save BAL register.\n         APUT  MESSAG2A,L'MESSAG2A\n         APUT  MESSAG2B,L'MESSAG2B\n         APUT  MESSAG2C,L'MESSAG2C\n         APUT  MESSAG2D,L'MESSAG2D\n         APUT  MESSAG2E,L'MESSAG2E\n         APUT  MESSAG2F,L'MESSAG2F\n         APUT  MESSAGEM,L'MESSAGEM\n         APUT  MESSAG2G,L'MESSAG2G\n         APUT  MESSAG2H,L'MESSAG2H\n         APUT  MESSAGEM,L'MESSAGEM\n         APUT  MESSAG2I,L'MESSAG2I\n         APUT  MESSAG2J,L'MESSAG2J\n         APUT  MESSAG2K,L'MESSAG2K\n         APUT  MESSAG2L,L'MESSAG2L\n         APUT  MESSAG2M,L'MESSAG2M\n         APUT  MESSAG2N,L'MESSAG2N\n         APUT  MESSAG2O,L'MESSAG2O\n         APUT  MESSAG2P,L'MESSAG2P\n         APUT  MESSAG2Q,L'MESSAG2Q\n         APUT  MESSAG2R,L'MESSAG2R\n         APUT  MESSAG2S,L'MESSAG2S\n         APUT  MESSAG2T,L'MESSAG2T\n         APUT  MESSAGEM,L'MESSAGEM\n         L     R9,SAVER9K            Restore BAL register.\n         BR    R9\n** ---------------------------------------------------------------- **\nKEY0SWNS DS    0H                    Key 0 for SWAP or NSWP\n         ST    R9,SAVER9L            Save BAL register.\n         ST    R6,SAVER6A\nKEY0TSTA DS    0H\n* -- >  Test if this command is being run APF Authorized - below\n         STM   R15,R1,SAVE14T1     Now save registers and test if APF\n         XR    R15,R15                  authorized.\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.\n* -- >  Test if this command is being run APF Authorized - above\n         TM    FLAG2,X'04'         Make ASID swappable?\n         BO    KEY0SWAP            Yes. Do it.\n         TM    FLAG2,X'08'         Make ASID non-swappable?\n         BO    KEY0NSWP            Yes. Do it.\n         B     KEY0EXIT            Not SWAP or NSWP, don't belong here.\n*\nKEY0NSWP DS    0H                    Make address space non-swappable.\n\n         CLC   OWNASID,FOUNASID      Target asid different from ours?\n         BE    KEY0DNSW              No. Just do SYSEVENT.\n         MVC   FUNC,=CL8'DONTSWAP'\n         BAL   R9,BUILDSRB           Build SRB block                JOE\n*                                                                   JOE\n         L     R6,SAVER6A                                           JOE\n         L     R9,SAVER9L            Restore BAL register.          JOE\n         BR    R9                                                   JOE\nTEMPSAVE DS    4F                                                   JOE\n* - cross address space stuff - above\nKEY0DNSW DS    0H\n         MODESET MODE=SUP,KEY=ZERO\nKEY0SYSD DS    0H\n         LH    R6,FOUNASID\n         SYSEVENT DONTSWAP,ASID=(R6),ENTRY=SVC\n*        STATUS SET,MC,STEP                  EXCLUSIVE TASK\n*        LA    R1,1                          LOAD NEW AUTH. INDEX\n*        AXSET AX=(1)                        SET NEW AUTH. INDEX\n*        ST    R0,OLDAX                      SAVE OLD AUTH. INDEX\n*        LH    R1,FOUNASID                   LOAD JES2 ASID.\n*        SSAR  R1                            SET SPACE SECONDARY JES2.\n*        ST    R1,SYSEVCOD\n*        LTR   R1,R1\n*        BNZ   KEY0NODO\n*        STATUS RESET,MC,STEP\nKEY0NNRM DS    0H\n         MODESET MODE=PROB,KEY=NZERO\n         MVC   MESSAGNS+4(8),FOUNJOBI\n         APUT  MESSAGNS,L'MESSAGNS\n         B     KEY0EXIT\nKEY0SWAP DS    0H                    Make address space swappable.\n         CLC   OWNASID,FOUNASID      Target asid different from ours?\n         BE    KEY0DSWP              No. Just do SYSEVENT.\n         MVC   FUNC,=CL8'OKSWAP'\n         BAL   R9,BUILDSRB           Build SRB CSA CONTROL BLOCKS\n         L     R6,SAVER6A                                           JOE\n         L     R9,SAVER9L            Restore BAL register.          JOE\n         BR    R9                                                   JOE\n* - cross address space stuff - below\n* - cross address space stuff - above\nKEY0DSWP DS    0H\n         LH    R6,FOUNASID\n         SYSEVENT OKSWAP,ASID=(R6),ENTRY=SVC\n*        STATUS RESET,MC,STEP\n*        ST    R1,SYSEVCOD\n*        LTR   R1,R1\n*        BNZ   KEY0NODO\nKEY0SNRM DS    0H\n         MODESET MODE=PROB,KEY=NZERO\n         MVC   MESSAGSW+4(8),FOUNJOBI\n         APUT  MESSAGSW,L'MESSAGSW\n         B     KEY0EXIT\nKEY0NODO DS    0H\n         MODESET MODE=PROB,KEY=NZERO\n         HEX   MESSAGNG+43,1,SYSEVCOD+3\n         APUT  MESSAGNG,L'MESSAGNG\nKEY0EXIT DS    0H\n         L     R6,SAVER6A\n         L     R9,SAVER9L            Restore BAL register.\n         BR    R9\nBUILDSRB DS    0H\n*---------------------------------------------------------------*   JOE\n*       temp code to under testauth and hercules                *   JOE\n*---------------------------------------------------------------*   JOE\n         STM   R6,R9,TEMPSAVE        Save Registers                 JOE\n         BAL   R9,GETASCB            Find ASCB for this asid        JOE\n         LR    R9,R15                Hold ASCB                      JOE\n         L     R9,0(,R9)             Point to ASCB                  JOE\n         MODESET MODE=SUP,KEY=ZERO   Get into supervisor state      JOE\n*                                                                   JOE\nCSA_LEN  EQU  SRBSIZE+84             Csa For Control Blocks         JOE\n*                                                                   JOE\n*---------------------------------------------------------------*   JOE\n*       Get CSA for SRB CONTROL BLOCK                           *   JOE\n*---------------------------------------------------------------*   JOE\n         STORAGE OBTAIN,SP=241,LENGTH=CSA_LEN Get Some CSA          JOE\n         LR    R6,R1                 Point r2 to srb control block  JOE\n         USING SRB,R6                Address SRB                    JOE\n         XC    SRB(SRBSIZE),SRB      Clear out srb                  JOE\n         ST    R9,SRBASCB            Save ASCB                      JOE\n         LA    R8,SRBSIZE(,R6)       R8 -> paramlist                JOE\n*       Get CSA paramter list                                   *   JOE\n         ST    R8,SRBPARM                                           JOE\n         LA    R7,72(,R8)            Point to ECB                   JOE\n         XC    0(4,R7),0(R7)         Clear ECB Address              JOE\n         LA    R7,4(,R7)             Point to ASCb                  JOE\n         MVC   0(4,R7),X'224'                                       JOE\n         LA    R7,4(,R7)             Point to ASCb                  JOE\n         CLC   FUNC,=C'DONTSWAP'     NON-SWAPPABLE                  JOE\n         BE    NONSWAP                                              JOE\n         MVC   0(4,R7),=C'OKSW'                                     JOE\n         B     SETEPA                                               JOE\nNONSWAP  DS    0H                                                   JOE\n         MVC   0(4,R7),=C'DONT'                                     JOE\nSETEPA   DS    0H                                                   JOE\n         STORAGE OBTAIN,SP=227,LENGTH=SWAPLEN  Get Fixed CSA        JOE\n         ST    R1,SRBEPA             set entry point                JOE\n         LR    R14,R1                Hold that thought              JOE\n         LA    R15,SWAPLEN           Get Length                     JOE\n         LR    R1,R15                                               JOE\n         LA    R0,SWAPXMEM           Point to SRB routine           JOE\n         MVCL  R14,R0                Move routine                   JOE\n*                                                                   JOE\n         SCHEDULE SRB=(R6),SCOPE=GLOBAL,MODE=NONXM                  JOE\n*                                                                   JOE\n         LA    R7,72(,R8)            Point to ECB                   JOE\n*                                                                   JOE\n         WAIT  ECB=(R7)                                             JOE\n*                                                                   JOE\n         L     R9,SRBEPA             Get Entry Point Address        JOE\n*                                                                   JOE\n         STORAGE RELEASE,ADDR=(R6),LENGTH=CSA_LEN,SP=241            JOE\n*                                                                   JOE\n         STORAGE RELEASE,ADDR=(R9),LENGTH=CSA_LEN,SP=227            JOE\n*                                                                   JOE\n         MODESET KEY=NZERO,MODE=PROB                                joe\n*                                                                   JOE\n         LM    R6,R9,TEMPSAVE        Save Registers                 JOE\n         BR    R9                    Return                         JOE\nSYSEVCOD DC    F'0'                  SYSEVENT Return Code\nOLDAX    DS    F\nWAREA    DS    D                     Work area\nWAREB    DS    D                     Work area\n** ---------------------------------------------------------------- **\n** --         C  O  N  S  T  A  N  T  S                          -- **\n** ---------------------------------------------------------------- **\nMESSAGNA DC    C'Command was not invoked APF authorized.'\nMESSAGEN DC    C'End of CSCB chain was reached.'\nMESSAGEY DC    C'No valid keyword was coded.'\nFLAG1    DC    X'00'\n*              X'01'               ASID ONLY - NO JOBNAME\n*              X'02'               JOBNAME IS PRESENT.\n*              X'04'               ASID( WAS PRESENT IN PARMS.\n*              X'08'               CSCB CHAIN DISPLAY ONLY.\nFLAG2    DC    X'00'\n*              X'01'               CNCL WAS CODED\n*              X'02'               NCNC WAS CODED\n*              X'04'               SWAP WAS CODED\n*              X'08'               NSWP WAS CODED\n*              X'10'               FORC WAS CODED\n*              X'20'               CSCB WAS CODED\nONSWIT   DC    X'00'\n*              X'01'               TURN BIT ON\n*              X'02'               TURN BIT OFF\nHEXSAVE  DS    3F                  SAVE FOR HEX MACRO\nSAVE     DS    9D                  Program Save Area\nSAVE14T1 DS    2D                  Save \"system-used\" registers.\n         DC    C' '                Blank before OUTPUT line.\nOUTPUT   DC    CL80'  '            Variable output line.\nFUNC     DS    CL8                 Swapppinmg function\n         LTORG\n*-----------------------------------------------------------------* JOE\n*                         SRB CODE                                * JOE\n*-----------------------------------------------------------------* JOE\nSWAPXMEM DS    0D                                                   JOE\n         DROP  R12,R11,R10                                          JOE\n         BASR  R5,0                                                 JOE\n         USING *,R5                  Entry Point                    JOE\n         LR    R10,R14               SAVE RETURN ADDRESS            JOE\n         LR    R13,R1                                               JOE\n*                                                                   JOE\n         LA    R9,72(,R13)          Point to ECB Address            JOE\n         LA    R8,76(,R13)          Point to ASCB Address           JOE\n         L     R8,0(,R8)                                            JOE\n         L     R7,80(,R13)          Get code                        JOE\n*                                                                   JOE\n         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=STDSAVE         JOE\n*                                                                   JOE\n         C      R7,=C'OKSW'        OKSWAP                           JOE\n         BE     SETSWAP                                             JOE\n*                                                                   JOE\n         SYSEVENT DONTSWAP,ENTRY=BRANCH                             JOE\n*                                                                   JOE\n         B      UNLOCK                                              JOE\n*                                                                   JOE\nSETSWAP  DS     0H                                                  JOE\n         SYSEVENT OKSWAP,ENTRY=BRANCH                               JOE\n*                                                                   JOE\nUNLOCK   DS     0H                                                  JOE\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE                    JOE\n*                                                                   JOE\n*                                                                   JOE\n         POST  (R9),ASCB=(R8),ERRET=GOBACK,LINKAGE=BRANCH           JOE\n*                                                                   JOE\nGOBACK   LR    R14,R10               Return Address                 JOE\n         BR    R14                   Return                         JOE\n         LTORG                                                      JOE\nSWAPRTM  DS    0D                                                   JOE\nSWAPLEN  EQU   *-SWAPXMEM                                           JOE\n** ---------------------------------------------------------------- **\n         SPACE\n         TITLE '- MAPPING MACROS.'\n         CVT   DSECT=YES           Map the CVT.\n         IEECHAIN                  Map the CSCB control block.\n         IHASRB                                                     JOE\n         IHAASVT                                                    JOE\n         IHAASCB                                                    JOE\n         IHAASXB                                                    JOE\n         IRAOUCB                                                    JOE\n         IHAPSA   DSECT=YES,LIST=YES                           HD APR88\n         IHAFRRS\n         EJECT                                                 HD APR88\n         IKJEFLWA                                                  JOE\n         END   CNCLPG\n** ---------------------------------------------------------------- **\n*  -----------------------------------------------------------------  *\n*  --           Create PUTLINE environment.                       --  *\n*  -----------------------------------------------------------------  *\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUEMNTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   128                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         IHAPSA   DSECT=YES,LIST=YES                           HD APR88\n         EJECT\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   14,12,12(13)       SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES            RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    1,8(13)            OUR SAVE AREA POINTER\n         ST    13,4(1)            POINTER TO CALLERS SAVE AREA\n         LR    13,1               @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(R13)         POINT TO CALLERS RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 ASSUME BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 ASSUME BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(RML)               MESSAGE LENGTH\n         STH   R15,PUTLEN                 PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    2,R13                    @OUR SAVE AREA\n         LR    3,R15                    SAVE RETURN CODE\n         L     R13,4(R13)               @CALLERS SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,3                    RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CNCLPG20": {"ttr": 3333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x14\\x00\\x05\\x01\\x11)\\x8f\\x01\\x17\\x13o\\x14&\\x06t\\x062\\x00\\x00\\xe5\\xf1\\xd9\\xf2\\xd4\\xf0@@@@'", "ispf": {"version": "01.20", "flags": 0, "createdate": "2011-10-25T00:00:00", "modifydate": "2017-05-16T14:26:05", "lines": 1652, "newlines": 1586, "modlines": 0, "user": "V1R2M0"}, "text": "CNCLPG   TITLE 'Make address space cancelable, non-swappable, etc. '\n*  -----------------------------------------------------------------  *\n*                                                                     *\n*    Function:   To make an address space Cancelable or               *\n*                Non-cancelable, Forcible or Non-forcible,            *\n*                Swappable or Non-swappable.                          *\n*                                                                     *\n*  -----------------------------------------------------------------  *\n*                                                                     *\n*    Notes:                                                           *\n*                                                                     *\n*           CANCELABLE, NON-CANCELABLE, FORCIBLE, NON-FORCIBLE:       *\n*                                                                     *\n*    CSCB        Cancelable, Non-cancelable, Forcible, Non-forcible   *\n*    chain       are determined by bit settings in the address        *\n*                space's CSCB, which is part of the CSCB chain.       *\n*                                                                     *\n*    Jobname     Each active address space has a CSCB in the chain.   *\n*    and/or      You get to a particular address space by running     *\n*    ASID        the entire CSCB chain (mapped by the IEECHAIN        *\n*    match       macro) looking for a match on jobname and/or ASID,   *\n*                and preferably on both.                              *\n*                                                                     *\n*    DISPlay     There may be more than one address space for a       *\n*    or          given job name, and more than one CSCB entry         *\n*    \"CSCB\"      for a given ASID.  The CSCB or DISPlay option        *\n*    option      of CNCLPG will run the entire CSCB chain and         *\n*                it will show ALL the matches for the parameters      *\n*                given.  To display the ENTIRE CSCB chain from start  *\n*                to finish, use a dash ( - ) instead of the jobname.  *\n*                                                                     *\n*    Multiple    If only the jobname or the ASID number alone         *\n*    jobs        are used to do an ACTION, then CNCLPG will stop      *\n*    with the    at the FIRST CSCB which matches, when an ACTION is   *\n*    same name   called for (but NOT for a DISPLAY).  That is why     *\n*                it is better to run the DISPlay (or CSCB) function   *\n*                of CNCLPG first, to display all the possible CSCB    *\n*                entries that might match, before changing any        *\n*                particular address space.  There might be more       *\n*                than one address space with the same jobname or      *\n*                ASID, and you want to change only the correct        *\n*                one, NOT the wrong one.  So it is good practice      *\n*                to display first, and then do a change to the        *\n*                exact address space you want to affect, using        *\n*                both the jobname and ASID(hhhh) parameters.          *\n*                                                                     *\n*           SWAPPABLE AND NON-SWAPPABLE:                              *\n*                                                                     *\n*    SWAP and    Setting an address space to be swappable or          *\n*    NSWP need   non-swappable, is accomplished by executing          *\n*    to run a    a SYSEVENT macro.  This has to execute in the        *\n*    SYSEVENT    target address space, and it was done here by        *\n*    macro in    scheduling an SRB to run in the target address       *\n*    the         space, when it is different from the address         *\n*    target      space running the program.  That piece of code       *\n*    address     was written by Joe Reichman.  Thanks, Joe.           *\n*    space       You did the hard part!                               *\n*                                                                     *\n*    -------------------------------------------------------------    *\n*                                                                     *\n*    Syntax:     TSO Command:  APF-authorized.                        *\n*                                                                     *\n*        CNCLPG |jobid \u00ddASID(hhhh)\u00a8 |CNCL|NCNC|FORC|NFRC|NSWP|SWAP    *\n*               |ASID(hhhh)         |CNCL|NCNC|FORC|NFRC|NSWP|SWAP    *\n*               |                   |CSCB or DISP                     *\n*               |-  (displays the entire CSCB chain)                  *\n*               |?  (displays help)                                   *\n*                                                                     *\n*    Date:       April 15, 2010                                       *\n*                                                                     *\n*    Latest Modification:   October 30, 2011                          *\n*                                                                     *\n*    Authors:    Sam Golob, Joe Reichman (who did the hard part)      *\n*                                                                     *\n*    Technical Detail:  PUTLINE interface for TSO Output.             *\n*                       Uses the APUT macro, and EPUTL module.        *\n*                                                                     *\n*    Changes:  1.  SWAP, NSWP support dropped from this program       *\n*                   initially.  Version is 1.0.0.                     *\n*                                                                     *\n*              2.  Messages and DISP improved, to just show matching  *\n*                   CSCB chain entries, instead of all of them.       *\n*                   Coding a dash instead of a jobname or asid(hhhh)  *\n*                   - will display the entire CSCB chain.             *\n*                                                                     *\n*              3.  SWAP, NSWP support put back in this program.       *\n*                   Version is 1.1.0   (June 16, 2010)                *\n*                   It now does your own address space.  The cross    *\n*                   memory stuff was not put in yet, to make other    *\n*                   address spaces swappable, or non-swappable.       *\n*                                                                     *\n*              4.  Complete SWAP, NSWP support for cross address      *\n*                   space communication, was put in by Joe            *\n*                   Reichman.  (Oct 2011)  Version is 1.2.0.          *\n*                                                                     *\n*   Change   Pgmr                   Description                       *\n*   -------  -----   ----------------------------------------------   *\n*                                                                     *\n*            JOER     Add SRB code to allow swapping in xmem.         *\n*                     (See lines commented with JOE.)                 *\n*                                                                     *\n*  -----------------------------------------------------------------  *\n*\n*  This macro lets you display hex values in a report.\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    STM   R15,R1,HEXSAVE           Save work registers.\n         LA    R1,&FROM                 Load from address.\n         LA    R0,&LEN                  Load length of hex number.\n         LA    R15,&TO                  Load to address.\n         BAL   R9,HEX                   BAL to routine.\n         LM    R15,R1,HEXSAVE           Restore work registers.\n         MEND\n*  -----------------------------------------------------------------  *\n*  --           Create PUTLINE environment.                       --  *\n*  -----------------------------------------------------------------  *\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP THE PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\n* --       End of Internal Macros......                            -- *\n* ------------------------------------------------------------------- *\n         SPACE 3\nCNCLPG   CSECT\nCNCLPG   AMODE 31\nCNCLPG   RMODE ANY\n         YREGS\n         USING CNCLPG,R15          (Establish temporary base).\n         B     BEGIN               Skip over eyecatcher.\nEYEC0    DC    AL1(EYECL)          Exclusive length of header.\nEYEC     DC    C' CNCLPG - &SYSDATE - &SYSTIME -'\n         DC    C'     --------------------------------    '\n         DC    C' VER 1.2.0   '\n         DC    C'                   '\nEYECL    EQU   *-EYEC\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)     Save caller's registers\n         LR    R6,R1               Preserve CPPL pointer.\n         LR    R12,R15             Copy base.\n         USING CNCLPG,R12,R11,R10  (Tell assembler).\n         LA    R11,4095(,R12)      Load bases.\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)\n         LA    R10,1(,R10)\n         LR    R14,R13             Copy caller's save area pointer.\n         LA    R13,SAVE            Point to my save area.\n         ST    R13,8(,R14)         Chain ...\n         ST    R14,SAVE+4          ... Save areas.\n         SPACE 1\nAUTHTEST DS    0H\n         ST    R1,SAVER1A\n         L     R1,16               CVTPTR\n         L     R1,0(,R1)           TCB WORDS\n         L     R1,4(,R1)           CURRENT TCB\n         L     R1,180(,R1)         TCBJSCB\n         L     R1,264(,R1)         JSCBPSCB\n         LA    R1,0(,R1)           CLEAR HI ORDER BYTE\n         LTR   R1,R1               IS THERE A PSCB\n         BZ    NOTFOUND            NO, ISSUE COMMAND-NOT-FOUND MSG\n         TM    X'10'(R1),X'80'     PSCB OPER AUTHORITY?\n         BZ    NOTFOUND            NO, ISSUE COMMAND-NOT-FOUND MSG\n         L     R1,SAVER1A\nINITCON  DS    0H                  Initialize some constants.\n         MVI   FLAG1,X'00'\n         MVI   FLAG2,X'00'\n         MVI   ONSWIT,X'00'\n         MVI   ERRASID,X'00'\n         MVI   CANCINDC,X'00'\n         MVI   OUTPUT-1,X'40'\n         MVC   OUTPUT,OUTPUT-1\n         MVI   NEWCHACT,X'00'\n*        B     TEST                TEST CODE\nMYASID   DS    0H                  Get my ASID\n         L     R2,X'224'           Point to PSAAOLD (my ASCB)\n         LA    R2,X'24'(,R2)       Point to my own ASID (ASCBASID)\n         MVC   OWNASID(2),0(R2)    Save it for comparison later\n         B     PRTITLE             Branch past constant\nOWNASID  DS    H\nPRTITLE  DS    0H                  Print program title.\n         APUT  MESSAGET,L'MESSAGET\n         APUT  MESSAGEU,L'MESSAGEU\nCONT0    DS    0H                  Look at command's parameters.\n         LTR   R6,R6               Any CPPL?\n         BZ    EOJ8                No.  Get out.\n         L     R1,0(,R6)           Pt to cmd buffer. (R6 reused later)\n         LTR   R1,R1               Any CMD buffer?\n         BZ    EOJ8                Get out if none.\n         LH    R3,0(,R1)           Load length.\n         CH    R3,=H'4'            Anything?\n         BNH   EOJ4                No. Get out.\n         LR    R5,R3               Length of command + 4\n         ICM   R5,14,FULLZERO      Clear hi order 3 bytes.\n         LH    R3,2(,R1)           Load offset.\n         SR    R5,R3               Subtract offset from full length+4\n         SH    R5,=H'4'            Correct for length of cmdbufr header\n         BC    8,WMESS2            Zero, message to enter userid.\n         BC    5,EOJ8              Less, or overflow, out.\nPARM     DS    0H\n         BAL   R9,GETIDS           Get parameters for the command.\n         B     EOJ0\n*\n* --- Parms gotten at this point.                            -------- *\n*\n** ---------------------------------------------------------------- **\nWMESS2   DS    0H                  Print help messages.\n         BAL   R9,PRINTERR\n         B     EOJ4\n** ---------------------------------------------------------------- **\nEOJ0     DS    0H                  End of job.\n         APUT  RETURN0,L'RETURN0\n         LA    R15,0               Set CC = 0.\n         B     RETURN\nEOJ4     DS    0H\n         APUT  RETURN4,L'RETURN4\n         LA    R15,4               Set CC = 4.\n         B     RETURN\nEOJ8     DS    0H\n         APUT  RETURN8,L'RETURN8\n         LA    R15,8               Set CC = 8.\n         B     RETURN\nRETURN   L     R13,SAVE+4\n         L     R14,12(,R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n** ---------------------------------------------------------------- **\nNOTAUTH  DS    0H                  Command not APF authorized message.\n         APUT  MESSAGNA,L'MESSAGNA\n         B     EOJ4\n** ---------------------------------------------------------------- **\nNOTFOUND DS    0H                  Command NOT ALLOWED message.\n         APUT  MESSAGAU,L'MESSAGAU\n         B     RETURN\n** ---------------------------------------------------------------- **\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        Get the parameters for the command.                      *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*   Notes:  The ASID(xxx) can be coded first, without a userid.   *\n*           A dash can be coded first, to run the entire CSCB     *\n*            chain and display all the jobnames in it, with       *\n*            their associated ASIDs.  ? coded first gives HELP.   *\n*           If you code the word CSCB or DISP(lay) after either   *\n*            a jobname or an ASID(hhhh) then a display of ALL     *\n*            matching CSCB chain entries will be displayed, and   *\n*            no changes will be made.                             *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETIDS   DS    0H                  Get all parameters for the program.\n         ST    R9,SAVER9A\n         ST    R4,SAVER4C\n         AR    R1,R3               Point ...\n         LA    R1,4(,R1)           ... to char.\n         LA    R6,8                Load reg for BCT loop.\n         LR    R7,R1               Initialize pointer to first\n         LA    R7,0(,R7)                character of the ID field.\n         LA    R8,0                Initialize character count.\n         MVC   JOBID(8),BLANKS     Clear (first param - JOBNAME) field.\n         LA    R4,JOBID            Point reg to beginng of JOBID field.\n*\nCUTIDLEN DS    0H                  Look at the JOBID field first.\n*                                  (May contain ASID( or CSCB.)\n*\n         CLI   0(R7),X'40'         Is this character a blank?\n         BE    NOMORCUT            Yes, we are at the end of the field.\n         MVC   0(1,R4),0(R7)       Move only one character at a time.\n         OC    JOBID(8),BLANKS     And uppercase the partial jobid.\n*\n*   Is this a run of the CSCB chain only?\n* -- >  Test for CSCB  first  ---- below\n         CLI   JOBID,C'-'          Did we code '-' first?\n         BNE   CSCBHELP            No. Try if help asked for.\n         B     CSCBRUN1            Yes. Run entire CSCB chain.\n* - > Help\nCSCBHELP DS    0H\n         CLI   JOBID,C'?'          Help?\n         BNE   NOCSCB              No. Skip this code.\n         BAL   R9,PRINTERR         Yes. Print messages\n         B     EOJ0                  and get out with code 0.\n* - > Help\nCSCBRUN1 DS    0H\n         ST    R8,SAVER8A          Store count for display if needed.\n         OI    FLAG2,X'40'         Mark that this is CSCB only run.\n         BAL   R9,RUNCSCB          Do the run for CSCB chain.\n         B     EOJ0                Out with normal return code.\nNOCSCB   DS    0H\n* -- >  Test for CSCB  first  ---- above\n*\n*   Was the ASCB(hhh) parameter coded without the jobid?\n* -- >  Test for ASID( first  ---- below\n         CLC   JOBID(L'ASIDC),ASIDC  Did we code ASID( in jobid field?\n         BNE   NOASIDF             No. Pass this code.\n         OI    FLAG1,X'01'         Flag that ASID( ) was first.\n         NI    FLAG1,X'FF'-X'02'   Turn off Jobname in jobid field flag\n         MVC   ASIDWKL(L'ASIDC),JOBID  Move the ASID( to proper field.\n         MVC   JOBID,BLANKS        Blank out Job ID if ASID( coded.\n         LA    R7,1(,R7)           Bump another character.\n         LA    R8,1(,R8)           Count another character.\n         LA    R6,1                Set number of branches later.\n*                                  This will limit number of params\n*                                   that are searched for.\n         B     ASIDONLY            Bypass all the real jobname stuff.\n* -- >  Test for ASID( first  ---- above\nNOASIDF  DS    0H                  ASID( is not the first parameter.\n         LA    R4,1(,R4)           Bump another character.\n         LA    R7,1(,R7)           Bump another character.\n         LA    R8,1(,R8)           Count another character.\n         CR    R8,R5               End of command buffer ?\n         BNL   NOMORCUT            Yes. Get out now.\n         BCT   R6,CUTIDLEN         Try for the next blank, up till 8.\nNOMORCUT DS    0H\n         STC   R8,SAVCOUNT         Save length of Jobname\n         L     R4,SAVER4C          Restore work register for use later.\n         OC    JOBID(8),BLANKS     Uppercase the new Job Id.\n         OI    FLAG1,X'02'         Set 'Jobname Coded' flag.\n*  -  Display the found JOBID - below\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Search Jobname:'\n         MVC   OUTPUT+17(8),JOBID\n         APUT  OUTPUT,30\n         APUT  MESSAGEL,L'MESSAGEL\n*  -  Display the found JOBID - above\n         LA    R6,1                Set number of branches later.\n*                                  This will limit number of params\n*                                   that are searched for.\n         B     LOOKKEYW\n*  Constants - below - ***\nJOBID    DC    C'        '         STORE PARM USERID HERE\nBLANKS   DC    C'        '         8 BLANKS\nMESSAGET DC    C'CNCLPG 1.2.0 - Make a Job, STC or TSU Cancelable, etc.X\n                (? for help)'\nMESSAGEU DC   C'------ ----- - ---- - ---- --- -- --- ----------- ----'\nMESSAGEL DC    C'----------------------------'\nMESSAGEM DC    C'-----------------------------------------------'\nMESSAG2A DC    C'Enter JOBNAME and/or ASID(hhhh) after COMMAND name,'\nMESSAG2B DC    C'   then CNCL, NCNC, FORC, NFRC, NSWP, or SWAP. '\nMESSAG2U DC    C'   Or code CSCB or DISP to just display CSCB entries.'\nMESSAG2C DC    C'   DISPlay or CSCB will display CSCB chain entries,'\nMESSAG2D DC    C'   without changing them.'\nMESSAG2E DC    C' When changing a job, we want to be accurate, '\nMESSAG2F DC    C'  therefore you should use the DISPlay option first.'\nMESSAG2G DC   C' To display the whole CSCB, code - (dash) for JOBNAME.'\nMESSAG2H DC    C' To see this help message, code ? for JOBNAME.'\nMESSAG2I DC    C'Notes (important) : '\nMESSAG2J DC   C' CSCB (DISP) display for an ASID shows all occurrences'\nMESSAG2K DC    C'  for that ASID, regardless of JOBNAME.      '\nMESSAG2L DC C' CSCB (DISP) display for a JOBNAME shows all occurrences'\nMESSAG2M DC    C'  for that JOBNAME, regardless of ASID.      '\nMESSAG2N DC    C' CNCL, NCNC, FORC, NFRC, NSWP, SWAP changes the FIRST'\nMESSAG2O DC    C'  entry in the CSCB chain that matches, if multiple '\nMESSAG2P DC    C'  entries exist. But DISP will display ALL applicable'\nMESSAG2Q DC    C'  matching entries in the CSCB chain, so you can see'\nMESSAG2R DC    C'  which one you want to change specifically.'\nMESSAG2S DC    C' When you code BOTH jobname and asid, to CHANGE it,'\nMESSAG2T DC    C'  then ONLY that specific job and asid gets changed.'\nMESSAGE3 DC    C'WE GOT HERE'\nMESSAGE4 DC    C'TEST CHECK THIS'\nMESSAGNG DC    C'Job was not done. SYSEVENT return code was     '\nMESSAGNS DC    C'Job xxxxxxxx for ASID HHHH made non-swappable.'\nMESSAGSW DC    C'Job xxxxxxxx for ASID HHHH was made swappable.'\nMESSAGAN DC    C'Job xxxxxxxx for ASID HHHH already non-swappable.'\nMESSAGAS DC    C'Job xxxxxxxx for ASID HHHH was already swappable.'\nMESSAGFN DC    C'Function xxxx was called for.'\nMESSAGAU DC    C'IKJ56500I COMMAND CNCLPG NOT FOUND'\nRETURN0  DC    C'Return code is 0'\nRETURN4  DC    C'Return code is 4'\nRETURN8  DC    C'Return code is 8'\n*                     ***  Places to save registers  ***  below\nSAVER1A  DS    F\nSAVER3A  DS    F\nSAVER3B  DS    F\nSAVER3C  DS    F\nSAVER3D  DS    F\nSAVER3E  DS    F\nSAVER4A  DS    F\nSAVER4B  DS    F\nSAVER4C  DS    F\nSAVER5A  DS    F\nSAVER6A  DS    F\nSAVER6B  DS    F\nSAVER7A  DS    F\nSAVER8A  DS    F\nSAVER9A  DS    F\nSAVER9B  DS    F\nSAVER9C  DS    F\nSAVER9D  DS    F\nSAVER9E  DS    F\nSAVER9F  DS    F\nSAVER9G  DS    F\nSAVER9H  DS    F\nSAVER9I  DS    F\nSAVER9J  DS    F\nSAVER9K  DS    F\nSAVER9L  DS    F\nSAVER9M  DS    F\nSAVER9N  DS    F\n*                     ***  Places to save registers  ***  above\nSAVCOUNT DS    X\nDUBLZERO DC    D'0'\nFULLZERO DC    F'0'\nCANCINDC DC    X'00'\nCANCKEY0 DC    X'00'\nNEWCHACT DC    X'00'\n*  Constants - above - ***\nLOOKKEYW DS    0H                  Look for additional keywords.\n         LA    R7,1(,R7)           Bump command buffer pointer.\n         LA    R8,1(,R8)           Bump character counter.\n         CR    R8,R5               End of command buffer?\n         BNL   GETIDEND            Yes. Don't look any more.\n         MVC   ASIDWKL(5),BLANKS   Clear parameter work field.\n         MVC   ASIDWKL(5),0(R7)    Next 5 characters to work field.\nASIDONLY DS    0H                  Jump to here if ASID( coded first.\n         OC    ASIDWKL(4),BLANKS   Uppercase work field.\n         CLC   ASIDC,ASIDWKL       Is the ASID( keyword there?\n         BE    DOASID              Yes. Process it.\n         CLC   CNCLC,ASIDWKL       Is the CNCL  keyword there?\n         BE    DOCNCL              Yes. Process it.\n         CLC   NCNCC,ASIDWKL       Is the NCNC  keyword there?\n         BE    DONCNC              Yes. Process it.\n         CLC   SWAPC,ASIDWKL       Is the SWAP  keyword there?\n         BE    DOSWAP              Yes. Process it.\n         CLC   NSWPC,ASIDWKL       Is the NSWP  keyword there?\n         BE    DONSWP              Yes. Process it.\n         CLC   FORCC,ASIDWKL       Is the FORC  keyword there?\n         BE    DOFORC              Yes. Process it.\n         CLC   NFRCC,ASIDWKL       Is the NFRC  keyword there?\n         BE    DONFRC              Yes. Process it.\n         CLC   CSCBC,ASIDWKL       Is the CSCB  keyword there?\n         BE    DOCSCB              Yes. Process it.\n         CLC   DISPC,ASIDWKL       Is the DISP  keyword there?\n         BE    DOCSCB              Yes. Process it.\n         B     LOOKKEYW            Go loop and look at next character.\nASIDWKL  DC    CL5' '              Second parameter work area.\n*\nASIDC    DC    C'ASID('            Literals....\nCNCLC    DC    C'CNCL'\nNCNCC    DC    C'NCNC'\nSWAPC    DC    C'SWAP'\nNSWPC    DC    C'NSWP'\nFORCC    DC    C'FORC'\nNFRCC    DC    C'NFRC'\nCSCBC    DC    C'CSCB'\nDISPC    DC    C'DISP'\n*\nDOASID   DS    0H                  Look for hex value of the ASID.\n         OI    FLAG1,X'04'         Show that ASID( was coded.\n         BAL   R9,GETASID          Go get the rest of the parameters.\n         MVC   ASIDWKL(5),BLANKS   Blank out the second wkarea for\n*                                   a further parameter search.\n         B     LOOKKEYW            Re-loop to look further for params.\n*\nDOCNCL   DS    0H                  Handle CNCL (cancelable) keyword.\n         OI    CANCINDC,X'08'      Show which CHACT bit is affected.\n         OI    FLAG2,X'01'         Show that CNCL was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'01'        Set to OR the bits\n         NI    ONSWIT,X'FF'-X'02'   and not to AND the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n* ------------------------------------------------------------------- *\n*                                    Print the action code.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),CNCLC\n         APUT  OUTPUT,25\n*                                    Print the bit in CHACT affected.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDONCNC   DS    0H                  Handle NCNC (non-cancelable) keyword\n         OI    CANCINDC,X'08'      Show which CHACT bit is affected.\n         OI    FLAG2,X'02'         Show that NCNC was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'02'        Set to AND the bits\n         NI    ONSWIT,X'FF'-X'01'   and not to OR the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n*                                    Print the action code.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),NCNCC\n         APUT  OUTPUT,25\n*                                    Print the bit in CHACT affected.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDOSWAP   DS    0H                  Now this routine is operational.\n         OI    FLAG2,X'04'         Show that SWAP was coded.\n         MVC   MESSAGFN+9(4),SWAPC   Write message to say that.\n         APUT  MESSAGFN,L'MESSAGFN\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         BAL   R9,KEY0SWNS         Do SYSEVENT OKSWAP, xmem or not.\n         BCT   R6,LOOKKEYW\n         B     GETIDEND\n* ------------------------------------------------------------------- *\nDONSWP   DS    0H                  Now this routine is operational.\n         OI    FLAG2,X'08'         Show that NSWP was coded.\n         MVC   MESSAGFN+9(4),NSWPC   Write message to say that.\n         APUT  MESSAGFN,L'MESSAGFN\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         BAL   R9,KEY0SWNS         Do SYSEVENT DONTSWAP, xmem or not.\n         BCT   R6,LOOKKEYW\n         B     GETIDEND\n* ------------------------------------------------------------------- *\nDOFORC   DS    0H                  Handle FORC (forcible) keyword\n         OI    FLAG2,X'10'         Show which CHACT bit is affected.\n         OI    CANCINDC,X'01'      Show that FORC was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'01'        Set to OR the bits\n         NI    ONSWIT,X'FF'-X'02'   and not to AND the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n*\n         MVC   OUTPUT,OUTPUT-1       Print the action code.\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),FORCC\n         APUT  OUTPUT,25\n*\n         MVC   OUTPUT,OUTPUT-1       Print the bit in CHACT affected.\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDONFRC   DS    0H                  Handle NFRC (non-forcible) keyword\n         OI    FLAG2,X'20'         Show which CHACT bit is affected.\n         OI    CANCINDC,X'01'      Show that NFRC was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'02'        Set to AND the bits\n         NI    ONSWIT,X'FF'-X'01'   and not to OR the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n*\n         MVC   OUTPUT,OUTPUT-1       Print the action code.\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),NFRCC\n         APUT  OUTPUT,25\n*\n         MVC   OUTPUT,OUTPUT-1       Print the bit in CHACT affected.\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDOCSCB   DS    0H\n         OI    FLAG1,X'08'         Show CSCB keyword was coded.\n         OI    FLAG2,X'40'         Show CSCB keyword was coded.\n         MVC   OUTPUT,OUTPUT-1       Print the action code.\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),CSCBC\n         MVC   OUTPUT+23(9),=C'(DISPlay)'\n         APUT  OUTPUT,35\n         BAL   R9,RUNCSCB          Run the CSCB chain with print.\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nGETIDEND DS    0H                  End of keyword processing.\n         TM    FLAG2,X'7F'         Check if any real actions were asked\n         BM    GETKEYNR            Yes, some were.\n         APUT  MESSAGEY,L'MESSAGEY    No. Display help messages.\n         BAL   R9,PRINTERR\n         B     EOJ4                   And end with code = 4.\nGETKEYNR DS    0H                  Real actions WERE asked for.\n         B     EOJ0                So end with normal return code.\n         L     R9,SAVER9A\n         BR    R9\n** ---------------------------------------------------------------- **\nHEX      DS    0H                  Display hex values.\n         ST    R9,SAVER9B\n         MVC   1(1,R15),0(R1)      Move byte.\n         UNPK  0(3,R15),1(2,R15)   Unpack.\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)         Increment output pointer.\n         LA    R1,1(,R1)           Increment input pointer.\n         BCT   R0,HEX              Decrement length, then loop.\n         MVI   0(R15),C' '         Blank the trailing byte.\n         L     R9,SAVER9B\n         BR    R9                  Return to caller.\nHEXTAB   DC    C'0123456789ABCDEF' Translate table.\n** ---------------------------------------------------------------- **\nGETASID  DS    0H                  Get hex ASID for 2 bytes.\n         ST    R9,SAVER9C          Save registers.\n         STM   R1,R6,SAVERGS1\n         LA    R6,4                Load BCT register.\n         LA    R4,ASIDWK           Point to ASID work area.\n         TM    FLAG1,X'02'         Ask if Job name was coded.\n         BZ    GETAFL01            Wasn't. Have to adjust pointers.\n         LA    R7,5(,R7)           Bump command buffer pointer.\n         LA    R8,5(,R8)           Bump character counter.\nGETAFL01 DS    0H\nGETASIDL DS    0H                  Loop to get hex ASID for 4 display\n*                                    bytes to convert to 2 hex bytes.\n         CLI   0(R7),C')'          Have we reached close parenthesis?\n         BE    GETASIDG            Yes, assume we've got it.\n         CLI   0(R7),C' '          Have we hit a blank?\n         BE    GETASIDG            Yes, assume we've got it.\n         MVC   0(1,R4),0(R7)       Otherwise move one character over.\n         LA    R4,1(,R4)           Bump one ASIDWK character (target)\n         LA    R7,1(,R7)           Bump command buffer pointer.\n         LA    R8,1(,R8)           Bump character counter.\n         BCT   R6,GETASIDL         Loop for 4 characters.\n         B     GETASIDG            We don't look for more than 4.\nGETASIDG DS    0H\n*        APUT  ASIDWK,4\n         LA    R4,ASIDWK           Point register at workarea again.\n         LA    R1,4                Maximum of 4 characters.\nGETASIDA DS    0H\n         CLI   3(R4),X'40'         Is last character a blank (<4 total)\n         BNE   GETASIDM            No. We're finished sliding.\n         BCTR  R4,0                Slide the pointer one place back.\n         BCT   R1,GETASIDA         Do it no more than 4 times.\nGETASIDM DS    0H\n         MVC   ASIDMV(4),0(R4)     Move 4 characters so last one\n*                                     is not blank.\n         MVC   ASIDWKSV(4),ASIDMV    Save these 4 characters\n         MVC   ASIDWKS(4),ASIDMV        in two places.\n         MVC   OUTPUT,OUTPUT-1       Clear output line.\n         MVC   OUTPUT(25),ASIDMSG    Move coded display format asid.\n         APUT  OUTPUT,40             And put out the message.\n         TR    ASIDMV(4),ASIDVAL     Translate display format message\n*                                      into format X'0h0h0h0h'.\n*        MVC   OUTPUT,OUTPUT-1       Test display of hex result.\n*        HEX   OUTPUT,4,ASIDMV\n*        APUT  OUTPUT,10\n         BAL   R9,VALIDTR            Validity check the hex number.\n         PACK  ASIDGET(3),ASIDMV(5)  Get rid of all zone nibbles.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Search ASID   :' Print resulting 2-bytes\n         HEX   OUTPUT+21,2,ASIDBIN\n         APUT  OUTPUT,30\n         APUT  MESSAGEL,L'MESSAGEL   Add underline for clear display.\n*\nGETASIDE DS    0H                    End of routine.\n         LM    R1,R6,SAVERGS1        Restore registers\n         L     R9,SAVER9C               and\n         BR    R9                          exit.\n** ---------------------------------------------------------------- **\nASIDWKB  DC    CL4'    '\nASIDWK   DC    CL4'    '\nASIDWKF  DC    CL4' '\nASIDMV   DC    CL4'    '\nASIDMVF  DC    CL4' '\nASIDBIN  DS    0XL2\nASIDGET  DC    XL4'00000000'\nSAVERGS1 DS    6F\n** ---------------------------------------------------------------- JOE\n*   GETASCB - return ASCB, given the asid of address space          JOE\n*   -------                                                         JOE\n*  Input:                                                           JOE\n*      FOUNASID = ASID                                              JOE\n*  Output:                                                          JOE\n*      r15 = 0    Error                                             JOE\n*      r15 = ASCB                                                   JOE\n** ---------------------------------------------------------------- JOE\nGETASCB  DS    0H                                                   JOE\n         ST    R9,SAVER9M            Save Register                  JOE\n         L     R15,CVTPTR            R15 -> cvt                     JOE\n         L     R15,CVTASVT-CVT(,R15)  R15 -> asvt                   JOE\n         USING ASVT,R15                                             JOE\n         CLC   ASVTASVT-ASVT(4,R15),=C'ASVT'  check eyecatcher      JOE\n         BNE   NOASCB                                               JOE\n         LA    R15,ASVTENTY-ASVT(,R15) Get first asvt slot          JOE\n         LH    R0,FOUNASID           Get asid in question           JOE\n         BCTR  R0,0                  Down By 1                      JOE\n         SLL   R0,2                  Multiply by 4                  JOE\n         AR    R15,R0                Point to ASCB                  JOE\n         B     GETASCBE              Exit this routine              JOE\nNOASCB   DS    0H                                                   JOE\n         XR    R15,R15               Clear r15 - no ASCB there      JOE\nGETASCBE DS    0H                                                   JOE\n         L     R9,SAVER9M            Restore Register               JOE\n         BR    R9                                                   JOE\n** ---------------------------------------------------------------- JOE\n*                   Translate table to validity check ASID.\n*                     Convert display values to X'0h'\n*                     (where h is the hex value).\nASIDVAL  DS    0D\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'00CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CC0A0B0C0D0E0FCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CC0A0B0C0D0E0FCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'00010203040506070809CCCCCCCCCCCC'\nFILLER1  DS    CL24\nASIDMSG  DC    CL21'ASID parm entered  : '\nASIDWKSV DC    CL4' '\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\nFINDCSCB DS    0H                  Find CSCB entry to change or report.\n         ST    R9,SAVER9D          Save registers.\n         ST    R3,SAVER3A\nFINDCSST DS    0H                  Get the first CSCB.\n         L     R3,16               CVT\n         L     R3,X'94'(,R3)       MSER - pointer to CSCB chain.\n         ICM   R3,15,0(R3)         First CSCB entry.\n         USING CHAIN,R3            Tell assembler.\n         BZ    FINDCSEC            If zero, we are at end of CSCB chain\nFINDCSLP DS    0H                  Loop through the CSCB entries.\n         MVC   CSCBACTF(1),CHACT     Save CSCB ACT flag for this CSCB.\n         MVC   CSCBJOBI(8),CHKEY     Save CSCB Jobid (CHKEY).\n         MVC   CSCBPROC(8),CHCLS     Save CSCB PROC id (CHCLS).\n         MVC   CSCBASID(2),CHASID    Save CSCB ASID (CHASID).\n* ------------------------------------------------------------------- *\n* We first try to match a JOBID if coded, to the job id in this CSCB. *\n* If equal, we see if an ASID has been coded, and both have to match. *\n* Otherwise, with no match, we go to the end of the CSCB chain.       *\n* ------------------------------------------------------------------- *\nFINDCSMY DS    0H                  Find the CSCB that I want.\n         TM    FLAG1,X'04'         Was ASID( coded at all?\n         BZ    FINDCSJB            No. Just find a JOBID match.\n         TM    FLAG1,X'01'         Is the JOB id missing?\n         BO    FINDCSAS            Yes, just look for an ASID match.\n         TM    FLAG1,X'02'         Was JOB id coded?\n         BO    FINDCSJB            Yes. Look for it.\n         ICM   R3,15,0(R3)         Go to next CSCB.\n         BZ    FINDCSEC            If zero, we are at end of CSCB chain\n         B     FINDCSLP            Look at next CSCB entry in table.\nFINDCSJB DS    0H                  Check for JOBID match in this CSCB.\n         CLC   JOBID(8),CSCBJOBI   Compare coded JOBID to CSCB jobname.\n         BE    FINDCSIA            Equal, check if ASID is there.\n         ICM   R3,15,0(R3)         Otherwise go to the next CSCB.\n         BZ    FINDCSEC            Zero, end of the CSCB chain.\n         B     FINDCSLP            Not zero, look at the next entry.\nFINDCSIA DS    0H\n         TM    FLAG1,X'04'         Was ASID( coded?\n         BZ    FINDCSFD            No. Found it on just a job match.\n*                                   So this is the first job that\n*                                   matched, if there are multiple\n*                                   jobs with the same name.\nFINDCSAS DS    0H                  Check the ASID in the CSCB.\n         CLC   ASIDBIN(2),CSCBASID Is this our ASID? Does it match.\n         BE    FINDCSFD            I guess we found it.\n         ICM   R3,15,0(R3)         Go to the next CSCB.\n         BZ    FINDCSEC            Zero marks the end of the CSCB chain\n         B     FINDCSLP            Not zero. Look at the next entry.\nFINDCSFD DS    0H                  Our CSCB has been found.\n         ST    R3,FOUNCSCB         Save found CSCB address.\n         MVC   FOUNACTF,CHACT      Save\n         MVC   FOUNJOBI,CHKEY        CSCB\n         MVC   FOUNPROC,CHCLS          info.\n         MVC   FOUNASID,CHASID\n         BAL   R9,PRNTCSCB         Print info from the current CSCB.\n         BAL   R9,FORCHACT         Format some CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Put out an underline.\n         B     FINDCSEN            Go to end of routine.\n         DROP  R3\nFINDCSEC DS    0H                  Came to end of CSCB chain.\n         APUT  MESSAGEN,L'MESSAGEN   Then put out a message\n         B     EOJ4                  And end with code 4.\nFINDCSEN DS    0H\n         L     R3,SAVER3A\n         L     R9,SAVER9D\n         BR    R9\n*            Constants associated with this routine.    -    below\nFOUNACTF DC    X'00'\nFOUNCSCB DS    F                   FOUND CSCB ADDRESS\nFOUNJOBI DC    CL8' '\nFOUNPROC DC    CL8' '\nFOUNASID DC    H'0'\nCSCBACTF DC    X'00'\nCSCBJOBI DC    CL8' '\nCSCBPROC DC    CL8' '\nCSCBASID DC    H'0'\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\nVALIDTR  DS    0H                  Validate hex characters coded.\n         ST    R9,SAVER9E          Save\n         STM   R4,R6,SAVEWRK          registers.\n         LA    R4,ASIDMV           Point to translated display chars.\n         LA    R6,ASIDWKS          Point to chars with error signs.\n         LA    R5,4                BCT register - only 4 times.\nVALIDTRS DS    0H\n         CLI   0(R4),X'CC'         Is this an invalid character?\n         BE    VALIDTRR            Yes. Substitute a ? for message.\n         LA    R4,1(,R4)           Next translated character.\n         LA    R6,1(,R6)           Next char for error message.\n         BCT   R5,VALIDTRS         Loop to test validity of this char.\n         TM    ERRASID,X'01'       After 4 chars, any errors found?\n         BO    VALIDERR            Yes. Write messages.\n         B     VALIDTRE            No. Get out of routine.\nVALIDTRR DS    0H                  Come here if invalid char found.\n         OI    ERRASID,X'01'       Flag that at least one was found.\n         MVI   0(R6),C'?'          Substitute a ? for it in message.\n         LA    R4,1(,R4)           Next translated character.\n         LA    R6,1(,R6)           Next char in error message.\n         BCT   R5,VALIDTRS         Check that character for validity.\nVALIDERR DS    0H                  Error messages if char is invalid.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(37),ASIDBADM\n         APUT  OUTPUT,45\n*        MVC   OUTPUT,OUTPUT-1\n*        MVC   OUTPUT(51),MSGBADPR\n*        APUT  OUTPUT,52\n         B     EOJ4                Get out with code 4.\nVALIDTRE DS    0H\n         L     R4,SAVER4B          Restore regs used in this routine.\n         LM    R4,R6,SAVEWRK\n         BR    R9\n*            Constants associated with this routine.    -    below\nERRASID  DC    X'00'\nSAVEWRK  DS    3F\nMSGBADPR DC    C'Bad ASID entered. Use end parenthesis ) to delimit.'\nASIDBADM DC    CL33'Bad Characters marked with a ?:  '\nASIDWKS  DC    CL4' '\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\n* -- -- -- -- -- -- -- -- -- -- -- --    R3 points to a CSCB address\nPRNTCSCB DS    0H                  Print a CSCB entry.\n         ST    R9,SAVER9F          Save BAL register.\n         ST    R3,SAVECSCB         Saved found CSCB address.\n         USING CHAIN,R3\n*                   Print info from current CSCB\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Job  ID :'\n         MVC   OUTPUT+11(8),CHKEY\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Proc ID :'\n         MVC   OUTPUT+11(8),CHCLS\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'ASID    :'\n         HEX   OUTPUT+11,2,CHASID\n         APUT  OUTPUT,25\n         TM    FLAG2,X'40'\n         BO    PRNTCSC1\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Previous CHACT Flags:'\n         HEX   OUTPUT+23,1,CHACT\n         APUT  OUTPUT,25\n         B     PRNTCSC2\nPRNTCSC1 DS    0H\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Current  CHACT Flags:'\n         HEX   OUTPUT+23,1,CHACT\n         APUT  OUTPUT,25\nPRNTCSC2 DS    0H\n         DROP  R3\n         L     R3,SAVECSCB         Restore register to what it was.\n         L     R9,SAVER9F          Restore BAL register and\n         BR    R9                     branch back to caller.\nSAVECSCB DS    F                   Saved address of found CSCB.\n** ---------------------------------------------------------------- **\nRUNCSCB  DS    0H                  Run through the CSCB chain.\n         ST    R9,SAVER9G\n         ST    R3,SAVER3C\n         ST    R7,SAVER7A\nRUNCSCBT DS    0H\n         TM    FLAG2,X'40'         Only run if CSCB keyword was coded.\n         BZ    RUNCSCBE            Not coded, get out.\n*                                  Display this is a CSCB chain run.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(40),=C'This is a run of the CSCB Chain only ...'\n         APUT  OUTPUT,45\n         APUT  MESSAGEL,L'MESSAGEL   Print underline.\n*                                  Find the CSCB chain:\n         L     R3,16               CVT\n         L     R3,X'94'(,R3)       MSER - pointer to CSCB chain.\n         ICM   R3,15,0(R3)         First CSCB entry.\n         BZ    RUNCSCBE            If zero, end of CSCB chain.\n*                                  Otherwise points to next CSCB in\n*                                    the table.\n         USING CHAIN,R3\nRUNCSCBD DS    0H                  Loop through CSCB entries.\n         MVC   CSCBACTF(1),CHACT     Save CSCB ACT flag for this CSCB.\n         MVC   CSCBJOBI(8),CHKEY     Save CSCB JOBID (CHKEY).\n         MVC   CSCBPROC(8),CHCLS     Save CSCB PROC id (CHCLS).\n         MVC   CSCBASID(2),CHASID    Save CSCB ASID (CHASID).\n*  Test\n*        MVC   OUTPUT,OUTPUT-1\n*        HEX   OUTPUT,2,CHASID\n*        HEX   OUTPUT+6,2,ASIDBIN\n*        MVI   OUTPUT+15,C'i'\n*        APUT  OUTPUT,25\n*  Test\n* -- Limit print of entries to Jobname or ASID only ----  below\n         CLI   JOBID,C'-'          Are we printing the whole CSCB?\n         BE    RUNCSCBY            Yes.\n         CLC   ASIDBIN,=X'0000'    Was an ASID coded for a search?\n         BNE   RUNCSCB2            No. Just check for Jobname.\nRUNCSCB1 DS    0H                  Check for Jobname match.\n         XR    R7,R7               Clear work register.\n         IC    R7,SAVCOUNT         Insert saved length of Jobid.\n         BCTR  R7,0                Decrement for execute.\n         EX    R7,RUNCSCOM         Do the compare for proper length.\n*        BNE   RUNCSCBS            Not equal, don't print result.\n         BE    RUNCSCBP            Equal, print this CSCB entry.\nRUNCSCB2 DS    0H                  Check if ASID was coded.\n         CLC   ASIDBIN,CHASID      ASID match?\n         BNE   RUNCSCBS            No. Skip print of CSCB entry.\nRUNCSCBY DS    0H\n* -- Limit print of entries to Jobname or ASID only ----  above\nRUNCSCBP DS    0H                  Print this entry....\n         BAL   R9,PRNTCSCB         Print of current CSCB information.\n         BAL   R9,FORCHACT         Format some CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline line.\nRUNCSCBS DS    0H                  If skipping an entry print, go here.\n         ICM   R3,15,0(R3)         Go to next CSCB entry in table.\n         BZ    RUNCSCBE            If it is zero, end of CSCB chain.\n         B     RUNCSCBD            Not zero, loop to next entry and\n*                                    print it.\nRUNCSCBE DS    0H                  End of routine.\n         L     R3,SAVER3C          Restore\n         L     R7,SAVER7A\n         L     R9,SAVER9G             registers and\n         BR    R9                        go back to caller.\nRUNCSCOM CLC   JOBID(*-*),CHKEY    Executed\n         DROP  R3\n** ---------------------------------------------------------------- **\nKEYZERO  DS    0H                  Into Key 0 and change CSCB cntl blk.\n         ST    R9,SAVER9H\n         ST    R4,SAVER4A\n*\n* -- >  Test if this command is being run APF Authorized - below\n         STM   R15,R1,SAVE14T1     Now save registers and test if APF\n         XR    R15,R15                  authorized.\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.\n* -- >  Test if this command is being run APF Authorized - above\n*\n* -- >    ***    Do as little as possible under Key 0.    ***\nKEYPRLIM DS    0H\n         TM    ONSWIT,X'01'        Are we OR-ing?\n         BZ    SWITOFF             No. Try AND-ing?\n         MVC   CANCKEY0,CANCINDC   Pre-process affecting bits.\n         B     SWITON              All done pre-processing.\nSWITOFF  DS    0H\n         TM    ONSWIT,X'02'        Are we AND-ing?\n         BZ    KEY0BYPS            No. Don't do anything else.\n         XC    CANCINDC,=X'FF'     Reverse the affected bits for AND.\n         MVC   CANCKEY0,CANCINDC   And move them to staging area.\nSWITON   DS    0H\n         USING CHAIN,R3\n         L     R3,FOUNCSCB         Save address of \"found CSCB\".\n*\n* -- >                             We're authorized. Go Key 0.\n         MODESET KEY=ZERO\n         TM    ONSWIT,X'01'        Are we OR-ing?\n         BZ    KEY0OFF             No. Try AND-ing.\n         OC    CHACT(1),CANCKEY0   Do the OR.\n         B     KEY0END             Out of Key 0.\nKEY0OFF  DS    0H\n         TM    ONSWIT,X'02'        Are we AND-ing?\n         BZ    KEY0END             No. Get out altogether.\n         NC    CHACT(1),CANCKEY0   Do the AND.\nKEY0END  DS    0H                  Out of Key 0.\n         MODESET KEY=NZERO\n*\nKEY0BYPS DS    0H                  Key 0 bypass - branch to here.\n         DROP  R3\n         L     R4,SAVER4A\n         L     R9,SAVER9H\n         BR    R9\n** ---------------------------------------------------------------- **\nPRNWCSCB DS    0H                  Print the changed CSCB entry.\n         ST    R9,SAVER9I          Save BAL register.\n         ST    R3,SAVER3D\n         L     R3,FOUNCSCB         Saved found CSCB address.\n         USING CHAIN,R3\n*                   Print info from changed CSCB.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Job  ID :'\n         MVC   OUTPUT+11(8),CHKEY\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Proc ID :'\n         MVC   OUTPUT+11(8),CHCLS\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'ASID    :'\n         HEX   OUTPUT+11,2,CHASID\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Modified CHACT Flags:'\n         HEX   OUTPUT+23,1,CHACT\n         APUT  OUTPUT,25\n         APUT  MESSAGEL,L'MESSAGEL\n         DROP  R3\n         L     R3,SAVER3D          Restore register to what it was.\n         L     R9,SAVER9I          Restore BAL register and\n         BR    R9                     branch back to caller.\n** ---------------------------------------------------------------- **\nFORCHACT DS    0H                  Format the CHACT Flags\n         ST    R9,SAVER9J          Save\n         ST    R3,SAVER3E             registers.\n         USING CHAIN,R3\nFORCANC0 DS    0H                  Show cancelable or not.\n         TM    CHACT,CHCL          Is job cancelable?\n         BO    FORCANC1            Yes, show cancelable.\n         BZ    FORCANC2            No. Show non-cancelable.\n         B     FORFORC0            Fall through, try forceable.\nFORCANC1 DS    0H\n         MVC   MESSTXT,MESSCAN     Tell em job is cancelable.\n         B     FORCANCP\nFORCANC2 DS    0H\n         MVC   MESSTXT,MESSNCN     Tell em job is non-cancelable.\nFORCANCP DS    0H                  Write the actual message out.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(28),FORMTMSG\n         APUT  OUTPUT,30\nFORFORC0 DS    0H                  Show forceable or not.\n         TM    CHACT,CHAFORCE      Is job forceable?\n         BO    FORFORC1            Yes, show forceable.\n         BZ    FORFORC2            No. Show non-forceable.\nFORFORC1 DS    0H\n         MVC   MESSTXT,MESSFOR     Tell em job is forceable.\n         B     FORFORCP\nFORFORC2 DS    0H\n         MVC   MESSTXT,MESSNFR     Tell em job is non-forceable.\nFORFORCP DS    0H                  Write the actual message out.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(28),FORMTMSG\n         APUT  OUTPUT,30\nFORCHEND DS    0H\n         DROP  R3\n         L     R3,SAVER3E          Restore\n         L     R9,SAVER9J             registers.\n         BR    R9\n*            Constants associated with this routine.    -    below\nMESSCAN  DC    CL14'Cancelable    '\nMESSNCN  DC    CL14'Non-Cancelable'\nMESSFOR  DC    CL14'Forcible      '\nMESSNFR  DC    CL14'Non-Forcible  '\nFORMTMSG DS    0CL28\nMESS000  DC    CL14'Job Status:   '\nMESSTXT  DC    CL14'              '\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\nPRINTERR DS    0H                    Print help messages.\n         ST    R9,SAVER9K            Save BAL register.\n         APUT  MESSAG2A,L'MESSAG2A\n         APUT  MESSAG2B,L'MESSAG2B\n         APUT  MESSAG2U,L'MESSAG2U\n         APUT  MESSAG2C,L'MESSAG2C\n         APUT  MESSAG2D,L'MESSAG2D\n         APUT  MESSAG2E,L'MESSAG2E\n         APUT  MESSAG2F,L'MESSAG2F\n         APUT  MESSAGEM,L'MESSAGEM\n         APUT  MESSAG2G,L'MESSAG2G\n         APUT  MESSAG2H,L'MESSAG2H\n         APUT  MESSAGEM,L'MESSAGEM\n         APUT  MESSAG2I,L'MESSAG2I\n         APUT  MESSAG2J,L'MESSAG2J\n         APUT  MESSAG2K,L'MESSAG2K\n         APUT  MESSAG2L,L'MESSAG2L\n         APUT  MESSAG2M,L'MESSAG2M\n         APUT  MESSAG2N,L'MESSAG2N\n         APUT  MESSAG2O,L'MESSAG2O\n         APUT  MESSAG2P,L'MESSAG2P\n         APUT  MESSAG2Q,L'MESSAG2Q\n         APUT  MESSAG2R,L'MESSAG2R\n         APUT  MESSAG2S,L'MESSAG2S\n         APUT  MESSAG2T,L'MESSAG2T\n         APUT  MESSAGEM,L'MESSAGEM\n         L     R9,SAVER9K            Restore BAL register.\n         BR    R9\n** ---------------------------------------------------------------- **\nKEY0SWNS DS    0H                    Key 0 for SWAP or NSWP\n         ST    R9,SAVER9L            Save BAL register.\n         ST    R6,SAVER6A\nKEY0TSTA DS    0H\n* -- >  Test if this command is being run APF Authorized - below\n         STM   R15,R1,SAVE14T1     Now save registers and test if APF\n         XR    R15,R15                  authorized.\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.\n* -- >  Test if this command is being run APF Authorized - above\n         TM    FLAG2,X'04'         Make ASID swappable?\n         BO    KEY0SWAP            Yes. Do it.\n         TM    FLAG2,X'08'         Make ASID non-swappable?\n         BO    KEY0NSWP            Yes. Do it.\n         B     KEY0EXIT            Not SWAP or NSWP, don't belong here.\n*\nKEY0NSWP DS    0H                    Make address space non-swappable.\n*\n         CLC   OWNASID,FOUNASID      Target asid different from ours?\n         BE    KEY0DNSW              No. Just do SYSEVENT.\n         MVC   FUNC,=CL8'DONTSWAP'   Set nswapping function         JOE\n         BAL   R9,BUILDSRB           Build SRB block                JOE\n*                                                                   JOE\n* ISSUE SUCCESSFUL MESSAGE                                          JOE\n*                                                                   JOE\n         MVC   MESSAGNS+4(8),FOUNJOBI                               JOE\n         HEX   MESSAGNS+22,2,FOUNASID                               JOE\n         APUT  MESSAGNS,L'MESSAGNS                                  JOE\n         L     R6,SAVER6A            Restore Register               JOE\n         L     R9,SAVER9L            Restore BAL register.          JOE\n         BR    R9                    go back                        JOE\nTEMPSAVE DS    4F                    save area                      JOE\n* ---------------------------------------------------------------- *\nKEY0DNSW DS    0H\n         MODESET MODE=SUP,KEY=ZERO\nKEY0SYSD DS    0H\n         LH    R6,FOUNASID\n         SYSEVENT DONTSWAP,ASID=(R6),ENTRY=SVC\nKEY0NNRM DS    0H\n         MODESET MODE=PROB,KEY=NZERO\n         MVC   MESSAGNS+4(8),FOUNJOBI\n         HEX   MESSAGNS+22,2,FOUNASID                               JOE\n         APUT  MESSAGNS,L'MESSAGNS\n         B     KEY0EXIT\nKEY0SWAP DS    0H                    Make address space swappable.\n         CLC   OWNASID,FOUNASID      Target asid different from ours?\n         BE    KEY0DSWP              No. Just do SYSEVENT.\n         MVC   FUNC,=CL8'OKSWAP'     Set function                   JOE\n         BAL   R9,BUILDSRB           Build SRB CSA CONTROL BLOCKS   JOE\n*                                                                   JOE\n*  issue successful message                                         JOE\n*                                                                   JOE\n         MVC   MESSAGSW+4(8),FOUNJOBI                               JOE\n         HEX   MESSAGSW+22,2,FOUNASID                               JOE\n         APUT  MESSAGSW,L'MESSAGSW                                  JOE\n         L     R6,SAVER6A            Restore Registers              JOE\n         L     R9,SAVER9L            Restore BAL register.          JOE\n         BR    R9                                                   JOE\nKEY0DSWP DS    0H\n         LH    R6,FOUNASID\n         SYSEVENT OKSWAP,ASID=(R6),ENTRY=SVC\nKEY0SNRM DS    0H\n         MODESET MODE=PROB,KEY=NZERO\n         MVC   MESSAGSW+4(8),FOUNJOBI\n         HEX   MESSAGSW+22,2,FOUNASID                               JOE\n         APUT  MESSAGSW,L'MESSAGSW\n         B     KEY0EXIT\nKEY0NODO DS    0H\n         MODESET MODE=PROB,KEY=NZERO\n         HEX   MESSAGNG+43,1,SYSEVCOD+3\n         APUT  MESSAGNG,L'MESSAGNG\nKEY0EXIT DS    0H\n         L     R6,SAVER6A\n         L     R9,SAVER9L            Restore BAL register.\n         BR    R9\n*--------------------------------------------------------------*    JOE\n*                                                              *    JOE\n*        BUILD SRB CONTROL BLOCK AND ACCOMPANYING CODE         *    JOE\n*                                                              *    JOE\n*--------------------------------------------------------------*    JOE\nBUILDSRB DS    0H                                                   JOE\n         STM   R6,R9,TEMPSAVE        Save Registers                 JOE\n         BAL   R9,GETASCB            Find ASCB for this asid        JOE\n         LR    R9,R15                Hold ASCB                      JOE\n         L     R9,0(,R9)             Point to ASCB                  JOE\n         MODESET MODE=SUP,KEY=ZERO   Get into supervisor state      JOE\n*                                                                   JOE\nCSA_LEN  EQU  SRBSIZE+84             CSA SRBLOCK AND PARAMTERS      JOE\n*                                                                   JOE\n*---------------------------------------------------------------*   JOE\n*       Get CSA for SRB CONTROL BLOCK SUBPOOL 241               *   JOE\n*---------------------------------------------------------------*   JOE\n         STORAGE OBTAIN,SP=241,LENGTH=CSA_LEN Get Some CSA          JOE\n         LR    R6,R1                 Point R6 to SRB control block  JOE\n         USING SRB,R6                Address SRB                    JOE\n         XC    SRB(SRBSIZE),SRB      Clear out SRB                  JOE\n         ST    R9,SRBASCB            Save ASCB                      JOE\n         LA    R8,SRBSIZE(,R6)       R8 -> paramlist                JOE\n*       Get CSA paramter list                                   *   JOE\n         ST    R8,SRBPARM            Store paramter list address    JOE\n         LA    R7,72(,R8)            Point to ECB                   JOE\n         XC    0(4,R7),0(R7)         Clear ECB Address              JOE\n         LA    R7,4(,R7)             Point to ASCB                  JOE\n         MVC   0(4,R7),X'224'        Move \"HOME\" PSAAOLD address sp JOE\n         LA    R7,4(,R7)             Bump to next param             JOE\n         CLC   FUNC,=C'DONTSWAP'     Q. non swappable function      JOE\n         BE    NONSWAP               Yes; branch if so              JOE\n         MVC   0(4,R7),=C'OKSW'      Otherwise swappable            JOE\n         B     SETEPA                Set SRB program entry point    JOE\nNONSWAP  DS    0H                                                   JOE\n         MVC   0(4,R7),=C'DONT'      Set FUNCTION IN R7             JOE\n*---------------------------------------------------------------*   JOE\n*       Get CSA for SRB CONTROL BLOCK SUBPOOL 227               *   JOE\n*---------------------------------------------------------------*   JOE\nSETEPA   DS    0H                                                   JOE\n         STORAGE OBTAIN,SP=227,LENGTH=SWAPLEN  Get Fixed CSA        JOE\n         ST    R1,SRBEPA             Set entry point                JOE\n         LR    R14,R1                Hold that thought              JOE\n         LA    R15,SWAPLEN           Get Length                     JOE\n         LR    R1,R15                                               JOE\n         LA    R0,SWAPXMEM           Point to SRB routine           JOE\n         MVCL  R14,R0                Move routine                   JOE\n*                                                                   JOE\n         SCHEDULE SRB=(R6),SCOPE=GLOBAL,MODE=NONXM                  JOE\n*                                                                   JOE\n         LA    R7,72(,R8)            Point to ECB                   JOE\n*                                                                   JOE\n         WAIT  ECB=(R7)                                             JOE\n*                                                                   JOE\n         L     R9,SRBEPA             Get Entry Point Address        JOE\n*                                                                   JOE\n         STORAGE RELEASE,ADDR=(R6),LENGTH=CSA_LEN,SP=241            JOE\n*                                                                   JOE\n         STORAGE RELEASE,ADDR=(R9),LENGTH=SWAPLEN,SP=227            JOE\n*                                                                   JOE\n         MODESET KEY=NZERO,MODE=PROB                                JOE\n*                                                                   JOE\n         LM    R6,R9,TEMPSAVE        Save Registers                 JOE\n         BR    R9                    Return                         JOE\nSYSEVCOD DC    F'0'                  SYSEVENT Return Code\nOLDAX    DS    F\nWAREA    DS    D                     Work area\nWAREB    DS    D                     Work area\n** ---------------------------------------------------------------- **\n** --         C  O  N  S  T  A  N  T  S                          -- **\n** ---------------------------------------------------------------- **\nMESSAGNA DC    C'Command was not invoked APF authorized.'\nMESSAGEN DC    C'End of CSCB chain was reached.'\nMESSAGEY DC    C'No valid keyword was coded.'\nFLAG1    DC    X'00'\n*              X'01'               ASID ONLY - NO JOBNAME\n*              X'02'               JOBNAME IS PRESENT.\n*              X'04'               ASID( WAS PRESENT IN PARMS.\n*              X'08'               CSCB CHAIN DISPLAY ONLY.\nFLAG2    DC    X'00'\n*              X'01'               CNCL WAS CODED\n*              X'02'               NCNC WAS CODED\n*              X'04'               SWAP WAS CODED\n*              X'08'               NSWP WAS CODED\n*              X'10'               FORC WAS CODED\n*              X'20'               CSCB WAS CODED\nONSWIT   DC    X'00'\n*              X'01'               TURN BIT ON\n*              X'02'               TURN BIT OFF\nHEXSAVE  DS    3F                  SAVE FOR HEX MACRO\nSAVE     DS    9D                  Program Save Area\nSAVE14T1 DS    2D                  Save \"system-used\" registers.\n         DC    C' '                Blank before OUTPUT line.\nOUTPUT   DC    CL80'  '            Variable output line.\nFUNC     DS    CL8                 Swapppinmg function\n         LTORG\n*-----------------------------------------------------------------* JOE\n*                         SRB CODE                                * JOE\n*-----------------------------------------------------------------* JOE\nSWAPXMEM DS    0D                                                   JOE\n         DROP  R12,R11,R10                                          JOE\n         BASR  R5,0                                                 JOE\n         USING *,R5                Entry Point                      JOE\n         LR    R10,R14             Save return address              JOE\n         LR    R13,R1                                               JOE\n*                                                                   JOE\n         LA    R9,72(,R13)         Point to ECB Address             JOE\n         LA    R8,76(,R13)         Point to ASCB Address            JOE\n         L     R8,0(,R8)                                            JOE\n         L     R7,80(,R13)         Get code                         JOE\n*                                                                   JOE\n         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=STDSAVE         JOE\n*                                                                   JOE\n         C      R7,=C'OKSW'        OKSWAP                           JOE\n         BE     SETSWAP                                             JOE\n*                                                                   JOE\n         SYSEVENT DONTSWAP,ENTRY=BRANCH                             JOE\n*                                                                   JOE\n         B      UNLOCK                                              JOE\n*                                                                   JOE\nSETSWAP  DS     0H                                                  JOE\n         SYSEVENT OKSWAP,ENTRY=BRANCH                               JOE\n*                                                                   JOE\nUNLOCK   DS     0H                                                  JOE\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE                    JOE\n*                                                                   JOE\n*                                                                   JOE\n         POST  (R9),ASCB=(R8),ERRET=GOBACK,LINKAGE=BRANCH           JOE\n*                                                                   JOE\nGOBACK   LR    R14,R10               Return Address                 JOE\n         BR    R14                   Return                         JOE\n         LTORG                                                      JOE\nSWAPRTM  DS    0D                                                   JOE\nSWAPLEN  EQU   *-SWAPXMEM                                           JOE\n** ---------------------------------------------------------------- **\n         SPACE\n         TITLE '- MAPPING MACROS.'\n         CVT   DSECT=YES           Map the CVT.\n         IEECHAIN                  Map the CSCB control block.\n         IHASRB                                                     JOE\n         IHAASVT                                                    JOE\n         IHAASCB                                                    JOE\n         IHAASXB                                                    JOE\n         IRAOUCB                                                    JOE\n         IHAPSA   DSECT=YES,LIST=YES                           HD APR88\n         IHAFRRS\n         EJECT                                                 HD APR88\n         IKJEFLWA                                                   JOE\n         END   CNCLPG\n** ---------------------------------------------------------------- **\n*  -----------------------------------------------------------------  *\n*  --           Create PUTLINE environment.                       --  *\n*  -----------------------------------------------------------------  *\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUEMNTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   128                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         IHAPSA   DSECT=YES,LIST=YES                           HD APR88\n         EJECT\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   14,12,12(13)       SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES            RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    1,8(13)            OUR SAVE AREA POINTER\n         ST    13,4(1)            POINTER TO CALLERS SAVE AREA\n         LR    13,1               @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(R13)         POINT TO CALLERS RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 ASSUME BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 ASSUME BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(RML)               MESSAGE LENGTH\n         STH   R15,PUTLEN                 PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    2,R13                    @OUR SAVE AREA\n         LR    3,R15                    SAVE RETURN CODE\n         L     R13,4(R13)               @CALLERS SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,3                    RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CNCLPG27": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1b\\x00\\'\\x01\\x11)\\x8f\\x01\\x17\\x14?\"\\x14\\x07\\x0f\\x062\\x00\\x00\\xe5\\xf1\\xd9\\xf2\\xd4\\xf7@@@@'", "ispf": {"version": "01.27", "flags": 0, "createdate": "2011-10-25T00:00:00", "modifydate": "2017-05-23T22:14:27", "lines": 1807, "newlines": 1586, "modlines": 0, "user": "V1R2M7"}, "text": "CNCLPG   TITLE 'Make address space cancelable, non-swappable, etc. '\n*  -----------------------------------------------------------------  *\n*                                                                     *\n*    Function:   To make an address space Cancelable or               *\n*                Non-Cancelable, Forcible or Non-Forcible,            *\n*                Swappable or Non-Swappable.  Or BURN the             *\n*                address space (version 1.2.5).  KILL the             *\n*                address space is same as BURN, but first             *\n*                the non-MEMTERM bits in the ASCB are                 *\n*                turned off (version 1.2.6).                          *\n*                                                                     *\n*                If the address space is non-MEMTERM-able,            *\n*                and you try to BURN it, an error message             *\n*                is issued, and nothing occurs.  But if you           *\n*                try and KILL it, the non-MEMTERM bits are            *\n*                turned off, and the address space is whacked.        *\n*                The message will tell you so.                        *\n*                                                                     *\n*    Authority:  You need PSCB OPER authority to run this             *\n*                command.  To do the BURN and KILL functions,         *\n*                you ALSO need PSCB ACCOUNT authority.                *\n*                                                                     *\n*  -----------------------------------------------------------------  *\n*                                                                     *\n*    Notes:                                                           *\n*                                                                     *\n*           CANCELABLE, NON-CANCELABLE, FORCIBLE, NON-FORCIBLE:       *\n*                                                                     *\n*    CSCB        Cancelable, Non-cancelable, Forcible, Non-forcible   *\n*    chain       are determined by bit settings in the address        *\n*                space's CSCB, which is part of the CSCB chain.       *\n*                                                                     *\n*    Jobname     Each active address space has a CSCB in the chain.   *\n*    and/or      You get to a particular address space by running     *\n*    ASID        the entire CSCB chain (mapped by the IEECHAIN        *\n*    match       macro) looking for a match on jobname and/or ASID,   *\n*                and preferably on both.                              *\n*                                                                     *\n*    DISPlay     There may be more than one address space for a       *\n*    or          given job name, and more than one CSCB entry         *\n*    \"CSCB\"      for a given ASID.  The CSCB or DISPlay option        *\n*    option      of CNCLPG will run the entire CSCB chain and         *\n*                it will show ALL the matches for the parameters      *\n*                given.  To display the ENTIRE CSCB chain from start  *\n*                to finish, use a dash ( - ) instead of the jobname.  *\n*                                                                     *\n*    Multiple    If only the jobname or the ASID number alone         *\n*    jobs        are used to do an ACTION, then CNCLPG will stop      *\n*    with the    at the FIRST CSCB which matches, when an ACTION is   *\n*    same name   called for (but NOT for a DISPLAY).  That is why     *\n*                it is better to run the DISPlay (or CSCB) function   *\n*                of CNCLPG first, to display all the possible CSCB    *\n*                entries that might match, before changing any        *\n*                particular address space.  There might be more       *\n*                than one address space with the same jobname or      *\n*                ASID, and you want to change only the correct        *\n*                one, NOT the wrong one.  So it is good practice      *\n*                to display first, and then do a change to the        *\n*                exact address space you want to affect, using        *\n*                both the jobname and ASID(hhhh) parameters.          *\n*                                                                     *\n*           SWAPPABLE AND NON-SWAPPABLE:                              *\n*                                                                     *\n*    SWAP and    Setting an address space to be swappable or          *\n*    NSWP need   non-swappable, is accomplished by executing          *\n*    to run a    a SYSEVENT macro.  This has to execute in the        *\n*    SYSEVENT    target address space, and it was done here by        *\n*    macro in    scheduling an SRB to run in the target address       *\n*    the         space, when it is different from the address         *\n*    target      space running the program.  That piece of code       *\n*    address     was written by Joe Reichman.  Thanks, Joe.           *\n*    space       You did the hard part!                               *\n*                                                                     *\n*    -------------------------------------------------------------    *\n*    BURN        BURN -  Kill the designated address space with a     *\n*    (v 1.2.5)   CALLRTM TYPE=MEMTERM (like a FORCE).  Be careful !   *\n*    -------------------------------------------------------------    *\n*    KILL        KILL -  Kill the designated address space with a     *\n*    (v 1.2.6)   CALLRTM TYPE=MEMTERM (like a FORCE).  Be careful !   *\n*                KILL is a \"super BURN\".  Be VERY careful.....!       *\n*                Before doing the MEMTERM, KILL turns off bits        *\n*                in the ASCB (ASCBNOMT and ASCBNOMD), the             *\n*                \"non-FORCIBLE\" bits.  Can whack any address space.   *\n*    (v 1.2.7)   You need PSCB ACCOUNT authority to run BURN or KILL, *\n*                along with OPER authority to run the rest of the     *\n*                program.                                             *\n*    -------------------------------------------------------------    *\n*                                                                     *\n*    Syntax:     TSO Command:  APF-authorized.                        *\n*                                                                     *\n*        CNCLPG |jobid \u00ddASID(hhhh)\u00a8 |CNCL|NCNC|FORC|NFRC|NSWP|SWAP    *\n*               |ASID(hhhh)         |CNCL|NCNC|FORC|NFRC|NSWP|SWAP    *\n*               |                   |CSCB or DISP                     *\n*               |                   |BURN                             *\n*               |                   |KILL                             *\n*               |-  (displays the entire CSCB chain)                  *\n*               |?  (displays help)                                   *\n*                                                                     *\n*    Date:       April 15, 2010                                       *\n*                                                                     *\n*    Latest Modification:   May 21, 2017                              *\n*                                                                     *\n*    Authors:    Sam Golob, Joe Reichman (who did the hard part)      *\n*                                                                     *\n*    Technical Detail:  PUTLINE interface for TSO Output.             *\n*                       Uses the APUT macro, and EPUTL module.        *\n*                                                                     *\n*    Changes:  1.  SWAP, NSWP support dropped from this program       *\n*                   initially.  Version is 1.0.0.                     *\n*                                                                     *\n*              2.  Messages and DISP improved, to just show matching  *\n*                   CSCB chain entries, instead of all of them.       *\n*                   Coding a dash instead of a jobname or asid(hhhh)  *\n*                   - will display the entire CSCB chain.             *\n*                                                                     *\n*              3.  SWAP, NSWP support put back in this program.       *\n*                   Version is 1.1.0   (June 16, 2010)                *\n*                   It now does your own address space.  The cross    *\n*                   memory stuff was not put in yet, to make other    *\n*                   address spaces swappable, or non-swappable.       *\n*                                                                     *\n*              4.  Complete SWAP, NSWP support for cross address      *\n*                   space communication, was put in by Joe            *\n*                   Reichman.  (Oct 2011)  Version is 1.2.0.          *\n*                                                                     *\n*              5.  Burn an address space, if that is desired.         *\n*                   (Oct 2012)  Version is 1.2.5.                     *\n*                                                                     *\n*              6.  Kill an address space.  Before you do the          *\n*                  CALLRTM MEMTERM, the non-forcible flags in the     *\n*                  ASCB are turned off.                               *\n*                   (May 2017)  Version is 1.2.6.                     *\n*                                                                     *\n*              7.  Authority checking. So far, you need PSCB OPER     *\n*                   to do anything. ACCT to do BURN or KILL.          *\n*                   Version is 1.2.7.                                 *\n*                                                                     *\n*   Change   Pgmr                   Description                       *\n*   -------  -----   ----------------------------------------------   *\n*                                                                     *\n*            JOER     Add SRB code to allow swapping in xmem.         *\n*                     (See lines commented with JOE.)                 *\n*                                                                     *\n*  -----------------------------------------------------------------  *\n*\n*  This macro lets you display hex values in a report.\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    STM   R15,R1,HEXSAVE           Save work registers.\n         LA    R1,&FROM                 Load from address.\n         LA    R0,&LEN                  Load length of hex number.\n         LA    R15,&TO                  Load to address.\n         BAL   R9,HEX                   BAL to routine.\n         LM    R15,R1,HEXSAVE           Restore work registers.\n         MEND\n*  -----------------------------------------------------------------  *\n*  --           Create PUTLINE environment.                       --  *\n*  -----------------------------------------------------------------  *\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP THE PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\n* --       End of Internal Macros......                            -- *\n* ------------------------------------------------------------------- *\n         SPACE 3\nCNCLPG   CSECT\nCNCLPG   AMODE 31\nCNCLPG   RMODE ANY\n         YREGS\n         USING CNCLPG,R15          (Establish temporary base).\n         B     BEGIN               Skip over eyecatcher.\nEYEC0    DC    AL1(EYECL)          Exclusive length of header.\nEYEC     DC    C' CNCLPG - &SYSDATE - &SYSTIME -'\n         DC    C'     --------------------------------    '\n         DC    C' VER 1.2.7   '\n         DC    C'                   '\nEYECL    EQU   *-EYEC\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)     Save caller's registers\n         LR    R6,R1               Preserve CPPL pointer.\n         LR    R12,R15             Copy base.\n         USING CNCLPG,R12,R11,R10  (Tell assembler).\n         LA    R11,4095(,R12)      Load bases.\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)\n         LA    R10,1(,R10)\n         LR    R14,R13             Copy caller's save area pointer.\n         LA    R13,SAVE            Point to my save area.\n         ST    R13,8(,R14)         Chain ...\n         ST    R14,SAVE+4          ... Save areas.\n*                                  Get PSCBATR1 byte and copy it\n         ST    R1,SAVER1A          Save work register\n         L     R1,16               CVTPTR\n         L     R1,0(,R1)           TCB words\n         L     R1,4(,R1)           Current TCB\n         L     R1,180(,R1)         TCBJSCB\n         L     R1,264(,R1)         JSCBPSCB\n         LA    R1,0(,R1)           Clear hi order byte\n         LTR   R1,R1               Is there a PSCB ?\n         BZ    NOTFOUND            No, Issue COMMAND-NOT-FOUND msg\n         MVI   FLAG0,X'00'         Zero FLAG0 for safety\n         MVC   FLAG0(1),X'10'(R1)  Overlay it with PSCBATR1\n         L     R1,SAVER1A          Restore work register\nAUTHTEST DS    0H\n         TM    FLAG0,X'80'         PSCB OPER AUTHORITY?\n         BZ    NOTFOUND            No, Issue COMMAND-NOT-FOUND msg\nINITCON  DS    0H                  Initialize some constants.\n         MVI   FLAG1,X'00'\n         MVI   FLAG2,X'00'\n         MVI   ONSWIT,X'00'\n         MVI   RTMCOD,X'00'\n         MVI   ERRASID,X'00'\n         MVI   CANCINDC,X'00'\n         MVI   KILLFLAG,X'00'\n         MVI   OUTPUT-1,X'40'\n         MVC   OUTPUT,OUTPUT-1\n         MVI   NEWCHACT,X'00'\n*        B     TEST                TEST CODE\nMYASID   DS    0H                  Get my ASID\n         L     R2,X'224'           Point to PSAAOLD (my ASCB)\n         LA    R2,X'24'(,R2)       Point to my own ASID (ASCBASID)\n         MVC   OWNASID(2),0(R2)    Save it for comparison later\n         B     PRTITLE             Branch past constant\nOWNASID  DS    H\nPRTITLE  DS    0H                  Print program title.\n         APUT  MESSAGET,L'MESSAGET\n         APUT  MESSAGEU,L'MESSAGEU\nCONT0    DS    0H                  Look at command's parameters.\n         LTR   R6,R6               Any CPPL?\n         BZ    EOJ8                No.  Get out.\n         L     R1,0(,R6)           Pt to cmd buffer. (R6 reused later)\n         LTR   R1,R1               Any CMD buffer?\n         BZ    EOJ8                Get out if none.\n         LH    R3,0(,R1)           Load length.\n         CH    R3,=H'4'            Anything?\n         BNH   EOJ4                No. Get out.\n         LR    R5,R3               Length of command + 4\n         ICM   R5,14,FULLZERO      Clear hi order 3 bytes.\n         LH    R3,2(,R1)           Load offset.\n         SR    R5,R3               Subtract offset from full length+4\n         SH    R5,=H'4'            Correct for length of cmdbufr header\n         BC    8,WMESS2            Zero, message to enter userid.\n         BC    5,EOJ8              Less, or overflow, out.\nPARM     DS    0H\n         BAL   R9,GETIDS           Get parameters for the command.\n         B     EOJ0\n*\n* --- Parms gotten at this point.                            -------- *\n*\n** ---------------------------------------------------------------- **\nWMESS2   DS    0H                  Print help messages.\n         BAL   R9,PRINTERR\n         B     EOJ4\n** ---------------------------------------------------------------- **\nEOJ0     DS    0H                  End of job.\n         APUT  RETURN0,L'RETURN0\n         LA    R15,0               Set CC = 0.\n         B     RETURN\nEOJ4     DS    0H\n         APUT  RETURN4,L'RETURN4\n         LA    R15,4               Set CC = 4.\n         B     RETURN\nEOJ8     DS    0H\n         APUT  RETURN8,L'RETURN8\n         LA    R15,8               Set CC = 8.\n         B     RETURN\nRETURN   L     R13,SAVE+4\n         L     R14,12(,R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n** ---------------------------------------------------------------- **\nNOTAUTH  DS    0H                  Command not APF authorized message.\n         APUT  MESSAGNA,L'MESSAGNA\n         B     EOJ4\n** ---------------------------------------------------------------- **\nNOTFOUND DS    0H                  Fake command not found message.\n         APUT  MESSAGAU,L'MESSAGAU\n         B     RETURN\n** ---------------------------------------------------------------- **\nNOTALLOW DS    0H                  Command NOT ALLOWED message.\n         APUT  MESSAGAT,L'MESSAGAT\n         B     RETURN\n** ---------------------------------------------------------------- **\nNOTMEMTM DS    0H                  Address space not MEMTERM-able.\n         MVC   MESSAGNM+4(8),FOUNJOBI    Jobname into message\n         HEX   MESSAGNM+22,2,FOUNASID    ASID into message\n         APUT  MESSAGNM,L'MESSAGNM       Say job Not-Memterm-able\n         B     RETURN\n** ---------------------------------------------------------------- **\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        Get the parameters for the command.                      *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*   Notes:  The ASID(xxx) can be coded first, without a userid.   *\n*           A dash can be coded first, to run the entire CSCB     *\n*            chain and display all the jobnames in it, with       *\n*            their associated ASIDs.  ? coded first gives HELP.   *\n*           If you code the word CSCB or DISP(lay) after either   *\n*            a jobname or an ASID(hhhh) then a display of ALL     *\n*            matching CSCB chain entries will be displayed, and   *\n*            no changes will be made.                             *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETIDS   DS    0H                  Get all parameters for the program.\n         ST    R9,SAVER9A\n         ST    R4,SAVER4C\n         AR    R1,R3               Point ...\n         LA    R1,4(,R1)           ... to char.\n         LA    R6,8                Load reg for BCT loop.\n         LR    R7,R1               Initialize pointer to first\n         LA    R7,0(,R7)                character of the ID field.\n         LA    R8,0                Initialize character count.\n         MVC   JOBID(8),BLANKS     Clear (first param - JOBNAME) field.\n         LA    R4,JOBID            Point reg to beginng of JOBID field.\n*\nCUTIDLEN DS    0H                  Look at the JOBID field first.\n*                                  (May contain ASID( or CSCB.)\n*\n         CLI   0(R7),X'40'         Is this character a blank?\n         BE    NOMORCUT            Yes, we are at the end of the field.\n         MVC   0(1,R4),0(R7)       Move only one character at a time.\n         OC    JOBID(8),BLANKS     And uppercase the partial jobid.\n*\n*   Is this a run of the CSCB chain only?\n* -- >  Test for CSCB  first  ---- below\n         CLI   JOBID,C'-'          Did we code '-' first?\n         BNE   CSCBHELP            No. Try if help asked for.\n         B     CSCBRUN1            Yes. Run entire CSCB chain.\n* - > Help\nCSCBHELP DS    0H\n         CLI   JOBID,C'?'          Help?\n         BNE   NOCSCB              No. Skip this code.\n         BAL   R9,PRINTERR         Yes. Print messages\n         B     EOJ0                  and get out with code 0.\n* - > Help\nCSCBRUN1 DS    0H\n         ST    R8,SAVER8A          Store count for display if needed.\n         OI    FLAG2,X'40'         Mark that this is CSCB only run.\n         BAL   R9,RUNCSCB          Do the run for CSCB chain.\n         B     EOJ0                Out with normal return code.\nNOCSCB   DS    0H\n* -- >  Test for CSCB  first  ---- above\n*\n*   Was the ASCB(hhh) parameter coded without the jobid?\n* -- >  Test for ASID( first  ---- below\n         CLC   JOBID(L'ASIDC),ASIDC  Did we code ASID( in jobid field?\n         BNE   NOASIDF             No. Pass this code.\n         OI    FLAG1,X'01'         Flag that ASID( ) was first.\n         NI    FLAG1,X'FF'-X'02'   Turn off Jobname in jobid field flag\n         MVC   ASIDWKL(L'ASIDC),JOBID  Move the ASID( to proper field.\n         MVC   JOBID,BLANKS        Blank out Job ID if ASID( coded.\n         LA    R7,1(,R7)           Bump another character.\n         LA    R8,1(,R8)           Count another character.\n         LA    R6,1                Set number of branches later.\n*                                  This will limit number of params\n*                                   that are searched for.\n         B     ASIDONLY            Bypass all the real jobname stuff.\n* -- >  Test for ASID( first  ---- above\nNOASIDF  DS    0H                  ASID( is not the first parameter.\n         LA    R4,1(,R4)           Bump another character.\n         LA    R7,1(,R7)           Bump another character.\n         LA    R8,1(,R8)           Count another character.\n         CR    R8,R5               End of command buffer ?\n         BNL   NOMORCUT            Yes. Get out now.\n         BCT   R6,CUTIDLEN         Try for the next blank, up till 8.\nNOMORCUT DS    0H\n         STC   R8,SAVCOUNT         Save length of Jobname\n         L     R4,SAVER4C          Restore work register for use later.\n         OC    JOBID(8),BLANKS     Uppercase the new Job Id.\n         OI    FLAG1,X'02'         Set 'Jobname Coded' flag.\n*  -  Display the found JOBID - below\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Search Jobname:'\n         MVC   OUTPUT+17(8),JOBID\n         APUT  OUTPUT,30\n         APUT  MESSAGEL,L'MESSAGEL\n*  -  Display the found JOBID - above\n         LA    R6,1                Set number of branches later.\n*                                  This will limit number of params\n*                                   that are searched for.\n         B     LOOKKEYW\n*  Constants - below - ***\nJOBID    DC    C'        '         STORE PARM USERID HERE\nBLANKS   DC    C'        '         8 BLANKS\nMESSAGET DC    C'CNCLPG 1.2.7 - Make a Job, STC or TSU Cancelable, etc.X\n                (? for help)'\nMESSAGEU DC   C'------ ----- - ---- - ---- --- -- --- ----------- ----'\nMESSAGEL DC    C'----------------------------'\nMESSAGEM DC    C'-----------------------------------------------'\nMESSAG2A DC    C'Enter JOBNAME and/or ASID(hhhh) after COMMAND name,'\nMESSAG2B DC    C'   then CNCL, NCNC, FORC, NFRC, NSWP, or SWAP. '\nMESSAG2V DC    C'To get rid of the address space, code BURN or KILL.'\nMESSAG2U DC    C'Or code CSCB or DISP to just display CSCB entries.'\nMESSAG2C DC    C'   DISPlay or CSCB will display CSCB chain entries,'\nMESSAG2D DC    C'   without changing them.'\nMESSAG2E DC    C' When affecting a job, we want to be accurate, '\nMESSAG2F DC    C'  therefore you should use the DISPlay option first.'\nMESSAG2G DC   C' To display the whole CSCB, code - (dash) for JOBNAME.'\nMESSAG2H DC    C' To see this help message, code ? for JOBNAME.'\nMESSAG2I DC    C'Notes (important) : '\nMESSAG2J DC   C' CSCB (DISP) display for an ASID shows all occurrences'\nMESSAG2K DC    C'  for that ASID, regardless of JOBNAME.      '\nMESSAG2L DC C' CSCB (DISP) display for a JOBNAME shows all occurrences'\nMESSAG2M DC    C'  for that JOBNAME, regardless of ASID.      '\nMESSAG2N DC    C' CNCL, NCNC, FORC, NFRC, NSWP, SWAP changes the FIRST'\nMESSAG2O DC    C'  entry in the CSCB chain that matches, if multiple '\nMESSAG2P DC    C'  entries exist. But DISP will display ALL applicable'\nMESSAG2Q DC    C'  matching entries in the CSCB chain, so you can see'\nMESSAG2R DC    C'  which one you want to change specifically.'\nMESSAG2S DC    C' When you code BOTH jobname and asid, to CHANGE it,'\nMESSAG2T DC    C'  then ONLY that specific job and asid gets changed.'\nMESSAGE3 DC    C'WE GOT HERE'\nMESSAGE4 DC    C'TEST CHECK THIS'\nMESSAGNG DC    C'Job was not done. SYSEVENT return code was     '\nMESSAGNS DC    C'Job xxxxxxxx for ASID HHHH made non-swappable.'\nMESSAGSW DC    C'Job xxxxxxxx for ASID HHHH was made swappable.'\nMESSAGAN DC    C'Job xxxxxxxx for ASID HHHH already non-swappable.'\nMESSAGAS DC    C'Job xxxxxxxx for ASID HHHH was already swappable.'\nMESSAGFN DC    C'Function xxxx was called for.'\nMESSAGBU DC    C'Job xxxxxxxx for ASID HHHH has been burned.'\nMESSAGKI DC    C'Job xxxxxxxx for ASID HHHH has been killed.'\nMESSAGAU DC    C'IKJ56500I COMMAND CNCLPG NOT FOUND'\nMESSAGAT DC    C'Lacking authority to execute this command.'\nMESSAGNM DC    C'Job xxxxxxxx for ASID HHHH not MEMTERM-able.'\nRETURN0  DC    C'Return code is 0'\nRETURN4  DC    C'Return code is 4'\nRETURN8  DC    C'Return code is 8'\n*                     ***  Places to save registers  ***  below\nSAVER1A  DS    F\nSAVER3A  DS    F\nSAVER3B  DS    F\nSAVER3C  DS    F\nSAVER3D  DS    F\nSAVER3E  DS    F\nSAVER4A  DS    F\nSAVER4B  DS    F\nSAVER4C  DS    F\nSAVER5A  DS    F\nSAVER6A  DS    F\nSAVER6B  DS    F\nSAVER7A  DS    F\nSAVER7B  DS    F\nSAVER8A  DS    F\nSAVER9A  DS    F\nSAVER9B  DS    F\nSAVER9C  DS    F\nSAVER9D  DS    F\nSAVER9E  DS    F\nSAVER9F  DS    F\nSAVER9G  DS    F\nSAVER9H  DS    F\nSAVER9I  DS    F\nSAVER9J  DS    F\nSAVER9K  DS    F\nSAVER9L  DS    F\nSAVER9M  DS    F\nSAVER9N  DS    F\n*                     ***  Places to save registers  ***  above\nSAVCOUNT DS    X\nKILLFLAG DS    X                                                    KIL\n*              X'01'               KILL indicated\n*              X'02'               BURN indicated\nDUBLZERO DC    D'0'\nFULLZERO DC    F'0'\nCANCINDC DC    X'00'\nCANCKEY0 DC    X'00'\nNEWCHACT DC    X'00'\n*  Constants - above - ***\nLOOKKEYW DS    0H                  Look for additional keywords.\n         LA    R7,1(,R7)           Bump command buffer pointer.\n         LA    R8,1(,R8)           Bump character counter.\n         CR    R8,R5               End of command buffer?\n         BNL   GETIDEND            Yes. Don't look any more.\n         MVC   ASIDWKL(5),BLANKS   Clear parameter work field.\n         MVC   ASIDWKL(5),0(R7)    Next 5 characters to work field.\nASIDONLY DS    0H                  Jump to here if ASID( coded first.\n         OC    ASIDWKL(4),BLANKS   Uppercase work field.\n         CLC   ASIDC,ASIDWKL       Is the ASID( keyword there?\n         BE    DOASID              Yes. Process it.\n         CLC   CNCLC,ASIDWKL       Is the CNCL  keyword there?\n         BE    DOCNCL              Yes. Process it.\n         CLC   NCNCC,ASIDWKL       Is the NCNC  keyword there?\n         BE    DONCNC              Yes. Process it.\n         CLC   SWAPC,ASIDWKL       Is the SWAP  keyword there?\n         BE    DOSWAP              Yes. Process it.\n         CLC   NSWPC,ASIDWKL       Is the NSWP  keyword there?\n         BE    DONSWP              Yes. Process it.\n         CLC   FORCC,ASIDWKL       Is the FORC  keyword there?\n         BE    DOFORC              Yes. Process it.\n         CLC   NFRCC,ASIDWKL       Is the NFRC  keyword there?\n         BE    DONFRC              Yes. Process it.\n         CLC   CSCBC,ASIDWKL       Is the CSCB  keyword there?\n         BE    DOCSCB              Yes. Process it.\n         CLC   DISPC,ASIDWKL       Is the DISP  keyword there?\n         BE    DOCSCB              Yes. Process it.\n         CLC   BURNC,ASIDWKL       Is the BURN  keyword there?      BUR\n         BE    DOBURN              Yes. Process it.                 BUR\n         CLC   KILLC,ASIDWKL       Is the KILL  keyword there?      KIL\n         BE    DOKILL              Yes. Process it.                 KIL\n         B     LOOKKEYW            Go loop and look at next character.\nASIDWKL  DC    CL5' '              Second parameter work area.\n*\nASIDC    DC    C'ASID('            Literals....\nCNCLC    DC    C'CNCL'\nNCNCC    DC    C'NCNC'\nSWAPC    DC    C'SWAP'\nNSWPC    DC    C'NSWP'\nFORCC    DC    C'FORC'\nNFRCC    DC    C'NFRC'\nCSCBC    DC    C'CSCB'\nDISPC    DC    C'DISP'\nBURNC    DC    C'BURN'                                              BUR\nKILLC    DC    C'KILL'                                              KIL\n*\nDOASID   DS    0H                  Look for hex value of the ASID.\n         OI    FLAG1,X'04'         Show that ASID( was coded.\n         BAL   R9,GETASID          Go get the rest of the parameters.\n         MVC   ASIDWKL(5),BLANKS   Blank out the second wkarea for\n*                                   a further parameter search.\n         B     LOOKKEYW            Re-loop to look further for params.\n*\nDOCNCL   DS    0H                  Handle CNCL (cancelable) keyword.\n         OI    CANCINDC,X'08'      Show which CHACT bit is affected.\n         OI    FLAG2,X'01'         Show that CNCL was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'01'        Set to OR the bits\n         NI    ONSWIT,X'FF'-X'02'   and not to AND the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n* ------------------------------------------------------------------- *\n*                                    Print the action code.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),CNCLC\n         APUT  OUTPUT,25\n*                                    Print the bit in CHACT affected.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDONCNC   DS    0H                  Handle NCNC (non-cancelable) keyword\n         OI    CANCINDC,X'08'      Show which CHACT bit is affected.\n         OI    FLAG2,X'02'         Show that NCNC was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'02'        Set to AND the bits\n         NI    ONSWIT,X'FF'-X'01'   and not to OR the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n*                                    Print the action code.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),NCNCC\n         APUT  OUTPUT,25\n*                                    Print the bit in CHACT affected.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDOSWAP   DS    0H                  Now this routine is operational.\n         OI    FLAG2,X'04'         Show that SWAP was coded.\n         MVC   MESSAGFN+9(4),SWAPC   Write message to say that.\n         APUT  MESSAGFN,L'MESSAGFN\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         BAL   R9,KEY0SWNS         Do SYSEVENT OKSWAP, xmem or not.\n         BCT   R6,LOOKKEYW\n         B     GETIDEND\n* ------------------------------------------------------------------- *\nDONSWP   DS    0H                  Now this routine is operational.\n         OI    FLAG2,X'08'         Show that NSWP was coded.\n         MVC   MESSAGFN+9(4),NSWPC   Write message to say that.\n         APUT  MESSAGFN,L'MESSAGFN\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         BAL   R9,KEY0SWNS         Do SYSEVENT DONTSWAP, xmem or not.\n         BCT   R6,LOOKKEYW\n         B     GETIDEND\n* ------------------------------------------------------------------- *\nDOFORC   DS    0H                  Handle FORC (forcible) keyword\n         OI    FLAG2,X'10'         Show which CHACT bit is affected.\n         OI    CANCINDC,X'01'      Show that FORC was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'01'        Set to OR the bits\n         NI    ONSWIT,X'FF'-X'02'   and not to AND the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n*\n         MVC   OUTPUT,OUTPUT-1       Print the action code.\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),FORCC\n         APUT  OUTPUT,25\n*\n         MVC   OUTPUT,OUTPUT-1       Print the bit in CHACT affected.\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDONFRC   DS    0H                  Handle NFRC (non-forcible) keyword\n         OI    FLAG2,X'20'         Show which CHACT bit is affected.\n         OI    CANCINDC,X'01'      Show that NFRC was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'02'        Set to AND the bits\n         NI    ONSWIT,X'FF'-X'01'   and not to OR the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n*\n         MVC   OUTPUT,OUTPUT-1       Print the action code.\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),NFRCC\n         APUT  OUTPUT,25\n*\n         MVC   OUTPUT,OUTPUT-1       Print the bit in CHACT affected.\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDOCSCB   DS    0H\n         OI    FLAG1,X'08'         Show CSCB keyword was coded.\n         OI    FLAG2,X'40'         Show CSCB keyword was coded.\n         MVC   OUTPUT,OUTPUT-1       Print the action code.\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),CSCBC\n         MVC   OUTPUT+23(9),=C'(DISPlay)'\n         APUT  OUTPUT,35\n         BAL   R9,RUNCSCB          Run the CSCB chain with print.\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nGETIDEND DS    0H                  End of keyword processing.\n         TM    FLAG2,X'FF'         Check if any real actions asked  BUR\n         BM    GETKEYNR            Yes, some were.\n         APUT  MESSAGEY,L'MESSAGEY    No. Display help messages.\n         BAL   R9,PRINTERR\n         B     EOJ4                   And end with code = 4.\nGETKEYNR DS    0H                  Real actions WERE asked for.\n         B     EOJ0                So end with normal return code.\n         L     R9,SAVER9A\n         BR    R9\n** ---------------------------------------------------------------- **\nHEX      DS    0H                  Display hex values.\n         ST    R9,SAVER9B\n         MVC   1(1,R15),0(R1)      Move byte.\n         UNPK  0(3,R15),1(2,R15)   Unpack.\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)         Increment output pointer.\n         LA    R1,1(,R1)           Increment input pointer.\n         BCT   R0,HEX              Decrement length, then loop.\n         MVI   0(R15),C' '         Blank the trailing byte.\n         L     R9,SAVER9B\n         BR    R9                  Return to caller.\nHEXTAB   DC    C'0123456789ABCDEF' Translate table.\n** ---------------------------------------------------------------- **\nGETASID  DS    0H                  Get hex ASID for 2 bytes.\n         ST    R9,SAVER9C          Save registers.\n         STM   R1,R6,SAVERGS1\n         LA    R6,4                Load BCT register.\n         LA    R4,ASIDWK           Point to ASID work area.\n         TM    FLAG1,X'02'         Ask if Job name was coded.\n         BZ    GETAFL01            Wasn't. Have to adjust pointers.\n         LA    R7,5(,R7)           Bump command buffer pointer.\n         LA    R8,5(,R8)           Bump character counter.\nGETAFL01 DS    0H\nGETASIDL DS    0H                  Loop to get hex ASID for 4 display\n*                                    bytes to convert to 2 hex bytes.\n         CLI   0(R7),C')'          Have we reached close parenthesis?\n         BE    GETASIDG            Yes, assume we've got it.\n         CLI   0(R7),C' '          Have we hit a blank?\n         BE    GETASIDG            Yes, assume we've got it.\n         MVC   0(1,R4),0(R7)       Otherwise move one character over.\n         LA    R4,1(,R4)           Bump one ASIDWK character (target)\n         LA    R7,1(,R7)           Bump command buffer pointer.\n         LA    R8,1(,R8)           Bump character counter.\n         BCT   R6,GETASIDL         Loop for 4 characters.\n         B     GETASIDG            We don't look for more than 4.\nGETASIDG DS    0H\n*        APUT  ASIDWK,4\n         LA    R4,ASIDWK           Point register at workarea again.\n         LA    R1,4                Maximum of 4 characters.\nGETASIDA DS    0H\n         CLI   3(R4),X'40'         Is last character a blank (<4 total)\n         BNE   GETASIDM            No. We're finished sliding.\n         BCTR  R4,0                Slide the pointer one place back.\n         BCT   R1,GETASIDA         Do it no more than 4 times.\nGETASIDM DS    0H\n         MVC   ASIDMV(4),0(R4)     Move 4 characters so last one\n*                                     is not blank.\n         MVC   ASIDWKSV(4),ASIDMV    Save these 4 characters\n         MVC   ASIDWKS(4),ASIDMV        in two places.\n         MVC   OUTPUT,OUTPUT-1       Clear output line.\n         MVC   OUTPUT(25),ASIDMSG    Move coded display format asid.\n         APUT  OUTPUT,40             And put out the message.\n         TR    ASIDMV(4),ASIDVAL     Translate display format message\n*                                      into format X'0h0h0h0h'.\n*        MVC   OUTPUT,OUTPUT-1       Test display of hex result.\n*        HEX   OUTPUT,4,ASIDMV\n*        APUT  OUTPUT,10\n         BAL   R9,VALIDTR            Validity check the hex number.\n         PACK  ASIDGET(3),ASIDMV(5)  Get rid of all zone nibbles.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Search ASID   :' Print resulting 2-bytes\n         HEX   OUTPUT+21,2,ASIDBIN\n         APUT  OUTPUT,30\n         APUT  MESSAGEL,L'MESSAGEL   Add underline for clear display.\n*\nGETASIDE DS    0H                    End of routine.\n         LM    R1,R6,SAVERGS1        Restore registers\n         L     R9,SAVER9C               and\n         BR    R9                          exit.\n** ---------------------------------------------------------------- **\nASIDWKB  DC    CL4'    '\nASIDWK   DC    CL4'    '\nASIDWKF  DC    CL4' '\nASIDMV   DC    CL4'    '\nASIDMVF  DC    CL4' '\nASIDBIN  DS    0XL2\nASIDGET  DC    XL4'00000000'\nSAVERGS1 DS    6F\n** ---------------------------------------------------------------- JOE\n*   GETASCB - return ASCB, given the asid of address space          JOE\n*   -------                                                         JOE\n*  Input:                                                           JOE\n*      FOUNASID = ASID                                              JOE\n*  Output:                                                          JOE\n*      r15 = 0    Error                                             JOE\n*      r15 = ASCB                                                   JOE\n** ---------------------------------------------------------------- JOE\nGETASCB  DS    0H                                                   JOE\n         ST    R9,SAVER9M            Save Register                  JOE\n         L     R15,CVTPTR            R15 -> cvt                     JOE\n         L     R15,CVTASVT-CVT(,R15)  R15 -> asvt                   JOE\n         USING ASVT,R15                                             JOE\n         CLC   ASVTASVT-ASVT(4,R15),=C'ASVT'  check eyecatcher      JOE\n         BNE   NOASCB                                               JOE\n         LA    R15,ASVTENTY-ASVT(,R15) Get first asvt slot          JOE\n         LH    R0,FOUNASID           Get asid in question           JOE\n         BCTR  R0,0                  Down By 1                      JOE\n         SLL   R0,2                  Multiply by 4                  JOE\n         AR    R15,R0                Point to ASCB                  JOE\n         B     GETASCBE              Exit this routine              JOE\nNOASCB   DS    0H                                                   JOE\n         XR    R15,R15               Clear r15 - no ASCB there      JOE\nGETASCBE DS    0H                                                   JOE\n         L     R9,SAVER9M            Restore Register               JOE\n         BR    R9                                                   JOE\n** ---------------------------------------------------------------- JOE\n*                   Translate table to validity check ASID.\n*                     Convert display values to X'0h'\n*                     (where h is the hex value).\nASIDVAL  DS    0D\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'00CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CC0A0B0C0D0E0FCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CC0A0B0C0D0E0FCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'00010203040506070809CCCCCCCCCCCC'\nFILLER1  DS    CL24\nASIDMSG  DC    CL21'ASID parm entered  : '\nASIDWKSV DC    CL4' '\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\nFINDCSCB DS    0H                  Find CSCB entry to change or report.\n         ST    R9,SAVER9D          Save registers.\n         ST    R3,SAVER3A\nFINDCSST DS    0H                  Get the first CSCB.\n         L     R3,16               CVT\n         L     R3,X'94'(,R3)       MSER - pointer to CSCB chain.\n         ICM   R3,15,0(R3)         First CSCB entry.\n         USING CHAIN,R3            Tell assembler.\n         BZ    FINDCSEC            If zero, we are at end of CSCB chain\nFINDCSLP DS    0H                  Loop through the CSCB entries.\n         MVC   CSCBACTF(1),CHACT     Save CSCB ACT flag for this CSCB.\n         MVC   CSCBJOBI(8),CHKEY     Save CSCB Jobid (CHKEY).\n         MVC   CSCBPROC(8),CHCLS     Save CSCB PROC id (CHCLS).\n         MVC   CSCBASID(2),CHASID    Save CSCB ASID (CHASID).\n* ------------------------------------------------------------------- *\n* We first try to match a JOBID if coded, to the job id in this CSCB. *\n* If equal, we see if an ASID has been coded, and both have to match. *\n* Otherwise, with no match, we go to the end of the CSCB chain.       *\n* ------------------------------------------------------------------- *\nFINDCSMY DS    0H                  Find the CSCB that I want.\n         TM    FLAG1,X'04'         Was ASID( coded at all?\n         BZ    FINDCSJB            No. Just find a JOBID match.\n         TM    FLAG1,X'01'         Is the JOB id missing?\n         BO    FINDCSAS            Yes, just look for an ASID match.\n         TM    FLAG1,X'02'         Was JOB id coded?\n         BO    FINDCSJB            Yes. Look for it.\n         ICM   R3,15,0(R3)         Go to next CSCB.\n         BZ    FINDCSEC            If zero, we are at end of CSCB chain\n         B     FINDCSLP            Look at next CSCB entry in table.\nFINDCSJB DS    0H                  Check for JOBID match in this CSCB.\n         CLC   JOBID(8),CSCBJOBI   Compare coded JOBID to CSCB jobname.\n         BE    FINDCSIA            Equal, check if ASID is there.\n         ICM   R3,15,0(R3)         Otherwise go to the next CSCB.\n         BZ    FINDCSEC            Zero, end of the CSCB chain.\n         B     FINDCSLP            Not zero, look at the next entry.\nFINDCSIA DS    0H\n         TM    FLAG1,X'04'         Was ASID( coded?\n         BZ    FINDCSFD            No. Found it on just a job match.\n*                                   So this is the first job that\n*                                   matched, if there are multiple\n*                                   jobs with the same name.\nFINDCSAS DS    0H                  Check the ASID in the CSCB.\n         CLC   ASIDBIN(2),CSCBASID Is this our ASID? Does it match.\n         BE    FINDCSFD            I guess we found it.\n         ICM   R3,15,0(R3)         Go to the next CSCB.\n         BZ    FINDCSEC            Zero marks the end of the CSCB chain\n         B     FINDCSLP            Not zero. Look at the next entry.\nFINDCSFD DS    0H                  Our CSCB has been found.\n         ST    R3,FOUNCSCB         Save found CSCB address.\n         MVC   FOUNACTF,CHACT      Save\n         MVC   FOUNJOBI,CHKEY        CSCB\n         MVC   FOUNPROC,CHCLS          info.\n         MVC   FOUNASID,CHASID\n         BAL   R9,PRNTCSCB         Print info from the current CSCB.\n         BAL   R9,FORCHACT         Format some CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Put out an underline.\n         B     FINDCSEN            Go to end of routine.\n         DROP  R3\nFINDCSEC DS    0H                  Came to end of CSCB chain.\n         APUT  MESSAGEN,L'MESSAGEN   Then put out a message\n         B     EOJ4                  And end with code 4.\nFINDCSEN DS    0H\n         L     R3,SAVER3A\n         L     R9,SAVER9D\n         BR    R9\n*            Constants associated with this routine.    -    below\nFOUNACTF DC    X'00'\nFOUNCSCB DS    F                   FOUND CSCB ADDRESS\nFOUNJOBI DC    CL8' '\nFOUNPROC DC    CL8' '\nFOUNASID DC    H'0'\nCSCBACTF DC    X'00'\nCSCBJOBI DC    CL8' '\nCSCBPROC DC    CL8' '\nCSCBASID DC    H'0'\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\nVALIDTR  DS    0H                  Validate hex characters coded.\n         ST    R9,SAVER9E          Save\n         STM   R4,R6,SAVEWRK          registers.\n         LA    R4,ASIDMV           Point to translated display chars.\n         LA    R6,ASIDWKS          Point to chars with error signs.\n         LA    R5,4                BCT register - only 4 times.\nVALIDTRS DS    0H\n         CLI   0(R4),X'CC'         Is this an invalid character?\n         BE    VALIDTRR            Yes. Substitute a ? for message.\n         LA    R4,1(,R4)           Next translated character.\n         LA    R6,1(,R6)           Next char for error message.\n         BCT   R5,VALIDTRS         Loop to test validity of this char.\n         TM    ERRASID,X'01'       After 4 chars, any errors found?\n         BO    VALIDERR            Yes. Write messages.\n         B     VALIDTRE            No. Get out of routine.\nVALIDTRR DS    0H                  Come here if invalid char found.\n         OI    ERRASID,X'01'       Flag that at least one was found.\n         MVI   0(R6),C'?'          Substitute a ? for it in message.\n         LA    R4,1(,R4)           Next translated character.\n         LA    R6,1(,R6)           Next char in error message.\n         BCT   R5,VALIDTRS         Check that character for validity.\nVALIDERR DS    0H                  Error messages if char is invalid.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(37),ASIDBADM\n         APUT  OUTPUT,45\n*        MVC   OUTPUT,OUTPUT-1\n*        MVC   OUTPUT(51),MSGBADPR\n*        APUT  OUTPUT,52\n         B     EOJ4                Get out with code 4.\nVALIDTRE DS    0H\n         L     R4,SAVER4B          Restore regs used in this routine.\n         LM    R4,R6,SAVEWRK\n         BR    R9\n*            Constants associated with this routine.    -    below\nERRASID  DC    X'00'\nSAVEWRK  DS    3F\nMSGBADPR DC    C'Bad ASID entered. Use end parenthesis ) to delimit.'\nASIDBADM DC    CL33'Bad Characters marked with a ?:  '\nASIDWKS  DC    CL4' '\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\n* -- -- -- -- -- -- -- -- -- -- -- --    R3 points to a CSCB address\nPRNTCSCB DS    0H                  Print a CSCB entry.\n         ST    R9,SAVER9F          Save BAL register.\n         ST    R3,SAVECSCB         Saved found CSCB address.\n         USING CHAIN,R3\n*                   Print info from current CSCB\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Job  ID :'\n         MVC   OUTPUT+11(8),CHKEY\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Proc ID :'\n         MVC   OUTPUT+11(8),CHCLS\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'ASID    :'\n         HEX   OUTPUT+11,2,CHASID\n         APUT  OUTPUT,25\n         TM    FLAG2,X'80'                Is this a BURN or KILL?   KIL\n         BO    PRNTFINI                   Yes. Abridge the messages BUR\n         TM    FLAG2,X'40'                CSCB only run. i.e. DISPLAY\n         BO    PRNTCSC1\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Previous CHACT Flags:'\n         HEX   OUTPUT+23,1,CHACT\n         APUT  OUTPUT,25\n         B     PRNTCSC2\nPRNTCSC1 DS    0H\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Current  CHACT Flags:'\n         HEX   OUTPUT+23,1,CHACT\n         APUT  OUTPUT,25\nPRNTCSC2 DS    0H\n         DROP  R3\nPRNTFINI DS    0H                                                   BUR\n         L     R3,SAVECSCB         Restore register to what it was.\n         L     R9,SAVER9F          Restore BAL register and\n*                                     branch back to caller.        BUR\n         BR    R9\nSAVECSCB DS    F                   Saved address of found CSCB.\n** ---------------------------------------------------------------- **\nRUNCSCB  DS    0H                  Run through the CSCB chain.\n         ST    R9,SAVER9G\n         ST    R3,SAVER3C\n         ST    R7,SAVER7A\nRUNCSCBT DS    0H\n         TM    FLAG2,X'40'         Only run if CSCB keyword was coded.\n         BZ    RUNCSCBE            Not coded, get out.\n*                                  Display this is a CSCB chain run.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(40),=C'This is a run of the CSCB Chain only ...'\n         APUT  OUTPUT,45\n         APUT  MESSAGEL,L'MESSAGEL   Print underline.\n*                                  Find the CSCB chain:\n         L     R3,16               CVT\n         L     R3,X'94'(,R3)       MSER - pointer to CSCB chain.\n         ICM   R3,15,0(R3)         First CSCB entry.\n         BZ    RUNCSCBE            If zero, end of CSCB chain.\n*                                  Otherwise points to next CSCB in\n*                                    the table.\n         USING CHAIN,R3\nRUNCSCBD DS    0H                  Loop through CSCB entries.\n         MVC   CSCBACTF(1),CHACT     Save CSCB ACT flag for this CSCB.\n         MVC   CSCBJOBI(8),CHKEY     Save CSCB JOBID (CHKEY).\n         MVC   CSCBPROC(8),CHCLS     Save CSCB PROC id (CHCLS).\n         MVC   CSCBASID(2),CHASID    Save CSCB ASID (CHASID).\n*  Test\n*        MVC   OUTPUT,OUTPUT-1\n*        HEX   OUTPUT,2,CHASID\n*        HEX   OUTPUT+6,2,ASIDBIN\n*        MVI   OUTPUT+15,C'i'\n*        APUT  OUTPUT,25\n*  Test\n* -- Limit print of entries to Jobname or ASID only ----  below\n         CLI   JOBID,C'-'          Are we printing the whole CSCB?\n         BE    RUNCSCBY            Yes.\n         CLC   ASIDBIN,=X'0000'    Was an ASID coded for a search?\n         BNE   RUNCSCB2            No. Just check for Jobname.\nRUNCSCB1 DS    0H                  Check for Jobname match.\n         XR    R7,R7               Clear work register.\n         IC    R7,SAVCOUNT         Insert saved length of Jobid.\n         BCTR  R7,0                Decrement for execute.\n         EX    R7,RUNCSCOM         Do the compare for proper length.\n*        BNE   RUNCSCBS            Not equal, don't print result.\n         BE    RUNCSCBP            Equal, print this CSCB entry.\nRUNCSCB2 DS    0H                  Check if ASID was coded.\n         CLC   ASIDBIN,CHASID      ASID match?\n         BNE   RUNCSCBS            No. Skip print of CSCB entry.\nRUNCSCBY DS    0H\n* -- Limit print of entries to Jobname or ASID only ----  above\nRUNCSCBP DS    0H                  Print this entry....\n         BAL   R9,PRNTCSCB         Print of current CSCB information.\n         BAL   R9,FORCHACT         Format some CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline line.\nRUNCSCBS DS    0H                  If skipping an entry print, go here.\n         ICM   R3,15,0(R3)         Go to next CSCB entry in table.\n         BZ    RUNCSCBE            If it is zero, end of CSCB chain.\n         B     RUNCSCBD            Not zero, loop to next entry and\n*                                    print it.\nRUNCSCBE DS    0H                  End of routine.\n         L     R3,SAVER3C          Restore\n         L     R7,SAVER7A\n         L     R9,SAVER9G             registers and\n         BR    R9                        go back to caller.\nRUNCSCOM CLC   JOBID(*-*),CHKEY    Executed\n         DROP  R3\n** ---------------------------------------------------------------- **\nKEYZERO  DS    0H                  Into Key 0 and change CSCB cntl blk.\n         ST    R9,SAVER9H\n         ST    R4,SAVER4A\n*\n* -- >  Test if this command is being run APF Authorized - below\n         STM   R15,R1,SAVE14T1     Now save registers and test if APF\n         XR    R15,R15                  authorized.\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.\n* -- >  Test if this command is being run APF Authorized - above\n*\n* -- >    ***    Do as little as possible under Key 0.    ***\nKEYPRLIM DS    0H\n         TM    ONSWIT,X'01'        Are we OR-ing?\n         BZ    SWITOFF             No. Try AND-ing?\n         MVC   CANCKEY0,CANCINDC   Pre-process affecting bits.\n         B     SWITON              All done pre-processing.\nSWITOFF  DS    0H\n         TM    ONSWIT,X'02'        Are we AND-ing?\n         BZ    KEY0BYPS            No. Don't do anything else.\n         XC    CANCINDC,=X'FF'     Reverse the affected bits for AND.\n         MVC   CANCKEY0,CANCINDC   And move them to staging area.\nSWITON   DS    0H\n         USING CHAIN,R3\n         L     R3,FOUNCSCB         Save address of \"found CSCB\".\n*\n* -- >                             We're authorized. Go Key 0.\n         MODESET KEY=ZERO\n         TM    ONSWIT,X'01'        Are we OR-ing?\n         BZ    KEY0OFF             No. Try AND-ing.\n         OC    CHACT(1),CANCKEY0   Do the OR.\n         B     KEY0END             Out of Key 0.\nKEY0OFF  DS    0H\n         TM    ONSWIT,X'02'        Are we AND-ing?\n         BZ    KEY0END             No. Get out altogether.\n         NC    CHACT(1),CANCKEY0   Do the AND.\nKEY0END  DS    0H                  Out of Key 0.\n         MODESET KEY=NZERO\n*\nKEY0BYPS DS    0H                  Key 0 bypass - branch to here.\n         DROP  R3\n         L     R4,SAVER4A\n         L     R9,SAVER9H\n         BR    R9\n** ---------------------------------------------------------------- **\nPRNWCSCB DS    0H                  Print the changed CSCB entry.\n         ST    R9,SAVER9I          Save BAL register.\n         ST    R3,SAVER3D\n         L     R3,FOUNCSCB         Saved found CSCB address.\n         USING CHAIN,R3\n*                   Print info from changed CSCB.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Job  ID :'\n         MVC   OUTPUT+11(8),CHKEY\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Proc ID :'\n         MVC   OUTPUT+11(8),CHCLS\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'ASID    :'\n         HEX   OUTPUT+11,2,CHASID\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Modified CHACT Flags:'\n         HEX   OUTPUT+23,1,CHACT\n         APUT  OUTPUT,25\n         APUT  MESSAGEL,L'MESSAGEL\n         DROP  R3\n         L     R3,SAVER3D          Restore register to what it was.\n         L     R9,SAVER9I          Restore BAL register and\n         BR    R9                     branch back to caller.\n** ---------------------------------------------------------------- **\nFORCHACT DS    0H                  Format the CHACT Flags\n         ST    R9,SAVER9J          Save\n         ST    R3,SAVER3E             registers.\n         USING CHAIN,R3\nFORCANC0 DS    0H                  Show cancelable or not.\n         TM    CHACT,CHCL          Is job cancelable?\n         BO    FORCANC1            Yes, show cancelable.\n         BZ    FORCANC2            No. Show non-cancelable.\n         B     FORFORC0            Fall through, try forceable.\nFORCANC1 DS    0H\n         MVC   MESSTXT,MESSCAN     Tell em job is cancelable.\n         B     FORCANCP\nFORCANC2 DS    0H\n         MVC   MESSTXT,MESSNCN     Tell em job is non-cancelable.\nFORCANCP DS    0H                  Write the actual message out.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(28),FORMTMSG\n         APUT  OUTPUT,30\nFORFORC0 DS    0H                  Show forceable or not.\n         TM    CHACT,CHAFORCE      Is job forceable?\n         BO    FORFORC1            Yes, show forceable.\n         BZ    FORFORC2            No. Show non-forceable.\nFORFORC1 DS    0H\n         MVC   MESSTXT,MESSFOR     Tell em job is forceable.\n         B     FORFORCP\nFORFORC2 DS    0H\n         MVC   MESSTXT,MESSNFR     Tell em job is non-forceable.\nFORFORCP DS    0H                  Write the actual message out.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(28),FORMTMSG\n         APUT  OUTPUT,30\nFORCHEND DS    0H\n         DROP  R3\n         L     R3,SAVER3E          Restore\n         L     R9,SAVER9J             registers.\n         BR    R9\n*            Constants associated with this routine.    -    below\nMESSCAN  DC    CL14'Cancelable    '\nMESSNCN  DC    CL14'Non-Cancelable'\nMESSFOR  DC    CL14'Forcible      '\nMESSNFR  DC    CL14'Non-Forcible  '\nFORMTMSG DS    0CL28\nMESS000  DC    CL14'Job Status:   '\nMESSTXT  DC    CL14'              '\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\nPRINTERR DS    0H                    Print help messages.\n         ST    R9,SAVER9K            Save BAL register.\n         APUT  MESSAG2A,L'MESSAG2A\n         APUT  MESSAG2B,L'MESSAG2B\n         APUT  MESSAG2V,L'MESSAG2V\n         APUT  MESSAG2U,L'MESSAG2U\n         APUT  MESSAG2C,L'MESSAG2C\n         APUT  MESSAG2D,L'MESSAG2D\n         APUT  MESSAG2E,L'MESSAG2E\n         APUT  MESSAG2F,L'MESSAG2F\n         APUT  MESSAGEM,L'MESSAGEM\n         APUT  MESSAG2G,L'MESSAG2G\n         APUT  MESSAG2H,L'MESSAG2H\n         APUT  MESSAGEM,L'MESSAGEM\n         APUT  MESSAG2I,L'MESSAG2I\n         APUT  MESSAG2J,L'MESSAG2J\n         APUT  MESSAG2K,L'MESSAG2K\n         APUT  MESSAG2L,L'MESSAG2L\n         APUT  MESSAG2M,L'MESSAG2M\n         APUT  MESSAG2N,L'MESSAG2N\n         APUT  MESSAG2O,L'MESSAG2O\n         APUT  MESSAG2P,L'MESSAG2P\n         APUT  MESSAG2Q,L'MESSAG2Q\n         APUT  MESSAG2R,L'MESSAG2R\n         APUT  MESSAG2S,L'MESSAG2S\n         APUT  MESSAG2T,L'MESSAG2T\n         APUT  MESSAGEM,L'MESSAGEM\n         L     R9,SAVER9K            Restore BAL register.\n         BR    R9\n** ---------------------------------------------------------------- **\n*\nDOBURN   DS    0H                        BURN process. Both flgs on.BUR\n         OI    KILLFLAG,X'02'            Announce BURN as keyword   BUR\nDOKILL   DS    0H                        KILL process. KILL flag on.KIL\n         OI    KILLFLAG,X'01'            Announce KILL as keyword   KIL\nFLGSDONE DS    0H                        Flags have been set.\n         TM    FLAG0,X'40'               Have PSCB ACCT authority?\n         BZ    NOTALLOW                  No. Can't do these commands.\n*                                        Print the action code for\n*                                        everything under FLAG2=X'80'\n         OI    FLAG2,X'80'               Mark as a KILL or BURN     BUR\n         MVC   OUTPUT,OUTPUT-1           Print message accordingly  BUR\n         MVC   OUTPUT(15),=C'Action code   :'                       BUR\n         MVC   OUTPUT+17(4),KILLC                                   BUR\n         TM    KILLFLAG,X'02'            Is it really a BURN?       KIL\n         BZ    KEEPKILL                  No. Don't overlay message  KIL\n         MVC   OUTPUT+17(4),BURNC        Yes. Mark as a BURN.       KIL\nKEEPKILL DS    0H                                                   KIL\n         APUT  OUTPUT,25                                            BUR\n* -- >  Test if this command is being run APF Authorized - below    BUR\n         STM   R15,R1,SAVE14T1   Now save registers and test if APF BUR\n         XR    R15,R15                authorized.                   BUR\n         TESTAUTH FCTN=1           Are we authorized?               BUR\n         LTR   R15,R15             Test the return code.            BUR\n         BNZ   NOTAUTH           Not zero, tell not authorized.     BUR\n         LM    R15,R1,SAVE14T1   Restore registers used by TESTAUTH BUR\n* -- >  Test if this command is being run APF Authorized - above    BUR\n         BAL   R9,FINDCSCB               Get the Address Space.     BUR\n         MODESET KEY=ZERO,MODE=SUP                                  BUR\n         ST    R7,SAVER7B                Store work register        BUR\n         LH    R7,CSCBASID               Set ASID                   BUR\n*----->               KILL routine - below                          KIL\n         TM    KILLFLAG,X'01'            Is the KILL flag on?       KIL\n         BZ    EXITKILL                  No. Exit this routine.     KIL\n         CLC   CSCBASID,=X'0000'         Did FINDCSCB find a CSCB?  KIL\n         BE    EXITKILL                  No. Exit this routine.     KIL\n         MVC   FOUNASID,CSCBASID         Stage ASID to get the ASCB KIL\n         BAL   R9,GETASCB                Get the ASCB.              KIL\n         LTR   R15,R15                   Is there one?              KIL\n         BZ    EXITKILL                  No. Exit this routine.     KIL\n         ST    R15,SAVEASCB              Save address of ASCB.      KIL\n         L     R15,0(,R15)               Load it to address fields. KIL\n         USING ASCB,R15                                             KIL\n         TM    KILLFLAG,X'02'            BURN only?                 BUR\n         BO    EXITKILL                  Non-forcible still on.     BUR\n         NI    ASCBFLG2,255-ASCBNOMT     Turn off NON-FORCIBLE bit  KIL\n         NI    ASCBFLG2,255-ASCBNOMD     Turn off Dat error bit     KIL\nEXITKILL DS    0H                        Now do CALLRTM MEMTERM.    KIL\n         DROP  R15                       Drop ASCB addressability   KIL\n*----->               KILL routine - above                          KIL\n         ST    R13,SAVER13A              Save R13                   BUR\n         LA    R13,RTMSAVE               RTM save area              BUR\n         CALLRTM TYPE=MEMTERM,ASID=(R7),COMPCOD=100                 BUR\n         STC   R15,RTMCOD                Save MEMTERM Return Code\n         L     R13,SAVER13A              Restore R13                BUR\n         L     R7,SAVER7B                Restore work register      BUR\n         MODESET KEY=NZERO,MODE=PROB                                BUR\n         CLI   RTMCOD,X'2C'              Non-memtermable addr space?\n         BE    NOTMEMTM                  Yes. Issue message to say so.\n         TM    KILLFLAG,X'02'            BURN msg instead of KILL?  KIL\n         BO    BURNMSG                   Yes. Run BURN message.     KIL\n         MVC   MESSAGKI+4(8),FOUNJOBI    Jobname into message       BUR\n         HEX   MESSAGKI+22,2,FOUNASID    ASID into message          BUR\n         APUT  MESSAGKI,L'MESSAGKI       Say job was killed.        BUR\n         B     BURNEND                   Skip BURN message          KIL\nBURNMSG  MVC   MESSAGBU+4(8),FOUNJOBI    Jobname into message       KIL\n         HEX   MESSAGBU+22,2,FOUNASID    ASID into message          KIL\n         APUT  MESSAGBU,L'MESSAGBU       Say job was burned.        KIL\nBURNEND  B     GETIDEND            After enough looks, end.         KIL\nRTMSAVE  DS    CL72                Work area for RTM                BUR\nSAVER13A DS    F                   Place to save R13                BUR\nSAVEASCB DS    F                   Save ASCB address                KIL\n** ---------------------------------------------------------------- **\nKEY0SWNS DS    0H                    Key 0 for SWAP or NSWP\n         ST    R9,SAVER9L            Save BAL register.\n         ST    R6,SAVER6A\nKEY0TSTA DS    0H\n* -- >  Test if this command is being run APF Authorized - below\n         STM   R15,R1,SAVE14T1     Now save registers and test if APF\n         XR    R15,R15                  authorized.\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.\n* -- >  Test if this command is being run APF Authorized - above\n         TM    FLAG2,X'04'         Make ASID swappable?\n         BO    KEY0SWAP            Yes. Do it.\n         TM    FLAG2,X'08'         Make ASID non-swappable?\n         BO    KEY0NSWP            Yes. Do it.\n         B     KEY0EXIT            Not SWAP or NSWP, don't belong here.\n*\nKEY0NSWP DS    0H                    Make address space non-swappable.\n*\n         CLC   OWNASID,FOUNASID      Target asid different from ours?\n         BE    KEY0DNSW              No. Just do SYSEVENT.\n         MVC   FUNC,=CL8'DONTSWAP'   Set nswapping function         JOE\n         BAL   R9,BUILDSRB           Build SRB block                JOE\n*                                                                   JOE\n* ISSUE SUCCESSFUL MESSAGE                                          JOE\n*                                                                   JOE\n         MVC   MESSAGNS+4(8),FOUNJOBI                               JOE\n         HEX   MESSAGNS+22,2,FOUNASID                               JOE\n         APUT  MESSAGNS,L'MESSAGNS                                  JOE\n         L     R6,SAVER6A            Restore Register               JOE\n         L     R9,SAVER9L            Restore BAL register.          JOE\n         BR    R9                    go back                        JOE\nTEMPSAVE DS    4F                    save area                      JOE\n* ---------------------------------------------------------------- *\nKEY0DNSW DS    0H\n         MODESET MODE=SUP,KEY=ZERO\nKEY0SYSD DS    0H\n         LH    R6,FOUNASID\n         SYSEVENT DONTSWAP,ASID=(R6),ENTRY=SVC\nKEY0NNRM DS    0H\n         MODESET MODE=PROB,KEY=NZERO\n         MVC   MESSAGNS+4(8),FOUNJOBI\n         HEX   MESSAGNS+22,2,FOUNASID                               JOE\n         APUT  MESSAGNS,L'MESSAGNS\n         B     KEY0EXIT\nKEY0SWAP DS    0H                    Make address space swappable.\n         CLC   OWNASID,FOUNASID      Target asid different from ours?\n         BE    KEY0DSWP              No. Just do SYSEVENT.\n         MVC   FUNC,=CL8'OKSWAP'     Set function                   JOE\n         BAL   R9,BUILDSRB           Build SRB CSA CONTROL BLOCKS   JOE\n*                                                                   JOE\n*  issue successful message                                         JOE\n*                                                                   JOE\n         MVC   MESSAGSW+4(8),FOUNJOBI                               JOE\n         HEX   MESSAGSW+22,2,FOUNASID                               JOE\n         APUT  MESSAGSW,L'MESSAGSW                                  JOE\n         L     R6,SAVER6A            Restore Registers              JOE\n         L     R9,SAVER9L            Restore BAL register.          JOE\n         BR    R9                                                   JOE\nKEY0DSWP DS    0H\n         LH    R6,FOUNASID\n         SYSEVENT OKSWAP,ASID=(R6),ENTRY=SVC\nKEY0SNRM DS    0H\n         MODESET MODE=PROB,KEY=NZERO\n         MVC   MESSAGSW+4(8),FOUNJOBI\n         HEX   MESSAGSW+22,2,FOUNASID                               JOE\n         APUT  MESSAGSW,L'MESSAGSW\n         B     KEY0EXIT\nKEY0NODO DS    0H\n         MODESET MODE=PROB,KEY=NZERO\n         HEX   MESSAGNG+43,1,SYSEVCOD+3\n         APUT  MESSAGNG,L'MESSAGNG\nKEY0EXIT DS    0H\n         L     R6,SAVER6A\n         L     R9,SAVER9L            Restore BAL register.\n         BR    R9\n*--------------------------------------------------------------*    JOE\n*                                                              *    JOE\n*        BUILD SRB CONTROL BLOCK AND ACCOMPANYING CODE         *    JOE\n*                                                              *    JOE\n*--------------------------------------------------------------*    JOE\nBUILDSRB DS    0H                                                   JOE\n         STM   R6,R9,TEMPSAVE        Save Registers                 JOE\n         BAL   R9,GETASCB            Find ASCB for this asid        JOE\n         LR    R9,R15                Hold ASCB                      JOE\n         L     R9,0(,R9)             Point to ASCB                  JOE\n         MODESET MODE=SUP,KEY=ZERO   Get into supervisor state      JOE\n*                                                                   JOE\nCSA_LEN  EQU  SRBSIZE+84             CSA SRBLOCK AND PARAMTERS      JOE\n*                                                                   JOE\n*---------------------------------------------------------------*   JOE\n*       Get CSA for SRB CONTROL BLOCK SUBPOOL 241               *   JOE\n*---------------------------------------------------------------*   JOE\n         STORAGE OBTAIN,SP=241,LENGTH=CSA_LEN Get Some CSA          JOE\n         LR    R6,R1                 Point R6 to SRB control block  JOE\n         USING SRB,R6                Address SRB                    JOE\n         XC    SRB(SRBSIZE),SRB      Clear out SRB                  JOE\n         ST    R9,SRBASCB            Save ASCB                      JOE\n         LA    R8,SRBSIZE(,R6)       R8 -> paramlist                JOE\n*       Get CSA paramter list                                   *   JOE\n         ST    R8,SRBPARM            Store paramter list address    JOE\n         LA    R7,72(,R8)            Point to ECB                   JOE\n         XC    0(4,R7),0(R7)         Clear ECB Address              JOE\n         LA    R7,4(,R7)             Point to ASCB                  JOE\n         MVC   0(4,R7),X'224'        Move \"HOME\" PSAAOLD address sp JOE\n         LA    R7,4(,R7)             Bump to next param             JOE\n         CLC   FUNC,=C'DONTSWAP'     Q. non swappable function      JOE\n         BE    NONSWAP               Yes; branch if so              JOE\n         MVC   0(4,R7),=C'OKSW'      Otherwise swappable            JOE\n         B     SETEPA                Set SRB program entry point    JOE\nNONSWAP  DS    0H                                                   JOE\n         MVC   0(4,R7),=C'DONT'      Set FUNCTION IN R7             JOE\n*---------------------------------------------------------------*   JOE\n*       Get CSA for SRB CONTROL BLOCK SUBPOOL 227               *   JOE\n*---------------------------------------------------------------*   JOE\nSETEPA   DS    0H                                                   JOE\n         STORAGE OBTAIN,SP=227,LENGTH=SWAPLEN  Get Fixed CSA        JOE\n         ST    R1,SRBEPA             Set entry point                JOE\n         LR    R14,R1                Hold that thought              JOE\n         LA    R15,SWAPLEN           Get Length                     JOE\n         LR    R1,R15                                               JOE\n         LA    R0,SWAPXMEM           Point to SRB routine           JOE\n         MVCL  R14,R0                Move routine                   JOE\n*                                                                   JOE\n         SCHEDULE SRB=(R6),SCOPE=GLOBAL,MODE=NONXM                  JOE\n*                                                                   JOE\n         LA    R7,72(,R8)            Point to ECB                   JOE\n*                                                                   JOE\n         WAIT  ECB=(R7)                                             JOE\n*                                                                   JOE\n         L     R9,SRBEPA             Get Entry Point Address        JOE\n*                                                                   JOE\n         STORAGE RELEASE,ADDR=(R6),LENGTH=CSA_LEN,SP=241            JOE\n*                                                                   JOE\n         STORAGE RELEASE,ADDR=(R9),LENGTH=SWAPLEN,SP=227            JOE\n*                                                                   JOE\n         MODESET KEY=NZERO,MODE=PROB                                JOE\n*                                                                   JOE\n         LM    R6,R9,TEMPSAVE        Save Registers                 JOE\n         BR    R9                    Return                         JOE\nSYSEVCOD DC    F'0'                  SYSEVENT Return Code\nOLDAX    DS    F\nWAREA    DS    D                     Work area\nWAREB    DS    D                     Work area\n** ---------------------------------------------------------------- **\n** --         C  O  N  S  T  A  N  T  S                          -- **\n** ---------------------------------------------------------------- **\nMESSAGNA DC    C'Command was not invoked APF authorized.'\nMESSAGEN DC    C'End of CSCB chain was reached.'\nMESSAGEY DC    C'No valid keyword was coded.'\nFLAG0    DC    X'00'               Copy of PSCBATR1 - Authority levels\nFLAG1    DC    X'00'               Needed to parse parameters\n*              X'01'               ASID ONLY - NO JOBNAME\n*              X'02'               JOBNAME IS PRESENT.\n*              X'04'               ASID( WAS PRESENT IN PARMS.\n*              X'08'               CSCB CHAIN DISPLAY ONLY.\nFLAG2    DC    X'00'\n*              X'01'               CNCL WAS CODED\n*              X'02'               NCNC WAS CODED\n*              X'04'               SWAP WAS CODED\n*              X'08'               NSWP WAS CODED\n*              X'10'               FORC WAS CODED\n*              X'20'               CSCB WAS CODED\n*              X'80'               BURN OR KILL WAS CODED           KIL\n*              X'40'               CSCB chain run only.\nRTMCOD   DC    X'00'               Saved return code from MEMTERM\nONSWIT   DC    X'00'\n*              X'01'               TURN BIT ON\n*              X'02'               TURN BIT OFF\nHEXSAVE  DS    3F                  SAVE FOR HEX MACRO\nSAVE     DS    9D                  Program Save Area\nSAVE14T1 DS    2D                  Save \"system-used\" registers.\n         DC    C' '                Blank before OUTPUT line.\nOUTPUT   DC    CL80'  '            Variable output line.\nFUNC     DS    CL8                 Swapppinmg function\n         LTORG\n*-----------------------------------------------------------------* JOE\n*                         SRB CODE                                * JOE\n*-----------------------------------------------------------------* JOE\nSWAPXMEM DS    0D                                                   JOE\n         DROP  R12,R11,R10                                          JOE\n         BASR  R5,0                                                 JOE\n         USING *,R5                Entry Point                      JOE\n         LR    R10,R14             Save return address              JOE\n         LR    R13,R1                                               JOE\n*                                                                   JOE\n         LA    R9,72(,R13)         Point to ECB Address             JOE\n         LA    R8,76(,R13)         Point to ASCB Address            JOE\n         L     R8,0(,R8)                                            JOE\n         L     R7,80(,R13)         Get code                         JOE\n*                                                                   JOE\n         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=STDSAVE         JOE\n*                                                                   JOE\n         C      R7,=C'OKSW'        OKSWAP                           JOE\n         BE     SETSWAP                                             JOE\n*                                                                   JOE\n         XR    R1,R1               Undocumented instead of WAIT     JOE\n         SYSEVENT DONTSWAP,ENTRY=BRANCH                             JOE\n*                                                                   JOE\n         B     UNLOCK                                               JOE\n*                                                                   JOE\nSETSWAP  DS    0H                                                   JOE\n         XR    R1,R1               Undocumented instead of WAIT     JOE\n         SYSEVENT OKSWAP,ENTRY=BRANCH                               JOE\n*                                                                   JOE\nUNLOCK   DS    0H                                                   JOE\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE                    JOE\n*                                                                   JOE\n*                                                                   JOE\n         POST  (R9),ASCB=(R8),ERRET=GOBACK,LINKAGE=BRANCH           JOE\n*                                                                   JOE\nGOBACK   LR    R14,R10               Return Address                 JOE\n         BR    R14                   Return                         JOE\n         LTORG                                                      JOE\nSWAPRTM  DS    0D                                                   JOE\nSWAPLEN  EQU   *-SWAPXMEM                                           JOE\n** ---------------------------------------------------------------- **\n         SPACE\n         TITLE '- MAPPING MACROS.'\n         CVT   DSECT=YES           Map the CVT.\n         IEECHAIN                  Map the CSCB control block.\n         IHASRB                                                     JOE\n         IHAASVT                                                    JOE\n         IHAASCB                                                    JOE\n         IHAASXB                                                    JOE\n         IRAOUCB                                                    JOE\n         IHAPSA   DSECT=YES,LIST=YES                           HD APR88\n         IHAFRRS\n         EJECT                                                 HD APR88\n         IKJEFLWA                                                   JOE\n         END   CNCLPG\n** ---------------------------------------------------------------- **\n*  -----------------------------------------------------------------  *\n*  --           Create PUTLINE environment.                       --  *\n*  -----------------------------------------------------------------  *\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUEMNTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   128                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         IHAPSA   DSECT=YES,LIST=YES                           HD APR88\n         EJECT\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   14,12,12(13)       SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES            RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    1,8(13)            OUR SAVE AREA POINTER\n         ST    13,4(1)            POINTER TO CALLERS SAVE AREA\n         LR    13,1               @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(R13)         POINT TO CALLERS RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 ASSUME BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 ASSUME BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(RML)               MESSAGE LENGTH\n         STH   R15,PUTLEN                 PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    2,R13                    @OUR SAVE AREA\n         LR    3,R15                    SAVE RETURN CODE\n         L     R13,4(R13)               @CALLERS SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,3                    RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CNCLPG28": {"ttr": 4618, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1c\\x00F\\x01\\x11)\\x8f\\x01\\x17\\x14?\"\\x04\\x07\\xd2\\x062\\x00\\x00\\xe5\\xf1\\xd9\\xf2\\xd4\\xf8@@@@'", "ispf": {"version": "01.28", "flags": 0, "createdate": "2011-10-25T00:00:00", "modifydate": "2017-05-23T22:04:46", "lines": 2002, "newlines": 1586, "modlines": 0, "user": "V1R2M8"}, "text": "CNCLPG   TITLE 'Make address space cancelable, non-swappable, etc. '\n*  -----------------------------------------------------------------  *\n*                                                                     *\n*    Function:   To make an address space Cancelable or               *\n*                Non-Cancelable, Forcible or Non-Forcible,            *\n*                Swappable or Non-Swappable.  Or BURN the             *\n*                address space (version 1.2.5).  KILL the             *\n*                address space is same as BURN, but first             *\n*                the non-MEMTERM bits in the ASCB are                 *\n*                turned off (version 1.2.6).                          *\n*                                                                     *\n*                If the address space is non-MEMTERM-able,            *\n*                and you try to BURN it, an error message             *\n*                is issued, and nothing occurs.  But if you           *\n*                try and KILL it, the non-MEMTERM bits are            *\n*                turned off, and the address space is whacked.        *\n*                The message will tell you so.                        *\n*                                                                     *\n*    Authority:  You need PSCB OPER authority to run this             *\n*                command.  To do BURN, KILL, NMEM, and MEMT           *\n*                functions, you ALSO need PSCB ACCOUNT authority.     *\n*                Any function controlled by the KILLFLAG, needs       *\n*                PSCB ACCOUNT authority.                              *\n*                                                                     *\n*  -----------------------------------------------------------------  *\n*                                                                     *\n*    Notes:                                                           *\n*                                                                     *\n*           CANCELABLE, NON-CANCELABLE, FORCIBLE, NON-FORCIBLE:       *\n*                                                                     *\n*    CSCB        Cancelable, Non-cancelable, Forcible, Non-forcible   *\n*    chain       are determined by bit settings in the address        *\n*                space's CSCB, which is part of the CSCB chain.       *\n*                                                                     *\n*    Jobname     Each active address space has a CSCB in the chain.   *\n*    and/or      You get to a particular address space by running     *\n*    ASID        the entire CSCB chain (mapped by the IEECHAIN        *\n*    match       macro) looking for a match on jobname and/or ASID,   *\n*                and preferably on both.                              *\n*                                                                     *\n*    DISPlay     There may be more than one address space for a       *\n*    or          given job name, and more than one CSCB entry         *\n*    \"CSCB\"      for a given ASID.  The CSCB or DISPlay option        *\n*    option      of CNCLPG will run the entire CSCB chain and         *\n*                it will show ALL the matches for the parameters      *\n*                given.  To display the ENTIRE CSCB chain from start  *\n*                to finish, use a dash ( - ) instead of the jobname.  *\n*                                                                     *\n*    Multiple    If only the jobname or the ASID number alone         *\n*    jobs        are used to do an ACTION, then CNCLPG will stop      *\n*    with the    at the FIRST CSCB which matches, when an ACTION is   *\n*    same name   called for (but NOT for a DISPLAY).  That is why     *\n*                it is better to run the DISPlay (or CSCB) function   *\n*                of CNCLPG first, to display all the possible CSCB    *\n*                entries that might match, before changing any        *\n*                particular address space.  There might be more       *\n*                than one address space with the same jobname or      *\n*                ASID, and you want to change only the correct        *\n*                one, NOT the wrong one.  So it is good practice      *\n*                to display first, and then do a change to the        *\n*                exact address space you want to affect, using        *\n*                both the jobname and ASID(hhhh) parameters.          *\n*                                                                     *\n*           SWAPPABLE AND NON-SWAPPABLE:                              *\n*                                                                     *\n*    SWAP and    Setting an address space to be swappable or          *\n*    NSWP need   non-swappable, is accomplished by executing          *\n*    to run a    a SYSEVENT macro.  This has to execute in the        *\n*    SYSEVENT    target address space, and it was done here by        *\n*    macro in    scheduling an SRB to run in the target address       *\n*    the         space, when it is different from the address         *\n*    target      space running the program.  That piece of code       *\n*    address     was written by Joe Reichman.  Thanks, Joe.           *\n*    space       You did the hard part!                               *\n*                                                                     *\n*       NON-MEMTERMABLE AND MEMTERMABLE: (THE REAL \"NON-FORCIBLE\")    *\n*                                                                     *\n*    NMEM makes  In the ASCB of an address space there are two        *\n*    a job both  bits, ASCBNOMT and less importantly, ASCBNOMD.       *\n*    NON-FORCI-  ASCBNOMT controls the attribute, when it is on,      *\n*    BLE and     that the address space is NON-MEMTERMABLE or         *\n*    NON-CANCEL- NON-FORCIBLE.  If NON-CANCELABLE is also true,       *\n*    ABLE.       as well as the non-memtermable bit ASCBNOMT,         *\n*                then if you try and cancel the job, it will say,     *\n*    MEMT makes  NON-CANCELABLE, and if you try and FORCE the         *\n*    the job     job, it will say NON-FORCIBLE.  The two bits         *\n*    FORCIBLE,   ASCBNOMT in the ASCB which has to be on, and         *\n*    but leaves  the cancelable bit in the job's CSCB entry,          *\n*    it to be    CNCL in flag CHACT, which has to be off,             *\n*    NON-CANCEL- control this situation.                              *\n*    ABLE.                                                            *\n*                A job should not be left NON-FORCIBLE and            *\n*                CANCELABLE.  That defeats the purpose of             *\n*                NON-FORCIBLE, in that the job can easily             *\n*                then be cancelled, because CANCEL will work.         *\n*                                                                     *\n*                The action NMEM (non-memtermable) sets both          *\n*                then non-forcible bit in the ASCB on, and the        *\n*                cancelable bit in the job's CSCB entry, off.         *\n*                The action MEMT (make memtermable) turns only        *\n*                the ASCBNOMT bit (non-memtermable) off, but          *\n*                leaves the non-cancelable situation in place.        *\n*                If you want to turn off non-cancelable later,        *\n*                then the CNCL action will do this.                   *\n*                                                                     *\n*    -------------------------------------------------------------    *\n*    BURN        BURN -  Kill the designated address space with a     *\n*    (v 1.2.5)   CALLRTM TYPE=MEMTERM (like a FORCE).  Be careful !   *\n*    -------------------------------------------------------------    *\n*    KILL        KILL -  Kill the designated address space with a     *\n*    (v 1.2.6)   CALLRTM TYPE=MEMTERM (like a FORCE).  Be careful !   *\n*                KILL is a \"super BURN\".  Be VERY careful.....!       *\n*                Before doing the MEMTERM, KILL turns off bits        *\n*                in the ASCB (ASCBNOMT and ASCBNOMD), the             *\n*                \"non-FORCIBLE\" bits.  Can whack any address space.   *\n*    (v 1.2.7)   You need PSCB ACCOUNT authority to run BURN or KILL, *\n*                along with OPER authority to run the rest of the     *\n*                program.                                             *\n*    -------------------------------------------------------------    *\n*    NMEM and    NMEM will make the address space NON-FORCIBLE        *\n*    MEMT        and NON-CANCELABLE.  MEMT will make the address      *\n*    (v 1.2.8)   space FORCIBLE, but it will leave the cancelable     *\n*                bit in place, however it was before.                 *\n*                (Since the FORCE operator command actually equates   *\n*                to a CALLRTM TYPE=MEMTERM macro call, making an      *\n*                address space NON-FORCIBLE is also called making     *\n*                it NON-MEMTERMABLE.                                  *\n*    -------------------------------------------------------------    *\n*                                                                     *\n*    Syntax:     TSO Command:  APF-authorized.                        *\n*                                                                     *\n*        CNCLPG |jobid \u00ddASID(hhhh)\u00a8 |CNCL|NCNC|FORC|NFRC|NSWP|SWAP    *\n*               |ASID(hhhh)         |CNCL|NCNC|FORC|NFRC|NSWP|SWAP    *\n*               |                   |CSCB or DISP                     *\n*               |                   |BURN                             *\n*               |                   |KILL                             *\n*               |                   |NMEM|MEMT                        *\n*               |-  (displays the entire CSCB chain)                  *\n*               |?  (displays help)                                   *\n*                                                                     *\n*    Date:       April 15, 2010                                       *\n*                                                                     *\n*    Latest Modification:   May 21, 2017                              *\n*                                                                     *\n*    Authors:    Sam Golob, Joe Reichman (who did the hard part)      *\n*                                                                     *\n*    Technical Detail:  PUTLINE interface for TSO Output.             *\n*                       Uses the APUT macro, and EPUTL module.        *\n*                                                                     *\n*    Changes:  1.  SWAP, NSWP support dropped from this program       *\n*                   initially.  Version is 1.0.0.                     *\n*                                                                     *\n*              2.  Messages and DISP improved, to just show matching  *\n*                   CSCB chain entries, instead of all of them.       *\n*                   Coding a dash instead of a jobname or asid(hhhh)  *\n*                   - will display the entire CSCB chain.             *\n*                                                                     *\n*              3.  SWAP, NSWP support put back in this program.       *\n*                   Version is 1.1.0   (June 16, 2010)                *\n*                   It now does your own address space.  The cross    *\n*                   memory stuff was not put in yet, to make other    *\n*                   address spaces swappable, or non-swappable.       *\n*                                                                     *\n*              4.  Complete SWAP, NSWP support for cross address      *\n*                   space communication, was put in by Joe            *\n*                   Reichman.  (Oct 2011)  Version is 1.2.0.          *\n*                                                                     *\n*              5.  Burn an address space, if that is desired.         *\n*                   (Oct 2012)  Version is 1.2.5.                     *\n*                                                                     *\n*              6.  Kill an address space.  Before you do the          *\n*                  CALLRTM MEMTERM, the non-forcible flags in the     *\n*                  ASCB are turned off.                               *\n*                   (May 2017)  Version is 1.2.6.                     *\n*                                                                     *\n*              7.  Authority checking. So far, you need PSCB OPER     *\n*                   to do anything. ACCT to do BURN or KILL.          *\n*                   Version is 1.2.7.                                 *\n*                                                                     *\n*              8.  Make address space Non-Memtermable (can't be       *\n*                   FORCEd), or Memtermable (can be FORCEd).          *\n*                   Non-Memtermable implies Non-Cancelable, because   *\n*                   it isn't effective if the address space is        *\n*                   Cancelable but non-Memtermable).  You can easily  *\n*                   get rid of it, and it defeats the purpose of      *\n*                   non-Memtermable.  If you later make it            *\n*                   Memtermable, you can make it Cancelable next.     *\n*                                                                     *\n*   Change   Pgmr                   Description                       *\n*   -------  -----   ----------------------------------------------   *\n*                                                                     *\n*            JOER     Add SRB code to allow swapping in xmem.         *\n*                     (See lines commented with JOE.)                 *\n*                                                                     *\n*  -----------------------------------------------------------------  *\n*\n*  This macro lets you display hex values in a report.\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    STM   R15,R1,HEXSAVE           Save work registers.\n         LA    R1,&FROM                 Load from address.\n         LA    R0,&LEN                  Load length of hex number.\n         LA    R15,&TO                  Load to address.\n         BAL   R9,HEX                   BAL to routine.\n         LM    R15,R1,HEXSAVE           Restore work registers.\n         MEND\n*  -----------------------------------------------------------------  *\n*  --           Create PUTLINE environment.                       --  *\n*  -----------------------------------------------------------------  *\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP THE PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\n* --       End of Internal Macros......                            -- *\n* ------------------------------------------------------------------- *\n         SPACE 3\n* ------------------------------------------------------------------- *\n*   The CSCB chain of control blocks is above the line, so you need   *\n*    to have AMODE 31.                                                *\n* ------------------------------------------------------------------- *\nCNCLPG   CSECT\nCNCLPG   AMODE 31\nCNCLPG   RMODE ANY\n         YREGS\n         USING CNCLPG,R15          (Establish temporary base).\n         B     BEGIN               Skip over eyecatcher.\nEYEC0    DC    AL1(EYECL)          Exclusive length of header.\nEYEC     DC    C' CNCLPG - &SYSDATE - &SYSTIME -'\n         DC    C'     --------------------------------    '\n         DC    C' VER 1.2.8   '\n         DC    C'                   '\nEYECL    EQU   *-EYEC\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)     Save caller's registers\n         LR    R6,R1               Preserve CPPL pointer.\n         LR    R12,R15             Copy base.\n         USING CNCLPG,R12,R11,R10  (Tell assembler).\n         LA    R11,4095(,R12)      Load bases.\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)\n         LA    R10,1(,R10)\n         LR    R14,R13             Copy caller's save area pointer.\n         LA    R13,SAVE            Point to my save area.\n         ST    R13,8(,R14)         Chain ...\n         ST    R14,SAVE+4          ... Save areas.\n*                                  Get PSCBATR1 byte and copy it\n         ST    R1,SAVER1A          Save work register\n         L     R1,16               CVTPTR\n         L     R1,0(,R1)           TCB words\n         L     R1,4(,R1)           Current TCB\n         L     R1,180(,R1)         TCBJSCB\n         L     R1,264(,R1)         JSCBPSCB\n         LA    R1,0(,R1)           Clear hi order byte\n         LTR   R1,R1               Is there a PSCB ?\n         BZ    NOTFOUND            No, Issue COMMAND-NOT-FOUND msg\n         MVI   FLAG0,X'00'         Zero FLAG0 for safety\n         MVC   FLAG0(1),X'10'(R1)  Overlay it with PSCBATR1\n         L     R1,SAVER1A          Restore work register\nAUTHTEST DS    0H\n         TM    FLAG0,X'80'         PSCB OPER AUTHORITY?\n         BZ    NOTFOUND            No, Issue COMMAND-NOT-FOUND msg\nINITCON  DS    0H                  Initialize some constants.\n         MVI   FLAG1,X'00'\n         MVI   FLAG2,X'00'\n         MVI   ONSWIT,X'00'\n         MVI   RTMCOD,X'00'\n         MVI   ERRASID,X'00'\n         MVI   CANCINDC,X'00'\n         MVI   KILLFLAG,X'00'\n         MVI   OUTPUT-1,X'40'\n         MVC   OUTPUT,OUTPUT-1\n         MVI   NEWCHACT,X'00'\nMYASID   DS    0H                  Get my ASID\n         L     R2,X'224'           Point to PSAAOLD (my ASCB)\n         LA    R2,X'24'(,R2)       Point to my own ASID (ASCBASID)\n         MVC   OWNASID(2),0(R2)    Save it for comparison later\n         B     PRTITLE             Branch past constant\nOWNASID  DS    H\nPRTITLE  DS    0H                  Print program title.\n         APUT  MESSAGET,L'MESSAGET\n         APUT  MESSAGEU,L'MESSAGEU\nCONT0    DS    0H                  Look at command's parameters.\n         LTR   R6,R6               Any CPPL?\n         BZ    EOJ8                No.  Get out.\n         L     R1,0(,R6)           Pt to cmd buffer. (R6 reused later)\n         LTR   R1,R1               Any CMD buffer?\n         BZ    EOJ8                Get out if none.\n         LH    R3,0(,R1)           Load length.\n         CH    R3,=H'4'            Anything?\n         BNH   EOJ4                No. Get out.\n         LR    R5,R3               Length of command + 4\n         ICM   R5,14,FULLZERO      Clear hi order 3 bytes.\n         LH    R3,2(,R1)           Load offset.\n         SR    R5,R3               Subtract offset from full length+4\n         SH    R5,=H'4'            Correct for length of cmdbufr header\n         BC    8,WMESS2            Zero, message to enter userid.\n         BC    5,EOJ8              Less, or overflow, out.\nPARM     DS    0H\n         BAL   R9,GETIDS           Get parameters for the command.\n*                                  All the processing hooks off here.\n         B     EOJ0\n** ---------------------------------------------------------------- **\nWMESS2   DS    0H                  Print help messages.\n         BAL   R9,PRINTERR\n         B     EOJ4\n** ---------------------------------------------------------------- **\nEOJ0     DS    0H                  End of job.\n         APUT  RETURN0,L'RETURN0\n         LA    R15,0               Set CC = 0.\n         B     RETURN\nEOJ4     DS    0H\n         APUT  RETURN4,L'RETURN4\n         LA    R15,4               Set CC = 4.\n         B     RETURN\nEOJ8     DS    0H\n         APUT  RETURN8,L'RETURN8\n         LA    R15,8               Set CC = 8.\n         B     RETURN\nRETURN   L     R13,SAVE+4\n         L     R14,12(,R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n** ---------------------------------------------------------------- **\nNOTAUTH  DS    0H                  Command not APF authorized message.\n         APUT  MESSAGNA,L'MESSAGNA\n         B     EOJ4\n** ---------------------------------------------------------------- **\nNOTFOUND DS    0H                  Fake command not found message.\n         APUT  MESSAGAU,L'MESSAGAU\n         B     RETURN\n** ---------------------------------------------------------------- **\nNOTALLOW DS    0H                  Command NOT ALLOWED message.\n         APUT  MESSAGAT,L'MESSAGAT\n         B     RETURN\n** ---------------------------------------------------------------- **\nNOTMEMTM DS    0H                  Address space not MEMTERM-able.\n         MVC   MESSAGNM+4(8),FOUNJOBI    Jobname into message\n         HEX   MESSAGNM+22,2,FOUNASID    ASID into message\n         APUT  MESSAGNM,L'MESSAGNM       Say job Not-Memterm-able\n         APUT  MESSAGEL,L'MESSAGEL         and not burned,\n         APUT  MESSAGFL,L'MESSAGFL\n         BAL   R9,FORCHACT                 But show final status.\n         B     RETURN\n** ---------------------------------------------------------------- **\n* ---           Everything after here is subroutines.            --- *\n** ---------------------------------------------------------------- **\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                Get the parameters for the command.              *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*   Notes:  The ASID(xxx) can be coded first, without a userid.   *\n*           A dash can be coded first, to run the entire CSCB     *\n*            chain and display all the jobnames in it, with       *\n*            their associated ASIDs.  ? coded first gives HELP.   *\n*           If you code the word CSCB or DISP(lay) after either   *\n*            a jobname or an ASID(hhhh) then a display of ALL     *\n*            matching CSCB chain entries will be displayed, and   *\n*            no changes will be made.                             *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETIDS   DS    0H                  Get all parameters for the program.\n         ST    R9,SAVER9A\n         ST    R4,SAVER4C\n         AR    R1,R3               Point ...\n         LA    R1,4(,R1)           ... to char.\n         LA    R6,8                Load reg for BCT loop.\n         LR    R7,R1               Initialize pointer to first\n         LA    R7,0(,R7)                character of the ID field.\n         LA    R8,0                Initialize character count.\n         MVC   JOBID(8),BLANKS     Clear (first param - JOBNAME) field.\n         LA    R4,JOBID            Point reg to beginng of JOBID field.\n*\nCUTIDLEN DS    0H                  Look at the JOBID field first.\n*                                  (May contain ASID( or CSCB.)\n*\n         CLI   0(R7),X'40'         Is this character a blank?\n         BE    NOMORCUT            Yes, we are at the end of the field.\n         MVC   0(1,R4),0(R7)       Move only one character at a time.\n         OC    JOBID(8),BLANKS     And uppercase the partial jobid.\n*\n*   Is this a run of the CSCB chain only?\n* -- >  Test for CSCB  first  ---- below\n         CLI   JOBID,C'-'          Did we code '-' first?\n         BNE   CSCBHELP            No. Try if help asked for.\n         B     CSCBRUN1            Yes. Run entire CSCB chain.\n* - > Help\nCSCBHELP DS    0H\n         CLI   JOBID,C'?'          Help?\n         BNE   NOCSCB              No. Skip this code.\n         BAL   R9,PRINTERR         Yes. Print messages\n         B     EOJ0                  and get out with code 0.\n* - > Help\nCSCBRUN1 DS    0H\n         ST    R8,SAVER8A          Store count for display if needed.\n         OI    FLAG2,X'40'         Mark that this is CSCB only run.\n         BAL   R9,RUNCSCB          Do the run for CSCB chain.\n         B     EOJ0                Out with normal return code.\nNOCSCB   DS    0H\n* -- >  Test for CSCB  first  ---- above\n*\n*   Was the ASCB(hhh) parameter coded without the jobid?\n* -- >  Test for ASID( first  ---- below\n         CLC   JOBID(L'ASIDC),ASIDC  Did we code ASID( in jobid field?\n         BNE   NOASIDF             No. Pass this code.\n         OI    FLAG1,X'01'         Flag that ASID( ) was first.\n         NI    FLAG1,X'FF'-X'02'   Turn off Jobname in jobid field flag\n         MVC   ASIDWKL(L'ASIDC),JOBID  Move the ASID( to proper field.\n         MVC   JOBID,BLANKS        Blank out Job ID if ASID( coded.\n         LA    R7,1(,R7)           Bump another character.\n         LA    R8,1(,R8)           Count another character.\n         LA    R6,1                Set number of branches later.\n*                                  This will limit number of params\n*                                   that are searched for.\n         B     ASIDONLY            Bypass all the real jobname stuff.\n* -- >  Test for ASID( first  ---- above\nNOASIDF  DS    0H                  ASID( is not the first parameter.\n         LA    R4,1(,R4)           Bump another character.\n         LA    R7,1(,R7)           Bump another character.\n         LA    R8,1(,R8)           Count another character.\n         CR    R8,R5               End of command buffer ?\n         BNL   NOMORCUT            Yes. Get out now.\n         BCT   R6,CUTIDLEN         Try for the next blank, up till 8.\nNOMORCUT DS    0H\n         STC   R8,SAVCOUNT         Save length of Jobname\n         L     R4,SAVER4C          Restore work register for use later.\n         OC    JOBID(8),BLANKS     Uppercase the new Job Id.\n         OI    FLAG1,X'02'         Set 'Jobname Coded' flag.\n*  -  Display the found JOBID - below\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Search Jobname:'\n         MVC   OUTPUT+17(8),JOBID\n         APUT  OUTPUT,30\n         APUT  MESSAGEL,L'MESSAGEL\n*  -  Display the found JOBID - above\n         LA    R6,1                Set number of branches later.\n*                                  This will limit number of params\n*                                   that are searched for.\n         B     LOOKKEYW\n*  Constants - below - ***\nJOBID    DC    C'        '         STORE PARM USERID HERE\nBLANKS   DC    C'        '         8 BLANKS\nMESSAGET DC    C'CNCLPG 1.2.8 - Make a Job, STC or TSU Cancelable, etc.X\n                (? for help)'\nMESSAGEU DC   C'------ ----- - ---- - ---- --- -- --- ----------- ----'\nMESSAGEL DC    C'----------------------------'\nMESSAGEM DC    C'-----------------------------------------------'\nMESSAG2A DC    C'Enter JOBNAME and/or ASID(hhhh) after COMMAND name,'\nMESSAG2B DC    C'   then CNCL, NCNC, FORC, NFRC, NSWP, or SWAP. '\nMESSAG2V DC    C'To get rid of the address space, code BURN or KILL.'\nMESSAG2U DC    C'Or code CSCB or DISP to just display CSCB entries.'\nMESSAG2C DC    C'   DISPlay or CSCB will display CSCB chain entries,'\nMESSAG2D DC    C'   without changing them.'\nMESSAG2E DC    C' When affecting a job, we want to be accurate, '\nMESSAG2F DC    C'  therefore you should use the DISPlay option first.'\nMESSAG2G DC   C' To display the whole CSCB, code - (dash) for JOBNAME.'\nMESSAG2H DC    C' To see this help message, code ? for JOBNAME.'\nMESSAG2I DC    C'Notes (important) : '\nMESSAG2J DC   C' CSCB (DISP) display for an ASID shows all occurrences'\nMESSAG2K DC    C'  for that ASID, regardless of JOBNAME.      '\nMESSAG2L DC C' CSCB (DISP) display for a JOBNAME shows all occurrences'\nMESSAG2M DC    C'  for that JOBNAME, regardless of ASID.      '\nMESSAG2N DC    C' CNCL, NCNC, FORC, NFRC, NSWP, SWAP changes the FIRST'\nMESSAG2O DC    C'  entry in the CSCB chain that matches, if multiple '\nMESSAG2P DC    C'  entries exist. But DISP will display ALL applicable'\nMESSAG2Q DC    C'  matching entries in the CSCB chain, so you can see'\nMESSAG2R DC    C'  which one you want to change specifically.'\nMESSAG2S DC    C' When you code BOTH jobname and asid, to CHANGE it,'\nMESSAG2T DC    C'  then ONLY that specific job and asid gets changed.'\nMESSAGE3 DC    C'WE GOT HERE'\nMESSAGE4 DC    C'TEST CHECK THIS'\nMESSAGNG DC    C'Job was not done. SYSEVENT return code was     '\nMESSAGNS DC    C'Job xxxxxxxx for ASID HHHH made non-swappable.'\nMESSAGSW DC    C'Job xxxxxxxx for ASID HHHH was made swappable.'\nMESSAGAN DC    C'Job xxxxxxxx for ASID HHHH already non-swappable.'\nMESSAGAS DC    C'Job xxxxxxxx for ASID HHHH was already swappable.'\nMESSAGFN DC    C'Function xxxx was called for.'\nMESSAGBU DC    C'Job xxxxxxxx for ASID HHHH has been burned.'\nMESSAGKI DC    C'Job xxxxxxxx for ASID HHHH has been killed.'\nMESSAGAU DC    C'IKJ56500I COMMAND CNCLPG NOT FOUND'\nMESSAGAT DC    C'Lacking authority to execute this command.'\nMESSAGNM DC    C'Job xxxxxxxx for ASID HHHH not MEMTERM-able. Not burnex\n               d.'\nMESSAGM1 DC    C'Job xxxxxxxx for ASID HHHH made non-memtermable.'\nMESSAGM2 DC    C'Job xxxxxxxx for ASID HHHH was made memtermable.'\nMESSAGFL DC    C'Final Job Status Report.'\nRETURN0  DC    C'Return code is 0'\nRETURN4  DC    C'Return code is 4'\nRETURN8  DC    C'Return code is 8'\n*                     ***  Places to save registers  ***  below\nSAVER1A  DS    F\nSAVER3A  DS    F\nSAVER3B  DS    F\nSAVER3C  DS    F\nSAVER3D  DS    F\nSAVER3E  DS    F\nSAVER3F  DS    F\nSAVER4A  DS    F\nSAVER4B  DS    F\nSAVER4C  DS    F\nSAVER4D  DS    F\nSAVER5A  DS    F\nSAVER6A  DS    F\nSAVER6B  DS    F\nSAVER7A  DS    F\nSAVER7B  DS    F\nSAVER8A  DS    F\nSAVER9A  DS    F\nSAVER9B  DS    F\nSAVER9C  DS    F\nSAVER9D  DS    F\nSAVER9E  DS    F\nSAVER9F  DS    F\nSAVER9G  DS    F\nSAVER9H  DS    F\nSAVER9I  DS    F\nSAVER9J  DS    F\nSAVER9K  DS    F\nSAVER9L  DS    F\nSAVER9M  DS    F\nSAVER9N  DS    F\n*                     ***  Places to save registers  ***  above\nSAVCOUNT DS    X\nKILLFLAG DS    X\n*              X'01'               KILL indicated\n*              X'02'               BURN indicated  X'01' also on\n*              X'04'               NMEM indicated\n*              X'08'               MEMT indicated\nDUBLZERO DC    D'0'\nFULLZERO DC    F'0'\nCANCINDC DC    X'00'\nCANCKEY0 DC    X'00'\nNEWCHACT DC    X'00'\n*  Constants - above - ***\nLOOKKEYW DS    0H                  Look for additional keywords.\n         LA    R7,1(,R7)           Bump command buffer pointer.\n         LA    R8,1(,R8)           Bump character counter.\n         CR    R8,R5               End of command buffer?\n         BNL   GETIDEND            Yes. Don't look any more.\n         MVC   ASIDWKL(5),BLANKS   Clear parameter work field.\n         MVC   ASIDWKL(5),0(R7)    Next 5 characters to work field.\nASIDONLY DS    0H                  Jump to here if ASID( coded first.\n         OC    ASIDWKL(4),BLANKS   Uppercase work field.\n         CLC   ASIDC,ASIDWKL       Is the ASID( keyword there?\n         BE    DOASID              Yes. Process it.\n         CLC   CNCLC,ASIDWKL       Is the CNCL  keyword there?\n         BE    DOCNCL              Yes. Process it.\n         CLC   NCNCC,ASIDWKL       Is the NCNC  keyword there?\n         BE    DONCNC              Yes. Process it.\n         CLC   SWAPC,ASIDWKL       Is the SWAP  keyword there?\n         BE    DOSWAP              Yes. Process it.\n         CLC   NSWPC,ASIDWKL       Is the NSWP  keyword there?\n         BE    DONSWP              Yes. Process it.\n         CLC   FORCC,ASIDWKL       Is the FORC  keyword there?\n         BE    DOFORC              Yes. Process it.\n         CLC   NFRCC,ASIDWKL       Is the NFRC  keyword there?\n         BE    DONFRC              Yes. Process it.\n         CLC   CSCBC,ASIDWKL       Is the CSCB  keyword there?\n         BE    DOCSCB              Yes. Process it.\n         CLC   DISPC,ASIDWKL       Is the DISP  keyword there?\n         BE    DOCSCB              Yes. Process it.\n         CLC   BURNC,ASIDWKL       Is the BURN  keyword there?      BUR\n         BE    DOBURN              Yes. Process it.                 BUR\n         CLC   KILLC,ASIDWKL       Is the KILL  keyword there?      KIL\n         BE    DOKILL              Yes. Process it.                 KIL\n         CLC   NMEMC,ASIDWKL       Is the NMEM  keyword there?\n         BE    DONMEM              Yes. Process it.\n         CLC   MEMTC,ASIDWKL       Is the MEMT  keyword there?\n         BE    DOMEMT              Yes. Process it.\n         B     LOOKKEYW            Go loop and look at next character.\nASIDWKL  DC    CL5' '              Second parameter work area.\n*\nASIDC    DC    C'ASID('            Literals....\nCNCLC    DC    C'CNCL'\nNCNCC    DC    C'NCNC'\nSWAPC    DC    C'SWAP'\nNSWPC    DC    C'NSWP'\nFORCC    DC    C'FORC'\nNFRCC    DC    C'NFRC'\nCSCBC    DC    C'CSCB'\nDISPC    DC    C'DISP'\nBURNC    DC    C'BURN'\nKILLC    DC    C'KILL'\nNMEMC    DC    C'NMEM'\nMEMTC    DC    C'MEMT'\n*\nDOASID   DS    0H                  Look for hex value of the ASID.\n         OI    FLAG1,X'04'         Show that ASID( was coded.\n         BAL   R9,GETASID          Go get the rest of the parameters.\n         MVC   ASIDWKL(5),BLANKS   Blank out the second wkarea for\n*                                   a further parameter search.\n         B     LOOKKEYW            Re-loop to look further for params.\n*\nDOCNCL   DS    0H                  Handle CNCL (cancelable) keyword.\n         OI    CANCINDC,X'08'      Show which CHACT bit is affected.\n         OI    FLAG2,X'01'         Show that CNCL was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'01'        Set to OR the bits\n         NI    ONSWIT,X'FF'-X'02'   and not to AND the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n* ------------------------------------------------------------------- *\n*                                    Print the action code.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),CNCLC\n         APUT  OUTPUT,25\n*                                    Print the bit in CHACT affected.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDONCNC   DS    0H                  Handle NCNC (non-cancelable) keyword\n         OI    CANCINDC,X'08'      Show which CHACT bit is affected.\n         OI    FLAG2,X'02'         Show that NCNC was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'02'        Set to AND the bits\n         NI    ONSWIT,X'FF'-X'01'   and not to OR the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n*                                    Print the action code.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),NCNCC\n         APUT  OUTPUT,25\n*                                    Print the bit in CHACT affected.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDOSWAP   DS    0H                  Now this routine is operational.\n         OI    FLAG2,X'04'         Show that SWAP was coded.\n         MVC   MESSAGFN+9(4),SWAPC   Write message to say that.\n         APUT  MESSAGFN,L'MESSAGFN\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         BAL   R9,KEY0SWNS         Do SYSEVENT OKSWAP, xmem or not.\n         BCT   R6,LOOKKEYW\n         B     GETIDEND\n* ------------------------------------------------------------------- *\nDONSWP   DS    0H                  Now this routine is operational.\n         OI    FLAG2,X'08'         Show that NSWP was coded.\n         MVC   MESSAGFN+9(4),NSWPC   Write message to say that.\n         APUT  MESSAGFN,L'MESSAGFN\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         BAL   R9,KEY0SWNS         Do SYSEVENT DONTSWAP, xmem or not.\n         BCT   R6,LOOKKEYW\n         B     GETIDEND\n* ------------------------------------------------------------------- *\nDOFORC   DS    0H                  Handle FORC (forcible) keyword\n         OI    FLAG2,X'10'         Show which CHACT bit is affected.\n         OI    CANCINDC,X'01'      Show that FORC was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'01'        Set to OR the bits\n         NI    ONSWIT,X'FF'-X'02'   and not to AND the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n*\n         MVC   OUTPUT,OUTPUT-1       Print the action code.\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),FORCC\n         APUT  OUTPUT,25\n*\n         MVC   OUTPUT,OUTPUT-1       Print the bit in CHACT affected.\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDONFRC   DS    0H                  Handle NFRC (non-forcible) keyword\n         OI    FLAG2,X'20'         Show which CHACT bit is affected.\n         OI    CANCINDC,X'01'      Show that NFRC was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'02'        Set to AND the bits\n         NI    ONSWIT,X'FF'-X'01'   and not to OR the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n*\n         MVC   OUTPUT,OUTPUT-1       Print the action code.\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),NFRCC\n         APUT  OUTPUT,25\n*\n         MVC   OUTPUT,OUTPUT-1       Print the bit in CHACT affected.\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDOCSCB   DS    0H\n         OI    FLAG1,X'08'         Show CSCB keyword was coded.\n         OI    FLAG2,X'40'         Show CSCB keyword was coded.\n         MVC   OUTPUT,OUTPUT-1       Print the action code.\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),CSCBC\n         MVC   OUTPUT+23(9),=C'(DISPlay)'\n         APUT  OUTPUT,35\n         BAL   R9,RUNCSCB          Run the CSCB chain with print.\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nGETIDEND DS    0H                  End of keyword processing.\n         TM    FLAG2,X'FF'         Check if any real actions asked  BUR\n         BNZ   GETKEYNR            Yes, some were.\n         APUT  MESSAGEY,L'MESSAGEY    No. Display help messages.\n         BAL   R9,PRINTERR\n         B     EOJ4                   And end with code = 4.\nGETKEYNR DS    0H                  Real actions WERE asked for.\n         TM    KILLFLAG,X'FF'      Any of the KILLFLAG options on?\n         BZ    SKPKEYNR            No, no extra printout.\n         TM    KILLFLAG,X'03'      If kill, then don't need status.\n         BNZ   SKPKEYNR\nGETKEYNS DS    0H                  Real actions WERE asked for.\n         APUT  MESSAGEL,L'MESSAGEL\n         APUT  MESSAGFL,L'MESSAGFL\n         BAL   R9,FORCHACT         Show summary after actions.\nSKPKEYNR DS    0H                  Real actions WERE asked for.\n         B     EOJ0                So end with normal return code.\n         L     R9,SAVER9A\n         BR    R9\n** ---------------------------------------------------------------- **\nHEX      DS    0H                  Display hex values.\n         ST    R9,SAVER9B\n         MVC   1(1,R15),0(R1)      Move byte.\n         UNPK  0(3,R15),1(2,R15)   Unpack.\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)         Increment output pointer.\n         LA    R1,1(,R1)           Increment input pointer.\n         BCT   R0,HEX              Decrement length, then loop.\n         MVI   0(R15),C' '         Blank the trailing byte.\n         L     R9,SAVER9B\n         BR    R9                  Return to caller.\nHEXTAB   DC    C'0123456789ABCDEF' Translate table.\n** ---------------------------------------------------------------- **\nGETASID  DS    0H                  Get hex ASID for 2 bytes.\n         ST    R9,SAVER9C          Save registers.\n         STM   R1,R6,SAVERGS1\n         LA    R6,4                Load BCT register.\n         LA    R4,ASIDWK           Point to ASID work area.\n         TM    FLAG1,X'02'         Ask if Job name was coded.\n         BZ    GETAFL01            Wasn't. Have to adjust pointers.\n         LA    R7,5(,R7)           Bump command buffer pointer.\n         LA    R8,5(,R8)           Bump character counter.\nGETAFL01 DS    0H\nGETASIDL DS    0H                  Loop to get hex ASID for 4 display\n*                                    bytes to convert to 2 hex bytes.\n         CLI   0(R7),C')'          Have we reached close parenthesis?\n         BE    GETASIDG            Yes, assume we've got it.\n         CLI   0(R7),C' '          Have we hit a blank?\n         BE    GETASIDG            Yes, assume we've got it.\n         MVC   0(1,R4),0(R7)       Otherwise move one character over.\n         LA    R4,1(,R4)           Bump one ASIDWK character (target)\n         LA    R7,1(,R7)           Bump command buffer pointer.\n         LA    R8,1(,R8)           Bump character counter.\n         BCT   R6,GETASIDL         Loop for 4 characters.\n         B     GETASIDG            We don't look for more than 4.\nGETASIDG DS    0H\n*        APUT  ASIDWK,4\n         LA    R4,ASIDWK           Point register at workarea again.\n         LA    R1,4                Maximum of 4 characters.\nGETASIDA DS    0H\n         CLI   3(R4),X'40'         Is last character a blank (<4 total)\n         BNE   GETASIDM            No. We're finished sliding.\n         BCTR  R4,0                Slide the pointer one place back.\n         BCT   R1,GETASIDA         Do it no more than 4 times.\nGETASIDM DS    0H\n         MVC   ASIDMV(4),0(R4)     Move 4 characters so last one\n*                                     is not blank.\n         MVC   ASIDWKSV(4),ASIDMV    Save these 4 characters\n         MVC   ASIDWKS(4),ASIDMV        in two places.\n         MVC   OUTPUT,OUTPUT-1       Clear output line.\n         MVC   OUTPUT(25),ASIDMSG    Move coded display format asid.\n         APUT  OUTPUT,40             And put out the message.\n         TR    ASIDMV(4),ASIDVAL     Translate display format message\n*                                      into format X'0h0h0h0h'.\n*        MVC   OUTPUT,OUTPUT-1       Test display of hex result.\n*        HEX   OUTPUT,4,ASIDMV\n*        APUT  OUTPUT,10\n         BAL   R9,VALIDTR            Validity check the hex number.\n         PACK  ASIDGET(3),ASIDMV(5)  Get rid of all zone nibbles.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Search ASID   :' Print resulting 2-bytes\n         HEX   OUTPUT+21,2,ASIDBIN\n         APUT  OUTPUT,30\n         APUT  MESSAGEL,L'MESSAGEL   Add underline for clear display.\n*\nGETASIDE DS    0H                    End of routine.\n         LM    R1,R6,SAVERGS1        Restore registers\n         L     R9,SAVER9C               and\n         BR    R9                          exit.\n** ---------------------------------------------------------------- **\nASIDWKB  DC    CL4'    '\nASIDWK   DC    CL4'    '\nASIDWKF  DC    CL4' '\nASIDMV   DC    CL4'    '\nASIDMVF  DC    CL4' '\nASIDBIN  DS    0XL2\nASIDGET  DC    XL4'00000000'\nSAVERGS1 DS    6F\n** ---------------------------------------------------------------- JOE\n*   GETASCB - return ASCB, given the asid of address space          JOE\n*   -------                                                         JOE\n*  Input:                                                           JOE\n*      FOUNASID = ASID                                              JOE\n*  Output:                                                          JOE\n*      r15 = 0    Error                                             JOE\n*      r15 = ASCB                                                   JOE\n** ---------------------------------------------------------------- JOE\nGETASCB  DS    0H                                                   JOE\n         ST    R9,SAVER9M            Save Register                  JOE\n         L     R15,CVTPTR            R15 -> cvt                     JOE\n         L     R15,CVTASVT-CVT(,R15)  R15 -> asvt                   JOE\n         USING ASVT,R15                                             JOE\n         CLC   ASVTASVT-ASVT(4,R15),=C'ASVT'  check eyecatcher      JOE\n         BNE   NOASCB                                               JOE\n         LA    R15,ASVTENTY-ASVT(,R15) Get first asvt slot          JOE\n         LH    R0,FOUNASID           Get asid in question           JOE\n         BCTR  R0,0                  Down By 1                      JOE\n         SLL   R0,2                  Multiply by 4                  JOE\n         AR    R15,R0                Point to ASCB                  JOE\n         B     GETASCBE              Exit this routine              JOE\nNOASCB   DS    0H                                                   JOE\n         XR    R15,R15               Clear r15 - no ASCB there      JOE\nGETASCBE DS    0H                                                   JOE\n         L     R9,SAVER9M            Restore Register               JOE\n         BR    R9                                                   JOE\n** ---------------------------------------------------------------- JOE\n*                   Translate table to validity check ASID.\n*                     Convert display values to X'0h'\n*                     (where h is the hex value).\nASIDVAL  DS    0D\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'00CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CC0A0B0C0D0E0FCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CC0A0B0C0D0E0FCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'00010203040506070809CCCCCCCCCCCC'\nFILLER1  DS    CL24\nASIDMSG  DC    CL21'ASID parm entered  : '\nASIDWKSV DC    CL4' '\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\nFINDCSCB DS    0H                  Find CSCB entry to change or report.\n         ST    R9,SAVER9D          Save registers.\n         ST    R3,SAVER3A\nFINDCSST DS    0H                  Get the first CSCB.\n         L     R3,16               CVT\n         L     R3,X'94'(,R3)       MSER - pointer to CSCB chain.\n         ICM   R3,15,0(R3)         First CSCB entry.\n         USING CHAIN,R3            Tell assembler.\n         BZ    FINDCSEC            If zero, we are at end of CSCB chain\nFINDCSLP DS    0H                  Loop through the CSCB entries.\n         MVC   CSCBACTF(1),CHACT     Save CSCB ACT flag for this CSCB.\n         MVC   SAVEACTF(1),CHACT     Save CSCB ACT flag for this CSCB.\n         MVC   CSCBJOBI(8),CHKEY     Save CSCB Jobid (CHKEY).\n         MVC   CSCBPROC(8),CHCLS     Save CSCB PROC id (CHCLS).\n         MVC   CSCBASID(2),CHASID    Save CSCB ASID (CHASID).\n* ------------------------------------------------------------------- *\n* We first try to match a JOBID if coded, to the job id in this CSCB. *\n* If equal, we see if an ASID has been coded, and both have to match. *\n* Otherwise, with no match, we go to the end of the CSCB chain.       *\n* ------------------------------------------------------------------- *\nFINDCSMY DS    0H                  Find the CSCB that I want.\n         TM    FLAG1,X'04'         Was ASID( coded at all?\n         BZ    FINDCSJB            No. Just find a JOBID match.\n         TM    FLAG1,X'01'         Is the JOB id missing?\n         BO    FINDCSAS            Yes, just look for an ASID match.\n         TM    FLAG1,X'02'         Was JOB id coded?\n         BO    FINDCSJB            Yes. Look for it.\n         ICM   R3,15,0(R3)         Go to next CSCB.\n         BZ    FINDCSEC            If zero, we are at end of CSCB chain\n         B     FINDCSLP            Look at next CSCB entry in table.\nFINDCSJB DS    0H                  Check for JOBID match in this CSCB.\n         CLC   JOBID(8),CSCBJOBI   Compare coded JOBID to CSCB jobname.\n         BE    FINDCSIA            Equal, check if ASID is there.\n         ICM   R3,15,0(R3)         Otherwise go to the next CSCB.\n         BZ    FINDCSEC            Zero, end of the CSCB chain.\n         B     FINDCSLP            Not zero, look at the next entry.\nFINDCSIA DS    0H\n         TM    FLAG1,X'04'         Was ASID( coded?\n         BZ    FINDCSFD            No. Found it on just a job match.\n*                                   So this is the first job that\n*                                   matched, if there are multiple\n*                                   jobs with the same name.\nFINDCSAS DS    0H                  Check the ASID in the CSCB.\n         CLC   ASIDBIN(2),CSCBASID Is this our ASID? Does it match.\n         BE    FINDCSFD            I guess we found it.\n         ICM   R3,15,0(R3)         Go to the next CSCB.\n         BZ    FINDCSEC            Zero marks the end of the CSCB chain\n         B     FINDCSLP            Not zero. Look at the next entry.\nFINDCSFD DS    0H                  Our CSCB has been found.\n         ST    R3,FOUNCSCB         Save found CSCB address.\n         MVC   FOUNACTF,CHACT      Save\n         MVC   SAVEACTF,CHACT      Save\n         MVC   FOUNJOBI,CHKEY        CSCB\n         MVC   FOUNPROC,CHCLS          info.\n         MVC   FOUNASID,CHASID\n         MVC   SAVEASID,CHASID\n         BAL   R9,PRNTCSCB         Print info from the current CSCB.\n         BAL   R9,FORCHACT         Format some CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Put out an underline.\n         B     FINDCSEN            Go to end of routine.\n         DROP  R3\nFINDCSEC DS    0H                  Came to end of CSCB chain.\n         APUT  MESSAGEN,L'MESSAGEN   Then put out a message\n         B     EOJ4                  And end with code 4.\nFINDCSEN DS    0H\n         L     R3,SAVER3A\n         L     R9,SAVER9D\n         BR    R9\n*            Constants associated with this routine.    -    below\nFOUNACTF DC    X'00'\nSAVEACTF DC    X'00'\nFOUNCSCB DS    F                   FOUND CSCB ADDRESS\nFOUNJOBI DC    CL8' '\nFOUNPROC DC    CL8' '\nFOUNASID DC    H'0'\nSAVEASID DC    H'0'\nCSCBACTF DC    X'00'\nCSCBJOBI DC    CL8' '\nCSCBPROC DC    CL8' '\nCSCBASID DC    H'0'\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\nVALIDTR  DS    0H                  Validate hex characters coded.\n         ST    R9,SAVER9E          Save\n         STM   R4,R6,SAVEWRK          registers.\n         LA    R4,ASIDMV           Point to translated display chars.\n         LA    R6,ASIDWKS          Point to chars with error signs.\n         LA    R5,4                BCT register - only 4 times.\nVALIDTRS DS    0H\n         CLI   0(R4),X'CC'         Is this an invalid character?\n         BE    VALIDTRR            Yes. Substitute a ? for message.\n         LA    R4,1(,R4)           Next translated character.\n         LA    R6,1(,R6)           Next char for error message.\n         BCT   R5,VALIDTRS         Loop to test validity of this char.\n         TM    ERRASID,X'01'       After 4 chars, any errors found?\n         BO    VALIDERR            Yes. Write messages.\n         B     VALIDTRE            No. Get out of routine.\nVALIDTRR DS    0H                  Come here if invalid char found.\n         OI    ERRASID,X'01'       Flag that at least one was found.\n         MVI   0(R6),C'?'          Substitute a ? for it in message.\n         LA    R4,1(,R4)           Next translated character.\n         LA    R6,1(,R6)           Next char in error message.\n         BCT   R5,VALIDTRS         Check that character for validity.\nVALIDERR DS    0H                  Error messages if char is invalid.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(37),ASIDBADM\n         APUT  OUTPUT,45\n*        MVC   OUTPUT,OUTPUT-1\n*        MVC   OUTPUT(51),MSGBADPR\n*        APUT  OUTPUT,52\n         B     EOJ4                Get out with code 4.\nVALIDTRE DS    0H\n         L     R4,SAVER4B          Restore regs used in this routine.\n         LM    R4,R6,SAVEWRK\n         BR    R9\n*            Constants associated with this routine.    -    below\nERRASID  DC    X'00'\nSAVEWRK  DS    3F\nMSGBADPR DC    C'Bad ASID entered. Use end parenthesis ) to delimit.'\nASIDBADM DC    CL33'Bad Characters marked with a ?:  '\nASIDWKS  DC    CL4' '\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\n* -- -- -- -- -- -- -- -- -- -- -- --    R3 points to a CSCB address\nPRNTCSCB DS    0H                  Print a CSCB entry.\n         ST    R9,SAVER9F          Save BAL register.\n         ST    R3,SAVECSCB         Saved found CSCB address.\n         USING CHAIN,R3\n*                   Print info from current CSCB\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Job  ID :'\n         MVC   OUTPUT+11(8),CHKEY\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Proc ID :'\n         MVC   OUTPUT+11(8),CHCLS\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'ASID    :'\n         HEX   OUTPUT+11,2,CHASID\n         APUT  OUTPUT,25\n         TM    FLAG2,X'80'                Is this a BURN or KILL?   KIL\n         BO    PRNTFINI                   Yes. Abridge the messages BUR\n         TM    FLAG2,X'40'                CSCB only run. i.e. DISPLAY\n         BO    PRNTCSC1\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Previous CHACT Flags:'\n         HEX   OUTPUT+23,1,CHACT\n         APUT  OUTPUT,25\n         B     PRNTCSC2\nPRNTCSC1 DS    0H\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Current  CHACT Flags:'\n         HEX   OUTPUT+23,1,CHACT\n         APUT  OUTPUT,25\nPRNTCSC2 DS    0H\n         DROP  R3\nPRNTFINI DS    0H                                                   BUR\n         L     R3,SAVECSCB         Restore register to what it was.\n         L     R9,SAVER9F          Restore BAL register and\n*                                     branch back to caller.        BUR\n         BR    R9\nSAVECSCB DS    F                   Saved address of found CSCB.\n** ---------------------------------------------------------------- **\nRUNCSCB  DS    0H                  Run through the CSCB chain.\n         ST    R9,SAVER9G\n         ST    R3,SAVER3C\n         ST    R7,SAVER7A\nRUNCSCBT DS    0H\n         TM    FLAG2,X'40'         Only run if CSCB keyword was coded.\n         BZ    RUNCSCBE            Not coded, get out.\n*                                  Display this is a CSCB chain run.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(40),=C'This is a run of the CSCB Chain only ...'\n         APUT  OUTPUT,45\n         APUT  MESSAGEL,L'MESSAGEL   Print underline.\n*                                  Find the CSCB chain:\n         L     R3,16               CVT\n         L     R3,X'94'(,R3)       MSER - pointer to CSCB chain.\n         ICM   R3,15,0(R3)         First CSCB entry.\n         BZ    RUNCSCBE            If zero, end of CSCB chain.\n*                                  Otherwise points to next CSCB in\n*                                    the table.\n         USING CHAIN,R3\nRUNCSCBD DS    0H                  Loop through CSCB entries.\n         MVC   CSCBACTF(1),CHACT     Save CSCB ACT flag for this CSCB.\n         MVC   SAVEACTF(1),CHACT     Save CSCB ACT flag for this CSCB.\n         MVC   CSCBJOBI(8),CHKEY     Save CSCB JOBID (CHKEY).\n         MVC   CSCBPROC(8),CHCLS     Save CSCB PROC id (CHCLS).\n         MVC   CSCBASID(2),CHASID    Save CSCB ASID (CHASID).\n         MVC   SAVEASID(2),CHASID    Save CSCB ASID (CHASID).\n*  Test\n*        MVC   OUTPUT,OUTPUT-1\n*        HEX   OUTPUT,2,CHASID\n*        HEX   OUTPUT+6,2,ASIDBIN\n*        MVI   OUTPUT+15,C'i'\n*        APUT  OUTPUT,25\n*  Test\n* -- Limit print of entries to Jobname or ASID only ----  below\n         CLI   JOBID,C'-'          Are we printing the whole CSCB?\n         BE    RUNCSCBY            Yes.\n         CLC   ASIDBIN,=X'0000'    Was an ASID coded for a search?\n         BNE   RUNCSCB2            No. Just check for Jobname.\nRUNCSCB1 DS    0H                  Check for Jobname match.\n         XR    R7,R7               Clear work register.\n         IC    R7,SAVCOUNT         Insert saved length of Jobid.\n         BCTR  R7,0                Decrement for execute.\n         EX    R7,RUNCSCOM         Do the compare for proper length.\n*        BNE   RUNCSCBS            Not equal, don't print result.\n         BE    RUNCSCBP            Equal, print this CSCB entry.\nRUNCSCB2 DS    0H                  Check if ASID was coded.\n         CLC   ASIDBIN,CHASID      ASID match?\n         BNE   RUNCSCBS            No. Skip print of CSCB entry.\nRUNCSCBY DS    0H\n* -- Limit print of entries to Jobname or ASID only ----  above\nRUNCSCBP DS    0H                  Print this entry....\n         BAL   R9,PRNTCSCB         Print of current CSCB information.\n         BAL   R9,FORCHACT         Format some CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline line.\nRUNCSCBS DS    0H                  If skipping an entry print, go here.\n         ICM   R3,15,0(R3)         Go to next CSCB entry in table.\n         BZ    RUNCSCBE            If it is zero, end of CSCB chain.\n         B     RUNCSCBD            Not zero, loop to next entry and\n*                                    print it.\nRUNCSCBE DS    0H                  End of routine.\n         L     R3,SAVER3C          Restore\n         L     R7,SAVER7A\n         L     R9,SAVER9G             registers and\n         BR    R9                        go back to caller.\nRUNCSCOM CLC   JOBID(*-*),CHKEY    Executed\n         DROP  R3\n** ---------------------------------------------------------------- **\nKEYZERO  DS    0H                  Into Key 0 and change CSCB cntl blk.\n         ST    R9,SAVER9H\n         ST    R4,SAVER4A\n*\n* -- >  Test if this command is being run APF Authorized - below\n         STM   R15,R1,SAVE14T1     Now save registers and test if APF\n         XR    R15,R15                  authorized.\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.\n* -- >  Test if this command is being run APF Authorized - above\n*\n* -- >    ***    Do as little as possible under Key 0.    ***\nKEYPRLIM DS    0H\n         TM    ONSWIT,X'01'        Are we OR-ing?\n         BZ    SWITOFF             No. Try AND-ing?\n         MVC   CANCKEY0,CANCINDC   Pre-process affecting bits.\n         B     SWITON              All done pre-processing.\nSWITOFF  DS    0H\n         TM    ONSWIT,X'02'        Are we AND-ing?\n         BZ    KEY0BYPS            No. Don't do anything else.\n         XC    CANCINDC,=X'FF'     Reverse the affected bits for AND.\n         MVC   CANCKEY0,CANCINDC   And move them to staging area.\nSWITON   DS    0H\n         USING CHAIN,R3\n         L     R3,FOUNCSCB         Save address of \"found CSCB\".\n*\n* -- >                             We're authorized. Go Key 0.\n         MODESET KEY=ZERO\n         TM    ONSWIT,X'01'        Are we OR-ing?\n         BZ    KEY0OFF             No. Try AND-ing.\n         OC    CHACT(1),CANCKEY0   Do the OR.\n         B     KEY0END             Out of Key 0.\nKEY0OFF  DS    0H\n         TM    ONSWIT,X'02'        Are we AND-ing?\n         BZ    KEY0END             No. Get out altogether.\n         NC    CHACT(1),CANCKEY0   Do the AND.\nKEY0END  DS    0H                  Out of Key 0.\n         MODESET KEY=NZERO\n*\nKEY0BYPS DS    0H                  Key 0 bypass - branch to here.\n         MVC   SAVEACTF(1),CHACT   Record for posterity\n         DROP  R3\n         L     R4,SAVER4A\n         L     R9,SAVER9H\n         BR    R9\n** ---------------------------------------------------------------- **\nPRNWCSCB DS    0H                  Print the changed CSCB entry.\n         ST    R9,SAVER9I          Save BAL register.\n         ST    R3,SAVER3D\n         L     R3,FOUNCSCB         Saved found CSCB address.\n         USING CHAIN,R3\n*                   Print info from changed CSCB.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Job  ID :'\n         MVC   OUTPUT+11(8),CHKEY\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Proc ID :'\n         MVC   OUTPUT+11(8),CHCLS\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'ASID    :'\n         HEX   OUTPUT+11,2,CHASID\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Modified CHACT Flags:'\n         HEX   OUTPUT+23,1,CHACT\n         APUT  OUTPUT,25\n         APUT  MESSAGEL,L'MESSAGEL\n         DROP  R3\n         L     R3,SAVER3D          Restore register to what it was.\n         L     R9,SAVER9I          Restore BAL register and\n         BR    R9                     branch back to caller.\n** ---------------------------------------------------------------- **\n**             REPORT - Format the CHACT Flags - REPORT             **\n** ---------------------------------------------------------------- **\nFORCHACT DS    0H                  SAVEACTF less volatile than CHACT.\n         ST    R9,SAVER9J          Save\n         ST    R3,SAVER3E             registers.\n         USING CHAIN,R3\nFORCANC0 DS    0H                  Show cancelable or not.\n         TM    SAVEACTF,CHCL       Is job cancelable?\n         BO    FORCANC1            Yes, show cancelable.\n         BZ    FORCANC2            No. Show non-cancelable.\n         B     FORFORC0            Fall through, try forceable.\nFORCANC1 DS    0H\n         MVC   MESSTXT,MESSCAN     Tell em job is cancelable.\n         B     FORCANCP\nFORCANC2 DS    0H\n         MVC   MESSTXT,MESSNCN     Tell em job is non-cancelable.\nFORCANCP DS    0H                  Write the actual message out.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(28),FORMTMSG\n         APUT  OUTPUT,30\nFORFORC0 DS    0H                  Show forceable or not.\n         TM    SAVEACTF,CHAFORCE   Can you do FORCE w/o CANCEL?\n         BO    FORFORC1            Yes. Don't need CANCEL first.\n         BZ    FORFORC2            No. Show you need CANCEL first.\nFORFORC1 DS    0H\n         MVC   MESSTXT,MESSFOR     Tell em FORCE ok w/o CANCEL.\n         B     FORFORCP\nFORFORC2 DS    0H\n         MVC   MESSTXT,MESSNFR     Tell em need CANCEL before FORCE.\nFORFORCP DS    0H                  Write the actual message out.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(28),FORMTMSG\n         APUT  OUTPUT,30\nFORKILLF DS    0H                  Figure out if Non-Memtermable or not\n         ST    R4,SAVER4D          Save work register\n*        CLC   SAVEASID,CHASID\n*        BNE   FORKILLX\n*        MVC   FOUNASID,CHASID     Stage ASID for GETASCB routine\n*        B     FORKILLY\nFORKILLX MVC   FOUNASID,SAVEASID\nFORKILLY DS    0H\n         BAL   R9,GETASCB          Get the ASCB.\n         LTR   R15,R15             Is there one?\n         BZ    FORCHEND            No. Exit this routine.\n         ST    R15,SAVEASCB        Save address of ASCB.\n         L     R4,SAVEASCB         Reload address of ASCB in work reg.\n         L     R4,0(,R4)           Get actual ASCB into register.\n         USING ASCB,R4\n         TM    ASCBFLG2,ASCBNOMT   Test if Non-Memtermable bit is on.\n         BZ    FOROMEMT            No. Report that it's off.\n         MVC   MESSTXT,MESSNMT     Yes. Put Non-Memtermable into msg.\n         B     FORKILLO            And put out the message.\nFOROMEMT DS    0H\n         MVC   MESSTXT,MESSMMT     No. Put Memtermable into message.\nFORKILLO MVC   OUTPUT,OUTPUT-1     And put out the message.\n         MVC   OUTPUT(28),FORMTMSG\n         APUT  OUTPUT,30\n         L     R4,SAVER4D          Restore work register.\n         DROP  R4                  Lose ASCB addressability.\nFORCHEND DS    0H\n         DROP  R3\n         L     R3,SAVER3E          Restore\n         L     R9,SAVER9J             registers.\n         BR    R9\n*            Constants associated with this routine.    -    below\nMESSCAN  DC    CL15'Cancelable     '\nMESSNCN  DC    CL15'Non-Cancelable '\nMESSFOR  DC    CL15'Force w/o Cncel'\nMESSNFR  DC    CL15'Cancel + Force '\nMESSNMT  DC    CL15'Non-Memtermable'\nMESSMMT  DC    CL15'Memtermable    '\nFORMTMSG DS    0CL28\nMESS000  DC    CL13'Job Status:  '\nMESSTXT  DC    CL15'               '\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\nPRINTERR DS    0H                    Print help messages.\n         ST    R9,SAVER9K            Save BAL register.\n         APUT  MESSAG2A,L'MESSAG2A\n         APUT  MESSAG2B,L'MESSAG2B\n         APUT  MESSAG2V,L'MESSAG2V\n         APUT  MESSAG2U,L'MESSAG2U\n         APUT  MESSAG2C,L'MESSAG2C\n         APUT  MESSAG2D,L'MESSAG2D\n         APUT  MESSAG2E,L'MESSAG2E\n         APUT  MESSAG2F,L'MESSAG2F\n         APUT  MESSAGEM,L'MESSAGEM\n         APUT  MESSAG2G,L'MESSAG2G\n         APUT  MESSAG2H,L'MESSAG2H\n         APUT  MESSAGEM,L'MESSAGEM\n         APUT  MESSAG2I,L'MESSAG2I\n         APUT  MESSAG2J,L'MESSAG2J\n         APUT  MESSAG2K,L'MESSAG2K\n         APUT  MESSAG2L,L'MESSAG2L\n         APUT  MESSAG2M,L'MESSAG2M\n         APUT  MESSAG2N,L'MESSAG2N\n         APUT  MESSAG2O,L'MESSAG2O\n         APUT  MESSAG2P,L'MESSAG2P\n         APUT  MESSAG2Q,L'MESSAG2Q\n         APUT  MESSAG2R,L'MESSAG2R\n         APUT  MESSAG2S,L'MESSAG2S\n         APUT  MESSAG2T,L'MESSAG2T\n         APUT  MESSAGEM,L'MESSAGEM\n         L     R9,SAVER9K            Restore BAL register.\n         BR    R9\n** ----------------------------------------------------------------- **\n*        Control of the following routines are under control of       *\n*           the KILLFLAG, and are not under control of FLAG2.         *\n*                                                                     *\n*        KILLFLAG controls processes KILL, BURN, NMEM and MEMT.       *\n*              (Routine sets FLAG2 EQU X'80')                         *\n*  ------------------------------------------------------------------ *\n*                   Settings of the KILLFLAG                          *\n*                                                                     *\n*  KILLFLAG  equals  X'01'            for KILL (whack always)         *\n*                    X'01' and X'02'  for BURN (whack only if MEMT)   *\n*                    X'04'            for NMEM (make NON-memtermable) *\n*                    X'08'            for MEMT (make memtermable)     *\n*                                                                     *\n** ----------------------------------------------------------------- **\nDONMEM   DS    0H                        NON-MEMTERMABLE   FLAG X'04'\n         NI    KILLFLAG,X'04'            ONLY NMEM FLAG ON. Others off\n         OI    KILLFLAG,X'04'            TURN NMEM FLAG ON\n         B     FLGSDONE\nDOMEMT   DS    0H                        MEMTERMABLE       FLAG X'08'\n         NI    KILLFLAG,X'08'            ONLY MEMT FLAG ON  Others off\n         OI    KILLFLAG,X'08'            TURN MEMT FLAG ON\n         B     FLGSDONE\nDOBURN   DS    0H                        BURN. X'02' and X'01' both on\n         OI    KILLFLAG,X'02'            Announce BURN as keyword\nDOKILL   DS    0H                        KILL process. KILL flag on.\n         OI    KILLFLAG,X'01'            Announce KILL as keyword\nFLGSDONE DS    0H                        Flags have been set.\n         TM    FLAG0,X'40'               Have PSCB ACCT authority?\n         BZ    NOTALLOW                  No. Can't do these commands.\n*  ------------------------------------------------------------------ *\n*                    Print the action code for                        *\n*                    everything under FLAG2=X'80'                     *\n*  ------------------------------------------------------------------ *\n         OI    FLAG2,X'80'               Mark under KILLFLAG control.\n*  ------------------------------------------------------------------ *\n         MVC   OUTPUT,OUTPUT-1           Print message accordingly\n         MVC   OUTPUT(15),=C'Action code   :'\nTRYBURN  TM    KILLFLAG,X'02'            For BURN, X'01' and X'02' on.\n         BZ    TRYKILL\n         MVC   OUTPUT+17(4),BURNC        Mark as a BURN.\n         B     PRTCODE\nTRYKILL  TM    KILLFLAG,X'01'\n         BZ    TRYNMEM\n         MVC   OUTPUT+17(4),KILLC        Mark as a KILL.\n         B     PRTCODE\nTRYNMEM  TM    KILLFLAG,X'04'\n         BZ    TRYMEMT\n         MVC   OUTPUT+17(4),NMEMC        Mark as a NMEM.\n         B     PRTCODE\nTRYMEMT  TM    KILLFLAG,X'08'\n         BZ    PRTCODE\n         MVC   OUTPUT+17(4),MEMTC        Mark as a MEMT.\nPRTCODE  DS     0H                       And print the result.\n         APUT  OUTPUT,25\n*  ------------------------------------------------------------------ *\n* -- >  Test if this command is being run APF Authorized - below    BUR\nTAUTH    STM   R15,R1,SAVE14T1   Now save registers and test if APF BUR\n         XR    R15,R15                authorized.                   BUR\n         TESTAUTH FCTN=1           Are we authorized?               BUR\n         LTR   R15,R15             Test the return code.            BUR\n         BNZ   NOTAUTH           Not zero, tell not authorized.     BUR\n         LM    R15,R1,SAVE14T1   Restore registers used by TESTAUTH BUR\n* -- >  Test if this command is being run APF Authorized - above    BUR\n*  ------------------------------------------------------------------ *\n         BAL   R9,FINDCSCB               Get correct CSCB entry.    BUR\n         MODESET KEY=ZERO,MODE=SUP                                  BUR\n         ST    R7,SAVER7B                Store work register        BUR\n         LH    R7,CSCBASID               Set ASID                   BUR\n         TM    KILLFLAG,X'0C'            NMEM or MEMT action?\n         BNZ   ASCBBITS                  If either, then not KILL\n*----->               KILL routine - below                          KIL\n         TM    KILLFLAG,X'01'            Is the KILL flag on?       KIL\n         BZ    SKIPMEMT                  No. Exit this routine.     KIL\nASCBBITS DS    0H\n         CLC   CSCBASID,=X'0000'         Did FINDCSCB find a CSCB?  KIL\n         BE    SKIPMEMT                  No. Exit this routine.     KIL\n         MVC   FOUNASID,CSCBASID         Stage ASID to get the ASCB KIL\n         BAL   R9,GETASCB                Get the ASCB.              KIL\n         LTR   R15,R15                   Is there one?              KIL\n         BZ    SKIPMEMT                  No. Exit this routine.     KIL\n         ST    R15,SAVEASCB              Save address of ASCB.      KIL\n         L     R15,0(,R15)               Load it to address fields. KIL\n         USING ASCB,R15                                             KIL\n         TM    KILLFLAG,X'08'            MEMT?\n         BO    FORCEOFF\n         TM    KILLFLAG,X'04'            NMEM?\n         BO    FORCEON\n         TM    KILLFLAG,X'02'            BURN only?                 BUR\n         BO    EXITKILL                  Non-forcible still on.     BUR\n         TM    KILLFLAG,X'01'            If not X'01' then no MEMTERM.\n         BZ    SKIPMEMT                  Yes. Turn off ASCB bits first.\n         NI    ASCBFLG2,255-ASCBNOMT     Turn off NON-FORCIBLE bit  KIL\n         NI    ASCBFLG2,255-ASCBNOMD     Turn off Dat error bit     KIL\n         B     EXITKILL                  Go do MEMTERM.\nFORCEOFF NI    ASCBFLG2,255-ASCBNOMT     Turn off NON-FORCIBLE bit\n         NI    ASCBFLG2,255-ASCBNOMD     Turn off Dat error bit\n         B     SKIPMEMT                  And skip MEMTERM.\nFORCEON  DS    0H                        Make Non-Memtermable.\n         OI    ASCBFLG2,ASCBNOMT         Put the ASCBNOMT bit on.\n         ST    R3,SAVER3F                Then\n         L     R3,FOUNCSCB                  Make\n         USING CHAIN,R3                        Job\n         NI    CHACT,255-X'08'                    Non-Cancelable too.\n         MVC   SAVEACTF(1),CHACT         Save for reporting\n         L     R3,SAVER3F                Restore work register.\n         B     SKIPMEMT                  Don't do CALLRTM MEMTERM.\n         DROP  R3\nEXITKILL DS    0H                        Now do CALLRTM MEMTERM.    KIL\n         DROP  R15                       Drop ASCB addressability   KIL\n*----->               KILL routine - above                          KIL\n         ST    R13,SAVER13A              Save R13                   BUR\n         LA    R13,RTMSAVE               RTM save area              BUR\n         CALLRTM TYPE=MEMTERM,ASID=(R7),COMPCOD=100                 BUR\n         STC   R15,RTMCOD                Save MEMTERM Return Code\n         L     R13,SAVER13A              Restore R13                BUR\nSKIPMEMT DS    0H\n         L     R7,SAVER7B                Restore work register      BUR\n         MODESET KEY=NZERO,MODE=PROB                                BUR\n         CLI   RTMCOD,X'2C'              Non-memtermable addr space?\n         BE    NOTMEMTM                  Yes. Issue message to say so.\n*\n         TM    KILLFLAG,X'04'            Message if NMEM done.\n         BZ    TRYMMEMT\n         MVC   MESSAGM1+4(8),FOUNJOBI    Jobname into message       BUR\n         HEX   MESSAGM1+22,2,FOUNASID    ASID into message          BUR\n         APUT  MESSAGM1,L'MESSAGM1       Say job made non-memtermable\n         B     BURNEND                   Done with message\nTRYMMEMT DS    0H\n         TM    KILLFLAG,X'08'\n         BZ    TRYMBURN\n         MVC   MESSAGM2+4(8),FOUNJOBI    Jobname into message       BUR\n         HEX   MESSAGM2+22,2,FOUNASID    ASID into message          BUR\n         APUT  MESSAGM2,L'MESSAGM2       Say job was killed.        BUR\n         B     BURNEND                   Done with message          KIL\nTRYMBURN TM    KILLFLAG,X'02'            KILL msg instead of BURN?  KIL\n         BO    BURNMSG                   Yes. Run BURN message.     KIL\n         MVC   MESSAGKI+4(8),FOUNJOBI    Jobname into message       BUR\n         HEX   MESSAGKI+22,2,FOUNASID    ASID into message          BUR\n         APUT  MESSAGKI,L'MESSAGKI       Say job was killed.        BUR\n         B     BURNEND                   Skip BURN message          KIL\nBURNMSG  DS    0H\n         MVC   MESSAGBU+4(8),FOUNJOBI    Jobname into message       KIL\n         HEX   MESSAGBU+22,2,FOUNASID    ASID into message          KIL\n         APUT  MESSAGBU,L'MESSAGBU       Say job was burned.        KIL\nBURNEND  DS    0H\n         B     GETIDEND            After enough looks, end.         KIL\nRTMSAVE  DS    CL72                Work area for RTM                BUR\nSAVER13A DS    F                   Place to save R13                BUR\nSAVEASCB DS    F                   Save ASCB address                KIL\n** ---------------------------------------------------------------- **\nKEY0SWNS DS    0H                    Key 0 for SWAP or NSWP\n         ST    R9,SAVER9L            Save BAL register.\n         ST    R6,SAVER6A\nKEY0TSTA DS    0H\n* -- >  Test if this command is being run APF Authorized - below\n         STM   R15,R1,SAVE14T1     Now save registers and test if APF\n         XR    R15,R15                  authorized.\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.\n* -- >  Test if this command is being run APF Authorized - above\n         TM    FLAG2,X'04'         Make ASID swappable?\n         BO    KEY0SWAP            Yes. Do it.\n         TM    FLAG2,X'08'         Make ASID non-swappable?\n         BO    KEY0NSWP            Yes. Do it.\n         B     KEY0EXIT            Not SWAP or NSWP, don't belong here.\n*\nKEY0NSWP DS    0H                    Make address space non-swappable.\n*\n         CLC   OWNASID,FOUNASID      Target asid different from ours?\n         BE    KEY0DNSW              No. Just do SYSEVENT.\n         MVC   FUNC,=CL8'DONTSWAP'   Set nswapping function         JOE\n         BAL   R9,BUILDSRB           Build SRB block                JOE\n*                                                                   JOE\n* ISSUE SUCCESSFUL MESSAGE                                          JOE\n*                                                                   JOE\n         MVC   MESSAGNS+4(8),FOUNJOBI                               JOE\n         HEX   MESSAGNS+22,2,FOUNASID                               JOE\n         APUT  MESSAGNS,L'MESSAGNS                                  JOE\n         L     R6,SAVER6A            Restore Register               JOE\n         L     R9,SAVER9L            Restore BAL register.          JOE\n         BR    R9                    go back                        JOE\nTEMPSAVE DS    4F                    save area                      JOE\n* ---------------------------------------------------------------- *\nKEY0DNSW DS    0H\n         MODESET MODE=SUP,KEY=ZERO\nKEY0SYSD DS    0H\n         LH    R6,FOUNASID\n         SYSEVENT DONTSWAP,ASID=(R6),ENTRY=SVC\nKEY0NNRM DS    0H\n         MODESET MODE=PROB,KEY=NZERO\n         MVC   MESSAGNS+4(8),FOUNJOBI\n         HEX   MESSAGNS+22,2,FOUNASID                               JOE\n         APUT  MESSAGNS,L'MESSAGNS\n         B     KEY0EXIT\nKEY0SWAP DS    0H                    Make address space swappable.\n         CLC   OWNASID,FOUNASID      Target asid different from ours?\n         BE    KEY0DSWP              No. Just do SYSEVENT.\n         MVC   FUNC,=CL8'OKSWAP'     Set function                   JOE\n         BAL   R9,BUILDSRB           Build SRB CSA CONTROL BLOCKS   JOE\n*                                                                   JOE\n*  issue successful message                                         JOE\n*                                                                   JOE\n         MVC   MESSAGSW+4(8),FOUNJOBI                               JOE\n         HEX   MESSAGSW+22,2,FOUNASID                               JOE\n         APUT  MESSAGSW,L'MESSAGSW                                  JOE\n         L     R6,SAVER6A            Restore Registers              JOE\n         L     R9,SAVER9L            Restore BAL register.          JOE\n         BR    R9                                                   JOE\nKEY0DSWP DS    0H\n         LH    R6,FOUNASID\n         SYSEVENT OKSWAP,ASID=(R6),ENTRY=SVC\nKEY0SNRM DS    0H\n         MODESET MODE=PROB,KEY=NZERO\n         MVC   MESSAGSW+4(8),FOUNJOBI\n         HEX   MESSAGSW+22,2,FOUNASID                               JOE\n         APUT  MESSAGSW,L'MESSAGSW\n         B     KEY0EXIT\nKEY0NODO DS    0H\n         MODESET MODE=PROB,KEY=NZERO\n         HEX   MESSAGNG+43,1,SYSEVCOD+3\n         APUT  MESSAGNG,L'MESSAGNG\nKEY0EXIT DS    0H\n         L     R6,SAVER6A\n         L     R9,SAVER9L            Restore BAL register.\n         BR    R9\n*--------------------------------------------------------------*    JOE\n*                                                              *    JOE\n*        BUILD SRB CONTROL BLOCK AND ACCOMPANYING CODE         *    JOE\n*                                                              *    JOE\n*--------------------------------------------------------------*    JOE\nBUILDSRB DS    0H                                                   JOE\n         STM   R6,R9,TEMPSAVE        Save Registers                 JOE\n         BAL   R9,GETASCB            Find ASCB for this asid        JOE\n         LR    R9,R15                Hold ASCB                      JOE\n         L     R9,0(,R9)             Point to ASCB                  JOE\n         MODESET MODE=SUP,KEY=ZERO   Get into supervisor state      JOE\n*                                                                   JOE\nCSA_LEN  EQU  SRBSIZE+84             CSA SRBLOCK AND PARAMTERS      JOE\n*                                                                   JOE\n*---------------------------------------------------------------*   JOE\n*       Get CSA for SRB CONTROL BLOCK SUBPOOL 241               *   JOE\n*---------------------------------------------------------------*   JOE\n         STORAGE OBTAIN,SP=241,LENGTH=CSA_LEN Get Some CSA          JOE\n         LR    R6,R1                 Point R6 to SRB control block  JOE\n         USING SRB,R6                Address SRB                    JOE\n         XC    SRB(SRBSIZE),SRB      Clear out SRB                  JOE\n         ST    R9,SRBASCB            Save ASCB                      JOE\n         LA    R8,SRBSIZE(,R6)       R8 -> paramlist                JOE\n*       Get CSA paramter list                                   *   JOE\n         ST    R8,SRBPARM            Store paramter list address    JOE\n         LA    R7,72(,R8)            Point to ECB                   JOE\n         XC    0(4,R7),0(R7)         Clear ECB Address              JOE\n         LA    R7,4(,R7)             Point to ASCB                  JOE\n         MVC   0(4,R7),X'224'        Move \"HOME\" PSAAOLD address sp JOE\n         LA    R7,4(,R7)             Bump to next param             JOE\n         CLC   FUNC,=C'DONTSWAP'     Q. non swappable function      JOE\n         BE    NONSWAP               Yes; branch if so              JOE\n         MVC   0(4,R7),=C'OKSW'      Otherwise swappable            JOE\n         B     SETEPA                Set SRB program entry point    JOE\nNONSWAP  DS    0H                                                   JOE\n         MVC   0(4,R7),=C'DONT'      Set FUNCTION IN R7             JOE\n*---------------------------------------------------------------*   JOE\n*       Get CSA for SRB CONTROL BLOCK SUBPOOL 227               *   JOE\n*---------------------------------------------------------------*   JOE\nSETEPA   DS    0H                                                   JOE\n         STORAGE OBTAIN,SP=227,LENGTH=SWAPLEN  Get Fixed CSA        JOE\n         ST    R1,SRBEPA             Set entry point                JOE\n         LR    R14,R1                Hold that thought              JOE\n         LA    R15,SWAPLEN           Get Length                     JOE\n         LR    R1,R15                                               JOE\n         LA    R0,SWAPXMEM           Point to SRB routine           JOE\n         MVCL  R14,R0                Move routine                   JOE\n*                                                                   JOE\n         SCHEDULE SRB=(R6),SCOPE=GLOBAL,MODE=NONXM                  JOE\n*                                                                   JOE\n         LA    R7,72(,R8)            Point to ECB                   JOE\n*                                                                   JOE\n         WAIT  ECB=(R7)                                             JOE\n*                                                                   JOE\n         L     R9,SRBEPA             Get Entry Point Address        JOE\n*                                                                   JOE\n         STORAGE RELEASE,ADDR=(R6),LENGTH=CSA_LEN,SP=241            JOE\n*                                                                   JOE\n         STORAGE RELEASE,ADDR=(R9),LENGTH=SWAPLEN,SP=227            JOE\n*                                                                   JOE\n         MODESET KEY=NZERO,MODE=PROB                                JOE\n*                                                                   JOE\n         LM    R6,R9,TEMPSAVE        Save Registers                 JOE\n         BR    R9                    Return                         JOE\nSYSEVCOD DC    F'0'                  SYSEVENT Return Code\nOLDAX    DS    F\nWAREA    DS    D                     Work area\nWAREB    DS    D                     Work area\n** ---------------------------------------------------------------- **\n** --         C  O  N  S  T  A  N  T  S                          -- **\n** ---------------------------------------------------------------- **\nMESSAGNA DC    C'Command was not invoked APF authorized.'\nMESSAGEN DC    C'End of CSCB chain was reached.'\nMESSAGEY DC    C'No valid keyword was coded.'\nFLAG0    DC    X'00'               Copy of PSCBATR1 - Authority levels\nFLAG1    DC    X'00'               Needed to parse parameters\n*              X'01'               ASID ONLY - NO JOBNAME\n*              X'02'               JOBNAME IS PRESENT.\n*              X'04'               ASID( WAS PRESENT IN PARMS.\n*              X'08'               CSCB CHAIN DISPLAY ONLY.\nFLAG2    DC    X'00'\n*              X'01'               CNCL WAS CODED\n*              X'02'               NCNC WAS CODED\n*              X'04'               SWAP WAS CODED\n*              X'08'               NSWP WAS CODED\n*              X'10'               FORC WAS CODED\n*              X'20'               CSCB WAS CODED\n*              X'80'               BURN OR KILL WAS CODED           KIL\n*              X'40'               CSCB chain run only.\nRTMCOD   DC    X'00'               Saved return code from MEMTERM\nONSWIT   DC    X'00'\n*              X'01'               TURN BIT ON\n*              X'02'               TURN BIT OFF\nHEXSAVE  DS    3F                  SAVE FOR HEX MACRO\nSAVE     DS    9D                  Program Save Area\nSAVE14T1 DS    2D                  Save \"system-used\" registers.\n         DC    C' '                Blank before OUTPUT line.\nOUTPUT   DC    CL80'  '            Variable output line.\nFUNC     DS    CL8                 Swapppinmg function\n         LTORG\n*-----------------------------------------------------------------* JOE\n*                         SRB CODE                                * JOE\n*-----------------------------------------------------------------* JOE\nSWAPXMEM DS    0D                                                   JOE\n         DROP  R12,R11,R10                                          JOE\n         BASR  R5,0                                                 JOE\n         USING *,R5                Entry Point                      JOE\n         LR    R10,R14             Save return address              JOE\n         LR    R13,R1                                               JOE\n*                                                                   JOE\n         LA    R9,72(,R13)         Point to ECB Address             JOE\n         LA    R8,76(,R13)         Point to ASCB Address            JOE\n         L     R8,0(,R8)                                            JOE\n         L     R7,80(,R13)         Get code                         JOE\n*                                                                   JOE\n         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=STDSAVE         JOE\n*                                                                   JOE\n         C      R7,=C'OKSW'        OKSWAP                           JOE\n         BE     SETSWAP                                             JOE\n*                                                                   JOE\n         XR    R1,R1               Undocumented instead of WAIT     JOE\n         SYSEVENT DONTSWAP,ENTRY=BRANCH                             JOE\n*                                                                   JOE\n         B     UNLOCK                                               JOE\n*                                                                   JOE\nSETSWAP  DS    0H                                                   JOE\n         XR    R1,R1               Undocumented instead of WAIT     JOE\n         SYSEVENT OKSWAP,ENTRY=BRANCH                               JOE\n*                                                                   JOE\nUNLOCK   DS    0H                                                   JOE\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE                    JOE\n*                                                                   JOE\n*                                                                   JOE\n         POST  (R9),ASCB=(R8),ERRET=GOBACK,LINKAGE=BRANCH           JOE\n*                                                                   JOE\nGOBACK   LR    R14,R10               Return Address                 JOE\n         BR    R14                   Return                         JOE\n         LTORG                                                      JOE\nSWAPRTM  DS    0D                                                   JOE\nSWAPLEN  EQU   *-SWAPXMEM                                           JOE\n** ---------------------------------------------------------------- **\n         SPACE\n         TITLE '- MAPPING MACROS.'\n         CVT   DSECT=YES           Map the CVT.\n         IEECHAIN                  Map the CSCB control block.\n         IHASRB                                                     JOE\n         IHAASVT                                                    JOE\n         IHAASCB                                                    JOE\n         IHAASXB                                                    JOE\n         IRAOUCB                                                    JOE\n         IHAPSA   DSECT=YES,LIST=YES                           HD APR88\n         IHAFRRS\n         EJECT                                                 HD APR88\n         IKJEFLWA                                                   JOE\n         END   CNCLPG\n** ---------------------------------------------------------------- **\n*  -----------------------------------------------------------------  *\n*  --           Create PUTLINE environment.                       --  *\n*  -----------------------------------------------------------------  *\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUEMNTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   128                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         IHAPSA   DSECT=YES,LIST=YES                           HD APR88\n         EJECT\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   14,12,12(13)       SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES            RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    1,8(13)            OUR SAVE AREA POINTER\n         ST    13,4(1)            POINTER TO CALLERS SAVE AREA\n         LR    13,1               @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(R13)         POINT TO CALLERS RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 ASSUME BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 ASSUME BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(RML)               MESSAGE LENGTH\n         STH   R15,PUTLEN                 PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    2,R13                    @OUR SAVE AREA\n         LR    3,R15                    SAVE RETURN CODE\n         L     R13,4(R13)               @CALLERS SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,3                    RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CNCLP210": {"ttr": 5635, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1e\\x00\\x03\\x01\\x11)\\x8f\\x01\\x17\\x15\\x0f\\x15!\\x08\\xb1\\x062\\x00\\x00\\xe5\\xf1\\xd9\\xf2\\xd4\\xf1\\xf0@@@'", "ispf": {"version": "01.30", "flags": 0, "createdate": "2011-10-25T00:00:00", "modifydate": "2017-05-30T15:21:03", "lines": 2225, "newlines": 1586, "modlines": 0, "user": "V1R2M10"}, "text": "CNCLPG   TITLE 'Make address space cancelable, non-swappable, etc. '\n*  -----------------------------------------------------------------  *\n*                                                                     *\n*    Function:   To make an address space Cancelable or               *\n*                Non-Cancelable, Forcible or Non-Forcible,            *\n*                Swappable or Non-Swappable.  Or BURN the             *\n*                address space (version 1.2.5).  KILL the             *\n*                address space is same as BURN, but first             *\n*                the non-MEMTERM bits in the ASCB are                 *\n*                turned off (version 1.2.6).                          *\n*                                                                     *\n*                If the address space is non-MEMTERM-able,            *\n*                and you try to BURN it, an error message             *\n*                is issued, and nothing occurs.  But if you           *\n*                try and KILL it, the non-MEMTERM bits are            *\n*                turned off, and the address space is whacked.        *\n*                The message will tell you so.                        *\n*                                                                     *\n*    Authority:  You need PSCB OPER authority to run this             *\n*                command.  To do BURN, KILL, NMEM, and MEMT           *\n*                functions, you ALSO need PSCB ACCOUNT authority.     *\n*                Any function controlled by the KILLFLAG, needs       *\n*                PSCB ACCOUNT authority.                              *\n*                                                                     *\n*  -----------------------------------------------------------------  *\n*                                                                     *\n*    Notes:                                                           *\n*                                                                     *\n*           CANCELABLE, NON-CANCELABLE, FORCIBLE, NON-FORCIBLE:       *\n*                                                                     *\n*    CSCB        Cancelable, Non-cancelable, Forcible, Non-forcible   *\n*    chain       are determined by bit settings in the address        *\n*                space's CSCB, which is part of the CSCB chain.       *\n*                                                                     *\n*    Jobname     Each active address space has a CSCB in the chain.   *\n*    and/or      You get to a particular address space by running     *\n*    ASID        the entire CSCB chain (mapped by the IEECHAIN        *\n*    match       macro) looking for a match on jobname and/or ASID,   *\n*                and preferably on both.                              *\n*                                                                     *\n*    DISPlay     There may be more than one address space for a       *\n*    or          given job name, and more than one CSCB entry         *\n*    \"CSCB\"      for a given ASID.  The CSCB or DISPlay option        *\n*    option      of CNCLPG will run the entire CSCB chain and         *\n*                it will show ALL the matches for the parameters      *\n*                given.  To display the ENTIRE CSCB chain from start  *\n*                to finish, use a dash ( - ) instead of the jobname.  *\n*                                                                     *\n*    Multiple    If only the jobname or the ASID number alone         *\n*    jobs        are used to do an ACTION, then CNCLPG will stop      *\n*    with the    at the FIRST CSCB which matches, when an ACTION is   *\n*    same name   called for (but NOT for a DISPLAY).  That is why     *\n*                it is better to run the DISPlay (or CSCB) function   *\n*                of CNCLPG first, to display all the possible CSCB    *\n*                entries that might match, before changing any        *\n*                particular address space.  There might be more       *\n*                than one address space with the same jobname or      *\n*                ASID, and you want to change only the correct        *\n*                one, NOT the wrong one.  So it is good practice      *\n*                to display first, and then do a change to the        *\n*                exact address space you want to affect, using        *\n*                both the jobname and ASID(hhhh) parameters.          *\n*                                                                     *\n*           SWAPPABLE AND NON-SWAPPABLE:                              *\n*                                                                     *\n*    SWAP and    Setting an address space to be swappable or          *\n*    NSWP need   non-swappable, is accomplished by executing          *\n*    to run a    a SYSEVENT macro.  This has to execute in the        *\n*    SYSEVENT    target address space, and it was done here by        *\n*    macro in    scheduling an SRB to run in the target address       *\n*    the         space, when it is different from the address         *\n*    target      space running the program.  That piece of code       *\n*    address     was written by Joe Reichman.  Thanks, Joe.           *\n*    space       You did the hard part!                               *\n*                                                                     *\n*       NON-MEMTERMABLE AND MEMTERMABLE: (THE REAL \"NON-FORCIBLE\")    *\n*                                                                     *\n*    NMEM makes  In the ASCB of an address space there are two        *\n*    a job both  bits, ASCBNOMT and less importantly, ASCBNOMD.       *\n*    NON-FORCI-  ASCBNOMT controls the attribute, when it is on,      *\n*    BLE and     that the address space is NON-MEMTERMABLE or         *\n*    NON-CANCEL- NON-FORCIBLE.  If NON-CANCELABLE is also true,       *\n*    ABLE.       as well as the non-memtermable bit ASCBNOMT,         *\n*                then if you try and cancel the job, it will say,     *\n*    MEMT makes  NON-CANCELABLE, and if you try and FORCE the         *\n*    the job     job, it will say NON-FORCIBLE.  The two bits         *\n*    FORCIBLE,   ASCBNOMT in the ASCB which has to be on, and         *\n*    but leaves  the cancelable bit in the job's CSCB entry,          *\n*    it to be    CNCL in flag CHACT, which has to be off,             *\n*    NON-CANCEL- control this situation.                              *\n*    ABLE.                                                            *\n*                A job should not be left NON-FORCIBLE and            *\n*                CANCELABLE.  That defeats the purpose of             *\n*                NON-FORCIBLE, in that the job can easily             *\n*                then be cancelled, because CANCEL will work.         *\n*                                                                     *\n*                The action NMEM (non-memtermable) sets both          *\n*                then non-forcible bit in the ASCB on, and the        *\n*                cancelable bit in the job's CSCB entry, off.         *\n*                The action MEMT (make memtermable) turns only        *\n*                the ASCBNOMT bit (non-memtermable) off, but          *\n*                leaves the non-cancelable situation in place.        *\n*                If you want to turn off non-cancelable later,        *\n*                then the CNCL action will do this.                   *\n*                                                                     *\n*    -------------------------------------------------------------    *\n*    BURN        BURN -  Kill the designated address space with a     *\n*    (v 1.2.5)   CALLRTM TYPE=MEMTERM (like a FORCE).  Be careful !   *\n*    -------------------------------------------------------------    *\n*    KILL        KILL -  Kill the designated address space with a     *\n*    (v 1.2.6)   CALLRTM TYPE=MEMTERM (like a FORCE).  Be careful !   *\n*                KILL is a \"super BURN\".  Be VERY careful.....!       *\n*                Before doing the MEMTERM, KILL turns off bits        *\n*                in the ASCB (ASCBNOMT and ASCBNOMD), the             *\n*                \"non-FORCIBLE\" bits.  Can whack any address space.   *\n*    (v 1.2.7)   You need PSCB ACCOUNT authority to run BURN or KILL, *\n*                along with OPER authority to run the rest of the     *\n*                program.                                             *\n*    -------------------------------------------------------------    *\n*    NMEM and    NMEM will make the address space NON-FORCIBLE        *\n*    MEMT        and NON-CANCELABLE.  MEMT will make the address      *\n*    (v 1.2.8)   space FORCIBLE, but it will leave the cancelable     *\n*                bit in place, however it was before.                 *\n*                (Since the FORCE operator command actually equates   *\n*                to a CALLRTM TYPE=MEMTERM macro call, making an      *\n*                address space NON-FORCIBLE is also called making     *\n*                it NON-MEMTERMABLE.                                  *\n*    -------------------------------------------------------------    *\n*    TSWP        Instead of initially making an address nonswappable  *\n*    (v 1.2.9)   using a DONTSWAP function in the SYSEVENT macro,     *\n*                there is now an alternative of doing a TRANSWAP      *\n*                function, which operates on a swappable address      *\n*                space, swaps it out, and then swaps it in, trying    *\n*                to use protected storage frames.  This only works    *\n*                if the address space was swappable to begin with.    *\n*                Otherwise, the TSWP seems to work like an NSWP.      *\n*                IBM recommends TSWP instead of NSWP if the address   *\n*                space is to remain non-swappable for a long time.    *\n*                                                                     *\n*                NUMBER OF DONTSWAP REQUESTS - OUCBNDS field of the   *\n*                        OUCB control block (macro IRAOUCB)           *\n*                Each NSWP or TSWP request increments this number     *\n*                by one.  An address space cannot be made swappable   *\n*                until this number is reduced to one, and a           *\n*                SYSEVENT OKSWAP is issued.  If the number is more    *\n*                than one, then each successive SYSEVENT OKSWAP       *\n*                against the address space, decrements this number    *\n*                by one.  NSWP, TSWP, and SWAP requests now display   *\n*                this number.                                         *\n*    -------------------------------------------------------------    *\n*    FSWP        If several users issued DONTSWAP requests against    *\n*    (v 1.2.10)  the same address space, then the OUCBNDS field,      *\n*                which is a halfword number, contains a quantity      *\n*                that is more than X'0001'.  To make that address     *\n*                space swappable, you would have to issue that        *\n*                number of SYSEVENT OKSWAP requests.  Each OKSWAP     *\n*                request reduces the number by one.  FSWP (Forced     *\n*                SWAP) first sets this number to X'0001' and then     *\n*                issues a SYSEVENT OKSWAP.  So you can be sure to     *\n*                make that address swappable right away, with ONE     *\n*                action, and not many.                                *\n*    -------------------------------------------------------------    *\n*    Syntax:     TSO Command:  APF-authorized.                        *\n*                                                                     *\n*        CNCLPG |jobid \u00ddASID(hhhh)\u00a8 |CNCL|NCNC (cancelable, non-canc) *\n*               |ASID(hhhh)         |FORC    (force w/o cancel)       *\n*               |                   |NFRC    (force needs cancel)     *\n*               |                   |NSWP|SWAP (non-swap, swappable)  *\n*               |                   |TSWP (transwap)                  *\n*               |                   |FSWP (force swappable immediate) *\n*               |                   |CSCB or DISP (display CSCB blks) *\n*               |                   |BURN (memterm the address space) *\n*               |                   |KILL (memterm after turning      *\n*               |                   |      off non-memtermable bits)  *\n*               |                   |NMEM|MEMT  (turn on/off          *\n*               |                   |        non-memtermable bits)    *\n*               |-  (displays the entire CSCB chain)                  *\n*               |?  (displays help)                                   *\n*                                                                     *\n*    Date:       April 15, 2010                                       *\n*                                                                     *\n*    Latest Modification:   May 30, 2017                              *\n*                                                                     *\n*    Authors:    Sam Golob, Joe Reichman (who did the hard part)      *\n*                                                                     *\n*    Technical Detail:  PUTLINE interface for TSO Output.             *\n*                       Uses the APUT macro, and EPUTL module.        *\n*                                                                     *\n*    Changes:  1.  SWAP, NSWP support dropped from this program       *\n*                   initially.  Version is 1.0.0.                     *\n*                                                                     *\n*              2.  Messages and DISP improved, to just show matching  *\n*                   CSCB chain entries, instead of all of them.       *\n*                   Coding a dash instead of a jobname or asid(hhhh)  *\n*                   - will display the entire CSCB chain.             *\n*                                                                     *\n*              3.  SWAP, NSWP support put back in this program.       *\n*                   Version is 1.1.0   (June 16, 2010)                *\n*                   It now does your own address space.  The cross    *\n*                   memory stuff was not put in yet, to make other    *\n*                   address spaces swappable, or non-swappable.       *\n*                                                                     *\n*              4.  Complete SWAP, NSWP support for cross address      *\n*                   space communication, was put in by Joe            *\n*                   Reichman.  (Oct 2011)  Version is 1.2.0.          *\n*                                                                     *\n*              5.  Burn an address space, if that is desired.         *\n*                   (Oct 2012)  Version is 1.2.5.                     *\n*                                                                     *\n*              6.  Kill an address space.  Before you do the          *\n*                  CALLRTM MEMTERM, the non-forcible flags in the     *\n*                  ASCB are turned off.                               *\n*                   (May 2017)  Version is 1.2.6.                     *\n*                                                                     *\n*              7.  Authority checking. So far, you need PSCB OPER     *\n*                   to do anything. ACCT to do BURN or KILL.          *\n*                   Version is 1.2.7.                                 *\n*                                                                     *\n*              8.  Make address space Non-Memtermable (can't be       *\n*                   FORCEd), or Memtermable (can be FORCEd).          *\n*                   Non-Memtermable implies Non-Cancelable, because   *\n*                   it isn't effective if the address space is        *\n*                   Cancelable but non-Memtermable).  You can easily  *\n*                   get rid of it, and it defeats the purpose of      *\n*                   non-Memtermable.  If you later make it            *\n*                   Memtermable, you can make it Cancelable next.     *\n*                                                                     *\n*              9.  Add TSWP function to do a TRANSWAP instead of      *\n*                   a DONTSWAP.  It really is only good if you do     *\n*                   it the first time, on an initially swappable      *\n*                   address space.                                    *\n*                                                                     *\n*             10.  Added display of the OUCBNDS field (halfword),     *\n*                   which is the number of outstanding DONTSWAP       *\n*                   requests.  The address space cannot become        *\n*                   swappable until this number is reduced to 1,      *\n*                   and an OKSWAP is done.                            *\n*                                                                     *\n*             11.  SRB was modified to run in 31-bit mode (from Joe). *\n*                                                                     *\n*             12.  Added Forced SWAP option to make the address       *\n*                   space swappable even though there are a number    *\n*                   of DONTSWAP requests still against it.  One       *\n*                   application of this is if you want to TRANSWAP    *\n*                   the address space.  First you FSWP it to ensure   *\n*                   that it is swappable, and then you TSWP it to     *\n*                   do the TRANSWAP.                                  *\n*                                                                     *\n*                                                                     *\n*   Change   Pgmr                   Description                       *\n*   -------  -----   ----------------------------------------------   *\n*                                                                     *\n*            JOER     Add SRB code to allow swapping in xmem.         *\n*                     (See lines commented with JOE.)                 *\n*                                                                     *\n*  -----------------------------------------------------------------  *\n*\n*  This macro lets you display hex values in a report.\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    STM   R15,R1,HEXSAVE           Save work registers.\n         LA    R1,&FROM                 Load from address.\n         LA    R0,&LEN                  Load length of hex number.\n         LA    R15,&TO                  Load to address.\n         BAL   R9,HEX                   BAL to routine.\n         LM    R15,R1,HEXSAVE           Restore work registers.\n         MEND\n*  -----------------------------------------------------------------  *\n*  --           Create PUTLINE environment.                       --  *\n*  -----------------------------------------------------------------  *\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP THE PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\n* --       End of Internal Macros......                            -- *\n* ------------------------------------------------------------------- *\n         SPACE 3\n* ------------------------------------------------------------------- *\n*   The CSCB chain of control blocks is above the line, so you need   *\n*    to have AMODE 31.                                                *\n* ------------------------------------------------------------------- *\nCNCLPG   CSECT\nCNCLPG   AMODE 31\nCNCLPG   RMODE ANY\n         YREGS\n         USING CNCLPG,R15          (Establish temporary base).\n         B     BEGIN               Skip over eyecatcher.\nEYEC0    DC    AL1(EYECL)          Exclusive length of header.\nEYEC     DC    C' CNCLPG - &SYSDATE - &SYSTIME -'\n         DC    C'     --------------------------------    '\n         DC    C' VER 1.2.10  '\n         DC    C'                   '\nEYECL    EQU   *-EYEC\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)     Save caller's registers\n         LR    R6,R1               Preserve CPPL pointer.\n         LR    R12,R15             Copy base.\n         USING CNCLPG,R12,R11,R10  (Tell assembler).\n         LA    R11,4095(,R12)      Load bases.\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)\n         LA    R10,1(,R10)\n         LR    R14,R13             Copy caller's save area pointer.\n         LA    R13,SAVE            Point to my save area.\n         ST    R13,8(,R14)         Chain ...\n         ST    R14,SAVE+4          ... Save areas.\n*                                  Get PSCBATR1 byte and copy it\n         ST    R1,SAVER1A          Save work register\n         L     R1,16               CVTPTR\n         L     R1,0(,R1)           TCB words\n         L     R1,4(,R1)           Current TCB\n         L     R1,180(,R1)         TCBJSCB\n         L     R1,264(,R1)         JSCBPSCB\n         LA    R1,0(,R1)           Clear hi order byte\n         LTR   R1,R1               Is there a PSCB ?\n         BZ    NOTFOUND            No, Issue COMMAND-NOT-FOUND msg\n         MVI   FLAG0,X'00'         Zero FLAG0 for safety\n         MVC   FLAG0(1),X'10'(R1)  Overlay it with PSCBATR1\n         L     R1,SAVER1A          Restore work register\nAUTHTEST DS    0H\n         TM    FLAG0,X'80'         PSCB OPER AUTHORITY?\n         BZ    NOTFOUND            No, Issue COMMAND-NOT-FOUND msg\nINITCON  DS    0H                  Initialize some constants.\n         MVI   FLAG1,X'00'\n         MVI   FLAG2,X'00'\n         MVI   FLAG3,X'00'\n         MVI   ONSWIT,X'00'\n         MVI   RTMCOD,X'00'\n         MVC   SRBNDS,=H'0'\n         MVC   KEY0NDS,=H'0'\n         MVI   ERRASID,X'00'\n         MVI   CANCINDC,X'00'\n         MVI   KILLFLAG,X'00'\n         MVI   OUTPUT-1,X'40'\n         MVC   OUTPUT,OUTPUT-1\n         MVI   NEWCHACT,X'00'\nMYASID   DS    0H                  Get my ASID\n         L     R2,X'224'           Point to PSAAOLD (my ASCB)\n         LA    R2,X'24'(,R2)       Point to my own ASID (ASCBASID)\n         MVC   OWNASID(2),0(R2)    Save it for comparison later\n         B     PRTITLE             Branch past constant\nOWNASID  DS    H\nPRTITLE  DS    0H                  Print program title.\n         APUT  MESSAGET,L'MESSAGET\n         APUT  MESSAGEU,L'MESSAGEU\nCONT0    DS    0H                  Look at command's parameters.\n         LTR   R6,R6               Any CPPL?\n         BZ    EOJ8                No.  Get out.\n         L     R1,0(,R6)           Pt to cmd buffer. (R6 reused later)\n         LTR   R1,R1               Any CMD buffer?\n         BZ    EOJ8                Get out if none.\n         LH    R3,0(,R1)           Load length.\n         CH    R3,=H'4'            Anything?\n         BNH   EOJ4                No. Get out.\n         LR    R5,R3               Length of command + 4\n         ICM   R5,14,FULLZERO      Clear hi order 3 bytes.\n         LH    R3,2(,R1)           Load offset.\n         SR    R5,R3               Subtract offset from full length+4\n         SH    R5,=H'4'            Correct for length of cmdbufr header\n         BC    8,WMESS2            Zero, message to enter userid.\n         BC    5,EOJ8              Less, or overflow, out.\nPARM     DS    0H\n         BAL   R9,GETIDS           Get parameters for the command.\n*                                  All the processing hooks off here.\n         B     EOJ0\n** ---------------------------------------------------------------- **\nWMESS2   DS    0H                  Print help messages.\n         BAL   R9,PRINTERR\n         B     EOJ4\n** ---------------------------------------------------------------- **\nEOJ0     DS    0H                  End of job.\n         APUT  RETURN0,L'RETURN0\n         LA    R15,0               Set CC = 0.\n         B     RETURN\nEOJ4     DS    0H\n         APUT  RETURN4,L'RETURN4\n         LA    R15,4               Set CC = 4.\n         B     RETURN\nEOJ8     DS    0H\n         APUT  RETURN8,L'RETURN8\n         LA    R15,8               Set CC = 8.\n         B     RETURN\nRETURN   L     R13,SAVE+4\n         L     R14,12(,R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n** ---------------------------------------------------------------- **\nNOTAUTH  DS    0H                  Command not APF authorized message.\n         APUT  MESSAGNA,L'MESSAGNA\n         B     EOJ4\n** ---------------------------------------------------------------- **\nNOTFOUND DS    0H                  Fake command not found message.\n         APUT  MESSAGAU,L'MESSAGAU\n         B     RETURN\n** ---------------------------------------------------------------- **\nNOTALLOW DS    0H                  Command NOT ALLOWED message.\n         APUT  MESSAGAT,L'MESSAGAT\n         B     RETURN\n** ---------------------------------------------------------------- **\nNOTMEMTM DS    0H                  Address space not MEMTERM-able.\n         MVC   MESSAGNM+4(8),FOUNJOBI    Jobname into message\n         HEX   MESSAGNM+22,2,FOUNASID    ASID into message\n         APUT  MESSAGNM,L'MESSAGNM       Say job Not-Memterm-able\n         APUT  MESSAGEL,L'MESSAGEL         and not burned,\n         APUT  MESSAGFL,L'MESSAGFL\n         BAL   R9,FORCHACT                 But show final status.\n         B     RETURN\n** ---------------------------------------------------------------- **\n* ---           Everything after here is subroutines.            --- *\n** ---------------------------------------------------------------- **\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                Get the parameters for the command.              *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*   Notes:  The ASID(xxx) can be coded first, without a userid.   *\n*           A dash can be coded first, to run the entire CSCB     *\n*            chain and display all the jobnames in it, with       *\n*            their associated ASIDs.  ? coded first gives HELP.   *\n*           If you code the word CSCB or DISP(lay) after either   *\n*            a jobname or an ASID(hhhh) then a display of ALL     *\n*            matching CSCB chain entries will be displayed, and   *\n*            no changes will be made.                             *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETIDS   DS    0H                  Get all parameters for the program.\n         ST    R9,SAVER9A\n         ST    R4,SAVER4C\n         AR    R1,R3               Point ...\n         LA    R1,4(,R1)           ... to char.\n         LA    R6,8                Load reg for BCT loop.\n         LR    R7,R1               Initialize pointer to first\n         LA    R7,0(,R7)                character of the ID field.\n         LA    R8,0                Initialize character count.\n         MVC   JOBID(8),BLANKS     Clear (first param - JOBNAME) field.\n         LA    R4,JOBID            Point reg to beginng of JOBID field.\n*\nCUTIDLEN DS    0H                  Look at the JOBID field first.\n*                                  (May contain ASID( or CSCB.)\n*\n         CLI   0(R7),X'40'         Is this character a blank?\n         BE    NOMORCUT            Yes, we are at the end of the field.\n         MVC   0(1,R4),0(R7)       Move only one character at a time.\n         OC    JOBID(8),BLANKS     And uppercase the partial jobid.\n*\n*   Is this a run of the CSCB chain only?\n* -- >  Test for CSCB  first  ---- below\n         CLI   JOBID,C'-'          Did we code '-' first?\n         BNE   CSCBHELP            No. Try if help asked for.\n         B     CSCBRUN1            Yes. Run entire CSCB chain.\n* - > Help\nCSCBHELP DS    0H\n         CLI   JOBID,C'?'          Help?\n         BNE   NOCSCB              No. Skip this code.\n         BAL   R9,PRINTERR         Yes. Print messages\n         B     EOJ0                  and get out with code 0.\n* - > Help\nCSCBRUN1 DS    0H\n         ST    R8,SAVER8A          Store count for display if needed.\n         OI    FLAG2,X'40'         Mark that this is CSCB only run.\n         BAL   R9,RUNCSCB          Do the run for CSCB chain.\n         B     EOJ0                Out with normal return code.\nNOCSCB   DS    0H\n* -- >  Test for CSCB  first  ---- above\n*\n*   Was the ASCB(hhh) parameter coded without the jobid?\n* -- >  Test for ASID( first  ---- below\n         CLC   JOBID(L'ASIDC),ASIDC  Did we code ASID( in jobid field?\n         BNE   NOASIDF             No. Pass this code.\n         OI    FLAG1,X'01'         Flag that ASID( ) was first.\n         NI    FLAG1,X'FF'-X'02'   Turn off Jobname in jobid field flag\n         MVC   ASIDWKL(L'ASIDC),JOBID  Move the ASID( to proper field.\n         MVC   JOBID,BLANKS        Blank out Job ID if ASID( coded.\n         LA    R7,1(,R7)           Bump another character.\n         LA    R8,1(,R8)           Count another character.\n         LA    R6,1                Set number of branches later.\n*                                  This will limit number of params\n*                                   that are searched for.\n         B     ASIDONLY            Bypass all the real jobname stuff.\n* -- >  Test for ASID( first  ---- above\nNOASIDF  DS    0H                  ASID( is not the first parameter.\n         LA    R4,1(,R4)           Bump another character.\n         LA    R7,1(,R7)           Bump another character.\n         LA    R8,1(,R8)           Count another character.\n         CR    R8,R5               End of command buffer ?\n         BNL   NOMORCUT            Yes. Get out now.\n         BCT   R6,CUTIDLEN         Try for the next blank, up till 8.\nNOMORCUT DS    0H\n         STC   R8,SAVCOUNT         Save length of Jobname\n         L     R4,SAVER4C          Restore work register for use later.\n         OC    JOBID(8),BLANKS     Uppercase the new Job Id.\n         OI    FLAG1,X'02'         Set 'Jobname Coded' flag.\n*  -  Display the found JOBID - below\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Search Jobname:'\n         MVC   OUTPUT+17(8),JOBID\n         APUT  OUTPUT,30\n         APUT  MESSAGEL,L'MESSAGEL\n*  -  Display the found JOBID - above\n         LA    R6,1                Set number of branches later.\n*                                  This will limit number of params\n*                                   that are searched for.\n         B     LOOKKEYW\n*  Constants - below - ***\nJOBID    DC    C'        '         STORE PARM USERID HERE\nBLANKS   DC    C'        '         8 BLANKS\nMESSAGET DC   C'CNCLPG 1.2.10 - Make a Job, STC or TSU Cancelable, etc.X\n                (? for help)'\nMESSAGEU DC  C'------ ------ - ---- - ---- --- -- --- ----------- ----'\nMESSAGEL DC    C'----------------------------'\nMESSAGEM DC    C'-----------------------------------------------'\nMESSAG2A DC    C'Enter JOBNAME and/or ASID(hhhh) after COMMAND name,'\nMESSAG2B DC    C'   then CNCL, NCNC, FORC, NFRC, NSWP, or SWAP. '\nMESSAG2V DC    C'To get rid of the address space, code BURN or KILL.'\nMESSAG2U DC    C'Or code CSCB or DISP to just display CSCB entries.'\nMESSAG2C DC    C'   DISPlay or CSCB will display CSCB chain entries,'\nMESSAG2D DC    C'   without changing them.'\nMESSAG2E DC    C' When affecting a job, we want to be accurate, '\nMESSAG2F DC    C'  therefore you should use the DISPlay option first.'\nMESSAG2G DC   C' To display the whole CSCB, code - (dash) for JOBNAME.'\nMESSAG2H DC    C' To see this help message, code ? for JOBNAME.'\nMESSAG2I DC    C'Notes (important) : '\nMESSAG2J DC   C' CSCB (DISP) display for an ASID shows all occurrences'\nMESSAG2K DC    C'  for that ASID, regardless of JOBNAME.      '\nMESSAG2L DC C' CSCB (DISP) display for a JOBNAME shows all occurrences'\nMESSAG2M DC    C'  for that JOBNAME, regardless of ASID.      '\nMESSAG2N DC    C' CNCL, NCNC, FORC, NFRC, NSWP, SWAP changes the FIRST'\nMESSAG2O DC    C'  entry in the CSCB chain that matches, if multiple '\nMESSAG2P DC    C'  entries exist. But DISP will display ALL applicable'\nMESSAG2Q DC    C'  matching entries in the CSCB chain, so you can see'\nMESSAG2R DC    C'  which one you want to change specifically.'\nMESSAG2S DC    C' When you code BOTH jobname and asid, to CHANGE it,'\nMESSAG2T DC    C'  then ONLY that specific job and asid gets changed.'\nMESSAGE3 DC    C'WE GOT HERE'\nMESSAGE4 DC    C'TEST CHECK THIS'\nMESSAGNG DC    C'Job was not done. SYSEVENT return code was     '\nMESSAGNS DC    C'Job xxxxxxxx for ASID HHHH made non-swappable.'\nMESSAGTS DC    C'Job xxxxxxxx for ASID HHHH was trans-swppped.'\nMESSAGSW DC    C'Job xxxxxxxx for ASID HHHH was made swappable.'\nMESSAGSY DC C'  Job xxxxxxxx for ASID HHHH was not made swappable yet.'\nMESSAGAN DC    C'Job xxxxxxxx for ASID HHHH already non-swappable.'\nMESSAGAS DC    C'Job xxxxxxxx for ASID HHHH was already swappable.'\nMESSAGFN DC    C'Function xxxx was called for.'\nMESSAGBU DC    C'Job xxxxxxxx for ASID HHHH has been burned.'\nMESSAGKI DC    C'Job xxxxxxxx for ASID HHHH has been killed.'\nMESSAGAU DC    C'IKJ56500I COMMAND CNCLPG NOT FOUND'\nMESSAGAT DC    C'Lacking authority to execute this command.'\nMESSAGNM DC    C'Job xxxxxxxx for ASID HHHH not MEMTERM-able. Not burnex\n               d.'\nMESSAGM1 DC    C'Job xxxxxxxx for ASID HHHH made non-memtermable.'\nMESSAGM2 DC    C'Job xxxxxxxx for ASID HHHH was made memtermable.'\nMESSAGFL DC    C'Final Job Status Report.'\nRETURN0  DC    C'Return code is 0'\nRETURN4  DC    C'Return code is 4'\nRETURN8  DC    C'Return code is 8'\n*                     ***  Places to save registers  ***  below\nSAVER1A  DS    F\nSAVER3A  DS    F\nSAVER3B  DS    F\nSAVER3C  DS    F\nSAVER3D  DS    F\nSAVER3E  DS    F\nSAVER3F  DS    F\nSAVER4A  DS    F\nSAVER4B  DS    F\nSAVER4C  DS    F\nSAVER4D  DS    F\nSAVER5A  DS    F\nSAVER6A  DS    F\nSAVER6B  DS    F\nSAVER7A  DS    F\nSAVER7B  DS    F\nSAVER8A  DS    F\nSAVER9A  DS    F\nSAVER9B  DS    F\nSAVER9C  DS    F\nSAVER9D  DS    F\nSAVER9E  DS    F\nSAVER9F  DS    F\nSAVER9G  DS    F\nSAVER9H  DS    F\nSAVER9I  DS    F\nSAVER9J  DS    F\nSAVER9K  DS    F\nSAVER9L  DS    F\nSAVER9M  DS    F\nSAVER9N  DS    F\n*                     ***  Places to save registers  ***  above\nSAVCOUNT DS    X\nKILLFLAG DS    X\n*              X'01'               KILL indicated\n*              X'02'               BURN indicated  X'01' also on\n*              X'04'               NMEM indicated\n*              X'08'               MEMT indicated\nDUBLZERO DC    D'0'\nFULLZERO DC    F'0'\nCANCINDC DC    X'00'\nCANCKEY0 DC    X'00'\nNEWCHACT DC    X'00'\n*  Constants - above - ***\nLOOKKEYW DS    0H                  Look for additional keywords.\n         LA    R7,1(,R7)           Bump command buffer pointer.\n         LA    R8,1(,R8)           Bump character counter.\n         CR    R8,R5               End of command buffer?\n         BNL   GETIDEND            Yes. Don't look any more.\n         MVC   ASIDWKL(5),BLANKS   Clear parameter work field.\n         MVC   ASIDWKL(5),0(R7)    Next 5 characters to work field.\nASIDONLY DS    0H                  Jump to here if ASID( coded first.\n         OC    ASIDWKL(4),BLANKS   Uppercase work field.\n         CLC   ASIDC,ASIDWKL       Is the ASID( keyword there?\n         BE    DOASID              Yes. Process it.\n         CLC   CNCLC,ASIDWKL       Is the CNCL  keyword there?\n         BE    DOCNCL              Yes. Process it.\n         CLC   NCNCC,ASIDWKL       Is the NCNC  keyword there?\n         BE    DONCNC              Yes. Process it.\n         CLC   SWAPC,ASIDWKL       Is the SWAP  keyword there?\n         BE    DOSWAP              Yes. Process it.\n         CLC   NSWPC,ASIDWKL       Is the NSWP  keyword there?\n         BE    DONSWP              Yes. Process it.\n         CLC   TSWPC,ASIDWKL       Is the TSWP  keyword there?\n         BE    DOTSWP              Yes. Process it.\n         CLC   FSWPC,ASIDWKL       Is the FSWP  keyword there?\n         BE    DOFSWP              Yes. Process it.\n         CLC   FORCC,ASIDWKL       Is the FORC  keyword there?\n         BE    DOFORC              Yes. Process it.\n         CLC   NFRCC,ASIDWKL       Is the NFRC  keyword there?\n         BE    DONFRC              Yes. Process it.\n         CLC   CSCBC,ASIDWKL       Is the CSCB  keyword there?\n         BE    DOCSCB              Yes. Process it.\n         CLC   DISPC,ASIDWKL       Is the DISP  keyword there?\n         BE    DOCSCB              Yes. Process it.\n         CLC   BURNC,ASIDWKL       Is the BURN  keyword there?      BUR\n         BE    DOBURN              Yes. Process it.                 BUR\n         CLC   KILLC,ASIDWKL       Is the KILL  keyword there?      KIL\n         BE    DOKILL              Yes. Process it.                 KIL\n         CLC   NMEMC,ASIDWKL       Is the NMEM  keyword there?\n         BE    DONMEM              Yes. Process it.\n         CLC   MEMTC,ASIDWKL       Is the MEMT  keyword there?\n         BE    DOMEMT              Yes. Process it.\n         B     LOOKKEYW            Go loop and look at next character.\nASIDWKL  DC    CL5' '              Second parameter work area.\n*\nASIDC    DC    C'ASID('            Literals....\nCNCLC    DC    C'CNCL'\nNCNCC    DC    C'NCNC'\nSWAPC    DC    C'SWAP'\nNSWPC    DC    C'NSWP'\nTSWPC    DC    C'TSWP'\nFSWPC    DC    C'FSWP'\nFORCC    DC    C'FORC'\nNFRCC    DC    C'NFRC'\nCSCBC    DC    C'CSCB'\nDISPC    DC    C'DISP'\nBURNC    DC    C'BURN'\nKILLC    DC    C'KILL'\nNMEMC    DC    C'NMEM'\nMEMTC    DC    C'MEMT'\n*\nDOASID   DS    0H                  Look for hex value of the ASID.\n         OI    FLAG1,X'04'         Show that ASID( was coded.\n         BAL   R9,GETASID          Go get the rest of the parameters.\n         MVC   ASIDWKL(5),BLANKS   Blank out the second wkarea for\n*                                   a further parameter search.\n         B     LOOKKEYW            Re-loop to look further for params.\n*\nDOCNCL   DS    0H                  Handle CNCL (cancelable) keyword.\n         OI    CANCINDC,X'08'      Show which CHACT bit is affected.\n         OI    FLAG2,X'01'         Show that CNCL was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'01'        Set to OR the bits\n         NI    ONSWIT,X'FF'-X'02'   and not to AND the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n* ------------------------------------------------------------------- *\n*                                    Print the action code.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),CNCLC\n         APUT  OUTPUT,25\n*                                    Print the bit in CHACT affected.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDONCNC   DS    0H                  Handle NCNC (non-cancelable) keyword\n         OI    CANCINDC,X'08'      Show which CHACT bit is affected.\n         OI    FLAG2,X'02'         Show that NCNC was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'02'        Set to AND the bits\n         NI    ONSWIT,X'FF'-X'01'   and not to OR the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n*                                    Print the action code.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),NCNCC\n         APUT  OUTPUT,25\n*                                    Print the bit in CHACT affected.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDOFSWP   DS    0H\n         OI    FLAG3,X'02'         Indicate FSWP instead of SWAP.\nDOSWAP   DS    0H                  Now this routine is operational.\n         OI    FLAG2,X'04'         Show that SWAP was coded.\n         TM    FLAG3,X'02'         Was Forced SWAP indicated?\n         BO    DOMSGFSW            Show that FSWP was coded.\n         MVC   MESSAGFN+9(4),SWAPC   Write message to say SWAP.\n         B     DOMSGPRT\nDOMSGFSW MVC   MESSAGFN+9(4),FSWPC   Write message to say FSWP.\nDOMSGPRT DS    0H\n         APUT  MESSAGFN,L'MESSAGFN\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         BAL   R9,KEY0SWNS         Do SYSEVENT OKSWAP, xmem or not.\n         BCT   R6,LOOKKEYW\n         B     GETIDEND\n* ------------------------------------------------------------------- *\nDONSWP   DS    0H                  Now this routine is operational.\n         OI    FLAG2,X'08'         Show that NSWP was coded.\n         MVC   MESSAGFN+9(4),NSWPC   Write message to say that.\n         APUT  MESSAGFN,L'MESSAGFN\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         BAL   R9,KEY0SWNS         Do SYSEVENT DONTSWAP, xmem or not.\n         BCT   R6,LOOKKEYW\n         B     GETIDEND\n* ------------------------------------------------------------------- *\nDOTSWP   DS    0H                  Now this routine is operational.\n         OI    FLAG2,X'08'         Show that NSWP was coded.\n         OI    FLAG3,X'01'         Show that TSWP was coded.\n         MVC   MESSAGFN+9(4),TSWPC   Write message to say that.\n         APUT  MESSAGFN,L'MESSAGFN\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         BAL   R9,KEY0SWNS         Do SYSEVENT TRANSWAP, xmem or not.\n         BCT   R6,LOOKKEYW\n         B     GETIDEND\n* ------------------------------------------------------------------- *\nDOFORC   DS    0H                  Handle FORC (forcible) keyword\n         OI    FLAG2,X'10'         Show which CHACT bit is affected.\n         OI    CANCINDC,X'01'      Show that FORC was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'01'        Set to OR the bits\n         NI    ONSWIT,X'FF'-X'02'   and not to AND the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n*\n         MVC   OUTPUT,OUTPUT-1       Print the action code.\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),FORCC\n         APUT  OUTPUT,25\n*\n         MVC   OUTPUT,OUTPUT-1       Print the bit in CHACT affected.\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDONFRC   DS    0H                  Handle NFRC (non-forcible) keyword\n         OI    FLAG2,X'20'         Show which CHACT bit is affected.\n         OI    CANCINDC,X'01'      Show that NFRC was coded.\n         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.\n         OI    ONSWIT,X'02'        Set to AND the bits\n         NI    ONSWIT,X'FF'-X'01'   and not to OR the bits.\n         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.\n         BAL   R9,PRNWCSCB         Print the info from the current CSCB\n         BAL   R9,FORCHACT         Format the relevant CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline.\n*\n         MVC   OUTPUT,OUTPUT-1       Print the action code.\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),NFRCC\n         APUT  OUTPUT,25\n*\n         MVC   OUTPUT,OUTPUT-1       Print the bit in CHACT affected.\n         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'\n         HEX   OUTPUT+25,1,CANCINDC\n         APUT  OUTPUT,30\n*\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nDOCSCB   DS    0H\n         OI    FLAG1,X'08'         Show CSCB keyword was coded.\n         OI    FLAG2,X'40'         Show CSCB keyword was coded.\n         MVC   OUTPUT,OUTPUT-1       Print the action code.\n         MVC   OUTPUT(15),=C'Action code   :'\n         MVC   OUTPUT+17(4),CSCBC\n         MVC   OUTPUT+23(9),=C'(DISPlay)'\n         APUT  OUTPUT,35\n         BAL   R9,RUNCSCB          Run the CSCB chain with print.\n         BCT   R6,LOOKKEYW         Look for another keyword.\n         B     GETIDEND            After enough looks, end.\n* ------------------------------------------------------------------- *\nGETIDEND DS    0H                  End of keyword processing.\n         TM    FLAG2,X'FF'         Check if any real actions asked  BUR\n         BNZ   GETKEYNR            Yes, some were.\n         APUT  MESSAGEY,L'MESSAGEY    No. Display help messages.\n         BAL   R9,PRINTERR\n         B     EOJ4                   And end with code = 4.\nGETKEYNR DS    0H                  Real actions WERE asked for.\n         TM    KILLFLAG,X'FF'      Any of the KILLFLAG options on?\n         BZ    SKPKEYNR            No, no extra printout.\n         TM    KILLFLAG,X'03'      If kill, then don't need status.\n         BNZ   SKPKEYNR\nGETKEYNS DS    0H                  Real actions WERE asked for.\n         APUT  MESSAGEL,L'MESSAGEL\n         APUT  MESSAGFL,L'MESSAGFL\n         BAL   R9,FORCHACT         Show summary after actions.\nSKPKEYNR DS    0H                  Real actions WERE asked for.\n         B     EOJ0                So end with normal return code.\n         L     R9,SAVER9A\n         BR    R9\n** ---------------------------------------------------------------- **\nHEX      DS    0H                  Display hex values.\n         ST    R9,SAVER9B\n         MVC   1(1,R15),0(R1)      Move byte.\n         UNPK  0(3,R15),1(2,R15)   Unpack.\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)         Increment output pointer.\n         LA    R1,1(,R1)           Increment input pointer.\n         BCT   R0,HEX              Decrement length, then loop.\n         MVI   0(R15),C' '         Blank the trailing byte.\n         L     R9,SAVER9B\n         BR    R9                  Return to caller.\nHEXTAB   DC    C'0123456789ABCDEF' Translate table.\n** ---------------------------------------------------------------- **\nGETASID  DS    0H                  Get hex ASID for 2 bytes.\n         ST    R9,SAVER9C          Save registers.\n         STM   R1,R6,SAVERGS1\n         LA    R6,4                Load BCT register.\n         LA    R4,ASIDWK           Point to ASID work area.\n         TM    FLAG1,X'02'         Ask if Job name was coded.\n         BZ    GETAFL01            Wasn't. Have to adjust pointers.\n         LA    R7,5(,R7)           Bump command buffer pointer.\n         LA    R8,5(,R8)           Bump character counter.\nGETAFL01 DS    0H\nGETASIDL DS    0H                  Loop to get hex ASID for 4 display\n*                                    bytes to convert to 2 hex bytes.\n         CLI   0(R7),C')'          Have we reached close parenthesis?\n         BE    GETASIDG            Yes, assume we've got it.\n         CLI   0(R7),C' '          Have we hit a blank?\n         BE    GETASIDG            Yes, assume we've got it.\n         MVC   0(1,R4),0(R7)       Otherwise move one character over.\n         LA    R4,1(,R4)           Bump one ASIDWK character (target)\n         LA    R7,1(,R7)           Bump command buffer pointer.\n         LA    R8,1(,R8)           Bump character counter.\n         BCT   R6,GETASIDL         Loop for 4 characters.\n         B     GETASIDG            We don't look for more than 4.\nGETASIDG DS    0H\n*        APUT  ASIDWK,4\n         LA    R4,ASIDWK           Point register at workarea again.\n         LA    R1,4                Maximum of 4 characters.\nGETASIDA DS    0H\n         CLI   3(R4),X'40'         Is last character a blank (<4 total)\n         BNE   GETASIDM            No. We're finished sliding.\n         BCTR  R4,0                Slide the pointer one place back.\n         BCT   R1,GETASIDA         Do it no more than 4 times.\nGETASIDM DS    0H\n         MVC   ASIDMV(4),0(R4)     Move 4 characters so last one\n*                                     is not blank.\n         MVC   ASIDWKSV(4),ASIDMV    Save these 4 characters\n         MVC   ASIDWKS(4),ASIDMV        in two places.\n         MVC   OUTPUT,OUTPUT-1       Clear output line.\n         MVC   OUTPUT(25),ASIDMSG    Move coded display format asid.\n         APUT  OUTPUT,40             And put out the message.\n         TR    ASIDMV(4),ASIDVAL     Translate display format message\n*                                      into format X'0h0h0h0h'.\n*        MVC   OUTPUT,OUTPUT-1       Test display of hex result.\n*        HEX   OUTPUT,4,ASIDMV\n*        APUT  OUTPUT,10\n         BAL   R9,VALIDTR            Validity check the hex number.\n         PACK  ASIDGET(3),ASIDMV(5)  Get rid of all zone nibbles.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(15),=C'Search ASID   :' Print resulting 2-bytes\n         HEX   OUTPUT+21,2,ASIDBIN\n         APUT  OUTPUT,30\n         APUT  MESSAGEL,L'MESSAGEL   Add underline for clear display.\n*\nGETASIDE DS    0H                    End of routine.\n         LM    R1,R6,SAVERGS1        Restore registers\n         L     R9,SAVER9C               and\n         BR    R9                          exit.\n** ---------------------------------------------------------------- **\nASIDWKB  DC    CL4'    '\nASIDWK   DC    CL4'    '\nASIDWKF  DC    CL4' '\nASIDMV   DC    CL4'    '\nASIDMVF  DC    CL4' '\nASIDBIN  DS    0XL2\nASIDGET  DC    XL4'00000000'\nSAVERGS1 DS    6F\n** ---------------------------------------------------------------- JOE\n*   GETASCB - return ASCB, given the asid of address space          JOE\n*   -------                                                         JOE\n*  Input:                                                           JOE\n*      FOUNASID = ASID                                              JOE\n*  Output:                                                          JOE\n*      r15 = 0    Error                                             JOE\n*      R15 = ASCB                                                   JOE\n** ---------------------------------------------------------------- JOE\nGETASCB  DS    0H                                                   JOE\n         ST    R9,SAVER9M            Save Register                  JOE\n         L     R15,CVTPTR            R15 -> cvt                     JOE\n         L     R15,CVTASVT-CVT(,R15)  R15 -> asvt                   JOE\n         USING ASVT,R15                                             JOE\n         CLC   ASVTASVT-ASVT(4,R15),=C'ASVT'  check eyecatcher      JOE\n         BNE   NOASCB                                               JOE\n         LA    R15,ASVTENTY-ASVT(,R15) Get first asvt slot          JOE\n         LH    R0,FOUNASID           Get asid in question           JOE\n         BCTR  R0,0                  Down By 1                      JOE\n         SLL   R0,2                  Multiply by 4                  JOE\n         AR    R15,R0                Point to ASCB                  JOE\n         B     GETASCBE              Exit this routine              JOE\nNOASCB   DS    0H                                                   JOE\n         XR    R15,R15               Clear r15 - no ASCB there      JOE\nGETASCBE DS    0H                                                   JOE\n         L     R9,SAVER9M            Restore Register               JOE\n         BR    R9                                                   JOE\n** ---------------------------------------------------------------- JOE\n*                   Translate table to validity check ASID.\n*                     Convert display values to X'0h'\n*                     (where h is the hex value).\nASIDVAL  DS    0D\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'00CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CC0A0B0C0D0E0FCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CC0A0B0C0D0E0FCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'\n         DC    XL16'00010203040506070809CCCCCCCCCCCC'\nFILLER1  DS    CL24\nASIDMSG  DC    CL21'ASID parm entered  : '\nASIDWKSV DC    CL4' '\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\nFINDCSCB DS    0H                  Find CSCB entry to change or report.\n         ST    R9,SAVER9D          Save registers.\n         ST    R3,SAVER3A\nFINDCSST DS    0H                  Get the first CSCB.\n         L     R3,16               CVT\n         L     R3,X'94'(,R3)       MSER - pointer to CSCB chain.\n         ICM   R3,15,0(R3)         First CSCB entry.\n         USING CHAIN,R3            Tell assembler.\n         BZ    FINDCSEC            If zero, we are at end of CSCB chain\nFINDCSLP DS    0H                  Loop through the CSCB entries.\n         MVC   CSCBACTF(1),CHACT     Save CSCB ACT flag for this CSCB.\n         MVC   SAVEACTF(1),CHACT     Save CSCB ACT flag for this CSCB.\n         MVC   CSCBJOBI(8),CHKEY     Save CSCB Jobid (CHKEY).\n         MVC   CSCBPROC(8),CHCLS     Save CSCB PROC id (CHCLS).\n         MVC   CSCBASID(2),CHASID    Save CSCB ASID (CHASID).\n* ------------------------------------------------------------------- *\n* We first try to match a JOBID if coded, to the job id in this CSCB. *\n* If equal, we see if an ASID has been coded, and both have to match. *\n* Otherwise, with no match, we go to the end of the CSCB chain.       *\n* ------------------------------------------------------------------- *\nFINDCSMY DS    0H                  Find the CSCB that I want.\n         TM    FLAG1,X'04'         Was ASID( coded at all?\n         BZ    FINDCSJB            No. Just find a JOBID match.\n         TM    FLAG1,X'01'         Is the JOB id missing?\n         BO    FINDCSAS            Yes, just look for an ASID match.\n         TM    FLAG1,X'02'         Was JOB id coded?\n         BO    FINDCSJB            Yes. Look for it.\n         ICM   R3,15,0(R3)         Go to next CSCB.\n         BZ    FINDCSEC            If zero, we are at end of CSCB chain\n         B     FINDCSLP            Look at next CSCB entry in table.\nFINDCSJB DS    0H                  Check for JOBID match in this CSCB.\n         CLC   JOBID(8),CSCBJOBI   Compare coded JOBID to CSCB jobname.\n         BE    FINDCSIA            Equal, check if ASID is there.\n         ICM   R3,15,0(R3)         Otherwise go to the next CSCB.\n         BZ    FINDCSEC            Zero, end of the CSCB chain.\n         B     FINDCSLP            Not zero, look at the next entry.\nFINDCSIA DS    0H\n         TM    FLAG1,X'04'         Was ASID( coded?\n         BZ    FINDCSFD            No. Found it on just a job match.\n*                                   So this is the first job that\n*                                   matched, if there are multiple\n*                                   jobs with the same name.\nFINDCSAS DS    0H                  Check the ASID in the CSCB.\n         CLC   ASIDBIN(2),CSCBASID Is this our ASID? Does it match.\n         BE    FINDCSFD            I guess we found it.\n         ICM   R3,15,0(R3)         Go to the next CSCB.\n         BZ    FINDCSEC            Zero marks the end of the CSCB chain\n         B     FINDCSLP            Not zero. Look at the next entry.\nFINDCSFD DS    0H                  Our CSCB has been found.\n         ST    R3,FOUNCSCB         Save found CSCB address.\n         MVC   FOUNACTF,CHACT      Save\n         MVC   SAVEACTF,CHACT      Save\n         MVC   FOUNJOBI,CHKEY        CSCB\n         MVC   FOUNPROC,CHCLS          info.\n         MVC   FOUNASID,CHASID\n         MVC   SAVEASID,CHASID\n         BAL   R9,PRNTCSCB         Print info from the current CSCB.\n         BAL   R9,FORCHACT         Format some CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Put out an underline.\n         B     FINDCSEN            Go to end of routine.\n         DROP  R3\nFINDCSEC DS    0H                  Came to end of CSCB chain.\n         APUT  MESSAGEN,L'MESSAGEN   Then put out a message\n         B     EOJ4                  And end with code 4.\nFINDCSEN DS    0H\n         L     R3,SAVER3A\n         L     R9,SAVER9D\n         BR    R9\n*            Constants associated with this routine.    -    below\nFOUNACTF DC    X'00'\nSAVEACTF DC    X'00'\nFOUNCSCB DS    F                   FOUND CSCB ADDRESS\nFOUNJOBI DC    CL8' '\nFOUNPROC DC    CL8' '\nFOUNASID DC    H'0'\nSAVEASID DC    H'0'\nCSCBACTF DC    X'00'\nCSCBJOBI DC    CL8' '\nCSCBPROC DC    CL8' '\nCSCBASID DC    H'0'\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\nVALIDTR  DS    0H                  Validate hex characters coded.\n         ST    R9,SAVER9E          Save\n         STM   R4,R6,SAVEWRK          registers.\n         LA    R4,ASIDMV           Point to translated display chars.\n         LA    R6,ASIDWKS          Point to chars with error signs.\n         LA    R5,4                BCT register - only 4 times.\nVALIDTRS DS    0H\n         CLI   0(R4),X'CC'         Is this an invalid character?\n         BE    VALIDTRR            Yes. Substitute a ? for message.\n         LA    R4,1(,R4)           Next translated character.\n         LA    R6,1(,R6)           Next char for error message.\n         BCT   R5,VALIDTRS         Loop to test validity of this char.\n         TM    ERRASID,X'01'       After 4 chars, any errors found?\n         BO    VALIDERR            Yes. Write messages.\n         B     VALIDTRE            No. Get out of routine.\nVALIDTRR DS    0H                  Come here if invalid char found.\n         OI    ERRASID,X'01'       Flag that at least one was found.\n         MVI   0(R6),C'?'          Substitute a ? for it in message.\n         LA    R4,1(,R4)           Next translated character.\n         LA    R6,1(,R6)           Next char in error message.\n         BCT   R5,VALIDTRS         Check that character for validity.\nVALIDERR DS    0H                  Error messages if char is invalid.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(37),ASIDBADM\n         APUT  OUTPUT,45\n*        MVC   OUTPUT,OUTPUT-1\n*        MVC   OUTPUT(51),MSGBADPR\n*        APUT  OUTPUT,52\n         B     EOJ4                Get out with code 4.\nVALIDTRE DS    0H\n         L     R4,SAVER4B          Restore regs used in this routine.\n         LM    R4,R6,SAVEWRK\n         BR    R9\n*            Constants associated with this routine.    -    below\nERRASID  DC    X'00'\nSAVEWRK  DS    3F\nMSGBADPR DC    C'Bad ASID entered. Use end parenthesis ) to delimit.'\nASIDBADM DC    CL33'Bad Characters marked with a ?:  '\nASIDWKS  DC    CL4' '\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\n* -- -- -- -- -- -- -- -- -- -- -- --    R3 points to a CSCB address\nPRNTCSCB DS    0H                  Print a CSCB entry.\n         ST    R9,SAVER9F          Save BAL register.\n         ST    R3,SAVECSCB         Saved found CSCB address.\n         USING CHAIN,R3\n*                   Print info from current CSCB\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Job  ID :'\n         MVC   OUTPUT+11(8),CHKEY\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Proc ID :'\n         MVC   OUTPUT+11(8),CHCLS\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'ASID    :'\n         HEX   OUTPUT+11,2,CHASID\n         APUT  OUTPUT,25\n         TM    FLAG2,X'80'                Is this a BURN or KILL?   KIL\n         BO    PRNTFINI                   Yes. Abridge the messages BUR\n         TM    FLAG2,X'40'                CSCB only run. i.e. DISPLAY\n         BO    PRNTCSC1\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Previous CHACT Flags:'\n         HEX   OUTPUT+23,1,CHACT\n         APUT  OUTPUT,25\n         B     PRNTCSC2\nPRNTCSC1 DS    0H\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Current  CHACT Flags:'\n         HEX   OUTPUT+23,1,CHACT\n         APUT  OUTPUT,25\nPRNTCSC2 DS    0H\n         DROP  R3\nPRNTFINI DS    0H                                                   BUR\n         L     R3,SAVECSCB         Restore register to what it was.\n         L     R9,SAVER9F          Restore BAL register and\n*                                     branch back to caller.        BUR\n         BR    R9\nSAVECSCB DS    F                   Saved address of found CSCB.\n** ---------------------------------------------------------------- **\nRUNCSCB  DS    0H                  Run through the CSCB chain.\n         ST    R9,SAVER9G\n         ST    R3,SAVER3C\n         ST    R7,SAVER7A\nRUNCSCBT DS    0H\n         TM    FLAG2,X'40'         Only run if CSCB keyword was coded.\n         BZ    RUNCSCBE            Not coded, get out.\n*                                  Display this is a CSCB chain run.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(40),=C'This is a run of the CSCB Chain only ...'\n         APUT  OUTPUT,45\n         APUT  MESSAGEL,L'MESSAGEL   Print underline.\n*                                  Find the CSCB chain:\n         L     R3,16               CVT\n         L     R3,X'94'(,R3)       MSER - pointer to CSCB chain.\n         ICM   R3,15,0(R3)         First CSCB entry.\n         BZ    RUNCSCBE            If zero, end of CSCB chain.\n*                                  Otherwise points to next CSCB in\n*                                    the table.\n         USING CHAIN,R3\nRUNCSCBD DS    0H                  Loop through CSCB entries.\n         MVC   CSCBACTF(1),CHACT     Save CSCB ACT flag for this CSCB.\n         MVC   SAVEACTF(1),CHACT     Save CSCB ACT flag for this CSCB.\n         MVC   CSCBJOBI(8),CHKEY     Save CSCB JOBID (CHKEY).\n         MVC   CSCBPROC(8),CHCLS     Save CSCB PROC id (CHCLS).\n         MVC   CSCBASID(2),CHASID    Save CSCB ASID (CHASID).\n         MVC   SAVEASID(2),CHASID    Save CSCB ASID (CHASID).\n*  Test\n*        MVC   OUTPUT,OUTPUT-1\n*        HEX   OUTPUT,2,CHASID\n*        HEX   OUTPUT+6,2,ASIDBIN\n*        MVI   OUTPUT+15,C'i'\n*        APUT  OUTPUT,25\n*  Test\n* -- Limit print of entries to Jobname or ASID only ----  below\n         CLI   JOBID,C'-'          Are we printing the whole CSCB?\n         BE    RUNCSCBY            Yes.\n         CLC   ASIDBIN,=X'0000'    Was an ASID coded for a search?\n         BNE   RUNCSCB2            No. Just check for Jobname.\nRUNCSCB1 DS    0H                  Check for Jobname match.\n         XR    R7,R7               Clear work register.\n         IC    R7,SAVCOUNT         Insert saved length of Jobid.\n         BCTR  R7,0                Decrement for execute.\n         EX    R7,RUNCSCOM         Do the compare for proper length.\n*        BNE   RUNCSCBS            Not equal, don't print result.\n         BE    RUNCSCBP            Equal, print this CSCB entry.\nRUNCSCB2 DS    0H                  Check if ASID was coded.\n         CLC   ASIDBIN,CHASID      ASID match?\n         BNE   RUNCSCBS            No. Skip print of CSCB entry.\nRUNCSCBY DS    0H\n* -- Limit print of entries to Jobname or ASID only ----  above\nRUNCSCBP DS    0H                  Print this entry....\n         BAL   R9,PRNTCSCB         Print of current CSCB information.\n         BAL   R9,FORCHACT         Format some CHACT flags.\n         APUT  MESSAGEL,L'MESSAGEL   Print an underline line.\nRUNCSCBS DS    0H                  If skipping an entry print, go here.\n         ICM   R3,15,0(R3)         Go to next CSCB entry in table.\n         BZ    RUNCSCBE            If it is zero, end of CSCB chain.\n         B     RUNCSCBD            Not zero, loop to next entry and\n*                                    print it.\nRUNCSCBE DS    0H                  End of routine.\n         L     R3,SAVER3C          Restore\n         L     R7,SAVER7A\n         L     R9,SAVER9G             registers and\n         BR    R9                        go back to caller.\nRUNCSCOM CLC   JOBID(*-*),CHKEY    Executed\n         DROP  R3\n** ---------------------------------------------------------------- **\nKEYZERO  DS    0H                  Into Key 0 and change CSCB cntl blk.\n         ST    R9,SAVER9H\n         ST    R4,SAVER4A\n*\n* -- >  Test if this command is being run APF Authorized - below\n         STM   R15,R1,SAVE14T1     Now save registers and test if APF\n         XR    R15,R15                  authorized.\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.\n* -- >  Test if this command is being run APF Authorized - above\n*\n* -- >    ***    Do as little as possible under Key 0.    ***\nKEYPRLIM DS    0H\n         TM    ONSWIT,X'01'        Are we OR-ing?\n         BZ    SWITOFF             No. Try AND-ing?\n         MVC   CANCKEY0,CANCINDC   Pre-process affecting bits.\n         B     SWITON              All done pre-processing.\nSWITOFF  DS    0H\n         TM    ONSWIT,X'02'        Are we AND-ing?\n         BZ    KEY0BYPS            No. Don't do anything else.\n         XC    CANCINDC,=X'FF'     Reverse the affected bits for AND.\n         MVC   CANCKEY0,CANCINDC   And move them to staging area.\nSWITON   DS    0H\n         USING CHAIN,R3\n         L     R3,FOUNCSCB         Save address of \"found CSCB\".\n*\n* -- >                             We're authorized. Go Key 0.\n         MODESET KEY=ZERO\n         TM    ONSWIT,X'01'        Are we OR-ing?\n         BZ    KEY0OFF             No. Try AND-ing.\n         OC    CHACT(1),CANCKEY0   Do the OR.\n         B     KEY0END             Out of Key 0.\nKEY0OFF  DS    0H\n         TM    ONSWIT,X'02'        Are we AND-ing?\n         BZ    KEY0END             No. Get out altogether.\n         NC    CHACT(1),CANCKEY0   Do the AND.\nKEY0END  DS    0H                  Out of Key 0.\n         MODESET KEY=NZERO\n*\nKEY0BYPS DS    0H                  Key 0 bypass - branch to here.\n         MVC   SAVEACTF(1),CHACT   Record for posterity\n         DROP  R3\n         L     R4,SAVER4A\n         L     R9,SAVER9H\n         BR    R9\n** ---------------------------------------------------------------- **\nPRNWCSCB DS    0H                  Print the changed CSCB entry.\n         ST    R9,SAVER9I          Save BAL register.\n         ST    R3,SAVER3D\n         L     R3,FOUNCSCB         Saved found CSCB address.\n         USING CHAIN,R3\n*                   Print info from changed CSCB.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Job  ID :'\n         MVC   OUTPUT+11(8),CHKEY\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'Proc ID :'\n         MVC   OUTPUT+11(8),CHCLS\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(9),=C'ASID    :'\n         HEX   OUTPUT+11,2,CHASID\n         APUT  OUTPUT,25\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(21),=C'Modified CHACT Flags:'\n         HEX   OUTPUT+23,1,CHACT\n         APUT  OUTPUT,25\n         APUT  MESSAGEL,L'MESSAGEL\n         DROP  R3\n         L     R3,SAVER3D          Restore register to what it was.\n         L     R9,SAVER9I          Restore BAL register and\n         BR    R9                     branch back to caller.\n** ---------------------------------------------------------------- **\n**             REPORT - Format the CHACT Flags - REPORT             **\n** ---------------------------------------------------------------- **\nFORCHACT DS    0H                  SAVEACTF less volatile than CHACT.\n         ST    R9,SAVER9J          Save\n         ST    R3,SAVER3E             registers.\n         USING CHAIN,R3\nFORCANC0 DS    0H                  Show cancelable or not.\n         TM    SAVEACTF,CHCL       Is job cancelable?\n         BO    FORCANC1            Yes, show cancelable.\n         BZ    FORCANC2            No. Show non-cancelable.\n         B     FORFORC0            Fall through, try forceable.\nFORCANC1 DS    0H\n         MVC   MESSTXT,MESSCAN     Tell em job is cancelable.\n         B     FORCANCP\nFORCANC2 DS    0H\n         MVC   MESSTXT,MESSNCN     Tell em job is non-cancelable.\nFORCANCP DS    0H                  Write the actual message out.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(28),FORMTMSG\n         APUT  OUTPUT,30\nFORFORC0 DS    0H                  Show forceable or not.\n         TM    SAVEACTF,CHAFORCE   Can you do FORCE w/o CANCEL?\n         BO    FORFORC1            Yes. Don't need CANCEL first.\n         BZ    FORFORC2            No. Show you need CANCEL first.\nFORFORC1 DS    0H\n         MVC   MESSTXT,MESSFOR     Tell em FORCE ok w/o CANCEL.\n         B     FORFORCP\nFORFORC2 DS    0H\n         MVC   MESSTXT,MESSNFR     Tell em need CANCEL before FORCE.\nFORFORCP DS    0H                  Write the actual message out.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(28),FORMTMSG\n         APUT  OUTPUT,30\nFORKILLF DS    0H                  Figure out if Non-Memtermable or not\n         ST    R4,SAVER4D          Save work register\n*        CLC   SAVEASID,CHASID\n*        BNE   FORKILLX\n*        MVC   FOUNASID,CHASID     Stage ASID for GETASCB routine\n*        B     FORKILLY\nFORKILLX MVC   FOUNASID,SAVEASID\nFORKILLY DS    0H\n         BAL   R9,GETASCB          Get the ASCB.\n         LTR   R15,R15             Is there one?\n         BZ    FORCHEND            No. Exit this routine.\n         ST    R15,SAVEASCB        Save address of ASCB.\n         L     R4,SAVEASCB         Reload address of ASCB in work reg.\n         L     R4,0(,R4)           Get actual ASCB into register.\n         USING ASCB,R4\n         TM    ASCBFLG2,ASCBNOMT   Test if Non-Memtermable bit is on.\n         BZ    FOROMEMT            No. Report that it's off.\n         MVC   MESSTXT,MESSNMT     Yes. Put Non-Memtermable into msg.\n         B     FORKILLO            And put out the message.\nFOROMEMT DS    0H\n         MVC   MESSTXT,MESSMMT     No. Put Memtermable into message.\nFORKILLO MVC   OUTPUT,OUTPUT-1     And put out the message.\n         MVC   OUTPUT(28),FORMTMSG\n         APUT  OUTPUT,30\n         L     R4,SAVER4D          Restore work register.\n         DROP  R4                  Lose ASCB addressability.\nFORCHEND DS    0H\n         DROP  R3\n         L     R3,SAVER3E          Restore\n         L     R9,SAVER9J             registers.\n         BR    R9\n*            Constants associated with this routine.    -    below\nMESSCAN  DC    CL15'Cancelable     '\nMESSNCN  DC    CL15'Non-Cancelable '\nMESSFOR  DC    CL15'Force w/o Cncel'\nMESSNFR  DC    CL15'Cancel + Force '\nMESSNMT  DC    CL15'Non-Memtermable'\nMESSMMT  DC    CL15'Memtermable    '\nFORMTMSG DS    0CL28\nMESS000  DC    CL13'Job Status:  '\nMESSTXT  DC    CL15'               '\n*            Constants associated with this routine.    -    above\n** ---------------------------------------------------------------- **\nPRINTERR DS    0H                    Print help messages.\n         ST    R9,SAVER9K            Save BAL register.\n         APUT  MESSAG2A,L'MESSAG2A\n         APUT  MESSAG2B,L'MESSAG2B\n         APUT  MESSAG2V,L'MESSAG2V\n         APUT  MESSAG2U,L'MESSAG2U\n         APUT  MESSAG2C,L'MESSAG2C\n         APUT  MESSAG2D,L'MESSAG2D\n         APUT  MESSAG2E,L'MESSAG2E\n         APUT  MESSAG2F,L'MESSAG2F\n         APUT  MESSAGEM,L'MESSAGEM\n         APUT  MESSAG2G,L'MESSAG2G\n         APUT  MESSAG2H,L'MESSAG2H\n         APUT  MESSAGEM,L'MESSAGEM\n         APUT  MESSAG2I,L'MESSAG2I\n         APUT  MESSAG2J,L'MESSAG2J\n         APUT  MESSAG2K,L'MESSAG2K\n         APUT  MESSAG2L,L'MESSAG2L\n         APUT  MESSAG2M,L'MESSAG2M\n         APUT  MESSAG2N,L'MESSAG2N\n         APUT  MESSAG2O,L'MESSAG2O\n         APUT  MESSAG2P,L'MESSAG2P\n         APUT  MESSAG2Q,L'MESSAG2Q\n         APUT  MESSAG2R,L'MESSAG2R\n         APUT  MESSAG2S,L'MESSAG2S\n         APUT  MESSAG2T,L'MESSAG2T\n         APUT  MESSAGEM,L'MESSAGEM\n         L     R9,SAVER9K            Restore BAL register.\n         BR    R9\n** ----------------------------------------------------------------- **\n*        Control of the following routines are under control of       *\n*           the KILLFLAG, and are not under control of FLAG2.         *\n*                                                                     *\n*        KILLFLAG controls processes KILL, BURN, NMEM and MEMT.       *\n*              (Routine sets FLAG2 EQU X'80')                         *\n*  ------------------------------------------------------------------ *\n*                   Settings of the KILLFLAG                          *\n*                                                                     *\n*  KILLFLAG  equals  X'01'            for KILL (whack always)         *\n*                    X'01' and X'02'  for BURN (whack only if MEMT)   *\n*                    X'04'            for NMEM (make NON-memtermable) *\n*                    X'08'            for MEMT (make memtermable)     *\n*                                                                     *\n** ----------------------------------------------------------------- **\nDONMEM   DS    0H                        NON-MEMTERMABLE   FLAG X'04'\n         NI    KILLFLAG,X'04'            ONLY NMEM FLAG ON. Others off\n         OI    KILLFLAG,X'04'            TURN NMEM FLAG ON\n         B     FLGSDONE\nDOMEMT   DS    0H                        MEMTERMABLE       FLAG X'08'\n         NI    KILLFLAG,X'08'            ONLY MEMT FLAG ON  Others off\n         OI    KILLFLAG,X'08'            TURN MEMT FLAG ON\n         B     FLGSDONE\nDOBURN   DS    0H                        BURN. X'02' and X'01' both on\n         OI    KILLFLAG,X'02'            Announce BURN as keyword\nDOKILL   DS    0H                        KILL process. KILL flag on.\n         OI    KILLFLAG,X'01'            Announce KILL as keyword\nFLGSDONE DS    0H                        Flags have been set.\n         TM    FLAG0,X'40'               Have PSCB ACCT authority?\n         BZ    NOTALLOW                  No. Can't do these commands.\n*  ------------------------------------------------------------------ *\n*                    Print the action code for                        *\n*                    everything under FLAG2=X'80'                     *\n*  ------------------------------------------------------------------ *\n         OI    FLAG2,X'80'               Mark under KILLFLAG control.\n*  ------------------------------------------------------------------ *\n         MVC   OUTPUT,OUTPUT-1           Print message accordingly\n         MVC   OUTPUT(15),=C'Action code   :'\nTRYBURN  TM    KILLFLAG,X'02'            For BURN, X'01' and X'02' on.\n         BZ    TRYKILL\n         MVC   OUTPUT+17(4),BURNC        Mark as a BURN.\n         B     PRTCODE\nTRYKILL  TM    KILLFLAG,X'01'\n         BZ    TRYNMEM\n         MVC   OUTPUT+17(4),KILLC        Mark as a KILL.\n         B     PRTCODE\nTRYNMEM  TM    KILLFLAG,X'04'\n         BZ    TRYMEMT\n         MVC   OUTPUT+17(4),NMEMC        Mark as a NMEM.\n         B     PRTCODE\nTRYMEMT  TM    KILLFLAG,X'08'\n         BZ    PRTCODE\n         MVC   OUTPUT+17(4),MEMTC        Mark as a MEMT.\nPRTCODE  DS     0H                       And print the result.\n         APUT  OUTPUT,25\n*  ------------------------------------------------------------------ *\n* -- >  Test if this command is being run APF Authorized - below    BUR\nTAUTH    STM   R15,R1,SAVE14T1   Now save registers and test if APF BUR\n         XR    R15,R15                authorized.                   BUR\n         TESTAUTH FCTN=1           Are we authorized?               BUR\n         LTR   R15,R15             Test the return code.            BUR\n         BNZ   NOTAUTH           Not zero, tell not authorized.     BUR\n         LM    R15,R1,SAVE14T1   Restore registers used by TESTAUTH BUR\n* -- >  Test if this command is being run APF Authorized - above    BUR\n*  ------------------------------------------------------------------ *\n         BAL   R9,FINDCSCB               Get correct CSCB entry.    BUR\n         MODESET KEY=ZERO,MODE=SUP                                  BUR\n         ST    R7,SAVER7B                Store work register        BUR\n         LH    R7,CSCBASID               Set ASID                   BUR\n         TM    KILLFLAG,X'0C'            NMEM or MEMT action?\n         BNZ   ASCBBITS                  If either, then not KILL\n*----->               KILL routine - below                          KIL\n         TM    KILLFLAG,X'01'            Is the KILL flag on?       KIL\n         BZ    SKIPMEMT                  No. Exit this routine.     KIL\nASCBBITS DS    0H\n         CLC   CSCBASID,=X'0000'         Did FINDCSCB find a CSCB?  KIL\n         BE    SKIPMEMT                  No. Exit this routine.     KIL\n         MVC   FOUNASID,CSCBASID         Stage ASID to get the ASCB KIL\n         BAL   R9,GETASCB                Get the ASCB.              KIL\n         LTR   R15,R15                   Is there one?              KIL\n         BZ    SKIPMEMT                  No. Exit this routine.     KIL\n         ST    R15,SAVEASCB              Save address of ASCB.      KIL\n         L     R15,0(,R15)               Load it to address fields. KIL\n         USING ASCB,R15                                             KIL\n         TM    KILLFLAG,X'08'            MEMT?\n         BO    FORCEOFF\n         TM    KILLFLAG,X'04'            NMEM?\n         BO    FORCEON\n         TM    KILLFLAG,X'02'            BURN only?                 BUR\n         BO    EXITKILL                  Non-forcible still on.     BUR\n         TM    KILLFLAG,X'01'            If not X'01' then no MEMTERM.\n         BZ    SKIPMEMT                  Yes. Turn off ASCB bits first.\n         NI    ASCBFLG2,255-ASCBNOMT     Turn off NON-FORCIBLE bit  KIL\n         NI    ASCBFLG2,255-ASCBNOMD     Turn off Dat error bit     KIL\n         B     EXITKILL                  Go do MEMTERM.\nFORCEOFF NI    ASCBFLG2,255-ASCBNOMT     Turn off NON-FORCIBLE bit\n         NI    ASCBFLG2,255-ASCBNOMD     Turn off Dat error bit\n         B     SKIPMEMT                  And skip MEMTERM.\nFORCEON  DS    0H                        Make Non-Memtermable.\n         OI    ASCBFLG2,ASCBNOMT         Put the ASCBNOMT bit on.\n         ST    R3,SAVER3F                Then\n         L     R3,FOUNCSCB                  Make\n         USING CHAIN,R3                        Job\n         NI    CHACT,255-X'08'                    Non-Cancelable too.\n         MVC   SAVEACTF(1),CHACT         Save for reporting\n         L     R3,SAVER3F                Restore work register.\n         B     SKIPMEMT                  Don't do CALLRTM MEMTERM.\n         DROP  R3\nEXITKILL DS    0H                        Now do CALLRTM MEMTERM.    KIL\n         DROP  R15                       Drop ASCB addressability   KIL\n*----->               KILL routine - above                          KIL\n         ST    R13,SAVER13A              Save R13                   BUR\n         LA    R13,RTMSAVE               RTM save area              BUR\n         CALLRTM TYPE=MEMTERM,ASID=(R7),COMPCOD=100                 BUR\n         STC   R15,RTMCOD                Save MEMTERM Return Code\n         L     R13,SAVER13A              Restore R13                BUR\nSKIPMEMT DS    0H\n         L     R7,SAVER7B                Restore work register      BUR\n         MODESET KEY=NZERO,MODE=PROB                                BUR\n         CLI   RTMCOD,X'2C'              Non-memtermable addr space?\n         BE    NOTMEMTM                  Yes. Issue message to say so.\n*\n         TM    KILLFLAG,X'04'            Message if NMEM done.\n         BZ    TRYMMEMT\n         MVC   MESSAGM1+4(8),FOUNJOBI    Jobname into message       BUR\n         HEX   MESSAGM1+22,2,FOUNASID    ASID into message          BUR\n         APUT  MESSAGM1,L'MESSAGM1       Say job made non-memtermable\n         B     BURNEND                   Done with message\nTRYMMEMT DS    0H\n         TM    KILLFLAG,X'08'\n         BZ    TRYMBURN\n         MVC   MESSAGM2+4(8),FOUNJOBI    Jobname into message       BUR\n         HEX   MESSAGM2+22,2,FOUNASID    ASID into message          BUR\n         APUT  MESSAGM2,L'MESSAGM2       Say job was killed.        BUR\n         B     BURNEND                   Done with message          KIL\nTRYMBURN TM    KILLFLAG,X'02'            KILL msg instead of BURN?  KIL\n         BO    BURNMSG                   Yes. Run BURN message.     KIL\n         MVC   MESSAGKI+4(8),FOUNJOBI    Jobname into message       BUR\n         HEX   MESSAGKI+22,2,FOUNASID    ASID into message          BUR\n         APUT  MESSAGKI,L'MESSAGKI       Say job was killed.        BUR\n         B     BURNEND                   Skip BURN message          KIL\nBURNMSG  DS    0H\n         MVC   MESSAGBU+4(8),FOUNJOBI    Jobname into message       KIL\n         HEX   MESSAGBU+22,2,FOUNASID    ASID into message          KIL\n         APUT  MESSAGBU,L'MESSAGBU       Say job was burned.        KIL\nBURNEND  DS    0H\n         B     GETIDEND            After enough looks, end.         KIL\nRTMSAVE  DS    CL72                Work area for RTM                BUR\nSAVER13A DS    F                   Place to save R13                BUR\nSAVEASCB DS    F                   Save ASCB address                KIL\n** ---------------------------------------------------------------- **\nKEY0SWNS DS    0H                    Key 0 for SWAP or NSWP or TSWP\n         ST    R9,SAVER9L            Save BAL register.\n         ST    R6,SAVER6A\nKEY0TSTA DS    0H\n* -- >  Test if this command is being run APF Authorized - below\n         STM   R15,R1,SAVE14T1     Now save registers and test if APF\n         XR    R15,R15                  authorized.\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.\n* -- >  Test if this command is being run APF Authorized - above\n         TM    FLAG2,X'04'         Make ASID swappable?\n         BO    KEY0SWAP            Yes. Do it.\n         TM    FLAG2,X'08'         Make ASID non-swappable?\n         BO    KEY0NSWP            Yes. Do it.\n         B     KEY0EXIT            Not SWAP or NSWP, don't belong here.\n*\nKEY0NSWP DS    0H                    Make address space non-swappable.\n*\n         CLC   OWNASID,FOUNASID    Target ASID different from ours?\n         BE    KEY0DNSW            No. Just do SYSEVENT in this adrspc\n         TM    FLAG3,X'01'           Was TRANSWAP asked for?\n         BO    KEY0TSWP              Yes. Go set it.\n         MVC   FUNC,=CL8'DONTSWAP'   Set DONTSWAP function          JOE\n         B     KEY0DONS              Go set up SRB and SYSEVENT stuff\nKEY0TSWP DS    0H\n         MVC   FUNC,=CL8'TRANSWAP'   Set TRANSWAP function\nKEY0DONS DS    0H\n         BAL   R9,BUILDSRB           Build SRB block                JOE\n*                                                                   JOE\n* ISSUE SUCCESSFUL MESSAGE                                          JOE\n*                                                                   JOE\n* ----- >           Find OUCBNDS Count        < ----- *     below\n         MVC   OUTPUT,OUTPUT-1           Display DONTSWAP count\n         MVC   OUTPUT+2(32),=C'Outstanding DONTSWAP requests:  '\n         HEX   OUTPUT+35,2,KEY0NDS   Number was gotten from the SRB.\n         APUT  OUTPUT,50\n* ----- >           Find OUCBNDS Count        < ----- *     above\n         TM    FLAG3,X'01'               Different msgs for TSWP, NSWP\n         BZ    KEY0RPNS\n         MVC   MESSAGTS+4(8),FOUNJOBI    TRANSWAP messages\n         HEX   MESSAGTS+22,2,FOUNASID\n         APUT  MESSAGTS,L'MESSAGTS\n         B     KEY0RPTS\nKEY0RPNS DS    0H\n         MVC   MESSAGNS+4(8),FOUNJOBI    DONTSWAP messages          JOE\n         HEX   MESSAGNS+22,2,FOUNASID                               JOE\n         APUT  MESSAGNS,L'MESSAGNS                                  JOE\nKEY0RPTS DS    0H\n         L     R6,SAVER6A            Restore Register               JOE\n         L     R9,SAVER9L            Restore BAL register.          JOE\n         BR    R9                    go back                        JOE\nTEMPSAVE DS    4F                    save area                      JOE\n* ---------------------------------------------------------------- *\nKEY0DNSW DS    0H                    Action for our address space\n         MODESET MODE=SUP,KEY=ZERO\nKEY0SYSD DS    0H\n         LH    R6,FOUNASID\n         TM    FLAG3,X'01'           TSWP instead of NSWP?\n         BO    KEY0SYST              Yes. Do TRANSWAP function.\n         SYSEVENT DONTSWAP,ASID=(R6),ENTRY=SVC\n         B     KEY0NNRM              No.  Do DONTSWAP function.\nKEY0SYST SYSEVENT TRANSWAP,ASID=(R6),ENTRY=SVC\nKEY0NNRM DS    0H                    Display the results.\n* ----- >           Find OUCBNDS Count        < ----- *     below\n         L     R2,X'224'                 ASCB\n         L     R2,X'90'(,R2)             ASCBOUCB\n         LA    R2,X'88'(,R2)             OUCBNDS (Count Field)\n         MVC   KEY0NDS(2),0(R2)\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT+2(32),=C'Outstanding DONTSWAP requests:  '\n         HEX   OUTPUT+35,2,KEY0NDS       Display the number found.\n         APUT  OUTPUT,50\n* ----- >           Find OUCBNDS Count        < ----- *     below\n         MODESET MODE=PROB,KEY=NZERO\n         TM    FLAG3,X'01'\n         BZ    KEY0METS\n         MVC   MESSAGTS+4(8),FOUNJOBI    TRANSWAP message\n         HEX   MESSAGTS+22,2,FOUNASID\n         APUT  MESSAGTS,L'MESSAGTS\n         B     KEY0EXIT\nKEY0METS MVC   MESSAGNS+4(8),FOUNJOBI    DONTSWAP message\n         HEX   MESSAGNS+22,2,FOUNASID                               JOE\n         APUT  MESSAGNS,L'MESSAGNS\n         B     KEY0EXIT\n* ---------------------------------------------------------------- *\nKEY0SWAP DS    0H                    Make address space swappable.\n         CLC   OWNASID,FOUNASID      Target asid different from ours?\n         BE    KEY0DSWP              No. Just do SYSEVENT.\n         MVC   FUNC,=CL8'OKSWAP'     Set function                   JOE\n         BAL   R9,BUILDSRB           Build SRB CSA CONTROL BLOCKS   JOE\n*                                                                   JOE\n*  ISSUE SUCCESSFUL MESSAGE                                         JOE\n*                                                                   JOE\n* ----- >                         Display outstanding DONTSWAP count\n         MVC   OUTPUT,OUTPUT-1       and show still non-swappable\n         MVC   OUTPUT+2(32),=C'Outstanding DONTSWAP requests:  '\n         HEX   OUTPUT+35,2,KEY0NDS\n         APUT  OUTPUT,50\n         CLC   KEY0NDS,=X'0000'   Positive DONTSWAP count?  Yes?\n         BNH   KEY0NOMX           Display instructional message.\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT+2(32),=C'Run SWAP again until count is 0.'\n         APUT  OUTPUT,50\n         MVC   MESSAGSY+6(8),FOUNJOBI    Show job not done yet.\n         HEX   MESSAGSY+24,2,FOUNASID\n         APUT  MESSAGSY,L'MESSAGSY\n         B     KEY0SNDN\nKEY0NOMX DS    0H\n* ----- >                             Display job is now swappable\nKEY0SDNE MVC   MESSAGSW+4(8),FOUNJOBI                               JOE\n         HEX   MESSAGSW+22,2,FOUNASID                               JOE\n         APUT  MESSAGSW,L'MESSAGSW                                  JOE\nKEY0SNDN L     R6,SAVER6A            Restore Registers              JOE\n         L     R9,SAVER9L            Restore BAL register.          JOE\n         BR    R9                                                   JOE\n* ---------------------------------------------------------------- *\nKEY0DSWP DS    0H\n         LH    R6,FOUNASID\n* ---- >          FSWP code below\n         MODESET MODE=SUP,KEY=ZERO\n         TM    FLAG3,X'02'\n         BZ    KEY0DSNF\n         L     R2,X'224'                 ASCB\n         L     R2,X'90'(,R2)             ASCBOUCB\n         LA    R2,X'88'(,R2)             OUCBNDS (Count Field)\n         MVC   0(2,R2),=X'0001'          Set DONTSWAP count to 1\nKEY0DSNF DS    0H\n* ---- >          FSWP code above\n         SYSEVENT OKSWAP,ASID=(R6),ENTRY=SVC\nKEY0SNRM DS    0H\n* ----- >           Find OUCBNDS Count        < ----- *     below\n         L     R2,X'224'                 ASCB\n         L     R2,X'90'(,R2)             ASCBOUCB\n         LA    R2,X'88'(,R2)             OUCBNDS (Count Field)\n         MVC   KEY0NDS(2),0(R2)          Move to staging area.\n         MVC   OUTPUT,OUTPUT-1           Display DONTSWAP count.\n         MVC   OUTPUT+2(32),=C'Outstanding DONTSWAP requests:  '\n         HEX   OUTPUT+35,2,KEY0NDS\n         APUT  OUTPUT,50\n* ----- >           Find OUCBNDS Count        < ----- *     above\n         MODESET MODE=PROB,KEY=NZERO\n         CLC   KEY0NDS(2),=X'0001'       DONTSWAP count low enough?\n         BNL   KEY0NODO                  No. Tell em \"no can do\".\n         MVC   MESSAGSW+4(8),FOUNJOBI    Yes. Display that it's done.\n         HEX   MESSAGSW+22,2,FOUNASID                               JOE\n         APUT  MESSAGSW,L'MESSAGSW\n         B     KEY0EXIT                  Finished with this routine.\nKEY0NODO DS    0H                        DONTSWAP count too high.\n         MODESET MODE=PROB,KEY=NZERO\n         MVC   OUTPUT,OUTPUT-1           Display \"no can do\" message\n         MVC   MESSAGSY+6(8),FOUNJOBI\n         HEX   MESSAGSY+24,2,FOUNASID\n         APUT  MESSAGSY,L'MESSAGSY\n         MVC   OUTPUT,OUTPUT-1           Display instructional message\n         MVC   OUTPUT+2(32),=C'Run SWAP again until count is 0.'\n         APUT  OUTPUT,50\n         MVC   OUTPUT,OUTPUT-1\n         HEX   MESSAGNG+43,1,SYSEVCOD+3  Display RC from SYSEVENT.\n         APUT  MESSAGNG,L'MESSAGNG\nKEY0EXIT DS    0H\n         L     R6,SAVER6A\n         L     R9,SAVER9L                Restore BAL register.\n         BR    R9\n* ---------------------------------------------------------------- *\nKEY0NDS  DS    H\n*--------------------------------------------------------------*    JOE\n*                                                              *    JOE\n*        BUILD SRB CONTROL BLOCK AND ACCOMPANYING CODE         *    JOE\n*                                                              *    JOE\n*--------------------------------------------------------------*    JOE\nBUILDSRB DS    0H                                                   JOE\n         STM   R6,R9,TEMPSAVE        Save Registers                 JOE\n         BAL   R9,GETASCB            Find ASCB for this asid        JOE\n         LR    R9,R15                Hold ASCB                      JOE\n         L     R9,0(,R9)             Point to ASCB                  JOE\n         MODESET MODE=SUP,KEY=ZERO   Get into supervisor state      JOE\n*                                                                   JOE\nCSA_LEN  EQU  SRBSIZE+84             CSA SRBLOCK AND PARAMTERS      JOE\n*                                                                   JOE\n*---------------------------------------------------------------*   JOE\n*       Get CSA for SRB CONTROL BLOCK SUBPOOL 241               *   JOE\n*---------------------------------------------------------------*   JOE\n         STORAGE OBTAIN,SP=241,LENGTH=CSA_LEN Get Some CSA          JOE\n         LR    R6,R1                 Point R6 to SRB control block  JOE\n         USING SRB,R6                Address SRB                    JOE\n         XC    SRB(SRBSIZE),SRB      Clear out SRB                  JOE\n         ST    R9,SRBASCB            Save ASCB                      JOE\n         LA    R8,SRBSIZE(,R6)       R8 -> paramlist                JOE\n*       Get CSA paramter list                                   *   JOE\n         ST    R8,SRBPARM            Store paramter list address    JOE\n         LA    R7,72(,R8)            Point to ECB                   JOE\n         XC    0(4,R7),0(R7)         Clear ECB Address              JOE\n         LA    R7,4(,R7)             Point to ASCB                  JOE\n         MVC   0(4,R7),X'224'        Move \"HOME\" PSAAOLD address sp JOE\n         LA    R7,4(,R7)             Bump to next param             JOE\n         CLC   FUNC,=C'DONTSWAP'     Q. non swappable function      JOE\n         BE    NONSWAP               Yes; branch if so              JOE\n         CLC   FUNC,=C'TRANSWAP'     Q. non swappable function      JOE\n         BE    TRNSWAP               Yes; branch if so              JOE\n         MVC   0(4,R7),=C'OKSW'      Otherwise swappable            JOE\n         MVC   SRBFLAG3(1),FLAG3\n         B     SETEPA                Set SRB program entry point    JOE\nNONSWAP  DS    0H                                                   JOE\n         MVC   0(4,R7),=C'DONT'      Set FUNCTION IN R7             JOE\n         MVC   SRBFLAG3(1),FLAG3\n         B     ENDSWAP\nTRNSWAP  DS    0H\n         MVC   0(4,R7),=C'TRAN'      Set FUNCTION IN R7\n         MVC   SRBFLAG3(1),FLAG3\nENDSWAP  DS    0H\n*---------------------------------------------------------------*   JOE\n*       Get CSA for SRB CONTROL BLOCK SUBPOOL 227               *   JOE\n*---------------------------------------------------------------*   JOE\nSETEPA   DS    0H                                                   JOE\n         STORAGE OBTAIN,SP=227,LENGTH=SWAPLEN  Get Fixed CSA        JOE\n         O     R1,=X'80000000'       SRB must run in 31-bit mode.   JOE\n         ST    R1,SRBEPA             Set entry point                JOE\n         LR    R14,R1                Hold that thought              JOE\n         LA    R15,SWAPLEN           Get Length                     JOE\n         LR    R1,R15                                               JOE\n         LA    R0,SWAPXMEM           Point to SRB routine           JOE\n         MVCL  R14,R0                Move routine                   JOE\n*                                                                   JOE\n         SCHEDULE SRB=(R6),SCOPE=GLOBAL,MODE=NONXM                  JOE\n*                                                                   JOE\n         LA    R7,72(,R8)            Point to ECB                   JOE\n*                                                                   JOE\n         WAIT  ECB=(R7)                                             JOE\n*                                                                   JOE\n         L     R9,SRBEPA             Get Entry Point Address        JOE\n         MVC   KEY0NDS(2),SRBNDS-SWAPXMEM(R9)   Get OUCBNDS out.\n*                                                                   JOE\n         STORAGE RELEASE,ADDR=(R6),LENGTH=CSA_LEN,SP=241            JOE\n*                                                                   JOE\n         STORAGE RELEASE,ADDR=(R9),LENGTH=SWAPLEN,SP=227            JOE\n*                                                                   JOE\n         MODESET KEY=NZERO,MODE=PROB                                JOE\n*                                                                   JOE\n         LM    R6,R9,TEMPSAVE        Save Registers                 JOE\n         BR    R9                    Return                         JOE\nSYSEVCOD DC    F'0'                  SYSEVENT Return Code\nOLDAX    DS    F\nWAREA    DS    D                     Work area\nWAREB    DS    D                     Work area\n** ---------------------------------------------------------------- **\n** --         C  O  N  S  T  A  N  T  S                          -- **\n** ---------------------------------------------------------------- **\nMESSAGNA DC    C'Command was not invoked APF authorized.'\nMESSAGEN DC    C'End of CSCB chain was reached.'\nMESSAGEY DC    C'No valid keyword was coded.'\nFLAG0    DC    X'00'               Copy of PSCBATR1 - Authority levels\nFLAG1    DC    X'00'               Needed to parse parameters\n*              X'01'               ASID ONLY - NO JOBNAME\n*              X'02'               JOBNAME IS PRESENT.\n*              X'04'               ASID( WAS PRESENT IN PARMS.\n*              X'08'               CSCB CHAIN DISPLAY ONLY.\nFLAG2    DC    X'00'\n*              X'01'               CNCL WAS CODED\n*              X'02'               NCNC WAS CODED\n*              X'04'               SWAP WAS CODED\n*              X'08'               NSWP WAS CODED\n*              X'10'               FORC WAS CODED\n*              X'20'               CSCB WAS CODED\n*              X'80'               BURN OR KILL WAS CODED           KIL\n*              X'40'               CSCB chain run only.\nFLAG3    DC    X'00'\nRTMCOD   DC    X'00'               Saved return code from MEMTERM\nONSWIT   DC    X'00'\n*              X'01'               TURN BIT ON\n*              X'02'               TURN BIT OFF\nHEXSAVE  DS    3F                  SAVE FOR HEX MACRO\nSAVE     DS    9D                  Program Save Area\nSAVE14T1 DS    2D                  Save \"system-used\" registers.\n         DC    C' '                Blank before OUTPUT line.\nOUTPUT   DC    CL80'  '            Variable output line.\nFUNC     DS    CL8                 Swapppinmg function\n         LTORG\n*-----------------------------------------------------------------* JOE\n*                         SRB CODE                                * JOE\n*-----------------------------------------------------------------* JOE\nSWAPXMEM DS    0D                                                   JOE\n         DROP  R12,R11,R10                                          JOE\n         BASR  R5,0                                                 JOE\n         USING *,R5                Entry Point                      JOE\n         LR    R10,R14             Save return address              JOE\n         LR    R13,R1                                               JOE\n*                                                                   JOE\n         LA    R9,72(,R13)         Point to ECB Address             JOE\n         LA    R8,76(,R13)         Point to ASCB Address            JOE\n         L     R8,0(,R8)                                            JOE\n         L     R7,80(,R13)         Get code                         JOE\n*                                                                   JOE\n         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=STDSAVE         JOE\n*                                                                   JOE\n         C      R7,=C'OKSW'        OKSWAP                           JOE\n         BE     SETSWAP                                             JOE\n*                                                                   JOE\n         XR    R1,R1               Undocumented instead of WAIT     JOE\n         TM    SRBFLAG3,X'01'\n         BO    SWAPTRAN\n         SYSEVENT DONTSWAP,ENTRY=BRANCH                             JOE\n         B     SWAPDONT\nSWAPTRAN DS    0H\n         SYSEVENT TRANSWAP,ENTRY=BRANCH                             JOE\nSWAPDONT DS    0H\n*                                                                   JOE\n* ----- >           Find OUCBNDS Count        < ----- *     below\n         L     R2,X'224'                 ASCB\n         L     R2,X'90'(,R2)             ASCBOUCB\n         LA    R2,X'88'(,R2)             OUCBNDS (Count Field)\n         LH    R2,0(,R2)                 Point to halfword of data\n         STH   R2,SRBNDS\n* ----- >           Find OUCBNDS Count        < ----- *     above\n         B     UNLOCK                                               JOE\n*                                                                   JOE\nSETSWAP  DS    0H                                                   JOE\n*\n* ----- >           FSWP code                 < ----- *     below\n         TM    SRBFLAG3,X'02'\n         BZ    SETSWAPF\n         L     R2,X'224'                 ASCB\n         L     R2,X'90'(,R2)             ASCBOUCB\n         LA    R2,X'88'(,R2)             OUCBNDS (Count Field)\n         MVC   0(2,R2),=X'0001'          Set DONTSWAP count to 1\nSETSWAPF DS    0H\n* ----- >           FSWP code                 < ----- *     above\n*                                                                   JOE\n         XR    R1,R1               Undocumented instead of WAIT     JOE\n         SYSEVENT OKSWAP,ENTRY=BRANCH                               JOE\n* ----- >           Find OUCBNDS Count        < ----- *     below\n         L     R2,X'224'                 ASCB\n         L     R2,X'90'(,R2)             ASCBOUCB\n         LA    R2,X'88'(,R2)             OUCBNDS (Count Field)\n         LH    R2,0(,R2)                 Point to halfword of data\n         STH   R2,SRBNDS\n* ----- >           Find OUCBNDS Count        < ----- *     above\nUNLOCK   DS    0H                                                   JOE\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE                    JOE\n*                                                                   JOE\n*                                                                   JOE\n         POST  (R9),ASCB=(R8),ERRET=GOBACK,LINKAGE=BRANCH           JOE\n*                                                                   JOE\nGOBACK   LR    R14,R10               Return Address                 JOE\n         BR    R14                   Return                         JOE\n         LTORG                                                      JOE\nSRBFLAG3 DC    X'00'                 Copy of program's FLAG3\nSRBNDS   DS    H                     Storage for OUCBNDS value\nSWAPRTM  DS    0D                    Align on doubleword            JOE\nSWAPLEN  EQU   *-SWAPXMEM                                           JOE\n** ---------------------------------------------------------------- **\n         SPACE\n         TITLE '- MAPPING MACROS.'\n         CVT   DSECT=YES           Map the CVT.\n         IEECHAIN                  Map the CSCB control block.\n         IHASRB                                                     JOE\n         IHAASVT                                                    JOE\n         IHAASCB                                                    JOE\n         IHAASXB                                                    JOE\n         IRAOUCB                                                    JOE\n         IHAPSA   DSECT=YES,LIST=YES                           HD APR88\n         IHAFRRS\n         EJECT                                                 HD APR88\n         IKJEFLWA                                                   JOE\n         END   CNCLPG\n** ---------------------------------------------------------------- **\n*  -----------------------------------------------------------------  *\n*  --           Create PUTLINE environment.                       --  *\n*  -----------------------------------------------------------------  *\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUEMNTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   128                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         IHAPSA   DSECT=YES,LIST=YES                           HD APR88\n         EJECT\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   14,12,12(13)       SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES            RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    1,8(13)            OUR SAVE AREA POINTER\n         ST    13,4(1)            POINTER TO CALLERS SAVE AREA\n         LR    13,1               @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(R13)         POINT TO CALLERS RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 ASSUME BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 ASSUME BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(RML)               MESSAGE LENGTH\n         STH   R15,PUTLEN                 PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    2,R13                    @OUR SAVE AREA\n         LR    3,R15                    SAVE RETURN CODE\n         L     R13,4(R13)               @CALLERS SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,3                    RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOADLIB": {"ttr": 6408, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x00E\\x01\\x19\\x06O\\x01\\x19\\x06O\\x13%\\x0eZ\\x0eZ\\x00\\x00\\xd3\\xd6\\xc1\\xc4\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "2019-03-05T00:00:00", "modifydate": "2019-03-05T13:25:45", "lines": 3674, "newlines": 3674, "modlines": 0, "user": "LOADLIB"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "TSO$": {"ttr": 7943, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x005\\x01\\x10\\x10_\\x01\\x10\\x10_\"3\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-04-15T00:00:00", "modifydate": "2010-04-15T22:33:35", "lines": 31, "newlines": 31, "modlines": 0, "user": "SBGOLOB"}, "text": "The TSOB, TSOE, TSOV, and TSOR commands from Mark Zelden:\n\n\n    Trappable output from TSO commands, which has been produced\nby the PUTLINE interface (as opposed to the TPUT interface) can\nbe captured and REDISPLAYED IN SCROLLABLE FORM.  This is the\npurpose of the above commands:\n\nTSOB  -  Capture TSO output and BROWSE it.\n\nTSOE  -  Capture TSO output and EDIT it.\n\nTSOV  -  Capture TSO output and VIEW it.\n\nTSOR  -  Capture TSO output and REVIEW it, using the REVIEW TSO\n         fullscreen command from CBT Tape File 134.\n\n    To use these, type:\n\n\u00ddTSO\u00a8 TSOx COMMAND parameters ....\n\nwhere if you are on an ISPF command line, you have to prefix\na TSO command with the word \"TSO\".\n\n    Try em.  You'll like em.\n\n    All the best of everything........\n\nSam\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOB": {"ttr": 7945, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x08'\\x7f\\x13\\x10\\x00\\x1a\\x00\\x1a\\x00\\x00\\xd4\\xe9\\xc5\\xd3\\xc4\\xc5\\xd5@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2008-10-03T13:10:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "MZELDEN"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n/* TRACE ?I */\nparse arg TSOCMD\naddress ISPEXEC \"CONTROL ERRORS RETURN\"\naddress TSO\nddnm = 'DD'||random(1,99999)    /* choose random ddname  */\njunk = msg(off)\n\"ALLOC FILE(\"||ddnm||\") UNIT(VIO) NEW TRACKS SPACE(90,90) DELETE\",\n\" REUSE LRECL(172) RECFM(F B) BLKSIZE(8944)\"\njunk = msg(on)\n/*                                    */\n/*  issue tso commnd and trap output  */\n/*                                    */\njunk=outtrap(LINE.)\nTSOCMD\njunk=outtrap('off')\n/*                                    */\n\"EXECIO\" line.0  \"DISKW\" ddnm \"(STEM LINE. FINIS\"\naddress ISPEXEC \"LMINIT DATAID(TEMP) DDNAME(\"||ddnm||\")\"\naddress ISPEXEC \"BROWSE DATAID(\"||temp\")\"\naddress ISPEXEC \"LMFREE DATAID(\"||temp\")\"\njunk = msg(off)\n\"FREE FI(\"||ddnm||\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOE": {"ttr": 7947, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x08'\\x7f\\x13\\x10\\x00\\x1a\\x00\\x1a\\x00\\x00\\xd4\\xe9\\xc5\\xd3\\xc4\\xc5\\xd5@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2008-10-03T13:10:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "MZELDEN"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n/* TRACE ?I */\nparse arg TSOCMD\naddress ISPEXEC \"CONTROL ERRORS RETURN\"\naddress TSO\nddnm = 'DD'||random(1,99999)    /* choose random ddname  */\njunk = msg(off)\n\"ALLOC FILE(\"||ddnm||\") UNIT(VIO) NEW TRACKS SPACE(90,90) DELETE\",\n\" REUSE LRECL(172) RECFM(F B) BLKSIZE(8944)\"\njunk = msg(on)\n/*                                    */\n/*  issue tso commnd and trap output  */\n/*                                    */\njunk=outtrap(LINE.)\nTSOCMD\njunk=outtrap('off')\n/*                                    */\n\"EXECIO\" line.0  \"DISKW\" ddnm \"(STEM LINE. FINIS\"\naddress ISPEXEC \"LMINIT DATAID(TEMP) DDNAME(\"||ddnm||\")\"\naddress ISPEXEC \"EDIT   DATAID(\"||temp\")\"\naddress ISPEXEC \"LMFREE DATAID(\"||temp\")\"\njunk = msg(off)\n\"FREE FI(\"||ddnm||\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOR": {"ttr": 7949, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x07\\x11\\x7f\\x01\\x08'\\x7f\\x13\\x10\\x00\\x1f\\x00\\x1f\\x00\\x00\\xd4\\xe9\\xc5\\xd3\\xc4\\xc5\\xd5@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-04-27T00:00:00", "modifydate": "2008-10-03T13:10:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "MZELDEN"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n/**************************************************/\n/* NOTE:  Use of this EXEC requires the REVIEW    */\n/*        command from CBT file 134 or 135.       */\n/**************************************************/\n/* REVIEW command output.  This has an advantage  */\n/* over TSOE/TSOB/TSOV in that it works under     */\n/* native TSO (TSO READY) without ISPF.           */\n/**************************************************/\n/* TRACE ?I */\nparse arg TSOCMD\naddress TSO\nddnm = 'DD'||random(1,99999)    /* choose random ddname  */\njunk = msg(off)\n\"ALLOC FILE(\"||ddnm||\") UNIT(SYSALLDA) NEW TRACKS SPACE(9,9) DELETE\",\n\" REUSE LRECL(172) RECFM(F B) BLKSIZE(8944)\"\njunk = msg(on)\n/*                                    */\n/*  issue tso commnd and trap output  */\n/*                                    */\njunk=outtrap(LINE.)\nTSOCMD\njunk=outtrap('off')\n/*                                    */\n\"EXECIO\" line.0  \"DISKW\" ddnm \"(STEM LINE. FINIS\"\naddress TSO     \"REVIEW       \"||ddnm||\"    FILE\"\njunk = msg(off)\n\"FREE FI(\"||ddnm||\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOV": {"ttr": 7951, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x07\\x11\\x7f\\x01\\x08'\\x7f\\x13\\x10\\x00\\x1f\\x00\\x1f\\x00\\x00\\xd4\\xe9\\xc5\\xd3\\xc4\\xc5\\xd5@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-04-27T00:00:00", "modifydate": "2008-10-03T13:10:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "MZELDEN"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n/****************************************************/\n/* There is really no advantage to using TSOV over  */\n/* TSOE since a temporary data set is used, but     */\n/* to complete the TSO* set of EXECs - here it is.  */\n/****************************************************/\n/* TRACE ?I */\nparse arg TSOCMD\naddress ISPEXEC \"CONTROL ERRORS RETURN\"\naddress TSO\nddnm = 'DD'||random(1,99999)    /* choose random ddname  */\njunk = msg(off)\n\"ALLOC FILE(\"||ddnm||\") UNIT(VIO) NEW TRACKS SPACE(90,90) DELETE\",\n\" REUSE LRECL(172) RECFM(F B) BLKSIZE(8944)\"\njunk = msg(on)\n/*                                    */\n/*  issue tso commnd and trap output  */\n/*                                    */\njunk=outtrap(LINE.)\nTSOCMD\njunk=outtrap('off')\n/*                                    */\n\"EXECIO\" line.0  \"DISKW\" ddnm \"(STEM LINE. FINIS\"\naddress ISPEXEC \"LMINIT DATAID(TEMP) DDNAME(\"||ddnm||\")\"\naddress ISPEXEC \"VIEW   DATAID(\"||temp\")\"\naddress ISPEXEC \"LMFREE DATAID(\"||temp\")\"\njunk = msg(off)\n\"FREE FI(\"||ddnm||\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WAITT": {"ttr": 7953, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x006\\x01\\x19\\x06?\\x01\\x19\\x06O\\x15\\x01\\x019\\x00\\xda\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2019-03-04T00:00:00", "modifydate": "2019-03-05T15:01:36", "lines": 313, "newlines": 218, "modlines": 0, "user": "SBGOLOB"}, "text": "WAITT    TITLE 'TSO COMMAND TO ALLOW RESET OF WAIT TIME CANCEL VALUE'\nWAITT    CSECT ,\nWAITT    RMODE 24\nWAITT    AMODE 31\n*\n         PRINT GEN\n*\n* FUNCTION: ALLOWS A TSO USER TO MODIFY THE TIME VALUE THAT IS USED TO\n*           DETERMINE HOW LONG THE SESSION MAY REMAIN IN A WAIT STATE\n*           BEFORE IT IS CANCELLED (S522 ABEND).  USER MUST HAVE TSO\n*           OPER AUTHORITY, AND THIS COMMAND MUST BE AUTHORIZED IN THE\n*           IKJEFTE2 TABLE (AUTHCMD NAMES ENTRY IN PARMLIB MEMBER\n*           IKJTSOxx).\n*\n* ASSEMBLY MACLIBS:     SYS1.MACLIB\n*\n* LINK EDIT ATTRIBUTES: REUS, AC(1)\n*\n* REQUIREMENTS:   NEED PSCB OPER AUTHORITY TO CHANGE ANYTHING.\n*\n*                 COMMAND MUST BE RUN APF-AUTHORIZED, AND MUST\n*                  BE ENTERED IN THE IKJEFTE2 TABLE.\n*\n* WRITTEN:   AROUND 1989.\n*\n* MODIFIED:  SAM GOLOB  -  MARCH 2019\n*\n* INVOKING: WAITT #####X    (SEE ADDED POWER, BELOW)\n*\n*    WHERE: ##### IS 1 TO 5 DIGIT VALUE\n*\n*               X IS H, M OR S TO SIGNIFY THAT THE VALUE IS HOURS,\n*                 MINUTES OR SECONDS.\n*\n*     NOTE: THE NUMBER OF SECONDS IS CONVERTED INTO WAIT TIME UNITS,\n*           EACH OF WHICH REPRESENTS 1.048576 SECONDS.  SOME VALUES\n*           CAN NOT BE REPRESENTED EXACTLY.  IE: 30 MINUTES IS 1800\n*           SECONDS OR 1716 WAIT UNITS.  WHEN 1716 WAIT UNITS ARE\n*           CONVERTED BACK TO SECONDS, THEY BECOME 1799 SECONDS.\n*           THIS IS NOT A PHENOMENON OF THE COMMAND, BUT OF MVS.\n*\n*    ADDED POWER:   WAITT T  -  EXEMPTS JOB FROM STEP TIMING\n*                   WAITT Z  -  TURNS OF EXEMPTION SWITCH\n*\n*          ASCBRCTF IS X'66' INTO THE ASCB.  X'01' ON, EXEMPTS\n*                                            FROM STEP TIMING.\n*\nFPR0     EQU   0                   FLOATING-POINT  REGISTER 0\n*\nR0       EQU   0                   GENERAL PURPOSE REGISTER 0\nR1       EQU   1                      \"       \"        \"    1\nR2       EQU   2                      \"       \"        \"    2\nR3       EQU   3                      \"       \"        \"    3\nR4       EQU   4                      \"       \"        \"    4\nR5       EQU   5                      \"       \"        \"    5\nR6       EQU   6                      \"       \"        \"    6\nR7       EQU   7                      \"       \"        \"    7\nR8       EQU   8                      \"       \"        \"    8\nR9       EQU   9                      \"       \"        \"    9\nR10      EQU   10                     \"       \"        \"    10\nR11      EQU   11                     \"       \"        \"    11\nR12      EQU   12                     \"       \"        \"    12\nR13      EQU   13                     \"       \"        \"    13\nR14      EQU   14                     \"       \"        \"    14\nR15      EQU   15                     \"       \"        \"    15\n*\n         EJECT ,\n*\n         USING WAITT,R15           TEMPORARY ADDRESSABILITY\n*\nBEGIN    SAVE  (14,12),T,'WAITT      &SYSDATE  &SYSTIME '\n         LA    R12,SAVEAREA        GET ADDRESS OF OUR REG SAVE AREA\n         ST    R13,4(,R12)         PROVIDE BACKWARD\n         ST    R12,8(,R13)          AND FORWARD CHAINING\n         LR    R13,R12             COPY NEW SAVE AREA ADDRESS\n         LR    R12,R15             COPY PROGRAM  BASE ADDRESS\n         DROP  R15                 DROP TEMPORARY ADDRESSABILITY\n         USING WAITT,R12           AND PROVIDE PERMANENT ADDRESSABILITY\n*\n*       APF-AUTHORIZATION CHECK TO BE RUN FIRST..........\n*\n* -- >  Test if this command is being run APF Authorized - below\n         STM   R15,R1,SAVE14T1     Now save registers and test if APF\n         XR    R15,R15                  authorized.\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.\n* -- >  Test if this command is being run APF Authorized - above\n*\n         L     R3,16               GET ADDRESS OF CVT\n         L     R3,0(,R3)            GET ADDRESS OF TCB/ASCB WORDS\n         L     R3,12(,R3)            GET ADDRESS OF OUR ASCB..........\n*\n         LR    R4,R1               COPY PARM/CPPL ADDRESS\n         TM    0(R4),X'80'         IS IT A PARM OR A CPPL ADDRESS\n         BO    SHOWTIME            IF \"CALL\"ED, JUST SHOW THE TIME\n*\n* CHEAP SECURITY CHECK TO TRY TO KEEP UNAUTHORIZED USERS FROM BEING\n* ABLE TO CHANGE THEIR WAIT TIME.  THIS WILL DO THE TRICK IF YOU RUN\n* THE COMMAND FROM A PROTECTED AUTHORIZED LIBRARY, ELSE YOU MAY WANT\n* TO GET A LITTLE MORE EXOTIC.  (I'VE TURNED IT OFF.  YOU ARE WELCOME\n* TO TURN IT BACK ON--THE CODE HAS BEEN LEFT INTACT.)\n*\n         L     R5,8(,R4)           GET POINTER TO PSCB\n         TM    16(R5),X'80'        DO WE HAVE OPER AUTHORITY\n         BO    YESOPER             YES. GO DO OUR THING.\n         BAL   R8,NOOPER           NO. SEND MESSAGE YOU DON'T HAVE IT\n         B     SHOWTEND            AND EXIT.\nYESOPER  DS    0H                  USER HAS PSCB OPER AUTHORITY.\n         B     CHKCOMD             USER CHECK CURRENTLY DISABLED,\n*                                  BUT LEFT IN, IF SOMEBODY WANTS\n*                                  TO USE THE CODE AS A MODEL.\n* ----->    Check user by Userid, code - below\n         LA    R6,VALUSRS          POINT TO START OF VALIDATION TABLE\n*\nCHKUSER  DS    0H\n         CLC   0(7,R5),0(R6)       IS CALLER ALLOWED TO RESET TIME\n         BE    CHKCOMD             YES, CONTINUE\n         LA    R6,20(,R6)          ELSE POINT TO NEXT TABLE ENTRY\n         CLI   0(R6),255           IS IT END OF TABLE\n         BNE   CHKUSER             NO, CONTINUE\n         B     SHOWTIME            ELSE JUST SHOW THE TIME\n* ----->    Check user by Userid, code - above\n*\n* GET INVOKER'S PARM, MAKE SURE IT'S VALID.........................\n*\nCHKCOMD  DS    0H\n         MVC   MNMXVALS,=A(0900,65535,7200)  MIN MAX FOR EVERYBODY\n*        MVC   MNMXVALS,8(R6)      MIN MAX BY USERID TABLE...\n         L     R5,0(,R4)           GET POINTER TO COMMAND BUFFER\n         LH    R6,2(,R5)           GET OFFSET TO COMMAND VARIABLE(S)\n         LTR   R6,R6               ARE THERE ANY VARIABLES\n         BZ    SHOWTIME            NO, SHOW THE CURRENT WAIT VALUE\n         LH    R7,0(,R5)           GET LENGTH OF COMMAND BUFFER\n         SR    R7,R6               SUBTRACT VARIABLE OFFSET FROM LGH.\n         SH    R7,=H'5'            SUBTRACT CONSTANT  FROM LENGTH\n         BM    SHOWTIME             SHOW THE CURRENT WAIT VALUE\n*                                    IF NO VARIABLES ON THE COMMAND\n         LA    R5,4(R5,R6)         POINT TO START OF VARIABLES\n*\n         CH    R7,=AL2(6)          DOES INPUT EXCEED MAXIMUM\n         BNH   *+8                 NO, CONTINUE\n         LA    R7,5                ELSE SET LENGTH TO MAX\n         LA    R1,0(R5,R7)         POINT TO LAST CHARACTER IN VARIABLE\n         OI    0(R1),X'40'         SET LAST CHARACTER TO UPPER-CASE\n         BCTR  R7,R0               DECREMENT LENGTH BY 1\n* ---  Test the parms here  ---  below\n*                                  TEST PARMS HERE\n         CLI   0(R1),C'T'          DO WE WANT TO EXEMPT FROM TIMING?\n         BNE   PASST               NO. BYPASS THAT CODE.\n         BAL   R8,EXEMPTIT         GO EXEMPT JOB.\n         B     SHOWTIME            REPORT RESULTS AND EXIT.\nPASST    DS    0H\n         CLI   0(R1),C'Z'          DO WE WANT TO KILL EXEMPTION?\n         BNE   OTHPARMS            NO. TEST FOR OTHER PARMS.\n         BAL   R8,NOEXEMPT         GO KILL EXEMPTION BIT.\n         B     SHOWTIME            REPORT RESULTS AND EXIT.\nOTHPARMS DS    0H\n         LA    R0,3600             SET MULTIPLIER VALUE FOR HOURS\n         CLI   0(R1),C'H'           IS PARM SPECIFIED AS HOURS\n         BE    VALIDATE              YES, CONTINUE\n         LA    R0,60               SET MULTIPLIER VALUE FOR MINUTES\n         CLI   0(R1),C'M'           IS PARM SPECIFIED AS MINUTES\n         BE    VALIDATE              YES, CONTINUE\n         LA    R0,1                SET MULTIPLIER VALUE FOR SECONDS\n         CLI   0(R1),C'S'           IS PARM SPECIFIED AS SECONDS\n         BNE   SHOWTIME              NO, DON'T ATTEMPT UPDATE\n* ---  Test the parms here  ---  above\n*\n* CONVERT THE HOURS, MINUTES OR SECONDS TO SECONDS & MAKE SURE THAT\n* IT'S WITHIN RANGE;  IF NOT DEFAULT TIME VALUE WILL BE SET........\n*\nVALIDATE STH   R0,DELTAVAL         STORE THE VARIABLE EXTENSION AMOUNT\n         EX    R7,TRANVALS          ENSURE VARIABLE IS ALL NUMERIC\n         BNZ   SHOWTIME              BYPASS UPDATE IF ANY NON-NUMERIC\n         EX    R7,PACKVALS            ELSE PACK THE VARIABLE\n         CVB   R0,DUBLWORD         CONVERT VALUE TO BINARY\n         MH    R0,DELTAVAL         CONVERT VALUE TO SECONDS\n         C     R0,MINTIME          IS REQUESTED VALUE < MINIMUM\n         BNL   *+8                  NO, CONTINUE\n         L     R0,DEFTIME            ELSE RESET TO DEFAULT VALUE\n         C     R0,MAXTIME          IS REQUESTED VALUE > MAXIMUM\n         BNH   *+8                  NO, CONTINUE\n         L     R0,DEFTIME            ELSE RESET TO DEFAULT VALUE\n         O     R0,SHORTZER         MAKE BINARY VALUE UNNORM F/P VALUE\n         ST    R0,DUBLWORD         STORE THE F/P VALUE\n         LE    FPR0,DUBLWORD       LOAD VALUE INTO F/P REGISTER\n         DE    FPR0,=E'1.048576'   CONVERT FROM SECONDS TO WAIT UNITS\n         AU    FPR0,SHORTZER       MAKE IT UN-NORMALIZED F/P VALUE\n         STE   FPR0,DUBLWORD       STORE THE VALUE\n         MVI   DUBLWORD,0          STRIP THE SIGN & EXPONENT\n         BAL   R8,WAITRSET         RESET THE WAIT TIME IN ASCB\n*\nSHOWTIME L     R0,X'C4'(,R3)       PICK UP ASCB WAIT TIME VALUE\n         O     R0,SHORTZER         MAKE BINARY VALUE UNNORM F/P VALUE\n         ST    R0,DUBLWORD         STORE THE F/P VALUE\n         LE    FPR0,DUBLWORD       LOAD VALUE INTO F/P REGISTER\n         ME    FPR0,=E'1.048576'   CONVERT FROM WAIT UNITS TO SECONDS\n         AE    FPR0,=E'0.5'        ROUND SECONDS\n         AU    FPR0,SHORTZER       MAKE IT UN-NORMALIZED F/P VALUE\n         STE   FPR0,DUBLWORD       STORE THE VALUE\n         MVI   DUBLWORD,0          STRIP THE SIGN & EXPONENT\n         L     R0,DUBLWORD         PICK UP THE BINARY VALUE\n         CVD   R0,DUBLWORD         CONVERT IT TO DECIMAL\n         ED    CURSECS,DUBLWORD+5  EDIT IT INTO THE MESSAGE\n         TPUT  CURMSG,L'CURMSG     OUTPUT THE MESSAGE TO TERMINAL\n*\n         TM    X'66'(R3),X'01'     CHECK IF EXEMPTION IS ON\n         BO    PRTYEXMT            YES. TELL US SO.\n         TPUT  NTEXMPT,L'NTEXMPT   NO. TELL US THAT AS WELL.\n         B     SHOWTEND\nPRTYEXMT DS    0H\n         TPUT  ISEXMPT,L'ISEXMPT   MESSAGE THAT WE'RE EXEMPT.\n*\nSHOWTEND DS    0H\n         L     R13,4(,R13)         GET ADDRESS OF PREVIOUS SAVE AREA\n         RETURN (14,12),T,RC=0      AND TERMINATE TASK WITH R/C = ZERO\n*\nNOTAUTH  TPUT  NAUTHMS,L'NAUTHMS\n         B     SHOWTEND\n*\nTRANVALS TRT   0(0,R5),TRTABLE     *** EXECUTED INSTRUCTION ***\nPACKVALS PACK  DUBLWORD,0(0,R5)    *** EXECUTED INSTRUCTION ***\n*\n* IN CASE YOU WANT TO CHECK THIS CODE OUT BEFORE INSTALLING, SET THE\n* FOLLOWING NOP TO A BRANCH AND RUN IT;   IT'LL DO EVERYTHING EXCEPT\n* ACTUALLY GETTING INTO AUTHORIZED STATE AND MODIFYING THE ASCB.....\n*\nWAITRSET L     R0,DUBLWORD         *** FOR TESTING,\n         NOP   4(,R8)                  SET NOP TO BRANCH ***\n*\n* IF YOU USE A \"SECRET\" SVC TO GET INTO AUTHORIZED STATE (INSTEAD OF\n* RUNNING FROM AUTHORIZED LIBRARY), HERE'S WHERE TO CODE IT.........\n*\n         MODESET KEY=ZERO,MODE=SUP\n         MVC   X'C4'(4,R3),DUBLWORD MOVE NEW VALUE INTO ASCB\n         MODESET KEY=NZERO,MODE=PROB\n*\n* IF YOU USE A \"SECRET\" SVC TO GET INTO AUTHORIZED STATE, HERE'S WHERE\n* YOU WANT TO  GET BACK OUT INTO UNAUTHORIZED STATE.................\n*\n         BR    R8\n*\n* ------ >  Code to turn on exemption bit in the ASCBRCTF field\nEXEMPTIT DS    0H                     Need APF-Authorization here\n         MODESET KEY=ZERO,MODE=SUP\n         OI    X'66'(R3),X'01'\n         MODESET KEY=NZERO,MODE=PROB\n*                                     Don't need authorization here\n         TPUT  Q522MSG,L'Q522MSG      Say we are exempt from timing\n         BR    R8\n*\n* ------ >  Code to turn off exemption bit in the ASCBRCTF field\nNOEXEMPT DS    0H                     Need APF-Authorization here\n         MODESET KEY=ZERO,MODE=SUP\n         NI    X'66'(R3),X'FF'-X'01'\n         MODESET KEY=NZERO,MODE=PROB\n*                                     Don't need authorization here\n         TPUT  NONEXMT,L'NONEXMT      Say we're not exempt from timing\n         BR    R8\n*\nNOOPER   DS    0H\n         TPUT  OPERMSG,L'OPERMSG      Say we need OPER authority\n         BR    R8\n*\n         LTORG ,\nSAVEAREA DC    8D'0'               REGISTER SAVE AREA\nSAVE14T1 DC    2D'0'\n*\nDUBLWORD DC    D'0'                DOUBLE-WORD WORK AREA\nSHORTZER DC    X'46000000'         SHORT UNNORMALIZED F/P ZERO\nDELTAVAL DC    H'0'\n*\n         DC    0D'0'\nTRTABLE  DC    256X'04'\n         ORG   TRTABLE+C'0'\n         DC    10X'00'\n         ORG   ,\n*\nMNMXVALS DC    0XL12'0'\nMINTIME  DC    A(0900)\nMAXTIME  DC    A(65535)\nDEFTIME  DC    A(7200)\n*\n* CHEAP SECURITY VERIFICATION TABLE FOLLOWS:\n*\n*    (1) REPLACE 'TSO_UID' WITH THE TSO USER I.D. THAT SHOULD BE\n*        ALLOWED TO ISSUE THIS COMMAND.\n*\n*    (2) SET THE MINIMUM, MAXIMUM AND DEFAULT VALUES TO REFLECT\n*        THE MINIMUM & MAXIMUM NUMBER OF SECONDS THE USER  WILL\n*        BE ALLOWED TO SET AND THE DEFAULT VALUE THAT WILL BE\n*        USED IF HE/SHE ATTEMPTS TO SET A VALUE THAT IS OUTSIDE\n*        THE MIN/MAX RANGE.\n*\nVALUSRS  DC    CL8'TSO_UID1',A(0900,7200,3600) MIN,MAX,DEFAULT SECONDS\n         DC    CL8'TSO_UID2',A(0900,7200,3600)\n*\n         DC    X'FF'               END-OF-TABLE STOPPER...............\n*\n*\nCURMSG   DC    C'CURRENT WAIT TIME VALUE IS: NN,NNN SECONDS'\n         ORG   *-15\nCURSECS  DC    X'4020206B202120'\n         ORG   ,\nQ522MSG  DC    C'JOB MADE EXEMPT FROM STEP TIMING'\nNONEXMT  DC    C'JOB MADE NON-EXEMPT FROM STEP TIMING'\nISEXMPT  DC    C'JOB IS EXEMPT FROM STEP TIMING'\nNTEXMPT  DC    C'JOB NOT EXEMPT FROM STEP TIMING'\nNAUTHMS  DC    C'*** THIS COMMAND MUST BE RUN AUTHORIZED ***'\nOPERMSG  DC    C'*** THIS COMMAND NEEDS OPER AUTHORITY ***'\n         END   BEGIN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WAITT$": {"ttr": 8198, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00)\\x01\\x07\"_\\x01\\x19\\x06O\\x13\\x12\\x00\\x1c\\x00\\x0e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2007-08-13T00:00:00", "modifydate": "2019-03-05T13:12:29", "lines": 28, "newlines": 14, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE826(WAITT)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n ORDER   WAITT\n SETCODE AC(1)\n SETSSI  CB497826\n ENTRY   WAITT\n NAME    WAITT(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WAITT@": {"ttr": 8200, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x06\\x01\\x19\\x06?\\x01\\x19\\x06?#A\\x00*\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-03-04T00:00:00", "modifydate": "2019-03-04T23:41:06", "lines": 42, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": ")F FUNCTION -\n\n  The WAITT command allows you to adjust your job's or TSO\n  session's wait time, by adjusting the ASCBSWTL field in\n  the ASCB.  Optionally, you can turn on, or off, exemption\n  from step timing altogether.\n\n  The way the program is coded:\n\n     The minimum wait time is 900   seconds.\n     The maximum wait time is 65535 seconds.\n\n  And you can code any number in between.\n\n\n)X SYNTAX -\n\n  WAITT    |  nnnnS      nnnn seconds\n           |  mmmM       mmm  minutes\n           |  hhH        hh   hours\n\n  WAITT T  -  EXEMPTS JOB FROM STEP TIMING\n  WAITT Z  -  TURNS OFF EXEMPTION FROM STEP TIMING\n\n           or no operands\n\n)O OPERANDS -\n\n  no operands  -  Then the program shows your current wait time\n                  and also shows if exemption is on or off.\n\n  nnnnS    number followed by S indicates number of seconds\n\n  nnnnM    number followed by M indicates number of minutes\n\n  hhH      number followed by H indicates number of hours\n\n  T        exempts the job from step timing\n\n  Z        turns off the exemption from step timing\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT826/FILE826.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT826", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}