CNCLPG   TITLE 'Make an address space cancelable or non-canclable. '
*  -----------------------------------------------------------------  *
*                                                                     *
*    Function:   To make an address space Cancelable, Non-cancelable, *
*                Forcible, or Non-forcible.                           *
*                                                                     *
*                This is determined by bit settings in the address    *
*                space's CSCB.                                        *
*                                                                     *
*    Syntax:     TSO Command:                                         *
*                                                                     *
*        CNCLPG |jobid ÝASID(hhhh)¨ |CNCL|NCNC|FORC|NFRC              *
*               |ASID(hhhh)         |CNCL|NCNC|FORC|NFRC              *
*               |                   |CSCB or DISP                     *
*               |-  (displays the entire CSCB chain)                  *
*               |?  (displays help)                                   *
*                                                                     *
*    Date:       April 15, 2010                                       *
*                                                                     *
*    Author:     Sam Golob                                            *
*                                                                     *
*    Technical Detail:  PUTLINE interface for TSO Output.             *
*                                                                     *
*                                                                     *
*    Changes:  1.  SWAP, NSWP support dropped from this program.      *
*                                                                     *
*              2.  Messages and DISP improved, to just show matching  *
*                   CSCB chain entries, instead of all of them.       *
*                                                                     *
*  -----------------------------------------------------------------  *
*  This macro lets you display hex values in a report.
         MACRO
&NAME    HEX   &TO,&LEN,&FROM
&NAME    STM   R15,R1,HEXSAVE           Save work registers.
         LA    R1,&FROM                 Load from address.
         LA    R0,&LEN                  Load length of hex number.
         LA    R15,&TO                  Load to address.
         BAL   R9,HEX                   BAL to routine.
         LM    R15,R1,HEXSAVE           Restore work registers.
         MEND
*  -----------------------------------------------------------------  *
*  --           Create PUTLINE environment.                       --  *
*  -----------------------------------------------------------------  *
         MACRO
&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &
               &LEN,                    @LENGTH OF MESSAGE             &
               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &
               &EPA=                    EPUTL EPA
.*
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*
.*  --> E@PUT
.*
.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.
.*
.*
.*  ARGUMENTS: -----------------------------------------------------
.*
.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL
.*
.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)
.*
.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT
.*            COMPATIBILITY.
.*
.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE
.*
.*
.*   EXAMPLES: -----------------------------------------------------
.*
.*      1) APUT  'LITERAL'
.*
.*      2) APUT  (R3),80
.*
.*      3) APUT  LABEL
.*
.*      4) APUT  LABEL,40
.*
.*
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*
.*
.*  LOCAL SET SYMBOLS
.*
         LCLC  &SMA                     MESSAGE ADDRESS (REG)
         LCLC  &SML                     MESSAGE LENGTH (REG)
         LCLC  &SEP                     EPA (REGISTER)
.*
         LCLC  &L1,&L2,&L3              LOCAL LABELS
.*
&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS
&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS
&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS
.*
.*
.*  MESSAGE ADDRESS
.*
         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*
.*                                                          *HMD 11/86*
&LABEL   DS    0H                                           *HMD 11/86*
.*                                                          *HMD 11/86*
.A0500   ANOP                                               *HMD 11/86*
         AIF   ('&MSG' NE '').A2000
         MNOTE 8,'''&MSG='' MISSING / REQUIRED'
         MEXIT
.*
.A2000   ANOP
         AIF   ('&MSG'(1,1) NE '(').A2400
&SMA     SETC  '&MSG'(2,K'&MSG-2)
         LR    R1,&SMA                  @MESSAGE TEXT
         AGO   .A2600
.*
.A2400   ANOP
         AIF   ('&MSG'(1,1) NE '''').A2500
         B     &L3                      BRANCH AROUND MESSAGE
&L2      DC    C&MSG
&L3      DS    0H
         LA    R1,&L2                   @MESSAGE
         AGO   .A2600
.*
.A2500   ANOP
         LA    R1,&MSG                  @MESSAGE TEXT
.A2600   ANOP
.*
.*  MESSAGE LENGTH
.*
         AIF   ('&LEN' NE '').A3000
         AIF   ('&MSG'(1,1) NE '''').A2800
         LA    R0,L'&L2                 MESSAGE LENGTH
         AGO   .A3600
.*
.A2800   ANOP
         AIF   ('&MSG'(1,1) EQ '(').A2900
         LA    R0,L'&MSG                MESSAGE LENGTH
         AGO   .A3600
.*
.A2900   ANOP
         MNOTE 8,'''LEN'' MISSING / REQUIRED'
         MEXIT
.*
.A3000   ANOP
         AIF   ('&LEN'(1,1) NE '(').A3400
&SML     SETC  '&LEN'(2,K'&LEN-2)
         LR    R0,&SML                  MESSAGE LENGTH
         AGO   .A3600
.*
.A3400   ANOP
         LA    R0,&LEN                  MESSAGE LENGTH
.A3600   ANOP
.*
.*  RSA
.*
         AIF   ('&RSA' EQ '').A4900
         ST    R14,&RSA                 SAVE REGS 14
.A4900   ANOP
.*
.*  ENTRY POINT
.*
         AIF   ('&EPA' NE '').A5000
         L     R15,=V(EPUTL)            EPA
         AGO   .A5600
.*
.A5000   AIF   ('&EPA'(1,1) NE '(').A5400
&SEP     SETC  '&EPA'(2,K'&EPA-2)
         LR    R15,&SEP                 EPA
         AGO   .A5600
.*
.A5400   ANOP
         L     R15,&EPA                 EPA
.*
.A5600   ANOP
.*
.*  CALL LINKAGE
.*
.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE
.*
         AIF   ('&RSA' EQ '').A6900
         L     R14,&RSA                 RESTORE R14
.A6900   ANOP
.*
.AMEND   MEND
* ------------------------------------------------------------------- *
* --       End of Internal Macros......                            -- *
* ------------------------------------------------------------------- *
         SPACE 3
CNCLPG   CSECT
CNCLPG   AMODE 31
CNCLPG   RMODE ANY
         YREGS
         USING CNCLPG,R15          (Establish temporary base).
         B     BEGIN               Skip over eyecatcher.
EYEC0    DC    AL1(EYECL)          Exclusive length of header.
EYEC     DC    C' CNCLPG - &SYSDATE - &SYSTIME -'
         DC    C'     --------------------------------    '
         DC    C' VER 1.0.0   '
         DC    C'                   '
EYECL    EQU   *-EYEC
         DROP  R15                 (DROP TEMPORARY BASE).
BEGIN    STM   R14,R12,12(R13)     Save caller's registers
         LR    R6,R1               Preserve CPPL pointer.
         LR    R12,R15             Copy base.
         USING CNCLPG,R12,R11,R10  (Tell assembler).
         LA    R11,4095(,R12)      Load bases.
         LA    R11,1(,R11)
         LA    R10,4095(,R11)
         LA    R10,1(,R10)
         LR    R14,R13             Copy caller's save area pointer.
         LA    R13,SAVE            Point to my save area.
         ST    R13,8(,R14)         Chain ...
         ST    R14,SAVE+4          ... Save areas.
         SPACE 1
AUTHTEST DS    0H
         ST    R1,SAVER1A
         L     R1,16               CVTPTR
         L     R1,0(,R1)           TCB WORDS
         L     R1,4(,R1)           CURRENT TCB
         L     R1,180(,R1)         TCBJSCB
         L     R1,264(,R1)         JSCBPSCB
         LA    R1,0(,R1)           CLEAR HI ORDER BYTE
         LTR   R1,R1               IS THERE A PSCB
         BZ    NOTFOUND            NO, ISSUE COMMAND-NOT-FOUND MSG
         TM    X'10'(R1),X'80'     PSCB OPER AUTHORITY?
         BZ    NOTFOUND            NO, ISSUE COMMAND-NOT-FOUND MSG
         L     R1,SAVER1A
INITCON  DS    0H                  Initialize some constants.
         MVI   FLAG1,X'00'
         MVI   FLAG2,X'00'
         MVI   ONSWIT,X'00'
         MVI   ERRASID,X'00'
         MVI   CANCINDC,X'00'
         MVI   OUTPUT-1,X'40'
         MVC   OUTPUT,OUTPUT-1
         MVI   NEWCHACT,X'00'
PRTITLE  DS    0H                  Print program title.
         APUT  MESSAGET,L'MESSAGET
         APUT  MESSAGEU,L'MESSAGEU
CONT0    DS    0H                  Look at command's parameters.
         LTR   R6,R6               Any CPPL?
         BZ    EOJ8                No.  Get out.
         L     R1,0(,R6)           Pt to cmd buffer. (R6 reused later)
         LTR   R1,R1               Any CMD buffer?
         BZ    EOJ8                Get out if none.
         LH    R3,0(,R1)           Load length.
         CH    R3,=H'4'            Anything?
         BNH   EOJ4                No. Get out.
         LR    R5,R3               Length of command + 4
         ICM   R5,14,FULLZERO      Clear hi order 3 bytes.
         LH    R3,2(,R1)           Load offset.
         SR    R5,R3               Subtract offset from full length+4
         SH    R5,=H'4'            Correct for length of cmdbufr header
         BC    8,WMESS2            Zero, message to enter userid.
         BC    5,EOJ8              Less, or overflow, out.
PARM     DS    0H
         BAL   R9,GETIDS           Get parameters for the command.
         B     EOJ0
*
* --- Parms gotten at this point.                            -------- *
*
** ---------------------------------------------------------------- **
WMESS2   DS    0H                  Print help messages.
         BAL   R9,PRINTERR
         B     EOJ4
** ---------------------------------------------------------------- **
EOJ0     DS    0H                  End of job.
         APUT  RETURN0,L'RETURN0
         LA    R15,0               Set CC = 0.
         B     RETURN
EOJ4     DS    0H
         APUT  RETURN4,L'RETURN4
         LA    R15,4               Set CC = 4.
         B     RETURN
EOJ8     DS    0H
         APUT  RETURN8,L'RETURN8
         LA    R15,8               Set CC = 8.
         B     RETURN
RETURN   L     R13,SAVE+4
         L     R14,12(,R13)
         LM    R0,R12,20(R13)
         BR    R14
** ---------------------------------------------------------------- **
NOTAUTH  DS    0H                  Command not APF authorized message.
         APUT  MESSAGNA,L'MESSAGNA
         B     EOJ4
** ---------------------------------------------------------------- **
NOTFOUND DS    0H                  Command NOT ALLOWED message.
         APUT  MESSAGAU,L'MESSAGAU
         B     RETURN
** ---------------------------------------------------------------- **
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*        Get the parameters for the command.                      *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*   Notes:  The ASID(xxx) can be coded first, without a userid.   *
*           A dash can be coded first, to run the entire CSCB     *
*            chain and display all the jobnames in it, with       *
*            their associated ASIDs.  ? coded first gives HELP.   *
*           If you code the word CSCB or DISP(lay) after either   *
*            a jobname or an ASID(hhhh) then a display of the     *
*            matching CSCB chain entries will be displayed, and   *
*            no changes will be made.                             *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
GETIDS   DS    0H                  Get all parameters for the program.
         ST    R9,SAVER9A
         ST    R4,SAVER4C
         AR    R1,R3               Point ...
         LA    R1,4(,R1)           ... to char.
         LA    R6,8                Load reg for BCT loop.
         LR    R7,R1               Initialize pointer to first
         LA    R7,0(,R7)                character of the ID field.
         LA    R8,0                Initialize character count.
         MVC   JOBID(8),BLANKS     Clear (first param - JOBNAME) field.
         LA    R4,JOBID            Point reg to beginng of JOBID field.
*
CUTIDLEN DS    0H                  Look at the JOBID field first.
*                                  (May contain ASID( or CSCB.)
*
         CLI   0(R7),X'40'         Is this character a blank?
         BE    NOMORCUT            Yes, we are at the end of the field.
         MVC   0(1,R4),0(R7)       Move only one character at a time.
         OC    JOBID(8),BLANKS     And uppercase the partial jobid.
*
*   Is this a run of the CSCB chain only?
* -- >  Test for CSCB  first  ---- below
         CLI   JOBID,C'-'          Did we code '-' first?
         BNE   CSCBHELP            No. Try if help asked for.
         B     CSCBRUN1            Yes. Run entire CSCB chain.
* - > Help
CSCBHELP DS    0H
         CLI   JOBID,C'?'          Help?
         BNE   NOCSCB              No. Skip this code.
         BAL   R9,PRINTERR         Yes. Print messages
         B     EOJ0                  and get out with code 0.
* - > Help
CSCBRUN1 DS    0H
         ST    R8,SAVER8A          Store count for display if needed.
         OI    FLAG2,X'40'         Mark that this is CSCB only run.
         BAL   R9,RUNCSCB          Do the run for CSCB chain.
         B     EOJ0                Out with normal return code.
NOCSCB   DS    0H
* -- >  Test for CSCB  first  ---- above
*
*   Was the ASCB(hhh) parameter coded without the jobid?
* -- >  Test for ASID( first  ---- below
         CLC   JOBID(L'ASIDC),ASIDC  Did we code ASID( in jobid field?
         BNE   NOASIDF             No. Pass this code.
         OI    FLAG1,X'01'         Flag that ASID( ) was first.
         NI    FLAG1,X'FF'-X'02'   Turn off Jobname in jobid field flag
         MVC   ASIDWKL(L'ASIDC),JOBID  Move the ASID( to proper field.
         MVC   JOBID,BLANKS        Blank out Job ID if ASID( coded.
         LA    R7,1(,R7)           Bump another character.
         LA    R8,1(,R8)           Count another character.
         LA    R6,1                Set number of branches later.
*                                  This will limit number of params
*                                   that are searched for.
         B     ASIDONLY            Bypass all the real jobname stuff.
* -- >  Test for ASID( first  ---- above
NOASIDF  DS    0H                  ASID( is not the first parameter.
         LA    R4,1(,R4)           Bump another character.
         LA    R7,1(,R7)           Bump another character.
         LA    R8,1(,R8)           Count another character.
         CR    R8,R5               End of command buffer ?
         BNL   NOMORCUT            Yes. Get out now.
         BCT   R6,CUTIDLEN         Try for the next blank, up till 8.
NOMORCUT DS    0H
         STC   R8,SAVCOUNT         Save length of Jobname
         L     R4,SAVER4C          Restore work register for use later.
         OC    JOBID(8),BLANKS     Uppercase the new Job Id.
         OI    FLAG1,X'02'         Set 'Jobname Coded' flag.
*  -  Display the found JOBID - below
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(15),=C'Search Jobname:'
         MVC   OUTPUT+17(8),JOBID
         APUT  OUTPUT,30
         APUT  MESSAGEL,L'MESSAGEL
*  -  Display the found JOBID - above
         LA    R6,1                Set number of branches later.
*                                  This will limit number of params
*                                   that are searched for.
         B     LOOKKEYW
*  Constants - below - ***
JOBID    DC    C'        '         STORE PARM USERID HERE
BLANKS   DC    C'        '         8 BLANKS
MESSAGET DC    C'CNCLPG - Make a Job, STC or TSU Cancelable, etc. (? foX
               r help)'
MESSAGEU DC    C'------ - ---- - ---- --- -- --- ----------- ----'
MESSAGEL DC    C'----------------------------'
MESSAGEM DC    C'-----------------------------------------------'
MESSAG2A DC    C'Enter JOBNAME and/or ASID(hhhh) after COMMAND name,'
MESSAG2B DC    C'   then CNCL, NCNC, FORC, NFRC, or code CSCB or DISP.'
MESSAG2C DC    C'   DISPlay or CSCB will display CSCB chain entries,'
MESSAG2D DC    C'   without changing them.'
MESSAG2E DC    C' When changing a job, we want to be accurate, '
MESSAG2F DC    C'  therefore you should use the DISPlay option first.'
MESSAG2G DC   C' To display the whole CSCB, code - (dash) for JOBNAME.'
MESSAG2H DC    C' To see this help message, code ? for JOBNAME.'
MESSAG2I DC    C'Notes : '
MESSAG2J DC   C' CSCB (DISP) display for an ASID shows all occurrences'
MESSAG2K DC    C'  for that ASID, regardless of JOBNAME.      '
MESSAG2L DC C' CSCB (DISP) display for a JOBNAME shows all occurrences'
MESSAG2M DC    C'  for that JOBNAME, regardless of ASID.      '
MESSAG2N DC    C' CNCL, NCNC, FORC, NFRC will change the first '
MESSAG2O DC    C'  entry in the CSCB chain that matches, if multiple '
MESSAG2P DC    C'  entries exist. But DISP will display ALL applicable'
MESSAG2Q DC    C'  matching entries in the CSCB chain, so you can see'
MESSAG2R DC    C'  which one you want to change specifically.'
MESSAG2S DC    C' When you code BOTH jobname and asid, to CHANGE it,'
MESSAG2T DC    C'  then ONLY that specific job and asid gets changed.'
MESSAGE3 DC    C'WE GOT HERE'
MESSAGE4 DC    C'TEST CHECK THIS'
MESSAGAU DC    C'IKJ56500I COMMAND CNCLPG NOT FOUND'
RETURN0  DC    C'Return code is 0'
RETURN4  DC    C'Return code is 4'
RETURN8  DC    C'Return code is 8'
*                     ***  Places to save registers  ***  below
SAVER1A  DS    F
SAVER3A  DS    F
SAVER3B  DS    F
SAVER3C  DS    F
SAVER3D  DS    F
SAVER3E  DS    F
SAVER4A  DS    F
SAVER4B  DS    F
SAVER4C  DS    F
SAVER5A  DS    F
SAVER7A  DS    F
SAVER8A  DS    F
SAVER9A  DS    F
SAVER9B  DS    F
SAVER9C  DS    F
SAVER9D  DS    F
SAVER9E  DS    F
SAVER9F  DS    F
SAVER9G  DS    F
SAVER9H  DS    F
SAVER9I  DS    F
SAVER9J  DS    F
SAVER9K  DS    F
*                     ***  Places to save registers  ***  above
SAVCOUNT DS    X
DUBLZERO DC    D'0'
FULLZERO DC    F'0'
CANCINDC DC    X'00'
CANCKEY0 DC    X'00'
NEWCHACT DC    X'00'
*  Constants - above - ***
LOOKKEYW DS    0H                  Look for additional keywords.
         LA    R7,1(,R7)           Bump command buffer pointer.
         LA    R8,1(,R8)           Bump character counter.
         CR    R8,R5               End of command buffer?
         BNL   GETIDEND            Yes. Don't look any more.
         MVC   ASIDWKL(5),BLANKS   Clear parameter work field.
         MVC   ASIDWKL(5),0(R7)    Next 5 characters to work field.
ASIDONLY DS    0H                  Jump to here if ASID( coded first.
         OC    ASIDWKL(4),BLANKS   Uppercase work field.
         CLC   ASIDC,ASIDWKL       Is the ASID( keyword there?
         BE    DOASID              Yes. Process it.
         CLC   CNCLC,ASIDWKL       Is the CNCL  keyword there?
         BE    DOCNCL              Yes. Process it.
         CLC   NCNCC,ASIDWKL       Is the NCNC  keyword there?
         BE    DONCNC              Yes. Process it.
         CLC   FORCC,ASIDWKL       Is the FORC  keyword there?
         BE    DOFORC              Yes. Process it.
         CLC   NFRCC,ASIDWKL       Is the NFRC  keyword there?
         BE    DONFRC              Yes. Process it.
         CLC   CSCBC,ASIDWKL       Is the CSCB  keyword there?
         BE    DOCSCB              Yes. Process it.
         CLC   DISPC,ASIDWKL       Is the DISP  keyword there?
         BE    DOCSCB              Yes. Process it.
         B     LOOKKEYW            Go loop and look at next character.
ASIDWKL  DC    CL5' '              Second parameter work area.
*
ASIDC    DC    C'ASID('            Literals....
CNCLC    DC    C'CNCL'
NCNCC    DC    C'NCNC'
FORCC    DC    C'FORC'
NFRCC    DC    C'NFRC'
CSCBC    DC    C'CSCB'
DISPC    DC    C'DISP'
*
DOASID   DS    0H                  Look for hex value of the ASID.
         OI    FLAG1,X'04'         Show that ASID( was coded.
         BAL   R9,GETASID          Go get the rest of the parameters.
         MVC   ASIDWKL(5),BLANKS   Blank out the second wkarea for
*                                   a further parameter search.
         B     LOOKKEYW            Re-loop to look further for params.
*
DOCNCL   DS    0H                  Handle CNCL (cancelable) keyword.
         OI    CANCINDC,X'08'      Show which CHACT bit is affected.
         OI    FLAG2,X'01'         Show that CNCL was coded.
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.
         OI    ONSWIT,X'01'        Set to OR the bits
         NI    ONSWIT,X'FF'-X'02'   and not to AND the bits.
         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.
         BAL   R9,PRNWCSCB         Print the info from the current CSCB
         BAL   R9,FORCHACT         Format the relevant CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Print an underline.
* ------------------------------------------------------------------- *
*                                    Print the action code.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(15),=C'Action code   :'
         MVC   OUTPUT+17(4),CNCLC
         APUT  OUTPUT,25
*                                    Print the bit in CHACT affected.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'
         HEX   OUTPUT+25,1,CANCINDC
         APUT  OUTPUT,30
*
         BCT   R6,LOOKKEYW         Look for another keyword.
         B     GETIDEND            After enough looks, end.
* ------------------------------------------------------------------- *
DONCNC   DS    0H                  Handle NCNC (non-cancelable) keyword
         OI    CANCINDC,X'08'      Show which CHACT bit is affected.
         OI    FLAG2,X'02'         Show that NCNC was coded.
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.
         OI    ONSWIT,X'02'        Set to AND the bits
         NI    ONSWIT,X'FF'-X'01'   and not to OR the bits.
         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.
         BAL   R9,PRNWCSCB         Print the info from the current CSCB
         BAL   R9,FORCHACT         Format the relevant CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Print an underline.
*                                    Print the action code.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(15),=C'Action code   :'
         MVC   OUTPUT+17(4),NCNCC
         APUT  OUTPUT,25
*                                    Print the bit in CHACT affected.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'
         HEX   OUTPUT+25,1,CANCINDC
         APUT  OUTPUT,30
*
         BCT   R6,LOOKKEYW         Look for another keyword.
         B     GETIDEND            After enough looks, end.
* ------------------------------------------------------------------- *
DOFORC   DS    0H                  Handle FORC (forcible) keyword
         OI    FLAG2,X'10'         Show which CHACT bit is affected.
         OI    CANCINDC,X'01'      Show that FORC was coded.
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.
         OI    ONSWIT,X'01'        Set to OR the bits
         NI    ONSWIT,X'FF'-X'02'   and not to AND the bits.
         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.
         BAL   R9,PRNWCSCB         Print the info from the current CSCB
         BAL   R9,FORCHACT         Format the relevant CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Print an underline.
*
         MVC   OUTPUT,OUTPUT-1       Print the action code.
         MVC   OUTPUT(15),=C'Action code   :'
         MVC   OUTPUT+17(4),FORCC
         APUT  OUTPUT,25
*
         MVC   OUTPUT,OUTPUT-1       Print the bit in CHACT affected.
         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'
         HEX   OUTPUT+25,1,CANCINDC
         APUT  OUTPUT,30
*
         BCT   R6,LOOKKEYW         Look for another keyword.
         B     GETIDEND            After enough looks, end.
* ------------------------------------------------------------------- *
DONFRC   DS    0H                  Handle NFRC (non-forcible) keyword
         OI    FLAG2,X'20'         Show which CHACT bit is affected.
         OI    CANCINDC,X'01'      Show that NFRC was coded.
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.
         OI    ONSWIT,X'02'        Set to AND the bits
         NI    ONSWIT,X'FF'-X'01'   and not to OR the bits.
         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.
         BAL   R9,PRNWCSCB         Print the info from the current CSCB
         BAL   R9,FORCHACT         Format the relevant CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Print an underline.
*
         MVC   OUTPUT,OUTPUT-1       Print the action code.
         MVC   OUTPUT(15),=C'Action code   :'
         MVC   OUTPUT+17(4),NFRCC
         APUT  OUTPUT,25
*
         MVC   OUTPUT,OUTPUT-1       Print the bit in CHACT affected.
         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'
         HEX   OUTPUT+25,1,CANCINDC
         APUT  OUTPUT,30
*
         BCT   R6,LOOKKEYW         Look for another keyword.
         B     GETIDEND            After enough looks, end.
* ------------------------------------------------------------------- *
DOCSCB   DS    0H
         OI    FLAG1,X'08'         Show CSCB keyword was coded.
         OI    FLAG2,X'40'         Show CSCB keyword was coded.
         MVC   OUTPUT,OUTPUT-1       Print the action code.
         MVC   OUTPUT(15),=C'Action code   :'
         MVC   OUTPUT+17(4),CSCBC
         MVC   OUTPUT+23(9),=C'(DISPlay)'
         APUT  OUTPUT,35
         BAL   R9,RUNCSCB          Run the CSCB chain with print.
         BCT   R6,LOOKKEYW         Look for another keyword.
         B     GETIDEND            After enough looks, end.
* ------------------------------------------------------------------- *
GETIDEND DS    0H                  End of keyword processing.
         TM    FLAG2,X'7F'         Check if any real actions were asked
         BM    GETKEYNR            Yes, some were.
         APUT  MESSAGEY,L'MESSAGEY    No. Display help messages.
         BAL   R9,PRINTERR
         B     EOJ4                   And end with code = 4.
GETKEYNR DS    0H                  Real actions WERE asked for.
         B     EOJ0                So end with normal return code.
         L     R9,SAVER9A
         BR    R9
** ---------------------------------------------------------------- **
HEX      DS    0H                  Display hex values.
         ST    R9,SAVER9B
         MVC   1(1,R15),0(R1)      Move byte.
         UNPK  0(3,R15),1(2,R15)   Unpack.
         TR    0(2,R15),HEXTAB-240
         LA    R15,2(,R15)         Increment output pointer.
         LA    R1,1(,R1)           Increment input pointer.
         BCT   R0,HEX              Decrement length, then loop.
         MVI   0(R15),C' '         Blank the trailing byte.
         L     R9,SAVER9B
         BR    R9                  Return to caller.
HEXTAB   DC    C'0123456789ABCDEF' Translate table.
** ---------------------------------------------------------------- **
GETASID  DS    0H                  Get hex ASID for 2 bytes.
         ST    R9,SAVER9C          Save registers.
         STM   R1,R6,SAVERGS1
         LA    R6,4                Load BCT register.
         LA    R4,ASIDWK           Point to ASID work area.
         TM    FLAG1,X'02'         Ask if Job name was coded.
         BZ    GETAFL01            Wasn't. Have to adjust pointers.
         LA    R7,5(,R7)           Bump command buffer pointer.
         LA    R8,5(,R8)           Bump character counter.
GETAFL01 DS    0H
GETASIDL DS    0H                  Loop to get hex ASID for 4 display
*                                    bytes to convert to 2 hex bytes.
         CLI   0(R7),C')'          Have we reached close parenthesis?
         BE    GETASIDG            Yes, assume we've got it.
         CLI   0(R7),C' '          Have we hit a blank?
         BE    GETASIDG            Yes, assume we've got it.
         MVC   0(1,R4),0(R7)       Otherwise move one character over.
         LA    R4,1(,R4)           Bump one ASIDWK character (target)
         LA    R7,1(,R7)           Bump command buffer pointer.
         LA    R8,1(,R8)           Bump character counter.
         BCT   R6,GETASIDL         Loop for 4 characters.
         B     GETASIDG            We don't look for more than 4.
GETASIDG DS    0H
*        APUT  ASIDWK,4
         LA    R4,ASIDWK           Point register at workarea again.
         LA    R1,4                Maximum of 4 characters.
GETASIDA DS    0H
         CLI   3(R4),X'40'         Is last character a blank (<4 total)
         BNE   GETASIDM            No. We're finished sliding.
         BCTR  R4,0                Slide the pointer one place back.
         BCT   R1,GETASIDA         Do it no more than 4 times.
GETASIDM DS    0H
         MVC   ASIDMV(4),0(R4)     Move 4 characters so last one
*                                     is not blank.
         MVC   ASIDWKSV(4),ASIDMV    Save these 4 characters
         MVC   ASIDWKS(4),ASIDMV        in two places.
         MVC   OUTPUT,OUTPUT-1       Clear output line.
         MVC   OUTPUT(25),ASIDMSG    Move coded display format asid.
         APUT  OUTPUT,40             And put out the message.
         TR    ASIDMV(4),ASIDVAL     Translate display format message
*                                      into format X'0h0h0h0h'.
         BAL   R9,VALIDTR            Validity check the hex number.
         PACK  ASIDGET(3),ASIDMV(5)  Get rid of all zone nibbles.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(15),=C'Search ASID   :' Print resulting 2-bytes
         HEX   OUTPUT+21,2,ASIDBIN
         APUT  OUTPUT,30
         APUT  MESSAGEL,L'MESSAGEL   Add underline for clear display.
*
GETASIDE DS    0H                    End of routine.
         LM    R1,R6,SAVERGS1        Restore registers
         L     R9,SAVER9C               and
         BR    R9                          exit.
*            Constants associated with this routine.    -    below
ASIDWKB  DC    CL4'    '
ASIDWK   DC    CL4'    '
ASIDWKF  DC    CL4' '
ASIDMV   DC    CL4'    '
ASIDMVF  DC    CL4' '
ASIDBIN  DS    0XL2
ASIDGET  DC    XL4'00000000'

SAVERGS1 DS    6F
*                   Translate table to validity check ASID.
*                     Convert display values to X'0h'
*                     (where h is the hex value).
ASIDVAL  DS    0D
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'00CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CC0A0B0C0D0E0FCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CC0A0B0C0D0E0FCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'00010203040506070809CCCCCCCCCCCC'
FILLER1  DS    CL24
ASIDMSG  DC    CL21'ASID parm entered  : '
ASIDWKSV DC    CL4' '
*            Constants associated with this routine.    -    above
** ---------------------------------------------------------------- **
FINDCSCB DS    0H                  Find CSCB entry to change or report.
         ST    R9,SAVER9D          Save registers.
         ST    R3,SAVER3A
FINDCSST DS    0H                  Get the first CSCB.
         L     R3,16               CVT
         L     R3,X'94'(,R3)       MSER - pointer to CSCB chain.
         ICM   R3,15,0(R3)         First CSCB entry.
         USING CHAIN,R3            Tell assembler.
         BZ    FINDCSEC            If zero, we are at end of CSCB chain
FINDCSLP DS    0H                  Loop through the CSCB entries.
         MVC   CSCBACTF(1),CHACT     Save CSCB ACT flag for this CSCB.
         MVC   CSCBJOBI(8),CHKEY     Save CSCB Jobid (CHKEY).
         MVC   CSCBPROC(8),CHCLS     Save CSCB PROC id (CHCLS).
         MVC   CSCBASID(2),CHASID    Save CSCB ASID (CHASID).
* ------------------------------------------------------------------- *
* We first try to match a JOBID if coded, to the job id in this CSCB. *
* If equal, we see if an ASID has been coded, and both have to match. *
* Otherwise, with no match, we go to the end of the CSCB chain.       *
* ------------------------------------------------------------------- *
FINDCSMY DS    0H                  Find the CSCB that I want.
         TM    FLAG1,X'04'         Was ASID( coded at all?
         BZ    FINDCSJB            No. Just find a JOBID match.
         TM    FLAG1,X'01'         Is the JOB id missing?
         BO    FINDCSAS            Yes, just look for an ASID match.
         TM    FLAG1,X'02'         Was JOB id coded?
         BO    FINDCSJB            Yes. Look for it.
         ICM   R3,15,0(R3)         Go to next CSCB.
         BZ    FINDCSEC            If zero, we are at end of CSCB chain
         B     FINDCSLP            Look at next CSCB entry in table.
FINDCSJB DS    0H                  Check for JOBID match in this CSCB.
         CLC   JOBID(8),CSCBJOBI   Compare coded JOBID to CSCB jobname.
         BE    FINDCSIA            Equal, check if ASID is there.
         ICM   R3,15,0(R3)         Otherwise go to the next CSCB.
         BZ    FINDCSEC            Zero, end of the CSCB chain.
         B     FINDCSLP            Not zero, look at the next entry.
FINDCSIA DS    0H
         TM    FLAG1,X'04'         Was ASID( coded?
         BZ    FINDCSFD            No. Found it on just a job match.
*                                   So this is the first job that
*                                   matched, if there are multiple
*                                   jobs with the same name.
FINDCSAS DS    0H                  Check the ASID in the CSCB.
         CLC   ASIDBIN(2),CSCBASID Is this our ASID? Does it match.
         BE    FINDCSFD            I guess we found it.
         ICM   R3,15,0(R3)         Go to the next CSCB.
         BZ    FINDCSEC            Zero marks the end of the CSCB chain
         B     FINDCSLP            Not zero. Look at the next entry.
FINDCSFD DS    0H                  Our CSCB has been found.
         ST    R3,FOUNCSCB         Save found CSCB address.
         MVC   FOUNACTF,CHACT      Save
         MVC   FOUNJOBI,CHKEY        CSCB
         MVC   FOUNPROC,CHCLS          info.
         MVC   FOUNASID,CHASID
         BAL   R9,PRNTCSCB         Print info from the current CSCB.
         BAL   R9,FORCHACT         Format some CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Put out an underline.
         B     FINDCSEN            Go to end of routine.
         DROP  R3
FINDCSEC DS    0H                  Came to end of CSCB chain.
         APUT  MESSAGEN,L'MESSAGEN   Then put out a message
         B     EOJ4                  And end with code 4.
FINDCSEN DS    0H
         L     R3,SAVER3A
         L     R9,SAVER9D
         BR    R9
*            Constants associated with this routine.    -    below
FOUNCSCB DS    F                   FOUND CSCB ADDRESS
FOUNACTF DC    X'00'
FOUNJOBI DC    CL8' '
FOUNPROC DC    CL8' '
FOUNASID DC    XL2'0000'
CSCBACTF DC    X'00'
CSCBJOBI DC    CL8' '
CSCBPROC DC    CL8' '
CSCBASID DC    XL2'0000'
*            Constants associated with this routine.    -    above
** ---------------------------------------------------------------- **
VALIDTR  DS    0H                  Validate hex characters coded.
         ST    R9,SAVER9E          Save
         STM   R4,R6,SAVEWRK          registers.
         LA    R4,ASIDMV           Point to translated display chars.
         LA    R6,ASIDWKS          Point to chars with error signs.
         LA    R5,4                BCT register - only 4 times.
VALIDTRS DS    0H
         CLI   0(R4),X'CC'         Is this an invalid character?
         BE    VALIDTRR            Yes. Substitute a ? for message.
         LA    R4,1(,R4)           Next translated character.
         LA    R6,1(,R6)           Next char for error message.
         BCT   R5,VALIDTRS         Loop to test validity of this char.
         TM    ERRASID,X'01'       After 4 chars, any errors found?
         BO    VALIDERR            Yes. Write messages.
         B     VALIDTRE            No. Get out of routine.
VALIDTRR DS    0H                  Come here if invalid char found.
         OI    ERRASID,X'01'       Flag that at least one was found.
         MVI   0(R6),C'?'          Substitute a ? for it in message.
         LA    R4,1(,R4)           Next translated character.
         LA    R6,1(,R6)           Next char in error message.
         BCT   R5,VALIDTRS         Check that character for validity.
VALIDERR DS    0H                  Error messages if char is invalid.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(37),ASIDBADM
         APUT  OUTPUT,45
         B     EOJ4                Get out with code 4.
VALIDTRE DS    0H
         L     R4,SAVER4B          Restore regs used in this routine.
         LM    R4,R6,SAVEWRK
         BR    R9
*            Constants associated with this routine.    -    below
ERRASID  DC    X'00'
SAVEWRK  DS    3F
MSGBADPR DC    C'Bad ASID entered. Use end parenthesis ) to delimit.'
ASIDBADM DC    CL33'Bad Characters marked with a ?:  '
ASIDWKS  DC    CL4' '
*            Constants associated with this routine.    -    above
** ---------------------------------------------------------------- **
* -- -- -- -- -- -- -- -- -- -- -- --    R3 points to a CSCB address
PRNTCSCB DS    0H                  Print a CSCB entry.
         ST    R9,SAVER9F          Save BAL register.
         ST    R3,SAVECSCB         Saved found CSCB address.
         USING CHAIN,R3
*                   Print info from current CSCB
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'Job  ID :'
         MVC   OUTPUT+11(8),CHKEY
         APUT  OUTPUT,25
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'Proc ID :'
         MVC   OUTPUT+11(8),CHCLS
         APUT  OUTPUT,25
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'ASID    :'
         HEX   OUTPUT+11,2,CHASID
         APUT  OUTPUT,25
         TM    FLAG2,X'40'
         BO    PRNTCSC1
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(21),=C'Previous CHACT Flags:'
         HEX   OUTPUT+23,1,CHACT
         APUT  OUTPUT,25
         B     PRNTCSC2
PRNTCSC1 DS    0H
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(21),=C'Current  CHACT Flags:'
         HEX   OUTPUT+23,1,CHACT
         APUT  OUTPUT,25
PRNTCSC2 DS    0H
         DROP  R3
         L     R3,SAVECSCB         Restore register to what it was.
         L     R9,SAVER9F          Restore BAL register and
         BR    R9                     branch back to caller.
SAVECSCB DS    F                   Saved address of found CSCB.
** ---------------------------------------------------------------- **
RUNCSCB  DS    0H                  Run through the CSCB chain.
         ST    R9,SAVER9G
         ST    R3,SAVER3C
         ST    R7,SAVER7A
RUNCSCBT DS    0H
         TM    FLAG2,X'40'         Only run if CSCB keyword was coded.
         BZ    RUNCSCBE            Not coded, get out.
*                                  Display this is a CSCB chain run.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(40),=C'This is a run of the CSCB Chain only ...'
         APUT  OUTPUT,45
         APUT  MESSAGEL,L'MESSAGEL   Print underline.
*                                  Find the CSCB chain:
         L     R3,16               CVT
         L     R3,X'94'(,R3)       MSER - pointer to CSCB chain.
         ICM   R3,15,0(R3)         First CSCB entry.
         BZ    RUNCSCBE            If zero, end of CSCB chain.
*                                  Otherwise points to next CSCB in
*                                    the table.
         USING CHAIN,R3
RUNCSCBD DS    0H                  Loop through CSCB entries.
         MVC   CSCBACTF(1),CHACT     Save CSCB ACT flag for this CSCB.
         MVC   CSCBJOBI(8),CHKEY     Save CSCB JOBID (CHKEY).
         MVC   CSCBPROC(8),CHCLS     Save CSCB PROC id (CHCLS).
         MVC   CSCBASID(2),CHASID    Save CSCB ASID (CHASID).
*
* -- Limit print of entries to Jobname or ASID only ----  below
         CLI   JOBID,C'-'          Are we printing the whole CSCB?
         BE    RUNCSCBY            Yes.
         CLC   ASIDBIN,=X'0000'    Was an ASID coded for a search?
         BNE   RUNCSCB2            No. Just check for Jobname.
RUNCSCB1 DS    0H                  Check for Jobname match.
         XR    R7,R7               Clear work register.
         IC    R7,SAVCOUNT         Insert saved length of Jobid.
         BCTR  R7,0                Decrement for execute.
         EX    R7,RUNCSCOM         Do the compare for proper length.
*        BNE   RUNCSCBS            Not equal, don't print result.
         BE    RUNCSCBP            Equal, print this CSCB entry.
RUNCSCB2 DS    0H                  Check if ASID was coded.
         CLC   ASIDBIN,CHASID      ASID match?
         BNE   RUNCSCBS            No. Skip print of CSCB entry.
RUNCSCBY DS    0H
* -- Limit print of entries to Jobname or ASID only ----  above
RUNCSCBP DS    0H                  Print this entry....
         BAL   R9,PRNTCSCB         Print of current CSCB information.
         BAL   R9,FORCHACT         Format some CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Print an underline line.
RUNCSCBS DS    0H                  If skipping an entry print, go here.
         ICM   R3,15,0(R3)         Go to next CSCB entry in table.
         BZ    RUNCSCBE            If it is zero, end of CSCB chain.
         B     RUNCSCBD            Not zero, loop to next entry and
*                                    print it.
RUNCSCBE DS    0H                  End of routine.
         L     R3,SAVER3C          Restore
         L     R7,SAVER7A
         L     R9,SAVER9G             registers and
         BR    R9                        go back to caller.
RUNCSCOM CLC   JOBID(*-*),CHKEY   Executed
         DROP  R3
** ---------------------------------------------------------------- **
KEYZERO  DS    0H                  Into Key 0 and change CSCB cntl blk.
         ST    R9,SAVER9H
         ST    R4,SAVER4A
*
* -- >  Test if this command is being run APF Authorized - below
         STM   R15,R1,SAVE14T1     Now save registers and test if APF
         XR    R15,R15                  authorized.
         TESTAUTH FCTN=1           Are we authorized?
         LTR   R15,R15             Test the return code.
         BNZ   NOTAUTH             Not zero, tell not authorized.
         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.
* -- >  Test if this command is being run APF Authorized - above
*
* -- >    ***    Do as little as possible under Key 0.    ***
KEYPRLIM DS    0H
         TM    ONSWIT,X'01'        Are we OR-ing?
         BZ    SWITOFF             No. Try AND-ing?
         MVC   CANCKEY0,CANCINDC   Pre-process affecting bits.
         B     SWITON              All done pre-processing.
SWITOFF  DS    0H
         TM    ONSWIT,X'02'        Are we AND-ing?
         BZ    KEY0BYPS            No. Don't do anything else.
         XC    CANCINDC,=X'FF'     Reverse the affected bits for AND.
         MVC   CANCKEY0,CANCINDC   And move them to staging area.
SWITON   DS    0H
         USING CHAIN,R3
         L     R3,FOUNCSCB         Save address of "found CSCB".
*
* -- >                             We're authorized. Go Key 0.
         MODESET KEY=ZERO
         TM    ONSWIT,X'01'        Are we OR-ing?
         BZ    KEY0OFF             No. Try AND-ing.
         OC    CHACT(1),CANCKEY0   Do the OR.
         B     KEY0END             Out of Key 0.
KEY0OFF  DS    0H
         TM    ONSWIT,X'02'        Are we AND-ing?
         BZ    KEY0END             No. Get out altogether.
         NC    CHACT(1),CANCKEY0   Do the AND.
KEY0END  DS    0H                  Out of Key 0.
         MODESET KEY=NZERO
*
KEY0BYPS DS    0H                  Key 0 bypass - branch to here.
         DROP  R3
         L     R4,SAVER4A
         L     R9,SAVER9H
         BR    R9
** ---------------------------------------------------------------- **
PRNWCSCB DS    0H                  Print the changed CSCB entry.
         ST    R9,SAVER9I          Save BAL register.
         ST    R3,SAVER3D
         L     R3,FOUNCSCB         Saved found CSCB address.
         USING CHAIN,R3
*                   Print info from changed CSCB.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'Job  ID :'
         MVC   OUTPUT+11(8),CHKEY
         APUT  OUTPUT,25
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'Proc ID :'
         MVC   OUTPUT+11(8),CHCLS
         APUT  OUTPUT,25
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'ASID    :'
         HEX   OUTPUT+11,2,CHASID
         APUT  OUTPUT,25
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(21),=C'Modified CHACT Flags:'
         HEX   OUTPUT+23,1,CHACT
         APUT  OUTPUT,25
         APUT  MESSAGEL,L'MESSAGEL
         DROP  R3
         L     R3,SAVER3D          Restore register to what it was.
         L     R9,SAVER9I          Restore BAL register and
         BR    R9                     branch back to caller.
** ---------------------------------------------------------------- **
FORCHACT DS    0H                  Format the CHACT Flags
         ST    R9,SAVER9J          Save
         ST    R3,SAVER3E             registers.
         USING CHAIN,R3
FORCANC0 DS    0H                  Show cancelable or not.
         TM    CHACT,CHCL          Is job cancelable?
         BO    FORCANC1            Yes, show cancelable.
         BZ    FORCANC2            No. Show non-cancelable.
         B     FORFORC0            Fall through, try forceable.
FORCANC1 DS    0H
         MVC   MESSTXT,MESSCAN     Tell em job is cancelable.
         B     FORCANCP
FORCANC2 DS    0H
         MVC   MESSTXT,MESSNCN     Tell em job is non-cancelable.
FORCANCP DS    0H                  Write the actual message out.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(28),FORMTMSG
         APUT  OUTPUT,30
FORFORC0 DS    0H                  Show forceable or not.
         TM    CHACT,CHAFORCE      Is job forceable?
         BO    FORFORC1            Yes, show forceable.
         BZ    FORFORC2            No. Show non-forceable.
FORFORC1 DS    0H
         MVC   MESSTXT,MESSFOR     Tell em job is forceable.
         B     FORFORCP
FORFORC2 DS    0H
         MVC   MESSTXT,MESSNFR     Tell em job is non-forceable.
FORFORCP DS    0H                  Write the actual message out.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(28),FORMTMSG
         APUT  OUTPUT,30
FORCHEND DS    0H
         DROP  R3
         L     R3,SAVER3E          Restore
         L     R9,SAVER9J             registers.
         BR    R9
*            Constants associated with this routine.    -    below
MESSCAN  DC    CL14'Cancelable    '
MESSNCN  DC    CL14'Non-Cancelable'
MESSFOR  DC    CL14'Forcible      '
MESSNFR  DC    CL14'Non-Forcible  '
FORMTMSG DS    0CL28
MESS000  DC    CL14'Job Status:   '
MESSTXT  DC    CL14'              '
*            Constants associated with this routine.    -    above
** ---------------------------------------------------------------- **
PRINTERR DS    0H                    Print help messages.
         ST    R9,SAVER9K            Save BAL register.
         APUT  MESSAG2A,L'MESSAG2A
         APUT  MESSAG2B,L'MESSAG2B
         APUT  MESSAG2C,L'MESSAG2C
         APUT  MESSAG2D,L'MESSAG2D
         APUT  MESSAG2E,L'MESSAG2E
         APUT  MESSAG2F,L'MESSAG2F
         APUT  MESSAGEM,L'MESSAGEM
         APUT  MESSAG2G,L'MESSAG2G
         APUT  MESSAG2H,L'MESSAG2H
         APUT  MESSAGEM,L'MESSAGEM
         APUT  MESSAG2I,L'MESSAG2I
         APUT  MESSAG2J,L'MESSAG2J
         APUT  MESSAG2K,L'MESSAG2K
         APUT  MESSAG2L,L'MESSAG2L
         APUT  MESSAG2M,L'MESSAG2M
         APUT  MESSAG2N,L'MESSAG2N
         APUT  MESSAG2O,L'MESSAG2O
         APUT  MESSAG2P,L'MESSAG2P
         APUT  MESSAG2Q,L'MESSAG2Q
         APUT  MESSAG2R,L'MESSAG2R
         APUT  MESSAG2S,L'MESSAG2S
         APUT  MESSAG2T,L'MESSAG2T
         APUT  MESSAGEM,L'MESSAGEM
         L     R9,SAVER9K            Restore BAL register.
         BR    R9
** ---------------------------------------------------------------- **
** --         C  O  N  S  T  A  N  T  S                          -- **
** ---------------------------------------------------------------- **
MESSAGNA DC    C'Command was not invoked APF authorized.'
MESSAGEN DC    C'End of CSCB chain was reached.'
MESSAGEY DC    C'No valid keyword was coded.'
FLAG1    DC    X'00'
*              X'01'               ASID ONLY - NO JOBNAME
*              X'02'               JOBNAME IS PRESENT.
*              X'04'               ASID( WAS PRESENT IN PARMS.
*              X'08'               CSCB CHAIN DISPLAY ONLY.
FLAG2    DC    X'00'
*              X'01'               CNCL WAS CODED
*              X'02'               NCNC WAS CODED
*              X'04'               SWAP WAS CODED
*              X'08'               NSWP WAS CODED
*              X'10'               FORC WAS CODED
*              X'20'               CSCB WAS CODED
ONSWIT   DC    X'00'
*              X'01'               TURN BIT ON
*              X'02'               TURN BIT OFF
HEXSAVE  DS    3F                  SAVE FOR HEX MACRO
SAVE     DS    9D                  Program Save Area
SAVE14T1 DS    2D                  Save "system-used" registers.
         DC    C' '                Blank before OUTPUT line.
OUTPUT   DC    CL80'  '            Variable output line.
         LTORG
** ---------------------------------------------------------------- **
         SPACE
         TITLE '- MAPPING MACROS.'
         CVT   DSECT=YES           Map the CVT.
         IEECHAIN                  Map the CSCB control block.
         END   CNCLPG
** ---------------------------------------------------------------- **
*  -----------------------------------------------------------------  *
*  --           Create PUTLINE environment.                       --  *
*  -----------------------------------------------------------------  *
EPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&
               OR'
EPUTL    CSECT                                              *HMD 10/85*
         LCLB  &XA                                          *HMD 10/85*
&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*  MODULE NAME  . . . . EPUTL
*
*  ALIASES  . . . . . . NONE
*
*  DATE WRITTEN . . . . 06/85
*  UPDATED      . . . . 04/88                                  HD APR88
*
*  AUTHOR . . . . . . . JIM ELSWORTH
*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88
*
*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR
*
*  PURPOSE:
*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE
*
*
*  DESCRIPTION:
*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.
*    ISSUES SINGLE LINE PUTLINE.
*
*
*  ATTRIBUTES:
*    REENTRANT
*
*  FEATURES:
*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.
*
*  CALLED MODULES:
*    PUTLINE
*
*  ASSUMPTIONS:
*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE
*
*  ABENDS:
*    POSSIBLE 0CX IF BAD ARGUEMNTS
*
*  CAVEATS:
*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB
*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.
*
*
*  INPUT ARGUMENTS:
*    1)  R1 : ADDRESS OF MESSAGE TEXT
*    2)  R0 : LENGTH OF MESSAGE TEXT
*    3) R13 : STANDARD OS SAVE AREA
*    4) R14 : RETURN ADDRESS
*    5) R15 : ENTRY ADDRESS
*
*               ( CONTINUED ... )
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*
*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR
*
RCBA     EQU   100                 BAD MESSAGE ADDRESS
RCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG
*
MAXMSG   EQU   128                 MAXIMUM MESSAGE LENGTH
*
*
*  REGISTERS USED:
*
R0       EQU   0                   MESSAGE LENGTH AT ENTRY
R1       EQU   1                   MESSAGE ADDRESS AT ENTRY
R2       EQU   2                   WORK
RMA      EQU   4                   @MESSAGE TEXT
RML      EQU   5                   MESSAGE LENGTH
RUPT     EQU   6                   @UPT (USER PROFILE TABLE)
RECT     EQU   7                   @ECT
R12      EQU   12                  CSECT BASE
R13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA
R14      EQU   14                  WORK/LINKAGE
R15      EQU   15                  WORK/LINKAGE
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
         IKJCPPL
         EJECT
         IKJTCB   LIST=YES                                  *HMD 10/85*
         EJECT                                              *HMD 10/85*
         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*
         EJECT
         IHAPSA   LIST=YES                                     HD APR88
         EJECT                                                 HD APR88
PUTLDS   DSECT
         DS    18F                      OS SAVE AREA
PUTAAA   EQU   *
PUTECB   DS    F                        ECB
PUTIOPL  DS    4F                       IOPLADS
PUTBLOK  PUTLINE MF=L
PUTLEN   DS    H                        LENGTH
PUTZZZ   DS    H                        RESERVED
PUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA
PUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS
         EJECT
***********************************************************************
*  SET UP LINKAGE
***********************************************************************
         SPACE 1
EPUTL    CSECT
         AIF  (NOT &XA).X001                                *HMD 10/85*
EPUTL    AMODE 31
.X001    ANOP                                               *HMD 10/85*
         STM   14,12,12(13)       SAVE CALLERS REGS
         LR    R12,R15            COPY EPA
         USING EPUTL,R12          ADDRESSABILITY
         AIF   (NOT &XA).X002                               *HMD 10/85*
         GETMAIN RU,              LV=LENGTH                            &
               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &
               LOC=RES            RELATIVE TO 16MB LINE
         AGO   .X003                                        *HMD 10/85*
.X002    ANOP                                               *HMD 10/85*
         GETMAIN RU,              LV=LENGTH                            &
               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA
.X003    ANOP                                               *HMD 10/85*
         ST    1,8(13)            OUR SAVE AREA POINTER
         ST    13,4(1)            POINTER TO CALLERS SAVE AREA
         LR    13,1               @OUR SAVE AREA
         USING PUTLDS,R13         MAP SA AND WORK AREA
         L     R14,4(R13)         POINT TO CALLERS RSA
         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN
         SPACE 2
***********************************************************************
*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE
***********************************************************************
         SPACE 1
         LA    R15,RCBA                 ASSUME BAD ADDRESS
         LTR   RMA,R1                   MESSAGE ADDRESS
         BNP   RETURN                   GOOD ASSUMPTION
         LA    R15,RCBL                 ASSUME BAD LENGTH
         LTR   RML,R0                   POSITIVE?
         BNP   RETURN                   -NO
         C     RML,=A(MAXMSG)           MORE THAN MAX?
         BH    RETURN                   -YES
         SPACE 2
***********************************************************************
*  BUILD PARAMETER LIST
***********************************************************************
         SPACE 1
         LA    R15,4(RML)               MESSAGE LENGTH
         STH   R15,PUTLEN                 PLUS HEADER
         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW
         BCTR  RML,0                    REDUCE FOR MOVE
         EX    RML,PUTMOVE
         EJECT
***********************************************************************
*  DIG UP ADDRESS OF UPT AND ECT
***********************************************************************
         SPACE 1
         L     R2,PSATOLD-PSA           @TCB                   HD APR88
         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA
         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP
         USING CPPL,R2                  MAP CPPL
         L     RUPT,CPPLUPT             @UPT
         L     RECT,CPPLECT             @ECT
         SPACE 2
***********************************************************************
*  ISSUE PUTLINE CALL
***********************************************************************
         SPACE 1
         XC    PUTECB,PUTECB            CLEAR ECB
         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88
         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &
               UPT=(RUPT),              @UPT                           &
               ECT=(RECT),              @ECT                           &
               ECB=PUTECB,              @ECB                           &
               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &
               MF=(E,PUTIOPL)
         EJECT
***********************************************************************
*  RETURN TO CALLER
***********************************************************************
         SPACE 1
RETURN   EQU   *
         LR    2,R13                    @OUR SAVE AREA
         LR    3,R15                    SAVE RETURN CODE
         L     R13,4(R13)               @CALLERS SAVE AREA
         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0
         LR    R15,3                    RESTORE RC
         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS
         SPACE 5
***********************************************************************
*  CONSTANTS AND NON-REENTRANT WORK AREAS
***********************************************************************
         SPACE 1
PUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER
         SPACE 2
         LTORG
         SPACE 2
         END EPUTL
