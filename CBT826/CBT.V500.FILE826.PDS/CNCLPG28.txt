CNCLPG   TITLE 'Make address space cancelable, non-swappable, etc. '
*  -----------------------------------------------------------------  *
*                                                                     *
*    Function:   To make an address space Cancelable or               *
*                Non-Cancelable, Forcible or Non-Forcible,            *
*                Swappable or Non-Swappable.  Or BURN the             *
*                address space (version 1.2.5).  KILL the             *
*                address space is same as BURN, but first             *
*                the non-MEMTERM bits in the ASCB are                 *
*                turned off (version 1.2.6).                          *
*                                                                     *
*                If the address space is non-MEMTERM-able,            *
*                and you try to BURN it, an error message             *
*                is issued, and nothing occurs.  But if you           *
*                try and KILL it, the non-MEMTERM bits are            *
*                turned off, and the address space is whacked.        *
*                The message will tell you so.                        *
*                                                                     *
*    Authority:  You need PSCB OPER authority to run this             *
*                command.  To do BURN, KILL, NMEM, and MEMT           *
*                functions, you ALSO need PSCB ACCOUNT authority.     *
*                Any function controlled by the KILLFLAG, needs       *
*                PSCB ACCOUNT authority.                              *
*                                                                     *
*  -----------------------------------------------------------------  *
*                                                                     *
*    Notes:                                                           *
*                                                                     *
*           CANCELABLE, NON-CANCELABLE, FORCIBLE, NON-FORCIBLE:       *
*                                                                     *
*    CSCB        Cancelable, Non-cancelable, Forcible, Non-forcible   *
*    chain       are determined by bit settings in the address        *
*                space's CSCB, which is part of the CSCB chain.       *
*                                                                     *
*    Jobname     Each active address space has a CSCB in the chain.   *
*    and/or      You get to a particular address space by running     *
*    ASID        the entire CSCB chain (mapped by the IEECHAIN        *
*    match       macro) looking for a match on jobname and/or ASID,   *
*                and preferably on both.                              *
*                                                                     *
*    DISPlay     There may be more than one address space for a       *
*    or          given job name, and more than one CSCB entry         *
*    "CSCB"      for a given ASID.  The CSCB or DISPlay option        *
*    option      of CNCLPG will run the entire CSCB chain and         *
*                it will show ALL the matches for the parameters      *
*                given.  To display the ENTIRE CSCB chain from start  *
*                to finish, use a dash ( - ) instead of the jobname.  *
*                                                                     *
*    Multiple    If only the jobname or the ASID number alone         *
*    jobs        are used to do an ACTION, then CNCLPG will stop      *
*    with the    at the FIRST CSCB which matches, when an ACTION is   *
*    same name   called for (but NOT for a DISPLAY).  That is why     *
*                it is better to run the DISPlay (or CSCB) function   *
*                of CNCLPG first, to display all the possible CSCB    *
*                entries that might match, before changing any        *
*                particular address space.  There might be more       *
*                than one address space with the same jobname or      *
*                ASID, and you want to change only the correct        *
*                one, NOT the wrong one.  So it is good practice      *
*                to display first, and then do a change to the        *
*                exact address space you want to affect, using        *
*                both the jobname and ASID(hhhh) parameters.          *
*                                                                     *
*           SWAPPABLE AND NON-SWAPPABLE:                              *
*                                                                     *
*    SWAP and    Setting an address space to be swappable or          *
*    NSWP need   non-swappable, is accomplished by executing          *
*    to run a    a SYSEVENT macro.  This has to execute in the        *
*    SYSEVENT    target address space, and it was done here by        *
*    macro in    scheduling an SRB to run in the target address       *
*    the         space, when it is different from the address         *
*    target      space running the program.  That piece of code       *
*    address     was written by Joe Reichman.  Thanks, Joe.           *
*    space       You did the hard part!                               *
*                                                                     *
*       NON-MEMTERMABLE AND MEMTERMABLE: (THE REAL "NON-FORCIBLE")    *
*                                                                     *
*    NMEM makes  In the ASCB of an address space there are two        *
*    a job both  bits, ASCBNOMT and less importantly, ASCBNOMD.       *
*    NON-FORCI-  ASCBNOMT controls the attribute, when it is on,      *
*    BLE and     that the address space is NON-MEMTERMABLE or         *
*    NON-CANCEL- NON-FORCIBLE.  If NON-CANCELABLE is also true,       *
*    ABLE.       as well as the non-memtermable bit ASCBNOMT,         *
*                then if you try and cancel the job, it will say,     *
*    MEMT makes  NON-CANCELABLE, and if you try and FORCE the         *
*    the job     job, it will say NON-FORCIBLE.  The two bits         *
*    FORCIBLE,   ASCBNOMT in the ASCB which has to be on, and         *
*    but leaves  the cancelable bit in the job's CSCB entry,          *
*    it to be    CNCL in flag CHACT, which has to be off,             *
*    NON-CANCEL- control this situation.                              *
*    ABLE.                                                            *
*                A job should not be left NON-FORCIBLE and            *
*                CANCELABLE.  That defeats the purpose of             *
*                NON-FORCIBLE, in that the job can easily             *
*                then be cancelled, because CANCEL will work.         *
*                                                                     *
*                The action NMEM (non-memtermable) sets both          *
*                then non-forcible bit in the ASCB on, and the        *
*                cancelable bit in the job's CSCB entry, off.         *
*                The action MEMT (make memtermable) turns only        *
*                the ASCBNOMT bit (non-memtermable) off, but          *
*                leaves the non-cancelable situation in place.        *
*                If you want to turn off non-cancelable later,        *
*                then the CNCL action will do this.                   *
*                                                                     *
*    -------------------------------------------------------------    *
*    BURN        BURN -  Kill the designated address space with a     *
*    (v 1.2.5)   CALLRTM TYPE=MEMTERM (like a FORCE).  Be careful !   *
*    -------------------------------------------------------------    *
*    KILL        KILL -  Kill the designated address space with a     *
*    (v 1.2.6)   CALLRTM TYPE=MEMTERM (like a FORCE).  Be careful !   *
*                KILL is a "super BURN".  Be VERY careful.....!       *
*                Before doing the MEMTERM, KILL turns off bits        *
*                in the ASCB (ASCBNOMT and ASCBNOMD), the             *
*                "non-FORCIBLE" bits.  Can whack any address space.   *
*    (v 1.2.7)   You need PSCB ACCOUNT authority to run BURN or KILL, *
*                along with OPER authority to run the rest of the     *
*                program.                                             *
*    -------------------------------------------------------------    *
*    NMEM and    NMEM will make the address space NON-FORCIBLE        *
*    MEMT        and NON-CANCELABLE.  MEMT will make the address      *
*    (v 1.2.8)   space FORCIBLE, but it will leave the cancelable     *
*                bit in place, however it was before.                 *
*                (Since the FORCE operator command actually equates   *
*                to a CALLRTM TYPE=MEMTERM macro call, making an      *
*                address space NON-FORCIBLE is also called making     *
*                it NON-MEMTERMABLE.                                  *
*    -------------------------------------------------------------    *
*                                                                     *
*    Syntax:     TSO Command:  APF-authorized.                        *
*                                                                     *
*        CNCLPG |jobid ÝASID(hhhh)¨ |CNCL|NCNC|FORC|NFRC|NSWP|SWAP    *
*               |ASID(hhhh)         |CNCL|NCNC|FORC|NFRC|NSWP|SWAP    *
*               |                   |CSCB or DISP                     *
*               |                   |BURN                             *
*               |                   |KILL                             *
*               |                   |NMEM|MEMT                        *
*               |-  (displays the entire CSCB chain)                  *
*               |?  (displays help)                                   *
*                                                                     *
*    Date:       April 15, 2010                                       *
*                                                                     *
*    Latest Modification:   May 21, 2017                              *
*                                                                     *
*    Authors:    Sam Golob, Joe Reichman (who did the hard part)      *
*                                                                     *
*    Technical Detail:  PUTLINE interface for TSO Output.             *
*                       Uses the APUT macro, and EPUTL module.        *
*                                                                     *
*    Changes:  1.  SWAP, NSWP support dropped from this program       *
*                   initially.  Version is 1.0.0.                     *
*                                                                     *
*              2.  Messages and DISP improved, to just show matching  *
*                   CSCB chain entries, instead of all of them.       *
*                   Coding a dash instead of a jobname or asid(hhhh)  *
*                   - will display the entire CSCB chain.             *
*                                                                     *
*              3.  SWAP, NSWP support put back in this program.       *
*                   Version is 1.1.0   (June 16, 2010)                *
*                   It now does your own address space.  The cross    *
*                   memory stuff was not put in yet, to make other    *
*                   address spaces swappable, or non-swappable.       *
*                                                                     *
*              4.  Complete SWAP, NSWP support for cross address      *
*                   space communication, was put in by Joe            *
*                   Reichman.  (Oct 2011)  Version is 1.2.0.          *
*                                                                     *
*              5.  Burn an address space, if that is desired.         *
*                   (Oct 2012)  Version is 1.2.5.                     *
*                                                                     *
*              6.  Kill an address space.  Before you do the          *
*                  CALLRTM MEMTERM, the non-forcible flags in the     *
*                  ASCB are turned off.                               *
*                   (May 2017)  Version is 1.2.6.                     *
*                                                                     *
*              7.  Authority checking. So far, you need PSCB OPER     *
*                   to do anything. ACCT to do BURN or KILL.          *
*                   Version is 1.2.7.                                 *
*                                                                     *
*              8.  Make address space Non-Memtermable (can't be       *
*                   FORCEd), or Memtermable (can be FORCEd).          *
*                   Non-Memtermable implies Non-Cancelable, because   *
*                   it isn't effective if the address space is        *
*                   Cancelable but non-Memtermable).  You can easily  *
*                   get rid of it, and it defeats the purpose of      *
*                   non-Memtermable.  If you later make it            *
*                   Memtermable, you can make it Cancelable next.     *
*                                                                     *
*   Change   Pgmr                   Description                       *
*   -------  -----   ----------------------------------------------   *
*                                                                     *
*            JOER     Add SRB code to allow swapping in xmem.         *
*                     (See lines commented with JOE.)                 *
*                                                                     *
*  -----------------------------------------------------------------  *
*
*  This macro lets you display hex values in a report.
         MACRO
&NAME    HEX   &TO,&LEN,&FROM
&NAME    STM   R15,R1,HEXSAVE           Save work registers.
         LA    R1,&FROM                 Load from address.
         LA    R0,&LEN                  Load length of hex number.
         LA    R15,&TO                  Load to address.
         BAL   R9,HEX                   BAL to routine.
         LM    R15,R1,HEXSAVE           Restore work registers.
         MEND
*  -----------------------------------------------------------------  *
*  --           Create PUTLINE environment.                       --  *
*  -----------------------------------------------------------------  *
         MACRO
&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &
               &LEN,                    @LENGTH OF MESSAGE             &
               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &
               &EPA=                    EPUTL EPA
.*
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*
.*  --> E@PUT
.*
.*  THIS MACRO SETS UP THE PARAMETERS AND INVOKES THE EPUTL ROUTINE.
.*
.*
.*  ARGUMENTS: -----------------------------------------------------
.*
.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL
.*
.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)
.*
.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT
.*            COMPATIBILITY.
.*
.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE
.*
.*
.*   EXAMPLES: -----------------------------------------------------
.*
.*      1) APUT  'LITERAL'
.*
.*      2) APUT  (R3),80
.*
.*      3) APUT  LABEL
.*
.*      4) APUT  LABEL,40
.*
.*
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*
.*
.*  LOCAL SET SYMBOLS
.*
         LCLC  &SMA                     MESSAGE ADDRESS (REG)
         LCLC  &SML                     MESSAGE LENGTH (REG)
         LCLC  &SEP                     EPA (REGISTER)
.*
         LCLC  &L1,&L2,&L3              LOCAL LABELS
.*
&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS
&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS
&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS
.*
.*
.*  MESSAGE ADDRESS
.*
         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*
.*                                                          *HMD 11/86*
&LABEL   DS    0H                                           *HMD 11/86*
.*                                                          *HMD 11/86*
.A0500   ANOP                                               *HMD 11/86*
         AIF   ('&MSG' NE '').A2000
         MNOTE 8,'''&MSG='' MISSING / REQUIRED'
         MEXIT
.*
.A2000   ANOP
         AIF   ('&MSG'(1,1) NE '(').A2400
&SMA     SETC  '&MSG'(2,K'&MSG-2)
         LR    R1,&SMA                  @MESSAGE TEXT
         AGO   .A2600
.*
.A2400   ANOP
         AIF   ('&MSG'(1,1) NE '''').A2500
         B     &L3                      BRANCH AROUND MESSAGE
&L2      DC    C&MSG
&L3      DS    0H
         LA    R1,&L2                   @MESSAGE
         AGO   .A2600
.*
.A2500   ANOP
         LA    R1,&MSG                  @MESSAGE TEXT
.A2600   ANOP
.*
.*  MESSAGE LENGTH
.*
         AIF   ('&LEN' NE '').A3000
         AIF   ('&MSG'(1,1) NE '''').A2800
         LA    R0,L'&L2                 MESSAGE LENGTH
         AGO   .A3600
.*
.A2800   ANOP
         AIF   ('&MSG'(1,1) EQ '(').A2900
         LA    R0,L'&MSG                MESSAGE LENGTH
         AGO   .A3600
.*
.A2900   ANOP
         MNOTE 8,'''LEN'' MISSING / REQUIRED'
         MEXIT
.*
.A3000   ANOP
         AIF   ('&LEN'(1,1) NE '(').A3400
&SML     SETC  '&LEN'(2,K'&LEN-2)
         LR    R0,&SML                  MESSAGE LENGTH
         AGO   .A3600
.*
.A3400   ANOP
         LA    R0,&LEN                  MESSAGE LENGTH
.A3600   ANOP
.*
.*  RSA
.*
         AIF   ('&RSA' EQ '').A4900
         ST    R14,&RSA                 SAVE REGS 14
.A4900   ANOP
.*
.*  ENTRY POINT
.*
         AIF   ('&EPA' NE '').A5000
         L     R15,=V(EPUTL)            EPA
         AGO   .A5600
.*
.A5000   AIF   ('&EPA'(1,1) NE '(').A5400
&SEP     SETC  '&EPA'(2,K'&EPA-2)
         LR    R15,&SEP                 EPA
         AGO   .A5600
.*
.A5400   ANOP
         L     R15,&EPA                 EPA
.*
.A5600   ANOP
.*
.*  CALL LINKAGE
.*
.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE
.*
         AIF   ('&RSA' EQ '').A6900
         L     R14,&RSA                 RESTORE R14
.A6900   ANOP
.*
.AMEND   MEND
* ------------------------------------------------------------------- *
* --       End of Internal Macros......                            -- *
* ------------------------------------------------------------------- *
         SPACE 3
* ------------------------------------------------------------------- *
*   The CSCB chain of control blocks is above the line, so you need   *
*    to have AMODE 31.                                                *
* ------------------------------------------------------------------- *
CNCLPG   CSECT
CNCLPG   AMODE 31
CNCLPG   RMODE ANY
         YREGS
         USING CNCLPG,R15          (Establish temporary base).
         B     BEGIN               Skip over eyecatcher.
EYEC0    DC    AL1(EYECL)          Exclusive length of header.
EYEC     DC    C' CNCLPG - &SYSDATE - &SYSTIME -'
         DC    C'     --------------------------------    '
         DC    C' VER 1.2.8   '
         DC    C'                   '
EYECL    EQU   *-EYEC
         DROP  R15                 (DROP TEMPORARY BASE).
BEGIN    STM   R14,R12,12(R13)     Save caller's registers
         LR    R6,R1               Preserve CPPL pointer.
         LR    R12,R15             Copy base.
         USING CNCLPG,R12,R11,R10  (Tell assembler).
         LA    R11,4095(,R12)      Load bases.
         LA    R11,1(,R11)
         LA    R10,4095(,R11)
         LA    R10,1(,R10)
         LR    R14,R13             Copy caller's save area pointer.
         LA    R13,SAVE            Point to my save area.
         ST    R13,8(,R14)         Chain ...
         ST    R14,SAVE+4          ... Save areas.
*                                  Get PSCBATR1 byte and copy it
         ST    R1,SAVER1A          Save work register
         L     R1,16               CVTPTR
         L     R1,0(,R1)           TCB words
         L     R1,4(,R1)           Current TCB
         L     R1,180(,R1)         TCBJSCB
         L     R1,264(,R1)         JSCBPSCB
         LA    R1,0(,R1)           Clear hi order byte
         LTR   R1,R1               Is there a PSCB ?
         BZ    NOTFOUND            No, Issue COMMAND-NOT-FOUND msg
         MVI   FLAG0,X'00'         Zero FLAG0 for safety
         MVC   FLAG0(1),X'10'(R1)  Overlay it with PSCBATR1
         L     R1,SAVER1A          Restore work register
AUTHTEST DS    0H
         TM    FLAG0,X'80'         PSCB OPER AUTHORITY?
         BZ    NOTFOUND            No, Issue COMMAND-NOT-FOUND msg
INITCON  DS    0H                  Initialize some constants.
         MVI   FLAG1,X'00'
         MVI   FLAG2,X'00'
         MVI   ONSWIT,X'00'
         MVI   RTMCOD,X'00'
         MVI   ERRASID,X'00'
         MVI   CANCINDC,X'00'
         MVI   KILLFLAG,X'00'
         MVI   OUTPUT-1,X'40'
         MVC   OUTPUT,OUTPUT-1
         MVI   NEWCHACT,X'00'
MYASID   DS    0H                  Get my ASID
         L     R2,X'224'           Point to PSAAOLD (my ASCB)
         LA    R2,X'24'(,R2)       Point to my own ASID (ASCBASID)
         MVC   OWNASID(2),0(R2)    Save it for comparison later
         B     PRTITLE             Branch past constant
OWNASID  DS    H
PRTITLE  DS    0H                  Print program title.
         APUT  MESSAGET,L'MESSAGET
         APUT  MESSAGEU,L'MESSAGEU
CONT0    DS    0H                  Look at command's parameters.
         LTR   R6,R6               Any CPPL?
         BZ    EOJ8                No.  Get out.
         L     R1,0(,R6)           Pt to cmd buffer. (R6 reused later)
         LTR   R1,R1               Any CMD buffer?
         BZ    EOJ8                Get out if none.
         LH    R3,0(,R1)           Load length.
         CH    R3,=H'4'            Anything?
         BNH   EOJ4                No. Get out.
         LR    R5,R3               Length of command + 4
         ICM   R5,14,FULLZERO      Clear hi order 3 bytes.
         LH    R3,2(,R1)           Load offset.
         SR    R5,R3               Subtract offset from full length+4
         SH    R5,=H'4'            Correct for length of cmdbufr header
         BC    8,WMESS2            Zero, message to enter userid.
         BC    5,EOJ8              Less, or overflow, out.
PARM     DS    0H
         BAL   R9,GETIDS           Get parameters for the command.
*                                  All the processing hooks off here.
         B     EOJ0
** ---------------------------------------------------------------- **
WMESS2   DS    0H                  Print help messages.
         BAL   R9,PRINTERR
         B     EOJ4
** ---------------------------------------------------------------- **
EOJ0     DS    0H                  End of job.
         APUT  RETURN0,L'RETURN0
         LA    R15,0               Set CC = 0.
         B     RETURN
EOJ4     DS    0H
         APUT  RETURN4,L'RETURN4
         LA    R15,4               Set CC = 4.
         B     RETURN
EOJ8     DS    0H
         APUT  RETURN8,L'RETURN8
         LA    R15,8               Set CC = 8.
         B     RETURN
RETURN   L     R13,SAVE+4
         L     R14,12(,R13)
         LM    R0,R12,20(R13)
         BR    R14
** ---------------------------------------------------------------- **
NOTAUTH  DS    0H                  Command not APF authorized message.
         APUT  MESSAGNA,L'MESSAGNA
         B     EOJ4
** ---------------------------------------------------------------- **
NOTFOUND DS    0H                  Fake command not found message.
         APUT  MESSAGAU,L'MESSAGAU
         B     RETURN
** ---------------------------------------------------------------- **
NOTALLOW DS    0H                  Command NOT ALLOWED message.
         APUT  MESSAGAT,L'MESSAGAT
         B     RETURN
** ---------------------------------------------------------------- **
NOTMEMTM DS    0H                  Address space not MEMTERM-able.
         MVC   MESSAGNM+4(8),FOUNJOBI    Jobname into message
         HEX   MESSAGNM+22,2,FOUNASID    ASID into message
         APUT  MESSAGNM,L'MESSAGNM       Say job Not-Memterm-able
         APUT  MESSAGEL,L'MESSAGEL         and not burned,
         APUT  MESSAGFL,L'MESSAGFL
         BAL   R9,FORCHACT                 But show final status.
         B     RETURN
** ---------------------------------------------------------------- **
* ---           Everything after here is subroutines.            --- *
** ---------------------------------------------------------------- **
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*                Get the parameters for the command.              *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*   Notes:  The ASID(xxx) can be coded first, without a userid.   *
*           A dash can be coded first, to run the entire CSCB     *
*            chain and display all the jobnames in it, with       *
*            their associated ASIDs.  ? coded first gives HELP.   *
*           If you code the word CSCB or DISP(lay) after either   *
*            a jobname or an ASID(hhhh) then a display of ALL     *
*            matching CSCB chain entries will be displayed, and   *
*            no changes will be made.                             *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
GETIDS   DS    0H                  Get all parameters for the program.
         ST    R9,SAVER9A
         ST    R4,SAVER4C
         AR    R1,R3               Point ...
         LA    R1,4(,R1)           ... to char.
         LA    R6,8                Load reg for BCT loop.
         LR    R7,R1               Initialize pointer to first
         LA    R7,0(,R7)                character of the ID field.
         LA    R8,0                Initialize character count.
         MVC   JOBID(8),BLANKS     Clear (first param - JOBNAME) field.
         LA    R4,JOBID            Point reg to beginng of JOBID field.
*
CUTIDLEN DS    0H                  Look at the JOBID field first.
*                                  (May contain ASID( or CSCB.)
*
         CLI   0(R7),X'40'         Is this character a blank?
         BE    NOMORCUT            Yes, we are at the end of the field.
         MVC   0(1,R4),0(R7)       Move only one character at a time.
         OC    JOBID(8),BLANKS     And uppercase the partial jobid.
*
*   Is this a run of the CSCB chain only?
* -- >  Test for CSCB  first  ---- below
         CLI   JOBID,C'-'          Did we code '-' first?
         BNE   CSCBHELP            No. Try if help asked for.
         B     CSCBRUN1            Yes. Run entire CSCB chain.
* - > Help
CSCBHELP DS    0H
         CLI   JOBID,C'?'          Help?
         BNE   NOCSCB              No. Skip this code.
         BAL   R9,PRINTERR         Yes. Print messages
         B     EOJ0                  and get out with code 0.
* - > Help
CSCBRUN1 DS    0H
         ST    R8,SAVER8A          Store count for display if needed.
         OI    FLAG2,X'40'         Mark that this is CSCB only run.
         BAL   R9,RUNCSCB          Do the run for CSCB chain.
         B     EOJ0                Out with normal return code.
NOCSCB   DS    0H
* -- >  Test for CSCB  first  ---- above
*
*   Was the ASCB(hhh) parameter coded without the jobid?
* -- >  Test for ASID( first  ---- below
         CLC   JOBID(L'ASIDC),ASIDC  Did we code ASID( in jobid field?
         BNE   NOASIDF             No. Pass this code.
         OI    FLAG1,X'01'         Flag that ASID( ) was first.
         NI    FLAG1,X'FF'-X'02'   Turn off Jobname in jobid field flag
         MVC   ASIDWKL(L'ASIDC),JOBID  Move the ASID( to proper field.
         MVC   JOBID,BLANKS        Blank out Job ID if ASID( coded.
         LA    R7,1(,R7)           Bump another character.
         LA    R8,1(,R8)           Count another character.
         LA    R6,1                Set number of branches later.
*                                  This will limit number of params
*                                   that are searched for.
         B     ASIDONLY            Bypass all the real jobname stuff.
* -- >  Test for ASID( first  ---- above
NOASIDF  DS    0H                  ASID( is not the first parameter.
         LA    R4,1(,R4)           Bump another character.
         LA    R7,1(,R7)           Bump another character.
         LA    R8,1(,R8)           Count another character.
         CR    R8,R5               End of command buffer ?
         BNL   NOMORCUT            Yes. Get out now.
         BCT   R6,CUTIDLEN         Try for the next blank, up till 8.
NOMORCUT DS    0H
         STC   R8,SAVCOUNT         Save length of Jobname
         L     R4,SAVER4C          Restore work register for use later.
         OC    JOBID(8),BLANKS     Uppercase the new Job Id.
         OI    FLAG1,X'02'         Set 'Jobname Coded' flag.
*  -  Display the found JOBID - below
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(15),=C'Search Jobname:'
         MVC   OUTPUT+17(8),JOBID
         APUT  OUTPUT,30
         APUT  MESSAGEL,L'MESSAGEL
*  -  Display the found JOBID - above
         LA    R6,1                Set number of branches later.
*                                  This will limit number of params
*                                   that are searched for.
         B     LOOKKEYW
*  Constants - below - ***
JOBID    DC    C'        '         STORE PARM USERID HERE
BLANKS   DC    C'        '         8 BLANKS
MESSAGET DC    C'CNCLPG 1.2.8 - Make a Job, STC or TSU Cancelable, etc.X
                (? for help)'
MESSAGEU DC   C'------ ----- - ---- - ---- --- -- --- ----------- ----'
MESSAGEL DC    C'----------------------------'
MESSAGEM DC    C'-----------------------------------------------'
MESSAG2A DC    C'Enter JOBNAME and/or ASID(hhhh) after COMMAND name,'
MESSAG2B DC    C'   then CNCL, NCNC, FORC, NFRC, NSWP, or SWAP. '
MESSAG2V DC    C'To get rid of the address space, code BURN or KILL.'
MESSAG2U DC    C'Or code CSCB or DISP to just display CSCB entries.'
MESSAG2C DC    C'   DISPlay or CSCB will display CSCB chain entries,'
MESSAG2D DC    C'   without changing them.'
MESSAG2E DC    C' When affecting a job, we want to be accurate, '
MESSAG2F DC    C'  therefore you should use the DISPlay option first.'
MESSAG2G DC   C' To display the whole CSCB, code - (dash) for JOBNAME.'
MESSAG2H DC    C' To see this help message, code ? for JOBNAME.'
MESSAG2I DC    C'Notes (important) : '
MESSAG2J DC   C' CSCB (DISP) display for an ASID shows all occurrences'
MESSAG2K DC    C'  for that ASID, regardless of JOBNAME.      '
MESSAG2L DC C' CSCB (DISP) display for a JOBNAME shows all occurrences'
MESSAG2M DC    C'  for that JOBNAME, regardless of ASID.      '
MESSAG2N DC    C' CNCL, NCNC, FORC, NFRC, NSWP, SWAP changes the FIRST'
MESSAG2O DC    C'  entry in the CSCB chain that matches, if multiple '
MESSAG2P DC    C'  entries exist. But DISP will display ALL applicable'
MESSAG2Q DC    C'  matching entries in the CSCB chain, so you can see'
MESSAG2R DC    C'  which one you want to change specifically.'
MESSAG2S DC    C' When you code BOTH jobname and asid, to CHANGE it,'
MESSAG2T DC    C'  then ONLY that specific job and asid gets changed.'
MESSAGE3 DC    C'WE GOT HERE'
MESSAGE4 DC    C'TEST CHECK THIS'
MESSAGNG DC    C'Job was not done. SYSEVENT return code was     '
MESSAGNS DC    C'Job xxxxxxxx for ASID HHHH made non-swappable.'
MESSAGSW DC    C'Job xxxxxxxx for ASID HHHH was made swappable.'
MESSAGAN DC    C'Job xxxxxxxx for ASID HHHH already non-swappable.'
MESSAGAS DC    C'Job xxxxxxxx for ASID HHHH was already swappable.'
MESSAGFN DC    C'Function xxxx was called for.'
MESSAGBU DC    C'Job xxxxxxxx for ASID HHHH has been burned.'
MESSAGKI DC    C'Job xxxxxxxx for ASID HHHH has been killed.'
MESSAGAU DC    C'IKJ56500I COMMAND CNCLPG NOT FOUND'
MESSAGAT DC    C'Lacking authority to execute this command.'
MESSAGNM DC    C'Job xxxxxxxx for ASID HHHH not MEMTERM-able. Not burnex
               d.'
MESSAGM1 DC    C'Job xxxxxxxx for ASID HHHH made non-memtermable.'
MESSAGM2 DC    C'Job xxxxxxxx for ASID HHHH was made memtermable.'
MESSAGFL DC    C'Final Job Status Report.'
RETURN0  DC    C'Return code is 0'
RETURN4  DC    C'Return code is 4'
RETURN8  DC    C'Return code is 8'
*                     ***  Places to save registers  ***  below
SAVER1A  DS    F
SAVER3A  DS    F
SAVER3B  DS    F
SAVER3C  DS    F
SAVER3D  DS    F
SAVER3E  DS    F
SAVER3F  DS    F
SAVER4A  DS    F
SAVER4B  DS    F
SAVER4C  DS    F
SAVER4D  DS    F
SAVER5A  DS    F
SAVER6A  DS    F
SAVER6B  DS    F
SAVER7A  DS    F
SAVER7B  DS    F
SAVER8A  DS    F
SAVER9A  DS    F
SAVER9B  DS    F
SAVER9C  DS    F
SAVER9D  DS    F
SAVER9E  DS    F
SAVER9F  DS    F
SAVER9G  DS    F
SAVER9H  DS    F
SAVER9I  DS    F
SAVER9J  DS    F
SAVER9K  DS    F
SAVER9L  DS    F
SAVER9M  DS    F
SAVER9N  DS    F
*                     ***  Places to save registers  ***  above
SAVCOUNT DS    X
KILLFLAG DS    X
*              X'01'               KILL indicated
*              X'02'               BURN indicated  X'01' also on
*              X'04'               NMEM indicated
*              X'08'               MEMT indicated
DUBLZERO DC    D'0'
FULLZERO DC    F'0'
CANCINDC DC    X'00'
CANCKEY0 DC    X'00'
NEWCHACT DC    X'00'
*  Constants - above - ***
LOOKKEYW DS    0H                  Look for additional keywords.
         LA    R7,1(,R7)           Bump command buffer pointer.
         LA    R8,1(,R8)           Bump character counter.
         CR    R8,R5               End of command buffer?
         BNL   GETIDEND            Yes. Don't look any more.
         MVC   ASIDWKL(5),BLANKS   Clear parameter work field.
         MVC   ASIDWKL(5),0(R7)    Next 5 characters to work field.
ASIDONLY DS    0H                  Jump to here if ASID( coded first.
         OC    ASIDWKL(4),BLANKS   Uppercase work field.
         CLC   ASIDC,ASIDWKL       Is the ASID( keyword there?
         BE    DOASID              Yes. Process it.
         CLC   CNCLC,ASIDWKL       Is the CNCL  keyword there?
         BE    DOCNCL              Yes. Process it.
         CLC   NCNCC,ASIDWKL       Is the NCNC  keyword there?
         BE    DONCNC              Yes. Process it.
         CLC   SWAPC,ASIDWKL       Is the SWAP  keyword there?
         BE    DOSWAP              Yes. Process it.
         CLC   NSWPC,ASIDWKL       Is the NSWP  keyword there?
         BE    DONSWP              Yes. Process it.
         CLC   FORCC,ASIDWKL       Is the FORC  keyword there?
         BE    DOFORC              Yes. Process it.
         CLC   NFRCC,ASIDWKL       Is the NFRC  keyword there?
         BE    DONFRC              Yes. Process it.
         CLC   CSCBC,ASIDWKL       Is the CSCB  keyword there?
         BE    DOCSCB              Yes. Process it.
         CLC   DISPC,ASIDWKL       Is the DISP  keyword there?
         BE    DOCSCB              Yes. Process it.
         CLC   BURNC,ASIDWKL       Is the BURN  keyword there?      BUR
         BE    DOBURN              Yes. Process it.                 BUR
         CLC   KILLC,ASIDWKL       Is the KILL  keyword there?      KIL
         BE    DOKILL              Yes. Process it.                 KIL
         CLC   NMEMC,ASIDWKL       Is the NMEM  keyword there?
         BE    DONMEM              Yes. Process it.
         CLC   MEMTC,ASIDWKL       Is the MEMT  keyword there?
         BE    DOMEMT              Yes. Process it.
         B     LOOKKEYW            Go loop and look at next character.
ASIDWKL  DC    CL5' '              Second parameter work area.
*
ASIDC    DC    C'ASID('            Literals....
CNCLC    DC    C'CNCL'
NCNCC    DC    C'NCNC'
SWAPC    DC    C'SWAP'
NSWPC    DC    C'NSWP'
FORCC    DC    C'FORC'
NFRCC    DC    C'NFRC'
CSCBC    DC    C'CSCB'
DISPC    DC    C'DISP'
BURNC    DC    C'BURN'
KILLC    DC    C'KILL'
NMEMC    DC    C'NMEM'
MEMTC    DC    C'MEMT'
*
DOASID   DS    0H                  Look for hex value of the ASID.
         OI    FLAG1,X'04'         Show that ASID( was coded.
         BAL   R9,GETASID          Go get the rest of the parameters.
         MVC   ASIDWKL(5),BLANKS   Blank out the second wkarea for
*                                   a further parameter search.
         B     LOOKKEYW            Re-loop to look further for params.
*
DOCNCL   DS    0H                  Handle CNCL (cancelable) keyword.
         OI    CANCINDC,X'08'      Show which CHACT bit is affected.
         OI    FLAG2,X'01'         Show that CNCL was coded.
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.
         OI    ONSWIT,X'01'        Set to OR the bits
         NI    ONSWIT,X'FF'-X'02'   and not to AND the bits.
         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.
         BAL   R9,PRNWCSCB         Print the info from the current CSCB
         BAL   R9,FORCHACT         Format the relevant CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Print an underline.
* ------------------------------------------------------------------- *
*                                    Print the action code.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(15),=C'Action code   :'
         MVC   OUTPUT+17(4),CNCLC
         APUT  OUTPUT,25
*                                    Print the bit in CHACT affected.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'
         HEX   OUTPUT+25,1,CANCINDC
         APUT  OUTPUT,30
*
         BCT   R6,LOOKKEYW         Look for another keyword.
         B     GETIDEND            After enough looks, end.
* ------------------------------------------------------------------- *
DONCNC   DS    0H                  Handle NCNC (non-cancelable) keyword
         OI    CANCINDC,X'08'      Show which CHACT bit is affected.
         OI    FLAG2,X'02'         Show that NCNC was coded.
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.
         OI    ONSWIT,X'02'        Set to AND the bits
         NI    ONSWIT,X'FF'-X'01'   and not to OR the bits.
         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.
         BAL   R9,PRNWCSCB         Print the info from the current CSCB
         BAL   R9,FORCHACT         Format the relevant CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Print an underline.
*                                    Print the action code.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(15),=C'Action code   :'
         MVC   OUTPUT+17(4),NCNCC
         APUT  OUTPUT,25
*                                    Print the bit in CHACT affected.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'
         HEX   OUTPUT+25,1,CANCINDC
         APUT  OUTPUT,30
*
         BCT   R6,LOOKKEYW         Look for another keyword.
         B     GETIDEND            After enough looks, end.
* ------------------------------------------------------------------- *
DOSWAP   DS    0H                  Now this routine is operational.
         OI    FLAG2,X'04'         Show that SWAP was coded.
         MVC   MESSAGFN+9(4),SWAPC   Write message to say that.
         APUT  MESSAGFN,L'MESSAGFN
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.
         BAL   R9,KEY0SWNS         Do SYSEVENT OKSWAP, xmem or not.
         BCT   R6,LOOKKEYW
         B     GETIDEND
* ------------------------------------------------------------------- *
DONSWP   DS    0H                  Now this routine is operational.
         OI    FLAG2,X'08'         Show that NSWP was coded.
         MVC   MESSAGFN+9(4),NSWPC   Write message to say that.
         APUT  MESSAGFN,L'MESSAGFN
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.
         BAL   R9,KEY0SWNS         Do SYSEVENT DONTSWAP, xmem or not.
         BCT   R6,LOOKKEYW
         B     GETIDEND
* ------------------------------------------------------------------- *
DOFORC   DS    0H                  Handle FORC (forcible) keyword
         OI    FLAG2,X'10'         Show which CHACT bit is affected.
         OI    CANCINDC,X'01'      Show that FORC was coded.
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.
         OI    ONSWIT,X'01'        Set to OR the bits
         NI    ONSWIT,X'FF'-X'02'   and not to AND the bits.
         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.
         BAL   R9,PRNWCSCB         Print the info from the current CSCB
         BAL   R9,FORCHACT         Format the relevant CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Print an underline.
*
         MVC   OUTPUT,OUTPUT-1       Print the action code.
         MVC   OUTPUT(15),=C'Action code   :'
         MVC   OUTPUT+17(4),FORCC
         APUT  OUTPUT,25
*
         MVC   OUTPUT,OUTPUT-1       Print the bit in CHACT affected.
         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'
         HEX   OUTPUT+25,1,CANCINDC
         APUT  OUTPUT,30
*
         BCT   R6,LOOKKEYW         Look for another keyword.
         B     GETIDEND            After enough looks, end.
* ------------------------------------------------------------------- *
DONFRC   DS    0H                  Handle NFRC (non-forcible) keyword
         OI    FLAG2,X'20'         Show which CHACT bit is affected.
         OI    CANCINDC,X'01'      Show that NFRC was coded.
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.
         OI    ONSWIT,X'02'        Set to AND the bits
         NI    ONSWIT,X'FF'-X'01'   and not to OR the bits.
         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.
         BAL   R9,PRNWCSCB         Print the info from the current CSCB
         BAL   R9,FORCHACT         Format the relevant CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Print an underline.
*
         MVC   OUTPUT,OUTPUT-1       Print the action code.
         MVC   OUTPUT(15),=C'Action code   :'
         MVC   OUTPUT+17(4),NFRCC
         APUT  OUTPUT,25
*
         MVC   OUTPUT,OUTPUT-1       Print the bit in CHACT affected.
         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'
         HEX   OUTPUT+25,1,CANCINDC
         APUT  OUTPUT,30
*
         BCT   R6,LOOKKEYW         Look for another keyword.
         B     GETIDEND            After enough looks, end.
* ------------------------------------------------------------------- *
DOCSCB   DS    0H
         OI    FLAG1,X'08'         Show CSCB keyword was coded.
         OI    FLAG2,X'40'         Show CSCB keyword was coded.
         MVC   OUTPUT,OUTPUT-1       Print the action code.
         MVC   OUTPUT(15),=C'Action code   :'
         MVC   OUTPUT+17(4),CSCBC
         MVC   OUTPUT+23(9),=C'(DISPlay)'
         APUT  OUTPUT,35
         BAL   R9,RUNCSCB          Run the CSCB chain with print.
         BCT   R6,LOOKKEYW         Look for another keyword.
         B     GETIDEND            After enough looks, end.
* ------------------------------------------------------------------- *
GETIDEND DS    0H                  End of keyword processing.
         TM    FLAG2,X'FF'         Check if any real actions asked  BUR
         BNZ   GETKEYNR            Yes, some were.
         APUT  MESSAGEY,L'MESSAGEY    No. Display help messages.
         BAL   R9,PRINTERR
         B     EOJ4                   And end with code = 4.
GETKEYNR DS    0H                  Real actions WERE asked for.
         TM    KILLFLAG,X'FF'      Any of the KILLFLAG options on?
         BZ    SKPKEYNR            No, no extra printout.
         TM    KILLFLAG,X'03'      If kill, then don't need status.
         BNZ   SKPKEYNR
GETKEYNS DS    0H                  Real actions WERE asked for.
         APUT  MESSAGEL,L'MESSAGEL
         APUT  MESSAGFL,L'MESSAGFL
         BAL   R9,FORCHACT         Show summary after actions.
SKPKEYNR DS    0H                  Real actions WERE asked for.
         B     EOJ0                So end with normal return code.
         L     R9,SAVER9A
         BR    R9
** ---------------------------------------------------------------- **
HEX      DS    0H                  Display hex values.
         ST    R9,SAVER9B
         MVC   1(1,R15),0(R1)      Move byte.
         UNPK  0(3,R15),1(2,R15)   Unpack.
         TR    0(2,R15),HEXTAB-240
         LA    R15,2(,R15)         Increment output pointer.
         LA    R1,1(,R1)           Increment input pointer.
         BCT   R0,HEX              Decrement length, then loop.
         MVI   0(R15),C' '         Blank the trailing byte.
         L     R9,SAVER9B
         BR    R9                  Return to caller.
HEXTAB   DC    C'0123456789ABCDEF' Translate table.
** ---------------------------------------------------------------- **
GETASID  DS    0H                  Get hex ASID for 2 bytes.
         ST    R9,SAVER9C          Save registers.
         STM   R1,R6,SAVERGS1
         LA    R6,4                Load BCT register.
         LA    R4,ASIDWK           Point to ASID work area.
         TM    FLAG1,X'02'         Ask if Job name was coded.
         BZ    GETAFL01            Wasn't. Have to adjust pointers.
         LA    R7,5(,R7)           Bump command buffer pointer.
         LA    R8,5(,R8)           Bump character counter.
GETAFL01 DS    0H
GETASIDL DS    0H                  Loop to get hex ASID for 4 display
*                                    bytes to convert to 2 hex bytes.
         CLI   0(R7),C')'          Have we reached close parenthesis?
         BE    GETASIDG            Yes, assume we've got it.
         CLI   0(R7),C' '          Have we hit a blank?
         BE    GETASIDG            Yes, assume we've got it.
         MVC   0(1,R4),0(R7)       Otherwise move one character over.
         LA    R4,1(,R4)           Bump one ASIDWK character (target)
         LA    R7,1(,R7)           Bump command buffer pointer.
         LA    R8,1(,R8)           Bump character counter.
         BCT   R6,GETASIDL         Loop for 4 characters.
         B     GETASIDG            We don't look for more than 4.
GETASIDG DS    0H
*        APUT  ASIDWK,4
         LA    R4,ASIDWK           Point register at workarea again.
         LA    R1,4                Maximum of 4 characters.
GETASIDA DS    0H
         CLI   3(R4),X'40'         Is last character a blank (<4 total)
         BNE   GETASIDM            No. We're finished sliding.
         BCTR  R4,0                Slide the pointer one place back.
         BCT   R1,GETASIDA         Do it no more than 4 times.
GETASIDM DS    0H
         MVC   ASIDMV(4),0(R4)     Move 4 characters so last one
*                                     is not blank.
         MVC   ASIDWKSV(4),ASIDMV    Save these 4 characters
         MVC   ASIDWKS(4),ASIDMV        in two places.
         MVC   OUTPUT,OUTPUT-1       Clear output line.
         MVC   OUTPUT(25),ASIDMSG    Move coded display format asid.
         APUT  OUTPUT,40             And put out the message.
         TR    ASIDMV(4),ASIDVAL     Translate display format message
*                                      into format X'0h0h0h0h'.
*        MVC   OUTPUT,OUTPUT-1       Test display of hex result.
*        HEX   OUTPUT,4,ASIDMV
*        APUT  OUTPUT,10
         BAL   R9,VALIDTR            Validity check the hex number.
         PACK  ASIDGET(3),ASIDMV(5)  Get rid of all zone nibbles.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(15),=C'Search ASID   :' Print resulting 2-bytes
         HEX   OUTPUT+21,2,ASIDBIN
         APUT  OUTPUT,30
         APUT  MESSAGEL,L'MESSAGEL   Add underline for clear display.
*
GETASIDE DS    0H                    End of routine.
         LM    R1,R6,SAVERGS1        Restore registers
         L     R9,SAVER9C               and
         BR    R9                          exit.
** ---------------------------------------------------------------- **
ASIDWKB  DC    CL4'    '
ASIDWK   DC    CL4'    '
ASIDWKF  DC    CL4' '
ASIDMV   DC    CL4'    '
ASIDMVF  DC    CL4' '
ASIDBIN  DS    0XL2
ASIDGET  DC    XL4'00000000'
SAVERGS1 DS    6F
** ---------------------------------------------------------------- JOE
*   GETASCB - return ASCB, given the asid of address space          JOE
*   -------                                                         JOE
*  Input:                                                           JOE
*      FOUNASID = ASID                                              JOE
*  Output:                                                          JOE
*      r15 = 0    Error                                             JOE
*      r15 = ASCB                                                   JOE
** ---------------------------------------------------------------- JOE
GETASCB  DS    0H                                                   JOE
         ST    R9,SAVER9M            Save Register                  JOE
         L     R15,CVTPTR            R15 -> cvt                     JOE
         L     R15,CVTASVT-CVT(,R15)  R15 -> asvt                   JOE
         USING ASVT,R15                                             JOE
         CLC   ASVTASVT-ASVT(4,R15),=C'ASVT'  check eyecatcher      JOE
         BNE   NOASCB                                               JOE
         LA    R15,ASVTENTY-ASVT(,R15) Get first asvt slot          JOE
         LH    R0,FOUNASID           Get asid in question           JOE
         BCTR  R0,0                  Down By 1                      JOE
         SLL   R0,2                  Multiply by 4                  JOE
         AR    R15,R0                Point to ASCB                  JOE
         B     GETASCBE              Exit this routine              JOE
NOASCB   DS    0H                                                   JOE
         XR    R15,R15               Clear r15 - no ASCB there      JOE
GETASCBE DS    0H                                                   JOE
         L     R9,SAVER9M            Restore Register               JOE
         BR    R9                                                   JOE
** ---------------------------------------------------------------- JOE
*                   Translate table to validity check ASID.
*                     Convert display values to X'0h'
*                     (where h is the hex value).
ASIDVAL  DS    0D
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'00CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CC0A0B0C0D0E0FCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CC0A0B0C0D0E0FCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'00010203040506070809CCCCCCCCCCCC'
FILLER1  DS    CL24
ASIDMSG  DC    CL21'ASID parm entered  : '
ASIDWKSV DC    CL4' '
*            Constants associated with this routine.    -    above
** ---------------------------------------------------------------- **
FINDCSCB DS    0H                  Find CSCB entry to change or report.
         ST    R9,SAVER9D          Save registers.
         ST    R3,SAVER3A
FINDCSST DS    0H                  Get the first CSCB.
         L     R3,16               CVT
         L     R3,X'94'(,R3)       MSER - pointer to CSCB chain.
         ICM   R3,15,0(R3)         First CSCB entry.
         USING CHAIN,R3            Tell assembler.
         BZ    FINDCSEC            If zero, we are at end of CSCB chain
FINDCSLP DS    0H                  Loop through the CSCB entries.
         MVC   CSCBACTF(1),CHACT     Save CSCB ACT flag for this CSCB.
         MVC   SAVEACTF(1),CHACT     Save CSCB ACT flag for this CSCB.
         MVC   CSCBJOBI(8),CHKEY     Save CSCB Jobid (CHKEY).
         MVC   CSCBPROC(8),CHCLS     Save CSCB PROC id (CHCLS).
         MVC   CSCBASID(2),CHASID    Save CSCB ASID (CHASID).
* ------------------------------------------------------------------- *
* We first try to match a JOBID if coded, to the job id in this CSCB. *
* If equal, we see if an ASID has been coded, and both have to match. *
* Otherwise, with no match, we go to the end of the CSCB chain.       *
* ------------------------------------------------------------------- *
FINDCSMY DS    0H                  Find the CSCB that I want.
         TM    FLAG1,X'04'         Was ASID( coded at all?
         BZ    FINDCSJB            No. Just find a JOBID match.
         TM    FLAG1,X'01'         Is the JOB id missing?
         BO    FINDCSAS            Yes, just look for an ASID match.
         TM    FLAG1,X'02'         Was JOB id coded?
         BO    FINDCSJB            Yes. Look for it.
         ICM   R3,15,0(R3)         Go to next CSCB.
         BZ    FINDCSEC            If zero, we are at end of CSCB chain
         B     FINDCSLP            Look at next CSCB entry in table.
FINDCSJB DS    0H                  Check for JOBID match in this CSCB.
         CLC   JOBID(8),CSCBJOBI   Compare coded JOBID to CSCB jobname.
         BE    FINDCSIA            Equal, check if ASID is there.
         ICM   R3,15,0(R3)         Otherwise go to the next CSCB.
         BZ    FINDCSEC            Zero, end of the CSCB chain.
         B     FINDCSLP            Not zero, look at the next entry.
FINDCSIA DS    0H
         TM    FLAG1,X'04'         Was ASID( coded?
         BZ    FINDCSFD            No. Found it on just a job match.
*                                   So this is the first job that
*                                   matched, if there are multiple
*                                   jobs with the same name.
FINDCSAS DS    0H                  Check the ASID in the CSCB.
         CLC   ASIDBIN(2),CSCBASID Is this our ASID? Does it match.
         BE    FINDCSFD            I guess we found it.
         ICM   R3,15,0(R3)         Go to the next CSCB.
         BZ    FINDCSEC            Zero marks the end of the CSCB chain
         B     FINDCSLP            Not zero. Look at the next entry.
FINDCSFD DS    0H                  Our CSCB has been found.
         ST    R3,FOUNCSCB         Save found CSCB address.
         MVC   FOUNACTF,CHACT      Save
         MVC   SAVEACTF,CHACT      Save
         MVC   FOUNJOBI,CHKEY        CSCB
         MVC   FOUNPROC,CHCLS          info.
         MVC   FOUNASID,CHASID
         MVC   SAVEASID,CHASID
         BAL   R9,PRNTCSCB         Print info from the current CSCB.
         BAL   R9,FORCHACT         Format some CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Put out an underline.
         B     FINDCSEN            Go to end of routine.
         DROP  R3
FINDCSEC DS    0H                  Came to end of CSCB chain.
         APUT  MESSAGEN,L'MESSAGEN   Then put out a message
         B     EOJ4                  And end with code 4.
FINDCSEN DS    0H
         L     R3,SAVER3A
         L     R9,SAVER9D
         BR    R9
*            Constants associated with this routine.    -    below
FOUNACTF DC    X'00'
SAVEACTF DC    X'00'
FOUNCSCB DS    F                   FOUND CSCB ADDRESS
FOUNJOBI DC    CL8' '
FOUNPROC DC    CL8' '
FOUNASID DC    H'0'
SAVEASID DC    H'0'
CSCBACTF DC    X'00'
CSCBJOBI DC    CL8' '
CSCBPROC DC    CL8' '
CSCBASID DC    H'0'
*            Constants associated with this routine.    -    above
** ---------------------------------------------------------------- **
VALIDTR  DS    0H                  Validate hex characters coded.
         ST    R9,SAVER9E          Save
         STM   R4,R6,SAVEWRK          registers.
         LA    R4,ASIDMV           Point to translated display chars.
         LA    R6,ASIDWKS          Point to chars with error signs.
         LA    R5,4                BCT register - only 4 times.
VALIDTRS DS    0H
         CLI   0(R4),X'CC'         Is this an invalid character?
         BE    VALIDTRR            Yes. Substitute a ? for message.
         LA    R4,1(,R4)           Next translated character.
         LA    R6,1(,R6)           Next char for error message.
         BCT   R5,VALIDTRS         Loop to test validity of this char.
         TM    ERRASID,X'01'       After 4 chars, any errors found?
         BO    VALIDERR            Yes. Write messages.
         B     VALIDTRE            No. Get out of routine.
VALIDTRR DS    0H                  Come here if invalid char found.
         OI    ERRASID,X'01'       Flag that at least one was found.
         MVI   0(R6),C'?'          Substitute a ? for it in message.
         LA    R4,1(,R4)           Next translated character.
         LA    R6,1(,R6)           Next char in error message.
         BCT   R5,VALIDTRS         Check that character for validity.
VALIDERR DS    0H                  Error messages if char is invalid.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(37),ASIDBADM
         APUT  OUTPUT,45
*        MVC   OUTPUT,OUTPUT-1
*        MVC   OUTPUT(51),MSGBADPR
*        APUT  OUTPUT,52
         B     EOJ4                Get out with code 4.
VALIDTRE DS    0H
         L     R4,SAVER4B          Restore regs used in this routine.
         LM    R4,R6,SAVEWRK
         BR    R9
*            Constants associated with this routine.    -    below
ERRASID  DC    X'00'
SAVEWRK  DS    3F
MSGBADPR DC    C'Bad ASID entered. Use end parenthesis ) to delimit.'
ASIDBADM DC    CL33'Bad Characters marked with a ?:  '
ASIDWKS  DC    CL4' '
*            Constants associated with this routine.    -    above
** ---------------------------------------------------------------- **
* -- -- -- -- -- -- -- -- -- -- -- --    R3 points to a CSCB address
PRNTCSCB DS    0H                  Print a CSCB entry.
         ST    R9,SAVER9F          Save BAL register.
         ST    R3,SAVECSCB         Saved found CSCB address.
         USING CHAIN,R3
*                   Print info from current CSCB
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'Job  ID :'
         MVC   OUTPUT+11(8),CHKEY
         APUT  OUTPUT,25
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'Proc ID :'
         MVC   OUTPUT+11(8),CHCLS
         APUT  OUTPUT,25
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'ASID    :'
         HEX   OUTPUT+11,2,CHASID
         APUT  OUTPUT,25
         TM    FLAG2,X'80'                Is this a BURN or KILL?   KIL
         BO    PRNTFINI                   Yes. Abridge the messages BUR
         TM    FLAG2,X'40'                CSCB only run. i.e. DISPLAY
         BO    PRNTCSC1
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(21),=C'Previous CHACT Flags:'
         HEX   OUTPUT+23,1,CHACT
         APUT  OUTPUT,25
         B     PRNTCSC2
PRNTCSC1 DS    0H
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(21),=C'Current  CHACT Flags:'
         HEX   OUTPUT+23,1,CHACT
         APUT  OUTPUT,25
PRNTCSC2 DS    0H
         DROP  R3
PRNTFINI DS    0H                                                   BUR
         L     R3,SAVECSCB         Restore register to what it was.
         L     R9,SAVER9F          Restore BAL register and
*                                     branch back to caller.        BUR
         BR    R9
SAVECSCB DS    F                   Saved address of found CSCB.
** ---------------------------------------------------------------- **
RUNCSCB  DS    0H                  Run through the CSCB chain.
         ST    R9,SAVER9G
         ST    R3,SAVER3C
         ST    R7,SAVER7A
RUNCSCBT DS    0H
         TM    FLAG2,X'40'         Only run if CSCB keyword was coded.
         BZ    RUNCSCBE            Not coded, get out.
*                                  Display this is a CSCB chain run.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(40),=C'This is a run of the CSCB Chain only ...'
         APUT  OUTPUT,45
         APUT  MESSAGEL,L'MESSAGEL   Print underline.
*                                  Find the CSCB chain:
         L     R3,16               CVT
         L     R3,X'94'(,R3)       MSER - pointer to CSCB chain.
         ICM   R3,15,0(R3)         First CSCB entry.
         BZ    RUNCSCBE            If zero, end of CSCB chain.
*                                  Otherwise points to next CSCB in
*                                    the table.
         USING CHAIN,R3
RUNCSCBD DS    0H                  Loop through CSCB entries.
         MVC   CSCBACTF(1),CHACT     Save CSCB ACT flag for this CSCB.
         MVC   SAVEACTF(1),CHACT     Save CSCB ACT flag for this CSCB.
         MVC   CSCBJOBI(8),CHKEY     Save CSCB JOBID (CHKEY).
         MVC   CSCBPROC(8),CHCLS     Save CSCB PROC id (CHCLS).
         MVC   CSCBASID(2),CHASID    Save CSCB ASID (CHASID).
         MVC   SAVEASID(2),CHASID    Save CSCB ASID (CHASID).
*  Test
*        MVC   OUTPUT,OUTPUT-1
*        HEX   OUTPUT,2,CHASID
*        HEX   OUTPUT+6,2,ASIDBIN
*        MVI   OUTPUT+15,C'i'
*        APUT  OUTPUT,25
*  Test
* -- Limit print of entries to Jobname or ASID only ----  below
         CLI   JOBID,C'-'          Are we printing the whole CSCB?
         BE    RUNCSCBY            Yes.
         CLC   ASIDBIN,=X'0000'    Was an ASID coded for a search?
         BNE   RUNCSCB2            No. Just check for Jobname.
RUNCSCB1 DS    0H                  Check for Jobname match.
         XR    R7,R7               Clear work register.
         IC    R7,SAVCOUNT         Insert saved length of Jobid.
         BCTR  R7,0                Decrement for execute.
         EX    R7,RUNCSCOM         Do the compare for proper length.
*        BNE   RUNCSCBS            Not equal, don't print result.
         BE    RUNCSCBP            Equal, print this CSCB entry.
RUNCSCB2 DS    0H                  Check if ASID was coded.
         CLC   ASIDBIN,CHASID      ASID match?
         BNE   RUNCSCBS            No. Skip print of CSCB entry.
RUNCSCBY DS    0H
* -- Limit print of entries to Jobname or ASID only ----  above
RUNCSCBP DS    0H                  Print this entry....
         BAL   R9,PRNTCSCB         Print of current CSCB information.
         BAL   R9,FORCHACT         Format some CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Print an underline line.
RUNCSCBS DS    0H                  If skipping an entry print, go here.
         ICM   R3,15,0(R3)         Go to next CSCB entry in table.
         BZ    RUNCSCBE            If it is zero, end of CSCB chain.
         B     RUNCSCBD            Not zero, loop to next entry and
*                                    print it.
RUNCSCBE DS    0H                  End of routine.
         L     R3,SAVER3C          Restore
         L     R7,SAVER7A
         L     R9,SAVER9G             registers and
         BR    R9                        go back to caller.
RUNCSCOM CLC   JOBID(*-*),CHKEY    Executed
         DROP  R3
** ---------------------------------------------------------------- **
KEYZERO  DS    0H                  Into Key 0 and change CSCB cntl blk.
         ST    R9,SAVER9H
         ST    R4,SAVER4A
*
* -- >  Test if this command is being run APF Authorized - below
         STM   R15,R1,SAVE14T1     Now save registers and test if APF
         XR    R15,R15                  authorized.
         TESTAUTH FCTN=1           Are we authorized?
         LTR   R15,R15             Test the return code.
         BNZ   NOTAUTH             Not zero, tell not authorized.
         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.
* -- >  Test if this command is being run APF Authorized - above
*
* -- >    ***    Do as little as possible under Key 0.    ***
KEYPRLIM DS    0H
         TM    ONSWIT,X'01'        Are we OR-ing?
         BZ    SWITOFF             No. Try AND-ing?
         MVC   CANCKEY0,CANCINDC   Pre-process affecting bits.
         B     SWITON              All done pre-processing.
SWITOFF  DS    0H
         TM    ONSWIT,X'02'        Are we AND-ing?
         BZ    KEY0BYPS            No. Don't do anything else.
         XC    CANCINDC,=X'FF'     Reverse the affected bits for AND.
         MVC   CANCKEY0,CANCINDC   And move them to staging area.
SWITON   DS    0H
         USING CHAIN,R3
         L     R3,FOUNCSCB         Save address of "found CSCB".
*
* -- >                             We're authorized. Go Key 0.
         MODESET KEY=ZERO
         TM    ONSWIT,X'01'        Are we OR-ing?
         BZ    KEY0OFF             No. Try AND-ing.
         OC    CHACT(1),CANCKEY0   Do the OR.
         B     KEY0END             Out of Key 0.
KEY0OFF  DS    0H
         TM    ONSWIT,X'02'        Are we AND-ing?
         BZ    KEY0END             No. Get out altogether.
         NC    CHACT(1),CANCKEY0   Do the AND.
KEY0END  DS    0H                  Out of Key 0.
         MODESET KEY=NZERO
*
KEY0BYPS DS    0H                  Key 0 bypass - branch to here.
         MVC   SAVEACTF(1),CHACT   Record for posterity
         DROP  R3
         L     R4,SAVER4A
         L     R9,SAVER9H
         BR    R9
** ---------------------------------------------------------------- **
PRNWCSCB DS    0H                  Print the changed CSCB entry.
         ST    R9,SAVER9I          Save BAL register.
         ST    R3,SAVER3D
         L     R3,FOUNCSCB         Saved found CSCB address.
         USING CHAIN,R3
*                   Print info from changed CSCB.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'Job  ID :'
         MVC   OUTPUT+11(8),CHKEY
         APUT  OUTPUT,25
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'Proc ID :'
         MVC   OUTPUT+11(8),CHCLS
         APUT  OUTPUT,25
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'ASID    :'
         HEX   OUTPUT+11,2,CHASID
         APUT  OUTPUT,25
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(21),=C'Modified CHACT Flags:'
         HEX   OUTPUT+23,1,CHACT
         APUT  OUTPUT,25
         APUT  MESSAGEL,L'MESSAGEL
         DROP  R3
         L     R3,SAVER3D          Restore register to what it was.
         L     R9,SAVER9I          Restore BAL register and
         BR    R9                     branch back to caller.
** ---------------------------------------------------------------- **
**             REPORT - Format the CHACT Flags - REPORT             **
** ---------------------------------------------------------------- **
FORCHACT DS    0H                  SAVEACTF less volatile than CHACT.
         ST    R9,SAVER9J          Save
         ST    R3,SAVER3E             registers.
         USING CHAIN,R3
FORCANC0 DS    0H                  Show cancelable or not.
         TM    SAVEACTF,CHCL       Is job cancelable?
         BO    FORCANC1            Yes, show cancelable.
         BZ    FORCANC2            No. Show non-cancelable.
         B     FORFORC0            Fall through, try forceable.
FORCANC1 DS    0H
         MVC   MESSTXT,MESSCAN     Tell em job is cancelable.
         B     FORCANCP
FORCANC2 DS    0H
         MVC   MESSTXT,MESSNCN     Tell em job is non-cancelable.
FORCANCP DS    0H                  Write the actual message out.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(28),FORMTMSG
         APUT  OUTPUT,30
FORFORC0 DS    0H                  Show forceable or not.
         TM    SAVEACTF,CHAFORCE   Can you do FORCE w/o CANCEL?
         BO    FORFORC1            Yes. Don't need CANCEL first.
         BZ    FORFORC2            No. Show you need CANCEL first.
FORFORC1 DS    0H
         MVC   MESSTXT,MESSFOR     Tell em FORCE ok w/o CANCEL.
         B     FORFORCP
FORFORC2 DS    0H
         MVC   MESSTXT,MESSNFR     Tell em need CANCEL before FORCE.
FORFORCP DS    0H                  Write the actual message out.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(28),FORMTMSG
         APUT  OUTPUT,30
FORKILLF DS    0H                  Figure out if Non-Memtermable or not
         ST    R4,SAVER4D          Save work register
*        CLC   SAVEASID,CHASID
*        BNE   FORKILLX
*        MVC   FOUNASID,CHASID     Stage ASID for GETASCB routine
*        B     FORKILLY
FORKILLX MVC   FOUNASID,SAVEASID
FORKILLY DS    0H
         BAL   R9,GETASCB          Get the ASCB.
         LTR   R15,R15             Is there one?
         BZ    FORCHEND            No. Exit this routine.
         ST    R15,SAVEASCB        Save address of ASCB.
         L     R4,SAVEASCB         Reload address of ASCB in work reg.
         L     R4,0(,R4)           Get actual ASCB into register.
         USING ASCB,R4
         TM    ASCBFLG2,ASCBNOMT   Test if Non-Memtermable bit is on.
         BZ    FOROMEMT            No. Report that it's off.
         MVC   MESSTXT,MESSNMT     Yes. Put Non-Memtermable into msg.
         B     FORKILLO            And put out the message.
FOROMEMT DS    0H
         MVC   MESSTXT,MESSMMT     No. Put Memtermable into message.
FORKILLO MVC   OUTPUT,OUTPUT-1     And put out the message.
         MVC   OUTPUT(28),FORMTMSG
         APUT  OUTPUT,30
         L     R4,SAVER4D          Restore work register.
         DROP  R4                  Lose ASCB addressability.
FORCHEND DS    0H
         DROP  R3
         L     R3,SAVER3E          Restore
         L     R9,SAVER9J             registers.
         BR    R9
*            Constants associated with this routine.    -    below
MESSCAN  DC    CL15'Cancelable     '
MESSNCN  DC    CL15'Non-Cancelable '
MESSFOR  DC    CL15'Force w/o Cncel'
MESSNFR  DC    CL15'Cancel + Force '
MESSNMT  DC    CL15'Non-Memtermable'
MESSMMT  DC    CL15'Memtermable    '
FORMTMSG DS    0CL28
MESS000  DC    CL13'Job Status:  '
MESSTXT  DC    CL15'               '
*            Constants associated with this routine.    -    above
** ---------------------------------------------------------------- **
PRINTERR DS    0H                    Print help messages.
         ST    R9,SAVER9K            Save BAL register.
         APUT  MESSAG2A,L'MESSAG2A
         APUT  MESSAG2B,L'MESSAG2B
         APUT  MESSAG2V,L'MESSAG2V
         APUT  MESSAG2U,L'MESSAG2U
         APUT  MESSAG2C,L'MESSAG2C
         APUT  MESSAG2D,L'MESSAG2D
         APUT  MESSAG2E,L'MESSAG2E
         APUT  MESSAG2F,L'MESSAG2F
         APUT  MESSAGEM,L'MESSAGEM
         APUT  MESSAG2G,L'MESSAG2G
         APUT  MESSAG2H,L'MESSAG2H
         APUT  MESSAGEM,L'MESSAGEM
         APUT  MESSAG2I,L'MESSAG2I
         APUT  MESSAG2J,L'MESSAG2J
         APUT  MESSAG2K,L'MESSAG2K
         APUT  MESSAG2L,L'MESSAG2L
         APUT  MESSAG2M,L'MESSAG2M
         APUT  MESSAG2N,L'MESSAG2N
         APUT  MESSAG2O,L'MESSAG2O
         APUT  MESSAG2P,L'MESSAG2P
         APUT  MESSAG2Q,L'MESSAG2Q
         APUT  MESSAG2R,L'MESSAG2R
         APUT  MESSAG2S,L'MESSAG2S
         APUT  MESSAG2T,L'MESSAG2T
         APUT  MESSAGEM,L'MESSAGEM
         L     R9,SAVER9K            Restore BAL register.
         BR    R9
** ----------------------------------------------------------------- **
*        Control of the following routines are under control of       *
*           the KILLFLAG, and are not under control of FLAG2.         *
*                                                                     *
*        KILLFLAG controls processes KILL, BURN, NMEM and MEMT.       *
*              (Routine sets FLAG2 EQU X'80')                         *
*  ------------------------------------------------------------------ *
*                   Settings of the KILLFLAG                          *
*                                                                     *
*  KILLFLAG  equals  X'01'            for KILL (whack always)         *
*                    X'01' and X'02'  for BURN (whack only if MEMT)   *
*                    X'04'            for NMEM (make NON-memtermable) *
*                    X'08'            for MEMT (make memtermable)     *
*                                                                     *
** ----------------------------------------------------------------- **
DONMEM   DS    0H                        NON-MEMTERMABLE   FLAG X'04'
         NI    KILLFLAG,X'04'            ONLY NMEM FLAG ON. Others off
         OI    KILLFLAG,X'04'            TURN NMEM FLAG ON
         B     FLGSDONE
DOMEMT   DS    0H                        MEMTERMABLE       FLAG X'08'
         NI    KILLFLAG,X'08'            ONLY MEMT FLAG ON  Others off
         OI    KILLFLAG,X'08'            TURN MEMT FLAG ON
         B     FLGSDONE
DOBURN   DS    0H                        BURN. X'02' and X'01' both on
         OI    KILLFLAG,X'02'            Announce BURN as keyword
DOKILL   DS    0H                        KILL process. KILL flag on.
         OI    KILLFLAG,X'01'            Announce KILL as keyword
FLGSDONE DS    0H                        Flags have been set.
         TM    FLAG0,X'40'               Have PSCB ACCT authority?
         BZ    NOTALLOW                  No. Can't do these commands.
*  ------------------------------------------------------------------ *
*                    Print the action code for                        *
*                    everything under FLAG2=X'80'                     *
*  ------------------------------------------------------------------ *
         OI    FLAG2,X'80'               Mark under KILLFLAG control.
*  ------------------------------------------------------------------ *
         MVC   OUTPUT,OUTPUT-1           Print message accordingly
         MVC   OUTPUT(15),=C'Action code   :'
TRYBURN  TM    KILLFLAG,X'02'            For BURN, X'01' and X'02' on.
         BZ    TRYKILL
         MVC   OUTPUT+17(4),BURNC        Mark as a BURN.
         B     PRTCODE
TRYKILL  TM    KILLFLAG,X'01'
         BZ    TRYNMEM
         MVC   OUTPUT+17(4),KILLC        Mark as a KILL.
         B     PRTCODE
TRYNMEM  TM    KILLFLAG,X'04'
         BZ    TRYMEMT
         MVC   OUTPUT+17(4),NMEMC        Mark as a NMEM.
         B     PRTCODE
TRYMEMT  TM    KILLFLAG,X'08'
         BZ    PRTCODE
         MVC   OUTPUT+17(4),MEMTC        Mark as a MEMT.
PRTCODE  DS     0H                       And print the result.
         APUT  OUTPUT,25
*  ------------------------------------------------------------------ *
* -- >  Test if this command is being run APF Authorized - below    BUR
TAUTH    STM   R15,R1,SAVE14T1   Now save registers and test if APF BUR
         XR    R15,R15                authorized.                   BUR
         TESTAUTH FCTN=1           Are we authorized?               BUR
         LTR   R15,R15             Test the return code.            BUR
         BNZ   NOTAUTH           Not zero, tell not authorized.     BUR
         LM    R15,R1,SAVE14T1   Restore registers used by TESTAUTH BUR
* -- >  Test if this command is being run APF Authorized - above    BUR
*  ------------------------------------------------------------------ *
         BAL   R9,FINDCSCB               Get correct CSCB entry.    BUR
         MODESET KEY=ZERO,MODE=SUP                                  BUR
         ST    R7,SAVER7B                Store work register        BUR
         LH    R7,CSCBASID               Set ASID                   BUR
         TM    KILLFLAG,X'0C'            NMEM or MEMT action?
         BNZ   ASCBBITS                  If either, then not KILL
*----->               KILL routine - below                          KIL
         TM    KILLFLAG,X'01'            Is the KILL flag on?       KIL
         BZ    SKIPMEMT                  No. Exit this routine.     KIL
ASCBBITS DS    0H
         CLC   CSCBASID,=X'0000'         Did FINDCSCB find a CSCB?  KIL
         BE    SKIPMEMT                  No. Exit this routine.     KIL
         MVC   FOUNASID,CSCBASID         Stage ASID to get the ASCB KIL
         BAL   R9,GETASCB                Get the ASCB.              KIL
         LTR   R15,R15                   Is there one?              KIL
         BZ    SKIPMEMT                  No. Exit this routine.     KIL
         ST    R15,SAVEASCB              Save address of ASCB.      KIL
         L     R15,0(,R15)               Load it to address fields. KIL
         USING ASCB,R15                                             KIL
         TM    KILLFLAG,X'08'            MEMT?
         BO    FORCEOFF
         TM    KILLFLAG,X'04'            NMEM?
         BO    FORCEON
         TM    KILLFLAG,X'02'            BURN only?                 BUR
         BO    EXITKILL                  Non-forcible still on.     BUR
         TM    KILLFLAG,X'01'            If not X'01' then no MEMTERM.
         BZ    SKIPMEMT                  Yes. Turn off ASCB bits first.
         NI    ASCBFLG2,255-ASCBNOMT     Turn off NON-FORCIBLE bit  KIL
         NI    ASCBFLG2,255-ASCBNOMD     Turn off Dat error bit     KIL
         B     EXITKILL                  Go do MEMTERM.
FORCEOFF NI    ASCBFLG2,255-ASCBNOMT     Turn off NON-FORCIBLE bit
         NI    ASCBFLG2,255-ASCBNOMD     Turn off Dat error bit
         B     SKIPMEMT                  And skip MEMTERM.
FORCEON  DS    0H                        Make Non-Memtermable.
         OI    ASCBFLG2,ASCBNOMT         Put the ASCBNOMT bit on.
         ST    R3,SAVER3F                Then
         L     R3,FOUNCSCB                  Make
         USING CHAIN,R3                        Job
         NI    CHACT,255-X'08'                    Non-Cancelable too.
         MVC   SAVEACTF(1),CHACT         Save for reporting
         L     R3,SAVER3F                Restore work register.
         B     SKIPMEMT                  Don't do CALLRTM MEMTERM.
         DROP  R3
EXITKILL DS    0H                        Now do CALLRTM MEMTERM.    KIL
         DROP  R15                       Drop ASCB addressability   KIL
*----->               KILL routine - above                          KIL
         ST    R13,SAVER13A              Save R13                   BUR
         LA    R13,RTMSAVE               RTM save area              BUR
         CALLRTM TYPE=MEMTERM,ASID=(R7),COMPCOD=100                 BUR
         STC   R15,RTMCOD                Save MEMTERM Return Code
         L     R13,SAVER13A              Restore R13                BUR
SKIPMEMT DS    0H
         L     R7,SAVER7B                Restore work register      BUR
         MODESET KEY=NZERO,MODE=PROB                                BUR
         CLI   RTMCOD,X'2C'              Non-memtermable addr space?
         BE    NOTMEMTM                  Yes. Issue message to say so.
*
         TM    KILLFLAG,X'04'            Message if NMEM done.
         BZ    TRYMMEMT
         MVC   MESSAGM1+4(8),FOUNJOBI    Jobname into message       BUR
         HEX   MESSAGM1+22,2,FOUNASID    ASID into message          BUR
         APUT  MESSAGM1,L'MESSAGM1       Say job made non-memtermable
         B     BURNEND                   Done with message
TRYMMEMT DS    0H
         TM    KILLFLAG,X'08'
         BZ    TRYMBURN
         MVC   MESSAGM2+4(8),FOUNJOBI    Jobname into message       BUR
         HEX   MESSAGM2+22,2,FOUNASID    ASID into message          BUR
         APUT  MESSAGM2,L'MESSAGM2       Say job was killed.        BUR
         B     BURNEND                   Done with message          KIL
TRYMBURN TM    KILLFLAG,X'02'            KILL msg instead of BURN?  KIL
         BO    BURNMSG                   Yes. Run BURN message.     KIL
         MVC   MESSAGKI+4(8),FOUNJOBI    Jobname into message       BUR
         HEX   MESSAGKI+22,2,FOUNASID    ASID into message          BUR
         APUT  MESSAGKI,L'MESSAGKI       Say job was killed.        BUR
         B     BURNEND                   Skip BURN message          KIL
BURNMSG  DS    0H
         MVC   MESSAGBU+4(8),FOUNJOBI    Jobname into message       KIL
         HEX   MESSAGBU+22,2,FOUNASID    ASID into message          KIL
         APUT  MESSAGBU,L'MESSAGBU       Say job was burned.        KIL
BURNEND  DS    0H
         B     GETIDEND            After enough looks, end.         KIL
RTMSAVE  DS    CL72                Work area for RTM                BUR
SAVER13A DS    F                   Place to save R13                BUR
SAVEASCB DS    F                   Save ASCB address                KIL
** ---------------------------------------------------------------- **
KEY0SWNS DS    0H                    Key 0 for SWAP or NSWP
         ST    R9,SAVER9L            Save BAL register.
         ST    R6,SAVER6A
KEY0TSTA DS    0H
* -- >  Test if this command is being run APF Authorized - below
         STM   R15,R1,SAVE14T1     Now save registers and test if APF
         XR    R15,R15                  authorized.
         TESTAUTH FCTN=1           Are we authorized?
         LTR   R15,R15             Test the return code.
         BNZ   NOTAUTH             Not zero, tell not authorized.
         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.
* -- >  Test if this command is being run APF Authorized - above
         TM    FLAG2,X'04'         Make ASID swappable?
         BO    KEY0SWAP            Yes. Do it.
         TM    FLAG2,X'08'         Make ASID non-swappable?
         BO    KEY0NSWP            Yes. Do it.
         B     KEY0EXIT            Not SWAP or NSWP, don't belong here.
*
KEY0NSWP DS    0H                    Make address space non-swappable.
*
         CLC   OWNASID,FOUNASID      Target asid different from ours?
         BE    KEY0DNSW              No. Just do SYSEVENT.
         MVC   FUNC,=CL8'DONTSWAP'   Set nswapping function         JOE
         BAL   R9,BUILDSRB           Build SRB block                JOE
*                                                                   JOE
* ISSUE SUCCESSFUL MESSAGE                                          JOE
*                                                                   JOE
         MVC   MESSAGNS+4(8),FOUNJOBI                               JOE
         HEX   MESSAGNS+22,2,FOUNASID                               JOE
         APUT  MESSAGNS,L'MESSAGNS                                  JOE
         L     R6,SAVER6A            Restore Register               JOE
         L     R9,SAVER9L            Restore BAL register.          JOE
         BR    R9                    go back                        JOE
TEMPSAVE DS    4F                    save area                      JOE
* ---------------------------------------------------------------- *
KEY0DNSW DS    0H
         MODESET MODE=SUP,KEY=ZERO
KEY0SYSD DS    0H
         LH    R6,FOUNASID
         SYSEVENT DONTSWAP,ASID=(R6),ENTRY=SVC
KEY0NNRM DS    0H
         MODESET MODE=PROB,KEY=NZERO
         MVC   MESSAGNS+4(8),FOUNJOBI
         HEX   MESSAGNS+22,2,FOUNASID                               JOE
         APUT  MESSAGNS,L'MESSAGNS
         B     KEY0EXIT
KEY0SWAP DS    0H                    Make address space swappable.
         CLC   OWNASID,FOUNASID      Target asid different from ours?
         BE    KEY0DSWP              No. Just do SYSEVENT.
         MVC   FUNC,=CL8'OKSWAP'     Set function                   JOE
         BAL   R9,BUILDSRB           Build SRB CSA CONTROL BLOCKS   JOE
*                                                                   JOE
*  issue successful message                                         JOE
*                                                                   JOE
         MVC   MESSAGSW+4(8),FOUNJOBI                               JOE
         HEX   MESSAGSW+22,2,FOUNASID                               JOE
         APUT  MESSAGSW,L'MESSAGSW                                  JOE
         L     R6,SAVER6A            Restore Registers              JOE
         L     R9,SAVER9L            Restore BAL register.          JOE
         BR    R9                                                   JOE
KEY0DSWP DS    0H
         LH    R6,FOUNASID
         SYSEVENT OKSWAP,ASID=(R6),ENTRY=SVC
KEY0SNRM DS    0H
         MODESET MODE=PROB,KEY=NZERO
         MVC   MESSAGSW+4(8),FOUNJOBI
         HEX   MESSAGSW+22,2,FOUNASID                               JOE
         APUT  MESSAGSW,L'MESSAGSW
         B     KEY0EXIT
KEY0NODO DS    0H
         MODESET MODE=PROB,KEY=NZERO
         HEX   MESSAGNG+43,1,SYSEVCOD+3
         APUT  MESSAGNG,L'MESSAGNG
KEY0EXIT DS    0H
         L     R6,SAVER6A
         L     R9,SAVER9L            Restore BAL register.
         BR    R9
*--------------------------------------------------------------*    JOE
*                                                              *    JOE
*        BUILD SRB CONTROL BLOCK AND ACCOMPANYING CODE         *    JOE
*                                                              *    JOE
*--------------------------------------------------------------*    JOE
BUILDSRB DS    0H                                                   JOE
         STM   R6,R9,TEMPSAVE        Save Registers                 JOE
         BAL   R9,GETASCB            Find ASCB for this asid        JOE
         LR    R9,R15                Hold ASCB                      JOE
         L     R9,0(,R9)             Point to ASCB                  JOE
         MODESET MODE=SUP,KEY=ZERO   Get into supervisor state      JOE
*                                                                   JOE
CSA_LEN  EQU  SRBSIZE+84             CSA SRBLOCK AND PARAMTERS      JOE
*                                                                   JOE
*---------------------------------------------------------------*   JOE
*       Get CSA for SRB CONTROL BLOCK SUBPOOL 241               *   JOE
*---------------------------------------------------------------*   JOE
         STORAGE OBTAIN,SP=241,LENGTH=CSA_LEN Get Some CSA          JOE
         LR    R6,R1                 Point R6 to SRB control block  JOE
         USING SRB,R6                Address SRB                    JOE
         XC    SRB(SRBSIZE),SRB      Clear out SRB                  JOE
         ST    R9,SRBASCB            Save ASCB                      JOE
         LA    R8,SRBSIZE(,R6)       R8 -> paramlist                JOE
*       Get CSA paramter list                                   *   JOE
         ST    R8,SRBPARM            Store paramter list address    JOE
         LA    R7,72(,R8)            Point to ECB                   JOE
         XC    0(4,R7),0(R7)         Clear ECB Address              JOE
         LA    R7,4(,R7)             Point to ASCB                  JOE
         MVC   0(4,R7),X'224'        Move "HOME" PSAAOLD address sp JOE
         LA    R7,4(,R7)             Bump to next param             JOE
         CLC   FUNC,=C'DONTSWAP'     Q. non swappable function      JOE
         BE    NONSWAP               Yes; branch if so              JOE
         MVC   0(4,R7),=C'OKSW'      Otherwise swappable            JOE
         B     SETEPA                Set SRB program entry point    JOE
NONSWAP  DS    0H                                                   JOE
         MVC   0(4,R7),=C'DONT'      Set FUNCTION IN R7             JOE
*---------------------------------------------------------------*   JOE
*       Get CSA for SRB CONTROL BLOCK SUBPOOL 227               *   JOE
*---------------------------------------------------------------*   JOE
SETEPA   DS    0H                                                   JOE
         STORAGE OBTAIN,SP=227,LENGTH=SWAPLEN  Get Fixed CSA        JOE
         ST    R1,SRBEPA             Set entry point                JOE
         LR    R14,R1                Hold that thought              JOE
         LA    R15,SWAPLEN           Get Length                     JOE
         LR    R1,R15                                               JOE
         LA    R0,SWAPXMEM           Point to SRB routine           JOE
         MVCL  R14,R0                Move routine                   JOE
*                                                                   JOE
         SCHEDULE SRB=(R6),SCOPE=GLOBAL,MODE=NONXM                  JOE
*                                                                   JOE
         LA    R7,72(,R8)            Point to ECB                   JOE
*                                                                   JOE
         WAIT  ECB=(R7)                                             JOE
*                                                                   JOE
         L     R9,SRBEPA             Get Entry Point Address        JOE
*                                                                   JOE
         STORAGE RELEASE,ADDR=(R6),LENGTH=CSA_LEN,SP=241            JOE
*                                                                   JOE
         STORAGE RELEASE,ADDR=(R9),LENGTH=SWAPLEN,SP=227            JOE
*                                                                   JOE
         MODESET KEY=NZERO,MODE=PROB                                JOE
*                                                                   JOE
         LM    R6,R9,TEMPSAVE        Save Registers                 JOE
         BR    R9                    Return                         JOE
SYSEVCOD DC    F'0'                  SYSEVENT Return Code
OLDAX    DS    F
WAREA    DS    D                     Work area
WAREB    DS    D                     Work area
** ---------------------------------------------------------------- **
** --         C  O  N  S  T  A  N  T  S                          -- **
** ---------------------------------------------------------------- **
MESSAGNA DC    C'Command was not invoked APF authorized.'
MESSAGEN DC    C'End of CSCB chain was reached.'
MESSAGEY DC    C'No valid keyword was coded.'
FLAG0    DC    X'00'               Copy of PSCBATR1 - Authority levels
FLAG1    DC    X'00'               Needed to parse parameters
*              X'01'               ASID ONLY - NO JOBNAME
*              X'02'               JOBNAME IS PRESENT.
*              X'04'               ASID( WAS PRESENT IN PARMS.
*              X'08'               CSCB CHAIN DISPLAY ONLY.
FLAG2    DC    X'00'
*              X'01'               CNCL WAS CODED
*              X'02'               NCNC WAS CODED
*              X'04'               SWAP WAS CODED
*              X'08'               NSWP WAS CODED
*              X'10'               FORC WAS CODED
*              X'20'               CSCB WAS CODED
*              X'80'               BURN OR KILL WAS CODED           KIL
*              X'40'               CSCB chain run only.
RTMCOD   DC    X'00'               Saved return code from MEMTERM
ONSWIT   DC    X'00'
*              X'01'               TURN BIT ON
*              X'02'               TURN BIT OFF
HEXSAVE  DS    3F                  SAVE FOR HEX MACRO
SAVE     DS    9D                  Program Save Area
SAVE14T1 DS    2D                  Save "system-used" registers.
         DC    C' '                Blank before OUTPUT line.
OUTPUT   DC    CL80'  '            Variable output line.
FUNC     DS    CL8                 Swapppinmg function
         LTORG
*-----------------------------------------------------------------* JOE
*                         SRB CODE                                * JOE
*-----------------------------------------------------------------* JOE
SWAPXMEM DS    0D                                                   JOE
         DROP  R12,R11,R10                                          JOE
         BASR  R5,0                                                 JOE
         USING *,R5                Entry Point                      JOE
         LR    R10,R14             Save return address              JOE
         LR    R13,R1                                               JOE
*                                                                   JOE
         LA    R9,72(,R13)         Point to ECB Address             JOE
         LA    R8,76(,R13)         Point to ASCB Address            JOE
         L     R8,0(,R8)                                            JOE
         L     R7,80(,R13)         Get code                         JOE
*                                                                   JOE
         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=STDSAVE         JOE
*                                                                   JOE
         C      R7,=C'OKSW'        OKSWAP                           JOE
         BE     SETSWAP                                             JOE
*                                                                   JOE
         XR    R1,R1               Undocumented instead of WAIT     JOE
         SYSEVENT DONTSWAP,ENTRY=BRANCH                             JOE
*                                                                   JOE
         B     UNLOCK                                               JOE
*                                                                   JOE
SETSWAP  DS    0H                                                   JOE
         XR    R1,R1               Undocumented instead of WAIT     JOE
         SYSEVENT OKSWAP,ENTRY=BRANCH                               JOE
*                                                                   JOE
UNLOCK   DS    0H                                                   JOE
         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE                    JOE
*                                                                   JOE
*                                                                   JOE
         POST  (R9),ASCB=(R8),ERRET=GOBACK,LINKAGE=BRANCH           JOE
*                                                                   JOE
GOBACK   LR    R14,R10               Return Address                 JOE
         BR    R14                   Return                         JOE
         LTORG                                                      JOE
SWAPRTM  DS    0D                                                   JOE
SWAPLEN  EQU   *-SWAPXMEM                                           JOE
** ---------------------------------------------------------------- **
         SPACE
         TITLE '- MAPPING MACROS.'
         CVT   DSECT=YES           Map the CVT.
         IEECHAIN                  Map the CSCB control block.
         IHASRB                                                     JOE
         IHAASVT                                                    JOE
         IHAASCB                                                    JOE
         IHAASXB                                                    JOE
         IRAOUCB                                                    JOE
         IHAPSA   DSECT=YES,LIST=YES                           HD APR88
         IHAFRRS
         EJECT                                                 HD APR88
         IKJEFLWA                                                   JOE
         END   CNCLPG
** ---------------------------------------------------------------- **
*  -----------------------------------------------------------------  *
*  --           Create PUTLINE environment.                       --  *
*  -----------------------------------------------------------------  *
EPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&
               OR'
EPUTL    CSECT                                              *HMD 10/85*
         LCLB  &XA                                          *HMD 10/85*
&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*  MODULE NAME  . . . . EPUTL
*
*  ALIASES  . . . . . . NONE
*
*  DATE WRITTEN . . . . 06/85
*  UPDATED      . . . . 04/88                                  HD APR88
*
*  AUTHOR . . . . . . . JIM ELSWORTH
*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88
*
*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR
*
*  PURPOSE:
*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE
*
*
*  DESCRIPTION:
*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.
*    ISSUES SINGLE LINE PUTLINE.
*
*
*  ATTRIBUTES:
*    REENTRANT
*
*  FEATURES:
*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.
*
*  CALLED MODULES:
*    PUTLINE
*
*  ASSUMPTIONS:
*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE
*
*  ABENDS:
*    POSSIBLE 0CX IF BAD ARGUEMNTS
*
*  CAVEATS:
*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB
*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.
*
*
*  INPUT ARGUMENTS:
*    1)  R1 : ADDRESS OF MESSAGE TEXT
*    2)  R0 : LENGTH OF MESSAGE TEXT
*    3) R13 : STANDARD OS SAVE AREA
*    4) R14 : RETURN ADDRESS
*    5) R15 : ENTRY ADDRESS
*
*               ( CONTINUED ... )
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*
*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR
*
RCBA     EQU   100                 BAD MESSAGE ADDRESS
RCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG
*
MAXMSG   EQU   128                 MAXIMUM MESSAGE LENGTH
*
*
*  REGISTERS USED:
*
R0       EQU   0                   MESSAGE LENGTH AT ENTRY
R1       EQU   1                   MESSAGE ADDRESS AT ENTRY
R2       EQU   2                   WORK
RMA      EQU   4                   @MESSAGE TEXT
RML      EQU   5                   MESSAGE LENGTH
RUPT     EQU   6                   @UPT (USER PROFILE TABLE)
RECT     EQU   7                   @ECT
R12      EQU   12                  CSECT BASE
R13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA
R14      EQU   14                  WORK/LINKAGE
R15      EQU   15                  WORK/LINKAGE
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
         IKJCPPL
         EJECT
         IKJTCB   LIST=YES                                  *HMD 10/85*
         EJECT                                              *HMD 10/85*
         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*
         IHAPSA   DSECT=YES,LIST=YES                           HD APR88
         EJECT
PUTLDS   DSECT
         DS    18F                      OS SAVE AREA
PUTAAA   EQU   *
PUTECB   DS    F                        ECB
PUTIOPL  DS    4F                       IOPLADS
PUTBLOK  PUTLINE MF=L
PUTLEN   DS    H                        LENGTH
PUTZZZ   DS    H                        RESERVED
PUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA
PUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS
         EJECT
***********************************************************************
*  SET UP LINKAGE
***********************************************************************
         SPACE 1
EPUTL    CSECT
         AIF  (NOT &XA).X001                                *HMD 10/85*
EPUTL    AMODE 31
.X001    ANOP                                               *HMD 10/85*
         STM   14,12,12(13)       SAVE CALLERS REGS
         LR    R12,R15            COPY EPA
         USING EPUTL,R12          ADDRESSABILITY
         AIF   (NOT &XA).X002                               *HMD 10/85*
         GETMAIN RU,              LV=LENGTH                            &
               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &
               LOC=RES            RELATIVE TO 16MB LINE
         AGO   .X003                                        *HMD 10/85*
.X002    ANOP                                               *HMD 10/85*
         GETMAIN RU,              LV=LENGTH                            &
               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA
.X003    ANOP                                               *HMD 10/85*
         ST    1,8(13)            OUR SAVE AREA POINTER
         ST    13,4(1)            POINTER TO CALLERS SAVE AREA
         LR    13,1               @OUR SAVE AREA
         USING PUTLDS,R13         MAP SA AND WORK AREA
         L     R14,4(R13)         POINT TO CALLERS RSA
         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN
         SPACE 2
***********************************************************************
*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE
***********************************************************************
         SPACE 1
         LA    R15,RCBA                 ASSUME BAD ADDRESS
         LTR   RMA,R1                   MESSAGE ADDRESS
         BNP   RETURN                   GOOD ASSUMPTION
         LA    R15,RCBL                 ASSUME BAD LENGTH
         LTR   RML,R0                   POSITIVE?
         BNP   RETURN                   -NO
         C     RML,=A(MAXMSG)           MORE THAN MAX?
         BH    RETURN                   -YES
         SPACE 2
***********************************************************************
*  BUILD PARAMETER LIST
***********************************************************************
         SPACE 1
         LA    R15,4(RML)               MESSAGE LENGTH
         STH   R15,PUTLEN                 PLUS HEADER
         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW
         BCTR  RML,0                    REDUCE FOR MOVE
         EX    RML,PUTMOVE
         EJECT
***********************************************************************
*  DIG UP ADDRESS OF UPT AND ECT
***********************************************************************
         SPACE 1
         L     R2,PSATOLD-PSA           @TCB                   HD APR88
         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA
         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP
         USING CPPL,R2                  MAP CPPL
         L     RUPT,CPPLUPT             @UPT
         L     RECT,CPPLECT             @ECT
         SPACE 2
***********************************************************************
*  ISSUE PUTLINE CALL
***********************************************************************
         SPACE 1
         XC    PUTECB,PUTECB            CLEAR ECB
         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88
         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &
               UPT=(RUPT),              @UPT                           &
               ECT=(RECT),              @ECT                           &
               ECB=PUTECB,              @ECB                           &
               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &
               MF=(E,PUTIOPL)
         EJECT
***********************************************************************
*  RETURN TO CALLER
***********************************************************************
         SPACE 1
RETURN   EQU   *
         LR    2,R13                    @OUR SAVE AREA
         LR    3,R15                    SAVE RETURN CODE
         L     R13,4(R13)               @CALLERS SAVE AREA
         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0
         LR    R15,3                    RESTORE RC
         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS
         SPACE 5
***********************************************************************
*  CONSTANTS AND NON-REENTRANT WORK AREAS
***********************************************************************
         SPACE 1
PUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER
         SPACE 2
         LTORG
         SPACE 2
         END EPUTL
