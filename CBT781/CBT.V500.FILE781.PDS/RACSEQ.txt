RACSEQ   TITLE 'RACSEQ - USE R_ADMIN TO EXTRACT RACF PROFILE'
         PRINT OFF
         COPY  IEABRC
         PRINT ON
         SYSSTATE ARCHLVL=2
***********************************************************************
***********************************************************************
***                                                                 ***
***  MODULE - RACSEQ                                                ***
***                                                                 ***
***      This TSO command invokes the extract function of R_admin   ***
***      (IRRSEQ00) and displays every profile field to the         ***
***      display using PUTLINE.                                     ***
***                                                                 ***
***      It is invoked from the TSO command line like:              ***
***        RACSEQ CLASS(classname) PROFILE(profilename)             ***
***                                                                 ***
***      The supported classes are USER, GROUP, and CONNECT.        ***
***      If not specified, CLASS defaults to USER. All values for   ***
***      CLASS will be folded to upper case by TSO parse services.  ***
***                                                                 ***
***      The PROFILE field is a user ID or group name for USER      ***
***      and GROUP, respectively. For CONNECT, it is the user ID    ***
***      followed by a period followed by the group name. E.G.      ***
***       IBMUSER.SYS1                                              ***
***                                                                 ***
***      NOTE: "profilename" is case-sensitive! This means you can  ***
***            display lower case user IDs such as irrcerta, but    ***
***            it also means you must remember to upper-case the    ***
***            user ID for most cases.  If you forget, you will     ***
***            receive a 4/4/4 return code combination!             ***
***                                                                 ***
***  INPUT: R1 points to the address of the CPPL                    ***
***                                                                 ***
***  RETURN CODES:                                                  ***
***     0 - This sample always returns 0 unless altered.            ***
***  non0 - Parse rc or SAF rc from R_admin                         ***
***                                                                 ***
***  Register usage:                                                ***
***   R11 - Autodata base register                                  ***
***   R12 - Base register                                           ***
***   R13 - Savearea address                                        ***
***  Further register usage is documented in the code below.        ***
***                                                                 ***
***********************************************************************
***********************************************************************
         EJECT
***********************************************************************
***********************************************************************
***                                                                 ***
***      COPYRIGHT IBM CORPORATION, 2006                            ***
***                                                                 ***
***      THIS CODE HAS NOT BEEN SUBMITTED TO ANY FORMAL IBM TEST    ***
***      AND IS DISTRIBUTED ON AN "AS IS" BASIS WITHOUT ANY         ***
***      WARRANTY EITHER EXPRESS OR IMPLIED. THE IMPLEMENTATION     ***
***      OF ANY OF THE TECHNIQUES DESCRIBED OR USED HEREIN IS A     ***
***      CUSTOMER RESPONSIBILITY AND DEPENDS ON THE CUSTOMER'S      ***
***      OPERATIONAL ENVIRONMENT. WHILE EACH ITEM MAY HAVE BEEN     ***
***      REVIEWED FOR ACCURACY IN A SPECIFIC SITUATION AND MAY      ***
***      RUN IN A SPECIFIC ENVIRONMENT, THERE IS NO GUARANTEE       ***
***      THAT THE SAME OR SIMILAR RESULTS WILL BE OBTAINED ELSE-    ***
***      WHERE. CUSTOMERS ATTEMPTING TO ADAPT THESE TECHNIQUES TO   ***
***      THEIR OWN ENVIRONMENTS DO SO AT THEIR OWN RISK.            ***
***                                                                 ***
***********************************************************************
***********************************************************************
         EJECT
RACSEQ   CSECT ,                   An R_admin sample routine
RACSEQ   AMODE 31
RACSEQ   RMODE ANY
         SAVE  (14,12),,RACSEQ-&SYSDATE-&SYSTIME
*        USING RACSEQ,R12          set base register
*
* Get dynamic storage
*
         LARL  R12,DATA           POINT TO STATIC DATA AREA
         USING DATA,R12
         LR    R10,R1             SAVE CPPL ADDRESS
         L     R0,DYNSIZE          dynamic area size to R0
         STORAGE OBTAIN,                                               X
               LOC=24,                                                 X
               LENGTH=(0)
         LR    R11,R1              dynamic area addressability
         USING DATD,R11            base
         USING S99RB,DYNS99RB
         ST    R13,SAVEAREA+4      save caller's savearea address
         ST    R11,8(R13)          save our savearea address
         LR    R13,R11             our savearea address to R13
         ST    R10,CPPLPTR         save saved input CPPL address
         EJECT
*
* Initialize PUTLINE Output Line Descriptor (OLD) segment pointers
* for use throughout this program. The pointers to the segments (i.e.
* message line and inserts) remain constant; each message will set the
* number of segments and the actual length/data.
* Register usage
*  R2 = CPPLUPT for PUTLINE
*  R3 = CPPLECT for PUTLINE
*  R5 = Disposable work reg
*  R10 = Disposable work reg
*
         LA    R10,SEG1LEN
         ST    R10,OLDSEGA1
         LA    R10,SEG2LEN
         ST    R10,OLDSEGA2
         LA    R10,SEG3LEN
         ST    R10,OLDSEGA3
         LA    R10,SEG4LEN
         ST    R10,OLDSEGA4
         LARL  R10,BR5            POINT TO "NO OUTPUT" SUBROUTINE
         ST    R10,DO_PUT@        PUT IT IN SUBROUTINE ADDRESS
         XC    OPENSW,OPENSW
         LHI   0,-1
         ST    0,UNIXFD           Initialize UNIX File Descriptor
         MVC   DCBOUT(LDCB),DCBINIT
         USING IHADCB,DCBOUT
         MVC   OPEN24(LOPEN24),OPEN24I
         LA    0,OPEN24           POINT TO EXIT
         ST    0,EXLST
         MVI   EXLST,X'85'        OPEN EXIT CODE+HOB ON.
         LA    0,EXLST
         STCM  0,B'0111',DCBEXLSA POINT TO EXLST IN DCB
*
* Initialize parse stuff and parse the input command image.
*
         L     R1,CPPLPTR           Get address of CPPL
         USING CPPL,R1              And establish addressability
         LA    R6,DYNPPL            GET ADDRESS OF PPL
         USING PPL,R6               AND ESTABLISH ADDRESSABILITY
         MVC   PPLUPT,CPPLUPT       PUT IN THE UPT ADDRESS FROM CPPL
         L     R2,CPPLUPT           And keep it around in R2
         MVC   PPLECT,CPPLECT       PUT IN THE ECT ADDRESS FROM CPPL
         L     R3,CPPLECT           And keep it around in R3
         LA    R0,PUTECB
         MVC   PPLCBUF,CPPLCBUF     PUT IN THE COMMAND BUFFER ADDRESS
         L     R5,=A(RACPDE)        Get address of parse macros (PCL)
         ST    R5,PPLPCL            STORE IT IN THE PPL
         LA    R5,PDLPTR            Get address of parse result anchor
         ST    R5,PPLANS            STORE IT IN THE PPL
         CALLTSSR EP=IKJPARS,MF=(E,PPL)   INVOKE PARSE
         LTR   R15,R15              IF PARSE RETURN CODE IS ZERO
         JZ    GETANS               Go process results
         DROP  R1
*
* Unexpected parse error.  Print return code and bail.
*
         ST    R15,SAFRC            Store rc
         XC    DYNEFF(L_EFF),DYNEFF
         LA    1,DYNEFF
         USING GFDSECTD,1
         MVC   GFCPPLP,CPPLPTR
         ST    15,GFRCODE
         LHI   0,GFPARSE
         STH   0,GFCALLID
         ST    1,DYNEFF@
         DROP  1
         LA    1,DYNEFF@
         OI    0(1),X'80'
         LINK  EP=IKJEFF19
         MVC   OLDNUM,=A(2)         One message segment
         LHI   R10,L'MSG9+4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG9),MSG9
         LHI   R10,6                2-digit rc + header
         STH   R10,SEG2LEN
         LHI   R10,L'MSG9           Insert position of rc (eol)
         STH   R10,SEG2OFF
         CVD   R15,PACKDEC1         Convert 2 digits of parse rc
         LA    R10,PACKDEC1
         UNPK  0(2,R10),6(2,R10)
         OI    1(R10),X'F0'         Fix the sign nibble
         MVC   SEG2DATA(2),PACKDEC1 Move 2-char parse rc
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
*
* Get the class name and profile name from parse output. The class
* name will determine the R_Admin function code to use.
*
GETANS   DS    0H
         L     R1,PPLANS            Get the PDL anchor address
         L     R1,0(,R1)            Get the PDL address itself
         ST    R1,PDLPTR            Save it for later
         DROP  R6
         USING SEQPDL,R1            Get addressability to PDL
         EJECT
*
* Initialize IRRSEQ00 parameters
*
         MVI   FUNCODE,ADMN_XTR_USER Assume USER class for now
         OC    PDLCLASS,PDLCLASS    CLASS specified?
         JZ    MOREPRMS             No, default to USER
         L     R10,CLSPTR           Get class name ptr
         CLC   GRPCLS(5),0(R10)     GROUP class?
         JNE   CHKCON               Nope
         MVI   FUNCODE,ADMN_XTR_GROUP Yup
         J     MOREPRMS             Continue with R_admin parms
CHKCON   DS    0H
         CLC   CONCLS(7),0(R10)     CONNECT class?
         JNE   CHKUSR               Nope
         MVI   FUNCODE,ADMN_XTR_CONNECT Yup
         J     MOREPRMS             Continue with R_admin parms
CHKUSR   DS    0H
         CLC   USERCLS(4),0(R10)    USER class?
         JE    MOREPRMS             Yup
         DROP  R1
*
*        Error - unsupported class. Issue a message.
*
         MVC   OLDNUM,=A(1)         One message segment
         LHI   R10,L'MSG7+4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG7),MSG7
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
*
MOREPRMS DS    0H
         L     R1,PDLPTR
         USING SEQPDL,R1            Get addressability to PDL
         XC    ALET,ALET            Use zero ALET
         XC    SAFRC,SAFRC          Initialize return/reason codes
         XC    RACFRC,RACFRC
         XC    RACFRS,RACFRS
         XC    USERLEN,USERLEN      Not supplying "run-as" user
         XC    ACEE,ACEE            Not supplying "run-as" ACEE
         MVI   SUBPOOL,127          Use subpool 127
         XC    OUTMSG,OUTMSG        Clear output message pointer
*
* In the Parm_list area, fill in the version and the user length,
* and copy the input user ID to the contiguous storage after the
* Parm_list storage.
*
         LA    R6,RADPLIST
         USING ADMN_PROF_MAP,R6
         MVI   ADMN_PROF_VERSION,0
         OC    PDLPROF,PDLPROF      PROFILE specified?
         JNZ   GETPROF
*
*        Error.  No profile.  Issue syntax message.
*
         MVC   OLDNUM,=A(1)         One message segment
         LHI   R10,L'MSG8+4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG8),MSG8
         DROP  R1
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
*
GETPROF  DS    0H
         USING SEQPDL,R1            Get addressability to PDL
         LH    R8,PROFLEN           Get profile length
         ST    R8,ADMN_PROF_NAMELEN Save length in plist header
         L     R9,PROFPTR
* The following instruction moves too much storage, but the extra will
* be ignored because we just set the length accurately. But, this is
* lazy and an execute instruction should be used.
         MVC   EXTPROF,0(R9)        Move profile name to R_admin plist
         DROP  R1
         DROP  R6
         EJECT
*
* Initialize IRRSEQ00 call parameter list.  That is, a list of
* addresses to the individual parameters set up above.
*
         LA    R1,WORKAREA
         ST    R1,WORKAREA@
         LA    R1,ALET
         ST    R1,ALET1@
         ST    R1,ALET2@
         ST    R1,ALET3@
         LA    R1,SAFRC
         ST    R1,SAFRC@
         LA    R1,RACFRC
         ST    R1,RACFRC@
         LA    R1,RACFRS
         ST    R1,RACFRS@
         LA    R1,FUNCODE
         ST    R1,FUNCODE@
         LA    R1,RADPLIST
         ST    R1,RADPLIST@
         LA    R1,USER
         ST    R1,USER@
         LA    R1,ACEE
         ST    R1,ACEE@
         LA    R1,SUBPOOL
         ST    R1,SUBPOOL@
         LA    R1,OUTMSG
         ST    R1,OUTMSG@
         OC    OUTMSG@,=X'80000000'       Turn on VL bit in last parm
*
* Call R_admin.  We've manually built the plist which would correspond
* to the following CALL statement (continuation characters omitted).
*
*        CALL  IRRSEQ00,
*              (WORKAREA,
*              ALET,SAFRC,
*              ALET,RACFRC,
*              ALET,RACFRS,
*              FUNCODE,
*              RADPLIST,
*              0,0,              Not passing "run-as" user or ACEE
*              SUBPOOL,
*              OUTMSG),VL
         LA    R1,WORKAREA@      Get list of addrs in R1
         L     R15,=V(IRRSEQ00)
         BASR  R14,R15
*
* Test return code and issue an error message if non-zero
*
         LT    R5,SAFRC           Get SAF return code
         JZ    GOODSEQ
*
* Convert the return/reason codes for message inserts
*
         CVD   R5,PACKDEC1          Convert binary to packed decimal
         LA    R5,PACKDEC1          Going to use 8 byte field for both
         UNPK  0(2,R5),6(2,R5)      Then to zoned decimal
         OI    1(R5),X'F0'          Fix the sign nibble
         L     R5,RACFRC            Convert the RACF rc too
         CVD   R5,PACKDEC2
         LA    R5,PACKDEC2
         UNPK  0(2,R5),6(2,R5)
         OI    1(R5),X'F0'
         L     R5,RACFRS            Convert the RACF reason code too
         CVD   R5,PACKDEC3
         LA    R5,PACKDEC3
         UNPK  0(2,R5),6(2,R5)
         OI    1(R5),X'F0'
         MVC   OLDNUM,=A(4)         Four message segments
         LHI   R5,L'MSG6+4
         STH   R5,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG6),MSG6
         LHI   R5,6                 All inserts will be 2 chars + hdr
         STH   R5,SEG2LEN
         STH   R5,SEG3LEN
         STH   R5,SEG4LEN
         LHI   R5,22                Insert position of SAF rc
         STH   R5,SEG2OFF
         MVC   SEG2DATA(2),PACKDEC1 Move 2-char SAF rc
         LHI   R5,32                Insert position of RACF rc
         STH   R5,SEG3OFF
         MVC   SEG3DATA(2),PACKDEC2 Move 2-char RACF rc
         LHI   R5,L'MSG6            Insert position of RACF rc (eol)
         STH   R5,SEG4OFF
         MVC   SEG4DATA(2),PACKDEC3 Move 2-char RACF rc
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
*
         EJECT
*
* R_admin worked! We'll start the command output by simply echoing
* the class and profile name, just to reassure the user. Also say
* how many segments there are.
*
GOODSEQ  DS    0H                   Issue warm and fuzzy message
         L     R1,PDLPTR
         USING SEQPDL,R1
         LH    R9,PDLOUTPUT
         LTR   R9,R9
         JZ    CONTXML            NO OUTPUT PARMS AT ALL
*
         AHI   R9,-1              MAKE ZERO BASED
         SLL   R9,2               MAKE OFFSET
         C     R9,MAXTBL          COMPARE TO MAX
         JNL   OUTX               TOO BIG???
         L     R10,OUTP(R9)       PROCESSING ROUTINE
         L     R9,OUTTBL(R9)      GET OFFSET
         LA    R9,PDEXML1(R9)     GET ADDRESS
         BR    R10                PROCESS OPTION
*
* PROCESS OTHER OPTIONS
OUTX     DS    0H
         L     R8,MAXTBL
         MVC   SAFRC,=F'20'
         LARL  R5,GETOUT
         LHI   R0,L'ERR1+4
         STH   R0,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'ERR1),ERR1
         MVC   OLDNUM,=A(1)
         J     DO_TERM
DODDN    DS    0H
* DDN(...)
         TM    XML1FLG,X'80'      ANY DDN?
         JZ    NODDN              NO???
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG14),MSG14
         MVC   SEG1LEN,=AL2(4+L'MSG14)
         MVC   SEG2OFF,=AL2(L'MSG14)
         LH    9,XML1LEN
         AHI   9,4
         STH   9,SEG2LEN
         AHI   9,-5
         JM    NODDN
         MVC   OLDNUM,=A(2)
         L     14,XML1PTR
         LA    R15,SEG2DATA
         EX    9,MOVESTR
         MVC   DCBDDNAM,=CL8' '
         LA    R15,DCBDDNAM
         EX    9,MOVESTR
         LARL  5,DOOPEN3          WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
*
NODDN    DS    0H
         MVC   OLDNUM,=A(1)
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG15),MSG15
         MVC   SEG1LEN,=AL2(4+L'MSG15)
         MVC   SAFRC,=F'20'
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
DODSN    DS    0H
* DSNAME(...)
         TM    XML2FLG,X'80'      ANY DSN?
         JZ    NODSN              NO???
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG12),MSG12
         MVC   SEG1LEN,=AL2(4+L'MSG12)
         MVC   SEG2OFF,=AL2(L'MSG12)
         LH    9,XML2LEN          GET LENGTH OF DSN
         AHI   9,5
         STH   9,SEG2LEN
         AHI   9,-6
         JM    NODSN
         L     10,XML2PTR         POINT TO DSN
         EX    9,MOVESEG2         MOVE IT IN
         MVC   OLDNUM,=A(2)
         JAS   5,DO_TERM
         MVC   S99RBLN,=AL1(L_S99RB)
         MVI   S99VERB,S99VRBAL
         LA    R5,TEXTP
         ST    R5,S99TXTPP
         LA    R5,DYNS99RB
         ST    R5,DYNS99R@
         OI    DYNS99R@,X'80'     SET END-OF-LIST ON
         LA    0,DSNT
         ST    0,TEXTP+0
         LA    0,DDNT
         ST    0,TEXTP+4
         LA    0,DISP1T
         ST    0,TEXTP+8
         LA    0,DISP2T
         ST    0,TEXTP+12
         LA    0,DISP3T
         ST    0,TEXTP+16
         LA    0,FREET
         ST    0,TEXTP+20
         LA    0,MEMBERT
         ST    0,TEXTP+24
         LA    0,LIKET
         ST    0,TEXTP+28
         LA    0,USINGT
         ST    0,TEXTP+32
         LA    0,=AL2(0)          THIS IS REALLY A DO NOTHING
         ST    0,TEXTP+36
         OI    TEXTP+36,X'80'
         MVC   MEMBERT,=AL2(0)
         MVC   LIKET,=AL2(0)
         MVC   USINGT,=AL2(0)
         LH    R9,XML2MEM
         LTR   R9,R9              MEMBER NAME?
         JZ    NOMEM              NOPE
         STH   R9,MEMBERT+4
         MVC   MEMBERT(2),=AL2(DALMEMBR)
         MVC   MEMBERT+2(2),=AL2(1)
         LA    15,MEMBERT+6
         L     14,XML2MEM
         AHI   9,-1
         EX    9,MOVESTR          MOVE IN MEMBER NAME
NOMEM    DS    0H
         L     R1,PDLPTR
         MVC   DSNT(2),=AL2(DALDSNAM)
         MVC   DSNT+2(2),=AL2(1)
         LH    5,XML2LEN
         STH   5,DSNT+4
         LA    15,DSNT+6
         L     14,XML2PTR
         AHI   5,-1
         EX    5,MOVESTR
         MVC   DISP1T(2),=AL2(DALSTATS)
         MVC   DISP1T+2(2),=AL2(1)
         MVC   DISP1T+4(2),=AL2(1)
         MVI   DISP1T+6,X'01'     DISP=OLD
         MVC   DISP2T(2),=AL2(DALNDISP)
         MVC   DISP2T+2(2),=AL2(1)
         MVC   DISP2T+4(2),=AL2(1)
         MVI   DISP2T+6,X'08'     DISP=KEEP
         MVC   DISP3T(2),=AL2(DALCDISP)
         MVC   DISP3T+2(2),=AL2(1)
         MVC   DISP3T+4(2),=AL2(1)
         MVI   DISP3T+6,X'08'     DISP=KEEP
         MVC   FREET(2),=AL2(DALCLOSE) FREE=CLOSE
         XC    FREET+2(2),FREET+2
         LH    5,LIKELEN
         LTR   5,5
         JZ    NOLIKE
         MVC   LIKET(2),=AL2(DALDCBDS)
         MVC   LIKET+2(2),=AL2(1)
         STH   5,LIKET+4
         AHI   5,-1
         LA    15,LIKET+6
         L     14,LIKEPTR
         EX    5,MOVESTR
NOLIKE   DS    0H
         LH    5,USNGLEN
         LTR   5,5
         JZ    NOUSING
         MVC   USINGT(2),=AL2(DALDCBDD)
         MVC   USINGT+2(2),=AL2(1)
         STH   5,USINGT+4
         AHI   5,-1
         LA    15,USINGT+6
         L     14,USNGPTR
         EX    5,MOVESTR
         LA    R1,USINGT
NOUSING  DS    0H
         MVC   DDNT(2),=AL2(DALRTDDN)
         MVC   DDNT+2(2),=AL2(1)
         MVC   DDNT+4(2),=AL2(8)
         LA    R1,DYNS99R@        POINT TO PARM LIST
         DYNALLOC ,               DO DYNAMIC ALLOCATION
         LTR   R15,R15
         JZ    DOOPEN2
         MVI   DISP1T+6,X'04'     DISP=NEW
         MVI   DISP2T+6,X'02'     DISP=CATLG
         MVI   DISP3T+6,X'02'     DISP=CATLG
         LA    R1,DYNS99R@        POINT TO PARM LIST
         DYNALLOC ,               TRY DISP=(NEW,CATLG,CATLG)
         LTR   R15,R15
         JZ    DOOPEN2
         LA    R1,DYNS99R@        POINT TO PARM LIST
         MVC   SAFRC,=F'20'
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DYNERR             WRITE MESSAGE TO USER
DOOPEN2  DS    0H
         LH    5,DDNT+4           GET LENGTH OF DDNAME
         MVC   DCBDDNAM,=CL8' '   BLANK IT
         LA    15,DCBDDNAM
         LA    14,DDNT+6
         AHI   5,-1
         EX    5,MOVESTR
DOOPEN3  DS    0H
         MVC   OPEN(LOPEN),OPENMFL
         LA    R1,OPEN
         OPEN  (DCBOUT,(OUTPUT)),MF=(E,(1)),MODE=31
         LTR   R5,R15
         JZ    OPENOK
         WTO   'OPEN FAILED',ROUTCDE=11
         MVC   SAFRC,=F'20'
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
OPENOK   DS    0H
         MVI   OPENSW,1           SAY WE DID THE OPEN
         TM    DCBDSORG,DCBDSGPS
         JZ    NOT_PS
         TM    DCBRECFM,DCBRECF+DCBRECV
         JNM   BAD_RECFM
         LARL  5,DO_FILE_F        RECFM=F
         ST    5,DO_PUT@
         TM    DCBRECFM,DCBRECF
         JO    CONTXML
         LARL  5,DO_FILE_V        RECFM=V
         ST    5,DO_PUT@
         J     CONTXML
BAD_RECFM DS   0H
         MVC   SAFRC,=F'20'
         LARL  R5,GETOUT
         LHI   R0,L'ERR2+4
         STH   R0,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'ERR2),ERR2
         MVC   OLDNUM,=A(1)
         J     DO_TERM            Tell the user the recfm is bad
NOT_PS   DS    0H
         LHI   R0,L'ERR3+4
         STH   R0,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'ERR3),ERR3
         MVC   SAFRC,=F'20'
         LARL  R5,GETOUT
         J     DO_TERM            Tell the user the DSORG is bad
NODSN    DS    0H
         MVC   OLDNUM,=A(1)
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG11),MSG11
         MVC   SEG1LEN,=AL2(4+L'MSG11)
         MVC   SAFRC,=F'20'
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
DOPATH   DS    0H
*|PATH(...)
         LARL  5,DO_UNIX          OUTPUT TO UNIX FILE
         ST    5,DO_PUT@
         TM    XML3FLG,X'80'      ANY PATH?
         JZ    NOPATH             NO???
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG16),MSG16
         MVC   SEG1LEN,=AL2(4+L'MSG16)
         MVC   SEG2OFF,=AL2(L'MSG16)
         LH    9,XML3LEN         GET LENGTH OF PATH
         AHI   9,5
         STH   9,SEG2LEN
         AHI   9,-6
         JM    NOPATH             NULL?
         L     10,XML3PTR         POINT TO PATH
         CLI   0(10),C'/'         Path must begin at root
         JNE   NOTROOT            But it isn't.
         EX    9,MOVESEG2         MOVE IT IN
         AHI   9,1                RESTORE TRUE LENGTH
         ST    R9,PATHLEN         SAVE IN PARM LIST
         LA    0,PATHLEN          +0
         LA    1,SEG2DATA         +4
         LA    R2,O_FLAG          +8
         LA    3,UNIXMODE         +12
         LA    R4,UNIXFD          +16
         LA    R5,RET_CODE        +20
         LA    R6,RSN_CODE        +24
         STM   R0,R6,TEXTP
         OI    TEXTP+24,X'80'
         LA    R1,TEXTP
         LINK  SF=(E,BPX1OPN)
         LT    R15,UNIXFD
         JM    UNIXFAIL           Open failed
         LOAD  EP=BPX1WRT
         ST    R0,BPX1WRT
         MVC   OLDNUM,=A(2)
         LARL  5,CONTXML          WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
UNIXFAIL DS    0H                 UNIX file failed to open
         LHI   R0,L'ERR4+4
         STH   R0,SEG1LEN
         LHI   R0,8
         STH   R0,SEG2LEN
         STH   R0,SEG3LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG2OFF,=AL2(33)
         MVC   SEG3OFF,=AL2(41)
         MVC   SEG1DATA(L'ERR4),ERR4
         UNPK  PACKDEC1(9),RET_CODE
         TR    PACKDEC1(8),TOHEX-C'0'
         MVC   SEG2DATA(8),PACKDEC1
         UNPK  PACKDEC1(9),RSN_CODE
         TR    PACKDEC1(8),TOHEX-C'0'
         MVC   SEG2DATA(8),PACKDEC1
         MVC   OLDNUM,=A(3)
         LARL  R5,GETOUT
         MVC   SAFRC,=F'20'
         J     DO_TERM            Tell user UNIX open failed.
NOTROOT  DS    0H
         MVC   OLDNUM,=A(1)
         LHI   R0,L'MSG22+4
         STH   R0,SEG1LEN
         MVC   SEG1DATA(L'MSG22),MSG22
         MVC   SAFRC,=F'20'
         LARL  R5,GETOUT          Where to go after message
         J     DO_TERM            Write message to user's terminal
NOPATH   DS    0H
         MVC   OLDNUM,=A(1)
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG17),MSG17
         MVC   SEG1LEN,=AL2(4+L'MSG17)
         MVC   SAFRC,=F'20'
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
DOTERM   DS    0H
         LARL  5,DO_TERM
         ST    5,DO_PUT@
         J     CONTXML
DOSYSOUT DS    0H
         TM    SYSCFLG,X'80'      SYSOUT CLASS SPECIFIED?
         JZ    NOCLASS            ERROR
         LT    9,SYSCPTR          GET POINTER TO CLASS
         JZ    NOCLASS            HUH?
         CLC   SYSCLEN,=AL2(1)    CHECK LENGTH
         JNE   BADCLASS
*
* Issue message to let the user know the sysout class
         MVC   OLDNUM,=A(2)
         LHI   R10,L'MSG21
         STH   R10,SEG2OFF
         AHI   R10,4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG21),MSG21
         MVC   SEG2LEN,=AL2(5)
*
* MOVE THE SYSOUT CLASS
         MVC   SEG2DATA(1),0(R9)  MOVE INTO MESSAGE
         MVC   SYSOUTT+6,0(R9)    MOVE INTO DYNALLOC TEXT UNIT
         JAS   5,DO_TERM
*
* MORE CODE TO ACTUALLY IMPLEMENT THIS
         MVC   S99RBLN,=AL1(L_S99RB)
         MVI   S99VERB,S99VRBAL
         LA    R5,TEXTP
         ST    R5,S99TXTPP
         LA    R5,DYNS99RB
         ST    R5,DYNS99R@
         OI    DYNS99R@,X'80'     SET END-OF-LIST ON
         MVC   FREET(2),=AL2(DALCLOSE) FREE=CLOSE
         XC    FREET+2(2),FREET+2
         MVC   DDNT(2),=AL2(DALRTDDN)
         MVC   DDNT+2(2),=AL2(1)
         MVC   DDNT+4(2),=AL2(8)
         MVC   SYSOUTT(2),=AL2(DALSYSOU)
         MVC   SYSOUTT+2(2),=AL2(1)
         MVC   SYSOUTT+4(2),=AL2(1)
         MVC   FREET(2),=AL2(DALCLOSE) FREE=CLOSE
         XC    FREET+2(2),FREET+2
         L     1,PDLPTR
         LH    5,LIKELEN
         LTR   5,5
         JZ    NOLIKE2
         MVC   LIKET(2),=AL2(DALDCBDS)
         MVC   LIKET+2(2),=AL2(1)
         STH   5,LIKET+4
         AHI   5,-1
         LA    15,LIKET+6
         L     14,LIKEPTR
         EX    5,MOVESTR
NOLIKE2  DS    0H
         L     1,PDLPTR
         LH    5,USNGLEN
         LTR   5,5
         JZ    NOUSING2
         L     1,PDLPTR
         MVC   USINGT(2),=AL2(DALDCBDD)
         MVC   USINGT+2(2),=AL2(1)
         STH   5,USINGT+4
         AHI   5,-1
         LA    15,USINGT+6
         L     14,USNGPTR
         EX    5,MOVESTR
NOUSING2 DS    0H
         DROP  R1
         LA    0,SYSOUTT
         ST    0,TEXTP+0
         LA    0,FREET
         ST    0,TEXTP+4
         LA    0,DDNT
         ST    0,TEXTP+8
         LA    0,USINGT
         ST    0,TEXTP+12
         LA    0,LIKET
         ST    0,TEXTP+16
         LA    0,=AL2(0)          THIS IS REALLY A DO NOTHING
         ST    0,TEXTP+20
         OI    TEXTP+20,X'80'
         LA    R1,DYNS99R@        POINT TO PARM LIST
         DYNALLOC ,               DO DYNAMIC ALLOCATION
         LTR   R15,R15
         JZ    DOOPEN2
         LA    R1,DYNS99R@        POINT TO PARM LIST
         MVC   SAFRC,=F'20'
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DYNERR             WRITE MESSAGE TO USER
NOCLASS  DS    0H
         MVC   OLDNUM,=A(1)         One message segment
         LHI   R10,L'MSG18+4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG18),MSG18
         MVC   SAFRC,=F'20'
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
BADCLASS DS    0H
         MVC   OLDNUM,=A(1)         One message segment
         LHI   R10,L'MSG19+4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG19),MSG19
         MVC   SAFRC,=F'20'
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
*
XMLERROR DS    0H
* MORE THAN ONE OF DDN, DSNAME, OR PATH SPECIFIED
* INSERT MORE CODE
*
*        Error - more than one of DDN, DSNAME, or PATH entered
*
         MVC   OLDNUM,=A(1)         One message segment
         LHI   R10,L'MSG10+4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG10),MSG10
         MVC   SAFRC,=F'20'
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
CONTXML  DS    0H
         L     R1,PDLPTR
         USING SEQPDL,R1
* 1 ==> NONXML SPECIFIED OR DEFAULTED
* 2 ==> XML SPECIFIED
         MVC   XMLSWITCH,PDLXML
         CLC   PDLXML,=AL2(2)
         JNE   NOXML
         MVC   OLDNUM,=A(1)         One message segment
         LHI   R10,L'MSG20+4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG20),MSG20
         JAS   5,DO_TERM
         LHI   R10,L'XMLBEGIN+4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'XMLBEGIN),XMLBEGIN
         L     5,DO_PUT@
         BASR  5,5
NOXML    DS    0H
         MVC   OLDNUM,=A(4)         Four message segments
         LHI   R5,L'MSG1+4
         STH   R5,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG1),MSG1
         L     R1,PDLPTR
         USING SEQPDL,R1
         LH    R5,PROFLEN           Get profile name length
         AHI   R5,4                 Add 4 for header (length/offset)
         STH   R5,SEG2LEN
         LHI   R5,20                Offset of first insert
         STH   R5,SEG2OFF
         L     R14,PROFPTR          Source: profile pointer from parse
         LA    R15,SEG2DATA         Target: segment data
         LH    R5,SEG2LEN           Get profile length back
         AHI   R5,-1                Decrement for execute
         EX    R5,MOVESTR           Move profile name to msg data
*
         LHI   R5,30                Offset of second insert
         STH   R5,SEG3OFF
         LT    R9,CLSPTR            Get Class pointer from PDL
         JZ    USEUSER              Not specified, default to USER
         LH    R5,CLSLEN            Get class name length
         AHI   R5,4                 Add 4 for header (len/offset)
         STH   R5,SEG3LEN
         LA    R15,SEG3DATA
         LR    R14,R9
         AHI   5,-1
         EX    5,MOVESTR
         MVC   SEG3DATA,0(R9)       Move class name to msg data
         J     SEGNUMS              Proceed
         DROP  R1
USEUSER  DS    0H                   Display USER class
         LHI   R5,8                 4 for "USER" + header
         STH   R5,SEG3LEN
         MVC   SEG3DATA(4),=C'USER' Move USER class name to msg data
SEGNUMS  DS    0H                   Insert number of segments
         LHI   R5,6                 Max 2-digit #segments
         STH   R5,SEG4LEN
         LHI   R5,L'MSG1            Offset of third insert (eol)
         STH   R5,SEG4OFF
         USING ADMN_PROF_MAP,R1
         L     R1,OUTMSG            Get output address in R1
         L     R5,ADMN_PROF_NUMSEG  Number of segment descriptors
         CVD   R5,PACKDEC1          Convert binary to packed decimal
         LA    R5,PACKDEC1          Going to use 8 byte field for both
         UNPK  0(2,R5),6(2,R5)      Then to zoned decimal
         OI    1(R5),X'F0'          Fix the sign nibble
         MVC   SEG4DATA(2),PACKDEC1 Move 2-char number of segments
         DROP  R1
         CLI   XMLSWITCH+1,2      XML FORMAT?
         JNE   NOTXML1
         LHI   0,18
         STH   0,SEG2OFF
         LHI   0,35
         STH   0,SEG3OFF
         LHI   0,53
         STH   0,SEG4OFF
         LHI   5,L'XML1+4
         STH   5,SEG1LEN
         MVC   SEG1DATA(L'XML1),XML1
NOTXML1  DS    0H
         L     5,DO_PUT@
         BASR  5,5
         EJECT
***********************************************************************
*
* Now process the output.  For each segment descriptor, print a message
* indicating the segment name.  For each of its field descriptors,
* print the field name and its data.
*  - For boolean field, print TRUE or FALSE
*  - For repeat fields, print each of its constituent fields
*
* Register usage
*  R1 = R_admin output buffer (OUTMSG)
*  R2 = Number of segment descriptors to process
*  R3 = Address of current segment descriptor
*  R4 = Number of field descriptors to process
*  R5 = Address of current field descriptor
*
***********************************************************************
         USING ADMN_PROF_MAP,R1
         L     R1,OUTMSG             Get output address in R1
         L     R2,ADMN_PROF_NUMSEG   Number of segment descriptors
         LA    R3,ADMN_PROF_PROFNAME Get addr of profile name
         A     R3,ADMN_PROF_NAMELEN  Add length of profile name to get *
                                     addr of 1st segment descriptor
         USING ADMN_PROF_SEGDESC,R3  Basing for segment descriptor
*
         L     R5,ADMN_PROF_FIELDOFFSET Get offset to 1st field desc.
         AR    R5,R1                 Add to base to get address
         USING ADMN_PROF_FIELDDESC,R5 Basing for field descriptor
*
DOSEGS   DS    0H                    For each segment descriptor
         L     R4,ADMN_PROF_NUMFIELDS Number of field descriptors for  *
                                     this segment
         JAS   R14,SEGMSG            Issue segment message
*
DOFIELDS DS    0H                    For each field descriptor
         LLH   R9,ADMN_PROF_FIELDTYPE  Get type of field
         C     R9,=A(ADMN_PROF_RPTHDR) Is it a repeat field header?
         JE    REPEAT                Yes, repeat field
* Boolean fields and normal character fields land here. Go print them.
         JAS   R14,FLDMSG            Display field name and value
         J     NEXTFLD               Get next field
*
REPEAT   DS    0H
         JAS   R15,DOREPEAT          Go process repeat field. R5 will  *
                                     point to next FD on return
         J     NEXTFLD2              Continue with main fields
*
* Set basing for next field descriptor. Decrement count of fields
* to see if we are finished.
*
NEXTFLD  DS    0H
         LA    R5,ADMN_PROF_NEXTFIELD Get next FD address
NEXTFLD2 DS    0H
         JCT   R4,DOFIELDS           Decrement number of fields
*
* Set basing for next segment descriptor. Decrement count of segments
* to see if we are finished. Note that R5 is already pointing to the
* first field descriptor in the next segment.
*
NEXTSEG  DS    0H
         LA    R3,ADMN_PROF_NEXTSEG  Get next SD address
         CLI   XMLSWITCH+1,2      XML OUTPUT?
         JNE   NOXML2
         MVC   OLDNUM,=A(2)
         XC    SEG1OFF,SEG1OFF
         LHI   R0,L'XMLEND+4
         STH   R0,SEG1LEN
         MVC   SEG1DATA(L'XMLEND),XMLEND
         MVC   SEG2LEN(2+2+8),RACSEGSV
         LHI   R0,3
         STH   R0,SEG2OFF
         LR    R14,R5             SAVE
         L     R5,DO_PUT@
         BASR  R5,R5
         LR    R5,R14             RESTORE
NOXML2   DS    0H
         JCT   R2,DOSEGS             Decrement number of segments
         J     FREEOUT               Done with segments, finish up
         EJECT
*
* free the R_admin output storage
*
FREEOUT  DS    0H
         CLI   XMLSWITCH+1,2      XML?
         JNE   FREEOUT2           No
         MVC   OLDNUM,=A(1)
         XC    SEG1OFF,SEG1OFF
         LHI   0,L'XML1B+4
         STH   0,SEG1LEN
         MVC   SEG1DATA(L'XML1B),XML1B
         L     R5,DO_PUT@
         BASR  R5,R5
FREEOUT2 DS    0H
         L     R1,OUTMSG
         L     R0,ADMN_PROF_OUTLEN Output area size to R0
         STORAGE RELEASE,                                              X
               LENGTH=(0),                                             X
               ADDR=(1),                                               X
               SP=127
         DROP  R1
*
* free the parse PDL and our dynamic storage and return...
*
GETOUT   DS    0H
         LA    R1,PDLPTR           Point to the PDL pointer
         IKJRLSA (R1)              Free storage that parse allocated
         LT    R2,UNIXFD
         JM    NOUNIX
         LA    R2,UNIXFD          +0
         LA    R3,RET_VAL         +4
         LA    R4,RET_CODE        +8
         LA    R5,RSN_CODE        +12
         STM   R2,R5,REGSAVE      +16
         OI    REGSAVE+16,X'80'
         LA    R1,REGSAVE         POINT TO PARM LIST
         LINK  SF=(E,BPX1CLO)
NOUNIX   DS    0H
         CLI   OPENSW,1
         JNE   NOCLOSE
         MVC   OPEN(LOPEN),OPENMFL
         LA    R1,OPEN
         CLOSE (DCBOUT),MF=(E,(1)),MODE=31
NOCLOSE  DS    0H
         L     R0,DYNSIZE          Dynamic area size to R0
         L     R13,SAVEAREA+4      Restore R13
         LR    R1,R11              Dynamic data address to R1
         L     R5,SAFRC
         STORAGE RELEASE,                                              X
               LENGTH=(0),                                             X
               ADDR=(1)
         LR    R15,R5
         RETURN (14,12),T,RC=(15)  Restore registers and return
         EJECT
*---------------------------------------------------------------------*
* DOREPEAT:                                                           *
*                                                                     *
* For repeat fields, cycle through each subfield for each occurrence. *
*                                                                     *
* Register input:  R5  = address of repeat field header descriptor    *
*                  R15 = return address                               *
*                                                                     *
* Register output: R5  = address of the next field descriptor after   *
*                        the entire repeat field just processed       *
*                                                                     *
* Register usage:                                                     *
*  R6 - Number of occurrences of repeat field                         *
*  R7 - Number of subfields within each occurrence                    *
*  R8 - Address of subfield descriptor                                *
*  R9 - Work register                                                 *
*---------------------------------------------------------------------*
DOREPEAT DS    0H
         ST    R5,SAVEFD2
         ST    R15,SAVEFD3
         JAS   R14,RPTMSG            Go print header field
         L     R6,ADMN_PROF_RPTNUM   Number of occurrences
         LA    R8,ADMN_PROF_NEXTFIELD Get next FD address
RPTOCC   DS    0H                    Process occurrence
         L     R7,ADMN_PROF_FIELDDIM Number of subfields per occurrence
         DROP  R5
RPTSFLD  DS    0H                    Process subfield
         ST    R5,SAVEFD             Save header field descriptor
         LR    R5,R8                 Get subfield desc in R5 for FLDMSG
         JAS   R14,FLDMSG            Print subfield name and value
         L     R5,SAVEFD             Get header FD back
         USING ADMN_PROF_FIELDDESC,R8 Basing for subfield descriptor
         LA    R8,ADMN_PROF_NEXTFIELD Get next FD address
         DROP  R8
         JCT   R7,RPTSFLD            Loop if subfields remaining
         CLI   XMLSWITCH+1,2      XML?
         JE    NOSEP              No separator needed
         JAS   R14,SEPMSG            Print separator
NOSEP    DS    0H
         JCT   R6,RPTOCC             Loop if occurrences remaining
         CLI   XMLSWITCH+1,2
         JNE   NOTXMLA
         L     R5,SAVEFD2
         USING ADMN_PROF_FIELDDESC,R5 Basing for subfield descriptor
         MVC   SEG2DATA(8),ADMN_PROF_FIELDNAME  Move in field name
         DROP  R5
         MVC   SEG1DATA(L'XMLEND),XMLEND
         LHI   0,L'XMLEND+4
         STH   0,SEG1LEN
         LHI   0,3
         STH   0,SEG2OFF
         XC    SEG1OFF,SEG1OFF
         LA    1,SEG2DATA+7
         LHI   6,8
SQZA     DS    0H
         CLI   0(R1),C' '
         JNE   ESQZA
         BCTR  R1,0
         JCT   R6,SQZA
ESQZA    DS    0H
         AHI   R6,4
         STH   R6,SEG2LEN
         MVC   OLDNUM,=A(2)
         L     R5,DO_PUT@
         BASR  R5,R5
NOTXMLA  DS    0H
         LR    R5,R8                 All done. Set R5 to next FD addr
         L     R15,SAVEFD3
         BR    R15                   Return to caller
*        DROP  R8
*---------------------------------------------------------------------*
* SEGMSG:                                                             *
*                                                                     *
* At the beginning of each segment, issue a message identifying the   *
* segment name.                                                       *
*                                                                     *
* Register input:  R3  = address of segment descriptor                *
*                  R4  = number of fields in this segment             *
*                  R14 = return address                               *
*                                                                     *
* Register output:                                                    *
*                                                                     *
* Register usage:                                                     *
*---------------------------------------------------------------------*
SEGMSG   DS    0H
         STM   14,12,REGSAVE        Save caller's regs
         MVC   OLDNUM,=A(3)         Three message segments
         LHI   R10,L'MSG2+4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG2),MSG2
         LHI   R10,8+4              Get segment name length + header
         STH   R10,SEG2LEN
         LHI   R10,10               Offset of 1st insert
         STH   R10,SEG2OFF
         MVC   SEG2DATA(8),ADMN_PROF_SEGNAME  Move in segment name
         MVC   RACSEGSV+2+2(8),SEG2DATA
         LHI   R2,6                 Max 2-digit number of fields
         STH   R2,SEG3LEN
         LHI   R2,L'MSG2            Insert position of insert (eol)
         STH   R2,SEG3OFF
         CVD   R4,PACKDEC1          Convert binary to packed decimal
         LA    R2,PACKDEC1          Going to use 8 byte field for both
         UNPK  0(2,R2),6(2,R2)      Then to zoned decimal
         OI    1(R2),X'F0'          Fix the sign nibble
         MVC   SEG3DATA(2),PACKDEC1 Move 2-char number of fields
         CLI   XMLSWITCH+1,2      XML?
         JNE   NOTXML2            NO
         MVC   SEG1DATA(L'XML2),XML2
         LHI   0,L'XML2+4
         STH   0,SEG1LEN
         LHI   0,2
         STH   0,SEG2OFF
*
* SQUEEZE OUT TRAILING BLANKS
         LA    R1,SEG2DATA
         LH    R2,SEG2LEN
         AHI   R2,-4
         AR    R1,R2
         AHI   R1,-1
SQZ1     DS    0H
         CLI   0(R1),C' '
         JNE   ESQZ1
         BCTR  R1,0               BACK UP ONE BYTE
         BRCT  R2,SQZ1
ESQZ1    DS    0H
         AHI   R2,4
         STH   R2,SEG2LEN
         LHI   0,11
         STH   0,SEG3OFF
         MVC   RACSEGSV(2+2+8),SEG2LEN
NOTXML2  DS    0H
         L     5,DO_PUT@
         BASR  5,5
*        JAS   5,DO_TERM
         LM    14,12,REGSAVE        Restore caller's regs
         BR    R14                  Return to caller
         EJECT
*---------------------------------------------------------------------*
* RPTMSG:                                                             *
*                                                                     *
* At the beginning of each repeat field, print a message identifying  *
* the repeat field header name. There is no data to print.            *
*                                                                     *
* Register input:  R5  = address of field descriptor                  *
*                  R14 = return address                               *
*                                                                     *
* Register output:                                                    *
*                                                                     *
* Register usage:                                                     *
*                                                                     *
*---------------------------------------------------------------------*
RPTMSG   DS    0H
         STM   14,12,REGSAVE        Save caller's regs
         MVC   OLDNUM,=A(4)         Four message segments
         LHI   R10,L'MSG3+4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG3),MSG3
         LHI   R10,8+4              Get field name length + header
         STH   R10,SEG2LEN
         LHI   R10,16               Offset of 1st insert
         STH   R10,SEG2OFF
         USING ADMN_PROF_FIELDDESC,R5 Basing for field descriptor
         MVC   SEG2DATA(8),ADMN_PROF_FIELDNAME  Move in field name
*
         LHI   R2,6                 Max 2-digit #subfields
         STH   R2,SEG3LEN
         LHI   R2,27                Offset of 2nd insert
         STH   R2,SEG3OFF
         L     R4,ADMN_PROF_FIELDDIM Number of subfields per occurrence
         CVD   R4,PACKDEC1          Convert binary to packed decimal
         LA    R2,PACKDEC1          Going to use 8 byte field for both
         UNPK  0(2,R2),6(2,R2)      Then to zoned decimal
         OI    1(R2),X'F0'          Fix the sign nibble
         MVC   SEG3DATA(2),PACKDEC1 Move 2-char number of subfields
*
         LHI   R2,8                 Max 4-digit #occurrences
         STH   R2,SEG4LEN
         LHI   R2,L'MSG3            Offset of 3rd insert (end of line)
         STH   R2,SEG4OFF
         L     R4,ADMN_PROF_RPTNUM  Number of occurrences
         CVD   R4,PACKDEC2          Convert binary to packed decimal
         LA    R2,PACKDEC2          Point to source
         UNPK  0(4,R2),5(3,R2)      Then to zoned decimal
         OI    3(R2),X'F0'          Fix the sign nibble
         MVC   SEG4DATA(4),PACKDEC2 Move 4-char number of occurrences
*
         DROP  R5
         CLI   XMLSWITCH+1,2      XML?
         JNE   NOTXML3
         MVC   SEG1DATA(L'XML3),XML3
         LHI   0,L'XML3+4
         STH   0,SEG1LEN
         LHI   0,2
         STH   0,SEG2OFF
         LA    1,SEG2DATA
         LH    2,SEG2LEN
         AHI   2,-4
         AR    R1,R2
         AHI   R1,-1
SQZ3     DS    0H
         CLI   0(R1),C' '
         JNE   ESQZ3
         BCTR  R1,0
         JCT   R2,SQZ3
ESQZ3    DS    0H
         AHI   R2,4
         STH   R2,SEG2LEN
         LHI   0,14
         STH   0,SEG3OFF
         LHI   0,39
         STH   0,SEG4OFF
NOTXML3  DS    0H
         L     5,DO_PUT@
         BASR  5,5
         LM    14,12,REGSAVE        Restore caller's regs
         BR    R14                  Return to caller
         EJECT
*---------------------------------------------------------------------*
* FLDMSG:                                                             *
*                                                                     *
* For each field, display the field name and its value.               *
*                                                                     *
* Register input:  R5  = address of field descriptor                  *
*                  R14 = return address                               *
*                                                                     *
* Register output:                                                    *
*                                                                     *
* Register usage:                                                     *
*---------------------------------------------------------------------*
FLDMSG   DS    0H
         USING ADMN_PROF_FIELDDESC,R5 Basing for field descriptor
         STM   14,12,REGSAVE        Save caller's regs
         MVC   OLDNUM,=A(3)         Three message segments
         XC    SEG1OFF,SEG1OFF      Segment 1 offset always 0
         LLH   R9,ADMN_PROF_FIELDTYPE
         N     R9,=A(ADMN_PROF_REPEAT)
         JZ    NOTRPT               Nope
         LHI   R10,L'MSG4RPT+4      Use extra indentation for repeat
         STH   R10,SEG1LEN
         MVC   SEG1DATA(L'MSG4RPT),MSG4RPT
         MVC   SEG2OFF,=AL2(5)      Indent field name 5 spaces
         LHI   R10,L'MSG4RPT        Offset of 3rd insert (end of line)
         STH   R10,SEG3OFF
         J     NXTMSEG
NOTRPT   DS    0H
         LHI   R10,L'MSG4+4
         STH   R10,SEG1LEN
         MVC   SEG1DATA(L'MSG4),MSG4
         MVC   SEG2OFF,=AL2(3)      Indent field name 3 spaces
         LHI   R10,L'MSG4           Offset of 3rd insert (end of line)
         STH   R10,SEG3OFF
NXTMSEG  DS    0H
         LHI   R10,8+4              Get field name length + header
         STH   R10,SEG2LEN
         MVC   SEG2DATA(8),ADMN_PROF_FIELDNAME  Move in field name
*
         ICM   R9,B'0011',ADMN_PROF_FIELDTYPE   Reload field type
         L     R8,=A(ADMN_PROF_BOOLEAN)
         NR    R9,R8                      Is field boolean?
         JZ    NOTBOOL
         L     R9,ADMN_PROF_FIELDFLAG     Get flag word
         L     R8,=A(ADMN_PROF_VALUE)     Get equate for true/false
         SLL   R8,16                      Move halfword to fullword
         NR    R9,R8                      Is boolean value bit on?
         JZ    NOTTRUE
         LHI   R10,4+4              Length("TRUE") + header
         STH   R10,SEG3LEN
         MVC   SEG3DATA(4),=C'TRUE'
         J     DOFPUT
NOTTRUE  DS    0H
         LHI   R10,5+4              Length("FALSE") + header
         STH   R10,SEG3LEN
         MVC   SEG3DATA(5),=C'FALSE'
         J     DOFPUT
NOTBOOL  DS    0H
         L     R10,ADMN_PROF_FIELDLEN     Get length of field data
         C     R10,=A(L'SEG3DATA)         Is value > buffer length?
         JNH   NOPROB                     No
         LHI   R10,L'SEG3DATA             Lazy again, just truncate
NOPROB   DS    0H
         ST    R10,SAVEDLEN               Save it for later
         AHI   R10,4                      Add 4 for header
         STH   R10,SEG3LEN                Store it
         L     R14,ADMN_PROF_DATA_OFFSET  Get offset of field data
         A     R14,OUTMSG                 Add to start of output block
         LA    R15,SEG3DATA               Target: msg segment 3 data
         L     R10,SAVEDLEN               Reload field length
         AHI   R10,-1               Decrement length for move
         EX    R10,MOVESTR          Move field data
DOFPUT   DS    0H
         CLI   XMLSWITCH+1,2      XML OUTPUT?
         JNE   NOTXML4
         LHI   0,L'XML4+4
         STH   0,SEG1LEN
         MVC   SEG1DATA(L'XML4),XML4
         LHI   0,2
         STH   0,SEG2OFF
         LHI   0,3
         STH   0,SEG3OFF
         LHI   0,5
         STH   0,SEG4OFF
         LA    R1,SEG2DATA
         LH    R2,SEG2LEN
         AHI   R2,-4
         AR    R1,R2
         AHI   R1,-1
SQZ4     DS    0H
         CLI   0(R1),C' '
         JNE   ESQZ4
         BCTR  R1,0
         JCT   R2,SQZ4
ESQZ4    DS    0H
         AHI   R2,4
         STH   R2,SEG2LEN
         MVC   SEG4LEN,SEG2LEN
         MVC   SEG4DATA,SEG2DATA
         MVC   OLDNUM,=A(4)
NOTXML4  DS    0H
         L     5,DO_PUT@
         BASR  5,5
         LM    14,12,REGSAVE        Restore caller's regs
         BR    R14                  Return to caller
         EJECT
*---------------------------------------------------------------------*
* SEPMSG:                                                             *
*                                                                     *
* Print a separator line between occurrences of a repeat field.       *
*                                                                     *
* Register input:  R14 = return address                               *
*                                                                     *
* Register output:                                                    *
*                                                                     *
* Register usage:                                                     *
*                                                                     *
*---------------------------------------------------------------------*
SEPMSG   DS    0H
         STM   14,12,REGSAVE        Save caller's regs
         MVC   OLDNUM,=A(1)         One message segment
         LHI   R10,L'MSG5+4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG5),MSG5
         L     5,DO_PUT@
         BASR  5,5
         LM    14,12,REGSAVE        Restore caller's regs
         BR    R14                  Return to caller
         EJECT
*
***********************************************************************
*
*
* Routine called by parse to validate a UNIX path
*
*
***********************************************************************
VALDPATH DS    0H
         STM   14,12,12(13)
         LM    5,7,0(1)           LOAD PARAMETERS
* R5 POINTS TO THE PDE
* R6 IS THE ADDRESS OF A WORK AREA
* R7 MAY BE USED TO POINT TO A SECOND LEVEL MESSAGE
         L     8,0(,5)            POINT TO OPERAND
         LH    10,4(,5)           LENGTH OF OPERAND
         AHI   10,-1              DEC
         SLR   15,15
         JM    PATHERR1
VALRET   DS    0H
         l     14,12(,13)
         LM    0,12,20(13)
         BSM   0,14               RETURN TO PARSE
PATHERR1 DS    0H
         LHI   15,4
         J     VALRET
         EJECT
*
***********************************************************************
*
*
* Routine called by parse to validate a DSN
*
*
***********************************************************************
VALIDSN  DS    0H
         STM   14,12,12(13)
         LM    5,7,0(1)           LOAD PARAMETERS
* R5 POINTS TO THE PDE
* R6 IS THE ADDRESS OF A WORK AREA
* R7 MAY BE USED TO POINT TO A SECOND LEVEL MESSAGE
         SLR   15,15
         J     VALRET             RETURN TO PARSE
         EJECT
RC24     DS    0H
         MVC   SAFRC,=F'24'
         J     GETOUT
DO_TERM DS     0H
         STM   R0,R15,PUTSAVE
         L     R1,CPPLPTR           Get address of CPPL
         USING CPPL,R1              And establish addressability
         L     R2,CPPLUPT
         L     R3,CPPLECT
         DROP  R1
         XC    PUTECB,PUTECB        Clear ECB
         LA    R4,OLDNUM
         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *
               OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)
         LTR   R15,R15
         JNZ   *+2
         LM    R0,R15,PUTSAVE
         BR    5
DO_FILE_F DS   0H                 OUTPUT USING DCB
         STM   R0,R15,PUTSAVE
         L     R1,CPPLPTR           Get address of CPPL
         USING CPPL,R1              And establish addressability
         L     R2,CPPLUPT
         L     R3,CPPLECT
         DROP  R1
         XC    PUTECB,PUTECB        Clear ECB
         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *
               OUTPUT=(OLDNUM,FORMAT,SINGLE,INFOR),MF=(E,PUTIOPL)
         LTR   R15,R15            Putline OK?
         JNZ   RC24               No, exit with RC=24
         L     2,PUTSEQ+8         Get address of record
         LH    3,0(,2)            Get length of record
         AHI   3,-4               Remove length of LLBB prefix
         CH    3,DCBLRECL         Compare record length
         JNH   DO_F_PUT
*
* DATASET LRECL TOO SMALL, INFORM USER
BAD_RECLEN DS  0H
         CVD   3,PACKDEC1
*        UNPK  SEG2DATA(2*L'PACKDEC1-1),PACKDEC1
*        OI    SEG2DATA+2*L'PACKDEC1-2,C'0'
         MVC   EDMKFLD,EDMKINIT
         LA    R1,EDMKFLD
         EDMK  EDMKFLD,PACKDEC1
         LR    R14,R1
         LA    R15,SEG2DATA
         LA    R9,EDMKFLD+L'EDMKFLD-1
         SLR   R9,R1
         EX    9,MOVESTR
         AHI   R9,5
         STH   R9,SEG2LEN
         LHI   R0,L'ERR5+4
         STH   R0,SEG1LEN
*        LHI   R0,2*L'PACKDEC1-1+4
*        STH   R0,SEG2LEN
*        STH   R0,SEG3LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG2OFF,=AL2(46)
         MVC   SEG3OFF,=AL2(L'ERR5)
         MVC   SEG1DATA(L'ERR5),ERR5
         LH    R0,DCBLRECL
         CVD   R0,PACKDEC1
         MVC   EDMKFLD,EDMKINIT
         LA    R1,EDMKFLD
         EDMK  EDMKFLD,PACKDEC1
         LR    R14,R1
         LA    R15,SEG3DATA
         LA    R9,EDMKFLD+L'EDMKFLD-1
         SLR   R9,R1
         EX    9,MOVESTR
         AHI   R9,5
         STH   R9,SEG3LEN
*        UNPK  SEG3DATA(2*L'PACKDEC1-1),PACKDEC1
*        OI    SEG3DATA+2*L'PACKDEC1-2,C'0'
         MVC   OLDNUM,=A(3)
         MVC   SAFRC,=F'20'
         LARL  R5,GETOUT
         J     DO_TERM            Tell terminal user record too long
DO_F_PUT DS    0H
         PUT   DCBOUT             Get buffer
         LH    3,DCBLRECL
         AHI   3,-2
         MVI   0(1),C' '
         LR    14,1
         LA    15,1(,1)
         EX    3,MOVESTR          BLANK OUT I/O BUFFER
         LH    3,0(,2)            Length of record to write
         AHI   3,-5               Actual lrecl-1
         LA    14,4(,2)           First character of actual data
         LR    15,1               Buffer address
         EX    3,MOVESTR          Move data to buffer
         LR    R1,R2              Get buffer address
         LH    R0,0(,R1)          Get length
         STORAGE RELEASE,                                              X
               ADDR=(1),                                               X
               LENGTH=(0),                                             X
               SP=1
         LM    R0,R15,PUTSAVE
         BR    5
DO_FILE_V DS   0H                 OUTPUT USING DCB
         STM   R0,R15,PUTSAVE
         L     R1,CPPLPTR           Get address of CPPL
         USING CPPL,R1              And establish addressability
         L     R2,CPPLUPT
         L     R3,CPPLECT
         DROP  R1
         XC    PUTECB,PUTECB        Clear ECB
         LA    R4,OLDNUM
         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *
               OUTPUT=(OLDNUM,FORMAT,SINGLE,INFOR),MF=(E,PUTIOPL)
         LTR   R15,R15            Putline OK?
         JNZ   RC24               No, exit with RC=24
         L     14,PUTSEQ+8        POINT TO RECORD FROM PUTLINE
         LH    3,0(,14)           GET ITS LENGTH
         CH    9,DCBLRECL         Will it fit?
         JH    BAD_RECLEN         Yes
         PUT   DCBOUT
         L     14,PUTSEQ+8        POINT TO RECORD FROM PUTLINE
         LR    R15,R1             BUFFER RETURNED BY PUT
         AHI   9,-1               ADJ LENGTH FOR EX
         EX    9,MOVESTR          MOVE THE RECORD TO THE BUFFER
         L     R1,PUTSEQ+8        Get buffer address
         LH    R0,0(,R1)          Get length
         STORAGE RELEASE,                                              X
               ADDR=(1),                                               X
               LENGTH=(0),                                             X
               SP=1
         LM    R0,R15,PUTSAVE
         BR    5
DO_UNIX  DS    0H                 OUTPUT USING UNIX
         STM   R0,R15,PUTSAVE
         L     R1,CPPLPTR           Get address of CPPL
         USING CPPL,R1              And establish addressability
         L     R2,CPPLUPT
         L     R3,CPPLECT
         DROP  R1
         XC    PUTECB,PUTECB        Clear ECB
         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *
               OUTPUT=(OLDNUM,FORMAT,SINGLE,INFOR),MF=(E,PUTIOPL)
         LTR   R15,R15            Putline OK?
         JNZ   RC24               No, exit with RC=24
         L     14,PUTSEQ+8        POINT TO RECORD FROM PUTLINE
         LH    9,0(,14)           GET ITS LENGTH
*        STH   9,SEG1LEN
*        XC    SEG1OFF,SEG1OFF
         AHI   9,-5               Actual length of data -1
         LA    R14,4(,R14)        POINT TO DATA
         LA    R15,SEG1DATA       SOMEWHERE TO PUT IT
         EX    R9,MOVESTR         MOVE IT TO BUFFER
         LA    R14,1(R9,R15)
         MVI   0(R14),X'15'       EBCDIC NEWLINE
         AHI   R9,2               Length of record plus the NL
*        MVC   OLDNUM,=A(1)
*        PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,
*              OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)
         ST    R9,SAVEDLEN
         L     R15,BPX1WRT
         L     R2,UNIXFD
         LA    R3,SEG1DATA
         L     R4,SAVEDLEN
         LA    R2,SEG1DATA
         ST    R2,TEXTP
         CALL  (15),(UNIXFD,                                           X
               TEXTP,                                                  X
               =F'0',                                                  X
               SAVEDLEN,                                               X
               RET_VAL,                                                X
               RET_CODE,                                               X
               RSN_CODE),VL,                                           X
               MF=(E,TEXTP+4)
         LM    R0,R1,RET_CODE
         LT    R9,RET_VAL
         JM    WRITFAIL           WRITE FAILED
         C     R9,SAVEDLEN        WROTE ALL THE BYTES?
         JNE   WRT2FAIL           FAILED AGAIN
         L     R1,PUTSEQ+8        Get buffer address
         LH    R0,0(,R1)          Get length
         STORAGE RELEASE,                                              X
               ADDR=(1),                                               X
               LENGTH=(0),                                             X
               SP=1
         LM    R0,R15,PUTSAVE
         BR    5
WRITFAIL DS    0H
         MVC   SAFRC,=F'20'
         UNPK  PACKDEC1(9),RET_CODE(5)
         TR    PACKDEC1(8),TOHEX-C'0'
         UNPK  PACKDEC2(9),RSN_CODE(5)
         TR    PACKDEC2(8),TOHEX-C'0'
         LHI   R0,L'MSG23+4
         STH   R0,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG23),MSG23
         LHI   R0,8
         STH   R0,SEG2LEN
         STH   R0,SEG3LEN
         LHI   R0,37
         STH   R0,SEG2OFF
         LHI   R0,45
         STH   R0,SEG3OFF
         MVC   SEG2DATA(8),PACKDEC1
         MVC   SEG3DATA(8),PACKDEC2
         MVC   OLDNUM,=A(3)
         LARL  R5,GETOUT
         J     DO_TERM
WRT2FAIL DS    0H
         MVC   SAFRC,=F'20'
         LHI   R0,L'MSG24
         STH   R0,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG24),MSG24
         MVC   SEG2LEN,=AL2(8)
         MVC   SEG3LEN,=AL2(8)
         MVC   SEG2OFF,=AL2(32)
         MVC   SEG3OFF,=AL2(43)
         CVD   R9,PACKDEC1
         OI    PACKDEC1+7,C'0'
         MVC   SEG2DATA(8),PACKDEC1
         L     R9,SAVEDLEN
         CVD   R9,PACKDEC1
         OI    PACKDEC1+7,C'0'
         MVC   SEG3DATA(8),PACKDEC1
         LARL  R5,GETOUT
         J     DO_TERM
*        J     GETOUT
BR5      DS    0H                 NO OUTPUT AT ALL?
         WTO   'BR5',ROUTCDE=11
         BR    5
DYNERR   DS    0H                      SAVE RETCODE FOR DAIRFAIL
         USING DFDSECTD,DRFLPARM       SET ADDRESSIBLITY TO PARM LIST
         ST    R15,DRFLR15             SAVE RETCODE FOR DAIRFAIL
         ST    R1,DFS99RBP
         LA    R1,DRFLPARM             LOAD DAIRFAIL PARM LIST ADDRESS
         XC    DRFLPARM(DFLEN),DRFLPARM CLEAR AREA FIRST
         LA    R15,DRFLR15             GET ADDRESS OF SAVED REG 15
         ST    R15,DFRCP               SAVE IN DAIRFAIL PARM LIST
         LA    R15,FULL0               GET ADDRESS OF OF DUMMY F02
         ST    R15,DFJEFF02            SAVE IN DAIRFAIL PARM LIST
         LA    R15,DRFLID              GET ADDRESS OF CALLER'S FLAGS
         ST    R15,DFIDP               SAVE IN DAIRFAIL PARM LIST
         LINK  SF=(E,LINKDRFL)         LINK TO DAIRFAIL SERVICE ROUTINE
         BR    5
*
***********************************************************************
*
*
* PARSE macros used to describe the command operands
*
*
***********************************************************************
RACPDE   IKJPARM
KWCLASS  IKJKEYWD
         IKJNAME 'CLASS',SUBFLD=SEQCLASS
KWPROF   IKJKEYWD
         IKJNAME 'PROFILE',SUBFLD=SEQPROF
KWOUTPUT IKJKEYWD DEFAULT='TERMINAL'
         IKJNAME 'DDNAME',SUBFLD=DDN,                                  X
               ALIAS=('FI','FILE')
         IKJNAME 'DSNAME',SUBFLD=DSNAME,                               X
               ALIAS=('DATASET','DA')
         IKJNAME 'PATH',SUBFLD=PATH ALIAS=('PATH')
         IKJNAME 'TERMINAL'
         IKJNAME 'SYSOUT',SUBFLD=OUTCLASS
KWALLOC  IKJKEYWD
         IKJNAME 'USING',SUBFLD=USING1
         IKJNAME 'LIKE',SUBFLD=LIKE1
KWXML    IKJKEYWD DEFAULT='NONXML'
         IKJNAME  'NONXML'
         IKJNAME  'XML'
SEQCLASS IKJSUBF
SFCLASS  IKJIDENT 'CLASS',MAXLNTH=8,FIRST=ANY,OTHER=ANY,               *
               DEFAULT='USER',                                         *
               HELP=('RACF class name from which to extract')
*
SEQPROF  IKJSUBF
SFPROF   IKJIDENT 'PROFILE',MAXLNTH=255,FIRST=ANY,OTHER=ANY,           *
               HELP=('RACF profile name to extract'),ASIS,             *
               PROMPT='Profile name. Use <user>.<group> for CONNECT'
DDN      IKJSUBF
XMLDD    IKJIDENT 'DDN',UPPERCASE,MAXLNTH=8,FIRST=ALPHA,               X
               OTHER=ALPHANUM,                                         X
               HELP=('DD name to use for XML output')
DSNAME   IKJSUBF
XMLDS    IKJPOSIT DSNAME,USID,                                         X
               HELP=('Dataset Name to be used for XML output')
PATH     IKJSUBF
XMLPAT   IKJIDENT 'PATH',ASIS,MAXLNTH=255,                             X
               FIRST=ANY,OTHER=ANY,                                    X
               VALIDCK=VALDPATH,                                       X
               HELP=('UNIX path and file name')
OUTCLASS IKJSUBF
OUTCLAS  IKJIDENT 'SYSOUT',UPPERCASE,MAXLNTH=1,                        X
               FIRST=NONATNUM,                                         X
               HELP=('SYSOUT class (A..Z,0..9)')
USING1   IKJSUBF
USING    IKJIDENT 'USING',UPPERCASE,MAXLNTH=8,                         X
               FIRST=ALPHA,OTHER=ALPHANUM,                             X
               HELP=('ATTR name for dataset allocation considerations')
LIKE1    IKJSUBF
LIKE     IKJPOSIT DSNAME,USID,                                         X
               HELP=('Dataset Name to be used as a model for allocatingX
                a new output dataset.')
         IKJENDP
         EJECT
*
* static data
*
DATA     DS    0D
DYNSIZE  DC    AL4(SIZEDATD)       dynamic area size
USERCLS  DC    CL4'USER'           USER class
GRPCLS   DC    CL5'GROUP'          GROUP class
CONCLS   DC    CL7'CONNECT'        CONNECT class
PUTSEQ   PUTLINE MF=L
OUTTBL   DC    A(PDEXML1-PDEXML1)
         DC    A(PDEXML2-PDEXML1)
         DC    A(PDEXML3-PDEXML1)
         DC    A(0)               NO PDE FOR TERMINAL
         DC    A(PDESYSC-PDEXML1)
         DC    A(0)               NO PDE FOR XML/NONXML
LXMLTBL  EQU   *-OUTTBL
MAXTBL   DC    A(LXMLTBL)
OUTP     DC    A(DODDN),A(DODSN),A(DOPATH)
         DC    A(DOTERM),A(DOSYSOUT)
MOVESEG2 MVC   SEG2DATA+0(0),0(10)
MOVESTR  MVC   0(*-*,R15),0(R14)
*
* Define text of command output and error messages. There must be
* a leading blank so that we are immune to the TSO PROFILE MSGID
* setting.
*
XMLBEGIN DC    C' <?xml version="1.0"?>'
MSG1     DC    CL41' Displaying profile  in class . Segments:'
XML1     DC    C' <RACSEQ><PROFILE></PROFILE><CLASS></CLASS><SEGMENTS><X
               /SEGMENTS>' 18/35/53
XML1B    DC    C' </RACSEQ>'
MSG2     DC    CL18' Segment:  Fields:'
XML2     DC    C' <><FIELDS></FIELDS>' 2/11
MSG3     DC    CL40'   Repeat field: Subfields: Occurrences:'
XML3     DC    C' <><SUBFIELDS></SUBFIELDS><OCCURRENCES></OCCURRENCES>'
*                  2           14 39
XMLEND   DC    C' </>' 3
MSG4     DC    CL4'   :'             2 spaces||fieldname||:||value
XML4     DC    C' <></>' 2/3/5
MSG4RPT  DC    CL6'     :'           4 spaces||fieldname||:||value
MSG5     DC    CL50'     ---------------------------------------------'
MSG6     DC    CL46' R_admin Error! SAFrc  - RACFrc  - RACFreason '
MSG7     DC    CL26' Error! Unsupported class!'
MSG8     DC    CL45' Syntax: RACSEQ CLASS(class) PROFILE(profile)'
MSG9     DC    CL28' IKJPARS error! Return Code '
MSG10    DC    C' Error! At most one of DDN, DSNAME, and PATH may be spX
                ecified'
MSG11    DC    C' Error! No data set name specified!'
MSG12    DC    C' Output to DSN:'
MSG14    DC    C' Output to DD:'
MSG15    DC    C' Error! No DD name specified!'
MSG16    DC    C' Output to PATH:'
MSG17    DC    C' Error! No path name specified!'
MSG18    DC    C' Error! SYSOUT has no operand.'
MSG19    DC    C' Error! SYSOUT is not exactly 1 character.'
MSG20    DC    C' Output will be in XML format.'
MSG21    DC    C' Output will be directed to SYSOUT class '
MSG22    DC    C' PATH must begin at the root. It may not be relative.'
MSG23    DC    C' UNIX write failed. RET_VAL=-1, RC=0x ,RSN=0x'
MSG24    DC    C' UNIX write incomplete. Desired= , Written='
ERR1     DC    C' Logic error. No logic to process a specified option.'
ERR2     DC    C' RECFM is unrecognized or invalid. Aborting.'
ERR3     DC    C' DSORG unusable. Must be PS. Aborting'
ERR4     DC    C' Open for UNIX file failed. RC=0x ,RSN=0x'
ERR5     DC    C' Error. LRECL too small for record. Record is  bytes  x
               long. File LRECL is '
EDMKINIT DC    (2*L'PACKDEC1-1)X'20'
TOHEX    DC    C'0123456789ABCDEF'
         DS    0D
         LTORG
         DS    0D
DCBINIT  DCB   MACRF=(PL),                                             X
               DSORG=PS
LDCB     EQU   *-DCBINIT
OPENMFL  OPEN  (DCBINIT,(OUTPUT)),MF=L,MODE=31
LOPEN    EQU   *-OPENMFL
         DS    0D
LDATA    EQU   *-DATA
FULL0    DC    F'0'                    ADDRESS OF NULL IKJEFF02 ROUTINE
DRFLR15  DC    A(0)
DRFLPARM DC    XL(DFLEN)'00'
DRFLID   DC    AL1(DFWTP),AL1(DFSVC99)
BPX1WRT  DS    F                  DYNAMIC ADDRESS OF BPX1WRT
LINKDRFL LINK  EP=IKJEFF18,SF=L        LINK TO DAIRFAIL SERVICE ROUTINE
BPX1CLO  LINK  EP=BPX1CLO,SF=L
BPX1OPN  LINK  EP=BPX1OPN,SF=L
*
* Mapped by BPXYMODE & BPXYFTYP
UNIXMODE DC    AL1(0),AL1(0),AL1(S_IRUSR)
         DC    AL1(S_IRWXU2+S_IRGRP)
*
* Mapped by BPXYOPNF
O_FLAG DC      AL1(0),AL1(0),AL1(0)
         DC    AL1(O_CREAT+O_TRUNC+O_WRONLY)
*
* THEN FOLLOWING CODE IS COPIED INTO THE 24-BIT DYNAMIC
* AREA SO THAT OPEN, IN 24 BIT MODE, CAN USE IT
* IT SIMPLY DOES A BRANCH-AND-SET-MODE TO THE REAL
* EXIT AT OPEN31.
OPEN24I  DS    0D
         LA    1,0(,1)            CLEAR HOB OF R1 SO IT WON'T HURT
*                                 ANYTHING IN 31 BIT MODE
         L     15,AOPEN31-OPEN24I(,15)
         BSM   14,15              INVOKE 31 BIT EXIT
AOPEN31  DC    A(X'80000000'+OPEN31)
LOPEN24  EQU   *-OPEN24I
*
* END OF COPIED CODE
*
* DCB OPEN EXIT R1 POINTS TO DCB UPON ENTRY
OPEN31   DS    0H
         CLI   DCBRECFM-IHADCB(R1),0
         JNE   GOTRECFM
         MVI   DCBRECFM-IHADCB(R1),DCBRECV+DCBRECBR
GOTRECFM DS    0H
         SLR   R0,R0
         CH    R0,DCBLRECL-IHADCB(R1)
         JNZ   GOTLRECL
         LHI   3,125
         STH   3,DCBLRECL-IHADCB(R1)
GOTLRECL DS    0H
         CH    R0,DCBBLKSI-IHADCB(R1)
         JNZ   GOTBLKSI
         LHI   R3,4096
         STH   R3,DCBBLKSI-IHADCB(R1)
GOTBLKSI DS    0H
         TM    DCBRECFM-IHADCB(R1),DCBRECU
         JO    RECFMU
         TM    DCBRECFM-IHADCB(R1),DCBRECV
         JO    RECFMV
         TM    DCBRECFM-IHADCB(R1),DCBRECF
         JO    RECFMF
         J     BSM014
RECFMU   DS    0H
         MVC   DCBLRECL-IHADCB(1),DCBBLKSI-IHADCB(R1)
         J     BSM014
RECFMV   DS    0H
         LH    R3,DCBBLKSI
         AHI   R3,-4
         CH    R3,DCBLRECL
         JNL   BSM014
         STH   R3,DCBLRECL
         J     BSM014
RECFMF   DS    0H
         LH    R3,DCBBLKSI
         SLR   R2,R2
         LH    R0,DCBLRECL
         DR    R2,R0
         LTR   R2,R2
         JZ    BSM014
         MH    R3,DCBLRECL-IHADCB(R1)
         STH   R3,DCBBLKSI-IHADCB(R1)
BSM014   DS    0H
         BSM   0,14               RETURN TO OPEN
*
* DSECT for this routine's dynamic area
*
DATD     DSECT
         DS    0D
SAVEAREA DS    18F                 register save area
REGSAVE  DS    16F                 internal subroutine save area
UNIXFD   DS    F                  UNIX File Descriptor
PATHLEN  DS    F
RET_VAL  DS    F                  UNIX return value
RET_CODE DS    F                  UNIX return code
RSN_CODE DS    F                  UNIX reason code
SAVEDLEN DS    F                   Temp variable for field data length
SAVEFD   DS    F                   Temp variable for @ field descriptor
SAVEFD2  DS    F                   Temp variable for @ field descriptor
SAVEFD3  DS    F                   Temp variable for @ field descriptor
PUTSAVE  DS    16F
DYNPPL   DS    CL(L_PPL)           PPL area
PPLPTR   DS    F                   Pointer to DYNPPL
CPPLPTR  DS    F                   Pointer to input CPPL
PDLPTR   DS    F                   Pointer to output PDL
MYECB    DS    F                   Command ECB
PUTIOPL  DS    4F                  E-form IOPL area for PUTLINE
PUTECB   DS    F                   ECB for PUTLINE
PACKDEC1 DS    CL8                 Output for CVD
PACKDEC2 DS    CL8                 Output for CVD
PACKDEC3 DS    CL8                 Output for CVD
EDMKFLD  DS    CL(2*L'PACKDEC1-1)' '
*
* Output Line Descriptor (OLD) fields for PUTLINE
OLDNUM   DS    F                   Number of segments
OLDSEGA1 DS    F                   Pointer to first message segment
OLDSEGA2 DS    F                   Pointer to second message segment
OLDSEGA3 DS    F                   Pointer to third message segment
OLDSEGA4 DS    F                   Pointer to fourth message segment
SEG1LEN  DS    H                   Segment 1 length
SEG1OFF  DS    H                   Segment 1 offset
SEG1DATA DS    CL100               Segment 1 data
SEG2LEN  DS    H                   Segment 2 length
SEG2OFF  DS    H                   Segment 2 offset
SEG2DATA DS    CL100               Segment 2 data
SEG3LEN  DS    H                   Segment 3 length
SEG3OFF  DS    H                   Segment 3 offset
SEG3DATA DS    CL255               Segment 3 data
SEG4LEN  DS    H                   Segment 4 length
SEG4OFF  DS    H                   Segment 4 offset
SEG4DATA DS    CL255               Segment 4 data
*
* Parms for IRRSEQ00
*
WORKAREA DS    CL1024
ALET     DS    F
SAFRC    DS    F
RACFRC   DS    F
RACFRS   DS    F
FUNCODE  DS    AL1
USER     DS    0CL9
USERLEN  DS    AL1
USERID   DS    CL8
ACEE     DS    F
SUBPOOL  DS    AL1
OUTMSG   DS    F
RADPLIST DS    CL(ADMN_PROF_PROFNAME-ADMN_PROF_MAP) Plist header
EXTPROF  DS    CL17                                 Profile to extract
DYNEFF@  DS    F
DYNEFF   DS    (L_EFF)C
DO_PUT@  DS    A
DYNS99R@ DS    A
DYNS99RB DS    (L_S99RB)C' '
         DS    0F
TEXTP    DS    A  +0              ADDRESS OF DSN TEXT UNIT
         DS    A   4              ADDRESS OF RETURN DDN TEXT UNIT
         DS    A   8              ADDRESS OF DISP1
         DS    A   12             ADDRESS OF DISP2
         DS    A   16             ADDRESS OF DISP3
         DS    A   20             FREE=CLOSE
         DS    A   24             ADDRESS OF MEMBER
         DS    A   28             ADDRESS OF LIKET
         DS    A   32             ADDRESS OF USING
         DS    A   36             ADDRESS OF NOTHING
DSNT     DS    H,H,H,CL44         KEY=DALDSNAM
MEMBERT  DS    H,H,H,CL8          KEY=DALMEMBR
DISP1T   DS    3H,X               KEY=DALSTATS
DISP2T   DS    3H,X               KEY=DALNDISP
DISP3T   DS    3H,X               KEY=DALCDISP
FREET    DS    2H                 KEY=DALCLOSE
LIKET    DS    3H,CL44            KEY=DALDCBDS
USINGT   DS    3H,CL8             KEY=DALDCBDD
DDNT     DS    3H,CL8             KEY=DALRTDDN
SYSOUTT  DS    3H,C               KEY=DALSYSOU
*
* Parm list for IRRSEQ00.  That is, a list of adresses to the actual
* Parameter data defined above.
*
WORKAREA@ DS    A
ALET1@    DS    A
SAFRC@    DS    A
ALET2@    DS    A
RACFRC@   DS    A
ALET3@    DS    A
RACFRS@   DS    A
FUNCODE@  DS    A
RADPLIST@ DS    A
USER@     DS    A
ACEE@     DS    A
SUBPOOL@  DS    A
OUTMSG@   DS    A
RACSEGSV DS    H,H,CL8            len, offset, data
         DS    0F
DCBOUT    DS    (LDCB)C' '
         DS    0F
OPEN     DS    (LOPEN)C' '
XMLSWITCH DS    H
OPENSW   DS    X
         DS    0D
OPEN24   DS    (LOPEN24)XL1
EXLST    DS    F
         DS    0D
SIZEDATD EQU   *-DATD              length of DSECT
*
***********************************************************************
* The following DSECT maps the results of the parse.                  *
***********************************************************************
         EJECT
SEQPDL   DSECT
PDLHDR   DS    CL8
PDLCLASS DS    H
PDLPROF  DS    H
PDLOUTPUT DS   H
PDLALLOC DS    H
PDLXML   DS    H
*
* PDE FOR THE CLASS()
PDECLASS DS    0CL8
CLSPTR   DS    F
CLSLEN   DS    H
         DS    CL2
*
* PDE FOR PROFILE()
PDEPROF  DS    0CL8
PROFPTR  DS    F
PROFLEN  DS    H
         DS    CL2
*
* PDE FOR DDN()
PDEXML1  DS    0CL8
XML1PTR  DS    A
XML1LEN  DS    H
XML1FLG  DS    X,X
*
* PDE FOR DSNAME()
PDEXML2  DS    0CL24
XML2PTR  DS    A
XML2LEN  DS    H
XML2FLG  DS    X,X
XML2MEM  DS    A
XML2LN2  DS    H
XML2FLG2 DS    X,X
XML2PSWD DS    A
XML2LN3  DS    H
XML2FLG3 DS    X,X
*
* PDE FOR PATH()
PDEXML3  DS    0CL8
XML3PTR  DS    A
XML3LEN  DS    H
XML3FLG  DS    X,X
*
* PDE FOR TERMINAL (AIN'T ONE!)
*DETERM  DS    0CL8
*ERMPTR  DS    A
*ERMLEN  DS    H
*ERMFLG  DS    X,X
*
* PDE FOR SYSOUT()
PDESYSC  DS    0CL8
SYSCPTR  DS    A
SYSCLEN  DS    H
SYSCFLG  DS    X
         DS    X
*
* PDE FOR USING()
PDEUSNG  DS    0CL8
USNGPTR  DS    A
USNGLEN  DS    H
USNGFLG  DS    X,X
*
* PDE FOR LIKE()
PDELIKE  DS    0CL24
LIKEPTR  DS    A
LIKELEN  DS    H
LIKEFLG  DS    X,X
LIKEMEM  DS    A
LIKELN2  DS    H
LIKEFLG2 DS    X,X
LIKEPSWD DS    A
LIKELN3  DS    H
LIKEFLG3 DS    X,X
* PDE FOR XML/NONXML (AIN'T ONE!)
*
* equates
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
*
* MAPPINGS
*
         IKJCPPL
         IKJPPL
L_PPL    EQU   *-PPL
         IKJEFFGF GFDSECT=YES
L_EFF    EQU   *-GFDSECTD
         EJECT
         IRRPCOMP
         EJECT
         CVT   DSECT=YES        CVT MAPPING NEEDED FOR CALLTSSR MACRO
         EJECT
         DCBD  DSORG=PS
         IEFZB4D2
         IEFZB4D0
L_S99RB  EQU   S99RBEND-S99RB
         IEFSJDKY
         IKJEFFDF DFDSECT=YES      DAIRFAIL PARM LIST MAP
         BPXYOPNF
         BPXYMODE
         BPXYFTYP
         END   RACSEQ
