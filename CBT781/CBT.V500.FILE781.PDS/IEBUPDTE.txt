//* INSERT JOB CARD HERE
//* YOU MUST DOWNLOAD THE RACSEQ SOURCE CODE FROM THE IBM
//* WEB SITE AT:
//* http://www.ibm.com/servers/eserver/zseries/zos/racf/racseq.html
//* PLACE THE SOURCE CODE IN THIS LIBRARY UNDER THE NAME RACSEQ
//* AFTER THAT, ASSEMBLE THE CODE INTO A TSO ACCESSABLE LIBRARY
//* USING JCL MODELLED ON MEMBER ASMACL
// SET THISDSN=this.dsn
//* MODIFY this.dsn ABOVE TO THE ACTUAL DSN
//STEP010  EXEC  PGM=IEBUPDTE,
//             PARM=MOD
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=OLD,DSN=&THISDSN
//SYSUT2   DD  DISP=OLD,DSN=*.SYSUT1
//*
//SYSIN    DD  *
./  CHANGE LIST=ALL,NAME=RACSEQ
./ DELETE  SEQ1=00010003,SEQ2=00010003
RACSEQ   TITLE 'RACSEQ - USE R_ADMIN TO EXTRACT RACF PROFILE'
         PRINT OFF
         COPY  IEABRC
         PRINT ON
         SYSSTATE ARCHLVL=2
./ DELETE  SEQ1=00660003,SEQ2=00670003
RACSEQ   RMODE ANY
./ DELETE  SEQ1=00690003,SEQ2=00710003
*        USING RACSEQ,R12          set base register
         LARL  R12,DATA           POINT TO STATIC DATA AREA
         USING DATA,R12
         LR    R10,R1             SAVE CPPL ADDRESS
./ DELETE  SEQ1=00760003,SEQ2=00770003
         STORAGE OBTAIN,                                               X
               LOC=24,                                                 X
               LENGTH=(0)
         USING S99RB,DYNS99RB
         LARL  R10,BR5            POINT TO "NO OUTPUT" SUBROUTINE
         ST    R10,DO_PUT@        PUT IT IN SUBROUTINE ADDRESS
         XC    OPENSW,OPENSW
         LHI   0,-1
         ST    0,UNIXFD           Initialize UNIX File Descriptor
         MVC   DCBOUT(LDCB),DCBINIT
         USING IHADCB,DCBOUT
         MVC   OPEN24(LOPEN24),OPEN24I
         LA    0,OPEN24           POINT TO EXIT
         ST    0,EXLST
         MVI   EXLST,X'85'        OPEN EXIT CODE+HOB ON.
         LA    0,EXLST
         STCM  0,B'0111',DCBEXLSA POINT TO EXLST IN DCB
         LA    R0,PUTECB
./ DELETE  SEQ1=01220003,SEQ2=01220003
         JZ    GETANS               Go process results
         XC    DYNEFF(L_EFF),DYNEFF
         LA    1,DYNEFF
         USING GFDSECTD,1
         MVC   GFCPPLP,CPPLPTR
         ST    15,GFRCODE
         LHI   0,GFPARSE
         STH   0,GFCALLID
         ST    1,DYNEFF@
         DROP  1
         LA    1,DYNEFF@
         OI    0(1),X'80'
         LINK  EP=IKJEFF19
./ DELETE  SEQ1=01290003,SEQ2=01290003
         LHI   R10,L'MSG9+4
./ DELETE  SEQ1=01320003,SEQ2=01330003
         MVC   SEG1DATA(L'MSG9),MSG9
         LHI   R10,6                2-digit rc + header
./ DELETE  SEQ1=01350003,SEQ2=01350003
         LHI   R10,L'MSG9           Insert position of rc (eol)
./ DELETE  SEQ1=01420003,SEQ2=01450003
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
./ DELETE  SEQ1=01520003,SEQ2=01520003
         L     R1,0(,R1)            Get the PDL address itself
./ DELETE  SEQ1=01620003,SEQ2=01620003
         JZ    MOREPRMS             No, default to USER
./ DELETE  SEQ1=01650003,SEQ2=01650003
         JNE   CHKCON               Nope
./ DELETE  SEQ1=01670003,SEQ2=01670003
         J     MOREPRMS             Continue with R_admin parms
./ DELETE  SEQ1=01700003,SEQ2=01700003
         JNE   CHKUSR               Nope
./ DELETE  SEQ1=01720003,SEQ2=01720003
         J     MOREPRMS             Continue with R_admin parms
./ DELETE  SEQ1=01750003,SEQ2=01750003
         JE    MOREPRMS             Yup
./ DELETE  SEQ1=01810003,SEQ2=01810003
         LHI   R10,L'MSG7+4
./ DELETE  SEQ1=01840003,SEQ2=01890003
         MVC   SEG1DATA(L'MSG7),MSG7
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
*
         L     R1,PDLPTR
         USING SEQPDL,R1            Get addressability to PDL
./ DELETE  SEQ1=02080003,SEQ2=02080003
         JNZ   GETPROF
./ DELETE  SEQ1=02130003,SEQ2=02130003
         LHI   R10,L'MSG8+4
./ DELETE  SEQ1=02160003,SEQ2=02160003
         MVC   SEG1DATA(L'MSG8),MSG8
./ DELETE  SEQ1=02180003,SEQ2=02210003
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
*
./ DELETE  SEQ1=02790003,SEQ2=02790003
         BASR  R14,R15
./ DELETE  SEQ1=02830003,SEQ2=02840003
         LT    R5,SAFRC           Get SAF return code
         JZ    GOODSEQ
./ DELETE  SEQ1=03030003,SEQ2=03030003
         LHI   R5,L'MSG6+4
./ DELETE  SEQ1=03060003,SEQ2=03070003
         MVC   SEG1DATA(L'MSG6),MSG6
         LHI   R5,6                 All inserts will be 2 chars + hdr
./ DELETE  SEQ1=03110003,SEQ2=03110003
         LHI   R5,22                Insert position of SAF rc
./ DELETE  SEQ1=03140003,SEQ2=03140003
         LHI   R5,32                Insert position of RACF rc
./ DELETE  SEQ1=03170003,SEQ2=03170003
         LHI   R5,L'MSG6            Insert position of RACF rc (eol)
./ DELETE  SEQ1=03200003,SEQ2=03230003
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
*
         L     R1,PDLPTR
         USING SEQPDL,R1
         LH    R9,PDLOUTPUT
         LTR   R9,R9
         JZ    CONTXML            NO OUTPUT PARMS AT ALL
*
         AHI   R9,-1              MAKE ZERO BASED
         SLL   R9,2               MAKE OFFSET
         C     R9,MAXTBL          COMPARE TO MAX
         JNL   OUTX               TOO BIG???
         L     R10,OUTP(R9)       PROCESSING ROUTINE
         L     R9,OUTTBL(R9)      GET OFFSET
         LA    R9,PDEXML1(R9)     GET ADDRESS
         BR    R10                PROCESS OPTION
*
* PROCESS OTHER OPTIONS
OUTX     DS    0H
         L     R8,MAXTBL
         MVC   SAFRC,=F'20'
         LARL  R5,GETOUT
         LHI   R0,L'ERR1+4
         STH   R0,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'ERR1),ERR1
         MVC   OLDNUM,=A(1)
         J     DO_TERM
DODDN    DS    0H
* DDN(...)
         TM    XML1FLG,X'80'      ANY DDN?
         JZ    NODDN              NO???
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG14),MSG14
         MVC   SEG1LEN,=AL2(4+L'MSG14)
         MVC   SEG2OFF,=AL2(L'MSG14)
         LH    9,XML1LEN
         AHI   9,4
         STH   9,SEG2LEN
         AHI   9,-5
         JM    NODDN
         MVC   OLDNUM,=A(2)
         L     14,XML1PTR
         LA    R15,SEG2DATA
         EX    9,MOVESTR
         MVC   DCBDDNAM,=CL8' '
         LA    R15,DCBDDNAM
         EX    9,MOVESTR
         LARL  5,DOOPEN3          WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
*
NODDN    DS    0H
         MVC   OLDNUM,=A(1)
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG15),MSG15
         MVC   SEG1LEN,=AL2(4+L'MSG15)
         MVC   SAFRC,=F'20'
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
DODSN    DS    0H
* DSNAME(...)
         TM    XML2FLG,X'80'      ANY DSN?
         JZ    NODSN              NO???
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG12),MSG12
         MVC   SEG1LEN,=AL2(4+L'MSG12)
         MVC   SEG2OFF,=AL2(L'MSG12)
         LH    9,XML2LEN          GET LENGTH OF DSN
         AHI   9,5
         STH   9,SEG2LEN
         AHI   9,-6
         JM    NODSN
         L     10,XML2PTR         POINT TO DSN
         EX    9,MOVESEG2         MOVE IT IN
         MVC   OLDNUM,=A(2)
         JAS   5,DO_TERM
         MVC   S99RBLN,=AL1(L_S99RB)
         MVI   S99VERB,S99VRBAL
         LA    R5,TEXTP
         ST    R5,S99TXTPP
         LA    R5,DYNS99RB
         ST    R5,DYNS99R@
         OI    DYNS99R@,X'80'     SET END-OF-LIST ON
         LA    0,DSNT
         ST    0,TEXTP+0
         LA    0,DDNT
         ST    0,TEXTP+4
         LA    0,DISP1T
         ST    0,TEXTP+8
         LA    0,DISP2T
         ST    0,TEXTP+12
         LA    0,DISP3T
         ST    0,TEXTP+16
         LA    0,FREET
         ST    0,TEXTP+20
         LA    0,MEMBERT
         ST    0,TEXTP+24
         LA    0,LIKET
         ST    0,TEXTP+28
         LA    0,USINGT
         ST    0,TEXTP+32
         LA    0,=AL2(0)          THIS IS REALLY A DO NOTHING
         ST    0,TEXTP+36
         OI    TEXTP+36,X'80'
         MVC   MEMBERT,=AL2(0)
         MVC   LIKET,=AL2(0)
         MVC   USINGT,=AL2(0)
         LH    R9,XML2MEM
         LTR   R9,R9              MEMBER NAME?
         JZ    NOMEM              NOPE
         STH   R9,MEMBERT+4
         MVC   MEMBERT(2),=AL2(DALMEMBR)
         MVC   MEMBERT+2(2),=AL2(1)
         LA    15,MEMBERT+6
         L     14,XML2MEM
         AHI   9,-1
         EX    9,MOVESTR          MOVE IN MEMBER NAME
NOMEM    DS    0H
         L     R1,PDLPTR
         MVC   DSNT(2),=AL2(DALDSNAM)
         MVC   DSNT+2(2),=AL2(1)
         LH    5,XML2LEN
         STH   5,DSNT+4
         LA    15,DSNT+6
         L     14,XML2PTR
         AHI   5,-1
         EX    5,MOVESTR
         MVC   DISP1T(2),=AL2(DALSTATS)
         MVC   DISP1T+2(2),=AL2(1)
         MVC   DISP1T+4(2),=AL2(1)
         MVI   DISP1T+6,X'01'     DISP=OLD
         MVC   DISP2T(2),=AL2(DALNDISP)
         MVC   DISP2T+2(2),=AL2(1)
         MVC   DISP2T+4(2),=AL2(1)
         MVI   DISP2T+6,X'08'     DISP=KEEP
         MVC   DISP3T(2),=AL2(DALCDISP)
         MVC   DISP3T+2(2),=AL2(1)
         MVC   DISP3T+4(2),=AL2(1)
         MVI   DISP3T+6,X'08'     DISP=KEEP
         MVC   FREET(2),=AL2(DALCLOSE) FREE=CLOSE
         XC    FREET+2(2),FREET+2
         LH    5,LIKELEN
         LTR   5,5
         JZ    NOLIKE
         MVC   LIKET(2),=AL2(DALDCBDS)
         MVC   LIKET+2(2),=AL2(1)
         STH   5,LIKET+4
         AHI   5,-1
         LA    15,LIKET+6
         L     14,LIKEPTR
         EX    5,MOVESTR
NOLIKE   DS    0H
         LH    5,USNGLEN
         LTR   5,5
         JZ    NOUSING
         MVC   USINGT(2),=AL2(DALDCBDD)
         MVC   USINGT+2(2),=AL2(1)
         STH   5,USINGT+4
         AHI   5,-1
         LA    15,USINGT+6
         L     14,USNGPTR
         EX    5,MOVESTR
         LA    R1,USINGT
NOUSING  DS    0H
         MVC   DDNT(2),=AL2(DALRTDDN)
         MVC   DDNT+2(2),=AL2(1)
         MVC   DDNT+4(2),=AL2(8)
         LA    R1,DYNS99R@        POINT TO PARM LIST
         DYNALLOC ,               DO DYNAMIC ALLOCATION
         LTR   R15,R15
         JZ    DOOPEN2
         MVI   DISP1T+6,X'04'     DISP=NEW
         MVI   DISP2T+6,X'02'     DISP=CATLG
         MVI   DISP3T+6,X'02'     DISP=CATLG
         LA    R1,DYNS99R@        POINT TO PARM LIST
         DYNALLOC ,               TRY DISP=(NEW,CATLG,CATLG)
         LTR   R15,R15
         JZ    DOOPEN2
         LA    R1,DYNS99R@        POINT TO PARM LIST
         MVC   SAFRC,=F'20'
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DYNERR             WRITE MESSAGE TO USER
DOOPEN2  DS    0H
         LH    5,DDNT+4           GET LENGTH OF DDNAME
         MVC   DCBDDNAM,=CL8' '   BLANK IT
         LA    15,DCBDDNAM
         LA    14,DDNT+6
         AHI   5,-1
         EX    5,MOVESTR
DOOPEN3  DS    0H
         MVC   OPEN(LOPEN),OPENMFL
         LA    R1,OPEN
         OPEN  (DCBOUT,(OUTPUT)),MF=(E,(1)),MODE=31
         LTR   R5,R15
         JZ    OPENOK
         WTO   'OPEN FAILED',ROUTCDE=11
         MVC   SAFRC,=F'20'
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
OPENOK   DS    0H
         MVI   OPENSW,1           SAY WE DID THE OPEN
         TM    DCBDSORG,DCBDSGPS
         JZ    NOT_PS
         TM    DCBRECFM,DCBRECF+DCBRECV
         JNM   BAD_RECFM
         LARL  5,DO_FILE_F        RECFM=F
         ST    5,DO_PUT@
         TM    DCBRECFM,DCBRECF
         JO    CONTXML
         LARL  5,DO_FILE_V        RECFM=V
         ST    5,DO_PUT@
         J     CONTXML
BAD_RECFM DS   0H
         MVC   SAFRC,=F'20'
         LARL  R5,GETOUT
         LHI   R0,L'ERR2+4
         STH   R0,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'ERR2),ERR2
         MVC   OLDNUM,=A(1)
         J     DO_TERM            Tell the user the recfm is bad
NOT_PS   DS    0H
         LHI   R0,L'ERR3+4
         STH   R0,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'ERR3),ERR3
         MVC   SAFRC,=F'20'
         LARL  R5,GETOUT
         J     DO_TERM            Tell the user the DSORG is bad
NODSN    DS    0H
         MVC   OLDNUM,=A(1)
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG11),MSG11
         MVC   SEG1LEN,=AL2(4+L'MSG11)
         MVC   SAFRC,=F'20'
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
DOPATH   DS    0H
*|PATH(...)
         LARL  5,DO_UNIX          OUTPUT TO UNIX FILE
         ST    5,DO_PUT@
         TM    XML3FLG,X'80'      ANY PATH?
         JZ    NOPATH             NO???
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG16),MSG16
         MVC   SEG1LEN,=AL2(4+L'MSG16)
         MVC   SEG2OFF,=AL2(L'MSG16)
         LH    9,XML3LEN         GET LENGTH OF PATH
         AHI   9,5
         STH   9,SEG2LEN
         AHI   9,-6
         JM    NOPATH             NULL?
         L     10,XML3PTR         POINT TO PATH
         CLI   0(10),C'/'         Path must begin at root
         JNE   NOTROOT            But it isn't.
         EX    9,MOVESEG2         MOVE IT IN
         AHI   9,1                RESTORE TRUE LENGTH
         ST    R9,PATHLEN         SAVE IN PARM LIST
         LA    0,PATHLEN          +0
         LA    1,SEG2DATA         +4
         LA    R2,O_FLAG          +8
         LA    3,UNIXMODE         +12
         LA    R4,UNIXFD          +16
         LA    R5,RET_CODE        +20
         LA    R6,RSN_CODE        +24
         STM   R0,R6,TEXTP
         OI    TEXTP+24,X'80'
         LA    R1,TEXTP
         LINK  SF=(E,BPX1OPN)
         LT    R15,UNIXFD
         JM    UNIXFAIL           Open failed
         LOAD  EP=BPX1WRT
         ST    R0,BPX1WRT
         MVC   OLDNUM,=A(2)
         LARL  5,CONTXML          WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
UNIXFAIL DS    0H                 UNIX file failed to open
         LHI   R0,L'ERR4+4
         STH   R0,SEG1LEN
         LHI   R0,8
         STH   R0,SEG2LEN
         STH   R0,SEG3LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG2OFF,=AL2(33)
         MVC   SEG3OFF,=AL2(41)
         MVC   SEG1DATA(L'ERR4),ERR4
         UNPK  PACKDEC1(9),RET_CODE
         TR    PACKDEC1(8),TOHEX-C'0'
         MVC   SEG2DATA(8),PACKDEC1
         UNPK  PACKDEC1(9),RSN_CODE
         TR    PACKDEC1(8),TOHEX-C'0'
         MVC   SEG2DATA(8),PACKDEC1
         MVC   OLDNUM,=A(3)
         LARL  R5,GETOUT
         MVC   SAFRC,=F'20'
         J     DO_TERM            Tell user UNIX open failed.
NOTROOT  DS    0H
         MVC   OLDNUM,=A(1)
         LHI   R0,L'MSG22+4
         STH   R0,SEG1LEN
         MVC   SEG1DATA(L'MSG22),MSG22
         MVC   SAFRC,=F'20'
         LARL  R5,GETOUT          Where to go after message
         J     DO_TERM            Write message to user's terminal
NOPATH   DS    0H
         MVC   OLDNUM,=A(1)
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG17),MSG17
         MVC   SEG1LEN,=AL2(4+L'MSG17)
         MVC   SAFRC,=F'20'
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
DOTERM   DS    0H
         LARL  5,DO_TERM
         ST    5,DO_PUT@
         J     CONTXML
DOSYSOUT DS    0H
         TM    SYSCFLG,X'80'      SYSOUT CLASS SPECIFIED?
         JZ    NOCLASS            ERROR
         LT    9,SYSCPTR          GET POINTER TO CLASS
         JZ    NOCLASS            HUH?
         CLC   SYSCLEN,=AL2(1)    CHECK LENGTH
         JNE   BADCLASS
*
* Issue message to let the user know the sysout class
         MVC   OLDNUM,=A(2)
         LHI   R10,L'MSG21
         STH   R10,SEG2OFF
         AHI   R10,4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG21),MSG21
         MVC   SEG2LEN,=AL2(5)
*
* MOVE THE SYSOUT CLASS
         MVC   SEG2DATA(1),0(R9)  MOVE INTO MESSAGE
         MVC   SYSOUTT+6,0(R9)    MOVE INTO DYNALLOC TEXT UNIT
         JAS   5,DO_TERM
*
* MORE CODE TO ACTUALLY IMPLEMENT THIS
         MVC   S99RBLN,=AL1(L_S99RB)
         MVI   S99VERB,S99VRBAL
         LA    R5,TEXTP
         ST    R5,S99TXTPP
         LA    R5,DYNS99RB
         ST    R5,DYNS99R@
         OI    DYNS99R@,X'80'     SET END-OF-LIST ON
         MVC   FREET(2),=AL2(DALCLOSE) FREE=CLOSE
         XC    FREET+2(2),FREET+2
         MVC   DDNT(2),=AL2(DALRTDDN)
         MVC   DDNT+2(2),=AL2(1)
         MVC   DDNT+4(2),=AL2(8)
         MVC   SYSOUTT(2),=AL2(DALSYSOU)
         MVC   SYSOUTT+2(2),=AL2(1)
         MVC   SYSOUTT+4(2),=AL2(1)
         MVC   FREET(2),=AL2(DALCLOSE) FREE=CLOSE
         XC    FREET+2(2),FREET+2
         L     1,PDLPTR
         LH    5,LIKELEN
         LTR   5,5
         JZ    NOLIKE2
         MVC   LIKET(2),=AL2(DALDCBDS)
         MVC   LIKET+2(2),=AL2(1)
         STH   5,LIKET+4
         AHI   5,-1
         LA    15,LIKET+6
         L     14,LIKEPTR
         EX    5,MOVESTR
NOLIKE2  DS    0H
         L     1,PDLPTR
         LH    5,USNGLEN
         LTR   5,5
         JZ    NOUSING2
         L     1,PDLPTR
         MVC   USINGT(2),=AL2(DALDCBDD)
         MVC   USINGT+2(2),=AL2(1)
         STH   5,USINGT+4
         AHI   5,-1
         LA    15,USINGT+6
         L     14,USNGPTR
         EX    5,MOVESTR
NOUSING2 DS    0H
         DROP  R1
         LA    0,SYSOUTT
         ST    0,TEXTP+0
         LA    0,FREET
         ST    0,TEXTP+4
         LA    0,DDNT
         ST    0,TEXTP+8
         LA    0,USINGT
         ST    0,TEXTP+12
         LA    0,LIKET
         ST    0,TEXTP+16
         LA    0,=AL2(0)          THIS IS REALLY A DO NOTHING
         ST    0,TEXTP+20
         OI    TEXTP+20,X'80'
         LA    R1,DYNS99R@        POINT TO PARM LIST
         DYNALLOC ,               DO DYNAMIC ALLOCATION
         LTR   R15,R15
         JZ    DOOPEN2
         LA    R1,DYNS99R@        POINT TO PARM LIST
         MVC   SAFRC,=F'20'
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DYNERR             WRITE MESSAGE TO USER
NOCLASS  DS    0H
         MVC   OLDNUM,=A(1)         One message segment
         LHI   R10,L'MSG18+4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG18),MSG18
         MVC   SAFRC,=F'20'
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
BADCLASS DS    0H
         MVC   OLDNUM,=A(1)         One message segment
         LHI   R10,L'MSG19+4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG19),MSG19
         MVC   SAFRC,=F'20'
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
*
XMLERROR DS    0H
* MORE THAN ONE OF DDN, DSNAME, OR PATH SPECIFIED
* INSERT MORE CODE
*
*        Error - more than one of DDN, DSNAME, or PATH entered
*
         MVC   OLDNUM,=A(1)         One message segment
         LHI   R10,L'MSG10+4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG10),MSG10
         MVC   SAFRC,=F'20'
         LARL  5,GETOUT           WHERE TO GO BACK TO
         J     DO_TERM            WRITE MESSAGE TO USER
CONTXML  DS    0H
         L     R1,PDLPTR
         USING SEQPDL,R1
* 1 ==> NONXML SPECIFIED OR DEFAULTED
* 2 ==> XML SPECIFIED
         MVC   XMLSWITCH,PDLXML
         CLC   PDLXML,=AL2(2)
         JNE   NOXML
         MVC   OLDNUM,=A(1)         One message segment
         LHI   R10,L'MSG20+4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG20),MSG20
         JAS   5,DO_TERM
         LHI   R10,L'XMLBEGIN+4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'XMLBEGIN),XMLBEGIN
         L     5,DO_PUT@
         BASR  5,5
NOXML    DS    0H
./ DELETE  SEQ1=03320003,SEQ2=03320003
         LHI   R5,L'MSG1+4
./ DELETE  SEQ1=03350003,SEQ2=03350003
         MVC   SEG1DATA(L'MSG1),MSG1
./ DELETE  SEQ1=03390003,SEQ2=03390003
         AHI   R5,4                 Add 4 for header (length/offset)
./ DELETE  SEQ1=03410003,SEQ2=03410003
         LHI   R5,20                Offset of first insert
./ DELETE  SEQ1=03460003,SEQ2=03460003
         AHI   R5,-1                Decrement for execute
./ DELETE  SEQ1=03490003,SEQ2=03490003
         LHI   R5,30                Offset of second insert
./ DELETE  SEQ1=03510003,SEQ2=03520003
         LT    R9,CLSPTR            Get Class pointer from PDL
         JZ    USEUSER              Not specified, default to USER
./ DELETE  SEQ1=03540003,SEQ2=03540003
         AHI   R5,4                 Add 4 for header (len/offset)
         LA    R15,SEG3DATA
         LR    R14,R9
         AHI   5,-1
         EX    5,MOVESTR
./ DELETE  SEQ1=03570003,SEQ2=03570003
         J     SEGNUMS              Proceed
./ DELETE  SEQ1=03600003,SEQ2=03600003
         LHI   R5,8                 4 for "USER" + header
./ DELETE  SEQ1=03640003,SEQ2=03640003
         LHI   R5,6                 Max 2-digit #segments
./ DELETE  SEQ1=03660003,SEQ2=03660003
         LHI   R5,L'MSG1            Offset of third insert (eol)
./ DELETE  SEQ1=03770003,SEQ2=03790003
         CLI   XMLSWITCH+1,2      XML FORMAT?
         JNE   NOTXML1
         LHI   0,18
         STH   0,SEG2OFF
         LHI   0,35
         STH   0,SEG3OFF
         LHI   0,53
         STH   0,SEG4OFF
         LHI   5,L'XML1+4
         STH   5,SEG1LEN
         MVC   SEG1DATA(L'XML1),XML1
NOTXML1  DS    0H
         L     5,DO_PUT@
         BASR  5,5
./ DELETE  SEQ1=04120003,SEQ2=04120003
         JAS   R14,SEGMSG            Issue segment message
./ DELETE  SEQ1=04150003,SEQ2=04190003
         LLH   R9,ADMN_PROF_FIELDTYPE  Get type of field
         C     R9,=A(ADMN_PROF_RPTHDR) Is it a repeat field header?
         JE    REPEAT                Yes, repeat field
./ DELETE  SEQ1=04210003,SEQ2=04220003
         JAS   R14,FLDMSG            Display field name and value
         J     NEXTFLD               Get next field
*
./ DELETE  SEQ1=04240003,SEQ2=04240003
         JAS   R15,DOREPEAT          Go process repeat field. R5 will  *
./ DELETE  SEQ1=04260003,SEQ2=04260003
         J     NEXTFLD2              Continue with main fields
./ DELETE  SEQ1=04340003,SEQ2=04350003
         JCT   R4,DOFIELDS           Decrement number of fields
./ DELETE  SEQ1=04430003,SEQ2=04440003
         CLI   XMLSWITCH+1,2      XML OUTPUT?
         JNE   NOXML2
         MVC   OLDNUM,=A(2)
         XC    SEG1OFF,SEG1OFF
         LHI   R0,L'XMLEND+4
         STH   R0,SEG1LEN
         MVC   SEG1DATA(L'XMLEND),XMLEND
         MVC   SEG2LEN(2+2+8),RACSEGSV
         LHI   R0,3
         STH   R0,SEG2OFF
         LR    R14,R5             SAVE
         L     R5,DO_PUT@
         BASR  R5,R5
         LR    R5,R14             RESTORE
NOXML2   DS    0H
         JCT   R2,DOSEGS             Decrement number of segments
         J     FREEOUT               Done with segments, finish up
         CLI   XMLSWITCH+1,2      XML?
         JNE   FREEOUT2           No
         MVC   OLDNUM,=A(1)
         XC    SEG1OFF,SEG1OFF
         LHI   0,L'XML1B+4
         STH   0,SEG1LEN
         MVC   SEG1DATA(L'XML1B),XML1B
         L     R5,DO_PUT@
         BASR  R5,R5
FREEOUT2 DS    0H
         L     R1,OUTMSG
./ DELETE  SEQ1=04510003,SEQ2=04530003
         STORAGE RELEASE,                                              X
               LENGTH=(0),                                             X
               ADDR=(1),                                               X
               SP=127
         LT    R2,UNIXFD
         JM    NOUNIX
         LA    R2,UNIXFD          +0
         LA    R3,RET_VAL         +4
         LA    R4,RET_CODE        +8
         LA    R5,RSN_CODE        +12
         STM   R2,R5,REGSAVE      +16
         OI    REGSAVE+16,X'80'
         LA    R1,REGSAVE         POINT TO PARM LIST
         LINK  SF=(E,BPX1CLO)
NOUNIX   DS    0H
         CLI   OPENSW,1
         JNE   NOCLOSE
         MVC   OPEN(LOPEN),OPENMFL
         LA    R1,OPEN
         CLOSE (DCBOUT),MF=(E,(1)),MODE=31
NOCLOSE  DS    0H
./ DELETE  SEQ1=04640003,SEQ2=04650003
         L     R5,SAFRC
         STORAGE RELEASE,                                              X
               LENGTH=(0),                                             X
               ADDR=(1)
         LR    R15,R5
./ DELETE  SEQ1=04670003,SEQ2=04670003
./ DELETE  SEQ1=04750003,SEQ2=04750003
*                  R15 = return address                               *
./ DELETE  SEQ1=04870003,SEQ2=04870003
         ST    R5,SAVEFD2
         ST    R15,SAVEFD3
         JAS   R14,RPTMSG            Go print header field
./ DELETE  SEQ1=04960003,SEQ2=04960003
         JAS   R14,FLDMSG            Print subfield name and value
./ DELETE  SEQ1=05000003,SEQ2=05040003
         JCT   R7,RPTSFLD            Loop if subfields remaining
         CLI   XMLSWITCH+1,2      XML?
         JE    NOSEP              No separator needed
         JAS   R14,SEPMSG            Print separator
NOSEP    DS    0H
         JCT   R6,RPTOCC             Loop if occurrences remaining
         CLI   XMLSWITCH+1,2
         JNE   NOTXMLA
         L     R5,SAVEFD2
         USING ADMN_PROF_FIELDDESC,R5 Basing for subfield descriptor
         MVC   SEG2DATA(8),ADMN_PROF_FIELDNAME  Move in field name
         DROP  R5
         MVC   SEG1DATA(L'XMLEND),XMLEND
         LHI   0,L'XMLEND+4
         STH   0,SEG1LEN
         LHI   0,3
         STH   0,SEG2OFF
         XC    SEG1OFF,SEG1OFF
         LA    1,SEG2DATA+7
         LHI   6,8
SQZA     DS    0H
         CLI   0(R1),C' '
         JNE   ESQZA
         BCTR  R1,0
         JCT   R6,SQZA
ESQZA    DS    0H
         AHI   R6,4
         STH   R6,SEG2LEN
         MVC   OLDNUM,=A(2)
         L     R5,DO_PUT@
         BASR  R5,R5
NOTXMLA  DS    0H
         LR    R5,R8                 All done. Set R5 to next FD addr
         L     R15,SAVEFD3
         BR    R15                   Return to caller
*        DROP  R8
./ DELETE  SEQ1=05230003,SEQ2=05230003
         LHI   R10,L'MSG2+4
./ DELETE  SEQ1=05260003,SEQ2=05270003
         MVC   SEG1DATA(L'MSG2),MSG2
         LHI   R10,8+4              Get segment name length + header
./ DELETE  SEQ1=05290003,SEQ2=05290003
         LHI   R10,10               Offset of 1st insert
./ DELETE  SEQ1=05320003,SEQ2=05320003
         MVC   RACSEGSV+2+2(8),SEG2DATA
         LHI   R2,6                 Max 2-digit number of fields
./ DELETE  SEQ1=05340003,SEQ2=05340003
         LHI   R2,L'MSG2            Insert position of insert (eol)
./ DELETE  SEQ1=05410003,SEQ2=05470003
         CLI   XMLSWITCH+1,2      XML?
         JNE   NOTXML2            NO
         MVC   SEG1DATA(L'XML2),XML2
         LHI   0,L'XML2+4
         STH   0,SEG1LEN
         LHI   0,2
         STH   0,SEG2OFF
*
* SQUEEZE OUT TRAILING BLANKS
         LA    R1,SEG2DATA
         LH    R2,SEG2LEN
         AHI   R2,-4
         AR    R1,R2
         AHI   R1,-1
SQZ1     DS    0H
         CLI   0(R1),C' '
         JNE   ESQZ1
         BCTR  R1,0               BACK UP ONE BYTE
         BRCT  R2,SQZ1
ESQZ1    DS    0H
         AHI   R2,4
         STH   R2,SEG2LEN
         LHI   0,11
         STH   0,SEG3OFF
         MVC   RACSEGSV(2+2+8),SEG2LEN
NOTXML2  DS    0H
         L     5,DO_PUT@
         BASR  5,5
*        JAS   5,DO_TERM
./ DELETE  SEQ1=05500003,SEQ2=05500003
./ DELETE  SEQ1=05690003,SEQ2=05690003
         LHI   R10,L'MSG3+4
./ DELETE  SEQ1=05720003,SEQ2=05730003
         MVC   SEG1DATA(L'MSG3),MSG3
         LHI   R10,8+4              Get field name length + header
./ DELETE  SEQ1=05750003,SEQ2=05750003
         LHI   R10,16               Offset of 1st insert
./ DELETE  SEQ1=05800003,SEQ2=05800003
         LHI   R2,6                 Max 2-digit #subfields
./ DELETE  SEQ1=05820003,SEQ2=05820003
         LHI   R2,27                Offset of 2nd insert
./ DELETE  SEQ1=05910003,SEQ2=05910003
         LHI   R2,8                 Max 4-digit #occurrences
./ DELETE  SEQ1=05930003,SEQ2=05930003
         LHI   R2,L'MSG3            Offset of 3rd insert (end of line)
./ DELETE  SEQ1=06030003,SEQ2=06090003
         CLI   XMLSWITCH+1,2      XML?
         JNE   NOTXML3
         MVC   SEG1DATA(L'XML3),XML3
         LHI   0,L'XML3+4
         STH   0,SEG1LEN
         LHI   0,2
         STH   0,SEG2OFF
         LA    1,SEG2DATA
         LH    2,SEG2LEN
         AHI   2,-4
         AR    R1,R2
         AHI   R1,-1
SQZ3     DS    0H
         CLI   0(R1),C' '
         JNE   ESQZ3
         BCTR  R1,0
         JCT   R2,SQZ3
ESQZ3    DS    0H
         AHI   R2,4
         STH   R2,SEG2LEN
         LHI   0,14
         STH   0,SEG3OFF
         LHI   0,39
         STH   0,SEG4OFF
NOTXML3  DS    0H
         L     5,DO_PUT@
         BASR  5,5
./ DELETE  SEQ1=06120003,SEQ2=06120003
./ DELETE  SEQ1=06310003,SEQ2=06360003
         LLH   R9,ADMN_PROF_FIELDTYPE
         N     R9,=A(ADMN_PROF_REPEAT)
         JZ    NOTRPT               Nope
         LHI   R10,L'MSG4RPT+4      Use extra indentation for repeat
./ DELETE  SEQ1=06380003,SEQ2=06380003
         MVC   SEG1DATA(L'MSG4RPT),MSG4RPT
./ DELETE  SEQ1=06400003,SEQ2=06400003
         LHI   R10,L'MSG4RPT        Offset of 3rd insert (end of line)
./ DELETE  SEQ1=06420003,SEQ2=06420003
         J     NXTMSEG
./ DELETE  SEQ1=06440003,SEQ2=06440003
         LHI   R10,L'MSG4+4
./ DELETE  SEQ1=06460003,SEQ2=06460003
         MVC   SEG1DATA(L'MSG4),MSG4
./ DELETE  SEQ1=06480003,SEQ2=06480003
         LHI   R10,L'MSG4           Offset of 3rd insert (end of line)
./ DELETE  SEQ1=06510003,SEQ2=06510003
         LHI   R10,8+4              Get field name length + header
./ DELETE  SEQ1=06580003,SEQ2=06580003
         JZ    NOTBOOL
./ DELETE  SEQ1=06630003,SEQ2=06640003
         JZ    NOTTRUE
         LHI   R10,4+4              Length("TRUE") + header
./ DELETE  SEQ1=06660003,SEQ2=06670003
         MVC   SEG3DATA(4),=C'TRUE'
         J     DOFPUT
./ DELETE  SEQ1=06690003,SEQ2=06690003
         LHI   R10,5+4              Length("FALSE") + header
./ DELETE  SEQ1=06710003,SEQ2=06720003
         MVC   SEG3DATA(5),=C'FALSE'
         J     DOFPUT
./ DELETE  SEQ1=06760003,SEQ2=06770003
         JNH   NOPROB                     No
         LHI   R10,L'SEG3DATA             Lazy again, just truncate
./ DELETE  SEQ1=06800003,SEQ2=06800003
         AHI   R10,4                      Add 4 for header
./ DELETE  SEQ1=06860003,SEQ2=06860003
         AHI   R10,-1               Decrement length for move
./ DELETE  SEQ1=06890003,SEQ2=06950003
         CLI   XMLSWITCH+1,2      XML OUTPUT?
         JNE   NOTXML4
         LHI   0,L'XML4+4
         STH   0,SEG1LEN
         MVC   SEG1DATA(L'XML4),XML4
         LHI   0,2
         STH   0,SEG2OFF
         LHI   0,3
         STH   0,SEG3OFF
         LHI   0,5
         STH   0,SEG4OFF
         LA    R1,SEG2DATA
         LH    R2,SEG2LEN
         AHI   R2,-4
         AR    R1,R2
         AHI   R1,-1
SQZ4     DS    0H
         CLI   0(R1),C' '
         JNE   ESQZ4
         BCTR  R1,0
         JCT   R2,SQZ4
ESQZ4    DS    0H
         AHI   R2,4
         STH   R2,SEG2LEN
         MVC   SEG4LEN,SEG2LEN
         MVC   SEG4DATA,SEG2DATA
         MVC   OLDNUM,=A(4)
NOTXML4  DS    0H
         L     5,DO_PUT@
         BASR  5,5
./ DELETE  SEQ1=06980003,SEQ2=06980003
./ DELETE  SEQ1=07150003,SEQ2=07150003
         LHI   R10,L'MSG5+4
./ DELETE  SEQ1=07180003,SEQ2=07180003
         MVC   SEG1DATA(L'MSG5),MSG5
         L     5,DO_PUT@
         BASR  5,5
         LM    14,12,REGSAVE        Restore caller's regs
         BR    R14                  Return to caller
         EJECT
*
***********************************************************************
*
*
* Routine called by parse to validate a UNIX path
*
*
***********************************************************************
VALDPATH DS    0H
         STM   14,12,12(13)
         LM    5,7,0(1)           LOAD PARAMETERS
* R5 POINTS TO THE PDE
* R6 IS THE ADDRESS OF A WORK AREA
* R7 MAY BE USED TO POINT TO A SECOND LEVEL MESSAGE
         L     8,0(,5)            POINT TO OPERAND
         LH    10,4(,5)           LENGTH OF OPERAND
         AHI   10,-1              DEC
         SLR   15,15
         JM    PATHERR1
VALRET   DS    0H
         l     14,12(,13)
         LM    0,12,20(13)
         BSM   0,14               RETURN TO PARSE
PATHERR1 DS    0H
         LHI   15,4
         J     VALRET
         EJECT
*
***********************************************************************
*
*
* Routine called by parse to validate a DSN
*
*
***********************************************************************
VALIDSN  DS    0H
         STM   14,12,12(13)
         LM    5,7,0(1)           LOAD PARAMETERS
* R5 POINTS TO THE PDE
* R6 IS THE ADDRESS OF A WORK AREA
* R7 MAY BE USED TO POINT TO A SECOND LEVEL MESSAGE
         SLR   15,15
         J     VALRET             RETURN TO PARSE
         EJECT
RC24     DS    0H
         MVC   SAFRC,=F'24'
         J     GETOUT
DO_TERM DS     0H
         STM   R0,R15,PUTSAVE
         DROP  R1
         LA    R4,OLDNUM
./ DELETE  SEQ1=07260003,SEQ2=07270003
         LTR   R15,R15
         JNZ   *+2
         LM    R0,R15,PUTSAVE
         BR    5
DO_FILE_F DS   0H                 OUTPUT USING DCB
         STM   R0,R15,PUTSAVE
         L     R1,CPPLPTR           Get address of CPPL
         USING CPPL,R1              And establish addressability
         L     R2,CPPLUPT
         L     R3,CPPLECT
./ DELETE  SEQ1=07290003,SEQ2=07290003
         XC    PUTECB,PUTECB        Clear ECB
         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *
               OUTPUT=(OLDNUM,FORMAT,SINGLE,INFOR),MF=(E,PUTIOPL)
         LTR   R15,R15            Putline OK?
         JNZ   RC24               No, exit with RC=24
         L     2,PUTSEQ+8         Get address of record
         LH    3,0(,2)            Get length of record
         AHI   3,-4               Remove length of LLBB prefix
         CH    3,DCBLRECL         Compare record length
         JNH   DO_F_PUT
*
* DATASET LRECL TOO SMALL, INFORM USER
BAD_RECLEN DS  0H
         CVD   3,PACKDEC1
*        UNPK  SEG2DATA(2*L'PACKDEC1-1),PACKDEC1
*        OI    SEG2DATA+2*L'PACKDEC1-2,C'0'
         MVC   EDMKFLD,EDMKINIT
         LA    R1,EDMKFLD
         EDMK  EDMKFLD,PACKDEC1
         LR    R14,R1
         LA    R15,SEG2DATA
         LA    R9,EDMKFLD+L'EDMKFLD-1
         SLR   R9,R1
         EX    9,MOVESTR
         AHI   R9,5
         STH   R9,SEG2LEN
         LHI   R0,L'ERR5+4
         STH   R0,SEG1LEN
*        LHI   R0,2*L'PACKDEC1-1+4
*        STH   R0,SEG2LEN
*        STH   R0,SEG3LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG2OFF,=AL2(46)
         MVC   SEG3OFF,=AL2(L'ERR5)
         MVC   SEG1DATA(L'ERR5),ERR5
         LH    R0,DCBLRECL
         CVD   R0,PACKDEC1
         MVC   EDMKFLD,EDMKINIT
         LA    R1,EDMKFLD
         EDMK  EDMKFLD,PACKDEC1
         LR    R14,R1
         LA    R15,SEG3DATA
         LA    R9,EDMKFLD+L'EDMKFLD-1
         SLR   R9,R1
         EX    9,MOVESTR
         AHI   R9,5
         STH   R9,SEG3LEN
*        UNPK  SEG3DATA(2*L'PACKDEC1-1),PACKDEC1
*        OI    SEG3DATA+2*L'PACKDEC1-2,C'0'
         MVC   OLDNUM,=A(3)
         MVC   SAFRC,=F'20'
         LARL  R5,GETOUT
         J     DO_TERM            Tell terminal user record too long
DO_F_PUT DS    0H
         PUT   DCBOUT             Get buffer
         LH    3,DCBLRECL
         AHI   3,-2
         MVI   0(1),C' '
         LR    14,1
         LA    15,1(,1)
         EX    3,MOVESTR          BLANK OUT I/O BUFFER
         LH    3,0(,2)            Length of record to write
         AHI   3,-5               Actual lrecl-1
         LA    14,4(,2)           First character of actual data
         LR    15,1               Buffer address
         EX    3,MOVESTR          Move data to buffer
         LR    R1,R2              Get buffer address
         LH    R0,0(,R1)          Get length
         STORAGE RELEASE,                                              X
               ADDR=(1),                                               X
               LENGTH=(0),                                             X
               SP=1
         LM    R0,R15,PUTSAVE
         BR    5
DO_FILE_V DS   0H                 OUTPUT USING DCB
         STM   R0,R15,PUTSAVE
         L     R1,CPPLPTR           Get address of CPPL
         USING CPPL,R1              And establish addressability
         L     R2,CPPLUPT
         L     R3,CPPLECT
         DROP  R1
         XC    PUTECB,PUTECB        Clear ECB
         LA    R4,OLDNUM
         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *
               OUTPUT=(OLDNUM,FORMAT,SINGLE,INFOR),MF=(E,PUTIOPL)
         LTR   R15,R15            Putline OK?
         JNZ   RC24               No, exit with RC=24
         L     14,PUTSEQ+8        POINT TO RECORD FROM PUTLINE
         LH    3,0(,14)           GET ITS LENGTH
         CH    9,DCBLRECL         Will it fit?
         JH    BAD_RECLEN         Yes
         PUT   DCBOUT
         L     14,PUTSEQ+8        POINT TO RECORD FROM PUTLINE
         LR    R15,R1             BUFFER RETURNED BY PUT
         AHI   9,-1               ADJ LENGTH FOR EX
         EX    9,MOVESTR          MOVE THE RECORD TO THE BUFFER
         L     R1,PUTSEQ+8        Get buffer address
         LH    R0,0(,R1)          Get length
         STORAGE RELEASE,                                              X
               ADDR=(1),                                               X
               LENGTH=(0),                                             X
               SP=1
         LM    R0,R15,PUTSAVE
         BR    5
DO_UNIX  DS    0H                 OUTPUT USING UNIX
         STM   R0,R15,PUTSAVE
         L     R1,CPPLPTR           Get address of CPPL
         USING CPPL,R1              And establish addressability
         L     R2,CPPLUPT
         L     R3,CPPLECT
         DROP  R1
         XC    PUTECB,PUTECB        Clear ECB
         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *
               OUTPUT=(OLDNUM,FORMAT,SINGLE,INFOR),MF=(E,PUTIOPL)
         LTR   R15,R15            Putline OK?
         JNZ   RC24               No, exit with RC=24
         L     14,PUTSEQ+8        POINT TO RECORD FROM PUTLINE
         LH    9,0(,14)           GET ITS LENGTH
*        STH   9,SEG1LEN
*        XC    SEG1OFF,SEG1OFF
         AHI   9,-5               Actual length of data -1
         LA    R14,4(,R14)        POINT TO DATA
         LA    R15,SEG1DATA       SOMEWHERE TO PUT IT
         EX    R9,MOVESTR         MOVE IT TO BUFFER
         LA    R14,1(R9,R15)
         MVI   0(R14),X'15'       EBCDIC NEWLINE
         AHI   R9,2               Length of record plus the NL
*        MVC   OLDNUM,=A(1)
*        PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,
*              OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)
         ST    R9,SAVEDLEN
         L     R15,BPX1WRT
         L     R2,UNIXFD
         LA    R3,SEG1DATA
         L     R4,SAVEDLEN
         LA    R2,SEG1DATA
         ST    R2,TEXTP
         CALL  (15),(UNIXFD,                                           X
               TEXTP,                                                  X
               =F'0',                                                  X
               SAVEDLEN,                                               X
               RET_VAL,                                                X
               RET_CODE,                                               X
               RSN_CODE),VL,                                           X
               MF=(E,TEXTP+4)
         LM    R0,R1,RET_CODE
         LT    R9,RET_VAL
         JM    WRITFAIL           WRITE FAILED
         C     R9,SAVEDLEN        WROTE ALL THE BYTES?
         JNE   WRT2FAIL           FAILED AGAIN
         L     R1,PUTSEQ+8        Get buffer address
         LH    R0,0(,R1)          Get length
         STORAGE RELEASE,                                              X
               ADDR=(1),                                               X
               LENGTH=(0),                                             X
               SP=1
         LM    R0,R15,PUTSAVE
         BR    5
WRITFAIL DS    0H
         MVC   SAFRC,=F'20'
         UNPK  PACKDEC1(9),RET_CODE(5)
         TR    PACKDEC1(8),TOHEX-C'0'
         UNPK  PACKDEC2(9),RSN_CODE(5)
         TR    PACKDEC2(8),TOHEX-C'0'
         LHI   R0,L'MSG23+4
         STH   R0,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG23),MSG23
         LHI   R0,8
         STH   R0,SEG2LEN
         STH   R0,SEG3LEN
         LHI   R0,37
         STH   R0,SEG2OFF
         LHI   R0,45
         STH   R0,SEG3OFF
         MVC   SEG2DATA(8),PACKDEC1
         MVC   SEG3DATA(8),PACKDEC2
         MVC   OLDNUM,=A(3)
         LARL  R5,GETOUT
         J     DO_TERM
WRT2FAIL DS    0H
         MVC   SAFRC,=F'20'
         LHI   R0,L'MSG24
         STH   R0,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA(L'MSG24),MSG24
         MVC   SEG2LEN,=AL2(8)
         MVC   SEG3LEN,=AL2(8)
         MVC   SEG2OFF,=AL2(32)
         MVC   SEG3OFF,=AL2(43)
         CVD   R9,PACKDEC1
         OI    PACKDEC1+7,C'0'
         MVC   SEG2DATA(8),PACKDEC1
         L     R9,SAVEDLEN
         CVD   R9,PACKDEC1
         OI    PACKDEC1+7,C'0'
         MVC   SEG3DATA(8),PACKDEC1
         LARL  R5,GETOUT
         J     DO_TERM
*        J     GETOUT
BR5      DS    0H                 NO OUTPUT AT ALL?
         WTO   'BR5',ROUTCDE=11
         BR    5
DYNERR   DS    0H                      SAVE RETCODE FOR DAIRFAIL
         USING DFDSECTD,DRFLPARM       SET ADDRESSIBLITY TO PARM LIST
         ST    R15,DRFLR15             SAVE RETCODE FOR DAIRFAIL
         ST    R1,DFS99RBP
         LA    R1,DRFLPARM             LOAD DAIRFAIL PARM LIST ADDRESS
         XC    DRFLPARM(DFLEN),DRFLPARM CLEAR AREA FIRST
         LA    R15,DRFLR15             GET ADDRESS OF SAVED REG 15
         ST    R15,DFRCP               SAVE IN DAIRFAIL PARM LIST
         LA    R15,FULL0               GET ADDRESS OF OF DUMMY F02
         ST    R15,DFJEFF02            SAVE IN DAIRFAIL PARM LIST
         LA    R15,DRFLID              GET ADDRESS OF CALLER'S FLAGS
         ST    R15,DFIDP               SAVE IN DAIRFAIL PARM LIST
         LINK  SF=(E,LINKDRFL)         LINK TO DAIRFAIL SERVICE ROUTINE
         BR    5
KWOUTPUT IKJKEYWD DEFAULT='TERMINAL'
         IKJNAME 'DDNAME',SUBFLD=DDN,                                  X
               ALIAS=('FI','FILE')
         IKJNAME 'DSNAME',SUBFLD=DSNAME,                               X
               ALIAS=('DATASET','DA')
         IKJNAME 'PATH',SUBFLD=PATH ALIAS=('PATH')
         IKJNAME 'TERMINAL'
         IKJNAME 'SYSOUT',SUBFLD=OUTCLASS
KWALLOC  IKJKEYWD
         IKJNAME 'USING',SUBFLD=USING1
         IKJNAME 'LIKE',SUBFLD=LIKE1
KWXML    IKJKEYWD DEFAULT='NONXML'
         IKJNAME  'NONXML'
         IKJNAME  'XML'
DDN      IKJSUBF
XMLDD    IKJIDENT 'DDN',UPPERCASE,MAXLNTH=8,FIRST=ALPHA,               X
               OTHER=ALPHANUM,                                         X
               HELP=('DD name to use for XML output')
DSNAME   IKJSUBF
XMLDS    IKJPOSIT DSNAME,USID,                                         X
               HELP=('Dataset Name to be used for XML output')
PATH     IKJSUBF
XMLPAT   IKJIDENT 'PATH',ASIS,MAXLNTH=255,                             X
               FIRST=ANY,OTHER=ANY,                                    X
               VALIDCK=VALDPATH,                                       X
               HELP=('UNIX path and file name')
OUTCLASS IKJSUBF
OUTCLAS  IKJIDENT 'SYSOUT',UPPERCASE,MAXLNTH=1,                        X
               FIRST=NONATNUM,                                         X
               HELP=('SYSOUT class (A..Z,0..9)')
USING1   IKJSUBF
USING    IKJIDENT 'USING',UPPERCASE,MAXLNTH=8,                         X
               FIRST=ALPHA,OTHER=ALPHANUM,                             X
               HELP=('ATTR name for dataset allocation considerations')
LIKE1    IKJSUBF
LIKE     IKJPOSIT DSNAME,USID,                                         X
               HELP=('Dataset Name to be used as a model for allocatingX
                a new output dataset.')
./ DELETE  SEQ1=07570003,SEQ2=07570003
DATA     DS    0D
OUTTBL   DC    A(PDEXML1-PDEXML1)
         DC    A(PDEXML2-PDEXML1)
         DC    A(PDEXML3-PDEXML1)
         DC    A(0)               NO PDE FOR TERMINAL
         DC    A(PDESYSC-PDEXML1)
         DC    A(0)               NO PDE FOR XML/NONXML
LXMLTBL  EQU   *-OUTTBL
MAXTBL   DC    A(LXMLTBL)
OUTP     DC    A(DODDN),A(DODSN),A(DOPATH)
         DC    A(DOTERM),A(DOSYSOUT)
MOVESEG2 MVC   SEG2DATA+0(0),0(10)
MOVESTR  MVC   0(*-*,R15),0(R14)
XMLBEGIN DC    C' <?xml version="1.0"?>'
XML1     DC    C' <RACSEQ><PROFILE></PROFILE><CLASS></CLASS><SEGMENTS><X
               /SEGMENTS>' 18/35/53
XML1B    DC    C' </RACSEQ>'
XML2     DC    C' <><FIELDS></FIELDS>' 2/11
XML3     DC    C' <><SUBFIELDS></SUBFIELDS><OCCURRENCES></OCCURRENCES>'
*                  2           14 39
XMLEND   DC    C' </>' 3
XML4     DC    C' <></>' 2/3/5
MSG10    DC    C' Error! At most one of DDN, DSNAME, and PATH may be spX
                ecified'
MSG11    DC    C' Error! No data set name specified!'
MSG12    DC    C' Output to DSN:'
MSG14    DC    C' Output to DD:'
MSG15    DC    C' Error! No DD name specified!'
MSG16    DC    C' Output to PATH:'
MSG17    DC    C' Error! No path name specified!'
MSG18    DC    C' Error! SYSOUT has no operand.'
MSG19    DC    C' Error! SYSOUT is not exactly 1 character.'
MSG20    DC    C' Output will be in XML format.'
MSG21    DC    C' Output will be directed to SYSOUT class '
MSG22    DC    C' PATH must begin at the root. It may not be relative.'
MSG23    DC    C' UNIX write failed. RET_VAL=-1, RC=0x ,RSN=0x'
MSG24    DC    C' UNIX write incomplete. Desired= , Written='
ERR1     DC    C' Logic error. No logic to process a specified option.'
ERR2     DC    C' RECFM is unrecognized or invalid. Aborting.'
ERR3     DC    C' DSORG unusable. Must be PS. Aborting'
ERR4     DC    C' Open for UNIX file failed. RC=0x ,RSN=0x'
ERR5     DC    C' Error. LRECL too small for record. Record is  bytes  x
               long. File LRECL is '
EDMKINIT DC    (2*L'PACKDEC1-1)X'20'
TOHEX    DC    C'0123456789ABCDEF'
         DS    0D
DCBINIT  DCB   MACRF=(PL),                                             X
               DSORG=PS
LDCB     EQU   *-DCBINIT
OPENMFL  OPEN  (DCBINIT,(OUTPUT)),MF=L,MODE=31
LOPEN    EQU   *-OPENMFL
         DS    0D
LDATA    EQU   *-DATA
FULL0    DC    F'0'                    ADDRESS OF NULL IKJEFF02 ROUTINE
DRFLR15  DC    A(0)
DRFLPARM DC    XL(DFLEN)'00'
DRFLID   DC    AL1(DFWTP),AL1(DFSVC99)
BPX1WRT  DS    F                  DYNAMIC ADDRESS OF BPX1WRT
LINKDRFL LINK  EP=IKJEFF18,SF=L        LINK TO DAIRFAIL SERVICE ROUTINE
BPX1CLO  LINK  EP=BPX1CLO,SF=L
BPX1OPN  LINK  EP=BPX1OPN,SF=L
*
* Mapped by BPXYMODE & BPXYFTYP
UNIXMODE DC    AL1(0),AL1(0),AL1(S_IRUSR)
         DC    AL1(S_IRWXU2+S_IRGRP)
*
* Mapped by BPXYOPNF
O_FLAG DC      AL1(0),AL1(0),AL1(0)
         DC    AL1(O_CREAT+O_TRUNC+O_WRONLY)
*
* THEN FOLLOWING CODE IS COPIED INTO THE 24-BIT DYNAMIC
* AREA SO THAT OPEN, IN 24 BIT MODE, CAN USE IT
* IT SIMPLY DOES A BRANCH-AND-SET-MODE TO THE REAL
* EXIT AT OPEN31.
OPEN24I  DS    0D
         LA    1,0(,1)            CLEAR HOB OF R1 SO IT WON'T HURT
*                                 ANYTHING IN 31 BIT MODE
         L     15,AOPEN31-OPEN24I(,15)
         BSM   14,15              INVOKE 31 BIT EXIT
AOPEN31  DC    A(X'80000000'+OPEN31)
LOPEN24  EQU   *-OPEN24I
*
* END OF COPIED CODE
*
* DCB OPEN EXIT R1 POINTS TO DCB UPON ENTRY
OPEN31   DS    0H
         CLI   DCBRECFM-IHADCB(R1),0
         JNE   GOTRECFM
         MVI   DCBRECFM-IHADCB(R1),DCBRECV+DCBRECBR
GOTRECFM DS    0H
         SLR   R0,R0
         CH    R0,DCBLRECL-IHADCB(R1)
         JNZ   GOTLRECL
         LHI   3,125
         STH   3,DCBLRECL-IHADCB(R1)
GOTLRECL DS    0H
         CH    R0,DCBBLKSI-IHADCB(R1)
         JNZ   GOTBLKSI
         LHI   R3,4096
         STH   R3,DCBBLKSI-IHADCB(R1)
GOTBLKSI DS    0H
         TM    DCBRECFM-IHADCB(R1),DCBRECU
         JO    RECFMU
         TM    DCBRECFM-IHADCB(R1),DCBRECV
         JO    RECFMV
         TM    DCBRECFM-IHADCB(R1),DCBRECF
         JO    RECFMF
         J     BSM014
RECFMU   DS    0H
         MVC   DCBLRECL-IHADCB(1),DCBBLKSI-IHADCB(R1)
         J     BSM014
RECFMV   DS    0H
         LH    R3,DCBBLKSI
         AHI   R3,-4
         CH    R3,DCBLRECL
         JNL   BSM014
         STH   R3,DCBLRECL
         J     BSM014
RECFMF   DS    0H
         LH    R3,DCBBLKSI
         SLR   R2,R2
         LH    R0,DCBLRECL
         DR    R2,R0
         LTR   R2,R2
         JZ    BSM014
         MH    R3,DCBLRECL-IHADCB(R1)
         STH   R3,DCBBLKSI-IHADCB(R1)
BSM014   DS    0H
         BSM   0,14               RETURN TO OPEN
UNIXFD   DS    F                  UNIX File Descriptor
PATHLEN  DS    F
RET_VAL  DS    F                  UNIX return value
RET_CODE DS    F                  UNIX return code
RSN_CODE DS    F                  UNIX reason code
SAVEFD2  DS    F                   Temp variable for @ field descriptor
SAVEFD3  DS    F                   Temp variable for @ field descriptor
PUTSAVE  DS    16F
EDMKFLD  DS    CL(2*L'PACKDEC1-1)' '
DYNEFF@  DS    F
DYNEFF   DS    (L_EFF)C
DO_PUT@  DS    A
DYNS99R@ DS    A
DYNS99RB DS    (L_S99RB)C' '
         DS    0F
TEXTP    DS    A  +0              ADDRESS OF DSN TEXT UNIT
         DS    A   4              ADDRESS OF RETURN DDN TEXT UNIT
         DS    A   8              ADDRESS OF DISP1
         DS    A   12             ADDRESS OF DISP2
         DS    A   16             ADDRESS OF DISP3
         DS    A   20             FREE=CLOSE
         DS    A   24             ADDRESS OF MEMBER
         DS    A   28             ADDRESS OF LIKET
         DS    A   32             ADDRESS OF USING
         DS    A   36             ADDRESS OF NOTHING
DSNT     DS    H,H,H,CL44         KEY=DALDSNAM
MEMBERT  DS    H,H,H,CL8          KEY=DALMEMBR
DISP1T   DS    3H,X               KEY=DALSTATS
DISP2T   DS    3H,X               KEY=DALNDISP
DISP3T   DS    3H,X               KEY=DALCDISP
FREET    DS    2H                 KEY=DALCLOSE
LIKET    DS    3H,CL44            KEY=DALDCBDS
USINGT   DS    3H,CL8             KEY=DALDCBDD
DDNT     DS    3H,CL8             KEY=DALRTDDN
SYSOUTT  DS    3H,C               KEY=DALSYSOU
RACSEGSV DS    H,H,CL8            len, offset, data
         DS    0F
DCBOUT    DS    (LDCB)C' '
         DS    0F
OPEN     DS    (LOPEN)C' '
XMLSWITCH DS    H
OPENSW   DS    X
         DS    0D
OPEN24   DS    (LOPEN24)XL1
EXLST    DS    F
         DS    0D
PDLOUTPUT DS   H
PDLALLOC DS    H
PDLXML   DS    H
*
* PDE FOR THE CLASS()
*
* PDE FOR PROFILE()
*
* PDE FOR DDN()
PDEXML1  DS    0CL8
XML1PTR  DS    A
XML1LEN  DS    H
XML1FLG  DS    X,X
*
* PDE FOR DSNAME()
PDEXML2  DS    0CL24
XML2PTR  DS    A
XML2LEN  DS    H
XML2FLG  DS    X,X
XML2MEM  DS    A
XML2LN2  DS    H
XML2FLG2 DS    X,X
XML2PSWD DS    A
XML2LN3  DS    H
XML2FLG3 DS    X,X
*
* PDE FOR PATH()
PDEXML3  DS    0CL8
XML3PTR  DS    A
XML3LEN  DS    H
XML3FLG  DS    X,X
*
* PDE FOR TERMINAL (AIN'T ONE!)
*DETERM  DS    0CL8
*ERMPTR  DS    A
*ERMLEN  DS    H
*ERMFLG  DS    X,X
*
* PDE FOR SYSOUT()
PDESYSC  DS    0CL8
SYSCPTR  DS    A
SYSCLEN  DS    H
SYSCFLG  DS    X
         DS    X
*
* PDE FOR USING()
PDEUSNG  DS    0CL8
USNGPTR  DS    A
USNGLEN  DS    H
USNGFLG  DS    X,X
*
* PDE FOR LIKE()
PDELIKE  DS    0CL24
LIKEPTR  DS    A
LIKELEN  DS    H
LIKEFLG  DS    X,X
LIKEMEM  DS    A
LIKELN2  DS    H
LIKEFLG2 DS    X,X
LIKEPSWD DS    A
LIKELN3  DS    H
LIKEFLG3 DS    X,X
* PDE FOR XML/NONXML (AIN'T ONE!)
         IKJEFFGF GFDSECT=YES
L_EFF    EQU   *-GFDSECTD
         EJECT
         DCBD  DSORG=PS
         IEFZB4D2
         IEFZB4D0
L_S99RB  EQU   S99RBEND-S99RB
         IEFSJDKY
         IKJEFFDF DFDSECT=YES      DAIRFAIL PARM LIST MAP
         BPXYOPNF
         BPXYMODE
         BPXYFTYP
