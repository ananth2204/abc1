RACSEQ TITLE 'RACSEQ - USE R_ADMIN TO EXTRACT RACF PROFILE'
***********************************************************************
***********************************************************************
***                                                                 ***
***  MODULE - RACSEQ                                                ***
***                                                                 ***
***      This TSO command invokes the extract function of R_admin   ***
***      (IRRSEQ00) and displays every profile field to the         ***
***      display using PUTLINE.                                     ***
***                                                                 ***
***      It is invoked from the TSO command line like:              ***
***        RACSEQ CLASS(classname) PROFILE(profilename)             ***
***                                                                 ***
***      The supported classes are USER, GROUP, and CONNECT.        ***
***      If not specified, CLASS defaults to USER. All values for   ***
***      CLASS will be folded to upper case by TSO parse services.  ***
***                                                                 ***
***      The PROFILE field is a user ID or group name for USER      ***
***      and GROUP, respectively. For CONNECT, it is the user ID    ***
***      followed by a period followed by the group name. E.G.      ***
***       IBMUSER.SYS1                                              ***
***                                                                 ***
***      NOTE: "profilename" is case-sensitive! This means you can  ***
***            display lower case user IDs such as irrcerta, but    ***
***            it also means you must remember to upper-case the    ***
***            user ID for most cases.  If you forget, you will     ***
***            receive a 4/4/4 return code combination!             ***
***                                                                 ***
***  INPUT: R1 points to the address of the CPPL                    ***
***                                                                 ***
***  RETURN CODES:                                                  ***
***     0 - This sample always returns 0 unless altered.            ***
***  non0 - Parse rc or SAF rc from R_admin                         ***
***                                                                 ***
***  Register usage:                                                ***
***   R11 - Autodata base register                                  ***
***   R12 - Base register                                           ***
***   R13 - Savearea address                                        ***
***  Further register usage is documented in the code below.        ***
***                                                                 ***
***********************************************************************
***********************************************************************
         EJECT
***********************************************************************
***********************************************************************
***                                                                 ***
***      COPYRIGHT IBM CORPORATION, 2006                            ***
***                                                                 ***
***      THIS CODE HAS NOT BEEN SUBMITTED TO ANY FORMAL IBM TEST    ***
***      AND IS DISTRIBUTED ON AN "AS IS" BASIS WITHOUT ANY         ***
***      WARRANTY EITHER EXPRESS OR IMPLIED. THE IMPLEMENTATION     ***
***      OF ANY OF THE TECHNIQUES DESCRIBED OR USED HEREIN IS A     ***
***      CUSTOMER RESPONSIBILITY AND DEPENDS ON THE CUSTOMER'S      ***
***      OPERATIONAL ENVIRONMENT. WHILE EACH ITEM MAY HAVE BEEN     ***
***      REVIEWED FOR ACCURACY IN A SPECIFIC SITUATION AND MAY      ***
***      RUN IN A SPECIFIC ENVIRONMENT, THERE IS NO GUARANTEE       ***
***      THAT THE SAME OR SIMILAR RESULTS WILL BE OBTAINED ELSE-    ***
***      WHERE. CUSTOMERS ATTEMPTING TO ADAPT THESE TECHNIQUES TO   ***
***      THEIR OWN ENVIRONMENTS DO SO AT THEIR OWN RISK.            ***
***                                                                 ***
***********************************************************************
***********************************************************************
         EJECT
RACSEQ   CSECT ,                   An R_admin sample routine
RACSEQ   AMODE 31
RACSEQ   RMODE 31
RACSEQ   CSECT
         SAVE  (14,12),,RACSEQ-&SYSDATE-&SYSTIME
         LR    R12,R15             program addressability
         USING RACSEQ,R12          set base register
         LR    R10,R1              save input CPPL address
*
* Get dynamic storage
*
         L     R0,DYNSIZE          dynamic area size to R0
         GETMAIN RU,LV=(0)         getmain dynamic area
*              LV=(0),SP=229
         LR    R11,R1              dynamic area addressability
         USING DATD,R11            base
         ST    R13,SAVEAREA+4      save caller's savearea address
         ST    R11,8(R13)          save our savearea address
         LR    R13,R11             our savearea address to R13
         ST    R10,CPPLPTR         save saved input CPPL address
         EJECT
*
* Initialize PUTLINE Output Line Descriptor (OLD) segment pointers
* for use throughout this program. The pointers to the segments (i.e.
* message line and inserts) remain constant; each message will set the
* number of segments and the actual length/data.
* Register usage
*  R2 = CPPLUPT for PUTLINE
*  R3 = CPPLECT for PUTLINE
*  R5 = Disposable work reg
*  R10 = Disposable work reg
*
         LA    R10,SEG1LEN
         ST    R10,OLDSEGA1
         LA    R10,SEG2LEN
         ST    R10,OLDSEGA2
         LA    R10,SEG3LEN
         ST    R10,OLDSEGA3
         LA    R10,SEG4LEN
         ST    R10,OLDSEGA4
*
* Initialize parse stuff and parse the input command image.
*
         L     R1,CPPLPTR           Get address of CPPL
         USING CPPL,R1              And establish addressability
         LA    R6,DYNPPL            GET ADDRESS OF PPL
         USING PPL,R6               AND ESTABLISH ADDRESSABILITY
         MVC   PPLUPT,CPPLUPT       PUT IN THE UPT ADDRESS FROM CPPL
         L     R2,CPPLUPT           And keep it around in R2
         MVC   PPLECT,CPPLECT       PUT IN THE ECT ADDRESS FROM CPPL
         L     R3,CPPLECT           And keep it around in R3
         MVC   PPLCBUF,CPPLCBUF     PUT IN THE COMMAND BUFFER ADDRESS
         L     R5,=A(RACPDE)        Get address of parse macros (PCL)
         ST    R5,PPLPCL            STORE IT IN THE PPL
         LA    R5,PDLPTR            Get address of parse result anchor
         ST    R5,PPLANS            STORE IT IN THE PPL
         CALLTSSR EP=IKJPARS,MF=(E,PPL)   INVOKE PARSE
         LTR   R15,R15              IF PARSE RETURN CODE IS ZERO
         BZ    GETANS               Go process results
         DROP  R1
*
* Unexpected parse error.  Print return code and bail.
*
         ST    R15,SAFRC            Store rc
         MVC   OLDNUM,=A(2)         One message segment
         LA    R10,L'MSG9+4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA,MSG9
         LA    R10,6                2-digit rc + header
         STH   R10,SEG2LEN
         LA    R10,L'MSG9           Insert position of rc (eol)
         STH   R10,SEG2OFF
         CVD   R15,PACKDEC1         Convert 2 digits of parse rc
         LA    R10,PACKDEC1
         UNPK  0(2,R10),6(2,R10)
         OI    1(R10),X'F0'         Fix the sign nibble
         MVC   SEG2DATA(2),PACKDEC1 Move 2-char parse rc
         XC    PUTECB,PUTECB        Clear ECB
         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *
               OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)
         B     GETOUT               Get out of Dodge
*
* Get the class name and profile name from parse output. The class
* name will determine the R_Admin function code to use.
*
GETANS   DS    0H
         L     R1,PPLANS            Get the PDL anchor address
         L     R1,0(R1)             Get the PDL address itself
         ST    R1,PDLPTR            Save it for later
         DROP  R6
         USING SEQPDL,R1            Get addressability to PDL
         EJECT
*
* Initialize IRRSEQ00 parameters
*
         MVI   FUNCODE,ADMN_XTR_USER Assume USER class for now
         OC    PDLCLASS,PDLCLASS    CLASS specified?
         BZ    MOREPRMS             No, default to USER
         L     R10,CLSPTR           Get class name ptr
         CLC   GRPCLS(5),0(R10)     GROUP class?
         BNE   CHKCON               Nope
         MVI   FUNCODE,ADMN_XTR_GROUP Yup
         B     MOREPRMS             Continue with R_admin parms
CHKCON   DS    0H
         CLC   CONCLS(7),0(R10)     CONNECT class?
         BNE   CHKUSR               Nope
         MVI   FUNCODE,ADMN_XTR_CONNECT Yup
         B     MOREPRMS             Continue with R_admin parms
CHKUSR   DS    0H
         CLC   USERCLS(4),0(R10)    USER class?
         BE    MOREPRMS             Yup
         DROP  R1
*
*        Error - unsupported class. Issue a message.
*
         MVC   OLDNUM,=A(1)         One message segment
         LA    R10,L'MSG7+4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA,MSG7
         XC    PUTECB,PUTECB        Clear ECB
         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *
               OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)
         B     GETOUT               Get out of dodge
         USING SEQPDL,R1            Get addressability to PDL
MOREPRMS DS    0H
         XC    ALET,ALET            Use zero ALET
         XC    SAFRC,SAFRC          Initialize return/reason codes
         XC    RACFRC,RACFRC
         XC    RACFRS,RACFRS
         XC    USERLEN,USERLEN      Not supplying "run-as" user
         XC    ACEE,ACEE            Not supplying "run-as" ACEE
         MVI   SUBPOOL,127          Use subpool 127
         XC    OUTMSG,OUTMSG        Clear output message pointer
*
* In the Parm_list area, fill in the version and the user length,
* and copy the input user ID to the contiguous storage after the
* Parm_list storage.
*
         LA    R6,RADPLIST
         USING ADMN_PROF_MAP,R6
         MVI   ADMN_PROF_VERSION,0
         OC    PDLPROF,PDLPROF      PROFILE specified?
         BNZ   GETPROF
*
*        Error.  No profile.  Issue syntax message.
*
         MVC   OLDNUM,=A(1)         One message segment
         LA    R10,L'MSG8+4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA,MSG8
         DROP  R1
         XC    PUTECB,PUTECB        Clear ECB
         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *
               OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)
         B     GETOUT               Get out of Dodge
GETPROF  DS    0H
         USING SEQPDL,R1            Get addressability to PDL
         LH    R8,PROFLEN           Get profile length
         ST    R8,ADMN_PROF_NAMELEN Save length in plist header
         L     R9,PROFPTR
* The following instruction moves too much storage, but the extra will
* be ignored because we just set the length accurately. But, this is
* lazy and an execute instruction should be used.
         MVC   EXTPROF,0(R9)        Move profile name to R_admin plist
         DROP  R1
         DROP  R6
         EJECT
*
* Initialize IRRSEQ00 call parameter list.  That is, a list of
* addresses to the individual parameters set up above.
*
         LA    R1,WORKAREA
         ST    R1,WORKAREA@
         LA    R1,ALET
         ST    R1,ALET1@
         ST    R1,ALET2@
         ST    R1,ALET3@
         LA    R1,SAFRC
         ST    R1,SAFRC@
         LA    R1,RACFRC
         ST    R1,RACFRC@
         LA    R1,RACFRS
         ST    R1,RACFRS@
         LA    R1,FUNCODE
         ST    R1,FUNCODE@
         LA    R1,RADPLIST
         ST    R1,RADPLIST@
         LA    R1,USER
         ST    R1,USER@
         LA    R1,ACEE
         ST    R1,ACEE@
         LA    R1,SUBPOOL
         ST    R1,SUBPOOL@
         LA    R1,OUTMSG
         ST    R1,OUTMSG@
         OC    OUTMSG@,=X'80000000'       Turn on VL bit in last parm
*
* Call R_admin.  We've manually built the plist which would correspond
* to the following CALL statement (continuation characters omitted).
*
*        CALL  IRRSEQ00,
*              (WORKAREA,
*              ALET,SAFRC,
*              ALET,RACFRC,
*              ALET,RACFRS,
*              FUNCODE,
*              RADPLIST,
*              0,0,              Not passing "run-as" user or ACEE
*              SUBPOOL,
*              OUTMSG),VL
         LA    R1,WORKAREA@      Get list of addrs in R1
         L     R15,=V(IRRSEQ00)
         BALR  R14,R15
*
* Test return code and issue an error message if non-zero
*
         ICM   R5,B'1111',SAFRC     Get SAF return code
         BZ    GOODSEQ
*
* Convert the return/reason codes for message inserts
*
         CVD   R5,PACKDEC1          Convert binary to packed decimal
         LA    R5,PACKDEC1          Going to use 8 byte field for both
         UNPK  0(2,R5),6(2,R5)      Then to zoned decimal
         OI    1(R5),X'F0'          Fix the sign nibble
         L     R5,RACFRC            Convert the RACF rc too
         CVD   R5,PACKDEC2
         LA    R5,PACKDEC2
         UNPK  0(2,R5),6(2,R5)
         OI    1(R5),X'F0'
         L     R5,RACFRS            Convert the RACF reason code too
         CVD   R5,PACKDEC3
         LA    R5,PACKDEC3
         UNPK  0(2,R5),6(2,R5)
         OI    1(R5),X'F0'
         MVC   OLDNUM,=A(4)         Four message segments
         LA    R5,L'MSG6+4
         STH   R5,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA,MSG6
         LA    R5,6                 All inserts will be 2 chars + hdr
         STH   R5,SEG2LEN
         STH   R5,SEG3LEN
         STH   R5,SEG4LEN
         LA    R5,22                Insert position of SAF rc
         STH   R5,SEG2OFF
         MVC   SEG2DATA(2),PACKDEC1 Move 2-char SAF rc
         LA    R5,32                Insert position of RACF rc
         STH   R5,SEG3OFF
         MVC   SEG3DATA(2),PACKDEC2 Move 2-char RACF rc
         LA    R5,L'MSG6            Insert position of RACF rc (eol)
         STH   R5,SEG4OFF
         MVC   SEG4DATA(2),PACKDEC3 Move 2-char RACF rc
         XC    PUTECB,PUTECB        Clear ECB
         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *
               OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)
         B     GETOUT
         EJECT
*
* R_admin worked! We'll start the command output by simply echoing
* the class and profile name, just to reassure the user. Also say
* how many segments there are.
*
GOODSEQ  DS    0H                   Issue warm and fuzzy message
         MVC   OLDNUM,=A(4)         Four message segments
         LA    R5,L'MSG1+4
         STH   R5,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA,MSG1
         L     R1,PDLPTR
         USING SEQPDL,R1
         LH    R5,PROFLEN           Get profile name length
         LA    R5,4(R5)             Add 4 for header (length/offset)
         STH   R5,SEG2LEN
         LA    R5,20                Offset of first insert
         STH   R5,SEG2OFF
         L     R14,PROFPTR          Source: profile pointer from parse
         LA    R15,SEG2DATA         Target: segment data
         LH    R5,SEG2LEN           Get profile length back
         BCTR  R5,0                 Decrement for execute
         EX    R5,MOVESTR           Move profile name to msg data
*
         LA    R5,30                Offset of second insert
         STH   R5,SEG3OFF
         ICM   R9,B'1111',CLSPTR    Get Class pointer from PDL
         BZ    USEUSER              Not specified, default to USER
         LH    R5,CLSLEN            Get class name length
         LA    R5,4(R5)             Add 4 for header (len/offset)
         STH   R5,SEG3LEN
         MVC   SEG3DATA,0(R9)       Move class name to msg data
         B     SEGNUMS              Proceed
         DROP  R1
USEUSER  DS    0H                   Display USER class
         LA    R5,8                 4 for "USER" + header
         STH   R5,SEG3LEN
         MVC   SEG3DATA(4),=C'USER' Move USER class name to msg data
SEGNUMS  DS    0H                   Insert number of segments
         LA    R5,6                 Max 2-digit #segments
         STH   R5,SEG4LEN
         LA    R5,L'MSG1            Offset of third insert (eol)
         STH   R5,SEG4OFF
         USING ADMN_PROF_MAP,R1
         L     R1,OUTMSG            Get output address in R1
         L     R5,ADMN_PROF_NUMSEG  Number of segment descriptors
         CVD   R5,PACKDEC1          Convert binary to packed decimal
         LA    R5,PACKDEC1          Going to use 8 byte field for both
         UNPK  0(2,R5),6(2,R5)      Then to zoned decimal
         OI    1(R5),X'F0'          Fix the sign nibble
         MVC   SEG4DATA(2),PACKDEC1 Move 2-char number of segments
         DROP  R1
         XC    PUTECB,PUTECB        Clear ECB
         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *
               OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)
         EJECT
***********************************************************************
*
* Now process the output.  For each segment descriptor, print a message
* indicating the segment name.  For each of its field descriptors,
* print the field name and its data.
*  - For boolean field, print TRUE or FALSE
*  - For repeat fields, print each of its constituent fields
*
* Register usage
*  R1 = R_admin output buffer (OUTMSG)
*  R2 = Number of segment descriptors to process
*  R3 = Address of current segment descriptor
*  R4 = Number of field descriptors to process
*  R5 = Address of current field descriptor
*
***********************************************************************
         USING ADMN_PROF_MAP,R1
         L     R1,OUTMSG             Get output address in R1
         L     R2,ADMN_PROF_NUMSEG   Number of segment descriptors
         LA    R3,ADMN_PROF_PROFNAME Get addr of profile name
         A     R3,ADMN_PROF_NAMELEN  Add length of profile name to get *
                                     addr of 1st segment descriptor
         USING ADMN_PROF_SEGDESC,R3  Basing for segment descriptor
*
         L     R5,ADMN_PROF_FIELDOFFSET Get offset to 1st field desc.
         AR    R5,R1                 Add to base to get address
         USING ADMN_PROF_FIELDDESC,R5 Basing for field descriptor
*
DOSEGS   DS    0H                    For each segment descriptor
         L     R4,ADMN_PROF_NUMFIELDS Number of field descriptors for  *
                                     this segment
         BAL   R14,SEGMSG            Issue segment message
*
DOFIELDS DS    0H                    For each field descriptor
         XR    R9,R9                 Clear R9 for insert
         ICM   R9,B'0011',ADMN_PROF_FIELDTYPE   Get type of field
         L     R8,=A(ADMN_PROF_RPTHDR) Is it a repeat field header?
         CR    R9,R8
         BE    REPEAT                Yes, repeat field
* Boolean fields and normal character fields land here. Go print them.
         BAL   R14,FLDMSG            Display field name and value
         B     NEXTFLD               Get next field
REPEAT   DS    0H
         BAL   R15,DOREPEAT          Go process repeat field. R5 will  *
                                     point to next FD on return
         B     NEXTFLD2              Continue with main fields
*
* Set basing for next field descriptor. Decrement count of fields
* to see if we are finished.
*
NEXTFLD  DS    0H
         LA    R5,ADMN_PROF_NEXTFIELD Get next FD address
NEXTFLD2 DS    0H
         BCT   R4,DOFIELDS           Decrement number of fields
         B     NEXTSEG               Done with fields. Check next seg
*
* Set basing for next segment descriptor. Decrement count of segments
* to see if we are finished. Note that R5 is already pointing to the
* first field descriptor in the next segment.
*
NEXTSEG  DS    0H
         LA    R3,ADMN_PROF_NEXTSEG  Get next SD address
         BCT   R2,DOSEGS             Decrement number of segments
         B     FREEOUT               Done with segments, finish up
         EJECT
*
* free the R_admin output storage
*
FREEOUT  DS    0H
         L     R0,ADMN_PROF_OUTLEN Output area size to R0
         FREEMAIN RU,SP=127,       freemain                            *
               LV=(0),             dynamic                             *
               A=(1)               area
         DROP  R1
*
* free the parse PDL and our dynamic storage and return...
*
GETOUT   DS    0H
         LA    R1,PDLPTR           Point to the PDL pointer
         IKJRLSA (R1)              Free storage that parse allocated
         L     R0,DYNSIZE          Dynamic area size to R0
         L     R13,SAVEAREA+4      Restore R13
         LR    R1,R11              Dynamic data address to R1
         FREEMAIN RU,LV=(0),A=(1)  Freemain dynamic area
         L     R15,SAFRC           Make SAF rc overall rc
         RETURN (14,12),T,RC=(15)  Restore registers and return
MOVESTR  MVC   0(*-*,R15),0(R14)
         EJECT
*---------------------------------------------------------------------*
* DOREPEAT:                                                           *
*                                                                     *
* For repeat fields, cycle through each subfield for each occurrence. *
*                                                                     *
* Register input:  R5  = address of repeat field header descriptor    *
*                  R14 = return address                               *
*                                                                     *
* Register output: R5  = address of the next field descriptor after   *
*                        the entire repeat field just processed       *
*                                                                     *
* Register usage:                                                     *
*  R6 - Number of occurrences of repeat field                         *
*  R7 - Number of subfields within each occurrence                    *
*  R8 - Address of subfield descriptor                                *
*  R9 - Work register                                                 *
*---------------------------------------------------------------------*
DOREPEAT DS    0H
         BAL   R14,RPTMSG            Go print header field
         L     R6,ADMN_PROF_RPTNUM   Number of occurrences
         LA    R8,ADMN_PROF_NEXTFIELD Get next FD address
RPTOCC   DS    0H                    Process occurrence
         L     R7,ADMN_PROF_FIELDDIM Number of subfields per occurrence
         DROP  R5
RPTSFLD  DS    0H                    Process subfield
         ST    R5,SAVEFD             Save header field descriptor
         LR    R5,R8                 Get subfield desc in R5 for FLDMSG
         BAL   R14,FLDMSG            Print subfield name and value
         L     R5,SAVEFD             Get header FD back
         USING ADMN_PROF_FIELDDESC,R8 Basing for subfield descriptor
         LA    R8,ADMN_PROF_NEXTFIELD Get next FD address
         BCT   R7,RPTSFLD            Loop if subfields remaining
         BAL   R14,SEPMSG            Print separator
         BCT   R6,RPTOCC             Loop if occurrences remaining
         LR    R5,R8                 All done. Set R5 to next FD addr
         BR    R15                   Return to caller
         DROP  R8
*---------------------------------------------------------------------*
* SEGMSG:                                                             *
*                                                                     *
* At the beginning of each segment, issue a message identifying the   *
* segment name.                                                       *
*                                                                     *
* Register input:  R3  = address of segment descriptor                *
*                  R4  = number of fields in this segment             *
*                  R14 = return address                               *
*                                                                     *
* Register output:                                                    *
*                                                                     *
* Register usage:                                                     *
*---------------------------------------------------------------------*
SEGMSG   DS    0H
         STM   14,12,REGSAVE        Save caller's regs
         MVC   OLDNUM,=A(3)         Three message segments
         LA    R10,L'MSG2+4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA,MSG2
         LA    R10,8+4              Get segment name length + header
         STH   R10,SEG2LEN
         LA    R10,10               Offset of 1st insert
         STH   R10,SEG2OFF
         MVC   SEG2DATA(8),ADMN_PROF_SEGNAME  Move in segment name
         LA    R2,6                 Max 2-digit number of fields
         STH   R2,SEG3LEN
         LA    R2,L'MSG2            Insert position of insert (eol)
         STH   R2,SEG3OFF
         CVD   R4,PACKDEC1          Convert binary to packed decimal
         LA    R2,PACKDEC1          Going to use 8 byte field for both
         UNPK  0(2,R2),6(2,R2)      Then to zoned decimal
         OI    1(R2),X'F0'          Fix the sign nibble
         MVC   SEG3DATA(2),PACKDEC1 Move 2-char number of fields
         L     R1,CPPLPTR           Get address of CPPL
         USING CPPL,R1              And establish addressability
         L     R2,CPPLUPT
         L     R3,CPPLECT
         XC    PUTECB,PUTECB        Clear ECB
         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *
               OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)
         LM    14,12,REGSAVE        Restore caller's regs
         BR    R14                  Return to caller
         DROP  R1
         EJECT
*---------------------------------------------------------------------*
* RPTMSG:                                                             *
*                                                                     *
* At the beginning of each repeat field, print a message identifying  *
* the repeat field header name. There is no data to print.            *
*                                                                     *
* Register input:  R5  = address of field descriptor                  *
*                  R14 = return address                               *
*                                                                     *
* Register output:                                                    *
*                                                                     *
* Register usage:                                                     *
*                                                                     *
*---------------------------------------------------------------------*
RPTMSG   DS    0H
         STM   14,12,REGSAVE        Save caller's regs
         MVC   OLDNUM,=A(4)         Four message segments
         LA    R10,L'MSG3+4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA,MSG3
         LA    R10,8+4              Get field name length + header
         STH   R10,SEG2LEN
         LA    R10,16               Offset of 1st insert
         STH   R10,SEG2OFF
         USING ADMN_PROF_FIELDDESC,R5 Basing for field descriptor
         MVC   SEG2DATA(8),ADMN_PROF_FIELDNAME  Move in field name
*
         LA    R2,6                 Max 2-digit #subfields
         STH   R2,SEG3LEN
         LA    R2,27                Offset of 2nd insert
         STH   R2,SEG3OFF
         L     R4,ADMN_PROF_FIELDDIM Number of subfields per occurrence
         CVD   R4,PACKDEC1          Convert binary to packed decimal
         LA    R2,PACKDEC1          Going to use 8 byte field for both
         UNPK  0(2,R2),6(2,R2)      Then to zoned decimal
         OI    1(R2),X'F0'          Fix the sign nibble
         MVC   SEG3DATA(2),PACKDEC1 Move 2-char number of subfields
*
         LA    R2,8                 Max 4-digit #occurrences
         STH   R2,SEG4LEN
         LA    R2,L'MSG3            Offset of 3rd insert (end of line)
         STH   R2,SEG4OFF
         L     R4,ADMN_PROF_RPTNUM  Number of occurrences
         CVD   R4,PACKDEC2          Convert binary to packed decimal
         LA    R2,PACKDEC2          Point to source
         UNPK  0(4,R2),5(3,R2)      Then to zoned decimal
         OI    3(R2),X'F0'          Fix the sign nibble
         MVC   SEG4DATA(4),PACKDEC2 Move 4-char number of occurrences
*
         DROP  R5
         L     R1,CPPLPTR           Get address of CPPL
         USING CPPL,R1              And establish addressability
         L     R2,CPPLUPT
         L     R3,CPPLECT
         XC    PUTECB,PUTECB        Clear ECB
         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *
               OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)
         LM    14,12,REGSAVE        Restore caller's regs
         BR    R14                  Return to caller
         DROP  R1
         EJECT
*---------------------------------------------------------------------*
* FLDMSG:                                                             *
*                                                                     *
* For each field, display the field name and its value.               *
*                                                                     *
* Register input:  R5  = address of field descriptor                  *
*                  R14 = return address                               *
*                                                                     *
* Register output:                                                    *
*                                                                     *
* Register usage:                                                     *
*---------------------------------------------------------------------*
FLDMSG   DS    0H
         USING ADMN_PROF_FIELDDESC,R5 Basing for field descriptor
         STM   14,12,REGSAVE        Save caller's regs
         MVC   OLDNUM,=A(3)         Three message segments
         XC    SEG1OFF,SEG1OFF      Segment 1 offset always 0
         XR    R9,R9                Clear R9 for insert
         ICM   R9,B'0011',ADMN_PROF_FIELDTYPE   Get type of field
         L     R8,=A(ADMN_PROF_REPEAT)
         NR    R9,R8                Piece of repeat field?
         BZ    NOTRPT               Nope
         LA    R10,L'MSG4RPT+4      Use extra indentation for repeat
         STH   R10,SEG1LEN
         MVC   SEG1DATA,MSG4RPT
         MVC   SEG2OFF,=AL2(5)      Indent field name 5 spaces
         LA    R10,L'MSG4RPT        Offset of 3rd insert (end of line)
         STH   R10,SEG3OFF
         B     NXTMSEG
NOTRPT   DS    0H
         LA    R10,L'MSG4+4
         STH   R10,SEG1LEN
         MVC   SEG1DATA,MSG4
         MVC   SEG2OFF,=AL2(3)      Indent field name 3 spaces
         LA    R10,L'MSG4           Offset of 3rd insert (end of line)
         STH   R10,SEG3OFF
NXTMSEG  DS    0H
         LA    R10,8+4              Get field name length + header
         STH   R10,SEG2LEN
         MVC   SEG2DATA(8),ADMN_PROF_FIELDNAME  Move in field name
*
         ICM   R9,B'0011',ADMN_PROF_FIELDTYPE   Reload field type
         L     R8,=A(ADMN_PROF_BOOLEAN)
         NR    R9,R8                      Is field boolean?
         BZ    NOTBOOL
         L     R9,ADMN_PROF_FIELDFLAG     Get flag word
         L     R8,=A(ADMN_PROF_VALUE)     Get equate for true/false
         SLL   R8,16                      Move halfword to fullword
         NR    R9,R8                      Is boolean value bit on?
         BZ    NOTTRUE
         LA    R10,4+4              Length("TRUE") + header
         STH   R10,SEG3LEN
         MVC   SEG3DATA,=C'TRUE'
         B     DOFPUT
NOTTRUE  DS    0H
         LA    R10,5+4              Length("FALSE") + header
         STH   R10,SEG3LEN
         MVC   SEG3DATA,=C'FALSE'
         B     DOFPUT
NOTBOOL  DS    0H
         L     R10,ADMN_PROF_FIELDLEN     Get length of field data
         C     R10,=A(L'SEG3DATA)         Is value > buffer length?
         BNH   NOPROB                     No
         LA    R10,L'SEG3DATA             Lazy again, just truncate
NOPROB   DS    0H
         ST    R10,SAVEDLEN               Save it for later
         LA    R10,4(R10)                 Add 4 for header
         STH   R10,SEG3LEN                Store it
         L     R14,ADMN_PROF_DATA_OFFSET  Get offset of field data
         A     R14,OUTMSG                 Add to start of output block
         LA    R15,SEG3DATA               Target: msg segment 3 data
         L     R10,SAVEDLEN               Reload field length
         BCTR  R10,0                Decrement length for move
         EX    R10,MOVESTR          Move field data
DOFPUT   DS    0H
         L     R1,CPPLPTR           Get address of CPPL
         USING CPPL,R1              And establish addressability
         L     R2,CPPLUPT
         L     R3,CPPLECT
         XC    PUTECB,PUTECB        Clear ECB
         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *
               OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)
         LM    14,12,REGSAVE        Restore caller's regs
         BR    R14                  Return to caller
         DROP  R1
         EJECT
*---------------------------------------------------------------------*
* SEPMSG:                                                             *
*                                                                     *
* Print a separator line between occurrences of a repeat field.       *
*                                                                     *
* Register input:  R14 = return address                               *
*                                                                     *
* Register output:                                                    *
*                                                                     *
* Register usage:                                                     *
*                                                                     *
*---------------------------------------------------------------------*
SEPMSG   DS    0H
         STM   14,12,REGSAVE        Save caller's regs
         MVC   OLDNUM,=A(1)         One message segment
         LA    R10,L'MSG5+4
         STH   R10,SEG1LEN
         XC    SEG1OFF,SEG1OFF
         MVC   SEG1DATA,MSG5
         L     R1,CPPLPTR           Get address of CPPL
         USING CPPL,R1              And establish addressability
         L     R2,CPPLUPT
         L     R3,CPPLECT
         XC    PUTECB,PUTECB        Clear ECB
         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *
               OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)
         LM    14,12,REGSAVE        Restore caller's regs
         BR    R14                  Return to caller
         DROP  R1
         EJECT
*
***********************************************************************
*
*
* PARSE macros used to describe the command operands
*
*
***********************************************************************
RACPDE   IKJPARM
KWCLASS  IKJKEYWD
         IKJNAME 'CLASS',SUBFLD=SEQCLASS
KWPROF   IKJKEYWD
         IKJNAME 'PROFILE',SUBFLD=SEQPROF
SEQCLASS IKJSUBF
SFCLASS  IKJIDENT 'CLASS',MAXLNTH=8,FIRST=ANY,OTHER=ANY,               *
               DEFAULT='USER',                                         *
               HELP=('RACF class name from which to extract')
*
SEQPROF  IKJSUBF
SFPROF   IKJIDENT 'PROFILE',MAXLNTH=255,FIRST=ANY,OTHER=ANY,           *
               HELP=('RACF profile name to extract'),ASIS,             *
               PROMPT='Profile name. Use <user>.<group> for CONNECT'
         IKJENDP
         EJECT
*
* static data
*
         DS    0D
DYNSIZE  DC    AL4(SIZEDATD)       dynamic area size
USERCLS  DC    CL4'USER'           USER class
GRPCLS   DC    CL5'GROUP'          GROUP class
CONCLS   DC    CL7'CONNECT'        CONNECT class
PUTSEQ   PUTLINE MF=L
*
* Define text of command output and error messages. There must be
* a leading blank so that we are immune to the TSO PROFILE MSGID
* setting.
*
MSG1     DC    CL41' Displaying profile  in class . Segments:'
MSG2     DC    CL18' Segment:  Fields:'
MSG3     DC    CL40'   Repeat field: Subfields: Occurrences:'
MSG4     DC    CL4'   :'             2 spaces||fieldname||:||value
MSG4RPT  DC    CL6'     :'           4 spaces||fieldname||:||value
MSG5     DC    CL50'     ---------------------------------------------'
MSG6     DC    CL46' R_admin Error! SAFrc  - RACFrc  - RACFreason '
MSG7     DC    CL26' Error! Unsupported class!'
MSG8     DC    CL45' Syntax: RACSEQ CLASS(class) PROFILE(profile)'
MSG9     DC    CL28' IKJPARS error! Return Code '
         DS    0D
         LTORG
*
* DSECT for this routine's dynamic area
*
DATD     DSECT
         DS    0D
SAVEAREA DS    18F                 register save area
REGSAVE  DS    16F                 internal subroutine save area
SAVEDLEN DS    F                   Temp variable for field data length
SAVEFD   DS    F                   Temp variable for @ field descriptor
DYNPPL   DS    CL(L_PPL)           PPL area
PPLPTR   DS    F                   Pointer to DYNPPL
CPPLPTR  DS    F                   Pointer to input CPPL
PDLPTR   DS    F                   Pointer to output PDL
MYECB    DS    F                   Command ECB
PUTIOPL  DS    4F                  E-form IOPL area for PUTLINE
PUTECB   DS    F                   ECB for PUTLINE
PACKDEC1 DS    CL8                 Output for CVD
PACKDEC2 DS    CL8                 Output for CVD
PACKDEC3 DS    CL8                 Output for CVD
*
* Output Line Descriptor (OLD) fields for PUTLINE
OLDNUM   DS    F                   Number of segments
OLDSEGA1 DS    F                   Pointer to first message segment
OLDSEGA2 DS    F                   Pointer to second message segment
OLDSEGA3 DS    F                   Pointer to third message segment
OLDSEGA4 DS    F                   Pointer to fourth message segment
SEG1LEN  DS    H                   Segment 1 length
SEG1OFF  DS    H                   Segment 1 offset
SEG1DATA DS    CL100               Segment 1 data
SEG2LEN  DS    H                   Segment 2 length
SEG2OFF  DS    H                   Segment 2 offset
SEG2DATA DS    CL100               Segment 2 data
SEG3LEN  DS    H                   Segment 3 length
SEG3OFF  DS    H                   Segment 3 offset
SEG3DATA DS    CL255               Segment 3 data
SEG4LEN  DS    H                   Segment 4 length
SEG4OFF  DS    H                   Segment 4 offset
SEG4DATA DS    CL255               Segment 4 data
*
* Parms for IRRSEQ00
*
WORKAREA DS    CL1024
ALET     DS    F
SAFRC    DS    F
RACFRC   DS    F
RACFRS   DS    F
FUNCODE  DS    AL1
USER     DS    0CL9
USERLEN  DS    AL1
USERID   DS    CL8
ACEE     DS    F
SUBPOOL  DS    AL1
OUTMSG   DS    F
RADPLIST DS    CL(ADMN_PROF_PROFNAME-ADMN_PROF_MAP) Plist header
EXTPROF  DS    CL17                                 Profile to extract
*
* Parm list for IRRSEQ00.  That is, a list of adresses to the actual
* Parameter data defined above.
*
WORKAREA@ DS    A
ALET1@    DS    A
SAFRC@    DS    A
ALET2@    DS    A
RACFRC@   DS    A
ALET3@    DS    A
RACFRS@   DS    A
FUNCODE@  DS    A
RADPLIST@ DS    A
USER@     DS    A
ACEE@     DS    A
SUBPOOL@  DS    A
OUTMSG@   DS    A
SIZEDATD EQU   *-DATD              length of DSECT
*
***********************************************************************
* The following DSECT maps the results of the parse.                  *
***********************************************************************
         EJECT
SEQPDL   DSECT
PDLHDR   DS    CL8
PDLCLASS DS    H
PDLPROF  DS    H
PDECLASS DS    0CL8
CLSPTR   DS    F
CLSLEN   DS    H
         DS    CL2
PDEPROF  DS    0CL8
PROFPTR  DS    F
PROFLEN  DS    H
         DS    CL2
*
* equates
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
*
* MAPPINGS
*
         IKJCPPL
         IKJPPL
L_PPL    EQU   *-PPL
         EJECT
         IRRPCOMP
         EJECT
         CVT   DSECT=YES        CVT MAPPING NEEDED FOR CALLTSSR MACRO
         END   RACSEQ
